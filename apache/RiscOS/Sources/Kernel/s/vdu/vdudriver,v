head	4.25;
access;
symbols
	Kernel-6_15:4.25
	Kernel-6_14:4.25
	Kernel-6_01-3:4.22
	Kernel-6_13:4.24
	Kernel-6_12:4.23
	Kernel-6_11:4.23
	Kernel-6_10:4.22
	Kernel-6_09:4.22
	Kernel-6_08-4_129_2_10:4.20.2.1
	Kernel-6_08-4_129_2_9:4.20.2.1
	Kernel-6_08:4.22
	Kernel-6_07:4.22
	Kernel-6_06:4.22
	Kernel-6_05-4_129_2_8:4.20.2.1
	Kernel-6_05:4.22
	Kernel-6_04:4.22
	Kernel-6_03:4.22
	Kernel-6_01-2:4.22
	Kernel-6_01-4_146_2_1:4.22
	Kernel-6_02:4.22
	Kernel-6_01-1:4.22
	Kernel-6_01:4.22
	Kernel-6_00:4.22
	Kernel-5_99:4.22
	Kernel-5_98:4.22
	Kernel-5_97-4_129_2_7:4.20.2.1
	Kernel-5_97:4.22
	Kernel-5_96:4.22
	Kernel-5_95:4.21
	Kernel-5_94:4.20
	Kernel-5_93:4.20
	Kernel-5_92:4.20
	Kernel-5_91:4.20
	Kernel-5_90:4.20
	Kernel-5_89-4_129_2_6:4.20
	Kernel-5_89:4.20
	Kernel-5_88-4_129_2_5:4.20
	Kernel-5_88-4_129_2_4:4.20
	Kernel-5_88:4.20
	Kernel-5_87:4.20
	Kernel-5_86-4_129_2_3:4.20
	Kernel-5_86-4_129_2_2:4.20
	Kernel-5_86-4_129_2_1:4.20
	Kernel-5_86:4.20
	SMP:4.20.0.2
	SMP_bp:4.20
	Kernel-5_85:4.20
	Kernel-5_54-1:4.17
	Kernel-5_84:4.20
	Kernel-5_83:4.20
	Kernel-5_82:4.20
	Kernel-5_81:4.19
	Kernel-5_80:4.19
	Kernel-5_79:4.19
	Kernel-5_78:4.19
	Kernel-5_77:4.19
	Kernel-5_76:4.19
	Kernel-5_75:4.19
	Kernel-5_74:4.19
	Kernel-5_73:4.17
	Kernel-5_72:4.17
	Kernel-5_71:4.17
	Kernel-5_70:4.17
	Kernel-5_69:4.17
	Kernel-5_68:4.17
	Kernel-5_67:4.17
	Kernel-5_66:4.17
	Kernel-5_65:4.17
	Kernel-5_64:4.17
	Kernel-5_63:4.17
	Kernel-5_62:4.17
	Kernel-5_61:4.17
	Kernel-5_60:4.17
	Kernel-5_59:4.17
	Kernel-5_58:4.17
	Kernel-5_57:4.17
	Kernel-5_56:4.17
	Kernel-5_55:4.17
	Kernel-5_54:4.17
	Kernel-5_53:4.17
	Kernel-5_52:4.17
	Kernel-5_51:4.17
	Kernel-5_50:4.16
	Kernel-5_49:4.15
	HAL_merge:4.12.2.32
	Kernel-5_48:4.14
	Kernel-5_35-4_79_2_327:4.12.2.32
	Kernel-5_35-4_79_2_326:4.12.2.32
	Kernel-5_35-4_79_2_325:4.12.2.32
	Kernel-5_35-4_79_2_324:4.12.2.32
	Kernel-5_35-4_79_2_323:4.12.2.32
	Kernel-5_35-4_79_2_322:4.12.2.32
	Kernel-5_35-4_79_2_321:4.12.2.32
	Kernel-5_35-4_79_2_320:4.12.2.32
	Kernel-5_35-4_79_2_319:4.12.2.32
	Kernel-5_35-4_79_2_318:4.12.2.32
	Kernel-5_35-4_79_2_317:4.12.2.32
	Kernel-5_35-4_79_2_316:4.12.2.32
	Kernel-5_35-4_79_2_315:4.12.2.32
	Kernel-5_35-4_79_2_314:4.12.2.32
	Kernel-5_35-4_79_2_313:4.12.2.32
	Kernel-5_35-4_79_2_312:4.12.2.32
	Kernel-5_35-4_79_2_311:4.12.2.32
	Kernel-5_35-4_79_2_310:4.12.2.32
	Kernel-5_35-4_79_2_309:4.12.2.32
	Kernel-5_35-4_79_2_308:4.12.2.32
	Kernel-5_35-4_79_2_307:4.12.2.32
	Kernel-5_35-4_79_2_306:4.12.2.32
	Kernel-5_35-4_79_2_305:4.12.2.32
	Kernel-5_35-4_79_2_304:4.12.2.32
	Kernel-5_35-4_79_2_303:4.12.2.32
	Kernel-5_35-4_79_2_302:4.12.2.32
	Kernel-5_35-4_79_2_301:4.12.2.32
	Kernel-5_35-4_79_2_300:4.12.2.32
	Kernel-5_35-4_79_2_299:4.12.2.32
	Kernel-5_35-4_79_2_298:4.12.2.32
	Kernel-5_35-4_79_2_297:4.12.2.32
	Kernel-5_35-4_79_2_296:4.12.2.32
	Kernel-5_35-4_79_2_295:4.12.2.32
	Kernel-5_35-4_79_2_294:4.12.2.32
	Kernel-5_35-4_79_2_293:4.12.2.32
	Kernel-5_35-4_79_2_292:4.12.2.32
	Kernel-5_35-4_79_2_291:4.12.2.32
	Kernel-5_35-4_79_2_290:4.12.2.32
	Kernel-5_35-4_79_2_289:4.12.2.32
	Kernel-5_35-4_79_2_288:4.12.2.32
	Kernel-5_35-4_79_2_287:4.12.2.32
	Kernel-5_35-4_79_2_286:4.12.2.32
	Kernel-5_35-4_79_2_285:4.12.2.32
	Kernel-5_35-4_79_2_284:4.12.2.32
	Kernel-5_35-4_79_2_283:4.12.2.31
	Kernel-5_35-4_79_2_282:4.12.2.31
	Kernel-5_35-4_79_2_281:4.12.2.31
	Kernel-5_35-4_79_2_280:4.12.2.31
	Kernel-5_35-4_79_2_279:4.12.2.31
	Kernel-5_35-4_79_2_278:4.12.2.31
	Kernel-5_35-4_79_2_277:4.12.2.31
	Kernel-5_35-4_79_2_276:4.12.2.31
	Kernel-5_35-4_79_2_275:4.12.2.31
	Kernel-5_35-4_79_2_274:4.12.2.31
	Kernel-5_35-4_79_2_273:4.12.2.31
	Kernel-5_35-4_79_2_272:4.12.2.31
	Kernel-5_35-4_79_2_271:4.12.2.31
	Kernel-5_35-4_79_2_270:4.12.2.31
	Kernel-5_35-4_79_2_269:4.12.2.31
	Kernel-5_35-4_79_2_268:4.12.2.30
	Kernel-5_35-4_79_2_267:4.12.2.30
	Kernel-5_35-4_79_2_266:4.12.2.30
	Kernel-5_35-4_79_2_265:4.12.2.30
	Kernel-5_35-4_79_2_264:4.12.2.30
	Kernel-5_35-4_79_2_263:4.12.2.30
	Kernel-5_35-4_79_2_262:4.12.2.30
	Kernel-5_35-4_79_2_261:4.12.2.30
	Kernel-5_35-4_79_2_260:4.12.2.30
	Kernel-5_35-4_79_2_259:4.12.2.30
	Kernel-5_35-4_79_2_258:4.12.2.30
	Kernel-5_35-4_79_2_257:4.12.2.30
	Kernel-5_35-4_79_2_256:4.12.2.30
	Kernel-5_35-4_79_2_255:4.12.2.30
	Kernel-5_35-4_79_2_254:4.12.2.30
	Kernel-5_35-4_79_2_253:4.12.2.30
	Kernel-5_35-4_79_2_252:4.12.2.30
	Kernel-5_35-4_79_2_251:4.12.2.30
	Kernel-5_35-4_79_2_250:4.12.2.30
	Kernel-5_35-4_79_2_249:4.12.2.30
	Kernel-5_35-4_79_2_248:4.12.2.30
	Kernel-5_35-4_79_2_247:4.12.2.30
	Kernel-5_35-4_79_2_246:4.12.2.30
	Kernel-5_35-4_79_2_245:4.12.2.30
	Kernel-5_35-4_79_2_244:4.12.2.30
	Kernel-5_35-4_79_2_243:4.12.2.30
	Kernel-5_35-4_79_2_242:4.12.2.30
	Kernel-5_35-4_79_2_241:4.12.2.30
	Kernel-5_35-4_79_2_240:4.12.2.30
	Kernel-5_35-4_79_2_239:4.12.2.30
	Kernel-5_35-4_79_2_238:4.12.2.30
	Kernel-5_35-4_79_2_237:4.12.2.30
	Kernel-5_35-4_79_2_236:4.12.2.30
	Kernel-5_35-4_79_2_235:4.12.2.30
	Kernel-5_35-4_79_2_234:4.12.2.30
	Kernel-5_35-4_79_2_233:4.12.2.30
	Kernel-5_35-4_79_2_232:4.12.2.30
	Kernel-5_35-4_79_2_231:4.12.2.30
	Kernel-5_35-4_79_2_230:4.12.2.30
	Kernel-5_35-4_79_2_229:4.12.2.30
	Kernel-5_35-4_79_2_228:4.12.2.30
	Kernel-5_35-4_79_2_227:4.12.2.30
	Kernel-5_35-4_79_2_226:4.12.2.30
	Kernel-5_35-4_79_2_225:4.12.2.30
	Kernel-5_35-4_79_2_224:4.12.2.30
	Kernel-5_35-4_79_2_223:4.12.2.30
	Kernel-5_35-4_79_2_222:4.12.2.30
	Kernel-5_35-4_79_2_221:4.12.2.30
	Kernel-5_35-4_79_2_220:4.12.2.30
	Kernel-5_35-4_79_2_219:4.12.2.29
	Kernel-5_35-4_79_2_218:4.12.2.29
	Kernel-5_35-4_79_2_217:4.12.2.29
	Kernel-5_35-4_79_2_216:4.12.2.29
	Kernel-5_35-4_79_2_215:4.12.2.28
	Kernel-5_35-4_79_2_214:4.12.2.28
	Kernel-5_35-4_79_2_213:4.12.2.28
	Kernel-5_35-4_79_2_212:4.12.2.27
	Kernel-5_35-4_79_2_211:4.12.2.27
	Kernel-5_35-4_79_2_210:4.12.2.27
	Kernel-5_35-4_79_2_209:4.12.2.27
	Kernel-5_35-4_79_2_208:4.12.2.27
	Kernel-5_35-4_79_2_207:4.12.2.27
	Kernel-5_35-4_79_2_206:4.12.2.26
	Kernel-5_35-4_79_2_205:4.12.2.25
	Kernel-5_35-4_79_2_204:4.12.2.25
	Kernel-5_35-4_79_2_203:4.12.2.25
	Kernel-5_35-4_79_2_202:4.12.2.24
	Kernel-5_35-4_79_2_201:4.12.2.24
	Kernel-5_35-4_79_2_200:4.12.2.24
	Kernel-5_35-4_79_2_199:4.12.2.24
	Kernel-5_35-4_79_2_198:4.12.2.24
	Kernel-5_35-4_79_2_197:4.12.2.24
	Kernel-5_35-4_79_2_196:4.12.2.24
	Kernel-5_35-4_79_2_195:4.12.2.24
	Kernel-5_35-4_79_2_194:4.12.2.24
	Kernel-5_35-4_79_2_193:4.12.2.23
	Kernel-5_35-4_79_2_192:4.12.2.23
	Kernel-5_35-4_79_2_191:4.12.2.23
	Kernel-5_35-4_79_2_190:4.12.2.23
	Kernel-5_35-4_79_2_189:4.12.2.23
	Kernel-5_35-4_79_2_188:4.12.2.23
	Kernel-5_35-4_79_2_187:4.12.2.23
	Kernel-5_35-4_79_2_186:4.12.2.23
	Kernel-5_35-4_79_2_185:4.12.2.22
	Kernel-5_35-4_79_2_184:4.12.2.22
	Kernel-5_35-4_79_2_183:4.12.2.22
	Kernel-5_35-4_79_2_182:4.12.2.22
	Kernel-5_35-4_79_2_181:4.12.2.22
	Kernel-5_35-4_79_2_180:4.12.2.22
	Kernel-5_35-4_79_2_179:4.12.2.22
	Kernel-5_35-4_79_2_178:4.12.2.22
	Kernel-5_35-4_79_2_177:4.12.2.22
	Kernel-5_35-4_79_2_176:4.12.2.22
	Kernel-5_35-4_79_2_175:4.12.2.22
	Kernel-5_35-4_79_2_174:4.12.2.22
	Kernel-5_35-4_79_2_173:4.12.2.21
	Kernel-5_35-4_79_2_172:4.12.2.21
	Kernel-5_35-4_79_2_171:4.12.2.21
	Kernel-5_35-4_79_2_170:4.12.2.21
	Kernel-5_35-4_79_2_169:4.12.2.21
	Kernel-5_35-4_79_2_168:4.12.2.21
	Kernel-5_35-4_79_2_167:4.12.2.21
	Kernel-5_35-4_79_2_166:4.12.2.21
	Kernel-5_35-4_79_2_165:4.12.2.21
	RPi_merge:4.12.2.18.2.6
	Kernel-5_35-4_79_2_147_2_23:4.12.2.18.2.6
	Kernel-5_35-4_79_2_147_2_22:4.12.2.18.2.5
	Kernel-5_35-4_79_2_147_2_21:4.12.2.18.2.4
	Kernel-5_35-4_79_2_147_2_20:4.12.2.18.2.4
	Kernel-5_35-4_79_2_147_2_19:4.12.2.18.2.3
	Kernel-5_35-4_79_2_147_2_18:4.12.2.18.2.3
	Kernel-5_35-4_79_2_164:4.12.2.20
	Kernel-5_35-4_79_2_163:4.12.2.20
	Kernel-5_35-4_79_2_147_2_17:4.12.2.18.2.2
	Kernel-5_35-4_79_2_147_2_16:4.12.2.18.2.2
	Kernel-5_35-4_79_2_147_2_15:4.12.2.18.2.2
	Kernel-5_35-4_79_2_162:4.12.2.20
	Kernel-5_35-4_79_2_161:4.12.2.20
	Kernel-5_35-4_79_2_147_2_14:4.12.2.18.2.2
	Kernel-5_35-4_79_2_147_2_13:4.12.2.18.2.2
	Kernel-5_35-4_79_2_160:4.12.2.20
	Kernel-5_35-4_79_2_159:4.12.2.20
	Kernel-5_35-4_79_2_158:4.12.2.19
	Kernel-5_35-4_79_2_157:4.12.2.19
	Kernel-5_35-4_79_2_156:4.12.2.19
	Kernel-5_35-4_79_2_147_2_12:4.12.2.18.2.2
	Kernel-5_35-4_79_2_147_2_11:4.12.2.18.2.2
	Kernel-5_35-4_79_2_155:4.12.2.19
	Kernel-5_35-4_79_2_147_2_10:4.12.2.18.2.2
	Kernel-5_35-4_79_2_154:4.12.2.19
	Kernel-5_35-4_79_2_153:4.12.2.19
	Kernel-5_35-4_79_2_147_2_9:4.12.2.18.2.2
	Kernel-5_35-4_79_2_152:4.12.2.19
	Kernel-5_35-4_79_2_151:4.12.2.19
	Kernel-5_35-4_79_2_147_2_8:4.12.2.18.2.2
	Kernel-5_35-4_79_2_147_2_7:4.12.2.18.2.2
	Kernel-5_35-4_79_2_150:4.12.2.19
	Kernel-5_35-4_79_2_147_2_6:4.12.2.18.2.2
	Kernel-5_35-4_79_2_147_2_5:4.12.2.18.2.2
	Kernel-5_35-4_79_2_149:4.12.2.18
	Kernel-5_35-4_79_2_147_2_4:4.12.2.18.2.1
	Kernel-5_35-4_79_2_147_2_3:4.12.2.18.2.1
	Kernel-5_35-4_79_2_148:4.12.2.18
	Kernel-5_35-4_79_2_147_2_2:4.12.2.18.2.1
	Kernel-5_35-4_79_2_147_2_1:4.12.2.18.2.1
	RPi:4.12.2.18.0.2
	RPi_bp:4.12.2.18
	Kernel-5_35-4_79_2_98_2_52_2_1:4.12.2.15.2.2.2.1
	alees_Kernel_dev:4.12.2.15.2.2.0.2
	alees_Kernel_dev_bp:4.12.2.15.2.2
	Kernel-5_35-4_79_2_147:4.12.2.18
	Kernel-5_35-4_79_2_146:4.12.2.18
	Kernel-5_35-4_79_2_145:4.12.2.18
	Kernel-5_35-4_79_2_144:4.12.2.18
	Kernel-5_35-4_79_2_143:4.12.2.18
	Kernel-5_35-4_79_2_142:4.12.2.18
	Kernel-5_35-4_79_2_141:4.12.2.18
	Kernel-5_35-4_79_2_140:4.12.2.18
	Kernel-5_35-4_79_2_139:4.12.2.18
	Kernel-5_35-4_79_2_138:4.12.2.18
	Kernel-5_35-4_79_2_137:4.12.2.17
	Kernel-5_35-4_79_2_136:4.12.2.17
	Kernel-5_35-4_79_2_135:4.12.2.17
	Kernel-5_35-4_79_2_134:4.12.2.17
	Kernel-5_35-4_79_2_133:4.12.2.17
	Kernel-5_35-4_79_2_132:4.12.2.17
	Kernel-5_35-4_79_2_131:4.12.2.17
	Kernel-5_35-4_79_2_130:4.12.2.17
	Kernel-5_35-4_79_2_129:4.12.2.17
	Kernel-5_35-4_79_2_128:4.12.2.17
	Kernel-5_35-4_79_2_127:4.12.2.17
	Kernel-5_35-4_79_2_126:4.12.2.17
	Kernel-5_35-4_79_2_125:4.12.2.17
	Kernel-5_35-4_79_2_124:4.12.2.17
	Kernel-5_35-4_79_2_123:4.12.2.16
	Cortex_merge:4.12.2.15.2.3
	Kernel-5_35-4_79_2_122:4.12.2.15
	Kernel-5_35-4_79_2_98_2_54:4.12.2.15.2.3
	Kernel-5_35-4_79_2_98_2_53:4.12.2.15.2.3
	Kernel-5_35-4_79_2_98_2_52:4.12.2.15.2.2
	Kernel-5_35-4_79_2_98_2_51:4.12.2.15.2.2
	Kernel-5_35-4_79_2_98_2_50:4.12.2.15.2.2
	Kernel-5_35-4_79_2_98_2_49:4.12.2.15.2.2
	Kernel-5_35-4_79_2_98_2_48:4.12.2.15.2.2
	Kernel-5_35-4_79_2_121:4.12.2.15
	Kernel-5_35-4_79_2_98_2_47:4.12.2.15.2.1
	Kernel-5_35-4_79_2_120:4.12.2.15
	Kernel-5_35-4_79_2_98_2_46:4.12.2.15.2.1
	Kernel-5_35-4_79_2_119:4.12.2.15
	Kernel-5_35-4_79_2_98_2_45:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_44:4.12.2.15.2.1
	Kernel-5_35-4_79_2_118:4.12.2.15
	Kernel-5_35-4_79_2_98_2_43:4.12.2.15.2.1
	Kernel-5_35-4_79_2_117:4.12.2.15
	Kernel-5_35-4_79_2_116:4.12.2.15
	Kernel-5_35-4_79_2_98_2_42:4.12.2.15.2.1
	Kernel-5_35-4_79_2_115:4.12.2.15
	Kernel-5_35-4_79_2_98_2_41:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_40:4.12.2.15.2.1
	Kernel-5_35-4_79_2_114:4.12.2.15
	Kernel-5_35-4_79_2_98_2_39:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_38:4.12.2.15.2.1
	Kernel-5_35-4_79_2_113:4.12.2.15
	Kernel-5_35-4_79_2_112:4.12.2.15
	Kernel-5_35-4_79_2_98_2_37:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_36:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_35:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_34:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_33:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_32:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_31:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_30:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_29:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_28:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_27:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_26:4.12.2.15.2.1
	Kernel-5_35-4_79_2_111:4.12.2.15
	Kernel-5_35-4_79_2_98_2_25:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_24:4.12.2.15.2.1
	Kernel-5_35-4_79_2_98_2_23:4.12.2.15
	Kernel-5_35-4_79_2_110:4.12.2.15
	Kernel-5_35-4_79_2_98_2_22:4.12.2.15
	Kernel-5_35-4_79_2_109:4.12.2.15
	Kernel-5_35-4_79_2_98_2_21:4.12.2.15
	Kernel-5_35-4_79_2_98_2_20:4.12.2.15
	Kernel-5_35-4_79_2_108:4.12.2.15
	Kernel-5_35-4_79_2_107:4.12.2.15
	Kernel-5_35-4_79_2_98_2_19:4.12.2.15
	Kernel-5_35-4_79_2_98_2_18:4.12.2.15
	Kernel-5_35-4_79_2_98_2_17:4.12.2.15
	Kernel-5_35-4_79_2_98_2_16:4.12.2.15
	Kernel-5_35-4_79_2_98_2_15:4.12.2.15
	Kernel-5_35-4_79_2_106:4.12.2.15
	Kernel-5_35-4_79_2_105:4.12.2.15
	Kernel-5_35-4_79_2_104:4.12.2.15
	Kernel-5_35-4_79_2_98_2_14:4.12.2.15
	Kernel-5_35-4_79_2_98_2_13:4.12.2.15
	Kernel-5_35-4_79_2_98_2_12:4.12.2.15
	Kernel-5_35-4_79_2_98_2_11:4.12.2.15
	Kernel-5_35-4_79_2_98_2_10:4.12.2.15
	Kernel-5_35-4_79_2_98_2_9:4.12.2.15
	Kernel-5_35-4_79_2_103:4.12.2.15
	Kernel-5_35-4_79_2_102:4.12.2.15
	Kernel-5_35-4_79_2_98_2_8:4.12.2.15
	Kernel-5_35-4_79_2_98_2_7:4.12.2.15
	Kernel-5_35-4_79_2_98_2_6:4.12.2.15
	Kernel-5_35-4_79_2_98_2_5:4.12.2.15
	Kernel-5_35-4_79_2_98_2_4:4.12.2.15
	Kernel-5_35-4_79_2_101:4.12.2.15
	Kernel-5_35-4_79_2_100:4.12.2.15
	Kernel-5_35-4_79_2_99:4.12.2.15
	Kernel-5_35-4_79_2_98_2_3:4.12.2.15
	Kernel-5_35-4_79_2_98_2_2:4.12.2.15
	Kernel-5_35-4_79_2_98_2_1:4.12.2.15
	Cortex:4.12.2.15.0.2
	Cortex_bp:4.12.2.15
	Kernel-5_35-4_79_2_98:4.12.2.15
	Kernel-5_35-4_79_2_97:4.12.2.15
	Kernel-5_35-4_79_2_96:4.12.2.15
	Kernel-5_35-4_79_2_95:4.12.2.15
	Kernel-5_35-4_79_2_94:4.12.2.15
	Kernel-5_35-4_79_2_93:4.12.2.15
	Kernel-5_35-4_79_2_92:4.12.2.15
	Kernel-5_35-4_79_2_91:4.12.2.15
	Kernel-5_35-4_79_2_90:4.12.2.15
	Kernel-5_35-4_79_2_89:4.12.2.15
	Kernel-5_35-4_79_2_88:4.12.2.15
	Kernel-5_35-4_79_2_87:4.12.2.15
	Kernel-5_35-4_79_2_86:4.12.2.15
	Kernel-5_35-4_79_2_85:4.12.2.15
	Kernel-5_35-4_79_2_84:4.12.2.15
	Kernel-5_35-4_79_2_83:4.12.2.15
	Kernel-5_35-4_79_2_82:4.12.2.15
	Kernel-5_35-4_79_2_81:4.12.2.15
	Kernel-5_35-4_79_2_80:4.12.2.14
	Kernel-5_35-4_79_2_79:4.12.2.14
	Kernel-5_35-4_79_2_78:4.12.2.14
	Kernel-5_35-4_79_2_77:4.12.2.14
	RO_5_07:4.12.2.14
	Kernel-5_35-4_79_2_76:4.12.2.14
	Kernel-5_35-4_79_2_75:4.12.2.14
	Kernel-5_35-4_79_2_74:4.12.2.14
	Kernel-5_35-4_79_2_73:4.12.2.14
	Kernel-5_35-4_79_2_72:4.12.2.14
	Kernel-5_35-4_79_2_71:4.12.2.14
	Kernel-5_35-4_79_2_70:4.12.2.14
	Kernel-5_35-4_79_2_69:4.12.2.14
	Kernel-5_35-4_79_2_68:4.12.2.14
	Kernel-5_35-4_79_2_67:4.12.2.13
	Kernel-5_35-4_79_2_66:4.12.2.13
	Kernel-5_35-4_79_2_65:4.12.2.12
	Kernel-5_35-4_79_2_64:4.12.2.12
	Kernel-5_35-4_79_2_63:4.12.2.12
	Kernel-5_35-4_79_2_62:4.12.2.12
	Kernel-5_35-4_79_2_61:4.12.2.12
	Kernel-5_35-4_79_2_59:4.12.2.12
	Kernel-5_35-4_79_2_58:4.12.2.12
	Kernel-5_35-4_79_2_57:4.12.2.12
	Kernel-5_35-4_79_2_56:4.12.2.12
	Kernel-5_35-4_79_2_55:4.12.2.12
	Kernel-5_35-4_79_2_54:4.12.2.12
	Kernel-5_35-4_79_2_53:4.12.2.12
	Kernel-5_35-4_79_2_52:4.12.2.11
	Kernel-5_35-4_79_2_51:4.12.2.11
	Kernel-5_35-4_79_2_50:4.12.2.10
	Kernel-5_35-4_79_2_49:4.12.2.10
	Kernel-5_35-4_79_2_48:4.12.2.10
	Kernel-5_47:4.13
	Kernel-5_46-4_90_2_1:4.13
	nbingham_Kernel_FastNC_dev_bp:4.13
	nbingham_Kernel_FastNC_dev:4.13.0.2
	Kernel-5_46:4.13
	Kernel-5_45:4.13
	Kernel-5_35-4_79_2_47:4.12.2.9
	Kernel-5_35-4_79_2_46:4.12.2.9
	Kernel-5_35-4_79_2_45:4.12.2.9
	Kernel-5_35-4_79_2_44:4.12.2.9
	Kernel-5_35-4_79_2_25_2_2:4.12.2.9
	Kernel-5_35-4_79_2_43:4.12.2.9
	Kernel-5_35-4_79_2_42:4.12.2.9
	Kernel-5_35-4_79_2_41:4.12.2.9
	Kernel-5_35-4_79_2_40:4.12.2.9
	Kernel-5_35-4_79_2_39:4.12.2.9
	Kernel-5_35-4_79_2_38:4.12.2.9
	Kernel-5_35-4_79_2_37:4.12.2.9
	Kernel-5_35-4_79_2_36:4.12.2.9
	Kernel-5_35-4_79_2_35:4.12.2.9
	Kernel-5_35-4_79_2_34:4.12.2.9
	Kernel-5_35-4_79_2_33:4.12.2.9
	Kernel-5_35-4_79_2_32:4.12.2.9
	Kernel-5_44:4.13
	Kernel-5_35-4_79_2_25_2_1:4.12.2.9
	Kernel-5_43:4.13
	Kernel-5_35-4_79_2_31:4.12.2.9
	Kernel-5_35-4_79_2_30:4.12.2.9
	Kernel-5_35-4_79_2_29:4.12.2.9
	Kernel-5_35-4_79_2_28:4.12.2.9
	Kernel-5_35-4_79_2_27:4.12.2.9
	Kernel-5_35-4_79_2_26:4.12.2.9
	Kernel-5_42:4.13
	Kernel-5_41:4.13
	Kernel-5_40:4.13
	Kernel-5_35-4_79_2_25:4.12.2.9
	Kernel-5_35-4_79_2_24:4.12.2.9
	Kernel-5_35-4_79_2_23:4.12.2.9
	Kernel-5_35-4_79_2_22:4.12.2.9
	Kernel-5_35-4_79_2_21:4.12.2.9
	Kernel-5_35-4_79_2_20:4.12.2.9
	Kernel-5_35-4_79_2_19:4.12.2.9
	Kernel-5_35-4_79_2_18:4.12.2.9
	Kernel-5_35-4_79_2_17:4.12.2.9
	Kernel-5_35-4_79_2_16:4.12.2.9
	Kernel-5_35-4_79_2_15:4.12.2.9
	Kernel-5_35-4_79_2_14:4.12.2.8
	Kernel-5_39:4.13
	Kernel-5_13-4_52_2_1:4.10
	Bethany:4.10.0.2
	Kernel-5_38:4.13
	Kernel-5_35-4_79_2_13:4.12.2.8
	Kernel-5_35-4_79_2_12:4.12.2.8
	Kernel-5_35-4_79_2_11:4.12.2.8
	Kernel-5_37:4.13
	Kernel-5_35-4_79_2_10:4.12.2.6
	Kernel-5_35-4_79_2_9:4.12.2.5
	Kernel-5_36:4.12
	Kernel-5_35-4_79_2_8:4.12.2.4
	Kernel-5_35-4_79_2_7:4.12.2.4
	Kernel-5_35-4_79_2_6:4.12.2.4
	Kernel-5_35-4_79_2_5:4.12.2.3
	Kernel-5_35-4_79_2_4:4.12.2.3
	Kernel-5_35-4_79_2_3:4.12.2.2
	Kernel-5_35-4_79_2_2:4.12.2.1
	dellis_autobuild_BaseSW:4.12
	Kernel-5_35-4_79_2_1:4.12.2.1
	HAL:4.12.0.2
	Kernel-5_35:4.12
	Kernel-5_34:4.12
	Kernel-5_33:4.12
	Kernel-5_32:4.12
	Kernel-5_31:4.12
	Kernel-5_30:4.12
	Kernel-5_29:4.11
	Kernel-5_28:4.11
	Kernel-5_27:4.11
	Kernel-5_26:4.11
	Kernel-5_25:4.11
	Kernel-5_24:4.11
	Kernel-5_23:4.11
	Kernel-5_22:4.10
	sbrodie_sedwards_16Mar2000:4.10
	Kernel-5_21:4.10
	Kernel-5_20:4.10
	Kernel-5_19:4.10
	Kernel-5_18:4.10
	Kernel-5_17:4.10
	Kernel-5_16:4.10
	Kernel-5_15:4.10
	Kernel-5_14:4.10
	Kernel-5_13:4.10
	Kernel-5_12:4.10
	Kernel-5_11:4.10
	Kernel-5_10:4.10
	Kernel-5_09:4.10
	Kernel-5_08:4.10
	Kernel-5_07:4.10
	Kernel-5_06:4.10
	Kernel-5_05:4.10
	Kernel-5_04:4.10
	Kernel-5_03:4.10
	Kernel-5_02:4.10
	Kernel-5_01:4.10
	Kernel-5_00:4.10
	Kernel-4_99:4.10
	Kernel-4_98:4.9
	Kernel-4_97:4.9
	Kernel-4_96:4.9
	Kernel-4_95:4.8
	Kernel-4_94:4.8
	Kernel-4_93:4.8
	Kernel-4_92:4.8
	Kernel-4_91:4.7
	Kernel-4_90:4.7
	dcotton_autobuild_BaseSW:4.13
	Kernel-4_89:4.7
	Kernel-4_88:4.7
	Kernel-4_87:4.6
	Kernel-4_86:4.5
	Kernel-4_85:4.4
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.3.2.3.2.1
	Kernel-4_84:4.4
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.3.2.3.2.1
	Ursula_RiscPC_bp:4.3.2.3
	Kernel-4_83:4.4
	Kernel-4_82:4.4
	Kernel-4_81:4.4
	Kernel-4_80:4.4
	Kernel-4_79:4.4
	Kernel-4_78:4.4
	Kernel-4_77:4.4
	Kernel-4_76:4.4
	Kernel-4_75:4.4
	Kernel-4_74:4.4
	Kernel-4_73:4.4
	Kernel-4_72:4.4
	Kernel-4_71:4.4
	Kernel-4_70:4.4
	Kernel-4_69:4.4
	Kernel-4_68:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.3.2.1
	Ursula_RiscPC:4.3.2.3.0.2
	Kernel-4_63-1_1_2_5:4.1.7.5
	Kernel-4_63-1_1_2_4:4.1.7.5
	Kernel-4_67:4.4
	Kernel-4_66:4.4
	Kernel-4_63-1_1_2_3:4.1.7.5
	Kernel-4_65:4.4
	Ursula_merge:4.3
	Kernel-4_64:4.4
	mstphens_Kernel-3_81:4.3.2.4
	Kernel-4_63-1_1_2_2:4.1.7.5
	nicke_Kernel_4_62:4.1.7.5
	rthornb_UrsulaBuild-19Aug1998:4.3.2.3
	UrsulaBuild_FinalSoftload:4.3.2.3
	rthornb_UrsulaBuild-12Aug1998:4.3.2.3
	aglover_UrsulaBuild-05Aug1998:4.3.2.3
	rthornb_UrsulaBuild-29Jul1998:4.3.2.3
	rthornb_UrsulaBuild-22Jul1998:4.3.2.3
	nturton_v459:4.1.7.2
	nturton_v460:4.1.7.3
	rthornb_UrsulaBuild-15Jul1998:4.3.2.3
	rthornb_UrsulaBuild-07Jul1998:4.3.2.3
	rthornb_UrsulaBuild-17Jun1998:4.3.2.3
	rthornb_UrsulaBuild-03Jun1998:4.3.2.3
	rthornb_UrsulaBuild-27May1998:4.3.2.3
	mstphens_Kernel-3_80:4.3.2.3
	rthornb_UrsulaBuild-21May1998:4.3.2.3
	afrost_Boca-1_2-Beta:4.1.7.4
	rthornb_UrsulaBuild_01May1998:4.3.2.3
	afrost_NC2_Generic:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	Spin_merge:4.1.7.5
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.25
date	2018.11.07.22.28.13;	author jlee;	state Exp;
branches;
next	4.24;
commitid	Ub9LVqEF46x8X3ZA;

4.24
date	2018.09.16.20.33.13;	author jlee;	state Exp;
branches;
next	4.23;
commitid	JScgekZtQefmZmSA;

4.23
date	2018.07.14.19.02.27;	author jlee;	state Exp;
branches;
next	4.22;
commitid	DsDtaR4YavfJx8KA;

4.22
date	2018.02.04.19.17.59;	author jlee;	state Exp;
branches;
next	4.21;
commitid	P8lRrfmbNEUXLzpA;

4.21
date	2018.02.03.18.41.44;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	VwdJDuE1iBptBrpA;

4.20
date	2017.06.07.20.45.31;	author jlee;	state Exp;
branches
	4.20.2.1;
next	4.19;
commitid	u2lBBGPD3exe2uUz;

4.19
date	2016.12.15.18.33.32;	author jlee;	state Exp;
branches;
next	4.18;
commitid	ATZJJqFZmHhMT6yz;

4.18
date	2016.12.15.15.27.03;	author jlee;	state Exp;
branches;
next	4.17;
commitid	SNoEvPlWCrTKR5yz;

4.17
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches;
next	4.16;
commitid	skOEjp3ipLHx6xcz;

4.16
date	2016.06.30.20.42.11;	author jlee;	state Exp;
branches;
next	4.15;
commitid	bDF3DCxdmyMD0xcz;

4.15
date	2016.06.30.20.29.05;	author jlee;	state Exp;
branches;
next	4.14;
commitid	lMnWzoE9eJz3Wwcz;

4.14
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.13;
commitid	IWoXxARWeuLDOwcz;

4.13
date	2000.10.17.08.44.49;	author sbrodie;	state Exp;
branches;
next	4.12;

4.12
date	2000.06.28.16.12.26;	author bavison;	state Exp;
branches
	4.12.2.1;
next	4.11;

4.11
date	2000.04.04.14.27.39;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	99.10.19.09.26.49;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	99.10.14.12.18.28;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.10.07.11.09.27;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.09.20.14.59.37;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.09.17.10.11.43;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.09.16.13.53.39;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.09.30.08.42.55;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.05.51.58;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.14.07.33;	author nturton;	state Exp;
branches
	4.2.4.1;
next	4.1;

4.1
date	96.11.05.09.41.33;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.20.2.1
date	2018.02.16.00.01.46;	author jlee;	state Exp;
branches;
next	;
commitid	L7HYXYTsWSFlZ0rA;

4.12.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.12.2.2;

4.12.2.2
date	2000.10.03.12.05.59;	author mstephen;	state Exp;
branches;
next	4.12.2.3;

4.12.2.3
date	2000.10.05.11.55.12;	author mstephen;	state Exp;
branches;
next	4.12.2.4;

4.12.2.4
date	2000.10.05.14.33.00;	author mstephen;	state Exp;
branches;
next	4.12.2.5;

4.12.2.5
date	2000.10.16.11.37.10;	author mstephen;	state Exp;
branches;
next	4.12.2.6;

4.12.2.6
date	2000.10.16.12.35.53;	author mstephen;	state Exp;
branches;
next	4.12.2.7;

4.12.2.7
date	2000.10.17.08.54.13;	author sbrodie;	state Exp;
branches;
next	4.12.2.8;

4.12.2.8
date	2000.10.20.14.58.21;	author kbracey;	state Exp;
branches;
next	4.12.2.9;

4.12.2.9
date	2001.01.12.13.52.13;	author mstephen;	state Exp;
branches;
next	4.12.2.10;

4.12.2.10
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches;
next	4.12.2.11;

4.12.2.11
date	2002.11.30.00.31.12;	author bavison;	state Exp;
branches;
next	4.12.2.12;

4.12.2.12
date	2002.12.18.22.18.33;	author bavison;	state Exp;
branches;
next	4.12.2.13;

4.12.2.13
date	2004.05.06.16.02.05;	author kbracey;	state Exp;
branches;
next	4.12.2.14;

4.12.2.14
date	2004.06.18.14.38.54;	author bavison;	state Exp;
branches;
next	4.12.2.15;

4.12.2.15
date	2004.11.02.00.48.04;	author jballance;	state Exp;
branches
	4.12.2.15.2.1;
next	4.12.2.16;

4.12.2.16
date	2011.11.26.21.11.28;	author jlee;	state Exp;
branches;
next	4.12.2.17;
commitid	cI3W0zbtALQG6TIv;

4.12.2.17
date	2011.11.27.11.48.20;	author rsprowson;	state Exp;
branches;
next	4.12.2.18;
commitid	OFgqaKhOb6swXXIv;

4.12.2.18
date	2012.02.25.16.19.42;	author jlee;	state Exp;
branches
	4.12.2.18.2.1;
next	4.12.2.19;
commitid	ad3WnPntkzrizyUv;

4.12.2.19
date	2012.05.21.19.31.43;	author rsprowson;	state Exp;
branches;
next	4.12.2.20;
commitid	oEtPURiKNEPMRC5w;

4.12.2.20
date	2012.07.04.17.50.57;	author rsprowson;	state Exp;
branches;
next	4.12.2.21;
commitid	BwjRc3GMlaDwTgbw;

4.12.2.21
date	2012.09.18.22.01.21;	author jlee;	state Exp;
branches;
next	4.12.2.22;
commitid	eFa3Y1QY0MjZP3lw;

4.12.2.22
date	2012.10.28.16.51.51;	author rsprowson;	state Exp;
branches;
next	4.12.2.23;
commitid	ruXZqdTJKJ85Qaqw;

4.12.2.23
date	2013.03.28.21.36.34;	author jlee;	state Exp;
branches;
next	4.12.2.24;
commitid	UN0GP6eB0LlNyBJw;

4.12.2.24
date	2013.08.06.22.43.09;	author jlee;	state Exp;
branches;
next	4.12.2.25;
commitid	TOIaeUf2Q4rBIr0x;

4.12.2.25
date	2013.12.15.21.34.11;	author jlee;	state Exp;
branches;
next	4.12.2.26;
commitid	KwuK29hKRyXO7hhx;

4.12.2.26
date	2013.12.19.00.09.00;	author jlee;	state Exp;
branches;
next	4.12.2.27;
commitid	sFhm1gbZFIB4TFhx;

4.12.2.27
date	2014.01.01.16.32.19;	author jlee;	state Exp;
branches;
next	4.12.2.28;
commitid	Y3xhUMkzB7tvUqjx;

4.12.2.28
date	2014.03.28.00.12.57;	author jlee;	state Exp;
branches;
next	4.12.2.29;
commitid	cEZUvOhcFiZ8Joux;

4.12.2.29
date	2014.04.06.19.23.28;	author jlee;	state Exp;
branches;
next	4.12.2.30;
commitid	EtypGk33aKVRNEvx;

4.12.2.30
date	2014.04.18.14.10.56;	author jlee;	state Exp;
branches;
next	4.12.2.31;
commitid	4EaaKIpUowBKGaxx;

4.12.2.31
date	2015.07.10.20.16.42;	author jlee;	state Exp;
branches;
next	4.12.2.32;
commitid	wa0i3ESGlbkojMsy;

4.12.2.32
date	2015.08.31.19.28.45;	author jlee;	state Exp;
branches;
next	;
commitid	Ni3KL17bG70fnszy;

4.12.2.15.2.1
date	2010.02.28.19.33.57;	author jlee;	state Exp;
branches;
next	4.12.2.15.2.2;

4.12.2.15.2.2
date	2011.08.08.23.28.38;	author jlee;	state Exp;
branches
	4.12.2.15.2.2.2.1;
next	4.12.2.15.2.3;
commitid	D7rzILnwRRSXoLuv;

4.12.2.15.2.3
date	2011.09.24.19.55.59;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.12.2.15.2.2.2.1
date	2012.05.10.03.10.00;	author bavison;	state Exp;
branches;
next	;
commitid	HTVG5Da5tRqSM74w;

4.12.2.18.2.1
date	2012.05.10.03.28.12;	author bavison;	state Exp;
branches;
next	4.12.2.18.2.2;
commitid	kuJoT3AcfB16T74w;

4.12.2.18.2.2
date	2012.05.20.21.21.38;	author jballance;	state Exp;
branches;
next	4.12.2.18.2.3;
commitid	neZVFdyw3wNwvv5w;

4.12.2.18.2.3
date	2012.09.02.19.56.54;	author jlee;	state Exp;
branches;
next	4.12.2.18.2.4;
commitid	q3Bny0G3EqBdFZiw;

4.12.2.18.2.4
date	2012.09.07.23.05.59;	author jlee;	state Exp;
branches;
next	4.12.2.18.2.5;
commitid	Ik0jMROsIiH5yEjw;

4.12.2.18.2.5
date	2012.09.18.13.44.42;	author jlee;	state Exp;
branches;
next	4.12.2.18.2.6;
commitid	2BntgJjnyfkD51lw;

4.12.2.18.2.6
date	2012.09.18.15.50.10;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.3.2.1
date	97.05.21.09.30.42;	author mstphens;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	97.09.09.13.34.34;	author mstphens;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	97.10.21.15.31.36;	author mstphens;	state Exp;
branches
	4.3.2.3.2.1;
next	4.3.2.4;

4.3.2.4
date	98.09.24.13.17.48;	author mstphens;	state Exp;
branches;
next	;

4.3.2.3.2.1
date	98.11.23.14.59.41;	author mstphens;	state Exp;
branches;
next	;

4.2.4.1
date	97.04.04.14.50.41;	author nturton;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.33;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.02.41;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.08.09.35;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.16.46.14;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.49;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.29;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.13.15.03.55;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.12.11.14.01.36;	author nturton;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	98.06.05.09.31.56;	author afrost;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	98.07.21.17.57.47;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.25
log
@Attempt to tidy up substitute screen mode selection logic
Detail:
  Over the years the OS's substitute screen mode selection logic has grown to be a tangled mess, and the logic it does implement isn't always very useful. Additionally, the kernel is structured in such a way that it can be hard for modules to override it.
  This set of changes aims to fix the many of the problems, by doing the following:
  - Moving all substitute mode selection logic out of the core VDU driver code and into a Service_ModeTranslation handler. This means you now only have one place in the kernel to look instead of several, and modules can override the behaviour by claiming/blocking the service call as appropriate.
  - Moving handling of the built-in VIDC lists out of the core VDU driver code and into a Service_ModeExtension handler. This means programs can now inspect these VIDC lists by issuing the right service call (although you are essentially limited to lists which the GraphicsV driver is OK with)
  - Moving *TV interlace & offset adjustment logic into the Service_ModeExtension handler, since they're legacy things which can be handled more cleanly for MDF/EDID (and the old code was poking memory the kernel didn't own)
  - Adding a Service_EnumerateScreenModes implementation, so that if you end up in the desktop with ScreenModes non-functional, the display manager at least has something useful to show you
  - Enhancing the handling of the built-in numbered modes so that they are now available in any colour depth; the Service_ModeExtension handler (and related handlers) treat the builtin VIDC lists as a set of mode timings, not a discrete set of modes
  - Substitute mode selection logic is a complete re-write. Instead of trying a handful of numbered fallback modes, it now tries:
    - Same mode but at higher colour depths
    - Same mode but at lower colour depths
    - Alternate resolutions (half-width mode with no double-pixel if original request was for double-pixel, and default resolution for monitor type)
  - Combined with the logic to allow the builtin VIDC lists to be used at any colour depth, this means that the kernel should now be able to find substitute modes for machines which lack support for <=8bpp modes (e.g. OMAP5)
  - Additionally the mode substitution code will attempt to retain as many properties of the originally requested mode as possible (eigen values, gap mode type, etc.)
  Other improvements:
  - The kernel now actually vets the builtin VIDC lists instead of assuming that they'll work (which also means they'll have the correct ExtraBytes value, where applicable)
  - The kernel now uses GraphicsV 19 (VetMode2) to vet the mode during the mode switch process, using the result to detect where the framebuffer will be placed. This allows for GraphicsV drivers to switch between DA 2 and external framestores on a per-mode basis.
  - The kernel now supports mode selectors which specify LineLength values which are larger than necessary; this will get translated to a suitable ExtraBytes control list item (+ combined with whatever padding the driver indicates is necessary via the VetMode2 result)
  File changes:
  - hdr/KernelWS - Reserve space for a VIDC list, since the Service_ModeExtension implementation typically can't use the built-in list as-is
  - s/Arthur3 - Issue Service_ModeFileChanged when the configured monitor type is changed, so that DisplayManager + friends are aware that the set of available modes has changed
  - s/GetAll - Fiddle with GETs a bit
  - s/MemMap2 - Extra LTORG
  - s/NewIRQs - Small routine to install/uninstall false VSync routine (previously from PushModeInfo, which wasn't really the appropriate place for it)
  - s/Utility - Hook up the extra service call handlers
  - s/vdu/legacymodes - New file containing the new service call implementations, and some related code
  - s/vdu/vdudecl - Move mode workspace definition here, from vdumodes
  - s/vdu/vdudriver - Remove assorted bits of mode substitution code. Plug in new bits for calling GraphicsV 19 during mode set, and deal with ExtraBytes/LineLength during PushModeInfo
  - s/vdu/vdumodes - Move some workspace definitions to s/vdu/vdudecl. Tweak how the builtin VIDC lists are stored.
  - s/vdu/vduswis - Rip out more mode substitution code. Issue Service_ModeFileChanged when monitor type is changed by OS_ScreenMode.
Admin:
  Tested on Raspberry Pi 3, Iyonix, IGEPv5


Version 6.14. Tagged as 'Kernel-6_14'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduDriver
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - Vdu queue, mode, default windows etc.
;
; Author R C Manby
; Date   5.9.86
;

        GET s.vdu.VduGrafDec

        MACRO
        RMVT    $var, $BW
        [ "$BW"="B"
        =       (wk$var-wkstart)*2
        |
        [ "$BW"="W"
        =       (wk$var-wkstart)*2 +1
        |
        .... Invalid option on RMVT ....
        ]
        ]
        MEND

        MACRO
        RVVT    $var
        ASSERT  ($var >= 0) :LAND: ($var < &400) :LAND: (($var :AND: 3)=0)
        =       $var :SHR: 2
        MEND

        MACRO
        IssueService
        BL      Issue_Service
        MEND

        MACRO
        MALIGN  $length, $phase
        LCLA    temp
        LCLS    string
temp    SETA    .-ArthurVduDriver
        [ "$phase"=""
string  SETS    "ALIGN $length"
        |
string  SETS    "ALIGN $length, $phase"
        ]
        $string
temp    SETA    .-ArthurVduDriver-temp
        [ temp=0
        !       0, string :CC: " fitted exactly"
        |
        !       0, string :CC: " wasted " :CC: :STR: temp
        ]
        MEND


; Macro to load up video bandwidth and video memory size

        MACRO
        GetBandwidthAndSize  $bw, $size
        LDR     $size, =ZeroPage
        LDR     $size, [$size, #VideoSizeFlags]
        MOV     $bw, #100*1024*1024
        MOV     $size, $size, LSR #12
        MOV     $size, $size, LSL #12
        !       0, "Sort out GetBandwidthAndSize"
        MEND

; *****************************************************************************

; Vdu status bits

Vdu2ModeBitPosn *       0
Vdu2Mode        *       1 :SHL: Vdu2ModeBitPosn
Windowing       *       1 :SHL: 3
Shadowing       *       1 :SHL: 4

; *****************************************************************************

ArthurVduDriver

; *****************************************************************************
;
; VduInit - Once only initialisation of Vdu drivers eg after Break
; =======
;
VduInit ROUT
        Push    R14
        LDR     R0, =ZeroPage
        LDR     R14, [R0, #VideoPhysAddr]
        ASSERT (ZeroPage :AND: 255) = 0
        STRB    R0, [R0, #OsbyteVars + :INDEX: VDUqueueItems] ;purge queue
        STRB    R0, [WsPtr, #ScreenBlankFlag]   ; not blanked
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
        STR     R0, [WsPtr, #CursorCounter]
        STR     R0, [WsPtr, #CursorDesiredState]
        STR     R0, [WsPtr, #VduStatus]
        STRB    R0, [WsPtr, #PointerShapeNumber]  ; make sure pointer off
        STR     R0, [WsPtr, #PointerShapeLA]      ; no shape passed to HAL yet
        STR     R0, [WsPtr, #CursorStack]         ; 0 bits => on
        STR     R0, [WsPtr, #VduSaveAreaPtr]      ; indicate no save area yet
        STR     R0, [WsPtr, #ClipBoxEnable]       ; no clip box calculating
        STRB    R0, [WsPtr, #ExternalFramestore]
        STR     R0, [WsPtr, #GraphicsVFeatures]
        MOV     R3, #MaxGraphicsVDrivers
        LDR     R2, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
01
        STR     R0, [R2], #4
        SUBS    R3, R3, #1
        BNE     %BT01        
        MOV     R0, #GraphicsVInvalid
        STR     R0, [WsPtr, #CurrentGraphicsVDriver]
        STR     R14, [WsPtr, #TrueVideoPhysAddr]  ; init TrueVideoPhysAddr for internal RAM/VRAM framestore case 

        LDR     R0, =RangeC+SpriteReason_SwitchOutputToSprite
        STR     R0, [WsPtr, #SpriteMaskSelect]

        MOV     R0, #InitialCursorFlags         ; TMD 25/9/86
        STR     R0, [WsPtr, #CursorFlags]

        ADRL    R0, NUL                 ; point to MOV PC,R14
        STR     R0, [WsPtr, #WrchNbit]  ; just in case ...

        ADRL    R0, ExportedHLine
        STR     R0, [WsPtr, #HLineAddr]
        ADD     R0, WsPtr, #FgEcfOraEor
        STR     R0, [WsPtr, #GcolOraEorAddr]

        MOV     R0, #maxmode
        STR     R0, [WsPtr, #MaxMode]   ; constant now


        LDROSB  R0, LastBREAK           ; is it a hard reset ?
        TEQ     R0, #SoftReset
        BEQ     %FT10                   ; [no, don't reset font]


; allocate buffer for Tim's whizzy text expansion.  This now lives
; in the system heap, unless the claim request fails.  If the request
; fails then the pointer points at the original buffer in the Vdu
; driver workspace.

; This allows the user to access depths upto 16 bit per pixel before
; strings things things become afoot at the Circle K.

        LDR     R3, =TextExpandArea_Size
        BL      ClaimSysHeapNode        ; allocate buffer for heap data
        ADDVS   R2, WsPtr, #TextExpand
        STR     R2, [WsPtr, #TextExpandArea]

        LDR     R3, =ModeSelector_MaxSize+4     ; get block for two overlapping copies
        BL      ClaimSysHeapNode                ; of mode selector, 1 word apart
        STR     R2, [WsPtr, #KernelModeSelector]


; now reset soft font from hard font

        MOV     R1, #1                  ; start at character 1*32
        STRB    R1, [WsPtr, #ScreenMemoryClaimed]
                                        ; can't claim memory till a mode change
        MOV     R2, #7                  ; copy 7 pages
        BL      DoResetFont

;initialise the 6 pointer shape pointers and blocks
;(shape buffers are 6 * &100 starting at CursorData)
;
        ADD     r0, WsPtr, #PointerShapes
        LDR     r2, =CursorData
        MOV     r3, #6
        ADD     r4, WsPtr, #PointerShapeBlocks
02
        STR     r4, [r0]                 ; attach pointer to block
        STR     r2, [r4, #PointerBuffLA]
        Push    "r0-r2"
        MOV     r1, #0
        STRB    r1, [r4, #PointerWidth]  ; zero width
        STRB    r1, [r4, #PointerHeight] ; zero height (no shape)
        SUB     sp, sp, #3*4             ; room for one entry of OS_Memory page block
        MOV     r1, sp
        STR     r2, [r1, #4]             ; provide logical address
        MOV     r2, #1
        MOV     r0, #&2200               ; convert logical to physical address
        SWI     XOS_Memory
        LDR     r2, [r1, #8]             ; read physical address
        STR     r2, [r4, #PointerBuffPA]
        ADD     sp, sp, #3*4
        Pull    "r0-r2"
        ADD     r4, r4, #PointerBlkSize
        ADD     r2, r2, #&100
        ADD     r0, r0, #4
        SUBS    r3, r3, #1
        BNE     %BT02

; palette space (256 normal + 1 border + 3 pointer = 260), and allowing for Gamma Correction
;   this space is: blank palette, 260 words
;                  logical and physical copies of both flash states, 260*4 words
;                  3 lookup tables for r,g,b mapping, 3*256 bytes
;
        LDR     r3, =Pal_Blocksize
        BL      ClaimSysHeapNode           ; this had better succeed!

        ASSERT  :INDEX:Pal_Blank = 0
        STR     r2, [WsPtr, #BlankPalAddr]
        ADD     r3, r2, #Pal_LogFirst
        STR     r3, [WsPtr, #FirPalAddr]
        ADD     r3, r2, #Pal_LogSecond
        STR     r3, [WsPtr, #SecPalAddr]

; initialise blank palette to all solid black
; zero-init the other palettes too, to make sure log & phys palettes are
; consistent

        MOV     r3, #0
        LDR     r4, =PalEntries*5
04      STR     r3, [r2], #4
        SUBS    r4, r4, #1
        BNE     %BT04

        ASSERT  Pal_RTable = Pal_Blank + PalEntries*5*4

; initialise red, green and blue transfer function tables to 1-1 mapping

        MOV     r0, #0
05
        STRB    r0, [r2, #Pal_STable-Pal_RTable] ; store in supremacy table
        STRB    r0, [r2, #Pal_BTable-Pal_RTable] ; store in blue table
        STRB    r0, [r2, #Pal_GTable-Pal_RTable] ; store in green table
        STRB    r0, [r2], #1                     ; store in red table, and advance
        ADD     r0, r0, #1
        CMP     r0, #256
        BCC     %BT05
10
        BL      SpriteInit

        LDR     R14, [WsPtr, #ScreenEndAddr]
        LDR     R0, [WsPtr, #TotalScreenSize]
        RSB     R0, R0, R14
        STR     R0, [WsPtr, #DisplayStart]
        BL      SetDisplayScreenStart
        STR     R0, [WsPtr, #ScreenStart]
        STR     R0, [WsPtr, #CursorAddr]
        STR     R0, [WsPtr, #InputCursorAddr]

        Pull    PC

        LTORG

; *****************************************************************************
;
;       InitialiseMode - Select mode number given by ModeNo variable
;                         
;       Called by MOS once before initialisation, and then afterwards
;       before printing "RISC OS ..."
;
; in:   -
; out:  r0 = corrupt, or error pointer
;       All other registers preserved
;

InitialiseMode ROUT
; if we don't have a video driver yet, now is a good time to check if the HAL
; provides one
        LDR     r0, =ZeroPage+VduDriverWorkSpace+CurrentGraphicsVDriver
        LDR     r0, [r0]
        CMP     r0, #GraphicsVInvalid
        BEQ     VduGrafHAL_Init         ; tail-call since InitialiseMode will get called again when the HAL registers itself
        
        Entry   "r1-r12"

        ; Refresh cached features flags before we start calling this new driver        
        MOV     r4, r0, LSL #24
        ORR     R4, R4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        VDWS    WsPtr
        STR     r0, [WsPtr, #GraphicsVFeatures]

        ; Update screen memory information
        ASSERT  GVDisplayFeature_SeparateFramestore < 256
        ANDS    r1, r0, #GVDisplayFeature_SeparateFramestore
        STRB    r1, [WsPtr, #ExternalFramestore]
        BNE     %FT20
        ; Screen DA is in use
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #VideoPhysAddr]
        STR     r0, [WsPtr, #TrueVideoPhysAddr] ; Point TrueVideoPhysAddr at the base of screen DA
        MOV     r0, #2
        SWI     XOS_ReadDynamicArea
        MOVVS   r1, #0                  ; shouldn't happen, but set a safe size just in case
        STR     r1, [WsPtr, #TotalScreenSize] ; Ensure TotalScreenSize consistent with DA size
        ; Reinitialise a few more variables which are used by the screen DA handler
        ADD     r1, r0, r1
        STR     r1, [WsPtr, #ScreenEndAddr]
        STR     r0, [WsPtr, #DisplayStart]
        BL      SetDisplayScreenStart
        STR     r0, [WsPtr, #ScreenStart]
        B       %FT30
20
        ; Driver manages memory itself
        TST     r0, #GVDisplayFeature_VariableFramestore
        BNE     %FT30                   ; Framestore changes with mode, we can't read its info here
        ; Framestore is fixed, get its info and remember it (ModeChangeSub currently relies on this for VRAM limit checking)
        LDR     r0, =ZeroPage+VduDriverWorkSpace+CurrentGraphicsVDriver
        LDR     r0, [r0]
        MOV     r4, r0, LSL #24
        ORR     r4, r4, #GraphicsV_FramestoreAddress
        BL      CallGraphicsV
        CMP     r4, #0
        MOVNE   r1, #0                  ; If call wasn't claimed, claim 0 screen memory. Mode change will then fail with out of memory error, which is about the best we can do.
        STR     r0, [WsPtr, #TrueVideoPhysAddr]
        STR     r1, [WsPtr, #TotalScreenSize]

30

        MOV     r0, #1                  ; no need to check for soft reset,
        SWI     XOS_ReadSysInfo         ; always use configured value
        MOV     r1, r0

        MOV     r0, #ScreenModeReason_SelectMode
        SWI     XOS_ScreenMode
        BVC     %FT40

        MOV     r0, #114                ; failed, so get rid of any shadow
        MOV     r1, #1
        SWI     XOS_Byte
        SWI     XOS_WriteI+22
        SWIVC   XOS_WriteI+0            ; and if we can't get mode 0, we're really fooked!!!
40
        BLVC    UpdateAllPalette        ; make sure GV driver is aware of the pointer colours (this will also redundantly set the main palette + border colour, but re-using this routine as-is avoids duplicating a bunch of code)
        EXIT

;
;
;------------------------------------------------------------------------------
;
; Vdu -  Main VDU driver entry point
; ===    Queue up bytes and dispatch via JVec
;
; in:   R0 = character to be printed
;
; out:  C=1 <=> send character to printer if enabled
;

Vdu     ROUT
        LDR     R11, =ZeroPage          ; NB used later in Vdu07 as well
        LDRB    R10, [R11, #OsbyteVars + :INDEX: VDUqueueItems]
        MOVS    R9, R10, LSL #24        ; move up to top byte (for sign extend)
        BEQ     Vdu07                   ; not queueing, then start Vdu sequence

; *****Comment made by DJS: Changing this to fall through if not queueing
; and branch if queueing might be a good idea - it would speed up all
; printable characters and simple cursor movements.

        LDR     R8, [WsPtr, #QOffset]
        STRB    R0, [R8, R9, ASR #24]   ; add byte to queue

        ADD     R10, R10, #1            ; move on pointer
        STRB    R10, [R11, #OsbyteVars + :INDEX: VDUqueueItems]

        CMP     R10, #&100              ; finished sequence ?
        MOVCC   PC, R14                 ; no, then return (no printing)

        Push    "R0, R14"
        BL      PreWrchCursor           ; exits with R6 = CursorFlags
        Pull    "R0"
05
        ADR     R14, VduPrintExit
        Push    R14
        BL      Vdu05
        BL      PostWrchCursor
        CLC                             ; also clears V
        ADD     SP,SP,#4
        Pull    PC

VduPrintExit                             ; exit used if print required
        BL      PostWrchCursor
        SEC                             ; also clears V
        Pull    PC

; *****************************************************************************

Vdu05   ROUT
        TST     R6, #VduDisabled        ; VDU enabled ?
        LDREQ   PC, [WsPtr, #JVec]      ; yes, then do it (no printing)

; Queue sequence has just completed, but VDU is disabled
; Only interesting case is VDU 1 (SOH), which must still print
; the character if the printer is enabled

        LDR     R10, [WsPtr, #JVec]
        ADR     R11, SOH
        TEQ     R10, R11                ; JVec -> SOH ?
        MOVNE   PC, R14                 ; no, then return (no printing)
SOH
        LDR     R1, [WsPtr, #VduStatus]  ; in VDU 2 mode ?
        TST     R1, #Vdu2Mode
        MOVEQ   PC, R14                 ; no, then return

        Push    R14
        BL      MOSDoPrint
        Pull    PC, VC                  ; good exit, so return

        Pull    R14                     ; bad exit, return with error
        B       VduBadExit

; *****************************************************************************

Vdu07   ROUT
        AND     R0, R0, #&FF            ; Only look at bottom byte!

        CMP     R0,#127                 ;If DELETE, change R0 to 32 and
        MOVEQ   R0,#32                  ;  drop through to control char code
        CMPNE   R0,#31                  ;Otherwise, branch to printable char
        BHI     Vdu20                   ;  code if not a control char

; *****Further desirable change: Make printable characters fall through,
; control characters take the branch - speeding up printable characters is
; important!

        ADR     R10, VduJTb             ; Address of beginning of jump table
        LDR     R9, [R10, R0, LSL #2]   ; Get routine address from VduJTB
        STR     R9, [WsPtr, #JVec]      ; save address

        ADD     R10, R10, #(VduQTb-VduJTb)

        LDRB    R9, [R10, R0]           ; Pick up QQ + length of queue
        RSBS    R10, R9, #QQ            ; -(length of queue) & test if none

        STRNEB  R10, [R11, #OsbyteVars + :INDEX: VDUqueueItems]
                                        ; yes, then set up Osbyte variable
        ADDNE   R9, R9, WsPtr
        STRNE   R9, [WsPtr, #QOffset]   ; and QOffset
        MOVNE   PC, R14

        Push    "R0,R14"
        BL      PreWrchCursor           ; exits with R6 = CursorFlags
        Pull    "R0"
10
        ADR     R14, VduPrintExit
        Push    R14
        BL      Vdu10
        BL      PostWrchCursor
        CLC                             ; also clears V
        ADD     SP, SP, #4
        Pull    PC

;
; This is the only byte of a single byte Vdu sequence
;
;       R6 = CursorFlags
;       R11 = 0 (used to index VDUqueueItems)
;

Vdu10   ROUT
        TST     R6, #CursorsSplit       ; are we cursor editing ?
        BNE     Vdu15
Vdu10Continue

; TMD 31/7/87; bug fixed here - chars 8 to 13 should still go to printer if
; enabled, even if VDU is disabled

        CMP     R0, #8                  ; is char in range 8-13 ?
        RSBCSS  R1, R0, #13             ; if so then we want to print it
        LDRCS   R1, [WsPtr, #VduStatus]
        MOVCSS  R1, R1, LSR #(Vdu2ModeBitPosn +1) ; providing printer enabled
        Pull    R14, CS                 ; so pull old R14

        TST     R6, #VduDisabled        ; are we disabled
        LDREQ   PC, [WsPtr, #JVec]      ; enabled, so go get em floyd !

        TEQ     R0, #6                  ; disabled, so is it ACK (enable VDU)
        BICEQ   R6, R6, #VduDisabled
        STREQ   R6, [WsPtr, #CursorFlags]

NUL ;Does nothing
ESC ;Does nothing
        MOV     PC, R14                 ; return anyway

; *****************************************************************************

Vdu15
        TEQ     R0, #13                 ; and is it a carriage return ?
        BNE     Vdu10Continue

        Push    "R0, R14"
        BIC     R6, R6, #CursorsSplit   ; then stop cursor editing
        STR     R6, [WsPtr, #CursorFlags]
        MOV     R1, #1                  ; restore old Reg10Copy
        BL      CursorOnOff
        Pull    "R0, R14"
        B       Vdu10Continue

; *****************************************************************************

Vdu20   ROUT
        Push    "R0,R14"
        BL      PreWrchCursor           ; exits with R6 = CursorFlags
        Pull    "R0"
05
        ADR     R14, VduPrintExit
        Push    R14
        BL      TimWrch
        BL      PostWrchCursor
        CLC                             ; also clears V
        ADD     SP, SP, #4
        Pull    PC

; *****************************************************************************

VduJTb                  ; Table of addresses
 & NUL                          ; Does nothing
 & SOH                          ; Next char to printer only
 & STX                          ; Enable printer
 & ETX                          ; Disable printer
 & EOT                          ; Write text at text cursor
 & ENQ                          ; Write text at graphics cursor
 & NUL                          ; Enable VDU drivers
 & BEL                          ; Beep
 & BS                           ; Cursor left
 & HT                           ; Cursor right
 & VduLF                        ; Cursor down
 & VT                           ; Cursor up
 & FF                           ; Clear text area (CLS)
 & VduCR                        ; Carriage return
 & SO                           ; Page mode on
 & SI                           ; Page mode off
 & DLE                          ; Clear graphics area (CLG)
 & DC1                          ; Define text colour (COLOUR)
 & DC2                          ; Define graphics colour and action (GCOL)
 & DC3                          ; Define logical colour
 & VDU20                        ; Restore default logical colours
 & NAK                          ; Disable VDU drivers
 & SYN                          ; Select screen mode (MODE)
 & ETB                          ; Reprogram display character (VDU23,...)
 & CAN                          ; Define graphics window
 & EM                           ; (PLOT k,x,x,y,y)
 & DefaultWindows               ; Restore default windows
 & ESC                          ; Does nothing
 & FS                           ; Define text window
 & GS                           ; Define graphics origin
 & RS                           ; Home cursor to "top left"
 & US                           ; Move text cursor (TAB x,y)
 & Delete                       ; Delete character (127)

        ASSERT  QQ+9 < 256

VduQTb          ; QQ + length of queue for each of the above
        DCB     QQ+0, QQ+1, QQ+0, QQ+0, QQ+0, QQ+0, QQ+0, QQ+0
        DCB     QQ+0, QQ+0, QQ+0, QQ+0, QQ+0, QQ+0, QQ+0, QQ+0
        DCB     QQ+0, QQ+1, QQ+2, QQ+5, QQ+0, QQ+0, QQ+1, QQ+9
        DCB     QQ+8, QQ+5, QQ+0, QQ+0, QQ+4, QQ+4, QQ+0, QQ+2
        DCB     QQ+0 ; (delete)
        ALIGN

; *****************************************************************************

WrchNbitTab
        &       Wrch1bit-WrchNbitTab
        &       Wrch2bit-WrchNbitTab
        &       Wrch4bit-WrchNbitTab
        &       Wrch8bit-WrchNbitTab
        &       Wrch16bit-WrchNbitTab
        &       Wrch32bit-WrchNbitTab
WrchNbitDoubleTab
        &       Wrch1bitDouble-WrchNbitDoubleTab

CursorNbitTab
        &       Cursor1bit-CursorNbitTab
        &       Cursor2bit-CursorNbitTab
        &       Cursor4bit-CursorNbitTab
        &       Cursor8bit-CursorNbitTab
        &       Cursor16bit-CursorNbitTab
        &       Cursor32bit-CursorNbitTab
        &       Cursor64bit-CursorNbitTab


; *****************************************************************************
;
;       SYN - Perform MODE change
;
;       External routine
;
; in:   Vdu queue contains mode number
;

SYN     ROUT                            ; Select screen mode (MODE)
        Push    lr
        LDRB    R2, [WsPtr, #QQ]        ; Read mode number from queue
        BL      ModeChangeSub
        Pull    lr
        MOVVC   pc, lr                  ; if no error, exit to Vdu
                                        ; (which calls PostWrchCursor)
; else drop thru into ...

VduBadExit                              ; jumped to if an error in VDU code
        Push    R0                      ; save error pointer
        BL      PostWrchCursor
        LDR     R0, [R13], #8           ; get error pointer, junk next entry
        SETV
        Pull    PC

; in: R2 = mode number / selector block
ModeChangeSub ROUT
        ; Wrap the bulk of ModeChangeSub in some code that will free any new
        ; TTX workspace pointer if the mode change fails (or the pointer isn't
        ; claimed for any other reason)
        Entry
        MOV     r0, #0
        STR     r0, [WsPtr, #TTXNewWorkspace]
        BL      %FT01
        LDR     r2, [WsPtr, #TTXNewWorkspace]
        TEQ     r2, #0
        EXIT    EQ
        MRS     r3, CPSR
        MOV     r4, r0
        BL      FreeSysHeapNode
        MSR     CPSR_c, r3
        MOV     r0, r4
        EXIT

01
        Push    lr

        MOV     R1, #Service_PreModeChange
        IssueService
        TEQ     R1, #0                  ; was service claimed ?
        BNE     %FT03                   ; no, so continue
        CMP     R0, #0                  ; service claimed; generate error ?
        Pull    PC, EQ                  ; no, just exit (V=0 from CMP)
        B       %FT07                   ; yes, then generate error
03
        MOV     R0, R2                  ; put mode (possibly changed) in R0
        MOV     R2, R0, LSR #7          ; R2 = 0/1 if bit 7 of mode clear/set
        CMP     r2, #2                  ; if mode number >= 256 then mode selector
        MOVCS   r2, #0                  ; so no shadow
        LDROSB  R1, Shadow
        TEQ     R1, #0                  ; if shadow 0 then force shadow mode
        MOVEQ   R2, #1

        BL      FindOKMode              ; out: R1 = mode we are going to use
        BVS     %FT07

        TEQ     R0, R1                  ; if substitute mode
        MOVNE   R2, #0                  ; then don't use shadow

        CMP     r1, #&100
        BICCC   r10, r1, #&80
        MOVCS   r10, r1
        MOV     R11, R10
        BL      PushModeInfo
        BVS     %FT07                   ; [probably duff mode selector]

        ; Allocate new teletext workspace if required
        LDR     R0, [R13, #wkModeFlags]
        TST     R0, #ModeFlag_Teletext
        MOVNE   R0, R13
        BLNE    TeletextAlloc
        BVS     %FT07
        
        Push    R1                      ; save proper mode

        ; Vet the mode - both to make sure the driver really is happy with it,
        ; and to cope with drivers which want to switch to different framebuffer
        ; types
        ADD     R0, R13, #wkwordsize+4
        Push    "R2"
        BL      DoFullVetMode
        Pull    "R2"
        SUB     R13, R13, #12
        BEQ     %FT06                   ; not supported, complain
        TST     R0, #GVVetMode2_ExtraBytes_Invalid
        BNE     %FT06                   ; Service_ModeExtension should have made sure ExtraBytes was valid
        ; R0, R3, R5 may contain important info
        STMIA   R13, {R0, R3, R5}
        AND     R0, R0, #GVVetMode2_ResultMask
        CMP     R0, #GVVetMode2_Result_UnkFramestore
        BEQ     %FT08                   ; Driver doesn't know where mode is going to be, so we can't vet the memory requirement

        LDR     R11, [R13, #16 + wkScreenSize] ; get screen size for this mode
        MOV     R11, R11, LSL R2        ; total amount needed
        
        CMP     R0, #GVVetMode2_Result_SysFramestore
        BNE     %FT045
        
        MOV     R0, #2
        SWI     XOS_ReadDynamicArea
        SUBS    R1, R11, R1
        BLE     %FT08

; try to extend the amount of screen memory

        ! 0, "Need to fix ModeChangeSub to not leave CursorAddr, etc. pointing to unmapped pages during DA resize. Causes bad stuff should an abort occur/screen output be attempted!" ; Note that even enlarging the DA can leave the pointers in a bad state, due to the way the screen DA handler shuffles down/unmaps the lower mapping of VRAM before the higher copy is enlarged

        MOV     R0, #2                  ; expand screen memory
        SWI     XOS_ChangeDynamicArea
        BVC     %FT08
06
        ADD     R13, R13, #PushedInfoSize + 4*4 ; junk stacked info + mode no + vetmode2 info
        ADR     R0, ErrorBlock_BadMODE
      [ International
        BL      TranslateError
      ]
07
        SETV                            ; indicate error
        Pull    PC

045
        CMP     R11, R5
        BHI     %BT06                   ; ext. framestore not big enough

; valid mode and enough memory

08
        LDR     r0, [sp, #12]          ; restore mode we are using
        CMP     r0, #&100               ; if not mode selector
        BICCC   r0, r0, #&80            ; then knock off shadow bit
        BCC     %FT12

; it's a mode selector, so copy it to our static mode selector block

        LDR     r1, [WsPtr, #KernelModeSelector] ; point at block

        SUBS    r3, r0, r1              ; if r0 -> 1st mode block position
        TEQNE   r3, #4                  ; or r0 -> 2nd mode block position
        MOVEQ   r1, r0                  ; then use it in place
        BEQ     %FT09

        LDR     r3, [WsPtr, #DisplayModeNo] ; else check if current mode is a mode selector
        SUB     r3, r3, r1              ; r3 = offset from start of block
        CMP     r3, #8                  ; if 0 or 4
        EORCC   r3, r3, #4              ; then make 4 or 0 (ie toggle between them)
        ADDCC   r1, r1, r3              ; and add on base

        ASSERT  (ModeSelector_ModeVars+4) :AND: 7 = 0
09
        MOV     r3, #0
10
        LDR     r6, [r0, r3]            ; copy 1st word - after fixed bit this will be previous var value
        STR     r6, [r1, r3]
        ADD     r3, r3, #4
        LDR     r6, [r0, r3]            ; copy 2nd word - after fixed bit this will be next var index
        STR     r6, [r1, r3]
        ADD     r3, r3, #4
        CMP     r3, #ModeSelector_ModeVars + 4  ; only exit if we've done the essential bit
        CMPCS   r6, #-1                 ; AND we've had a -1 as the var index (NOT as the value)
        CMPCC   r3, #ModeSelector_MaxSize ; OR we've gone off the end of our block
        BCC     %BT10                   ; [we haven't, so loop]

        CMP     r3, #ModeSelector_MaxSize       ; if we did go off the end
        MOVCS   r6, #-1
        STRCS   r6, [r1, #ModeSelector_MaxSize-4] ; then terminate it properly

        MOV     r0, r1                  ; point at static block
12
        STR     R0, [WsPtr, #DisplayModeNo] ; store the new display mode

; now issue Service_ModeChanging

        MOV     R1, #Service_ModeChanging
        BL      IssueModeService

; R13 -> mode variables

13      LDR     R3, [R13, #16+wkScreenSize]
        STR     R3, [WsPtr, #ScreenSize] ; store screensize BEFORE calling
                                        ; ConvertBankToAddress (was a bug!)

        Push    "r0-r6"

; If driver handles memory allocation, must change mode before asking for memory
; (the case where we change mode after setting up the memory is only retained for backwards-compatibility, just in case something special like Aemulor is relying on it)

        LDR     r0, [sp, #7*4]
        AND     r0, r0, #GVVetMode2_ResultMask
        CMP     r0, #GVVetMode2_Result_SysFramestore
        BEQ     %FT581
        CMP     r0, #GVVetMode2_Result_ExtFramestore
        LDREQ   r0, [sp, #8*4]
        LDREQ   r1, [sp, #9*4]
        BEQ     %FT580
        ; Must be UnkFramestore
        ADD     R0, R13, #wkwordsize+7*4+16     ; R0 -> VIDCList3
        BL      HardwareModeChange        
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_FramestoreAddress
        BL      CallGraphicsV

580
; for mapping in, round start address down and size up to megabyte boundaries
; r0 = physical start, r1= size
; so frame buffer is wholly contained within the mapped in area
        MOV     r3, #1<<20                      ; 1 Megabyte
        SUB     r3, r3, #1                      ; convert to mask
        MOV     r4, r1                          ; remember what was asked for
        AND     r5, r0, r3                      ; and offset from megabyte base
        TST     r1, r3                          ; non integer megabyte?
        BIC     r2, r1, r3                      ; (clear the bits)
        ADDNE   r2, r2, #1<<20                  ; yes.. up to next megabyte
        BIC     r1, r0, r3                      ; ensure megabyte boundary at start
        MOV     r0, #13                         ; map in permanently
        ORR     r0, r0, #1:SHL:8                ; buffered, uncached
        ORR     r0, r0, #1:SHL:16+1:SHL:17      ; doubly map, access permission specified
        SWI     XOS_Memory
        BVS     %FT581
        ADD     r0, r1, r5                      ; reconstruct base phys address
        STR     r0, [WsPtr, #TrueVideoPhysAddr] ; and update our copy
        STR     r4, [WsPtr, #TotalScreenSize]   ; what we asked for
        ADD     r3, r3, r4                      ; compute end
        ADD     r3, r3, r5                      ; and allow offset dfrom start
        STR     r3, [WsPtr, #ScreenEndAddr]     ; actual screen end
        MOV     r14, #1
        B       %FT582

581
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #VideoPhysAddr]
        STR     r0, [WsPtr, #TrueVideoPhysAddr] ; Point TrueVideoPhysAddr at the base of screen DA
        MOV     r0, #2
        SWI     XOS_ReadDynamicArea
        STRVC   r1, [WsPtr, #TotalScreenSize]
        ADDVC   r0, r0, r1
        STRVC   r0, [WsPtr, #ScreenEndAddr]
        MOV     r14, #0
582
        Pull    "r0-r6"
        STRB    r14, [WsPtr, #ExternalFramestore]

        TEQ     R2, #0                  ; Shadowing or not ?
        LDR     R3, [WsPtr, #VduStatus]
        BICEQ   R3, R3, #Shadowing
        ORRNE   R3, R3, #Shadowing
        STR     R3, [WsPtr, #VduStatus]

        STRB    R2, [WsPtr, #ScreenMemoryClaimed] ; only allow ADFS to claim
                                        ; if non-shadow (simplifies things!)

        BL      ConvertBankToAddress    ; R3 := default start for this bank
        STR     R3, [WsPtr, #DriverBankAddr]
        STR     R3, [WsPtr, #DisplayBankAddr]

        LDR     R6, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
        STRB    R6, [R6, #OsbyteVars + :INDEX:MemDriver]  ; indicate default
        STRB    R6, [R6, #OsbyteVars + :INDEX:MemDisplay] ; for both of these

        LDR     R6, [R13, #16+wkModeFlags]
        STR     R6, [WsPtr, #DisplayModeFlags]

; initialise any values which SwitchOutput refers to

        LDR     R4, [R13, #16+wkLineLength]
        STR     R4, [WsPtr, #DisplayLineLength]

; now set up other mode variables by calling SwitchOutput

        ADD     R3, WsPtr, #VduSaveArea+InitFlag
        MOV     R2, #0
        STR     R2, [R3]                ; indicate uninitialised
        TST     R6, #ModeFlag_Teletext
        MOVNE   R3, #0                  ; if teletext, then no save area
        MOVEQ   R3, #1                  ; else MOS's save area
        MOV     R1, #0                  ; just in case
        MOV     R0, #SpriteReason_SwitchOutputToSprite
        SWI     XOS_SpriteOp

; now create other variables from simple ones

        LDR     R3, [WsPtr, #NColour]
        STR     R3, [WsPtr, #DisplayNColour]

        ASSERT  YWindLimit = XWindLimit +4
        ASSERT  DisplayYWindLimit = DisplayXWindLimit +4
        ADD     R0, WsPtr, #XWindLimit
        LDMIA   R0, {R3, R4}
        ADD     R0, WsPtr, #DisplayXWindLimit
        STMIA   R0, {R3, R4}

        ASSERT  YEigFactor = XEigFactor +4
        ASSERT  DisplayYEigFactor = DisplayXEigFactor +4
        ADD     R0, WsPtr, #XEigFactor
        LDMIA   R0, {R3, R4}
        ADD     R0, WsPtr, #DisplayXEigFactor
        STMIA   R0, {R3, R4}

        ASSERT  Log2BPP = Log2BPC +4
        ADD     R0, WsPtr, #Log2BPC
        LDMIA   R0, {R0, R1}                    ; R0 = Log2BPC; R1 = Log2BPP
        STRB    R1, [WsPtr, #DisplayLog2BPP]
        SUB     R3, R3, R0                      ; adjust XEig for double pixels
        ADD     R3, R3, R1
        STRB    R3, [WsPtr, #PointerXEigFactor]

        LDR     R3, [R13, #16+wkModeFlags]
        STR     R3, [WsPtr, #ModeFlags]

; finished doing other variables

; tell hardware to change mode, unless already done
        LDR     r0, [r13], #16
        AND     r0, r0, #GVVetMode2_ResultMask
        CMP     r0, #GVVetMode2_Result_UnkFramestore
        ADDNE   R0, R13, #wkwordsize            ; R0 -> VIDCList3
        BLNE    HardwareModeChange

        ADD     R13, R13, #PushedInfoSize       ; junk stacked data

        ; for backward compatibility, show that video DMA is enabled in
        ; MEMC soft copy (DON'T call OS_UpdateMEMC, which would also
        ; make redundant call to HAL)
        ;
        SavePSR R2
        LDR     R0, =ZeroPage
        WritePSRc SVC_mode+I_bit+F_bit, R14
        LDR     R1, [R0, #MEMC_CR_SoftCopy]
        ORR     R1, R1, #(1 :SHL: 10)
        STR     R1, [R0, #MEMC_CR_SoftCopy]
        RestPSR R2

        BL      SetVendDefault

        LDR     R1, [WsPtr, #ScreenEndAddr]     ; need to reload cos corrupt
        LDR     R2, [WsPtr, #TotalScreenSize]
        SUB     R0, R1, R2                      ; R0 = Vstart
        BL      SetVstart
        MOV     R0, #0
        STRB    R0, [WsPtr, #PointerShapeNumber]
        STR     R0, [WsPtr, #TeletextOffset]
        STR     R0, [WsPtr, #CursorStack]       ; restore cursor on a mode

        BL      PalInit                 ; set default palette
        BL      UnblankScreen
        BL      SetMouseRectangle
        BL      FF

        MOV     R1, #Service_ModeChange
        BL      IssueModeService

        CLRV                            ; indicate no error
        Pull    PC                      ; return to caller

; *****************************************************************************
;
;       HardwareModeChange - Tell the video driver to change the mode
;
; in:   R0 = VIDC list
;
; out:  All regs preserved
;

HardwareModeChange
        Push    "R0-R4, LR"

;remember pixel rate (kHz) and border settings from VIDCList3
;
        LDR     R2, [R0, #VIDCList3_PixelRate]
        STR     R2, [WsPtr, #PixelRate]
        LDR     R2, [R0, #VIDCList3_HorizLeftBorder]
        STR     R2, [WsPtr, #BorderL]
        LDR     R2, [R0, #VIDCList3_VertiBottomBorder]
        STR     R2, [WsPtr, #BorderB]
        LDR     R2, [R0, #VIDCList3_HorizRightBorder]
        STR     R2, [WsPtr, #BorderR]
        LDR     R2, [R0, #VIDCList3_VertiTopBorder]
        STR     R2, [WsPtr, #BorderT]

;remember DPMSState (if specified) from VIDCList3
;
        MOV     R2, #0                      ; DPMSState = 0 if not specified in list
        ADD     R1, R0, #VIDCList3_ControlList
20      LDR     R3, [R1], #8                ; loop over the control parameter list
        CMP     R3, #-1
        BEQ     %FT30                       ; didn't find the DPMSState entry
        TEQ     R3, #ControlList_DPMSState
        BNE     %BT20                       ; next control parameter
        LDR     R2, [R1, #-4]               ; read DPMSState value
        AND     R2, R2, #3                  ; only bits 0,1 valid
30
        STRB    R2, [WsPtr, #ScreenBlankDPMSState]

;kernel/HAL split - call the HAL to program video controller for mode,
;
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_SetMode
        BL      CallGraphicsV

        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        STR     R0, [WsPtr, #GraphicsVFeatures] ; refresh cached features just in case something's happened to change them
        BL      UpdateFalseVsync

; claim/release memory needed for software pointer
        TST     R0, #GVDisplayFeature_HardwarePointer
        LDR     R2, [WsPtr, #SWP_Under]
        BEQ     %FT40
        TEQ     R2, #0
        MOVNE   R0, #0
        STRNE   R0, [WsPtr, #SWP_Under]
        MOVNE   R0, #ModHandReason_Free
        SWINE   XOS_Module
        B       %FT50

40
        TEQ     R2, #0
        BNE     %FT50
        ; Claim maximum amount needed
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #32*32*4
        SWI     XOS_Module
        STRVC   R2, [WsPtr, #SWP_Under]
50
        ; Release mutex and reset state
        ; Note that we do this even if the pointer isn't needed, to ensure we
        ; don't get confused about its state
        MOV     R2, #0
        STR     R2, [WsPtr, #SWP_Pos]
        STRB    R2, [WsPtr, #SWP_Mutex]
        Pull    "R0-R4, PC"

        MakeErrorBlock BadMODE

        LTORG

; The following symbols, apart from being used in NColourTable,
; are also used in constructing mode selectors for mode numbers in VduModes

NColour_0       *       1
NColour_1       *       3
NColour_2       *       15
NColour_3       *       63
NColour_4       *       &FFFF
NColour_5       *       &FFFFFFFF

; *****************************************************************************
;
;       IssueModeService - Issue service (either ModeChanging or ModeChange)
;
; in:   R1 = service code
;
; out:  R1 corrupted
;

IssueModeService Entry "r2,r3"
        BL      ReadMonitorType
        LDR     r2, [WsPtr, #DisplayModeNo]
        IssueService
        EXIT

; *****************************************************************************
;
;       PushModeInfo - Push appropriate mode table and video controller params
;       onto stack, having generated it by possibly issuing service
;
; in:   R10 = mode to try for
;       R11 = mode to use if service not claimed (and R10 is mode number)
;       R10 and R11 should have bit 7 CLEAR (if mode numbers)
;
; out:  If r10 is an invalid mode selector or invalid new format sprite word then
;         V=1
;         r0 -> error
;         stack flat (no pushed info)
;       else
;         V=0
;         Stack holds a mode table (size wkwordsize) and VIDCList
;         type 3 (size VIDCList3Size) (total size PushedInfoSize)
;       endif
;       All other registers preserved
;

PushModeInfoAnyMonitor ROUT
        SUB     sp, sp, #PushedInfoSize
        Push    "r2-r4,r7-r11, lr"
        MOV     r3, #-1
        MOV     r7, #-1                 ; indicate no VIDC stuff necessary
        CMP     r10, #&100              ; is it a mode selector
        BCS     PushModeInfoCommonNoService
        BranchIfKnownMode r10, PushModeInfoCommonNoService
        B       PushModeInfoCommon

PushModeInfo ROUT
        SUB     sp, sp, #PushedInfoSize
        Push    "r2-r4,r7-r11, lr"
        MOV     r7, #0                  ; indicate VIDC stuff IS necessary
        BL      ReadMonitorType
PushModeInfoCommon
        MOV     r2, r10                 ; r2 = original mode
        BL      OfferModeExtension
        BEQ     %FT30                   ; [service claimed]

        CMP     r2, #&100               ; service not claimed - check if mode selector
        MOVCC   r10, r11                ; unrecognised mode number, so use substitute
        BCC     PushModeInfoCommonNoService

25
; service not claimed and it's a mode selector - return error "Screen mode not available"

        ADR     r0, ErrorBlock_ModeNotAvailable
26
  [ International
        BL      TranslateError
  ]
        B       %FT40

        MakeErrorBlock ModeNotAvailable

30
        TEQ     r4, #0                  ; if r4 returned zero, then a mode selector was used
                                        ; either initially or after translation from mode number
        BEQ     %FT35                   ; so no ws list
        LDR     r2, [r4, #4]!           ; else if claimed, then find ws base mode
        CMP     r2, #&100               ; if ws base mode is a mode selector, it's invalid
        ANDCC   r2, r2, #&7F            ; else knock off shadow bit
        BCC     %FT35
        MOV     r10, r11                ; invalid ws base mode, so pretend service not responded to

; and drop thru to PushModeInfoCommonNoService

PushModeInfoCommonNoService
        MOV     r2, r10                 ; else use provided mode
        MOV     r3, #0
        MOV     r4, #0
35
        ADD     r9, sp, #9*4            ; adjust for pushed registers
        CMP     r2, #&100
        BCC     %FT45
        BL      GenerateModeSelectorVars ; also copes with new sprite mode word
        BVC     %FT55

; we got an error

40
        SETV
        Pull    "r2-r4,r7-r11,lr"       ; restore registers
        ADD     sp, sp, #PushedInfoSize ; junk stack frame
        MOV     pc, lr                  ; exit VS, r0 -> error

45
        ADRL    r14, Vwstab
        LDR     r10, [r14, r2, LSL #2]
        ADD     r14, r14, r10           ; r14 -> mode table
        MOV     r10, #wkwordsize-4
50
        LDR     r2, [r14, r10]
        STR     r2, [r9, r10]
        SUBS    r10, r10, #4
        BCS     %BT50

; now change any variables specified in workspace block or mode selector overrides

55
        TEQ     r4, #0                  ; if service was claimed
        ADDNE   r4, r4, #4              ; then skip ws base mode
        BLNE    ProcessModeVarPairs


; hopefully, R7 is still set from up there to be NZ if no VIDC stuff necessary

        CMP     r7, #0
        Pull    "r2-r4,r7-r11, pc", NE  ; if no VIDC stuff required, exit (NB V=0 from CMP)

; mjs Kernel/HAL split
; pushed video controller info is now hardware independent, it is a VIDCList type 3

        TEQ     R3, #0                  ; if no module claimed service
        MOVEQ   R2, R11                 ; then use provided mode
        BEQ     %FT62
59
        ADD     R14, R9, #wkwordsize    ; R14 -> space for VIDCList3
        ASSERT  VIDCList3BaseSize = 64
        LDMIA   R3!, {R2,R4,R7-R11}     ; 28 bytes
        STMIA   R14!, {R2,R4,R7-R11}
        LDMIA   R3!, {R2,R4,R7-R11}     ; 56 bytes
        STMIA   R14!, {R2,R4,R7-R11}
        LDMIA   R3!, {R2,R4}            ; 64 bytes
        STMIA   R14!, {R2,R4}
        MOV     R10, #VIDCList3Size-(VIDCList3BaseSize+4) ; this much space left for control list items (excluding terminator)
60
        LDR     R8, [R3], #4
        SUBS    R10, R10, #8
        BLT     %FT65                   ; List too long, throw an error
        CMP     R8, #-1
        LDRNE   R9, [R3], #4
        STMNEIA R14!, {R8-R9}
        BNE     %BT60
        STR     R8, [R14]

        ; Recalculate LineLength, ScreenSize based on the contents of the VIDC
        ; list
        ADD     R9, SP, #9*4            ; adjust for pushed registers
        LDR     R2, [R9, #wkwordsize + VIDCList3_PixelDepth]
        LDR     R4, [R9, #wkwordsize + VIDCList3_HorizDisplaySize]
        MOV     R4, R4, LSL R2
        ADD     R4, R4, #7
        MOV     R4, R4, LSR #3
        ADD     R14, R9, #wkwordsize + VIDCList3_ControlList
        MOV     R10, #0
61
        LDMIA   R14!, {R7, R8}
        CMP     R7, #ControlList_ExtraBytes
        ADDEQ   R4, R4, R8
        CMP     R7, #ControlList_Interlaced
        MOVEQ   R10, R8
        CMP     R7, #ControlList_Terminator
        BNE     %BT61
        STR     R4, [R9, #wkLineLength]
        LDR     R2, [R9, #wkwordsize + VIDCList3_VertiDisplaySize]
        MOV     R2, R2, LSL R10         ; Calculate height from VIDC list too (YWindLimit may have been tampered with?)
        MUL     R2, R4, R2
        LDR     R4, [R9, #wkModeFlags]
        TST     R4, #ModeFlag_Teletext
        MOVNE   R2, R2, LSL #1          ; teletext ScreenSize is actually enough for two screens
        STR     R2, [R9, #wkScreenSize]

        CMP     R10, #0
        ORRNE   R4, R4, #ModeFlag_InterlacedMode
        STRNE   R4, [R9, #wkModeFlags]  ; Make sure interlace is flagged as such

        LDR     R2, [WsPtr, #GraphicsVFeatures]
        TST     R2, #GVDisplayFeature_HardwareScroll
        ORREQ   R4, R4, #ModeFlag_HardScrollDisabled
        STREQ   R4, [R9, #wkModeFlags]

        CLRV
        Pull    "R2-R4,R7-R11, PC"      ; done

62                                      ; arrive here if service not claimed, R2 = provided mode number
        ; XXX possible to exit earlier? (right after OfferModeExtension?)
        B       %BT25

65
        ADRL    r0, ErrorBlock_BuffOverflow
        B       %BT26

; *****************************************************************************
;
;       GenerateModeSelectorVars - Work out mode variables from mode selector
;                                    or new format sprite mode word
;
; Note: the algorithms used to generate these variables are duplicated in
; s.vdu.vduswis in the OS_ReadModeVariable code.

; in:   r2 = new format sprite word or pointer to mode selector
;       r9 -> stack frame to store vars in
;
; out:  If valid then
;           V=0
;           r0 preserved
;       else
;           V=1
;           r0 -> error
;       endif
;       All other registers preserved
;

GenerateModeSelectorVars Entry "r0,r1,r3-r8,r10-r12"
        ASSERT  ModeSelector_Flags = 0
        ASSERT  ModeSelector_XRes = 4
        ASSERT  ModeSelector_YRes = 8
        ASSERT  ModeSelector_PixelDepth = 12
        TST     r2, #1                          ; is it a new format sprite mode word?
        BNE     %FT10                           ; [yes, so skip]
        MOV     r0, r2
        BL      ValidateModeSelector
        BVS     %FT95                           ; invalid - return error
        LDMIB   r2, {r4-r6}                     ; r4 = xres; r5 = yres; r6 = pixdepth

        STR     r6, [r9, #wkLog2BPC]            ; log2bpc = log2bpp = pixdepth
        STR     r6, [r9, #wkLog2BPP]
        ADR     lr, NColourTable
        LDR     lr, [lr, r6, LSL #2]            ; load NColour value
        STR     lr, [r9, #wkNColour]

        MOV     lr, #0
        STR     lr, [r9, #wkYShftFactor]        ; yshftfactor = 0 (obsolete)
        STR     lr, [r9, #wkModeFlags]          ; modeflags = 0

        MOV     lr, #1
        STR     lr, [r9, #wkXEigFactor]         ; xeig = 1
        CMP     r5, r4, LSR #1                  ; if yres < xres/2
        MOVCC   r7, #2                          ; then yeig = 2
        MOVCS   r7, #1                          ; else yeig = 1
        STR     r7, [r9, #wkYEigFactor]

        RSB     r7, lr, r4, LSR #3              ; scrrcol = (xres >> 3) -1
        STR     r7, [r9, #wkScrRCol]
        RSB     r7, lr, r5, LSR #3              ; scrbrow = (yres >> 3) -1
        STR     r7, [r9, #wkScrBRow]

        SUB     r7, r4, #1
        STR     r7, [r9, #wkXWindLimit]         ; xwindlimit = xres-1
        SUB     r7, r5, #1
        STR     r7, [r9, #wkYWindLimit]         ; ywindlimit = yres-1

        MOV     r7, r4, LSL r6                  ; r7 = xres << pixdepth
        MOV     lr, r7, LSR #3
        STR     lr, [r9, #wkLineLength]         ; linelen = (xres << pixdepth) >> 3

        MUL     r7, r5, r7                      ; r7 = (xres * yres) << pixdepth
        MOV     lr, r7, LSR #3
        STR     lr, [r9, #wkScreenSize]         ; screensize = ((xres * yres) << pixdepth) >> 3

        ADD     r4, r2, #ModeSelector_ModeVars  ; now do pairs of mode variables
        BL      ProcessModeVarPairs

        ; Fixup teletext modes
        LDR     r0, [r9, #wkModeFlags]
        TST     r0, #ModeFlag_Teletext
        BEQ     %FT09
        ; Force the mode flags to be correct for our implementation
      [ HiResTTX
        ORR     r0, r0, #ModeFlag_NonGraphic+ModeFlag_GapMode+ModeFlag_DoubleVertical
      |
        BIC     r0, r0, #ModeFlag_DoubleVertical
        ORR     r0, r0, #ModeFlag_NonGraphic+ModeFlag_GapMode
      ]
        STR     r0, [r9, #wkModeFlags]
        ; Ensure colour depth is acceptable
        LDR     r0, [r9, #wkNColour]
        CMP     r0, #15
      [ HiResTTX
        ADRLOL  r0, ErrorBlock_BadPixelDepth
        BLO     %FT90
        CMP     r0, #63
        ADREQL  r0, ErrorBlock_BadPixelDepth
        BEQ     %FT90
      |
        ADRNEL  r0, ErrorBlock_BadPixelDepth
        BNE     %FT90
      ]
        ; Massage ScreenSize, needs to be large enough for two screen banks
        LDR     r0, [r9, #wkScreenSize]
        MOV     r0, r0, LSL #1
        STR     r0, [r9, #wkScreenSize]
        ; Clamp ScrRCol, ScrBRow
        LDR     r0, [r9, #wkScrRCol]
        CMP     r0, #254 ; TTXDoubleCounts is a byte array
        MOVHI   r0, #254
        LDR     r7, [r2, #ModeSelector_XRes]
        MOV     lr, #1
      [ HiResTTX
        RSB     r7, lr, r7, LSR #4
      |
        RSB     r7, lr, r7, LSR #3
      ]
        CMP     r0, r7
        MOVHI   r0, r7
        STR     r0, [r9, #wkScrRCol]
        LDR     r0, [r9, #wkScrBRow]
      [ HiResTTX
        DivRem  r7, r5, #20, lr, norem
      |
        DivRem  r7, r5, #10, lr, norem
      ]
        CMP     r0, r7
        SUBHS   r0, r7, #1
        STR     r0, [r9, #wkScrBRow]

        CLRV
        EXIT

09
        ; We only have double-vertical char plotting routines for 1bpp
        LDR     r0, [r9, #wkModeFlags]
        LDR     r1, [r9, #wkLog2BPP]
        LDR     r3, [r9, #wkLog2BPC]
        TST     r0, #ModeFlag_DoubleVertical
        BEQ     %FT091
        CMP     r1, #0
        ; Also can't mix double-vertical with double-pixel, since that would also require another char plotting routine
        CMPEQ   r3, #0
        ADRNEL  r0, ErrorBlock_BadPixelDepth
        BNE     %FT90
091
        ; We only support 2bpp BBC gap modes
        TST     r0, #ModeFlag_BBCGapMode
        CMPNE   r1, #1
        ADRNEL  r0, ErrorBlock_BadPixelDepth
        BNE     %FT90
        ; We don't support double-pixel modes higher than 16bpp (or regular modes higher than 32bpp)
        CMP     r3, #5
        ADRHIL  r0, ErrorBlock_BadPixelDepth
        BHI     %FT90

        CLRV
        EXIT


; store info for new format sprite word in stack frame

10
        MOV     r0, #0
        STR     r0, [r9, #wkYShftFactor]        ; yshftfactor = 0
        STR     r0, [r9, #wkModeFlags]          ; modeflags = 0

        AND     r0, r2, #15<<27                 ; get type
        CMP     r0, #SpriteType_RISCOS5<<27     ; RISC OS 5 type?
        BEQ     %FT50

        CMP     r0, #SpriteType_New64K<<27      ; 64K colour sprite?
        MOVEQ   r0, #ModeFlag_64k
        STREQ   r0, [r9, #wkModeFlags]          ; Make a note of it
        MOVEQ   r0, #SpriteType_New16bpp        ; ... and treat as regular 16bpp
        MOVNE   r0, r0, LSR #27

15
      [ NoARMT2
        MOV     r1, r2, LSL #(31-13)
        MOV     r1, r1, LSR #(31-13)+1          ; extract xdpi (bits 1..13)
      |
        UBFX    r1, r2, #1, #13                 ; extract xdpi (bits 1..13)
      ]

        TEQ     r1, #180                        ; 180 => xeig=0
        MOVEQ   r1, #0
        BEQ     %FT20

        TEQ     r1, #22                         ; 22/23 => xeig=3
        TEQNE   r1, #23
        MOVEQ   r1, #3
        BEQ     %FT20

        TEQ     r1, #(45 :SHL: 2), 2            ; check if 45   (EQ,CC if so)
        CMPNE   r1, #90                         ; or 90         (EQ,CS if so)
        BNE     %FT85
        MOVCC   r1, #2                          ; 45 => xeig=2
        MOVCS   r1, #1                          ; 90 => xeig=1
20
        STR     r1, [r9, #wkXEigFactor]

      [ NoARMT2
        MOV     r1, r2, LSL #(31-26)
        MOV     r1, r1, LSR #(31-26)+14         ; extract ydpi (bits 14..26)
      |
        UBFX    r1, r2, #14, #13                ; extract ydpi (bits 14..26)
      ]

        TEQ     r1, #180                        ; 180 => yeig=0
        MOVEQ   r1, #0
        BEQ     %FT21

        TEQ     r1, #22                         ; 22/23 => yeig=3
        TEQNE   r1, #23
        MOVEQ   r1, #3
        BEQ     %FT21

        TEQ     r1, #(45 :SHL: 2), 2            ; check if 45   (EQ,CC if so)
        CMPNE   r1, #90                         ; or 90         (EQ,CS if so)
        BNE     %FT85
        MOVCC   r1, #2                          ; 45 => yeig=2
        MOVCS   r1, #1                          ; 90 => yeig=1
21
        STR     r1, [r9, #wkYEigFactor]


25
        CMP     r0, #SpriteType_MAX             ; check for legality - NB type 0 is impossible here because r2>=&100
        MOVCS   r0, #SpriteType_Substitute      ; substitute if unknown
        ADRL    lr, NSM_bpptable-4
        LDR     r0, [lr, r0, LSL #2]            ; get the bpp from table

        ADR     r1, NColourTable
        LDR     r1, [r1, r0, LSL #2]
        STR     r1, [r9, #wkNColour]

30
        STR     r0, [r9, #wkLog2BPC]
        STR     r0, [r9, #wkLog2BPP]

        CLRV
        EXIT

50
        TST     r2, #&F0000                     ; validate RO 5 sprite mode word
        TSTEQ   r2, #&0000E
        MOVNE   r0, #SpriteType_Substitute      ; and try substitute if bad
        BNE     %BT15

      [ NoARMT2
        MOV     r1, r2, LSR #4
        AND     r1, r1, #3                      ; extract XEigFactor (bits 4..5)
      |
        UBFX    r1, r2, #4, #2                  ; extract XEigFactor (bits 4..5)
      ]
        STR     r1, [r9, #wkXEigFactor]

      [ NoARMT2
        MOV     r1, r2, LSR #6
        AND     r1, r1, #3                      ; extract YEigFactor (bits 6..7)
      |
        UBFX    r1, r2, #6, #2                  ; extract YEigFactor (bits 6..7)
      ]
        STR     r1, [r9, #wkYEigFactor]

        AND     r1, r2, #&FF00                  ; extract ModeFlags
        ; Validate ModeFlags. We only support RGB colourspace, so the only valid
        ; bits are the RGB and alpha flags
        TST     r1, #&FF00-(ModeFlag_DataFormatSub_RGB+ModeFlag_DataFormatSub_Alpha)
        MOVNE   r0, #SpriteType_Substitute      ; try the substitute?
        BNE     %BT15

        MOV     r0, r2, LSR #20
        ANDS    r0, r0, #127                    ; extract type
        MOVEQ   r0, #SpriteType_Substitute      ; type 0 isn't valid!

        CMP     r0, #SpriteType_New64K
        ORREQ   r1, r1, #ModeFlag_64k
        MOVEQ   r0, #SpriteType_New16bpp

        CMP     r0, #SpriteType_New16bpp        ; for palettised modes
        CMPLT   r0, r1                          ; flags must be zero
        MOVLT   r0, #SpriteType_Substitute
        BLT     %BT15

        STR     r1, [r9, #wkModeFlags]

        CMP     r0, #SpriteType_New4K
        BNE     %BT25

        LDR     r0, =4095
        STR     r0, [r9, #wkNColour]
        MOV     r0, #4
        B       %BT30

85
        ADR     r0, ErrorBlock_Sprite_BadDPI
90
 [ International
        BL      TranslateError
 ]
95
        STR     r0, [sp]                        ; update saved r0
        SETV                                    ; indicate error
        EXIT

NColourTable    &       NColour_0, NColour_1, NColour_2
                &       NColour_3, NColour_4, NColour_5
                &       NColour_5 ; CMYK sprite (not supported)
                &       NColour_5 ; 24bpp sprite (not supported)
                &       NColour_5 ; JPEG sprite (not supported)
                &       NColour_4 ; 64K sprite
                &       NColour_5, NColour_5, NColour_5, NColour_5, NColour_5 ; sprite types 11-15
                &       4095 ; 4K sprite
                &       NColour_5, NColour_5 ; YCbCr 422 & 420 (not supported)
                ASSERT  . - NColourTable = (SpriteType_RO5MAX-1)*4

        MakeErrorBlock  BadPixelDepth
        MakeErrorBlock  Sprite_BadDPI

; *****************************************************************************
;
;       ValidateModeSelector - Check a mode selector is valid
;
; in:   r0 -> mode selector
;
; out:  If OK, then
;         V=0
;         All registers preserved
;       else
;         V=1
;         r0 -> error
;         All other registers preserved
;       endif
;

ValidateModeSelector Entry
        LDR     lr, [r0, #ModeSelector_Flags]
        AND     lr, lr, #ModeSelectorFlags_FormatMask
        TEQ     lr, #ModeSelectorFlags_ValidFormat
        ADRNE   r0, ErrorBlock_BadMSFlags
        BNE     %FT90
        LDR     lr, [r0, #ModeSelector_PixelDepth]
        CMP     lr, #6
        ADRCS   r0, ErrorBlock_BadPixelDepth
        BCS     %FT90
        CLRV
        EXIT

90
  [ International
        BL      TranslateError
  |
        SETV
  ]
        EXIT

        MakeErrorBlock BadMSFlags


; *****************************************************************************
;
;       ProcessModeVarPairs - Modify stacked variable info from
;                              mode variable (index, value) pairs
;
;       Internal routine used to do Service_ModeExtension workspace lists and
;        mode selectors
;
; in:   r4 -> first pair (may be none)
;       r9 -> stack frame
;
; out:  All registers preserved

ProcessModeVarPairs Entry "r4, r8, r10"
        ADRL    r14, RMVTab
10
        LDR     r10, [r4], #4           ; get next entry in ws table
        CMP     r10, #-1
        EXIT    EQ                      ; no more to do
        CMP     r10, #(SWIRVVTabModeEnd-SWIRVVTab) ; is it a mode variable ?
        BCS     %BT10                   ; no, then ignore
        LDRB    r10, [r14, r10]         ; load index out of RMVTab
        MOVS    r10, r10, LSR #1        ; shift byte/word flag into carry
        LDR     r8, [r4], #4            ; load value
        STRCCB  r8, [r9, r10]           ; either store byte
        STRCS   r8, [r9, r10]           ; or store word
        B       %BT10

; *****************************************************************************
;
;       OfferModeExtension - Issue mode extension service
;
; in:   R2 = mode specifier
;       R3 = monitor type
;
; out:  EQ => service claimed, R3 -> VIDC list, R4 -> workspace list
;       NE => service not claimed, R3,R4 preserved
;       All other registers preserved
;

OfferModeExtensionAnyMonitor ROUT
        MOV     r3, #-1
OfferModeExtension ROUT
        Push    "r1,r2,r4,r5,r14"

; TMD 10-Jan-94 - added code here to check for erroneous passing in of a sprite mode word.
; This prevents data aborts when modules try to index off a bad address.
;
; We could have done OS_ValidateAddress, but that would be rather slow, and mode selectors
; are of indeterminate length.
;
; If we detect one of these, we pretend the service wasn't claimed. Hopefully this should
; ensure that the mode change returns an error.

; Fixes bug MED-00483.

        BICS    r14, r2, #&FF                   ; NE if not a mode number
        TSTNE   r2, #3                          ; NE if not a mode number, but invalid mode selector
        Pull    "r1,r2,r4,r5,pc", NE            ; so exit NE, pretending that service not claimed

        GetBandwidthAndSize     r4, r5
        MOV     r1, #Service_ModeExtension
        IssueService
        TEQ     r1, #0                          ; if service claimed
        CMPNE   r3, #-1                         ; or if "don't care" monitortype
        BEQ     %FT90                           ; then we can't do any more

        CMP     r2, #&100                       ; if it's a mode selector
        BCS     %FT90                           ; then we can't help them either
        BranchIfNotKnownMode r2, %FA90          ; if we don't recognise screen mode number we can't either

; it is a known numbered mode, so create a mode selector on the stack that we can pass to service

        Push    "r6,r7"
        SUB     sp, sp, #ModeSelector_ModeVars+4        ; make room for block including terminator
        ADRL    r6, Vwstab
        LDR     r14, [r6, r2, LSL #2]
        ADD     r6, r6, r14
        BL      ModeNumberToModeSelector                ; R1, R7 corrupt
        MOV     r1, #Service_ModeExtension

        MOV     r2, sp
        IssueService
        TEQ     r1, #0
        BEQ     %FT10                                   ; service was claimed

; not claimed, so try again with -1 as frame rate

        MOV     r7, #-1
        STR     r7, [sp, #ModeSelector_FrameRate]
        IssueService
        TEQ     r1, #0
10
        ADD     sp, sp, #ModeSelector_ModeVars+4        ; junk mode selector
        Pull    "r6, r7"
90
        CMP     r2, #&100                               ; if we started or ended up with a mode selector
        MOVCS   r4, #0                                  ; then return r4 = 0 (if claimed)

        TEQ     r1, #0
        STREQ   r4, [sp, #2*4] ; if service claimed, then return r4 from service, else preserve it
        Pull    "r1,r2,r4,r5,pc"


; *****************************************************************************
;
; ETB - Redefine character
; ===   & other stuff
;
;       VDU 23,0,r,v,0|         Talk to 6845 !
;       VDU 23,1,n,m,r,g,b|     Program cursor
;       VDU 23,2,n1..n8         Ecf pattern 1
;       VDU 23,3,n1..n8         Ecf pattern 2
;       VDU 23,4,n1..n8         Ecf pattern 3
;       VDU 23,5,n1..n8         Ecf pattern 4
;       VDU 23,6,n1..n8         Dot dash line style
;       VDU 23,7,m,d,z|         Scroll window directly
;       VDU 23,8,t1,t2,x1,y1,x2,y2|     Clear block
;       VDU 23,9,n|             Set 1st flash time
;       VDU 23,10,n|            Set 2nd flash time
;       VDU 23,11|              Default Ecf patterns
;       VDU 23,12,n1..n8        Ecf pattern 1 (simple setting)
;       VDU 23,13,n1..n8        Ecf pattern 2 (simple setting)
;       VDU 23,14,n1..n8        Ecf pattern 3 (simple setting)
;       VDU 23,15,n1..n8        Ecf pattern 4 (simple setting)
;       VDU 23,16,x,y|          Cursor movement control
;       VDU 23,17,c,t|          Set colour tints, ECF info, char sizes
;
;
ETB
        LDRB    R0, [WsPtr, #QQ+0]
        CMP     R0, #32         ; defining a normal character ?
        BCS     DefineChar
        LDR     R2, [PC, R0, LSL #2]
        ADD     PC, PC, R2      ; enters routine with R0 => byte after 23


ETBtab
        &       Vdu23_0-ETBtab-4
        &       Vdu23_1-ETBtab-4
        &       ComplexEcfPattern-ETBtab-4
        &       ComplexEcfPattern-ETBtab-4
        &       ComplexEcfPattern-ETBtab-4
        &       ComplexEcfPattern-ETBtab-4
        &       LineStyle-ETBtab-4
        &       Vdu23_7-ETBtab-4
        &       Vdu23_8-ETBtab-4
        &       Vdu23_9-ETBtab-4
        &       Vdu23_10-ETBtab-4
        &       DefaultEcfPattern-ETBtab-4
        &       SimpleEcfPattern-ETBtab-4
        &       SimpleEcfPattern-ETBtab-4
        &       SimpleEcfPattern-ETBtab-4
        &       SimpleEcfPattern-ETBtab-4
        &       Vdu23_16-ETBtab-4
        &       Vdu23_17-ETBtab-4
        &       Vdu23_18-ETBtab-4
        &       Vdu23_19-ETBtab-4
        &       Vdu23_20-ETBtab-4
        &       Vdu23_21-ETBtab-4
        &       Vdu23_22-ETBtab-4
        &       Vdu23_23-ETBtab-4
        &       Vdu23_24-ETBtab-4
        &       Vdu23_25-ETBtab-4
        &       Vdu23_26-ETBtab-4
        &       Vdu23_27-ETBtab-4
        &       Vdu23_28-ETBtab-4
        &       Vdu23_29-ETBtab-4
        &       Vdu23_30-ETBtab-4
        &       Vdu23_31-ETBtab-4

; NB All other labels for Vdu23 are in TMD files so I don't have to pester RCM

;Vdu23_18       ; Assigned to Teletext operations
Vdu23_19
Vdu23_20
Vdu23_21
Vdu23_22
Vdu23_23
Vdu23_24
Vdu23_25
Vdu23_26
; Vdu23_27      ; Assigned to Richard (well some of it, anyway)
Vdu23_28
Vdu23_29
Vdu23_30
Vdu23_31
UnknownVdu23

; R0 already contains first parameter to VDU23

        MOV     R10, #UKVDU23V
        Push    "WsPtr, R14"            ; calling a vector corrupts R12
        BL      VduQQVec                ; so we have to preserve it
        Pull    "WsPtr, PC", VC         ; before we return to PostWrchCursor

; error in UKVDU23 vector, so go to vdu error exit

        Pull    "WsPtr, R14"
        B       VduBadExit

; *****************************************************************************
;
; DLE
; CLG - Clear graphics window
; ===
;
; On exit, R0..R11 corrupt
;
DLE
CLG     ROUT
        GraphicsMode R0
        MOVNE   PC,LR                   ; check for graphics mode (changed by DDV 15/9/92)

        ADD     R0, WsPtr, #BgEcfOraEor ; point at background colour
        STR     R0, [WsPtr, #GColAdr]
        ADD     R11, WsPtr, #GWLCol     ; load window coordinates into
        LDMIA   R11, {R0-R3}            ; RectFill's parameter space

        LDR     R6, [WsPtr, #CursorFlags] ; if clip box is not enabled
        TST     R6, #ClipBoxEnableBit   ; then goto code directly
        BEQ     RectFillA

        Push    R14                     ; else merge graphics window (in R0-R3)
        BL      MergeClipBox            ; with clip box
        Pull    R14
        B       RectFillA

; *****************************************************************************
;
; DC2
; GCol - Set Graphics action and colour
; ====
;
; On entry, R0 holds GCol action
;           R1 holds GCol colour, 0..127 means program fg
;                                 128..255 means program bg
;
; In 256-colour modes, the extra colours are accessed via TINT
;
DC2
GCol    ROUT
        LDRB    R0, [WsPtr, #QQ+0]      ; GCol action, eg store, eor etc.
        LDRB    R1, [WsPtr, #QQ+1]      ; GCol colour
        LDR     R2, [WsPtr, #NColour]   ; number of colours-1
        TST     R1, #&80
        AND     R1, R1, R2              ; limit colour to range available

        STREQ   R0, [WsPtr, #GPLFMD]    ; GCOL(a,0..127) is foreground
        STREQ   R1, [WsPtr, #GFCOL]

        STRNE   R0, [WsPtr, #GPLBMD]    ; GCOL(a,128..255) is background
        STRNE   R1, [WsPtr, #GBCOL]
                                        ; drop into SetColour to....

; SetColour - Setup FgEcf & BgEcf, used after GCOL or setting of Ecfs
; =========   or default palette (does a gcol).

SetColour
        Push    R14
        LDR     R1, [WsPtr, #GPLFMD]    ; setup FgEcf, maybe solid or Ecf
        LDR     R0, [WsPtr, #GFCOL]
        ADD     R2, WsPtr, #FgEcf
        LDR     R3, [WsPtr, #GFTint]    ; tint only used in 256 colour modes
        ADD     R4, WsPtr, #FgPattern   ; used if OS_SetColour call
        BL      SetCol10

        LDR     R1, [WsPtr, #GPLBMD]    ; and BgEcf
        LDR     R0, [WsPtr, #GBCOL]
        ADD     R2, WsPtr, #BgEcf
        LDR     R3, [WsPtr, #GBTint]
        ADD     R4, WsPtr, #BgPattern   ; used if OS_SetColour call
        BL      SetCol10

        ADD     R0, WsPtr, #FgEcf       ; setup FgEcfOraEor
        ADD     R1, WsPtr, #BgEcf
        ADD     R2, WsPtr, #FgEcfOraEor
        LDR     R3, [WsPtr, #GPLFMD]
        BL      SetCol60

        ADD     R0, WsPtr, #BgEcf       ; and BgEcfOraEor
        ADD     R1, WsPtr, #FgEcf
        ADD     R2, WsPtr, #BgEcfOraEor
        LDR     R3, [WsPtr, #GPLBMD]
        BL      SetCol60

        ADD     R0, WsPtr, #BgEcf       ; and BgEcfStore
        ADD     R1, WsPtr, #FgEcf
        ADD     R2, WsPtr, #BgEcfStore
        MOV     R3, #0
        BL      SetCol60

        Pull    PC

; SetCol10 - Internal to SetColour
;          Build up an Ecf, given action and colour numbers
;
; On entry, R0 holds colour (0..255, where 127..255 means 0..127)
;           R1 holds action (may indicate ecf)
;           R2 holds address to write data (FgEcf or BgEcf)
;           R3 holds tint information (only used in 256 colour modes)
;           R4 holds pointer to suitable pattern table for OS_SetColour call

SetCol10 ROUT
        ANDS    R1, R1, #&F0            ; actions >=16 mean Ecf
        BNE     SetCol30

        Push    R14
        LDR     R4, [WsPtr, #NColour]   ; else use given colour number
        AND     R0, R0, R4
        AND     R0, R0, #63             ; another bodge in the house of bodges
        TST     R4, #&F0                ; if 256 colour (ie 8bpp)
        BLNE    AddTintToColour         ; then combine tint with colour

; R0 contains colour number for current mode

        LDR     LR, [WsPtr, #BitsPerPix]
10
        TEQ     LR, #32
        ORRNE   R0, R0, R0, LSL LR      ; replicate again
        MOVNE   LR, LR, LSL #1          ; doubling the shift for each pass
        BNE     %BT10

        STR     R0, [R2]
        STR     R0, [R2, #4]
        STR     R0, [R2, #8]
        STR     R0, [R2, #12]
        STR     R0, [R2, #16]
        STR     R0, [R2, #20]
        STR     R0, [R2, #24]
        STR     R0, [R2, #28]

        Pull    "PC"

; R1 = ecf number as 16,32,48,64,80,96
; R2 -> destination
; R4 -> pattern block (if R1 =96!)

SetCol30
        CMP     R1, #96                 ; special internal plot?
        MOVCS   R0, R4                  ; yes, so point at pattern to be copied
        MOVCS   R3, #1                  ; col step =1
        MOVCS   R4, #0                  ; row step =0 (already there!)
        BCS     SetCol35

        CMP     R1, #80                 ; 80 => giant ecf (>80 does same)
        ADDCS   R0, WsPtr, #Ecf1        ; then point at ecf0
        MOVCS   R3, #8                  ; col step=8
        MOVCS   R4, #(1-8*4)            ; row step, back to 1st ecf on 1 byte
        BCS     SetCol35

        ADD     R0, WsPtr, #(Ecf1-8)
        ADD     R0, R0, R1, LSR #1      ; else point R0 at Ecf1,2,3 or 4

        LDR     R4, [WsPtr, #BitsPerPix]
        CMP     R4, #16
        BHI     SetCol45
        BEQ     SetCol40
        LDR     R5, [WsPtr, #BytesPerChar]
        TEQ     R4, R5                  ; if BitsPerPix <> 'fudged' BitsPerPix
        BNE     SetCol52                ; then double up the pixels
                                        ; else its a normal Ecf
        MOV     R3, #0                  ; col step=0, same byte each coloum
        MOV     R4, #1                  ; row step=1
SetCol35
        MOV     R5, #8                  ; do 8 rows
SetCol36
        MOV     R6, #4                  ; of 4 columns
SetCol37
        LDRB    R7, [R0], R3            ; read from source & move by col step
        STRB    R7, [R2], #1            ; write to dest, update dest pointer
        SUBS    R6, R6, #1
        BNE     SetCol37
        ADD     R0, R0, R4              ; step source pointer to next row
        SUBS    R5, R5, #1
        BNE     SetCol36
        MOV     PC, R14

; Generate 1x4 pattern for 16bpp
;
; R0 points to Ecf(n)
; R2 points to destination
;
; Uses R0,R2,R5,R6,R7
;
SetCol40
        LDMIA   R0, {R0,R6}             ; Grab full pattern block
        EOR     R5, R0, R0, ROR #16     ; &22221111 ^ &11112222
        EOR     R7, R6, R6, ROR #16
        EOR     R0, R0, R5, LSL #16     ; = &11111111
        EOR     R6, R6, R7, LSL #16
        EOR     R5, R5, R0              ; = &22222222
        EOR     R7, R7, R6
        STMIA   R2!,{R0,R5,R6,R7}       ; Store 4 rows
        STMIA   R2!,{R0,R5,R6,R7}       ; 8 rows
        MOV     PC, R14

; Generate 1x2 pattern for 32bpp
;
; R0 points to Ecf(n)
; R2 points to destination
;
; Uses R0,R2,R5,R6,R7
;
SetCol45
        LDMIA   R0, {R0,R5}
        MOV     R6,R0
        MOV     R7,R5
        STMIA   R2!,{R0,R5,R6,R7}
        STMIA   R2!,{R0,R5,R6,R7}
        MOV     PC, R14

; Double up the pixels for Mode2 etc
;
; R0 points to Ecf(n)
; R2 points to destination
;
; Uses
;
;     R3  - NColour used as PixMsk
;     R4  - BitsPerPix
;     R5  - BytesPerChar (unused)
;     R6  - byte cntr 7..0
;     R7  - source byte
;     R8  - ExtrtShftFact
;     R9  - InsrtShftFact
;     R10 - result word
;     R11 - temp

SetCol52
        LDR     R3, [WsPtr, #NColour]   ; mask for extracting pixels from ecf
        TST     R3, #&F0                ; ** if 256 colour mode
        MOVNE   R3, #&FF                ; ** then use &FF (TMD 25-Mar-87)
        LDR     R4, [WsPtr, #BitsPerPix]
        MOV     R6, #7                  ; 8 bytes/rows to do
SetCol54
        LDRB    R7, [R0, R6]            ; get byte of Ecf(n)
        RSB     R8, R4, #8
        RSB     R9, R4, #32
        MOV     R10, #0                 ; clear result word
SetCol57
        AND     R11, R3, R7, ROR R8     ; extract 1 pixel from Ecf
        ORR     R10, R10, R11, LSL R9   ; double it into result word
        SUB     R9, R9, R4
        ORR     R10, R10, R11, LSL R9

        SUB     R8, R8, R4
        AND     R8, R8, #7

        SUBS    R9, R9, R4
        BGE     SetCol57                ; process next pixel in result word

        STR     R10, [R2, R6, LSL #2]   ; write expanded word to (Fg/Bg)Ecf

        SUBS    R6, R6, #1
        BGE     SetCol54                ; process next row/byte
        MOV     PC, R14

; Tables of full colours for 2,4 & 16 colour modes (256 colour modes
; use colour number directly).
;
; N.B. these are tables of bytes

TBFullCol
        =       &FF                     ; not used - remove sometime
                                        ; (DJS comment: don't bother!)
        =       &00, &FF                ; 2 colour mode
        =       &00, &55, &AA, &FF      ; 4 colour mode

        =       &FF, &FF, &FF, &FF      ; not used but cannot be removed
        =       &FF, &FF, &FF, &FF      ; (8 colour mode!)

        =       &00, &11, &22, &33      ; 16 colour mode
        =       &44, &55, &66, &77
        =       &88, &99, &AA, &BB
        =       &CC, &DD, &EE, &FF

        ALIGN

; *****************************************************************************
;
;       SetCol60 - Build up an ecf, ORed and EORed appropriate to GCOL action
;
;       Internal to SetColour
;
; in:   R0 -> ecf colour (FgEcf/BgEcf)
;       R1 -> transparent colour (BgEcf/FgEcf)
;       R2 -> destination FgEcfOraEor/BgEcfOraEor/BgEcfStore
;       R3 = gcol action number (may indicate ecf)
;
; uses: R4 = index into ecf (7..0)
;       R5 = ecf colour word
;       R6 = transparency mask, set to &FFFFFFFF for NO transparency
;       R7 -> zgoo..zgee for gcol action
;       R8 = mask for pixel under examination
;       R9 = shift factor to move mask to next pixel (BytesPerChar)
;       R10, R11 temporary
;

SetCol60 ROUT
        MOV     R4, #7                          ; 7..0 words to process
        AND     R3, R3, #&F                     ; extract action bits
        AND     R11, R3, #7                     ; 0-7 Store etc
                                                ; 8-15 ditto with transparency
        MOV     R11, R11, LSL #2                ; 4 bits for each
        LDR     R7, =TBscrmasks
        MOV     R7, R7, ROR R11                 ; relevant bits are in top 4
        AND     R7, R7, #&F0000000              ; isolate these bits (N,Z,C,V)
SetCol70
        LDR     R5, [R0, R4, LSL #2]            ; get ecf word
        TST     R3, #8                          ; if action < 8
        MOVEQ   R6, #&FFFFFFFF
        BEQ     SetCol90                        ; then not transparent
                                                ; else build transparency mask
        LDR     R8, [WsPtr, #RAMMaskTb]         ; fetch mask for leftmost pixel
        LDR     R9, [WsPtr, #BytesPerChar]      ; shift factor for next pixel
        LDR     R6, [R1, R4, LSL #2]            ; get 'transparent' colour
        EOR     R6, R6, R5
SetCol80
        TST     R6, R8                          ; if pixels the same,
                                                ; then it's transparent
        ORRNE   R6, R6, R8                      ; else set mask to plot it
        MOVS    R8, R8, LSL R9
        BNE     SetCol80

SetCol90
        MSR     CPSR_f, R7                      ; put bits into N, Z, C, V
                                                ;              OO,EO,OE,EE

        MOVCC   R10, R5                         ; if ORing with &00000000
        MOVCS   R10, #&FFFFFFFF                 ; if ORing with &FFFFFFFF
        MVNVS   R10, R10                        ; if EORing with &FFFFFFFF

;       MOVPL   R5, R5                          ; if ORing with &00000000
        MOVMI   R5, #&FFFFFFFF                  ; if ORing with &FFFFFFFF
        MVNEQ   R5, R5                          ; if EORing with &FFFFFFFF

; now R5 = OR mask, R10 = EOR mask

        AND     R5, R5, R6                      ; then clear 'transparent'
        AND     R10, R10, R6                    ; pixels

        LDR     R11, [WsPtr, #ECFShift]
        MOV     R5, R5, ROR R11                 ; rotate OR and EOR masks
        MOV     R10, R10, ROR R11               ; to correct for ECF X origin

        LDR     R11, [WsPtr, #ECFYOffset]
        ADD     R11, R11, R4                    ; add on ECF Y offset
        AND     R11, R11, #7                    ; and wrap

        ADD     R11, R2, R11, LSL #3
        STMIA   R11, {R5, R10}                  ; write to (Fg/Bg)EcfOraEor

        SUBS    R4, R4, #1
        BCS     SetCol70

        MOV     PC, R14

; *****************************************************************************
;
;       AddTintToColour - in 256 colour modes
;
;       Internal to SetColour (derived from TMD's FudgeColour)
;
; in:   R0 = colour (0..255), where 6 LSBits are used
;       R3 = tint
;
; out:  R0 holds colour byte with tint added
;       R1-R3 preserved
;       R4 undefined
;       PSR preserved
;

        !       0,"WARNING: AddTintToColour returns > 8 bit values now, check ECF handling!"

AddTintToColour
        Push    "R3,LR"
        AND     R0, R0, #63             ; extract suitable set of bits
        AND     R3, R3, #192            ; and another set
        ORR     R0, R0, R3
        BL      ConvertGCOLToColourNumber
        Pull    "R3,PC"

; *****************************************************************************
;
;       CAN - Define graphics window
;
;       External routine
;
; in:   The window is given by bytes in the vdu queue, as follows :-
;         QQ+0 = leftLo
;         QQ+1 = leftHi
;         QQ+2 = bottomLo
;         QQ+3 = bottomHi
;         QQ+4 = rightLo
;         QQ+5 = rightHi
;         QQ+6 = topLo
;         QQ+7 = topHi
;
;       These are relative to the current graphics origin.
;       The resultant window must obey the following rules :-
;         RCol >= LCol
;         TRow >= BRow
;         LCol >= 0
;         BRow >= 0
;         YWindLimit >= TRow
;         XWindLimit >= RCol
;

CAN     ROUT
        Push    R14
        ADD     R8, WsPtr, #GCsX        ; save ECursor away, cos EIG changes it
        LDMIA   R8, {R6, R7}            ; and we don't want it to!

; *****Change made by DJS
; Original code was:
;        LDRB    R0, [WsPtr, #QQ+5]      ; rightHi
;        LDRB    R1, [WsPtr, #QQ+4]      ; rightLo
;        PackXtnd R0,R0,R1               ; pack 2 bytes and sign extend
;
;        LDRB    R1, [WsPtr, #QQ+7]      ; topHi
;        LDRB    R2, [WsPtr, #QQ+6]      ; topLo
;        PackXtnd R1,R1,R2               ; pack 2 bytes and sign extend

        LoadCoordPair R0, R1, WsPtr, QQ+4 ;Get top right point

; *****End of change made by DJS

        MOV     R2, #&FF                ; convert external-to-internal
        BL      EIG                     ; as absolute coordinates

        MOV     R4, R0                  ; move internal version of top right
        MOV     R5, R1                  ; out of harm's way

; *****Change made by DJS
; Original code was:
;        LDRB    R0, [WsPtr, #QQ+1]      ; leftHi
;        LDRB    R1, [WsPtr, #QQ+0]      ; leftLo
;        PackXtnd R0,R0,R1               ; pack 2 bytes and sign extend
;
;        LDRB    R1, [WsPtr, #QQ+3]      ; bottomHi
;        LDRB    R2, [WsPtr, #QQ+2]      ; bottomLo
;        PackXtnd R1,R1,R2               ; pack 2 bytes and sign extend

        LoadCoordPair R0, R1, WsPtr, QQ+0 ;Get bottom left point

; *****End of change made by DJS

        MOV     R2, #&FF                ; convert external-to-internal
        BL      EIG                     ; as absolute coordinates

; For a valid window, the following must be true

        CMP     R4, R0                          ;  RCol >= LCol
        CMPGE   R5, R1                          ;  TRow >= BRow
        CMPGE   R0, #0                          ;  LCol >= 0
        CMPGE   R1, #0                          ;  BRow >= 0
        LDRGE   R2, [WsPtr, #YWindLimit]        ;  YWindLimit >= TRow
        CMPGE   R2, R5
        LDRGE   R2, [WsPtr, #XWindLimit]        ;  XWindLimit >= RCol
        CMPGE   R2, R4

        ADD     R2, WsPtr, #GWLCol
        STMGEIA R2, {R0,R1, R4,R5}      ; if the new window is OK, update it

        STMIA   R8, {R6, R7}            ; restore ECursor (EIG corrupted it)
        Pull    PC

; *****************************************************************************
;
;       DefaultWindows - Restore default windows
;
;       External routine, and called by mode change + switch output to sprite
;
;       Set default text and graphics windows,
;       Clear graphics origin and both cursors
;

DefaultWindows ROUT
        Push    R14
        MOV     R0, #0
        MOV     R1, #0
        ADD     R4, WsPtr, #GWLCol

        ASSERT  YWindLimit = XWindLimit +4

        ADD     R2, WsPtr, #XWindLimit
        LDMIA   R2, {R2,R3}     ; R2 := XWindLimit; R3 := YWindLimit
        STMIA   R4, {R0-R3}     ; zero GWLCol, GWBRow
                                ; GWRCol:=XWindLimit; GWTRow:=YWindLimit
        MOV     R3, #0
        LDR     R1, [WsPtr, #ScrBRow]
        LDR     R2, [WsPtr, #ScrRCol]
        ADD     R4, WsPtr, #TWLCol      ; zero TWLCol, TWTRow
        STMIA   R4!, {R0-R3}            ; TWRCol := ScrRCol; TWBRow := ScrBRow

        MOV     R1, #0
        MOV     R2, #0
        STMIA   R4!, {R0-R3}    ; zero OrgX, OrgY, GCsX, GCsY
        STMIA   R4!, {R0-R3}    ; zero OlderCsX, OlderCsY, OldCsX, OldCsY
        STMIA   R4!, {R0-R3}    ; zero GCsIX, GCsIY, NewPtX, NewPtY

        LDR     R0, [WsPtr, #VduSprite]
        TEQ     R0, #0

        LDR     R0, [WsPtr, #VduStatus]         ; if not outputting to sprite
        BICEQ   R0, R0, #Windowing              ; then indicate no text window
        ORRNE   R0, R0, #Windowing              ; else indicate is text window
        STR     R0, [WsPtr, #VduStatus]

        BL      HomeVdu4                        ; home TEXT cursor
                                                ; (even in VDU 5 mode)
        Pull    PC

; *****************************************************************************
;
;       GS - Define graphics origin
;
;       External routine
;
; in:   The origin is given by bytes in the vdu queue, as follows :-
;         QQ+0 = xLo
;         QQ+1 = xHi
;         QQ+2 = yLo
;         QQ+3 = yHi
;
;       The coordinates are in external 16 bit form.
;       This does not move the windows, but does move the graphics cursor
;

GS      ROUT
        Push    R14

; *****Change made by DJS
; Original code was:
;        LDRB    R0, [WsPtr, #QQ+1]      ; xHi
;        LDRB    R1, [WsPtr, #QQ+0]      ; xLo
;        PackXtnd R0,R0,R1               ; pack 2 bytes and sign extend
;        LDRB    R1, [WsPtr, #QQ+3]      ; yHi
;        LDRB    R2, [WsPtr, #QQ+2]      ; yLo
;        PackXtnd R1,R1,R2               ; pack 2 bytes and sign extend

        LoadCoordPair R0, R1, WsPtr, QQ+0

; *****End of change made by DJS

        ADD     R2, WsPtr, #OrgX
        STMIA   R2, {R0,R1}             ; write the new origin
        BL      IEG                     ; update external cursor
        Pull    PC

        LTORG

;------------------------------------------------------------------------------
;
; OS_SetColour implementation
; ------------
;
; This call can be used to change the current GCOL/pattern table used for
; plotting with the VDU primitives.
;
; in    R0 = flags / logical operation
;               bit 0-3 = logical operation
;               bit 4   = set => bg, else fg flag
;               bit 5   = set => pattern block supplied
;               bit 6   = set => set text colour
;               bit 7   = set => read colour
;       R1 = colour number / -> pattern block to use
; out   -
;
;------------------------------------------------------------------------------

setcol_LogicOpMask      * &0F
setcol_FgBgFlag         * &10
setcol_PatternFlag      * &20
setcol_TextColour       * &40
setcol_ReadFlag         * &80

        ASSERT  WsPtr > 9

SWISetColour ROUT

        Push    "R0-R9,WsPtr,R14"

        VDWS    WsPtr                           ; Obtain base of the VDU driver workspace

        TST     R0, #setcol_ReadFlag            ; Are we reading?
        BNE     %FT75

        TST     R0, #setcol_TextColour          ; Are we changing the text colour?
        BNE     %FT70

        AND     R2, R0, #setcol_LogicOpMask     ; Get the logical operation
        ORR     R2, R2, #&60                    ; Mark as being a special kind of pattern

        TST     R0, #setcol_FgBgFlag
        STREQ   R2, [WsPtr, #GPLFMD]            ; Store the relevant logical operation away for fg/bg
        STRNE   R2, [WsPtr, #GPLBMD]
        ADDEQ   R3, WsPtr, #FgPattern
        ADDNE   R3, WsPtr, #BgPattern           ; Setup the pointer to a store for the pattern

        TST     R0, #setcol_PatternFlag         ; Did the caller specify a pattern block?
        BNE     %FT50                           ; Yes so don't try to expand colour value to pattern

        MOV     R2, #1
        LDR     R4, [WsPtr, #Log2BPP]           ; Get the Log2 depth of the mode
        MOV     R4, R2, ASL R4                  ; R4 = bits per pixel
        RSB     R2, R2, R2, LSL R4              ; Get a mask to extract only meaningful bits from word
        AND     R1, R1, R2                      ; Extract bits suitable for this depth of mode
10
        TEQ     R4, #32                         ; Do we need to do any more replication
        ORRNE   R1, R1, R1, LSL R4              ; Yes so or word with itself shifted
        MOVNE   R4, R4, LSL #1                  ; and double amount to shift next time
        BNE     %BT10

        MOV     R2, #8
20
        STR     R1, [R3], #4                    ; now copy word 8 times into block
        SUBS    R2, R2, #1
        BNE     %BT20
        B       %FT60

50
        LDMIA   R1,{R0,R2,R4-R9}
        STMIA   R3,{R0,R2,R4-R9}                ; Copy the pattern into the buffer (assumes word aligned)
60
        BL      SetColour                       ; And then setup the internal GCOL tables
65
        Pull    "R0-R9,WsPtr,R14"
        ExitSWIHandler
70
        TST     R0, #setcol_FgBgFlag            ; Store the foreground or background colour?
        STREQ   R1, [WsPtr, #TextFgColour]
        STRNE   R1, [WsPtr, #TextBgColour]

        LDR     R0, [WsPtr, #CursorFlags]       ; Indicate the text colour needs re-computing!
        ORR     R0, R0, #TEUpdate
        STR     R0, [WsPtr, #CursorFlags]

        B       %BT65                           ; Leave gracefully ....

75
        ; Reading the colour...
        TST     R0, #setcol_TextColour
        BEQ     %FT80

        ; Reading text colour
        TST     R0, #setcol_FgBgFlag
        LDREQ   R1, [WsPtr, #TextFgColour]
        LDRNE   R1, [WsPtr, #TextBgColour]
        BIC     R0, R0, #setcol_PatternFlag :OR: setcol_ReadFlag

77
        ; Standard exit for reading the colour
        STMIA   SP, {R0,R1}
        B       %BT65

80
        ; Reading graphics colour
        TST     R0, #setcol_FgBgFlag
        LDREQ   R2, [WsPtr, #GPLFMD]            ; Get the relevant logical operation for fg/bg
        LDRNE   R2, [WsPtr, #GPLBMD]

        ; SetColour setting - copy block
        ADDEQ   R3, WsPtr, #FgEcf
        ADDNE   R3, WsPtr, #BgEcf

        ; Copy the pattern to the user's buffer
        LDMIA   R3,{R0,R3,R4-R9}
        STMIA   R1,{R0,R3,R4-R9}

        ; Construct a suitable reason code
        AND     R0, R2, #setcol_LogicOpMask
        ORRNE   R0, R0, #setcol_FgBgFlag
        ORR     R0, R0, #setcol_PatternFlag
        B       %BT77

; *****************************************************************************
;
;       HandleServiceDisplayStatus
;
;       Called from kernel service call handler
;
; in:   R0 = sub-reason
;       R1 = Service_DisplayStatus
;       R2 = GraphicsV driver number
;       LR = return address
;
; out:  R12 corrupt
;
HandleServiceDisplayStatus ROUT
        ; We're only interested in DisplayStatus_Changing/DisplayStatus_Changed
        TEQ     r0, #DisplayStatus_Changing
        TEQNE   r0, #DisplayStatus_Changed
        MOVNE   pc, lr
        Entry   "r0-r4"

        ; We're only interested in the current driver
        VDWS    WsPtr
        LDR     r1, [WsPtr, #CurrentGraphicsVDriver]
        TEQ     r1, r2
        BNE     %FT90

        ; Translate this call into the corresponding Service_DisplayChanging calls
        ; DisplayStatus_Changing -> DisplayChanged_PreChanging
        ; DisplayStatus_Changed  -> DisplayChanged_Changing,
        ;                           DisplayChanged_Changed
        ; This may sound odd, but that's how it fits with the way the
        ; DisplayChanged service call is designed. The ScreenModes module will
        ; recache its mode list when it receives DisplayChanged_Changing, so we
        ; must only issue the call once the driver has finished changing its
        ; configuration.

        TEQ     r0, #DisplayStatus_Changed
        BEQ     %FT50
        MOV     r0, #DisplayChanged_PreChanging
        MOV     r1, #Service_DisplayChanged
        MOV     r3, #DisplayChangedSub_ModeNotChanged
        IssueService
        EXIT

50
        ; It was a DisplayStatus_Changed call. Recache any important values
        ; that we care about.
        MOV     r4, r2, LSL #24
        ORR     r4, r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        STR     r0, [WsPtr, #GraphicsVFeatures]
        BL      UpdateFalseVsync

        ; Currently we assume that the driver's hardware
        ; scroll ability won't have been changed.

        ; Now issue the two DisplayChanged service calls
        MOV     r0, #DisplayChanged_Changing
        MOV     r1, #Service_DisplayChanged
        FRAMLDR r2
        MOV     r3, #DisplayChangedSub_ModeNotChanged
        IssueService
        MOV     r0, #DisplayChanged_Changed
        IssueService
90
        EXIT


        LTORG

        END
@


4.24
log
@Improve detection of invalid/unsupported screen modes
Detail:
  s/vdu/vdudriver - When using mode selector blocks, don't allow the system to switch into double-vertical, double-pixel, or BBC-gap modes which are in colour depths unsupported by the kernel
Admin:
  Tested on BB-xM


Version 6.13. Tagged as 'Kernel-6_13'
@
text
@a25 1
        GET s.vdu.VduDecl
a591 79
; table of susbstitute mode numbers to cater for hardware that might
; not support all of 1,2,4,8 bpp (bits per pixel) modes
;
; indexed by mode number (0..49), pairs of byte values:
;   bpp    = bits per pixel of this mode number
;   promo  = promoted mode number (0..49), or &FF if none
;
; promoted number is:
;  1) same resolution at next higher bpp (up to 8), if available, or
;  2) similar resolution at 8 bpp (8 bpp should be available on most h/w)
;
ModePromoTable
;
;          bpp promo       mode no.
;
      DCB    1,    8     ;  0
      DCB    2,    9     ;  1
      DCB    4,   10     ;  2
      DCB    1,   15     ;  3
      DCB    1,    1     ;  4
      DCB    2,    2     ;  5
      DCB    1,   13     ;  6
    [ TTX256
      ; This case should be irrelevant (ModePromoTable no longer used for mode 7), but keep it in sync with vdumodes just in case
      DCB    8,  &FF     ;  7
    |
      DCB    4,   13     ;  7
    ]
      DCB    2,   12     ;  8
      DCB    4,   13     ;  9
      DCB    8,  &FF     ; 10
      DCB    2,   14     ; 11
      DCB    4,   15     ; 12
      DCB    8,  &FF     ; 13
      DCB    4,   15     ; 14
      DCB    8,  &FF     ; 15
      DCB    4,   24     ; 16
      DCB    4,   24     ; 17
      DCB    1,   19     ; 18
      DCB    2,   20     ; 19
      DCB    4,   21     ; 20
      DCB    8,  &FF     ; 21
      DCB    4,   36     ; 22
      DCB    1,   28     ; 23
      DCB    8,  &FF     ; 24
      DCB    1,   26     ; 25
      DCB    2,   27     ; 26
      DCB    4,   28     ; 27
      DCB    8,  &FF     ; 28
      DCB    1,   30     ; 29
      DCB    2,   31     ; 30
      DCB    4,   32     ; 31
      DCB    8,  &FF     ; 32
      DCB    1,   34     ; 33
      DCB    2,   35     ; 34
      DCB    4,   36     ; 35
      DCB    8,  &FF     ; 36
      DCB    1,   38     ; 37
      DCB    2,   39     ; 38
      DCB    4,   40     ; 39
      DCB    8,  &FF     ; 40
      DCB    1,   42     ; 41
      DCB    2,   43     ; 42
      DCB    4,   28     ; 43
      DCB    1,   45     ; 44
      DCB    2,   46     ; 45
      DCB    4,   15     ; 46
      DCB    8,  &FF     ; 47
      DCB    4,   49     ; 48
      DCB    8,  &FF     ; 49
      DCB    1,   51     ; 50
      DCB    2,   52     ; 51
      DCB    4,   53     ; 52
      DCB    8,  &FF     ; 53

      ASSERT (.-ModePromoTable)=(NumModes*2)
;
      ALIGN

d618 1
a639 45
        ;If its a common mode number (0..49) consider a possible mode number
        ;substitution, if hardware does not support given bits per pixel.
        ;We are vaguely assuming h/w supports at least 8 bpp, otherwise we may
        ;not be able to find a usable mode number, and later code may not handle
        ;that well. This is probably ok, 8 bpp is almost universal.
        ;
        CMP     r2, #256
        BHS     mchsub_3
        AND     r1, r2, #&7F
        CMP     r1, #NumModes                ; mode number
        BHS     mchsub_3
        ; For mode 7 we have some logic in FindOKMode to deal with looking for a replacement, prefer that over this logic
        CMP     r1, #7
        BEQ     mchsub_3
        Push    "r0-r4"
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        TEQ     r4, #0
        MOVNE   r0, #0
        MOVEQ   r4, r1
        MOVNE   r4, #2_111111
        STR     r0, [WsPtr, #GraphicsVFeatures] ; refresh cached features
        Pull    "r0-r2"
        ADR     lr, ModePromoTable           ; table of mode promotions
mchsub_1
        MOV     r1, r1, LSL #1
        LDRB    r3, [lr, r1]                 ; bpp for this mode number (1,2,4,8)
        TST     r3, r4                       ; supported in h/w?
        ANDNE   r2, r2, #&80                 ; if yes, take mode number that passed
        ORRNE   r2, r2, r1, LSR #1
        BNE     mchsub_2
        ADD     r1, r1, #1                   ; else look for promotion
        LDRB    r1, [lr, r1]                 ; new mode number
        CMP     r1, #&FF                     ; &FF if none
        BNE     mchsub_1
        ;alright, dont panic, just try to get a VGA-like mode of any bpp, if not tried already
        CMP     r1, #28                      ; VGA 8 bpp
        MOVNE   r1, #25                      ; VGA 1 bpp
        BNE     mchsub_1
mchsub_2
        Pull    "r3, r4"
;
mchsub_3
d675 1
a675 4

        LDR     R11, [R13, #wkScreenSize] ; get screen size for this mode
        LDR     R9, [WsPtr, #TotalScreenSize] ; maximum allowed amount

a676 2
        RSBS    R1, R9, R11, LSL R2     ; extra amount we need
        BLS     %FT08                   ; enough memory, so skip
d678 16
a693 3
        LDRB    R0, [WsPtr, #ExternalFramestore]
        TEQ     R0, #0
        BEQ     %FT05
d695 10
a704 7
; External framestore in use; does driver support growing/reallocating it?

        LDR     R0, [WsPtr, #GraphicsVFeatures]
        TST     r0, #GVDisplayFeature_VariableFramestore
        BNE     %FT08                   ; realloc supported, assume driver can allocate required memory since it OK'd the mode
        B       %FT06                   ; not supported, complain
05
d714 1
a714 1
        ADD     R13, R13, #PushedInfoSize + 1*4 ; junk stacked info + mode no.
d723 4
d730 1
a730 1
        Pull    R0                      ; restore mode we are using
d780 1
a780 1
13      LDR     R3, [R13, #wkScreenSize]
d787 1
d789 11
a799 5
        LDR     r0, [WsPtr, #GraphicsVFeatures]
        TST     r0, #GVDisplayFeature_VariableFramestore
        ADDNE   R0, R13, #wkwordsize+7*4        ; R0 -> VIDCList3
        BLNE    HardwareModeChange
        
a803 2
        TEQ     r4, #0
        BNE     %FT581
d805 1
d830 1
d832 4
a835 1
        MOV     r0, #128+2
d863 1
a863 1
        LDR     R6, [R13, #wkModeFlags]
d868 1
a868 1
        LDR     R4, [R13, #wkLineLength]
d910 1
a910 1
        LDR     R3, [R13, #wkModeFlags]
d916 5
a920 4
        LDR     r0, [WsPtr, #GraphicsVFeatures]
        TST     r0, #GVDisplayFeature_VariableFramestore
        ADDEQ   R0, R13, #wkwordsize            ; R0 -> VIDCList3
        BLEQ    HardwareModeChange
a969 19
;adjust vertical porch parameters in VIDCList3 for TVVertical (from *TV)
;
        LDROSB  R1, TVVertical
        MOV     R1, R1, LSL #24          ; sign extend to 32 bits
        MOV     R1, R1, ASR #24-3        ; and multiply by 8
        LDR     R2, [WsPtr, #ModeFlags]
        TST     R2, #ModeFlag_GapMode    ; gap mode ?
        ADDNE   R1, R1, R1, ASR #2       ; add on 2 rows if so
        TST     R2, #ModeFlag_DoubleVertical ; if double vertical
        ADDNE   R1, R1, R1               ; then double it
        LDR     R2, [R0, #VIDCList3_VertiBackPorch]
        SUBS    R2, R2, R1
        MOVMI   R2, #0
        STR     R2, [R0, #VIDCList3_VertiBackPorch]   ;subtract from back porch, clamp at 0
        LDR     R2, [R0, #VIDCList3_VertiFrontPorch]
        ADDS    R2, R2, R1
        MOVMI   R2, #0
        STR     R2, [R0, #VIDCList3_VertiFrontPorch]  ;add to front porch, clamp at 0

d1009 1
a1038 1

a1052 2
        GET     s.vdu.VduModes

d1113 1
d1117 1
a1173 74
; special VIDCListType3 widgetry
; 1) Set SyncPol_Interlace (according to TVInterlace) if not already specified
; 2) check for the interlaced flag in the control parameters - if set, set the interlaced
;    flag in the mode flags

        TEQ     r3, #0                  ; do we have a VIDC list?
        BEQ     %FT58
        LDR     r2, [r3, #0]            ; is it type 3? (actually, it always should be now)
        TEQ     r2, #3
        BNE     %FT58
        LDR     r10, [r3, #VIDCList3_SyncPol]
        TST     r10, #SyncPol_InterlaceSpecified
        BNE     %FT56                              ; Interlace already specified
        LDROSB  R14, TVInterlace
        TST     R14, #1
        ORRNE   R10, R10, #SyncPol_InterlaceSpecified                     ; specify as non-interlaced
        ORREQ   R10, R10, #(SyncPol_InterlaceSpecified+SyncPol_Interlace) ; specify as interlaced
        STR     R10, [r3, #VIDCList3_SyncPol]

56
        ADD     r10, r3, #VIDCList3_ControlList
57      LDR     r14, [r10], #8          ; loop over the control parameter list
        CMP     r14, #-1
        BEQ     %FT58                   ; didn't find the interlaced entry - not interlaced

        TEQ     r14, #ControlList_ExtraBytes
        BNE     %FT571
        LDR     r14, [r10, #-4]
        ; Adjust LineLength, ScreenSize by ExtraBytes
        LDR     r2, [r9, #wkModeFlags]
        TST     r2, #ModeFlag_Teletext
        LDR     r2, [r9, #wkLineLength]
        ADD     r2, r2, r14
        STR     r2, [r9, #wkLineLength]
        LDR     r2, [r9, #wkYWindLimit]
        MLA     r2, r14, r2, r14        ; (yWindLimit+1) * ExtraBytes
        LDR     r14, [r9, #wkScreenSize]
        ADD     r14, r14, r2
        ADDNE   r14, r14, r2            ; teletext ScreenSize is actually enough for two screens
        STR     r14, [r9, #wkScreenSize]
        B       %BT57

571
        TEQ     r14, #ControlList_Interlaced
        BNE     %BT57                   ; check the next one then

        LDR     r14, [r10, #-4]         ; read value
        TEQ     r14, #0
        BEQ     %BT57                   ; if zero, not interlaced

; it's interlaced
        LDR     r14, [r9, #wkModeFlags]
        ORR     r14, r14, #ModeFlag_InterlacedMode
        STR     r14, [r9, #wkModeFlags]
        B       %BT57                   ; process remaining control list items
58
        Push    "r0-r2"
        LDR     r0, [WsPtr, #GraphicsVFeatures]
        TST     r0, #GVDisplayFeature_HardwareScroll
        LDREQ   r14, [r9, #wkModeFlags]
        ORREQ   r14, r14, #ModeFlag_HardScrollDisabled
        STREQ   r14, [r9, #wkModeFlags]
  ; claim or release falsevsync vector if vsyncs supported/not supported
        TST     r0, #GVDisplayFeature_NoVsyncIRQ ; are VSyncs not generated?
        MOV     r0, #TickerV
        LDR     r1, =FalseVsyncIRQ
        LDR     r2, =ZeroPage+OsbyteVars
        BEQ     %ft2
        SWI     XOS_Claim
        B       %ft1
2       SWI     XOS_Release
1
             
        Pull    "r0-r2"
d1199 1
a1199 1
        MOVLT   R8, #-1                 ; emergency terminate (source list too long)
d1205 37
d1246 6
a1251 14
        BL      ReadMonitorType         ; get monitor type in R3
        CMP     R3, #NumMonitorTypes    ; monitor type must be in range
        CMPCC   R2, #NumModes           ; and mode must be in range
        MOVCC   R11, #NumModes
        MLACC   R11, R3, R11, R2        ; then form monitortype*numberofmodes + modenumber
        MOVCS   R11, #0                 ; if illegal then use mode 0 monitortype 0
64
        ADRL    R14, BigVIDCTable       ; point to big table
        LDR     R11, [R14, R11, LSL #2] ; and load offset
        CMP     R11, #-1                ; if table offset is valid
        ADDCC   R3, R14, R11            ; then add to table address (R3 -> VIDCList3 from table)
        BCC     %BT59                   ; copy it and exit
        MOV     R11, #0                 ; desperate again, use mode 0 monitortype 0 (this had better have valid entry)
        B       %BT64
d1641 1
a1682 6
        MOV     r6, #ModeSelectorFlags_ValidFormat
        STR     r6, [sp, #ModeSelector_Flags]
        ADRL    r6, FrameRateTable
        LDRB    r6, [r6, r2]
        STR     r6, [sp, #ModeSelector_FrameRate]

d1686 2
a1687 17
        LDR     r14, [r6, #wkLog2BPP]
        STR     r14, [sp, #ModeSelector_PixelDepth]     ; pixdepth = log2bpp

        LDR     r7, [r6, #wkLog2BPC]
        SUB     r14, r7, r14                            ; r14 = log2bpc-log2bpp

        LDR     r7, [r6, #wkXWindLimit]
        ADD     r7, r7, #1
        MOV     r7, r7, LSL r14
        STR     r7, [sp, #ModeSelector_XRes]

        LDR     r7, [r6, #wkYWindLimit]
        ADD     r7, r7, #1
        STR     r7, [sp, #ModeSelector_YRes]

        MOV     r7, #-1
        STR     r7, [sp, #ModeSelector_ModeVars]
d2536 1
d2538 1
a2538 1
        ; Currently we assume that the driver's VSync ability or hardware
@


4.23
log
@Evict ECFIndex and PalIndex from VDU workspace
Detail:
  ECFIndex and PalIndex claim to be mode variables, but it's impossible for extension modes to specify their values.
  Since they're easy to calculate from the ModeFlags and Log2BPP values, drop them from the mode workspace (+ table of builtin modes) and calculate them on the fly instead.
  File changes:
  - hdr/KernelWS - Drop ECFIndex & PalIndex from workspace
  - s/vdu/vdumodes - Adjust workspace definition, drop ECFIndex & PalIndex values from VWSTAB
  - s/vdu/vdudriver - Remove now-redundant copy loop from ModeChangeSub. Remove code from GenerateModeSelectorVars that sets up the ECFIndex & PalIndex values on the stack
  - s/vdu/vdugrafl - Adjust copy loop in SwitchOutputToSprite/Mask
  - s/vdu/vdupalette, s/vdu/vdupalxx - Add GetPalIndex routine to generate PalIndex on the fly. Drop the obsolete 16bpp palette/gamma table and shuffle the other entries to simplify GetPalIndex a bit.
  - s/vdu/vduplot - Add GetECFIndex routine to generate ECFIndex on the fly. Also, fix things so that mode 0 isn't the only rectangular-pixel mode which uses the special rectangular-pixel ECF patterns (index 0 vs. index 4). Fiddle with ExportedHLine a bit to avoid an out-of-range ADR.
  - s/NewReset - Fix UAL warning for MOV R0, AppSpaceStart. Adjust memset to not assume 512KB is the correct amount
Admin:
  Tested on Raspberry Pi 3


Version 6.11. Tagged as 'Kernel-6_11'
@
text
@d1539 3
d1543 22
@


4.22
log
@Fix some pointer colour issues. Fix PaletteV 6 (blank screen) return value.
Detail:
  s/vdu/vdudriver - On startup, initialise all palettes to 0, not just Pal_Blank. Ensures that entries which might not always be explicitly initialised (e.g. pointer) are self-consistent. Also make sure InitialiseMode communicates the pointer palette to the new GV driver, since some components tend to program it in a lazy manner (e.g. Hourglass)
  s/vdu/vdupalxx - Fix UpdateAllPalette setting R4 to 0 on exit. Fix PV_BlankScreen R0 return value to be 0/1 as the comment suggests instead of always being 0 due to GraphicsV calls.
Admin:
  Tested on wandboard
  Fixes incorrect hourglass colours after reset, due to software RAM clear not wiping the kernel's palette (kernel + Hourglass thought old colours were still in use, but IMXVideo hadn't been told any colours yet so was using defaults of 0)


Version 5.96. Tagged as 'Kernel-5_96'
@
text
@a964 10
        MOV     R2, #wkend-wkdispstart  ; number of bytes to do
        ADD     R1, R13, #wkdispstart

        ADD     R4, WsPtr, #PalIndex    ; first display mode variable
15
        LDR     R3, [R1], #4            ; copy variables
        STR     R3, [R4], #4
        SUBS    R2, R2, #4              ; loop until all done
        BNE     %BT15

d973 2
a974 1
        STR     R2, [R3]                ; indicate uninitialised (R2=0)
a1452 6
        ADR     lr, PalIndexTable
        LDRB    lr, [lr, r6]
        STR     lr, [r9, #wkPalIndex]
        ADR     lr, ECFIndexTable
        LDRB    lr, [lr, r6]
        STR     lr, [r9, #wkECFIndex]
a1510 4
        ; Fixup PalIndex
        CMP     r0, #255
        MOVLS   r0, #4
        STRLS   r0, [r9, #wkPalIndex]
a1624 8
        ADR     r1, PalIndexTable
        LDRB    r1, [r1, r0]
        STR     r1, [r9, #wkPalIndex]

        ADR     r1, ECFIndexTable
        LDRB    r1, [r1, r0]
        STR     r1, [r9, #wkECFIndex]

a1700 4
PalIndexTable   =       0, 1, 2, 3, 7, 7        ; TODO get rid of palette 6 if VIDC mangling is gone for good
        ALIGN                                   ; makes ECFIndexTable more accessible
ECFIndexTable   =       4, 2, 3, 5, 5, 5
        ALIGN
@


4.21
log
@Recover gracefully from a completely blank set of CMOS
Newly born boards have all 0xFF's in their CMOS (EEPROM), but the new order of keyboard scan did
  Init -> Scan keyboard -> Check (or wipe) CMOS
and would therefore leave 0xFF's in a select few kernel workspace areas and OS_Byte values.
Defer the init which reads CMOS until after the check/wipe step. Only the screen area size is now done early, but MassageScreenSize clamps that properly anyway.

Arthur3.s: Relocate stranded function SetupPrinterBuffer to osinit.
PMF/key.s: Drop support for SoftReset.
PMF/osinit.s: Stuff in hardcoded defaults at early init. Retrieve the proper ones later. Take ownership of SystemSprite/RamFS/Font Manager dynamic areas (deferrable).
vdudriver.s: Use symbolic name.
NewReset.s: Defer SystemSprite/RamFS/Font Manager area creation, MouseInit, Read(Hard)CMOSDefaults until later.
hdr/Options: Delete unused IgnoreVRAM. Remove MaxRAMFS_Size now PMPs make it not useful. Shuffle ARM6Support/XScaleMiniCache/XScaleJTAGDebug to be adjacent to their definitions.

Tested by filling first 256 bytes with 0xFF and powering up. Reset now completes, OS_Byte variables look sensible.

Version 5.95. Tagged as 'Kernel-5_95'
@
text
@d228 2
d232 1
a232 1
        MOV     r4, #PalEntries
d237 1
a237 1
        ADD     r2, r2, #Pal_RTable-(Pal_Blank+4*PalEntries) ; r2 -> rgb tables
d338 1
a338 1
        EXIT    VC
d345 2
@


4.20
log
@Initial support for the ExtraBytes VIDC control list item
Detail:
  The ExtraBytes control list item can be used to add padding between framebuffer rows.
  When the kernel sees a VIDC list containing this item, it will now adjust the LineLength and ScreenSize mode variables accordingly, with the end result that the correct amount of memory will be allocated for the framebuffer and the OS will render into it correctly.
  Files changed:
  - hdr/KernelWS - Add DisplayLineLength variable to allow the correct LineLength value to be preserved when screen output is redirected to a sprite
  - s/vdu/vdudriver - Make ModeChangeSub initialise DisplayLineLength before calling SwitchOutputToSprite. Update PushModeInfo to take ExtraBytes into account when calculating LineLength and ScreenSize.
  - s/vdu/vdugrafl - Adjust SwitchOutputToSprite to use DisplayLineLength when restoring screen output
  - s/vdu/vduwrch - Fix full-screen CLS to not write to the padding bytes
Admin:
  Tested on Raspberry Pi 3


Version 5.82. Tagged as 'Kernel-5_82'
@
text
@d152 1
a152 1
        TEQ     R0, #0
@


4.20.2.1
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d152 1
a152 1
        TEQ     R0, #SoftReset
a227 2
; zero-init the other palettes too, to make sure log & phys palettes are
; consistent
d230 1
a230 1
        LDR     r4, =PalEntries*5
d235 1
a235 1
        ASSERT  Pal_RTable = Pal_Blank + PalEntries*5*4
d336 1
a336 1
        BVC     %FT40
a342 2
40
        BLVC    UpdateAllPalette        ; make sure GV driver is aware of the pointer colours (this will also redundantly set the main palette + border colour, but re-using this routine as-is avoids duplicating a bunch of code)
@


4.19
log
@Teletext fixes
Detail:
  s/vdu/vdudriver, s/vdu/vdumodes - Re-introduce TTX256 so that 8bpp teletext will be used if no MDF is loaded
  s/vdu/vdudriver - If the video driver didn't support the native mode 7 colour depth, ModePromoTable was swapping it for another mode number, preventing the AltTTX code in FindOKMode from operating. So, skip the ModePromoTable check for mode 7.
  s/vdu/vduswis - Minor correction to alternate teletext mode search; 1<<5 = 32bpp, so stop search at log2bpp of 6
Admin:
  Tested on Raspberry Pi


Version 5.74. Retagged as 'Kernel-5_74'
@
text
@d971 5
d1321 18
d1344 1
a1344 1
        BEQ     %FT58                   ; if zero, not interlaced
d1350 1
@


4.18
log
@Add support for custom teletext modes
Detail:
  This set of changes:
  * Adds support for the T, TX and TY mode string elements (as per RISCOS Ltd)
  * Adds support for entering arbitrary-resolution teletext modes by using mode selector blocks with the Teletext mode flag set
  * ScrRCol and ScrBRow mode variables can be provided in the mode selector in order to restrict the number of text rows/columns in teletext modes (as per RISCOS Ltd)
  * If the rows / columns are restricted in this manner then the text window will be centered on the screen, to try and avoid things looking too ugly (no variable text scaling implemented)
  * For HiResTTX, all colour depths >= 4bpp are now supported by teletext. This essentially makes the TTX256 switch obsolete.
  * If the "native" mode 7 is unavailable then the kernel will try a series of fallback resolutions & colour depths in an effort to find a combination that works
  Known bugs/issues:
  * Teletext column count has a max limit of 255 due to TTXDoubleCounts being a byte array
  * If there's a border around the text window, the border will not be refreshed when changing transparency modes using a VDU 23,18,0 sequence
  * ScreenLoad looks like it can overflow the LargeCommon buffer (no buffer size check) - needs fixing before LargeCommon can be safely shrunk below (Old)TTXMapSize
  File changes:
  - hdr/KernelWS - Make CharWidth non-conditional. Adjust handling of teletext workspace; it's now allocated from the system heap to allow it to cope with arbitrary screen sizes
  - s/vdu/vdu23 - Make CharWidth non-conditional
  - s/vdu/vducursoft - Make CursorTeletext cope with arbitrary colour depths, make CharWidth non-conditional, remove hard-coded teletext values
  - s/vdu/vdudriver - Deal with teletext workspace allocation during ModeChangeSub. Deal with selecting teletext modes (and validating colour depth) in GenerateModeSelectorVars.
  - s/vdu/vdugrafl - Make CharWidth non-conditional. Calculate offset required for text window centering.
  - s/vdu/vdumodes - Remove TTX256
  - s/vdu/vduswis - Try other teletext modes if native mode 7 not available. Extend OS_ScreenMode reason codes to cope with teletext mode strings.
  - s/vdu/vduttx - Update to use dynamic workspace. Replace various hardcoded values with variable lookups. Update character plotting + colour/palette selection to work with true-colour modes if HiResTTX.
  - s/vdu/vduwrch - Move some useful code into a subroutine. Update FastCLS to cope with true-colour teletext. Update AddressR0R1 to cope with text window centering offset. Make CharWidth non-conditional.
Admin:
  Tested on Raspberry Pi, BB-xM
  VDU 23,18,0 in 256-colour teletext now works correctly (previously 64-colour mode was in use, causing palette update to be ruined by VIDC1-mangling)


Version 5.74. Tagged as 'Kernel-5_74'
@
text
@d611 4
d616 1
d726 3
@


4.17
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d587 1
a610 3
    [ TTX256
      DCB    8,  &FF     ;  7
    |
a611 1
    ]
d690 18
d781 7
d1185 1
a1185 1
;       R11 = mode to use if service not claimed
d1465 58
@


4.16
log
@Delete STB code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a desktop build):
  * STB
  * RO371Timings
  * NormalSpeedROMS
  * AutoSpeedROMS
  * RISCPCBurstMode
  * InterlacedPointer
  * ParallelFlashUpgrade (and s/FlashROM file)
  * Embedded_UI
  Some of the deleted code might be worth revisiting in future:
  * OS_ReadSysInfo 4 support for storing the MAC in alternate CMOS locations (including 2nd copy for error checking) or fetching via Service_MachineAddress
  * Mouse handling changes, possibly aimed at hiding the mouse pointer if a mouse isn't connected
  * More strict CMOS validation in s/NewReset
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.50. Tagged as 'Kernel-5_50'
@
text
@a24 11
        GBLL NewStyleEcfs
NewStyleEcfs   SETL  {TRUE}

        GBLL    DoVdu23_0_12
DoVdu23_0_12   SETL  {FALSE}

        GBLL    BleedinDaveBell
BleedinDaveBell SETL {TRUE}

        GBLL    LCDPowerCtrl
LCDPowerCtrl    SETL {TRUE}
a29 42
        HostVdu
        Push    "R0,R14"
      [ ZeroPage = 0
        LDR     R0, [R0, -R0]
      |
        LDR     R0, =ZeroPage
        LDR     R0, [R0]
      ]
        TEQ     R0, #0
        ADREQ   R0, %FT01
        SWIEQ   OS_CLI
        Pull    "R0,R14"
        B       %FT02
01
        =       "HOSTVDU", 0
        ALIGN
02
        MEND

        MACRO
        Print   $string
        Push    "R0,R14"
      [ ZeroPage = 0
        LDR     R0, [R0, -R0]
      |
        LDR     R0, =ZeroPage
        LDR     R0, [R0]
      ]
        TEQ     R0, #0
        BNE     %FT01
        SWI     OS_WriteS
        =       "$string", 0
        ALIGN
        SWI     OS_ReadC
        Pull    "R0,R14",CS
        SWICS   OS_BreakPt
        SWI     OS_NewLine
01
        Pull    "R0,R14"
        MEND

        MACRO
a1414 21
 [ RogerEXEY
; TMD 09-Dec-93
; New algorithms for xeig, yeig from Roger:
;       xeig = 1: yeig = 1
;       if yres<xres/2 OR yres<400 then yeig = 2
;       if (xres<<xeig)<(yres<<yeig) then xeig = 2

        CMP     r5, r4, LSR #1                  ; if yres < xres/2
        CMPCS   r5, #400                        ; or yres < 400
        MOVCC   r7, #2                          ; then yeig = 2
        MOVCS   r7, #1                          ; else yeig = 1
        STR     r7, [r9, #wkYEigFactor]

        MOV     r7, r5, LSL r7                  ; r7 = yres << yeig
        CMP     r7, r4, LSL #1                  ; if (xres<<1) < (yres<<yeig)
        MOVHI   r7, #2                          ; then xeig = 2
        MOVLS   r7, #1                          ; else xeig = 1
        STR     r7, [r9, #wkXEigFactor]

        MOV     lr, #1
 |
d1421 1
a1421 1
 ]
@


4.15
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@d35 1
a35 1
LCDPowerCtrl    SETL {TRUE} :LAND: :LNOT: STB
a854 6
 [ STB
TV_Mode_string
         =       "TV_Mode", 0
        ALIGN
 ]

a1856 9
 [ STB
svc_PortMan
        TEQ     R0, #0                                  ; PortManager starting
        MOVNE   PC, LR

        ! 0, "HAL - svc_PortMan broken by kernel/HAL split due to lack of VIDCControlSoftCopy"
        MOV     PC, LR
 ]

@


4.14
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a129 1
  [ HAL
a135 5
  |
        MOV     $size, #0
        LDR     $bw, [$size, #VideoBandwidth]   ; load bandwidth
        LDR     $size, [$size, #VideoSize]      ; and total amount of video RAM
  ]
a432 1
 [ No26bitCode
a433 5
 |
        MOV     R14, PC
        ADD     R14, R14, #(VduPrintExit-%BT05-8) ; push address of SEC exit
                                                  ; (with flags)
 ]
a504 1
 [ No26bitCode
a505 5
 |
        MOV     R14, PC
        ADD     R14, R14, #(VduPrintExit-%BT10-8) ; push address of SEC exit
                                                  ; (with flags)
 ]
a565 1
 [ No26bitCode
a566 5
 |
        MOV     R14, PC
        ADD     R14, R14, #(VduPrintExit-%BT05-8) ; push address of SEC exit
                                                  ; (with flags)
 ]
a911 14

        [ {FALSE} ;;; LCDPowerCtrl :LAND: :LNOT: STB
                  ;;; HAL no LCD support
        ;Switch LCD off here if it is _not_ an LCD mode
        MOV     R3, #0
        LDRB    R3, [R3, #LCD_Active]
        ANDS    R0, R3, #&7F            ;Pick out the lcd mode bits, ignoring the single/dual panel bit
        Push    "r0-r1"
        MOVEQ   R0, #0
        LDREQ   R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        SWIEQ   XPortable_Control
        Pull    "r0-r1"
        ]

a1078 13
        [ {FALSE} ;;; LCDPowerCtrl :LAND: :LNOT: STB
                  ;;; mjsHAL no LCD support
        ;Switch the LCD on if LCD mode
        Push    "r0"
        MOV     R1, #0
        LDRB    R1, [R1, #LCD_Active]
        ANDS    R1, R1, #&7F            ;Check the LCD mode bits only, not the single/dual panel bit
        LDRNE   R0, =(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        LDRNE   R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        SWINE   XPortable_Control
        Pull    "r0"
        ]

a1867 1
    [ {TRUE}
a1869 14
    |
; When PortManager restarts, we need to put TV_Mode back. PortMan defaults to
; output high, but we don't know polarity of bit, so must set either way.
        Entry   "r0-r1, WsPtr"
        VDWS    WsPtr
        LDR     R0, [WsPtr, #VIDCControlSoftCopy]       ; get saved VIDC control register
        AND     R0, R0, #CR_VCLK :OR: CR_HCLK :OR: CR_RCLK
        TEQ     R0, #CR_HCLK                            ; are we using HCLK?
        MOVNE   R0, #1                                  ; no: TV_Mode = 0
        MOVEQ   R0, #3                                  ; yes: TV_Mode = 1
        addr    R1, TV_Mode_string
        SWI     XPortMan_AccessBit
        EXIT
    ]
@


4.13
log
@  Fixed an EXITS that should be an EXIT.
Detail:
  An EXITS without EntryS was used in a conditional block.  It does not
    need to be EXITS.
Admin:
  Only affects STB builds.
  Tested in 32-bit Lazarus build.

Version 5.37. Tagged as 'Kernel-5_37'
@
text
@d26 1
a26 1
NewStyleEcfs   SETL  1=1
d34 2
a35 2
	GBLL	LCDPowerCtrl
LCDPowerCtrl	SETL {TRUE} :LAND: :LNOT: STB
d43 1
d45 4
d63 1
d65 4
a124 1
 [ ModeSelectors
d130 8
a137 1
  [ MEMC_Type = "IOMD"
a140 3
  |
        LDR     $bw, =38400000                  ; if no ARM600 then must be MEMC based
        LDR     $size, =480*1024
a142 1
 ]
d164 3
a166 1
        MOV     R0, #0
d169 3
d175 16
a190 5
        STR     R0, [WsPtr, #PointerHeights]    ; zero all 4 heights
        STRB    R0, [WsPtr, #PointerShapeNumber] ; make sure pointer off
        STR     R0, [WsPtr, #CursorStack]       ; 0 bits => on
        STR     R0, [WsPtr, #VduSaveAreaPtr]    ; indicate no save area yet
        STR     R0, [WsPtr, #ClipBoxEnable]     ; no clip box calculating
a213 1
 [ VIDC_Type = "VIDC20"
a227 1
  [ ModeSelectors
a230 1
  ]
a231 1
 ]
d241 43
a283 11
 [ VIDC_Type = "VIDC20"
  [ GammaCorrection
        MOV     r3, #(256+1+3)*4*4+3*256 ; logical and physical copies of both flash states
                                        ; plus 3 lookup tables for r,g,b
  |
        MOV     r3, #(256+1+3)*4*2      ; soft copy of palette (2 flash states)
  ]
        BL      ClaimSysHeapNode        ; this had better succeed!
        STR     r2, [WsPtr, #FirPalAddr]

        ADD     r3, r2, #260*4
d286 1
a286 2
; now initialise entries for pointer palette so they will actually program pointer palettte
; because VDU20 doesn't change pointer palette
d288 5
a292 6
        MOV     r3, #&50000000
        MOV     r4, #&60000000
        MOV     r5, #&70000000

        ADD     r2, r2, #260*4          ; store in 1st copy of logical
        STMDB   r2, {r3-r5}             ; (last 3 entries)
d294 1
a294 2
        ADD     r2, r2, #260*4
        STMDB   r2, {r3-r5}             ; store in 2nd copy of logical
a295 8
 [ GammaCorrection
        ADD     r2, r2, #260*4
        STMDB   r2, {r3-r5}             ; store in 1st copy of physical

        ADD     r2, r2, #260*4
        STMDB   r2, {r3-r5}             ; store in 2nd copy of physical

; r2 now points off end of all 4 copies, ie start of rgb tables
d300 4
a303 3
        STRB    r0, [r2, #&200]                 ; store in blue table
        STRB    r0, [r2, #&100]                 ; store in green table
        STRB    r0, [r2], #1                    ; store in red table, and advance
a306 2
  ]
 ]
d310 1
d312 1
a312 1
        RSB     R0, R0, #ScreenEndAdr
d314 1
a314 1
        STR     R0, [WsPtr, #DisplayScreenStart]
d326 1
a326 1
;
d331 2
a332 1
; out:  All registers may be corrupted (except R13_svc !)
d335 54
a388 12
InitialiseMode ENTRY
 [ SoftResets
        MOV     r0, #&FD                ; read last reset type
        MOV     r1, #0
        MOV     r2, #&FF
        SWI     XOS_Byte
        CMP     r1, #SoftReset
        LDREQ   r0, =VduDriverWorkSpace+ModeNo
        LDREQ   r0, [r0]                ; use previous mode if a soft reset
        MOVNE   r0, #1                  ; otherwise read configured mode
        SWINE   XOS_ReadSysInfo
 |
a390 2
 ]
 [ ModeSelectors
d392 1
a395 5
 |
        SWI     XOS_WriteI+22
        SWIVC   XOS_WriteC
        EXIT    VC
 ]
d405 1
d417 1
a417 1
        MOV     R11, #0                 ; NB used later in Vdu07 as well
d450 2
a451 1
        Pull    "R14,PC"
d517 3
d523 1
d528 2
a529 1
        Pull    "R14,PC"
d584 3
d590 1
d595 2
a596 1
        Pull    "R14,PC"
d665 79
d765 1
d767 1
a767 1
        Pull    "R0, R14,PC"
d771 43
a813 4
        [ :LNOT: STB
        MOV     r1, #0
        STRB    r1, [r1, #LCD_Active]   ;Default to non-lcd active, single panel (mainly for Stork power-saving info)
        ]
a817 1

a823 1
 [ ModeSelectors
a825 1
 ]
a835 1
 [ ModeSelectors
a838 3
 |
        BIC     R10, R1, #&80
 ]
d850 12
d864 2
d869 1
a869 1

a888 1
 [ ModeSelectors
a928 3
 |
        BIC     R0, R0, #&80            ; knock out shadow bit
 ]
d937 12
a948 11
	[ LCDPowerCtrl :LAND: :LNOT: STB
	;Switch LCD off here if it is _not_ an LCD mode
	MOV	R3, #0
	LDRB	R3, [R3, #LCD_Active]
	ANDS	R0, R3, #&7F		;Pick out the lcd mode bits, ignoring the single/dual panel bit
	Push	"r0-r1"
	MOVEQ	R0, #0
	LDREQ	R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
	SWIEQ	XPortable_Control
	Pull	"r0-r1"
	]
d956 51
d1020 2
a1021 1
        MOV     R6, #0
d1042 1
a1042 1
        TST     R6, #Flag_Teletext
d1071 1
d1074 1
a1074 5
        STR     R3, [WsPtr, #PointerXEigFactor]

; Need to ensure we get modeflags correct - they were supposed to be monitor-
; independent, but unfortunately the interlace flag depends on the response
; to Service_ModeExtension. We can't rely on OS_SpriteOp to get it right.
d1081 5
a1085 378
 [ VIDC_Type = "VIDC20"
        LDROSB  R2, TVInterlace
        TST     R2, #1
        MOVNE   R4, #0
        MOVEQ   R4, #CR_Interlace
 |
        BL      ReadSyncType            ; out: r4 = configured sync (0 or 1) and NE if 1
        MOVNE   R4, #CompSync

        LDROSB  R2, TVInterlace
        TST     R2, #1
        ORREQ   R4, R4, #CR_Interlace   ; 0 or &40
 ]

        LDROSB  R5, TVVertical
        MOV     R5, R5, LSL #24         ; sign extend to 32 bits
 [ VIDC_Type = "VIDC20"
        MOV     R5, R5, ASR #24-3       ; and multiply by 8
 |
        MOV     R5, R5, ASR #24-3-14    ; and multiply by 8*(2^14)
 ]
        LDR     R1, [WsPtr, #ModeFlags]
        TST     R1, #Flag_GapMode       ; gap mode ?
        ADDNE   R5, R5, R5, ASR #2      ; add on 2 rows if so
        TST     R1, #Flag_DoubleVertical ; if double vertical
        ADDNE   R5, R5, R5              ; then double it

        ADD     R0, R13, #wkwordsize    ; R0 -> table of VIDC parms
        MOV     R7, R0                  ; keep copy for if we go wrong

 [ ChrontelSupport
        LDR     R1, [R0, #(PseudoRegister_PixelRate:SHR:22)-&80*4] ; get pixel rate
        CMP     R1, #-1                 ; if not specified
        MOVEQ   R1, #0                  ; then use zero
        BIC     R1, R1, #&FF000000      ; Only use 24 bits
        STR     R1, [WsPtr, #PixelRate]
 ]
 [ VIDC_Type = "VIDC20"
        LDR     R1, [R0, #(PseudoRegister_DPMSState:SHR:22)-&80*4] ; get DPMS state if specified
        CMP     R1, #-1                 ; if not specified
        MOVEQ   R1, #0                  ; then use zero
        ANDNE   R1, R1, #3              ; else only use bits 0 and 1
        STRB    R1, [WsPtr, #ScreenBlankDPMSState]

 [ STB
        LDR     R1, [R0, #(PseudoRegister_HClockSpeed:SHR:22)-&80*4] ; are we using HCLK?
        CMP     R1, #-1
        Push    "r0-r1"
        MOVEQ   R0, #1                  ; if not, pull the TV_Mode GPIO line low (if present)
        MOVNE   R0, #3                  ; if we are, pull it high
        ADR     R1, TV_Mode_string
        SWI     XPortMan_AccessBit      ; (don't forget svc_PortMan below)
        Pull    "r0-r1"
 ]


        MOV     R1, #0                  ; always select 24MHz clock to feed into VIDC, and normal syncs
 |
; now set up the VIDC clock latch, before we program any VIDC registers
; and also set up the sync polarity while we're at it

        LDR     R1, [R0, #(&E0-&80)]    ; get CR with clock+sync bits
        EOR     R1, R1, R4              ; adjust vertical/composite flag
        TST     R1, #CompSync           ; if doing composite sync
        BICNE   R1, R1, #SyncControlMask ; then ensure normal syncs

        AND     R1, R1, #ClockControlMask :OR: SyncControlMask

        ASSERT  SyncControlShift = ClockControlShift+2

        MOV     R1, R1, LSR #ClockControlShift
 ]
 [ IO_Type <> "IOMD"
        LDR     R3, =VIDCClockSelect
        STRB    R1, [R3]
 ]

 [ {FALSE}                              ; TMD 02-Sep-92: This bit removed - no production h/w has this latch
        BL      ReadMonitorType         ; now mute sound pin if not monitortype 0 (sound pin = VGA test pin)
        TEQ     R3, #0                  ; if monitortype 0 then program 0
        MOVNE   R3, #1                  ; else program 1
        LDR     R1, =IOEB_SoundSuppress
        STRB    R3, [R1]                ; OK to do this on old machines
 ]

        MOV     R3, #VIDC               ; point to VidC
18
 [ VIDC_Type = "VIDC20"
        MOV     R1, #(128-PseudoRegisters)*4 ; number of bytes to do (don't program pseudo-registers!)
 |
        MOV     R1, #31*4               ; number of bytes to do (register &FC is the pseudo one to tell
                                        ; the OS the real VIDC clock rate)
 ]

   [ {FALSE}   ;DEBUGGING CODE - DUMPS THE VIDC REGISTER TABLE TO A FILE (DONE FOR LCDSUPPORT)

	Push	"r0-r12"

	MOV	r10, #0
	LDRB	r10, [r10, #LCD_Active]
	CMP	r10, #2

	Pull    "r0-12", NE
	BNE     %FT20

	MOV	r10, r0
	MOV	r11, r1

        ! 0, "**** WARNING: VIDC List debugging assembled in ****"

        MOV     r0, #&80
        ADR     r1, DbgFilename
        SWI     XOS_Find

        Pull    "r0-r12", VS
	BVS	%FT20

        MOV     r1, r0
        MOV     r0, #2
	MOV	r2, r10
        MOV     r3, r11
        SWI     XOS_GBPB

        MOV     r0, #0
        SWI     XOS_Find

        Pull    "r0-r12"

DbgFilename
        =       "$.VIDCData", 0
        ALIGN

   ]


20
        LDR     R2, [R0], #4            ; Get data from table

        CMP     R2, #-1                 ; unprogrammed register ?
        BEQ     %FT80                   ; then skip

        AND     R6, R2, #&FF000000

        TEQ     R6, #HorizDisplayStart
        STREQ   R2, [WsPtr, #CursorFudgeFactor] ; save for later !

25
        CMP     R6, #VertiBorderStart
        RSBCSS  R14, R6, #VertiCursorEnd
        BCC     %FT40                   ; not a vertical register

; programming one of the registers affected by *TV

        SUB     R8, R2, R5              ; subtract offset
        TEQ     R6, #VertiDisplayStart  ; test for display start
        BICEQ   R14, R8, #&FF000000     ; get rid of register bits
        STREQ   R14, [WsPtr, #VertAdjust] ; save for pointer programming

        EOR     R14, R8, R2             ; see if now programming different reg
        MOVS    R14, R14, LSR #24       ; zero if OK

        MOVNE   R5, #0                  ; we've gone wrong, so set 0 adjust
        MOVNE   R0, R7                  ; and go back to the beginning
        BNE     %BT18

        MOV     R2, R8                  ; otherwise update register
40
 [ VIDC_Type = "VIDC20"
        TEQ     R6, #HorizSyncWidth             ; if h.sync width register
        STREQ   R2, [WsPtr, #HSWRSoftCopy]      ; then save for DPMS stuff
        TEQ     R6, #VertiSyncWidth             ; likewise v.sync width
        STREQ   R2, [WsPtr, #VSWRSoftCopy]

        TEQ     R6, #VIDCExternal       ; check for external register (which contains syncs)
        BNE     %FT50

        Push    "r4"
        BL      ReadSyncType
        Pull    "r4"
        BICNE   R2, R2, #(Ext_HSYNCbits :OR: Ext_VSYNCbits)     ; if composite sync then don't invert syncs
        ORRNE   R2, R2, #Ext_InvertCompVSYNC :OR: Ext_InvertCompHSYNC ; and force both syncs to be composite (because of lack of
                                                                ; swap in A540 VIDC card)
        B       %FT75
50
        TEQ     R6, #VIDCFSyn
        BNE     %FT60

        LDR     R8, =FSyn_ResetValue    ; set test bits on, and r > v
        STR     R8, [R3]

; we may need some delay in here...

        LDR     R8, =FSyn_ClearR :OR: FSyn_ClearV :OR: FSyn_ForceLow :OR: FSyn_ForceHigh
        ORR     R2, R2, R8
        BIC     R2, R2, #FSyn_ForceHigh ; force test bits on, except this one
        STR     R2, [R3]

; we may also need some delay in here...

        BIC     R2, R2, R8              ; remove test bits
        B       %FT75

60
  [ MEMC_Type = "IOMD"
        TEQ     r6, #VIDCDataControl
        BNE     %FT65

        BIC     r2, r2, #DCR_BusBits
        MOV     r14, #0
        LDR     r14, [r14, #VRAMWidth]
        CMP     r14, #2                 ; if using 64-bit wide VRAM
        ORRCS   r2, r2, #DCR_Bus63_0    ; then data on all 64 bits
        ORRCC   r2, r2, #DCR_Bus31_0    ; else for 32-bit wide VRAM or DRAM-only,
                                        ; data is on low 32 bits
        BCC     %FT65

; dual-bank VRAM, so HDWR value needs to be halved

        MOV     r14, r2, LSL #(31-10)   ; get HDWR bits at top - NB allow bit 10 to be used here!
        BIC     r2, r2, r14, LSR #(31-10) ; knock off bits
        TST     r14, #1 :SHL: (31-10)   ; see if bottom bit would get knocked off
        ORRNE   r2, r2, #DCR_HDis       ; if so, then disable HDis mechanism (for eg mode 29)
        ORREQ   r2, r2, r14, LSR #(31-9) ; otherwise, put bits back one bit further down

65
  ]
 ]
        TEQ     R6, #VIDCControl        ; if control register
        BNE     %FT75

; programming control register, so EOR sync/interlace bits, save in soft copy
; then work out CursorFudgeFactor from HorizDisplayStart (in CursorFudgeFactor)
; and bits-per-pixel in control register

        EOR     R2, R2, R4              ; then EOR sync/interlace bits

 [ VIDC_Type = "VIDC20"
  [ MorrisSupport
    ;    MOV     R10, #IOMD_Base
    ;    LDRB    R9, [R10, #IOMD_ID0]
    ;    CMP     R9, #&E7
    ;    LDRB    R9, [R10, #IOMD_ID1]
    ;    CMPEQ   R9, #&D4
    ;    MOVNE   R9, #32000              ;Morris clocks VIDC20L at 32Mhz
    ;    LDREQ   R9, =24000              ;RISC PC clocks VIDC20 at 24MHz
        MOV     R9, #0
        LDRB    R9, [R9, #IOSystemType]
        TST     R9, #IOST_7500
        LDREQ   R9, =24000              ;RISC PC clocks VIDC20 at 24MHz
        MOVNE   R9, #32000              ;Morris clocks VIDC20L at 32Mhz                         ;
  |
        LDR     R9, =24000
  ]
        STR     R9, [WsPtr, #VIDCClockSpeed]
  [ {FALSE}

; The following code computes the actual pixel rate used, but we don't actually
; need to know this!

        AND     R8, R2, #3
        CMP     R8, #1
        MOVEQ   R9, #0                  ; dunno what HCLK is, so assume 0
        MOVCS   R8, #1                  ; r-modulus not used, so 1
        BCS     %FT71                   ; PLL not used

        LDR     R10, [R7, #(&D0-&80)*4] ; get FreqSyn register
        MOV     R8, R10, LSR #8
        AND     R8, R8, #63
        ADD     R8, R8, #1              ; r8 = v-modulus
        MUL     R9, R8, R9

        AND     R8, R10, #63
        ADD     R8, R8, #1              ; r8 = r-modulus
71
        MOV     R10, R2, LSR #2
        AND     R10, R10, #7
        ADD     R10, R10, #1            ; r10 = clock divider
        MUL     R8, R10, R8             ; r8 = global divider
        DivRem  R10, R9, R8, R11        ; r10 = pixel rate in kHz
  ]
        STR     R2, [WsPtr, #VIDCControlCopy] ; and save in copy

  [ MEMC_Type = "IOMD"
; now compute FSIZE properly
        LDR     R10, [R7, #(&94-&80)*4] ; get vertidisplayend
        BIC     R10, R10, #&FF000000
        LDR     R8, [R7, #(&93-&80)*4]  ; get vertidisplaystart
        BIC     R8, R8, #&FF000000
        SUB     R10, R10, R8            ; verti displayed
        LDR     R8, [R7, #(&90-&80)*4]  ; verti total
        BIC     R8, R8, #&FF000000
        SUB     R10, R8, R10
        ADD     R10, R10, #1            ; vidc parms are n-2, we want n-1
        MOV     R8, #IOMD_Base
        STRB    R10, [R8, #IOMD_FSIZE]
  ]

        LDR     R14, [WsPtr, #CursorFudgeFactor] ; R14 = horiz display start (-18)
        BIC     R14, R14, #&FF000000
        ADD     R14, R14, #(18-17)      ; horiz cursor start is programmed with n-17
        STR     R14, [WsPtr, #CursorFudgeFactor]
 |

; new algorithm for working out DMA request values from MemorySpeed,
; bits/pixel, pixel rate, and VIDC clock rate
; value n to program is >= (25-11v/m)/8
; therefore n = 3-INT((11v/m-1)/8), forced into range 0..3,
; where m=memory rate (in kHz)
;       v=screen memory rate (in kbytes/second (NOT Kbytes/second))
;        = <vc=VIDC clock>*<vs=value out of MemorySpeedTab>/48
;
; ie n = 3-INT((vc*vs*11/(48*m)-1)/8)

        LDR     R9, [R7, #&FC-&80]      ; see if the module has told us the real VIDC clock
        CMP     R9, #-1
        BNE     %FT71
        AND     R8, R2, #ClockControlMask ; extract VIDC clock bits
        ADR     R9, VIDCClockSpeeds
        LDR     R9, [R9, R8, LSR #ClockControlShift-2]  ; R9 = vc (in kHz)
71
        STR     R9, [WsPtr, #VIDCClockSpeed] ; store away for reading by RVV
        AND     R8, R2, #15             ; pixel rate in 0,1, bits/pixel in 2,3
        ADR     R10, MemorySpeedTab     ; now load memory rate relative to 24M
        LDRB    R8, [R10, R8]           ; R8 = vs
        MUL     R8, R9, R8              ; R8 = vc*vs
        ADD     R9, R8, R8, LSL #2      ; R9 = vc*vs*5
        ADD     R8, R8, R9, LSL #1      ; R8 = vc*vs*11
        MOV     R9, #0
        LDR     R9, [R9, #MemorySpeed]  ; memory speed in kHz in bottom 16 bits
        BIC     R9, R9, #&FF000000
        BIC     R9, R9, #&00FF0000      ; R9 = m
        ADD     R9, R9, R9, LSL #1      ; R9 = m*3
        MOV     R9, R9, LSL #4          ; R9 = m*48
        DivRem  R10, R8, R9, R11        ; R10 = vc*vs*11/(48*m)
        SUB     R10, R10, #1            ; R10 = vc*vs*11/(48*m)-1
        MOVS    R10, R10, ASR #3        ; R10 = (vc*vs*11/(48*m)-1)/8
        MOVMI   R10, #0                 ; if going to be > 3 then make 3
        RSBS    R10, R10, #3            ; R10 = 3-(vc*vs*11/(48*m)-1)/8
        MOVMI   R10, #0                 ; if -ve then make 0
        BIC     R2, R2, #(3:SHL:4) :OR: ClockControlMask
                                        ; knock out FIFO + clock bits
        ORR     R2, R2, R10, LSL #4     ; put result in bits 4,5
        STR     R2, [WsPtr, #VIDCControlCopy] ; and save in copy

        LDR     R14, [WsPtr, #CursorFudgeFactor] ; R14 = horiz display start
        BIC     R14, R14, #&FF000000    ; lbpp = 0, 1, 2, 3
        MOV     R14, R14, LSR #14       ; R14 = (m-19, m-11, m-7, m-5)/2

        MOV     R8, R2, LSR #2          ; put bits 2,3 (lbpp) into bits 0,1
        AND     R8, R8, #3              ; just look at these bits
        RSB     R8, R8, #3              ; R8 = 3, 2, 1, 0
        MOV     R9, #1
        ADD     R14, R14, R9, LSL R8    ; R14 = (m-3, m-3, m-3, m-3)/2
        MOV     R14, R14, LSL #1        ; R14 = m-3
        SUB     R14, R14, #3            ; R14 = m-6
        STR     R14, [WsPtr, #CursorFudgeFactor]
 ]
75

 [ {FALSE} ; *** debugging
        Push    "r0"
        MOV     r0, r2
        BL      TubeDumpR0
        Pull    "r0"
        TubeString r8, r9, r10, " ",cc ; pad out to 10 chars
 ]

        TEQ     R6, #VIDCExternal
        STREQ   R2, [WsPtr, #VIDCExternalSoftCopy]
        TEQ     R6, #VIDCFSyn
        STREQ   R2, [WsPtr, #VIDCFSynSoftCopy]
        TEQ     R6, #VIDCControl
        STREQ   R2, [WsPtr, #VIDCControlSoftCopy]

        STR     R2, [R3]                ; stuff it into VidC
80
        SUBS    R1, R1, #4
        BNE     %BT20
d1089 11
a1099 8
        MOV     R0, #(1 :SHL: 10)       ; enable video DMA
        ORR     R1, R0, #(1 :SHL: 9)    ; refresh only in vflyback
        SWI     XOS_UpdateMEMC

        MOV     R0, #VertiCursorStart + 0       ; program cursor start and end
        STR     R0, [R3]
        MOV     R0, #VertiCursorEnd + 0         ; to zero
        STR     R0, [R3]
d1101 1
a1101 1
        BL      SetVendDefault                  ; set to ScreenEndAdr-16
d1103 1
a1103 1
        MOV     R1, #ScreenEndAdr               ; need to reload cos corrupt
d1117 12
a1128 11
	[ LCDPowerCtrl :LAND: :LNOT: STB
	;Switch the LCD on if LCD mode
	Push	"r0"
	MOV	R1, #0
	LDRB	R1, [R1, #LCD_Active]
	ANDS	R1, R1, #&7F		;Check the LCD mode bits only, not the single/dual panel bit
	LDRNE	R0, =(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
	LDRNE	R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
	SWINE	XPortable_Control
	Pull	"r0"
	]
d1136 100
a1239 12
 [ :LNOT: (VIDC_Type = "VIDC20")
MemorySpeedTab
        =       2, 3, 4, 6,  4, 6, 8, 12,  8, 12, 16, 24,  16, 24, 32, 48
        ALIGN

VIDCClockSpeeds
        &       24000
        &       25175
        &       36000
        &       00000
 ]

d1261 1
a1261 1
IssueModeService ENTRY "r2,r3"
d1269 1
a1269 1
;       PushModeInfo - Push appropriate mode table and VIDC parms
d1272 1
a1272 1
; in:   R10 = mode to try for (issue service if not in range 0..20,22..23)
d1274 1
a1274 1
;       R10 and R11 should have bit 7 CLEAR
d1279 1
a1279 1
;         stack flat
d1281 3
a1283 3
;         V=1
;         Stack holds a mode table (size wkwordsize) and VIDC parms (size 32*4)
;         (total size PushedInfoSize)
a1292 1
 [ ModeSelectors
a1294 1
 ]
a1305 1
 [ ModeSelectors
a1333 7
 |
        MOVNE   r10, r11                ; not claimed, so use substitute
        BNE     PushModeInfoCommonNoService
        LDR     r2, [r4, #4]!           ; if claimed, then find ws base mode
        AND     r2, r2, #&7F            ; no funny business
        B       %FT35
 ]
a1339 1
 [ ModeSelectors :LOR: {TRUE}           ; mode selectors or sprite mode words
a1353 2
 ]
47
d1371 4
a1374 3
 [ VIDCListType3
; special widgetry - check for the interlaced flag in the control parameters - if
; set, set the interlaced flag in the mode flags
d1378 1
a1378 1
        LDR     r2, [r3, #0]            ; is it type 3?
d1381 8
d1390 1
d1405 1
a1405 1
        ORR     r14, r14, #Flag_InterlacedMode
d1408 18
a1425 1
 ]
d1432 2
a1433 15
; now set up VIDC table, first from MOS table, then changes from module

; first clear out all 32 (or 128) VIDC entries with -1

        ADD     R14, R9, #wkwordsize
        MOV     R10, #VIDCParmsSize
        MOV     R8, #-1
60
        STR     R8, [R14], #4
        SUBS    R10, R10, #4
        BNE     %BT60

; now copy over MOS's table

        ADD     R9, R9, #wkwordsize-VIDCParmsSize
d1438 21
a1458 6
 [ VIDCListType3
        LDR     r2, [r3, #0]
        TEQ     r2, #3                  ; if VIDC list type 3
        BEQ     ProcessVIDCListType3    ; then don't copy any MOS data into table, just process list
 ]
        LDR     r2, [r3, #4]            ; else just load VIDC list base mode, and copy MOS's table for that
d1460 1
a1460 2
62
        Push    R3
d1467 1
d1471 4
a1474 104
        ADDCC   R11, R14, R11           ; then add to table address
        BLCC    UpdateVIDCTable         ; and fetch data
        Pull    R3

 [ VIDC_Type = "VIDC20"
        TEQ     R3, #0
        LDRNE   R2, [R3, #0]            ; get VIDC table type
        TSTNE   R2, #2                  ; test for VIDC20 compatible table
        ADDNE   R11, R3, #8             ; if exists
        BLNE    UpdateVIDCTable         ; then modify parameters

        CLRV
        Pull    "R2-R4,R7-R11, PC"      ; ignore any second list for the time being (it's all coded in main list)
 |

; now copy modules changes

        TEQ     R3, #0
        ADDNE   R11, R3, #8             ; if module list exists, then
        BLNE    UpdateVIDCTable         ; modify the table

        LDRNE   R2, [R3, #0]            ; get VIDC table type
        TSTNE   R2, #1                  ; bit 0 set if has second list
        BNE     %FT70                   ; has 2nd list
65
        CLRV
        Pull    "R2-R4,R7-R11, PC"      ; if no module table, or no second list
                                        ; then exit
70
        LDR     R2, [R11], #4
        CMP     R2, #-1
        BEQ     %BT65                   ; exit VC if found end of list

        MOV     R7, R2, LSR #24         ; R7=type of data (0=pixel rate,1=sync, 2=real VIDC clock)
        BIC     R2, R2, R7, LSL #24     ; knock out data type

; now the change to allow the real VIDC clock rate to be declared by the module

        CMP     R7, #2
        STREQ   R2, [R13, #9*4+wkwordsize+&FC-&80] ; store in pseudo-register &FC
        BEQ     %BT70
        CMP     R7, #1
        BHI     %BT70                   ; if > 1 then unknown, so skip
        BEQ     %FT90                   ; if 1 then sync polarity specification

; R2 is requested pixel rate in kHz - scan through available pixel rates to
; find match

        MOV     R3, #-1                 ; least error so far
        MOV     R4, #(0 :SHL: ClockControlShift) :OR: 3
                                        ; clock and internal pixel rates merged
                                        ; bits 9 and 10 are clock rate
                                        ; bits 0 and 1 are internal pixel rate
                                        ; 0 => n/3, 1 => n/2, 2 => 2n/3, 3 => n
75
        ADRL    R9, VIDCClockSpeeds     ; point at table of available rates
        LDR     R9, [R9, R4, LSR #ClockControlShift-2]  ; get clock rate
        TST     R4, #2
        MOVNE   R9, R9, LSL #1          ; if bit 1 set then multiply by 2
        TST     R4, #1
        MOVNE   R10, R9, LSR #1         ; if bit 0 set then divide by 2
        BNE     %FT80                   ; and skip
        MOV     R7, #3
        DivRem  R10, R9, R7, R14        ; if bit 0 clear then divide by 3
80
        SUBS    R14, R10, R2            ; difference between desired and actual
        MOVEQ   R8, R4
        BEQ     %FT85                   ; found exact match, so use it
        RSBMI   R14, R14, #0            ; get absolute error
        CMP     R14, R3                 ; if less than least error
        MOVCC   R3, R14                 ; then R3 = new least error
        MOVCC   R8, R4                  ; and R8 = best fit
        TST     R4, #3                  ; if not just tried pixel rate 0
        SUBNE   R4, R4, #1              ; then try next pixel rate
        BNE     %BT75
        ADD     R4, R4, #1 :SHL: ClockControlShift ; move to next clock rate
        TEQ     R4, #4 :SHL: ClockControlShift  ; if not finished
        ORRNE   R4, R4, #3              ; then set internal pixel rate to 3
        BNE     %BT75                   ; and loop

; R8 is best fit, so store it in the VIDC list

85
        ADD     R9, R13, #9*4+wkwordsize+&E0-&80 ; point at control register
        LDR     R10, [R9]               ; get previously specified CR
        BIC     R10, R10, #ClockControlMask ; knock out clock select
        BIC     R10, R10, #3            ; and pixel rate select
        ORR     R10, R10, R8
        STR     R10, [R9]
        B       %BT70                   ; go back and see if any more

; R2 = sync polarity specification
; bit 0 set => -ve Hsync
; bit 1 set => -ve Vsync

90
        ADD     R9, R13, #9*4+wkwordsize+&E0-&80 ; point at control register
        LDR     R10, [R9]               ; get previously specified CR
        BIC     R10, R10, #SyncControlMask ; knock out sync selects
        ORR     R10, R10, R2, LSL #SyncControlShift ; and insert new ones
        STR     R10, [R9]
        B       %BT70                   ; go back and see if any more

 ]
d1497 1
a1497 2
GenerateModeSelectorVars ENTRY "r0,r1,r3-r8,r10-r12"
 [ ModeSelectors
a1501 1
 ]
d1503 1
a1503 2
        BNE     %FT50                           ; [yes, so skip]
 [ ModeSelectors
a1576 4
 |
        B       %FT90                           ; it's not a new format sprite word, and mode selectors not enabled
                                                ; so return error
 ]
d1580 1
a1580 1
50
d1585 9
a1593 20
        MOV     r0, r2, LSR #27                 ; get type
        CMP     r0, #SpriteType_MAX             ; check for legality - NB type 0 is illegal because r2>=&100
        MOVCS   r0, #SpriteType_Substitute      ; substitute if unknown
        ADRL    lr, NSM_bpptable-4
        LDR     r0, [lr, r0, LSL #2]            ; get the bpp from table

        STR     r0, [r9, #wkLog2BPC]
        STR     r0, [r9, #wkLog2BPP]

        ADR     r1, NColourTable
        LDR     r1, [r1, r0, LSL #2]
        STR     r1, [r9, #wkNColour]

        ADR     r1, PalIndexTable
        LDRB    r1, [r1, r0]
        STR     r1, [r9, #wkPalIndex]

        ADR     r1, ECFIndexTable
        LDRB    r1, [r1, r0]
        STR     r1, [r9, #wkECFIndex]
d1595 2
d1599 3
d1605 1
a1605 1
        BEQ     %FT70
d1610 1
a1610 1
        BEQ     %FT70
d1614 1
a1614 1
        BNE     %FT80
d1617 1
a1617 1
70
d1620 1
d1623 3
d1629 1
a1629 1
        BEQ     %FT71
d1634 1
a1634 1
        BEQ     %FT71
d1638 1
a1638 1
        BNE     %FT80
d1641 1
a1641 1
71
d1644 23
d1670 53
a1722 1
80
d1735 9
a1743 1
PalIndexTable   =       0, 1, 2, 3, 6, 7
a1750 1
 [ ModeSelectors
d1767 1
a1767 1
ValidateModeSelector ENTRY
d1783 2
a1785 1
        SETV
a1789 1
 ]
d1804 1
a1804 1
ProcessModeVarPairs ENTRY "r4, r8, r10"
a1818 636
 [ VIDCListType3

                                ^       4
VIDCList3_PixelDepth            #       4
VIDCList3_HorizSyncWidth        #       4
VIDCList3_HorizBackPorch        #       4
VIDCList3_HorizLeftBorder       #       4
VIDCList3_HorizDisplaySize      #       4
VIDCList3_HorizRightBorder      #       4
VIDCList3_HorizFrontPorch       #       4
VIDCList3_VertiSyncWidth        #       4
VIDCList3_VertiBackPorch        #       4
VIDCList3_VertiTopBorder        #       4
VIDCList3_VertiDisplaySize      #       4
VIDCList3_VertiBottomBorder     #       4
VIDCList3_VertiFrontPorch       #       4
VIDCList3_PixelRate             #       4
VIDCList3_SyncPol               #       4
VIDCList3_ControlList           #       0

; Indices in control list

                                ^       1
ControlList_LCDMode             #       1
ControlList_LCDDualPanelMode    #       1
ControlList_LCDOffset0          #       1
ControlList_LCDOffset1          #       1
ControlList_HiResMode           #       1
ControlList_DACControl          #       1
ControlList_RGBPedestals        #       1
ControlList_ExternalRegister    #       1
ControlList_HClockSelect        #       1
ControlList_RClockFrequency     #       1
ControlList_DPMSState           #       1
ControlList_Interlaced          #       1
ControlList_InvalidReason       #       0

;
;       ProcessVIDCListType3 - Convert type3 VIDC list into VIDC20 parameters
;
; in:   r3 -> VIDC list (type 3)
;       r9 -> VIDC table (where R9!(nn << 2) holds parameter for register nnxxxxxx
;              for nn=80 to FF
;       stacked r2-r4, r7-r11, lr

ProcessVIDCListType3 ROUT
        LDR     r2, [r3, #VIDCList3_HorizSyncWidth]
        BIC     r2, r2, #1              ; must be even
        SUB     r2, r2, #8              ; horiz parameters start off at n-8
        ORR     r14, r2, #HorizSyncWidth
        STR     r14, [r9, #HorizSyncWidth :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizBackPorch]
        ADD     r2, r2, r4
        BIC     r2, r2, #1
        SUB     r2, r2, #4              ; HBSR is N-12
        ORR     r14, r2, #HorizBorderStart
        STR     r14, [r9, #HorizBorderStart :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizLeftBorder]
        ADD     r2, r2, r4
        BIC     r2, r2, #1
        SUB     r2, r2, #6              ; HDSR is N-18
        ORR     r14, r2, #HorizDisplayStart
        STR     r14, [r9, #HorizDisplayStart :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizDisplaySize]
        BIC     r4, r4, #1
        LDR     r7, [r3, #VIDCList3_PixelDepth]
        MOV     r10, r4, LSL r7         ; number of bits in one displayed raster (not needed later any more)

        ANDS    r8, r10, #31            ; if line length not multiple of 32
        MOVNE   r8, #DCR_HDis           ; then set HDis bit
        ORR     r8, r8, r10, LSR #5     ; OR in number of words per line

; Note - the DCR_Bus bits get overridden and the HDWR bits modified further down the line by the mode change code
; on the basis of how much VRAM we've got, and on whether we have a dual-panel LCD or not...

 [ MEMC_Type = "IOMD"
        ORR     r8, r8, #DCR_VRAMOff :OR: DCR_Bus31_0 :OR: DCR_Sync
 |
        ORR     r8, r8, #DCR_VRAMOff :OR: DCR_Bus31_0
 ]
        ORR     r8, r8, #VIDCDataControl
        STR     r8, [r9, #VIDCDataControl :SHR: 22]

        ADD     r2, r2, r4              ; HDER is also N-18
        ORR     r14, r2, #HorizDisplayEnd
        STR     r14, [r9, #HorizDisplayEnd :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizRightBorder]
        ADD     r2, r2, r4
        ADD     r2, r2, #6              ; HBER is N-12
        BIC     r2, r2, #1
        ORR     r14, r2, #HorizBorderEnd
        STR     r14, [r9, #HorizBorderEnd :SHR: 22]

        LDR     r4, [r3, #VIDCList3_HorizFrontPorch]
        ADD     r2, r2, r4
        ADD     r2, r2, #4              ; HCR is N-8
        BIC     r2, r2, #3              ; must be mult of 4
        ORR     r14, r2, #HorizCycle
        STR     r14, [r9, #HorizCycle :SHR: 22]

        ADD     r2, r2, #8              ; HIR is N/2
        MOV     r2, r2, LSR #1
        ORR     r14, r2, #HorizInterlace
        STR     r14, [r9, #HorizInterlace :SHR: 22]

        LDR     r2, [r3, #VIDCList3_VertiSyncWidth]
        SUB     r2, r2, #2              ; vertical registers are N-2
        ORR     r14, r2, #VertiSyncWidth
        STR     r14, [r9, #VertiSyncWidth :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiBackPorch]
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiBorderStart
        STR     r14, [r9, #VertiBorderStart :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiTopBorder]
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiDisplayStart
        STR     r14, [r9, #VertiDisplayStart :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiDisplaySize]
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiDisplayEnd
        STR     r14, [r9, #VertiDisplayEnd :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiBottomBorder]
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiBorderEnd
        STR     r14, [r9, #VertiBorderEnd :SHR: 22]

        LDR     r4, [r3, #VIDCList3_VertiFrontPorch]
        ADD     r2, r2, r4
        ORR     r14, r2, #VertiCycle
        STR     r14, [r9, #VertiCycle :SHR: 22]

        LDR     r4, [r3, #VIDCList3_SyncPol]
        MOV     r14, #VIDCExternal
        TST     r4, #1
        ORRNE   r14, r14, #Ext_InvertHSYNC
        TST     r4, #2
        ORRNE   r14, r14, #Ext_InvertVSYNC
        ORR     r14, r14, #Ext_DACsOn
        ORR     r14, r14, #Ext_ERegExt
        STR     r14, [r9, #VIDCExternal :SHR: 22]

        MOV     r14, #VIDCControl
        STR     r14, [r9, #VIDCControl :SHR: 22]

        Push    "r0, r1"
        Push    "r3"

; Now go through VIDC control parameters list (not all indices can be handled yet)

        ADD     r3, r3, #VIDCList3_ControlList-8  ; point at 1st entry -8
50
        LDR     r4, [r3, #8]!                   ; load next index
        CMP     r4, #-1                         ; if -1 then end of list
        BEQ     %FT60                           ; so skip

        CMP     r4, #0                          ; if non-zero (CS if zero)
        CMPNE   r4, #ControlList_InvalidReason  ; and if known reason
        LDRCC   r2, [r3, #4]                    ; then load value
        BLCC    ProcessControlListItem          ; and process this item
        B       %BT50                           ; go onto next item in list

; put a minimum of 4, cos 800 x 600 x 1bpp don't work otherwise
FIFOLoadTable
        &       0                               ; dummy entry (not used)
        &       0                               ; never use 0
        &       0                               ; use 1 up to (and including) here
        &       0                               ; use 2 up to (and including) here
        &       0                               ; use 3 up to (and including) here
        &       60000 :SHL: 3                   ; use 4 up to (and including) here
        &       75000 :SHL: 3                   ; use 5 up to (and including) here
        &       90000 :SHL: 3                   ; use 6 up to (and including) here
                                                ; else use 7

60
        Pull    "r3"
        LDR     r0, [r3, #VIDCList3_PixelRate]  ; get pixel rate
   [ ChrontelSupport
	ORR	r10, r0, #PseudoRegister_PixelRate               ; Set index
        STR     r10, [r9, #PseudoRegister_PixelRate :SHR: 22]    ; Store for later
   ]
        MOV     r10, r0, LSL r7                 ; peak mem b/w (x 1E3 bits/sec) - save for FIFO calculation

 [ MorrisSupport
   ;     MOV     R14, #IOMD_Base
   ;     LDRB    R1, [R14, #IOMD_ID0]
   ;     CMP     R1, #&E7
   ;     LDRB    R1, [R14, #IOMD_ID1]
   ;     CMPEQ   R1, #&D4
   ;     MOVNE   R1, #32000              ;Morris clocks VIDC20L at 32Mhz
   ;     LDREQ   R1, =24000              ;RISC PC clocks VIDC20 at 24MHz
        MOV     R1, #0
        LDRB    R1, [R1, #IOSystemType]
        TST     R1, #IOST_7500
        LDREQ   R1, =24000              ;RISC PC clocks VIDC20 at 24MHz
        MOVNE   R1, #32000              ;Morris clocks VIDC20L at 32Mhz
;>>>RCM says can we replace the above by
;>>>    LDR     R1, [WsPtr, #VIDCClockSpeed]
 |
        LDR     r1, =rclk       ; eventually will need to replace this if specified in control list
 ]
        BL      ComputeModuli   ; out: r0 = FSync bits, r1 = CR bits
        ORR     r0, r0, #VIDCFSyn
        STR     r0, [r9, #VIDCFSyn :SHR: 22]

        LDR     r0, [r9, #VIDCControl :SHR: 22]
        ORR     r0, r0, r1

        TEQ     r7, #5          ; if 32 bpp, then stick in 6 not 5
        MOVEQ   r7, #6
        ORR     r0, r0, r7, LSL #5

; now work out FIFO load position - r10 is b/w in thousands of bytes/sec

; do it by means of a binary chop on 3 bits

        ADR     r4, FIFOLoadTable
        LDR     r2, [r4, #4*4]                  ; load 0-3/4-7 split
        CMP     r10, r2
        MOVLS   r7, #0                          ; if <=, then bottom half
        MOVHI   r7, #4                          ; else top half
        ADDHI   r4, r4, #4*4                    ; and advance table pointer

        LDR     r2, [r4, #2*4]
        CMP     r10, r2
        ORRHI   r7, r7, #2
        ADDHI   r4, r4, #2*4

        LDR     r2, [r4, #1*4]
        CMP     r10, r2
        ORRHI   r7, r7, #1

        ORR     r0, r0, r7, LSL #CR_FIFOLoadShift
        STR     r0, [r9, #VIDCControl :SHR: 22]

; Now, for debugging purposes, output data to a file

 [ {FALSE}

        ! 0, "**** WARNING: Mode change debugging assembled in ****"

        [ :LNOT: STB
	MOV	r0, #0
	LDRB	r0, [r0, #LCD_Active]
	CMP	r0, #2
        Pull    "r0, r1, r2-r4, r7-r11, pc", NE
        ]


        MOV     r0, #&80
        ADR     r1, ModeFilename
        SWI     XOS_Find

        Pull    "r0, r1, r2-r4, r7-r11, pc", VS

        MOV     r1, r0
        MOV     r0, #2
        ADD     r2, r9, #VIDCParmsSize  ; r2 -> data
        MOV     r3, #VIDCParmsSize
        SWI     XOS_GBPB

        MOV     r0, #0
        SWI     XOS_Find

        Pull    "r0, r1, r2-r4, r7-r11, pc"

ModeFilename
        =       "$.ModeData", 0
        ALIGN
 |
        Pull    "r0, r1, r2-r4, r7-r11, pc"
 ]

; *****************************************************************************
;
;       ProcessControlListItem
;
; in:   r2 = value for item
;       r4 = index for item (guaranteed in range)
;       r9 -> VIDC register array
;
; out:  r0-r2, r4, r7, r8, r10, r11 may be corrupted
;       r3, r9, r12 must be preserved

ProcessControlListItem ENTRY
        LDR     pc, [pc, r4, LSL #2]
        NOP
        &       ProcessControlListNOP                   ; 0 - NOP
        &       ProcessControlListLCDMode               ; 1 - LCD mode
        &       ProcessControlListLCDDualPanelMode      ; 2 - LCD dual-panel mode
        &       ProcessControlListLCDOffsetRegister0    ; 3 - LCD offset register 0
        &       ProcessControlListLCDOffsetRegister1    ; 4 - LCD offset register 1
        &       ProcessControlListHiResMode             ; 5 - Hi-res mode
        &       ProcessControlListDACControl            ; 6 - DAC control
        &       ProcessControlListRGBPedestals          ; 7 - RGB pedestal enables
        &       ProcessControlListExternalRegister      ; 8 - External register
        &       ProcessControlListHClockSelect          ; 9 - HClk select/specify
        &       ProcessControlListNOP                   ; 10 - RClk frequency
        &       ProcessControlListDPMSState             ; 11 - DPMS state
        &       ProcessControlListNOP                   ; 12 - Interlaced mode

ProcessControlListLCDMode
        [ STB
        MOV     r1, #Ext_LCDGrey
        |
        MOV     r0, #0
	LDRB	r1, [r0, #LCD_Active]		;Read the existing value
	AND	r1, r1, #&80			;Clear all but the single/dual bit, 'cos this might have been set already
	ORR	r1, r1, r2			;Bung our new lcdmode into the byte, and....
        STRB    r1, [r0, #LCD_Active]           ;...store in the KernelWS which LCD mode we are in.
        MOV     r1, #Ext_ECKOn			;Set the ECLK on

	CMP	r2, #3				;Was (is) it active-matrix?
	ORRNE	r1, r1, #Ext_LCDGrey		;If not, set the LCD greyscaler 'on'
	]
05
        MOV     r0, #VIDCExternal
10
        MOV     r7, r1
        TEQ     r2, #0                          ; if value non-zero
        MOVNE   r2, r1                          ; then use value in r1
15
        AND     r2, r2, r7                      ; ensure only relevant bits set
        LDR     lr, [r9, r0, LSR #22]           ; load word from register bank
        BIC     lr, lr, r7                      ; knock out bits in mask
        ORR     lr, lr, r2                      ; OR in new bits
        STR     lr, [r9, r0, LSR #22]           ; and store in array

ProcessControlListNOP
        EXIT

ProcessControlListHiResMode
        MOV     r1, #Ext_HiResMono              ; bit of a misnomer, it's not nec. mono
        B       %BT05

ProcessControlListDACControl
        MOV     r1, #Ext_DACsOn
        B       %BT05

ProcessControlListRGBPedestals
        MOV     r0, #VIDCExternal
        MOV     r2, r2, LSL #Ext_PedsShift
        MOV     r7, #Ext_PedsOn
        B       %BT15

ProcessControlListExternalRegister
        MOV     r0, #VIDCExternal
        MOV     r7, #&FF
        B       %BT15

ProcessControlListLCDDualPanelMode
        [ STB
        MOV     r0, #VIDCControl
        MOV     r1, #CR_DualPanel
        B       %BT10
        |
        MOV     r0, #0
	LDRB	r1, [r0, #LCD_Active]
	ORR	r1, r1, #&80			;Set the top bit & leave the rest as-is
        STRB    r1, [r0, #LCD_Active]           ;Store in the KernelWS that we are in dual-panel LCD mode.
        LDR     r0, [r9, #VIDCDataControl :SHR: 22]
        MOV     r1, r0, LSL #(31-10)            ;Put HDWR bits to the top
        BIC     r0, r0, r1, LSR #(31-10)        ;knock off bits
        ORR     r0, r0, r1, LSR #(31-11)        ;Put back one bit further up (ie mul by 2)
        STR     r0, [r9, #VIDCDataControl :SHR: 22]

        LDR     r0, [r9, #VertiDisplayEnd :SHR: 22]
	LDR	r1, [r9, #VertiDisplayStart :SHR: 22]
	BIC	r0, r0, #VertiDisplayEnd
	BIC	r1, r1, #VertiDisplayStart
	SUB	r0, r0, r1			;R0 = Vres
	ADD	r1, r1, r0, LSR #1		;R1 = Vres/2 + VDSR
	ORR	r1, r1, #VertiDisplayEnd
	STR	r1, [r9, #VertiDisplayEnd :SHR: 22]

	LDR	r1, [r9, #VertiCycle :SHR: 22]
	BIC	r1, r1, #VertiCycle
	SUB	r1, r1, r0, LSR #1
	ORR	r1, r1, #VertiCycle
	STR	r1, [r9, #VertiCycle :SHR: 22]

	LDR	r1, [r9, #VertiBorderEnd :SHR: 22]
	BIC	r1, r1, #VertiBorderEnd
	SUB	r1, r1, r0, LSR #1
	ORR	r1, r1, #VertiBorderEnd
	STR	r1, [r9, #VertiBorderEnd :SHR: 22]

	LDR	r1, [r9, #VIDCExternal :SHR: 22]
	BIC	r1, r1, #Ext_ERegExt
	ORR	r1, r1, #Ext_ERegGreen
	STR	r1, [r9, #VIDCExternal :SHR: 22]

        MOV     r0, #VIDCControl
        MOV     r1, #CR_DualPanel
        B       %BT10
        ]

ProcessControlListLCDOffsetRegister0
        MOV     r0, #LCDOffsetRegister0
20
        ORR     r2, r2, r0                      ; put high bits of register at top
        STR     r2, [r9, r0, LSR #22]           ; and store in array
	MOV	r0, #VIDC			;ACTUALLY PROGRAM VIDC (I know I shouldn't but I don't care - I've got a cold)
	STR	r2, [r0]
        EXIT

ProcessControlListLCDOffsetRegister1
        MOV     r0, #LCDOffsetRegister1
        B       %BT20

ProcessControlListHClockSelect
        MOV     r0, #PseudoRegister_HClockSpeed ; pseudo-register holding HClock speed
        B       %FT40

ProcessControlListDPMSState
        MOV     r0, #PseudoRegister_DPMSState   ; pseudo-register holding DPMS state
40      ORR     r2, r2, r0                      ; form combined value
        STR     r2, [r9, r0, LSR #22]           ; store in register
        EXIT


; *****************************************************************************
;
;       ComputeModuli - Work out VCO moduli for a given frequency
;
; in:   r0 = desired frequency (kHz)
;       r1 = rclk frequency (kHz) (normally 24000)
;       r9 -> VIDC table
;
; out:  r0 = bits to put in bits 0..15 of Frequency Synthesizer Register
;       r1 = bits to put in bits 0..4 of Control Register

rclk    *       24000           ; Reference clock into VIDC20 (in kHz)
VCO_Min *       55000           ; minimum VCO frequency (in kHz)
VCO_Max *      110000           ; maximum VCO frequency (in kHz)

fpshf   *       11              ; Shift value for fixed point arithmetic

        ^       0, sp

BestDInOrOutOfRange     #       4
BestRInOrOutOfRange     #       4
BestVInOrOutOfRange     #       4
BestDInRange            #       4
BestRInRange            #       4
BestVInRange            #       4
BestRangeError          #       4
ComputeModuliStack      *       :INDEX: @@

ComputeModuli ENTRY "r2-r12", ComputeModuliStack
        LDR     r2, [r9, #PseudoRegister_HClockSpeed:SHR:22]            ; are we using HCLK?
        CMP     r2, #-1
        BEQ     %FT05                                                   ; -1 => no, use VCLK/RCLK

        BIC     r1, r2, #&FF000000                                      ; r1 = HCLK frequency
        SUB     r1, r1, r1, LSR #2                                      ; r1 = HCLK * 3/4
        CMP     r0, r1
        MOVLO   r1, #CR_HCLK :OR: ((2-1) :SHL: CR_PixelDivShift)        ; if < 3/4 HCLK, use divide by 2
        MOVHS   r1, #CR_HCLK :OR: ((1-1) :SHL: CR_PixelDivShift)        ; else use divide by 1
        LDR     r0, =(63 :SHL: FSyn_RShift) :OR: (1 :SHL: FSyn_VShift)  ; minimum V, maximum R
        EXIT

; Use VCLK/RCLK
05
        MOV     r12, #-1                ; smallest error for values in or out of VCO range
        MOV     r11, #-1                ; smallest error for values in VCO range
        STR     r11, BestDInRange
        STR     r11, BestVInRange
        STR     r11, BestRInRange
        STR     r11, BestDInOrOutOfRange
        STR     r11, BestVInOrOutOfRange
        STR     r11, BestRInOrOutOfRange
        STR     r11, BestRangeError
        MOV     r5, r1                  ; r5 = rclk frequency, normally 24000 (32000 on Morris)
        LDR     r1, =VCO_Min            ; r1 = minimum VCO frequency (in kHz)
        LDR     r2, =VCO_Max            ; r2 = maximum VCO frequency (in kHz)
        MOV     r3, #1                  ; r3 = D
10
        MOV     r4, #1                  ; r4 = R
15
        MUL     r6, r0, r3              ; r6 = xD
        MUL     r7, r6, r4              ; r7 = xRD
        ADD     r7, r7, r5, LSR #1      ; r7 = xRD + vref/2
        DivRem  r8, r7, r5, r9          ; r8 = (xRD + vref/2) DIV vref = V value

        TEQ     r4, #1                  ; if R=1 then V must be 1, else it's no good
        BNE     %FT20
        TEQ     r8, #1
        BNE     %FT50
        BEQ     %FT25
20
        CMP     r8, #2                  ; if R<>1 then V must be in range 2..64
        RSBCSS  r7, r8, #64
        BCC     %FT50                   ; V out of range, so skip
25
        MUL     r7, r5, r8              ; r7 = V * vref
        MOV     r7, r7, LSL #fpshf      ; r7 = (V * vref) << fixedpointshift
        DivRem  r9, r7, r4, r14         ; r9 = ((V * vref) << fixedpointshift)/R = VCO frequency << fixedpointshift
        MOV     r6, r9
        DivRem  r7, r9, r3, r14         ; r7 = output frequency << fixedpointshift
        SUBS    r7, r7, r0, LSL #fpshf
        RSBCC   r7, r7, #0              ; r7 = absolute error << fixedpointshift

        TEQ     r4, #1                  ; if R=1 then no need to check VCO range
        BEQ     %FT27                   ; because VCO won't be used, so it's a 1st class citizen

        CMP     r6, r1, LSL #fpshf      ; test if VCO freq >= min
        RSBCSS  r14, r6, r2, LSL #fpshf ; and <= max
        BCC     %FT40                   ; not in range, so not a first class citizen
27
        CMP     r7, r11
        BHI     %FT40                   ; worse than the best case for in VCO range, so ignore
        BCC     %FT30                   ; is definitely better than the best case for in or out

        LDR     r14, BestRInRange       ; is equal best for in, so check R value
        CMP     r4, r14                 ; is newR < bestR
        BCS     %FT40                   ; is greater or equal R value (ie not higher comp. freq., so not best)
30
        MOV     r11, r7
        STR     r3, BestDInRange
        STR     r4, BestRInRange
        STR     r8, BestVInRange
        MOV     r14, #0
        B       %FT45

40
        RSBS    r14, r6, r1, LSL #fpshf ; r14 = min-this, if this<min
        SUBCC   r14, r6, r2, LSL #fpshf ; else r14 = this-max, ie r14 = how much this is outside range

        CMP     r7, r12
        BHI     %FT50                   ; worse than the best case for in or out of VCO range, so ignore
        BCC     %FT45                   ; is definitely better than the best case for in or out

        LDR     r9, BestRangeError      ; is equal best for in or out, so check error
        CMP     r14, r9
        BCS     %FT50                   ; not lower error, so skip
45
        MOV     r12, r7
        STR     r3, BestDInOrOutOfRange
        STR     r4, BestRInOrOutOfRange
        STR     r8, BestVInOrOutOfRange
        STR     r14, BestRangeError
50
  [ :LNOT: DontUseVCO                   ; If we don't use the VCO, R has to be 1
        ADD     r4, r4, #1
        CMP     r4, #16                 ; R goes from 2 to 16 (was 2 to 64)
        BLS     %BT15
  ]

        ADD     r3, r3, #1
        CMP     r3, #8                  ; D goes from 1 to 8
        BLS     %BT10

        ADR     r2, BestDInRange
        LDR     r3, [r2]
        CMP     r3, #-1
        ADDEQ   r2, r2, #BestDInOrOutOfRange - BestDInRange
        LDREQ   r3, [r2]                ; r3 = Best D
        LDR     r4, [r2, #BestRInRange - BestDInRange]  ; r4 = Best R
        LDR     r5, [r2, #BestVInRange - BestDInRange]  ; r5 = Best V

        SUBS    r4, r4, #1              ; values in FSyn are n-1
  [ VCOstartfix
        ;do *not* do the very slow trick - this will stall the VCO and it may not restart
        ;properly later (we don't give a fig for power consumption)
        MOVEQ   r4, #3
        MOVEQ   r5, #8                  ; after sub below, (7+1)/(3+1) so VCO runs at twice ref clock
  |
        MOVEQ   r4, #63                 ; if R=V=1 then use max R
        MOVEQ   r5, #2                  ; and min V to make VCO go really slow
  ]

        SUB     r5, r5, #1              ; for both v and r
        ASSERT  FSyn_RShift = 0
        ORR     r0, r4, r5, LSL #FSyn_VShift

        SUB     r3, r3, #1              ; D is also stored as n-1
        MOV     r1, r3, LSL #CR_PixelDivShift
        ASSERT  CR_VCLK = 0
        ORREQ   r1, r1, #CR_RCLK        ; if using VCO then set for VCLK, else RCLK

        EXIT
 ] ; VIDCListType3

; *****************************************************************************
;
;       UpdateVIDCTable - Add changes to a pushed VIDC table
;
; in:   R9 + nn        -> entry on stack for register nn000000
;    or R9 + (nn << 2) -> ditto, for VIDC20
;       R11 -> change table, terminated with -1
;
; out:  R11 -> word after -1 terminator
;       All other registers preserved (including PSR)
;
 [ MorrisSupport
UpdateVIDCTable ROUT
        EntryS "R0"
        MOV     R0, #0
        LDRB    R0, [R0, #IOSystemType]
        TST     R0, #IOST_7500
        MOVEQ   R0, #1                          ;if rclk is 24MHz, stop at first -1
        MOVNE   R0, #2                          ;if rclk is 32MHz, overwrite clock dividers with different data
10
        LDR     R14, [R11], #4
        CMP     R14, #-1
        LDREQ   R14, [R11], #4                  ;EQ, on terminator, so skip it
        SUBEQS  R0, R0, #1
        EXITS   EQ                              ;EQ, quit on first (iff rclk=24MHz) or second terminator (iff rclk=32MHz)

        CMP     R14, #&80000000                 ; must be in range &80..&FF
        STRCS   R14, [R9, R14, LSR #22]         ; NB bits 23 and 22 are assumed to be zero
        B       %BT10
 |
UpdateVIDCTable ROUT
        EntryS
10
        LDR     R14, [R11], #4
        CMP     R14, #-1
        EXITS   EQ
        CMP     R14, #&80000000                 ; must be in range &80..&FF
  [ VIDC_Type = "VIDC20"
        STRCS   R14, [R9, R14, LSR #22]         ; NB bits 23 and 22 are assumed to be zero
  |
        STRCS   R14, [R9, R14, LSR #24]
  ]
        B       %BT10
 ]

a1832 1
 [ ModeSelectors
a1912 7
 |
        Push    "r1, lr"
        MOV     r1, #Service_ModeExtension
        IssueService
        TEQ     r1, #0
        Pull    "r1, pc"
 ]
d1919 4
d1927 1
a1927 1
        LDR     R0, [WsPtr, #VIDCControlCopy]           ; get saved VIDC control register
d1935 1
d1938 1
d2189 4
a2192 1
        LDR     R4, [WsPtr, #BitsPerPix] ; if BitsPerPix <> 'fudged' BitsPerPix
d2194 1
a2194 1
        TEQ     R4, R5
d2201 1
a2201 1
SetCol40
d2203 1
a2203 1
SetCol50
d2207 1
a2207 1
        BNE     SetCol50
d2210 35
a2244 1
        BNE     SetCol40
d2361 1
a2361 1
        msr    ,CPSR_f, R7                      ; put bits into N, Z, C, V
d2537 2
a2538 2
        LDR     R0, [WsPtr, #ModeFlags]
        TST     R0, #Flag_HardScrollDisabled
d2712 69
@


4.12
log
@  Added compile-time support for full-resolution teletext characters in
  teletext emulation mode (MODE 7) for that authentic BBC Micro feel.
  Also introduced a few useful teletext control features via VDU 23,18.
  Unrelatedly, fixed *ScreenLoad to work for interlaced displays.

Detail:
  The new typeface is designed on a 16x20 grid (previously we had used 8x10),
  so it uses a screen resolution of 640x500 pixels (rather than 320x250).
  Since we have been unable to source a genuine teletext font, and since
  examination of a BBC Micro suggests that the genuine font may not have been
  a power-of-2 pixels wide, I have designed one specially, based upon the one
  supplied in Zap distributions (a 12x20 font). Rather than increase the
  amount of workspace that the kernel requires for cacheing graphic
  characters, it now generates them on the fly, as they are required; this
  should only add about 25% to their rendering time.

  The new VDU 23 sequences are as follows:

  VDU 23,18,0,mode,0,0,0,0,0,0
    Switch transparency mode
      mode = 0: "Text" mode: the whole display is set opaque
      mode = 1: "Mix" mode: foreground colours, and both foreground and
        background of boxed text are opaque; non-boxed background colours are
        all transparent
      mode = 2: "Box" mode: boxed regions are opaque, others are transparent
      mode = 3: "TV" mode: the whole display is set transparent
    Default is mode = 0.

  VDU 23,18,1,suspend,0,0,0,0,0,0
    Suspend or resume bitmap updates
    This call allows an application to request that the kernel suspends
    updates to the framebuffer bitmap. This allows for a significant speed
    increase in the rendering time for a large amount of text, for example
    when redrawing a complete teletext page, because each time you plot a
    single character, it can cause the whole of the rest of the line to be
    re-rendered. When you switch out of suspend mode, the whole screen is
    refreshed in a single pass. Note that the appearance of the display is
    undefined is you cause a hardware scroll while in suspend mode.
      suspend = 0: screen update is enabled
      suspend = 1: screen update is suspended
    Default is suspend = 0.

  VDU 23,18,2,reveal,0,0,0,0,0,0
    Reveal/conceal
      reveal = 0: characters between the Conceal control code and the next
        colour control code are replaced by spaces
      reveal = 1: all characters are displayed
    Default is reveal = 0.

  VDU 23,18,3,black_emable,0,0,0,0,0,0
    Enable/disable black foreground colour control codes
      black_enable = 0: control codes &80 and &90 do nothing
      black_enable = 1: control code &80 selects black text, control code
        &90 selects black graphics
    Default is black_enable = 0.

  I have performed some timing tests on the rendering of complete teletext
  pages grabbed from the teletext server. These show that the new code
  generally imposes a 2x speed hit. However, when using the VDU 23,18,1
  suspend function, this improves to a 20% speed increase when compared to
  the old low-resolution code. Better still, because the framebuffer is only
  being updated for the final stage of this process, the screen *appears* to
  be updated some 3x faster than with the old code!

  A comment on the VDU variable Log2BPC is in order: in previous kernels,
  this was able unambiguously to refer to both the framebuffer width of a
  character in bytes, and the framebuffer width of an "addressable pixel" in
  bits; this no longer works with the 16-pixel wide teletext font. Bearing
  in mind that future kernels may support Unicode system fonts where the
  width varies from character to character, I have chosen to fix Log2BPC to
  the "addressable pixel" definition.

Admin:
  Requires HdrSrc 0.89 and (for non-desktop builds) Interlace 0.61. A monitor
  definition file containing a definition for a 640x500 screen mode is also
  required; version 0.40 of ModeFiles contains a suitable mode for STB-400.

  Tested fairly rigourously on an Ursula build, a Lazarus build and an
  STB-400 build, using genuine teletext pages and Yellow River Kingdom.

Version 5.30. Tagged as 'Kernel-5_30'
@
text
@d2600 1
a2600 1
        EXITS
@


4.12.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@a120 3
  [ HAL
        !       0, "Sort out GetBandwidthAndSize"
  |
a128 1
  ]
d289 1
a289 1
InitialiseMode Entry
d1024 1
a1024 1
        LDRB    r14, [r14, #VRAMWidth]
d1276 1
a1276 1
IssueModeService Entry "r2,r3"
d1596 1
a1596 1
GenerateModeSelectorVars Entry "r0,r1,r3-r8,r10-r12"
d1793 1
a1793 1
ValidateModeSelector Entry
d1830 1
a1830 1
ProcessModeVarPairs Entry "r4, r8, r10"
d2136 1
a2136 1
ProcessControlListItem Entry
d2301 1
a2301 1
ComputeModuli Entry "r2-r12", ComputeModuliStack
d2988 1
a2988 1
        MSR     CPSR_f, R7                      ; put bits into N, Z, C, V
@


4.12.2.2
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@d34 2
a35 2
        GBLL    LCDPowerCtrl
LCDPowerCtrl    SETL {TRUE} :LAND: :LNOT: STB
d115 1
d124 1
d128 4
d134 1
d162 5
a166 5
        STRB    R0, [WsPtr, #PointerShapeNumber]  ; make sure pointer off
        STR     R0, [WsPtr, #PointerShapeLA]      ; no shape passed to HAL yet
        STR     R0, [WsPtr, #CursorStack]         ; 0 bits => on
        STR     R0, [WsPtr, #VduSaveAreaPtr]      ; indicate no save area yet
        STR     R0, [WsPtr, #ClipBoxEnable]       ; no clip box calculating
d190 1
d205 1
d209 1
d211 1
d221 9
a229 47
; mjsHAL - temporary workspace while semi HALised code still in kernel
;
        MOV     r3, #mjs_thalwk_size
        BL      ClaimSysHeapNode          ; this had better succeed!
        LDR     r4, =mjs_tempHALworkspace
        STR     r2, [r4, #0]
        BL      mjs_tempHALworkspace_init
;

;initialise the 6 pointer shape pointers and blocks
;(shape buffers are 6 * &100 starting at CursorData)
;
        ADD     r0, WsPtr, #PointerShapes
        LDR     r2, =CursorData
        MOV     r3, #6
        ADD     r4, WsPtr, #PointerShapeBlocks
02
        STR     r4, [r0]                 ; attach pointer to block
        STR     r2, [r4, #PointerBuffLA]
        Push    "r0-r2"
        MOV     r1, #0
        STRB    r1, [r4, #PointerWidth]  ; zero width
        STRB    r1, [r4, #PointerHeight] ; zero height (no shape)
        SUB     sp, sp, #3*4             ; room for one entry of OS_Memory page block
        MOV     r1, sp
        STR     r2, [r1, #4]             ; provide logical address
        MOV     r2, #1
        MOV     r0, #&2200               ; convert logical to physical address
        SWI     XOS_Memory
        LDR     r2, [r1, #8]             ; read physical address
        STR     r2, [r4, #PointerBuffPA]
        ADD     sp, sp, #3*4
        Pull    "r0-r2"
        ADD     r4, r4, #PointerBlkSize
        ADD     r2, r2, #&100
        ADD     r0, r0, #4
        SUBS    r3, r3, #1
        BNE     %BT02

; palette space (256 normal + 1 border + 3 pointer = 260), and allowing for Gamma Correction
;   this space is: blank palette, 260 words
;                  logical and physical copies of both flash states, 260*4 words
;                  3 lookup tables for r,g,b mapping, 3*256 bytes
;
        MOV     r3, #260*4
        ADD     r3, r3, #260*4*4 + 3*256 
        BL      ClaimSysHeapNode           ; this had better succeed!
a230 1
        STR     r2, [WsPtr, #BlankPalAddr]
a231 2
        STR     r3, [WsPtr, #FirPalAddr]
        ADD     r3, r3, #260*4
d234 9
a242 1
; initialise blank palette to all solid black
d244 6
a249 5
        MOV     r3, #0
        MOV     r4, #260     
04      STR     r3, [r2], #4
        SUBS    r4, r4, #1
        BNE     %BT04
d251 2
a252 1
        ADD     r2, r2, #260*4*4   ; r2 -> rgb tables
d254 1
d265 2
d308 1
d313 5
d616 1
d619 1
d630 1
d634 3
d673 1
d714 3
d725 11
a735 11
        [ LCDPowerCtrl :LAND: :LNOT: STB
        ;Switch LCD off here if it is _not_ an LCD mode
        MOV     R3, #0
        LDRB    R3, [R3, #LCD_Active]
        ANDS    R0, R3, #&7F            ;Pick out the lcd mode bits, ignoring the single/dual panel bit
        Push    "r0-r1"
        MOVEQ   R0, #0
        LDREQ   R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        SWIEQ   XPortable_Control
        Pull    "r0-r1"
        ]
d819 198
a1016 2
        Push    "R0-R3, R9, R12"                ; preserve registers ready to make HAL call later 
        ADD     R0, R13, #wkwordsize+6*4        ; R0 -> VIDCList3 (we have just pushed 6 regs)
d1018 174
a1191 42
;adjust vertical porch parameters in VIDCList3 for TVVertical (from *TV)
;
        LDROSB  R1, TVVertical
        MOV     R1, R1, LSL #24          ; sign extend to 32 bits
        MOV     R1, R1, ASR #24-3        ; and multiply by 8
        LDR     R2, [WsPtr, #ModeFlags]
        TST     R2, #Flag_GapMode        ; gap mode ?
        ADDNE   R1, R1, R1, ASR #2       ; add on 2 rows if so
        TST     R2, #Flag_DoubleVertical ; if double vertical
        ADDNE   R1, R1, R1               ; then double it
        LDR     R2, [R0, #VIDCList3_VertiBackPorch]
        SUBS    R2, R2, R1
        MOVMI   R2, #0
        STR     R2, [R0, #VIDCList3_VertiBackPorch]   ;subtract from back porch, clamp at 0
        LDR     R2, [R0, #VIDCList3_VertiFrontPorch]
        ADDS    R2, R2, R1
        MOVMI   R2, #0
        STR     R2, [R0, #VIDCList3_VertiFrontPorch]  ;add to front porch, clamp at 0

;remember pixel rate (kHz) from VIDCList3
;
        LDR     R2, [R0, #VIDCList3_PixelRate]
        STR     R2, [WsPtr, #PixelRate]   

;remember DPMSState (if specified) from VIDCList3
;
        MOV     R2, #0                      ; DPMSState = 0 if not specified in list
        ADD     R1, R0, #VIDCList3_ControlList
20      LDR     R3, [R1], #8                ; loop over the control parameter list
        CMP     R3, #-1
        BEQ     %FT30                       ; didn't find the DPMSState entry
        TEQ     R3, #ControlList_DPMSState
        BNE     %BT20                       ; next control parameter
        LDR     R2, [R1, #-4]               ; read DPMSState value
        AND     R2, R2, #3                  ; only bits 0,1 valid
30
        STRB    R2, [WsPtr, #ScreenBlankDPMSState]
     
;kernel/HAL split - call the HAL to program video controller for mode,
;
        mjsAddressHAL
        mjsCallHAL    HAL_Video_SetMode
d1193 4
a1196 1
        Pull    "R0-R3, R9, R12"            ; restore registers after HAL call
a1199 4
;;; mjsHAL - still some hardware dependency here - IOMD for DMA etc
;;;          needs transfer to HAL routine, either as part of hit-specific-VIDC
;;;          call above, or as additional call(s)

d1204 5
d1225 11
a1235 11
        [ LCDPowerCtrl :LAND: :LNOT: STB
        ;Switch the LCD on if LCD mode
        Push    "r0"
        MOV     R1, #0
        LDRB    R1, [R1, #LCD_Active]
        ANDS    R1, R1, #&7F            ;Check the LCD mode bits only, not the single/dual panel bit
        LDRNE   R0, =(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        LDRNE   R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        SWINE   XPortable_Control
        Pull    "r0"
        ]
d1247 12
d1288 1
a1288 1
;       PushModeInfo - Push appropriate mode table and video controller params
d1291 1
a1291 1
; in:   R10 = mode to try for
d1293 1
a1293 1
;       R10 and R11 should have bit 7 CLEAR (if mode numbers)
d1298 1
a1298 1
;         stack flat (no pushed info)
d1300 3
a1302 3
;         V=0
;         Stack holds a mode table (size wkwordsize) and VIDCList
;         type 3 (size VIDCList3Size) (total size PushedInfoSize)
d1312 1
d1315 1
d1327 1
d1356 7
d1369 1
d1384 2
d1403 3
a1405 4
; special VIDCListType3 widgetry
; 1) Set SyncPol_Interlace (according to TVInterlace) if not already specified 
; 2) check for the interlaced flag in the control parameters - if set, set the interlaced
;    flag in the mode flags
d1409 1
a1409 1
        LDR     r2, [r3, #0]            ; is it type 3? (actually, it always should be now)
a1412 10
        LDR     r10, [r3, #VIDCList3_SyncPol]
        TST     r10, #SyncPol_InterlaceSpecified
        BNE     %FT56                              ; Interlace already specified
        LDROSB  R14, TVInterlace
        TST     R14, #1
        ORRNE   R10, R10, #SyncPol_InterlaceSpecified                     ; specify as non-interlaced
        ORREQ   R10, R10, #(SyncPol_InterlaceSpecified+SyncPol_Interlace) ; specify as interlaced
        STR     R10, [r3, #VIDCList3_SyncPol]

56
d1430 1
d1437 15
a1451 2
; mjs Kernel/HAL split
; pushed video controller info is now hardware independent, it is a VIDCList type 3
d1456 6
a1461 12
59
        ADD     R14, R9, #wkwordsize    ; R14 -> space for VIDCList3
        MOV     R10, #VIDCList3Size     ; its a VIDCList3, R10 is max room we have    
60
        LDR     R8, [R3], #4            ; copy list
        SUBS    R10, R10, #4
        MOVEQ   R8, #-1                 ; emergency terminate (source list too long)
        STR     R8, [R14], #4
        CMP     R8, #-1
        BNE     %BT60
        CLRV
        Pull    "R2-R4,R7-R11, PC"      ; done
d1463 2
a1464 1
62                                      ; arrive here if service not claimed, R2 = provided mode number
a1470 1
64
d1474 104
a1577 4
        ADDCC   R3, R14, R11            ; then add to table address (R3 -> VIDCList3 from table)
        BCC     %BT59                   ; copy it and exit
        MOV     R11, #0                 ; desperate again, use mode 0 monitortype 0 (this had better have valid entry)
        B       %BT64
d1601 1
d1606 1
d1609 1
d1683 4
d1780 1
d1819 1
d1849 636
d2499 1
d2580 7
a2592 7
    [ {TRUE}
;;;mjsHAL - may need sorting/HAL split
;;;         for now, switched out coz kernel doesn't have VIDCControlSoftCopy any more!
;;;
   ! 0, "mjsHAL - svc_PortMan currently broken by kernel/HAL split"
        MOV     PC, LR
    |  
d2597 1
a2597 1
        LDR     R0, [WsPtr, #VIDCControlSoftCopy]       ; get saved VIDC control register
a2604 1
    ]
a2605 1

@


4.12.2.3
log
@further kernel/HAL split work in video area
almost-HAL code for VIDC20/IOMD in vdu.vduhint, now almost divorced
from kernel workspace
tested briefly in Ursula desktop environment

Version 5.35, 4.79.2.4. Tagged as 'Kernel-5_35-4_79_2_4'
@
text
@d612 4
a615 1

d726 1
a726 2
        [ {FALSE} ;;; LCDPowerCtrl :LAND: :LNOT: STB
                  ;;; mjsHAL no LCD support
d870 7
a876 11
        ; for backward compatibility, show that video DMA is enabled in
        ; MEMC soft copy (DON'T call OS_UpdateMEMC, which would also
        ; make redundant call to HAL)
        ;
        SavePSR R2
        MOV     R0, #0
        WritePSRc SVC_mode+I_bit+F_bit, R14
        LDR     R1, [R0, #MEMC_CR_SoftCopy]
        ORR     R1, R1, #(1 :SHL: 10)
        STR     R1, [R0, #MEMC_CR_SoftCopy]
        RestPSR R2
d878 1
a878 1
        BL      SetVendDefault
d894 1
a894 2
        [ {FALSE} ;;; LCDPowerCtrl :LAND: :LNOT: STB
                  ;;; mjsHAL no LCD support
@


4.12.2.4
log
@mjs macros switch on HAL for calling video code in HAL/pseudo HAL cases
vduhint code even more almost ready to move to HAL

Version 5.35, 4.79.2.6. Tagged as 'Kernel-5_35-4_79_2_6'
@
text
@d210 2
a211 4
  [ :LNOT: HAL
    ;
    ; mjsHAL - temporary workspace while semi HALised code still in kernel
    ;
d217 1
a217 2
    ;
  ]
@


4.12.2.5
log
@add some HAL_Video calls, attempt to deal with lack of h/w scroll

Version 5.35, 4.79.2.9. Tagged as 'Kernel-5_35-4_79_2_9'
@
text
@a160 18
        Push    "r4, r9, r12"
        mjsAddressHAL
        MOV     r4, r12                       ; temp WsPtr
        mjsCallHAL HAL_Video_PixelFormats
        STR     r0, [r4, #HWPixelFormats]
        mjsCallHAL HAL_Video_Features
        STR     r0, [r4, #HWVideoFeatures]
        mjsCallHAL HAL_Video_Features
        STR     r0, [r4, #HWPixelFormats]
        mjsCallHAL HAL_Video_BufferAlignment
        STR     r0, [r4, #HWBufferAlign]
        Pull    "r4, r9, r12"
      
        ;;; sort this out!
        ! 0, "mjsHAL not doing anything useful with HAL_Video_PixelFormats"
        ! 0, "mjsHAL not doing anything useful with HAL_Video_bufferAlign"
        ! 0, "mjsHAL not dealing with lack of h/w pointer"

d812 4
a815 2
        LDR     R3, [WsPtr, #HWVideoFeatures]
        TST     R3, #1                          ; bit 0 set if h/w scroll supported
a816 1
        ORREQ   R3, R3, #Flag_HardScrollDisabled
@


4.12.2.6
log
@second attempt at handling lack of h/w scroll

Version 5.35, 4.79.2.10. Tagged as 'Kernel-5_35-4_79_2_10'
@
text
@d830 2
d833 1
a1107 5
        LDR     r14, [WsPtr, #HWVideoFeatures]
        TST     r14, #1                         ; bit 0 is h/w scroll support
        LDREQ   r14, [r9, #wkModeFlags]
        ORREQ   r14, r14, #Flag_HardScrollDisabled
        STREQ   r14, [r9, #wkModeFlags]
@


4.12.2.7
log
@  Merged Kernel 5.37 changes to HAL branch.
Detail:
  It's actually in a section removed conditionally for the HAL but it
    does keep the HAL branch up to date.
@
text
@d1530 1
a1530 1
        EXIT
@


4.12.2.8
log
@Stuff. A bit of touchscreen, I expect, and probably some other bits too.
@
text
@a120 3
        MOV     $size, #0
        MOV     $bw, #100*1024*1024
        LDR     $size, [$size, #VideoSize]
d173 1
a173 1

d276 1
a276 1
        ADD     r3, r3, #260*4*4 + 3*256
d288 1
a288 1
        MOV     r4, #260
d835 1
a835 1
        Push    "R0-R3, R9, R12"                ; preserve registers ready to make HAL call later
d860 1
a860 1
        STR     R2, [WsPtr, #PixelRate]
d875 1
a875 1

d1068 1
a1068 1
; 1) Set SyncPol_Interlace (according to TVInterlace) if not already specified
d1124 1
a1124 1
        MOV     R10, #VIDCList3Size     ; its a VIDCList3, R10 is max room we have
d1518 1
a1518 1
    |
d2096 2
a2097 2
        LDR     R0, [WsPtr, #VduSprite]
        TEQ     R0, #0
@


4.12.2.9
log
@kernel now attempts to substitute video mode numbers in face of
h/w with limited bits-per-pixel support (not tested yet)
HAL_API document added - early draft only, of interest to those
writing or modifying HALs for new h/w
ARMop_API document added - early draft only, of interest only
to those modifying kernel to support new ARM cores
*** polite comments on HAL_API welcome ***

Version 5.35, 4.79.2.15. Tagged as 'Kernel-5_35-4_79_2_15'
@
text
@d171 2
d178 2
a179 1
        ! 0, "mjsHAL not doing anything useful with HAL_Video_BufferAlignment"
a609 69
; table of susbstitute mode numbers to cater for hardware that might
; not support all of 1,2,4,8 bpp (bits per pixel) modes
;
; indexed by mode number (0..49), pairs of byte values:
;   bpp    = bits per pixel of this mode number
;   promo  = promoted mode number (0..49), or &FF if none
;
; promoted number is:
;  1) same resolution at next higher bpp (up to 8), if available, or
;  2) similar resolution at 8 bpp (8 bpp should be available on most h/w)
;
ModePromoTable
;
;          bpp promo       mode no.
;
      DCB    1,    8     ;  0   
      DCB    2,    9     ;  1
      DCB    4,   10     ;  2
      DCB    1,   15     ;  3
      DCB    1,    1     ;  4
      DCB    2,    2     ;  5
      DCB    1,   13     ;  6
      DCB    4,   13     ;  7
      DCB    2,   12     ;  8
      DCB    4,   13     ;  9
      DCB    8,  &FF     ; 10
      DCB    2,   14     ; 11
      DCB    4,   15     ; 12
      DCB    8,  &FF     ; 13
      DCB    4,   15     ; 14
      DCB    8,  &FF     ; 15
      DCB    4,   24     ; 16
      DCB    4,   24     ; 17
      DCB    1,   19     ; 18
      DCB    2,   20     ; 19
      DCB    4,   21     ; 20
      DCB    8,  &FF     ; 21
      DCB    4,   36     ; 22
      DCB    1,   28     ; 23
      DCB    8,  &FF     ; 24
      DCB    1,   26     ; 25
      DCB    2,   27     ; 26
      DCB    4,   28     ; 27
      DCB    8,  &FF     ; 28
      DCB    1,   30     ; 29
      DCB    2,   31     ; 30
      DCB    4,   32     ; 31
      DCB    8,  &FF     ; 32
      DCB    1,   34     ; 33
      DCB    2,   35     ; 34
      DCB    4,   36     ; 35
      DCB    8,  &FF     ; 36
      DCB    1,   38     ; 37
      DCB    2,   39     ; 38
      DCB    4,   40     ; 39
      DCB    8,  &FF     ; 40
      DCB    1,   42     ; 41
      DCB    2,   43     ; 42
      DCB    4,   28     ; 43
      DCB    1,   45     ; 44
      DCB    2,   46     ; 45
      DCB    4,   15     ; 46
      DCB    8,  &FF     ; 47
      DCB    4,   49     ; 48
      DCB    8,  &FF     ; 49
;
      ALIGN


a636 33
        ;If its a common mode number (0..49) consider a possible mode number
        ;substitution, if hardware does not support given bits per pixel.
        ;We are vaguely assuming h/w supports at least 8 bpp, otherwise we may
        ;not be able to find a usable mode number, and later code may not handle
        ;that well. This is probably ok, 8 bpp is almost universal.
        ;
        CMP     r2, #256
        BHS     mchsub_3
        AND     r1, r2, #&7F
        CMP     r1, #50                      ; mode number
        BHS     mchsub_3
        Push    "r3, r4"
        ADR     lr, ModePromoTable           ; table of mode promotions
        LDR     r4, [WsPtr, #HWPixelFormats] ; bits 0 to 3 set for 1,2,4,8 bpp supported
mchsub_1
        MOV     r1, r1, LSL #1
        LDRB    r3, [lr, r1]                 ; bpp for this mode number (1,2,4,8)
        TST     r3, r4                       ; supported in h/w?
        ANDNE   r2, r2, #&80                 ; if yes, take mode number that passed
        ORRNE   r2, r2, r1, LSR #1
        BNE     mchsub_2
        ADD     r1, r1, #1                   ; else look for promotion
        LDRB    r1, [lr, r1]                 ; new mode number
        CMP     r1, #&FF                     ; &FF if none
        BNE     mchsub_1
        ;alright, dont panic, just try to get a VGA-like mode of any bpp, if not tried already
        CMP     r1, #28                      ; VGA 8 bpp
        MOVNE   r1, #25                      ; VGA 1 bpp
        BNE     mchsub_1
mchsub_2
        Pull    "r3, r4"        
;
mchsub_3
@


4.12.2.10
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a162 1
        STRB    R0, [WsPtr, #ExternalFramestore]
a163 1
 [ :LNOT:UseGraphicsV
a173 1
 ]
a307 1
        LDR     R14, [WsPtr, #ScreenEndAddr]
d309 1
a309 1
        RSB     R0, R0, R14
d622 1
a622 1
      DCB    1,    8     ;  0
d715 1
a715 9
 [ UseGraphicsV
        Push    "r0-r2"
        MOV     r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        TEQ     r4, #0
        MOVEQ   r4, r1
        MOVNE   r4, #2_111111
        Pull    "r0-r2"
 |
a716 2
 ]
        ADR     lr, ModePromoTable           ; table of mode promotions
d733 1
a733 1
        Pull    "r3, r4"
a772 6
 [ UseGraphicsV
        LDRB    R0, [WsPtr, #ExternalFramestore]
        TEQ     R0, #0
        BNE     %FT06                   ; can't grow an external framestore
 ]

d778 1
a778 1
06
a864 34
 [ UseGraphicsV
        Push    "r0-r4"
        MOV     r4, #GraphicsV_FramestoreAddress
        BL      CallGraphicsV
        TEQ     r4, #0
        BNE     %FT581
        MOV     r1, r1, LSR #20                 ; round size down to 1MB
        MOV     r2, r1, LSL #20
        ADD     r0, r0, #1:SHL:20               ; round addr up to 1MB
        SUB     r0, r0, #1
        MOV     r0, r0, LSR #20                 ; (because of OS_Memory 13 limits)
        MOV     r1, r0, LSL #20
        MOV     r0, #13                         ; map in permanently
        ORR     r0, r0, #1:SHL:8                ; buffered, uncached
        ORR     r0, r0, #1:SHL:16               ; doubly map
        SWI     XOS_Memory
        BVS     %FT581
        STR     r2, [WsPtr, #TotalScreenSize]
        ADD     r3, r3, r2
        STR     r3, [WsPtr, #ScreenEndAddr]
        MOV     r14, #1
        B       %FT582
581
        MOV     r0, #128+2
        SWI     XOS_ReadDynamicArea
        STRVC   r1, [WsPtr, #TotalScreenSize]
        ADDVC   r0, r0, r1
        STRVC   r0, [WsPtr, #ScreenEndAddr]
        MOV     r14, #0
582
        Pull    "r0-r4"
        STRB    r14, [WsPtr, #ExternalFramestore]
 ]

a936 1
 [ :LNOT:UseGraphicsV
a938 3
 |
        ADD     R0, R13, #wkwordsize            ; R0 -> VIDCList3
 ]
a979 4
 [ UseGraphicsV
        MOV     R4, #GraphicsV_SetMode
        BL      CallGraphicsV
 |
a983 1
 ]
d1001 1
a1001 1
        LDR     R1, [WsPtr, #ScreenEndAddr]     ; need to reload cos corrupt
a1206 8
 [ UseGraphicsV
        Push    "r0-r2,r4"
        MOV     r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        TEQ     r4, #0
        TSTEQ   r0, #1                          ; bit 0 is h/w scroll support
        Pull    "r0-r2,r4"
 |
a1208 1
 ]
@


4.12.2.11
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d315 1
a315 1
        BL	SetDisplayScreenStart
d899 1
a899 1
        ORR     r0, r0, #1:SHL:16+1:SHL:17      ; doubly map, access permission specified
@


4.12.2.12
log
@Added 256-colour version of the (high-resolution only) teletext code,
and support for teletext when hardware scroll is disabled. Both are required
for Tungsten.
Turned off the module init/final service calls, since we still don't have an
allocation for them.
Upped the OS version number to 5.01.

Version 5.35, 4.79.2.53. Tagged as 'Kernel-5_35-4_79_2_53'
@
text
@a632 3
    [ TTX256
      DCB    8,  &FF     ;  7
    |
a633 1
    ]
a749 1
; BKPT &600D
@


4.12.2.13
log
@* HAL can choose to limit amount of screen memory to allocate
  [Not fully implemented - for now leaves at least 16MB free if only
  one RAM area; was 1MB].
* Added HAL_USBControllerInfo, HAL_MonitorLeadID and HAL_Video_Render.
* Added HAL->OS call OS_IICOpV.
* OS_MMUControl now allows independent control of I and C bits.
* Added facility to deactivate keyboard debounce (magic word "NoKd" in
  R2 in KeyV 0).
* Fixed problem with RAM amounts not a multiple of 4MB.
* Supremacy bit (in VDU 19) now sets all 8 bits of supremacy.
* Added PaletteV 14 (reads gamma tables).
* Added Supremacy transfer functions (like gamma correction, but for
  supremacy). Allows easy global supremacy effects in a mode-independent
  fashion. Controlled with PaletteV 15,16.
* Added modes 50-53 (320x240, 1,2,4,8bpp). Intended for small LCD.
* Added 13.5kHz versions of TV modes (selected by Hdr:Machine).
* Upped desktop version to 5.06.

Version 5.35, 4.79.2.66. Tagged as 'Kernel-5_35-4_79_2_66'
@
text
@d26 1
a26 1
NewStyleEcfs   SETL  {TRUE}
d165 1
a168 3
        mjsCallHAL HAL_Video_Features
        STR     r0, [r4, #HALVideoFeatures]
 [ :LNOT:UseGraphicsV
d171 2
d175 1
a176 1
        Pull    "r4, r9, r12"
d278 2
a279 1
        LDR     r3, =Pal_Blocksize
a281 1
        ASSERT  :INDEX:Pal_Blank = 0
d283 1
a283 1
        ADD     r3, r2, #Pal_LogFirst
d285 1
a285 1
        ADD     r3, r2, #Pal_LogSecond
d291 1
a291 1
        MOV     r4, #PalEntries
d296 1
a296 1
        ADD     r2, r2, #Pal_RTable-(Pal_Blank+4*PalEntries) ; r2 -> rgb tables
d302 3
a304 4
        STRB    r0, [r2, #Pal_STable-Pal_RTable] ; store in supremacy table
        STRB    r0, [r2, #Pal_BTable-Pal_RTable] ; store in blue table
        STRB    r0, [r2, #Pal_GTable-Pal_RTable] ; store in green table
        STRB    r0, [r2], #1                     ; store in red table, and advance
a679 6
      DCB    1,   51     ; 50
      DCB    2,   52     ; 51
      DCB    4,   53     ; 52
      DCB    8,  &FF     ; 53

      ASSERT (.-ModePromoTable)=(NumModes*2)
d720 1
a720 1
        CMP     r1, #NumModes                ; mode number
d754 1
d1283 1
a1283 1
        LDR     r14, [WsPtr, #HALVideoFeatures]
@


4.12.2.14
log
@  Added four new VDU variables.
Detail:
  174: left border size
  175: bottom border size
  176: right border size
  177: top border size
Admin:
  Not tested.

Version 5.35, 4.79.2.68. Tagged as 'Kernel-5_35-4_79_2_68'
@
text
@d1028 1
a1028 1
;remember pixel rate (kHz) and border settings from VIDCList3
a1031 8
        LDR     R2, [R0, #VIDCList3_HorizLeftBorder]
        STR     R2, [WsPtr, #BorderL]
        LDR     R2, [R0, #VIDCList3_VertiBottomBorder]
        STR     R2, [WsPtr, #BorderB]
        LDR     R2, [R0, #VIDCList3_HorizRightBorder]
        STR     R2, [WsPtr, #BorderR]
        LDR     R2, [R0, #VIDCList3_VertiTopBorder]
        STR     R2, [WsPtr, #BorderT]
@


4.12.2.15
log
@     several mode:
     1: default ticker based vsync generated whenever no device present to do so
     2: graphicsv handling and spec updated to use the hi 8 bits in the
        reason code (R4) to define the display number. Kernel only knows
        of display 0
Detail:
Admin:
     tested castle  castle added ip


Version 5.35, 4.79.2.81. Tagged as 'Kernel-5_35-4_79_2_81'
@
text
@d1293 2
a1294 14
  ; claim or release falsevsync vector if vsyncs supported/not supported
        Push    "r0"
        TST     r0, #1<<4                       ; NE = VSyncs not generated?
        MOV     a1, #TickerV
        LDR     a2, =FalseVsyncIRQ
        LDR     a3, =OsbyteVars
        BEQ     %ft2
        SWI     XOS_Claim
        B       %ft1
2       SWI     XOS_Release
1
        Pull    "r0"
             
        TST     r0, #1                          ; bit 0 is h/w scroll support
@


4.12.2.16
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@a42 1
      [ ZeroPage = 0
a43 4
      |
        LDR     R0, =ZeroPage
        LDR     R0, [R0]
      ]
a57 1
      [ ZeroPage = 0
a58 4
      |
        LDR     R0, =ZeroPage
        LDR     R0, [R0]
      ]
d121 1
a121 1
        LDR     $size, =ZeroPage
d152 1
a152 2
        LDR     R0, =ZeroPage
        ASSERT (ZeroPage :AND: 255) = 0
a154 3
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
d343 1
a343 1
        LDREQ   r0, =ZeroPage+VduDriverWorkSpace+ModeNo
d375 1
a375 1
        LDR     R11, =ZeroPage          ; NB used later in Vdu07 as well
d408 1
a408 2
        ADD     SP,SP,#4
        Pull    PC
a473 3
 [ No26bitCode
        ADR     R14, VduPrintExit
 |
a476 1
 ]
d481 1
a481 2
        ADD     SP, SP, #4
        Pull    PC
a535 3
 [ No26bitCode
        ADR     R14, VduPrintExit
 |
a538 1
 ]
d543 1
a543 2
        ADD     SP, SP, #4
        Pull    PC
a711 1
        LDR     R0, [R13], #8           ; get error pointer, junk next entry
d713 1
a713 1
        Pull    PC
a805 2
        ! 0, "Need to fix ModeChangeSub to not leave CursorAddr, etc. pointing to unmapped pages during DA resize. Causes bad stuff should an abort occur/screen output be attempted!" ; Note that even enlarging the DA can leave the pointers in a bad state, due to the way the screen DA handler shuffles down/unmaps the lower mapping of VRAM before the higher copy is enlarged

d943 1
a943 2
        LDR     R6, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
d1074 1
a1074 1
        LDR     R0, =ZeroPage
d1298 1
a1298 1
        LDR     a3, =ZeroPage+OsbyteVars
a2475 2
        LTORG

@


4.12.2.17
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d330 1
a330 1
        BL      SetDisplayScreenStart
@


4.12.2.18
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@a182 3
        ; Set bit 31 of features if HAL_Video_Render supported
        CheckHAL HAL_Video_Render, r1
        ORREQ   r0, r0, #1:SHL:31
@


4.12.2.19
log
@Make Mike's macros permanent.
While the HAL and kernel were being split some temporary macros were used for the bits being worked on, after 12 years of use they're probably safe to adopt.
mjsCallHAL -> CallHAL; mjsAddressHAL -> AddressHAL; mjsHAL -> HAL.
OS_VIDCDividerSWI code now always does NoSuchSWI (had been switched out previously).
File vduhint.s no longer assembled (was empty).


Version 5.35, 4.79.2.150. Tagged as 'Kernel-5_35-4_79_2_150'
@
text
@d180 1
a180 1
        AddressHAL
d182 1
a182 1
        CallHAL HAL_Video_Features
d188 1
a188 1
        CallHAL HAL_Video_PixelFormats
d190 1
a190 1
        CallHAL HAL_Video_BufferAlignment
d196 2
a197 2
        ! 0, "HAL not doing anything useful with HAL_Video_BufferAlignment"
        ! 0, "HAL not dealing with lack of h/w pointer"
d248 12
d909 1
a909 1
                  ;;; HAL no LCD support
d1093 2
a1094 2
        AddressHAL
        CallHAL HAL_Video_SetMode
d1130 1
a1130 1
                  ;;; HAL no LCD support
d1750 4
a1753 1
        ! 0, "HAL - svc_PortMan broken by kernel/HAL split due to lack of VIDCControlSoftCopy"
@


4.12.2.20
log
@Make GraphicsV_IICOp more consistent
No accepts  r0 = b31-24 set 0
                 b23-16 fully qualified IIC address
                 b15-0  starting offset
            r1 = buffer pointer
            r2 = number of bytes to tranfer
            r4 = b31-24 display number
                 b23-16 head
                 b15-0  reason code (=14)
Now returns r0 = result codes as per HAL_IICTransfer()
            r1 = buffer pointer incremented by number of bytes transferred
            r2 = number of bytes *not* transferred
            r4 = 0
Removed '_' after Video in entry numbers to be consistent with other HAL entry naming, and HAL_VideoFlybackDevice.
Added IICStatus return numbers to Hdr:HALEntries.
Stop calling HAL_MonitorLeadID as only IOMD implemented it - just guess VGA until the graphics driver says otherwise.

Version 5.35, 4.79.2.159. Tagged as 'Kernel-5_35-4_79_2_159'
@
text
@d182 3
a184 3
        CallHAL HAL_VideoFeatures
        ; Set bit 31 of features if HAL_VideoRender supported
        CheckHAL HAL_VideoRender, r1
d188 1
a188 1
        CallHAL HAL_VideoPixelFormats
d190 1
a190 1
        CallHAL HAL_VideoBufferAlignment
d196 1
a196 1
        ! 0, "HAL not doing anything useful with HAL_VideoBufferAlignment"
d1082 1
a1082 1
        CallHAL HAL_VideoSetMode
@


4.12.2.21
log
@Merge with RPi branch
Detail:
  Merge the RPi branch with the HAL branch, ending RPi branch development
  Brief summary of changes brought in:
  * Added HAL_VideoStartupMode to allow the HAL to specify a startup mode for the OS
  * Fixed addresses being sent to GraphicsV_SetDMAAddress being wrong for external framestores (addresses were given as if internal framestore was in use)
  * Add InverseTextTransparency option for limited compile-time support for targets where framebuffer alpha channel is important
  * Fix ConfiguredLanguage for non-Tungsten builds
  * Update ARMv6 CPU detection to read cache parameters from cache type register instead of using KnownCPUTable
  * Add HALDebugHexTX/TX2/TX4 debug routines for writing out numbers via HAL
  * Use HAL_TimerIRQClear when clearing timer 0 interrupt instead of just HAL_IRQClear
  * Initialise FileLangCMOS using defines from Hdr:FSNumbers instead of magic numbers. Use SDFS on M_ARM11ZF.
  * Improved software mouse pointer support; software pointer now removed & restored in some of the same places the text cursor is
  * Improve support for external framestores; driver is now able to grow/shrink/move the framestore on mode changes if bit 5 of GraphicsV_DisplayFeatures R0 is set
  * GraphicsV_FramestoreAddress now has a default claimant which calls HAL_VideoFramestoreAddress
Admin:
  Tested on Raspberry Pi, Iyonix, OMAP3, IOMD


Version 5.35, 4.79.2.165. Tagged as 'Kernel-5_35-4_79_2_165'
@
text
@a162 1
        LDR     R14, [R0, #VideoPhysAddr]
a177 1
        STR     R14, [WsPtr, #TrueVideoPhysAddr]  ; init TrueVideoPhysAddr for internal RAM/VRAM framestore case 
d333 1
a333 1
;                         
a355 6
; at this stage, r0 = current screen mode either mode number or mode specifier
; lets give the HAL a chance to be fussy.
        AddressHAL
        CallHAL    HAL_VideoStartupMode

01
a356 1

a368 1
;
d782 1
d818 1
a818 12
        BEQ     %FT05

; External framestore in use; does driver support growing/reallocating it?

        Push    "r1-r2,r4"
        MOV     r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        Pull    "r1-r2,r4"
        TST     r0, #1<<5
        BNE     %FT08                   ; realloc supported, assume driver can allocate required memory since it OK'd the mode
        B       %FT06                   ; not supported, complain
05
d916 1
a916 10
        Push    "r0-r6"
        MOV     r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV

; If driver handles memory allocation, must change mode before asking for memory

        TST     r0, #1<<5
        ADDNE   R0, R13, #wkwordsize+7*4        ; R0 -> VIDCList3
        BLNE    HardwareModeChange
        
a920 27

 [ {TRUE}
; for mapping in, round start address down and size up to megabyte boundaries
; r0 = physical start, r1= size
; so frame buffer is wholly contained within the mapped in area
        MOV     r3, #1<<20                      ; 1 Megabyte
        SUB     r3, r3, #1                      ; convert to mask
        MOV     r4, r1                          ; remember what was asked for
        AND     r5, r0, r3                      ; and offset from megabyte base
        TST     r1, r3                          ; non integer megabyte?
        BIC     r2, r1, r3                      ; (clear the bits)
        ADDNE   r2, r2, #1<<20                  ; yes.. up to next megabyte
        BIC     r1, r0, r3                      ; ensure megabyte boundary at start
        MOV     r0, #13                         ; map in permanently
        ORR     r0, r0, #1:SHL:8                ; buffered, uncached
        ORR     r0, r0, #1:SHL:16+1:SHL:17      ; doubly map, access permission specified
        SWI     XOS_Memory
        BVS     %FT581
        ADD     r0, r1, r5                      ; reconstruct base phys address
        STR     r0, [WsPtr, #TrueVideoPhysAddr] ; and update our copy
        STR     r4, [WsPtr, #TotalScreenSize]   ; what we asked for
        ADD     r3, r3, r4                      ; compute end
        ADD     r3, r3, r5                      ; and allow offset dfrom start
        STR     r3, [WsPtr, #ScreenEndAddr]     ; actual screen end
        MOV     r14, #1
        B       %FT582
  |
a931 2
        ADD     r0, r1, r5                      ; reconstruct base phys address
        STR     r0, [WsPtr, #TrueVideoPhysAddr] ; and update our copy
a936 2

 ]
d945 1
a945 1
        Pull    "r0-r6"
d1022 6
a1027 67
; tell hardware to change mode, unless already done
        MOV     r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        TST     r0, #1<<5
        ADDEQ   R0, R13, #wkwordsize            ; R0 -> VIDCList3
        BLEQ    HardwareModeChange

        ADD     R13, R13, #PushedInfoSize       ; junk stacked data

        ; for backward compatibility, show that video DMA is enabled in
        ; MEMC soft copy (DON'T call OS_UpdateMEMC, which would also
        ; make redundant call to HAL)
        ;
        SavePSR R2
        LDR     R0, =ZeroPage
        WritePSRc SVC_mode+I_bit+F_bit, R14
        LDR     R1, [R0, #MEMC_CR_SoftCopy]
        ORR     R1, R1, #(1 :SHL: 10)
        STR     R1, [R0, #MEMC_CR_SoftCopy]
        RestPSR R2

        BL      SetVendDefault

        LDR     R1, [WsPtr, #ScreenEndAddr]     ; need to reload cos corrupt
        LDR     R2, [WsPtr, #TotalScreenSize]
        SUB     R0, R1, R2                      ; R0 = Vstart
        BL      SetVstart
        MOV     R0, #0
        STRB    R0, [WsPtr, #PointerShapeNumber]
        STR     R0, [WsPtr, #TeletextOffset]
        STR     R0, [WsPtr, #CursorStack]       ; restore cursor on a mode

        BL      PalInit                 ; set default palette
        BL      UnblankScreen
        BL      SetMouseRectangle
        BL      FF

        [ {FALSE} ;;; LCDPowerCtrl :LAND: :LNOT: STB
                  ;;; mjsHAL no LCD support
        ;Switch the LCD on if LCD mode
        Push    "r0"
        MOV     R1, #0
        LDRB    R1, [R1, #LCD_Active]
        ANDS    R1, R1, #&7F            ;Check the LCD mode bits only, not the single/dual panel bit
        LDRNE   R0, =(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        LDRNE   R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        SWINE   XPortable_Control
        Pull    "r0"
        ]

        MOV     R1, #Service_ModeChange
        BL      IssueModeService

        CLRV                            ; indicate no error
        Pull    PC                      ; return to caller

; *****************************************************************************
;
;       HardwareModeChange - Tell the video driver to change the mode
;
; in:   R0 = VIDC list
;
; out:  All regs preserved
;

HardwareModeChange
        Push    "R0-R4, LR"
d1077 1
d1080 3
d1084 2
a1085 1
        Pull    "R0-R4, PC"
d1087 48
d1281 1
@


4.12.2.22
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d1669 1
a1669 1
  |
a1670 1
  ]
@


4.12.2.23
log
@Teach the kernel about different memory attributes
Detail:
  Briefly, this set of changes:
  * Adjusts PhysRamTable so that it retains the flags passed in by the HAL from OS_AddRAM (by storing them in the lower 12 bits of the size field)
  * Sorts the non-VRAM entries of PhysRamTable by speed and DMA capability, to ensure optimal memory allocation during OS startup.
  * Adjust the initial memory allocation logic to allow the cursor/sound chunk and HAL noncacheable workspace to come from DMA capable memory
  * Extends OS_Memory 12 to accept a 'must be DMA capable' flag in bit 8 of R0. This is the same as available in ROL's OS.
  * Extends OS_DynamicArea 0 to allow the creation of dynamic areas that automatically allocate from DMA capable memory. In ROL's OS this was done by setting bit 12 of R4, but we're using bits 12-14 for specifying the cache policy, so instead bit 15 is used.
  * Fixes OS_ReadSysInfo 6 to return the correct DevicesEnd value now that the IRQ/device limit is computed at runtime
  File changes:
  * hdr/OSEntries - Add definitions of the various flags passed to OS_AddRAM by the HAL. Add a new flag, NoDMA, for memory which can't be used for DMA.
  * hdr/KernelWS - Tidy PhysRamTable definition a bit by removing all the DRAM bank definitions except the first - this makes it easier to search for code which is interacting with the table. Remove VRAMFlags, it's redundant now that the flags are kept in the table. Add DMA allocation info to InitWs.
  * s/AMBControl/memmap - Updated to mask out the flags from PhysRamTable when reading RAM block sizes.
  * s/ARM600 - Strip out a lot of IOMD specific pre-HAL code.
  * s/ChangeDyn - Updated to cope with the flags stored in PhysRamTable. Implement support for DMA-capable dynamic areas. Rewrite InitDynamicAreas to insert pages into the free pool in the right order so that the fastest memory will be taken from it first.
  * s/GetAll, s/Middle - Fix OS_ReadSysInfo 6 to return the correct HAL-specific DevicesEnd value
  * s/HAL - Significant rework of initial RAM allocation code to allow the kernel workspace to come from the fastest DMA incapable RAM, while also allowing allocation of DMA capable memory for HAL NCNB workspace & kernel cursor/sound chunks. ClearPhysRAM rewritten as part of this.
  * s/MemInfo - Updated to cope with the flags stored in PhysRamTable. Add support for the new OS_Memory 12 flag. Update OS_Memory 7 to not assume PhysRamTable entries are sorted in address order, and rip out the old pre-HAL IOMD implementation.
  * s/NewReset - Remove GetPagesFromFreePool option, assume TRUE (as this has been the case for the past 10+ years). Revise a few comments and strip dead code. Update to cope with PhysRamTable flags.
  * s/VMSAv6 - Remove a couple of unused definitions
  * s/vdu/vdudriver - Update to cope with PhysRamTable flags
Admin:
  Tested in Kinetic RiscPC ROM softload, Iyonix softload, & OMAP3


Version 5.35, 4.79.2.186. Tagged as 'Kernel-5_35-4_79_2_186'
@
text
@a131 1
        LDR     $size, [$size, #VideoSizeFlags]
d133 1
a133 2
        MOV     $size, $size, LSR #12
        MOV     $size, $size, LSL #12
@


4.12.2.24
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d1046 1
a1046 1
        TST     R6, #ModeFlag_Teletext
d1158 1
a1158 1
        TST     R2, #ModeFlag_GapMode    ; gap mode ?
d1160 1
a1160 1
        TST     R2, #ModeFlag_DoubleVertical ; if double vertical
d1375 1
a1375 1
        ORR     r14, r14, #ModeFlag_InterlacedMode
d1402 1
a1402 1
        ORREQ   r14, r14, #ModeFlag_HardScrollDisabled
d1418 1
a1418 8
        ASSERT  VIDCList3BaseSize = 64
        LDMIA   R3!, {R2,R4,R7-R11}     ; 28 bytes
        STMIA   R14!, {R2,R4,R7-R11}
        LDMIA   R3!, {R2,R4,R7-R11}     ; 56 bytes
        STMIA   R14!, {R2,R4,R7-R11}
        LDMIA   R3!, {R2,R4}            ; 64 bytes
        STMIA   R14!, {R2,R4}
        MOV     R10, #VIDCList3Size-(VIDCList3BaseSize+4) ; this much space left for control list items (excluding terminator)
d1420 4
a1423 3
        LDR     R8, [R3], #4
        SUBS    R10, R10, #8
        MOVLT   R8, #-1                 ; emergency terminate (source list too long)
a1424 2
        LDRNE   R9, [R3], #4
        STMNEIA R14!, {R8-R9}
a1425 1
        STR     R8, [R14]
d1472 1
a1472 1
        BNE     %FT10                           ; [yes, so skip]
d1549 1
a1549 1
10
d1554 20
a1573 9
        AND     r0, r2, #15<<27                 ; get type
        CMP     r0, #SpriteType_RISCOS5<<27     ; RISC OS 5 type?
        BEQ     %FT50

        CMP     r0, #SpriteType_New64K<<27      ; 64K colour sprite?
        MOVEQ   r0, #ModeFlag_64k
        STREQ   r0, [r9, #wkModeFlags]          ; Make a note of it
        MOVEQ   r0, #SpriteType_New16bpp        ; ... and treat as regular 16bpp
        MOVNE   r0, r0, LSR #27
a1574 2
15
      [ NoARMT2
a1576 3
      |
        UBFX    r1, r2, #1, #13                 ; extract xdpi (bits 1..13)
      ]
d1580 1
a1580 1
        BEQ     %FT20
d1585 1
a1585 1
        BEQ     %FT20
d1589 1
a1589 1
        BNE     %FT85
d1592 1
a1592 1
20
a1594 1
      [ NoARMT2
a1596 3
      |
        UBFX    r1, r2, #14, #13                ; extract ydpi (bits 14..26)
      ]
d1600 1
a1600 1
        BEQ     %FT21
d1605 1
a1605 1
        BEQ     %FT21
d1609 1
a1609 1
        BNE     %FT85
d1612 1
a1612 1
21
a1614 23

25
        CMP     r0, #SpriteType_MAX             ; check for legality - NB type 0 is impossible here because r2>=&100
        MOVCS   r0, #SpriteType_Substitute      ; substitute if unknown
        ADRL    lr, NSM_bpptable-4
        LDR     r0, [lr, r0, LSL #2]            ; get the bpp from table

        ADR     r1, NColourTable
        LDR     r1, [r1, r0, LSL #2]
        STR     r1, [r9, #wkNColour]

30
        STR     r0, [r9, #wkLog2BPC]
        STR     r0, [r9, #wkLog2BPP]

        ADR     r1, PalIndexTable
        LDRB    r1, [r1, r0]
        STR     r1, [r9, #wkPalIndex]

        ADR     r1, ECFIndexTable
        LDRB    r1, [r1, r0]
        STR     r1, [r9, #wkECFIndex]

d1618 1
a1618 53
50
        TST     r2, #&F0000                     ; validate RO 5 sprite mode word
        TSTEQ   r2, #&0000E
        MOVNE   r0, #SpriteType_Substitute      ; and try substitute if bad
        BNE     %BT15

      [ NoARMT2
        MOV     r1, r2, LSR #4
        AND     r1, r1, #3                      ; extract XEigFactor (bits 4..5)
      |
        UBFX    r1, r2, #4, #2                  ; extract XEigFactor (bits 4..5)
      ]
        STR     r1, [r9, #wkXEigFactor]

      [ NoARMT2
        MOV     r1, r2, LSR #6
        AND     r1, r1, #3                      ; extract YEigFactor (bits 6..7)
      |
        UBFX    r1, r2, #6, #2                  ; extract YEigFactor (bits 6..7)
      ]
        STR     r1, [r9, #wkYEigFactor]

        AND     r1, r2, #&FF00                  ; extract ModeFlags
        ; Validate ModeFlags. We only support RGB colourspace, so the only valid
        ; bits are the RGB and alpha flags
        TST     r1, #&FF00-(ModeFlag_DataFormatSub_RGB+ModeFlag_DataFormatSub_Alpha)
        MOVNE   r0, #SpriteType_Substitute      ; try the substitute?
        BNE     %BT15

        MOV     r0, r2, LSR #20
        ANDS    r0, r0, #127                    ; extract type
        MOVEQ   r0, #SpriteType_Substitute      ; type 0 isn't valid!

        CMP     r0, #SpriteType_New64K
        ORREQ   r1, r1, #ModeFlag_64k
        MOVEQ   r0, #SpriteType_New16bpp

        CMP     r0, #SpriteType_New16bpp        ; for palettised modes
        CMPLT   r0, r1                          ; flags must be zero
        MOVLT   r0, #SpriteType_Substitute
        BLT     %BT15

        STR     r1, [r9, #wkModeFlags]

        CMP     r0, #SpriteType_New4K
        BNE     %BT25

        LDR     r0, =4095
        STR     r0, [r9, #wkNColour]
        MOV     r0, #4
        B       %BT30

85
a1630 8
                &       NColour_5 ; CMYK sprite (not supported)
                &       NColour_5 ; 24bpp sprite (not supported)
                &       NColour_5 ; JPEG sprite (not supported)
                &       NColour_4 ; 64K sprite
                &       NColour_5, NColour_5, NColour_5, NColour_5, NColour_5 ; sprite types 11-15
                &       4095 ; 4K sprite
                &       NColour_5, NColour_5 ; YCbCr 422 & 420 (not supported)
                ASSERT  . - NColourTable = (SpriteType_RO5MAX-1)*4
@


4.12.2.25
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@a180 9
        STR     R0, [WsPtr, #GraphicsVFeatures]
        MOV     R3, #MaxGraphicsVDrivers
        LDR     R2, =ZeroPage+VduDriverWorkSpace+GraphicsVDrivers
01
        STR     R0, [R2], #4
        SUBS    R3, R3, #1
        BNE     %BT01        
        MOV     R0, #GraphicsVInvalid
        STR     R0, [WsPtr, #CurrentGraphicsVDriver]
d183 20
d342 1
a342 2
; out:  r0 = corrupt, or error pointer
;       All other registers preserved
d345 1
a345 17
InitialiseMode ROUT
; if we don't have a video driver yet, now is a good time to check if the HAL
; provides one
        LDR     r0, =ZeroPage+VduDriverWorkSpace+CurrentGraphicsVDriver
        LDR     r0, [r0]
        CMP     r0, #GraphicsVInvalid
        BEQ     VduGrafHAL_Init         ; tail-call since InitialiseMode will get called again when the HAL registers itself
        
        Entry   "r1-r12"

        ; Refresh cached features flags before we start calling this new driver        
        MOV     r4, r0, LSL #24
        ORR     R4, R4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        VDWS    WsPtr
        STR     r0, [WsPtr, #GraphicsVFeatures]

d361 3
a363 5
; lets give the driver a chance to be fussy.
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        ORR     R4, R4, #GraphicsV_StartupMode
        BL      CallGraphicsV
        
d365 1
d758 4
a761 4
        Push    "r0-r4"
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_DisplayFeatures
a763 1
        MOVEQ   r0, #0
a765 1
        STR     r0, [WsPtr, #GraphicsVFeatures] ; refresh cached features
d767 3
d826 1
d833 5
a837 2
        LDR     R0, [WsPtr, #GraphicsVFeatures]
        TST     r0, #GVDisplayFeature_VariableFramestore
d841 1
d937 1
d939 2
d944 1
a944 2
        LDR     r0, [WsPtr, #GraphicsVFeatures]
        TST     r0, #GVDisplayFeature_VariableFramestore
d948 1
a948 3
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_FramestoreAddress
d953 1
d978 21
d1009 1
d1085 3
a1087 2
        LDR     r0, [WsPtr, #GraphicsVFeatures]
        TST     r0, #GVDisplayFeature_VariableFramestore
d1200 1
a1200 3
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_SetMode
a1202 6
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        STR     R0, [WsPtr, #GraphicsVFeatures] ; refresh cached features just in case something's happened to change them

d1378 4
a1381 6
        Push    "r0-r2"
        LDR     r0, [WsPtr, #GraphicsVFeatures]
        TST     r0, #GVDisplayFeature_HardwareScroll
        LDREQ   r14, [r9, #wkModeFlags]
        ORREQ   r14, r14, #ModeFlag_HardScrollDisabled
        STREQ   r14, [r9, #wkModeFlags]
d1383 5
a1387 4
        TST     r0, #GVDisplayFeature_NoVsyncIRQ ; are VSyncs not generated?
        MOV     r0, #TickerV
        LDR     r1, =FalseVsyncIRQ
        LDR     r2, =ZeroPage+OsbyteVars
d1393 1
d1395 9
a1403 1
        Pull    "r0-r2"
d1721 1
a1721 1
PalIndexTable   =       0, 1, 2, 3, 7, 7        ; TODO get rid of palette 6 if VIDC mangling is gone for good
@


4.12.2.26
log
@Miscellaneous fixes
Detail:
  s/MemInfo - Fix OS_Memory 0 physical-to-logical conversion returning bad addresses for most cases due to R5 being modified by physical_to_ppn (bug introduced in revision 4.4.2.20)
  s/vdu/vdudriver - Fix some VDU driver variables not being initialised correctly when switching GraphicsV driver
  s/vdu/vdugrafv - Fix handling of VSync events from GraphicsV drivers other than driver zero
  s/vdu/vduswis - Fix abort when OS_ScreenMode 11 is passed a bad driver number
Admin:
  Tested on Raspberry Pi
  There still seems to be a bug lurking somewhere when switching to a GraphicsV driver that uses DA2; the system will crash horribly unless DA2 is already a suitable size for the initial mode change


Version 5.35, 4.79.2.206. Tagged as 'Kernel-5_35-4_79_2_206'
@
text
@a351 31
        ; Update screen memory information
        ASSERT  GVDisplayFeature_SeparateFramestore < 256
        ANDS    r1, r0, #GVDisplayFeature_SeparateFramestore
        STRB    r1, [WsPtr, #ExternalFramestore]
        BNE     %FT20
        ; Screen DA is in use
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #VideoPhysAddr]
        STR     r0, [WsPtr, #TrueVideoPhysAddr] ; Point TrueVideoPhysAddr at the base of screen DA
        MOV     r0, #2
        SWI     XOS_ReadDynamicArea
        MOVVS   r1, #0                  ; shouldn't happen, but set a safe size just in case
        STR     r1, [WsPtr, #TotalScreenSize] ; Ensure TotalScreenSize consistent with DA size
        B       %FT30
20
        ; Driver manages memory itself
        TST     r0, #GVDisplayFeature_VariableFramestore
        BNE     %FT30                   ; Framestore changes with mode, we can't read its info here
        ; Framestore is fixed, get its info and remember it (ModeChangeSub currently relies on this for VRAM limit checking)
        LDR     r0, =ZeroPage+VduDriverWorkSpace+CurrentGraphicsVDriver
        LDR     r0, [r0]
        MOV     r4, r0, LSL #24
        ORR     r4, r4, #GraphicsV_FramestoreAddress
        BL      CallGraphicsV
        CMP     r4, #0
        MOVNE   r1, #0                  ; If call wasn't claimed, claim 0 screen memory. Mode change will then fail with out of memory error, which is about the best we can do.
        STR     r0, [WsPtr, #TrueVideoPhysAddr]
        STR     r1, [WsPtr, #TotalScreenSize]

30

@


4.12.2.27
log
@Fix dodgy mode changes on Raspberry Pi. Fix crash when switching to a driver which uses DA 2 if DA 2 isn't already large enough.
Detail:
  s/vdu/vdudriver:
  - Fix bug in ModeChangeSub which caused the VariableFramestore flag to be ignored, resulting in unreliable mode changes on the Raspberry Pi.
  - Changed InitialiseMode to reset a few more variables when preparing to use a driver which uses DA 2. Without this the screen DA handler will likely crash when attempting to resize the DA for the initial mode change.
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.207. Tagged as 'Kernel-5_35-4_79_2_207'
@
text
@a364 6
        ; Reinitialise a few more variables which are used by the screen DA handler
        ADD     r1, r0, r1
        STR     r1, [WsPtr, #ScreenEndAddr]
        STR     r0, [WsPtr, #DisplayStart]
        BL      SetDisplayScreenStart
        STR     r0, [WsPtr, #ScreenStart]
d802 1
a802 1
        MOVNE   r0, #0
@


4.12.2.28
log
@Fix OS_SpriteOp 41 (read pixel) for 4K colour sprites. Update ECF patterns to work sensibly in true colour modes.
Detail:
  s/vdu/vdugrafg - Change SetupSprModeData to calculate SprReadNColour from log2bpp instead of the NColour mode variable - fixes the alpha component being lost when using OS_SpriteOp 41 to read from 4K colour sprites with alpha channels
  s/vdu/vdudriver - Change SetCol30 to generate more sensible ECF colour blocks when in true colour modes. Previously it would treat each byte of the 8 byte ECF pattern as a separate row, and replicate the byte 4 times to produce one colour word per row. However this isn't so great for true colour modes, especially if you have an alpha channel which needs specific values. So to fix the issue, take inspiration from how Paint assumed the ECF patterns worked, and treat 16bpp modes as being a 1x4 pattern and 32bpp modes as being a 1x2 pattern
Admin:
  Tested on BB-xM
  OS_SpriteOp 41 fix fixes Paint colour picker always returning 0 alpha when picking from 4K ARGB sprites
  ECF change fixes Paint's masked sprite background ECF pattern to display properly in true colour modes


Version 5.35, 4.79.2.213. Tagged as 'Kernel-5_35-4_79_2_213'
@
text
@d2181 1
a2181 4
        LDR     R4, [WsPtr, #BitsPerPix]
        CMP     R4, #16
        BHI     SetCol45
        BEQ     SetCol40
d2183 1
a2183 1
        TEQ     R4, R5                  ; if BitsPerPix <> 'fudged' BitsPerPix
d2190 1
a2190 1
SetCol36
d2192 1
a2192 1
SetCol37
d2196 1
a2196 1
        BNE     SetCol37
d2199 1
a2199 35
        BNE     SetCol36
        MOV     PC, R14

; Generate 1x4 pattern for 16bpp
;
; R0 points to Ecf(n)
; R2 points to destination
;
; Uses R0,R2,R5,R6,R7
;
SetCol40
        LDMIA   R0, {R0,R6}             ; Grab full pattern block
        EOR     R5, R0, R0, ROR #16     ; &22221111 ^ &11112222
        EOR     R7, R6, R6, ROR #16
        EOR     R0, R0, R5, LSL #16     ; = &11111111
        EOR     R6, R6, R7, LSL #16
        EOR     R5, R5, R0              ; = &22222222
        EOR     R7, R7, R6
        STMIA   R2!,{R0,R5,R6,R7}       ; Store 4 rows
        STMIA   R2!,{R0,R5,R6,R7}       ; 8 rows
        MOV     PC, R14

; Generate 1x2 pattern for 32bpp
;
; R0 points to Ecf(n)
; R2 points to destination
;
; Uses R0,R2,R5,R6,R7
;
SetCol45
        LDMIA   R0, {R0,R5}
        MOV     R6,R0
        MOV     R7,R5
        STMIA   R2!,{R0,R5,R6,R7}
        STMIA   R2!,{R0,R5,R6,R7}
@


4.12.2.29
log
@Improve Service_DisplayStatus, Service_DisplayChanged functionality
Detail:
  hdr/VduExt - Define new Service_DisplayChanged reason code for us to issue before anything actually happens. Define new Service_DisplayStatus reason codes for drivers to issue when they change their configuration/capabilities in some way.
  s/Utility - Listen out for Service_DisplayStatus
  s/vdu/vdudriver - When DisplayStatus_Changing/DisplayStatus_Changed is received for the current driver, translate into the appropriate DisplayChanged reason codes so that software which only cares about the current driver doesn't have two sets of service calls to listen out for
  s/vdu/vduswis - When switching driver in OS_ScreenMode 11, issue the new Service_DisplayChanged PreChanging reason code before we update the current GraphicsV driver VDU variable
Admin:
  Tested in Iyonix ROM softload


Version 5.35, 4.79.2.216. Tagged as 'Kernel-5_35-4_79_2_216'
@
text
@a2703 67
; *****************************************************************************
;
;       HandleServiceDisplayStatus
;
;       Called from kernel service call handler
;
; in:   R0 = sub-reason
;       R1 = Service_DisplayStatus
;       R2 = GraphicsV driver number
;       LR = return address
;
; out:  R12 corrupt
;
HandleServiceDisplayStatus ROUT
        ; We're only interested in DisplayStatus_Changing/DisplayStatus_Changed
        TEQ     r0, #DisplayStatus_Changing
        TEQNE   r0, #DisplayStatus_Changed
        MOVNE   pc, lr
        Entry   "r0-r4"

        ; We're only interested in the current driver
        VDWS    WsPtr
        LDR     r1, [WsPtr, #CurrentGraphicsVDriver]
        TEQ     r1, r2
        BNE     %FT90

        ; Translate this call into the corresponding Service_DisplayChanging calls
        ; DisplayStatus_Changing -> DisplayChanged_PreChanging
        ; DisplayStatus_Changed  -> DisplayChanged_Changing,
        ;                           DisplayChanged_Changed
        ; This may sound odd, but that's how it fits with the way the
        ; DisplayChanged service call is designed. The ScreenModes module will
        ; recache its mode list when it receives DisplayChanged_Changing, so we
        ; must only issue the call once the driver has finished changing its
        ; configuration.

        TEQ     r0, #DisplayStatus_Changed
        BEQ     %FT50
        MOV     r0, #DisplayChanged_PreChanging
        MOV     r1, #Service_DisplayChanged
        MOV     r3, #DisplayChangedSub_ModeNotChanged
        IssueService
        EXIT

50
        ; It was a DisplayStatus_Changed call. Recache any important values
        ; that we care about.
        MOV     r4, r2, LSL #24
        ORR     r4, r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        STR     r0, [WsPtr, #GraphicsVFeatures]

        ; Currently we assume that the driver's VSync ability or hardware
        ; scroll ability won't have been changed.

        ; Now issue the two DisplayChanged service calls
        MOV     r0, #DisplayChanged_Changing
        MOV     r1, #Service_DisplayChanged
        FRAMLDR r2
        MOV     r3, #DisplayChangedSub_ModeNotChanged
        IssueService
        MOV     r0, #DisplayChanged_Changed
        IssueService
90
        EXIT


@


4.12.2.30
log
@Change handling of GraphicsV_StartupMode. Fix OS_CheckModeValid for variable framestore case.
Detail:
  s/PMF/osinit, s/vdu/vdudriver - Move GraphicsV_StartupMode call from InitialiseMode to TranslateMonitorLeadType. This means (a) it'll only be used if the CMOS mode is set to 'auto' and (b) the returned mode can more easily be read by other modules via OS_ReadSysInfo 1.
  s/vdu/vduswis - Make OS_CheckModeValid act as if we have practically unlimited screen memory if using a GraphcisV driver with variable external framestore. In this case it's the driver should have already OK'd the memory requirements from within the VetMode call issued by FindOKMode - although the check won't be fully valid if we're checking for a shadow mode as the driver currently isn't told how many screen banks are required.
Admin:
  Tested on Raspberry Pi
  OS_CheckModeValid fix ensures valid modes which require large amounts of VRAM are reported correctly when we're currently in a low-memory mode


Version 5.35, 4.79.2.220. Tagged as 'Kernel-5_35-4_79_2_220'
@
text
@d403 7
@


4.12.2.31
log
@Add builtin software pointer support
Detail:
  This set of changes adds support for rendering software mouse pointers directly in the kernel, rather than requiring graphics drivers to render them themselves as was the case previously.
  If a driver returns from GraphicsV_Features with the 'hardware pointer' bit clear, and a call to GraphicsV_UpdatePointer is returned unclaimed, then the kernel will step in and render a software pointer. This allows selective control over which areas of the screen the software pointer is used (e.g. if hardware only supports its use in some areas)
  hdr/KernelWS - Shrink PointerXEigFactor to 1 byte to free up some space for tracking the display log2bpp. Use 8 words of space for tracking software pointer state.
  s/vdu/vducursoft - Adjust existing the existing calls to the software pointer RemovePointer/RestorePointer functions so that they're called with IRQs enabled
  s/vdu/vdudriver - Keep track of display log2bpp. Claim/release memory needed for restoring pixels under software pointer.
  s/vdu/vdugrafhal - Update HAL_VideoUpdatePointer handling so that 0 can be returned in a1 to indicate the GraphicsV call should be left unclaimed.
  s/vdu/vdupalxx - Trigger updates of the cached software pointer palette whenever it's likely to become invalidated.
  s/vdu/vdupointer - Add software pointer implementation. Relying on a SpriteExtend OS_SpriteOp would be nice, but we're in the background so have to do plotting & unplotting manually. ColourTrans is used to cache the pointer palette colours for the current mode, although we're limited to calling it from a callback.
Admin:
  Tested on Raspberry Pi & BB-xM
  Pointer is very flickery under some circumstances (e.g. running !CloseUp) due to needing to plot/unplot around any VDU driver screen access (as per text cursor). So code may need revising in future once we can trap reads/writes from specific screen memory pages.


Version 5.35, 4.79.2.269. Tagged as 'Kernel-5_35-4_79_2_269'
@
text
@a1082 1
        STRB    R1, [WsPtr, #DisplayLog2BPP]
d1085 1
a1085 1
        STRB    R3, [WsPtr, #PointerXEigFactor]
a1217 26
; claim/release memory needed for software pointer
        TST     R0, #GVDisplayFeature_HardwarePointer
        LDR     R2, [WsPtr, #SWP_Under]
        BEQ     %FT40
        TEQ     R2, #0
        MOVNE   R0, #0
        STRNE   R0, [WsPtr, #SWP_Under]
        MOVNE   R0, #ModHandReason_Free
        SWINE   XOS_Module
        B       %FT50

40
        TEQ     R2, #0
        BNE     %FT50
        ; Claim maximum amount needed
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #32*32*4
        SWI     XOS_Module
        STRVC   R2, [WsPtr, #SWP_Under]
50
        ; Release mutex and reset state
        ; Note that we do this even if the pointer isn't needed, to ensure we
        ; don't get confused about its state
        MOV     R2, #0
        STR     R2, [WsPtr, #SWP_Pos]
        STRB    R2, [WsPtr, #SWP_Mutex]
@


4.12.2.32
log
@Add initial support for "physical memory pools"
Detail:
  This set of changes adds support for "physical memory pools" (aka PMPs), a new type of dynamic area which allow physical pages to be claimed/allocated without mapping them in to the logical address space. PMPs have full control over which physical pages they use (similar to DAs which request specific physical pages), and also have full control over the logical mapping of their pages (which pages go where, and per-page access/cacheability control).
  Currently the OS makes use of two PMPs: one for the free pool (which now has a logical size of zero - freeing up gigabytes of logical space), and one for the RAM disc (logical size of 1MB, allowing for a physical size limited only by the amount of free memory)
  Implementing these changes has required a number of other changes to be made:
  * The CAM has been expanded from 8 bytes per entry to 16 bytes per entry, in order to allow each RAM page to store information about its PMP association
  * The system heap has been expanded to 32MB in size (from just under 4MB), in order to allow it to be used to store PMP page lists (1 word needed per page, but PMP pages may not always have physical pages assigned to them - so to allow multiple large PMPs to exist we need more than just 1 word per RAM page)
  * The &FA000000-&FBFFFFFF area of fixed kernel workspace has been shuffled around to accomodate the larger CAM, and the system heap is now located just above the RMA.
  * SoftResets code stripped out (unlikely we'll ever want to fix and re-enable it)
  * A couple of FastCDA options are now permanently on
  * Internal page flags shuffled around a bit. PageFlags_Unavailable now publicly exposed so that PMP clients can lock/unlock pages at will.
  * When OS_ChangeDynamicArea is asked to grow or shrink the free pool, it now implicitly converts it into a shrink or grow of application space (which is what would happen anyway). This simplifies the implementation; during a grow, pages (or replacement pages) are always sourced from the free pool, and during a shrink pages are always sent to the free pool.
  File changes:
  - hdr/KernelWS - Extend DANode structure. Describe CAM format. Adjust kernel workspace.
  - hdr/OSRSI6, s/Middle - Add new item to expose the CAM format
  - hdr/Options - Remove SoftResets switch. Add some PMP switches.
  - s/ARM600, s/VMSAv6 - Updated for new CAM format. Note that although the CAM stores PMP information, BangCamUpdate currently doesn't deal with updating that data - it's the caller's responsibility to do so where appropriate.
  - s/ChangeDyn - Lots of changes to implement PMP support, and to cope with the new CAM format.
  - s/HAL - Updated to cope with new CAM format, and lack of logical mapping of free pool.
  - s/MemInfo - Updated to cope with new CAM format. OS_Memory 0 updated to cope with converting PPN to PA for pages which are mapped out. OS_Memory 24 updated to decode the access permissions on a per-page basis for PMPs, and fixed its HWM usage for sparse DAs.
  - s/NewReset - Soft reset code and unused AddCamEntries function removed. Updated to cope with new CAM format, PMP free pool, PMP RAMFS
  - s/AMBControl/allocate - Update comment (RMA hasn't been used for AMBControl nodes for a long time)
  - s/AMBControl/growp, s/AMBControl/memmap, s/AMBControl/shrinkp - Update for new CAM format + PMP free pool
  - s/vdu/vdudriver - Strip out soft reset code.
Admin:
  Tested on Pandaboard
  This is just a first iteration of the PMP feature, with any luck future changes will improve functionality. This means APIs are subject to change as well.


Version 5.35, 4.79.2.284. Tagged as 'Kernel-5_35-4_79_2_284'
@
text
@d389 11
d402 1
@


4.12.2.18.2.1
log
@  Merge of Raspberry Pi support code against latest kernel
Detail:
  This is a new branch from the current tip of the HAL branch, incorporating
  the changes received from Adrian Lees. The same caveats apply - this is a
  work in progress and will not work on any other platform at present.
Admin:
  Builds, but not tested.

Version 5.35, 4.79.2.147.2.1. Tagged as 'Kernel-5_35-4_79_2_147_2_1'
@
text
@d368 1
a368 6
        ! 0, "FIXME: temporary code"
;!!!
   ADR r1,mode_defn

;        MOV     r1, r0

a379 8
        ! 0, "FIXME: temporary code"
mode_defn DCD 1
        DCD 1920
        DCD 1080
        DCD 5
        DCD -1
        DCD -1

a746 4
        ! 0, "FIXME: temporary code"
; !!!
  ADRL R2,mode_defn

a811 1
  DebugTX "FindOKMode reached"
a818 1
  DebugTX "PushModeInfo done"
a845 1
  DebugTX "Can't grow framestore"
a846 1
  DebugTX "Mode fail"
a928 3
        ! 0, "FIXME: temporary code"
;!!!
  [ {FALSE}
a932 7
  |
  ;hardcoded values for R-Pi alpha. external framestore requires a GraphicsV client,
  ;  but still debating the merits of external vs internal
  MOV r0,#&2000000
  MOV r1,#&0800000
  MOV r4,#0
  ]
d1217 2
a1218 7
        ! 0, "FIXME: temporary code"
;!!!
;        BL      OfferModeExtension
;        BEQ     %FT30                   ; [service claimed]
  MOV r3,#0
  MOV r4,#0
  B %FT30
a1416 1
;  DebugTX "ValModeSel"
a1419 1
;  DebugTX "Passed"
@


4.12.2.18.2.2
log
@  Changes to resolve some of the BCM2835 initial hacks
  1: Added HAL_FramebufferAddress entry.
  2: Minor mod the NoIrqVecSwiDispatch mods recently submitted. Improved coverage
  3: Added compile time switch InverseTextTransparency to toggle sense of text
  (pre-wimp) for use until correct transparency behaviour is introduced in the RPi
  start.elf.
  4: Ensured that if a non aligned frame buffer is reported, ALL of the space
  is actually mapped in.
Detail:
  (list files and functions that have changed)
Admin:
  builds and runs .. Still needs service_mode extension work to replace hard
  coded mode definition files
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 5.35, 4.79.2.147.2.5. Tagged as 'Kernel-5_35-4_79_2_147_2_5'
@
text
@d949 4
a952 2
        Push    "r0-r6"
        ! 0, "FIXME: fixed (!?) temporary code"
a956 23
 [ {TRUE}
; for mapping in, round start address down and size up to megabyte boundaries
; r0 = physical start, r1= size
; so frame buffer is wholly contained within the mapped in area
        MOV     r3, #1<<20                      ; 1 Megabyte
        SUB     r3, r3, #1                      ; convert to mask
        MOV     r4, r1                          ; remember what was asked for
        AND     r5, r0, r3                      ; and offset from megabyte base
        TST     r1, r3                          ; non integer megabyte?
        BIC     r2, r1, r3                      ; (clear the bits)
        ADDNE   r2, r2, #1<<20                  ; yes.. up to next megabyte
        BIC     r1, r0, r3                      ; ensure megabyte boundary at start
        MOV     r0, #13                         ; map in permanently
        ORR     r0, r0, #1:SHL:8                ; buffered, uncached
        ORR     r0, r0, #1:SHL:16+1:SHL:17      ; doubly map, access permission specified
        SWI     XOS_Memory
        BVS     %FT581
        STR     r4, [WsPtr, #TotalScreenSize]   ; what we asked for
        ADD     r3, r3, r4                      ; compute end
        ADD     r3, r3, r5                      ; and allow offset dfrom start
        STR     r3, [WsPtr, #ScreenEndAddr]     ; actual screen end
        MOV     r14, #1
        B       %FT582
d958 6
a979 2

 ]
d988 1
a988 1
        Pull    "r0-r6"
@


4.12.2.18.2.3
log
@Preperation for working Raspberry Pi video driver
Detail:
  hdr/HALEntries - Add new HAL_Video_StartupMode HAL entry to allow the HAL to specify a startup mode
  s/HAL, s/Kernel - Tweaked debug routines
  s/vdu/vdudriver - Make use of HAL_Video_StartupMode in InitialiseMode to decide what initial mode should be. Clean up some hacks & debug. Improve handling of external framestores; if bit 5 of GraphicsV_DisplayFeatures r0 is set, the kernel will now allow the display driver to grow/shrink/move its framestore in response to mode changes.
  s/vdu/vdugrafv - Adjust default GV_FramestoreAddress implementation to only claim vector if HAL returns a framestore
  s/vdu/vduswis - Re-enable FindOKMode
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.18. Tagged as 'Kernel-5_35-4_79_2_147_2_18'
@
text
@d345 1
a345 1
;                         
d368 3
a370 4
; at this stage, r0 = current screen mode either mode number or mode specifier
; lets give the HAL a chance to be fussy.
        mjsAddressHAL
        mjsCallHAL    HAL_Video_StartupMode
d372 1
a372 2
01
        MOV     r1, r0
d385 8
a392 1
;
d760 4
d811 1
d829 1
d837 1
d849 1
a849 3
        BNE     %FT08                   ; video driver agreed to the mode change
                                        ; so should handle memory growth OK
                                        ; maybe complain if GV_Features R0 bit 5 not set?
d865 1
d867 1
d950 1
a950 9
        MOV     r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV

; If driver handles memory allocation, must change mode before asking for memory

        TST     r0, #1<<5
        ADDNE   R0, R13, #wkwordsize+7*4        ; R0 -> VIDCList3
        BLNE    HardwareModeChange
        
a954 1

d1082 6
a1087 67
; tell hardware to change mode, unless already done
        MOV     r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        TST     r0, #1<<5
        ADDEQ   R0, R13, #wkwordsize            ; R0 -> VIDCList3
        BLEQ    HardwareModeChange

        ADD     R13, R13, #PushedInfoSize       ; junk stacked data

        ; for backward compatibility, show that video DMA is enabled in
        ; MEMC soft copy (DON'T call OS_UpdateMEMC, which would also
        ; make redundant call to HAL)
        ;
        SavePSR R2
        LDR     R0, =ZeroPage
        WritePSRc SVC_mode+I_bit+F_bit, R14
        LDR     R1, [R0, #MEMC_CR_SoftCopy]
        ORR     R1, R1, #(1 :SHL: 10)
        STR     R1, [R0, #MEMC_CR_SoftCopy]
        RestPSR R2

        BL      SetVendDefault

        LDR     R1, [WsPtr, #ScreenEndAddr]     ; need to reload cos corrupt
        LDR     R2, [WsPtr, #TotalScreenSize]
        SUB     R0, R1, R2                      ; R0 = Vstart
        BL      SetVstart
        MOV     R0, #0
        STRB    R0, [WsPtr, #PointerShapeNumber]
        STR     R0, [WsPtr, #TeletextOffset]
        STR     R0, [WsPtr, #CursorStack]       ; restore cursor on a mode

        BL      PalInit                 ; set default palette
        BL      UnblankScreen
        BL      SetMouseRectangle
        BL      FF

        [ {FALSE} ;;; LCDPowerCtrl :LAND: :LNOT: STB
                  ;;; mjsHAL no LCD support
        ;Switch the LCD on if LCD mode
        Push    "r0"
        MOV     R1, #0
        LDRB    R1, [R1, #LCD_Active]
        ANDS    R1, R1, #&7F            ;Check the LCD mode bits only, not the single/dual panel bit
        LDRNE   R0, =(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        LDRNE   R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        SWINE   XPortable_Control
        Pull    "r0"
        ]

        MOV     R1, #Service_ModeChange
        BL      IssueModeService

        CLRV                            ; indicate no error
        Pull    PC                      ; return to caller

; *****************************************************************************
;
;       HardwareModeChange - Tell the video driver to change the mode
;
; in:   R0 = VIDC list
;
; out:  All regs preserved
;

HardwareModeChange
        Push    "R0-R4, LR"
d1137 1
d1140 31
d1172 4
a1175 1
        Pull    "R0-R4, PC"
d1177 18
d1265 7
a1271 2
        BL      OfferModeExtension
        BEQ     %FT30                   ; [service claimed]
d1346 1
d1470 1
d1474 1
@


4.12.2.18.2.4
log
@Clean up remaining kernel hacks
Detail:
  Docs/RPiNotes - Deleted, contents no longer relevant
  s/HAL, s/Kernel, s/vdu/vduswis, s/pmf/key - Cleaned up debug code
  s/NewIRQs - No need to piggy back on timer 0 IRQ to generate a fake VSync; PushModeInfo already claims/releases TickerV as appropriate if video driver doesn't provide a VSync IRQ.
  s/NewReset - Re-enable LookForHALRTC call, the stack imbalance bug was fixed before the Pi changes were merged in
  s/vdu/vducursoft - Streamline PostWrchCursor a bit by only preserving R14 around RestorePointer if the software pointer is in use
  s/vdu/vdudriver - Amend ModeChangeSub improvements to ensure old external framestore handling logic is used if driver doesn't support framestore growth/realloc
Admin:
  Tested on Raspberry Pi with high processor vectors
  Kernel now looks to be in a good state for merging back into HAL branch
  Note - Software mouse pointer support in vducursoft only checks HALVideoFeatures, so doesn't take into account the capabilities of any GraphicsV driver that may be in use.


Version 5.35, 4.79.2.147.2.20. Tagged as 'Kernel-5_35-4_79_2_147_2_20'
@
text
@d837 3
a839 12
        BEQ     %FT05

; External framestore in use; does driver support growing/reallocating it?

        Push    "r1-r2,r4"
        MOV     r4, #GraphicsV_DisplayFeatures
        BL      CallGraphicsV
        Pull    "r1-r2,r4"
        TST     r0, #1<<5
        BNE     %FT08                   ; realloc supported, assume driver can allocate required memory since it OK'd the mode
        B       %FT06                   ; not supported, complain
05
@


4.12.2.18.2.5
log
@Fix addresses sent to GraphicsV_SetDMAAddress when external framestore in use. Add ID for BCM2835 VDU HAL device.
Detail:
  hdr/KernelWS, s/vdu/vdudriver, s/vdu/vduwrch - Fixed wrong addresses being sent to GraphicsV_SetDMAAddress when an external framestore is in use. Previously VideoPhysAddr was being treated as if it was the base of screen memory, but that's only the case if an internal framestore is in use. Since VideoPhysAddr is part of PhysRamTable it's not possible to change it to point to an external framestore, so a new workspace variable, TrueVideoPhysAddr, is used instead.
  hdr/HALDevice - Added device ID for BCM2835 VDU device
  s/PMF/IIC - Corrected an incorrect comment in IICDoOp
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.22. Tagged as 'Kernel-5_35-4_79_2_147_2_22'
@
text
@a162 1
        LDR     R14, [R0, #VideoPhysAddr]
a177 1
        STR     R14, [WsPtr, #TrueVideoPhysAddr]  ; init TrueVideoPhysAddr for internal RAM/VRAM framestore case 
a977 2
        ADD     r0, r1, r5                      ; reconstruct base phys address
        STR     r0, [WsPtr, #TrueVideoPhysAddr] ; and update our copy
a995 2
        ADD     r0, r1, r5                      ; reconstruct base phys address
        STR     r0, [WsPtr, #TrueVideoPhysAddr] ; and update our copy
@


4.12.2.18.2.6
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d182 1
a182 1
        AddressHAL
d184 3
a186 3
        CallHAL HAL_VideoFeatures
        ; Set bit 31 of features if HAL_VideoRender supported
        CheckHAL HAL_VideoRender, r1
d190 1
a190 1
        CallHAL HAL_VideoPixelFormats
d192 1
a192 1
        CallHAL HAL_VideoBufferAlignment
d198 2
a199 2
        ! 0, "HAL not doing anything useful with HAL_VideoBufferAlignment"
        ! 0, "HAL not dealing with lack of h/w pointer"
d250 12
d372 2
a373 2
        AddressHAL
        CallHAL    HAL_VideoStartupMode
d929 1
a929 1
                  ;;; HAL no LCD support
d1817 4
a1820 1
        ! 0, "HAL - svc_PortMan broken by kernel/HAL split due to lack of VIDCControlSoftCopy"
@


4.12.2.15.2.1
log
@Update VDU HAL device for new OMAPVideo driver, fix MVA-based cache/TLB maintenance ops aborting on ARMv7, add warning to VDU driver about inconsistent state variables during screen mode changes
Detail:
  hdr/VideoDevice - removed Address2 and Device2 fields as it makes more sense for them to be in the device specific field (which for OMAP3 is a pointer to an OMAP3-specific struct)
  s/VMSAv6 - Modify data abort handler to ignore aborts that are generated by MVA-based cache/TLB maintenance ops. Unlike earlier ARM architectures, MVA-based ops can abort under ARMv7 if the page has no mapping to a physical address.
  s/vdu/vdudriver - Add a warning about VDU driver state variables (particularly CursorAddr) being left in invalid states during the execution of mode changes. This can cause problems if any attempt is made to output to the screen during the mode change (e.g. as a result of an abort)
Admin:
  Tested on rev C2 beagleboard. Video device changes mean that OMAP3 HAL 0.23 will be needed for ROM compilation to succeed.


Version 5.35, 4.79.2.98.2.24. Tagged as 'Kernel-5_35-4_79_2_98_2_24'
@
text
@a805 2
        ! 0, "Need to fix ModeChangeSub to not leave CursorAddr, etc. pointing to unmapped pages during DA resize. Causes bad stuff should an abort occur/screen output be attempted!" ; Note that even enlarging the DA can leave the pointers in a bad state, due to the way the screen DA handler shuffles down/unmaps the lower mapping of VRAM before the higher copy is enlarged

@


4.12.2.15.2.2
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@a42 1
      [ ZeroPage = 0
a43 4
      |
        LDR     R0, =ZeroPage
        LDR     R0, [R0]
      ]
a57 1
      [ ZeroPage = 0
a58 4
      |
        LDR     R0, =ZeroPage
        LDR     R0, [R0]
      ]
d121 1
a121 1
        LDR     $size, =ZeroPage
d152 1
a152 2
        LDR     R0, =ZeroPage
        ASSERT (ZeroPage :AND: 255) = 0
a154 3
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
d343 1
a343 1
        LDREQ   r0, =ZeroPage+VduDriverWorkSpace+ModeNo
d375 1
a375 1
        LDR     R11, =ZeroPage          ; NB used later in Vdu07 as well
d945 1
a945 2
        LDR     R6, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
d1076 1
a1076 1
        LDR     R0, =ZeroPage
d1300 1
a1300 1
        LDR     a3, =ZeroPage+OsbyteVars
a2477 2
        LTORG

@


4.12.2.15.2.2.2.1
log
@  Support for Raspberry Pi / BCM2835
Detail:
  Falls into two main areas: graphics support and ARM11 core support.
  A work in progress - in many cases the code changes need to be replaced
  with an alternative mechanism which will permit the kernel to still function
  on other platforms. Adrian marked these with "!!!" comments - I have added
  ! directives as well so that they don't get forgotten about.
Admin:
  Changes received from Adrian Lees. This revision represents the code largely
  as delivered, and is placed on its own branch (forked off from the version
  from which he worked). It is intended for reference. It doesn't build against
  current headers - this is likely to require a merge with the other changes
  to the kernel since that time.

Version 5.35, 4.79.2.98.2.52.2.1. Tagged as 'Kernel-5_35-4_79_2_98_2_52_2_1'
@
text
@d365 1
a365 6
        ! 0, "FIXME: temporary code"
;!!!
   ADR r1,mode_defn

;        MOV     r1, r0

a376 8
        ! 0, "FIXME: temporary code"
mode_defn DCD 1
        DCD 1920
        DCD 1080
        DCD 5
        DCD -1
        DCD -1

a731 4
        ! 0, "FIXME: temporary code"
; !!!
  ADRL R2,mode_defn

a796 1
  DebugTX "FindOKMode reached"
a803 1
  DebugTX "PushModeInfo done"
a830 1
  DebugTX "Can't grow framestore"
a831 1
  DebugTX "Mode fail"
a913 3
        ! 0, "FIXME: temporary code"
;!!!
  [ {FALSE}
a917 7
  |
  ;hardcoded values for R-Pi alpha. external framestore requires a GraphicsV client,
  ;  but still debating the merits of external vs internal
  MOV r0,#&2000000
  MOV r1,#&0800000
  MOV r4,#0
  ]
d1202 2
a1203 7
        ! 0, "FIXME: temporary code"
;!!!
;        BL      OfferModeExtension
;        BEQ     %FT30                   ; [service claimed]
  MOV r3,#0
  MOV r4,#0
  B %FT30
a1401 1
;  DebugTX "ValModeSel"
a1404 1
;  DebugTX "Passed"
@


4.12.2.15.2.3
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d422 1
a422 2
        ADD     SP,SP,#4
        Pull    PC
a487 3
 [ No26bitCode
        ADR     R14, VduPrintExit
 |
a490 1
 ]
d495 1
a495 2
        ADD     SP, SP, #4
        Pull    PC
a549 3
 [ No26bitCode
        ADR     R14, VduPrintExit
 |
a552 1
 ]
d557 1
a557 2
        ADD     SP, SP, #4
        Pull    PC
a725 1
        LDR     R0, [R13], #8           ; get error pointer, junk next entry
d727 1
a727 1
        Pull    PC
@


4.11
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d2672 1
a2672 1
Vdu23_18
@


4.10
log
@Was using flags=2 to get PortManager to turn off outputs instead of flags=1.

Version 4.99. Tagged as 'Kernel-4_99'
@
text
@d356 3
d362 1
d1280 1
a1280 1
        EXITS
d2449 1
a2449 1
        Push    "R0,R14"
d2460 1
a2460 1
        Pull    "R0,PC",EQ,^                    ;EQ, quit on first (iff rclk=24MHz) or second terminator (iff rclk=32MHz)
d2467 1
a2467 1
        Push    "R14"
d2471 1
a2471 1
        Pull    "PC",EQ,^
d2587 1
a2587 1
        MOVNES  PC, LR
d2988 1
a2988 1
        TEQP    R7, #SVC_mode                   ; put bits into N, Z, C, V
@


4.9
log
@Fixed error in RDCH speed restoring logic.
When screen is blanked, DACs are turned off (60mA saving).
If DPMS state 3 comes on, sync lines are set low.

Version 4.96. Tagged as 'Kernel-4_96'
@
text
@d859 1
a859 1
        MOVEQ   R0, #2                  ; if not, pull the TV_Mode GPIO line low (if present)
d2592 1
a2592 1
        MOVNE   R0, #2                                  ; no: TV_Mode = 0
@


4.8
log
@Kernel now uses PortManager to set TV_Mode GPIO line, and updates it on
every mode change, rather than doing it once based on the monitor lead ID.
Requires PortManager, and required if PortManager is present.

Version 4.92. Tagged as 'Kernel-4_92'
@
text
@a1177 1
  [ StorkPowerSave :LAND: :LNOT: STB
a1183 1
  ]
@


4.7
log
@Kernel now sets "interlaced" mode flag itself from mode control parameters;
this simplifies the Interlace module's job significantly.
Hard font synchronised with International module.

Version 4.88. Tagged as 'Kernel-4_88'
@
text
@d655 6
d855 12
d2580 19
@


4.6
log
@Was erroneously programming a pseudo-register into VIDC.

Version 4.87. Tagged as 'Kernel-4_87'
@
text
@d796 7
d1379 29
d1859 1
d1974 3
d1978 30
d2037 3
d2042 1
a2042 1
        ORR     r0, r1, r7, LSL #5
a2045 2
 [ {TRUE}

a2062 6
 |
        CMP     r10, #&10000 :SHL: 3            ; this value (65.536 Mbytes/sec) lies above the point at which 7 works
                                                ; and below the point at which 7 is needed
        MOVCC   r7, #6
        MOVCS   r7, #7
 ]
a2064 1
        ORR     r0, r0, #VIDCControl
a2066 42
; Now go through VIDC control parameters list (not all indices can be handled yet)

        ADD     r3, r3, #VIDCList3_ControlList-8  ; point at 1st entry -8
50
        LDR     r4, [r3, #8]!                   ; load next index
        CMP     r4, #-1                         ; if -1 then end of list
        BEQ     %FT60                           ; so skip

        CMP     r4, #0                          ; if non-zero (CS if zero)
        CMPNE   r4, #ControlList_InvalidReason  ; and if known reason
        LDRCC   r2, [r3, #4]                    ; then load value
        BLCC    ProcessControlListItem          ; and process this item
        B       %BT50                           ; go onto next item in list

 [ {TRUE}
FIFOLoadTable
  [ {TRUE}      ; put a minimum of 4, cos 800 x 600 x 1bpp don't work otherwise
        &       0                               ; dummy entry (not used)
        &       0                               ; never use 0
        &       0                               ; use 1 up to (and including) here
        &       0                               ; use 2 up to (and including) here
        &       0                               ; use 3 up to (and including) here
        &       60000 :SHL: 3                   ; use 4 up to (and including) here
        &       75000 :SHL: 3                   ; use 5 up to (and including) here
        &       90000 :SHL: 3                   ; use 6 up to (and including) here
                                                ; else use 7
  |
        &       0                               ; dummy entry (not used)
        &       0                               ; never use 0
        &       12000 :SHL: 3                   ; use 1 up to (and including) here
        &       24000 :SHL: 3                   ; use 2 up to (and including) here
        &       36000 :SHL: 3                   ; use 3 up to (and including) here
        &       60000 :SHL: 3                   ; use 4 up to (and including) here
        &       75000 :SHL: 3                   ; use 5 up to (and including) here
        &       90000 :SHL: 3                   ; use 6 up to (and including) here
                                                ; else use 7
  ]
 ]


60

d2131 1
d2282 2
a2283 2
        LDR     r1, [r9, #PseudoRegister_HClockSpeed:SHR:22]            ; are we using HCLK?
        CMP     r1, #-1
d2286 1
a2286 1
        BIC     r1, r1, #&FF000000                                      ; r1 = HCLK frequency
@


4.5
log
@Default RCLK mode now RCLK/2 rather than RCLK/1.
Doesn't force CMOS setting of sync and monitortype on NCs/STBs.
Accepts HClockSelect parameter (number 9) in VIDC lists. Uses this to
determine whether to use HCLK or not, rather than abusing
Service_MonitorLeadTranslation.
If DontUseVCO flag is set, then VCLK will not be used - only RCLK (or HCLK if
requested).

Version 4.86. Tagged as 'Kernel-4_86'
@
text
@d874 1
a874 2
        MOV     R1, #124*4              ; number of bytes to do (register &FC is the pseudo one to tell
                                        ; the OS the real VIDC clock rate)
@


4.4
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d2107 1
a2107 1
        &       ProcessControlListNOP                   ; 9 - HClk select/specify
d2220 4
d2226 1
a2226 1
        ORR     r2, r2, r0                      ; form combined value
d2237 1
d2260 11
a2270 22
 [ ChrontelSupport
	MOV	r1, #CR_HCLK :OR: ((1-1) :SHL: CR_PixelDivShift)	; use divide by 1
	LDR	r0, =(63 :SHL: FSyn_RShift) :OR: (1 :SHL: FSyn_VShift)	; minimum V, maximum R
	EXIT
 |
  [ UseHClk :LAND: STB

; TMD 09-Oct-96: Only check monitor lead type if there is the hardware, otherwise assume just TV
   [ IOMD_C_MonitorType <> 0
	BL	TranslateMonitorLeadType	; -> r3=mode, r4=monitor, r5=sync
	CMP	r4, #3
	BEQ	%FT05
   ]

; Use HClk
	LDR	r1, =12500		; if desired pixel clock
	CMP	r0, r1
	MOVCC	r1, #CR_HCLK :OR: ((2-1) :SHL: CR_PixelDivShift)	; if < 12.5MHz, use divide by 2
	MOVCS	r1, #CR_HCLK :OR: ((1-1) :SHL: CR_PixelDivShift)	; else use divide by 1
	LDR	r0, =63 :OR: (1 :SHL: FSyn_VShift) ; minimum V, maximum R
	EXIT
  ]
d2353 1
d2357 1
a2391 1
 ] ; ChrontelSupport
@


4.3
log
@RISC OS 3.71 kernel changes merged.
Not fully tested on all hardware permutations.
@
text
@d828 7
d1940 4
d2255 5
d2396 2
a2397 2

 ]
@


4.3.2.1
log
@Added following enhancements:

 - Chocolate screen mapping (section mapped and cached), StrongARM only
   Phoebe h/w (IOMD 2) will have register to assist this, but code currently
   relies on data abort mechanism to keep screen up to date wrt write-back
   data cache.

 - Chocolate AMBControl task switching (lazy page mapping), StrongARM only
   Improves task swapping speed. There appears to be a StrongAEM silicon
   bug rev 2 and 3) which means that LDMIB rn, {regs includind rn} cannot
   be reliably restarted after a data abort. This stuffs Chocolate AMBControl
   (awaiting response from Digital).

Both enhancements need more work to complete for Phoebe. Chocolate AMBControl
may well have to be made dormant because of silicon bug.

Note that this kernel *will* cause problems with task switching on StrongARM,
unless Chocolate task switching is disabled via !Flavour application.
@
text
@d34 2
a35 2
        GBLL    LCDPowerCtrl
LCDPowerCtrl    SETL {TRUE} :LAND: :LNOT: STB
d711 11
a721 11
        [ LCDPowerCtrl :LAND: :LNOT: STB
        ;Switch LCD off here if it is _not_ an LCD mode
        MOV     R3, #0
        LDRB    R3, [R3, #LCD_Active]
        ANDS    R0, R3, #&7F            ;Pick out the lcd mode bits, ignoring the single/dual panel bit
        Push    "r0-r1"
        MOVEQ   R0, #0
        LDREQ   R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        SWIEQ   XPortable_Control
        Pull    "r0-r1"
        ]
d876 1
a876 1
        Push    "r0-r12"
d878 3
a880 3
        MOV     r10, #0
        LDRB    r10, [r10, #LCD_Active]
        CMP     r10, #2
d882 2
a883 2
        Pull    "r0-12", NE
        BNE     %FT20
d885 2
a886 2
        MOV     r10, r0
        MOV     r11, r1
d895 1
a895 1
        BVS     %FT20
d899 1
a899 1
        MOV     r2, r10
d1188 11
a1198 11
        [ LCDPowerCtrl :LAND: :LNOT: STB
        ;Switch the LCD on if LCD mode
        Push    "r0"
        MOV     R1, #0
        LDRB    R1, [R1, #LCD_Active]
        ANDS    R1, R1, #&7F            ;Check the LCD mode bits only, not the single/dual panel bit
        LDRNE   R0, =(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        LDRNE   R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
        SWINE   XPortable_Control
        Pull    "r0"
        ]
a1202 12
  [ ChocolateScreen
    ;if someone has suspended cached screen, or just the screen cleaner (and this has not already
    ;been fixed by screen Dynamic Area size change) we want to put things straight now
        MOV     LR,#0
        LDR     LR,[LR,#ARMA_Cleaner_status]
        TST     LR,#ACS_SCdisable
        BNE     MCS_chocolatesorted     ;sadly not available
        TST     LR,#ACS_SCsuspend
        BLNE    Screen_makechocolate    ;sort out SC suspended (and maybe screen not cached as well)
MCS_chocolatesorted
  ]

d2042 3
a2044 3
        MOV     r0, #0
        LDRB    r0, [r0, #LCD_Active]
        CMP     r0, #2
d2105 3
a2107 3
        LDRB    r1, [r0, #LCD_Active]           ;Read the existing value
        AND     r1, r1, #&80                    ;Clear all but the single/dual bit, 'cos this might have been set already
        ORR     r1, r1, r2                      ;Bung our new lcdmode into the byte, and....
d2109 1
a2109 1
        MOV     r1, #Ext_ECKOn                  ;Set the ECLK on
d2111 3
a2113 3
        CMP     r2, #3                          ;Was (is) it active-matrix?
        ORRNE   r1, r1, #Ext_LCDGrey            ;If not, set the LCD greyscaler 'on'
        ]
d2156 2
a2157 2
        LDRB    r1, [r0, #LCD_Active]
        ORR     r1, r1, #&80                    ;Set the top bit & leave the rest as-is
d2166 24
a2189 24
        LDR     r1, [r9, #VertiDisplayStart :SHR: 22]
        BIC     r0, r0, #VertiDisplayEnd
        BIC     r1, r1, #VertiDisplayStart
        SUB     r0, r0, r1                      ;R0 = Vres
        ADD     r1, r1, r0, LSR #1              ;R1 = Vres/2 + VDSR
        ORR     r1, r1, #VertiDisplayEnd
        STR     r1, [r9, #VertiDisplayEnd :SHR: 22]

        LDR     r1, [r9, #VertiCycle :SHR: 22]
        BIC     r1, r1, #VertiCycle
        SUB     r1, r1, r0, LSR #1
        ORR     r1, r1, #VertiCycle
        STR     r1, [r9, #VertiCycle :SHR: 22]

        LDR     r1, [r9, #VertiBorderEnd :SHR: 22]
        BIC     r1, r1, #VertiBorderEnd
        SUB     r1, r1, r0, LSR #1
        ORR     r1, r1, #VertiBorderEnd
        STR     r1, [r9, #VertiBorderEnd :SHR: 22]

        LDR     r1, [r9, #VIDCExternal :SHR: 22]
        BIC     r1, r1, #Ext_ERegExt
        ORR     r1, r1, #Ext_ERegGreen
        STR     r1, [r9, #VIDCExternal :SHR: 22]
d2201 2
a2202 2
        MOV     r0, #VIDC                       ;ACTUALLY PROGRAM VIDC (I know I shouldn't but I don't care - I've got a cold)
        STR     r2, [r0]
d2248 3
a2250 3
        BL      TranslateMonitorLeadType        ; -> r3=mode, r4=monitor, r5=sync
        CMP     r4, #3
        BEQ     %FT05
d2254 6
a2259 6
        LDR     r1, =12500              ; if desired pixel clock
        CMP     r0, r1
        MOVCC   r1, #CR_HCLK :OR: ((2-1) :SHL: CR_PixelDivShift)        ; if < 12.5MHz, use divide by 2
        MOVCS   r1, #CR_HCLK :OR: ((1-1) :SHL: CR_PixelDivShift)        ; else use divide by 1
        LDR     r0, =63 :OR: (1 :SHL: FSyn_VShift) ; minimum V, maximum R
        EXIT
@


4.3.2.2
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d115 1
d126 2
d130 1
d201 1
d205 1
d218 1
d221 3
d243 1
d261 1
d290 11
d303 2
d309 5
d608 1
d611 1
d622 1
d626 3
d648 1
d650 1
d659 1
d700 3
d804 6
d817 1
d837 13
d852 2
d856 7
d870 2
d874 39
d1034 26
d1082 54
d1139 7
d1287 1
d1290 1
d1302 1
d1312 1
d1314 1
d1331 7
d1344 1
d1359 1
d1402 1
d1406 1
d1434 89
d1547 1
d1552 1
d1555 1
d1577 21
d1604 1
d1629 4
d1708 1
d1710 1
d1726 1
d1757 1
d1759 1
d1765 1
d1795 1
d1875 1
d1975 1
d1994 6
d2019 1
d2021 1
d2031 12
d2049 33
d2083 1
d2393 1
d2435 1
d2454 1
d2535 7
@


4.3.2.3
log
@1) Fixes and tidy ups:
   - mapping of Cur/Sys/Sound area done more elegantly, and soft CAM info
     is now consistent with it
   - cached screen cleaning on VSync performed *after* VSync events
   - comments at top of ARM600 modernised
   - Pages_Unsafe/Safe code fixed to work properly on StrongARM with
     pages that are involved in interrupts (there is no fix for ARM8,
     since that is unlikely to be needed - an ASSERT checks use of ARM8
   - OS_DynamicArea code souped up, to be much more efficient for large
     numbers of dynamic areas (see comments near top of ChangeDyn)
   - cached screen is now suspended on h/w scroll (avoids possible cache
     incoherency)
2) API changes:
   - new OS_Memory reason code (10) allows Wimp to inform kernel of
     Wimp_ClaimFreeMemory, and can control VRAM rescue (see below)
   - new OS_ReadSysInfo reason code (6) allows reading of kernel values
     (reserved for Acorn use, eg. for SoftLoad, ROMPatch)
   - new OS_DynamicArea reason codes (6 and 7) allow for more efficient
     monitoring of dynamic areas by TaskManager (reserved for Acorn use)
3) Changes for Phoebe:
   - kernel runs a VRAM rescue process, which ensures that any VRAM not
     used for the screen is reclaimed if necessary and sinks to the bottom
     of the Free Pool. This is important for Phoebe, where VRAM is slower
     than SDRAM, but does no harm on other platforms.
   - logical copy of physical RAM is removed from memory map. This frees
     up 256M of address space that will later be used for PCI on Phoebe,
     but should do no harm on other platforms (this space is marked
     private in PRMs, so 3rd parties should not use it).
@
text
@d1005 2
a1006 5
    ;If someone has suspended cached screen, or just the screen cleaner (and this has not already
    ;been fixed by screen Dynamic Area size change) we want to put things straight now. Note that this
    ;is necessary both to avoid 3rd party s/w permanently suspending cached screen, and to restore
    ;cached screen after kernel hardware scrolling suspended it (eg. returning to desktop after F12).
    ;
@


4.3.2.3.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d35 1
a35 1
LCDPowerCtrl    SETL {TRUE}
d120 1
d124 2
d182 2
d201 1
d211 1
d250 1
d563 1
d566 1
d669 1
a669 1
        [ LCDPowerCtrl
d756 1
d761 2
d766 1
d768 2
d779 1
d787 5
d795 1
d798 5
d835 1
a854 13
        ;look for bit 23 set, meaning must program new VCO
        TST     R2, #(1 :SHL 23)
        BEQ     %FT55
        Push    "R0"
        BIC     R0,R2,#&FF000000
        BIC     R0,R0,#&00800000        ; frequency from bits 22:0 of pseudo FSyn value
        BL      program_newVCO
        MOV     R2, #VIDCFSyn           ; construct real FSyn value
        ORR     R2, R2, #63 :SHL: 8     ; large v
        ORR     R2, R2, #63             ; large r
        Pull    "R0"
55

d871 1
d893 2
d904 17
a920 14
66
        MOV     r9,#IOMD_Base
        LDRB    r9,[r9,#IOMD_ID0]
        TEQ     r9,#IOMD_Original :AND: &FF
        TEQNE   r9,#IOMD_IOMD2    :AND: &FF
        LDREQ   r9,=24000                   ;Risc PC, Phoebe clock VIDC20 at 24MHz
        BEQ     %FT67
        TEQ     r9,#IOMD_7500     :AND: &FF
        TEQNE   r9,#IOMD_7500FE   :AND: &FF
        MOVEQ   r9,#32000                   ;Morris clocks VIDC20L at 32Mhz
        BEQ     %FT67
        B       %BT66                       ;deliberate panic hang up

67
d924 1
d937 1
d943 2
d948 1
a948 1
  [ StorkPowerSave
d989 1
a989 1
        [ LCDPowerCtrl
d1026 12
d1212 1
d1221 2
d1535 1
d1537 2
d1609 18
a1626 23
65
        MOV     r1,#IOMD_Base
        LDRB    r1,[r1,#IOMD_ID0]
  [ PhoebeBodge_OldVCO
        TEQ     r1,#IOMD_Original :AND: &FF
        TEQNE   r1,#IOMD_IOMD2    :AND: &FF
        LDREQ   r1,=24000                   ;Risc PC, Phoebe clock VIDC20 at 24MHz
        BEQ     %FT67
  |
        TEQ     r1,#IOMD_Original :AND: &FF
        LDREQ   r1,=24000                   ;Risc PC clocks VIDC20 at 24MHz
        BEQ     %FT67
        TEQ     r1,#IOMD_IOMD2    :AND: &FF
        MOVEQ   r1,#0                       ;special value, means use new VCO
        BEQ     %FT67                       ;Phoebe has new style VCO
  ]
        TEQ     r1,#IOMD_7500     :AND: &FF
        TEQNE   r1,#IOMD_7500FE   :AND: &FF
        MOVEQ   r1,#32000                   ;Morris clocks VIDC20L at 32Mhz
        BEQ     %FT67
        B       %BT65                       ;deliberate panic hang up

67
a1627 10

        ;look for bit 23 of r0 set, meaning must program new VCO
        TST     r0,#(1 :SHL 23)
        BEQ     %FT68
        BIC     r0,r0,#&00800000        ; frequency from bits 22:0 of pseudo FSyn value
        BL      program_newVCO
        MOV     r0,#63 :SHL: 8          ; large v
        ORR     r0,r0,#63               ; large r
68

d1720 3
d1732 1
d1769 5
d1813 1
a1840 1
;            OR = 0, meaning use new style VCO (as on Phoebe)
a1842 2
;     OR (Phoebe style VCO):
;       r0 bit 23 set, and frequency (kHz) in bits 22:0 (pseudo FSyn value)
a1844 1

d1863 1
d1865 15
a1879 4
        CMP     r1, #0                                ; check for new style VCO (Phoebe)
        ORREQ   r0, r0, #(1 :SHL: 23)                 ; pseudo-bit 23 = 1 flags use new VCO
        MOVEQ   r1, #0                                ; divider = 1, pixel source = VCLK
        BEQ     %FT99
a1997 1
99
a1999 88
; *****

; program_newVCO
;
; Program the Focus Semiconductor FS6031/6131 VCO device for desired clock
; frequency.
;
; In:  r0 = desired frequency (f), in kHz
;

nvco_slaveaddress * 2_10110000
nvco_reg1         * 176
nvco_reg2         * 20
nvco_reg6         * 32
nvco_reg7         * 0
nvco_reg8         * 16

program_newVCO ROUT

        Push    "r0-r5,lr"

; limit f to a range of roughly 5 MHz to 250 MHz

        CMP     r0, #5*1024
        MOVLO   r0, #5*1024
        CMP     r0, #250*1024
        MOVHI   r0, #250*1024

        ADD     r0, r0, #10        ; rounding
        MOV     r2, #20
        DivRem  r1, r0, r2, r3     ; r1 := freq in units of 20 kHz

; Calculate values for registers 3, 4 and 5 in VCO device.
; The other five registers are not dependent on f

        CMP     r1, #40*50         ; if f >= 40 MHz
        MOVGE   r3, #0             ; reg3 value
        BGE     %FT10

        CMP     r1, #10*50         ; if f <= 10 MHz
        MOVLE   r3, #9             ; reg3 value
        ADDLE   r1, r1, r1, LSL #2
        MOVLE   r1, r1, LSL #1     ; f := f*10
        BLE     %FT10

        MOV     r3, #2             ; else if f>10 MHz and f<40 MHz reg3 value
        MOV     r1, r1, LSL #2     ; f := f*4

10      AND     r4, r1, #&FF       ; reg4 value (lower 8 bits)
        MOV     r5, r1, LSR #8
        ORR     r5, r5, #&80       ; reg5 value (128 + upper 7 bits)
        
; Now send all eight register values out on the I2C bus

        MOV     r0, #nvco_slaveaddress
        BL      StartTXPollAck

        MOV     r0, #0
        BL      i2c_tx
        MOV     r0, #nvco_reg1
        BL      i2c_tx
        MOV     r0, #nvco_reg2
        BL      i2c_tx
        MOV     r0, r3
        BL      i2c_tx
        MOV     r0, r4
        BL      i2c_tx
        MOV     r0, r5
        BL      i2c_tx
        MOV     r0, #nvco_reg6
        BL      i2c_tx
        MOV     r0, #nvco_reg7
        BL      i2c_tx
        MOV     r0, #nvco_reg8
        BL      i2c_tx

        BL      Stop

        Pull    "r0-r5,pc"

; i2c_tx
;
; Send a byte to I2C and wait for acknowledge

i2c_tx  ENTRY
        BL      TXByte
        BL      Acknowledge
        EXIT
d2009 1
a2009 1
; out:  R11 -> word after pixrate (which is assumed to follow -1 terminator)
d2012 1
d2014 6
a2019 1
        Push    "R0-R2,R14"
d2023 4
a2026 1
        BEQ     %FT20                           ; terminator reached
d2030 14
a2043 26
20
        MOV     R1, #IOMD_Base
        LDRB    R1, [R1,#IOMD_ID0]
        TEQ     R1, #IOMD_Original :AND: &FF
        LDREQ   R1, =24000                      ; 24 MHz ref clock on Risc PC
        BEQ     %FT30
        TEQ     R1, #IOMD_7500     :AND: &FF
        TEQNE   R1, #IOMD_7500FE   :AND: &FF
        MOVEQ   R1, #32000                      ; 32 MHz ref clock on A7000,A7000+
        BEQ     %FT30
        TEQ     R1, #IOMD_IOMD2    :AND: &FF
        MOVEQ   R1, #0                          ; special value, meaning new VCO
        BEQ     %FT30
        BNE     %BT20                           ; deliberate panic hang up
30
        LDR     R0, [R11], #4                   ; pick up planted pixrate (kHz)
        BL      ComputeModuli                   ; out: r0 = FSyn  bits, r1 = Control bits
        MOV     R14, #VIDCFSyn
        LDR     R2, [R9, R14, LSR #22]
        ORR     R2, R2, R0                      ; munge in FSyn bits from ComputeModuli
        STR     R2, [R9, R14, LSR #22]
        MOV     R14, #VIDCControl
        LDR     R2, [R9, R14, LSR #22]
        ORR     R2, R2, R1                      ; munge in Control bits from ComputeModuli
        STR     R2, [R9, R14, LSR #22]
        Pull    "R0-R2,PC",,^
d2572 1
a2572 1
;;;        !       0,"WARNING: AddTintToColour returns > 8 bit values now, check ECF handling!"
@


4.3.2.4
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d35 1
a35 1
LCDPowerCtrl    SETL {TRUE}
d120 1
d124 2
d182 2
d201 1
d211 1
d250 1
d563 1
d566 1
d669 1
a669 1
        [ LCDPowerCtrl
d756 1
d761 2
d766 1
d768 2
d779 1
d787 5
d795 1
d798 5
d835 1
a854 13
        ;look for bit 23 set, meaning must program new VCO
        TST     R2, #(1 :SHL 23)
        BEQ     %FT55
        Push    "R0"
        BIC     R0,R2,#&FF000000
        BIC     R0,R0,#&00800000        ; frequency from bits 22:0 of pseudo FSyn value
        BL      program_newVCO
        MOV     R2, #VIDCFSyn           ; construct real FSyn value
        ORR     R2, R2, #63 :SHL: 8     ; large v
        ORR     R2, R2, #63             ; large r
        Pull    "R0"
55

d871 1
d893 2
d904 17
a920 14
66
        MOV     r9,#IOMD_Base
        LDRB    r9,[r9,#IOMD_ID0]
        TEQ     r9,#IOMD_Original :AND: &FF
        TEQNE   r9,#IOMD_IOMD2    :AND: &FF
        LDREQ   r9,=24000                   ;Risc PC, Phoebe clock VIDC20 at 24MHz
        BEQ     %FT67
        TEQ     r9,#IOMD_7500     :AND: &FF
        TEQNE   r9,#IOMD_7500FE   :AND: &FF
        MOVEQ   r9,#32000                   ;Morris clocks VIDC20L at 32Mhz
        BEQ     %FT67
        B       %BT66                       ;deliberate panic hang up

67
d924 1
d937 1
d943 2
d948 1
a948 1
  [ StorkPowerSave
d989 1
a989 1
        [ LCDPowerCtrl
d1026 12
d1212 1
d1221 2
d1535 1
d1537 2
d1609 18
a1626 23
65
        MOV     r1,#IOMD_Base
        LDRB    r1,[r1,#IOMD_ID0]
  [ PhoebeBodge_OldVCO
        TEQ     r1,#IOMD_Original :AND: &FF
        TEQNE   r1,#IOMD_IOMD2    :AND: &FF
        LDREQ   r1,=24000                   ;Risc PC, Phoebe clock VIDC20 at 24MHz
        BEQ     %FT67
  |
        TEQ     r1,#IOMD_Original :AND: &FF
        LDREQ   r1,=24000                   ;Risc PC clocks VIDC20 at 24MHz
        BEQ     %FT67
        TEQ     r1,#IOMD_IOMD2    :AND: &FF
        MOVEQ   r1,#0                       ;special value, means use new VCO
        BEQ     %FT67                       ;Phoebe has new style VCO
  ]
        TEQ     r1,#IOMD_7500     :AND: &FF
        TEQNE   r1,#IOMD_7500FE   :AND: &FF
        MOVEQ   r1,#32000                   ;Morris clocks VIDC20L at 32Mhz
        BEQ     %FT67
        B       %BT65                       ;deliberate panic hang up

67
a1627 10

        ;look for bit 23 of r0 set, meaning must program new VCO
        TST     r0,#(1 :SHL 23)
        BEQ     %FT68
        BIC     r0,r0,#&00800000        ; frequency from bits 22:0 of pseudo FSyn value
        BL      program_newVCO
        MOV     r0,#63 :SHL: 8          ; large v
        ORR     r0,r0,#63               ; large r
68

d1720 3
d1732 1
d1769 5
d1813 1
a1840 1
;            OR = 0, meaning use new style VCO (as on Phoebe)
a1842 2
;     OR (Phoebe style VCO):
;       r0 bit 23 set, and frequency (kHz) in bits 22:0 (pseudo FSyn value)
a1844 1

d1863 1
d1865 15
a1879 4
        CMP     r1, #0                                ; check for new style VCO (Phoebe)
        ORREQ   r0, r0, #(1 :SHL: 23)                 ; pseudo-bit 23 = 1 flags use new VCO
        MOVEQ   r1, #0                                ; divider = 1, pixel source = VCLK
        BEQ     %FT99
a1997 1
99
a1999 88
; *****

; program_newVCO
;
; Program the Focus Semiconductor FS6031/6131 VCO device for desired clock
; frequency.
;
; In:  r0 = desired frequency (f), in kHz
;

nvco_slaveaddress * 2_10110000
nvco_reg1         * 176
nvco_reg2         * 20
nvco_reg6         * 32
nvco_reg7         * 0
nvco_reg8         * 16

program_newVCO ROUT

        Push    "r0-r5,lr"

; limit f to a range of roughly 5 MHz to 250 MHz

        CMP     r0, #5*1024
        MOVLO   r0, #5*1024
        CMP     r0, #250*1024
        MOVHI   r0, #250*1024

        ADD     r0, r0, #10        ; rounding
        MOV     r2, #20
        DivRem  r1, r0, r2, r3     ; r1 := freq in units of 20 kHz

; Calculate values for registers 3, 4 and 5 in VCO device.
; The other five registers are not dependent on f

        CMP     r1, #40*50         ; if f >= 40 MHz
        MOVGE   r3, #0             ; reg3 value
        BGE     %FT10

        CMP     r1, #10*50         ; if f <= 10 MHz
        MOVLE   r3, #9             ; reg3 value
        ADDLE   r1, r1, r1, LSL #2
        MOVLE   r1, r1, LSL #1     ; f := f*10
        BLE     %FT10

        MOV     r3, #2             ; else if f>10 MHz and f<40 MHz reg3 value
        MOV     r1, r1, LSL #2     ; f := f*4

10      AND     r4, r1, #&FF       ; reg4 value (lower 8 bits)
        MOV     r5, r1, LSR #8
        ORR     r5, r5, #&80       ; reg5 value (128 + upper 7 bits)
        
; Now send all eight register values out on the I2C bus

        MOV     r0, #nvco_slaveaddress
        BL      StartTXPollAck

        MOV     r0, #0
        BL      i2c_tx
        MOV     r0, #nvco_reg1
        BL      i2c_tx
        MOV     r0, #nvco_reg2
        BL      i2c_tx
        MOV     r0, r3
        BL      i2c_tx
        MOV     r0, r4
        BL      i2c_tx
        MOV     r0, r5
        BL      i2c_tx
        MOV     r0, #nvco_reg6
        BL      i2c_tx
        MOV     r0, #nvco_reg7
        BL      i2c_tx
        MOV     r0, #nvco_reg8
        BL      i2c_tx

        BL      Stop

        Pull    "r0-r5,pc"

; i2c_tx
;
; Send a byte to I2C and wait for acknowledge

i2c_tx  ENTRY
        BL      TXByte
        BL      Acknowledge
        EXIT
d2009 1
a2009 1
; out:  R11 -> word after pixrate (which is assumed to follow -1 terminator)
d2012 1
d2014 6
a2019 1
        Push    "R0-R2,R14"
d2023 4
a2026 1
        BEQ     %FT20                           ; terminator reached
d2030 14
a2043 26
20
        MOV     R1, #IOMD_Base
        LDRB    R1, [R1,#IOMD_ID0]
        TEQ     R1, #IOMD_Original :AND: &FF
        LDREQ   R1, =24000                      ; 24 MHz ref clock on Risc PC
        BEQ     %FT30
        TEQ     R1, #IOMD_7500     :AND: &FF
        TEQNE   R1, #IOMD_7500FE   :AND: &FF
        MOVEQ   R1, #32000                      ; 32 MHz ref clock on A7000,A7000+
        BEQ     %FT30
        TEQ     R1, #IOMD_IOMD2    :AND: &FF
        MOVEQ   R1, #0                          ; special value, meaning new VCO
        BEQ     %FT30
        BNE     %BT20                           ; deliberate panic hang up
30
        LDR     R0, [R11], #4                   ; pick up planted pixrate (kHz)
        BL      ComputeModuli                   ; out: r0 = FSyn  bits, r1 = Control bits
        MOV     R14, #VIDCFSyn
        LDR     R2, [R9, R14, LSR #22]
        ORR     R2, R2, R0                      ; munge in FSyn bits from ComputeModuli
        STR     R2, [R9, R14, LSR #22]
        MOV     R14, #VIDCControl
        LDR     R2, [R9, R14, LSR #22]
        ORR     R2, R2, R1                      ; munge in Control bits from ComputeModuli
        STR     R2, [R9, R14, LSR #22]
        Pull    "R0-R2,PC",,^
d2572 1
a2572 1
;;;        !       0,"WARNING: AddTintToColour returns > 8 bit values now, check ECF handling!"
@


4.2
log
@Kernel merged
@
text
@d1020 1
a1020 1
    ;    CMP     R9, #&98
d1022 3
a1024 3
    ;    CMPEQ   R9, #&5B
    ;    MOVEQ   R9, #32000              ;Morris clocks VIDC20L at 32Mhz
    ;    LDRNE   R9, =24000              ;RISC PC clocks VIDC20 at 24MHz
d1938 1
a1938 1
   ;     CMP     R1, #&98
d1940 3
a1942 3
   ;     CMPEQ   R1, #&5B
   ;     MOVEQ   R1, #32000              ;Morris clocks VIDC20L at 32Mhz
   ;     LDRNE   R1, =24000              ;RISC PC clocks VIDC20 at 24MHz
d2360 6
d2368 1
@


4.2.4.1
log
@File merged from Spinner branch
@
text
@a2243 6

 [ ChrontelSupport
	MOV	r1, #CR_HCLK :OR: ((1-1) :SHL: CR_PixelDivShift)	; use divide by 1
	LDR	r0, =63 :OR: (1 :SHL: FSyn_VShift)			; minimum V, maximum R
	EXIT
 |
d2373 2
a2374 2
 ] ; ChrontelSupport
 ] ; VIDCListType3
@


4.1
log
@Initial revision
@
text
@d34 3
d593 4
d700 1
a700 1
 |        
d710 13
d725 1
a725 1
        LDR     R3, [R13, #wkScreenSize]
d873 42
d1147 9
d1188 12
d1630 1
a1630 1
        CMP     r0, #SpriteType_MAX             ; check for legality - NB type 0 is illegal because r2>=&100                         
d1656 1
a1656 1
        
d1661 1
a1661 1
        
d1675 2
a1676 2
        BEQ     %FT71                               
        
d1858 1
a1858 1
; on the basis of how much VRAM we've got
d1948 1
a1948 1
;>>>RCM says can we replace the above by 
d2041 8
d2067 1
a2067 1
        =       "SCSI::HD4.$.ModeData", 0
d2101 1
d2103 11
d2126 1
d2150 41
d2194 1
d2201 2
d2206 1
a2206 1
        MOV     r1, #LCDOffsetRegister1
d2244 20
d2713 1
a2713 1
        
d2753 1
a2753 1
                                     
d2845 1
a2845 1
                                     
d2964 1
a2964 1
        Pull    "R3,PC"        
d3140 1
a3140 1
; 
d3160 1
a3160 1
                            
d3173 1
a3173 1
        BNE     %FT70                    
d3177 1
a3177 1
     
d3217 1
a3217 1
                     
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d693 1
a693 1
 |
d1547 1
a1547 1
        CMP     r0, #SpriteType_MAX             ; check for legality - NB type 0 is illegal because r2>=&100
d1573 1
a1573 1

d1578 1
a1578 1

d1592 2
a1593 2
        BEQ     %FT71

d1865 1
a1865 1
;>>>RCM says can we replace the above by
a2095 20
  [ UseHClk

; TMD 09-Oct-96: Only check monitor lead type if there is the hardware, otherwise assume just TV
   [ IOMD_C_MonitorType <> 0
	BL	TranslateMonitorLeadType	; -> r3=mode, r4=monitor, r5=sync
	CMP	r4, #3
	BEQ	%FT05
   ]

; Use HClk
	LDR	r1, =12500		; if desired pixel clock
	CMP	r0, r1
	MOVCC	r1, #CR_HCLK :OR: ((2-1) :SHL: CR_PixelDivShift)	; if < 12.5MHz, use divide by 2
	MOVCS	r1, #CR_HCLK :OR: ((1-1) :SHL: CR_PixelDivShift)	; else use divide by 1
	LDR	r0, =63 :OR: (1 :SHL: FSyn_VShift) ; minimum V, maximum R
	EXIT
  ]

; Use VCLK/RCLK
05
d2206 1
a2206 1
 ] ; VIDCListType3
d2545 1
a2545 1

d2585 1
a2585 1

d2677 1
a2677 1

d2796 1
a2796 1
        Pull    "R3,PC"
d2972 1
a2972 1
;
d2992 1
a2992 1

d3005 1
a3005 1
        BNE     %FT70
d3009 1
a3009 1

d3049 1
a3049 1

@


4.1.7.2
log
@Added support for Chrontel device.
@
text
@a2095 6

 [ ChrontelSupport
	MOV	r1, #CR_HCLK :OR: ((1-1) :SHL: CR_PixelDivShift)	; use divide by 1
	LDR	r0, =63 :OR: (1 :SHL: FSyn_VShift)			; minimum V, maximum R
	EXIT
 |
d2225 1
a2225 1
 ] ; ChrontelSupport
@


4.1.7.3
log
@Fixed to use HCLK for built-in video modes on NC with Chrontel
@
text
@d2099 1
a2099 1
	LDR	r0, =(63 :SHL: FSyn_RShift) :OR: (1 :SHL: FSyn_VShift)	; minimum V, maximum R
@


4.1.7.4
log
@Compile time option for TV display HCLK divider added
@
text
@a2097 3
   [ BuildForPAL
	MOV	r1, #CR_HCLK :OR: ((4-1) :SHL: CR_PixelDivShift)	; use divide by 4
   |
a2098 1
   ]
@


4.1.7.5
log
@Added SWI OS_VIDCDivider, and vdu variable PixelRate for better video mode
support.  Fixed to build for Risc PC.
@
text
@a807 7
 [ ChrontelSupport
        LDR     R1, [R0, #(PseudoRegister_PixelRate:SHR:22)-&80*4] ; get pixel rate
        CMP     R1, #-1                 ; if not specified
        MOVEQ   R1, #0                  ; then use zero
        BIC     R1, R1, #&FF000000      ; Only use 24 bits
        STR     R1, [WsPtr, #PixelRate]
 ]
a1849 4
   [ ChrontelSupport
	ORR	r10, r0, #PseudoRegister_PixelRate               ; Set index
        STR     r10, [r9, #PseudoRegister_PixelRate :SHR: 22]    ; Store for later
   ]
d2098 3
d2102 1
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d693 1
a693 1
 |
d1547 1
a1547 1
        CMP     r0, #SpriteType_MAX             ; check for legality - NB type 0 is illegal because r2>=&100
d1573 1
a1573 1

d1578 1
a1578 1

d1592 2
a1593 2
        BEQ     %FT71

d1865 1
a1865 1
;>>>RCM says can we replace the above by
a2095 20
  [ UseHClk

; TMD 09-Oct-96: Only check monitor lead type if there is the hardware, otherwise assume just TV
   [ IOMD_C_MonitorType <> 0
	BL	TranslateMonitorLeadType	; -> r3=mode, r4=monitor, r5=sync
	CMP	r4, #3
	BEQ	%FT05
   ]

; Use HClk
	LDR	r1, =12500		; if desired pixel clock
	CMP	r0, r1
	MOVCC	r1, #CR_HCLK :OR: ((2-1) :SHL: CR_PixelDivShift)	; if < 12.5MHz, use divide by 2
	MOVCS	r1, #CR_HCLK :OR: ((1-1) :SHL: CR_PixelDivShift)	; else use divide by 1
	LDR	r0, =63 :OR: (1 :SHL: FSyn_VShift) ; minimum V, maximum R
	EXIT
  ]

; Use VCLK/RCLK
05
d2206 1
a2206 1
 ] ; VIDCListType3
d2545 1
a2545 1

d2585 1
a2585 1

d2677 1
a2677 1

d2796 1
a2796 1
        Pull    "R3,PC"
d2972 1
a2972 1
;
d2992 1
a2992 1

d3005 1
a3005 1
        BNE     %FT70
d3009 1
a3009 1

d3049 1
a3049 1

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a33 3
	GBLL	LCDPowerCtrl
LCDPowerCtrl	SETL {TRUE}

a589 2
        MOV     r1, #0
        STRB    r1, [r1, #LCD_Active]   ;Default to non-lcd active, single panel (mainly for Stork power-saving info)
d693 1
a693 1
 |
a702 13

	[ LCDPowerCtrl
	;Switch LCD off here if it is _not_ an LCD mode
	MOV	R3, #0
	LDRB	R3, [R3, #LCD_Active]
	ANDS	R0, R3, #&7F		;Pick out the lcd mode bits, ignoring the single/dual panel bit
	Push	"r0-r1"
	MOVEQ	R0, #0
	LDREQ	R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
	SWIEQ	XPortable_Control
	Pull	"r0-r1"
	]

d705 1
a705 1
13      LDR     R3, [R13, #wkScreenSize]
a852 42

   [ {FALSE}   ;DEBUGGING CODE - DUMPS THE VIDC REGISTER TABLE TO A FILE (DONE FOR LCDSUPPORT)

	Push	"r0-r12"

	MOV	r10, #0
	LDRB	r10, [r10, #LCD_Active]
	CMP	r10, #2

	Pull    "r0-12", NE
	BNE     %FT20

	MOV	r10, r0
	MOV	r11, r1

        ! 0, "**** WARNING: VIDC List debugging assembled in ****"

        MOV     r0, #&80
        ADR     r1, DbgFilename
        SWI     XOS_Find

        Pull    "r0-r12", VS
	BVS	%FT20

        MOV     r1, r0
        MOV     r0, #2
	MOV	r2, r10
        MOV     r3, r11
        SWI     XOS_GBPB

        MOV     r0, #0
        SWI     XOS_Find

        Pull    "r0-r12"

DbgFilename
        =       "$.VIDCData", 0
        ALIGN

   ]


a1084 9
  [ StorkPowerSave
        TEQ     R6, #VIDCExternal
        STREQ   R2, [WsPtr, #VIDCExternalSoftCopy]
        TEQ     R6, #VIDCFSyn
        STREQ   R2, [WsPtr, #VIDCFSynSoftCopy]
        TEQ     R6, #VIDCControl
        STREQ   R2, [WsPtr, #VIDCControlSoftCopy]
  ]

a1116 12
	[ LCDPowerCtrl
	;Switch the LCD on if LCD mode
	Push	"r0"
	MOV	R1, #0
	LDRB	R1, [R1, #LCD_Active]
	ANDS	R1, R1, #&7F		;Check the LCD mode bits only, not the single/dual panel bit
	LDRNE	R0, =(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
	LDRNE	R1, =:NOT:(PortableControl_LCDEnable :OR: PortableControl_BacklightEnable)
	SWINE	XPortable_Control
	Pull	"r0"
	]

d1547 1
a1547 1
        CMP     r0, #SpriteType_MAX             ; check for legality - NB type 0 is illegal because r2>=&100
d1573 1
a1573 1

d1578 1
a1578 1

d1592 2
a1593 2
        BEQ     %FT71

d1775 1
a1775 1
; on the basis of how much VRAM we've got, and on whether we have a dual-panel LCD or not...
d1865 1
a1865 1
;>>>RCM says can we replace the above by
a1957 6
	MOV	r0, #0
	LDRB	r0, [r0, #LCD_Active]
	CMP	r0, #2
        Pull    "r0, r1, r2-r4, r7-r11, pc", NE


d1976 1
a1976 1
        =       "$.ModeData", 0
d2010 1
a2010 9
        MOV     r0, #0
	LDRB	r1, [r0, #LCD_Active]		;Read the existing value
	AND	r1, r1, #&80			;Clear all but the single/dual bit, 'cos this might have been set already
	ORR	r1, r1, r2			;Bung our new lcdmode into the byte, and....
        STRB    r1, [r0, #LCD_Active]           ;...store in the KernelWS which LCD mode we are in.
        MOV     r1, #Ext_ECKOn			;Set the ECLK on

	CMP	r2, #3				;Was (is) it active-matrix?
	ORRNE	r1, r1, #Ext_LCDGrey		;If not, set the LCD greyscaler 'on'
a2022 1

a2045 36
        MOV     r0, #0
	LDRB	r1, [r0, #LCD_Active]
	ORR	r1, r1, #&80			;Set the top bit & leave the rest as-is
        STRB    r1, [r0, #LCD_Active]           ;Store in the KernelWS that we are in dual-panel LCD mode.
        LDR     r0, [r9, #VIDCDataControl :SHR: 22]
        MOV     r1, r0, LSL #(31-10)            ;Put HDWR bits to the top
        BIC     r0, r0, r1, LSR #(31-10)        ;knock off bits
        ORR     r0, r0, r1, LSR #(31-11)        ;Put back one bit further up (ie mul by 2)
        STR     r0, [r9, #VIDCDataControl :SHR: 22]

        LDR     r0, [r9, #VertiDisplayEnd :SHR: 22]
	LDR	r1, [r9, #VertiDisplayStart :SHR: 22]
	BIC	r0, r0, #VertiDisplayEnd
	BIC	r1, r1, #VertiDisplayStart
	SUB	r0, r0, r1			;R0 = Vres
	ADD	r1, r1, r0, LSR #1		;R1 = Vres/2 + VDSR
	ORR	r1, r1, #VertiDisplayEnd
	STR	r1, [r9, #VertiDisplayEnd :SHR: 22]

	LDR	r1, [r9, #VertiCycle :SHR: 22]
	BIC	r1, r1, #VertiCycle
	SUB	r1, r1, r0, LSR #1
	ORR	r1, r1, #VertiCycle
	STR	r1, [r9, #VertiCycle :SHR: 22]

	LDR	r1, [r9, #VertiBorderEnd :SHR: 22]
	BIC	r1, r1, #VertiBorderEnd
	SUB	r1, r1, r0, LSR #1
	ORR	r1, r1, #VertiBorderEnd
	STR	r1, [r9, #VertiBorderEnd :SHR: 22]

	LDR	r1, [r9, #VIDCExternal :SHR: 22]
	BIC	r1, r1, #Ext_ERegExt
	ORR	r1, r1, #Ext_ERegGreen
	STR	r1, [r9, #VIDCExternal :SHR: 22]

a2054 2
	MOV	r0, #VIDC			;ACTUALLY PROGRAM VIDC (I know I shouldn't but I don't care - I've got a cold)
	STR	r2, [r0]
d2058 1
a2058 1
        MOV     r0, #LCDOffsetRegister1
d2545 1
a2545 1

d2585 1
a2585 1

d2677 1
a2677 1

d2796 1
a2796 1
        Pull    "R3,PC"
d2972 1
a2972 1
;
d2992 1
a2992 1

d3005 1
a3005 1
        BNE     %FT70
d3009 1
a3009 1

d3049 1
a3049 1

@


4.1.3.2
log
@RISC OS 3.71 version taken
@
text
@d1018 1
a1018 1
    ;    CMP     R9, #&E7
d1020 3
a1022 3
    ;    CMPEQ   R9, #&D4
    ;    MOVNE   R9, #32000              ;Morris clocks VIDC20L at 32Mhz
    ;    LDREQ   R9, =24000              ;RISC PC clocks VIDC20 at 24MHz
d1936 1
a1936 1
   ;     CMP     R1, #&E7
d1938 3
a1940 3
   ;     CMPEQ   R1, #&D4
   ;     MOVNE   R1, #32000              ;Morris clocks VIDC20L at 32Mhz
   ;     LDREQ   R1, =24000              ;RISC PC clocks VIDC20 at 24MHz
a2325 6
  [ VCOstartfix
        ;do *not* do the very slow trick - this will stall the VCO and it may not restart
        ;properly later (we don't give a fig for power consumption)
        MOVEQ   r4, #3
        MOVEQ   r5, #8                  ; after sub below, (7+1)/(3+1) so VCO runs at twice ref clock
  |
a2327 1
  ]
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d1018 1
a1018 1
    ;    CMP     R9, #&E7
d1020 3
a1022 3
    ;    CMPEQ   R9, #&D4
    ;    MOVNE   R9, #32000              ;Morris clocks VIDC20L at 32Mhz
    ;    LDREQ   R9, =24000              ;RISC PC clocks VIDC20 at 24MHz
d1936 1
a1936 1
   ;     CMP     R1, #&E7
d1938 3
a1940 3
   ;     CMPEQ   R1, #&D4
   ;     MOVNE   R1, #32000              ;Morris clocks VIDC20L at 32Mhz
   ;     LDREQ   R1, =24000              ;RISC PC clocks VIDC20 at 24MHz
a2325 6
  [ VCOstartfix
        ;do *not* do the very slow trick - this will stall the VCO and it may not restart
        ;properly later (we don't give a fig for power consumption)
        MOVEQ   r4, #3
        MOVEQ   r5, #8                  ; after sub below, (7+1)/(3+1) so VCO runs at twice ref clock
  |
a2327 1
  ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

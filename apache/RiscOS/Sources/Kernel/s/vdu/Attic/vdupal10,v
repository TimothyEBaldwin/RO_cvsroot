head	4.4;
access;
symbols
	HAL_merge:4.2.2.2
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.2
	Kernel-5_35-4_79_2_326:4.2.2.2
	Kernel-5_35-4_79_2_325:4.2.2.2
	Kernel-5_35-4_79_2_324:4.2.2.2
	Kernel-5_35-4_79_2_323:4.2.2.2
	Kernel-5_35-4_79_2_322:4.2.2.2
	Kernel-5_35-4_79_2_321:4.2.2.2
	Kernel-5_35-4_79_2_320:4.2.2.2
	Kernel-5_35-4_79_2_319:4.2.2.2
	Kernel-5_35-4_79_2_318:4.2.2.2
	Kernel-5_35-4_79_2_317:4.2.2.2
	Kernel-5_35-4_79_2_316:4.2.2.2
	Kernel-5_35-4_79_2_315:4.2.2.2
	Kernel-5_35-4_79_2_314:4.2.2.2
	Kernel-5_35-4_79_2_313:4.2.2.2
	Kernel-5_35-4_79_2_312:4.2.2.2
	Kernel-5_35-4_79_2_311:4.2.2.2
	Kernel-5_35-4_79_2_310:4.2.2.2
	Kernel-5_35-4_79_2_309:4.2.2.2
	Kernel-5_35-4_79_2_308:4.2.2.2
	Kernel-5_35-4_79_2_307:4.2.2.2
	Kernel-5_35-4_79_2_306:4.2.2.2
	Kernel-5_35-4_79_2_305:4.2.2.2
	Kernel-5_35-4_79_2_304:4.2.2.2
	Kernel-5_35-4_79_2_303:4.2.2.2
	Kernel-5_35-4_79_2_302:4.2.2.2
	Kernel-5_35-4_79_2_301:4.2.2.2
	Kernel-5_35-4_79_2_300:4.2.2.2
	Kernel-5_35-4_79_2_299:4.2.2.2
	Kernel-5_35-4_79_2_298:4.2.2.2
	Kernel-5_35-4_79_2_297:4.2.2.2
	Kernel-5_35-4_79_2_296:4.2.2.2
	Kernel-5_35-4_79_2_295:4.2.2.2
	Kernel-5_35-4_79_2_294:4.2.2.2
	Kernel-5_35-4_79_2_293:4.2.2.2
	Kernel-5_35-4_79_2_292:4.2.2.2
	Kernel-5_35-4_79_2_291:4.2.2.2
	Kernel-5_35-4_79_2_290:4.2.2.2
	Kernel-5_35-4_79_2_289:4.2.2.2
	Kernel-5_35-4_79_2_288:4.2.2.2
	Kernel-5_35-4_79_2_287:4.2.2.2
	Kernel-5_35-4_79_2_286:4.2.2.2
	Kernel-5_35-4_79_2_285:4.2.2.2
	Kernel-5_35-4_79_2_284:4.2.2.2
	Kernel-5_35-4_79_2_283:4.2.2.2
	Kernel-5_35-4_79_2_282:4.2.2.2
	Kernel-5_35-4_79_2_281:4.2.2.2
	Kernel-5_35-4_79_2_280:4.2.2.2
	Kernel-5_35-4_79_2_279:4.2.2.2
	Kernel-5_35-4_79_2_278:4.2.2.2
	Kernel-5_35-4_79_2_277:4.2.2.2
	Kernel-5_35-4_79_2_276:4.2.2.2
	Kernel-5_35-4_79_2_275:4.2.2.2
	Kernel-5_35-4_79_2_274:4.2.2.2
	Kernel-5_35-4_79_2_273:4.2.2.2
	Kernel-5_35-4_79_2_272:4.2.2.2
	Kernel-5_35-4_79_2_271:4.2.2.2
	Kernel-5_35-4_79_2_270:4.2.2.2
	Kernel-5_35-4_79_2_269:4.2.2.2
	Kernel-5_35-4_79_2_268:4.2.2.2
	Kernel-5_35-4_79_2_267:4.2.2.2
	Kernel-5_35-4_79_2_266:4.2.2.2
	Kernel-5_35-4_79_2_265:4.2.2.2
	Kernel-5_35-4_79_2_264:4.2.2.2
	Kernel-5_35-4_79_2_263:4.2.2.2
	Kernel-5_35-4_79_2_262:4.2.2.2
	Kernel-5_35-4_79_2_261:4.2.2.2
	Kernel-5_35-4_79_2_260:4.2.2.2
	Kernel-5_35-4_79_2_259:4.2.2.2
	Kernel-5_35-4_79_2_258:4.2.2.2
	Kernel-5_35-4_79_2_257:4.2.2.2
	Kernel-5_35-4_79_2_256:4.2.2.2
	Kernel-5_35-4_79_2_255:4.2.2.2
	Kernel-5_35-4_79_2_254:4.2.2.2
	Kernel-5_35-4_79_2_253:4.2.2.2
	Kernel-5_35-4_79_2_252:4.2.2.2
	Kernel-5_35-4_79_2_251:4.2.2.2
	Kernel-5_35-4_79_2_250:4.2.2.2
	Kernel-5_35-4_79_2_249:4.2.2.2
	Kernel-5_35-4_79_2_248:4.2.2.2
	Kernel-5_35-4_79_2_247:4.2.2.2
	Kernel-5_35-4_79_2_246:4.2.2.2
	Kernel-5_35-4_79_2_245:4.2.2.2
	Kernel-5_35-4_79_2_244:4.2.2.2
	Kernel-5_35-4_79_2_243:4.2.2.2
	Kernel-5_35-4_79_2_242:4.2.2.2
	Kernel-5_35-4_79_2_241:4.2.2.2
	Kernel-5_35-4_79_2_240:4.2.2.2
	Kernel-5_35-4_79_2_239:4.2.2.2
	Kernel-5_35-4_79_2_238:4.2.2.2
	Kernel-5_35-4_79_2_237:4.2.2.2
	Kernel-5_35-4_79_2_236:4.2.2.2
	Kernel-5_35-4_79_2_235:4.2.2.2
	Kernel-5_35-4_79_2_234:4.2.2.2
	Kernel-5_35-4_79_2_233:4.2.2.2
	Kernel-5_35-4_79_2_232:4.2.2.2
	Kernel-5_35-4_79_2_231:4.2.2.2
	Kernel-5_35-4_79_2_230:4.2.2.2
	Kernel-5_35-4_79_2_229:4.2.2.2
	Kernel-5_35-4_79_2_228:4.2.2.2
	Kernel-5_35-4_79_2_227:4.2.2.2
	Kernel-5_35-4_79_2_226:4.2.2.2
	Kernel-5_35-4_79_2_225:4.2.2.2
	Kernel-5_35-4_79_2_224:4.2.2.2
	Kernel-5_35-4_79_2_223:4.2.2.2
	Kernel-5_35-4_79_2_222:4.2.2.2
	Kernel-5_35-4_79_2_221:4.2.2.2
	Kernel-5_35-4_79_2_220:4.2.2.2
	Kernel-5_35-4_79_2_219:4.2.2.2
	Kernel-5_35-4_79_2_218:4.2.2.2
	Kernel-5_35-4_79_2_217:4.2.2.2
	Kernel-5_35-4_79_2_216:4.2.2.2
	Kernel-5_35-4_79_2_215:4.2.2.2
	Kernel-5_35-4_79_2_214:4.2.2.2
	Kernel-5_35-4_79_2_213:4.2.2.2
	Kernel-5_35-4_79_2_212:4.2.2.2
	Kernel-5_35-4_79_2_211:4.2.2.2
	Kernel-5_35-4_79_2_210:4.2.2.2
	Kernel-5_35-4_79_2_209:4.2.2.2
	Kernel-5_35-4_79_2_208:4.2.2.2
	Kernel-5_35-4_79_2_207:4.2.2.2
	Kernel-5_35-4_79_2_206:4.2.2.2
	Kernel-5_35-4_79_2_205:4.2.2.2
	Kernel-5_35-4_79_2_204:4.2.2.2
	Kernel-5_35-4_79_2_203:4.2.2.2
	Kernel-5_35-4_79_2_202:4.2.2.2
	Kernel-5_35-4_79_2_201:4.2.2.2
	Kernel-5_35-4_79_2_200:4.2.2.2
	Kernel-5_35-4_79_2_199:4.2.2.2
	Kernel-5_35-4_79_2_198:4.2.2.2
	Kernel-5_35-4_79_2_197:4.2.2.2
	Kernel-5_35-4_79_2_196:4.2.2.2
	Kernel-5_35-4_79_2_195:4.2.2.2
	Kernel-5_35-4_79_2_194:4.2.2.2
	Kernel-5_35-4_79_2_193:4.2.2.1
	Kernel-5_35-4_79_2_192:4.2.2.1
	Kernel-5_35-4_79_2_191:4.2.2.1
	Kernel-5_35-4_79_2_190:4.2.2.1
	Kernel-5_35-4_79_2_189:4.2.2.1
	Kernel-5_35-4_79_2_188:4.2.2.1
	Kernel-5_35-4_79_2_187:4.2.2.1
	Kernel-5_35-4_79_2_186:4.2.2.1
	Kernel-5_35-4_79_2_185:4.2.2.1
	Kernel-5_35-4_79_2_184:4.2.2.1
	Kernel-5_35-4_79_2_183:4.2.2.1
	Kernel-5_35-4_79_2_182:4.2.2.1
	Kernel-5_35-4_79_2_181:4.2.2.1
	Kernel-5_35-4_79_2_180:4.2.2.1
	Kernel-5_35-4_79_2_179:4.2.2.1
	Kernel-5_35-4_79_2_178:4.2.2.1
	Kernel-5_35-4_79_2_177:4.2.2.1
	Kernel-5_35-4_79_2_176:4.2.2.1
	Kernel-5_35-4_79_2_175:4.2.2.1
	Kernel-5_35-4_79_2_174:4.2.2.1
	Kernel-5_35-4_79_2_173:4.2.2.1
	Kernel-5_35-4_79_2_172:4.2.2.1
	Kernel-5_35-4_79_2_171:4.2.2.1
	Kernel-5_35-4_79_2_170:4.2.2.1
	Kernel-5_35-4_79_2_169:4.2.2.1
	Kernel-5_35-4_79_2_168:4.2.2.1
	Kernel-5_35-4_79_2_167:4.2.2.1
	Kernel-5_35-4_79_2_166:4.2.2.1
	Kernel-5_35-4_79_2_165:4.2.2.1
	RPi_merge:4.2.2.1
	Kernel-5_35-4_79_2_147_2_23:4.2.2.1
	Kernel-5_35-4_79_2_147_2_22:4.2.2.1
	Kernel-5_35-4_79_2_147_2_21:4.2.2.1
	Kernel-5_35-4_79_2_147_2_20:4.2.2.1
	Kernel-5_35-4_79_2_147_2_19:4.2.2.1
	Kernel-5_35-4_79_2_147_2_18:4.2.2.1
	Kernel-5_35-4_79_2_164:4.2.2.1
	Kernel-5_35-4_79_2_163:4.2.2.1
	Kernel-5_35-4_79_2_147_2_17:4.2.2.1
	Kernel-5_35-4_79_2_147_2_16:4.2.2.1
	Kernel-5_35-4_79_2_147_2_15:4.2.2.1
	Kernel-5_35-4_79_2_162:4.2.2.1
	Kernel-5_35-4_79_2_161:4.2.2.1
	Kernel-5_35-4_79_2_147_2_14:4.2.2.1
	Kernel-5_35-4_79_2_147_2_13:4.2.2.1
	Kernel-5_35-4_79_2_160:4.2.2.1
	Kernel-5_35-4_79_2_159:4.2.2.1
	Kernel-5_35-4_79_2_158:4.2.2.1
	Kernel-5_35-4_79_2_157:4.2.2.1
	Kernel-5_35-4_79_2_156:4.2.2.1
	Kernel-5_35-4_79_2_147_2_12:4.2.2.1
	Kernel-5_35-4_79_2_147_2_11:4.2.2.1
	Kernel-5_35-4_79_2_155:4.2.2.1
	Kernel-5_35-4_79_2_147_2_10:4.2.2.1
	Kernel-5_35-4_79_2_154:4.2.2.1
	Kernel-5_35-4_79_2_153:4.2.2.1
	Kernel-5_35-4_79_2_147_2_9:4.2.2.1
	Kernel-5_35-4_79_2_152:4.2.2.1
	Kernel-5_35-4_79_2_151:4.2.2.1
	Kernel-5_35-4_79_2_147_2_8:4.2.2.1
	Kernel-5_35-4_79_2_147_2_7:4.2.2.1
	Kernel-5_35-4_79_2_150:4.2.2.1
	Kernel-5_35-4_79_2_147_2_6:4.2.2.1
	Kernel-5_35-4_79_2_147_2_5:4.2.2.1
	Kernel-5_35-4_79_2_149:4.2.2.1
	Kernel-5_35-4_79_2_147_2_4:4.2.2.1
	Kernel-5_35-4_79_2_147_2_3:4.2.2.1
	Kernel-5_35-4_79_2_148:4.2.2.1
	Kernel-5_35-4_79_2_147_2_2:4.2.2.1
	Kernel-5_35-4_79_2_147_2_1:4.2.2.1
	RPi:4.2.2.1.0.6
	RPi_bp:4.2.2.1
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2.2.1
	alees_Kernel_dev:4.2.2.1.0.4
	alees_Kernel_dev_bp:4.2.2.1
	Kernel-5_35-4_79_2_147:4.2.2.1
	Kernel-5_35-4_79_2_146:4.2.2.1
	Kernel-5_35-4_79_2_145:4.2.2.1
	Kernel-5_35-4_79_2_144:4.2.2.1
	Kernel-5_35-4_79_2_143:4.2.2.1
	Kernel-5_35-4_79_2_142:4.2.2.1
	Kernel-5_35-4_79_2_141:4.2.2.1
	Kernel-5_35-4_79_2_140:4.2.2.1
	Kernel-5_35-4_79_2_139:4.2.2.1
	Kernel-5_35-4_79_2_138:4.2.2.1
	Kernel-5_35-4_79_2_137:4.2.2.1
	Kernel-5_35-4_79_2_136:4.2.2.1
	Kernel-5_35-4_79_2_135:4.2.2.1
	Kernel-5_35-4_79_2_134:4.2.2.1
	Kernel-5_35-4_79_2_133:4.2.2.1
	Kernel-5_35-4_79_2_132:4.2.2.1
	Kernel-5_35-4_79_2_131:4.2.2.1
	Kernel-5_35-4_79_2_130:4.2.2.1
	Kernel-5_35-4_79_2_129:4.2.2.1
	Kernel-5_35-4_79_2_128:4.2.2.1
	Kernel-5_35-4_79_2_127:4.2.2.1
	Kernel-5_35-4_79_2_126:4.2.2.1
	Kernel-5_35-4_79_2_125:4.2.2.1
	Kernel-5_35-4_79_2_124:4.2.2.1
	Kernel-5_35-4_79_2_123:4.2.2.1
	Cortex_merge:4.2.2.1
	Kernel-5_35-4_79_2_122:4.2.2.1
	Kernel-5_35-4_79_2_98_2_54:4.2.2.1
	Kernel-5_35-4_79_2_98_2_53:4.2.2.1
	Kernel-5_35-4_79_2_98_2_52:4.2.2.1
	Kernel-5_35-4_79_2_98_2_51:4.2.2.1
	Kernel-5_35-4_79_2_98_2_50:4.2.2.1
	Kernel-5_35-4_79_2_98_2_49:4.2.2.1
	Kernel-5_35-4_79_2_98_2_48:4.2.2.1
	Kernel-5_35-4_79_2_121:4.2.2.1
	Kernel-5_35-4_79_2_98_2_47:4.2.2.1
	Kernel-5_35-4_79_2_120:4.2.2.1
	Kernel-5_35-4_79_2_98_2_46:4.2.2.1
	Kernel-5_35-4_79_2_119:4.2.2.1
	Kernel-5_35-4_79_2_98_2_45:4.2.2.1
	Kernel-5_35-4_79_2_98_2_44:4.2.2.1
	Kernel-5_35-4_79_2_118:4.2.2.1
	Kernel-5_35-4_79_2_98_2_43:4.2.2.1
	Kernel-5_35-4_79_2_117:4.2.2.1
	Kernel-5_35-4_79_2_116:4.2.2.1
	Kernel-5_35-4_79_2_98_2_42:4.2.2.1
	Kernel-5_35-4_79_2_115:4.2.2.1
	Kernel-5_35-4_79_2_98_2_41:4.2.2.1
	Kernel-5_35-4_79_2_98_2_40:4.2.2.1
	Kernel-5_35-4_79_2_114:4.2.2.1
	Kernel-5_35-4_79_2_98_2_39:4.2.2.1
	Kernel-5_35-4_79_2_98_2_38:4.2.2.1
	Kernel-5_35-4_79_2_113:4.2.2.1
	Kernel-5_35-4_79_2_112:4.2.2.1
	Kernel-5_35-4_79_2_98_2_37:4.2.2.1
	Kernel-5_35-4_79_2_98_2_36:4.2.2.1
	Kernel-5_35-4_79_2_98_2_35:4.2.2.1
	Kernel-5_35-4_79_2_98_2_34:4.2.2.1
	Kernel-5_35-4_79_2_98_2_33:4.2.2.1
	Kernel-5_35-4_79_2_98_2_32:4.2.2.1
	Kernel-5_35-4_79_2_98_2_31:4.2.2.1
	Kernel-5_35-4_79_2_98_2_30:4.2.2.1
	Kernel-5_35-4_79_2_98_2_29:4.2.2.1
	Kernel-5_35-4_79_2_98_2_28:4.2.2.1
	Kernel-5_35-4_79_2_98_2_27:4.2.2.1
	Kernel-5_35-4_79_2_98_2_26:4.2.2.1
	Kernel-5_35-4_79_2_111:4.2.2.1
	Kernel-5_35-4_79_2_98_2_25:4.2.2.1
	Kernel-5_35-4_79_2_98_2_24:4.2.2.1
	Kernel-5_35-4_79_2_98_2_23:4.2.2.1
	Kernel-5_35-4_79_2_110:4.2.2.1
	Kernel-5_35-4_79_2_98_2_22:4.2.2.1
	Kernel-5_35-4_79_2_109:4.2.2.1
	Kernel-5_35-4_79_2_98_2_21:4.2.2.1
	Kernel-5_35-4_79_2_98_2_20:4.2.2.1
	Kernel-5_35-4_79_2_108:4.2.2.1
	Kernel-5_35-4_79_2_107:4.2.2.1
	Kernel-5_35-4_79_2_98_2_19:4.2.2.1
	Kernel-5_35-4_79_2_98_2_18:4.2.2.1
	Kernel-5_35-4_79_2_98_2_17:4.2.2.1
	Kernel-5_35-4_79_2_98_2_16:4.2.2.1
	Kernel-5_35-4_79_2_98_2_15:4.2.2.1
	Kernel-5_35-4_79_2_106:4.2.2.1
	Kernel-5_35-4_79_2_105:4.2.2.1
	Kernel-5_35-4_79_2_104:4.2.2.1
	Kernel-5_35-4_79_2_98_2_14:4.2.2.1
	Kernel-5_35-4_79_2_98_2_13:4.2.2.1
	Kernel-5_35-4_79_2_98_2_12:4.2.2.1
	Kernel-5_35-4_79_2_98_2_11:4.2.2.1
	Kernel-5_35-4_79_2_98_2_10:4.2.2.1
	Kernel-5_35-4_79_2_98_2_9:4.2.2.1
	Kernel-5_35-4_79_2_103:4.2.2.1
	Kernel-5_35-4_79_2_102:4.2.2.1
	Kernel-5_35-4_79_2_98_2_8:4.2.2.1
	Kernel-5_35-4_79_2_98_2_7:4.2.2.1
	Kernel-5_35-4_79_2_98_2_6:4.2.2.1
	Kernel-5_35-4_79_2_98_2_5:4.2.2.1
	Kernel-5_35-4_79_2_98_2_4:4.2.2.1
	Kernel-5_35-4_79_2_101:4.2.2.1
	Kernel-5_35-4_79_2_100:4.2.2.1
	Kernel-5_35-4_79_2_99:4.2.2.1
	Kernel-5_35-4_79_2_98_2_3:4.2.2.1
	Kernel-5_35-4_79_2_98_2_2:4.2.2.1
	Kernel-5_35-4_79_2_98_2_1:4.2.2.1
	Cortex:4.2.2.1.0.2
	Cortex_bp:4.2.2.1
	Kernel-5_35-4_79_2_98:4.2.2.1
	Kernel-5_35-4_79_2_97:4.2.2.1
	Kernel-5_35-4_79_2_96:4.2.2.1
	Kernel-5_35-4_79_2_95:4.2.2.1
	Kernel-5_35-4_79_2_94:4.2.2.1
	Kernel-5_35-4_79_2_93:4.2.2.1
	Kernel-5_35-4_79_2_92:4.2.2.1
	Kernel-5_35-4_79_2_91:4.2.2.1
	Kernel-5_35-4_79_2_90:4.2.2.1
	Kernel-5_35-4_79_2_89:4.2.2.1
	Kernel-5_35-4_79_2_88:4.2.2.1
	Kernel-5_35-4_79_2_87:4.2.2.1
	Kernel-5_35-4_79_2_86:4.2.2.1
	Kernel-5_35-4_79_2_85:4.2.2.1
	Kernel-5_35-4_79_2_84:4.2.2.1
	Kernel-5_35-4_79_2_83:4.2.2.1
	Kernel-5_35-4_79_2_82:4.2.2.1
	Kernel-5_35-4_79_2_81:4.2.2.1
	Kernel-5_35-4_79_2_80:4.2.2.1
	Kernel-5_35-4_79_2_79:4.2.2.1
	Kernel-5_35-4_79_2_78:4.2.2.1
	Kernel-5_35-4_79_2_77:4.2.2.1
	RO_5_07:4.2.2.1
	Kernel-5_35-4_79_2_76:4.2.2.1
	Kernel-5_35-4_79_2_75:4.2.2.1
	Kernel-5_35-4_79_2_74:4.2.2.1
	Kernel-5_35-4_79_2_73:4.2.2.1
	Kernel-5_35-4_79_2_72:4.2.2.1
	Kernel-5_35-4_79_2_71:4.2.2.1
	Kernel-5_35-4_79_2_70:4.2.2.1
	Kernel-5_35-4_79_2_69:4.2.2.1
	Kernel-5_35-4_79_2_68:4.2.2.1
	Kernel-5_35-4_79_2_67:4.2.2.1
	Kernel-5_35-4_79_2_66:4.2.2.1
	Kernel-5_35-4_79_2_65:4.2.2.1
	Kernel-5_35-4_79_2_64:4.2.2.1
	Kernel-5_35-4_79_2_63:4.2.2.1
	Kernel-5_35-4_79_2_62:4.2.2.1
	Kernel-5_35-4_79_2_61:4.2.2.1
	Kernel-5_35-4_79_2_59:4.2.2.1
	Kernel-5_35-4_79_2_58:4.2.2.1
	Kernel-5_35-4_79_2_57:4.2.2.1
	Kernel-5_35-4_79_2_56:4.2.2.1
	Kernel-5_35-4_79_2_55:4.2.2.1
	Kernel-5_35-4_79_2_54:4.2.2.1
	Kernel-5_35-4_79_2_53:4.2.2.1
	Kernel-5_35-4_79_2_52:4.2.2.1
	Kernel-5_35-4_79_2_51:4.2.2.1
	Kernel-5_35-4_79_2_50:4.2.2.1
	Kernel-5_35-4_79_2_49:4.2.2.1
	Kernel-5_35-4_79_2_48:4.2.2.1
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.4
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2.2.1
	Kernel-5_35-4_79_2_46:4.2.2.1
	Kernel-5_35-4_79_2_45:4.2.2.1
	Kernel-5_35-4_79_2_44:4.2.2.1
	Kernel-5_35-4_79_2_25_2_2:4.2.2.1
	Kernel-5_35-4_79_2_43:4.2.2.1
	Kernel-5_35-4_79_2_42:4.2.2.1
	Kernel-5_35-4_79_2_41:4.2.2.1
	Kernel-5_35-4_79_2_40:4.2.2.1
	Kernel-5_35-4_79_2_39:4.2.2.1
	Kernel-5_35-4_79_2_38:4.2.2.1
	Kernel-5_35-4_79_2_37:4.2.2.1
	Kernel-5_35-4_79_2_36:4.2.2.1
	Kernel-5_35-4_79_2_35:4.2.2.1
	Kernel-5_35-4_79_2_34:4.2.2.1
	Kernel-5_35-4_79_2_33:4.2.2.1
	Kernel-5_35-4_79_2_32:4.2.2.1
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2.2.1
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2.2.1
	Kernel-5_35-4_79_2_30:4.2.2.1
	Kernel-5_35-4_79_2_29:4.2.2.1
	Kernel-5_35-4_79_2_28:4.2.2.1
	Kernel-5_35-4_79_2_27:4.2.2.1
	Kernel-5_35-4_79_2_26:4.2.2.1
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2.2.1
	Kernel-5_35-4_79_2_24:4.2.2.1
	Kernel-5_35-4_79_2_23:4.2.2.1
	Kernel-5_35-4_79_2_22:4.2.2.1
	Kernel-5_35-4_79_2_21:4.2.2.1
	Kernel-5_35-4_79_2_20:4.2.2.1
	Kernel-5_35-4_79_2_19:4.2.2.1
	Kernel-5_35-4_79_2_18:4.2.2.1
	Kernel-5_35-4_79_2_17:4.2.2.1
	Kernel-5_35-4_79_2_16:4.2.2.1
	Kernel-5_35-4_79_2_15:4.2.2.1
	Kernel-5_35-4_79_2_14:4.2.2.1
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2.2.1
	Kernel-5_35-4_79_2_12:4.2.2.1
	Kernel-5_35-4_79_2_11:4.2.2.1
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2.2.1
	Kernel-5_35-4_79_2_9:4.2.2.1
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2.2.1
	Kernel-5_35-4_79_2_7:4.2.2.1
	Kernel-5_35-4_79_2_6:4.2.2.1
	Kernel-5_35-4_79_2_5:4.2.2.1
	Kernel-5_35-4_79_2_4:4.2.2.1
	Kernel-5_35-4_79_2_3:4.2.2.1
	Kernel-5_35-4_79_2_2:4.2
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	Kernel-4_84:4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	afrost_Boca-1_2-Beta:4.1.7.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2016.06.30.20.29.05;	author jlee;	state dead;
branches;
next	4.3;
commitid	lMnWzoE9eJz3Wwcz;

4.3
date	2016.06.30.20.08.20;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.04.04.14.27.42;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.40;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.10.03.12.05.59;	author mstephen;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2013.08.06.22.43.10;	author jlee;	state Exp;
branches;
next	;
commitid	TOIaeUf2Q4rBIr0x;

4.1.1.1
date	96.11.05.09.41.40;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.38;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.49;	author mstphens;	state dead;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.26;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.52;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > VduPal10

; mjs - not used any more (it's pre-Medusa, for goodness sake)

; Palette programming for VIDC10 (ie VIDC1 or VIDC1a)

; *****************************************************************************

; PaletteV handler
; ----------------

; *****************************************************************************
;
;       MOSPaletteV - Default owner of PaletteV
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6

MOSPaletteV ROUT
        CMP     r4, #1
        MOVCC   pc, lr
        BEQ     PV_ReadPalette
        CMP     r4, #3
        BCC     PV_SetPalette
        BEQ     PV_1stFlashState
        CMP     r4, #5
        BCC     PV_2ndFlashState
        BEQ     PV_SetDefaultPalette
        CMP     r4, #7
        BCC     PV_BlankScreen
        MOV     pc, lr                  ; reason code not known, so pass it on

; *****************************************************************************

PV_SetDefaultPalette ROUT
        Push    "r0-r3,r5-r9"
        LDR     r0, [WsPtr, #PalIndex]  ; the new index 0-5
        ADR     r1, paldptab
        LDR     r2, [r1, r0, LSL #2]    ; offset from r1 to start of table
        ADD     r0, r0, #1              ; point to next item
        LDR     r5, [r1, r0, LSL #2]    ; offset from r1 to end of table +1
        ADD     r2, r2, r1              ; r2 -> start of table
        ADD     r5, r5, r1              ; r5 -> end of table
        MOV     r0, #0                  ; start at palette index 0
        MOV     r1, #3                  ; set both halves
10
        LDR     r6, [r2], #4
        MOVS    r3, r6, LSL #17         ; get 1st half word and set carry if flashing
        MOV     r3, r3, LSR #17
        MOVCC   r4, #0
        LDRCS   r4, =&FFF               ; flashing so invert 2nd half RGB
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        MOVS    r3, r6, LSL #1          ; get 2nd half word and set carry if flashing
        MOV     r3, r3, LSR #17
        MOVCC   r4, #0
        LDRCS   r4, =&FFF
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        TEQ     r2, r5
        BNE     %BT10

; now ensure all palette entries from 0..15 are initialised

        MOV     r3, #0                  ; set unused (and border) to black
        MOV     r4, #0                  ; no flashing
20
        CMP     r0, #16
        BHS     %FT25
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        B       %BT20

25      MOV     r2, #0                  ; Set border to black (sup 0)
        BL      BorderInitEntry

        MOV     r4, #0                  ; indicate PaletteV operation complete
        Pull    "r0-r3,r5-r9,pc"        ; restore registers and claim vector

        LTORG

; *****************************************************************************

; Table of offsets from paldata_pointer to palette data

paldptab
        &       paldat1-paldptab        ; 2  Colour Modes
        &       paldat2-paldptab        ; 4
        &       paldat4-paldptab        ; 16
        &       paldat8-paldptab        ; 256
        &       paldatT-paldptab        ; teletext mode
        &       paldatHR-paldptab       ; Hi-res mono mode
        &       paldatend-paldptab      ; end of table marker

paldat1 ; Data for 1 bit modes - only necessary to program registers 0 and 1

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &0FFF           ; 1  White

paldat2 ; Data for 2 bit modes - only necessary to program registers 0..3

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &000F           ; 1  Red
        DCW     &00FF           ; 2  Yellow
        DCW     &0FFF           ; 3  White

paldat4 ; Data for 4 bit modes - program all registers
        ; Flashing Colours will be needed here

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &000F           ; 1  Red
        DCW     &00F0           ; 2  Green
        DCW     &00FF           ; 3  Yellow
        DCW     &0F00           ; 4  Blue
        DCW     &0F0F           ; 5  Magenta
        DCW     &0FF0           ; 6  Cyan
        DCW     &0FFF           ; 7  White
        DCW     &8000           ; 8  Flashing Black
        DCW     &800F           ; 9  Flashing Red
        DCW     &80F0           ; 10 Flashing Green
        DCW     &80FF           ; 11 Flashing Yellow
        DCW     &8F00           ; 12 Flashing Blue
        DCW     &8F0F           ; 13 Flashing Magenta
        DCW     &8FF0           ; 14 Flashing Cyan
        DCW     &8FFF           ; 15 Flashing White

paldat8 ; Data for 8 bit modes - Program all registers
        ; PP field is 16 for all these, cos not true BBC colours

;               FSBGR

        DCW     &0000           ; 0
        DCW     &0111           ; 1
        DCW     &0222           ; 2
        DCW     &0333           ; 3
        DCW     &0004           ; 4
        DCW     &0115           ; 5
        DCW     &0226           ; 6
        DCW     &0337           ; 7
        DCW     &0400           ; 8
        DCW     &0511           ; 9
        DCW     &0622           ; A
        DCW     &0733           ; B
        DCW     &0404           ; C
        DCW     &0515           ; D
        DCW     &0626           ; E
        DCW     &0737           ; F

paldatT ; Data for teletext mode

        DCW     &0000           ; 0 Black
        DCW     &000F           ; 1 Red
        DCW     &00F0           ; 2 Green
        DCW     &00FF           ; 3 Yellow
        DCW     &0F00           ; 4 Blue
        DCW     &0F0F           ; 5 Magenta
        DCW     &0FF0           ; 6 Cyan
        DCW     &0FFF           ; 7 White

; Colours 8 to 15 have supremacy bit set

        DCW     &1000           ; 8 Supremacy+ Black
        DCW     &100F           ; 9            Red
        DCW     &10F0           ; 10           Green
        DCW     &10FF           ; 11           Yellow
        DCW     &1F00           ; 12           Blue
        DCW     &1F0F           ; 13           Magenta
        DCW     &1FF0           ; 14           Cyan
        DCW     &1FFF           ; 15           White

paldatHR  ; data for Hi-res mono mode
        DCW     &0000           ; Only red gun necessary
        DCW     &0111           ; but setting all three makes
        DCW     &0222           ; reading it more natural
        DCW     &0333
        DCW     &0444
        DCW     &0555
        DCW     &0666
        DCW     &0777
        DCW     &0888
        DCW     &0999
        DCW     &0AAA
        DCW     &0BBB
        DCW     &0CCC
        DCW     &0DDD
        DCW     &0EEE
        DCW     &0FFF

        DCW     &0000           ; border black
        DCW     &0010           ; fixed pointer colours
        DCW     &0020
        DCW     &0030
paldatend


; *****************************************************************************

; PaletteV call to set palette
; in:   R0 = logical colour
;       R1 = colour type (16,17,18,24,25)
;       R2 = BBGGRRS0
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on
;

PV_SetPalette ROUT
        Push    "r0-r3"
        TEQ     r1, #16                 ; if 16 then set both colours
        MOVEQ   r1, #3
        BEQ     UpdateNormalColour

        TEQ     r1, #17                 ; elif 17 then set 1st colour
        MOVEQ   r1, #1
        BEQ     UpdateNormalColour

        TEQ     r1, #18                 ; elif 18 then set 2nd colour
        MOVEQ   r1, #2
        BEQ     UpdateNormalColour

        TEQ     r1, #24                 ; elif 24 then border colour
        BEQ     BorderColour

        TEQ     r1, #25                 ; elif 25 then pointer colour
        BEQ     PointerColour

        Pull    "r0-r3"
        MOV     pc, lr                  ; else not defined

; *****************************************************************************

UpdateNormalColour ROUT
        LDR     lr, [WsPtr, #DisplayNColour] ; get the mask
        AND     r0, r0, lr              ; and mask it off
        AND     r0, r0, #15             ; maximum 15
        BL      UpdateSettingAndVIDC
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "r0-r3, pc"

BorderInitEntry ENTRY "r0-r3"           ; entry used in default palette setting
BorderColour ROUT
        LDR     r0, [WsPtr, #PalIndex]  ; if hi res mono
        TEQ     r0, #5
        BICEQ   r2, r2, #&00300000      ; then knock out bits 0,1 of green palette

        MOV     r0, #16                 ; palette index for border colour
        MOV     r1, #3                  ; both colours
        BL      UpdateSettingAndVIDC

; Now test for BBC gap mode (ie 3 or 6)
; if so then set colour 2 to same as border, and colour 3 to inverse

        LDR     lr, [WsPtr, #DisplayModeFlags]
        TST     lr, #ModeFlag_BBCGapMode
        BEQ     %FT10

        MOV     r0, #2                  ; make colour 2 (gap) same as border
        BL      UpdateSettingAndVIDC

        MOV     r0, #3                  ; make colour 3 inverse gap
        MVN     r2, r2                  ; invert R, G and B
        EOR     r2, r2, #&FF            ; but use same supremacy
        BL      UpdateSettingAndVIDC
10
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "r0-r3, pc"


PointerColour ROUT
        LDR     r1, [WsPtr, #PalIndex]  ; if hi res mono, then don't allow
        TEQ     r1, #5                  ; pointer palette changes
        ANDNES  r0, r0, #3              ; force pointer colour number in range 1..3
        BEQ     %FT10                   ; zero is invalid
        ADD     r0, r0, #16             ; form palette index 17..19
        MOV     r1, #3
        BL      UpdateSettingAndVIDC
10
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "r0-r3,pc"

UpdateSettingAndVIDC ROUT
        AND     r4, r2, #&F0000000
        MOV     r3, r4, LSR #(28-8)     ; move blue to bits 8..11
        AND     r4, r2, #&00F00000
        ORR     r3, r3, r4, LSR #(20-4) ; move green to bits 4..7
        AND     r4, r2, #&0000F000
        ORR     r3, r3, r4, LSR #(12-0) ; move red to bits 0..3
        AND     r4, r2, #&00000080
        ORR     r3, r3, r4, LSL #(12-7) ; move sup to bit 12

        CMP     r0, #16                 ; if not normal colour
        BCS     %FT10                   ; then OK for hi-res-mono
        LDR     r4, [WsPtr, #PalIndex]
        TEQ     r4, #5
        BEQ     UpdateHiResRGB
10
        MOV     r4, #0                  ; indicate no EORing between parts

; and drop thru to ...

UpdateSettingStraightRGB ENTRY "r2,r5,r6"
        PHPSEI                          ; protect against IRQs
        ORR     r3, r3, r0, LSL #26     ; form VIDC register number at top
        LDRB    r5, [WsPtr, #ScreenBlankFlag]
        TEQ     r5, #0
        MOVNE   r5, #&00FFFFFF          ; bits to knock out if blanked

        LDROSB  r2, FlashState          ; 0 => second, 1 => first
        CMP     r2, #1                  ; C=0 => second, C=1 => first

        TST     r1, #1
        BEQ     %FT10                   ; skip if not setting 1st colour
        ADD     r2, WsPtr, #FirPalSetting
        STR     r3, [r2, r0, LSL #2]
        MOVCS   r2, #VIDC
        BICCS   r6, r3, r5              ; knock out bits for blanking
        STRCS   r6, [r2]                ; poke VIDC if setting 1st colour and in 1st state
10
        TST     r1, #2
        BEQ     %FT20                   ; skip if not setting 2nd colour
        ADD     r2, WsPtr, #SecPalSetting
        EOR     r3, r3, r4              ; toggle requested bits for 2nd half
        STR     r3, [r2, r0, LSL #2]
        MOVCC   r2, #VIDC
        BICCC   r6, r3, r5              ; knock out bits for blanking
        STRCC   r6, [r2]                ; poke VIDC if setting 2nd colour and in 2nd state
20
        PLP
        EXIT                            ; restore registers, claim vector

; *****************************************************************************
;
;       UpdateHiResRGB - Routine to program normal palette for Hi-Res-Mono display
;
; in:   r0 = logical colour
;       r1 = mask of which states to update (bit 0 = 1st flash state, bit 1 = 2nd)
;       r3 = &0000SBGR
;
; out:  r3, r4 may be corrupted
;

UpdateHiResRGB ENTRY "r5"
        PHPSEI
        Push    "lr"
        LDROSB  r5, FlashState
        TEQ     r5, #0                  ; 0 => 2nd state, 1 => 1st state
        MOVNE   r5, #VIDC               ; 1st state => r5 = VIDC, else = 0

        TST     r1, #1
        ADDNE   r4, WsPtr, #FirPalSetting
        BLNE    UpdateOneHiResSetting

        EOR     r5, r5, #VIDC           ; 2nd state => r5 = VIDC, else = 0
        TST     r1, #2
        ADDNE   r4, WsPtr, #SecPalSetting
        BLNE    UpdateOneHiResSetting
        Pull    "lr"
        PLP
        EXIT

UpdateOneHiResSetting ENTRY "r1,r2,r6-r9"
        LDRB    lr, [WsPtr, #ScreenBlankFlag]
        TEQ     lr, #0
        MOVNE   lr, #&00FFFFFF          ; if blanked, mask off these bits

        LDR     r2, =&FFF
        TEQ     r0, #0
        MOVEQ   r1, r3                  ; if programming colour 0 then 1st colour is r3
        LDREQ   r6, [r4, #15*4]         ; and 2nd colour is what's in colour 15
        LDRNE   r1, [r4, #0*4]          ; else 1st colour is what's in colour 0
        MOVNE   r6, r3                  ; and 2nd colour is r3

        EOR     r6, r6, #&008           ; invert bit R3 of colour 15
        EOR     r6, r6, r1              ; inverted EOR of colours 0 and 15
        ANDS    r6, r6, #&008           ; just use R3 for black/white
        MOVNE   r6, r2                  ; if non-zero make BIC mask full RGB else 0
        ANDS    r1, r1, #&008           ; if colour 0 = white then make EOR mask full RGB else 0
        MOVNE   r1, r2

        ADD     r7, r4, #16*4           ; end of table
        MOV     r8, #0                  ; start
        LDR     r2, =&04000111          ; amount to add on each time round

10
        BIC     r9, r8, r6              ; take value and knock out BIC mask
        EOR     r9, r9, r1              ; then toggle EOR mask
        STR     r9, [r4], #4            ; store in soft copy
        TEQ     r5, #0                  ; if updating VIDC
        BICNE   r9, r9, lr              ; knock out bits (for blanking)
        STRNE   r9, [r5]                ; then do it
        ADD     r8, r8, r2              ; move on to next value
        TEQ     r4, r7                  ; if not done all 16 entries
        BNE     %BT10                   ; then loop

        EXIT

        LTORG

; *****************************************************************************
;
;       PV_ReadPalette - PaletteV read palette handler
;
; in:   R0 = logical colour
;       R1 = 16 (read normal colour)
;            24 (read border colour)
;            25 (read cursor colour)
;
; out:  R2 = first flash setting   (BBGGRRS0), supremacy bit 7
;       R3 = second flash setting  (BBGGRRS0), supremacy bit 7
;

PV_ReadPalette ROUT
        Push    "r10,r11"
        LDR     r10, [WsPtr, #DisplayNColour] ; logical colours in this mode -1
        TEQ     r1, #24                 ; is it reading border palette
        MOVEQ   r11, #16                ; then set up border index
        BEQ     %FT10                   ; and go

        TEQ     r1, #25                 ; is it reading pointer palette
        BEQ     %FT05
        AND     r11, r0, r10            ; no, then force into suitable range
        AND     r11, r11, #15           ; only allow 0..15
        LDR     r2, [WsPtr, #PalIndex]
        TEQ     r2, #5                  ; if hi res mono
        TEQEQ   r11, #1                 ; and reading colour 1
        MOVEQ   r11, #15                ; then read colour 15 instead
        B       %FT10                   ; always skip
05
        ANDS    r11, r0, #3             ; else force logical colour 0..3
        BEQ     %FT99                   ; and 0 is illegal, so do nothing
        ADD     r11, r11, #16           ; set up correct index
10
        CMP     r11, #16                ; is it normal one (not border/cursor)
        MOVCSS  r3, #0                  ; no, then don't fudge colours; Z=1
                                        ; (carry preserved from CMP)
        ANDCCS  r3, r10, #&F0           ; yes, then fudge if 256 colour mode

        ADD     r10, WsPtr, #FirPalSetting

        LDR     r11, [r10, r11, LSL #2]! ; r11 := 1st XX00SBGR
        BLNE    FudgeRGB

        AND     lr, r11, #&F00          ; lr  := 1st 00000B00
        MOV     r2, lr, LSL #20         ; r2  := 1st B0000000
        AND     lr, r11, #&0F0          ; lr  := 1st 000000G0
        ORR     r2, r2, lr, LSL #16     ; r2  := 1st B0G00000
        AND     lr, r11, #&00F          ; lr  := 1st 0000000R
        ORR     r2, r2, lr, LSL #12     ; r2  := 1st B0G0R000
        ORR     r2, r2, r2, LSR #4      ; r2  := 1st BBGGRR00
        AND     lr, r11, #&1000
        ORR     r2, r2, lr, LSR #5      ; r2  := 1st BBGGRRS0

        LDR     r11, [r10, #SecPalSetting-FirPalSetting]
        BLNE    FudgeRGB

        AND     lr, r11, #&F00          ; lr  := 2nd 00000B00
        MOV     r3, lr, LSL #20         ; r3  := 2nd B0000000
        AND     lr, r11, #&0F0          ; lr  := 2nd 000000G0
        ORR     r3, r3, lr, LSL #16     ; r3  := 2nd B0G00000
        AND     lr, r11, #&00F          ; lr  := 2nd 0000000R
        ORR     r3, r3, lr, LSL #12     ; r3  := 2nd B0G0R000
        ORR     r3, r3, r3, LSR #4      ; r3  := 2nd BBGGRR00
        AND     lr, r11, #&1000
        ORR     r3, r3, lr, LSR #5      ; r3  := 2nd BBGGRRS0
99
        MOV     r4, #0
        Pull    "r10, r11, pc"

FudgeRGB ROUT
 [ No26bitCode
        mrs    ,r4, CPSR
 ]
        BIC     r11, r11, #&C8          ; knock out top bit R, top 2 bits G
        BIC     r11, r11, #&800         ; knock out top bit B

        TST     r0, #&10                ; override top bit of red
        ORRNE   r11, r11, #&8
        TST     r0, #&20                ; override next to top bit of green
        ORRNE   r11, r11, #&40
        TST     r0, #&40                ; override top bit of green
        ORRNE   r11, r11, #&80
        TST     r0, #&80                ; override top bit of blue
        ORRNE   r11, r11, #&800
 [ No26bitCode
        msr    ,CPSR_f, r4
 |
        MOVS    pc, lr
 ]

; *****************************************************************************
;
;       PV_1stFlashState - PaletteV routine to set first flash state
;

PV_1stFlashState ROUT
        Push    "r0-r3"
        ADD     r0, WsPtr, #FirPalSetting
DoR0Flash
        MOV     r1, #15                 ; logical colour
DoAllUpdate
        LDRB    lr, [WsPtr, #ScreenBlankFlag]
        TEQ     lr, #0
        MOVEQ   lr, #&FF000000          ; unblanked, just knock off top 8 bits
        MOVNE   lr, #&FFFFFFFF          ; blanked, knock off all bits!
        MOV     r2, #VIDC
10
        LDR     r3, [r0, r1, LSL #2]
        BIC     r3, r3, lr              ; get rid of top bits, or all if blanked
        ORR     r3, r3, r1, LSL #26     ; OR in register number
        STR     r3, [r2]                ; program VidC
        SUBS    r1, r1, #1
        BPL     %BT10

        MOV     r4, #0
        Pull    "r0-r3, pc"

; *****************************************************************************
;
;       PV_2ndFlashState - PaletteV routine to set second flash state
;

PV_2ndFlashState ROUT
        Push    "r0-r3"
        ADD     r0, WsPtr, #SecPalSetting
        B       DoR0Flash

; *****************************************************************************
;
;       UpdateAllPalette - Update all VIDC palette entries
;

UpdateAllPalette ENTRY "r0-r3"          ; "r0-r3,lr" stacked ready to branch to code
        LDROSB  r0, FlashState
        CMP     r0, #1
        ADDCS   r0, WsPtr, #FirPalSetting ; FlashState = 1 => 1st state, 0 => 2nd state
        ADDCC   r0, WsPtr, #SecPalSetting
        MOV     r1, #19                 ; do 0-15 and border + 3 pointer
        B       DoAllUpdate

; *****************************************************************************
;
;       PV_BlankScreen - Blank/unblank screen
;
; in:   R0 = -1 => read blank state
;       R0 = 0 => unblank screen
;       R0 = 1 => blank screen
;
; out:  R0 = old state (0=unblanked, 1=blanked)
;       R4 = 0

PV_BlankScreen ROUT
        Push    "r1-r3"
        LDRB    r3, [WsPtr, #ScreenBlankFlag]
        CMP     r0, #1
        BHI     %FT99

        TEQ     r0, r3                  ; changing to same state? (carry preserved)
        BEQ     %FT99                   ; if so, do nothing

        STRB    r0, [WsPtr, #ScreenBlankFlag] ; update new state

        MOVCC   r0, #(1 :SHL: 10) :OR: (0 :SHL: 8) ; unblank: video DMA on, no refresh
        MOVCS   r0, #(0 :SHL: 10) :OR: (3 :SHL: 8) ; blank:   video DMA off, continuous refresh
        MOV     r1, #(1 :SHL: 10) :OR: (3 :SHL: 8) ; bits to modify
        SWI     XOS_UpdateMEMC

        PHPSEI  r0, lr                  ; disable IRQs so we don't get a flash in the middle
        BL      UpdateAllPalette        ; update all palette, including border + pointer
        PLP     r0                      ; restore old IRQ state
99
        MOV     r0, r3
        MOV     r4, #0
        Pull    "r1-r3, pc"


        END
@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d17 2
d281 1
a281 1
        TST     lr, #Flag_BBCGapMode
@


4.2.2.1
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@a16 2
; mjs - not used any more (it's pre-Medusa, for goodness sake)

@


4.2.2.2
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d281 1
a281 1
        TST     lr, #ModeFlag_BBCGapMode
@


4.1
log
@Initial revision
@
text
@d39 1
a39 1
        MOVCCS  pc, lr
d49 1
a49 1
        MOVS    pc, lr                  ; reason code not known, so pass it on
d87 4
a90 3
        BLCC    UpdateSettingStraightRGB
        ADDCC   r0, r0, #1
        BCC     %BT20
d92 1
a92 1
        MOV     r2, #0                  ; Set border to black (sup 0)
d199 13
a211 13
        DCW     &0333 
        DCW     &0444 
        DCW     &0555 
        DCW     &0666 
        DCW     &0777 
        DCW     &0888 
        DCW     &0999 
        DCW     &0AAA 
        DCW     &0BBB 
        DCW     &0CCC 
        DCW     &0DDD 
        DCW     &0EEE 
        DCW     &0FFF 
d253 1
a253 1
        MOVS    pc, lr                  ; else not defined
d305 1
a305 1
        
d354 1
a354 1
        EXITS                           ; restore registers, claim vector
d384 1
a384 1
        EXITS
d406 1
a406 1
        MOV     r8, #0                  ; start 
d408 1
a408 1
        
d420 1
a420 1
        EXITS
d495 3
d509 3
d513 1
d592 1
a592 3
        MOV     r0, pc
        ORR     lr, r0, #I_bit          ; disable IRQs so we don't get a flash in the middle
        TEQP    lr, #0
d594 1
a594 1
        TEQP    r0, #0                  ; restore old IRQ state
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

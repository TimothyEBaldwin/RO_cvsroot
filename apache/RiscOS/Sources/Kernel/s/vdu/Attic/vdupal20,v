head	4.8;
access;
symbols
	HAL_merge:4.6.2.3
	Kernel-5_48:4.7
	Kernel-5_35-4_79_2_327:4.6.2.3
	Kernel-5_35-4_79_2_326:4.6.2.3
	Kernel-5_35-4_79_2_325:4.6.2.3
	Kernel-5_35-4_79_2_324:4.6.2.3
	Kernel-5_35-4_79_2_323:4.6.2.3
	Kernel-5_35-4_79_2_322:4.6.2.3
	Kernel-5_35-4_79_2_321:4.6.2.3
	Kernel-5_35-4_79_2_320:4.6.2.3
	Kernel-5_35-4_79_2_319:4.6.2.3
	Kernel-5_35-4_79_2_318:4.6.2.3
	Kernel-5_35-4_79_2_317:4.6.2.3
	Kernel-5_35-4_79_2_316:4.6.2.3
	Kernel-5_35-4_79_2_315:4.6.2.3
	Kernel-5_35-4_79_2_314:4.6.2.3
	Kernel-5_35-4_79_2_313:4.6.2.3
	Kernel-5_35-4_79_2_312:4.6.2.3
	Kernel-5_35-4_79_2_311:4.6.2.3
	Kernel-5_35-4_79_2_310:4.6.2.3
	Kernel-5_35-4_79_2_309:4.6.2.3
	Kernel-5_35-4_79_2_308:4.6.2.3
	Kernel-5_35-4_79_2_307:4.6.2.3
	Kernel-5_35-4_79_2_306:4.6.2.3
	Kernel-5_35-4_79_2_305:4.6.2.3
	Kernel-5_35-4_79_2_304:4.6.2.3
	Kernel-5_35-4_79_2_303:4.6.2.3
	Kernel-5_35-4_79_2_302:4.6.2.3
	Kernel-5_35-4_79_2_301:4.6.2.3
	Kernel-5_35-4_79_2_300:4.6.2.3
	Kernel-5_35-4_79_2_299:4.6.2.3
	Kernel-5_35-4_79_2_298:4.6.2.3
	Kernel-5_35-4_79_2_297:4.6.2.3
	Kernel-5_35-4_79_2_296:4.6.2.3
	Kernel-5_35-4_79_2_295:4.6.2.3
	Kernel-5_35-4_79_2_294:4.6.2.3
	Kernel-5_35-4_79_2_293:4.6.2.3
	Kernel-5_35-4_79_2_292:4.6.2.3
	Kernel-5_35-4_79_2_291:4.6.2.3
	Kernel-5_35-4_79_2_290:4.6.2.3
	Kernel-5_35-4_79_2_289:4.6.2.3
	Kernel-5_35-4_79_2_288:4.6.2.3
	Kernel-5_35-4_79_2_287:4.6.2.3
	Kernel-5_35-4_79_2_286:4.6.2.3
	Kernel-5_35-4_79_2_285:4.6.2.3
	Kernel-5_35-4_79_2_284:4.6.2.3
	Kernel-5_35-4_79_2_283:4.6.2.3
	Kernel-5_35-4_79_2_282:4.6.2.3
	Kernel-5_35-4_79_2_281:4.6.2.3
	Kernel-5_35-4_79_2_280:4.6.2.3
	Kernel-5_35-4_79_2_279:4.6.2.3
	Kernel-5_35-4_79_2_278:4.6.2.3
	Kernel-5_35-4_79_2_277:4.6.2.3
	Kernel-5_35-4_79_2_276:4.6.2.3
	Kernel-5_35-4_79_2_275:4.6.2.3
	Kernel-5_35-4_79_2_274:4.6.2.3
	Kernel-5_35-4_79_2_273:4.6.2.3
	Kernel-5_35-4_79_2_272:4.6.2.3
	Kernel-5_35-4_79_2_271:4.6.2.3
	Kernel-5_35-4_79_2_270:4.6.2.3
	Kernel-5_35-4_79_2_269:4.6.2.3
	Kernel-5_35-4_79_2_268:4.6.2.3
	Kernel-5_35-4_79_2_267:4.6.2.3
	Kernel-5_35-4_79_2_266:4.6.2.3
	Kernel-5_35-4_79_2_265:4.6.2.3
	Kernel-5_35-4_79_2_264:4.6.2.3
	Kernel-5_35-4_79_2_263:4.6.2.3
	Kernel-5_35-4_79_2_262:4.6.2.3
	Kernel-5_35-4_79_2_261:4.6.2.3
	Kernel-5_35-4_79_2_260:4.6.2.3
	Kernel-5_35-4_79_2_259:4.6.2.3
	Kernel-5_35-4_79_2_258:4.6.2.3
	Kernel-5_35-4_79_2_257:4.6.2.3
	Kernel-5_35-4_79_2_256:4.6.2.3
	Kernel-5_35-4_79_2_255:4.6.2.3
	Kernel-5_35-4_79_2_254:4.6.2.3
	Kernel-5_35-4_79_2_253:4.6.2.3
	Kernel-5_35-4_79_2_252:4.6.2.3
	Kernel-5_35-4_79_2_251:4.6.2.3
	Kernel-5_35-4_79_2_250:4.6.2.3
	Kernel-5_35-4_79_2_249:4.6.2.3
	Kernel-5_35-4_79_2_248:4.6.2.3
	Kernel-5_35-4_79_2_247:4.6.2.3
	Kernel-5_35-4_79_2_246:4.6.2.3
	Kernel-5_35-4_79_2_245:4.6.2.3
	Kernel-5_35-4_79_2_244:4.6.2.3
	Kernel-5_35-4_79_2_243:4.6.2.3
	Kernel-5_35-4_79_2_242:4.6.2.3
	Kernel-5_35-4_79_2_241:4.6.2.3
	Kernel-5_35-4_79_2_240:4.6.2.3
	Kernel-5_35-4_79_2_239:4.6.2.3
	Kernel-5_35-4_79_2_238:4.6.2.3
	Kernel-5_35-4_79_2_237:4.6.2.3
	Kernel-5_35-4_79_2_236:4.6.2.3
	Kernel-5_35-4_79_2_235:4.6.2.3
	Kernel-5_35-4_79_2_234:4.6.2.3
	Kernel-5_35-4_79_2_233:4.6.2.3
	Kernel-5_35-4_79_2_232:4.6.2.3
	Kernel-5_35-4_79_2_231:4.6.2.3
	Kernel-5_35-4_79_2_230:4.6.2.3
	Kernel-5_35-4_79_2_229:4.6.2.3
	Kernel-5_35-4_79_2_228:4.6.2.3
	Kernel-5_35-4_79_2_227:4.6.2.3
	Kernel-5_35-4_79_2_226:4.6.2.3
	Kernel-5_35-4_79_2_225:4.6.2.3
	Kernel-5_35-4_79_2_224:4.6.2.3
	Kernel-5_35-4_79_2_223:4.6.2.3
	Kernel-5_35-4_79_2_222:4.6.2.3
	Kernel-5_35-4_79_2_221:4.6.2.3
	Kernel-5_35-4_79_2_220:4.6.2.3
	Kernel-5_35-4_79_2_219:4.6.2.3
	Kernel-5_35-4_79_2_218:4.6.2.3
	Kernel-5_35-4_79_2_217:4.6.2.3
	Kernel-5_35-4_79_2_216:4.6.2.3
	Kernel-5_35-4_79_2_215:4.6.2.3
	Kernel-5_35-4_79_2_214:4.6.2.3
	Kernel-5_35-4_79_2_213:4.6.2.3
	Kernel-5_35-4_79_2_212:4.6.2.3
	Kernel-5_35-4_79_2_211:4.6.2.3
	Kernel-5_35-4_79_2_210:4.6.2.3
	Kernel-5_35-4_79_2_209:4.6.2.3
	Kernel-5_35-4_79_2_208:4.6.2.3
	Kernel-5_35-4_79_2_207:4.6.2.3
	Kernel-5_35-4_79_2_206:4.6.2.3
	Kernel-5_35-4_79_2_205:4.6.2.3
	Kernel-5_35-4_79_2_204:4.6.2.3
	Kernel-5_35-4_79_2_203:4.6.2.3
	Kernel-5_35-4_79_2_202:4.6.2.3
	Kernel-5_35-4_79_2_201:4.6.2.3
	Kernel-5_35-4_79_2_200:4.6.2.3
	Kernel-5_35-4_79_2_199:4.6.2.3
	Kernel-5_35-4_79_2_198:4.6.2.3
	Kernel-5_35-4_79_2_197:4.6.2.3
	Kernel-5_35-4_79_2_196:4.6.2.3
	Kernel-5_35-4_79_2_195:4.6.2.3
	Kernel-5_35-4_79_2_194:4.6.2.3
	Kernel-5_35-4_79_2_193:4.6.2.2
	Kernel-5_35-4_79_2_192:4.6.2.2
	Kernel-5_35-4_79_2_191:4.6.2.2
	Kernel-5_35-4_79_2_190:4.6.2.2
	Kernel-5_35-4_79_2_189:4.6.2.2
	Kernel-5_35-4_79_2_188:4.6.2.2
	Kernel-5_35-4_79_2_187:4.6.2.2
	Kernel-5_35-4_79_2_186:4.6.2.2
	Kernel-5_35-4_79_2_185:4.6.2.2
	Kernel-5_35-4_79_2_184:4.6.2.2
	Kernel-5_35-4_79_2_183:4.6.2.2
	Kernel-5_35-4_79_2_182:4.6.2.2
	Kernel-5_35-4_79_2_181:4.6.2.2
	Kernel-5_35-4_79_2_180:4.6.2.2
	Kernel-5_35-4_79_2_179:4.6.2.2
	Kernel-5_35-4_79_2_178:4.6.2.2
	Kernel-5_35-4_79_2_177:4.6.2.2
	Kernel-5_35-4_79_2_176:4.6.2.2
	Kernel-5_35-4_79_2_175:4.6.2.2
	Kernel-5_35-4_79_2_174:4.6.2.2
	Kernel-5_35-4_79_2_173:4.6.2.2
	Kernel-5_35-4_79_2_172:4.6.2.2
	Kernel-5_35-4_79_2_171:4.6.2.2
	Kernel-5_35-4_79_2_170:4.6.2.2
	Kernel-5_35-4_79_2_169:4.6.2.2
	Kernel-5_35-4_79_2_168:4.6.2.2
	Kernel-5_35-4_79_2_167:4.6.2.2
	Kernel-5_35-4_79_2_166:4.6.2.2
	Kernel-5_35-4_79_2_165:4.6.2.2
	RPi_merge:4.6.2.2
	Kernel-5_35-4_79_2_147_2_23:4.6.2.2
	Kernel-5_35-4_79_2_147_2_22:4.6.2.2
	Kernel-5_35-4_79_2_147_2_21:4.6.2.2
	Kernel-5_35-4_79_2_147_2_20:4.6.2.2
	Kernel-5_35-4_79_2_147_2_19:4.6.2.2
	Kernel-5_35-4_79_2_147_2_18:4.6.2.2
	Kernel-5_35-4_79_2_164:4.6.2.2
	Kernel-5_35-4_79_2_163:4.6.2.2
	Kernel-5_35-4_79_2_147_2_17:4.6.2.2
	Kernel-5_35-4_79_2_147_2_16:4.6.2.2
	Kernel-5_35-4_79_2_147_2_15:4.6.2.2
	Kernel-5_35-4_79_2_162:4.6.2.2
	Kernel-5_35-4_79_2_161:4.6.2.2
	Kernel-5_35-4_79_2_147_2_14:4.6.2.2
	Kernel-5_35-4_79_2_147_2_13:4.6.2.2
	Kernel-5_35-4_79_2_160:4.6.2.2
	Kernel-5_35-4_79_2_159:4.6.2.2
	Kernel-5_35-4_79_2_158:4.6.2.2
	Kernel-5_35-4_79_2_157:4.6.2.2
	Kernel-5_35-4_79_2_156:4.6.2.2
	Kernel-5_35-4_79_2_147_2_12:4.6.2.2
	Kernel-5_35-4_79_2_147_2_11:4.6.2.2
	Kernel-5_35-4_79_2_155:4.6.2.2
	Kernel-5_35-4_79_2_147_2_10:4.6.2.2
	Kernel-5_35-4_79_2_154:4.6.2.2
	Kernel-5_35-4_79_2_153:4.6.2.2
	Kernel-5_35-4_79_2_147_2_9:4.6.2.2
	Kernel-5_35-4_79_2_152:4.6.2.2
	Kernel-5_35-4_79_2_151:4.6.2.2
	Kernel-5_35-4_79_2_147_2_8:4.6.2.2
	Kernel-5_35-4_79_2_147_2_7:4.6.2.2
	Kernel-5_35-4_79_2_150:4.6.2.2
	Kernel-5_35-4_79_2_147_2_6:4.6.2.2
	Kernel-5_35-4_79_2_147_2_5:4.6.2.2
	Kernel-5_35-4_79_2_149:4.6.2.2
	Kernel-5_35-4_79_2_147_2_4:4.6.2.2
	Kernel-5_35-4_79_2_147_2_3:4.6.2.2
	Kernel-5_35-4_79_2_148:4.6.2.2
	Kernel-5_35-4_79_2_147_2_2:4.6.2.2
	Kernel-5_35-4_79_2_147_2_1:4.6.2.2
	RPi:4.6.2.2.0.6
	RPi_bp:4.6.2.2
	Kernel-5_35-4_79_2_98_2_52_2_1:4.6.2.2
	alees_Kernel_dev:4.6.2.2.0.4
	alees_Kernel_dev_bp:4.6.2.2
	Kernel-5_35-4_79_2_147:4.6.2.2
	Kernel-5_35-4_79_2_146:4.6.2.2
	Kernel-5_35-4_79_2_145:4.6.2.2
	Kernel-5_35-4_79_2_144:4.6.2.2
	Kernel-5_35-4_79_2_143:4.6.2.2
	Kernel-5_35-4_79_2_142:4.6.2.2
	Kernel-5_35-4_79_2_141:4.6.2.2
	Kernel-5_35-4_79_2_140:4.6.2.2
	Kernel-5_35-4_79_2_139:4.6.2.2
	Kernel-5_35-4_79_2_138:4.6.2.2
	Kernel-5_35-4_79_2_137:4.6.2.2
	Kernel-5_35-4_79_2_136:4.6.2.2
	Kernel-5_35-4_79_2_135:4.6.2.2
	Kernel-5_35-4_79_2_134:4.6.2.2
	Kernel-5_35-4_79_2_133:4.6.2.2
	Kernel-5_35-4_79_2_132:4.6.2.2
	Kernel-5_35-4_79_2_131:4.6.2.2
	Kernel-5_35-4_79_2_130:4.6.2.2
	Kernel-5_35-4_79_2_129:4.6.2.2
	Kernel-5_35-4_79_2_128:4.6.2.2
	Kernel-5_35-4_79_2_127:4.6.2.2
	Kernel-5_35-4_79_2_126:4.6.2.2
	Kernel-5_35-4_79_2_125:4.6.2.2
	Kernel-5_35-4_79_2_124:4.6.2.2
	Kernel-5_35-4_79_2_123:4.6.2.2
	Cortex_merge:4.6.2.2
	Kernel-5_35-4_79_2_122:4.6.2.2
	Kernel-5_35-4_79_2_98_2_54:4.6.2.2
	Kernel-5_35-4_79_2_98_2_53:4.6.2.2
	Kernel-5_35-4_79_2_98_2_52:4.6.2.2
	Kernel-5_35-4_79_2_98_2_51:4.6.2.2
	Kernel-5_35-4_79_2_98_2_50:4.6.2.2
	Kernel-5_35-4_79_2_98_2_49:4.6.2.2
	Kernel-5_35-4_79_2_98_2_48:4.6.2.2
	Kernel-5_35-4_79_2_121:4.6.2.2
	Kernel-5_35-4_79_2_98_2_47:4.6.2.2
	Kernel-5_35-4_79_2_120:4.6.2.2
	Kernel-5_35-4_79_2_98_2_46:4.6.2.2
	Kernel-5_35-4_79_2_119:4.6.2.2
	Kernel-5_35-4_79_2_98_2_45:4.6.2.2
	Kernel-5_35-4_79_2_98_2_44:4.6.2.2
	Kernel-5_35-4_79_2_118:4.6.2.2
	Kernel-5_35-4_79_2_98_2_43:4.6.2.2
	Kernel-5_35-4_79_2_117:4.6.2.2
	Kernel-5_35-4_79_2_116:4.6.2.2
	Kernel-5_35-4_79_2_98_2_42:4.6.2.2
	Kernel-5_35-4_79_2_115:4.6.2.2
	Kernel-5_35-4_79_2_98_2_41:4.6.2.2
	Kernel-5_35-4_79_2_98_2_40:4.6.2.2
	Kernel-5_35-4_79_2_114:4.6.2.2
	Kernel-5_35-4_79_2_98_2_39:4.6.2.2
	Kernel-5_35-4_79_2_98_2_38:4.6.2.2
	Kernel-5_35-4_79_2_113:4.6.2.2
	Kernel-5_35-4_79_2_112:4.6.2.2
	Kernel-5_35-4_79_2_98_2_37:4.6.2.2
	Kernel-5_35-4_79_2_98_2_36:4.6.2.2
	Kernel-5_35-4_79_2_98_2_35:4.6.2.2
	Kernel-5_35-4_79_2_98_2_34:4.6.2.2
	Kernel-5_35-4_79_2_98_2_33:4.6.2.2
	Kernel-5_35-4_79_2_98_2_32:4.6.2.2
	Kernel-5_35-4_79_2_98_2_31:4.6.2.2
	Kernel-5_35-4_79_2_98_2_30:4.6.2.2
	Kernel-5_35-4_79_2_98_2_29:4.6.2.2
	Kernel-5_35-4_79_2_98_2_28:4.6.2.2
	Kernel-5_35-4_79_2_98_2_27:4.6.2.2
	Kernel-5_35-4_79_2_98_2_26:4.6.2.2
	Kernel-5_35-4_79_2_111:4.6.2.2
	Kernel-5_35-4_79_2_98_2_25:4.6.2.2
	Kernel-5_35-4_79_2_98_2_24:4.6.2.2
	Kernel-5_35-4_79_2_98_2_23:4.6.2.2
	Kernel-5_35-4_79_2_110:4.6.2.2
	Kernel-5_35-4_79_2_98_2_22:4.6.2.2
	Kernel-5_35-4_79_2_109:4.6.2.2
	Kernel-5_35-4_79_2_98_2_21:4.6.2.2
	Kernel-5_35-4_79_2_98_2_20:4.6.2.2
	Kernel-5_35-4_79_2_108:4.6.2.2
	Kernel-5_35-4_79_2_107:4.6.2.2
	Kernel-5_35-4_79_2_98_2_19:4.6.2.2
	Kernel-5_35-4_79_2_98_2_18:4.6.2.2
	Kernel-5_35-4_79_2_98_2_17:4.6.2.2
	Kernel-5_35-4_79_2_98_2_16:4.6.2.2
	Kernel-5_35-4_79_2_98_2_15:4.6.2.2
	Kernel-5_35-4_79_2_106:4.6.2.2
	Kernel-5_35-4_79_2_105:4.6.2.2
	Kernel-5_35-4_79_2_104:4.6.2.2
	Kernel-5_35-4_79_2_98_2_14:4.6.2.2
	Kernel-5_35-4_79_2_98_2_13:4.6.2.2
	Kernel-5_35-4_79_2_98_2_12:4.6.2.2
	Kernel-5_35-4_79_2_98_2_11:4.6.2.2
	Kernel-5_35-4_79_2_98_2_10:4.6.2.2
	Kernel-5_35-4_79_2_98_2_9:4.6.2.2
	Kernel-5_35-4_79_2_103:4.6.2.2
	Kernel-5_35-4_79_2_102:4.6.2.2
	Kernel-5_35-4_79_2_98_2_8:4.6.2.2
	Kernel-5_35-4_79_2_98_2_7:4.6.2.2
	Kernel-5_35-4_79_2_98_2_6:4.6.2.2
	Kernel-5_35-4_79_2_98_2_5:4.6.2.2
	Kernel-5_35-4_79_2_98_2_4:4.6.2.2
	Kernel-5_35-4_79_2_101:4.6.2.2
	Kernel-5_35-4_79_2_100:4.6.2.2
	Kernel-5_35-4_79_2_99:4.6.2.2
	Kernel-5_35-4_79_2_98_2_3:4.6.2.2
	Kernel-5_35-4_79_2_98_2_2:4.6.2.2
	Kernel-5_35-4_79_2_98_2_1:4.6.2.2
	Cortex:4.6.2.2.0.2
	Cortex_bp:4.6.2.2
	Kernel-5_35-4_79_2_98:4.6.2.2
	Kernel-5_35-4_79_2_97:4.6.2.2
	Kernel-5_35-4_79_2_96:4.6.2.2
	Kernel-5_35-4_79_2_95:4.6.2.2
	Kernel-5_35-4_79_2_94:4.6.2.2
	Kernel-5_35-4_79_2_93:4.6.2.2
	Kernel-5_35-4_79_2_92:4.6.2.2
	Kernel-5_35-4_79_2_91:4.6.2.2
	Kernel-5_35-4_79_2_90:4.6.2.2
	Kernel-5_35-4_79_2_89:4.6.2.2
	Kernel-5_35-4_79_2_88:4.6.2.2
	Kernel-5_35-4_79_2_87:4.6.2.2
	Kernel-5_35-4_79_2_86:4.6.2.2
	Kernel-5_35-4_79_2_85:4.6.2.2
	Kernel-5_35-4_79_2_84:4.6.2.2
	Kernel-5_35-4_79_2_83:4.6.2.2
	Kernel-5_35-4_79_2_82:4.6.2.2
	Kernel-5_35-4_79_2_81:4.6.2.2
	Kernel-5_35-4_79_2_80:4.6.2.2
	Kernel-5_35-4_79_2_79:4.6.2.2
	Kernel-5_35-4_79_2_78:4.6.2.2
	Kernel-5_35-4_79_2_77:4.6.2.2
	RO_5_07:4.6.2.2
	Kernel-5_35-4_79_2_76:4.6.2.2
	Kernel-5_35-4_79_2_75:4.6.2.2
	Kernel-5_35-4_79_2_74:4.6.2.2
	Kernel-5_35-4_79_2_73:4.6.2.2
	Kernel-5_35-4_79_2_72:4.6.2.2
	Kernel-5_35-4_79_2_71:4.6.2.2
	Kernel-5_35-4_79_2_70:4.6.2.2
	Kernel-5_35-4_79_2_69:4.6.2.2
	Kernel-5_35-4_79_2_68:4.6.2.2
	Kernel-5_35-4_79_2_67:4.6.2.2
	Kernel-5_35-4_79_2_66:4.6.2.2
	Kernel-5_35-4_79_2_65:4.6.2.2
	Kernel-5_35-4_79_2_64:4.6.2.2
	Kernel-5_35-4_79_2_63:4.6.2.2
	Kernel-5_35-4_79_2_62:4.6.2.2
	Kernel-5_35-4_79_2_61:4.6.2.2
	Kernel-5_35-4_79_2_59:4.6.2.2
	Kernel-5_35-4_79_2_58:4.6.2.2
	Kernel-5_35-4_79_2_57:4.6.2.2
	Kernel-5_35-4_79_2_56:4.6.2.2
	Kernel-5_35-4_79_2_55:4.6.2.2
	Kernel-5_35-4_79_2_54:4.6.2.2
	Kernel-5_35-4_79_2_53:4.6.2.2
	Kernel-5_35-4_79_2_52:4.6.2.2
	Kernel-5_35-4_79_2_51:4.6.2.2
	Kernel-5_35-4_79_2_50:4.6.2.2
	Kernel-5_35-4_79_2_49:4.6.2.2
	Kernel-5_35-4_79_2_48:4.6.2.2
	Kernel-5_47:4.6
	Kernel-5_46-4_90_2_1:4.6
	nbingham_Kernel_FastNC_dev_bp:4.6
	nbingham_Kernel_FastNC_dev:4.6.0.4
	Kernel-5_46:4.6
	Kernel-5_45:4.6
	Kernel-5_35-4_79_2_47:4.6.2.2
	Kernel-5_35-4_79_2_46:4.6.2.2
	Kernel-5_35-4_79_2_45:4.6.2.2
	Kernel-5_35-4_79_2_44:4.6.2.2
	Kernel-5_35-4_79_2_25_2_2:4.6.2.2
	Kernel-5_35-4_79_2_43:4.6.2.2
	Kernel-5_35-4_79_2_42:4.6.2.2
	Kernel-5_35-4_79_2_41:4.6.2.2
	Kernel-5_35-4_79_2_40:4.6.2.2
	Kernel-5_35-4_79_2_39:4.6.2.2
	Kernel-5_35-4_79_2_38:4.6.2.2
	Kernel-5_35-4_79_2_37:4.6.2.2
	Kernel-5_35-4_79_2_36:4.6.2.2
	Kernel-5_35-4_79_2_35:4.6.2.2
	Kernel-5_35-4_79_2_34:4.6.2.2
	Kernel-5_35-4_79_2_33:4.6.2.2
	Kernel-5_35-4_79_2_32:4.6.2.2
	Kernel-5_44:4.6
	Kernel-5_35-4_79_2_25_2_1:4.6.2.2
	Kernel-5_43:4.6
	Kernel-5_35-4_79_2_31:4.6.2.2
	Kernel-5_35-4_79_2_30:4.6.2.2
	Kernel-5_35-4_79_2_29:4.6.2.2
	Kernel-5_35-4_79_2_28:4.6.2.2
	Kernel-5_35-4_79_2_27:4.6.2.2
	Kernel-5_35-4_79_2_26:4.6.2.2
	Kernel-5_42:4.6
	Kernel-5_41:4.6
	Kernel-5_40:4.6
	Kernel-5_35-4_79_2_25:4.6.2.2
	Kernel-5_35-4_79_2_24:4.6.2.2
	Kernel-5_35-4_79_2_23:4.6.2.2
	Kernel-5_35-4_79_2_22:4.6.2.2
	Kernel-5_35-4_79_2_21:4.6.2.2
	Kernel-5_35-4_79_2_20:4.6.2.2
	Kernel-5_35-4_79_2_19:4.6.2.2
	Kernel-5_35-4_79_2_18:4.6.2.2
	Kernel-5_35-4_79_2_17:4.6.2.2
	Kernel-5_35-4_79_2_16:4.6.2.2
	Kernel-5_35-4_79_2_15:4.6.2.2
	Kernel-5_35-4_79_2_14:4.6.2.2
	Kernel-5_39:4.6
	Kernel-5_13-4_52_2_1:4.4
	Bethany:4.4.0.2
	Kernel-5_38:4.6
	Kernel-5_35-4_79_2_13:4.6.2.2
	Kernel-5_35-4_79_2_12:4.6.2.2
	Kernel-5_35-4_79_2_11:4.6.2.2
	Kernel-5_37:4.6
	Kernel-5_35-4_79_2_10:4.6.2.2
	Kernel-5_35-4_79_2_9:4.6.2.2
	Kernel-5_36:4.6
	Kernel-5_35-4_79_2_8:4.6.2.2
	Kernel-5_35-4_79_2_7:4.6.2.2
	Kernel-5_35-4_79_2_6:4.6.2.2
	Kernel-5_35-4_79_2_5:4.6.2.2
	Kernel-5_35-4_79_2_4:4.6.2.2
	Kernel-5_35-4_79_2_3:4.6.2.2
	Kernel-5_35-4_79_2_2:4.6.2.1
	dellis_autobuild_BaseSW:4.6
	Kernel-5_35-4_79_2_1:4.6.2.1
	HAL:4.6.0.2
	Kernel-5_35:4.6
	Kernel-5_34:4.6
	Kernel-5_33:4.6
	Kernel-5_32:4.6
	Kernel-5_31:4.6
	Kernel-5_30:4.6
	Kernel-5_29:4.6
	Kernel-5_28:4.6
	Kernel-5_27:4.6
	Kernel-5_26:4.6
	Kernel-5_25:4.6
	Kernel-5_24:4.6
	Kernel-5_23:4.6
	Kernel-5_22:4.5
	sbrodie_sedwards_16Mar2000:4.5
	Kernel-5_21:4.5
	Kernel-5_20:4.4
	Kernel-5_19:4.4
	Kernel-5_18:4.4
	Kernel-5_17:4.4
	Kernel-5_16:4.4
	Kernel-5_15:4.4
	Kernel-5_14:4.4
	Kernel-5_13:4.4
	Kernel-5_12:4.4
	Kernel-5_11:4.4
	Kernel-5_10:4.3
	Kernel-5_09:4.3
	Kernel-5_08:4.3
	Kernel-5_07:4.3
	Kernel-5_06:4.3
	Kernel-5_05:4.3
	Kernel-5_04:4.3
	Kernel-5_03:4.3
	Kernel-5_02:4.3
	Kernel-5_01:4.3
	Kernel-5_00:4.3
	Kernel-4_99:4.3
	Kernel-4_98:4.3
	Kernel-4_97:4.3
	Kernel-4_96:4.3
	Kernel-4_95:4.2
	Kernel-4_94:4.2
	Kernel-4_93:4.2
	Kernel-4_92:4.2
	Kernel-4_91:4.2
	Kernel-4_90:4.2
	dcotton_autobuild_BaseSW:4.6
	Kernel-4_89:4.2
	Kernel-4_88:4.2
	Kernel-4_87:4.2
	Kernel-4_86:4.2
	Kernel-4_85:4.2
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.1.2.1
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.1.2.1
	Ursula_RiscPC_bp:4.2.2.1
	Kernel-4_83:4.2
	Kernel-4_82:4.2
	Kernel-4_81:4.2
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.2
	Ursula_merge:4.2
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.2.2.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	mstphens_Kernel-3_80:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2016.06.30.20.29.05;	author jlee;	state dead;
branches;
next	4.7;
commitid	lMnWzoE9eJz3Wwcz;

4.7
date	2016.06.30.20.08.20;	author jlee;	state Exp;
branches;
next	4.6;
commitid	IWoXxARWeuLDOwcz;

4.6
date	2000.04.04.14.27.42;	author kbracey;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2000.03.10.15.50.07;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.01.26.13.16.47;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	99.10.14.12.18.30;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.07.39;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.40;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2000.09.15.12.38.02;	author kbracey;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2000.10.03.12.06.00;	author mstephen;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2013.08.06.22.43.10;	author jlee;	state Exp;
branches;
next	;
commitid	TOIaeUf2Q4rBIr0x;

4.2.2.1
date	97.09.09.13.34.50;	author mstphens;	state Exp;
branches
	4.2.2.1.2.1;
next	4.2.2.2;

4.2.2.2
date	98.09.24.13.17.54;	author mstphens;	state Exp;
branches;
next	;

4.2.2.1.2.1
date	98.11.23.14.59.46;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.40;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.42;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.53;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > VduPal20

; mjs Sep 2000
;
; not used any more, since kernel/HAL split
; vdupalxx is the file now used for generic palette programming 

; Palette programming for VIDC20

; *****************************************************************************

; PaletteV handler
; ----------------

; *****************************************************************************
;
;       MOSPaletteV - Default owner of PaletteV
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6
        ASSERT  paletteV_BulkRead = 7
        ASSERT  paletteV_BulkWrite = 8
        ASSERT  paletteV_GammaCorrection = 9
 [ LCDInvert
        ASSERT  paletteV_LCDInvert = 10
 ]
 [ StorkPowerSave
        ASSERT  paletteV_VIDCDisable = 12
        ASSERT  paletteV_VIDCRestore = 13
 ]

MOSPaletteV ROUT
        CMP     r4, #1
        MOVCC   pc, lr
        BEQ     PV_ReadPalette
        CMP     r4, #3
        BCC     PV_SetPalette
        BEQ     PV_1stFlashState
        CMP     r4, #5
        BCC     PV_2ndFlashState
        BEQ     PV_SetDefaultPalette
        CMP     r4, #7
        BCC     PV_BlankScreen
        BEQ     PV_BulkRead
        CMP     r4, #9
        BCC     PV_BulkWrite
        BEQ     PV_GammaCorrect
 [ LCDInvert
        CMP     r4, #11
        BCC     PV_LCDInvert
 ]
 [ StorkPowerSave
        MOVEQ   pc, lr
        CMP     r4, #13
        BCC     PV_VIDCDisable
        BEQ     PV_VIDCRestore
        MOVEQ   pc, lr
 ]
        MOV     pc, lr                  ; reason code not known, so pass it on

; *****************************************************************************

PV_SetDefaultPalette ROUT
        Push    "r0-r3,r5-r9"
        LDR     r0, [WsPtr, #PalIndex]  ; the new index 0-7
        ADR     r1, paldptab
        LDR     r2, [r1, r0, LSL #2]    ; offset from r1 to start of table
        ADD     r0, r0, #1              ; point to next item
        LDR     r5, [r1, r0, LSL #2]    ; offset from r1 to end of table +1
        ADDS    r2, r2, r1              ; r2 -> start of table
        BICMI   pc, r2, #&80000000      ; if negative then it's a routine
        ADD     r5, r5, r1              ; r5 -> end of table
        BIC     r5, r5, #&80000000
        MOV     r0, #0                  ; start at palette index 0
        MOV     r1, #3                  ; set both halves
10
        LDR     r6, [r2], #4
        MOVS    r3, r6, LSL #17         ; get 1st half word and set carry if flashing
        MOV     r3, r3, LSR #17
        MOVCC   r4, #0
        LDRCS   r4, =&FFF               ; flashing so invert 2nd half RGB
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        MOVS    r3, r6, LSL #1          ; get 2nd half word and set carry if flashing
        MOV     r3, r3, LSR #17
        MOVCC   r4, #0
        LDRCS   r4, =&FFF
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        TEQ     r2, r5
        BNE     %BT10

; now ensure all palette entries from 0..255 are initialised

        MOV     r3, #0                  ; set unused (and border) to black
        MOV     r4, #0                  ; no flashing
20
        CMP     r0, #256
        BHS     FinishDefault
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        B       %BT20

FinishDefault
        MOV     r2, #0                  ; set border to black (and setup colours 2,3 in BBC gap modes)
        BL      BorderInitEntry

        MOV     r4, #0                  ; indicate PaletteV operation complete
        Pull    "r0-r3,r5-r9,pc"        ; restore registers and claim vector

        LTORG

; *****************************************************************************

; Table of offsets from paldata_pointer to palette data

paldptab
        &       paldat1-paldptab        ; 2  Colour Modes
        &       paldat2-paldptab        ; 4
        &       paldat4-paldptab        ; 16
        &       (paldat8-paldptab) :OR: &80000000  ; 256 (VIDC10 compatible) - use routine
        &       paldatT-paldptab        ; teletext mode
        &       paldatHR-paldptab       ; Hi-res mono mode
        &       (paldat16-paldptab) :OR: &80000000 ; 16 bpp - use routine
        &       (paldat32-paldptab) :OR: &80000000 ; 32 bpp (or 256 greys - they're identical!) - use routine
        &       paldatend-paldptab      ; end of table marker

paldat1 ; Data for 1 bit modes - only necessary to program registers 0 and 1

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &0FFF           ; 1  White

paldat2 ; Data for 2 bit modes - only necessary to program registers 0..3

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &000F           ; 1  Red
        DCW     &00FF           ; 2  Yellow
        DCW     &0FFF           ; 3  White

paldat4 ; Data for 4 bit modes - program all registers
        ; Flashing Colours will be needed here

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &000F           ; 1  Red
        DCW     &00F0           ; 2  Green
        DCW     &00FF           ; 3  Yellow
        DCW     &0F00           ; 4  Blue
        DCW     &0F0F           ; 5  Magenta
        DCW     &0FF0           ; 6  Cyan
        DCW     &0FFF           ; 7  White
        DCW     &8000           ; 8  Flashing Black
        DCW     &800F           ; 9  Flashing Red
        DCW     &80F0           ; 10 Flashing Green
        DCW     &80FF           ; 11 Flashing Yellow
        DCW     &8F00           ; 12 Flashing Blue
        DCW     &8F0F           ; 13 Flashing Magenta
        DCW     &8FF0           ; 14 Flashing Cyan
        DCW     &8FFF           ; 15 Flashing White

; Routine to initialise palette for VIDC10-compatible 8bpp modes
; Note this must still be in between paldat4 and paldatT

paldat8 ROUT
        MOV     r1, #3                  ; set both halves of palette
        MOV     r0, #0                  ; starting index
10
        AND     r2, r0, #3              ; get tint bits
        ORR     r2, r2, r2, LSL #4      ; and duplicate into bits 8,9,12,13,16,17,20,21,24,25,28,29
        ORR     r2, r2, r2, LSL #8
        ORR     r2, r2, r2, LSL #16
        BIC     r2, r2, #&FF
        TST     r0, #4
        ORRNE   r2, r2, #&00004400
        TST     r0, #8
        ORRNE   r2, r2, #&44000000
        TST     r0, #&10
        ORRNE   r2, r2, #&00008800
        TST     r0, #&20
        ORRNE   r2, r2, #&00440000
        TST     r0, #&40
        ORRNE   r2, r2, #&00880000
        TST     r0, #&80
        ORRNE   r2, r2, #&88000000
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #1
        TEQ     r0, #&100
        BNE     %BT10
        B       FinishDefault

paldatT ; Data for teletext mode

        DCW     &0000           ; 0 Black
        DCW     &000F           ; 1 Red
        DCW     &00F0           ; 2 Green
        DCW     &00FF           ; 3 Yellow
        DCW     &0F00           ; 4 Blue
        DCW     &0F0F           ; 5 Magenta
        DCW     &0FF0           ; 6 Cyan
        DCW     &0FFF           ; 7 White

; Colours 8 to 15 have supremacy bit set

        DCW     &1000           ; 8 Supremacy+ Black
        DCW     &100F           ; 9            Red
        DCW     &10F0           ; 10           Green
        DCW     &10FF           ; 11           Yellow
        DCW     &1F00           ; 12           Blue
        DCW     &1F0F           ; 13           Magenta
        DCW     &1FF0           ; 14           Cyan
        DCW     &1FFF           ; 15           White

paldatHR  ; data for Hi-res mono mode
        DCW     &0000           ; Only red gun necessary
        DCW     &0111           ; but setting all three makes
        DCW     &0222           ; reading it more natural
        DCW     &0333
        DCW     &0444
        DCW     &0555
        DCW     &0666
        DCW     &0777
        DCW     &0888
        DCW     &0999
        DCW     &0AAA
        DCW     &0BBB
        DCW     &0CCC
        DCW     &0DDD
        DCW     &0EEE
        DCW     &0FFF

        DCW     &0000           ; border black
        DCW     &0010           ; fixed pointer colours
        DCW     &0020
        DCW     &0030

paldat16 ROUT
        ADR     r5, paldat16tab
palmetatab
        MOV     r1, #3                  ; set both halves of palette
        MOV     r0, #0                  ; starting index
10
        MOV     r8, r5
        MOV     r2, #0
        MOV     r6, r0
20
        LDR     r7, [r8], #4
        MOVS    r6, r6, LSR #1
        ORRCS   r2, r2, r7
        BNE     %BT20
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #1
        TEQ     r0, #&100
        BNE     %BT10
        B       FinishDefault

paldat16tab
        &       &00000800       ; palette bit 0
        &       &00081000       ;             1
        &       &08102100       ;             2
        &       &10214200       ;             3
        &       &21428400       ;             4
        &       &42840000       ;             5
        &       &84000000       ;             6
        &       &00000000       ;             7

paldat32 ROUT
        ADR     r5, paldat32tab
        B       palmetatab

paldat32tab
        &       &01010100       ; palette bit 0
        &       &02020200       ;             1
        &       &04040400       ;             2
        &       &08080800       ;             3
        &       &10101000       ;             4
        &       &20202000       ;             5
        &       &40404000       ;             6
        &       &80808000       ;             7

paldatend

; *****************************************************************************

; PaletteV call to set palette in bulk
; in:   R0 => list of colours, or 0
;       R1 =  colour type (16,17,18,24,25) in b24-31 & number to do in b23-b00
;       R2 => list of palette entries (both flash states if 16, one if 17/18)
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on

PV_BulkWrite    ROUT
        Push    "R0-R3,R5-R11"          ; pc already stacked

        ;register usage:
        ;[R6] colour list
        ;R7   colour type
        ;R8   max number
        ;[R9] palette entries
        ;R10  loop counter
        ;R11  colour number

        MOV     R7,R1,LSR #24
        BIC     R8,R1,#&FF000000
        MOV     R6,R0
        MOV     R9,R2

        MOV     R10,#0
10
        TEQ     R6,#0
        MOVEQ   R11,R10
        LDRNE   R11,[R6],#4

        TEQ     R7,#16
        TEQNE   R7,#17

        MOVEQ   R0,R11
        MOVEQ   R1,#1
        LDREQ   R2,[R9],#4
        BLEQ    UpdateNormalColour

        TEQ     R7,#16
        TEQNE   R7,#18

        MOVEQ   R0,R11
        MOVEQ   R1,#2
        LDREQ   R2,[R9],#4
        BLEQ    UpdateNormalColour

        TEQ     R7,#24

        MOVEQ   R0,R11
        LDREQ   R2,[R9],#4
        BLEQ    BorderColour

        TEQ     R7,#25

        MOVEQ   R0,R11
        LDREQ   R2,[R9],#4
        BLEQ    PointerColour

        ADD     R10,R10,#1
        CMP     R10,R8
        BCC     %BT10

        MOV     R4,#0
        Pull    "R0-R3,R5-R11,PC"

; *****************************************************************************

; PaletteV call to set palette
; in:   R0 = logical colour
;       R1 = colour type (16,17,18,24,25)
;       R2 = BBGGRRS0
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on
;

;amg 19/4/93 - change this routine to make all the calls subroutines rather
; than branches. Although it will slow this down a bit, it makes the bulk
; write a lot simpler and involves less duplication of mungeing code.

PV_SetPalette ROUT
        Push    "r0-r3"
        TEQ     r1, #16                 ; if 16 then set both colours
        MOVEQ   r1, #3
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #17                 ; elif 17 then set 1st colour
        MOVEQ   r1, #1
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #18                 ; elif 18 then set 2nd colour
        MOVEQ   r1, #2
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #24                 ; elif 24 then border colour
        BEQ     Call_BorderColour

        TEQ     r1, #25                 ; elif 25 then pointer colour
        BEQ     Call_PointerColour
10
        Pull    "r0-r3"
        MOV     pc, lr                  ; else not defined

Call_UpdateNormalColour
        BL      UpdateNormalColour
        Pull    "r0-r3,pc"

BorderInitEntry Push "r0-r3,lr"           ; entry used in default palette setting
Call_BorderColour
        BL      BorderColour
        Pull    "r0-r3,pc"

Call_PointerColour
        BL      PointerColour
        Pull    "r0-r3,pc"

; *****************************************************************************

UpdateNormalColour ROUT
        Push    "LR"
        LDR     lr, [WsPtr, #DisplayNColour] ; get the mask
        TEQ     lr, #63                 ; is it brain-damaged VIDC10-compatible 256 colour mode?
        BEQ     %FT10
        AND     r0, r0, lr              ; and mask it off
        AND     r0, r0, #255            ; definitely no more than 256 palette entries
        BL      UpdateSettingAndVIDC
05
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "pc"

10
        AND     r0, r0, #15             ; starting palette entry
20
        LDR     r3, =&88CC8800          ; r3 = bits controlled by bits 4..7 of pixel value
        BIC     r2, r2, r3
        TST     r0, #&10                ; test bit 4 (r3,7)
        ORRNE   r2, r2, #&00008800
        TST     r0, #&20                ; test bit 5 (g2,6)
        ORRNE   r2, r2, #&00440000
        TST     r0, #&40                ; test bit 6 (g3,7)
        ORRNE   r2, r2, #&00880000
        TST     r0, #&80                ; test bit 7 (b3,7)
        ORRNE   r2, r2, #&88000000
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #&10
        CMP     r0, #&100
        BCC     %BT20
        B       %BT05

BorderColour ROUT
        Push    "LR"
        MOV     r0, #&40000000          ; pseudo-palette-index for border colour
        MOV     r1, #3                  ; both colours
        BL      UpdateSettingAndVIDC

; Now test for BBC gap mode (ie 3 or 6)
; if so then set colour 2 to same as border, and colour 3 to inverse

        LDR     lr, [WsPtr, #DisplayModeFlags]
        TST     lr, #ModeFlag_BBCGapMode
        BEQ     %FT10

        MOV     r0, #2                  ; make colour 2 (gap) same as border
        BL      UpdateSettingAndVIDC

        MOV     r0, #3                  ; make colour 3 inverse gap
        MVN     r2, r2                  ; invert R, G and B
        EOR     r2, r2, #&FF            ; but use same supremacy
        BL      UpdateSettingAndVIDC
10
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "pc"


PointerColour ROUT
        Push    "LR"
        ANDS    r0, r0, #3              ; force pointer colour number in range 1..3
        BEQ     %FT10                   ; zero is invalid
        MOV     r0, r0, LSL #28         ; move up to top nybble
        ORR     r0, r0, #&40000000      ; form pseudo-palette-index
        MOV     r1, #3
        BL      UpdateSettingAndVIDC
10
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "pc"

; UpdateSettingStraightRGB
;
; in:   r0 = logical colour (border = 4 << 28, pointer colours = 5,6,7 << 28)
;       r1 = bit mask of which flash states to update (bit 0 set => 1st, bit 1 set => 2nd)
;       r3 = SBGR
;       r4 = SBGR to EOR with to go from 1st to 2nd flash state

; out:  r0,r1,r2,r4 preserved
;       r3 corrupted

UpdateSettingStraightRGB EntryS "r2,r5,r6,r7"
        ANDS    r5, r3, #1 :SHL: 12     ; get supremacy bit in 1st colour
        MOVNE   r5, #1 :SHL: 27         ; put in r5 in new position
        AND     r6, r3, #&FF0           ; r6 = 00000BG0
        ORR     r5, r5, r6, LSL #8      ; r5 = 0s0BG000
        AND     r6, r3, #&0FF           ; r6 = 000000GR
        ORR     r5, r5, r6, LSL #4      ; r5 = 0s0BGGR0
        AND     r6, r3, #&00F           ; r6 = 0000000R
        ORR     r5, r5, r6              ; r5 = 0s0BGGRR
        AND     r6, r3, #&F00           ; r6 = 00000B00
        ORR     r3, r5, r6, LSL #12     ; r3 = 0sBBGGRR

        ANDS    r5, r4, #1 :SHL: 12     ; get supremacy bit in EOR mask
        MOVNE   r5, #1 :SHL: 27         ; put in r5 in new position
        AND     r6, r4, #&FF0           ; r6 = 00000BG0
        ORR     r5, r5, r6, LSL #8      ; r5 = 0s0BG000
        AND     r6, r4, #&0FF           ; r6 = 000000GR
        ORR     r5, r5, r6, LSL #4      ; r5 = 0s0BGGR0
        AND     r6, r4, #&00F           ; r6 = 0000000R
        ORR     r5, r5, r6              ; r5 = 0s0BGGRR
        AND     r6, r4, #&F00           ; r6 = 00000B00
        ORR     r4, r5, r6, LSL #12     ; r5 = 0sBBGGRR
        B       UpdateSettingCommon


; UpdateSettingAndVIDC
;
; in:   r0 = logical colour (border = 4 << 28, pointer colours = 5,6,7 << 28)
;       r1 = bit mask of which flash states to update (bit 0 set => 1st, bit 1 set => 2nd)
;       r2 = BBGGRRS0
;
; out:  r0, r1, r2 preserved
;       r3, r4 corrupted
;

UpdateSettingAndVIDC ALTENTRY

        ;amg: changed to handle 4 bits of supremacy

        MOV     r3, r2, LSR #8          ; r3 = 00bbggrr
        ANDS    r2, r2, #&F0            ; r2 = 000000s0
        ORRNE   r3, r3, r2, LSL #20     ; r3 = 0sbbggrr

        MOV     r4, #0                  ; indicate no EORing between parts

; ... and drop thru to

; UpdateSettingCommon
;
; in:   r0 = logical colour (border = 4 << 28, pointer colours = 5,6,7 << 28)
;       r1 = bit mask of which flash states to update (bit 0 set => 1st, bit 1 set => 2nd)
;       r3 = 0sBBGGRR   (s in bits 24-27)
;       r2, r5, r6, r7, lr stacked
;
; out:  r0, r1, r2, r4 preserved
;       r3 corrupted
;
UpdateSettingCommon ROUT
        PHPSEI                          ; protect against IRQs

        Push    "r0, r8, r9"
        MOV     r7, #VIDC

        TST     r0, #&40000000          ; if border or pointer
        ORRNE   r3, r3, r0              ; then merge with RGB
        MOVNE   r0, r0, LSR #28         ; and make r0 into index for soft copy
        ADDNE   r0, r0, #(256-4)        ; ie 256, 257, 258 or 259

        ORREQ   r5, r0, #VIDCPalAddress ; else set up palette index register
        STREQ   r5, [r7]

        LDRB    r5, [WsPtr, #ScreenBlankFlag]
        TEQ     r5, #0
        MOVNE   r5, #&0FFFFFFF          ; bits to knock out if blanked (EBBGGRR)

        LDROSB  r2, FlashState          ; 0 => second, 1 => first
        CMP     r2, #1                  ; C=0 => second, C=1 => first

        TST     r1, #1
        BEQ     %FT10                   ; skip if not setting 1st colour
        LDR     r2, [WsPtr, #FirPalAddr]
        ADD     r8, r2, #(256+1+3)*4*4  ; r8 -> rgb transfer tables
        STR     r3, [r2, r0, LSL #2]!   ; store in logical colour and write back pointer
        AND     r6, r3, #&FF            ; r6 = red
        LDRB    r6, [r8, r6]            ; r6 = gamma(red)
        ADD     r8, r8, #&100           ; r8 -> green transfer
        AND     r9, r3, #&FF00          ; r9 = green << 8
        LDRB    r9, [r8, r9, LSR #8]    ; r9 = gamma(green)
        ORR     r6, r6, r9, LSL #8      ; r6 = gamma(red) + (gamma(green)<<8)
        ADD     r8, r8, #&100           ; r8 -> blue transfer
        AND     r9, r3, #&FF0000        ; r9 = blue << 16
        LDRB    r9, [r8, r9, LSR #16]   ; r9 = gamma(blue)
        ORR     r6, r6, r9, LSL #16     ; r6 = gamma(red) + (gamma(green)<<8) + (gamma(blue)<<16)
        AND     r9, r3, #&FF000000      ; knock out rgb from original
        ORR     r6, r6, r9              ; and or in new bits
        STR     r6, [r2, #(256+1+3)*4*2] ; store in physical copy

        BICCS   r6, r6, r5              ; knock out bits for blanking
   [ LCDSupport
        Push    "lr", CS
        BLCS    Poke_VIDC
        Pull    "lr", CS
   |
        STRCS   r6, [r7]                ; poke VIDC if setting 1st colour and in 1st state
   ]
10
        EOR     r3, r3, r4              ; toggle requested bits for 2nd half
        TST     r1, #2
        BEQ     %FT20                   ; skip if not setting 2nd colour
        LDR     r2, [WsPtr, #SecPalAddr]
        ADD     r8, r2, #(256+1+3)*4*3  ; r8 -> rgb transfer tables
        STR     r3, [r2, r0, LSL #2]!   ; store in logical copy and write back

        AND     r6, r3, #&FF            ; r6 = red
        LDRB    r6, [r8, r6]            ; r6 = gamma(red)
        ADD     r8, r8, #&100           ; r8 -> green transfer
        AND     r9, r3, #&FF00          ; r9 = green << 8
        LDRB    r9, [r8, r9, LSR #8]    ; r9 = gamma(green)
        ORR     r6, r6, r9, LSL #8      ; r6 = gamma(red) + (gamma(green)<<8)
        ADD     r8, r8, #&100           ; r8 -> blue transfer
        AND     r9, r3, #&FF0000        ; r9 = blue << 16
        LDRB    r9, [r8, r9, LSR #16]   ; r9 = gamma(blue)
        ORR     r6, r6, r9, LSL #16     ; r6 = gamma(red) + (gamma(green)<<8) + (gamma(blue)<<16)
        AND     r9, r3, #&FF000000      ; knock out rgb from original
        ORR     r6, r6, r9              ; and or in new bits
        STR     r6, [r2, #(256+1+3)*4*2] ; store in physical copy

        BICCC   r6, r6, r5              ; knock out bits for blanking
   [ LCDSupport
        Push    "lr", CC
        BLCC    Poke_VIDC
        Pull    "lr", CC
   |
        STRCC   r6, [r7]                ; poke VIDC if setting 2nd colour and in 2nd state
   ]
20
        PLP
        Pull    "r0, r8, r9"
        EXITS                           ; restore registers, claim vector

; *****************************************************************************
;
; PV_BulkRead - Read multiple palette entries with one call
;
; in:   R0 => list of colours wanted, or 0 to start with first and increment
;       R1 =  b24-b31 - colour type: 16/17/18/24/25
;             b00-b23 - number of colours to do
;
;       R2 => memory for first flash state colours (and second if R3=0)
;       R3 => memory for second flash state colours (if 0, intermingle with R2 instead)
;
; out:  all preserved (R4 set to 0 to show call handled)

; flags used to control routine

PV_BR_WantFirst *       1               ; doing 16 or 17
PV_BR_WantSecond *      2               ; doing 16 or 18
PV_BR_HaveList *        4               ; we have a list of colours
PV_BR_TwoLists *        8               ; we have two output areas (R2 & R3 valid)
PV_BR_Border   *        16              ; doing 24
PV_BR_Mouse    *        32              ; doing 25

PV_BulkRead ROUT
        Push    "R0-R3,R6-R11"             ; return addr already stacked

        MOV     R6,R1,LSR #24           ; isolate the colour type

        MOV     R7,#(PV_BR_WantFirst + PV_BR_WantSecond)

        CMP     R6,#17                  ; do we want both flash states ?
        BICEQ   R7,R7,#PV_BR_WantSecond ; if 17 only want first flash state

        CMP     R6,#18
        BICEQ   R7,R7,#PV_BR_WantFirst  ; if 18 only want second flash state

        CMP     R6,#24
        ORREQ   R7,R7,#PV_BR_Border
        ORRGT   R7,R7,#PV_BR_Mouse

        ;now set up other control flags
        CMP     R0,#0
        ORRNE   R7,R7,#PV_BR_HaveList   ; we have a list of colours

        CMP     R3,#0
        ORRNE   R7,R7,#PV_BR_TwoLists   ; we have two output areas

        ;set up a mask for the number of colours
        LDR     R8,[WsPtr,#DisplayNColour]
        TEQ     R8,#63
        MOVEQ   R8,#255                 ; deal with braindamaged 8BPP case

        ;the mouse has colours 1-3
        TST     R7,#PV_BR_Mouse
        MOVNE   R8,#3

        ;take the colour type off the top of R1, leaving #colours wanted
        BIC     R1,R1,#&FF000000

        ; register usage:
        ; [R0]: colour list
        ; R1: number of colours
        ; [R2]: first flash state list
        ; [R3]: second flash state list
        ; R7: control flags
        ; R8: mask for colour number
        ; R9: loop counter
        ; R10: misc
        ; LR: misc

        MOV     R9,#0
30
        TST     R7,#PV_BR_HaveList
        LDRNE   LR,[R0],#4
        MOVEQ   LR,R9                   ; LR = wanted colour number

        AND     LR,LR,R8                ; ensure it is sensible

        TST     R7,#PV_BR_Border
        MOVNE   LR,#256                 ; border is stored as colour 256

        TST     R7,#PV_BR_Mouse
        BEQ     %FT40

        TEQ     LR,#0
        BEQ     %FT50                   ;colour 0 is invalid
        ADD     LR,LR,#256              ;bring into range (257-259)

40
        TST     R7,#PV_BR_WantFirst

        LDRNE   R10,[WsPtr,#FirPalAddr]

        LDRNE   R10,[R10,LR,LSL#2]      ; xsbbggrr - could be 4 sup. bits
        MOVNE   R11,R10,LSL #8          ; bbggrr00
        ANDNE   R10,R10,#&0F000000      ; 0s000000
        ORRNE   R11,R11,R10,LSR #20     ; bbggrrs0
        STRNE   R11,[R2],#4

        TST     R7,#PV_BR_WantSecond
        BEQ     %FT60                   ; have to use a branch here - another TST coming up

        LDR     R10,[WsPtr,#SecPalAddr]

        LDR     R10,[R10,LR,LSL#2]      ; xsbbggrr
        MOV     R11,R10,LSL #8          ; bbggrr00
        ANDNE   R10,R10,#&0F000000      ; 0s000000
        ORR     R11,R11,R10,LSR #20     ; bbggrrs0

        TST     R7,#PV_BR_TwoLists

        STREQ   R11,[R2],#4
        STRNE   R11,[R3],#4

60      ADD     R9,R9,#1
        CMP     R9,R1
        BCC     %BT30
50
        MOV     R4,#0
        Pull    "R0-R3,R6-R11,PC"          ; return addr already stacked


; *****************************************************************************
;
;       PV_ReadPalette - PaletteV read palette handler
;
; in:   R0 = logical colour
;       R1 = 16 (read normal colour)
;            24 (read border colour)
;            25 (read cursor colour)
;
; out:  R2 = first flash setting   (BBGGRRS0), supremacy bits 4-7
;       R3 = second flash setting  (BBGGRRS0), supremacy bits 4-7
;

PV_ReadPalette ROUT
        Push    "r10,r11"
        LDR     r10, [WsPtr, #DisplayNColour] ; logical colours in this mode -1
        TEQ     r10, #63                ; if bodgy 256 colour mode
        MOVEQ   r10, #255               ; then use AND mask of 255

        TEQ     r1, #24                 ; is it reading border palette
        MOVEQ   r11, #&100              ; then set up border index
        BEQ     %FT10                   ; and go

        TEQ     r1, #25                 ; is it reading pointer palette
        BEQ     %FT05
        AND     r11, r0, r10            ; no, then force into suitable range
        B       %FT10                   ; always skip
05
        ANDS    r11, r0, #3             ; else force logical colour 0..3
        BEQ     %FT99                   ; and 0 is illegal, so do nothing
        ADD     r11, r11, #&100         ; set up correct index
10

; note no need to fudge 256-colour modes, since we have the correct full 256 entry palette

; bjga: changed to handle 4 bits of supremacy (BulkRead already does)

        LDR     r10, [WsPtr, #FirPalAddr]
        LDR     r10, [r10, r11, LSL #2] ; r10 := 1st XSBBGGRR
        MOV     r2, r10, LSL #8         ; r2  := 1st BBGGRR00
        AND     r10, r10, #&0F000000    ; r10 := 1st 0S000000
        ORR     r2, r2, r10, LSR #20    ; r2  := 1st BBGGRRS0

        LDR     r10, [WsPtr, #SecPalAddr]
        LDR     r10, [r10, r11, LSL #2] ; r10 := 2nd XSBBGGRR
        MOV     r3, r10, LSL #8         ; r3  := 2nd BBGGRR00
        AND     r10, r10, #&0F000000    ; r10 := 2nd 0S000000
        ORR     r3, r3, r10, LSR #20    ; r3  := 2nd BBGGRRS0
99
        MOV     r4, #0
        Pull    "r10, r11, pc"

; *****************************************************************************
;
;       PV_1stFlashState - PaletteV routine to set first flash state
;

PV_1stFlashState ROUT
        Push    "r0-r3"
        LDR     r0, [WsPtr, #FirPalAddr]
DoR0Flash
        MOV     r1, #256                ; just update normal palette
DoAllUpdate
        ADD     r0, r0, #(256+1+3)*4*2  ; move pointer to physical palette copy
        ADD     r1, r0, r1, LSL #2
        MOV     r2, #VIDC
        MOV     r3, #VIDCPalAddress + 0 ; initialise palette address to 0
        PHPSEI                          ; disable IRQs round this bit
        STR     r3, [r2]

        LDRB    r4, [WsPtr, #ScreenBlankFlag]
        TEQ     r4, #0                  ; if unblanked, leave all bits alone
        MOVNE   r4, #&0FFFFFFF          ; blanked, knock off all bits, except register bits
10
        LDR     r3, [r0], #4
        BIC     r3, r3, r4
   [ LCDSupport
        Push    "r6,r7,r14"
        MOV     r6, r3
        MOV     r7, r2
        BL      Poke_VIDC
        Pull    "r6,r7,r14"
   |
        STR     r3, [r2]
   ]
        TEQ     r0, r1
        BNE     %BT10

        PLP
        MOV     r4, #0
        Pull    "r0-r3, pc"

; *****************************************************************************
;
;       PV_2ndFlashState - PaletteV routine to set second flash state
;

PV_2ndFlashState ROUT
        Push    "r0-r3"
        LDR     r0, [WsPtr, #SecPalAddr]
        B       DoR0Flash

; *****************************************************************************
;
;       UpdateAllPalette - Update all VIDC palette entries
;

UpdateAllPalette Entry "r0-r3"          ; "r0-r3,lr" stacked ready to branch to code
        LDROSB  r0, FlashState
        CMP     r0, #1
        LDRCS   r0, [WsPtr, #FirPalAddr] ; FlashState = 1 => 1st state, 0 => 2nd state
        LDRCC   r0, [WsPtr, #SecPalAddr]
        MOV     r1, #260                ; update normal palette and border/pointer
        B       DoAllUpdate

; *****************************************************************************
;
;       PV_BlankScreen - Blank/unblank screen
;
; in:   R0 = -1 => read blank state
;       R0 = 0 => unblank screen
;       R0 = 1 => blank screen
;
; out:  R0 = old state (0=unblanked, 1=blanked)
;       R4 = 0

PV_BlankScreen ROUT
        Push    "r1-r3"
        LDRB    r3, [WsPtr, #ScreenBlankFlag]
        CMP     r0, #1
        BHI     %FT99

        TEQ     r0, r3                  ; changing to same state? (carry preserved)
        BEQ     %FT99                   ; if so, do nothing

        STRB    r0, [WsPtr, #ScreenBlankFlag] ; update new state
        MOV     r4, #VIDC
        LDRB    r0, [WsPtr, #ScreenBlankDPMSState]
        BCC     %FT50

; blanking

        TST     r0, #1                  ; if hsyncs should be off,
        LDRNE   r1, =HorizSyncWidth + ((1:SHL:14) -1)   ; maximum value in h.sync width register
        STRNE   r1, [r4]

        TST     r0, #2                  ; if vsyncs should be off,
        LDRNE   r1, =VertiSyncWidth + ((1:SHL:13) -1)   ; maximum value in v.sync width register
        STRNE   r1, [r4]

        LDR     r1, [WsPtr, #VIDCExternalSoftCopy]
        AND     r0, r0, #3
        TEQ     r0, #3                                         ; if both syncs off
        BICEQ   r1, r1, #Ext_HSYNCbits :OR: Ext_VSYNCbits
        ORREQ   r1, r1, #Ext_InvertHSYNC :OR: Ext_InvertVSYNC  ; set sync signals to low (less power)
        BIC     r1, r1, #Ext_DACsOn                     ; turn off the DACs
        STR     r1, [r4]

        MOV     r0, #(0 :SHL: 10) :OR: (3 :SHL: 8) ; blank:   video DMA off, continuous refresh
        B       %FT60

50

; unblanking

        LDR     r1, [WsPtr, #VIDCExternalSoftCopy]
        STR     r1, [r4]                ; restore DACs and sync type

        TST     r0, #1                  ; if hsyncs were turned off,
        LDRNE   r1, [WsPtr, #HSWRSoftCopy] ; then restore from soft copy
        STRNE   r1, [r4]

        TST     r0, #2                  ; if vsyncs were turned off,
        LDRNE   r1, [WsPtr, #VSWRSoftCopy] ; then restore from soft copy
        STRNE   r1, [r4]

        MOV     r0, #(1 :SHL: 10) :OR: (0 :SHL: 8) ; unblank: video DMA on, no refresh
60
        MOV     r1, #(1 :SHL: 10) :OR: (3 :SHL: 8) ; bits to modify
        SWI     XOS_UpdateMEMC

        PHPSEI  r0, lr                  ; disable IRQs so we don't get a flash in the middle
        BL      UpdateAllPalette        ; update all palette, including border + pointer
        PLP     r0                      ; restore old IRQ state
99
        MOV     r0, r3
        MOV     r4, #0
        Pull    "r1-r3, pc"


; *****************************************************************************
;
;       PV_GammaCorrect - Update gamma correction tables
;
; in:   r0 -> red table
;       r1 -> green table
;       r2 -> blue table
;
; out:  r4 = 0

PV_GammaCorrect ROUT
        Push    "r0-r3,r5-r8"
        LDR     r4, [WsPtr, #FirPalAddr]
        ADD     r4, r4, #(256+1+3)*4*4          ; point to gamma tables
        ADD     r3, r4, #256
10
        LDR     lr, [r0], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT10

        ADD     r3, r4, #256
20
        LDR     lr, [r1], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT20

        ADD     r3, r4, #256
30
        LDR     lr, [r2], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT30

; now go through the logical palette, recomputing the physical from it using the new tables

        SUB     r0, r4, #3*256                  ; r0 -> red table
        SUB     r1, r4, #2*256                  ; r1 -> green table
        SUB     r2, r4, #1*256                  ; r2 -> blue table

        LDR     r4, [WsPtr, #FirPalAddr]        ; r4 -> start of logical palette
        ADD     r5, r4, #260*4*2                ; r5 -> start of physical palette
        MOV     r6, r5                          ; r6 = r5 = end of logical palette
40
        LDR     r7, [r4], #4                    ; get word
        AND     r8, r7, #&FF                    ; r8 = red
        LDRB    r8, [r0, r8]                    ; r8 = gamma(red)
        AND     lr, r7, #&FF00                  ; lr = green << 8
        LDRB    lr, [r1, lr, LSR #8]            ; lr = gamma(green)
        ORR     r8, r8, lr, LSL #8              ; r8 = gamma(red) + (gamma(green)<<8)
        AND     lr, r7, #&FF0000                ; lr = blue << 16
        LDRB    lr, [r2, lr, LSR #16]           ; lr = gamma(blue)
        ORR     r8, r8, lr, LSL #16             ; r8 = gamma(red) + (gamma(green)<<8) + (gamma(blue)<<16)
        AND     lr, r7, #&FF000000              ; lr = other bits
        ORR     r8, r8, lr                      ; r8 = gamma-corrected combined value
        STR     r8, [r5], #4                    ; store word
        TEQ     r4, r6
        BNE     %BT40

        BL      UpdateAllPalette

        MOV     r4, #0
        Pull    "r0-r3,r5-r8, pc"


 [ LCDInvert
; *****************************************************************************
;
;       PV_LCDInvert - Invert the LCD palette
;
; in:   r0 = inversion state to use (0=uninverted, 1=inverted)
;
; out:  r4 = 0

PV_LCDInvert ROUT
        MOV     r4, #0
        STRB    r0, [r4, #LCD_Inverted]

        BL      UpdateAllPalette
        MOV     r4, #0
        Pull    "pc"
 ]

 [ StorkPowerSave
; *****************************************************************************
PV_VIDCDisable
        ROUT
        Push    "r2"

        MOV     r4, #VIDC

        LDR     r2, =&C0000003    ;dac off, ereg set to external LUT
        STR     r2, [r4]

        LDR     r2, =&D0004000    ;Vclk off, Pcomp=0
        STR     r2, [r4]

        LDR     r2, =&E0004049    ;PoDown, Hclk
        STR     r2, [r4]

        MOV     r4, #0
        Pull    "r2, pc"

; *****************************************************************************
PV_VIDCRestore
        ROUT
        Push    "r2,r3,R8"
        MOV     r3, #VIDC

        LDR     r2, [WsPtr, #VIDCControlSoftCopy]       ;restore from soft copy
        STR     r2, [r3]

        LDR     r2, [WsPtr, #VIDCExternalSoftCopy]      ;restore from soft copy
        STR     r2, [r3]

        LDR     r2, [WsPtr, #VIDCFSynSoftCopy]          ;restore from soft copy
 [ 1 = 1
        LDR     R8, =FSyn_ResetValue    ; set test bits on, and r > v
        STR     R8, [R3]

; we may need some delay in here...

        LDR     R8, =FSyn_ClearR :OR: FSyn_ClearV :OR: FSyn_ForceLow :OR: FSyn_ForceHigh
        ORR     R2, R2, R8
        BIC     R2, R2, #FSyn_ForceHigh ; force test bits on, except this one
        STR     R2, [R3]

; we may also need some delay in here...

        BIC     R2, R2, R8              ; remove test bits
 ]
        STR     r2, [r3]


        MOV     r4, #0
        Pull    "r2,r3,R8, pc"
 ]
; *****************************************************************************
;
;       Poke_VIDC
;
; in:   r6 = CRT palette VIDC entry &AeBbGgRr (where A is the VIDC register 'address')
;       r7 = address to poke
;
; out:  all registers preserved
;
; NOTE: If LCD_Active in the KernelWS != 0, the value bunged into VIDC is the
; value required by the greyscaler to approximate the luminance of r6 on entry.

Poke_VIDC
        EntryS  "r0-r4"
 [ :LNOT: STB
        MOV     r0, #0
        LDRB    r0, [r0, #LCD_Active]
        CMP     r0, #0
        STREQ   r6,[r7]         ;Ho hum, it's a CRT, so no mucking about
        EXITS   EQ
 ]

        MOV     r0, #&0f
        AND     r4, r0, r6, LSR #28     ;r4 = VIDC register 'address' (in bottom 4 bits)
        MOV     r0, #&ff
        AND     r2, r0, r6, LSR #16     ;r2 = blue
        AND     r1, r0, r6, LSR #8      ;r1 = green
        ADD     r2, r2, r1, LSL #2      ;r2 = 4green + blue
        AND     r1, r0, r6              ;r1 = red
        ADD     r2, r2, r1, LSL #1      ;r2 = 4green + 2red + blue  - _Very_ approx CIE weightings!

 [ :LNOT: STB
        MOV     r0, #0
        LDRB    r0, [r0, #LCD_Inverted]
        CMP     r0, #0
        MOVNE   r0, #255
        RSBNE   r0, r0, r0, LSL #3      ;Move 1785 into R0
        RSBNE   r2, r2, r0
 ]
        ADR     r3, NewPalTab           ; perform binary chop using table (lifted from PortableA4 module, with added comments)

        LDR     r0, [r3, #8*4]                  ;read the middle table value
        CMP     r2, r0
        ADDCC   r1, r3, #0*4
        ADDCS   r1, r3, #8*4
        LDR     r0, [r1, #4*4]
        CMP     r2, r0
        ADDCS   r1, r1, #4*4
        LDR     r0, [r1, #2*4]
        CMP     r2, r0
        ADDCS   r1, r1, #2*4
        LDR     r0, [r1, #1*4]
        CMP     r2, r0
        ADDCS   r1, r1, #1*4
        SUB     r3, r1, r3

        MOV     r2, r3, LSR #2          ;R2 is now in the range 0-14
        CMP     r2, #7
        ADDGT   r2, r2, #1              ;Now R2 in range 0-7,9-15
        AND     r2, r2, #&0f            ;Just to be on the safe side....

        ORR     r2, r2, r2, LSL #8
        ORR     r2, r2, r2, LSL #16     ;Now &0x0x0x0x (where x is 0-7,9-15)
        ORR     r2, r2, r4, LSL #28     ;Now &Ax0x0x0x (A is the VIDC address)
        STR     r2, [r7]                ;And into the VIDC we go!

        EXITS

NewPalTab
        DCD     0, 119, 238, 357, 476, 595, 714, 833, 953, 1072, 1191, 1310, 1429, 1548, 1667, -1

        END
@


4.7
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@@


4.6
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d17 5
a42 1
 [ GammaCorrection
a43 1
 ]
a66 2

 [ GammaCorrection
a67 1
 ]
d470 1
a470 1
        TST     lr, #Flag_BBCGapMode
a563 1
 [ GammaCorrection
a645 53
 |
UpdateSettingCommon ROUT
        PHPSEI                          ; protect against IRQs

        Push    "r0"
        MOV     r7, #VIDC

        TST     r0, #&40000000          ; if border or pointer
        ORRNE   r3, r3, r0              ; then merge with RGB
        MOVNE   r0, r0, LSR #28         ; and make r0 into index for soft copy
        ADDNE   r0, r0, #(256-4)        ; ie 256, 257, 258 or 259

        ORREQ   r5, r0, #VIDCPalAddress ; else set up palette index register
        STREQ   r5, [r7]

        LDRB    r5, [WsPtr, #ScreenBlankFlag]
        TEQ     r5, #0
        MOVNE   r5, #&0FFFFFFF          ; bits to knock out if blanked (EBBGGRR)

        LDROSB  r2, FlashState          ; 0 => second, 1 => first
        CMP     r2, #1                  ; C=0 => second, C=1 => first

        TST     r1, #1
        BEQ     %FT10                   ; skip if not setting 1st colour
        LDR     r2, [WsPtr, #FirPalAddr]
        STR     r3, [r2, r0, LSL #2]
        BICCS   r6, r3, r5              ; knock out bits for blanking
   [ LCDSupport
        Push    "lr", CS
        BLCS    Poke_VIDC
        Pull    "lr", CS
   |
        STRCS   r6, [r7]                ; poke VIDC if setting 1st colour and in 1st state
   ]
10
        EOR     r3, r3, r4              ; toggle requested bits for 2nd half
        TST     r1, #2
        BEQ     %FT20                   ; skip if not setting 2nd colour
        LDR     r2, [WsPtr, #SecPalAddr]
        STR     r3, [r2, r0, LSL #2]
        BICCC   r6, r3, r5              ; knock out bits for blanking
   [ LCDSupport
        Push    "lr", CC
        BLCC    Poke_VIDC
        Pull    "lr", CC
   |
        STRCC   r6, [r7]                ; poke VIDC if setting 2nd colour and in 2nd state
   ]
20
        PLP
        Pull    "r0"
        EXITS                           ; restore registers, claim vector
 ]
a830 1
 [ GammaCorrection
a831 1
 ]
d875 1
a875 1
UpdateAllPalette ENTRY "r0-r3"          ; "r0-r3,lr" stacked ready to branch to code
a956 1
 [ GammaCorrection
a1021 1
 ]
@


4.6.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d931 1
a931 1
UpdateAllPalette Entry "r0-r3"          ; "r0-r3,lr" stacked ready to branch to code
@


4.6.2.2
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@a16 5
; mjs Sep 2000
;
; not used any more, since kernel/HAL split
; vdupalxx is the file now used for generic palette programming 

d38 1
d40 1
d64 2
d67 1
d564 1
d647 53
d885 1
d887 1
d1013 1
d1079 1
@


4.6.2.3
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d470 1
a470 1
        TST     lr, #ModeFlag_BBCGapMode
@


4.5
log
@PaletteV bulk read of pointer colours now works correctly in 1bpp modes.

Version 5.21. Tagged as 'Kernel-5_21'
@
text
@d51 1
a51 1
        MOVCCS  pc, lr
d73 1
a73 1
        MOVEQS  pc, lr
d77 1
a77 1
        MOVEQS  pc, lr
d79 1
a79 1
        MOVS    pc, lr                  ; reason code not known, so pass it on
d119 4
a122 3
        BLCC    UpdateSettingStraightRGB
        ADDCC   r0, r0, #1
        BCC     %BT20
d412 1
a412 1
        MOVS    pc, lr                  ; else not defined
d507 1
a507 1
UpdateSettingStraightRGB ENTRY "r2,r5,r6,r7"
d1005 1
a1005 3
        MOV     r0, pc
        ORR     lr, r0, #I_bit          ; disable IRQs so we don't get a flash in the middle
        TEQP    lr, #0
d1007 1
a1007 1
        TEQP    r0, #0                  ; restore old IRQ state
d1167 1
a1167 1
        Push    "r0-r4,lr"
d1173 1
a1173 1
        Pull    "r0-r4,pc",EQ,^
d1220 1
a1220 1
        Pull    "r0-r4,pc",,^
@


4.4
log
@Changed default PaletteV handler so that read palette reason code returns all
four supremacy bits in the palette entries (previously it cleared all except
bit 7). This brings it into line with the bulk read reason code.

Version 5.11. Tagged as 'Kernel-5_11'
@
text
@d751 4
a782 1
        ANDS    LR,LR,#3
@


4.3
log
@Fixed error in RDCH speed restoring logic.
When screen is blanked, DACs are turned off (60mA saving).
If DPMS state 3 comes on, sync lines are set low.

Version 4.96. Tagged as 'Kernel-4_96'
@
text
@d827 2
a828 2
; out:  R2 = first flash setting   (BBGGRRS0), supremacy bit 7
;       R3 = second flash setting  (BBGGRRS0), supremacy bit 7
d853 2
d858 2
a859 2
        TST     r10, #1 :SHL: 27
        ORRNE   r2, r2, #&80            ; r2  := 1st BBGGRRS0
d864 2
a865 2
        TST     r10, #1 :SHL: 27
        ORRNE   r3, r3, #&80            ; r3  := 2nd BBGGRRS0
@


4.2
log
@Kernel merged
@
text
@d963 1
d968 8
d983 3
d989 1
d1170 1
a1170 1
 ]       
@


4.2.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d38 1
d40 1
d65 1
d67 1
d563 1
d646 53
d879 1
d881 1
d996 1
d1062 1
d1116 1
a1116 1

d1130 2
a1132 1
        STR     r2, [r3]
@


4.2.2.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d1088 1
d1094 1
d1105 1
d1112 1
@


4.2.2.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d1088 1
d1094 1
d1105 1
d1112 1
@


4.1
log
@Initial revision
@
text
@d37 2
a38 2
        ASSERT  paletteV_BulkWrite = 8      
 [ GammaCorrection        
d40 8
a47 1
 ]       
d64 1
a64 1
        
d68 11
d241 13
a253 13
        DCW     &0333 
        DCW     &0444 
        DCW     &0555 
        DCW     &0666 
        DCW     &0777 
        DCW     &0888 
        DCW     &0999 
        DCW     &0AAA 
        DCW     &0BBB 
        DCW     &0CCC 
        DCW     &0DDD 
        DCW     &0EEE 
        DCW     &0FFF 
d315 1
a315 1
;       otherwise preserve R4 and pass on                       
d319 1
a319 1
                      
d459 1
a459 1
BorderColour ROUT   
d484 1
a484 1
PointerColour ROUT  
d495 1
a495 1
        
d605 5
d611 1
d635 5
d641 1
d673 5
d679 1
d687 5
d693 1
d704 1
a704 1
; in:   R0 => list of colours wanted, or 0 to start with first and increment 
d712 1
a712 1
                                                                    
d721 1
a721 1
                    
d724 1
a724 1
                    
d726 1
a726 1
        
d728 1
a728 1
   
d731 1
a731 1
        
d735 1
a735 1
        CMP     R6,#24                      
d738 1
a738 1
        
d742 1
a742 1
        
d745 1
a745 1
                           
d750 1
a750 1
                          
d753 1
a753 1
        
d759 1
a759 1
        ; R7: control flags   
d764 1
a764 1
        
d772 1
a772 1
   
d775 1
a775 1
        
d778 1
a778 1
        
d783 2
a784 2
   
40        
d786 3
a788 3
        
        LDRNE   R10,[WsPtr,#FirPalAddr]             
        
d794 1
a794 1
        
d797 3
a799 3
        
        LDR     R10,[WsPtr,#SecPalAddr]           
        
d801 1
a801 1
        MOV     R11,R10,LSL #8          ; bbggrr00 
d809 1
a809 1
        
d813 2
a814 2
50                                
        MOV     R4,#0                                                
d894 7
d902 1
d1063 145
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d37 2
a38 2
        ASSERT  paletteV_BulkWrite = 8
 [ GammaCorrection
d40 1
a40 8
 ]
 [ LCDInvert
        ASSERT  paletteV_LCDInvert = 10
 ]
 [ StorkPowerSave
        ASSERT  paletteV_VIDCDisable = 12
        ASSERT  paletteV_VIDCRestore = 13
 ]
d57 1
a57 1

a60 11
 [ LCDInvert
        CMP     r4, #11
        BCC     PV_LCDInvert
 ]
 [ StorkPowerSave
        MOVEQS  pc, lr
        CMP     r4, #13
        BCC     PV_VIDCDisable
        BEQ     PV_VIDCRestore
        MOVEQS  pc, lr
 ]
d223 13
a235 13
        DCW     &0333
        DCW     &0444
        DCW     &0555
        DCW     &0666
        DCW     &0777
        DCW     &0888
        DCW     &0999
        DCW     &0AAA
        DCW     &0BBB
        DCW     &0CCC
        DCW     &0DDD
        DCW     &0EEE
        DCW     &0FFF
d297 1
a297 1
;       otherwise preserve R4 and pass on
d301 1
a301 1

d441 1
a441 1
BorderColour ROUT
d466 1
a466 1
PointerColour ROUT
d477 1
a477 1

a586 5
   [ LCDSupport
        Push    "lr", CS
        BLCS    Poke_VIDC
        Pull    "lr", CS
   |
a587 1
   ]
a610 5
   [ LCDSupport
        Push    "lr", CC
        BLCC    Poke_VIDC
        Pull    "lr", CC
   |
a611 1
   ]
a642 5
   [ LCDSupport
        Push    "lr", CS
        BLCS    Poke_VIDC
        Pull    "lr", CS
   |
a643 1
   ]
a650 5
   [ LCDSupport
        Push    "lr", CC
        BLCC    Poke_VIDC
        Pull    "lr", CC
   |
a651 1
   ]
d662 1
a662 1
; in:   R0 => list of colours wanted, or 0 to start with first and increment
d670 1
a670 1

d679 1
a679 1

d682 1
a682 1

d684 1
a684 1

d686 1
a686 1

d689 1
a689 1

d693 1
a693 1
        CMP     R6,#24
d696 1
a696 1

d700 1
a700 1

d703 1
a703 1

d708 1
a708 1

d711 1
a711 1

d717 1
a717 1
        ; R7: control flags
d722 1
a722 1

d730 1
a730 1

d733 1
a733 1

d736 1
a736 1

d741 2
a742 2

40
d744 3
a746 3

        LDRNE   R10,[WsPtr,#FirPalAddr]

d752 1
a752 1

d755 3
a757 3

        LDR     R10,[WsPtr,#SecPalAddr]

d759 1
a759 1
        MOV     R11,R10,LSL #8          ; bbggrr00
d767 1
a767 1

d771 2
a772 2
50
        MOV     R4,#0
a851 7
   [ LCDSupport
        Push    "r6,r7,r14"
        MOV     r6, r3
        MOV     r7, r2
        BL      Poke_VIDC
        Pull    "r6,r7,r14"
   |
a852 1
   ]
a1012 142


 [ LCDInvert
; *****************************************************************************
;
;       PV_LCDInvert - Invert the LCD palette
;
; in:   r0 = inversion state to use (0=uninverted, 1=inverted)
;
; out:  r4 = 0

PV_LCDInvert ROUT
        MOV     r4, #0
        STRB    r0, [r4, #LCD_Inverted]

        BL      UpdateAllPalette
        MOV     r4, #0
        Pull    "pc"
 ]

 [ StorkPowerSave
; *****************************************************************************
PV_VIDCDisable
        ROUT
        Push    "r2"

        MOV     r4, #VIDC

        LDR     r2, =&C0000003    ;dac off, ereg set to external LUT
        STR     r2, [r4]

        LDR     r2, =&D0004000    ;Vclk off, Pcomp=0
        STR     r2, [r4]

        LDR     r2, =&E0004049    ;PoDown, Hclk
        STR     r2, [r4]

        MOV     r4, #0
        Pull    "r2, pc"

; *****************************************************************************
PV_VIDCRestore
        ROUT
        Push    "r2,r3,R8"
        MOV     r3, #VIDC

        LDR     r2, [WsPtr, #VIDCControlSoftCopy]       ;restore from soft copy
        STR     r2, [r3]

        LDR     r2, [WsPtr, #VIDCExternalSoftCopy]      ;restore from soft copy
        STR     r2, [r3]

        LDR     r2, [WsPtr, #VIDCFSynSoftCopy]          ;restore from soft copy
 [ 1 = 1
        LDR     R8, =FSyn_ResetValue    ; set test bits on, and r > v
        STR     R8, [R3]

; we may need some delay in here...

        LDR     R8, =FSyn_ClearR :OR: FSyn_ClearV :OR: FSyn_ForceLow :OR: FSyn_ForceHigh
        ORR     R2, R2, R8
        BIC     R2, R2, #FSyn_ForceHigh ; force test bits on, except this one
        STR     R2, [R3]

; we may also need some delay in here...

        BIC     R2, R2, R8              ; remove test bits
 ]
        STR     r2, [r3]


        MOV     r4, #0
        Pull    "r2,r3,R8, pc"
 ]
; *****************************************************************************
;
;       Poke_VIDC
;
; in:   r6 = CRT palette VIDC entry &AeBbGgRr (where A is the VIDC register 'address')
;       r7 = address to poke
;
; out:  all registers preserved
;
; NOTE: If LCD_Active in the KernelWS != 0, the value bunged into VIDC is the
; value required by the greyscaler to approximate the luminance of r6 on entry.

Poke_VIDC
        Push    "r0-r4,lr"
        MOV     r0, #0
        LDRB    r0, [r0, #LCD_Active]
        CMP     r0, #0
        STREQ   r6,[r7]         ;Ho hum, it's a CRT, so no mucking about
        Pull    "r0-r4,pc",EQ,^

        MOV     r0, #&0f
        AND     r4, r0, r6, LSR #28     ;r4 = VIDC register 'address' (in bottom 4 bits)
        MOV     r0, #&ff
        AND     r2, r0, r6, LSR #16     ;r2 = blue
        AND     r1, r0, r6, LSR #8      ;r1 = green
        ADD     r2, r2, r1, LSL #2      ;r2 = 4green + blue
        AND     r1, r0, r6              ;r1 = red
        ADD     r2, r2, r1, LSL #1      ;r2 = 4green + 2red + blue  - _Very_ approx CIE weightings!

        MOV     r0, #0
        LDRB    r0, [r0, #LCD_Inverted]
        CMP     r0, #0
        MOVNE   r0, #255
        RSBNE   r0, r0, r0, LSL #3      ;Move 1785 into R0
        RSBNE   r2, r2, r0

        ADR     r3, NewPalTab           ; perform binary chop using table (lifted from PortableA4 module, with added comments)

        LDR     r0, [r3, #8*4]                  ;read the middle table value
        CMP     r2, r0
        ADDCC   r1, r3, #0*4
        ADDCS   r1, r3, #8*4
        LDR     r0, [r1, #4*4]
        CMP     r2, r0
        ADDCS   r1, r1, #4*4
        LDR     r0, [r1, #2*4]
        CMP     r2, r0
        ADDCS   r1, r1, #2*4
        LDR     r0, [r1, #1*4]
        CMP     r2, r0
        ADDCS   r1, r1, #1*4
        SUB     r3, r1, r3

        MOV     r2, r3, LSR #2          ;R2 is now in the range 0-14
        CMP     r2, #7
        ADDGT   r2, r2, #1              ;Now R2 in range 0-7,9-15
        AND     r2, r2, #&0f            ;Just to be on the safe side....

        ORR     r2, r2, r2, LSL #8
        ORR     r2, r2, r2, LSL #16     ;Now &0x0x0x0x (where x is 0-7,9-15)
        ORR     r2, r2, r4, LSL #28     ;Now &Ax0x0x0x (A is the VIDC address)
        STR     r2, [r7]                ;And into the VIDC we go!

        Pull    "r0-r4,pc",,^

NewPalTab
        DCD     0, 119, 238, 357, 476, 595, 714, 833, 953, 1072, 1191, 1310, 1429, 1548, 1667, -1

@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.5;
access;
symbols
	Kernel-6_15:4.5
	Kernel-6_14:4.5
	Kernel-6_01-3:4.5
	Kernel-6_13:4.5
	Kernel-6_12:4.5
	Kernel-6_11:4.5
	Kernel-6_10:4.5
	Kernel-6_09:4.5
	Kernel-6_08-4_129_2_10:4.5
	Kernel-6_08-4_129_2_9:4.5
	Kernel-6_08:4.5
	Kernel-6_07:4.5
	Kernel-6_06:4.5
	Kernel-6_05-4_129_2_8:4.5
	Kernel-6_05:4.5
	Kernel-6_04:4.5
	Kernel-6_03:4.5
	Kernel-6_01-2:4.5
	Kernel-6_01-4_146_2_1:4.5
	Kernel-6_02:4.5
	Kernel-6_01-1:4.5
	Kernel-6_01:4.5
	Kernel-6_00:4.5
	Kernel-5_99:4.5
	Kernel-5_98:4.5
	Kernel-5_97-4_129_2_7:4.5
	Kernel-5_97:4.5
	Kernel-5_96:4.5
	Kernel-5_95:4.5
	Kernel-5_94:4.5
	Kernel-5_93:4.5
	Kernel-5_92:4.5
	Kernel-5_91:4.5
	Kernel-5_90:4.5
	Kernel-5_89-4_129_2_6:4.5
	Kernel-5_89:4.5
	Kernel-5_88-4_129_2_5:4.5
	Kernel-5_88-4_129_2_4:4.5
	Kernel-5_88:4.5
	Kernel-5_87:4.5
	Kernel-5_86-4_129_2_3:4.5
	Kernel-5_86-4_129_2_2:4.5
	Kernel-5_86-4_129_2_1:4.5
	Kernel-5_86:4.5
	SMP:4.5.0.2
	SMP_bp:4.5
	Kernel-5_85:4.5
	Kernel-5_54-1:4.5
	Kernel-5_84:4.5
	Kernel-5_83:4.5
	Kernel-5_82:4.5
	Kernel-5_81:4.5
	Kernel-5_80:4.5
	Kernel-5_79:4.5
	Kernel-5_78:4.5
	Kernel-5_77:4.5
	Kernel-5_76:4.5
	Kernel-5_75:4.5
	Kernel-5_74:4.5
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.5
	Kernel-5_64:4.5
	Kernel-5_63:4.5
	Kernel-5_62:4.5
	Kernel-5_61:4.5
	Kernel-5_60:4.5
	Kernel-5_59:4.5
	Kernel-5_58:4.5
	Kernel-5_57:4.5
	Kernel-5_56:4.5
	Kernel-5_55:4.5
	Kernel-5_54:4.5
	Kernel-5_53:4.5
	Kernel-5_52:4.5
	Kernel-5_51:4.5
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.2.2.8
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.8
	Kernel-5_35-4_79_2_326:4.2.2.8
	Kernel-5_35-4_79_2_325:4.2.2.8
	Kernel-5_35-4_79_2_324:4.2.2.8
	Kernel-5_35-4_79_2_323:4.2.2.8
	Kernel-5_35-4_79_2_322:4.2.2.8
	Kernel-5_35-4_79_2_321:4.2.2.8
	Kernel-5_35-4_79_2_320:4.2.2.7
	Kernel-5_35-4_79_2_319:4.2.2.7
	Kernel-5_35-4_79_2_318:4.2.2.7
	Kernel-5_35-4_79_2_317:4.2.2.7
	Kernel-5_35-4_79_2_316:4.2.2.7
	Kernel-5_35-4_79_2_315:4.2.2.7
	Kernel-5_35-4_79_2_314:4.2.2.7
	Kernel-5_35-4_79_2_313:4.2.2.7
	Kernel-5_35-4_79_2_312:4.2.2.7
	Kernel-5_35-4_79_2_311:4.2.2.7
	Kernel-5_35-4_79_2_310:4.2.2.7
	Kernel-5_35-4_79_2_309:4.2.2.7
	Kernel-5_35-4_79_2_308:4.2.2.7
	Kernel-5_35-4_79_2_307:4.2.2.7
	Kernel-5_35-4_79_2_306:4.2.2.7
	Kernel-5_35-4_79_2_305:4.2.2.7
	Kernel-5_35-4_79_2_304:4.2.2.7
	Kernel-5_35-4_79_2_303:4.2.2.7
	Kernel-5_35-4_79_2_302:4.2.2.7
	Kernel-5_35-4_79_2_301:4.2.2.7
	Kernel-5_35-4_79_2_300:4.2.2.7
	Kernel-5_35-4_79_2_299:4.2.2.7
	Kernel-5_35-4_79_2_298:4.2.2.7
	Kernel-5_35-4_79_2_297:4.2.2.7
	Kernel-5_35-4_79_2_296:4.2.2.7
	Kernel-5_35-4_79_2_295:4.2.2.7
	Kernel-5_35-4_79_2_294:4.2.2.7
	Kernel-5_35-4_79_2_293:4.2.2.7
	Kernel-5_35-4_79_2_292:4.2.2.7
	Kernel-5_35-4_79_2_291:4.2.2.7
	Kernel-5_35-4_79_2_290:4.2.2.7
	Kernel-5_35-4_79_2_289:4.2.2.7
	Kernel-5_35-4_79_2_288:4.2.2.7
	Kernel-5_35-4_79_2_287:4.2.2.7
	Kernel-5_35-4_79_2_286:4.2.2.7
	Kernel-5_35-4_79_2_285:4.2.2.7
	Kernel-5_35-4_79_2_284:4.2.2.7
	Kernel-5_35-4_79_2_283:4.2.2.7
	Kernel-5_35-4_79_2_282:4.2.2.7
	Kernel-5_35-4_79_2_281:4.2.2.7
	Kernel-5_35-4_79_2_280:4.2.2.7
	Kernel-5_35-4_79_2_279:4.2.2.7
	Kernel-5_35-4_79_2_278:4.2.2.7
	Kernel-5_35-4_79_2_277:4.2.2.7
	Kernel-5_35-4_79_2_276:4.2.2.7
	Kernel-5_35-4_79_2_275:4.2.2.7
	Kernel-5_35-4_79_2_274:4.2.2.7
	Kernel-5_35-4_79_2_273:4.2.2.7
	Kernel-5_35-4_79_2_272:4.2.2.7
	Kernel-5_35-4_79_2_271:4.2.2.7
	Kernel-5_35-4_79_2_270:4.2.2.7
	Kernel-5_35-4_79_2_269:4.2.2.7
	Kernel-5_35-4_79_2_268:4.2.2.7
	Kernel-5_35-4_79_2_267:4.2.2.7
	Kernel-5_35-4_79_2_266:4.2.2.7
	Kernel-5_35-4_79_2_265:4.2.2.7
	Kernel-5_35-4_79_2_264:4.2.2.7
	Kernel-5_35-4_79_2_263:4.2.2.7
	Kernel-5_35-4_79_2_262:4.2.2.7
	Kernel-5_35-4_79_2_261:4.2.2.7
	Kernel-5_35-4_79_2_260:4.2.2.7
	Kernel-5_35-4_79_2_259:4.2.2.7
	Kernel-5_35-4_79_2_258:4.2.2.7
	Kernel-5_35-4_79_2_257:4.2.2.7
	Kernel-5_35-4_79_2_256:4.2.2.7
	Kernel-5_35-4_79_2_255:4.2.2.7
	Kernel-5_35-4_79_2_254:4.2.2.7
	Kernel-5_35-4_79_2_253:4.2.2.7
	Kernel-5_35-4_79_2_252:4.2.2.7
	Kernel-5_35-4_79_2_251:4.2.2.7
	Kernel-5_35-4_79_2_250:4.2.2.7
	Kernel-5_35-4_79_2_249:4.2.2.7
	Kernel-5_35-4_79_2_248:4.2.2.7
	Kernel-5_35-4_79_2_247:4.2.2.7
	Kernel-5_35-4_79_2_246:4.2.2.7
	Kernel-5_35-4_79_2_245:4.2.2.7
	Kernel-5_35-4_79_2_244:4.2.2.7
	Kernel-5_35-4_79_2_243:4.2.2.7
	Kernel-5_35-4_79_2_242:4.2.2.7
	Kernel-5_35-4_79_2_241:4.2.2.7
	Kernel-5_35-4_79_2_240:4.2.2.7
	Kernel-5_35-4_79_2_239:4.2.2.7
	Kernel-5_35-4_79_2_238:4.2.2.7
	Kernel-5_35-4_79_2_237:4.2.2.7
	Kernel-5_35-4_79_2_236:4.2.2.7
	Kernel-5_35-4_79_2_235:4.2.2.7
	Kernel-5_35-4_79_2_234:4.2.2.7
	Kernel-5_35-4_79_2_233:4.2.2.7
	Kernel-5_35-4_79_2_232:4.2.2.7
	Kernel-5_35-4_79_2_231:4.2.2.7
	Kernel-5_35-4_79_2_230:4.2.2.7
	Kernel-5_35-4_79_2_229:4.2.2.7
	Kernel-5_35-4_79_2_228:4.2.2.7
	Kernel-5_35-4_79_2_227:4.2.2.7
	Kernel-5_35-4_79_2_226:4.2.2.7
	Kernel-5_35-4_79_2_225:4.2.2.7
	Kernel-5_35-4_79_2_224:4.2.2.7
	Kernel-5_35-4_79_2_223:4.2.2.7
	Kernel-5_35-4_79_2_222:4.2.2.7
	Kernel-5_35-4_79_2_221:4.2.2.7
	Kernel-5_35-4_79_2_220:4.2.2.7
	Kernel-5_35-4_79_2_219:4.2.2.7
	Kernel-5_35-4_79_2_218:4.2.2.7
	Kernel-5_35-4_79_2_217:4.2.2.7
	Kernel-5_35-4_79_2_216:4.2.2.7
	Kernel-5_35-4_79_2_215:4.2.2.7
	Kernel-5_35-4_79_2_214:4.2.2.7
	Kernel-5_35-4_79_2_213:4.2.2.7
	Kernel-5_35-4_79_2_212:4.2.2.6
	Kernel-5_35-4_79_2_211:4.2.2.6
	Kernel-5_35-4_79_2_210:4.2.2.6
	Kernel-5_35-4_79_2_209:4.2.2.5
	Kernel-5_35-4_79_2_208:4.2.2.5
	Kernel-5_35-4_79_2_207:4.2.2.5
	Kernel-5_35-4_79_2_206:4.2.2.5
	Kernel-5_35-4_79_2_205:4.2.2.5
	Kernel-5_35-4_79_2_204:4.2.2.5
	Kernel-5_35-4_79_2_203:4.2.2.5
	Kernel-5_35-4_79_2_202:4.2.2.5
	Kernel-5_35-4_79_2_201:4.2.2.5
	Kernel-5_35-4_79_2_200:4.2.2.5
	Kernel-5_35-4_79_2_199:4.2.2.5
	Kernel-5_35-4_79_2_198:4.2.2.5
	Kernel-5_35-4_79_2_197:4.2.2.5
	Kernel-5_35-4_79_2_196:4.2.2.4
	Kernel-5_35-4_79_2_195:4.2.2.4
	Kernel-5_35-4_79_2_194:4.2.2.4
	Kernel-5_35-4_79_2_193:4.2.2.3
	Kernel-5_35-4_79_2_192:4.2.2.3
	Kernel-5_35-4_79_2_191:4.2.2.3
	Kernel-5_35-4_79_2_190:4.2.2.3
	Kernel-5_35-4_79_2_189:4.2.2.3
	Kernel-5_35-4_79_2_188:4.2.2.3
	Kernel-5_35-4_79_2_187:4.2.2.3
	Kernel-5_35-4_79_2_186:4.2.2.3
	Kernel-5_35-4_79_2_185:4.2.2.3
	Kernel-5_35-4_79_2_184:4.2.2.3
	Kernel-5_35-4_79_2_183:4.2.2.3
	Kernel-5_35-4_79_2_182:4.2.2.3
	Kernel-5_35-4_79_2_181:4.2.2.3
	Kernel-5_35-4_79_2_180:4.2.2.3
	Kernel-5_35-4_79_2_179:4.2.2.3
	Kernel-5_35-4_79_2_178:4.2.2.3
	Kernel-5_35-4_79_2_177:4.2.2.3
	Kernel-5_35-4_79_2_176:4.2.2.3
	Kernel-5_35-4_79_2_175:4.2.2.3
	Kernel-5_35-4_79_2_174:4.2.2.3
	Kernel-5_35-4_79_2_173:4.2.2.3
	Kernel-5_35-4_79_2_172:4.2.2.3
	Kernel-5_35-4_79_2_171:4.2.2.3
	Kernel-5_35-4_79_2_170:4.2.2.3
	Kernel-5_35-4_79_2_169:4.2.2.3
	Kernel-5_35-4_79_2_168:4.2.2.3
	Kernel-5_35-4_79_2_167:4.2.2.3
	Kernel-5_35-4_79_2_166:4.2.2.3
	Kernel-5_35-4_79_2_165:4.2.2.3
	RPi_merge:4.2.2.3
	Kernel-5_35-4_79_2_147_2_23:4.2.2.3
	Kernel-5_35-4_79_2_147_2_22:4.2.2.3
	Kernel-5_35-4_79_2_147_2_21:4.2.2.3
	Kernel-5_35-4_79_2_147_2_20:4.2.2.3
	Kernel-5_35-4_79_2_147_2_19:4.2.2.3
	Kernel-5_35-4_79_2_147_2_18:4.2.2.3
	Kernel-5_35-4_79_2_164:4.2.2.3
	Kernel-5_35-4_79_2_163:4.2.2.3
	Kernel-5_35-4_79_2_147_2_17:4.2.2.3
	Kernel-5_35-4_79_2_147_2_16:4.2.2.3
	Kernel-5_35-4_79_2_147_2_15:4.2.2.3
	Kernel-5_35-4_79_2_162:4.2.2.3
	Kernel-5_35-4_79_2_161:4.2.2.3
	Kernel-5_35-4_79_2_147_2_14:4.2.2.3
	Kernel-5_35-4_79_2_147_2_13:4.2.2.3
	Kernel-5_35-4_79_2_160:4.2.2.3
	Kernel-5_35-4_79_2_159:4.2.2.3
	Kernel-5_35-4_79_2_158:4.2.2.3
	Kernel-5_35-4_79_2_157:4.2.2.3
	Kernel-5_35-4_79_2_156:4.2.2.3
	Kernel-5_35-4_79_2_147_2_12:4.2.2.3
	Kernel-5_35-4_79_2_147_2_11:4.2.2.3
	Kernel-5_35-4_79_2_155:4.2.2.3
	Kernel-5_35-4_79_2_147_2_10:4.2.2.3
	Kernel-5_35-4_79_2_154:4.2.2.3
	Kernel-5_35-4_79_2_153:4.2.2.3
	Kernel-5_35-4_79_2_147_2_9:4.2.2.3
	Kernel-5_35-4_79_2_152:4.2.2.3
	Kernel-5_35-4_79_2_151:4.2.2.3
	Kernel-5_35-4_79_2_147_2_8:4.2.2.3
	Kernel-5_35-4_79_2_147_2_7:4.2.2.3
	Kernel-5_35-4_79_2_150:4.2.2.3
	Kernel-5_35-4_79_2_147_2_6:4.2.2.3
	Kernel-5_35-4_79_2_147_2_5:4.2.2.3
	Kernel-5_35-4_79_2_149:4.2.2.3
	Kernel-5_35-4_79_2_147_2_4:4.2.2.3
	Kernel-5_35-4_79_2_147_2_3:4.2.2.3
	Kernel-5_35-4_79_2_148:4.2.2.3
	Kernel-5_35-4_79_2_147_2_2:4.2.2.3
	Kernel-5_35-4_79_2_147_2_1:4.2.2.3
	RPi:4.2.2.3.0.6
	RPi_bp:4.2.2.3
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2.2.3
	alees_Kernel_dev:4.2.2.3.0.4
	alees_Kernel_dev_bp:4.2.2.3
	Kernel-5_35-4_79_2_147:4.2.2.3
	Kernel-5_35-4_79_2_146:4.2.2.3
	Kernel-5_35-4_79_2_145:4.2.2.3
	Kernel-5_35-4_79_2_144:4.2.2.3
	Kernel-5_35-4_79_2_143:4.2.2.3
	Kernel-5_35-4_79_2_142:4.2.2.3
	Kernel-5_35-4_79_2_141:4.2.2.3
	Kernel-5_35-4_79_2_140:4.2.2.3
	Kernel-5_35-4_79_2_139:4.2.2.3
	Kernel-5_35-4_79_2_138:4.2.2.3
	Kernel-5_35-4_79_2_137:4.2.2.3
	Kernel-5_35-4_79_2_136:4.2.2.3
	Kernel-5_35-4_79_2_135:4.2.2.3
	Kernel-5_35-4_79_2_134:4.2.2.3
	Kernel-5_35-4_79_2_133:4.2.2.3
	Kernel-5_35-4_79_2_132:4.2.2.3
	Kernel-5_35-4_79_2_131:4.2.2.3
	Kernel-5_35-4_79_2_130:4.2.2.3
	Kernel-5_35-4_79_2_129:4.2.2.3
	Kernel-5_35-4_79_2_128:4.2.2.3
	Kernel-5_35-4_79_2_127:4.2.2.3
	Kernel-5_35-4_79_2_126:4.2.2.3
	Kernel-5_35-4_79_2_125:4.2.2.3
	Kernel-5_35-4_79_2_124:4.2.2.3
	Kernel-5_35-4_79_2_123:4.2.2.3
	Cortex_merge:4.2.2.3
	Kernel-5_35-4_79_2_122:4.2.2.3
	Kernel-5_35-4_79_2_98_2_54:4.2.2.3
	Kernel-5_35-4_79_2_98_2_53:4.2.2.3
	Kernel-5_35-4_79_2_98_2_52:4.2.2.3
	Kernel-5_35-4_79_2_98_2_51:4.2.2.3
	Kernel-5_35-4_79_2_98_2_50:4.2.2.3
	Kernel-5_35-4_79_2_98_2_49:4.2.2.3
	Kernel-5_35-4_79_2_98_2_48:4.2.2.3
	Kernel-5_35-4_79_2_121:4.2.2.3
	Kernel-5_35-4_79_2_98_2_47:4.2.2.3
	Kernel-5_35-4_79_2_120:4.2.2.3
	Kernel-5_35-4_79_2_98_2_46:4.2.2.3
	Kernel-5_35-4_79_2_119:4.2.2.3
	Kernel-5_35-4_79_2_98_2_45:4.2.2.3
	Kernel-5_35-4_79_2_98_2_44:4.2.2.3
	Kernel-5_35-4_79_2_118:4.2.2.3
	Kernel-5_35-4_79_2_98_2_43:4.2.2.3
	Kernel-5_35-4_79_2_117:4.2.2.3
	Kernel-5_35-4_79_2_116:4.2.2.3
	Kernel-5_35-4_79_2_98_2_42:4.2.2.3
	Kernel-5_35-4_79_2_115:4.2.2.3
	Kernel-5_35-4_79_2_98_2_41:4.2.2.3
	Kernel-5_35-4_79_2_98_2_40:4.2.2.3
	Kernel-5_35-4_79_2_114:4.2.2.3
	Kernel-5_35-4_79_2_98_2_39:4.2.2.3
	Kernel-5_35-4_79_2_98_2_38:4.2.2.3
	Kernel-5_35-4_79_2_113:4.2.2.3
	Kernel-5_35-4_79_2_112:4.2.2.3
	Kernel-5_35-4_79_2_98_2_37:4.2.2.3
	Kernel-5_35-4_79_2_98_2_36:4.2.2.3
	Kernel-5_35-4_79_2_98_2_35:4.2.2.3
	Kernel-5_35-4_79_2_98_2_34:4.2.2.3
	Kernel-5_35-4_79_2_98_2_33:4.2.2.3
	Kernel-5_35-4_79_2_98_2_32:4.2.2.3
	Kernel-5_35-4_79_2_98_2_31:4.2.2.3
	Kernel-5_35-4_79_2_98_2_30:4.2.2.3
	Kernel-5_35-4_79_2_98_2_29:4.2.2.3
	Kernel-5_35-4_79_2_98_2_28:4.2.2.3
	Kernel-5_35-4_79_2_98_2_27:4.2.2.3
	Kernel-5_35-4_79_2_98_2_26:4.2.2.3
	Kernel-5_35-4_79_2_111:4.2.2.3
	Kernel-5_35-4_79_2_98_2_25:4.2.2.3
	Kernel-5_35-4_79_2_98_2_24:4.2.2.3
	Kernel-5_35-4_79_2_98_2_23:4.2.2.3
	Kernel-5_35-4_79_2_110:4.2.2.3
	Kernel-5_35-4_79_2_98_2_22:4.2.2.3
	Kernel-5_35-4_79_2_109:4.2.2.3
	Kernel-5_35-4_79_2_98_2_21:4.2.2.3
	Kernel-5_35-4_79_2_98_2_20:4.2.2.3
	Kernel-5_35-4_79_2_108:4.2.2.3
	Kernel-5_35-4_79_2_107:4.2.2.3
	Kernel-5_35-4_79_2_98_2_19:4.2.2.3
	Kernel-5_35-4_79_2_98_2_18:4.2.2.3
	Kernel-5_35-4_79_2_98_2_17:4.2.2.3
	Kernel-5_35-4_79_2_98_2_16:4.2.2.3
	Kernel-5_35-4_79_2_98_2_15:4.2.2.3
	Kernel-5_35-4_79_2_106:4.2.2.3
	Kernel-5_35-4_79_2_105:4.2.2.3
	Kernel-5_35-4_79_2_104:4.2.2.3
	Kernel-5_35-4_79_2_98_2_14:4.2.2.3
	Kernel-5_35-4_79_2_98_2_13:4.2.2.3
	Kernel-5_35-4_79_2_98_2_12:4.2.2.3
	Kernel-5_35-4_79_2_98_2_11:4.2.2.3
	Kernel-5_35-4_79_2_98_2_10:4.2.2.3
	Kernel-5_35-4_79_2_98_2_9:4.2.2.3
	Kernel-5_35-4_79_2_103:4.2.2.3
	Kernel-5_35-4_79_2_102:4.2.2.3
	Kernel-5_35-4_79_2_98_2_8:4.2.2.3
	Kernel-5_35-4_79_2_98_2_7:4.2.2.3
	Kernel-5_35-4_79_2_98_2_6:4.2.2.3
	Kernel-5_35-4_79_2_98_2_5:4.2.2.3
	Kernel-5_35-4_79_2_98_2_4:4.2.2.3
	Kernel-5_35-4_79_2_101:4.2.2.3
	Kernel-5_35-4_79_2_100:4.2.2.3
	Kernel-5_35-4_79_2_99:4.2.2.3
	Kernel-5_35-4_79_2_98_2_3:4.2.2.3
	Kernel-5_35-4_79_2_98_2_2:4.2.2.3
	Kernel-5_35-4_79_2_98_2_1:4.2.2.3
	Cortex:4.2.2.3.0.2
	Cortex_bp:4.2.2.3
	Kernel-5_35-4_79_2_98:4.2.2.3
	Kernel-5_35-4_79_2_97:4.2.2.3
	Kernel-5_35-4_79_2_96:4.2.2.3
	Kernel-5_35-4_79_2_95:4.2.2.3
	Kernel-5_35-4_79_2_94:4.2.2.3
	Kernel-5_35-4_79_2_93:4.2.2.3
	Kernel-5_35-4_79_2_92:4.2.2.3
	Kernel-5_35-4_79_2_91:4.2.2.3
	Kernel-5_35-4_79_2_90:4.2.2.3
	Kernel-5_35-4_79_2_89:4.2.2.3
	Kernel-5_35-4_79_2_88:4.2.2.3
	Kernel-5_35-4_79_2_87:4.2.2.3
	Kernel-5_35-4_79_2_86:4.2.2.3
	Kernel-5_35-4_79_2_85:4.2.2.3
	Kernel-5_35-4_79_2_84:4.2.2.3
	Kernel-5_35-4_79_2_83:4.2.2.3
	Kernel-5_35-4_79_2_82:4.2.2.3
	Kernel-5_35-4_79_2_81:4.2.2.3
	Kernel-5_35-4_79_2_80:4.2.2.3
	Kernel-5_35-4_79_2_79:4.2.2.3
	Kernel-5_35-4_79_2_78:4.2.2.3
	Kernel-5_35-4_79_2_77:4.2.2.3
	RO_5_07:4.2.2.3
	Kernel-5_35-4_79_2_76:4.2.2.3
	Kernel-5_35-4_79_2_75:4.2.2.3
	Kernel-5_35-4_79_2_74:4.2.2.3
	Kernel-5_35-4_79_2_73:4.2.2.3
	Kernel-5_35-4_79_2_72:4.2.2.3
	Kernel-5_35-4_79_2_71:4.2.2.3
	Kernel-5_35-4_79_2_70:4.2.2.3
	Kernel-5_35-4_79_2_69:4.2.2.3
	Kernel-5_35-4_79_2_68:4.2.2.3
	Kernel-5_35-4_79_2_67:4.2.2.3
	Kernel-5_35-4_79_2_66:4.2.2.3
	Kernel-5_35-4_79_2_65:4.2.2.3
	Kernel-5_35-4_79_2_64:4.2.2.3
	Kernel-5_35-4_79_2_63:4.2.2.3
	Kernel-5_35-4_79_2_62:4.2.2.3
	Kernel-5_35-4_79_2_61:4.2.2.3
	Kernel-5_35-4_79_2_59:4.2.2.3
	Kernel-5_35-4_79_2_58:4.2.2.3
	Kernel-5_35-4_79_2_57:4.2.2.3
	Kernel-5_35-4_79_2_56:4.2.2.3
	Kernel-5_35-4_79_2_55:4.2.2.3
	Kernel-5_35-4_79_2_54:4.2.2.3
	Kernel-5_35-4_79_2_53:4.2.2.3
	Kernel-5_35-4_79_2_52:4.2.2.3
	Kernel-5_35-4_79_2_51:4.2.2.3
	Kernel-5_35-4_79_2_50:4.2.2.2
	Kernel-5_35-4_79_2_49:4.2.2.2
	Kernel-5_35-4_79_2_48:4.2.2.2
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.4
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2.2.2
	Kernel-5_35-4_79_2_46:4.2.2.2
	Kernel-5_35-4_79_2_45:4.2.2.2
	Kernel-5_35-4_79_2_44:4.2.2.2
	Kernel-5_35-4_79_2_25_2_2:4.2.2.1
	Kernel-5_35-4_79_2_43:4.2.2.2
	Kernel-5_35-4_79_2_42:4.2.2.2
	Kernel-5_35-4_79_2_41:4.2.2.2
	Kernel-5_35-4_79_2_40:4.2.2.2
	Kernel-5_35-4_79_2_39:4.2.2.2
	Kernel-5_35-4_79_2_38:4.2.2.2
	Kernel-5_35-4_79_2_37:4.2.2.1
	Kernel-5_35-4_79_2_36:4.2.2.1
	Kernel-5_35-4_79_2_35:4.2.2.1
	Kernel-5_35-4_79_2_34:4.2.2.1
	Kernel-5_35-4_79_2_33:4.2.2.1
	Kernel-5_35-4_79_2_32:4.2.2.1
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2.2.1
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2.2.1
	Kernel-5_35-4_79_2_30:4.2.2.1
	Kernel-5_35-4_79_2_29:4.2.2.1
	Kernel-5_35-4_79_2_28:4.2.2.1
	Kernel-5_35-4_79_2_27:4.2.2.1
	Kernel-5_35-4_79_2_26:4.2.2.1
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2.2.1
	Kernel-5_35-4_79_2_24:4.2.2.1
	Kernel-5_35-4_79_2_23:4.2.2.1
	Kernel-5_35-4_79_2_22:4.2.2.1
	Kernel-5_35-4_79_2_21:4.2.2.1
	Kernel-5_35-4_79_2_20:4.2.2.1
	Kernel-5_35-4_79_2_19:4.2.2.1
	Kernel-5_35-4_79_2_18:4.2.2.1
	Kernel-5_35-4_79_2_17:4.2.2.1
	Kernel-5_35-4_79_2_16:4.2.2.1
	Kernel-5_35-4_79_2_15:4.2.2.1
	Kernel-5_35-4_79_2_14:4.2.2.1
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2.2.1
	Kernel-5_35-4_79_2_12:4.2.2.1
	Kernel-5_35-4_79_2_11:4.2.2.1
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2.2.1
	Kernel-5_35-4_79_2_9:4.2.2.1
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2.2.1
	Kernel-5_35-4_79_2_7:4.2.2.1
	Kernel-5_35-4_79_2_6:4.2.2.1
	Kernel-5_35-4_79_2_5:4.2.2.1
	Kernel-5_35-4_79_2_4:4.2.2.1
	Kernel-5_35-4_79_2_3:4.2.2.1
	Kernel-5_35-4_79_2_2:4.2.2.1
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2.2.1
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches;
next	4.4;
commitid	skOEjp3ipLHx6xcz;

4.4
date	2016.06.30.20.29.05;	author jlee;	state Exp;
branches;
next	4.3;
commitid	lMnWzoE9eJz3Wwcz;

4.3
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.04.04.14.27.40;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.38;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.09.15.12.38.02;	author kbracey;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2001.06.18.14.49.48;	author mstephen;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2002.11.30.00.31.13;	author bavison;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	2013.08.06.22.43.10;	author jlee;	state Exp;
branches;
next	4.2.2.5;
commitid	TOIaeUf2Q4rBIr0x;

4.2.2.5
date	2013.10.06.18.02.42;	author jlee;	state Exp;
branches;
next	4.2.2.6;
commitid	6Bp9Hz2X0M7Ucg8x;

4.2.2.6
date	2014.03.09.15.57.02;	author jlee;	state Exp;
branches;
next	4.2.2.7;
commitid	FnXbK143NQLRy2sx;

4.2.2.7
date	2014.03.28.00.12.57;	author jlee;	state Exp;
branches;
next	4.2.2.8;
commitid	cEZUvOhcFiZ8Joux;

4.2.2.8
date	2016.05.22.12.42.51;	author jlee;	state Exp;
branches;
next	;
commitid	nDV8KQG2F69ZBt7z;

4.1.1.1
date	96.11.05.09.41.38;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.14;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.41;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.12;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.42;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > &.Source.VduGrafG
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - Sprite stuff
;
; Author R C Manby
; Date   10.11.86
;

RangeB * 256
RangeC * 512

; Macros for various sprite operations

        MACRO
        KillSpChoosePtr
        MOV     R0, #0
        STR     R0, [WsPtr, #SpChoosePtr]
        MEND

        MACRO
        CopyDown $to,$from,$bytes, $tmp, $tmp2
        LDR     $tmp2, [WsPtr, #VduSprite]      ; sprite being output to by Vdu
        ADD     $tmp, $from, $bytes
        SUB     $tmp, $tmp, #1                  ; from + bytes -1
        CMP     $tmp2, $to                      ; if VOTS >= to
        CMPCS   $tmp, $tmp2                     ; and from+bytes-1 >= VOTS
        BCC     %FT00
        Push    "R0, R14"
        SUB     R0, $to, $from                  ; then adjust address vars
        BL      AdjustSpriteAddress             ; by offset = to-from
        Pull    "R0, R14"
00
        CMP     $bytes, #0                      ; bytes must be a multiple of 4
01
        LDRNE   $tmp, [$from], #4
        STRNE   $tmp, [$to], #4
        SUBNES  $bytes, $bytes, #4
        BNE     %BT01
        MEND

        MACRO
        CopyUp $to,$from,$bytes, $tmp, $tmp2
        LDR     $tmp2, [WsPtr, #VduSprite]      ; sprite being output to by Vdu
        ADD     $tmp, $to, $bytes
        SUB     $tmp, $tmp, #1                  ; to + bytes -1
        CMP     $tmp2, $from                    ; if VOTS >= from
        CMPCS   $tmp, $tmp2                     ; and to+bytes-1 >= VOTS
        BCC     %FT00
        Push    "R0, R14"
        SUB     R0, $to, $from                  ; then adjust address vars
        BL      AdjustSpriteAddress             ; by offset = to-from
        Pull    "R0, R14"
00
01
        SUBS    $bytes, $bytes, #4
        LDRCS   $tmp, [$from, $bytes]
        STRCS   $tmp, [$to, $bytes]
        BHI     %BT01
        MEND

; copy R0 bytes from R3 to R2 (R2+:=R0; R3+:=R0)
; corrupts R0, R4-R11, R14
; NB not used at present

        MACRO
        CopyDownFast
        SUBS    R0, R0, #9*4
10
        LDMCSIA R3!, {R4-R11,R14}
        STMCSIA R2!, {R4-R11,R14}
        SUBCSS  R0, R0, #9*4
        BCS     %BT10
        ADDS    R0, R0, #9*4
20
        LDRNE   R4, [R3], #4
        STRNE   R4, [R2], #4
        SUBNES  R0, R0, #4
        BNE     %BT20
        MEND

        MACRO
        ClearWords $from,$words, $tmp
        MOV     $tmp,#0
01
        SUBS    $words, $words, #1
        STRCS   $tmp, [$from], #4
        BHI     %BT01
        MEND

; *****************************************************************************
;
;       AdjustSpriteAddress - Move VduSprite, ScreenStart, CursorAddr and
;        InputCursorAddr by R0
;
;       Internal routine, called by routines that use macros
;        CopyDown, CopyUp
;
; in:   R0 = no. of bytes to add on (can be -ve)
;

AdjustSpriteAddress ROUT
        Push    R14
        LDR     R14, [WsPtr, #VduSprite]
        ADD     R14, R14, R0
        STR     R14, [WsPtr, #VduSprite]
        LDR     R14, [WsPtr, #ScreenStart]
        ADD     R14, R14, R0
        STR     R14, [WsPtr, #ScreenStart]
        B       AdjustCursorVars        ; update CursorAddr, InputCursorAddr

; *****************************************************************************
;
;       SpriteInit - Setup sprite workspace on reset (called whenever break
;                    is pressed)
;

SpriteInit ROUT
        Push    R14

        BL      ClearSpritePtrName      ; clear SpChoosePtr,SpChooseName

        Pull    PC

        LTORG

; *****************************************************************************
;
;       Vdu23_27 - SCHOOSE/SGET a numbered sprite
;
; in:   QQ?0 = 0 => Select sprite STR$(QQ?1) for plotting
;       QQ?0 = 1 => Sget an area of screen and put it in sprite STR$(QQ?1)
;

Vdu23_27 ROUT
        LDRB    R0, [WsPtr, #QQ+1]
        CMP     R0, #1
        MOVCC   R3, #SpriteReason_SelectSprite          ; 0-Select sprite
        MOVEQ   R3, #SpriteReason_GetSprite             ; 1-Pickup sprite
        MOVHI   PC, R14

        Push    R14

        LDRB    R0, [WsPtr, #QQ+2]      ; sprite number
        ADD     R1, WsPtr, #NameBuf
        MOV     R2, #4
        SWI     XOS_BinaryToDecimal
        MOV     R0, #13
        STRB    R0, [R1, R2]            ; $NameBuf := STR$(n)

        MOV     R0, R3                  ; R0 = sprite-op reason code
        MOV     R2, R1                  ; R2 -> sprite name
        MOV     R3, #0                  ; extension gap size
        SWI     XOS_SpriteOp            ; perform operation, ignore errors

        Pull    PC

; *****************************************************************************
;
;       SpritePlot - PLOT &E8-&EF,X,Y
;
; in:   R2 = plot code
;
; The 2 LSBits of the plot code specify fg/bg colour and action as :-
;  0 => No effect eqv. of Gcol(5,c)
;  1 => Plot sprite using foreground Gcol action
;  2 => Invert eqv. of Gcol(4,c)
;  3 => Plot mask in background colour and Gcol action
;

SpritePlot ROUT
        Push    R14

        AND     R3, R2, #3              ; 2 LSBits of plot code
        CMP     R3, #1
        MOVCC   R5, #5                  ; gcol action - no effect
        LDREQ   R5, [WsPtr, #GPLFMD]    ;              foreground
        MOVHI   R5, #4                  ;              invert or background

        AND     R5, R5, #&0F            ; knock out any ecf bits

        LDR     R2, [WsPtr, #SpChoosePtr]      ; If ChoosePtr <> 0
        CMP     R2, #0
        BNE     %FT10                   ; then use as pointer to sprite

        MOV     R0, #SpriteReason_SelectSprite ; else select it first
        LDR     R2, =SpChooseName
        ADD     R2, R2, WsPtr           ; sprite name ptr
        SWI     XOS_SpriteOp
        LDR     R2, [WsPtr, #SpChoosePtr]

10                                      ; R2 points to the sprite
        CMP     R3, #3
        MOVNE   R0, #RangeC+SpriteReason_PutSprite
        LDREQ   R0, =RangeC+SpriteReason_PlotMask
        LDR     R1, [WsPtr, #SpAreaStart]
        SWI     XOS_SpriteOp            ; perform operation, ignoring errors

        Pull    PC

; *****************************************************************************
;
;       SwiSpriteOp - Entry point for SWI OS_SpriteOp
;
; in:   R0 = sprite op reason code
;       R1 -> sprite area (usually)
;       R2 -> sprite (usually)
;       R3..? parameters
;

SwiSpriteOp ROUT
        Push    R14
        BranchNotJustUs %F10, SpriteV, R11, R14

; we are sole owners of SpriteV, so call our internal routine

        Push    PC                      ; push address of SwiSpriteReturn
        B       SpriteVecHandler
        &       0

SwiSpriteReturn
        Pull    R14
        ORRVS   R14, R14, #V_bit        ; if error, set V_bit in link
        ExitSWIHandler

; we are not the sole owners of SpriteV, so call the vector

10
        MOV     R10, #SpriteV
        BL      %FT20
        Pull    R14
        ORRVS   R14, R14, #V_bit        ; if error, set V_bit in link
        ExitSWIHandler

20
        CallAVector

; *****************************************************************************
;
;       SpriteVecHandler - Default owner of SpriteV
;
; in:   R0-R7 contain our entry parameters
;
; out:  R0-R7 contain exit parameters
;       R8-R12 are preserved
;

        MACRO
        SpriteOpDispatch $cond
        ADD$cond PC, R10, R11, ASR #8
        MEND

        MACRO
        SpriteOpEntry   $addr, $flags
        &       (($addr - SwiSpriteOpCallTb) :SHL: 8) + $flags
        MEND

; The end of this code is put before the beginning, so that
; SpriteDispatchReturn + SVC_mode is within ADR reach of the dispatcher

BadReasonCode ROUT
        ADRL    R0, SpriteErr_BadReasonCode
      [ International
        BL      TranslateError
      ]
        B       %FT20
SpriteIsCurrentDest
        ADRL    R0, SpriteErr_SpriteIsCurrentDest
      [ International
        BL      TranslateError
      ]
        B       %FT20

15
        ADRL    R0, SpriteErr_DoesntExist
      [ International
        BL      TranslateError
      ]

20                                      ; Exit SWI with error, error code in R0
        STR     R0, [WsPtr, #RetnReg0]
30
        SETV                            ; indicate an error

; and drop thru to...

SpriteDispatchReturn
        ADD     R11, WsPtr, #RetnReg0
        LDMIA   R11, {R0-R9}            ; Restore R0-R9
        MOV     R10, R13                ; Point at old returned registers
        Push    "R0-R9"                 ; Save new returned registers on stack
        LDMIA   R10, {R0-R9}            ; Load old returned registers
        STMIA   R11, {R0-R9}            ; and put them in the dump area
        Pull    "R0-R9"                 ; restore new returned registers
        ADD     R13, R13, #10*4         ; remove stack frame
        Pull    "R10-R12,PC"

SpriteVecHandler
        Push    "R10-R12"
        WritePSRc SVC_mode, WsPtr       ; Re-enable interupts

        VDWS    WsPtr                   ; Point R12 at Vdu driver workspace
        ADD     R11, WsPtr, #RetnReg0

        SUB     R13, R13, #10*4         ; Create stack frame for old RetnRegs
        MOV     R10, R13                ; Keep pointer to this frame
        Push    "R0-R9"                 ; Save new regs while we copy old ones
        LDMIA   R11, {R0-R9}            ; Load old regs
        STMIA   R10, {R0-R9}            ; and push them onto stack
        Pull    "R0-R9"                 ; Restore new regs
        STMIA   R11, {R0-R9}            ; Dump R0-R9

        CMP     R0, #RangeC + &100      ; if top bits out of range
        BCS     BadReasonCode           ; then error

        CMP     R0, #RangeB             ; if Range A type
        LDRCC   R1, [WsPtr, #SpAreaStart] ; then point at MOS sprite area

        AND     R0, R0, #&FF            ; Kill the range bits
        CMP     R0, #(SwiSpriteOpCallTb_End-SwiSpriteOpCallTb)/4
        BCS     BadReasonCode

        ADR     R10, SwiSpriteOpCallTb
        ADR     R14, SpriteDispatchReturn ; return address
        LDR     R11, [R10, R0, LSL #2]  ; load (offset<<8) + flags

        TST     R11, #SSO_ScreenNotAllowed ; if call can specify screen (R2=0)
        TEQEQ   R2, #0                  ; and it is specified
        MOVEQ   R1, #0                  ; then make sprite area ptr 0 as well
        TSTNE   R11, #SSO_NeedsSomething ; or nothing needed anyway
        SpriteOpDispatch EQ             ; then dispatch

        TEQ     R1, #0                  ; else needs sprite area ptr
        ADREQ   R0, SpriteErr_NoWorkSpace ; so if zero then invalid
      [ International
        BLEQ    TranslateError
      ]
        BEQ     %BT20

        TST     R11, #SSO_DangerAreaOp  ; if not a danger area op
        BEQ     %FT32                   ; then skip

        LDR     R9, [WsPtr, #VduSpriteArea] ; else check if sprite area is same
        TEQ     R9, R1
        BEQ     SpriteIsCurrentDest     ; and error if so

32
        TST     R11, #SSO_NeedsSprite   ; if doesn't need sprite
        BNE     %FT33

        TEQ     R0,#SpriteReason_CreateSprite
        BEQ     %FT21

        TEQ     R0,#SpriteReason_ScreenSave
        TEQNE   R0,#SpriteReason_GetSprite
        TEQNE   R0,#SpriteReason_GetSpriteUserCoords

        SpriteOpDispatch NE             ; let it go if we're not interested in it

        LDR     R9,[WsPtr, #Log2BPP]    ; fetch the current bpp

        CMP     R9,#4
        SpriteOpDispatch CC             ; let it go if below 16bpp
22
        CMP     R3,#0
        BNE     %FT34                   ; bang if it has a palette

        SpriteOpDispatch                ; then dispatch

21      ;createsprite. R6=mode number or sprite mode word, or => mode descriptor
        Push    "R0-R3,R14"
        MOV     R0,R6
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        MOVCS   R2,#0
        CMP     R2,#4
        Pull    "R0-R3,R14"
        SpriteOpDispatch CC
        B       %BT22

33
        TEQ     R2, #0                  ; if sprite ptr is zero it's a boob
        BEQ     %BT15                   ; so say SpriteDoesntExist

        LDR     R9, [WsPtr, #RetnReg0]
        CMP     R9, #RangeC             ; if not range C then must look up
        BCS     %FT35                   ; sprite name and convert to pt4
        Push    R14
        BL      SpriteCtrlBlk           ; in: R2 -> name; out: R2 -> sprite
        Pull    R14
        BVS     %BT15                   ; no such sprite

35

;medusa note.
;
;On Medusa masks and palettes for 16/32bpp sprites are in a transient state
;Medusa will fault 16/32bpp mask/palette operations, in readiness for the
;introduction of new (more compact) mask/palette formats.
;
;another medusa note.
;
;Mask operations using 1bpp masks on new format sprites are now being included.
;However palettes on 16/32bpp are still not allowed.
;

;amg 12/11/93, sort out the logic here so that palettes on new format sprites
;really do get faulted

;amg 25th May 1994. We now allow palettes on new format sprites of 8bpp
;and below

        ; find the sprite type
        Push   "R14"
        LDR    R9,[R2,#spMode]

        ANDS   R14,R9,#15<<27           ; get the sprite type
        BEQ    %FT37                    ; t=0 (ie old format)

        CMP    R14,#SpriteType_RISCOS5<<27 ; if it's a RISC OS 5 sprite mode word
        MOVEQ  R14,R9,LSR #20            ; then get the actual sprite type
        MOVNE  R14,R14,LSR #27
        ANDEQS R14,R14,#127
        MOVEQ  R14,#SpriteType_Substitute ; Panic and treat as 32bpp?

        CMP    R14,#SpriteType_New16bpp ; check sprite type number
        BCC    %FT38                    ; despatch if new format and under 16bpp
        

39
        ; so, does it have a palette
        ADD    R9,R2,#spImage
        LDMIA  R9,{R9,R14}              ; pick up offsets to mask & image
        CMP    R9,R14
        MOVGT  R9,R14                   ; R9->top of palette block
        SUBS   R9,R9,#spPalette         ; R9 = size of palette block
        BEQ    %FT38                    ; no palette, so no error

        Pull   "R14"
34
        ADRL    R0, SpriteErr_NoMaskOrPaletteAllowedInThisDepth
        [ International
        BL      TranslateError
        ]
        B       %BT20

37      ;however, until mode selectors work there are some 16/32bpp old modes
        Push    "R0-R3"                 ; save context
        MOV     R0,R9
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ; read log2bpp for the sprite's mode
        MOV     R9,R2                   ; and move it for posterity
        Pull    "R0-R3"
        CMP     R9,#4
        BCS     %BT39                   ; log2bpp of 4 = 16bpp, so see if we want to fault it
38
        TST     R11, #SSO_DangerOp      ; if a destructive op
        Pull    "R14"
        BEQ     %FT40

        LDR     R9, [WsPtr, #VduSprite]
        TEQ     R9, R2
        BEQ     SpriteIsCurrentDest     ; then stop him!

40
        TST     R11, #SSO_NeedsSpriteModeData
        SpriteOpDispatch EQ

        Push    "R5-R7, R10, R11, R14"
        BL      SetupSprModeData
        Pull    "R5-R7, R10, R11, R14"
        SpriteOpDispatch VC

        B       %BT30                   ; Invalid spMode field


SSO_ScreenNotAllowed    * 1 :SHL: 0
SSO_NeedsSomething      * 1 :SHL: 1
SSO_NeedsSprite         * 1 :SHL: 2
SSO_NeedsSpriteModeData * 1 :SHL: 3
SSO_DangerOp            * 1 :SHL: 4
SSO_DangerAreaOp        * 1 :SHL: 5

Group1  * SSO_ScreenNotAllowed
Group2  * Group1 + SSO_NeedsSomething
Group3  * Group2 + SSO_NeedsSprite
Group4  * Group3 + SSO_NeedsSpriteModeData
Group5  * SSO_NeedsSomething + SSO_NeedsSprite

SwiSpriteOpCallTb
        SpriteOpEntry BadReasonCode, Group1
        SpriteOpEntry BadReasonCode, Group1
        SpriteOpEntry ScreenSave, Group1
        SpriteOpEntry ScreenLoad, Group1
        SpriteOpEntry BadReasonCode, Group1 ; 4
        SpriteOpEntry BadReasonCode, Group1 ; 5
        SpriteOpEntry BadReasonCode, Group1 ; 6
        SpriteOpEntry BadReasonCode, Group1 ; 7

; The following need valid workspace

        SpriteOpEntry ReadAreaCB, Group2
        SpriteOpEntry ClearSprites, Group2 + SSO_DangerAreaOp   ; *SNew
        SpriteOpEntry LoadSpriteFile, Group2 + SSO_DangerAreaOp
                                                ; *SLoad <filename>
        SpriteOpEntry MergeSpriteFile, Group2 + SSO_DangerAreaOp
                                                ; *SMerge <filename>
        SpriteOpEntry SaveSpriteFile, Group2    ; *SSave <filename>
        SpriteOpEntry ReturnName, Group2
        SpriteOpEntry GetSprite, Group2         ; *SGet <name>
        SpriteOpEntry CreateSprite, Group2
        SpriteOpEntry GetSpriteUserCoords, Group2
        SpriteOpEntry BadReasonCode, Group2 ; 17 CheckSpriteArea
        SpriteOpEntry BadReasonCode, Group2 ; 18
        SpriteOpEntry BadReasonCode, Group2 ; 19
        SpriteOpEntry BadReasonCode, Group2 ; 20
        SpriteOpEntry BadReasonCode, Group2 ; 21
        SpriteOpEntry BadReasonCode, Group2 ; 22
        SpriteOpEntry BadReasonCode, Group2 ; 23

; The following need a sprite

        SpriteOpEntry SelectSprite, Group3      ; *SChoose <n> [<m>]
        SpriteOpEntry DeleteSprite, Group3 + SSO_DangerOp       ; *SDelete <n>
        SpriteOpEntry RenameSprite, Group3                      ; *SRename
        SpriteOpEntry CopySprite, Group3                        ; *SCopy
        SpriteOpEntry PutSprite, Group3
        SpriteOpEntry CreateMask, Group3
        SpriteOpEntry RemoveMask, Group3 + SSO_DangerOp
        SpriteOpEntry InsertRow, Group3 + SSO_DangerOp
        SpriteOpEntry DeleteRow, Group3 + SSO_DangerOp
        SpriteOpEntry FlipAboutXAxis, Group3
        SpriteOpEntry PutSpriteUserCoords, Group3
        SpriteOpEntry BadReasonCode, Group3 ; 35 AppendSprite
        SpriteOpEntry BadReasonCode, Group3 ; 36 SetPointerShape
        SpriteOpEntry BadReasonCode, Group3 ; 37 CreateRemovePalette
        SpriteOpEntry BadReasonCode, Group3 ; 38 CreateRemoveAlpha
        SpriteOpEntry BadReasonCode, Group3 ; 39

; The following need sprite mode data

        SpriteOpEntry ReadSpriteSize, Group4
        SpriteOpEntry ReadPixelColour, Group4
        SpriteOpEntry WritePixelColour, Group4
        SpriteOpEntry ReadPixelMask, Group4
        SpriteOpEntry WritePixelMask, Group4
        SpriteOpEntry InsertCol, Group4 + SSO_DangerOp
        SpriteOpEntry DeleteCol, Group4 + SSO_DangerOp
        SpriteOpEntry FlipAboutYAxis, Group4 + SSO_DangerOp
        SpriteOpEntry PlotMask, Group4
        SpriteOpEntry PlotMaskUserCoords, Group4
        SpriteOpEntry BadReasonCode, Group4 ; 50 PlotMaskScaled
        SpriteOpEntry BadReasonCode, Group4 ; 51 PaintCharScaled
        SpriteOpEntry BadReasonCode, Group4 ; 52 PutSpriteScaled
        SpriteOpEntry BadReasonCode, Group4 ; 53 PutSpriteGreyScaled
        SpriteOpEntry RemoveLeftHandWastage, Group4
        SpriteOpEntry BadReasonCode, Group4 ; 55 PlotMaskTransformed
        SpriteOpEntry BadReasonCode, Group4 ; 56 PutSpriteTransformed
        SpriteOpEntry BadReasonCode, Group4 ; 57 InsertDeleteRows
        SpriteOpEntry BadReasonCode, Group4 ; 58 InsertDeleteColumns
        SpriteOpEntry BadReasonCode, Group4 ; 59 pseudo reason used by Wimp

; The following need (sprite area + sprite) or (anything + 0), meaning screen

        SpriteOpEntry SwitchOutputToSprite, Group5 ; 60
        SpriteOpEntry SwitchOutputToMask, Group5   ; 61
        SpriteOpEntry ReadSaveAreaSize, Group5     ; 62

SwiSpriteOpCallTb_End


; *****************************************************************************
;
;       SetupSprModeData - Set up registers and variables from the sprite mode
;
;       Internal routine: called by sprite dispatch, CreateHeader
;
; in:   R2 -> sprite
;
; out:  R0-R5 preserved
;       R6 = ReadNColour (for a single screen pixel)
;       R7 = WriteNColour (=R6 except in double pixel modes)
;       R8 = BytesPerChar }
;       R9 = XShftFactor  } calculated from Log2BPC which is BitsPerPix
;       R10 = NPix        }  corrected for double pixel modes
;       R11 = Log2BPC     }
;
;       SprReadNColour..SprLog2BPC setup accordingly
;
;       If error, then RetnReg0 updated

SetupSprModeData ROUT
        Push    R14
        LDR     R11, [R2, #spMode]
        CMP     r11, #&100              ; check for mode selector/new format sprite word
        BCC     %FT05                   ; [it's a mode number so check for known ones]
        TST     r11, #1                 ; if it's a new format sprite word
        BNE     %FT10                   ; then call pushmodeinfo to get info on it
        B       %FT20                   ; else it's a mode selector, which is illegal as a sprite mode word
05
        BranchIfKnownMode R11, %FA10
        Push    "R2-R4"
        MOV     R2, R11
        BL      OfferModeExtensionAnyMonitor
        Pull    "R2-R4"
        BNE     %FT20

10
        MOV     R10, R11
        BL      PushModeInfoAnyMonitor
        BVS     %FT30                   ; if duff new format sprite word, return error

        LDR     R11, [R13, #wkModeFlags]
        TST     R11, #ModeFlag_NonGraphic
        BNE     %FT15                   ; non-graphic mode
        STR     R11, [WsPtr, #SprModeFlags]

        LDR     R11, [R13, #wkLog2BPC]                  ; Log2BPC
        LDR     R14, [R13, #wkLog2BPP]                  ; Log2BPP

        ADD     R13, R13, #PushedInfoSize

        MOV     R7, #1
        RSB     R9, R11, #5             ; XShftFactor
        RSB     R10, R7, R7, LSL R9     ; NPix
        MOV     R6, R7, LSL R14
        MOV     R8, R7, LSL R11         ; BytesPerChar
        RSB     R6, R7, R7, LSL R6      ; ReadNColour
        RSB     R7, R7, R7, LSL R8      ; WriteNColour

        Push    R5
        ADD     R5, WsPtr, #SprReadNColour
        STMIA   R5, {R6-R11,R14}        ; SprRead..SprLog2BPP
        CLRV
        Pull    "R5, PC"

15
        ADD     R13, R13, #PushedInfoSize
20
        ADRL    R0, SpriteErr_InvalidSpriteMode
      [ International
        BL      TranslateError
      ]
30
        STR     R0, [WsPtr, #RetnReg0]
        SETV
        Pull    pc


; *****************************************************************************

; Blocks for sprite errors

SpriteErr_NoWorkSpace                       MakeErrorBlock Sprite_NoWorkSpace
SpriteErr_NoRoom                            MakeErrorBlock Sprite_NoRoom
SpriteErr_DoesntExist                       MakeErrorBlock Sprite_DoesntExist
SpriteErr_NoSprites                         MakeErrorBlock Sprite_NoSprites
SpriteErr_NotGraphics                       MakeErrorBlock Sprite_NotGraphics
SpriteErr_NotEnoughRoom                     MakeErrorBlock Sprite_NotEnoughRoom
SpriteErr_BadSpriteFile                     MakeErrorBlock Sprite_BadSpriteFile
SpriteErr_NoRoomToMerge                     MakeErrorBlock Sprite_NoRoomToMerge
SpriteErr_Bad2ndPtr                         MakeErrorBlock Sprite_Bad2ndPtr
SpriteErr_InvalidRowOrCol                   MakeErrorBlock Sprite_InvalidRowOrCol
SpriteErr_InvalidHeight                     MakeErrorBlock Sprite_InvalidHeight
SpriteErr_InvalidWidth                      MakeErrorBlock Sprite_InvalidWidth
SpriteErr_NoRoomToInsert                    MakeErrorBlock Sprite_NoRoomToInsert
SpriteErr_SpriteAlreadyExists               MakeErrorBlock Sprite_SpriteAlreadyExists
SpriteErr_InvalidSpriteMode                 MakeErrorBlock Sprite_InvalidSpriteMode
SpriteErr_BadReasonCode                     MakeErrorBlock Sprite_BadReasonCode
SpriteErr_CantInTeletext                    MakeErrorBlock Sprite_CantInTeletext
SpriteErr_InvalidSaveArea                   MakeErrorBlock Sprite_InvalidSaveArea
SpriteErr_SpriteIsCurrentDest               MakeErrorBlock Sprite_SpriteIsCurrentDest
SpriteErr_NoMaskOrPaletteAllowedInThisDepth MakeErrorBlock Sprite_NoMaskOrPaletteAllowedInThisDepth

; *****************************************************************************
;
;       ClearSprites - Clear sprite area (*SNEW)
;
;       External routine + dropped thru to
;

ClearSprites ROUT
        LDR     R2, [R1, #saFirst]
        STR     R2, [R1, #saFree]
        MOV     R2, #0
        STR     R2, [R1,#saNumber]

        LDR     R0, [WsPtr, #RetnReg0]  ; if rangeb or rangec
        CMP     R0, #RangeB
        BHS     DoesNowt                ; exit immediately

; else its rangea, so drop thru to ...

ClearSpritePtrName ROUT
        MOV     R0, #0
        STR     R0, [WsPtr, #SpChoosePtr]
        STR     R0, [WsPtr, #SpChooseName]
        STR     R0, [WsPtr, #SpChooseName+4]
        STR     R0, [WsPtr, #SpChooseName+8]
        MOV     R0, #13
        STRB    R0, [WsPtr, #SpChooseName+12]   ; *SChoose <null name>
DoesNowt
        RETURNVC

; *****************************************************************************
;
;       ReadAreaCB - Read information from sprite area CB into registers
;
;       External routine
;
; in:   R1 -> sprite area
;
; out:  R2 = offset to end of sprite area (ie total size)
;       R3 = number of sprites in area
;       R4 = offset to first sprite
;       R5 = offset to first free word
;

ReadAreaCB ROUT
        LDMIA   R1, {R2,R3,R4,R5}               ; saEnd,saNumber,saFirst,saFree
        ADD     R11, WsPtr, #RetnReg2
        STMIA   R11, {R2,R3,R4,R5}
        RETURNVC

; *****************************************************************************
;
;       SelectSprite - Select a named sprite for use by PLOT &E8..&EF
;
;       External routine + called by GetSprite
;
; in:   R2 -> sprite CB
;
; out:  R0, R9..R11 corrupted
;       If not using system sprite area, then R2 -> address of sprite
;

SelectSprite ROUT
        Push    R14
        LDR     R0, [WsPtr, #RetnReg0]          ; if not in system sprite area
        CMP     R0, #RangeB
        STRCS   R2, [WsPtr, #RetnReg2]          ; return the sprite address
        Pull    PC, CS

        STR     R2, [WsPtr, #SpChoosePtr]       ; else store name & address
        ADD     R14, R2, #spName                ; for use by PLOT
        LDMIA   R14, {R9,R10,R11}               ; load 12 bytes of name
        LDR     R14, =SpChooseName
        ADD     R14, R14, WsPtr                 ; RetnReg2 NOT altered, so user
        STMIA   R14, {R9,R10,R11}               ; can't poke the workspace
        Pull    PC

; *****************************************************************************
;
;       ReturnName - Return name of nth sprite in sprite area as a string
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> buffer
;       R3 = max buffer length
;       R4 = sprite number (n)
;
; out:  R3 actual string length
;       RetnReg3 updated
;

ReturnName ROUT
        LDR     R5, [R1, #saNumber]     ; check for 1 <= R4 <= saNumber
        CMP     R4, #1
        CMPGE   R5, R4
        BGE     %FT05

        ADRL    R0, SpriteErr_DoesntExist ; out of range, so generate error
      [ International
        Push    "lr"
        BL      TranslateError_VClear
        Pull    "lr"
      ]
        STR     R0, [WsPtr, #RetnReg0]
        RETURNVS

05      LDR     R5, [R1, #saFirst]
        ADD     R5, R5, R1              ; ptr to 1st sprite
10
        SUBS    R4, R4, #1
        LDRNE   R6, [R5, #spNext]       ; if not sprite we want
        ADDNE   R5, R5, R6              ; chain to next one
        BNE     %BT10

        ADD     R5, R5, #spName         ; found sprite, R5 -> name

        SUBS    R3, R3, #1
        MOVLS   R3, #0                  ; if was 0 or 1 then set R3 to 0
        STRLS   R3, [WsPtr, #RetnReg3]
        STREQB  R3, [R2]                ; if was 1 then store 0 terminator
        MOVLS   PC, R14                 ; if was 0 or 1 then exit (assume SUB cleared V)

        CMP     R3, #SpriteNameSize     ; if length > maximum sprite name len
        MOVHI   R3, #SpriteNameSize     ; then limit to maximum sprite name len

; R3 is now maximum number of characters to store, excluding terminator

        MOV     R6, R2                  ; remember start address
20
        LDRB    R4, [R5], #1            ; load a byte from sprite name
        CMP     R4, #" "                ; if char > " "
        STRHIB  R4, [R2], #1            ; then store character and inc ptr
        SUBHIS  R3, R3, #1              ; and decrement character count
        BHI     %BT20                   ; loop until char<=" " or count expired

        MOV     R4, #0                  ; store terminating 0
        STRB    R4, [R2]
        SUB     R3, R2, R6              ; R3 = no. of characters,
        STR     R3, [WsPtr, #RetnReg3]  ; excluding terminator
        RETURNVC                        ; indicate no error

; *****************************************************************************
;
;       RenameSprite - Rename a sprite
;
;       External routine (AlreadyExists is used by CopySprite)
;
; in:   R2 -> sprite
;       R3 -> new name
;

RenameSprite ROUT
        Push    "R2, R14"
        MOV     R2, R3
        BL      GetName                 ; returns name in R9-R11
        BL      SpriteCtrlBlk           ; try to find sprite of that name
        BVC     AlreadyExists
        Pull    "R2, R14"
        ADD     R8, R2, #spName
        STMIA   R8, {R9-R11}
        KillSpChoosePtr                 ; in case it points to renamed sprite
        RETURNVC

AlreadyExists                           ; sprite with new name already exists
        Pull    "R3, R14"
        TEQ     R2, R3                  ; if it's the same one, then exit VC
        RETURNVC                        ; (SRename/SCopy fred fred is allowed)

        ADRL    R0, SpriteErr_SpriteAlreadyExists
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        STR     R0, [WsPtr,#RetnReg0]
        RETURNVS

; *****************************************************************************
;
;       CopySprite - Make a copy of a sprite
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 -> new name
;

CopySprite ROUT
        Push    "R2, R14"               ; save ptr to sprite to be copied
        MOV     R2, R3
        BL      GetName                 ; returns new name in R9-R11
        BL      SpriteCtrlBlk           ; try to find sprite of that name
        BVC     AlreadyExists           ; [we found one of that name]
        Pull    R2
        LDR     R8, [R1, #saFree]
        ADD     R8, R8, R1              ; address sprite will be copied to
        ADD     R8, R8, #spName         ; address of its name field
        BL      AppendSprite            ; copy it
        STMVCIA R8, {R9-R11}            ; if copy OK, rename it
        Pull    PC                      ; exit with V clear/set appropriately

; *****************************************************************************
;
;       ReadSpriteSize - Read sprite size and other info
;
;       External routine
;
; in:   R2 -> sprite
;
; out:  R1,R2 preserved
;       R3 = width in pixels
;       R4 = height in pixels
;       R5 = 0/1 for solid/transparent
;       R6 = mode sprite was defined in
;
;       RetnReg3..RetnReg6 updated
;

ReadSpriteSize ROUT
        ADD     R3, R2, #spWidth
        LDMIA   R3, {R3,R4,R5,R6}       ; spWidth,spHeight,spLBit,spRBit
        ADD     R4, R4, #1              ; R4 := height in pixels
        ADD     R3, R3, #1              ; R3 := width in words
        RSB     R3, R5, R3, LSL #5      ; convert to bits and sub LH wastage
        SUB     R3, R3, #31             ; subtract RH wastage
        ADD     R3, R3, R6
        LDR     R11, [WsPtr, #SprLog2BPC]
        MOV     R3, R3, LSR R11         ; number of pixels in row
        LDR     R5, [R2, #spImage]
        LDR     R6, [R2, #spTrans]
        SUBS    R5, R5, R6
        MOVNE   R5, #1                  ; if spImage=spTrans then no mask
        LDR     R6, [R2, #spMode]

        ADD     R11, WsPtr, #RetnReg3
        STMIA   R11, {R3-R6}

        RETURNVC

; *****************************************************************************
;
;       ReadSpriteWidth - Read width of a sprite
;
;       Internal routine, called by PlotMask, InsertCol, DeleteCol
;
; in:   R2 -> sprite
;
; out:  R0 = sprite width in pixels
;       All other registers preserved
;

ReadSpriteWidth ROUT
        Push    "R4-R6, R14"
        ADD     R0, R2, #spWidth
        LDMIA   R0, {R0,R4,R5,R6}       ; spWidth,spHeight,spLBit,spRBit
        ADD     R0, R0, #1              ; width in words
        RSB     R0, R5, R0, LSL #5
        SUB     R0, R0, #31
        ADD     R0, R0, R6              ; total number of bits in row
        LDR     R5, [WsPtr, #SprLog2BPC]
        MOV     R0, R0, LSR R5          ; number of pixels in row
        Pull    "R4-R6, PC"

; *****************************************************************************
;
;       DeleteSpriteByName
;
;       Internal routine, called by MergeSprite, GetSprite, CreateSprite
;
; in:   R1 -> sprite area
;       R2 -> name of sprite to be deleted
;
; out:  All registers preserved
;

DeleteSpriteByName ROUT
        Push    "R2-R4, R14"
        BL      SpriteCtrlBlk           ; R2: In , SpriteNamePtr
                                        ;     Out, SpriteCBptr
        BLVC    DeleteSprite            ; if found, then delete it
        Pull    "R2-R4, PC"

; *****************************************************************************
;
;       DeleteSprite
;
;       External routine + called by DeleteSpriteByName
;
; in:   R1 -> sprite area
;       R2 -> sprite
;
; out:  All registers preserved
;

DeleteSprite ROUT
        Push    "R0, R3,R4, R14"
        LDR     R3, [R2, #spNext]
        ADD     R3, R3, R2
        LDR     R0, [R1, #saFree]
        ADD     R0, R0, R1
        SUB     R0, R0, R3
        CopyDown R2, R3, R0, R14, R4
        LDR     R3, [R1, #saNumber]     ; decrement sprite count
        SUB     R3, R3, #1
        STR     R3, [R1, #saNumber]
        SUB     R3, R2, R1              ; (R2 points to first free location)
        STR     R3, [R1, #saFree]       ; update saFree

        KillSpChoosePtr                 ;Because the sprites have moved

        Pull    "R0, R3,R4, PC"

; *****************************************************************************
;
;       GetName - Read sprite name into buffer, lower cased, padded to 12 chars
;
;       Internal routine, called by RenameSprite, CopySprite,
;        SpriteCtrlBlk, CreateHeader
;
; in:   R2 -> sprite name (terminated by char <= 32)
;
; out:  Name returned in R9-R11 and NameBuf
;       All other registers preserved
;

GetName ROUT
        Push    "R2-R5, R14"
        ADD     R3, WsPtr, #NameBuf
        MOV     R4, #SpriteNameSize
10
        LDRB    R5, [R2], #1
        uk_LowerCase R5, R14
        CMP     R5, #" "
        STRHIB  R5, [R3], #1
        SUBHIS  R4, R4, #1              ; loop until char<=32 or done 12 chars
        BHI     %BT10

        MOV     R5, #0
        CMP     R4, #0                  ; pad with 0 or more nulls
20
        STRHIB  R5, [R3], #1
        SUBHIS  R4, R4, #1
        BHI     %BT20

        ADD     R9, WsPtr, #NameBuf
        LDMIA   R9, {R9-R11}            ; name returned in R9-R11 and NameBuf

        Pull    "R2-R5, PC"

; *****************************************************************************
;
;       SpriteCtrlBlk - Search for control block of named sprite
;
;       Internal routine, called by sprite dispatch, RenameSprite,
;        CopySprite, DeleteSpriteByName
;
; in:   R1 -> sprite area
;       R2 -> sprite name
;
; out:  V=0 => R2 -> sprite
;       V=1 => sprite not found
;              R2 -> first free byte (this fact not used by anyone yet)
;       All other registers preserved
;

SpriteCtrlBlk ROUT
        Entry   "R3-R11"
        ASSERT  saNumber = 4
        ASSERT  saFirst = 8
        LDMIB   R1, {R4,R5}             ; saNumber, saFirst
        ADD     R3, R5, R1              ; point to first sprite/free space
        CMP     R4, #0
        BEQ     %FT20                   ; no sprites, exit with R3 pointing
                                        ; at free space and R4=0
        BL      GetName                 ; search name in R9-R11 and NameBuf
10
        LDMIA   R3, {R5, R6,R7,R8}      ; spNext, spName(0..2)
        CMP     R6, R9
        CMPEQ   R7, R10
        CMPEQ   R8, R11                 ; (V:=0 if equal)
        BEQ     %FT30                   ; sprite found

        ADD     R3, R3, R5
        SUBS    R4, R4, #1              ; try next sprite
        BNE     %BT10
20
        SETV                            ; indicate not found
30
        MOV     R2, R3                  ; R2 -> sprite or to free space
        EXIT

; As above, but uses source name directly without passing it through GetName
; Name must be word aligned and in correct format!

SpriteCtrlBlkNoGetName
        ALTENTRY
        ASSERT  saNumber = 4
        ASSERT  saFirst = 8
        LDMIB   R1, {R4,R5}             ; saNumber, saFirst
        ADD     R3, R5, R1              ; point to first sprite/free space
        CMP     R4, #0
        BEQ     %BT20                   ; no sprites, exit with R3 pointing
        LDMIA   R2, {R9-R11}
        B       %BT10        

        LTORG

; *****************************************************************************
;
;       InternaliseCoords - Convert from external to internal coords
;                           for sprite plotting
;
;       Internal routine called by PutSpriteUserCoords, PlotMaskUserCoords
;
; in:   R3 = external X coordinate
;       R4 = external Y coordinate
;
; out:  R3 = internal X coordinate
;       R4 = internal Y coordinate
;       R1, R2, R5 preserved
;

InternaliseCoords ROUT
        Push    "R1,R2,R5, R14"
        MOV     R0, R3                  ; put external coordinate in R0,R1
        MOV     R1, R4
        ADD     R7, WsPtr, #GCsX
        LDMIA   R7, {R8,R9}             ; preserve GCsX,GCsY around EIG
        MOV     R2, #4                  ; indicate absolute coords
        BL      EIG
        STMIA   R7, {R8,R9}             ; restore GcsX,GCsY
        MOV     R3, R0                  ; internal coord of plotting point
        MOV     R4, R1
        Pull    "R1,R2,R5, PC"

; *****************************************************************************
;
;       PutSpriteUserCoords - Draw sprite to screen using given ext. coords
;
;       External routine
;
; in:   R1 -> sprite area (not used)
;       R2 -> sprite
;       R3 = X coordinate to plot at
;       R4 = Y coordinate to plot at
;       R5 = GCOL action to be used
;

PutSpriteUserCoords ROUT
        Push    R14
        BL      InternaliseCoords
        Pull    R14
        B       PutSpri20

; *****************************************************************************
;
;       PutSprite - Draw sprite to screen at NewPt
;
;       External routine + PutSpri20 called by PutSpriteUserCoords
;        (also external)
;
; in:   R1 -> sprite area (not used)
;       R2 -> sprite
;       R5 = GCOL action to be used
;

; Values held in Ram
;
; N.B. The ordering of these variables is VERY important
;      rearrange at your peril
;
; Within the 'memory to screen' drawing loop, WsPtr (R12) points at
;  ScrAdr, variables either side being loaded/saved in groups using
;  LDMDB / STMIA / LDMIB
;
;           SPltWidth   }
;           SPltHeight  }
;           SPltScrOff  }
;           SPltMemOff  } LDMDB
; WsPtr ->  SPltScrAdr    } STMIA
;           SPltColCnt    } } LDMIB
;           SPltMemAdr      }
;           SPltShftR       }
;           SPltShftL       }
;
;           SPltMskAdr
;
;           SPltLMask
;           SPltRMask
;
;           SPltzgooPtr
;
;

PutSprite ROUT
        ASSERT  NewPtY = NewPtX +4
        ADD     R3, WsPtr, #NewPtX
        LDMIA   R3, {R3, R4}            ; plot sprite at NewPt(X,Y)
PutSpri20
        GraphicsMode R0
        BNE     PutSpriNotGraphics      ; quit with error if not graphics mode

        Push    "WsPtr, R14"            ; push both so R12,R14 are free for use

        Push    "R2"                    ; save the pointer to the sprite

        BL      GenSpritePlotParmBlk

        Pull    "R11"

        BVS     SpriteOffScreen

        SWI     XOS_RemoveCursors       ; assume no error can occur!

        LDR     R5, [WsPtr, #SPltMemAdr]
        LDR     R6, [WsPtr, #SPltMskAdr]
        TEQ     R6, #0
        BEQ     %FT20

        ADD     R6, R6, R5
        STR     R6, [WsPtr, #SPltMskAdr]

        LDR     R14, [R11, #spMode]
        MOVS    R8,R14,ASR #27          ; check for wide mask
        BMI     PutSpriWideMaskErr
        TEQ     R8,#SpriteType_RISCOS5
      [ NoARMT2
        ANDEQ   R8, R14, #127<<20
        MOVEQ   R8, R8, LSR #20
      |
        UBFXEQ  R8, R14, #20, #7
      ]

        ;note: new format 1bpp sprites are thrown at the old routine, since it
        ;will render them faster

        CMP     R8, #2
        BCC     TransPlot               ; it's got transparent bits in it! (
        BCS     NewTransPlot            ; it's got 1bpp transparent bits in it!!!
20

; Plot sprite ignoring transparency mask (if any)


        ADD     R11, WsPtr, #SPltzgooMasks
        LDMIA   R11, {R8-R11}           ; masks for screen access (zgoo..zgee)

        LDR     R2, [WsPtr, #SPltAction]  ; GCOL action
        ADD     WsPtr, WsPtr, #SPltScrAdr ; repoint WsPtr at SPltScrAdr
        LDMIA   WsPtr, {R0-R1,R5-R7}

        TST     R2, #7
        BNE     SolPl10                 ; not store, do it slowly

; SimpleCase

SolPlFast10

;       R0    ,R1    ,     R5    ,R6   ,R7   ,(R8  ,R9  ,R10 ,R11 )
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,(zgoo,zgeo,zgoe,zgee)

; Plot the first (leftmost) word

        LDMIA   R5, {R2,R3}
        ADD     R5, R5, #4

        ShiftR  R2,R3, R6,R7            ; shift R3,R2 right R6 places
                                        ; we only need result word R2
        LDR     R4, [WsPtr, #SPltLMask-SPltScrAdr] ; on leftmost word
        AND     R3, R2, R4              ; mask down to just the required pixels

 [ AvoidScreenReads
        CMP     R4, #&FFFFFFFF
        LDRNE   R2, [R0]                ; plot 1 word
        BICNE   R2, R2, R4              ; knock out mask bits
        ORRNE   R3, R2, R3              ; and or sprite bits
 |
        LDR     R2, [R0]                ; plot 1 word
        BIC     R2, R2, R4              ; knock out mask bits
        ORR     R3, R2, R3              ; and or sprite bits
 ]
        STR     R3, [R0], #4

        SUBS    R1, R1, #1
        BLT     SolPlFast50             ; if all plotted, try next scanline
                                        ; else try for blocks of 7
        SUBS    R1, R1, #7
        BLT     SolPlFast30

        TEQ     R6, #0                  ; if shift needed, use loop 20
        BNE     SolPlFast20             ; else loop 15

SolPlFast15

;       R0    ,R1         ,R5
;       ScrAdr,ColCnt,    ,MemAdr

        LDMIA   R5!, {R2-R4,R8-R11}     ; read 7 words
        STMIA   R0!, {R2-R4,R8-R11}     ; write 7 words back to screen
        SUBS    R1, R1, #7
        BGE     SolPlFast15
        B       SolPlFast30

SolPlFast20

;       R0    ,R1         ,R5    ,R6   ,R7
;       ScrAdr,ColCnt,    ,MemAdr,ShftR,ShftL

        LDMIA   R5, {R2-R4,R8-R11,R14}  ; 8 words needed, gives 7 after shift
        ADD     R5, R5, #7*4            ; advance source ptr 7 words

        ShiftR  R2,R3, R6,R7            ; shift right R6 bits
        ShiftR  R3,R4, R6,R7            ; we only want result words
        ShiftR  R4,R8, R6,R7            ; R2-R4, R8-R11
        ShiftR  R8,R9, R6,R7
        ShiftR  R9,R10, R6,R7
        ShiftR  R10,R11, R6,R7
        ShiftR  R11,R14, R6,R7

        STMIA   R0!, {R2-R4,R8-R11}     ; write 7 words back to screen
        SUBS    R1, R1, #7
        BGE     SolPlFast20

SolPlFast30                             ; try 1 word at a time
        ADDS    R1, R1, #7

;       R0    ,R1    ,     R5    ,R6   ,R7
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL

; If EQ this is rightmost word

SolPlFast40
        LDMIA   R5, {R2,R3}
        ADD     R5, R5, #4

        ShiftR  R2,R3, R6,R7            ; shift R3,R2 right R6 places
                                        ; we only need result word R2
        BEQ     SolPlFast45             ; if rightmost word, jump out.
        STR     R2, [R0], #4

        SUBS    R1, R1, #1
        B       SolPlFast40

SolPlFast45
        LDR     R4, [WsPtr, #SPltRMask-SPltScrAdr]
        AND     R3, R2, R4              ; mask down to just the required pixels

 [ AvoidScreenReads
        CMP     R4, #&FFFFFFFF
        LDRNE   R2, [R0]                ; plot 1 word
        BICNE   R2, R2, R4              ; knock out mask bits
        ORRNE   R3, R2, R3              ; and or sprite bits
 |
        LDR     R2, [R0]                ; plot 1 word
        BIC     R2, R2, R4              ; knock out mask bits
        ORR     R3, R2, R3              ; and or sprite bits
 ]
        STR     R3, [R0], #4

SolPlFast50                             ; now try the next scanline
        LDMDB   WsPtr, {R1,R2,R3,R4}    ; R1   ,R2    ,R3    ,R4
                                        ; Width,Height,ScrOff,MemOff
        ADD     R0, R0, R3
        ADD     R5, R5, R4
        SUBS    R2, R2, #1
        STRGE   R2, [WsPtr, #SPltHeight-SPltScrAdr]
        BGE     SolPlFast10             ; plot next scanline
ComplicatedExit
        SWI     XOS_RestoreCursors
SpriteOffScreen
        Pull    "WsPtr, R14"
        RETURNVC

PutSpriWideMaskErr
        ; Not supported!
        SWI     XOS_RestoreCursors
        Pull    "WsPtr, R14"
PutSpriWideMaskErr2
        ADRL    R0, SpriteErr_InvalidSpriteMode
        B       %FT90

PutSpriNotGraphics
        ADRL    R0, SpriteErr_NotGraphics
90
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        STR     R0, [WsPtr, #RetnReg0]
        RETURNVS


; Complicated case

SolPl10 ROUT

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8  ,R9  ,R10 ,R11
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee

; Plot the first (leftmost) word

        LDMIA   R5, {R2,R3}
        ADD     R5, R5, #4

        ShiftR  R2,R3, R6,R7            ; shift R3,R2 right R6 places
                                        ; we only need result word R2

        OrrEor  R3,R2, R10,R11          ; form EOR mask
        OrrEor  R2,R2, R8,R9            ; form OR mask

        LDR     R4, [WsPtr, #SPltLMask-SPltScrAdr] ; on leftmost word
        AND     R2, R2, R4              ; mask down to just the required pixels
        AND     R3, R3, R4

        LDR     R4, [R0]                ; plot 1 word
        OrrEor  R4,R4, R2,R3
        STR     R4, [R0], #4

        SUBS    R1, R1, #1
        BLT     SolPl50                 ; if all plotted, try next scanline
                                        ; else try for blocks of 4
        SUBS    R1, R1, #4
        BLT     SolPl30

SolPl20
        STMIA   WsPtr, {R0,R1}          ; save ScrAdr,ColCnt

;       R0    ,R1         ,R5    ,R6   ,R7   ,R8  ,R9  ,R10 ,R11
;       ScrAdr,ColCnt,    ,MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee

        LDMIA   R5, {R0-R4}             ; 5 words needed, gives 4 after shift
        ADD     R5, R5, #16             ; advance source ptr 4 words
        STR     R5, [WsPtr, #SPltMemAdr-SPltScrAdr]

        ShiftR  R0,R1, R6,R7            ; shift R4-R0 right R6 bits
        ShiftR  R1,R2, R6,R7            ; we only want result words R3-R0
        ShiftR  R2,R3, R6,R7
        ShiftR  R3,R4, R6,R7

        LDR     R4, [WsPtr]             ; get screen address
        LDMIA   R4, {R4-R7}             ; get 4 screen words

        ORoreorEORoreor R4,R0, R8,R9,R10,R11, R14
        ORoreorEORoreor R5,R1, R8,R9,R10,R11, R14
        ORoreorEORoreor R6,R2, R8,R9,R10,R11, R14
        ORoreorEORoreor R7,R3, R8,R9,R10,R11, R14

        LDR     R0, [WsPtr]             ; screen address
        STMIA   R0!, {R4-R7}            ; write 4 words back to screen
        LDMIB   WsPtr, {R1,R5-R7}       ; reload anything we shat on

        SUBS    R1, R1, #4
        BGE     SolPl20

SolPl30                                  ; try 1 word at a time
        ADDS    R1, R1, #4

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8  ,R9  ,R10 ,R11
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee

; If EQ this is rightmost word

SolPl40
        LDMIA   R5, {R2,R3}
        ADD     R5, R5, #4

        ShiftR  R2,R3, R6,R7            ; shift R3,R2 right R6 places
                                        ; we only need result word R2
        OrrEor  R3,R2, R10,R11          ; form EOR mask
        OrrEor  R2,R2, R8,R9            ; form OR

        LDREQ   R4, [WsPtr, #SPltRMask-SPltScrAdr] ; if rightmost word,
        ANDEQ   R2, R2, R4              ; mask down to just the
        ANDEQ   R3, R3, R4              ; required pixels

        LDR     R4, [R0]
        OrrEor  R4,R4, R2,R3
        STR     R4, [R0], #4

        SUBS    R1, R1, #1
        BGE     SolPl40

SolPl50                                 ; now try the next scanline
        LDMDB   WsPtr, {R1,R2,R3,R4}    ; R1   ,R2    ,R3    ,R4
                                        ; Width,Height,ScrOff,MemOff
        ADD     R0, R0, R3
        ADD     R5, R5, R4
        SUBS    R2, R2, #1
        STRGE   R2, [WsPtr, #SPltHeight-SPltScrAdr]
        BGE     SolPl10                 ; plot next scanline
        B       ComplicatedExit

; *****************************************************************************
;
;       NewTransPlot - Plot sprite using 1 bpp transparency mask
;       Called with R11 -> sprite, R8 = sprite type
;       TransPlot is used for 1bpp new sprites since it will be faster

NewTransPlot ROUT

        ; need to derive: bpp, and 1<<(5-log2bpp)

        ADRL    R0, NSM_bpptable-4
        LDR     R10, [R0, R8, LSL #2]   ; get the log2bpp to R10

        ;R10=log2bpp, R11=>sprite

        LDR     R8, [R11, #spWidth]      ; words-1

        ADD     R9, R8, #1
        MOV     R9, R9, LSL #2           ; number of bytes per row
        STR     R9, [WsPtr, #SPltMaskRowPtr]

        LDR     R9, [R11, #spRBit]       ; last bit used
        ADD     R9, R9, #1               ; change to number of bits
        MOV     R9, R9, LSR R10          ; number of pixels

        RSB     R0, R10, #5
        MOV     R8, R8, LSL R0           ; number of pixels for full words

        ADD     R8, R8, R9               ; total number of pixels

        ANDS    R9, R8, #&1F
        MOVNE   R9, #4
        BIC     R8, R8, #&1F
        ADD     R9, R9, R8, LSR #3       ; number of bytes per mask row

        STR     R9, [WsPtr, #SPltMaskRowLen]

        LDR     R8, [R11, #spImage]
        LDR     R9, [R11, #spTrans]
        ADD     R8, R8, R11
        ADD     R9, R9, R11

        ;RSB     R0, R10, #5            <- DONE ABOVE

        MOV     R1, #1
        MOV     R2, R1, LSL R0          ; r2 holds number of pixels per word

        MOV     R3, R1, LSL R10         ; r3 holds bits per pixel

        ADD     WsPtr, WsPtr, #SPltScrAdr       ; repoint WsPtr, at SPltScrAdr

        LDMIA   WsPtr, {R0-R1,R5-R7,R14}

        STR     R2, [WsPtr, #SPltPixPerWord-SPltScrAdr]
        STR     R3, [WsPtr, #SPltBPP-SPltScrAdr]

        ; sort out where to begin in 1bpp mask (rewritten Aug '93)

        MOV     LR, R9                  ; LR = mask pointer
        MOV     R3, #0                  ; R3 = mask bit
        CMP     R5, R8                  ; R5=>data to plot, R8=>start of sprite

        BEQ     %FT11                   ; nothing to do, go store R3 & LR
        BCC     %FT13                   ; start is before sprite data

        ;R3, R9, r10, R11 free
        ;R2 comes in holding pix per word

        ;if R6 is non zero the image will be a word early.
        MOV     R9, R5                  ; working copy of pointer within sprite
        CMP     R6, #0
        ADDNE   R9, R9, #4              ; take out the extra word for now

        LDR     R11,[WsPtr, #SPltMaskRowLen-SPltScrAdr] ; bytes per mask row

        SUBS    R10, R9, R8             ; difference in bytes

        LDR     R8,[WsPtr, #SPltMaskRowPtr-SPltScrAdr] ; loaded with bytes per image row
        BEQ     %FT13
14
        ;is it less than a row of data
        CMP     R10, R8
        BCC     %FT12                   ; yes it is

        ;deal with a row (or more of data)
        SUB     R10, R10, R8
        ADD     LR, LR, R11
        B       %BT14

12      ;start point is on this row. subtract 4 from difference and add
        ;pix per word to mask bit/ptr until diff=0
        CMP     R10, #0
        BEQ     %FT13

        SUB     R10, R10, #4

        ADD     R3, R3, R2
        CMP     R3, #32
        SUBCS   R3, R3, #32
        ADDCS   LR, LR, #4
        CMP     R10, #0
        BNE     %BT12

13
        ;deal with R6
        CMP     R6,#0
        BEQ     %FT11

        SUBS    R3, R3, R2                ;subtract pix per word
        ADDMI   R3, R3, #32
        SUBMI   LR, LR, #4                ;deal with going into previous word

11
        STR     R3, [WsPtr, #SPltMaskBit-SPltScrAdr]
        STR     LR, [WsPtr, #SPltMaskPtr-SPltScrAdr]

        ; and save it for the end of row increments
        STR     R3, [WsPtr, #SPltMaskRowBit-SPltScrAdr]
        STR     LR, [WsPtr, #SPltMaskRowPtr-SPltScrAdr]

        ADD     R11, WsPtr, #SPltzgooMasks-SPltScrAdr
        LDMIA   R11, {R8-R11}           ; masks for screen access (zgoo..zgee)

NTrnPl10

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8  ,R9  ,R10 ,R11,    R14
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee,
;
; As far as possible this is based on the original transplot.
;

; Plot the first (leftmost) word

        BL      getmaskword
        MOV     R2, R3

        BL      getmaskword_noinc
        ShiftR  R2,R3, R6,R7            ; we only need result word R2

        LDMIA   R5, {R3,R4}             ; fetch and shift image
        ADD     R5, R5, #4
        ShiftR  R3,R4, R6,R7            ; shift R4,R3 right R6 places

        OrrEor  R4,R3, R10,R11          ; form EOR mask
        OrrEor  R3,R3, R8,R9            ; form OR mask

        AND     R3, R3, R2              ; clear out any transparent pixels
        AND     R4, R4, R2

        LDR     R2, [WsPtr, #SPltLMask-SPltScrAdr] ; on leftmost word
        AND     R3, R3, R2              ; mask down to just the required pixels
        AND     R4, R4, R2

        LDR     R2, [R0]                ; plot 1 word
        OrrEor  R2,R2, R3,R4
        STR     R2, [R0], #4

        SUBS    R1, R1, #1
        BLT     NTrnPl50                 ; if all plotted, try next scanline
                                        ; else try for blocks of 2
        SUBS    R1, R1, #2
        BLT     NTrnPl30

NTrnPl20
        STMIA   WsPtr, {R0,R1}          ; ScrAdr,ColCnt

;       R0    ,R1         ,R5    ,R6   ,R7   ,R8  ,R9  ,R10 ,R11 ,   R14
;       ScrAdr,ColCnt,    ,MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee,   MskAdr


        BL     getmaskword
        MOV    R0, R3
        BL     getmaskword
        MOV    R1, R3

        BL     getmaskword_noinc
        MOV    R2, R3
        ShiftR R0,R1, R6,R7
        ShiftR R1,R2, R6,R7             ; aligned mask in R0,R1

        LDMIA  R5, {R2-R4}              ; 3 image words needed, gives 2 after
        ADD    R5, R5, #8               ; shifting
        STR    R5, [WsPtr, #SPltMemAdr-SPltScrAdr]
        ShiftR R2,R3, R6,R7
        ShiftR R3,R4, R6,R7             ; aligned image in R2,R3

        LDR    R4, [WsPtr]              ; screen address
        LDMIA  R4, {R4,R5}              ; 2 screen words

        ORoreorEORoreorMASK R4,R2,R0, R8,R9,R10,R11, R14
        ORoreorEORoreorMASK R5,R3,R1, R8,R9,R10,R11, R14

        LDR    R0, [WsPtr]              ; screen address
        STMIA  R0!, {R4,R5}             ; write 2 words back to screen
        LDMIB  WsPtr, {R1,R5,R6}        ; reload anything we shat on

        SUBS   R1, R1, #2
        BGE    NTrnPl20

NTrnPl30                                 ; try 1 word at a time
        ADDS   R1, R1, #2

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8  ,R9  ,R10 ,R11
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee

; If EQ this is rightmost word

NTrnPl40

        BL      getmaskword
        MOV     R2, R3

        BL      getmaskword_noinc
        ShiftR  R2,R3, R6,R7    ; shift R3,R2 right R6 places, result in R2

        LDMIA   R5, {R3,R4}     ; fetch and align image
        ADD     R5, R5, #4
        ShiftR  R3,R4, R6,R7    ; shift R4,R3 right R6 places, result in R3

        OrrEor  R4,R3, R10,R11  ; form EOR mask
        OrrEor  R3,R3, R8,R9    ; form OR

        AND     R3, R3, R2      ; clear out transparant pixels
        AND     R4, R4, R2

        LDREQ   R2, [WsPtr, #SPltRMask-SPltScrAdr] ; if rightmost word,
        ANDEQ   R3, R3, R2              ; mask down to just the
        ANDEQ   R4, R4, R2              ; required pixels

        LDR     R2, [R0]
        OrrEor  R2,R2, R3,R4
        STR     R2, [R0], #4

        SUBS    R1, R1, #1
        BGE     NTrnPl40

NTrnPl50
        ; now try the next scanline

        ; BEWARE ... genspriteplotparmblock returns values for memoff and
        ; scroff which take account of alignment of screen and sprite data
        ;
        ; Do not alter the logic below unless you really know what
        ; to expect from this routine!!

        LDR     LR, [WsPtr, #SPltMaskRowPtr-SPltScrAdr]
        LDR     R3, [WsPtr, #SPltMaskRowBit-SPltScrAdr]

        LDR     R2, [WsPtr, #SPltMaskRowLen-SPltScrAdr]

        ADD     LR, LR, R2

        STR     LR, [WsPtr, #SPltMaskPtr-SPltScrAdr]
        STR     R3, [WsPtr, #SPltMaskBit-SPltScrAdr]
        STR     LR, [WsPtr, #SPltMaskRowPtr-SPltScrAdr]
        STR     R3, [WsPtr, #SPltMaskRowBit-SPltScrAdr]

        LDMDB   WsPtr, {R1,R2,R3,R4}    ; R1   ,R2    ,R3    ,R4
                                        ; Width,Height,ScrOff,MemOff

        ADD     R0, R0, R3
        ADD     R5, R5, R4

        SUBS    R2, R2, #1
        STRGE   R2, [WsPtr, #SPltHeight-SPltScrAdr]
        BGE     NTrnPl10                 ; plot next scanline

        SWI     XOS_RestoreCursors

        Pull    "WsPtr, R14"
        RETURNVC

; get a mask word without incrementing the pointers

getmaskword_noinc ROUT
        Push    "R4, R5, LR"

        LDR     R4, [WsPtr, #SPltMaskBit-SPltScrAdr]
        LDR     R5, [WsPtr, #SPltMaskPtr-SPltScrAdr]
        BL      getmaskword                             ; preserves flags
        STR     R4, [WsPtr, #SPltMaskBit-SPltScrAdr]
        STR     R5, [WsPtr, #SPltMaskPtr-SPltScrAdr]

        LDMFD   R13!,{R4,R5,R15}                        ; must preserve flags

; get a mask word, and increment pointers

getmaskword ROUT
        Push    "R2,R4,R5,R6,R7,R8,R14"
        MRS     R8, CPSR

;R6 -> mask
;R7 = bit offset

;return in R3, update R6, R7, restore other registers

        MOV     R3, #0                   ; initial result
        LDR     LR, [WsPtr, #SPltPixPerWord-SPltScrAdr]  ; pixels per word
        LDR     R2, [WsPtr, #SPltBPP-SPltScrAdr]    ; bpp

        LDR     R7, [WsPtr, #SPltMaskBit-SPltScrAdr]
        LDR     R6, [WsPtr, #SPltMaskPtr-SPltScrAdr]

        LDR     R4, [R6]                 ; get the mask word
10
        CMP     R7, #0
        LDREQ   R4, [R6]                 ; fetch a new word if required
        MOV     R5, R4, LSR R7           ; shift desired bit down to bit 0

        MOV     R3, R3, LSR #1           ; shift down the result by one bit
        ORR     R3, R3, R5, LSL #31      ; and put bit 0 in at bit 31

        ; now use an ASR of bpp-1 to finish off
        SUB     R5, R2, #1
        MOV     R3, R3, ASR R5

        ADD     R7, R7, #1               ; next mask bit

        CMP     R7, #32                  ; on to next word ?
        ADDEQ   R6, R6, #4               ; increment mask word pointer
        MOVEQ   R7, #0                   ; bit pointer back to 0
                                         ; but don't fetch new word until it is needed!

        SUBS    LR, LR, #1               ; one pixel done
        BNE     %BT10

        STR     R7, [WsPtr, #SPltMaskBit-SPltScrAdr]
        STR     R6, [WsPtr, #SPltMaskPtr-SPltScrAdr]

        ;result in R3, MaskBit/MaskPtr adjusted

        MSR     CPSR_f, R8
        LDMFD   R13!,{R2,R4,R5,R6,R7,R8,R15} ; must save flags

        LTORG

; *****************************************************************************
;
;       TransPlot - Plot sprite using transparency mask
;

TransPlot
        ADD     R11, WsPtr, #SPltzgooMasks
        LDMIA   R11, {R8-R11}           ; masks for screen access (zgoo..zgee)

        ADD     WsPtr, WsPtr, #SPltScrAdr       ; repoint WsPtr, at SPltScrAdr

        LDMIA   WsPtr, {R0-R1,R5-R7,R14}

TrnPl10

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8  ,R9  ,R10 ,R11,    R14
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee,   MskAdr

; Plot the first (leftmost) word

        LDMIA   R14, {R2,R3}            ; fetch and shift mask right R6 places
        ADD     R14, R14, #4
        ShiftR  R2,R3, R6,R7            ; we only need result word R2

        LDMIA   R5, {R3,R4}             ; fetch and shift image
        ADD     R5, R5, #4
        ShiftR  R3,R4, R6,R7            ; shift R4,R3 right R6 places
                                        ; we only need result word R3
        OrrEor  R4,R3, R10,R11          ; form EOR mask
        OrrEor  R3,R3, R8,R9            ; form OR mask

        AND     R3, R3, R2              ; clear out any transparent pixels
        AND     R4, R4, R2

        LDR     R2, [WsPtr, #SPltLMask-SPltScrAdr] ; on leftmost word
        AND     R3, R3, R2              ; mask down to just the required pixels
        AND     R4, R4, R2

        LDR     R2, [R0]                ; plot 1 word
        OrrEor  R2,R2, R3,R4
        STR     R2, [R0], #4

        SUBS    R1, R1, #1
        BLT     TrnPl50                 ; if all plotted, try next scanline
                                        ; else try for blocks of 2
        SUBS    R1, R1, #2
        BLT     TrnPl30

TrnPl20
        STMIA   WsPtr, {R0,R1}          ; ScrAdr,ColCnt

;       R0    ,R1         ,R5    ,R6   ,R7   ,R8  ,R9  ,R10 ,R11 ,   R14
;       ScrAdr,ColCnt,    ,MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee,   MskAdr

        LDMIA  R14, {R0-R2}             ; 3 mask words, gives 2 after shifting
        ADD    R14, R14, #8             ; advance mask ptr 2 words
        ShiftR R0,R1, R6,R7
        ShiftR R1,R2, R6,R7             ; aligned mask in R0,R1

        LDMIA  R5, {R2-R4}              ; 3 image words needed, gives 2 after
        ADD    R5, R5, #8               ; shifting
        STR    R5, [WsPtr, #SPltMemAdr-SPltScrAdr]
        ShiftR R2,R3, R6,R7
        ShiftR R3,R4, R6,R7             ; aligned image in R2,R3

        LDR    R4, [WsPtr]              ; screen address
        LDMIA  R4, {R4,R5}              ; 2 screen words

        ORoreorEORoreorMASK R4,R2,R0, R8,R9,R10,R11, R6
        ORoreorEORoreorMASK R5,R3,R1, R8,R9,R10,R11, R6

        LDR    R0, [WsPtr]              ; screen address
        STMIA  R0!, {R4,R5}             ; write 2 words back to screen
        LDMIB  WsPtr, {R1,R5-R6}        ; reload anything we shat on

        SUBS   R1, R1, #2
        BGE    TrnPl20

TrnPl30                                 ; try 1 word at a time
        ADDS   R1, R1, #2

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8  ,R9  ,R10 ,R11
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee

; If EQ this is rightmost word

TrnPl40
        LDMIA   R14, {R2,R3}    ; fetch and align trans mask
        ADD     R14, R14, #4
        ShiftR  R2,R3, R6,R7    ; shift R3,R2 right R6 places, result in R2

        LDMIA   R5, {R3,R4}     ; fetch and align image
        ADD     R5, R5, #4
        ShiftR  R3,R4, R6,R7    ; shift R4,R3 right R6 places, result in R3

        OrrEor  R4,R3, R10,R11  ; form EOR mask
        OrrEor  R3,R3, R8,R9    ; form OR

        AND     R3, R3, R2      ; clear out transparant pixels
        AND     R4, R4, R2

        LDREQ   R2, [WsPtr, #SPltRMask-SPltScrAdr] ; if rightmost word,
        ANDEQ   R3, R3, R2              ; mask down to just the
        ANDEQ   R4, R4, R2              ; required pixels

        LDR     R2, [R0]
        OrrEor  R2,R2, R3,R4
        STR     R2, [R0], #4

        SUBS    R1, R1, #1
        BGE     TrnPl40

TrnPl50                                 ; now try the next scanline
        LDMDB   WsPtr, {R1,R2,R3,R4}    ; R1   ,R2    ,R3    ,R4
                                        ; Width,Height,ScrOff,MemOff
        ADD     R0, R0, R3
        ADD     R5, R5, R4
        ADD     R14, R14, R4
        SUBS    R2, R2, #1
        STRGE   R2, [WsPtr, #SPltHeight-SPltScrAdr]
        BGE     TrnPl10                 ; plot next scanline

        SWI     XOS_RestoreCursors

        Pull    "WsPtr, R14"
        RETURNVC

        LTORG

; *****************************************************************************
;
;       PlotMaskUserCoords - Draw a rectangle through a sprite mask
;                            using given external coordinates
;
;       External routine
;
; in:   R1 -> sprite area (not used)
;       R2 -> sprite
;       R3 = X coordinate to plot at
;       R4 = Y coordinate to plot at
;

PlotMaskUserCoords ROUT
        Push    R14
        BL      InternaliseCoords
        Pull    R14
        B       PlotMa20

; *****************************************************************************
;
; PlotNewMask
;
; Version of PlotMask for new 1bpp format sprites
;
; R0 = sprite mode word
; R2 -> sprite
; R10 = bits 27-31 of mode word

PlotNewMask ROUT

        TEQ     R10, #SpriteType_RISCOS5
      [ NoARMT2
        ANDEQ   R10, R0, #127<<20
        MOVEQ   R10, R10, LSR #20
      |
        UBFXEQ  R10, R0, #20, #7
      ]
        ADRL    R0, NSM_bpptable-4
        LDR     R10, [R0, R10, LSL #2]          ;get the log2bpp

        ;derive mask row length
        ;r10=log2bpp, r2=>sprite

        LDR     R8, [R2, #spWidth]       ; words-1

        ADD     R9, R8, #1               ; total words for a line of image
        MOV     R9, R9, LSL #2           ; total bytes for a line of image
        STR     R9, [WsPtr, #SPltMaskRowPtr]
                                         ; save it for determining mask start position

        LDR     R9, [R2, #spRBit]        ; last bit used
        ADD     R9, R9, #1               ; change to number of bits
        MOV     R9, R9, LSR R10          ; number of pixels

        RSB     R0, R10, #5
        MOV     R8, R8, LSL R0           ; number of pixels for full words

        ADD     R8, R8, R9               ; total number of pixels

        ANDS    R9, R8, #&1F
        MOVNE   R9, #4
        BIC     R8, R8, #&1F
        ADD     R9, R9, R8, LSR #3       ; number of bytes per mask row

        STR     R9, [WsPtr, #SPltMaskRowLen]

        MOV     R1, #1
        MOV     R0, R1, LSL R0                  ;number of pixels

        MOV     R6, R1, LSL R10                 ;bits per pixel

        STR     R0, [WsPtr, #SPltPixPerWord]
        STR     R6, [WsPtr, #SPltBPP]

        LDR     R0, [R2, #spHeight]
        ADD     R0, R0, R4
        LDR     R10, [WsPtr, #GWTRow]
        Least   R0, R0, R10             ; top scanline within window

        LDR     R10, [WsPtr, #YWindLimit]
        SUB     R0, R10, R0             ; flip Y
        AND     R0, R0, #7
        STR     R0, [WsPtr, #SPltEcfIndx] ; index into Ecf

        ADD     R0, WsPtr, R0, LSL #3
        ADD     R0, R0, #BgEcfOraEor
        STR     R0, [WsPtr, #SPltEcfPtr] ; ptr to ECF for highest row plotted

        ;STR     R2, [WsPtr, #SPltMaskRowPtr] ;temp, to save it

        LDR     R8, [R2, #spImage]
        LDR     R9, [R2, #spTrans]
        ADD     R8, R8, R2
        ADD     R9, R9, R2

        Push    "WsPtr, R14"            ; push both so R12,R14 are free for use
        Push    "R2"

        BL      GenSpritePlotParmBlk

        Pull    "R2"

        BVS     SpriteOffScreen
        SWI     XOS_RemoveCursors       ; assume no error can occur!

        ;LDR     R2, [WsPtr, #SPltMaskRowPtr]  ;recover pointer to sprite

        LDR     R8, [R2, #spImage]            ;offset to image
        LDR     R9, [R2, #spTrans]            ;offset to mask
        ADD     R8, R8, R2                    ;change to address of image
        ADD     R9, R9, R2                    ;change to address of mask

        LDR     R5, [WsPtr, #SPltMemAdr]      ;start memory address to plot
        LDR     LR, [WsPtr, #SPltMskAdr]      ;start mask address to plot
        TEQ     LR, #0                        ;off screen ?
        BEQ     SpriteOffScreen               ;so plot nothing

        ;amg 19/1/94 rip out the original algorithm and replace it with the correct one
        ;used with newtransplot which correctly handles genspriteplotparmblk's oddities

        ;now deal with sprites where we aren't starting
        ;at the beginning....
        LDR     R2, [WsPtr, #SPltPixPerWord]  ;pick up pixels per word

        MOV     LR, R9                        ;save mask address
        MOV     R3, #0                        ;set mask pixel counter to 0
        CMP     R5, R8                        ;memory address to plot from = image address ?
        BEQ     %FT11                         ;yes - no fudging needed
        BCC     %FT13

        MOV     R9, R5                        ;working copy of plot start within sprite
        CMP     R6, #0
        ADDNE   R9, R9, #4                    ;take out the extra word for now

        LDR     R11, [WsPtr, #SPltMaskRowLen] ;bytes per mask row
        SUBS    R10, R9, R8                   ;difference between plot start & sprite start
        LDR     R8, [WsPtr, #SPltMaskRowPtr]  ;bytes per image row
        BEQ     %FT13                         ;no difference

14
        ;is it less than a row of data different ?
        CMP     R10, R8
        BCC     %FT12                         ;yes, it is

        ;deal with whole rows
        SUB     R10, R10, R8                  ;decrease difference by size of image row
        ADD     LR, LR, R11                   ;increase mask pointer by size of mask row
        B       %BT14                         ;and loop until less than a row to do

12      ;start pointer is on this row. reduce the difference and increase the mask start
        ;point until they match

        CMP     R10, #0                       ;check for nothing to do
        BEQ     %FT13

        SUB     R10, R10, #4                  ;reduce image by a word

        ADD     R3, R3, R2                    ;increase mask start pixel by the number of
                                              ;pixels in that word

        CMP     R3, #32
        SUBCS   R3, R3, #32
        ADDCS   LR, LR, #4                    ;get the mask bit back into a word's worth

        CMP     R10, #0                       ;extra test down here to avoid taking two
        BNE     %BT12                         ;branches

13      ;remember R6 ? uncompensate now
        CMP     R6, #0
        BEQ     %FT11

        SUBS    R3, R3, R2                    ;go back by the number of pixels in a word
        ADDMI   R3, R3, #32
        SUBMI   LR, LR, #4                    ;deal with going back into previous mask word

11
        STR     R3, [WsPtr, #SPltMaskBit]     ;starting mask bit to plot
        STR     LR, [WsPtr, #SPltMaskPtr]     ;starting mask word to plot

        ; and save it for the end of row increments
        STR     R3, [WsPtr, #SPltMaskRowBit]
        STR     LR, [WsPtr, #SPltMaskRowPtr]

        STR     LR, [WsPtr, #SPltMskAdr]
        STR     LR, [WsPtr, #SPltMemAdr]

        ADD     WsPtr, WsPtr, #SPltScrAdr ; repoint WsPtr at SPltScrAdr

        LDMIA   WsPtr, {R0-R1,R5-R7}

        LDR     R5, [WsPtr, #SPltMaskPtr-SPltScrAdr]
        LDR     R8, [WsPtr, #SPltEcfPtr-SPltScrAdr]
10
        LDMIA   R8, {R8,R9}             ; ora,eor for this row

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8 ,R9
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,ora,eor

;       Plot the first (Leftmost) word

        BL      getmaskword
        MOV     R2, R3

        BL      getmaskword_noinc

        ShiftR  R2,R3, R6,R7            ; shift R3,R2 right R6 places
                                        ; we only need result word R2
        LDR     R10, [WsPtr, #SPltLMask-SPltScrAdr] ; on leftmost word
        AND     R2, R2, R10             ; mask down to just the required pixels

        LDR     R4, [R0]                ; plot 1 word
        OrrEorMASK R4,R2, R8,R9, R14
        STR     R4, [R0], #4

        SUBS    R1, R1, #1
        BLT     %FT50                   ; if all plotted, try next scanline
                                        ; else try for blocks of 4
        SUBS    R1, R1, #4
        BLT     %FT30

20
        STMIA   WsPtr, {R0,R1}          ; save ScrAdr,ColCnt

;       R0    ,R1         ,R5    ,R6   ,R7
;       ScrAdr,ColCnt,    ,MemAdr,ShftR,ShftL


        BL     getmaskword
        MOV    R0, R3
        BL     getmaskword
        MOV    R1, R3
        BL     getmaskword
        MOV    R2, R3
        BL     getmaskword
        MOV    R8, R3
        BL     getmaskword_noinc
        MOV    R4,R3
        MOV    R3,R8

        ShiftR  R0,R1, R6,R7            ; shift R4-R0 right R6 bits
        ShiftR  R1,R2, R6,R7            ; we only want result words R3-R0
        ShiftR  R2,R3, R6,R7
        ShiftR  R3,R4, R6,R7

        LDR     R4, [WsPtr]             ; get screen address
        LDMIA   R4, {R8-R11}            ; get 4 screen words

        LDR     R6, [WsPtr, #SPltEcfPtr-SPltScrAdr]
        LDMIA   R6, {R6,R7}             ; ora,eor for this row

        OrrEorMASK R8,R0,  R6,R7, R14   ; Scr:=ScrOR(oraANDmsk)EOR(eorANDmsk)
        OrrEorMASK R9,R1,  R6,R7, R14
        OrrEorMASK R10,R2, R6,R7, R14
        OrrEorMASK R11,R3, R6,R7, R14

        LDR     R0, [WsPtr]             ; screen address
        STMIA   R0!, {R8-R11}           ; write 4 words back to screen
        LDMIB   WsPtr, {R1,R5-R7}       ; reload anything we shat on

        SUBS    R1, R1, #4
        BGE     %BT20

30                                      ; try 1 word at a time
        ADDS    R1, R1, #4

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8 ,R9
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,ora,eor

; If EQ this is rightmost word

        LDR     R8, [WsPtr, #SPltEcfPtr-SPltScrAdr]
        LDMIA   R8, {R8,R9}             ; ora,eor for this row
        LDR     R10, [WsPtr, #SPltRMask-SPltScrAdr]
40

        BL      getmaskword
        MOV     R2, R3

        BL      getmaskword_noinc
        ShiftR  R2,R3, R6,R7    ; shift R3,R2 right R6 places, result in R2
                                ; we only need result word R2

        ANDEQ   R2, R2, R10     ; if rightmost word, mask down to just the
                                ; required pixels
        LDR     R4, [R0]
        OrrEorMASK R4,R2, R8,R9, R14
        STR     R4, [R0], #4

        SUBS    R1, R1, #1
        BGE     %BT40

50                              ; now try the next scanline
        ; BEWARE ... genspriteplotparmblock returns values for memoff and
        ; scroff which take account of alignment of screen and sprite data
        ;
        ; Do not alter the logic below unless you really know what
        ; to expect from this routine!!

        LDMDB   WsPtr, {R1,R2,R3,R4}    ; R1   ,R2    ,R3    ,R4
                                        ; Width,Height,ScrOff,MemOff


        LDR     LR, [WsPtr, #SPltMaskRowPtr-SPltScrAdr]
        LDR     R3, [WsPtr, #SPltMaskRowBit-SPltScrAdr]

        LDR     R2, [WsPtr, #SPltMaskRowLen-SPltScrAdr]

        ADD     LR, LR, R2

        STR     LR, [WsPtr, #SPltMaskPtr-SPltScrAdr]
        STR     R3, [WsPtr, #SPltMaskBit-SPltScrAdr]
        STR     LR, [WsPtr, #SPltMaskRowPtr-SPltScrAdr]
        STR     R3, [WsPtr, #SPltMaskRowBit-SPltScrAdr]

        LDMDB   WsPtr, {R1,R2,R3,R4}    ; R1   ,R2    ,R3    ,R4
                                        ; Width,Height,ScrOff,MemOff
        ADD     R0, R0, R3

        ADD     R10, WsPtr, #(SPltEcfPtr-SPltScrAdr)

        LDMIA   R10, {R8,R9}    ; EcfPtr,EcfIndx
        ADD     R8, R8, #8      ; step both to next row in Ecf
        ADD     R9, R9, #1
        CMP     R9, #8
        MOVGE   R9, #0          ; it's a wrap!
        SUBGE   R8, R8, #(8*8)
        STMIA   R10, {R8,R9}

        SUBS    R2, R2, #1
        STRGE   R2, [WsPtr, #SPltHeight-SPltScrAdr]
        BGE     %BT10                   ; plot next scanline

        SWI XOS_RestoreCursors

        Pull    "WsPtr, R14"
        RETURNVC

; *****************************************************************************
;
;       PlotMask - Draw a rectangle through a sprite mask
;
;       External routine + PlotMa20 called by PlotMaskUserCoords
;        (also external)
;
; in:   R1 -> sprite area (not used)
;       R2 -> sprite
;

PlotMask ROUT
        ASSERT  NewPtY = NewPtX +4
        ADD     R3, WsPtr, #NewPtX
        LDMIA   R3, {R3, R4}            ; plot sprite at NewPt(X,Y)
PlotMa20
        GraphicsMode R0
        BNE     PutSpriNotGraphics      ; quit with error if not graphics mode

        LDR     R5, [WsPtr, #GPLBMD]    ; background GCOL action
        ORR     R5, R5, #8              ; force 'use mask'
        LDR     R10, [R2, #spImage]
        LDR     R11, [R2, #spTrans]
        TEQ     R10, R11                ; spImage=spTrans if no mask
        BEQ     %FT90                   ; so plot a rectangle

        LDR     R0, [R2, #spMode]
        MOVS    R10, R0, ASR #27
        BMI     PutSpriWideMaskErr2
        BNE     PlotNewMask

        LDR     R0, [R2, #spHeight]
        ADD     R0, R0, R4
        LDR     R10, [WsPtr, #GWTRow]
        Least   R0, R0, R10             ; top scanline within window

        LDR     R10, [WsPtr, #YWindLimit]
        SUB     R0, R10, R0             ; flip Y
        AND     R0, R0, #7
        STR     R0, [WsPtr, #SPltEcfIndx] ; index into Ecf

        ADD     R0, WsPtr, R0, LSL #3
        ADD     R0, R0, #BgEcfOraEor
        STR     R0, [WsPtr, #SPltEcfPtr] ; ptr to ECF for highest row plotted

        Push    "WsPtr, R14"            ; push both so R12,R14 are free for use
        BL      GenSpritePlotParmBlk
        BVS     SpriteOffScreen
        SWI     XOS_RemoveCursors       ; assume no error can occur!

        LDR     R5, [WsPtr, #SPltMemAdr]
        LDR     R6, [WsPtr, #SPltMskAdr]
        TEQ     R6, #0
        BEQ     SpriteOffScreen

        ADD     R6, R6, R5
        STR     R6, [WsPtr, #SPltMskAdr]
        STR     R6, [WsPtr, #SPltMemAdr]

        ADD     WsPtr, WsPtr, #SPltScrAdr ; repoint WsPtr at SPltScrAdr

        LDMIA   WsPtr, {R0-R1,R5-R7}
        LDR     R8, [WsPtr, #SPltEcfPtr-SPltScrAdr]
10
        LDMIA   R8, {R8,R9}             ; ora,eor for this row

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8 ,R9
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,ora,eor

;       Plot the first (Leftmost) word

        LDMIA   R5, {R2,R3}
        ADD     R5, R5, #4

        ShiftR  R2,R3, R6,R7            ; shift R3,R2 right R6 places
                                        ; we only need result word R2
        LDR     R10, [WsPtr, #SPltLMask-SPltScrAdr] ; on leftmost word
        AND     R2, R2, R10             ; mask down to just the required pixels

        LDR     R4, [R0]                ; plot 1 word
        OrrEorMASK R4,R2, R8,R9, R14
        STR     R4, [R0], #4

        SUBS    R1, R1, #1
        BLT     %FT50                   ; if all plotted, try next scanline
                                        ; else try for blocks of 4
        SUBS    R1, R1, #4
        BLT     %FT30

20
        STMIA   WsPtr, {R0,R1}          ; save ScrAdr,ColCnt

;       R0    ,R1         ,R5    ,R6   ,R7
;       ScrAdr,ColCnt,    ,MemAdr,ShftR,ShftL

        LDMIA   R5, {R0-R4}             ; 5 words needed, gives 4 after shift
        ADD     R5, R5, #16             ; advance source ptr 4 words
        STR     R5, [WsPtr, #SPltMemAdr-SPltScrAdr]

        ShiftR  R0,R1, R6,R7            ; shift R4-R0 right R6 bits
        ShiftR  R1,R2, R6,R7            ; we only want result words R3-R0
        ShiftR  R2,R3, R6,R7
        ShiftR  R3,R4, R6,R7

        LDR     R4, [WsPtr]             ; get screen address
        LDMIA   R4, {R8-R11}            ; get 4 screen words

        LDR     R6, [WsPtr, #SPltEcfPtr-SPltScrAdr]
        LDMIA   R6, {R6,R7}             ; ora,eor for this row

        OrrEorMASK R8,R0,  R6,R7, R14   ; Scr:=ScrOR(oraANDmsk)EOR(eorANDmsk)
        OrrEorMASK R9,R1,  R6,R7, R14
        OrrEorMASK R10,R2, R6,R7, R14
        OrrEorMASK R11,R3, R6,R7, R14

        LDR     R0, [WsPtr]             ; screen address
        STMIA   R0!, {R8-R11}           ; write 4 words back to screen
        LDMIB   WsPtr, {R1,R5-R7}       ; reload anything we shat on

        SUBS    R1, R1, #4
        BGE     %BT20

30                                      ; try 1 word at a time
        ADDS    R1, R1, #4

;       R0    ,R1    ,     R5    ,R6   ,R7   ,R8 ,R9
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,ora,eor

; If EQ this is rightmost word

        LDR     R8, [WsPtr, #SPltEcfPtr-SPltScrAdr]
        LDMIA   R8, {R8,R9}             ; ora,eor for this row
        LDR     R10, [WsPtr, #SPltRMask-SPltScrAdr]
40
        LDMIA   R5, {R2,R3}
        ADD     R5, R5, #4

        ShiftR  R2,R3, R6,R7    ; shift R3,R2 right R6 places
                                ; we only need result word R2

        ANDEQ   R2, R2, R10     ; if rightmost word, mask down to just the
                                ; required pixels
        LDR     R4, [R0]
        OrrEorMASK R4,R2, R8,R9, R14
        STR     R4, [R0], #4

        SUBS    R1, R1, #1
        BGE     %BT40

50                              ; now try the next scanline

        LDMDB   WsPtr, {R1,R2,R3,R4}    ; R1   ,R2    ,R3    ,R4
                                        ; Width,Height,ScrOff,MemOff
        ADD     R0, R0, R3
        ADD     R5, R5, R4

        ADD     R10, WsPtr, #(SPltEcfPtr-SPltScrAdr)

        LDMIA   R10, {R8,R9}    ; EcfPtr,EcfIndx
        ADD     R8, R8, #8      ; step both to next row in Ecf
        ADD     R9, R9, #1
        CMP     R9, #8
        MOVGE   R9, #0          ; it's a wrap!
        SUBGE   R8, R8, #(8*8)
        STMIA   R10, {R8,R9}

        SUBS    R2, R2, #1
        STRGE   R2, [WsPtr, #SPltHeight-SPltScrAdr]
        BGE     %BT10                   ; plot next scanline

        SWI XOS_RestoreCursors

        Pull    "WsPtr, R14"
        RETURNVC

; Sprite has no mask or gcol says dont use it, so draw a rectangle

90
        Push    R14
        BL      ReadSpriteWidth         ; on exit R0=width in pixels
        ADD     R5, R3, R0
        MOV     R0, R3                  ; x0
        MOV     R1, R4                  ; y0

        LDR     R3, [R2, #spHeight]
        ADD     R3, R3, R4              ; y1
        SUB     R2, R5, #1              ; x1

        LDR     R4, [WsPtr, #CursorFlags]
        TST     R4, #ClipBoxEnableBit
        BLNE    ClipPlotMask

        ADD     R4, WsPtr, #BgEcfOraEor ; select Bg colour & action
        STR     R4, [WsPtr, #GColAdr]
        B       RectFillB

ClipPlotMask ROUT
        Push    "R0-R7,R10,R11, R14"
        ADD     R10, R13, #2*4          ; R10 -> last point (R2,R3)
        MOV     R11, #2                 ; merge two points
        BL      MergeR11PointsFromR10
        Pull    "R0-R7,R10,R11, PC"

; *****************************************************************************
;
;       GenSpritePlotParmBlk - Generate lots of useful variables to help us
;                              to plot sprite
;
;       Internal routine, called by PutSprite, PlotMask, ScreenLoad
;
; in:   R2 -> sprite
;       R3 = X coordinate to plot at
;       R4 = Y coordinate to plot at
;       R5 = GCOL action
;

GenSpritePlotParmBlk ROUT
        Push    R14
        AND     R5, R5, #&F             ; lose any ECF colour bits
        LDR     R6, [R2, #spImage]
        LDR     R7, [R2,#spTrans]
        SUB     R6, R7, R6              ; offset from Image to Trans mask
                                        ; =0 if no mask
        STR     R5, [WsPtr, #SPltAction] ; save action for simple case spotting
        CMP     R5, #8                  ; if GCOL action < 8
        MOVLT   R6, #0                  ; plot as solid anyway
        STR     R6, [WsPtr, #SPltMskAdr]

        AND     R5, R5, #7
        MOV     R5, R5, LSL #2          ; 4 bits for each
        LDR     R6, =TBscrmasks
        MOV     R6, R6, ROR R5          ; put correct bits in top 4 bits
        MOV     R7, R6, ASR #31         ; set R7 to 0 or -1 on bit 31
        MOV     R6, R6, LSL #1
        MOV     R8, R6, ASR #31         ; set R8 to 0 or -1 on bit 30
        MOV     R6, R6, LSL #1
        MOV     R9, R6, ASR #31         ; set R9 to 0 or -1 on bit 29
        MOV     R6, R6, LSL #1
        MOV     R10, R6, ASR #31        ; set R10 to 0 or -1 on bit 28

        ADD     R6, WsPtr, #SPltzgooMasks
        STMIA   R6, {R7-R10}            ; store zgoo, zgeo, zgoe, zgee

        MOV     R14, R2                 ; leave sprite CB ptr in R14
        MOV     R0, R3                  ; leave X coord in R0
        MOV     R1, R4                  ; leave Y coord in R1

        ADD     R11, R14, #spWidth
        LDMIA   R11, {R2,R3}            ; Width-1, Height-1

        ADD     R4, WsPtr, #GWLCol      ; R4  ,R5  ,R6  ,R7
        LDMIA   R4, {R4,R5,R6,R7}       ; LCol,BRow,RCol,TRow

        SUBS    R5, R5, R1
        MOVLT   R5, #0                  ; no. of rows below window

        ADD     R1, R1, R3              ; Coord of topLH of sprite

        SUBS    R7, R1, R7
        MOVLT   R7, #0                  ; no. of rows above window
        SUB     R1, R1, R7              ; clipped topLH coord

        ADD     R5, R5, R7              ; reduction factor for height

        ADD     R2, R2, #1

        MOV     R8, R14
        LDR     R9, [WsPtr, #CursorFlags]
        TST     R9, #ClipBoxEnableBit
        BLNE    ClipSpritePlot
        MOV     R14, R8

        MUL     R3, R7, R2              ; word offset into sprite image

        Push    "R3,R5"                 ; word offset and height reduction

        Push    R14
        BL      ScreenAddr
        Pull    R14
        MOV     R4, R2                  ; address of top left corner

        LDR     R5, [R14, #spImage]
        ADD     R5, R5, R14             ; address of sprite image

        Pull    R6
        ADD     R5, R5, R6, LSL #2

        LDR     R9, [WsPtr, #XShftFactor]
        LDR     R10, [WsPtr, #NPix]
        LDR     R11, [WsPtr, #Log2BPC]

        BitLOffset R7,R0, R9,R10,R11    ; R7 := bit position to align to
        WordOffset R8,R0, R9,R10,R11    ; R8 := word offset on line

        LDR     R0, [WsPtr, #GWRCol]
        BitROffset R1,R0, R9,R10,R11
        WordOffset R2,R0, R9,R10,R11
        Push    "R1,R2"

        LDR     R0, [WsPtr, #GWLCol]
        BitLOffset R1,R0, R9,R10,R11
        WordOffset R2,R0, R9,R10,R11

        Push    "R1,R2,R8"

        ADD     R11, R14, #spWidth
        LDMIA   R11, {R0,R1,R6,R8}      ; Width-1, Height-1, LBit, RBit

        MOV     R3, #0                  ; offset to next row in sprite

        SUBS    R6, R6, R7              ; no. of bits to shift sprite
                                        ; before plotting
                                        ; use R7 as LBit
        SUBS    R8, R8, R6              ; calculate new RBit
        ADDLT   R8, R8, #32
        ADDLT   R3, R3, #4

        CMP     R8, #32
        SUBGE   R8, R8, #32
        SUBGE   R3, R3, #4

; R9  Offset on line to plot point, R7 LBit
; R11 Offset on line to GWLCol      R10 bit position

        Pull    "R10,R11"
        Pull    R9

        SUBS    R9, R11, R9
        SUBLT   R11, R11, R9

        ADDGT   R4, R4, R9, LSL #2
        ADDGT   R5, R5, R9, LSL #2
        ADDGT   R3, R3, R9, LSL #2

        CMPEQ   R10, R7
        MOVGT   R7, R10

; R10 Offset to GWRCol, R9 bit position
; R11 Offset to RHedge of sprite, R8 RBit

        ADD     R11, R11, R0
        SUB     R11, R11, R3, ASR #2

        Pull    "R9,R10"

        SUBS    R10, R11, R10
        ADDGT   R3, R3, R10, LSL #2

        CMPEQ   R8, R9
        MOVGT   R8, R9

        Pull    R10

        SUBS    R1, R1, R10             ; correct height
        BLT     %FT20

        SUBS    R0, R0, R3, ASR #2      ; corrected width
        BLT     %FT20

        LDR     R2,[WsPtr,#LineLength]
        SUB     R2, R2, #4
        SUB     R2, R2, R0, LSL #2      ; offset to next screen line

        MOV     R9, #&FFFFFFFE          ; RHand partial word mask
        MVN     R9, R9, LSL R8
        MOV     R8, #&FFFFFFFF
        MOV     R8, R8, LSL R7          ; LHand partial word mask

        ANDEQ   R8, R8, R9              ; if width=0, combine LH & RH masks
        MOVEQ   R9, R8

        CMP     R6, #0
        ADDLT   R6, R6, #32             ; correct if neg
        SUBLT   R5, R5, #4
        RSB     R7, R6, #32             ; its complement

        ADD     R11, WsPtr, #SPltWidth
        STMIA   R11, {R0,R1,R2,R3,R4}   ; SPltWidth..SPltScrAdr

        ADD     R11, WsPtr, #SPltColCnt
        STMIA   R11, {R0,R5,R6,R7}      ; SPltColCnt..SPltShftL

        ADD     R11, WsPtr, #SPltMskAdr
        STMIB   R11, {R8,R9}            ; SPltLMask,SPltRMask

        CLRV
        Pull    PC

20
        SETV
        Pull    PC

        LTORG

        END
@


4.4
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a135 8
        [ :LNOT: AssemblingArthur
        LDR     R0, =SvcTable                   ; intercept SWI SpriteOp
        ADR     R1, SwiSpriteOp
        STR     R1, [R0, #(OS_SpriteOp*4)]

        ADRL    R1, SwiReadPoint                ; might as well catch ReadPoint
        STR     R1, [R0, #(OS_ReadPoint*4)]     ; here
        ]
a507 2

       [ AssemblingArthur :LOR: Module
a508 4
       |
        SpriteOpEntry ClaimSpace, Group1        ; *SSpace <size>
       ]

a610 1
 [ ModeSelectors
a616 1
 ]
@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a347 1
 [ No26bitCode
a348 3
 |
        ADR     R14, SpriteDispatchReturn + SVC_mode ; return address
 ]
a665 1
 [ No26bitCode
a667 4
 |
        Pull    "R5, R14"
        BICS    PC, R14, #V_bit
 ]
a1789 1
 [ No26bitCode
a1791 3
 |
        Push    "R2,R4,R5,R6,R7,R14"
 ]
a1832 1
 [ No26bitCode
a1834 3
 |
        LDMFD   R13!,{R2,R4,R5,R6,R7,R15}^ ; must save flags
 ]
a2689 1
 [ No26bitCode
a2691 4
 |
        Pull    R14
        BICS    PC, R14, #V_bit         ; VC some/all of sprite in window
 ]
a2693 1
 [ No26bitCode
a2695 4
 |
        Pull    R14
        ORRS    PC, R14, #V_bit         ; VS sprite completely outside window
 ]
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a146 37
 [ :LNOT: NewStyle_SpriteArea
        [ AssemblingArthur
        MOV     R0, #0
        LDRB    R0, [R0, #OsbyteVars + :INDEX: LastBREAK]
        CMP     R0, #0          ; Soft=0,POR=1,Hard=2
        BNE     %FT10           ; If CtrlBreak or PowerOnReset setup default
        Pull    PC, EQ          ; sprite area

;        LDR     R1, [WsPtr, #SpAreaStart]
;        CMP     R1, #0
;        BEQ     %FT20
;        BL      ValidateSpriteArea
;        BVC     %FT20
        ]
10
        [ AssemblingArthur :LOR: Module
        MOV     R2, #0
        LDR     R2, [R2, #SpriteSize]   ; Tony sez this is (0..n)*(8or32)Kbytes
        CMP     R2, #0
        STREQ   R2, [WsPtr, #SpAreaStart]       ; EQ means no workspace
        Pull    PC, EQ

        LDR     R1, =SpriteSpaceAddress
        STR     R1, [WsPtr, #SpAreaStart]
;       SUB     R2, R2, #16             ; Lose 4 words in case we overshoot

        MOV     R3, #0                  ; no sprites
        MOV     R4, #SpriteAreaCBsize   ; saFirst
        MOV     R5, #SpriteAreaCBsize   ; saFree

        STMIA   R1, {R2,R3,R4,R5}       ; saEnd,saNumber,saFirst,saFree
        |
        MOV     R1, #0
        STR     R1, [WsPtr, #SpAreaStart]       ; no sprite workspace
        ]
20
 ]
d344 1
a344 1
        CMP     R0, #SpriteReason_BadReasonCode
d442 1
d445 1
a445 1
        MOVS   R9,R9,LSR #27            ; put the sprite type at b0
a446 1
39
d448 9
a456 2
        CMP    R9,#SpriteType_New16bpp  ; check sprite type number
        BCC    %FT37                    ; despatch if new format and under 8bpp
d458 1
a459 3
        Push   "R14"                    ; I need another register for CMP

        ; now check for a palette
a464 1
        Pull   "R14"
d467 1
d476 1
a476 1
        Push    "R0-R3,R14"             ; save context
d481 1
a481 1
        Pull    "R0-R3,R14"
d486 1
d519 1
a519 1
        SpriteOpEntry DoesNowt, Group1
d522 1
a522 1
        SpriteOpEntry DoesNowt, Group1
d529 4
a532 4
        SpriteOpEntry DoesNowt, Group1
        SpriteOpEntry DoesNowt, Group1
        SpriteOpEntry DoesNowt, Group1
        SpriteOpEntry DoesNowt, Group1
d547 7
a553 7
        SpriteOpEntry DoesNowt, Group2
        SpriteOpEntry DoesNowt, Group2
        SpriteOpEntry DoesNowt, Group2
        SpriteOpEntry DoesNowt, Group2
        SpriteOpEntry DoesNowt, Group2
        SpriteOpEntry DoesNowt, Group2
        SpriteOpEntry DoesNowt, Group2
d568 5
a572 5
        SpriteOpEntry DoesNowt, Group3
        SpriteOpEntry DoesNowt, Group3
        SpriteOpEntry DoesNowt, Group3
        SpriteOpEntry DoesNowt, Group3
        SpriteOpEntry DoesNowt, Group3
d586 4
a589 4
        SpriteOpEntry DoesNowt, Group4  ; 50            ; PlotMaskScaled
        SpriteOpEntry DoesNowt, Group4  ; 51            ; PaintCharScaled
        SpriteOpEntry DoesNowt, Group4  ; 52            ; PutSpriteScaled
        SpriteOpEntry DoesNowt, Group4  ; 53            ; PutSpriteGreyScaled
d591 5
a595 5
        SpriteOpEntry DoesNowt, Group4                  ; 55 PlotMaskTransformed
        SpriteOpEntry DoesNowt, Group4                  ; 56 PutSpriteTransformed
        SpriteOpEntry DoesNowt, Group4                  ; 57 InsertDeleteRows
        SpriteOpEntry DoesNowt, Group4                  ; 58 InsertDeleteColumns
        SpriteOpEntry DoesNowt, Group4                  ; 59 pseudo reason used by Wimp
d603 3
d650 1
a650 1
        TST     R11, #Flag_NonGraphic
d652 1
a653 6
        LDR     R6, [R13, #wkNColour]                   ; ReadNColour
        ;changed by amg 12/11/93 to stop it mistaking 16/32bpp for 8
;        TST     R6, #&F0                                ; 256 colour mode ?
;        MOVNE   R6, #&FF                                ; then use &FF
        CMP     R6,#63
        MOVEQ   R6,#255
d655 1
d658 1
a658 1
11
d662 1
d664 1
d669 1
a669 1
        STMIA   R5, {R6-R11}            ; SprRead..SprLog2BPC
d703 1
a703 1
SpriteErr_Bad2ndPtr                        MakeErrorBlock Sprite_Bad2ndPtr
d1084 4
a1087 2
        Push    "R3-R11, R14"
        LDMIA   R1, {R3,R4,R5}          ; saEnd, saNumber, saFirst
d1107 17
a1123 1
        Pull    "R3-R11, PC"
d1241 9
a1249 1
        MOV     R14,R14,LSR #27
d1254 1
a1254 1
        CMP     R14, #2
d1269 1
a1269 1
        TEQ     R2, #0
d1287 1
a1287 1
        AND     R2, R2, R4              ; mask down to just the required pixels
d1289 10
a1298 3
        LDR     R3, [R0]                ; plot 1 word
        BIC     R3, R3, R4              ; knock out mask bits
        ORR     R3, R3, R2              ; and or sprite bits
d1307 14
d1355 1
a1355 6
        LDREQ   R4, [WsPtr, #SPltRMask-SPltScrAdr] ; if rightmost word,
        ANDEQ   R2, R2, R4              ; mask down to just the required pixels

        LDREQ   R3, [R0]
        BICEQ   R3, R3, R4
        ORREQ   R2, R2, R3
d1359 17
a1375 1
        BGE     SolPlFast40
d1391 8
d1401 1
d1413 1
a1413 1
SolPl10
d1514 1
a1514 1
;       Called with R11 -> sprite
a1520 2
        LDR     R10, [R11, #spMode]
        MOV     R10, R10, LSR #27
d1522 1
a1522 1
        LDR     R10, [R0, R10, LSL #2]   ; get the log2bpp to R10
d1801 1
a1801 1
        mrs    ,R8, CPSR
d1847 1
a1847 1
        msr    ,CPSR_f, R8
d2008 4
d2015 7
a2021 2
        LDR     R10, [R2, #spMode]
        MOV     R10, R10, LSR #27
d2349 2
a2350 1
        MOVS    R0, R0, LSR #27
d2724 1
@


4.2.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@a1136 2
        LTORG

d1766 1
a1766 1
        MRS     R8, CPSR
d1812 1
a1812 1
        MSR     CPSR_f, R8
a2678 1
        LTORG
@


4.2.2.2
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d147 37
@


4.2.2.3
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d1256 1
a1256 1
        AND     R3, R2, R4              ; mask down to just the required pixels
d1258 3
a1260 10
 [ AvoidScreenReads
        CMP     R4, #&FFFFFFFF
        LDRNE   R2, [R0]                ; plot 1 word
        BICNE   R2, R2, R4              ; knock out mask bits
        ORRNE   R3, R2, R3              ; and or sprite bits
 |
        LDR     R2, [R0]                ; plot 1 word
        BIC     R2, R2, R4              ; knock out mask bits
        ORR     R3, R2, R3              ; and or sprite bits
 ]
a1268 14
        TEQ     R6, #0                  ; if shift needed, use loop 20
        BNE     SolPlFast20             ; else loop 15

SolPlFast15

;       R0    ,R1         ,R5
;       ScrAdr,ColCnt,    ,MemAdr

        LDMIA   R5!, {R2-R4,R8-R11}     ; read 7 words
        STMIA   R0!, {R2-R4,R8-R11}     ; write 7 words back to screen
        SUBS    R1, R1, #7
        BGE     SolPlFast15
        B       SolPlFast30

d1303 6
a1308 1
        BEQ     SolPlFast45             ; if rightmost word, jump out.
d1312 1
a1312 17
        B       SolPlFast40

SolPlFast45
        LDR     R4, [WsPtr, #SPltRMask-SPltScrAdr]
        AND     R3, R2, R4              ; mask down to just the required pixels

 [ AvoidScreenReads
        CMP     R4, #&FFFFFFFF
        LDRNE   R2, [R0]                ; plot 1 word
        BICNE   R2, R2, R4              ; knock out mask bits
        ORRNE   R3, R2, R3              ; and or sprite bits
 |
        LDR     R2, [R0]                ; plot 1 word
        BIC     R2, R2, R4              ; knock out mask bits
        ORR     R3, R2, R3              ; and or sprite bits
 ]
        STR     R3, [R0], #4
@


4.2.2.4
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@a441 1
        Push   "R14"
d444 1
a444 1
        ANDS   R14,R9,#15<<27           ; get the sprite type
d446 1
d448 2
a449 9
        CMP    R14,#SpriteType_RISCOS5<<27 ; if it's a RISC OS 5 sprite mode word
        MOVEQ  R14,R9,LSR #20            ; then get the actual sprite type
        MOVNE  R14,R14,LSR #27
        ANDEQS R14,R14,#127
        MOVEQ  R14,#SpriteType_Substitute ; Panic and treat as 32bpp?

        CMP    R14,#SpriteType_New16bpp ; check sprite type number
        BCC    %FT38                    ; despatch if new format and under 16bpp
        
a450 1
39
d452 3
d460 1
a462 1
        Pull   "R14"
d471 1
a471 1
        Push    "R0-R3"                 ; save context
d476 1
a476 1
        Pull    "R0-R3"
a480 1
        Pull    "R14"
d641 1
a641 1
        TST     R11, #ModeFlag_NonGraphic
a642 1
        STR     R11, [WsPtr, #SprModeFlags]
a650 1
        LDR     R14, [R13, #wkLog2BPP]                  ; Log2BPP
d662 1
a662 1
        STMIA   R5, {R6-R11,R14}        ; SprRead..SprLog2BPP
a1217 1
        TST     R14,#&80000000          ; check for wide mask
a1218 1
        BNE     PutSpriWideMaskErr
a1359 6
PutSpriWideMaskErr
        ; Not supported!
        SWI     XOS_RestoreCursors
        ADRL    R0, SpriteErr_InvalidSpriteMode
        B       %FT90

a1361 1
90
d1373 1
a1373 1
SolPl10 ROUT
a2301 2
        TST     R0, #&80000000
        BNE     PutSpriWideMaskErr
@


4.2.2.5
log
@Fix plotting of RISC OS 5 type sprites and masks. Fix hang when attempting to report "alpha mask not supported" error. Fix reading/writing of alpha mask pixels.
Detail:
  s/vdu/vdugrafg - Fixed PutSprite and PlotMask to correctly deal with RISC OS 5 type sprite mode words. Fix infinite loops in PutSpriWideMaskErr casued by R14 getting trashed.
  s/vdu/vdugrafh - Fixed SpriteMaskAddr malfunctioning when trying to calculate addresses in alpha masks. Minor ReadPixelMask & WritePixelMask optimisations.
  s/vdu/vduswis - Fixed OS_ScreenMode 13 & 14 to count "G2" as a valid colour specifier.
Admin:
  Tested on BB-xM
  Should hopefully fix the random hangs reported on the forums when trying to use sprites with alpha masks


Version 5.35, 4.79.2.197. Tagged as 'Kernel-5_35-4_79_2_197'
@
text
@d1226 3
a1228 9
        MOVS    R8,R14,ASR #27          ; check for wide mask
        BMI     PutSpriWideMaskErr
        TEQ     R8,#SpriteType_RISCOS5
      [ NoARMT2
        ANDEQ   R8, R14, #127<<20
        MOVEQ   R8, R8, LSR #20
      |
        UBFXEQ  R8, R14, #20, #7
      ]
d1233 1
a1233 1
        CMP     R8, #2
a1372 2
        Pull    "WsPtr, R14"
PutSpriWideMaskErr2
d1491 1
a1491 1
;       Called with R11 -> sprite, R8 = sprite type
d1498 2
d1501 1
a1501 1
        LDR     R10, [R0, R8, LSL #2]   ; get the log2bpp to R10
a1986 4
;
; R0 = sprite mode word
; R2 -> sprite
; R10 = bits 27-31 of mode word
d1990 2
a1991 7
        TEQ     R10, #SpriteType_RISCOS5
      [ NoARMT2
        ANDEQ   R10, R0, #127<<20
        MOVEQ   R10, R10, LSR #20
      |
        UBFXEQ  R10, R0, #20, #7
      ]
d2319 3
a2321 2
        MOVS    R10, R0, ASR #27
        BMI     PutSpriWideMaskErr2
@


4.2.2.6
log
@ModeFlag_GreyscalePalette handling improvements. Issue service calls on certain GraphicsV events. Sprite tweaks and fixes.
Detail:
  hdr/VduExt - Add reason codes used by Service_DisplayChanged & Service_DisplayStatus
  s/vdu/vdugrafg - Remove dependency on SpriteReason_BadReasonCode; just use the size of our lookup table instead. Alter SpriteOp lookup table so that unimplemented ops return an error instead of doing nothing. Fix PutSprite incorrectly using the slow GCOL action plotter if a request was made to plot a sprite using its mask but the sprite has none.
  s/vdu/vdugrafl - Update screen redirection handling to set ModeFlag_GreyscalePalette if switching output to a sprite with a greyscale palette or a RISC OS Select alpha mask. Restore the flag to its correct value when restoring screen output.
  s/vdu/vdupalxx - Update ModeFlag_GreyscalePalette in realtime as the palette is changed
  s/vdu/vduswis - Issue Service_DisplayChanged during OS_ScreenMode 11. Issue Service_DisplayStatus during OS_ScreenMode 65 & 66.
Admin:
  Tested on Iyonix, BB-xM


Version 5.35, 4.79.2.210. Tagged as 'Kernel-5_35-4_79_2_210'
@
text
@d344 1
a344 1
        CMP     R0, #(SwiSpriteOpCallTb_End-SwiSpriteOpCallTb)/4
d519 1
a519 1
        SpriteOpEntry BadReasonCode, Group1
d522 1
a522 1
        SpriteOpEntry BadReasonCode, Group1
d529 4
a532 4
        SpriteOpEntry BadReasonCode, Group1 ; 4
        SpriteOpEntry BadReasonCode, Group1 ; 5
        SpriteOpEntry BadReasonCode, Group1 ; 6
        SpriteOpEntry BadReasonCode, Group1 ; 7
d547 7
a553 7
        SpriteOpEntry BadReasonCode, Group2 ; 17 CheckSpriteArea
        SpriteOpEntry BadReasonCode, Group2 ; 18
        SpriteOpEntry BadReasonCode, Group2 ; 19
        SpriteOpEntry BadReasonCode, Group2 ; 20
        SpriteOpEntry BadReasonCode, Group2 ; 21
        SpriteOpEntry BadReasonCode, Group2 ; 22
        SpriteOpEntry BadReasonCode, Group2 ; 23
d568 5
a572 5
        SpriteOpEntry BadReasonCode, Group3 ; 35 AppendSprite
        SpriteOpEntry BadReasonCode, Group3 ; 36 SetPointerShape
        SpriteOpEntry BadReasonCode, Group3 ; 37 CreateRemovePalette
        SpriteOpEntry BadReasonCode, Group3 ; 38 CreateRemoveAlpha
        SpriteOpEntry BadReasonCode, Group3 ; 39
d586 4
a589 4
        SpriteOpEntry BadReasonCode, Group4 ; 50 PlotMaskScaled
        SpriteOpEntry BadReasonCode, Group4 ; 51 PaintCharScaled
        SpriteOpEntry BadReasonCode, Group4 ; 52 PutSpriteScaled
        SpriteOpEntry BadReasonCode, Group4 ; 53 PutSpriteGreyScaled
d591 5
a595 5
        SpriteOpEntry BadReasonCode, Group4 ; 55 PlotMaskTransformed
        SpriteOpEntry BadReasonCode, Group4 ; 56 PutSpriteTransformed
        SpriteOpEntry BadReasonCode, Group4 ; 57 InsertDeleteRows
        SpriteOpEntry BadReasonCode, Group4 ; 58 InsertDeleteColumns
        SpriteOpEntry BadReasonCode, Group4 ; 59 pseudo reason used by Wimp
a602 3
SwiSpriteOpCallTb_End


d704 1
a704 1
SpriteErr_Bad2ndPtr                         MakeErrorBlock Sprite_Bad2ndPtr
d1254 1
a1254 1
        TST     R2, #7
@


4.2.2.7
log
@Fix OS_SpriteOp 41 (read pixel) for 4K colour sprites. Update ECF patterns to work sensibly in true colour modes.
Detail:
  s/vdu/vdugrafg - Change SetupSprModeData to calculate SprReadNColour from log2bpp instead of the NColour mode variable - fixes the alpha component being lost when using OS_SpriteOp 41 to read from 4K colour sprites with alpha channels
  s/vdu/vdudriver - Change SetCol30 to generate more sensible ECF colour blocks when in true colour modes. Previously it would treat each byte of the 8 byte ECF pattern as a separate row, and replicate the byte 4 times to produce one colour word per row. However this isn't so great for true colour modes, especially if you have an alpha channel which needs specific values. So to fix the issue, take inspiration from how Paint assumed the ECF patterns worked, and treat 16bpp modes as being a 1x4 pattern and 32bpp modes as being a 1x2 pattern
Admin:
  Tested on BB-xM
  OS_SpriteOp 41 fix fixes Paint colour picker always returning 0 alpha when picking from 4K ARGB sprites
  ECF change fixes Paint's masked sprite background ECF pattern to display properly in true colour modes


Version 5.35, 4.79.2.213. Tagged as 'Kernel-5_35-4_79_2_213'
@
text
@d654 6
d664 1
a664 1

a667 1
        MOV     R6, R7, LSL R14
a668 1
        RSB     R6, R7, R7, LSL R6      ; ReadNColour
@


4.2.2.8
log
@[308] SpriteOp 11 (merge sprite areas) gets slow for large numbers of sprites
Detail:
  s/vdu/vdugrafh - Rewrite MergeSpriteAreas so that memory movement is now O(N) instead of O(N^2). Checking for duplicate sprites is still slow (O(N^2) search), but this resolves the main performance bottleneck with the code.
  s/vdu/vdugrafg - Add a variant of SpriteCtrlBlk which skips the call to GetName; this helps MergeSpriteAreas for the common case of a dest area with lots of sprites and a source area with a handful of sprites (SpriteCtrlBlk is now called on the source area once per dest sprite, previously was called on the dest area once per source sprite).
Admin:
  Tested on Raspberry Pi 1, merging Sovereign theme Sprites11 file with itself (2.2MB file, 358 sprites)
  Old code took 860cs, new code takes 18cs (15cs of which appears to be loading the second copy of the file, judging by *SLoad timings)


Version 5.35, 4.79.2.321. Tagged as 'Kernel-5_35-4_79_2_321'
@
text
@d1084 2
a1085 4
        Entry   "R3-R11"
        ASSERT  saNumber = 4
        ASSERT  saFirst = 8
        LDMIB   R1, {R4,R5}             ; saNumber, saFirst
d1105 1
a1105 15
        EXIT

; As above, but uses source name directly without passing it through GetName
; Name must be word aligned and in correct format!

SpriteCtrlBlkNoGetName
        ALTENTRY
        ASSERT  saNumber = 4
        ASSERT  saFirst = 8
        LDMIB   R1, {R4,R5}             ; saNumber, saFirst
        ADD     R3, R5, R1              ; point to first sprite/free space
        CMP     R4, #0
        BEQ     %BT20                   ; no sprites, exit with R3 pointing
        LDMIA   R2, {R9-R11}
        B       %BT10        
@


4.1
log
@Initial revision
@
text
@a350 1
 [ Fix5
a356 4
 ]
        [ :LNOT: AssemblingArthur :LAND: :LNOT: Module
        SWIVS   XOS_GenerateError
        ]
d361 1
a361 1
        TEQP    PC, #SVC_mode           ; Re-enable interupts
a365 1
 [ Fix5
a371 1
 ]
d385 3
d389 1
d414 2
a415 2
        BNE     %FT33                                           
                                         
d457 1
a457 1
 
d460 1
a460 1
;medusa note.                                            
d470 1
a470 1
;                      
d473 1
a473 1
;really do get faulted         
d476 1
a476 1
;and below                    
d497 1
a497 1
        Pull   "R14"                     
d504 1
a504 1
        ] 
d514 1
a514 1
        CMP     R9,#4  
d656 1
a656 1
        LDR     R11, [R2, #spMode] 
d689 1
a689 1
        ADD     R13, R13, #PushedInfoSize                               
d700 4
d706 1
d761 1
a761 1
        BICCSS  PC, R14, #V_bit         ; then return immediately
d774 1
a774 1
        BICS    PC, R14, #V_bit
d794 1
a794 1
        BICS    PC, R14, #V_bit
d842 1
d844 1
a844 1
        ADRLTL  R0, SpriteErr_DoesntExist ; out of range, so generate error
d846 3
a848 3
        Push    "lr",LT
        BLLT    TranslateError_VClear
        Pull    "lr",LT
d850 2
a851 2
        STRLT   R0, [WsPtr, #RetnReg0]
        ORRLTS  PC, R14, #V_bit
d853 1
a853 1
        LDR     R5, [R1, #saFirst]
d867 1
a867 1
        BICLSS  PC, R14, #V_bit         ; if was 0 or 1 then exit
d886 1
a886 1
        BICS    PC, R14, #V_bit         ; indicate no error
d908 1
a908 1
        BICS    PC, R14, #V_bit
d913 1
a913 1
        BICEQS  PC, R14, #V_bit         ; (SRename/SCopy fred fred is allowed)
d922 1
a922 1
        ORRS    PC, R14, #V_bit
d973 1
a973 1
        ADD     R3, R3, R6 
d985 1
a985 1
        BICS    PC, R14, #V_bit
a1228 1
   [ {TRUE}
d1230 2
a1231 20
        ADRNEL  R0, SpriteErr_NotGraphics
      [ International
        Push    "lr",NE
        BLNE    TranslateError
        Pull    "lr",NE
      ]
        STRNE   R0, [WsPtr, #RetnReg0]
        ORRNES  PC, R14, #V_bit         ; quit with error if not graphics mode
   |
        LDR     R0, [WsPtr, #NPix]
        TEQ     R0, #0
        ADREQL  R0, SpriteErr_NotGraphics
      [ International
        Push    "lr",EQ
        BLEQ    TranslateError
        Pull    "lr",EQ
      ]
        STREQ   R0, [WsPtr, #RetnReg0]
        ORREQS  PC, R14, #V_bit         ; quit with error if not graphics mode
    ]
d1251 1
a1251 1
                        
d1254 1
a1254 1
                                                                            
d1263 1
a1263 1
; Plot sprite ignoring transparency mask (if any)     
d1306 1
a1306 1
;       R0    ,R1         ,R5    ,R6   ,R7   
d1327 1
a1327 1
;       R0    ,R1    ,     R5    ,R6   ,R7   
d1361 12
a1372 1
        BICS    PC, R14, #V_bit
d1477 1
a1477 1
;       Called with R11 -> sprite 
d1483 1
a1483 1
        
d1485 1
a1485 1
        MOV     R10, R10, LSR #27  
d1488 1
a1488 1
        
d1490 1
a1490 1
        
d1492 1
a1492 1
        
d1500 1
a1500 1
        
d1503 1
a1503 1
        
d1507 1
a1507 1
        MOVNE   R9, #4    
d1519 1
a1519 1
        
d1533 1
a1533 1
        
d1535 1
a1535 1
        MOV     R3, #0                  ; R3 = mask bit 
d1537 1
a1537 1
        
d1540 2
a1541 2
        
        ;R3, R9, r10, R11 free  
d1543 1
a1543 1
        
d1548 1
a1548 1
        
d1550 1
a1550 1
        
d1556 2
a1557 2
        ;is it less than a row of data             
        CMP     R10, R8      
d1583 1
a1583 1
        
d1591 1
a1591 1
        
d1595 1
a1595 1
                       
d1598 1
a1598 1
        
d1602 1
a1602 1
;       ScrAdr,ColCnt,     MemAdr,ShftR,ShftL,zgoo,zgeo,zgoe,zgee,   
d1606 1
a1606 1
                                           
d1611 1
a1611 1
        
d1644 1
a1644 1
  
d1650 1
a1650 1
        
d1683 2
a1684 2
NTrnPl40   
        
d1686 1
a1686 1
        MOV     R2, R3     
d1712 1
a1712 1
NTrnPl50  
d1714 1
a1714 1
        
d1723 1
a1723 1
                                        
d1725 1
a1725 1
        
d1732 1
a1732 1
        
d1735 1
a1735 1
                                        
d1746 1
a1746 1
        BICS    PC, R14, #V_bit
d1749 1
a1749 1
                    
d1751 3
a1753 3
        Push    "R4, R5, LR" 
        
        LDR     R4, [WsPtr, #SPltMaskBit-SPltScrAdr]    
d1755 2
a1756 2
        BL      getmaskword
        STR     R4, [WsPtr, #SPltMaskBit-SPltScrAdr]    
d1758 3
a1760 3
        
        LDMFD   R13!,{R4,R5,R15}^
                                                   
d1764 4
d1769 1
d1779 2
a1780 2
        
        LDR     R7, [WsPtr, #SPltMaskBit-SPltScrAdr]    
d1782 1
a1782 1
        
d1784 1
a1784 1
10                 
d1794 1
a1794 1
        MOV     R3, R3, ASR R5           
d1797 1
a1797 1
        
d1804 1
a1804 1
        BNE     %BT10      
d1806 1
a1806 1
        STR     R7, [WsPtr, #SPltMaskBit-SPltScrAdr]    
d1811 4
d1816 1
d1945 1
a1945 1
        BICS    PC, R14, #V_bit
d1974 1
a1974 1
PlotNewMask ROUT               
d1980 2
a1981 2
             
        ;derive mask row length 
d1984 2
a1985 2
        LDR     R8, [R2, #spWidth]       ; words-1    
        
d1994 1
a1994 1
        
d1997 1
a1997 1
        
d2001 1
a2001 1
        MOVNE   R9, #4    
d2006 1
a2006 1
        
d2009 1
a2009 1
        
d2011 1
a2011 1
        
d2014 1
a2014 1
        
d2028 1
a2028 1
                            
d2030 1
a2030 1
 
d2038 1
a2038 1
        
d2040 1
a2040 1
        
d2042 1
a2042 1
        
d2047 1
a2047 1
 
d2051 2
a2052 2
        ADD     R9, R9, R2                    ;change to address of mask  
        
d2057 1
a2057 1
        
d2060 1
a2060 1
                          
d2070 1
a2070 1
        
d2074 1
a2074 1
        
d2079 2
a2080 2
        
14      
d2084 1
a2084 1
        
d2089 1
a2089 1
        
d2092 1
a2092 1
        
d2095 1
a2095 1
        
d2097 1
a2097 1
        
d2100 1
a2100 1
                                              
d2104 1
a2104 1
        
d2107 2
a2108 2
        
13      ;remember R6 ? uncompensate now  
d2111 1
a2111 1
        
d2115 1
a2115 1
        
d2119 1
a2119 1
        
d2126 1
a2126 1
        
d2130 1
a2130 1
        
d2143 1
a2143 1
        
d2215 1
a2215 1
        
d2217 1
a2217 1
        MOV     R2, R3     
d2245 1
a2245 1
                                        
d2247 1
a2247 1
        
d2254 1
a2254 1
 
d2276 1
a2276 1
        BICS    PC, R14, #V_bit
d2294 2
a2295 22
    [ {TRUE}
        GraphicsMode R0            
        ADRNEL  R0, SpriteErr_NotGraphics
      [ International
        Push    "lr",NE
        BLNE    TranslateError
        Pull    "lr",NE
      ]
        STRNE   R0, [WsPtr, #RetnReg0]
        ORRNES  PC, Link, #V_bit        ; quit with error if not graphics mode
    |
        LDR     R0, [WsPtr, #NPix]
        TEQ     R0, #0
        ADREQL  R0, SpriteErr_NotGraphics
      [ International
        Push    "lr",EQ
        BLEQ    TranslateError
        Pull    "lr",EQ
      ]
        STREQ   R0, [WsPtr, #RetnReg0]
        ORREQS  PC, Link, #V_bit        ; quit with error if not graphics mode
    ]     
d2303 1
a2303 1
                                
d2450 1
a2450 1
        BICS    PC, R14, #V_bit
d2662 4
d2668 1
d2671 4
d2677 1
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d136 8
d147 37
d324 1
d326 1
d330 1
d332 1
d337 1
d339 1
d351 1
d358 4
d371 1
d378 1
d403 1
d405 1
d505 1
d507 1
d555 1
d557 3
d660 1
d667 1
d710 1
d712 1
d842 1
d846 1
d913 1
d917 1
d1226 1
d1229 1
d1233 1
d1236 12
d2289 1
d2292 1
d2296 1
d2299 12
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

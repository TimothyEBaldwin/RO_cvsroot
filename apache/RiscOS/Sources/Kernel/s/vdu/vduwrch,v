head	4.9;
access;
symbols
	Kernel-6_15:4.9
	Kernel-6_14:4.9
	Kernel-6_01-3:4.9
	Kernel-6_13:4.9
	Kernel-6_12:4.9
	Kernel-6_11:4.9
	Kernel-6_10:4.9
	Kernel-6_09:4.9
	Kernel-6_08-4_129_2_10:4.9
	Kernel-6_08-4_129_2_9:4.9
	Kernel-6_08:4.9
	Kernel-6_07:4.9
	Kernel-6_06:4.9
	Kernel-6_05-4_129_2_8:4.9
	Kernel-6_05:4.9
	Kernel-6_04:4.9
	Kernel-6_03:4.9
	Kernel-6_01-2:4.9
	Kernel-6_01-4_146_2_1:4.9
	Kernel-6_02:4.9
	Kernel-6_01-1:4.9
	Kernel-6_01:4.9
	Kernel-6_00:4.9
	Kernel-5_99:4.9
	Kernel-5_98:4.9
	Kernel-5_97-4_129_2_7:4.9
	Kernel-5_97:4.9
	Kernel-5_96:4.9
	Kernel-5_95:4.9
	Kernel-5_94:4.9
	Kernel-5_93:4.9
	Kernel-5_92:4.9
	Kernel-5_91:4.9
	Kernel-5_90:4.9
	Kernel-5_89-4_129_2_6:4.9
	Kernel-5_89:4.9
	Kernel-5_88-4_129_2_5:4.9
	Kernel-5_88-4_129_2_4:4.9
	Kernel-5_88:4.9
	Kernel-5_87:4.9
	Kernel-5_86-4_129_2_3:4.9
	Kernel-5_86-4_129_2_2:4.9
	Kernel-5_86-4_129_2_1:4.9
	Kernel-5_86:4.9
	SMP:4.9.0.2
	SMP_bp:4.9
	Kernel-5_85:4.9
	Kernel-5_54-1:4.7
	Kernel-5_84:4.9
	Kernel-5_83:4.9
	Kernel-5_82:4.9
	Kernel-5_81:4.8
	Kernel-5_80:4.8
	Kernel-5_79:4.8
	Kernel-5_78:4.8
	Kernel-5_77:4.8
	Kernel-5_76:4.8
	Kernel-5_75:4.8
	Kernel-5_74:4.8
	Kernel-5_73:4.7
	Kernel-5_72:4.7
	Kernel-5_71:4.7
	Kernel-5_70:4.7
	Kernel-5_69:4.7
	Kernel-5_68:4.7
	Kernel-5_67:4.7
	Kernel-5_66:4.7
	Kernel-5_65:4.7
	Kernel-5_64:4.7
	Kernel-5_63:4.7
	Kernel-5_62:4.7
	Kernel-5_61:4.7
	Kernel-5_60:4.7
	Kernel-5_59:4.7
	Kernel-5_58:4.7
	Kernel-5_57:4.7
	Kernel-5_56:4.7
	Kernel-5_55:4.7
	Kernel-5_54:4.7
	Kernel-5_53:4.7
	Kernel-5_52:4.7
	Kernel-5_51:4.7
	Kernel-5_50:4.6
	Kernel-5_49:4.6
	HAL_merge:4.5.2.18
	Kernel-5_48:4.6
	Kernel-5_35-4_79_2_327:4.5.2.18
	Kernel-5_35-4_79_2_326:4.5.2.18
	Kernel-5_35-4_79_2_325:4.5.2.18
	Kernel-5_35-4_79_2_324:4.5.2.18
	Kernel-5_35-4_79_2_323:4.5.2.18
	Kernel-5_35-4_79_2_322:4.5.2.18
	Kernel-5_35-4_79_2_321:4.5.2.18
	Kernel-5_35-4_79_2_320:4.5.2.18
	Kernel-5_35-4_79_2_319:4.5.2.18
	Kernel-5_35-4_79_2_318:4.5.2.18
	Kernel-5_35-4_79_2_317:4.5.2.18
	Kernel-5_35-4_79_2_316:4.5.2.18
	Kernel-5_35-4_79_2_315:4.5.2.18
	Kernel-5_35-4_79_2_314:4.5.2.18
	Kernel-5_35-4_79_2_313:4.5.2.18
	Kernel-5_35-4_79_2_312:4.5.2.18
	Kernel-5_35-4_79_2_311:4.5.2.18
	Kernel-5_35-4_79_2_310:4.5.2.18
	Kernel-5_35-4_79_2_309:4.5.2.18
	Kernel-5_35-4_79_2_308:4.5.2.18
	Kernel-5_35-4_79_2_307:4.5.2.18
	Kernel-5_35-4_79_2_306:4.5.2.18
	Kernel-5_35-4_79_2_305:4.5.2.18
	Kernel-5_35-4_79_2_304:4.5.2.18
	Kernel-5_35-4_79_2_303:4.5.2.18
	Kernel-5_35-4_79_2_302:4.5.2.18
	Kernel-5_35-4_79_2_301:4.5.2.18
	Kernel-5_35-4_79_2_300:4.5.2.18
	Kernel-5_35-4_79_2_299:4.5.2.18
	Kernel-5_35-4_79_2_298:4.5.2.18
	Kernel-5_35-4_79_2_297:4.5.2.18
	Kernel-5_35-4_79_2_296:4.5.2.18
	Kernel-5_35-4_79_2_295:4.5.2.18
	Kernel-5_35-4_79_2_294:4.5.2.18
	Kernel-5_35-4_79_2_293:4.5.2.18
	Kernel-5_35-4_79_2_292:4.5.2.18
	Kernel-5_35-4_79_2_291:4.5.2.18
	Kernel-5_35-4_79_2_290:4.5.2.18
	Kernel-5_35-4_79_2_289:4.5.2.18
	Kernel-5_35-4_79_2_288:4.5.2.18
	Kernel-5_35-4_79_2_287:4.5.2.18
	Kernel-5_35-4_79_2_286:4.5.2.18
	Kernel-5_35-4_79_2_285:4.5.2.18
	Kernel-5_35-4_79_2_284:4.5.2.18
	Kernel-5_35-4_79_2_283:4.5.2.18
	Kernel-5_35-4_79_2_282:4.5.2.18
	Kernel-5_35-4_79_2_281:4.5.2.18
	Kernel-5_35-4_79_2_280:4.5.2.18
	Kernel-5_35-4_79_2_279:4.5.2.18
	Kernel-5_35-4_79_2_278:4.5.2.18
	Kernel-5_35-4_79_2_277:4.5.2.18
	Kernel-5_35-4_79_2_276:4.5.2.18
	Kernel-5_35-4_79_2_275:4.5.2.18
	Kernel-5_35-4_79_2_274:4.5.2.18
	Kernel-5_35-4_79_2_273:4.5.2.18
	Kernel-5_35-4_79_2_272:4.5.2.18
	Kernel-5_35-4_79_2_271:4.5.2.18
	Kernel-5_35-4_79_2_270:4.5.2.18
	Kernel-5_35-4_79_2_269:4.5.2.18
	Kernel-5_35-4_79_2_268:4.5.2.18
	Kernel-5_35-4_79_2_267:4.5.2.18
	Kernel-5_35-4_79_2_266:4.5.2.18
	Kernel-5_35-4_79_2_265:4.5.2.18
	Kernel-5_35-4_79_2_264:4.5.2.18
	Kernel-5_35-4_79_2_263:4.5.2.18
	Kernel-5_35-4_79_2_262:4.5.2.18
	Kernel-5_35-4_79_2_261:4.5.2.18
	Kernel-5_35-4_79_2_260:4.5.2.18
	Kernel-5_35-4_79_2_259:4.5.2.18
	Kernel-5_35-4_79_2_258:4.5.2.18
	Kernel-5_35-4_79_2_257:4.5.2.18
	Kernel-5_35-4_79_2_256:4.5.2.18
	Kernel-5_35-4_79_2_255:4.5.2.18
	Kernel-5_35-4_79_2_254:4.5.2.18
	Kernel-5_35-4_79_2_253:4.5.2.18
	Kernel-5_35-4_79_2_252:4.5.2.18
	Kernel-5_35-4_79_2_251:4.5.2.18
	Kernel-5_35-4_79_2_250:4.5.2.18
	Kernel-5_35-4_79_2_249:4.5.2.17
	Kernel-5_35-4_79_2_248:4.5.2.17
	Kernel-5_35-4_79_2_247:4.5.2.17
	Kernel-5_35-4_79_2_246:4.5.2.17
	Kernel-5_35-4_79_2_245:4.5.2.17
	Kernel-5_35-4_79_2_244:4.5.2.17
	Kernel-5_35-4_79_2_243:4.5.2.17
	Kernel-5_35-4_79_2_242:4.5.2.17
	Kernel-5_35-4_79_2_241:4.5.2.17
	Kernel-5_35-4_79_2_240:4.5.2.17
	Kernel-5_35-4_79_2_239:4.5.2.17
	Kernel-5_35-4_79_2_238:4.5.2.17
	Kernel-5_35-4_79_2_237:4.5.2.17
	Kernel-5_35-4_79_2_236:4.5.2.17
	Kernel-5_35-4_79_2_235:4.5.2.17
	Kernel-5_35-4_79_2_234:4.5.2.17
	Kernel-5_35-4_79_2_233:4.5.2.17
	Kernel-5_35-4_79_2_232:4.5.2.17
	Kernel-5_35-4_79_2_231:4.5.2.17
	Kernel-5_35-4_79_2_230:4.5.2.17
	Kernel-5_35-4_79_2_229:4.5.2.17
	Kernel-5_35-4_79_2_228:4.5.2.17
	Kernel-5_35-4_79_2_227:4.5.2.17
	Kernel-5_35-4_79_2_226:4.5.2.17
	Kernel-5_35-4_79_2_225:4.5.2.17
	Kernel-5_35-4_79_2_224:4.5.2.17
	Kernel-5_35-4_79_2_223:4.5.2.17
	Kernel-5_35-4_79_2_222:4.5.2.17
	Kernel-5_35-4_79_2_221:4.5.2.17
	Kernel-5_35-4_79_2_220:4.5.2.17
	Kernel-5_35-4_79_2_219:4.5.2.17
	Kernel-5_35-4_79_2_218:4.5.2.17
	Kernel-5_35-4_79_2_217:4.5.2.17
	Kernel-5_35-4_79_2_216:4.5.2.17
	Kernel-5_35-4_79_2_215:4.5.2.17
	Kernel-5_35-4_79_2_214:4.5.2.17
	Kernel-5_35-4_79_2_213:4.5.2.17
	Kernel-5_35-4_79_2_212:4.5.2.17
	Kernel-5_35-4_79_2_211:4.5.2.17
	Kernel-5_35-4_79_2_210:4.5.2.17
	Kernel-5_35-4_79_2_209:4.5.2.17
	Kernel-5_35-4_79_2_208:4.5.2.17
	Kernel-5_35-4_79_2_207:4.5.2.17
	Kernel-5_35-4_79_2_206:4.5.2.17
	Kernel-5_35-4_79_2_205:4.5.2.17
	Kernel-5_35-4_79_2_204:4.5.2.17
	Kernel-5_35-4_79_2_203:4.5.2.16
	Kernel-5_35-4_79_2_202:4.5.2.15
	Kernel-5_35-4_79_2_201:4.5.2.15
	Kernel-5_35-4_79_2_200:4.5.2.15
	Kernel-5_35-4_79_2_199:4.5.2.15
	Kernel-5_35-4_79_2_198:4.5.2.15
	Kernel-5_35-4_79_2_197:4.5.2.15
	Kernel-5_35-4_79_2_196:4.5.2.15
	Kernel-5_35-4_79_2_195:4.5.2.15
	Kernel-5_35-4_79_2_194:4.5.2.15
	Kernel-5_35-4_79_2_193:4.5.2.14
	Kernel-5_35-4_79_2_192:4.5.2.14
	Kernel-5_35-4_79_2_191:4.5.2.14
	Kernel-5_35-4_79_2_190:4.5.2.14
	Kernel-5_35-4_79_2_189:4.5.2.14
	Kernel-5_35-4_79_2_188:4.5.2.14
	Kernel-5_35-4_79_2_187:4.5.2.14
	Kernel-5_35-4_79_2_186:4.5.2.14
	Kernel-5_35-4_79_2_185:4.5.2.14
	Kernel-5_35-4_79_2_184:4.5.2.14
	Kernel-5_35-4_79_2_183:4.5.2.14
	Kernel-5_35-4_79_2_182:4.5.2.14
	Kernel-5_35-4_79_2_181:4.5.2.14
	Kernel-5_35-4_79_2_180:4.5.2.14
	Kernel-5_35-4_79_2_179:4.5.2.14
	Kernel-5_35-4_79_2_178:4.5.2.14
	Kernel-5_35-4_79_2_177:4.5.2.14
	Kernel-5_35-4_79_2_176:4.5.2.14
	Kernel-5_35-4_79_2_175:4.5.2.14
	Kernel-5_35-4_79_2_174:4.5.2.14
	Kernel-5_35-4_79_2_173:4.5.2.14
	Kernel-5_35-4_79_2_172:4.5.2.14
	Kernel-5_35-4_79_2_171:4.5.2.14
	Kernel-5_35-4_79_2_170:4.5.2.14
	Kernel-5_35-4_79_2_169:4.5.2.14
	Kernel-5_35-4_79_2_168:4.5.2.14
	Kernel-5_35-4_79_2_167:4.5.2.14
	Kernel-5_35-4_79_2_166:4.5.2.14
	Kernel-5_35-4_79_2_165:4.5.2.14
	RPi_merge:4.5.2.11.2.3
	Kernel-5_35-4_79_2_147_2_23:4.5.2.11.2.3
	Kernel-5_35-4_79_2_147_2_22:4.5.2.11.2.2
	Kernel-5_35-4_79_2_147_2_21:4.5.2.11.2.1
	Kernel-5_35-4_79_2_147_2_20:4.5.2.11.2.1
	Kernel-5_35-4_79_2_147_2_19:4.5.2.11.2.1
	Kernel-5_35-4_79_2_147_2_18:4.5.2.11.2.1
	Kernel-5_35-4_79_2_164:4.5.2.13
	Kernel-5_35-4_79_2_163:4.5.2.13
	Kernel-5_35-4_79_2_147_2_17:4.5.2.11.2.1
	Kernel-5_35-4_79_2_147_2_16:4.5.2.11.2.1
	Kernel-5_35-4_79_2_147_2_15:4.5.2.11.2.1
	Kernel-5_35-4_79_2_162:4.5.2.13
	Kernel-5_35-4_79_2_161:4.5.2.13
	Kernel-5_35-4_79_2_147_2_14:4.5.2.11.2.1
	Kernel-5_35-4_79_2_147_2_13:4.5.2.11.2.1
	Kernel-5_35-4_79_2_160:4.5.2.13
	Kernel-5_35-4_79_2_159:4.5.2.13
	Kernel-5_35-4_79_2_158:4.5.2.12
	Kernel-5_35-4_79_2_157:4.5.2.12
	Kernel-5_35-4_79_2_156:4.5.2.12
	Kernel-5_35-4_79_2_147_2_12:4.5.2.11.2.1
	Kernel-5_35-4_79_2_147_2_11:4.5.2.11.2.1
	Kernel-5_35-4_79_2_155:4.5.2.12
	Kernel-5_35-4_79_2_147_2_10:4.5.2.11.2.1
	Kernel-5_35-4_79_2_154:4.5.2.12
	Kernel-5_35-4_79_2_153:4.5.2.12
	Kernel-5_35-4_79_2_147_2_9:4.5.2.11.2.1
	Kernel-5_35-4_79_2_152:4.5.2.12
	Kernel-5_35-4_79_2_151:4.5.2.12
	Kernel-5_35-4_79_2_147_2_8:4.5.2.11.2.1
	Kernel-5_35-4_79_2_147_2_7:4.5.2.11.2.1
	Kernel-5_35-4_79_2_150:4.5.2.12
	Kernel-5_35-4_79_2_147_2_6:4.5.2.11.2.1
	Kernel-5_35-4_79_2_147_2_5:4.5.2.11.2.1
	Kernel-5_35-4_79_2_149:4.5.2.11
	Kernel-5_35-4_79_2_147_2_4:4.5.2.11
	Kernel-5_35-4_79_2_147_2_3:4.5.2.11
	Kernel-5_35-4_79_2_148:4.5.2.11
	Kernel-5_35-4_79_2_147_2_2:4.5.2.11
	Kernel-5_35-4_79_2_147_2_1:4.5.2.11
	RPi:4.5.2.11.0.2
	RPi_bp:4.5.2.11
	Kernel-5_35-4_79_2_98_2_52_2_1:4.5.2.9.2.5
	alees_Kernel_dev:4.5.2.9.2.5.0.2
	alees_Kernel_dev_bp:4.5.2.9.2.5
	Kernel-5_35-4_79_2_147:4.5.2.11
	Kernel-5_35-4_79_2_146:4.5.2.11
	Kernel-5_35-4_79_2_145:4.5.2.11
	Kernel-5_35-4_79_2_144:4.5.2.11
	Kernel-5_35-4_79_2_143:4.5.2.11
	Kernel-5_35-4_79_2_142:4.5.2.11
	Kernel-5_35-4_79_2_141:4.5.2.11
	Kernel-5_35-4_79_2_140:4.5.2.11
	Kernel-5_35-4_79_2_139:4.5.2.11
	Kernel-5_35-4_79_2_138:4.5.2.11
	Kernel-5_35-4_79_2_137:4.5.2.11
	Kernel-5_35-4_79_2_136:4.5.2.11
	Kernel-5_35-4_79_2_135:4.5.2.11
	Kernel-5_35-4_79_2_134:4.5.2.11
	Kernel-5_35-4_79_2_133:4.5.2.11
	Kernel-5_35-4_79_2_132:4.5.2.11
	Kernel-5_35-4_79_2_131:4.5.2.11
	Kernel-5_35-4_79_2_130:4.5.2.11
	Kernel-5_35-4_79_2_129:4.5.2.11
	Kernel-5_35-4_79_2_128:4.5.2.11
	Kernel-5_35-4_79_2_127:4.5.2.11
	Kernel-5_35-4_79_2_126:4.5.2.11
	Kernel-5_35-4_79_2_125:4.5.2.11
	Kernel-5_35-4_79_2_124:4.5.2.11
	Kernel-5_35-4_79_2_123:4.5.2.10
	Cortex_merge:4.5.2.9.2.6
	Kernel-5_35-4_79_2_122:4.5.2.9
	Kernel-5_35-4_79_2_98_2_54:4.5.2.9.2.6
	Kernel-5_35-4_79_2_98_2_53:4.5.2.9.2.6
	Kernel-5_35-4_79_2_98_2_52:4.5.2.9.2.5
	Kernel-5_35-4_79_2_98_2_51:4.5.2.9.2.5
	Kernel-5_35-4_79_2_98_2_50:4.5.2.9.2.5
	Kernel-5_35-4_79_2_98_2_49:4.5.2.9.2.5
	Kernel-5_35-4_79_2_98_2_48:4.5.2.9.2.5
	Kernel-5_35-4_79_2_121:4.5.2.9
	Kernel-5_35-4_79_2_98_2_47:4.5.2.9.2.4
	Kernel-5_35-4_79_2_120:4.5.2.9
	Kernel-5_35-4_79_2_98_2_46:4.5.2.9.2.4
	Kernel-5_35-4_79_2_119:4.5.2.9
	Kernel-5_35-4_79_2_98_2_45:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_44:4.5.2.9.2.4
	Kernel-5_35-4_79_2_118:4.5.2.9
	Kernel-5_35-4_79_2_98_2_43:4.5.2.9.2.4
	Kernel-5_35-4_79_2_117:4.5.2.9
	Kernel-5_35-4_79_2_116:4.5.2.9
	Kernel-5_35-4_79_2_98_2_42:4.5.2.9.2.4
	Kernel-5_35-4_79_2_115:4.5.2.9
	Kernel-5_35-4_79_2_98_2_41:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_40:4.5.2.9.2.4
	Kernel-5_35-4_79_2_114:4.5.2.9
	Kernel-5_35-4_79_2_98_2_39:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_38:4.5.2.9.2.4
	Kernel-5_35-4_79_2_113:4.5.2.9
	Kernel-5_35-4_79_2_112:4.5.2.9
	Kernel-5_35-4_79_2_98_2_37:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_36:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_35:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_34:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_33:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_32:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_31:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_30:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_29:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_28:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_27:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_26:4.5.2.9.2.4
	Kernel-5_35-4_79_2_111:4.5.2.9
	Kernel-5_35-4_79_2_98_2_25:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_24:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_23:4.5.2.9.2.4
	Kernel-5_35-4_79_2_110:4.5.2.9
	Kernel-5_35-4_79_2_98_2_22:4.5.2.9.2.4
	Kernel-5_35-4_79_2_109:4.5.2.9
	Kernel-5_35-4_79_2_98_2_21:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_20:4.5.2.9.2.4
	Kernel-5_35-4_79_2_108:4.5.2.9
	Kernel-5_35-4_79_2_107:4.5.2.9
	Kernel-5_35-4_79_2_98_2_19:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_18:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_17:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_16:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_15:4.5.2.9.2.4
	Kernel-5_35-4_79_2_106:4.5.2.9
	Kernel-5_35-4_79_2_105:4.5.2.9
	Kernel-5_35-4_79_2_104:4.5.2.9
	Kernel-5_35-4_79_2_98_2_14:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_13:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_12:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_11:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_10:4.5.2.9.2.4
	Kernel-5_35-4_79_2_98_2_9:4.5.2.9.2.4
	Kernel-5_35-4_79_2_103:4.5.2.9
	Kernel-5_35-4_79_2_102:4.5.2.9
	Kernel-5_35-4_79_2_98_2_8:4.5.2.9.2.3
	Kernel-5_35-4_79_2_98_2_7:4.5.2.9.2.2
	Kernel-5_35-4_79_2_98_2_6:4.5.2.9.2.1
	Kernel-5_35-4_79_2_98_2_5:4.5.2.9
	Kernel-5_35-4_79_2_98_2_4:4.5.2.9
	Kernel-5_35-4_79_2_101:4.5.2.9
	Kernel-5_35-4_79_2_100:4.5.2.9
	Kernel-5_35-4_79_2_99:4.5.2.9
	Kernel-5_35-4_79_2_98_2_3:4.5.2.9
	Kernel-5_35-4_79_2_98_2_2:4.5.2.9
	Kernel-5_35-4_79_2_98_2_1:4.5.2.9
	Cortex:4.5.2.9.0.2
	Cortex_bp:4.5.2.9
	Kernel-5_35-4_79_2_98:4.5.2.9
	Kernel-5_35-4_79_2_97:4.5.2.9
	Kernel-5_35-4_79_2_96:4.5.2.9
	Kernel-5_35-4_79_2_95:4.5.2.9
	Kernel-5_35-4_79_2_94:4.5.2.9
	Kernel-5_35-4_79_2_93:4.5.2.9
	Kernel-5_35-4_79_2_92:4.5.2.9
	Kernel-5_35-4_79_2_91:4.5.2.9
	Kernel-5_35-4_79_2_90:4.5.2.9
	Kernel-5_35-4_79_2_89:4.5.2.9
	Kernel-5_35-4_79_2_88:4.5.2.9
	Kernel-5_35-4_79_2_87:4.5.2.9
	Kernel-5_35-4_79_2_86:4.5.2.9
	Kernel-5_35-4_79_2_85:4.5.2.9
	Kernel-5_35-4_79_2_84:4.5.2.8
	Kernel-5_35-4_79_2_83:4.5.2.8
	Kernel-5_35-4_79_2_82:4.5.2.8
	Kernel-5_35-4_79_2_81:4.5.2.8
	Kernel-5_35-4_79_2_80:4.5.2.8
	Kernel-5_35-4_79_2_79:4.5.2.8
	Kernel-5_35-4_79_2_78:4.5.2.8
	Kernel-5_35-4_79_2_77:4.5.2.8
	RO_5_07:4.5.2.8
	Kernel-5_35-4_79_2_76:4.5.2.8
	Kernel-5_35-4_79_2_75:4.5.2.8
	Kernel-5_35-4_79_2_74:4.5.2.8
	Kernel-5_35-4_79_2_73:4.5.2.8
	Kernel-5_35-4_79_2_72:4.5.2.8
	Kernel-5_35-4_79_2_71:4.5.2.8
	Kernel-5_35-4_79_2_70:4.5.2.8
	Kernel-5_35-4_79_2_69:4.5.2.8
	Kernel-5_35-4_79_2_68:4.5.2.8
	Kernel-5_35-4_79_2_67:4.5.2.8
	Kernel-5_35-4_79_2_66:4.5.2.8
	Kernel-5_35-4_79_2_65:4.5.2.8
	Kernel-5_35-4_79_2_64:4.5.2.8
	Kernel-5_35-4_79_2_63:4.5.2.8
	Kernel-5_35-4_79_2_62:4.5.2.8
	Kernel-5_35-4_79_2_61:4.5.2.8
	Kernel-5_35-4_79_2_59:4.5.2.8
	Kernel-5_35-4_79_2_58:4.5.2.7
	Kernel-5_35-4_79_2_57:4.5.2.7
	Kernel-5_35-4_79_2_56:4.5.2.7
	Kernel-5_35-4_79_2_55:4.5.2.7
	Kernel-5_35-4_79_2_54:4.5.2.6
	Kernel-5_35-4_79_2_53:4.5.2.6
	Kernel-5_35-4_79_2_52:4.5.2.5
	Kernel-5_35-4_79_2_51:4.5.2.5
	Kernel-5_35-4_79_2_50:4.5.2.4
	Kernel-5_35-4_79_2_49:4.5.2.4
	Kernel-5_35-4_79_2_48:4.5.2.4
	Kernel-5_47:4.5
	Kernel-5_46-4_90_2_1:4.5
	nbingham_Kernel_FastNC_dev_bp:4.5
	nbingham_Kernel_FastNC_dev:4.5.0.4
	Kernel-5_46:4.5
	Kernel-5_45:4.5
	Kernel-5_35-4_79_2_47:4.5.2.3
	Kernel-5_35-4_79_2_46:4.5.2.3
	Kernel-5_35-4_79_2_45:4.5.2.3
	Kernel-5_35-4_79_2_44:4.5.2.3
	Kernel-5_35-4_79_2_25_2_2:4.5.2.2
	Kernel-5_35-4_79_2_43:4.5.2.3
	Kernel-5_35-4_79_2_42:4.5.2.3
	Kernel-5_35-4_79_2_41:4.5.2.3
	Kernel-5_35-4_79_2_40:4.5.2.3
	Kernel-5_35-4_79_2_39:4.5.2.3
	Kernel-5_35-4_79_2_38:4.5.2.3
	Kernel-5_35-4_79_2_37:4.5.2.2
	Kernel-5_35-4_79_2_36:4.5.2.2
	Kernel-5_35-4_79_2_35:4.5.2.2
	Kernel-5_35-4_79_2_34:4.5.2.2
	Kernel-5_35-4_79_2_33:4.5.2.2
	Kernel-5_35-4_79_2_32:4.5.2.2
	Kernel-5_44:4.5
	Kernel-5_35-4_79_2_25_2_1:4.5.2.2
	Kernel-5_43:4.5
	Kernel-5_35-4_79_2_31:4.5.2.2
	Kernel-5_35-4_79_2_30:4.5.2.2
	Kernel-5_35-4_79_2_29:4.5.2.2
	Kernel-5_35-4_79_2_28:4.5.2.2
	Kernel-5_35-4_79_2_27:4.5.2.2
	Kernel-5_35-4_79_2_26:4.5.2.2
	Kernel-5_42:4.5
	Kernel-5_41:4.5
	Kernel-5_40:4.5
	Kernel-5_35-4_79_2_25:4.5.2.2
	Kernel-5_35-4_79_2_24:4.5.2.2
	Kernel-5_35-4_79_2_23:4.5.2.2
	Kernel-5_35-4_79_2_22:4.5.2.2
	Kernel-5_35-4_79_2_21:4.5.2.2
	Kernel-5_35-4_79_2_20:4.5.2.2
	Kernel-5_35-4_79_2_19:4.5.2.2
	Kernel-5_35-4_79_2_18:4.5.2.2
	Kernel-5_35-4_79_2_17:4.5.2.2
	Kernel-5_35-4_79_2_16:4.5.2.2
	Kernel-5_35-4_79_2_15:4.5.2.2
	Kernel-5_35-4_79_2_14:4.5.2.2
	Kernel-5_39:4.5
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.5
	Kernel-5_35-4_79_2_13:4.5.2.2
	Kernel-5_35-4_79_2_12:4.5.2.2
	Kernel-5_35-4_79_2_11:4.5.2.2
	Kernel-5_37:4.5
	Kernel-5_35-4_79_2_10:4.5.2.2
	Kernel-5_35-4_79_2_9:4.5.2.2
	Kernel-5_36:4.5
	Kernel-5_35-4_79_2_8:4.5.2.2
	Kernel-5_35-4_79_2_7:4.5.2.2
	Kernel-5_35-4_79_2_6:4.5.2.2
	Kernel-5_35-4_79_2_5:4.5.2.2
	Kernel-5_35-4_79_2_4:4.5.2.2
	Kernel-5_35-4_79_2_3:4.5.2.1
	Kernel-5_35-4_79_2_2:4.5.2.1
	dellis_autobuild_BaseSW:4.5
	Kernel-5_35-4_79_2_1:4.5.2.1
	HAL:4.5.0.2
	Kernel-5_35:4.5
	Kernel-5_34:4.5
	Kernel-5_33:4.5
	Kernel-5_32:4.5
	Kernel-5_31:4.5
	Kernel-5_30:4.5
	Kernel-5_29:4.4
	Kernel-5_28:4.4
	Kernel-5_27:4.3
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.5
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.2.2.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.2.2.1
	Ursula_RiscPC_bp:4.1.4.2
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.2.2.1
	Ursula_RiscPC:4.1.4.2.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.3
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.2
	UrsulaBuild_FinalSoftload:4.1.4.2
	rthornb_UrsulaBuild-12Aug1998:4.1.4.2
	aglover_UrsulaBuild-05Aug1998:4.1.4.2
	rthornb_UrsulaBuild-29Jul1998:4.1.4.2
	rthornb_UrsulaBuild-22Jul1998:4.1.4.2
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.2
	rthornb_UrsulaBuild-07Jul1998:4.1.4.2
	rthornb_UrsulaBuild-17Jun1998:4.1.4.2
	rthornb_UrsulaBuild-03Jun1998:4.1.4.2
	rthornb_UrsulaBuild-27May1998:4.1.4.2
	mstphens_Kernel-3_80:4.1.4.2
	rthornb_UrsulaBuild-21May1998:4.1.4.2
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2017.06.07.20.45.31;	author jlee;	state Exp;
branches;
next	4.8;
commitid	u2lBBGPD3exe2uUz;

4.8
date	2016.12.15.15.27.03;	author jlee;	state Exp;
branches;
next	4.7;
commitid	SNoEvPlWCrTKR5yz;

4.7
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches;
next	4.6;
commitid	skOEjp3ipLHx6xcz;

4.6
date	2016.06.30.20.08.20;	author jlee;	state Exp;
branches;
next	4.5;
commitid	IWoXxARWeuLDOwcz;

4.5
date	2000.06.28.16.12.26;	author bavison;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	2000.05.12.15.14.29;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.10.15.35.25;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2000.04.04.14.27.43;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.42;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.5.2.1
date	2000.09.15.12.38.02;	author kbracey;	state Exp;
branches;
next	4.5.2.2;

4.5.2.2
date	2000.10.05.11.55.13;	author mstephen;	state Exp;
branches;
next	4.5.2.3;

4.5.2.3
date	2001.06.18.14.49.48;	author mstephen;	state Exp;
branches;
next	4.5.2.4;

4.5.2.4
date	2002.10.07.17.29.46;	author kbracey;	state Exp;
branches;
next	4.5.2.5;

4.5.2.5
date	2002.11.30.00.31.14;	author bavison;	state Exp;
branches;
next	4.5.2.6;

4.5.2.6
date	2002.12.18.22.18.34;	author bavison;	state Exp;
branches;
next	4.5.2.7;

4.5.2.7
date	2003.01.27.15.25.36;	author kbracey;	state Exp;
branches;
next	4.5.2.8;

4.5.2.8
date	2003.03.31.09.44.12;	author kbracey;	state Exp;
branches;
next	4.5.2.9;

4.5.2.9
date	2005.05.04.11.14.34;	author kbracey;	state Exp;
branches
	4.5.2.9.2.1;
next	4.5.2.10;

4.5.2.10
date	2011.11.26.21.11.29;	author jlee;	state Exp;
branches;
next	4.5.2.11;
commitid	cI3W0zbtALQG6TIv;

4.5.2.11
date	2011.11.27.11.48.22;	author rsprowson;	state Exp;
branches
	4.5.2.11.2.1;
next	4.5.2.12;
commitid	OFgqaKhOb6swXXIv;

4.5.2.12
date	2012.05.21.19.31.45;	author rsprowson;	state Exp;
branches;
next	4.5.2.13;
commitid	oEtPURiKNEPMRC5w;

4.5.2.13
date	2012.07.04.17.50.58;	author rsprowson;	state Exp;
branches;
next	4.5.2.14;
commitid	BwjRc3GMlaDwTgbw;

4.5.2.14
date	2012.09.18.22.01.22;	author jlee;	state Exp;
branches;
next	4.5.2.15;
commitid	eFa3Y1QY0MjZP3lw;

4.5.2.15
date	2013.08.06.22.43.11;	author jlee;	state Exp;
branches;
next	4.5.2.16;
commitid	TOIaeUf2Q4rBIr0x;

4.5.2.16
date	2013.12.15.21.34.14;	author jlee;	state Exp;
branches;
next	4.5.2.17;
commitid	KwuK29hKRyXO7hhx;

4.5.2.17
date	2013.12.17.19.08.57;	author jlee;	state Exp;
branches;
next	4.5.2.18;
commitid	mr92WavK9Mu4gwhx;

4.5.2.18
date	2014.12.21.09.35.47;	author rsprowson;	state Exp;
branches;
next	;
commitid	zj3o85xlzNCYdT2y;

4.5.2.9.2.1
date	2009.05.10.20.22.33;	author bavison;	state Exp;
branches;
next	4.5.2.9.2.2;

4.5.2.9.2.2
date	2009.05.10.20.38.03;	author jlee;	state Exp;
branches;
next	4.5.2.9.2.3;

4.5.2.9.2.3
date	2009.05.17.01.34.44;	author bavison;	state Exp;
branches;
next	4.5.2.9.2.4;

4.5.2.9.2.4
date	2009.06.15.23.56.11;	author bavison;	state Exp;
branches;
next	4.5.2.9.2.5;

4.5.2.9.2.5
date	2011.08.08.23.28.38;	author jlee;	state Exp;
branches;
next	4.5.2.9.2.6;
commitid	D7rzILnwRRSXoLuv;

4.5.2.9.2.6
date	2011.09.24.19.55.59;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.5.2.11.2.1
date	2012.05.20.21.21.39;	author jballance;	state Exp;
branches;
next	4.5.2.11.2.2;
commitid	neZVFdyw3wNwvv5w;

4.5.2.11.2.2
date	2012.09.18.13.44.42;	author jlee;	state Exp;
branches;
next	4.5.2.11.2.3;
commitid	2BntgJjnyfkD51lw;

4.5.2.11.2.3
date	2012.09.18.15.50.12;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.1.1.1
date	96.11.05.09.41.42;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.04.08;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.57;	author mstphens;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.10.21.15.31.42;	author mstphens;	state Exp;
branches
	4.1.4.2.2.1;
next	4.1.4.3;

4.1.4.3
date	98.09.24.13.18.01;	author mstphens;	state Exp;
branches;
next	;

4.1.4.2.2.1
date	98.11.23.14.59.52;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.44;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.05.03;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Initial support for the ExtraBytes VIDC control list item
Detail:
  The ExtraBytes control list item can be used to add padding between framebuffer rows.
  When the kernel sees a VIDC list containing this item, it will now adjust the LineLength and ScreenSize mode variables accordingly, with the end result that the correct amount of memory will be allocated for the framebuffer and the OS will render into it correctly.
  Files changed:
  - hdr/KernelWS - Add DisplayLineLength variable to allow the correct LineLength value to be preserved when screen output is redirected to a sprite
  - s/vdu/vdudriver - Make ModeChangeSub initialise DisplayLineLength before calling SwitchOutputToSprite. Update PushModeInfo to take ExtraBytes into account when calculating LineLength and ScreenSize.
  - s/vdu/vdugrafl - Adjust SwitchOutputToSprite to use DisplayLineLength when restoring screen output
  - s/vdu/vduwrch - Fix full-screen CLS to not write to the padding bytes
Admin:
  Tested on Raspberry Pi 3


Version 5.82. Tagged as 'Kernel-5_82'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduWrch

;       Text printing etc.
;       ------------------

;       Author          Tim Dobson
;       Started         01-Sep-86
;       Status          Mostly Arm-less

; *****************************************************************************

; CursorFlags bits

; Bit   0       '81 column' mode
; Bits  1-3     Cursor movement directions
; Bit   4       Wrap instead of scroll in VDU4 mode
; Bit   5       Don't move cursor after printing character
; Bit   6       Don't wrap in VDU 5 mode
; Bit   7       Unused but could be set by user
; Bit   8       When in Wrch or screen update operation, set to 1 and forms
;               part of mask for ROR #10.
;               Otherwise is set to 0.
;               Tested by cursor code to see if it can update CursorFlags.
; Bits  9-17    Set to 101111000 so we can TST CursorFlags with itself ROR #10
;               to test for OR of C81Bit, Vdu5Bit, silly movement bits in 1 go
;               in order to optimise the case when none of these are present
; Bit   18      Set when cursors are split - since bit 8 is set this triggers
; Bit   19      Set when in teletext mode
; Bit   20      Set when in page mode
; Bit   21      Set when clip box calculations are enabled - this triggers
; Bits  22-24   Unused, but probably have to be zero because of ROR #10
; Bit   25      Actual cursor state  (1 => cursor is on screen)
; Bit   26      Set if VDU disabled
; Bits  27-28   Unused, but probably have to be zero because of ROR #10
; Bit   29      TextExpand not up-to-date
; Bit   30      VDU 5 mode
; Bit   31      In the '81st' column

InWrchBitPosn * 8
InWrchBit        *  1 :SHL: InWrchBitPosn
CursorsSplit     *  1 :SHL: 18
TeletextMode     *  1 :SHL: 19
PageMode         *  1 :SHL: 20
ClipBoxEnableBit *  1 :SHL: 21
ActualState      *  1 :SHL: 25
VduDisabled      *  1 :SHL: 26
TEUpdate         *  1 :SHL: 29
Vdu5Bit          *  1 :SHL: 30
C81Bit           *  1 :SHL: 31
InitialCursorFlags * (&1E :SHL: 10) :OR: (C81Bit :SHR: (32-10))

; The TST R6, R6, ROR #10 returns non-zero if
;
;       C81Bit OR Vdu5 OR (any of bits 1-4) OR CursorsSplit
;       OR ClipBoxEnableBit OR (TEUpdate AND bit7) OR Teletext
;
; The last two of these are slightly undesirable, but fairly harmless since:
;   (a) bit 7 is not normally set, and TEUpdate is only set when a colour
;       change happens.
;   (b) Teletext mode takes quite a long time anyway.
; NB We don't believe that the TST needs to detect Teletext mode, but if you
; want to stop it doing so, it's on your own head. Check everything carefully!

; *****************************************************************************
;
;       Set default logical and physical colours

bpp     RN      0
fore    RN      1
back    RN      2
tabaddr RN      3
index   RN      4
source  RN      5
dest    RN      6
col     RN      7
orrbits RN      8
addbits RN      9
bit0    RN      10

hiaddr  RN      4
loaddr  RN      5
; dest          6
hiword  RN      7       ; must be higher number than dest (for Colour16Bit)
loword  RN      8
cbyte   RN      9
spare1  RN      10
spare2  RN      11

; *****************************************************************************
;
;       VDU 20 - Set default colours (if output mode not teletext)
;        and palette (if display mode not teletext)
;
;       External routine, and DefaultColours called by mode change
;        and SwitchOutputToSprite
;
; in:   R6 = CursorFlags (for output mode)
;

VDU20   ROUT
        LDR     R0, [WsPtr, #DisplayModeFlags]  ; if display mode is
        TST     R0, #ModeFlag_Teletext          ; not teletext, then restore
        BNE     %FT10                           ; default palette

        Push    R14
        BL      PalInit                         ; R6 is preserved over the call
        Pull    R14
10
        TST     R6, #TeletextMode               ; if output mode is teletext
        MOVNE   PC, R14                         ; then don't reset colours

; else drop thru to ...

DefaultColours ROUT
        Push    R14

        ASSERT  GPLBMD = GPLFMD +4
        ASSERT  GFCOL = GPLFMD +8
        ASSERT  GBCOL = GPLFMD +12

        ASSERT  TBTint = TFTint +4
        ASSERT  GFTint = TFTint +8
        ASSERT  GBTint = TFTint +12

        ASSERT  TBackCol = TForeCol +4
        ASSERT  back > fore

        MOV     R0, #0                  ; foreground action := store
        MOV     R1, #0                  ; background action := store
        LDR     R2, [WsPtr, #NColour]   ; GCOL(0,(NColour AND 7)) except
        TST     R2, #&F0                ; for 256 colour modes
        ANDEQ   R2, R2, #7              ; when we use colour 63 (=NColour)
        MOV     R3, #0                  ; background colour := black
        ADD     R4, WsPtr, #GPLFMD      ; store GPLFMD, GPLBMD, GFCOL, GBCOL
        STMIA   R4, {R0-R3}

        MOV     R0, #&FF                ; R0 = TFTint := &FF; R1 = TBTint := 0
        MOV     R2, #&FF                ; R2 = GFTint := &FF; R3 = GBTint := 0
        ADD     R4, WsPtr, #TFTint
        STMIA   R4, {R0-R3}

        BL      SetColour               ; Update FgEcf & BgEcf

        LDR     bpp, [WsPtr, #BitsPerPix]
        LDR     fore, [WsPtr, #NColour] ; Number of colours allowed -1
        LDR     R8, [WsPtr, #ModeFlags]
        TEQ     fore, #63               ; are we in bodgy 256 colour mode?
        MOVEQ   fore, #255              ; then use colour 255 (cringe!)
        TEQ     fore, #15               ; 16 colour mode
        TSTEQ   R8, #ModeFlag_GreyscalePalette
        MOVEQ   fore, #7                ; Default is 7 for this depth of mode
        CMP     fore, #255
        MOV     back, #0
        BLS     %FT10
        ; Deal with true colour modes
        ; Default foreground is white, background is black
        ; Alpha/supremacy is taken from mode flags
        BL      GetAlphaSupremacyBits_AltEntry
        ; Arrive here with fore = full RGB, back = alpha/supremacy mask
        TST     R8, #ModeFlag_DataFormatSub_Alpha
        ORRNE   fore, fore, back        ; Is alpha blended mode, so set full alpha
        MOVEQ   back, #0                ; Transparency/supremacy mode, clear transfer channel
        

10
        ADD     R14, WsPtr, #TForeCol
        STMIA   R14, {fore, back}               ; save fgd + bgd text colours
        Pull    R14

;       and drop thru to ...

SetColours ROUT
        Push    R14

        CMP     bpp, #16

        MOVLS   R8, back, ROR bpp               ; move bits to top of word
        MOVLS   R9, fore, ROR bpp

        LDR     bpp, [WsPtr, #BytesPerChar]     ; fudge some more bits

        BHI     %FT20                           ; can't fudge anything over 16bpp
        ORR     back, R8, back, ROR bpp
        ORR     fore, R9, fore, ROR bpp

        MOV     LR, bpp
10
        TEQ     LR, #32                         ; have we finished replicating through word yet?
        ORRNE   back, back, back, LSR LR        ;   if not then expand again through the word
        ORRNE   fore, fore, fore, LSR LR
        MOVNE   LR, LR, LSL #1                  ; double the shift ready for the next pass
        BNE     %BT10                           ;   and loop again!

20
        STR     fore, [WsPtr, #TextFgColour]
        STR     back, [WsPtr, #TextBgColour]    ; store bit expanded fore / background colour

;       New colour change code
;       entered with fore, back expanded to <bytes_per_char> bits
;       and bpp set to be <bytes_per_char>

        TEQ     bpp, #16
        BEQ     Colour16Bit     ; can't optimise

        TEQ     bpp, #32
        BEQ     Colour32Bit     ; cannie optimise captin!

        EOR     fore, fore, back                ; so we can AND and EOR
        LDR     loaddr, [WsPtr, #TextExpandArea]
        ADD     dest, loaddr, bpp, LSL #8       ; end+1 destination addr
        MOV     hiaddr, dest                    ; TextPlain now moves around,
                                                ; depending on bytes-per-char
30
        LDR     cbyte, [hiaddr], #4
        AND     cbyte, cbyte, fore
        EOR     cbyte, cbyte, back
        STR     cbyte, [loaddr], #4
        TEQ     loaddr, dest
        BNE     %BT30

        Pull    PC
        LTORG

; *****************************************************************************
;
;       GetAlphaSupremacyBits - Get bit masks that correspond to the RGB and
;       alpha/supremacy components of a true-colour pixel
;
;       Exits with:
;       fore = RGB mask
;       back = alpha/supremacy mask
;       R8 = mode flags
;       R9 corrupt
;

GetAlphaSupremacyBits ROUT
        LDR     fore, [WsPtr, #NColour] ; Number of colours allowed -1
        LDR     R8, [WsPtr, #ModeFlags]
GetAlphaSupremacyBits_AltEntry
        MOV     R9, fore
        MOV     fore, #-1
        CMP     R9, #-1                 ; 32bpp?
        BIC     fore, fore, #&FF000000
        MOVEQ   back, #&FF000000        ; top byte is alpha/supremacy
        TEQNE   R9, fore                ; 24bpp packed?
        MOVEQ   pc, lr
        BIC     fore, fore, #&FF0000
        TEQ     R9, fore, LSR #4        ; 4k?
        MOVEQ   fore, fore, LSR #4
        MOVEQ   back, #&F000
        MOVEQ   pc, lr
        ; Not 32bpp, 24bpp or 4k, so must be 32k or 64k
        TST     R8, #ModeFlag_64k
        BICEQ   fore, fore, #&8000      ; is 32k
        MOVEQ   back, #&8000
        MOV     pc, lr

; *****************************************************************************
;
;       Colour16Bit - Set up colour table for 16 bits per pixel
;       Entered with R14 already pushed
;

Colour16Bit
        LDR     tabaddr, [WsPtr, #TextExpandArea]


        ADR     hiaddr, C16BTab
        ADD     R10, hiaddr, #128
C16B20
        ADR     loaddr, C16BTab
C16B30
        LDMIA   hiaddr, {dest, hiword}
        BL      OutputColour
        MOV     dest, hiword
        BL      OutputColour

        LDMIA   loaddr!, {dest, loword}
        BL      OutputColour
        MOV     dest, loword
        BL      OutputColour

        TEQ     loaddr, R10
        BNE     C16B30

        ADD     hiaddr, hiaddr, #8
        TEQ     hiaddr, R10
        BNE     C16B20

        Pull    PC

C16BTab
        &       &00000000, &00000000
        &       &00000000, &FFFF0000
        &       &00000000, &0000FFFF
        &       &00000000, &FFFFFFFF

        &       &FFFF0000, &00000000
        &       &FFFF0000, &FFFF0000
        &       &FFFF0000, &0000FFFF
        &       &FFFF0000, &FFFFFFFF

        &       &0000FFFF, &00000000
        &       &0000FFFF, &FFFF0000
        &       &0000FFFF, &0000FFFF
        &       &0000FFFF, &FFFFFFFF

        &       &FFFFFFFF, &00000000
        &       &FFFFFFFF, &FFFF0000
        &       &FFFFFFFF, &0000FFFF
        &       &FFFFFFFF, &FFFFFFFF

; *****************************************************************************
;
;       Colour32Bit - Set up colour table for 32 bits per pixel
;       Entered with R14 already pushed
;

Colour32Bit
        LDR     tabaddr, [WsPtr, #TextExpandArea]
        MOV     dest, #0
C32B20

; Expand the value in 'dest' so that each bit is stored as a word
; zero bits are stored in the background and non-zero bits are stored in
; foreground.  This is indexed when expanding the 1BPP VDU font out to
; the current depth.

        TST     dest, #1 <<7
        STREQ   back, [tabaddr], #4
        STRNE   fore, [tabaddr], #4
        TST     dest, #1 <<6
        STREQ   back, [tabaddr], #4
        STRNE   fore, [tabaddr], #4
        TST     dest, #1 <<5
        STREQ   back, [tabaddr], #4
        STRNE   fore, [tabaddr], #4
        TST     dest, #1 <<4
        STREQ   back, [tabaddr], #4
        STRNE   fore, [tabaddr], #4
        TST     dest, #1 <<3
        STREQ   back, [tabaddr], #4
        STRNE   fore, [tabaddr], #4
        TST     dest, #1 <<2
        STREQ   back, [tabaddr], #4
        STRNE   fore, [tabaddr], #4
        TST     dest, #1 <<1
        STREQ   back, [tabaddr], #4
        STRNE   fore, [tabaddr], #4
        TST     dest, #1 <<0
        STREQ   back, [tabaddr], #4
        STRNE   fore, [tabaddr], #4

        ADD     dest, dest, #1
        TEQ     dest, #256
        BNE     C32B20

        Pull    "PC"

; *****************************************************************************
;
;       Fast CLS used when no text window defined
;

FastCLS ROUT
        Push    R14
        BL      CheckTEUpdate

        TST     R6, #TeletextMode               ; teletext mode ?
        BEQ     %FT10                           ; and skip

        BL      TTXFastCLS                      ; else clear teletext map
        MOV     R5, #7
        MOV     R6, #8                          ; and clear screen to (transparent) black
        BL      TTXUpdateColours
        B       %FT15
10
        BL      CheckAcceleration
        BNE     %FT15
        MOV     R11, R13                        ; try to do an accelerated
        BIC     R13, R13, #63                   ; rectangle fill - need an
        LDR     R0, [WsPtr, #TextBgColour]
        MOV     R1, #&FFFFFFFF                  ; alignedOraEor block
        MVN     R2, R0
        MOV     R3, R1
        MOV     R4, R2
        Push    "R1-R4"
        Push    "R1-R4"
        Push    "R1-R4"
        Push    "R1-R4"
        MOV     R0, #0                          ; left
        LDR     R1, [WsPtr, #YWindLimit]        ; top
        LDR     R2, [WsPtr, #XWindLimit]        ; right (okay because checked BPC=BPP)
        MOV     R3, #0                          ; bottom
        MOV     R4, R13                         ; colour block
        Push    "R0-R4"
        MOV     R0, #GVRender_Sync
        MOV     R1, #GVRender_FillRectangle
        MOV     R2, R13
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_Render
        BL      CallGraphicsV
        MOV     R13, R11
        TEQ     R4, #GraphicsV_Complete
        Pull    PC, EQ
15
        ; If the framebuffer rows aren't contiguous then we must use SlowCLS
        LDR     R0, [WsPtr, #XWindLimit]
        LDR     R1, [WsPtr, #Log2BPP]
        ADD     R0, R0, #1
        LDR     R2, [WsPtr, #LineLength]
        MOV     R0, R0, LSL R1
        CMP     R0, R2, LSL #3
        Pull    "LR", NE
        BNE     SlowCLS

        LDR     R0, [WsPtr, #TextBgColour]
        LDR     R8, [WsPtr, #ScreenStart]
        MOV     R1, R0
        MOV     R2, R0
        MOV     R3, R0
        MOV     R4, R0
        MOV     R5, R0
        MOV     R6, R0
        MOV     R7, R0
        LDR     R9, [WsPtr, #ScreenSize]        ; screen size in bytes
20
        SUBS    R9, R9, #256                    ; if another 256 to do
        STMCSIA R8!, {R0 - R7}                  ; a bit excessive, I know !
        STMCSIA R8!, {R0 - R7}
        STMCSIA R8!, {R0 - R7}
        STMCSIA R8!, {R0 - R7}
        STMCSIA R8!, {R0 - R7}
        STMCSIA R8!, {R0 - R7}
        STMCSIA R8!, {R0 - R7}
        STMCSIA R8!, {R0 - R7}
        BHI     %BT20                           ; only loop if more to do
        ADDCC   R9, R9, #256                    ; add back the last 256
30
        SUBS    R9, R9, #4
        STRCS   R0, [R8], #4
        BHI     %BT30

        Pull    PC

; *****************************************************************************
;
;       Home cursor to "top left"

RS
Home
        MOV     R0, #0
        MOV     R1, #0
        B       TabR0R1

; *****************************************************************************
;
;       Address text cursor position
; in:   R0 = X position
;       R1 = Y position
;
; out:  CursorAddr contains screen address

CursorR0R1
        STR     R0, [WsPtr, #CursorX]
        STR     R1, [WsPtr, #CursorY]
CTADDR10
        Push    R14
        BL      AddressR0R1
        STR     R2, [WsPtr, #CursorAddr]
        Pull    PC

;       Calculate cursor address

AddressCursor
        LDR     R0, [WsPtr, #CursorX]
        LDR     R1, [WsPtr, #CursorY]
        B       CTADDR10


;       Address an X,Y text position in R0,R1
;       R2 is screen address on exit
;       R1, R3, R4 corrupted; R0, R5-R13 preserved

AddressR0R1     ROUT
        LDR     R2, [WsPtr, #ScreenStart] ; start address of top of screen
        LDR     R4, [WsPtr, #TextOffset]  ; offset for centering text window
        LDR     R3, [WsPtr, #CharWidth]
        ADD     R2, R2, R4
        LDR     R4, [WsPtr, #RowLength]
        MLA     R2, R3, R0, R2            ; add in X offset
        MLA     R2, R4, R1, R2            ; add in Y*RowLength
        MOV     PC, R14

; *****************************************************************************
;
;       Write character in R0 (>=32) to the screen
;       R6 = CursorFlags on entry
;

font    RN      1
screen  RN      2
bigfont RN      3
mask    RN      4
tophalf RN      5
bottomhalf RN   6
lbpp    RN      7
byte    RN      8
scrbyte RN      9
scrbyte2 RN     10
linelen RN      11

; *****Comment by DJS: Given we want applications to use the windowing world,
;   shouldn't we be optimising VDU 5 characters a bit more here? - even if it
;   makes VDU 4 characters a bit less optimal?

TimWrch ROUT
        LDR     R1, [WsPtr, #VduStatus]         ; test all silly flags at once
        TST     R1, #Vdu2Mode
        TSTEQ   R6, #(VduDisabled :OR: TEUpdate :OR: C81Bit :OR: Vdu5Bit)
        TSTEQ   R6, #(TeletextMode :OR: ClipBoxEnableBit)
10
        ADDEQ   font, WsPtr, #(Font-32*8)
        ADDEQ   font, font, R0, LSL #3
        LDMEQIA font, {tophalf, bottomhalf}
        Push    R14, EQ
        ADREQ   R14, %FT15
        LDREQ   screen, [WsPtr, #CursorAddr]
        LDREQ   bigfont, [WsPtr, #TextExpandArea]
        LDREQ   linelen, [WsPtr, #LineLength]
        LDREQ   PC, [WsPtr, #WrchNbit]

; *****Change made by DJS
; Moved the following code down to a place where we don't have to branch
; around it!
;        B       %FT20
;15
;        Pull    R14
;PostCharMove
;        LDR     R6, [WsPtr, #CursorFlags]
;        TST     R6, #32                         ; move cursor after char ?
;        BEQ     CHT                             ; move "right" & test for C81
;        MOV     PC, R14
;
;20
; *****End of change made by DJS

; if printing enabled then we want to print this character,
; so pull the old R14 off the stack

        TST     R1, #Vdu2Mode
        Pull    R14, NE                         ; in VDU 2 mode, so pull R14
        TST     R6, #VduDisabled                ; if VDU disabled
        MOVNE   PC, R14                         ; then don't print it
        TST     R6, #TEUpdate                   ; if colours need updating
        BNE     %FT30                           ; then do it + return to %25
25
        TST     R6, #Vdu5Bit
        BNE     Vdu5Wrch
        TST     R6, #C81Bit
        BNE     %FT40
35
        TST     R6, #TeletextMode
        BNE     TTXWrch
        TST     R6, #ClipBoxEnableBit
        BEQ     %BT10                           ; must enter with EQ

; now update clip box

        Push    R14
        BL      ClipCursorCell
        Pull    R14
        TST     R0, #0                          ; set EQ
        B       %BT10

; *****Change made by DJS
; Code moved down from above.

15
        Pull    R14
PostCharMove
        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #32                         ; move cursor after char ?
        BEQ     CHT                             ; move "right" & test for C81
        MOV     PC, R14

; *****End of change made by DJS

30
        Push    "R0,R14"
        BL      ReallySetColours                ; update colour table
        Pull    "R0,R14"
        B       %BT25

40
        Push    "R0, R14"
        BL      RCRLFR6                         ; do pending CRLF
        Pull    "R0, R14"
        B       %BT35

; *****************************************************************************
;
;       Write character in 1 bit-per-pixel mode

Wrch1bit

; *****Change made by DJS
; Original code was:
;        MOV     mask, #&FF000000
;
;        AND     byte, mask, tophalf, LSL #24
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        AND     byte, mask, tophalf, LSL #16
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        AND     byte, mask, tophalf, LSL #8
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        LDRB    scrbyte, [bigfont, tophalf, LSR #24]
;        STRB    scrbyte, [screen], linelen
;
;        AND     byte, mask, bottomhalf, LSL #24
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        AND     byte, mask, bottomhalf, LSL #16
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        AND     byte, mask, bottomhalf, LSL #8
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        LDRB    scrbyte, [bigfont, bottomhalf, LSR #24]
;        STRB    scrbyte, [screen], linelen
;
; There is no need to use "mask" at all in this...

        MOV     byte, tophalf, LSL #24
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        MOV     byte, tophalf, LSL #16
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        MOV     byte, tophalf, LSL #8
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        LDRB    scrbyte, [bigfont, tophalf, LSR #24]
        STRB    scrbyte, [screen], linelen

        MOV     byte, bottomhalf, LSL #24
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        MOV     byte, bottomhalf, LSL #16
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        MOV     byte, bottomhalf, LSL #8
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        LDRB    scrbyte, [bigfont, bottomhalf, LSR #24]
        STRB    scrbyte, [screen], linelen

; *****End of change made by DJS

        [ 1=0 ; *** No 1 bpc non-BBC gap modes at present ***
        LDR     R0, [WsPtr, #ModeFlags]         ; now test for non-BBC gap mode
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
        MOVNE   PC, R14
        LDRB    scrbyte, [bigfont]              ; store backgd in next 2
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen
        ]
        MOV     PC, R14

Wrch1bitDouble

; *****Change made by DJS
; Original code was:
;        MOV     mask, #&FF000000
;
;        AND     byte, mask, tophalf, LSL #24
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        STRB    scrbyte, [screen], linelen
;        AND     byte, mask, tophalf, LSL #16
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        STRB    scrbyte, [screen], linelen
;        AND     byte, mask, tophalf, LSL #8
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        STRB    scrbyte, [screen], linelen
;        LDRB    scrbyte, [bigfont, tophalf, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        STRB    scrbyte, [screen], linelen
;
;        AND     byte, mask, bottomhalf, LSL #24
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        STRB    scrbyte, [screen], linelen
;        AND     byte, mask, bottomhalf, LSL #16
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        STRB    scrbyte, [screen], linelen
;        AND     byte, mask, bottomhalf, LSL #8
;        LDRB    scrbyte, [bigfont, byte, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        STRB    scrbyte, [screen], linelen
;        LDRB    scrbyte, [bigfont, bottomhalf, LSR #24]
;        STRB    scrbyte, [screen], linelen
;        STRB    scrbyte, [screen], linelen
;
; As above, "mask" is not needed.

        MOV     byte, tophalf, LSL #24
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen
        MOV     byte, tophalf, LSL #16
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen
        MOV     byte, tophalf, LSL #8
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen
        LDRB    scrbyte, [bigfont, tophalf, LSR #24]
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen

        MOV     byte, bottomhalf, LSL #24
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen
        MOV     byte, bottomhalf, LSL #16
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen
        MOV     byte, bottomhalf, LSL #8
        LDRB    scrbyte, [bigfont, byte, LSR #24]
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen
        LDRB    scrbyte, [bigfont, bottomhalf, LSR #24]
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen

; *****End of change made by DJS

        [ 1=0 ; *** No 1 bpc non-BBC gap modes at present ***
        LDR     R0, [WsPtr, #ModeFlags]         ; now test for non-BBC gap mode
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
        MOVNE   PC, R14
        LDRB    scrbyte, [bigfont]              ; store backgd in next 2
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], linelen
        ]
        MOV     PC, R14

Wrch2bit

; *****Change made by DJS
; Original code was:
;
;        MOV     mask, #&FE000000
;        SUB     linelen, linelen, #1
;
;        AND     byte, mask, tophalf, LSL #24
;        LDR     scrbyte, [bigfont, byte, LSR #23]
;        MOVS    byte, tophalf, LSR #1
;        MOVCS   scrbyte, scrbyte, LSR #16
;        STRB    scrbyte, [screen], #1
;        MOV     scrbyte, scrbyte, LSR #8
;        STRB    scrbyte, [screen], linelen
;
;        AND     byte, mask, tophalf, LSL #16
;        LDR     scrbyte, [bigfont, byte, LSR #23]
;        MOVS    byte, tophalf, LSR #9
;        MOVCS   scrbyte, scrbyte, LSR #16
;        STRB    scrbyte, [screen], #1
;        MOV     scrbyte, scrbyte, LSR #8
;        STRB    scrbyte, [screen], linelen
;
;        AND     byte, mask, tophalf, LSL #8
;        LDR     scrbyte, [bigfont, byte, LSR #23]
;        MOVS    byte, tophalf, LSR #17
;        MOVCS   scrbyte, scrbyte, LSR #16
;        STRB    scrbyte, [screen], #1
;        MOV     scrbyte, scrbyte, LSR #8
;        STRB    scrbyte, [screen], linelen
;
;        AND     byte, mask, tophalf
;        LDR     scrbyte, [bigfont, byte, LSR #23]
;        MOVS    byte, tophalf, LSR #25
;        MOVCS   scrbyte, scrbyte, LSR #16
;        STRB    scrbyte, [screen], #1
;        MOV     scrbyte, scrbyte, LSR #8
;        STRB    scrbyte, [screen], linelen
;
;        AND     byte, mask, bottomhalf, LSL #24
;        LDR     scrbyte, [bigfont, byte, LSR #23]
;        MOVS    byte, bottomhalf, LSR #1
;        MOVCS   scrbyte, scrbyte, LSR #16
;        STRB    scrbyte, [screen], #1
;        MOV     scrbyte, scrbyte, LSR #8
;        STRB    scrbyte, [screen], linelen
;
;        AND     byte, mask, bottomhalf, LSL #16
;        LDR     scrbyte, [bigfont, byte, LSR #23]
;        MOVS    byte, bottomhalf, LSR #9
;        MOVCS   scrbyte, scrbyte, LSR #16
;        STRB    scrbyte, [screen], #1
;        MOV     scrbyte, scrbyte, LSR #8
;        STRB    scrbyte, [screen], linelen
;
;        AND     byte, mask, bottomhalf, LSL #8
;        LDR     scrbyte, [bigfont, byte, LSR #23]
;        MOVS    byte, bottomhalf, LSR #17
;        MOVCS   scrbyte, scrbyte, LSR #16
;        STRB    scrbyte, [screen], #1
;        MOV     scrbyte, scrbyte, LSR #8
;        STRB    scrbyte, [screen], linelen
;
;        AND     byte, mask, bottomhalf
;        LDR     scrbyte, [bigfont, byte, LSR #23]
;        MOVS    byte, bottomhalf, LSR #25
;        MOVCS   scrbyte, scrbyte, LSR #16
;        STRB    scrbyte, [screen], #1
;        MOV     scrbyte, scrbyte, LSR #8
;        STRB    scrbyte, [screen], linelen
;
; Messing around with this a bit, I found the following shorter & faster
; code:

        MOV     mask, #&7F
        SUB     linelen, linelen, #1

        ANDS    byte, mask, tophalf, LSR #1             ;C := bit 0 of tophalf
        LDR     scrbyte, [bigfont, byte, LSL #2]
        MOVCS   scrbyte, scrbyte, LSR #16
        STRB    scrbyte, [screen], #1
        MOV     scrbyte, scrbyte, LSR #8
        STRB    scrbyte, [screen], linelen

        ANDS    byte, mask, tophalf, LSR #9             ;C := bit 8 of tophalf
        LDR     scrbyte, [bigfont, byte, LSL #2]
        MOVCS   scrbyte, scrbyte, LSR #16
        STRB    scrbyte, [screen], #1
        MOV     scrbyte, scrbyte, LSR #8
        STRB    scrbyte, [screen], linelen

        ANDS    byte, mask, tophalf, LSR #17            ;C := bit 16 of tophalf
        LDR     scrbyte, [bigfont, byte, LSL #2]
        MOVCS   scrbyte, scrbyte, LSR #16
        STRB    scrbyte, [screen], #1
        MOV     scrbyte, scrbyte, LSR #8
        STRB    scrbyte, [screen], linelen

        ANDS    byte, mask, tophalf, LSR #25            ;C := bit 24 of tophalf
        LDR     scrbyte, [bigfont, byte, LSL #2]
        MOVCS   scrbyte, scrbyte, LSR #16
        STRB    scrbyte, [screen], #1
        MOV     scrbyte, scrbyte, LSR #8
        STRB    scrbyte, [screen], linelen

        ANDS    byte, mask, bottomhalf, LSR #1          ;C := bit 0 of b'half
        LDR     scrbyte, [bigfont, byte, LSL #2]
        MOVCS   scrbyte, scrbyte, LSR #16
        STRB    scrbyte, [screen], #1
        MOV     scrbyte, scrbyte, LSR #8
        STRB    scrbyte, [screen], linelen

        ANDS    byte, mask, bottomhalf, LSR #9          ;C := bit 8 of b'half
        LDR     scrbyte, [bigfont, byte, LSL #2]
        MOVCS   scrbyte, scrbyte, LSR #16
        STRB    scrbyte, [screen], #1
        MOV     scrbyte, scrbyte, LSR #8
        STRB    scrbyte, [screen], linelen

        ANDS    byte, mask, bottomhalf, LSR #17         ;C := bit 16 of b'half
        LDR     scrbyte, [bigfont, byte, LSL #2]
        MOVCS   scrbyte, scrbyte, LSR #16
        STRB    scrbyte, [screen], #1
        MOV     scrbyte, scrbyte, LSR #8
        STRB    scrbyte, [screen], linelen

        ANDS    byte, mask, bottomhalf, LSR #25         ;C := bit 24 of b'half
        LDR     scrbyte, [bigfont, byte, LSL #2]
        MOVCS   scrbyte, scrbyte, LSR #16
        STRB    scrbyte, [screen], #1
        MOV     scrbyte, scrbyte, LSR #8
        STRB    scrbyte, [screen], linelen

; *****End of change made by DJS

        LDR     R0, [WsPtr, #ModeFlags]         ; now test for non-BBC gap mode
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
        MOVNE   PC, R14
        LDRB    scrbyte, [bigfont]              ; store backgd in next 2
        STRB    scrbyte, [screen], #1
        STRB    scrbyte, [screen], linelen
        STRB    scrbyte, [screen], #1
        STRB    scrbyte, [screen], linelen
        MOV     PC, R14

Wrch4bit
        MOV     R10, #0                         ; extra rows are 0 if not TTX
        LDR     R0, [WsPtr, #ModeFlags]         ; now test for non-BBC gap mode
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EOR     R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
        MOV     mask, #&FF000000                ; don't set mask in Wrch4bitTTX
      [ :LNOT: HiResTTX
Wrch4bitTTX
      ]
        AND     byte, mask, tophalf, LSL #24
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen
        AND     byte, mask, tophalf, LSL #16
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen
        AND     byte, mask, tophalf, LSL #8
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen
        AND     byte, mask, tophalf
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen

        AND     byte, mask, bottomhalf, LSL #24
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen
        AND     byte, mask, bottomhalf, LSL #16
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen
        AND     byte, mask, bottomhalf, LSL #8
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen
        AND     byte, mask, bottomhalf
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen

        TEQ     R0, #0
        MOVNE   PC, R14
        AND     byte, mask, R10, LSL #8
        LDR     scrbyte, [bigfont, byte, LSR #22] ;get 1st extra (0 or for TTX)
        STR     scrbyte, [screen], linelen
        AND     byte, mask, R10
        LDR     scrbyte, [bigfont, byte, LSR #22] ;get 2nd extra (0 or for TTX)
        STR     scrbyte, [screen], linelen
        MOV     PC, R14

Wrch8bit
        MOV     mask, #&FF000000

        AND     byte, mask, tophalf, LSL #24
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, tophalf, LSL #16
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, tophalf, LSL #8
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, tophalf
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #24
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #16
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #8
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}

        [ 1=0 ; *** No 8 bpc non-BBC gap modes at present ***
        LDR     R0, [WsPtr, #ModeFlags]         ; now test for non-BBC gap mode
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
        MOVNE   PC, R14
        LDMIA   bigfont, {scrbyte, scrbyte2}    ; store backgd in next 2
        ADD     screen, screen, linelen
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        STMIA   screen, {scrbyte, scrbyte2}
        ]
        MOV     PC, R14

Wrch16bit
        MOV     mask, #&FF000000
        SUB     linelen, linelen, #16

        AND     byte, mask, tophalf, LSL #24
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, tophalf, LSL #16
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, tophalf, LSL #8
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, tophalf
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #24
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #16
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #8
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}

        [ 1=0 ; *** No 16 bpc non-BBC gap modes at present ***
        LDR     R0, [WsPtr, #ModeFlags]         ; now test for non-BBC gap mode
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
        MOVNE   PC, R14
        LDMIA   bigfont, {scrbyte, scrbyte2}    ; store backgd in next 2
        ADD     screen, screen, linelen
        STMIA   screen!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        STMIA   screen!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ]
        MOV     PC, R14

; *****************************************************************************

; Write a character at 32 bit per pixel
;
; NB: This code assumes that we have no concept of gap modes.

Wrch32bit
        Push    "R0-R1,R5-R7,R9-R10,R12,LR"

        MOV     mask, #&FF000000

        AND     byte, mask, tophalf, LSL #24
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte,   {R0,R1, R6,R7, R9,R10, R12,LR}
        STMIA   screen, {R0,R1, R6,R7, R9,R10, R12,LR}
        ADD     screen, screen, linelen

        AND     byte, mask, tophalf, LSL #16
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte,   {R0,R1, R6,R7, R9,R10, R12,LR}
        STMIA   screen, {R0,R1, R6,R7, R9,R10, R12,LR}
        ADD     screen, screen, linelen

        AND     byte, mask, tophalf, LSL #8
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte,   {R0,R1, R6,R7, R9,R10, R12,LR}
        STMIA   screen, {R0,R1, R6,R7, R9,R10, R12,LR}
        ADD     screen, screen, linelen

        AND     byte, mask, tophalf
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte,   {R0,R1, R6,R7, R9,R10, R12,LR}
        STMIA   screen, {R0,R1, R6,R7, R9,R10, R12,LR}
        ADD     screen, screen, linelen

        LDR     bottomhalf, [SP, #4*3]                  ; restore 'bottomhalf' (R6 pushed onto stack)

        AND     byte, mask, bottomhalf, LSL #24
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte,   {R0,R1, R5,R7, R9,R10, R12,LR}
        STMIA   screen, {R0,R1, R5,R7, R9,R10, R12,LR}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #16
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte,   {R0,R1, R5,R7, R9,R10, R12,LR}
        STMIA   screen, {R0,R1, R5,R7, R9,R10, R12,LR}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #8
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte,   {R0,R1, R5,R7, R9,R10, R12,LR}
        STMIA   screen, {R0,R1, R5,R7, R9,R10, R12,LR}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte,   {R0,R1, R5,R7, R9,R10, R12,LR}
        STMIA   screen, {R0,R1, R5,R7, R9,R10, R12,LR}
        ADD     screen, screen, linelen

        Pull    "R0-R1,R5,R6,R7,R9-R10,R12,PC"


; *****************************************************************************
;
;       BS - Backspace
;       move cursor "left"
;
; in:   R6 = CursorFlags
;

BS
        TST     R6, R6, ROR #10                 ; test &1E or C81Bit or Vdu5
        BNE     SpecialBS

        LDR     R0, [WsPtr, #CursorX]
        LDR     R2, [WsPtr, #CursorAddr]
        LDR     R3, [WsPtr, #CharWidth]
        LDR     R4, [WsPtr, #TWLCol]

        SUB     R0, R0, #1                      ; no Master wazerks yet !
        SUB     R2, R2, R3
        CMP     R0, R4
        STRGE   R0, [WsPtr, #CursorX]           ; I do mean GE !
        STRGE   R2, [WsPtr, #CursorAddr]
        MOVGE   PC, R14

        LDR     R0, =ZeroPage
        LDRB    R1, [R0, #OsbyteVars + :INDEX: PageModeLineCount]
        TEQ     R1, #0
        SUBNE   R1, R1, #1
        STRB    R1, [R0, #OsbyteVars + :INDEX: PageModeLineCount]

        LDR     R0, [WsPtr, #TWRCol]
        LDR     R1, [WsPtr, #CursorY]
        LDR     R4, [WsPtr, #TWTRow]

        SUB     R1, R1, #1
        CMP     R1, R4

        BGE     CursorR0R1

        STR     R0, [WsPtr, #CursorX]
        BSR     ScrollDown
        B       AddressCursor

; *****************************************************************************
;
;       Horizontal TAB - ie move cursor "right"
;
; in:   R6 = CursorFlags
;

HT
        TST     R6, R6, ROR #10 ; test for &1E or C81Bit or Vdu5
        BNE     SpecialHT

        LDR     R0, [WsPtr, #CursorX]
        LDR     R2, [WsPtr, #CursorAddr]
        LDR     R3, [WsPtr, #CharWidth]
        LDR     R4, [WsPtr, #TWRCol]

        ADD     R0, R0, #1
        ADD     R2, R2, R3
        CMP     R0, R4
        STRLS   R0, [WsPtr, #CursorX]
        STRLS   R2, [WsPtr, #CursorAddr]
        MOVLS   PC, R14

        BSR     PageTest

        LDR     R0, [WsPtr, #TWLCol]
        LDR     R1, [WsPtr, #CursorY]
        LDR     R4, [WsPtr, #TWBRow]

        ADD     R1, R1, #1
        CMP     R1, R4
        BLS     CursorR0R1                       ; not on bottom line

        STR     R0, [WsPtr, #CursorX]
        BSR     ScrollUp
        B       AddressCursor                    ; re-address cursor position

; *****************************************************************************
;
;       VduLF - Line feed
;
; in:   R6 = CursorFlags
;

VduLF
        TST     R6, #Vdu5Bit
        BNE     Vdu5LF

        BSR     PageTest                ; check for CTRL/SHIFT, page mode

        TST     R6, R6, ROR #10
        BNE     SpecialLF

        LDR     R1, [WsPtr, #CursorY]
        LDR     R2, [WsPtr, #CursorAddr]
        LDR     R3, [WsPtr, #RowLength]
        LDR     R4, [WsPtr, #TWBRow]

        ADD     R1, R1, #1                      ; no Master wazerks
        ADD     R2, R2, R3
        CMP     R1, R4
        STRLS   R1, [WsPtr, #CursorY]
        STRLS   R2, [WsPtr, #CursorAddr]
        MOVLS   PC, R14

        BSR     ScrollUp
        B       AddressCursor

; *****************************************************************************
;
;       VT - Cursor up
;

VT
        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #Vdu5Bit
        BNE     Vdu5VT

        LDR     R0, =ZeroPage
        LDRB    R1, [R0, #OsbyteVars + :INDEX: PageModeLineCount]
        TEQ     R1, #0
        SUBNE   R1, R1, #1
        STRB    R1, [R0, #OsbyteVars + :INDEX: PageModeLineCount]

        TST     R6, R6, ROR #10
        BNE     SpecialVT

        LDR     R1, [WsPtr, #CursorY]
        LDR     R2, [WsPtr, #CursorAddr]
        LDR     R3, [WsPtr, #RowLength]
        LDR     R4, [WsPtr, #TWTRow]

        SUB     R1, R1, #1
        SUB     R2, R2, R3
        CMP     R1, R4
        STRGE   R1, [WsPtr, #CursorY]
        STRGE   R2, [WsPtr, #CursorAddr]
        MOVGE   PC, R14

        BSR     ScrollDown
        B       AddressCursor

; *****************************************************************************
;
;       VduCR - Carriage return
;       move to "left" boundary
;
; in:   R6 = CursorFlags
;
; out:  R6 = updated CursorFlags

VduCR
CR10                            ; entry point for releasing pending CRLF
        TST     R6, #Vdu5Bit
        BNE     Vdu5CR

        BIC     R6, R6, #C81Bit                 ; destroy pending CRLF
        STR     R6, [WsPtr, #CursorFlags]
        Push    R14
        BL      CursorB0                        ; preserves R6
        BL      AddressCursor                   ; preserves R6
        Pull    PC

; *****************************************************************************
;
;       FS - Define text window
;

FS      ROUT
        LDRB    R0, [WsPtr, #QQ+0]              ; left
        LDRB    R1, [WsPtr, #QQ+1]              ; bottom
        LDRB    R2, [WsPtr, #QQ+2]              ; right
        LDRB    R3, [WsPtr, #QQ+3]              ; top
        LDR     R4, [WsPtr, #ScrRCol]           ; max right
        LDR     R5, [WsPtr, #ScrBRow]           ; max bottom

        LDR     R6, [WsPtr, #VduStatus]
        ORR     R6, R6, #Windowing              ; we are windowing
        STR     R6, [WsPtr, #VduStatus]

; Secondary entry point, for validating unpacked context variables
; NB doesn't want to set windowing bit

FSRegs
        CMP     R2, R0                          ; right >= left
        CMPCS   R4, R2                          ; max right >= right
        CMPCS   R1, R3                          ; bottom >= top
        CMPCS   R5, R1                          ; max bottom >= bottom
        MOVCC   PC, R14                         ; invalid window

        ADD     R6, WsPtr, #TWLCol
        STMIA   R6, {R0-R3}                     ; write new window settings

; now check for input cursor being outside window

        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #CursorsSplit
        BEQ     %FT10                           ; [cursors not split]

        ASSERT  InputCursorY = InputCursorX +4
        ADD     R6, WsPtr, #InputCursorX        ; R6 := InputCursorX
        LDMIA   R6, {R6, R7}                    ; R7 := InputCursorY

        CMP     R6, R0                          ; X >= left
        CMPCS   R2, R6                          ; right >= X
        CMPCS   R7, R3                          ; Y >= top
        CMPCS   R1, R7                          ; bottom >= Y

        BCS     %FT10                           ; [not outside window]

        LDR     R6, [WsPtr, #CursorX]           ; get output cursor posn
        LDR     R7, [WsPtr, #CursorY]
        LDR     R4, [WsPtr, #CursorAddr]
        Push    "R0-R4, R6, R7, R14"            ; save window and output cursor

        BL      HomeVdu4                        ; Home output cursor

        LDR     R6, [WsPtr, #CursorX]           ; Copy output ...
        LDR     R7, [WsPtr, #CursorY]
        LDR     R4, [WsPtr, #CursorAddr]

        STR     R6, [WsPtr, #InputCursorX]      ; ... to input
        STR     R7, [WsPtr, #InputCursorY]
        STR     R4, [WsPtr, #InputCursorAddr]

        Pull    "R0-R4, R6, R7, R14"            ; restore old registers
        STR     R6, [WsPtr, #CursorX]
        STR     R7, [WsPtr, #CursorY]
        STR     R4, [WsPtr, #CursorAddr]
10

; now check output cursor is inside window

        LDR     R6, [WsPtr, #CursorX]           ; get output cursor posn
        LDR     R7, [WsPtr, #CursorY]

        CMP     R6, R0                          ; X >= left
        CMPCS   R2, R6                          ; right >= X
        CMPCS   R7, R3                          ; Y >= top
        CMPCS   R1, R7                          ; bottom >= Y

        MOVCS   PC, R14                         ; cursor inside window

; and drop thru to ...

HomeVdu4                                        ; home TEXT cursor, even in
                                                ; VDU 5 mode
        MOV     R0, #0                          ; move to "0,0"
        MOV     R1, #0
        LDR     R6, [WsPtr, #CursorFlags]

        B       TabR0R1NotVdu5                  ; (destroys any pending CRLF)

; *****************************************************************************
;
;       TCOL - Set text colour (foreground or background)
;
        ASSERT  TBackCol = TForeCol +4
        ASSERT  back > fore

TCOL
DC1
        TST     R6, #TeletextMode               ; if in teletext
        MOVNE   PC, R14                         ; then ignore

        LDR     bpp, [WsPtr, #BitsPerPix]
        ADD     fore, WsPtr, #TForeCol
        LDMIA   fore, {fore, back}

        LDR     R3, [WsPtr, #NColour]
        LDRB    R4, [WsPtr, #QQ+0]              ; get colour specified
        CMP     R4, #128                        ; C=1 => set background
        AND     R4, R4, R3
        AND     R4, R4, #63                     ; oh no not again!
        STRCC   R4, [WsPtr, #TForeCol]
        STRCS   R4, [WsPtr, #TBackCol]
        MOVCC   R5, fore
        MOVCS   R5, back                        ; R5 is old appropriate colour
        MOVCC   fore, R4
        MOVCS   back, R4

        BCS     %FT31                           ; branch for background

        ; amg: only update the appropriate one
        CMP     R4,R5
        MOVEQ   PC, R14
        Push    "LR"
        BL      CompileTextFg
        Pull    "LR"
        B       %FT32
31
        CMP     R4, R5
        MOVEQ   PC, R14                         ; same as last time
        Push    "LR"
        BL      CompileTextBg                   ; ensure that TextBg is kosher
        Pull    "LR"                            ;   preserving the return address
32
        LDR     R6, [WsPtr, #CursorFlags]
        ORR     R6, R6, #TEUpdate
R6toCursorFlags
        STR     R6, [WsPtr, #CursorFlags]

        MOV     PC, R14

CheckTEUpdate
        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #TEUpdate
        MOVEQ   PC, R14
ReallySetColours
        BIC     R6, R6, #TEUpdate
        STR     R6, [WsPtr, #CursorFlags]       ; clear update flag

        Push    "R6, R14"
        LDR     bpp, [WsPtr, #BitsPerPix]
        LDR     fore, [WsPtr, #TextFgColour]
        LDR     back, [WsPtr, #TextBgColour]
        BL      SetColours
        Pull    "R6, PC"

; *****************************************************************************
;
;       FF - Clear text window (CLS)
;

FF
        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #Vdu5Bit
        BNE     Vdu5FF

        ASSERT  (ZeroPage :AND: 255) = 0
        STROSB  R0, PageModeLineCount, R0       ; zero page mode line count

        LDR     R0, [WsPtr, #VduStatus]
        TST     R0, #Windowing
        BNE     SlowCLS                         ; windowing, so do slowly

        Push    R14
        TST     R6, #ClipBoxEnableBit
        BLNE    SetClipBoxToFullScreen
        LDR     R0, [WsPtr, #DriverBankAddr]    ; set driver's screen start
        STR     R0, [WsPtr, #ScreenStart]
        BL      SetDisplayScreenStart

        LDR     R0, [WsPtr, #DisplayBankAddr]
        BL      SetVinit                        ; program Vinit
                                                ; (and set DisplayStart)
        BL      Home       ; home cursor after ScreenStart initialised
        TST     R6, #CursorsSplit
        BLNE    AddressInputCursor
        Pull    R14

        LDR     R0, [WsPtr, #ModeFlags]
        TST     R0, #ModeFlag_BBCGapMode        ; if not BBC gap mode
        BEQ     FastCLS                         ; then use fast code

SlowCLS
        BSR     Home

        ADD     R0, WsPtr, #TWLCol              ; R0 := TWLCol; R1 := TWBRow
        LDMIA   R0, {R0-R3}                     ; R2 := TWRCol; R3 := TWTRow

;       and drop thru to ...

;       ClearBox - Clears a box of text chars on the screen
;
; in:   R0 = left column
;       R1 = bottom row
;       R2 = right column
;       R3 = top row

ClearBox ROUT
        Push    R14
        TST     R6, #ClipBoxEnableBit
        BLNE    ClipTextArea

        TST     R6, #TeletextMode
        BNE     TTXClearBox

        BL      GetBoxInfo
        Pull    R14

ClearThisBox
        STR     R8, [WsPtr, #RowsToDo]

        LDR     R9, [WsPtr, #CursorFlags]
        TST     R9, #TEUpdate
        BNE     %FT99

05
        LDR     R8, [WsPtr, #TextBgColour]
        LDRB    R1, [WsPtr, #ModeFlags]
        TST     R1, #ModeFlag_BBCGapMode ; is it a BBC gap mode ?
        LDRNE   R1, =&AAAAAAAA          ; use colour 2 for gaps if so
        MOVEQ   R1, R8                  ; else use background colour
        EOR     R1, R1, R8              ; EOR toggle for colour
        STR     R1, [WsPtr, #EORtoggle]
        LDR     R0, [WsPtr, #RowMult]   ; 8 or 10

ClearRow
        MOV     R6, #0
ClearLineNew
        MOV     R9, R8
        MOV     R10, R8
        MOV     R11, R8
ClearLine
        MOV     R1, R2                  ; R1 is current address
        ADD     R3, R2, R5              ; R3 is byte after last one
10
        CMP     R1, R3
        BEQ     DoneLine
        TST     R1, #3
        STRNEB  R8, [R1], #1            ; store if not on word boundary
        BNE     %BT10

        SUB     R4, R3, R1              ; number of bytes left on this line
        MOV     R4, R4, LSR #4          ; number of 4-words left on this line
        SUBS    R4, R4, #1              ; C=0 if 0, C=1 if >0
14
        STMHIIA R1!, {R8-R11}           ; done if R4 > 0
        STMCSIA R1!, {R8-R11}           ; done if R4 >= 0
        SUBCSS  R4, R4, #2              ; this code dropped thru if R4 was 0
        BCS     %BT14

        BIC     R4, R3, #3
20
        CMP     R1, R4
        STRNE   R8, [R1], #4
        BNE     %BT20

30
        CMP     R1, R3
        STRNEB  R8, [R1], #1
        BNE     %BT30

DoneLine
        ADD     R2, R2, R7
        ADD     R6, R6, #1
        CMP     R6, #8
        BCC     ClearLine
        LDR     R1, [WsPtr, #EORtoggle]
        EOREQ   R8, R8, R1
        CMP     R6, R0
        BCC     ClearLineNew

        EOR     R8, R8, R1
        LDR     R1, [WsPtr, #RowsToDo]
        SUBS    R1, R1, #1
        STR     R1, [WsPtr, #RowsToDo]
        BNE     ClearRow

        MOV     PC, R14

99
        Push    "R2, R5-R7, R14"
        MOV     R6, R9
        BL      ReallySetColours
        Pull    "R2, R5-R7, R14"
        B       %BT05

        LTORG

; *****************************************************************************
;
;       GetWindowInfo - sets up some info for current text window
;
;       GetBoxInfo - sets up some info for a given box
;
; in:   R0 = left
;       R1 = bottom
;       R2 = right
;       R3 = top
;
; out:  R2 = address of top left
;       R5 = number of bytes horizontally
;       R6 = number of pixel rows vertically
;       R7 = LineLength
;       R8 = number of character rows vertically

GetWindowInfo
        ADD     R0, WsPtr, #TWLCol              ; R0 := TWLCol; R1 := TWBRow
        LDMIA   R0, {R0-R3}                     ; R2 := TWRCol; R3 := TWTRow
GetBoxInfo
        SUB     R5, R2, R0
        ADD     R5, R5, #1                      ; number of chars horiz
        LDR     R6, [WsPtr, #CharWidth]         ; should be bytes/char
        MUL     R5, R6, R5                      ; number of bytes horiz

        SUB     R6, R1, R3
        ADD     R8, R6, #1                      ; number of char rows vert

        LDR     R7, [WsPtr, #ModeFlags]

        MOV     R6, R8, LSL #3                  ; *8
        TST     R7, #ModeFlag_GapMode           ; if gap mode
        ADDNE   R6, R6, R8, LSL #1              ; (+*2) = *10
        TST     R7, #ModeFlag_DoubleVertical    ; if double mode
        ADDNE   R6, R6, R6                      ; then double

        LDR     R7, [WsPtr, #LineLength]

        MOV     R1, R3                          ; prepare to address top left
        B       AddressR0R1

;
;       TextWindowToGraphics - current text window converted to graphics
;
;       TextBoxToGraphics - given text box converted to graphics coordinates
;
; in:   R0 = left
;       R1 = bottom
;       R2 = right
;       R3 = top
;
; out:  R0-R3 converted to internal graphics coordinates
;       R5 = number of pixels horizontally
;       R6 = number of pixel rows vertically
;       R7 = row height in pixels
;       R8 = number of character rows vertically

ScreenToGraphics
        MOV     R0, #0
        LDR     R1, [WsPtr, #ScrBRow]
        LDR     R2, [WsPtr, #ScrRCol]
        MOV     R3, #0
        B       TextBoxToGraphics

TextWindowToGraphics
        ADD     R0, WsPtr, #TWLCol              ; R0 := TWLCol; R1 := TWBRow
        LDMIA   R0, {R0-R3}                     ; R2 := TWRCol; R3 := TWTRow
TextBoxToGraphics
        SUB     R5, R2, R0
        ADD     R5, R5, #1                      ; number of chars horiz

        LDR     R6, [WsPtr, #CharWidth]         ; bytes/char (not log2)
        LDR     R7, [WsPtr, #Log2BPP]           ; log2 bits/pixel

        MUL     R0, R6, R0                      ; number of bytes horiz
        MUL     R5, R6, R5
        SUB     R7, R7, #3                      ; log2 bytes/pixel

        MOV     R0, R0, LSR R7                  ; number of pixels horiz
        MOV     R5, R5, LSR R7
        ADD     R2, R0, R5                      ; recalculate right coord
        SUB     R2, R2, #1

        LDR     R7, [WsPtr, #TCharSizeY]

        SUB     R8, R1, R3
        ADD     R8, R8, #1                      ; number of char rows vert
        MUL     R3, R7, R3                      ; convert top to pixels (from top)
        MUL     R6, R7, R8                      ; convert height to pixels
        LDR     R1, [WsPtr, #YWindLimit]
        SUB     R3, R1, R3                      ; Y-flip coordinate (bottom-left = 0,0)
        SUB     R1, R3, R6                      ; recalculate bottom coord
        ADD     R1, R1, #1

        MOV     PC, R14

; *****************************************************************************
;
;       US - TAB(X,Y)
;

US
        LDRB    R0, [WsPtr, #QQ+0]
        LDRB    R1, [WsPtr, #QQ+1]
TabR0R1

        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #Vdu5Bit
        BNE     Vdu5TAB

TabR0R1NotVdu5
        LDR     R9,  [WsPtr, #CursorX]
        LDR     R10, [WsPtr, #CursorY]
        Push    "R0,R9,R10"             ; save old X,Y in case it doesn't work

        EOR     R6, R6, #8              ; update Y position
        MOV     R0, R1
        BSR     CursorBdy

        EOR     R6, R6, #8              ; now try X position
        Pull    R0
        BSR     CursorBdyCheck
        MOV     R7, #0                  ; will be clearing C81Bit
        BCS     US10                    ; was in window, so OK

        TEQ     R6, R6, LSR #1          ; are we in 81 column mode
                                        ; (just want to set carry)
        BCC     US20                    ; can't do it

        SUB     R0, R0, #1              ; could be attempt to move to col 81
        BSR     CursorBdyCheck
        BCC     US20                    ; still can't do it
        MOV     R7, #C81Bit             ; set C81Bit
US10
        BIC     R6, R6, #C81Bit
        ORR     R6, R6, R7
        STR     R6, [WsPtr, #CursorFlags]

US20
        Pull    "R9,R10"

        STRCC   R9,  [WsPtr, #CursorX]  ; couldn't do it, so restore position
        STRCC   R10, [WsPtr, #CursorY]

        B       AddressCursor

; *****************************************************************************
;
;       ScrollUp - Scroll the current text window up
;

ScrollUp
        LDR     R0, [WsPtr, #VduStatus]
        TST     R0, #Windowing
        BNE     SoftScrollUp
HardScrollUp
        LDR     R1, [WsPtr, #ModeFlags]
        TST     R1, #ModeFlag_HardScrollDisabled
        BNE     HardScrollSpriteUp

        Push    R14
        LDR     R1, [WsPtr, #RowLength]
        LDR     R2, [WsPtr, #TotalScreenSize]
        LDR     R14, [WsPtr, #ScreenEndAddr]

        LDR     R0, [WsPtr, #DisplayScreenStart]
        ADD     R0, R0, R1
        CMP     R0, R14
        SUBCS   R0, R0, R2
        BL      SetDisplayScreenStart
        LDR     R14, [WsPtr, #ScreenEndAddr]
        STR     R0, [WsPtr, #ScreenStart]

        LDR     R0, [WsPtr, #DisplayStart]
        ADD     R0, R0, R1
        CMP     R0, R14
        SUBCS   R0, R0, R2

        BL      SetVinit                ; program vinit and set DisplayStart

        TST     R6, #TeletextMode
        BLNE    TTXHardScrollUp
        Pull    R14

ClearBottomScreenLine
        MOV     R0, #0                          ; Don't use window coords -
        LDR     R1, [WsPtr, #ScrBRow]           ; code also used in VDU23,7
        LDR     R2, [WsPtr, #ScrRCol]
        MOV     R3, R1
        B       ClearBox

; Code to scroll whole 'screen' up, when hard scroll disabled
; (ie outputting to sprite)

HardScrollSpriteUp
        Push    R14
        TST     R6, #TeletextMode
        BNE     TTXSoftScrollUp
        BL      TryCopyScreenUp
        Pull    R14,EQ
        BEQ     ClearBottomScreenLine
        BL      GetScreenInfo           ; get box info for whole 'screen'
        LDR     R0, [WsPtr, #RowMult]
        BL      SoftScrollUp2
        Pull    R14
        B       ClearBottomScreenLine

; Clear bottom line of window

ClearBottomLine
        ADD     R0, WsPtr, #TWLCol              ; R0 := TWLCol; R1 := TWBRow
        LDMIA   R0, {R0-R2}                     ; R2 := TWRCol
        MOV     R3, R1                          ; R3 := TWBRow
        B       ClearBox

SoftScrollUp
        Push    R14
        TST     R6, #TeletextMode
        BNE     TTXSoftScrollUp

        BL      TryCopyWindowUp
        Pull    R14, EQ
        BEQ     ClearBottomLine
        BL      GetWindowInfo

;       R2 = address of top left
;       R5 = number of bytes horizontally
;       R6 = number of pixel rows in box
;       R7 = linelength
;       R8 = number of character rows in box

        LDR     R0, [WsPtr, #RowMult]
        BL      SoftScrollUp2
        Pull    R14
        B       ClearBottomLine

; *****************************************************************************
;
;       SoftScrollUp2 - Called by SoftScrollUp and by Teletext to scroll map
;
; in:   R0 = RowMult
;       R2 = screen address of top left of area to scroll
;       R5 = number of bytes horizontally
;       R6 = number of pixel rows vertically
;       R7 = linelength
;

SoftScrollUp2 ROUT
        SUBS    R6, R6, R0              ; scroll number of rows-1
        MOVEQ   PC, R14                 ; single row window, nowt to scroll

ScrollLineUp
        MOV     R1, R2
        LDR     R3, [WsPtr, #RowLength]
        ADD     R0, R1, R3              ; R0 -> line below
        ADD     R3, R2, R5              ; R3 -> byte after last one on upper
10
        CMP     R1, R3
        BEQ     %FT40                   ; finished
        TST     R1, #3                  ; if not word aligned
        LDRNEB  R8, [R0], #1            ; then copy a byte
        STRNEB  R8, [R1], #1
        BNE     %BT10

        SUB     R4, R3, R1              ; number of bytes left on this line
        MOVS    R4, R4, LSR #4          ; number of 4-words left on this line
        SUBS    R4, R4, #1              ; C=0 if 0, C=1 if >0
14
        LDMHIIA R0!, {R8-R11}           ; this code dropped thru if was 0
        STMHIIA R1!, {R8-R11}
        LDMCSIA R0!, {R8-R11}
        STMCSIA R1!, {R8-R11}
        SUBCSS  R4, R4, #2
        BCS     %BT14

        BIC     R4, R3, #3
20
        CMP     R1, R4
        LDRNE   R8, [R0], #4
        STRNE   R8, [R1], #4
        BNE     %BT20

30
        CMP     R1, R3
        LDRNEB  R8, [R0], #1
        STRNEB  R8, [R1], #1
        BNE     %BT30

40
        ADD     R2, R2, R7
        SUBS    R6, R6, #1
        BNE     ScrollLineUp

        MOV     PC, R14

; *****************************************************************************
;
;       TryCopyScreenUp - use GraphicsV to copy screen up
;
; in:   nothing
; out:  R0-R11 corrupted
;       Z flag set if successful

TryCopyScreenUp
        Push    R14
        BL      CheckAcceleration
        Pull    PC, NE                  ; return with Z clear (unsuccessful)
        BL      ScreenToGraphics
TryCopyUpCommon
        SUB     R4, R2, R0              ; width-1
        SUB     R5, R3, R1              ; height-1
        SUBS    R5, R5, R7              ; less one row
        Pull    PC,MI                   ; return with Z clear (unsuccessful)
        MOV     R2, R0                  ; dstL=srcL
        ADD     R3, R1, R7              ; dstB=srcB +1row
TryCopyCommon
        Push    "R0-R5"
        MOV     R0, #GVRender_Sync
        MOV     R1, #GVRender_CopyRectangle
        MOV     R2, R13
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_Render
        BL      CallGraphicsV
        ADD     R13, R13, #6*4
        TEQ     R4, #GraphicsV_Complete
        Pull    PC

; .............................................................................
;
;       TryCopyWindowUp - use GraphicsV to copy window up
;
; in:   nothing
; out:  R0-R11 corrupted
;       Z flag set if successful

TryCopyWindowUp
        LDR     R0, [WsPtr, #VduSprite]
        TEQ     R0, #0                  ; don't try it if outputting to sprite
        MOVNE   PC, R14                 ; return with Z clear (unsuccessful)
        Push    R14
        ADR     R14, TryCopyUpCommon
        B       TextWindowToGraphics

; *****************************************************************************
;
;       TryCopyScreenDown - use GraphicsV to copy screen down
;
; in:   nothing
; out:  R0-R11 corrupted
;       Z flag set if successful

TryCopyScreenDown
        Push    R14
        BL      CheckAcceleration
        Pull    PC, NE                  ; return with Z clear (unsuccessful)
        BL      ScreenToGraphics
TryCopyDownCommon
        SUB     R4, R2, R0              ; width-1
        SUB     R5, R3, R1              ; height-1
        SUBS    R5, R5, R7              ; less one row
        Pull    PC,MI                   ; return with Z clear (unsuccessful)
        MOV     R2, R0                  ; dstL=srcL
        MOV     R3, R1                  ; dstB=bot
        ADD     R1, R1, R7              ; srcB=bot +1row
        B       TryCopyCommon

; .............................................................................
;
;       TryCopyWindowDown - use GraphicsV to copy window down
;
; in:   nothing
; out:  R0-R11 corrupted
;       Z flag set if successful

TryCopyWindowDown
        LDR     R0, [WsPtr, #VduSprite]
        TEQ     R0, #0                  ; don't try it if outputting to sprite
        MOVNE   PC, R14                 ; return with Z clear (unsuccessful)
        Push    R14
        ADR     R14, TryCopyDownCommon
        B       TextWindowToGraphics

; *****************************************************************************
;
;       ScrollDown - Scroll the current text window down
;

ScrollDown
        LDR     R0, [WsPtr, #VduStatus]
        TST     R0, #Windowing
        BNE     SoftScrollDown
HardScrollDown
        LDR     R1, [WsPtr, #ModeFlags]
        TST     R1, #ModeFlag_HardScrollDisabled
        BNE     HardScrollSpriteDown

        Push    R14
        LDR     R1, [WsPtr, #RowLength]
        LDR     R2, [WsPtr, #TotalScreenSize]
        LDR     R14, [WsPtr, #ScreenEndAddr]

        LDR     R0, [WsPtr, #DisplayScreenStart]
        SUB     R0, R0, R1                      ; down one row
        ADD     R3, R0, R2
        CMP     R3, R14                         ; if < then need wrap
        MOVCC   R0, R3
        BL      SetDisplayScreenStart
        LDR     R14, [WsPtr, #ScreenEndAddr]
        STR     R0, [WsPtr, #ScreenStart]

        LDR     R0, [WsPtr, #DisplayStart]
        SUB     R0, R0, R1
        ADD     R3, R0, R2
        CMP     R3, R14
        MOVCC   R0, R3

        BL      SetVinit                ; program vinit and set DisplayStart

        TST     R6, #TeletextMode
        BLNE    TTXHardScrollDown
        Pull    R14

ClearTopScreenLine
        MOV     R0, #0                          ; don't use window coords -
        MOV     R1, #0                          ; code also used by VDU23,7
        LDR     R2, [WsPtr, #ScrRCol]
        MOV     R3, #0
        B       ClearBox

; Code to scroll whole 'screen' down, when hard scroll disabled
; (ie outputting to sprite)

HardScrollSpriteDown
        Push    R14
        TST     R6, #TeletextMode
        BNE     TTXSoftScrollDown
        BL      TryCopyScreenDown
        Pull    R14, EQ
        BEQ     ClearTopLine
        BL      GetScreenInfo           ; get box info for whole 'screen'

        MOV     R0, #0
        LDR     R1, [WsPtr, #ScrBRow]
        BL      AddressR0R1             ; R2 -> top line of bottom left char

        LDR     R0, [WsPtr, #RowMult]
        BL      SoftScrollDown2
        Pull    R14
        B       ClearTopScreenLine

; Clear top line of window

ClearTopLine
        ADD     R0, WsPtr, #TWLCol              ; R0 := TWLCol; (R1 := TWBRow)
        LDMIA   R0, {R0-R3}                     ; R2 := TWRCol; R3 := TWTRow
        MOV     R1, R3                          ; R1 := TWTRow
        B       ClearBox

SoftScrollDown
        Push    R14
        TST     R6, #TeletextMode
        BNE     TTXSoftScrollDown

        BL      TryCopyWindowDown
        Pull    R14, EQ
        BEQ     ClearTopLine
        BL      GetWindowInfo

;       R2 = address of top left
;       R5 = number of bytes horizontally
;       R6 = number of pixel rows in box
;       R7 = linelength
;       R8 = number of character rows in box

        ADD     R0, WsPtr, #TWLCol              ; R0 := TWLCol; R1 := TWBRow
        LDMIA   R0, {R0-R1}
        BL      AddressR0R1             ; R2 -> top line of bottom left char

        LDR     R0, [WsPtr, #RowMult]
        BL      SoftScrollDown2
        Pull    R14
        B       ClearTopLine

; *****************************************************************************
;
;       SoftScrollDown2 - Called by SoftScrollDown and by TTX to scroll map
;
; in:   R0 = RowMult
;       R2 = screen address of top line of bottom left char
;       R5 = number of bytes horizontally
;       R6 = number of pixel rows vertically
;       R7 = linelength
;

SoftScrollDown2 ROUT
        SUBS    R6, R6, R0              ; scroll number of rows-1
        MOVEQ   PC, R14                 ; single row window, nowt to scroll

        SUB     R2, R2, R7              ; R2 -> bottom line of next-to-bottom
        LDR     R1, [WsPtr, #RowLength]
        ADD     R2, R2, R1              ; R2 -> bottom line of bottom

ScrollLineDown
        MOV     R1, R2
        LDR     R3, [WsPtr, #RowLength]
        SUB     R0, R1, R3              ; R0 -> line above,needs fudging
        ADD     R3, R2, R5              ; R3 -> byte after last one on upper
10
        CMP     R1, R3
        BEQ     %FT40                   ; finished
        TST     R1, #3
        LDRNEB  R8, [R0], #1
        STRNEB  R8, [R1], #1
        BNE     %BT10

        SUB     R4, R3, R1              ; number of bytes left on this line
        MOVS    R4, R4, LSR #4          ; number of 4-words left on this line
        SUBS    R4, R4, #1              ; C=0 if 0, C=1 if >0
14
        LDMHIIA R0!, {R8-R11}           ; this code dropped thru if was 0
        STMHIIA R1!, {R8-R11}
        LDMCSIA R0!, {R8-R11}
        STMCSIA R1!, {R8-R11}
        SUBCSS  R4, R4, #2
        BCS     %BT14

        BIC     R4, R3, #3
20
        CMP     R1, R4
        LDRNE   R8, [R0], #4
        STRNE   R8, [R1], #4
        BNE     %BT20

30
        CMP     R1, R3
        LDRNEB  R8, [R0], #1
        STRNEB  R8, [R1], #1
        BNE     %BT30

40
        SUB     R2, R2, R7
        SUBS    R6, R6, #1
        BNE     ScrollLineDown

        MOV     PC, R14

; *****************************************************************************
;
;       SetVinit       - Program Vinit with address in R0
;       SetVstart      - Program Vstart with address in R0
;       SetVendDefault - Program Vend with end address for TotalScreenSize
;
; out:  R0-R2 corrupted
;

; mjs Oct 2000 kernel/HAL split
; these routines now call GraphicsV_SetDMAAddress

; Note that the addresses provided are logical addresses for the software mapping
; of the display, and this starts at (ScreenEndAddr - TotalScreenSize) for
; wonderful historical reasons (h/w scroll, two mappings, blah, blah) - see eg. PRM 1-354
;
; To get physical address for the HAL, we subtract this software mapping start
; address and add the physical address of the start of video memory.
;

SetVstart
        LDR     r2, [WsPtr, #ScreenEndAddr]
        SUB     r1, r0, r2
        LDR     r2, [WsPtr, #TotalScreenSize]
        ADD     r1, r1, r2                      ; now we have offset of Vstart in video RAM
        LDR     r2, [WsPtr, #TrueVideoPhysAddr]
        ADD     r1, r1, r2                      ; now we have physical address of Vstart
        MOV     r0, #GVDAG_VStart
        B       Do_GVDAG

SetVendDefault
        LDR     r2, [WsPtr, #TrueVideoPhysAddr]
        LDR     r1, [WsPtr, #TotalScreenSize]
        ADD     r1, r1, r2                      ; physical address of Vend
        MOV     r0, #GVDAG_VEnd
        B       Do_GVDAG

SetDisplayScreenStart
        Push    "r0-r2,lr"
        BL      SetVrender
        Pull    "r0-r2,pc"

SetVrender
        STR     r0, [WsPtr, #DisplayScreenStart]
        LDR     r2, [WsPtr, #ScreenEndAddr]
        SUB     r1, r0, r2
        LDR     r2, [WsPtr, #TotalScreenSize]
        ADD     r1, r1, r2                      ; now we have offset of Vrender in video RAM
        LDR     r0, [WsPtr, #TeletextOffset]
        ADD     r1, r1, r0                      ; add on teletext bank offset
        CMP     r1, r2                          ; if out of range
        SUBCS   r1, r1, r2                      ; then subtract total size
        LDR     r2, [WsPtr, #TrueVideoPhysAddr] ; now we have physical address
        ADD     r1, r1, r2
        MOV     r0, #GVDAG_VRender
        B       Do_GVDAG

SetVinit
        STR     r0, [WsPtr, #DisplayStart]
        LDR     r2, [WsPtr, #ScreenEndAddr]
        SUB     r1, r0, r2
        LDR     r2, [WsPtr, #TotalScreenSize]
        ADD     r1, r1, r2                      ; now we have offset of Vinit in video RAM
        LDR     r0, [WsPtr, #TeletextOffset]
        ADD     r1, r1, r0                      ; add on teletext bank offset
        CMP     r1, r2                          ; if out of range
        SUBCS   r1, r1, r2                      ; then subtract total size
        LDR     r2, [WsPtr, #TrueVideoPhysAddr] ; now we have physical address
        ADD     r1, r1, r2
        MOV     r0, #GVDAG_VInit
Do_GVDAG
        Push    "r4, lr"
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_SetDMAAddress
        BL      CallGraphicsV
        Pull    "r4, pc"

; *****************************************************************************
;
;       ConvertBankToAddress - Convert bank number into default start address
;
; in:   R2 = screen bank number (0..n)
;
; out:  R3 = default start address for that bank
;       R0-R2 preserved
;       R4,R5 corrupted
;

ConvertBankToAddress ROUT
        MOV     R4, R2
        LDR     R3, [WsPtr, #TotalScreenSize]
        LDR     R5, [WsPtr, #ScreenEndAddr]
        RSB     R3, R3, R5                      ; R3 := start of all screen mem
        LDR     R5, [WsPtr, #ScreenSize]
10
        MOVS    R4, R4, LSR #1                  ; add on R4*ScreenSize
        ADDCS   R3, R3, R5
        ADD     R5, R5, R5
        BNE     %BT10
        MOV     PC, R14

; *****************************************************************************
;
;       Delete - delete a character
;
; in:   R6 = CursorFlags
;

Delete  ROUT
        Push    R14

        TST     R6, #TEUpdate                   ; if colours dirty
        BLNE    ReallySetColours                ; then update them

        TST     R6, #32                         ; Bit 5 set => no cursor move
        BLEQ    BS
        LDR     R6, [WsPtr, #CursorFlags]       ; reload in case BS corrupts it

        TST     R6, #Vdu5Bit
        TSTEQ   R6, #(TeletextMode :OR: ClipBoxEnableBit)
        BNE     %FT20
10
        Pull    R14
        MOV     tophalf, #0                     ; Print with space
        MOV     bottomhalf, #0
        LDR     screen, [WsPtr, #CursorAddr]
        LDR     bigfont, [WsPtr, #TextExpandArea]
        LDR     linelen, [WsPtr, #LineLength]
        LDR     PC, [WsPtr, #WrchNbit]

20
        TST     R6, #Vdu5Bit
        Pull    R14, NE
        BNE     Vdu5Delete

        TST     R6, #TeletextMode
        MOVNE   R0, #32                         ; wipe out with space
        Pull    R14, NE
        BNE     TTXDoChar

        BL      ClipCursorCell                  ; must be ClipBoxEnable
        B       %BT10                           ; so clip cursor and continue

      [ {FALSE}

; *****************************************************************************
;
;       Convert colours if in 256 colour mode
;
; in:   bpp = BitsPerPix
;       fore = foreground colour (in 'user' format)
;       back = background colour (-------""-------)
;
; out:  fore, back = adjusted colours (if necessary)

ConvertCol
        CMP     bpp, #8
        MOVNE   PC, R14

        Push    R14
        MOV     col, fore
        LDR     index, [WsPtr, #TFTint]
        BL      FudgeColour
        MOV     fore, col

        MOV     col, back
        LDR     index, [WsPtr, #TBTint]
        BL      FudgeColour
        MOV     back, col

        Pull    PC

FudgeColour                             ; col   =   0  0 B3 B2 G3 G2 R3 R2
                                        ; index =  t1 t0  0  0  0  0  0  0

        MOV     R3, col, LSL #2         ; R3 :=  B3 B2 G3 G2 R3 R2  0  0
        AND     R3, R3, #&84            ; R3 :=  B3  0  0  0  0 R2  0  0
        MOVS    col, col, LSL #28       ; C :=   B2
        MOV     col, col, LSR #29       ; col :=  0  0  0  0  0 G3 G2 R3
        ORR     col, R3, col, LSL #4    ; col := B3 G3 G2 R3  0 R2  0  0
        ORRCS   col, col, #&08          ; col := B3 G3 G2 R3 B2 R2  0  0
        ORR     col, col, index, LSR #6 ; col := B3 G3 G2 R3 B2 R2 T1 T0
        MOV     PC, R14

      ]

; *****************************************************************************

PlainBit ROUT

; first set up RAMMaskTb

        ASSERT  bpp=0

        LDR     bpp, [WsPtr, #BytesPerChar]
        MOV     R1, #1
        RSB     R1, R1, R1, LSL bpp      ; first form mask for leftmost pixel
                                         ; = (2^BytesPerChar)-1

        ADD     R3, WsPtr, #RAMMaskTb
10
        STR     R1, [R3], #4            ; store mask
        MOVS    R1, R1, LSL bpp         ; shift to next pixel
        BNE     %BT10                   ; loop until all shifted out

; DDV: Original code used to read:
;
;       TEQ     bpp, #16
;       MOVEQ   PC, R14     ; nothing to do on a mode change in this mode
;
; In 32 bit per pixel modes this used to cause an overflow, new function
; drops out if the bpp >= 16.
;
        CMP     bpp, #16
        MOVGE   PC, R14     ; nothing to do on a mode change in this mode
        Push    R14

        LDR     tabaddr, [WsPtr, #TextExpandArea]
        ADD     tabaddr, tabaddr, bpp, LSL #8   ; TextPlain now dynamic

        MOV     dest, #&80000000

        CMP     bpp, #4
        BHI     Plain8Bit
        BEQ     Plain4Bit
        CMP     bpp, #1
        BHI     Plain2Bit

Plain1Bit
        ADR     hiaddr, P1BTab
        ADD     R10, hiaddr, #8                ; end address
P1B20
        LDR     hiword, [hiaddr], #4
P1B25
        ADR     loaddr, P1BTab
P1B30
        LDR     loword, [loaddr], #4
P1B40
        MOV     cbyte, hiword, LSL #28
        ORR     dest, cbyte, dest, LSR #4
        MOV     cbyte, loword, LSL #28
        ORRS    dest, cbyte, dest, LSR #4
        BLCS    OutputNoColour

        MOVS    loword, loword, LSR #4
        BNE     P1B40
        TEQ     loaddr, R10
        BNE     P1B30

        MOVS    hiword, hiword, LSR #4
        BNE     P1B25
        TEQ     hiaddr, R10
        BNE     P1B20

        Pull    PC

OutputColour
        AND     cbyte, dest, fore
        BIC     dest, back, dest
        ORR     dest, dest, cbyte
OutputNoColour
        STR     dest, [tabaddr], #4
        MOV     dest, #&80000000
        MOV     PC, R14

P1BTab
        &       &E6A2C480
        &       &F7B3D591

; *****************************************************************************

Plain2Bit
        ADR     hiaddr, P2BTab
        ADD     R10, hiaddr, #16
P2B20
        LDR     hiword, [hiaddr], #4
P2B25
        ADR     loaddr, P2BTab
P2B30
        LDR     loword, [loaddr], #4
P2B40
        MOV     cbyte, hiword, LSL #24
        ORR     dest, cbyte, dest, LSR #8
        MOV     cbyte, loword, LSL #24
        ORRS    dest, cbyte, dest, LSR #8
        BLCS    OutputNoColour

        MOVS    loword, loword, LSR #8
        BNE     P2B40
        TEQ     loaddr, R10
        BNE     P2B30

        MOVS    hiword, hiword, LSR #8
        BNE     P2B25
        TEQ     hiaddr, R10
        BNE     P2B20

        Pull    PC

P2BTab
        &       &F030C000
        &       &FC3CCC0C
        &       &F333C303
        &       &FF3FCF0F

; *****************************************************************************

Plain4Bit
        ADR     hiaddr, P4BTab
        ADD     R10, hiaddr, #32
P4B20
        LDR     hiword, [hiaddr], #4
P4B25
        ADR     loaddr, P4BTab
P4B30
        LDR     loword, [loaddr], #4
P4B40
        MOV     cbyte, hiword, LSL #16
        ORR     dest, cbyte, dest, LSR #16
        MOV     cbyte, loword, LSL #16
        ORRS    dest, cbyte, dest, LSR #16
        BLCS    OutputNoColour

        MOVS    loword, loword, LSR #16
        BNE     P4B40
        TEQ     loaddr, R10
        BNE     P4B30

        MOVS    hiword, hiword, LSR #16
        BNE     P4B25
        TEQ     hiaddr, R10
        BNE     P4B20

        Pull    PC

P4BTab
        &       &F0000000
        &       &FF000F00
        &       &F0F000F0
        &       &FFF00FF0
        &       &F00F000F
        &       &FF0F0F0F
        &       &F0FF00FF
        &       &FFFF0FFF

; *****************************************************************************

Plain8Bit
        ADR     hiaddr, P8BTab
        ADD     R10, hiaddr, #64
P8B20
        LDR     hiword, [hiaddr], #4
        ADR     loaddr, P8BTab
P8B30
        MOV     dest, hiword
        BL      OutputNoColour
        LDR     dest, [loaddr], #4
        BL      OutputNoColour

        TEQ     loaddr, R10
        BNE     P8B30

        TEQ     hiaddr, R10
        BNE     P8B20

        Pull    PC

P8BTab
        &       &00000000
        &       &FF000000
        &       &00FF0000
        &       &FFFF0000
        &       &0000FF00
        &       &FF00FF00
        &       &00FFFF00
        &       &FFFFFF00
        &       &000000FF
        &       &FF0000FF
        &       &00FF00FF
        &       &FFFF00FF
        &       &0000FFFF
        &       &FF00FFFF
        &       &00FFFFFF
        &       &FFFFFFFF

; *****************************************************************************
;
;       ReadCharacter - Read character at (input) text cursor position
;
; out:  R0 = character, 0 if unrecognised
;

ReadCharacter
        Push    R14

        BL      PreWrchCursor           ; remove both cursors
        BL      CheckTEUpdate           ; update TextExpand if necessary
                                        ; R6 = CursorFlags on exit
        TST     R6, #TeletextMode
        BNE     TTXReadCharacter

        TST     R6, #CursorsSplit
        LDREQ   R2, [WsPtr, #CursorAddr]        ; point to correct address
        LDRNE   R2, [WsPtr, #InputCursorAddr]

        LDR     R4, [WsPtr, #TextBgColour]
        LDR     R8, [WsPtr, #LineLength]

        LDR     R1, [WsPtr, #ModeFlags]
        TST     R1, #ModeFlag_DoubleVertical
        BNE     RdCh1BitDouble

        LDR     R1, [WsPtr, #CharWidth]
        CMP     R1, #2
        BCC     RdCh1Bit
        BEQ     RdCh2Bit
        CMP     R1, #8
        BCC     RdCh4Bit
        BEQ     RdCh8Bit

        CMP     R1, #16
        BEQ     RdCh16Bit

; Read character from cursor position for 32 bit per pixel

; in    R2 -> cursor address
;       R4 = background colour
;       R8 = line length to be used
;
; out   R6 = first four bytes of char defn
;       R7 = last four bytes of char defn

; used  R0,R1,R3,R5,R9,R10,R11,LR = loading screen data!

        MACRO
        ConvertTo1BPP $source, $dest, $bit
        EORS    $source, $source, R4
        ORRNE   $dest, $dest, #$bit
        MEND

RdChr32Bit
        Push    "R0-R1,R3,R5,R9,R10-R12"

        BL      RdCh32Bit_GetData
        MOV     R6,R7
        BL      RdCh32Bit_GetData

        Pull    "R0-R1,R3,R5,R9,R10-R12"
        B       RDCH14

; ***********************************************************************

RdCh32Bit_GetData
        MOV     R7, #1:SHL:31

RdCh32Bit_Loop
        MOVS    R7, R7, LSR #8

        LDMIA   R2,{R0,R1,R3,R5,R9,R10,R11,R12}
        ConvertTo1BPP R0,  R7, 1<<31
        ConvertTo1BPP R1,  R7, 1<<30
        ConvertTo1BPP R3,  R7, 1<<29
        ConvertTo1BPP R5,  R7, 1<<28
        ConvertTo1BPP R9,  R7, 1<<27
        ConvertTo1BPP R10, R7, 1<<26
        ConvertTo1BPP R11, R7, 1<<25
        ConvertTo1BPP R12, R7, 1<<24

        ADD     R2, R2, R8
        BCC     RdCh32Bit_Loop

        MOV     PC,LR

RdCh16Bit
        ADD     R2, R2, #12
        ADD     R5, R2, R8, LSL #2              ; half way
        ADD     R3, R2, R8, LSL #3              ; one-after-finishing R2
        ADD     R8, R8, #12
        MOV     R7, #0
RDCH90
        LDR     R1, [R2], #-4
        EOR     R1, R1, R4
        CMP     R1, #&00010000
        MOV     R7, R7, RRX
        MOV     R1, R1, LSL #16
        CMP     R1, #&00010000
        MOV     R7, R7, RRX

        LDR     R1, [R2], #-4
        EOR     R1, R1, R4
        CMP     R1, #&00010000
        MOV     R7, R7, RRX
        MOV     R1, R1, LSL #16
        CMP     R1, #&00010000
        MOV     R7, R7, RRX

        LDR     R1, [R2], #-4
        EOR     R1, R1, R4
        CMP     R1, #&00010000
        MOV     R7, R7, RRX
        MOV     R1, R1, LSL #16
        CMP     R1, #&00010000
        MOV     R7, R7, RRX

        LDR     R1, [R2], R8
        EOR     R1, R1, R4
        CMP     R1, #&00010000
        MOV     R7, R7, RRX
        MOV     R1, R1, LSL #16
        CMP     R1, #&00010000
        MOV     R7, R7, RRX

        TEQ     R2, R5                          ; half-way, so copy out word
        MOVEQ   R6, R7                          ; top word
        MOVEQ   R7, #0

        TEQ     R2, R3                          ; finished ?
        BNE     RDCH90
        BEQ     RDCH14


RdCh8Bit
        ADD     R2, R2, #4
        ADD     R5, R2, R8, LSL #2              ; half way
        ADD     R3, R2, R8, LSL #3              ; one-after-finishing R2
        MOV     R7, #0
        ADD     R8, R8, #4                      ; alternate between -4 and LL+4
        MVN     R9, R8
        EOR     R9, R9, #3                      ; thing to EOR R8 with
RDCH84
        EOR     R8, R8, R9
        LDR     R1, [R2], R8
        EOR     R1, R1, R4
        CMP     R1, #&01000000
        MOV     R7, R7, RRX
        MOV     R1, R1, LSL #8
        ORR     R1, R1, #1                      ; dummy bit
        CMP     R1, #&01000000
RDCH88
        MOV     R7, R7, RRX
        MOV     R1, R1, LSL #8
        CMP     R1, #&01000000                  ; Z => finish, C = output bit
        BNE     RDCH88

        TEQ     R2, R5                          ; half-way, so copy out word
        MOVEQ   R6, R7                          ; top word
        MOVEQ   R7, #0

        TEQ     R2, R3                          ; finished ?
        BNE     RDCH84
        BEQ     RDCH14


RdCh4Bit
        ADD     R5, R2, R8, LSL #2              ; half way
        ADD     R3, R2, R8, LSL #3              ; one-after-finishing R2
        MOV     R7, #0
RDCH44
        LDR     R1, [R2], R8
        EOR     R1, R1, R4
        CMP     R1, #&10000000
        MOV     R7, R7, RRX
        MOV     R1, R1, LSL #4
        ORR     R1, R1, #1                      ; dummy bit
        CMP     R1, #&10000000
RDCH48
        MOV     R7, R7, RRX
        MOV     R1, R1, LSL #4
        CMP     R1, #&10000000                  ; Z => finish, C = output bit
        BNE     RDCH48

        TEQ     R2, R5                          ; half-way, so copy out word
        MOVEQ   R6, R7                          ; top word
        MOVEQ   R7, #0

        TEQ     R2, R3                          ; finished ?
        BNE     RDCH44
        BEQ     RDCH14


RdCh2Bit
        ANDS    R0, R2, #3
        EOR     R2, R2, R0                      ; make R2 -> word boundary
        MOVNE   R0, #16                         ; shift adjust
        ADD     R5, R2, R8, LSL #2              ; half way
        ADD     R3, R2, R8, LSL #3              ; one-after-finishing R2
        MOV     R7, #0
RDCH24
        LDR     R1, [R2], R8
        EOR     R1, R1, R4
        MOV     R1, R1, ROR R0
        MOV     R1, R1, LSL #16                 ; important bits at top
        ORR     R1, R1, #&4000                  ; dummy bit
        CMP     R1, #&40000000
RDCH28
        MOV     R7, R7, RRX
        MOV     R1, R1, LSL #2
        CMP     R1, #&40000000                  ; Z => finish, C = output bit
        BNE     RDCH28

        TEQ     R2, R5                          ; half-way, so copy out word
        MOVEQ   R6, R7                          ; top word
        MOVEQ   R7, #0

        TEQ     R2, R3                          ; finished ?
        BNE     RDCH24
        BEQ     RDCH14

RdCh1Bit
        LDRB    R6, [R2], R8
        MOV     R6, R6, LSL #24
        LDRB    R0, [R2], R8
        ORR     R6, R6, R0, LSL #16
        LDRB    R0, [R2], R8
        ORR     R6, R6, R0, LSL #8
        LDRB    R0, [R2], R8
        ORR     R0, R6, R0
        EOR     R0, R0, R4                      ; make background zero

        MOV     R6, #1                          ; now invert order of bits
RDCH10
        MOVS    R0, R0, LSR #1
        ADCS    R6, R6, R6
        BCC     RDCH10

        LDRB    R7, [R2], R8
        MOV     R7, R7, LSL #24
        LDRB    R0, [R2], R8
        ORR     R7, R7, R0, LSL #16
        LDRB    R0, [R2], R8
        ORR     R7, R7, R0, LSL #8
        LDRB    R0, [R2], R8
        ORR     R0, R7, R0
        EOR     R0, R0, R4

        MOV     R7, #1                          ; now invert order of bits
RDCH12
        MOVS    R0, R0, LSR #1
        ADCS    R7, R7, R7
        BCC     RDCH12

RDCH14
        MOV     R0, #32
        ADD     R1, WsPtr, # Font
RDCH16
        LDMIA   R1!, {R2,R3}
        TEQ     R2, R6
        TEQEQ   R3, R7
        BEQ     RDCH17                          ; successful match
        ADD     R0, R0, #1
        TEQ     R0, #127
        ADDEQ   R0, R0, #1
        ADDEQ   R1, R1, #8
        ANDS    R0, R0, #&FF                    ; 0 if finished
        BNE     RDCH16

RDCH17
        Push    R0                              ; save char
        BL      PostWrchCursor
        Pull    "R0, PC"

; *****************************************************************************

RdCh1BitDouble                                  ; double height mode
        LDRB    R0, [R2], R8
        LDRB    R3, [R2], R8
        TEQ     R0, R3
        MOVEQ   R6, R0, LSL #24
        LDREQB  R0, [R2], R8
        LDREQB  R3, [R2], R8
        TEQEQ   R0, R3
        ORREQ   R6, R6, R0, LSL #16
        LDREQB  R0, [R2], R8
        LDREQB  R3, [R2], R8
        TEQEQ   R0, R3
        ORREQ   R6, R6, R0, LSL #8
        LDREQB  R0, [R2], R8
        LDREQB  R3, [R2], R8
        TEQEQ   R0, R3
        ORREQ   R0, R6, R0

        MOVNE   R0, #0                          ; indicate bad character
        BNE     RDCH17                          ; and branch

        EOR     R0, R0, R4                      ; make background zero

        MOV     R6, #1                          ; now invert order of bits
RDCH10D
        MOVS    R0, R0, LSR #1
        ADCS    R6, R6, R6
        BCC     RDCH10D

        LDRB    R0, [R2], R8
        LDRB    R3, [R2], R8
        TEQ     R0, R3
        MOVEQ   R7, R0, LSL #24
        LDREQB  R0, [R2], R8
        LDREQB  R3, [R2], R8
        TEQEQ   R0, R3
        ORREQ   R7, R7, R0, LSL #16
        LDREQB  R0, [R2], R8
        LDREQB  R3, [R2], R8
        TEQEQ   R0, R3
        ORREQ   R7, R7, R0, LSL #8
        LDREQB  R0, [R2], R8
        LDREQB  R3, [R2], R8
        TEQEQ   R0, R3
        ORREQ   R0, R7, R0

        MOVNE   R0, #0                          ; indicate bad character
        BNE     RDCH17                          ; and branch

        EOR     R0, R0, R4

        MOV     R7, #1                          ; now invert order of bits
RDCH12D
        MOVS    R0, R0, LSR #1
        ADCS    R7, R7, R7
        BCC     RDCH12D
        B       RDCH14

; *****************************************************************************

TTXReadCharacter
        TST     R6, #CursorsSplit
        LDR     R1, [WsPtr, #TTXLineStartsPtr]
        LDREQ   R2, [WsPtr, #CursorY]
        LDRNE   R2, [WsPtr, #InputCursorY]
        LDR     R1, [R1, R2, LSL #2]
        LDREQ   R2, [WsPtr, #CursorX]
        LDRNE   R2, [WsPtr, #InputCursorX]
        ADD     R2, R2, #1                      ; skip dummy
        LDRB    R1, [R1, R2, LSL #2]
        MOV     R0, R1
        TEQ     R1, #"#"                        ; not those again !
        MOVEQ   R0, #"`"
        TEQ     R1, #"`"
        MOVEQ   R0, #"_"
        TEQ     R1, #"_"
        MOVEQ   R0, #"#"
        B       RDCH17

; *****************************************************************************
;
;       DoOSBYTE87 - OSBYTE &87 entry point
;
; in:   -
;
; out:  R0 = &87
;       R1 = character at text cursor, 0 if unrecognised
;       R2 = screen mode
;

DoOSBYTE87
        Push    "R3-R11,R14"
        BL      ReadCharacter
        MOV     R1, R0
        MOV     R0, #&87
        LDR     R2, [WsPtr, #ModeNo]
        CMP     R0, #0                          ; clear V for any wallies!
        Pull    "R3-R11,PC"

; *****************************************************************************
;
;       PageTest - check for CTRL/SHIFT, page mode
;
; in:   R6 = CursorFlags
;

PageTest
        Push    R14

        BL      Page_ProcessCallbacks   ; give callbacks at least one chance per line

        CLC                             ; don't set leds first time
        BL      CtrlShiftTest           ; on exit, C=CTRL, N=SHIFT
        BCC     Page20                  ; CTRL up, then branch
        BPL     Page20                  ; SHIFT up, then branch

; CTRL and SHIFT are down

        BL      ClearLines              ; CTRL+SHIFT down, so clear lines
        BL      PostWrchCursor          ; we may be some time, so enable cursor
CSWaitLoop
        SEC                             ; set leds
        BL      CtrlShiftTest
        BCC     Page18
        BLMI    Page_ProcessCallbacksIdle
        BMI     CSWaitLoop              ; and wait for change (NB C=1 now)
Page18
 [ {FALSE}
        BL      LEDsOff                 ; put LEDs back to normal
 ]
        BL      PreWrchCursor           ; get rid of cursor again

; CTRL and SHIFT are not both down

Page20
        CLC                             ; don't set leds first time
        BL      CtrlShiftTest
        BCC     Page40                  ; [CTRL not down]

; CTRL down, so wait for auto repeat delay time before continuing

        BL      PostWrchCursor          ; we may be some time, so enable cursor

        LDROSB  R1, KeyRepRate
        STROSB  R1, CentiCounter, R0
        CLC
Page30
        BL      CtrlShiftTest
        BCC     Page35                  ; CTRL no longer down
        LDROSB  R1, CentiCounter
        CMP     R1, #1
        BLCS    Page_ProcessCallbacksIdle
        BCS     Page30                  ; loop with carry set
Page35
        BL      PreWrchCursor           ; remove cursor again

; CTRL not down, test for page mode

Page40
; If we're using the debug terminal, never use paged mode, because serial input doesn't work too well when you need to detect shift being pressed!
 [ :LNOT: DebugTerminal
        EOR     R0, R6, #PageMode
        TST     R0, #(PageMode :OR: CursorsSplit)
        Pull    PC, NE                  ; cursors split or not in page mode

        LDROSB  R3, PageModeLineCount
        BL      BotRowCheck             ; are we on bottom row ?
        BNE     IncLinesExit
        TST     R6, #8
        LDREQ   R0, [WsPtr, #TWBRow]
        LDREQ   R1, [WsPtr, #TWTRow]
        LDRNE   R0, [WsPtr, #TWRCol]
        LDRNE   R1, [WsPtr, #TWLCol]
        SUB     R0, R0, R1              ; get number of lines in window
        SUB     R0, R0, R0, LSR #2      ; * 3/4 (rounded up)
        CMP     R0, R3                  ; does PageModeLineCount exceed this ?
        BCC     Page50                  ; yes, then wait until SHIFT up
IncLinesExit
        ADD     R3, R3, #1
        STROSB  R3, PageModeLineCount, R0
 ]
        Pull    PC

Page50                                  ; NB C=0 on entry from above
        BL      CtrlShiftTest
        BMI     Page55

; Waiting for shift

        BL      PostWrchCursor          ; put cursor back on for now
PageWaitLoop
        SEC
        BL      CtrlShiftTest
        BLPL    Page_ProcessCallbacksIdle
        BPL     PageWaitLoop
        BL      PreWrchCursor

Page55
        Pull    R14
ClearLines
        MOV     R0, #1                  ; fudge for MASTER compatibility
        STROSB  R0, PageModeLineCount, R1
        MOV     PC, R14

BotRowCheck
        TST     R6, #2
        LDREQ   R1, [WsPtr, #TWRCol]
        LDRNE   R1, [WsPtr, #TWLCol]
        TST     R6, #4
        LDREQ   R0, [WsPtr, #TWBRow]
        LDRNE   R0, [WsPtr, #TWTRow]
        TST     R6, #8
        EORNE   R0, R0, R1              ; swap R0, R1
        EORNE   R1, R0, R1
        EORNE   R0, R0, R1
        LDREQ   R2, [WsPtr, #CursorY]
        LDRNE   R2, [WsPtr, #CursorX]
        TEQ     R0, R2
        MOV     PC, R14

CtrlShiftTest ROUT
        BCC     %FT05
 [ {FALSE}
        Push    R14
        BL      LEDsOn
        Pull    R14
 ]
05      LDR     R0, =ZeroPage
        LDRB    R0, [R0, #ESC_Status]
        TST     R0, #&40                ; escape condition ?
        LDROSB  R0, KeyBdStatus         ; (preserves PSR)
        BEQ     %FT10                   ; [no escape]

        Push    R14
        BIC     R0, R0, #KBStat_ScrollLock ; escape, so cancel scroll lock
        STROSB  R0, KeyBdStatus, R14    ; and store back
        MOV     R0, #&20                ; pretend shift down, ctrl up
        MOVS    R0, R0, LSL #(32-6)     ; C=CTRL, N=SHIFT
        Pull    PC

10
        TST     R0, #&08                ; shift bit
        ORRNE   R0, R0, #&20            ; move it to bit below ctrl (bit 6)
        BICEQ   R0, R0, #&20
        TST     R0, #KBStat_ScrollLock  ; if scroll lock on
        ORRNE   R0, R0, #&60            ; then pretend ctrl and shift down
        MOVS    R0, R0, LSL #(32-6)     ; C=CTRL, N=SHIFT
        MOV     PC, R14

Page_ProcessCallbacks
        Entry
        ; See if there are any pending callbacks
        LDR     R0, =ZeroPage
        LDRB    R14, [R0, #CallBack_Flag]
        TST     R14, #CBack_VectorReq
        BLNE    process_callback_chain
        EXIT

Page_ProcessCallbacksIdle
        EntryS                          ; routine must preserve flags
        ; See if there are any pending callbacks
        LDR     R0, =ZeroPage
        LDRB    R14, [R0, #CallBack_Flag]
        TST     R14, #CBack_VectorReq
        BLNE    process_callback_chain
        ; Now they're dealt with, we have nothing else to do, so call Idle
        LDRB    R14, [r0, #PortableFlags]
        TST     R14, #PortableFeature_Idle
        SWINE   XPortable_Idle
        EXITS

; *****************************************************************************
;
;       SO - Page mode on
;
; in:   R6 = CursorFlags
;

SO
        LDR     R0, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
        STRB    R0, [R0, #OsbyteVars + :INDEX: PageModeLineCount]

        ORR     R6, R6, #PageMode
        STR     R6, [WsPtr, #CursorFlags]

        MOV     PC, R14

; *****************************************************************************
;
;       SI - Page mode off
;
; in:   R6 = CursorFlags
;

SI
        BIC     R6, R6, #PageMode
        STR     R6, [WsPtr, #CursorFlags]

        MOV     PC, R14

; *****************************************************************************
;
;       DoResetFont - Reset some or all of the soft font from the hard font
;
; in:   R1*32 = start character, R2 = number of pages to copy
;
;       NB no range checking is done on these numbers

DoResetFont     ROUT

        ADRL    R0, HardFont-32*8
        ADD     R3, WsPtr, #(Font-32*8)

        ADD     R0, R0, R1, LSL #8      ; start source
        ADD     R3, R3, R1, LSL #8      ; start dest
        ADD     R1, R0, R2, LSL #8      ; end source

10
        LDR     R2, [R0], #4
        STR     R2, [R3], #4
        TEQ     R0, R1
        BNE     %BT10

        MOV     PC, R14

; *****************************************************************************
;
;       DoReadFont - Read character font
;
; in:   R1 -> control block
;       [R1, #0] = character to read (2..5 => read ecf, 6=> read dotdash)
;
; out:  [R1, #1..8] = font for that character
;

DoReadFont
        LDRB    R0, [R1]
        CMP     R0, #32
        ADD     R0, WsPtr, R0, LSL #3
        ADDCS   R0, R0, #(Font-32*8)           ; R0 -> font
        ADDCC   R0, R0, #(Ecf1-2*8)
        LDMIA   R0, {R2,R3}

      [ NoARMv6 :LOR: NoUnaligned
        STRB    R2, [R1, #1]
        MOV     R2, R2, LSR #8
        STRB    R2, [R1, #2]
        MOV     R2, R2, LSR #8
        STRB    R2, [R1, #3]
        MOV     R2, R2, LSR #8
        STRB    R2, [R1, #4]

        STRB    R3, [R1, #5]
        MOV     R3, R3, LSR #8
        STRB    R3, [R1, #6]
        MOV     R3, R3, LSR #8
        STRB    R3, [R1, #7]
        MOV     R3, R3, LSR #8
        STRB    R3, [R1, #8]
      |
        ; Use unaligned store from ARMv6
        STR     R2, [R1], #4
        STR     R3, [R1]
      ]

        MOV     PC, R14

; *****************************************************************************
;
;       NAK - Disable VDU
;
; in:   R6 = CursorFlags
;

NAK
        ORR     R6, R6, #VduDisabled
        STR     R6, [WsPtr, #CursorFlags]
        MOV     PC, R14

; *****************************************************************************
;
;       STX - Turn printer on
;       ETX - Turn printer off
;
; in:   R0 = 2 or 3
;

STX
ETX

; insert code here to call UPTVEC or NETVEC
; (probably need to restore cursor while doing so in case of 'Not listening')

        LDR     R1, [WsPtr, #VduStatus]
        TEQ     R0, #2                          ; turning on ?
        ORREQ   R1, R1, #Vdu2Mode               ; yes, then set bit
        BICNE   R1, R1, #Vdu2Mode               ; no, then clear bit
        STR     R1, [WsPtr, #VduStatus]
        MOVEQ   PC, R14                         ; exit if not turning off

        Push    R14
        MOV     R0, #&7B                        ; make printer dormant
        SWI     XOS_Byte
        Pull    PC, VC

; bad exit from the OSBYTE

        Pull    R14
        B       VduBadExit

; *****************************************************************************
;
;       BEL - Do VDU 7
;
; in:   BELLchannel, BELLinfo, BELLfreq, BELLdur contain info for bell
;       BELLinfo:       Bits 0,1        S bits
;                       Bit  2          H bit
;                       Bits 3-6        (envelope-1) OR (volume+15)
;                       Bit  7          0 => envelope, 1 => volume
;
; out:  SOUND &HFSC, A, P, D
;

BEL     ROUT
        Push    R14
        BYTEWS  R0
        ADD     R1, WsPtr, #(BeepBlock :AND: &FF)
        ADD     R1, R1, #(BeepBlock :AND: &FF00)

        MOV     R2, #0
        STRB    R2, [R1, #5]                    ; zero hi-byte of pitch
        STRB    R2, [R1, #7]                    ; zero hi-byte of duration

        LDRB    R2, [R0, #:INDEX: BELLchannel]  ; copy channel
        STRB    R2, [R1, #0]                    ; into OSWORD block

        LDRB    R2, [R0, #:INDEX: BELLinfo]     ; get info
        AND     R3, R2, #7                      ; bit 2 of R3 is H, bits 0,1=S
        TST     R3, #4
        EORNE   R3, R3, #(4 :EOR: &10)          ; put H into bit 4
        STRB    R3, [R1, #1]                    ; store H and S

        MOV     R2, R2, LSL #24
        MOV     R2, R2, ASR #(24+3)             ; shift down, sign extending
        ADD     R2, R2, #1
        STRB    R2, [R1, #2]                    ; store lo-byte of env/vol
        MOV     R2, R2, LSR #8
        STRB    R2, [R1, #3]                    ; store hi-byte of env/vol

        LDRB    R2, [R0, #:INDEX: BELLfreq]
        STRB    R2, [R1, #4]                    ; copy pitch

        LDRB    R2, [R0, #:INDEX: BELLdur]
        STRB    R2, [R1, #6]                    ; copy duration

        MOV     R0, #7                          ; OSWORD SOUND
        SWI     XOS_Word
        Pull    PC

; *****************************************************************************

; Compile the text fg / bg (and tint info if required) into a sensible set of
; colour words.

; The routines take the TextFg and TextBg colours, if NColour >= 63 then
; we attempt to combine the tint information, this is then passed onto
; ColourTrans to force the colour change.

; in    -
; out   [TextFgColour] / [TextBgColour] updated to contain new values

; amg: 30/11/93 split these into separate routines to sort out a problem.
; When OS_SetColour was being used for text colours in >=8bpp TForeCol/TBackCol
; and TForeTint/TBackTint went out of step. Thus when a VDU 17 or VDU 23,17,0 | 1
; came along both fore and back text colours were getting changed. This solution
; is not perfect, since doing a TINT command before a colour change will still
; go wrong but I consider that worth leaving against the alternative of changing
; the function of this area of the code by having some magic value.

CompileTextBg ROUT

        Entry   "R0-R1"

        LDR     R1, [WsPtr, #NColour]
        CMP     R1, #63                         ; is this a daft mode?

        LDR     R0, [WsPtr, #TBackCol]
        LDRCS   LR, [WsPtr, #TBTint]
        ANDCS   LR, LR, #&C0                    ; only look at 2 bits of tint
        ORRCS   R0, R0, LR                      ; combine tint value to bg colour
        BLCS    ConvertGCOLToColourNumber
        STRVC   R0, [WsPtr, #TextBgColour]

        EXIT

CompileTextFg   ROUT

        Entry   "R0-R1"

        LDR     R1, [WsPtr, #NColour]
        CMP     R1, #63                         ; is this a daft mode?

        LDR     R0, [WsPtr, #TForeCol]
        LDRCS   LR, [WsPtr, #TFTint]
        ANDCS   LR, LR, #&C0                    ; only look at 2 bits of tint
        ORRCS   R0, R0, LR                      ; combine in the tint value
        BLCS    ConvertGCOLToColourNumber       ; convert colour using ColourTrans
        STRVC   R0, [WsPtr, #TextFgColour]      ;   store the value away - assume it worked!?!@@?

        EXIT


; *****************************************************************************
;
; Convert a GCOL including Tint information to a physical colour, returning
; the colour number.  This is used for backwards compatibility with the
; existing 8 bit interfaces providided within the kernel.
;
; in    R0 = GCOL ( + tint ) := t t b b g g r r
; out   R0 = colour number (at current depth)
;       V set if no ColourTrans module.

; don't call CTrans if in 8bpp since otherwise GCOL numbers vary with
; palette changes!

ConvertGCOLToColourNumber ROUT

        EntryS  "R1-R2"

        LDR     R1, [WsPtr, #NColour]
        CMP     R1, #63
        CMPNE   R1, #255
        BEQ     %FT20

        AND     LR, R0, #4_3000                 ; extract the tint information
        MOV     R0, R0, LSL #14                 ; convert to a sensible bit location
        AND     R2, R0, #4_0003 :SHL: 14        ; extract the red
        ORR     R2, R2, LR, LSL #6              ; and then combine the tint information
        AND     R1, R0, #4_0030 :SHL: 14        ; extract the green
        ORR     R2, R2, R1, LSL #6
        ORR     R2, R2, LR, LSL #14             ; and combine with tint and green
        AND     R1, R0, #4_0300 :SHL: 14        ; finally extract the blue component
        ORR     R2, R2, R1, LSL #12
        ORR     R2, R2, LR, LSL #22             ; combine in the tint and blue
        ORR     R0, R2, R2, LSR #4              ; ensure physcial colour yields pure-white!

        SWI     XColourTrans_ReturnColourNumber

        EXITS
20
        MOV     r1, r0, LSR #6                  ; r1 =   0  0  0  0  0  0 T1 T0
        AND     r2, r0, #2_00100001             ; r2 =   0  0 B3  0  0  0  0 R2
        ORR     r1, r1, r2, LSL #2              ; r1 =  B3  0  0  0  0 R2 T1 T0
        AND     r2, r0, #2_00010000             ; r2 =   0  0  0 B2  0  0  0  0
        ORR     r1, r1, r2, LSR #1              ; r1 =  B3  0  0  0 B2 R2 T1 T0
        AND     r2, r0, #2_00001110             ; r2 =   0  0  0  0 G3 G2 R3  0
        ORR     r0, r1, r2, LSL #3              ; r0 =  B3 G3 G2 R3 B2 R2 T1 T0
        EXITS

        LTORG

        END
@


4.8
log
@Add support for custom teletext modes
Detail:
  This set of changes:
  * Adds support for the T, TX and TY mode string elements (as per RISCOS Ltd)
  * Adds support for entering arbitrary-resolution teletext modes by using mode selector blocks with the Teletext mode flag set
  * ScrRCol and ScrBRow mode variables can be provided in the mode selector in order to restrict the number of text rows/columns in teletext modes (as per RISCOS Ltd)
  * If the rows / columns are restricted in this manner then the text window will be centered on the screen, to try and avoid things looking too ugly (no variable text scaling implemented)
  * For HiResTTX, all colour depths >= 4bpp are now supported by teletext. This essentially makes the TTX256 switch obsolete.
  * If the "native" mode 7 is unavailable then the kernel will try a series of fallback resolutions & colour depths in an effort to find a combination that works
  Known bugs/issues:
  * Teletext column count has a max limit of 255 due to TTXDoubleCounts being a byte array
  * If there's a border around the text window, the border will not be refreshed when changing transparency modes using a VDU 23,18,0 sequence
  * ScreenLoad looks like it can overflow the LargeCommon buffer (no buffer size check) - needs fixing before LargeCommon can be safely shrunk below (Old)TTXMapSize
  File changes:
  - hdr/KernelWS - Make CharWidth non-conditional. Adjust handling of teletext workspace; it's now allocated from the system heap to allow it to cope with arbitrary screen sizes
  - s/vdu/vdu23 - Make CharWidth non-conditional
  - s/vdu/vducursoft - Make CursorTeletext cope with arbitrary colour depths, make CharWidth non-conditional, remove hard-coded teletext values
  - s/vdu/vdudriver - Deal with teletext workspace allocation during ModeChangeSub. Deal with selecting teletext modes (and validating colour depth) in GenerateModeSelectorVars.
  - s/vdu/vdugrafl - Make CharWidth non-conditional. Calculate offset required for text window centering.
  - s/vdu/vdumodes - Remove TTX256
  - s/vdu/vduswis - Try other teletext modes if native mode 7 not available. Extend OS_ScreenMode reason codes to cope with teletext mode strings.
  - s/vdu/vduttx - Update to use dynamic workspace. Replace various hardcoded values with variable lookups. Update character plotting + colour/palette selection to work with true-colour modes if HiResTTX.
  - s/vdu/vduwrch - Move some useful code into a subroutine. Update FastCLS to cope with true-colour teletext. Update AddressR0R1 to cope with text window centering offset. Make CharWidth non-conditional.
Admin:
  Tested on Raspberry Pi, BB-xM
  VDU 23,18,0 in 256-colour teletext now works correctly (previously 64-colour mode was in use, causing palette update to be ruined by VIDC1-mangling)


Version 5.74. Tagged as 'Kernel-5_74'
@
text
@d422 10
@


4.7
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d172 2
a173 18
        MOV     r14, fore
        MOV     fore, #-1
        CMP     r14, #-1                ; 32bpp?
        BIC     fore, fore, #&FF000000
        MOVEQ   back, #&FF000000        ; top byte is alpha/supremacy
        TEQNE   r14, fore               ; 24bpp packed?
        BEQ     %FT09
        BIC     fore, fore, #&FF0000
        TEQ     r14, fore, LSR #4       ; 4k?
        MOVEQ   fore, fore, LSR #4
        MOVEQ   back, #&F000
        BEQ     %FT09
        ; Not 32bpp, 24bpp or 4k, so must be 32k or 64k
        TST     R8, #ModeFlag_64k
        BICEQ   fore, fore, #&8000      ; is 32k
        MOVEQ   back, #&8000
09
        ; Arrive here with fore = foreground, back = alpha/supremacy mask
d240 34
a383 1
        LDREQ   R0, [WsPtr, #TextBgColour]
d387 3
a389 1
        MOV     R0, #0                          ; and clear to zero
d396 1
d421 1
a422 1
15
d491 4
d496 1
a496 8
        LDR     R3, [WsPtr, #Log2BPC]
      [ HiResTTX
        LDR     R2, [WsPtr, #ModeFlags]
        TST     R2, #ModeFlag_Teletext
        ADDNE   R3, R3, #1
      ]
        LDR     R2, [WsPtr, #ScreenStart] ; start address of top of screen
        ADD     R2, R2, R0, LSL R3        ; add in X offset
a1178 1
      [ HiResTTX
a1179 3
      |
        LDR     R3, [WsPtr, #BytesPerChar]
      ]
a1220 1
      [ HiResTTX
a1221 3
      |
        LDR     R3, [WsPtr, #BytesPerChar]
      ]
d1652 2
a1653 2
        LDR     R6, [WsPtr, #Log2BPC]           ; should be log2 bytes/char
        MOV     R5, R5, LSL R6                  ; number of bytes horiz
d1700 1
a1700 1
      [ HiResTTX
a1706 4
      |
        LDR     R6, [WsPtr, #Log2BPC]           ; should be log2 bytes/char
        LDR     R7, [WsPtr, #Log2BPP]           ; should be log2 bits/pixel
        ADD     R6, R6, #3
a1707 3
        MOV     R0, R0, LSL R6                  ; number of bits horiz
        MOV     R5, R5, LSL R6
      ]
d1713 1
a1713 7
        LDR     R6, [WsPtr, #ModeFlags]

        MOV     R7, #8                          ; 8 pixels high
        TST     R6, #ModeFlag_GapMode           ; if gap mode
        MOVNE   R7, #10                         ; then 10 pixels high
        TST     R6, #ModeFlag_DoubleVertical    ; if double mode
        ADDNE   R7, R7, R7                      ; then double
d2590 2
a2591 2
        LDR     R1, [WsPtr, #Log2BPC]
        CMP     R1, #1
d2594 1
a2594 1
        CMP     R1, #3
d2598 1
a2598 1
        CMP     R1, #4
d2903 1
a2903 1
        ADRL    R1, TTXLineStarts
@


4.6
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a3110 1
      [ StorkPowerSave
a3113 1
      ]
@


4.5
log
@  Added compile-time support for full-resolution teletext characters in
  teletext emulation mode (MODE 7) for that authentic BBC Micro feel.
  Also introduced a few useful teletext control features via VDU 23,18.
  Unrelatedly, fixed *ScreenLoad to work for interlaced displays.

Detail:
  The new typeface is designed on a 16x20 grid (previously we had used 8x10),
  so it uses a screen resolution of 640x500 pixels (rather than 320x250).
  Since we have been unable to source a genuine teletext font, and since
  examination of a BBC Micro suggests that the genuine font may not have been
  a power-of-2 pixels wide, I have designed one specially, based upon the one
  supplied in Zap distributions (a 12x20 font). Rather than increase the
  amount of workspace that the kernel requires for cacheing graphic
  characters, it now generates them on the fly, as they are required; this
  should only add about 25% to their rendering time.

  The new VDU 23 sequences are as follows:

  VDU 23,18,0,mode,0,0,0,0,0,0
    Switch transparency mode
      mode = 0: "Text" mode: the whole display is set opaque
      mode = 1: "Mix" mode: foreground colours, and both foreground and
        background of boxed text are opaque; non-boxed background colours are
        all transparent
      mode = 2: "Box" mode: boxed regions are opaque, others are transparent
      mode = 3: "TV" mode: the whole display is set transparent
    Default is mode = 0.

  VDU 23,18,1,suspend,0,0,0,0,0,0
    Suspend or resume bitmap updates
    This call allows an application to request that the kernel suspends
    updates to the framebuffer bitmap. This allows for a significant speed
    increase in the rendering time for a large amount of text, for example
    when redrawing a complete teletext page, because each time you plot a
    single character, it can cause the whole of the rest of the line to be
    re-rendered. When you switch out of suspend mode, the whole screen is
    refreshed in a single pass. Note that the appearance of the display is
    undefined is you cause a hardware scroll while in suspend mode.
      suspend = 0: screen update is enabled
      suspend = 1: screen update is suspended
    Default is suspend = 0.

  VDU 23,18,2,reveal,0,0,0,0,0,0
    Reveal/conceal
      reveal = 0: characters between the Conceal control code and the next
        colour control code are replaced by spaces
      reveal = 1: all characters are displayed
    Default is reveal = 0.

  VDU 23,18,3,black_emable,0,0,0,0,0,0
    Enable/disable black foreground colour control codes
      black_enable = 0: control codes &80 and &90 do nothing
      black_enable = 1: control code &80 selects black text, control code
        &90 selects black graphics
    Default is black_enable = 0.

  I have performed some timing tests on the rendering of complete teletext
  pages grabbed from the teletext server. These show that the new code
  generally imposes a 2x speed hit. However, when using the VDU 23,18,1
  suspend function, this improves to a 20% speed increase when compared to
  the old low-resolution code. Better still, because the framebuffer is only
  being updated for the final stage of this process, the screen *appears* to
  be updated some 3x faster than with the old code!

  A comment on the VDU variable Log2BPC is in order: in previous kernels,
  this was able unambiguously to refer to both the framebuffer width of a
  character in bytes, and the framebuffer width of an "addressable pixel" in
  bits; this no longer works with the 16-pixel wide teletext font. Bearing
  in mind that future kernels may support Unicode system fonts where the
  width varies from character to character, I have chosen to fix Log2BPC to
  the "addressable pixel" definition.

Admin:
  Requires HdrSrc 0.89 and (for non-desktop builds) Interlace 0.61. A monitor
  definition file containing a definition for a 640x500 screen mode is also
  required; version 0.40 of ModeFiles contains a suitable mode for STB-400.

  Tested fairly rigourously on an Ursula build, a Lazarus build and an
  STB-400 build, using genuine teletext pages and Yellow River Kingdom.

Version 5.30. Tagged as 'Kernel-5_30'
@
text
@d116 1
a116 1
        TST     R0, #Flag_Teletext              ; not teletext, then restore
d142 2
a143 2
        MOV     R0, #0                          ; foreground action := store
        MOV     R1, #0                          ; background action := store
d147 1
a147 1
        MOV     R3, #0                          ; background colour := black
d156 1
a156 1
        BL      SetColour                       ; Update FgEcf & BgEcf
d159 8
a166 12
        LDR     fore, [WsPtr, #NColour]         ; Number of colours allowed -1
        TEQ     fore, #63                       ; are we in bodgy 256 colour mode?
        MOVEQ   fore, #255                      ; then use colour 255 (cringe!)
        TEQ     fore, #15                       ; 16 colour mode
        MOVEQ   fore, #7                        ; Default is 7 for this depth of mode

 [ {TRUE} ; TMD 25-Jun-93 - change default text colour in 16bpp to &7FFF, and 32bpp to &00FFFFFF
        LDR     r14, =&FFFF
        CMP     fore, r14
        BICEQ   fore, fore, #&8000              ;     &FFFF     ->      &7FFF
        BICHI   fore, fore, #&FF000000          ; &FFFFFFFF     ->  &00FFFFFF
 ]
d168 28
d205 4
a208 2
        MOV     R8, back, ROR bpp               ; move bits to top of word
        MOV     R9, fore, ROR bpp
d211 2
d224 1
a234 1
      [ VIDC_Type = "VIDC20"
a236 1
      ]
a238 1
      [ VIDC_Type = "VIDC20"
a239 3
      |
        ADD     loaddr, WsPtr, #TextExpand
      ]
d243 1
a243 1
10
d249 1
a249 1
        BNE     %BT10
d256 1
a256 1
;       Colour16Bit - Set up colour table for MODE 10
a260 1
      [ VIDC_Type = "VIDC20"
d262 1
a262 3
      |
        ADD     tabaddr, WsPtr, #TextExpandArea
      ]
a308 2
      [ VIDC_Type = "VIDC20"

d311 1
a311 1
;       Colour32Bit - Set up colour table for MODE 48 (32 bit per pixel)
d320 1
a320 1
; Expand the value in in 'hiaddr' so that each bit is stored as a word
a355 2
      ]

d371 1
d373 30
d426 1
a426 1
        STMCSIA R8!, {R0}
d475 1
a475 1
        TST     R2, #Flag_Teletext
a516 1
      [ VIDC_Type = "VIDC20"
a517 3
      |
        ADDEQ   bigfont, WsPtr, #TextExpand
      ]
d653 2
a654 2
        AND     R0, R0, #(Flag_GapMode :OR: Flag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #Flag_GapMode           ; (gapmode AND NOT bbcgapmode)
d738 2
a739 2
        AND     R0, R0, #(Flag_GapMode :OR: Flag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #Flag_GapMode           ; (gapmode AND NOT bbcgapmode)
d884 2
a885 2
        AND     R0, R0, #(Flag_GapMode :OR: Flag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #Flag_GapMode           ; (gapmode AND NOT bbcgapmode)
d897 2
a898 2
        AND     R0, R0, #(Flag_GapMode :OR: Flag_BBCGapMode) ; we want R0=0 iff
        EOR     R0, R0, #Flag_GapMode           ; (gapmode AND NOT bbcgapmode)
d991 2
a992 2
        AND     R0, R0, #(Flag_GapMode :OR: Flag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #Flag_GapMode           ; (gapmode AND NOT bbcgapmode)
d1071 2
a1072 2
        AND     R0, R0, #(Flag_GapMode :OR: Flag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #Flag_GapMode           ; (gapmode AND NOT bbcgapmode)
d1176 1
a1176 1
        MOV     R0, #0
d1277 1
a1277 1
        MOV     R0, #0
d1488 1
a1498 1
        STR     R0, [WsPtr, #DisplayScreenStart]
d1500 1
d1511 1
a1511 1
        TST     R0, #Flag_BBCGapMode            ; if not BBC gap mode
d1550 1
a1550 1
        TST     R1, #Flag_BBCGapMode    ; is it a BBC gap mode ?
d1652 1
a1652 1
        TST     R7, #Flag_GapMode               ; if gap mode
d1654 1
a1654 1
        TST     R7, #Flag_DoubleVertical        ; if double mode
d1662 67
d1791 1
a1791 1
        TST     R1, #Flag_HardScrollDisabled
d1794 1
d1797 1
d1801 1
a1801 1
        CMP     R0, #ScreenEndAdr
d1803 2
a1804 1
        STR     R0, [WsPtr, #DisplayScreenStart]
d1809 1
a1809 1
        CMP     R0, #ScreenEndAdr
a1811 1
        Push    R14
d1830 5
d1854 3
d1931 88
d2028 1
a2028 1
        TST     R1, #Flag_HardScrollDisabled
d2031 1
d2034 1
d2039 1
a2039 1
        CMP     R3, #ScreenEndAdr               ; if < then need wrap
d2041 2
a2042 1
        STR     R0, [WsPtr, #DisplayScreenStart]
d2048 1
a2048 1
        CMP     R3, #ScreenEndAdr
a2050 1
        Push    R14
d2069 5
d2098 3
d2183 3
a2185 3
;       SetVinit  - Program Vinit  with address in R0
;       SetVstart - Program Vstart --------""--------
;       SetVend   - Program Vend   --------""--------
d2190 11
d2202 8
a2209 6
        MOV     R1, #MEMCDAG_VStart
SetLag
        SUB     R0, R0, #ScreenEndAdr
        LDR     R2, [WsPtr, #TotalScreenSize]
        ADD     R0, R0, R2                      ; make startofscreen 0
        B       SetDAGOffset                    ; call generic interface
d2212 25
a2236 14
 [ MEMC_Type = "IOMD"
        MOV     R0, #0
        LDR     R0, [R0, #VRAMWidth]
        CMP     R0, #1
        MOVCC   R0, #16                         ; DRAM-only, subtract 16
        MOVEQ   R0, #SAMLength/2                ; 1 bank of VRAM - 1/2 SAM
        MOVHI   R0, #SAMLength                  ; 2 banks of VRAM - 1/2 SAM * 2
        RSB     R0, R0, #ScreenEndAdr
 |
        MOV     R0, #ScreenEndAdr
        SUB     R0, R0, #16
 ]
        MOV     R1, #MEMCDAG_VEnd
        B       SetLag
d2239 19
a2257 18
        STR     R0, [WsPtr, #DisplayStart]
        SUB     R0, R0, #ScreenEndAdr
        LDR     R2, [WsPtr, #TotalScreenSize]
        ADD     R0, R0, R2                      ; make start of screen 0
        LDR     R1, [WsPtr, #TeletextOffset]
        ADD     R0, R0, R1                      ; add on teletext bank offset
        CMP     R0, R2                          ; if out of range
        SUBCS   R0, R0, R2                      ; then subtract total size
SetVinitPhys
        STR     R0, [WsPtr, #VinitCopy]
        MOV     R1, #MEMCDAG_VInit
SetDAGOffset
 [ MEMC_Type = "IOMD"
        MOV     R2, #0
        LDR     R2, [R2, #VideoPhysAddr]        ; add on physical address of start of video RAM
        ADD     R0, R0, R2
 ]
        B       SetDAG                          ; call generic interface
d2273 2
a2274 1
        RSB     R3, R3, #ScreenEndAdr           ; R3 := start of all screen mem
a2307 1
      [ VIDC_Type = "VIDC20"
a2308 3
      |
        ADD     bigfont, WsPtr, #TextExpand
      ]
a2377 6

; *****Change made by DJS
; Original code was:
;        MOV     R1, R1, LSL bpp         ; first form mask for leftmost pixel
;        SUB     R1, R1, #1              ; = (2^BytesPerChar)-1

a2380 2
; *****End of change made by DJS

d2396 1
a2396 1
        MOVGT   PC, R14     ; nothing to do on a mode change in this mode
a2398 1
      [ VIDC_Type = "VIDC20"
a2399 3
      |
        ADD     tabaddr, WsPtr, #TextExpand
      ]
d2591 1
a2591 1
        TST     R1, #Flag_DoubleVertical
d2601 1
a2601 1
      [ VIDC_Type = "VIDC20"
a2654 2
      ]

d2972 3
d3004 2
d3025 1
d3066 7
a3072 1
        MOV     R0, #0
d3097 1
a3097 1
        MOV     R0, #0
d3106 1
a3106 1
        MOV     R0, #0
d3112 1
a3112 1
        LDR     R14, [r0, #PortableFlags]
d3126 2
a3127 1
        MOV     R0, #0
d3191 1
d3207 5
d3392 1
a3392 1
        ORR     R0, R2, R2, LSR #4              ; ensure physcial colour yeilds pure-white!
@


4.5.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d1982 1
a1982 1
        LDRB    R0, [R0, #VRAMWidth]
d1984 1
a1984 1
        MOVLO   R0, #16                         ; DRAM-only, subtract 16
@


4.5.2.2
log
@further kernel/HAL split work in video area
almost-HAL code for VIDC20/IOMD in vdu.vduhint, now almost divorced
from kernel workspace
tested briefly in Ursula desktop environment

Version 5.35, 4.79.2.4. Tagged as 'Kernel-5_35-4_79_2_4'
@
text
@d1964 3
a1966 3
;       SetVinit       - Program Vinit with address in R0
;       SetVstart      - Program Vstart with address in R0
;       SetVendDefault - Program Vend with end address for TotalScreenSize
a1970 11
; mjs Oct 2000 kernel/HAL split
; these routines now call HAL_Video_SetDAG

; Note that the addresses provided are logical addresses for the software mapping
; of the display, and this starts at (ScreenEndAdr - TotalScreenSize) for
; wonderful historical reasons (h/w scroll, two mappings, blah, blah) - see eg. PRM 1-354
;
; To get physical address for the HAL, we subtract this software mapping start
; address and add the physical address of the start of video memory.
;

d1972 6
a1977 8
        SUB     r1, r0, #ScreenEndAdr
        LDR     r2, [WsPtr, #TotalScreenSize]
        ADD     r1, r1, r2                      ; now we have offset of Vstart in video RAM
        MOV     r2, #0
        LDR     r2, [r2, #VideoPhysAddr]
        ADD     r1, r1, r2                      ; now we have physical address of Vstart
        MOV     r0, #HALDAG_VStart
        B       Do_HALDAG
d1980 14
a1993 6
        MOV     r2, #0
        LDR     r2, [r2, #VideoPhysAddr]
        LDR     r1, [WsPtr, #TotalScreenSize]
        ADD     r1, r1, r2                      ; physical address of Vend
        MOV     r0, #HALDAG_VEnd
        B       Do_HALDAG
d1996 18
a2013 18
        STR     r0, [WsPtr, #DisplayStart]
        SUB     r1, r0, #ScreenEndAdr
        LDR     r2, [WsPtr, #TotalScreenSize]
        ADD     r1, r1, r2                      ; now we have offset of Vinit in video RAM
        LDR     r0, [WsPtr, #TeletextOffset]
        ADD     r1, r1, r0                      ; add on teletext bank offset
        CMP     r1, r2                          ; if out of range
        SUBCS   r1, r1, r2                      ; then subtract total size
        MOV     r2, #0
        LDR     r2, [r2, #VideoPhysAddr]        ; now we have physical address
        ADD     r1, r1, r2
        MOV     r0, #HALDAG_VInit
Do_HALDAG
        Push    "r3, r9, r12, lr"               ; we can corrupt r0-r2
        mjsAddressHAL 
        mjsCallHAL    HAL_Video_SetDAG
        Pull    "r3, r9, r12, lr"
        MOV     pc, lr
@


4.5.2.3
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d206 1
d209 1
d212 1
d214 3
d238 1
d240 3
a242 1

d289 2
d338 2
d470 1
d472 3
d2068 1
d2070 3
d2171 1
d2173 3
d2377 1
a2377 1

d2430 2
@


4.5.2.4
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a1665 1
        Push    R14
a1667 1
        LDR     R14, [WsPtr, #ScreenEndAddr]
d1671 1
a1671 1
        CMP     R0, R14
d1678 1
a1678 1
        CMP     R0, R14
d1681 1
a1804 1
        Push    R14
a1806 1
        LDR     R14, [WsPtr, #ScreenEndAddr]
d1811 1
a1811 1
        CMP     R3, R14                         ; if < then need wrap
d1819 1
a1819 1
        CMP     R3, R14
d1822 1
d1958 1
a1958 1
; of the display, and this starts at (ScreenEndAddr - TotalScreenSize) for
d1966 1
a1966 2
        LDR     r2, [WsPtr, #ScreenEndAddr]
        SUB     r1, r0, r2
d1985 1
a1985 2
        LDR     r2, [WsPtr, #ScreenEndAddr]
        SUB     r1, r0, r2
a1996 6
 [ UseGraphicsV
        Push    "r4, lr"
        MOV     r4, #GraphicsV_SetDMAAddress
        BL      CallGraphicsV
        Pull    "r4, pc"
 |
d1998 1
a1998 1
        mjsAddressHAL
d2000 2
a2001 2
        Pull    "r3, r9, r12, pc"
 ]
d2017 1
a2017 2
        LDR     R5, [WsPtr, #ScreenEndAddr]
        RSB     R3, R3, R5                      ; R3 := start of all screen mem
a2722 1
        BL      LEDsOff                 ; put LEDs back to normal
d2811 1
a2811 5
	BCC     %FT05
        Push    R14
        BL      LEDsOn
        Pull    R14
05      MOV     R0, #0
@


4.5.2.5
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@a342 29
 [ UseGraphicsV
        BL      CheckAcceleration
        BNE     %FT15
        MOV     R11, R13                        ; try to do an accelerated
        BIC     R13, R13, #63                   ; rectangle fill - need an
        MOV     R1, #&FFFFFFFF                  ; alignedOraEor block
        MVN     R2, R0
        MOV     R3, R1
        MOV     R4, R2
        Push    "R1-R4"
        Push    "R1-R4"
        Push    "R1-R4"
        Push    "R1-R4"
        MOV     R0, #0                          ; left
        LDR     R1, [WsPtr, #YWindLimit]        ; top
        LDR     R2, [WsPtr, #XWindLimit]        ; right (okay because checked BPC=BPP)
        MOV     R3, #0                          ; bottom
        MOV     R4, R13                         ; colour block
        Push    "R0-R4"
        MOV     R0, #GVRender_Sync
        MOV     R1, #GVRender_FillRectangle
        MOV     R2, R13
        MOV     R4, #GraphicsV_Render
        BL      CallGraphicsV
        MOV     R13, R11
        TEQ     R4, #GraphicsV_Complete
        Pull    PC, EQ
15
 ]
d1438 1
a1439 1
	BL      SetDisplayScreenStart
a1600 60
 [ UseGraphicsV
;
;       TextWindowToGraphics - current text window converted to graphics
;
;       TextBoxToGraphics - given text box converted to graphics coordinates
;
; in:   R0 = left
;       R1 = bottom
;       R2 = right
;       R3 = top
;
; out:  R0-R3 converted to internal graphics coordinates
;       R5 = number of pixels horizontally
;       R6 = number of pixel rows vertically
;       R7 = row height in pixels
;       R8 = number of character rows vertically

ScreenToGraphics
        MOV     R0, #0
        LDR     R1, [WsPtr, #ScrBRow]
        LDR     R2, [WsPtr, #ScrRCol]
        MOV     R3, #0
        B       TextBoxToGraphics

TextWindowToGraphics
        ADD     R0, WsPtr, #TWLCol              ; R0 := TWLCol; R1 := TWBRow
        LDMIA   R0, {R0-R3}                     ; R2 := TWRCol; R3 := TWTRow
TextBoxToGraphics
        SUB     R5, R2, R0
        ADD     R5, R5, #1                      ; number of chars horiz
        LDR     R6, [WsPtr, #Log2BPC]           ; should be log2 bytes/char
        LDR     R7, [WsPtr, #Log2BPP]           ; should be log2 bits/pixel
        ADD     R6, R6, #3

        MOV     R0, R0, LSL R6                  ; number of bits horiz
        MOV     R5, R5, LSL R6
        MOV     R0, R0, LSR R7                  ; number of pixels horiz
        MOV     R5, R5, LSR R7
        ADD     R2, R0, R5                      ; recalculate right coord
        SUB     R2, R2, #1

        LDR     R6, [WsPtr, #ModeFlags]

        MOV     R7, #8                          ; 8 pixels high
        TST     R6, #Flag_GapMode               ; if gap mode
        MOVNE   R7, #10                         ; then 10 pixels high
        TST     R6, #Flag_DoubleVertical        ; if double mode
        ADDNE   R7, R7, R7                      ; then double

        SUB     R8, R1, R3
        ADD     R8, R8, #1                      ; number of char rows vert
        MUL     R3, R7, R3                      ; convert top to pixels (from top)
        MUL     R6, R7, R8                      ; convert height to pixels
        LDR     R1, [WsPtr, #YWindLimit]
        SUB     R3, R1, R3                      ; Y-flip coordinate (bottom-left = 0,0)
        SUB     R1, R3, R6                      ; recalculate bottom coord
        ADD     R1, R1, #1

        MOV     PC, R14
 ]
d1675 1
a1675 2
        BL      SetDisplayScreenStart
        LDR     R14, [WsPtr, #ScreenEndAddr]
a1700 5
 [ UseGraphicsV
        BL      TryCopyScreenUp
        Pull    R14,EQ
        BEQ     ClearBottomScreenLine
 ]
a1719 5
 [ UseGraphicsV
        BL      TryCopyWindowUp
        Pull    R14, EQ
        BEQ     ClearBottomLine
 ]
a1791 48
 [ UseGraphicsV
; *****************************************************************************
;
;       TryCopyScreenUp - use GraphicsV to copy screen up
;
; in:   nothing
; out:  R0-R11 corrupted
;       Z flag set if successful

TryCopyScreenUp
        Push    R14
        BL      CheckAcceleration
        Pull    PC, NE                  ; return with Z clear (unsuccessful)
        BL      ScreenToGraphics
TryCopyUpCommon
        SUB     R4, R2, R0              ; width-1
        SUB     R5, R3, R1              ; height-1
        SUBS    R5, R5, R7              ; less one row
        Pull    PC,MI                   ; return with Z clear (unsuccessful)
        MOV     R2, R0                  ; dstL=srcL
        ADD     R3, R1, R7              ; dstB=srcB +1row
        Push    "R0-R5"
        MOV     R0, #3
        MOV     R1, #1
        MOV     R2, R13
        MOV     R4, #GraphicsV_Render
        BL      CallGraphicsV
        ADD     R13, R13, #6*4
        TEQ     R4, #GraphicsV_Complete
        Pull    PC

; .............................................................................
;
;       TryCopyWindowUp - use GraphicsV to copy window up
;
; in:   nothing
; out:  R0-R11 corrupted
;       Z flag set if successful

TryCopyWindowUp
        LDR     R0, [WsPtr, #VduSprite]
        TEQ     R0, #0                  ; don't try it if outputting to sprite
        MOVNE   PC, R14                 ; return with Z clear (unsuccessful)
        Push    R14
        ADR     R14, TryCopyUpCommon
        B       TextWindowToGraphics
 ]

d1816 1
a1816 2
        BL      SetDisplayScreenStart
        LDR     R14, [WsPtr, #ScreenEndAddr]
a1985 21
SetDisplayScreenStart
        Push    "r0-r2,lr"
        BL      SetVrender
        Pull    "r0-r2,pc"

SetVrender
        STR     r0, [WsPtr, #DisplayScreenStart]
        LDR     r2, [WsPtr, #ScreenEndAddr]
        SUB     r1, r0, r2
        LDR     r2, [WsPtr, #TotalScreenSize]
        ADD     r1, r1, r2                      ; now we have offset of Vrender in video RAM
        LDR     r0, [WsPtr, #TeletextOffset]
        ADD     r1, r1, r0                      ; add on teletext bank offset
        CMP     r1, r2                          ; if out of range
        SUBCS   r1, r1, r2                      ; then subtract total size
        MOV     r2, #0
        LDR     r2, [r2, #VideoPhysAddr]        ; now we have physical address
        ADD     r1, r1, r2
        MOV     r0, #HALDAG_VRender
        B       Do_HALDAG

a2733 1
 [ {FALSE}
a2734 1
 ]
a2823 1
 [ {FALSE}
a2826 1
 ]
d3140 1
a3140 1
        ORR     R0, R2, R2, LSR #4              ; ensure physcial colour yields pure-white!
@


4.5.2.6
log
@Added 256-colour version of the (high-resolution only) teletext code,
and support for teletext when hardware scroll is disabled. Both are required
for Tungsten.
Turned off the module init/final service calls, since we still don't have an
allocation for them.
Upped the OS version number to 5.01.

Version 5.35, 4.79.2.53. Tagged as 'Kernel-5_35-4_79_2_53'
@
text
@a341 3
 [ UseGraphicsV
        B       %FT15
 ]
d1619 1
a1659 8
      [ HiResTTX
        LDR     R6, [WsPtr, #CharWidth]         ; bytes/char (not log2)
        LDR     R7, [WsPtr, #Log2BPP]           ; log2 bits/pixel

        MUL     R0, R6, R0                      ; number of bytes horiz
        MUL     R5, R6, R5
        SUB     R7, R7, #3                      ; log2 bytes/pixel
      |
a1665 1
      ]
a1790 2
        TST     R6, #TeletextMode
        BNE     TTXSoftScrollUp
a1991 2
        TST     R6, #TeletextMode
        BNE     TTXSoftScrollDown
@


4.5.2.7
log
@Support for keys held down in the HAL at power on.
*Configure ANYTHINGsize was broken due to not setting R0 to ReadUnsigned
IIC ack message uninternationalised
OS_Memory was saying we only had 4M of RAM
VDU4 scrolling when output was switched to sprite was causing corruption
on use of CTRL-J and CTRL-K
Default SystemSize CMOS set to 32k

Version 5.35, 4.79.2.55. Tagged as 'Kernel-5_35-4_79_2_55'
@
text
@a1621 1
        MOV     R6, R8, LSL #3                  ; *8
d2317 6
d2325 2
@


4.5.2.8
log
@Huge update to L7200 HAL for Customer M 2 demo - now runs with 5.02 Kernel
used in Tungsten.
Added "fast" flash tool for Customer L, allowing ROMs to be sent serially at
115200 baud not 9600 baud.
Fix to VDU despatch for ARMv4 and later.
Fixes to power on delete keyboard and keyboard timeout
Implemented MemoryReadPhys and MemoryAmounts with the HAL.

Version 5.35, 4.79.2.59. Tagged as 'Kernel-5_35-4_79_2_59'
@
text
@a372 1
        LDR     R0, [WsPtr, #TextBgColour]
@


4.5.2.9
log
@Added code for hardware acceleration of "scroll down" function. Untested.

Version 5.35, 4.79.2.85. Tagged as 'Kernel-5_35-4_79_2_85'
@
text
@a1927 1
TryCopyCommon
a1952 39

; *****************************************************************************
;
;       TryCopyScreenDown - use GraphicsV to copy screen down
;
; in:   nothing
; out:  R0-R11 corrupted
;       Z flag set if successful

TryCopyScreenDown
        Push    R14
        BL      CheckAcceleration
        Pull    PC, NE                  ; return with Z clear (unsuccessful)
        BL      ScreenToGraphics
TryCopyDownCommon
        SUB     R4, R2, R0              ; width-1
        SUB     R5, R3, R1              ; height-1
        SUBS    R5, R5, R7              ; less one row
        Pull    PC,MI                   ; return with Z clear (unsuccessful)
        MOV     R2, R0                  ; dstL=srcL
        MOV     R3, R1                  ; dstB=bot
        ADD     R1, R1, R7              ; srcB=bot +1row
        B       TryCopyCommon

; .............................................................................
;
;       TryCopyWindowDown - use GraphicsV to copy window down
;
; in:   nothing
; out:  R0-R11 corrupted
;       Z flag set if successful

TryCopyWindowDown
        LDR     R0, [WsPtr, #VduSprite]
        TEQ     R0, #0                  ; don't try it if outputting to sprite
        MOVNE   PC, R14                 ; return with Z clear (unsuccessful)
        Push    R14
        ADR     R14, TryCopyDownCommon
        B       TextWindowToGraphics
a2008 5
 [ UseGraphicsV
        BL      TryCopyScreenDown
        Pull    R14, EQ
        BEQ     ClearTopLine
 ]
a2032 5
 [ UseGraphicsV
        BL      TryCopyWindowDown
        Pull    R14, EQ
        BEQ     ClearTopLine
 ]
@


4.5.2.10
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d399 1
a399 1
        STRCS   R0, [R8], #4
d1149 1
a1149 1
        LDR     R0, =ZeroPage
d1250 1
a1250 1
        LDR     R0, =ZeroPage
a1460 1
        ASSERT  (ZeroPage :AND: 255) = 0
d2188 1
a2188 1
        LDR     r2, =ZeroPage
d2195 1
a2195 1
        LDR     r2, =ZeroPage
d2217 1
a2217 1
        LDR     r2, =ZeroPage
d2233 1
a2233 1
        LDR     r2, =ZeroPage
a2994 2
; If we're using the debug terminal, never use paged mode, because serial input doesn't work too well when you need to detect shift being pressed!
 [ :LNOT: DebugTerminal
a3013 1
 ]
d3060 1
a3060 1
05      LDR     R0, =ZeroPage
d3085 1
a3085 1
        LDR     R0, =ZeroPage
d3094 1
a3094 1
        LDR     R0, =ZeroPage
d3100 1
a3100 1
        LDRB    R14, [r0, #PortableFlags]
d3114 1
a3114 2
        LDR     R0, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
a3177 1
      [ NoARMv6 :LOR: NoUnaligned
a3192 5
      |
        ; Use unaligned store from ARMv6
        STR     R2, [R1], #4
        STR     R3, [R1]
      ]
@


4.5.2.11
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d1473 1
a1473 1
        BL      SetDisplayScreenStart
d3058 1
a3058 1
        BCC     %FT05
@


4.5.2.12
log
@Make Mike's macros permanent.
While the HAL and kernel were being split some temporary macros were used for the bits being worked on, after 12 years of use they're probably safe to adopt.
mjsCallHAL -> CallHAL; mjsAddressHAL -> AddressHAL; mjsHAL -> HAL.
OS_VIDCDividerSWI code now always does NoSuchSWI (had been switched out previously).
File vduhint.s no longer assembled (was empty).


Version 5.35, 4.79.2.150. Tagged as 'Kernel-5_35-4_79_2_150'
@
text
@d2246 2
a2247 2
        AddressHAL
        CallHAL HAL_Video_SetDAG
@


4.5.2.13
log
@Make GraphicsV_IICOp more consistent
No accepts  r0 = b31-24 set 0
                 b23-16 fully qualified IIC address
                 b15-0  starting offset
            r1 = buffer pointer
            r2 = number of bytes to tranfer
            r4 = b31-24 display number
                 b23-16 head
                 b15-0  reason code (=14)
Now returns r0 = result codes as per HAL_IICTransfer()
            r1 = buffer pointer incremented by number of bytes transferred
            r2 = number of bytes *not* transferred
            r4 = 0
Removed '_' after Video in entry numbers to be consistent with other HAL entry naming, and HAL_VideoFlybackDevice.
Added IICStatus return numbers to Hdr:HALEntries.
Stop calling HAL_MonitorLeadID as only IOMD implemented it - just guess VGA until the graphics driver says otherwise.

Version 5.35, 4.79.2.159. Tagged as 'Kernel-5_35-4_79_2_159'
@
text
@d2174 1
a2174 1
; these routines now call HAL_VideoSetDAG
d2247 1
a2247 1
        CallHAL HAL_VideoSetDAG
@


4.5.2.14
log
@Merge with RPi branch
Detail:
  Merge the RPi branch with the HAL branch, ending RPi branch development
  Brief summary of changes brought in:
  * Added HAL_VideoStartupMode to allow the HAL to specify a startup mode for the OS
  * Fixed addresses being sent to GraphicsV_SetDMAAddress being wrong for external framestores (addresses were given as if internal framestore was in use)
  * Add InverseTextTransparency option for limited compile-time support for targets where framebuffer alpha channel is important
  * Fix ConfiguredLanguage for non-Tungsten builds
  * Update ARMv6 CPU detection to read cache parameters from cache type register instead of using KnownCPUTable
  * Add HALDebugHexTX/TX2/TX4 debug routines for writing out numbers via HAL
  * Use HAL_TimerIRQClear when clearing timer 0 interrupt instead of just HAL_IRQClear
  * Initialise FileLangCMOS using defines from Hdr:FSNumbers instead of magic numbers. Use SDFS on M_ARM11ZF.
  * Improved software mouse pointer support; software pointer now removed & restored in some of the same places the text cursor is
  * Improve support for external framestores; driver is now able to grow/shrink/move the framestore on mode changes if bit 5 of GraphicsV_DisplayFeatures R0 is set
  * GraphicsV_FramestoreAddress now has a default claimant which calls HAL_VideoFramestoreAddress
Admin:
  Tested on Raspberry Pi, Iyonix, OMAP3, IOMD


Version 5.35, 4.79.2.165. Tagged as 'Kernel-5_35-4_79_2_165'
@
text
@a167 4
 [ InverseTextTransparency     ; test to invert text transparency when transparency channel inverted
        ORREQ   fore, fore, #&8000              ;     &7FFF     ->      &FFFF
        ORRHI   fore, fore, #&FF000000          ; &00FFFFFF     ->  &FFFFFFFF
 |       
a170 1
 ]
d2189 2
a2190 1
        LDR     r2, [WsPtr, #TrueVideoPhysAddr]
d2196 2
a2197 1
        LDR     r2, [WsPtr, #TrueVideoPhysAddr]
d2218 2
a2219 1
        LDR     r2, [WsPtr, #TrueVideoPhysAddr] ; now we have physical address
d2234 2
a2235 1
        LDR     r2, [WsPtr, #TrueVideoPhysAddr] ; now we have physical address
@


4.5.2.15
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d116 1
a116 1
        TST     R0, #ModeFlag_Teletext          ; not teletext, then restore
d142 2
a143 2
        MOV     R0, #0                  ; foreground action := store
        MOV     R1, #0                  ; background action := store
d147 1
a147 1
        MOV     R3, #0                  ; background colour := black
d156 1
a156 1
        BL      SetColour               ; Update FgEcf & BgEcf
d159 17
a175 8
        LDR     fore, [WsPtr, #NColour] ; Number of colours allowed -1
        LDR     R8, [WsPtr, #ModeFlags]
        TEQ     fore, #63               ; are we in bodgy 256 colour mode?
        MOVEQ   fore, #255              ; then use colour 255 (cringe!)
        TEQ     fore, #15               ; 16 colour mode
        TSTEQ   R8, #ModeFlag_GreyscalePalette
        MOVEQ   fore, #7                ; Default is 7 for this depth of mode
        CMP     fore, #255
a176 28
        BLS     %FT10
        ; Deal with true colour modes
        ; Default foreground is white, background is black
        ; Alpha/supremacy is taken from mode flags
        MOV     r14, fore
        MOV     fore, #-1
        CMP     r14, #-1                ; 32bpp?
        BIC     fore, fore, #&FF000000
        MOVEQ   back, #&FF000000        ; top byte is alpha/supremacy
        TEQNE   r14, fore               ; 24bpp packed?
        BEQ     %FT09
        BIC     fore, fore, #&FF0000
        TEQ     r14, fore, LSR #4       ; 4k?
        MOVEQ   fore, fore, LSR #4
        MOVEQ   back, #&F000
        BEQ     %FT09
        ; Not 32bpp, 24bpp or 4k, so must be 32k or 64k
        TST     R8, #ModeFlag_64k
        BICEQ   fore, fore, #&8000      ; is 32k
        MOVEQ   back, #&8000
09
        ; Arrive here with fore = foreground, back = alpha/supremacy mask
        TST     R8, #ModeFlag_DataFormatSub_Alpha
        ORRNE   fore, fore, back        ; Is alpha blended mode, so set full alpha
        MOVEQ   back, #0                ; Transparency/supremacy mode, clear transfer channel
        

10
d186 2
a187 4
        CMP     bpp, #16

        MOVLS   R8, back, ROR bpp               ; move bits to top of word
        MOVLS   R9, fore, ROR bpp
a189 2

        BHI     %FT20                           ; can't fudge anything over 16bpp
a200 1
20
d219 1
a219 1
30
d225 1
a225 1
        BNE     %BT30
d232 1
a232 1
;       Colour16Bit - Set up colour table for 16 bits per pixel
d287 1
a287 1
;       Colour32Bit - Set up colour table for 32 bits per pixel
d296 1
a296 1
; Expand the value in 'dest' so that each bit is stored as a word
d453 1
a453 1
        TST     R2, #ModeFlag_Teletext
d631 2
a632 2
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
d716 2
a717 2
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
d862 2
a863 2
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
d875 2
a876 2
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EOR     R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
d969 2
a970 2
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
d1049 2
a1050 2
        AND     R0, R0, #(ModeFlag_GapMode :OR: ModeFlag_BBCGapMode) ; we want R0=0 iff
        EORS    R0, R0, #ModeFlag_GapMode       ; (gapmode AND NOT bbcgapmode)
d1489 1
a1489 1
        TST     R0, #ModeFlag_BBCGapMode        ; if not BBC gap mode
d1528 1
a1528 1
        TST     R1, #ModeFlag_BBCGapMode ; is it a BBC gap mode ?
d1630 1
a1630 1
        TST     R7, #ModeFlag_GapMode           ; if gap mode
d1632 1
a1632 1
        TST     R7, #ModeFlag_DoubleVertical    ; if double mode
d1693 1
a1693 1
        TST     R6, #ModeFlag_GapMode           ; if gap mode
d1695 1
a1695 1
        TST     R6, #ModeFlag_DoubleVertical    ; if double mode
d1771 1
a1771 1
        TST     R1, #ModeFlag_HardScrollDisabled
d2012 1
a2012 1
        TST     R1, #ModeFlag_HardScrollDisabled
d2179 1
a2179 1
; these routines now call GraphicsV_SetDMAAddress
d2389 1
a2389 1
        MOVGE   PC, R14     ; nothing to do on a mode change in this mode
d2584 1
a2584 1
        TST     R1, #ModeFlag_DoubleVertical
@


4.5.2.16
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d397 1
a397 3
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_Render
d1963 1
a1963 3
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_Render
d2220 2
a2221 2
        MOV     r0, #GVDAG_VStart
        B       Do_GVDAG
d2227 2
a2228 2
        MOV     r0, #GVDAG_VEnd
        B       Do_GVDAG
d2247 2
a2248 2
        MOV     r0, #GVDAG_VRender
        B       Do_GVDAG
d2262 3
a2264 2
        MOV     r0, #GVDAG_VInit
Do_GVDAG
d2266 1
a2266 3
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_SetDMAAddress
d2269 6
@


4.5.2.17
log
@Strip out some old build switches
Detail:
  hdr/Options, s/ArthurSWIs, s/ChangeDyn, s/PMF/KbdDrA1, s/PMF/key, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdugrafhal, s/vdu/vdugrafv, s/vdu/vdumodes, s/vdu/vduwrch:
  - Strip out DoingVdu build switch (did nothing)
  - Strip out Japanese16BitSound switch (did nothing)
  - Strip out MakeModeSelectorsForModeNUmbers switch (altered the mode list structures, but there wasn't any code to do anything with the new data)
  - Strip out remaining uses of UseGraphicsV switch (now hardwired to {TRUE})
  - Strip out ShadowROM switch (altered FixedAreasTable to show the shadow mapping, but code to create the mapping is missing)
  - Strip out PollMouse switch (old Archimedes-era debug/development option)
Admin:
  Tested on BB-xM
  Builds to same binary as previous version


Version 5.35, 4.79.2.204. Tagged as 'Kernel-5_35-4_79_2_204'
@
text
@d371 1
d373 1
d375 1
d406 1
d1666 1
d1734 1
d1838 1
d1842 1
d1862 1
d1866 1
d1939 1
d2027 1
d2083 1
d2087 1
d2112 1
d2116 1
@


4.5.2.18
log
@Use symbol for GraphicsV op
@
text
@d1951 2
a1952 2
        MOV     R0, #GVRender_Sync
        MOV     R1, #GVRender_CopyRectangle
@


4.5.2.11.2.1
log
@  Changes to resolve some of the BCM2835 initial hacks
  1: Added HAL_FramebufferAddress entry.
  2: Minor mod the NoIrqVecSwiDispatch mods recently submitted. Improved coverage
  3: Added compile time switch InverseTextTransparency to toggle sense of text
  (pre-wimp) for use until correct transparency behaviour is introduced in the RPi
  start.elf.
  4: Ensured that if a non aligned frame buffer is reported, ALL of the space
  is actually mapped in.
Detail:
  (list files and functions that have changed)
Admin:
  builds and runs .. Still needs service_mode extension work to replace hard
  coded mode definition files
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 5.35, 4.79.2.147.2.5. Tagged as 'Kernel-5_35-4_79_2_147_2_5'
@
text
@a167 4
 [ InverseTextTransparency     ; test to invert text transparency when transparency channel inverted
        ORREQ   fore, fore, #&8000              ;     &7FFF     ->      &FFFF
        ORRHI   fore, fore, #&FF000000          ; &00FFFFFF     ->  &FFFFFFFF
 |       
a170 1
 ]
@


4.5.2.11.2.2
log
@Fix addresses sent to GraphicsV_SetDMAAddress when external framestore in use. Add ID for BCM2835 VDU HAL device.
Detail:
  hdr/KernelWS, s/vdu/vdudriver, s/vdu/vduwrch - Fixed wrong addresses being sent to GraphicsV_SetDMAAddress when an external framestore is in use. Previously VideoPhysAddr was being treated as if it was the base of screen memory, but that's only the case if an internal framestore is in use. Since VideoPhysAddr is part of PhysRamTable it's not possible to change it to point to an external framestore, so a new workspace variable, TrueVideoPhysAddr, is used instead.
  hdr/HALDevice - Added device ID for BCM2835 VDU device
  s/PMF/IIC - Corrected an incorrect comment in IICDoOp
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.22. Tagged as 'Kernel-5_35-4_79_2_147_2_22'
@
text
@d2194 2
a2195 1
        LDR     r2, [WsPtr, #TrueVideoPhysAddr]
d2201 2
a2202 1
        LDR     r2, [WsPtr, #TrueVideoPhysAddr]
d2223 2
a2224 1
        LDR     r2, [WsPtr, #TrueVideoPhysAddr] ; now we have physical address
d2239 2
a2240 1
        LDR     r2, [WsPtr, #TrueVideoPhysAddr] ; now we have physical address
@


4.5.2.11.2.3
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d2179 1
a2179 1
; these routines now call HAL_VideoSetDAG
d2247 2
a2248 2
        AddressHAL
        CallHAL HAL_VideoSetDAG
@


4.5.2.9.2.1
log
@  Unaligned loads/stores optimised for ARMv6+
Detail:
  Having scanned the kernel source for unaligned load code fragments which
  would abort on ARMv6 and v7 and not having found any, I took the opportunity
  to give them build-time switches to use unaligned LDR((S)H)/STR(H)
  instructions if built for a new enough platform. Also added a couple of
  cases of LDRSB that will benefit v4 CPUs and a few instances of the v6
  SXTH instruction, but since objasm doesn't yet understand it (and when it
  does, not everyone will have upgraded) they are currently written as
  DCI statements.
  Most of the changes are to OS_Word handlers, which are notorious in that
  their input/output block is not word-aligned.
Admin:
  Not tested, but it should at least build.

Version 5.35, 4.79.2.98.2.6. Tagged as 'Kernel-5_35-4_79_2_98_2_6'
@
text
@a3177 1
      [ NoARMv6
a3192 5
      |
        ; Use unaligned store from ARMv6
        STR     R2, [R1], #4
        STR     R3, [R1]
      ]
@


4.5.2.9.2.2
log
@Disable paged scrolling when using the debug terminal
Detail:
  s/vdu/vduwrch - Modify PageTest to never use paged scrolling when DebugTerminal is true (since serial terminals aren't able to send shift up/down messages)
Admin:
  Tested on rev C2 beagleboard.


Version 5.35, 4.79.2.98.2.7. Tagged as 'Kernel-5_35-4_79_2_98_2_7'
@
text
@a2994 2
; If we're using the debug terminal, never use paged mode, because serial input doesn't work too well when you need to detect shift being pressed!
 [ :LNOT: DebugTerminal
a3013 1
 ]
@


4.5.2.9.2.3
log
@  Miscellaneous v6-related updates
Detail:
 * Stopped calling the broken abort fixup code when running under VMSAv6.
   Might be desirable to update it, possibly farmed out to a separate module -
   still need to think about this.
 * Unaligned load optimisations can now be disabled by the global NoUnaligned
   flag for testing purposes.
 * Extended OS_ReadUnsigned to permit reading of 64-bit unsigned integers.
   See Docs.ReadUnsigned for more details. Also sped it up by using MLA
   (or UMLAL) for most digits rather than repeated addition.
 * Bugfix is OS_GSRead: an uninitialised r0 was being passed to
   OS_ReadUnsigned, causing undesirable effects on rare occasions.
Admin:
  Tested on a rev B7 beagleboard.

Version 5.35, 4.79.2.98.2.8. Tagged as 'Kernel-5_35-4_79_2_98_2_8'
@
text
@d3181 1
a3181 1
      [ NoARMv6 :LOR: NoUnaligned
@


4.5.2.9.2.4
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  s.PMF.i2cutils line 454: this LDR of byte values was harmless (bits 8
    upwards are discarded later) but slower than an LDRB on ARMv6 or later.
  s.PMF.i2cutils line 556: should have loaded RTCFitted using LDRB. Looks
    like effect would have been to reduce utilisation of CMOS cache.
  s.vdu.vduswis line 1500: mistakenly accessing ExternalFramestore using LDR.
    I don't think the intention was to prevent the screen DA being resized
    while screen memory was claimed, but that was the effect.
  s.vdu.vduwrch line 3106: this LDR of a 1-byte variable was harmless (only
    used for testing bit 4) but slower than an LDRB on ARMv6 or later.
  CPU version is no longer specified in the makefile - it's better to inherit
  it from the build environment now that we actually set it appropriately.
Admin:
  Built and briefly tested.

Version 5.35, 4.79.2.98.2.9. Tagged as 'Kernel-5_35-4_79_2_98_2_9'
@
text
@d3103 1
a3103 1
        LDRB    R14, [r0, #PortableFlags]
@


4.5.2.9.2.5
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d1149 1
a1149 1
        LDR     R0, =ZeroPage
d1250 1
a1250 1
        LDR     R0, =ZeroPage
a1460 1
        ASSERT  (ZeroPage :AND: 255) = 0
d2188 1
a2188 1
        LDR     r2, =ZeroPage
d2195 1
a2195 1
        LDR     r2, =ZeroPage
d2217 1
a2217 1
        LDR     r2, =ZeroPage
d2233 1
a2233 1
        LDR     r2, =ZeroPage
d3063 1
a3063 1
05      LDR     R0, =ZeroPage
d3088 1
a3088 1
        LDR     R0, =ZeroPage
d3097 1
a3097 1
        LDR     R0, =ZeroPage
d3117 1
a3117 2
        LDR     R0, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
@


4.5.2.9.2.6
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d399 1
a399 1
        STRCS   R0, [R8], #4
@


4.4
log
@  Improvement to the new callback functionality from version 5.27.
Detail:
  In the previous version, Portable_Idle was called each time that the callback
  chain was examined. This is only desirable in cases where we're polling the
  keyboard, waiting before scrolling the text window; in the normal case, it's
  an unnecessary slow-down. Now fixed to only call Portable_Idle if we're
  waiting for a key up/down/timeout.
Admin:
  Not tested.

Version 5.28. Tagged as 'Kernel-5_28'
@
text
@d426 5
d857 1
d859 1
d1119 3
d1123 1
d1165 3
d1169 1
@


4.3
log
@  Callbacks can now go off when the text window scrolls (newline or line wrap).
  In particular, they can go off when Scroll Lock etc have frozen the text
  output.
Detail:
  The callback chain is examined at least once per line scroll. Additionally,
  it is examined repeatedly while Scroll Lock or Ctrl-Shift are acting, while
  idling between lines if Ctrl is held down, and while waiting for the Shift
  key to be pressed at the bottom of a screen when in page mode.
  The opportunity is also taken to call Portable_Idle after each time that the
  callback chain has been examined.
Admin:
  Not tested.

Version 5.27. Tagged as 'Kernel-5_27'
@
text
@d2727 1
a2727 1
        BLMI    Page_ProcessCallbacks
d2751 1
a2751 1
        BLCS    Page_ProcessCallbacks
d2790 1
a2790 1
        BLPL    Page_ProcessCallbacks
d2841 9
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d2712 2
d2727 1
d2751 1
d2790 1
d2839 15
@


4.1
log
@Initial revision
@
text
@d180 1
a180 1
                
d195 1
a195 1
       
d198 1
a198 1
 
d208 2
a209 2
        BEQ     Colour32Bit     ; cannie optimise captin!        
      ]                            
d288 1
a288 1
        
d290 1
a290 1
    
d299 1
a299 1
        MOV     dest, #0           
d304 1
a304 1
; foreground.  This is indexed when expanding the 1BPP VDU font out to 
d332 1
a332 1
        ADD     dest, dest, #1    
d334 1
a334 1
        BNE     C32B20                              
d1039 1
a1039 1
 
d1044 1
a1044 1
         
d1068 1
a1068 1
        
d1253 1
a1253 1
CR10                            ; entry point for releasing pending CRLF  
d1381 1
a1381 1
        
d1383 1
a1383 1
        
d1391 1
a1391 1
31        
d1394 1
a1394 1
        Push    "LR"                
d1568 1
a1568 1
;       R1 = bottom 
d2068 1
a2068 1
        
d2097 1
a2097 1
        
d2109 1
a2109 1
               
d2138 1
a2138 1
             
d2177 1
a2177 1
        ORR     dest, cbyte, dest, LSR #4 
d2220 1
a2220 1
        ORR     dest, cbyte, dest, LSR #8 
d2256 1
a2256 1
        ORR     dest, cbyte, dest, LSR #16 
d2360 1
a2360 1
      
d2371 1
a2371 1
                                   
d2377 2
a2378 2
                      
RdChr32Bit      
d2380 2
a2381 2
                                           
        BL      RdCh32Bit_GetData            
d2392 1
a2392 1
                     
d2408 3
a2410 3
        
        MOVS    PC,LR
        
d2412 1
a2412 1
                        
d3039 1
a3039 1
        Push    "R0-R1,LR"
d3043 1
a3043 1
                                      
d3051 1
a3051 1
        Pull    "R0-R1,PC",,^
d3055 1
a3055 1
        Push    "R0-R1,LR"
a3065 2
        
        Pull    "R0-R1,PC",,^
d3067 3
a3069 1
                                                                      
d3073 1
a3073 1
; the colour number.  This is used for backwards compatibility with the 
d3077 1
a3077 1
; out   R0 = colour number (at current depth) 
d3085 2
a3086 2
        Push    "R1-R2, LR"
        
d3088 1
a3088 1
        CMP     R1, #63              
d3094 1
a3094 1
        AND     R2, R0, #4_0003 :SHL: 14        ; extract the red             
d3100 1
a3100 1
        ORR     R2, R2, R1, LSL #12             
d3106 1
a3106 1
        Pull    "R1-R2, PC",,^
d3115 2
a3116 2
        Pull    "R1-R2, PC",,^
        
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d165 1
d170 1
d215 1
d241 1
d468 1
d603 9
d688 9
d939 11
d1019 13
d1974 2
d2051 1
d2069 42
d2154 1
@


4.1.4.2
log
@1) Fixes and tidy ups:
   - mapping of Cur/Sys/Sound area done more elegantly, and soft CAM info
     is now consistent with it
   - cached screen cleaning on VSync performed *after* VSync events
   - comments at top of ARM600 modernised
   - Pages_Unsafe/Safe code fixed to work properly on StrongARM with
     pages that are involved in interrupts (there is no fix for ARM8,
     since that is unlikely to be needed - an ASSERT checks use of ARM8
   - OS_DynamicArea code souped up, to be much more efficient for large
     numbers of dynamic areas (see comments near top of ChangeDyn)
   - cached screen is now suspended on h/w scroll (avoids possible cache
     incoherency)
2) API changes:
   - new OS_Memory reason code (10) allows Wimp to inform kernel of
     Wimp_ClaimFreeMemory, and can control VRAM rescue (see below)
   - new OS_ReadSysInfo reason code (6) allows reading of kernel values
     (reserved for Acorn use, eg. for SoftLoad, ROMPatch)
   - new OS_DynamicArea reason codes (6 and 7) allow for more efficient
     monitoring of dynamic areas by TaskManager (reserved for Acorn use)
3) Changes for Phoebe:
   - kernel runs a VRAM rescue process, which ensures that any VRAM not
     used for the screen is reclaimed if necessary and sinks to the bottom
     of the Free Pool. This is important for Phoebe, where VRAM is slower
     than SDRAM, but does no harm on other platforms.
   - logical copy of physical RAM is removed from memory map. This frees
     up 256M of address space that will later be used for PCI on Phoebe,
     but should do no harm on other platforms (this space is marked
     private in PRMs, so 3rd parties should not use it).
@
text
@a1620 9
        Push    R14

  [ ChocolateScreen
        MOV     R0,#4
        MOV     R1,#1           ;suspend-cached-screen bit
        MOV     R2,#-1          ;no change to VSync laziness
        BL      ScreenMode_ChocolateControl
  ]

d1636 1
a1759 9
        Push    R14

  [ ChocolateScreen
        MOV     R0,#4
        MOV     R1,#1           ;suspend-cached-screen bit
        MOV     R2,#-1          ;no change to VSync laziness
        BL      ScreenMode_ChocolateControl
  ]

d1777 1
@


4.1.4.2.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d204 1
d206 2
a207 1
        BEQ     Colour32Bit     ; cannie optimise captin!                                    
d210 1
d212 2
d235 1
d237 2
d285 2
d334 2
d461 1
d463 2
d1934 1
d1942 2
d1960 1
d1964 1
d2015 1
d2017 2
d2075 1
d2077 2
d2280 1
d2333 2
@


4.1.4.3
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d204 1
d206 2
a207 1
        BEQ     Colour32Bit     ; cannie optimise captin!                                    
d210 1
d212 2
d235 1
d237 2
d285 2
d334 2
d461 1
d463 2
d1934 1
d1942 2
d1960 1
d1964 1
d2015 1
d2017 2
d2075 1
d2077 2
d2280 1
d2333 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

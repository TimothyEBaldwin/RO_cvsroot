head	4.1;
access;
symbols
	Kernel-6_15:4.1
	Kernel-6_14:4.1
	Kernel-6_01-3:4.1
	Kernel-6_13:4.1
	Kernel-6_12:4.1
	Kernel-6_11:4.1
	Kernel-6_10:4.1
	Kernel-6_09:4.1
	Kernel-6_08-4_129_2_10:4.1
	Kernel-6_08-4_129_2_9:4.1
	Kernel-6_08:4.1
	Kernel-6_07:4.1
	Kernel-6_06:4.1
	Kernel-6_05-4_129_2_8:4.1
	Kernel-6_05:4.1
	Kernel-6_04:4.1
	Kernel-6_03:4.1
	Kernel-6_01-2:4.1
	Kernel-6_01-4_146_2_1:4.1
	Kernel-6_02:4.1
	Kernel-6_01-1:4.1
	Kernel-6_01:4.1
	Kernel-6_00:4.1
	Kernel-5_99:4.1
	Kernel-5_98:4.1
	Kernel-5_97-4_129_2_7:4.1
	Kernel-5_97:4.1
	Kernel-5_96:4.1
	Kernel-5_95:4.1
	Kernel-5_94:4.1
	Kernel-5_93:4.1
	Kernel-5_92:4.1
	Kernel-5_91:4.1
	Kernel-5_90:4.1
	Kernel-5_89-4_129_2_6:4.1
	Kernel-5_89:4.1
	Kernel-5_88-4_129_2_5:4.1
	Kernel-5_88-4_129_2_4:4.1
	Kernel-5_88:4.1
	Kernel-5_87:4.1
	Kernel-5_86-4_129_2_3:4.1
	Kernel-5_86-4_129_2_2:4.1
	Kernel-5_86-4_129_2_1:4.1
	Kernel-5_86:4.1
	SMP:4.1.0.2
	SMP_bp:4.1
	Kernel-5_85:4.1
	Kernel-5_54-1:4.1
	Kernel-5_84:4.1
	Kernel-5_83:4.1
	Kernel-5_82:4.1
	Kernel-5_81:4.1
	Kernel-5_80:4.1
	Kernel-5_79:4.1
	Kernel-5_78:4.1
	Kernel-5_77:4.1
	Kernel-5_76:4.1
	Kernel-5_75:4.1
	Kernel-5_74:4.1
	Kernel-5_73:4.1
	Kernel-5_72:4.1
	Kernel-5_71:4.1
	Kernel-5_70:4.1
	Kernel-5_69:4.1
	Kernel-5_68:4.1
	Kernel-5_67:4.1
	Kernel-5_66:4.1
	Kernel-5_65:4.1
	Kernel-5_64:4.1
	Kernel-5_63:4.1
	Kernel-5_62:4.1
	Kernel-5_61:4.1
	Kernel-5_60:4.1
	Kernel-5_59:4.1
	Kernel-5_58:4.1
	Kernel-5_57:4.1
	Kernel-5_56:4.1
	Kernel-5_55:4.1
	Kernel-5_54:4.1
	Kernel-5_53:4.1
	Kernel-5_52:4.1
	Kernel-5_51:4.1
	Kernel-5_50:4.1
	Kernel-5_49:4.1
	HAL_merge:1.1.2.4
	Kernel-5_48:4.1
	Kernel-5_35-4_79_2_327:1.1.2.4
	Kernel-5_35-4_79_2_326:1.1.2.4
	Kernel-5_35-4_79_2_325:1.1.2.4
	Kernel-5_35-4_79_2_324:1.1.2.4
	Kernel-5_35-4_79_2_323:1.1.2.4
	Kernel-5_35-4_79_2_322:1.1.2.4
	Kernel-5_35-4_79_2_321:1.1.2.4
	Kernel-5_35-4_79_2_320:1.1.2.4
	Kernel-5_35-4_79_2_319:1.1.2.4
	Kernel-5_35-4_79_2_318:1.1.2.4
	Kernel-5_35-4_79_2_317:1.1.2.4
	Kernel-5_35-4_79_2_316:1.1.2.4
	Kernel-5_35-4_79_2_315:1.1.2.4
	Kernel-5_35-4_79_2_314:1.1.2.4
	Kernel-5_35-4_79_2_313:1.1.2.4
	Kernel-5_35-4_79_2_312:1.1.2.4
	Kernel-5_35-4_79_2_311:1.1.2.4
	Kernel-5_35-4_79_2_310:1.1.2.4
	Kernel-5_35-4_79_2_309:1.1.2.4
	Kernel-5_35-4_79_2_308:1.1.2.4
	Kernel-5_35-4_79_2_307:1.1.2.4
	Kernel-5_35-4_79_2_306:1.1.2.4
	Kernel-5_35-4_79_2_305:1.1.2.4
	Kernel-5_35-4_79_2_304:1.1.2.4
	Kernel-5_35-4_79_2_303:1.1.2.4
	Kernel-5_35-4_79_2_302:1.1.2.4
	Kernel-5_35-4_79_2_301:1.1.2.4
	Kernel-5_35-4_79_2_300:1.1.2.4
	Kernel-5_35-4_79_2_299:1.1.2.4
	Kernel-5_35-4_79_2_298:1.1.2.4
	Kernel-5_35-4_79_2_297:1.1.2.4
	Kernel-5_35-4_79_2_296:1.1.2.4
	Kernel-5_35-4_79_2_295:1.1.2.4
	Kernel-5_35-4_79_2_294:1.1.2.4
	Kernel-5_35-4_79_2_293:1.1.2.4
	Kernel-5_35-4_79_2_292:1.1.2.4
	Kernel-5_35-4_79_2_291:1.1.2.4
	Kernel-5_35-4_79_2_290:1.1.2.4
	Kernel-5_35-4_79_2_289:1.1.2.4
	Kernel-5_35-4_79_2_288:1.1.2.4
	Kernel-5_35-4_79_2_287:1.1.2.4
	Kernel-5_35-4_79_2_286:1.1.2.4
	Kernel-5_35-4_79_2_285:1.1.2.4
	Kernel-5_35-4_79_2_284:1.1.2.4
	Kernel-5_35-4_79_2_283:1.1.2.4
	Kernel-5_35-4_79_2_282:1.1.2.4
	Kernel-5_35-4_79_2_281:1.1.2.4
	Kernel-5_35-4_79_2_280:1.1.2.4
	Kernel-5_35-4_79_2_279:1.1.2.4
	Kernel-5_35-4_79_2_278:1.1.2.4
	Kernel-5_35-4_79_2_277:1.1.2.4
	Kernel-5_35-4_79_2_276:1.1.2.4
	Kernel-5_35-4_79_2_275:1.1.2.4
	Kernel-5_35-4_79_2_274:1.1.2.4
	Kernel-5_35-4_79_2_273:1.1.2.4
	Kernel-5_35-4_79_2_272:1.1.2.4
	Kernel-5_35-4_79_2_271:1.1.2.4
	Kernel-5_35-4_79_2_270:1.1.2.4
	Kernel-5_35-4_79_2_269:1.1.2.4
	Kernel-5_35-4_79_2_268:1.1.2.3
	Kernel-5_35-4_79_2_267:1.1.2.3
	Kernel-5_35-4_79_2_266:1.1.2.3
	Kernel-5_35-4_79_2_265:1.1.2.3
	Kernel-5_35-4_79_2_264:1.1.2.3
	Kernel-5_35-4_79_2_263:1.1.2.3
	Kernel-5_35-4_79_2_262:1.1.2.3
	Kernel-5_35-4_79_2_261:1.1.2.3
	Kernel-5_35-4_79_2_260:1.1.2.3
	Kernel-5_35-4_79_2_259:1.1.2.3
	Kernel-5_35-4_79_2_258:1.1.2.3
	Kernel-5_35-4_79_2_257:1.1.2.3
	Kernel-5_35-4_79_2_256:1.1.2.3
	Kernel-5_35-4_79_2_255:1.1.2.3
	Kernel-5_35-4_79_2_254:1.1.2.3
	Kernel-5_35-4_79_2_253:1.1.2.3
	Kernel-5_35-4_79_2_252:1.1.2.3
	Kernel-5_35-4_79_2_251:1.1.2.3
	Kernel-5_35-4_79_2_250:1.1.2.3
	Kernel-5_35-4_79_2_249:1.1.2.3
	Kernel-5_35-4_79_2_248:1.1.2.3
	Kernel-5_35-4_79_2_247:1.1.2.3
	Kernel-5_35-4_79_2_246:1.1.2.3
	Kernel-5_35-4_79_2_245:1.1.2.3
	Kernel-5_35-4_79_2_244:1.1.2.3
	Kernel-5_35-4_79_2_243:1.1.2.3
	Kernel-5_35-4_79_2_242:1.1.2.3
	Kernel-5_35-4_79_2_241:1.1.2.3
	Kernel-5_35-4_79_2_240:1.1.2.3
	Kernel-5_35-4_79_2_239:1.1.2.3
	Kernel-5_35-4_79_2_238:1.1.2.3
	Kernel-5_35-4_79_2_237:1.1.2.3
	Kernel-5_35-4_79_2_236:1.1.2.3
	Kernel-5_35-4_79_2_235:1.1.2.3
	Kernel-5_35-4_79_2_234:1.1.2.3
	Kernel-5_35-4_79_2_233:1.1.2.3
	Kernel-5_35-4_79_2_232:1.1.2.3
	Kernel-5_35-4_79_2_231:1.1.2.3
	Kernel-5_35-4_79_2_230:1.1.2.3
	Kernel-5_35-4_79_2_229:1.1.2.3
	Kernel-5_35-4_79_2_228:1.1.2.3
	Kernel-5_35-4_79_2_227:1.1.2.3
	Kernel-5_35-4_79_2_226:1.1.2.3
	Kernel-5_35-4_79_2_225:1.1.2.3
	Kernel-5_35-4_79_2_224:1.1.2.3
	Kernel-5_35-4_79_2_223:1.1.2.3
	Kernel-5_35-4_79_2_222:1.1.2.3
	Kernel-5_35-4_79_2_221:1.1.2.3
	Kernel-5_35-4_79_2_220:1.1.2.3
	Kernel-5_35-4_79_2_219:1.1.2.3
	Kernel-5_35-4_79_2_218:1.1.2.3
	Kernel-5_35-4_79_2_217:1.1.2.3
	Kernel-5_35-4_79_2_216:1.1.2.3
	Kernel-5_35-4_79_2_215:1.1.2.3
	Kernel-5_35-4_79_2_214:1.1.2.2
	Kernel-5_35-4_79_2_213:1.1.2.2
	Kernel-5_35-4_79_2_212:1.1.2.2
	Kernel-5_35-4_79_2_211:1.1.2.2
	Kernel-5_35-4_79_2_210:1.1.2.2
	Kernel-5_35-4_79_2_209:1.1.2.2
	Kernel-5_35-4_79_2_208:1.1.2.2
	Kernel-5_35-4_79_2_207:1.1.2.2
	Kernel-5_35-4_79_2_206:1.1.2.2
	Kernel-5_35-4_79_2_205:1.1.2.2
	Kernel-5_35-4_79_2_204:1.1.2.2
	Kernel-5_35-4_79_2_203:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


4.1
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	1.1;
commitid	IWoXxARWeuLDOwcz;

1.1
date	2013.12.15.21.34.12;	author jlee;	state dead;
branches
	1.1.2.1;
next	;
commitid	KwuK29hKRyXO7hhx;

1.1.2.1
date	2013.12.15.21.34.12;	author jlee;	state Exp;
branches;
next	1.1.2.2;
commitid	KwuK29hKRyXO7hhx;

1.1.2.2
date	2013.12.17.19.08.56;	author jlee;	state Exp;
branches;
next	1.1.2.3;
commitid	mr92WavK9Mu4gwhx;

1.1.2.3
date	2014.04.04.22.19.21;	author jballance;	state Exp;
branches;
next	1.1.2.4;
commitid	bAG8kI0jJo5cQpvx;

1.1.2.4
date	2015.07.10.20.16.42;	author jlee;	state Exp;
branches;
next	;
commitid	wa0i3ESGlbkojMsy;


desc
@@


4.1
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@; Copyright 2013 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduGrafHAL
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - HAL GraphicsV driver
;
; Author K J Bracey
; Date   30.8.02
;

        MACRO
        GVHEntry $name
        ASSERT  . - MOSGraphicsVHAL_Table = GraphicsV_$name * 4
        B       GVHAL_$name
        MEND

MOSGraphicsVHAL ROUT
        ; HAL driver assumed to be driver #0
        CMP     r4, #(MOSGraphicsVHAL_TableEnd - MOSGraphicsVHAL_Table) / 4
        ADDLO   pc, pc, r4, LSL #2
        MOV     pc, lr                  ; reason code not known, so pass it on
MOSGraphicsVHAL_Table
        MOV     pc, lr                  ; 0
        MOV     pc, lr                  ; 1
        GVHEntry SetMode                ; 2
        GVHEntry SetInterlace           ; 3
        GVHEntry SetBlank               ; 4
        GVHEntry UpdatePointer          ; 5
        GVHEntry SetDMAAddress          ; 6
        GVHEntry VetMode                ; 7
        GVHEntry DisplayFeatures        ; 8
        GVHEntry FramestoreAddress      ; 9
        GVHEntry WritePaletteEntry      ; 10
        GVHEntry WritePaletteEntries    ; 11
        GVHEntry ReadPaletteEntry       ; 12
        GVHEntry Render                 ; 13
        GVHEntry IICOp                  ; 14
        MOV     pc, lr                  ; 15
        GVHEntry StartupMode            ; 16
        GVHEntry PixelFormats           ; 17   GVHAL_PixelFormats
MOSGraphicsVHAL_TableEnd

GVHAL_SetMode
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoSetMode
        Pull    "r0-r3, r9, pc"

GVHAL_SetInterlace
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoSetInterlace
        Pull    "r0-r3, r9, pc"

GVHAL_SetBlank
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoSetBlank
        Pull    "r0-r3, r9, pc"

GVHAL_UpdatePointer
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        CallHAL HAL_VideoUpdatePointer
        TEQ     r0, #0
        MOVNE   r4, #0
        Pull    "r0-r3, r9, pc"

GVHAL_SetDMAAddress
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoSetDAG
        Pull    "r0-r3, r9, pc"

GVHAL_VetMode
        Push    "r1-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoVetMode
        Pull    "r1-r3, r9, pc"

GVHAL_DisplayFeatures
        Push    "r0,r1,r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoFeatures
        STR     r0, [sp, #0]
        CallHAL HAL_VideoPixelFormats
        STR     r0, [sp, #4]
        CallHAL HAL_VideoBufferAlignment
        MOV     r2, r0
        Pull    "r0,r1,r3, r9, pc"

GVHAL_PixelFormats
        Push    "r3, r9, lr"
        AddressHAL WsPtr
        MOV     r0, #0
        MOV     r1, #0
        CallHAL HAL_VideoPixelFormatList
        ORRS    r3, r2, r1
        MOVNE   r4, #0
        Pull    "r3, r9, pc"

GVHAL_FramestoreAddress
        Push    "r3, r9, lr"
        AddressHAL WsPtr
        MOV     r0, #0
        MOV     r1, #0
        CallHAL HAL_VideoFramestoreAddress
        ORRS    r2, r0, r1
        MOVNE   r4, #0
        Pull    "r3, r9, pc"

GVHAL_WritePaletteEntry
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoWritePaletteEntry
        Pull    "r0-r3, r9, pc"

GVHAL_WritePaletteEntries
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoWritePaletteEntries
        Pull    "r0-r3, r9, pc"

GVHAL_ReadPaletteEntry
        Push    "r0,r2-r3, r9, lr"
        AddressHAL WsPtr
        CheckHAL HAL_VideoReadPaletteEntry, r3
        Pull    "r0,r2-r3, r9, pc", EQ
        MOV     r4, #0
      [ NoARMv5
        MOV     lr, pc
        MOV     pc, r3
      |
        BLX     r3
      ]
        MOV     r1,r0
        Pull    "r0,r2-r3, r9, pc"

GVHAL_Render
        Push    "r9, lr"
        AddressHAL WsPtr
        LDR     WsPtr, [sb, #-(EntryNo_HAL_VideoRender+1) * 4]
        ADRL    lr, NullHALEntry
        TEQ     WsPtr, lr
        Pull    "r9, pc", EQ ; Early-exit if HAL_VideoRender not supported
        Push    "r0-r3"
        ORR     r0, r0, #1:SHL:31
        MOV     lr, pc
        MOV     pc, WsPtr
        TEQ     r0, #0
        MOVPL   r4, #0
        Pull    "r0-r3, r9, pc"

GVHAL_IICOp
        Push    "r1-r3, r9, lr"
        AddressHAL WsPtr
        Push    "r2"                            ; Bytes desired to tranfer
        MOV     r2, sp                          
        CallHAL HAL_VideoIICOp
        Pull    "r4"                            ; Bytes actually transferred
        Pull    "r1-r3, r9, lr"
        ADD     r1, r1, r4                      ; Advance pointer
        SUB     r2, r2, r4                      ; Bytes not transferred
        MOV     r4, #0
        MOV     pc, lr

GVHAL_StartupMode
        Push    "r1-r3, r9, lr"
        AddressHAL WsPtr                   
        CallHAL HAL_VideoStartupMode
        MOV     r4, #0
        Pull    "r1-r3, r9, pc"


VduGrafHAL_Init ROUT
        Entry   "r0-r12"
        AddressHAL

        ; Do we actually have a HAL driver?
        ; For now, just use HAL_VideoPixelFormats as a check
        MOV     r0, #0
        CallHAL HAL_VideoPixelFormats
        TEQ     r0, #0
        EXIT    EQ

        ; Good, we have a driver

        ; Register with the OS
        MOV     r0, #ScreenModeReason_RegisterDriver
        MOV     r1, #0
        ADR     r2, VduGrafHAL_Name
        SWI     XOS_ScreenMode
        ; Assume success, since HAL should be first driver registered
        
        ; Set up VSync IRQ handler
        MOV     r0, #-1
        CallHAL HAL_VideoFlybackDevice
        CMP     r0, #-1
        BEQ     %FT10
        MOV     r5, r0
        ADR     r1, VduGrafHAL_VsyncIRQ
        LDR     r2, =ZeroPage
        SWI     XOS_ClaimDeviceVector
        MOV     r0, r5
        CallHAL HAL_IRQClear            ; clear vsync IRQ
        MOV     r0, r5
        CallHAL HAL_IRQEnable           ; enable vsync IRQ
10

        ;;; sort this out!
        ! 0, "HAL not doing anything useful with HAL_VideoBufferAlignment"
        ! 0, "HAL not dealing with lack of h/w pointer"

        ; Get on GraphicsV
        MOV     r0, #GraphicsV
        ADR     r1, MOSGraphicsVHAL
        LDR     r2, =ZeroPage
        SWI     XOS_Claim

        ; Now let the OS know that we're good to go
        MOV     r0, #ScreenModeReason_StartDriver
        MOV     r1, #0 ; Our driver number (hopefully)
        SWI     XOS_ScreenMode

        EXIT
        

VduGrafHAL_VsyncIRQ ROUT
        ; Don't push r14 - we're using new interface, and claim the vector
        ; TODO - deal with shared IRQs
        Push    "r4,r9,r12"
        AddressHAL r12
        CallHAL HAL_IRQClear            ; Clear the vsync interrupt
        MOV     r4, #GraphicsV_VSync
        BL      CallGraphicsV           ; Tell the VDU driver
        Pull    "r4,r9,r12,pc"

        ; Might want to add a HAL call for this at some point
VduGrafHAL_Name
        =       "HAL", 0
        ALIGN        

        END
@


1.1
log
@file vdugrafhal was initially added on branch HAL.
@
text
@d1 266
@


1.1.2.1
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@a0 256
; Copyright 2013 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduGrafHAL
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - HAL GraphicsV driver
;
; Author K J Bracey
; Date   30.8.02
;

        ASSERT UseGraphicsV

        MACRO
        GVHEntry $name
        ASSERT  . - MOSGraphicsVHAL_Table = GraphicsV_$name * 4
        B       GVHAL_$name
        MEND

MOSGraphicsVHAL ROUT
        ; HAL driver assumed to be driver #0
        CMP     r4, #(MOSGraphicsVHAL_TableEnd - MOSGraphicsVHAL_Table) / 4
        ADDLS   pc, pc, r4, LSL #2
        MOV     pc, lr                  ; reason code not known, so pass it on
MOSGraphicsVHAL_Table
        MOV     pc, lr                  ; 0
        MOV     pc, lr                  ; 1
        GVHEntry SetMode                ; 2
        GVHEntry SetInterlace           ; 3
        GVHEntry SetBlank               ; 4
        GVHEntry UpdatePointer          ; 5
        GVHEntry SetDMAAddress          ; 6
        GVHEntry VetMode                ; 7
        GVHEntry DisplayFeatures        ; 8
        GVHEntry FramestoreAddress      ; 9
        GVHEntry WritePaletteEntry      ; 10
        GVHEntry WritePaletteEntries    ; 11
        GVHEntry ReadPaletteEntry       ; 12
        GVHEntry Render                 ; 13
        GVHEntry IICOp                  ; 14
        MOV     pc, lr                  ; 15
        GVHEntry StartupMode            ; 16
MOSGraphicsVHAL_TableEnd

GVHAL_SetMode
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoSetMode
        Pull    "r0-r3, r9, pc"

GVHAL_SetInterlace
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoSetInterlace
        Pull    "r0-r3, r9, pc"

GVHAL_SetBlank
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoSetBlank
        Pull    "r0-r3, r9, pc"

GVHAL_UpdatePointer
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoUpdatePointer
        Pull    "r0-r3, r9, pc"

GVHAL_SetDMAAddress
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoSetDAG
        Pull    "r0-r3, r9, pc"

GVHAL_VetMode
        Push    "r1-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoVetMode
        Pull    "r1-r3, r9, pc"

GVHAL_DisplayFeatures
        Push    "r0,r1,r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoFeatures
        STR     r0, [sp, #0]
        CallHAL HAL_VideoPixelFormats
        STR     r0, [sp, #4]
        CallHAL HAL_VideoBufferAlignment
        MOV     r2, r0
        Pull    "r0,r1,r3, r9, pc"

GVHAL_FramestoreAddress
        Push    "r3, r9, lr"
        AddressHAL WsPtr
        MOV     r0, #0
        MOV     r1, #0
        CallHAL HAL_VideoFramestoreAddress
        ORRS    r2, r0, r1
        MOVNE   r4, #0
        Pull    "r3, r9, pc"

GVHAL_WritePaletteEntry
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoWritePaletteEntry
        Pull    "r0-r3, r9, pc"

GVHAL_WritePaletteEntries
        Push    "r0-r3, r9, lr"
        AddressHAL WsPtr
        MOV     r4, #0
        CallHAL HAL_VideoWritePaletteEntries
        Pull    "r0-r3, r9, pc"

GVHAL_ReadPaletteEntry
        Push    "r0,r2-r3, r9, lr"
        AddressHAL WsPtr
        CheckHAL HAL_VideoReadPaletteEntry, r3
        Pull    "r0,r2-r3, r9, pc", EQ
        MOV     r4, #0
      [ NoARMv5
        MOV     lr, pc
        MOV     pc, r3
      |
        BLX     r3
      ]
        MOV     r1,r0
        Pull    "r0,r2-r3, r9, pc"

GVHAL_Render
        Push    "r9, lr"
        AddressHAL WsPtr
        LDR     WsPtr, [sb, #-(EntryNo_HAL_VideoRender+1) * 4]
        ADRL    lr, NullHALEntry
        TEQ     WsPtr, lr
        Pull    "r9, pc", EQ ; Early-exit if HAL_VideoRender not supported
        Push    "r0-r3"
        ORR     r0, r0, #1:SHL:31
        MOV     lr, pc
        MOV     pc, WsPtr
        TEQ     r0, #0
        MOVPL   r4, #0
        Pull    "r0-r3, r9, pc"

GVHAL_IICOp
        Push    "r1-r3, r9, lr"
        AddressHAL WsPtr
        Push    "r2"                            ; Bytes desired to tranfer
        MOV     r2, sp                          
        CallHAL HAL_VideoIICOp
        Pull    "r4"                            ; Bytes actually transferred
        Pull    "r1-r3, r9, lr"
        ADD     r1, r1, r4                      ; Advance pointer
        SUB     r2, r2, r4                      ; Bytes not transferred
        MOV     r4, #0
        MOV     pc, lr

GVHAL_StartupMode
        Push    "r1-r3, r9, lr"
        AddressHAL WsPtr                   
        CallHAL HAL_VideoStartupMode
        MOV     r4, #0
        Pull    "r1-r3, r9, pc"


VduGrafHAL_Init ROUT
        Entry   "r0-r12"
        AddressHAL

        ; Do we actually have a HAL driver?
        ; For now, just use HAL_VideoPixelFormats as a check
        MOV     r0, #0
        CallHAL HAL_VideoPixelFormats
        TEQ     r0, #0
        EXIT    EQ

        ; Good, we have a driver

        ; Register with the OS
        MOV     r0, #ScreenModeReason_RegisterDriver
        MOV     r1, #0
        ADR     r2, VduGrafHAL_Name
        SWI     XOS_ScreenMode
        ; Assume success, since HAL should be first driver registered
        
        ; Set up VSync IRQ handler
        MOV     r0, #-1
        CallHAL HAL_VideoFlybackDevice
        CMP     r0, #-1
        BEQ     %FT10
        MOV     r5, r0
        ADR     r1, VduGrafHAL_VsyncIRQ
        LDR     r2, =ZeroPage
        SWI     XOS_ClaimDeviceVector
        MOV     r0, r5
        CallHAL HAL_IRQClear            ; clear vsync IRQ
        MOV     r0, r5
        CallHAL HAL_IRQEnable           ; enable vsync IRQ
10

        ;;; sort this out!
        ! 0, "HAL not doing anything useful with HAL_VideoBufferAlignment"
        ! 0, "HAL not dealing with lack of h/w pointer"

        ; Get on GraphicsV
        MOV     r0, #GraphicsV
        ADR     r1, MOSGraphicsVHAL
        LDR     r2, =ZeroPage
        SWI     XOS_Claim

        ; Now let the OS know that we're good to go
        MOV     r0, #ScreenModeReason_StartDriver
        MOV     r1, #0 ; Our driver number (hopefully)
        SWI     XOS_ScreenMode

        EXIT
        

VduGrafHAL_VsyncIRQ ROUT
        ; Don't push r14 - we're using new interface, and claim the vector
        ; TODO - deal with shared IRQs
        Push    "r4,r9,r12"
        AddressHAL r12
        CallHAL HAL_IRQClear            ; Clear the vsync interrupt
        MOV     r4, #GraphicsV_VSync
        BL      CallGraphicsV           ; Tell the VDU driver
        Pull    "r4,r9,r12,pc"

        ; Might want to add a HAL call for this at some point
VduGrafHAL_Name
        =       "HAL", 0
        ALIGN        

        END
@


1.1.2.2
log
@Strip out some old build switches
Detail:
  hdr/Options, s/ArthurSWIs, s/ChangeDyn, s/PMF/KbdDrA1, s/PMF/key, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdugrafhal, s/vdu/vdugrafv, s/vdu/vdumodes, s/vdu/vduwrch:
  - Strip out DoingVdu build switch (did nothing)
  - Strip out Japanese16BitSound switch (did nothing)
  - Strip out MakeModeSelectorsForModeNUmbers switch (altered the mode list structures, but there wasn't any code to do anything with the new data)
  - Strip out remaining uses of UseGraphicsV switch (now hardwired to {TRUE})
  - Strip out ShadowROM switch (altered FixedAreasTable to show the shadow mapping, but code to create the mapping is missing)
  - Strip out PollMouse switch (old Archimedes-era debug/development option)
Admin:
  Tested on BB-xM
  Builds to same binary as previous version


Version 5.35, 4.79.2.204. Tagged as 'Kernel-5_35-4_79_2_204'
@
text
@d26 2
@


1.1.2.3
log
@  Correction to code to add GraphicsV_PixelFormats call to
  HAL graphics driver calls.  Added further debug capability
Detail:
  Added additional HAL call. minor code correction in hal graphicsv dispatcher
  Added DebugReg macro to aid debugging
Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 5.35, 4.79.2.215. Tagged as 'Kernel-5_35-4_79_2_215'
@
text
@d35 1
a35 1
        ADDLO   pc, pc, r4, LSL #2
a54 1
        GVHEntry PixelFormats           ; 17   GVHAL_PixelFormats
a110 10
GVHAL_PixelFormats
        Push    "r3, r9, lr"
        AddressHAL WsPtr
        MOV     r0, #0
        MOV     r1, #0
        CallHAL HAL_VideoPixelFormatList
        ORRS    r3, r2, r1
        MOVNE   r4, #0
        Pull    "r3, r9, pc"

@


1.1.2.4
log
@Add builtin software pointer support
Detail:
  This set of changes adds support for rendering software mouse pointers directly in the kernel, rather than requiring graphics drivers to render them themselves as was the case previously.
  If a driver returns from GraphicsV_Features with the 'hardware pointer' bit clear, and a call to GraphicsV_UpdatePointer is returned unclaimed, then the kernel will step in and render a software pointer. This allows selective control over which areas of the screen the software pointer is used (e.g. if hardware only supports its use in some areas)
  hdr/KernelWS - Shrink PointerXEigFactor to 1 byte to free up some space for tracking the display log2bpp. Use 8 words of space for tracking software pointer state.
  s/vdu/vducursoft - Adjust existing the existing calls to the software pointer RemovePointer/RestorePointer functions so that they're called with IRQs enabled
  s/vdu/vdudriver - Keep track of display log2bpp. Claim/release memory needed for restoring pixels under software pointer.
  s/vdu/vdugrafhal - Update HAL_VideoUpdatePointer handling so that 0 can be returned in a1 to indicate the GraphicsV call should be left unclaimed.
  s/vdu/vdupalxx - Trigger updates of the cached software pointer palette whenever it's likely to become invalidated.
  s/vdu/vdupointer - Add software pointer implementation. Relying on a SpriteExtend OS_SpriteOp would be nice, but we're in the background so have to do plotting & unplotting manually. ColourTrans is used to cache the pointer palette colours for the current mode, although we're limited to calling it from a callback.
Admin:
  Tested on Raspberry Pi & BB-xM
  Pointer is very flickery under some circumstances (e.g. running !CloseUp) due to needing to plot/unplot around any VDU driver screen access (as per text cursor). So code may need revising in future once we can trap reads/writes from specific screen memory pages.


Version 5.35, 4.79.2.269. Tagged as 'Kernel-5_35-4_79_2_269'
@
text
@d82 1
a83 2
        TEQ     r0, #0
        MOVNE   r4, #0
@



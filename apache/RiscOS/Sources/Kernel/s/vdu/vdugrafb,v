head	4.4;
access;
symbols
	Kernel-6_14:4.4
	Kernel-6_01-3:4.4
	Kernel-6_13:4.4
	Kernel-6_12:4.4
	Kernel-6_11:4.4
	Kernel-6_10:4.4
	Kernel-6_09:4.4
	Kernel-6_08-4_129_2_10:4.4
	Kernel-6_08-4_129_2_9:4.4
	Kernel-6_08:4.4
	Kernel-6_07:4.4
	Kernel-6_06:4.4
	Kernel-6_05-4_129_2_8:4.4
	Kernel-6_05:4.4
	Kernel-6_04:4.4
	Kernel-6_03:4.4
	Kernel-6_01-2:4.4
	Kernel-6_01-4_146_2_1:4.4
	Kernel-6_02:4.4
	Kernel-6_01-1:4.4
	Kernel-6_01:4.4
	Kernel-6_00:4.4
	Kernel-5_99:4.4
	Kernel-5_98:4.4
	Kernel-5_97-4_129_2_7:4.4
	Kernel-5_97:4.4
	Kernel-5_96:4.4
	Kernel-5_95:4.4
	Kernel-5_94:4.4
	Kernel-5_93:4.4
	Kernel-5_92:4.4
	Kernel-5_91:4.4
	Kernel-5_90:4.4
	Kernel-5_89-4_129_2_6:4.4
	Kernel-5_89:4.4
	Kernel-5_88-4_129_2_5:4.4
	Kernel-5_88-4_129_2_4:4.4
	Kernel-5_88:4.4
	Kernel-5_87:4.4
	Kernel-5_86-4_129_2_3:4.4
	Kernel-5_86-4_129_2_2:4.4
	Kernel-5_86-4_129_2_1:4.4
	Kernel-5_86:4.4
	SMP:4.4.0.2
	SMP_bp:4.4
	Kernel-5_85:4.4
	Kernel-5_54-1:4.4
	Kernel-5_84:4.4
	Kernel-5_83:4.4
	Kernel-5_82:4.4
	Kernel-5_81:4.4
	Kernel-5_80:4.4
	Kernel-5_79:4.4
	Kernel-5_78:4.4
	Kernel-5_77:4.4
	Kernel-5_76:4.4
	Kernel-5_75:4.4
	Kernel-5_74:4.4
	Kernel-5_73:4.4
	Kernel-5_72:4.4
	Kernel-5_71:4.4
	Kernel-5_70:4.4
	Kernel-5_69:4.4
	Kernel-5_68:4.4
	Kernel-5_67:4.4
	Kernel-5_66:4.4
	Kernel-5_65:4.4
	Kernel-5_64:4.4
	Kernel-5_63:4.4
	Kernel-5_62:4.4
	Kernel-5_61:4.4
	Kernel-5_60:4.4
	Kernel-5_59:4.4
	Kernel-5_58:4.4
	Kernel-5_57:4.4
	Kernel-5_56:4.4
	Kernel-5_55:4.4
	Kernel-5_54:4.4
	Kernel-5_53:4.4
	Kernel-5_52:4.4
	Kernel-5_51:4.4
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.2.2.3
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.3
	Kernel-5_35-4_79_2_326:4.2.2.3
	Kernel-5_35-4_79_2_325:4.2.2.3
	Kernel-5_35-4_79_2_324:4.2.2.3
	Kernel-5_35-4_79_2_323:4.2.2.3
	Kernel-5_35-4_79_2_322:4.2.2.3
	Kernel-5_35-4_79_2_321:4.2.2.3
	Kernel-5_35-4_79_2_320:4.2.2.3
	Kernel-5_35-4_79_2_319:4.2.2.3
	Kernel-5_35-4_79_2_318:4.2.2.3
	Kernel-5_35-4_79_2_317:4.2.2.3
	Kernel-5_35-4_79_2_316:4.2.2.3
	Kernel-5_35-4_79_2_315:4.2.2.3
	Kernel-5_35-4_79_2_314:4.2.2.3
	Kernel-5_35-4_79_2_313:4.2.2.3
	Kernel-5_35-4_79_2_312:4.2.2.3
	Kernel-5_35-4_79_2_311:4.2.2.3
	Kernel-5_35-4_79_2_310:4.2.2.3
	Kernel-5_35-4_79_2_309:4.2.2.3
	Kernel-5_35-4_79_2_308:4.2.2.3
	Kernel-5_35-4_79_2_307:4.2.2.3
	Kernel-5_35-4_79_2_306:4.2.2.3
	Kernel-5_35-4_79_2_305:4.2.2.3
	Kernel-5_35-4_79_2_304:4.2.2.3
	Kernel-5_35-4_79_2_303:4.2.2.3
	Kernel-5_35-4_79_2_302:4.2.2.3
	Kernel-5_35-4_79_2_301:4.2.2.3
	Kernel-5_35-4_79_2_300:4.2.2.3
	Kernel-5_35-4_79_2_299:4.2.2.3
	Kernel-5_35-4_79_2_298:4.2.2.3
	Kernel-5_35-4_79_2_297:4.2.2.3
	Kernel-5_35-4_79_2_296:4.2.2.3
	Kernel-5_35-4_79_2_295:4.2.2.3
	Kernel-5_35-4_79_2_294:4.2.2.3
	Kernel-5_35-4_79_2_293:4.2.2.3
	Kernel-5_35-4_79_2_292:4.2.2.3
	Kernel-5_35-4_79_2_291:4.2.2.3
	Kernel-5_35-4_79_2_290:4.2.2.3
	Kernel-5_35-4_79_2_289:4.2.2.3
	Kernel-5_35-4_79_2_288:4.2.2.3
	Kernel-5_35-4_79_2_287:4.2.2.3
	Kernel-5_35-4_79_2_286:4.2.2.3
	Kernel-5_35-4_79_2_285:4.2.2.3
	Kernel-5_35-4_79_2_284:4.2.2.3
	Kernel-5_35-4_79_2_283:4.2.2.3
	Kernel-5_35-4_79_2_282:4.2.2.3
	Kernel-5_35-4_79_2_281:4.2.2.3
	Kernel-5_35-4_79_2_280:4.2.2.3
	Kernel-5_35-4_79_2_279:4.2.2.3
	Kernel-5_35-4_79_2_278:4.2.2.3
	Kernel-5_35-4_79_2_277:4.2.2.3
	Kernel-5_35-4_79_2_276:4.2.2.3
	Kernel-5_35-4_79_2_275:4.2.2.3
	Kernel-5_35-4_79_2_274:4.2.2.3
	Kernel-5_35-4_79_2_273:4.2.2.3
	Kernel-5_35-4_79_2_272:4.2.2.3
	Kernel-5_35-4_79_2_271:4.2.2.3
	Kernel-5_35-4_79_2_270:4.2.2.3
	Kernel-5_35-4_79_2_269:4.2.2.3
	Kernel-5_35-4_79_2_268:4.2.2.3
	Kernel-5_35-4_79_2_267:4.2.2.3
	Kernel-5_35-4_79_2_266:4.2.2.3
	Kernel-5_35-4_79_2_265:4.2.2.3
	Kernel-5_35-4_79_2_264:4.2.2.3
	Kernel-5_35-4_79_2_263:4.2.2.3
	Kernel-5_35-4_79_2_262:4.2.2.3
	Kernel-5_35-4_79_2_261:4.2.2.3
	Kernel-5_35-4_79_2_260:4.2.2.3
	Kernel-5_35-4_79_2_259:4.2.2.3
	Kernel-5_35-4_79_2_258:4.2.2.3
	Kernel-5_35-4_79_2_257:4.2.2.3
	Kernel-5_35-4_79_2_256:4.2.2.3
	Kernel-5_35-4_79_2_255:4.2.2.3
	Kernel-5_35-4_79_2_254:4.2.2.3
	Kernel-5_35-4_79_2_253:4.2.2.3
	Kernel-5_35-4_79_2_252:4.2.2.3
	Kernel-5_35-4_79_2_251:4.2.2.3
	Kernel-5_35-4_79_2_250:4.2.2.3
	Kernel-5_35-4_79_2_249:4.2.2.3
	Kernel-5_35-4_79_2_248:4.2.2.3
	Kernel-5_35-4_79_2_247:4.2.2.3
	Kernel-5_35-4_79_2_246:4.2.2.3
	Kernel-5_35-4_79_2_245:4.2.2.3
	Kernel-5_35-4_79_2_244:4.2.2.3
	Kernel-5_35-4_79_2_243:4.2.2.3
	Kernel-5_35-4_79_2_242:4.2.2.3
	Kernel-5_35-4_79_2_241:4.2.2.3
	Kernel-5_35-4_79_2_240:4.2.2.3
	Kernel-5_35-4_79_2_239:4.2.2.3
	Kernel-5_35-4_79_2_238:4.2.2.3
	Kernel-5_35-4_79_2_237:4.2.2.3
	Kernel-5_35-4_79_2_236:4.2.2.3
	Kernel-5_35-4_79_2_235:4.2.2.3
	Kernel-5_35-4_79_2_234:4.2.2.3
	Kernel-5_35-4_79_2_233:4.2.2.3
	Kernel-5_35-4_79_2_232:4.2.2.3
	Kernel-5_35-4_79_2_231:4.2.2.3
	Kernel-5_35-4_79_2_230:4.2.2.3
	Kernel-5_35-4_79_2_229:4.2.2.3
	Kernel-5_35-4_79_2_228:4.2.2.3
	Kernel-5_35-4_79_2_227:4.2.2.3
	Kernel-5_35-4_79_2_226:4.2.2.3
	Kernel-5_35-4_79_2_225:4.2.2.3
	Kernel-5_35-4_79_2_224:4.2.2.3
	Kernel-5_35-4_79_2_223:4.2.2.3
	Kernel-5_35-4_79_2_222:4.2.2.3
	Kernel-5_35-4_79_2_221:4.2.2.3
	Kernel-5_35-4_79_2_220:4.2.2.3
	Kernel-5_35-4_79_2_219:4.2.2.3
	Kernel-5_35-4_79_2_218:4.2.2.3
	Kernel-5_35-4_79_2_217:4.2.2.3
	Kernel-5_35-4_79_2_216:4.2.2.3
	Kernel-5_35-4_79_2_215:4.2.2.3
	Kernel-5_35-4_79_2_214:4.2.2.3
	Kernel-5_35-4_79_2_213:4.2.2.3
	Kernel-5_35-4_79_2_212:4.2.2.3
	Kernel-5_35-4_79_2_211:4.2.2.3
	Kernel-5_35-4_79_2_210:4.2.2.3
	Kernel-5_35-4_79_2_209:4.2.2.3
	Kernel-5_35-4_79_2_208:4.2.2.3
	Kernel-5_35-4_79_2_207:4.2.2.3
	Kernel-5_35-4_79_2_206:4.2.2.3
	Kernel-5_35-4_79_2_205:4.2.2.3
	Kernel-5_35-4_79_2_204:4.2.2.3
	Kernel-5_35-4_79_2_203:4.2.2.3
	Kernel-5_35-4_79_2_202:4.2.2.3
	Kernel-5_35-4_79_2_201:4.2.2.3
	Kernel-5_35-4_79_2_200:4.2.2.3
	Kernel-5_35-4_79_2_199:4.2.2.3
	Kernel-5_35-4_79_2_198:4.2.2.3
	Kernel-5_35-4_79_2_197:4.2.2.3
	Kernel-5_35-4_79_2_196:4.2.2.3
	Kernel-5_35-4_79_2_195:4.2.2.3
	Kernel-5_35-4_79_2_194:4.2.2.3
	Kernel-5_35-4_79_2_193:4.2.2.3
	Kernel-5_35-4_79_2_192:4.2.2.3
	Kernel-5_35-4_79_2_191:4.2.2.3
	Kernel-5_35-4_79_2_190:4.2.2.3
	Kernel-5_35-4_79_2_189:4.2.2.3
	Kernel-5_35-4_79_2_188:4.2.2.3
	Kernel-5_35-4_79_2_187:4.2.2.3
	Kernel-5_35-4_79_2_186:4.2.2.3
	Kernel-5_35-4_79_2_185:4.2.2.3
	Kernel-5_35-4_79_2_184:4.2.2.3
	Kernel-5_35-4_79_2_183:4.2.2.3
	Kernel-5_35-4_79_2_182:4.2.2.3
	Kernel-5_35-4_79_2_181:4.2.2.3
	Kernel-5_35-4_79_2_180:4.2.2.3
	Kernel-5_35-4_79_2_179:4.2.2.3
	Kernel-5_35-4_79_2_178:4.2.2.3
	Kernel-5_35-4_79_2_177:4.2.2.3
	Kernel-5_35-4_79_2_176:4.2.2.3
	Kernel-5_35-4_79_2_175:4.2.2.3
	Kernel-5_35-4_79_2_174:4.2.2.3
	Kernel-5_35-4_79_2_173:4.2.2.3
	Kernel-5_35-4_79_2_172:4.2.2.3
	Kernel-5_35-4_79_2_171:4.2.2.3
	Kernel-5_35-4_79_2_170:4.2.2.3
	Kernel-5_35-4_79_2_169:4.2.2.3
	Kernel-5_35-4_79_2_168:4.2.2.3
	Kernel-5_35-4_79_2_167:4.2.2.3
	Kernel-5_35-4_79_2_166:4.2.2.3
	Kernel-5_35-4_79_2_165:4.2.2.3
	RPi_merge:4.2.2.3
	Kernel-5_35-4_79_2_147_2_23:4.2.2.3
	Kernel-5_35-4_79_2_147_2_22:4.2.2.3
	Kernel-5_35-4_79_2_147_2_21:4.2.2.3
	Kernel-5_35-4_79_2_147_2_20:4.2.2.3
	Kernel-5_35-4_79_2_147_2_19:4.2.2.3
	Kernel-5_35-4_79_2_147_2_18:4.2.2.3
	Kernel-5_35-4_79_2_164:4.2.2.3
	Kernel-5_35-4_79_2_163:4.2.2.3
	Kernel-5_35-4_79_2_147_2_17:4.2.2.3
	Kernel-5_35-4_79_2_147_2_16:4.2.2.3
	Kernel-5_35-4_79_2_147_2_15:4.2.2.3
	Kernel-5_35-4_79_2_162:4.2.2.3
	Kernel-5_35-4_79_2_161:4.2.2.3
	Kernel-5_35-4_79_2_147_2_14:4.2.2.3
	Kernel-5_35-4_79_2_147_2_13:4.2.2.3
	Kernel-5_35-4_79_2_160:4.2.2.3
	Kernel-5_35-4_79_2_159:4.2.2.3
	Kernel-5_35-4_79_2_158:4.2.2.3
	Kernel-5_35-4_79_2_157:4.2.2.3
	Kernel-5_35-4_79_2_156:4.2.2.3
	Kernel-5_35-4_79_2_147_2_12:4.2.2.3
	Kernel-5_35-4_79_2_147_2_11:4.2.2.3
	Kernel-5_35-4_79_2_155:4.2.2.3
	Kernel-5_35-4_79_2_147_2_10:4.2.2.3
	Kernel-5_35-4_79_2_154:4.2.2.3
	Kernel-5_35-4_79_2_153:4.2.2.3
	Kernel-5_35-4_79_2_147_2_9:4.2.2.3
	Kernel-5_35-4_79_2_152:4.2.2.3
	Kernel-5_35-4_79_2_151:4.2.2.3
	Kernel-5_35-4_79_2_147_2_8:4.2.2.3
	Kernel-5_35-4_79_2_147_2_7:4.2.2.3
	Kernel-5_35-4_79_2_150:4.2.2.3
	Kernel-5_35-4_79_2_147_2_6:4.2.2.3
	Kernel-5_35-4_79_2_147_2_5:4.2.2.3
	Kernel-5_35-4_79_2_149:4.2.2.3
	Kernel-5_35-4_79_2_147_2_4:4.2.2.3
	Kernel-5_35-4_79_2_147_2_3:4.2.2.3
	Kernel-5_35-4_79_2_148:4.2.2.3
	Kernel-5_35-4_79_2_147_2_2:4.2.2.3
	Kernel-5_35-4_79_2_147_2_1:4.2.2.3
	RPi:4.2.2.3.0.2
	RPi_bp:4.2.2.3
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2.2.2
	alees_Kernel_dev:4.2.2.2.0.4
	alees_Kernel_dev_bp:4.2.2.2
	Kernel-5_35-4_79_2_147:4.2.2.3
	Kernel-5_35-4_79_2_146:4.2.2.3
	Kernel-5_35-4_79_2_145:4.2.2.3
	Kernel-5_35-4_79_2_144:4.2.2.3
	Kernel-5_35-4_79_2_143:4.2.2.3
	Kernel-5_35-4_79_2_142:4.2.2.3
	Kernel-5_35-4_79_2_141:4.2.2.3
	Kernel-5_35-4_79_2_140:4.2.2.3
	Kernel-5_35-4_79_2_139:4.2.2.3
	Kernel-5_35-4_79_2_138:4.2.2.3
	Kernel-5_35-4_79_2_137:4.2.2.2
	Kernel-5_35-4_79_2_136:4.2.2.2
	Kernel-5_35-4_79_2_135:4.2.2.2
	Kernel-5_35-4_79_2_134:4.2.2.2
	Kernel-5_35-4_79_2_133:4.2.2.2
	Kernel-5_35-4_79_2_132:4.2.2.2
	Kernel-5_35-4_79_2_131:4.2.2.2
	Kernel-5_35-4_79_2_130:4.2.2.2
	Kernel-5_35-4_79_2_129:4.2.2.2
	Kernel-5_35-4_79_2_128:4.2.2.2
	Kernel-5_35-4_79_2_127:4.2.2.2
	Kernel-5_35-4_79_2_126:4.2.2.2
	Kernel-5_35-4_79_2_125:4.2.2.2
	Kernel-5_35-4_79_2_124:4.2.2.2
	Kernel-5_35-4_79_2_123:4.2.2.2
	Cortex_merge:4.2.2.2
	Kernel-5_35-4_79_2_122:4.2.2.2
	Kernel-5_35-4_79_2_98_2_54:4.2.2.2
	Kernel-5_35-4_79_2_98_2_53:4.2.2.2
	Kernel-5_35-4_79_2_98_2_52:4.2.2.2
	Kernel-5_35-4_79_2_98_2_51:4.2.2.2
	Kernel-5_35-4_79_2_98_2_50:4.2.2.2
	Kernel-5_35-4_79_2_98_2_49:4.2.2.2
	Kernel-5_35-4_79_2_98_2_48:4.2.2.2
	Kernel-5_35-4_79_2_121:4.2.2.2
	Kernel-5_35-4_79_2_98_2_47:4.2.2.2
	Kernel-5_35-4_79_2_120:4.2.2.2
	Kernel-5_35-4_79_2_98_2_46:4.2.2.2
	Kernel-5_35-4_79_2_119:4.2.2.2
	Kernel-5_35-4_79_2_98_2_45:4.2.2.2
	Kernel-5_35-4_79_2_98_2_44:4.2.2.2
	Kernel-5_35-4_79_2_118:4.2.2.2
	Kernel-5_35-4_79_2_98_2_43:4.2.2.2
	Kernel-5_35-4_79_2_117:4.2.2.2
	Kernel-5_35-4_79_2_116:4.2.2.2
	Kernel-5_35-4_79_2_98_2_42:4.2.2.2
	Kernel-5_35-4_79_2_115:4.2.2.2
	Kernel-5_35-4_79_2_98_2_41:4.2.2.2
	Kernel-5_35-4_79_2_98_2_40:4.2.2.2
	Kernel-5_35-4_79_2_114:4.2.2.2
	Kernel-5_35-4_79_2_98_2_39:4.2.2.2
	Kernel-5_35-4_79_2_98_2_38:4.2.2.2
	Kernel-5_35-4_79_2_113:4.2.2.2
	Kernel-5_35-4_79_2_112:4.2.2.2
	Kernel-5_35-4_79_2_98_2_37:4.2.2.2
	Kernel-5_35-4_79_2_98_2_36:4.2.2.2
	Kernel-5_35-4_79_2_98_2_35:4.2.2.2
	Kernel-5_35-4_79_2_98_2_34:4.2.2.2
	Kernel-5_35-4_79_2_98_2_33:4.2.2.2
	Kernel-5_35-4_79_2_98_2_32:4.2.2.2
	Kernel-5_35-4_79_2_98_2_31:4.2.2.2
	Kernel-5_35-4_79_2_98_2_30:4.2.2.2
	Kernel-5_35-4_79_2_98_2_29:4.2.2.2
	Kernel-5_35-4_79_2_98_2_28:4.2.2.2
	Kernel-5_35-4_79_2_98_2_27:4.2.2.2
	Kernel-5_35-4_79_2_98_2_26:4.2.2.2
	Kernel-5_35-4_79_2_111:4.2.2.2
	Kernel-5_35-4_79_2_98_2_25:4.2.2.2
	Kernel-5_35-4_79_2_98_2_24:4.2.2.2
	Kernel-5_35-4_79_2_98_2_23:4.2.2.2
	Kernel-5_35-4_79_2_110:4.2.2.2
	Kernel-5_35-4_79_2_98_2_22:4.2.2.2
	Kernel-5_35-4_79_2_109:4.2.2.2
	Kernel-5_35-4_79_2_98_2_21:4.2.2.2
	Kernel-5_35-4_79_2_98_2_20:4.2.2.2
	Kernel-5_35-4_79_2_108:4.2.2.2
	Kernel-5_35-4_79_2_107:4.2.2.2
	Kernel-5_35-4_79_2_98_2_19:4.2.2.2
	Kernel-5_35-4_79_2_98_2_18:4.2.2.2
	Kernel-5_35-4_79_2_98_2_17:4.2.2.2
	Kernel-5_35-4_79_2_98_2_16:4.2.2.2
	Kernel-5_35-4_79_2_98_2_15:4.2.2.2
	Kernel-5_35-4_79_2_106:4.2.2.2
	Kernel-5_35-4_79_2_105:4.2.2.2
	Kernel-5_35-4_79_2_104:4.2.2.2
	Kernel-5_35-4_79_2_98_2_14:4.2.2.2
	Kernel-5_35-4_79_2_98_2_13:4.2.2.2
	Kernel-5_35-4_79_2_98_2_12:4.2.2.2
	Kernel-5_35-4_79_2_98_2_11:4.2.2.2
	Kernel-5_35-4_79_2_98_2_10:4.2.2.2
	Kernel-5_35-4_79_2_98_2_9:4.2.2.2
	Kernel-5_35-4_79_2_103:4.2.2.2
	Kernel-5_35-4_79_2_102:4.2.2.2
	Kernel-5_35-4_79_2_98_2_8:4.2.2.2
	Kernel-5_35-4_79_2_98_2_7:4.2.2.2
	Kernel-5_35-4_79_2_98_2_6:4.2.2.2
	Kernel-5_35-4_79_2_98_2_5:4.2.2.2
	Kernel-5_35-4_79_2_98_2_4:4.2.2.2
	Kernel-5_35-4_79_2_101:4.2.2.2
	Kernel-5_35-4_79_2_100:4.2.2.2
	Kernel-5_35-4_79_2_99:4.2.2.2
	Kernel-5_35-4_79_2_98_2_3:4.2.2.2
	Kernel-5_35-4_79_2_98_2_2:4.2.2.2
	Kernel-5_35-4_79_2_98_2_1:4.2.2.2
	Cortex:4.2.2.2.0.2
	Cortex_bp:4.2.2.2
	Kernel-5_35-4_79_2_98:4.2.2.2
	Kernel-5_35-4_79_2_97:4.2.2.2
	Kernel-5_35-4_79_2_96:4.2.2.2
	Kernel-5_35-4_79_2_95:4.2.2.2
	Kernel-5_35-4_79_2_94:4.2.2.2
	Kernel-5_35-4_79_2_93:4.2.2.2
	Kernel-5_35-4_79_2_92:4.2.2.2
	Kernel-5_35-4_79_2_91:4.2.2.2
	Kernel-5_35-4_79_2_90:4.2.2.2
	Kernel-5_35-4_79_2_89:4.2.2.2
	Kernel-5_35-4_79_2_88:4.2.2.2
	Kernel-5_35-4_79_2_87:4.2.2.2
	Kernel-5_35-4_79_2_86:4.2.2.2
	Kernel-5_35-4_79_2_85:4.2.2.2
	Kernel-5_35-4_79_2_84:4.2.2.2
	Kernel-5_35-4_79_2_83:4.2.2.2
	Kernel-5_35-4_79_2_82:4.2.2.2
	Kernel-5_35-4_79_2_81:4.2.2.2
	Kernel-5_35-4_79_2_80:4.2.2.2
	Kernel-5_35-4_79_2_79:4.2.2.2
	Kernel-5_35-4_79_2_78:4.2.2.2
	Kernel-5_35-4_79_2_77:4.2.2.2
	RO_5_07:4.2.2.2
	Kernel-5_35-4_79_2_76:4.2.2.2
	Kernel-5_35-4_79_2_75:4.2.2.2
	Kernel-5_35-4_79_2_74:4.2.2.2
	Kernel-5_35-4_79_2_73:4.2.2.2
	Kernel-5_35-4_79_2_72:4.2.2.2
	Kernel-5_35-4_79_2_71:4.2.2.2
	Kernel-5_35-4_79_2_70:4.2.2.2
	Kernel-5_35-4_79_2_69:4.2.2.2
	Kernel-5_35-4_79_2_68:4.2.2.2
	Kernel-5_35-4_79_2_67:4.2.2.2
	Kernel-5_35-4_79_2_66:4.2.2.2
	Kernel-5_35-4_79_2_65:4.2.2.2
	Kernel-5_35-4_79_2_64:4.2.2.2
	Kernel-5_35-4_79_2_63:4.2.2.2
	Kernel-5_35-4_79_2_62:4.2.2.2
	Kernel-5_35-4_79_2_61:4.2.2.2
	Kernel-5_35-4_79_2_59:4.2.2.2
	Kernel-5_35-4_79_2_58:4.2.2.2
	Kernel-5_35-4_79_2_57:4.2.2.2
	Kernel-5_35-4_79_2_56:4.2.2.2
	Kernel-5_35-4_79_2_55:4.2.2.2
	Kernel-5_35-4_79_2_54:4.2.2.2
	Kernel-5_35-4_79_2_53:4.2.2.2
	Kernel-5_35-4_79_2_52:4.2.2.2
	Kernel-5_35-4_79_2_51:4.2.2.2
	Kernel-5_35-4_79_2_50:4.2.2.2
	Kernel-5_35-4_79_2_49:4.2.2.2
	Kernel-5_35-4_79_2_48:4.2.2.2
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.4
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2.2.1
	Kernel-5_35-4_79_2_46:4.2.2.1
	Kernel-5_35-4_79_2_45:4.2.2.1
	Kernel-5_35-4_79_2_44:4.2.2.1
	Kernel-5_35-4_79_2_25_2_2:4.2.2.1
	Kernel-5_35-4_79_2_43:4.2.2.1
	Kernel-5_35-4_79_2_42:4.2.2.1
	Kernel-5_35-4_79_2_41:4.2.2.1
	Kernel-5_35-4_79_2_40:4.2.2.1
	Kernel-5_35-4_79_2_39:4.2.2.1
	Kernel-5_35-4_79_2_38:4.2.2.1
	Kernel-5_35-4_79_2_37:4.2.2.1
	Kernel-5_35-4_79_2_36:4.2.2.1
	Kernel-5_35-4_79_2_35:4.2.2.1
	Kernel-5_35-4_79_2_34:4.2.2.1
	Kernel-5_35-4_79_2_33:4.2.2.1
	Kernel-5_35-4_79_2_32:4.2.2.1
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2.2.1
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2.2.1
	Kernel-5_35-4_79_2_30:4.2.2.1
	Kernel-5_35-4_79_2_29:4.2.2.1
	Kernel-5_35-4_79_2_28:4.2.2.1
	Kernel-5_35-4_79_2_27:4.2.2.1
	Kernel-5_35-4_79_2_26:4.2.2.1
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2.2.1
	Kernel-5_35-4_79_2_24:4.2.2.1
	Kernel-5_35-4_79_2_23:4.2.2.1
	Kernel-5_35-4_79_2_22:4.2.2.1
	Kernel-5_35-4_79_2_21:4.2.2.1
	Kernel-5_35-4_79_2_20:4.2.2.1
	Kernel-5_35-4_79_2_19:4.2.2.1
	Kernel-5_35-4_79_2_18:4.2.2.1
	Kernel-5_35-4_79_2_17:4.2.2.1
	Kernel-5_35-4_79_2_16:4.2.2.1
	Kernel-5_35-4_79_2_15:4.2.2.1
	Kernel-5_35-4_79_2_14:4.2.2.1
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2.2.1
	Kernel-5_35-4_79_2_12:4.2.2.1
	Kernel-5_35-4_79_2_11:4.2.2.1
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2.2.1
	Kernel-5_35-4_79_2_9:4.2.2.1
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2.2.1
	Kernel-5_35-4_79_2_7:4.2.2.1
	Kernel-5_35-4_79_2_6:4.2.2.1
	Kernel-5_35-4_79_2_5:4.2.2.1
	Kernel-5_35-4_79_2_4:4.2.2.1
	Kernel-5_35-4_79_2_3:4.2.2.1
	Kernel-5_35-4_79_2_2:4.2.2.1
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2.2.1
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2016.06.30.20.29.05;	author jlee;	state Exp;
branches;
next	4.3;
commitid	lMnWzoE9eJz3Wwcz;

4.3
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.04.04.14.27.40;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.35;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2012.02.25.16.19.42;	author jlee;	state Exp;
branches;
next	;
commitid	ad3WnPntkzrizyUv;

4.1.1.1
date	96.11.05.09.41.35;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.02.58;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.35;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.58;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.35;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduGrafB
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - Graphics circle outline, fill, arc, sector & segment
;
; Author R C Manby
; Date   5.9.86
;

; *****************************************************************************
;
;       CircleOutline - Circle outline
;
;       External routine
;
; in:   ICursor is the centre of the circle
;       NewPt is a point on the circumference
;
; out:  R0-R11 corrupt
;

CircleOutline ROUT
        Push    R14
        ADD     R11, WsPtr, #GCsIX              ; R0 := CentreX; R1 := CentreY
        LDMIA   R11, {R0-R3}                    ; R2 := NewPtX; R3 := NewPtY
        BL      GenCircleParm                   ; set up parm. block in R0-R7
        ADD     R9, WsPtr, #CircleBlk           ; R9 -> saved R0
        ADD     R11, R9, #5*4                   ; R11 -> saved R5
        STMIA   R11, {R5-R7}                    ; save R5-R7 once and for all
10
        STMIA   R9, {R0-R4}                     ; save R0-R4 before plotting pt

        SUB     R10, R5, R0                     ; upper left point
        ADD     R0, R5, R0                      ; upper right point
        ADD     R1, R6, R1
        BL      PlotPoint                       ; do upper right point

        CMP     R10, R0
        MOVNE   R0, R10                         ; do upper left point
        BLNE    PlotPoint                       ; unless same as upper right

        LDMIA   R9, {R0,R1}                     ; reload X, Y
        CMP     R1, #0                          ; if yPnt=0, skip lower
        BEQ     %FT20                           ; pixel pair

        LDMIA   R11, {R5,R6}                    ; reload CentreX, CentreY

        SUB     R10, R5, R0                     ; lower left point
        ADD     R0, R5, R0                      ; lower right point
        SUB     R1, R6, R1
        BL      PlotPoint

        CMP     R10, R0
        MOVNE   R0, R10                         ; do lower left point
        BLNE    PlotPoint                       ; unless same as lower right

20
        LDMIA   R9, {R0-R7}                     ; reload the parameter block
        TEQ     R0, #0                          ; if xPnt=0
        Pull    PC,EQ                           ; then finish
        BL      AdvCircleParm                   ; else step to next point
        B       %BT10                           ; and go round again

; *****************************************************************************
;
;       CircleFill - Circular area fill
;
;       External routine
;
; in:   ICursor is the centre of the circle
;       NewPt is a point on the circumference
;
; out:  R0-R11 corrupt
;

CircleFill ROUT
        Push    R14
        ADD     R11, WsPtr, #GCsIX              ; centre is ICursor
        LDMIA   R11, {R0-R3}                    ; point is NewPt
        BL      GenCircleParm                   ; set up parameter block
        ADD     R11, WsPtr, #CircleBlk          ; in R0-R6
10
        STMIA   R11, {R0-R7}                    ; save prior to line drawing
        ADD     R2, R5, R0                      ; RightX = CentreX+xPnt
        SUB     R11, R6, R1                     ; LowerY = CentreY-yPnt

        SUB     R0, R5, R0                      ; LeftX  = CentreX-xPnt
        ADD     R1, R6, R1                      ; UpperY = CentreY+yPnt
        BL      NewHLine                        ; draw upper slice

        CMP     R11, R1                         ; unless UpperY=LowerY
        MOV     R1, R11
        BLNE    NewHLine                        ; do draw lower slice

        ADDS    R11, WsPtr, #CircleBlk          ; (C := 0)
        LDMIA   R11, {R0-R7}                    ; reload the parameter block
20
        TEQ     R0, #0
        Pull    PC, EQ                          ; finish if xPnt=0
        BL      AdvCircleParm                   ; else step to next point
        BCC     %BT20                           ; step until yPnt changes
        B       %BT10                           ; do next slice

; *****************************************************************************
;
;       CircleArc - Circular arc outline
;
;       External routine
;
; in:   OldCs is the centre of the circle
;       ICursor is the start of the arc
;       NewPt is the finishing point of the arc
;
; out:  R0-R11 corrupt
;

CircleArc ROUT
        Push    R14
        BL      GenArcParmBlk
        ADD     R11, WsPtr, #CircleBlk
        LDMIA   R11, {R0-R7}                    ; reload the parameter block
10
        STMIA   R11, {R0-R7}                    ; save prior to line drawing
        BL      Reflect
        BL      UpdateQuadrants

        LDRB    R8, [WsPtr, #Quad0Draw]         ; if LSBit set, plot this point
        TST     R8, #1
        LDRNE   R0, [WsPtr, #ArcPoint0X]
        LDRNE   R1, [WsPtr, #ArcPoint0Y]
        BLNE    PlotPoint

        LDR     R0, [WsPtr, #CircleBlk]         ; if xPnt=0, ignore left pixel
        CMP     R0, #0
        BEQ     %FT20

        LDRB    R8, [WsPtr, #Quad1Draw]         ; if LSBit set, plot this point
        TST     R8, #1
        LDRNE   R0, [WsPtr, #ArcPoint1X]
        LDRNE   R1, [WsPtr, #ArcPoint1Y]
        BLNE    PlotPoint
20
        LDR     R0, [WsPtr, #(CircleBlk+4)]     ; if yPnt=0, skip lower
        CMP     R0, #0                          ; pixel pair
        BEQ     %FT30

        LDRB    R8, [WsPtr, #Quad3Draw]         ; if LSBit set, plot this point
        TST     R8, #1
        LDRNE   R0, [WsPtr, #ArcPoint3X]
        LDRNE   R1, [WsPtr, #ArcPoint3Y]
        BLNE    PlotPoint

        LDR     R0, [WsPtr, #CircleBlk]         ; if xPnt=0, ignore left pixel
        CMP     R0, #0
        BEQ     %FT30

        LDRB    R8, [WsPtr, #Quad2Draw]         ; if LSBit set, plot this point
        TST     R8,#1
        LDRNE   R0, [WsPtr, #ArcPoint2X]
        LDRNE   R1, [WsPtr, #ArcPoint2Y]
        BLNE    PlotPoint
30
        ADD     R11, WsPtr, #CircleBlk
        LDMIA   R11, {R0-R7}                    ; reload the parameter block
        TEQ     R0, #0
        Pull    PC, EQ                          ; finish if xPnt=0

        BL      AdvCircleParm                   ; else step to next point
        B       %BT10                           ; and go round again

; *****************************************************************************
;
;       SegmentFill - Circular segment fill
;
;       External routine
;
; in:   OldCs is the centre of the circle
;       ICursor is the start of the segment
;       NewPt is the finishing point of the segment
;
; out:  R0-R11 corrupt
;

SegmentFill ROUT
        Push    R14
        BL      GenArcParmBlk
        BL      GenSegParmBlk
        ADD     R11, WsPtr,#CircleBlk
        LDMIA   R11, {R0-R7}                    ; reload the parameter block
10
        STMIA   R11, {R0-R7}                    ; save prior to line drawing
        BL      Reflect
        BL      UpdateQuadrants
        LDR     R0, [WsPtr, #Quad0StateChange]  ; if any quadrant changes state
        CMP     R0, #0
        BLNE    SegmentLineOn                   ; try starting segment line

        LDR     R7, [WsPtr, #ArcPoint1X]        ; limits of segment line
        LDR     R8, [WsPtr, #ArcPoint0X]
        LDR     R9, [WsPtr, #ArcPoint1Y]        ; current scanline
        LDR     R11, [WsPtr, #UpperSegLinePtr]  ; holds 0 or points at CLine2
        CMP     R11, #0
        BLNE    SegLineStep                     ; and advance if active

        LDR     R0, [WsPtr, #ArcPoint1X]
        LDR     R1, [WsPtr, #ArcPoint1Y]
        LDR     R2, [WsPtr, #ArcPoint0X]
        LDRB    R3, [WsPtr, #Quad1Draw]
        LDRB    R4, [WsPtr, #Quad0Draw]
        BL      SegmentSlice

        LDR     R0, [WsPtr, #(CircleBlk+4)]     ; if yPnt=0, skip lower line
        CMP     R0, #0
        BEQ     %FT15

        LDR     R7, [WsPtr, #ArcPoint2X]        ; limits of segment line
        LDR     R8, [WsPtr, #ArcPoint3X]
        LDR     R9, [WsPtr, #ArcPoint3Y]        ; current scanline
        LDR     R11, [WsPtr, #LowerSegLinePtr]  ; holds 0 or points at CLine3
        CMP     R11, #0
        BLNE    SegLineStep                     ; and advance if active

        Swap    R7,R8

        LDR     R0, [WsPtr, #ArcPoint3X]
        LDR     R1, [WsPtr, #ArcPoint3Y]
        LDR     R2, [WsPtr, #ArcPoint2X]
        LDRB    R3, [WsPtr, #Quad3Draw]
        LDRB    R4, [WsPtr, #Quad2Draw]
        BL      SegmentSlice
15
        LDR     R0, [WsPtr, #Quad0StateChange]  ; if any quadrant state changes
        CMP     R0, #0                          ; left, kill segment line
        BLNE    SegmentLineOff

        ADD     R11, WsPtr, #CircleBlk
        LDMIA   R11, {R0-R7}                    ; reload the parameter block
20
        TEQ     R0, #0
        Pull    PC, EQ                          ; finish if xPnt=0

        BL      AdvCircleParm                   ; else step to next point
        BCS     %BT10                           ; do next slice
        BCC     %BT20                           ; step until yPnt changes

; *****************************************************************************
;
;       SegLineStep - Advance the segment line, limited to be within the circle
;
;       Internal routine, called by SegmentFill
;
; in:   R7 = left circleX
;       R8 = right circleX
;       R9 = current scanline
;       R11 = pointer to Line (CLine2 or CLine3) (can't hold zero any more)
;

SegLineStep ROUT
        Push    R14
        LDMIA   R11, {R0-R6,R10} ; N.B. EndX is in R10
        CMP     R4, #0          ; if line is horizontal
        MOVEQ   R9, R10         ; then line limits are in R0 & R10,
        BEQ     %FT50           ;      R9 := R10 and branch
                                ; else find limits

        CMP     R9, R1          ; advance line until currentY = circleY
20
        BLNE    AdvLineParm     ; (this usually takes one step)
        CMP     R9, R1
        BNE     %BT20

        MOV     R9, R0          ; assume CurrentX is the left most point

        CMP     R10, R0         ; if currentX=EndX
        BEQ     %FT40           ; then no need to advance line

        CMP     R2, #0          ; else While bres >= 0 do AdvLineParm
30
        AdvLineParm_GE          ; this leaves us furthest point on segment
        CMP     R10, R0
        BEQ     %FT40
        CMP     R2, #0          ; line for this scanline in R0
        BGE     %BT30
40
        STMIA   R11, {R0-R4}    ; update the line parameter block
50
        CMP     R9, R0          ; R9 := LeftX
        MOVGT   R10, R9
        MOVGT   R9, R0
        MOVLE   R10, R0         ; R10 := RightX

        CMP     R8, R10         ; force R10 into range R7..R8
        MOVLT   R10, R8
        CMP     R7, R10
        MOVGT   R10, R7

        CMP     R7, R9          ; force R9 into range R7..R8
        MOVGT   R9, R7
        CMP     R8, R9
        MOVLT   R9, R8

        MOV     R8, R10
        MOV     R7, R9
        Pull    PC

; *****************************************************************************
;
;       SegmentSlice - Draw a slice of a circular segment
;
;       Internal routine, called by SegmentFill
;
; in:   R0 = circleX left
;       R1 = circleY
;       R2 = circleX right
;       R3 = left quadrant control word  (TopL or BotR)
;       R4 = right quadrant control word (TopR or BotL)
;       R7 = left most point of segment line for this slice
;       R8 = right most point of segment line for this slice
;
; out:  R0-R11 corrupt
;

SegmentSlice ROUT
        TST     R3, #1          ; if both quadrants empty
        TSTEQ   R4, #1          ; or not at start of segment
        MOVEQ   PC, R14         ; then return

        TST     R3, #1          ; if both quadrants to be filled
        TSTNE   R4, #1          ; or filling below segment line
        BNE     HLine           ; then draw a slice of circle

;              0 0              ; ......
;              1 1              ; (----)

;              0 1              ;     \)    ;     /) ;  \---)    ;  /---)
;              1 0              ; (/        ; (\     ; (---/     ; (---\ 

; From here on, all plotting decisions can be made from
; the LSBit of one quadrant field

        TST     R3, #1
        MOVEQ   R0, R7          ; Draw ---)
        BEQ     HLine

        MOV     R2, R8          ; Draw (---
        B       HLine

; *****************************************************************************
;
;       SegmentLineOn - Try to start segment line
;
;       Internal routine, called by SegmentFill
;

SegmentLineOn ROUT
        Push    R14
                                                ; quadrant 0
        LDRB    R10, [WsPtr, #Quad0StateChange] ; state change 0..2
        ADD     R9, WsPtr, #ArcPoint0X          ; address of point on circle
        ADD     R8, WsPtr, #CLine2              ; line block to use if starting
        LDR     R11, [WsPtr, #UpperSegLinePtr]  ; 0 or ptr to active line
        BL      SegmentLineO5
        STRB    R10, [WsPtr, #Quad0StateChange] ; new state change flag

        LDRB    R10, [WsPtr, #Quad1StateChange] ; quadrant 1
        ADD     R9, WsPtr, #ArcPoint1X
        ADD     R8, WsPtr, #CLine2
        BL      SegmentLineO5
        STRB    R10, [WsPtr, #Quad1StateChange]
        STR     R11, [WsPtr, #UpperSegLinePtr]  ; unchanged/updated lineptr

                                                ; lower hemisphere
        LDRB    R10, [WsPtr, #Quad2StateChange] ; quadrant 2
        ADD     R9, WsPtr, #ArcPoint2X
        ADD     R8, WsPtr, #CLine3
        LDR     R11, [WsPtr, #LowerSegLinePtr]
        BL      SegmentLineO5
        STRB    R10, [WsPtr, #Quad2StateChange]

        LDRB    R10, [WsPtr, #Quad3StateChange] ; quadrant 3
        ADD     R9, WsPtr, #ArcPoint3X
        ADD     R8, WsPtr, #CLine3
        BL      SegmentLineO5
        STRB    R10, [WsPtr, #Quad3StateChange]
        STR     R11, [WsPtr, #LowerSegLinePtr]

        Pull    PC

; *****************************************************************************
;
;       SegmentLineO5 - On state change, start segment line and update
;        statechange - if line already active, do nothing
;
;       Internal routine, called by SegmentLineOn
;
; in:   R8  -> CLine(2..3)
;       R9  -> ArcPoint(0..3)X
;       R10 = Quad(0..3)StateChange
;         0 means no change
;         1 means one line hit
;         2 means both lines hit
;       R11 = 0 or pointer to segment line
;
; out:  R10 = updated Quad(0..3)StateChange
;       R11 = 0 or points at newly created line
;

SegmentLineO5 ROUT
        CMP     R10, #0         ; if state unchanged
        MOVEQ   PC, R14         ; then go home

        CMP     R11, #0         ; else if segment line active
        MOVNE   PC, R14         ;      then go home

        Push    R14             ;      else start the segment line
        MOV     R11, R8
        LDMIA   R9, {R0,R1}     ; run from point on circle
        LDMIA   R11, {R2,R3}    ; to other end
        BL      GenLineParm
        STMIA   R11, {R0-R8}
        MOV     R10, R10, LSR #1 ; state1->state0, state2->state1
        Pull    PC

; *****************************************************************************
;
;       SegmentLineOff - Try to kill segment line
;
;       Internal routine, called by SegmentFill
;
; in:   R0 = stateflags for each quadrant
;
; out:  R0 preserved
;       R1 corrupted
;

SegmentLineOff ROUT
        MOV     R1, #0
        TST     R0, #&3                         ; if statechange occurred in
        TSTEQ   R0, #&300                       ; Quad0 or Quad1
        STRNE   R1, [WsPtr, #UpperSegLinePtr]   ; then kill upper segment line

        TST     R0, #&30000                     ; if statechange occured in
        TSTEQ   R0, #&3000000                   ; Quad2 or Quad3
        STRNE   R1, [WsPtr, #LowerSegLinePtr]   ; then kill lower segment line

        MOV     PC, R14

; *****************************************************************************
;
;       SectorFill - Circular sector (pie) fill
;
;       External routine
;
; in:   OldCs is the centre of the circle
;       ICursor is the start of the sector
;       NewPt is the finishing point of the sector
;
; out:  R0-R11 corrupt
;

SectorFill ROUT
        Push    R14
        BL      GenArcParmBlk
        ADD     R11, WsPtr, #CircleBlk
        LDMIA   R11, {R0-R7}                    ; reload the parameter block
SectorFi10
        STMIA   R11, {R0-R7}                    ; save prior to line drawing
        BL      Reflect
        BL      UpdateQuadrants

        LDR     R0, [WsPtr, #(CircleBlk+4)]     ; if yPnt=0, panic
        CMP     R0, #0
        BEQ     SectorFi40

        LDR     R0, [WsPtr, #ArcPoint1X]
        LDR     R1, [WsPtr, #ArcPoint1Y]
        LDR     R2, [WsPtr, #ArcPoint0X]
        LDRB    R3, [WsPtr, #Quad1Draw]
        LDRB    R4, [WsPtr, #Quad0Draw]
        BL      SectorSlice

        LDR     R0, [WsPtr, #ArcPoint3X]
        LDR     R1, [WsPtr, #ArcPoint3Y]
        LDR     R2, [WsPtr, #ArcPoint2X]
        LDRB    R3, [WsPtr, #Quad3Draw]
        LDRB    R4, [WsPtr, #Quad2Draw]
        BL      SectorSlice

SectorFi20
        ADD     R11, WsPtr, #CircleBlk
        LDMIA   R11, {R0-R7}                    ; reload the parameter block
SectorFi30
        TEQ     R0, #0
        Pull    PC, EQ                          ; finish if xPnt=0
        BL      AdvCircleParm                   ; else step to next point
        BCS     SectorFi10                      ; do next slice
        BCC     SectorFi30                      ; step until yPnt changes

SectorFi40
        LDR     R0, [WsPtr, #CLine0Near]        ; equal to CLine1NearX &
        LDR     R1, [WsPtr, #ArcPoint0Y]        ; centre of circle
        LDR     R3, [WsPtr, #CLine0Far]
        LDR     R4, [WsPtr, #CLine1Far]

        Greatest R2, R0,R3              ; draw from rightmost of CLine0, Cline1
        Greatest R2, R2,R4

        Least R0, R0,R3                 ; to left most of CLine0, Cline1
        Least R0, R0,R4

        LDR     R3, [WsPtr, #Quad0Draw] ; all 4 drawing control bytes

        TST     R3, #&00000001          ; if Quad0 or
        TSTEQ   R3, #&01000000          ;    Quad3 fills against circle
        LDRNE   R2, [WsPtr, #ArcPoint0X] ; then override R2

        TST     R3, #&00000100          ; If Quad1 or
        TSTEQ   R3, #&00010000          ;    Quad2 fills against circle
        LDRNE   R0, [WsPtr, #ArcPoint1X] ; then override R0

        BL      NewHLine                ; draw the line (sorted coords)
        B       SectorFi20


;
; Internal subroutine for sector (pie) fills
;
; On entry, R0 - circleX left
;           R1 - circleY
;           R2 - circleX right
;           R3 - left quadrant control word  (TopL or BotR)
;           R4 - right quadrant control word (TopR or BotL)
;
; On exit, R0-R11 corrupt
;
SectorSlice
        CMP   R4,#&57                           ; (--//)
        LDREQ R3,[WsPtr,#CLine0Far]
        LDREQ R4,[WsPtr,#CLine1Near]
        BEQ DoubleHLine

        CMP   R3,#&73                           ; (\\--)
        LDREQ R3,[WsPtr,#CLine0Near]
        LDREQ R4,[WsPtr,#CLine1Far]
        BEQ DoubleHLine

        CMP   R4,#&07                           ; (-\/-)
        CMPEQ R3,#&03
        LDREQ R3,[WsPtr,#CLine0Near]
        LDREQ R4,[WsPtr,#CLine1Near]
        BEQ DoubleHLine

        CMP   R4,#&07                           ;    /-)
        LDREQ R0,[WsPtr,#CLine1Near]
        BEQ HLine
        CMP   R3,#&03                           ; (-\ 
        LDREQ R2,[WsPtr,#CLine0Near]
        BEQ HLine

        CMP   R4,#&3A                           ;    /-/
        LDREQ R0,[WsPtr,#CLine1Near]
        LDREQ R2,[WsPtr,#CLine0Far]
        BEQ HLine

        CMP   R3,#&1E                           ; \-\ 
        LDREQ R0,[WsPtr,#CLine1Far]
        LDREQ R2,[WsPtr,#CLine0Near]
        BEQ HLine

        CMP   R4,#1                             ; ...--)
        MOVLT PC,Link                           ;Nothing in either quadrant
        LDRGT R2,[WsPtr,#CLine0Far]             ; ...--/
        CMP   R3,#1                             ; (--...
        LDRGT R0,[WsPtr,#CLine1Far]             ; \--...
        B HLine
;
;
;
;------------------------------------------------------------------------------
;
; Reflect - Generate four point on a circle by
; =======   reflection about its centre
;
; On entry, R0..R7 hold a circle parameter block
; On exit,  R0 (X), R1  (Y) point in Quadrant0
;           R2 (X), R3  (Y) point in Quadrant1
;           R7 (X), R8  (Y) point in Quadrant2
;           R9 (X), R10 (Y) point in Quadrant3
;           R11 points at ArcPoint0X
;
;           ArcPoint(0..3) updated
;
; Format of a circle control block
;       R0 - xPnt   (CurrentX - relative to centre)
;       R1 - yPnt   (CurrentY - relative to centre)
;       R2 - sum (Bres)
;       R3 - upcnt
;       R4 - downcnt
;       R5 - CentreX
;       R6 - CentreY
;       R7 - Aspect (pixel shape : 0 square, 1 horz rect, 2 vert rect)
;
Reflect
        ADD R9,R5,R0    ;Quad 3  CentreX+xPnt   ;Calculate all 4 points
        SUB R10,R6,R1   ;        CentreY-yPnt   ; by reflection about centre

        SUB R7,R5,R0    ;Quad 2  CentreX-xPnt
        SUB R8,R6,R1    ;        CentreY-yPnt

        SUB R2,R5,R0    ;Quad 1  CentreX-xPnt
        ADD R3,R6,R1    ;        CentreY+yPnt

        ADD R0,R5,R0    ;Quad 0  CentreX+xPnt
        ADD R1,R6,R1    ;        CentreY+yPnt

        ADD R11,WsPtr,#ArcPoint0X
        STMIA R11,{R0,R1, R2,R3, R7,R8, R9,R10} ;And store the lot for later on

        MOV PC,Link
;
;
;
;  update lines & quadrant data
;
;  use R9  as offset from WsPtr to ArcPoint(0..3)X
;  use R10 as offset from WsPtr to QuadControl(0..3)
;  use R11 as address of line parameter block(0..1)
;
;
UpdateQuadrants
        SaveRetAdr

        MOV R0,#0
        STR R0,[WsPtr,#Quad0StateChange]        ;Clear flags for each quadrant

        LDR R0,[WsPtr,#Quad0Control]            ;Update the 4 'drawing'
        STR R0,[WsPtr,#Quad0Draw]               ; control bytes

                                                ;Start by looking at quadrant 0
        ADD R10,WsPtr,#Quad0Control             ;Address of control byte
        ADD R9,WsPtr,#ArcPoint0X                ;Address of point on circle
        BL UpdateQuadr10

        ADD R10,R10,#(Quad1Control-Quad0Control)        ;Quadrant 1
        ADD R9,R9,#(ArcPoint1X-ArcPoint0X)
        BL UpdateQuadr10

        ADD R10,R10,#(Quad1Control-Quad0Control)        ;Quadrant 2
        ADD R9,R9,#(ArcPoint1X-ArcPoint0X)
        BL UpdateQuadr10

        ADD R10,R10,#(Quad1Control-Quad0Control)        ;Quadrant 3
        ADD R9,R9,#(ArcPoint1X-ArcPoint0X)
        BL UpdateQuadr10

        Return


UpdateQuadr10
        LDRB R0,[R10]           ;Get control block for quadrant
        TST R0,#&2              ;If 0 or 1
        MOVEQ PC,Link           ; then nothing to do

        SaveRetAdr              ; else update the line

        LDMIA R9,{R7,R8}                        ;Point on circle in this quad

        TST R0,#4
        ADDEQ R11,WsPtr,#CLine0                 ;Load parm blk for line(0/1)
        ADDNE R11,WsPtr,#CLine1

        LDMIA R11,{R0,R1,R2,R3,R4,R5,R6}        ;EndX,EndY (R7,R8) not needed
        BL ArcLineStep
        STMIA R11,{R0,R1,R2,R3,R4,R5,R6,R8}     ;Update the changes, EndX
                                                ; used for NearX

        CMP R7,#1                               ; 'change state' flag
        MOV R7,#1                               ;Convert to one line hit
        STRGEB R7,[R10,#(Quad0StateChange-Quad0Control)]

        LDRB R0,[R10]           ;Get control block for quadrant and look at
        MOV R0,R0,LSR #3        ; next control field
        STRGEB R0,[R10]         ;If 'change state' write back next field

                                                        ;If outside circle
        TSTEQ R0,#1                                     ; or changing into a
        STRGTB R0,[R10,#(Quad0Draw-Quad0Control)]       ; plotting state update
                                                        ; drawing control byte

        TST R0,#2                               ;If new field doesnt advance a
        Return EQ                               ; line then quit
                                                ; else update second line
        Push R0

        LDMIA R9,{R7,R8}                        ;Point on circle in this quad

        TST R0,#4
        ADDEQ R11,WsPtr,#CLine0                 ;Load parm blk for line(0/1)
        ADDNE R11,WsPtr,#CLine1

        LDMIA R11,{R0,R1,R2,R3,R4,R5,R6}        ;EndX,EndY (R7,R8) not needed
        BL ArcLineStep
        STMIA R11,{R0,R1,R2,R3,R4,R5,R6,R8}     ;Update the changes, EndX
                                                ; used for NearX

        CMP R7,#1                               ; 'change state' flag
        MOV R7,#2                               ;Convert to both lines hit
        STRGEB R7,[R10,#(Quad0StateChange-Quad0Control)]

        Pull R0         ;Use earlier value instead of reloading control block,
                        ; as whally lines (dy/dx = 0/0) blewup when 2nd line
                        ; terminated before 1st line. This case should not
                        ; now get through, but you never now.

        MOV R0,R0,LSR #3        ;Next field in control field
        STRGEB R0,[R10]         ;If 'changing state' write this back

        STRGTB R0,[R10,#(Quad0Draw-Quad0Control)]       ; and update drawing
                                                        ; control byte
        Return
;
;
;
; ArcLineStep - Step line parameter block checking for interception
; ===========     with circle.
;
;               Return first ('near') and last ('far') points of line
;                 that fall on this scanline, limiting 'far' to the point on
;                 the circle if interception occurs.
;
; On entry, R0..R6 hold a line parameter block (EndX,EndY are not loaded)
;
; Format of a line control block
;           R0 - StartX (CurrentX)
;           R1 - StartY (CurrentY)
;           R2 - Bres
;           R3 - DeltaX
;           R4 - DeltaY
;           R5 - StepX (+1/-1) (Equv bit6 of Sign in 6502 version)
;           R6 - StepY (+1/-1) (Equv bit7 of Sign in 6502 version)
;                (R7 - EndX            Not used in this routine,)
;                (R8 - EndY            so not passed in)
;
;           R7,R8  CircleX,CircleY
;
; On exit,  R0 (X), R1 (Y), R2 (bres) updated
;           R7 0/1/2 for within/on/outside circle
;           R8 nearX
;
;
; R9,R10,R11 unused
;
ArcLineStep
        SaveRetAdr

        CMP R8,R1               ;Advance line until CurrentY = CircleY
ArcLineSt10
        BLNE AdvLineParm
        CMP R8,R1               ; {this usually takes one step}
        BNE ArcLineSt10

        MOV R8,R0               ;This point is nearX
                                ; ie the first point on this scanline

        SUBS R14,R0,R7          ;If  (CurrentX=CircleX) then farX is on circle
        TEQNE R5,R14            ;If ((CurrentX-CircleX) EOR StepX is +ve)
                                ;then farX is outside circle
        MOVPL R0,R7             ;      limit farX to circleX
        MOVPL R7,#2             ;      set change flag =2 for outside
        MOVEQ R7,#1             ;                      =1 for on circle
        Return PL               ;      and return


        CMP R2,#0               ;While bres >= 0 and within circle AdvLineParm
ArcLineSt20                     ; this leaves us with farX,farY in R0,R1
        AdvLineParm_GE

        CMP R0,R7               ;If (CurrentX=CircleX) then farX is on circle
        MOVEQ R7,#1             ;      set change flag
        Return EQ               ;      and return
                                ; else within circle

        CMP R2,#0               ;If y about to change, return farX,farY
        BGE ArcLineSt20         ; else loop back to step the line
        MOV R7,#0
        Return
;
;
;
; Assumes  R9, R10 & R11 are not corrupted over calls to GenLineParm
;
;
GenArcParmBlk
        SaveRetAdr

        ADD R11,WsPtr,#OldCsX                   ;Build parm block for a circle
        LDMIA R11,{R0,R1,R2,R3}                 ; centre OldCs, point on
        BL GenCircleParm                        ; circumference in ICursor

        ADD R11,WsPtr,#CircleBlk
        STMIA R11,{R0,R1,R2,R3,R4,R5,R6,R7}

        ADD R10,WsPtr,#CLine0
        ADD R11,WsPtr,#OldCsX

        LDMIA R11!,{R0,R1,R2,R3}                ;CLine0 gives start of arc
        BL GenLineParm                          ; (OldCs->ICursor)
        STMIA R10!,{R0,R1,R2,R3,R4,R5,R6,R7,R8}
;
; Use StepX and StepY for 'start of arc' line to form the beginnings of
; an index into the arc control block table
; StepX & StepY each hold +1 or -1 and the value left in R9 is
;
;     R9  | Quad
;   ------+------
;    0000 |  0
;    0100 |  1
;    1100 |  2
;    1000 |  3
;
;
        AND R5,R5,#&4                           ;
        AND R6,R6,#&8                           ; See above for details
        ORR R9,R6,R5                            ;

        LDMIA R11,{R2,R3}                       ;CLine1 gives end line of arc
                                                ; (OldCs->NewPt)

        CMP R0,R2                               ;If OldCs=NewPt
        CMPEQ R1,R3                             ; use OldCs->(NewPtX+1,NewPtY)
        ADDEQ R2,R2,#1                          ; for compatability with Master

        BL GenLineParm
        STMIA R10,{R0,R1,R2,R3,R4,R5,R6,R7,R8}

        AND R5,R5,#&4
        AND R6,R6,#&8
        ORR R6,R6,R5                            ; 'end of arc'

        CMP R9,R6               ;If start and end quadrants different
        ORRNE R9,R9,R6,LSL #2   ;  then index = start OR (end <<2)
        BNE GenArcPar10         ;  and branch

                                ;else special case code for index, based
                                ; on gradients of line

        LDR R7,[WsPtr,#(CLine0+12)]     ; DeltaX0.DeltaY1
        LDR R8,[WsPtr,#(CLine1+16)]
        MUL R0, R7, R8

        LDR R7,[WsPtr,#(CLine0+16)]     ; DeltaX1.DeltaY0
        LDR R8,[WsPtr,#(CLine1+12)]
        MUL R9, R7, R8

        CMP R0,R9                       ;For gradients <,>,=
        ORRLT R9,R6,#&40                ; generate index into table
        ORRGT R9,R6,#&50
        ORREQ R9,R6,R6,LSL #2

GenArcPar10
        ADR R0,GenArcTb                 ; GenArcTb

        LDR R0,[R0,R9]
        STR R0,[WsPtr,#Quad0Control]    ;Setup all FOUR control BYTEs

        Return



;
;
; 00 000 000  &00     no points to be plotted
; 00 000 001  &01     all points to be plotted
; 00 001 x10  &0A,0E  plot nothing until line x hits circle then start plotting
; 00 000 x11  &03,07  plot points until line x hits circle then stop
; 00 y11 x10  &3A,1E  plot points only between line x and line y
; 01 y10 x11  &73,57  plot points from x axis to line x, then line y to y axis
;
;
GenArcTb
 & &0000003A    ; 0->0 (short arc)
 & &01010307    ; 1->0
 & &03000007    ; 3->0
 & &010A0007    ; 2->0

 & &00000E0A    ; 0->1
 & &00001E00    ; 1->1 (short arc)
 & &03000E01    ; 3->1
 & &010A0E01    ; 2->1

 & &0E01010A    ; 0->3
 & &0E010300    ; 1->3
 & &1E000000    ; 3->3 (short arc)
 & &0E0A0000    ; 2->3

 & &0007010A    ; 0->2
 & &00070300    ; 1->2
 & &03070101    ; 3->2
 & &003A0000    ; 2->2 (short arc)


 & &01010157    ; 0->0 (long arc)    grad line0 > grad line1
 & &00001E00    ; 1->1 (short arc)
 & &1E000000    ; 3->3 (short arc)
 & &01570101    ; 2->2 (long arc)

 & &0000003A    ; 0->0 (short arc)   grad line0 < grad line 1
 & &01017301    ; 1->1 (long arc)
 & &73010101    ; 3->3 (long arc)
 & &003A0000    ; 2->2 (short arc)
;
;
;


GenSegParmBlk
        SaveRetAdr

        ADD R11,WsPtr,#CLine1           ;Get all line data except EndX,EndY
        LDMIA R11,{R0,R1,R2,R3,R4,R5,R6}

        LDR R11,[WsPtr,#AspectRatio]    ;Frigging non square frigging pixels
                                        ; 0=Sq, 1=horz, 2=vert
        CMP R11,#1
        MOVEQ R3,R3,LSL #1              ;If horz, scale up deltaX
        MOVGT R4,R4,LSL #1              ;If vert, scale up deltaY

        [ {TRUE}
        LDR     R8, [WsPtr, #CircleRadSquare] ; R8 = r2
        MUL     R9, R3, R3              ; R9 = DX2
        MUL     R10, R4, R4             ; R10 = DY2
        ADD     R11, R9, R10            ; R11 = R2

        MOV     R3, R10
        BL      DoubleMulDivSquareRoot
        MOV     R4, R3                  ; R4 = dy

        MOV     R3, R9
        BL      DoubleMulDivSquareRoot  ; R3 = dx
        |
        MUL R9,R3,R3                    ;R9 := Square(deltaX)
        MOV R2,R9                       ;R2 := Square(deltaX)

        LDR R8,[WsPtr,#CircleRadSquare]
        MUL R3,R9,R8                    ;R3 := Square(radius) * Square(deltaX)

        MUL R9,R4,R4                    ;R9 := Square(deltaY)
        ADD R2,R2,R9                    ;R2 := Square(deltaX) + Square(deltaY)

        MUL R10,R9,R8                   ;R10 := Square(radius) * Square(deltaY)

        MOV R9,R2
; *****Change made by DJS
; Use new DivRem macro, not old DIVREM
; Original code was:
;        DIVREM R7,R10,R9, R8            ;R7 := (rad^2 * deltaY^2)/R2
        DivRem R7,R10,R9, R8            ;R7 := (rad^2 * deltaY^2)/R2
; *****End of change made by DJS
        BL SquareRoot                   ;Iy left in R8
        MOV R4,R8

; *****Change made by DJS
; Use new DivRem macro, not old DIVREM
; Original code was:
;        DIVREM R7,R3,R2, R8             ;R7 := (rad^2 * deltaX^2)/R2
        DivRem R7,R3,R2, R8             ;R7 := (rad^2 * deltaX^2)/R2
; *****End of change made by DJS
        BL SquareRoot                   ;Ix left in R8
        MOV R3,R8
        ]

        LDR R11,[WsPtr,#AspectRatio]    ; 0=Sq, 1=horz, 2=vert
        CMP R11,#1
        MOVEQ R3,R3,LSR #1              ;If horz, scale down deltaX
        MOVGT R4,R4,LSR #1              ;If vert, scale down deltaY

        CMP R5,#0                       ;If StepX >= 0
        ADDGE R0,R0,R3                  ; then R0 := StartX+R3
        SUBLT R0,R0,R3                  ; else R0 := StartX-R3

        CMP R6,#0                       ;If StepY >= 0
        ADDGE R1,R1,R4                  ; then R1 := StartY+R4
        SUBLT R1,R1,R4                  ; else R1 := StartY-R4

;
; R0,R1 is the intercept of CLine1 and the circle
;       so, segment line runs from here to endpoint of CLine0
;

        LDR R2,[WsPtr,#CLine0EndX]
        LDR R3,[WsPtr,#CLine0EndY]

        CompSwapT R0,R1, R2,R3, R4       ; Order coords

;
; If segment line crosses X axis
; then initialise both upper & lower segment lines
; else leave endpoints for later use
;

        LDR R4,[WsPtr,#Quad0Control]    ;All 4 control bytes
        ORR R4,R4,R4,LSR #8             ;If bit1 =0, not in upper hemisphere
                                        ;If bit9 =0, not in lower hemisphere
        AND R4,R4,R4,LSR #16
        TST R4,#2                       ;If bit1 =0
        BEQ GenSegParmB10               ; then line does not cross X axis

                                        ; else start both CLine2 & CLine3
                                        ;      running, so..

        BL GenLineParm                          ;Initialise CLine2 as the
        ADD R11,WsPtr,#CLine2                   ; upper hemisphere segment line
        STMIA R11,{R0,R1,R2,R3,R4,R5,R6,R7,R8}
        STR R11,[WsPtr,#UpperSegLinePtr]

        MOV R2,R0                               ;Run CLine3, in the opposite
        MOV R3,R1                               ; direction for use as the
        MOV R0,R7                               ; lower hemisphere segment line
        MOV R1,R8
        BL GenLineParm
        ADD R11,WsPtr,#CLine3
        STMIA R11,{R0,R1,R2,R3,R4,R5,R6,R7,R8}
        STR R11,[WsPtr,#LowerSegLinePtr]

        Return

GenSegParmB10                           ;Line does not cross X axis, so..
        ADD R11,WsPtr,#CLine2           ;Upper hemisphere segment line, runs
        STMIA R11,{R2,R3}               ; to R2,R3  (if it runs at all)

        ADD R11,WsPtr,#CLine3           ;Lower hemisphere segment line, runs
        STMIA R11,{R0,R1}               ; to R0,R1  (if it runs at all)

        MOV R11,#0                              ;Both lines inactive
        STR R11,[WsPtr,#UpperSegLinePtr]
        STR R11,[WsPtr,#LowerSegLinePtr]

        Return

; *****************************************************************************
;
;       DoubleMulDivSquareRoot - Compute SQR(a*b/c) in double precision
;
; in:   R3 = a
;       R8 = b
;       R11 = c
;
; out:  R3 = result
;       R2, R7 corrupted
;

DoubleMulDivSquareRoot ROUT
        Push    "R8-R11,R14"
    [ NoARMM
        MOV     R2, R3, LSR #16                 ; R2 = ah
        EOR     R7, R3, R2, LSL #16             ; R7 = al
        MOV     R9, R8, LSR #16                 ; R9 = bh
        EOR     R10, R8, R9, LSL #16            ; R10 = bl

        MUL     R3, R7, R10                     ; R3 = al.bl
        MUL     R14, R7, R9                     ; R14 = al.bh
        MLA     R14, R10, R2, R14               ; R14 = al.bh + ah.bl
        MUL     R8, R2, R9                      ; R8 = ah.bh

        ADDS    R3, R3, R14, LSL #16            ; R3 = lower 32 bits of a.b
        ADC     R8, R8, R14, LSR #16            ; R8 = upper 32 bits of a.b
    |
        ; Use UMULL
      [ NoARMv6
        ; Rn can't be RdLo/RdHi in ARMv5 and below
        MOV     R2, R3
        UMULL   R3, R8, R2, R8
      |
        UMULL   R3, R8, R3, R8
      ]
    ]
; now do divide of a.b by c
; we know that a.b < 2^61, so no problem with top bit of a.b
      [ NoARMv5
        MOV     R9, R11                         ; R9 = low 32 bits of shifted c
        MOV     R10, #0                         ; R10 = hi 32 bits of shifted c
10
        ADDS    R9, R9, R9                      ; shift R9,R10 left one place
        ADC     R10, R10, R10
        CMP     R9, R3                          ; compare R9,R10 with a.b
        SBCS    R14, R10, R8
        BCC     %BT10                           ; if lower then loop
      |
        CLZ     R9, R11
        TEQ     R8, #0
        CLZNE   R2, R8
        CLZEQ   R2, R3
        ADDNE   R9, R9, #32
        SUBS    R2, R9, R2                      ; R2 = how many bits to shift R11 left
        MOVLT   R3, #0
        Pull    "R8-R11,PC",LT

        MOV     R9, R11, LSL R2
        SUBS    R2, R2, #32
        MOVGE   R10, R11, LSL R2
        RSBLT   R2, R2, #0
        MOVLT   R10, R11, LSR R2
      ]

        MOV     R7, #0                          ; zero result
20
        CMP     R3, R9                          ; if a.b >= R9,R10
        SBCS    R14, R8, R10
        SUBCS   R3, R3, R9                      ; then a.b -:= R9,R10
        MOVCS   R8, R14
        ADC     R7, R7, R7                      ; shift result up with new bit
        MOVS    R10, R10, LSR #1                ; shift R9,R10 right one bit
        MOV     R9, R9, RRX
        BNE     %BT20                           ; for termination, R10 = 0
        CMP     R9, R11                         ; and R9 < R11
        BCS     %BT20

        BL      SquareRoot                      ; in: R7 = arg
                                                ; out: R8 = result, R9-R11 corrupt
        MOV     R3, R8
        Pull    "R8-R11,PC"



        END
@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a780 1
 [ No26bitCode
a782 4
 |
        CMP R0,R7               ;If  (CurrentX=CircleX) then farX is on circle
        TEQNE R5,PC             ;If ((CurrentX-CircleX) EOR StepX is +ve)
 ]
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d352 1
a352 1
;              1 0              ; (/        ; (\     ; (---/     ; (---\
d572 1
a572 1
        CMP   R3,#&03                           ; (-\
d581 1
a581 1
        CMP   R3,#&1E                           ; \-\
d781 4
d787 1
d1075 1
d1088 10
a1097 1

d1100 1
a1100 1

d1109 16
@


4.2.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d352 1
a352 1
;              1 0              ; (/        ; (\     ; (---/     ; (---\ 
d572 1
a572 1
        CMP   R3,#&03                           ; (-\ 
d581 1
a581 1
        CMP   R3,#&1E                           ; \-\ 
@


4.2.2.2
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a780 4
 [ No26bitCode
        SUBS R14,R0,R7          ;If  (CurrentX=CircleX) then farX is on circle
        TEQNE R5,R14            ;If ((CurrentX-CircleX) EOR StepX is +ve)
 |
a782 1
 ]
@


4.2.2.3
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@a1074 1
    [ NoARMM
d1087 1
a1087 10
    |
        ; Use UMULL
      [ NoARMv6
        ; Rn can't be RdLo/RdHi in ARMv5 and below
        MOV     R2, R3
        UMULL   R3, R8, R2, R8
      |
        UMULL   R3, R8, R3, R8
      ]
    ]
d1090 1
a1090 1
      [ NoARMv5
a1098 16
      |
        CLZ     R9, R11
        TEQ     R8, #0
        CLZNE   R2, R8
        CLZEQ   R2, R3
        ADDNE   R9, R9, #32
        SUBS    R2, R9, R2                      ; R2 = how many bits to shift R11 left
        MOVLT   R3, #0
        Pull    "R8-R11,PC",LT

        MOV     R9, R11, LSL R2
        SUBS    R2, R2, #32
        MOVGE   R10, R11, LSL R2
        RSBLT   R2, R2, #0
        MOVLT   R10, R11, LSR R2
      ]
@


4.1
log
@Initial revision
@
text
@d75 4
a78 5
        TEQ     R0, #0                          ; if xPnt<>0
        BLNE    AdvCircleParm                   ; then step to next point
        BNE     %BT10                           ; and go round again

        Pull    PC                              ; else finish
d462 1
a462 1
        MOVS    PC, R14
d581 1
a581 1
        CMP   R3,#&1E                           ; \-\ 
d635 1
a635 1
        MOVS PC,Link
d743 1
a743 1
;               Return first ('near') and last ('far') points of line 
d745 2
a746 2
;                 the circle if interception occurs.          
; 
d765 1
a765 1
;       
d801 1
a801 1
        MOV R7,#0               
d806 1
a806 1
; Assumes  R9, R10 & R11 are not corrupted over calls to GenLineParm 
d871 1
a871 1
        CMP R0,R9                       ;For gradients <,>,= 
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d945 1
d957 31
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

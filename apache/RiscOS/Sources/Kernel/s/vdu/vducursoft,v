head	4.6;
access;
symbols
	Kernel-6_14:4.6
	Kernel-6_01-3:4.6
	Kernel-6_13:4.6
	Kernel-6_12:4.6
	Kernel-6_11:4.6
	Kernel-6_10:4.6
	Kernel-6_09:4.6
	Kernel-6_08-4_129_2_10:4.6
	Kernel-6_08-4_129_2_9:4.6
	Kernel-6_08:4.6
	Kernel-6_07:4.6
	Kernel-6_06:4.6
	Kernel-6_05-4_129_2_8:4.6
	Kernel-6_05:4.6
	Kernel-6_04:4.6
	Kernel-6_03:4.6
	Kernel-6_01-2:4.6
	Kernel-6_01-4_146_2_1:4.6
	Kernel-6_02:4.6
	Kernel-6_01-1:4.6
	Kernel-6_01:4.6
	Kernel-6_00:4.6
	Kernel-5_99:4.6
	Kernel-5_98:4.6
	Kernel-5_97-4_129_2_7:4.6
	Kernel-5_97:4.6
	Kernel-5_96:4.6
	Kernel-5_95:4.6
	Kernel-5_94:4.6
	Kernel-5_93:4.6
	Kernel-5_92:4.6
	Kernel-5_91:4.6
	Kernel-5_90:4.6
	Kernel-5_89-4_129_2_6:4.6
	Kernel-5_89:4.6
	Kernel-5_88-4_129_2_5:4.6
	Kernel-5_88-4_129_2_4:4.6
	Kernel-5_88:4.6
	Kernel-5_87:4.6
	Kernel-5_86-4_129_2_3:4.6
	Kernel-5_86-4_129_2_2:4.6
	Kernel-5_86-4_129_2_1:4.6
	Kernel-5_86:4.6
	SMP:4.6.0.2
	SMP_bp:4.6
	Kernel-5_85:4.6
	Kernel-5_54-1:4.5
	Kernel-5_84:4.6
	Kernel-5_83:4.6
	Kernel-5_82:4.6
	Kernel-5_81:4.6
	Kernel-5_80:4.6
	Kernel-5_79:4.6
	Kernel-5_78:4.6
	Kernel-5_77:4.6
	Kernel-5_76:4.6
	Kernel-5_75:4.6
	Kernel-5_74:4.6
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.5
	Kernel-5_64:4.5
	Kernel-5_63:4.5
	Kernel-5_62:4.5
	Kernel-5_61:4.5
	Kernel-5_60:4.5
	Kernel-5_59:4.5
	Kernel-5_58:4.5
	Kernel-5_57:4.5
	Kernel-5_56:4.5
	Kernel-5_55:4.5
	Kernel-5_54:4.5
	Kernel-5_53:4.5
	Kernel-5_52:4.5
	Kernel-5_51:4.5
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.3.2.7
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.3.2.7
	Kernel-5_35-4_79_2_326:4.3.2.7
	Kernel-5_35-4_79_2_325:4.3.2.7
	Kernel-5_35-4_79_2_324:4.3.2.7
	Kernel-5_35-4_79_2_323:4.3.2.7
	Kernel-5_35-4_79_2_322:4.3.2.7
	Kernel-5_35-4_79_2_321:4.3.2.7
	Kernel-5_35-4_79_2_320:4.3.2.7
	Kernel-5_35-4_79_2_319:4.3.2.7
	Kernel-5_35-4_79_2_318:4.3.2.7
	Kernel-5_35-4_79_2_317:4.3.2.7
	Kernel-5_35-4_79_2_316:4.3.2.7
	Kernel-5_35-4_79_2_315:4.3.2.7
	Kernel-5_35-4_79_2_314:4.3.2.7
	Kernel-5_35-4_79_2_313:4.3.2.7
	Kernel-5_35-4_79_2_312:4.3.2.7
	Kernel-5_35-4_79_2_311:4.3.2.7
	Kernel-5_35-4_79_2_310:4.3.2.7
	Kernel-5_35-4_79_2_309:4.3.2.7
	Kernel-5_35-4_79_2_308:4.3.2.7
	Kernel-5_35-4_79_2_307:4.3.2.7
	Kernel-5_35-4_79_2_306:4.3.2.7
	Kernel-5_35-4_79_2_305:4.3.2.7
	Kernel-5_35-4_79_2_304:4.3.2.7
	Kernel-5_35-4_79_2_303:4.3.2.7
	Kernel-5_35-4_79_2_302:4.3.2.7
	Kernel-5_35-4_79_2_301:4.3.2.7
	Kernel-5_35-4_79_2_300:4.3.2.7
	Kernel-5_35-4_79_2_299:4.3.2.7
	Kernel-5_35-4_79_2_298:4.3.2.7
	Kernel-5_35-4_79_2_297:4.3.2.7
	Kernel-5_35-4_79_2_296:4.3.2.7
	Kernel-5_35-4_79_2_295:4.3.2.7
	Kernel-5_35-4_79_2_294:4.3.2.7
	Kernel-5_35-4_79_2_293:4.3.2.7
	Kernel-5_35-4_79_2_292:4.3.2.7
	Kernel-5_35-4_79_2_291:4.3.2.7
	Kernel-5_35-4_79_2_290:4.3.2.7
	Kernel-5_35-4_79_2_289:4.3.2.7
	Kernel-5_35-4_79_2_288:4.3.2.7
	Kernel-5_35-4_79_2_287:4.3.2.7
	Kernel-5_35-4_79_2_286:4.3.2.7
	Kernel-5_35-4_79_2_285:4.3.2.7
	Kernel-5_35-4_79_2_284:4.3.2.7
	Kernel-5_35-4_79_2_283:4.3.2.7
	Kernel-5_35-4_79_2_282:4.3.2.7
	Kernel-5_35-4_79_2_281:4.3.2.7
	Kernel-5_35-4_79_2_280:4.3.2.7
	Kernel-5_35-4_79_2_279:4.3.2.7
	Kernel-5_35-4_79_2_278:4.3.2.7
	Kernel-5_35-4_79_2_277:4.3.2.7
	Kernel-5_35-4_79_2_276:4.3.2.7
	Kernel-5_35-4_79_2_275:4.3.2.7
	Kernel-5_35-4_79_2_274:4.3.2.7
	Kernel-5_35-4_79_2_273:4.3.2.7
	Kernel-5_35-4_79_2_272:4.3.2.7
	Kernel-5_35-4_79_2_271:4.3.2.7
	Kernel-5_35-4_79_2_270:4.3.2.7
	Kernel-5_35-4_79_2_269:4.3.2.7
	Kernel-5_35-4_79_2_268:4.3.2.6
	Kernel-5_35-4_79_2_267:4.3.2.6
	Kernel-5_35-4_79_2_266:4.3.2.6
	Kernel-5_35-4_79_2_265:4.3.2.6
	Kernel-5_35-4_79_2_264:4.3.2.6
	Kernel-5_35-4_79_2_263:4.3.2.6
	Kernel-5_35-4_79_2_262:4.3.2.6
	Kernel-5_35-4_79_2_261:4.3.2.6
	Kernel-5_35-4_79_2_260:4.3.2.6
	Kernel-5_35-4_79_2_259:4.3.2.6
	Kernel-5_35-4_79_2_258:4.3.2.6
	Kernel-5_35-4_79_2_257:4.3.2.6
	Kernel-5_35-4_79_2_256:4.3.2.6
	Kernel-5_35-4_79_2_255:4.3.2.6
	Kernel-5_35-4_79_2_254:4.3.2.6
	Kernel-5_35-4_79_2_253:4.3.2.6
	Kernel-5_35-4_79_2_252:4.3.2.6
	Kernel-5_35-4_79_2_251:4.3.2.6
	Kernel-5_35-4_79_2_250:4.3.2.6
	Kernel-5_35-4_79_2_249:4.3.2.6
	Kernel-5_35-4_79_2_248:4.3.2.6
	Kernel-5_35-4_79_2_247:4.3.2.6
	Kernel-5_35-4_79_2_246:4.3.2.6
	Kernel-5_35-4_79_2_245:4.3.2.6
	Kernel-5_35-4_79_2_244:4.3.2.6
	Kernel-5_35-4_79_2_243:4.3.2.6
	Kernel-5_35-4_79_2_242:4.3.2.6
	Kernel-5_35-4_79_2_241:4.3.2.6
	Kernel-5_35-4_79_2_240:4.3.2.6
	Kernel-5_35-4_79_2_239:4.3.2.6
	Kernel-5_35-4_79_2_238:4.3.2.6
	Kernel-5_35-4_79_2_237:4.3.2.6
	Kernel-5_35-4_79_2_236:4.3.2.6
	Kernel-5_35-4_79_2_235:4.3.2.6
	Kernel-5_35-4_79_2_234:4.3.2.6
	Kernel-5_35-4_79_2_233:4.3.2.6
	Kernel-5_35-4_79_2_232:4.3.2.6
	Kernel-5_35-4_79_2_231:4.3.2.6
	Kernel-5_35-4_79_2_230:4.3.2.6
	Kernel-5_35-4_79_2_229:4.3.2.6
	Kernel-5_35-4_79_2_228:4.3.2.6
	Kernel-5_35-4_79_2_227:4.3.2.6
	Kernel-5_35-4_79_2_226:4.3.2.6
	Kernel-5_35-4_79_2_225:4.3.2.6
	Kernel-5_35-4_79_2_224:4.3.2.6
	Kernel-5_35-4_79_2_223:4.3.2.6
	Kernel-5_35-4_79_2_222:4.3.2.6
	Kernel-5_35-4_79_2_221:4.3.2.6
	Kernel-5_35-4_79_2_220:4.3.2.6
	Kernel-5_35-4_79_2_219:4.3.2.6
	Kernel-5_35-4_79_2_218:4.3.2.6
	Kernel-5_35-4_79_2_217:4.3.2.6
	Kernel-5_35-4_79_2_216:4.3.2.6
	Kernel-5_35-4_79_2_215:4.3.2.6
	Kernel-5_35-4_79_2_214:4.3.2.6
	Kernel-5_35-4_79_2_213:4.3.2.6
	Kernel-5_35-4_79_2_212:4.3.2.6
	Kernel-5_35-4_79_2_211:4.3.2.6
	Kernel-5_35-4_79_2_210:4.3.2.6
	Kernel-5_35-4_79_2_209:4.3.2.6
	Kernel-5_35-4_79_2_208:4.3.2.6
	Kernel-5_35-4_79_2_207:4.3.2.6
	Kernel-5_35-4_79_2_206:4.3.2.6
	Kernel-5_35-4_79_2_205:4.3.2.6
	Kernel-5_35-4_79_2_204:4.3.2.6
	Kernel-5_35-4_79_2_203:4.3.2.6
	Kernel-5_35-4_79_2_202:4.3.2.5
	Kernel-5_35-4_79_2_201:4.3.2.5
	Kernel-5_35-4_79_2_200:4.3.2.5
	Kernel-5_35-4_79_2_199:4.3.2.5
	Kernel-5_35-4_79_2_198:4.3.2.5
	Kernel-5_35-4_79_2_197:4.3.2.5
	Kernel-5_35-4_79_2_196:4.3.2.5
	Kernel-5_35-4_79_2_195:4.3.2.5
	Kernel-5_35-4_79_2_194:4.3.2.5
	Kernel-5_35-4_79_2_193:4.3.2.4
	Kernel-5_35-4_79_2_192:4.3.2.4
	Kernel-5_35-4_79_2_191:4.3.2.4
	Kernel-5_35-4_79_2_190:4.3.2.4
	Kernel-5_35-4_79_2_189:4.3.2.4
	Kernel-5_35-4_79_2_188:4.3.2.4
	Kernel-5_35-4_79_2_187:4.3.2.4
	Kernel-5_35-4_79_2_186:4.3.2.4
	Kernel-5_35-4_79_2_185:4.3.2.4
	Kernel-5_35-4_79_2_184:4.3.2.4
	Kernel-5_35-4_79_2_183:4.3.2.4
	Kernel-5_35-4_79_2_182:4.3.2.4
	Kernel-5_35-4_79_2_181:4.3.2.4
	Kernel-5_35-4_79_2_180:4.3.2.4
	Kernel-5_35-4_79_2_179:4.3.2.4
	Kernel-5_35-4_79_2_178:4.3.2.3
	Kernel-5_35-4_79_2_177:4.3.2.3
	Kernel-5_35-4_79_2_176:4.3.2.3
	Kernel-5_35-4_79_2_175:4.3.2.3
	Kernel-5_35-4_79_2_174:4.3.2.3
	Kernel-5_35-4_79_2_173:4.3.2.3
	Kernel-5_35-4_79_2_172:4.3.2.3
	Kernel-5_35-4_79_2_171:4.3.2.3
	Kernel-5_35-4_79_2_170:4.3.2.3
	Kernel-5_35-4_79_2_169:4.3.2.3
	Kernel-5_35-4_79_2_168:4.3.2.3
	Kernel-5_35-4_79_2_167:4.3.2.3
	Kernel-5_35-4_79_2_166:4.3.2.3
	Kernel-5_35-4_79_2_165:4.3.2.3
	RPi_merge:4.3.2.2.6.2
	Kernel-5_35-4_79_2_147_2_23:4.3.2.2.6.2
	Kernel-5_35-4_79_2_147_2_22:4.3.2.2.6.2
	Kernel-5_35-4_79_2_147_2_21:4.3.2.2.6.2
	Kernel-5_35-4_79_2_147_2_20:4.3.2.2.6.2
	Kernel-5_35-4_79_2_147_2_19:4.3.2.2.6.1
	Kernel-5_35-4_79_2_147_2_18:4.3.2.2.6.1
	Kernel-5_35-4_79_2_164:4.3.2.2
	Kernel-5_35-4_79_2_163:4.3.2.2
	Kernel-5_35-4_79_2_147_2_17:4.3.2.2.6.1
	Kernel-5_35-4_79_2_147_2_16:4.3.2.2.6.1
	Kernel-5_35-4_79_2_147_2_15:4.3.2.2.6.1
	Kernel-5_35-4_79_2_162:4.3.2.2
	Kernel-5_35-4_79_2_161:4.3.2.2
	Kernel-5_35-4_79_2_147_2_14:4.3.2.2.6.1
	Kernel-5_35-4_79_2_147_2_13:4.3.2.2.6.1
	Kernel-5_35-4_79_2_160:4.3.2.2
	Kernel-5_35-4_79_2_159:4.3.2.2
	Kernel-5_35-4_79_2_158:4.3.2.2
	Kernel-5_35-4_79_2_157:4.3.2.2
	Kernel-5_35-4_79_2_156:4.3.2.2
	Kernel-5_35-4_79_2_147_2_12:4.3.2.2.6.1
	Kernel-5_35-4_79_2_147_2_11:4.3.2.2.6.1
	Kernel-5_35-4_79_2_155:4.3.2.2
	Kernel-5_35-4_79_2_147_2_10:4.3.2.2.6.1
	Kernel-5_35-4_79_2_154:4.3.2.2
	Kernel-5_35-4_79_2_153:4.3.2.2
	Kernel-5_35-4_79_2_147_2_9:4.3.2.2.6.1
	Kernel-5_35-4_79_2_152:4.3.2.2
	Kernel-5_35-4_79_2_151:4.3.2.2
	Kernel-5_35-4_79_2_147_2_8:4.3.2.2.6.1
	Kernel-5_35-4_79_2_147_2_7:4.3.2.2.6.1
	Kernel-5_35-4_79_2_150:4.3.2.2
	Kernel-5_35-4_79_2_147_2_6:4.3.2.2.6.1
	Kernel-5_35-4_79_2_147_2_5:4.3.2.2.6.1
	Kernel-5_35-4_79_2_149:4.3.2.2
	Kernel-5_35-4_79_2_147_2_4:4.3.2.2.6.1
	Kernel-5_35-4_79_2_147_2_3:4.3.2.2.6.1
	Kernel-5_35-4_79_2_148:4.3.2.2
	Kernel-5_35-4_79_2_147_2_2:4.3.2.2.6.1
	Kernel-5_35-4_79_2_147_2_1:4.3.2.2.6.1
	RPi:4.3.2.2.0.6
	RPi_bp:4.3.2.2
	Kernel-5_35-4_79_2_98_2_52_2_1:4.3.2.2.4.1
	alees_Kernel_dev:4.3.2.2.0.4
	alees_Kernel_dev_bp:4.3.2.2
	Kernel-5_35-4_79_2_147:4.3.2.2
	Kernel-5_35-4_79_2_146:4.3.2.2
	Kernel-5_35-4_79_2_145:4.3.2.2
	Kernel-5_35-4_79_2_144:4.3.2.2
	Kernel-5_35-4_79_2_143:4.3.2.2
	Kernel-5_35-4_79_2_142:4.3.2.2
	Kernel-5_35-4_79_2_141:4.3.2.2
	Kernel-5_35-4_79_2_140:4.3.2.2
	Kernel-5_35-4_79_2_139:4.3.2.2
	Kernel-5_35-4_79_2_138:4.3.2.2
	Kernel-5_35-4_79_2_137:4.3.2.2
	Kernel-5_35-4_79_2_136:4.3.2.2
	Kernel-5_35-4_79_2_135:4.3.2.2
	Kernel-5_35-4_79_2_134:4.3.2.2
	Kernel-5_35-4_79_2_133:4.3.2.2
	Kernel-5_35-4_79_2_132:4.3.2.2
	Kernel-5_35-4_79_2_131:4.3.2.2
	Kernel-5_35-4_79_2_130:4.3.2.2
	Kernel-5_35-4_79_2_129:4.3.2.2
	Kernel-5_35-4_79_2_128:4.3.2.2
	Kernel-5_35-4_79_2_127:4.3.2.2
	Kernel-5_35-4_79_2_126:4.3.2.2
	Kernel-5_35-4_79_2_125:4.3.2.2
	Kernel-5_35-4_79_2_124:4.3.2.2
	Kernel-5_35-4_79_2_123:4.3.2.2
	Cortex_merge:4.3.2.2
	Kernel-5_35-4_79_2_122:4.3.2.2
	Kernel-5_35-4_79_2_98_2_54:4.3.2.2
	Kernel-5_35-4_79_2_98_2_53:4.3.2.2
	Kernel-5_35-4_79_2_98_2_52:4.3.2.2
	Kernel-5_35-4_79_2_98_2_51:4.3.2.2
	Kernel-5_35-4_79_2_98_2_50:4.3.2.2
	Kernel-5_35-4_79_2_98_2_49:4.3.2.2
	Kernel-5_35-4_79_2_98_2_48:4.3.2.2
	Kernel-5_35-4_79_2_121:4.3.2.2
	Kernel-5_35-4_79_2_98_2_47:4.3.2.2
	Kernel-5_35-4_79_2_120:4.3.2.2
	Kernel-5_35-4_79_2_98_2_46:4.3.2.2
	Kernel-5_35-4_79_2_119:4.3.2.2
	Kernel-5_35-4_79_2_98_2_45:4.3.2.2
	Kernel-5_35-4_79_2_98_2_44:4.3.2.2
	Kernel-5_35-4_79_2_118:4.3.2.2
	Kernel-5_35-4_79_2_98_2_43:4.3.2.2
	Kernel-5_35-4_79_2_117:4.3.2.2
	Kernel-5_35-4_79_2_116:4.3.2.2
	Kernel-5_35-4_79_2_98_2_42:4.3.2.2
	Kernel-5_35-4_79_2_115:4.3.2.2
	Kernel-5_35-4_79_2_98_2_41:4.3.2.2
	Kernel-5_35-4_79_2_98_2_40:4.3.2.2
	Kernel-5_35-4_79_2_114:4.3.2.2
	Kernel-5_35-4_79_2_98_2_39:4.3.2.2
	Kernel-5_35-4_79_2_98_2_38:4.3.2.2
	Kernel-5_35-4_79_2_113:4.3.2.2
	Kernel-5_35-4_79_2_112:4.3.2.2
	Kernel-5_35-4_79_2_98_2_37:4.3.2.2
	Kernel-5_35-4_79_2_98_2_36:4.3.2.2
	Kernel-5_35-4_79_2_98_2_35:4.3.2.2
	Kernel-5_35-4_79_2_98_2_34:4.3.2.2
	Kernel-5_35-4_79_2_98_2_33:4.3.2.2
	Kernel-5_35-4_79_2_98_2_32:4.3.2.2
	Kernel-5_35-4_79_2_98_2_31:4.3.2.2
	Kernel-5_35-4_79_2_98_2_30:4.3.2.2
	Kernel-5_35-4_79_2_98_2_29:4.3.2.2
	Kernel-5_35-4_79_2_98_2_28:4.3.2.2
	Kernel-5_35-4_79_2_98_2_27:4.3.2.2
	Kernel-5_35-4_79_2_98_2_26:4.3.2.2
	Kernel-5_35-4_79_2_111:4.3.2.2
	Kernel-5_35-4_79_2_98_2_25:4.3.2.2
	Kernel-5_35-4_79_2_98_2_24:4.3.2.2
	Kernel-5_35-4_79_2_98_2_23:4.3.2.2
	Kernel-5_35-4_79_2_110:4.3.2.2
	Kernel-5_35-4_79_2_98_2_22:4.3.2.2
	Kernel-5_35-4_79_2_109:4.3.2.2
	Kernel-5_35-4_79_2_98_2_21:4.3.2.2
	Kernel-5_35-4_79_2_98_2_20:4.3.2.2
	Kernel-5_35-4_79_2_108:4.3.2.2
	Kernel-5_35-4_79_2_107:4.3.2.2
	Kernel-5_35-4_79_2_98_2_19:4.3.2.2
	Kernel-5_35-4_79_2_98_2_18:4.3.2.2
	Kernel-5_35-4_79_2_98_2_17:4.3.2.2
	Kernel-5_35-4_79_2_98_2_16:4.3.2.2
	Kernel-5_35-4_79_2_98_2_15:4.3.2.2
	Kernel-5_35-4_79_2_106:4.3.2.2
	Kernel-5_35-4_79_2_105:4.3.2.2
	Kernel-5_35-4_79_2_104:4.3.2.2
	Kernel-5_35-4_79_2_98_2_14:4.3.2.2
	Kernel-5_35-4_79_2_98_2_13:4.3.2.2
	Kernel-5_35-4_79_2_98_2_12:4.3.2.2
	Kernel-5_35-4_79_2_98_2_11:4.3.2.2
	Kernel-5_35-4_79_2_98_2_10:4.3.2.2
	Kernel-5_35-4_79_2_98_2_9:4.3.2.2
	Kernel-5_35-4_79_2_103:4.3.2.2
	Kernel-5_35-4_79_2_102:4.3.2.2
	Kernel-5_35-4_79_2_98_2_8:4.3.2.2
	Kernel-5_35-4_79_2_98_2_7:4.3.2.2
	Kernel-5_35-4_79_2_98_2_6:4.3.2.2
	Kernel-5_35-4_79_2_98_2_5:4.3.2.2
	Kernel-5_35-4_79_2_98_2_4:4.3.2.2
	Kernel-5_35-4_79_2_101:4.3.2.2
	Kernel-5_35-4_79_2_100:4.3.2.2
	Kernel-5_35-4_79_2_99:4.3.2.2
	Kernel-5_35-4_79_2_98_2_3:4.3.2.2
	Kernel-5_35-4_79_2_98_2_2:4.3.2.2
	Kernel-5_35-4_79_2_98_2_1:4.3.2.2
	Cortex:4.3.2.2.0.2
	Cortex_bp:4.3.2.2
	Kernel-5_35-4_79_2_98:4.3.2.2
	Kernel-5_35-4_79_2_97:4.3.2.2
	Kernel-5_35-4_79_2_96:4.3.2.2
	Kernel-5_35-4_79_2_95:4.3.2.2
	Kernel-5_35-4_79_2_94:4.3.2.2
	Kernel-5_35-4_79_2_93:4.3.2.2
	Kernel-5_35-4_79_2_92:4.3.2.2
	Kernel-5_35-4_79_2_91:4.3.2.2
	Kernel-5_35-4_79_2_90:4.3.2.2
	Kernel-5_35-4_79_2_89:4.3.2.2
	Kernel-5_35-4_79_2_88:4.3.2.2
	Kernel-5_35-4_79_2_87:4.3.2.2
	Kernel-5_35-4_79_2_86:4.3.2.2
	Kernel-5_35-4_79_2_85:4.3.2.2
	Kernel-5_35-4_79_2_84:4.3.2.2
	Kernel-5_35-4_79_2_83:4.3.2.2
	Kernel-5_35-4_79_2_82:4.3.2.2
	Kernel-5_35-4_79_2_81:4.3.2.2
	Kernel-5_35-4_79_2_80:4.3.2.2
	Kernel-5_35-4_79_2_79:4.3.2.2
	Kernel-5_35-4_79_2_78:4.3.2.2
	Kernel-5_35-4_79_2_77:4.3.2.2
	RO_5_07:4.3.2.2
	Kernel-5_35-4_79_2_76:4.3.2.2
	Kernel-5_35-4_79_2_75:4.3.2.2
	Kernel-5_35-4_79_2_74:4.3.2.2
	Kernel-5_35-4_79_2_73:4.3.2.2
	Kernel-5_35-4_79_2_72:4.3.2.2
	Kernel-5_35-4_79_2_71:4.3.2.2
	Kernel-5_35-4_79_2_70:4.3.2.2
	Kernel-5_35-4_79_2_69:4.3.2.2
	Kernel-5_35-4_79_2_68:4.3.2.2
	Kernel-5_35-4_79_2_67:4.3.2.2
	Kernel-5_35-4_79_2_66:4.3.2.2
	Kernel-5_35-4_79_2_65:4.3.2.2
	Kernel-5_35-4_79_2_64:4.3.2.2
	Kernel-5_35-4_79_2_63:4.3.2.2
	Kernel-5_35-4_79_2_62:4.3.2.2
	Kernel-5_35-4_79_2_61:4.3.2.2
	Kernel-5_35-4_79_2_59:4.3.2.2
	Kernel-5_35-4_79_2_58:4.3.2.2
	Kernel-5_35-4_79_2_57:4.3.2.2
	Kernel-5_35-4_79_2_56:4.3.2.2
	Kernel-5_35-4_79_2_55:4.3.2.2
	Kernel-5_35-4_79_2_54:4.3.2.2
	Kernel-5_35-4_79_2_53:4.3.2.2
	Kernel-5_35-4_79_2_52:4.3.2.1
	Kernel-5_35-4_79_2_51:4.3.2.1
	Kernel-5_35-4_79_2_50:4.3.2.1
	Kernel-5_35-4_79_2_49:4.3.2.1
	Kernel-5_35-4_79_2_48:4.3.2.1
	Kernel-5_47:4.3
	Kernel-5_46-4_90_2_1:4.3
	nbingham_Kernel_FastNC_dev_bp:4.3
	nbingham_Kernel_FastNC_dev:4.3.0.4
	Kernel-5_46:4.3
	Kernel-5_45:4.3
	Kernel-5_35-4_79_2_47:4.3.2.1
	Kernel-5_35-4_79_2_46:4.3.2.1
	Kernel-5_35-4_79_2_45:4.3.2.1
	Kernel-5_35-4_79_2_44:4.3.2.1
	Kernel-5_35-4_79_2_25_2_2:4.3.2.1
	Kernel-5_35-4_79_2_43:4.3.2.1
	Kernel-5_35-4_79_2_42:4.3.2.1
	Kernel-5_35-4_79_2_41:4.3.2.1
	Kernel-5_35-4_79_2_40:4.3.2.1
	Kernel-5_35-4_79_2_39:4.3.2.1
	Kernel-5_35-4_79_2_38:4.3.2.1
	Kernel-5_35-4_79_2_37:4.3.2.1
	Kernel-5_35-4_79_2_36:4.3.2.1
	Kernel-5_35-4_79_2_35:4.3.2.1
	Kernel-5_35-4_79_2_34:4.3.2.1
	Kernel-5_35-4_79_2_33:4.3.2.1
	Kernel-5_35-4_79_2_32:4.3.2.1
	Kernel-5_44:4.3
	Kernel-5_35-4_79_2_25_2_1:4.3.2.1
	Kernel-5_43:4.3
	Kernel-5_35-4_79_2_31:4.3.2.1
	Kernel-5_35-4_79_2_30:4.3.2.1
	Kernel-5_35-4_79_2_29:4.3.2.1
	Kernel-5_35-4_79_2_28:4.3.2.1
	Kernel-5_35-4_79_2_27:4.3.2.1
	Kernel-5_35-4_79_2_26:4.3.2.1
	Kernel-5_42:4.3
	Kernel-5_41:4.3
	Kernel-5_40:4.3
	Kernel-5_35-4_79_2_25:4.3.2.1
	Kernel-5_35-4_79_2_24:4.3.2.1
	Kernel-5_35-4_79_2_23:4.3.2.1
	Kernel-5_35-4_79_2_22:4.3.2.1
	Kernel-5_35-4_79_2_21:4.3.2.1
	Kernel-5_35-4_79_2_20:4.3.2.1
	Kernel-5_35-4_79_2_19:4.3.2.1
	Kernel-5_35-4_79_2_18:4.3.2.1
	Kernel-5_35-4_79_2_17:4.3.2.1
	Kernel-5_35-4_79_2_16:4.3.2.1
	Kernel-5_35-4_79_2_15:4.3.2.1
	Kernel-5_35-4_79_2_14:4.3.2.1
	Kernel-5_39:4.3
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.10
	Kernel-5_38:4.3
	Kernel-5_35-4_79_2_13:4.3.2.1
	Kernel-5_35-4_79_2_12:4.3.2.1
	Kernel-5_35-4_79_2_11:4.3.2.1
	Kernel-5_37:4.3
	Kernel-5_35-4_79_2_10:4.3.2.1
	Kernel-5_35-4_79_2_9:4.3.2.1
	Kernel-5_36:4.3
	Kernel-5_35-4_79_2_8:4.3.2.1
	Kernel-5_35-4_79_2_7:4.3.2.1
	Kernel-5_35-4_79_2_6:4.3.2.1
	Kernel-5_35-4_79_2_5:4.3.2.1
	Kernel-5_35-4_79_2_4:4.3.2.1
	Kernel-5_35-4_79_2_3:4.3.2.1
	Kernel-5_35-4_79_2_2:4.3.2.1
	dellis_autobuild_BaseSW:4.3
	Kernel-5_35-4_79_2_1:4.3.2.1
	HAL:4.3.0.2
	Kernel-5_35:4.3
	Kernel-5_34:4.3
	Kernel-5_33:4.3
	Kernel-5_32:4.3
	Kernel-5_31:4.3
	Kernel-5_30:4.3
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.3
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1
	Ursula_RiscPC_bp:4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	mstphens_Kernel-3_80:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2016.12.15.15.27.03;	author jlee;	state Exp;
branches;
next	4.5;
commitid	SNoEvPlWCrTKR5yz;

4.5
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches;
next	4.4;
commitid	skOEjp3ipLHx6xcz;

4.4
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.3;
commitid	IWoXxARWeuLDOwcz;

4.3
date	2000.06.28.16.12.26;	author bavison;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	2000.04.04.14.27.39;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.33;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2002.12.18.22.18.33;	author bavison;	state Exp;
branches
	4.3.2.2.4.1
	4.3.2.2.6.1;
next	4.3.2.3;

4.3.2.3
date	2012.09.18.22.01.21;	author jlee;	state Exp;
branches;
next	4.3.2.4;
commitid	eFa3Y1QY0MjZP3lw;

4.3.2.4
date	2012.12.05.02.03.07;	author jlee;	state Exp;
branches;
next	4.3.2.5;
commitid	2qluFMz4Ck6yHYuw;

4.3.2.5
date	2013.08.06.22.43.09;	author jlee;	state Exp;
branches;
next	4.3.2.6;
commitid	TOIaeUf2Q4rBIr0x;

4.3.2.6
date	2013.12.15.21.34.11;	author jlee;	state Exp;
branches;
next	4.3.2.7;
commitid	KwuK29hKRyXO7hhx;

4.3.2.7
date	2015.07.10.20.16.42;	author jlee;	state Exp;
branches;
next	;
commitid	wa0i3ESGlbkojMsy;

4.3.2.2.4.1
date	2012.05.10.03.09.59;	author bavison;	state Exp;
branches;
next	;
commitid	HTVG5Da5tRqSM74w;

4.3.2.2.6.1
date	2012.05.10.03.28.12;	author bavison;	state Exp;
branches;
next	4.3.2.2.6.2;
commitid	kuJoT3AcfB16T74w;

4.3.2.2.6.2
date	2012.09.07.23.05.57;	author jlee;	state Exp;
branches;
next	;
commitid	Ik0jMROsIiH5yEjw;

4.1.1.1
date	96.11.05.09.41.33;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.02.31;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.45;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.27;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Add support for custom teletext modes
Detail:
  This set of changes:
  * Adds support for the T, TX and TY mode string elements (as per RISCOS Ltd)
  * Adds support for entering arbitrary-resolution teletext modes by using mode selector blocks with the Teletext mode flag set
  * ScrRCol and ScrBRow mode variables can be provided in the mode selector in order to restrict the number of text rows/columns in teletext modes (as per RISCOS Ltd)
  * If the rows / columns are restricted in this manner then the text window will be centered on the screen, to try and avoid things looking too ugly (no variable text scaling implemented)
  * For HiResTTX, all colour depths >= 4bpp are now supported by teletext. This essentially makes the TTX256 switch obsolete.
  * If the "native" mode 7 is unavailable then the kernel will try a series of fallback resolutions & colour depths in an effort to find a combination that works
  Known bugs/issues:
  * Teletext column count has a max limit of 255 due to TTXDoubleCounts being a byte array
  * If there's a border around the text window, the border will not be refreshed when changing transparency modes using a VDU 23,18,0 sequence
  * ScreenLoad looks like it can overflow the LargeCommon buffer (no buffer size check) - needs fixing before LargeCommon can be safely shrunk below (Old)TTXMapSize
  File changes:
  - hdr/KernelWS - Make CharWidth non-conditional. Adjust handling of teletext workspace; it's now allocated from the system heap to allow it to cope with arbitrary screen sizes
  - s/vdu/vdu23 - Make CharWidth non-conditional
  - s/vdu/vducursoft - Make CursorTeletext cope with arbitrary colour depths, make CharWidth non-conditional, remove hard-coded teletext values
  - s/vdu/vdudriver - Deal with teletext workspace allocation during ModeChangeSub. Deal with selecting teletext modes (and validating colour depth) in GenerateModeSelectorVars.
  - s/vdu/vdugrafl - Make CharWidth non-conditional. Calculate offset required for text window centering.
  - s/vdu/vdumodes - Remove TTX256
  - s/vdu/vduswis - Try other teletext modes if native mode 7 not available. Extend OS_ScreenMode reason codes to cope with teletext mode strings.
  - s/vdu/vduttx - Update to use dynamic workspace. Replace various hardcoded values with variable lookups. Update character plotting + colour/palette selection to work with true-colour modes if HiResTTX.
  - s/vdu/vduwrch - Move some useful code into a subroutine. Update FastCLS to cope with true-colour teletext. Update AddressR0R1 to cope with text window centering offset. Make CharWidth non-conditional.
Admin:
  Tested on Raspberry Pi, BB-xM
  VDU 23,18,0 in 256-colour teletext now works correctly (previously 64-colour mode was in use, causing palette update to be ruined by VIDC1-mangling)


Version 5.74. Tagged as 'Kernel-5_74'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduCurSoft

SlowCursorSpeed * 16
FastCursorSpeed * 8
OnFlashTime * 48
OffFlashTime * 16

;       InitCursor - initialise cursor shape and address

InitCursor ROUT
        Push    R14
        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #TeletextMode               ; if teletext mode
        MOVNE   R0, #&72                        ; then start at 9 (slow flash)
        MOVEQ   R0, #&67                        ; else start at 7 (slow flash)
        BL      ProgReg10AndCopy

        MOV     R0, #1                          ; set to flash immediately
        STR     R0, [WsPtr, #CursorCounter]     ; AFTER setting CursorSpeed
                                                ; in case VSYNC happens
        LDR     R1, [WsPtr, #VduSprite]
        TEQ     R1, #0                          ; if outputting to sprite
        MOVNE   R0, #&20                        ; then turn cursor off
        BLNE    ProgReg10AndCopy

        LDR     R0, [WsPtr, #RowMult]           ; 8 or 10 or 16 or 20
        Pull    R14

; and drop thru to ...

SetCursorBottom
        LDR     R1, [WsPtr, #LineLength]
        MUL     R2, R1, R0
        STR     R2, [WsPtr, #CursorEndOffset]
        MOV     PC, R14

SetCursorTop
        LDR     R1, [WsPtr, #LineLength]
        MUL     R2, R1, R0
        STR     R2, [WsPtr, #CursorStartOffset]
        MOV     PC, R14

; *****************************************************************************

; Cursors are split, so remove output cursor

DoOutputCursor ROUT
        Push    R14
        LDR     R1, [WsPtr, #LineLength]
        MOV     R1, R1, LSL #3                  ; and end after 8 rows
        LDR     R0, [WsPtr, #ModeFlags]
        TST     R0, #ModeFlag_DoubleVertical    ; if double vertical
        ADDNE   R1, R1, R1                      ; end after 16 rows
        MOV     R0, #0                          ; start on top line
        BL      EORCursor
        LDR     R2, [WsPtr, #InputCursorAddr]   ; flashing cursor is at input
        Pull    R14
        B       PreWC10

; *****************************************************************************
;
;       PreWrchCursor - Remove cursors prior to Wrch
;
; out:  R6 = new CursorFlags; R5,R7 preserved; others corrupted
;

PreWrchCursor

; Need to disable IRQs here to stop Vsync modifying CursorFlags in between
; us reading it and writing it

        MRS     R3, CPSR
        ORR     R1, R3, #I32_bit
        MSR     CPSR_c, R1

        LDR     R6, [WsPtr, #CursorFlags]
        MOVS    R0, R6, LSL #(32-InWrchBitPosn) ; CS => was already off
        ORRCC   R6, R6, #InWrchBit              ; protect against vsyncs
        STRCC   R6, [WsPtr, #CursorFlags]

        LDR     R0, [WsPtr, #CursorStack]
        MOV     R0, R0, RRX                     ; shift down + put current
                                                ; state in top bit
        STR     R0, [WsPtr, #CursorStack]

        MSR     CPSR_c, R3                      ; restore old I bit

        MOV     R2,R14                          ; n.b. calling remove even if
        LDR     R14, [WsPtr, #SWP_Under]        ; soft pointer not currently
        TEQ     R14, #0                         ; visible. This sets the lock, 
        BLNE    RemovePointer                   ; preventing it from being      
        MOV     R14,R2                          ; turned on while we're busy.

        MOVCS   PC, R14                         ; already off, so exit

        LDR     R2, [WsPtr, #CursorAddr]        ; point to output
        TST     R6, #CursorsSplit
        BNE     DoOutputCursor
PreWC10
        TST     R6, #ActualState
        MOVEQ   PC, R14                         ; flash cursor is off anyway
        BIC     R6, R6, #ActualState
        STR     R6, [WsPtr, #CursorFlags]

; and drop thru to EORFlashCursor

; *****************************************************************************
;
;       EORCursor - Exclusive-OR cursor with screen
;
; in:   R0 = Start offset from top of cursor
;       R1 = End+1 offset
;       R2 = Screen address of appropriate cursor
;       R6 = CursorFlags
;
; out:  R5-R7 preserved; R0-R4, R8-R11 corrupted
;

EORFlashCursor
        ASSERT  CursorEndOffset-CursorStartOffset=4
        ADD     R0, WsPtr, #CursorStartOffset
        LDMIA   R0, {R0,R1}
EORCursor
        CMP     R0, R1
        MOVCS   PC, R14                 ; top >= bottom, so nowt

        ADD     R1, R1, R2

        LDR     R3, [WsPtr, #LineLength]

        ASSERT  CursorNbit = CursorFill +4
        ADD     R4, WsPtr, #CursorFill
        LDMIA   R4, {R4, PC}            ; load CursorFill and CursorNbit

Cursor1bit
        LDRB    R8, [R0, R2]!
        EOR     R8, R8, R4
        STRB    R8, [R0], R3
        TEQ     R0, R1
        MOVEQ   PC, R14
Cursor1loop
        LDRB    R8, [R0]
        EOR     R8, R8, R4
        STRB    R8, [R0], R3
        TEQ     R0, R1
        BNE     Cursor1loop
        MOV     PC, R14

Cursor2bit
        ADD     R0, R0, R2
Cursor2loop
        LDRB    R8, [R0, #1]
        EOR     R8, R8, R4
        STRB    R8, [R0, #1]
        LDRB    R8, [R0]
        EOR     R8, R8, R4
        STRB    R8, [R0], R3
        TEQ     R0, R1
        BNE     Cursor2loop
        MOV     PC, R14

CursorTeletext
        Push    "R0, R1, R3, R5, R14"
        LDR     R14, [WsPtr, #ScreenSize]
        ADD     R0, R0, R14, LSR #1             ; go to other screen
        ADD     R1, R1, R14, LSR #1
        LDR     R5, [WsPtr, #Log2BPC]
        ADRL    R14, CursorNbitTab
      [ HiResTTX
        ADD     R5, R5, #1
      ]
        LDR     R5, [R14, R5, LSL #2]
        ADD     R5, R5, R14
      [ NoARMv5
        MOV     R14, PC
        MOV     PC, R5
      |
        BLX     R5
      ]
        MOV     R8, R5
        Pull    "R0, R1, R3, R5, R14"
        MOV     PC, R8

Cursor4bit
        LDR     R8, [R0, R2]!
        EOR     R8, R8, R4
        STR     R8, [R0], R3
        TEQ     R0, R1
        MOVEQ   PC, R14
Cursor4loop
        LDR     R8, [R0]
        EOR     R8, R8, R4
        STR     R8, [R0], R3
        TEQ     R0, R1
        BNE     Cursor4loop
        MOV     PC, R14

Cursor8bit
        ADD     R0, R0, R2
Cursor8loop
        LDMIA   R0, {R8,R9}
        EOR     R8, R8, R4
        EOR     R9, R9, R4
        STMIA   R0, {R8,R9}
        ADD     R0, R0, R3
        TEQ     R0, R1
        BNE     Cursor8loop
        MOV     PC, R14

Cursor16bit
        ADD     R0, R0, R2
Cursor16loop
        LDMIA   R0, {R8-R11}
        EOR     R8, R8, R4
        EOR     R9, R9, R4
        EOR     R10, R10, R4
        EOR     R11, R11, R4
        STMIA   R0, {R8-R11}
        ADD     R0, R0, R3
        TEQ     R0, R1
        BNE     Cursor16loop
        MOV     PC, R14

Cursor32bit
        ADD     R0, R0, R2
        SUB     R3, R3, #32
Cursor32loop
        LDMIA   R0, {R8-R11}
        EOR     R8, R8, R4
        EOR     R9, R9, R4
        EOR     R10, R10, R4
        EOR     R11, R11, R4
        STMIA   R0!, {R8-R11}
        LDMIA   R0, {R8-R11}
        EOR     R8, R8, R4
        EOR     R9, R9, R4
        EOR     R10, R10, R4
        EOR     R11, R11, R4
        STMIA   R0!, {R8-R11}
        ADD     R0, R0, R3
        TEQ     R0, R1
        BNE     Cursor32loop
        MOV     PC, R14

Cursor64bit
        ADD     R0, R0, R2
        SUB     R3, R3, #64
Cursor64loop
        LDMIA   R0, {R8-R11}
        EOR     R8, R8, R4
        EOR     R9, R9, R4
        EOR     R10, R10, R4
        EOR     R11, R11, R4
        STMIA   R0!, {R8-R11}
        LDMIA   R0, {R8-R11}
        EOR     R8, R8, R4
        EOR     R9, R9, R4
        EOR     R10, R10, R4
        EOR     R11, R11, R4
        STMIA   R0!, {R8-R11}
        LDMIA   R0, {R8-R11}
        EOR     R8, R8, R4
        EOR     R9, R9, R4
        EOR     R10, R10, R4
        EOR     R11, R11, R4
        STMIA   R0!, {R8-R11}
        LDMIA   R0, {R8-R11}
        EOR     R8, R8, R4
        EOR     R9, R9, R4
        EOR     R10, R10, R4
        EOR     R11, R11, R4
        STMIA   R0!, {R8-R11}
        ADD     R0, R0, R3
        TEQ     R0, R1
        BNE     Cursor64loop
        MOV     PC, R14

; *****************************************************************************
;
;       PostWrchCursor - Put back cursors after Wrch
;
; out:  R6 = new CursorFlags, R5,R7 preserved, all others undefined
;

PostWrchCursor ROUT

        LDR     R6,[WsPtr, #SWP_Restore]
        TEQ     R6,#0
        BEQ     %FT10

        MOV     R6,R14
        BL      RestorePointer
        MOV     R14,R6
10

        LDR     R6, [WsPtr, #CursorFlags]
        LDR     R0, [WsPtr, #CursorStack]
        MOVS    R0, R0, LSL #1
        STR     R0, [WsPtr, #CursorStack]
        MOVCS   PC, R14                         ; we're still off, so do nowt

        Push    R14
        [       ForceMark
        LDR     R0, [WsPtr, #CursorCounter]
        TEQ     R0, #0                          ; are we flashing
        LDRNE   R0, [WsPtr, #CursorSpeed]       ; force to start of mark state
        STRNE   R0, [WsPtr, #CursorCounter]
        MOVNE   R0, #ActualState
        STRNE   R0, [WsPtr, #CursorDesiredState]
        ]

        [       RePlot
        LDR     R1, [WsPtr, #CursorDesiredState]
        EOR     R1, R1, R6              ; EOR of desired and actual
        ANDS    R1, R1, #ActualState    ; just get that bit
        BEQ     PWC10                   ; same, then go home

        EOR     R6, R1, R6              ; EOR actual bit

        TST     R6, #CursorsSplit
        LDRNE   R2, [WsPtr, #InputCursorAddr]
        LDREQ   R2, [WsPtr, #CursorAddr]
        BL      EORFlashCursor
PWC10
        ]

        BIC     R6, R6, #InWrchBit              ; coming out of wrch now
        TST     R6, #CursorsSplit
        STREQ   R6, [WsPtr, #CursorFlags]
        Pull    PC, EQ                          ; return if no output cursor

        LDR     R2, [WsPtr, #CursorAddr]
        LDR     R1, [WsPtr, #LineLength]
        MOV     R1, R1, LSL #3                  ; and end after 8 rows
        LDR     R0, [WsPtr, #ModeFlags]
        TST     R0, #ModeFlag_DoubleVertical    ; if double vertical
        ADDNE   R1, R1, R1                      ; end after 16 rows
        MOV     R0, #0                          ; start on top line
        BL      EORCursor
        STR     R6, [WsPtr, #CursorFlags]       ; only clear it now ?
        Pull    PC


; *****************************************************************************

VsyncCall ROUT
        Push    "R0-R11,R14"

        BL      PollPointer
        BL      UpdatePointer

        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #TeletextMode
        BLNE    TeletextFlashTest               ; if TTX, do other stuff
VsyncReturn
        LDR     R1, [WsPtr, #CursorDesiredState]
        LDR     R0, [WsPtr, #CursorCounter]
        SUBS    R0, R0, #1
        LDREQ   R0, [WsPtr, #CursorSpeed]       ; if is zero, reload
        EOREQ   R1, R1, #ActualState            ; and toggle desired state
        STREQ   R1, [WsPtr, #CursorDesiredState]

        STRCS   R0, [WsPtr, #CursorCounter]     ; store back unless was frozen

        TST     R6, #InWrchBit
        Pull    "R0-R11,PC", NE         ; in wrch, so don't touch screen
                                        ; or modify CursorFlags

        EOR     R1, R1, R6              ; EOR of desired and actual
        ANDS    R1, R1, #ActualState    ; just get that bit
        Pull    "R0-R11,PC", EQ         ; same, then go home

        EOR     R6, R1, R6              ; EOR actual bit
        STR     R6, [WsPtr, #CursorFlags]

        TST     R6, #CursorsSplit
        LDRNE   R2, [WsPtr, #InputCursorAddr]
        LDREQ   R2, [WsPtr, #CursorAddr]
        BL      EORFlashCursor

        Pull    "R0-R11,PC"

; *****************************************************************************

TeletextFlashTest ROUT
        LDR     R3, [WsPtr, #TeletextCount]
        SUBS    R3, R3, #1
        BNE     %FT20                           ; count not expired

        LDR     R1, [WsPtr, #TeletextOffset]
        LDR     R0, [WsPtr, #ScreenSize]
        EORS    R1, R1, R0, LSR #1              ; switch to other flash bank
        STR     R1, [WsPtr, #TeletextOffset]
        MOVEQ   R3, #OnFlashTime
        MOVNE   R3, #OffFlashTime
        LDR     R0, [WsPtr, #DisplayStart]
        STR     R3, [WsPtr, #TeletextCount]
        B       SetVinit                        ; tail-call to VsyncReturn on exit
20
        STR     R3, [WsPtr, #TeletextCount]
        B       VsyncReturn

; *****************************************************************************
;
;       Vdu23_0_10 - Program cursor start, flash/steady, on/off
;

Vdu23_0_10
        LDRB    R0, [WsPtr, #QQ+2]      ; get parameter
ProgReg10AndCopy
        STR     R0, [WsPtr, #Reg10Copy]

; and drop thru to ...

ProgReg10
        AND     R1, R0, #&60
        CMP     R1, #&40
        BCS     IsFlashing
        MOV     R2, #0
        STR     R2, [WsPtr, #CursorCounter]       ; freeze the flashing
        TST     R1, #&20
        MOVEQ   R2, #ActualState                ; steady cursor
        STR     R2, [WsPtr, #CursorDesiredState]
        B       PR1010

IsFlashing
        TST     R1, #&20
        MOVEQ   R2, #FastCursorSpeed
        MOVNE   R2, #SlowCursorSpeed
        STR     R2, [WsPtr, #CursorSpeed]
        LDR     R2, [WsPtr, #CursorCounter]
        TEQ     R2, #0                          ; was flashing frozen ?
                                                ; if not, don't perturb flash
        MOVEQ   R2, #1                          ; set to flash immediately
        STREQ   R2, [WsPtr, #CursorCounter]

PR1010
        AND     R0, R0, #&1F                    ; get start position bits
        TST     R6, #TeletextMode               ; if teletext mode
        MOVNE   R0, R0, LSR #1                  ; then divide by 2
        LDR     R1, [WsPtr, #ModeFlags]
        TST     R1, #ModeFlag_DoubleVertical    ; if double vertical
        MOVNE   R0, R0, LSL #1                  ; then double cursor value

        LDR     R1, [WsPtr, #RowMult]
        CMP     R0, R1                          ; is it > rowmult ?
        MOVHI   R0, R1                          ; set to rowmult if so
        B       SetCursorTop


; *****************************************************************************
;
;       Vdu23_0_11 - Program cursor end
;

Vdu23_0_11
        LDRB    R0, [WsPtr, #QQ+2]      ; get parameter
        TST     R6, #TeletextMode       ; if teletext
        MOVNE   R0, R0, LSR #1          ; then divide by 2

        ADD     R0, R0, #1              ; get end line +1

        LDR     R1, [WsPtr, #ModeFlags]
        TST     R1, #ModeFlag_DoubleVertical ; if double vertical
        MOVNE   R0, R0, LSL #1               ; then double cursor value

        LDR     R1, [WsPtr, #RowMult]
        CMP     R0, R1
        MOVHI   R0, R1                  ; if > rowmult, set to rowmult
        B       SetCursorBottom

; *****************************************************************************
;
;       Vdu23_1 - Program cursor
;

Vdu23_1
        LDR     R0, [WsPtr, #CursorFlags]
        TST     R0, #Vdu5Bit
        MOVNE   PC, R14                 ; none of this nonsense in VDU5 mode

        LDRB    R1, [WsPtr, #QQ+1]      ; get parameter

CursorOnOff
        CMP     R1, #1
        MOVCC   R0, #&20                ; 0 -> just turn off
        LDRCS   R0, [WsPtr, #Reg10Copy] ; 1,2,3 -> read old state
        BLS     ProgReg10               ; 0,1 -> program hardware
        TEQ     R1, #2
        BICEQ   R0, R0, #&60            ; 2 -> steady
        ORRNE   R0, R0, #&60            ; 3 -> slow flashing
        STR     R0, [WsPtr, #Reg10Copy] ; save in copy
        B       ProgReg10

; *****************************************************************************
;
;       DoCursorEdit
;
; in:   R0 = &87 => COPY
;            &88 => cursor left
;            &89 => cursor right
;            &8A => cursor down
;            &8B => cursor up
;
; out:  C=0 => doing COPY and valid character
;       C=1    otherwise
;


DoCursorEdit
        LDR     R6, [WsPtr, #CursorFlags]
        TEQ     R0, #&87
        BNE     IsCursorMove

; COPY character under cursor

        Push    R14
        TST     R6, #CursorsSplit
        BEQ     BadCopyExit             ; cursors not split so don't copy

        TST     R6, #Vdu5Bit
        BNE     BadCopyExit             ; can't copy in VDU5 mode

        BL      ReadCharacter

        TEQ     R0, #0
        BEQ     BadCopyExit

        BL      VDUBE                   ; is a cursor movement valid ?
        BNE     DoCE10

        Push    R0
        BL      PreWrchCursor
        BL      InputCursorHT
        BL      PostWrchCursor
        Pull    R0

DoCE10
        CLC
        Pull    PC

BadCopyExit
        BL      BEL                     ; make bell sound
        SEC
        Pull    PC

; *****************************************************************************
;
;       VDUBE - Check if valid to move cursor
;
; out:  R0 preserved
;       R1 = 0 => OK, R1<>0 => OK
;       R6 = CursorFlags
;       Z => OK, NZ => not OK
;       C = 1

VDUBE
        LDR     R6, [WsPtr, #CursorFlags]
        LDROSB  R1, VDUqueueItems               ; zero if not buffering
        TEQ     R1, #0

        ANDEQS  R1, R6, #Vdu5Bit                ; zero if not in VDU 5 mode

; insert check for vdu disabled here

        CMP     R1, #0                          ; set Z on R1, C:=1
        MOV     PC, R14

; *****************************************************************************

IsCursorMove
        Push    R14
        BL      VDUBE
        Pull    PC, NE

        Push    R0
        BL      PreWrchCursor                   ; remove both cursors
        Pull    R0
        BL      ICM10
        BL      PostWrchCursor

        SEC
        Pull    PC

ICM10
        TST     R6, #CursorsSplit
        BNE     AlreadySplit

        Push    R0
        LDR     R0, [WsPtr, #Reg10Copy]
        AND     R0, R0, #&DF                    ; use double flash rate
        BSR     ProgReg10

        LDR     R0, [WsPtr, #CursorX]           ; copy parameters
        STR     R0, [WsPtr, #InputCursorX]
        LDR     R0, [WsPtr, #CursorY]
        STR     R0, [WsPtr, #InputCursorY]
        LDR     R0, [WsPtr, #CursorAddr]
        STR     R0, [WsPtr, #InputCursorAddr]

        ORR     R6, R6, #CursorsSplit
        STR     R6, [WsPtr, #CursorFlags]

        Pull    R0

AlreadySplit
        CMP     R0, #&89
        BCC     InputCursorLeft         ; &88
        BEQ     InputCursorRight        ; &89
        CMP     R0, #&8B
        BCC     InputCursorDown         ; &8A

; and drop thru to ...

InputCursorUp
        LDR     R1, [WsPtr, #InputCursorY]
        LDR     R2, [WsPtr, #InputCursorAddr]
        LDR     R3, [WsPtr, #RowLength]
        LDR     R4, [WsPtr, #TWTRow]

        SUB     R1, R1, #1
        SUB     R2, R2, R3
        CMP     R1, R4
        LDRLT   R1, [WsPtr, #TWBRow]
        STR     R1, [WsPtr, #InputCursorY]      ; need signed comparison
        STRGE   R2, [WsPtr, #InputCursorAddr]   ; in case Y went -ve
        MOVGE   PC, R14
        B       AddressInputCursor

InputCursorDown
        LDR     R1, [WsPtr, #InputCursorY]
        LDR     R2, [WsPtr, #InputCursorAddr]
        LDR     R3, [WsPtr, #RowLength]
        LDR     R4, [WsPtr, #TWBRow]

        ADD     R1, R1, #1
        ADD     R2, R2, R3
        CMP     R1, R4
        LDRHI   R1, [WsPtr, #TWTRow]
        STR     R1, [WsPtr, #InputCursorY]
        STRLS   R2, [WsPtr, #InputCursorAddr]
        MOVLS   PC, R14

; and drop thru to ...

AddressInputCursor
        Push    R14
        LDR     R0, [WsPtr, #InputCursorX]
        LDR     R1, [WsPtr, #InputCursorY]
        BL      AddressR0R1
        STR     R2, [WsPtr, #InputCursorAddr]
        Pull    PC

AddressCursors
        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #CursorsSplit
        BEQ     AddressCursor
        BSR     AddressInputCursor
        B       AddressCursor


InputCursorLeft
        LDR     R0, [WsPtr, #InputCursorX]
        LDR     R2, [WsPtr, #InputCursorAddr]
        LDR     R3, [WsPtr, #CharWidth]
        LDR     R4, [WsPtr, #TWLCol]

        SUB     R0, R0, #1
        SUB     R2, R2, R3
        CMP     R0, R4
        LDRLT   R0, [WsPtr, #TWRCol]
        STR     R0, [WsPtr, #InputCursorX]
        STRGE   R2, [WsPtr, #InputCursorAddr]   ; I do mean GE !
        MOVGE   PC, R14

        BSR     AddressInputCursor
        B       InputCursorUp

InputCursorRight
        LDR     R0, [WsPtr, #InputCursorX]
        LDR     R2, [WsPtr, #InputCursorAddr]
        LDR     R3, [WsPtr, #CharWidth]
        LDR     R4, [WsPtr, #TWRCol]

        ADD     R0, R0, #1
        ADD     R2, R2, R3
        CMP     R0, R4
        LDRHI   R0, [WsPtr, #TWLCol]
        STR     R0, [WsPtr, #InputCursorX]
        STRLS   R2, [WsPtr, #InputCursorAddr]
        MOVLS   PC, R14

        BSR     AddressInputCursor
        B       InputCursorDown

; *****************************************************************************
;
;       InputCursorHT - move input cursor "right" after copying
;

InputCursorHT
        Push    R14
        LDR     R6, [WsPtr, #CursorFlags]
        BL      InputCursorMove
        BCC     ICHTExit

        BL      InputCursorB0
        BL      AddressInputCursor
        EOR     R6, R6, #8
        BL      InputCursorMove
        BLCS    InputCursorB0
ICHTExit
        Pull    R14
        B       AddressInputCursor

        LTORG

        END
@


4.5
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d177 6
a182 9
    [ TTX256
        ASSERT  HiResTTX
        Push    "R0, R1, R14"
        ADD     R0, R0, #320*1024               ; go to other screen
        ADD     R1, R1, #320*1024
        BL      Cursor16bit
        Pull    "R0, R1, R14"
        B       Cursor16bit
    |
d184 7
a190 6
        Push    "R0, R1, R14"
        ADD     R0, R0, #160*1024               ; go to other screen
        ADD     R1, R1, #160*1024
        BL      Cursor8bit
        Pull    "R0, R1, R14"
        B       Cursor8bit
d192 1
a192 7
        Push    "R0, R1, R14"
        ADD     R0, R0, #40*1024                ; go to other screen
        ADD     R1, R1, #40*1024
        BL      Cursor4bit
        Pull    "R0, R1, R14"

; and drop thru to ...
d194 3
a196 1
    ]
d259 33
d405 2
a406 10
    [ TTX256
        ASSERT  HiResTTX
        EORS    R1, R1, #320*1024               ; switch to other flash bank
    |
      [ HiResTTX
        EORS    R1, R1, #160*1024               ; switch to other flash bank
      |
        EORS    R1, R1, #40*1024                ; switch to other flash bank
      ]
    ]
a678 1
      [ HiResTTX
a679 3
      |
        LDR     R3, [WsPtr, #BytesPerChar]
      ]
a695 1
      [ HiResTTX
a696 3
      |
        LDR     R3, [WsPtr, #BytesPerChar]
      ]
d730 2
@


4.4
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a335 1
 [ AssemblePointerV
a336 1
 ]
@


4.3
log
@  Added compile-time support for full-resolution teletext characters in
  teletext emulation mode (MODE 7) for that authentic BBC Micro feel.
  Also introduced a few useful teletext control features via VDU 23,18.
  Unrelatedly, fixed *ScreenLoad to work for interlaced displays.

Detail:
  The new typeface is designed on a 16x20 grid (previously we had used 8x10),
  so it uses a screen resolution of 640x500 pixels (rather than 320x250).
  Since we have been unable to source a genuine teletext font, and since
  examination of a BBC Micro suggests that the genuine font may not have been
  a power-of-2 pixels wide, I have designed one specially, based upon the one
  supplied in Zap distributions (a 12x20 font). Rather than increase the
  amount of workspace that the kernel requires for cacheing graphic
  characters, it now generates them on the fly, as they are required; this
  should only add about 25% to their rendering time.

  The new VDU 23 sequences are as follows:

  VDU 23,18,0,mode,0,0,0,0,0,0
    Switch transparency mode
      mode = 0: "Text" mode: the whole display is set opaque
      mode = 1: "Mix" mode: foreground colours, and both foreground and
        background of boxed text are opaque; non-boxed background colours are
        all transparent
      mode = 2: "Box" mode: boxed regions are opaque, others are transparent
      mode = 3: "TV" mode: the whole display is set transparent
    Default is mode = 0.

  VDU 23,18,1,suspend,0,0,0,0,0,0
    Suspend or resume bitmap updates
    This call allows an application to request that the kernel suspends
    updates to the framebuffer bitmap. This allows for a significant speed
    increase in the rendering time for a large amount of text, for example
    when redrawing a complete teletext page, because each time you plot a
    single character, it can cause the whole of the rest of the line to be
    re-rendered. When you switch out of suspend mode, the whole screen is
    refreshed in a single pass. Note that the appearance of the display is
    undefined is you cause a hardware scroll while in suspend mode.
      suspend = 0: screen update is enabled
      suspend = 1: screen update is suspended
    Default is suspend = 0.

  VDU 23,18,2,reveal,0,0,0,0,0,0
    Reveal/conceal
      reveal = 0: characters between the Conceal control code and the next
        colour control code are replaced by spaces
      reveal = 1: all characters are displayed
    Default is reveal = 0.

  VDU 23,18,3,black_emable,0,0,0,0,0,0
    Enable/disable black foreground colour control codes
      black_enable = 0: control codes &80 and &90 do nothing
      black_enable = 1: control code &80 selects black text, control code
        &90 selects black graphics
    Default is black_enable = 0.

  I have performed some timing tests on the rendering of complete teletext
  pages grabbed from the teletext server. These show that the new code
  generally imposes a 2x speed hit. However, when using the VDU 23,18,1
  suspend function, this improves to a 20% speed increase when compared to
  the old low-resolution code. Better still, because the framebuffer is only
  being updated for the final stage of this process, the screen *appears* to
  be updated some 3x faster than with the old code!

  A comment on the VDU variable Log2BPC is in order: in previous kernels,
  this was able unambiguously to refer to both the framebuffer width of a
  character in bytes, and the framebuffer width of an "addressable pixel" in
  bits; this no longer works with the 16-pixel wide teletext font. Bearing
  in mind that future kernels may support Unicode system fonts where the
  width varies from character to character, I have chosen to fix Log2BPC to
  the "addressable pixel" definition.

Admin:
  Requires HdrSrc 0.89 and (for non-desktop builds) Interlace 0.61. A monitor
  definition file containing a definition for a 640x500 screen mode is also
  required; version 0.40 of ModeFiles contains a suitable mode for STB-400.

  Tested fairly rigourously on an Ursula build, a Lazarus build and an
  STB-400 build, using genuine teletext pages and Yellow River Kingdom.

Version 5.30. Tagged as 'Kernel-5_30'
@
text
@d66 1
a66 1
        TST     R0, #Flag_DoubleVertical        ; if double vertical
d86 1
a86 2
 [ No26bitCode
        mrs    ,R3, CPSR
d88 2
a89 4
        msr    ,CPSR_c, R1
 |
        SETPSR  I_bit, R1
 ]
d100 8
a107 2
 [ No26bitCode
        msr    ,CPSR_c, R3                      ; restore old I bit
a108 5
 |
        MOVCSS  PC, R14                         ; already off, so exit
                                                ; (restoring I_bit)
        TEQP    R14, #0                         ; restore old I_bit
 ]
d177 9
d202 1
d272 11
a282 1
PostWrchCursor
d323 1
a323 1
        TST     R0, #Flag_DoubleVertical        ; if double vertical
d380 4
d389 1
d394 2
a395 1
        BL      SetVinit                        ; preserves R3
d439 1
a439 1
        TST     R1, #Flag_DoubleVertical        ; if double vertical
d461 2
a462 2
        TST     R1, #Flag_DoubleVertical ; if double vertical
        MOVNE   R0, R0, LSL #1           ; then double cursor value
@


4.3.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d87 1
a87 1
        MRS     R3, CPSR
d89 1
a89 1
        MSR     CPSR_c, R1
d104 1
a104 1
        MSR     CPSR_c, R3                      ; restore old I bit
@


4.3.2.2
log
@Added 256-colour version of the (high-resolution only) teletext code,
and support for teletext when hardware scroll is disabled. Both are required
for Tungsten.
Turned off the module init/final service calls, since we still don't have an
allocation for them.
Upped the OS version number to 5.01.

Version 5.35, 4.79.2.53. Tagged as 'Kernel-5_35-4_79_2_53'
@
text
@a178 9
    [ TTX256
        ASSERT  HiResTTX
        Push    "R0, R1, R14"
        ADD     R0, R0, #320*1024               ; go to other screen
        ADD     R1, R1, #320*1024
        BL      Cursor16bit
        Pull    "R0, R1, R14"
        B       Cursor16bit
    |
a194 1
    ]
a361 4
    [ TTX256
        ASSERT  HiResTTX
        EORS    R1, R1, #320*1024               ; switch to other flash bank
    |
a366 1
    ]
@


4.3.2.3
log
@Merge with RPi branch
Detail:
  Merge the RPi branch with the HAL branch, ending RPi branch development
  Brief summary of changes brought in:
  * Added HAL_VideoStartupMode to allow the HAL to specify a startup mode for the OS
  * Fixed addresses being sent to GraphicsV_SetDMAAddress being wrong for external framestores (addresses were given as if internal framestore was in use)
  * Add InverseTextTransparency option for limited compile-time support for targets where framebuffer alpha channel is important
  * Fix ConfiguredLanguage for non-Tungsten builds
  * Update ARMv6 CPU detection to read cache parameters from cache type register instead of using KnownCPUTable
  * Add HALDebugHexTX/TX2/TX4 debug routines for writing out numbers via HAL
  * Use HAL_TimerIRQClear when clearing timer 0 interrupt instead of just HAL_IRQClear
  * Initialise FileLangCMOS using defines from Hdr:FSNumbers instead of magic numbers. Use SDFS on M_ARM11ZF.
  * Improved software mouse pointer support; software pointer now removed & restored in some of the same places the text cursor is
  * Improve support for external framestores; driver is now able to grow/shrink/move the framestore on mode changes if bit 5 of GraphicsV_DisplayFeatures R0 is set
  * GraphicsV_FramestoreAddress now has a default claimant which calls HAL_VideoFramestoreAddress
Admin:
  Tested on Raspberry Pi, Iyonix, OMAP3, IOMD


Version 5.35, 4.79.2.165. Tagged as 'Kernel-5_35-4_79_2_165'
@
text
@a102 6
        MOV     R2,R14
        LDR     R14, [WsPtr, #HALVideoFeatures]
        TST     R14, #2
        BLEQ    RemovePointer
        MOV     R14,R2

d274 1
a274 15
PostWrchCursor ROUT

        LDR     R6,[WsPtr, #HALVideoFeatures]
        TST     R6,#2
        BNE     %FT10

        MOV     R6,R14
        MRS     R4,CPSR
        ORR     R3,R4,#I32_bit
        MSR     CPSR_c,R3
        BL      RestorePointer
        MSR     CPSR_c,R4
        MOV     R14,R6
10

@


4.3.2.4
log
@Be more careful when updating Vinit from the VSync IRQ handler
Detail:
  s/vdu/vducursoft - TeletextFlashTest now stores the updated TeletextCount before calling SetVinit. This provides some protection against getting stuck in an infinite loop (+ stack overflow) if SetVinit takes longer than 1 VSync to complete (or some other catastrophe occurs)
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.179. Tagged as 'Kernel-5_35-4_79_2_179'
@
text
@d406 1
a406 2
        STR     R3, [WsPtr, #TeletextCount]
        B       SetVinit                        ; tail-call to VsyncReturn on exit
@


4.3.2.5
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d66 1
a66 1
        TST     R0, #ModeFlag_DoubleVertical    ; if double vertical
d335 1
a335 1
        TST     R0, #ModeFlag_DoubleVertical    ; if double vertical
d451 1
a451 1
        TST     R1, #ModeFlag_DoubleVertical    ; if double vertical
d473 1
a473 1
        TST     R1, #ModeFlag_DoubleVertical ; if double vertical
@


4.3.2.6
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d104 2
a105 2
        LDR     R14, [WsPtr, #GraphicsVFeatures]
        TST     R14, #GVDisplayFeature_HardwarePointer
d282 2
a283 2
        LDR     R6,[WsPtr, #GraphicsVFeatures]
        TST     R6,#GVDisplayFeature_HardwarePointer
d474 1
a474 1
        MOVNE   R0, R0, LSL #1               ; then double cursor value
@


4.3.2.7
log
@Add builtin software pointer support
Detail:
  This set of changes adds support for rendering software mouse pointers directly in the kernel, rather than requiring graphics drivers to render them themselves as was the case previously.
  If a driver returns from GraphicsV_Features with the 'hardware pointer' bit clear, and a call to GraphicsV_UpdatePointer is returned unclaimed, then the kernel will step in and render a software pointer. This allows selective control over which areas of the screen the software pointer is used (e.g. if hardware only supports its use in some areas)
  hdr/KernelWS - Shrink PointerXEigFactor to 1 byte to free up some space for tracking the display log2bpp. Use 8 words of space for tracking software pointer state.
  s/vdu/vducursoft - Adjust existing the existing calls to the software pointer RemovePointer/RestorePointer functions so that they're called with IRQs enabled
  s/vdu/vdudriver - Keep track of display log2bpp. Claim/release memory needed for restoring pixels under software pointer.
  s/vdu/vdugrafhal - Update HAL_VideoUpdatePointer handling so that 0 can be returned in a1 to indicate the GraphicsV call should be left unclaimed.
  s/vdu/vdupalxx - Trigger updates of the cached software pointer palette whenever it's likely to become invalidated.
  s/vdu/vdupointer - Add software pointer implementation. Relying on a SpriteExtend OS_SpriteOp would be nice, but we're in the background so have to do plotting & unplotting manually. ColourTrans is used to cache the pointer palette colours for the current mode, although we're limited to calling it from a callback.
Admin:
  Tested on Raspberry Pi & BB-xM
  Pointer is very flickery under some circumstances (e.g. running !CloseUp) due to needing to plot/unplot around any VDU driver screen access (as per text cursor). So code may need revising in future once we can trap reads/writes from specific screen memory pages.


Version 5.35, 4.79.2.269. Tagged as 'Kernel-5_35-4_79_2_269'
@
text
@d86 1
d90 3
a92 1

d103 7
a110 7

        MOV     R2,R14                          ; n.b. calling remove even if
        LDR     R14, [WsPtr, #SWP_Under]        ; soft pointer not currently
        TEQ     R14, #0                         ; visible. This sets the lock, 
        BLNE    RemovePointer                   ; preventing it from being      
        MOV     R14,R2                          ; turned on while we're busy.

d112 5
d282 3
a284 3
        LDR     R6,[WsPtr, #SWP_Restore]
        TEQ     R6,#0
        BEQ     %FT10
d287 3
d291 1
@


4.3.2.2.6.1
log
@  Merge of Raspberry Pi support code against latest kernel
Detail:
  This is a new branch from the current tip of the HAL branch, incorporating
  the changes received from Adrian Lees. The same caveats apply - this is a
  work in progress and will not work on any other platform at present.
Admin:
  Builds, but not tested.

Version 5.35, 4.79.2.147.2.1. Tagged as 'Kernel-5_35-4_79_2_147_2_1'
@
text
@a102 6
        MOV     R2,R14
        LDR     R14, [WsPtr, #HALVideoFeatures]
        TST     R14, #2
        BLEQ    RemovePointer
        MOV     R14,R2

d274 1
a274 15
PostWrchCursor ROUT

        MOV     R6,R14
        LDR     R14,[WsPtr, #HALVideoFeatures]
        TST     R14,#2
        BNE     %FT10

        MRS     R4,CPSR
        ORR     R3,R4,#I32_bit
        MSR CPSR_c,R3
        BL      RestorePointer
        MSR CPSR_c,R4
10
        MOV     R14,R6

@


4.3.2.2.6.2
log
@Clean up remaining kernel hacks
Detail:
  Docs/RPiNotes - Deleted, contents no longer relevant
  s/HAL, s/Kernel, s/vdu/vduswis, s/pmf/key - Cleaned up debug code
  s/NewIRQs - No need to piggy back on timer 0 IRQ to generate a fake VSync; PushModeInfo already claims/releases TickerV as appropriate if video driver doesn't provide a VSync IRQ.
  s/NewReset - Re-enable LookForHALRTC call, the stack imbalance bug was fixed before the Pi changes were merged in
  s/vdu/vducursoft - Streamline PostWrchCursor a bit by only preserving R14 around RestorePointer if the software pointer is in use
  s/vdu/vdudriver - Amend ModeChangeSub improvements to ensure old external framestore handling logic is used if driver doesn't support framestore growth/realloc
Admin:
  Tested on Raspberry Pi with high processor vectors
  Kernel now looks to be in a good state for merging back into HAL branch
  Note - Software mouse pointer support in vducursoft only checks HALVideoFeatures, so doesn't take into account the capabilities of any GraphicsV driver that may be in use.


Version 5.35, 4.79.2.147.2.20. Tagged as 'Kernel-5_35-4_79_2_147_2_20'
@
text
@d282 3
a284 2
        LDR     R6,[WsPtr, #HALVideoFeatures]
        TST     R6,#2
a286 1
        MOV     R6,R14
d289 1
a289 1
        MSR     CPSR_c,R3
d291 2
a292 1
        MSR     CPSR_c,R4
a293 1
10
@


4.3.2.2.4.1
log
@  Support for Raspberry Pi / BCM2835
Detail:
  Falls into two main areas: graphics support and ARM11 core support.
  A work in progress - in many cases the code changes need to be replaced
  with an alternative mechanism which will permit the kernel to still function
  on other platforms. Adrian marked these with "!!!" comments - I have added
  ! directives as well so that they don't get forgotten about.
Admin:
  Changes received from Adrian Lees. This revision represents the code largely
  as delivered, and is placed on its own branch (forked off from the version
  from which he worked). It is intended for reference. It doesn't build against
  current headers - this is likely to require a merge with the other changes
  to the kernel since that time.

Version 5.35, 4.79.2.98.2.52.2.1. Tagged as 'Kernel-5_35-4_79_2_98_2_52_2_1'
@
text
@a102 6
        MOV     R2,R14
        LDR     R14, [WsPtr, #HALVideoFeatures]
        TST     R14, #2
        BLEQ    RemovePointer
        MOV     R14,R2

d274 1
a274 15
PostWrchCursor ROUT

        MOV     R6,R14
        LDR     R14,[WsPtr, #HALVideoFeatures]
        TST     R14,#2
        BNE     %FT10

        MRS     R4,CPSR
        ORR     R3,R4,#I32_bit
        MSR CPSR_c,R3
        BL      RestorePointer
        MSR CPSR_c,R4
10
        MOV     R14,R6

@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d179 8
d194 1
d362 3
d366 1
d638 3
d642 1
d659 3
d663 1
@


4.1
log
@Initial revision
@
text
@d86 5
d92 1
d103 4
d110 1
d523 1
a523 1
        
d572 1
a572 1
        
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

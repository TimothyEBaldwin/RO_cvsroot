head	4.4;
access;
symbols
	Kernel-6_14:4.4
	Kernel-6_01-3:4.4
	Kernel-6_13:4.4
	Kernel-6_12:4.4
	Kernel-6_11:4.4
	Kernel-6_10:4.4
	Kernel-6_09:4.4
	Kernel-6_08-4_129_2_10:4.4
	Kernel-6_08-4_129_2_9:4.4
	Kernel-6_08:4.4
	Kernel-6_07:4.4
	Kernel-6_06:4.4
	Kernel-6_05-4_129_2_8:4.4
	Kernel-6_05:4.4
	Kernel-6_04:4.4
	Kernel-6_03:4.4
	Kernel-6_01-2:4.4
	Kernel-6_01-4_146_2_1:4.4
	Kernel-6_02:4.4
	Kernel-6_01-1:4.4
	Kernel-6_01:4.4
	Kernel-6_00:4.4
	Kernel-5_99:4.4
	Kernel-5_98:4.4
	Kernel-5_97-4_129_2_7:4.4
	Kernel-5_97:4.4
	Kernel-5_96:4.4
	Kernel-5_95:4.4
	Kernel-5_94:4.4
	Kernel-5_93:4.4
	Kernel-5_92:4.4
	Kernel-5_91:4.4
	Kernel-5_90:4.4
	Kernel-5_89-4_129_2_6:4.4
	Kernel-5_89:4.4
	Kernel-5_88-4_129_2_5:4.4
	Kernel-5_88-4_129_2_4:4.4
	Kernel-5_88:4.4
	Kernel-5_87:4.4
	Kernel-5_86-4_129_2_3:4.4
	Kernel-5_86-4_129_2_2:4.4
	Kernel-5_86-4_129_2_1:4.4
	Kernel-5_86:4.4
	SMP:4.4.0.2
	SMP_bp:4.4
	Kernel-5_85:4.4
	Kernel-5_54-1:4.4
	Kernel-5_84:4.4
	Kernel-5_83:4.4
	Kernel-5_82:4.4
	Kernel-5_81:4.4
	Kernel-5_80:4.4
	Kernel-5_79:4.4
	Kernel-5_78:4.4
	Kernel-5_77:4.4
	Kernel-5_76:4.4
	Kernel-5_75:4.4
	Kernel-5_74:4.4
	Kernel-5_73:4.4
	Kernel-5_72:4.4
	Kernel-5_71:4.4
	Kernel-5_70:4.4
	Kernel-5_69:4.4
	Kernel-5_68:4.4
	Kernel-5_67:4.4
	Kernel-5_66:4.4
	Kernel-5_65:4.4
	Kernel-5_64:4.4
	Kernel-5_63:4.4
	Kernel-5_62:4.4
	Kernel-5_61:4.4
	Kernel-5_60:4.4
	Kernel-5_59:4.4
	Kernel-5_58:4.4
	Kernel-5_57:4.4
	Kernel-5_56:4.4
	Kernel-5_55:4.4
	Kernel-5_54:4.4
	Kernel-5_53:4.4
	Kernel-5_52:4.4
	Kernel-5_51:4.4
	Kernel-5_50:4.3
	Kernel-5_49:4.3
	HAL_merge:4.2.2.5
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.5
	Kernel-5_35-4_79_2_326:4.2.2.5
	Kernel-5_35-4_79_2_325:4.2.2.5
	Kernel-5_35-4_79_2_324:4.2.2.5
	Kernel-5_35-4_79_2_323:4.2.2.5
	Kernel-5_35-4_79_2_322:4.2.2.5
	Kernel-5_35-4_79_2_321:4.2.2.5
	Kernel-5_35-4_79_2_320:4.2.2.4
	Kernel-5_35-4_79_2_319:4.2.2.4
	Kernel-5_35-4_79_2_318:4.2.2.4
	Kernel-5_35-4_79_2_317:4.2.2.4
	Kernel-5_35-4_79_2_316:4.2.2.4
	Kernel-5_35-4_79_2_315:4.2.2.4
	Kernel-5_35-4_79_2_314:4.2.2.4
	Kernel-5_35-4_79_2_313:4.2.2.4
	Kernel-5_35-4_79_2_312:4.2.2.4
	Kernel-5_35-4_79_2_311:4.2.2.4
	Kernel-5_35-4_79_2_310:4.2.2.4
	Kernel-5_35-4_79_2_309:4.2.2.4
	Kernel-5_35-4_79_2_308:4.2.2.4
	Kernel-5_35-4_79_2_307:4.2.2.4
	Kernel-5_35-4_79_2_306:4.2.2.4
	Kernel-5_35-4_79_2_305:4.2.2.4
	Kernel-5_35-4_79_2_304:4.2.2.4
	Kernel-5_35-4_79_2_303:4.2.2.4
	Kernel-5_35-4_79_2_302:4.2.2.4
	Kernel-5_35-4_79_2_301:4.2.2.4
	Kernel-5_35-4_79_2_300:4.2.2.4
	Kernel-5_35-4_79_2_299:4.2.2.4
	Kernel-5_35-4_79_2_298:4.2.2.4
	Kernel-5_35-4_79_2_297:4.2.2.4
	Kernel-5_35-4_79_2_296:4.2.2.4
	Kernel-5_35-4_79_2_295:4.2.2.4
	Kernel-5_35-4_79_2_294:4.2.2.4
	Kernel-5_35-4_79_2_293:4.2.2.4
	Kernel-5_35-4_79_2_292:4.2.2.4
	Kernel-5_35-4_79_2_291:4.2.2.4
	Kernel-5_35-4_79_2_290:4.2.2.4
	Kernel-5_35-4_79_2_289:4.2.2.4
	Kernel-5_35-4_79_2_288:4.2.2.4
	Kernel-5_35-4_79_2_287:4.2.2.4
	Kernel-5_35-4_79_2_286:4.2.2.4
	Kernel-5_35-4_79_2_285:4.2.2.4
	Kernel-5_35-4_79_2_284:4.2.2.4
	Kernel-5_35-4_79_2_283:4.2.2.4
	Kernel-5_35-4_79_2_282:4.2.2.4
	Kernel-5_35-4_79_2_281:4.2.2.4
	Kernel-5_35-4_79_2_280:4.2.2.4
	Kernel-5_35-4_79_2_279:4.2.2.4
	Kernel-5_35-4_79_2_278:4.2.2.4
	Kernel-5_35-4_79_2_277:4.2.2.4
	Kernel-5_35-4_79_2_276:4.2.2.4
	Kernel-5_35-4_79_2_275:4.2.2.4
	Kernel-5_35-4_79_2_274:4.2.2.4
	Kernel-5_35-4_79_2_273:4.2.2.4
	Kernel-5_35-4_79_2_272:4.2.2.4
	Kernel-5_35-4_79_2_271:4.2.2.4
	Kernel-5_35-4_79_2_270:4.2.2.4
	Kernel-5_35-4_79_2_269:4.2.2.4
	Kernel-5_35-4_79_2_268:4.2.2.4
	Kernel-5_35-4_79_2_267:4.2.2.4
	Kernel-5_35-4_79_2_266:4.2.2.4
	Kernel-5_35-4_79_2_265:4.2.2.4
	Kernel-5_35-4_79_2_264:4.2.2.4
	Kernel-5_35-4_79_2_263:4.2.2.4
	Kernel-5_35-4_79_2_262:4.2.2.4
	Kernel-5_35-4_79_2_261:4.2.2.4
	Kernel-5_35-4_79_2_260:4.2.2.4
	Kernel-5_35-4_79_2_259:4.2.2.4
	Kernel-5_35-4_79_2_258:4.2.2.4
	Kernel-5_35-4_79_2_257:4.2.2.4
	Kernel-5_35-4_79_2_256:4.2.2.4
	Kernel-5_35-4_79_2_255:4.2.2.4
	Kernel-5_35-4_79_2_254:4.2.2.4
	Kernel-5_35-4_79_2_253:4.2.2.4
	Kernel-5_35-4_79_2_252:4.2.2.4
	Kernel-5_35-4_79_2_251:4.2.2.4
	Kernel-5_35-4_79_2_250:4.2.2.4
	Kernel-5_35-4_79_2_249:4.2.2.4
	Kernel-5_35-4_79_2_248:4.2.2.4
	Kernel-5_35-4_79_2_247:4.2.2.4
	Kernel-5_35-4_79_2_246:4.2.2.4
	Kernel-5_35-4_79_2_245:4.2.2.4
	Kernel-5_35-4_79_2_244:4.2.2.4
	Kernel-5_35-4_79_2_243:4.2.2.4
	Kernel-5_35-4_79_2_242:4.2.2.4
	Kernel-5_35-4_79_2_241:4.2.2.4
	Kernel-5_35-4_79_2_240:4.2.2.4
	Kernel-5_35-4_79_2_239:4.2.2.4
	Kernel-5_35-4_79_2_238:4.2.2.4
	Kernel-5_35-4_79_2_237:4.2.2.4
	Kernel-5_35-4_79_2_236:4.2.2.4
	Kernel-5_35-4_79_2_235:4.2.2.4
	Kernel-5_35-4_79_2_234:4.2.2.4
	Kernel-5_35-4_79_2_233:4.2.2.4
	Kernel-5_35-4_79_2_232:4.2.2.4
	Kernel-5_35-4_79_2_231:4.2.2.4
	Kernel-5_35-4_79_2_230:4.2.2.4
	Kernel-5_35-4_79_2_229:4.2.2.4
	Kernel-5_35-4_79_2_228:4.2.2.4
	Kernel-5_35-4_79_2_227:4.2.2.4
	Kernel-5_35-4_79_2_226:4.2.2.4
	Kernel-5_35-4_79_2_225:4.2.2.4
	Kernel-5_35-4_79_2_224:4.2.2.4
	Kernel-5_35-4_79_2_223:4.2.2.4
	Kernel-5_35-4_79_2_222:4.2.2.4
	Kernel-5_35-4_79_2_221:4.2.2.4
	Kernel-5_35-4_79_2_220:4.2.2.4
	Kernel-5_35-4_79_2_219:4.2.2.4
	Kernel-5_35-4_79_2_218:4.2.2.4
	Kernel-5_35-4_79_2_217:4.2.2.4
	Kernel-5_35-4_79_2_216:4.2.2.4
	Kernel-5_35-4_79_2_215:4.2.2.4
	Kernel-5_35-4_79_2_214:4.2.2.4
	Kernel-5_35-4_79_2_213:4.2.2.4
	Kernel-5_35-4_79_2_212:4.2.2.4
	Kernel-5_35-4_79_2_211:4.2.2.4
	Kernel-5_35-4_79_2_210:4.2.2.4
	Kernel-5_35-4_79_2_209:4.2.2.4
	Kernel-5_35-4_79_2_208:4.2.2.4
	Kernel-5_35-4_79_2_207:4.2.2.4
	Kernel-5_35-4_79_2_206:4.2.2.4
	Kernel-5_35-4_79_2_205:4.2.2.4
	Kernel-5_35-4_79_2_204:4.2.2.4
	Kernel-5_35-4_79_2_203:4.2.2.4
	Kernel-5_35-4_79_2_202:4.2.2.4
	Kernel-5_35-4_79_2_201:4.2.2.4
	Kernel-5_35-4_79_2_200:4.2.2.4
	Kernel-5_35-4_79_2_199:4.2.2.4
	Kernel-5_35-4_79_2_198:4.2.2.4
	Kernel-5_35-4_79_2_197:4.2.2.3
	Kernel-5_35-4_79_2_196:4.2.2.2
	Kernel-5_35-4_79_2_195:4.2.2.2
	Kernel-5_35-4_79_2_194:4.2.2.2
	Kernel-5_35-4_79_2_193:4.2.2.1
	Kernel-5_35-4_79_2_192:4.2.2.1
	Kernel-5_35-4_79_2_191:4.2.2.1
	Kernel-5_35-4_79_2_190:4.2.2.1
	Kernel-5_35-4_79_2_189:4.2.2.1
	Kernel-5_35-4_79_2_188:4.2.2.1
	Kernel-5_35-4_79_2_187:4.2.2.1
	Kernel-5_35-4_79_2_186:4.2.2.1
	Kernel-5_35-4_79_2_185:4.2.2.1
	Kernel-5_35-4_79_2_184:4.2.2.1
	Kernel-5_35-4_79_2_183:4.2.2.1
	Kernel-5_35-4_79_2_182:4.2.2.1
	Kernel-5_35-4_79_2_181:4.2.2.1
	Kernel-5_35-4_79_2_180:4.2.2.1
	Kernel-5_35-4_79_2_179:4.2.2.1
	Kernel-5_35-4_79_2_178:4.2.2.1
	Kernel-5_35-4_79_2_177:4.2.2.1
	Kernel-5_35-4_79_2_176:4.2.2.1
	Kernel-5_35-4_79_2_175:4.2.2.1
	Kernel-5_35-4_79_2_174:4.2.2.1
	Kernel-5_35-4_79_2_173:4.2
	Kernel-5_35-4_79_2_172:4.2
	Kernel-5_35-4_79_2_171:4.2
	Kernel-5_35-4_79_2_170:4.2
	Kernel-5_35-4_79_2_169:4.2
	Kernel-5_35-4_79_2_168:4.2
	Kernel-5_35-4_79_2_167:4.2
	Kernel-5_35-4_79_2_166:4.2
	Kernel-5_35-4_79_2_165:4.2
	RPi_merge:4.2
	Kernel-5_35-4_79_2_147_2_23:4.2
	Kernel-5_35-4_79_2_147_2_22:4.2
	Kernel-5_35-4_79_2_147_2_21:4.2
	Kernel-5_35-4_79_2_147_2_20:4.2
	Kernel-5_35-4_79_2_147_2_19:4.2
	Kernel-5_35-4_79_2_147_2_18:4.2
	Kernel-5_35-4_79_2_164:4.2
	Kernel-5_35-4_79_2_163:4.2
	Kernel-5_35-4_79_2_147_2_17:4.2
	Kernel-5_35-4_79_2_147_2_16:4.2
	Kernel-5_35-4_79_2_147_2_15:4.2
	Kernel-5_35-4_79_2_162:4.2
	Kernel-5_35-4_79_2_161:4.2
	Kernel-5_35-4_79_2_147_2_14:4.2
	Kernel-5_35-4_79_2_147_2_13:4.2
	Kernel-5_35-4_79_2_160:4.2
	Kernel-5_35-4_79_2_159:4.2
	Kernel-5_35-4_79_2_158:4.2
	Kernel-5_35-4_79_2_157:4.2
	Kernel-5_35-4_79_2_156:4.2
	Kernel-5_35-4_79_2_147_2_12:4.2
	Kernel-5_35-4_79_2_147_2_11:4.2
	Kernel-5_35-4_79_2_155:4.2
	Kernel-5_35-4_79_2_147_2_10:4.2
	Kernel-5_35-4_79_2_154:4.2
	Kernel-5_35-4_79_2_153:4.2
	Kernel-5_35-4_79_2_147_2_9:4.2
	Kernel-5_35-4_79_2_152:4.2
	Kernel-5_35-4_79_2_151:4.2
	Kernel-5_35-4_79_2_147_2_8:4.2
	Kernel-5_35-4_79_2_147_2_7:4.2
	Kernel-5_35-4_79_2_150:4.2
	Kernel-5_35-4_79_2_147_2_6:4.2
	Kernel-5_35-4_79_2_147_2_5:4.2
	Kernel-5_35-4_79_2_149:4.2
	Kernel-5_35-4_79_2_147_2_4:4.2
	Kernel-5_35-4_79_2_147_2_3:4.2
	Kernel-5_35-4_79_2_148:4.2
	Kernel-5_35-4_79_2_147_2_2:4.2
	Kernel-5_35-4_79_2_147_2_1:4.2
	RPi:4.2.0.10
	RPi_bp:4.2
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2
	alees_Kernel_dev:4.2.0.8
	alees_Kernel_dev_bp:4.2
	Kernel-5_35-4_79_2_147:4.2
	Kernel-5_35-4_79_2_146:4.2
	Kernel-5_35-4_79_2_145:4.2
	Kernel-5_35-4_79_2_144:4.2
	Kernel-5_35-4_79_2_143:4.2
	Kernel-5_35-4_79_2_142:4.2
	Kernel-5_35-4_79_2_141:4.2
	Kernel-5_35-4_79_2_140:4.2
	Kernel-5_35-4_79_2_139:4.2
	Kernel-5_35-4_79_2_138:4.2
	Kernel-5_35-4_79_2_137:4.2
	Kernel-5_35-4_79_2_136:4.2
	Kernel-5_35-4_79_2_135:4.2
	Kernel-5_35-4_79_2_134:4.2
	Kernel-5_35-4_79_2_133:4.2
	Kernel-5_35-4_79_2_132:4.2
	Kernel-5_35-4_79_2_131:4.2
	Kernel-5_35-4_79_2_130:4.2
	Kernel-5_35-4_79_2_129:4.2
	Kernel-5_35-4_79_2_128:4.2
	Kernel-5_35-4_79_2_127:4.2
	Kernel-5_35-4_79_2_126:4.2
	Kernel-5_35-4_79_2_125:4.2
	Kernel-5_35-4_79_2_124:4.2
	Kernel-5_35-4_79_2_123:4.2
	Cortex_merge:4.2
	Kernel-5_35-4_79_2_122:4.2
	Kernel-5_35-4_79_2_98_2_54:4.2
	Kernel-5_35-4_79_2_98_2_53:4.2
	Kernel-5_35-4_79_2_98_2_52:4.2
	Kernel-5_35-4_79_2_98_2_51:4.2
	Kernel-5_35-4_79_2_98_2_50:4.2
	Kernel-5_35-4_79_2_98_2_49:4.2
	Kernel-5_35-4_79_2_98_2_48:4.2
	Kernel-5_35-4_79_2_121:4.2
	Kernel-5_35-4_79_2_98_2_47:4.2
	Kernel-5_35-4_79_2_120:4.2
	Kernel-5_35-4_79_2_98_2_46:4.2
	Kernel-5_35-4_79_2_119:4.2
	Kernel-5_35-4_79_2_98_2_45:4.2
	Kernel-5_35-4_79_2_98_2_44:4.2
	Kernel-5_35-4_79_2_118:4.2
	Kernel-5_35-4_79_2_98_2_43:4.2
	Kernel-5_35-4_79_2_117:4.2
	Kernel-5_35-4_79_2_116:4.2
	Kernel-5_35-4_79_2_98_2_42:4.2
	Kernel-5_35-4_79_2_115:4.2
	Kernel-5_35-4_79_2_98_2_41:4.2
	Kernel-5_35-4_79_2_98_2_40:4.2
	Kernel-5_35-4_79_2_114:4.2
	Kernel-5_35-4_79_2_98_2_39:4.2
	Kernel-5_35-4_79_2_98_2_38:4.2
	Kernel-5_35-4_79_2_113:4.2
	Kernel-5_35-4_79_2_112:4.2
	Kernel-5_35-4_79_2_98_2_37:4.2
	Kernel-5_35-4_79_2_98_2_36:4.2
	Kernel-5_35-4_79_2_98_2_35:4.2
	Kernel-5_35-4_79_2_98_2_34:4.2
	Kernel-5_35-4_79_2_98_2_33:4.2
	Kernel-5_35-4_79_2_98_2_32:4.2
	Kernel-5_35-4_79_2_98_2_31:4.2
	Kernel-5_35-4_79_2_98_2_30:4.2
	Kernel-5_35-4_79_2_98_2_29:4.2
	Kernel-5_35-4_79_2_98_2_28:4.2
	Kernel-5_35-4_79_2_98_2_27:4.2
	Kernel-5_35-4_79_2_98_2_26:4.2
	Kernel-5_35-4_79_2_111:4.2
	Kernel-5_35-4_79_2_98_2_25:4.2
	Kernel-5_35-4_79_2_98_2_24:4.2
	Kernel-5_35-4_79_2_98_2_23:4.2
	Kernel-5_35-4_79_2_110:4.2
	Kernel-5_35-4_79_2_98_2_22:4.2
	Kernel-5_35-4_79_2_109:4.2
	Kernel-5_35-4_79_2_98_2_21:4.2
	Kernel-5_35-4_79_2_98_2_20:4.2
	Kernel-5_35-4_79_2_108:4.2
	Kernel-5_35-4_79_2_107:4.2
	Kernel-5_35-4_79_2_98_2_19:4.2
	Kernel-5_35-4_79_2_98_2_18:4.2
	Kernel-5_35-4_79_2_98_2_17:4.2
	Kernel-5_35-4_79_2_98_2_16:4.2
	Kernel-5_35-4_79_2_98_2_15:4.2
	Kernel-5_35-4_79_2_106:4.2
	Kernel-5_35-4_79_2_105:4.2
	Kernel-5_35-4_79_2_104:4.2
	Kernel-5_35-4_79_2_98_2_14:4.2
	Kernel-5_35-4_79_2_98_2_13:4.2
	Kernel-5_35-4_79_2_98_2_12:4.2
	Kernel-5_35-4_79_2_98_2_11:4.2
	Kernel-5_35-4_79_2_98_2_10:4.2
	Kernel-5_35-4_79_2_98_2_9:4.2
	Kernel-5_35-4_79_2_103:4.2
	Kernel-5_35-4_79_2_102:4.2
	Kernel-5_35-4_79_2_98_2_8:4.2
	Kernel-5_35-4_79_2_98_2_7:4.2
	Kernel-5_35-4_79_2_98_2_6:4.2
	Kernel-5_35-4_79_2_98_2_5:4.2
	Kernel-5_35-4_79_2_98_2_4:4.2
	Kernel-5_35-4_79_2_101:4.2
	Kernel-5_35-4_79_2_100:4.2
	Kernel-5_35-4_79_2_99:4.2
	Kernel-5_35-4_79_2_98_2_3:4.2
	Kernel-5_35-4_79_2_98_2_2:4.2
	Kernel-5_35-4_79_2_98_2_1:4.2
	Cortex:4.2.0.4
	Cortex_bp:4.2
	Kernel-5_35-4_79_2_98:4.2
	Kernel-5_35-4_79_2_97:4.2
	Kernel-5_35-4_79_2_96:4.2
	Kernel-5_35-4_79_2_95:4.2
	Kernel-5_35-4_79_2_94:4.2
	Kernel-5_35-4_79_2_93:4.2
	Kernel-5_35-4_79_2_92:4.2
	Kernel-5_35-4_79_2_91:4.2
	Kernel-5_35-4_79_2_90:4.2
	Kernel-5_35-4_79_2_89:4.2
	Kernel-5_35-4_79_2_88:4.2
	Kernel-5_35-4_79_2_87:4.2
	Kernel-5_35-4_79_2_86:4.2
	Kernel-5_35-4_79_2_85:4.2
	Kernel-5_35-4_79_2_84:4.2
	Kernel-5_35-4_79_2_83:4.2
	Kernel-5_35-4_79_2_82:4.2
	Kernel-5_35-4_79_2_81:4.2
	Kernel-5_35-4_79_2_80:4.2
	Kernel-5_35-4_79_2_79:4.2
	Kernel-5_35-4_79_2_78:4.2
	Kernel-5_35-4_79_2_77:4.2
	RO_5_07:4.2
	Kernel-5_35-4_79_2_76:4.2
	Kernel-5_35-4_79_2_75:4.2
	Kernel-5_35-4_79_2_74:4.2
	Kernel-5_35-4_79_2_73:4.2
	Kernel-5_35-4_79_2_72:4.2
	Kernel-5_35-4_79_2_71:4.2
	Kernel-5_35-4_79_2_70:4.2
	Kernel-5_35-4_79_2_69:4.2
	Kernel-5_35-4_79_2_68:4.2
	Kernel-5_35-4_79_2_67:4.2
	Kernel-5_35-4_79_2_66:4.2
	Kernel-5_35-4_79_2_65:4.2
	Kernel-5_35-4_79_2_64:4.2
	Kernel-5_35-4_79_2_63:4.2
	Kernel-5_35-4_79_2_62:4.2
	Kernel-5_35-4_79_2_61:4.2
	Kernel-5_35-4_79_2_59:4.2
	Kernel-5_35-4_79_2_58:4.2
	Kernel-5_35-4_79_2_57:4.2
	Kernel-5_35-4_79_2_56:4.2
	Kernel-5_35-4_79_2_55:4.2
	Kernel-5_35-4_79_2_54:4.2
	Kernel-5_35-4_79_2_53:4.2
	Kernel-5_35-4_79_2_52:4.2
	Kernel-5_35-4_79_2_51:4.2
	Kernel-5_35-4_79_2_50:4.2
	Kernel-5_35-4_79_2_49:4.2
	Kernel-5_35-4_79_2_48:4.2
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.6
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2
	Kernel-5_35-4_79_2_46:4.2
	Kernel-5_35-4_79_2_45:4.2
	Kernel-5_35-4_79_2_44:4.2
	Kernel-5_35-4_79_2_25_2_2:4.2
	Kernel-5_35-4_79_2_43:4.2
	Kernel-5_35-4_79_2_42:4.2
	Kernel-5_35-4_79_2_41:4.2
	Kernel-5_35-4_79_2_40:4.2
	Kernel-5_35-4_79_2_39:4.2
	Kernel-5_35-4_79_2_38:4.2
	Kernel-5_35-4_79_2_37:4.2
	Kernel-5_35-4_79_2_36:4.2
	Kernel-5_35-4_79_2_35:4.2
	Kernel-5_35-4_79_2_34:4.2
	Kernel-5_35-4_79_2_33:4.2
	Kernel-5_35-4_79_2_32:4.2
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2
	Kernel-5_35-4_79_2_30:4.2
	Kernel-5_35-4_79_2_29:4.2
	Kernel-5_35-4_79_2_28:4.2
	Kernel-5_35-4_79_2_27:4.2
	Kernel-5_35-4_79_2_26:4.2
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2
	Kernel-5_35-4_79_2_24:4.2
	Kernel-5_35-4_79_2_23:4.2
	Kernel-5_35-4_79_2_22:4.2
	Kernel-5_35-4_79_2_21:4.2
	Kernel-5_35-4_79_2_20:4.2
	Kernel-5_35-4_79_2_19:4.2
	Kernel-5_35-4_79_2_18:4.2
	Kernel-5_35-4_79_2_17:4.2
	Kernel-5_35-4_79_2_16:4.2
	Kernel-5_35-4_79_2_15:4.2
	Kernel-5_35-4_79_2_14:4.2
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2
	Kernel-5_35-4_79_2_12:4.2
	Kernel-5_35-4_79_2_11:4.2
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2
	Kernel-5_35-4_79_2_9:4.2
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2
	Kernel-5_35-4_79_2_7:4.2
	Kernel-5_35-4_79_2_6:4.2
	Kernel-5_35-4_79_2_5:4.2
	Kernel-5_35-4_79_2_4:4.2
	Kernel-5_35-4_79_2_3:4.2
	Kernel-5_35-4_79_2_2:4.2
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches;
next	4.3;
commitid	skOEjp3ipLHx6xcz;

4.3
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.04.04.14.27.41;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.39;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2012.10.28.16.51.51;	author rsprowson;	state Exp;
branches;
next	4.2.2.2;
commitid	ruXZqdTJKJ85Qaqw;

4.2.2.2
date	2013.08.06.22.43.10;	author jlee;	state Exp;
branches;
next	4.2.2.3;
commitid	TOIaeUf2Q4rBIr0x;

4.2.2.3
date	2013.10.06.18.02.42;	author jlee;	state Exp;
branches;
next	4.2.2.4;
commitid	6Bp9Hz2X0M7Ucg8x;

4.2.2.4
date	2013.10.13.15.15.31;	author jlee;	state Exp;
branches;
next	4.2.2.5;
commitid	2ACnPraaXQyB399x;

4.2.2.5
date	2016.05.22.12.42.51;	author jlee;	state Exp;
branches;
next	;
commitid	nDV8KQG2F69ZBt7z;

4.1.1.1
date	96.11.05.09.41.39;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.18;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.42;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.14;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.44;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduGrafH
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - Sprite stuff
;
; Authors   RManby, TDobson
; Started   10.11.86

; ************************************************************
; ***    C h a n g e   L i s t  (better late than never!)  ***
; ************************************************************

; Date       Description
; ----       -----------
; 17-Feb-88  Created change list
;            Fixed bug in SLOAD (errors weren't reported)
; 08-Apr-88  Changed LoadFile to use open with nodir + mustopen
; 20-May-88  Changed NoRoomToLoad to NotEnoughRoom

; *****************************************************************************
;
;       MergeSpriteFile - Merge sprite file from filing system
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> filename
;

MergeSpriteFile ROUT
        Push    R14
        KillSpChoosePtr
        LDR     R3, [R1, #saFree]
        ADD     R3, R3, R1
        BL      LoadFile        ; R1 -> sprite area, R2 -> filename
        Pull    PC, VS          ; R3 -> free space
        SUB     R2, R3, #4
        BL      MergeSpriteAreas ; in: R1 -> destination, R2 -> source, V=0
        Pull    R14
        RETURNVC

; *****************************************************************************
;
;       LoadSpriteFile - Load sprite file from filing system
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> filename
;

LoadSpriteFile ROUT
        KillSpChoosePtr
        ADD     R3, R1, #saNumber       ; R3 = load address

; and drop thru to LoadFile (V will be set/cleared by that routine)

; *****************************************************************************
;
;       LoadFile - Load sprite file to particular address
;
;       Internal routine, called by LoadSpriteFile, MergeSpriteFile
;
; in:   R1 -> sprite area
;       R2 -> filename
;       R3 = load address
;
; out:  VS => error during load, R0 -> error
;       VC => loaded OK, R0 undefined
;       R1-R11 preserved
;

LoadFile ROUT
        Push    "R1-R6, R14"

 ; new version (07-Dec-89) to help broadcast loader a bit

        Push    "R2,R3"                 ; filename ptr, load address
        LDR     R6, [R1, #saEnd]
        ADD     R6, R6, R1
        SUB     R6, R6, R3              ; free space = saEnd-LoadAddress

        MOV     R0, #OSFile_ReadInfo
        MOV     R1, R2                  ; filename ptr
        SWI     XOS_File                ; OSFILE(5), returns R0 type, R4 length
        BVS     %FT10                   ; R0 file type, R4 length

        TEQ     R0, #object_file        ; if not a file
        BNE     %FT08                   ; then make into suitable error

        CMP     R6, R4                  ; will file fit in available space ?
        ADRCCL  R0, SpriteErr_NotEnoughRoom
      [ International
        BLCC    TranslateError
      ]
        BCC     %FT10

; There is room to load file, so load the lot

        MOV     R0, #OSFile_Load
        Pull    "R1, R2"                ; filename ptr, load address
        MOV     R3, #0                  ; use given address
        SWI     XOS_File
        BVS     %FT20

; TMD 07-Oct-91 (G-RO-9262)
; New code inserted here
; Check validity of sprite file
; R4 = file length from XOS_File above

; TMD 06-Mar-92 (RP-0589)
; Validity check weakened to only check that
; offset to first sprite is < length of file

        LDR     R3, [sp, #2*4]          ; R3 = load address
        LDR     R1, [R3, #saFirst-4]    ; offset to first sprite must be < length of file
        CMP     R1, R4
        Pull    "R1-R6, PC",CC          ; R0 is corrupt, R1-R11 preserved, V=0

; it was a bad file, so make it look like an empty sprite area before erroring
; so that in SLoad case we don't get a naff sprite area.

05
        MOV     R0, #0
        STR     R0, [R3, #saNumber-4]
        MOV     R0, #SpriteAreaCBsize
        STR     R0, [R3, #saFirst-4]
        STR     R0, [R3, #saFree-4]

        ADRL    R0, SpriteErr_BadSpriteFile
      [ International
        BL      TranslateError
      ]
        B       %FT20

08
        MOV     R2, R0
        MOV     R0, #OSFile_MakeError   ; then make into suitable error
        SWI     XOS_File
10
        ADD     R13, R13, #2*4          ; balance stack
20
        Pull    "R1-R6, R14"            ; return with error
        STR     R0, [WsPtr, #RetnReg0]
        RETURNVS                        ; R1-R11 preserved

; *****************************************************************************
;
;       SaveSpriteFile - Save sprite area to filing system
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> filename
;

SaveSpriteFile ROUT
        LDR     R3, [R1, #saNumber]             ; if no sprites
        TEQ     R3, #0
        BEQ     %FT10                           ; then quit with error

        Push    R14
        ADD     R4, R1, #saNumber               ; save sprite area, excluding
        LDR     R5, [R1, #saFree]               ; free space or saEnd
        ADD     R5, R5, R1

        MOV     R0, #OSFile_SaveStamp
        MOV     R1, R2                          ; filename ptr
        LDR     R2, =&FF9                       ; type=SpriteFile
        MOV     R3, #0                          ; junk

        SWI     XOS_File                        ; save file
        STRVS   R0, [WsPtr, #RetnReg0]
        Pull    PC

10
        ADRL    R0, SpriteErr_NoSprites
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        STR     R0, [WsPtr, #RetnReg0]
        RETURNVS

        LTORG

; *****************************************************************************
;
;       MergeSpriteAreas - Merge two sprite areas
;
;       Internal routine, called by MergeSpriteFile
;
; in:   R1 -> destination sprite area
;       R2 -> source sprite area
;       V=0
;
; out:  All registers preserved
;

MergeSpriteAreas ROUT
        TEQ     R2, #0                  ; validate R2 (R1 already checked)
        BEQ     %FT90
        Push    "R1-R7, R14"

; Maintain two pointers to destination area - a read pointer and a write
; pointer. Enumerate all the sprites in the destination. If the corresponding
; sprite is found in the source area, advance the read pointer but leave the
; write pointer as-is. If the sprite isn't found, and read ptr != write ptr,
; CopyDown the dest sprite from read to write and then advance both pointers.
;
; Once all dest sprites enumerated, append entire src area to end of dest.
;
; This algorithm isn't optimal (O(N^2) search), but memory moved is O(N), which
; is a big improvement over the original implementation (O(N^2)).

        MOV     R3, R1                  ; R3 = dest area
        MOV     R1, R2                  ; R1 = src area
        ASSERT  saNumber = 4
        ASSERT  saFirst = 8
        LDMIB   R3, {R4, R5}
        MOV     R2, R3
        MOV     R6, R5
        MOV     R7, R4
        ; Loop start is slightly ugly to allow sneaky re-use of ADD instructions
05
        ADD     R6, R6, R2              ; write ptr
06
        ADD     R5, R5, R2              ; read ptr
10
        SUBS    R4, R4, #1
        BLT     %FT50
        ADD     R2, R5, #spName
        BL      SpriteCtrlBlkNoGetName
        LDR     R2, [R5, #spNext]
        SUBVC   R7, R7, #1              ; Sprite found, reduce dest sprite count
        BVC     %BT06                   ; Advance read ptr
        ; Sprite not found, copy down if necessary
        CMP     R5, R6
        BEQ     %BT05                   ; Advance read & writr ptr
        CopyDown R6, R5, R2, R14, R0    ; Advances R5 & R6 for us
        B       %BT10

50
        ; All duplicate sprites in dest removed
        ; Update area header and SpChoosePtr
        SUB     R6, R6, R3              ; New saFree
        LDR     R5, [R3, #saFree]
        CMP     R6, R5
        BEQ     %FT55
        STR     R7, [R3, #saNumber]
        STR     R6, [R3, #saFree]
        KillSpChoosePtr                 ; Only kill if something was deleted, to match old behaviour
55
        ; Append src sprites
        ASSERT  saNumber = 4
        ASSERT  saFirst = 8
        LDMIB   R1, {R4, R5}
        ADD     R2, R5, R1
        MOV     R1, R3
60
        SUBS    R4, R4, #1
        BLT     %FT80
        BL      AppendSprite            ; return R2 -> next sprite
                                        ; or error 'NoRoomToMerge'
        BVC     %BT60

80        
        Pull    "R1-R7, PC"             ; exit with V already set up

90
        ADRL    R0, SpriteErr_Bad2ndPtr
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        STR     R0, [WsPtr, #RetnReg0]
        RETURNVS

; *****************************************************************************
;
;       MergeSprite - Merge sprite into sprite area
;
;       Internal routine, called by MergeSpriteAreas
;
; in:   R1 -> destination area
;       R2 -> source sprite
;
; out:  R2 -> past end of source sprite (ie next sprite)
;

MergeSprite ROUT
        Push    "R1, R3-R5, R14"
        ADD     R2, R2, #spName
        BL      DeleteSpriteByName      ; in: R1-R2; out: all preserved
        SUB     R2, R2, #spName
AddSprite
        LDR     R3, [R1, #saFree]
        LDR     R5, [R1, #saEnd]
        SUB     R5, R5, R3              ; amount of free ram in dest area

        LDR     R4, [R2, #spNext]       ; space needed for sprite
        CMP     R5, R4
        BCC     %FT10

        ADD     R3, R3, R1              ; first free locn in dest. area
        CopyDown R3,R2,R4,R5,R14        ; NB CopyDown will exit with R3 -> end
                                        ; of dest area
        LDR     R4, [R1, #saNumber]     ; update number of sprites
        ADD     R4, R4, #1
        STR     R4, [R1, #saNumber]

        SUB     R3, R3, R1              ; and free space offset
        STR     R3, [R1, #saFree]

        Pull    "R1, R3-R5, R14"
        RETURNVC                        ; ignore 'not found' from DeleteSprite

10
        Pull    "R1, R3-R5, R14"
        ADRL    R0, SpriteErr_NoRoomToMerge
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        STR     R0, [WsPtr, #RetnReg0]
        RETURNVS

; *****************************************************************************
;
;       AppendSprite - Append sprite to sprite area
;
;       Internal routine, called by CopySprite
;
; in:   R1 -> destination area
;       R2 -> source sprite
;
; out:  R2 -> past end of source sprite (ie next sprite)
;

AppendSprite ROUT
        Push    "R1, R3-R5, R14"
        B       AddSprite

; *****************************************************************************
;
;       ExtendHorizontally - Add one column to RHS of the sprite
;
;       Internal routine, called by InsertCol
;
; in:   R1 -> sprite area
;       R2 -> sprite
;

ExtendHorizontally ROUT
        Push    "R3-R6, R9-R11, R14"
        LDR     R3, [R2, #spRBit]
        LDR     R4, [WsPtr, #SprBytesPerChar]
        ADD     R3, R3, R4              ; alter spRBit to include next pixel
        CMP     R3, #32
        BCC     %FT20
                                        ; >=32 means add 1 word to each row
        LDR     R3, [R2, #spHeight]
        ADD     R3, R3, #1              ; extend by (spHeight+1) words
        BL      ExtendSprite            ; (space doubled if mask present)
        Pull    "R3-R6, R9-R11, PC", VS ; no room, then give error

        MOV     R4, #0
        BL      MaskOffset              ; use spHeight+1 as row counter,
        MOVNE   R3, R3, LSL #1          ; doubled if mask present

        LDRNE   R5, [R2, #spTrans]      ; correct mask ptr, if mask present
        ADDNE   R5, R5, R3, LSL #1      ; R3 is words*2, hence LSL
        STRNE   R5, [R2, #spTrans]

        BL      InsertWords             ; Insert R3 words at position R4 in
                                        ; sprite, ie at beginning
        LDR     R5, [R2, #spWidth]
        ADD     R5, R5, #1              ; new spWidth
        STR     R5, [R2, #spWidth]

        LDR     R9, [R2, #spImage]
        ADD     R9, R9, R2              ; to
        ADD     R10, R9, R3, LSL #2     ; from

10
        MOV     R11, R5, LSL #2
                                        ; move one row
        CopyDown R9,R10,R11,R14,R6      ; To,From,Size, Temp

        STR     R4, [R9], #4            ; add 1 word at RH end of row
        SUBS    R3, R3, #1
        BHI     %BT10                   ; next row

        LDR     R3, [WsPtr, #SprBytesPerChar]
        SUBS    R3, R3, #1
20
        STR     R3, [R2, #spRBit]
        Pull    "R3-R6, R9-R11, R14"
        RETURNVC

; *****************************************************************************
;
;       ReduceHorizontally - Remove some bits from the RHS of the sprite
;
;       Internal routine, called by DeleteCol
;
; in:   R0 = number of bits to delete off right hand side
;       R1 -> sprite area
;       R2 -> sprite
;

ReduceHorizontally ROUT
        Push    "R3-R6, R9-R11, R14"
        LDR     R3, [R2, #spRBit]
        SUBS    R3, R3, R0              ; alter spRBit to exclude those bits
        ADDCC   R3, R3, #32             ; if underflow then extract whole word
        STR     R3, [R2, #spRBit]
        BCS     %FT20
                                        ; < 0 means remove 1 word per row
        LDR     R3, [R2, #spHeight]
        ADD     R3, R3, #1              ; remove (spHeight+1) words
        MOV     R4, #0
        BL      MaskOffset
        MOVNE   R3, R3, LSL #1          ; doubled if mask present

        LDRNE   R5, [R2, #spTrans]      ; correct mask ptr, if mask present
        SUBNE   R5, R5, R3, LSL #1      ; R3 is words*2, hence LSL
        STRNE   R5, [R2, #spTrans]

        LDR     R9, [R2, #spImage]
        ADD     R9, R9, R2              ; to
        MOV     R10, R9                 ; from
        LDR     R5, [R2, #spWidth]
10
        MOV     R11, R5, LSL #2
                                        ; move one row
        CopyDown R9,R10,R11,R14,R6      ; To,From,Size, Temp


        ADD     R10, R10, #4            ; skip unwanted word
        SUBS    R3, R3, #1
        BHI     %BT10                   ; next row

; R9 -> past end of this sprite
; R10 -> next sprite

        SUB     R3, R10, R9
        MOV     R3, R3, LSR #2          ; no. of words to remove
        SUB     R4, R9, R2
        LDR     R9, [R2, #spImage]
        SUB     R4, R4, R9              ; byte offset within image

        BL      RemoveWords

        LDR     R5, [R2, #spWidth]
        SUB     R5, R5, #1              ; new spWidth
        STR     R5, [R2, #spWidth]
20
        Pull    "R3-R6, R9-R11, R14"
        RETURNVC

; *****************************************************************************
;
;       InsertRow - Insert blank row into sprite
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = row number to insert below (0 => bottom, spHeight+1 => above top)
;

InsertRow ROUT
        Push    "R0,R4,R14"
        MOV     R0, #57                 ; SpriteOp reason code for insert/delete rows
        ORR     R0, R0, #512            ;Set it to use pointers to user area & sprite
        MOV     R4, #1                  ; We're only inserting one row! (put 1 in)
        SWI     XOS_SpriteOp
        BVS     %FT20

        Pull    "R0,R4,R14"
        RETURNVC                        ; exit OK

20
        STR     R0, [WsPtr, #RetnReg0]
        Pull    "R0,R4,R14"
        RETURNVS                        ; exit with error

; *****************************************************************************
;
;       DeleteRow - Delete row from sprite
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = row number to remove (0=bottom, spHeight=top)
;

DeleteRow ROUT
        Push    "R0,R4,R14"
        MOV     R0, #57                 ; SpriteOp reason code for insert/delete rows
        ORR     R0, R0, #512            ;Set it to use pointers to user area & sprite
        MVN     R4, #0                  ; We're only removing one row! (put -1 in)
        SWI     XOS_SpriteOp
        BVS     %FT20

        Pull    "R0,R4,R14"
        RETURNVC                        ; exit OK

20
        STR     R0, [WsPtr, #RetnReg0]
        Pull    "R0,R4,R14"
        RETURNVS                        ; exit with error

; *****************************************************************************
;
;       InsertCol - Insert blank column into sprite
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = column to insert at (0 => before left..width => after right)
;

InsertCol ROUT
        Push    "R0,R4,R14"
        MOV     R0, #58                 ; SpriteOp reason code for insert/delete cols
        ORR     R0, R0, #512            ;Set it to use pointers to user area & sprite
        MOV     R4, #1                  ; We're only inserting one column! (put 1 in)
        SWI     XOS_SpriteOp
        BVS     %FT20

        Pull    "R0,R4,R14"
        RETURNVC                        ; exit OK

20
        STR     R0, [WsPtr, #RetnReg0]
        Pull    "R0,R4,R14"
        RETURNVS                        ; exit with error

; *****************************************************************************
;
;       DeleteCol - Delete column from sprite
;
;       External routine, and LHWastageEntry called from RemoveLeftHandWastage
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = column number to remove (0 => left, width-1 => right)
;

DeleteCol ROUT
        Push    "R0,R4,R14"
        MOV     R0, #58                 ; SpriteOp reason code for insert/delete cols
        ORR     R0, R0, #512            ;Set it to use pointers to user area & sprite
        MVN     R4, #0                  ; We're only removing one row! (put -1 in)
        SWI     XOS_SpriteOp
        BVS     %FT20

        Pull    "R0,R4,R14"
        RETURNVC                        ; exit OK

20
        STR     R0, [WsPtr, #RetnReg0]
        Pull    "R0,R4,R14"
        RETURNVS                        ; exit with error

; *****************************************************************************
;
;       ExtendSprite - Add R3 words to the end of the sprite (R3*2 if mask)
;
;       Internal routine, called by ExtendHorizontally, InsertRow, CreateMask,
;        and ExtendSpriteByR3 called by GetSprite
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = no. of words to insert (gets doubled if mask present)
;

ExtendSpriteByR3 ROUT
        Push    "R3, R8-R11, R14"
        B       ExtendSprite10

ExtendSprite ROUT
        Push    "R3, R8-R11, R14"
        BL      MaskOffset
        MOVNE   R3, R3, LSL #1          ; double no. of words if mask present
ExtendSprite10
        LDR     R10, [R1, #saEnd]
        LDR     R11, [R1, #saFree]
        SUB     R10, R10, R3, LSL #2
        CMP     R10, R11
        BCC     %FT10

        LDR     R10, [R2, #spNext]
        ADD     R10, R10, R2            ; copy source
        ADD     R9, R10, R3, LSL #2     ; copy destination

        LDR     R11, [R1, #saFree]
        ADD     R11, R11, R1
        SUB     R11, R11, R10           ; size (bytes) to copy
        CopyUp  R9,R10,R11, R14, R8     ; To,From,Size,Temp, Temp2

        LDR     R9, [R1, #saFree]
        ADD     R9, R9, R3, LSL #2
        STR     R9, [R1, #saFree]       ; update saFree

        LDR     R9, [R2, #spNext]
        ADD     R9, R9, R3, LSL #2
        STR     R9, [R2, #spNext]       ; update spNext

        Pull    "R3, R8-R11, R14"
        RETURNVC

10
        ADRL    R0, SpriteErr_NoRoomToInsert
      [ International
        BL      TranslateError
      ]
        STR     R0, [WsPtr, #RetnReg0]
        Pull    "R3, R8-R11, R14"
        RETURNVS

; *****************************************************************************
;
;       InsertWords - Insert R3 words into given sprite at specified position
;
;       Internal routine, called by ExtendHorizontally, InsertRow
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = number of words to insert
;       R4 = insertion point (byte offset within sprite image)
;
;       NB Assumes ExtendSprite has been called to leave R3 extra words
;       at the end of the sprite
;
; out:  All registers preserved
;

InsertWords ROUT
        Push    "R8-R11, R14"
        LDR     R10, [R2, #spImage]
        ADD     R10, R10, R2
        ADD     R10, R10, R4            ; copy source
        ADD     R9, R10, R3, LSL #2     ; copy destination
        LDR     R11, [R2, #spNext]
        ADD     R11, R11, R2
        SUB     R11, R11, R9            ; size (bytes) to copy
        CopyUp  R9,R10,R11, R14,R8      ; To,From,Size,Temp, Temp2
        Pull    "R8-R11, R14"
        RETURNVC

; *****************************************************************************
;
;       ClearWords - Clear R3 words in sprite
;
;       Internal routine, called by InsertRow, CreateSprite
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = number of words to clear
;       R4 = byte offset within sprite image to clear from
;
; out:  All registers preserved
;

ClearWords ROUT
        Push    "R9-R11, R14"
        LDR     R10, [R2, #spImage]
        ADD     R10, R10, R2
        ADD     R10, R10, R4            ; clear from
        MOVS    R9, R3
        MOVNE   R11, #0
10
        STRNE   R11, [R10], #4
        SUBNES  R9, R9, #1
        BNE     %BT10
        Pull    "R9-R11, R14"
        RETURNVC

; *****************************************************************************
;
;       RemoveWords - Delete R3 words from given sprite
;
;       Internal routine, called by ReduceHorizontally, DeleteRow, RemoveMask,
;        GetSprite
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = number of words to remove
;       R4 = removal point (byte offset within sprite image)
;
; out:  All registers preserved
;       spNext (in sprite) and spFree (in sprite area) updated
;

RemoveWords ROUT
        Push    "R8-R11, R14"
        LDR     R9, [R2, #spImage]
        ADD     R9, R9, R2
        ADD     R9, R9, R4              ; copy destination
        ADD     R10, R9, R3, LSL #2     ; copy source
        LDR     R11, [R1, #saFree]
        ADD     R11, R11, R1
        SUB     R11, R11, R10           ; size (bytes) to copy
        CopyDown R9,R10,R11, R14,R8     ; To,From,Size,Temp, temp2
        SUB     R9, R9, R1
        STR     R9, [R1, #saFree]       ; update saFree
        LDR     R9, [R2, #spNext]
        SUB     R9, R9, R3, LSL #2
        STR     R9, [R2, #spNext]       ; update spNext
        Pull    "R8-R11, PC"

; *****************************************************************************
;
;       MaskOffset - Read mask size (0 if absent)
;
;       Internal routine, called by ExtendHorizontally, ReduceHorizontally,
;        InsertRow, DeleteRow, ExtendSprite, FlipAboutXAxis
;
; in:   R2 -> sprite
;
; out:  R0 = 0 if no mask, otherwise mask size
;       EQ if no mask, NE if mask present
;

MaskOffset ROUT
        Push    R14
        LDR     R0, [R2, #spImage]
        LDR     R14, [R2, #spTrans]
        SUBS    R0, R14, R0             ; offset from Image to Trans mask
                                        ; =0 if no mask
        Pull    PC                      ; return EQ/NE for nomask/mask

; *****************************************************************************
;
;       ReadPixelColour - Read colour of a pixel in a given sprite
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = X coordinate of pixel (0 = left)
;       R4 = Y coordinate of pixel (0 = bottom)
;
; out:  RetnReg5 = colour  (0..NColour) or  0..63
;       RetnReg6 = tint     0           or  0/64/128/192
;

ReadPixelColour ROUT
        Push    R14
        BL      SpriteGenAddr           ; returns R6,      R7
        Pull    PC, VS                  ;         Address, Bit position
        LDR     R5, [R6]                ; word from sprite
        LDR     R6, [WsPtr, #SprReadNColour]

        CMP     R6, #63                 ; check for 256 colour
        MOVEQ   R6, #255

        AND     R0, R6, R5, LSR R7      ; extract one pixel (bit0..)

        CMP     R6, #255

        MOVNE   R2, R0                  ; colour = pixel
        MOVNE   R3, #0                  ; tint   = 0
        BNE     %FT10

        ;now check for size of palette
        ADD     R2, R2, #spImage        ; point to image/mask start
        LDMIA   R2, {R2, R3}
        CMP     R3, R3
        MOVGT   R3, R3
        SUB     R2, R2, #spPalette
        CMP     R2, #&0800
        BEQ     %FT05

        ;see comment below - for this call to work we have to temporarily
        ;set NColour to SprReadNColour

        LDR     R8,[WsPtr,#NColour]
        STR     R6,[WsPtr,#NColour]

        BL      ExtractTintAndColour    ; else extract colour & tint from pixel

        STR     R8,[WsPtr,#NColour]
        B       %FT10
05
        MOV     R2, R0
        MOV     R3, #0
10
        STR     R2, [WsPtr, #RetnReg5]  ; pass colour in R5
        STR     R3, [WsPtr, #RetnReg6]  ; and tint in R6
        Pull    R14
        RETURNVC

; *****************************************************************************
;
;       WritePixelColour - Write a pixel in a given sprite
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = X coordinate of pixel (0 = left)
;       R4 = Y coordinate of pixel (0 = bottom)
;       R5 = pixel colour
;       R6 = tint
;
; out:  R1-R11 preserved
;

; amg: note. need to handle full palettes differently here - since the GCOL and TINT
; model should not apply. Check for a full palette on an 8bpp sprite and deal with
; it accordingly.
; amg: bug fix to MED-01885. Although ReadPixel and WritePixel use SprReadNColour,
; then call AddTintToColour which uses NColour - being the screen's value not the
; sprites. Therefore, the safest fix this near freeze is to simply temporarily change
; the NColour value for the call, and then restore it.

WritePixelColour ROUT
        Push    "R1-R4, R14"
        LDR     R8, [WsPtr, #SprReadNColour]

        AND     R0, R5, R8              ; limit colour to 0..NColour

        CMP     R8, #63                 ; check for 256 colours
        CMPNE   R8, #255
        BNE     %FT08                   ; despatch non 8bpp

        ;now need to determine size of 8bpp sprite's palette
        ADD     R3, R2, #spImage        ; point to image/mask start
        LDMIA   R3, {R2, R3}            ; fetch them
        CMP     R2, R3                  ; which is higher
        MOVGT   R2, R3                  ; use the lesser
        SUB     R2, R2, #spPalette      ; subtract start offset
        CMP     R2, #&800

      [ {FALSE}
        MOVNE   R3, R6                  ; then combine

        ;see comment above - for this call to work we have to temporarily
        ;set NColour to SprReadNColour

        LDRNE   R7,[WsPtr,#NColour]
        STRNE   R8,[WsPtr,#NColour]

        BLNE    AddTintToColour         ; colour & tint

        STRNE   R7,[WsPtr,#NColour]
      |
        BEQ     %FT05
        ; Rather than mess around with NColour, just include the guts of the tinting code here
        MOV     r1, r6, LSR #6                  ; r1 =   0  0  0  0  0  0 T1 T0
        AND     r1, r1, #3
        AND     r2, r0, #2_00100001             ; r2 =   0  0 B3  0  0  0  0 R2
        ORR     r1, r1, r2, LSL #2              ; r1 =  B3  0  0  0  0 R2 T1 T0
        AND     r2, r0, #2_00010000             ; r2 =   0  0  0 B2  0  0  0  0
        ORR     r1, r1, r2, LSR #1              ; r1 =  B3  0  0  0 B2 R2 T1 T0
        AND     r2, r0, #2_00001110             ; r2 =   0  0  0  0 G3 G2 R3  0
        ORR     r0, r1, r2, LSL #3              ; r0 =  B3 G3 G2 R3 B2 R2 T1 T0
        
      ]

        B       %FT05                   ; 8 bpp take this branch
08
        ADDCC   R0, R0, R8              ; else index into full colour table
        ADRCCL  R5, TBFullCol
        LDRCCB  R0, [R5, R0]            ; N.B. a table of bytes
        BCC     %FT05                   ; 1,2,4 bpp take this branch

        ; if 16bpp only need to shift round once, if 32bpp not at all
        LDR     LR, [WsPtr,#SprLog2BPP]
        CMP     LR, #4
        MOV     R5, R0
        BCS     %FT06                   ; 32 bpp takes this branch

        B       %FT07                   ; and 16 bpp takes this one
05
        ORR     R5, R0, R0, LSL #8      ; expand byte value into a word
07
        ORR     R5, R5, R5, LSL #16
06
        Pull    "R1-R4"
        BL      SpriteGenAddr           ; returns R6,      R7
        Pull    PC, VS                  ;         Address, Bit position
        LDR     R8, [WsPtr, #SprWriteNColour]
        AND     R5, R5, R8              ; limit colour to pixel width
        LDR     R0, [R6]                ; word from sprite
        BIC     R0, R0, R8, LSL R7
        ORR     R0, R0, R5, LSL R7
        STR     R0, [R6]
        Pull    R14
        RETURNVC

; *****************************************************************************
;
;       ReadPixelMask - Read mask state for a pixel in a given sprite
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = X coordinate of pixel (0 = left)
;       R4 = Y coordinate of pixel (0 = bottom)
;
; out:  RetnReg5 = 0/1 (transparent/solid) or 0-255 for alpha-mask sprites
;

ReadPixelMask ROUT
        Push    R14
        LDR     R5, [R2, #spImage]
        LDR     R6, [R2, #spTrans]
        SUBS    R5, R6, R5              ; offset from Image to Trans mask
        BEQ     %FT20                   ; if =0, no mask so pixel is solid
        BL      SpriteMaskAddr          ; returns R6,      R7
        Pull    PC, VS                  ;         Address, Bit position
        LDR     R5, [R6, R5]            ; word from mask

        LDR     LR, [R2, #spMode]       ; check mask type
        MOVS    LR, LR, ASR #27
        MOVMI   R5, R5, LSR R7          ; alpha mask
        ANDMI   R5, R5, #255
        BMI     %FT10
        MOVNE   R6, #1                  ; 1bpp mask
        LDREQ   R6, [WsPtr, #SprReadNColour]

        ANDS    R5, R6, R5, LSR R7      ; extract one mask pixel (bit0..)
        MOVNE   R5, #1
10
        STR     R5, [WsPtr, #RetnReg5]
        Pull    R14
        RETURNVC

20
        LDR     LR, [R2, #spMode]       ; check mask type
        TST     LR, #&80000000
        MOVEQ   R5, #1
        MOVNE   R5, #255
        STR     R5, [WsPtr, #RetnReg5]
        Pull    R14
        RETURNVC

; *****************************************************************************
;
;       WritePixelMask - Write a pixel in the mask for a given sprite
;
;       External routine
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = X coordinate of pixel (0 = left)
;       R4 = Y coordinate of pixel (0 = bottom)
;       R5 = pixel mask 0/1 (transparent/solid) or 0-255 for alpha-mask sprites
;

WritePixelMask ROUT
        Push    R14
        LDR     R8, [R2, #spImage]
        LDR     R9, [R2, #spTrans]
        SUBS    R9, R9, R8              ; offset from Image to Trans mask
        BEQ     %FT10                   ; if =0, no mask so quit
        BL      SpriteMaskAddr          ; returns R6,      R7
        Pull    PC, VS                  ;         Address, Bit position

        LDR     LR, [R2, #spMode]
        MOVS    LR, LR, ASR #27
        MOVMI   R8, #255                ; alpha mask
        BMI     %FT05
        
        LDREQ   R8, [WsPtr, #SprWriteNColour]
        MOVNE   R8, #1                  ; 1bpp mask

        TEQ     R5, #0
        MOVNE   R5, R8
05
        LDR     R0, [R6, R9]            ; word from mask
        BIC     R0, R0, R8, LSL R7
        ORR     R0, R0, R5, LSL R7
        STR     R0, [R6, R9]
10
        Pull    R14
        RETURNVC

; *****************************************************************************
;
;       SpriteGenAddr - Generate address for a given (X,Y) position
;
;       SpriteMaskAddr - For use on mask (copes with old/new/alpha masks)
;
;       Internal routine, called by InsertCol, DeleteCol, ReadPixelColour,
;        WritePixelColour, ReadPixelMask, WritePixelMask
;
;       Note that InsertCol and DeleteCol are *not* being altered for the
;       present round of 1bpp mask work.
;
;
; in:   R1 -> sprite area
;       R2 -> sprite
;       R3 = X coordinate of pixel (0 = left)
;       R4 = Y coordinate of pixel (0 = bottom)
;
; out:  R6 = address
;       R7 = bit position of pixel
;       R1-R5, R8-R11 preserved
;       V=1 => outside sprite, R0 -> error
;

SpriteMaskAddr ROUT
        Push    "R1-R5, R8-R11, LR"

        LDR     R11, [R2, #spMode]
        MOVS    R11, R11, LSR #27       ; get the sprite type from the mode word
        BEQ     %FT10                   ; branch: old format, use old routine as is

        ADD     R5, R2, #spWidth
        LDMIA   R5, {R5-R8}             ; R5     ,R6      ,R7    ,R8
                                        ; spWidth,spHeight,spLBit,spRBit
        SUBS    R4, R6, R4              ; invert Y coord
        BCC     %FT90                   ; must be in range 0..spHeight

        BL      GetMaskspWidth          ; change R5 to suit the mask width
                                        ; and R8 to new last bit used

        MLA     R0, R5, R4, R4          ; word offset to row = Y*(width+1)

        ;for new format masks the depth is fixed, so...

        TST     R11, #16                ; alpha mask or 1bpp mask?

        MOVEQ   R11, #0                 ; Log2BPC
        MOVEQ   R9, #5                  ; XShftFactor
        MOVEQ   R10, #31                ; SprNPix
        MOVNE   R11, #3                 ; Log2BPC
        MOVNE   R9, #2                  ; XShftFactor
        MOVNE   R10, #3                 ; SprNPix

        B       %FT20                   ; and continue in the old code

SpriteGenAddr
        Push    "R1-R5, R8-R11, LR"
10
        ADD     R5, R2, #spWidth
        LDMIA   R5, {R5-R8}             ; R5     ,R6      ,R7    ,R8
                                        ; spWidth,spHeight,spLBit,spRBit
        SUBS    R4, R6, R4              ; invert Y coord
        BCC     %FT90                   ; must be in range 0..spHeight

        MLA     R0, R5, R4, R4          ; word offset to row = Y*(width+1)

        LDR     R9, [WsPtr, #SprXShftFactor]
        LDR     R10, [WsPtr, #SprNPix]
        LDR     R11, [WsPtr, #SprLog2BPC]
20
        BitLOffset R6,R3, R9,R10,R11
        WordOffset R3,R3, R9,R10,R11

; sprite starts LBit bits into word
; so add LBit to bit offset

        ADD     R7, R6, R7
        ADD     R3, R3, R7, LSR #5      ; if offset>=32 then inc word address
        AND     R7, R7, #31             ; force offset into range 0..31

        CMP     R3, R5                  ; R3 should now be in range 0..spWidth
        CMPEQ   R7, R8                  ; if R3=spWidth, then check bit posn
        BHI     %FT90                   ; is within sprite

        ADD     R6, R0, R3              ; word offset into sprite
        ADD     R6, R2, R6, LSL #2
        LDR     R8, [R2, #spImage]
        ADD     R6, R6, R8              ; byte address of word in sprite

        Pull    "R1-R5, R8-R11, LR"
        RETURNVC

90
        ADRL    R0, SpriteErr_InvalidRowOrCol
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        STR     R0, [WsPtr, #RetnReg0]
        Pull    "R1-R5, R8-R11, LR"
        RETURNVS


; *****************************************************************************
;
;       GetMaskspWidth - convert spWidth for data to spWidth for mask (1bpp & alpha masks)
;
;       Internal routine, called from spritemaskaddr & switchouputtomask
;
; in:   R5 = spWidth (ie width in words-1)
;       (expects R2->sprite)
;
; out:  R5 = spWidth (words -1) for mask data
;       R8 modified for new last bit used in mask data

; should only be called for new format sprites, but will cope with old too

;NOTE: If any changes are made to this routine, please look at the SpriteExtend
;source too, as there is a very similiar routine there too (in SprAdjSize). WT

GetMaskspWidth ROUT
        Push    "R0,LR"

        LDR     R0, [R2, #spMode]       ; fetch the sprite mode
        ANDS    LR, R0, #15<<27         ; isolate the sprite type and test for =0

        Pull    "R0,PC",EQ              ; if an old format sprite, return R5 unchanged

        TEQ     LR, #SpriteType_RISCOS5<<27
      [ NoARMT2
        ANDEQ   LR, R0, #127<<20
        MOVEQ   LR, LR, LSR #20
      |
        UBFXEQ  LR, R0, #20, #7
      ]
        MOVNE   LR, LR, LSR #27


        ; treat any T>max sprites as 32bpp
        CMP     LR, #SpriteType_RO5MAX
        MOVCS   LR, #SpriteType_Substitute

        TST     R0, #&80000000

        ; bugfix 9/8/93: get log2bpp this way
        ADRL    R0, NSM_bpptable-4
        LDR     LR, [R0, LR, LSL #2]    ; get the log2bpp to LR

        RSB     R0, LR, #5              ; and change to 5-log2bpp

        MOV     R5, R5, LSL R0          ; width in pixels

        LDR     R0, [R2, #spRBit]
        ADD     R0, R0, #1
        ADD     R5, R5, R0, LSR LR

        MOVNE   R5, R5, LSL #3          ; make 8 times wider if alpha mask

        ANDS    LR, R5, #&1F            ; fit exactly in a number of words ?
        SUB     R8, LR, #1              ; alter the last bit used for the mask data
                                        ; fix bug MED-01130....
        AND     R8, R8, #&1F            ; ....bring back into range 00-1F (may be -1 here)
        MOVNE   LR, #1                  ; if not, add an extra word
        ADD     R5, LR, R5, LSR #5      ; add the whole number of words
        SUB     R5, R5, #1              ; returns as words-1

        Pull    "R0,PC"
        

; *****************************************************************************
;
;       RemoveLeftHandWastage - Remove left-hand wastage from a sprite
;
;       Internal routine, but made external for testing
;
; in:   R1 -> sprite area
;       R2 -> sprite
;

RemoveLeftHandWastage ROUT
        LDR     R0, [R2, #spLBit]
        CMP     R0, #0                  ; is there any wastage ?
        MOVEQ   PC, R14                 ; no, then exit straight away

        Push    "R1, R2, R14"           ; get stack the same as in DeleteCol
        LDR     R11, [R2, #spImage]
        ADD     R11, R11, R2            ; R11 := address of first word
        MOV     R7, #0                  ; bit position of first pixel
        STR     R7, [R2, #spLBit]       ; pretend LBit = 0
        MOV     R10, #0                 ; byte offset from LH end to delete pt.

        LDR     R9, [R2, #spWidth]
        MOV     R9, R9, LSL #2          ; byte offset from delete pt to LH end
                                        ; of next row -4
        LDR     R8, [R2, #spNext]
        ADD     R8, R8, R2              ; first byte after sprite

        MOV     R2, R0                  ; number of bits to delete
LHWastageEntry
        RSB     R3, R2, #32                     ; LShft := 32-RShft

        MOV     R4, #1
        RSB     R4, R4, R4, LSL R7      ; mask for pixels left of deletion pt.
        MVN     R5, R4                  ; inclusive & right of extractn. pt.

; R0,   R1,   R2   ,R3   ,R4   ,R5   ,R6   ,R7     ,R8    ,R9     ,R10   .R11
;   ,     ,   RShft,LShft,LMask,RMask,     ,WordCnt,EndAdr,WordOff,RowOff,Adr

; R11 -> LH end of row

10
        ADD     R11, R11, R10           ; step to deletion point
        LDR     R0, [R11]
        AND     R1, R5, R0, LSR R2      ; extract & shift rightmost pixels
                                        ; (ie MSBits)
        AND     R0, R4, R0              ; extract leftmost pixels (ie LSBits)
        ORR     R0, R0, R1              ; recombine (unwanted pixel removed)
        LDR     R1, [R11, #4]           ; shift leftmost pixel of next word
        ORR     R0, R0, R1, LSL R3      ; in at rightmost end of this word
        STR     R0, [R11], #4           ; NB #4 to cope with naff rowoff (R10)
        CMP     R9, #0
        BEQ     %FT30
        MOV     R7, R9
20
        LDMIA   R11,{R0,R1}             ; now do a 1 pixel shift left
        MOV     R0, R0, LSR R2          ; of the rest of the row
        ORR     R0, R0, R1, LSL R3
        STR     R0, [R11], #4
        SUBS    R7, R7, #4
        BGT     %BT20

; R11 -> LH end of next row

30
        CMP     R8, R11
        BHI     %BT10                   ; if EndAdr>Adr, do next row

        MOV     R0, R2                  ; R0 = number of bits to delete
        LDMFD   R13, {R1,R2}
        BL      ReduceHorizontally
        Pull    "R1-R2, R14"
        RETURNVC

60
        STR     R0, [WsPtr, #RetnReg0]
70
        Pull    "R1-R2, R14"
        RETURNVS


        END
@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a182 1
        [ AssemblingArthur :LOR: Module
a186 6
        |
        MOV     R0, #0                          ; normal save
        MOV     R1, R2                          ; filename ptr
        MOV     R2, #0
        MOV     R3, #0
        ]
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d226 64
a289 2
        BEQ     %FT30
        Push    "R1-R4, R14"
d291 2
a292 14
        LDR     R4, [R2, #saNumber]     ; number of sprites to merge
        TEQ     R4, #0
        BEQ     %FT20                   ; nothing to merge

        LDR     R3, [R2, #saFirst]
        ADD     R2, R2, R3
10                                      ; R1 -> dest area CB,
        BL      MergeSprite             ; R2 -> to sprite CB
                                        ; return R2 -> next sprite
        BVS     %FT20                   ; error 'NoRoomToMerge'
        SUBS    R4, R4, #1              ; (V:=0 if becoming zero)
        BNE     %BT10
20
        Pull    "R1-R4, PC"             ; exit with V already set up
d294 1
a294 1
30
d867 1
d879 13
d901 2
a902 3
        LDR     LR, [R2, #spMode]
        MOV     LR, LR, LSR #27
        CMP     LR, #6
d935 1
a935 1
; out:  RetnReg5 = 0/1 (transparent/solid)
d943 1
a943 2
        MOVEQ   R5, #1                  ; if =0, no mask so pixel is solid
        BEQ     %FT10
d948 6
a953 3
        LDR     LR, [R2, #spMode]       ; check for 1bpp masks
        MOVS    LR, LR, LSR #27
        MOVNE   R6, #1
d963 9
d982 1
a982 1
;       R5 = pixel mask 0/1 (transparent/solid)
d995 4
a998 1
        MOVS    LR, LR, LSR #27
d1000 1
a1000 1
        MOVNE   R8, #1                  ; adjust for new format sprites
d1004 1
d1017 1
a1017 1
;       SpriteMaskAddr - For use on mask (copes with old/new masks)
d1040 2
a1041 2
        LDR     LR, [R2, #spMode]
        MOVS    LR, LR, LSR #27         ; get the sprite type from the mode word
d1057 8
a1064 3
        MOV     R9, #5                  ; XShftFactor
        MOV     R10, #31                ; SprNPix
        MOV     R11, #0                 ; Log2BPC
d1119 1
a1119 1
;       GetMaskspWidth - convert spWidth for data to spWidth for mask (1bpp masks)
d1137 2
a1138 2
        LDR     LR, [R2, #spMode]       ; fetch the sprite mode
        MOVS    LR, LR, LSR #27         ; isolate the sprite type and test for =0
d1142 10
d1153 1
a1153 1
        CMP     LR, #SpriteType_MAX
d1156 2
d1162 1
a1162 1
        RSB     LR, LR, #5              ; and change to 5-log2bpp
d1164 1
a1164 1
        MOV     R5, R5, LSL LR          ; number of pixels for full words
a1165 1
        RSB     LR, LR, #5              ; now switch back to log2bpp
d1170 2
d1181 1
a1181 1

a1263 23
; ******************************************************************************
;
;        bounce_new_format_masks - object to masks on new format sprites
;
;        enter with R2->sprite
;        either returns with all registers preserved, or VS and R0->error

bounce_new_format_masks ROUT
        STMFD   R13!,{R0,R14}
        LDR     LR, [R2, #spMode]       ; fetch the sprites mode
        MOVS    LR, LR, LSR #27         ; set NE if new format
        LDMEQFD R13!,{R0,R15}           ; out now if old format
        BL      MaskOffset              ; returns R0=mask size, EQ if no mask, NE if mask
        LDMEQFD R13!,{R0,R15}           ; out now if no mask
        ADRL    R0, SpriteErr_NoMaskOrPaletteAllowedInThisDepth
        [ International
        BL      TranslateError
        ]
        SETV
        STR     R0,[R13]
        STR     R0,[WsPtr, #RetnReg0]
        LDMFD   R13!,{R0,R15}

@


4.2.2.1
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d1183 1
a1183 1
      [ International
d1185 1
a1185 1
      |
a1186 1
      ]
@


4.2.2.2
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@a816 1
      [ {FALSE}
a827 13
      |
        BEQ     %FT05
        ; Rather than mess around with NColour, just include the guts of the tinting code here
        MOV     r1, r6, LSR #6                  ; r1 =   0  0  0  0  0  0 T1 T0
        AND     r1, r1, #3
        AND     r2, r0, #2_00100001             ; r2 =   0  0 B3  0  0  0  0 R2
        ORR     r1, r1, r2, LSL #2              ; r1 =  B3  0  0  0  0 R2 T1 T0
        AND     r2, r0, #2_00010000             ; r2 =   0  0  0 B2  0  0  0  0
        ORR     r1, r1, r2, LSR #1              ; r1 =  B3  0  0  0 B2 R2 T1 T0
        AND     r2, r0, #2_00001110             ; r2 =   0  0  0  0 G3 G2 R3  0
        ORR     r0, r1, r2, LSL #3              ; r0 =  B3 G3 G2 R3 B2 R2 T1 T0
        
      ]
d837 3
a839 2
        LDR     LR, [WsPtr,#SprLog2BPP]
        CMP     LR, #4
d872 1
a872 1
; out:  RetnReg5 = 0/1 (transparent/solid) or 0-255 for alpha-mask sprites
d886 2
a887 6
        LDR     LR, [R2, #spMode]       ; check mask type
        TST     LR, #&80000000          ; alpha mask?
        MOVNE   R5, R5, LSR R7
        ANDNE   R5, R5, #255
        BNE     %FT10
        MOVS    LR, LR, LSR #27         ; 1bpp mask?
d908 1
a908 1
;       R5 = pixel mask 0/1 (transparent/solid) or 0-255 for alpha-mask sprites
a920 4
        TST     LR, #&80000000
        MOVNE   R8, #255                ; alpha mask
        BNE     %FT05
        
d923 1
a923 1
        MOVNE   R8, #1                  ; 1bpp mask
a926 1
05
d939 1
a939 1
;       SpriteMaskAddr - For use on mask (copes with old/new/alpha masks)
d962 2
a963 2
        LDR     R11, [R2, #spMode]
        MOVS    R11, R11, LSR #27       ; get the sprite type from the mode word
d979 2
a980 2
        TST     R11, #16                ; alpha mask or 1bpp mask?

a981 4
        MOVEQ   R9, #5                  ; XShftFactor
        MOVEQ   R10, #31                ; SprNPix
        MOVNE   R8, #2                  ; XShftFactor
        MOVNE   R10, #3                 ; SprNPix
d1036 1
a1036 1
;       GetMaskspWidth - convert spWidth for data to spWidth for mask (1bpp & alpha masks)
d1054 2
a1055 2
        LDR     R0, [R2, #spMode]       ; fetch the sprite mode
        ANDS    LR, R0, #15<<27         ; isolate the sprite type and test for =0
a1058 10
        TEQ     LR, #SpriteType_RISCOS5<<27
      [ NoARMT2
        ANDEQ   LR, R0, #127<<20
        MOVEQ   LR, LR, LSR #20
      |
        UBFXEQ  LR, R0, #20, #7
      ]
        MOVNE   LR, LR, LSR #27


d1060 1
a1060 1
        CMP     LR, #SpriteType_RO5MAX
a1062 2
        TST     R0, #&80000000

d1067 1
a1067 1
        RSB     R0, LR, #5              ; and change to 5-log2bpp
d1069 1
a1069 1
        MOV     R5, R5, LSL R0          ; width in pixels
d1071 1
a1075 2
        MOVNE   R5, R5, LSL #3          ; make 8 times wider if alpha mask

d1085 1
a1085 1
        
d1168 24
@


4.2.2.3
log
@Fix plotting of RISC OS 5 type sprites and masks. Fix hang when attempting to report "alpha mask not supported" error. Fix reading/writing of alpha mask pixels.
Detail:
  s/vdu/vdugrafg - Fixed PutSprite and PlotMask to correctly deal with RISC OS 5 type sprite mode words. Fix infinite loops in PutSpriWideMaskErr casued by R14 getting trashed.
  s/vdu/vdugrafh - Fixed SpriteMaskAddr malfunctioning when trying to calculate addresses in alpha masks. Minor ReadPixelMask & WritePixelMask optimisations.
  s/vdu/vduswis - Fixed OS_ScreenMode 13 & 14 to count "G2" as a valid colour specifier.
Admin:
  Tested on BB-xM
  Should hopefully fix the random hangs reported on the forums when trying to use sprites with alpha masks


Version 5.35, 4.79.2.197. Tagged as 'Kernel-5_35-4_79_2_197'
@
text
@d900 6
a905 5
        MOVS    LR, LR, ASR #27
        MOVMI   R5, R5, LSR R7          ; alpha mask
        ANDMI   R5, R5, #255
        BMI     %FT10
        MOVNE   R6, #1                  ; 1bpp mask
d938 3
a940 3
        MOVS    LR, LR, ASR #27
        MOVMI   R8, #255                ; alpha mask
        BMI     %FT05
d942 1
d1006 1
a1006 1
        MOVNE   R9, #2                  ; XShftFactor
@


4.2.2.4
log
@More alpha mask read/write fixes
Detail:
  s/vdu/vdugrafh - Fixed SpriteMaskAddr to use the right Log2BPC value when generating addressed for alpha masks. Fix ReadPixelMask to return 255 when sprite has now mask, but mode word has wide mask bit set.
Admin:
  Tested on BB-xM
  Reading/writing alpha mask pixels now works properly across the whole image


Version 5.35, 4.79.2.198. Tagged as 'Kernel-5_35-4_79_2_198'
@
text
@d893 2
a894 1
        BEQ     %FT20                   ; if =0, no mask so pixel is solid
a913 9
20
        LDR     LR, [R2, #spMode]       ; check mask type
        TST     LR, #&80000000
        MOVEQ   R5, #1
        MOVNE   R5, #255
        STR     R5, [WsPtr, #RetnReg5]
        Pull    R14
        RETURNVC

d1001 1
a1001 1
        MOVEQ   R11, #0                 ; Log2BPC
a1003 1
        MOVNE   R11, #3                 ; Log2BPC
@


4.2.2.5
log
@[308] SpriteOp 11 (merge sprite areas) gets slow for large numbers of sprites
Detail:
  s/vdu/vdugrafh - Rewrite MergeSpriteAreas so that memory movement is now O(N) instead of O(N^2). Checking for duplicate sprites is still slow (O(N^2) search), but this resolves the main performance bottleneck with the code.
  s/vdu/vdugrafg - Add a variant of SpriteCtrlBlk which skips the call to GetName; this helps MergeSpriteAreas for the common case of a dest area with lots of sprites and a source area with a handful of sprites (SpriteCtrlBlk is now called on the source area once per dest sprite, previously was called on the dest area once per source sprite).
Admin:
  Tested on Raspberry Pi 1, merging Sovereign theme Sprites11 file with itself (2.2MB file, 358 sprites)
  Old code took 860cs, new code takes 18cs (15cs of which appears to be loading the second copy of the file, judging by *SLoad timings)


Version 5.35, 4.79.2.321. Tagged as 'Kernel-5_35-4_79_2_321'
@
text
@d226 2
a227 2
        BEQ     %FT90
        Push    "R1-R7, R14"
d229 14
a242 61
; Maintain two pointers to destination area - a read pointer and a write
; pointer. Enumerate all the sprites in the destination. If the corresponding
; sprite is found in the source area, advance the read pointer but leave the
; write pointer as-is. If the sprite isn't found, and read ptr != write ptr,
; CopyDown the dest sprite from read to write and then advance both pointers.
;
; Once all dest sprites enumerated, append entire src area to end of dest.
;
; This algorithm isn't optimal (O(N^2) search), but memory moved is O(N), which
; is a big improvement over the original implementation (O(N^2)).

        MOV     R3, R1                  ; R3 = dest area
        MOV     R1, R2                  ; R1 = src area
        ASSERT  saNumber = 4
        ASSERT  saFirst = 8
        LDMIB   R3, {R4, R5}
        MOV     R2, R3
        MOV     R6, R5
        MOV     R7, R4
        ; Loop start is slightly ugly to allow sneaky re-use of ADD instructions
05
        ADD     R6, R6, R2              ; write ptr
06
        ADD     R5, R5, R2              ; read ptr
10
        SUBS    R4, R4, #1
        BLT     %FT50
        ADD     R2, R5, #spName
        BL      SpriteCtrlBlkNoGetName
        LDR     R2, [R5, #spNext]
        SUBVC   R7, R7, #1              ; Sprite found, reduce dest sprite count
        BVC     %BT06                   ; Advance read ptr
        ; Sprite not found, copy down if necessary
        CMP     R5, R6
        BEQ     %BT05                   ; Advance read & writr ptr
        CopyDown R6, R5, R2, R14, R0    ; Advances R5 & R6 for us
        B       %BT10

50
        ; All duplicate sprites in dest removed
        ; Update area header and SpChoosePtr
        SUB     R6, R6, R3              ; New saFree
        LDR     R5, [R3, #saFree]
        CMP     R6, R5
        BEQ     %FT55
        STR     R7, [R3, #saNumber]
        STR     R6, [R3, #saFree]
        KillSpChoosePtr                 ; Only kill if something was deleted, to match old behaviour
55
        ; Append src sprites
        ASSERT  saNumber = 4
        ASSERT  saFirst = 8
        LDMIB   R1, {R4, R5}
        ADD     R2, R5, R1
        MOV     R1, R3
60
        SUBS    R4, R4, #1
        BLT     %FT80
        BL      AppendSprite            ; return R2 -> next sprite
                                        ; or error 'NoRoomToMerge'
        BVC     %BT60
d244 1
a244 4
80        
        Pull    "R1-R7, PC"             ; exit with V already set up

90
@


4.1
log
@Initial revision
@
text
@d56 1
a56 1
        BICS    PC, R14, #V_bit
d161 1
a161 1
        ORRS    PC, R14, #V_bit         ; R1-R11 preserved
d207 1
a207 1
        ORRS    PC, R14, #V_bit
d235 1
a235 1
10                                      ; R1 -> dest area CB, 
d252 1
a252 1
        ORRS    PC, R14, #V_bit
d291 1
a291 1
        BICS    PC, R14, #V_bit         ; ignore 'not found' from DeleteSprite
d302 1
a302 1
        ORRS    PC, R14, #V_bit
d353 1
a353 1
        LDR     R5, [R2, #spWidth]            
d375 1
a375 1
        BICS    PC, R14, #V_bit
d409 1
a409 1
        LDR     R5, [R2, #spWidth]            
d431 1
a431 1
        LDR     R5, [R2, #spWidth]            
d436 1
a436 1
        BICS    PC, R14, #V_bit
d458 1
a458 1
        BICS    PC, R14, #V_bit         ; exit OK
d463 1
a463 1
        ORRS    PC, R14, #V_bit         ; exit with error
d485 1
a485 1
        BICS    PC, R14, #V_bit         ; exit OK
d490 1
a490 1
        ORRS    PC, R14, #V_bit         ; exit with error
d512 1
a512 1
        BICS    PC, R14, #V_bit         ; exit OK
d517 1
a517 1
        ORRS    PC, R14, #V_bit         ; exit with error
d539 1
a539 1
        BICS    PC, R14, #V_bit         ; exit OK
d544 1
a544 1
        ORRS    PC, R14, #V_bit         ; exit with error
d591 1
a591 1
        BICS    PC, R14, #V_bit
d600 1
a600 1
        ORRS    PC, R14, #V_bit
d630 1
a630 1
        BICS    PC, R14, #V_bit
d658 1
a658 1
        BICS    PC, R14, #V_bit
d735 1
a735 1
                    
d740 1
a740 1
             
d744 3
a746 3
        MOVNE   R3, #0                  ; tint   = 0 
        BNE     %FT10                 
        
d754 2
a755 1
                  
d759 4
a762 4
        LDRNE   R8,[WsPtr,#NColour]
        STRNE   R6,[WsPtr,#NColour]
        
        BLNE    ExtractTintAndColour    ; else extract colour & tint from pixel
d764 5
a768 4
        STRNE   R8,[WsPtr,#NColour]
        
        MOVEQ   R2, R0
        MOVEQ   R3, #0
d773 1
a773 1
        BICS    PC, R14, #V_bit
d793 1
a793 1
; it accordingly. 
d802 1
a802 1
        
d804 1
a804 1
        
d806 3
a808 3
        CMPNE   R8, #255                            
        BNE     %FT08                   ; despatch non 8bpp       
        
d816 3
a818 3
        
        MOVNE   R3, R6                  ; then combine     
        
d821 1
a821 1
        
d824 1
a824 1
        
d826 1
a826 1
        
d828 1
a828 1
        
d842 1
a842 1
        
d859 1
a859 1
        BICS    PC, R14, #V_bit
d885 1
a885 1
        
d890 1
a890 1
        
d896 1
a896 1
        BICS    PC, R14, #V_bit
d933 1
a933 1
        BICS    PC, R14, #V_bit
d961 1
a961 1
        
d965 1
a965 1
        
d971 1
a971 1
        
d985 1
a985 1
SpriteGenAddr 
d987 1
a987 1
10        
d1020 1
a1020 1
        BICS    PC,Link,#V_bit
d1031 1
a1031 1
        ORRS    PC, R14, #V_bit
d1042 1
a1042 1
;                                                                    
d1050 1
a1050 1
                
d1053 1
a1053 1
        
d1056 1
a1056 1
        
d1058 1
a1058 1
                                             
d1062 1
a1062 1
        
d1066 1
a1066 1
        
d1070 1
a1070 1
                                           
d1072 1
a1072 1
        LDR     R0, [R2, #spRBit] 
d1075 1
a1075 1
        
d1083 1
a1083 1
        
d1099 2
a1100 2
        TEQ     R0, #0                  ; is there any wastage ?
        BICEQS  PC, R14, #V_bit         ; no, then exit straight away
d1159 1
a1159 1
        BICS    PC, R14, #V_bit
d1165 1
a1165 1
        ORRS    PC, R14, #V_bit
d1171 1
a1171 1
;               
d1176 1
a1176 1
        STMFD   R13!,{R0,R14} 
d1185 2
a1186 2
        ] 
        SETV             
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d109 1
d111 1
d147 1
d149 1
d183 1
d188 6
d201 1
d205 1
d246 1
d250 1
d296 1
d300 1
d595 1
d597 1
d1022 1
d1026 1
d1181 1
d1183 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

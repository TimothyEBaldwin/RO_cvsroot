head	4.3;
access;
symbols
	Kernel-6_14:4.3
	Kernel-6_01-3:4.3
	Kernel-6_13:4.3
	Kernel-6_12:4.3
	Kernel-6_11:4.3
	Kernel-6_10:4.3
	Kernel-6_09:4.3
	Kernel-6_08-4_129_2_10:4.3
	Kernel-6_08-4_129_2_9:4.3
	Kernel-6_08:4.3
	Kernel-6_07:4.3
	Kernel-6_06:4.3
	Kernel-6_05-4_129_2_8:4.3
	Kernel-6_05:4.3
	Kernel-6_04:4.3
	Kernel-6_03:4.3
	Kernel-6_01-2:4.3
	Kernel-6_01-4_146_2_1:4.3
	Kernel-6_02:4.3
	Kernel-6_01-1:4.3
	Kernel-6_01:4.3
	Kernel-6_00:4.3
	Kernel-5_99:4.3
	Kernel-5_98:4.3
	Kernel-5_97-4_129_2_7:4.3
	Kernel-5_97:4.3
	Kernel-5_96:4.3
	Kernel-5_95:4.3
	Kernel-5_94:4.3
	Kernel-5_93:4.3
	Kernel-5_92:4.3
	Kernel-5_91:4.3
	Kernel-5_90:4.3
	Kernel-5_89-4_129_2_6:4.3
	Kernel-5_89:4.3
	Kernel-5_88-4_129_2_5:4.3
	Kernel-5_88-4_129_2_4:4.3
	Kernel-5_88:4.3
	Kernel-5_87:4.3
	Kernel-5_86-4_129_2_3:4.3
	Kernel-5_86-4_129_2_2:4.3
	Kernel-5_86-4_129_2_1:4.3
	Kernel-5_86:4.3
	SMP:4.3.0.2
	SMP_bp:4.3
	Kernel-5_85:4.3
	Kernel-5_54-1:4.3
	Kernel-5_84:4.3
	Kernel-5_83:4.3
	Kernel-5_82:4.3
	Kernel-5_81:4.3
	Kernel-5_80:4.3
	Kernel-5_79:4.3
	Kernel-5_78:4.3
	Kernel-5_77:4.3
	Kernel-5_76:4.3
	Kernel-5_75:4.3
	Kernel-5_74:4.3
	Kernel-5_73:4.3
	Kernel-5_72:4.3
	Kernel-5_71:4.3
	Kernel-5_70:4.3
	Kernel-5_69:4.3
	Kernel-5_68:4.3
	Kernel-5_67:4.3
	Kernel-5_66:4.3
	Kernel-5_65:4.3
	Kernel-5_64:4.3
	Kernel-5_63:4.3
	Kernel-5_62:4.3
	Kernel-5_61:4.3
	Kernel-5_60:4.3
	Kernel-5_59:4.3
	Kernel-5_58:4.3
	Kernel-5_57:4.3
	Kernel-5_56:4.3
	Kernel-5_55:4.3
	Kernel-5_54:4.3
	Kernel-5_53:4.3
	Kernel-5_52:4.3
	Kernel-5_51:4.3
	Kernel-5_50:4.3
	Kernel-5_49:4.3
	HAL_merge:4.2.2.5
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.5
	Kernel-5_35-4_79_2_326:4.2.2.5
	Kernel-5_35-4_79_2_325:4.2.2.5
	Kernel-5_35-4_79_2_324:4.2.2.5
	Kernel-5_35-4_79_2_323:4.2.2.5
	Kernel-5_35-4_79_2_322:4.2.2.5
	Kernel-5_35-4_79_2_321:4.2.2.5
	Kernel-5_35-4_79_2_320:4.2.2.5
	Kernel-5_35-4_79_2_319:4.2.2.5
	Kernel-5_35-4_79_2_318:4.2.2.5
	Kernel-5_35-4_79_2_317:4.2.2.5
	Kernel-5_35-4_79_2_316:4.2.2.5
	Kernel-5_35-4_79_2_315:4.2.2.5
	Kernel-5_35-4_79_2_314:4.2.2.5
	Kernel-5_35-4_79_2_313:4.2.2.5
	Kernel-5_35-4_79_2_312:4.2.2.5
	Kernel-5_35-4_79_2_311:4.2.2.5
	Kernel-5_35-4_79_2_310:4.2.2.5
	Kernel-5_35-4_79_2_309:4.2.2.5
	Kernel-5_35-4_79_2_308:4.2.2.5
	Kernel-5_35-4_79_2_307:4.2.2.5
	Kernel-5_35-4_79_2_306:4.2.2.5
	Kernel-5_35-4_79_2_305:4.2.2.5
	Kernel-5_35-4_79_2_304:4.2.2.5
	Kernel-5_35-4_79_2_303:4.2.2.5
	Kernel-5_35-4_79_2_302:4.2.2.5
	Kernel-5_35-4_79_2_301:4.2.2.5
	Kernel-5_35-4_79_2_300:4.2.2.5
	Kernel-5_35-4_79_2_299:4.2.2.5
	Kernel-5_35-4_79_2_298:4.2.2.5
	Kernel-5_35-4_79_2_297:4.2.2.5
	Kernel-5_35-4_79_2_296:4.2.2.5
	Kernel-5_35-4_79_2_295:4.2.2.5
	Kernel-5_35-4_79_2_294:4.2.2.5
	Kernel-5_35-4_79_2_293:4.2.2.5
	Kernel-5_35-4_79_2_292:4.2.2.5
	Kernel-5_35-4_79_2_291:4.2.2.5
	Kernel-5_35-4_79_2_290:4.2.2.5
	Kernel-5_35-4_79_2_289:4.2.2.5
	Kernel-5_35-4_79_2_288:4.2.2.5
	Kernel-5_35-4_79_2_287:4.2.2.5
	Kernel-5_35-4_79_2_286:4.2.2.5
	Kernel-5_35-4_79_2_285:4.2.2.5
	Kernel-5_35-4_79_2_284:4.2.2.5
	Kernel-5_35-4_79_2_283:4.2.2.5
	Kernel-5_35-4_79_2_282:4.2.2.5
	Kernel-5_35-4_79_2_281:4.2.2.5
	Kernel-5_35-4_79_2_280:4.2.2.5
	Kernel-5_35-4_79_2_279:4.2.2.5
	Kernel-5_35-4_79_2_278:4.2.2.5
	Kernel-5_35-4_79_2_277:4.2.2.5
	Kernel-5_35-4_79_2_276:4.2.2.5
	Kernel-5_35-4_79_2_275:4.2.2.5
	Kernel-5_35-4_79_2_274:4.2.2.5
	Kernel-5_35-4_79_2_273:4.2.2.5
	Kernel-5_35-4_79_2_272:4.2.2.5
	Kernel-5_35-4_79_2_271:4.2.2.5
	Kernel-5_35-4_79_2_270:4.2.2.5
	Kernel-5_35-4_79_2_269:4.2.2.5
	Kernel-5_35-4_79_2_268:4.2.2.5
	Kernel-5_35-4_79_2_267:4.2.2.5
	Kernel-5_35-4_79_2_266:4.2.2.5
	Kernel-5_35-4_79_2_265:4.2.2.5
	Kernel-5_35-4_79_2_264:4.2.2.5
	Kernel-5_35-4_79_2_263:4.2.2.5
	Kernel-5_35-4_79_2_262:4.2.2.5
	Kernel-5_35-4_79_2_261:4.2.2.5
	Kernel-5_35-4_79_2_260:4.2.2.5
	Kernel-5_35-4_79_2_259:4.2.2.5
	Kernel-5_35-4_79_2_258:4.2.2.5
	Kernel-5_35-4_79_2_257:4.2.2.5
	Kernel-5_35-4_79_2_256:4.2.2.5
	Kernel-5_35-4_79_2_255:4.2.2.5
	Kernel-5_35-4_79_2_254:4.2.2.5
	Kernel-5_35-4_79_2_253:4.2.2.5
	Kernel-5_35-4_79_2_252:4.2.2.5
	Kernel-5_35-4_79_2_251:4.2.2.5
	Kernel-5_35-4_79_2_250:4.2.2.5
	Kernel-5_35-4_79_2_249:4.2.2.5
	Kernel-5_35-4_79_2_248:4.2.2.5
	Kernel-5_35-4_79_2_247:4.2.2.5
	Kernel-5_35-4_79_2_246:4.2.2.5
	Kernel-5_35-4_79_2_245:4.2.2.5
	Kernel-5_35-4_79_2_244:4.2.2.5
	Kernel-5_35-4_79_2_243:4.2.2.5
	Kernel-5_35-4_79_2_242:4.2.2.5
	Kernel-5_35-4_79_2_241:4.2.2.5
	Kernel-5_35-4_79_2_240:4.2.2.5
	Kernel-5_35-4_79_2_239:4.2.2.5
	Kernel-5_35-4_79_2_238:4.2.2.5
	Kernel-5_35-4_79_2_237:4.2.2.5
	Kernel-5_35-4_79_2_236:4.2.2.5
	Kernel-5_35-4_79_2_235:4.2.2.5
	Kernel-5_35-4_79_2_234:4.2.2.5
	Kernel-5_35-4_79_2_233:4.2.2.5
	Kernel-5_35-4_79_2_232:4.2.2.5
	Kernel-5_35-4_79_2_231:4.2.2.5
	Kernel-5_35-4_79_2_230:4.2.2.5
	Kernel-5_35-4_79_2_229:4.2.2.5
	Kernel-5_35-4_79_2_228:4.2.2.5
	Kernel-5_35-4_79_2_227:4.2.2.5
	Kernel-5_35-4_79_2_226:4.2.2.5
	Kernel-5_35-4_79_2_225:4.2.2.5
	Kernel-5_35-4_79_2_224:4.2.2.5
	Kernel-5_35-4_79_2_223:4.2.2.5
	Kernel-5_35-4_79_2_222:4.2.2.5
	Kernel-5_35-4_79_2_221:4.2.2.5
	Kernel-5_35-4_79_2_220:4.2.2.5
	Kernel-5_35-4_79_2_219:4.2.2.5
	Kernel-5_35-4_79_2_218:4.2.2.5
	Kernel-5_35-4_79_2_217:4.2.2.5
	Kernel-5_35-4_79_2_216:4.2.2.5
	Kernel-5_35-4_79_2_215:4.2.2.5
	Kernel-5_35-4_79_2_214:4.2.2.5
	Kernel-5_35-4_79_2_213:4.2.2.5
	Kernel-5_35-4_79_2_212:4.2.2.5
	Kernel-5_35-4_79_2_211:4.2.2.5
	Kernel-5_35-4_79_2_210:4.2.2.5
	Kernel-5_35-4_79_2_209:4.2.2.5
	Kernel-5_35-4_79_2_208:4.2.2.5
	Kernel-5_35-4_79_2_207:4.2.2.5
	Kernel-5_35-4_79_2_206:4.2.2.5
	Kernel-5_35-4_79_2_205:4.2.2.5
	Kernel-5_35-4_79_2_204:4.2.2.5
	Kernel-5_35-4_79_2_203:4.2.2.4
	Kernel-5_35-4_79_2_202:4.2.2.3
	Kernel-5_35-4_79_2_201:4.2.2.3
	Kernel-5_35-4_79_2_200:4.2.2.3
	Kernel-5_35-4_79_2_199:4.2.2.3
	Kernel-5_35-4_79_2_198:4.2.2.3
	Kernel-5_35-4_79_2_197:4.2.2.3
	Kernel-5_35-4_79_2_196:4.2.2.3
	Kernel-5_35-4_79_2_195:4.2.2.3
	Kernel-5_35-4_79_2_194:4.2.2.3
	Kernel-5_35-4_79_2_193:4.2.2.3
	Kernel-5_35-4_79_2_192:4.2.2.3
	Kernel-5_35-4_79_2_191:4.2.2.3
	Kernel-5_35-4_79_2_190:4.2.2.3
	Kernel-5_35-4_79_2_189:4.2.2.3
	Kernel-5_35-4_79_2_188:4.2.2.3
	Kernel-5_35-4_79_2_187:4.2.2.3
	Kernel-5_35-4_79_2_186:4.2.2.3
	Kernel-5_35-4_79_2_185:4.2.2.3
	Kernel-5_35-4_79_2_184:4.2.2.3
	Kernel-5_35-4_79_2_183:4.2.2.3
	Kernel-5_35-4_79_2_182:4.2.2.3
	Kernel-5_35-4_79_2_181:4.2.2.3
	Kernel-5_35-4_79_2_180:4.2.2.3
	Kernel-5_35-4_79_2_179:4.2.2.3
	Kernel-5_35-4_79_2_178:4.2.2.3
	Kernel-5_35-4_79_2_177:4.2.2.3
	Kernel-5_35-4_79_2_176:4.2.2.3
	Kernel-5_35-4_79_2_175:4.2.2.3
	Kernel-5_35-4_79_2_174:4.2.2.3
	Kernel-5_35-4_79_2_173:4.2.2.3
	Kernel-5_35-4_79_2_172:4.2.2.3
	Kernel-5_35-4_79_2_171:4.2.2.3
	Kernel-5_35-4_79_2_170:4.2.2.3
	Kernel-5_35-4_79_2_169:4.2.2.3
	Kernel-5_35-4_79_2_168:4.2.2.3
	Kernel-5_35-4_79_2_167:4.2.2.3
	Kernel-5_35-4_79_2_166:4.2.2.3
	Kernel-5_35-4_79_2_165:4.2.2.3
	RPi_merge:4.2.2.3
	Kernel-5_35-4_79_2_147_2_23:4.2.2.3
	Kernel-5_35-4_79_2_147_2_22:4.2.2.3
	Kernel-5_35-4_79_2_147_2_21:4.2.2.3
	Kernel-5_35-4_79_2_147_2_20:4.2.2.3
	Kernel-5_35-4_79_2_147_2_19:4.2.2.3
	Kernel-5_35-4_79_2_147_2_18:4.2.2.3
	Kernel-5_35-4_79_2_164:4.2.2.3
	Kernel-5_35-4_79_2_163:4.2.2.3
	Kernel-5_35-4_79_2_147_2_17:4.2.2.3
	Kernel-5_35-4_79_2_147_2_16:4.2.2.3
	Kernel-5_35-4_79_2_147_2_15:4.2.2.3
	Kernel-5_35-4_79_2_162:4.2.2.3
	Kernel-5_35-4_79_2_161:4.2.2.3
	Kernel-5_35-4_79_2_147_2_14:4.2.2.3
	Kernel-5_35-4_79_2_147_2_13:4.2.2.3
	Kernel-5_35-4_79_2_160:4.2.2.3
	Kernel-5_35-4_79_2_159:4.2.2.3
	Kernel-5_35-4_79_2_158:4.2.2.3
	Kernel-5_35-4_79_2_157:4.2.2.3
	Kernel-5_35-4_79_2_156:4.2.2.3
	Kernel-5_35-4_79_2_147_2_12:4.2.2.3
	Kernel-5_35-4_79_2_147_2_11:4.2.2.3
	Kernel-5_35-4_79_2_155:4.2.2.3
	Kernel-5_35-4_79_2_147_2_10:4.2.2.3
	Kernel-5_35-4_79_2_154:4.2.2.3
	Kernel-5_35-4_79_2_153:4.2.2.3
	Kernel-5_35-4_79_2_147_2_9:4.2.2.3
	Kernel-5_35-4_79_2_152:4.2.2.3
	Kernel-5_35-4_79_2_151:4.2.2.3
	Kernel-5_35-4_79_2_147_2_8:4.2.2.3
	Kernel-5_35-4_79_2_147_2_7:4.2.2.3
	Kernel-5_35-4_79_2_150:4.2.2.3
	Kernel-5_35-4_79_2_147_2_6:4.2.2.3
	Kernel-5_35-4_79_2_147_2_5:4.2.2.3
	Kernel-5_35-4_79_2_149:4.2.2.3
	Kernel-5_35-4_79_2_147_2_4:4.2.2.3
	Kernel-5_35-4_79_2_147_2_3:4.2.2.3
	Kernel-5_35-4_79_2_148:4.2.2.3
	Kernel-5_35-4_79_2_147_2_2:4.2.2.3
	Kernel-5_35-4_79_2_147_2_1:4.2.2.3
	RPi:4.2.2.3.0.2
	RPi_bp:4.2.2.3
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2.2.2
	alees_Kernel_dev:4.2.2.2.0.4
	alees_Kernel_dev_bp:4.2.2.2
	Kernel-5_35-4_79_2_147:4.2.2.3
	Kernel-5_35-4_79_2_146:4.2.2.3
	Kernel-5_35-4_79_2_145:4.2.2.3
	Kernel-5_35-4_79_2_144:4.2.2.3
	Kernel-5_35-4_79_2_143:4.2.2.3
	Kernel-5_35-4_79_2_142:4.2.2.3
	Kernel-5_35-4_79_2_141:4.2.2.3
	Kernel-5_35-4_79_2_140:4.2.2.3
	Kernel-5_35-4_79_2_139:4.2.2.3
	Kernel-5_35-4_79_2_138:4.2.2.3
	Kernel-5_35-4_79_2_137:4.2.2.3
	Kernel-5_35-4_79_2_136:4.2.2.3
	Kernel-5_35-4_79_2_135:4.2.2.3
	Kernel-5_35-4_79_2_134:4.2.2.3
	Kernel-5_35-4_79_2_133:4.2.2.3
	Kernel-5_35-4_79_2_132:4.2.2.3
	Kernel-5_35-4_79_2_131:4.2.2.3
	Kernel-5_35-4_79_2_130:4.2.2.3
	Kernel-5_35-4_79_2_129:4.2.2.3
	Kernel-5_35-4_79_2_128:4.2.2.3
	Kernel-5_35-4_79_2_127:4.2.2.3
	Kernel-5_35-4_79_2_126:4.2.2.3
	Kernel-5_35-4_79_2_125:4.2.2.2
	Kernel-5_35-4_79_2_124:4.2.2.2
	Kernel-5_35-4_79_2_123:4.2.2.2
	Cortex_merge:4.2.2.2
	Kernel-5_35-4_79_2_122:4.2.2.2
	Kernel-5_35-4_79_2_98_2_54:4.2.2.2
	Kernel-5_35-4_79_2_98_2_53:4.2.2.2
	Kernel-5_35-4_79_2_98_2_52:4.2.2.2
	Kernel-5_35-4_79_2_98_2_51:4.2.2.2
	Kernel-5_35-4_79_2_98_2_50:4.2.2.2
	Kernel-5_35-4_79_2_98_2_49:4.2.2.2
	Kernel-5_35-4_79_2_98_2_48:4.2.2.2
	Kernel-5_35-4_79_2_121:4.2.2.2
	Kernel-5_35-4_79_2_98_2_47:4.2.2.2
	Kernel-5_35-4_79_2_120:4.2.2.2
	Kernel-5_35-4_79_2_98_2_46:4.2.2.2
	Kernel-5_35-4_79_2_119:4.2.2.2
	Kernel-5_35-4_79_2_98_2_45:4.2.2.2
	Kernel-5_35-4_79_2_98_2_44:4.2.2.2
	Kernel-5_35-4_79_2_118:4.2.2.2
	Kernel-5_35-4_79_2_98_2_43:4.2.2.2
	Kernel-5_35-4_79_2_117:4.2.2.2
	Kernel-5_35-4_79_2_116:4.2.2.2
	Kernel-5_35-4_79_2_98_2_42:4.2.2.2
	Kernel-5_35-4_79_2_115:4.2.2.2
	Kernel-5_35-4_79_2_98_2_41:4.2.2.2
	Kernel-5_35-4_79_2_98_2_40:4.2.2.2
	Kernel-5_35-4_79_2_114:4.2.2.2
	Kernel-5_35-4_79_2_98_2_39:4.2.2.2
	Kernel-5_35-4_79_2_98_2_38:4.2.2.2
	Kernel-5_35-4_79_2_113:4.2.2.2
	Kernel-5_35-4_79_2_112:4.2.2.2
	Kernel-5_35-4_79_2_98_2_37:4.2.2.2
	Kernel-5_35-4_79_2_98_2_36:4.2.2.2
	Kernel-5_35-4_79_2_98_2_35:4.2.2.2
	Kernel-5_35-4_79_2_98_2_34:4.2.2.2
	Kernel-5_35-4_79_2_98_2_33:4.2.2.2
	Kernel-5_35-4_79_2_98_2_32:4.2.2.2
	Kernel-5_35-4_79_2_98_2_31:4.2.2.2
	Kernel-5_35-4_79_2_98_2_30:4.2.2.2
	Kernel-5_35-4_79_2_98_2_29:4.2.2.2
	Kernel-5_35-4_79_2_98_2_28:4.2.2.2
	Kernel-5_35-4_79_2_98_2_27:4.2.2.2
	Kernel-5_35-4_79_2_98_2_26:4.2.2.2
	Kernel-5_35-4_79_2_111:4.2.2.2
	Kernel-5_35-4_79_2_98_2_25:4.2.2.2
	Kernel-5_35-4_79_2_98_2_24:4.2.2.2
	Kernel-5_35-4_79_2_98_2_23:4.2.2.2
	Kernel-5_35-4_79_2_110:4.2.2.2
	Kernel-5_35-4_79_2_98_2_22:4.2.2.2
	Kernel-5_35-4_79_2_109:4.2.2.2
	Kernel-5_35-4_79_2_98_2_21:4.2.2.2
	Kernel-5_35-4_79_2_98_2_20:4.2.2.2
	Kernel-5_35-4_79_2_108:4.2.2.2
	Kernel-5_35-4_79_2_107:4.2.2.2
	Kernel-5_35-4_79_2_98_2_19:4.2.2.2
	Kernel-5_35-4_79_2_98_2_18:4.2.2.2
	Kernel-5_35-4_79_2_98_2_17:4.2.2.2
	Kernel-5_35-4_79_2_98_2_16:4.2.2.2
	Kernel-5_35-4_79_2_98_2_15:4.2.2.2
	Kernel-5_35-4_79_2_106:4.2.2.2
	Kernel-5_35-4_79_2_105:4.2.2.2
	Kernel-5_35-4_79_2_104:4.2.2.2
	Kernel-5_35-4_79_2_98_2_14:4.2.2.2
	Kernel-5_35-4_79_2_98_2_13:4.2.2.2
	Kernel-5_35-4_79_2_98_2_12:4.2.2.2
	Kernel-5_35-4_79_2_98_2_11:4.2.2.2
	Kernel-5_35-4_79_2_98_2_10:4.2.2.2
	Kernel-5_35-4_79_2_98_2_9:4.2.2.2
	Kernel-5_35-4_79_2_103:4.2.2.2
	Kernel-5_35-4_79_2_102:4.2.2.2
	Kernel-5_35-4_79_2_98_2_8:4.2.2.2
	Kernel-5_35-4_79_2_98_2_7:4.2.2.2
	Kernel-5_35-4_79_2_98_2_6:4.2.2.2
	Kernel-5_35-4_79_2_98_2_5:4.2.2.2
	Kernel-5_35-4_79_2_98_2_4:4.2.2.2
	Kernel-5_35-4_79_2_101:4.2.2.2
	Kernel-5_35-4_79_2_100:4.2.2.2
	Kernel-5_35-4_79_2_99:4.2.2.2
	Kernel-5_35-4_79_2_98_2_3:4.2.2.2
	Kernel-5_35-4_79_2_98_2_2:4.2.2.2
	Kernel-5_35-4_79_2_98_2_1:4.2.2.2
	Cortex:4.2.2.2.0.2
	Cortex_bp:4.2.2.2
	Kernel-5_35-4_79_2_98:4.2.2.2
	Kernel-5_35-4_79_2_97:4.2.2.2
	Kernel-5_35-4_79_2_96:4.2.2.2
	Kernel-5_35-4_79_2_95:4.2.2.2
	Kernel-5_35-4_79_2_94:4.2.2.2
	Kernel-5_35-4_79_2_93:4.2.2.2
	Kernel-5_35-4_79_2_92:4.2.2.2
	Kernel-5_35-4_79_2_91:4.2.2.2
	Kernel-5_35-4_79_2_90:4.2.2.2
	Kernel-5_35-4_79_2_89:4.2.2.2
	Kernel-5_35-4_79_2_88:4.2.2.2
	Kernel-5_35-4_79_2_87:4.2.2.2
	Kernel-5_35-4_79_2_86:4.2.2.2
	Kernel-5_35-4_79_2_85:4.2.2.2
	Kernel-5_35-4_79_2_84:4.2.2.2
	Kernel-5_35-4_79_2_83:4.2.2.2
	Kernel-5_35-4_79_2_82:4.2.2.2
	Kernel-5_35-4_79_2_81:4.2.2.2
	Kernel-5_35-4_79_2_80:4.2.2.2
	Kernel-5_35-4_79_2_79:4.2.2.2
	Kernel-5_35-4_79_2_78:4.2.2.2
	Kernel-5_35-4_79_2_77:4.2.2.2
	RO_5_07:4.2.2.2
	Kernel-5_35-4_79_2_76:4.2.2.2
	Kernel-5_35-4_79_2_75:4.2.2.2
	Kernel-5_35-4_79_2_74:4.2.2.2
	Kernel-5_35-4_79_2_73:4.2.2.2
	Kernel-5_35-4_79_2_72:4.2.2.2
	Kernel-5_35-4_79_2_71:4.2.2.2
	Kernel-5_35-4_79_2_70:4.2.2.2
	Kernel-5_35-4_79_2_69:4.2.2.2
	Kernel-5_35-4_79_2_68:4.2.2.2
	Kernel-5_35-4_79_2_67:4.2.2.2
	Kernel-5_35-4_79_2_66:4.2.2.2
	Kernel-5_35-4_79_2_65:4.2.2.2
	Kernel-5_35-4_79_2_64:4.2.2.2
	Kernel-5_35-4_79_2_63:4.2.2.2
	Kernel-5_35-4_79_2_62:4.2.2.2
	Kernel-5_35-4_79_2_61:4.2.2.2
	Kernel-5_35-4_79_2_59:4.2.2.2
	Kernel-5_35-4_79_2_58:4.2.2.2
	Kernel-5_35-4_79_2_57:4.2.2.2
	Kernel-5_35-4_79_2_56:4.2.2.2
	Kernel-5_35-4_79_2_55:4.2.2.2
	Kernel-5_35-4_79_2_54:4.2.2.2
	Kernel-5_35-4_79_2_53:4.2.2.2
	Kernel-5_35-4_79_2_52:4.2.2.2
	Kernel-5_35-4_79_2_51:4.2.2.2
	Kernel-5_35-4_79_2_50:4.2.2.1
	Kernel-5_35-4_79_2_49:4.2.2.1
	Kernel-5_35-4_79_2_48:4.2.2.1
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.6
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2
	Kernel-5_35-4_79_2_46:4.2
	Kernel-5_35-4_79_2_45:4.2
	Kernel-5_35-4_79_2_44:4.2
	Kernel-5_35-4_79_2_25_2_2:4.2
	Kernel-5_35-4_79_2_43:4.2
	Kernel-5_35-4_79_2_42:4.2
	Kernel-5_35-4_79_2_41:4.2
	Kernel-5_35-4_79_2_40:4.2
	Kernel-5_35-4_79_2_39:4.2
	Kernel-5_35-4_79_2_38:4.2
	Kernel-5_35-4_79_2_37:4.2
	Kernel-5_35-4_79_2_36:4.2
	Kernel-5_35-4_79_2_35:4.2
	Kernel-5_35-4_79_2_34:4.2
	Kernel-5_35-4_79_2_33:4.2
	Kernel-5_35-4_79_2_32:4.2
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2
	Kernel-5_35-4_79_2_30:4.2
	Kernel-5_35-4_79_2_29:4.2
	Kernel-5_35-4_79_2_28:4.2
	Kernel-5_35-4_79_2_27:4.2
	Kernel-5_35-4_79_2_26:4.2
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2
	Kernel-5_35-4_79_2_24:4.2
	Kernel-5_35-4_79_2_23:4.2
	Kernel-5_35-4_79_2_22:4.2
	Kernel-5_35-4_79_2_21:4.2
	Kernel-5_35-4_79_2_20:4.2
	Kernel-5_35-4_79_2_19:4.2
	Kernel-5_35-4_79_2_18:4.2
	Kernel-5_35-4_79_2_17:4.2
	Kernel-5_35-4_79_2_16:4.2
	Kernel-5_35-4_79_2_15:4.2
	Kernel-5_35-4_79_2_14:4.2
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2
	Kernel-5_35-4_79_2_12:4.2
	Kernel-5_35-4_79_2_11:4.2
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2
	Kernel-5_35-4_79_2_9:4.2
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2
	Kernel-5_35-4_79_2_7:4.2
	Kernel-5_35-4_79_2_6:4.2
	Kernel-5_35-4_79_2_5:4.2
	Kernel-5_35-4_79_2_4:4.2
	Kernel-5_35-4_79_2_3:4.2
	Kernel-5_35-4_79_2_2:4.2
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.04.04.14.27.40;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.36;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2002.11.30.00.31.13;	author bavison;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2011.11.27.12.54.10;	author rsprowson;	state Exp;
branches;
next	4.2.2.4;
commitid	qUSTS070aqq3kYIv;

4.2.2.4
date	2013.12.15.21.34.12;	author jlee;	state Exp;
branches;
next	4.2.2.5;
commitid	KwuK29hKRyXO7hhx;

4.2.2.5
date	2013.12.17.19.08.56;	author jlee;	state Exp;
branches;
next	;
commitid	mr92WavK9Mu4gwhx;

4.1.1.1
date	96.11.05.09.41.36;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.04;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.36;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.02;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.37;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduGrafD

;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - Block Copy and Move
;
; Author R C Manby
; Date   2.10.86
;

; *****************************************************************************
;
;       BlockCopyMove - Copy/Move a rectangular area
;
; in:   OldCs marks start of area to copy/move
;       ICursor marks end of area to copy/move
;       NewPt is lower left of destination area
;       R2 = plot number &B8..&BF
;
; out:  R0..R11 corrupt
;

BlockCopyMove ROUT
        TST     R2, #3                          ; Do nowt on 'MoveOnly' codes
        MOVEQ   PC, R14

        SaveRetAdr

        ADD     R0, WsPtr, #BgEcfStore          ; Select 'store' in background
        STR     R0, [WsPtr, #GColAdr]           ; to be used by HLine when
                                                ; clearing source & dest lines

; Build up source & destination data as follows
;
; R0   R1   R2   R3   R4    R5    R6    R7    R8
; SrcL,SrcB,SrcR,SrcT,DestL,DestB,DestR,DestT,CopyFlag

        AND     R8, R2, #2                      ; 0/2 means Move/Copy

        ADD     R11, WsPtr, #OldCsX
        LDMIA   R11, {R0,R1, R2,R3, R4,R5}      ; OldCs, ICursor, NewPt

        SortT   R0, R2, R6                      ; Order SrcL,SrcB,SrcR,SrcT
        SortT   R1, R3, R6                      ;       R0 , R1 , R2 , R3

        SUB     R6, R2, R0
        ADD     R6, R6, R4                      ; DestR := SrcR-SrcL+DestL

        SUB     R7, R3, R1
        ADD     R7, R7, R5                      ; DestT := SrcT-SrcB+DestB

        ADD     R11, WsPtr, #CMSrc
        STMIA   R11, {R0-R7,R8}                 ; Unclipped src & dest areas
                                                ; and CopyFlag
        LDR     R11, [WsPtr, #CursorFlags]
        TST     R11, #ClipBoxEnableBit
        BLNE    ClipBlockCopyMove

; now work out ACTUAL area to copy
; first, we window destination area

        LDR     R10, [WsPtr, #GWLCol]
        LDR     R11, [WsPtr, #GWRCol]

        SUBS    R8, R10, R4                     ; R8 = GWLCol - DestL
        ADDGT   R4, R4, R8                      ; if > 0 then DestL := GWLCol
        ADDGT   R0, R0, R8                      ; and adjust SrcL to match

        SUBS    R8, R6, R11                     ; R8 = DestR - GWRCol
        SUBGT   R6, R6, R8                      ; if > 0 then DestR := GWRCol
        SUBGT   R2, R2, R8                      ; and adjust SrcR to match

        CMP     R6, R4                          ; check DestR >= DestL
        BLT     EraseSource                     ; if not then just erase source
                                                ; if a block move

        STR     R4, [WsPtr, #CMDest2L]          ; save horizontal dest coords
        STR     R6, [WsPtr, #CMDest2R]          ; windowed at dest

        SUBS    R8, R10, R0                     ; R8 = GWLCol - SrcL
        ADDGT   R0, R0, R8                      ; if > 0 then SrcL := GWLCol
        ADDGT   R4, R4, R8                      ; and adjust DestL to match

        SUBS    R8, R2, R11                     ; R8 = SrcR - GWRCol
        SUBGT   R2, R2, R8                      ; if > 0 then SrcR := GWRCol
        SUBGT   R6, R6, R8                      ; and adjust DestR to match

        LDR     R10, [WsPtr, #GWBRow]
        LDR     R11, [WsPtr, #GWTRow]

        SUBS    R8, R10, R5                     ; R8 = GWBRow - DestB
        ADDGT   R5, R5, R8                      ; if > 0 then DestB := GWBRow
        ADDGT   R1, R1, R8                      ; and adjust SrcB to match

        SUBS    R8, R7, R11                     ; R8 = DestT - GWTRow
        SUBGT   R7, R7, R8                      ; if > 0 then DestT := GWTRow
        SUBGT   R3, R3, R8                      ; and adjust SrcT to match

        CMP     R7, R5                          ; check DestT >= DestB
        BLT     EraseSource                     ; if not then just erase source
                                                ; if a block move

        STR     R5, [WsPtr, #CMDest2B]          ; save vertical dest coords
        STR     R7, [WsPtr, #CMDest2T]          ; windowed at dest

        SUBS    R8, R10, R1                     ; R8 = GWBRow - SrcB
        ADDGT   R1, R1, R8                      ; if > 0 then SrcB := GWBRow
        ADDGT   R5, R5, R8                      ; and adjust DestB to match

        SUBS    R8, R3, R11                     ; R8 = SrcT - GWTRow
        SUBGT   R3, R3, R8                      ; if > 0 then SrcT := GWTRow
        SUBGT   R7, R7, R8                      ; and adjust DestT to match

; now R0-R3 is source windowed both ways
;     R4-R7 is dest   windowed both ways

        ADD     R8, WsPtr, #CMDest3L
        STMIA   R8, {R4-R7}                     ; save destination windowed
                                                ; both ways

        LDR     R9, [WsPtr, #VduSprite]

        CMP     R2, R0                          ; check SrcR >= SrcL
        SUBGES  R8, R3, R1                      ; and SrcT >= SrcB (R8=lines-1)
        BLT     EraseDest                       ; if not, then go to wiping out
                                                ; destination stage

        STR     R8, [WsPtr, #CMVertCount]       ; no. of vertical lines -1

        BL      CheckAcceleration               ; okay to accelerate?
        BNE     %FT05

; not redirected to sprite - try calling GraphicsV for some acceleration

        Push    "R2"
        Push    "R8"
        SUB     R14, R2, R0
        Push    "R0,R1,R4,R5,R14"               ; srcL,srcB,dstL,dstB,W-1,H-1
        MOV     R0, #GVRender_Sync
        MOV     R1, #GVRender_CopyRectangle
        MOV     R2, R13
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_Render
        BL      CallGraphicsV                   ; (R0,R1,R2,R4->R4)
        TEQ     R4, #GraphicsV_Complete         ; did it do it?
        Pull    "R0,R1,R4"
        ADD     R13, R13, #3*4
        Pull    "R2"
        BEQ     EraseDest                       ; then go straight to erase

05      LDR     R9, [WsPtr, #Log2BPC]
        LDR     R10, [WsPtr, #XShftFactor]
        LDR     R11, [WsPtr, #NPix]

        MOV     R8, R6, LSR R10                 ; DestR word offset
        SUB     R8, R8, R4, LSR R10             ; -DestL word offset
        STR     R8, [WsPtr, #CMDestCount]       ; No. of dest words -1

        AND     R8, R6, R11                     ; R8 = DestR pixel offset
        ADD     R14, WsPtr,#RAMMaskTb
        LDR     R8, [R14, R8, LSL #2]           ; R8 = mask for right pixel
        SUB     R14, R8, #1             ; In rh mask, set all bits lower than
        ORR     R14, R14, R8            ; pixel, RHM := RHM OR (RHM-1)
        STR     R14, [WsPtr, #CMRMask]

        AND     R8, R4, R11                     ; R8 = DestL pixel offset
        ADD     R14, WsPtr, #RAMMaskTb
        LDR     R8, [R14, R8, LSL #2]           ; R8 = mask for left pixel
        RSB     R14, R8, #0             ; In lh mask, set all bits higher than
        ORR     R14, R14, R8            ; pixel, LHM := LHM OR (0-LHM)
        STR     R14, [WsPtr, #CMLMask]

        CMP     R0, R4                          ; test whether SrcL >= DestL
        BLT     SrcHLTDest

; source is to the right of dest, so start at left hand side

        AND     R8, R4, R11                     ; R8 = DestL pixel offset
        AND     R14, R0, R11                    ; R14 = SrcL pixel offset
        SUB     R11, R14, R8                    ; R11 = Src-Dest pixel offset
        MOV     R11, R11, LSL R9                ; R11 = Src-Dest bit offset

        CMP     R11, #0                         ; if rightshift < 0
        ADDLT   R11, R11, #32                   ; if < 0, correct result
        MOVGE   R10, #0
        MOVLT   R10, #-4                        ; and subtract 4 off src addr

        STR     R11, [WsPtr, #CMRShift]
        RSB     R11, R11, #32
        STR     R11, [WsPtr, #CMLShift]

        LDR     R6, [WsPtr, #LineLength]        ; (no longer need DestR)

        CMP     R1, R5                          ; if SrcB >= DestB
        RSBGE   R6, R6, #0                      ; then go upwards
        STR     R6, [WsPtr, #CMVertDir]

        MOVLT   R1, R3                          ; else go down
        MOVLT   R5, R7                          ; so use top coords

        BL      ScreenAddr                      ; R2 = address of src corner
        ADD     R2, R2, R10
        STR     R2, [WsPtr, #CMSourceAddr]

        MOV     R0, R4
        MOV     R1, R5
        BL      ScreenAddr                      ; R2 = address of dest corner
        STR     R2, [WsPtr, #CMDestAddr]

        ADD     R11, WsPtr, #CMStuff
        LDMIA   R11, {R0-R6}            ; src,dest,cnt,rtshf,lfshf,rtmsk,ltmsk
10
        TEQ     R2, #0                  ; only one word on a line ?
        ANDEQ   R5, R5, R6              ; then rightmask:=rightmask AND lftmask
        LDREQ   R14, [R0], #4           ; and load first word up
        BEQ     %FT45                   ; and do endword

; do first word

        LDMIA   R0!, {R11,R14}          ; load 2 words
        ShiftR  R11, R14, R3, R4        ; shift them
        AND     R11, R11, R6            ; AND with leftmask
        LDR     R10, [R1]               ; load word from dest
        BIC     R10, R10, R6            ; clear out bits in leftmask
        ORR     R10, R10, R11           ; OR in new bits
        STR     R10, [R1], #4
        SUBS    R2, R2, #1              ; decrement count
        BEQ     %FT40                   ; if zero, do finish word

        SUBS    R2, R2, #7              ; can we do 7 words ?
        BCC     %FT30                   ; no, then do 1 word at a time

; do 7 words at a time

        TEQ     R3, #0                  ; if rightshf = 0
        BEQ     %FT60                   ; then do non-shifting version
20
 [ {TRUE}                               ; TMD optimisation 12-May-93
        MOV     R5, R14, LSR R3
        LDMIA   R0!, {R6-R11,R14}
        ORR     R5, R5, R6, LSL R4
 |
        MOV     R5, R14
        LDMIA   R0!, {R6-R11,R14}       ; load next 7 words
        ShiftR  R5, R6, R3, R4
 ]
        ShiftR  R6, R7, R3, R4
        ShiftR  R7, R8, R3, R4
        ShiftR  R8, R9, R3, R4
        ShiftR  R9, R10, R3, R4
        ShiftR  R10, R11, R3, R4
        ShiftR  R11, R14, R3, R4
        STMIA   R1!, {R5-R11}
        SUBS    R2, R2, #7
        BCS     %BT20

30
        ADDS    R2, R2, #7
        BEQ     %FT40                   ; if count expired, do last word

; do 1 word at a time

35
        MOV     R5, R14
        LDR     R14, [R0], #4
        ShiftR  R5, R14, R3, R4
        STR     R5, [R1], #4
        SUBS    R2, R2, #1
        BNE     %BT35

; do last word

40
        LDR     R5, [WsPtr, #CMRMask]   ; load right mask
45

; now test if any bits would be used (so we don't go off end of memory)

        MOV     R11, #&FFFFFFFF
        TST     R5, R11, LSL R4         ; NE => safe to read from here
        LDRNE   R11, [R0], #4           ; R14 = left word; R11 = right word
        ShiftR  R14, R11, R3, R4        ; form single word
        AND     R14, R14, R5            ; mask source word
        LDR     R10, [R1]               ; load dest word
        BIC     R10, R10, R5            ; mask dest word
        ORR     R10, R10, R14           ; OR two words
        STR     R10, [R1], #4           ; store back

; now go on to next row

        LDR     R7, [WsPtr, #CMVertCount]
        SUBS    R7, R7, #1
        BCC     EraseDest               ; finished, so go to erase dest stage
        STR     R7, [WsPtr, #CMVertCount]
        ADD     R11, WsPtr, #CMStuff
        LDMIA   R11, {R0-R6}            ; load up info again
        LDR     R7, [WsPtr, #CMVertDir]
        ADD     R0, R0, R7              ; move source pointer
        ADD     R1, R1, R7              ; and dest pointer
        STMIA   R11, {R0,R1}            ; store these back
        B       %BT10                   ; and loop

; non-shifting version, for speed
; do 7 words at a time

60
        MOV     R5, R14
        LDMIA   R0!, {R6-R11,R14}       ; load next 7 words
        STMIA   R1!, {R5-R11}
        SUBS    R2, R2, #7
        BCS     %BT60
        ADDS    R2, R2, #7
        BNE     %BT35                   ; count not expired, do last few words
        B       %BT40                   ; count expired, do last word

; *****************************************************************************

; source is to the left of dest, so start at right hand side

SrcHLTDest ROUT
        MOV     R0, R2                          ; rt coords are relevant ones
        MOV     R4, R6

        AND     R8, R4, R11                     ; R8 = DestR pixel offset
        AND     R14, R0, R11                    ; R14 = SrcR pixel offset
        SUB     R11, R14, R8                    ; R11 = Src-Dest pixel offset
        MOV     R11, R11, LSL R9                ; R11 = Src-Dest bit offset

        RSB     R11, R11, #32                   ; R11 = leftshift
        CMP     R11, #32                        ; if >= 32
        SUBCS   R11, R11, #32                   ; then put in range
        MOVCC   R10, #4                         ; else add 4
        MOVCS   R10, #0                         ; to src addr

        STR     R11, [WsPtr, #CMLShift]
        RSB     R11, R11, #32
        STR     R11, [WsPtr, #CMRShift]

        LDR     R6, [WsPtr, #LineLength]        ; (no longer need R6)

        CMP     R1, R5                          ; if SrcB >= DestB
        RSBGE   R6, R6, #0                      ; then go upwards
        STR     R6, [WsPtr, #CMVertDir]

        MOVLT   R1, R3                          ; else go down
        MOVLT   R5, R7                          ; so use top coords

        BL      ScreenAddr                      ; R2 = address of src corner
        ADD     R2, R2, R10
        STR     R2, [WsPtr, #CMSourceAddr]

        MOV     R0, R4
        MOV     R1, R5
        BL      ScreenAddr                      ; R2 = address of dest corner
        STR     R2, [WsPtr, #CMDestAddr]

        ADD     R11, WsPtr, #CMStuff
        LDMIA   R11, {R0-R6}            ; src,dest,cnt,rtshf,lfshf,rtmsk,ltmsk
10
        TEQ     R2, #0                  ; only one word on a line ?
        ANDEQ   R6, R6, R5              ; then leftmask:=leftmask AND rightmask
        LDREQ   R5, [R0], #-4           ; and load first word up
        BEQ     %FT45                   ; and do endword

; do first word

        LDMDA   R0!, {R11,R14}          ; load 2 words
        ShiftL  R11, R14, R3, R4        ; shift them
        AND     R14, R14, R5            ; AND with rightmask
        LDR     R10, [R1]               ; load word from dest
        BIC     R10, R10, R5            ; clear out bits in rightmask
        ORR     R10, R10, R14           ; OR in new bits
        STR     R10, [R1], #-4
        MOV     R5, R11
        SUBS    R2, R2, #1              ; decrement count
        BEQ     %FT40                   ; if zero, do finish word

        SUBS    R2, R2, #7              ; can we do 7 words ?
        BCC     %FT30                   ; no, then do 1 word at a time

; do 7 words at a time

        TEQ     R4, #0                  ; if leftshf=0
        BEQ     %FT60                   ; then do non-shifting version
20
 [ {TRUE}                               ; TMD optimisation 12-May-93
        MOV     R14, R5, LSL R4
        LDMDA   R0!, {R5-R11}
        ORR     R14, R14, R11, LSR R3
 |
        MOV     R14, R5
        LDMDA   R0!, {R5-R11}           ; load next 7 words
        ShiftL  R11, R14, R3, R4
 ]
        ShiftL  R10, R11, R3, R4
        ShiftL  R9, R10, R3, R4
        ShiftL  R8, R9, R3, R4
        ShiftL  R7, R8, R3, R4
        ShiftL  R6, R7, R3, R4
        ShiftL  R5, R6, R3, R4
        STMDA   R1!, {R6-R11,R14}
        SUBS    R2, R2, #7
        BCS     %BT20

30
        ADDS    R2, R2, #7
        BEQ     %FT40                   ; if count expired, do last word

; do 1 word at a time

35
        MOV     R14, R5
        LDR     R5, [R0], #-4
        ShiftL  R5, R14, R3, R4
        STR     R14, [R1], #-4
        SUBS    R2, R2, #1
        BNE     %BT35

; do last word

40
        LDR     R6, [WsPtr, #CMLMask]   ; load left mask
45

; now test if any bits would be used (so we don't go off start of memory)

        MOV     R11, #&FFFFFFFF
        TST     R6, R11, LSR R3         ; NE => safe to read from here
        LDRNE   R11, [R0], #-4          ; R11 = left word; R5 = right word
        ShiftL  R11, R5, R3, R4         ; form single word
        AND     R5, R5, R6              ; mask source word
        LDR     R10, [R1]               ; load dest word
        BIC     R10, R10, R6            ; mask dest word
        ORR     R10, R10, R5            ; OR two words
        STR     R10, [R1], #-4          ; store back

; now go on to next row

        LDR     R7, [WsPtr, #CMVertCount]
        SUBS    R7, R7, #1
        BCC     EraseDest               ; finished, so go to erase dest stage
        STR     R7, [WsPtr, #CMVertCount]
        ADD     R11, WsPtr, #CMStuff
        LDMIA   R11, {R0-R6}            ; load up info again
        LDR     R7, [WsPtr, #CMVertDir]
        ADD     R0, R0, R7              ; move source pointer
        ADD     R1, R1, R7              ; and dest pointer
        STMIA   R11, {R0,R1}            ; store these back
        B       %BT10                   ; and loop

; non-shifting version, for speed
; do 7 words at a time

60
        MOV     R14, R5
        LDMDA   R0!, {R5-R11}           ; load next 8 words
      [ SupportARMX
        MOV     R11, R11                ; Dummy instruction for XScale weirdness
      ]
        STMDA   R1!, {R6-R11,R14}
        SUBS    R2, R2, #7
        BCS     %BT60
        ADDS    R2, R2, #7
        BNE     %BT35                   ; count not expired, do last few words
        B       %BT40                   ; count expired, do last word

; *****************************************************************************

; Erase the area Dest2\Dest3

EraseDest ROUT

; first do the flat rectangle

        ADD     R8, WsPtr, #CMDest2L
        LDMIA   R8, {R0-R7}             ; R0..R3 = Dest2; R4..R7 = Dest3
        BL      EraseDifference

; and drop thru to ...

EraseSource
        LDR     R8, [WsPtr, #CMCopyFlag] ; 0 => move, 2 => copy
        TEQ     R8, #0                  ; is it a move
        Return  NE                      ; no, then exit

        ADD     R8, WsPtr, #CMSrc       ; R0..R3 = unclipped src
        LDMIA   R8, {R0-R7}             ; R4..R7 = unclipped dest

; window both source and destination in source domain

        LDR     R10, [WsPtr, #GWLCol]
        LDR     R11, [WsPtr, #GWRCol]

        SUBS    R8, R10, R0             ; R8 = GWLCol - SrcL
        ADDGT   R0, R0, R8              ; if > 0 then SrcL := GWLCol
        ADDGT   R4, R4, R8              ; and adjust DestL to match

        SUBS    R8, R2, R11             ; R8 = SrcR - GWRCol
        SUBGT   R2, R2, R8              ; if > 0 then SrcR := GWRCol
        SUBGT   R6, R6, R8              ; and adjust DestR to match

        CMP     R2, R0                  ; check SrcR >= SrcL
        Return  LT                      ; if not then nothing to erase

        LDR     R10, [WsPtr, #GWBRow]
        LDR     R11, [WsPtr, #GWTRow]

        SUBS    R8, R10, R1             ; R8 = GWBRow - SrcB
        ADDGT   R1, R1, R8              ; if > 0 then SrcB := GWBRow
        ADDGT   R5, R5, R8              ; and adjust DestB to match

        SUBS    R8, R3, R11             ; R8 = SrcT - GWTRow
        SUBGT   R3, R3, R8              ; if > 0 then SrcT := GWTRow
        SUBGT   R7, R7, R8              ; and adjust DestT to match

        CMP     R3, R1                  ; check SrcT >= SrcB
        Return  LT                      ; if not then nothing to erase

; now window the dest coords to the source

        CMP     R7, R3                  ; if DestT >= SrcT
        MOVGE   R7, R3                  ; then DestT := SrcT
        MOVLT   R5, R1                  ; else DestB := SrcB
        CMP     R6, R2                  ; if DestR >= SrcR
        MOVGE   R6, R2                  ; then DestR := SrcR
        MOVLT   R4, R0                  ; else DestL := SrcL

        Pull    R14

; and drop thru to ...

; *****************************************************************************
;
;       EraseDifference - Erase the difference between two rectangles with at
;                         least one vertical and one horizontal shared boundary
;
; in:   R0-R3 = larger one
;       R4-R7 = smaller one
;

EraseDifference ROUT

; first do the flat rectangle

        CMP     R6, R4                  ; check for Dest3 being null
        CMPGE   R7, R5
        BLT     RectFillA               ; if is, just clear Dest2

        Push    "R0-R7,R14"

        TEQ     R3, R7                  ; if Dest2T = Dest3T
        SUBEQ   R3, R5, #1              ; then top = Dest3B -1
        ADDNE   R1, R7, #1              ; else bottom = Dest3T +1
        CMP     R3, R1                  ; if top >= bottom
        BLGE    RectFillA

; now do the tall rectangle

        Pull    "R0-R7"

        TEQ     R3, R7                  ; if Dest2T = Dest3T
        MOVEQ   R1, R5                  ; then bottom = Dest3B
        MOVNE   R3, R7                  ; else top = Dest3T

        TEQ     R0, R4                  ; if Dest2L = Dest3L
        ADDEQ   R0, R6, #1              ; then left = Dest3R +1
        SUBNE   R2, R4, #1              ; else right = Dest3L -1

        CMP     R3, R1                  ; if top >= bottom
        CMPGE   R2, R0                  ; and right >= left
        BLGE    RectFillA               ; then fill it

        Pull    PC


        END
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d137 2
d146 23
a168 1
        LDR     R9, [WsPtr, #Log2BPC]
d474 3
@


4.2.2.1
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a449 2
        MOV     R11, R11
        ! 0, "Block copy has dummy instruction for XScale weirdness"
@


4.2.2.2
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@a136 2
        LDR     R9, [WsPtr, #VduSprite]

d144 1
a144 23
 [ UseGraphicsV
        BL      CheckAcceleration               ; okay to accelerate?
        BNE     %FT05

; not redirected to sprite - try calling GraphicsV for some acceleration

        Push    "R2"
        Push    "R8"
        SUB     R14, R2, R0
        Push    "R0,R1,R4,R5,R14"               ; srcL,srcB,dstL,dstB,W-1,H-1
        MOV     R0, #GVRender_Sync
        MOV     R1, #GVRender_CopyRectangle
        MOV     R2, R13
        MOV     R4, #GraphicsV_Render
        BL      CallGraphicsV                   ; (R0,R1,R2,R4->R4)
        TEQ     R4, #GraphicsV_Complete         ; did it do it?
        Pull    "R0,R1,R4"
        ADD     R13, R13, #3*4
        Pull    "R2"
        BEQ     EraseDest                       ; then go straight to erase
 ]

05      LDR     R9, [WsPtr, #Log2BPC]
@


4.2.2.3
log
@Added 'UnConv' error (see also HdrSrc).
Implement OS_ConvertVariform, internally the other conversions now just call it.
Add tester for Variform to 'Dev'.
Made block copy weirdness for XScale dependent on XScale arch flag.

Version 5.35, 4.79.2.126. Tagged as 'Kernel-5_35-4_79_2_126'
@
text
@d474 2
a475 3
      [ SupportARMX
        MOV     R11, R11                ; Dummy instruction for XScale weirdness
      ]
@


4.2.2.4
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d159 1
a159 3
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_Render
@


4.2.2.5
log
@Strip out some old build switches
Detail:
  hdr/Options, s/ArthurSWIs, s/ChangeDyn, s/PMF/KbdDrA1, s/PMF/key, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdugrafhal, s/vdu/vdugrafv, s/vdu/vdumodes, s/vdu/vduwrch:
  - Strip out DoingVdu build switch (did nothing)
  - Strip out Japanese16BitSound switch (did nothing)
  - Strip out MakeModeSelectorsForModeNUmbers switch (altered the mode list structures, but there wasn't any code to do anything with the new data)
  - Strip out remaining uses of UseGraphicsV switch (now hardwired to {TRUE})
  - Strip out ShadowROM switch (altered FixedAreasTable to show the shadow mapping, but code to create the mapping is missing)
  - Strip out PollMouse switch (old Archimedes-era debug/development option)
Admin:
  Tested on BB-xM
  Builds to same binary as previous version


Version 5.35, 4.79.2.204. Tagged as 'Kernel-5_35-4_79_2_204'
@
text
@d146 1
d168 1
@


4.1
log
@Initial revision
@
text
@d41 1
a41 1
        MOVEQS  PC, R14
d68 1
a68 1
        ADD     R11, WsPtr, #CMSrc                    
d150 1
a150 1
        STR     R8, [WsPtr, #CMDestCount]       ; No. of dest words -1 
d155 1
a155 1
        SUB     R14, R8, #1             ; In rh mask, set all bits lower than 
d546 1
a546 1
        
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d231 1
d235 5
d379 1
d383 5
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

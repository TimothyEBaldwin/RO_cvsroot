head	4.5;
access;
symbols
	Kernel-6_14:4.5
	Kernel-6_01-3:4.4
	Kernel-6_13:4.5
	Kernel-6_12:4.5
	Kernel-6_11:4.5
	Kernel-6_10:4.4
	Kernel-6_09:4.4
	Kernel-6_08-4_129_2_10:4.4
	Kernel-6_08-4_129_2_9:4.4
	Kernel-6_08:4.4
	Kernel-6_07:4.4
	Kernel-6_06:4.4
	Kernel-6_05-4_129_2_8:4.4
	Kernel-6_05:4.4
	Kernel-6_04:4.4
	Kernel-6_03:4.4
	Kernel-6_01-2:4.4
	Kernel-6_01-4_146_2_1:4.4
	Kernel-6_02:4.4
	Kernel-6_01-1:4.4
	Kernel-6_01:4.4
	Kernel-6_00:4.4
	Kernel-5_99:4.4
	Kernel-5_98:4.4
	Kernel-5_97-4_129_2_7:4.4
	Kernel-5_97:4.4
	Kernel-5_96:4.4
	Kernel-5_95:4.4
	Kernel-5_94:4.4
	Kernel-5_93:4.4
	Kernel-5_92:4.4
	Kernel-5_91:4.4
	Kernel-5_90:4.4
	Kernel-5_89-4_129_2_6:4.4
	Kernel-5_89:4.4
	Kernel-5_88-4_129_2_5:4.4
	Kernel-5_88-4_129_2_4:4.4
	Kernel-5_88:4.4
	Kernel-5_87:4.4
	Kernel-5_86-4_129_2_3:4.4
	Kernel-5_86-4_129_2_2:4.4
	Kernel-5_86-4_129_2_1:4.4
	Kernel-5_86:4.4
	SMP:4.4.0.2
	SMP_bp:4.4
	Kernel-5_85:4.4
	Kernel-5_54-1:4.4
	Kernel-5_84:4.4
	Kernel-5_83:4.4
	Kernel-5_82:4.4
	Kernel-5_81:4.4
	Kernel-5_80:4.4
	Kernel-5_79:4.4
	Kernel-5_78:4.4
	Kernel-5_77:4.4
	Kernel-5_76:4.4
	Kernel-5_75:4.4
	Kernel-5_74:4.4
	Kernel-5_73:4.4
	Kernel-5_72:4.4
	Kernel-5_71:4.4
	Kernel-5_70:4.4
	Kernel-5_69:4.4
	Kernel-5_68:4.4
	Kernel-5_67:4.4
	Kernel-5_66:4.4
	Kernel-5_65:4.4
	Kernel-5_64:4.4
	Kernel-5_63:4.4
	Kernel-5_62:4.4
	Kernel-5_61:4.4
	Kernel-5_60:4.4
	Kernel-5_59:4.4
	Kernel-5_58:4.4
	Kernel-5_57:4.4
	Kernel-5_56:4.4
	Kernel-5_55:4.4
	Kernel-5_54:4.4
	Kernel-5_53:4.4
	Kernel-5_52:4.4
	Kernel-5_51:4.4
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.2.2.5
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.5
	Kernel-5_35-4_79_2_326:4.2.2.5
	Kernel-5_35-4_79_2_325:4.2.2.5
	Kernel-5_35-4_79_2_324:4.2.2.5
	Kernel-5_35-4_79_2_323:4.2.2.5
	Kernel-5_35-4_79_2_322:4.2.2.5
	Kernel-5_35-4_79_2_321:4.2.2.5
	Kernel-5_35-4_79_2_320:4.2.2.5
	Kernel-5_35-4_79_2_319:4.2.2.5
	Kernel-5_35-4_79_2_318:4.2.2.5
	Kernel-5_35-4_79_2_317:4.2.2.5
	Kernel-5_35-4_79_2_316:4.2.2.5
	Kernel-5_35-4_79_2_315:4.2.2.5
	Kernel-5_35-4_79_2_314:4.2.2.5
	Kernel-5_35-4_79_2_313:4.2.2.5
	Kernel-5_35-4_79_2_312:4.2.2.5
	Kernel-5_35-4_79_2_311:4.2.2.5
	Kernel-5_35-4_79_2_310:4.2.2.5
	Kernel-5_35-4_79_2_309:4.2.2.5
	Kernel-5_35-4_79_2_308:4.2.2.5
	Kernel-5_35-4_79_2_307:4.2.2.5
	Kernel-5_35-4_79_2_306:4.2.2.5
	Kernel-5_35-4_79_2_305:4.2.2.5
	Kernel-5_35-4_79_2_304:4.2.2.5
	Kernel-5_35-4_79_2_303:4.2.2.5
	Kernel-5_35-4_79_2_302:4.2.2.5
	Kernel-5_35-4_79_2_301:4.2.2.5
	Kernel-5_35-4_79_2_300:4.2.2.5
	Kernel-5_35-4_79_2_299:4.2.2.5
	Kernel-5_35-4_79_2_298:4.2.2.5
	Kernel-5_35-4_79_2_297:4.2.2.5
	Kernel-5_35-4_79_2_296:4.2.2.5
	Kernel-5_35-4_79_2_295:4.2.2.5
	Kernel-5_35-4_79_2_294:4.2.2.5
	Kernel-5_35-4_79_2_293:4.2.2.5
	Kernel-5_35-4_79_2_292:4.2.2.5
	Kernel-5_35-4_79_2_291:4.2.2.5
	Kernel-5_35-4_79_2_290:4.2.2.5
	Kernel-5_35-4_79_2_289:4.2.2.5
	Kernel-5_35-4_79_2_288:4.2.2.5
	Kernel-5_35-4_79_2_287:4.2.2.5
	Kernel-5_35-4_79_2_286:4.2.2.5
	Kernel-5_35-4_79_2_285:4.2.2.5
	Kernel-5_35-4_79_2_284:4.2.2.5
	Kernel-5_35-4_79_2_283:4.2.2.5
	Kernel-5_35-4_79_2_282:4.2.2.5
	Kernel-5_35-4_79_2_281:4.2.2.5
	Kernel-5_35-4_79_2_280:4.2.2.5
	Kernel-5_35-4_79_2_279:4.2.2.5
	Kernel-5_35-4_79_2_278:4.2.2.5
	Kernel-5_35-4_79_2_277:4.2.2.5
	Kernel-5_35-4_79_2_276:4.2.2.5
	Kernel-5_35-4_79_2_275:4.2.2.5
	Kernel-5_35-4_79_2_274:4.2.2.5
	Kernel-5_35-4_79_2_273:4.2.2.5
	Kernel-5_35-4_79_2_272:4.2.2.5
	Kernel-5_35-4_79_2_271:4.2.2.5
	Kernel-5_35-4_79_2_270:4.2.2.5
	Kernel-5_35-4_79_2_269:4.2.2.5
	Kernel-5_35-4_79_2_268:4.2.2.5
	Kernel-5_35-4_79_2_267:4.2.2.5
	Kernel-5_35-4_79_2_266:4.2.2.5
	Kernel-5_35-4_79_2_265:4.2.2.5
	Kernel-5_35-4_79_2_264:4.2.2.5
	Kernel-5_35-4_79_2_263:4.2.2.5
	Kernel-5_35-4_79_2_262:4.2.2.5
	Kernel-5_35-4_79_2_261:4.2.2.5
	Kernel-5_35-4_79_2_260:4.2.2.5
	Kernel-5_35-4_79_2_259:4.2.2.5
	Kernel-5_35-4_79_2_258:4.2.2.5
	Kernel-5_35-4_79_2_257:4.2.2.5
	Kernel-5_35-4_79_2_256:4.2.2.5
	Kernel-5_35-4_79_2_255:4.2.2.5
	Kernel-5_35-4_79_2_254:4.2.2.5
	Kernel-5_35-4_79_2_253:4.2.2.5
	Kernel-5_35-4_79_2_252:4.2.2.5
	Kernel-5_35-4_79_2_251:4.2.2.5
	Kernel-5_35-4_79_2_250:4.2.2.5
	Kernel-5_35-4_79_2_249:4.2.2.5
	Kernel-5_35-4_79_2_248:4.2.2.5
	Kernel-5_35-4_79_2_247:4.2.2.5
	Kernel-5_35-4_79_2_246:4.2.2.5
	Kernel-5_35-4_79_2_245:4.2.2.5
	Kernel-5_35-4_79_2_244:4.2.2.5
	Kernel-5_35-4_79_2_243:4.2.2.5
	Kernel-5_35-4_79_2_242:4.2.2.5
	Kernel-5_35-4_79_2_241:4.2.2.5
	Kernel-5_35-4_79_2_240:4.2.2.5
	Kernel-5_35-4_79_2_239:4.2.2.5
	Kernel-5_35-4_79_2_238:4.2.2.5
	Kernel-5_35-4_79_2_237:4.2.2.5
	Kernel-5_35-4_79_2_236:4.2.2.5
	Kernel-5_35-4_79_2_235:4.2.2.5
	Kernel-5_35-4_79_2_234:4.2.2.5
	Kernel-5_35-4_79_2_233:4.2.2.5
	Kernel-5_35-4_79_2_232:4.2.2.5
	Kernel-5_35-4_79_2_231:4.2.2.5
	Kernel-5_35-4_79_2_230:4.2.2.5
	Kernel-5_35-4_79_2_229:4.2.2.5
	Kernel-5_35-4_79_2_228:4.2.2.5
	Kernel-5_35-4_79_2_227:4.2.2.5
	Kernel-5_35-4_79_2_226:4.2.2.5
	Kernel-5_35-4_79_2_225:4.2.2.5
	Kernel-5_35-4_79_2_224:4.2.2.5
	Kernel-5_35-4_79_2_223:4.2.2.5
	Kernel-5_35-4_79_2_222:4.2.2.5
	Kernel-5_35-4_79_2_221:4.2.2.5
	Kernel-5_35-4_79_2_220:4.2.2.5
	Kernel-5_35-4_79_2_219:4.2.2.5
	Kernel-5_35-4_79_2_218:4.2.2.5
	Kernel-5_35-4_79_2_217:4.2.2.5
	Kernel-5_35-4_79_2_216:4.2.2.5
	Kernel-5_35-4_79_2_215:4.2.2.5
	Kernel-5_35-4_79_2_214:4.2.2.5
	Kernel-5_35-4_79_2_213:4.2.2.5
	Kernel-5_35-4_79_2_212:4.2.2.5
	Kernel-5_35-4_79_2_211:4.2.2.5
	Kernel-5_35-4_79_2_210:4.2.2.5
	Kernel-5_35-4_79_2_209:4.2.2.5
	Kernel-5_35-4_79_2_208:4.2.2.5
	Kernel-5_35-4_79_2_207:4.2.2.5
	Kernel-5_35-4_79_2_206:4.2.2.5
	Kernel-5_35-4_79_2_205:4.2.2.5
	Kernel-5_35-4_79_2_204:4.2.2.5
	Kernel-5_35-4_79_2_203:4.2.2.5
	Kernel-5_35-4_79_2_202:4.2.2.5
	Kernel-5_35-4_79_2_201:4.2.2.5
	Kernel-5_35-4_79_2_200:4.2.2.5
	Kernel-5_35-4_79_2_199:4.2.2.5
	Kernel-5_35-4_79_2_198:4.2.2.5
	Kernel-5_35-4_79_2_197:4.2.2.5
	Kernel-5_35-4_79_2_196:4.2.2.5
	Kernel-5_35-4_79_2_195:4.2.2.5
	Kernel-5_35-4_79_2_194:4.2.2.5
	Kernel-5_35-4_79_2_193:4.2.2.5
	Kernel-5_35-4_79_2_192:4.2.2.5
	Kernel-5_35-4_79_2_191:4.2.2.5
	Kernel-5_35-4_79_2_190:4.2.2.5
	Kernel-5_35-4_79_2_189:4.2.2.5
	Kernel-5_35-4_79_2_188:4.2.2.5
	Kernel-5_35-4_79_2_187:4.2.2.5
	Kernel-5_35-4_79_2_186:4.2.2.5
	Kernel-5_35-4_79_2_185:4.2.2.5
	Kernel-5_35-4_79_2_184:4.2.2.5
	Kernel-5_35-4_79_2_183:4.2.2.5
	Kernel-5_35-4_79_2_182:4.2.2.5
	Kernel-5_35-4_79_2_181:4.2.2.5
	Kernel-5_35-4_79_2_180:4.2.2.5
	Kernel-5_35-4_79_2_179:4.2.2.5
	Kernel-5_35-4_79_2_178:4.2.2.5
	Kernel-5_35-4_79_2_177:4.2.2.5
	Kernel-5_35-4_79_2_176:4.2.2.5
	Kernel-5_35-4_79_2_175:4.2.2.5
	Kernel-5_35-4_79_2_174:4.2.2.5
	Kernel-5_35-4_79_2_173:4.2.2.5
	Kernel-5_35-4_79_2_172:4.2.2.5
	Kernel-5_35-4_79_2_171:4.2.2.5
	Kernel-5_35-4_79_2_170:4.2.2.5
	Kernel-5_35-4_79_2_169:4.2.2.5
	Kernel-5_35-4_79_2_168:4.2.2.5
	Kernel-5_35-4_79_2_167:4.2.2.5
	Kernel-5_35-4_79_2_166:4.2.2.5
	Kernel-5_35-4_79_2_165:4.2.2.5
	RPi_merge:4.2.2.5
	Kernel-5_35-4_79_2_147_2_23:4.2.2.5
	Kernel-5_35-4_79_2_147_2_22:4.2.2.5
	Kernel-5_35-4_79_2_147_2_21:4.2.2.5
	Kernel-5_35-4_79_2_147_2_20:4.2.2.5
	Kernel-5_35-4_79_2_147_2_19:4.2.2.5
	Kernel-5_35-4_79_2_147_2_18:4.2.2.5
	Kernel-5_35-4_79_2_164:4.2.2.5
	Kernel-5_35-4_79_2_163:4.2.2.5
	Kernel-5_35-4_79_2_147_2_17:4.2.2.5
	Kernel-5_35-4_79_2_147_2_16:4.2.2.5
	Kernel-5_35-4_79_2_147_2_15:4.2.2.5
	Kernel-5_35-4_79_2_162:4.2.2.5
	Kernel-5_35-4_79_2_161:4.2.2.5
	Kernel-5_35-4_79_2_147_2_14:4.2.2.5
	Kernel-5_35-4_79_2_147_2_13:4.2.2.5
	Kernel-5_35-4_79_2_160:4.2.2.5
	Kernel-5_35-4_79_2_159:4.2.2.5
	Kernel-5_35-4_79_2_158:4.2.2.5
	Kernel-5_35-4_79_2_157:4.2.2.5
	Kernel-5_35-4_79_2_156:4.2.2.5
	Kernel-5_35-4_79_2_147_2_12:4.2.2.5
	Kernel-5_35-4_79_2_147_2_11:4.2.2.5
	Kernel-5_35-4_79_2_155:4.2.2.5
	Kernel-5_35-4_79_2_147_2_10:4.2.2.5
	Kernel-5_35-4_79_2_154:4.2.2.5
	Kernel-5_35-4_79_2_153:4.2.2.5
	Kernel-5_35-4_79_2_147_2_9:4.2.2.5
	Kernel-5_35-4_79_2_152:4.2.2.5
	Kernel-5_35-4_79_2_151:4.2.2.5
	Kernel-5_35-4_79_2_147_2_8:4.2.2.5
	Kernel-5_35-4_79_2_147_2_7:4.2.2.5
	Kernel-5_35-4_79_2_150:4.2.2.5
	Kernel-5_35-4_79_2_147_2_6:4.2.2.5
	Kernel-5_35-4_79_2_147_2_5:4.2.2.5
	Kernel-5_35-4_79_2_149:4.2.2.5
	Kernel-5_35-4_79_2_147_2_4:4.2.2.5
	Kernel-5_35-4_79_2_147_2_3:4.2.2.5
	Kernel-5_35-4_79_2_148:4.2.2.5
	Kernel-5_35-4_79_2_147_2_2:4.2.2.5
	Kernel-5_35-4_79_2_147_2_1:4.2.2.5
	RPi:4.2.2.5.0.2
	RPi_bp:4.2.2.5
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2.2.3.2.2
	alees_Kernel_dev:4.2.2.3.2.2.0.2
	alees_Kernel_dev_bp:4.2.2.3.2.2
	Kernel-5_35-4_79_2_147:4.2.2.5
	Kernel-5_35-4_79_2_146:4.2.2.5
	Kernel-5_35-4_79_2_145:4.2.2.5
	Kernel-5_35-4_79_2_144:4.2.2.5
	Kernel-5_35-4_79_2_143:4.2.2.5
	Kernel-5_35-4_79_2_142:4.2.2.5
	Kernel-5_35-4_79_2_141:4.2.2.5
	Kernel-5_35-4_79_2_140:4.2.2.5
	Kernel-5_35-4_79_2_139:4.2.2.5
	Kernel-5_35-4_79_2_138:4.2.2.5
	Kernel-5_35-4_79_2_137:4.2.2.5
	Kernel-5_35-4_79_2_136:4.2.2.5
	Kernel-5_35-4_79_2_135:4.2.2.5
	Kernel-5_35-4_79_2_134:4.2.2.5
	Kernel-5_35-4_79_2_133:4.2.2.5
	Kernel-5_35-4_79_2_132:4.2.2.5
	Kernel-5_35-4_79_2_131:4.2.2.5
	Kernel-5_35-4_79_2_130:4.2.2.5
	Kernel-5_35-4_79_2_129:4.2.2.5
	Kernel-5_35-4_79_2_128:4.2.2.5
	Kernel-5_35-4_79_2_127:4.2.2.5
	Kernel-5_35-4_79_2_126:4.2.2.5
	Kernel-5_35-4_79_2_125:4.2.2.5
	Kernel-5_35-4_79_2_124:4.2.2.5
	Kernel-5_35-4_79_2_123:4.2.2.4
	Cortex_merge:4.2.2.3.2.3
	Kernel-5_35-4_79_2_122:4.2.2.3
	Kernel-5_35-4_79_2_98_2_54:4.2.2.3.2.3
	Kernel-5_35-4_79_2_98_2_53:4.2.2.3.2.3
	Kernel-5_35-4_79_2_98_2_52:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_51:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_50:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_49:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_48:4.2.2.3.2.2
	Kernel-5_35-4_79_2_121:4.2.2.3
	Kernel-5_35-4_79_2_98_2_47:4.2.2.3.2.2
	Kernel-5_35-4_79_2_120:4.2.2.3
	Kernel-5_35-4_79_2_98_2_46:4.2.2.3.2.2
	Kernel-5_35-4_79_2_119:4.2.2.3
	Kernel-5_35-4_79_2_98_2_45:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_44:4.2.2.3.2.2
	Kernel-5_35-4_79_2_118:4.2.2.3
	Kernel-5_35-4_79_2_98_2_43:4.2.2.3.2.2
	Kernel-5_35-4_79_2_117:4.2.2.3
	Kernel-5_35-4_79_2_116:4.2.2.3
	Kernel-5_35-4_79_2_98_2_42:4.2.2.3.2.2
	Kernel-5_35-4_79_2_115:4.2.2.3
	Kernel-5_35-4_79_2_98_2_41:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_40:4.2.2.3.2.2
	Kernel-5_35-4_79_2_114:4.2.2.3
	Kernel-5_35-4_79_2_98_2_39:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_38:4.2.2.3.2.2
	Kernel-5_35-4_79_2_113:4.2.2.3
	Kernel-5_35-4_79_2_112:4.2.2.3
	Kernel-5_35-4_79_2_98_2_37:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_36:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_35:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_34:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_33:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_32:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_31:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_30:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_29:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_28:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_27:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_26:4.2.2.3.2.2
	Kernel-5_35-4_79_2_111:4.2.2.3
	Kernel-5_35-4_79_2_98_2_25:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_24:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_23:4.2.2.3.2.2
	Kernel-5_35-4_79_2_110:4.2.2.3
	Kernel-5_35-4_79_2_98_2_22:4.2.2.3.2.2
	Kernel-5_35-4_79_2_109:4.2.2.3
	Kernel-5_35-4_79_2_98_2_21:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_20:4.2.2.3.2.2
	Kernel-5_35-4_79_2_108:4.2.2.3
	Kernel-5_35-4_79_2_107:4.2.2.3
	Kernel-5_35-4_79_2_98_2_19:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_18:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_17:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_16:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_15:4.2.2.3.2.2
	Kernel-5_35-4_79_2_106:4.2.2.3
	Kernel-5_35-4_79_2_105:4.2.2.3
	Kernel-5_35-4_79_2_104:4.2.2.3
	Kernel-5_35-4_79_2_98_2_14:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_13:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_12:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_11:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_10:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_9:4.2.2.3.2.2
	Kernel-5_35-4_79_2_103:4.2.2.3
	Kernel-5_35-4_79_2_102:4.2.2.3
	Kernel-5_35-4_79_2_98_2_8:4.2.2.3.2.2
	Kernel-5_35-4_79_2_98_2_7:4.2.2.3.2.1
	Kernel-5_35-4_79_2_98_2_6:4.2.2.3.2.1
	Kernel-5_35-4_79_2_98_2_5:4.2.2.3
	Kernel-5_35-4_79_2_98_2_4:4.2.2.3
	Kernel-5_35-4_79_2_101:4.2.2.3
	Kernel-5_35-4_79_2_100:4.2.2.3
	Kernel-5_35-4_79_2_99:4.2.2.3
	Kernel-5_35-4_79_2_98_2_3:4.2.2.3
	Kernel-5_35-4_79_2_98_2_2:4.2.2.3
	Kernel-5_35-4_79_2_98_2_1:4.2.2.3
	Cortex:4.2.2.3.0.2
	Cortex_bp:4.2.2.3
	Kernel-5_35-4_79_2_98:4.2.2.3
	Kernel-5_35-4_79_2_97:4.2.2.3
	Kernel-5_35-4_79_2_96:4.2.2.3
	Kernel-5_35-4_79_2_95:4.2.2.3
	Kernel-5_35-4_79_2_94:4.2.2.3
	Kernel-5_35-4_79_2_93:4.2.2.3
	Kernel-5_35-4_79_2_92:4.2.2.3
	Kernel-5_35-4_79_2_91:4.2.2.3
	Kernel-5_35-4_79_2_90:4.2.2.3
	Kernel-5_35-4_79_2_89:4.2.2.3
	Kernel-5_35-4_79_2_88:4.2.2.3
	Kernel-5_35-4_79_2_87:4.2.2.3
	Kernel-5_35-4_79_2_86:4.2.2.3
	Kernel-5_35-4_79_2_85:4.2.2.3
	Kernel-5_35-4_79_2_84:4.2.2.3
	Kernel-5_35-4_79_2_83:4.2.2.3
	Kernel-5_35-4_79_2_82:4.2.2.3
	Kernel-5_35-4_79_2_81:4.2.2.3
	Kernel-5_35-4_79_2_80:4.2.2.3
	Kernel-5_35-4_79_2_79:4.2.2.3
	Kernel-5_35-4_79_2_78:4.2.2.3
	Kernel-5_35-4_79_2_77:4.2.2.3
	RO_5_07:4.2.2.3
	Kernel-5_35-4_79_2_76:4.2.2.3
	Kernel-5_35-4_79_2_75:4.2.2.3
	Kernel-5_35-4_79_2_74:4.2.2.3
	Kernel-5_35-4_79_2_73:4.2.2.3
	Kernel-5_35-4_79_2_72:4.2.2.3
	Kernel-5_35-4_79_2_71:4.2.2.3
	Kernel-5_35-4_79_2_70:4.2.2.3
	Kernel-5_35-4_79_2_69:4.2.2.3
	Kernel-5_35-4_79_2_68:4.2.2.3
	Kernel-5_35-4_79_2_67:4.2.2.3
	Kernel-5_35-4_79_2_66:4.2.2.3
	Kernel-5_35-4_79_2_65:4.2.2.3
	Kernel-5_35-4_79_2_64:4.2.2.3
	Kernel-5_35-4_79_2_63:4.2.2.3
	Kernel-5_35-4_79_2_62:4.2.2.3
	Kernel-5_35-4_79_2_61:4.2.2.3
	Kernel-5_35-4_79_2_59:4.2.2.3
	Kernel-5_35-4_79_2_58:4.2.2.2
	Kernel-5_35-4_79_2_57:4.2.2.2
	Kernel-5_35-4_79_2_56:4.2.2.2
	Kernel-5_35-4_79_2_55:4.2.2.2
	Kernel-5_35-4_79_2_54:4.2.2.2
	Kernel-5_35-4_79_2_53:4.2.2.2
	Kernel-5_35-4_79_2_52:4.2.2.2
	Kernel-5_35-4_79_2_51:4.2.2.2
	Kernel-5_35-4_79_2_50:4.2.2.2
	Kernel-5_35-4_79_2_49:4.2.2.2
	Kernel-5_35-4_79_2_48:4.2.2.2
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.4
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2.2.1
	Kernel-5_35-4_79_2_46:4.2.2.1
	Kernel-5_35-4_79_2_45:4.2.2.1
	Kernel-5_35-4_79_2_44:4.2.2.1
	Kernel-5_35-4_79_2_25_2_2:4.2.2.1
	Kernel-5_35-4_79_2_43:4.2.2.1
	Kernel-5_35-4_79_2_42:4.2.2.1
	Kernel-5_35-4_79_2_41:4.2.2.1
	Kernel-5_35-4_79_2_40:4.2.2.1
	Kernel-5_35-4_79_2_39:4.2.2.1
	Kernel-5_35-4_79_2_38:4.2.2.1
	Kernel-5_35-4_79_2_37:4.2.2.1
	Kernel-5_35-4_79_2_36:4.2.2.1
	Kernel-5_35-4_79_2_35:4.2.2.1
	Kernel-5_35-4_79_2_34:4.2.2.1
	Kernel-5_35-4_79_2_33:4.2.2.1
	Kernel-5_35-4_79_2_32:4.2.2.1
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2.2.1
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2.2.1
	Kernel-5_35-4_79_2_30:4.2.2.1
	Kernel-5_35-4_79_2_29:4.2.2.1
	Kernel-5_35-4_79_2_28:4.2.2.1
	Kernel-5_35-4_79_2_27:4.2.2.1
	Kernel-5_35-4_79_2_26:4.2.2.1
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2.2.1
	Kernel-5_35-4_79_2_24:4.2.2.1
	Kernel-5_35-4_79_2_23:4.2.2.1
	Kernel-5_35-4_79_2_22:4.2.2.1
	Kernel-5_35-4_79_2_21:4.2.2.1
	Kernel-5_35-4_79_2_20:4.2.2.1
	Kernel-5_35-4_79_2_19:4.2.2.1
	Kernel-5_35-4_79_2_18:4.2.2.1
	Kernel-5_35-4_79_2_17:4.2.2.1
	Kernel-5_35-4_79_2_16:4.2.2.1
	Kernel-5_35-4_79_2_15:4.2.2.1
	Kernel-5_35-4_79_2_14:4.2.2.1
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2.2.1
	Kernel-5_35-4_79_2_12:4.2.2.1
	Kernel-5_35-4_79_2_11:4.2.2.1
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2.2.1
	Kernel-5_35-4_79_2_9:4.2.2.1
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2.2.1
	Kernel-5_35-4_79_2_7:4.2.2.1
	Kernel-5_35-4_79_2_6:4.2.2.1
	Kernel-5_35-4_79_2_5:4.2.2.1
	Kernel-5_35-4_79_2_4:4.2.2.1
	Kernel-5_35-4_79_2_3:4.2.2.1
	Kernel-5_35-4_79_2_2:4.2.2.1
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2.2.1
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2018.07.14.19.02.28;	author jlee;	state Exp;
branches;
next	4.4;
commitid	DsDtaR4YavfJx8KA;

4.4
date	2016.06.30.20.29.05;	author jlee;	state Exp;
branches;
next	4.3;
commitid	lMnWzoE9eJz3Wwcz;

4.3
date	2016.06.30.20.08.20;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.04.04.14.27.42;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.41;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.09.15.12.38.02;	author kbracey;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2003.03.31.09.44.12;	author kbracey;	state Exp;
branches
	4.2.2.3.2.1;
next	4.2.2.4;

4.2.2.4
date	2011.11.26.21.11.28;	author jlee;	state Exp;
branches;
next	4.2.2.5;
commitid	cI3W0zbtALQG6TIv;

4.2.2.5
date	2011.11.27.11.48.22;	author rsprowson;	state Exp;
branches;
next	;
commitid	OFgqaKhOb6swXXIv;

4.2.2.3.2.1
date	2009.05.10.20.22.33;	author bavison;	state Exp;
branches;
next	4.2.2.3.2.2;

4.2.2.3.2.2
date	2009.05.17.01.34.43;	author bavison;	state Exp;
branches;
next	4.2.2.3.2.3;

4.2.2.3.2.3
date	2011.09.24.19.55.59;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.1.1.1
date	96.11.05.09.41.41;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.51;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.51;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.33;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.56;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Evict ECFIndex and PalIndex from VDU workspace
Detail:
  ECFIndex and PalIndex claim to be mode variables, but it's impossible for extension modes to specify their values.
  Since they're easy to calculate from the ModeFlags and Log2BPP values, drop them from the mode workspace (+ table of builtin modes) and calculate them on the fly instead.
  File changes:
  - hdr/KernelWS - Drop ECFIndex & PalIndex from workspace
  - s/vdu/vdumodes - Adjust workspace definition, drop ECFIndex & PalIndex values from VWSTAB
  - s/vdu/vdudriver - Remove now-redundant copy loop from ModeChangeSub. Remove code from GenerateModeSelectorVars that sets up the ECFIndex & PalIndex values on the stack
  - s/vdu/vdugrafl - Adjust copy loop in SwitchOutputToSprite/Mask
  - s/vdu/vdupalette, s/vdu/vdupalxx - Add GetPalIndex routine to generate PalIndex on the fly. Drop the obsolete 16bpp palette/gamma table and shuffle the other entries to simplify GetPalIndex a bit.
  - s/vdu/vduplot - Add GetECFIndex routine to generate ECFIndex on the fly. Also, fix things so that mode 0 isn't the only rectangular-pixel mode which uses the special rectangular-pixel ECF patterns (index 0 vs. index 4). Fiddle with ExportedHLine a bit to avoid an out-of-range ADR.
  - s/NewReset - Fix UAL warning for MOV R0, AppSpaceStart. Adjust memset to not assume 512KB is the correct amount
Admin:
  Tested on Raspberry Pi 3


Version 6.11. Tagged as 'Kernel-6_11'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduPlot
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu graphics code - Entry point for plotting & low level primitives
;                     & Ecf pattern setting
; Author R C Manby
; Date   5.9.86
;

; *****************************************************************************
;
; EM
; PLOT - Graphics operation, eg triangle, line etc.
; ====
;
; The plot operation, and the co-ordinate to plot at given by bytes
;  in the vdu queue, as follows
;  QQ+0 - plot number
;  QQ+1 - xLo
;  QQ+2 - xHi
;  QQ+3 - yLo
;  QQ+4 - yHi
;
; The co-ordinate is in external 16 bit form.
; If 2 or 3 are required, they are taken from ICursor & OldCs
;
; Also, both PLOT and EntryFromSWIPlot are entered with R6 = CursorFlags
;
EM
PLOT    ROUT
      [ {TRUE}
        GraphicsMode R0                 ; Quit if not a graphics mode
        MOVNE   PC, Link
      |
        LDR     R0, [WsPtr, #NPix]
        CMP     R0, #0                  ; Quit if not a graphics mode
        MOVEQ   PC, Link
      ]

        ASSERT  ((QQ+1):AND:3)=0
        LDR     R2, [WsPtr, #QQ+1]      ; R2 = xlo,xhi,ylo,yhi
        MOV     R0, R2, LSL #16         ; R0 = 0  ,0  ,xlo,xhi
        MOV     R0, R0, ASR #16         ; R0 = xlo,xhi,sgn,sgn
        MOV     R1, R2, ASR #16         ; R1 = ylo,yhi,sgn,sgn

        LDRB    R2, [WsPtr, #QQ+0]      ; plot mode
        MOV     R9, #0                  ; indicate coming from VDU Plot

EntryFromSWIPlot
        SaveRetAdr

; now convert to internal coords (modified EIG code)

        ASSERT  OrgY = OrgX +4
        ASSERT  GCsX = OrgX +8
        ASSERT  GCsY = OrgX +12
        ASSERT  YEigFactor = XEigFactor +4

        ADD     R3, WsPtr, #OrgX

        LDMIA   R3!, {R4-R5}            ; R4 = OrgX: R5 = OrgY
        TST     R2, #4                  ; If bit2 is clear, then relative
        LDMEQIA R3, {R7-R8}             ; so load old cursor position
        ADDEQ   R0, R0, R7              ; and add
        ADDEQ   R1, R1, R8
        STMIA   R3, {R0-R1}             ; store new coords in GCsX,GCsY

        ADD     R3, WsPtr, #XEigFactor
        LDMIA   R3, {R7-R8}             ; R7 = XEigFactor: R8 = YEigFactor
        ADD     R0, R0, R4              ; add on origin
        ADD     R1, R1, R5
        MOV     R0, R0, ASR R7          ; and shift down
        MOV     R1, R1, ASR R8

        ADD     R3, WsPtr, #NewPtX
        STMIA   R3, {R0-R1}

;
; The 2 LSBits of the plot code specify fg/bg colour and action as :-
;  0 No effect eqv. of Gcol(5,c)
;  1 Foreground colour using foreground Gcol action
;  2 Invert eqv. of Gcol(4,c)
;  3 Background colour using background Gcol action
;

; *****Change made by DJS
;   Original code was:
;        MOV     R3, R2, LSL #30         ; put bottom 2 bits into top 2 bits
;        CMP     R3, #&40000000          ; set lots of flags
;
;        ADDMI   R4, WsPtr, #BgEcfOraEor ; if 0 or 3
;        ADRCC   R4, NoEffect            ; if 0
;        ADDEQ   R4, WsPtr, #FgEcfOraEor ; if 1
;        ADRVS   R4, Invert              ; if 2

        MOVS    R3, R2, LSL #31         ;Put bit 1 in C, NOT(bit 0) in Z
        ADR     R4, NoEffect            ; if 0, 1, 2 or 3
        ADDNE   R4, WsPtr, #FgEcfOraEor ; if 1 or 3
        ADRCS   R4, Invert              ; if 2 or 3
        ADDHI   R4, WsPtr, #BgEcfOraEor ; if CS & NE - i.e. 3

; *****End of change made by DJS

        STR     R4, [WsPtr, #GColAdr]   ; save address of Ecf to plot with

        TST     R6, #ClipBoxEnableBit
        BLNE    DoPlotClipBox

        BIC     R11, R2, #2_111         ; ARMv4 says we have to keep bits 1:0 of PC =0
        ADR     R14, CTidy              ; set up return address
                                        ; R0=X, R1=Y, R2=plot code
        ADD     PC, PC, R11, LSR #1     ; jump to branch
        &       0                       ; dummy word

 B LineDrawSolid           ;   0 - Solid line
 B LineDrawSolid           ;   8 - Solid line, endpoint omitted
 B LineDrawDotted          ;  16 - Dot-dash line, restart pattern
 B LineDrawDotted          ;  24 - Dot-dash line, restart pattern,
                           ;        endpoint omitted
 B LineDrawSolid           ;  32 - Solid extension line
 B LineDrawSolid           ;  40 - Solid extension line, endpoint omitted
 B LineDrawDotted          ;  48 - Dot-dash extension line, continue pattern
 B LineDrawDotted          ;  56 - Dot-dash extension line, continue pattern,
                           ;        endpoint omitted
 B PlotPoint               ;  64 - Point plot
 B FillLRnonBg             ;  72 - Line fill L&R, upto non-background
 B TriangleFill            ;  80 - Triangle fill
 B FillLRtoBg              ;  88 - Fill right, upto background
 B RectangleFill           ;  96 - Rectangle fill
 B FillLRtoFg              ; 104 - Line fill L&R, upto foreground
 B ParallelogramFill       ; 112 - Parallelogram Fill
 B FillLRnonFg             ; 120 - Fill right, upto non-foreground
 B FloodNonBg              ; 128 - Flood to non-bg (ie over bg)
 B FloodToFg               ; 136 - Flood to fg (ie over non-fg)
 B CircleOutline           ; 144 - Circle outline
 B CircleFill              ; 152 - Circle fill
 B CircleArc               ; 160 - Circular arc outline
 B SegmentFill             ; 168 - Segment fill
 B SectorFill              ; 176 - Sector (pie) fill
 B BlockCopyMove           ; 184 - Block copy/move
 B EllipseOutline          ; 192 - Ellipse outline
 B EllipseFill             ; 200 - Ellipse fill
 B   NYA                   ; 208 - Unassigned
 B   NYA                   ; 216 - Unassigned
 B   NYA                   ; 224 - Unassigned
 B SpritePlot              ; 232 - Sprite plot
 B   NYA                   ; 240 - Assigned to applications
 B   NYA                   ; 248 - Assigned to applications

CTidy                           ; The "normal" return point after a plot
                                ; operation, any call that does not want
                                ; the cursors moving should pull return
                                ; address off the stack

                                ; Shuffle the cursors along
                                ;  NewPt -> ICursor -> OldCs -> OlderCs
                                ;
                                ; ECursor was set earlier by EIG

        ADD     R0, WsPtr, #OldCsX
        LDMIA   R0, {R1,R2, R3,R4, R5,R6} ; OldCs(X,Y) ICursor(X,Y) NewPt(X,Y)
        ADD     R0, WsPtr, #OlderCsX
        STMIA   R0, {R1,R2, R3,R4, R5,R6}
        Return

NYA
        MOV     R0, R2                  ; R0 := plot code
        MOV     R10, #UKPLOTV
        Push    "R9, WsPtr, R14"        ; save SWIPlot indicator, WsPtr + link
        BL      VduQQVec
        Pull    "R9, WsPtr, PC", VC     ; return to CTidy if no error

; error in UKPLOTV

        Pull    "R9, WsPtr"     ; restore SWIPlot indicator and WsPtr
        ADD     R13, R13, #8    ; throw away return to CTidy
                                ; and return address stacked by PLOT
        TEQ     R9, #0          ; called from Wrch ?
        BEQ     VduBadExit      ; yes, then go to error exit code
        B       SWIPlotBadExit  ; no, then go to SWIPlot error exit

VduQQVec
        ADD     R1, WsPtr, #QQ
VduGoVec
        CallAVector



;
; Words for forming ZGORA & ZGEOR for colour actions 0 to 7, where
;  0=Store, 1=OR, 2=AND, 3=EOR, 4=Inverse, 5=No change,
;  6=And Not(colour) ie BIC,   7=Or Not(colour)
;
;
; The values correspond to TBzgoo etc on the 6502 and are stored
; in the following order zgoo,zgeo,zgoe,zgee to allow LDM to be used
;
;                         Action
;                       0 1 2 3 4 5 6 7
; TBzgoo  OR the  OR :- F,0,0,F,F,F,0,0
; TBzgeo EOR the  OR :- 0,0,F,F,F,F,0,F
; TBzgoe  OR the EOR :- 0,F,0,0,F,F,0,F
; TBzgee EOR the EOR :- F,F,F,0,0,F,0,F
;

TBscrmasks      *       2_10010111000011111110110001010011

        [ {FALSE}
TBscrmask
 & &FFFFFFFF    ;Store colour to screen  ( OR the  OR)
 & &00000000    ;                        (EOR the  OR)
 & &00000000    ;                        ( OR the EOR)
 & &FFFFFFFF    ;                        (EOR the EOR)

 & &00000000    ;OR colour to screen
 & &00000000
 & &FFFFFFFF
 & &FFFFFFFF

 & &00000000    ;AND
 & &FFFFFFFF
 & &00000000
 & &FFFFFFFF

 & &FFFFFFFF    ;EOR
 & &FFFFFFFF
 & &00000000
 & &00000000

 & &FFFFFFFF    ;Invert
 & &FFFFFFFF
 & &FFFFFFFF
 & &00000000

 & &FFFFFFFF    ;No change
 & &FFFFFFFF
 & &FFFFFFFF
 & &FFFFFFFF

 & &00000000    ;BIC (ie AND NOTcol)
 & &00000000
 & &00000000
 & &00000000

 & &00000000    ;OR NOTcol
 & &FFFFFFFF
 & &FFFFFFFF
 & &FFFFFFFF
        ]

        MALIGN  64      ; Invert and NoEffect must be aligned to a multiple
                        ; of 64 for line drawing routines (TMD)

                        ;Interleaved zgora & zgeor values to give invert
                        ; and no effect plotting, used when plot code
Invert                  ; overrides Fg/Bg Gcol colour and action.
 & &00000000
 & &FFFFFFFF
 & &00000000
 & &FFFFFFFF
 & &00000000
 & &FFFFFFFF
 & &00000000
 & &FFFFFFFF
 & &00000000
 & &FFFFFFFF
 & &00000000
 & &FFFFFFFF
 & &00000000
 & &FFFFFFFF
 & &00000000
 & &FFFFFFFF
NoEffect
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000
 & &00000000

; *****************************************************************************
;
; EIG - External to internal graphic coordinate conversion
; ===
;
; Convert external coordinates (either relative or absolute) into
; internal ones. No windowing is done.
;
;
; On entry, R0 (X), R1 (Y) hold coordinate (external co-ords)
;           R2 holds plot mode, where bit2 = 0 for relative (add ECursor)
;                                          = 1 for absolute (add origin)
;
; On exit,  R0 (X), R1 (Y) hold internal representation
;           R2 preserved
;
;           R3 corrupt
;
;           The external cursor (GCsX,GCsY) is updated to the new point,
;           hence in triangle relative mode, the points are relative to
;           the last point specified, not the original.
;
EIG
                                ;Do Ycoord first
        TST R2,#4               ;If bit2 is clear
        LDREQ R3,[WsPtr,#GCsY]  ;then co-ord is relative
        ADDEQ R1,R1,R3          ;     so add previous cursor (ext. rep.)

        STR R1,[WsPtr,#GCsY]    ;Update previous cursor
        LDR R3,[WsPtr,#OrgY]    ;Add origin
        ADD R1,R1,R3

        LDR R3, [WsPtr, #YEigFactor]
        MOV R1,R1,ASR R3        ;Transform 0-1023 to 0-255 or 0-511

                                ;Do Xcoord
        LDREQ R3,[WsPtr,#GCsX]  ;If relative then
        ADDEQ R0,R0,R3          ;  add previous cursor (ext. rep.)

        STR R0,[WsPtr,#GCsX]    ;Update previous cursor
        LDR R3,[WsPtr,#OrgX]    ;Add origin
        ADD R0,R0,R3

        LDR R3,[WsPtr,#XEigFactor]
        MOV R0,R0,ASR R3        ;Transform 0-1279 to 0-639/0-319/0-159

        MOV PC,R14

; *****************************************************************************
;
; IEG - Inverse of EIG. Convert ICursor to ECursor
; ===
;
; On exit, R0 (X), R1 (Y) holds ECursor, ECursor updated
;       R2, R3 hold XEigFactor, YEigFactor
;       R4, R5 corrupt
;
        ASSERT  GCsIY = GCsIX +4
        ASSERT  YEigFactor = XEigFactor +4
        ASSERT  OrgY = OrgX +4
        ASSERT  GCsY = GCsX +4
IEG
        ADD     R0, WsPtr, #GCsIX
        LDMIA   R0, {R0,R1}             ; load graphics cursor (internal)
IEGB
        ADD     R2, WsPtr, #XEigFactor
        LDMIA   R2, {R2, R3}            ; R2 = XEigFactor; R3 = YEigFactor
        ADD     R4, WsPtr, #OrgX
        LDMIA   R4, {R4, R5}            ; R4 = OrgX; R5 = OrgY
        RSB     R0, R4, R0, LSL R2      ; R0 = (X << XEigFactor)-OrgX
        RSB     R1, R5, R1, LSL R3      ; R1 = (Y << YEigFactor)-OrgY
        ADD     R4, WsPtr, #GCsX
        STMIA   R4, {R0,R1}             ; write graphics cursor (external)

        MOV PC,R14

        [ {FALSE}
; *****************************************************************************
;
; Window - Check a coordinate against the graphics window
; ======
;
; On entry, R0 (X), R1 (Y) holds coordinate to window
; On exit,  R0,R1 preserved,
;           R3 corrupt
;           R2 holds result, as follows:
;
;                |      |
;           1001 | 1000 | 1010
;                |      |
;           -----+------+-----
;                |      |
;           0001 | 0000 | 0010
;                |      |
;           -----+------+-----
;                |      |
;           0101 | 0100 | 0110
;                |      |
;
;
;
Window
        MOV R2,#0
        LDR R3,[WsPtr,#GWBRow]          ;Test ycoord against window
        CMP R1,R3
        ORRLT R2,R2,#4                  ;Set bit 2 if Y < window

        LDR R3,[WsPtr,#GWTRow]
        CMP R3,R1
        ORRLT R2,R2,#8                  ;Set bit 3 if Y > window

        LDR R3,[WsPtr,#GWLCol]          ;Test xcoord against window
        CMP R0,R3
        ORRLT R2,R2,#1                  ;Set bit 0 if X < window

        LDR R3,[WsPtr,#GWRCol]
        CMP R3,R0
        ORRLT R2,R2,#2                  ;Set bit 1 if X > window

        MOV PC,R14

        ]
; *****************************************************************************
;
; ScreenAddr - Generate screen address of coordinate
; ==========
;
; On entry, R0 (X), R1 (Y) holds coordinate - must be within graphics window
; On exit,  R0,R1 preserved,
;           R2 holds word address
;           R3 holds pixel mask
;
;           R7,R8 corrupt
ScreenAddr
        ASSERT  LineLength = YWindLimit +4

        ADD     R7, WsPtr, #YWindLimit
        LDMIA   R7, {R7,R8}                     ; R7=YWindLimit,R8=LineLength
        SUB     R2, R7, R1                      ; flip ycoord into R2

        LDR     R7, [WsPtr, #ScreenStart]       ; add the screen start
        MLA     R2, R8, R2, R7                  ; to Ycoord * bytes per row

        LDR     R3, [WsPtr, #XShftFactor]       ; R7 := 2,3,4 or 5
        MOV     R8, R0, ASR R3                  ; R8 := word offset
        ADD     R2, R2, R8, LSL #2              ; add on to screen address

        EOR     R7, R0, R8, LSL R3              ; R7 := pixel offset
        ADD     R3, WsPtr, #RAMMaskTb
        LDR     R3, [R3, R7, LSL #2]            ; R3 := mask for this pixel

        MOV     PC, R14

; *****************************************************************************
;
; PlotPoint - Plot a point in the current colour
; =========
;
; On entry, R0 (X), R1 (Y) holds coordinate of point
; On exit,  R0,R1 preserved
;           R2-R8 corrupt
;           R9-R11 preserved
;

PlotPoint
        WINDow  R0,R1, R2,R3,R4,R5
        MOVLT   PC, R14                         ; If outside window, give up

        ASSERT  LineLength = YWindLimit +4

        ADD     R7, WsPtr, #YWindLimit
        LDMIA   R7, {R7,R8}                     ; R7=YWindLimit; R8=LineLength
        SUB     R2, R7, R1                      ; flip ycoord into R2

; *****Change made by DJS
; Original code was:
;        ASSERT  GColAdr = XShftFactor +4
;        ASSERT  ScreenStart = XShftFactor +8
;
;        ADD     R4, WsPtr, #XShftFactor         ; R4=XShftFactor; R5=GColAdr
;        LDMIA   R4, {R4, R5, R7}                ; R7=ScreenStart
;
;        MLA     R2, R8, R2, R7                  ; R2=ScreenStart+Y*LineLength
;        MOV     R8, R0, ASR R4                  ; R8 := XCoord DIV 4,8,16
;                                                ;   or 32
;        EOR     R7, R0, R8, LSL R4              ; R7 := pixel offset in word
;        ADD     R3, WsPtr, #RAMMaskTb
;        LDR     R3, [R3, R7, LSL #2]            ; R3 := mask for this pixel
;
;        EOR     R6, R1, #7                      ; flip Ycoord
;        AND     R6, R6, #7                      ; line within ecf
; This does not calculate the ecf line correctly, resulting in bugs if (e.g.)
; a destination sprite is not a multiple of 8 pixels high.

        AND     R6, R2, #7                      ; R6 := line with ecf

        ASSERT  GColAdr = XShftFactor +4
        ASSERT  ScreenStart = XShftFactor +8

        ADD     R4, WsPtr, #XShftFactor         ; R4=XShftFactor; R5=GColAdr
        LDMIA   R4, {R4, R5, R7}                ; R7=ScreenStart

        MLA     R2, R8, R2, R7                  ; R2=ScreenStart+Y*LineLength
        MOV     R8, R0, ASR R4                  ; R8 := XCoord DIV 4,8,16 or 32
        EOR     R7, R0, R8, LSL R4              ; R7 := pixel offset in word
        ADD     R3, WsPtr, #RAMMaskTb
        LDR     R3, [R3, R7, LSL #2]            ; R3 := mask for this pixel

; *****End of change made by DJS

        ADD     R5, R5, R6, LSL #3
        LDMIA   R5, {R5, R6}                    ; get zgora,zgeor

        AND     R5, R5, R3                      ; mask zgora
        AND     R6, R6, R3                      ; & zgeor for this pixel
 [ AvoidScreenReads
        CMP     R5, #&FFFFFFFF
        LDRNE   R7, [R2, R8, LSL #2]
 |
        LDR     R7, [R2, R8, LSL #2]
 ]
        ORR     R7, R7, R5                      ; and hit the screen
        EOR     R7, R7, R6
        STR     R7, [R2, R8, LSL #2]
        MOV     PC, R14

; *****************************************************************************
;
; ComplexEcfPattern
; =================
;
; On entry, R0 holds pattern number, where 2..6 means Ecf1..4
;
; Vdu queue holds
;
;          QQ+0  pattern number
;          QQ+1  pattern bytes 0
;           |                  |
;          QQ+8                7
;
; ComplexEcfPat10 is an entry point from simple Ecf setting for 8 bpp modes
;                 ie simple=complex in 8 bpp modes
;                 R1 points to Ecf(n) to be programmed.
;
; Corrupts R0..R3
;

ComplexEcfPattern ROUT                  ; R0 holds 2,3,4,5 for Ecfs 1,2,3,4
        ADD     R1, WsPtr, #(Ecf1-2*8)
        ADD     R1, R1, R0, LSL #3      ; point R1 at Ecf(n)
ComplexEcfPat10
        ADD     R0, WsPtr, #(QQ+1)
        LDR     R2, [WsPtr, #BBCcompatibleECFs] ; if in BBC mode
        CMP     R2, #0
        BEQ     ComplexEcfPat20                 ; then unmangle the interleaved
                                                ;      pixels
        LDMIA   R0, {R2,R3}                     ; else (native) use as given
        STMIA   R1, {R2,R3}
        B       SetColour       ; update FgEcf & BgEcf incase they use this Ecf

; R1 points at Ecf(n)
; R0 points at QQ+1
;
; Uses R2 - pointer into InterleaveTB(BitsPerPix)
;      R3 - byte to process 7..0
;      R4 - #1
;      R5 - bit within byte to process 7..0
;      R6 - result byte
;      R7 - byte from queue
;      R8 - bit mask from InterleaveTB(BitsPerPix,R5)

ComplexEcfPat20
        ADR     R2, InterleaveTB
        LDR     R3, [WsPtr, #Log2BPP]   ; 0,1,2,3 means 1,2,4,8 bits per pixel
        ADD     R2, R2, R3, LSL #3      ; point R2 at entry in interleave table
        MOV     R3, #7                  ; 7..0 bytes to process
        MOV     R4, #1
ComplexEcfPat30
        MOV     R5, #7                  ; 7..0 bits per byte
        MOV     R6, #0                  ; clear result byte
        LDRB    R7, [R0, R3]            ; byte from queue
ComplexEcfPat40
        LDRB    R8, [R2, R5]
        TST     R8, R7
        ORRNE   R6, R6, R4, LSL R5      ; set bit in result byte
        SUBS    R5, R5, #1
        BGE     ComplexEcfPat40         ; process next bit

        STRB    R6, [R1, R3]            ; write de-interleaved byte to Ecf(n)
        SUBS    R3, R3, #1
        BGE     ComplexEcfPat30         ; process next byte from queue

        B       SetColour       ; update FgEcf & BgEcf incase they use this Ecf

;
; InterleaveTB - Values used to unpack BBC style interleaved pixels
;
InterleaveTB
; 1 bit  per pixel eg Mode 0 & 4 - Log2BPP is 0
        =       &80, &40, &20, &10, &08, &04, &02, &01
; 2 bits per pixel eg Mode 1 & 5 - Log2BPP is 1
        =       &08, &80, &04, &40, &02, &20, &01, &10
; 4 bits per pixel eg Mode 2 - Log2BPP is 2
        =       &02, &08, &20, &80, &01, &04, &10, &40
; 8 bits per pixel - no effect - Log2BPP is 3
        =       &01, &02, &04, &08, &10, &20, &40, &80

        ALIGN

; *****************************************************************************
;
; LineStyle - Setup dotted line style (does not affect repeat length)
; =========
;
; Corrupts R0..R3
;

LineStyle ROUT
        MOV     R3, #8                          ; Copy 8 bytes in reverse order
        ADD     R1, WsPtr, #QQ+9
        ADD     R2, WsPtr, #DotLineStyle        ; from Queue into DotLineStyle
LineSty10
        LDRB    R0, [R1, #-1]!
        STRB    R0, [R2], #1
        SUBS    R3, R3, #1
        BNE     LineSty10
        MOV     PC, R14

        LTORG   ;limited offsets

; *****************************************************************************
;
;       DefaultLineStyle - Setup default line style and length
;
;       Internal routine, called by mode change, SwitchOutputToSprite and
;        FX163,242,n code
;
; out:  Can corrupt R0-R3,
;       PSR preserved
;

DefaultLineStyle ROUT
        MRS     R3, CPSR
DefaultLineStylePSRready
        MOV     R0, #8                  ; dot pattern repeats after 8 pixels
        STR     R0, [WsPtr, #DotLineLength]
        LDR     R0, =&AAAAAAAA          ; on-off pattern
        STR     R0, [WsPtr, #DotLineStyle+0] ; 64 bits of pattern
        STR     R0, [WsPtr, #DotLineStyle+4]
        MOV     R0, #0                  ; force a restart of the pattern
        STR     R0, [WsPtr, #LineDotCnt] ; if the user does a "continue"
        MSR     CPSR_f, R3
        MOV     PC, R14

; *****************************************************************************
;
;       SetPatLength - Set dotted line repeat length
;
;       Internal routine, called by DoOsbyte163_242
;
; in:   R2 = 1..64 => set pattern length to this
;            0     => set default length and pattern
;
; out:  Can corrupt R0-R3,
;       PSR preserved
;

SetPatLength ROUT
        MRS     R3, CPSR
        CMP     R2, #0
        BEQ     DefaultLineStylePSRready
        STR     R2, [WsPtr, #DotLineLength]     ; 1..64
        MOV     R2, #0                          ; force restart of the pattern
        STR     R2, [WsPtr, #LineDotCnt]        ; if the user does a "continue"
        MSR     CPSR_f, R3
        MOV     PC, R14


; *****************************************************************************
;
;       GetECFIndex - Return index of default ECF patterns for mode
;
;       Out:
;       R0 = table index
;       R2 corrupt
;

GetECFIndex ROUT
        ; Non-graphic modes always get index 0 (empty patterns)
        LDR     R0, [WsPtr, #ModeFlags]
        TST     R0, #ModeFlag_NonGraphic
        MOVNE   R0, #0
        MOVNE   PC, LR
        ; Other modes are dependent on BPP
        LDR     R0, [WsPtr, #Log2BPP]
        ; Extra hassle for 1bpp, we want two different patterns depending on pixel aspect ratio
        CMP     R0, #0
        LDREQ   R2, [WsPtr, #AspectRatio]
        CMPEQ   R2, #2
        MOVEQ   R0, #1
        LDRNEB  R0, [PC, R0] ; 1 or 4 for 1bpp
        MOV     PC, LR
        DCB     4, 2, 3, 5, 5, 5 ; 1bpp-32bpp
        ALIGN

; *****************************************************************************
;
;       DefaultEcfPattern - Setup all 4 ecf patterns for this mode
;       (does not affect line style)
;
;       Internal routine, called by mode change, SwitchOutputToSprite and
;        VDU 23_11
;

DefaultEcfPattern ROUT
        MOV     R0, #0
        STR     R0, [WsPtr, #BBCcompatibleECFs] ;Select BBC compatible ECF mode

        Push    "lr"
        BL      GetECFIndex
        Pull    "lr"
        ADR     R1, DefEcfTb
        ADD     R0, R1, R0, LSL #4      ; 16 bytes per entry
        ADD     R1, WsPtr, #Ecf1

        LDMIA   R0, {R2,R4,R6,R8}       ; Get all four patterns for each mode
        LDMIA   R0, {R3,R5,R7,R9}       ; duplicate top half into bottom half
        STMIA   R1, {R2-R9}             ; Write all 4 Ecfs
        B       SetColour       ; update FgEcf & BgEcf in case they are Ecfs


DefEcfTb        ; Table of default ECFs, indexed by ECFIndex

; Modes 3,6,7 (i.e. non-graphic modes)
 & 0
 & 0
 & 0
 & 0

; Mode 0 (i.e. 1:2 eigen 1bpp modes)
 & &00330033     ;Dark grey      (3 black, 1 white)
 & &CC33CC33     ;Grey           (2 black, 2 white)
 & &CCFFCCFF     ;Light grey     (1 black, 3 white)
 & &030C30C0     ;Hatching

; Modes 1,5,8,11,19 (i.e. 2bpp modes)
 & &55665566     ;Red orange     (3 red, 1 yellow)
 & &99669966     ;Orange         (2 red, 2 yellow)
 & &99AA99AA     ;Yellow orange  (1 red, 3 yellow)
 & &BBEEBBEE     ;Cream          (2 white, 2 yellow)

; Modes 2,9,12,14,16,17,20(,21) (i.e. 4bpp modes)
 & &31133113     ;Orange         (2 red, 2 yellow)
 & &51155115     ;Pink           (2 red, 2 magenta)
 & &32233223     ;Yellow green   (2 green, 2 yellow)
 & &37733773     ;Cream          (2 white, 2 yellow)

; Modes 4,18,22,23 (i.e. square pixel 1bpp modes)
 & &00550055     ;Dark grey      (3 black, 1 white)
 & &AA55AA55     ;Grey           (2 black, 2 white)
 & &AAFFAAFF     ;Light grey     (1 black, 3 white)
 & &11224488     ;Hatching

; Modes 10,13,15 (>= 8bpp modes)
 & &FFFEFDFC     ;Its runnier than yoy'll lik itt
 & &00010203
 & &20212223
 & &DFDEDDDC

; *****************************************************************************
;
;       SimpleEcfPattern - Setup simple ecf pattern
;
;       Internal routine, called by VDU23_12..15
;
; in:   R0 = 12..15 for ecfs 1..4
;       Vdu queue holds
;          QQ+0  pattern number
;          QQ+1  pattern bytes 0
;           |                  |
;          QQ+8                7
;

SimpleEcfPattern ROUT
        ADD     R1, WsPtr, #(Ecf1-12*8)
        ADD     R1, R1, R0, LSL #3      ; Point R1 at ECF(n)
        ADD     R2, WsPtr, #(QQ+1)      ; Point R2 at first colour in queue
        ADR     R3, SimpEcfTb
        Push    "lr"
        BL      GetECFIndex
        LDRB    R10, [R3, R0]           ; Mask for this mode
        Pull    "lr"
        CMP     R10, #&FF
        BEQ     SimplEc20               ; 256 colour modes are different
        LDR     R5, [WsPtr, #NColour]
        ADRL    R4, TBFullCol           ; Base of full colour table (of bytes)
        ADD     R4, R4, R5              ; Access to table is always
                                        ; TBFullCol(NColour+(byte AND NColour))
                                        ; so add NColour in now !
        MOV     R7, #4                  ; There are 4 pairs of bytes in queue
SimplEc10
        LDRB    R6, [R2], #1            ; Get first colour of pair from queue
        AND     R6, R6, R5              ; (byte AND NColour)
        LDRB    R6, [R4, R6]            ; The full byte for this colour
        AND     R6, R6, R10             ; Extract required pixels
        LDRB    R9, [R2], #1            ; Get next colour of pair from queue
        AND     R9, R9, R5              ; (byte AND Ncolour)
        LDRB    R9, [R4, R9]
        BIC     R9, R9, R10             ; Extract required pixels and
        ORR     R6, R6, R9              ; build into final pattern
        STRB    R6, [R1, #4]            ; Replicate pattern in both halves
        STRB    R6, [R1], #1            ; of ECF
        SUBS    R7, R7, #1
        BNE     SimplEc10
        B       SetColour       ; update FgEcf & BgEcf in case they use this

; R1 -> ECF(n)
; R2 -> first colour in queue

SimplEc20
        Push    R14
        MOV     R5, #8
SimplEc30
        LDRB    R0, [R2], #1            ; Get byte from queue
        AND     R3, R0, #&C0            ; Extract Tint
        AND     R0, R0, #&3F            ;         Colour

        BL      AddTintToColour         ; Recombine in our funny fashion
        STRB    R0, [R1], #1            ; And store in the Ecf
        SUBS    R5, R5, #1
        BNE     SimplEc30
        Pull    R14
        B       SetColour       ; Update FgEcf & BgEcf incase they use this Ecf

SimpEcfTb       ; Table of masks for simple ECFs, indexed by ECFIndex
                ; (bit set => use left pixel, bit clear => use right pixel)

        =       &00     ; Modes 3,6,7
        =       &33     ; Mode 0
        =       &33     ; Modes 1,5,8,11,19
        =       &0F     ; Modes 2,9,12,14,16,17,20
        =       &55     ; Modes 4,18,21,22
        =       &FF     ; Modes 10,13,15

        ALIGN

; *****************************************************************************
;
;       ExportedHLine - Routine exported via VDU variable HLineAddr
;
; in:   R0,R2 = X coords in some order (internal coords)
;       R1 = Y coord (internal coord)
;       R3 = 0 => no effect
;       R3 = 1 => foreground colour/action
;       R3 = 2 => invert
;       R3 = 3 => background colour/action
;       R3 >= 4 => R3 -> eight word pairs
;

ExportedHLine ROUT
        Push    "R0,R2,R4-R10,WsPtr,R14"
        VDWS    WsPtr
        CMP     R3, #4
        BCS     %FT10

; *****Change made by DJS
;   Original code was:
;        MOV     R3, R3, LSL #30         ; put bottom 2 bits into top 2 bits
;        CMP     R3, #&40000000          ; set lots of flags
;
;        ADDMI   R3, WsPtr, #BgEcfOraEor ; if 0 or 3
;        ADRCC   R3, NoEffect            ; if 0
;        ADDEQ   R3, WsPtr, #FgEcfOraEor ; if 1
;        ADRVS   R3, Invert              ; if 2

        MOVS    R3, R3, LSL #31         ;Put bit 1 in C, NOT(bit 0) in Z
        ADR     R3, NoEffect            ; if 0, 1, 2 or 3
        ADDCS   R3, R3,#Invert-NoEffect ; if 2 or 3
        ADDNE   R3, WsPtr, #FgEcfOraEor ; if 1 or 3
        ADDHI   R3, WsPtr, #BgEcfOraEor ; if CS & NE - i.e. 3

; *****End of change made by DJS

10
        STR     R3, [WsPtr, #GColAdr]   ; save address of Ecf to plot with
        BL      HLine
        CLRV
        Pull    "R0,R2,R4-R10,WsPtr,PC"

; *****************************************************************************
;
; NewHLine - Horizontal line draw   an even newer version what does 8 words
; ========                          at a time if it can
;
; On entry, R0 (X), R1 (Y) holds coordinate of point
;           R2             holds right hand XCoord
; On exit,  R3 preserved
;           R4..R10 corrupt
;           PSR preserved
;
; N.B. R11 WILL BE PRESERVED - This is assumed by rectangle fill and all circle
;                              operations
;

HLine
        SortT   R0, R2, R4              ; Sort the Xcoord into order R0<=R2

NewHLine ROUT                           ; Entry point for sorted Xcoords

        ADD     R4, WsPtr, #GWLCol
        LDMIA   R4, {R4-R7}             ; GWLCol,GWBRow,GWRCol,GWTRow

        CMP     R7, R1                  ; Test ycoord against window
        CMPGE   R1, R5

        CMPGE   R6, R0                  ; Test xcoords against window
        CMPGE   R2, R4
        MOVLT   PC, R14                 ; Quit if above,below,left or right
                                        ; of window

        Greatest R0, R0, R4             ; If start of line to left of window
                                        ; pull to window edge
        Least   R2, R2, R6              ; If end of line to right of window
                                        ; pull to window edge

        Push    "R0-R3,R11,Link"

;
; Now, R0 holds Start (leftX), R1 holds Y and R2 holds End (rightX)
;
; Now pick up ecf word and form the ZGORA & ZGEOR masks
;

        ASSERT  LineLength = YWindLimit +4
        ASSERT  GColAdr = XShftFactor +4
        ASSERT  ScreenStart = XShftFactor +8

        ADD     R11, WsPtr, #YWindLimit
        LDMIA   R11, {R10-R11}          ; R10 = YWindLimit; R11 = LineLength

        ADD     R9, WsPtr, #XShftFactor
        LDMIA   R9, {R7-R9}             ; R7 = XShftFactor; R8 = GColAdr
                                        ; R9 = ScreenStart

        SUB     R1, R10, R1             ; flip ycoord into R1
        AND     R6, R1, #7              ; R6 = line within ecf
        ADD     R8, R8, R6, LSL #3      ; R8 -> zgora, zgeor
        LDMIA   R8, {R8, R10}           ; R8 = zgora; R10 = zgeor

        MLA     R9, R11, R1, R9         ; R9 -> start of this scan line

        MOV     R6, R0, LSR R7          ; R6 = X1Coord word offset
        MOV     R11, R2, LSR R7         ; R11 = X2Coord word offset
        ADD     R9, R9, R6, LSL #2      ; R9 = address of lefthand word

; *****Change made by DJS
; Original code was:
;
;        EOR     R4, R0, R6, LSL R7      ; R4 = X1 pixel offset
;        EOR     R5, R2, R11, LSL R7     ; R5 = X2 pixel offset
;
;        SUBS    R11, R11, R6            ; R11 = number of words -1
;                                        ; and set Z on it
;
;        ADD     R7, WsPtr, #RAMMaskTb   ; R7 -> MaskTb for this mode
;        LDR     R6, [R7, R4, LSL #2]    ; R6 = left mask
;        LDR     R14, [R7, R5, LSL #2]   ; R14 = right mask
;
;        SUB     R7, R14, #1             ; in right mask set all bits lower
;        ORR     R14, R14, R7            ; by RM = RM OR (RM-1)
;
;        RSB     R7, R6, #0              ; in left mask, set all bits higher
;        ORR     R6, R6, R7              ; by LM = LM OR (-LM)
;
; The following code is shorter and faster.

        SUBS    R11, R11, R6            ; R11 = number of words -1
                                        ; and set Z on it

        RSB     R7, R7, #5              ; R7 = Log2BPC (quicker than loading!)
        MOV     R14, #31                ; constant to extract bit offsets
        AND     R4, R14, R0, LSL R7     ; R4 = start of X1 pixel offset
        AND     R5, R14, R2, LSL R7     ; R5 = start of X2 pixel offset
        MOV     R14, #-1                ; Useful both as -1 and as &FFFFFFFF
        SUB     R5, R5, R14, LSL R7     ; R5 = end of X2 pixel offset
        MOV     R6, R14, LSL R4         ; R6 = left mask
        MVN     R14, R14, LSL R5        ; R14 = right mask

; *****End of change made by DJS

        ANDEQ   R14, R14, R6            ; if start word = end word
        BEQ     %FT40                   ; then combine masks

 [ AvoidScreenReads
        AND     R1, R8, R6              ; zgora AND left mask
        CMP     R1, #&FFFFFFFF
        LDRNE   R0, [R9]                ; do left hand word of line
 |
        LDR     R0, [R9]                ; do left hand word of line
        AND     R1, R8, R6              ; zgora AND left mask
 ]
        AND     R2, R10, R6             ; zgeor AND left mask
        ORR     R0, R0, R1              ; screen OR or mask
        EOR     R0, R0, R2              ; EOR eor mask
        STR     R0, [R9], #4            ; store to screen

        SUBS    R11, R11, #1            ; decrement word count, if =0
        BEQ     %FT40                   ; then plot RH partial word

        CMP     R8, #-1                 ; if R8 = -1 then store action
        BNE     %FT05                   ; else do it the slow way

        MVN     R0, R10                 ; R0 = word of colour to plot
        MOV     R1, R0
        MOV     R2, R0
        MOV     R3, R0
        ADDS    R8, R8, R11, LSR #3     ; R8 = (no. of words DIV 8)-1
        BCC     %FT60                   ; must be fewer than 8
        MOV     R4, R0
        MOV     R5, R0
        MOV     R6, R0
        MOV     R7, R0

; *****Additional message inserted by DJS

        [       ((.-KernelBase) :AND: 15) = 12
        !       0, "HLine critical loop has bad alignment for running in RAM"
        ]

; *****End of message inserted by DJS

50
        STMCSIA R9!, {R0-R7}            ; write 8 words to screen if >=0
        STMHIIA R9!, {R0-R7}            ; write 8 words to screen if > 0
        SUBS    R8, R8, #2              ; try for another 16
        BCS     %BT50
60
        TST     R11, #4                 ; can we do 4 words ?
        STMNEIA R9!, {R0-R3}            ; write 4 words to screen
        TST     R11, #2                 ; can we do 2 words ?
        STMNEIA R9!, {R0-R1}            ; write 2 words to screen
        TST     R11, #1                 ; can we do 1 word ?
        STRNE   R0, [R9], #4            ; write 1 word to screen
        AND     R10, R10, R14           ; do partial word at end
 [ AvoidScreenReads
        CMP     R14, #&FFFFFFFF
        LDRNE   R0, [R9]
 |
        LDR     R0, [R9]
 ]
        OrrEor  R0,R0, R14,R10
        STR     R0, [R9],#4
70
        Pull    "R0-R3,R11,PC"

; code for when not store action

05
        SUBS    R11, R11, #8            ; else try for 8 words at a time
        BMI     %FT20                   ; failed, so try for 4 at a time
10
        LDMIA   R9, {R0-R7}
        OrrEor  R0,R0, R8,R10           ; Write 8 words to screen
        OrrEor  R1,R1, R8,R10
        OrrEor  R2,R2, R8,R10
        OrrEor  R3,R3, R8,R10
        OrrEor  R4,R4, R8,R10
        OrrEor  R5,R5, R8,R10
        OrrEor  R6,R6, R8,R10
        OrrEor  R7,R7, R8,R10
        STMIA   R9!, {R0-R7}
        SUBS    R11, R11, #8            ; try for another 8
        BPL     %BT10

20
        ADDS    R11, R11, #4            ; can we do 4 words ?
        BMI     %FT30                   ; no, then do 1 word at a time

        LDMIA   R9, {R0-R3}
        OrrEor  R0,R0, R8,R10           ; Write 4 words to screen
        OrrEor  R1,R1, R8,R10
        OrrEor  R2,R2, R8,R10
        OrrEor  R3,R3, R8,R10
        STMIA   R9!, {R0-R3}

        SUB     R11, R11, #4
30
        ADDS    R11, R11, #4            ; Correct for earlier SUB #4

40                                      ; Plot single words
        ANDEQ   R8, R8, R14             ; If EQ, this is RH word,
        ANDEQ   R10, R10, R14           ; so mask down to required pixels
        LDR     R0, [R9]
        OrrEor  R0,R0, R8,R10
        STR     R0, [R9],#4

        SUBS    R11,R11,#1
        BPL     %BT40

        Pull    "R0-R3,R11,PC"

; *****************************************************************************
;
;       NewVLine - Vertical line draw for non-dotted solid pattern lines
;
; in:   R0 = R2 = X coord
;       R1 = bottom Y coord
;       R3 = top Y coord
;
; out:  R4-R10 corrupt
;       PSR preserved
;

NewVLine ROUT                           ; Entry point for sorted Ycoords

        ADD     R4, WsPtr, #GWLCol
        LDMIA   R4, {R4-R7}             ; GWLCol,GWBRow,GWRCol,GWTRow

        CMP     R7, R1                  ; Test ycoord against window
        CMPGE   R3, R5

        CMPGE   R6, R0                  ; Test xcoords against window
        CMPGE   R2, R4
        MOVLT   PC, R14                 ; Quit if above,below,left or right
                                        ; of window

        Greatest R1, R1, R5             ; If bottom of line below window
                                        ; pull to window edge
        Least   R3, R3, R7              ; If top of line above window
                                        ; pull to window edge


        Push    "R0-R3,R11,Link"

; Now, R0 holds X, R1 holds bottom Y and R3 holds top Y
;
; Now pick up ecf word and form the ZGORA & ZGEOR masks
;

        ASSERT  LineLength = YWindLimit +4
        ASSERT  GColAdr = XShftFactor +4
        ASSERT  ScreenStart = XShftFactor +8

        ADD     R11, WsPtr, #YWindLimit
        LDMIA   R11, {R10-R11}          ; R10 = YWindLimit; R11 = LineLength

        ADD     R9, WsPtr, #XShftFactor
        LDMIA   R9, {R7-R9}             ; R7 = XShftFactor; R8 = GColAdr
                                        ; R9 = ScreenStart
        SUB     R1, R3, R1              ; R1 = number of dots to do -1

        SUB     R3, R10, R3             ; R3 = flipped top ycoord
        MLA     R9, R11, R3, R9         ; R9 -> start of this scan line

        LDMIA   R8, {R8, R10}           ; R8 = zgora; R10 = zgeor
                                        ; (no need to index with Y cos we
                                        ; know there's no ECF pattern)

        MOV     R6, R0, LSR R7          ; R6 = X coord word offset
        ADD     R9, R9, R6, LSL #2      ; R9 = address of top word

        EOR     R4, R0, R6, LSL R7      ; R4 = X pixel offset

        ADD     R7, WsPtr, #RAMMaskTb   ; R7 -> MaskTb for this mode
        LDR     R6, [R7, R4, LSL #2]    ; R6 = pixel mask
        AND     R8, R8, R6              ; zgora = zgora AND pixelmask
        AND     R10, R10, R6            ; zgeor = zgeor AND pixelmask

 [ AvoidScreenReads
        CMP     R8, #&FFFFFFFF
        BEQ     %FT20
 ]

; now do the plotting

10
        LDR     R6, [R9]
        ORR     R6, R6, R8
        EOR     R6, R6, R10
        STR     R6, [R9], R11
        SUBS    R1, R1, #1
        BPL     %BT10

        Pull    "R0-R3,R11,PC"

 [ AvoidScreenReads
20      MVN     R6, R10
25      STR     R6, [R9], R11
        SUBS    R1, R1, #1
        BPL     %BT25
        Pull    "R0-R3,R11,PC"
 ]


; *****************************************************************************
;
; DoubleHLine - Draw 2 horizontal lines
; ===========
;
; On entry, R0 (X) - Left most point
;           R1 (Y) - y ordinate of line
;           R2 (X) - Right most point
;           R3 (X) - end of left most line
;           R4 (X) - start of right most line
;
; On exit,  R0..R10 preserved  } subject
;           R11 corrupt        }  to change
;
DoubleHLine
        Push    "R0-R10, R14"
        MOV     R2, R3                  ; draw left line, R0->R3 inc.
        BL      HLine
        LDMIB   R13, {R1-R4}
        MOV     R0, R4                  ; draw right line, R4->R2 inc.
        BL      HLine
        Pull    "R0-R10, PC"

; *****************************************************************************
;
;       ExtractTintAndColour - Convert 256-colour mode byte value into
;        colour and tint
;
;       Internal routine, called by ReadPixelColour, SwiReadPoint
;
; in:   R0 = single screen pixel (ie 'half' user pixel in double modes)
;
; out:  R0 corrupt
;       R2 = colour value (GCOL a,colour)
;       R3 = tint Vdu 23,17 etc
;

ExtractTintAndColour ROUT
                                        ; R0 := B3 G3 G2 R3 B2 R2 T1 T0
        MOV     R3, R0, LSL #6          ; R3 := T1 T0  0  0  0  0  0  0
        AND     R3, R3, #&C0
        AND     R2, R0, #&84            ; R2 := B3  0  0  0  0 R2  0  0
        TST     R0, #8
        ORRNE   R2, R2, #&40            ; R2 := B3 B2  0  0  0 R2  0  0
        AND     R0, R0, #&70            ; R0 :=  0 G3 G2 R3  0  0  0  0
        ORR     R2, R2, R0, LSR #1      ; R2 := B3 B2 G3 G2 R3 R2  0  0
        MOV     R2, R2, LSR #2          ; R2 :=  0  0 B3 B2 G3 G2 R3 R2
        MOV     PC, R14

; *****************************************************************************
;
;       SwiReadPoint - Read colour of screen pixel
;
;       External routine - entry point for SWI OS_ReadPoint
;
; in:   R0, R1 = X, Y coordinate of point
;
; out:  R2 = colour (as in GCOL a,colour)       } -1 if off screen
;       R3 = tint value (as in VDU 23,17 etc)   }  0 if off screen
;       R4 = 0/-1 for On/Off screen
;       R0,R1, R5-R9 preserved (R10-R12 preserved by MOS)
;

SwiReadPoint ROUT
        WritePSRc SVC_mode, WsPtr       ; re-enable interrupts
        VDWS    WsPtr                   ; point R12 at vdu driver workspace

      [ {TRUE}
        GraphicsMode R10                ; if not a graphics mode then give up now!
        BNE     %FT20
      |
        LDR     R10, [WsPtr, #NPix]     ; if not a graphics mode then
        CMP     R10, #0                 ; indicate off screen
        BEQ     %FT20
      ]

        Push    "R0-R9, R14"            ; save registers

        ADD     R7, WsPtr, #GCsX
        LDMIA   R7, {R8,R9}             ; preserve GCsX,GCsY around EIG
        MOV     R2, #4                  ; absolute coord
        BL      EIG
        STMIA   R7, {R8,R9}             ; restore GcsX,GCsY

        WINDow  R0,R1, R2,R3,R4,R5
        BLT     %FT10                   ; outside window

        Push    "R0,R1"                 ; save internal coords
        BL      PreWrchCursor           ; remove any split cursors etc
        Pull    "R0,R1"
                                        ;     R0,R1,R2 ,R3 ,R4 ,R5 ,R6 ,R7 ,R8
        BL      ScreenAddr              ; in :X ,Y
                                        ; out:X ,Y ,Adr,Msk,   ,   ,   ,crp,crp
        LDR     R8, [WsPtr, #NColour]

;amg - changes here to cope with 16/32bpp which will also return an NCOL with b4-b7 set

;        TST     R8, #&F0                ; if NColour=63
;        MOVNE   R8, #&FF                ; then use 255

        CMP     R8,#63
        MOVEQ   R8,#255

        LDR     R9, [WsPtr, #XShftFactor]
        LDR     R10, [WsPtr, #NPix]
        LDR     R11, [WsPtr, #Log2BPC]

        BitLOffset R7,R0, R9,R10,R11    ; R7 := bit position to align to

        LDR     R0, [R2]
        AND     R0, R8, R0, LSR R7      ; extract one pixel

        TEQ     R8,#255
        MOVNE   R2,R0
        MOVNE   R3,#0
        BLEQ    ExtractTintAndColour

;        TST     R8, #&F0                ; if not a 256 colour mode
;        MOVEQ   R2, R0                  ; colour = pixel
;        MOVEQ   R3, #0                  ; tint   = 0
;        BLNE    ExtractTintAndColour    ; else extract colour & tint from pixel

        MOV     R4, #0                  ; indicate on screen

        ADD     R0, R13, #2*4           ; point to stacked R2
        STMIA   R0, {R2-R4}

        BL      PostWrchCursor

        Pull    "R0-R9, R14"            ; restore R0-R9 & return address
        BIC     R14, R14, #V_bit
        ExitSWIHandler

10
        Pull    "R0-R9, R14"            ; restore R0-R9 & return address
20
        MOV     R2, #-1
        MOV     R3, #0
        MOV     R4, #-1

        BIC     R14, R14, #V_bit
        ExitSWIHandler

; *****************************************************************************
;
;       GenCircleParm - Generate a control block for a circle
;
;       Internal routine, called by CircleOutline, CircleFill, GenArcParmBlk
;
; in:   R0 (X), R1(Y) centre of circle
;       R2 (X), R3(Y) point on circumference
;
; out:  R0-R7 hold the following control block
;         R0 - xPnt   (CurrentX - relative to centre)
;         R1 - yPnt   (CurrentY - relative to centre)
;         R2 - sum (Bres)
;         R3 - upcnt
;         R4 - downcnt
;         R5 - CentreX
;         R6 - CentreY
;         R7 - Aspect (pixel shape : 0 square, 1 horz rect, 2 vert rect)
;       R8-R11 undefined
;
GenCircleParm
        Push    R14
        LDR     R11, [WsPtr, #AspectRatio]
        SUB     R7, R2, R0
        TST     R11, #1                 ; if pixels are horz rects, adjust
        MOVNE   R7, R7, LSL #1          ; x distance
        MUL     R2, R7, R7              ; R2 = (x-cx)^2

        SUB     R7, R3, R1
        TST     R11, #2                 ; if pixels are vert rects, adjust
        MOVNE   R7, R7, LSL #1          ; y distance

        MLA     R2, R7, R7, R2          ; rawradsqr=(x-cx)^2 + (y-cy)^2
        MOV     R7, R2
        BL      SquareRoot

        ADD     R2, R2, R8              ; radsqr=rawradsqr+rawrad
        STR     R2, [WsPtr, #CircleRadSquare]   ; needed in seg. line calc

        MOV     R7, R2
        BL      SquareRoot
        MOV     R4, R8                  ; R4=rad, R2=radsqr

;
; Now build the parameter block proper
;
;  R0 = CentreX, R1 = CentreY, R2 = radsqr, R4 = rad
;
        MUL     R9, R4, R4              ; R9=rad*rad
        SUB     R2, R2, R9              ; Sum=radsqu-rad*rad

        MOV     R5, R0                  ; CentreX
        MOV     R6, R1                  ; CentreY

        MOV     R0, R4                  ; xPnt starts at rad

        ADD     R4, R4, R4
        SUB     R4, R4, #1              ; downcnt = 2*rad-1

        MOV     R1, #0                  ; yPnt starts at 0
        MOV     R3, #1                  ; upcnt = 1

        LDR     R7, [WsPtr,#AspectRatio] ; taking account of pixel shape
        LDR     R11, [WsPtr, #CursorFlags]
        TST     R11, #ClipBoxEnableBit
        BLNE    ClipCircle

        CMP     R7, #1

        MOVEQ   R0, R0, ASR #1          ; if horz pixel (ie like mode2)
        ADDEQ   R2, R2, R4
        SUBEQ   R4, R4, #2

        SUBGT   R2, R2, R3              ; if vert pixel (ie like mode0)
        ADDGT   R3, R3, #2

        Pull    PC

; *****************************************************************************
;
;       AdvCircleParm - Advance a set of circle parameters
;
;       Internal routine, called by CircleOutline, CircleFill, CircleArc,
;        SegmentFill, SectorFill
;
; in:   R0..R7 hold a circle parameter block
;
; out:  R0 (X), R1 (Y) updated
;       C=1 <=> R1 (Y) has changed
;       Z preserved
;
;       Format of a control block
;         R0 - xPnt   (CurrentX - relative to centre)
;         R1 - yPnt   (CurrentY - relative to centre)
;         R2 - sum (Bres)
;         R3 - upcnt
;         R4 - downcnt
;         R5 - CentreX
;         R6 - CentreY
;         R7 - Aspect (pixel shape : 0 square, 1 horz rect, 2 vert rect)
;

AdvCircleParm ROUT
        CMP     R2, R3                  ; if sum >= upcnt advance Y only
        BGE     %FT10

        SUB     R0, R0, #1              ; else step xPnt inward one point

        ADD     R2, R2, R4              ; Sum := Sum + DownCnt
        SUB     R4, R4, #2              ; DownCnt = next lower odd number

        TST     R7, #1                  ; if pixels are horizontal rectangles
        ADDNE   R2, R2, R4              ; modify sum again, so x steps at
        SUBNE   R4, R4, #2              ; half normal rate

        CMP     R2, R3
        BGE     %FT10
        CLC                             ; if not doing Y, indicate with C=0
        MOV     PC, R14
10
                                        ; if sum >= upcnt then advance Y
        ADD     R1, R1, #1              ; step yPnt up a line

        SUB     R2, R2, R3              ; Sum := Sum - UpCnt
        ADD     R3, R3, #2              ; UpCnt = next higher odd number

        TST     R7, #2                  ; if pixels are vertical rectangles
        SUBNE   R2, R2, R3              ; modify sum again, so y steps
        ADDNE   R3, R3, #2              ; at half normal rate

        SEC                             ; Y modified, so return C=1
        MOV     PC, R14

; *****************************************************************************
;
;       SquareRoot - Calculate the square root of a 32-bit number
;
;       Internal routine, called by GenSegParmBlk, GenCircleParm
;
;       SquareRootAlt is a alternative routine which specifies the precision
;        of the result in R11 (SquareRoot produces a 16-bit result)
;
; in:   R7 = number to squareroot
;
; out:  R8 = result
;       R9-R11 corrupted
;         R9 temp
;         R10 sqdiff
;         R11 counter
;

SquareRoot ROUT
        MOV     R11, #16                ; 16 bit result
SquareRootAlt
        MOV     R8, #0                  ; result=0
        MOV     R10, #0                 ; sqdiff=0
10

; *****Change made by DJS
; Original code was:
;        ADDS    R7, R7, R7              ; (sqdiff,number) = (sqdiff,number)*4
;        ADC     R10, R10, R10
;        ADDS    R7, R7, R7
;        ADCS    R10, R10, R10           ; (C:=0 we hope!)

        MOVS    R10, R10, LSL #2        ; C:=0 (we hope!) while doing (sqdiff,
        ORR     R10, R10, R7, LSR #30   ;   number) := (sqdiff, number) * 4
        MOV     R7, R7, LSL #2

; *****End of change made by DJS

        SBCS    R9, R10, R8, LSL #2     ; C=0 here, so try to subtract
                                        ; result*4 +1 from sqdiff
        MOVCS   R10, R9                 ; if successful then shift in a "1" bit
        ADC     R8, R8, R8              ; else shift in a "0" bit
        SUBS    R11, R11, #1            ; decrement loop counter
        BNE     %BT10

        MOV     PC, R14

; *****************************************************************************
;
;       DoOsWord13 - Read graphics cursors (in external coords)
;
; in:   R1 -> control block
;
; out:  [R1+0..1] = old cursor X
;       [R1+2..3] = old cursor Y
;       [R1+4..5] = current cursor X
;       [R1+6..7] = current cursor Y
;
        ASSERT  OldCsY = OldCsX +4
        ASSERT  YEigFactor = XEigFactor +4
        ASSERT  OrgY = OrgX +4
        ASSERT  GCsY = GCsX +4

DoOsWord13 ROUT
        Push    "R0-R6"
        MOV     R6, R1                  ; pointer to control block

        ADD     R0, WsPtr, #OldCsX
        LDMIA   R0, {R0, R1}
        ADD     R2, WsPtr, #XEigFactor
        LDMIA   R2, {R2, R3}            ; R2 = XEigFactor; R3 = YEigFactor
        ADD     R4, WsPtr, #OrgX
        LDMIA   R4, {R4, R5}            ; R4 = OrgX; R5 = OrgY
        RSB     R0, R4, R0, LSL R2      ; R0 = (X << XEigFactor)-OrgX
        RSB     R1, R5, R1, LSL R3      ; R1 = (Y << YEigFactor)-OrgY

      [ NoARMv6 :LOR: NoUnaligned
        STRB    R0, [R6], #1
        MOV     R0, R0, LSR #8
        STRB    R0, [R6], #1
        STRB    R1, [R6], #1
        MOV     R1, R1, LSR #8
        STRB    R1, [R6], #1
      |
        ; Use unaligned halfword stores available from ARMv6
        STRH    R0, [R6], #2
        STRH    R1, [R6], #2
      ]

        ADD     R0, WsPtr, #GCsX
        LDMIA   R0, {R0, R1}            ; get current cursor

      [ NoARMv6 :LOR: NoUnaligned
        STRB    R0, [R6], #1
        MOV     R0, R0, LSR #8
        STRB    R0, [R6], #1
        STRB    R1, [R6], #1
        MOV     R1, R1, LSR #8
        STRB    R1, [R6], #1
      |
        ; Use unaligned halfword stores available from ARMv6
        STRH    R0, [R6], #2
        STRH    R1, [R6]
      ]

        Pull    "R0-R6"
        MOV     PC, R14

        LTORG
        END
@


4.4
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@d684 28
d725 3
a727 1
        LDR     R0, [WsPtr, #ECFIndex]
d738 1
a738 1
DefEcfTb        ; Table of default ECFs, indexed by ECFIndex (a mode variable)
d740 1
a740 1
; Modes 3,6,7
d746 1
a746 1
; Mode 0
d752 1
a752 1
; Modes 1,5,8,11,19
d758 1
a758 1
; Modes 2,9,12,14,16,17,20(,21)
d764 1
a764 1
; Modes 4,18,22,23
d770 1
a770 1
; Modes 10,13,15
d795 4
a798 2
        LDR     R4, [WsPtr, #ECFIndex]
        LDRB    R10, [R3, R4]           ; Mask for this mode
d884 1
a885 1
        ADRCS   R3, Invert              ; if 2 or 3
@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a125 1
 [ No26bitCode
a126 3
 |
        ADR     R14, CTidy + SVC_mode   ; set up return address
 ]
a352 1
 [ No26bitCode
a353 3
 |
        MOVS PC,R14
 ]
a380 1
 [ No26bitCode
a381 3
 |
        MOVS PC,R14
 ]
a425 1
 [ No26bitCode
a426 3
 |
        MOVS PC,R14                     ;Return to whence we came
 ]
a457 1
 [ No26bitCode
a458 3
 |
        MOVS    PC, R14                         ; and return
 ]
a648 1
 [ No26bitCode
a649 1
 ]
a657 1
 [ No26bitCode
a659 3
 |
        MOVS    PC, R14
 ]
a674 1
 [ No26bitCode
a675 1
 ]
a680 1
 [ No26bitCode
a682 3
 |
        MOVS    PC, R14
 ]
a891 1
 [ No26bitCode
a892 3
 |
        MOVLTS  PC, R14                 ; Quit if above,below,left or right
 ]
a1027 1
 [ No26bitCode
a1028 3
 |
        Pull    "R0-R3,R11,PC",,^       ; pretty certain flag preservation not required
 ]
a1073 1
 [ No26bitCode
a1074 3
 |
        Pull    "R0-R3,R11,PC",,^
 ]
a1097 1
 [ No26bitCode
a1099 4
 |
        MOVLTS  PC, R14                 ; Quit if above,below,left or right
                                        ; of window
 ]
a1157 1
 [ No26bitCode
a1158 3
 |
        Pull    "R0-R3,R11,PC",,^
 ]
a1164 1
 [ No26bitCode
a1165 3
 |
        Pull    "R0-R3,R11,PC",,^
 ]
a1427 1
 [ No26bitCode
a1430 3
 |
        BICLTS  PC, R14, #C_bit         ; if not doing Y, indicate with C=0
 ]
a1441 1
 [ No26bitCode
a1443 3
 |
        ORRS    PC, R14, #C_bit         ; Y modified, so return C=1
 ]
a1489 1
 [ No26bitCode
a1490 3
 |
        MOVS    PC, R14
 ]
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d125 4
d130 1
d132 1
a132 2
        ADD     PC, PC, R2, LSR #1      ; jump to branch (bottom 2 bits of the
                                        ; result are ignored!)
d542 6
a547 1
        LDR     R7, [R2, R8, LSL #2]!           ;
d550 1
a550 1
        STR     R7, [R2]
d670 1
a670 1
        mrs    ,R3, CPSR
d681 1
a681 1
        msr    ,CPSR_f, R3
d702 1
a702 1
        mrs    ,R3, CPSR
d710 1
a710 1
        msr    ,CPSR_f, R3
d1004 5
d1011 1
d1036 1
a1036 1
        [       (. :AND: 15) = 12
d1053 1
a1053 1
        STMNEIA R9!, {R0}               ; write 1 word to screen
d1055 4
d1060 1
d1063 1
a1063 1

d1192 5
d1213 11
d1590 1
d1597 5
d1606 1
d1613 5
@


4.2.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d661 1
a661 1
        MRS     R3, CPSR
d672 1
a672 1
        MSR     CPSR_f, R3
d693 1
a693 1
        MRS     R3, CPSR
d701 1
a701 1
        MSR     CPSR_f, R3
d1021 1
a1021 1
        [       ((.-KernelBase) :AND: 15) = 12
@


4.2.2.2
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a124 3
 [ No26bitCode
        ADR     R14, CTidy              ; set up return address
 |
a125 1
 ]
d538 1
a538 6
 [ AvoidScreenReads
        CMP     R5, #&FFFFFFFF
        LDRNE   R7, [R2, R8, LSL #2]
 |
        LDR     R7, [R2, R8, LSL #2]
 ]
d541 1
a541 1
        STR     R7, [R2, R8, LSL #2]
a994 5
 [ AvoidScreenReads
        AND     R1, R8, R6              ; zgora AND left mask
        CMP     R1, #&FFFFFFFF
        LDRNE   R0, [R9]                ; do left hand word of line
 |
a996 1
 ]
a1039 4
 [ AvoidScreenReads
        CMP     R14, #&FFFFFFFF
        LDRNE   R0, [R9]
 |
a1040 1
 ]
d1043 1
a1043 1
70
a1171 5
 [ AvoidScreenReads
        CMP     R8, #&FFFFFFFF
        BEQ     %FT20
 ]

a1187 11
 [ AvoidScreenReads
20      MVN     R6, R10
25      STR     R6, [R9], R11
        SUBS    R1, R1, #1
        BPL     %BT25
 [ No26bitCode
        Pull    "R0-R3,R11,PC"
 |
        Pull    "R0-R3,R11,PC",,^
 ]
 ]
@


4.2.2.3
log
@Huge update to L7200 HAL for Customer M 2 demo - now runs with 5.02 Kernel
used in Tungsten.
Added "fast" flash tool for Customer L, allowing ROMs to be sent serially at
115200 baud not 9600 baud.
Fix to VDU despatch for ARMv4 and later.
Fixes to power on delete keyboard and keyboard timeout
Implemented MemoryReadPhys and MemoryAmounts with the HAL.

Version 5.35, 4.79.2.59. Tagged as 'Kernel-5_35-4_79_2_59'
@
text
@a124 1
	BIC	R11, R2, #2_111		; ARMv4 says we have to keep bits 1:0 of PC =0
d131 2
a132 1
        ADD     PC, PC, R11, LSR #1     ; jump to branch
@


4.2.2.4
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d1053 1
a1053 1
        STRNE   R0, [R9], #4            ; write 1 word to screen
a1589 1
      [ NoARMv6 :LOR: NoUnaligned
a1595 5
      |
        ; Use unaligned halfword stores available from ARMv6
        STRH    R0, [R6], #2
        STRH    R1, [R6], #2
      ]
a1599 1
      [ NoARMv6 :LOR: NoUnaligned
a1605 5
      |
        ; Use unaligned halfword stores available from ARMv6
        STRH    R0, [R6], #2
        STRH    R1, [R6]
      ]
@


4.2.2.5
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d125 1
a125 1
        BIC     R11, R2, #2_111         ; ARMv4 says we have to keep bits 1:0 of PC =0
@


4.2.2.3.2.1
log
@  Unaligned loads/stores optimised for ARMv6+
Detail:
  Having scanned the kernel source for unaligned load code fragments which
  would abort on ARMv6 and v7 and not having found any, I took the opportunity
  to give them build-time switches to use unaligned LDR((S)H)/STR(H)
  instructions if built for a new enough platform. Also added a couple of
  cases of LDRSB that will benefit v4 CPUs and a few instances of the v6
  SXTH instruction, but since objasm doesn't yet understand it (and when it
  does, not everyone will have upgraded) they are currently written as
  DCI statements.
  Most of the changes are to OS_Word handlers, which are notorious in that
  their input/output block is not word-aligned.
Admin:
  Not tested, but it should at least build.

Version 5.35, 4.79.2.98.2.6. Tagged as 'Kernel-5_35-4_79_2_98_2_6'
@
text
@a1589 1
      [ NoARMv6
a1595 5
      |
        ; Use unaligned halfword stores available from ARMv6
        STRH    R0, [R6], #2
        STRH    R1, [R6], #2
      ]
a1599 1
      [ NoARMv6
a1605 5
      |
        ; Use unaligned halfword stores available from ARMv6
        STRH    R0, [R6], #2
        STRH    R1, [R6]
      ]
@


4.2.2.3.2.2
log
@  Miscellaneous v6-related updates
Detail:
 * Stopped calling the broken abort fixup code when running under VMSAv6.
   Might be desirable to update it, possibly farmed out to a separate module -
   still need to think about this.
 * Unaligned load optimisations can now be disabled by the global NoUnaligned
   flag for testing purposes.
 * Extended OS_ReadUnsigned to permit reading of 64-bit unsigned integers.
   See Docs.ReadUnsigned for more details. Also sped it up by using MLA
   (or UMLAL) for most digits rather than repeated addition.
 * Bugfix is OS_GSRead: an uninitialised r0 was being passed to
   OS_ReadUnsigned, causing undesirable effects on rare occasions.
Admin:
  Tested on a rev B7 beagleboard.

Version 5.35, 4.79.2.98.2.8. Tagged as 'Kernel-5_35-4_79_2_98_2_8'
@
text
@d1590 1
a1590 1
      [ NoARMv6 :LOR: NoUnaligned
d1606 1
a1606 1
      [ NoARMv6 :LOR: NoUnaligned
@


4.2.2.3.2.3
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d1053 1
a1053 1
        STRNE   R0, [R9], #4            ; write 1 word to screen
@


4.1
log
@Initial revision
@
text
@d54 1
a54 1
      ]       
d205 1
a205 1
;   
d353 3
d357 1
d385 3
d389 1
d434 3
d438 1
d470 3
d474 1
d489 1
a489 1
        MOVLTS  PC, R14                         ; If outside window, give up
d511 1
a511 1
;        
d530 1
a530 1
        
d587 1
a587 1
;      R8 - bit mask from InterleaveTB(BitsPerPix,R5) 
d644 1
a644 1
        MOVS    PC, R14
d655 1
a655 1
; out:  Can corrupt R0-R3, 
d660 4
d671 4
d676 1
d692 3
d696 1
a696 1
        BEQ     DefaultLineStyle
d700 4
d705 1
d723 1
a723 1
        ADD     R1, WsPtr, #Ecf1      
d808 1
a808 1
        STRB    R6, [R1, #4]            ; Replicate pattern in both halves 
d915 3
d919 1
d1044 5
a1048 1
        Pull    "R0-R3,R11,PC",,^
d1094 3
d1098 1
d1122 4
d1128 1
d1155 1
a1155 1
        SUB     R3, R10, R3             ; R3 = flipped top ycoord 
d1182 3
d1186 1
d1231 1
a1231 1
        AND     R2, R0, #&84            ; R2 := B3  0  0  0  0 R2  0  0 
d1234 1
a1234 1
        AND     R0, R0, #&70            ; R0 :=  0 G3 G2 R3  0  0  0  0 
d1237 1
a1237 1
        MOVS    PC, R14
d1254 1
a1254 1
        TEQP    PC, #SVC_mode           ; re-enable interrupts
d1264 1
a1264 1
      ]       
d1292 1
a1292 1
        
d1338 1
a1338 1
; 
d1449 5
d1455 1
d1467 4
d1472 1
d1519 3
d1523 1
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d47 1
d50 5
d224 42
d383 46
d1203 1
d1206 5
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

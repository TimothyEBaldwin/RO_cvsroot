head	4.6;
access;
symbols
	Kernel-6_15:4.6
	Kernel-6_14:4.6
	Kernel-6_01-3:4.6
	Kernel-6_13:4.6
	Kernel-6_12:4.6
	Kernel-6_11:4.6
	Kernel-6_10:4.6
	Kernel-6_09:4.6
	Kernel-6_08-4_129_2_10:4.5.2.1
	Kernel-6_08-4_129_2_9:4.5.2.1
	Kernel-6_08:4.6
	Kernel-6_07:4.6
	Kernel-6_06:4.6
	Kernel-6_05-4_129_2_8:4.5.2.1
	Kernel-6_05:4.6
	Kernel-6_04:4.6
	Kernel-6_03:4.6
	Kernel-6_01-2:4.6
	Kernel-6_01-4_146_2_1:4.6
	Kernel-6_02:4.6
	Kernel-6_01-1:4.6
	Kernel-6_01:4.6
	Kernel-6_00:4.6
	Kernel-5_99:4.6
	Kernel-5_98:4.6
	Kernel-5_97-4_129_2_7:4.5.2.1
	Kernel-5_97:4.6
	Kernel-5_96:4.6
	Kernel-5_95:4.6
	Kernel-5_94:4.6
	Kernel-5_93:4.5
	Kernel-5_92:4.5
	Kernel-5_91:4.5
	Kernel-5_90:4.5
	Kernel-5_89-4_129_2_6:4.5
	Kernel-5_89:4.5
	Kernel-5_88-4_129_2_5:4.5
	Kernel-5_88-4_129_2_4:4.5
	Kernel-5_88:4.5
	Kernel-5_87:4.5
	Kernel-5_86-4_129_2_3:4.5
	Kernel-5_86-4_129_2_2:4.5
	Kernel-5_86-4_129_2_1:4.5
	Kernel-5_86:4.5
	SMP:4.5.0.2
	SMP_bp:4.5
	Kernel-5_85:4.5
	Kernel-5_54-1:4.3
	Kernel-5_84:4.5
	Kernel-5_83:4.5
	Kernel-5_82:4.5
	Kernel-5_81:4.5
	Kernel-5_80:4.5
	Kernel-5_79:4.5
	Kernel-5_78:4.5
	Kernel-5_77:4.5
	Kernel-5_76:4.5
	Kernel-5_75:4.5
	Kernel-5_74:4.4
	Kernel-5_73:4.3
	Kernel-5_72:4.3
	Kernel-5_71:4.3
	Kernel-5_70:4.3
	Kernel-5_69:4.3
	Kernel-5_68:4.3
	Kernel-5_67:4.3
	Kernel-5_66:4.3
	Kernel-5_65:4.3
	Kernel-5_64:4.3
	Kernel-5_63:4.3
	Kernel-5_62:4.3
	Kernel-5_61:4.3
	Kernel-5_60:4.3
	Kernel-5_59:4.3
	Kernel-5_58:4.3
	Kernel-5_57:4.3
	Kernel-5_56:4.3
	Kernel-5_55:4.3
	Kernel-5_54:4.3
	Kernel-5_53:4.3
	Kernel-5_52:4.3
	Kernel-5_51:4.3
	Kernel-5_50:4.3
	Kernel-5_49:4.3
	HAL_merge:4.2.2.4
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.4
	Kernel-5_35-4_79_2_326:4.2.2.4
	Kernel-5_35-4_79_2_325:4.2.2.3
	Kernel-5_35-4_79_2_324:4.2.2.3
	Kernel-5_35-4_79_2_323:4.2.2.3
	Kernel-5_35-4_79_2_322:4.2.2.3
	Kernel-5_35-4_79_2_321:4.2.2.3
	Kernel-5_35-4_79_2_320:4.2.2.3
	Kernel-5_35-4_79_2_319:4.2.2.3
	Kernel-5_35-4_79_2_318:4.2.2.3
	Kernel-5_35-4_79_2_317:4.2.2.3
	Kernel-5_35-4_79_2_316:4.2.2.3
	Kernel-5_35-4_79_2_315:4.2.2.3
	Kernel-5_35-4_79_2_314:4.2.2.3
	Kernel-5_35-4_79_2_313:4.2.2.3
	Kernel-5_35-4_79_2_312:4.2.2.3
	Kernel-5_35-4_79_2_311:4.2.2.3
	Kernel-5_35-4_79_2_310:4.2.2.3
	Kernel-5_35-4_79_2_309:4.2.2.3
	Kernel-5_35-4_79_2_308:4.2.2.3
	Kernel-5_35-4_79_2_307:4.2.2.3
	Kernel-5_35-4_79_2_306:4.2.2.3
	Kernel-5_35-4_79_2_305:4.2.2.3
	Kernel-5_35-4_79_2_304:4.2.2.3
	Kernel-5_35-4_79_2_303:4.2.2.3
	Kernel-5_35-4_79_2_302:4.2.2.3
	Kernel-5_35-4_79_2_301:4.2.2.3
	Kernel-5_35-4_79_2_300:4.2.2.3
	Kernel-5_35-4_79_2_299:4.2.2.3
	Kernel-5_35-4_79_2_298:4.2.2.3
	Kernel-5_35-4_79_2_297:4.2.2.3
	Kernel-5_35-4_79_2_296:4.2.2.3
	Kernel-5_35-4_79_2_295:4.2.2.3
	Kernel-5_35-4_79_2_294:4.2.2.3
	Kernel-5_35-4_79_2_293:4.2.2.3
	Kernel-5_35-4_79_2_292:4.2.2.3
	Kernel-5_35-4_79_2_291:4.2.2.3
	Kernel-5_35-4_79_2_290:4.2.2.3
	Kernel-5_35-4_79_2_289:4.2.2.3
	Kernel-5_35-4_79_2_288:4.2.2.3
	Kernel-5_35-4_79_2_287:4.2.2.3
	Kernel-5_35-4_79_2_286:4.2.2.3
	Kernel-5_35-4_79_2_285:4.2.2.3
	Kernel-5_35-4_79_2_284:4.2.2.3
	Kernel-5_35-4_79_2_283:4.2.2.3
	Kernel-5_35-4_79_2_282:4.2.2.3
	Kernel-5_35-4_79_2_281:4.2.2.3
	Kernel-5_35-4_79_2_280:4.2.2.3
	Kernel-5_35-4_79_2_279:4.2.2.3
	Kernel-5_35-4_79_2_278:4.2.2.3
	Kernel-5_35-4_79_2_277:4.2.2.3
	Kernel-5_35-4_79_2_276:4.2.2.3
	Kernel-5_35-4_79_2_275:4.2.2.3
	Kernel-5_35-4_79_2_274:4.2.2.3
	Kernel-5_35-4_79_2_273:4.2.2.3
	Kernel-5_35-4_79_2_272:4.2.2.3
	Kernel-5_35-4_79_2_271:4.2.2.3
	Kernel-5_35-4_79_2_270:4.2.2.3
	Kernel-5_35-4_79_2_269:4.2.2.3
	Kernel-5_35-4_79_2_268:4.2.2.3
	Kernel-5_35-4_79_2_267:4.2.2.3
	Kernel-5_35-4_79_2_266:4.2.2.3
	Kernel-5_35-4_79_2_265:4.2.2.3
	Kernel-5_35-4_79_2_264:4.2.2.3
	Kernel-5_35-4_79_2_263:4.2.2.3
	Kernel-5_35-4_79_2_262:4.2.2.3
	Kernel-5_35-4_79_2_261:4.2.2.3
	Kernel-5_35-4_79_2_260:4.2.2.3
	Kernel-5_35-4_79_2_259:4.2.2.3
	Kernel-5_35-4_79_2_258:4.2.2.3
	Kernel-5_35-4_79_2_257:4.2.2.3
	Kernel-5_35-4_79_2_256:4.2.2.3
	Kernel-5_35-4_79_2_255:4.2.2.3
	Kernel-5_35-4_79_2_254:4.2.2.3
	Kernel-5_35-4_79_2_253:4.2.2.3
	Kernel-5_35-4_79_2_252:4.2.2.3
	Kernel-5_35-4_79_2_251:4.2.2.3
	Kernel-5_35-4_79_2_250:4.2.2.3
	Kernel-5_35-4_79_2_249:4.2.2.3
	Kernel-5_35-4_79_2_248:4.2.2.3
	Kernel-5_35-4_79_2_247:4.2.2.3
	Kernel-5_35-4_79_2_246:4.2.2.3
	Kernel-5_35-4_79_2_245:4.2.2.3
	Kernel-5_35-4_79_2_244:4.2.2.3
	Kernel-5_35-4_79_2_243:4.2.2.3
	Kernel-5_35-4_79_2_242:4.2.2.3
	Kernel-5_35-4_79_2_241:4.2.2.3
	Kernel-5_35-4_79_2_240:4.2.2.3
	Kernel-5_35-4_79_2_239:4.2.2.3
	Kernel-5_35-4_79_2_238:4.2.2.3
	Kernel-5_35-4_79_2_237:4.2.2.3
	Kernel-5_35-4_79_2_236:4.2.2.3
	Kernel-5_35-4_79_2_235:4.2.2.3
	Kernel-5_35-4_79_2_234:4.2.2.3
	Kernel-5_35-4_79_2_233:4.2.2.3
	Kernel-5_35-4_79_2_232:4.2.2.3
	Kernel-5_35-4_79_2_231:4.2.2.3
	Kernel-5_35-4_79_2_230:4.2.2.3
	Kernel-5_35-4_79_2_229:4.2.2.3
	Kernel-5_35-4_79_2_228:4.2.2.3
	Kernel-5_35-4_79_2_227:4.2.2.3
	Kernel-5_35-4_79_2_226:4.2.2.3
	Kernel-5_35-4_79_2_225:4.2.2.3
	Kernel-5_35-4_79_2_224:4.2.2.3
	Kernel-5_35-4_79_2_223:4.2.2.3
	Kernel-5_35-4_79_2_222:4.2.2.3
	Kernel-5_35-4_79_2_221:4.2.2.3
	Kernel-5_35-4_79_2_220:4.2.2.3
	Kernel-5_35-4_79_2_219:4.2.2.3
	Kernel-5_35-4_79_2_218:4.2.2.3
	Kernel-5_35-4_79_2_217:4.2.2.3
	Kernel-5_35-4_79_2_216:4.2.2.3
	Kernel-5_35-4_79_2_215:4.2.2.3
	Kernel-5_35-4_79_2_214:4.2.2.3
	Kernel-5_35-4_79_2_213:4.2.2.3
	Kernel-5_35-4_79_2_212:4.2.2.3
	Kernel-5_35-4_79_2_211:4.2.2.3
	Kernel-5_35-4_79_2_210:4.2.2.3
	Kernel-5_35-4_79_2_209:4.2.2.3
	Kernel-5_35-4_79_2_208:4.2.2.3
	Kernel-5_35-4_79_2_207:4.2.2.3
	Kernel-5_35-4_79_2_206:4.2.2.3
	Kernel-5_35-4_79_2_205:4.2.2.3
	Kernel-5_35-4_79_2_204:4.2.2.3
	Kernel-5_35-4_79_2_203:4.2.2.3
	Kernel-5_35-4_79_2_202:4.2.2.3
	Kernel-5_35-4_79_2_201:4.2.2.3
	Kernel-5_35-4_79_2_200:4.2.2.3
	Kernel-5_35-4_79_2_199:4.2.2.3
	Kernel-5_35-4_79_2_198:4.2.2.3
	Kernel-5_35-4_79_2_197:4.2.2.3
	Kernel-5_35-4_79_2_196:4.2.2.3
	Kernel-5_35-4_79_2_195:4.2.2.3
	Kernel-5_35-4_79_2_194:4.2.2.3
	Kernel-5_35-4_79_2_193:4.2.2.3
	Kernel-5_35-4_79_2_192:4.2.2.3
	Kernel-5_35-4_79_2_191:4.2.2.3
	Kernel-5_35-4_79_2_190:4.2.2.3
	Kernel-5_35-4_79_2_189:4.2.2.3
	Kernel-5_35-4_79_2_188:4.2.2.3
	Kernel-5_35-4_79_2_187:4.2.2.3
	Kernel-5_35-4_79_2_186:4.2.2.3
	Kernel-5_35-4_79_2_185:4.2.2.3
	Kernel-5_35-4_79_2_184:4.2.2.3
	Kernel-5_35-4_79_2_183:4.2.2.3
	Kernel-5_35-4_79_2_182:4.2.2.3
	Kernel-5_35-4_79_2_181:4.2.2.3
	Kernel-5_35-4_79_2_180:4.2.2.3
	Kernel-5_35-4_79_2_179:4.2.2.3
	Kernel-5_35-4_79_2_178:4.2.2.3
	Kernel-5_35-4_79_2_177:4.2.2.3
	Kernel-5_35-4_79_2_176:4.2.2.3
	Kernel-5_35-4_79_2_175:4.2.2.3
	Kernel-5_35-4_79_2_174:4.2.2.3
	Kernel-5_35-4_79_2_173:4.2.2.3
	Kernel-5_35-4_79_2_172:4.2.2.3
	Kernel-5_35-4_79_2_171:4.2.2.3
	Kernel-5_35-4_79_2_170:4.2.2.3
	Kernel-5_35-4_79_2_169:4.2.2.3
	Kernel-5_35-4_79_2_168:4.2.2.3
	Kernel-5_35-4_79_2_167:4.2.2.3
	Kernel-5_35-4_79_2_166:4.2.2.3
	Kernel-5_35-4_79_2_165:4.2.2.3
	RPi_merge:4.2.2.3
	Kernel-5_35-4_79_2_147_2_23:4.2.2.3
	Kernel-5_35-4_79_2_147_2_22:4.2.2.3
	Kernel-5_35-4_79_2_147_2_21:4.2.2.3
	Kernel-5_35-4_79_2_147_2_20:4.2.2.3
	Kernel-5_35-4_79_2_147_2_19:4.2.2.3
	Kernel-5_35-4_79_2_147_2_18:4.2.2.3
	Kernel-5_35-4_79_2_164:4.2.2.3
	Kernel-5_35-4_79_2_163:4.2.2.3
	Kernel-5_35-4_79_2_147_2_17:4.2.2.3
	Kernel-5_35-4_79_2_147_2_16:4.2.2.3
	Kernel-5_35-4_79_2_147_2_15:4.2.2.3
	Kernel-5_35-4_79_2_162:4.2.2.3
	Kernel-5_35-4_79_2_161:4.2.2.3
	Kernel-5_35-4_79_2_147_2_14:4.2.2.3
	Kernel-5_35-4_79_2_147_2_13:4.2.2.3
	Kernel-5_35-4_79_2_160:4.2.2.3
	Kernel-5_35-4_79_2_159:4.2.2.3
	Kernel-5_35-4_79_2_158:4.2.2.3
	Kernel-5_35-4_79_2_157:4.2.2.3
	Kernel-5_35-4_79_2_156:4.2.2.3
	Kernel-5_35-4_79_2_147_2_12:4.2.2.3
	Kernel-5_35-4_79_2_147_2_11:4.2.2.3
	Kernel-5_35-4_79_2_155:4.2.2.3
	Kernel-5_35-4_79_2_147_2_10:4.2.2.3
	Kernel-5_35-4_79_2_154:4.2.2.3
	Kernel-5_35-4_79_2_153:4.2.2.3
	Kernel-5_35-4_79_2_147_2_9:4.2.2.3
	Kernel-5_35-4_79_2_152:4.2.2.3
	Kernel-5_35-4_79_2_151:4.2.2.3
	Kernel-5_35-4_79_2_147_2_8:4.2.2.3
	Kernel-5_35-4_79_2_147_2_7:4.2.2.3
	Kernel-5_35-4_79_2_150:4.2.2.3
	Kernel-5_35-4_79_2_147_2_6:4.2.2.3
	Kernel-5_35-4_79_2_147_2_5:4.2.2.3
	Kernel-5_35-4_79_2_149:4.2.2.3
	Kernel-5_35-4_79_2_147_2_4:4.2.2.3
	Kernel-5_35-4_79_2_147_2_3:4.2.2.3
	Kernel-5_35-4_79_2_148:4.2.2.3
	Kernel-5_35-4_79_2_147_2_2:4.2.2.3
	Kernel-5_35-4_79_2_147_2_1:4.2.2.3
	RPi:4.2.2.3.0.6
	RPi_bp:4.2.2.3
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2.2.3
	alees_Kernel_dev:4.2.2.3.0.4
	alees_Kernel_dev_bp:4.2.2.3
	Kernel-5_35-4_79_2_147:4.2.2.3
	Kernel-5_35-4_79_2_146:4.2.2.3
	Kernel-5_35-4_79_2_145:4.2.2.3
	Kernel-5_35-4_79_2_144:4.2.2.3
	Kernel-5_35-4_79_2_143:4.2.2.3
	Kernel-5_35-4_79_2_142:4.2.2.3
	Kernel-5_35-4_79_2_141:4.2.2.3
	Kernel-5_35-4_79_2_140:4.2.2.3
	Kernel-5_35-4_79_2_139:4.2.2.3
	Kernel-5_35-4_79_2_138:4.2.2.3
	Kernel-5_35-4_79_2_137:4.2.2.3
	Kernel-5_35-4_79_2_136:4.2.2.3
	Kernel-5_35-4_79_2_135:4.2.2.3
	Kernel-5_35-4_79_2_134:4.2.2.3
	Kernel-5_35-4_79_2_133:4.2.2.3
	Kernel-5_35-4_79_2_132:4.2.2.3
	Kernel-5_35-4_79_2_131:4.2.2.3
	Kernel-5_35-4_79_2_130:4.2.2.3
	Kernel-5_35-4_79_2_129:4.2.2.3
	Kernel-5_35-4_79_2_128:4.2.2.3
	Kernel-5_35-4_79_2_127:4.2.2.3
	Kernel-5_35-4_79_2_126:4.2.2.3
	Kernel-5_35-4_79_2_125:4.2.2.3
	Kernel-5_35-4_79_2_124:4.2.2.3
	Kernel-5_35-4_79_2_123:4.2.2.3
	Cortex_merge:4.2.2.3
	Kernel-5_35-4_79_2_122:4.2.2.3
	Kernel-5_35-4_79_2_98_2_54:4.2.2.3
	Kernel-5_35-4_79_2_98_2_53:4.2.2.3
	Kernel-5_35-4_79_2_98_2_52:4.2.2.3
	Kernel-5_35-4_79_2_98_2_51:4.2.2.3
	Kernel-5_35-4_79_2_98_2_50:4.2.2.3
	Kernel-5_35-4_79_2_98_2_49:4.2.2.3
	Kernel-5_35-4_79_2_98_2_48:4.2.2.3
	Kernel-5_35-4_79_2_121:4.2.2.3
	Kernel-5_35-4_79_2_98_2_47:4.2.2.3
	Kernel-5_35-4_79_2_120:4.2.2.3
	Kernel-5_35-4_79_2_98_2_46:4.2.2.3
	Kernel-5_35-4_79_2_119:4.2.2.3
	Kernel-5_35-4_79_2_98_2_45:4.2.2.3
	Kernel-5_35-4_79_2_98_2_44:4.2.2.3
	Kernel-5_35-4_79_2_118:4.2.2.3
	Kernel-5_35-4_79_2_98_2_43:4.2.2.3
	Kernel-5_35-4_79_2_117:4.2.2.3
	Kernel-5_35-4_79_2_116:4.2.2.3
	Kernel-5_35-4_79_2_98_2_42:4.2.2.3
	Kernel-5_35-4_79_2_115:4.2.2.3
	Kernel-5_35-4_79_2_98_2_41:4.2.2.3
	Kernel-5_35-4_79_2_98_2_40:4.2.2.3
	Kernel-5_35-4_79_2_114:4.2.2.3
	Kernel-5_35-4_79_2_98_2_39:4.2.2.3
	Kernel-5_35-4_79_2_98_2_38:4.2.2.3
	Kernel-5_35-4_79_2_113:4.2.2.3
	Kernel-5_35-4_79_2_112:4.2.2.3
	Kernel-5_35-4_79_2_98_2_37:4.2.2.3
	Kernel-5_35-4_79_2_98_2_36:4.2.2.3
	Kernel-5_35-4_79_2_98_2_35:4.2.2.3
	Kernel-5_35-4_79_2_98_2_34:4.2.2.3
	Kernel-5_35-4_79_2_98_2_33:4.2.2.3
	Kernel-5_35-4_79_2_98_2_32:4.2.2.3
	Kernel-5_35-4_79_2_98_2_31:4.2.2.3
	Kernel-5_35-4_79_2_98_2_30:4.2.2.3
	Kernel-5_35-4_79_2_98_2_29:4.2.2.3
	Kernel-5_35-4_79_2_98_2_28:4.2.2.3
	Kernel-5_35-4_79_2_98_2_27:4.2.2.3
	Kernel-5_35-4_79_2_98_2_26:4.2.2.3
	Kernel-5_35-4_79_2_111:4.2.2.3
	Kernel-5_35-4_79_2_98_2_25:4.2.2.3
	Kernel-5_35-4_79_2_98_2_24:4.2.2.3
	Kernel-5_35-4_79_2_98_2_23:4.2.2.3
	Kernel-5_35-4_79_2_110:4.2.2.3
	Kernel-5_35-4_79_2_98_2_22:4.2.2.3
	Kernel-5_35-4_79_2_109:4.2.2.3
	Kernel-5_35-4_79_2_98_2_21:4.2.2.3
	Kernel-5_35-4_79_2_98_2_20:4.2.2.3
	Kernel-5_35-4_79_2_108:4.2.2.3
	Kernel-5_35-4_79_2_107:4.2.2.3
	Kernel-5_35-4_79_2_98_2_19:4.2.2.3
	Kernel-5_35-4_79_2_98_2_18:4.2.2.3
	Kernel-5_35-4_79_2_98_2_17:4.2.2.3
	Kernel-5_35-4_79_2_98_2_16:4.2.2.3
	Kernel-5_35-4_79_2_98_2_15:4.2.2.3
	Kernel-5_35-4_79_2_106:4.2.2.3
	Kernel-5_35-4_79_2_105:4.2.2.3
	Kernel-5_35-4_79_2_104:4.2.2.3
	Kernel-5_35-4_79_2_98_2_14:4.2.2.3
	Kernel-5_35-4_79_2_98_2_13:4.2.2.3
	Kernel-5_35-4_79_2_98_2_12:4.2.2.3
	Kernel-5_35-4_79_2_98_2_11:4.2.2.3
	Kernel-5_35-4_79_2_98_2_10:4.2.2.3
	Kernel-5_35-4_79_2_98_2_9:4.2.2.3
	Kernel-5_35-4_79_2_103:4.2.2.3
	Kernel-5_35-4_79_2_102:4.2.2.3
	Kernel-5_35-4_79_2_98_2_8:4.2.2.3
	Kernel-5_35-4_79_2_98_2_7:4.2.2.3
	Kernel-5_35-4_79_2_98_2_6:4.2.2.3
	Kernel-5_35-4_79_2_98_2_5:4.2.2.3
	Kernel-5_35-4_79_2_98_2_4:4.2.2.3
	Kernel-5_35-4_79_2_101:4.2.2.3
	Kernel-5_35-4_79_2_100:4.2.2.3
	Kernel-5_35-4_79_2_99:4.2.2.3
	Kernel-5_35-4_79_2_98_2_3:4.2.2.3
	Kernel-5_35-4_79_2_98_2_2:4.2.2.3
	Kernel-5_35-4_79_2_98_2_1:4.2.2.3
	Cortex:4.2.2.3.0.2
	Cortex_bp:4.2.2.3
	Kernel-5_35-4_79_2_98:4.2.2.3
	Kernel-5_35-4_79_2_97:4.2.2.3
	Kernel-5_35-4_79_2_96:4.2.2.3
	Kernel-5_35-4_79_2_95:4.2.2.3
	Kernel-5_35-4_79_2_94:4.2.2.3
	Kernel-5_35-4_79_2_93:4.2.2.3
	Kernel-5_35-4_79_2_92:4.2.2.3
	Kernel-5_35-4_79_2_91:4.2.2.3
	Kernel-5_35-4_79_2_90:4.2.2.3
	Kernel-5_35-4_79_2_89:4.2.2.3
	Kernel-5_35-4_79_2_88:4.2.2.3
	Kernel-5_35-4_79_2_87:4.2.2.3
	Kernel-5_35-4_79_2_86:4.2.2.3
	Kernel-5_35-4_79_2_85:4.2.2.3
	Kernel-5_35-4_79_2_84:4.2.2.3
	Kernel-5_35-4_79_2_83:4.2.2.3
	Kernel-5_35-4_79_2_82:4.2.2.3
	Kernel-5_35-4_79_2_81:4.2.2.3
	Kernel-5_35-4_79_2_80:4.2.2.3
	Kernel-5_35-4_79_2_79:4.2.2.3
	Kernel-5_35-4_79_2_78:4.2.2.3
	Kernel-5_35-4_79_2_77:4.2.2.3
	RO_5_07:4.2.2.3
	Kernel-5_35-4_79_2_76:4.2.2.3
	Kernel-5_35-4_79_2_75:4.2.2.3
	Kernel-5_35-4_79_2_74:4.2.2.3
	Kernel-5_35-4_79_2_73:4.2.2.3
	Kernel-5_35-4_79_2_72:4.2.2.3
	Kernel-5_35-4_79_2_71:4.2.2.3
	Kernel-5_35-4_79_2_70:4.2.2.3
	Kernel-5_35-4_79_2_69:4.2.2.3
	Kernel-5_35-4_79_2_68:4.2.2.3
	Kernel-5_35-4_79_2_67:4.2.2.3
	Kernel-5_35-4_79_2_66:4.2.2.3
	Kernel-5_35-4_79_2_65:4.2.2.3
	Kernel-5_35-4_79_2_64:4.2.2.3
	Kernel-5_35-4_79_2_63:4.2.2.3
	Kernel-5_35-4_79_2_62:4.2.2.3
	Kernel-5_35-4_79_2_61:4.2.2.3
	Kernel-5_35-4_79_2_59:4.2.2.3
	Kernel-5_35-4_79_2_58:4.2.2.3
	Kernel-5_35-4_79_2_57:4.2.2.3
	Kernel-5_35-4_79_2_56:4.2.2.3
	Kernel-5_35-4_79_2_55:4.2.2.3
	Kernel-5_35-4_79_2_54:4.2.2.3
	Kernel-5_35-4_79_2_53:4.2.2.3
	Kernel-5_35-4_79_2_52:4.2.2.2
	Kernel-5_35-4_79_2_51:4.2.2.2
	Kernel-5_35-4_79_2_50:4.2.2.2
	Kernel-5_35-4_79_2_49:4.2.2.2
	Kernel-5_35-4_79_2_48:4.2.2.2
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.4
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2.2.2
	Kernel-5_35-4_79_2_46:4.2.2.2
	Kernel-5_35-4_79_2_45:4.2.2.2
	Kernel-5_35-4_79_2_44:4.2.2.2
	Kernel-5_35-4_79_2_25_2_2:4.2.2.1
	Kernel-5_35-4_79_2_43:4.2.2.2
	Kernel-5_35-4_79_2_42:4.2.2.2
	Kernel-5_35-4_79_2_41:4.2.2.2
	Kernel-5_35-4_79_2_40:4.2.2.2
	Kernel-5_35-4_79_2_39:4.2.2.2
	Kernel-5_35-4_79_2_38:4.2.2.2
	Kernel-5_35-4_79_2_37:4.2.2.1
	Kernel-5_35-4_79_2_36:4.2.2.1
	Kernel-5_35-4_79_2_35:4.2.2.1
	Kernel-5_35-4_79_2_34:4.2.2.1
	Kernel-5_35-4_79_2_33:4.2.2.1
	Kernel-5_35-4_79_2_32:4.2.2.1
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2.2.1
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2.2.1
	Kernel-5_35-4_79_2_30:4.2.2.1
	Kernel-5_35-4_79_2_29:4.2.2.1
	Kernel-5_35-4_79_2_28:4.2.2.1
	Kernel-5_35-4_79_2_27:4.2.2.1
	Kernel-5_35-4_79_2_26:4.2.2.1
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2.2.1
	Kernel-5_35-4_79_2_24:4.2.2.1
	Kernel-5_35-4_79_2_23:4.2.2.1
	Kernel-5_35-4_79_2_22:4.2.2.1
	Kernel-5_35-4_79_2_21:4.2.2.1
	Kernel-5_35-4_79_2_20:4.2.2.1
	Kernel-5_35-4_79_2_19:4.2.2.1
	Kernel-5_35-4_79_2_18:4.2.2.1
	Kernel-5_35-4_79_2_17:4.2.2.1
	Kernel-5_35-4_79_2_16:4.2.2.1
	Kernel-5_35-4_79_2_15:4.2.2.1
	Kernel-5_35-4_79_2_14:4.2.2.1
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2.2.1
	Kernel-5_35-4_79_2_12:4.2.2.1
	Kernel-5_35-4_79_2_11:4.2.2.1
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2.2.1
	Kernel-5_35-4_79_2_9:4.2.2.1
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2.2.1
	Kernel-5_35-4_79_2_7:4.2.2.1
	Kernel-5_35-4_79_2_6:4.2.2.1
	Kernel-5_35-4_79_2_5:4.2.2.1
	Kernel-5_35-4_79_2_4:4.2.2.1
	Kernel-5_35-4_79_2_3:4.2.2.1
	Kernel-5_35-4_79_2_2:4.2.2.1
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2.2.1
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.1
	Kernel-5_28:4.1
	Kernel-5_27:4.1
	Kernel-5_26:4.1
	Kernel-5_25:4.1
	Kernel-5_24:4.1
	Kernel-5_23:4.1
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1.2.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1.2.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1.2.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2018.01.26.00.10.48;	author jlee;	state Exp;
branches;
next	4.5;
commitid	N4RJQzHGK1PlIjoA;

4.5
date	2016.12.17.18.33.46;	author jlee;	state Exp;
branches
	4.5.2.1;
next	4.4;
commitid	gK0l0oJHtyZOPmyz;

4.4
date	2016.12.15.15.27.03;	author jlee;	state Exp;
branches;
next	4.3;
commitid	SNoEvPlWCrTKR5yz;

4.3
date	2016.06.30.20.08.20;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.06.28.16.12.26;	author bavison;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.42;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.5.2.1
date	2018.02.16.00.01.46;	author jlee;	state Exp;
branches;
next	;
commitid	L7HYXYTsWSFlZ0rA;

4.2.2.1
date	2000.09.15.12.38.02;	author kbracey;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2001.06.18.14.49.48;	author mstephen;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2002.12.18.22.18.34;	author bavison;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	2016.06.01.19.04.19;	author jlee;	state Exp;
branches;
next	;
commitid	RvzEEv3Jl47VoN8z;

4.1.1.1
date	96.11.05.09.41.42;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.04.04;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.55;	author mstphens;	state Exp;
branches
	4.1.4.1.2.1;
next	4.1.4.2;

4.1.4.2
date	98.09.24.13.17.59;	author mstphens;	state Exp;
branches;
next	;

4.1.4.1.2.1
date	98.11.23.14.59.50;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.40;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.05.01;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Teletext fixes
Detail:
  s/vdu/vdugrafl - Disable hardware scrolling if we're in a teletext mode with a border. Quick fix in lieu of adding some code to make sure the relevant border areas are cleared when scrolling.
  s/vdu/vduttx - Ignore VDU 23,18,<n> sequences when outside of teletext. Fixes a crash when screen update suspend/resume sequences are used.
Admin:
  Tested on RiscPC


Version 5.94. Tagged as 'Kernel-5_94'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduTTX

;       Teletext (MODE 7) emulation
;       ---------------------------

;       Author          Tim Dobson
;       Started         24-Feb-87

; *****************************************************************************

; Teletext control codes

TTX_AlphaRed     *      &01
TTX_AlphaGreen   *      &02
TTX_AlphaYellow  *      &03
TTX_AlphaBlue    *      &04
TTX_AlphaMagenta *      &05
TTX_AlphaCyan    *      &06
TTX_AlphaWhite   *      &07
TTX_Flash        *      &08
TTX_Steady       *      &09
TTX_EndBox       *      &0A
TTX_StartBox     *      &0B
TTX_NormalHeight *      &0C
TTX_DoubleHeight *      &0D

TTX_GraphRed     *      &11
TTX_GraphGreen   *      &12
TTX_GraphYellow  *      &13
TTX_GraphBlue    *      &14
TTX_GraphMagenta *      &15
TTX_GraphCyan    *      &16
TTX_GraphWhite   *      &17
TTX_Conceal      *      &18
TTX_Contiguous   *      &19
TTX_Separated    *      &1A
TTX_BlackBackgd  *      &1C
TTX_NewBackgd    *      &1D
TTX_HoldGraph    *      &1E
TTX_RelGraph     *      &1F

TTXGraphContFontA * TTXSoftFonts +0    ; Contiguous graphics font (&20-&3F)
TTXGraphSepaFontA * TTXSoftFonts +&140 ; Separated graphics font  (&20-&3F)
TTXGraphContFontB * TTXSoftFonts +&280 ; Contiguous graphics font (&60-&7F)
TTXGraphSepaFontB * TTXSoftFonts +&3C0 ; Separated graphics font  (&60-&7F)

; Bits in the map

;       Bits 0-7        8 bit character
;       Bit  8          0 => Alpha, 1 => Graphics
;       Bit  9          0 => Contiguous, 1 => Separated
;       Bit  10         0 => Steady, 1 => Flash
;       Bit  11         0 => Release, 1 => Hold
;       Bit  12         0 => Reveal, 1 => Conceal
;       Bits 13-14      Bit 13  Bit 14
;                       0       0       Single Height
;                       1       0       Undefined
;                       0       1       Double Height Top
;                       1       1       Double Height Bottom
;       Bit  15         1 => Pending Start Box
;       Bit  16         1 => Pending End Box
;       Bits 17-19      Foreground colour
;       Bit  20         0 => Unboxed, 1 => Boxed
;       Bits 21-23      Background colour
;       Bit  24         0 => Unboxed, 1 => Boxed
;       Bits 25-29,31   Held graphic
;       Bit  30         0 => Held graphic contiguous, 1 => separated

MapBit_Char     *       1 :SHL: 0
MapBit_Graph    *       1 :SHL: 8
MapBit_Separated *      1 :SHL: 9
MapBit_Flash    *       1 :SHL: 10
MapBit_Hold     *       1 :SHL: 11
MapBit_Conceal  *       1 :SHL: 12
MapBit_Bottom   *       1 :SHL: 13
MapBit_Double   *       1 :SHL: 14
MapBit_PendingStart *   1 :SHL: 15

MapBit_PendingEnd *     1 :SHL: 16
MapBit_ForeMask *       7 :SHL: 17
MapBit_BackMask *       7 :SHL: 21
MapBits_Boxed   *       (1 :SHL: 20) :OR: (1 :SHL: 24)
MapBit_HeldMask *       &7F :SHL: 25
MapBit_HeldSeparated *  1 :SHL: 30

MapForeShift    *       17
MapBackShift    *       21
MapHeldShift    *       25

MapBit_Default  *       (7 :SHL: MapForeShift)+32 ; default at start of line

; *****************************************************************************
;
;       TeletextAlloc - Allocate teletext workspace for pending mode change
;       Entered with R0 -> mode workspace
;

TeletextAlloc ROUT
        Entry   "r1-r7"
        ; We allocate one block from the system heap which is large enough to contain:
        ; * TTXMap: (columns+1)*rows*4
        ; * TTXLineStarts: rows*4
        ; * TTXDoubleCounts: rows*1
        LDR     R4, [R0, #wkScrRCol]
        ADD     R4, R4, #2
        LDR     R5, [R0, #wkScrBRow]
        ADD     R5, R5, #1
        MUL     R6, R4, R5
        MOV     R6, R6, LSL #2 ; TTXMap size, TTXLineStarts offset
        ADD     R7, R6, R5, LSL #2 ; TTXMap+TTXLineStarts size, TTXDoubleCounts offset
        ADD     R3, R7, R5 ; Total size
        BL      ClaimSysHeapNode
        ; Remember new workspace pointer for later
        STRVC   R2, [WsPtr, #TTXNewWorkspace]
        EXIT

; *****************************************************************************
;
;       TeletextInit - Initialise teletext workspace
;       Called when MODE 7 (or 135) is selected
;

TeletextInit ROUT
        Entry
        ; Claim the workspace that was previously allocated by TeletextAlloc
        LDR     R2, [WsPtr, #TTXNewWorkspace]
        TEQ     R2, #0
        BEQ     %FT05 ; If there's no pending workspace pointer then VDU output is switching from sprite back to screen and we should skip most of this
        BL      TeletextFinalise ; Ensure old workspace is freed
        MOV     R0, #0
        STR     R0, [WsPtr, #TTXNewWorkspace]

        ; Calculate offsets to the different components
        ; NOTE: TTXFastCLS relies on TTXLineStarts directly following TTXMap
        LDR     R4, [WsPtr, #ScrRCol]
        ADD     R4, R4, #2
        LDR     R5, [WsPtr, #ScrBRow]
        ADD     R5, R5, #1
        MUL     R6, R4, R5
        MOV     R6, R6, LSL #2 ; TTXMap size, TTXLineStarts offset
        ADD     R7, R6, R5, LSL #2 ; TTXMap+TTXLineStarts size, TTXDoubleCounts offset

        ; Fill in the pointers
        STR     R2, [WsPtr, #TTXMapPtr]
        ADD     R6, R2, R6
        STR     R6, [WsPtr, #TTXLineStartsPtr]
        ADD     R7, R2, R7
        STR     R7, [WsPtr, #TTXDoubleCountsPtr]


        ; Initialise TTXLineStarts
        ; Everything else is initialised later on
01
        STR     R2, [R6], #4
        ADD     R2, R2, R4, LSL #2
        TEQ     R6, R7
        BNE     %BT01

05        
        MOV     R0, #1                          ; set to flash immediately
        STR     R0, [WsPtr, #TeletextCount]

        MOV     R0, #TTXFlag_Conceal
        ORR     R0, R0, #TTXFlag_FgTransBIC :OR: TTXFlag_BgTransBIC
        STR     R0, [WsPtr, #TTXFlags]

      [ :LNOT: HiResTTX
; compute the graphics fonts

        ADD     R0, WsPtr, #TTXSoftFonts ; R0 -> contiguous font
        MOV     R2, #&20                ; R2 = character number
        MOV     R3, #0                  ; R3 = byte to store
10
        ADD     R1, R0, #&140           ; R1 -> separated font
20
        TST     R2, #1                  ; top left
        ORRNE   R3, R3, #&F0
        TST     R2, #2                  ; top right
        ORRNE   R3, R3, #&0F
        STRB    R3, [R0], #1            ; 3 pixel rows for top
        STRB    R3, [R0], #1
        STRB    R3, [R0], #1
        AND     R3, R3, #&77            ; do separated
        STRB    R3, [R1], #1
        STRB    R3, [R1], #1
        MOV     R3, #0
        STRB    R3, [R1], #1

        TST     R2, #4                  ; middle left
        ORRNE   R3, R3, #&F0
        TST     R2, #8                  ; middle right
        ORRNE   R3, R3, #&0F
        STRB    R3, [R0], #1            ; 4 pixel rows for middle
        STRB    R3, [R0], #1
        STRB    R3, [R0], #1
        STRB    R3, [R0], #1
        AND     R3, R3, #&77            ; do separated
        STRB    R3, [R1], #1
        STRB    R3, [R1], #1
        STRB    R3, [R1], #1
        MOV     R3, #0
        STRB    R3, [R1], #1

        TST     R2, #&10                ; bottom left
        ORRNE   R3, R3, #&F0
        TST     R2, #&40                ; bottom right
        ORRNE   R3, R3, #&0F
        STRB    R3, [R0], #1            ; 3 pixel rows for bottom
        STRB    R3, [R0], #1
        STRB    R3, [R0], #1
        AND     R3, R3, #&77            ; do separated
        STRB    R3, [R1], #1
        STRB    R3, [R1], #1
        MOV     R3, #0
        STRB    R3, [R1], #1

        ADD     R2, R2, #1
        TEQ     R2, #&40                ; if at end of 1st part
        MOVEQ   R2, #&60                ; then start 2nd
        ADDEQ   R0, R0, #&140           ; skipping separated already done
        BEQ     %BT10                   ; and resetting R1 too

        TEQ     R2, #&80                ; finished
        BNE     %BT20
      ]

        EXIT

; *****************************************************************************
;
;       TeletextFinalise - Free teletext workspace
;       Called when switching out of teletext mode
;

TeletextFinalise ROUT
        Entry   "r0-r2"
        ; TTXMapPtr is the pointer to the allocated block
        LDR     R2, [WsPtr, #TTXMapPtr]
        CMP     R2, #0
        BLNE    FreeSysHeapNode
        MOV     R0, #0
        STR     R0, [WsPtr, #TTXMapPtr]
        STR     R0, [WsPtr, #TTXLineStartsPtr]
        STR     R0, [WsPtr, #TTXDoubleCountsPtr]
        CLRV
        EXIT

; *****************************************************************************
;
;       Vdu23_18 - Miscellaneous Teletext operations
;

Vdu23_18
        LDRB    R2, [WsPtr, #QQ+1]
        CMP     R2, #(Vdu23_18_TabEnd - Vdu23_18_TabStart) / 4
        BCS     UnknownVdu23
        LDR     R0, [WsPtr, #CursorFlags]
        TST     R0, #TeletextMode
        ADDNE   PC, PC, R2, LSL #2
        MOV     PC, LR
Vdu23_18_TabStart
        B       Vdu23_18_0
        B       Vdu23_18_1
        B       Vdu23_18_2
        B       Vdu23_18_3
Vdu23_18_TabEnd

; *****************************************************************************
;
;       Vdu23_18_0 - Set transparency
;

Vdu23_18_0 ROUT
        Push    "R14"
        LDRB    R5, [WsPtr, #QQ+2]
        AND     R5, R5, #3
        LDR     R6, [WsPtr, #TTXFlags]
        AND     R14, R6, #TTXFlag_TransModeMask
        TEQ     R14, R5, LSL #TTXFlag_TransModeShift
        Pull    "PC", EQ                ; fast exit if nothing's changed

        ; Because the border is being reprogrammed, switches in and out of mode 0 (solid)
        ; look messy unless we reprogram the palette too (on the non-solid side of the switch)
        TEQ     R5, #0                  ; switching into mode 0?
        ADREQ   R2, TTXPalette_Solid    ; if so, program a solid palette
        MOVEQ   R7, #0                  ; use a black border
        BLEQ    SetTTXPalette

        ; Munge the TTXFlags to match the transparency mode
        ORR     R6, R6, #TTXFlag_FgTransEOR :OR: TTXFlag_BgTransEOR
        ORR     R6, R6, #TTXFlag_FgTransBIC :OR: TTXFlag_BgTransBIC
        TEQ     R5, #3                  ; already adjusted for mode 3 (transparent)
        BEQ     %FT10
        TEQ     R5, #2                  ; in modes 0 (solid) and 1 (mix)
        BICNE   R6, R6, #TTXFlag_FgTransEOR ; we just clear the fg transparency bit
        BICEQ   R6, R6, #TTXFlag_FgTransBIC ; in mode 2 (box) we just toggle it
        TEQ     R5, #0                  ; in modes 1 (mix) and 2 (box)
        BICNE   R6, R6, #TTXFlag_BgTransBIC ; we just toggle the bg transparency bit
        BICEQ   R6, R6, #TTXFlag_BgTransEOR ; in mode 0 (solid) we just clear it
10
        ; Move the mode bits from TTXFlags to R7, and then from R5 to TTXFlags
        MOV     R7, R6
        BIC     R6, R6, #TTXFlag_TransModeMask
        ORR     R6, R6, R5, LSL #TTXFlag_TransModeShift
        STR     R6, [WsPtr, #TTXFlags]

        ; Redraw the screen (paletted case)
        Push    "R7"
        LDR     R7, [WsPtr, #Log2BPP]
        CMP     R7, #3
        BLLS    RefreshBitmap
        Pull    "R7"

        ; Deal with the opposite palette programming case (switching away from mode 0)
        TST     R7, #TTXFlag_TransModeMask
        ADREQ   R2, TTXPalette_Mixed    ; use a mixed palette for all other modes
        MOVEQ   R7, #&FF                ; and they all have a transparent border, too
        BLEQ    SetTTXPalette

        ; Redraw the screen (true colour case)
        LDR     R7, [WsPtr, #Log2BPP]
        CMP     R7, #3
        MOVHI   R7, #-1
        STRHI   R7, [WsPtr, #TForeCol]  ; ensure TTXUpdateColours gets called on next char plot
        BLHI    RefreshBitmap

        Pull    "PC"

SetTTXPalette
        Push    "R14"
        LDR     R0, [WsPtr, #Log2BPP]
        CMP     R0, #3
        BHI     %FT20
        ; Set 1st flash states
        MOV     R0, #0                  ; start at colour 0
        MOV     R1, #16                 ; program 16 colours
        ORR     R1, R1, #17:SHL:24      ; program 1st flash state
        MOV     R4, #paletteV_BulkWrite
        BL      CallPaletteV
        ; Set 2nd flash states
        MOV     R0, #0                  ; start at colour 0
        MOV     R1, #16                 ; program 16 colours
        ORR     R1, R1, #18:SHL:24      ; program 2nd flash state
        MOV     R4, #paletteV_BulkWrite
        BL      CallPaletteV
20
        ; Set up the border colour
        MOV     R0, #0                  ; logical colour 0
        MOV     R1, #24                 ; type 24 (border)
        MOV     R2, R7                  ; palette entry passed in R7
        MOV     R4, #paletteV_Set
        BL      CallPaletteV
        Pull    "PC"

TTXPalette_Solid
        &       &00000000       ; black
        &       &0000FF00       ; red
        &       &00FF0000       ; green
        &       &00FFFF00       ; yellow
        &       &FF000000       ; blue
        &       &FF00FF00       ; magenta
        &       &FFFF0000       ; cyan
        &       &FFFFFF00       ; white
TTXPalette_Mixed
        &       &00000000       ; black
        &       &0000FF00       ; red
        &       &00FF0000       ; green
        &       &00FFFF00       ; yellow
        &       &FF000000       ; blue
        &       &FF00FF00       ; magenta
        &       &FFFF0000       ; cyan
        &       &FFFFFF00       ; white
        &       &000000FF       ; transparent
        &       &0000FFFF       ; transparent
        &       &00FF00FF       ; transparent
        &       &00FFFFFF       ; transparent
        &       &FF0000FF       ; transparent
        &       &FF00FFFF       ; transparent
        &       &FFFF00FF       ; transparent
        &       &FFFFFFFF       ; transparent

; *****************************************************************************
;
;       Vdu23_18_1 - Suspend/resume bitmap updates
;

Vdu23_18_1 ROUT
        Push    "R14"
        LDRB    R0, [WsPtr, #QQ+2]
        LDR     R1, [WsPtr, #TTXFlags]
        TST     R0, #1                          ; bit 0 of 3rd parameter
        BICEQ   R2, R1, #TTXFlag_Suspend        ; determines new setting of suspend flag
        ORRNE   R2, R1, #TTXFlag_Suspend
        STR     R2, [WsPtr, #TTXFlags]
        BICS    R14, R1, R2                     ; if coming out of suspension
        BLNE    RefreshBitmap                   ; then redraw screen
        Pull    "PC"

; *****************************************************************************
;
;       Vdu23_18_2 - Reveal/conceal
;

Vdu23_18_2 ROUT
        Push    "R14"
        LDRB    R0, [WsPtr, #QQ+2]
        LDR     R1, [WsPtr, #TTXFlags]
        TST     R0, #1                          ; bit 0 of 3rd parameter
        ORREQ   R1, R1, #TTXFlag_Conceal        ; determines new setting of reveal flag
        BICNE   R1, R1, #TTXFlag_Conceal
        STR     R1, [WsPtr, #TTXFlags]
        TST     R1, #TTXFlag_Suspend            ; unless suspended,
        BLEQ    RefreshBitmap                   ; redraw the screen
        Pull    "PC"

; *****************************************************************************
;
;       Vdu23_18_3 - Enable/disable black foreground control codes
;

Vdu23_18_3 ROUT
        Push    "R14"
        LDRB    R0, [WsPtr, #QQ+2]
        LDR     R1, [WsPtr, #TTXFlags]
        TST     R0, #1                          ; bit 0 of 3rd parameter
        BICEQ   R2, R1, #TTXFlag_BlackEnable    ; determines new setting of blackenable flag
        ORRNE   R2, R1, #TTXFlag_BlackEnable
        EOR     R1, R1, R2
        TST     R1, #TTXFlag_BlackEnable        ; has blackenable changed?
        Pull    "PC", EQ                        ; if not, then exit

        Push    "R2"                            ; save R2 for later
        ORR     R2, R2, #TTXFlag_Suspend        ; temporarily suspend bitmap update
        STR     R2, [WsPtr, #TTXFlags]

        MOV     R0, #0                          ; start at left
        MOV     R1, #0                          ; start at top
        LDR     R2, [WsPtr, #TTXMapPtr]         ; R2 -> start of map
        ADD     R7, R2, #4*1                    ; R7 -> map entry for first real char
        LDR     R5, [WsPtr, #ScrRCol]
        ADD     R5, R7, R5, LSL #2              ; R5 -> map entry for last char on first line
        MOV     R11, #0                         ; R11 = top line
        LDR     R10, [WsPtr, #ScrBRow]
        ADD     R10, R10, #1                    ; R10 = bottom line + 1
        ADR     R14, %FT50
        Push    "R14"                           ; set up return address on stack
        B       TTXScanZap2                     ; recalculate the map
50
        Pull    "R2"                            ; retrieve the final TTXFlags
        STR     R2, [WsPtr, #TTXFlags]          ; save them
        TST     R2, #TTXFlag_Suspend            ; and unless we were suspended on entry
        BLEQ    RefreshBitmap                   ; then redraw the screen
        Pull    "PC"

; *****************************************************************************
;
;       RefreshBitmap - Brings bitmap up-to-date with TTXMap
;

RefreshBitmap ROUT
        Entry   "R9-R11"
        MOV     R0, #0
        MOV     R1, #0
        BL      AddressR0R1             ; R2 -> top-left character in bitmap
        LDR     R7, [WsPtr, #RowLength]
        LDR     R11, [WsPtr, #CharWidth]
        LDR     R8, [WsPtr, #ScrRCol]
        MLA     R8, R11, R8, R11
        SUB     R7, R7, R8              ; R7 = offset from end of one row to start of next
        LDR     R8, [WsPtr, #TTXLineStartsPtr]
        MOV     R6, #0                  ; R6 is line number: 0 <= R11 <= 24
        LDR     R10, [WsPtr, #ScrBRow]
10
        LDR     R4, [R8, R6, LSL #2]    ; R4 -> map entry for magic 0th character
        LDR     R5, [WsPtr, #ScrRCol]
        ADD     R5, R5, #1
        ADD     R5, R4, R5, LSL #2      ; R5 -> last map entry on line
20
        LDR     R1, [R4], #4            ; load map entry for previous character
        LDR     R0, [R4]                ; load map entry for current character
        BIC     R1, R1, #&FF
        AND     R0, R0, #&FF
        ORR     R0, R1, R0              ; construct R0 and R1 as required by DoPreControl
        AND     R1, R0, #&7F
        CMP     R1, #&20                ; is it a control char
        BLCC    DoPreControl            ; [do pre-control things]
        BL      UpdateHeldBits
        BL      TTXPaintChar            ; paint it to the screen
        ADD     R2, R2, R11
        CMP     R4, R5
        BCC     %BT20
        ADD     R2, R2, R7              ; and drop down to start of next line
        ADD     R6, R6, #1
        CMP     R6, R10
        BLS     %BT10
        EXIT

 [ HiResTTX
; *****************************************************************************
;
;       ComputeGraphic - Called on a character-by-character basis
;       Generates a graphic character on the fly
;
; in:   R1 -> space to build character in
;       R3 = character: bits 0-4,6 are block flags, bit 5 is separated flag
;
; out:  Character built in R1
;       All regs preserved
;

ComputeGraphic ROUT
        Push    "R1,mask,R10,R14"
        MOV     mask, #&FF000000
        ORR     mask, mask, mask, LSR #16       ; mask for setting left-hand blocks (shift for right-hand)
        MOV     R10, #&C0000000
        ORR     R10, R10, R10, LSR #16
        ORR     R10, R10, R10, LSR #8           ; mask for separated graphics vertical lines

        MOV     R14, #0                         ; holds each word of the character as we build it up
        TST     R3, #1:SHL:0
        ORRNE   R14, R14, mask
        TST     R3, #1:SHL:1
        ORRNE   R14, R14, mask, LSR #8
        TST     R3, #1:SHL:5
        BICNE   R14, R14, R10
        STR     R14, [R1], #4                   ; first 4 lines identical
        STR     R14, [R1], #4
        MOVNE   R14, #0                         ; if separated, then 2 horizontal lines, else same as above
        STR     R14, [R1], #4

        MOV     R14, #0
        TST     R3, #1:SHL:2
        ORRNE   R14, R14, mask
        TST     R3, #1:SHL:3
        ORRNE   R14, R14, mask, LSR #8
        TST     R3, #1:SHL:5
        BICNE   R14, R14, R10
        STR     R14, [R1], #4                   ; 8 lines total for middle blocks
        STR     R14, [R1], #4
        STR     R14, [R1], #4
        MOVNE   R14, #0
        STR     R14, [R1], #4

        MOV     R14, #0
        TST     R3, #1:SHL:4
        ORRNE   R14, R14, mask
        TST     R3, #1:SHL:6
        ORRNE   R14, R14, mask, LSR #8
        TST     R3, #1:SHL:5
        BICNE   R14, R14, R10
        STR     R14, [R1], #4                   ; 6 lines total for bottom blocks
        STR     R14, [R1], #4
        MOVNE   R14, #0
        STR     R14, [R1], #4
        Pull    "R1,mask,R10,PC"
 ]

; *****************************************************************************
;
;       TTXFastCLS - Called when clearing whole screen
;       Clears the teletext map to default
;

TTXFastCLS ROUT
        LDR     R0, [WsPtr, #TTXMapPtr] ; R0 -> map
        LDR     R1, [WsPtr, #TTXLineStartsPtr] ; R1 -> end of map
        LDR     R2, =MapBit_Default     ; R2 = default status at start of line
10
        STR     R2, [R0], #4
        CMP     R0, R1
        BLO     %BT10

        LDR     R0, [WsPtr, #TTXDoubleCountsPtr] ; zero double counts on each line
        LDR     R1, [WsPtr, #ScrBRow]
        ADD     R1, R1, #1
        ADD     R1, R1, R0
        MOV     R2, #0
20
        STRB    R2, [R0], #1
        TEQ     R0, R1
        BNE     %BT20

        MOV     PC, R14

; *****************************************************************************
;
;       TTXUpdateColours - Update colour table for new colours
;
; in:   R5 = new foregd colour
;       R6 = new backgd colour
;
; out:  R0, R2 preserved
;

TTXUpdateColours ROUT
        Push    "R0,R2,R14"
        ADD     R14, WsPtr, #TForeCol
        STMIA   R14, {R5,R6}
        MOV     fore, R5
        MOV     back, R6
        LDR     bpp, [WsPtr, #BitsPerPix]
      [ HiResTTX
        CMP     bpp, #8
        BLS     %FT10
        ; Convert colour index to pixel value
        ADRL    R14, TTXPalette_Solid
        LDR     R0, [R14, fore, LSL #2]
        LDR     back, [R14, back, LSL #2]
        SWI     XColourTrans_ReturnColourNumber
        MOV     fore, R0
        MOV     R0, back
        SWI     XColourTrans_ReturnColourNumber
        ; Fixup the supremacy/alpha channel if necessary
        ; (ColourTrans always sets it to default!)
        TST     R5, #8
        TSTEQ   R6, #8
        LDRNE   R14, [WsPtr, #TTXFlags]
        TSTNE   R14, #TTXFlag_TransModeMask
        BEQ     %FT09
        Push    "fore"
        BL      GetAlphaSupremacyBits
        Pull    "fore"
        TST     R5, #8
        EORNE   fore, fore, back
        TST     R6, #8
        EORNE   R0, R0, back
09
        MOV     back, R0
        LDR     bpp, [WsPtr, #BitsPerPix] ; (R0)        
10
      ]
        BL      SetColours
        Pull    "R0,R2,PC"

 [ :LNOT: HiResTTX
; *****************************************************************************
;
;       PrintDoubleHeight - Process font for double height
;
; in:   R0 = char + attributes
;       tophalf    contains bytes 0123
;       bottomhalf contains bytes 4567
;       R10        contains bytes xx89
;       We know that at least one of MapBit_Bottom or MapBit_Double is set
;
; out:  tophalf, bottomhalf, R10 updated
;       R3 corrupted
;

PrintDoubleHeight ROUT
        TST     R0, #MapBit_Double              ; if not double height,
        MOVEQ   tophalf, #0                     ; then must be single height
        MOVEQ   bottomhalf, #0                  ; part on line below double,
        MOVEQ   R10, #0                         ; so make it invisible
        MOVEQ   PC, R14

        TST     R0, #MapBit_Bottom
        BNE     %FT10                           ; [bottom half of double]

        [ 1=1 ;                 0 1              2 3         4
; do top half, we want tophalf=0112, bottomhalf=2334, R10=xx45
        MOV     R10, bottomhalf, LSL #16        ; R10 := o o 4 5
        ORR     R10, R10, R10, LSL #8           ; R10 := o o 4 4/5
        AND     R3, tophalf, #&FF000000         ; R3 := o o o 3
        ORR     bottomhalf, R3, bottomhalf, LSL #24 ; bot := o o o 3/4
        MOV     R3, tophalf, LSR #16            ; R3 := 2 3 o o
        ORR     R3, R3, R3, LSL #8              ; R3 := 2 2/3 3 o
        ORR     bottomhalf, bottomhalf, R3      ; bot := 2 2/3 3 3/4
        MOV     tophalf, tophalf, LSL #16       ; top := o o 0 1
        ORR     tophalf, tophalf, tophalf, LSR #8 ; top := o 0 0/1 1
        MOV     tophalf, tophalf, LSR #8        ; top := 0 0/1 1 o
        ORR     tophalf, tophalf, bottomhalf, LSL #24 ; top := 0 0/1 1 2
        AND     R3, tophalf, #&00FF0000         ; R3 := o o 1 o
        ORR     tophalf, tophalf, R3, LSL #8    ; top := 0 0/1 1 1/2
        MOV     PC, R14

10 ;                               5 6              7 8         9
; do bottom half, we want tophalf=5667, bottomhalf=7889, R10=xx9o
        AND     tophalf, bottomhalf, #&FF000000 ; top := o o o 7
        MOV     R3, bottomhalf, LSL #8          ; R3 := o 4 5 6
        MOV     R3, R3, LSR #16                 ; R3 := 5 6 o o
        ORR     tophalf, tophalf, R3            ; top := 5 6 o 7
        ORR     tophalf, tophalf, R3, LSL #8    ; top := 5 5/6 6 7
        AND     R3, R3, #&0000FF00              ; R3 := o 6 o o
        ORR     tophalf, tophalf, R3, LSL #16   ; top := 5 5/6 6 6/7
        MOV     bottomhalf, bottomhalf, LSR #24 ; bot := 7 o o o
        AND     R3, R10, #&00FF0000             ; R3 := o o 8 o
        ORR     bottomhalf, bottomhalf, R3, LSR #8 ; bot := 7 8 o o
        ORR     bottomhalf, bottomhalf, bottomhalf, LSL #8 ; bot := 7 7/8 8 o
        ORR     R3, R10, R10, LSL #8            ; R3 := x x x 8/9
        AND     R3, R3, #&FF000000              ; R3 := o o o 8/9
        ORR     bottomhalf, bottomhalf, R3      ; bot := 7 7/8 8 8/9
        MOV     R10, R10, LSR #24               ; R10 := 9 o o o
        ORR     R10, R10, R10, LSL #8           ; R10 := 9 9 o o
        MOV     R10, R10, LSL #16               ; R10 := o o 9 9
        MOV     PC, R14
        |
; do top half, we want tophalf=0011, bottomhalf=2233, R10=xx44

        MOV     R10, bottomhalf, LSL #24        ; R10 := ooo4
        ORR     R10, R10, R10, LSR #8           ; R10 := oo44
        AND     bottomhalf, tophalf, #&00FF0000 ; bottom := oo2o
        ORR     bottomhalf, bottomhalf, tophalf, LSR #24 ; bottom := 3o2o
        ORR     bottomhalf, bottomhalf, bottomhalf, LSL #8 ; bottom := 3322
        MOV     bottomhalf, bottomhalf, ROR #16 ; bottom := 2233
        AND     R3, tophalf, #&0000FF00         ; R3 := o1oo
        AND     tophalf, tophalf, #&FF          ; top := 0ooo
        ORR     tophalf, tophalf, R3, LSL #8    ; top := 0o1o
        ORR     tophalf, tophalf, tophalf, LSL #8 ; top := 0011
        MOV     PC, R14

; do bottom half, we want tophalf=5566, bottomhalf=7788, R10=xx99

10
        AND     tophalf, bottomhalf, #&0000FF00         ; top := o5oo
        MOV     bottomhalf, bottomhalf, LSR #16         ; bot := 67oo
        ORR     tophalf, tophalf, bottomhalf, LSL #24   ; top := o5o6
        ORR     tophalf, tophalf, tophalf, LSR #8       ; top := 5566
        MOV     bottomhalf, bottomhalf, LSR #8          ; bot := 7ooo
        MOV     R10, R10, LSR #16                       ; R10 := 89oo
        ORR     bottomhalf, bottomhalf, R10, LSL #16    ; bot := 7o89
        BIC     bottomhalf, bottomhalf, #&FF000000      ; bot := 7o8o
        ORR     bottomhalf, bottomhalf, bottomhalf, LSL #8 ; bot := 7788
        BIC     R10, R10, #&FF                          ; R10 := o9oo
        ORR     R10, R10, R10, LSR #8                   ; R10 := 99oo
        MOV     R10, R10, LSL #16                       ; R10 := oo99
        MOV     PC, R14
        ]
 ]

; *****************************************************************************
;
;       TTXWrch - Print a character in the range &20-&FF
;
; in:   R0 = character
; out:  cursor has been moved on if appropriate
;

TTXWrch ROUT
        Push    R14
        BL      TTXDoChar
        Pull    R14
        B       PostCharMove

; *****************************************************************************
;
;       TTXDoChar - Print a character (don't move cursor)
;
; in:   R0 = character
;

TTXDoChar ROUT
        Push    R14

        MOV     R3, R0
        TEQ     R3, #"#"                        ; swap around the three
        MOVEQ   R0, #"_"                        ; old favourites
        TEQ     R3, #"_"
        MOVEQ   R0, #"`"
        TEQ     R3, #"`"
        MOVEQ   R0, #"#"

        LDR     R11, [WsPtr, #CursorY]          ; R11 = current Y position
        LDR     R3, [WsPtr, #CursorX]           ; R3=start X posn on this line
        LDR     R2, [WsPtr, #CursorAddr]        ; screen address
TTXScanFromHere
        MOV     R4, #0                          ; Xmin and
        MOV     R5, #0                          ; Xmax are irrelevant
        MOV     R10, #0                         ; Ymax always <= Y so no zap
;
;       TTXScanZap - Plot multiple characters from map, or plot spaces
;
; in:   R0 = current (initial) character
;       R2 = current screen addr
;       R3 = current X
;       R4 = X min of area
;       R5 = X max of area
;       R10 = Y max of area
;       R11 = current Y
;       R12 -> VDU workspace
;       R14 = non-zero to plot from map, zero to plot spaces
;       Return address stacked
;
; out:  R0-R11 corrupt
;
TTXScanZap
        LDR     R1, [WsPtr, #TTXLineStartsPtr]  ; R1 -> table of line starts
        LDR     R8, [R1, R11, LSL #2]           ; R8 -> map entry at st.of line
        LDR     R7, [WsPtr, #ScrRCol]
        ADD     R7, R7, #1
        ADD     R7, R8, R7, LSL #2              ; R7 -> end of this line
        LDR     R1, [R8, R3, LSL #2]!           ; R1 = prev. char+attr
        LDR     R6, [WsPtr, #CharWidth]
08
        LDR     R3, [WsPtr, #TTXDoubleCountsPtr]
        LDRB    R9, [R3, R11]                   ; R9 = no. of dbls on this line
10
        BIC     R1, R1, #&FF                    ; clear char bits
        ORR     R0, R1, R0                      ; store new char
        AND     R1, R0, #&7F                    ; just look at char bits

        Push    R14
        CMP     R1, #&20                        ; is it a control char
        BLCC    DoPreControl                    ; [do pre-control things]

        BL      UpdateHeldBits                  ; this needs doing irrespective of suspension
        LDR     R14, [WsPtr, #TTXFlags]
        TST     R14, #TTXFlag_Suspend
        BLEQ    TTXPaintChar

        BIC     R0, R0, #(MapBit_PendingStart :OR: MapBit_PendingEnd)

        CMP     R1, #&20
        BLCC    DoPostControl                   ; [do post-control things]
        Pull    R14                             ; restore zap flag

        LDR     R1, [R8, #4]!                   ; get old character
        STR     R0, [R8]                        ; store character away

        AND     R3, R1, #&7F                    ; if overwriting double height
        TEQ     R3, #TTX_DoubleHeight
        SUBEQ   R9, R9, #1                      ; then one less

        EOR     R1, R0, R1                      ; get difference
        BIC     R3, R1, #&FF                    ; difference in attributes
        MOV     R1, R0                          ; R1 = prev char + new attr

        CMP     R11, R10                        ; if Y >= Ymax
        BCS     %FT20                           ; then load from map
        CMPCC   R8, R5                          ; else if X <= Xmax
        MOVLS   R3, #1                          ; then pretend attr different
        CMPCC   R4, R8                          ; if Xmin < X < Xmax
        CMPCC   R14, #1                         ; and we're zapping (not scan)
        MOVCC   R0, #32                         ; then zap to space
20
        LDRCSB  R0, [R8, #4]                    ; else load from map

        TEQ     R3, #0                          ; if attributes different
        TEQNE   R8, R7                          ; and not at end of line
        ADDNE   R2, R2, R6                      ; then move to next char
        BNE     %BT10                           ; and loop

        LDR     R3, [WsPtr, #TTXDoubleCountsPtr]
        STRB    R9, [R3, R11]                   ; update no. of doubles

        LDR     R3, [WsPtr, #ScrBRow]
        TEQ     R11, R3
        ADD     R11, R11, #1                    ; go to next line
        Pull    PC, EQ                          ; if off bottom of screen then finished

        MOVS    R3, R9                          ; if no doubles
                                                ; then next line is top line
        EORNE   R3, R1, #MapBit_Bottom          ; else next line is opposite
                                                ; to this line

        LDR     R1, [R7, #4]                    ; get dummy word on next line
        EOR     R3, R1, R3                      ; difference
        ANDS    R3, R3, #MapBit_Bottom          ; difference in 'bottom' bit
        EORNE   R1, R1, #MapBit_Bottom          ; if different then toggle bit
        STR     R1, [R7, #4]!                   ; always store back
        BNE     %FT30                           ; and do another row

        CMP     R11, R10                        ; else if finished zap
        Pull    PC, CS                          ; then exit
30

; now compute new R2

        SUB     R3, R7, R8                      ; (no. of chars before eol) * 4
        LDR     R9, [WsPtr, #ScrRCol]
        ADD     R9, R9, #1
        RSB     R3, R3, R9, LSL #2              ; (current char number) * 4
        MUL     R3, R6, R3                      ; (number of bytes) * 4
        SUB     R2, R2, R3, LSR #2              ; back to start of old line
        LDR     R3, [WsPtr, #RowLength]
        ADD     R2, R2, R3                      ; move down a row

        MOV     R8, R7                          ; R8 -> dummy char on new line
        ADD     R7, R7, R9, LSL #2              ; R7 -> last char on new line

        ADD     R9, R9, #1
        ADD     R4, R4, R9, LSL #2              ; move Xmin to next line
        ADD     R5, R5, R9, LSL #2              ; move Xmax to next line

        CMP     R11, R10                        ; if Y < Ymax
        CMPCC   R8, R5                          ; and X < Xmax
        CMPCC   R4, R8                          ; if also Xmin < X
        CMPCC   R14, #1                         ; & we're zapping not scanning
        MOVCC   R0, #32                         ; then zap to space
        LDRCSB  R0, [R8, #4]                    ; else load from map
        B       %BT08

; *****************************************************************************
;
;       TTXClearBox - Fill a rectangle with spaces, and update screen
;
; in:   R0 = left column
;       R1 = bottom row
;       R2 = right column
;       R3 = top row
;       Return address already stacked
;

TTXClearBox
        ADD     R10, R1, #1                     ; R10 := bottom +1
        MOV     R11, R3                         ; R11 := top
        ADD     R5, R2, #1                      ; R5 := right + 1

        MOV     R1, R3
        BL      AddressR0R1                     ; R2 := address(topleft)
                                                ; R1, R3, R4 corrupted
        MOV     R3, R0                          ; R3 := left

        LDR     R4, [WsPtr, #TTXLineStartsPtr]
        LDR     R0, [R4, R11, LSL #2]           ; R0 -> dummy(top)
        ADD     R5, R0, R5, LSL #2              ; R5 := map(topright)
        ADD     R4, R0, R3, LSL #2              ; R4 := map(topleft)-4
        SUB     R4, R4, #4                      ; R4 := map(topleft)-8
        MOV     R0, #32                         ; start with a space
        MOV     R14, #0                         ; indicate zapping
        B       TTXScanZap                      ; go and do it

; *****************************************************************************
;
;       TTXHardScrollUp - Scroll teletext screen upwards
;

TTXHardScrollUp ROUT

; first scroll map up

        LDR     R0, [WsPtr, #RowLength]         ; save real RowLength
        Push    "R0, R6, R14"                   ; and save CursorFlags

        MOV     R0, #1                          ; pretend rowmult = 1
        LDR     R2, [WsPtr, #TTXMapPtr]         ; R2 -> TTXMap
        LDR     R5, [WsPtr, #ScrRCol]
        ADD     R5, R5, #2
        MOV     R5, R5, LSL #2                  ; R5 = no. of bytes horiz
        STR     R5, [WsPtr, #RowLength]         ; pretend rowlength
        LDR     R6, [WsPtr, #ScrBRow]           ; no. of 'pixel' rows
        MOV     R7, R5                          ; linelength
        ADD     R6, R6, #1
        BL      SoftScrollUp2

        Pull    "R0, R6"
        STR     R0, [WsPtr, #RowLength]         ; restore RowLength

; now 'scroll' DoubleCounts

        LDR     R0, [WsPtr, #TTXDoubleCountsPtr]
        LDR     R1, [WsPtr, #ScrBRow]
        ADD     R1, R0, R1
10
        LDRB    R2, [R0, #1]
        STRB    R2, [R0], #1
        TEQ     R0, R1
        BNE     %BT10

; now see if top line was a 'bottom' row
; if so, we need to rescan from the top

        LDR     R8, [WsPtr, #TTXMapPtr]         ; R8 -> top left map
        LDR     R1, [R8]                        ; R1 = dummy word
        TST     R1, #MapBit_Bottom              ; if not bottom
        BEQ     %FT20                           ; then OK

        BIC     R1, R1, #MapBit_Bottom          ; make into a 'top' line
        STR     R1, [R8]                        ; store back
        LDRB    R0, [R8, #4]                    ; R0 = first char
        MOV     R3, #0                          ; X = 0
        MOV     R11, #0                         ; Y = 0
        LDR     R2, [WsPtr, #ScreenStart]       ; screen address for top-left
        LDR     R14, [WsPtr, #TextOffset]       ; plus the offset
        ADD     R2, R2, R14

        ADR     R14, %FT20
        Push    R14
        B       TTXScanFromHere

20

; now see if new bottom line should be a 'bottom' or a 'top' line

        LDR     R1, [WsPtr, #ScrBRow]
        SUB     R1, R1, #1
        LDR     R0, [WsPtr, #TTXLineStartsPtr]
        LDR     R0, [R0, R1, LSL #2]            ; R0 -> dummy word on line 23
        LDR     R14, [WsPtr, #TTXDoubleCountsPtr]
        LDRB    R1, [R14, R1]                   ; no. of dbls on line 23
        TEQ     R1, #0                          ; if R1=0 then line 24 is 'top'
        LDRNE   R1, [R0]                        ; else line 24 is opposite
        EORNE   R1, R1, #MapBit_Bottom          ; of line 23
        ANDNE   R1, R1, #MapBit_Bottom
        LDR     R14, [WsPtr, #ScrRCol]
        ADD     R14, R14, #2
        LDR     R2, [R0, R14, LSL #2]           ; R2 = dummy word on line 24
        BIC     R2, R2, #MapBit_Bottom          ; clear that bit
        ORR     R2, R2, R1                      ; OR in new bit
        STR     R2, [R0, R14, LSL #2]           ; and store back

        Pull    PC

; *****************************************************************************
;
;       TTXSoftScrollUp - Scroll screen up by software in teletext mode
;

TTXSoftScrollUp ROUT

; first scroll map up

        LDR     R0, [WsPtr, #RowLength]         ; save real RowLength
        LDR     R1, [WsPtr, #TWTRow]            ; top row
        LDR     R3, [WsPtr, #TWBRow]            ; bottom row

        LDR     R2, [WsPtr, #TTXLineStartsPtr]
        LDR     R2, [R2, R1, LSL #2]            ; R2 -> dummy char top row
        ADD     R2, R2, #4                      ; R2 -> 0th char top row
        LDR     R4, [WsPtr, #TWLCol]
        LDR     R5, [WsPtr, #TWRCol]

        Push    "R0-R6,R14"                     ; and save CursorFlags

        ADD     R2, R2, R4, LSL #2              ; R2 -> top left char

        SUB     R5, R5, R4
        ADD     R5, R5, #1                      ; R5 = no. of chars wide
        MOV     R5, R5, LSL #2                  ; R5 = no. of bytes / line

        SUB     R6, R3, R1
        ADD     R6, R6, #1                      ; R6 = no. of 'pixel' rows

        LDR     R7, [WsPtr, #ScrRCol]
        ADD     R7, R7, #2
        MOV     R7, R7, LSL #2                  ; R7 = line length
        STR     R7, [WsPtr, #RowLength]         ; pretend row length
        MOV     R0, #1                          ; pretend rowmult =1

        BL      SoftScrollUp2

        Pull    "R0-R6"
        STR     R0, [WsPtr, #RowLength]         ; restore RowLength

; now R1=top row, R2 -> char 0 on row R1, R3=bottom row, R4=left, R5=right

; now clear bottom row

        LDR     R7, [WsPtr, #TTXLineStartsPtr]
        LDR     R7, [R7, R3, LSL #2]            ; R7 -> dummy word(bottom)
        ADD     R8, R7, R5, LSL #2              ; R8 -> char before bottom rt
        ADD     R7, R7, R4, LSL #2              ; R7 -> char before bottom left
        MOV     R0, #32
30
        STRB    R0, [R7, #4]!                   ; zap to space
        CMP     R7, R8                          ; if <= char before bottom rt
        BLS     %BT30                           ; then loop

        MOV     R9, R2
CountAndRescan
        BL      CountDoubles

; now rescan from top of window

        ADD     R10, R3, #1                     ; R10 = bottom + 1
        MOV     R11, R1                         ; R11 = top
        ADD     R7, R2, R4, LSL #2              ; R7 = map(left,top)
        ADD     R5, R2, R5, LSL #2              ; R5 = map(right,top)
        MOV     R0, R4                          ; R0 = left
TTXScanZap2
        BL      AddressR0R1                     ; R2 = screen(left,top)
                                                ; (R1,R3,R4 corrupted)
        SUB     R4, R7, #8                      ; R4 = map(left,top)-8
        MOV     R3, R0                          ; R3 = left
        LDRB    R0, [R4, #8]                    ; R0 = first char
        MOV     R14, #1                         ; scan not zap
        B       TTXScanZap

; *****************************************************************************
;
;       CountDoubles - Count double height characters in a range of rows
;
; in:   R1 = top row to count
;       R3 = bottom row to count
;       R9 -> map(0,top)
;
; out:  R1-R6 preserved
;

CountDoubles ROUT
        Entry
        LDR     R7, [WsPtr, #TTXDoubleCountsPtr]
        ADD     R7, R7, R1                      ; R7 -> current double count
        MOV     R11, R1
        LDR     R14, [WsPtr, #ScrRCol]
        ADD     R14, R14, #1
10
        ADD     R8, R9, R14, LSL #2             ; R8 -> dummy char next row
        MOV     R10, #0                         ; count so far
20
        LDR     R0, [R9], #4                    ; load char word
        AND     R0, R0, #&7F                    ; only look at bottom 7 bits
        TEQ     R0, #TTX_DoubleHeight           ; if double height
        ADDEQ   R10, R10, #1                    ; then increment count
        TEQ     R9, R8                          ; if not at end of row
        BNE     %BT20                           ; then loop

        STRB    R10, [R7], #1                   ; store double count
        ADD     R9, R9, #4                      ; skip dummy char
        ADD     R11, R11, #1                    ; goto next row
        CMP     R11, R3                         ; if <= bottom
        BLS     %BT10                           ; then loop

        EXIT

; *****************************************************************************
;
;       TTXHardScrollDown - Scroll teletext screen downwards
;

TTXHardScrollDown ROUT

; first scroll map down

        LDR     R0, [WsPtr, #RowLength]         ; save real RowLength
        Push    "R0, R6, R14"                   ; and save CursorFlags

        MOV     R0, #1                          ; pretend rowmult = 1
        LDR     R6, [WsPtr, #ScrBRow]
        LDR     R2, [WsPtr, #TTXLineStartsPtr]
        LDR     R2, [R2, R6, LSL #2]            ; R2 -> dummy char on bottom
        LDR     R5, [WsPtr, #ScrRCol]
        ADD     R5, R5, #2
        MOV     R5, R5, LSL #2                  ; R5 = no. of bytes horiz
        STR     R5, [WsPtr, #RowLength]         ; pretend rowlength
        ADD     R6, R6, #1                      ; no. of 'pixel' rows
        MOV     R7, R5                          ; linelength
        BL      SoftScrollDown2
        SUB     R14, R6, #1

        Pull    "R0, R6"
        STR     R0, [WsPtr, #RowLength]         ; restore RowLength

; now 'scroll' DoubleCounts

        LDR     R0, [WsPtr, #TTXDoubleCountsPtr]
        ADD     R1, R0, R14
10
        LDRB    R2, [R1, #-1]
        STRB    R2, [R1], #-1
        TEQ     R1, R0
        BNE     %BT10

; now make top row a 'top' row

        LDR     R0, [WsPtr, #TTXMapPtr]         ; R0 -> top line dummy word
        LDR     R1, [R0]                        ; R1 = dummy word
        BIC     R1, R1, #MapBit_Bottom          ; clear 'bottom' bit
        STR     R1, [R0]                        ; and store back

        Pull    PC

; *****************************************************************************
;
;       TTXSoftScrollDown - Scroll screen down by software in teletext mode
;

TTXSoftScrollDown ROUT

; first scroll map down

        LDR     R0, [WsPtr, #RowLength]         ; save real RowLength
        LDR     R1, [WsPtr, #TWTRow]            ; top row
        LDR     R3, [WsPtr, #TWBRow]            ; bottom row

        LDR     R2, [WsPtr, #TTXLineStartsPtr]
        LDR     R2, [R2, R3, LSL #2]            ; R2 -> dummy char bottom row
        ADD     R2, R2, #4                      ; R2 -> 0th char bottom row
        LDR     R4, [WsPtr, #TWLCol]
        LDR     R5, [WsPtr, #TWRCol]

        Push    "R0-R6,R14"                     ; and save CursorFlags

        ADD     R2, R2, R4, LSL #2              ; R2 -> bottom left char

        SUB     R5, R5, R4
        ADD     R5, R5, #1                      ; R5 = no. of chars wide
        MOV     R5, R5, LSL #2                  ; R5 = no. of bytes / line

        SUB     R6, R3, R1
        ADD     R6, R6, #1                      ; R6 = no. of 'pixel' rows

        LDR     R7, [WsPtr, #ScrRCol]
        ADD     R7, R7, #2
        MOV     R7, R7, LSL #2                  ; R7 = line length
        STR     R7, [WsPtr, #RowLength]         ; pretend row length
        MOV     R0, #1                          ; pretend rowmult =1

        BL      SoftScrollDown2

        Pull    "R0-R6"
        STR     R0, [WsPtr, #RowLength]         ; restore RowLength

; now R1=top row, R2 -> char 0 on row R3, R3=bottom row, R4=left, R5=right

; now clear top row

        LDR     R7, [WsPtr, #TTXLineStartsPtr]
        LDR     R7, [R7, R1, LSL #2]            ; R7 -> dummy word(top)
        ADD     R8, R7, R5, LSL #2              ; R8 -> char before top rt
        ADD     R7, R7, R4, LSL #2              ; R7 -> char before top left
        MOV     R0, #32
30
        STRB    R0, [R7, #4]!                   ; zap to space
        CMP     R7, R8                          ; if <= char before bottom rt
        BLS     %BT30                           ; then loop

        SUB     R9, R8, R5, LSL #2              ; R9 -> dummy word(top)
        ADD     R9, R9, #4                      ; R9 -> map(0,top)
        MOV     R2, R9
        B       CountAndRescan                  ; count doubles and rescan
                                                ; from top of window

; *****************************************************************************
;
;       TTXScrollLeft - Scroll left (by software) in Teletext mode
;
; in:   R0 bit0=0 => scroll window
;               1 => scroll screen
;

TTXScrollLeft ROUT
        Push    R14
        BL      TTXSideScroll1
        MOV     R5, R0                          ; R5 = left = column to check
                                                ; for double height chars
        BL      TTXSideScroll2                  ; do second part
        BL      ScrollLeft2

; now store spaces in right hand column

        Pull    "R0-R3, R6, R9"
        ADD     R4, R9, R2, LSL #2              ; R4 -> map(right,top)
TTXSideScroll3
        MOV     R7, R3                          ; R7 = current row
        MOV     R8, #32                         ; poke spaces
        LDR     R10, [WsPtr, #ScrRCol]
        ADD     R10, R10, #2
20
        STRB    R8, [R4], R10, LSL #2           ; store space and move down
        ADD     R7, R7, #1                      ; next row
        CMP     R7, R1                          ; if row <= bottom
        BLS     %BT20                           ; then loop

; now rescan from top of window/screen

        ADD     R10, R1, #1                     ; R10 = bottom+1
        MOV     R11, R3                         ; R11 = top
        ADD     R7, R9, R0, LSL #2              ; R7 -> map(left,top)
        ADD     R5, R9, R2, LSL #2              ; R5 -> map(right,top)
        MOV     R1, R3                          ; R1 = top
        B       TTXScanZap2

; *****************************************************************************
;
;       TTXScrollRight - Scroll right (by software) in Teletext mode
;
; in:   R0 bit0=0 => scroll window
;               1 => scroll screen
;

TTXScrollRight ROUT
        Push    R14
        BL      TTXSideScroll1
        MOV     R5, R2                          ; R5 = right = column to check
                                                ; for double height chars
        BL      TTXSideScroll2
        BL      ScrollRight2

; now store spaces in left hand column

        Pull    "R0-R3, R6, R9"
        ADD     R4, R9, R0, LSL #2              ; R4 -> map(left,top)
        B       TTXSideScroll3

; *****************************************************************************
;
;       TTXSideScroll1 - Do first part of sideways scroll
;

TTXSideScroll1 ROUT
        MOVS    R0, R0, LSR #1

; C=0 => scroll window

        ADDCC   R0, WsPtr, #TWLCol              ; R0 = left, R1 = bottom
        LDMCCIA R0, {R0-R3}                     ; R2 = right, R3 = top

; C=1 => scroll screen

        MOVCS   R0, #0                          ; left
        LDRCS   R1, [WsPtr, #ScrBRow]           ; bottom
        LDRCS   R2, [WsPtr, #ScrRCol]           ; right
        MOVCS   R3, #0                          ; top

        MOV     PC, R14

; *****************************************************************************
;
;       TTXSideScroll2 - Do second part of sideways scroll
;
; in:   R5 = left or right hand column for left or right scroll respectively
;

TTXSideScroll2 ROUT

; first check char R5 on each line and decrement double count if a double

        LDR     R4, [WsPtr, #TTXLineStartsPtr]
        LDR     R4, [R4, R3, LSL #2]            ; R4 -> map(dummy,top)
        ADD     R9, R4, #4                      ; R9 -> map(0,top)
        ADD     R4, R9, R5, LSL #2              ; R4 -> map(left or right,top)
        Push    "R9"

        LDR     R9, [WsPtr, #ScrRCol]
        ADD     R9, R9, #2

        LDR     R5, [WsPtr, #TTXDoubleCountsPtr]
        MOV     R7, R3                          ; R7 = current row
10
        LDR     R8, [R4], R9, LSL #2            ; get char+attr
        AND     R8, R8, #&7F
        TEQ     R8, #TTX_DoubleHeight           ; test if double height char

        LDREQB  R8, [R5, R7]                    ; if so then load double count
        SUBEQ   R8, R8, #1                      ; decrement it
        STREQB  R8, [R5, R7]                    ; and store back

        ADD     R7, R7, #1                      ; next row
        CMP     R7, R1                          ; if row <= bottom
        BLS     %BT10                           ; then loop

; now scroll map

        MOV     R7, R9, LSL #2                  ; linelength
        LDR     R9, [sp]
        Push    "R0-R3, R6"
        SUB     R5, R2, R0                      ; R5 = right-left
        ADD     R5, R5, #1                      ; R5 = right-left+1
        MOV     R5, R5, LSL #2                  ; R5 = (right-left+1)*4
        ADD     R2, R9, R0, LSL #2              ; R2 -> map(left,top)
        SUB     R6, R1, R3                      ; R6 = bottom-top
        ADD     R6, R6, #1                      ; R6 = bottom-top+1
        MOV     R9, #4                          ; no. of bytes to scroll by

        MOV     PC, R14

; *****************************************************************************
;
;       UpdateHeldBits - change the held graphic bits of R0 if necessary
;       TTXPaintChar used to have this functionality
;

UpdateHeldBits ROUT
        TST     R0, #&60 :OR: MapBit_Hold       ; if a control code and not holding,
        BICEQ   R0, R0, #MapBit_HeldMask        ; clear mask
        MOVEQ   PC, R14

        TST     R0, #MapBit_Graph
        TSTNE   R0, #&20                        ; if not a graphic character,
        MOVEQ   PC, R14                         ; preserve the bits that were copied from the previous character

        BIC     R0, R0, #MapBit_HeldMask        ; else copy the character to the held graphic bits
        ORR     R0, R0, R0, LSL #MapHeldShift
        TST     R0, #MapBit_Separated
        BICEQ   R0, R0, #MapBit_HeldSeparated
        ORRNE   R0, R0, #MapBit_HeldSeparated
        MOV     PC, R14

; *****************************************************************************
;
;       TTXPaintChar - Paint char according to attributes
;
; in:   R0 = character + attributes word
;       R2 -> screen (for the time being)
;
; out:  R3, R12 corrupt

TTXPaintChar ROUT
        Entry   "R1,R4-R11"
        VDWS    WsPtr                           ; for now

; first set up the colours

        ADD     R1, WsPtr, #TForeCol
        LDMIA   R1, {R1, R3}                    ; R1 = TForeCol; R3 = TBackCol
        MOV     R4, #&0F
        LDR     R14, [WsPtr, #TTXFlags]
        BIC     R5, R0, R14                     ; apply BIC masks
        EOR     R14, R5, R14, LSL #8            ; apply EOR masks
        AND     R5, R4, R14, LSR #MapForeShift  ; R5 = new foregd colour
        AND     R6, R4, R14, LSR #MapBackShift  ; R6 = new backgd colour

        TEQ     R1, R5                          ; if foregd different
        TEQEQ   R3, R6                          ; or backgd different
        BLNE    TTXUpdateColours                ; then update colour table

      [ HiResTTX
        ADRL    R1, TTXHardFont-32*40           ; R1 -> base for font
      |
        ADRL    R1, TTXHardFont-32*10           ; R1 -> base for font
      ]
        MOVS    R3, R0, LSL #26                 ; C := bit6, N := bit5
        AND     R3, R0, #&7F                    ; R3 = char
        BMI     %FT10                           ; [&20-&3F or &60-&7F]
        BCS     %FT20                           ; [&40-&5F (definitely Alpha)]

; control code, so display as space or held graphic

        TST     R0, #MapBit_Hold                ; zero if not holding
        MOVEQ   R3, #&20                        ; pretend to be space
        BEQ     %FT20                           ; [display as space]

; next instruction assumes no valid bits above held graphic bits

        MOV     R3, R0, LSR #MapHeldShift       ; R3 = char to display
        B       %FT30                           ; [display as held graphic]

; char in range &20-&3F or &60-&7F, so check for alpha/graphics

10
        TST     R0, #MapBit_Graph               ; in graphics mode
        BEQ     %FT20                           ; [no, so definitely Alpha]
        TST     R0, #MapBit_Separated           ; separated graphics ?
        BICEQ   R3, R3, #&20                    ; no, then make &00-&1F,&40-&5F
30
        ADD     R1, WsPtr, #TTXSoftFonts
      [ HiResTTX
        TST     R3, #&5F                        ; if a space
        ADREQL  R1, TTXHardFont                 ; then just use the hard font, for speed
        BLNE    ComputeGraphic                  ; else generate the bitmap
        B       %FT40
20
        ADD     R1, R1, R3, LSL #5              ; add 32*char
        ADD     R1, R1, R3, LSL #3              ; add 8*char
40
      |
20
        ADD     R1, R1, R3, LSL #3              ; add 8*char
        ADD     R1, R1, R3, LSL #1              ; add 2*char
      ]

        TST     R0, #MapBit_Conceal             ; concealing ?
        LDRNE   R14, [WsPtr, #TTXFlags]
        TSTNE   R14, #TTXFlag_Conceal           ; and reveal is off?
        ADRNEL  R1, TTXHardFont                 ; yes, then display as space

 [ :LNOT: HiResTTX
; now load font bytes
; 0..3 into tophalf
; 4..7 into bottomhalf
; 8..9 into R10 (top 2 bytes)

        TST     R1, #2                          ; starting on a word bdy ?

        SUBNE   R1, R1, #2                      ; if not, move back
        LDMIA   R1, {tophalf, bottomhalf, R10}  ; yes, so load all 3 up
        MOVEQ   R10, R10, LSL #16
        MOVNE   tophalf, tophalf, LSR #16
        ORRNE   tophalf, tophalf, bottomhalf, LSL #16
        MOVNE   bottomhalf, bottomhalf, LSR #16
        ORRNE   bottomhalf, bottomhalf, R10, LSL #16

        TST     R0, #(MapBit_Bottom :OR: MapBit_Double)
        BLNE    PrintDoubleHeight

        LDR     bigfont, [WsPtr, #TextExpandArea]
        MOV     mask, #&FF000000
        LDR     linelen, [WsPtr, #LineLength]
        Push    "R0, screen"
        MOV     R0, #0                          ; indicate 10 rows
        BL      Wrch4bitTTX                     ; do 1st bank

        LDMFD   R13, {R0, screen}               ; restore char + scr. addr
        LDR     byte, [WsPtr, #ScreenSize]
        ADD     screen, screen, byte, LSR #1    ; point to 2nd bank
        TST     R0, #MapBit_Flash
        MOVNE   mask, #0                        ; flash => 2nd bank is space
        MOV     R0, #0
        BL      Wrch4bitTTX
        Pull    "R0, screen"
        EXIT
 |
; here we do the two screen banks in an outer loop and have a
; 5-stage inner loop each time plotting 4 rows (1/5th of the character)

        TST     R0, #MapBit_Bottom              ; for bottom-half characters
        ADDNE   R1, R1, #2*10                   ; start half-way through the character

        LDR     bigfont, [WsPtr, #TextExpandArea]

        MOV     mask, #&FF000000
        LDR     linelen, [WsPtr, #LineLength]
        LDR     byte, [WsPtr, #CharWidth]
        SUB     linelen, linelen, byte, LSR #1  ; adjust line offset to account for performing two screen writes per row

        Push    "R1, screen"
        BL      WrchHiResTTX                    ; do 1st bank

        LDMFD   R13, {R1, screen}               ; restore pointers to character and screen address
        LDR     byte, [WsPtr, #ScreenSize]
        ADD     screen, screen, byte, LSR #1    ; point to 2nd bank
        TST     R0, #MapBit_Flash
        MOVNE   mask, #0                        ; flash => 2nd bank is space
        BL      WrchHiResTTX                    ; do 2nd bank

        Pull    "R1, screen"
        EXIT


; *****************************************************************************
;
;       WrchHiResTTX - Write a high-res teletext char to screen
;
; in:   R0 = character + attributes word
;       R1 -> character definition
;       screen -> screen
;       bigfont -> font definition
;       mask = &FF000000 for normal, &0 for blank
;       linelen = LineLength-(CharWidth/2)
;
; out:  tophalf, bottomhalf, byte, scrbyte, scrbyte2, R7 corrupt
;

WrchHiResTTX ROUT
        Entry
        LDR     R7, [WsPtr, #Log2BPP]
        ADR     R14, WrchHiResTTXTab - 8
        LDR     R14, [R14, R7, LSL #2]

        MOV     R7, #4                          ; do each plot in 5 stages; R7 holds stage number
01      TST     R0, #MapBit_Double
        LDMEQIA R1!, {tophalf, bottomhalf}      ; single height characters, load 4 rows
        LDRNE   tophalf, [R1], #4               ; double height characters, load 2 rows
        MOVNE   bottomhalf, tophalf, LSR #16    ; and double up
        ORRNE   bottomhalf, bottomhalf, bottomhalf, LSL #16
        MOVNE   tophalf, tophalf, LSL #16
        ORRNE   tophalf, tophalf, tophalf, LSR #16
        AND     byte, R0, #(MapBit_Double :OR: MapBit_Bottom) ; byte is used here as a scratch register
        TEQ     byte, #MapBit_Bottom            ; if single height on line below top-half double height,
        MOVEQ   tophalf, #0                     ; make it invisible
        MOVEQ   bottomhalf, #0
        MOV     PC, R14                         ; call routine

WrchHiResTTX8
        AND     byte, mask, tophalf, LSL #16
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, tophalf, LSL #24
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        AND     byte, mask, tophalf
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, tophalf, LSL #8
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #16
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, bottomhalf, LSL #24
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        AND     byte, mask, bottomhalf
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, bottomhalf, LSL #8
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        SUBS    R7, R7, #1
        BPL     %BT01
        EXIT

WrchHiResTTX4
        AND     byte, mask, tophalf, LSL #16
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], #4
        AND     byte, mask, tophalf, LSL #24
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen
        AND     byte, mask, tophalf
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], #4
        AND     byte, mask, tophalf, LSL #8
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen

        AND     byte, mask, bottomhalf, LSL #16
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], #4
        AND     byte, mask, bottomhalf, LSL #24
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen
        AND     byte, mask, bottomhalf
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], #4
        AND     byte, mask, bottomhalf, LSL #8
        LDR     scrbyte, [bigfont, byte, LSR #22]
        STR     scrbyte, [screen], linelen

        SUBS    R7, R7, #1
        BPL     %BT01
        EXIT

WrchHiResTTX16
        SUB     linelen, linelen, #16
        AND     byte, mask, tophalf, LSL #16
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, tophalf, LSL #24
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        AND     byte, mask, tophalf
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, tophalf, LSL #8
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #16
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, bottomhalf, LSL #24
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        AND     byte, mask, bottomhalf
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, bottomhalf, LSL #8
        ADD     byte, bigfont, byte, LSR #20
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        SUBS    R7, R7, #1
        ADD     linelen, linelen, #16
        BPL     %BT01
        EXIT

WrchHiResTTX32
        SUB     linelen, linelen, #32
        AND     byte, mask, tophalf, LSL #16
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, tophalf, LSL #24
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        AND     byte, mask, tophalf
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, tophalf, LSL #8
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #16
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, bottomhalf, LSL #24
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        AND     byte, mask, bottomhalf
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, bottomhalf, LSL #8
        ADD     byte, bigfont, byte, LSR #19
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        LDMIA   byte!, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        SUBS    R7, R7, #1
        ADD     linelen, linelen, #32
        BPL     %BT01
        EXIT

WrchHiResTTXTab
        &       WrchHiResTTX4
        &       WrchHiResTTX8
        &       WrchHiResTTX16
        &       WrchHiResTTX32
 ]

; *****************************************************************************

        LTORG

; *****************************************************************************
;
;       DoPreControl  - Process 'at'    action of control char
;       DoPostControl - Process 'after' action of control char
;
; in:   R0 = new char + attributes of current previous char
;       R1 = new char AND &7F
;       (0 <= R1 <= 31)
;       R9 = double height char counter
;
; out:  R0 = updated char + attributes
;       R3 = corrupt
;       R9 = updated
;

DoPreControl ROUT
        ADD     PC, PC, R1, LSL #3
DoPostControl ROUT
        ADD     PC, PC, R1, LSL #3
        MOV     PC, R14                 ; &00 Pre
        B       DoAlphaBlack            ; &00 Post
        MOV     PC, R14                 ; &01 Pre
        B       DoAlphaColour           ; &01 Post
        MOV     PC, R14                 ; &02 Pre
        B       DoAlphaColour           ; &02 Post
        MOV     PC, R14                 ; &03 Pre
        B       DoAlphaColour           ; &03 Post
        MOV     PC, R14                 ; &04 Pre
        B       DoAlphaColour           ; &04 Post
        MOV     PC, R14                 ; &05 Pre
        B       DoAlphaColour           ; &05 Post
        MOV     PC, R14                 ; &06 Pre
        B       DoAlphaColour           ; &06 Post
        MOV     PC, R14                 ; &07 Pre
        B       DoAlphaColour           ; &07 Post
        MOV     PC, R14                 ; &08 Pre
        B       DoFlash                 ; &08 Post
        BIC     R0, R0, #MapBit_Flash   ; &09 Pre       ; clear flash mode
        MOV     PC, R14                 ; &09 Post
        B       DoPreEndBox             ; &0A Pre
        B       DoPostEndBox            ; &0A Post
        B       DoPreStartBox           ; &0B Pre
        B       DoPostStartBox          ; &0B Post
        B       DoSingleHeight          ; &0C Pre
        MOV     PC, R14                 ; &0C Post
        B       DoDoubleHeight          ; &0D Pre
        MOV     PC, R14                 ; &0D Post
        MOV     PC, R14                 ; &0E Pre
        MOV     PC, R14                 ; &0E Post
        MOV     PC, R14                 ; &0F Pre
        MOV     PC, R14                 ; &0F Post
        MOV     PC, R14                 ; &10 Pre
        B       DoGraphBlack            ; &10 Post
        MOV     PC, R14                 ; &11 Pre
        B       DoGraphColour           ; &11 Post
        MOV     PC, R14                 ; &12 Pre
        B       DoGraphColour           ; &12 Post
        MOV     PC, R14                 ; &13 Pre
        B       DoGraphColour           ; &13 Post
        MOV     PC, R14                 ; &14 Pre
        B       DoGraphColour           ; &14 Post
        MOV     PC, R14                 ; &15 Pre
        B       DoGraphColour           ; &15 Post
        MOV     PC, R14                 ; &16 Pre
        B       DoGraphColour           ; &16 Post
        MOV     PC, R14                 ; &17 Pre
        B       DoGraphColour           ; &17 Post
        ORR     R0, R0, #MapBit_Conceal ; &18 Pre       ; set conceal mode
        MOV     PC, R14                 ; &18 Post
        MOV     PC, R14                 ; &19 Pre
        BIC     R0, R0, #MapBit_Separated ; &19 Post    ; clear separated
        MOV     PC, R14                 ; &1A Pre
        ORR     R0, R0, #MapBit_Separated ; &1A Post    ; set separated
        MOV     PC, R14                 ; &1B Pre
        MOV     PC, R14                 ; &1B Post
        BIC     R0, R0, #MapBit_BackMask ; &1C Pre      ; clear backgd colour
        MOV     PC, R14                 ; &1C Post
        B       DoNewBackgd             ; &1D Pre
        MOV     PC, R14                 ; &1D Post
        ORR     R0, R0, #MapBit_Hold    ; &1E Pre       ; set hold graph mode
        MOV     PC, R14                 ; &1E Post
        MOV     PC, R14                 ; &1F Pre
        BIC     R0, R0, #MapBit_Hold    ; &1F Post      ; clear hold graph mode
        MOV     PC, R14

; *****************************************************************************

DoAlphaBlack
        LDR     R3, [WsPtr, #TTXFlags]
        TST     R3, #TTXFlag_BlackEnable        ; unless enabled,
        MOVEQ   PC, R14                         ; do nothing
        ; drop through...
DoAlphaColour
        BIC     R0, R0, #MapBit_HeldMask        ; clear held graphic
        BIC     R0, R0, #(MapBit_ForeMask :OR: MapBit_Conceal)
                                                ; clear colour + conceal
        ORR     R0, R0, R1, LSL #MapForeShift   ; put in new colour
        BIC     R0, R0, #MapBit_Graph           ; set alpha mode
        MOV     PC, R14

DoGraphBlack
        LDR     R3, [WsPtr, #TTXFlags]
        TST     R3, #TTXFlag_BlackEnable        ; unless enabled,
        MOVEQ   PC, R14                         ; do nothing
        ; drop through...
DoGraphColour
        BIC     R0, R0, #(MapBit_ForeMask :OR: MapBit_Conceal)
                                                ; clear colour + conceal
        AND     R3, R1, #&07                    ; ensure only colour bits
        ORR     R0, R0, R3, LSL #MapForeShift   ; put in new colour
        ORR     R0, R0, #MapBit_Graph           ; set graph mode
        MOV     PC, R14

DoFlash
        ORR     R0, R0, #MapBit_Flash           ; set flash mode
        MOV     PC, R14

DoNewBackgd
        AND     R3, R0, #MapBit_ForeMask        ; R5 = fore colour
        BIC     R0, R0, #MapBit_BackMask        ; clear old backgd
        ORR     R0, R0, R3, LSL #(MapBackShift-MapForeShift) ; new backgd
        MOV     PC, R14

DoDoubleHeight
        TST     R0, #MapBit_Double              ; if currently single height
        BICEQ   R0, R0, #MapBit_HeldMask        ; then cancel held graphic
        ORR     R0, R0, #MapBit_Double          ; set double height mode
        ADD     R9, R9, #1                      ; one more double char
        MOV     PC, R14

DoSingleHeight
        TST     R0, #MapBit_Double              ; if currently double height
        BICNE   R0, R0, #MapBit_HeldMask        ; then cancel held graphic
        BIC     R0, R0, #MapBit_Double          ; set single height mode
        MOV     PC, R14

DoPreStartBox
        TST     R0, #MapBit_PendingStart        ; if prev char was start box
        ORRNE   R0, R0, #MapBits_Boxed          ; then start boxed area
        MOV     PC, R14

DoPostStartBox
        ORR     R0, R0, #MapBit_PendingStart    ; "Previous char is Start Box"
        MOV     PC, R14

DoPreEndBox
        TST     R0, #MapBit_PendingEnd          ; if prev char was end box
        BICNE   R0, R0, #MapBits_Boxed          ; then end boxed area
        MOV     PC, R14

DoPostEndBox
        ORR     R0, R0, #MapBit_PendingEnd      ; "Previous char is End Box"
        MOV     PC, R14

; *****************************************************************************

TTXHardFont
 [ HiResTTX
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000 ; space
        DCW     &0000,&0000,&0300,&0300,&0300,&0300,&0300,&0300,&0300,&0300,&0300,&0300,&0000,&0000,&0300,&0300,&0000,&0000,&0000,&0000 ; !
        DCW     &0000,&0000,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000 ; "
        DCW     &0000,&0000,&03F0,&07F8,&0E1C,&0C0C,&0C00,&0C00,&3F80,&3F80,&0C00,&0C00,&0C00,&0C00,&3FFC,&3FFC,&0000,&0000,&0000,&0000 ; 
        DCW     &0000,&0000,&0FF0,&1FF8,&399C,&318C,&3180,&3980,&1FF0,&0FF8,&019C,&018C,&318C,&399C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; $
        DCW     &0000,&0000,&3C00,&3C0C,&3C1C,&3C38,&0070,&00E0,&01C0,&0380,&0700,&0E00,&1C3C,&383C,&303C,&003C,&0000,&0000,&0000,&0000 ; %
        DCW     &0000,&0000,&0E00,&1F00,&3B80,&3180,&3380,&3F00,&1E00,&1F00,&3F8C,&31DC,&30F8,&3878,&1FFC,&0FCC,&0000,&0000,&0000,&0000 ; &
        DCW     &0000,&0000,&0180,&0180,&0180,&0180,&0180,&0180,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000 ; '
        DCW     &0000,&0000,&0060,&00E0,&01C0,&0380,&0700,&0600,&0600,&0600,&0600,&0700,&0380,&01C0,&00E0,&0060,&0000,&0000,&0000,&0000 ; (
        DCW     &0000,&0000,&0600,&0700,&0380,&01C0,&00E0,&0060,&0060,&0060,&0060,&00E0,&01C0,&0380,&0700,&0600,&0000,&0000,&0000,&0000 ; )
        DCW     &0000,&0000,&0180,&318C,&399C,&1DB8,&0FF0,&07E0,&03C0,&03C0,&07E0,&0FF0,&1DB8,&399C,&318C,&0180,&0000,&0000,&0000,&0000 ; *
        DCW     &0000,&0000,&0000,&0000,&0180,&0180,&0180,&0180,&3FFC,&3FFC,&0180,&0180,&0180,&0180,&0000,&0000,&0000,&0000,&0000,&0000 ; +
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0180,&0180,&0180,&0180,&0380,&0300,&0000,&0000 ; ,
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0FF0,&0FF0,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000 ; -
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0180,&0180,&0000,&0000,&0000,&0000 ; .
        DCW     &0000,&0000,&0000,&0018,&0038,&0070,&00E0,&01C0,&0380,&0700,&0E00,&1C00,&1800,&0000,&0000,&0000,&0000,&0000,&0000,&0000 ; /
        DCW     &0000,&0000,&03C0,&07E0,&0E70,&1C38,&381C,&300C,&300C,&300C,&300C,&381C,&1C38,&0E70,&07E0,&03C0,&0000,&0000,&0000,&0000 ; 0
        DCW     &0000,&0000,&0180,&0180,&0F80,&0F80,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0FF0,&0FF0,&0000,&0000,&0000,&0000 ; 1
        DCW     &0000,&0000,&0FF0,&1FF8,&381C,&300C,&000C,&001C,&07F8,&0FF0,&1C00,&3800,&3000,&3000,&3FFC,&3FFC,&0000,&0000,&0000,&0000 ; 2
        DCW     &0000,&0000,&3FFC,&3FFC,&001C,&0038,&0070,&00E0,&01F8,&01FC,&000C,&000C,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; 3
        DCW     &0000,&0000,&0070,&00F0,&01F0,&03B0,&0730,&0E30,&1C30,&3830,&3FFC,&3FFC,&0030,&0030,&0030,&0030,&0000,&0000,&0000,&0000 ; 4
        DCW     &0000,&0000,&3FFC,&3FFC,&3000,&3000,&3FF0,&3FF8,&001C,&000C,&000C,&000C,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; 5
        DCW     &0000,&0000,&01F0,&07F0,&0F00,&1C00,&3800,&3000,&3FF0,&3FF8,&301C,&300C,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; 6
        DCW     &0000,&0000,&3FFC,&3FFC,&000C,&001C,&0038,&0070,&00E0,&01C0,&0380,&0700,&0600,&0600,&0600,&0600,&0000,&0000,&0000,&0000 ; 7
        DCW     &0000,&0000,&0FF0,&1FF8,&381C,&300C,&300C,&381C,&1FF8,&1FF8,&381C,&300C,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; 8
        DCW     &0000,&0000,&0FF0,&1FF8,&381C,&300C,&300C,&380C,&1FFC,&0FFC,&000C,&001C,&0038,&00F0,&0FE0,&0F80,&0000,&0000,&0000,&0000 ; 9
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0180,&0180,&0000,&0000,&0000,&0000,&0000,&0000,&0180,&0180,&0000,&0000,&0000,&0000 ; :
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0180,&0180,&0000,&0000,&0000,&0000,&0180,&0180,&0180,&0180,&0380,&0300,&0000,&0000 ; ;
        DCW     &0000,&0000,&0060,&00E0,&01C0,&0380,&0700,&0E00,&1C00,&1C00,&0E00,&0700,&0380,&01C0,&00E0,&0060,&0000,&0000,&0000,&0000 ; <
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&3FFC,&3FFC,&0000,&0000,&3FFC,&3FFC,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000 ; =
        DCW     &0000,&0000,&0600,&0700,&0380,&01C0,&00E0,&0070,&0038,&0038,&0070,&00E0,&01C0,&0380,&0700,&0600,&0000,&0000,&0000,&0000 ; >
        DCW     &0000,&0000,&0FE0,&1FF0,&3838,&3018,&0038,&0070,&00E0,&01C0,&0180,&0180,&0000,&0000,&0180,&0180,&0000,&0000,&0000,&0000 ; ?
        DCW     &0000,&0000,&0FF0,&1FF8,&381C,&300C,&31FC,&31FC,&318C,&318C,&31FC,&31FC,&3000,&3800,&1FF0,&0FF0,&0000,&0000,&0000,&0000 ; @@
        DCW     &0000,&0000,&0180,&03C0,&07E0,&0E70,&1C38,&381C,&300C,&300C,&3FFC,&3FFC,&300C,&300C,&300C,&300C,&0000,&0000,&0000,&0000 ; A
        DCW     &0000,&0000,&3FF0,&3FF8,&301C,&300C,&300C,&301C,&3FF8,&3FF8,&301C,&300C,&300C,&301C,&3FF8,&3FF0,&0000,&0000,&0000,&0000 ; B
        DCW     &0000,&0000,&0FF0,&1FF8,&381C,&300C,&3000,&3000,&3000,&3000,&3000,&3000,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; C
        DCW     &0000,&0000,&3FF0,&3FF8,&301C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&301C,&3FF8,&3FF0,&0000,&0000,&0000,&0000 ; D
        DCW     &0000,&0000,&3FFC,&3FFC,&3000,&3000,&3000,&3000,&3FF0,&3FF0,&3000,&3000,&3000,&3000,&3FFC,&3FFC,&0000,&0000,&0000,&0000 ; E
        DCW     &0000,&0000,&3FFC,&3FFC,&3000,&3000,&3000,&3000,&3FF0,&3FF0,&3000,&3000,&3000,&3000,&3000,&3000,&0000,&0000,&0000,&0000 ; F
        DCW     &0000,&0000,&0FF0,&1FF8,&381C,&300C,&3000,&3000,&3000,&3000,&303C,&303C,&300C,&380C,&1FFC,&0FFC,&0000,&0000,&0000,&0000 ; G
        DCW     &0000,&0000,&300C,&300C,&300C,&300C,&300C,&300C,&3FFC,&3FFC,&300C,&300C,&300C,&300C,&300C,&300C,&0000,&0000,&0000,&0000 ; H
        DCW     &0000,&0000,&0FF0,&0FF0,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0FF0,&0FF0,&0000,&0000,&0000,&0000 ; I
        DCW     &0000,&0000,&000C,&000C,&000C,&000C,&000C,&000C,&000C,&000C,&000C,&000C,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; J
        DCW     &0000,&0000,&1818,&1838,&1870,&18E0,&19C0,&1B80,&1F00,&1F00,&1B80,&19C0,&18E0,&1870,&1838,&1818,&0000,&0000,&0000,&0000 ; K
        DCW     &0000,&0000,&3000,&3000,&3000,&3000,&3000,&3000,&3000,&3000,&3000,&3000,&3000,&3000,&3FFC,&3FFC,&0000,&0000,&0000,&0000 ; L
        DCW     &0000,&0000,&300C,&300C,&381C,&3C3C,&3E7C,&37EC,&33CC,&318C,&300C,&300C,&300C,&300C,&300C,&300C,&0000,&0000,&0000,&0000 ; M
        DCW     &0000,&0000,&300C,&300C,&380C,&3C0C,&3E0C,&370C,&338C,&31CC,&30EC,&307C,&303C,&301C,&300C,&300C,&0000,&0000,&0000,&0000 ; N
        DCW     &0000,&0000,&0FF0,&1FF8,&381C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; O
        DCW     &0000,&0000,&3FF0,&3FF8,&301C,&300C,&300C,&301C,&3FF8,&3FF0,&3000,&3000,&3000,&3000,&3000,&3000,&0000,&0000,&0000,&0000 ; P
        DCW     &0000,&0000,&0FF0,&1FF8,&381C,&300C,&300C,&300C,&300C,&300C,&30CC,&30EC,&3078,&3838,&1FFC,&0FCC,&0000,&0000,&0000,&0000 ; Q
        DCW     &0000,&0000,&3FF0,&3FF8,&301C,&300C,&300C,&301C,&3FF8,&3FF0,&31C0,&30E0,&3070,&3038,&301C,&300C,&0000,&0000,&0000,&0000 ; R
        DCW     &0000,&0000,&0FF0,&1FF8,&381C,&300C,&3000,&3800,&1FF0,&0FF8,&001C,&000C,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; S
        DCW     &0000,&0000,&3FFC,&3FFC,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0000,&0000,&0000,&0000 ; T
        DCW     &0000,&0000,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; U
        DCW     &0000,&0000,&300C,&300C,&300C,&300C,&381C,&1818,&1C38,&0C30,&0E70,&07E0,&03C0,&03C0,&0180,&0180,&0000,&0000,&0000,&0000 ; V
        DCW     &0000,&0000,&300C,&300C,&300C,&300C,&300C,&300C,&318C,&318C,&318C,&318C,&318C,&3FFC,&1FF8,&0E70,&0000,&0000,&0000,&0000 ; W
        DCW     &0000,&0000,&300C,&300C,&381C,&1C38,&0E70,&07E0,&03C0,&03C0,&07E0,&0E70,&1C38,&381C,&300C,&300C,&0000,&0000,&0000,&0000 ; X
        DCW     &0000,&0000,&300C,&300C,&381C,&1C38,&0E70,&07E0,&03C0,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0000,&0000,&0000,&0000 ; Y
        DCW     &0000,&0000,&3FFC,&3FFC,&001C,&0038,&0070,&00E0,&01C0,&0380,&0700,&0E00,&1C00,&3800,&3FFC,&3FFC,&0000,&0000,&0000,&0000 ; Z
        DCW     &0000,&0000,&0000,&0000,&0300,&0700,&0E00,&1C00,&3FFC,&3FFC,&1C00,&0E00,&0700,&0300,&0000,&0000,&0000,&0000,&0000,&0000 ; 
        DCW     &0000,&0000,&3000,&3000,&3000,&3000,&3000,&3000,&3000,&3000,&31F0,&31F8,&000C,&000C,&0018,&0070,&00C0,&0180,&01FC,&01FC ; 
        DCW     &0000,&0000,&0000,&0000,&00C0,&00E0,&0070,&0038,&3FFC,&3FFC,&0038,&0070,&00E0,&00C0,&0000,&0000,&0000,&0000,&0000,&0000 ; 
        DCW     &0000,&0000,&0000,&0000,&0180,&03C0,&07E0,&0FF0,&1DB8,&1998,&0180,&0180,&0180,&0180,&0000,&0000,&0000,&0000,&0000,&0000 ; 
        DCW     &0000,&0000,&0630,&0630,&0630,&0630,&1FFC,&1FFC,&0630,&0630,&1FFC,&1FFC,&0630,&0630,&0630,&0630,&0000,&0000,&0000,&0000 ; #
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&FFFF,&FFFF,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000,&0000 ; 
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&1FF0,&1FF8,&001C,&000C,&1FFC,&3FFC,&300C,&300C,&3FFC,&1FFC,&0000,&0000,&0000,&0000 ; a
        DCW     &0000,&0000,&3000,&3000,&3000,&3000,&3FF0,&3FF8,&301C,&300C,&300C,&300C,&300C,&301C,&3FF8,&3FF0,&0000,&0000,&0000,&0000 ; b
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0FFC,&1FFC,&3800,&3000,&3000,&3000,&3000,&3800,&1FFC,&0FFC,&0000,&0000,&0000,&0000 ; c
        DCW     &0000,&0000,&000C,&000C,&000C,&000C,&0FFC,&1FFC,&380C,&300C,&300C,&300C,&300C,&380C,&1FFC,&0FFC,&0000,&0000,&0000,&0000 ; d
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0FF0,&1FF8,&381C,&300C,&3FFC,&3FFC,&3000,&3800,&1FF8,&0FF8,&0000,&0000,&0000,&0000 ; e
        DCW     &0000,&0000,&0030,&00F0,&01C0,&0180,&0180,&0180,&0FF0,&0FF0,&0180,&0180,&0180,&0180,&0180,&0180,&0000,&0000,&0000,&0000 ; f
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0FFC,&1FFC,&380C,&300C,&300C,&300C,&300C,&380C,&1FFC,&0FFC,&000C,&001C,&0FF8,&0FF0 ; g
        DCW     &0000,&0000,&3000,&3000,&3000,&3000,&3FF0,&3FF8,&301C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&0000,&0000,&0000,&0000 ; h
        DCW     &0000,&0000,&0180,&0180,&0000,&0000,&0F80,&0F80,&0180,&0180,&0180,&0180,&0180,&0180,&0FF0,&0FF0,&0000,&0000,&0000,&0000 ; i
        DCW     &0000,&0000,&0180,&0180,&0000,&0000,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0380,&0F00,&0C00 ; j
        DCW     &0000,&0000,&1800,&1800,&1800,&1800,&1818,&1838,&18F0,&1BC0,&1F80,&1F80,&19C0,&18F0,&1838,&1818,&0000,&0000,&0000,&0000 ; k
        DCW     &0000,&0000,&0F80,&0F80,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0180,&0FF0,&0FF0,&0000,&0000,&0000,&0000 ; l
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&3E30,&3FF8,&33FC,&318C,&318C,&318C,&318C,&318C,&318C,&318C,&0000,&0000,&0000,&0000 ; m
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&3FF0,&3FF8,&301C,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&0000,&0000,&0000,&0000 ; n
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0FF0,&1FF8,&381C,&300C,&300C,&300C,&300C,&381C,&1FF8,&0FF0,&0000,&0000,&0000,&0000 ; o
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&3FF0,&3FF8,&301C,&300C,&300C,&300C,&300C,&301C,&3FF8,&3FF0,&3000,&3000,&3000,&3000 ; p
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0FFC,&1FFC,&380C,&300C,&300C,&300C,&300C,&380C,&1FFC,&0FFC,&000C,&000C,&000C,&000C ; q
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&31FC,&33FC,&3E00,&3C00,&3000,&3000,&3000,&3000,&3000,&3000,&0000,&0000,&0000,&0000 ; r
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&0FFC,&1FFC,&3000,&3000,&1FF0,&0FF8,&000C,&000C,&3FF8,&3FF0,&0000,&0000,&0000,&0000 ; s
        DCW     &0000,&0000,&0180,&0180,&0180,&0180,&0FF0,&0FF0,&0180,&0180,&0180,&0180,&0180,&01C0,&00F0,&0030,&0000,&0000,&0000,&0000 ; t
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&380C,&1FFC,&0FFC,&0000,&0000,&0000,&0000 ; u
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&300C,&300C,&300C,&381C,&1818,&1C38,&0E70,&07E0,&03C0,&0180,&0000,&0000,&0000,&0000 ; v
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&300C,&300C,&300C,&300C,&318C,&318C,&318C,&3FFC,&1FF8,&0E70,&0000,&0000,&0000,&0000 ; w
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&300C,&381C,&1E78,&0FF0,&03C0,&03C0,&0FF0,&1E78,&381C,&300C,&0000,&0000,&0000,&0000 ; x
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&300C,&300C,&300C,&300C,&300C,&300C,&300C,&380C,&1FFC,&0FFC,&000C,&001C,&0FF8,&0FF0 ; y
        DCW     &0000,&0000,&0000,&0000,&0000,&0000,&3FFC,&3FFC,&0038,&00F0,&01E0,&0780,&0F00,&1C00,&3FFC,&3FFC,&0000,&0000,&0000,&0000 ; z
        DCW     &0000,&0000,&1800,&1800,&1800,&1800,&1800,&1800,&1800,&1800,&1818,&1838,&00F8,&0198,&0318,&0318,&03F8,&03F8,&0018,&0018 ; 
        DCW     &0000,&0000,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0C60,&0000,&0000,&0000,&0000 ; ||
        DCW     &0000,&0000,&3E00,&3F00,&0180,&0180,&3F00,&3F00,&0180,&0180,&3F0C,&3E1C,&007C,&00CC,&018C,&018C,&01FC,&01FC,&000C,&000C ; 
        DCW     &0000,&0000,&0000,&0000,&0180,&0180,&0000,&0000,&3FFC,&3FFC,&0000,&0000,&0180,&0180,&0000,&0000,&0000,&0000,&0000,&0000 ; 
        DCW     &0000,&0000,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&3FFC,&0000,&0000,&0000,&0000 ; block
 |
        =       &00,&00,&00,&00,&00,&00,&00,&00,&00,&00 ; space
        =       &00,&08,&08,&08,&08,&08,&00,&08,&00,&00 ; !
        =       &00,&14,&14,&14,&00,&00,&00,&00,&00,&00 ; "
        =       &00,&0C,&12,&10,&38,&10,&10,&3E,&00,&00 ; `
        =       &00,&1C,&2A,&28,&1C,&0A,&2A,&1C,&00,&00 ; $
        =       &00,&30,&32,&04,&08,&10,&26,&06,&00,&00 ; %
        =       &00,&10,&28,&28,&10,&2A,&24,&1A,&00,&00 ; &
        =       &00,&08,&08,&08,&00,&00,&00,&00,&00,&00 ; '
        =       &00,&04,&08,&10,&10,&10,&08,&04,&00,&00 ; (
        =       &00,&10,&08,&04,&04,&04,&08,&10,&00,&00 ; )
        =       &00,&08,&2A,&1C,&08,&1C,&2A,&08,&00,&00 ; *
        =       &00,&00,&08,&08,&3E,&08,&08,&00,&00,&00 ; +
        =       &00,&00,&00,&00,&00,&00,&08,&08,&10,&00 ; ,
        =       &00,&00,&00,&00,&1C,&00,&00,&00,&00,&00 ; -
        =       &00,&00,&00,&00,&00,&00,&00,&08,&00,&00 ; .
        =       &00,&00,&02,&04,&08,&10,&20,&00,&00,&00 ; /
        =       &00,&08,&14,&22,&22,&22,&14,&08,&00,&00 ; 0
        =       &00,&08,&18,&08,&08,&08,&08,&1C,&00,&00 ; 1
        =       &00,&1C,&22,&02,&0C,&10,&20,&3E,&00,&00 ; 2
        =       &00,&3E,&02,&04,&0C,&02,&22,&1C,&00,&00 ; 3
        =       &00,&04,&0C,&14,&24,&3E,&04,&04,&00,&00 ; 4
        =       &00,&3E,&20,&3C,&02,&02,&22,&1C,&00,&00 ; 5
        =       &00,&0C,&10,&20,&3C,&22,&22,&1C,&00,&00 ; 6
        =       &00,&3E,&02,&04,&08,&10,&10,&10,&00,&00 ; 7
        =       &00,&1C,&22,&22,&1C,&22,&22,&1C,&00,&00 ; 8
        =       &00,&1C,&22,&22,&1E,&02,&04,&18,&00,&00 ; 9
        =       &00,&00,&00,&08,&00,&00,&08,&00,&00,&00 ; :
        =       &00,&00,&00,&08,&00,&00,&08,&08,&10,&00 ; ;
        =       &00,&04,&08,&10,&20,&10,&08,&04,&00,&00 ; <
        =       &00,&00,&00,&3E,&00,&3E,&00,&00,&00,&00 ; =
        =       &00,&10,&08,&04,&02,&04,&08,&10,&00,&00 ; >
        =       &00,&1C,&22,&04,&08,&08,&00,&08,&00,&00 ; ?
        =       &00,&1C,&22,&2E,&2A,&2E,&20,&1C,&00,&00 ; @@
        =       &00,&08,&14,&22,&22,&3E,&22,&22,&00,&00 ; A
        =       &00,&3C,&22,&22,&3C,&22,&22,&3C,&00,&00 ; B
        =       &00,&1C,&22,&20,&20,&20,&22,&1C,&00,&00 ; C
        =       &00,&3C,&22,&22,&22,&22,&22,&3C,&00,&00 ; D
        =       &00,&3E,&20,&20,&3C,&20,&20,&3E,&00,&00 ; E
        =       &00,&3E,&20,&20,&3C,&20,&20,&20,&00,&00 ; F
        =       &00,&1C,&22,&20,&20,&26,&22,&1E,&00,&00 ; G
        =       &00,&22,&22,&22,&3E,&22,&22,&22,&00,&00 ; H
        =       &00,&1C,&08,&08,&08,&08,&08,&1C,&00,&00 ; I
        =       &00,&02,&02,&02,&02,&02,&22,&1C,&00,&00 ; J
        =       &00,&22,&24,&28,&30,&28,&24,&22,&00,&00 ; K
        =       &00,&20,&20,&20,&20,&20,&20,&3E,&00,&00 ; L
        =       &00,&22,&36,&2A,&22,&22,&22,&22,&00,&00 ; M
        =       &00,&22,&22,&32,&2A,&26,&22,&22,&00,&00 ; N
        =       &00,&1C,&22,&22,&22,&22,&22,&1C,&00,&00 ; O
        =       &00,&3C,&22,&22,&3C,&20,&20,&20,&00,&00 ; P
        =       &00,&1C,&22,&22,&22,&2A,&24,&1A,&00,&00 ; Q
        =       &00,&3C,&22,&22,&3C,&28,&24,&22,&00,&00 ; R
        =       &00,&1C,&22,&20,&1C,&02,&22,&1C,&00,&00 ; S
        =       &00,&3E,&08,&08,&08,&08,&08,&08,&00,&00 ; T
        =       &00,&22,&22,&22,&22,&22,&22,&1C,&00,&00 ; U
        =       &00,&22,&22,&22,&14,&14,&08,&08,&00,&00 ; V
        =       &00,&22,&22,&22,&2A,&2A,&2A,&14,&00,&00 ; W
        =       &00,&22,&22,&14,&08,&14,&22,&22,&00,&00 ; X
        =       &00,&22,&22,&14,&08,&08,&08,&08,&00,&00 ; Y
        =       &00,&3E,&02,&04,&08,&10,&20,&3E,&00,&00 ; Z
        =       &00,&00,&08,&10,&3E,&10,&08,&00,&00,&00 ; [
        =       &00,&20,&20,&20,&20,&2C,&02,&04,&08,&0E ; \
        =       &00,&00,&08,&04,&3E,&04,&08,&00,&00,&00 ; ]
        =       &00,&00,&08,&1C,&2A,&08,&08,&00,&00,&00 ; ^
        =       &00,&14,&14,&3E,&14,&3E,&14,&14,&00,&00 ; #
        =       &00,&00,&00,&00,&3E,&00,&00,&00,&00,&00 ; _
        =       &00,&00,&00,&1C,&02,&1E,&22,&1E,&00,&00 ; a
        =       &00,&20,&20,&3C,&22,&22,&22,&3C,&00,&00 ; b
        =       &00,&00,&00,&1E,&20,&20,&20,&1E,&00,&00 ; c
        =       &00,&02,&02,&1E,&22,&22,&22,&1E,&00,&00 ; d
        =       &00,&00,&00,&1C,&22,&3E,&20,&1C,&00,&00 ; e
        =       &00,&04,&08,&08,&1C,&08,&08,&08,&00,&00 ; f
        =       &00,&00,&00,&1E,&22,&22,&22,&1E,&02,&1C ; g
        =       &00,&20,&20,&3C,&22,&22,&22,&22,&00,&00 ; h
        =       &00,&08,&00,&18,&08,&08,&08,&1C,&00,&00 ; i
        =       &00,&08,&00,&08,&08,&08,&08,&08,&08,&10 ; j
        =       &00,&10,&10,&12,&14,&18,&14,&12,&00,&00 ; k
        =       &00,&18,&08,&08,&08,&08,&08,&1C,&00,&00 ; l
        =       &00,&00,&00,&34,&2A,&2A,&2A,&2A,&00,&00 ; m
        =       &00,&00,&00,&3C,&22,&22,&22,&22,&00,&00 ; n
        =       &00,&00,&00,&1C,&22,&22,&22,&1C,&00,&00 ; o
        =       &00,&00,&00,&3C,&22,&22,&22,&3C,&20,&20 ; p
        =       &00,&00,&00,&1E,&22,&22,&22,&1E,&02,&02 ; q
        =       &00,&00,&00,&16,&18,&10,&10,&10,&00,&00 ; r
        =       &00,&00,&00,&1E,&20,&1C,&02,&3C,&00,&00 ; s
        =       &00,&08,&08,&1C,&08,&08,&08,&04,&00,&00 ; t
        =       &00,&00,&00,&22,&22,&22,&22,&1E,&00,&00 ; u
        =       &00,&00,&00,&22,&22,&14,&14,&08,&00,&00 ; v
        =       &00,&00,&00,&22,&22,&2A,&2A,&14,&00,&00 ; w
        =       &00,&00,&00,&22,&14,&08,&14,&22,&00,&00 ; x
        =       &00,&00,&00,&22,&22,&22,&22,&1E,&02,&1C ; y
        =       &00,&00,&00,&3E,&04,&08,&10,&3E,&00,&00 ; z
        =       &00,&10,&10,&10,&10,&12,&06,&0A,&0E,&02 ; {
        =       &00,&14,&14,&14,&14,&14,&14,&14,&00,&00 ; |
        =       &00,&30,&08,&30,&08,&32,&06,&0A,&0E,&02 ; }
        =       &00,&00,&08,&00,&3E,&00,&08,&00,&00,&00 ; ~
        =       &00,&3E,&3E,&3E,&3E,&3E,&3E,&3E,&00,&00 ; &FF
 ]

        END
@


4.5
log
@Fix screen redirection when in teletext modes. Fix *ScreenLoad buffer overflow.
Detail:
  s/vdu/vdugrafl, s/vdu/vduttx - Adjust initialisation & shutdown of TTX workspace to fix workspace being erroneously freed/reinitialised when redirecting output to a sprite
  s/vdu/vdugrafk - If ScreenLoad needs to load one row at a time (e.g. when graphics window width != sprite width), allocate a block from the RMA instead of assuming that ScrLoaBuffer is large enough
  hdr/KernelWS - Get rid of ScrLoaBuffer, and shrink LargeCommon to a suitable size. Frees about 2K of VDU workspace.
  s/GetAll - Move Hdr:Sprite earlier in list of GETs
Admin:
  Tested on Raspberry Pi


Version 5.75. Tagged as 'Kernel-5_75'
@
text
@d270 5
a274 2
        ADDCC   PC, PC, R2, LSL #2
        B       UnknownVdu23
@


4.5.2.1
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d270 2
a271 5
        BCS     UnknownVdu23
        LDR     R0, [WsPtr, #CursorFlags]
        TST     R0, #TeletextMode
        ADDNE   PC, PC, R2, LSL #2
        MOV     PC, LR
@


4.4
log
@Add support for custom teletext modes
Detail:
  This set of changes:
  * Adds support for the T, TX and TY mode string elements (as per RISCOS Ltd)
  * Adds support for entering arbitrary-resolution teletext modes by using mode selector blocks with the Teletext mode flag set
  * ScrRCol and ScrBRow mode variables can be provided in the mode selector in order to restrict the number of text rows/columns in teletext modes (as per RISCOS Ltd)
  * If the rows / columns are restricted in this manner then the text window will be centered on the screen, to try and avoid things looking too ugly (no variable text scaling implemented)
  * For HiResTTX, all colour depths >= 4bpp are now supported by teletext. This essentially makes the TTX256 switch obsolete.
  * If the "native" mode 7 is unavailable then the kernel will try a series of fallback resolutions & colour depths in an effort to find a combination that works
  Known bugs/issues:
  * Teletext column count has a max limit of 255 due to TTXDoubleCounts being a byte array
  * If there's a border around the text window, the border will not be refreshed when changing transparency modes using a VDU 23,18,0 sequence
  * ScreenLoad looks like it can overflow the LargeCommon buffer (no buffer size check) - needs fixing before LargeCommon can be safely shrunk below (Old)TTXMapSize
  File changes:
  - hdr/KernelWS - Make CharWidth non-conditional. Adjust handling of teletext workspace; it's now allocated from the system heap to allow it to cope with arbitrary screen sizes
  - s/vdu/vdu23 - Make CharWidth non-conditional
  - s/vdu/vducursoft - Make CursorTeletext cope with arbitrary colour depths, make CharWidth non-conditional, remove hard-coded teletext values
  - s/vdu/vdudriver - Deal with teletext workspace allocation during ModeChangeSub. Deal with selecting teletext modes (and validating colour depth) in GenerateModeSelectorVars.
  - s/vdu/vdugrafl - Make CharWidth non-conditional. Calculate offset required for text window centering.
  - s/vdu/vdumodes - Remove TTX256
  - s/vdu/vduswis - Try other teletext modes if native mode 7 not available. Extend OS_ScreenMode reason codes to cope with teletext mode strings.
  - s/vdu/vduttx - Update to use dynamic workspace. Replace various hardcoded values with variable lookups. Update character plotting + colour/palette selection to work with true-colour modes if HiResTTX.
  - s/vdu/vduwrch - Move some useful code into a subroutine. Update FastCLS to cope with true-colour teletext. Update AddressR0R1 to cope with text window centering offset. Make CharWidth non-conditional.
Admin:
  Tested on Raspberry Pi, BB-xM
  VDU 23,18,0 in 256-colour teletext now works correctly (previously 64-colour mode was in use, causing palette update to be ruined by VIDC1-mangling)


Version 5.74. Tagged as 'Kernel-5_74'
@
text
@d139 8
a156 5
        ; Claim the workspace that was previously allocated by TeletextAlloc
        LDR     R2, [WsPtr, #TTXNewWorkspace]
        MOV     R0, #0
        STR     R0, [WsPtr, #TTXNewWorkspace]

d172 2
a173 1
        
d250 1
a250 1
        Entry
@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@d108 25
d138 32
d237 20
a256 1
        MOV     PC, R14
d314 1
a314 1
        ; Redraw the screen
d316 3
a318 1
        BL      RefreshBitmap
d327 7
d338 3
d353 1
d445 1
a445 2
        ADRL    R2, TTXLineStarts
        LDR     R2, [R2]                        ; R2 -> start of map
d447 2
a448 1
        ADD     R5, R2, #4*40                   ; R5 -> map entry for last char on first line
d450 2
a451 1
        MOV     R10, #25                        ; R10 = bottom line + 1
d468 1
a468 1
        Push    "R14"
d472 6
d479 1
a479 2
        LDR     R7, [WsPtr, #RowLength]
        ADRL    R8, TTXLineStarts
d482 3
a484 1
        ADD     R5, R4, #40*4           ; R5 -> last map entry on line
d496 1
a496 10
    [ TTX256
        ASSERT  HiResTTX
        ADD     R2,R2, #16
    |
      [ HiResTTX
        ADD     R2, R2, #8
      |
        ADD     R2, R2, #4              ; move to next char on same line
      ]
    ]
a498 10
    [ TTX256
        ASSERT  HiResTTX
        SUB     R2, R2, #640
    |
      [ HiResTTX
        SUB     R2, R2, #320
      |
        SUB     R2, R2, #160            ; move back to start of this line
      ]
    ]
d501 1
a501 1
        CMP     R6, #24
d503 1
a503 1
        Pull    "PC"
d511 6
a519 3
        ; R1 -> space to build character in
        ; R3 = character: bits 0-4,6 are block flags, bit 5 is separated flag
        ; mask (R4), R10, R14 corrupted
d572 2
a573 2
        ADD     R0, WsPtr, #TTXMap      ; R0 -> map
        ADD     R1, R0, #TTXMapSize-4   ; R1 -> last word of map
d578 1
a578 1
        BLS     %BT10
d580 4
a583 2
        ADD     R0, WsPtr, #TTXDoubleCounts   ; zero double counts on each line
        ADD     R1, R0, #25
d609 30
d653 3
d777 16
d794 1
a794 1
        ADRL    R1, TTXLineStarts               ; R1 -> table of line starts
d796 3
a798 1
        ADD     R7, R8, #40*4                   ; R7 -> end of this line
d800 1
d802 1
a802 1
        ADD     R3, WsPtr, #TTXDoubleCounts
d847 1
a847 10
    [ TTX256
        ASSERT  HiResTTX
        ADDNE   R2, R2, #16
    |
      [ HiResTTX
        ADDNE   R2, R2, #8
      |
        ADDNE   R2, R2, #4                      ; then move to next char
      ]
    ]
d850 1
a850 1
        ADD     R3, WsPtr, #TTXDoubleCounts
d853 2
d856 1
a856 2
        TEQ     R11, #25                        ; if off bottom of screen
        Pull    PC, EQ                          ; then finished
d877 5
a881 11
        RSB     R3, R3, #160                    ; (current char number) * 4
    [ TTX256
        ASSERT  HiResTTX
        SUB     R2, R2, R3, LSL #2              ; back to start of old line
    |
      [ HiResTTX
        SUB     R2, R2, R3, LSL #1              ; back to start of old line
      |
        SUB     R2, R2, R3                      ; back to start of old line
      ]
    ]
d886 1
a886 1
        ADD     R7, R7, #40*4                   ; R7 -> last char on new line
d888 3
a890 2
        ADD     R4, R4, #41*4                   ; move Xmin to next line
        ADD     R5, R5, #41*4                   ; move Xmax to next line
d921 1
a921 1
        ADRL    R4, TTXLineStarts
d943 4
a946 2
        LDR     R2, TTXLineStarts               ; R2 -> TTXMap
        MOV     R5, #41*4                       ; R5 = no. of bytes horiz
d948 1
a948 1
        MOV     R6, #25                         ; no. of 'pixel' rows
d950 1
d958 3
a960 2
        ADD     R0, WsPtr, #TTXDoubleCounts
        ADD     R1, R0, #24
d970 1
a970 1
        LDR     R8, TTXLineStarts               ; R8 -> top left map
d981 2
d992 6
a997 3
        ADRL    R0, TTXLineStarts
        LDR     R0, [R0, #23*4]                 ; R0 -> dummy word on line 23
        LDRB    R1, [WsPtr, #TTXDoubleCounts+23] ; no. of dbls on line 23
d1002 3
a1004 1
        LDR     R2, [R0, #41*4]                 ; R2 = dummy word on line 24
d1007 1
a1007 1
        STR     R2, [R0, #41*4]                 ; and store back
d1024 1
a1024 1
        ADRL    R2, TTXLineStarts
d1041 3
a1043 1
        MOV     R7, #41*4                       ; R7 = line length
d1056 1
a1056 1
        ADRL    R7, TTXLineStarts
d1098 2
a1099 1
        ADD     R7, WsPtr, #TTXDoubleCounts
d1102 2
d1105 1
a1105 1
        ADD     R8, R9, #40*4                   ; R8 -> dummy char next row
d1121 1
a1121 1
        MOV     PC, R14
d1136 6
a1141 2
        LDR     R2, TTXLineStarts+24*4          ; R2 -> dummy char on bottom
        MOV     R5, #41*4                       ; R5 = no. of bytes horiz
d1143 1
a1143 1
        MOV     R6, #25                         ; no. of 'pixel' rows
d1146 1
d1153 2
a1154 2
        ADD     R0, WsPtr, #TTXDoubleCounts
        ADD     R1, R0, #24
d1163 1
a1163 1
        LDR     R0, TTXLineStarts               ; R0 -> top line dummy word
d1183 1
a1183 1
        ADR     R2, TTXLineStarts
d1200 3
a1202 1
        MOV     R7, #41*4                       ; R7 = line length
d1215 1
a1215 1
        ADR     R7, TTXLineStarts
d1254 2
d1257 1
a1257 1
        STRB    R8, [R4], #41*4                 ; store space and move down
d1326 1
a1326 1
        ADR     R4, TTXLineStarts
d1330 4
d1335 1
a1335 1
        ADD     R5, WsPtr, #TTXDoubleCounts
d1338 1
a1338 1
        LDR     R8, [R4], #41*4                 ; get char+attr
d1352 3
a1354 1
        Push    "R0-R3, R6, R9"
a1360 1
        MOV     R7, #41*4                       ; linelength
d1394 1
a1394 1
; out:  R0,R2 preserved
d1416 1
a1416 1
        ADR     R1, TTXHardFont-32*40           ; R1 -> base for font
d1418 1
a1418 1
        ADR     R1, TTXHardFont-32*10           ; R1 -> base for font
d1447 1
a1447 1
        ADREQ   R1, TTXHardFont                 ; then just use the hard font, for speed
d1463 1
a1463 1
        ADRNE   R1, TTXHardFont                 ; yes, then display as space
d1492 2
a1493 1
        ADD     screen, screen, #40*1024
d1511 3
a1513 2
      [ TTX256
        SUB     linelen, linelen, #8            ; adjust line offset to account for writing 2 words/line
d1515 1
a1515 1
        BL      Wrch8bitTTX                     ; do 1st bank
d1518 2
a1519 1
        ADD     screen, screen, #320*1024       ; point to 2nd bank
d1522 1
a1522 1
        BL      Wrch8bitTTX                     ; do 2nd bank
d1525 2
a1526 4
      |
        SUB     linelen, linelen, #4            ; adjust line offset to account for writing 2 words/line
        Push    "R1, screen"
        BL      Wrch4bitTTX                     ; do 1st bank
d1528 13
a1540 5
        LDMFD   R13, {R1, screen}               ; restore pointers to character and screen address
        ADD     screen, screen, #160*1024       ; point to 2nd bank
        TST     R0, #MapBit_Flash
        MOVNE   mask, #0                        ; flash => 2nd bank is space
        BL      Wrch4bitTTX                     ; do 2nd bank
d1542 5
a1546 3
        Pull    "R1, screen"
      ]
        EXIT
a1547 5
 [ TTX256
Wrch8bitTTX ROUT
 |
Wrch4bitTTX ROUT
 ]
d1560 1
d1562 1
a1562 1
 [ TTX256
d1600 6
a1605 1
 |
a1630 1
 ]
d1634 161
a1794 1
        MOV     PC, R14
a1798 8
TTXLineStarts
        GBLA    lineno
lineno  SETA    0
        WHILE   lineno < 25
        &       ZeroPage+VduDriverWorkSpace+TTXMap+4*41*lineno
lineno  SETA    lineno +1
        WEND

d1809 5
@


4.2
log
@  Added compile-time support for full-resolution teletext characters in
  teletext emulation mode (MODE 7) for that authentic BBC Micro feel.
  Also introduced a few useful teletext control features via VDU 23,18.
  Unrelatedly, fixed *ScreenLoad to work for interlaced displays.

Detail:
  The new typeface is designed on a 16x20 grid (previously we had used 8x10),
  so it uses a screen resolution of 640x500 pixels (rather than 320x250).
  Since we have been unable to source a genuine teletext font, and since
  examination of a BBC Micro suggests that the genuine font may not have been
  a power-of-2 pixels wide, I have designed one specially, based upon the one
  supplied in Zap distributions (a 12x20 font). Rather than increase the
  amount of workspace that the kernel requires for cacheing graphic
  characters, it now generates them on the fly, as they are required; this
  should only add about 25% to their rendering time.

  The new VDU 23 sequences are as follows:

  VDU 23,18,0,mode,0,0,0,0,0,0
    Switch transparency mode
      mode = 0: "Text" mode: the whole display is set opaque
      mode = 1: "Mix" mode: foreground colours, and both foreground and
        background of boxed text are opaque; non-boxed background colours are
        all transparent
      mode = 2: "Box" mode: boxed regions are opaque, others are transparent
      mode = 3: "TV" mode: the whole display is set transparent
    Default is mode = 0.

  VDU 23,18,1,suspend,0,0,0,0,0,0
    Suspend or resume bitmap updates
    This call allows an application to request that the kernel suspends
    updates to the framebuffer bitmap. This allows for a significant speed
    increase in the rendering time for a large amount of text, for example
    when redrawing a complete teletext page, because each time you plot a
    single character, it can cause the whole of the rest of the line to be
    re-rendered. When you switch out of suspend mode, the whole screen is
    refreshed in a single pass. Note that the appearance of the display is
    undefined is you cause a hardware scroll while in suspend mode.
      suspend = 0: screen update is enabled
      suspend = 1: screen update is suspended
    Default is suspend = 0.

  VDU 23,18,2,reveal,0,0,0,0,0,0
    Reveal/conceal
      reveal = 0: characters between the Conceal control code and the next
        colour control code are replaced by spaces
      reveal = 1: all characters are displayed
    Default is reveal = 0.

  VDU 23,18,3,black_emable,0,0,0,0,0,0
    Enable/disable black foreground colour control codes
      black_enable = 0: control codes &80 and &90 do nothing
      black_enable = 1: control code &80 selects black text, control code
        &90 selects black graphics
    Default is black_enable = 0.

  I have performed some timing tests on the rendering of complete teletext
  pages grabbed from the teletext server. These show that the new code
  generally imposes a 2x speed hit. However, when using the VDU 23,18,1
  suspend function, this improves to a 20% speed increase when compared to
  the old low-resolution code. Better still, because the framebuffer is only
  being updated for the final stage of this process, the screen *appears* to
  be updated some 3x faster than with the old code!

  A comment on the VDU variable Log2BPC is in order: in previous kernels,
  this was able unambiguously to refer to both the framebuffer width of a
  character in bytes, and the framebuffer width of an "addressable pixel" in
  bits; this no longer works with the 16-pixel wide teletext font. Bearing
  in mind that future kernels may support Unicode system fonts where the
  width varies from character to character, I have chosen to fix Log2BPC to
  the "addressable pixel" definition.

Admin:
  Requires HdrSrc 0.89 and (for non-desktop builds) Interlace 0.61. A monitor
  definition file containing a definition for a 640x500 screen mode is also
  required; version 0.40 of ModeFiles contains a suitable mode for STB-400.

  Tested fairly rigourously on an Ursula build, a Lazarus build and an
  STB-400 build, using genuine teletext pages and Yellow River Kingdom.

Version 5.30. Tagged as 'Kernel-5_30'
@
text
@d399 4
d408 1
d411 4
d420 1
d712 4
d721 1
d751 4
d760 1
d921 1
a921 1
        ADR     R7, TTXLineStarts
a1331 1
      [ VIDC_Type = "VIDC20"
a1332 3
      |
        ADD     bigfont, WsPtr, #TextExpand
      ]
a1353 1
      [ VIDC_Type = "VIDC20"
d1355 1
a1355 3
      |
        ADD     bigfont, WsPtr, #TextExpand
      ]
d1358 13
d1382 1
d1385 3
d1389 2
a1390 1
        MOV     R10, #4                         ; do each plot in 5 stages; R10 holds stage number
d1403 39
d1467 1
d1469 1
a1469 1
        SUBS    R10, R10, #1
d1480 1
a1480 1
        &       VduDriverWorkSpace+TTXMap+4*41*lineno
d1796 1
a1796 1
        =       &00,&20,&20,&20,&20,&2C,&02,&04,&08,&0E ; \
@


4.2.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d1725 1
a1725 1
        =       &00,&20,&20,&20,&20,&2C,&02,&04,&08,&0E ; \
@


4.2.2.2
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d1312 1
d1314 3
d1338 1
d1340 3
a1342 1

@


4.2.2.3
log
@Added 256-colour version of the (high-resolution only) teletext code,
and support for teletext when hardware scroll is disabled. Both are required
for Tungsten.
Turned off the module init/final service calls, since we still don't have an
allocation for them.
Upped the OS version number to 5.01.

Version 5.35, 4.79.2.53. Tagged as 'Kernel-5_35-4_79_2_53'
@
text
@a398 4
    [ TTX256
        ASSERT  HiResTTX
        ADD     R2,R2, #16
    |
a403 1
    ]
a405 4
    [ TTX256
        ASSERT  HiResTTX
        SUB     R2, R2, #640
    |
a410 1
    ]
a701 4
    [ TTX256
        ASSERT  HiResTTX
        ADDNE   R2, R2, #16
    |
a706 1
    ]
a735 4
    [ TTX256
        ASSERT  HiResTTX
        SUB     R2, R2, R3, LSL #2              ; back to start of old line
    |
a740 1
    ]
d901 1
a901 1
        ADRL    R7, TTXLineStarts
a1337 13
      [ TTX256
        SUB     linelen, linelen, #8            ; adjust line offset to account for writing 2 words/line
        Push    "R1, screen"
        BL      Wrch8bitTTX                     ; do 1st bank

        LDMFD   R13, {R1, screen}               ; restore pointers to character and screen address
        ADD     screen, screen, #320*1024       ; point to 2nd bank
        TST     R0, #MapBit_Flash
        MOVNE   mask, #0                        ; flash => 2nd bank is space
        BL      Wrch8bitTTX                     ; do 2nd bank

        Pull    "R1, screen"
      |
a1348 1
      ]
a1350 3
 [ TTX256
Wrch8bitTTX ROUT
 |
d1352 1
a1352 2
 ]
        MOV     R7, #4                          ; do each plot in 5 stages; R7 holds stage number
a1364 39
 [ TTX256
        AND     byte, mask, tophalf, LSL #16
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, tophalf, LSL #24
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        AND     byte, mask, tophalf
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, tophalf, LSL #8
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen

        AND     byte, mask, bottomhalf, LSL #16
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, bottomhalf, LSL #24
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
        AND     byte, mask, bottomhalf
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen!, {scrbyte, scrbyte2}
        AND     byte, mask, bottomhalf, LSL #8
        ADD     byte, bigfont, byte, LSR #21
        LDMIA   byte, {scrbyte, scrbyte2}
        STMIA   screen, {scrbyte, scrbyte2}
        ADD     screen, screen, linelen
 |
a1389 1
 ]
d1391 1
a1391 1
        SUBS    R7, R7, #1
@


4.2.2.4
log
@Fix teletext mode when zero page relocated
Detail:
  s/vdu/vduttx - References to VduDriverWorkSpace need to be ZeroPage-relative. Without relocation, it looks like most of these addresses were hitting the Debugger workspace page, avoiding an immediate crash but causing no text to appear on screen.
Admin:
  Tested on Raspberry Pi 1


Version 5.35, 4.79.2.326. Tagged as 'Kernel-5_35-4_79_2_326'
@
text
@d1480 1
a1480 1
        &       ZeroPage+VduDriverWorkSpace+TTXMap+4*41*lineno
@


4.1
log
@Initial revision
@
text
@d80 1
a80 1
;       Bits 25-29,31   Held graphic 
d116 5
d178 1
d184 292
d519 1
d610 1
d668 4
a671 3
        Push    "R1,R4-R11"
        BL      TTXPaintChar
        Pull    "R1,R4-R11"
d702 3
d706 1
d734 5
a738 2
        SUB     R3, R7, R8                      ; no. of chars before eol
        RSB     R3, R3, #160                    ; current char number
d740 1
d799 1
a799 1
        
d828 1
a828 1
        
d878 1
a878 1
        
d976 1
a976 1
        
d1027 1
a1027 1
        
d1195 22
d1222 1
a1222 3
; out:  R2 preserved
;       R0 largely preserved, but held graphic bits may have been changed
;
d1225 1
a1225 1
        Push    R14
d1233 5
a1237 2
        AND     R5, R4, R0, LSR #MapForeShift   ; R5 = new foregd colour
        AND     R6, R4, R0, LSR #MapBackShift   ; R6 = new backgd colour
d1243 3
d1247 1
a1256 1
        BICEQ   R0, R0, #MapBit_HeldMask        ; and cancel held graphic
a1270 2
        BIC     R0, R0, #MapBit_HeldMask        ; cancel current held graphic
        ORR     R0, R0, R3, LSL #MapHeldShift   ; and put new one in
d1273 10
d1286 1
d1289 2
d1293 1
d1329 73
a1401 1
        Pull    "R0, screen, PC"
d1430 1
a1430 1
        MOV     PC, R14                 ; &00 Post
d1462 1
a1462 1
        MOV     PC, R14                 ; &10 Post
d1497 5
d1510 5
d1567 98
d1761 1
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d968 1
@


4.1.4.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d965 1
d967 2
@


4.1.4.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d965 1
d967 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

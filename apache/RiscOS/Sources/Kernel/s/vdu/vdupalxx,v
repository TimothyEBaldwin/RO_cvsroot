head	4.5;
access;
symbols
	Kernel-6_14:4.5
	Kernel-6_01-3:4.4
	Kernel-6_13:4.5
	Kernel-6_12:4.5
	Kernel-6_11:4.5
	Kernel-6_10:4.4
	Kernel-6_09:4.4
	Kernel-6_08-4_129_2_10:4.3.2.1
	Kernel-6_08-4_129_2_9:4.3.2.1
	Kernel-6_08:4.4
	Kernel-6_07:4.4
	Kernel-6_06:4.4
	Kernel-6_05-4_129_2_8:4.3.2.1
	Kernel-6_05:4.4
	Kernel-6_04:4.4
	Kernel-6_03:4.4
	Kernel-6_01-2:4.4
	Kernel-6_01-4_146_2_1:4.4
	Kernel-6_02:4.4
	Kernel-6_01-1:4.4
	Kernel-6_01:4.4
	Kernel-6_00:4.4
	Kernel-5_99:4.4
	Kernel-5_98:4.4
	Kernel-5_97-4_129_2_7:4.3.2.1
	Kernel-5_97:4.4
	Kernel-5_96:4.4
	Kernel-5_95:4.3
	Kernel-5_94:4.3
	Kernel-5_93:4.3
	Kernel-5_92:4.3
	Kernel-5_91:4.3
	Kernel-5_90:4.3
	Kernel-5_89-4_129_2_6:4.3
	Kernel-5_89:4.3
	Kernel-5_88-4_129_2_5:4.3
	Kernel-5_88-4_129_2_4:4.3
	Kernel-5_88:4.3
	Kernel-5_87:4.3
	Kernel-5_86-4_129_2_3:4.3
	Kernel-5_86-4_129_2_2:4.3
	Kernel-5_86-4_129_2_1:4.3
	Kernel-5_86:4.3
	SMP:4.3.0.2
	SMP_bp:4.3
	Kernel-5_85:4.3
	Kernel-5_54-1:4.3
	Kernel-5_84:4.3
	Kernel-5_83:4.3
	Kernel-5_82:4.3
	Kernel-5_81:4.3
	Kernel-5_80:4.3
	Kernel-5_79:4.3
	Kernel-5_78:4.3
	Kernel-5_77:4.3
	Kernel-5_76:4.3
	Kernel-5_75:4.3
	Kernel-5_74:4.3
	Kernel-5_73:4.3
	Kernel-5_72:4.3
	Kernel-5_71:4.3
	Kernel-5_70:4.3
	Kernel-5_69:4.3
	Kernel-5_68:4.3
	Kernel-5_67:4.3
	Kernel-5_66:4.3
	Kernel-5_65:4.3
	Kernel-5_64:4.3
	Kernel-5_63:4.3
	Kernel-5_62:4.3
	Kernel-5_61:4.3
	Kernel-5_60:4.3
	Kernel-5_59:4.3
	Kernel-5_58:4.3
	Kernel-5_57:4.3
	Kernel-5_56:4.3
	Kernel-5_55:4.3
	Kernel-5_54:4.3
	Kernel-5_53:4.3
	Kernel-5_52:4.3
	Kernel-5_51:4.3
	Kernel-5_50:4.2
	Kernel-5_49:4.2
	HAL_merge:1.1.2.12
	Kernel-5_48:4.1
	Kernel-5_35-4_79_2_327:1.1.2.12
	Kernel-5_35-4_79_2_326:1.1.2.12
	Kernel-5_35-4_79_2_325:1.1.2.12
	Kernel-5_35-4_79_2_324:1.1.2.12
	Kernel-5_35-4_79_2_323:1.1.2.12
	Kernel-5_35-4_79_2_322:1.1.2.12
	Kernel-5_35-4_79_2_321:1.1.2.12
	Kernel-5_35-4_79_2_320:1.1.2.12
	Kernel-5_35-4_79_2_319:1.1.2.12
	Kernel-5_35-4_79_2_318:1.1.2.12
	Kernel-5_35-4_79_2_317:1.1.2.12
	Kernel-5_35-4_79_2_316:1.1.2.12
	Kernel-5_35-4_79_2_315:1.1.2.12
	Kernel-5_35-4_79_2_314:1.1.2.12
	Kernel-5_35-4_79_2_313:1.1.2.12
	Kernel-5_35-4_79_2_312:1.1.2.12
	Kernel-5_35-4_79_2_311:1.1.2.12
	Kernel-5_35-4_79_2_310:1.1.2.12
	Kernel-5_35-4_79_2_309:1.1.2.12
	Kernel-5_35-4_79_2_308:1.1.2.12
	Kernel-5_35-4_79_2_307:1.1.2.12
	Kernel-5_35-4_79_2_306:1.1.2.12
	Kernel-5_35-4_79_2_305:1.1.2.12
	Kernel-5_35-4_79_2_304:1.1.2.12
	Kernel-5_35-4_79_2_303:1.1.2.12
	Kernel-5_35-4_79_2_302:1.1.2.12
	Kernel-5_35-4_79_2_301:1.1.2.12
	Kernel-5_35-4_79_2_300:1.1.2.12
	Kernel-5_35-4_79_2_299:1.1.2.12
	Kernel-5_35-4_79_2_298:1.1.2.12
	Kernel-5_35-4_79_2_297:1.1.2.12
	Kernel-5_35-4_79_2_296:1.1.2.12
	Kernel-5_35-4_79_2_295:1.1.2.12
	Kernel-5_35-4_79_2_294:1.1.2.12
	Kernel-5_35-4_79_2_293:1.1.2.12
	Kernel-5_35-4_79_2_292:1.1.2.12
	Kernel-5_35-4_79_2_291:1.1.2.12
	Kernel-5_35-4_79_2_290:1.1.2.12
	Kernel-5_35-4_79_2_289:1.1.2.12
	Kernel-5_35-4_79_2_288:1.1.2.12
	Kernel-5_35-4_79_2_287:1.1.2.12
	Kernel-5_35-4_79_2_286:1.1.2.12
	Kernel-5_35-4_79_2_285:1.1.2.12
	Kernel-5_35-4_79_2_284:1.1.2.12
	Kernel-5_35-4_79_2_283:1.1.2.12
	Kernel-5_35-4_79_2_282:1.1.2.12
	Kernel-5_35-4_79_2_281:1.1.2.12
	Kernel-5_35-4_79_2_280:1.1.2.12
	Kernel-5_35-4_79_2_279:1.1.2.12
	Kernel-5_35-4_79_2_278:1.1.2.12
	Kernel-5_35-4_79_2_277:1.1.2.12
	Kernel-5_35-4_79_2_276:1.1.2.12
	Kernel-5_35-4_79_2_275:1.1.2.12
	Kernel-5_35-4_79_2_274:1.1.2.12
	Kernel-5_35-4_79_2_273:1.1.2.12
	Kernel-5_35-4_79_2_272:1.1.2.12
	Kernel-5_35-4_79_2_271:1.1.2.12
	Kernel-5_35-4_79_2_270:1.1.2.12
	Kernel-5_35-4_79_2_269:1.1.2.12
	Kernel-5_35-4_79_2_268:1.1.2.11
	Kernel-5_35-4_79_2_267:1.1.2.11
	Kernel-5_35-4_79_2_266:1.1.2.11
	Kernel-5_35-4_79_2_265:1.1.2.11
	Kernel-5_35-4_79_2_264:1.1.2.11
	Kernel-5_35-4_79_2_263:1.1.2.11
	Kernel-5_35-4_79_2_262:1.1.2.11
	Kernel-5_35-4_79_2_261:1.1.2.11
	Kernel-5_35-4_79_2_260:1.1.2.11
	Kernel-5_35-4_79_2_259:1.1.2.11
	Kernel-5_35-4_79_2_258:1.1.2.11
	Kernel-5_35-4_79_2_257:1.1.2.11
	Kernel-5_35-4_79_2_256:1.1.2.11
	Kernel-5_35-4_79_2_255:1.1.2.11
	Kernel-5_35-4_79_2_254:1.1.2.11
	Kernel-5_35-4_79_2_253:1.1.2.11
	Kernel-5_35-4_79_2_252:1.1.2.11
	Kernel-5_35-4_79_2_251:1.1.2.11
	Kernel-5_35-4_79_2_250:1.1.2.11
	Kernel-5_35-4_79_2_249:1.1.2.11
	Kernel-5_35-4_79_2_248:1.1.2.11
	Kernel-5_35-4_79_2_247:1.1.2.11
	Kernel-5_35-4_79_2_246:1.1.2.11
	Kernel-5_35-4_79_2_245:1.1.2.11
	Kernel-5_35-4_79_2_244:1.1.2.11
	Kernel-5_35-4_79_2_243:1.1.2.11
	Kernel-5_35-4_79_2_242:1.1.2.11
	Kernel-5_35-4_79_2_241:1.1.2.11
	Kernel-5_35-4_79_2_240:1.1.2.11
	Kernel-5_35-4_79_2_239:1.1.2.11
	Kernel-5_35-4_79_2_238:1.1.2.11
	Kernel-5_35-4_79_2_237:1.1.2.11
	Kernel-5_35-4_79_2_236:1.1.2.11
	Kernel-5_35-4_79_2_235:1.1.2.11
	Kernel-5_35-4_79_2_234:1.1.2.11
	Kernel-5_35-4_79_2_233:1.1.2.11
	Kernel-5_35-4_79_2_232:1.1.2.11
	Kernel-5_35-4_79_2_231:1.1.2.11
	Kernel-5_35-4_79_2_230:1.1.2.11
	Kernel-5_35-4_79_2_229:1.1.2.11
	Kernel-5_35-4_79_2_228:1.1.2.11
	Kernel-5_35-4_79_2_227:1.1.2.11
	Kernel-5_35-4_79_2_226:1.1.2.11
	Kernel-5_35-4_79_2_225:1.1.2.11
	Kernel-5_35-4_79_2_224:1.1.2.11
	Kernel-5_35-4_79_2_223:1.1.2.11
	Kernel-5_35-4_79_2_222:1.1.2.11
	Kernel-5_35-4_79_2_221:1.1.2.11
	Kernel-5_35-4_79_2_220:1.1.2.11
	Kernel-5_35-4_79_2_219:1.1.2.11
	Kernel-5_35-4_79_2_218:1.1.2.11
	Kernel-5_35-4_79_2_217:1.1.2.11
	Kernel-5_35-4_79_2_216:1.1.2.11
	Kernel-5_35-4_79_2_215:1.1.2.11
	Kernel-5_35-4_79_2_214:1.1.2.11
	Kernel-5_35-4_79_2_213:1.1.2.11
	Kernel-5_35-4_79_2_212:1.1.2.11
	Kernel-5_35-4_79_2_211:1.1.2.11
	Kernel-5_35-4_79_2_210:1.1.2.11
	Kernel-5_35-4_79_2_209:1.1.2.10
	Kernel-5_35-4_79_2_208:1.1.2.10
	Kernel-5_35-4_79_2_207:1.1.2.10
	Kernel-5_35-4_79_2_206:1.1.2.10
	Kernel-5_35-4_79_2_205:1.1.2.10
	Kernel-5_35-4_79_2_204:1.1.2.10
	Kernel-5_35-4_79_2_203:1.1.2.10
	Kernel-5_35-4_79_2_202:1.1.2.9
	Kernel-5_35-4_79_2_201:1.1.2.9
	Kernel-5_35-4_79_2_200:1.1.2.9
	Kernel-5_35-4_79_2_199:1.1.2.9
	Kernel-5_35-4_79_2_198:1.1.2.9
	Kernel-5_35-4_79_2_197:1.1.2.9
	Kernel-5_35-4_79_2_196:1.1.2.9
	Kernel-5_35-4_79_2_195:1.1.2.9
	Kernel-5_35-4_79_2_194:1.1.2.9
	Kernel-5_35-4_79_2_193:1.1.2.8
	Kernel-5_35-4_79_2_192:1.1.2.8
	Kernel-5_35-4_79_2_191:1.1.2.8
	Kernel-5_35-4_79_2_190:1.1.2.8
	Kernel-5_35-4_79_2_189:1.1.2.8
	Kernel-5_35-4_79_2_188:1.1.2.8
	Kernel-5_35-4_79_2_187:1.1.2.8
	Kernel-5_35-4_79_2_186:1.1.2.8
	Kernel-5_35-4_79_2_185:1.1.2.8
	Kernel-5_35-4_79_2_184:1.1.2.8
	Kernel-5_35-4_79_2_183:1.1.2.8
	Kernel-5_35-4_79_2_182:1.1.2.8
	Kernel-5_35-4_79_2_181:1.1.2.8
	Kernel-5_35-4_79_2_180:1.1.2.8
	Kernel-5_35-4_79_2_179:1.1.2.8
	Kernel-5_35-4_79_2_178:1.1.2.8
	Kernel-5_35-4_79_2_177:1.1.2.8
	Kernel-5_35-4_79_2_176:1.1.2.8
	Kernel-5_35-4_79_2_175:1.1.2.8
	Kernel-5_35-4_79_2_174:1.1.2.8
	Kernel-5_35-4_79_2_173:1.1.2.8
	Kernel-5_35-4_79_2_172:1.1.2.8
	Kernel-5_35-4_79_2_171:1.1.2.8
	Kernel-5_35-4_79_2_170:1.1.2.8
	Kernel-5_35-4_79_2_169:1.1.2.8
	Kernel-5_35-4_79_2_168:1.1.2.8
	Kernel-5_35-4_79_2_167:1.1.2.8
	Kernel-5_35-4_79_2_166:1.1.2.8
	Kernel-5_35-4_79_2_165:1.1.2.8
	RPi_merge:1.1.2.6.2.1
	Kernel-5_35-4_79_2_147_2_23:1.1.2.6.2.1
	Kernel-5_35-4_79_2_147_2_22:1.1.2.6
	Kernel-5_35-4_79_2_147_2_21:1.1.2.6
	Kernel-5_35-4_79_2_147_2_20:1.1.2.6
	Kernel-5_35-4_79_2_147_2_19:1.1.2.6
	Kernel-5_35-4_79_2_147_2_18:1.1.2.6
	Kernel-5_35-4_79_2_164:1.1.2.8
	Kernel-5_35-4_79_2_163:1.1.2.8
	Kernel-5_35-4_79_2_147_2_17:1.1.2.6
	Kernel-5_35-4_79_2_147_2_16:1.1.2.6
	Kernel-5_35-4_79_2_147_2_15:1.1.2.6
	Kernel-5_35-4_79_2_162:1.1.2.8
	Kernel-5_35-4_79_2_161:1.1.2.8
	Kernel-5_35-4_79_2_147_2_14:1.1.2.6
	Kernel-5_35-4_79_2_147_2_13:1.1.2.6
	Kernel-5_35-4_79_2_160:1.1.2.8
	Kernel-5_35-4_79_2_159:1.1.2.8
	Kernel-5_35-4_79_2_158:1.1.2.7
	Kernel-5_35-4_79_2_157:1.1.2.7
	Kernel-5_35-4_79_2_156:1.1.2.7
	Kernel-5_35-4_79_2_147_2_12:1.1.2.6
	Kernel-5_35-4_79_2_147_2_11:1.1.2.6
	Kernel-5_35-4_79_2_155:1.1.2.7
	Kernel-5_35-4_79_2_147_2_10:1.1.2.6
	Kernel-5_35-4_79_2_154:1.1.2.7
	Kernel-5_35-4_79_2_153:1.1.2.7
	Kernel-5_35-4_79_2_147_2_9:1.1.2.6
	Kernel-5_35-4_79_2_152:1.1.2.7
	Kernel-5_35-4_79_2_151:1.1.2.7
	Kernel-5_35-4_79_2_147_2_8:1.1.2.6
	Kernel-5_35-4_79_2_147_2_7:1.1.2.6
	Kernel-5_35-4_79_2_150:1.1.2.7
	Kernel-5_35-4_79_2_147_2_6:1.1.2.6
	Kernel-5_35-4_79_2_147_2_5:1.1.2.6
	Kernel-5_35-4_79_2_149:1.1.2.6
	Kernel-5_35-4_79_2_147_2_4:1.1.2.6
	Kernel-5_35-4_79_2_147_2_3:1.1.2.6
	Kernel-5_35-4_79_2_148:1.1.2.6
	Kernel-5_35-4_79_2_147_2_2:1.1.2.6
	Kernel-5_35-4_79_2_147_2_1:1.1.2.6
	RPi:1.1.2.6.0.2
	RPi_bp:1.1.2.6
	Kernel-5_35-4_79_2_98_2_52_2_1:1.1.2.5.2.1
	alees_Kernel_dev:1.1.2.5.2.1.0.2
	alees_Kernel_dev_bp:1.1.2.5.2.1
	Kernel-5_35-4_79_2_147:1.1.2.6
	Kernel-5_35-4_79_2_146:1.1.2.6
	Kernel-5_35-4_79_2_145:1.1.2.6
	Kernel-5_35-4_79_2_144:1.1.2.6
	Kernel-5_35-4_79_2_143:1.1.2.6
	Kernel-5_35-4_79_2_142:1.1.2.6
	Kernel-5_35-4_79_2_141:1.1.2.6
	Kernel-5_35-4_79_2_140:1.1.2.6
	Kernel-5_35-4_79_2_139:1.1.2.6
	Kernel-5_35-4_79_2_138:1.1.2.6
	Kernel-5_35-4_79_2_137:1.1.2.6
	Kernel-5_35-4_79_2_136:1.1.2.6
	Kernel-5_35-4_79_2_135:1.1.2.6
	Kernel-5_35-4_79_2_134:1.1.2.6
	Kernel-5_35-4_79_2_133:1.1.2.6
	Kernel-5_35-4_79_2_132:1.1.2.6
	Kernel-5_35-4_79_2_131:1.1.2.6
	Kernel-5_35-4_79_2_130:1.1.2.6
	Kernel-5_35-4_79_2_129:1.1.2.6
	Kernel-5_35-4_79_2_128:1.1.2.6
	Kernel-5_35-4_79_2_127:1.1.2.6
	Kernel-5_35-4_79_2_126:1.1.2.6
	Kernel-5_35-4_79_2_125:1.1.2.6
	Kernel-5_35-4_79_2_124:1.1.2.6
	Kernel-5_35-4_79_2_123:1.1.2.6
	Cortex_merge:1.1.2.5.2.1
	Kernel-5_35-4_79_2_122:1.1.2.5
	Kernel-5_35-4_79_2_98_2_54:1.1.2.5.2.1
	Kernel-5_35-4_79_2_98_2_53:1.1.2.5.2.1
	Kernel-5_35-4_79_2_98_2_52:1.1.2.5.2.1
	Kernel-5_35-4_79_2_98_2_51:1.1.2.5.2.1
	Kernel-5_35-4_79_2_98_2_50:1.1.2.5.2.1
	Kernel-5_35-4_79_2_98_2_49:1.1.2.5.2.1
	Kernel-5_35-4_79_2_98_2_48:1.1.2.5.2.1
	Kernel-5_35-4_79_2_121:1.1.2.5
	Kernel-5_35-4_79_2_98_2_47:1.1.2.5
	Kernel-5_35-4_79_2_120:1.1.2.5
	Kernel-5_35-4_79_2_98_2_46:1.1.2.5
	Kernel-5_35-4_79_2_119:1.1.2.5
	Kernel-5_35-4_79_2_98_2_45:1.1.2.5
	Kernel-5_35-4_79_2_98_2_44:1.1.2.5
	Kernel-5_35-4_79_2_118:1.1.2.5
	Kernel-5_35-4_79_2_98_2_43:1.1.2.5
	Kernel-5_35-4_79_2_117:1.1.2.5
	Kernel-5_35-4_79_2_116:1.1.2.5
	Kernel-5_35-4_79_2_98_2_42:1.1.2.5
	Kernel-5_35-4_79_2_115:1.1.2.5
	Kernel-5_35-4_79_2_98_2_41:1.1.2.5
	Kernel-5_35-4_79_2_98_2_40:1.1.2.5
	Kernel-5_35-4_79_2_114:1.1.2.5
	Kernel-5_35-4_79_2_98_2_39:1.1.2.5
	Kernel-5_35-4_79_2_98_2_38:1.1.2.5
	Kernel-5_35-4_79_2_113:1.1.2.5
	Kernel-5_35-4_79_2_112:1.1.2.5
	Kernel-5_35-4_79_2_98_2_37:1.1.2.5
	Kernel-5_35-4_79_2_98_2_36:1.1.2.5
	Kernel-5_35-4_79_2_98_2_35:1.1.2.5
	Kernel-5_35-4_79_2_98_2_34:1.1.2.5
	Kernel-5_35-4_79_2_98_2_33:1.1.2.5
	Kernel-5_35-4_79_2_98_2_32:1.1.2.5
	Kernel-5_35-4_79_2_98_2_31:1.1.2.5
	Kernel-5_35-4_79_2_98_2_30:1.1.2.5
	Kernel-5_35-4_79_2_98_2_29:1.1.2.5
	Kernel-5_35-4_79_2_98_2_28:1.1.2.5
	Kernel-5_35-4_79_2_98_2_27:1.1.2.5
	Kernel-5_35-4_79_2_98_2_26:1.1.2.5
	Kernel-5_35-4_79_2_111:1.1.2.5
	Kernel-5_35-4_79_2_98_2_25:1.1.2.5
	Kernel-5_35-4_79_2_98_2_24:1.1.2.5
	Kernel-5_35-4_79_2_98_2_23:1.1.2.5
	Kernel-5_35-4_79_2_110:1.1.2.5
	Kernel-5_35-4_79_2_98_2_22:1.1.2.5
	Kernel-5_35-4_79_2_109:1.1.2.5
	Kernel-5_35-4_79_2_98_2_21:1.1.2.5
	Kernel-5_35-4_79_2_98_2_20:1.1.2.5
	Kernel-5_35-4_79_2_108:1.1.2.5
	Kernel-5_35-4_79_2_107:1.1.2.5
	Kernel-5_35-4_79_2_98_2_19:1.1.2.5
	Kernel-5_35-4_79_2_98_2_18:1.1.2.5
	Kernel-5_35-4_79_2_98_2_17:1.1.2.5
	Kernel-5_35-4_79_2_98_2_16:1.1.2.5
	Kernel-5_35-4_79_2_98_2_15:1.1.2.5
	Kernel-5_35-4_79_2_106:1.1.2.5
	Kernel-5_35-4_79_2_105:1.1.2.5
	Kernel-5_35-4_79_2_104:1.1.2.5
	Kernel-5_35-4_79_2_98_2_14:1.1.2.5
	Kernel-5_35-4_79_2_98_2_13:1.1.2.5
	Kernel-5_35-4_79_2_98_2_12:1.1.2.5
	Kernel-5_35-4_79_2_98_2_11:1.1.2.5
	Kernel-5_35-4_79_2_98_2_10:1.1.2.5
	Kernel-5_35-4_79_2_98_2_9:1.1.2.5
	Kernel-5_35-4_79_2_103:1.1.2.5
	Kernel-5_35-4_79_2_102:1.1.2.5
	Kernel-5_35-4_79_2_98_2_8:1.1.2.5
	Kernel-5_35-4_79_2_98_2_7:1.1.2.5
	Kernel-5_35-4_79_2_98_2_6:1.1.2.5
	Kernel-5_35-4_79_2_98_2_5:1.1.2.5
	Kernel-5_35-4_79_2_98_2_4:1.1.2.5
	Kernel-5_35-4_79_2_101:1.1.2.5
	Kernel-5_35-4_79_2_100:1.1.2.5
	Kernel-5_35-4_79_2_99:1.1.2.5
	Kernel-5_35-4_79_2_98_2_3:1.1.2.5
	Kernel-5_35-4_79_2_98_2_2:1.1.2.5
	Kernel-5_35-4_79_2_98_2_1:1.1.2.5
	Cortex:1.1.2.5.0.2
	Cortex_bp:1.1.2.5
	Kernel-5_35-4_79_2_98:1.1.2.5
	Kernel-5_35-4_79_2_97:1.1.2.5
	Kernel-5_35-4_79_2_96:1.1.2.5
	Kernel-5_35-4_79_2_95:1.1.2.5
	Kernel-5_35-4_79_2_94:1.1.2.5
	Kernel-5_35-4_79_2_93:1.1.2.5
	Kernel-5_35-4_79_2_92:1.1.2.5
	Kernel-5_35-4_79_2_91:1.1.2.5
	Kernel-5_35-4_79_2_90:1.1.2.5
	Kernel-5_35-4_79_2_89:1.1.2.5
	Kernel-5_35-4_79_2_88:1.1.2.5
	Kernel-5_35-4_79_2_87:1.1.2.5
	Kernel-5_35-4_79_2_86:1.1.2.5
	Kernel-5_35-4_79_2_85:1.1.2.5
	Kernel-5_35-4_79_2_84:1.1.2.5
	Kernel-5_35-4_79_2_83:1.1.2.5
	Kernel-5_35-4_79_2_82:1.1.2.5
	Kernel-5_35-4_79_2_81:1.1.2.5
	Kernel-5_35-4_79_2_80:1.1.2.5
	Kernel-5_35-4_79_2_79:1.1.2.5
	Kernel-5_35-4_79_2_78:1.1.2.5
	Kernel-5_35-4_79_2_77:1.1.2.5
	RO_5_07:1.1.2.5
	Kernel-5_35-4_79_2_76:1.1.2.5
	Kernel-5_35-4_79_2_75:1.1.2.5
	Kernel-5_35-4_79_2_74:1.1.2.5
	Kernel-5_35-4_79_2_73:1.1.2.5
	Kernel-5_35-4_79_2_72:1.1.2.5
	Kernel-5_35-4_79_2_71:1.1.2.5
	Kernel-5_35-4_79_2_70:1.1.2.5
	Kernel-5_35-4_79_2_69:1.1.2.5
	Kernel-5_35-4_79_2_68:1.1.2.5
	Kernel-5_35-4_79_2_67:1.1.2.5
	Kernel-5_35-4_79_2_66:1.1.2.5
	Kernel-5_35-4_79_2_65:1.1.2.4
	Kernel-5_35-4_79_2_64:1.1.2.4
	Kernel-5_35-4_79_2_63:1.1.2.4
	Kernel-5_35-4_79_2_62:1.1.2.4
	Kernel-5_35-4_79_2_61:1.1.2.4
	Kernel-5_35-4_79_2_59:1.1.2.4
	Kernel-5_35-4_79_2_58:1.1.2.4
	Kernel-5_35-4_79_2_57:1.1.2.4
	Kernel-5_35-4_79_2_56:1.1.2.4
	Kernel-5_35-4_79_2_55:1.1.2.4
	Kernel-5_35-4_79_2_54:1.1.2.4
	Kernel-5_35-4_79_2_53:1.1.2.4
	Kernel-5_35-4_79_2_52:1.1.2.4
	Kernel-5_35-4_79_2_51:1.1.2.4
	Kernel-5_35-4_79_2_50:1.1.2.4
	Kernel-5_35-4_79_2_49:1.1.2.4
	Kernel-5_35-4_79_2_48:1.1.2.4
	Kernel-5_35-4_79_2_47:1.1.2.3
	Kernel-5_35-4_79_2_46:1.1.2.3
	Kernel-5_35-4_79_2_45:1.1.2.3
	Kernel-5_35-4_79_2_44:1.1.2.3
	Kernel-5_35-4_79_2_25_2_2:1.1.2.3
	Kernel-5_35-4_79_2_43:1.1.2.3
	Kernel-5_35-4_79_2_42:1.1.2.3
	Kernel-5_35-4_79_2_41:1.1.2.3
	Kernel-5_35-4_79_2_40:1.1.2.3
	Kernel-5_35-4_79_2_39:1.1.2.3
	Kernel-5_35-4_79_2_38:1.1.2.3
	Kernel-5_35-4_79_2_37:1.1.2.3
	Kernel-5_35-4_79_2_36:1.1.2.3
	Kernel-5_35-4_79_2_35:1.1.2.3
	Kernel-5_35-4_79_2_34:1.1.2.3
	Kernel-5_35-4_79_2_33:1.1.2.3
	Kernel-5_35-4_79_2_32:1.1.2.3
	Kernel-5_35-4_79_2_25_2_1:1.1.2.3
	Kernel-5_35-4_79_2_31:1.1.2.3
	Kernel-5_35-4_79_2_30:1.1.2.3
	Kernel-5_35-4_79_2_29:1.1.2.3
	Kernel-5_35-4_79_2_28:1.1.2.3
	Kernel-5_35-4_79_2_27:1.1.2.3
	Kernel-5_35-4_79_2_26:1.1.2.3
	Kernel-5_35-4_79_2_25:1.1.2.3
	Kernel-5_35-4_79_2_24:1.1.2.3
	Kernel-5_35-4_79_2_23:1.1.2.3
	Kernel-5_35-4_79_2_22:1.1.2.3
	Kernel-5_35-4_79_2_21:1.1.2.3
	Kernel-5_35-4_79_2_20:1.1.2.3
	Kernel-5_35-4_79_2_19:1.1.2.3
	Kernel-5_35-4_79_2_18:1.1.2.3
	Kernel-5_35-4_79_2_17:1.1.2.3
	Kernel-5_35-4_79_2_16:1.1.2.3
	Kernel-5_35-4_79_2_15:1.1.2.3
	Kernel-5_35-4_79_2_14:1.1.2.3
	Kernel-5_35-4_79_2_13:1.1.2.3
	Kernel-5_35-4_79_2_12:1.1.2.3
	Kernel-5_35-4_79_2_11:1.1.2.3
	Kernel-5_35-4_79_2_10:1.1.2.3
	Kernel-5_35-4_79_2_9:1.1.2.3
	Kernel-5_35-4_79_2_8:1.1.2.2
	Kernel-5_35-4_79_2_7:1.1.2.2
	Kernel-5_35-4_79_2_6:1.1.2.2
	Kernel-5_35-4_79_2_5:1.1.2.2
	Kernel-5_35-4_79_2_4:1.1.2.2
	Kernel-5_35-4_79_2_3:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


4.5
date	2018.07.14.19.02.28;	author jlee;	state Exp;
branches;
next	4.4;
commitid	DsDtaR4YavfJx8KA;

4.4
date	2018.02.04.19.18.00;	author jlee;	state Exp;
branches;
next	4.3;
commitid	P8lRrfmbNEUXLzpA;

4.3
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches
	4.3.2.1;
next	4.2;
commitid	skOEjp3ipLHx6xcz;

4.2
date	2016.06.30.20.29.05;	author jlee;	state Exp;
branches;
next	4.1;
commitid	lMnWzoE9eJz3Wwcz;

4.1
date	2016.06.30.20.08.20;	author jlee;	state Exp;
branches;
next	1.1;
commitid	IWoXxARWeuLDOwcz;

1.1
date	2000.10.03.12.06.00;	author mstephen;	state dead;
branches
	1.1.2.1;
next	;

4.3.2.1
date	2018.02.16.00.01.46;	author jlee;	state Exp;
branches;
next	;
commitid	L7HYXYTsWSFlZ0rA;

1.1.2.1
date	2000.10.03.12.06.00;	author mstephen;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2000.10.05.11.55.13;	author mstephen;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2000.10.06.09.08.12;	author kbracey;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.05.06.16.02.05;	author kbracey;	state Exp;
branches
	1.1.2.5.2.1;
next	1.1.2.6;

1.1.2.6
date	2011.11.26.21.11.28;	author jlee;	state Exp;
branches
	1.1.2.6.2.1;
next	1.1.2.7;
commitid	cI3W0zbtALQG6TIv;

1.1.2.7
date	2012.05.21.19.31.44;	author rsprowson;	state Exp;
branches;
next	1.1.2.8;
commitid	oEtPURiKNEPMRC5w;

1.1.2.8
date	2012.07.04.17.50.57;	author rsprowson;	state Exp;
branches;
next	1.1.2.9;
commitid	BwjRc3GMlaDwTgbw;

1.1.2.9
date	2013.08.06.22.43.10;	author jlee;	state Exp;
branches;
next	1.1.2.10;
commitid	TOIaeUf2Q4rBIr0x;

1.1.2.10
date	2013.12.15.21.34.13;	author jlee;	state Exp;
branches;
next	1.1.2.11;
commitid	KwuK29hKRyXO7hhx;

1.1.2.11
date	2014.03.09.15.57.03;	author jlee;	state Exp;
branches;
next	1.1.2.12;
commitid	FnXbK143NQLRy2sx;

1.1.2.12
date	2015.07.10.20.16.42;	author jlee;	state Exp;
branches;
next	;
commitid	wa0i3ESGlbkojMsy;

1.1.2.5.2.1
date	2011.08.08.23.28.38;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

1.1.2.6.2.1
date	2012.09.18.15.50.11;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;


desc
@@


4.5
log
@Evict ECFIndex and PalIndex from VDU workspace
Detail:
  ECFIndex and PalIndex claim to be mode variables, but it's impossible for extension modes to specify their values.
  Since they're easy to calculate from the ModeFlags and Log2BPP values, drop them from the mode workspace (+ table of builtin modes) and calculate them on the fly instead.
  File changes:
  - hdr/KernelWS - Drop ECFIndex & PalIndex from workspace
  - s/vdu/vdumodes - Adjust workspace definition, drop ECFIndex & PalIndex values from VWSTAB
  - s/vdu/vdudriver - Remove now-redundant copy loop from ModeChangeSub. Remove code from GenerateModeSelectorVars that sets up the ECFIndex & PalIndex values on the stack
  - s/vdu/vdugrafl - Adjust copy loop in SwitchOutputToSprite/Mask
  - s/vdu/vdupalette, s/vdu/vdupalxx - Add GetPalIndex routine to generate PalIndex on the fly. Drop the obsolete 16bpp palette/gamma table and shuffle the other entries to simplify GetPalIndex a bit.
  - s/vdu/vduplot - Add GetECFIndex routine to generate ECFIndex on the fly. Also, fix things so that mode 0 isn't the only rectangular-pixel mode which uses the special rectangular-pixel ECF patterns (index 0 vs. index 4). Fiddle with ExportedHLine a bit to avoid an out-of-range ADR.
  - s/NewReset - Fix UAL warning for MOV R0, AppSpaceStart. Adjust memset to not assume 512KB is the correct amount
Admin:
  Tested on Raspberry Pi 3


Version 6.11. Tagged as 'Kernel-6_11'
@
text
@; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; vdupalxx

; mjs Sep 2000
;
; Palette programming for generic video controller, delegating h/w
; specifics to HAL calls. Think of any 'VIDC' references here as for a
; generic video controller.

; Format of a 32-bit palette entry in soft palette tables (eg. FirPalAddr) and
; for calls to HAL is:
;
;    BBGGRRSS
;
; ie. 8-8-8-8 bits for Blue-Green-Red-Supremacy
; 'Supremacy' is expected to be 0=solid .. 255=transparent
; [pre-HAL, Medusa kernels used a soft palette format of 0SBBGGRR, being VIDC20-ish]
;
; soft palette tables are indexed by 0..259, where:
;
;   0..255    are normal (display) palette entries
;             type 0, index 0..255 for HAL calls
;   256       is border entry
;             type 1, index 0 for HAL calls
;   257..259  are pointer palette entries
;             type 2, index 1..3 for HAL calls (HAL index 0 assumed to
;             correspond to transparent, and not used)


; *****************************************************************************

; PaletteV handler
; ----------------

; *****************************************************************************
;
;       MOSPaletteV - Default owner of PaletteV
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6
        ASSERT  paletteV_BulkRead = 7
        ASSERT  paletteV_BulkWrite = 8
        ASSERT  paletteV_GammaCorrection = 9
        ASSERT  paletteV_LCDInvert = 10
        ASSERT  paletteV_VIDCDisable = 12
        ASSERT  paletteV_VIDCRestore = 13
        ASSERT  paletteV_ReadGammaCorrection = 14
        ASSERT  paletteV_ReadSupremacyTransfer = 15
        ASSERT  paletteV_SetSupremacyTransfer = 16

MOSPaletteV ROUT
        CMP     r4, #16
        ADDLS   pc, pc, r4, LSL #2
        MOV     pc, lr                  ; reason code not known, so pass it on
        MOV     pc, lr                  ; 0
        B       PV_ReadPalette          ; 1
        B       PV_SetPalette           ; 2
        B       PV_1stFlashState        ; 3
        B       PV_2ndFlashState        ; 4
        B       PV_SetDefaultPalette    ; 5
        B       PV_BlankScreen          ; 6
        B       PV_BulkRead             ; 7
        B       PV_BulkWrite            ; 8
        B       PV_GammaCorrect         ; 9
        MOV     pc, lr                  ; 10 (was PV_LCDInvert)
        MOV     pc, lr                  ; 11
        B       PV_VIDCDisable          ; 12
        B       PV_VIDCRestore          ; 13
        B       PV_ReadGammaCorrect     ; 22
        B       PV_ReadSupremacyXfer    ; 23
        B       PV_SetSupremacyXfer     ; 24

; *****************************************************************************

PV_SetDefaultPalette ROUT
        Push    "r0-r3,r5-r9"
        LDR     r0, [WsPtr, #DisplayModeFlags]
        TST     r0, #ModeFlag_GreyscalePalette
        BNE     %FT30
05
        BL      GetPalIndex             ; the new index 0-6
        ADR     r1, paldptab
        LDR     r2, [r1, r6, LSL #2]    ; offset from r1 to start of table
        ADD     r6, r6, #1              ; point to next item
        LDR     r5, [r1, r6, LSL #2]    ; offset from r1 to end of table +1
        TST     r2, #&80000000          ; if bit 31 set, it's a routine
        BIC     r2, r2, #&80000000      ; clear that flag
        ADD     r2, r2, r1              ; r2 -> start of table
        MOVNE   pc, r2                  ; or call routine
        BIC     r5, r5, #&80000000      ; clear routine flag
        ADD     r5, r5, r1              ; r5 -> end of table
        MOV     r0, #0                  ; start at palette index 0
        MOV     r1, #3                  ; set both halves
10
        LDR     r6, [r2], #4
        MOVS    r3, r6, LSL #17         ; get 1st half word and set carry if flashing
        MOV     r3, r3, LSR #17
        MOVCC   r4, #0
        LDRCS   r4, =&FFF               ; flashing so invert 2nd half RGB
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        MOVS    r3, r6, LSL #1          ; get 2nd half word and set carry if flashing
        MOV     r3, r3, LSR #17
        MOVCC   r4, #0
        LDRCS   r4, =&FFF
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        TEQ     r2, r5
        BNE     %BT10

; now ensure all palette entries from 0..255 are initialised

15
        MOV     r3, #0                  ; set unused (and border) to black
        MOV     r4, #0                  ; no flashing
20
        CMP     r0, #256
        BHS     FinishDefault
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        B       %BT20

30
        ; Check that we know how to generate a greyscale palette for this mode
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TST     r0, #ModeFlag_DataFormatFamily_Mask ; Must be RGB
        BNE     %BT05
        LDR     r6, [WsPtr, #DisplayNColour]
        CMP     r6, #63                 ; not possible in VIDC10 256 colour
        BEQ     %BT05
        LDR     r0, [WsPtr, #Log2BPP]
        CMP     r0, #3                  ; Must be <= 256 colour
        CMPLS   r6, #255                ; Check both values to be sure
        BHI     %BT05
        MOV     r1, #3
        MOV     r2, #0
        ADR     r5, greyscale_mult
        LDR     r5, [r5, r0, LSL #2]
        MOV     r0, #0
35
        MUL     r2, r0, r5
        BL      UpdateNormalColour
        SUBS    r6, r6, #1
        ADD     r0, r0, #1
        BGE     %BT35
        B       %BT15

FinishDefault
        MOV     r2, #0                  ; set border to black (and setup colours 2,3 in BBC gap modes)
        BL      BorderInitEntry

        ; Ensure software pointer palette is refereshed
        LDR     r4, [WsPtr, #GraphicsVFeatures]
        TST     r4, #GVDisplayFeature_HardwarePointer
        LDREQB  r4, [WsPtr, #SWP_Callback]
        TEQEQ   r4, #0
        BLEQ    RegisterSoftwarePointerCallback

        MOV     r4, #0                  ; indicate PaletteV operation complete
        Pull    "r0-r3,r5-r9,pc"        ; restore registers and claim vector

        LTORG
        
greyscale_mult
        DCD     &FFFFFF00 ; 1bpp
        DCD     &55555500 ; 2bpp
        DCD     &11111100 ; 4bpp
        DCD     &01010100 ; 8bpp

; *****************************************************************************

; Table of offsets from paldata_pointer to palette data

paldptab
        &       paldat1-paldptab        ; 2  Colour Modes
        &       paldat2-paldptab        ; 4
        &       paldat4-paldptab        ; 16
        &       (paldat8-paldptab) :OR: &80000000  ; 256 (VIDC10 compatible) - use routine
        &       (paldatLin-paldptab) :OR: &80000000 ; 16bpp, 32bpp, 256 greys - use routine
        &       paldatT-paldptab        ; teletext mode
        &       paldatHR-paldptab       ; Hi-res mono mode
        &       paldatend-paldptab      ; end of table marker

paldat1 ; Data for 1 bit modes - only necessary to program registers 0 and 1

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &0FFF           ; 1  White

paldat2 ; Data for 2 bit modes - only necessary to program registers 0..3

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &000F           ; 1  Red
        DCW     &00FF           ; 2  Yellow
        DCW     &0FFF           ; 3  White

paldat4 ; Data for 4 bit modes - program all registers
        ; Flashing Colours will be needed here

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &000F           ; 1  Red
        DCW     &00F0           ; 2  Green
        DCW     &00FF           ; 3  Yellow
        DCW     &0F00           ; 4  Blue
        DCW     &0F0F           ; 5  Magenta
        DCW     &0FF0           ; 6  Cyan
        DCW     &0FFF           ; 7  White
        DCW     &8000           ; 8  Flashing Black
        DCW     &800F           ; 9  Flashing Red
        DCW     &80F0           ; 10 Flashing Green
        DCW     &80FF           ; 11 Flashing Yellow
        DCW     &8F00           ; 12 Flashing Blue
        DCW     &8F0F           ; 13 Flashing Magenta
        DCW     &8FF0           ; 14 Flashing Cyan
        DCW     &8FFF           ; 15 Flashing White

; Routine to initialise palette for VIDC10-compatible 8bpp modes
; Note this must still be in between paldat4 and paldatT

paldat8 ROUT
        MOV     r1, #3                  ; set both halves of palette
        MOV     r0, #0                  ; starting index
10
        AND     r2, r0, #3              ; get tint bits
        ORR     r2, r2, r2, LSL #4      ; and duplicate into bits 8,9,12,13,16,17,20,21,24,25,28,29
        ORR     r2, r2, r2, LSL #8
        ORR     r2, r2, r2, LSL #16
        BIC     r2, r2, #&FF
        TST     r0, #4
        ORRNE   r2, r2, #&00004400
        TST     r0, #8
        ORRNE   r2, r2, #&44000000
        TST     r0, #&10
        ORRNE   r2, r2, #&00008800
        TST     r0, #&20
        ORRNE   r2, r2, #&00440000
        TST     r0, #&40
        ORRNE   r2, r2, #&00880000
        TST     r0, #&80
        ORRNE   r2, r2, #&88000000
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #1
        TEQ     r0, #&100
        BNE     %BT10
        B       FinishDefault

; Linear / greyscale palette or gamma table
paldatLin ROUT
        ADR     r5, paldatLintab
palmetatab
        MOV     r1, #3                  ; set both halves of palette
        MOV     r0, #0                  ; starting index
10
        MOV     r8, r5
        MOV     r2, #0
        MOV     r6, r0
20
        LDR     r7, [r8], #4
        MOVS    r6, r6, LSR #1
        ORRCS   r2, r2, r7
        BNE     %BT20
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #1
        TEQ     r0, #&100
        BNE     %BT10
        B       FinishDefault

paldatLintab
 [ DefaultSupremacy
        &       &01010101       ; palette bit 0
        &       &02020202       ;             1
        &       &04040404       ;             2
        &       &08080808       ;             3
        &       &10101010       ;             4
        &       &20202020       ;             5
        &       &40404040       ;             6
        &       &80808080       ;             7
 |
        &       &01010100       ; palette bit 0
        &       &02020200       ;             1
        &       &04040400       ;             2
        &       &08080800       ;             3
        &       &10101000       ;             4
        &       &20202000       ;             5
        &       &40404000       ;             6
        &       &80808000       ;             7
 ]

paldatT ; Data for teletext mode

        DCW     &0000           ; 0 Black
        DCW     &000F           ; 1 Red
        DCW     &00F0           ; 2 Green
        DCW     &00FF           ; 3 Yellow
        DCW     &0F00           ; 4 Blue
        DCW     &0F0F           ; 5 Magenta
        DCW     &0FF0           ; 6 Cyan
        DCW     &0FFF           ; 7 White

; Colours 8 to 15 have supremacy bit set

        DCW     &1000           ; 8 Supremacy+ Black
        DCW     &100F           ; 9            Red
        DCW     &10F0           ; 10           Green
        DCW     &10FF           ; 11           Yellow
        DCW     &1F00           ; 12           Blue
        DCW     &1F0F           ; 13           Magenta
        DCW     &1FF0           ; 14           Cyan
        DCW     &1FFF           ; 15           White

paldatHR  ; data for Hi-res mono mode
        DCW     &0000           ; Only red gun necessary
        DCW     &0111           ; but setting all three makes
        DCW     &0222           ; reading it more natural
        DCW     &0333
        DCW     &0444
        DCW     &0555
        DCW     &0666
        DCW     &0777
        DCW     &0888
        DCW     &0999
        DCW     &0AAA
        DCW     &0BBB
        DCW     &0CCC
        DCW     &0DDD
        DCW     &0EEE
        DCW     &0FFF

        DCW     &0000           ; border black
        DCW     &0010           ; fixed pointer colours
        DCW     &0020
        DCW     &0030


paldatend

; *****************************************************************************

; PaletteV call to set palette in bulk
; in:   R0 => list of colours, or 0
;       R1 =  colour type (16,17,18,24,25) in b24-31 & number to do in b23-b00
;       R2 => list of palette entries (both flash states if 16, one if 17/18)
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on

PV_BulkWrite    ROUT
        Push    "R0-R3,R5-R11"          ; pc already stacked

        ;register usage:
        ;[R6] colour list
        ;R7   colour type
        ;R8   max number
        ;[R9] palette entries
        ;R10  loop counter
        ;R11  colour number

        MOV     R7,R1,LSR #24
        BIC     R8,R1,#&FF000000
        MOV     R6,R0
        MOV     R9,R2

        MOV     R10,#0
10
        TEQ     R6,#0
        MOVEQ   R11,R10
        LDRNE   R11,[R6],#4

        TEQ     R7,#16
        TEQNE   R7,#17

        MOVEQ   R0,R11
        MOVEQ   R1,#1+4
        LDREQ   R2,[R9],#4
        BLEQ    UpdateNormalColour

        TEQ     R7,#16
        TEQNE   R7,#18

        MOVEQ   R0,R11
        MOVEQ   R1,#2+4
        LDREQ   R2,[R9],#4
        BLEQ    UpdateNormalColour

        TEQ     R7,#24

        MOVEQ   R0,R11
        LDREQ   R2,[R9],#4
        BLEQ    BorderColour

        TEQ     R7,#25

        MOVEQ   R0,R11
        LDREQ   R2,[R9],#4
        BLEQ    PointerColour

        ADD     R10,R10,#1
        CMP     R10,R8
        BCC     %BT10

        ; Update greyscale palette mode flag as appropriate
        LDR     r2, [WsPtr, #DisplayNColour]
        CMP     r7, #19
        CMP     r2, #256
        BHS     %FT90
        PHPSEI
        LDR     r7, [WsPtr, #DisplayModeFlags]
        CMP     r2, #63
        LDR     r5, [WsPtr, #FirPalAddr]
        MOVEQ   r2, #255
        LDR     r6, [WsPtr, #SecPalAddr]
        BIC     r7, r7, #ModeFlag_GreyscalePalette
30
        LDR     r8, [r5], #4
        LDR     r9, [r6], #4
        EOR     r8, r8, r8, LSL #8
        EOR     r9, r9, r9, LSL #8
        CMP     r8, #&10000
        CMPLO   r9, #&10000
        BHS     %FT40
        SUBS    r2, r2, #1
        BGE     %BT30
        ORR     r7, r7, #ModeFlag_GreyscalePalette
40
        STR     r7, [WsPtr, #DisplayModeFlags]
        ; Update live ModeFlags if not redirected to sprite
        LDR     r8, [WsPtr, #VduSprite]
        TEQ     r8, #0
        STREQ   r7, [WsPtr, #ModeFlags]
        PLP
90

        MOV     R4,#0
        Pull    "R0-R3,R5-R11,PC"

; *****************************************************************************

; PaletteV call to set palette
; in:   R0 = logical colour
;       R1 = colour type (16,17,18,24,25)
;       R2 = BBGGRRSS
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on
;

;amg 19/4/93 - change this routine to make all the calls subroutines rather
; than branches. Although it will slow this down a bit, it makes the bulk
; write a lot simpler and involves less duplication of mungeing code.

PV_SetPalette ROUT
        Push    "r0-r3"
        TEQ     r1, #16                 ; if 16 then set both colours
        MOVEQ   r1, #3
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #17                 ; elif 17 then set 1st colour
        MOVEQ   r1, #1
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #18                 ; elif 18 then set 2nd colour
        MOVEQ   r1, #2
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #24                 ; elif 24 then border colour
        BEQ     Call_BorderColour

        TEQ     r1, #25                 ; elif 25 then pointer colour
        BEQ     Call_PointerColour
10
        Pull    "r0-r3"
        MOV     pc, lr                  ; else not defined

Call_UpdateNormalColour
        BL      UpdateNormalColour
        Pull    "r0-r3,pc"

BorderInitEntry Push "r0-r3,lr"           ; entry used in default palette setting
Call_BorderColour
        BL      BorderColour
        Pull    "r0-r3,pc"

Call_PointerColour
        BL      PointerColour
        Pull    "r0-r3,pc"

; *****************************************************************************

UpdateNormalColour ROUT
        Push    "LR"
        LDR     lr, [WsPtr, #DisplayNColour] ; get the mask
        TEQ     lr, #63                 ; is it brain-damaged VIDC10-compatible 256 colour mode?
        BEQ     %FT10
        AND     r0, r0, lr              ; and mask it off
        AND     r0, r0, #255            ; definitely no more than 256 palette entries
        BL      UpdateSettingAndVIDC
05
        LDR     r4, [WsPtr, #GraphicsVFeatures]
        TST     r4, #GVDisplayFeature_HardwarePointer
        LDREQB  r4, [WsPtr, #SWP_Callback]
        TEQEQ   r4, #0
        LDREQB  r4, [WsPtr, #DisplayLog2BPP]
        TSTEQ   r4, #&FC                ; Callback only needed here for <=8bpp
        BLEQ    RegisterSoftwarePointerCallback
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "pc"

10
        AND     r0, r0, #15             ; starting palette entry
20
        LDR     r3, =&88CC8800          ; r3 = bits controlled by bits 4..7 of pixel value
        BIC     r2, r2, r3
        TST     r0, #&10                ; test bit 4 (r3,7)
        ORRNE   r2, r2, #&00008800
        TST     r0, #&20                ; test bit 5 (g2,6)
        ORRNE   r2, r2, #&00440000
        TST     r0, #&40                ; test bit 6 (g3,7)
        ORRNE   r2, r2, #&00880000
        TST     r0, #&80                ; test bit 7 (b3,7)
        ORRNE   r2, r2, #&88000000
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #&10
        CMP     r0, #&100
        BCC     %BT20
        B       %BT05

BorderColour ROUT
        Push    "LR"
        MOV     r0, #256                ; pseudo-palette-index for border colour
        MOV     r1, #3                  ; both colours
        BL      UpdateSettingAndVIDC

; Now test for BBC gap mode (ie 3 or 6)
; if so then set colour 2 to same as border, and colour 3 to inverse

        LDR     lr, [WsPtr, #DisplayModeFlags]
        TST     lr, #ModeFlag_BBCGapMode
        BEQ     %FT10

        MOV     r0, #2                  ; make colour 2 (gap) same as border
        BL      UpdateSettingAndVIDC

        MOV     r0, #3                  ; make colour 3 inverse gap
        MVN     r2, r2                  ; invert R, G and B
        EOR     r2, r2, #&FF            ; but use same supremacy
        BL      UpdateSettingAndVIDC
10
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "pc"


PointerColour ROUT
        Push    "LR"
        ANDS    r0, r0, #3              ; force pointer colour number in range 1..3
        BEQ     %FT10                   ; zero is invalid
        ADD     r0, r0, #256            ; index in range 257..259
        MOV     r1, #3
        BL      UpdateSettingAndVIDC
10
        LDR     r4, [WsPtr, #GraphicsVFeatures]
        TST     r4, #GVDisplayFeature_HardwarePointer
        LDREQB  r4, [WsPtr, #SWP_Callback]
        TEQEQ   r4, #0
        BLEQ    RegisterSoftwarePointerCallback
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "pc"

; UpdateSettingStraightRGB
;
; in:   r0 = index (0..255 for normal, 256 for border, 257..259 for pointer)
;       r1 = bit mask of which flash states to update (bit 0 set => 1st, bit 1 set => 2nd)
;            bit 2 set to suppress greyscale palette check
;       r3 = SBGR
;       r4 = SBGR to EOR with to go from 1st to 2nd flash state

; out:  r0,r1,r2,r4 preserved
;       r3 corrupted

UpdateSettingStraightRGB EntryS "r2,r5,r6,r7"

        ANDS    r5, r3, #1 :SHL: 12     ; get supremacy bit (s) in 1st colour
        MOVNE   r5, #&FF                ; r5 = 000000SS
        AND     r6, r3, #&FF0           ; r6 = 00000BG0
        ORR     r5, r5, r6, LSL #16     ; r5 = 0BG000SS
        AND     r6, r3, #&0FF           ; r6 = 000000GR
        ORR     r5, r5, r6, LSL #12     ; r5 = 0BGGR0SS
        AND     r6, r3, #&00F           ; r6 = 0000000R
        ORR     r5, r5, r6, LSL #8      ; r5 = 0BGGRRSS
        AND     r6, r3, #&F00           ; r6 = 00000B00
        ORR     r3, r5, r6, LSL #20     ; r3 = BBGGRRSS

        ANDS    r5, r4, #1 :SHL: 12     ; get supremacy bit (s) in EOR mask
        MOVNE   r5, #&FF                ; r5 = 000000SS
        AND     r6, r4, #&FF0           ; r6 = 00000BG0
        ORR     r5, r5, r6, LSL #16     ; r5 = 0BG000SS
        AND     r6, r4, #&0FF           ; r6 = 000000GR
        ORR     r5, r5, r6, LSL #12     ; r5 = 0BGGR0SS
        AND     r6, r4, #&00F           ; r6 = 0000000R
        ORR     r5, r5, r6, LSL #8      ; r5 = 0BGGRRSS
        AND     r6, r4, #&F00           ; r6 = 00000B00
        ORR     r4, r5, r6, LSL #20     ; r4 = BBGGRRSS

        B       UpdateSettingCommon


; UpdateSettingAndVIDC
;
; in:   r0 = index (0..255 for normal, 256 for border, 257..259 for pointer)
;       r1 = bit mask of which flash states to update (bit 0 set => 1st, bit 1 set => 2nd)
;            bit 2 set to suppress greyscale palette check
;       r2 = BBGGRRSS
;
; out:  r0, r1, r2 preserved
;       r3, r4 corrupted
;

UpdateSettingAndVIDC ALTENTRY

        MOV     r3, r2
        MOV     r4, #0                  ; indicate no EORing between parts

; ... and drop thru to

; UpdateSettingCommon
;
; in:   r0 = index (0..255 for normal, 256 for border, 257..259 for pointer)
;       r1 = bit mask of which flash states to update (bit 0 set => 1st, bit 1 set => 2nd)
;            bit 2 set to suppress greyscale palette check
;       r3 = BBGGRRSS
;       r4 = BBGGRRSS to EOR with to go from 1st to 2nd flash state
;       r2, r5, r6, r7, lr stacked
;
; out:  r0, r1, r2, r4 preserved
;       r3 corrupted
;
UpdateSettingCommon ROUT
        PHPSEI                          ; protect against IRQs

        Push    "r8, r9"

        LDRB    r5, [WsPtr, #ScreenBlankFlag]
        TEQ     r5, #0
        MOVNE   r5, #&FFFFFFFF          ; bits to knock out if blanked

        LDROSB  r2, FlashState          ; 0 => second, 1 => first
        CMP     r2, #1                  ; C=0 => second, C=1 => first

        TST     r1, #1
        BEQ     %FT10                   ; skip if not setting 1st colour
        LDR     r2, [WsPtr, #FirPalAddr]
        ADD     r8, r2, #Pal_RTable-Pal_LogFirst ; r8 -> rgb transfer tables
        STR     r3, [r2, r0, LSL #2]!   ; store in logical colour and write back pointer
        AND     r6, r3, #&0000FF00      ; r6 = red << 8
        LDRB    r6, [r8, r6, LSR #8]    ; r6 = gamma(red)
        ADD     r8, r8, #&100           ; r8 -> green transfer
        AND     r9, r3, #&00FF0000      ; r9 = green << 16
        LDRB    r9, [r8, r9, LSR #16]   ; r9 = gamma(green)
        ORR     r6, r6, r9, LSL #8      ; r6 = gamma(red) + (gamma(green)<<8)
        ADD     r8, r8, #&100           ; r8 -> blue transfer
        AND     r9, r3, #&FF000000      ; r9 = blue << 24
        LDRB    r9, [r8, r9, LSR #24]   ; r9 = gamma(blue)
        ORR     r6, r6, r9, LSL #16     ; r6 = gamma(red) + (gamma(green)<<8) + (gamma(blue)<<16)
        ADD     r8, r8, #&100           ; r8 -> supremacy transfer
        AND     r9, r3, #&000000FF      ; r9 = supremacy
        LDRB    r9, [r8, r9]            ; r9 = transfer(supremacy)
        ORR     r6, r9, r6, LSL #8      ; r6 = gamma(rgb) + transfer(supremacy)
        STR     r6, [r2, #Pal_PhysFirst-Pal_LogFirst] ; store in physical copy

        BCC     %FT10                   ; only hit hardware if flash state = first

;;; mjs
;;; Pre HAL code had possible LCD greyscale munging, not supported in interim s.vduhint code
;;;
        Push    "r0-r2,r4,lr"
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_WritePaletteEntry
        BIC     r1, r6, r5                ; r1 = palette colour after knocking out blanking bits
        AND     r2, r0, #255              ; reduced index (0..255 normal, 0 border, 1..3 pointer)
        CMP     r0, #256                  ; HI if pointer
        MOVLS   r0, r0, LSR #8            ; type 0=normal, 1=border
        MOVHI   r0, #2                    ; type 2=pointer
        BL      CallGraphicsV
        Pull    "r0-r2,r4,lr"

10
        EOR     r3, r3, r4              ; toggle requested bits for 2nd half
        TST     r1, #2
        BEQ     %FT20                   ; skip if not setting 2nd colour
        LDR     r2, [WsPtr, #SecPalAddr]
        ADD     r8, r2, #Pal_RTable-Pal_LogSecond ; r8 -> rgb transfer tables
        STR     r3, [r2, r0, LSL #2]!   ; store in logical copy and write back

        AND     r6, r3, #&0000FF00      ; r6 = red << 8
        LDRB    r6, [r8, r6, LSR #8]    ; r6 = gamma(red)
        ADD     r8, r8, #&100           ; r8 -> green transfer
        AND     r9, r3, #&00FF0000      ; r9 = green << 16
        LDRB    r9, [r8, r9, LSR #16]   ; r9 = gamma(green)
        ORR     r6, r6, r9, LSL #8      ; r6 = gamma(red) + (gamma(green)<<8)
        ADD     r8, r8, #&100           ; r8 -> blue transfer
        AND     r9, r3, #&FF000000      ; r9 = blue << 24
        LDRB    r9, [r8, r9, LSR #24]   ; r9 = gamma(blue)
        ORR     r6, r6, r9, LSL #16     ; r6 = gamma(red) + (gamma(green)<<8) + (gamma(blue)<<16)
        ADD     r8, r8, #&100           ; r8 -> supremacy transfer
        AND     r9, r3, #&000000FF      ; r9 = supremacy
        LDRB    r9, [r8, r9]            ; r9 = transfer(supremacy)
        ORR     r6, r9, r6, LSL #8      ; r6 = gamma(rgb) + transfer(supremacy)
        STR     r6, [r2, #Pal_PhysSecond-Pal_LogSecond] ; store in physical copy

        BCS     %FT20                   ; only hit hardware if flash state = second

;;; mjs
;;; Pre HAL code had possible LCD greyscale munging, not supported in interim s.vduhint code
;;;
        Push    "r0-r2,r4,lr"
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_WritePaletteEntry
        BIC     r1, r6, r5                ; r1 = palette colour after knocking out blanking bits
        AND     r2, r0, #255              ; reduced index (0..255 normal, 0 border, 1..3 pointer)
        CMP     r0, #256                  ; HI if pointer
        MOVLS   r0, r0, LSR #8            ; type 0=normal, 1=border
        MOVHI   r0, #2                    ; type 2=pointer
        BL      CallGraphicsV
        Pull    "r0-r2,r4,lr"

20
        ; Update greyscale palette mode flag as appropriate
        ; NOTE - relies on r3 being 2nd flash state
        LDR     r2, [WsPtr, #DisplayNColour]
        CMP     r0, #256
        CMPLO   r2, #256
        CMPLO   r1, #4
        BHS     %FT90
        EOR     r4, r3, r4              ; r4 = 1st flash state, r3 = 2nd
        EOR     r8, r3, r3, LSL #8
        EOR     r9, r4, r4, LSL #8
        TST     r1, #1
        MOVEQ   r9, #0                  ; treat unmodified flash states as greyscale - the full check below will sort things out properly if required
        TST     r2, #1
        MOVEQ   r8, #0
        CMP     r8, #&10000
        CMPLO   r9, #&10000
        ; LO -> palette potentially greyscale, HS -> definitely not greyscale
        LDR     r7, [WsPtr, #DisplayModeFlags]
        BICHS   r7, r7, #ModeFlag_GreyscalePalette
        BHS     %FT40
        TST     r7, #ModeFlag_GreyscalePalette
        BNE     %FT90
        ; Check the full palette for greyscaleness
        CMP     r2, #63
        LDR     r5, [WsPtr, #FirPalAddr]
        MOVEQ   r2, #255
        LDR     r6, [WsPtr, #SecPalAddr]
30
        LDR     r8, [r5], #4
        LDR     r9, [r6], #4
        EOR     r8, r8, r8, LSL #8
        EOR     r9, r9, r9, LSL #8
        CMP     r8, #&10000
        CMPLO   r9, #&10000
        BHS     %FT90
        SUBS    r2, r2, #1
        BGE     %BT30
        ORR     r7, r7, #ModeFlag_GreyscalePalette
40
        STR     r7, [WsPtr, #DisplayModeFlags]
        ; Update live ModeFlags if not redirected to sprite
        LDR     r8, [WsPtr, #VduSprite]
        TEQ     r8, #0
        STREQ   r7, [WsPtr, #ModeFlags]
90
        PLP
        Pull    "r8, r9"
        EXITS                           ; restore registers, claim vector

; *****************************************************************************
;
; PV_BulkRead - Read multiple palette entries with one call
;
; in:   R0 => list of colours wanted, or 0 to start with first and increment
;       R1 =  b24-b31 - colour type: 16/17/18/24/25
;             b00-b23 - number of colours to do
;
;       R2 => memory for first flash state colours (and second if R3=0)
;       R3 => memory for second flash state colours (if 0, intermingle with R2 instead)
;
; out:  all preserved (R4 set to 0 to show call handled)

; flags used to control routine

PV_BR_WantFirst *       1               ; doing 16 or 17
PV_BR_WantSecond *      2               ; doing 16 or 18
PV_BR_HaveList *        4               ; we have a list of colours
PV_BR_TwoLists *        8               ; we have two output areas (R2 & R3 valid)
PV_BR_Border   *        16              ; doing 24
PV_BR_Mouse    *        32              ; doing 25

PV_BulkRead ROUT
        Push    "R0-R3,R6-R11"             ; return addr already stacked

        MOV     R6,R1,LSR #24           ; isolate the colour type

        MOV     R7,#(PV_BR_WantFirst + PV_BR_WantSecond)

        CMP     R6,#17                  ; do we want both flash states ?
        BICEQ   R7,R7,#PV_BR_WantSecond ; if 17 only want first flash state

        CMP     R6,#18
        BICEQ   R7,R7,#PV_BR_WantFirst  ; if 18 only want second flash state

        CMP     R6,#24
        ORREQ   R7,R7,#PV_BR_Border
        ORRGT   R7,R7,#PV_BR_Mouse

        ;now set up other control flags
        CMP     R0,#0
        ORRNE   R7,R7,#PV_BR_HaveList   ; we have a list of colours

        CMP     R3,#0
        ORRNE   R7,R7,#PV_BR_TwoLists   ; we have two output areas

        ;set up a mask for the number of colours
        LDR     R8,[WsPtr,#DisplayNColour]
        TEQ     R8,#63
        MOVEQ   R8,#255                 ; deal with braindamaged 8BPP case

        ;the mouse has colours 1-3
        TST     R7,#PV_BR_Mouse
        MOVNE   R8,#3

        ;take the colour type off the top of R1, leaving #colours wanted
        BIC     R1,R1,#&FF000000

        ; register usage:
        ; [R0]: colour list
        ; R1: number of colours
        ; [R2]: first flash state list
        ; [R3]: second flash state list
        ; R7: control flags
        ; R8: mask for colour number
        ; R9: loop counter
        ; R10: misc
        ; LR: misc

        MOV     R9,#0
30
        TST     R7,#PV_BR_HaveList
        LDRNE   LR,[R0],#4
        MOVEQ   LR,R9                   ; LR = wanted colour number

        AND     LR,LR,R8                ; ensure it is sensible

        TST     R7,#PV_BR_Border
        MOVNE   LR,#256                 ; border is stored as colour 256

        TST     R7,#PV_BR_Mouse
        BEQ     %FT40

        TEQ     LR,#0
        BEQ     %FT50                   ;colour 0 is invalid
        ADD     LR,LR,#256              ;bring into range (257-259)

40
        TST     R7,#PV_BR_WantFirst

        LDRNE   R10,[WsPtr,#FirPalAddr]

        LDRNE   R11,[R10,LR,LSL#2]      ; BBGGRRSS
        STRNE   R11,[R2],#4

        TST     R7,#PV_BR_WantSecond
        BEQ     %FT60                   ; have to use a branch here - another TST coming up

        LDR     R10,[WsPtr,#SecPalAddr]

        LDR     R11,[R10,LR,LSL#2]      ; BBGGRRSS

        TST     R7,#PV_BR_TwoLists

        STREQ   R11,[R2],#4
        STRNE   R11,[R3],#4

60      ADD     R9,R9,#1
        CMP     R9,R1
        BCC     %BT30
50
        MOV     R4,#0
        Pull    "R0-R3,R6-R11,PC"          ; return addr already stacked


; *****************************************************************************
;
;       PV_ReadPalette - PaletteV read palette handler
;
; in:   R0 = logical colour
;       R1 = 16 (read normal colour)
;            24 (read border colour)
;            25 (read cursor colour)
;
; out:  R2 = first flash setting   (BBGGRRSS)
;       R3 = second flash setting  (BBGGRRSS)
;

PV_ReadPalette ROUT
        Push    "r10,r11"
        LDR     r10, [WsPtr, #DisplayNColour] ; logical colours in this mode -1
        TEQ     r10, #63                ; if bodgy 256 colour mode
        MOVEQ   r10, #255               ; then use AND mask of 255

        TEQ     r1, #24                 ; is it reading border palette
        MOVEQ   r11, #&100              ; then set up border index
        BEQ     %FT10                   ; and go

        TEQ     r1, #25                 ; is it reading pointer palette
        BEQ     %FT05
        AND     r11, r0, r10            ; no, then force into suitable range
        B       %FT10                   ; always skip
05
        ANDS    r11, r0, #3             ; else force logical colour 0..3
        BEQ     %FT99                   ; and 0 is illegal, so do nothing
        ADD     r11, r11, #&100         ; set up correct index
10

; note no need to fudge 256-colour modes, since we have the correct full 256 entry palette

        LDR     r10, [WsPtr, #FirPalAddr]
        LDR     r2, [r10, r11, LSL #2]  ; r2 := 1st BBGGRRSS
        LDR     r10, [WsPtr, #SecPalAddr]
        LDR     r3, [r10, r11, LSL #2]  ; r3 := 2nd BBGGRRSS
99
        MOV     r4, #0
        Pull    "r10, r11, pc"

; *****************************************************************************
;
;       PV_1stFlashState - PaletteV routine to set first flash state
;

PV_1stFlashState ROUT
        Entry   "r0-r3"
        LDRB    r1, [WsPtr, #ScreenBlankFlag]
        TEQ     r1, #0
        LDREQ   r1, [WsPtr, #FirPalAddr]
        ADDEQ   r1, r1, #Pal_PhysFirst - Pal_LogFirst ; move pointer to physical palette copy
        LDRNE   r1, [WsPtr, #BlankPalAddr]
DoR0Flash
        MOV     r0, #0                  ; type 0 (normal)
        MOV     r2, #0                  ; start at entry 0
        MOV     r3, #256                ; 256 entries
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_WritePaletteEntries
        BL      CallGraphicsV
        EXIT

; *****************************************************************************
;
;       PV_2ndFlashState - PaletteV routine to set second flash state
;

PV_2ndFlashState ROUT
        ALTENTRY
        LDRB    r1, [WsPtr, #ScreenBlankFlag]
        TEQ     r1, #0
        LDREQ   r1, [WsPtr, #SecPalAddr]
        ADDEQ   r1, r1, #Pal_PhysFirst-Pal_LogFirst ; move pointer to physical palette copy
        LDRNE   r1, [WsPtr, #BlankPalAddr]
        B       DoR0Flash

; *****************************************************************************
;
;       UpdateAllPalette - Update all VIDC palette entries
;

UpdateAllPalette ROUT
        Entry   "r0-r4, r9-r11"
;sort out which palette to use
        LDROSB  r0, FlashState
        CMP     r0, #1
        LDRCS   r1, [WsPtr, #FirPalAddr]   ; FlashState = 1 => 1st state, 0 => 2nd state
        LDRCC   r1, [WsPtr, #SecPalAddr]
        ADD     r1, r1, #Pal_PhysFirst-Pal_LogFirst ; move pointer to physical palette copy
        LDRB    r10, [WsPtr, #ScreenBlankFlag]
        TEQ     r10, #0
        LDRNE   r1, [WsPtr, #BlankPalAddr] ; blank palette after all
;
        ADD     r10, r1, #256*4            ; pointer to border colour
        PHPSEI  r11                        ; disable IRQs round this bit
;first, the normal colours
        MOV     r0, #0                  ; type 0 (normal)
        MOV     r2, #0                  ; start at entry 0
        MOV     r3, #256                ; 256 entries
        LDR     r9, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r9, r9, LSL #24
        ORR     r4, r9, #GraphicsV_WritePaletteEntries
        BL      CallGraphicsV
;next, border colour
        LDR     r1, [r10]               ; border colour
        MOV     r0, #1                  ; type 1
        MOV     r2, #0                  ; index 0
        ORR     r4, r9, #GraphicsV_WritePaletteEntry
        BL      CallGraphicsV
;finally, pointer colours
        ADD     r1, r10, #4             ; pointer to pointer colours (oh yes)
        MOV     r0, #2                  ; type 2
        MOV     r2, #1                  ; start at index 1
        MOV     r3, #3                  ; 3 entries
        ORR     r4, r9, #GraphicsV_WritePaletteEntries
        BL      CallGraphicsV
;
        PLP     r11
        EXIT

; *****************************************************************************
;
;       PV_BlankScreen - Blank/unblank screen
;
; in:   R0 = -1 => read blank state
;       R0 = 0 => unblank screen
;       R0 = 1 => blank screen
;
; out:  R0 = old state (0=unblanked, 1=blanked)
;       R4 = 0

PV_BlankScreen ROUT
        Push    "r1-r3, r9"

        LDRB    r3, [WsPtr, #ScreenBlankFlag]
        CMP     r0, #1
        BHI     %FT99                   ; just reading
        TEQ     r0, r3                  ; changing to same state?
        BEQ     %FT99                   ; if so, do nothing

        AND     r0, r0, #1
        STRB    r0, [WsPtr, #ScreenBlankFlag]      ; update new state
        LDRB    r1, [WsPtr, #ScreenBlankDPMSState]

        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_SetBlank
        BL      CallGraphicsV

        ; for backward compatibility, show video DMA state in
        ; MEMC soft copy (DON'T call OS_UpdateMEMC, which would also
        ; make redundant call to HAL)
        ;
        SavePSR r2
        LDR     r9, =ZeroPage
        WritePSRc SVC_mode+I_bit+F_bit, r14
        LDR     r1, [r9, #MEMC_CR_SoftCopy]
        TEQ     r0, #1
        BICEQ   r1, r1, #(1 :SHL: 10)
        ORRNE   r1, r1, #(1 :SHL: 10)
        STR     r1, [r9, #MEMC_CR_SoftCopy]
        RestPSR r2

        BL      UpdateAllPalette        ; update all palette, including border + pointer

99
        MOV     r0, r3
        MOV     r4, #0
        Pull    "r1-r3, r9, pc"

; *****************************************************************************
;
;       PV_ReadGammaCorrect - Read gamma correction tables
;
; in:   r0 -> red table
;       r1 -> green table
;       r2 -> blue table
;
; out:  r4 = 0

PV_ReadGammaCorrect ROUT
        Push    "r0-r3"
        LDR     r4, [WsPtr, #FirPalAddr]
        ADD     r4, r4, #Pal_RTable-Pal_LogFirst; point to gamma tables
        ADD     r3, r4, #256
10
        LDR     lr, [r4], #4
        STR     lr, [r0], #4
        TEQ     r4, r3
        BNE     %BT10

        ASSERT  Pal_GTable = Pal_RTable+256
        ADD     r3, r4, #256
20
        LDR     lr, [r4], #4
        STR     lr, [r1], #4
        TEQ     r4, r3
        BNE     %BT20

        ASSERT  Pal_BTable = Pal_GTable+256
        ADD     r3, r4, #256
30
        LDR     lr, [r4], #4
        STR     lr, [r2], #4
        TEQ     r4, r3
        BNE     %BT30

        MOV     r4, #0
        Pull    "r0-r3, pc"

; *****************************************************************************
;
;       PV_GammaCorrect - Update gamma correction tables
;
; in:   r0 -> red table
;       r1 -> green table
;       r2 -> blue table
;
; out:  r4 = 0

PV_GammaCorrect ROUT
        Push    "r0-r3"
        LDR     r4, [WsPtr, #FirPalAddr]
        ADD     r4, r4, #Pal_RTable-Pal_LogFirst; point to gamma tables
        ADD     r3, r4, #256
10
        LDR     lr, [r0], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT10

        ASSERT  Pal_GTable = Pal_RTable+256
        ADD     r3, r4, #256
20
        LDR     lr, [r1], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT20

        ASSERT  Pal_BTable = Pal_GTable+256
        ADD     r3, r4, #256
30
        LDR     lr, [r2], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT30

        BL      RecomputeLogicalPalette

        MOV     r4, #0
        Pull    "r0-r3, pc"


; go through the logical palette, recomputing the physical from it using the new tables
;
; out:  r0-r4 corrupted

RecomputeLogicalPalette ROUT
        Push    "r5-r8, lr"

        LDR     r4, [WsPtr, #FirPalAddr]        ; r4 -> start of logical palette
        ADD     r5, r4, #Pal_PhysFirst-Pal_LogFirst ; r5 -> start of physical palette
        MOV     r6, r5                          ; r6 = r5 = end of logical palette
        ADD     r0, r4, #Pal_RTable-Pal_LogFirst; r0 -> red table
        ADD     r1, r4, #Pal_GTable-Pal_LogFirst; r1 -> green table
        ADD     r2, r4, #Pal_BTable-Pal_LogFirst; r2 -> blue table
        ADD     r3, r4, #Pal_STable-Pal_LogFirst; r3 -> supremacy table
40
        LDR     r7, [r4], #4                    ; get word
        AND     r8, r7, #&0000FF00              ; r8 = red << 8
        LDRB    r8, [r0, r8, LSR #8]            ; r8 = gamma(red)
        AND     lr, r7, #&00FF0000              ; lr = green << 16
        LDRB    lr, [r1, lr, LSR #16]           ; lr = gamma(green)
        ORR     r8, r8, lr, LSL #8              ; r8 = gamma(red) + (gamma(green)<<8)
        AND     lr, r7, #&FF000000              ; lr = blue << 24
        LDRB    lr, [r2, lr, LSR #24]           ; lr = gamma(blue)
        ORR     r8, r8, lr, LSL #16             ; r8 = gamma(red) + (gamma(green)<<8) + (gamma(blue)<<16)
        AND     lr, r7, #&000000FF              ; lr = supremacy
        LDRB    lr, [r3, lr]                    ; lr = transfer(supremacy)
        ORR     r8, lr, r8, LSL #8              ; r8 = gamma-corrected BBGGRRSS value
        STR     r8, [r5], #4                    ; store word
        TEQ     r4, r6
        BNE     %BT40

        BL      UpdateAllPalette

        Pull    "r5-r8, pc"

; *****************************************************************************
;
;       PV_ReadSupremacyXfer - Read supremacy transfer table
;
; in:   r0 -> supremacy table
;
; out:  r4 = 0

PV_ReadSupremacyXfer ROUT
        Push    "r0,r3"
        LDR     r4, [WsPtr, #FirPalAddr]
        ADD     r4, r4, #Pal_STable-Pal_LogFirst; point to supremacy table
        ADD     r3, r4, #256
10
        LDR     lr, [r4], #4
        STR     lr, [r0], #4
        TEQ     r4, r3
        BNE     %BT10

        MOV     r4, #0
        Pull    "r0,r3, pc"

; *****************************************************************************
;
;       PV_SetSupremacyXfer - Read supremacy transfer table
;
; in:   r0 -> supremacy table
;
; out:  r4 = 0

PV_SetSupremacyXfer ROUT
        Push    "r0-r3"
        LDR     r4, [WsPtr, #FirPalAddr]
        ADD     r4, r4, #Pal_STable-Pal_LogFirst; point to supremacy table
        ADD     r3, r4, #256
10
        LDR     lr, [r0], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT10

        BL      RecomputeLogicalPalette

        MOV     r4, #0
        Pull    "r0-r3, pc"


; *****************************************************************************

PV_VIDCDisable  ROUT
        Push    "r0-r3, r9, r12"

        MOV     r0, #1
        AddressHAL
        CallHAL HAL_VideoSetPowerSave

        MOV     r4, #0
        Pull    "r0-r3, r9, r12, pc"

; *****************************************************************************

PV_VIDCRestore  ROUT
        Push    "r0-r3, r9, r12"

        MOV     r0, #0
        AddressHAL
        CallHAL HAL_VideoSetPowerSave

        MOV     r4, #0
        Pull    "r0-r3, r9, r12, pc"

        END
@


4.4
log
@Fix some pointer colour issues. Fix PaletteV 6 (blank screen) return value.
Detail:
  s/vdu/vdudriver - On startup, initialise all palettes to 0, not just Pal_Blank. Ensures that entries which might not always be explicitly initialised (e.g. pointer) are self-consistent. Also make sure InitialiseMode communicates the pointer palette to the new GV driver, since some components tend to program it in a lazy manner (e.g. Hourglass)
  s/vdu/vdupalxx - Fix UpdateAllPalette setting R4 to 0 on exit. Fix PV_BlankScreen R0 return value to be 0/1 as the comment suggests instead of always being 0 due to GraphicsV calls.
Admin:
  Tested on wandboard
  Fixes incorrect hourglass colours after reset, due to software RAM clear not wiping the kernel's palette (kernel + Hourglass thought old colours were still in use, but IMXVideo hadn't been told any colours yet so was using defaults of 0)


Version 5.96. Tagged as 'Kernel-5_96'
@
text
@d100 1
a100 1
        LDR     r0, [WsPtr, #PalIndex]  ; the new index 0-7
d102 3
a104 3
        LDR     r2, [r1, r0, LSL #2]    ; offset from r1 to start of table
        ADD     r0, r0, #1              ; point to next item
        LDR     r5, [r1, r0, LSL #2]    ; offset from r1 to end of table +1
d198 1
a200 2
        &       (paldat16-paldptab) :OR: &80000000 ; 16 bpp - use routine
        &       (paldat32-paldptab) :OR: &80000000 ; 32 bpp (or 256 greys - they're identical!) - use routine
d271 42
a357 65
paldat16 ROUT
        ADR     r5, paldat16tab
palmetatab
        MOV     r1, #3                  ; set both halves of palette
        MOV     r0, #0                  ; starting index
10
        MOV     r8, r5
        MOV     r2, #0
        MOV     r6, r0
20
        LDR     r7, [r8], #4
        MOVS    r6, r6, LSR #1
        ORRCS   r2, r2, r7
        BNE     %BT20
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #1
        TEQ     r0, #&100
        BNE     %BT10
        B       FinishDefault

paldat16tab
 [ DefaultSupremacy
        &       &00000800       ; palette bit 0
        &       &00081000       ;             1
        &       &08102100       ;             2
        &       &102142FF       ;             3
        &       &21428400       ;             4
        &       &42840000       ;             5
        &       &84000000       ;             6
        &       &00000000       ;             7
 |
        &       &00000800       ; palette bit 0
        &       &00081000       ;             1
        &       &08102100       ;             2
        &       &10214200       ;             3
        &       &21428400       ;             4
        &       &42840000       ;             5
        &       &84000000       ;             6
        &       &00000000       ;             7
 ]

paldat32 ROUT
        ADR     r5, paldat32tab
        B       palmetatab

paldat32tab
 [ DefaultSupremacy
        &       &01010101       ; palette bit 0
        &       &02020202       ;             1
        &       &04040404       ;             2
        &       &08080808       ;             3
        &       &10101010       ;             4
        &       &20202020       ;             5
        &       &40404040       ;             6
        &       &80808080       ;             7
 |
        &       &01010100       ; palette bit 0
        &       &02020200       ;             1
        &       &04040400       ;             2
        &       &08080800       ;             3
        &       &10101000       ;             4
        &       &20202000       ;             5
        &       &40404000       ;             6
        &       &80808000       ;             7
 ]
@


4.3
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d1027 1
a1027 1
        Entry   "r0-r3, r9-r11"
a1062 1
        MOV     r4, #0
d1079 1
a1079 1
        LDRB    r4, [WsPtr, #ScreenBlankFlag]
d1082 1
a1082 1
        TEQ     r0, r4                  ; changing to same state?
d1111 1
a1111 1
        MOV     r0, r4
@


4.3.2.1
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d1027 1
a1027 1
        Entry   "r0-r4, r9-r11"
d1063 1
d1080 1
a1080 1
        LDRB    r3, [WsPtr, #ScreenBlankFlag]
d1083 1
a1083 1
        TEQ     r0, r3                  ; changing to same state?
d1112 1
a1112 1
        MOV     r0, r3
@


4.2
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a62 1
 [ LCDInvert
a63 2
 ]
 [ StorkPowerSave
a65 1
 ]
a85 1
 [ StorkPowerSave
a87 4
 |
        MOV     pc, lr                  ; 12
        MOV     pc, lr                  ; 13
 ]
a1280 2
 [ StorkPowerSave

a1304 2
 ]   ; StorkPowerSave

@


4.1
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@d88 1
a88 5
 [ LCDInvert :LAND: :LNOT: HAL
        B       PV_LCDInvert            ; 10
 |
        MOV     pc, lr                  ; 10
 ]
a1289 14
 [ LCDInvert :LAND: :LNOT: HAL
; *****************************************************************************
;
;       PV_LCDInvert - Invert the LCD palette
;
; in:   r0 = inversion state to use (0=uninverted, 1=inverted)
;
; out:  r4 = 0

PV_LCDInvert ROUT
        MOV     r4, #0
        Pull    "pc"
 ]

@


1.1
log
@file vdupalxx was initially added on branch HAL.
@
text
@d1 1336
@


1.1.2.1
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@a0 1060
; Copyright 2000 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; vdupalxx

; mjs Sep 2000
;
; Palette programming for generic video controller, delegating h/w
; specifics to HAL calls. Think of any 'VIDC' references here as for a
; generic video controller.

; Format of a 32-bit palette entry in soft palette tables (eg. FirPalAddr) and
; for calls to HAL is:
;
;    BBGGRRSS
;
; ie. 8-8-8-8 bits for Blue-Green-Red-Supremacy
; 'Supremacy' is expected to be 0=solid .. 255=transparent
; [pre-HAL, Medusa kernels used a soft palette format of 0SBBGGRR, being VIDC20-ish]
;
; soft palette tables are indexed by 0..259, where:
;
;   0..255    are normal (display) palette entries
;             type 0, index 0..255 for HAL calls
;   256       is border entry
;             type 1, index 0 for HAL calls
;   257..259  are pointer palette entries
;             type 2, index 1..3 for HAL calls (HAL index 0 assumed to
;             correspond to transparent, and not used)


; *****************************************************************************

; PaletteV handler
; ----------------

; *****************************************************************************
;
;       MOSPaletteV - Default owner of PaletteV
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6
        ASSERT  paletteV_BulkRead = 7
        ASSERT  paletteV_BulkWrite = 8
        ASSERT  paletteV_GammaCorrection = 9
 [ LCDInvert
        ASSERT  paletteV_LCDInvert = 10
 ]
 [ StorkPowerSave
        ASSERT  paletteV_VIDCDisable = 12
        ASSERT  paletteV_VIDCRestore = 13
 ]

MOSPaletteV ROUT
        CMP     r4, #1
        MOVCC   pc, lr
        BEQ     PV_ReadPalette
        CMP     r4, #3
        BCC     PV_SetPalette
        BEQ     PV_1stFlashState
        CMP     r4, #5
        BCC     PV_2ndFlashState
        BEQ     PV_SetDefaultPalette
        CMP     r4, #7
        BCC     PV_BlankScreen
        BEQ     PV_BulkRead
        CMP     r4, #9
        BCC     PV_BulkWrite
        BEQ     PV_GammaCorrect
 [ LCDInvert
        CMP     r4, #11
        BCC     PV_LCDInvert
 ]
 [ StorkPowerSave
        MOVEQ   pc, lr
        CMP     r4, #13
        BCC     PV_VIDCDisable
        BEQ     PV_VIDCRestore
        MOVEQ   pc, lr
 ]
        MOV     pc, lr                  ; reason code not known, so pass it on

; *****************************************************************************

PV_SetDefaultPalette ROUT
        Push    "r0-r3,r5-r9"
        LDR     r0, [WsPtr, #PalIndex]  ; the new index 0-7
        ADR     r1, paldptab
        LDR     r2, [r1, r0, LSL #2]    ; offset from r1 to start of table
        ADD     r0, r0, #1              ; point to next item
        LDR     r5, [r1, r0, LSL #2]    ; offset from r1 to end of table +1
        ADDS    r2, r2, r1              ; r2 -> start of table
        BICMI   pc, r2, #&80000000      ; if negative then it's a routine
        ADD     r5, r5, r1              ; r5 -> end of table
        BIC     r5, r5, #&80000000
        MOV     r0, #0                  ; start at palette index 0
        MOV     r1, #3                  ; set both halves
10
        LDR     r6, [r2], #4
        MOVS    r3, r6, LSL #17         ; get 1st half word and set carry if flashing
        MOV     r3, r3, LSR #17
        MOVCC   r4, #0
        LDRCS   r4, =&FFF               ; flashing so invert 2nd half RGB
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        MOVS    r3, r6, LSL #1          ; get 2nd half word and set carry if flashing
        MOV     r3, r3, LSR #17
        MOVCC   r4, #0
        LDRCS   r4, =&FFF
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        TEQ     r2, r5
        BNE     %BT10

; now ensure all palette entries from 0..255 are initialised

        MOV     r3, #0                  ; set unused (and border) to black
        MOV     r4, #0                  ; no flashing
20
        CMP     r0, #256
        BHS     FinishDefault
        BL      UpdateSettingStraightRGB
        ADD     r0, r0, #1
        B       %BT20

FinishDefault
        MOV     r2, #0                  ; set border to black (and setup colours 2,3 in BBC gap modes)
        BL      BorderInitEntry

        MOV     r4, #0                  ; indicate PaletteV operation complete
        Pull    "r0-r3,r5-r9,pc"        ; restore registers and claim vector

        LTORG

; *****************************************************************************

; Table of offsets from paldata_pointer to palette data

paldptab
        &       paldat1-paldptab        ; 2  Colour Modes
        &       paldat2-paldptab        ; 4
        &       paldat4-paldptab        ; 16
        &       (paldat8-paldptab) :OR: &80000000  ; 256 (VIDC10 compatible) - use routine
        &       paldatT-paldptab        ; teletext mode
        &       paldatHR-paldptab       ; Hi-res mono mode
        &       (paldat16-paldptab) :OR: &80000000 ; 16 bpp - use routine
        &       (paldat32-paldptab) :OR: &80000000 ; 32 bpp (or 256 greys - they're identical!) - use routine
        &       paldatend-paldptab      ; end of table marker

paldat1 ; Data for 1 bit modes - only necessary to program registers 0 and 1

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &0FFF           ; 1  White

paldat2 ; Data for 2 bit modes - only necessary to program registers 0..3

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &000F           ; 1  Red
        DCW     &00FF           ; 2  Yellow
        DCW     &0FFF           ; 3  White

paldat4 ; Data for 4 bit modes - program all registers
        ; Flashing Colours will be needed here

;               FSBGR

        DCW     &0000           ; 0  Black
        DCW     &000F           ; 1  Red
        DCW     &00F0           ; 2  Green
        DCW     &00FF           ; 3  Yellow
        DCW     &0F00           ; 4  Blue
        DCW     &0F0F           ; 5  Magenta
        DCW     &0FF0           ; 6  Cyan
        DCW     &0FFF           ; 7  White
        DCW     &8000           ; 8  Flashing Black
        DCW     &800F           ; 9  Flashing Red
        DCW     &80F0           ; 10 Flashing Green
        DCW     &80FF           ; 11 Flashing Yellow
        DCW     &8F00           ; 12 Flashing Blue
        DCW     &8F0F           ; 13 Flashing Magenta
        DCW     &8FF0           ; 14 Flashing Cyan
        DCW     &8FFF           ; 15 Flashing White

; Routine to initialise palette for VIDC10-compatible 8bpp modes
; Note this must still be in between paldat4 and paldatT

paldat8 ROUT
        MOV     r1, #3                  ; set both halves of palette
        MOV     r0, #0                  ; starting index
10
        AND     r2, r0, #3              ; get tint bits
        ORR     r2, r2, r2, LSL #4      ; and duplicate into bits 8,9,12,13,16,17,20,21,24,25,28,29
        ORR     r2, r2, r2, LSL #8
        ORR     r2, r2, r2, LSL #16
        BIC     r2, r2, #&FF
        TST     r0, #4
        ORRNE   r2, r2, #&00004400
        TST     r0, #8
        ORRNE   r2, r2, #&44000000
        TST     r0, #&10
        ORRNE   r2, r2, #&00008800
        TST     r0, #&20
        ORRNE   r2, r2, #&00440000
        TST     r0, #&40
        ORRNE   r2, r2, #&00880000
        TST     r0, #&80
        ORRNE   r2, r2, #&88000000
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #1
        TEQ     r0, #&100
        BNE     %BT10
        B       FinishDefault

paldatT ; Data for teletext mode

        DCW     &0000           ; 0 Black
        DCW     &000F           ; 1 Red
        DCW     &00F0           ; 2 Green
        DCW     &00FF           ; 3 Yellow
        DCW     &0F00           ; 4 Blue
        DCW     &0F0F           ; 5 Magenta
        DCW     &0FF0           ; 6 Cyan
        DCW     &0FFF           ; 7 White

; Colours 8 to 15 have supremacy bit set

        DCW     &1000           ; 8 Supremacy+ Black
        DCW     &100F           ; 9            Red
        DCW     &10F0           ; 10           Green
        DCW     &10FF           ; 11           Yellow
        DCW     &1F00           ; 12           Blue
        DCW     &1F0F           ; 13           Magenta
        DCW     &1FF0           ; 14           Cyan
        DCW     &1FFF           ; 15           White

paldatHR  ; data for Hi-res mono mode
        DCW     &0000           ; Only red gun necessary
        DCW     &0111           ; but setting all three makes
        DCW     &0222           ; reading it more natural
        DCW     &0333
        DCW     &0444
        DCW     &0555
        DCW     &0666
        DCW     &0777
        DCW     &0888
        DCW     &0999
        DCW     &0AAA
        DCW     &0BBB
        DCW     &0CCC
        DCW     &0DDD
        DCW     &0EEE
        DCW     &0FFF

        DCW     &0000           ; border black
        DCW     &0010           ; fixed pointer colours
        DCW     &0020
        DCW     &0030

paldat16 ROUT
        ADR     r5, paldat16tab
palmetatab
        MOV     r1, #3                  ; set both halves of palette
        MOV     r0, #0                  ; starting index
10
        MOV     r8, r5
        MOV     r2, #0
        MOV     r6, r0
20
        LDR     r7, [r8], #4
        MOVS    r6, r6, LSR #1
        ORRCS   r2, r2, r7
        BNE     %BT20
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #1
        TEQ     r0, #&100
        BNE     %BT10
        B       FinishDefault

paldat16tab
        &       &00000800       ; palette bit 0
        &       &00081000       ;             1
        &       &08102100       ;             2
        &       &10214200       ;             3
        &       &21428400       ;             4
        &       &42840000       ;             5
        &       &84000000       ;             6
        &       &00000000       ;             7

paldat32 ROUT
        ADR     r5, paldat32tab
        B       palmetatab

paldat32tab
        &       &01010100       ; palette bit 0
        &       &02020200       ;             1
        &       &04040400       ;             2
        &       &08080800       ;             3
        &       &10101000       ;             4
        &       &20202000       ;             5
        &       &40404000       ;             6
        &       &80808000       ;             7

paldatend

; *****************************************************************************

; PaletteV call to set palette in bulk
; in:   R0 => list of colours, or 0
;       R1 =  colour type (16,17,18,24,25) in b24-31 & number to do in b23-b00
;       R2 => list of palette entries (both flash states if 16, one if 17/18)
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on

PV_BulkWrite    ROUT
        Push    "R0-R3,R5-R11"          ; pc already stacked

        ;register usage:
        ;[R6] colour list
        ;R7   colour type
        ;R8   max number
        ;[R9] palette entries
        ;R10  loop counter
        ;R11  colour number

        MOV     R7,R1,LSR #24
        BIC     R8,R1,#&FF000000
        MOV     R6,R0
        MOV     R9,R2

        MOV     R10,#0
10
        TEQ     R6,#0
        MOVEQ   R11,R10
        LDRNE   R11,[R6],#4

        TEQ     R7,#16
        TEQNE   R7,#17

        MOVEQ   R0,R11
        MOVEQ   R1,#1
        LDREQ   R2,[R9],#4
        BLEQ    UpdateNormalColour

        TEQ     R7,#16
        TEQNE   R7,#18

        MOVEQ   R0,R11
        MOVEQ   R1,#2
        LDREQ   R2,[R9],#4
        BLEQ    UpdateNormalColour

        TEQ     R7,#24

        MOVEQ   R0,R11
        LDREQ   R2,[R9],#4
        BLEQ    BorderColour

        TEQ     R7,#25

        MOVEQ   R0,R11
        LDREQ   R2,[R9],#4
        BLEQ    PointerColour

        ADD     R10,R10,#1
        CMP     R10,R8
        BCC     %BT10

        MOV     R4,#0
        Pull    "R0-R3,R5-R11,PC"

; *****************************************************************************

; PaletteV call to set palette
; in:   R0 = logical colour
;       R1 = colour type (16,17,18,24,25)
;       R2 = BBGGRRSS
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on
;

;amg 19/4/93 - change this routine to make all the calls subroutines rather
; than branches. Although it will slow this down a bit, it makes the bulk
; write a lot simpler and involves less duplication of mungeing code.

PV_SetPalette ROUT
        Push    "r0-r3"
        TEQ     r1, #16                 ; if 16 then set both colours
        MOVEQ   r1, #3
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #17                 ; elif 17 then set 1st colour
        MOVEQ   r1, #1
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #18                 ; elif 18 then set 2nd colour
        MOVEQ   r1, #2
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #24                 ; elif 24 then border colour
        BEQ     Call_BorderColour

        TEQ     r1, #25                 ; elif 25 then pointer colour
        BEQ     Call_PointerColour
10
        Pull    "r0-r3"
        MOV     pc, lr                  ; else not defined

Call_UpdateNormalColour
        BL      UpdateNormalColour
        Pull    "r0-r3,pc"

BorderInitEntry Push "r0-r3,lr"           ; entry used in default palette setting
Call_BorderColour
        BL      BorderColour
        Pull    "r0-r3,pc"

Call_PointerColour
        BL      PointerColour
        Pull    "r0-r3,pc"

; *****************************************************************************

UpdateNormalColour ROUT
        Push    "LR"
        LDR     lr, [WsPtr, #DisplayNColour] ; get the mask
        TEQ     lr, #63                 ; is it brain-damaged VIDC10-compatible 256 colour mode?
        BEQ     %FT10
        AND     r0, r0, lr              ; and mask it off
        AND     r0, r0, #255            ; definitely no more than 256 palette entries
        BL      UpdateSettingAndVIDC
05
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "pc"

10
        AND     r0, r0, #15             ; starting palette entry
20
        LDR     r3, =&88CC8800          ; r3 = bits controlled by bits 4..7 of pixel value
        BIC     r2, r2, r3
        TST     r0, #&10                ; test bit 4 (r3,7)
        ORRNE   r2, r2, #&00008800
        TST     r0, #&20                ; test bit 5 (g2,6)
        ORRNE   r2, r2, #&00440000
        TST     r0, #&40                ; test bit 6 (g3,7)
        ORRNE   r2, r2, #&00880000
        TST     r0, #&80                ; test bit 7 (b3,7)
        ORRNE   r2, r2, #&88000000
        BL      UpdateSettingAndVIDC
        ADD     r0, r0, #&10
        CMP     r0, #&100
        BCC     %BT20
        B       %BT05

BorderColour ROUT
        Push    "LR"
        MOV     r0, #256                ; pseudo-palette-index for border colour
        MOV     r1, #3                  ; both colours
        BL      UpdateSettingAndVIDC

; Now test for BBC gap mode (ie 3 or 6)
; if so then set colour 2 to same as border, and colour 3 to inverse

        LDR     lr, [WsPtr, #DisplayModeFlags]
        TST     lr, #Flag_BBCGapMode
        BEQ     %FT10

        MOV     r0, #2                  ; make colour 2 (gap) same as border
        BL      UpdateSettingAndVIDC

        MOV     r0, #3                  ; make colour 3 inverse gap
        MVN     r2, r2                  ; invert R, G and B
        EOR     r2, r2, #&FF            ; but use same supremacy
        BL      UpdateSettingAndVIDC
10
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "pc"


PointerColour ROUT
        Push    "LR"
        ANDS    r0, r0, #3              ; force pointer colour number in range 1..3
        BEQ     %FT10                   ; zero is invalid
        ADD     r0, r0, #256            ; index in range 257..259
        MOV     r1, #3
        BL      UpdateSettingAndVIDC
10
        MOV     r4, #0                  ; indicate successful PaletteV op
        Pull    "pc"

; UpdateSettingStraightRGB
;
; in:   r0 = index (0..255 for normal, 256 for border, 257..259 for pointer)
;       r1 = bit mask of which flash states to update (bit 0 set => 1st, bit 1 set => 2nd)
;       r3 = SBGR
;       r4 = SBGR to EOR with to go from 1st to 2nd flash state

; out:  r0,r1,r2,r4 preserved
;       r3 corrupted

UpdateSettingStraightRGB EntryS "r2,r5,r6,r7"

        ANDS    r5, r3, #1 :SHL: 12     ; get supremacy bit (s) in 1st colour
        MOVNE   r5, #&FF                ; r5 = 000000SS
        AND     r6, r3, #&FF0           ; r6 = 00000BG0
        ORR     r5, r5, r6, LSL #16     ; r5 = 0BG000SS
        AND     r6, r3, #&0FF           ; r6 = 000000GR
        ORR     r5, r5, r6, LSL #12     ; r5 = 0BGGR0SS
        AND     r6, r3, #&00F           ; r6 = 0000000R
        ORR     r5, r5, r6, LSL #8      ; r5 = 0BGGRRSS
        AND     r6, r3, #&F00           ; r6 = 00000B00
        ORR     r3, r5, r6, LSL #20     ; r3 = BBGGRRSS

        ANDS    r5, r4, #1 :SHL: 12     ; get supremacy bit (s) in EOR mask
        MOVNE   r5, #&FF                ; r5 = 000000SS
        AND     r6, r4, #&FF0           ; r6 = 00000BG0
        ORR     r5, r5, r6, LSL #16     ; r5 = 0BG000SS
        AND     r6, r4, #&0FF           ; r6 = 000000GR
        ORR     r5, r5, r6, LSL #12     ; r5 = 0BGGR0SS
        AND     r6, r4, #&00F           ; r6 = 0000000R
        ORR     r5, r5, r6, LSL #8      ; r5 = 0BGGRRSS
        AND     r6, r4, #&F00           ; r6 = 00000B00
        ORR     r4, r5, r6, LSL #20     ; r4 = BBGGRRSS

        B       UpdateSettingCommon


; UpdateSettingAndVIDC
;
; in:   r0 = index (0..255 for normal, 256 for border, 257..259 for pointer)
;       r1 = bit mask of which flash states to update (bit 0 set => 1st, bit 1 set => 2nd)
;       r2 = BBGGRRSS
;
; out:  r0, r1, r2 preserved
;       r3, r4 corrupted
;

UpdateSettingAndVIDC ALTENTRY

        MOV     r3, r2
        MOV     r4, #0                  ; indicate no EORing between parts

; ... and drop thru to

; UpdateSettingCommon
;
; in:   r0 = index (0..255 for normal, 256 for border, 257..259 for pointer)
;       r1 = bit mask of which flash states to update (bit 0 set => 1st, bit 1 set => 2nd)
;       r3 = BBGGRRSS
;       r4 = BBGGRRSS to EOR with to go from 1st to 2nd flash state
;       r2, r5, r6, r7, lr stacked
;
; out:  r0, r1, r2, r4 preserved
;       r3 corrupted
;
UpdateSettingCommon ROUT
        PHPSEI                          ; protect against IRQs

        Push    "r8, r9"

        LDRB    r5, [WsPtr, #ScreenBlankFlag]
        TEQ     r5, #0
        MOVNE   r5, #&FFFFFFFF          ; bits to knock out if blanked

        LDROSB  r2, FlashState          ; 0 => second, 1 => first
        CMP     r2, #1                  ; C=0 => second, C=1 => first

        TST     r1, #1
        BEQ     %FT10                   ; skip if not setting 1st colour
        LDR     r2, [WsPtr, #FirPalAddr]
        ADD     r8, r2, #(256+1+3)*4*4  ; r8 -> rgb transfer tables
        STR     r3, [r2, r0, LSL #2]!   ; store in logical colour and write back pointer
        AND     r6, r3, #&0000FF00      ; r6 = red << 8
        LDRB    r6, [r8, r6, LSR #8]    ; r6 = gamma(red)
        ADD     r8, r8, #&100           ; r8 -> green transfer
        AND     r9, r3, #&00FF0000      ; r9 = green << 16
        LDRB    r9, [r8, r9, LSR #16]   ; r9 = gamma(green)
        ORR     r6, r6, r9, LSL #8      ; r6 = gamma(red) + (gamma(green)<<8)
        ADD     r8, r8, #&100           ; r8 -> blue transfer
        AND     r9, r3, #&FF000000      ; r9 = blue << 24
        LDRB    r9, [r8, r9, LSR #24]   ; r9 = gamma(blue)
        ORR     r6, r6, r9, LSL #16     ; r6 = gamma(red) + (gamma(green)<<8) + (gamma(blue)<<16)
        AND     r9, r3, #&000000FF      ; knock out rgb from original
        ORR     r6, r9, r6, LSL #8      ; and or in new bits
        STR     r6, [r2, #(256+1+3)*4*2] ; store in physical copy

        BCC     %FT10                   ; only hit hardware if flash state = first

;;;mjsHAL
;;; old code had possible LCD greyscale munging, not supported in interim s.vduhint code
;;;
        Push    "r0-r3, r12, lr"
        BIC     r1, r6, r5                ; r1 = palette colour after knocking out blanking bits
        AND     r2, r0, #255              ; reduced index (0..255 normal, 0 border, 1..3 pointer)   
        CMP     r0, #256                  ; HI if pointer
        MOVLS   r0, r0, LSR #8            ; type 0=normal, 1=border
        MOVHI   r0, #2                    ; type 2=pointer
        mjsAddressHAL
        mjsCallHAL    HAL_Video_WritePaletteEntry
        Pull    "r0-r3, r12, lr"

10
        EOR     r3, r3, r4              ; toggle requested bits for 2nd half
        TST     r1, #2
        BEQ     %FT20                   ; skip if not setting 2nd colour
        LDR     r2, [WsPtr, #SecPalAddr]
        ADD     r8, r2, #(256+1+3)*4*3  ; r8 -> rgb transfer tables
        STR     r3, [r2, r0, LSL #2]!   ; store in logical copy and write back

        AND     r6, r3, #&0000FF00      ; r6 = red << 8
        LDRB    r6, [r8, r6, LSR #8]    ; r6 = gamma(red)
        ADD     r8, r8, #&100           ; r8 -> green transfer
        AND     r9, r3, #&00FF0000      ; r9 = green << 16
        LDRB    r9, [r8, r9, LSR #16]   ; r9 = gamma(green)
        ORR     r6, r6, r9, LSL #8      ; r6 = gamma(red) + (gamma(green)<<8)
        ADD     r8, r8, #&100           ; r8 -> blue transfer
        AND     r9, r3, #&FF000000      ; r9 = blue << 24
        LDRB    r9, [r8, r9, LSR #24]   ; r9 = gamma(blue)
        ORR     r6, r6, r9, LSL #16     ; r6 = gamma(red) + (gamma(green)<<8) + (gamma(blue)<<16)
        AND     r9, r3, #&000000FF      ; knock out rgb from original
        ORR     r6, r9, r6, LSL #8      ; and or in new bits
        STR     r6, [r2, #(256+1+3)*4*2] ; store in physical copy

        BCS     %FT20                   ; only hit hardware if flash state = second

;;;mjsHAL
;;; old code had possible LCD greyscale munging, not supported in interim s.vduhint code
;;;
        Push    "r0-r3, r12, lr"
        BIC     r1, r6, r5                ; r1 = palette colour after knocking out blanking bits
        AND     r2, r0, #255              ; reduced index (0..255 normal, 0 border, 1..3 pointer)   
        CMP     r0, #256                  ; HI if pointer
        MOVLS   r0, r0, LSR #8            ; type 0=normal, 1=border
        MOVHI   r0, #2                    ; type 2=pointer
        mjsAddressHAL
        mjsCallHAL    HAL_Video_WritePaletteEntry
        Pull    "r0-r3, r12, lr"

20
        PLP
        Pull    "r8, r9"
        EXITS                           ; restore registers, claim vector

; *****************************************************************************
;
; PV_BulkRead - Read multiple palette entries with one call
;
; in:   R0 => list of colours wanted, or 0 to start with first and increment
;       R1 =  b24-b31 - colour type: 16/17/18/24/25
;             b00-b23 - number of colours to do
;
;       R2 => memory for first flash state colours (and second if R3=0)
;       R3 => memory for second flash state colours (if 0, intermingle with R2 instead)
;
; out:  all preserved (R4 set to 0 to show call handled)

; flags used to control routine

PV_BR_WantFirst *       1               ; doing 16 or 17
PV_BR_WantSecond *      2               ; doing 16 or 18
PV_BR_HaveList *        4               ; we have a list of colours
PV_BR_TwoLists *        8               ; we have two output areas (R2 & R3 valid)
PV_BR_Border   *        16              ; doing 24
PV_BR_Mouse    *        32              ; doing 25

PV_BulkRead ROUT
        Push    "R0-R3,R6-R11"             ; return addr already stacked

        MOV     R6,R1,LSR #24           ; isolate the colour type

        MOV     R7,#(PV_BR_WantFirst + PV_BR_WantSecond)

        CMP     R6,#17                  ; do we want both flash states ?
        BICEQ   R7,R7,#PV_BR_WantSecond ; if 17 only want first flash state

        CMP     R6,#18
        BICEQ   R7,R7,#PV_BR_WantFirst  ; if 18 only want second flash state

        CMP     R6,#24
        ORREQ   R7,R7,#PV_BR_Border
        ORRGT   R7,R7,#PV_BR_Mouse

        ;now set up other control flags
        CMP     R0,#0
        ORRNE   R7,R7,#PV_BR_HaveList   ; we have a list of colours

        CMP     R3,#0
        ORRNE   R7,R7,#PV_BR_TwoLists   ; we have two output areas

        ;set up a mask for the number of colours
        LDR     R8,[WsPtr,#DisplayNColour]
        TEQ     R8,#63
        MOVEQ   R8,#255                 ; deal with braindamaged 8BPP case

        ;the mouse has colours 1-3
        TST     R7,#PV_BR_Mouse
        MOVNE   R8,#3

        ;take the colour type off the top of R1, leaving #colours wanted
        BIC     R1,R1,#&FF000000

        ; register usage:
        ; [R0]: colour list
        ; R1: number of colours
        ; [R2]: first flash state list
        ; [R3]: second flash state list
        ; R7: control flags
        ; R8: mask for colour number
        ; R9: loop counter
        ; R10: misc
        ; LR: misc

        MOV     R9,#0
30
        TST     R7,#PV_BR_HaveList
        LDRNE   LR,[R0],#4
        MOVEQ   LR,R9                   ; LR = wanted colour number

        AND     LR,LR,R8                ; ensure it is sensible

        TST     R7,#PV_BR_Border
        MOVNE   LR,#256                 ; border is stored as colour 256

        TST     R7,#PV_BR_Mouse
        BEQ     %FT40

        TEQ     LR,#0
        BEQ     %FT50                   ;colour 0 is invalid
        ADD     LR,LR,#256              ;bring into range (257-259)

40
        TST     R7,#PV_BR_WantFirst

        LDRNE   R10,[WsPtr,#FirPalAddr]

        LDRNE   R11,[R10,LR,LSL#2]      ; BBGGRRSS
        STRNE   R11,[R2],#4

        TST     R7,#PV_BR_WantSecond
        BEQ     %FT60                   ; have to use a branch here - another TST coming up

        LDR     R10,[WsPtr,#SecPalAddr]

        LDR     R11,[R10,LR,LSL#2]      ; BBGGRRSS

        TST     R7,#PV_BR_TwoLists

        STREQ   R11,[R2],#4
        STRNE   R11,[R3],#4

60      ADD     R9,R9,#1
        CMP     R9,R1
        BCC     %BT30
50
        MOV     R4,#0
        Pull    "R0-R3,R6-R11,PC"          ; return addr already stacked


; *****************************************************************************
;
;       PV_ReadPalette - PaletteV read palette handler
;
; in:   R0 = logical colour
;       R1 = 16 (read normal colour)
;            24 (read border colour)
;            25 (read cursor colour)
;
; out:  R2 = first flash setting   (BBGGRRSS)
;       R3 = second flash setting  (BBGGRRSS)
;

PV_ReadPalette ROUT
        Push    "r10,r11"
        LDR     r10, [WsPtr, #DisplayNColour] ; logical colours in this mode -1
        TEQ     r10, #63                ; if bodgy 256 colour mode
        MOVEQ   r10, #255               ; then use AND mask of 255

        TEQ     r1, #24                 ; is it reading border palette
        MOVEQ   r11, #&100              ; then set up border index
        BEQ     %FT10                   ; and go

        TEQ     r1, #25                 ; is it reading pointer palette
        BEQ     %FT05
        AND     r11, r0, r10            ; no, then force into suitable range
        B       %FT10                   ; always skip
05
        ANDS    r11, r0, #3             ; else force logical colour 0..3
        BEQ     %FT99                   ; and 0 is illegal, so do nothing
        ADD     r11, r11, #&100         ; set up correct index
10

; note no need to fudge 256-colour modes, since we have the correct full 256 entry palette

        LDR     r10, [WsPtr, #FirPalAddr]
        LDR     r2, [r10, r11, LSL #2]  ; r2 := 1st BBGGRRSS
        LDR     r10, [WsPtr, #SecPalAddr]
        LDR     r3, [r10, r11, LSL #2]  ; r3 := 2nd BBGGRRSS
99
        MOV     r4, #0
        Pull    "r10, r11, pc"

; *****************************************************************************
;
;       PV_1stFlashState - PaletteV routine to set first flash state
;

PV_1stFlashState ROUT
        Push    "r0-r3, r9, r10, r12, lr"
        LDRB    r1, [WsPtr, #ScreenBlankFlag]
        TEQ     r1, #0
        LDREQ   r1, [WsPtr, #FirPalAddr]
        ADDEQ   r1, r1, #(256+1+3)*4*2     ; move pointer to physical palette copy
        LDRNE   r1, [WsPtr, #BlankPalAddr]
DoR0Flash
        MOV     r0, #0                  ; type 0 (normal)
        MOV     r2, #0                  ; start at entry 0
        MOV     r3, #256                ; 256 entries
        PHPSEI  r10                     ; disable IRQs round this bit
        mjsAddressHAL
        mjsCallHAL    HAL_Video_WritePaletteEntries
        PLP     r10
        MOV     r4, #0
        Pull    "r0-r3, r9, r10, r12, pc"

; *****************************************************************************
;
;       PV_2ndFlashState - PaletteV routine to set second flash state
;

PV_2ndFlashState ROUT
        Push    "r0-r3, r9, r10, r12, lr"
        LDRB    r1, [WsPtr, #ScreenBlankFlag]
        TEQ     r1, #0
        LDREQ   r1, [WsPtr, #SecPalAddr]
        ADDEQ   r1, r1, #(256+1+3)*4*2  ; move pointer to physical palette copy
        LDRNE   r1, [WsPtr, #BlankPalAddr]
        B       DoR0Flash

; *****************************************************************************
;
;       UpdateAllPalette - Update all VIDC palette entries
;

UpdateAllPalette ROUT
        Push    "r0-r3, r9, r10-r12, lr"
        mjsAddressHAL
;sort out which palette to use
        LDROSB  r0, FlashState
        CMP     r0, #1
        LDRCS   r1, [WsPtr, #FirPalAddr]   ; FlashState = 1 => 1st state, 0 => 2nd state
        LDRCC   r1, [WsPtr, #SecPalAddr]
        ADD     r1, r1, #(256+1+3)*4*2     ; move pointer to physical palette copy
        LDRB    r10, [WsPtr, #ScreenBlankFlag]
        TEQ     r10, #0
        LDRNE   r1, [WsPtr, #BlankPalAddr] ; blank palette after all
;
        ADD     r10, r1, #256*4            ; pointer to border colour
        PHPSEI  r11                        ; disable IRQs round this bit
;first, the normal colours
        MOV     r0, #0                  ; type 0 (normal)
        MOV     r2, #0                  ; start at entry 0
        MOV     r3, #256                ; 256 entries
        mjsCallHAL HAL_Video_WritePaletteEntries
;next, border colour
        LDR     r1, [r10]               ; border colour
        MOV     r0, #1                  ; type 1
        MOV     r2, #0                  ; index 0
        mjsCallHAL HAL_Video_WritePaletteEntry
;finally, pointer colours
        ADD     r1, r10, #4             ; pointer to pointer colours (oh yes)
        MOV     r0, #2                  ; type 2
        MOV     r2, #1                  ; start at index 1
        MOV     r3, #3                  ; 3 entries
        mjsCallHAL HAL_Video_WritePaletteEntries
;
        PLP     r11
        MOV     r4, #0
        Pull    "r0-r3, r9, r10-r12, pc"

; *****************************************************************************
;
;       PV_BlankScreen - Blank/unblank screen
;
; in:   R0 = -1 => read blank state
;       R0 = 0 => unblank screen
;       R0 = 1 => blank screen
;
; out:  R0 = old state (0=unblanked, 1=blanked)
;       R4 = 0

PV_BlankScreen ROUT
        Push    "r1-r3, r9"

        LDRB    r4, [WsPtr, #ScreenBlankFlag]
        CMP     r0, #1
        BHI     %FT99                   ; just reading
        TEQ     r0, r4                  ; changing to same state?
        BEQ     %FT99                   ; if so, do nothing

        AND     r0, r0, #1
        STRB    r0, [WsPtr, #ScreenBlankFlag]      ; update new state
        LDRB    r1, [WsPtr, #ScreenBlankDPMSState]

        Push    "r0, r12"
        mjsAddressHAL
        mjsCallHAL HAL_Video_SetBlank
        Pull    "r0, r12"

;;;mjsHAL still h/w dependency here for IOMD, needs sorting?
;;;
        TEQ     r0, #1
        MOVEQ   r0, #(0 :SHL: 10) :OR: (3 :SHL: 8) ; blank:   video DMA off, continuous refresh
        MOVNE   r0, #(1 :SHL: 10) :OR: (0 :SHL: 8) ; unblank: video DMA on, no refresh
        MOV     r1, #(1 :SHL: 10) :OR: (3 :SHL: 8) ; bits to modify
        SWI     XOS_UpdateMEMC

        BL      UpdateAllPalette        ; update all palette, including border + pointer

99
        MOV     r0, r4
        MOV     r4, #0
        Pull    "r1-r3, r9, pc"

; *****************************************************************************
;
;       PV_GammaCorrect - Update gamma correction tables
;
; in:   r0 -> red table
;       r1 -> green table
;       r2 -> blue table
;
; out:  r4 = 0

PV_GammaCorrect ROUT
        Push    "r0-r3,r5-r8"
        LDR     r4, [WsPtr, #FirPalAddr]
        ADD     r4, r4, #(256+1+3)*4*4          ; point to gamma tables
        ADD     r3, r4, #256
10
        LDR     lr, [r0], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT10

        ADD     r3, r4, #256
20
        LDR     lr, [r1], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT20

        ADD     r3, r4, #256
30
        LDR     lr, [r2], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT30

; now go through the logical palette, recomputing the physical from it using the new tables

        SUB     r0, r4, #3*256                  ; r0 -> red table
        SUB     r1, r4, #2*256                  ; r1 -> green table
        SUB     r2, r4, #1*256                  ; r2 -> blue table

        LDR     r4, [WsPtr, #FirPalAddr]        ; r4 -> start of logical palette
        ADD     r5, r4, #260*4*2                ; r5 -> start of physical palette
        MOV     r6, r5                          ; r6 = r5 = end of logical palette
40
        LDR     r7, [r4], #4                    ; get word
        AND     r8, r7, #&0000FF00              ; r8 = red << 8
        LDRB    r8, [r0, r8, LSR #8]            ; r8 = gamma(red)
        AND     lr, r7, #&00FF0000              ; lr = green << 16
        LDRB    lr, [r1, lr, LSR #16]           ; lr = gamma(green)
        ORR     r8, r8, lr, LSL #8              ; r8 = gamma(red) + (gamma(green)<<8)
        AND     lr, r7, #&FF000000              ; lr = blue << 24
        LDRB    lr, [r2, lr, LSR #24]           ; lr = gamma(blue)
        ORR     r8, r8, lr, LSL #16             ; r8 = gamma(red) + (gamma(green)<<8) + (gamma(blue)<<16)
        AND     lr, r7, #&000000FF              ; lr = 000000SS
        ORR     r8, lr, r8, LSL #8              ; r8 = gamma-corrected BBGGRRSS value
        STR     r8, [r5], #4                    ; store word
        TEQ     r4, r6
        BNE     %BT40

        BL      UpdateAllPalette

        MOV     r4, #0
        Pull    "r0-r3,r5-r8, pc"


 [ LCDInvert
; *****************************************************************************
;
;       PV_LCDInvert - Invert the LCD palette
;
; in:   r0 = inversion state to use (0=uninverted, 1=inverted)
;
; out:  r4 = 0

PV_LCDInvert ROUT
        MOV     r4, #0
        STRB    r0, [r4, #LCD_Inverted]

        BL      UpdateAllPalette
        MOV     r4, #0
        Pull    "pc"
 ]

 [ StorkPowerSave

; *****************************************************************************

PV_VIDCDisable  ROUT
        Push    "r0-r3, r9, r12"

        MOV     r0, #1
        mjsAddressHAL
        mjsCallHAL    HAL_Video_SetPowerSave

        MOV     r4, #0
        Pull    "r0-r3, r9, r12, pc"

; *****************************************************************************

PV_VIDCRestore  ROUT
        Push    "r0-r3, r9, r12"

        MOV     r0, #0
        mjsAddressHAL
        mjsCallHAL    HAL_Video_SetPowerSave

        MOV     r4, #0
        Pull    "r0-r3, r9, r12, pc"

 ]   ; StorkPowerSave

        END
@


1.1.2.2
log
@further kernel/HAL split work in video area
almost-HAL code for VIDC20/IOMD in vdu.vduhint, now almost divorced
from kernel workspace
tested briefly in Ursula desktop environment

Version 5.35, 4.79.2.4. Tagged as 'Kernel-5_35-4_79_2_4'
@
text
@d933 2
a934 8
        ; for backward compatibility, show video DMA state in
        ; MEMC soft copy (DON'T call OS_UpdateMEMC, which would also
        ; make redundant call to HAL)
        ;
        SavePSR r2
        MOV     r9, #0
        WritePSRc SVC_mode+I_bit+F_bit, r14
        LDR     r1, [r9, #MEMC_CR_SoftCopy]
d936 4
a939 4
        BICEQ   r1, r1, #(1 :SHL: 10)
        ORRNE   r1, r1, #(1 :SHL: 10)
        STR     r1, [r9, #MEMC_CR_SoftCopy]
        RestPSR r2
d1024 4
a1027 2
        ;;;mjsHAL not supported
        ;;;
@


1.1.2.3
log
@Wahey! This version gives you a display.

It says "Abort on data transfer".
@
text
@d109 2
a110 5
        TST     r2, #&80000000          ; if bit 31 set, it's a routine
        BIC     r2, r2, #&80000000      ; clear that flag
        ADD     r2, r2, r1              ; r2 -> start of table
        MOVNE   pc, r2                  ; or call routine
        BIC     r5, r5, #&80000000      ; clear routine flag
d112 1
d618 1
a618 1
        AND     r2, r0, #255              ; reduced index (0..255 normal, 0 border, 1..3 pointer)
d655 1
a655 1
        AND     r2, r0, #255              ; reduced index (0..255 normal, 0 border, 1..3 pointer)
@


1.1.2.4
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d72 15
a86 13
        CMP     r4, #13
        ADDLS   pc, pc, r4, LSL #2
        MOV     pc, lr                  ; reason code not known, so pass it on
        MOV     pc, lr                  ; 0
        B       PV_ReadPalette          ; 1
        B       PV_SetPalette           ; 2
        B       PV_1stFlashState        ; 3
        B       PV_2ndFlashState        ; 4
        B       PV_SetDefaultPalette    ; 5
        B       PV_BlankScreen          ; 6
        B       PV_BulkRead             ; 7
        B       PV_BulkWrite            ; 8
        B       PV_GammaCorrect         ; 9
d88 2
a89 3
        B       PV_LCDInvert            ; 10
 |
        MOV     pc, lr                  ; 10
a90 1
        MOV     pc, lr                  ; 11
d92 5
a96 5
        B       PV_VIDCDisable          ; 12
        B       PV_VIDCRestore          ; 13
 |
        MOV     pc, lr                  ; 12
        MOV     pc, lr                  ; 13
d98 1
a617 11
 [ UseGraphicsV
        Push    "r0-r2,r4,lr"
        MOV     r4, #GraphicsV_WritePaletteEntry
        BIC     r1, r6, r5                ; r1 = palette colour after knocking out blanking bits
        AND     r2, r0, #255              ; reduced index (0..255 normal, 0 border, 1..3 pointer)
        CMP     r0, #256                  ; HI if pointer
        MOVLS   r0, r0, LSR #8            ; type 0=normal, 1=border
        MOVHI   r0, #2                    ; type 2=pointer
        BL      CallGraphicsV
        Pull    "r0-r2,r4,lr"
 |
a626 1
 ]
a654 11
 [ UseGraphicsV
        Push    "r0-r2,r4,lr"
        MOV     r4, #GraphicsV_WritePaletteEntry
        BIC     r1, r6, r5                ; r1 = palette colour after knocking out blanking bits
        AND     r2, r0, #255              ; reduced index (0..255 normal, 0 border, 1..3 pointer)
        CMP     r0, #256                  ; HI if pointer
        MOVLS   r0, r0, LSR #8            ; type 0=normal, 1=border
        MOVHI   r0, #2                    ; type 2=pointer
        BL      CallGraphicsV
        Pull    "r0-r2,r4,lr"
 |
a663 1
 ]
d834 1
a834 5
 [ UseGraphicsV
        Entry   "r0-r3"
 |
        Entry   "r0-r3, r9, r10, r12"
 ]
a843 4
 [ UseGraphicsV
        MOV     r4, #GraphicsV_WritePaletteEntries
        BL      CallGraphicsV
 |
d849 1
a849 2
 ]
        EXIT
d857 1
a857 1
        ALTENTRY
d871 1
a871 4
 [ UseGraphicsV
        Entry   "r0-r3, r10-r11"
 |
        Entry   "r0-r3, r9, r10-r12"
a872 1
 ]
a884 21
 [ UseGraphicsV
;first, the normal colours
        MOV     r0, #0                  ; type 0 (normal)
        MOV     r2, #0                  ; start at entry 0
        MOV     r3, #256                ; 256 entries
        MOV     r4, #GraphicsV_WritePaletteEntries
        BL      CallGraphicsV
;next, border colour
        LDR     r1, [r10]               ; border colour
        MOV     r0, #1                  ; type 1
        MOV     r2, #0                  ; index 0
        MOV     r4, #GraphicsV_WritePaletteEntry
        BL      CallGraphicsV
;finally, pointer colours
        ADD     r1, r10, #4             ; pointer to pointer colours (oh yes)
        MOV     r0, #2                  ; type 2
        MOV     r2, #1                  ; start at index 1
        MOV     r3, #3                  ; 3 entries
        MOV     r4, #GraphicsV_WritePaletteEntries
        BL      CallGraphicsV
 |
a900 1
 ]
d904 1
a904 1
        EXIT
a929 4
 [ UseGraphicsV
        MOV     r4, #GraphicsV_SetBlank
        BL      CallGraphicsV
 |
a933 1
 ]
@


1.1.2.5
log
@* HAL can choose to limit amount of screen memory to allocate
  [Not fully implemented - for now leaves at least 16MB free if only
  one RAM area; was 1MB].
* Added HAL_USBControllerInfo, HAL_MonitorLeadID and HAL_Video_Render.
* Added HAL->OS call OS_IICOpV.
* OS_MMUControl now allows independent control of I and C bits.
* Added facility to deactivate keyboard debounce (magic word "NoKd" in
  R2 in KeyV 0).
* Fixed problem with RAM amounts not a multiple of 4MB.
* Supremacy bit (in VDU 19) now sets all 8 bits of supremacy.
* Added PaletteV 14 (reads gamma tables).
* Added Supremacy transfer functions (like gamma correction, but for
  supremacy). Allows easy global supremacy effects in a mode-independent
  fashion. Controlled with PaletteV 15,16.
* Added modes 50-53 (320x240, 1,2,4,8bpp). Intended for small LCD.
* Added 13.5kHz versions of TV modes (selected by Hdr:Machine).
* Upped desktop version to 5.06.

Version 5.35, 4.79.2.66. Tagged as 'Kernel-5_35-4_79_2_66'
@
text
@a69 3
        ASSERT  paletteV_ReadGammaCorrection = 14
        ASSERT  paletteV_ReadSupremacyTransfer = 15
        ASSERT  paletteV_SetSupremacyTransfer = 16
d72 1
a72 1
        CMP     r4, #16
a97 3
        B       PV_ReadGammaCorrect     ; 22
        B       PV_ReadSupremacyXfer    ; 23
        B       PV_SetSupremacyXfer     ; 24
a301 10
 [ DefaultSupremacy
        &       &00000800       ; palette bit 0
        &       &00081000       ;             1
        &       &08102100       ;             2
        &       &102142FF       ;             3
        &       &21428400       ;             4
        &       &42840000       ;             5
        &       &84000000       ;             6
        &       &00000000       ;             7
 |
a309 1
 ]
a315 10
 [ DefaultSupremacy
        &       &01010101       ; palette bit 0
        &       &02020202       ;             1
        &       &04040404       ;             2
        &       &08080808       ;             3
        &       &10101010       ;             4
        &       &20202020       ;             5
        &       &40404040       ;             6
        &       &80808080       ;             7
 |
a323 1
 ]
d596 1
a596 1
        ADD     r8, r2, #Pal_RTable-Pal_LogFirst ; r8 -> rgb transfer tables
d608 3
a610 5
        ADD     r8, r8, #&100           ; r8 -> supremacy transfer
        AND     r9, r3, #&000000FF      ; r9 = supremacy
        LDRB    r9, [r8, r9]            ; r9 = transfer(supremacy)
        ORR     r6, r9, r6, LSL #8      ; r6 = gamma(rgb) + transfer(supremacy)
        STR     r6, [r2, #Pal_PhysFirst-Pal_LogFirst] ; store in physical copy
d644 1
a644 1
        ADD     r8, r2, #Pal_RTable-Pal_LogSecond ; r8 -> rgb transfer tables
d657 3
a659 5
        ADD     r8, r8, #&100           ; r8 -> supremacy transfer
        AND     r9, r3, #&000000FF      ; r9 = supremacy
        LDRB    r9, [r8, r9]            ; r9 = transfer(supremacy)
        ORR     r6, r9, r6, LSL #8      ; r6 = gamma(rgb) + transfer(supremacy)
        STR     r6, [r2, #Pal_PhysSecond-Pal_LogSecond] ; store in physical copy
d865 1
a865 1
        ADDEQ   r1, r1, #Pal_PhysFirst - Pal_LogFirst ; move pointer to physical palette copy
d893 1
a893 1
        ADDEQ   r1, r1, #Pal_PhysFirst-Pal_LogFirst ; move pointer to physical palette copy
d914 1
a914 1
        ADD     r1, r1, #Pal_PhysFirst-Pal_LogFirst ; move pointer to physical palette copy
a1020 40
;       PV_ReadGammaCorrect - Read gamma correction tables
;
; in:   r0 -> red table
;       r1 -> green table
;       r2 -> blue table
;
; out:  r4 = 0

PV_ReadGammaCorrect ROUT
        Push    "r0-r3"
        LDR     r4, [WsPtr, #FirPalAddr]
        ADD     r4, r4, #Pal_RTable-Pal_LogFirst; point to gamma tables
        ADD     r3, r4, #256
10
        LDR     lr, [r4], #4
        STR     lr, [r0], #4
        TEQ     r4, r3
        BNE     %BT10

        ASSERT  Pal_GTable = Pal_RTable+256
        ADD     r3, r4, #256
20
        LDR     lr, [r4], #4
        STR     lr, [r1], #4
        TEQ     r4, r3
        BNE     %BT20

        ASSERT  Pal_BTable = Pal_GTable+256
        ADD     r3, r4, #256
30
        LDR     lr, [r4], #4
        STR     lr, [r2], #4
        TEQ     r4, r3
        BNE     %BT30

        MOV     r4, #0
        Pull    "r0-r3, pc"

; *****************************************************************************
;
d1030 1
a1030 1
        Push    "r0-r3"
d1032 1
a1032 1
        ADD     r4, r4, #Pal_RTable-Pal_LogFirst; point to gamma tables
a1039 1
        ASSERT  Pal_GTable = Pal_RTable+256
a1046 1
        ASSERT  Pal_BTable = Pal_GTable+256
d1054 1
a1054 5
        BL      RecomputeLogicalPalette

        MOV     r4, #0
        Pull    "r0-r3, pc"

d1056 3
a1058 6
; go through the logical palette, recomputing the physical from it using the new tables
;
; out:  r0-r4 corrupted

RecomputeLogicalPalette ROUT
        Push    "r5-r8, lr"
d1061 1
a1061 1
        ADD     r5, r4, #Pal_PhysFirst-Pal_LogFirst ; r5 -> start of physical palette
a1062 4
        ADD     r0, r4, #Pal_RTable-Pal_LogFirst; r0 -> red table
        ADD     r1, r4, #Pal_GTable-Pal_LogFirst; r1 -> green table
        ADD     r2, r4, #Pal_BTable-Pal_LogFirst; r2 -> blue table
        ADD     r3, r4, #Pal_STable-Pal_LogFirst; r3 -> supremacy table
d1073 1
a1073 2
        AND     lr, r7, #&000000FF              ; lr = supremacy
        LDRB    lr, [r3, lr]                    ; lr = transfer(supremacy)
a1080 45
        Pull    "r5-r8, pc"

; *****************************************************************************
;
;       PV_ReadSupremacyXfer - Read supremacy transfer table
;
; in:   r0 -> supremacy table
;
; out:  r4 = 0

PV_ReadSupremacyXfer ROUT
        Push    "r0,r3"
        LDR     r4, [WsPtr, #FirPalAddr]
        ADD     r4, r4, #Pal_STable-Pal_LogFirst; point to supremacy table
        ADD     r3, r4, #256
10
        LDR     lr, [r4], #4
        STR     lr, [r0], #4
        TEQ     r4, r3
        BNE     %BT10

        MOV     r4, #0
        Pull    "r0,r3, pc"

; *****************************************************************************
;
;       PV_SetSupremacyXfer - Read supremacy transfer table
;
; in:   r0 -> supremacy table
;
; out:  r4 = 0

PV_SetSupremacyXfer ROUT
        Push    "r0-r3"
        LDR     r4, [WsPtr, #FirPalAddr]
        ADD     r4, r4, #Pal_STable-Pal_LogFirst; point to supremacy table
        ADD     r3, r4, #256
10
        LDR     lr, [r0], #4
        STR     lr, [r4], #4
        TEQ     r4, r3
        BNE     %BT10

        BL      RecomputeLogicalPalette

d1082 1
a1082 1
        Pull    "r0-r3, pc"
@


1.1.2.6
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d1035 1
a1035 1
        LDR     r9, =ZeroPage
@


1.1.2.6.2.1
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d88 1
a88 1
 [ LCDInvert :LAND: :LNOT: HAL
d644 2
a645 2
;;; mjs
;;; Pre HAL code had possible LCD greyscale munging, not supported in interim s.vduhint code
d664 2
a665 2
        AddressHAL
        CallHAL HAL_VideoWritePaletteEntry
d695 2
a696 2
;;; mjs
;;; Pre HAL code had possible LCD greyscale munging, not supported in interim s.vduhint code
d715 2
a716 2
        AddressHAL
        CallHAL HAL_VideoWritePaletteEntry
d908 2
a909 2
        AddressHAL
        CallHAL HAL_VideoWritePaletteEntries
d939 1
a939 1
        AddressHAL
d978 1
a978 1
        CallHAL HAL_VideoWritePaletteEntries
d983 1
a983 1
        CallHAL HAL_VideoWritePaletteEntry
d989 1
a989 1
        CallHAL HAL_VideoWritePaletteEntries
d1025 2
a1026 2
        AddressHAL
        CallHAL HAL_VideoSetBlank
d1216 1
a1216 1
 [ LCDInvert :LAND: :LNOT: HAL
d1226 2
d1240 2
a1241 2
        AddressHAL
        CallHAL HAL_VideoSetPowerSave
d1252 2
a1253 2
        AddressHAL
        CallHAL HAL_VideoSetPowerSave
@


1.1.2.7
log
@Make Mike's macros permanent.
While the HAL and kernel were being split some temporary macros were used for the bits being worked on, after 12 years of use they're probably safe to adopt.
mjsCallHAL -> CallHAL; mjsAddressHAL -> AddressHAL; mjsHAL -> HAL.
OS_VIDCDividerSWI code now always does NoSuchSWI (had been switched out previously).
File vduhint.s no longer assembled (was empty).


Version 5.35, 4.79.2.150. Tagged as 'Kernel-5_35-4_79_2_150'
@
text
@d88 1
a88 1
 [ LCDInvert :LAND: :LNOT: HAL
d644 2
a645 2
;;; mjs
;;; Pre HAL code had possible LCD greyscale munging, not supported in interim s.vduhint code
d664 2
a665 2
        AddressHAL
        CallHAL HAL_Video_WritePaletteEntry
d695 2
a696 2
;;; mjs
;;; Pre HAL code had possible LCD greyscale munging, not supported in interim s.vduhint code
d715 2
a716 2
        AddressHAL
        CallHAL HAL_Video_WritePaletteEntry
d908 2
a909 2
        AddressHAL
        CallHAL HAL_Video_WritePaletteEntries
d939 1
a939 1
        AddressHAL
d978 1
a978 1
        CallHAL HAL_Video_WritePaletteEntries
d983 1
a983 1
        CallHAL HAL_Video_WritePaletteEntry
d989 1
a989 1
        CallHAL HAL_Video_WritePaletteEntries
d1025 2
a1026 2
        AddressHAL
        CallHAL HAL_Video_SetBlank
d1216 1
a1216 1
 [ LCDInvert :LAND: :LNOT: HAL
d1226 2
d1240 2
a1241 2
        AddressHAL
        CallHAL HAL_Video_SetPowerSave
d1252 2
a1253 2
        AddressHAL
        CallHAL HAL_Video_SetPowerSave
@


1.1.2.8
log
@Make GraphicsV_IICOp more consistent
No accepts  r0 = b31-24 set 0
                 b23-16 fully qualified IIC address
                 b15-0  starting offset
            r1 = buffer pointer
            r2 = number of bytes to tranfer
            r4 = b31-24 display number
                 b23-16 head
                 b15-0  reason code (=14)
Now returns r0 = result codes as per HAL_IICTransfer()
            r1 = buffer pointer incremented by number of bytes transferred
            r2 = number of bytes *not* transferred
            r4 = 0
Removed '_' after Video in entry numbers to be consistent with other HAL entry naming, and HAL_VideoFlybackDevice.
Added IICStatus return numbers to Hdr:HALEntries.
Stop calling HAL_MonitorLeadID as only IOMD implemented it - just guess VGA until the graphics driver says otherwise.

Version 5.35, 4.79.2.159. Tagged as 'Kernel-5_35-4_79_2_159'
@
text
@d665 1
a665 1
        CallHAL HAL_VideoWritePaletteEntry
d716 1
a716 1
        CallHAL HAL_VideoWritePaletteEntry
d909 1
a909 1
        CallHAL HAL_VideoWritePaletteEntries
d978 1
a978 1
        CallHAL HAL_VideoWritePaletteEntries
d983 1
a983 1
        CallHAL HAL_VideoWritePaletteEntry
d989 1
a989 1
        CallHAL HAL_VideoWritePaletteEntries
d1026 1
a1026 1
        CallHAL HAL_VideoSetBlank
d1239 1
a1239 1
        CallHAL HAL_VideoSetPowerSave
d1251 1
a1251 1
        CallHAL HAL_VideoSetPowerSave
@


1.1.2.9
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@a108 4
        LDR     r0, [WsPtr, #DisplayModeFlags]
        TST     r0, #ModeFlag_GreyscalePalette
        BNE     %FT30
05
a140 1
15
a149 25
30
        ; Check that we know how to generate a greyscale palette for this mode
        ASSERT  ModeFlag_DataFormatFamily_RGB = 0
        TST     r0, #ModeFlag_DataFormatFamily_Mask ; Must be RGB
        BNE     %BT05
        LDR     r6, [WsPtr, #DisplayNColour]
        CMP     r6, #63                 ; not possible in VIDC10 256 colour
        BEQ     %BT05
        LDR     r0, [WsPtr, #Log2BPP]
        CMP     r0, #3                  ; Must be <= 256 colour
        CMPLS   r6, #255                ; Check both values to be sure
        BHI     %BT05
        MOV     r1, #3
        MOV     r2, #0
        ADR     r5, greyscale_mult
        LDR     r5, [r5, r0, LSL #2]
        MOV     r0, #0
35
        MUL     r2, r0, r5
        BL      UpdateNormalColour
        SUBS    r6, r6, #1
        ADD     r0, r0, #1
        BGE     %BT35
        B       %BT15

a157 6
        
greyscale_mult
        DCD     &FFFFFF00 ; 1bpp
        DCD     &55555500 ; 2bpp
        DCD     &11111100 ; 4bpp
        DCD     &01010100 ; 8bpp
d518 1
a518 1
        TST     lr, #ModeFlag_BBCGapMode
@


1.1.2.10
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d683 1
d685 1
a685 3
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_WritePaletteEntry
d693 11
d734 1
d736 1
a736 3
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_WritePaletteEntry
d744 11
d925 1
d927 3
d939 2
a940 3
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_WritePaletteEntries
d942 7
d971 6
a976 1
        Entry   "r0-r3, r9-r11"
d989 1
d994 1
a994 3
        LDR     r9, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r9, r9, LSL #24
        ORR     r4, r9, #GraphicsV_WritePaletteEntries
d1000 1
a1000 1
        ORR     r4, r9, #GraphicsV_WritePaletteEntry
d1007 1
a1007 1
        ORR     r4, r9, #GraphicsV_WritePaletteEntries
d1009 18
d1056 2
a1057 3
        LDR     r4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_SetBlank
d1059 6
@


1.1.2.11
log
@ModeFlag_GreyscalePalette handling improvements. Issue service calls on certain GraphicsV events. Sprite tweaks and fixes.
Detail:
  hdr/VduExt - Add reason codes used by Service_DisplayChanged & Service_DisplayStatus
  s/vdu/vdugrafg - Remove dependency on SpriteReason_BadReasonCode; just use the size of our lookup table instead. Alter SpriteOp lookup table so that unimplemented ops return an error instead of doing nothing. Fix PutSprite incorrectly using the slow GCOL action plotter if a request was made to plot a sprite using its mask but the sprite has none.
  s/vdu/vdugrafl - Update screen redirection handling to set ModeFlag_GreyscalePalette if switching output to a sprite with a greyscale palette or a RISC OS Select alpha mask. Restore the flag to its correct value when restoring screen output.
  s/vdu/vdupalxx - Update ModeFlag_GreyscalePalette in realtime as the palette is changed
  s/vdu/vduswis - Issue Service_DisplayChanged during OS_ScreenMode 11. Issue Service_DisplayStatus during OS_ScreenMode 65 & 66.
Admin:
  Tested on Iyonix, BB-xM


Version 5.35, 4.79.2.210. Tagged as 'Kernel-5_35-4_79_2_210'
@
text
@d428 1
a428 1
        MOVEQ   R1,#1+4
d436 1
a436 1
        MOVEQ   R1,#2+4
a455 32
        ; Update greyscale palette mode flag as appropriate
        LDR     r2, [WsPtr, #DisplayNColour]
        CMP     r7, #19
        CMP     r2, #256
        BHS     %FT90
        PHPSEI
        LDR     r7, [WsPtr, #DisplayModeFlags]
        CMP     r2, #63
        LDR     r5, [WsPtr, #FirPalAddr]
        MOVEQ   r2, #255
        LDR     r6, [WsPtr, #SecPalAddr]
        BIC     r7, r7, #ModeFlag_GreyscalePalette
30
        LDR     r8, [r5], #4
        LDR     r9, [r6], #4
        EOR     r8, r8, r8, LSL #8
        EOR     r9, r9, r9, LSL #8
        CMP     r8, #&10000
        CMPLO   r9, #&10000
        BHS     %FT40
        SUBS    r2, r2, #1
        BGE     %BT30
        ORR     r7, r7, #ModeFlag_GreyscalePalette
40
        STR     r7, [WsPtr, #DisplayModeFlags]
        ; Update live ModeFlags if not redirected to sprite
        LDR     r8, [WsPtr, #VduSprite]
        TEQ     r8, #0
        STREQ   r7, [WsPtr, #ModeFlags]
        PLP
90

a583 1
;            bit 2 set to suppress greyscale palette check
a620 1
;            bit 2 set to suppress greyscale palette check
a637 1
;            bit 2 set to suppress greyscale palette check
a736 45
        ; Update greyscale palette mode flag as appropriate
        ; NOTE - relies on r3 being 2nd flash state
        LDR     r2, [WsPtr, #DisplayNColour]
        CMP     r0, #256
        CMPLO   r2, #256
        CMPLO   r1, #4
        BHS     %FT90
        EOR     r4, r3, r4              ; r4 = 1st flash state, r3 = 2nd
        EOR     r8, r3, r3, LSL #8
        EOR     r9, r4, r4, LSL #8
        TST     r1, #1
        MOVEQ   r9, #0                  ; treat unmodified flash states as greyscale - the full check below will sort things out properly if required
        TST     r2, #1
        MOVEQ   r8, #0
        CMP     r8, #&10000
        CMPLO   r9, #&10000
        ; LO -> palette potentially greyscale, HS -> definitely not greyscale
        LDR     r7, [WsPtr, #DisplayModeFlags]
        BICHS   r7, r7, #ModeFlag_GreyscalePalette
        BHS     %FT40
        TST     r7, #ModeFlag_GreyscalePalette
        BNE     %FT90
        ; Check the full palette for greyscaleness
        CMP     r2, #63
        LDR     r5, [WsPtr, #FirPalAddr]
        MOVEQ   r2, #255
        LDR     r6, [WsPtr, #SecPalAddr]
30
        LDR     r8, [r5], #4
        LDR     r9, [r6], #4
        EOR     r8, r8, r8, LSL #8
        EOR     r9, r9, r9, LSL #8
        CMP     r8, #&10000
        CMPLO   r9, #&10000
        BHS     %FT90
        SUBS    r2, r2, #1
        BGE     %BT30
        ORR     r7, r7, #ModeFlag_GreyscalePalette
40
        STR     r7, [WsPtr, #DisplayModeFlags]
        ; Update live ModeFlags if not redirected to sprite
        LDR     r8, [WsPtr, #VduSprite]
        TEQ     r8, #0
        STREQ   r7, [WsPtr, #ModeFlags]
90
@


1.1.2.12
log
@Add builtin software pointer support
Detail:
  This set of changes adds support for rendering software mouse pointers directly in the kernel, rather than requiring graphics drivers to render them themselves as was the case previously.
  If a driver returns from GraphicsV_Features with the 'hardware pointer' bit clear, and a call to GraphicsV_UpdatePointer is returned unclaimed, then the kernel will step in and render a software pointer. This allows selective control over which areas of the screen the software pointer is used (e.g. if hardware only supports its use in some areas)
  hdr/KernelWS - Shrink PointerXEigFactor to 1 byte to free up some space for tracking the display log2bpp. Use 8 words of space for tracking software pointer state.
  s/vdu/vducursoft - Adjust existing the existing calls to the software pointer RemovePointer/RestorePointer functions so that they're called with IRQs enabled
  s/vdu/vdudriver - Keep track of display log2bpp. Claim/release memory needed for restoring pixels under software pointer.
  s/vdu/vdugrafhal - Update HAL_VideoUpdatePointer handling so that 0 can be returned in a1 to indicate the GraphicsV call should be left unclaimed.
  s/vdu/vdupalxx - Trigger updates of the cached software pointer palette whenever it's likely to become invalidated.
  s/vdu/vdupointer - Add software pointer implementation. Relying on a SpriteExtend OS_SpriteOp would be nice, but we're in the background so have to do plotting & unplotting manually. ColourTrans is used to cache the pointer palette colours for the current mode, although we're limited to calling it from a callback.
Admin:
  Tested on Raspberry Pi & BB-xM
  Pointer is very flickery under some circumstances (e.g. running !CloseUp) due to needing to plot/unplot around any VDU driver screen access (as per text cursor). So code may need revising in future once we can trap reads/writes from specific screen memory pages.


Version 5.35, 4.79.2.269. Tagged as 'Kernel-5_35-4_79_2_269'
@
text
@a183 7
        ; Ensure software pointer palette is refereshed
        LDR     r4, [WsPtr, #GraphicsVFeatures]
        TST     r4, #GVDisplayFeature_HardwarePointer
        LDREQB  r4, [WsPtr, #SWP_Callback]
        TEQEQ   r4, #0
        BLEQ    RegisterSoftwarePointerCallback

a553 7
        LDR     r4, [WsPtr, #GraphicsVFeatures]
        TST     r4, #GVDisplayFeature_HardwarePointer
        LDREQB  r4, [WsPtr, #SWP_Callback]
        TEQEQ   r4, #0
        LDREQB  r4, [WsPtr, #DisplayLog2BPP]
        TSTEQ   r4, #&FC                ; Callback only needed here for <=8bpp
        BLEQ    RegisterSoftwarePointerCallback
a608 5
        LDR     r4, [WsPtr, #GraphicsVFeatures]
        TST     r4, #GVDisplayFeature_HardwarePointer
        LDREQB  r4, [WsPtr, #SWP_Callback]
        TEQEQ   r4, #0
        BLEQ    RegisterSoftwarePointerCallback
@


1.1.2.5.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d1035 1
a1035 1
        LDR     r9, =ZeroPage
@



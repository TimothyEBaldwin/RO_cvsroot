head	4.8;
access;
symbols
	Kernel-6_15:4.8
	Kernel-6_14:4.8
	Kernel-6_01-3:4.7
	Kernel-6_13:4.7
	Kernel-6_12:4.7
	Kernel-6_11:4.7
	Kernel-6_10:4.7
	Kernel-6_09:4.7
	Kernel-6_08-4_129_2_10:4.7
	Kernel-6_08-4_129_2_9:4.7
	Kernel-6_08:4.7
	Kernel-6_07:4.7
	Kernel-6_06:4.7
	Kernel-6_05-4_129_2_8:4.7
	Kernel-6_05:4.7
	Kernel-6_04:4.7
	Kernel-6_03:4.7
	Kernel-6_01-2:4.7
	Kernel-6_01-4_146_2_1:4.7
	Kernel-6_02:4.7
	Kernel-6_01-1:4.7
	Kernel-6_01:4.7
	Kernel-6_00:4.7
	Kernel-5_99:4.7
	Kernel-5_98:4.7
	Kernel-5_97-4_129_2_7:4.7
	Kernel-5_97:4.7
	Kernel-5_96:4.7
	Kernel-5_95:4.7
	Kernel-5_94:4.7
	Kernel-5_93:4.7
	Kernel-5_92:4.7
	Kernel-5_91:4.7
	Kernel-5_90:4.7
	Kernel-5_89-4_129_2_6:4.7
	Kernel-5_89:4.7
	Kernel-5_88-4_129_2_5:4.7
	Kernel-5_88-4_129_2_4:4.7
	Kernel-5_88:4.7
	Kernel-5_87:4.7
	Kernel-5_86-4_129_2_3:4.7
	Kernel-5_86-4_129_2_2:4.7
	Kernel-5_86-4_129_2_1:4.7
	Kernel-5_86:4.7
	SMP:4.7.0.2
	SMP_bp:4.7
	Kernel-5_85:4.7
	Kernel-5_54-1:4.7
	Kernel-5_84:4.7
	Kernel-5_83:4.7
	Kernel-5_82:4.7
	Kernel-5_81:4.7
	Kernel-5_80:4.7
	Kernel-5_79:4.7
	Kernel-5_78:4.7
	Kernel-5_77:4.7
	Kernel-5_76:4.7
	Kernel-5_75:4.7
	Kernel-5_74:4.7
	Kernel-5_73:4.7
	Kernel-5_72:4.7
	Kernel-5_71:4.7
	Kernel-5_70:4.7
	Kernel-5_69:4.7
	Kernel-5_68:4.7
	Kernel-5_67:4.7
	Kernel-5_66:4.7
	Kernel-5_65:4.7
	Kernel-5_64:4.7
	Kernel-5_63:4.7
	Kernel-5_62:4.7
	Kernel-5_61:4.7
	Kernel-5_60:4.7
	Kernel-5_59:4.7
	Kernel-5_58:4.7
	Kernel-5_57:4.7
	Kernel-5_56:4.7
	Kernel-5_55:4.7
	Kernel-5_54:4.7
	Kernel-5_53:4.7
	Kernel-5_52:4.7
	Kernel-5_51:4.7
	Kernel-5_50:4.7
	Kernel-5_49:4.7
	HAL_merge:4.6.2.11
	Kernel-5_48:4.7
	Kernel-5_35-4_79_2_327:4.6.2.11
	Kernel-5_35-4_79_2_326:4.6.2.11
	Kernel-5_35-4_79_2_325:4.6.2.11
	Kernel-5_35-4_79_2_324:4.6.2.11
	Kernel-5_35-4_79_2_323:4.6.2.11
	Kernel-5_35-4_79_2_322:4.6.2.11
	Kernel-5_35-4_79_2_321:4.6.2.11
	Kernel-5_35-4_79_2_320:4.6.2.11
	Kernel-5_35-4_79_2_319:4.6.2.11
	Kernel-5_35-4_79_2_318:4.6.2.11
	Kernel-5_35-4_79_2_317:4.6.2.11
	Kernel-5_35-4_79_2_316:4.6.2.11
	Kernel-5_35-4_79_2_315:4.6.2.11
	Kernel-5_35-4_79_2_314:4.6.2.11
	Kernel-5_35-4_79_2_313:4.6.2.11
	Kernel-5_35-4_79_2_312:4.6.2.11
	Kernel-5_35-4_79_2_311:4.6.2.11
	Kernel-5_35-4_79_2_310:4.6.2.11
	Kernel-5_35-4_79_2_309:4.6.2.11
	Kernel-5_35-4_79_2_308:4.6.2.11
	Kernel-5_35-4_79_2_307:4.6.2.11
	Kernel-5_35-4_79_2_306:4.6.2.11
	Kernel-5_35-4_79_2_305:4.6.2.11
	Kernel-5_35-4_79_2_304:4.6.2.11
	Kernel-5_35-4_79_2_303:4.6.2.11
	Kernel-5_35-4_79_2_302:4.6.2.11
	Kernel-5_35-4_79_2_301:4.6.2.11
	Kernel-5_35-4_79_2_300:4.6.2.11
	Kernel-5_35-4_79_2_299:4.6.2.11
	Kernel-5_35-4_79_2_298:4.6.2.11
	Kernel-5_35-4_79_2_297:4.6.2.11
	Kernel-5_35-4_79_2_296:4.6.2.11
	Kernel-5_35-4_79_2_295:4.6.2.11
	Kernel-5_35-4_79_2_294:4.6.2.11
	Kernel-5_35-4_79_2_293:4.6.2.11
	Kernel-5_35-4_79_2_292:4.6.2.11
	Kernel-5_35-4_79_2_291:4.6.2.11
	Kernel-5_35-4_79_2_290:4.6.2.11
	Kernel-5_35-4_79_2_289:4.6.2.11
	Kernel-5_35-4_79_2_288:4.6.2.11
	Kernel-5_35-4_79_2_287:4.6.2.11
	Kernel-5_35-4_79_2_286:4.6.2.11
	Kernel-5_35-4_79_2_285:4.6.2.11
	Kernel-5_35-4_79_2_284:4.6.2.11
	Kernel-5_35-4_79_2_283:4.6.2.11
	Kernel-5_35-4_79_2_282:4.6.2.11
	Kernel-5_35-4_79_2_281:4.6.2.11
	Kernel-5_35-4_79_2_280:4.6.2.11
	Kernel-5_35-4_79_2_279:4.6.2.11
	Kernel-5_35-4_79_2_278:4.6.2.10
	Kernel-5_35-4_79_2_277:4.6.2.10
	Kernel-5_35-4_79_2_276:4.6.2.10
	Kernel-5_35-4_79_2_275:4.6.2.10
	Kernel-5_35-4_79_2_274:4.6.2.10
	Kernel-5_35-4_79_2_273:4.6.2.10
	Kernel-5_35-4_79_2_272:4.6.2.10
	Kernel-5_35-4_79_2_271:4.6.2.10
	Kernel-5_35-4_79_2_270:4.6.2.10
	Kernel-5_35-4_79_2_269:4.6.2.10
	Kernel-5_35-4_79_2_268:4.6.2.10
	Kernel-5_35-4_79_2_267:4.6.2.10
	Kernel-5_35-4_79_2_266:4.6.2.10
	Kernel-5_35-4_79_2_265:4.6.2.10
	Kernel-5_35-4_79_2_264:4.6.2.10
	Kernel-5_35-4_79_2_263:4.6.2.10
	Kernel-5_35-4_79_2_262:4.6.2.10
	Kernel-5_35-4_79_2_261:4.6.2.10
	Kernel-5_35-4_79_2_260:4.6.2.10
	Kernel-5_35-4_79_2_259:4.6.2.10
	Kernel-5_35-4_79_2_258:4.6.2.10
	Kernel-5_35-4_79_2_257:4.6.2.10
	Kernel-5_35-4_79_2_256:4.6.2.10
	Kernel-5_35-4_79_2_255:4.6.2.10
	Kernel-5_35-4_79_2_254:4.6.2.10
	Kernel-5_35-4_79_2_253:4.6.2.10
	Kernel-5_35-4_79_2_252:4.6.2.10
	Kernel-5_35-4_79_2_251:4.6.2.10
	Kernel-5_35-4_79_2_250:4.6.2.10
	Kernel-5_35-4_79_2_249:4.6.2.10
	Kernel-5_35-4_79_2_248:4.6.2.10
	Kernel-5_35-4_79_2_247:4.6.2.10
	Kernel-5_35-4_79_2_246:4.6.2.10
	Kernel-5_35-4_79_2_245:4.6.2.10
	Kernel-5_35-4_79_2_244:4.6.2.10
	Kernel-5_35-4_79_2_243:4.6.2.10
	Kernel-5_35-4_79_2_242:4.6.2.10
	Kernel-5_35-4_79_2_241:4.6.2.10
	Kernel-5_35-4_79_2_240:4.6.2.10
	Kernel-5_35-4_79_2_239:4.6.2.10
	Kernel-5_35-4_79_2_238:4.6.2.10
	Kernel-5_35-4_79_2_237:4.6.2.9
	Kernel-5_35-4_79_2_236:4.6.2.9
	Kernel-5_35-4_79_2_235:4.6.2.9
	Kernel-5_35-4_79_2_234:4.6.2.9
	Kernel-5_35-4_79_2_233:4.6.2.9
	Kernel-5_35-4_79_2_232:4.6.2.9
	Kernel-5_35-4_79_2_231:4.6.2.9
	Kernel-5_35-4_79_2_230:4.6.2.9
	Kernel-5_35-4_79_2_229:4.6.2.9
	Kernel-5_35-4_79_2_228:4.6.2.9
	Kernel-5_35-4_79_2_227:4.6.2.9
	Kernel-5_35-4_79_2_226:4.6.2.9
	Kernel-5_35-4_79_2_225:4.6.2.9
	Kernel-5_35-4_79_2_224:4.6.2.9
	Kernel-5_35-4_79_2_223:4.6.2.9
	Kernel-5_35-4_79_2_222:4.6.2.9
	Kernel-5_35-4_79_2_221:4.6.2.9
	Kernel-5_35-4_79_2_220:4.6.2.9
	Kernel-5_35-4_79_2_219:4.6.2.9
	Kernel-5_35-4_79_2_218:4.6.2.9
	Kernel-5_35-4_79_2_217:4.6.2.9
	Kernel-5_35-4_79_2_216:4.6.2.9
	Kernel-5_35-4_79_2_215:4.6.2.9
	Kernel-5_35-4_79_2_214:4.6.2.9
	Kernel-5_35-4_79_2_213:4.6.2.9
	Kernel-5_35-4_79_2_212:4.6.2.9
	Kernel-5_35-4_79_2_211:4.6.2.9
	Kernel-5_35-4_79_2_210:4.6.2.9
	Kernel-5_35-4_79_2_209:4.6.2.9
	Kernel-5_35-4_79_2_208:4.6.2.9
	Kernel-5_35-4_79_2_207:4.6.2.9
	Kernel-5_35-4_79_2_206:4.6.2.9
	Kernel-5_35-4_79_2_205:4.6.2.9
	Kernel-5_35-4_79_2_204:4.6.2.9
	Kernel-5_35-4_79_2_203:4.6.2.9
	Kernel-5_35-4_79_2_202:4.6.2.8
	Kernel-5_35-4_79_2_201:4.6.2.8
	Kernel-5_35-4_79_2_200:4.6.2.8
	Kernel-5_35-4_79_2_199:4.6.2.8
	Kernel-5_35-4_79_2_198:4.6.2.8
	Kernel-5_35-4_79_2_197:4.6.2.8
	Kernel-5_35-4_79_2_196:4.6.2.8
	Kernel-5_35-4_79_2_195:4.6.2.8
	Kernel-5_35-4_79_2_194:4.6.2.8
	Kernel-5_35-4_79_2_193:4.6.2.7
	Kernel-5_35-4_79_2_192:4.6.2.7
	Kernel-5_35-4_79_2_191:4.6.2.7
	Kernel-5_35-4_79_2_190:4.6.2.7
	Kernel-5_35-4_79_2_189:4.6.2.7
	Kernel-5_35-4_79_2_188:4.6.2.7
	Kernel-5_35-4_79_2_187:4.6.2.7
	Kernel-5_35-4_79_2_186:4.6.2.7
	Kernel-5_35-4_79_2_185:4.6.2.7
	Kernel-5_35-4_79_2_184:4.6.2.7
	Kernel-5_35-4_79_2_183:4.6.2.7
	Kernel-5_35-4_79_2_182:4.6.2.7
	Kernel-5_35-4_79_2_181:4.6.2.7
	Kernel-5_35-4_79_2_180:4.6.2.7
	Kernel-5_35-4_79_2_179:4.6.2.7
	Kernel-5_35-4_79_2_178:4.6.2.7
	Kernel-5_35-4_79_2_177:4.6.2.7
	Kernel-5_35-4_79_2_176:4.6.2.7
	Kernel-5_35-4_79_2_175:4.6.2.7
	Kernel-5_35-4_79_2_174:4.6.2.7
	Kernel-5_35-4_79_2_173:4.6.2.7
	Kernel-5_35-4_79_2_172:4.6.2.7
	Kernel-5_35-4_79_2_171:4.6.2.7
	Kernel-5_35-4_79_2_170:4.6.2.7
	Kernel-5_35-4_79_2_169:4.6.2.7
	Kernel-5_35-4_79_2_168:4.6.2.7
	Kernel-5_35-4_79_2_167:4.6.2.7
	Kernel-5_35-4_79_2_166:4.6.2.7
	Kernel-5_35-4_79_2_165:4.6.2.7
	RPi_merge:4.6.2.7
	Kernel-5_35-4_79_2_147_2_23:4.6.2.7
	Kernel-5_35-4_79_2_147_2_22:4.6.2.7
	Kernel-5_35-4_79_2_147_2_21:4.6.2.7
	Kernel-5_35-4_79_2_147_2_20:4.6.2.7
	Kernel-5_35-4_79_2_147_2_19:4.6.2.7
	Kernel-5_35-4_79_2_147_2_18:4.6.2.7
	Kernel-5_35-4_79_2_164:4.6.2.7
	Kernel-5_35-4_79_2_163:4.6.2.7
	Kernel-5_35-4_79_2_147_2_17:4.6.2.7
	Kernel-5_35-4_79_2_147_2_16:4.6.2.7
	Kernel-5_35-4_79_2_147_2_15:4.6.2.7
	Kernel-5_35-4_79_2_162:4.6.2.7
	Kernel-5_35-4_79_2_161:4.6.2.7
	Kernel-5_35-4_79_2_147_2_14:4.6.2.7
	Kernel-5_35-4_79_2_147_2_13:4.6.2.7
	Kernel-5_35-4_79_2_160:4.6.2.7
	Kernel-5_35-4_79_2_159:4.6.2.7
	Kernel-5_35-4_79_2_158:4.6.2.7
	Kernel-5_35-4_79_2_157:4.6.2.7
	Kernel-5_35-4_79_2_156:4.6.2.7
	Kernel-5_35-4_79_2_147_2_12:4.6.2.7
	Kernel-5_35-4_79_2_147_2_11:4.6.2.7
	Kernel-5_35-4_79_2_155:4.6.2.7
	Kernel-5_35-4_79_2_147_2_10:4.6.2.7
	Kernel-5_35-4_79_2_154:4.6.2.7
	Kernel-5_35-4_79_2_153:4.6.2.7
	Kernel-5_35-4_79_2_147_2_9:4.6.2.7
	Kernel-5_35-4_79_2_152:4.6.2.7
	Kernel-5_35-4_79_2_151:4.6.2.7
	Kernel-5_35-4_79_2_147_2_8:4.6.2.7
	Kernel-5_35-4_79_2_147_2_7:4.6.2.7
	Kernel-5_35-4_79_2_150:4.6.2.7
	Kernel-5_35-4_79_2_147_2_6:4.6.2.7
	Kernel-5_35-4_79_2_147_2_5:4.6.2.7
	Kernel-5_35-4_79_2_149:4.6.2.7
	Kernel-5_35-4_79_2_147_2_4:4.6.2.7
	Kernel-5_35-4_79_2_147_2_3:4.6.2.7
	Kernel-5_35-4_79_2_148:4.6.2.7
	Kernel-5_35-4_79_2_147_2_2:4.6.2.7
	Kernel-5_35-4_79_2_147_2_1:4.6.2.7
	RPi:4.6.2.7.0.2
	RPi_bp:4.6.2.7
	Kernel-5_35-4_79_2_98_2_52_2_1:4.6.2.5.2.2
	alees_Kernel_dev:4.6.2.5.2.2.0.2
	alees_Kernel_dev_bp:4.6.2.5.2.2
	Kernel-5_35-4_79_2_147:4.6.2.7
	Kernel-5_35-4_79_2_146:4.6.2.7
	Kernel-5_35-4_79_2_145:4.6.2.7
	Kernel-5_35-4_79_2_144:4.6.2.7
	Kernel-5_35-4_79_2_143:4.6.2.7
	Kernel-5_35-4_79_2_142:4.6.2.7
	Kernel-5_35-4_79_2_141:4.6.2.7
	Kernel-5_35-4_79_2_140:4.6.2.7
	Kernel-5_35-4_79_2_139:4.6.2.7
	Kernel-5_35-4_79_2_138:4.6.2.7
	Kernel-5_35-4_79_2_137:4.6.2.7
	Kernel-5_35-4_79_2_136:4.6.2.7
	Kernel-5_35-4_79_2_135:4.6.2.7
	Kernel-5_35-4_79_2_134:4.6.2.7
	Kernel-5_35-4_79_2_133:4.6.2.7
	Kernel-5_35-4_79_2_132:4.6.2.7
	Kernel-5_35-4_79_2_131:4.6.2.7
	Kernel-5_35-4_79_2_130:4.6.2.7
	Kernel-5_35-4_79_2_129:4.6.2.7
	Kernel-5_35-4_79_2_128:4.6.2.7
	Kernel-5_35-4_79_2_127:4.6.2.6
	Kernel-5_35-4_79_2_126:4.6.2.6
	Kernel-5_35-4_79_2_125:4.6.2.6
	Kernel-5_35-4_79_2_124:4.6.2.6
	Kernel-5_35-4_79_2_123:4.6.2.6
	Cortex_merge:4.6.2.5.2.3
	Kernel-5_35-4_79_2_122:4.6.2.5
	Kernel-5_35-4_79_2_98_2_54:4.6.2.5.2.3
	Kernel-5_35-4_79_2_98_2_53:4.6.2.5.2.3
	Kernel-5_35-4_79_2_98_2_52:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_51:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_50:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_49:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_48:4.6.2.5.2.2
	Kernel-5_35-4_79_2_121:4.6.2.5
	Kernel-5_35-4_79_2_98_2_47:4.6.2.5.2.2
	Kernel-5_35-4_79_2_120:4.6.2.5
	Kernel-5_35-4_79_2_98_2_46:4.6.2.5.2.2
	Kernel-5_35-4_79_2_119:4.6.2.5
	Kernel-5_35-4_79_2_98_2_45:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_44:4.6.2.5.2.2
	Kernel-5_35-4_79_2_118:4.6.2.5
	Kernel-5_35-4_79_2_98_2_43:4.6.2.5.2.2
	Kernel-5_35-4_79_2_117:4.6.2.5
	Kernel-5_35-4_79_2_116:4.6.2.5
	Kernel-5_35-4_79_2_98_2_42:4.6.2.5.2.2
	Kernel-5_35-4_79_2_115:4.6.2.5
	Kernel-5_35-4_79_2_98_2_41:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_40:4.6.2.5.2.2
	Kernel-5_35-4_79_2_114:4.6.2.5
	Kernel-5_35-4_79_2_98_2_39:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_38:4.6.2.5.2.2
	Kernel-5_35-4_79_2_113:4.6.2.5
	Kernel-5_35-4_79_2_112:4.6.2.5
	Kernel-5_35-4_79_2_98_2_37:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_36:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_35:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_34:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_33:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_32:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_31:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_30:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_29:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_28:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_27:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_26:4.6.2.5.2.2
	Kernel-5_35-4_79_2_111:4.6.2.5
	Kernel-5_35-4_79_2_98_2_25:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_24:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_23:4.6.2.5.2.2
	Kernel-5_35-4_79_2_110:4.6.2.5
	Kernel-5_35-4_79_2_98_2_22:4.6.2.5.2.2
	Kernel-5_35-4_79_2_109:4.6.2.5
	Kernel-5_35-4_79_2_98_2_21:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_20:4.6.2.5.2.2
	Kernel-5_35-4_79_2_108:4.6.2.5
	Kernel-5_35-4_79_2_107:4.6.2.5
	Kernel-5_35-4_79_2_98_2_19:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_18:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_17:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_16:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_15:4.6.2.5.2.2
	Kernel-5_35-4_79_2_106:4.6.2.5
	Kernel-5_35-4_79_2_105:4.6.2.5
	Kernel-5_35-4_79_2_104:4.6.2.5
	Kernel-5_35-4_79_2_98_2_14:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_13:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_12:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_11:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_10:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_9:4.6.2.5.2.2
	Kernel-5_35-4_79_2_103:4.6.2.5
	Kernel-5_35-4_79_2_102:4.6.2.5
	Kernel-5_35-4_79_2_98_2_8:4.6.2.5.2.2
	Kernel-5_35-4_79_2_98_2_7:4.6.2.5.2.1
	Kernel-5_35-4_79_2_98_2_6:4.6.2.5.2.1
	Kernel-5_35-4_79_2_98_2_5:4.6.2.5
	Kernel-5_35-4_79_2_98_2_4:4.6.2.5
	Kernel-5_35-4_79_2_101:4.6.2.5
	Kernel-5_35-4_79_2_100:4.6.2.5
	Kernel-5_35-4_79_2_99:4.6.2.5
	Kernel-5_35-4_79_2_98_2_3:4.6.2.5
	Kernel-5_35-4_79_2_98_2_2:4.6.2.5
	Kernel-5_35-4_79_2_98_2_1:4.6.2.5
	Cortex:4.6.2.5.0.2
	Cortex_bp:4.6.2.5
	Kernel-5_35-4_79_2_98:4.6.2.5
	Kernel-5_35-4_79_2_97:4.6.2.5
	Kernel-5_35-4_79_2_96:4.6.2.5
	Kernel-5_35-4_79_2_95:4.6.2.5
	Kernel-5_35-4_79_2_94:4.6.2.5
	Kernel-5_35-4_79_2_93:4.6.2.5
	Kernel-5_35-4_79_2_92:4.6.2.5
	Kernel-5_35-4_79_2_91:4.6.2.5
	Kernel-5_35-4_79_2_90:4.6.2.5
	Kernel-5_35-4_79_2_89:4.6.2.5
	Kernel-5_35-4_79_2_88:4.6.2.5
	Kernel-5_35-4_79_2_87:4.6.2.5
	Kernel-5_35-4_79_2_86:4.6.2.5
	Kernel-5_35-4_79_2_85:4.6.2.5
	Kernel-5_35-4_79_2_84:4.6.2.5
	Kernel-5_35-4_79_2_83:4.6.2.5
	Kernel-5_35-4_79_2_82:4.6.2.5
	Kernel-5_35-4_79_2_81:4.6.2.5
	Kernel-5_35-4_79_2_80:4.6.2.5
	Kernel-5_35-4_79_2_79:4.6.2.5
	Kernel-5_35-4_79_2_78:4.6.2.5
	Kernel-5_35-4_79_2_77:4.6.2.5
	RO_5_07:4.6.2.5
	Kernel-5_35-4_79_2_76:4.6.2.5
	Kernel-5_35-4_79_2_75:4.6.2.5
	Kernel-5_35-4_79_2_74:4.6.2.5
	Kernel-5_35-4_79_2_73:4.6.2.5
	Kernel-5_35-4_79_2_72:4.6.2.5
	Kernel-5_35-4_79_2_71:4.6.2.5
	Kernel-5_35-4_79_2_70:4.6.2.5
	Kernel-5_35-4_79_2_69:4.6.2.5
	Kernel-5_35-4_79_2_68:4.6.2.5
	Kernel-5_35-4_79_2_67:4.6.2.5
	Kernel-5_35-4_79_2_66:4.6.2.5
	Kernel-5_35-4_79_2_65:4.6.2.4
	Kernel-5_35-4_79_2_64:4.6.2.4
	Kernel-5_35-4_79_2_63:4.6.2.4
	Kernel-5_35-4_79_2_62:4.6.2.4
	Kernel-5_35-4_79_2_61:4.6.2.4
	Kernel-5_35-4_79_2_59:4.6.2.4
	Kernel-5_35-4_79_2_58:4.6.2.4
	Kernel-5_35-4_79_2_57:4.6.2.4
	Kernel-5_35-4_79_2_56:4.6.2.4
	Kernel-5_35-4_79_2_55:4.6.2.4
	Kernel-5_35-4_79_2_54:4.6.2.4
	Kernel-5_35-4_79_2_53:4.6.2.4
	Kernel-5_35-4_79_2_52:4.6.2.4
	Kernel-5_35-4_79_2_51:4.6.2.4
	Kernel-5_35-4_79_2_50:4.6.2.3
	Kernel-5_35-4_79_2_49:4.6.2.3
	Kernel-5_35-4_79_2_48:4.6.2.3
	Kernel-5_47:4.6
	Kernel-5_46-4_90_2_1:4.6
	nbingham_Kernel_FastNC_dev_bp:4.6
	nbingham_Kernel_FastNC_dev:4.6.0.4
	Kernel-5_46:4.6
	Kernel-5_45:4.6
	Kernel-5_35-4_79_2_47:4.6.2.2
	Kernel-5_35-4_79_2_46:4.6.2.2
	Kernel-5_35-4_79_2_45:4.6.2.2
	Kernel-5_35-4_79_2_44:4.6.2.2
	Kernel-5_35-4_79_2_25_2_2:4.6.2.2
	Kernel-5_35-4_79_2_43:4.6.2.2
	Kernel-5_35-4_79_2_42:4.6.2.2
	Kernel-5_35-4_79_2_41:4.6.2.2
	Kernel-5_35-4_79_2_40:4.6.2.2
	Kernel-5_35-4_79_2_39:4.6.2.2
	Kernel-5_35-4_79_2_38:4.6.2.2
	Kernel-5_35-4_79_2_37:4.6.2.2
	Kernel-5_35-4_79_2_36:4.6.2.2
	Kernel-5_35-4_79_2_35:4.6.2.2
	Kernel-5_35-4_79_2_34:4.6.2.2
	Kernel-5_35-4_79_2_33:4.6.2.2
	Kernel-5_35-4_79_2_32:4.6.2.2
	Kernel-5_44:4.6
	Kernel-5_35-4_79_2_25_2_1:4.6.2.2
	Kernel-5_43:4.6
	Kernel-5_35-4_79_2_31:4.6.2.2
	Kernel-5_35-4_79_2_30:4.6.2.2
	Kernel-5_35-4_79_2_29:4.6.2.2
	Kernel-5_35-4_79_2_28:4.6.2.2
	Kernel-5_35-4_79_2_27:4.6.2.2
	Kernel-5_35-4_79_2_26:4.6.2.2
	Kernel-5_42:4.6
	Kernel-5_41:4.6
	Kernel-5_40:4.6
	Kernel-5_35-4_79_2_25:4.6.2.2
	Kernel-5_35-4_79_2_24:4.6.2.2
	Kernel-5_35-4_79_2_23:4.6.2.2
	Kernel-5_35-4_79_2_22:4.6.2.2
	Kernel-5_35-4_79_2_21:4.6.2.2
	Kernel-5_35-4_79_2_20:4.6.2.2
	Kernel-5_35-4_79_2_19:4.6.2.2
	Kernel-5_35-4_79_2_18:4.6.2.2
	Kernel-5_35-4_79_2_17:4.6.2.2
	Kernel-5_35-4_79_2_16:4.6.2.2
	Kernel-5_35-4_79_2_15:4.6.2.2
	Kernel-5_35-4_79_2_14:4.6.2.2
	Kernel-5_39:4.6
	Kernel-5_13-4_52_2_1:4.5
	Bethany:4.5.0.2
	Kernel-5_38:4.6
	Kernel-5_35-4_79_2_13:4.6.2.2
	Kernel-5_35-4_79_2_12:4.6.2.2
	Kernel-5_35-4_79_2_11:4.6.2.2
	Kernel-5_37:4.6
	Kernel-5_35-4_79_2_10:4.6.2.2
	Kernel-5_35-4_79_2_9:4.6.2.2
	Kernel-5_36:4.6
	Kernel-5_35-4_79_2_8:4.6.2.2
	Kernel-5_35-4_79_2_7:4.6.2.2
	Kernel-5_35-4_79_2_6:4.6.2.2
	Kernel-5_35-4_79_2_5:4.6.2.2
	Kernel-5_35-4_79_2_4:4.6.2.2
	Kernel-5_35-4_79_2_3:4.6.2.1
	Kernel-5_35-4_79_2_2:4.6
	dellis_autobuild_BaseSW:4.6
	Kernel-5_35-4_79_2_1:4.6
	HAL:4.6.0.2
	Kernel-5_35:4.6
	Kernel-5_34:4.6
	Kernel-5_33:4.6
	Kernel-5_32:4.6
	Kernel-5_31:4.6
	Kernel-5_30:4.6
	Kernel-5_29:4.6
	Kernel-5_28:4.6
	Kernel-5_27:4.6
	Kernel-5_26:4.6
	Kernel-5_25:4.6
	Kernel-5_24:4.6
	Kernel-5_23:4.6
	Kernel-5_22:4.5
	sbrodie_sedwards_16Mar2000:4.5
	Kernel-5_21:4.5
	Kernel-5_20:4.5
	Kernel-5_19:4.5
	Kernel-5_18:4.5
	Kernel-5_17:4.5
	Kernel-5_16:4.5
	Kernel-5_15:4.5
	Kernel-5_14:4.5
	Kernel-5_13:4.5
	Kernel-5_12:4.5
	Kernel-5_11:4.5
	Kernel-5_10:4.5
	Kernel-5_09:4.5
	Kernel-5_08:4.5
	Kernel-5_07:4.5
	Kernel-5_06:4.5
	Kernel-5_05:4.5
	Kernel-5_04:4.5
	Kernel-5_03:4.5
	Kernel-5_02:4.5
	Kernel-5_01:4.5
	Kernel-5_00:4.5
	Kernel-4_99:4.5
	Kernel-4_98:4.5
	Kernel-4_97:4.5
	Kernel-4_96:4.5
	Kernel-4_95:4.5
	Kernel-4_94:4.5
	Kernel-4_93:4.5
	Kernel-4_92:4.5
	Kernel-4_91:4.5
	Kernel-4_90:4.5
	dcotton_autobuild_BaseSW:4.6
	Kernel-4_89:4.5
	Kernel-4_88:4.5
	Kernel-4_87:4.5
	Kernel-4_86:4.4
	Kernel-4_85:4.3
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.2.2.1
	Kernel-4_84:4.3
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.2.2.1
	Ursula_RiscPC_bp:4.2.2.2
	Kernel-4_83:4.3
	Kernel-4_82:4.3
	Kernel-4_81:4.3
	Kernel-4_80:4.3
	Kernel-4_79:4.3
	Kernel-4_78:4.3
	Kernel-4_77:4.3
	Kernel-4_76:4.3
	Kernel-4_75:4.3
	Kernel-4_74:4.3
	Kernel-4_73:4.3
	Kernel-4_72:4.3
	Kernel-4_71:4.3
	Kernel-4_70:4.3
	Kernel-4_69:4.3
	Kernel-4_68:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.2.2.1
	Ursula_RiscPC:4.2.2.2.0.2
	Kernel-4_63-1_1_2_5:4.1.7.2
	Kernel-4_63-1_1_2_4:4.1.7.2
	Kernel-4_67:4.3
	Kernel-4_66:4.3
	Kernel-4_63-1_1_2_3:4.1.7.2
	Kernel-4_65:4.3
	Ursula_merge:4.2
	Kernel-4_64:4.3
	mstphens_Kernel-3_81:4.2.2.3
	Kernel-4_63-1_1_2_2:4.1.7.2
	nicke_Kernel_4_62:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.2
	UrsulaBuild_FinalSoftload:4.2.2.2
	rthornb_UrsulaBuild-12Aug1998:4.2.2.2
	aglover_UrsulaBuild-05Aug1998:4.2.2.2
	rthornb_UrsulaBuild-29Jul1998:4.2.2.2
	rthornb_UrsulaBuild-22Jul1998:4.2.2.2
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.2
	rthornb_UrsulaBuild-07Jul1998:4.2.2.2
	rthornb_UrsulaBuild-17Jun1998:4.2.2.2
	rthornb_UrsulaBuild-03Jun1998:4.2.2.2
	rthornb_UrsulaBuild-27May1998:4.2.2.2
	mstphens_Kernel-3_80:4.2.2.2
	rthornb_UrsulaBuild-21May1998:4.2.2.2
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2018.11.07.22.28.13;	author jlee;	state Exp;
branches;
next	4.7;
commitid	Ub9LVqEF46x8X3ZA;

4.7
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.6;
commitid	IWoXxARWeuLDOwcz;

4.6
date	2000.04.04.14.27.39;	author kbracey;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	99.09.17.10.11.42;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.09.16.13.53.38;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.09.30.08.42.53;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.07.31;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.33;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2000.10.03.12.05.59;	author mstephen;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2000.10.05.11.55.12;	author mstephen;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches;
next	4.6.2.4;

4.6.2.4
date	2002.11.30.00.31.12;	author bavison;	state Exp;
branches;
next	4.6.2.5;

4.6.2.5
date	2004.05.06.16.02.04;	author kbracey;	state Exp;
branches
	4.6.2.5.2.1;
next	4.6.2.6;

4.6.2.6
date	2011.11.26.21.11.27;	author jlee;	state Exp;
branches;
next	4.6.2.7;
commitid	cI3W0zbtALQG6TIv;

4.6.2.7
date	2011.12.10.19.03.49;	author jlee;	state Exp;
branches;
next	4.6.2.8;
commitid	tEbdTPC2UwO3XFKv;

4.6.2.8
date	2013.08.06.22.43.09;	author jlee;	state Exp;
branches;
next	4.6.2.9;
commitid	TOIaeUf2Q4rBIr0x;

4.6.2.9
date	2013.12.15.21.34.11;	author jlee;	state Exp;
branches;
next	4.6.2.10;
commitid	KwuK29hKRyXO7hhx;

4.6.2.10
date	2014.09.18.21.52.55;	author jlee;	state Exp;
branches;
next	4.6.2.11;
commitid	6ckSnTJtm4MjkSQx;

4.6.2.11
date	2015.08.14.22.02.34;	author jlee;	state Exp;
branches;
next	;
commitid	6gyfvmM0cNZULhxy;

4.6.2.5.2.1
date	2009.05.10.20.22.33;	author bavison;	state Exp;
branches;
next	4.6.2.5.2.2;

4.6.2.5.2.2
date	2009.05.17.01.34.43;	author bavison;	state Exp;
branches;
next	4.6.2.5.2.3;

4.6.2.5.2.3
date	2011.09.24.19.55.59;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.2.2.1
date	97.05.21.09.30.40;	author mstphens;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.09.09.13.34.31;	author mstphens;	state Exp;
branches
	4.2.2.2.2.1;
next	4.2.2.3;

4.2.2.3
date	98.09.24.13.17.44;	author mstphens;	state Exp;
branches;
next	;

4.2.2.2.2.1
date	98.11.23.14.59.40;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.33;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.02.36;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.47;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.28;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	98.07.21.17.57.45;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Attempt to tidy up substitute screen mode selection logic
Detail:
  Over the years the OS's substitute screen mode selection logic has grown to be a tangled mess, and the logic it does implement isn't always very useful. Additionally, the kernel is structured in such a way that it can be hard for modules to override it.
  This set of changes aims to fix the many of the problems, by doing the following:
  - Moving all substitute mode selection logic out of the core VDU driver code and into a Service_ModeTranslation handler. This means you now only have one place in the kernel to look instead of several, and modules can override the behaviour by claiming/blocking the service call as appropriate.
  - Moving handling of the built-in VIDC lists out of the core VDU driver code and into a Service_ModeExtension handler. This means programs can now inspect these VIDC lists by issuing the right service call (although you are essentially limited to lists which the GraphicsV driver is OK with)
  - Moving *TV interlace & offset adjustment logic into the Service_ModeExtension handler, since they're legacy things which can be handled more cleanly for MDF/EDID (and the old code was poking memory the kernel didn't own)
  - Adding a Service_EnumerateScreenModes implementation, so that if you end up in the desktop with ScreenModes non-functional, the display manager at least has something useful to show you
  - Enhancing the handling of the built-in numbered modes so that they are now available in any colour depth; the Service_ModeExtension handler (and related handlers) treat the builtin VIDC lists as a set of mode timings, not a discrete set of modes
  - Substitute mode selection logic is a complete re-write. Instead of trying a handful of numbered fallback modes, it now tries:
    - Same mode but at higher colour depths
    - Same mode but at lower colour depths
    - Alternate resolutions (half-width mode with no double-pixel if original request was for double-pixel, and default resolution for monitor type)
  - Combined with the logic to allow the builtin VIDC lists to be used at any colour depth, this means that the kernel should now be able to find substitute modes for machines which lack support for <=8bpp modes (e.g. OMAP5)
  - Additionally the mode substitution code will attempt to retain as many properties of the originally requested mode as possible (eigen values, gap mode type, etc.)
  Other improvements:
  - The kernel now actually vets the builtin VIDC lists instead of assuming that they'll work (which also means they'll have the correct ExtraBytes value, where applicable)
  - The kernel now uses GraphicsV 19 (VetMode2) to vet the mode during the mode switch process, using the result to detect where the framebuffer will be placed. This allows for GraphicsV drivers to switch between DA 2 and external framestores on a per-mode basis.
  - The kernel now supports mode selectors which specify LineLength values which are larger than necessary; this will get translated to a suitable ExtraBytes control list item (+ combined with whatever padding the driver indicates is necessary via the VetMode2 result)
  File changes:
  - hdr/KernelWS - Reserve space for a VIDC list, since the Service_ModeExtension implementation typically can't use the built-in list as-is
  - s/Arthur3 - Issue Service_ModeFileChanged when the configured monitor type is changed, so that DisplayManager + friends are aware that the set of available modes has changed
  - s/GetAll - Fiddle with GETs a bit
  - s/MemMap2 - Extra LTORG
  - s/NewIRQs - Small routine to install/uninstall false VSync routine (previously from PushModeInfo, which wasn't really the appropriate place for it)
  - s/Utility - Hook up the extra service call handlers
  - s/vdu/legacymodes - New file containing the new service call implementations, and some related code
  - s/vdu/vdudecl - Move mode workspace definition here, from vdumodes
  - s/vdu/vdudriver - Remove assorted bits of mode substitution code. Plug in new bits for calling GraphicsV 19 during mode set, and deal with ExtraBytes/LineLength during PushModeInfo
  - s/vdu/vdumodes - Move some workspace definitions to s/vdu/vdudecl. Tweak how the builtin VIDC lists are stored.
  - s/vdu/vduswis - Rip out more mode substitution code. Issue Service_ModeFileChanged when monitor type is changed by OS_ScreenMode.
Admin:
  Tested on Raspberry Pi 3, Iyonix, IGEPv5


Version 6.14. Tagged as 'Kernel-6_14'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduDecl

; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver workspace and macro declarations
;
; Author R C Manby
; Date   5.9.86
;

        GBLL ForceMark                  ; whether we force start of mark state
ForceMark    SETL   {FALSE}             ; of cursor on exit from WRCH

        GBLL RePlot                     ; Re-plot cursor after wrch
RePlot  SETL {TRUE}

        GBLL UseVLineOnSolidLines       ; When TRUE VLine is assembled and used
UseVLineOnSolidLines  SETL {TRUE}       ; to plot vertical solid lines

        GBLL AvoidScreenReads           ; When TRUE, use extra code to avoid
AvoidScreenReads      SETL {TRUE}       ; reading the screen when we can avoid it

        GBLL DefaultSupremacy           ; When TRUE, 16bpp and 32bpp modes' default
DefaultSupremacy      SETL {FALSE}      ; palettes use top bits for supremacy

;
; Register usage
; ==============
;
StkPtr  RN 13    ;Restore on exit to keep BASIC happy!!
Link    RN 14

;
; Manifest constants
; ==================
;


; To change the order of mode variables, change the following:-
;  a)   The order of the 'wk' labels below
;  b)   The order of the output variables in macro VWSTAB
;  c)   The order of the variables in '$.Hdr.Workspace' and '$.Hdr.NewSpace'

        ^ 0
wkstart         # 0
; values which are calculated from sprite header when switching to sprite
wkScreenSize    # 4
wkXWindLimit    # 4
wkYWindLimit    # 4
wkLineLength    # 4
wkmiddle        # 0
; values which are taken from pushed mode info (from wkmiddle ... wkmidend)
wkNColour       # 4
wkYShftFactor   # 4
wkModeFlags     # 4
wkXEigFactor    # 4
wkYEigFactor    # 4
wkLog2BPC       # 4
wkLog2BPP       # 4
wkmidend        # 0
; these are also taken from sprite header
wkScrRCol       # 4
wkScrBRow       # 4
wkend           # 0
wksize * wkend-wkstart
wkwordsize * (wksize + 3) :AND: :NOT: 3

PushedInfoSize * wkwordsize + VIDCList3Size

NumModes        *       54
maxmode         *       NumModes-1

; Reason codes for generalised DAG interface



; Layout of palette space
PalEntries              *       256+1+3
                        ^       0
Pal_Blank               #       PalEntries*4    ; Blank palette (for screen saver)
Pal_LogFirst            #       PalEntries*4    ; Logical palette (as read/written by user)
Pal_LogSecond           #       PalEntries*4
Pal_PhysFirst           #       PalEntries*4    ; Physical palette (post transfer function)
Pal_PhysSecond          #       PalEntries*4
Pal_RTable              #       256             ; Logical->physical lookup tables for R,G,B,S
Pal_GTable              #       256
Pal_BTable              #       256
Pal_STable              #       256
Pal_Blocksize           #       0

; GraphicsV driver state
; For each allocated driver number, the corresponding word of GraphicsVDrivers
; points to an instance of the following structure:

                            ^   0
GVDriver_RegisterFlags      #   4        ; Flags on registration
GVDriver_Name               #   4        ; Name on registration
GVDriver_StateFlags         #   4        ; Current state flags
GVDriver_Size               #   0

GVDriverState_Started       *   1:SHL:0  ; ScreenMode_StartDriver called

;
; Macro Definitions
; =================
;

;
; Macro Sort - Sort two values into increasing order
;
        MACRO
        Sort    $lo, $hi
        CMP     $hi, $lo
        EORLT   $lo, $lo, $hi
        EORLT   $hi, $lo, $hi
        EORLT   $lo, $lo, $hi
        MEND

;
; Macro SortT - Sort two values into increasing order using a temporary reg
;
        MACRO
        SortT   $lo, $hi, $temp
        SUBS    $temp, $hi, $lo
        MOVLT   $hi, $lo
        ADDLT   $lo, $lo, $temp
        MEND

;
; Macro CompSwap - Compare and sort a pair of coordinates into
;                    order of increasing Y
;                  If Y values equal, sort in order of decreasing X
;
        MACRO
        CompSwap $xl,$yl, $xh,$yh
        CMP     $yh, $yl
        EORLT   $yl, $yl, $yh
        EORLT   $yh, $yl, $yh
        EORLT   $yl, $yl, $yh
        CMPEQ   $xl, $xh
        EORLT   $xl, $xl, $xh
        EORLT   $xh, $xl, $xh
        EORLT   $xl, $xl, $xh
        MEND

;
; Macro CompSwapT - Compare and sort a pair of coordinates into
;                    order of increasing Y
;                   If Y values equal, sort in order of decreasing X
;                   Uses a temporary register
;
        MACRO
        CompSwapT $xl,$yl, $xh,$yh, $temp
        SortT   $yl, $yh, $temp
        CMPEQ   $xl, $xh
        EORLT   $xl, $xl, $xh
        EORLT   $xh, $xl, $xh
        EORLT   $xl, $xl, $xh
        MEND

;
; Macro Difference - rc := ABS(ra-rb)
;
;                    Test GE/LT for ra>=rb / ra<rb
;
        MACRO
        Difference $rc,$ra,$rb
        SUBS $rc,$ra,$rb
        RSBLT $rc,$rc,#0
        MEND

;
; Macro Least - Select the smallest value (signed)
;
        MACRO
        Least $rc,$ra,$rb
        CMP $ra,$rb
       [ $rc = $ra
       |
        MOVLE $rc,$ra
       ]
       [ $rc = $rb
       |
        MOVGT $rc,$rb
       ]
        MEND

;
; Macro Greatest - Select the largest (signed) value
;
        MACRO
        Greatest $rc,$ra,$rb
        CMP $ra,$rb
       [ $rc = $ra
       |
        MOVGE $rc,$ra
       ]
       [ $rc = $rb
       |
        MOVLT $rc,$rb
       ]
        MEND

;
; Macro PackXtnd - pack 2 bytes into 1 word and sign extend
;

        MACRO
        PackXtnd $result,$hi,$lo
        [ $lo = $result
          ADD $result,$lo,$hi,LSL #8
          MOV $result,$result,LSL #16
          MOV $result,$result,ASR #16
        |
          MOV $result,$hi,LSL #24
          ORR $result,$lo,$result,ASR #16
        ]
        MEND

        MACRO
        LoadCoordPair   $x, $y, $basereg, $offset
    [ NoARMv4 :LOR: (($offset :AND: 1)=1)
      [ NoARMv6 :LOR: NoUnaligned
        ASSERT  $x < $y
        [ ($offset) :AND: 3 = 2
          ADD   $x, $basereg, #($offset)-2
          LDMIA $x, {$x, $y}                ; (Xh,Xl,??,??) (??,??,Yh,Yl)
          MOV   $x, $x, ASR #16             ; (Xs,Xs,Xh,Xl)
          [ NoARMv6
            MOV   $y, $y, LSL #16           ;               (Yh,Yl, 0, 0)
            MOV   $y, $y, ASR #16           ;               (Ys,Ys,Yh,Yl)
          |
            SXTH  $y, $y                    ;               (Ys,Ys,Yh,Yl)
          ]
        |
          [ ($offset) :AND: 3 = 0
            LDR   $x, [$basereg, #$offset]  ; (Yh,Yl,Xh,Xl)
          |
          [ ($offset) :AND: 3 = 1
            ADD   $x, $basereg, #($offset)-1
            LDMIA $x, {$x, $y}              ; (Yl,Xh,Xl,??) (??,??,??,Yh)
            MOV   $x, $x, LSR #8            ; ( 0,Yl,Xh,Xl)
            ORR   $x, $x, $y, LSL #24       ; (Yh,Yl,Xh,Xl)
          |
            ADD   $x, $basereg, #($offset)-3
            LDMIA $x, {$x, $y}              ; (Xl,??,??,??) (??,Yh,Yl,Xh)
            MOV   $x, $x, LSR #24           ; ( 0, 0, 0,Xl)
            ORR   $x, $x, $y, LSL #8        ; (Yh,Yl,Xh,Xl)
          ]
          ]
          MOV   $y, $x, ASR #16             ;               (Ys,Ys,Yh,Yl)
          [ NoARMv6
            MOV   $x, $x, LSL #16           ; (Xh,Xl, 0, 0)
            MOV   $x, $x, ASR #16           ; (Xs,Xs,Xh,Xl)
          |
            SXTH  $x, $x                    ; (Xs,Xs,Xh,Xl)
          ]
        ]
      |
        ; Use unaligned loads from ARMv6
        LDRSH   $x, [$basereg, #$offset]
        LDRSH   $y, [$basereg, #($offset)+2]
      ]
    |
        ; Aligned halfwords
        LDRSH   $x, [$basereg, #$offset]
        LDRSH   $y, [$basereg, #($offset)+2]
    ]
        MEND

;
; Macro SaveRetAdr - Push R14 to our pseudo stack
;
        MACRO
        SaveRetAdr
        Push    R14
        MEND

;
; Macro Return - Pull from stack into PC
;
        MACRO
        Return $cond
        LDR$cond PC, [StkPtr], #4
        MEND

;
; Macro SuperMode - Set supervisor mode
;
        MACRO
        SuperMode
        SWI &16
        MEND

;
; Macro WINDow - Compare coordinate against graphics window
;
;                Test GE/LT for within/outside window
;
        MACRO
        WINDow $rx,$ry, $rl,$rb,$rr,$rt
; ASSERT ($rl < $rb) AND ($rb < $rr) AND ($rr < $rt)
        ADD $rt,WsPtr,#GWLCol
        LDMIA $rt,{$rl,$rb,$rr,$rt}
        CMP $rx,$rl
        CMPGE $rr,$rx
        CMPGE $ry,$rb
        CMPGE $rt,$ry
        MEND

;
; Macro WindowRes - Window a coordinate, giving status word
;
;           Result word is as follows:
;
;                |      |
;           1001 | 1000 | 1010
;                |      |
;           -----+------+----- GWTRow
;                |      |
;           0001 | 0000 | 0010
;                |      |
;           -----+------+----- GWBRow
;                |      |
;           0101 | 0100 | 0110
;                |      |
;
;              GWLCol GWRCol
;
;
        MACRO
        WindowRes $result, $rx,$ry, $rl,$rb,$rr,$rt
; ASSERT ($rl < $rb) AND ($rb < $rr) AND ($rr < $rt)
        MOV $result,#0
        ADD $rt,WsPtr,#GWLCol
        LDMIA $rt,{$rl,$rb,$rr,$rt}
        CMP $rx,$rl
        ORRLT $result,$result,#1        ;Set bit 0 if X < window
        CMP $rr,$rx
        ORRLT $result,$result,#2        ;Set bit 1 if X > window
        CMP $ry,$rb
        ORRLT $result,$result,#4        ;Set bit 2 if Y < window
        CMP $rt,$ry
        ORRLT $result,$result,#8        ;Set bit 3 if Y > window
        MEND

        MACRO
$lab    EQUB    $var
        ASSERT  $var >= &00
        ASSERT  $var <= &FF
$lab    =       $var
        MEND

        MACRO
        OrrEor $d,$s, $or,$eor
        ORR $d,$s,$or
        EOR $d,$d,$eor
        MEND


        MACRO                           ;Scr:=ScrOR(oraANDmsk)EOR(eorANDmsk)
        OrrEorMASK $scr,$msk, $ora,$eor, $tmp
        AND $tmp,$msk,$ora
        ORR $scr,$scr,$tmp
        AND $tmp,$msk,$eor
        EOR $scr,$scr,$tmp
        MEND


        MACRO
        ORoreorEORoreor  $d,$s, $oo,$eo,$oe,$ee, $tmp
        OrrEor $tmp,$s, $oo,$eo
        ORR $d,$d,$tmp
        OrrEor $tmp,$s, $oe,$ee
        EOR $d,$d,$tmp
        MEND


        MACRO
        ORoreorEORoreorMASK  $d,$s,$m, $oo,$eo,$oe,$ee, $tmp
        OrrEor $tmp,$s, $oo,$eo
        AND $tmp,$tmp,$m
        ORR $d,$d,$tmp
        OrrEor $tmp,$s, $oe,$ee
        AND $tmp,$tmp,$m
        EOR $d,$d,$tmp
        MEND


        MACRO
        ShiftR $d,$e, $r,$rcomp
        MOV $d,$d,LSR $r
        ORR $d,$d,$e,LSL $rcomp
        MEND

        MACRO
        ShiftL $d,$e, $r,$rcomp
        MOV $e,$e,LSL $rcomp
        ORR $e,$e,$d,LSR $r
        MEND


        MACRO
        BitLOffset $b,$x, $xshftfactor,$npix,$log2bpc
        AND $b,$x,$npix
        MOV $b,$b,LSL $log2bpc
        MEND


        MACRO
        BitROffset $b,$x, $xshftfactor,$npix,$log2bpc
        AND $b,$x,$npix
        ADD $b,$b,#1
        MOV $b,$b,LSL $log2bpc
        SUB $b,$b,#1
        MEND


        MACRO
        WordOffset $w,$x, $xshftfactor,$npix,$log2bpc
        MOV $w,$x,ASR $xshftfactor
        MEND


        MACRO
        OffsetWordAndBit $o,$b,$x,$tmp
        LDR $tmp,[WsPtr,#XShftFactor]
        MOV $o,$x,ASR $tmp                      ;Word offset into scanline
        LDR $tmp,[WsPtr,#NPix]
        AND $b,$x,$tmp                          ;Pixel offset into word
        LDR $tmp,[WsPtr,#Log2BPC]
        MOV $b,$b,LSL $tmp                      ;Bit offset into word
        MEND


        MACRO
$label  ErrorMsg $num,$string
$label  DCD $num
        DCB "$string", 0
        ALIGN
        MEND

;
; Macro when given a register will return the state to indicate
; if we are in a graphics mode.  Originally lots of code used to simply
; load NPix and look for a null parameter (fair enough in 1-8 bit per pixel)
; but now we look at the mode flags, the choice of a new generation!
;
        MACRO
$label  GraphicsMode $scrap
$label  LDR     $scrap, [WsPtr, #ModeFlags]
        TST     $scrap, #ModeFlag_NonGraphic            ;NE then non-graphic mode!
        MEND

        END
@


4.7
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@d54 34
@


4.6
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d35 6
a51 3
 [ VIDC_Type = "VIDC20"

; Registers
a52 1
VIDCPalAddress          *       &10000000       ; used in palette programming
d54 1
a54 2
LCDOffsetRegister0      *       &30000000
LCDOffsetRegister1      *       &31000000
a55 151
HorizCycle              *       &80000000
HorizSyncWidth          *       &81000000
HorizBorderStart        *       &82000000
HorizDisplayStart       *       &83000000
HorizDisplayEnd         *       &84000000
HorizBorderEnd          *       &85000000
HorizCursorStart        *       &86000000       ; used in pointer programming
HorizInterlace          *       &87000000

VertiCycle              *       &90000000
VertiSyncWidth          *       &91000000       ; Needed to set up FSIZE register in IOMD
VertiBorderStart        *       &92000000       ; First register affected by *TV
VertiDisplayStart       *       &93000000
VertiDisplayEnd         *       &94000000
VertiBorderEnd          *       &95000000
VertiCursorStart        *       &96000000
VertiCursorEnd          *       &97000000       ; Last register affected by *TV

VIDCExternal            *       &C0000000
VIDCFSyn                *       &D0000000
VIDCControl             *       &E0000000
VIDCDataControl         *       &F0000000

; Pseudo-registers used to return additional information to kernel

PseudoRegisters         *       5               ; number of pseudo-register entries at end of table

PseudoRegister_HClockSpeed *    &FB000000       ; used to indicate VIDC hclock speed (and use it)
PseudoRegister_ClockSpeed *     &FC000000       ; used to indicate real VIDC rclock speed
PseudoRegister_DPMSState *      &FD000000       ; used to return desired DPMS state
 [ ChrontelSupport
PseudoRegister_PixelRate *      &FE000000       ; used to indicate the required pixel rate
 ]


; Bits in VCSR, VCER
CursorSinglePanel	*	0 :SHL: 13
CursorTopPanel		*	1 :SHL: 13
CursorBottomPanel	*	1 :SHL: 14
CursorStraddle		*	3 :SHL: 13


; Bits in external register

Ext_HSYNCbits   *       3 :SHL: 16
Ext_InvertHSYNC *       1 :SHL: 16
Ext_CompHSYNC   *       2 :SHL: 16
Ext_InvertCompHSYNC *   3 :SHL: 16
Ext_VSYNCbits   *       3 :SHL: 18
Ext_InvertVSYNC *       1 :SHL: 18
Ext_CompVSYNC   *       2 :SHL: 18
Ext_InvertCompVSYNC *   3 :SHL: 18
Ext_HiResMono   *       1 :SHL: 14
Ext_LCDGrey     *       1 :SHL: 13
Ext_DACsOn      *       1 :SHL: 12
Ext_PedsOn      *       7 :SHL: 8
Ext_PedsShift   *       8
Ext_ERegShift   *       4
Ext_ECKOn       *       1 :SHL: 2
Ext_ERegBits    *       3 :SHL: 0
Ext_ERegRed     *       0 :SHL: 0
Ext_ERegGreen   *       1 :SHL: 0
Ext_ERegBlue    *       2 :SHL: 0
Ext_ERegExt     *       3 :SHL: 0       ; use this for lowest power

; Bits in Frequency Synthesizer Register

FSyn_VShift     *       8
FSyn_RShift     *       0
FSyn_ClearV     *       1 :SHL: 15
FSyn_ForceLow   *       1 :SHL: 14
FSyn_ClearR     *       1 :SHL: 7
FSyn_ForceHigh  *       1 :SHL: 6

FSyn_ResetValue *       FSyn_ClearV :OR: FSyn_ClearR :OR: FSyn_ForceLow :OR: (63 :SHL: FSyn_RShift) :OR: (0 :SHL: FSyn_VShift)           ; value to get PLL working properly

; Bits in Control Register

CR_DualPanel    *       1 :SHL: 13
CR_Interlace    *       1 :SHL: 12
CR_FIFOLoadShift *      8
CR_LBPP0        *       0 :SHL: 5
CR_LBPP1        *       1 :SHL: 5
CR_LBPP2        *       2 :SHL: 5
CR_LBPP3        *       3 :SHL: 5
CR_LBPP4        *       4 :SHL: 5
CR_LBPP5        *       6 :SHL: 5 ; spot the gap!
CR_PixelDivShift *      2
CR_VCLK         *       0 :SHL: 0
CR_HCLK         *       1 :SHL: 0
CR_RCLK         *       2 :SHL: 0

; Bits in Data Control Register

DCR_VRAMOff     *       0 :SHL: 18
DCR_VRAMDiv1    *       1 :SHL: 18
DCR_VRAMDiv2    *       2 :SHL: 18
DCR_VRAMDiv4    *       3 :SHL: 18
DCR_BusBits     *       3 :SHL: 16
DCR_Bus31_0     *       1 :SHL: 16
DCR_Bus63_32    *       2 :SHL: 16
DCR_Bus63_0     *       3 :SHL: 16
DCR_HDis        *       1 :SHL: 13
DCR_Sync        *       1 :SHL: 12
DCR_HDWRShift   *       0

 |

; Registers
                                                                                                                                                                                                     
HorizDisplayStart       *       &8C000000       ; used in mode change code
HorizCursorStart        *       &98000000       ; used in pointer programming

VertiBorderStart        *       &A8000000       ; First register affected by *TV
VertiDisplayStart       *       &AC000000
VertiCursorStart        *       &B8000000
VertiCursorEnd          *       &BC000000       ; Last register affected by *TV

SoundFrequency          *       &C0000000
VIDCControl             *       &E0000000

; Bits in control register

CR_Interlace            *       &40             ; 0 - no interlace, 64 - interlace
CompSync        *       &80     ; Controls sync signal on CS/VS pin
                                ; 0 - output vertical sync, 128 - composite sync.
; Other bits

SupBit          *       &1000   ; Supremacy bit in palette
 ]

PhysCursorStartAdr * CursorSoundPhysRAM

; Reason codes for generalised DAG interface - independent of MEMC type

MEMCDAG_VInit   *       0
MEMCDAG_VStart  *       1
MEMCDAG_VEnd    *       2
MEMCDAG_CInit   *       3

MEMCDAG_MaxReason *     3

 [ ModeSelectors

; OS_ScreenMode reason codes

ScreenModeReason_SelectMode             *       0
ScreenModeReason_ReturnMode             *       1
ScreenModeReason_EnumerateModes         *       2
ScreenModeReason_SelectMonitorType      *       3
ScreenModeReason_Limit                  *       4
a56 1
; Mode selector format
d58 2
d61 20
a80 16
ModeSelector_Flags      #       4       ; flags word
ModeSelector_XRes       #       4       ; x-resolution in pixels
ModeSelector_YRes       #       4       ; y-resolution in pixels
ModeSelector_PixelDepth #       4       ; pixel depth (=Log2BPP)
ModeSelector_FrameRate  #       4       ; nominal frame rate (in Hz)
ModeSelector_ModeVars   #       0       ; start of pairs of (mode var index, value)

ModeSelectorFlags_FormatMask    *       &FF
ModeSelectorFlags_ValidFormat   *       1

ModeSelector_MaxSize    *       ModeSelector_ModeVars+(NumModeVars * 8)+4
                                        ; maximum size of a mode selector, with each mode variable overridden
                                        ; plus terminator on end

 ]

d82 1
d203 2
d210 6
a215 2
          MOV   $y, $y, LSL #16             ;               (Yh,Yl, 0, 0)
          MOV   $y, $y, ASR #16             ;               (Ys,Ys,Yh,Yl)
d233 6
a238 2
          MOV   $x, $x, LSL #16             ; (Xh,Xl, 0, 0)
          MOV   $x, $x, ASR #16             ; (Xs,Xs,Xh,Xl)
d240 10
d265 1
a265 1
        LDM$cond.FD StkPtr!, {PC}
d433 1
a433 1
        TST     $scrap, #Flag_NonGraphic                ;NE then non-graphic mode!
@


4.6.2.1
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@d46 139
@


4.6.2.2
log
@further kernel/HAL split work in video area
almost-HAL code for VIDC20/IOMD in vdu.vduhint, now almost divorced
from kernel workspace
tested briefly in Ursula desktop environment

Version 5.35, 4.79.2.4. Tagged as 'Kernel-5_35-4_79_2_4'
@
text
@d49 1
a49 1
; Reason codes for generalised DAG interface
d51 4
a54 3
HALDAG_VInit   *       0
HALDAG_VStart  *       1
HALDAG_VEnd    *       2
d56 1
@


4.6.2.3
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a34 3
        GBLL AvoidScreenReads           ; When TRUE, use extra code to avoid
AvoidScreenReads      SETL {TRUE}       ; reading the screen when we can avoid it

@


4.6.2.4
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@a56 1
HALDAG_VRender *       3
@


4.6.2.5
log
@* HAL can choose to limit amount of screen memory to allocate
  [Not fully implemented - for now leaves at least 16MB free if only
  one RAM area; was 1MB].
* Added HAL_USBControllerInfo, HAL_MonitorLeadID and HAL_Video_Render.
* Added HAL->OS call OS_IICOpV.
* OS_MMUControl now allows independent control of I and C bits.
* Added facility to deactivate keyboard debounce (magic word "NoKd" in
  R2 in KeyV 0).
* Fixed problem with RAM amounts not a multiple of 4MB.
* Supremacy bit (in VDU 19) now sets all 8 bits of supremacy.
* Added PaletteV 14 (reads gamma tables).
* Added Supremacy transfer functions (like gamma correction, but for
  supremacy). Allows easy global supremacy effects in a mode-independent
  fashion. Controlled with PaletteV 15,16.
* Added modes 50-53 (320x240, 1,2,4,8bpp). Intended for small LCD.
* Added 13.5kHz versions of TV modes (selected by Hdr:Machine).
* Upped desktop version to 5.06.

Version 5.35, 4.79.2.66. Tagged as 'Kernel-5_35-4_79_2_66'
@
text
@a37 3
        GBLL DefaultSupremacy           ; When TRUE, 16bpp and 32bpp modes' default
DefaultSupremacy      SETL {FALSE}      ; palettes use top bits for supremacy

a87 14

; Layout of palette space
PalEntries              *       256+1+3
                        ^       0
Pal_Blank               #       PalEntries*4    ; Blank palette (for screen saver)
Pal_LogFirst            #       PalEntries*4    ; Logical palette (as read/written by user)
Pal_LogSecond           #       PalEntries*4
Pal_PhysFirst           #       PalEntries*4    ; Physical palette (post transfer function)
Pal_PhysSecond          #       PalEntries*4
Pal_RTable              #       256             ; Logical->physical lookup tables for R,G,B,S
Pal_GTable              #       256
Pal_BTable              #       256
Pal_STable              #       256
Pal_Blocksize           #       0
@


4.6.2.6
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@a226 1
      [ NoARMv6 :LOR: NoUnaligned
a253 5
      |
        ; Use unaligned loads from ARMv6
        LDRSH   $x, [$basereg, #$offset]
        LDRSH   $y, [$basereg, #($offset)+2]
      ]
d269 1
a269 1
        LDR$cond PC, [StkPtr], #4
@


4.6.2.7
log
@Improve heap manager. Add heap testbed. Add dummy implementation of some OS_ScreenMode reason codes.
Detail:
  s/HeapMan, hdr/KernelWS - Heap manager improvements:
    - Errors generated by interrupted heap operations that are forced to complete by a OS_Heap call from the background are now cached in kernel workspace until the foreground task is resumed. This prevents them from being potentially overwritten by MessageTrans running out of background error buffers.
    - Added new OS_Heap reason code, #7 - Get area aligned. This allows areas of memory to be allocated at specific (power-of-2) alignments, and optionally without crossing a given (power-of-2) boundary. Alignment & boundary calculations are performed using logical addresses.
    - Removed the limitation that all free and allocated blocks must be a multiple of 8 bytes in length. This change was required in order to allow OS_Heap 7 to function correctly. Now the only requirements are that blocks must be multiples of 4 bytes in length, at 4 byte alignment, with a minimum length of 8 bytes. 4 extra padding bytes may still be added to the end of allocations in order to avoid creating 4-byte free blocks.
  s/HeapMan, TestSrc/HeapTest/Makefile, TestSrc/HeapTest/c/testbed, TestSrc/HeapTest/s/asm - Added heap testbed program. Can either use the OS_Heap SWI or directly include a copy of the Kernel's heap manager sources.
  s/vdudecl, s/vduswis - Added dummy implementations of OS_ScreenMode 4, 5 and 6. This prevents the Wimp generating lots of "Unknown OS_ScreenMode reason code" errors when redrawing the screen.
  s/Arthur3, s/Oscli - Moved dotstring closer to where it's used to avoid "ADRL out of range" errors in Tungsten build
Admin:
  Tested in OMAP3 ROM & Tungsten ROM softload.
  Heap testbed successfully performed over 400 million heap ops, so there shouldn't be any serious bugs in the new code (touch wood)


Version 5.35, 4.79.2.128. Tagged as 'Kernel-5_35-4_79_2_128'
@
text
@d71 1
a71 4
ScreenModeReason_ConfigureAcceleration  *       4
ScreenModeReason_CleanCache             *       5
ScreenModeReason_ForceCleanCache        *       6
ScreenModeReason_Limit                  *       7
@


4.6.2.8
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d63 32
d446 1
a446 1
        TST     $scrap, #ModeFlag_NonGraphic            ;NE then non-graphic mode!
@


4.6.2.9
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d57 4
a76 9
; GraphicsV driver state
; For each allocated driver number, the corresponding word of GraphicsVDrivers
; points to an instance of the following structure:

                            ^   0
GVDriver_RegisterFlags      #   4        ; Flags on registration
GVDriver_Name               #   4        ; Name on registration
GVDriver_StateFlags         #   4        ; Current state flags
GVDriver_Size               #   0
a77 1
GVDriverState_Started       *   1:SHL:0  ; ScreenMode_StartDriver called
@


4.6.2.10
log
@Fix PreCreateHeader to allow palettes for <=256 colour RISC OS 5 sprites. LoadCoordPair tweaks.
Detail:
  s/vdu/vdudecl - Add a couple more optimisations to LoadCoordPair - use SXTH where possible, and use LDRSH if data is halfword aligned (not currently the case, but may be in future)
  s/vdu/vdugrafj - Fix PreCreateHeader to allow <=256 colour RISC OS 5 sprites to have palettes
Admin:
  Tested on Pandaboard


Version 5.35, 4.79.2.238. Tagged as 'Kernel-5_35-4_79_2_238'
@
text
@a203 1
    [ NoARMv4 :LOR: (($offset :AND: 1)=1)
d210 2
a211 6
          [ NoARMv6
            MOV   $y, $y, LSL #16           ;               (Yh,Yl, 0, 0)
            MOV   $y, $y, ASR #16           ;               (Ys,Ys,Yh,Yl)
          |
            SXTH  $y, $y                    ;               (Ys,Ys,Yh,Yl)
          ]
d229 2
a230 6
          [ NoARMv6
            MOV   $x, $x, LSL #16           ; (Xh,Xl, 0, 0)
            MOV   $x, $x, ASR #16           ; (Xs,Xs,Xh,Xl)
          |
            SXTH  $x, $x                    ; (Xs,Xs,Xh,Xl)
          ]
a236 5
    |
        ; Aligned halfwords
        LDRSH   $x, [$basereg, #$offset]
        LDRSH   $y, [$basereg, #($offset)+2]
    ]
@


4.6.2.11
log
@Replace WriteBuffer_Drain ARMop with a suite of memory barrier ARMops
Detail:
  - Docs/HAL/ARMop_API - Updated with documentation for the new ARMops.
  - s/ARMops - Set up pointers for the new memory barrier ARMops. Add full implementations for ARMv6 & ARMv7; older architectures should be able to get by with a mix of null ops & write buffer drain ops. Update ARMopPtrTable to validate structure against the list in hdr/OSMisc
  - hdr/KernelWS - Reserve workspace for new ARMops. Free up a bit of space by limiting ourselves to 2 cache levels with ARMv7. Remove some unused definitions.
  - hdr/OSMisc - New header defining OS_PlatformFeatures & OS_MMUControl reason codes, OS_PlatformFeatures 0 flags, and OS_MMUControl 2 ARMop indices
  - Makefile - Add export rules for OSMisc header
  - hdr/ARMops, s/ARM600, s/VMSAv6 - Remove CPUFlag_* and MMUCReason_* definitions. Update OS_MMUControl write buffer drain to use DSB_ReadWrite ARMop (which is what most existing write buffer drain implementations have been renamed to).
  - s/GetAll - Get Hdr:OSMisc
  - s/Kernel - Use OS_PlatformFeatures reason code symbols
  - s/vdu/vdudecl - Remove unused definition
Admin:
  Tested on ARM11, Cortex-A8, Cortex-A9


Version 5.35, 4.79.2.279. Tagged as 'Kernel-5_35-4_79_2_279'
@
text
@d53 1
@


4.6.2.5.2.1
log
@  Unaligned loads/stores optimised for ARMv6+
Detail:
  Having scanned the kernel source for unaligned load code fragments which
  would abort on ARMv6 and v7 and not having found any, I took the opportunity
  to give them build-time switches to use unaligned LDR((S)H)/STR(H)
  instructions if built for a new enough platform. Also added a couple of
  cases of LDRSB that will benefit v4 CPUs and a few instances of the v6
  SXTH instruction, but since objasm doesn't yet understand it (and when it
  does, not everyone will have upgraded) they are currently written as
  DCI statements.
  Most of the changes are to OS_Word handlers, which are notorious in that
  their input/output block is not word-aligned.
Admin:
  Not tested, but it should at least build.

Version 5.35, 4.79.2.98.2.6. Tagged as 'Kernel-5_35-4_79_2_98_2_6'
@
text
@a226 1
      [ NoARMv6
a253 5
      |
        ; Use unaligned loads from ARMv6
        LDRSH   $x, [$basereg, #$offset]
        LDRSH   $y, [$basereg, #($offset)+2]
      ]
@


4.6.2.5.2.2
log
@  Miscellaneous v6-related updates
Detail:
 * Stopped calling the broken abort fixup code when running under VMSAv6.
   Might be desirable to update it, possibly farmed out to a separate module -
   still need to think about this.
 * Unaligned load optimisations can now be disabled by the global NoUnaligned
   flag for testing purposes.
 * Extended OS_ReadUnsigned to permit reading of 64-bit unsigned integers.
   See Docs.ReadUnsigned for more details. Also sped it up by using MLA
   (or UMLAL) for most digits rather than repeated addition.
 * Bugfix is OS_GSRead: an uninitialised r0 was being passed to
   OS_ReadUnsigned, causing undesirable effects on rare occasions.
Admin:
  Tested on a rev B7 beagleboard.

Version 5.35, 4.79.2.98.2.8. Tagged as 'Kernel-5_35-4_79_2_98_2_8'
@
text
@d227 1
a227 1
      [ NoARMv6 :LOR: NoUnaligned
@


4.6.2.5.2.3
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d275 1
a275 1
        LDR$cond PC, [StkPtr], #4
@


4.5
log
@Was erroneously programming a pseudo-register into VIDC.

Version 4.87. Tagged as 'Kernel-4_87'
@
text
@a400 9
; Macro UserMode - Return to user mode
;
        MACRO
        UserMode
        TEQP PC,#0        ; Return to user mode
        MOV R0,R0         ; Force a NOP so it works
        MEND

;
@


4.4
log
@Default RCLK mode now RCLK/2 rather than RCLK/1.
Doesn't force CMOS setting of sync and monitortype on NCs/STBs.
Accepts HClockSelect parameter (number 9) in VIDC lists. Uses this to
determine whether to use HCLK or not, rather than abusing
Service_MonitorLeadTranslation.
If DontUseVCO flag is set, then VCLK will not be used - only RCLK (or HCLK if
requested).

Version 4.86. Tagged as 'Kernel-4_86'
@
text
@d80 2
@


4.3
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d80 1
@


4.2
log
@Kernel merged
@
text
@d82 3
@


4.2.2.1
log
@Added following enhancements:

 - Chocolate screen mapping (section mapped and cached), StrongARM only
   Phoebe h/w (IOMD 2) will have register to assist this, but code currently
   relies on data abort mechanism to keep screen up to date wrt write-back
   data cache.

 - Chocolate AMBControl task switching (lazy page mapping), StrongARM only
   Improves task swapping speed. There appears to be a StrongAEM silicon
   bug rev 2 and 3) which means that LDMIB rn, {regs includind rn} cannot
   be reliably restarted after a data abort. This stuffs Chocolate AMBControl
   (awaiting response from Digital).

Both enhancements need more work to complete for Phoebe. Chocolate AMBControl
may well have to be made dormant because of silicon bug.

Note that this kernel *will* cause problems with task switching on StrongARM,
unless Chocolate task switching is disabled via !Flavour application.
@
text
@a198 6
  [ ChocolateScreen
ScreenModeReason_ChocolateControl       *       4  ;control chocolate flavour screen
ScreenModeReason_ChocolateUpdate        *       5  ;ensure chocolate flavour screen up to date, if not suspended
ScreenModeReason_ChocolateForceUpdate   *       6  ;force chocolate flavour screen up to date, even if suspended
ScreenModeReason_Limit                  *       7
  |
a199 1
  ]
@


4.2.2.2
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d156 22
d191 1
d225 1
@


4.2.2.2.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d46 1
d155 2
@


4.2.2.3
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d46 1
d155 2
@


4.1
log
@Initial revision
@
text
@d84 7
d158 1
a158 1
                                                                                                                                                                                                             
d393 1
a393 1
  
d556 1
a556 1
;                                                                   
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Added SWI OS_VIDCDivider, and vdu variable PixelRate for better video mode
support.  Fixed to build for Risc PC.
@
text
@d82 1
a82 3
 [ ChrontelSupport
PseudoRegister_PixelRate *      &FE000000       ; used to indicate the required pixel rate
 ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a83 7
; Bits in VCSR, VCER
CursorSinglePanel	*	0 :SHL: 13
CursorTopPanel		*	1 :SHL: 13
CursorBottomPanel	*	1 :SHL: 14
CursorStraddle		*	3 :SHL: 13


d151 1
a151 1
                                                                                                                                                                                                     
d386 1
a386 1

d549 1
a549 1
;
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.6;
access;
symbols
	Kernel-6_14:4.6
	Kernel-6_01-3:4.6
	Kernel-6_13:4.6
	Kernel-6_12:4.6
	Kernel-6_11:4.6
	Kernel-6_10:4.6
	Kernel-6_09:4.6
	Kernel-6_08-4_129_2_10:4.6
	Kernel-6_08-4_129_2_9:4.6
	Kernel-6_08:4.6
	Kernel-6_07:4.6
	Kernel-6_06:4.6
	Kernel-6_05-4_129_2_8:4.6
	Kernel-6_05:4.6
	Kernel-6_04:4.6
	Kernel-6_03:4.6
	Kernel-6_01-2:4.6
	Kernel-6_01-4_146_2_1:4.6
	Kernel-6_02:4.6
	Kernel-6_01-1:4.6
	Kernel-6_01:4.6
	Kernel-6_00:4.6
	Kernel-5_99:4.6
	Kernel-5_98:4.6
	Kernel-5_97-4_129_2_7:4.6
	Kernel-5_97:4.6
	Kernel-5_96:4.6
	Kernel-5_95:4.6
	Kernel-5_94:4.6
	Kernel-5_93:4.6
	Kernel-5_92:4.6
	Kernel-5_91:4.6
	Kernel-5_90:4.6
	Kernel-5_89-4_129_2_6:4.6
	Kernel-5_89:4.6
	Kernel-5_88-4_129_2_5:4.6
	Kernel-5_88-4_129_2_4:4.6
	Kernel-5_88:4.6
	Kernel-5_87:4.6
	Kernel-5_86-4_129_2_3:4.6
	Kernel-5_86-4_129_2_2:4.6
	Kernel-5_86-4_129_2_1:4.6
	Kernel-5_86:4.6
	SMP:4.6.0.2
	SMP_bp:4.6
	Kernel-5_85:4.6
	Kernel-5_54-1:4.5
	Kernel-5_84:4.6
	Kernel-5_83:4.6
	Kernel-5_82:4.6
	Kernel-5_81:4.6
	Kernel-5_80:4.6
	Kernel-5_79:4.6
	Kernel-5_78:4.6
	Kernel-5_77:4.6
	Kernel-5_76:4.6
	Kernel-5_75:4.6
	Kernel-5_74:4.5
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.5
	Kernel-5_64:4.5
	Kernel-5_63:4.5
	Kernel-5_62:4.5
	Kernel-5_61:4.5
	Kernel-5_60:4.5
	Kernel-5_59:4.5
	Kernel-5_58:4.5
	Kernel-5_57:4.5
	Kernel-5_56:4.5
	Kernel-5_55:4.5
	Kernel-5_54:4.5
	Kernel-5_53:4.5
	Kernel-5_52:4.5
	Kernel-5_51:4.5
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.3.2.1
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.3.2.1
	Kernel-5_35-4_79_2_326:4.3.2.1
	Kernel-5_35-4_79_2_325:4.3.2.1
	Kernel-5_35-4_79_2_324:4.3.2.1
	Kernel-5_35-4_79_2_323:4.3.2.1
	Kernel-5_35-4_79_2_322:4.3.2.1
	Kernel-5_35-4_79_2_321:4.3.2.1
	Kernel-5_35-4_79_2_320:4.3.2.1
	Kernel-5_35-4_79_2_319:4.3.2.1
	Kernel-5_35-4_79_2_318:4.3.2.1
	Kernel-5_35-4_79_2_317:4.3.2.1
	Kernel-5_35-4_79_2_316:4.3.2.1
	Kernel-5_35-4_79_2_315:4.3.2.1
	Kernel-5_35-4_79_2_314:4.3.2.1
	Kernel-5_35-4_79_2_313:4.3.2.1
	Kernel-5_35-4_79_2_312:4.3.2.1
	Kernel-5_35-4_79_2_311:4.3.2.1
	Kernel-5_35-4_79_2_310:4.3.2.1
	Kernel-5_35-4_79_2_309:4.3.2.1
	Kernel-5_35-4_79_2_308:4.3.2.1
	Kernel-5_35-4_79_2_307:4.3.2.1
	Kernel-5_35-4_79_2_306:4.3.2.1
	Kernel-5_35-4_79_2_305:4.3.2.1
	Kernel-5_35-4_79_2_304:4.3.2.1
	Kernel-5_35-4_79_2_303:4.3.2.1
	Kernel-5_35-4_79_2_302:4.3.2.1
	Kernel-5_35-4_79_2_301:4.3.2.1
	Kernel-5_35-4_79_2_300:4.3.2.1
	Kernel-5_35-4_79_2_299:4.3.2.1
	Kernel-5_35-4_79_2_298:4.3.2.1
	Kernel-5_35-4_79_2_297:4.3.2.1
	Kernel-5_35-4_79_2_296:4.3.2.1
	Kernel-5_35-4_79_2_295:4.3.2.1
	Kernel-5_35-4_79_2_294:4.3.2.1
	Kernel-5_35-4_79_2_293:4.3.2.1
	Kernel-5_35-4_79_2_292:4.3.2.1
	Kernel-5_35-4_79_2_291:4.3.2.1
	Kernel-5_35-4_79_2_290:4.3.2.1
	Kernel-5_35-4_79_2_289:4.3.2.1
	Kernel-5_35-4_79_2_288:4.3.2.1
	Kernel-5_35-4_79_2_287:4.3.2.1
	Kernel-5_35-4_79_2_286:4.3.2.1
	Kernel-5_35-4_79_2_285:4.3.2.1
	Kernel-5_35-4_79_2_284:4.3.2.1
	Kernel-5_35-4_79_2_283:4.3.2.1
	Kernel-5_35-4_79_2_282:4.3.2.1
	Kernel-5_35-4_79_2_281:4.3.2.1
	Kernel-5_35-4_79_2_280:4.3.2.1
	Kernel-5_35-4_79_2_279:4.3.2.1
	Kernel-5_35-4_79_2_278:4.3.2.1
	Kernel-5_35-4_79_2_277:4.3.2.1
	Kernel-5_35-4_79_2_276:4.3.2.1
	Kernel-5_35-4_79_2_275:4.3.2.1
	Kernel-5_35-4_79_2_274:4.3.2.1
	Kernel-5_35-4_79_2_273:4.3.2.1
	Kernel-5_35-4_79_2_272:4.3.2.1
	Kernel-5_35-4_79_2_271:4.3.2.1
	Kernel-5_35-4_79_2_270:4.3.2.1
	Kernel-5_35-4_79_2_269:4.3.2.1
	Kernel-5_35-4_79_2_268:4.3.2.1
	Kernel-5_35-4_79_2_267:4.3.2.1
	Kernel-5_35-4_79_2_266:4.3.2.1
	Kernel-5_35-4_79_2_265:4.3.2.1
	Kernel-5_35-4_79_2_264:4.3.2.1
	Kernel-5_35-4_79_2_263:4.3.2.1
	Kernel-5_35-4_79_2_262:4.3.2.1
	Kernel-5_35-4_79_2_261:4.3.2.1
	Kernel-5_35-4_79_2_260:4.3.2.1
	Kernel-5_35-4_79_2_259:4.3.2.1
	Kernel-5_35-4_79_2_258:4.3.2.1
	Kernel-5_35-4_79_2_257:4.3.2.1
	Kernel-5_35-4_79_2_256:4.3.2.1
	Kernel-5_35-4_79_2_255:4.3.2.1
	Kernel-5_35-4_79_2_254:4.3.2.1
	Kernel-5_35-4_79_2_253:4.3.2.1
	Kernel-5_35-4_79_2_252:4.3.2.1
	Kernel-5_35-4_79_2_251:4.3.2.1
	Kernel-5_35-4_79_2_250:4.3.2.1
	Kernel-5_35-4_79_2_249:4.3.2.1
	Kernel-5_35-4_79_2_248:4.3.2.1
	Kernel-5_35-4_79_2_247:4.3.2.1
	Kernel-5_35-4_79_2_246:4.3.2.1
	Kernel-5_35-4_79_2_245:4.3.2.1
	Kernel-5_35-4_79_2_244:4.3.2.1
	Kernel-5_35-4_79_2_243:4.3.2.1
	Kernel-5_35-4_79_2_242:4.3.2.1
	Kernel-5_35-4_79_2_241:4.3.2.1
	Kernel-5_35-4_79_2_240:4.3.2.1
	Kernel-5_35-4_79_2_239:4.3.2.1
	Kernel-5_35-4_79_2_238:4.3.2.1
	Kernel-5_35-4_79_2_237:4.3.2.1
	Kernel-5_35-4_79_2_236:4.3
	Kernel-5_35-4_79_2_235:4.3
	Kernel-5_35-4_79_2_234:4.3
	Kernel-5_35-4_79_2_233:4.3
	Kernel-5_35-4_79_2_232:4.3
	Kernel-5_35-4_79_2_231:4.3
	Kernel-5_35-4_79_2_230:4.3
	Kernel-5_35-4_79_2_229:4.3
	Kernel-5_35-4_79_2_228:4.3
	Kernel-5_35-4_79_2_227:4.3
	Kernel-5_35-4_79_2_226:4.3
	Kernel-5_35-4_79_2_225:4.3
	Kernel-5_35-4_79_2_224:4.3
	Kernel-5_35-4_79_2_223:4.3
	Kernel-5_35-4_79_2_222:4.3
	Kernel-5_35-4_79_2_221:4.3
	Kernel-5_35-4_79_2_220:4.3
	Kernel-5_35-4_79_2_219:4.3
	Kernel-5_35-4_79_2_218:4.3
	Kernel-5_35-4_79_2_217:4.3
	Kernel-5_35-4_79_2_216:4.3
	Kernel-5_35-4_79_2_215:4.3
	Kernel-5_35-4_79_2_214:4.3
	Kernel-5_35-4_79_2_213:4.3
	Kernel-5_35-4_79_2_212:4.3
	Kernel-5_35-4_79_2_211:4.3
	Kernel-5_35-4_79_2_210:4.3
	Kernel-5_35-4_79_2_209:4.3
	Kernel-5_35-4_79_2_208:4.3
	Kernel-5_35-4_79_2_207:4.3
	Kernel-5_35-4_79_2_206:4.3
	Kernel-5_35-4_79_2_205:4.3
	Kernel-5_35-4_79_2_204:4.3
	Kernel-5_35-4_79_2_203:4.3
	Kernel-5_35-4_79_2_202:4.3
	Kernel-5_35-4_79_2_201:4.3
	Kernel-5_35-4_79_2_200:4.3
	Kernel-5_35-4_79_2_199:4.3
	Kernel-5_35-4_79_2_198:4.3
	Kernel-5_35-4_79_2_197:4.3
	Kernel-5_35-4_79_2_196:4.3
	Kernel-5_35-4_79_2_195:4.3
	Kernel-5_35-4_79_2_194:4.3
	Kernel-5_35-4_79_2_193:4.3
	Kernel-5_35-4_79_2_192:4.3
	Kernel-5_35-4_79_2_191:4.3
	Kernel-5_35-4_79_2_190:4.3
	Kernel-5_35-4_79_2_189:4.3
	Kernel-5_35-4_79_2_188:4.3
	Kernel-5_35-4_79_2_187:4.3
	Kernel-5_35-4_79_2_186:4.3
	Kernel-5_35-4_79_2_185:4.3
	Kernel-5_35-4_79_2_184:4.3
	Kernel-5_35-4_79_2_183:4.3
	Kernel-5_35-4_79_2_182:4.3
	Kernel-5_35-4_79_2_181:4.3
	Kernel-5_35-4_79_2_180:4.3
	Kernel-5_35-4_79_2_179:4.3
	Kernel-5_35-4_79_2_178:4.3
	Kernel-5_35-4_79_2_177:4.3
	Kernel-5_35-4_79_2_176:4.3
	Kernel-5_35-4_79_2_175:4.3
	Kernel-5_35-4_79_2_174:4.3
	Kernel-5_35-4_79_2_173:4.3
	Kernel-5_35-4_79_2_172:4.3
	Kernel-5_35-4_79_2_171:4.3
	Kernel-5_35-4_79_2_170:4.3
	Kernel-5_35-4_79_2_169:4.3
	Kernel-5_35-4_79_2_168:4.3
	Kernel-5_35-4_79_2_167:4.3
	Kernel-5_35-4_79_2_166:4.3
	Kernel-5_35-4_79_2_165:4.3
	RPi_merge:4.3
	Kernel-5_35-4_79_2_147_2_23:4.3
	Kernel-5_35-4_79_2_147_2_22:4.3
	Kernel-5_35-4_79_2_147_2_21:4.3
	Kernel-5_35-4_79_2_147_2_20:4.3
	Kernel-5_35-4_79_2_147_2_19:4.3
	Kernel-5_35-4_79_2_147_2_18:4.3
	Kernel-5_35-4_79_2_164:4.3
	Kernel-5_35-4_79_2_163:4.3
	Kernel-5_35-4_79_2_147_2_17:4.3
	Kernel-5_35-4_79_2_147_2_16:4.3
	Kernel-5_35-4_79_2_147_2_15:4.3
	Kernel-5_35-4_79_2_162:4.3
	Kernel-5_35-4_79_2_161:4.3
	Kernel-5_35-4_79_2_147_2_14:4.3
	Kernel-5_35-4_79_2_147_2_13:4.3
	Kernel-5_35-4_79_2_160:4.3
	Kernel-5_35-4_79_2_159:4.3
	Kernel-5_35-4_79_2_158:4.3
	Kernel-5_35-4_79_2_157:4.3
	Kernel-5_35-4_79_2_156:4.3
	Kernel-5_35-4_79_2_147_2_12:4.3
	Kernel-5_35-4_79_2_147_2_11:4.3
	Kernel-5_35-4_79_2_155:4.3
	Kernel-5_35-4_79_2_147_2_10:4.3
	Kernel-5_35-4_79_2_154:4.3
	Kernel-5_35-4_79_2_153:4.3
	Kernel-5_35-4_79_2_147_2_9:4.3
	Kernel-5_35-4_79_2_152:4.3
	Kernel-5_35-4_79_2_151:4.3
	Kernel-5_35-4_79_2_147_2_8:4.3
	Kernel-5_35-4_79_2_147_2_7:4.3
	Kernel-5_35-4_79_2_150:4.3
	Kernel-5_35-4_79_2_147_2_6:4.3
	Kernel-5_35-4_79_2_147_2_5:4.3
	Kernel-5_35-4_79_2_149:4.3
	Kernel-5_35-4_79_2_147_2_4:4.3
	Kernel-5_35-4_79_2_147_2_3:4.3
	Kernel-5_35-4_79_2_148:4.3
	Kernel-5_35-4_79_2_147_2_2:4.3
	Kernel-5_35-4_79_2_147_2_1:4.3
	RPi:4.3.0.10
	RPi_bp:4.3
	Kernel-5_35-4_79_2_98_2_52_2_1:4.3
	alees_Kernel_dev:4.3.0.8
	alees_Kernel_dev_bp:4.3
	Kernel-5_35-4_79_2_147:4.3
	Kernel-5_35-4_79_2_146:4.3
	Kernel-5_35-4_79_2_145:4.3
	Kernel-5_35-4_79_2_144:4.3
	Kernel-5_35-4_79_2_143:4.3
	Kernel-5_35-4_79_2_142:4.3
	Kernel-5_35-4_79_2_141:4.3
	Kernel-5_35-4_79_2_140:4.3
	Kernel-5_35-4_79_2_139:4.3
	Kernel-5_35-4_79_2_138:4.3
	Kernel-5_35-4_79_2_137:4.3
	Kernel-5_35-4_79_2_136:4.3
	Kernel-5_35-4_79_2_135:4.3
	Kernel-5_35-4_79_2_134:4.3
	Kernel-5_35-4_79_2_133:4.3
	Kernel-5_35-4_79_2_132:4.3
	Kernel-5_35-4_79_2_131:4.3
	Kernel-5_35-4_79_2_130:4.3
	Kernel-5_35-4_79_2_129:4.3
	Kernel-5_35-4_79_2_128:4.3
	Kernel-5_35-4_79_2_127:4.3
	Kernel-5_35-4_79_2_126:4.3
	Kernel-5_35-4_79_2_125:4.3
	Kernel-5_35-4_79_2_124:4.3
	Kernel-5_35-4_79_2_123:4.3
	Cortex_merge:4.3
	Kernel-5_35-4_79_2_122:4.3
	Kernel-5_35-4_79_2_98_2_54:4.3
	Kernel-5_35-4_79_2_98_2_53:4.3
	Kernel-5_35-4_79_2_98_2_52:4.3
	Kernel-5_35-4_79_2_98_2_51:4.3
	Kernel-5_35-4_79_2_98_2_50:4.3
	Kernel-5_35-4_79_2_98_2_49:4.3
	Kernel-5_35-4_79_2_98_2_48:4.3
	Kernel-5_35-4_79_2_121:4.3
	Kernel-5_35-4_79_2_98_2_47:4.3
	Kernel-5_35-4_79_2_120:4.3
	Kernel-5_35-4_79_2_98_2_46:4.3
	Kernel-5_35-4_79_2_119:4.3
	Kernel-5_35-4_79_2_98_2_45:4.3
	Kernel-5_35-4_79_2_98_2_44:4.3
	Kernel-5_35-4_79_2_118:4.3
	Kernel-5_35-4_79_2_98_2_43:4.3
	Kernel-5_35-4_79_2_117:4.3
	Kernel-5_35-4_79_2_116:4.3
	Kernel-5_35-4_79_2_98_2_42:4.3
	Kernel-5_35-4_79_2_115:4.3
	Kernel-5_35-4_79_2_98_2_41:4.3
	Kernel-5_35-4_79_2_98_2_40:4.3
	Kernel-5_35-4_79_2_114:4.3
	Kernel-5_35-4_79_2_98_2_39:4.3
	Kernel-5_35-4_79_2_98_2_38:4.3
	Kernel-5_35-4_79_2_113:4.3
	Kernel-5_35-4_79_2_112:4.3
	Kernel-5_35-4_79_2_98_2_37:4.3
	Kernel-5_35-4_79_2_98_2_36:4.3
	Kernel-5_35-4_79_2_98_2_35:4.3
	Kernel-5_35-4_79_2_98_2_34:4.3
	Kernel-5_35-4_79_2_98_2_33:4.3
	Kernel-5_35-4_79_2_98_2_32:4.3
	Kernel-5_35-4_79_2_98_2_31:4.3
	Kernel-5_35-4_79_2_98_2_30:4.3
	Kernel-5_35-4_79_2_98_2_29:4.3
	Kernel-5_35-4_79_2_98_2_28:4.3
	Kernel-5_35-4_79_2_98_2_27:4.3
	Kernel-5_35-4_79_2_98_2_26:4.3
	Kernel-5_35-4_79_2_111:4.3
	Kernel-5_35-4_79_2_98_2_25:4.3
	Kernel-5_35-4_79_2_98_2_24:4.3
	Kernel-5_35-4_79_2_98_2_23:4.3
	Kernel-5_35-4_79_2_110:4.3
	Kernel-5_35-4_79_2_98_2_22:4.3
	Kernel-5_35-4_79_2_109:4.3
	Kernel-5_35-4_79_2_98_2_21:4.3
	Kernel-5_35-4_79_2_98_2_20:4.3
	Kernel-5_35-4_79_2_108:4.3
	Kernel-5_35-4_79_2_107:4.3
	Kernel-5_35-4_79_2_98_2_19:4.3
	Kernel-5_35-4_79_2_98_2_18:4.3
	Kernel-5_35-4_79_2_98_2_17:4.3
	Kernel-5_35-4_79_2_98_2_16:4.3
	Kernel-5_35-4_79_2_98_2_15:4.3
	Kernel-5_35-4_79_2_106:4.3
	Kernel-5_35-4_79_2_105:4.3
	Kernel-5_35-4_79_2_104:4.3
	Kernel-5_35-4_79_2_98_2_14:4.3
	Kernel-5_35-4_79_2_98_2_13:4.3
	Kernel-5_35-4_79_2_98_2_12:4.3
	Kernel-5_35-4_79_2_98_2_11:4.3
	Kernel-5_35-4_79_2_98_2_10:4.3
	Kernel-5_35-4_79_2_98_2_9:4.3
	Kernel-5_35-4_79_2_103:4.3
	Kernel-5_35-4_79_2_102:4.3
	Kernel-5_35-4_79_2_98_2_8:4.3
	Kernel-5_35-4_79_2_98_2_7:4.3
	Kernel-5_35-4_79_2_98_2_6:4.3
	Kernel-5_35-4_79_2_98_2_5:4.3
	Kernel-5_35-4_79_2_98_2_4:4.3
	Kernel-5_35-4_79_2_101:4.3
	Kernel-5_35-4_79_2_100:4.3
	Kernel-5_35-4_79_2_99:4.3
	Kernel-5_35-4_79_2_98_2_3:4.3
	Kernel-5_35-4_79_2_98_2_2:4.3
	Kernel-5_35-4_79_2_98_2_1:4.3
	Cortex:4.3.0.4
	Cortex_bp:4.3
	Kernel-5_35-4_79_2_98:4.3
	Kernel-5_35-4_79_2_97:4.3
	Kernel-5_35-4_79_2_96:4.3
	Kernel-5_35-4_79_2_95:4.3
	Kernel-5_35-4_79_2_94:4.3
	Kernel-5_35-4_79_2_93:4.3
	Kernel-5_35-4_79_2_92:4.3
	Kernel-5_35-4_79_2_91:4.3
	Kernel-5_35-4_79_2_90:4.3
	Kernel-5_35-4_79_2_89:4.3
	Kernel-5_35-4_79_2_88:4.3
	Kernel-5_35-4_79_2_87:4.3
	Kernel-5_35-4_79_2_86:4.3
	Kernel-5_35-4_79_2_85:4.3
	Kernel-5_35-4_79_2_84:4.3
	Kernel-5_35-4_79_2_83:4.3
	Kernel-5_35-4_79_2_82:4.3
	Kernel-5_35-4_79_2_81:4.3
	Kernel-5_35-4_79_2_80:4.3
	Kernel-5_35-4_79_2_79:4.3
	Kernel-5_35-4_79_2_78:4.3
	Kernel-5_35-4_79_2_77:4.3
	RO_5_07:4.3
	Kernel-5_35-4_79_2_76:4.3
	Kernel-5_35-4_79_2_75:4.3
	Kernel-5_35-4_79_2_74:4.3
	Kernel-5_35-4_79_2_73:4.3
	Kernel-5_35-4_79_2_72:4.3
	Kernel-5_35-4_79_2_71:4.3
	Kernel-5_35-4_79_2_70:4.3
	Kernel-5_35-4_79_2_69:4.3
	Kernel-5_35-4_79_2_68:4.3
	Kernel-5_35-4_79_2_67:4.3
	Kernel-5_35-4_79_2_66:4.3
	Kernel-5_35-4_79_2_65:4.3
	Kernel-5_35-4_79_2_64:4.3
	Kernel-5_35-4_79_2_63:4.3
	Kernel-5_35-4_79_2_62:4.3
	Kernel-5_35-4_79_2_61:4.3
	Kernel-5_35-4_79_2_59:4.3
	Kernel-5_35-4_79_2_58:4.3
	Kernel-5_35-4_79_2_57:4.3
	Kernel-5_35-4_79_2_56:4.3
	Kernel-5_35-4_79_2_55:4.3
	Kernel-5_35-4_79_2_54:4.3
	Kernel-5_35-4_79_2_53:4.3
	Kernel-5_35-4_79_2_52:4.3
	Kernel-5_35-4_79_2_51:4.3
	Kernel-5_35-4_79_2_50:4.3
	Kernel-5_35-4_79_2_49:4.3
	Kernel-5_35-4_79_2_48:4.3
	Kernel-5_47:4.3
	Kernel-5_46-4_90_2_1:4.3
	nbingham_Kernel_FastNC_dev_bp:4.3
	nbingham_Kernel_FastNC_dev:4.3.0.6
	Kernel-5_46:4.3
	Kernel-5_45:4.3
	Kernel-5_35-4_79_2_47:4.3
	Kernel-5_35-4_79_2_46:4.3
	Kernel-5_35-4_79_2_45:4.3
	Kernel-5_35-4_79_2_44:4.3
	Kernel-5_35-4_79_2_25_2_2:4.3
	Kernel-5_35-4_79_2_43:4.3
	Kernel-5_35-4_79_2_42:4.3
	Kernel-5_35-4_79_2_41:4.3
	Kernel-5_35-4_79_2_40:4.3
	Kernel-5_35-4_79_2_39:4.3
	Kernel-5_35-4_79_2_38:4.3
	Kernel-5_35-4_79_2_37:4.3
	Kernel-5_35-4_79_2_36:4.3
	Kernel-5_35-4_79_2_35:4.3
	Kernel-5_35-4_79_2_34:4.3
	Kernel-5_35-4_79_2_33:4.3
	Kernel-5_35-4_79_2_32:4.3
	Kernel-5_44:4.3
	Kernel-5_35-4_79_2_25_2_1:4.3
	Kernel-5_43:4.3
	Kernel-5_35-4_79_2_31:4.3
	Kernel-5_35-4_79_2_30:4.3
	Kernel-5_35-4_79_2_29:4.3
	Kernel-5_35-4_79_2_28:4.3
	Kernel-5_35-4_79_2_27:4.3
	Kernel-5_35-4_79_2_26:4.3
	Kernel-5_42:4.3
	Kernel-5_41:4.3
	Kernel-5_40:4.3
	Kernel-5_35-4_79_2_25:4.3
	Kernel-5_35-4_79_2_24:4.3
	Kernel-5_35-4_79_2_23:4.3
	Kernel-5_35-4_79_2_22:4.3
	Kernel-5_35-4_79_2_21:4.3
	Kernel-5_35-4_79_2_20:4.3
	Kernel-5_35-4_79_2_19:4.3
	Kernel-5_35-4_79_2_18:4.3
	Kernel-5_35-4_79_2_17:4.3
	Kernel-5_35-4_79_2_16:4.3
	Kernel-5_35-4_79_2_15:4.3
	Kernel-5_35-4_79_2_14:4.3
	Kernel-5_39:4.3
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.3
	Kernel-5_35-4_79_2_13:4.3
	Kernel-5_35-4_79_2_12:4.3
	Kernel-5_35-4_79_2_11:4.3
	Kernel-5_37:4.3
	Kernel-5_35-4_79_2_10:4.3
	Kernel-5_35-4_79_2_9:4.3
	Kernel-5_36:4.3
	Kernel-5_35-4_79_2_8:4.3
	Kernel-5_35-4_79_2_7:4.3
	Kernel-5_35-4_79_2_6:4.3
	Kernel-5_35-4_79_2_5:4.3
	Kernel-5_35-4_79_2_4:4.3
	Kernel-5_35-4_79_2_3:4.3
	Kernel-5_35-4_79_2_2:4.3
	dellis_autobuild_BaseSW:4.3
	Kernel-5_35-4_79_2_1:4.3
	HAL:4.3.0.2
	Kernel-5_35:4.3
	Kernel-5_34:4.3
	Kernel-5_33:4.3
	Kernel-5_32:4.3
	Kernel-5_31:4.3
	Kernel-5_30:4.3
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.3
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2016.12.17.18.33.46;	author jlee;	state Exp;
branches;
next	4.5;
commitid	gK0l0oJHtyZOPmyz;

4.5
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches;
next	4.4;
commitid	skOEjp3ipLHx6xcz;

4.4
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.3;
commitid	IWoXxARWeuLDOwcz;

4.3
date	2000.06.28.16.12.26;	author bavison;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	2000.04.04.14.27.41;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.40;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2014.09.16.21.39.33;	author jlee;	state Exp;
branches;
next	;
commitid	0aV9TXjR3sdKjCQx;

4.1.1.1
date	96.11.05.09.41.40;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.25;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.45;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.20;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.48;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Fix screen redirection when in teletext modes. Fix *ScreenLoad buffer overflow.
Detail:
  s/vdu/vdugrafl, s/vdu/vduttx - Adjust initialisation & shutdown of TTX workspace to fix workspace being erroneously freed/reinitialised when redirecting output to a sprite
  s/vdu/vdugrafk - If ScreenLoad needs to load one row at a time (e.g. when graphics window width != sprite width), allocate a block from the RMA instead of assuming that ScrLoaBuffer is large enough
  hdr/KernelWS - Get rid of ScrLoaBuffer, and shrink LargeCommon to a suitable size. Frees about 2K of VDU workspace.
  s/GetAll - Move Hdr:Sprite earlier in list of GETs
Admin:
  Tested on Raspberry Pi


Version 5.75. Tagged as 'Kernel-5_75'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduGrafK
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - Sprite stuff
;
; Author R C Manby
; Date   5.3.87
;

; *****************************************************************************
;
;       ScreenSave - Save screen within graphics window as a sprite file
;
;       External routine
;
; in:   R2 -> file name
;       R3 = 0/1 => exclude/include palette data
;

ScreenSave ROUT
        Push    R14
        SWI     XOS_RemoveCursors

      [ {TRUE}
        GraphicsMode R0
        BNE     %FT20
      |
        LDR     R0, [WsPtr, #NPix]
        CMP     R0, #0
        BEQ     %FT20                   ; quit with error if not graphics mode
      ]

                                        ; build a temporary sprite area header
        ADD     R1, WsPtr, #ScrSavAreaCB
        MOV     R4, #&7FFFFFFF                  ; size, very large
        MOV     R5, #1                          ; one sprite
        LDR     R6, =(ScrSavSpriteCB-ScrSavAreaCB) ;saFirst
        MOV     R7, R6                          ; saFree=saFirst
        STMIA   R1, {R4-R7}

        ADD     R11, WsPtr, #GWLCol             ; R4 ,R5 ,R6 ,R7
        LDMIA   R11, {R4,R5,R6,R7}              ; wL ,wB ,wR ,wT

        LDR     R0, [WsPtr, #ModeNo]
        STR     R0, [WsPtr, #SGetMode]  ; needs setting up before CreateHeader

        Push    R2                      ; preserve file name pointer

        ; if it is a mode selector mode with >256 colours force it to have no
        ; palette. CreateHeader will deal with <=256.
        LDR     R2, [WsPtr, #Log2BPP]
        CMP     R2, #4
        MOVCS   R3, #0

        ; amg 25th May 1994. The above is no longer completely true. We still
        ; don't allow palettes on 16/32bpp. Below that (whether new or old
        ; format of sprite) palettes are now allowed. No actual code change
        ; here, but CreateHeader has been changed.

        ADR     R2, ScrSavSpriteName
                                        ;      R3     ,R4,R5,R6,R7
        BL      CreateHeader            ; In : Palette,sl,sb,sr,st
        ADDVS   sp, sp, #4              ; (if error, junk stacked filename ptr and exit)
        BVS     %FT35
                                        ; Out: ImageSize

        ; If this is a new format sprite, we must remove any lefthand wastage
        LDR     LR, [R2, #spMode]
        MOV     R10, #0
        CMP     LR, #256
        LDRHS   LR, [R2, #spLBit]
        CMPHS   LR, #1
        BLO     %FT05
        ; Wastage removal needed
        ; Recalculate the sprite width and header
        MOV     R11, LR                 ; R11 becomes shift amount
        LDR     LR, [R2, #spRBit]
        SUB     LR, LR, R11
        LDR     R3, [R2, #spWidth]
        ADD     LR, LR, R3, LSL #5      ; LR = Bit width of sprite, minus 1
        MOV     R4, LR, LSR #5          ; New spWidth
        AND     LR, LR, #31             ; New spRBit
        STR     R10, [R2, #spLBit]
        STR     R4, [R2, #spWidth]
        STR     LR, [R2, #spRBit]
        ; Shrink sprite size if we've lost a column of words
        TEQ     R3, R4
        LDRNE   LR, [R2, #spNext]
        LDRNE   R3, [R2, #spHeight]
        SUBNE   LR, LR, #4
        SUBNE   LR, LR, R3, LSL #2
        STRNE   LR, [R2, #spNext]
        ORRNE   R11, R11, #1<<31        ; Set top bit of R11 to act as a flag
        ; Allocate temp buffer large enough for a single scanline
        MOV     R3, R4, LSL #2
        ADD     R3, R3, #8              ; note +8 so that we can blindly write the last word, even if it's empty
        MOV     R0, #ModHandReason_Claim
        Push    "R2"
        SWI     XOS_Module
        MOVVC   R10, R2
        Pull    "R2"
        ADDVS   sp, sp, #4
        BVS     %FT30
05
                                        ; now add the sprite to the sprite area
        LDR     R3, [R2, #spNext]       ; total size of new sprite
        LDMIA   R1, {R4,R5,R6,R7}       ; saEnd,saNumber,saFirst,saFree
        ADD     R7, R7, R3              ; new saFree
        MOV     R4, R7
        STMIA   R1, {R4,R5,R6,R7}

; Create file to prevent "Can't extend"

        MOV     R0, #OSFile_CreateStamp
        LDR     R1, [R13, #0]           ; R1 -> filename
        LDR     R2, =&FF9               ; Type=SpriteFile
        MOV     R3, #0                  ; Junk
        MOV     R4, #0
        SUB     R5, R7, #4              ; File size (ie exclude saEnd)
        SWI     XOS_File
        Pull    R1
        BVS     %FT30

; OpenUp file and save the Sprite area and sprite headers

        MOV     R0, #open_update :OR: open_mustopen :OR: open_nodir
        SWI     XOS_Find
        BVS     %FT30

        MOV     R1, R0
        MOV     R0, #2                  ; write bytes to file

        LDR     R2, =(ScrSavAreaCB+saNumber)
        ADD     R2, R2, WsPtr
        LDR     R3, =(ScrSavSpriteCB+spImage)
        LDR     R3, [WsPtr, R3]
        ADD     R3, R3, #(SpriteAreaCBsize-saNumber)

        MOV     R4, #0
        SWI     XOS_GBPB
        BVS     %FT40                   ; FileSwitchGotYa !

        Push    R1
        LDR     R0, [WsPtr, #GWLCol]
        LDR     R1, [WsPtr, #GWTRow]
        BL      ScreenAddr              ; R2 = ScrAdr of TopL of area
        Pull    R1

        LDR     R5, [WsPtr, #SGetWidth]
        ADD     R5, R5, #1
        MOV     R5, R5, LSL #2           ; width (bytes)
        LDR     R6, [WsPtr, #SGetHeight] ; height-1

        LDR     R7, [WsPtr, #LineLength]

        TEQ     R10, #0
        RSBNE   R9, R11, #32
        BNE     %FT50

        SUBS    R7, R7, R5              ; zero then can do as one lump
        MLAEQ   R5, R6, R5, R5          ; R5 = R5*(R6+1)
        MOVEQ   R6, #0                  ; only one chunk to do

;
; R0    ,R1    ,R2    ,R3    ,R4    ,R5   ,R6    ,R7
;       ,Handle,ScrAdr,Size  ,      ,Width,RowCnt,RowOfSt

10
        MOV     R0, #2
        MOV     R3, R5
        SWI     XOS_GBPB
        BVS     %FT40                   ; something went wrong

        ADD     R2, R2, R7              ; step to next screen line
        SUBS    R6, R6, #1
        BGE     %BT10

15
        MOV     R0, #0                  ; close file
        SWI     XOS_Find
        BVS     %FT30
        SWI     XOS_RestoreCursors
        Pull    R14
        RETURNVC                        ; no error, return VC

20
        ADRL    R0, SpriteErr_NotGraphics
      [ International
        BL      TranslateError
      |
        SETV
      ]
        MOV     R10, #0
        B       %FT30

40                                      ; return point after an error
        STR     R0, [WsPtr, #RetnReg0]  ; R0 ptr to message, R1 file handle
        MOV     R0, #0                  ; close file
        SWI     XOS_Find
30                                      ; return point after an error
        STRVS   R0, [WsPtr, #RetnReg0]  ; R0 ptr to message
        MOVS    R2, R10
        MOVNE   R0, #ModHandReason_Free
        SWINE   XOS_Module              ; Release temp buffer
35
        SWI     XOS_RestoreCursors
        Pull    R14
        RETURNVS

50
        ; R1 = file handle
        ; R2 = screen addr
        ; R5 = source width, bytes
        ; R6 = height-1
        ; R7 = source stride
        ; R9 = left shift amount
        ; R10 = temp buffer
        ; R11 = right shift amount
        ;       if top bit is set, indicates destination is narrower than source
        Push    "R5,R7"
        ; Work from right to left to hurt my brain less
        ; LR used to hold the bits which were shifted out of the right of the
        ; previously written word (i.e. the word to the right of the current)
        MOV     LR, #0
        ADD     R2, R2, R5
        ADD     R10, R10, R5
55
        LDR     R0, [R2, #-4]!
        ORR     R3, LR, R0, LSR R11
        MOV     LR, R0, LSL R9
        STR     R3, [R10, #-4]!
        SUBS    R5, R5, #4
        BEQ     %FT65
60
        CMP     R5, #4*4
        BLT     %BT55
        ; Do 4 words at a time
        LDMDB   R2!, {R0, R3, R4, R7}
        ORR     R8, LR, R7, LSR R11
        MOV     LR, R7, LSL R9
        ORR     R7, LR, R4, LSR R11
        MOV     LR, R4, LSL R9
        ORR     R4, LR, R3, LSR R11
        MOV     LR, R3, LSL R9
        ORR     R3, LR, R0, LSR R11
        MOV     LR, R0, LSL R9
        STMDB   R10!, {R3, R4, R7, R8}
        SUBS    R5, R5, #4*4
        BNE     %BT60
65
        Pull    "R5,R7"
        MOV     R8, R2
        MOV     R2, R10        
        SUB     R3, R5, R11, LSR #29    ; Work out actual row length
        MOV     R0, #2
        SWI     XOS_GBPB
        BVS     %BT40
        ADD     R2, R8, R7
        SUBS    R6, R6, #1
        BGE     %BT50

        MOV     R2, R10
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
        B       %BT15

ScrSavSpriteName
        = "screendump", 0
        ALIGN

        LTORG

; *****************************************************************************
;
;       ScreenLoad - Plot sprite file directly into graphics window
;
;       External routine
;
; in:   R2 -> file name
;

ScreenLoad ROUT
        Push    R14
        SWI     XOS_RemoveCursors

        MOV     R0, #open_read+open_mustopen+open_nodir
        MOV     R1, R2
        SWI     XOS_Find
        BVS     %FT80

        STR     R0, [WsPtr, #ScrLoaHandle]
        MOV     R1, R0
        MOV     R0, #4                          ; read areaCB from file
        ADD     R2, WsPtr, #ScrLoaAreaCB+saNumber
        MOV     R3, #(SpriteAreaCBsize-saNumber)
        MOV     R4, #0
        SWI     XOS_GBPB
        BVS     %FT70                           ; FileSwitchGotYa !

        MOV     R0, #3                          ; read spriteCB from file
        ADD     R2, WsPtr, #ScrLoaSpriteCB
        MOV     R3, #SpriteCBsize
        ADD     R3, R3, #MaxSpritePaletteSize
        LDR     R4, [WsPtr, #(ScrLoaAreaCB+saFirst)]
        SUB     R4, R4, #4
        SWI     XOS_GBPB
        BVS     %FT70

        ADD     R2, WsPtr, #ScrLoaSpriteCB
        BL      WritePaletteFromSprite          ; mode change (if needed)
        ;branch to 75 rather than 70 because RetnRegR0 is already set up
        BVS     %FT75                           ; and palette setting

      [ {TRUE}
        GraphicsMode R0
        BNE     %FT60
      |
        LDR     R0, [WsPtr, #NPix]
        CMP     R0, #0
        BEQ     %FT60                   ; quit with error if not graphics mode
      ]

; now check for being able to do it all at once

        ADD     R0, WsPtr, #GWLCol              ; R3=GWLCol; R4=GWBRow
        LDMIA   R0, {R3-R6}                     ; R5=GWRCol; R6=GWTRow

        ADD     R0, WsPtr, #ScrLoaSpriteCB
        ADD     R0, R0, #spWidth                ; R7=width-1; R8=height-1
        LDMIA   R0, {R7-R10}                    ; R9=LBit; R10=RBit

        SUB     R5, R5, R3                      ; R5 = window width
        LDR     R0, [WsPtr, #XWindLimit]
        TEQ     R0, R5                          ; if window width=full screen
        TEQEQ   R9, #0                          ; and LBit=0
        TEQEQ   R10, #31                        ; and RBit=31
        BNE     %FT05

        ADD     R5, R5, #1                      ; R5 = screen width in pixels
        ADD     R7, R7, #1                      ; R7 = sprite width in words
        LDR     R0, [WsPtr, #NPix]
        MLA     R0, R7, R0, R7                  ; R0 = width*(npix+1)
        TEQ     R0, R5                          ; and spritewidth=full screen
        BNE     %FT05

      [ {TRUE}
        LDR     R14, [WsPtr, #Log2BPC]
        MOV     R1, R5, LSL R14                 ; bit size of 1 row of pixels
        MOV     R1, R1, LSR #3                  ; byte size of 1 row of pixels
        LDR     R14, [WsPtr, #LineLength]       ; LineLength (in bytes)
        TEQ     R1, R14                         ; if they differ (eg interlaced mode)
        BNE     %FT05                           ;   then we can't optimise
      ]

; we know we can do it all in one chunk
; work out screen address and sprite offset

        LDR     R1, [WsPtr, #CursorFlags]       ; if computing clip box
        TST     R1, #ClipBoxEnableBit
        Push    "R0-R4", NE
        BLNE    SetClipBoxToFullScreen          ; then set to full screen
        Pull    "R0-R4", NE                     ; above routine preserves PSR

        MOV     R7, R7, LSL #2                  ; R7 = line width in bytes
        ADD     R1, R8, R4                      ; R1 = height-1 + GWBRow = YT
        SUBS    R9, R1, R6                      ; if YT > GWTRow then
                                                ; start at row (YT-GWTRow)
        MOVHI   R1, R6                          ; and YT=GWTRow, else
        MOVLS   R9, #0                          ; start at row 0 (and YT=YT)

        LDR     R0, [WsPtr, #ScrLoaAreaCB+saFirst]
        ADD     R2, WsPtr, #ScrLoaSpriteCB
        LDR     R2, [R2, #spImage]
        ADD     R0, R0, R2
        SUB     R0, R0, #4                      ; R0=offset into file of image
        MLA     R4, R7, R9, R0                  ; add on vertical wastage*width

        SUB     R9, R8, R9                      ; R9 = height-1-wastage
        MLA     R9, R7, R9, R7                  ; number of bytes to transfer

        MOV     R0, #0
        BL      ScreenAddr                      ; R2 := screen address
        MOV     R3, R9

        LDR     R1, [WsPtr, #ScrLoaHandle]
        MOV     R0, #3                          ; read from this position
        SWI     XOS_GBPB
        BVS     %FT70                           ; if error
        B       %FT52                           ; no error

; can't do it all at once; R3 = GWLCol, R4 = GWBRow

05
        ADD     R2, WsPtr, #ScrLoaSpriteCB      ; point at the spriteCB
        MOV     R5, #0
        BL      GenSpritePlotParmBlk            ; "plotting" at (GWLCol,GWBRow)
        BVS     %FT55                           ; off screen (not an error)

        ADD     R2, WsPtr, #ScrLoaSpriteCB
        LDR     R4, [WsPtr, #SPltMemAdr]        ; convert MemAdr into
        LDR     R5, [WsPtr, #ScrLoaAreaCB+saFirst]
        SUB     R4, R4, #4
        SUB     R4, R4, R2
        ADD     R4, R4, R5
        STR     R4, [WsPtr, #ScrLoaFilPtr]      ; file ptr

        LDR     R4, [R2, #spWidth]              ; convert spWidth into
        ADD     R4, R4, #1
        MOV     R4, R4, LSL #2
        STR     R4, [WsPtr, #ScrLoaFilOfst]     ; file ptr offset

; Allocate a temp RMA block which we can load individual rows into
        LDR     R3, [WsPtr, #SPltColCnt]
        ADD     R3, R3, #2
        MOV     R3, R3, LSL #2
        STR     R3, [WsPtr, #ScrLoaBytes]

        MOV     R0, #ModHandReason_Claim
        SWI     XOS_Module
        BVS     %FT70
        STR     R2, [WsPtr, #SPltMemAdr]
        STR     R2, [WsPtr, #ScrLoaBufAdr]

10                                              ; read row from file
        ADD     R1, WsPtr, #ScrLoaHandle
        LDMIA   R1, {R1,R2,R3,R4}               ; Handle,BufAdr,Bytes,FilPtr
        MOV     R0, #3
        SWI     XOS_GBPB
        BVS     %FT57

        ADD     R0, WsPtr, #SPltScrAdr
        LDMIA   R0, {R0-R1,R5-R7}       ; R0    ,R1    ,     R5    ,R6   ,R7
                                        ; ScrAdr,ColCnt,     BufAdr,ShftR,ShftL

        LDMIA   R5, {R2,R3}             ; plot the first (leftmost) word
        ADD     R5, R5, #4

        ShiftR  R2,R3, R6,R7            ; shift R3,R2 right R6 places
                                        ; we only need result word R2

        LDR     R3, [WsPtr, #SPltLMask] ; on leftmost word, mask down
        AND     R2, R2, R3              ; to just the required pixels

        LDR     R4, [R0]                ; plot 1 word
        BIC     R4, R4, R3
        ORR     R4, R4, R2
        STR     R4, [R0], #4

        SUBS    R1, R1, #1
        BLT     %FT50                   ; if all plotted, try next scanline
                                        ; else try for blocks of 4
        SUBS    R1, R1, #4
        BLT     %FT30

20
        ;R0    ,R1         ,R5    ,R6   ,R7
        ;ScrAdr,ColCnt,    ,BufAdr,ShftR,ShftL

        LDMIA   R5, {R2,R3,R8-R10}      ; 5 words needed, gives 4 after shift
        ADD     R5, R5, #16             ; advance source ptr 4 words

        ShiftR  R2,R3, R6,R7            ; shift R4-R0 right R6 bits
        ShiftR  R3,R8, R6,R7            ; we only want result words R3-R0
        ShiftR  R8,R9, R6,R7
        ShiftR  R9,R10,R6,R7

        STMIA   R0!, {R2,R3,R8-R9}      ; write 4 words back to screen
        SUBS    R1, R1, #4
        BGE     %BT20

30                                      ; try 1 word at a time
        ADDS    R1, R1, #4

;R0    ,R1    ,     R5    ,R6   ,R7
;ScrAdr,ColCnt,     BufAdr,ShftR,ShftL
;
; If EQ this is rightmost word

        BEQ     %FT45
40
        LDMIA   R5, {R2,R3}
        ADD     R5, R5, #4

        ShiftR  R2,R3, R6,R7            ; shift R3,R2 right R6 places
                                        ; we only need result word R2
        STR     R2, [R0], #4
        SUBS    R1, R1, #1
        BGT     %BT40

45
        LDMIA   R5, {R2,R3}
        ADD     R5, R5, #4

        ShiftR  R2,R3, R6,R7            ; shift R3,R2 right R6 places
                                        ; we only need result word R2

        LDR     R3, [WsPtr, #SPltRMask] ; rightmost word, so mask down to
        AND     R2, R2, R3              ; just the required pixels

        LDR     R4, [R0]
        BIC     R4, R4, R3
        ORR     R4, R4, R2
        STR     R4, [R0], #4

50                                      ; now try the next scanline
        ADD     R11, WsPtr, #SPltWidth
        LDMIA   R11, {R1,R2,R3,R4}      ; Width,Height,ScrOff,MemOff
        ADD     R5, R0, R3
        SUBS    R2, R2, #1
        STMIA   R11, {R1,R2,R3,R4,R5}   ; Width,Height,ScrOff,MemOff,ScrAdr

        ADD     R11, WsPtr, #ScrLoaHandle ; R1    ,R2    ,R3   ,R4    ,R5
        LDMIA   R11, {R1,R2,R3,R4,R5}     ; Handle,BufAdr,Bytes,FilPtr,FilOfst
        ADD     R4, R4, R5
        STR     R4, [WsPtr, #ScrLoaFilPtr]
        BGE     %BT10                   ; plot next scanline

        LDR     R2, [WsPtr, #ScrLoaBufAdr]
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
52
        MOV     R0, #0                  ; close file
        SWI     XOS_Find
        BVS     %FT80
55
        SWI     XOS_RestoreCursors
        Pull    R14
        RETURNVC


57
        STR     R0, [WsPtr, #RetnReg0]
        LDR     R2, [WsPtr, #ScrLoaBufAdr]
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
        B       %FT75
60
        ADRL    R0,SpriteErr_NotGraphics
      [ International
        BL      TranslateError
      ]
70                                      ; return point after an error
        STR     R0, [WsPtr, #RetnReg0]  ; R0 ptr to message, R1 file handle
75
        MOV     R0, #0                  ; close file
        SWI     XOS_Find
80                                      ; error, file not open
        STRVS   R0, [WsPtr, #RetnReg0]
        SWI     XOS_RestoreCursors
        Pull    R14
        RETURNVS


        END
@


4.5
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d428 11
a438 8
        LDR     R4, [WsPtr, #SPltColCnt]
        ADD     R4, R4, #2
        MOV     R4, R4, LSL #2
        STR     R4, [WsPtr, #ScrLoaBytes]

        ADD     R4, WsPtr, #ScrLoaBuffer
        STR     R4, [WsPtr, #SPltMemAdr]
        STR     R4, [WsPtr, #ScrLoaBufAdr]
d445 1
a445 1
        BVS     %FT70
d533 4
d546 7
@


4.4
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a129 1
        [ AssemblingArthur :LOR: Module
a136 3
        |
        CLRV
        ]
a141 1
        [ AssemblingArthur :LOR: Module
a142 3
        |
        MOV     R0, #open_write
        ]
@


4.3
log
@  Added compile-time support for full-resolution teletext characters in
  teletext emulation mode (MODE 7) for that authentic BBC Micro feel.
  Also introduced a few useful teletext control features via VDU 23,18.
  Unrelatedly, fixed *ScreenLoad to work for interlaced displays.

Detail:
  The new typeface is designed on a 16x20 grid (previously we had used 8x10),
  so it uses a screen resolution of 640x500 pixels (rather than 320x250).
  Since we have been unable to source a genuine teletext font, and since
  examination of a BBC Micro suggests that the genuine font may not have been
  a power-of-2 pixels wide, I have designed one specially, based upon the one
  supplied in Zap distributions (a 12x20 font). Rather than increase the
  amount of workspace that the kernel requires for cacheing graphic
  characters, it now generates them on the fly, as they are required; this
  should only add about 25% to their rendering time.

  The new VDU 23 sequences are as follows:

  VDU 23,18,0,mode,0,0,0,0,0,0
    Switch transparency mode
      mode = 0: "Text" mode: the whole display is set opaque
      mode = 1: "Mix" mode: foreground colours, and both foreground and
        background of boxed text are opaque; non-boxed background colours are
        all transparent
      mode = 2: "Box" mode: boxed regions are opaque, others are transparent
      mode = 3: "TV" mode: the whole display is set transparent
    Default is mode = 0.

  VDU 23,18,1,suspend,0,0,0,0,0,0
    Suspend or resume bitmap updates
    This call allows an application to request that the kernel suspends
    updates to the framebuffer bitmap. This allows for a significant speed
    increase in the rendering time for a large amount of text, for example
    when redrawing a complete teletext page, because each time you plot a
    single character, it can cause the whole of the rest of the line to be
    re-rendered. When you switch out of suspend mode, the whole screen is
    refreshed in a single pass. Note that the appearance of the display is
    undefined is you cause a hardware scroll while in suspend mode.
      suspend = 0: screen update is enabled
      suspend = 1: screen update is suspended
    Default is suspend = 0.

  VDU 23,18,2,reveal,0,0,0,0,0,0
    Reveal/conceal
      reveal = 0: characters between the Conceal control code and the next
        colour control code are replaced by spaces
      reveal = 1: all characters are displayed
    Default is reveal = 0.

  VDU 23,18,3,black_emable,0,0,0,0,0,0
    Enable/disable black foreground colour control codes
      black_enable = 0: control codes &80 and &90 do nothing
      black_enable = 1: control code &80 selects black text, control code
        &90 selects black graphics
    Default is black_enable = 0.

  I have performed some timing tests on the rendering of complete teletext
  pages grabbed from the teletext server. These show that the new code
  generally imposes a 2x speed hit. However, when using the VDU 23,18,1
  suspend function, this improves to a 20% speed increase when compared to
  the old low-resolution code. Better still, because the framebuffer is only
  being updated for the final stage of this process, the screen *appears* to
  be updated some 3x faster than with the old code!

  A comment on the VDU variable Log2BPC is in order: in previous kernels,
  this was able unambiguously to refer to both the framebuffer width of a
  character in bytes, and the framebuffer width of an "addressable pixel" in
  bits; this no longer works with the 16-pixel wide teletext font. Bearing
  in mind that future kernels may support Unicode system fonts where the
  width varies from character to character, I have chosen to fix Log2BPC to
  the "addressable pixel" definition.

Admin:
  Requires HdrSrc 0.89 and (for non-desktop builds) Interlace 0.61. A monitor
  definition file containing a definition for a 640x500 screen mode is also
  required; version 0.40 of ModeFiles contains a suitable mode for STB-400.

  Tested fairly rigourously on an Ursula build, a Lazarus build and an
  STB-400 build, using genuine teletext pages and Yellow River Kingdom.

Version 5.30. Tagged as 'Kernel-5_30'
@
text
@d82 39
d179 5
d202 1
d217 1
d226 3
d234 57
@


4.3.2.1
log
@Fix new format *ScreenSave'd sprites containing lefthand wastage
Detail:
  s/vdu/vdugrafk - When saving a new format sprite that would otherwise contain lefthand wastage, copy each screen row to a temporary buffer before saving it out in order to allow the wastage to be removed
Admin:
  Tested on Pandaboard
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/4/topics/2802


Version 5.35, 4.79.2.237. Tagged as 'Kernel-5_35-4_79_2_237'
@
text
@a81 39

        ; If this is a new format sprite, we must remove any lefthand wastage
        LDR     LR, [R2, #spMode]
        MOV     R10, #0
        CMP     LR, #256
        LDRHS   LR, [R2, #spLBit]
        CMPHS   LR, #1
        BLO     %FT05
        ; Wastage removal needed
        ; Recalculate the sprite width and header
        MOV     R11, LR                 ; R11 becomes shift amount
        LDR     LR, [R2, #spRBit]
        SUB     LR, LR, R11
        LDR     R3, [R2, #spWidth]
        ADD     LR, LR, R3, LSL #5      ; LR = Bit width of sprite, minus 1
        MOV     R4, LR, LSR #5          ; New spWidth
        AND     LR, LR, #31             ; New spRBit
        STR     R10, [R2, #spLBit]
        STR     R4, [R2, #spWidth]
        STR     LR, [R2, #spRBit]
        ; Shrink sprite size if we've lost a column of words
        TEQ     R3, R4
        LDRNE   LR, [R2, #spNext]
        LDRNE   R3, [R2, #spHeight]
        SUBNE   LR, LR, #4
        SUBNE   LR, LR, R3, LSL #2
        STRNE   LR, [R2, #spNext]
        ORRNE   R11, R11, #1<<31        ; Set top bit of R11 to act as a flag
        ; Allocate temp buffer large enough for a single scanline
        MOV     R3, R4, LSL #2
        ADD     R3, R3, #8              ; note +8 so that we can blindly write the last word, even if it's empty
        MOV     R0, #ModHandReason_Claim
        Push    "R2"
        SWI     XOS_Module
        MOVVC   R10, R2
        Pull    "R2"
        ADDVS   sp, sp, #4
        BVS     %FT30
05
a139 5

        TEQ     R10, #0
        RSBNE   R9, R11, #32
        BNE     %FT50

a157 1
15
a171 1
        MOV     R10, #0
a179 3
        MOVS    R2, R10
        MOVNE   R0, #ModHandReason_Free
        SWINE   XOS_Module              ; Release temp buffer
a184 57
50
        ; R1 = file handle
        ; R2 = screen addr
        ; R5 = source width, bytes
        ; R6 = height-1
        ; R7 = source stride
        ; R9 = left shift amount
        ; R10 = temp buffer
        ; R11 = right shift amount
        ;       if top bit is set, indicates destination is narrower than source
        Push    "R5,R7"
        ; Work from right to left to hurt my brain less
        ; LR used to hold the bits which were shifted out of the right of the
        ; previously written word (i.e. the word to the right of the current)
        MOV     LR, #0
        ADD     R2, R2, R5
        ADD     R10, R10, R5
55
        LDR     R0, [R2, #-4]!
        ORR     R3, LR, R0, LSR R11
        MOV     LR, R0, LSL R9
        STR     R3, [R10, #-4]!
        SUBS    R5, R5, #4
        BEQ     %FT65
60
        CMP     R5, #4*4
        BLT     %BT55
        ; Do 4 words at a time
        LDMDB   R2!, {R0, R3, R4, R7}
        ORR     R8, LR, R7, LSR R11
        MOV     LR, R7, LSL R9
        ORR     R7, LR, R4, LSR R11
        MOV     LR, R4, LSL R9
        ORR     R4, LR, R3, LSR R11
        MOV     LR, R3, LSL R9
        ORR     R3, LR, R0, LSR R11
        MOV     LR, R0, LSL R9
        STMDB   R10!, {R3, R4, R7, R8}
        SUBS    R5, R5, #4*4
        BNE     %BT60
65
        Pull    "R5,R7"
        MOV     R8, R2
        MOV     R2, R10        
        SUB     R3, R5, R11, LSR #29    ; Work out actual row length
        MOV     R0, #2
        SWI     XOS_GBPB
        BVS     %BT40
        ADD     R2, R8, R7
        SUBS    R6, R6, #1
        BGE     %BT50

        MOV     R2, R10
        MOV     R0, #ModHandReason_Free
        SWI     XOS_Module
        B       %BT15

@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d264 9
@


4.1
log
@Initial revision
@
text
@d163 1
a163 1
        BICS    PC, R14, #V_bit         ; no error, return VC
d183 1
a183 1
        ORRS    PC, R14, #V_bit
d231 1
a231 1
                       
d239 1
a239 1
      ]       
d430 1
a430 1
        BICS    PC, R14, #V_bit
d446 1
a446 1
        ORRS    PC, R14, #V_bit
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d40 1
d43 5
d91 1
d99 3
d107 1
d109 3
d167 1
d169 3
d232 1
d235 5
d434 1
d436 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

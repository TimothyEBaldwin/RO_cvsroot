head	4.6;
access;
symbols
	Kernel-6_15:4.6
	Kernel-6_14:4.6
	Kernel-6_01-3:4.6
	Kernel-6_13:4.6
	Kernel-6_12:4.6
	Kernel-6_11:4.6
	Kernel-6_10:4.6
	Kernel-6_09:4.6
	Kernel-6_08-4_129_2_10:4.6
	Kernel-6_08-4_129_2_9:4.6
	Kernel-6_08:4.6
	Kernel-6_07:4.6
	Kernel-6_06:4.6
	Kernel-6_05-4_129_2_8:4.6
	Kernel-6_05:4.6
	Kernel-6_04:4.6
	Kernel-6_03:4.6
	Kernel-6_01-2:4.6
	Kernel-6_01-4_146_2_1:4.6
	Kernel-6_02:4.6
	Kernel-6_01-1:4.6
	Kernel-6_01:4.6
	Kernel-6_00:4.6
	Kernel-5_99:4.6
	Kernel-5_98:4.6
	Kernel-5_97-4_129_2_7:4.6
	Kernel-5_97:4.6
	Kernel-5_96:4.6
	Kernel-5_95:4.6
	Kernel-5_94:4.6
	Kernel-5_93:4.6
	Kernel-5_92:4.6
	Kernel-5_91:4.6
	Kernel-5_90:4.6
	Kernel-5_89-4_129_2_6:4.6
	Kernel-5_89:4.6
	Kernel-5_88-4_129_2_5:4.6
	Kernel-5_88-4_129_2_4:4.6
	Kernel-5_88:4.6
	Kernel-5_87:4.6
	Kernel-5_86-4_129_2_3:4.6
	Kernel-5_86-4_129_2_2:4.6
	Kernel-5_86-4_129_2_1:4.6
	Kernel-5_86:4.6
	SMP:4.6.0.2
	SMP_bp:4.6
	Kernel-5_85:4.6
	Kernel-5_54-1:4.5
	Kernel-5_84:4.6
	Kernel-5_83:4.5
	Kernel-5_82:4.5
	Kernel-5_81:4.5
	Kernel-5_80:4.5
	Kernel-5_79:4.5
	Kernel-5_78:4.5
	Kernel-5_77:4.5
	Kernel-5_76:4.5
	Kernel-5_75:4.5
	Kernel-5_74:4.5
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.5
	Kernel-5_64:4.5
	Kernel-5_63:4.5
	Kernel-5_62:4.5
	Kernel-5_61:4.5
	Kernel-5_60:4.5
	Kernel-5_59:4.5
	Kernel-5_58:4.5
	Kernel-5_57:4.5
	Kernel-5_56:4.5
	Kernel-5_55:4.5
	Kernel-5_54:4.5
	Kernel-5_53:4.5
	Kernel-5_52:4.5
	Kernel-5_51:4.5
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.3.2.12
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.3.2.12
	Kernel-5_35-4_79_2_326:4.3.2.12
	Kernel-5_35-4_79_2_325:4.3.2.12
	Kernel-5_35-4_79_2_324:4.3.2.12
	Kernel-5_35-4_79_2_323:4.3.2.12
	Kernel-5_35-4_79_2_322:4.3.2.12
	Kernel-5_35-4_79_2_321:4.3.2.12
	Kernel-5_35-4_79_2_320:4.3.2.12
	Kernel-5_35-4_79_2_319:4.3.2.12
	Kernel-5_35-4_79_2_318:4.3.2.12
	Kernel-5_35-4_79_2_317:4.3.2.12
	Kernel-5_35-4_79_2_316:4.3.2.12
	Kernel-5_35-4_79_2_315:4.3.2.12
	Kernel-5_35-4_79_2_314:4.3.2.12
	Kernel-5_35-4_79_2_313:4.3.2.12
	Kernel-5_35-4_79_2_312:4.3.2.12
	Kernel-5_35-4_79_2_311:4.3.2.12
	Kernel-5_35-4_79_2_310:4.3.2.12
	Kernel-5_35-4_79_2_309:4.3.2.12
	Kernel-5_35-4_79_2_308:4.3.2.12
	Kernel-5_35-4_79_2_307:4.3.2.12
	Kernel-5_35-4_79_2_306:4.3.2.12
	Kernel-5_35-4_79_2_305:4.3.2.12
	Kernel-5_35-4_79_2_304:4.3.2.12
	Kernel-5_35-4_79_2_303:4.3.2.12
	Kernel-5_35-4_79_2_302:4.3.2.12
	Kernel-5_35-4_79_2_301:4.3.2.12
	Kernel-5_35-4_79_2_300:4.3.2.12
	Kernel-5_35-4_79_2_299:4.3.2.12
	Kernel-5_35-4_79_2_298:4.3.2.12
	Kernel-5_35-4_79_2_297:4.3.2.12
	Kernel-5_35-4_79_2_296:4.3.2.12
	Kernel-5_35-4_79_2_295:4.3.2.12
	Kernel-5_35-4_79_2_294:4.3.2.12
	Kernel-5_35-4_79_2_293:4.3.2.12
	Kernel-5_35-4_79_2_292:4.3.2.12
	Kernel-5_35-4_79_2_291:4.3.2.12
	Kernel-5_35-4_79_2_290:4.3.2.12
	Kernel-5_35-4_79_2_289:4.3.2.12
	Kernel-5_35-4_79_2_288:4.3.2.12
	Kernel-5_35-4_79_2_287:4.3.2.12
	Kernel-5_35-4_79_2_286:4.3.2.12
	Kernel-5_35-4_79_2_285:4.3.2.12
	Kernel-5_35-4_79_2_284:4.3.2.12
	Kernel-5_35-4_79_2_283:4.3.2.12
	Kernel-5_35-4_79_2_282:4.3.2.12
	Kernel-5_35-4_79_2_281:4.3.2.12
	Kernel-5_35-4_79_2_280:4.3.2.12
	Kernel-5_35-4_79_2_279:4.3.2.12
	Kernel-5_35-4_79_2_278:4.3.2.12
	Kernel-5_35-4_79_2_277:4.3.2.12
	Kernel-5_35-4_79_2_276:4.3.2.12
	Kernel-5_35-4_79_2_275:4.3.2.12
	Kernel-5_35-4_79_2_274:4.3.2.12
	Kernel-5_35-4_79_2_273:4.3.2.12
	Kernel-5_35-4_79_2_272:4.3.2.12
	Kernel-5_35-4_79_2_271:4.3.2.12
	Kernel-5_35-4_79_2_270:4.3.2.12
	Kernel-5_35-4_79_2_269:4.3.2.11
	Kernel-5_35-4_79_2_268:4.3.2.10
	Kernel-5_35-4_79_2_267:4.3.2.10
	Kernel-5_35-4_79_2_266:4.3.2.10
	Kernel-5_35-4_79_2_265:4.3.2.10
	Kernel-5_35-4_79_2_264:4.3.2.10
	Kernel-5_35-4_79_2_263:4.3.2.10
	Kernel-5_35-4_79_2_262:4.3.2.10
	Kernel-5_35-4_79_2_261:4.3.2.10
	Kernel-5_35-4_79_2_260:4.3.2.10
	Kernel-5_35-4_79_2_259:4.3.2.10
	Kernel-5_35-4_79_2_258:4.3.2.10
	Kernel-5_35-4_79_2_257:4.3.2.10
	Kernel-5_35-4_79_2_256:4.3.2.10
	Kernel-5_35-4_79_2_255:4.3.2.10
	Kernel-5_35-4_79_2_254:4.3.2.10
	Kernel-5_35-4_79_2_253:4.3.2.10
	Kernel-5_35-4_79_2_252:4.3.2.10
	Kernel-5_35-4_79_2_251:4.3.2.10
	Kernel-5_35-4_79_2_250:4.3.2.10
	Kernel-5_35-4_79_2_249:4.3.2.10
	Kernel-5_35-4_79_2_248:4.3.2.10
	Kernel-5_35-4_79_2_247:4.3.2.10
	Kernel-5_35-4_79_2_246:4.3.2.10
	Kernel-5_35-4_79_2_245:4.3.2.10
	Kernel-5_35-4_79_2_244:4.3.2.10
	Kernel-5_35-4_79_2_243:4.3.2.10
	Kernel-5_35-4_79_2_242:4.3.2.10
	Kernel-5_35-4_79_2_241:4.3.2.10
	Kernel-5_35-4_79_2_240:4.3.2.10
	Kernel-5_35-4_79_2_239:4.3.2.10
	Kernel-5_35-4_79_2_238:4.3.2.10
	Kernel-5_35-4_79_2_237:4.3.2.10
	Kernel-5_35-4_79_2_236:4.3.2.10
	Kernel-5_35-4_79_2_235:4.3.2.10
	Kernel-5_35-4_79_2_234:4.3.2.10
	Kernel-5_35-4_79_2_233:4.3.2.10
	Kernel-5_35-4_79_2_232:4.3.2.10
	Kernel-5_35-4_79_2_231:4.3.2.10
	Kernel-5_35-4_79_2_230:4.3.2.10
	Kernel-5_35-4_79_2_229:4.3.2.10
	Kernel-5_35-4_79_2_228:4.3.2.10
	Kernel-5_35-4_79_2_227:4.3.2.10
	Kernel-5_35-4_79_2_226:4.3.2.10
	Kernel-5_35-4_79_2_225:4.3.2.10
	Kernel-5_35-4_79_2_224:4.3.2.10
	Kernel-5_35-4_79_2_223:4.3.2.10
	Kernel-5_35-4_79_2_222:4.3.2.10
	Kernel-5_35-4_79_2_221:4.3.2.10
	Kernel-5_35-4_79_2_220:4.3.2.10
	Kernel-5_35-4_79_2_219:4.3.2.10
	Kernel-5_35-4_79_2_218:4.3.2.10
	Kernel-5_35-4_79_2_217:4.3.2.10
	Kernel-5_35-4_79_2_216:4.3.2.10
	Kernel-5_35-4_79_2_215:4.3.2.10
	Kernel-5_35-4_79_2_214:4.3.2.10
	Kernel-5_35-4_79_2_213:4.3.2.10
	Kernel-5_35-4_79_2_212:4.3.2.10
	Kernel-5_35-4_79_2_211:4.3.2.10
	Kernel-5_35-4_79_2_210:4.3.2.10
	Kernel-5_35-4_79_2_209:4.3.2.10
	Kernel-5_35-4_79_2_208:4.3.2.10
	Kernel-5_35-4_79_2_207:4.3.2.10
	Kernel-5_35-4_79_2_206:4.3.2.10
	Kernel-5_35-4_79_2_205:4.3.2.10
	Kernel-5_35-4_79_2_204:4.3.2.10
	Kernel-5_35-4_79_2_203:4.3.2.10
	Kernel-5_35-4_79_2_202:4.3.2.9
	Kernel-5_35-4_79_2_201:4.3.2.9
	Kernel-5_35-4_79_2_200:4.3.2.9
	Kernel-5_35-4_79_2_199:4.3.2.9
	Kernel-5_35-4_79_2_198:4.3.2.9
	Kernel-5_35-4_79_2_197:4.3.2.9
	Kernel-5_35-4_79_2_196:4.3.2.9
	Kernel-5_35-4_79_2_195:4.3.2.9
	Kernel-5_35-4_79_2_194:4.3.2.9
	Kernel-5_35-4_79_2_193:4.3.2.9
	Kernel-5_35-4_79_2_192:4.3.2.9
	Kernel-5_35-4_79_2_191:4.3.2.9
	Kernel-5_35-4_79_2_190:4.3.2.9
	Kernel-5_35-4_79_2_189:4.3.2.9
	Kernel-5_35-4_79_2_188:4.3.2.9
	Kernel-5_35-4_79_2_187:4.3.2.9
	Kernel-5_35-4_79_2_186:4.3.2.9
	Kernel-5_35-4_79_2_185:4.3.2.9
	Kernel-5_35-4_79_2_184:4.3.2.9
	Kernel-5_35-4_79_2_183:4.3.2.9
	Kernel-5_35-4_79_2_182:4.3.2.9
	Kernel-5_35-4_79_2_181:4.3.2.9
	Kernel-5_35-4_79_2_180:4.3.2.9
	Kernel-5_35-4_79_2_179:4.3.2.9
	Kernel-5_35-4_79_2_178:4.3.2.9
	Kernel-5_35-4_79_2_177:4.3.2.9
	Kernel-5_35-4_79_2_176:4.3.2.9
	Kernel-5_35-4_79_2_175:4.3.2.9
	Kernel-5_35-4_79_2_174:4.3.2.9
	Kernel-5_35-4_79_2_173:4.3.2.9
	Kernel-5_35-4_79_2_172:4.3.2.9
	Kernel-5_35-4_79_2_171:4.3.2.9
	Kernel-5_35-4_79_2_170:4.3.2.9
	Kernel-5_35-4_79_2_169:4.3.2.9
	Kernel-5_35-4_79_2_168:4.3.2.9
	Kernel-5_35-4_79_2_167:4.3.2.9
	Kernel-5_35-4_79_2_166:4.3.2.9
	Kernel-5_35-4_79_2_165:4.3.2.9
	RPi_merge:4.3.2.6.2.2
	Kernel-5_35-4_79_2_147_2_23:4.3.2.6.2.2
	Kernel-5_35-4_79_2_147_2_22:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_21:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_20:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_19:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_18:4.3.2.6.2.1
	Kernel-5_35-4_79_2_164:4.3.2.8
	Kernel-5_35-4_79_2_163:4.3.2.8
	Kernel-5_35-4_79_2_147_2_17:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_16:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_15:4.3.2.6.2.1
	Kernel-5_35-4_79_2_162:4.3.2.8
	Kernel-5_35-4_79_2_161:4.3.2.8
	Kernel-5_35-4_79_2_147_2_14:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_13:4.3.2.6.2.1
	Kernel-5_35-4_79_2_160:4.3.2.8
	Kernel-5_35-4_79_2_159:4.3.2.8
	Kernel-5_35-4_79_2_158:4.3.2.7
	Kernel-5_35-4_79_2_157:4.3.2.7
	Kernel-5_35-4_79_2_156:4.3.2.7
	Kernel-5_35-4_79_2_147_2_12:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_11:4.3.2.6.2.1
	Kernel-5_35-4_79_2_155:4.3.2.7
	Kernel-5_35-4_79_2_147_2_10:4.3.2.6.2.1
	Kernel-5_35-4_79_2_154:4.3.2.7
	Kernel-5_35-4_79_2_153:4.3.2.7
	Kernel-5_35-4_79_2_147_2_9:4.3.2.6.2.1
	Kernel-5_35-4_79_2_152:4.3.2.7
	Kernel-5_35-4_79_2_151:4.3.2.7
	Kernel-5_35-4_79_2_147_2_8:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_7:4.3.2.6.2.1
	Kernel-5_35-4_79_2_150:4.3.2.7
	Kernel-5_35-4_79_2_147_2_6:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_5:4.3.2.6.2.1
	Kernel-5_35-4_79_2_149:4.3.2.6
	Kernel-5_35-4_79_2_147_2_4:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_3:4.3.2.6.2.1
	Kernel-5_35-4_79_2_148:4.3.2.6
	Kernel-5_35-4_79_2_147_2_2:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147_2_1:4.3.2.6.2.1
	RPi:4.3.2.6.0.2
	RPi_bp:4.3.2.6
	Kernel-5_35-4_79_2_98_2_52_2_1:4.3.2.4.2.3.2.1
	alees_Kernel_dev:4.3.2.4.2.3.0.2
	alees_Kernel_dev_bp:4.3.2.4.2.3
	Kernel-5_35-4_79_2_147:4.3.2.6
	Kernel-5_35-4_79_2_146:4.3.2.6
	Kernel-5_35-4_79_2_145:4.3.2.6
	Kernel-5_35-4_79_2_144:4.3.2.6
	Kernel-5_35-4_79_2_143:4.3.2.6
	Kernel-5_35-4_79_2_142:4.3.2.6
	Kernel-5_35-4_79_2_141:4.3.2.6
	Kernel-5_35-4_79_2_140:4.3.2.6
	Kernel-5_35-4_79_2_139:4.3.2.6
	Kernel-5_35-4_79_2_138:4.3.2.6
	Kernel-5_35-4_79_2_137:4.3.2.6
	Kernel-5_35-4_79_2_136:4.3.2.6
	Kernel-5_35-4_79_2_135:4.3.2.6
	Kernel-5_35-4_79_2_134:4.3.2.6
	Kernel-5_35-4_79_2_133:4.3.2.6
	Kernel-5_35-4_79_2_132:4.3.2.6
	Kernel-5_35-4_79_2_131:4.3.2.6
	Kernel-5_35-4_79_2_130:4.3.2.6
	Kernel-5_35-4_79_2_129:4.3.2.6
	Kernel-5_35-4_79_2_128:4.3.2.6
	Kernel-5_35-4_79_2_127:4.3.2.6
	Kernel-5_35-4_79_2_126:4.3.2.6
	Kernel-5_35-4_79_2_125:4.3.2.6
	Kernel-5_35-4_79_2_124:4.3.2.6
	Kernel-5_35-4_79_2_123:4.3.2.5
	Cortex_merge:4.3.2.4.2.3
	Kernel-5_35-4_79_2_122:4.3.2.4
	Kernel-5_35-4_79_2_98_2_54:4.3.2.4.2.3
	Kernel-5_35-4_79_2_98_2_53:4.3.2.4.2.3
	Kernel-5_35-4_79_2_98_2_52:4.3.2.4.2.3
	Kernel-5_35-4_79_2_98_2_51:4.3.2.4.2.3
	Kernel-5_35-4_79_2_98_2_50:4.3.2.4.2.3
	Kernel-5_35-4_79_2_98_2_49:4.3.2.4.2.3
	Kernel-5_35-4_79_2_98_2_48:4.3.2.4.2.3
	Kernel-5_35-4_79_2_121:4.3.2.4
	Kernel-5_35-4_79_2_98_2_47:4.3.2.4.2.2
	Kernel-5_35-4_79_2_120:4.3.2.4
	Kernel-5_35-4_79_2_98_2_46:4.3.2.4.2.2
	Kernel-5_35-4_79_2_119:4.3.2.4
	Kernel-5_35-4_79_2_98_2_45:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_44:4.3.2.4.2.2
	Kernel-5_35-4_79_2_118:4.3.2.4
	Kernel-5_35-4_79_2_98_2_43:4.3.2.4.2.2
	Kernel-5_35-4_79_2_117:4.3.2.4
	Kernel-5_35-4_79_2_116:4.3.2.4
	Kernel-5_35-4_79_2_98_2_42:4.3.2.4.2.2
	Kernel-5_35-4_79_2_115:4.3.2.4
	Kernel-5_35-4_79_2_98_2_41:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_40:4.3.2.4.2.2
	Kernel-5_35-4_79_2_114:4.3.2.4
	Kernel-5_35-4_79_2_98_2_39:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_38:4.3.2.4.2.2
	Kernel-5_35-4_79_2_113:4.3.2.4
	Kernel-5_35-4_79_2_112:4.3.2.4
	Kernel-5_35-4_79_2_98_2_37:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_36:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_35:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_34:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_33:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_32:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_31:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_30:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_29:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_28:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_27:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_26:4.3.2.4.2.2
	Kernel-5_35-4_79_2_111:4.3.2.4
	Kernel-5_35-4_79_2_98_2_25:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_24:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_23:4.3.2.4.2.2
	Kernel-5_35-4_79_2_110:4.3.2.4
	Kernel-5_35-4_79_2_98_2_22:4.3.2.4.2.2
	Kernel-5_35-4_79_2_109:4.3.2.4
	Kernel-5_35-4_79_2_98_2_21:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_20:4.3.2.4.2.2
	Kernel-5_35-4_79_2_108:4.3.2.4
	Kernel-5_35-4_79_2_107:4.3.2.4
	Kernel-5_35-4_79_2_98_2_19:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_18:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_17:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_16:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_15:4.3.2.4.2.2
	Kernel-5_35-4_79_2_106:4.3.2.4
	Kernel-5_35-4_79_2_105:4.3.2.4
	Kernel-5_35-4_79_2_104:4.3.2.4
	Kernel-5_35-4_79_2_98_2_14:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_13:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_12:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_11:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_10:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_9:4.3.2.4.2.2
	Kernel-5_35-4_79_2_103:4.3.2.4
	Kernel-5_35-4_79_2_102:4.3.2.4
	Kernel-5_35-4_79_2_98_2_8:4.3.2.4.2.2
	Kernel-5_35-4_79_2_98_2_7:4.3.2.4.2.1
	Kernel-5_35-4_79_2_98_2_6:4.3.2.4.2.1
	Kernel-5_35-4_79_2_98_2_5:4.3.2.4
	Kernel-5_35-4_79_2_98_2_4:4.3.2.4
	Kernel-5_35-4_79_2_101:4.3.2.4
	Kernel-5_35-4_79_2_100:4.3.2.4
	Kernel-5_35-4_79_2_99:4.3.2.4
	Kernel-5_35-4_79_2_98_2_3:4.3.2.4
	Kernel-5_35-4_79_2_98_2_2:4.3.2.4
	Kernel-5_35-4_79_2_98_2_1:4.3.2.4
	Cortex:4.3.2.4.0.2
	Cortex_bp:4.3.2.4
	Kernel-5_35-4_79_2_98:4.3.2.4
	Kernel-5_35-4_79_2_97:4.3.2.4
	Kernel-5_35-4_79_2_96:4.3.2.4
	Kernel-5_35-4_79_2_95:4.3.2.4
	Kernel-5_35-4_79_2_94:4.3.2.4
	Kernel-5_35-4_79_2_93:4.3.2.4
	Kernel-5_35-4_79_2_92:4.3.2.4
	Kernel-5_35-4_79_2_91:4.3.2.4
	Kernel-5_35-4_79_2_90:4.3.2.4
	Kernel-5_35-4_79_2_89:4.3.2.4
	Kernel-5_35-4_79_2_88:4.3.2.4
	Kernel-5_35-4_79_2_87:4.3.2.4
	Kernel-5_35-4_79_2_86:4.3.2.4
	Kernel-5_35-4_79_2_85:4.3.2.4
	Kernel-5_35-4_79_2_84:4.3.2.4
	Kernel-5_35-4_79_2_83:4.3.2.4
	Kernel-5_35-4_79_2_82:4.3.2.4
	Kernel-5_35-4_79_2_81:4.3.2.4
	Kernel-5_35-4_79_2_80:4.3.2.4
	Kernel-5_35-4_79_2_79:4.3.2.4
	Kernel-5_35-4_79_2_78:4.3.2.4
	Kernel-5_35-4_79_2_77:4.3.2.4
	RO_5_07:4.3.2.4
	Kernel-5_35-4_79_2_76:4.3.2.4
	Kernel-5_35-4_79_2_75:4.3.2.4
	Kernel-5_35-4_79_2_74:4.3.2.4
	Kernel-5_35-4_79_2_73:4.3.2.4
	Kernel-5_35-4_79_2_72:4.3.2.4
	Kernel-5_35-4_79_2_71:4.3.2.4
	Kernel-5_35-4_79_2_70:4.3.2.4
	Kernel-5_35-4_79_2_69:4.3.2.4
	Kernel-5_35-4_79_2_68:4.3.2.4
	Kernel-5_35-4_79_2_67:4.3.2.4
	Kernel-5_35-4_79_2_66:4.3.2.4
	Kernel-5_35-4_79_2_65:4.3.2.4
	Kernel-5_35-4_79_2_64:4.3.2.4
	Kernel-5_35-4_79_2_63:4.3.2.4
	Kernel-5_35-4_79_2_62:4.3.2.4
	Kernel-5_35-4_79_2_61:4.3.2.4
	Kernel-5_35-4_79_2_59:4.3.2.4
	Kernel-5_35-4_79_2_58:4.3.2.4
	Kernel-5_35-4_79_2_57:4.3.2.4
	Kernel-5_35-4_79_2_56:4.3.2.4
	Kernel-5_35-4_79_2_55:4.3.2.4
	Kernel-5_35-4_79_2_54:4.3.2.4
	Kernel-5_35-4_79_2_53:4.3.2.4
	Kernel-5_35-4_79_2_52:4.3.2.4
	Kernel-5_35-4_79_2_51:4.3.2.4
	Kernel-5_35-4_79_2_50:4.3.2.4
	Kernel-5_35-4_79_2_49:4.3.2.4
	Kernel-5_35-4_79_2_48:4.3.2.4
	Kernel-5_47:4.3
	Kernel-5_46-4_90_2_1:4.3
	nbingham_Kernel_FastNC_dev_bp:4.3
	nbingham_Kernel_FastNC_dev:4.3.0.4
	Kernel-5_46:4.3
	Kernel-5_45:4.3
	Kernel-5_35-4_79_2_47:4.3.2.3
	Kernel-5_35-4_79_2_46:4.3.2.3
	Kernel-5_35-4_79_2_45:4.3.2.3
	Kernel-5_35-4_79_2_44:4.3.2.3
	Kernel-5_35-4_79_2_25_2_2:4.3.2.3
	Kernel-5_35-4_79_2_43:4.3.2.3
	Kernel-5_35-4_79_2_42:4.3.2.3
	Kernel-5_35-4_79_2_41:4.3.2.3
	Kernel-5_35-4_79_2_40:4.3.2.3
	Kernel-5_35-4_79_2_39:4.3.2.3
	Kernel-5_35-4_79_2_38:4.3.2.3
	Kernel-5_35-4_79_2_37:4.3.2.3
	Kernel-5_35-4_79_2_36:4.3.2.3
	Kernel-5_35-4_79_2_35:4.3.2.3
	Kernel-5_35-4_79_2_34:4.3.2.3
	Kernel-5_35-4_79_2_33:4.3.2.3
	Kernel-5_35-4_79_2_32:4.3.2.3
	Kernel-5_44:4.3
	Kernel-5_35-4_79_2_25_2_1:4.3.2.3
	Kernel-5_43:4.3
	Kernel-5_35-4_79_2_31:4.3.2.3
	Kernel-5_35-4_79_2_30:4.3.2.3
	Kernel-5_35-4_79_2_29:4.3.2.3
	Kernel-5_35-4_79_2_28:4.3.2.3
	Kernel-5_35-4_79_2_27:4.3.2.3
	Kernel-5_35-4_79_2_26:4.3.2.3
	Kernel-5_42:4.3
	Kernel-5_41:4.3
	Kernel-5_40:4.3
	Kernel-5_35-4_79_2_25:4.3.2.3
	Kernel-5_35-4_79_2_24:4.3.2.3
	Kernel-5_35-4_79_2_23:4.3.2.3
	Kernel-5_35-4_79_2_22:4.3.2.3
	Kernel-5_35-4_79_2_21:4.3.2.3
	Kernel-5_35-4_79_2_20:4.3.2.3
	Kernel-5_35-4_79_2_19:4.3.2.3
	Kernel-5_35-4_79_2_18:4.3.2.3
	Kernel-5_35-4_79_2_17:4.3.2.3
	Kernel-5_35-4_79_2_16:4.3.2.3
	Kernel-5_35-4_79_2_15:4.3.2.3
	Kernel-5_35-4_79_2_14:4.3.2.3
	Kernel-5_39:4.3
	Kernel-5_13-4_52_2_1:4.2
	Bethany:4.2.0.8
	Kernel-5_38:4.3
	Kernel-5_35-4_79_2_13:4.3.2.3
	Kernel-5_35-4_79_2_12:4.3.2.3
	Kernel-5_35-4_79_2_11:4.3.2.3
	Kernel-5_37:4.3
	Kernel-5_35-4_79_2_10:4.3.2.3
	Kernel-5_35-4_79_2_9:4.3.2.3
	Kernel-5_36:4.3
	Kernel-5_35-4_79_2_8:4.3.2.3
	Kernel-5_35-4_79_2_7:4.3.2.3
	Kernel-5_35-4_79_2_6:4.3.2.3
	Kernel-5_35-4_79_2_5:4.3.2.3
	Kernel-5_35-4_79_2_4:4.3.2.3
	Kernel-5_35-4_79_2_3:4.3.2.2
	Kernel-5_35-4_79_2_2:4.3.2.1
	dellis_autobuild_BaseSW:4.3
	Kernel-5_35-4_79_2_1:4.3.2.1
	HAL:4.3.0.2
	Kernel-5_35:4.3
	Kernel-5_34:4.3
	Kernel-5_33:4.3
	Kernel-5_32:4.3
	Kernel-5_31:4.3
	Kernel-5_30:4.3
	Kernel-5_29:4.3
	Kernel-5_28:4.3
	Kernel-5_27:4.3
	Kernel-5_26:4.3
	Kernel-5_25:4.3
	Kernel-5_24:4.3
	Kernel-5_23:4.3
	Kernel-5_22:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Kernel-5_21:4.2
	Kernel-5_20:4.2
	Kernel-5_19:4.2
	Kernel-5_18:4.2
	Kernel-5_17:4.2
	Kernel-5_16:4.2
	Kernel-5_15:4.2
	Kernel-5_14:4.2
	Kernel-5_13:4.2
	Kernel-5_12:4.2
	Kernel-5_11:4.2
	Kernel-5_10:4.2
	Kernel-5_09:4.2
	Kernel-5_08:4.2
	Kernel-5_07:4.2
	Kernel-5_06:4.2
	Kernel-5_05:4.2
	Kernel-5_04:4.2
	Kernel-5_03:4.2
	Kernel-5_02:4.2
	Kernel-5_01:4.2
	Kernel-5_00:4.2
	Kernel-4_99:4.2
	Kernel-4_98:4.2
	Kernel-4_97:4.2
	Kernel-4_96:4.2
	Kernel-4_95:4.2
	Kernel-4_94:4.2
	Kernel-4_93:4.2
	Kernel-4_92:4.2
	Kernel-4_91:4.2
	Kernel-4_90:4.2
	dcotton_autobuild_BaseSW:4.3
	Kernel-4_89:4.2
	Kernel-4_88:4.2
	Kernel-4_87:4.2
	Kernel-4_86:4.2
	Kernel-4_85:4.2
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.1.2.1
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.1.2.1
	Ursula_RiscPC_bp:4.2.2.1
	Kernel-4_83:4.2
	Kernel-4_82:4.2
	Kernel-4_81:4.2
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.2
	Ursula_merge:4.2
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.2.2.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	mstphens_Kernel-3_80:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2017.06.15.20.56.37;	author jlee;	state Exp;
branches;
next	4.5;
commitid	8BDmyAR9SQp7QvVz;

4.5
date	2016.06.30.20.59.54;	author jlee;	state Exp;
branches;
next	4.4;
commitid	skOEjp3ipLHx6xcz;

4.4
date	2016.06.30.20.08.20;	author jlee;	state Exp;
branches;
next	4.3;
commitid	IWoXxARWeuLDOwcz;

4.3
date	2000.04.04.14.27.42;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.14.07.41;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.41;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2000.09.15.12.38.02;	author kbracey;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2000.10.03.12.06.00;	author mstephen;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	2000.10.05.11.55.13;	author mstephen;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches
	4.3.2.4.2.1;
next	4.3.2.5;

4.3.2.5
date	2011.11.26.21.11.29;	author jlee;	state Exp;
branches;
next	4.3.2.6;
commitid	cI3W0zbtALQG6TIv;

4.3.2.6
date	2011.11.27.11.48.22;	author rsprowson;	state Exp;
branches
	4.3.2.6.2.1;
next	4.3.2.7;
commitid	OFgqaKhOb6swXXIv;

4.3.2.7
date	2012.05.21.19.31.44;	author rsprowson;	state Exp;
branches;
next	4.3.2.8;
commitid	oEtPURiKNEPMRC5w;

4.3.2.8
date	2012.07.04.17.50.57;	author rsprowson;	state Exp;
branches;
next	4.3.2.9;
commitid	BwjRc3GMlaDwTgbw;

4.3.2.9
date	2012.09.18.22.01.22;	author jlee;	state Exp;
branches;
next	4.3.2.10;
commitid	eFa3Y1QY0MjZP3lw;

4.3.2.10
date	2013.12.15.21.34.13;	author jlee;	state Exp;
branches;
next	4.3.2.11;
commitid	KwuK29hKRyXO7hhx;

4.3.2.11
date	2015.07.10.20.16.43;	author jlee;	state Exp;
branches;
next	4.3.2.12;
commitid	wa0i3ESGlbkojMsy;

4.3.2.12
date	2015.07.13.18.58.45;	author jlee;	state Exp;
branches;
next	;
commitid	5MW5L8DrRhNFM9ty;

4.3.2.4.2.1
date	2009.05.10.20.22.33;	author bavison;	state Exp;
branches;
next	4.3.2.4.2.2;

4.3.2.4.2.2
date	2009.05.17.01.34.43;	author bavison;	state Exp;
branches;
next	4.3.2.4.2.3;

4.3.2.4.2.3
date	2011.08.08.23.28.38;	author jlee;	state Exp;
branches
	4.3.2.4.2.3.2.1;
next	;
commitid	D7rzILnwRRSXoLuv;

4.3.2.4.2.3.2.1
date	2012.05.10.03.10.02;	author bavison;	state Exp;
branches;
next	;
commitid	HTVG5Da5tRqSM74w;

4.3.2.6.2.1
date	2012.05.10.03.28.12;	author bavison;	state Exp;
branches;
next	4.3.2.6.2.2;
commitid	kuJoT3AcfB16T74w;

4.3.2.6.2.2
date	2012.09.18.15.50.11;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.2.2.1
date	97.09.09.13.34.53;	author mstphens;	state Exp;
branches
	4.2.2.1.2.1;
next	4.2.2.2;

4.2.2.2
date	98.09.24.13.17.55;	author mstphens;	state Exp;
branches;
next	;

4.2.2.1.2.1
date	98.11.23.14.59.47;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.41;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.55;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.35;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.58;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Fix software pointer when ExtraBytes is in use
Detail:
  s/vdu/vdupointer - The software pointer code was calculating LineLength manually, due to previous kernel versions not storing a copy of the value that would be safe to use during screen redirection.
  Fix the code to use the new DisplayLineLength variable, so that the software pointer will be correct in modes which have row padding.
Admin:
  Tested on Raspberry Pi 3


Version 5.84. Tagged as 'Kernel-5_84'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduPointer

; mjs Sep 2000
;
; kernel/HAL split
; display pointer updating is no longer VIDC/IOMD specific
;

; *****************************************************************************
;
;       DoPointerStuff - Entry point for OSWORD nn
;
; in:   R1 -> control block
;       [R1, #0] : Reason code
;
;       Reason code 0 - Define pointer size, shape and active point
;
;       [R1, #1] : Shape number (1..4)
;       [R1, #2] : Width (w) in bytes (0..8)
;       [R1, #3] : Height (h) in pixels (0..32)
;       [R1, #4] : ActiveX in pixels from left (0..w*4-1)
;       [R1, #5] : ActiveY in pixels from top (0..h-1)
;       [R1, #6..9] : Pointer (P) to data
;       [P, #0..w*h-1] : Data bytes in rows from top to bottom,
;       left to right in each row.
;
;       Reason code 1 - Define mouse coordinate bounding box
;
;       [R1, #1..2] : left      ; all treated as
;       [R1, #3..4] : bottom    ; signed 16-bit values,
;       [R1, #5..6] : right     ; relative to screen origin at the time
;       [R1, #7..8] : top       ; the command is issued
;
;       If (left > right) or (bottom > top) then the command is ignored
;       An infinite box can be obtained by setting
;       left=&8000, right=&7FFF, bottom=&8000, top=&7FFF
;
;       If the current mouse position is outside the box, it is moved to
;       the nearest point inside the box
;
;       The mouse buffer is NOT flushed - any buffered coords will be moved
;       inside the bounding box when they are read.
;
;       Reason code 2 - Define mouse multipliers
;
;       [R1, #1] : X multiplier         ; both treated as
;       [R1, #2] : Y multiplier         ; signed 8-bit values
;
;       Reason code 3 - Set mouse position
;
;       [R1, #1..2] : X position        ; both treated as
;       [R1, #3..4] : Y position        ; signed 16-bit values
;       The mouse buffer is flushed
;
;       Reason code 4 - Read mouse position (not buffered)
;
;       out: [R1, #1..2] : X position   ; both treated as
;            [R1, #3..4] : Y position   ; signed 16-bit values
;
;       Reason code 5 - Set pointer position
;
;       [R1, #1..2] : X position        ; both treated as
;       [R1, #3..4] : Y position        ; signed 16-bit values
;
;       Reason code 6 - Read pointer position
;
;       out: [R1, #1..2] : X position   ; both treated as
;            [R1, #3..4] : Y position   ; signed 16-bit values
;

DoPointerStuff ROUT
        LDRB    R0, [R1, #0]

        CMP     R0, #7

        LDRCC   PC, [PC, R0, LSL #2]
        MOV     PC, R14                 ; ***** WHY NO ERROR????????
        DCD     DoDefinePointer
        DCD     DoMouseBox
        DCD     SetMouseMult
        DCD     SetMousePosn
        DCD     ReadMousePosn
        DCD     SetPointerPosn
        DCD     ReadPointerPosn

; *****************************************************************************

DoDefinePointer

        ; We allow interrupts during time we copy shape, but we copy into a
        ; holding descriptor, so shape will never be displayed (whether its the
        ; current one, or becomes the current one with an OSByte 6A) until the
        ; vsync after we have a complete definition.
        ;
        ; We have two holding buffers, so that we can always choose a holding
        ; buffer that is not currently being used for display by the HAL,
        ; despite multiple definitions between vsyncs. This all assumes we
        ; are never re-entered, but the documentation for OS_Word 21,0 says
        ; re-entrancy undefined anyway - should really say not re-entrant.

        Push    "R1-R7, R14"

        ; interrupts still off for critical choosing of buffer
        ;
        ADD     R6, WsPtr, #PointerShapesH
        MOV     R7, #0                          ; try holding shape 1
        LDR     R14, [R6, R7, LSL #2]           ; R14 -> shape
        LDR     R2, [R14, #PointerBuffLA]       ; shape buffer we propose to use
        LDR     R0, [WsPtr, #PointerShapeLA]    ; shape buffer owned by HAL
        TEQ     R0, R2                          ; identical?
        MOVEQ   R7, #1                          ; alright then, holding shape 2
        LDREQ   R14, [R6, R7, LSL #2]           ; R14 -> shape

        ; now R7 = holding shape index (0,1), R14 -> shape, not owned by HAL

        CLRPSR  I_bit, R0                       ; re-enable interrupts

        LDRB    R6, [R1, #1]                    ; shape number we're defining
        SUB     R6, R6, #1
        CMP     R6, #4                          ; now in range 0..3 ?
        BCS     %FT90                           ; bad shape number

        LDRB    R0, [R1, #2]                    ; R0 = width (bytes)
        LDRB    R2, [R1, #3]                    ; R2 = height
        LDRB    R3, [R1, #4]                    ; R3 = ActiveX
        LDRB    R4, [R1, #5]                    ; R4 = ActiveY

        CMP     R2, #0                          ; C=1 if EQ
        STREQB  R2, [R14, #PointerWidth]
        STREQB  R2, [R14, #PointerHeight]
        BEQ     %FT80                           ; empty shape (off)

        CMP     R0, #0                          ; C=1 if EQ
        STREQB  R0, [R14, #PointerWidth]
        STREQB  R0, [R14, #PointerHeight]
        CMPNE   R0, #8+1
        BCS     %FT90                           ; bad width

        CMP     R2, #32+1                       ; C=1 => bad height
        CMPCC   R3, R0, LSL #2                  ; ActiveX >= (width * 4) ?
        CMPCC   R4, R2                          ; ActiveY >= height

        BCS     %FT90                           ; bad definition

        STRB    R0, [R14, #PointerWidth ]       ; actual width in bytes, before padding to constant 8
        STRB    R2, [R14, #PointerHeight]
        STRB    R3, [R14, #PointerActiveX]
        STRB    R4, [R14, #PointerActiveY]

        ADD     R4, R1, #6
        LDW     R1, R4, R3, R5                  ; load word from
                                                ; unknown alignment
; Now R1 -> user's data

        LDR     R3, [R14, #PointerBuffLA]       ; R3 -> buffer to receive shape
20
        ADD     R4, R3, R0                      ; terminating R3 for this row
30
        LDRB    R5, [R1], #1
40
        STRB    R5, [R3], #1                    ; store to buffer
        CMP     R3, R4                          ; still within user data
        BCC     %BT30                           ; for this row ?

; now fill up rest of row

        MOV     R5, #0
        TST     R3, #7                          ; are we on a multiple of 8
        BNE     %BT40                           ; no, then store 0

        SUBS    R2, R2, #1                      ; done all rows ?
        BNE     %BT20                           ; no, then loop

80
        ; we now have a completely defined shape in a holding buffer
        ;
        PHPSEI  R0                              ; disable interrupts for critical shape logic
        ADD     R3, WsPtr, #PointerShapes
        ADD     R4, WsPtr, #PointerShapesH
        LDR     R1, [R3, R6, LSL #2]            ; swap the holding shape (R7=0,1) into
        LDR     R2, [R4, R7, LSL #2]            ; the shape we've just defined (R6 = 0..3)
        STR     R2, [R3, R6, LSL #2]
        STR     R1, [R4, R7, LSL #2]
        PLP     R0                              ; restore interrupts
90
        Pull    "R1-R7,PC"


; *****************************************************************************
;
;       SetMouseRectangle - Called on mode change to set appropriate mouse
;                           rectangle and mouse position
;
; in:   WsPtr -> VDWS
;

SetMouseRectangle ROUT
        Push    R14

        ASSERT  DisplayYWindLimit = DisplayXWindLimit +4
        ASSERT  DisplayXEigFactor = DisplayXWindLimit +8
        ASSERT  DisplayYEigFactor = DisplayXWindLimit +12

        ADD     R2, WsPtr, #DisplayXWindLimit
        LDMIA   R2, {R2-R5}

        ADD     R2, R2, #1              ; XWindLimit+1
        MOV     R2, R2, LSL R4          ; (XWindLimit+1) << XEigFactor
        SUB     R4, R2, #1              ; ((XWindLimit+1) << XEigFactor)-1
        MOV     R2, R2, LSR #1          ; centre x of window

        ADD     R3, R3, #1              ; YWindLimit+1
        MOV     R3, R3, LSL R5          ; (YWindLimit+1) << YEigFactor
        SUB     R5, R3, #1              ; ((YWindLimit+1) << YEigFactor)-1
        MOV     R3, R3, LSR #1          ; centre y of window

        BL      SetMousePosnRegs

        MOV     R2, #0                  ; left = 0
        MOV     R3, #0                  ; bottom = 0

        Push    "R1-R6"
        B       DoMouseBoxRegs


DoMouseBox ROUT
        Push    "R1-R6, R14"

      [ NoARMv6 :LOR: NoUnaligned
        LDRB    R2, [R1, #1]            ; R2 = left
        LDRB    R0, [R1, #2]
        ORR     R2, R2, R0, LSL #8

        LDRB    R3, [R1, #3]            ; R3 = bottom
        LDRB    R0, [R1, #4]
        ORR     R3, R3, R0, LSL #8

        LDRB    R4, [R1, #5]            ; R4 = right
        LDRB    R0, [R1, #6]
        ORR     R4, R4, R0, LSL #8

        LDRB    R5, [R1, #7]            ; R5 = top
        LDRB    R0, [R1, #8]
        ORR     R5, R5, R0, LSL #8
      |
        ; Use unaligned loads from ARMv6
        LDRH    R2, [R1, #1]            ; R2 = left
        LDRH    R3, [R1, #3]            ; R3 = bottom
        LDRH    R4, [R1, #5]            ; R4 = right
        LDRH    R5, [R1, #7]            ; R5 = top
      ]

DoMouseBoxRegs

; now add on graphics origin

        LDR     R0, [WsPtr, #OrgX]
        ADD     R2, R2, R0
        ADD     R4, R4, R0
        LDR     R0, [WsPtr, #OrgY]
        ADD     R3, R3, R0
        ADD     R5, R5, R0

; now sign extend all coords

      [ NoARMv6
        MOV     R2, R2, LSL #16
        MOV     R2, R2, ASR #16
        MOV     R3, R3, LSL #16
        MOV     R3, R3, ASR #16
        MOV     R4, R4, LSL #16
        MOV     R4, R4, ASR #16
        MOV     R5, R5, LSL #16
        MOV     R5, R5, ASR #16
      |
        ; ARMv6 lets you do this using SXTH
        SXTH    R2, R2
        SXTH    R3, R3
        SXTH    R4, R4
        SXTH    R5, R5
      ]

; now check right >= left and top >= bottom

        CMP     R4, R2
        CMPGE   R5, R3
        BLT     %FT10                   ; bad definition

; everything seems OK, so disable IRQs while we update vars

        MRS     R14, CPSR
        ORR     R0, R14, #I32_bit
        MSR     CPSR_c, R0

        Push    R11
        LDR     R11, =ZeroPage+KeyWorkSpace

        ADR     R0, MouseBounds
        STMIA   R0, {R2-R5}

; check mouse position is within box

        LDR     R0, MouseX
        CMP     R0, R2                  ; if X < left
        STRLT   R2, MouseX              ; then X := left
        CMP     R4, R0                  ; if right < X
        STRLT   R4, MouseX              ; then X := right

        LDR     R0, MouseY
        CMP     R0, R3                  ; if Y < bottom
        STRLT   R3, MouseY              ; then Y := bottom
        CMP     R5, R0                  ; if top < Y
        STRLT   R5, MouseY              ; then Y := top

        Pull    R11

        MSR     CPSR_c, R14             ; restore old IRQ state
10
        Pull    "R1-R6, PC"

; *****************************************************************************
;
;       UpdatePointer - Called on vsync to update pointer position
;
; in:   WsPtr (R12) -> VduDriverWorkSpace
;       IRQs disabled, but can be enabled (n.b. may be in IRQ mode)
;
UpdatePointer ROUT
        Push    "R14"

        LDRB    R5, [WsPtr, #PointerShapeNumber]

        TST     R5, #&80                   ; pointer unlinked if bit 7 set

        LDREQ   R6, MouseX
        STREQ   R6, [WsPtr, #PointerX]
        LDREQ   R6, MouseY
        STREQ   R6, [WsPtr, #PointerY]

        ANDS    R5, R5, #&7F                 ; clear bit 7 and set Z if 0 ie off
        BNE     %FT20

10
        MOV     R0, #0                       ; flags = 0 (pointer off)
        MOV     R1, #0                       ; x = 0
        MOV     R2, #0                       ; y = 0
        MOV     R3, #0                       ; shape descriptor = NULL
        STR     R3, [WsPtr, #PointerShapeLA] ; NULL passed as last buffer address
        B       %FT40

20
        ADD     R3, WsPtr, #PointerShapes-4
        LDR     R3, [R3, R5, LSL #2]         ; R3 -> current shape block (R5 = shape 1..4)

        LDRB    R0, [R3, #PointerHeight]     ; height of 0 switches pointer off
        TEQ     R0, #0
        BEQ     %BT10

        MOV     R0, #1                       ; R0 = flags, set pointer on (bit 0 = 1)

        LDR     R1, [WsPtr, #PointerShapeLA] ; last shape buffer given to HAL
        LDR     R4, [R3, #PointerBuffLA]     ; shape buffer we're about to give
        TEQ     R1, R4                       ; same as last time?
        STRNE   R4, [WsPtr, #PointerShapeLA] ; update
        ORRNE   R0, R0, #2                   ; flag new shape (bit 1 = 1)

        LDR     R1, [WsPtr, #PointerX]
        LDRB    R4, [WsPtr, #PointerXEigFactor]
        MOV     R1, R1, ASR R4                     ; R1 = pointer x, pixels
        LDRB    R4, [R3, #PointerActiveX]
        SUB     R1, R1, R4                         ; R1 = pointer x, adjusted for active point

        LDR     R2, [WsPtr, #PointerY]
        LDR     R4, [WsPtr, #DisplayYEigFactor]
        LDR     R5, [WsPtr, #DisplayYWindLimit]    ; R5 = display height -1
        SUB     R2, R5, R2, ASR R4                 ; R2 = pointer y, pixels, inverted
        LDRB    R4, [R3, #PointerActiveY]
        SUB     R2, R2, R4                         ; R2 = pointer y, adjusted for active point

        ; and its up to the HAL to handle clipping according to h/w capabilities
40
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_UpdatePointer
        BL      CallGraphicsV

        ; Software pointer required?
        LDR     R5, [WsPtr, #GraphicsVFeatures]
        TST     R5, #GVDisplayFeature_HardwarePointer
        Pull    "pc", NE

        ; Software pointer code can run with IRQs enabled; drop into SVC mode
        MRS     R6, CPSR                     ; Currently we should always be in IRQ mode here, but read current mode just in case
        MSR     CPSR_c, #SVC32_mode
        MOV     R5, R14

        ; If the call wasn't claimed, pass on to software pointer code
        ; If the call was claimed, we need to make sure the software pointer is off
        TEQ     R4, #0
        MOVEQ   R0, #0
        BL      UpdateSoftwarePointer

        MOV     R14, R5
        MSR     CPSR_c, R6
        Pull    "pc"

        LTORG

; *****************************************************************************

SetMouseMult ROUT
        Push    "R11,R14"
        LDR     R11, =ZeroPage+KeyWorkSpace

      [ NoARMv4
        LDRB    R0, [R1, #1]
        MOV     R0, R0, ASL #24         ; sign extend to 32 bits
        MOV     R0, R0, ASR #24
      |
        LDRSB   R0, [R1, #1]
      ]
        STR     R0, MouseXMult

      [ NoARMv4
        LDRB    R0, [R1, #2]
        MOV     R0, R0, ASL #24         ; sign extend to 32 bits
        MOV     R0, R0, ASR #24
      |
        LDRSB   R0, [R1, #2]
      ]
        STR     R0, MouseYMult

        Pull    "R11,PC"

; *****************************************************************************
;
;       GetCoordPair - get pair of 2-byte coords from R1+1..R1+4
;       adds on graphics origin and sign extends to 32 bits
;       and puts X into R2, Y into R3
;

GetCoordPair ROUT
      [ NoARMv6 :LOR: NoUnaligned
        LDRB    R0, [R1, #1]            ; get X coordinate
        LDRB    R2, [R1, #2]
        ORR     R0, R0, R2, LSL #8
      |
        ; Use unaligned loads and SXTH from ARMv6
        LDRH    R0, [R1, #1]            ; get X coordinate
      ]

        LDR     R2, [WsPtr, #OrgX]      ; add on origin
        ADD     R0, R0, R2

      [ NoARMv6
        MOV     R0, R0, ASL #16         ; sign extend 16 to 32
        MOV     R2, R0, ASR #16
      |
        SXTH    R2, R0
      ]

      [ NoARMv6 :LOR: NoUnaligned
        LDRB    R0, [R1, #3]            ; get Y coordinate
        LDRB    R3, [R1, #4]
        ORR     R0, R0, R3, LSL #8
      |
        LDRH    R0, [R1, #3]            ; get Y coordinate
      ]

        LDR     R3, [WsPtr, #OrgY]      ; add on origin
        ADD     R0, R0, R3

      [ NoARMv6
        MOV     R0, R0, ASL #16         ; sign extend 16 to 32
        MOV     R3, R0, ASR #16
      |
        SXTH    R3, R0
      ]

        MOV     PC, R14

; *****************************************************************************

SetMousePosn ROUT
        Push    "R2, R3, R11, R14"
        LDR     R11, =ZeroPage+KeyWorkSpace

        BL      GetCoordPair

; now check point is within bounding box

        LDR     R0, MouseBoundLCol
        CMP     R2, R0
        LDRGE   R0, MouseBoundRCol
        CMPGE   R0, R2
        LDRGE   R0, MouseBoundBRow
        CMPGE   R3, R0
        LDRGE   R0, MouseBoundTRow
        CMPGE   R0, R3

        BLGE    SetMousePosnRegs

        Pull    "R2, R3, R11, PC"

SetMousePosnRegs
        LDR     R11, =ZeroPage+KeyWorkSpace
        STR     R2, MouseX
        STR     R3, MouseY
        B       FlushMouse

; *****************************************************************************
;
;       StoreCoordPair - Stores X,Y coords in R2,R3 in R1+1..R1+4
;       subtracts graphics origin

StoreCoordPair ROUT

        LDR     R0, [WsPtr, #OrgX]      ; subtract off origin
        SUB     R2, R2, R0

      [ NoARMv6 :LOR: NoUnaligned
        STRB    R2, [R1, #1]            ; store lo-byte of X
        MOV     R2, R2, LSR #8
        STRB    R2, [R1, #2]            ; store hi-byte of X
      |
        ; Use unaligned store from ARMv6
        STRH    R2, [R1, #1]            ; store X
      ]

        LDR     R0, [WsPtr, #OrgY]      ; subtract off origin
        SUB     R3, R3, R0

      [ NoARMv6 :LOR: NoUnaligned
        STRB    R3, [R1, #3]            ; store lo-byte of Y
        MOV     R3, R3, LSR #8
        STRB    R3, [R1, #4]            ; store hi-byte of Y
      |
        ; Use unaligned store from ARMv6
        STRH    R3, [R1, #3]            ; store X
      ]

        MOV     PC, R14

; *****************************************************************************

ReadMousePosn ROUT
        Push    "r0-r3, r9-r11, lr"
        BL      PollPointer             ; update mouse position on a read
        LDR     r1, [sp, #1*4]          ; reload pointer to buffer
        LDR     R11, =ZeroPage+KeyWorkSpace

        LDR     R2, MouseX              ; get mouse X
        LDR     R3, MouseY              ; get mouse Y
        BL      StoreCoordPair
        Pull    "r0-r3, r9-r11, pc"

; *****************************************************************************

SetPointerPosn ROUT
        Push    "R2, R3, R14"

        BL      GetCoordPair

        STR     R2, [WsPtr, #PointerX]
        STR     R3, [WsPtr, #PointerY]

        Pull    "R2, R3, PC"

; *****************************************************************************

ReadPointerPosn ROUT
        Push    "R2, R3, R14"

        LDR     R2, [WsPtr, #PointerX]
        LDR     R3, [WsPtr, #PointerY]
        BL      StoreCoordPair

        Pull    "R2, R3, PC"

; *****************************************************************************
;
;       FlushMouse - Flush mouse buffer
;
; out:  All registers preserved

FlushMouse ROUT
        Push    "R0-R2, R14"
        MOV     R0, #21
        MOV     R1, #Buff_Mouse
        SWI     XOS_Byte
        Pull    "R0-R2, PC"

        LTORG

; *****************************************************************************
;
;       RemovePointer - Remove soft mouse pointer from screen
;
; in:   WsPtr -> VduDriverWorkspace
; out:  flags preserved

RemovePointer ROUT
        EntryS  "r10-r11"
        LDRB    r10, [WsPtr, #SWP_Mutex]
        TEQ     r10, #0
        BNE     %FT90
        ; Lock mutex
        MOV     r10, #1
        STRB    r10, [WsPtr, #SWP_Mutex]
        ; We need to set SWP_Restore so that we know to release the mutex once we're done
        ; However if the software pointer currently isn't visible (hardware pointer in use) then there might not be an image to restore
        ; So SWP_Restore can take three values:
        ; 0 -> not in RemovePointer block
        ; 1 -> in RemovePointer but no restore needed
        ; 2 -> in RemovePointer and restore needed
        LDR     r11, [WsPtr, #SWP_Pos]
        TEQ     r11, #0
        MOVNE   r10, #2
        STRB    r10, [WsPtr, #SWP_Restore]
        ; Remove pointer if necessary
        LDRNE   r10, [WsPtr, #SWP_Under]
        BLNE    RemoveSoftwarePointer
        ; Exit with mutex still locked
90
        EXITS

; *****************************************************************************
;
;       RestorePointer - Restore soft mouse pointer to previous state
;
; in:   WsPtr -> VduDriverWorkspace
;       Software pointer restore assumed to be needed

RestorePointer ROUT
        STMFD   R13!,{R0-R7,R14}
        PHPSEI  R7                           ; IRQs off while we work out what to do
        LDRB    R1, [WsPtr, #SWP_Restore]
        MOV     R0, #0
        STRB    R0, [WsPtr, #SWP_Restore]
        STRB    R0, [WsPtr, #SWP_Mutex]
        LDRB    R6, [WsPtr, #PointerShapeNumber]
        TST     R1, #2                       ; Was the software pointer actually on?
        ANDNES  R6, R6, #&7F
        BEQ     %FT90

        ADD     R3, WsPtr, #PointerShapes-4
        LDR     R3, [R3, R6, LSL #2]         ; R3 -> current shape block (R6 = shape 1..4)

        MOV     R0, #1                       ; R0 = flags, set pointer on (bit 0 = 1)

        LDR     R1, [WsPtr, #PointerShapeLA] ; last shape buffer given to HAL
        LDR     R4, [R3, #PointerBuffLA]     ; shape buffer we're about to give
        TEQ     R1, R4                       ; same as last time?
        STRNE   R4, [WsPtr, #PointerShapeLA] ; update
        ORRNE   R0, R0, #2                   ; flag new shape (bit 1 = 1)

        LDR     R1, [WsPtr, #PointerX]
        LDRB    R4, [WsPtr, #PointerXEigFactor]
        MOV     R1, R1, ASR R4                     ; R1 = pointer x, pixels
        LDRB    R4, [R3, #PointerActiveX]
        SUB     R1, R1, R4                         ; R1 = pointer x, adjusted for active point

        LDR     R2, [WsPtr, #PointerY]
        LDR     R4, [WsPtr, #DisplayYEigFactor]
        LDR     R5, [WsPtr, #DisplayYWindLimit]    ; R5 = display height -1
        SUB     R2, R5, R2, ASR R4                 ; R2 = pointer y, pixels, inverted
        LDRB    R4, [R3, #PointerActiveY]
        SUB     R2, R2, R4                         ; R2 = pointer y, adjusted for active point

        ; The pointer may have moved while we had it disabled.
        ; If it has moved, it's possible the hardware pointer has taken over
        ; and the software pointer isn't needed anymore
        ; Potentially we could deal with this inside UpdateSoftwarePointer
        ; (i.e. cache the new parameters if it gets called with the mutex
        ; locked), but that will add a fair bit of complexity. So for now go
        ; with the simpler approach of comparing the current position against
        ; the last position used by the software pointer and calling through to
        ; GraphicsV if it's changed (otherwise, call software pointer directly)

      [ NoARMv6
        MOV     R5, R1, LSL #16
        MOV     LR, R2, LSL #16
        ORR     R5, LR, R5, LSR #16
      |
        PKHBT   R5, R1, R2, LSL #16
      ]
        LDR     LR, [WsPtr, #SWP_Coords]
        TEQ     LR, R5
        BEQ     %FT50

        ; Pointer has moved - call GraphicsV
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_UpdatePointer
        BL      CallGraphicsV

        TEQ     R4, #0
        BEQ     %FT90

50
        ; IRQs on for software pointer call
        ; This does open up the possibility for the pointer shape/location to
        ; change under IRQ while we're still rendering it - so a more advanced
        ; locking mechanism may be desirable in future
        PLP     R7

        BL      UpdateSoftwarePointer
90
        PLP     R7
        LDMFD   R13!,{R0-R7,PC}

; *****************************************************************************
;
;       UpdateSoftwarePointer - Like GraphicsV_UpdatePointer, but for the
;                               software pointer
;
; in:   r0-r3 as per GraphicsV_UpdatePointer
;       WsPtr -> VduDriverWorkSpace

UpdateSoftwarePointer ROUT
        Entry   "r10-r11"
        ; Is the pointer possible?
        LDR     r10, [WsPtr, #SWP_Under]
        TEQ     r10, #0
        BEQ     %FT99
        ; Is mutex locked?
        LDRB    r11, [WsPtr, #SWP_Mutex]
        TEQ     r11, #0
        BNE     %FT99
        MOV     r11, #1
        STRB    r11, [WsPtr, #SWP_Mutex]
        ; Is pointer in same state as last time?
      [ NoARMv6
        MOV     r11, r1, LSL #16
        MOV     lr, r2, LSL #16
        ORR     r11, lr, r11, LSR #16
      |
        PKHBT   r11, r1, r2, LSL #16
      ]
        LDR     lr, [WsPtr, #SWP_Coords]
        TEQ     r11, lr ; Have coords changed?
        STRNE   r11, [WsPtr, #SWP_Coords]
        TSTEQ   r0, #2 ; Has shape changed?
        LDREQB  lr, [WsPtr, #SWP_Dirty]
        LDR     r11, [WsPtr, #SWP_Pos]
        TEQEQ   lr, #0 ; Has palette changed?
        BNE     %FT20
        ; The above state variables only track correctly for when the pointer is on. So we can only skip if it's currently on, and it's staying on.
        TEQ     r11, #0
        TSTNE   r0, #1
        BNE     %FT90
20
        ; Remove from previous position, if any
        TEQ     r11, #0
        BLNE    RemoveSoftwarePointer
        ; Plot in new position, if any
        TST     r0, #1
        BLNE    PlotSoftwarePointer
90
        ; Release mutex
        MOV     r11, #0
        STRB    r11, [WsPtr, #SWP_Mutex]
99
        EXIT

; *****************************************************************************
;
;       PlotSoftwarePointer - Plot software pointer to the screen
;
; in:   r1 = X position
;       r2 = Y position
;       r3 -> PointerBlkHAL
;       WsPtr -> VduDriverWorkSpace

PlotSoftwarePointer ROUT
        Entry   "r0-r11"
        ; Load shape info
        LDRB    r5, [r3, #PointerHeight]
        LDRB    r4, [r3, #PointerWidth]
        CMP     r5, #32
        LDR     r3, [r3, #PointerBuffLA]
        MOVGT   r5, #32
        ; Load screen info
        ; Must be careful to only use variables which aren't affected by output redirection
        LDR     r0, [WsPtr, #DisplayBankAddr]
        LDR     r6, [WsPtr, #DisplayXWindLimit]
        LDR     r7, [WsPtr, #DisplayYWindLimit]
        LDRB    r9, [WsPtr, #DisplayLog2BPP]
        ADD     r6, r6, #1
        ADD     r7, r7, #1
        MOV     r8, #0 ; Start X offset into pointer image (bits)
        MOV     r4, r4, LSL #2 ; byte width -> pixel width
        STRB    r8, [WsPtr, #SWP_Dirty]

        ; Do a quick scan of the image to see if the LHS is fully transparent
        ; This is the case for the default pointer image, at least
        CMP     r5, #0 ; Height can be zero on startup!
        ADD     r11, r3, r5, LSL #3
        BLE     %FT99
        MOV     r10, #0
10
        LDR     lr, [r11, #-8]!
        CMP     r11, r3
        ORR     r10, r10, lr
        BNE     %BT10
        TEQ     r10, #0
        ADDEQ   r8, r8, #32
        ADDEQ   r1, r1, #16
        SUBEQ   r4, r4, #16

        ; Crop image to screen
        CMP     r1, #0
        ADDLT   r4, r4, r1
        SUBLT   r8, r8, r1, LSL #1
        MOVLT   r1, #0
        ADD     lr, r1, r4
        SUBS    lr, lr, r6
        SUBGT   r4, r4, lr

        CMP     r2, #0
        ADDLT   r5, r5, r2
        SUBLT   r3, r3, r2, LSL #3
        MOVLT   r2, #0
        ADD     lr, r2, r5
        SUBS    lr, lr, r7
        SUBGT   r5, r5, lr

        ; Bail if fully off-screen
        CMP     r4, #0
        CMPGT   r5, #0
        BLE     %FT99

        LDR     r7, [WsPtr, #DisplayLineLength]
        MLA     r0, r7, r2, r0 ; First screen row to touch

        MOV     r1, r1, LSL r9 ; Screen X start, in bits

        ; Save the rectangle under the pointer
        ADR     lr, %FT30
        Push    "r0-r12,lr" ; For RemoveSoftwarePointerAltEntry
        ; Make things easier by converting to word-aligned coordinates
        ADD     lr, r1, r4, LSL r9 ; Screen X end, in bits
        ADD     lr, lr, #31
        MOV     r1, r1, LSR #5 ; X start in words
        RSB     r4, r1, lr, LSR #5 ; width in words

        ; Calculate screen addr to copy from
        ADD     r10, r0, r1, LSL #2 ; Copy dest

        ; Remember image size, position for restore later on
        STR     r10, [WsPtr, #SWP_Pos]
        STRB    r4, [WsPtr, #SWP_W]
        STRB    r5, [WsPtr, #SWP_H]

        ; Copy to SWP_Under
        ; Can reuse copy loop in RemoveSoftwarePointer
        SUB     r6, r7, r4, LSL #2 ; Src stride
        MOV     r7, #0 ; Dest stride
        LDR     r11, [WsPtr, #SWP_Under] ; Copy src
        B       RemoveSoftwarePointerAltEntry
30
        ; Arrive back here with r0-r12 restored
        ; Important values:
        ; r0 -> initial screen row
        ; r1 = screen X start, in bits
        ; r3 -> initial pointer row
        ; r4 = pointer pixel width
        ; r5 = height
        ; r7 = LineLength
        ; r8 = pointer X start, in bits
        ; r9 = Log2BPP
        ; For 32bpp modes we have a faster plotter available
        TEQ     r9, #5
        BEQ     %FT70
        ; Calculate end-of-row shift amount
        ADD     lr, r1, r4, LSL r9
        AND     lr, lr, #31
        RSB     lr, lr, #32
        ORR     lr, lr, lr, LSR #5 ; Use 33 to represent case where no shift is needed - ensures the MOVS clears C
        Push    "lr"
        ; Convert Log2BPP to BPP
        MOV     lr, #1
        MOV     r9, lr, LSL r9
        LDR     r10, =ZeroPage+VduDriverWorkSpace+SWP_Palette-4
        ; Conveniently, we can read screen words from SWP_Under, avoiding slow read-modify-write of screen memory
        LDR     r11, [WsPtr, #SWP_Under]
        ; Offset r0 to point at first word in row, compute initial mask word
        AND     lr, r1, #31
        ADD     r0, r0, r1, LSR #3
        MOV     r6, #&80000000
        BIC     r0, r0, #3 ; Row ptr assumed to be word aligned!
        MOV     r6, r6, LSR lr
        Push    "r0,r4,r6,r7,r8"
40
        ; Since the pointer is padded out to 32 pixels wide, it's easiest to
        ; just load an entire row and treat it as a 64 bit value
        LDMIA   r3!, {r1, r2}
        ; Skip the initial pixels
        TST     r8, #32
        AND     lr, r8, #31
        MOVNE   r1, r2
        RSB     r7, lr, #32
        MOV     r1, r1, LSR lr
        MVN     r8, #0
        ORR     r1, r1, r2, LSL r7
        MOV     r2, r2, LSR lr
        BIC     r8, r8, r8, LSR r9 ; Value to merge into mask word
        MOV     r7, #0
50
        ANDS    lr, r1, #3
        MOV     r1, r1, LSR #2
        LDRNE   lr, [r10, lr, LSL #2]
        ORR     r1, r1, r2, LSL #30
        ORR     r7, lr, r7, LSR r9 ; Merge in output pixel, 0 if transparent
        MOVNE   lr, r8
        MOV     r2, r2, LSR #2
        ORRS    r6, lr, r6, LSR r9 ; Merge in mask, 0 if transparent
        BCC     %FT60
        ; Store completed screen word
        ; EQ condition if fully transparent
        BEQ     %FT55
        LDR     lr, [r11]
        BIC     lr, lr, r6
        ORR     lr, lr, r7
        STR     lr, [r0]
55
        ADD     r11, r11, #4
        ADD     r0, r0, #4
        MOV     r6, #&80000000
60
        SUBS    r4, r4, #1
        BGT     %BT50
        ; Next row
        ; However, we may have a partial word to store
        ; Shift it down to the low end of the word, ready to store
        LDR     lr, [sp, #5*4] ; Grab precomputed shift amount
        MOVS    r6, r6, LSR lr
        MOV     r7, r7, LSR lr
        BLS     %FT65 ; ~C if no shift needed (actually, lr=33 to ensure C gets cleared), C+Z if word is transparent, C+~Z if visible
        LDR     lr, [r11]
        BIC     lr, lr, r6
        ORR     lr, lr, r7
        STR     lr, [r0]
65
        ADDCS   r11, r11, #4
        ; Last word dealt with
        ; Advance to next row
        LDMIA   sp, {r0,r4,r6,r7,r8}
        SUBS    r5, r5, #1
        ADD     r0, r0, r7
        STRNE   r0, [sp]               
        BNE     %BT40
        ; Junk stack contents
        ADD     sp, sp, #6*4
99
        EXIT

70
        ; Plotter for 32bpp modes
        ; No need to read from the screen, just blast out any non-transparent
        ; pixels
        LDR     r10, =ZeroPage+VduDriverWorkSpace+SWP_Palette-4
        ; Offset r0 to point at first word in row
        ADD     r0, r0, r1, LSR #3
        ; Calculate shift amount for pointer row
        AND     r6, r8, #31
        RSB     r11, r6, #32
        Push    "r0,r4"
75
        ; Since the pointer is padded out to 32 pixels wide, it's easiest to
        ; just load an entire row and treat it as a 64 bit value
        LDMIA   r3!, {r1, r2}
        ; Skip the initial pixels
        TST     r8, #32
        MOVNE   r1, r2
        MOV     r1, r1, LSR r6
        ORR     r1, r1, r2, LSL r11
        MOV     r2, r2, LSR r6
80
        ANDS    lr, r1, #3
        MOV     r1, r1, LSR #2
        LDRNE   lr, [r10, lr, LSL #2]
        ORR     r1, r1, r2, LSL #30
        MOV     r2, r2, LSR #2
        STRNE   lr, [r0]
        SUBS    r4, r4, #1
        ORRNES  lr, r1, r2 ; Stop if remainder of row is transparent
        ADD     r0, r0, #4
        BNE     %BT80
        ; Next row
        LDMIA   sp, {r0,r4}
        SUBS    r5, r5, #1
        ADD     r0, r0, r7
        STRNE   r0, [sp]               
        BNE     %BT75
        ; Junk stack contents
        ADD     sp, sp, #2*4
        EXIT
        


; *****************************************************************************
;
;       RemoveSoftwarePointer - Remove software pointer from the screen
;
; in:   r10 -> SWP_Under
;       r11 -> SWP_Pos
;       WsPtr -> VduDriverWorkSpace

RemoveSoftwarePointer
        Entry   "r0-r12" ; n.b. keep in sync with call from PlotSoftwarePointer
        ; Get parameters needed for unplot
        LDRB    r4, [WsPtr, #SWP_W]
        LDRB    r5, [WsPtr, #SWP_H]
        LDR     r6, [WsPtr, #DisplayLineLength]
        SUB     r7, r6, r4, LSL #2 ; Dest stride
        MOV     r6, #0 ; Src stride
        STR     r6, [WsPtr, #SWP_Pos]
RemoveSoftwarePointerAltEntry        
        ; Width assumed to be max of 32 words
        ; r0-r3, r8-r9, r12, lr free for use
        Push    "r4"
05
        ; Width will almost always be >= 8, so transfer groups of 8 first
        CMP     r4, #8
06
        LDMGEIA r10!, {r0-r3, r8-r9, r12, lr}
        SUBGE   r4, r4, #8
        STMGEIA r11!, {r0-r3, r8-r9, r12, lr}
        BEQ     %FT90
        CMP     r4, #8
        BGE     %BT06
        ; Transfer remainder
        MOVS    r4, r4, LSR #1
        LDRCS   r0, [r10], #4
        STRCS   r0, [r11], #4
        BEQ     %FT90
        MOVS    r4, r4, LSR #1
        LDMCSIA r10!, {r0-r1}
        STMCSIA r11!, {r0-r1}
        BEQ     %FT90
        ; NE so must be 4 left
        LDMIA   r10!, {r0-r3}
        STMIA   r11!, {r0-r3}
90
        LDR     r4, [sp]
        ADD     r10, r10, r6
        SUBS    r5, r5, #1
        ADD     r11, r11, r7
        BNE     %BT05
        ADD     sp, sp, #4
        EXIT

; *****************************************************************************
;
;       RegisterSoftwarePointerCallback - Register callback for palette update
;
; in:   WsPtr -> VduDriverWorkSpace

RegisterSoftwarePointerCallback
        Entry   "r0-r2"
        ; We may be in IRQ mode, so switch to SVC before calling SWI
        MRS     r2, CPSR
        ORR     r1, r2, #SVC32_mode
        MSR     CPSR_c, r1
        Push    "lr"
        ADR     r0, SoftwarePointerCallback
        MOV     r1, WsPtr
        SWI     XOS_AddCallBack
        MOVVC   r0, #1
        STRVCB  r0, [WsPtr, #SWP_Callback]
        Pull    "lr"
        MSR     CPSR_c, r2
        EXIT

; *****************************************************************************
;
;       SoftwarePointerCallback - Recalculate software pointer palette
;
; in:   WsPtr -> VduDriverWorkSpace

SoftwarePointerCallback
        Entry   "r0-r3"
        MOV     r0, #0
        STRB    r0, [WsPtr, #SWP_Callback]
        ; Can now enable IRQs (ColourTrans may be slow!)
        MSR     CPSR_c, #SVC32_mode
        ; Grab the three pointer colours and translate them
        ; We want to shift the result up to the high end of each word
        LDRB    r0, [WsPtr, #DisplayLog2BPP]
        MOV     r1, #1
        MOV     r0, r1, LSL r0
        RSB     r3, r0, #32
        LDR     r2, [WsPtr, #FirPalAddr]
        LDR     r1, [WsPtr, #DisplayModeNo]
        LDR     r0, [r2, #257*4]
        SWI     XColourTrans_ReturnColourNumberForMode
        MOV     r0, r0, LSL r3
        STR     r0, [WsPtr, #SWP_Palette]
        LDR     r0, [r2, #258*4]
        SWI     XColourTrans_ReturnColourNumberForMode
        MOV     r0, r0, LSL r3
        STR     r0, [WsPtr, #SWP_Palette+4]
        LDR     r0, [r2, #259*4]
        SWI     XColourTrans_ReturnColourNumberForMode
        MOV     r0, r0, LSL r3
        STR     r0, [WsPtr, #SWP_Palette+8]
        STRB    r1, [WsPtr, #SWP_Dirty]
        EXIT

        LTORG

        END
@


4.5
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d847 1
a847 2
        MOV     r7, r6, LSL r9
        MOV     r7, r7, LSR #3 ; LineLen
d883 1
a883 1
        ; r7 = LineLen
d1029 1
a1029 5
        LDR     r6, [WsPtr, #DisplayXWindLimit]
        LDRB    r9, [WsPtr, #DisplayLog2BPP]
        ADD     r6, r6, #1
        MOV     r6, r6, LSL r9
        MOV     r6, r6, LSR #3
@


4.4
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a560 1
 [ AssemblePointerV :LAND: {TRUE}
a570 11
 |
        Push    "R2, R3, R11, R14"
        LDR     R11, =ZeroPage+KeyWorkSpace

        LDR     R2, MouseX              ; get mouse X
        LDR     R3, MouseY              ; get mouse Y
        BL      StoreCoordPair

        Pull    "R2, R3, R11, PC"
 ]

@


4.3
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d17 6
a101 1
        [ STB
a102 38
        Push    "R1-R6, R14"
        CLRPSR  I_bit, R0                       ; could take some time

        MOV     R0, #19                         ; wait for vsync, so we change
        SWI     XOS_Byte                        ; cleanly (ignore errors)

        LDMFD   R13, {R1}                       ; get back pointer to block

        LDRB    R6, [R1, #1]                    ; shape number
        SUB     R6, R6, #1
        CMP     R6, #4                          ; now in range 0..3 ?
        BCS     %FT10                           ; bad shape number

        ADD     WsPtr, WsPtr, R6                ; point to table entries

        LDRB    R0, [R1, #2]                    ; R0 = width
        LDRB    R2, [R1, #3]                    ; R2 = height
        LDRB    R3, [R1, #4]                    ; R3 = ActiveX
        LDRB    R4, [R1, #5]                    ; R4 = ActiveY

        CMP     R2, #0                          ; C=1 if EQ
        STREQB  R2, [WsPtr, #PointerHeights]
        BEQ     %FT10

        CMP     R0, #0                          ; C=1 if EQ
        STREQB  R0, [WsPtr, #PointerHeights]
        CMPNE   R0, #8+1
        BCS     %FT10                           ; bad width

        CMP     R2, #32+1                       ; C=1 => bad height
        CMPCC   R3, R0, LSL #2                  ; ActiveX >= (width * 4) ?
        CMPCC   R4, R2                          ; ActiveY >= height

        BCS     %FT10                           ; bad definition

        STRB    R2, [WsPtr, #PointerHeights]
        STRB    R3, [WsPtr, #PointerActiveXs]
        STRB    R4, [WsPtr, #PointerActiveYs]
d104 23
a126 21
        ADD     R4, R1, #6
        LDW     R1, R4, R3, R5                  ; load word from
                                                ; unknown alignment
; Now R1 -> user's data

        LDR     R3, =CursorData                 ; &200 per shape, so
        ADD     R3, R3, R6, LSL #9              ; R3 -> first copy
 [ :LNOT: InterlacedPointer
        ADD     R6, R3, #&F8                    ; R6 -> second copy
 ]
20
        ADD     R4, R3, R0                      ; terminating R3 for this row
30
        LDRB    R5, [R1], #1
40
        STRB    R5, [R3], #1                    ; store to 1st copy
 [ :LNOT: InterlacedPointer
        STRB    R5, [R6], #1                    ; store to 2nd copy
 ]
        CMP     R3, R4                          ; still within user data
        BCC     %BT30                           ; for this row ?
d128 1
a128 1
; now fill up rest of row
d130 1
a130 3
        MOV     R5, #0
        TST     R3, #7                          ; are we on a multiple of 8
        BNE     %BT40                           ; no, then store 0
d132 1
a132 14
        SUBS    R2, R2, #1                      ; done all rows ?
        BNE     %BT20                           ; no, then loop

10
        Pull    "R1-R6,PC"
        |
DoDefinePointer ;Only copies the pointer defn into the defn buffer. OSByte 6A now copies the defn into the 'current' buffer -WT
        Push    "R1-R6, R14"

        CLRPSR  I_bit, R0                       ; could take some time

        LDMFD   R13, {R1}                       ; get back pointer to block

        LDRB    R6, [R1, #1]                    ; shape number
d135 1
a135 3
        BCS     %FT10                           ; bad shape number

        ADD     WsPtr, WsPtr, R6                ; point to table entries
d137 1
a137 1
        LDRB    R0, [R1, #2]                    ; R0 = width
d143 3
a145 2
        STREQB  R2, [WsPtr, #PointerHeights]
        BEQ     %FT10
d148 2
a149 1
        STREQB  R0, [WsPtr, #PointerHeights]
d151 1
a151 1
        BCS     %FT10                           ; bad width
d157 1
a157 1
        BCS     %FT10                           ; bad definition
d159 4
a162 3
        STRB    R2, [WsPtr, #PointerHeights]
        STRB    R3, [WsPtr, #PointerActiveXs]
        STRB    R4, [WsPtr, #PointerActiveYs]
d169 1
a169 3
        LDR     R3, =CursorData                 ; &100 per shape, 8 copies (4 current + 4 pointer definitions)
        ADD     R3, R3, #&400                   ; Skip the 'current' copies
        ADD     R3, R3, R6, LSL #8              ; R3 -> place to dump pointer definition
d175 1
a175 1
        STRB    R5, [R3], #1                    ; store to 1st copy
d188 13
a200 40
        ;Check whether the pointer we've just updated is the current one & if so, call OSByte 6A to update the current buffers.
        LDRB    R1, [WsPtr, #PointerShapeNumber]
        AND     R5, R1, #&7F                    ; Clear bit 7 from the ptrshapenumber - it is irrelevant atm.
        ADD     R6, R6, #1                      ; Get R6 back to range 1-4

        TEQ     R5, R6
        STREQB  R6, [WsPtr, #PointerShapeChanged]

10
        Pull    "R1-R6,PC"

        ]

 [ :LNOT:STB
 ; Entry: R5 = pointer shape required (0-3)
SetUpPointerShape ROUT
        ENTRY   "r0-r12"
        LDR     R0, =CursorData
        MOV     R1, R0                          ;R1 points to 1st current image
        ADD     R0, R0, #&400                   ;R0 points to the start of the buffer images
        ADD     R0, R0, R5, LSL #8              ;Now, it points to the source buffer image
        ADD     R2, R1, #&100                   ;R2 points to 2nd current image
        ADD     R3, R2, #&F8                    ;R3 points to 3rd current image (top line will get lost, on purpose!)
        ADD     R4, R3, #&100                   ;R4 points to 4th current image (correct wrt 3rd image)

;StrongARM note: cursor area is now marked cacheable/bufferable (so that SWI despatch etc. is also)
;However, since the area for the current cursor (@@ CursorData, &400 bytes) is never read by RISC OS,
;it can never be in the cache, so there is no need to clean the write-back cache to force the new data
;out. All that remain is the write buffer, but this will drain quickly without help.
;
        ADD     R5, R0, #&100                   ;R5 is the end address.
11      LDMIA   R0!, {R6-R12,R14}
        STMIA   R1!, {R6-R12,R14}
        STMIA   R2!, {R6-R12,R14}
        STMIA   R3!, {R6-R12,R14}
        STMIA   R4!, {R6-R12,R14}
        CMP     R0, R5
        BNE     %BT11                           ;Keep going, more to do

        EXIT
a201 1
 ]
d243 1
d259 7
d280 1
d289 7
d305 1
a305 1
        mrs    ,R14, CPSR
d307 1
a307 1
        msr    ,CPSR_c, R0
d310 1
a310 1
        MOV     R11, #KeyWorkSpace
d331 1
a331 1
        msr    ,CPSR_c, R14             ; restore old IRQ state
d340 1
a341 1
        [ STB
d343 1
a343 2
        MOV     R11, #KeyWorkSpace
        MOV     R10, #VIDC
a345 179
        TST     R5, #&80                ; pointer unlinked if bit 7 set

        LDREQ   R6, MouseX
        STREQ   R6, [WsPtr, #PointerX]
        LDREQ   R6, MouseY
        STREQ   R6, [WsPtr, #PointerY]

        ANDS    R5, R5, #&7F            ; clear bit 7 and set Z if 0 ie off
        SUBNE   R5, R5, #1
        ADDNE   R6, WsPtr, R5           ; R6 is WsPtr + index

        LDRNEB  R0, [R6, #PointerHeights]
        TEQNE   R0, #0                  ; if shape 0 or height 0
        BNE     %FT07
05

; don't display pointer

        MOV     R1, #0                  ; Y := 0
        MOV     R2, #0                  ; height := 0
        MOV     R4, #0                  ; LAG offset := 0
        B       %FT10

07
        LDR     R2, [WsPtr, #PointerXEigFactor]
        LDR     R3, [WsPtr, #PointerX]
        MOV     R3, R3, ASR R2

        LDRB    R2, [R6, #PointerActiveXs]
        SUB     R3, R3, R2              ; subtract off active point coord

        CMP     R3, #-31                ; if LHS < -31, ie RHS < 0
        BLT     %BT05                   ; then remove pointer completely (fixes MED-00523)

        LDR     R1, [WsPtr, #CursorFudgeFactor]
        ADDS    R3, R3, R1              ; X := X + CursFudgeFactor
        MOVLT   R3, #0                  ; if < 0 then make =0

        CMP     R3, #16*1024            ; if >= limit then make =limit-1
        MOVGE   R3, #16*1024
        SUBGE   R3, R3, #1

        ORR     R3, R3, #HorizCursorStart

 [ {FALSE} ; debug horiz pointer programming
        Push    "r0,lr"
        MOV     r0, r3
        BL      TubeDumpR0
        BL      TubeNewl
        Pull    "r0,lr"
 ]

        STR     R3, [R10]

; now process Y

        LDR     R1, [WsPtr, #PointerY]
        LDR     R2, [WsPtr, #DisplayYEigFactor]

        LDR     R3, [WsPtr, #DisplayYWindLimit]
                                        ; Total height of screen in pixels-1
 [ InterlacedPointer
	MOV	r8, r5, LSL #9		; LAG offset from CursorData
	LDR	r5, [WsPtr, #DisplayModeFlags]
	TST	r5, #Flag_InterlacedMode ; if not interlaced mode
	LDRB	r5, [r6, #PointerActiveYs] ; (load active Y in both cases)
	SUBEQ	r1, r3, r1, ASR r2	; then convert Y to pixels and invert
	SUBEQ	r1, r1, r5		; and subtract off active Y
	MOVEQ	r7, #3			; log2(offset from one row to next for copy)
	MOVEQ	r4, r8			; use initial base value if non-interlaced
	BEQ	%FT02			; then skip interlaced fudging

	SUB	r2, r2, #1		; convert field YEIG to frame YEIG
	ADD	r1, r5, r1, ASR r2	; convert Y to frame rasters and adjust for active Y
	LDR	r5, =OsbyteVars + :INDEX: CFStime ; the interlace module keeps the CFSTime variable with the
	LDRB	r5, [r5]		; bottom bit equal to the interlace phase, so read it to check phase
	TST	r5, #1			; if on top field
	SUBEQ	r1, r1, #1		; then move Y coordinate down by one frame line

	ANDS	r7, r1, #1		; if on bottom pattern (NE)
	ADD	r4, r8, r7, LSL #3	; then r4 -> 2nd line down else r4 -> top line
	ADDEQ	r0, r0, #1		; else on top, so round height up if odd
	SUB	r1, r3, r1, ASR #1	; convert Y to field lines and invert
	MOV	r7, #4			; log2(offset from one row to next)
	MOVS	r0, r0, LSR #1		; convert height to field lines
	MOVEQ	r1, #0			; if no lines
	MOVEQ	r2, #0			; then off
	MOVEQ	r4, #0
	BEQ	%FT10
02
        MOV     r2, #0                  ; height
 |
        SUB     R1, R3, R1, ASR R2      ; convert Y to pixels and invert
        LDRB    R2, [R6, #PointerActiveYs]
        SUB     R1, R1, R2
        MOV     R2, #0                  ; height
        MOV     R4, R5, LSL #9          ; LAG offset from CursorData
 ]

        ADD     R5, R3, #1              ; Total vertical pixels

        ADDS    R3, R1, R0              ; R3 = Y + PointerHeight(shape)
        MOVLE   R1, #0                  ; if <= 0 then off, ie Y=0, height=0
        BLE     %FT10

        CMP     R1, R5                  ; Y >= TotalHeight
        MOVGE   R1, #0                  ; then off
        BGE     %FT10

        CMP     R3, R5                  ; Y + PointerHeight > TotalHeight
        RSBGT   R2, R1, R5              ; then height=TotalHeight-Y
        BGT     %FT10

        CMP     R1, #0                  ; Y >=0
        MOVGE   R2, R0                  ; then height=PointerHeight
        BGE     %FT10

 [ InterlacedPointer
	ADD	r2, r1, r0		; height = PointerHeight + Y
	SUB	r4, r4, r1, LSL r7	; add on offset into shape data
	MOV	r1, #0			; set Y offset to zero
10
	TEQ	r7, #3			; if we're not doing interlaced
	TSTEQ	r4, #15			; and we're quad-word aligned
	BEQ	%FT20			; then just position pointer within original copy of data

	MOV	r9, #1
	MOV	r9, r9, LSL r7		; offset from one row to next
	ADD	r7, r8, #&100		; point r7 at 2nd copy offset
	LDR	r3, =CursorData
	ADD	r7, r7, r3		; r7 = absolute address of destination
	ADD	r3, r3, r4		; r3 = absolute address of source
	MOVS	r6, r2			; r6 = number of lines to do
	BEQ	%FT20			; none to do
15
	LDMIA	r3, {r0, r5}		; load 1 row of source data
	STMIA	r7!, {r0, r5}		; store to dest, advancing dest ptr
	ADD	r3, r3, r9		; advance source ptr
	SUBS	r6, r6, #1
	BNE	%BT15
	ADD	r4, r8, #&100		; move pointer to new altered copy
20
 |
        TST     R1, #1                  ; Y odd ?
        ADDNE   R4, R4, #&100           ; then use 2nd copy

        ADD     R2, R1, R0              ; height = PointerHeight+Y

        RSB     R1, R1, #0              ; Y := -Y
        BIC     R1, R1, #1              ; Y := (-Y AND NOT 1)
        ADD     R4, R4, R1, LSL #3      ; add on offset into shape
        MOV     R1, #0                  ; Y := 0
10
 ]
        Push    "r1, r14"
        MOV     r0, #0
        LDR     r0, [r0, #DRAMPhysAddrA]
        LDR     r1, =DRAMOffset_CursorChunk + (CursorData - CursorChunkAddress)
        ADD     r0, r0, r1
        ADD     r0, r0, r4
        MOV     r1, #MEMCDAG_CInit
        BL      SetDAG
        Pull    "r1, r14"

        LDR     R3, [WsPtr, #VertAdjust] ; get display start value
        ADD     R1, R1, R3              ; and add on

        ORR     R3, R1, #VertiCursorStart
        STR     R3, [R10]

        ADD     R1, R1, R2              ; add height
        ORR     R3, R1, #VertiCursorEnd
        STR     R3, [R10]

        MOV     PC, R14
        |
UpdatePointer ROUT
        MOV     R11, #KeyWorkSpace
        MOV     R10, #VIDC
d347 1
a347 2
        LDRB    R5, [WsPtr, #PointerShapeNumber]
        TST     R5, #&80                ; pointer unlinked if bit 7 set
d354 2
a355 63
        ANDS    R5, R5, #&7F            ; clear bit 7 and set Z if 0 ie off
        SUBNE   R5, R5, #1
        ADDNE   R6, WsPtr, R5           ; R6 is WsPtr + index

        LDRNEB  R0, [R6, #PointerHeights]
        TEQNE   R0, #0                  ; if shape 0 or height 0
        BNE     %FT07
05

; don't display pointer

        MOV     R1, #0                  ; Y := 0
        MOV     R2, #0                  ; height := 0
        MOV     R4, #0                  ; LAG offset := 0
        B       %FT10

07
        LDRB    R2, [WsPtr, #PointerShapeChanged]
        TEQ     R2, #0
        BEQ     %FT08

        MOV     R2, #0
        STRB    R2, [WsPtr, #PointerShapeChanged]
        BSR     SetUpPointerShape
08
        LDR     R2, [WsPtr, #PointerXEigFactor]
        LDR     R3, [WsPtr, #PointerX]
        MOV     R3, R3, ASR R2

        LDRB    R2, [R6, #PointerActiveXs]
        SUB     R3, R3, R2              ; subtract off active point coord

        CMP     R3, #-31                ; if LHS < -31, ie RHS < 0
        BLT     %BT05                   ; then remove pointer completely (fixes MED-00523)

        LDR     R1, [WsPtr, #CursorFudgeFactor]
        ADDS    R3, R3, R1              ; X := X + CursFudgeFactor
        MOVLT   R3, #0                  ; if < 0 then make =0

        CMP     R3, #16*1024            ; if >= limit then make =limit-1
        MOVGE   R3, #16*1024
        SUBGE   R3, R3, #1

        ORR     R3, R3, #HorizCursorStart

 [ {FALSE} ; debug horiz pointer programming
        Push    "r0,lr"
        MOV     r0, r3
        BL      TubeDumpR0
        BL      TubeNewl
        Pull    "r0,lr"
 ]

        STR     R3, [R10]

; now process Y

        LDR     R1, [WsPtr, #PointerY]
        LDR     R2, [WsPtr, #DisplayYEigFactor]

        LDR     R3, [WsPtr, #DisplayYWindLimit]
                                        ; Total height of screen in pixels-1
        SUB     R1, R3, R1, ASR R2      ; convert Y to pixels and invert
a356 33
        LDRB    R2, [R6, #PointerActiveYs]
        SUB     R1, R1, R2

        MOV     R2, #0                  ; height
        MOV     R4, #0                  ; LAG offset from CursorData

        ADD     R5, R3, #1              ; Total vertical pixels

        ADDS    R3, R1, R0              ; R3 = Y + PointerHeight(shape)
        MOVLE   R1, #0                  ; if <= 0 then off, ie Y=0, height=0
        BLE     %FT10

        CMP     R1, R5                  ; Y >= TotalHeight
        MOVGE   R1, #0                  ; then off
        BGE     %FT10

        CMP     R3, R5                  ; Y + PointerHeight > TotalHeight
        RSBGT   R2, R1, R5              ; then height=TotalHeight-Y
        BGT     %FT10

        CMP     R1, #0                  ; Y >=0
        MOVGE   R2, R0                  ; then height=PointerHeight
        BGE     %FT10

        TST     R1, #1                  ; Y odd ?
        ADDNE   R4, R4, #&200           ; then use 2nd pair of copies (ie the ones that start at line 1)

        ADD     R2, R1, R0              ; height = PointerHeight+Y

        RSB     R1, R1, #0              ; Y := -Y
        BIC     R1, R1, #1              ; Y := (-Y AND NOT 1)
        ADD     R4, R4, R1, LSL #3      ; add on offset into shape
        MOV     R1, #0                  ; Y := 0
d358 6
d365 3
a367 28
        ;Rightio, it's time to muck about if we're on a dual-panel LCD...
        Push    "r5,r14"
        MOV     r14, #0
        LDRB    r14, [r14, #LCD_Active]
        TST     r14, #&80
        MOVEQ   r14, #CursorSinglePanel ; Not a dual-panel, so no mucking about to do.
        BEQ     %FT12

        ;OTOH, it _is_ a dual panel, so best do some umming and ahhing. Um ah. :-)
        MOV     R5, R5, LSR #1          ; R5 is half the number of displayed rasters
        CMP     R5, R1
        MOVLT   R14, #CursorBottomPanel ; Pointer starts below the split, so it's in the bottom panel
        SUBLT   R1, R1, R5              ; Subtract the 1/2 panel offset
        BLT     %FT12

        ADD     R14, R1, R2             ; Get the 'y' of the bottom of the pointer
        CMP     R5, R14                 ; See if the pointer straddles the panels
        MOVGE   R14, #CursorTopPanel    ; Nope, it's entirely in the top panel
        BGE     %FT12

        TST     R1, #1                  ; Is the cursor on an odd Y?
        ADDNE   R4, R4, #&200           ; If so, then point to the odd-aligned pair of images
        SUB     R14, R1, R5             ; R14(Y) = Y-1/2 panel (ie Y is now < 0)
        RSB     R14, R14, #0            ; Y := -Y
        BIC     R14, R14, #1            ; Y := (-Y AND NOT 1)
        ADD     R4, R4, R14, LSL #3     ; add on offset into shape
        RSB     R2, R14, #32            ; R2 is now the height of the pointer block which belongs in the bottom panel
        SUBNE   R2, R2, #1              ; Knock another off if we're using the odd-aligned images (dunno why...)
d369 24
a392 1
        MOV     R14, #CursorStraddle    ; It straddles the paddles, so special programming of VCSR & VCER required later...
d394 26
a419 49
12
        Push    "r1, r14"
        MOV     r0, #0
        LDR     r0, [r0, #DRAMPhysAddrA]
        LDR     r1, =DRAMOffset_CursorChunk + (CursorData - CursorChunkAddress)
        ADD     r0, r0, r1

        ADD     r0, r0, r4
        MOV     r1, #MEMCDAG_CInit
        BL      SetDAG
        Pull    "r1, r14"

        CMP     R14, #CursorStraddle
        BEQ     %FT13                   ;It's a cursor straddly thingy, so we've to muck the VCSR & VCER up...

        LDR     R3, [WsPtr, #VertAdjust] ; get display start value
        ADD     R1, R1, R3              ; and add on

        ORR     R3, R1, #VertiCursorStart
        ORR     R14, R3, R14            ; Set the 'special' LCD bits
        STR     R14, [R10]

        ADD     R1, R1, R2              ; add height

        ORR     R3, R1, #VertiCursorEnd
        STR     R3, [R10]

        Pull    "r5,r14"
        MOV     PC, R14

13
        LDR     R3, [WsPtr, #VertAdjust] ; get display start value
        ADD     R1, R1, R3              ; and add on

        ORR     R3, R1, #VertiCursorEnd
        ORR     R5, R3, R14             ; Set the 'straddle' LCD bits
        STR     R5, [R10]

;        LDR     R3, [WsPtr, #VertAdjust] ; get display start value
;        ADD     R2, R2, R3               ; R2 is pointerheight+vertadjust
        ORR     R3, R2, #VertiCursorStart
        ORR     R14, R3, R14            ; Set the 'straddle' LCD bits
        STR     R14, [R10]

        Pull    "r5,r14"
        MOV     PC, R14


        ]
d427 1
a427 1
        MOV     R11, #KeyWorkSpace
d429 1
d433 3
d438 1
d442 3
d457 1
d461 4
d469 1
d472 3
d476 1
d480 3
d487 1
d490 3
d500 1
a500 1
        MOV     R11, #KeyWorkSpace
d520 1
a520 1
        MOV     R11, #KeyWorkSpace
d535 1
d539 4
d547 1
d551 4
d565 1
a565 1
        MOV     R11, #KeyWorkSpace
d574 1
a574 1
        MOV     R11, #KeyWorkSpace
d619 525
@


4.3.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d251 1
a251 1
        Entry   "r0-r12"
d364 1
a364 1
        MRS     R14, CPSR
d366 1
a366 1
        MSR     CPSR_c, R0
d390 1
a390 1
        MSR     CPSR_c, R14             ; restore old IRQ state
a727 4
 [ HAL32
        ! 0, "Sort out pointer stuff"
        BKPT    2
 |
a728 1
 ]
@


4.3.2.2
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@a16 6
; mjs Sep 2000
;
; kernel/HAL split
; display pointer updating is no longer VIDC/IOMD specific
;

d96 1
d98 38
d137 36
a172 23
        ; We allow interrupts during time we copy shape, but we copy into a
        ; holding descriptor, so shape will never be displayed (whether its the
        ; current one, or becomes the current one with an OSByte 6A) until the
        ; vsync after we have a complete definition.
        ;
        ; We have two holding buffers, so that we can always choose a holding
        ; buffer that is not currently being used for display by the HAL,
        ; despite multiple definitions between vsyncs. This all assumes we
        ; are never re-entered, but the documentation for OS_Word 21,0 says
        ; re-entrancy undefined anyway - should really say not re-entrant.
 
        Push    "R1-R7, R14"

        ; interrupts still off for critical choosing of buffer
        ;
        ADD     R6, WsPtr, #PointerShapesH
        MOV     R7, #0                          ; try holding shape 1
        LDR     R14, [R6, R7, LSL #2]           ; R14 -> shape 
        LDR     R2, [R14, #PointerBuffLA]       ; shape buffer we propose to use
        LDR     R0, [WsPtr, #PointerShapeLA]    ; shape buffer owned by HAL
        TEQ     R0, R2                          ; identical?
        MOVEQ   R7, #1                          ; alright then, holding shape 2
        LDREQ   R14, [R6, R7, LSL #2]           ; R14 -> shape 
d174 1
a174 1
        ; now R7 = holding shape index (0,1), R14 -> shape, not owned by HAL
d176 1
a176 1
        CLRPSR  I_bit, R0                       ; re-enable interrupts
d178 1
a178 1
        LDRB    R6, [R1, #1]                    ; shape number we're defining
d181 5
a185 3
        BCS     %FT90                           ; bad shape number
        
        LDRB    R0, [R1, #2]                    ; R0 = width (bytes)
d191 2
a192 3
        STREQB  R2, [R14, #PointerWidth]
        STREQB  R2, [R14, #PointerHeight]
        BEQ     %FT80                           ; empty shape (off)
d195 1
a195 2
        STREQB  R0, [R14, #PointerWidth]
        STREQB  R0, [R14, #PointerHeight]
d197 1
a197 1
        BCS     %FT90                           ; bad width
d203 1
a203 1
        BCS     %FT90                           ; bad definition
d205 3
a207 4
        STRB    R0, [R14, #PointerWidth ]       ; actual width in bytes, before padding to constant 8
        STRB    R2, [R14, #PointerHeight]
        STRB    R3, [R14, #PointerActiveX]
        STRB    R4, [R14, #PointerActiveY]
d214 3
a216 1
        LDR     R3, [R14, #PointerBuffLA]       ; R3 -> buffer to receive shape
d222 1
a222 1
        STRB    R5, [R3], #1                    ; store to buffer
d235 38
a272 13
80
        ; we now have a completely defined shape in a holding buffer
        ;
        PHPSEI  R0                              ; disable interrupts for critical shape logic
        ADD     R3, WsPtr, #PointerShapes
        ADD     R4, WsPtr, #PointerShapesH
        LDR     R1, [R3, R6, LSL #2]            ; swap the holding shape (R7=0,1) into
        LDR     R2, [R4, R7, LSL #2]            ; the shape we've just defined (R6 = 0..3)
        STR     R2, [R3, R6, LSL #2]
        STR     R1, [R4, R7, LSL #2]
        PLP     R0                              ; restore interrupts
90
        Pull    "R1-R7,PC"
d274 3
d400 1
d402 2
d406 1
d408 180
a587 1
        TST     R5, #&80                   ; pointer unlinked if bit 7 set
d594 15
a608 2
        ANDS    R5, R5, #&7F                 ; clear bit 7 and set Z if 0 ie off
        BNE     %FT20
d610 81
a691 6
        MOV     R0, #0                       ; flags = 0 (pointer off)
        MOV     R1, #0                       ; x = 0
        MOV     R2, #0                       ; y = 0
        MOV     R3, #0                       ; shape descriptor = NULL
        STR     R3, [WsPtr, #PointerShapeLA] ; NULL passed as last buffer address
        B       %FT40
d693 79
a771 28
20
        ADD     R3, WsPtr, #PointerShapes-4
        LDR     R3, [R3, R5, LSL #2]         ; R3 -> current shape block (R5 = shape 1..4)

        LDRB    R0, [R3, #PointerHeight]     ; height of 0 switches pointer off
        TEQ     R0, #0
        BEQ     %BT10

        MOV     R0, #1                       ; R0 = flags, set pointer on (bit 0 = 1)

        LDR     R1, [WsPtr, #PointerShapeLA] ; last shape buffer given to HAL
        LDRNE   R4, [R3, #PointerBuffLA]     ; shape buffer we're about to give
        TEQ     R1, R4                       ; same as last time?
        STRNE   R4, [WsPtr, #PointerShapeLA] ; update
        ORRNE   R0, R0, #2                   ; flag new shape (bit 1 = 1)

        LDR     R1, [WsPtr, #PointerX]
        LDR     R4, [WsPtr, #PointerXEigFactor]
        MOV     R1, R1, ASR R4                     ; R1 = pointer x, pixels
        LDRB    R4, [R3, #PointerActiveX]
        SUB     R1, R1, R4                         ; R1 = pointer x, adjusted for active point

        LDR     R2, [WsPtr, #PointerY]
        LDR     R4, [WsPtr, #DisplayYEigFactor]
        LDR     R5, [WsPtr, #DisplayYWindLimit]    ; R5 = display height -1
        SUB     R2, R5, R2, ASR R4                 ; R2 = pointer y, pixels, inverted
        LDRB    R4, [R3, #PointerActiveY]
        SUB     R2, R2, R4                         ; R2 = pointer y, adjusted for active point
d773 2
a774 6
        ; and its up to the HAL to handle clipping according to h/w capabilities
40
        Push    "R9, R12, LR"
        mjsAddressHAL
        mjsCallHAL     HAL_Video_UpdatePointer
        Pull    "R9, R12, LR"
a775 1
        MOV     PC, LR         
d777 1
@


4.3.2.3
log
@further kernel/HAL split work in video area
almost-HAL code for VIDC20/IOMD in vdu.vduhint, now almost divorced
from kernel workspace
tested briefly in Ursula desktop environment

Version 5.35, 4.79.2.4. Tagged as 'Kernel-5_35-4_79_2_4'
@
text
@d358 1
a358 1
        LDR     R4, [R3, #PointerBuffLA]     ; shape buffer we're about to give
@


4.3.2.4
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d114 1
a114 1

d121 1
a121 1
        LDR     R14, [R6, R7, LSL #2]           ; R14 -> shape
d126 1
a126 1
        LDREQ   R14, [R6, R7, LSL #2]           ; R14 -> shape
d136 1
a136 1

a377 6
 [ UseGraphicsV
        Push    "LR"
        MOV     R4, #GraphicsV_UpdatePointer
        BL      CallGraphicsV
        Pull    "PC"
 |
d381 3
a383 2
        Pull    "R9, R12, PC"
 ]
@


4.3.2.5
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@a242 1
      [ NoARMv6 :LOR: NoUnaligned
a257 7
      |
        ; Use unaligned loads from ARMv6
        LDRH    R2, [R1, #1]            ; R2 = left
        LDRH    R3, [R1, #3]            ; R3 = bottom
        LDRH    R4, [R1, #5]            ; R4 = right
        LDRH    R5, [R1, #7]            ; R5 = top
      ]
a271 1
      [ NoARMv6
a279 7
      |
        ; ARMv6 lets you do this using SXTH, but no support in objasm yet
        DCI     &E6BF2072  ; SXTH    R2, R2
        DCI     &E6BF3073  ; SXTH    R3, R3
        DCI     &E6BF4074  ; SXTH    R4, R4
        DCI     &E6BF5075  ; SXTH    R5, R5
      ]
d294 1
a294 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d397 1
a397 1
        LDR     R11, =ZeroPage+KeyWorkSpace
a398 1
      [ NoARMv4
a401 3
      |
        LDRSB   R0, [R1, #1]
      ]
a403 1
      [ NoARMv4
a406 3
      |
        LDRSB   R0, [R1, #2]
      ]
a418 1
      [ NoARMv6 :LOR: NoUnaligned
a421 4
      |
        ; Use unaligned loads and SXTH from ARMv6
        LDRH    R0, [R1, #1]            ; get X coordinate
      ]
a425 1
      [ NoARMv6
a427 3
      |
        DCI     &E6BF2070 ; SXTH    R2, R0
      ]
a428 1
      [ NoARMv6 :LOR: NoUnaligned
a431 3
      |
        LDRH    R0, [R1, #3]            ; get Y coordinate
      ]
a435 1
      [ NoARMv6
a437 3
      |
        DCI     &E6BF3070 ; SXTH    R3, R0
      ]
d445 1
a445 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d465 1
a465 1
        LDR     R11, =ZeroPage+KeyWorkSpace
a479 1
      [ NoARMv6 :LOR: NoUnaligned
a482 4
      |
        ; Use unaligned store from ARMv6
        STRH    R2, [R1, #1]            ; store X
      ]
a486 1
      [ NoARMv6 :LOR: NoUnaligned
a489 4
      |
        ; Use unaligned store from ARMv6
        STRH    R3, [R1, #3]            ; store X
      ]
d500 1
a500 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d509 1
a509 1
        LDR     R11, =ZeroPage+KeyWorkSpace
a553 2
        LTORG

@


4.3.2.6
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d290 5
a294 5
        ; ARMv6 lets you do this using SXTH
        SXTH    R2, R2
        SXTH    R3, R3
        SXTH    R4, R4
        SXTH    R5, R5
d459 1
a459 1
        SXTH    R2, R0
d477 1
a477 1
        SXTH    R3, R0
@


4.3.2.7
log
@Make Mike's macros permanent.
While the HAL and kernel were being split some temporary macros were used for the bits being worked on, after 12 years of use they're probably safe to adopt.
mjsCallHAL -> CallHAL; mjsAddressHAL -> AddressHAL; mjsHAL -> HAL.
OS_VIDCDividerSWI code now always does NoSuchSWI (had been switched out previously).
File vduhint.s no longer assembled (was empty).


Version 5.35, 4.79.2.150. Tagged as 'Kernel-5_35-4_79_2_150'
@
text
@d401 2
a402 2
        AddressHAL
        CallHAL HAL_Video_UpdatePointer
@


4.3.2.8
log
@Make GraphicsV_IICOp more consistent
No accepts  r0 = b31-24 set 0
                 b23-16 fully qualified IIC address
                 b15-0  starting offset
            r1 = buffer pointer
            r2 = number of bytes to tranfer
            r4 = b31-24 display number
                 b23-16 head
                 b15-0  reason code (=14)
Now returns r0 = result codes as per HAL_IICTransfer()
            r1 = buffer pointer incremented by number of bytes transferred
            r2 = number of bytes *not* transferred
            r4 = 0
Removed '_' after Video in entry numbers to be consistent with other HAL entry naming, and HAL_VideoFlybackDevice.
Added IICStatus return numbers to Hdr:HALEntries.
Stop calling HAL_MonitorLeadID as only IOMD implemented it - just guess VGA until the graphics driver says otherwise.

Version 5.35, 4.79.2.159. Tagged as 'Kernel-5_35-4_79_2_159'
@
text
@d402 1
a402 1
        CallHAL HAL_VideoUpdatePointer
@


4.3.2.9
log
@Merge with RPi branch
Detail:
  Merge the RPi branch with the HAL branch, ending RPi branch development
  Brief summary of changes brought in:
  * Added HAL_VideoStartupMode to allow the HAL to specify a startup mode for the OS
  * Fixed addresses being sent to GraphicsV_SetDMAAddress being wrong for external framestores (addresses were given as if internal framestore was in use)
  * Add InverseTextTransparency option for limited compile-time support for targets where framebuffer alpha channel is important
  * Fix ConfiguredLanguage for non-Tungsten builds
  * Update ARMv6 CPU detection to read cache parameters from cache type register instead of using KnownCPUTable
  * Add HALDebugHexTX/TX2/TX4 debug routines for writing out numbers via HAL
  * Use HAL_TimerIRQClear when clearing timer 0 interrupt instead of just HAL_IRQClear
  * Initialise FileLangCMOS using defines from Hdr:FSNumbers instead of magic numbers. Use SDFS on M_ARM11ZF.
  * Improved software mouse pointer support; software pointer now removed & restored in some of the same places the text cursor is
  * Improve support for external framestores; driver is now able to grow/shrink/move the framestore on mode changes if bit 5 of GraphicsV_DisplayFeatures R0 is set
  * GraphicsV_FramestoreAddress now has a default claimant which calls HAL_VideoFramestoreAddress
Admin:
  Tested on Raspberry Pi, Iyonix, OMAP3, IOMD


Version 5.35, 4.79.2.165. Tagged as 'Kernel-5_35-4_79_2_165'
@
text
@a606 56
; *****************************************************************************
;
;       RemovePointer - Remove soft mouse pointer from screen
;

RemovePointer ROUT
        STMFD   R13!,{R0-R6,R14}
        LDRB    R3, [WsPtr, #PointerShapeNumber]
        TST     R3, #&7F
        MOVNE   R0, #0
        MOVNE   R4, #GraphicsV_UpdatePointer
        BLNE    CallGraphicsV
        LDMFD   R13!,{R0-R6,PC}

; *****************************************************************************
;
;       RestorePointer - Restore soft mouse pointer to previous state
;

RestorePointer ROUT
        STMFD   R13!,{R0-R6,R14}
        LDRB    R6, [WsPtr, #PointerShapeNumber]
        ANDS    R6, R6, #&7F
        BEQ     %FT10

        ADD     R3, WsPtr, #PointerShapes-4
        LDR     R3, [R3, R6, LSL #2]         ; R3 -> current shape block (R6 = shape 1..4)

        MOV     R0, #1                       ; R0 = flags, set pointer on (bit 0 = 1)

        LDR     R1, [WsPtr, #PointerShapeLA] ; last shape buffer given to HAL
        LDR     R4, [R3, #PointerBuffLA]     ; shape buffer we're about to give
        TEQ     R1, R4                       ; same as last time?
        STRNE   R4, [WsPtr, #PointerShapeLA] ; update
        ORRNE   R0, R0, #2                   ; flag new shape (bit 1 = 1)

        LDR     R1, [WsPtr, #PointerX]
        LDR     R4, [WsPtr, #PointerXEigFactor]
        MOV     R1, R1, ASR R4                     ; R1 = pointer x, pixels
        LDRB    R4, [R3, #PointerActiveX]
        SUB     R1, R1, R4                         ; R1 = pointer x, adjusted for active point

        LDR     R2, [WsPtr, #PointerY]
        LDR     R4, [WsPtr, #DisplayYEigFactor]
        LDR     R5, [WsPtr, #DisplayYWindLimit]    ; R5 = display height -1
        SUB     R2, R5, R2, ASR R4                 ; R2 = pointer y, pixels, inverted
        LDRB    R4, [R3, #PointerActiveY]
        SUB     R2, R2, R4                         ; R2 = pointer y, adjusted for active point

        ; and it's up to the HAL to handle clipping according to h/w capabilities

        MOV     R4, #GraphicsV_UpdatePointer
        BL      CallGraphicsV
10
        LDMFD   R13!,{R0-R6,PC}

@


4.3.2.10
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d394 11
a404 4
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_UpdatePointer
        B       CallGraphicsV
d616 3
a618 7
        BEQ     %FT10
        MOV     R0, #0
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_UpdatePointer
        BL      CallGraphicsV
10
d658 1
a658 3
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_UpdatePointer
@


4.3.2.11
log
@Add builtin software pointer support
Detail:
  This set of changes adds support for rendering software mouse pointers directly in the kernel, rather than requiring graphics drivers to render them themselves as was the case previously.
  If a driver returns from GraphicsV_Features with the 'hardware pointer' bit clear, and a call to GraphicsV_UpdatePointer is returned unclaimed, then the kernel will step in and render a software pointer. This allows selective control over which areas of the screen the software pointer is used (e.g. if hardware only supports its use in some areas)
  hdr/KernelWS - Shrink PointerXEigFactor to 1 byte to free up some space for tracking the display log2bpp. Use 8 words of space for tracking software pointer state.
  s/vdu/vducursoft - Adjust existing the existing calls to the software pointer RemovePointer/RestorePointer functions so that they're called with IRQs enabled
  s/vdu/vdudriver - Keep track of display log2bpp. Claim/release memory needed for restoring pixels under software pointer.
  s/vdu/vdugrafhal - Update HAL_VideoUpdatePointer handling so that 0 can be returned in a1 to indicate the GraphicsV call should be left unclaimed.
  s/vdu/vdupalxx - Trigger updates of the cached software pointer palette whenever it's likely to become invalidated.
  s/vdu/vdupointer - Add software pointer implementation. Relying on a SpriteExtend OS_SpriteOp would be nice, but we're in the background so have to do plotting & unplotting manually. ColourTrans is used to cache the pointer palette colours for the current mode, although we're limited to calling it from a callback.
Admin:
  Tested on Raspberry Pi & BB-xM
  Pointer is very flickery under some circumstances (e.g. running !CloseUp) due to needing to plot/unplot around any VDU driver screen access (as per text cursor). So code may need revising in future once we can trap reads/writes from specific screen memory pages.


Version 5.35, 4.79.2.269. Tagged as 'Kernel-5_35-4_79_2_269'
@
text
@a339 1
;       IRQs disabled, but can be enabled (n.b. may be in IRQ mode)
a341 1
        Push    "R14"
d380 1
a380 1
        LDRB    R4, [WsPtr, #PointerXEigFactor]
d397 1
a397 1
        BL      CallGraphicsV
a398 19
        ; Software pointer required?
        LDR     R5, [WsPtr, #GraphicsVFeatures]
        TST     R5, #GVDisplayFeature_HardwarePointer
        Pull    "pc", NE

        ; Software pointer code can run with IRQs enabled; drop into SVC mode
        MRS     R6, CPSR                     ; Currently we should always be in IRQ mode here, but read current mode just in case
        MSR     CPSR_c, #SVC32_mode
        MOV     R5, R14

        ; If the call wasn't claimed, pass on to software pointer code
        ; If the call was claimed, we need to make sure the software pointer is off
        TEQ     R4, #0
        MOVEQ   R0, #0
        BL      UpdateSoftwarePointer

        MOV     R14, R5
        MSR     CPSR_c, R6
        Pull    "pc"
a603 2
; in:   WsPtr -> VduDriverWorkspace
; out:  flags preserved
d606 11
a616 16
        EntryS  "r10-r11"
        LDRB    r10, [WsPtr, #SWP_Mutex]
        TEQ     r10, #0
        BNE     %FT90
        ; Lock mutex
        MOV     r10, #1
        STRB    r10, [WsPtr, #SWP_Restore]
        STRB    r10, [WsPtr, #SWP_Mutex]
        ; Remove pointer if possible
        LDR     r11, [WsPtr, #SWP_Pos]
        LDR     r10, [WsPtr, #SWP_Under]
        TEQ     r11, #0
        BLNE    RemoveSoftwarePointer
        ; Exit with mutex still locked
90
        EXITS
a621 2
; in:   WsPtr -> VduDriverWorkspace
;       Software pointer restore assumed to be needed
a624 3
        MOV     R0, #0
        STRB    R0, [WsPtr, #SWP_Restore]
        STRB    R0, [WsPtr, #SWP_Mutex]
d641 1
a641 1
        LDRB    R4, [WsPtr, #PointerXEigFactor]
d653 6
a658 1
        BL      UpdateSoftwarePointer
a661 406
; *****************************************************************************
;
;       UpdateSoftwarePointer - Like GraphicsV_UpdatePointer, but for the
;                               software pointer
;
; in:   r0-r3 as per GraphicsV_UpdatePointer
;       WsPtr -> VduDriverWorkSpace

UpdateSoftwarePointer ROUT
        Entry   "r10-r11"
        ; Is the pointer possible?
        LDR     r10, [WsPtr, #SWP_Under]
        TEQ     r10, #0
        BEQ     %FT99
        ; Is mutex locked?
        LDRB    r11, [WsPtr, #SWP_Mutex]
        TEQ     r11, #0
        BNE     %FT99
        MOV     r11, #1
        STRB    r11, [WsPtr, #SWP_Mutex]
        ; Is pointer in same state as last time?
      [ NoARMv6
        MOV     r11, r1, LSL #16
        MOV     lr, r2, LSL #16
        ORR     r11, lr, r11, LSR #16
      |
        PKHBT   r11, r1, r2, LSL #16
      ]
        LDR     lr, [WsPtr, #SWP_Coords]
        TEQ     r11, lr ; Have coords changed?
        STRNE   r11, [WsPtr, #SWP_Coords]
        TSTEQ   r0, #2 ; Has shape changed?
        LDREQB  lr, [WsPtr, #SWP_Dirty]
        LDR     r11, [WsPtr, #SWP_Pos]
        TEQEQ   lr, #0 ; Has palette changed?
        BNE     %FT20
        ; The above state variables only track correctly for when the pointer is on. So we can only skip if it's currently on, and it's staying on.
        TEQ     r11, #0
        TSTNE   r0, #1
        BNE     %FT90
20
        ; Remove from previous position, if any
        TEQ     r11, #0
        BLNE    RemoveSoftwarePointer
        ; Plot in new position, if any
        TST     r0, #1
        BLNE    PlotSoftwarePointer
90
        ; Release mutex
        MOV     r11, #0
        STRB    r11, [WsPtr, #SWP_Mutex]
99
        EXIT

; *****************************************************************************
;
;       PlotSoftwarePointer - Plot software pointer to the screen
;
; in:   r1 = X position
;       r2 = Y position
;       r3 -> PointerBlkHAL
;       WsPtr -> VduDriverWorkSpace

PlotSoftwarePointer ROUT
        Entry   "r0-r11"
        ; Load shape info
        LDRB    r5, [r3, #PointerHeight]
        LDRB    r4, [r3, #PointerWidth]
        CMP     r5, #32
        LDR     r3, [r3, #PointerBuffLA]
        MOVGT   r5, #32
        ; Load screen info
        ; Must be careful to only use variables which aren't affected by output redirection
        LDR     r0, [WsPtr, #DisplayBankAddr]
        LDR     r6, [WsPtr, #DisplayXWindLimit]
        LDR     r7, [WsPtr, #DisplayYWindLimit]
        LDRB    r9, [WsPtr, #DisplayLog2BPP]
        ADD     r6, r6, #1
        ADD     r7, r7, #1
        MOV     r8, #0 ; Start X offset into pointer image (bits)
        MOV     r4, r4, LSL #2 ; byte width -> pixel width
        STRB    r8, [WsPtr, #SWP_Dirty]

        ; Do a quick scan of the image to see if the LHS is fully transparent
        ; This is the case for the default pointer image, at least
        CMP     r5, #0 ; Height can be zero on startup!
        ADD     r11, r3, r5, LSL #3
        BLE     %FT99
        MOV     r10, #0
10
        LDR     lr, [r11, #-8]!
        CMP     r11, r3
        ORR     r10, r10, lr
        BNE     %BT10
        TEQ     r10, #0
        ADDEQ   r8, r8, #32
        ADDEQ   r1, r1, #16
        SUBEQ   r4, r4, #16

        ; Crop image to screen
        CMP     r1, #0
        ADDLT   r4, r4, r1
        SUBLT   r8, r8, r1, LSL #1
        MOVLT   r1, #0
        ADD     lr, r1, r4
        SUBS    lr, lr, r6
        SUBGT   r4, r4, lr

        CMP     r2, #0
        ADDLT   r5, r5, r2
        SUBLT   r3, r3, r2, LSL #3
        MOVLT   r2, #0
        ADD     lr, r2, r5
        SUBS    lr, lr, r7
        SUBGT   r5, r5, lr

        ; Bail if fully off-screen
        CMP     r4, #0
        CMPGT   r5, #0
        BLE     %FT99

        MOV     r7, r6, LSL r9
        MOV     r7, r7, LSR #3 ; LineLen
        MLA     r0, r7, r2, r0 ; First screen row to touch

        MOV     r1, r1, LSL r9 ; Screen X start, in bits

        ; Save the rectangle under the pointer
        ADR     lr, %FT30
        Push    "r0-r12,lr" ; For RemoveSoftwarePointerAltEntry
        ; Make things easier by converting to word-aligned coordinates
        ADD     lr, r1, r4, LSL r9 ; Screen X end, in bits
        ADD     lr, lr, #31
        MOV     r1, r1, LSR #5 ; X start in words
        RSB     r4, r1, lr, LSR #5 ; width in words

        ; Calculate screen addr to copy from
        ADD     r10, r0, r1, LSL #2 ; Copy dest

        ; Remember image size, position for restore later on
        STR     r10, [WsPtr, #SWP_Pos]
        STRB    r4, [WsPtr, #SWP_W]
        STRB    r5, [WsPtr, #SWP_H]

        ; Copy to SWP_Under
        ; Can reuse copy loop in RemoveSoftwarePointer
        SUB     r6, r7, r4, LSL #2 ; Src stride
        MOV     r7, #0 ; Dest stride
        LDR     r11, [WsPtr, #SWP_Under] ; Copy src
        B       RemoveSoftwarePointerAltEntry
30
        ; Arrive back here with r0-r12 restored
        ; Important values:
        ; r0 -> initial screen row
        ; r1 = screen X start, in bits
        ; r3 -> initial pointer row
        ; r4 = pointer pixel width
        ; r5 = height
        ; r7 = LineLen
        ; r8 = pointer X start, in bits
        ; r9 = Log2BPP
        ; For 32bpp modes we have a faster plotter available
        TEQ     r9, #5
        BEQ     %FT70
        ; Calculate end-of-row shift amount
        ADD     lr, r1, r4, LSL r9
        AND     lr, lr, #31
        RSB     lr, lr, #32
        ORR     lr, lr, lr, LSR #5 ; Use 33 to represent case where no shift is needed - ensures the MOVS clears C
        Push    "lr"
        ; Convert Log2BPP to BPP
        MOV     lr, #1
        MOV     r9, lr, LSL r9
        LDR     r10, =ZeroPage+VduDriverWorkSpace+SWP_Palette-4
        ; Conveniently, we can read screen words from SWP_Under, avoiding slow read-modify-write of screen memory
        LDR     r11, [WsPtr, #SWP_Under]
        ; Offset r0 to point at first word in row, compute initial mask word
        AND     lr, r1, #31
        ADD     r0, r0, r1, LSR #3
        MOV     r6, #&80000000
        BIC     r0, r0, #3 ; Row ptr assumed to be word aligned!
        MOV     r6, r6, LSR lr
        Push    "r0,r4,r6,r7,r8"
40
        ; Since the pointer is padded out to 32 pixels wide, it's easiest to
        ; just load an entire row and treat it as a 64 bit value
        LDMIA   r3!, {r1, r2}
        ; Skip the initial pixels
        TST     r8, #32
        AND     lr, r8, #31
        MOVNE   r1, r2
        RSB     r7, lr, #32
        MOV     r1, r1, LSR lr
        MVN     r8, #0
        ORR     r1, r1, r2, LSL r7
        MOV     r2, r2, LSR lr
        BIC     r8, r8, r8, LSR r9 ; Value to merge into mask word
        MOV     r7, #0
50
        ANDS    lr, r1, #3
        MOV     r1, r1, LSR #2
        LDRNE   lr, [r10, lr, LSL #2]
        ORR     r1, r1, r2, LSL #30
        ORR     r7, lr, r7, LSR r9 ; Merge in output pixel, 0 if transparent
        MOVNE   lr, r8
        MOV     r2, r2, LSR #2
        ORRS    r6, lr, r6, LSR r9 ; Merge in mask, 0 if transparent
        BCC     %FT60
        ; Store completed screen word
        ; EQ condition if fully transparent
        BEQ     %FT55
        LDR     lr, [r11]
        BIC     lr, lr, r6
        ORR     lr, lr, r7
        STR     lr, [r0]
55
        ADD     r11, r11, #4
        ADD     r0, r0, #4
        MOV     r6, #&80000000
60
        SUBS    r4, r4, #1
        BGT     %BT50
        ; Next row
        ; However, we may have a partial word to store
        ; Shift it down to the low end of the word, ready to store
        LDR     lr, [sp, #5*4] ; Grab precomputed shift amount
        MOVS    r6, r6, LSR lr
        MOV     r7, r7, LSR lr
        BLS     %FT65 ; ~C if no shift needed (actually, lr=33 to ensure C gets cleared), C+Z if word is transparent, C+~Z if visible
        LDR     lr, [r11]
        BIC     lr, lr, r6
        ORR     lr, lr, r7
        STR     lr, [r0]
65
        ADDCS   r11, r11, #4
        ; Last word dealt with
        ; Advance to next row
        LDMIA   sp, {r0,r4,r6,r7,r8}
        SUBS    r5, r5, #1
        ADD     r0, r0, r7
        STRNE   r0, [sp]               
        BNE     %BT40
        ; Junk stack contents
        ADD     sp, sp, #6*4
99
        EXIT

70
        ; Plotter for 32bpp modes
        ; No need to read from the screen, just blast out any non-transparent
        ; pixels
        LDR     r10, =ZeroPage+VduDriverWorkSpace+SWP_Palette-4
        ; Offset r0 to point at first word in row
        ADD     r0, r0, r1, LSR #3
        ; Calculate shift amount for pointer row
        AND     r6, r8, #31
        RSB     r11, r6, #32
        Push    "r0,r4"
75
        ; Since the pointer is padded out to 32 pixels wide, it's easiest to
        ; just load an entire row and treat it as a 64 bit value
        LDMIA   r3!, {r1, r2}
        ; Skip the initial pixels
        TST     r8, #32
        MOVNE   r1, r2
        MOV     r1, r1, LSR r6
        ORR     r1, r1, r2, LSL r11
        MOV     r2, r2, LSR r6
80
        ANDS    lr, r1, #3
        MOV     r1, r1, LSR #2
        LDRNE   lr, [r10, lr, LSL #2]
        ORR     r1, r1, r2, LSL #30
        MOV     r2, r2, LSR #2
        STRNE   lr, [r0]
        SUBS    r4, r4, #1
        ORRNES  lr, r1, r2 ; Stop if remainder of row is transparent
        ADD     r0, r0, #4
        BNE     %BT80
        ; Next row
        LDMIA   sp, {r0,r4}
        SUBS    r5, r5, #1
        ADD     r0, r0, r7
        STRNE   r0, [sp]               
        BNE     %BT75
        ; Junk stack contents
        ADD     sp, sp, #2*4
        EXIT
        


; *****************************************************************************
;
;       RemoveSoftwarePointer - Remove software pointer from the screen
;
; in:   r10 -> SWP_Under
;       r11 -> SWP_Pos
;       WsPtr -> VduDriverWorkSpace

RemoveSoftwarePointer
        Entry   "r0-r12" ; n.b. keep in sync with call from PlotSoftwarePointer
        ; Get parameters needed for unplot
        LDRB    r4, [WsPtr, #SWP_W]
        LDRB    r5, [WsPtr, #SWP_H]
        LDR     r6, [WsPtr, #DisplayXWindLimit]
        LDRB    r9, [WsPtr, #DisplayLog2BPP]
        ADD     r6, r6, #1
        MOV     r6, r6, LSL r9
        MOV     r6, r6, LSR #3
        SUB     r7, r6, r4, LSL #2 ; Dest stride
        MOV     r6, #0 ; Src stride
        STR     r6, [WsPtr, #SWP_Pos]
RemoveSoftwarePointerAltEntry        
        ; Width assumed to be max of 32 words
        ; r0-r3, r8-r9, r12, lr free for use
        Push    "r4"
05
        ; Width will almost always be >= 8, so transfer groups of 8 first
        CMP     r4, #8
06
        LDMGEIA r10!, {r0-r3, r8-r9, r12, lr}
        SUBGE   r4, r4, #8
        STMGEIA r11!, {r0-r3, r8-r9, r12, lr}
        BEQ     %FT90
        CMP     r4, #8
        BGE     %BT06
        ; Transfer remainder
        MOVS    r4, r4, LSR #1
        LDRCS   r0, [r10], #4
        STRCS   r0, [r11], #4
        BEQ     %FT90
        MOVS    r4, r4, LSR #1
        LDMCSIA r10!, {r0-r1}
        STMCSIA r11!, {r0-r1}
        BEQ     %FT90
        ; NE so must be 4 left
        LDMIA   r10!, {r0-r3}
        STMIA   r11!, {r0-r3}
90
        LDR     r4, [sp]
        ADD     r10, r10, r6
        SUBS    r5, r5, #1
        ADD     r11, r11, r7
        BNE     %BT05
        ADD     sp, sp, #4
        EXIT

; *****************************************************************************
;
;       RegisterSoftwarePointerCallback - Register callback for palette update
;
; in:   WsPtr -> VduDriverWorkSpace

RegisterSoftwarePointerCallback
        Entry   "r0-r2"
        ; We may be in IRQ mode, so switch to SVC before calling SWI
        MRS     r2, CPSR
        ORR     r1, r2, #SVC32_mode
        MSR     CPSR_c, r1
        Push    "lr"
        ADR     r0, SoftwarePointerCallback
        MOV     r1, WsPtr
        SWI     XOS_AddCallBack
        MOVVC   r0, #1
        STRVCB  r0, [WsPtr, #SWP_Callback]
        Pull    "lr"
        MSR     CPSR_c, r2
        EXIT

; *****************************************************************************
;
;       SoftwarePointerCallback - Recalculate software pointer palette
;
; in:   WsPtr -> VduDriverWorkSpace

SoftwarePointerCallback
        Entry   "r0-r3"
        MOV     r0, #0
        STRB    r0, [WsPtr, #SWP_Callback]
        ; Can now enable IRQs (ColourTrans may be slow!)
        MSR     CPSR_c, #SVC32_mode
        ; Grab the three pointer colours and translate them
        ; We want to shift the result up to the high end of each word
        LDRB    r0, [WsPtr, #DisplayLog2BPP]
        MOV     r1, #1
        MOV     r0, r1, LSL r0
        RSB     r3, r0, #32
        LDR     r2, [WsPtr, #FirPalAddr]
        LDR     r1, [WsPtr, #DisplayModeNo]
        LDR     r0, [r2, #257*4]
        SWI     XColourTrans_ReturnColourNumberForMode
        MOV     r0, r0, LSL r3
        STR     r0, [WsPtr, #SWP_Palette]
        LDR     r0, [r2, #258*4]
        SWI     XColourTrans_ReturnColourNumberForMode
        MOV     r0, r0, LSL r3
        STR     r0, [WsPtr, #SWP_Palette+4]
        LDR     r0, [r2, #259*4]
        SWI     XColourTrans_ReturnColourNumberForMode
        MOV     r0, r0, LSL r3
        STR     r0, [WsPtr, #SWP_Palette+8]
        STRB    r1, [WsPtr, #SWP_Dirty]
        EXIT

        LTORG

@


4.3.2.12
log
@Fix software pointer being enabled when it isn't needed. Improve HangWatch support.
Detail:
  s/vdu/vdupointer - For any mode where the software pointer is usable, RestorePointer was restoring the software pointer regardless of whether it was in use at the time RemovePointer was called. This would cause both the software & hardware pointers to be briefly enabled at the same time, potentially causing flickering or other glitches. Fix the issue by making sure RestorePointer only restores if the software pointer was actually in use at the time RemovePointer was called. Also, attempt to deal with the situation where the pointer might have moved to a location where the software pointer is no longer required.
  s/Middle - Improve integration of HangWatch with the abort handler - avoid overwriting the top of the SVC stack so that it can be preserved for the HangWatch dump.
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.270. Tagged as 'Kernel-5_35-4_79_2_270'
@
text
@d635 1
d637 1
a637 6
        ; We need to set SWP_Restore so that we know to release the mutex once we're done
        ; However if the software pointer currently isn't visible (hardware pointer in use) then there might not be an image to restore
        ; So SWP_Restore can take three values:
        ; 0 -> not in RemovePointer block
        ; 1 -> in RemovePointer but no restore needed
        ; 2 -> in RemovePointer and restore needed
d639 1
a640 4
        MOVNE   r10, #2
        STRB    r10, [WsPtr, #SWP_Restore]
        ; Remove pointer if necessary
        LDRNE   r10, [WsPtr, #SWP_Under]
d654 1
a654 3
        STMFD   R13!,{R0-R7,R14}
        PHPSEI  R7                           ; IRQs off while we work out what to do
        LDRB    R1, [WsPtr, #SWP_Restore]
d659 2
a660 3
        TST     R1, #2                       ; Was the software pointer actually on?
        ANDNES  R6, R6, #&7F
        BEQ     %FT90
a685 37
        ; The pointer may have moved while we had it disabled.
        ; If it has moved, it's possible the hardware pointer has taken over
        ; and the software pointer isn't needed anymore
        ; Potentially we could deal with this inside UpdateSoftwarePointer
        ; (i.e. cache the new parameters if it gets called with the mutex
        ; locked), but that will add a fair bit of complexity. So for now go
        ; with the simpler approach of comparing the current position against
        ; the last position used by the software pointer and calling through to
        ; GraphicsV if it's changed (otherwise, call software pointer directly)

      [ NoARMv6
        MOV     R5, R1, LSL #16
        MOV     LR, R2, LSL #16
        ORR     R5, LR, R5, LSR #16
      |
        PKHBT   R5, R1, R2, LSL #16
      ]
        LDR     LR, [WsPtr, #SWP_Coords]
        TEQ     LR, R5
        BEQ     %FT50

        ; Pointer has moved - call GraphicsV
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_UpdatePointer
        BL      CallGraphicsV

        TEQ     R4, #0
        BEQ     %FT90

50
        ; IRQs on for software pointer call
        ; This does open up the possibility for the pointer shape/location to
        ; change under IRQ while we're still rendering it - so a more advanced
        ; locking mechanism may be desirable in future
        PLP     R7

d687 2
a688 3
90
        PLP     R7
        LDMFD   R13!,{R0-R7,PC}
@


4.3.2.6.2.1
log
@  Merge of Raspberry Pi support code against latest kernel
Detail:
  This is a new branch from the current tip of the HAL branch, incorporating
  the changes received from Adrian Lees. The same caveats apply - this is a
  work in progress and will not work on any other platform at present.
Admin:
  Builds, but not tested.

Version 5.35, 4.79.2.147.2.1. Tagged as 'Kernel-5_35-4_79_2_147_2_1'
@
text
@a606 56
; *****************************************************************************
;
;       RemovePointer - Remove soft mouse pointer from screen
;

RemovePointer ROUT
        STMFD   R13!,{R0-R6,R14}
        LDRB    R3, [WsPtr, #PointerShapeNumber]
        TST     R3, #&7F
        MOVNE   R0, #0
        MOVNE   R4, #GraphicsV_UpdatePointer
        BLNE    CallGraphicsV
        LDMFD   R13!,{R0-R6,PC}

; *****************************************************************************
;
;       RestorePointer - Restore soft mouse pointer to previous state
;

RestorePointer ROUT
        STMFD   R13!,{R0-R6,R14}
        LDRB    R6, [WsPtr, #PointerShapeNumber]
        ANDS    R6, R6, #&7F
        BEQ     %FT10

        ADD     R3, WsPtr, #PointerShapes-4
        LDR     R3, [R3, R6, LSL #2]         ; R3 -> current shape block (R6 = shape 1..4)

        MOV     R0, #1                       ; R0 = flags, set pointer on (bit 0 = 1)

        LDR     R1, [WsPtr, #PointerShapeLA] ; last shape buffer given to HAL
        LDR     R4, [R3, #PointerBuffLA]     ; shape buffer we're about to give
        TEQ     R1, R4                       ; same as last time?
        STRNE   R4, [WsPtr, #PointerShapeLA] ; update
        ORRNE   R0, R0, #2                   ; flag new shape (bit 1 = 1)

        LDR     R1, [WsPtr, #PointerX]
        LDR     R4, [WsPtr, #PointerXEigFactor]
        MOV     R1, R1, ASR R4                     ; R1 = pointer x, pixels
        LDRB    R4, [R3, #PointerActiveX]
        SUB     R1, R1, R4                         ; R1 = pointer x, adjusted for active point

        LDR     R2, [WsPtr, #PointerY]
        LDR     R4, [WsPtr, #DisplayYEigFactor]
        LDR     R5, [WsPtr, #DisplayYWindLimit]    ; R5 = display height -1
        SUB     R2, R5, R2, ASR R4                 ; R2 = pointer y, pixels, inverted
        LDRB    R4, [R3, #PointerActiveY]
        SUB     R2, R2, R4                         ; R2 = pointer y, adjusted for active point

        ; and it's up to the HAL to handle clipping according to h/w capabilities

        MOV     R4, #GraphicsV_UpdatePointer
        BL      CallGraphicsV
10
        LDMFD   R13!,{R0-R6,PC}

@


4.3.2.6.2.2
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d401 2
a402 2
        AddressHAL
        CallHAL HAL_VideoUpdatePointer
@


4.3.2.4.2.1
log
@  Unaligned loads/stores optimised for ARMv6+
Detail:
  Having scanned the kernel source for unaligned load code fragments which
  would abort on ARMv6 and v7 and not having found any, I took the opportunity
  to give them build-time switches to use unaligned LDR((S)H)/STR(H)
  instructions if built for a new enough platform. Also added a couple of
  cases of LDRSB that will benefit v4 CPUs and a few instances of the v6
  SXTH instruction, but since objasm doesn't yet understand it (and when it
  does, not everyone will have upgraded) they are currently written as
  DCI statements.
  Most of the changes are to OS_Word handlers, which are notorious in that
  their input/output block is not word-aligned.
Admin:
  Not tested, but it should at least build.

Version 5.35, 4.79.2.98.2.6. Tagged as 'Kernel-5_35-4_79_2_98_2_6'
@
text
@a242 1
      [ NoARMv6
a257 7
      |
        ; Use unaligned loads from ARMv6
        LDRH    R2, [R1, #1]            ; R2 = left
        LDRH    R3, [R1, #3]            ; R3 = bottom
        LDRH    R4, [R1, #5]            ; R4 = right
        LDRH    R5, [R1, #7]            ; R5 = top
      ]
a271 1
      [ NoARMv6
a279 7
      |
        ; ARMv6 lets you do this using SXTH, but no support in objasm yet
        DCI     &E6BF2072  ; SXTH    R2, R2
        DCI     &E6BF3073  ; SXTH    R3, R3
        DCI     &E6BF4074  ; SXTH    R4, R4
        DCI     &E6BF5075  ; SXTH    R5, R5
      ]
a398 1
      [ NoARMv4
a401 3
      |
        LDRSB   R0, [R1, #1]
      ]
a403 1
      [ NoARMv4
a406 3
      |
        LDRSB   R0, [R1, #2]
      ]
a418 1
      [ NoARMv6
a437 12
      |
        ; Use unaligned loads and SXTH from ARMv6
        LDRH    R0, [R1, #1]            ; get X coordinate
        LDR     R2, [WsPtr, #OrgX]      ; add on origin
        ADD     R0, R0, R2
        DCI     &E6BF2070 ; SXTH    R2, R0

        LDRH    R0, [R1, #3]            ; get Y coordinate
        LDR     R3, [WsPtr, #OrgY]      ; add on origin
        ADD     R0, R0, R3
        DCI     &E6BF3070 ; SXTH    R3, R0
      ]
a479 1
      [ NoARMv6
a482 4
      |
        ; Use unaligned store from ARMv6
        STRH    R2, [R1, #1]            ; store X
      ]
a486 1
      [ NoARMv6
a489 4
      |
        ; Use unaligned store from ARMv6
        STRH    R3, [R1, #3]            ; store X
      ]
@


4.3.2.4.2.2
log
@  Miscellaneous v6-related updates
Detail:
 * Stopped calling the broken abort fixup code when running under VMSAv6.
   Might be desirable to update it, possibly farmed out to a separate module -
   still need to think about this.
 * Unaligned load optimisations can now be disabled by the global NoUnaligned
   flag for testing purposes.
 * Extended OS_ReadUnsigned to permit reading of 64-bit unsigned integers.
   See Docs.ReadUnsigned for more details. Also sped it up by using MLA
   (or UMLAL) for most digits rather than repeated addition.
 * Bugfix is OS_GSRead: an uninitialised r0 was being passed to
   OS_ReadUnsigned, causing undesirable effects on rare occasions.
Admin:
  Tested on a rev B7 beagleboard.

Version 5.35, 4.79.2.98.2.8. Tagged as 'Kernel-5_35-4_79_2_98_2_8'
@
text
@d243 1
a243 1
      [ NoARMv6 :LOR: NoUnaligned
d443 1
a443 1
      [ NoARMv6 :LOR: NoUnaligned
d517 1
a517 1
      [ NoARMv6 :LOR: NoUnaligned
d529 1
a529 1
      [ NoARMv6 :LOR: NoUnaligned
@


4.3.2.4.2.3
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d310 1
a310 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d413 1
a413 1
        LDR     R11, =ZeroPage+KeyWorkSpace
a446 4
      |
        ; Use unaligned loads and SXTH from ARMv6
        LDRH    R0, [R1, #1]            ; get X coordinate
      ]
a450 1
      [ NoARMv6
a452 3
      |
        DCI     &E6BF2070 ; SXTH    R2, R0
      ]
a453 1
      [ NoARMv6 :LOR: NoUnaligned
a456 3
      |
        LDRH    R0, [R1, #3]            ; get Y coordinate
      ]
a460 1
      [ NoARMv6
d464 9
d482 1
a482 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d502 1
a502 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d547 1
a547 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d556 1
a556 1
        LDR     R11, =ZeroPage+KeyWorkSpace
a600 2
        LTORG

@


4.3.2.4.2.3.2.1
log
@  Support for Raspberry Pi / BCM2835
Detail:
  Falls into two main areas: graphics support and ARM11 core support.
  A work in progress - in many cases the code changes need to be replaced
  with an alternative mechanism which will permit the kernel to still function
  on other platforms. Adrian marked these with "!!!" comments - I have added
  ! directives as well so that they don't get forgotten about.
Admin:
  Changes received from Adrian Lees. This revision represents the code largely
  as delivered, and is placed on its own branch (forked off from the version
  from which he worked). It is intended for reference. It doesn't build against
  current headers - this is likely to require a merge with the other changes
  to the kernel since that time.

Version 5.35, 4.79.2.98.2.52.2.1. Tagged as 'Kernel-5_35-4_79_2_98_2_52_2_1'
@
text
@a606 56
; *****************************************************************************
;
;       RemovePointer - Remove soft mouse pointer from screen
;

RemovePointer ROUT
        STMFD   R13!,{R0-R6,R14}
        LDRB    R3, [WsPtr, #PointerShapeNumber]
        TST     R3, #&7F
        MOVNE   R0, #0
        MOVNE   R4, #GraphicsV_UpdatePointer
        BLNE    CallGraphicsV
        LDMFD   R13!,{R0-R6,PC}

; *****************************************************************************
;
;       RestorePointer - Restore soft mouse pointer to previous state
;

RestorePointer ROUT
        STMFD   R13!,{R0-R6,R14}
        LDRB    R6, [WsPtr, #PointerShapeNumber]
        ANDS    R6, R6, #&7F
        BEQ     %FT10

        ADD     R3, WsPtr, #PointerShapes-4
        LDR     R3, [R3, R6, LSL #2]         ; R3 -> current shape block (R6 = shape 1..4)

        MOV     R0, #1                       ; R0 = flags, set pointer on (bit 0 = 1)

        LDR     R1, [WsPtr, #PointerShapeLA] ; last shape buffer given to HAL
        LDR     R4, [R3, #PointerBuffLA]     ; shape buffer we're about to give
        TEQ     R1, R4                       ; same as last time?
        STRNE   R4, [WsPtr, #PointerShapeLA] ; update
        ORRNE   R0, R0, #2                   ; flag new shape (bit 1 = 1)

        LDR     R1, [WsPtr, #PointerX]
        LDR     R4, [WsPtr, #PointerXEigFactor]
        MOV     R1, R1, ASR R4                     ; R1 = pointer x, pixels
        LDRB    R4, [R3, #PointerActiveX]
        SUB     R1, R1, R4                         ; R1 = pointer x, adjusted for active point

        LDR     R2, [WsPtr, #PointerY]
        LDR     R4, [WsPtr, #DisplayYEigFactor]
        LDR     R5, [WsPtr, #DisplayYWindLimit]    ; R5 = display height -1
        SUB     R2, R5, R2, ASR R4                 ; R2 = pointer y, pixels, inverted
        LDRB    R4, [R3, #PointerActiveY]
        SUB     R2, R2, R4                         ; R2 = pointer y, adjusted for active point

        ; and it's up to the HAL to handle clipping according to h/w capabilities

        MOV     R4, #GraphicsV_UpdatePointer
        BL      CallGraphicsV
10
        LDMFD   R13!,{R0-R6,PC}

@


4.2
log
@Kernel merged
@
text
@a81 15
; *****Change made by DJS & SKS
; Original code was:
;        CMP     R0, #1
;        BCC     DoDefinePointer
;        BEQ     DoMouseBox
;        CMP     R0, #3
;        BCC     SetMouseMult
;        BEQ     SetMousePosn
;        CMP     R0, #5
;        BCC     ReadMousePosn
;        BEQ     SetPointerPosn
;        CMP     R0, #7
;        BCC     ReadPointerPosn
;        MOV     PC, R14

a83 14
        [       Module

        ADDCC   PC, PC, R0, LSL #2
        MOV     PC, R14                 ; ***** WHY NO ERROR????????
        B       DoDefinePointer
        B       DoMouseBox
        B       SetMouseMult
        B       SetMousePosn
        B       ReadMousePosn
        B       SetPointerPosn
        B       ReadPointerPosn

        |

a93 4
        ]

; *****End of change made by DJS & SKS

a98 1
 [ Fix8
d100 1
a100 1
 ]
a170 1
 [ LCDSupport
d174 1
a174 6
;wait for vsync moved to osbyte &6A
; [ Fix8
;        CLRPSR  I_bit, R0                       ; could take some time
; ]
;        MOV     R0, #19                         ; wait for vsync, so we change
;        SWI     XOS_Byte                        ; cleanly (ignore errors)
d239 3
a241 4
        CMP     R5, R6
        BNE     %FT10                           ; Phewee, we don't have to do the OSByte
        MOV     R0, #106
        SWI     XOS_Byte                        ; Do the Byte Man!
a244 65
 |                              ;BELOW MUST BE UNINDENTED BY 4CHARS TO WORK AGAIN!!!!!!!
    DoDefinePointer
            Push    "R1-R6, R14"
     [ Fix8
            CLRPSR  I_bit, R0                       ; could take some time
     ]
            MOV     R0, #19                         ; wait for vsync, so we change
            SWI     XOS_Byte                        ; cleanly (ignore errors)

            LDMFD   R13, {R1}                       ; get back pointer to block

            LDRB    R6, [R1, #1]                    ; shape number
            SUB     R6, R6, #1
            CMP     R6, #4                          ; now in range 0..3 ?
            BCS     %FT10                           ; bad shape number

            ADD     WsPtr, WsPtr, R6                ; point to table entries

            LDRB    R0, [R1, #2]                    ; R0 = width
            LDRB    R2, [R1, #3]                    ; R2 = height
            LDRB    R3, [R1, #4]                    ; R3 = ActiveX
            LDRB    R4, [R1, #5]                    ; R4 = ActiveY

            CMP     R2, #0                          ; C=1 if EQ
            STREQB  R2, [WsPtr, #PointerHeights]
            BEQ     %FT10

            CMP     R0, #0                          ; C=1 if EQ
            STREQB  R0, [WsPtr, #PointerHeights]
            CMPNE   R0, #8+1
            BCS     %FT10                           ; bad width

            CMP     R2, #32+1                       ; C=1 => bad height
            CMPCC   R3, R0, LSL #2                  ; ActiveX >= (width * 4) ?
            CMPCC   R4, R2                          ; ActiveY >= height

            BCS     %FT10                           ; bad definition

            STRB    R2, [WsPtr, #PointerHeights]
            STRB    R3, [WsPtr, #PointerActiveXs]
            STRB    R4, [WsPtr, #PointerActiveYs]

            ADD     R4, R1, #6
            LDW     R1, R4, R3, R5                  ; load word from
                                                    ; unknown alignment
    ; Now R1 -> user's data

            LDR     R3, =CursorData                 ; &200 per shape, so
            ADD     R3, R3, R6, LSL #9              ; R3 -> first copy
            ADD     R6, R3, #&F8                    ; R6 -> second copy
    20
            ADD     R4, R3, R0                      ; terminating R3 for this row
    30
            LDRB    R5, [R1], #1
    40
            STRB    R5, [R3], #1                    ; store to 1st copy
            STRB    R5, [R6], #1                    ; store to 2nd copy
            CMP     R3, R4                          ; still within user data
            BCC     %BT30                           ; for this row ?

    ; now fill up rest of row

            MOV     R5, #0
            TST     R3, #7                          ; are we on a multiple of 8
            BNE     %BT40                           ; no, then store 0
d246 29
a274 2
            SUBS    R2, R2, #1                      ; done all rows ?
            BNE     %BT20                           ; no, then loop
a275 2
    10
            Pull    "R1-R6,PC"
a276 2
        
        ]
d364 3
a366 3
        MOV     R14, PC
        ORR     R0, R14, #I_bit
        TEQP    R0, #0
d390 1
a390 10
;        BL      FlushMouse              ; flush mouse buffer no longer done

; *****Change made by DJS and SKS
; Bug fix. Original code was:
;        TEQP    R14, #0                 ; restore old IRQ state
;10
;        Pull    "R1-R6, PC"
; This is making use of a nonsense value of R14. It also looks as if this
; can be made shorter:

d392 1
a392 1
        Pull    "R1-R6, PC",,^          ;Return, restoring old IRQ state
a429 2
 [ VIDC_Type = "VIDC20"

a448 25
 |
        LDR     R1, [WsPtr, #CursorFudgeFactor]
        LDRB    R2, [R6, #PointerActiveXs]
        SUB     R1, R1, R2

        LDR     R2, [WsPtr, #PointerXEigFactor]
        LDR     R3, [WsPtr, #PointerX]
        MOV     R3, R3, ASR R2

        LDR     R4, [WsPtr, #DisplayModeFlags]
        TST     R4, #Flag_HiResMono     ; if not hi-res-mono
        MOVEQ   R3, R3, LSL #2          ; then multiply by 4

        ADD     R3, R3, R1, LSL #2      ; X := X + (CursFudgeFactor-ActiveX)<<2

        CMP     R3, #0                  ; if < 0 then make =0
        MOVLT   R3, #0

        CMP     R3, #8*1024             ; if >= limit then make =limit-1
        MOVGE   R3, #8*1024
        SUBGE   R3, R3, #1

        MOV     R3, R3, LSL #11
        ORR     R3, R3, #HorizCursorStart
 ]
a560 1
 [ MEMC_Type = "IOMD"
a564 3
 |
        LDR     r0, =PhysCursorStartAdr
 ]
a569 3
 [ VIDC_Type <> "VIDC20"
        MOV     R1, R1, LSL #14         ; shift up
 ]
a575 1
 [ VIDC_Type = "VIDC20"
a576 3
 |
        ADD     R1, R1, R2, LSL #14     ; add height
 ]
a581 1
 [ LCDSupport                   ;Assumes/Includes VIDC20 support & IOMD
d611 8
a770 160
 |                              ;BELOW MUST BE UNINDENTED BY 4CHARS TO WORK AGAIN!!!!!!!
    UpdatePointer ROUT
            MOV     R11, #KeyWorkSpace
            MOV     R10, #VIDC

            LDRB    R5, [WsPtr, #PointerShapeNumber]
            TST     R5, #&80                ; pointer unlinked if bit 7 set

            LDREQ   R6, MouseX
            STREQ   R6, [WsPtr, #PointerX]
            LDREQ   R6, MouseY
            STREQ   R6, [WsPtr, #PointerY]

            ANDS    R5, R5, #&7F            ; clear bit 7 and set Z if 0 ie off
            SUBNE   R5, R5, #1
            ADDNE   R6, WsPtr, R5           ; R6 is WsPtr + index

            LDRNEB  R0, [R6, #PointerHeights]
            TEQNE   R0, #0                  ; if shape 0 or height 0
            BNE     %FT07
    05

    ; don't display pointer

            MOV     R1, #0                  ; Y := 0
            MOV     R2, #0                  ; height := 0
            MOV     R4, #0                  ; LAG offset := 0
            B       %FT10

    07
     [ VIDC_Type = "VIDC20"

            LDR     R2, [WsPtr, #PointerXEigFactor]
            LDR     R3, [WsPtr, #PointerX]
            MOV     R3, R3, ASR R2

            LDRB    R2, [R6, #PointerActiveXs]
            SUB     R3, R3, R2              ; subtract off active point coord

            CMP     R3, #-31                ; if LHS < -31, ie RHS < 0
            BLT     %BT05                   ; then remove pointer completely (fixes MED-00523)

            LDR     R1, [WsPtr, #CursorFudgeFactor]
            ADDS    R3, R3, R1              ; X := X + CursFudgeFactor
            MOVLT   R3, #0                  ; if < 0 then make =0

            CMP     R3, #16*1024            ; if >= limit then make =limit-1
            MOVGE   R3, #16*1024
            SUBGE   R3, R3, #1

            ORR     R3, R3, #HorizCursorStart
     |
            LDR     R1, [WsPtr, #CursorFudgeFactor]
            LDRB    R2, [R6, #PointerActiveXs]
            SUB     R1, R1, R2

            LDR     R2, [WsPtr, #PointerXEigFactor]
            LDR     R3, [WsPtr, #PointerX]
            MOV     R3, R3, ASR R2

            LDR     R4, [WsPtr, #DisplayModeFlags]
            TST     R4, #Flag_HiResMono     ; if not hi-res-mono
            MOVEQ   R3, R3, LSL #2          ; then multiply by 4

            ADD     R3, R3, R1, LSL #2      ; X := X + (CursFudgeFactor-ActiveX)<<2

            CMP     R3, #0                  ; if < 0 then make =0
            MOVLT   R3, #0

            CMP     R3, #8*1024             ; if >= limit then make =limit-1
            MOVGE   R3, #8*1024
            SUBGE   R3, R3, #1

            MOV     R3, R3, LSL #11
            ORR     R3, R3, #HorizCursorStart
     ]

     [ {FALSE} ; debug horiz pointer programming
            Push    "r0,lr"
            MOV     r0, r3
            BL      TubeDumpR0
            BL      TubeNewl
            Pull    "r0,lr"
     ]

            STR     R3, [R10]

    ; now process Y

            LDR     R1, [WsPtr, #PointerY]
            LDR     R2, [WsPtr, #DisplayYEigFactor]

            LDR     R3, [WsPtr, #DisplayYWindLimit]
                                            ; Total height of screen in pixels-1
            SUB     R1, R3, R1, ASR R2      ; convert Y to pixels and invert

            LDRB    R2, [R6, #PointerActiveYs]
            SUB     R1, R1, R2

            MOV     R2, #0                  ; height
            MOV     R4, R5, LSL #9          ; LAG offset from CursorData

            ADD     R5, R3, #1              ; Total vertical pixels

            ADDS    R3, R1, R0              ; R3 = Y + PointerHeight(shape)
            MOVLE   R1, #0                  ; if <= 0 then off, ie Y=0, height=0
            BLE     %FT10

            CMP     R1, R5                  ; Y >= TotalHeight
            MOVGE   R1, #0                  ; then off
            BGE     %FT10

            CMP     R3, R5                  ; Y + PointerHeight > TotalHeight
            RSBGT   R2, R1, R5              ; then height=TotalHeight-Y
            BGT     %FT10

            CMP     R1, #0                  ; Y >=0
            MOVGE   R2, R0                  ; then height=PointerHeight
            BGE     %FT10

            TST     R1, #1                  ; Y odd ?
            ADDNE   R4, R4, #&100           ; then use 2nd copy

            ADD     R2, R1, R0              ; height = PointerHeight+Y

            RSB     R1, R1, #0              ; Y := -Y
            BIC     R1, R1, #1              ; Y := (-Y AND NOT 1)
            ADD     R4, R4, R1, LSL #3      ; add on offset into shape
            MOV     R1, #0                  ; Y := 0
    10
            Push    "r1, r14"
     [ MEMC_Type = "IOMD"
            MOV     r0, #0
            LDR     r0, [r0, #DRAMPhysAddrA]
            LDR     r1, =DRAMOffset_CursorChunk + (CursorData - CursorChunkAddress)
            ADD     r0, r0, r1
     |
            LDR     r0, =PhysCursorStartAdr
     ]
            ADD     r0, r0, r4
            MOV     r1, #MEMCDAG_CInit
            BL      SetDAG
            Pull    "r1, r14"

     [ VIDC_Type <> "VIDC20"
            MOV     R1, R1, LSL #14         ; shift up
     ]
            LDR     R3, [WsPtr, #VertAdjust] ; get display start value
            ADD     R1, R1, R3              ; and add on

            ORR     R3, R1, #VertiCursorStart
            STR     R3, [R10]

     [ VIDC_Type = "VIDC20"
            ADD     R1, R1, R2              ; add height
     |
            ADD     R1, R1, R2, LSL #14     ; add height
     ]
            ORR     R3, R1, #VertiCursorEnd
            STR     R3, [R10]
a771 3
            MOV     PC, R14
 ]
        
d783 1
a783 1
        MOV     R0, R0, LSL #24         ; sign extend to 32 bits
d788 1
a788 1
        MOV     R0, R0, LSL #24         ; sign extend to 32 bits
d809 1
a809 1
        MOV     R0, R0, LSL #16         ; sign extend 16 to 32
d819 1
a819 1
        MOV     R0, R0, LSL #16         ; sign extend 16 to 32
@


4.2.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d132 1
d134 1
d210 1
d212 1
d289 1
d291 1
d544 23
d569 7
d686 1
d694 1
d705 1
d762 7
d946 23
d971 7
d1031 1
d1039 1
d1050 1
@


4.2.2.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d129 74
d353 1
d486 187
d878 2
d899 3
d949 1
d954 2
d961 2
d969 1
d971 2
d979 1
@


4.2.2.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d129 74
d353 1
d486 187
d878 2
d899 3
d949 1
d954 2
d961 2
d969 1
d971 2
d979 1
@


4.1
log
@Initial revision
@
text
@d129 1
d178 1
d180 1
d187 1
d189 1
d204 156
d492 1
a492 1

d586 31
a617 1

a619 1

d622 1
d642 26
d678 1
d711 348
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a176 1
 [ :LNOT: InterlacedPointer
a177 1
 ]
a183 1
 [ :LNOT: InterlacedPointer
a184 1
 ]
a424 31
 [ InterlacedPointer
	MOV	r8, r5, LSL #9		; LAG offset from CursorData
	LDR	r5, [WsPtr, #DisplayModeFlags]
	TST	r5, #Flag_InterlacedMode ; if not interlaced mode
	LDRB	r5, [r6, #PointerActiveYs] ; (load active Y in both cases)
	SUBEQ	r1, r3, r1, ASR r2	; then convert Y to pixels and invert
	SUBEQ	r1, r1, r5		; and subtract off active Y
	MOVEQ	r7, #3			; log2(offset from one row to next for copy)
	MOVEQ	r4, r8			; use initial base value if non-interlaced
	BEQ	%FT02			; then skip interlaced fudging

	SUB	r2, r2, #1		; convert field YEIG to frame YEIG
	ADD	r1, r5, r1, ASR r2	; convert Y to frame rasters and adjust for active Y
	LDR	r5, =OsbyteVars + :INDEX: CFStime ; the interlace module keeps the CFSTime variable with the
	LDRB	r5, [r5]		; bottom bit equal to the interlace phase, so read it to check phase
	TST	r5, #1			; if on top field
	SUBEQ	r1, r1, #1		; then move Y coordinate down by one frame line

	ANDS	r7, r1, #1		; if on bottom pattern (NE)
	ADD	r4, r8, r7, LSL #3	; then r4 -> 2nd line down else r4 -> top line
	ADDEQ	r0, r0, #1		; else on top, so round height up if odd
	SUB	r1, r3, r1, ASR #1	; convert Y to field lines and invert
	MOV	r7, #4			; log2(offset from one row to next)
	MOVS	r0, r0, LSR #1		; convert height to field lines
	MOVEQ	r1, #0			; if no lines
	MOVEQ	r2, #0			; then off
	MOVEQ	r4, #0
	BEQ	%FT10
02
        MOV     r2, #0                  ; height
 |
d426 1
d429 1
a431 1
 ]
a450 26
 [ InterlacedPointer
	ADD	r2, r1, r0		; height = PointerHeight + Y
	SUB	r4, r4, r1, LSL r7	; add on offset into shape data
	MOV	r1, #0			; set Y offset to zero
10
	TEQ	r7, #3			; if we're not doing interlaced
	TSTEQ	r4, #15			; and we're quad-word aligned
	BEQ	%FT20			; then just position pointer within original copy of data

	MOV	r9, #1
	MOV	r9, r9, LSL r7		; offset from one row to next
	ADD	r7, r8, #&100		; point r7 at 2nd copy offset
	LDR	r3, =CursorData
	ADD	r7, r7, r3		; r7 = absolute address of destination
	ADD	r3, r3, r4		; r3 = absolute address of source
	MOVS	r6, r2			; r6 = number of lines to do
	BEQ	%FT20			; none to do
15
	LDMIA	r3, {r0, r5}		; load 1 row of source data
	STMIA	r7!, {r0, r5}		; store to dest, advancing dest ptr
	ADD	r3, r3, r9		; advance source ptr
	SUBS	r6, r6, #1
	BNE	%BT15
	ADD	r4, r8, #&100		; move pointer to new altered copy
20
 |
a460 1
 ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a176 1
 [ :LNOT: InterlacedPointer
a177 1
 ]
a183 1
 [ :LNOT: InterlacedPointer
a184 1
 ]
a424 31
 [ InterlacedPointer
	MOV	r8, r5, LSL #9		; LAG offset from CursorData
	LDR	r5, [WsPtr, #DisplayModeFlags]
	TST	r5, #Flag_InterlacedMode ; if not interlaced mode
	LDRB	r5, [r6, #PointerActiveYs] ; (load active Y in both cases)
	SUBEQ	r1, r3, r1, ASR r2	; then convert Y to pixels and invert
	SUBEQ	r1, r1, r5		; and subtract off active Y
	MOVEQ	r7, #3			; log2(offset from one row to next for copy)
	MOVEQ	r4, r8			; use initial base value if non-interlaced
	BEQ	%FT02			; then skip interlaced fudging

	SUB	r2, r2, #1		; convert field YEIG to frame YEIG
	ADD	r1, r5, r1, ASR r2	; convert Y to frame rasters and adjust for active Y
	LDR	r5, =OsbyteVars + :INDEX: CFStime ; the interlace module keeps the CFSTime variable with the
	LDRB	r5, [r5]		; bottom bit equal to the interlace phase, so read it to check phase
	TST	r5, #1			; if on top field
	SUBEQ	r1, r1, #1		; then move Y coordinate down by one frame line

	ANDS	r7, r1, #1		; if on bottom pattern (NE)
	ADD	r4, r8, r7, LSL #3	; then r4 -> 2nd line down else r4 -> top line
	ADDEQ	r0, r0, #1		; else on top, so round height up if odd
	SUB	r1, r3, r1, ASR #1	; convert Y to field lines and invert
	MOV	r7, #4			; log2(offset from one row to next)
	MOVS	r0, r0, LSR #1		; convert height to field lines
	MOVEQ	r1, #0			; if no lines
	MOVEQ	r2, #0			; then off
	MOVEQ	r4, #0
	BEQ	%FT10
02
        MOV     r2, #0                  ; height
 |
d426 1
d429 1
a431 1
 ]
a450 26
 [ InterlacedPointer
	ADD	r2, r1, r0		; height = PointerHeight + Y
	SUB	r4, r4, r1, LSL r7	; add on offset into shape data
	MOV	r1, #0			; set Y offset to zero
10
	TEQ	r7, #3			; if we're not doing interlaced
	TSTEQ	r4, #15			; and we're quad-word aligned
	BEQ	%FT20			; then just position pointer within original copy of data

	MOV	r9, #1
	MOV	r9, r9, LSL r7		; offset from one row to next
	ADD	r7, r8, #&100		; point r7 at 2nd copy offset
	LDR	r3, =CursorData
	ADD	r7, r7, r3		; r7 = absolute address of destination
	ADD	r3, r3, r4		; r3 = absolute address of source
	MOVS	r6, r2			; r6 = number of lines to do
	BEQ	%FT20			; none to do
15
	LDMIA	r3, {r0, r5}		; load 1 row of source data
	STMIA	r7!, {r0, r5}		; store to dest, advancing dest ptr
	ADD	r3, r3, r9		; advance source ptr
	SUBS	r6, r6, #1
	BNE	%BT15
	ADD	r4, r8, #&100		; move pointer to new altered copy
20
 |
a460 1
 ]
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d129 1
a129 2
 [ LCDSupport
DoDefinePointer ;Only copies the pointer defn into the defn buffer. OSByte 6A now copies the defn into the 'current' buffer -WT
d131 5
a135 7

;wait for vsync moved to osbyte &6A
; [ Fix8
;        CLRPSR  I_bit, R0                       ; could take some time
; ]
;        MOV     R0, #19                         ; wait for vsync, so we change
;        SWI     XOS_Byte                        ; cleanly (ignore errors)
d175 3
a177 3
        LDR     R3, =CursorData                 ; &100 per shape, 8 copies (4 current + 4 pointer definitions)
        ADD     R3, R3, #&400                   ; Skip the 'current' copies
        ADD     R3, R3, R6, LSL #8              ; R3 -> place to dump pointer definition
d184 1
a196 9
        ;Check whether the pointer we've just updated is the current one & if so, call OSByte 6A to update the current buffers.
        LDRB    R1, [WsPtr, #PointerShapeNumber]
        AND     R5, R1, #&7F                    ; Clear bit 7 from the ptrshapenumber - it is irrelevant atm.
        ADD     R6, R6, #1                      ; Get R6 back to range 1-4
        CMP     R5, R6
        BNE     %FT10                           ; Phewee, we don't have to do the OSByte
        MOV     R0, #106
        SWI     XOS_Byte                        ; Do the Byte Man!

a198 72
 |                              ;BELOW MUST BE UNINDENTED BY 4CHARS TO WORK AGAIN!!!!!!!
    DoDefinePointer
            Push    "R1-R6, R14"
     [ Fix8
            CLRPSR  I_bit, R0                       ; could take some time
     ]
            MOV     R0, #19                         ; wait for vsync, so we change
            SWI     XOS_Byte                        ; cleanly (ignore errors)

            LDMFD   R13, {R1}                       ; get back pointer to block

            LDRB    R6, [R1, #1]                    ; shape number
            SUB     R6, R6, #1
            CMP     R6, #4                          ; now in range 0..3 ?
            BCS     %FT10                           ; bad shape number

            ADD     WsPtr, WsPtr, R6                ; point to table entries

            LDRB    R0, [R1, #2]                    ; R0 = width
            LDRB    R2, [R1, #3]                    ; R2 = height
            LDRB    R3, [R1, #4]                    ; R3 = ActiveX
            LDRB    R4, [R1, #5]                    ; R4 = ActiveY

            CMP     R2, #0                          ; C=1 if EQ
            STREQB  R2, [WsPtr, #PointerHeights]
            BEQ     %FT10

            CMP     R0, #0                          ; C=1 if EQ
            STREQB  R0, [WsPtr, #PointerHeights]
            CMPNE   R0, #8+1
            BCS     %FT10                           ; bad width

            CMP     R2, #32+1                       ; C=1 => bad height
            CMPCC   R3, R0, LSL #2                  ; ActiveX >= (width * 4) ?
            CMPCC   R4, R2                          ; ActiveY >= height

            BCS     %FT10                           ; bad definition

            STRB    R2, [WsPtr, #PointerHeights]
            STRB    R3, [WsPtr, #PointerActiveXs]
            STRB    R4, [WsPtr, #PointerActiveYs]

            ADD     R4, R1, #6
            LDW     R1, R4, R3, R5                  ; load word from
                                                    ; unknown alignment
    ; Now R1 -> user's data

            LDR     R3, =CursorData                 ; &200 per shape, so
            ADD     R3, R3, R6, LSL #9              ; R3 -> first copy
            ADD     R6, R3, #&F8                    ; R6 -> second copy
    20
            ADD     R4, R3, R0                      ; terminating R3 for this row
    30
            LDRB    R5, [R1], #1
    40
            STRB    R5, [R3], #1                    ; store to 1st copy
            STRB    R5, [R6], #1                    ; store to 2nd copy
            CMP     R3, R4                          ; still within user data
            BCC     %BT30                           ; for this row ?

    ; now fill up rest of row

            MOV     R5, #0
            TST     R3, #7                          ; are we on a multiple of 8
            BNE     %BT40                           ; no, then store 0

            SUBS    R2, R2, #1                      ; done all rows ?
            BNE     %BT20                           ; no, then loop

    10
            Pull    "R1-R6,PC"
 ]
a331 1
 [ LCDSupport                   ;Assumes/Includes VIDC20 support & IOMD
d361 2
d382 25
d431 1
a431 1
        MOV     R4, #0                  ; LAG offset from CursorData
d452 1
a452 1
        ADDNE   R4, R4, #&200           ; then use 2nd pair of copies (ie the ones that start at line 1)
a460 33

        ;Rightio, it's time to muck about if we're on a dual-panel LCD...
        Push    "r5,r14"
        MOV     r14, #0
        LDRB    r14, [r14, #LCD_Active]
        TST     r14, #&80
        MOVEQ   r14, #CursorSinglePanel ; Not a dual-panel, so no mucking about to do.
        BEQ     %FT12

        ;OTOH, it _is_ a dual panel, so best do some umming and ahhing. Um ah. :-)
        MOV     R5, R5, LSR #1          ; R5 is half the number of displayed rasters
        CMP     R5, R1
        MOVLT   R14, #CursorBottomPanel ; Pointer starts below the split, so it's in the bottom panel
        SUBLT   R1, R1, R5              ; Subtract the 1/2 panel offset
        BLT     %FT12

        ADD     R14, R1, R2             ; Get the 'y' of the bottom of the pointer
        CMP     R5, R14                 ; See if the pointer straddles the panels
        MOVGE   R14, #CursorTopPanel    ; Nope, it's entirely in the top panel
        BGE     %FT12

        TST     R1, #1                  ; Is the cursor on an odd Y?
        ADDNE   R4, R4, #&200           ; If so, then point to the odd-aligned pair of images
        SUB     R14, R1, R5             ; R14(Y) = Y-1/2 panel (ie Y is now < 0)
        RSB     R14, R14, #0            ; Y := -Y
        BIC     R14, R14, #1            ; Y := (-Y AND NOT 1)
        ADD     R4, R4, R14, LSL #3     ; add on offset into shape
        RSB     R2, R14, #32            ; R2 is now the height of the pointer block which belongs in the bottom panel
        SUBNE   R2, R2, #1              ; Knock another off if we're using the odd-aligned images (dunno why...)

        MOV     R14, #CursorStraddle    ; It straddles the paddles, so special programming of VCSR & VCER required later...

12
d462 1
d467 3
a469 1

d475 3
a477 3
        CMP     R14, #CursorStraddle
        BEQ     %FT13                   ;It's a cursor straddly thingy, so we've to muck the VCSR & VCER up...

d482 1
a482 2
        ORR     R14, R3, R14            ; Set the 'special' LCD bits
        STR     R14, [R10]
d484 1
d486 3
a488 1

a491 1
        Pull    "r5,r14"
a492 181

13
        LDR     R3, [WsPtr, #VertAdjust] ; get display start value
        ADD     R1, R1, R3              ; and add on

        ORR     R3, R1, #VertiCursorEnd
        ORR     R5, R3, R14             ; Set the 'straddle' LCD bits
        STR     R5, [R10]

;        LDR     R3, [WsPtr, #VertAdjust] ; get display start value
;        ADD     R2, R2, R3               ; R2 is pointerheight+vertadjust
        ORR     R3, R2, #VertiCursorStart
        ORR     R14, R3, R14            ; Set the 'straddle' LCD bits
        STR     R14, [R10]

        Pull    "r5,r14"
        MOV     PC, R14

 |                              ;BELOW MUST BE UNINDENTED BY 4CHARS TO WORK AGAIN!!!!!!!
    UpdatePointer ROUT
            MOV     R11, #KeyWorkSpace
            MOV     R10, #VIDC

            LDRB    R5, [WsPtr, #PointerShapeNumber]
            TST     R5, #&80                ; pointer unlinked if bit 7 set

            LDREQ   R6, MouseX
            STREQ   R6, [WsPtr, #PointerX]
            LDREQ   R6, MouseY
            STREQ   R6, [WsPtr, #PointerY]

            ANDS    R5, R5, #&7F            ; clear bit 7 and set Z if 0 ie off
            SUBNE   R5, R5, #1
            ADDNE   R6, WsPtr, R5           ; R6 is WsPtr + index

            LDRNEB  R0, [R6, #PointerHeights]
            TEQNE   R0, #0                  ; if shape 0 or height 0
            BNE     %FT07
    05

    ; don't display pointer

            MOV     R1, #0                  ; Y := 0
            MOV     R2, #0                  ; height := 0
            MOV     R4, #0                  ; LAG offset := 0
            B       %FT10

    07
     [ VIDC_Type = "VIDC20"

            LDR     R2, [WsPtr, #PointerXEigFactor]
            LDR     R3, [WsPtr, #PointerX]
            MOV     R3, R3, ASR R2

            LDRB    R2, [R6, #PointerActiveXs]
            SUB     R3, R3, R2              ; subtract off active point coord

            CMP     R3, #-31                ; if LHS < -31, ie RHS < 0
            BLT     %BT05                   ; then remove pointer completely (fixes MED-00523)

            LDR     R1, [WsPtr, #CursorFudgeFactor]
            ADDS    R3, R3, R1              ; X := X + CursFudgeFactor
            MOVLT   R3, #0                  ; if < 0 then make =0

            CMP     R3, #16*1024            ; if >= limit then make =limit-1
            MOVGE   R3, #16*1024
            SUBGE   R3, R3, #1

            ORR     R3, R3, #HorizCursorStart
     |
            LDR     R1, [WsPtr, #CursorFudgeFactor]
            LDRB    R2, [R6, #PointerActiveXs]
            SUB     R1, R1, R2

            LDR     R2, [WsPtr, #PointerXEigFactor]
            LDR     R3, [WsPtr, #PointerX]
            MOV     R3, R3, ASR R2

            LDR     R4, [WsPtr, #DisplayModeFlags]
            TST     R4, #Flag_HiResMono     ; if not hi-res-mono
            MOVEQ   R3, R3, LSL #2          ; then multiply by 4

            ADD     R3, R3, R1, LSL #2      ; X := X + (CursFudgeFactor-ActiveX)<<2

            CMP     R3, #0                  ; if < 0 then make =0
            MOVLT   R3, #0

            CMP     R3, #8*1024             ; if >= limit then make =limit-1
            MOVGE   R3, #8*1024
            SUBGE   R3, R3, #1

            MOV     R3, R3, LSL #11
            ORR     R3, R3, #HorizCursorStart
     ]

     [ {FALSE} ; debug horiz pointer programming
            Push    "r0,lr"
            MOV     r0, r3
            BL      TubeDumpR0
            BL      TubeNewl
            Pull    "r0,lr"
     ]

            STR     R3, [R10]

    ; now process Y

            LDR     R1, [WsPtr, #PointerY]
            LDR     R2, [WsPtr, #DisplayYEigFactor]

            LDR     R3, [WsPtr, #DisplayYWindLimit]
                                            ; Total height of screen in pixels-1
            SUB     R1, R3, R1, ASR R2      ; convert Y to pixels and invert

            LDRB    R2, [R6, #PointerActiveYs]
            SUB     R1, R1, R2

            MOV     R2, #0                  ; height
            MOV     R4, R5, LSL #9          ; LAG offset from CursorData

            ADD     R5, R3, #1              ; Total vertical pixels

            ADDS    R3, R1, R0              ; R3 = Y + PointerHeight(shape)
            MOVLE   R1, #0                  ; if <= 0 then off, ie Y=0, height=0
            BLE     %FT10

            CMP     R1, R5                  ; Y >= TotalHeight
            MOVGE   R1, #0                  ; then off
            BGE     %FT10

            CMP     R3, R5                  ; Y + PointerHeight > TotalHeight
            RSBGT   R2, R1, R5              ; then height=TotalHeight-Y
            BGT     %FT10

            CMP     R1, #0                  ; Y >=0
            MOVGE   R2, R0                  ; then height=PointerHeight
            BGE     %FT10

            TST     R1, #1                  ; Y odd ?
            ADDNE   R4, R4, #&100           ; then use 2nd copy

            ADD     R2, R1, R0              ; height = PointerHeight+Y

            RSB     R1, R1, #0              ; Y := -Y
            BIC     R1, R1, #1              ; Y := (-Y AND NOT 1)
            ADD     R4, R4, R1, LSL #3      ; add on offset into shape
            MOV     R1, #0                  ; Y := 0
    10
            Push    "r1, r14"
     [ MEMC_Type = "IOMD"
            MOV     r0, #0
            LDR     r0, [r0, #DRAMPhysAddrA]
            LDR     r1, =DRAMOffset_CursorChunk + (CursorData - CursorChunkAddress)
            ADD     r0, r0, r1
     |
            LDR     r0, =PhysCursorStartAdr
     ]
            ADD     r0, r0, r4
            MOV     r1, #MEMCDAG_CInit
            BL      SetDAG
            Pull    "r1, r14"

     [ VIDC_Type <> "VIDC20"
            MOV     R1, R1, LSL #14         ; shift up
     ]
            LDR     R3, [WsPtr, #VertAdjust] ; get display start value
            ADD     R1, R1, R3              ; and add on

            ORR     R3, R1, #VertiCursorStart
            STR     R3, [R10]

     [ VIDC_Type = "VIDC20"
            ADD     R1, R1, R2              ; add height
     |
            ADD     R1, R1, R2, LSL #14     ; add height
     ]
            ORR     R3, R1, #VertiCursorEnd
            STR     R3, [R10]

            MOV     PC, R14
 ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.2;
access;
symbols
	Kernel-6_14:4.2
	Kernel-6_01-3:4.2
	Kernel-6_13:4.2
	Kernel-6_12:4.2
	Kernel-6_11:4.2
	Kernel-6_10:4.2
	Kernel-6_09:4.2
	Kernel-6_08-4_129_2_10:4.2
	Kernel-6_08-4_129_2_9:4.2
	Kernel-6_08:4.2
	Kernel-6_07:4.2
	Kernel-6_06:4.2
	Kernel-6_05-4_129_2_8:4.2
	Kernel-6_05:4.2
	Kernel-6_04:4.2
	Kernel-6_03:4.2
	Kernel-6_01-2:4.2
	Kernel-6_01-4_146_2_1:4.2
	Kernel-6_02:4.2
	Kernel-6_01-1:4.2
	Kernel-6_01:4.2
	Kernel-6_00:4.2
	Kernel-5_99:4.2
	Kernel-5_98:4.2
	Kernel-5_97-4_129_2_7:4.2
	Kernel-5_97:4.2
	Kernel-5_96:4.2
	Kernel-5_95:4.2
	Kernel-5_94:4.2
	Kernel-5_93:4.2
	Kernel-5_92:4.2
	Kernel-5_91:4.2
	Kernel-5_90:4.2
	Kernel-5_89-4_129_2_6:4.2
	Kernel-5_89:4.2
	Kernel-5_88-4_129_2_5:4.2
	Kernel-5_88-4_129_2_4:4.2
	Kernel-5_88:4.2
	Kernel-5_87:4.2
	Kernel-5_86-4_129_2_3:4.2
	Kernel-5_86-4_129_2_2:4.2
	Kernel-5_86-4_129_2_1:4.2
	Kernel-5_86:4.2
	SMP:4.2.0.2
	SMP_bp:4.2
	Kernel-5_85:4.2
	Kernel-5_54-1:4.2
	Kernel-5_84:4.2
	Kernel-5_83:4.2
	Kernel-5_82:4.2
	Kernel-5_81:4.2
	Kernel-5_80:4.2
	Kernel-5_79:4.2
	Kernel-5_78:4.2
	Kernel-5_77:4.2
	Kernel-5_76:4.2
	Kernel-5_75:4.2
	Kernel-5_74:4.2
	Kernel-5_73:4.2
	Kernel-5_72:4.2
	Kernel-5_71:4.2
	Kernel-5_70:4.2
	Kernel-5_69:4.2
	Kernel-5_68:4.2
	Kernel-5_67:4.2
	Kernel-5_66:4.2
	Kernel-5_65:4.2
	Kernel-5_64:4.2
	Kernel-5_63:4.2
	Kernel-5_62:4.2
	Kernel-5_61:4.2
	Kernel-5_60:4.2
	Kernel-5_59:4.2
	Kernel-5_58:4.2
	Kernel-5_57:4.2
	Kernel-5_56:4.2
	Kernel-5_55:4.2
	Kernel-5_54:4.2
	Kernel-5_53:4.2
	Kernel-5_52:4.2
	Kernel-5_51:4.2
	Kernel-5_50:4.2
	Kernel-5_49:4.2
	HAL_merge:4.1.8.2
	Kernel-5_48:4.2
	Kernel-5_35-4_79_2_327:4.1.8.2
	Kernel-5_35-4_79_2_326:4.1.8.2
	Kernel-5_35-4_79_2_325:4.1.8.2
	Kernel-5_35-4_79_2_324:4.1.8.2
	Kernel-5_35-4_79_2_323:4.1.8.2
	Kernel-5_35-4_79_2_322:4.1.8.2
	Kernel-5_35-4_79_2_321:4.1.8.2
	Kernel-5_35-4_79_2_320:4.1.8.2
	Kernel-5_35-4_79_2_319:4.1.8.2
	Kernel-5_35-4_79_2_318:4.1.8.2
	Kernel-5_35-4_79_2_317:4.1.8.2
	Kernel-5_35-4_79_2_316:4.1.8.2
	Kernel-5_35-4_79_2_315:4.1.8.2
	Kernel-5_35-4_79_2_314:4.1.8.2
	Kernel-5_35-4_79_2_313:4.1.8.2
	Kernel-5_35-4_79_2_312:4.1.8.2
	Kernel-5_35-4_79_2_311:4.1.8.2
	Kernel-5_35-4_79_2_310:4.1.8.2
	Kernel-5_35-4_79_2_309:4.1.8.2
	Kernel-5_35-4_79_2_308:4.1.8.2
	Kernel-5_35-4_79_2_307:4.1.8.2
	Kernel-5_35-4_79_2_306:4.1.8.2
	Kernel-5_35-4_79_2_305:4.1.8.2
	Kernel-5_35-4_79_2_304:4.1.8.2
	Kernel-5_35-4_79_2_303:4.1.8.2
	Kernel-5_35-4_79_2_302:4.1.8.2
	Kernel-5_35-4_79_2_301:4.1.8.2
	Kernel-5_35-4_79_2_300:4.1.8.2
	Kernel-5_35-4_79_2_299:4.1.8.2
	Kernel-5_35-4_79_2_298:4.1.8.2
	Kernel-5_35-4_79_2_297:4.1.8.2
	Kernel-5_35-4_79_2_296:4.1.8.2
	Kernel-5_35-4_79_2_295:4.1.8.2
	Kernel-5_35-4_79_2_294:4.1.8.2
	Kernel-5_35-4_79_2_293:4.1.8.2
	Kernel-5_35-4_79_2_292:4.1.8.2
	Kernel-5_35-4_79_2_291:4.1.8.2
	Kernel-5_35-4_79_2_290:4.1.8.2
	Kernel-5_35-4_79_2_289:4.1.8.2
	Kernel-5_35-4_79_2_288:4.1.8.2
	Kernel-5_35-4_79_2_287:4.1.8.2
	Kernel-5_35-4_79_2_286:4.1.8.2
	Kernel-5_35-4_79_2_285:4.1.8.2
	Kernel-5_35-4_79_2_284:4.1.8.2
	Kernel-5_35-4_79_2_283:4.1.8.2
	Kernel-5_35-4_79_2_282:4.1.8.2
	Kernel-5_35-4_79_2_281:4.1.8.2
	Kernel-5_35-4_79_2_280:4.1.8.2
	Kernel-5_35-4_79_2_279:4.1.8.2
	Kernel-5_35-4_79_2_278:4.1.8.2
	Kernel-5_35-4_79_2_277:4.1.8.2
	Kernel-5_35-4_79_2_276:4.1.8.2
	Kernel-5_35-4_79_2_275:4.1.8.2
	Kernel-5_35-4_79_2_274:4.1.8.2
	Kernel-5_35-4_79_2_273:4.1.8.2
	Kernel-5_35-4_79_2_272:4.1.8.2
	Kernel-5_35-4_79_2_271:4.1.8.2
	Kernel-5_35-4_79_2_270:4.1.8.2
	Kernel-5_35-4_79_2_269:4.1.8.2
	Kernel-5_35-4_79_2_268:4.1.8.2
	Kernel-5_35-4_79_2_267:4.1.8.2
	Kernel-5_35-4_79_2_266:4.1.8.2
	Kernel-5_35-4_79_2_265:4.1.8.2
	Kernel-5_35-4_79_2_264:4.1.8.2
	Kernel-5_35-4_79_2_263:4.1.8.2
	Kernel-5_35-4_79_2_262:4.1.8.2
	Kernel-5_35-4_79_2_261:4.1.8.2
	Kernel-5_35-4_79_2_260:4.1.8.2
	Kernel-5_35-4_79_2_259:4.1.8.2
	Kernel-5_35-4_79_2_258:4.1.8.2
	Kernel-5_35-4_79_2_257:4.1.8.2
	Kernel-5_35-4_79_2_256:4.1.8.2
	Kernel-5_35-4_79_2_255:4.1.8.2
	Kernel-5_35-4_79_2_254:4.1.8.2
	Kernel-5_35-4_79_2_253:4.1.8.2
	Kernel-5_35-4_79_2_252:4.1.8.2
	Kernel-5_35-4_79_2_251:4.1.8.2
	Kernel-5_35-4_79_2_250:4.1.8.2
	Kernel-5_35-4_79_2_249:4.1.8.2
	Kernel-5_35-4_79_2_248:4.1.8.2
	Kernel-5_35-4_79_2_247:4.1.8.2
	Kernel-5_35-4_79_2_246:4.1.8.2
	Kernel-5_35-4_79_2_245:4.1.8.2
	Kernel-5_35-4_79_2_244:4.1.8.2
	Kernel-5_35-4_79_2_243:4.1.8.2
	Kernel-5_35-4_79_2_242:4.1.8.2
	Kernel-5_35-4_79_2_241:4.1.8.2
	Kernel-5_35-4_79_2_240:4.1.8.2
	Kernel-5_35-4_79_2_239:4.1.8.2
	Kernel-5_35-4_79_2_238:4.1.8.2
	Kernel-5_35-4_79_2_237:4.1.8.2
	Kernel-5_35-4_79_2_236:4.1.8.2
	Kernel-5_35-4_79_2_235:4.1.8.2
	Kernel-5_35-4_79_2_234:4.1.8.2
	Kernel-5_35-4_79_2_233:4.1.8.2
	Kernel-5_35-4_79_2_232:4.1.8.2
	Kernel-5_35-4_79_2_231:4.1.8.2
	Kernel-5_35-4_79_2_230:4.1.8.2
	Kernel-5_35-4_79_2_229:4.1.8.2
	Kernel-5_35-4_79_2_228:4.1.8.2
	Kernel-5_35-4_79_2_227:4.1.8.2
	Kernel-5_35-4_79_2_226:4.1.8.2
	Kernel-5_35-4_79_2_225:4.1.8.2
	Kernel-5_35-4_79_2_224:4.1.8.2
	Kernel-5_35-4_79_2_223:4.1.8.2
	Kernel-5_35-4_79_2_222:4.1.8.2
	Kernel-5_35-4_79_2_221:4.1.8.2
	Kernel-5_35-4_79_2_220:4.1.8.2
	Kernel-5_35-4_79_2_219:4.1.8.2
	Kernel-5_35-4_79_2_218:4.1.8.2
	Kernel-5_35-4_79_2_217:4.1.8.2
	Kernel-5_35-4_79_2_216:4.1.8.2
	Kernel-5_35-4_79_2_215:4.1.8.2
	Kernel-5_35-4_79_2_214:4.1.8.2
	Kernel-5_35-4_79_2_213:4.1.8.2
	Kernel-5_35-4_79_2_212:4.1.8.2
	Kernel-5_35-4_79_2_211:4.1.8.2
	Kernel-5_35-4_79_2_210:4.1.8.2
	Kernel-5_35-4_79_2_209:4.1.8.2
	Kernel-5_35-4_79_2_208:4.1.8.2
	Kernel-5_35-4_79_2_207:4.1.8.2
	Kernel-5_35-4_79_2_206:4.1.8.2
	Kernel-5_35-4_79_2_205:4.1.8.2
	Kernel-5_35-4_79_2_204:4.1.8.2
	Kernel-5_35-4_79_2_203:4.1.8.2
	Kernel-5_35-4_79_2_202:4.1.8.2
	Kernel-5_35-4_79_2_201:4.1.8.2
	Kernel-5_35-4_79_2_200:4.1.8.2
	Kernel-5_35-4_79_2_199:4.1.8.2
	Kernel-5_35-4_79_2_198:4.1.8.2
	Kernel-5_35-4_79_2_197:4.1.8.2
	Kernel-5_35-4_79_2_196:4.1.8.2
	Kernel-5_35-4_79_2_195:4.1.8.2
	Kernel-5_35-4_79_2_194:4.1.8.2
	Kernel-5_35-4_79_2_193:4.1.8.2
	Kernel-5_35-4_79_2_192:4.1.8.2
	Kernel-5_35-4_79_2_191:4.1.8.2
	Kernel-5_35-4_79_2_190:4.1.8.2
	Kernel-5_35-4_79_2_189:4.1.8.2
	Kernel-5_35-4_79_2_188:4.1.8.2
	Kernel-5_35-4_79_2_187:4.1.8.2
	Kernel-5_35-4_79_2_186:4.1.8.2
	Kernel-5_35-4_79_2_185:4.1.8.2
	Kernel-5_35-4_79_2_184:4.1.8.2
	Kernel-5_35-4_79_2_183:4.1.8.2
	Kernel-5_35-4_79_2_182:4.1.8.2
	Kernel-5_35-4_79_2_181:4.1.8.2
	Kernel-5_35-4_79_2_180:4.1.8.2
	Kernel-5_35-4_79_2_179:4.1.8.2
	Kernel-5_35-4_79_2_178:4.1.8.2
	Kernel-5_35-4_79_2_177:4.1.8.2
	Kernel-5_35-4_79_2_176:4.1.8.2
	Kernel-5_35-4_79_2_175:4.1.8.2
	Kernel-5_35-4_79_2_174:4.1.8.2
	Kernel-5_35-4_79_2_173:4.1.8.2
	Kernel-5_35-4_79_2_172:4.1.8.2
	Kernel-5_35-4_79_2_171:4.1.8.2
	Kernel-5_35-4_79_2_170:4.1.8.2
	Kernel-5_35-4_79_2_169:4.1.8.2
	Kernel-5_35-4_79_2_168:4.1.8.2
	Kernel-5_35-4_79_2_167:4.1.8.2
	Kernel-5_35-4_79_2_166:4.1.8.2
	Kernel-5_35-4_79_2_165:4.1.8.2
	RPi_merge:4.1.8.2
	Kernel-5_35-4_79_2_147_2_23:4.1.8.2
	Kernel-5_35-4_79_2_147_2_22:4.1.8.2
	Kernel-5_35-4_79_2_147_2_21:4.1.8.2
	Kernel-5_35-4_79_2_147_2_20:4.1.8.2
	Kernel-5_35-4_79_2_147_2_19:4.1.8.2
	Kernel-5_35-4_79_2_147_2_18:4.1.8.2
	Kernel-5_35-4_79_2_164:4.1.8.2
	Kernel-5_35-4_79_2_163:4.1.8.2
	Kernel-5_35-4_79_2_147_2_17:4.1.8.2
	Kernel-5_35-4_79_2_147_2_16:4.1.8.2
	Kernel-5_35-4_79_2_147_2_15:4.1.8.2
	Kernel-5_35-4_79_2_162:4.1.8.2
	Kernel-5_35-4_79_2_161:4.1.8.2
	Kernel-5_35-4_79_2_147_2_14:4.1.8.2
	Kernel-5_35-4_79_2_147_2_13:4.1.8.2
	Kernel-5_35-4_79_2_160:4.1.8.2
	Kernel-5_35-4_79_2_159:4.1.8.2
	Kernel-5_35-4_79_2_158:4.1.8.2
	Kernel-5_35-4_79_2_157:4.1.8.2
	Kernel-5_35-4_79_2_156:4.1.8.2
	Kernel-5_35-4_79_2_147_2_12:4.1.8.2
	Kernel-5_35-4_79_2_147_2_11:4.1.8.2
	Kernel-5_35-4_79_2_155:4.1.8.2
	Kernel-5_35-4_79_2_147_2_10:4.1.8.2
	Kernel-5_35-4_79_2_154:4.1.8.2
	Kernel-5_35-4_79_2_153:4.1.8.2
	Kernel-5_35-4_79_2_147_2_9:4.1.8.2
	Kernel-5_35-4_79_2_152:4.1.8.2
	Kernel-5_35-4_79_2_151:4.1.8.2
	Kernel-5_35-4_79_2_147_2_8:4.1.8.2
	Kernel-5_35-4_79_2_147_2_7:4.1.8.2
	Kernel-5_35-4_79_2_150:4.1.8.2
	Kernel-5_35-4_79_2_147_2_6:4.1.8.2
	Kernel-5_35-4_79_2_147_2_5:4.1.8.2
	Kernel-5_35-4_79_2_149:4.1.8.2
	Kernel-5_35-4_79_2_147_2_4:4.1.8.2
	Kernel-5_35-4_79_2_147_2_3:4.1.8.2
	Kernel-5_35-4_79_2_148:4.1.8.2
	Kernel-5_35-4_79_2_147_2_2:4.1.8.2
	Kernel-5_35-4_79_2_147_2_1:4.1.8.2
	RPi:4.1.8.2.0.6
	RPi_bp:4.1.8.2
	Kernel-5_35-4_79_2_98_2_52_2_1:4.1.8.2
	alees_Kernel_dev:4.1.8.2.0.4
	alees_Kernel_dev_bp:4.1.8.2
	Kernel-5_35-4_79_2_147:4.1.8.2
	Kernel-5_35-4_79_2_146:4.1.8.2
	Kernel-5_35-4_79_2_145:4.1.8.2
	Kernel-5_35-4_79_2_144:4.1.8.2
	Kernel-5_35-4_79_2_143:4.1.8.2
	Kernel-5_35-4_79_2_142:4.1.8.2
	Kernel-5_35-4_79_2_141:4.1.8.2
	Kernel-5_35-4_79_2_140:4.1.8.2
	Kernel-5_35-4_79_2_139:4.1.8.2
	Kernel-5_35-4_79_2_138:4.1.8.2
	Kernel-5_35-4_79_2_137:4.1.8.2
	Kernel-5_35-4_79_2_136:4.1.8.2
	Kernel-5_35-4_79_2_135:4.1.8.2
	Kernel-5_35-4_79_2_134:4.1.8.2
	Kernel-5_35-4_79_2_133:4.1.8.2
	Kernel-5_35-4_79_2_132:4.1.8.2
	Kernel-5_35-4_79_2_131:4.1.8.2
	Kernel-5_35-4_79_2_130:4.1.8.2
	Kernel-5_35-4_79_2_129:4.1.8.2
	Kernel-5_35-4_79_2_128:4.1.8.2
	Kernel-5_35-4_79_2_127:4.1.8.2
	Kernel-5_35-4_79_2_126:4.1.8.2
	Kernel-5_35-4_79_2_125:4.1.8.2
	Kernel-5_35-4_79_2_124:4.1.8.2
	Kernel-5_35-4_79_2_123:4.1.8.2
	Cortex_merge:4.1.8.2
	Kernel-5_35-4_79_2_122:4.1.8.2
	Kernel-5_35-4_79_2_98_2_54:4.1.8.2
	Kernel-5_35-4_79_2_98_2_53:4.1.8.2
	Kernel-5_35-4_79_2_98_2_52:4.1.8.2
	Kernel-5_35-4_79_2_98_2_51:4.1.8.2
	Kernel-5_35-4_79_2_98_2_50:4.1.8.2
	Kernel-5_35-4_79_2_98_2_49:4.1.8.2
	Kernel-5_35-4_79_2_98_2_48:4.1.8.2
	Kernel-5_35-4_79_2_121:4.1.8.2
	Kernel-5_35-4_79_2_98_2_47:4.1.8.2
	Kernel-5_35-4_79_2_120:4.1.8.2
	Kernel-5_35-4_79_2_98_2_46:4.1.8.2
	Kernel-5_35-4_79_2_119:4.1.8.2
	Kernel-5_35-4_79_2_98_2_45:4.1.8.2
	Kernel-5_35-4_79_2_98_2_44:4.1.8.2
	Kernel-5_35-4_79_2_118:4.1.8.2
	Kernel-5_35-4_79_2_98_2_43:4.1.8.2
	Kernel-5_35-4_79_2_117:4.1.8.2
	Kernel-5_35-4_79_2_116:4.1.8.2
	Kernel-5_35-4_79_2_98_2_42:4.1.8.2
	Kernel-5_35-4_79_2_115:4.1.8.2
	Kernel-5_35-4_79_2_98_2_41:4.1.8.2
	Kernel-5_35-4_79_2_98_2_40:4.1.8.2
	Kernel-5_35-4_79_2_114:4.1.8.2
	Kernel-5_35-4_79_2_98_2_39:4.1.8.2
	Kernel-5_35-4_79_2_98_2_38:4.1.8.2
	Kernel-5_35-4_79_2_113:4.1.8.2
	Kernel-5_35-4_79_2_112:4.1.8.2
	Kernel-5_35-4_79_2_98_2_37:4.1.8.2
	Kernel-5_35-4_79_2_98_2_36:4.1.8.2
	Kernel-5_35-4_79_2_98_2_35:4.1.8.2
	Kernel-5_35-4_79_2_98_2_34:4.1.8.2
	Kernel-5_35-4_79_2_98_2_33:4.1.8.2
	Kernel-5_35-4_79_2_98_2_32:4.1.8.2
	Kernel-5_35-4_79_2_98_2_31:4.1.8.2
	Kernel-5_35-4_79_2_98_2_30:4.1.8.2
	Kernel-5_35-4_79_2_98_2_29:4.1.8.2
	Kernel-5_35-4_79_2_98_2_28:4.1.8.2
	Kernel-5_35-4_79_2_98_2_27:4.1.8.2
	Kernel-5_35-4_79_2_98_2_26:4.1.8.2
	Kernel-5_35-4_79_2_111:4.1.8.2
	Kernel-5_35-4_79_2_98_2_25:4.1.8.2
	Kernel-5_35-4_79_2_98_2_24:4.1.8.2
	Kernel-5_35-4_79_2_98_2_23:4.1.8.2
	Kernel-5_35-4_79_2_110:4.1.8.2
	Kernel-5_35-4_79_2_98_2_22:4.1.8.2
	Kernel-5_35-4_79_2_109:4.1.8.2
	Kernel-5_35-4_79_2_98_2_21:4.1.8.2
	Kernel-5_35-4_79_2_98_2_20:4.1.8.2
	Kernel-5_35-4_79_2_108:4.1.8.2
	Kernel-5_35-4_79_2_107:4.1.8.2
	Kernel-5_35-4_79_2_98_2_19:4.1.8.2
	Kernel-5_35-4_79_2_98_2_18:4.1.8.2
	Kernel-5_35-4_79_2_98_2_17:4.1.8.2
	Kernel-5_35-4_79_2_98_2_16:4.1.8.2
	Kernel-5_35-4_79_2_98_2_15:4.1.8.2
	Kernel-5_35-4_79_2_106:4.1.8.2
	Kernel-5_35-4_79_2_105:4.1.8.2
	Kernel-5_35-4_79_2_104:4.1.8.2
	Kernel-5_35-4_79_2_98_2_14:4.1.8.2
	Kernel-5_35-4_79_2_98_2_13:4.1.8.2
	Kernel-5_35-4_79_2_98_2_12:4.1.8.2
	Kernel-5_35-4_79_2_98_2_11:4.1.8.2
	Kernel-5_35-4_79_2_98_2_10:4.1.8.2
	Kernel-5_35-4_79_2_98_2_9:4.1.8.2
	Kernel-5_35-4_79_2_103:4.1.8.2
	Kernel-5_35-4_79_2_102:4.1.8.2
	Kernel-5_35-4_79_2_98_2_8:4.1.8.2
	Kernel-5_35-4_79_2_98_2_7:4.1.8.2
	Kernel-5_35-4_79_2_98_2_6:4.1.8.2
	Kernel-5_35-4_79_2_98_2_5:4.1.8.2
	Kernel-5_35-4_79_2_98_2_4:4.1.8.2
	Kernel-5_35-4_79_2_101:4.1.8.2
	Kernel-5_35-4_79_2_100:4.1.8.2
	Kernel-5_35-4_79_2_99:4.1.8.2
	Kernel-5_35-4_79_2_98_2_3:4.1.8.2
	Kernel-5_35-4_79_2_98_2_2:4.1.8.2
	Kernel-5_35-4_79_2_98_2_1:4.1.8.2
	Cortex:4.1.8.2.0.2
	Cortex_bp:4.1.8.2
	Kernel-5_35-4_79_2_98:4.1.8.2
	Kernel-5_35-4_79_2_97:4.1.8.2
	Kernel-5_35-4_79_2_96:4.1.8.2
	Kernel-5_35-4_79_2_95:4.1.8.2
	Kernel-5_35-4_79_2_94:4.1.8.2
	Kernel-5_35-4_79_2_93:4.1.8.2
	Kernel-5_35-4_79_2_92:4.1.8.2
	Kernel-5_35-4_79_2_91:4.1.8.2
	Kernel-5_35-4_79_2_90:4.1.8.2
	Kernel-5_35-4_79_2_89:4.1.8.2
	Kernel-5_35-4_79_2_88:4.1.8.2
	Kernel-5_35-4_79_2_87:4.1.8.2
	Kernel-5_35-4_79_2_86:4.1.8.2
	Kernel-5_35-4_79_2_85:4.1.8.2
	Kernel-5_35-4_79_2_84:4.1.8.2
	Kernel-5_35-4_79_2_83:4.1.8.2
	Kernel-5_35-4_79_2_82:4.1.8.2
	Kernel-5_35-4_79_2_81:4.1.8.2
	Kernel-5_35-4_79_2_80:4.1.8.2
	Kernel-5_35-4_79_2_79:4.1.8.2
	Kernel-5_35-4_79_2_78:4.1.8.2
	Kernel-5_35-4_79_2_77:4.1.8.2
	RO_5_07:4.1.8.2
	Kernel-5_35-4_79_2_76:4.1.8.2
	Kernel-5_35-4_79_2_75:4.1.8.2
	Kernel-5_35-4_79_2_74:4.1.8.2
	Kernel-5_35-4_79_2_73:4.1.8.2
	Kernel-5_35-4_79_2_72:4.1.8.2
	Kernel-5_35-4_79_2_71:4.1.8.2
	Kernel-5_35-4_79_2_70:4.1.8.2
	Kernel-5_35-4_79_2_69:4.1.8.2
	Kernel-5_35-4_79_2_68:4.1.8.2
	Kernel-5_35-4_79_2_67:4.1.8.2
	Kernel-5_35-4_79_2_66:4.1.8.2
	Kernel-5_35-4_79_2_65:4.1.8.2
	Kernel-5_35-4_79_2_64:4.1.8.2
	Kernel-5_35-4_79_2_63:4.1.8.2
	Kernel-5_35-4_79_2_62:4.1.8.2
	Kernel-5_35-4_79_2_61:4.1.8.2
	Kernel-5_35-4_79_2_59:4.1.8.2
	Kernel-5_35-4_79_2_58:4.1.8.2
	Kernel-5_35-4_79_2_57:4.1.8.2
	Kernel-5_35-4_79_2_56:4.1.8.2
	Kernel-5_35-4_79_2_55:4.1.8.2
	Kernel-5_35-4_79_2_54:4.1.8.2
	Kernel-5_35-4_79_2_53:4.1.8.2
	Kernel-5_35-4_79_2_52:4.1.8.2
	Kernel-5_35-4_79_2_51:4.1.8.2
	Kernel-5_35-4_79_2_50:4.1.8.1
	Kernel-5_35-4_79_2_49:4.1.8.1
	Kernel-5_35-4_79_2_48:4.1.8.1
	Kernel-5_47:4.1
	Kernel-5_46-4_90_2_1:4.1
	nbingham_Kernel_FastNC_dev_bp:4.1
	nbingham_Kernel_FastNC_dev:4.1.0.14
	Kernel-5_46:4.1
	Kernel-5_45:4.1
	Kernel-5_35-4_79_2_47:4.1.8.1
	Kernel-5_35-4_79_2_46:4.1.8.1
	Kernel-5_35-4_79_2_45:4.1.8.1
	Kernel-5_35-4_79_2_44:4.1.8.1
	Kernel-5_35-4_79_2_25_2_2:4.1
	Kernel-5_35-4_79_2_43:4.1.8.1
	Kernel-5_35-4_79_2_42:4.1.8.1
	Kernel-5_35-4_79_2_41:4.1.8.1
	Kernel-5_35-4_79_2_40:4.1.8.1
	Kernel-5_35-4_79_2_39:4.1.8.1
	Kernel-5_35-4_79_2_38:4.1.8.1
	Kernel-5_35-4_79_2_37:4.1
	Kernel-5_35-4_79_2_36:4.1
	Kernel-5_35-4_79_2_35:4.1
	Kernel-5_35-4_79_2_34:4.1
	Kernel-5_35-4_79_2_33:4.1
	Kernel-5_35-4_79_2_32:4.1
	Kernel-5_44:4.1
	Kernel-5_35-4_79_2_25_2_1:4.1
	Kernel-5_43:4.1
	Kernel-5_35-4_79_2_31:4.1
	Kernel-5_35-4_79_2_30:4.1
	Kernel-5_35-4_79_2_29:4.1
	Kernel-5_35-4_79_2_28:4.1
	Kernel-5_35-4_79_2_27:4.1
	Kernel-5_35-4_79_2_26:4.1
	Kernel-5_42:4.1
	Kernel-5_41:4.1
	Kernel-5_40:4.1
	Kernel-5_35-4_79_2_25:4.1
	Kernel-5_35-4_79_2_24:4.1
	Kernel-5_35-4_79_2_23:4.1
	Kernel-5_35-4_79_2_22:4.1
	Kernel-5_35-4_79_2_21:4.1
	Kernel-5_35-4_79_2_20:4.1
	Kernel-5_35-4_79_2_19:4.1
	Kernel-5_35-4_79_2_18:4.1
	Kernel-5_35-4_79_2_17:4.1
	Kernel-5_35-4_79_2_16:4.1
	Kernel-5_35-4_79_2_15:4.1
	Kernel-5_35-4_79_2_14:4.1
	Kernel-5_39:4.1
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.10
	Kernel-5_38:4.1
	Kernel-5_35-4_79_2_13:4.1
	Kernel-5_35-4_79_2_12:4.1
	Kernel-5_35-4_79_2_11:4.1
	Kernel-5_37:4.1
	Kernel-5_35-4_79_2_10:4.1
	Kernel-5_35-4_79_2_9:4.1
	Kernel-5_36:4.1
	Kernel-5_35-4_79_2_8:4.1
	Kernel-5_35-4_79_2_7:4.1
	Kernel-5_35-4_79_2_6:4.1
	Kernel-5_35-4_79_2_5:4.1
	Kernel-5_35-4_79_2_4:4.1
	Kernel-5_35-4_79_2_3:4.1
	Kernel-5_35-4_79_2_2:4.1
	dellis_autobuild_BaseSW:4.1
	Kernel-5_35-4_79_2_1:4.1
	HAL:4.1.0.8
	Kernel-5_35:4.1
	Kernel-5_34:4.1
	Kernel-5_33:4.1
	Kernel-5_32:4.1
	Kernel-5_31:4.1
	Kernel-5_30:4.1
	Kernel-5_29:4.1
	Kernel-5_28:4.1
	Kernel-5_27:4.1
	Kernel-5_26:4.1
	Kernel-5_25:4.1
	Kernel-5_24:4.1
	Kernel-5_23:4.1
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.1
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1.2.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1.2.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1.2.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.2
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.1;
commitid	IWoXxARWeuLDOwcz;

4.1
date	96.11.05.09.41.33;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1
	4.1.8.1;
next	;

4.1.1.1
date	96.11.05.09.41.33;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.02.26;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.27;	author mstphens;	state Exp;
branches
	4.1.4.1.2.1;
next	4.1.4.2;

4.1.4.2
date	98.09.24.13.17.42;	author mstphens;	state Exp;
branches;
next	;

4.1.4.1.2.1
date	98.11.23.14.59.39;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.42;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.25;	author nturton;	state Exp;
branches;
next	;

4.1.8.1
date	2001.06.18.14.49.47;	author mstephen;	state Exp;
branches;
next	4.1.8.2;

4.1.8.2
date	2002.11.30.00.31.12;	author bavison;	state Exp;
branches;
next	;


desc
@@


4.2
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.Vdu5

; *****************************************************************************
;
;       Print a character in VDU 5 mode
;

; *****This file has been extensively modified by DJS

; Alter these at your peril !

cxl     RN      0
scr     RN      0

ecfptr  RN      1
cword0  RN      1

cyb     RN      2
cyt2    RN      2
scrend  RN      2
cword1  RN      2

cxr     RN      3
cyb2    RN      3
ormask  RN      3

cxl2    RN      4
eormask RN      4

cyb3    RN      5
charmsk RN      5
cword2  RN      5

cyt     RN      6
llength RN      6
chartmp RN      6

sizex   RN      7
charptr RN      7

sizey   RN      8
invcharshf RN   8

charbyte RN     9

cxr2    RN      10
charshf RN      10

lgBPC   RN      11

Vdu5Wrch
        Push    R14
        BL      Vdu5DoChar
        Pull    R14
        B       PostCharMove

; Vdu23_18
;        LDR     R0, [WsPtr, #QQ+1]
Vdu5DoChar
        ADD     ecfptr, WsPtr, #FgEcfOraEor  ;Base address of OR/EOR pairs
Vdu5DoChar10
        Push    "R14"
        MOV     charbyte, R0                    ;Put character out of harm's
                                                ;  way
        ASSERT  cxl < cyt
        ASSERT  GCsIY = GCsIX +4
        ADD     cxl, WsPtr, #GCsIX
        LDMIA   cxl, {cxl, cyt}                 ; cxl=where left pixel would be
                                                ; cyt=where top pixel would be

        ASSERT  sizex < sizey
        ADD     sizex, WsPtr, #GCharSizes
        LDMIA   sizex, {sizex, sizey}
        CMP     sizey, #16                      ; if SizeY=8 or SizeY=16
        TEQNE   sizey, #8                       ;   (leaving CS <=> SizeY=16)
        TEQEQ   sizex, #8                       ; and SizeX=8, then do it fast
        BNE     SlowVdu5                        ; else do by scaled char

        TEQ     charbyte, #127                  ; Which font do we use?
        ADDNE   charptr, WsPtr, #(Font-32*8)    ; Soft if character not DELETE
        ADREQL  charptr, HardFont-32*8          ; Hard if character is DELETE
        ADD     charptr, charptr, charbyte, LSL #3      ;Point at char def

        MOVCS   charptr, charptr, ASL #1        ; Double address if SizeY = 16
        SUBCS   charptr, charptr, #1            ;   (tricky code, originally
                                                ;   designed by TMD)

        SUB     cyb, cyt, sizey
        ADD     cyb, cyb, #1                    ; where bottom pixel would be
        ADD     cxr, cxl, #7                    ; where right pixel would be

        ASSERT  GWBRow = GWLCol+4
        ASSERT  GWRCol = GWLCol+8
        ASSERT  GWTRow = GWLCol+12
        ASSERT  cyb3 > cxl2
        ASSERT  cxr2 > cyb3
        ASSERT  R14 > cxr2
        ADD     cxl2, WsPtr, #GWLCol
        LDMIA   cxl2, {cxl2, cyb3, cxr2, R14}

        Greatest cxl2, cxl2, cxl                ; cxl2 := windowed left
                                                ;   (2 instructions)
        Least   cxr2, cxr2, cxr                 ; cxr2 := windowed right
                                                ;   (2 instructions)
        Greatest cyb2, cyb3, cyb                ; cyb2 := windowed bottom
                                                ;   (3 instructions)
        Least   cyt2, R14, cyt                  ; cyt2 := windowed top
                                                ;   (3 instructions)

        SUBS    cyb2, cyt2, cyb2                ; top >= bottom ?
        CMPGE   cxr2, cxl2                      ; and right >= left ?
        Pull    "PC", LT                        ; Exit if not. Otherwise cyb2
                                                ;   has become clipped height

        LDR     R14, [WsPtr, #CursorFlags]      ; update changed box, if wanted
        TST     R14, #ClipBoxEnableBit
        BLNE    ClipVdu5

        ADD     charptr, charptr, cyt           ; adjust charptr to point at
        SUB     charptr, charptr, cyt2          ;   first used row of character

        MOV     charmsk, #&FF                   ; Produce mask to do left/right
        SUB     R14, cxl2, cxl                  ;   clipping
        MOV     charmsk, charmsk, LSR R14
        SUB     R14, cxr2, cxl2
        ADD     R14, R14, #1
        BIC     charmsk, charmsk, charmsk, LSR R14

        TEQ     sizey, #16                      ; If double height, signal this
        ORREQ   charmsk, charmsk, #1:SHL:31     ;   by making charmsk negative

        ASSERT  llength > scr
        ASSERT  LineLength = YWindLimit+4
        LDR     lgBPC, [WsPtr, #Log2BPC]        ; Address point at (cxl, cyt2),
        MOV     charshf, cxl, LSL lgBPC         ;   putting address in scr, bit
        ADD     scr, WsPtr, #YWindLimit         ;   offset in charshf and
        LDMIA   scr, {scr, llength}             ;   adjusting ecfptr
        SUB     scr, scr, cyt2
        AND     R14, scr, #7
        ADD     ecfptr, ecfptr, R14, LSL #3
        LDR     R14, [WsPtr, #ScreenStart]
        MLA     scr, llength, scr, R14
        MOV     R14, charshf, ASR #5
        ADD     scr, scr, R14, LSL #2
        AND     charshf, charshf, #31

        MLA     scrend, llength, cyb2, scr      ;Calculate terminating address

        RSB     invcharshf, charshf, #32        ;And inverse shift

Vdu5NextLine
        ASSERT  eormask > ormask
        LDMIA   ecfptr!, {ormask, eormask}      ;Pick up ecf info and advance
        TST     ecfptr, #63                     ;  ecf pointer, wrapping if
        SUBEQ   ecfptr, ecfptr, #64             ;  necessary

        ASSERT  HardFont < &40000000 :LOR: HardFont >= &C0000000
        ASSERT  WsPtr < &40000000 :LOR: WsPtr >= &C0000000
        TEQ     charmsk, #0                     ; Double height? (MI=yes)
        LDRMIB  charbyte, [charptr, -charptr, ASR #1] ; Use ASR, as font will be at
        LDRPLB  charbyte, [charptr]             ; top or bottom of memory (zero page,
        ADD     charptr, charptr, #1            ; system heap or ROM)

        ANDS    charbyte, charbyte, charmsk     ;Clip left & right; skip loop
        BEQ     Vdu5TryNextLine                 ;  body if nothing to plot

        Push    "ecfptr,scrend,charmsk,llength,charptr"

        LDR     R14, [WsPtr, #TextExpandArea]   ;Address correct expansion

        ADD     charptr, charbyte, #&100        ;  table entry, assuming that
        ADD     charptr, R14, charptr, LSL lgBPC        ;  this is not mode 10 or greater

        CMP     lgBPC, #1                       ;Pick up this entry:
        LDRLSB  cword0, [charptr, #0]           ;  1 byte if lgBPC = 0
        LDREQB  R14, [charptr, #1]              ;  2 bytes if lgBPC = 1
        ORREQ   cword0, cword0, R14, LSL #8
        MOV     cword1, #0
        BLS     Vdu5DoOneWord
        CMP     lgBPC, #3
        LDRLO   cword0, [charptr, #0]           ;  1 word if lgBPC = 2
        BLO     Vdu5DoOneWord
        BHI     Vdu5Mode10                      ;  4 words if lgBPC = 4
        LDMIA   charptr, {cword0, cword1}       ;  2 words if lgBPC = 3
        MOVS    cword2, cword1, LSR invcharshf

        MACRO
$l      DoVdu5Word $c, $reg, $off
$l
        LDR$c   chartmp, [scr, #$off]
        AND$c   R14, ormask, $reg
        ORR$c   chartmp, chartmp, R14
        AND$c   R14, eormask, $reg
        EOR$c   chartmp, chartmp, R14
        STR$c   chartmp, [scr, #$off]
        MEND

Vdu5DoTwoWords
        DoVdu5Word NE, cword2, 8
        MOV     cword1, cword1, LSL charshf
Vdu5DoOneWord
        ORRS    cword1, cword1, cword0, LSR invcharshf
        DoVdu5Word NE, cword1, 4
        MOVS    cword0, cword0, LSL charshf
        DoVdu5Word NE, cword0, 0

Vdu5LinePainted
        Pull    "ecfptr,scrend,charmsk,llength,charptr"

Vdu5TryNextLine
        TEQ     scr, scrend
        ADDNE   scr, scr, llength
        BNE     Vdu5NextLine

        Pull    "PC"

; This is mode 10 (or similar) - we must do bit expansion on the fly

Vdu5Mode10
        CMP     lgBPC, #5                       ; is this a 32 bit per pixel mode, if so then ignore the
        BEQ     Vdu5Mode32                      ; existing code and use a newer function

        ADRL    charptr, C16BTab
        AND     R14, charbyte, #&0F
        ADD     R14, charptr, R14, LSL #3
        LDMIA   R14, {cword0, cword1}

        MOVS    cword2, cword1, LSR invcharshf
        DoVdu5Word NE, cword2, 16
        MOV     cword1, cword1, LSL charshf
        ORRS    cword1, cword1, cword0, LSR invcharshf
        DoVdu5Word NE, cword1, 12
        MOVS    cword2, cword0, LSL charshf

        AND     R14, charbyte, #&F0
        ADD     R14, charptr, R14, LSR #1
        LDMIA   R14, {cword0, cword1}
        ORRS    cword2, cword2, cword1, LSR invcharshf
        B       Vdu5DoTwoWords

; Expand the character data out to 32 bit per pixel (mode 48 or similar)

        MACRO
$l      PixMunge32 $reg, $mask, $offset
$l
        TST     $reg, #$mask
        LDRNE   chartmp, [scr, #$offset]
        ORRNE   chartmp, chartmp, ormask
        EORNE   chartmp, chartmp, eormask
        STRNE   chartmp, [scr, #$offset]
        MEND

        MACRO
$l      PixSolid32 $reg, $mask, $offset
$l
        TST     $reg, #$mask
        STRNE   chartmp, [scr, #$offset]
        MEND

; Perform bit expansion on the fly, this is a word based operation, no need to
; extract sub-pixels from the ORR / EOR masks, simply perform the bit test and
; then write the character data to the screen!

Vdu5Mode32

 [ AvoidScreenReads
        CMP     ormask, #&FFFFFFFF
        BNE     Vdu5Mode32_NotSolid

        MVN     chartmp, eormask
        PixSolid32 charbyte, 1<<7, 0
        PixSolid32 charbyte, 1<<6, 4
        PixSolid32 charbyte, 1<<5, 8
        PixSolid32 charbyte, 1<<4, 12
        PixSolid32 charbyte, 1<<3, 16
        PixSolid32 charbyte, 1<<2, 20
        PixSolid32 charbyte, 1<<1, 24
        PixSolid32 charbyte, 1<<0, 28

        B       Vdu5LinePainted

Vdu5Mode32_NotSolid
 ]
        PixMunge32 charbyte, 1<<7, 0
        PixMunge32 charbyte, 1<<6, 4
        PixMunge32 charbyte, 1<<5, 8
        PixMunge32 charbyte, 1<<4, 12
        PixMunge32 charbyte, 1<<3, 16
        PixMunge32 charbyte, 1<<2, 20
        PixMunge32 charbyte, 1<<1, 24
        PixMunge32 charbyte, 1<<0, 28

        B       Vdu5LinePainted                 ; flow down and try the next line


; *****************************************************************************
;
;       Slow VDU 5 - Print char by scaled method (in SprExtend)
;
; in:   R1 (ecfptr)   = pointer to ecf pattern
;       R7 (sizex)    = SizeX
;       R8 (sizey)    = SizeY
;       R9 (charbyte) = character to plot
;
;       Stack:  Return address
;

        ASSERT  ecfptr   = R1
        ASSERT  sizex    = R7
        ASSERT  sizey    = R8
        ASSERT  charbyte = R9

SlowVdu5 ROUT

        MOV     R10, R1                         ; R10 := ecfptr

; now save current GCOL on stack if necessary

        ADD     R11, WsPtr, #FgEcfOraEor
        TEQ     R10, R11                        ; if going to use this one
        BEQ     %FT20                           ; then skip

        MOV     R0, #64                         ; 64 bytes
10
        LDMIA   R11, {R3-R6}                    ; copy old GCOL into stack
        Push    "R3-R6"                         ;   frame, reversing order of
                                                ;   16 byte chunks
        LDMIA   R10!, {R3-R6}                   ; copy new colour
        STMIA   R11!, {R3-R6}                   ; into GCOL
        SUBS    R0, R0, #16
        BNE     %BT10

20
        MOV     R4, #8
        MOV     R5, #8
        Push    "R4,R5"
        Push    "R7,R8"
        MOV     R6, R13                         ; R6 -> scaling block

        SUB     R1, R8, #1                      ; SizeY-1
        LDR     R5, [WsPtr, #YEigFactor]
        ADD     R3, WsPtr, #GCsX
        LDMIA   R3, {R3, R4}                    ; R3 = ext X; R4 = ext Y (top)
        SUB     R4, R4, R1, LSL R5              ; R4 = ext Y (bottom)
        MOV     R1, R9                          ; R1 = char
        MOV     R0, #SpriteReason_PaintCharScaled
        SWI     XOS_SpriteOp

        ADD     R13, R13, #4*4                  ; junk scaling block

        TEQ     R10, R11                        ; if we didn't copy GCOLs
        Pull    "PC", EQ                        ; then return, else copy back

        MOV     R0, #64
30
        Pull    "R3-R6"                         ; Reverse order of 16 byte
        STMDB   R11!, {R3-R6}                   ; chunks during copy again
        SUBS    R0, R0, #16
        BNE     %BT30
        Pull    PC


; *****************************************************************************
;
;       VDU 5 - Start printing text at graphics cursor

ENQ
        GraphicsMode R0
        MOVNE   PC, R14

        MOV     R1, #0
        BSR     CursorOnOff                     ; turn cursor off without
                                                ; saving to copy

        LDR     R6, [WsPtr, #CursorFlags]
        ORR     R6, R6, #Vdu5Bit
        B       R6toCursorFlags

; *****************************************************************************
;
;       VDU 4 - Return to printing text at text cursor

EOT
        GraphicsMode R0
        MOVNE   PC,LR

        MOV     R1, #1
        BSR     CursorOnOff                     ; restore cursor from copy

        LDR     R6, [WsPtr, #CursorFlags]
        BIC     R6, R6, #Vdu5Bit
        B       R6toCursorFlags

; *****************************************************************************
;
;       Vdu5HT - Move cursor "right" when in VDU 5 mode
;
; in:   R6 = CursorFlags

Vdu5HT
        Push    R14
        BL      GCursorMove             ; try to move in +ve X direction
        BCC     EndVdu5HT               ; if successful, finish
        BL      GCursorB0               ; else move cursor to -ve X boundary
Vdu5HT10
        EOR     R6, R6, #8              ; change to +ve Y direction
        BL      GCursorMove             ; try to move in that direction
        BLCS    GCursorB0               ; if unsuccessful, move to -ve Y bdy
EndVdu5HT
        Pull    R14
        B       IEG

; *****************************************************************************
;
;       Vdu5BS - Move cursor "left" when in VDU 5 mode
;
; in:   R6 = CursorFlags

Vdu5BS
        EOR     R6, R6, #6              ; go to -ve X direction
        B       Vdu5HT                  ; dead easy, huh ?

; *****************************************************************************
;
;       Vdu5LF - Move cursor "down" when in VDU 5 mode
;
; in:   R6 = CursorFlags

Vdu5LF
        Push    R14
        B       Vdu5HT10

; *****************************************************************************
;
;       Vdu5VT - Move cursor "up" when in VDU 5 mode
;
; in:   R6 = CursorFlags

Vdu5VT
        EOR     R6, R6, #6              ; go to -ve Y direction (eventually)
        B       Vdu5LF

; *****************************************************************************
;
;       Vdu5CR - Carriage return in VDU 5 mode
;
; in:   R6 = CursorFlags

Vdu5CR
        BSR     GCursorB0
        B       IEG

; *****************************************************************************
;
;       Vdu5FF - Clear screen in VDU 5 mode
;
; in:   R6 = CursorFlags

Vdu5FF
        BSR     Home
        B       CLG

; *****************************************************************************
;
;       Vdu5TAB - TAB(X,Y) in VDU 5 mode
;
; in:   R0 = X, R1 = Y, R6 = CursorFlags

Vdu5TAB
        BSR     GCursorBdy
        EOR     R6, R6, #8
        MOV     R0, R1
        BSR     GCursorBdy
        B       IEG

; *****************************************************************************
;
;       Vdu5Delete - Delete in VDU 5 mode (already done backspace)
;
; in:   R6 = CursorFlags

Vdu5Delete
        ADD     ecfptr, WsPtr, #BgEcfStore ; STORE background colour/ecf
        MOV     R0, #127                   ; uses hard font for this char
        B       Vdu5DoChar10

; *****************************************************************************
;
;       GCursorMove - Move graphics cursor in direction specified by R6
;       (0,4 = right; 2,6 = left; 8,10 = down; 12,14 = up)
;       R6 is preserved

GCursorMove
        ADD     R0, WsPtr, #GCsIX
        LDMIA   R0, {R0, R1}                    ; R0 = GCsIX; R1 = GCsIY
        ADD     R2, WsPtr, #GCharSpacing+8      ; +8 needed to address it
        LDMDB   R2, {R2, R3}                    ; R2=GCharSpaceX;R3=GCharSpaceY
        WINDow  R0, R1, R8,R9,R10,R11           ; return LT if outside window
        ADR     R7, GCMVTab
        B       DoJumpTable

GCMVTab
        &       GMoveRight-GCMVTab
        &       GMoveLeft-GCMVTab
        &       GMoveRight-GCMVTab
        &       GMoveLeft-GCMVTab
        &       GMoveDown-GCMVTab
        &       GMoveDown-GCMVTab
        &       GMoveUp-GCMVTab
        &       GMoveUp-GCMVTab

; Move graphics cursor right if possible - on exit C=0 iff OK to move

GMoveRight
        ADD     R0, R0, R2              ; add on GCharSpaceX
GMove10
        STR     R0, [WsPtr, #GCsIX]
GMove15
        BLT     GMoveOK                 ; if we were outside already
        TST     R6, #&40                ; or we are in nowrap mode
        BNE     GMoveOK                 ; then we were OK to move
        WINDow  R0, R1, R8,R9,R10,R11
        BGE     GMoveOK                 ; if inside now, then OK
        SEC
        MOV     PC, R14

GMoveOK
        CLC
        MOV     PC, R14

; Move graphics cursor left if possible - on exit C=0 iff OK to move

GMoveLeft
        SUB     R0, R0, R2              ; subtract off GCharSpaceX
        B       GMove10

; Move graphics cursor down if possible - on exit C=0 iff OK to move

GMoveDown
        SUB     R1, R1, R3              ; subtract off GCharSpaceY
GMove20
        STR     R1, [WsPtr, #GCsIY]
        B       GMove15

; Move graphics cursor up if possible - on exit C=0 iff OK to move

GMoveUp
        ADD     R1, R1, R3              ; add on GCharSpaceY
        B       GMove20

; *****************************************************************************
;
;       Move graphics cursor to boundary indicated by value of R6 in bits 1-3
;       (0 or 4 = left, 2 or 6 = right, 8 or 10 = up, 12 or 14 = down)
;       + R0 character positions in
;

GCursorB0
        MOV     R0, #0
GCursorBdy
        ADR     R7, GCBDYTab
        B       DoJumpTable

GCBDYTab
        &       GCursorLBdy-GCBDYTab
        &       GCursorRBdy-GCBDYTab
        &       GCursorLBdy-GCBDYTab
        &       GCursorRBdy-GCBDYTab
        &       GCursorUBdy-GCBDYTab
        &       GCursorUBdy-GCBDYTab
        &       GCursorDBdy-GCBDYTab
        &       GCursorDBdy-GCBDYTab

; Move graphics cursor to left boundary + R0 characters in

GCursorLBdy
        LDR     R7, [WsPtr, #GWLCol]
        LDR     R2, [WsPtr, #GCharSpaceX]
        MLA     R0, R2, R0, R7                  ; GCsIX := GWLCol + (X*SpaceX)
        STR     R0, [WsPtr, #GCsIX]
        MOV     PC, R14

; Move graphics cursor to right boundary + R0 characters in
; (adjust for character size)

GCursorRBdy
        LDR     R7, [WsPtr, #GWRCol]
        LDR     R2, [WsPtr, #GCharSizeX]
        SUB     R7, R2, R7                      ; R7 = SizeX-GWRCol
        LDR     R2, [WsPtr, #GCharSpaceX]
        MLA     R0, R2, R0, R7                  ; R0 = SizeX-GWRCol+X*SpaceX
        RSB     R0, R0, #1                      ; GWRCol-X*SpaceX-(SizeX-1)
        STR     R0, [WsPtr, #GCsIX]
        MOV     PC, R14

; Move graphics cursor to up boundary + R0 characters in

GCursorUBdy
        LDR     R7, [WsPtr, #GWTRow]
        LDR     R2, [WsPtr, #GCharSpaceY]
        RSB     R2, R2, #0                      ; -SizeY
        MLA     R0, R2, R0, R7                  ; GWTRow-Y*SizeY
        STR     R0, [WsPtr, #GCsIY]
        MOV     PC, R14

; Move graphics cursor to down boundary + R0 characters in
; (adjust for character size)

GCursorDBdy
        LDR     R7, [WsPtr, #GWBRow]
        LDR     R2, [WsPtr, #GCharSpaceY]
        MLA     R0, R2, R0, R7                  ; GWBRow+Y*SpaceY
        LDR     R2, [WsPtr, #GCharSizeY]
        ADD     R0, R0, R2
        SUB     R0, R0, #1                      ; GWBRow+Y*SpaceY+(SizeY-1)
        STR     R0, [WsPtr, #GCsIY]
        MOV     PC, R14

; *****************************************************************************
;
;       ClipVdu5 - Add a VDU 5 char to clip box
;
; in:   cxl2 = left
;       cyb2 = top-bottom
;       cxr2 = right
;       cyt2 = top
;
; out:  All registers preserved
;

        ASSERT  (cxl2=R4) :LAND: (cyb2=R3) :LAND: (cxr2=R10) :LAND: (cyt2=R2)

ClipVdu5 ROUT
        Push    "R0-R3, R4, R10, R14"
        MOV     R0, cxl2
        SUB     R1, cyt2, cyb2       ; top-(top-bottom) = bottom
        MOV     R3, cyt2
        MOV     R2, cxr2
        BL      MergeClipBox
        Pull    "R0-R3, R4, R10, PC"

        END
@


4.1
log
@Initial revision
@
text
@d98 2
a99 2
        MOVCS   charptr, charptr, LSL #1        ; Double address if SizeY = 16
                                                ;   (tricky code, originally
a135 3
        TEQ     sizey, #16                      ; If double height, signal this
        RSBEQ   charptr, charptr, #0            ;   by making fontptr negative

d143 3
d171 6
a176 4
        MVNS    charbyte, charptr               ;Pick up character definition
        LDRPLB  charbyte, [charbyte, -charbyte, LSR #1] ;  byte, using tricky
        SUBPL   charptr, charptr, #1            ;  code for double height (and
        LDRMIB  charbyte, [charptr], #1         ;  simple code for single!)
a182 1
      [ VIDC_Type = "VIDC20"
d184 1
a184 3
      |
        ADD     R14, WsPtr, #TextExpand         ;Address correct expansion
      ]
d200 12
d213 1
a213 6
        LDRNE   chartmp, [scr, #8]
        ANDNE   R14, ormask, cword2
        ORRNE   chartmp, chartmp, R14
        ANDNE   R14, eormask, cword2
        EORNE   chartmp, chartmp, R14
        STRNE   chartmp, [scr, #8]
d217 1
a217 6
        LDRNE   chartmp, [scr, #4]
        ANDNE   R14, ormask, cword1
        ORRNE   chartmp, chartmp, R14
        ANDNE   R14, eormask, cword1
        EORNE   chartmp, chartmp, R14
        STRNE   chartmp, [scr, #4]
d219 2
a220 7
        LDRNE   chartmp, [scr]
        ANDNE   R14, ormask, cword0
        ORRNE   chartmp, chartmp, R14
        ANDNE   R14, eormask, cword0
        EORNE   chartmp, chartmp, R14
        STRNE   chartmp, [scr]
  
a233 1
      [ VIDC_Type = "VIDC20"
a235 1
      ]
d243 1
a243 6
        LDRNE   chartmp, [scr, #16]
        ANDNE   R14, ormask, cword2
        ORRNE   chartmp, chartmp, R14
        ANDNE   R14, eormask, cword2
        EORNE   chartmp, chartmp, R14
        STRNE   chartmp, [scr, #16]
d246 1
a246 6
        LDRNE   chartmp, [scr, #12]
        ANDNE   R14, ormask, cword1
        ORRNE   chartmp, chartmp, R14
        ANDNE   R14, eormask, cword1
        EORNE   chartmp, chartmp, R14
        STRNE   chartmp, [scr, #12]
d248 1
a248 1
        
d254 1
a254 1
          
d257 1
a257 3
      [ VIDC_Type = "VIDC20"

        MACRO   
d266 10
a275 3
        
; Perform bit expansion on the fly, this is a word based operation, no need to 
; extract sub-pixels from the ORR / EOR masks, simply perform the bit test and 
d279 19
a297 1
                                   
d306 1
a306 1
                              
d308 1
a308 2
                            
      ]
a381 1
      [ {TRUE}
a383 5
      |
        LDR     R0, [WsPtr, #NPix]              ; Graphics mode ?
        TEQ     R0, #0
        MOVEQ   PC, R14                         ; no, then return
      ]       
a397 1
      [ {TRUE}
a399 5
      |
        LDR     R0, [WsPtr, #NPix]              ; Graphics mode ?
        TEQ     R0, #0
        MOVEQ   PC, R14                         ; no, then return
      ]
d604 1
a604 1
        LDR     R2, [WsPtr, #GCharSpaceX]        
@


4.1.8.1
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d181 1
d183 3
a185 1

d238 1
d241 1
d273 2
d301 2
a302 1

@


4.1.8.2
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d98 2
a99 2
        MOVCS   charptr, charptr, ASL #1        ; Double address if SizeY = 16
        SUBCS   charptr, charptr, #1            ;   (tricky code, originally
d136 3
a145 3
        TEQ     sizey, #16                      ; If double height, signal this
        ORREQ   charmsk, charmsk, #1:SHL:31     ;   by making charmsk negative

d171 4
a174 6
        ASSERT  HardFont < &40000000 :LOR: HardFont >= &C0000000
        ASSERT  WsPtr < &40000000 :LOR: WsPtr >= &C0000000
        TEQ     charmsk, #0                     ; Double height? (MI=yes)
        LDRMIB  charbyte, [charptr, -charptr, ASR #1] ; Use ASR, as font will be at
        LDRPLB  charbyte, [charptr]             ; top or bottom of memory (zero page,
        ADD     charptr, charptr, #1            ; system heap or ROM)
a197 12

        MACRO
$l      DoVdu5Word $c, $reg, $off
$l
        LDR$c   chartmp, [scr, #$off]
        AND$c   R14, ormask, $reg
        ORR$c   chartmp, chartmp, R14
        AND$c   R14, eormask, $reg
        EOR$c   chartmp, chartmp, R14
        STR$c   chartmp, [scr, #$off]
        MEND

d199 6
a204 1
        DoVdu5Word NE, cword2, 8
d208 6
a213 1
        DoVdu5Word NE, cword1, 4
d215 7
a221 2
        DoVdu5Word NE, cword0, 0

d244 6
a249 1
        DoVdu5Word NE, cword2, 16
d252 6
a257 1
        DoVdu5Word NE, cword1, 12
d259 1
a259 1

d265 1
a265 1

d268 1
a268 1
        MACRO
d277 3
a279 10

        MACRO
$l      PixSolid32 $reg, $mask, $offset
$l
        TST     $reg, #$mask
        STRNE   chartmp, [scr, #$offset]
        MEND

; Perform bit expansion on the fly, this is a word based operation, no need to
; extract sub-pixels from the ORR / EOR masks, simply perform the bit test and
d283 1
a283 19

 [ AvoidScreenReads
        CMP     ormask, #&FFFFFFFF
        BNE     Vdu5Mode32_NotSolid

        MVN     chartmp, eormask
        PixSolid32 charbyte, 1<<7, 0
        PixSolid32 charbyte, 1<<6, 4
        PixSolid32 charbyte, 1<<5, 8
        PixSolid32 charbyte, 1<<4, 12
        PixSolid32 charbyte, 1<<3, 16
        PixSolid32 charbyte, 1<<2, 20
        PixSolid32 charbyte, 1<<1, 24
        PixSolid32 charbyte, 1<<0, 28

        B       Vdu5LinePainted

Vdu5Mode32_NotSolid
 ]
d292 1
a292 1

d368 1
d371 5
d390 1
d393 5
d602 1
a602 1
        LDR     R2, [WsPtr, #GCharSpaceX]
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d184 1
d376 1
d379 5
d398 1
d401 5
@


4.1.4.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d181 1
d183 2
d237 1
d240 1
d272 2
d300 2
@


4.1.4.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d181 1
d183 2
d237 1
d240 1
d272 2
d300 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

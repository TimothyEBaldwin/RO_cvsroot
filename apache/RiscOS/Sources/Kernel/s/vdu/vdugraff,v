head	4.3;
access;
symbols
	Kernel-6_15:4.3
	Kernel-6_14:4.3
	Kernel-6_01-3:4.3
	Kernel-6_13:4.3
	Kernel-6_12:4.3
	Kernel-6_11:4.3
	Kernel-6_10:4.3
	Kernel-6_09:4.3
	Kernel-6_08-4_129_2_10:4.3
	Kernel-6_08-4_129_2_9:4.3
	Kernel-6_08:4.3
	Kernel-6_07:4.3
	Kernel-6_06:4.3
	Kernel-6_05-4_129_2_8:4.3
	Kernel-6_05:4.3
	Kernel-6_04:4.3
	Kernel-6_03:4.3
	Kernel-6_01-2:4.3
	Kernel-6_01-4_146_2_1:4.3
	Kernel-6_02:4.3
	Kernel-6_01-1:4.3
	Kernel-6_01:4.3
	Kernel-6_00:4.3
	Kernel-5_99:4.3
	Kernel-5_98:4.3
	Kernel-5_97-4_129_2_7:4.3
	Kernel-5_97:4.3
	Kernel-5_96:4.3
	Kernel-5_95:4.3
	Kernel-5_94:4.3
	Kernel-5_93:4.3
	Kernel-5_92:4.3
	Kernel-5_91:4.3
	Kernel-5_90:4.3
	Kernel-5_89-4_129_2_6:4.3
	Kernel-5_89:4.3
	Kernel-5_88-4_129_2_5:4.3
	Kernel-5_88-4_129_2_4:4.3
	Kernel-5_88:4.3
	Kernel-5_87:4.3
	Kernel-5_86-4_129_2_3:4.3
	Kernel-5_86-4_129_2_2:4.3
	Kernel-5_86-4_129_2_1:4.3
	Kernel-5_86:4.3
	SMP:4.3.0.2
	SMP_bp:4.3
	Kernel-5_85:4.3
	Kernel-5_54-1:4.3
	Kernel-5_84:4.3
	Kernel-5_83:4.3
	Kernel-5_82:4.3
	Kernel-5_81:4.3
	Kernel-5_80:4.3
	Kernel-5_79:4.3
	Kernel-5_78:4.3
	Kernel-5_77:4.3
	Kernel-5_76:4.3
	Kernel-5_75:4.3
	Kernel-5_74:4.3
	Kernel-5_73:4.3
	Kernel-5_72:4.3
	Kernel-5_71:4.3
	Kernel-5_70:4.3
	Kernel-5_69:4.3
	Kernel-5_68:4.3
	Kernel-5_67:4.3
	Kernel-5_66:4.3
	Kernel-5_65:4.3
	Kernel-5_64:4.3
	Kernel-5_63:4.3
	Kernel-5_62:4.3
	Kernel-5_61:4.3
	Kernel-5_60:4.3
	Kernel-5_59:4.3
	Kernel-5_58:4.3
	Kernel-5_57:4.3
	Kernel-5_56:4.3
	Kernel-5_55:4.3
	Kernel-5_54:4.3
	Kernel-5_53:4.3
	Kernel-5_52:4.3
	Kernel-5_51:4.3
	Kernel-5_50:4.3
	Kernel-5_49:4.3
	HAL_merge:4.2.2.2
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.2
	Kernel-5_35-4_79_2_326:4.2.2.2
	Kernel-5_35-4_79_2_325:4.2.2.2
	Kernel-5_35-4_79_2_324:4.2.2.2
	Kernel-5_35-4_79_2_323:4.2.2.2
	Kernel-5_35-4_79_2_322:4.2.2.2
	Kernel-5_35-4_79_2_321:4.2.2.2
	Kernel-5_35-4_79_2_320:4.2.2.2
	Kernel-5_35-4_79_2_319:4.2.2.2
	Kernel-5_35-4_79_2_318:4.2.2.2
	Kernel-5_35-4_79_2_317:4.2.2.2
	Kernel-5_35-4_79_2_316:4.2.2.2
	Kernel-5_35-4_79_2_315:4.2.2.2
	Kernel-5_35-4_79_2_314:4.2.2.2
	Kernel-5_35-4_79_2_313:4.2.2.2
	Kernel-5_35-4_79_2_312:4.2.2.2
	Kernel-5_35-4_79_2_311:4.2.2.2
	Kernel-5_35-4_79_2_310:4.2.2.2
	Kernel-5_35-4_79_2_309:4.2.2.2
	Kernel-5_35-4_79_2_308:4.2.2.2
	Kernel-5_35-4_79_2_307:4.2.2.2
	Kernel-5_35-4_79_2_306:4.2.2.2
	Kernel-5_35-4_79_2_305:4.2.2.2
	Kernel-5_35-4_79_2_304:4.2.2.2
	Kernel-5_35-4_79_2_303:4.2.2.2
	Kernel-5_35-4_79_2_302:4.2.2.2
	Kernel-5_35-4_79_2_301:4.2.2.2
	Kernel-5_35-4_79_2_300:4.2.2.2
	Kernel-5_35-4_79_2_299:4.2.2.2
	Kernel-5_35-4_79_2_298:4.2.2.2
	Kernel-5_35-4_79_2_297:4.2.2.2
	Kernel-5_35-4_79_2_296:4.2.2.2
	Kernel-5_35-4_79_2_295:4.2.2.2
	Kernel-5_35-4_79_2_294:4.2.2.2
	Kernel-5_35-4_79_2_293:4.2.2.2
	Kernel-5_35-4_79_2_292:4.2.2.2
	Kernel-5_35-4_79_2_291:4.2.2.2
	Kernel-5_35-4_79_2_290:4.2.2.2
	Kernel-5_35-4_79_2_289:4.2.2.2
	Kernel-5_35-4_79_2_288:4.2.2.2
	Kernel-5_35-4_79_2_287:4.2.2.2
	Kernel-5_35-4_79_2_286:4.2.2.2
	Kernel-5_35-4_79_2_285:4.2.2.2
	Kernel-5_35-4_79_2_284:4.2.2.2
	Kernel-5_35-4_79_2_283:4.2.2.2
	Kernel-5_35-4_79_2_282:4.2.2.2
	Kernel-5_35-4_79_2_281:4.2.2.2
	Kernel-5_35-4_79_2_280:4.2.2.2
	Kernel-5_35-4_79_2_279:4.2.2.2
	Kernel-5_35-4_79_2_278:4.2.2.2
	Kernel-5_35-4_79_2_277:4.2.2.2
	Kernel-5_35-4_79_2_276:4.2.2.2
	Kernel-5_35-4_79_2_275:4.2.2.2
	Kernel-5_35-4_79_2_274:4.2.2.2
	Kernel-5_35-4_79_2_273:4.2.2.2
	Kernel-5_35-4_79_2_272:4.2.2.2
	Kernel-5_35-4_79_2_271:4.2.2.2
	Kernel-5_35-4_79_2_270:4.2.2.2
	Kernel-5_35-4_79_2_269:4.2.2.2
	Kernel-5_35-4_79_2_268:4.2.2.2
	Kernel-5_35-4_79_2_267:4.2.2.2
	Kernel-5_35-4_79_2_266:4.2.2.2
	Kernel-5_35-4_79_2_265:4.2.2.2
	Kernel-5_35-4_79_2_264:4.2.2.2
	Kernel-5_35-4_79_2_263:4.2.2.2
	Kernel-5_35-4_79_2_262:4.2.2.2
	Kernel-5_35-4_79_2_261:4.2.2.2
	Kernel-5_35-4_79_2_260:4.2.2.2
	Kernel-5_35-4_79_2_259:4.2.2.2
	Kernel-5_35-4_79_2_258:4.2.2.2
	Kernel-5_35-4_79_2_257:4.2.2.2
	Kernel-5_35-4_79_2_256:4.2.2.2
	Kernel-5_35-4_79_2_255:4.2.2.2
	Kernel-5_35-4_79_2_254:4.2.2.2
	Kernel-5_35-4_79_2_253:4.2.2.2
	Kernel-5_35-4_79_2_252:4.2.2.2
	Kernel-5_35-4_79_2_251:4.2.2.2
	Kernel-5_35-4_79_2_250:4.2.2.2
	Kernel-5_35-4_79_2_249:4.2.2.2
	Kernel-5_35-4_79_2_248:4.2.2.2
	Kernel-5_35-4_79_2_247:4.2.2.2
	Kernel-5_35-4_79_2_246:4.2.2.2
	Kernel-5_35-4_79_2_245:4.2.2.2
	Kernel-5_35-4_79_2_244:4.2.2.2
	Kernel-5_35-4_79_2_243:4.2.2.2
	Kernel-5_35-4_79_2_242:4.2.2.2
	Kernel-5_35-4_79_2_241:4.2.2.2
	Kernel-5_35-4_79_2_240:4.2.2.2
	Kernel-5_35-4_79_2_239:4.2.2.2
	Kernel-5_35-4_79_2_238:4.2.2.2
	Kernel-5_35-4_79_2_237:4.2.2.2
	Kernel-5_35-4_79_2_236:4.2.2.2
	Kernel-5_35-4_79_2_235:4.2.2.2
	Kernel-5_35-4_79_2_234:4.2.2.2
	Kernel-5_35-4_79_2_233:4.2.2.2
	Kernel-5_35-4_79_2_232:4.2.2.2
	Kernel-5_35-4_79_2_231:4.2.2.2
	Kernel-5_35-4_79_2_230:4.2.2.2
	Kernel-5_35-4_79_2_229:4.2.2.2
	Kernel-5_35-4_79_2_228:4.2.2.2
	Kernel-5_35-4_79_2_227:4.2.2.2
	Kernel-5_35-4_79_2_226:4.2.2.2
	Kernel-5_35-4_79_2_225:4.2.2.2
	Kernel-5_35-4_79_2_224:4.2.2.2
	Kernel-5_35-4_79_2_223:4.2.2.2
	Kernel-5_35-4_79_2_222:4.2.2.2
	Kernel-5_35-4_79_2_221:4.2.2.2
	Kernel-5_35-4_79_2_220:4.2.2.2
	Kernel-5_35-4_79_2_219:4.2.2.2
	Kernel-5_35-4_79_2_218:4.2.2.2
	Kernel-5_35-4_79_2_217:4.2.2.2
	Kernel-5_35-4_79_2_216:4.2.2.2
	Kernel-5_35-4_79_2_215:4.2.2.2
	Kernel-5_35-4_79_2_214:4.2.2.2
	Kernel-5_35-4_79_2_213:4.2.2.2
	Kernel-5_35-4_79_2_212:4.2.2.2
	Kernel-5_35-4_79_2_211:4.2.2.2
	Kernel-5_35-4_79_2_210:4.2.2.2
	Kernel-5_35-4_79_2_209:4.2.2.2
	Kernel-5_35-4_79_2_208:4.2.2.2
	Kernel-5_35-4_79_2_207:4.2.2.2
	Kernel-5_35-4_79_2_206:4.2.2.2
	Kernel-5_35-4_79_2_205:4.2.2.2
	Kernel-5_35-4_79_2_204:4.2.2.2
	Kernel-5_35-4_79_2_203:4.2.2.2
	Kernel-5_35-4_79_2_202:4.2.2.2
	Kernel-5_35-4_79_2_201:4.2.2.2
	Kernel-5_35-4_79_2_200:4.2.2.2
	Kernel-5_35-4_79_2_199:4.2.2.2
	Kernel-5_35-4_79_2_198:4.2.2.2
	Kernel-5_35-4_79_2_197:4.2.2.2
	Kernel-5_35-4_79_2_196:4.2.2.2
	Kernel-5_35-4_79_2_195:4.2.2.2
	Kernel-5_35-4_79_2_194:4.2.2.2
	Kernel-5_35-4_79_2_193:4.2.2.2
	Kernel-5_35-4_79_2_192:4.2.2.2
	Kernel-5_35-4_79_2_191:4.2.2.2
	Kernel-5_35-4_79_2_190:4.2.2.2
	Kernel-5_35-4_79_2_189:4.2.2.2
	Kernel-5_35-4_79_2_188:4.2.2.2
	Kernel-5_35-4_79_2_187:4.2.2.2
	Kernel-5_35-4_79_2_186:4.2.2.2
	Kernel-5_35-4_79_2_185:4.2.2.2
	Kernel-5_35-4_79_2_184:4.2.2.2
	Kernel-5_35-4_79_2_183:4.2.2.2
	Kernel-5_35-4_79_2_182:4.2.2.2
	Kernel-5_35-4_79_2_181:4.2.2.2
	Kernel-5_35-4_79_2_180:4.2.2.2
	Kernel-5_35-4_79_2_179:4.2.2.2
	Kernel-5_35-4_79_2_178:4.2.2.2
	Kernel-5_35-4_79_2_177:4.2.2.2
	Kernel-5_35-4_79_2_176:4.2.2.2
	Kernel-5_35-4_79_2_175:4.2.2.2
	Kernel-5_35-4_79_2_174:4.2.2.2
	Kernel-5_35-4_79_2_173:4.2.2.2
	Kernel-5_35-4_79_2_172:4.2.2.2
	Kernel-5_35-4_79_2_171:4.2.2.2
	Kernel-5_35-4_79_2_170:4.2.2.2
	Kernel-5_35-4_79_2_169:4.2.2.2
	Kernel-5_35-4_79_2_168:4.2.2.2
	Kernel-5_35-4_79_2_167:4.2.2.2
	Kernel-5_35-4_79_2_166:4.2.2.2
	Kernel-5_35-4_79_2_165:4.2.2.2
	RPi_merge:4.2.2.2
	Kernel-5_35-4_79_2_147_2_23:4.2.2.2
	Kernel-5_35-4_79_2_147_2_22:4.2.2.2
	Kernel-5_35-4_79_2_147_2_21:4.2.2.2
	Kernel-5_35-4_79_2_147_2_20:4.2.2.2
	Kernel-5_35-4_79_2_147_2_19:4.2.2.2
	Kernel-5_35-4_79_2_147_2_18:4.2.2.2
	Kernel-5_35-4_79_2_164:4.2.2.2
	Kernel-5_35-4_79_2_163:4.2.2.2
	Kernel-5_35-4_79_2_147_2_17:4.2.2.2
	Kernel-5_35-4_79_2_147_2_16:4.2.2.2
	Kernel-5_35-4_79_2_147_2_15:4.2.2.2
	Kernel-5_35-4_79_2_162:4.2.2.2
	Kernel-5_35-4_79_2_161:4.2.2.2
	Kernel-5_35-4_79_2_147_2_14:4.2.2.2
	Kernel-5_35-4_79_2_147_2_13:4.2.2.2
	Kernel-5_35-4_79_2_160:4.2.2.2
	Kernel-5_35-4_79_2_159:4.2.2.2
	Kernel-5_35-4_79_2_158:4.2.2.2
	Kernel-5_35-4_79_2_157:4.2.2.2
	Kernel-5_35-4_79_2_156:4.2.2.2
	Kernel-5_35-4_79_2_147_2_12:4.2.2.2
	Kernel-5_35-4_79_2_147_2_11:4.2.2.2
	Kernel-5_35-4_79_2_155:4.2.2.2
	Kernel-5_35-4_79_2_147_2_10:4.2.2.2
	Kernel-5_35-4_79_2_154:4.2.2.2
	Kernel-5_35-4_79_2_153:4.2.2.2
	Kernel-5_35-4_79_2_147_2_9:4.2.2.2
	Kernel-5_35-4_79_2_152:4.2.2.2
	Kernel-5_35-4_79_2_151:4.2.2.2
	Kernel-5_35-4_79_2_147_2_8:4.2.2.2
	Kernel-5_35-4_79_2_147_2_7:4.2.2.2
	Kernel-5_35-4_79_2_150:4.2.2.2
	Kernel-5_35-4_79_2_147_2_6:4.2.2.2
	Kernel-5_35-4_79_2_147_2_5:4.2.2.2
	Kernel-5_35-4_79_2_149:4.2.2.2
	Kernel-5_35-4_79_2_147_2_4:4.2.2.2
	Kernel-5_35-4_79_2_147_2_3:4.2.2.2
	Kernel-5_35-4_79_2_148:4.2.2.2
	Kernel-5_35-4_79_2_147_2_2:4.2.2.2
	Kernel-5_35-4_79_2_147_2_1:4.2.2.2
	RPi:4.2.2.2.0.2
	RPi_bp:4.2.2.2
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2.2.1
	alees_Kernel_dev:4.2.2.1.0.4
	alees_Kernel_dev_bp:4.2.2.1
	Kernel-5_35-4_79_2_147:4.2.2.2
	Kernel-5_35-4_79_2_146:4.2.2.2
	Kernel-5_35-4_79_2_145:4.2.2.2
	Kernel-5_35-4_79_2_144:4.2.2.2
	Kernel-5_35-4_79_2_143:4.2.2.2
	Kernel-5_35-4_79_2_142:4.2.2.2
	Kernel-5_35-4_79_2_141:4.2.2.2
	Kernel-5_35-4_79_2_140:4.2.2.2
	Kernel-5_35-4_79_2_139:4.2.2.2
	Kernel-5_35-4_79_2_138:4.2.2.2
	Kernel-5_35-4_79_2_137:4.2.2.2
	Kernel-5_35-4_79_2_136:4.2.2.2
	Kernel-5_35-4_79_2_135:4.2.2.2
	Kernel-5_35-4_79_2_134:4.2.2.2
	Kernel-5_35-4_79_2_133:4.2.2.2
	Kernel-5_35-4_79_2_132:4.2.2.2
	Kernel-5_35-4_79_2_131:4.2.2.2
	Kernel-5_35-4_79_2_130:4.2.2.2
	Kernel-5_35-4_79_2_129:4.2.2.2
	Kernel-5_35-4_79_2_128:4.2.2.2
	Kernel-5_35-4_79_2_127:4.2.2.2
	Kernel-5_35-4_79_2_126:4.2.2.2
	Kernel-5_35-4_79_2_125:4.2.2.2
	Kernel-5_35-4_79_2_124:4.2.2.2
	Kernel-5_35-4_79_2_123:4.2.2.1
	Cortex_merge:4.2.2.1
	Kernel-5_35-4_79_2_122:4.2.2.1
	Kernel-5_35-4_79_2_98_2_54:4.2.2.1
	Kernel-5_35-4_79_2_98_2_53:4.2.2.1
	Kernel-5_35-4_79_2_98_2_52:4.2.2.1
	Kernel-5_35-4_79_2_98_2_51:4.2.2.1
	Kernel-5_35-4_79_2_98_2_50:4.2.2.1
	Kernel-5_35-4_79_2_98_2_49:4.2.2.1
	Kernel-5_35-4_79_2_98_2_48:4.2.2.1
	Kernel-5_35-4_79_2_121:4.2.2.1
	Kernel-5_35-4_79_2_98_2_47:4.2.2.1
	Kernel-5_35-4_79_2_120:4.2.2.1
	Kernel-5_35-4_79_2_98_2_46:4.2.2.1
	Kernel-5_35-4_79_2_119:4.2.2.1
	Kernel-5_35-4_79_2_98_2_45:4.2.2.1
	Kernel-5_35-4_79_2_98_2_44:4.2.2.1
	Kernel-5_35-4_79_2_118:4.2.2.1
	Kernel-5_35-4_79_2_98_2_43:4.2.2.1
	Kernel-5_35-4_79_2_117:4.2.2.1
	Kernel-5_35-4_79_2_116:4.2.2.1
	Kernel-5_35-4_79_2_98_2_42:4.2.2.1
	Kernel-5_35-4_79_2_115:4.2.2.1
	Kernel-5_35-4_79_2_98_2_41:4.2.2.1
	Kernel-5_35-4_79_2_98_2_40:4.2.2.1
	Kernel-5_35-4_79_2_114:4.2.2.1
	Kernel-5_35-4_79_2_98_2_39:4.2.2.1
	Kernel-5_35-4_79_2_98_2_38:4.2.2.1
	Kernel-5_35-4_79_2_113:4.2.2.1
	Kernel-5_35-4_79_2_112:4.2.2.1
	Kernel-5_35-4_79_2_98_2_37:4.2.2.1
	Kernel-5_35-4_79_2_98_2_36:4.2.2.1
	Kernel-5_35-4_79_2_98_2_35:4.2.2.1
	Kernel-5_35-4_79_2_98_2_34:4.2.2.1
	Kernel-5_35-4_79_2_98_2_33:4.2.2.1
	Kernel-5_35-4_79_2_98_2_32:4.2.2.1
	Kernel-5_35-4_79_2_98_2_31:4.2.2.1
	Kernel-5_35-4_79_2_98_2_30:4.2.2.1
	Kernel-5_35-4_79_2_98_2_29:4.2.2.1
	Kernel-5_35-4_79_2_98_2_28:4.2.2.1
	Kernel-5_35-4_79_2_98_2_27:4.2.2.1
	Kernel-5_35-4_79_2_98_2_26:4.2.2.1
	Kernel-5_35-4_79_2_111:4.2.2.1
	Kernel-5_35-4_79_2_98_2_25:4.2.2.1
	Kernel-5_35-4_79_2_98_2_24:4.2.2.1
	Kernel-5_35-4_79_2_98_2_23:4.2.2.1
	Kernel-5_35-4_79_2_110:4.2.2.1
	Kernel-5_35-4_79_2_98_2_22:4.2.2.1
	Kernel-5_35-4_79_2_109:4.2.2.1
	Kernel-5_35-4_79_2_98_2_21:4.2.2.1
	Kernel-5_35-4_79_2_98_2_20:4.2.2.1
	Kernel-5_35-4_79_2_108:4.2.2.1
	Kernel-5_35-4_79_2_107:4.2.2.1
	Kernel-5_35-4_79_2_98_2_19:4.2.2.1
	Kernel-5_35-4_79_2_98_2_18:4.2.2.1
	Kernel-5_35-4_79_2_98_2_17:4.2.2.1
	Kernel-5_35-4_79_2_98_2_16:4.2.2.1
	Kernel-5_35-4_79_2_98_2_15:4.2.2.1
	Kernel-5_35-4_79_2_106:4.2.2.1
	Kernel-5_35-4_79_2_105:4.2.2.1
	Kernel-5_35-4_79_2_104:4.2.2.1
	Kernel-5_35-4_79_2_98_2_14:4.2.2.1
	Kernel-5_35-4_79_2_98_2_13:4.2.2.1
	Kernel-5_35-4_79_2_98_2_12:4.2.2.1
	Kernel-5_35-4_79_2_98_2_11:4.2.2.1
	Kernel-5_35-4_79_2_98_2_10:4.2.2.1
	Kernel-5_35-4_79_2_98_2_9:4.2.2.1
	Kernel-5_35-4_79_2_103:4.2.2.1
	Kernel-5_35-4_79_2_102:4.2.2.1
	Kernel-5_35-4_79_2_98_2_8:4.2.2.1
	Kernel-5_35-4_79_2_98_2_7:4.2.2.1
	Kernel-5_35-4_79_2_98_2_6:4.2.2.1
	Kernel-5_35-4_79_2_98_2_5:4.2.2.1
	Kernel-5_35-4_79_2_98_2_4:4.2.2.1
	Kernel-5_35-4_79_2_101:4.2.2.1
	Kernel-5_35-4_79_2_100:4.2.2.1
	Kernel-5_35-4_79_2_99:4.2.2.1
	Kernel-5_35-4_79_2_98_2_3:4.2.2.1
	Kernel-5_35-4_79_2_98_2_2:4.2.2.1
	Kernel-5_35-4_79_2_98_2_1:4.2.2.1
	Cortex:4.2.2.1.0.2
	Cortex_bp:4.2.2.1
	Kernel-5_35-4_79_2_98:4.2.2.1
	Kernel-5_35-4_79_2_97:4.2.2.1
	Kernel-5_35-4_79_2_96:4.2.2.1
	Kernel-5_35-4_79_2_95:4.2.2.1
	Kernel-5_35-4_79_2_94:4.2.2.1
	Kernel-5_35-4_79_2_93:4.2.2.1
	Kernel-5_35-4_79_2_92:4.2.2.1
	Kernel-5_35-4_79_2_91:4.2.2.1
	Kernel-5_35-4_79_2_90:4.2.2.1
	Kernel-5_35-4_79_2_89:4.2.2.1
	Kernel-5_35-4_79_2_88:4.2.2.1
	Kernel-5_35-4_79_2_87:4.2.2.1
	Kernel-5_35-4_79_2_86:4.2.2.1
	Kernel-5_35-4_79_2_85:4.2.2.1
	Kernel-5_35-4_79_2_84:4.2.2.1
	Kernel-5_35-4_79_2_83:4.2.2.1
	Kernel-5_35-4_79_2_82:4.2.2.1
	Kernel-5_35-4_79_2_81:4.2.2.1
	Kernel-5_35-4_79_2_80:4.2.2.1
	Kernel-5_35-4_79_2_79:4.2.2.1
	Kernel-5_35-4_79_2_78:4.2.2.1
	Kernel-5_35-4_79_2_77:4.2.2.1
	RO_5_07:4.2.2.1
	Kernel-5_35-4_79_2_76:4.2.2.1
	Kernel-5_35-4_79_2_75:4.2.2.1
	Kernel-5_35-4_79_2_74:4.2.2.1
	Kernel-5_35-4_79_2_73:4.2.2.1
	Kernel-5_35-4_79_2_72:4.2.2.1
	Kernel-5_35-4_79_2_71:4.2.2.1
	Kernel-5_35-4_79_2_70:4.2.2.1
	Kernel-5_35-4_79_2_69:4.2.2.1
	Kernel-5_35-4_79_2_68:4.2.2.1
	Kernel-5_35-4_79_2_67:4.2.2.1
	Kernel-5_35-4_79_2_66:4.2.2.1
	Kernel-5_35-4_79_2_65:4.2.2.1
	Kernel-5_35-4_79_2_64:4.2.2.1
	Kernel-5_35-4_79_2_63:4.2.2.1
	Kernel-5_35-4_79_2_62:4.2.2.1
	Kernel-5_35-4_79_2_61:4.2.2.1
	Kernel-5_35-4_79_2_59:4.2.2.1
	Kernel-5_35-4_79_2_58:4.2.2.1
	Kernel-5_35-4_79_2_57:4.2.2.1
	Kernel-5_35-4_79_2_56:4.2.2.1
	Kernel-5_35-4_79_2_55:4.2.2.1
	Kernel-5_35-4_79_2_54:4.2.2.1
	Kernel-5_35-4_79_2_53:4.2.2.1
	Kernel-5_35-4_79_2_52:4.2.2.1
	Kernel-5_35-4_79_2_51:4.2.2.1
	Kernel-5_35-4_79_2_50:4.2.2.1
	Kernel-5_35-4_79_2_49:4.2.2.1
	Kernel-5_35-4_79_2_48:4.2.2.1
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.6
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2
	Kernel-5_35-4_79_2_46:4.2
	Kernel-5_35-4_79_2_45:4.2
	Kernel-5_35-4_79_2_44:4.2
	Kernel-5_35-4_79_2_25_2_2:4.2
	Kernel-5_35-4_79_2_43:4.2
	Kernel-5_35-4_79_2_42:4.2
	Kernel-5_35-4_79_2_41:4.2
	Kernel-5_35-4_79_2_40:4.2
	Kernel-5_35-4_79_2_39:4.2
	Kernel-5_35-4_79_2_38:4.2
	Kernel-5_35-4_79_2_37:4.2
	Kernel-5_35-4_79_2_36:4.2
	Kernel-5_35-4_79_2_35:4.2
	Kernel-5_35-4_79_2_34:4.2
	Kernel-5_35-4_79_2_33:4.2
	Kernel-5_35-4_79_2_32:4.2
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2
	Kernel-5_35-4_79_2_30:4.2
	Kernel-5_35-4_79_2_29:4.2
	Kernel-5_35-4_79_2_28:4.2
	Kernel-5_35-4_79_2_27:4.2
	Kernel-5_35-4_79_2_26:4.2
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2
	Kernel-5_35-4_79_2_24:4.2
	Kernel-5_35-4_79_2_23:4.2
	Kernel-5_35-4_79_2_22:4.2
	Kernel-5_35-4_79_2_21:4.2
	Kernel-5_35-4_79_2_20:4.2
	Kernel-5_35-4_79_2_19:4.2
	Kernel-5_35-4_79_2_18:4.2
	Kernel-5_35-4_79_2_17:4.2
	Kernel-5_35-4_79_2_16:4.2
	Kernel-5_35-4_79_2_15:4.2
	Kernel-5_35-4_79_2_14:4.2
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2
	Kernel-5_35-4_79_2_12:4.2
	Kernel-5_35-4_79_2_11:4.2
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2
	Kernel-5_35-4_79_2_9:4.2
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2
	Kernel-5_35-4_79_2_7:4.2
	Kernel-5_35-4_79_2_6:4.2
	Kernel-5_35-4_79_2_5:4.2
	Kernel-5_35-4_79_2_4:4.2
	Kernel-5_35-4_79_2_3:4.2
	Kernel-5_35-4_79_2_2:4.2
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.04.04.14.27.40;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.37;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2011.11.27.11.48.21;	author rsprowson;	state Exp;
branches;
next	;
commitid	OFgqaKhOb6swXXIv;

4.1.1.1
date	96.11.05.09.41.37;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.12;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.39;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.10;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.41;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > &.Source.VduGrafF
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - Solid & Dotted Line drawing routines
;
; Author R C Manby
; Date   27.10.86
;


;
;
;
;------------------------------------------------------------------------------
;
; DoOsbyte163_242 - Set dotted line length and return status information
; ===============
;
; We are only interested in OsByte 163,242,0..66
;
; OsByte 163,242,0..64 set dotted line length
;        163,242,0      set default dot pattern and length
;        163,242,1..64  set specified pattern length
;
; OsByte 163,242,65 return graphics status
;                   returns R1 = &Cn (means GXR on & flood on (for GXR))
;                                    (means SpriteRom on (for master/compact))
;                                  n = dotted line length MOD 64
;                           R2 = number of sprite pages
;
; OsByte 163,242,66 return sprite status
;                   returns R1 = R2 = 0 if no sprite selected
;                           R1 = current sprite width
;                           R2 = current sprite height
;
; When entered, we know it is FX 163,242,n
; Exit by MOV PC, R14 if still don't understand (ie n>66)
; Otherwise exit with Pull PC

DoOsbyte163_242 ROUT
        CMP R2,#66
        MOVHI PC, R14                   ; Not 0..66, so pass it on

        Push "R3-R12"                   ; Preserve the world
        VDWS WsPtr                      ; Point R12 at Vdu driver workspace

        CMP R2,#65
        BLLT SetPatLength               ; R2 holds 0/1..64    ; PSR preserved
        BLT OsByte_QuitA
        BGT OsByte163_242_66

OsByte163_242_65                        ; OsByte 163,242,65 - graphics status
        LDR R1,[WsPtr,#DotLineLength]
        AND R1,R1,#&3F                  ; Dot count MOD 64
        ORR R1,R1,#&C0                  ; GXR on, Flood on
        LDR R2,[WsPtr,#SpAreaStart]
        CMP R2,#0
        LDRNE R2,[R2,#saEnd]            ; SpriteWS size
        B OsByte_QuitA

OsByte163_242_66                        ; OsByte 163,242,66 - sprite status

        MOV R0,#SpriteReason_ReadSpriteSize
        LDR R2,=SpChooseName
        ADD R2,R2,WsPtr                 ; Sprite name ptr

        SWI XOS_SpriteOp

        MOVVS R1,#0                     ; If no sprite memory, or no sprite
        MOVVS R2,#0                     ; chosen, return 0,0 as width,height

        MOVVC R1,R3                     ; else return width,height in pixels
        MOVVC R2,R4

OsByte_QuitA
        Pull "R3-R12,PC"                ; restore registers and claim call
;
;
;
;------------------------------------------------------------------------------




        MACRO
        WriteToScreen $Adr,$Msk,$Ecf, $a,$b,$c
        LDMIA $Ecf,{$a,$b}
        AND $a,$a,$Msk
        AND $b,$b,$Msk
 [ AvoidScreenReads
        CMP $a,#&FFFFFFFF
        LDRNE $c,[$Adr]
 |
        LDR $c,[$Adr]
 ]
        ORR $c,$c,$a
        EOR $c,$c,$b
        STR $c,[$Adr]
        MEND


;
;
;
;------------------------------------------------------------------------------




rXCnt    RN 0
rYCnt    RN 1
rBres    RN 2
rDeltaY  RN 3
rPixShft RN 4
rScrAdr  RN 5
rPixMsk  RN 6
rDotPtr  RN 7

rEcfPtr  RN 8

rEcfBase RN 8
rEcfIndx RN 9
rDeltaX  RN 10
rScanStp RN 11

rDotCnt    RN 9
rDotPatLSW RN 10
rDotPatMSW RN 11

rDOTCnt    RN 10
rDOTPatLSW RN 11
rDOTPatMSW RN 14


;
;------------------------------------------------------------------------------
;
; LineDraw - General line drawing routine
; ========
;
; On entry, ICursor is the start point of the line
;           NewPt is the end point
;
;           R2 holds plot code, where bits mean :-
;              bit 5  clear/set - include/exclude initial point
;              bit 4  clear/set - solid/dotted line
;              bit 3  clear/set - include/exclude final point
;
;              bit 5  implies   - restart/continue dot pattern
;
LineDrawSolid
        TST     R2, #&03                ; if a no action one
        MOVEQ   PC, R14                 ; then do nowt, just shunt coords
LineDrawDotted ROUT
        EOR     R11, R2, #&18   ; Flip solid/dotted flag, and final point flag
                                ; bit 4 set/clear - solid/dotted line
                                ; bit 3 set/clear - include/exclude final point
        MOV     R9, #0
        ADD     R10, WsPtr, #LineDotCnt

        TST     R11, #&10
        STRNE   R9, [WsPtr, #LineDotPtr]        ; Solid line
        STREQ   R10, [WsPtr, #LineDotPtr]       ; Dotted line

        TSTEQ   R11, #&20               ; If dotted line & first point included
        STREQ   R9, [WsPtr, #LineDotCnt] ; then force a restart of the pattern

        STR     R9, [WsPtr, #PostCycleCount]    ; Assume all dots get plotted

        ADD R0,WsPtr,#GCsIX             ;Start ICursor
        LDMIA R0,{R0,R1,R2,R3}          ;End NewPt

        TEQ     R1, R3                  ; If line is horizontal
        BEQ     TryHLine                ; try to use HLine
        [ UseVLineOnSolidLines
        TEQ     R0, R2                  ; If line is vertical
        BEQ     TryVLine                ; try to use VLine
CantUseVLine
        ]
CantUseHLineOrVLine
        SaveRetAdr

        Difference R4,R0,R2
        Difference R5,R1,R3
        Greatest R10,R4,R5
        ADD R10,R10,#1                  ;Total number of dots on line

        BL GenLineParm                  ;Generate line control block
                                        ; in R0..R8

        TST R11,#&20                    ;If first point excluded
        SUBNE R10,R10,#1                ; then dec DotCycleCount and
        BLNE AdvLineParm                ;      advance to first pixel and

        TST R11,#&08                    ;If last point excluded
        SUBEQ R10,R10,#1                ; then dec DotCycleCount

        CMP R10,#0                      ;IF DotCycleCount <= 0
        Return LE                       ; then nothing to plot

        STR R10,[WsPtr,#DotCycleCount]
        STR R11,[WsPtr,#LineEndPtFlags]

        WINDow R0,R1, R9,R10,R11,R14    ;If start point outside window
        BLLT LineStartsOutsideWindow    ; then panic {won't return if whole
                                        ;             line outside window}

        WINDow R7,R8, R9,R10,R11,R14    ;If end point outside window
        BLLT LineEndsOutsideWindow      ; then panic as well

;
; R0    ,R1    ,R2  ,R3    ,R4    ,R5   ,R6
; StartX,StartY,Bres,DeltaX,DeltaY,StepX,StepY
;

                                        ;Modify StepX (+1/-1 means right/left)
        CMP R5,#0                       ; to give PixelMask shift factor
        LDR R5,[WsPtr,#BytesPerChar]    ; "Left"
        RSBPL R5,R5,#0                  ; "Right"

                                        ;Modify StepY (+1/-1 means up/down)
        CMP R6,#0                       ; to give offset to next scan line
        LDR R6,[WsPtr,#LineLength]      ; "Down"
        RSBPL R6,R6,#0                  ; "Up"

        Push "R2-R6"                    ;Bres,DeltaX,DeltaY,StepX,StepY

        BL ScreenAddr
        MOV R7,R2                       ;Screen Adr
        MOV R8,R3                       ;Pixel Mask

        LDR R9,[WsPtr, #YWindLimit]
        SUB R9,R9,R1                    ;subtract Y from YWindLimit
        AND R9,R9,#7                    ;EcfIndx

        Pull "R2-R6"                    ;Bres,DeltaX,DeltaY,StepX,StepY

        LDR R0,[WsPtr,#DotCycleCount]   ;Number of on screen pixels
        CMP R0,#0                       ; An LPO line starting outside & ending
        Return LE                       ;  on the window leaves zero dots!

        LDR R1,[WsPtr,#LineDotPtr]
        CMP R1,#0
        BNE DotDashLine

SolidLine ROUT
        Push    R12
        LDR     R1, [WsPtr, #GColAdr]           ; Base address of ECF
        ADD     R1, R1, R9, LSL #3              ; current address of ECF
;
; R0    ,R1     ,R2  ,R3    ,R4    ,R5     ,R6     ,R7    ,R8  ,R9
; PixCnt,EcfBase,Bres,DeltaX,DeltaY,MskShft,LineStp,ScrAdr,Mask,Indx
;

        LDMIA   R1,  {R9, R10}                  ; R9 = zgora; R10 = zgeor
20
        MOV     R12, R8
30
        SUBS    R0, R0, #1                      ; Dec pixel count
        BEQ     %FT57                           ; if zero, then finish off

40
; Advance the screen address and pixel mask one pixel

        TEQ     R2, #0                  ; If Bres positive
        BPL     %FT55                   ; then advance in X dirn only
                                        ; else advance in Y direction, which
                                        ; may involve advancing X afterwards
45
        AND     R14, R9, R12                    ; R14 = zgora AND pixmask
 [ AvoidScreenReads
        CMP     R14, #&FFFFFFFF
        LDRNE   R11, [R7]                       ; R11 = word from screen
 |
        LDR     R11, [R7]                       ; R11 = word from screen
 ]
        ORR     R11, R11, R14                   ; OR with screen
        AND     R14, R10, R12                   ; R14 = zgeor AND pixmask
        EOR     R11, R11, R14                   ; EOR with screen
        STR     R11, [R7], R6                   ; and store back, moving on

        CMP     R6, #&80000000          ; C=1 => going up the screen
        TSTCS   R1, #63                 ; so check being at word 0 of ECF
        SUBCS   R1, R1, #8              ; and then subtract 2 words
        ADDCC   R1, R1, #8              ; else add on 2 words first
        TSTCC   R1, #63                 ; and then test for wrap
        BEQ     %FT60
        LDMIA   R1,  {R9, R10}          ; reload zgora and zgeor
        ADDS    R2, R2, R3              ; Advance Bres, in Y dirn

        BMI     %BT20                   ; [don't need to move in X direction]
50
        MOV     R12, #0                 ; clear total pixel mask
55
;
; Advance in X direction
;
        CMP     R5, #&80000000          ; if +ve then RORing, so test if
        TSTCC   R8, #1                  ; bottom bit set before shifting
        MOV     R8, R8, ROR R5          ; shift word
        TSTCS   R8, #1                  ; else test after shifting
        SUB     R2, R2, R4              ; always advance Bres in X direction
        ORREQ   R12, R12, R8            ; if not wrapped, OR in new pixel
        BEQ     %BT30                   ; and loop

57
 [ AvoidScreenReads
        TEQ     R12, #0
        BEQ     %FT58
 ]
        AND     R14, R9, R12                    ; R14 = zgora AND pixmask
 [ AvoidScreenReads
        MVNS    R11, R14
        LDRNE   R11, [R7]                       ; R11 = word from screen
 |
        LDR     R11, [R7]                       ; R11 = word from screen
 ]
        ORR     R11, R11, R14                   ; OR with screen
        AND     R14, R10, R12                   ; R14 = zgeor AND pixmask
        EOR     R11, R11, R14                   ; EOR with screen
 [ AvoidScreenReads
        STR     R11, [R7]                       ; and store back
58      SUBCC   R7, R7, #4                      ; increment or decrement
        ADDCS   R7, R7, #4
 |
        STRCC   R11, [R7], #-4                  ; and store back
        STRCS   R11, [R7], #4                   ; incrementing or decrementing
 ]

        MOV     R12, R8                 ; reset total pixel mask

        SUBS    R0, R0, #1
        Pull    "R12, PC", LT           ; exit if COMPLETELY finished
        BEQ     %BT57                   ; if no more to do, then output word!
        TEQ     R2, #0                  ; test Bres again
        BPL     %BT55
        B       %BT45


; come here when ECF wraps (ie every eight Y coords)

60
        ADDCS   R1, R1, #64             ; if wrap and going up, then add 64
        SUBCC   R1, R1, #64             ; if wrap and going down, subtract 64
        LDMIA   R1,  {R9, R10}          ; reload zgora and zgeor
        ADDS    R2, R2, R3              ; Advance Bres, in Y dirn
        BMI     %BT20                   ; [don't need to move in X direction]
        B       %BT50

; *****************************************************************************
;
;       TryHLine - Try to use HLine (we already know Y1=Y2)
;
; in:   R0 = X1
;       R1 = R3 = Y
;       R2 = X2
;       R11 = plot code EOR &18
;         bit 3 set => include last point
;         bit 4 set => solid
;         bit 5 set => exclude first point
;

TryHLine ROUT
        TST     R11, #&10               ; is it dotted
        BEQ     CantUseHLineOrVLine     ; yes, then can't use HLine

        CMP     R2, R0
        MOVGE   R4, #1
        MOVLT   R4, #-1
        TST     R11, #&20               ; if first point excluded
        ADDNE   R0, R0, R4              ; then move R0 one pixel towards R2
        TST     R11, #&08               ; if last point excluded
        SUBEQ   R2, R2, R4              ; then move R2 one pixel towards R0

        CMP     R2, R0                  ; check order again
        EORLT   R0, R0, R2              ; make sure R0 <= R2
        EORLT   R2, R0, R2
        EORLT   R0, R0, R2
        RSBLT   R4, R4, #0              ; if swapped, then invert sign of R4
        TEQNE   R4, #1                  ; if order is now different
                                        ; (and they're not equal now)
        MOVNE   PC, R14                 ; then there's nothing to plot
        B       NewHLine                ; else go and do it!

; *****************************************************************************
;
;       TryVLine - Try to use VLine (we already know X1=X2)
;
; in:   R0 = R2 = X
;       R1 = Y1
;       R3 = Y2
;       R11 = plot code EOR &18
;         bit 3 set => include last point
;         bit 4 set => solid
;         bit 5 set => exclude first point
;

TryVLine ROUT
        TST     R11, #&10               ; is it dotted
        BEQ     CantUseHLineOrVLine     ; yes, then can't use VLine (or HLine)

; now make sure that we are using a solid pattern (not an ECF)
; this is true if the appropriate GCOL action is < 8

        AND     R4, R11, #3             ; look at bottom 2 bits of R11
        CMP     R4, #2                  ; to check which action
                                        ; (already ruled out 0 (no action))
        LDRCC   R4, [WsPtr, #GPLFMD]    ; <2 => 1 => foreground action
        MOVEQ   R4, #4                  ; =2 => 2 => invert action
        LDRHI   R4, [WsPtr, #GPLBMD]    ; >2 => 3 => background action
        CMP     R4, #8                  ; is it a solid action
        BCS     CantUseVLine

        CMP     R3, R1
        MOVGE   R4, #1
        MOVLT   R4, #-1
        TST     R11, #&20               ; if first point excluded
        ADDNE   R1, R1, R4              ; then move R1 one pixel towards R3
        TST     R11, #&08               ; if last point excluded
        SUBEQ   R3, R3, R4              ; then move R3 one pixel towards R1

        CMP     R3, R1                  ; check order again
        EORLT   R1, R1, R3              ; make sure R1 <= R3
        EORLT   R3, R1, R3
        EORLT   R1, R1, R3
        RSBLT   R4, R4, #0              ; if swapped, then invert sign of R4
        TEQNE   R4, #1                  ; if order is now different
                                        ; (and they're not equal now)
        MOVNE   PC, R14                 ; then there's nothing to plot
        B       NewVLine                ; else go and do it!


;
;
;
DotDashLine

;
; R0    ,R1    ,R2  ,R3    ,R4    ,R5     ,R6     ,R7    ,R8  ,R9
; PixCnt,DotPtr,Bres,DeltaX,DeltaY,MskShft,LineStp,ScrAdr,Mask,Indx
;

DotDash20
        LDMIA R1,{rDOTCnt,rDOTPatLSW,rDOTPatMSW}

        CMP rDOTCnt,#0

        ADDEQ rDOTCnt,WsPtr,#DotLineStyle               ;Restart pattern
        LDMEQIA rDOTCnt,{rDOTPatLSW,rDOTPatMSW}
        LDREQ rDOTCnt,[WsPtr,#DotLineLength]

        SUB rDOTCnt,rDOTCnt,#1

        MOVS rDOTPatMSW,rDOTPatMSW,LSL #1
        ORR rDOTPatMSW,rDOTPatMSW,rDOTPatLSW,LSR #31
        MOV rDOTPatLSW,rDOTPatLSW,LSL #1

        STMIA R1,{rDOTCnt,rDOTPatLSW,rDOTPatMSW}

        BCC DotDash30                           ;Don't plot this dot

        LDR R10,[WsPtr,#GColAdr]                ;Base address of ECF
        ADD R10,R10,R9,LSL #3                   ;Address of ECFora & ECFeor
        WriteToScreen R7,R8,R10, R10,R11,R14

DotDash30
        SUBS R0,R0,#1                           ;Dec pixel count
        BEQ DotDash60                           ;Finished on screen

DotDash40
;
; Advance the screen address and pixel mask one pixel
;

        CMP R2,#0               ;If Bres positive
        BPL DotDash50           ;then advance in X dirn only
                                ;else advance in Y direction, which may
                                ;     involve advancement in X afterwards

        CMP R6,#0               ;Advance Ecf to next scanline
        SUBLT R9,R9,#1          ; "Up" = (Old-1) Mod 7
        ADDGE R9,R9,#1          ; "Doun" = (Old+1) Mod 7
        AND R9,R9,#7

        ADD R7,R7,R6                    ;Advance screen address one scanline

        ADDS R2,R2,R3                   ;Advance Bres, in Y dirn
        BMI DotDash20                   ;
                                        ; may now need advancing in X dirn
DotDash50
;
; Advance in X direction
;
; Rotate PixMsk to next pixel position, altering ScrAdr if we cross to
;  the next word.
;

        TST     R8, R5                  ;If PixMsk at MSEnd of word
                                        ; and shifting left
        ADDMI   R7, R7, #4              ;then inc ScrAdr  {PixMsk will wrap}

        MOVS    R8, R8, ROR R5          ;Move PixMsk

                                        ;If PixMsk now at MSEnd of word
        RSBMIS  R11, R5, #0             ; and shift was right
        SUBMI   R7, R7, #4              ;then dec ScrAdr  {PixMsk wrapped}

        SUB     R2, R2, R4              ;Advance Bres, in X dirn
        B       DotDash20

DotDash60

        LDR R0,[WsPtr,#PostCycleCount]
        CMP R0,#0
        BLNE AdvanceDotPattern

        Return

        LTORG

 DCD 0 ; *** Inserted for diagnostic purposes !  ***

;
;
;
;------------------------------------------------------------------------------
;
; LineEndsOutSideWindow
; =====================
;
LineEndsOutsideWindow

        Push "R0-R8,Link"       ;Push whole parameter block

        ADD R0,WsPtr,#GCsIX             ;Start ICursor
        LDMIA R0,{R0,R1,R2,R3}          ;End NewPt
        Swap R0,R2
        Swap R1,R3

        BL GenLineParm                  ;Generate line control block
                                        ; in R0..R8
        LDR R11,[WsPtr,#LineEndPtFlags]

        TST R11,#&08                    ;If last point excluded
        BLEQ AdvLineParm                ; then advance to actual last point

        Push "R0,R1"                    ;EndX,EndY

        WindowRes R11,R0,R1, R7,R8,R9,R10       ;R11 := Window(End)

;
; R0  ,R1  ,R2  ,R3    ,R4    ,R5   ,R6   ,        ,R11
; EndX,EndY,Bres,DeltaX,DeltaY,StepX,StepY,        ,WEnd
;

        TST R11,#&C                             ;If above/below window
        BEQ LEO10

        BL InYWind                              ; then bring Y into window

        WindowRes R11,R0,R1, R7,R8,R9,R10       ;R11 := Window(NewEnd)

LEO10
        TST R11,#&3
        BEQ LEO20                       ;If start outside X window

        BL InXWind

        WindowRes R11,R0,R1, R7,R8,R9,R10       ;R11 := Window(NewEnd)

LEO20
        Pull "R9,R10"                           ;EndX,EndY

        Difference R0,R0,R9
        Difference R1,R1,R10
        Greatest R0,R0,R1

        LDR R1,[WsPtr,#DotCycleCount]
        SUB R1,R1,R0
        STR R1,[WsPtr,#DotCycleCount]
        STR R0,[WsPtr,#PostCycleCount]

        Pull "R0-R8,PC"
;
;
;
;------------------------------------------------------------------------------
;
; LineStartsOutSideWindow
; =======================
;
LineStartsOutsideWindow

        Push Link
        Push "R0,R1"                    ;StartX,StartY

        Push "R5,R6"
        WindowRes R10,R0,R1, R5,R6,R9,R14       ;R10 := Window(Start)
        WindowRes R11,R7,R8, R5,R6,R9,R14       ;R11 := Window(End)
        Pull "R5,R6"

        TST R10,R11
        BNE LineOutsideWindow           ;Line completely outside window


;
; R0    ,R1    ,R2  ,R3    ,R4    ,R5   ,R6   ,R7  ,R8    ,R10   ,R11
; StartX,StartY,Bres,DeltaX,DeltaY,StepX,StepY,EndX,EndY  ,WStart,WEnd
;

        TST R10,#&C                             ;If above/below window
        BEQ LSO10

        Push R11
        BL InYWind                              ; then bring Y into window
        Pull R11

        Push "R6-R8"
        WindowRes R10,R0,R1, R6,R7,R8,R9       ;R10 := Window(NewStart)
        Pull "R6-R8"

        TST R10,R11
        BNE LineOutsideWindow           ;Line completely outside window
LSO10
        TST R10,#&3
        BEQ LSO20                       ;If start outside X window

        Push R11
        BL InXWind
        Pull R11

        Push "R6-R8"
        WindowRes R10,R0,R1, R6,R7,R8,R9        ;R10 := Window(NewStart)
        Pull "R6-R8"
        CMP R10,#0

        BNE LineOutsideWindow           ;Cannot clip to window
LSO20
        Pull "R9,R10"           ;StartX,StartY

        Push "R0-R8"
        Difference R0,R0,R9
        Difference R1,R1,R10
        Greatest R0,R0,R1
        BL AdvanceDotPattern
        Pull "R0-R8"

        Pull "PC"


LineOutsideWindow
        Pull "R0,R1"                    ;Balance the stack
        LDR R0,[WsPtr,#DotCycleCount]
        BL AdvanceDotPattern

        Pull "Link"
        Return                          ;To caller of the line routine
;
;
;
;------------------------------------------------------------------------------
;


lpStartX  RN 0
lpStartY  RN 1
lpBres    RN 2
lpDeltaX  RN 3
lpDeltaY  RN 4
lpStepX   RN 5
lpStepY   RN 6






;
; InYWind - Bring a set of line parameters into the Y window
; =======
;
; On entry, R0-R6 contain a line parameter block
;       R0 - StartX
;       R1 - StartY
;       R2 - Bres
;       R3 - DeltaX
;       R4 - DeltaY
;       R5 - StepX (+1/-1) (Equv bit6 of Sign in 6502 version)
;       R6 - StepY (+1/-1) (Equv bit7 of Sign in 6502 version)
;       R7 - EndX
;       R8 - EndY
;
;       R9  - gwbrow
;       R10 - gwtrow
;
; Algorithm:
;  1. Calculate distance to Y window
;  2. Change StartY by (distance-1)
;  3. Add (distance-1)*DeltaX to Bres
;  4. Divide Bres by DeltaY
;  5. Subtract (quotient+1)*DeltaY from Bres
;  6. Change StartX by (quotient+1)
;  7. Do one more pixel advance by AdvLineParm
;      (N.B. this is always the Bres -ve case)
;
;
;
InYWind
        SaveRetAdr

        LDR R9,[WsPtr,#GWBRow]
        LDR R10,[WsPtr,#GWTRow]
                                        ;(1)
        CMP lpStepY,#0
        SUBGE R11,R9,lpStartY
        SUBLT R11,lpStartY,R10
        SUB R11,R11,#1                  ;(Distance to window) - 1

        BL InYW30                       ;Steps 2-6

        BL AdvLineParm                  ;Step to first pixel in window
        Return
;
; Flags still valid, GE/LT
;
; R11 holds distance to window -1
;
InYW30                                  ;(2)
        ADDGE lpStartY,lpStartY,R11             ;StartY := GWBRow-1
        SUBLT lpStartY,lpStartY,R11             ;StartY := GWTRow+1
                                        ;(3)
        MOV R10,lpDeltaX
        MUL R9,R11,R10
        ADDS lpBres,lpBres,R9                   ;Bres := Bres+(dist-1)*DeltaX

                                                ;If lpBres now -ve,
        MOVLT PC,Link                           ;then don't modify StartX
                                                ;     (quotient+1 is 0)
                                                ;else
        MOV R10,lpDeltaY
; *****Change made by DJS
; Use new DivRem macro, not old DIVREM
; Original code was:
;        DIVREM R11,lpBres,R10,R9
        DivRem R11,lpBres,R10,R9
; *****End of change made by DJS
        SUB lpBres,lpBres,lpDeltaY

        ADD R11,R11,#1                          ; quotient := 1+bres/deltay
                                        ;(6)
        CMP lpStepX,#0
        ADDGE lpStartX,lpStartX,R11
        SUBLT lpStartX,lpStartX,R11

        MOV PC,Link




;
; InXWind - Bring a set of line parametres into the X window
; =======
;
; On entry, R0-R6 contain a line parameter block
;       R0 - StartX
;       R1 - StartY
;       R2 - Bres
;       R3 - DeltaX
;       R4 - DeltaY
;       R5 - StepX (+1/-1) (Equv bit6 of Sign in 6502 version)
;       R6 - StepY (+1/-1) (Equv bit7 of Sign in 6502 version)
;       R7 - EndX
;       R8 - EndY
;
;       R9  - gwlcol
;       R10 - gwrcol
;
; Algorithm:
;  1. Replace Bres by -Bres-1
;  2. Swap StartX and StartY
;  3. Swap DeltaX and DeltaY
;  3a Swap StepX and StepY
;  4. Calculate distance to X window
;  5. Do steps 2-6 of InYWind
;  6. Repeat steps 1-3
;  7. Do one more pixel advance by AdvLineParm
;      (N.B. this is always the Bres +ve case)
;
InXWind
        SaveRetAdr

        LDR R9,[WsPtr,#GWLCol]
        LDR R10,[WsPtr,#GWRCol]
                                        ;(1)
        MVN lpBres,lpBres
                                        ;(2)(3)
        Push "lpStartX,lpDeltaX,lpStepX"
        Push "lpStartY,lpDeltaY,lpStepY"
        Pull "lpStartX,lpDeltaX,lpStepX"
        Pull "lpStartY,lpDeltaY,lpStepY"

        CMP lpStepY,#0                  ;Really StepX
        SUBGE R11,R9,lpStartY
        SUBLT R11,lpStartY,R10
        SUB R11,R11,#1                  ;(Distance to window) - 1

        BL InYW30                               ;Steps 2-6
                                        ;(1)
        MVN lpBres,lpBres
                                        ;(2)(3)
        Push "lpStartX,lpDeltaX,lpStepX"
        Push "lpStartY,lpDeltaY,lpStepY"
        Pull "lpStartX,lpDeltaX,lpStepX"
        Pull "lpStartY,lpDeltaY,lpStepY"

        BL AdvLineParm                  ;Step to first pixel in window
        Return




;
; rDotPtr    RN 7
; rDotCnt    RN 9
; rDotPatLSW RN 10
; rDotPatMSW RN 11

;
; On entry R0 holds number of places to step dot pattern
;
AdvanceDotPattern
        LDR R1,[WsPtr,#DotCycleCount]
        SUB R1,R1,R0
        STR R1,[WsPtr,#DotCycleCount]

        LDR rDotPtr,[WsPtr,#LineDotPtr]
        CMP rDotPtr,#0
        MOVEQ PC,Link

        LDR R1,[WsPtr,#DotLineLength]
        MOV R2,R1
; *****Change made by DJS
; Use new DivRem macro, not old DIVREM
; Original code was:
;        DIVREM R3,R0,R2,R4              ;R0:=R0 REM DotLineLength
        DivRem R3,R0,R2,R4              ;R0:=R0 REM DotLineLength
; *****End of change made by DJS

        LDMIA rDotPtr,{rDotCnt,rDotPatLSW,rDotPatMSW}

        CMP rDotCnt,R0
        SUBLT R0,R0,rDotCnt

        ADDLT rDotCnt,WsPtr,#DotLineStyle               ;Restart pattern
        LDMLTIA rDotCnt,{rDotPatLSW,rDotPatMSW}
        LDRLT rDotCnt,[WsPtr,#DotLineLength]

        SUB rDotCnt,rDotCnt,R0                          ;New value

 [ {TRUE}

; need special code if R0 > 32

        RSBS    R1, R0, #32
        MOVLT   rDotPatMSW, rDotPatLSW
        MOVLT   rDotPatLSW, #0                          ; probably not necessary
        SUBLT   R0, R0, #32
        RSBLT   R1, R0, #32

        MOV rDotPatMSW,rDotPatMSW,LSL R0
        ORR rDotPatMSW,rDotPatMSW,rDotPatLSW,LSR R1
        MOV rDotPatLSW,rDotPatLSW,LSL R0
 |

; old code

        RSB R1,R0,#32
        MOV rDotPatMSW,rDotPatMSW,LSL R0
        ORR rDotPatMSW,rDotPatMSW,rDotPatLSW,LSR R1
        MOV rDotPatLSW,rDotPatLSW,LSL R0
 ]

        STMIA rDotPtr,{rDotCnt,rDotPatLSW,rDotPatMSW}

        MOV PC,Link
;
;---------------------------------------------------------------------------
;

        END
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d106 4
d111 1
d287 4
d292 1
d323 4
d328 4
d333 1
d337 5
d344 1
d355 1
@


4.2.2.1
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a105 4
 [ AvoidScreenReads
        CMP $a,#&FFFFFFFF
        LDRNE $c,[$Adr]
 |
a106 1
 ]
a281 4
 [ AvoidScreenReads
        CMP     R14, #&FFFFFFFF
        LDRNE   R11, [R7]                       ; R11 = word from screen
 |
a282 1
 ]
a312 4
 [ AvoidScreenReads
        TEQ     R12, #0
        BEQ     %FT58
 ]
a313 4
 [ AvoidScreenReads
 	MVNS	R11, R14
        LDRNE   R11, [R7]                       ; R11 = word from screen
 |
a314 1
 ]
a317 5
 [ AvoidScreenReads
        STR     R11, [R7]                       ; and store back
58      SUBCC   R7, R7, #4                      ; increment or decrement
        ADDCS   R7, R7, #4
 |
a319 1
 ]
a328 1

@


4.2.2.2
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d329 1
a329 1
        MVNS    R11, R14
@


4.1
log
@Initial revision
@
text
@d73 1
a73 1
        CMP R2,#0            
d203 2
a204 2
        BLNE AdvLineParm                ; then advance to first pixel and
        SUBNE R10,R10,#1                ;      dec DotCycleCount
d223 1
a223 1
; R0    ,R1    ,R2  ,R3    ,R4    ,R5   ,R6   
d539 1
a539 1
        WindowRes R11,R0,R1, R7,R8,R9,R10       ;R11 := Window(End) 
d589 1
a589 1
        WindowRes R11,R7,R8, R5,R6,R9,R14       ;R11 := Window(End) 
d682 1
a682 1
;       
d861 1
a861 1
        ORR rDotPatMSW,rDotPatMSW,rDotPatLSW,LSR R1 
d869 1
a869 1
        ORR rDotPatMSW,rDotPatMSW,rDotPatLSW,LSR R1 
d875 1
a875 1
        MOVS PC,Link
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d850 1
d863 9
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.6;
access;
symbols
	Kernel-6_15:4.6
	Kernel-6_14:4.6
	Kernel-6_01-3:4.6
	Kernel-6_13:4.6
	Kernel-6_12:4.6
	Kernel-6_11:4.6
	Kernel-6_10:4.6
	Kernel-6_09:4.6
	Kernel-6_08-4_129_2_10:4.6
	Kernel-6_08-4_129_2_9:4.6
	Kernel-6_08:4.6
	Kernel-6_07:4.6
	Kernel-6_06:4.6
	Kernel-6_05-4_129_2_8:4.6
	Kernel-6_05:4.6
	Kernel-6_04:4.6
	Kernel-6_03:4.6
	Kernel-6_01-2:4.6
	Kernel-6_01-4_146_2_1:4.6
	Kernel-6_02:4.6
	Kernel-6_01-1:4.6
	Kernel-6_01:4.6
	Kernel-6_00:4.6
	Kernel-5_99:4.6
	Kernel-5_98:4.6
	Kernel-5_97-4_129_2_7:4.6
	Kernel-5_97:4.6
	Kernel-5_96:4.6
	Kernel-5_95:4.6
	Kernel-5_94:4.6
	Kernel-5_93:4.6
	Kernel-5_92:4.6
	Kernel-5_91:4.6
	Kernel-5_90:4.6
	Kernel-5_89-4_129_2_6:4.6
	Kernel-5_89:4.6
	Kernel-5_88-4_129_2_5:4.6
	Kernel-5_88-4_129_2_4:4.6
	Kernel-5_88:4.6
	Kernel-5_87:4.6
	Kernel-5_86-4_129_2_3:4.6
	Kernel-5_86-4_129_2_2:4.6
	Kernel-5_86-4_129_2_1:4.6
	Kernel-5_86:4.6
	SMP:4.6.0.2
	SMP_bp:4.6
	Kernel-5_85:4.6
	Kernel-5_54-1:4.5
	Kernel-5_84:4.6
	Kernel-5_83:4.6
	Kernel-5_82:4.6
	Kernel-5_81:4.6
	Kernel-5_80:4.6
	Kernel-5_79:4.6
	Kernel-5_78:4.6
	Kernel-5_77:4.6
	Kernel-5_76:4.6
	Kernel-5_75:4.6
	Kernel-5_74:4.6
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.5
	Kernel-5_64:4.5
	Kernel-5_63:4.5
	Kernel-5_62:4.5
	Kernel-5_61:4.5
	Kernel-5_60:4.5
	Kernel-5_59:4.5
	Kernel-5_58:4.5
	Kernel-5_57:4.5
	Kernel-5_56:4.5
	Kernel-5_55:4.5
	Kernel-5_54:4.5
	Kernel-5_53:4.5
	Kernel-5_52:4.5
	Kernel-5_51:4.5
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.3.2.9
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.3.2.9
	Kernel-5_35-4_79_2_326:4.3.2.9
	Kernel-5_35-4_79_2_325:4.3.2.9
	Kernel-5_35-4_79_2_324:4.3.2.9
	Kernel-5_35-4_79_2_323:4.3.2.9
	Kernel-5_35-4_79_2_322:4.3.2.9
	Kernel-5_35-4_79_2_321:4.3.2.9
	Kernel-5_35-4_79_2_320:4.3.2.9
	Kernel-5_35-4_79_2_319:4.3.2.9
	Kernel-5_35-4_79_2_318:4.3.2.9
	Kernel-5_35-4_79_2_317:4.3.2.9
	Kernel-5_35-4_79_2_316:4.3.2.9
	Kernel-5_35-4_79_2_315:4.3.2.9
	Kernel-5_35-4_79_2_314:4.3.2.9
	Kernel-5_35-4_79_2_313:4.3.2.9
	Kernel-5_35-4_79_2_312:4.3.2.9
	Kernel-5_35-4_79_2_311:4.3.2.9
	Kernel-5_35-4_79_2_310:4.3.2.9
	Kernel-5_35-4_79_2_309:4.3.2.9
	Kernel-5_35-4_79_2_308:4.3.2.9
	Kernel-5_35-4_79_2_307:4.3.2.9
	Kernel-5_35-4_79_2_306:4.3.2.9
	Kernel-5_35-4_79_2_305:4.3.2.9
	Kernel-5_35-4_79_2_304:4.3.2.9
	Kernel-5_35-4_79_2_303:4.3.2.9
	Kernel-5_35-4_79_2_302:4.3.2.9
	Kernel-5_35-4_79_2_301:4.3.2.9
	Kernel-5_35-4_79_2_300:4.3.2.9
	Kernel-5_35-4_79_2_299:4.3.2.9
	Kernel-5_35-4_79_2_298:4.3.2.9
	Kernel-5_35-4_79_2_297:4.3.2.9
	Kernel-5_35-4_79_2_296:4.3.2.9
	Kernel-5_35-4_79_2_295:4.3.2.9
	Kernel-5_35-4_79_2_294:4.3.2.9
	Kernel-5_35-4_79_2_293:4.3.2.9
	Kernel-5_35-4_79_2_292:4.3.2.9
	Kernel-5_35-4_79_2_291:4.3.2.9
	Kernel-5_35-4_79_2_290:4.3.2.9
	Kernel-5_35-4_79_2_289:4.3.2.9
	Kernel-5_35-4_79_2_288:4.3.2.9
	Kernel-5_35-4_79_2_287:4.3.2.9
	Kernel-5_35-4_79_2_286:4.3.2.9
	Kernel-5_35-4_79_2_285:4.3.2.9
	Kernel-5_35-4_79_2_284:4.3.2.9
	Kernel-5_35-4_79_2_283:4.3.2.9
	Kernel-5_35-4_79_2_282:4.3.2.9
	Kernel-5_35-4_79_2_281:4.3.2.9
	Kernel-5_35-4_79_2_280:4.3.2.9
	Kernel-5_35-4_79_2_279:4.3.2.9
	Kernel-5_35-4_79_2_278:4.3.2.9
	Kernel-5_35-4_79_2_277:4.3.2.9
	Kernel-5_35-4_79_2_276:4.3.2.9
	Kernel-5_35-4_79_2_275:4.3.2.9
	Kernel-5_35-4_79_2_274:4.3.2.9
	Kernel-5_35-4_79_2_273:4.3.2.9
	Kernel-5_35-4_79_2_272:4.3.2.9
	Kernel-5_35-4_79_2_271:4.3.2.9
	Kernel-5_35-4_79_2_270:4.3.2.9
	Kernel-5_35-4_79_2_269:4.3.2.9
	Kernel-5_35-4_79_2_268:4.3.2.9
	Kernel-5_35-4_79_2_267:4.3.2.9
	Kernel-5_35-4_79_2_266:4.3.2.9
	Kernel-5_35-4_79_2_265:4.3.2.9
	Kernel-5_35-4_79_2_264:4.3.2.9
	Kernel-5_35-4_79_2_263:4.3.2.9
	Kernel-5_35-4_79_2_262:4.3.2.9
	Kernel-5_35-4_79_2_261:4.3.2.9
	Kernel-5_35-4_79_2_260:4.3.2.9
	Kernel-5_35-4_79_2_259:4.3.2.9
	Kernel-5_35-4_79_2_258:4.3.2.9
	Kernel-5_35-4_79_2_257:4.3.2.9
	Kernel-5_35-4_79_2_256:4.3.2.9
	Kernel-5_35-4_79_2_255:4.3.2.9
	Kernel-5_35-4_79_2_254:4.3.2.9
	Kernel-5_35-4_79_2_253:4.3.2.9
	Kernel-5_35-4_79_2_252:4.3.2.9
	Kernel-5_35-4_79_2_251:4.3.2.9
	Kernel-5_35-4_79_2_250:4.3.2.9
	Kernel-5_35-4_79_2_249:4.3.2.9
	Kernel-5_35-4_79_2_248:4.3.2.9
	Kernel-5_35-4_79_2_247:4.3.2.9
	Kernel-5_35-4_79_2_246:4.3.2.9
	Kernel-5_35-4_79_2_245:4.3.2.9
	Kernel-5_35-4_79_2_244:4.3.2.9
	Kernel-5_35-4_79_2_243:4.3.2.9
	Kernel-5_35-4_79_2_242:4.3.2.9
	Kernel-5_35-4_79_2_241:4.3.2.9
	Kernel-5_35-4_79_2_240:4.3.2.9
	Kernel-5_35-4_79_2_239:4.3.2.9
	Kernel-5_35-4_79_2_238:4.3.2.9
	Kernel-5_35-4_79_2_237:4.3.2.9
	Kernel-5_35-4_79_2_236:4.3.2.9
	Kernel-5_35-4_79_2_235:4.3.2.9
	Kernel-5_35-4_79_2_234:4.3.2.9
	Kernel-5_35-4_79_2_233:4.3.2.9
	Kernel-5_35-4_79_2_232:4.3.2.9
	Kernel-5_35-4_79_2_231:4.3.2.9
	Kernel-5_35-4_79_2_230:4.3.2.9
	Kernel-5_35-4_79_2_229:4.3.2.9
	Kernel-5_35-4_79_2_228:4.3.2.9
	Kernel-5_35-4_79_2_227:4.3.2.9
	Kernel-5_35-4_79_2_226:4.3.2.9
	Kernel-5_35-4_79_2_225:4.3.2.9
	Kernel-5_35-4_79_2_224:4.3.2.9
	Kernel-5_35-4_79_2_223:4.3.2.9
	Kernel-5_35-4_79_2_222:4.3.2.9
	Kernel-5_35-4_79_2_221:4.3.2.9
	Kernel-5_35-4_79_2_220:4.3.2.9
	Kernel-5_35-4_79_2_219:4.3.2.9
	Kernel-5_35-4_79_2_218:4.3.2.9
	Kernel-5_35-4_79_2_217:4.3.2.9
	Kernel-5_35-4_79_2_216:4.3.2.9
	Kernel-5_35-4_79_2_215:4.3.2.9
	Kernel-5_35-4_79_2_214:4.3.2.9
	Kernel-5_35-4_79_2_213:4.3.2.9
	Kernel-5_35-4_79_2_212:4.3.2.9
	Kernel-5_35-4_79_2_211:4.3.2.9
	Kernel-5_35-4_79_2_210:4.3.2.9
	Kernel-5_35-4_79_2_209:4.3.2.9
	Kernel-5_35-4_79_2_208:4.3.2.9
	Kernel-5_35-4_79_2_207:4.3.2.9
	Kernel-5_35-4_79_2_206:4.3.2.9
	Kernel-5_35-4_79_2_205:4.3.2.9
	Kernel-5_35-4_79_2_204:4.3.2.9
	Kernel-5_35-4_79_2_203:4.3.2.9
	Kernel-5_35-4_79_2_202:4.3.2.8
	Kernel-5_35-4_79_2_201:4.3.2.8
	Kernel-5_35-4_79_2_200:4.3.2.8
	Kernel-5_35-4_79_2_199:4.3.2.8
	Kernel-5_35-4_79_2_198:4.3.2.8
	Kernel-5_35-4_79_2_197:4.3.2.8
	Kernel-5_35-4_79_2_196:4.3.2.8
	Kernel-5_35-4_79_2_195:4.3.2.8
	Kernel-5_35-4_79_2_194:4.3.2.8
	Kernel-5_35-4_79_2_193:4.3.2.7
	Kernel-5_35-4_79_2_192:4.3.2.7
	Kernel-5_35-4_79_2_191:4.3.2.7
	Kernel-5_35-4_79_2_190:4.3.2.7
	Kernel-5_35-4_79_2_189:4.3.2.7
	Kernel-5_35-4_79_2_188:4.3.2.7
	Kernel-5_35-4_79_2_187:4.3.2.7
	Kernel-5_35-4_79_2_186:4.3.2.7
	Kernel-5_35-4_79_2_185:4.3.2.7
	Kernel-5_35-4_79_2_184:4.3.2.7
	Kernel-5_35-4_79_2_183:4.3.2.7
	Kernel-5_35-4_79_2_182:4.3.2.7
	Kernel-5_35-4_79_2_181:4.3.2.7
	Kernel-5_35-4_79_2_180:4.3.2.7
	Kernel-5_35-4_79_2_179:4.3.2.7
	Kernel-5_35-4_79_2_178:4.3.2.7
	Kernel-5_35-4_79_2_177:4.3.2.7
	Kernel-5_35-4_79_2_176:4.3.2.7
	Kernel-5_35-4_79_2_175:4.3.2.7
	Kernel-5_35-4_79_2_174:4.3.2.7
	Kernel-5_35-4_79_2_173:4.3.2.7
	Kernel-5_35-4_79_2_172:4.3.2.7
	Kernel-5_35-4_79_2_171:4.3.2.7
	Kernel-5_35-4_79_2_170:4.3.2.7
	Kernel-5_35-4_79_2_169:4.3.2.7
	Kernel-5_35-4_79_2_168:4.3.2.7
	Kernel-5_35-4_79_2_167:4.3.2.7
	Kernel-5_35-4_79_2_166:4.3.2.7
	Kernel-5_35-4_79_2_165:4.3.2.7
	RPi_merge:4.3.2.5.2.1
	Kernel-5_35-4_79_2_147_2_23:4.3.2.5.2.1
	Kernel-5_35-4_79_2_147_2_22:4.3.2.5
	Kernel-5_35-4_79_2_147_2_21:4.3.2.5
	Kernel-5_35-4_79_2_147_2_20:4.3.2.5
	Kernel-5_35-4_79_2_147_2_19:4.3.2.5
	Kernel-5_35-4_79_2_147_2_18:4.3.2.5
	Kernel-5_35-4_79_2_164:4.3.2.7
	Kernel-5_35-4_79_2_163:4.3.2.7
	Kernel-5_35-4_79_2_147_2_17:4.3.2.5
	Kernel-5_35-4_79_2_147_2_16:4.3.2.5
	Kernel-5_35-4_79_2_147_2_15:4.3.2.5
	Kernel-5_35-4_79_2_162:4.3.2.7
	Kernel-5_35-4_79_2_161:4.3.2.7
	Kernel-5_35-4_79_2_147_2_14:4.3.2.5
	Kernel-5_35-4_79_2_147_2_13:4.3.2.5
	Kernel-5_35-4_79_2_160:4.3.2.7
	Kernel-5_35-4_79_2_159:4.3.2.7
	Kernel-5_35-4_79_2_158:4.3.2.6
	Kernel-5_35-4_79_2_157:4.3.2.6
	Kernel-5_35-4_79_2_156:4.3.2.6
	Kernel-5_35-4_79_2_147_2_12:4.3.2.5
	Kernel-5_35-4_79_2_147_2_11:4.3.2.5
	Kernel-5_35-4_79_2_155:4.3.2.6
	Kernel-5_35-4_79_2_147_2_10:4.3.2.5
	Kernel-5_35-4_79_2_154:4.3.2.6
	Kernel-5_35-4_79_2_153:4.3.2.6
	Kernel-5_35-4_79_2_147_2_9:4.3.2.5
	Kernel-5_35-4_79_2_152:4.3.2.6
	Kernel-5_35-4_79_2_151:4.3.2.6
	Kernel-5_35-4_79_2_147_2_8:4.3.2.5
	Kernel-5_35-4_79_2_147_2_7:4.3.2.5
	Kernel-5_35-4_79_2_150:4.3.2.6
	Kernel-5_35-4_79_2_147_2_6:4.3.2.5
	Kernel-5_35-4_79_2_147_2_5:4.3.2.5
	Kernel-5_35-4_79_2_149:4.3.2.5
	Kernel-5_35-4_79_2_147_2_4:4.3.2.5
	Kernel-5_35-4_79_2_147_2_3:4.3.2.5
	Kernel-5_35-4_79_2_148:4.3.2.5
	Kernel-5_35-4_79_2_147_2_2:4.3.2.5
	Kernel-5_35-4_79_2_147_2_1:4.3.2.5
	RPi:4.3.2.5.0.2
	RPi_bp:4.3.2.5
	Kernel-5_35-4_79_2_98_2_52_2_1:4.3.2.3.2.3
	alees_Kernel_dev:4.3.2.3.2.3.0.2
	alees_Kernel_dev_bp:4.3.2.3.2.3
	Kernel-5_35-4_79_2_147:4.3.2.5
	Kernel-5_35-4_79_2_146:4.3.2.5
	Kernel-5_35-4_79_2_145:4.3.2.5
	Kernel-5_35-4_79_2_144:4.3.2.5
	Kernel-5_35-4_79_2_143:4.3.2.5
	Kernel-5_35-4_79_2_142:4.3.2.5
	Kernel-5_35-4_79_2_141:4.3.2.5
	Kernel-5_35-4_79_2_140:4.3.2.5
	Kernel-5_35-4_79_2_139:4.3.2.5
	Kernel-5_35-4_79_2_138:4.3.2.5
	Kernel-5_35-4_79_2_137:4.3.2.5
	Kernel-5_35-4_79_2_136:4.3.2.5
	Kernel-5_35-4_79_2_135:4.3.2.5
	Kernel-5_35-4_79_2_134:4.3.2.5
	Kernel-5_35-4_79_2_133:4.3.2.5
	Kernel-5_35-4_79_2_132:4.3.2.5
	Kernel-5_35-4_79_2_131:4.3.2.5
	Kernel-5_35-4_79_2_130:4.3.2.5
	Kernel-5_35-4_79_2_129:4.3.2.5
	Kernel-5_35-4_79_2_128:4.3.2.5
	Kernel-5_35-4_79_2_127:4.3.2.5
	Kernel-5_35-4_79_2_126:4.3.2.4
	Kernel-5_35-4_79_2_125:4.3.2.4
	Kernel-5_35-4_79_2_124:4.3.2.4
	Kernel-5_35-4_79_2_123:4.3.2.4
	Cortex_merge:4.3.2.3.2.3
	Kernel-5_35-4_79_2_122:4.3.2.3
	Kernel-5_35-4_79_2_98_2_54:4.3.2.3.2.3
	Kernel-5_35-4_79_2_98_2_53:4.3.2.3.2.3
	Kernel-5_35-4_79_2_98_2_52:4.3.2.3.2.3
	Kernel-5_35-4_79_2_98_2_51:4.3.2.3.2.3
	Kernel-5_35-4_79_2_98_2_50:4.3.2.3.2.3
	Kernel-5_35-4_79_2_98_2_49:4.3.2.3.2.3
	Kernel-5_35-4_79_2_98_2_48:4.3.2.3.2.3
	Kernel-5_35-4_79_2_121:4.3.2.3
	Kernel-5_35-4_79_2_98_2_47:4.3.2.3.2.2
	Kernel-5_35-4_79_2_120:4.3.2.3
	Kernel-5_35-4_79_2_98_2_46:4.3.2.3.2.2
	Kernel-5_35-4_79_2_119:4.3.2.3
	Kernel-5_35-4_79_2_98_2_45:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_44:4.3.2.3.2.2
	Kernel-5_35-4_79_2_118:4.3.2.3
	Kernel-5_35-4_79_2_98_2_43:4.3.2.3.2.2
	Kernel-5_35-4_79_2_117:4.3.2.3
	Kernel-5_35-4_79_2_116:4.3.2.3
	Kernel-5_35-4_79_2_98_2_42:4.3.2.3.2.2
	Kernel-5_35-4_79_2_115:4.3.2.3
	Kernel-5_35-4_79_2_98_2_41:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_40:4.3.2.3.2.2
	Kernel-5_35-4_79_2_114:4.3.2.3
	Kernel-5_35-4_79_2_98_2_39:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_38:4.3.2.3.2.2
	Kernel-5_35-4_79_2_113:4.3.2.3
	Kernel-5_35-4_79_2_112:4.3.2.3
	Kernel-5_35-4_79_2_98_2_37:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_36:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_35:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_34:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_33:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_32:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_31:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_30:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_29:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_28:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_27:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_26:4.3.2.3.2.2
	Kernel-5_35-4_79_2_111:4.3.2.3
	Kernel-5_35-4_79_2_98_2_25:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_24:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_23:4.3.2.3.2.2
	Kernel-5_35-4_79_2_110:4.3.2.3
	Kernel-5_35-4_79_2_98_2_22:4.3.2.3.2.2
	Kernel-5_35-4_79_2_109:4.3.2.3
	Kernel-5_35-4_79_2_98_2_21:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_20:4.3.2.3.2.2
	Kernel-5_35-4_79_2_108:4.3.2.3
	Kernel-5_35-4_79_2_107:4.3.2.3
	Kernel-5_35-4_79_2_98_2_19:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_18:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_17:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_16:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_15:4.3.2.3.2.2
	Kernel-5_35-4_79_2_106:4.3.2.3
	Kernel-5_35-4_79_2_105:4.3.2.3
	Kernel-5_35-4_79_2_104:4.3.2.3
	Kernel-5_35-4_79_2_98_2_14:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_13:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_12:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_11:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_10:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_9:4.3.2.3.2.2
	Kernel-5_35-4_79_2_103:4.3.2.3
	Kernel-5_35-4_79_2_102:4.3.2.3
	Kernel-5_35-4_79_2_98_2_8:4.3.2.3.2.2
	Kernel-5_35-4_79_2_98_2_7:4.3.2.3.2.1
	Kernel-5_35-4_79_2_98_2_6:4.3.2.3.2.1
	Kernel-5_35-4_79_2_98_2_5:4.3.2.3
	Kernel-5_35-4_79_2_98_2_4:4.3.2.3
	Kernel-5_35-4_79_2_101:4.3.2.3
	Kernel-5_35-4_79_2_100:4.3.2.3
	Kernel-5_35-4_79_2_99:4.3.2.3
	Kernel-5_35-4_79_2_98_2_3:4.3.2.3
	Kernel-5_35-4_79_2_98_2_2:4.3.2.3
	Kernel-5_35-4_79_2_98_2_1:4.3.2.3
	Cortex:4.3.2.3.0.2
	Cortex_bp:4.3.2.3
	Kernel-5_35-4_79_2_98:4.3.2.3
	Kernel-5_35-4_79_2_97:4.3.2.3
	Kernel-5_35-4_79_2_96:4.3.2.3
	Kernel-5_35-4_79_2_95:4.3.2.3
	Kernel-5_35-4_79_2_94:4.3.2.3
	Kernel-5_35-4_79_2_93:4.3.2.3
	Kernel-5_35-4_79_2_92:4.3.2.3
	Kernel-5_35-4_79_2_91:4.3.2.3
	Kernel-5_35-4_79_2_90:4.3.2.3
	Kernel-5_35-4_79_2_89:4.3.2.3
	Kernel-5_35-4_79_2_88:4.3.2.3
	Kernel-5_35-4_79_2_87:4.3.2.3
	Kernel-5_35-4_79_2_86:4.3.2.3
	Kernel-5_35-4_79_2_85:4.3.2.3
	Kernel-5_35-4_79_2_84:4.3.2.3
	Kernel-5_35-4_79_2_83:4.3.2.3
	Kernel-5_35-4_79_2_82:4.3.2.3
	Kernel-5_35-4_79_2_81:4.3.2.3
	Kernel-5_35-4_79_2_80:4.3.2.3
	Kernel-5_35-4_79_2_79:4.3.2.3
	Kernel-5_35-4_79_2_78:4.3.2.3
	Kernel-5_35-4_79_2_77:4.3.2.3
	RO_5_07:4.3.2.3
	Kernel-5_35-4_79_2_76:4.3.2.3
	Kernel-5_35-4_79_2_75:4.3.2.3
	Kernel-5_35-4_79_2_74:4.3.2.3
	Kernel-5_35-4_79_2_73:4.3.2.3
	Kernel-5_35-4_79_2_72:4.3.2.3
	Kernel-5_35-4_79_2_71:4.3.2.3
	Kernel-5_35-4_79_2_70:4.3.2.3
	Kernel-5_35-4_79_2_69:4.3.2.3
	Kernel-5_35-4_79_2_68:4.3.2.3
	Kernel-5_35-4_79_2_67:4.3.2.3
	Kernel-5_35-4_79_2_66:4.3.2.3
	Kernel-5_35-4_79_2_65:4.3.2.3
	Kernel-5_35-4_79_2_64:4.3.2.3
	Kernel-5_35-4_79_2_63:4.3.2.3
	Kernel-5_35-4_79_2_62:4.3.2.3
	Kernel-5_35-4_79_2_61:4.3.2.3
	Kernel-5_35-4_79_2_59:4.3.2.3
	Kernel-5_35-4_79_2_58:4.3.2.3
	Kernel-5_35-4_79_2_57:4.3.2.3
	Kernel-5_35-4_79_2_56:4.3.2.3
	Kernel-5_35-4_79_2_55:4.3.2.3
	Kernel-5_35-4_79_2_54:4.3.2.3
	Kernel-5_35-4_79_2_53:4.3.2.3
	Kernel-5_35-4_79_2_52:4.3.2.3
	Kernel-5_35-4_79_2_51:4.3.2.3
	Kernel-5_35-4_79_2_50:4.3.2.2
	Kernel-5_35-4_79_2_49:4.3.2.2
	Kernel-5_35-4_79_2_48:4.3.2.2
	Kernel-5_47:4.3
	Kernel-5_46-4_90_2_1:4.3
	nbingham_Kernel_FastNC_dev_bp:4.3
	nbingham_Kernel_FastNC_dev:4.3.0.4
	Kernel-5_46:4.3
	Kernel-5_45:4.3
	Kernel-5_35-4_79_2_47:4.3.2.1
	Kernel-5_35-4_79_2_46:4.3.2.1
	Kernel-5_35-4_79_2_45:4.3.2.1
	Kernel-5_35-4_79_2_44:4.3.2.1
	Kernel-5_35-4_79_2_25_2_2:4.3.2.1
	Kernel-5_35-4_79_2_43:4.3.2.1
	Kernel-5_35-4_79_2_42:4.3.2.1
	Kernel-5_35-4_79_2_41:4.3.2.1
	Kernel-5_35-4_79_2_40:4.3.2.1
	Kernel-5_35-4_79_2_39:4.3.2.1
	Kernel-5_35-4_79_2_38:4.3.2.1
	Kernel-5_35-4_79_2_37:4.3.2.1
	Kernel-5_35-4_79_2_36:4.3.2.1
	Kernel-5_35-4_79_2_35:4.3.2.1
	Kernel-5_35-4_79_2_34:4.3.2.1
	Kernel-5_35-4_79_2_33:4.3.2.1
	Kernel-5_35-4_79_2_32:4.3.2.1
	Kernel-5_44:4.3
	Kernel-5_35-4_79_2_25_2_1:4.3.2.1
	Kernel-5_43:4.3
	Kernel-5_35-4_79_2_31:4.3.2.1
	Kernel-5_35-4_79_2_30:4.3.2.1
	Kernel-5_35-4_79_2_29:4.3.2.1
	Kernel-5_35-4_79_2_28:4.3.2.1
	Kernel-5_35-4_79_2_27:4.3.2.1
	Kernel-5_35-4_79_2_26:4.3.2.1
	Kernel-5_42:4.3
	Kernel-5_41:4.3
	Kernel-5_40:4.3
	Kernel-5_35-4_79_2_25:4.3.2.1
	Kernel-5_35-4_79_2_24:4.3.2.1
	Kernel-5_35-4_79_2_23:4.3.2.1
	Kernel-5_35-4_79_2_22:4.3.2.1
	Kernel-5_35-4_79_2_21:4.3.2.1
	Kernel-5_35-4_79_2_20:4.3.2.1
	Kernel-5_35-4_79_2_19:4.3.2.1
	Kernel-5_35-4_79_2_18:4.3.2.1
	Kernel-5_35-4_79_2_17:4.3.2.1
	Kernel-5_35-4_79_2_16:4.3.2.1
	Kernel-5_35-4_79_2_15:4.3.2.1
	Kernel-5_35-4_79_2_14:4.3.2.1
	Kernel-5_39:4.3
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.8
	Kernel-5_38:4.3
	Kernel-5_35-4_79_2_13:4.3.2.1
	Kernel-5_35-4_79_2_12:4.3.2.1
	Kernel-5_35-4_79_2_11:4.3.2.1
	Kernel-5_37:4.3
	Kernel-5_35-4_79_2_10:4.3.2.1
	Kernel-5_35-4_79_2_9:4.3.2.1
	Kernel-5_36:4.3
	Kernel-5_35-4_79_2_8:4.3.2.1
	Kernel-5_35-4_79_2_7:4.3.2.1
	Kernel-5_35-4_79_2_6:4.3.2.1
	Kernel-5_35-4_79_2_5:4.3.2.1
	Kernel-5_35-4_79_2_4:4.3.2.1
	Kernel-5_35-4_79_2_3:4.3.2.1
	Kernel-5_35-4_79_2_2:4.3
	dellis_autobuild_BaseSW:4.3
	Kernel-5_35-4_79_2_1:4.3
	HAL:4.3.0.2
	Kernel-5_35:4.3
	Kernel-5_34:4.3
	Kernel-5_33:4.3
	Kernel-5_32:4.3
	Kernel-5_31:4.3
	Kernel-5_30:4.3
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.3
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2016.12.15.15.27.03;	author jlee;	state Exp;
branches;
next	4.5;
commitid	SNoEvPlWCrTKR5yz;

4.5
date	2016.06.30.20.59.53;	author jlee;	state Exp;
branches;
next	4.4;
commitid	skOEjp3ipLHx6xcz;

4.4
date	2016.06.30.20.08.18;	author jlee;	state Exp;
branches;
next	4.3;
commitid	IWoXxARWeuLDOwcz;

4.3
date	2000.06.28.16.12.26;	author bavison;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	2000.04.04.14.27.39;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.32;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2000.10.03.12.05.59;	author mstephen;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	2002.11.30.00.31.12;	author bavison;	state Exp;
branches
	4.3.2.3.2.1;
next	4.3.2.4;

4.3.2.4
date	2011.11.26.21.11.27;	author jlee;	state Exp;
branches;
next	4.3.2.5;
commitid	cI3W0zbtALQG6TIv;

4.3.2.5
date	2011.11.27.19.18.22;	author rsprowson;	state Exp;
branches
	4.3.2.5.2.1;
next	4.3.2.6;
commitid	iuIXfUOByAFYr0Jv;

4.3.2.6
date	2012.05.21.19.31.42;	author rsprowson;	state Exp;
branches;
next	4.3.2.7;
commitid	oEtPURiKNEPMRC5w;

4.3.2.7
date	2012.07.04.17.50.56;	author rsprowson;	state Exp;
branches;
next	4.3.2.8;
commitid	BwjRc3GMlaDwTgbw;

4.3.2.8
date	2013.08.06.22.43.09;	author jlee;	state Exp;
branches;
next	4.3.2.9;
commitid	TOIaeUf2Q4rBIr0x;

4.3.2.9
date	2013.12.15.21.34.10;	author jlee;	state Exp;
branches;
next	;
commitid	KwuK29hKRyXO7hhx;

4.3.2.3.2.1
date	2009.05.10.20.22.33;	author bavison;	state Exp;
branches;
next	4.3.2.3.2.2;

4.3.2.3.2.2
date	2009.05.17.01.34.42;	author bavison;	state Exp;
branches;
next	4.3.2.3.2.3;

4.3.2.3.2.3
date	2011.08.08.23.28.37;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

4.3.2.5.2.1
date	2012.09.18.15.50.10;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.1.1.1
date	96.11.05.09.41.32;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.02.21;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.25;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.40;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.24;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Add support for custom teletext modes
Detail:
  This set of changes:
  * Adds support for the T, TX and TY mode string elements (as per RISCOS Ltd)
  * Adds support for entering arbitrary-resolution teletext modes by using mode selector blocks with the Teletext mode flag set
  * ScrRCol and ScrBRow mode variables can be provided in the mode selector in order to restrict the number of text rows/columns in teletext modes (as per RISCOS Ltd)
  * If the rows / columns are restricted in this manner then the text window will be centered on the screen, to try and avoid things looking too ugly (no variable text scaling implemented)
  * For HiResTTX, all colour depths >= 4bpp are now supported by teletext. This essentially makes the TTX256 switch obsolete.
  * If the "native" mode 7 is unavailable then the kernel will try a series of fallback resolutions & colour depths in an effort to find a combination that works
  Known bugs/issues:
  * Teletext column count has a max limit of 255 due to TTXDoubleCounts being a byte array
  * If there's a border around the text window, the border will not be refreshed when changing transparency modes using a VDU 23,18,0 sequence
  * ScreenLoad looks like it can overflow the LargeCommon buffer (no buffer size check) - needs fixing before LargeCommon can be safely shrunk below (Old)TTXMapSize
  File changes:
  - hdr/KernelWS - Make CharWidth non-conditional. Adjust handling of teletext workspace; it's now allocated from the system heap to allow it to cope with arbitrary screen sizes
  - s/vdu/vdu23 - Make CharWidth non-conditional
  - s/vdu/vducursoft - Make CursorTeletext cope with arbitrary colour depths, make CharWidth non-conditional, remove hard-coded teletext values
  - s/vdu/vdudriver - Deal with teletext workspace allocation during ModeChangeSub. Deal with selecting teletext modes (and validating colour depth) in GenerateModeSelectorVars.
  - s/vdu/vdugrafl - Make CharWidth non-conditional. Calculate offset required for text window centering.
  - s/vdu/vdumodes - Remove TTX256
  - s/vdu/vduswis - Try other teletext modes if native mode 7 not available. Extend OS_ScreenMode reason codes to cope with teletext mode strings.
  - s/vdu/vduttx - Update to use dynamic workspace. Replace various hardcoded values with variable lookups. Update character plotting + colour/palette selection to work with true-colour modes if HiResTTX.
  - s/vdu/vduwrch - Move some useful code into a subroutine. Update FastCLS to cope with true-colour teletext. Update AddressR0R1 to cope with text window centering offset. Make CharWidth non-conditional.
Admin:
  Tested on Raspberry Pi, BB-xM
  VDU 23,18,0 in 256-colour teletext now works correctly (previously 64-colour mode was in use, causing palette update to be ruined by VIDC1-mangling)


Version 5.74. Tagged as 'Kernel-5_74'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.Vdu23

; *****************************************************************************
;
;       DefineChar - define soft character
;
; in:   R0 = char to be defined
;

DefineChar
        ADD     R1, WsPtr, #(Font-32*8)
        ADD     R1, R1, R0, LSL #3              ; point to char definition

        ADD     R2, WsPtr, #QQ+1
        LDMIA   R2, {R2, R3}                    ; load 8 bytes
        STMIA   R1, {R2, R3}                    ; store 8 bytes
Nop
        MOV     PC, R14

; *****************************************************************************
;
;       VDU 23,7,m,d,z| - Scroll window directly
;
;       m=0     Scroll text window
;       m=1     Scroll entire screen
;
;       d=0     Scroll right
;       d=1     Scroll left
;       d=2     Scroll down
;       d=3     Scroll up
;       d=4     Scroll "right"
;       d=5     Scroll "left"
;       d=6     Scroll "down"
;       d=7     Scroll "up"
;
;       z=0     Scroll by 1 character cell
;       z=1     Scroll by 1 char vertically, 1 byte (whatever that is) horiz.
;

Vdu23_7 ROUT
        LDRB    R0, [WsPtr, #QQ+1]      ; R0 := m
        LDRB    R1, [WsPtr, #QQ+2]      ; R1 := d
        LDRB    R2, [WsPtr, #QQ+3]      ; R2 := z
Scroll012
        LDR     R6, [WsPtr, #CursorFlags]
        AND     R1, R1, #7              ; ignore higher bits
        CMP     R1, #4
        BCC     %FT10
        LDR     R4, ScrollDirWord
        CMP     R1, #6
        MOVCS   R4, R4, ROR #16
        AND     R3, R6, #&0E
        MOV     R3, R3, LSL #1
        MOV     R4, R4, LSR R3
        MOVS    R1, R1, LSR #1
        AND     R1, R4, #&0F
        EORCS   R1, R1, #1
10
        Push    R14
        TST     R6, #ClipBoxEnableBit   ; if calculating clip box
        BLNE    ClipScroll              ; then add text window or whole screen
        CMP     R0, #1                  ; C=1 => whole screen
        ADC     R1, R1, R1              ; put m into bit 0
        TEQ     R2, #0
        ORRNE   R1, R1, #&08            ; put z into bit 3
        ADR     R0, ScrollTab
        LDR     R2, [R0, R1, LSL #2]
        ADR     R14, ScrollRetn
        ADD     PC, R0, R2              ; carry on entry is m

ScrollRetn
        Pull    R14

; insert code here to re-address input cursor as well

        B       AddressCursors          ; re-address cursor positions

ScrollDirWord
        &       &33221010

ScrollTab
        &       ScrollRightChar-ScrollTab ; window right char
        &       ScrollRightChar-ScrollTab ; screen right char
        &       ScrollLeftChar-ScrollTab ; window left char
        &       ScrollLeftChar-ScrollTab ; screen left char
        &       ScrollDown-ScrollTab    ; window down char
        &       HardScrollDown-ScrollTab ; screen down char
        &       ScrollUp-ScrollTab      ; window up char
        &       HardScrollUp-ScrollTab  ; screen up char
        &       ScrollRightByte-ScrollTab ; window right byte
        &       ScrollRightByte-ScrollTab ; screen right byte
        &       ScrollLeftByte-ScrollTab ; window left byte
        &       ScrollLeftByte-ScrollTab ; screen left byte
        &       ScrollDown-ScrollTab    ; window down byte
        &       HardScrollDown-ScrollTab ; screen down byte
        &       ScrollUp-ScrollTab      ; window up byte
        &       HardScrollUp-ScrollTab  ; screen up byte


; *****************************************************************************
;
;       VDU 23,17,c,t| - Set tint
;
;       c=0     Set text foreground tint (default &FF)
;       c=1     Set text background tint (default &00)
;       c=2     Set graphics foreground tint (default &FF)
;       c=3     Set graphics background tint (default 0)
;       c=4     t=0 => BBC compatible ECFs, t=1 => native ECFs (default 0)
;       c=5     Swap foreground and background text colours/tints
;       c=6     VDU 23,17,6,x;y; - Set ECF origin to (x,y)
;       c=7     VDU 23,17,7,flags,x;y;0,0 - Set character size(s)
;       c=8-255 Reserved
;
;       t=tint  Only bits 6,7 relevant with this hardware

Vdu23_17
        LDRB    R0, [WsPtr, #QQ+1]              ; get c
        CMP     R0, #7
        MOVHI   R0, #17                         ; if unknown (>7), reload R0
        BHI     UnknownVdu23                    ; and call UKVDU23 vector
        BEQ     SetCharSizes

        CMP     R0, #6
        BEQ     SetECFOrigin

        CMP     R0, #4
        BHI     SwapColours                     ; 5 => swap colours

        LDRB    R1, [WsPtr, #QQ+2]              ; tint or BBC parm
        STREQ   R1, [WsPtr, #BBCcompatibleECFs] ; VDU 23,17,4,t...
        MOVEQ   PC, R14

        ADD     R2, WsPtr, #TFTint
        LDR     R3, [R2, R0, LSL #2]            ; get old tint
        STR     R1, [R2, R0, LSL #2]

        CMP     R0, #2                          ; graphics tint ?
        BCS     SetColour                       ; then update masks

        EOR     R1, R1, R3
        TST     R1, #&C0                        ; are top two bits different ?
        MOVEQ   PC, R14                         ; no need to redo table

        ; amg: use R1 here instead of 'bpp' which is R0. I need R0 in a moment.
        LDR     R1, [WsPtr, #BitsPerPix]
        CMP     R1, #8                          ; are we in 8 bits-per-pixel or more?
        MOVCC   PC, R14                         ; no, then exit

        Push    "lr"

        ; amg: only do foreground or background as appropriate
        CMP     R0,#1
        BEQ     %FT05
        BL      CompileTextFg
        B       %FT10
05
        BL      CompileTextBg                   ; update TextFgColour/TextBgColour
10
        Pull    "lr"

SetColoursDirty
        LDR     R6, [WsPtr, #CursorFlags]
        ORR     R6, R6, #TEUpdate               ; yes, then set colours dirty
        STR     R6, [WsPtr, #CursorFlags]
        MOV     PC, R14

; *****************************************************************************

SwapColours ROUT
        LDR     R1, [WsPtr, #TForeCol]
        LDR     R2, [WsPtr, #TBackCol]
        STR     R1, [WsPtr, #TBackCol]
        STR     R2, [WsPtr, #TForeCol]

        LDR     R1, [WsPtr, #TextFgColour]
        LDR     R2, [WsPtr, #TextBgColour]
        STR     R1, [WsPtr, #TextBgColour]
        STR     R2, [WsPtr, #TextFgColour]

        LDR     R3, [WsPtr, #BitsPerPix]
        CMP     R3, #8                          ; C=1 <=> 256 colour mode
        BCC     %FT10                           ; [not 256 colour mode]

        LDR     R1, [WsPtr, #TFTint]
        LDR     R2, [WsPtr, #TBTint]
        STR     R1, [WsPtr, #TBTint]
        STR     R2, [WsPtr, #TFTint]
10
        B       SetColoursDirty                 ; don't bother optimising the case
                                                ; when both colours are the same

; *****************************************************************************
;
;       SetECFOrigin - Set the origin of the ECF pattern
;
;       Called by VDU 23,17,6,x;y;0,0,0
;
; in:   QQ+2, QQ+3 = xlo, xhi
;       QQ+4, QQ+5 = ylo, yhi
;

SetECFOrigin ROUT

; *****Change made by DJS
; Original code was:
;        LDRB    R0, [WsPtr, #QQ+3]      ; xhi
;        LDRB    R1, [WsPtr, #QQ+2]      ; xlo
;        PackXtnd R0, R0, R1             ; pack 2 bytes and sign extend
;        LDRB    R1, [WsPtr, #QQ+5]      ; yhi
;        LDRB    R2, [WsPtr, #QQ+4]      ; ylo
;        PackXtnd R1, R1, R2             ; pack 2 bytes and sign extend

        LoadCoordPair R0, R1, WsPtr, QQ+2

; *****End of change made by DJS

SetECFOriginCommon
        Push    R14
        ADD     R8, WsPtr, #GCsX        ; save ECursor away, cos EIG changes it
        LDMIA   R8, {R6, R7}            ; and we don't want it to!

        MOV     R2, #&FF                ; convert external-to-internal
        BL      EIG                     ; as absolute coordinates

; now R0 = internal X; R1 = internal Y

        LDR     R3, [WsPtr, #NPix]
        LDR     R4, [WsPtr, #Log2BPC]

        AND     R0, R0, R3              ; X MOD (number of pixels per word)

; *****Change made by DJS
; Original code was:
;        MOVS    R0, R0, LSL R4          ; number of bits to rotate ECF left by
;        MOVEQ   R0, #32                 ; if zero then make 32
;        RSB     R0, R0, #32             ; so we make it zero again!
; I don't think anything cares whether this value is 0 or 32 in this case - it
; is only used as Rm in a couple of MOV Rn, Rn, ROR Rm instructions. So change
; to:
        MOV     R0, R0, LSL R4          ; number of bits to rotate ECF left by
        RSB     R0, R0, #32
; *****End of change made by DJS

        STR     R0, [WsPtr, #ECFShift]  ; number of bits to rotate right by

        LDR     R3, [WsPtr, #YWindLimit]
; *****Change made by DJS
; Need to increase R3 by one to produce correct alignment of the ECF patterns,
; as YWindLimit is an inclusive bound, not an exclusive one.
        ADD     R3, R3, #1
; *****End of change made by DJS
        SUB     R1, R3, R1              ; invert Y
        AND     R1, R1, #7              ; modulo 8
        STR     R1, [WsPtr, #ECFYOffset]

        STMIA   R8, {R6, R7}

        BL      SetColour               ; update colours now

        Pull    PC

; *****************************************************************************
;
;       SWISetECFOrigin - Entry point for SWI OS_SetECFOrigin
;
; in:   R0 = x-coordinate (external coords)
;       R1 = y-coordinate (-------""------)
;

SWISetECFOrigin ROUT
        Push    "R0-R9, R14"
        VDWS    WsPtr
        BL      SetECFOriginCommon
        Pull    "R0-R9, R14"
        ExitSWIHandler

; *****************************************************************************
;
;       Scroll left and right
;
; in:   C=0 => scroll window
;       C=1 => scroll screen

ScrollLeftChar
        MOV     R9, #0
        B       ScrollLeft

ScrollLeftByte
        LDR     R9, [WsPtr, #Log2BPP]
        LDR     R10, [WsPtr, #ModeFlags]
        TST     R10, #ModeFlag_BBCGapMode       ; if in BBC gap mode
        SUBNE   R9, R9, #1                      ; then 1 BBC byte = 2 ARM bytes

ScrollLeft
        LDR     R10, [WsPtr, #Log2BPC]
        SUB     R9, R10, R9

        MOV     R10, #1
        MOV     R9, R10, LSL R9                 ; R9 = bytes to move by

        ADC     R0, R0, R0                      ; bit0(R0) set => whole screen
        TST     R6, #TeletextMode               ; if teletext, then do special
        BNE     TTXScrollLeft

        Push    "R0, R14"                       ; save link and carry
        MOVS    R0, R0, LSR #1                  ; C=0/1 => window/screen
        BL      GetScrWindInfo
        BL      ScrollLeft2
        Pull    R0
        MOVS    R0, R0, LSR #1

; now clear right hand column

        ADDCC   R0, WsPtr, #TWBRow              ; C=0 => window
        LDMCCIA R0, {R1-R3}                     ; R1 = TWBRow; R2 = TWRCol
        MOVCC   R0, R2                          ; R3 = TWTRow; R0 = TWRCol

        ADDCS   R0, WsPtr, #ScrRCol             ; C=1 => screen
        LDMCSIA R0, {R0, R1}                    ; R0 = ScrRCol; R1 = ScrBRow
        MOVCS   R2, R0                          ; R2 = ScrRCol; R3 = 0
        MOVCS   R3, #0

;       R9 = width of column to clear (in bytes)

        BL      GetBoxInfo              ; get info for right hand char column
                                        ; R2 -> top left of right hand char col
                                        ; R5 := number of bytes for one char
        ADD     R2, R2, R5              ; R2 -> off right of top line
        MOV     R5, R9                  ; R5 := real number of bytes to do
        SUB     R2, R2, R5              ; R2 -> top left of column to clear
        Pull    R14
        B       ClearThisBox

; *****************************************************************************

GetScrWindInfo
        BCC     GetWindowInfo
GetScreenInfo
        MOV     R0, #0
        LDR     R1, [WsPtr, #ScrBRow]
        LDR     R2, [WsPtr, #ScrRCol]
        MOV     R3, #0
        B       GetBoxInfo

; *****************************************************************************
;
;       ScrollLeft2 - Scroll area of screen left (don't clear right column)
;
; in:   R2 -> screen(left,top)
;       R5 = width of box in bytes
;       R6 = number of scan lines in box
;       R7 = linelength
;       R9 = number of bytes to scroll by
;

ScrollLeft2 ROUT
        SUBS    R5, R5, R9                      ; number of bytes to scroll
        MOVEQ   PC, R14                         ; none to scroll

        MOV     R10, R9, LSL #3                 ; number of bits moving by
        CMP     R10, #32
        MOVCS   R10, #32                        ; only do 32 at a time
        RSB     R11, R10, #32                   ; 32-number of bits moving by

ScrollLineLeft
        MOV     R0, R2                          ; to addr (left)
        ADD     R1, R0, R9                      ; from addr (right)
        ADD     R3, R0, R5                      ; end+1 to addr
10
        TST     R0, #3                          ; if not on word boundary
        LDRNEB  R4, [R1], #1                    ; then copy a byte from R1
        STRNEB  R4, [R0], #1                    ; to R0
        CMPNE   R0, R3                          ; if not on bdy and not at end
        BNE     %BT10                           ; then loop

20
        ADD     R1, R1, #3                      ; round R1 up to next word
        BIC     R1, R1, #3

        TEQ     R11, #0                         ; if no shifts, use fast code
        BEQ     %FT60

        SUB     R3, R3, #3                      ; fudge factors anonymous
        CMP     R0, R3                          ; if can't do any words
        BCS     %FT40                           ; then skip
        LDR     R8, [R0]                        ; get word to be put into R4
30
        MOV     R4, R8, LSR R10                 ; get 2nd bits of old word
        LDR     R8, [R1], #4                    ; load new word
        ORR     R4, R4, R8, LSL R11             ; merge with 1st bits of new
        STR     R4, [R0], #4                    ; and store
        CMP     R0, R3                          ; if more words to do then loop
        BCC     %BT30
40
        ADD     R3, R3, #3                      ; put it back again

;       finish off the odd bytes
;       R0 -> next dest byte

        ADD     R1, R0, R9                      ; R1 -> next source byte
        CMP     R0, R3                          ; if not at end
50
        LDRCCB  R4, [R1], #1                    ; then copy a byte from R1
        STRCCB  R4, [R0], #1                    ; to R0
        CMPCC   R0, R3                          ; check for end
        BCC     %BT50                           ; and loop if not

        ADD     R2, R2, R7                      ; goto next line down
        SUBS    R6, R6, #1                      ; one less line to do
        BNE     ScrollLineLeft
        MOV     PC, R14

; fast code for when R10=32, R11=0

60
        SUB     R3, R3, #7                      ; must be able to do 8 bytes
        CMP     R0, R3
70
        LDMCCIA R1!, {R4, R8}                   ; if OK then copy 2 words
        STMCCIA R0!, {R4, R8}
        CMPCC   R0, R3                          ; check for end
        BCC     %BT70
        ADD     R3, R3, #4                      ; must be able to do 4 bytes
        CMP     R0, R3
80
        LDRCC   R4, [R1], #4                    ; if OK then copy a word
        STRCC   R4, [R0], #4
        CMPCC   R0, R3                          ; check for end
        BCC     %BT80
        B       %BT40                           ; do odd bytes at end

; *****************************************************************************

ScrollRightChar
        MOV     R9, #0
        B       ScrollRight

ScrollRightByte
        LDR     R9, [WsPtr, #Log2BPP]
        LDR     R10, [WsPtr, #ModeFlags]
        TST     R10, #ModeFlag_BBCGapMode       ; if in BBC gap mode
        SUBNE   R9, R9, #1                      ; then 1 BBC byte = 2 ARM bytes

ScrollRight
        LDR     R10, [WsPtr, #Log2BPC]
        SUB     R9, R10, R9

        MOV     R10, #1
        MOV     R9, R10, LSL R9                 ; R9 = bytes to move by

        ADC     R0, R0, R0                      ; bit0(R0) set => whole screen
        TST     R6, #TeletextMode               ; if teletext, then do special
        BNE     TTXScrollRight

        Push    "R0, R14"                       ; save link and carry
        MOVS    R0, R0, LSR #1                  ; C=0/1 => window/screen
        BL      GetScrWindInfo
        BL      ScrollRight2
        Pull    R0
        MOVS    R0, R0, LSR #1

; now clear left column

        ADDCC   R0, WsPtr, #TWLCol              ; C=0 => window
        LDMCCIA R0, {R0-R3}                     ; R0 = TWLCol; R1 = TWBRow
        MOVCC   R2, R0                          ; R2 = TWLCol; R3 = TWTRow

        MOVCS   R0, #0
        LDRCS   R1, [WsPtr, #ScrBRow]
        MOVCS   R2, R0
        MOVCS   R3, #0

;       R9 = width of column to clear (in bytes)

        BL      GetBoxInfo              ; get info for right hand char column
                                        ; R2 -> top left of left hand char col
                                        ; R5 := number of bytes for one char
        MOV     R5, R9                  ; R5 := real number of bytes to do
        Pull    R14
        B       ClearThisBox

; *****************************************************************************
;
;       ScrollRight2 - Scroll area of screen right (don't clear left column)
;
; in:   R2 -> screen(left,top)
;       R5 = width of box in bytes
;       R6 = number of scan lines in box
;       R7 = linelength
;       R9 = number of bytes to scroll by
;

ScrollRight2 ROUT
        ADD     R2, R2, R5                      ; R2 -> off top right
        SUB     R2, R2, #1                      ; R2 -> top right

        SUBS    R5, R5, R9                      ; number of bytes to scroll
        MOVEQ   PC, R14                         ; none to scroll

        MOV     R10, R9, LSL #3                 ; number of bits moving by
        CMP     R10, #32
        MOVCS   R10, #32                        ; only do 32 at a time
        RSB     R11, R10, #32                   ; 32-number of bits moving by

ScrollLineRight
        MOV     R0, R2                          ; to addr (right)
        SUB     R1, R0, R9                      ; from addr (left)
        SUB     R3, R0, R5                      ; end-1 to addr

        MOV     R8, #(3 :SHL: 30)
10
        CMP     R8, R0, LSL #30                 ; EQ if (R0 AND 3)=3
        LDRNEB  R4, [R1], #-1                   ; if not then copy a byte
        STRNEB  R4, [R0], #-1
        CMPNE   R0, R3                          ; if not aligned and not end
        BNE     %BT10                           ; then loop

        SUB     R1, R1, #3                      ; round R1 down to next word
        BIC     R1, R1, #3

        SUB     R0, R0, #3                      ; make R0 -> word boundary
        TEQ     R11, #0                         ; if no shifts, use fast code
        BEQ     %FT60

        CMP     R0, R3                          ; if no words
        BLS     %FT40                           ; then skip
        LDR     R8, [R0]                        ; get word to be put into R4
30
        MOV     R4, R8, LSL R10
        LDR     R8, [R1], #-4
        ORR     R4, R4, R8, LSR R11
        STR     R4, [R0], #-4
        CMP     R0, R3                          ; if R3 < R1 then no more words
        BHI     %BT30
40
        ADD     R0, R0, #3                      ; put it back again

;       finish off the odd bytes
;       R0 -> next dest byte

        SUB     R1, R0, R9                      ; R1 -> next source byte
        CMP     R0, R3                          ; check for end
50
        LDRHIB  R4, [R1], #-1                   ; if not end then copy byte
        STRHIB  R4, [R0], #-1
        CMPHI   R0, R3                          ; check for end
        BHI     %BT50

        ADD     R2, R2, R7                      ; move to next row
        SUBS    R6, R6, #1                      ; one less row to do
        BNE     ScrollLineRight
        MOV     PC, R14

; fast code for when R10=32, R11=0

60
        ADD     R3, R3, #4                      ; need to do at least 8 bytes
        CMP     R0, R3
70
        LDMHIDA R1!, {R4, R8}                   ; if OK then copy 2 words
        STMHIDA R0!, {R4, R8}
        CMPHI   R0, R3                          ; check for end
        BHI     %BT70

        SUB     R3, R3, #4                      ; put it back
        CMP     R0, R3
80
        LDRHI   R4, [R1], #-4                   ; if OK then copy 1 word
        STRHI   R4, [R0], #-4
        CMPHI   R0, R3                          ; check for end
        BHI     %BT80
        B       %BT40

; *****************************************************************************
;
;       VDU 23,16,x,y| - Change cursor flags
;
;       new := (old AND y) EOR x

Vdu23_16
        LDRB    R0, [WsPtr, #CursorFlags]       ; just affect bottom byte
        LDRB    R1, [WsPtr, #QQ+1]              ; x
        LDRB    R2, [WsPtr, #QQ+2]              ; y
        AND     R0, R0, R2
        EOR     R0, R0, R1
        STRB    R0, [WsPtr, #CursorFlags]

        TST     R0, #1
        BEQ     RCRLF                           ; leaving 81 column mode
                                                ; so release CRLF
        MOV     PC, R14

; *****************************************************************************
;
;       Move cursor to R0 chars from boundary
;       and check for being legal
;
; out:  C=1 => was within window
;       C=0 => outside window

        ASSERT  CursorY = CursorX +4

CursorBdyCheck
        Push    R14
        BL      CursorBdy
        ADD     R9, WsPtr, #CursorX
        LDMIA   R9, {R9, R10}
        CMP     R4, R9
        CMPCS   R3, R10
        Pull    PC

; *****************************************************************************
;
;       Move cursor to boundary indicated by value of R6 in bits 1-3
;       (0 or 4 = left, 2 or 6 = right, 8 or 10 = up, 12 or 14 = down)
;       + R0 character positions in
;
; out:  R7, R8, R11 undefined
;       R0, R1, R6, R9, R10, R12, R13 preserved
;       R2-R5 are window coords (left,down,right,up)
;
        ASSERT  TWBRow = TWLCol + 4
        ASSERT  TWRCol = TWLCol + 8
        ASSERT  TWTRow = TWLCol + 12

InputCursorB0
        MOV     R0, #0
InputCursorBdy
        ADD     R11, WsPtr, #InputCursorX
        B       CBDY05

CursorB0
        MOV     R0, #0
CursorBdy
        ADD     R11, WsPtr, #CursorX
CBDY05
        ADD     R7, WsPtr, #TWLCol      ; point to window coords
        LDMIA   R7, {R2-R5}

        ADR     R7, CBDYTab
DoJumpTable
        AND     R8, R6, #&0E
        LDR     R8, [R7, R8, LSL #1]
        ADD     PC, R7, R8

CBDYTab
        &       CursorLBdy-CBDYTab
        &       CursorRBdy-CBDYTab
        &       CursorLBdy-CBDYTab
        &       CursorRBdy-CBDYTab
        &       CursorUBdy-CBDYTab
        &       CursorUBdy-CBDYTab
        &       CursorDBdy-CBDYTab
        &       CursorDBdy-CBDYTab

; Move cursor to left boundary + R0 characters in

CursorLBdy
        ADD     R7, R0, R2
CBDY10
        STR     R7, [R11, #CursorX-CursorX]
        MOV     PC, R14

; Move cursor to right boundary + R0 characters in

CursorRBdy
        SUB     R7, R4, R0
        B       CBDY10

; Move cursor to up boundary + R0 characters in

CursorUBdy
        ADD     R7, R0, R5
CBDY20
        STR     R7, [R11, #CursorY-CursorX]
        MOV     PC, R14

; Move cursor to down boundary + R0 characters in

CursorDBdy
        SUB     R7, R3, R0
        B       CBDY20

; *****************************************************************************
;
;       CursorMove - Move cursor in direction corresponding to R6 bits 1-3
;       (0,4 = right; 2,6 = left; 8,10 = down; 12,14 = up)
;       R6 is preserved

        ASSERT  InputCursorY-InputCursorX = CursorY-CursorX
        ASSERT  InputCursorAddr-InputCursorX = CursorAddr-CursorX

InputCursorMove
        ADD     R11, WsPtr, #InputCursorX
        B       CurM10

CursorMove
        ADD     R11, WsPtr, #CursorX
CurM10
        ADR     R7, CMVTab
        B       DoJumpTable

CMVTab
        &       MoveRight-CMVTab
        &       MoveLeft-CMVTab
        &       MoveRight-CMVTab
        &       MoveLeft-CMVTab
        &       MoveDown-CMVTab
        &       MoveDown-CMVTab
        &       MoveUp-CMVTab
        &       MoveUp-CMVTab

; Move cursor right if possible - on exit C=1 iff at RHS

MoveRight
        LDR     R0, [R11, #CursorX-CursorX]
        LDR     R4, [WsPtr, #TWRCol]
        CMP     R0, R4
        MOVCS   PC, R14
        LDR     R2, [R11, #CursorAddr-CursorX]
        LDR     R3, [WsPtr, #CharWidth]
        ADD     R0, R0, #1
        ADD     R2, R2, R3
        STR     R0, [R11, #CursorX-CursorX]
        STR     R2, [R11, #CursorAddr-CursorX]
        MOV     PC, R14

; Move cursor left if possible - on exit C=1 iff at LHS

MoveLeft
        LDR     R0, [R11, #CursorX-CursorX]
        LDR     R4, [WsPtr, #TWLCol]
        CMP     R4, R0
        MOVCS   PC, R14
        LDR     R2, [R11, #CursorAddr-CursorX]
        LDR     R3, [WsPtr, #CharWidth]
        SUB     R0, R0, #1
        SUB     R2, R2, R3
        STR     R0, [R11, #CursorX-CursorX]
        STR     R2, [R11, #CursorAddr-CursorX]
        MOV     PC, R14

; Move cursor down if possible - on exit C=1 iff at bottom

MoveDown
        LDR     R1, [R11, #CursorY-CursorX]
        LDR     R4, [WsPtr, #TWBRow]
        CMP     R1, R4
        MOVCS   PC, R14
        LDR     R2, [R11, #CursorAddr-CursorX]
        LDR     R3, [WsPtr, #RowLength]
        ADD     R1, R1, #1
        ADD     R2, R2, R3
        STR     R1, [R11, #CursorY-CursorX]
        STR     R2, [R11, #CursorAddr-CursorX]
        MOV     PC, R14

; Move cursor up if possible - on exit C=1 iff at top

MoveUp
        LDR     R1, [R11, #CursorY-CursorX]
        LDR     R4, [WsPtr, #TWTRow]
        CMP     R4, R1
        MOVCS   PC, R14
        LDR     R2, [R11, #CursorAddr-CursorX]
        LDR     R3, [WsPtr, #RowLength]
        SUB     R1, R1, #1
        SUB     R2, R2, R3
        STR     R1, [R11, #CursorY-CursorX]
        STR     R2, [R11, #CursorAddr-CursorX]
        MOV     PC, R14

; *****************************************************************************
;
;       Special HT - used when abnormal cursor direction selected
;                    or if C81Bit set
;
; in:   R6 = CursorFlags
;

SpecialHT
        TST     R6, #Vdu5Bit
        BNE     Vdu5HT
        Push    "R6,R14"
        BL      RCRLFR6
        Pull    R6
        BL      CursorMove              ; try to move in appropriate direction
        Pull    PC, CC                  ; if successful, finish
        BL      CursorB0                ; else move cursor to -ve X boundary
        BL      AddressCursor           ; re-address cursor
        Pull    R14
        B       VduLF                   ; and do a line-feed

; *****************************************************************************
;
;       CHT - version of HT used after printing character
;       will set pending CRLF if necessary
;
; in:   R6 = CursorFlags

CHT
        TST     R6, R6, ROR #10 ; test for Vdu5 or &1E or C81Bit, latter not
                                ; possible as we just printed a char
        BNE     SpecialCHT

        LDR     R0, [WsPtr, #CursorX]
        LDR     R2, [WsPtr, #CursorAddr]
        LDR     R3, [WsPtr, #CharWidth]
        LDR     R4, [WsPtr, #TWRCol]

        ADD     R0, R0, #1
        ADD     R2, R2, R3
        CMP     R0, R4
        STRLS   R0, [WsPtr, #CursorX]
        STRLS   R2, [WsPtr, #CursorAddr]
        MOVLS   PC, R14

        TST     R6, #1                          ; are we in "81-column" mode
        BNE     CHT10                           ; yes, then just set C81Bit

        BSR     PageTest

        LDR     R0, [WsPtr, #TWLCol]
        LDR     R1, [WsPtr, #CursorY]
        LDR     R4, [WsPtr, #TWBRow]

        ADD     R1, R1, #1
        CMP     R1, R4
        BLS     CursorR0R1                       ; not on bottom line

        STR     R0, [WsPtr, #CursorX]
        BSR     ScrollUp
        B       AddressCursor                    ; re-address cursor position

CHT10
        ORR     R6, R6, #C81Bit
        STR     R6, [WsPtr, #CursorFlags]
        MOV     PC, R14

SpecialCHT
        TST     R6, #Vdu5Bit
        BNE     Vdu5HT
        BSR     CursorMove              ; try to move in appropriate direction
        MOVCC   PC, R14                 ; if successful, finish

        TST     R6, #1
        BNE     CHT10

        Push    R14
        BL      CursorB0                ; else move cursor to -ve X boundary
        BL      AddressCursor           ; re-address cursor
        Pull    R14
        B       VduLF                   ; and do a line-feed

; *****************************************************************************
;
;       Special BS - used when abnormal cursor direction selected
;                    or Vdu5 mode
;                    or if C81Bit was set
;
; in :  R6 = CursorFlags
;

SpecialBS
        TST     R6, #Vdu5Bit            ; VDU 5 mode ?
        BNE     Vdu5BS                  ; then branch

        TST     R6, #C81Bit             ; did we come here cos of C81Bit
        BICNE   R6, R6, #C81Bit         ; if so then clear the bit
        STRNE   R6, [WsPtr, #CursorFlags] ; store it back
        MOVNE   PC, R14                 ; and leave cursor where it is

        EOR     R6, R6, #6              ; move "left"
        Push    R14
        BL      CursorMove
        Pull    PC, CC                  ; if successful
        BL      CursorB0                ; move to +ve X boundary
        BL      AddressCursor           ; re-address cursor
        Pull    R14
        B       VT                      ; and do reverse line-feed

; *****************************************************************************
;
;       Special LF - used when abnormal cursor direction selected
;
; in :  R6 = CursorFlags
;

SpecialLF
        EOR     R6, R6, #8              ; move "down"
        Push    R14
        BL      CursorMove
        Pull    PC, CC                  ; if successful
        BL      CanScroll               ; see if we can scroll
        Pull    PC, CS                  ; if failed, exit with all done
        Pull    R14
        MOV     R0, #0                  ; scroll window
        MOV     R1, #7                  ; "up"
        MOV     R2, #0                  ; by 1 char
        B       Scroll012

; *****************************************************************************
;
;       Special VT - used when abnormal cursor direction selected
;
; in :  R6 = CursorFlags
;

SpecialVT
        EOR     R6, R6, #14             ; move "up"
        Push    R14
        BL      CursorMove
        Pull    PC, CC                  ; if successful
        BL      CanScroll               ; see if we can scroll
        Pull    PC, CS                  ; if failed, exit with all done
        Pull    R14
        MOV     R0, #0                  ; scroll window
        MOV     R1, #6                  ; "down"
        MOV     R2, #0                  ; by 1 char
        B       Scroll012

; *****************************************************************************
;
;       CanScroll - check whether we can scroll in direction R6
;
; in:   R6 = CursorFlags

CanScroll ROUT
        Push    R14
        TST     R6, #&10            ; do we scroll or move to other edge
        BNE     CantScroll

        TST     R6, #CursorsSplit
        BEQ     %FT10                   ; cursors not split, so input cursor
                                        ; not relevant
        EOR     R6, R6, #6
        BL      InputCursorMove         ; if cursor fails to move, it's OK
                                        ; where it is
        BL      AddressInputCursor      ; readdress it anyway, just in case
        EOR     R6, R6, #6              ; put R6 back
10
        CLC
        Pull    PC

CantScroll
        BL      CursorB0                ; move to opposite edge
        BL      AddressCursor
        SEC
        Pull    PC

; *****************************************************************************
;
;       Release any pending CRLF
;

RCRLF
        LDR     R6, [WsPtr, #CursorFlags]

; Extra entry point when R6 already loaded

RCRLFR6
        TST     R6, #C81Bit
        MOVEQ   PC, R14                 ; no pending CRLF
        BSR     CR10                    ; (clears C81Bit)
        B       VduLF

; *****************************************************************************
;
;       VDU 23,8,t1,t2,x1,y1,x2,y2| - Clear block of text
;
;       t=0     Top left of window
;       t=1     Top of cursor column
;       t=2     Off top right of window
;
;       t=4     Left end of cursor line
;       t=5     Cursor position
;       t=6     Off right of cursor line
;
;       t=8     Bottom left of window
;       t=9     Bottom of cursor column
;       t=10    Off bottom right of window
;

Vdu23_8
        MOV     R0, #0                  ; top left of window
        STRB    R0, [WsPtr, #CBWS+0]
        STRB    R0, [WsPtr, #CBWS+1]
        BSR     CP81                    ; cursor position
        STRB    R0, [WsPtr, #CBWS+2]
        STRB    R1, [WsPtr, #CBWS+3]
        BSR     WBotRig                 ; bottom right of window
        ADD     R0, R0, #1              ; off bottom right of window
        STRB    R0, [WsPtr, #CBWS+4]
        STRB    R1, [WsPtr, #CBWS+5]

        ADD     R3, WsPtr, #CBWS
        ADD     R2, R3, #QQ+2-CBWS
        LDRB    R0, [WsPtr, #QQ+1]      ; t1
        BSR     CLBL50
        LDRB    R0, [WsPtr, #QQ+2]      ; t2
        BSR     CLBL50

; Check end is after start

        LDRB    R2, [WsPtr, #CBStart]   ; start X
        LDRB    R3, [WsPtr, #CBStart+1] ; start Y
        LDRB    R4, [WsPtr, #CBEnd]     ; end X
        LDRB    R5, [WsPtr, #CBEnd+1]   ; end Y

        CMP     R5, R3
        CMPEQ   R4, R2
        MOVLS   PC, R14                 ; end <= start so do nothing

        LDR     R0, [WsPtr, #CursorX]   ; save cursor position
        LDR     R1, [WsPtr, #CursorY]
        Push    "R0,R1"

        MOV     R0, R3                  ; First row to clear
        MOV     R1, R2                  ; Start position for first row
        LDRB    R7, [WsPtr, #CBWS+4]    ; End position for all but last row

        ADD     R6, WsPtr, #TWLCol
        LDMIA   R6, {R8-R11}

        LDR     R6, [WsPtr, #CursorFlags]
CLBL20
        TEQ     R0, R5
        BEQ     CLBL40
        BSR     RowClear
        ADD     R0, R0, #1
        MOV     R1, #0                  ; start position for subsequent rows
        B       CLBL20

CLBL40
        MOV     R7, R4                  ; end position for last row
        BSR     RowClear

        Pull    "R0,R1"
        STR     R0, [WsPtr, #CursorX]
        STR     R1, [WsPtr, #CursorY]
        B       AddressCursor

CLBL50
        AND     R1, R0, #3
        MOV     R1, R1, LSL #1
        LDRB    R6, [WsPtr, #CBWS+4]
        BSR     CLBL60
        MOV     R1, R0, LSR #1
        ORR     R1, R1, #1
        LDRB    R6, [WsPtr, #CBWS+5]
CLBL60
        LDRB    R4, [R3, R1]            ; get base coordinate to use
        LDRB    R5, [R2, #1]!           ; get x or y offset

        MOV     R5, R5, LSL #24
        ADDS    R4, R4, R5, ASR #24     ; add sign extended offset to base
        MOVMI   R4, #0                  ; if <0 then make =0
        CMP     R4, R6
        MOVHI   R4, R6                  ; is this stringent enough ?

        STRB    R4, [R2, #CBStart-(QQ+3)]
        MOV     PC, R14

; *****************************************************************************
;
;       RowClear - Clear a "row" {R1 <= X < R7, Y = R0}

RowClear
        Push    "R0-R11,R14"
        SUB     R7, R7, #1
        CMP     R1, R7
        BHI     RowCL10         ; left > right, so ignore

        TST     R6, #8

        MOVEQ   R2, R1          ; left
        MOVEQ   R3, R0          ; bottom
        MOVEQ   R4, R7          ; right
        MOVEQ   R5, R0          ; top

        MOVNE   R2, R0          ; left
        MOVNE   R3, R7          ; bottom
        MOVNE   R4, R0          ; right
        MOVNE   R5, R1          ; top

        TST     R6, #2

        ADDEQ   R0, R8, R2
        ADDEQ   R2, R8, R4

        SUBNE   R0, R10, R4
        SUBNE   R2, R10, R2

        TST     R6, #4

        ADDEQ   R1, R11, R3
        ADDEQ   R3, R11, R5

        SUBNE   R1, R9, R5
        SUBNE   R3, R9, R3

        BL      ClearBox

RowCL10
        Pull    "R0-R11,PC"

; *****************************************************************************

DoReadPOSVPOSI ROUT
        MOV     R0, #0
        B       %FT05
DoReadPOSVPOSO
        MOV     R0, #1
05
        Push    "R4-R11, R14"
        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #CursorsSplit               ; if cursors are split
        TEQNE   R0, #1                          ; and reading input cursor
        BNE     %FT10                           ; then use input cursor
        BL      CP81                            ; else read output cursor
        B       %FT20
10
        BL      CP79
20
        MOV     R2, R1
        MOV     R1, R0
        Pull    "R4-R11, PC"

; *****************************************************************************
;
;       DoSetScreenStart - Set top of screen address (display + drivers)
;
; in:   R1 -> control block
;       [R1, #0] = bit mask;    bit 0 set => change drivers address
;                               bit 1 set => change display address
;
;       [R1, #1..4] = byte offset from lowest screen address
;
; out:  -
;

DoSetScreenStart ROUT
        Push    R14
        LDRB    R3, [R1, #0]                    ; R3 = bitmask
      [ NoARMv6 :LOR: NoUnaligned
        LDRB    R0, [R1, #1]
        LDRB    R2, [R1, #2]
        ORR     R0, R0, R2, LSL #8
        LDRB    R2, [R1, #3]
        ORR     R0, R0, R2, LSL #16
        LDRB    R2, [R1, #4]
        ORR     R0, R0, R2, LSL #24             ; R0 is now the offset
      |
        ; Use unaligned load from ARMv6
        LDR     R0, [R1, #1]
      ]
        LDR     R2, [WsPtr, #TotalScreenSize]
        CMP     R0, R2
        BCS     %FT10                           ; offset too large
        Push    "R0,R2,R3,R5-R10"

        MOV     R0, #1
        STRB    R0, [WsPtr, #ScreenMemoryClaimed]
                                                ; indicate memory not available
        BL      PreWrchCursor
        Pull    "R0,R2,R3,R5-R10"
        LDR     R14, [WsPtr, #ScreenEndAddr]
        ADD     R0, R0, R14
        SUB     R0, R0, R2                      ; make into a LOGRAM address

        TST     R3, #1
        BEQ     %FT05
        Push    R0
        BL      NewScreenStart
        Pull    R0
05
        TST     R3, #2
        BLNE    SetVinit               ; program vinit and set DisplayStart

        Push    "R5-R10"                        ; save registers
        BL      PostWrchCursor
        Pull    "R5-R10"
10
        Pull    PC

; *****************************************************************************
;
;       NewScreenStart - Update ScreenStart and readdress cursors
;
; in:   R0 = new screen start
;
; out:  R0, R2 corrupted; all others preserved
;

NewScreenStart ROUT
        Push    R14

        LDR     R2, [WsPtr, #DisplayScreenStart]
        BL      SetDisplayScreenStart
        LDR     R14, [WsPtr, #VduSprite]        ; test if outputting to sprite
        TEQ     R14, #0                         ; Z => outputting to screen
        MOVNE   PC, R14                 ; if outputting to sprite, don't update
                                        ; Screenstart or cursor addresses

        STR     R0, [WsPtr, #ScreenStart]
        SUB     R0, R0, R2                      ; R0 := new-old
AdjustCursorVars
        LDR     R14, [WsPtr, #CursorAddr]
        ADD     R14, R14, R0
        STR     R14, [WsPtr, #CursorAddr]
        LDR     R14, [WsPtr, #InputCursorAddr]
        ADD     R14, R14, R0
        STR     R14, [WsPtr, #InputCursorAddr]
        Pull    PC

; *****************************************************************************
;
;       DoSetDriverBank - Set VDU driver's screen bank (OSBYTE &70)
;
; in:   R1 = bank number (1..n) (NOTE: starts at 1)
;

DoSetDriverBank ROUT
        Push    R14
        MOVS    R2, R1
        BNE     %FT10
        LDR     R1, [WsPtr, #VduStatus]
        TST     R1, #Shadowing
        MOVEQ   R2, #1
        MOVNE   R2, #2
10
        LDR     R0, =ZeroPage
        LDRB    R1, [R0, #OsbyteVars + :INDEX: MemDriver] ; old value

        Push    "R1,R4-R10"             ; save registers
        BL      ConvertBankToAddress    ; R3 := start address of NEXT bank
        LDR     R14, [WsPtr, #ScreenEndAddr]
        CMP     R3, R14                 ; if after end, can't do it
        Pull    "R1,R4-R10,PC", HI      ; so exit

        STRB    R2, [WsPtr, #ScreenMemoryClaimed]
                                        ; indicate memory not available (R2<>0)
        STRB    R2, [R0, #OsbyteVars + :INDEX: MemDriver] ; store new value

        LDR     R0, [WsPtr, #DriverBankAddr] ; R0:=old default bank start
        LDR     R2, [WsPtr, #DisplayScreenStart] ; R2:=old current screen start
        SUB     R0, R2, R0              ; R0 := (current-default)
                                        ; in range 1-TotalSize..TotalSize-1

        LDR     R2, [WsPtr, #ScreenSize]
        SUB     R3, R3, R2              ; default start of THIS bank
        STR     R3, [WsPtr, #DriverBankAddr] ; R3 := new default bank start

        ADD     R0, R0, R3              ; new current start (not bound checked)

        LDR     R2, [WsPtr, #TotalScreenSize]

        RSBS    R0, R0, R14
        ADDLS   R0, R0, R2
        CMP     R0, R2
        SUBHI   R0, R0, R2              ; now in bounds (but inverted)
        RSB     R0, R0, R14

        Push    R0
        BL      PreWrchCursor
        Pull    R0

        BL      NewScreenStart

        BL      PostWrchCursor
        Pull    "R1,R4-R10,PC"

; *****************************************************************************
;
;       DoSetDisplayBank - Set displayed screen bank (OSBYTE &71)
;
; in:   R1 = bank number (1..n) (NOTE: starts at 1)
;

DoSetDisplayBank ROUT
        Push    R14
        MOVS    R2, R1
        BNE     %FT10
        LDR     R1, [WsPtr, #VduStatus]
        TST     R1, #Shadowing
        MOVEQ   R2, #1
        MOVNE   R2, #2
10
        LDR     R0, =ZeroPage
        LDRB    R1, [R0, #OsbyteVars + :INDEX: MemDisplay] ; old value
        Push    "R1,R4-R5"              ; save registers
        BL      ConvertBankToAddress    ; R3 := start address of NEXT bank
        LDR     R14, [WsPtr, #ScreenEndAddr]
        CMP     R3, R14                 ; if after end, can't do it
        Pull    "R1,R4-R5,PC", HI       ; so exit

        STRB    R2, [WsPtr, #ScreenMemoryClaimed]
                                        ; indicate memory not available (R2<>0)
        STRB    R2, [R0, #OsbyteVars + :INDEX: MemDisplay] ; store new value

        LDR     R0, [WsPtr, #DisplayBankAddr] ; R0 := old default bank start
        LDR     R2, [WsPtr, #DisplayStart]    ; R2 := old current display start
        SUB     R0, R2, R0              ; R0 := (current-default)
                                        ; in range 1-TotalSize..TotalSize-1

        LDR     R2, [WsPtr, #ScreenSize]
        SUB     R3, R3, R2              ; default start of THIS bank
        STR     R3, [WsPtr, #DisplayBankAddr] ; R3 := new default bank start

        ADD     R0, R0, R3              ; new current start (not bound checked)

        LDR     R2, [WsPtr, #TotalScreenSize]

        RSBS    R0, R0, R14
        ADDLS   R0, R0, R2
        CMP     R0, R2
        SUBHI   R0, R0, R2              ; now in bounds (but inverted)
        RSB     R0, R0, R14

        BL      SetVinit                ; program vinit and set DisplayStart
        Pull    "R1,R4-R5,PC"

; *****************************************************************************
;
;       CP81 - Read output cursor position,
;       taking C81Bit and CursorFlags into account
;
; out:  R0=X, R1=Y

CP81
        Push    R14
        BL      CP80
        LDR     R6, [WsPtr, #CursorFlags]
        TST     R6, #C81Bit
        ADDNE   R0, R0, #1                      ; in hidden column, so inc X
        Pull    PC

; *****************************************************************************
;
;       CP79 - Read input cursor position,
;       taking CursorFlags into account
;
; out:  R0=X, R1=Y

CP79
        MOV     R1, #InputCursorX-TWLCol
        B       CP80R1

; *****************************************************************************
;
;       WBotRig - Read coordinates of "bottom right" in user coords
;
; out:  R0=X, R1=Y

WBotRig
        ADD     R5, WsPtr, #TWLCol
        LDR     R6, [WsPtr, #CursorFlags]
        LDR     R0, [R5, #TWLCol-TWLCol]            ; get TWLCol
        LDR     R1, [R5, #TWRCol-TWLCol]            ; get TWRCol
        SUB     R4, R1, R0
        MOV     R2, #0
        MOV     R1, #0
        B       CP8010

; *****************************************************************************
;
;       CP80 - Read cursor position, taking CursorFlags into account

CP80
        MOV     R1, #CursorX-TWLCol
CP80R1
        ADD     R5, WsPtr, #TWLCol
        LDR     R6, [WsPtr, #CursorFlags]
        MOV     R2, #2
        MOV     R0, #0
        BSR     CP8020
        MOV     R4, R2
        MOV     R2, #4
CP8010
        ADD     R1, R1, #4
        MOV     R0, #TWTRow-TWLCol
        BSR     CP8020
        MOV     R0, R2
        MOV     R1, R2
        TST     R6, #8
        MOVEQ   R0, R4
        MOVNE   R1, R4

        MOV     PC, R14

CP8020
        TST     R2, R6
        EORNE   R0, R0, #8
        LDR     R2, [R5, R0]
        LDR     R3, [R5, R1]
        SUBNE   R2, R2, R3
        SUBEQ   R2, R3, R2
        MOV     PC, R14

; *****************************************************************************
;
;       Vdu23_0 - Program "6845"
;

Vdu23_0
        LDRB    R1, [WsPtr, #QQ+1]      ; get register number
        AND     R2, R1, #31             ; address register is 5 bits
        CMP     R2, #8
        MOVCC   PC, R14
        BEQ     Vdu23_0_8
        CMP     R2, #10
        BEQ     Vdu23_0_10
        CMP     R2, #12
        BCC     Vdu23_0_11

        B       UnknownVdu23


; *****************************************************************************
;
;       Vdu23_0_8 - Program interlace
;
; in:   R1 = unmasked register number (bits 5-7 may be set)

Vdu23_0_8 ROUT
        LDRB    R0, [WsPtr, #QQ+2]      ; value to program into interlace
        TST     R0, #&80                ; if negative, don't EOR with *TV
        TSTEQ   R1, #&E0                ; if not register 8, don't EOR
        BNE     %FT10                   ; don't EOR

        LDROSB  R1, TVInterlace
        TST     R1, #1
        EORNE   R0, R0, #1              ; toggle if *TV n,1 and number +ve
10
        Push    "R14"
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_SetInterlace
        BL      CallGraphicsV
        Pull    "PC"


; *****************************************************************************
;
;       Vdu23_9  - Equivalent of FX 9
;       Vdu23_10 - Equivalent of FX 10
;
; in:   R0 = 9 or 10
;

Vdu23_9
Vdu23_10
        Push    R14                             ; for the SWI
        LDRB    R1, [WsPtr, #QQ+1]              ; get X parameter
        SWI     XOS_Byte
        Pull    PC, VC                          ; no error, then return

        Pull    R14                             ; get stack back
        B       VduBadExit                      ; and tell the world

; *****************************************************************************
;
;       DoReadVDUStatus - Read VDU status
;
; out:  R1 = status
;       bit 0 set =>    printer enabled by VDU 2
;       bit 1 set =>    N/A
;       bit 2 set =>    in page mode
;       bit 3 set =>    text window in force
;       bit 4 set =>    in a shadow mode
;       bit 5 set =>    in VDU 5 mode
;       bit 6 set =>    cursor editing in progress
;       bit 7 set =>    VDU disabled (by VDU 21)
;
;       R2 corrupted
;

DoReadVDUStatus
        LDR     R1, [WsPtr, #VduStatus]         ; Vdu2, Window, Shadow bits

        LDR     R2, [WsPtr, #CursorFlags]

        TST     R2, #PageMode
        ORRNE   R1, R1, #&04

        TST     R2, #Vdu5Bit
        ORRNE   R1, R1, #&20

        TST     R2, #CursorsSplit
        ORRNE   R1, R1, #&40

        TST     R2, #VduDisabled
        ORRNE   R1, R1, #&80

        MOV     PC, R14

; *****************************************************************************
;
;       DoReadVDUVariable - Read BBC-style VDU variables
;
; in:   R1 = variable to read (only &00..&0F are supported)
;
; out:  R1 = value of that variable
;       R2 = value of next variable
;

DoReadVDUVariable
        CMP     R1, #(BBCVduVarsEnd-BBCVduVars)
        MOVCS   PC, R14                 ; don't support this variable
        ADR     R3, BBCVduVars          ; point to lookup table
        LDRB    R0, [R3, R1]!           ; get index for first variable
        LDRB    R1, [WsPtr, R0]         ; get first variable
        LDRB    R0, [R3, #1]            ; get index for second variable
        LDRB    R2, [WsPtr, R0]         ; get second variable
        MOV     PC, R14

BBCVduVars
        EQUB    GWLCol
        EQUB    GWLCol+1
        EQUB    GWBRow
        EQUB    GWBRow+1
        EQUB    GWRCol
        EQUB    GWRCol+1
        EQUB    GWTRow
        EQUB    GWTRow+1
        EQUB    TWLCol
        EQUB    TWBRow
        EQUB    TWRCol
        EQUB    TWTRow
        EQUB    OrgX
        EQUB    OrgX+1
        EQUB    OrgY
        EQUB    OrgY+1
BBCVduVarsEnd

; *****************************************************************************
;
;       SetCharSizes - Set char sizes for VDU 4 or VDU 5 text
;
; in:   QQ+2 = flags:   bit 0 set => set VDU 4 size
;                       bit 1 set => set VDU 5 size
;                       bit 2 set => set VDU 5 spacing
;       QQ+3,4  x size in pixels
;       QQ+5,6  y size in pixels
;

        ASSERT  YEigFactor = XEigFactor +4

SetCharSizes ROUT
        LDRB    R0, [WsPtr, #QQ+3]
        LDRB    R2, [WsPtr, #QQ+4]
        ORR     R0, R0, R2, LSL #8      ; R0 = x size

        LDRB    R1, [WsPtr, #QQ+5]
        LDRB    R2, [WsPtr, #QQ+6]
        ORR     R1, R1, R2, LSL #8      ; R1 = y size

        LDRB    R2, [WsPtr, #QQ+2]

        ADD     R3, WsPtr, #GCharSizes
        TST     R2, #2                  ; if modifying VDU 5 size
        STMNEIA R3, {R0, R1}

        ADD     R3, R3, #8
        TST     R2, #4                  ; if modifying VDU 5 spacing
        STMNEIA R3, {R0, R1}

        MOV     PC, R14

        END
@


4.5
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@a734 1
      [ HiResTTX
a735 3
      |
        LDR     R3, [WsPtr, #BytesPerChar]
      ]
a749 1
      [ HiResTTX
a750 3
      |
        LDR     R3, [WsPtr, #BytesPerChar]
      ]
a821 1
      [ HiResTTX
a822 3
      |
        LDR     R3, [WsPtr, #BytesPerChar]
      ]
@


4.4
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a1132 51
        [ :LNOT: AssemblingArthur

; *****************************************************************************
;
;       DoVduExternal - External entry point for
;       a) reading input cursor position
;       b) reading output cursor position
;       c) reading character at cursor position and screen mode
;       d) resetting all or part of font
;       e) reading font definitions
;       f) reading VDU status
;       g) reading VDU variables
;       h) reading palette (OSWORD &0B)
;       i) setting palette (OSWORD &0C)
;       j) various mouse/pointer stuff
;       k) set top of screen address
;       l) set VDU driver bank
;       m) set display bank
;
; in:   R0 = 0 => read input cursor position
;       R0 = 1 => read output cursor position
;       R0 = 2 => OSBYTE &87 - R1 := char at cursor, R2 := screen mode
;       R0 = 3 => reset font (R1*32 = start char, R2 = number of pages)
;       R0 = 4 => OSWORD 10 (R1 -> control block)
;       R0 = 5 => read VDU status
;       R0 = 6 => read VDU variables number R1, R1+1
;       R0 = 7 => read palette
;       R0 = 8 => set palette
;       R0 = 9 => mouse/pointer control
;       R0 = 10 => set top of screen address
;       R0 = 11 => set VDU driver bank
;       R0 = 12 => set display bank
;
; out:  a,b; R1 = X, R2 = Y
;       c; R1=char, R2=screen mode
;       f; R1=VDU status
;       g; R1=variable(n), R2=variable(n+1)
;       R0, R3 destroyed
;       R4-R11 preserved
;

DoVduExternal   ROUT
        CMP     R0, #ExtEntries
        MOVCS   PC, R14
        LDR     R3, [PC, R0, LSL #2]
        ADD     PC, PC, R3

ExtTable OutputExternals

        ]

a1441 5
        [ DoVdu23_0_12
        BEQ     Vdu23_0_12
        CMP     R2, #13
        BEQ     Vdu23_0_13
        ]
a1467 29
        [ DoVdu23_0_12

; *****************************************************************************
;
;       Vdu23_0_12 - Program "hi" byte of start of screen
;

Vdu23_0_12
        MOV     R2, #11                 ; starting bit number
V23012_10
        LDRB    R0, [WsPtr, #QQ+2]      ; get parameter
        LDR     R1, [WsPtr, #VinitCopy]
        MOV     R1, R1, ROR R2          ; move changing bits to bottom
        BIC     R1, R1, #&FF            ; clear old bits out
        ORR     R1, R1, R0              ; put in new bits
        RSB     R2, R2, #32             ; fudge cos we ain't got ROL
        MOV     R0, R1, ROR R2          ; put back to correct position
        B       SetVinitPhys

; *****************************************************************************
;
;       Vdu23_0_13 - Program "lo" byte of start of screen
;

Vdu23_0_13
        MOV     R2, #3                  ; starting bit number
        B       V23012_10

        ]
@


4.3
log
@  Added compile-time support for full-resolution teletext characters in
  teletext emulation mode (MODE 7) for that authentic BBC Micro feel.
  Also introduced a few useful teletext control features via VDU 23,18.
  Unrelatedly, fixed *ScreenLoad to work for interlaced displays.

Detail:
  The new typeface is designed on a 16x20 grid (previously we had used 8x10),
  so it uses a screen resolution of 640x500 pixels (rather than 320x250).
  Since we have been unable to source a genuine teletext font, and since
  examination of a BBC Micro suggests that the genuine font may not have been
  a power-of-2 pixels wide, I have designed one specially, based upon the one
  supplied in Zap distributions (a 12x20 font). Rather than increase the
  amount of workspace that the kernel requires for cacheing graphic
  characters, it now generates them on the fly, as they are required; this
  should only add about 25% to their rendering time.

  The new VDU 23 sequences are as follows:

  VDU 23,18,0,mode,0,0,0,0,0,0
    Switch transparency mode
      mode = 0: "Text" mode: the whole display is set opaque
      mode = 1: "Mix" mode: foreground colours, and both foreground and
        background of boxed text are opaque; non-boxed background colours are
        all transparent
      mode = 2: "Box" mode: boxed regions are opaque, others are transparent
      mode = 3: "TV" mode: the whole display is set transparent
    Default is mode = 0.

  VDU 23,18,1,suspend,0,0,0,0,0,0
    Suspend or resume bitmap updates
    This call allows an application to request that the kernel suspends
    updates to the framebuffer bitmap. This allows for a significant speed
    increase in the rendering time for a large amount of text, for example
    when redrawing a complete teletext page, because each time you plot a
    single character, it can cause the whole of the rest of the line to be
    re-rendered. When you switch out of suspend mode, the whole screen is
    refreshed in a single pass. Note that the appearance of the display is
    undefined is you cause a hardware scroll while in suspend mode.
      suspend = 0: screen update is enabled
      suspend = 1: screen update is suspended
    Default is suspend = 0.

  VDU 23,18,2,reveal,0,0,0,0,0,0
    Reveal/conceal
      reveal = 0: characters between the Conceal control code and the next
        colour control code are replaced by spaces
      reveal = 1: all characters are displayed
    Default is reveal = 0.

  VDU 23,18,3,black_emable,0,0,0,0,0,0
    Enable/disable black foreground colour control codes
      black_enable = 0: control codes &80 and &90 do nothing
      black_enable = 1: control code &80 selects black text, control code
        &90 selects black graphics
    Default is black_enable = 0.

  I have performed some timing tests on the rendering of complete teletext
  pages grabbed from the teletext server. These show that the new code
  generally imposes a 2x speed hit. However, when using the VDU 23,18,1
  suspend function, this improves to a 20% speed increase when compared to
  the old low-resolution code. Better still, because the framebuffer is only
  being updated for the final stage of this process, the screen *appears* to
  be updated some 3x faster than with the old code!

  A comment on the VDU variable Log2BPC is in order: in previous kernels,
  this was able unambiguously to refer to both the framebuffer width of a
  character in bytes, and the framebuffer width of an "addressable pixel" in
  bits; this no longer works with the 16-pixel wide teletext font. Bearing
  in mind that future kernels may support Unicode system fonts where the
  width varies from character to character, I have chosen to fix Log2BPC to
  the "addressable pixel" definition.

Admin:
  Requires HdrSrc 0.89 and (for non-desktop builds) Interlace 0.61. A monitor
  definition file containing a definition for a 640x500 screen mode is also
  required; version 0.40 of ModeFiles contains a suitable mode for STB-400.

  Tested fairly rigourously on an Ursula build, a Lazarus build and an
  STB-400 build, using genuine teletext pages and Yellow River Kingdom.

Version 5.30. Tagged as 'Kernel-5_30'
@
text
@d305 1
a305 6
        TST     R10, #Flag_BBCGapMode           ; if in BBC gap mode
 [ True

; TMD 23-May-89: BBC gap modes were done wrong here - it scrolled by 1/2 a
; BBC byte instead of 1

a306 3
 |
        MOVNE   R9, #1                          ; then 1 BBC byte = 2 ARM bytes
 ]
d455 1
a455 7
        TST     R10, #Flag_BBCGapMode           ; if in BBC gap mode

 [ True

; TMD 23-May-89: BBC gap modes were done wrong here - it scrolled by 1/2 a
; BBC byte instead of 1

a456 3
 |
        MOVNE   R9, #1                          ; then 1 BBC byte = 2 ARM bytes
 ]
d1222 1
d1230 4
d1244 2
a1245 1
        ADD     R0, R0, #ScreenEndAdr
d1273 1
a1273 2
        LDR     R2, [WsPtr, #VduSprite]         ; test if outputting to sprite
        TEQ     R2, #0                          ; Z => outputting to screen
d1276 3
a1278 1
        STR     R0, [WsPtr, #DisplayScreenStart]
a1283 1
        Push    R14
d1309 1
a1309 1
        MOV     R0, #0
d1314 2
a1315 1
        CMP     R3, #ScreenEndAdr       ; if after end, can't do it
d1335 1
a1335 1
        RSBS    R0, R0, #ScreenEndAdr
d1339 1
a1339 1
        RSB     R0, R0, #ScreenEndAdr
d1366 1
a1366 1
        MOV     R0, #0
d1370 3
a1372 2
        CMP     R3, #ScreenEndAdr       ; if after end, can't do it
        Pull    "R1,R4-R5,PC", HI      ; so exit
d1391 1
a1391 1
        RSBS    R0, R0, #ScreenEndAdr
d1395 1
a1395 1
        RSB     R0, R0, #ScreenEndAdr
d1517 6
a1522 8
        LDR     R1, [WsPtr, #VIDCControlCopy]
        BIC     R1, R1, #CR_Interlace
        TST     R0, #1
        ORRNE   R1, R1, #CR_Interlace    ; zero => no interlace

        MOV     R0, #VIDC
        STR     R1, [R0]                ; program VIDC
        MOV     PC, R14
@


4.3.2.1
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@d1526 4
a1529 4
        Push    "R0-R3, R9, R12, LR"
        mjsAddressHAL
        mjsCallHAL    HAL_Video_SetInterlace
        Pull    "R0-R3, R9, R12, LR"
d1531 2
@


4.3.2.2
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d1256 1
a1256 2
        LDR     R14, [WsPtr, #ScreenEndAddr]
        ADD     R0, R0, R14
d1325 1
a1325 2
        LDR     R14, [WsPtr, #ScreenEndAddr]
        CMP     R3, R14                 ; if after end, can't do it
d1345 1
a1345 1
        RSBS    R0, R0, R14
d1349 1
a1349 1
        RSB     R0, R0, R14
d1380 2
a1381 3
        LDR     R14, [WsPtr, #ScreenEndAddr]
        CMP     R3, R14                 ; if after end, can't do it
        Pull    "R1,R4-R5,PC", HI       ; so exit
d1400 1
a1400 1
        RSBS    R0, R0, R14
d1404 1
a1404 1
        RSB     R0, R0, R14
a1525 6
 [ UseGraphicsV
        Push    "R14"
        MOV     R4, #GraphicsV_SetInterlace
        BL      CallGraphicsV
        Pull    "R14"
 |
a1529 1
 ]
@


4.3.2.3
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d1285 2
a1286 1
        Push    R14
d1289 1
a1289 3
        BL      SetDisplayScreenStart
        LDR     R14, [WsPtr, #VduSprite]        ; test if outputting to sprite
        TEQ     R14, #0                         ; Z => outputting to screen
d1295 1
@


4.3.2.4
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@a1238 1
      [ NoARMv6 :LOR: NoUnaligned
a1245 4
      |
        ; Use unaligned load from ARMv6
        LDR     R0, [R1, #1]
      ]
d1321 1
a1321 1
        LDR     R0, =ZeroPage
d1378 1
a1378 1
        LDR     R0, =ZeroPage
@


4.3.2.5
log
@Rationalise some old switches.
Export less in hdr:RISCOS.
Delete unused GetDecimalPair routine.
Move CheckYear with other RTC stuff out of PMF/osword.
Hide DebugROMInit and DebugROMErrors in release (even numbered) versions.

Version 5.35, 4.79.2.127. Tagged as 'Kernel-5_35-4_79_2_127'
@
text
@d306 5
d312 3
d464 6
d471 3
@


4.3.2.5.2.1
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d1524 2
a1525 2
        AddressHAL
        CallHAL HAL_VideoSetInterlace
@


4.3.2.6
log
@Make Mike's macros permanent.
While the HAL and kernel were being split some temporary macros were used for the bits being worked on, after 12 years of use they're probably safe to adopt.
mjsCallHAL -> CallHAL; mjsAddressHAL -> AddressHAL; mjsHAL -> HAL.
OS_VIDCDividerSWI code now always does NoSuchSWI (had been switched out previously).
File vduhint.s no longer assembled (was empty).


Version 5.35, 4.79.2.150. Tagged as 'Kernel-5_35-4_79_2_150'
@
text
@d1524 2
a1525 2
        AddressHAL
        CallHAL HAL_Video_SetInterlace
@


4.3.2.7
log
@Make GraphicsV_IICOp more consistent
No accepts  r0 = b31-24 set 0
                 b23-16 fully qualified IIC address
                 b15-0  starting offset
            r1 = buffer pointer
            r2 = number of bytes to tranfer
            r4 = b31-24 display number
                 b23-16 head
                 b15-0  reason code (=14)
Now returns r0 = result codes as per HAL_IICTransfer()
            r1 = buffer pointer incremented by number of bytes transferred
            r2 = number of bytes *not* transferred
            r4 = 0
Removed '_' after Video in entry numbers to be consistent with other HAL entry naming, and HAL_VideoFlybackDevice.
Added IICStatus return numbers to Hdr:HALEntries.
Stop calling HAL_MonitorLeadID as only IOMD implemented it - just guess VGA until the graphics driver says otherwise.

Version 5.35, 4.79.2.159. Tagged as 'Kernel-5_35-4_79_2_159'
@
text
@d1525 1
a1525 1
        CallHAL HAL_VideoSetInterlace
@


4.3.2.8
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d305 1
a305 1
        TST     R10, #ModeFlag_BBCGapMode       ; if in BBC gap mode
d455 1
a455 1
        TST     R10, #ModeFlag_BBCGapMode       ; if in BBC gap mode
@


4.3.2.9
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d1517 1
d1519 1
a1519 3
        LDR     R4, [WsPtr, #CurrentGraphicsVDriver]
        MOV     R4, R4, LSL #24
        ORR     R4, R4, #GraphicsV_SetInterlace
d1521 9
a1529 1
        Pull    "PC"
@


4.3.2.3.2.1
log
@  Unaligned loads/stores optimised for ARMv6+
Detail:
  Having scanned the kernel source for unaligned load code fragments which
  would abort on ARMv6 and v7 and not having found any, I took the opportunity
  to give them build-time switches to use unaligned LDR((S)H)/STR(H)
  instructions if built for a new enough platform. Also added a couple of
  cases of LDRSB that will benefit v4 CPUs and a few instances of the v6
  SXTH instruction, but since objasm doesn't yet understand it (and when it
  does, not everyone will have upgraded) they are currently written as
  DCI statements.
  Most of the changes are to OS_Word handlers, which are notorious in that
  their input/output block is not word-aligned.
Admin:
  Not tested, but it should at least build.

Version 5.35, 4.79.2.98.2.6. Tagged as 'Kernel-5_35-4_79_2_98_2_6'
@
text
@a1238 1
      [ NoARMv6
a1245 4
      |
        ; Use unaligned load from ARMv6
        LDR     R0, [R1, #1]
      ]
@


4.3.2.3.2.2
log
@  Miscellaneous v6-related updates
Detail:
 * Stopped calling the broken abort fixup code when running under VMSAv6.
   Might be desirable to update it, possibly farmed out to a separate module -
   still need to think about this.
 * Unaligned load optimisations can now be disabled by the global NoUnaligned
   flag for testing purposes.
 * Extended OS_ReadUnsigned to permit reading of 64-bit unsigned integers.
   See Docs.ReadUnsigned for more details. Also sped it up by using MLA
   (or UMLAL) for most digits rather than repeated addition.
 * Bugfix is OS_GSRead: an uninitialised r0 was being passed to
   OS_ReadUnsigned, causing undesirable effects on rare occasions.
Admin:
  Tested on a rev B7 beagleboard.

Version 5.35, 4.79.2.98.2.8. Tagged as 'Kernel-5_35-4_79_2_98_2_8'
@
text
@d1239 1
a1239 1
      [ NoARMv6 :LOR: NoUnaligned
@


4.3.2.3.2.3
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d1326 1
a1326 1
        LDR     R0, =ZeroPage
d1383 1
a1383 1
        LDR     R0, =ZeroPage
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d752 3
d756 1
d771 3
d775 1
d847 3
d851 1
@


4.1
log
@Initial revision
@
text
@d157 1
a157 1
                                          
d162 1
a162 1
                               
d164 1
a164 1
                                     
d167 6
a172 3
        BLNE    CompileTextFg
        BLEQ    CompileTextBg                   ; update TextFgColour/TextBgColour

d188 1
a188 1
                                          
d1556 1
a1556 1
;       Vdu23_10 - Equivalent of FX 10 
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d1135 50
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

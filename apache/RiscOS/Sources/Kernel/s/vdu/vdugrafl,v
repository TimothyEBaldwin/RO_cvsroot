head	4.11;
access;
symbols
	Kernel-6_15:4.11
	Kernel-6_14:4.11
	Kernel-6_01-3:4.10
	Kernel-6_13:4.11
	Kernel-6_12:4.11
	Kernel-6_11:4.11
	Kernel-6_10:4.10
	Kernel-6_09:4.10
	Kernel-6_08-4_129_2_10:4.9.2.1
	Kernel-6_08-4_129_2_9:4.9.2.1
	Kernel-6_08:4.10
	Kernel-6_07:4.10
	Kernel-6_06:4.10
	Kernel-6_05-4_129_2_8:4.9.2.1
	Kernel-6_05:4.10
	Kernel-6_04:4.10
	Kernel-6_03:4.10
	Kernel-6_01-2:4.10
	Kernel-6_01-4_146_2_1:4.10
	Kernel-6_02:4.10
	Kernel-6_01-1:4.10
	Kernel-6_01:4.10
	Kernel-6_00:4.10
	Kernel-5_99:4.10
	Kernel-5_98:4.10
	Kernel-5_97-4_129_2_7:4.9.2.1
	Kernel-5_97:4.10
	Kernel-5_96:4.10
	Kernel-5_95:4.10
	Kernel-5_94:4.10
	Kernel-5_93:4.9
	Kernel-5_92:4.9
	Kernel-5_91:4.9
	Kernel-5_90:4.9
	Kernel-5_89-4_129_2_6:4.9
	Kernel-5_89:4.9
	Kernel-5_88-4_129_2_5:4.9
	Kernel-5_88-4_129_2_4:4.9
	Kernel-5_88:4.9
	Kernel-5_87:4.9
	Kernel-5_86-4_129_2_3:4.9
	Kernel-5_86-4_129_2_2:4.9
	Kernel-5_86-4_129_2_1:4.9
	Kernel-5_86:4.9
	SMP:4.9.0.2
	SMP_bp:4.9
	Kernel-5_85:4.9
	Kernel-5_54-1:4.6
	Kernel-5_84:4.9
	Kernel-5_83:4.9
	Kernel-5_82:4.9
	Kernel-5_81:4.8
	Kernel-5_80:4.8
	Kernel-5_79:4.8
	Kernel-5_78:4.8
	Kernel-5_77:4.8
	Kernel-5_76:4.8
	Kernel-5_75:4.8
	Kernel-5_74:4.7
	Kernel-5_73:4.6
	Kernel-5_72:4.6
	Kernel-5_71:4.6
	Kernel-5_70:4.6
	Kernel-5_69:4.6
	Kernel-5_68:4.6
	Kernel-5_67:4.6
	Kernel-5_66:4.6
	Kernel-5_65:4.6
	Kernel-5_64:4.6
	Kernel-5_63:4.6
	Kernel-5_62:4.6
	Kernel-5_61:4.6
	Kernel-5_60:4.6
	Kernel-5_59:4.6
	Kernel-5_58:4.6
	Kernel-5_57:4.6
	Kernel-5_56:4.6
	Kernel-5_55:4.6
	Kernel-5_54:4.6
	Kernel-5_53:4.6
	Kernel-5_52:4.6
	Kernel-5_51:4.6
	Kernel-5_50:4.6
	Kernel-5_49:4.5
	HAL_merge:4.4.2.7
	Kernel-5_48:4.5
	Kernel-5_35-4_79_2_327:4.4.2.7
	Kernel-5_35-4_79_2_326:4.4.2.7
	Kernel-5_35-4_79_2_325:4.4.2.7
	Kernel-5_35-4_79_2_324:4.4.2.7
	Kernel-5_35-4_79_2_323:4.4.2.7
	Kernel-5_35-4_79_2_322:4.4.2.7
	Kernel-5_35-4_79_2_321:4.4.2.7
	Kernel-5_35-4_79_2_320:4.4.2.7
	Kernel-5_35-4_79_2_319:4.4.2.7
	Kernel-5_35-4_79_2_318:4.4.2.7
	Kernel-5_35-4_79_2_317:4.4.2.7
	Kernel-5_35-4_79_2_316:4.4.2.7
	Kernel-5_35-4_79_2_315:4.4.2.7
	Kernel-5_35-4_79_2_314:4.4.2.7
	Kernel-5_35-4_79_2_313:4.4.2.7
	Kernel-5_35-4_79_2_312:4.4.2.7
	Kernel-5_35-4_79_2_311:4.4.2.7
	Kernel-5_35-4_79_2_310:4.4.2.7
	Kernel-5_35-4_79_2_309:4.4.2.7
	Kernel-5_35-4_79_2_308:4.4.2.7
	Kernel-5_35-4_79_2_307:4.4.2.7
	Kernel-5_35-4_79_2_306:4.4.2.7
	Kernel-5_35-4_79_2_305:4.4.2.7
	Kernel-5_35-4_79_2_304:4.4.2.7
	Kernel-5_35-4_79_2_303:4.4.2.7
	Kernel-5_35-4_79_2_302:4.4.2.7
	Kernel-5_35-4_79_2_301:4.4.2.7
	Kernel-5_35-4_79_2_300:4.4.2.7
	Kernel-5_35-4_79_2_299:4.4.2.7
	Kernel-5_35-4_79_2_298:4.4.2.7
	Kernel-5_35-4_79_2_297:4.4.2.7
	Kernel-5_35-4_79_2_296:4.4.2.7
	Kernel-5_35-4_79_2_295:4.4.2.7
	Kernel-5_35-4_79_2_294:4.4.2.7
	Kernel-5_35-4_79_2_293:4.4.2.7
	Kernel-5_35-4_79_2_292:4.4.2.7
	Kernel-5_35-4_79_2_291:4.4.2.7
	Kernel-5_35-4_79_2_290:4.4.2.7
	Kernel-5_35-4_79_2_289:4.4.2.7
	Kernel-5_35-4_79_2_288:4.4.2.7
	Kernel-5_35-4_79_2_287:4.4.2.7
	Kernel-5_35-4_79_2_286:4.4.2.7
	Kernel-5_35-4_79_2_285:4.4.2.7
	Kernel-5_35-4_79_2_284:4.4.2.7
	Kernel-5_35-4_79_2_283:4.4.2.7
	Kernel-5_35-4_79_2_282:4.4.2.7
	Kernel-5_35-4_79_2_281:4.4.2.7
	Kernel-5_35-4_79_2_280:4.4.2.7
	Kernel-5_35-4_79_2_279:4.4.2.7
	Kernel-5_35-4_79_2_278:4.4.2.7
	Kernel-5_35-4_79_2_277:4.4.2.7
	Kernel-5_35-4_79_2_276:4.4.2.7
	Kernel-5_35-4_79_2_275:4.4.2.7
	Kernel-5_35-4_79_2_274:4.4.2.7
	Kernel-5_35-4_79_2_273:4.4.2.7
	Kernel-5_35-4_79_2_272:4.4.2.7
	Kernel-5_35-4_79_2_271:4.4.2.7
	Kernel-5_35-4_79_2_270:4.4.2.7
	Kernel-5_35-4_79_2_269:4.4.2.7
	Kernel-5_35-4_79_2_268:4.4.2.7
	Kernel-5_35-4_79_2_267:4.4.2.7
	Kernel-5_35-4_79_2_266:4.4.2.7
	Kernel-5_35-4_79_2_265:4.4.2.7
	Kernel-5_35-4_79_2_264:4.4.2.7
	Kernel-5_35-4_79_2_263:4.4.2.7
	Kernel-5_35-4_79_2_262:4.4.2.7
	Kernel-5_35-4_79_2_261:4.4.2.7
	Kernel-5_35-4_79_2_260:4.4.2.7
	Kernel-5_35-4_79_2_259:4.4.2.7
	Kernel-5_35-4_79_2_258:4.4.2.7
	Kernel-5_35-4_79_2_257:4.4.2.7
	Kernel-5_35-4_79_2_256:4.4.2.7
	Kernel-5_35-4_79_2_255:4.4.2.7
	Kernel-5_35-4_79_2_254:4.4.2.7
	Kernel-5_35-4_79_2_253:4.4.2.7
	Kernel-5_35-4_79_2_252:4.4.2.7
	Kernel-5_35-4_79_2_251:4.4.2.7
	Kernel-5_35-4_79_2_250:4.4.2.7
	Kernel-5_35-4_79_2_249:4.4.2.7
	Kernel-5_35-4_79_2_248:4.4.2.7
	Kernel-5_35-4_79_2_247:4.4.2.7
	Kernel-5_35-4_79_2_246:4.4.2.7
	Kernel-5_35-4_79_2_245:4.4.2.7
	Kernel-5_35-4_79_2_244:4.4.2.7
	Kernel-5_35-4_79_2_243:4.4.2.7
	Kernel-5_35-4_79_2_242:4.4.2.7
	Kernel-5_35-4_79_2_241:4.4.2.7
	Kernel-5_35-4_79_2_240:4.4.2.7
	Kernel-5_35-4_79_2_239:4.4.2.7
	Kernel-5_35-4_79_2_238:4.4.2.7
	Kernel-5_35-4_79_2_237:4.4.2.7
	Kernel-5_35-4_79_2_236:4.4.2.7
	Kernel-5_35-4_79_2_235:4.4.2.7
	Kernel-5_35-4_79_2_234:4.4.2.7
	Kernel-5_35-4_79_2_233:4.4.2.7
	Kernel-5_35-4_79_2_232:4.4.2.7
	Kernel-5_35-4_79_2_231:4.4.2.7
	Kernel-5_35-4_79_2_230:4.4.2.7
	Kernel-5_35-4_79_2_229:4.4.2.7
	Kernel-5_35-4_79_2_228:4.4.2.7
	Kernel-5_35-4_79_2_227:4.4.2.7
	Kernel-5_35-4_79_2_226:4.4.2.7
	Kernel-5_35-4_79_2_225:4.4.2.7
	Kernel-5_35-4_79_2_224:4.4.2.7
	Kernel-5_35-4_79_2_223:4.4.2.7
	Kernel-5_35-4_79_2_222:4.4.2.7
	Kernel-5_35-4_79_2_221:4.4.2.7
	Kernel-5_35-4_79_2_220:4.4.2.7
	Kernel-5_35-4_79_2_219:4.4.2.7
	Kernel-5_35-4_79_2_218:4.4.2.7
	Kernel-5_35-4_79_2_217:4.4.2.7
	Kernel-5_35-4_79_2_216:4.4.2.7
	Kernel-5_35-4_79_2_215:4.4.2.7
	Kernel-5_35-4_79_2_214:4.4.2.7
	Kernel-5_35-4_79_2_213:4.4.2.7
	Kernel-5_35-4_79_2_212:4.4.2.7
	Kernel-5_35-4_79_2_211:4.4.2.7
	Kernel-5_35-4_79_2_210:4.4.2.7
	Kernel-5_35-4_79_2_209:4.4.2.6
	Kernel-5_35-4_79_2_208:4.4.2.6
	Kernel-5_35-4_79_2_207:4.4.2.6
	Kernel-5_35-4_79_2_206:4.4.2.6
	Kernel-5_35-4_79_2_205:4.4.2.6
	Kernel-5_35-4_79_2_204:4.4.2.6
	Kernel-5_35-4_79_2_203:4.4.2.6
	Kernel-5_35-4_79_2_202:4.4.2.6
	Kernel-5_35-4_79_2_201:4.4.2.6
	Kernel-5_35-4_79_2_200:4.4.2.6
	Kernel-5_35-4_79_2_199:4.4.2.6
	Kernel-5_35-4_79_2_198:4.4.2.6
	Kernel-5_35-4_79_2_197:4.4.2.6
	Kernel-5_35-4_79_2_196:4.4.2.6
	Kernel-5_35-4_79_2_195:4.4.2.6
	Kernel-5_35-4_79_2_194:4.4.2.6
	Kernel-5_35-4_79_2_193:4.4.2.5
	Kernel-5_35-4_79_2_192:4.4.2.5
	Kernel-5_35-4_79_2_191:4.4.2.5
	Kernel-5_35-4_79_2_190:4.4.2.5
	Kernel-5_35-4_79_2_189:4.4.2.5
	Kernel-5_35-4_79_2_188:4.4.2.5
	Kernel-5_35-4_79_2_187:4.4.2.5
	Kernel-5_35-4_79_2_186:4.4.2.5
	Kernel-5_35-4_79_2_185:4.4.2.5
	Kernel-5_35-4_79_2_184:4.4.2.5
	Kernel-5_35-4_79_2_183:4.4.2.5
	Kernel-5_35-4_79_2_182:4.4.2.5
	Kernel-5_35-4_79_2_181:4.4.2.5
	Kernel-5_35-4_79_2_180:4.4.2.5
	Kernel-5_35-4_79_2_179:4.4.2.5
	Kernel-5_35-4_79_2_178:4.4.2.5
	Kernel-5_35-4_79_2_177:4.4.2.5
	Kernel-5_35-4_79_2_176:4.4.2.5
	Kernel-5_35-4_79_2_175:4.4.2.5
	Kernel-5_35-4_79_2_174:4.4.2.5
	Kernel-5_35-4_79_2_173:4.4.2.5
	Kernel-5_35-4_79_2_172:4.4.2.5
	Kernel-5_35-4_79_2_171:4.4.2.5
	Kernel-5_35-4_79_2_170:4.4.2.5
	Kernel-5_35-4_79_2_169:4.4.2.5
	Kernel-5_35-4_79_2_168:4.4.2.5
	Kernel-5_35-4_79_2_167:4.4.2.5
	Kernel-5_35-4_79_2_166:4.4.2.5
	Kernel-5_35-4_79_2_165:4.4.2.5
	RPi_merge:4.4.2.5
	Kernel-5_35-4_79_2_147_2_23:4.4.2.5
	Kernel-5_35-4_79_2_147_2_22:4.4.2.5
	Kernel-5_35-4_79_2_147_2_21:4.4.2.5
	Kernel-5_35-4_79_2_147_2_20:4.4.2.5
	Kernel-5_35-4_79_2_147_2_19:4.4.2.5
	Kernel-5_35-4_79_2_147_2_18:4.4.2.5
	Kernel-5_35-4_79_2_164:4.4.2.5
	Kernel-5_35-4_79_2_163:4.4.2.5
	Kernel-5_35-4_79_2_147_2_17:4.4.2.5
	Kernel-5_35-4_79_2_147_2_16:4.4.2.5
	Kernel-5_35-4_79_2_147_2_15:4.4.2.5
	Kernel-5_35-4_79_2_162:4.4.2.5
	Kernel-5_35-4_79_2_161:4.4.2.5
	Kernel-5_35-4_79_2_147_2_14:4.4.2.5
	Kernel-5_35-4_79_2_147_2_13:4.4.2.5
	Kernel-5_35-4_79_2_160:4.4.2.5
	Kernel-5_35-4_79_2_159:4.4.2.5
	Kernel-5_35-4_79_2_158:4.4.2.5
	Kernel-5_35-4_79_2_157:4.4.2.5
	Kernel-5_35-4_79_2_156:4.4.2.5
	Kernel-5_35-4_79_2_147_2_12:4.4.2.5
	Kernel-5_35-4_79_2_147_2_11:4.4.2.5
	Kernel-5_35-4_79_2_155:4.4.2.5
	Kernel-5_35-4_79_2_147_2_10:4.4.2.5
	Kernel-5_35-4_79_2_154:4.4.2.5
	Kernel-5_35-4_79_2_153:4.4.2.5
	Kernel-5_35-4_79_2_147_2_9:4.4.2.5
	Kernel-5_35-4_79_2_152:4.4.2.5
	Kernel-5_35-4_79_2_151:4.4.2.5
	Kernel-5_35-4_79_2_147_2_8:4.4.2.5
	Kernel-5_35-4_79_2_147_2_7:4.4.2.5
	Kernel-5_35-4_79_2_150:4.4.2.5
	Kernel-5_35-4_79_2_147_2_6:4.4.2.5
	Kernel-5_35-4_79_2_147_2_5:4.4.2.5
	Kernel-5_35-4_79_2_149:4.4.2.5
	Kernel-5_35-4_79_2_147_2_4:4.4.2.5
	Kernel-5_35-4_79_2_147_2_3:4.4.2.5
	Kernel-5_35-4_79_2_148:4.4.2.5
	Kernel-5_35-4_79_2_147_2_2:4.4.2.5
	Kernel-5_35-4_79_2_147_2_1:4.4.2.5
	RPi:4.4.2.5.0.2
	RPi_bp:4.4.2.5
	Kernel-5_35-4_79_2_98_2_52_2_1:4.4.2.3.2.1
	alees_Kernel_dev:4.4.2.3.2.1.0.2
	alees_Kernel_dev_bp:4.4.2.3.2.1
	Kernel-5_35-4_79_2_147:4.4.2.5
	Kernel-5_35-4_79_2_146:4.4.2.5
	Kernel-5_35-4_79_2_145:4.4.2.5
	Kernel-5_35-4_79_2_144:4.4.2.5
	Kernel-5_35-4_79_2_143:4.4.2.5
	Kernel-5_35-4_79_2_142:4.4.2.5
	Kernel-5_35-4_79_2_141:4.4.2.5
	Kernel-5_35-4_79_2_140:4.4.2.5
	Kernel-5_35-4_79_2_139:4.4.2.5
	Kernel-5_35-4_79_2_138:4.4.2.5
	Kernel-5_35-4_79_2_137:4.4.2.5
	Kernel-5_35-4_79_2_136:4.4.2.5
	Kernel-5_35-4_79_2_135:4.4.2.5
	Kernel-5_35-4_79_2_134:4.4.2.5
	Kernel-5_35-4_79_2_133:4.4.2.5
	Kernel-5_35-4_79_2_132:4.4.2.5
	Kernel-5_35-4_79_2_131:4.4.2.5
	Kernel-5_35-4_79_2_130:4.4.2.5
	Kernel-5_35-4_79_2_129:4.4.2.5
	Kernel-5_35-4_79_2_128:4.4.2.5
	Kernel-5_35-4_79_2_127:4.4.2.5
	Kernel-5_35-4_79_2_126:4.4.2.5
	Kernel-5_35-4_79_2_125:4.4.2.5
	Kernel-5_35-4_79_2_124:4.4.2.5
	Kernel-5_35-4_79_2_123:4.4.2.4
	Cortex_merge:4.4.2.3.2.1
	Kernel-5_35-4_79_2_122:4.4.2.3
	Kernel-5_35-4_79_2_98_2_54:4.4.2.3.2.1
	Kernel-5_35-4_79_2_98_2_53:4.4.2.3.2.1
	Kernel-5_35-4_79_2_98_2_52:4.4.2.3.2.1
	Kernel-5_35-4_79_2_98_2_51:4.4.2.3.2.1
	Kernel-5_35-4_79_2_98_2_50:4.4.2.3.2.1
	Kernel-5_35-4_79_2_98_2_49:4.4.2.3.2.1
	Kernel-5_35-4_79_2_98_2_48:4.4.2.3.2.1
	Kernel-5_35-4_79_2_121:4.4.2.3
	Kernel-5_35-4_79_2_98_2_47:4.4.2.3
	Kernel-5_35-4_79_2_120:4.4.2.3
	Kernel-5_35-4_79_2_98_2_46:4.4.2.3
	Kernel-5_35-4_79_2_119:4.4.2.3
	Kernel-5_35-4_79_2_98_2_45:4.4.2.3
	Kernel-5_35-4_79_2_98_2_44:4.4.2.3
	Kernel-5_35-4_79_2_118:4.4.2.3
	Kernel-5_35-4_79_2_98_2_43:4.4.2.3
	Kernel-5_35-4_79_2_117:4.4.2.3
	Kernel-5_35-4_79_2_116:4.4.2.3
	Kernel-5_35-4_79_2_98_2_42:4.4.2.3
	Kernel-5_35-4_79_2_115:4.4.2.3
	Kernel-5_35-4_79_2_98_2_41:4.4.2.3
	Kernel-5_35-4_79_2_98_2_40:4.4.2.3
	Kernel-5_35-4_79_2_114:4.4.2.3
	Kernel-5_35-4_79_2_98_2_39:4.4.2.3
	Kernel-5_35-4_79_2_98_2_38:4.4.2.3
	Kernel-5_35-4_79_2_113:4.4.2.3
	Kernel-5_35-4_79_2_112:4.4.2.3
	Kernel-5_35-4_79_2_98_2_37:4.4.2.3
	Kernel-5_35-4_79_2_98_2_36:4.4.2.3
	Kernel-5_35-4_79_2_98_2_35:4.4.2.3
	Kernel-5_35-4_79_2_98_2_34:4.4.2.3
	Kernel-5_35-4_79_2_98_2_33:4.4.2.3
	Kernel-5_35-4_79_2_98_2_32:4.4.2.3
	Kernel-5_35-4_79_2_98_2_31:4.4.2.3
	Kernel-5_35-4_79_2_98_2_30:4.4.2.3
	Kernel-5_35-4_79_2_98_2_29:4.4.2.3
	Kernel-5_35-4_79_2_98_2_28:4.4.2.3
	Kernel-5_35-4_79_2_98_2_27:4.4.2.3
	Kernel-5_35-4_79_2_98_2_26:4.4.2.3
	Kernel-5_35-4_79_2_111:4.4.2.3
	Kernel-5_35-4_79_2_98_2_25:4.4.2.3
	Kernel-5_35-4_79_2_98_2_24:4.4.2.3
	Kernel-5_35-4_79_2_98_2_23:4.4.2.3
	Kernel-5_35-4_79_2_110:4.4.2.3
	Kernel-5_35-4_79_2_98_2_22:4.4.2.3
	Kernel-5_35-4_79_2_109:4.4.2.3
	Kernel-5_35-4_79_2_98_2_21:4.4.2.3
	Kernel-5_35-4_79_2_98_2_20:4.4.2.3
	Kernel-5_35-4_79_2_108:4.4.2.3
	Kernel-5_35-4_79_2_107:4.4.2.3
	Kernel-5_35-4_79_2_98_2_19:4.4.2.3
	Kernel-5_35-4_79_2_98_2_18:4.4.2.3
	Kernel-5_35-4_79_2_98_2_17:4.4.2.3
	Kernel-5_35-4_79_2_98_2_16:4.4.2.3
	Kernel-5_35-4_79_2_98_2_15:4.4.2.3
	Kernel-5_35-4_79_2_106:4.4.2.3
	Kernel-5_35-4_79_2_105:4.4.2.3
	Kernel-5_35-4_79_2_104:4.4.2.3
	Kernel-5_35-4_79_2_98_2_14:4.4.2.3
	Kernel-5_35-4_79_2_98_2_13:4.4.2.3
	Kernel-5_35-4_79_2_98_2_12:4.4.2.3
	Kernel-5_35-4_79_2_98_2_11:4.4.2.3
	Kernel-5_35-4_79_2_98_2_10:4.4.2.3
	Kernel-5_35-4_79_2_98_2_9:4.4.2.3
	Kernel-5_35-4_79_2_103:4.4.2.3
	Kernel-5_35-4_79_2_102:4.4.2.3
	Kernel-5_35-4_79_2_98_2_8:4.4.2.3
	Kernel-5_35-4_79_2_98_2_7:4.4.2.3
	Kernel-5_35-4_79_2_98_2_6:4.4.2.3
	Kernel-5_35-4_79_2_98_2_5:4.4.2.3
	Kernel-5_35-4_79_2_98_2_4:4.4.2.3
	Kernel-5_35-4_79_2_101:4.4.2.3
	Kernel-5_35-4_79_2_100:4.4.2.3
	Kernel-5_35-4_79_2_99:4.4.2.3
	Kernel-5_35-4_79_2_98_2_3:4.4.2.3
	Kernel-5_35-4_79_2_98_2_2:4.4.2.3
	Kernel-5_35-4_79_2_98_2_1:4.4.2.3
	Cortex:4.4.2.3.0.2
	Cortex_bp:4.4.2.3
	Kernel-5_35-4_79_2_98:4.4.2.3
	Kernel-5_35-4_79_2_97:4.4.2.3
	Kernel-5_35-4_79_2_96:4.4.2.3
	Kernel-5_35-4_79_2_95:4.4.2.3
	Kernel-5_35-4_79_2_94:4.4.2.3
	Kernel-5_35-4_79_2_93:4.4.2.3
	Kernel-5_35-4_79_2_92:4.4.2.3
	Kernel-5_35-4_79_2_91:4.4.2.3
	Kernel-5_35-4_79_2_90:4.4.2.3
	Kernel-5_35-4_79_2_89:4.4.2.3
	Kernel-5_35-4_79_2_88:4.4.2.3
	Kernel-5_35-4_79_2_87:4.4.2.3
	Kernel-5_35-4_79_2_86:4.4.2.3
	Kernel-5_35-4_79_2_85:4.4.2.3
	Kernel-5_35-4_79_2_84:4.4.2.3
	Kernel-5_35-4_79_2_83:4.4.2.3
	Kernel-5_35-4_79_2_82:4.4.2.3
	Kernel-5_35-4_79_2_81:4.4.2.3
	Kernel-5_35-4_79_2_80:4.4.2.3
	Kernel-5_35-4_79_2_79:4.4.2.3
	Kernel-5_35-4_79_2_78:4.4.2.3
	Kernel-5_35-4_79_2_77:4.4.2.3
	RO_5_07:4.4.2.3
	Kernel-5_35-4_79_2_76:4.4.2.3
	Kernel-5_35-4_79_2_75:4.4.2.3
	Kernel-5_35-4_79_2_74:4.4.2.3
	Kernel-5_35-4_79_2_73:4.4.2.3
	Kernel-5_35-4_79_2_72:4.4.2.3
	Kernel-5_35-4_79_2_71:4.4.2.3
	Kernel-5_35-4_79_2_70:4.4.2.3
	Kernel-5_35-4_79_2_69:4.4.2.3
	Kernel-5_35-4_79_2_68:4.4.2.3
	Kernel-5_35-4_79_2_67:4.4.2.3
	Kernel-5_35-4_79_2_66:4.4.2.3
	Kernel-5_35-4_79_2_65:4.4.2.3
	Kernel-5_35-4_79_2_64:4.4.2.3
	Kernel-5_35-4_79_2_63:4.4.2.3
	Kernel-5_35-4_79_2_62:4.4.2.3
	Kernel-5_35-4_79_2_61:4.4.2.3
	Kernel-5_35-4_79_2_59:4.4.2.3
	Kernel-5_35-4_79_2_58:4.4.2.3
	Kernel-5_35-4_79_2_57:4.4.2.3
	Kernel-5_35-4_79_2_56:4.4.2.3
	Kernel-5_35-4_79_2_55:4.4.2.3
	Kernel-5_35-4_79_2_54:4.4.2.3
	Kernel-5_35-4_79_2_53:4.4.2.3
	Kernel-5_35-4_79_2_52:4.4.2.2
	Kernel-5_35-4_79_2_51:4.4.2.2
	Kernel-5_35-4_79_2_50:4.4.2.2
	Kernel-5_35-4_79_2_49:4.4.2.2
	Kernel-5_35-4_79_2_48:4.4.2.2
	Kernel-5_47:4.4
	Kernel-5_46-4_90_2_1:4.4
	nbingham_Kernel_FastNC_dev_bp:4.4
	nbingham_Kernel_FastNC_dev:4.4.0.4
	Kernel-5_46:4.4
	Kernel-5_45:4.4
	Kernel-5_35-4_79_2_47:4.4.2.1
	Kernel-5_35-4_79_2_46:4.4.2.1
	Kernel-5_35-4_79_2_45:4.4.2.1
	Kernel-5_35-4_79_2_44:4.4.2.1
	Kernel-5_35-4_79_2_25_2_2:4.4.2.1
	Kernel-5_35-4_79_2_43:4.4.2.1
	Kernel-5_35-4_79_2_42:4.4.2.1
	Kernel-5_35-4_79_2_41:4.4.2.1
	Kernel-5_35-4_79_2_40:4.4.2.1
	Kernel-5_35-4_79_2_39:4.4.2.1
	Kernel-5_35-4_79_2_38:4.4.2.1
	Kernel-5_35-4_79_2_37:4.4.2.1
	Kernel-5_35-4_79_2_36:4.4.2.1
	Kernel-5_35-4_79_2_35:4.4.2.1
	Kernel-5_35-4_79_2_34:4.4.2.1
	Kernel-5_35-4_79_2_33:4.4.2.1
	Kernel-5_35-4_79_2_32:4.4.2.1
	Kernel-5_44:4.4
	Kernel-5_35-4_79_2_25_2_1:4.4.2.1
	Kernel-5_43:4.4
	Kernel-5_35-4_79_2_31:4.4.2.1
	Kernel-5_35-4_79_2_30:4.4.2.1
	Kernel-5_35-4_79_2_29:4.4.2.1
	Kernel-5_35-4_79_2_28:4.4.2.1
	Kernel-5_35-4_79_2_27:4.4.2.1
	Kernel-5_35-4_79_2_26:4.4.2.1
	Kernel-5_42:4.4
	Kernel-5_41:4.4
	Kernel-5_40:4.4
	Kernel-5_35-4_79_2_25:4.4.2.1
	Kernel-5_35-4_79_2_24:4.4.2.1
	Kernel-5_35-4_79_2_23:4.4.2.1
	Kernel-5_35-4_79_2_22:4.4.2.1
	Kernel-5_35-4_79_2_21:4.4.2.1
	Kernel-5_35-4_79_2_20:4.4.2.1
	Kernel-5_35-4_79_2_19:4.4.2.1
	Kernel-5_35-4_79_2_18:4.4.2.1
	Kernel-5_35-4_79_2_17:4.4.2.1
	Kernel-5_35-4_79_2_16:4.4.2.1
	Kernel-5_35-4_79_2_15:4.4.2.1
	Kernel-5_35-4_79_2_14:4.4.2.1
	Kernel-5_39:4.4
	Kernel-5_13-4_52_2_1:4.2
	Bethany:4.2.0.8
	Kernel-5_38:4.4
	Kernel-5_35-4_79_2_13:4.4.2.1
	Kernel-5_35-4_79_2_12:4.4.2.1
	Kernel-5_35-4_79_2_11:4.4.2.1
	Kernel-5_37:4.4
	Kernel-5_35-4_79_2_10:4.4.2.1
	Kernel-5_35-4_79_2_9:4.4
	Kernel-5_36:4.4
	Kernel-5_35-4_79_2_8:4.4
	Kernel-5_35-4_79_2_7:4.4
	Kernel-5_35-4_79_2_6:4.4
	Kernel-5_35-4_79_2_5:4.4
	Kernel-5_35-4_79_2_4:4.4
	Kernel-5_35-4_79_2_3:4.4
	Kernel-5_35-4_79_2_2:4.4
	dellis_autobuild_BaseSW:4.4
	Kernel-5_35-4_79_2_1:4.4
	HAL:4.4.0.2
	Kernel-5_35:4.4
	Kernel-5_34:4.4
	Kernel-5_33:4.4
	Kernel-5_32:4.4
	Kernel-5_31:4.4
	Kernel-5_30:4.4
	Kernel-5_29:4.3
	Kernel-5_28:4.3
	Kernel-5_27:4.3
	Kernel-5_26:4.3
	Kernel-5_25:4.3
	Kernel-5_24:4.3
	Kernel-5_23:4.3
	Kernel-5_22:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Kernel-5_21:4.2
	Kernel-5_20:4.2
	Kernel-5_19:4.2
	Kernel-5_18:4.2
	Kernel-5_17:4.2
	Kernel-5_16:4.2
	Kernel-5_15:4.2
	Kernel-5_14:4.2
	Kernel-5_13:4.2
	Kernel-5_12:4.2
	Kernel-5_11:4.2
	Kernel-5_10:4.2
	Kernel-5_09:4.2
	Kernel-5_08:4.2
	Kernel-5_07:4.2
	Kernel-5_06:4.2
	Kernel-5_05:4.2
	Kernel-5_04:4.2
	Kernel-5_03:4.2
	Kernel-5_02:4.2
	Kernel-5_01:4.2
	Kernel-5_00:4.2
	Kernel-4_99:4.2
	Kernel-4_98:4.2
	Kernel-4_97:4.2
	Kernel-4_96:4.2
	Kernel-4_95:4.2
	Kernel-4_94:4.2
	Kernel-4_93:4.2
	Kernel-4_92:4.2
	Kernel-4_91:4.2
	Kernel-4_90:4.2
	dcotton_autobuild_BaseSW:4.4
	Kernel-4_89:4.2
	Kernel-4_88:4.2
	Kernel-4_87:4.2
	Kernel-4_86:4.2
	Kernel-4_85:4.2
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.1.2.1
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.1.2.1
	Ursula_RiscPC_bp:4.2.2.1
	Kernel-4_83:4.2
	Kernel-4_82:4.2
	Kernel-4_81:4.2
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.2
	Ursula_merge:4.2
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.2.2.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	mstphens_Kernel-3_80:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	2018.07.14.19.02.27;	author jlee;	state Exp;
branches;
next	4.10;
commitid	DsDtaR4YavfJx8KA;

4.10
date	2018.01.26.00.10.48;	author jlee;	state Exp;
branches;
next	4.9;
commitid	N4RJQzHGK1PlIjoA;

4.9
date	2017.06.07.20.45.31;	author jlee;	state Exp;
branches
	4.9.2.1;
next	4.8;
commitid	u2lBBGPD3exe2uUz;

4.8
date	2016.12.17.18.33.46;	author jlee;	state Exp;
branches;
next	4.7;
commitid	gK0l0oJHtyZOPmyz;

4.7
date	2016.12.15.15.27.03;	author jlee;	state Exp;
branches;
next	4.6;
commitid	SNoEvPlWCrTKR5yz;

4.6
date	2016.06.30.20.42.11;	author jlee;	state Exp;
branches;
next	4.5;
commitid	bDF3DCxdmyMD0xcz;

4.5
date	2016.06.30.20.08.19;	author jlee;	state Exp;
branches;
next	4.4;
commitid	IWoXxARWeuLDOwcz;

4.4
date	2000.06.28.16.12.26;	author bavison;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	2000.04.04.14.27.42;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.07.36;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.40;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.9.2.1
date	2018.02.16.00.01.46;	author jlee;	state Exp;
branches;
next	;
commitid	L7HYXYTsWSFlZ0rA;

4.4.2.1
date	2000.10.16.12.35.53;	author mstephen;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2002.10.07.17.29.45;	author kbracey;	state Exp;
branches;
next	4.4.2.3;

4.4.2.3
date	2002.12.18.22.18.33;	author bavison;	state Exp;
branches
	4.4.2.3.2.1;
next	4.4.2.4;

4.4.2.4
date	2011.11.26.21.11.28;	author jlee;	state Exp;
branches;
next	4.4.2.5;
commitid	cI3W0zbtALQG6TIv;

4.4.2.5
date	2011.11.27.11.48.21;	author rsprowson;	state Exp;
branches;
next	4.4.2.6;
commitid	OFgqaKhOb6swXXIv;

4.4.2.6
date	2013.08.06.22.43.10;	author jlee;	state Exp;
branches;
next	4.4.2.7;
commitid	TOIaeUf2Q4rBIr0x;

4.4.2.7
date	2014.03.09.15.57.03;	author jlee;	state Exp;
branches;
next	;
commitid	FnXbK143NQLRy2sx;

4.4.2.3.2.1
date	2011.08.08.23.28.38;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

4.2.2.1
date	97.09.09.13.34.46;	author mstphens;	state Exp;
branches
	4.2.2.1.2.1;
next	4.2.2.2;

4.2.2.2
date	98.09.24.13.17.50;	author mstphens;	state Exp;
branches;
next	;

4.2.2.1.2.1
date	98.11.23.14.59.43;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.40;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.03.29;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.13.22;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.49;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Evict ECFIndex and PalIndex from VDU workspace
Detail:
  ECFIndex and PalIndex claim to be mode variables, but it's impossible for extension modes to specify their values.
  Since they're easy to calculate from the ModeFlags and Log2BPP values, drop them from the mode workspace (+ table of builtin modes) and calculate them on the fly instead.
  File changes:
  - hdr/KernelWS - Drop ECFIndex & PalIndex from workspace
  - s/vdu/vdumodes - Adjust workspace definition, drop ECFIndex & PalIndex values from VWSTAB
  - s/vdu/vdudriver - Remove now-redundant copy loop from ModeChangeSub. Remove code from GenerateModeSelectorVars that sets up the ECFIndex & PalIndex values on the stack
  - s/vdu/vdugrafl - Adjust copy loop in SwitchOutputToSprite/Mask
  - s/vdu/vdupalette, s/vdu/vdupalxx - Add GetPalIndex routine to generate PalIndex on the fly. Drop the obsolete 16bpp palette/gamma table and shuffle the other entries to simplify GetPalIndex a bit.
  - s/vdu/vduplot - Add GetECFIndex routine to generate ECFIndex on the fly. Also, fix things so that mode 0 isn't the only rectangular-pixel mode which uses the special rectangular-pixel ECF patterns (index 0 vs. index 4). Fiddle with ExportedHLine a bit to avoid an out-of-range ADR.
  - s/NewReset - Fix UAL warning for MOV R0, AppSpaceStart. Adjust memset to not assume 512KB is the correct amount
Admin:
  Tested on Raspberry Pi 3


Version 6.11. Tagged as 'Kernel-6_11'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.VduGrafL
;
; ARTHUR OPERATING SYSTEM - Vdu Drivers
; =======================
;
; Vdu driver code - Sprite stuff
;
; Author T M Dobson
; Date   22-Sep-87
;

; *****************************************************************************
;
;       ReadSaveAreaSize - Read size of a VDU context save area
;
; in:   R0 = SpriteReason_ReadSaveAreaSize
;       R1 -> sprite area
;       R2 -> sprite (0 => screen (possibly))
;
; out:  R3 = size of an area suitable for this sprite
;

ReadSaveAreaSize ROUT
        MOV     R3, #MainSize           ; I was kidding about it depending
        STR     R3, [WsPtr, #RetnReg3]  ; on the sprite!
        MOV     PC, R14

; *****************************************************************************
;
;       SwitchOutputToSprite - Make VDU(graphics) output go to a sprite
;
;       External routine
;
; in:   R0 = SpriteReason_SwitchOutputTo <Sprite or Mask>
;       R1 -> sprite area
;       R2 -> sprite (0 => screen)
;       R3 -> save area for VDU variables relating to sprite
;        0 => no save area, initialise variables from mode number of sprite
;             or display mode number
;        1 => use MOS's save area
;
;       First word of save area = 0      => uninitialised save area
;                                 "VOTS" => initialised save area
;                                 else error
;

; From Medusa onwards, things are further complicated here by the fact that
; the sprite may have a new sprite mode word rather than a mode number. When
; the former case occurs calling pushmodeinfoanymonitor doesn't really help
; very much. Instead, when a sprite mode word is given, it will derive or
; fudge all the variables that it is really interested from the sprite mode
; word directly.

SwitchOutputToSprite ROUT
SwitchOutputToMask ROUT
        CMP     R3, #1                  ; check for values 0 and 1
        MOVCC   R4, #0                  ; R3=0 => no save area, so not inited

        ADDEQ   R5, WsPtr, #VduSaveArea ; R3=1 => MOS's area
        MOVHI   R5, R3                  ; else user area
        LDRCS   R4, [R5, #InitFlag]     ; if is an area, load R4 with init flag
        LDR     R5, VOTS                ; compare with initialised identifier
        TEQ     R4, R5                  ; if not initialised
        TEQNE   R4, #0                  ; and not uninitialised
        BNE     InvalidSaveArea

; no more errors can be generated, so update returned registers

        ADD     R5, WsPtr, #VduOutputCurrentState
        LDMIA   R5, {R6-R9}
        ADD     R5, WsPtr, #RetnReg0
        STMIA   R5, {R6-R9}

        Push    "R0-R4,R14"

        ASSERT  SpriteMaskSelect = VduOutputCurrentState +0
        ASSERT  VduSpriteArea    = VduOutputCurrentState + 4
        ASSERT  VduSprite        = VduOutputCurrentState + 8

        ORR     R0, R0, #RangeC         ; make R0 into &2nn

        ADD     R5, WsPtr, #VduOutputCurrentState
        STMIA   R5, {R0-R2}

        BL      PreWrchCursor           ; remove cursor
        BL      PackVars                ; save away current vars into save area
                                        ; (if any)
        Pull    "R0-R4"
        STR     R3, [WsPtr, #VduSaveAreaPtr] ; save new save area ptr

        TEQ     R2, #0                  ; if switching to screen
        LDREQ   R9, [WsPtr, #DisplayScreenStart] ; then load up new ScreenStart
        LDREQ   R11, [WsPtr, #DisplayModeNo] ; and mode number
        BEQ     %FT20                   ; and skip sprite stuff

; do stuff for switching to sprite

        Push    R0
        BL      RemoveLeftHandWastage   ; then remove LH wastage from sprite
        Pull    R0                      ; (spLBit := 0)

        ASSERT  spHeight = spWidth +4
        ASSERT  spLBit   = spWidth +8
        ASSERT  spRBit   = spWidth +12
        ASSERT  spImage  = spWidth +16
        ASSERT  spTrans  = spWidth +20
        ASSERT  spMode   = spWidth +24

        ADD     R5, R2, #spWidth        ; R5=width:R6=height:R7=LBit(=0)
        LDMIA   R5, {R5-R11}            ; R8=RBit:R9=Image:R10=Trans:R11=Mode

        TEQ     R0, #SpriteReason_SwitchOutputToMask
        BNE     %FT23

        MOV     R9, R10                 ; point at mask instead of image
        MOVS    R0, R11, LSR #27
        BEQ     %FT23                   ; check for old format masks

        BL      GetMaskspWidth          ; adjust R5 and R8 to mask dimensions
        AND     R10, R11, #15<<27
        TEQ     R10, #SpriteType_RISCOS5<<27
        BEQ     %FT21
        TST     R11, #&80000000
        BIC     R11, R11, #&F8000000    ; wipe existing sprite type
        ORREQ   R11, R11, #SpriteType_New1bpp<<27 ; force to 1bpp
        ORRNE   R11, R11, #SpriteType_New8bpp<<27 ; force to 8bpp
        B       %FT23
21
        TST     R11, #&80000000
        AND     R11, R11, #&F0          ; preserve DPI fields, modeflags + original type must go
        ORR     R11, R11, #1+(SpriteType_RISCOS5<<27) ; mark as RO5 format
        ORREQ   R11, R11, #SpriteType_New1bpp<<20 ; force to 1bpp
        ORRNE   R11, R11, #SpriteType_New8bpp<<20 ; force to 8bpp
23
        ADD     R9, R9, R2              ; R9 -> sprite data or mask
20

        MOV     R10, R11
        BL      PushModeInfoAnyMonitor
        STRVS   R0, [WsPtr, #RetnReg0]
        Pull    "PC", VS

        STR     R9, [WsPtr, #ScreenStart]
        STR     R11, [WsPtr, #ModeNo]           ; new mode number

        MOV     R11, R13

        ; If we're switching output to screen, either find our values from the
        ; pushed mode info or from the saved DisplayXXX values.
        ; DisplayXXX is needed for any values which might differ from one
        ; display driver to another, but care is needed because ModeChangeSub
        ; actually calls us during the mode change to set up some of the
        ; variables (so need to make sure that any DisplayXXX values are set
        ; before we get called).
        ; Also note that we can't replace the above PushModeInfoAnyMonitor call
        ; with PushModeInfo (to get accurate values for the current display
        ; driver) because ScreenModes might not be running with the same MDF
        ; as when the original call was made.
        TEQ     R2, #0
        LDREQ   R5, [R12, #DisplayLineLength]
        LDREQ   R6, [R11, #wkYWindLimit]
        LDREQ   R7, [R11, #wkXWindLimit]
        LDREQ   R8, [R11, #wkScrRCol]
        LDREQ   R10, [R11, #wkScrBRow]
        BEQ     %FT30

        ; OK, we're switching to a sprite, so calculate the above values from
        ; the sprite header
        ADD     R5, R5, #1
        MOV     R5, R5, LSL #2                  ; R5 = width in bytes

        ADD     R7, R8, R5, LSL #3              ; R7 = LineLength*8 + spRBit
        SUB     R7, R7, #31                     ; R7=active area width in bits

        LDR     R8, [R11, #wkLog2BPC]
        MOV     R7, R7, LSR R8                  ; R7 = width in pixels
        MOV     R8, R7, LSR #3                  ; R8 = width in text columns
        SUB     R7, R7, #1                      ; R7 = max value of GWRCol

        SUB     R8, R8, #1                      ; R8 = max column number

        ADD     R10, R6, #1                     ; R10 = no. of pixel rows
        MOV     R10, R10, LSR #3                ; R10 = number of char rows
        SUB     R10, R10, #1                    ; R4 = maximum row number

30
        STR     R5, [WsPtr, #LineLength]
        STR     R6, [WsPtr, #YWindLimit]
        STR     R7, [WsPtr, #XWindLimit]
        STR     R8, [WsPtr, #ScrRCol]
        STR     R10, [WsPtr, #ScrBRow]

        ADD     R11, R11, #wkmiddle
        MOV     R0, #wkmidend-wkmiddle  ; number of bytes to do
        ASSERT  :INDEX: wkmiddle == :INDEX: wkNColour
        ADD     R1, WsPtr, #NColour     ; first mode variable that we do

40
        LDR     R5, [R11], #4           ; copy byte from mode table
        STR     R5, [R1], #4            ; into word variable
        SUBS    R0, R0, #4              ; decrement count
        BNE     %BT40                   ; loop until finished

        ADD     R13, R13, #PushedInfoSize       ; junked stacked info

; now create other variables from simple ones

        LDR     R0, [WsPtr, #Log2BPP]
        LDR     R1, [WsPtr, #Log2BPC]
        LDR     R5, [WsPtr, #XEigFactor]
        LDR     R6, [WsPtr, #ModeFlags]
        TEQ     R2, #0
        ORRNE   R6, R6, #ModeFlag_HardScrollDisabled ; if sprite then disable hard scroll
        STR     R6, [WsPtr, #ModeFlags]

        ;if switching to a sprite, check for full palette 8bpp, and set modeflags and
        ;NColour to suit.

        TEQ     R2, #0
        BEQ     %FT65                   ; switching to a sprite ?

        ADD     R7, R2, #spImage        ; point R7 at the image/mask start pair
        LDMIA   R7, {R7, LR}            ; fetch them
        CMP     R7, LR                  ; which is lower
        MOVGT   R7, LR                  ; use the lowest
        SUB     R7, R7, #spPalette      ; get the size of the palette

        CMP     R0, #3
        BNE     %FT51                   ; which is 8bpp ?

        CMP     R7, #&800               ; full 8bpp palette ?
        BNE     %FT51

        ORR     R6, R6, #ModeFlag_FullPalette
        STR     R6, [WsPtr, #ModeFlags] ; set the full palette flag

        MOV     LR, #255
        STR     LR, [WsPtr, #NColour]   ; and set the number of colours
51
        LDRB    LR, [WsPtr, #SpriteMaskSelect]
        TEQ     LR, #SpriteReason_SwitchOutputToSprite
        BEQ     %FT52
        LDR     LR, [R2, #spMode]
        TST     LR, #&80000000
        ORRNE   R6, R6, #ModeFlag_GreyscalePalette+ModeFlag_FullPalette ; alpha masks are 256 greyscale
        STRNE   R6, [WsPtr, #ModeFlags]
        MOVNE   LR, #255
        STRNE   LR, [WsPtr, #NColour]
        B       %FT65
52
        ; Redirecting to sprite image, check for greyscale palette
        CMP     R0, #3
        BHI     %FT65
        TSTEQ   R6, #ModeFlag_FullPalette ; 63 colour can't be greyscale
        TEQNE   R7, #0                    ; If no palette then (probably) also not greyscale
        BEQ     %FT65                   
        ADD     R8, R2, #spPalette
53
        LDR     LR, [R8], #4
        EOR     LR, LR, LR, LSL #8
        CMP     LR, #&10000
        BHS     %FT65
        SUBS    R7, R7, #4
        BGT     %BT53
        ORR     R6, R6, #ModeFlag_GreyscalePalette
        STR     R6, [WsPtr, #ModeFlags]        

65
        TST     R6, #ModeFlag_DoubleVertical
        ADREQL  R7, WrchNbitTab         ; point to correct table
        ADRNEL  R7, WrchNbitDoubleTab
        LDR     R8, [R7, R1, LSL #2]    ; get offset to correct code
        ADD     R8, R8, R7              ; convert to absolute address
        STR     R8, [WsPtr, #WrchNbit]

        ADRL    R7, CursorNbitTab
        LDR     R8, [R7, R1, LSL #2]
        ADD     R8, R8, R7
        TST     R6, #ModeFlag_Teletext
        ADRNEL  R8, CursorTeletext
        STR     R8, [WsPtr, #CursorNbit]

        TST     R6, #ModeFlag_NonGraphic
        MOVEQ   R7, #32                 ; if graphic mode
        MOVEQ   R7, R7, LSR R1          ; then = (32 >> lbpc)-1
        SUBEQ   R7, R7, #1
        MOVNE   R7, #0                  ; else = 0 ;;; NOT REALLY SAFE BET ANYMORE!!!
        STR     R7, [WsPtr, #NPix]

        RSB     R7, R1, #5              ; XShftFactor = 5-log2bpc
        STR     R7, [WsPtr, #XShftFactor]

        LDR     R7, [WsPtr, #YEigFactor]
        SUBS    R7, R5, R7              ; XEigFactor-YEigFactor
        MOVLT   R7, #2                  ; X<Y => 2 (vert rect)
        MOVGT   R7, #1                  ; X>Y => 1 (horz rect)
                                        ; else X=Y => 0 (square)
        STR     R7, [WsPtr, #AspectRatio]

        MOV     R8, #1
        MOV     R7, R8, LSL R0          ; bpp = 1 << lbpp
        STR     R7, [WsPtr, #BitsPerPix]

        MOV     R7, R8, LSL R1          ; bpc = 1 << lbpc
        STR     R7, [WsPtr, #BytesPerChar]

      [ HiResTTX
        TST     R6, #ModeFlag_Teletext  ; in teletext mode
        MOVNE   R7, R7, LSL #1          ; characters are 16 pixels, not 8
      ]
        STR     R7, [WsPtr, #CharWidth]

        TST     R6, #ModeFlag_BBCGapMode ; is it a BBC gap mode ?
        MOVNE   R7, #&55                ; yes, then use colour 1
        BNE     %FT70
        TEQ     R0, #2                  ; if (1<<2=4) bits per pixel
        MOVEQ   R7, #&77                ; then use colour 7 for cursor
        MOVNE   R7, #&FF                ; else use colour 15
      [ HiResTTX
        TST     R6, #ModeFlag_Teletext  ; unless it's 256 colour teletext
        BEQ     %FT70
        TEQ     R0, #3
        MOVEQ   R7, #&07                ; in which case still use colour 7
      ]
70
        ORR     R7, R7, R7, LSL #8      ; fill out to whole word
        ORR     R7, R7, R7, LSL #16
        STR     R7, [WsPtr, #CursorFill]

        TST     R6, #ModeFlag_DoubleVertical
        MOVEQ   R7, #8                  ; if single vertical then 8 pixels
        MOVNE   R7, #16                 ; if double vertical then 16 pixels
        STR     R7, [WsPtr, #TCharSizeY]
        TST     R6, #ModeFlag_GapMode
        ADDNE   R7, R7, R7, LSR #2      ; make 10 or 20 if gap mode
        STR     R7, [WsPtr, #RowMult]
        STR     R7, [WsPtr, #TCharSpaceY]
        MOV     R8, #8
      [ HiResTTX
        TST     R6, #ModeFlag_Teletext
        MOVNE   R8, #16
      ]
        STR     R8, [WsPtr, #TCharSizeX]
        STR     R8, [WsPtr, #TCharSpaceX]

        LDR     R8, [WsPtr, #LineLength]
        MUL     R7, R8, R7
        STR     R7, [WsPtr, #RowLength]

        ANDS    R14, R6, #ModeFlag_Teletext
        BEQ     %FT71
        ; Calculate TextOffset necessary to center the text window
        ; First, Y offset
        LDR     R7, [WsPtr, #RowMult]
        LDR     R14, [WsPtr, #ScrBRow]
        ADD     R14, R14, #1
        MUL     R14, R7, R14            ; text window height, pixels
        LDR     R7, [WsPtr, #YWindLimit]
        ADD     R7, R7, #1
        SUBS    R14, R7, R14            ; spare rows on screen
        ORRNE   R6, R6, #ModeFlag_HardScrollDisabled ; Disable hard scroll if there's any gap (we don't clear the border when scrolling!)
        MOV     R14, R14, LSR #1
        MUL     R14, R8, R14            ; byte offset to start at correct row
        ; Now, X offset
        LDR     R7, [WsPtr, #TCharSpaceX]
        LDR     R8, [WsPtr, #ScrRCol]
        ADD     R8, R8, #1
        MUL     R8, R7, R8              ; text window width, pixels
        LDR     R7, [WsPtr, #XWindLimit]
        ADD     R7, R7, #1
        SUBS    R8, R7, R8              ; spare columns on screen
        ORRNE   R6, R6, #ModeFlag_HardScrollDisabled
        MOV     R8, R8, LSR #1
        LDR     R7, [WsPtr, #Log2BPP]
        MOV     R8, R8, LSL R7          ; spare bits on row
        ADD     R14, R14, R8, LSR #3    ; combine with vertical offset
        BIC     R14, R14, #3            ; TTX assumes word alignment
        STR     R6, [WsPtr, #DisplayModeFlags] ; Write back the potentially-updated flags to DisplayModeFlags, since we're going to use that to reload ModeFlags below (assuming we aren't attempting TTX in a sprite!)
71
        STR     R14, [WsPtr, #TextOffset]

; finished doing other variables

        SWI     XColourTrans_InvalidateCache    ; let ColourTrans know we've changed mode
                                                ; so that colours get set up correctly

        TEQ     R4, #0                  ; initialising from a save area ?
        BEQ     %FT80                   ; no, then set to defaults

        BL      UnpackVars
        BL      AddressCursors
        BL      ValidateVars
        BL      PlainBit
        BL      SetColour
        LDR     R6, [WsPtr, #CursorFlags]
        ORR     R6, R6, #TEUpdate       ; TextExpand needs updating
        STR     R6, [WsPtr, #CursorFlags]
        B       %FT90
80

; *****Change made by DJS
; Original code was:
;        MOV     R0, #0
;        STR     R0, [WsPtr, #ECFShift]
;        STR     R0, [WsPtr, #ECFYOffset]
; This needed to be changed to make the bottom left of the screen (rather
; than the top left) be the default ECF origin.
        LDR     R0, [WsPtr, #YWindLimit]
        ADD     R0, R0, #1
        AND     R0, R0, #7
        STR     R0, [WsPtr, #ECFYOffset]
        MOV     R0, #0
        STR     R0, [WsPtr, #ECFShift]
; *****End of change made by DJS

        STR     R0, [WsPtr, #ClipBoxEnable]
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
      ]
        STRB    R0, [R0, #OsbyteVars + :INDEX: VDUqueueItems]

        MOV     R0, #8
        STR     R0, [WsPtr, #GCharSizeX]        ; chars are 8x8 by default
        STR     R0, [WsPtr, #GCharSizeY]
        STR     R0, [WsPtr, #GCharSpaceX]       ; and with 8x8 spacing
        STR     R0, [WsPtr, #GCharSpaceY]

        LDR     R1, [WsPtr, #ModeFlags]

        LDR     R0, [WsPtr, #CursorFlags]
        BIC     R0, R0, #(ActualState :OR: Vdu5Bit)
        BIC     R0, R0, #(CursorsSplit :OR: PageMode :OR: TeletextMode :OR: ClipBoxEnableBit)
        TST     R1, #ModeFlag_Teletext          ; is it teletext ?
        ORRNE   R0, R0, #TeletextMode           ; yes, then set bit
        STR     R0, [WsPtr, #CursorFlags]
        ADRNE   LR, %FT85
        BNE     TeletextInit                    ; (re-)initialise TTX if appropriate
        ; Not teletext mode. If we're switching output to screen, then we might
        ; be in the middle of a mode change from TTX to regular, so free any
        ; old TTX workspace.
        LDR     R2, [WsPtr, #VduSprite]
        TEQ     R2, #0
        BLEQ    TeletextFinalise
85

        BL      InitCursor                      ; initialise cursor after
                                                ; cursorflags
        BL      PlainBit                ; also sets up RAMMaskTb
        BL      DefaultColours          ; N.B. SetColour is called by both
        BL      DefaultEcfPattern       ; of these.
        BL      DefaultLineStyle
        BL      DefaultWindows
        BL      Home
90
        ; If we've just switched back to the screen, make sure the greyscale palette flag is accurate. Easiest way is to copy DisplayModeFlags into ModeFlags.
        ; (n.b. see also code above which deliberately updates DisplayModeFlags if in TTX)
        LDR     R2, [WsPtr, #VduSprite]
        TEQ     R2, #0
        LDREQ   R2, [WsPtr, #DisplayModeFlags]
        STREQ   R2, [WsPtr, #ModeFlags]
        BL      PostWrchCursor

        MOV     R1, #Service_SwitchingOutputToSprite    ; call Ran's service
        ADD     R2, WsPtr, #VduOutputCurrentState
        LDMIA   R2, {R2-R5}                             ; load the registers that were in R0-R3 on entry
        IssueService

        Pull    R14
        RETURNVC

InvalidSaveArea
        ADRL    R0, SpriteErr_InvalidSaveArea
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        STR     R0, [WsPtr, #RetnReg0]
        RETURNVS

VOTS    =       "VOTS"


; *****************************************************************************

; Specially saved items

                        ^       0
InitFlag                #       4       ; 0 => uninit, "VOTS" => init
SavedSpoolFileH         #       1       ; an OSBYTE variable
SavedWrchDest           #       1       ; --------""--------
SavedVDUqueueItems      #       1       ; --------""--------
                        #       1       ; padding to word align it
SavedDataOffset         #       0       ; start of compressed data

        GBLA    FirstOffset
        GBLA    NextOffset
        GBLA    CompressedSize

        MACRO
        CompStart
FirstOffset SETA -1
NextOffset SETA -1
CompressedSize SETA 0
        MEND

        MACRO
        Compress $v0, $v1, $v2, $v3, $v4, $v5, $v6, $v7
        [ "$v0"<>""
        Compo $v0
        ]
        [ "$v1"<>""
        Compo $v1
        ]
        [ "$v2"<>""
        Compo $v2
        ]
        [ "$v3"<>""
        Compo $v3
        ]
        [ "$v4"<>""
        Compo $v4
        ]
        [ "$v5"<>""
        Compo $v5
        ]
        [ "$v6"<>""
        Compo $v6
        ]
        [ "$v7"<>""
        Compo $v7
        ]
        MEND

        MACRO
        Compo   $var
        [ FirstOffset <> -1
         [ $var = NextOffset
NextOffset SETA ($var)+4
         |
         DCW FirstOffset
         DCW NextOffset
CompressedSize SETA CompressedSize + (NextOffset-FirstOffset)
FirstOffset SETA $var
NextOffset SETA ($var)+4
         ]
        |
FirstOffset SETA $var
NextOffset SETA ($var)+4
        ]
        MEND

        MACRO
        CompMult $start, $size
        [ FirstOffset <> -1
         [ $start = NextOffset
NextOffset SETA $start + $size
         |
         DCW FirstOffset
         DCW NextOffset
CompressedSize SETA CompressedSize + (NextOffset-FirstOffset)
FirstOffset SETA $start
NextOffset SETA $start + $size
         ]
        |
FirstOffset SETA $start
NextOffset SETA $start + $size
        ]
        MEND

        MACRO
        CompRange $start, $end
        CompMult $start, ($end+4-$start)
        MEND

        MACRO
        CompEnd
        [ FirstOffset <> -1
        DCW FirstOffset
        DCW NextOffset
CompressedSize SETA CompressedSize + (NextOffset-FirstOffset)
        ]
        &       -1
        MEND

CompressionTable
        CompStart

;        CompMult  FgEcf, 8*4        ; recreated from GCOLs + ecfs by
;        CompMult  BgEcf, 8*4        ; call to SetColour

        Compress  GPLFMD, GPLBMD, GFCOL, GBCOL, GWLCol, GWBRow, GWRCol, GWTRow
        CompRange qqqPad, JVec

;        Compress  ScreenStart ; worked out from sprite address each time

        Compress  TWLCol, TWBRow, TWRCol, TWTRow
        CompRange OrgX, NewPtY
        Compress  TForeCol, TBackCol, CursorX, CursorY

;       Compress  CursorAddr, InputCursorAddr - computed from (Input)CursorX,Y

        Compress  InputCursorX, InputCursorY

        Compress  VduStatus
        Compress  CursorDesiredState, CursorStartOffset, CursorEndOffset
        Compress  CursorCounter, CursorSpeed, Reg10Copy

;       Compress  CursorFill, CursorNbit - computed from mode variables

;       Compress  DriverBankAddr - refers to screen always

        CompRange Ecf1, Ecf4+4
        CompMult  DotLineStyle, 8

;       Compress  ModeNo - stored in sprite itself

        Compress  TFTint, TBTint, GFTint, GBTint

;       Compress  TotalScreenSize, MaxMode, ScreenEndAddr - refer to screen always

        Compress  CursorFlags, CursorStack
        Compress  ECFShift, ECFYOffset

        Compress  GCharSizeX, GCharSizeY, GCharSpaceX, GCharSpaceY
;       Compress  TCharSizeX, TCharSizeY        ; recomputed from mode number
;       Compress  TCharSpaceX, TCharSpaceY      ; each time

;       CompMult  FgEcfOraEor, 64      ; recreated from GCOLs and ecfs
;       CompMult  BgEcfOraEor, 64      ; by call to SetColour
;       CompMult  BgEcfStore, 64       ;

        Compress  LineDotCnt, LineDotPatLSW, LineDotPatMSW, DotLineLength
        Compress  BBCcompatibleECFs

;       Compress  WrchNbit - computed from mode number

        CompRange ClipBoxEnable, ClipBoxTRow

        CompMult  FgPattern, 4*8
        CompMult  BgPattern, 4*8

        Compress  TextFgColour
        Compress  TextBgColour

        CompEnd
CompressionTableEnd
MainSize * CompressedSize + SavedDataOffset

        ; N.B. teletext state is not saved

        ASSERT  MainSize <= SaveAreaSize
        ! 0, "Space free in VDU save area = ":CC::STR:(SaveAreaSize-MainSize)


; *****************************************************************************
;
;       PackVars - Pack variables into save area
;

PackVars ROUT
        CLC                             ; clear carry - indicate packing
PackOrUnpack
        Push    "R0-R4,R14"
        LDR     R0, [WsPtr, #VduSaveAreaPtr]
        TEQ     R0, #0
        Pull    "R0-R4,PC", EQ          ; ptr=0 => no area

        TEQ     R0, #1
        ADDEQ   R0, WsPtr, #VduSaveArea ; ptr=1 => use MOS's save area

        BL      DoSpecialVars                   ; process special vars

        ADD     R0, R0, #SavedDataOffset        ; move on to compressed data
        ADR     R1, CompressionTable
10
        LDR     R2, [R1], #4
        MVNS    R3, R2                  ; set Z if it was -1 (end of table)
        Pull    "R0-R4,PC", EQ          ; (preserves C)

        ADD     R3, WsPtr, R2, LSR #16          ; R3 = end pointer
        MOV     R2, R2, LSL #16
        ADD     R2, WsPtr, R2, LSR #16          ; R2 = start pointer
20
        LDRCC   R4, [R2], #4                    ; load a word from vars
        LDRCS   R4, [R0], #4                    ; or from save area
        STRCC   R4, [R0], #4                    ; store into save area
        STRCS   R4, [R2], #4                    ; or into vars
        TEQ     R2, R3                          ; end of this block ?
        BNE     %BT20                           ; [no, so loop]
        B       %BT10                           ; go back for another block

; *****************************************************************************
;
;       UnpackVars - Unpack variables from save area
;

UnpackVars ROUT
        SEC                             ; set carry - indicate unpacking
        B       PackOrUnpack

; *****************************************************************************
;
;       DoSpecialVars - Pack/unpack special vars: CursorAddr, InputCursorAddr,
;        (stored relative to ScreenStart); SpoolFileH, WrchDest, VDUqueueItems
;
; in:   R0 -> save area
;
; out:  R0 preserved
;       R1-R2 corrupted
;       Flags preserved
;

DoSpecialVars ROUT
        BYTEWS  R1
        BCS     %FT10
        LDRB    R2, [R1, #:INDEX: SpoolFileH]
        STRB    R2, [R0, #SavedSpoolFileH]
        LDRB    R2, [R1, #:INDEX: WrchDest]
        STRB    R2, [R0, #SavedWrchDest]
        LDRB    R2, [R1, #:INDEX: VDUqueueItems]
        STRB    R2, [R0, #SavedVDUqueueItems]
        LDR     R1, VOTS                ; initialised save area identifier
        STR     R1, [R0, #InitFlag]
        MOV     PC, R14

; unpack special vars (R1 -> ByteWS)

10
        LDRB    R2, [R0, #SavedSpoolFileH]
        STRB    R2, [R1, #:INDEX: SpoolFileH]
        LDRB    R2, [R0, #SavedWrchDest]
        STRB    R2, [R1, #:INDEX: WrchDest]
        LDRB    R2, [R0, #SavedVDUqueueItems]
        STRB    R2, [R1, #:INDEX: VDUqueueItems]
        MOV     PC, R14

; *****************************************************************************
;
;       ValidateVars - Validate unpacked variables (windows, cursor posns)
;

ValidateVars ROUT
        Push    R14
        ASSERT  ScrBRow = ScrRCol + 4
        ADD     R4, WsPtr, #ScrRCol
        LDMIA   R4, {R4, R5}            ; R4 = ScrRCol; R5 = ScrBRow

        ADD     R6, WsPtr, #TWLCol      ; R0 = TWLCol; R1 = TWBRow
        LDMIA   R6, {R0-R3}             ; R2 = TWRCol; R3 = TWTRow

        MOV     R7, #0
        MOV     R8, R5
        MOV     R9, R4
        MOV     R10, #0
        STMIA   R6, {R7-R10}            ; set up default window

        BL      FSRegs                  ; and attempt to define text window

        ASSERT  YWindLimit = XWindLimit + 4
        ADD     R0, WsPtr, #XWindLimit
        LDMIA   R0, {R2, R3}            ; R2 = XWindLimit; R3 = YWindLimit

        ADD     R8, WsPtr, #GWLCol      ; R4 = GWLCol; R5 = GWBRow
        LDMIA   R8, {R4-R7}             ; R6 = GWRCol; R7 = GWTRow

        CMP     R6, R2                  ; if GWRCol > XWindLimit
        CMPLS   R7, R3                  ; or GWTRow > YWindLimit

        MOVHI   R0, #0
        MOVHI   R1, #0
        STMHIIA R8, {R0-R3}             ; then set default graphics window

        Pull    PC

        END
@


4.10
log
@Teletext fixes
Detail:
  s/vdu/vdugrafl - Disable hardware scrolling if we're in a teletext mode with a border. Quick fix in lieu of adding some code to make sure the relevant border areas are cleared when scrolling.
  s/vdu/vduttx - Ignore VDU 23,18,<n> sequences when outside of teletext. Fixes a crash when screen update suspend/resume sequences are used.
Admin:
  Tested on RiscPC


Version 5.94. Tagged as 'Kernel-5_94'
@
text
@a206 3
        LDR     R0,[R11, #wkNColour]
        STR     R0,[WsPtr, #NColour]            ; copy number of colours -1

d209 2
a210 1
        ADD     R1, WsPtr, #YShftFactor ; first mode variable that we do
@


4.9
log
@Initial support for the ExtraBytes VIDC control list item
Detail:
  The ExtraBytes control list item can be used to add padding between framebuffer rows.
  When the kernel sees a VIDC list containing this item, it will now adjust the LineLength and ScreenSize mode variables accordingly, with the end result that the correct amount of memory will be allocated for the framebuffer and the OS will render into it correctly.
  Files changed:
  - hdr/KernelWS - Add DisplayLineLength variable to allow the correct LineLength value to be preserved when screen output is redirected to a sprite
  - s/vdu/vdudriver - Make ModeChangeSub initialise DisplayLineLength before calling SwitchOutputToSprite. Update PushModeInfo to take ExtraBytes into account when calculating LineLength and ScreenSize.
  - s/vdu/vdugrafl - Adjust SwitchOutputToSprite to use DisplayLineLength when restoring screen output
  - s/vdu/vduwrch - Fix full-screen CLS to not write to the padding bytes
Admin:
  Tested on Raspberry Pi 3


Version 5.82. Tagged as 'Kernel-5_82'
@
text
@d376 2
a377 1
        SUB     R14, R7, R14            ; spare rows on screen
d387 2
a388 1
        SUB     R8, R7, R8              ; spare columns on screen
d394 1
d473 1
@


4.9.2.1
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d376 1
a376 2
        SUBS    R14, R7, R14            ; spare rows on screen
        ORRNE   R6, R6, #ModeFlag_HardScrollDisabled ; Disable hard scroll if there's any gap (we don't clear the border when scrolling!)
d386 1
a386 2
        SUBS    R8, R7, R8              ; spare columns on screen
        ORRNE   R6, R6, #ModeFlag_HardScrollDisabled
a391 1
        STR     R6, [WsPtr, #DisplayModeFlags] ; Write back the potentially-updated flags to DisplayModeFlags, since we're going to use that to reload ModeFlags below (assuming we aren't attempting TTX in a sprite!)
a469 1
        ; (n.b. see also code above which deliberately updates DisplayModeFlags if in TTX)
@


4.8
log
@Fix screen redirection when in teletext modes. Fix *ScreenLoad buffer overflow.
Detail:
  s/vdu/vdugrafl, s/vdu/vduttx - Adjust initialisation & shutdown of TTX workspace to fix workspace being erroneously freed/reinitialised when redirecting output to a sprite
  s/vdu/vdugrafk - If ScreenLoad needs to load one row at a time (e.g. when graphics window width != sprite width), allocate a block from the RMA instead of assuming that ScrLoaBuffer is large enough
  hdr/KernelWS - Get rid of ScrLoaBuffer, and shrink LargeCommon to a suitable size. Frees about 2K of VDU workspace.
  s/GetAll - Move Hdr:Sprite earlier in list of GETs
Admin:
  Tested on Raspberry Pi


Version 5.75. Tagged as 'Kernel-5_75'
@
text
@d162 14
a175 3
        TEQ     R2, #0                          ; if outputting to screen
        LDREQ   R5, [R11, #wkLineLength]        ; then load up values
        LDREQ   R6, [R11, #wkYWindLimit]        ; from mode table
d179 1
a179 1
        BEQ     %FT30                           ; and skip more sprite stuff
d181 2
@


4.7
log
@Add support for custom teletext modes
Detail:
  This set of changes:
  * Adds support for the T, TX and TY mode string elements (as per RISCOS Ltd)
  * Adds support for entering arbitrary-resolution teletext modes by using mode selector blocks with the Teletext mode flag set
  * ScrRCol and ScrBRow mode variables can be provided in the mode selector in order to restrict the number of text rows/columns in teletext modes (as per RISCOS Ltd)
  * If the rows / columns are restricted in this manner then the text window will be centered on the screen, to try and avoid things looking too ugly (no variable text scaling implemented)
  * For HiResTTX, all colour depths >= 4bpp are now supported by teletext. This essentially makes the TTX256 switch obsolete.
  * If the "native" mode 7 is unavailable then the kernel will try a series of fallback resolutions & colour depths in an effort to find a combination that works
  Known bugs/issues:
  * Teletext column count has a max limit of 255 due to TTXDoubleCounts being a byte array
  * If there's a border around the text window, the border will not be refreshed when changing transparency modes using a VDU 23,18,0 sequence
  * ScreenLoad looks like it can overflow the LargeCommon buffer (no buffer size check) - needs fixing before LargeCommon can be safely shrunk below (Old)TTXMapSize
  File changes:
  - hdr/KernelWS - Make CharWidth non-conditional. Adjust handling of teletext workspace; it's now allocated from the system heap to allow it to cope with arbitrary screen sizes
  - s/vdu/vdu23 - Make CharWidth non-conditional
  - s/vdu/vducursoft - Make CursorTeletext cope with arbitrary colour depths, make CharWidth non-conditional, remove hard-coded teletext values
  - s/vdu/vdudriver - Deal with teletext workspace allocation during ModeChangeSub. Deal with selecting teletext modes (and validating colour depth) in GenerateModeSelectorVars.
  - s/vdu/vdugrafl - Make CharWidth non-conditional. Calculate offset required for text window centering.
  - s/vdu/vdumodes - Remove TTX256
  - s/vdu/vduswis - Try other teletext modes if native mode 7 not available. Extend OS_ScreenMode reason codes to cope with teletext mode strings.
  - s/vdu/vduttx - Update to use dynamic workspace. Replace various hardcoded values with variable lookups. Update character plotting + colour/palette selection to work with true-colour modes if HiResTTX.
  - s/vdu/vduwrch - Move some useful code into a subroutine. Update FastCLS to cope with true-colour teletext. Update AddressR0R1 to cope with text window centering offset. Make CharWidth non-conditional.
Admin:
  Tested on Raspberry Pi, BB-xM
  VDU 23,18,0 in 256-colour teletext now works correctly (previously 64-colour mode was in use, causing palette update to be ruined by VIDC1-mangling)


Version 5.74. Tagged as 'Kernel-5_74'
@
text
@a428 3
        ; Free any old teletext workspace
        BL      TeletextFinalise

d437 9
a445 1
        BLNE    TeletextInit                    ; initialise TTX if appropriate
@


4.6
log
@Delete STB code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a desktop build):
  * STB
  * RO371Timings
  * NormalSpeedROMS
  * AutoSpeedROMS
  * RISCPCBurstMode
  * InterlacedPointer
  * ParallelFlashUpgrade (and s/FlashROM file)
  * Embedded_UI
  Some of the deleted code might be worth revisiting in future:
  * OS_ReadSysInfo 4 support for storing the MAC in alternate CMOS locations (including 2nd copy for error checking) or fetching via Service_MachineAddress
  * Mouse handling changes, possibly aimed at hiding the mouse pointer if a mouse isn't connected
  * More strict CMOS validation in s/NewReset
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.50. Tagged as 'Kernel-5_50'
@
text
@d313 1
a314 1
      ]
d322 5
a326 3
      [ TTX256
        TST     R6, #ModeFlag_Teletext  ; unless it's teletext
        MOVNE   R7, #&07                ; in which case still use colour 7
d353 29
d429 3
d645 2
a649 10
        [ {FALSE}                       ; don't allow teletext mode for now
TTXCompressionTable
        CompStart
        CompMult  TTXDoubleCounts, 28   ; (25 rounded up to a word)
        CompMult  TTXMap, 41*25*4
        CompEnd
TTXCompressionTableEnd
TTXSize * CompressedSize
        ]

@


4.5
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a421 8
 [ STB          ; Change made by TMD 29-May-96, to stop cursor flashing before interlace module has
                ; fixed up LineLength on Service_SwitchingOutputToSprite
        MOV     R1, #Service_SwitchingOutputToSprite    ; issue the service *first*
        ADD     R2, WsPtr, #VduOutputCurrentState
        LDMIA   R2, {R2-R5}                             ; load the registers that were in R0-R3 on entry
        IssueService
        BL      PostWrchCursor                          ; it should now be safe to restore the cursor
 |
a427 1
 ]
@


4.4
log
@  Added compile-time support for full-resolution teletext characters in
  teletext emulation mode (MODE 7) for that authentic BBC Micro feel.
  Also introduced a few useful teletext control features via VDU 23,18.
  Unrelatedly, fixed *ScreenLoad to work for interlaced displays.

Detail:
  The new typeface is designed on a 16x20 grid (previously we had used 8x10),
  so it uses a screen resolution of 640x500 pixels (rather than 320x250).
  Since we have been unable to source a genuine teletext font, and since
  examination of a BBC Micro suggests that the genuine font may not have been
  a power-of-2 pixels wide, I have designed one specially, based upon the one
  supplied in Zap distributions (a 12x20 font). Rather than increase the
  amount of workspace that the kernel requires for cacheing graphic
  characters, it now generates them on the fly, as they are required; this
  should only add about 25% to their rendering time.

  The new VDU 23 sequences are as follows:

  VDU 23,18,0,mode,0,0,0,0,0,0
    Switch transparency mode
      mode = 0: "Text" mode: the whole display is set opaque
      mode = 1: "Mix" mode: foreground colours, and both foreground and
        background of boxed text are opaque; non-boxed background colours are
        all transparent
      mode = 2: "Box" mode: boxed regions are opaque, others are transparent
      mode = 3: "TV" mode: the whole display is set transparent
    Default is mode = 0.

  VDU 23,18,1,suspend,0,0,0,0,0,0
    Suspend or resume bitmap updates
    This call allows an application to request that the kernel suspends
    updates to the framebuffer bitmap. This allows for a significant speed
    increase in the rendering time for a large amount of text, for example
    when redrawing a complete teletext page, because each time you plot a
    single character, it can cause the whole of the rest of the line to be
    re-rendered. When you switch out of suspend mode, the whole screen is
    refreshed in a single pass. Note that the appearance of the display is
    undefined is you cause a hardware scroll while in suspend mode.
      suspend = 0: screen update is enabled
      suspend = 1: screen update is suspended
    Default is suspend = 0.

  VDU 23,18,2,reveal,0,0,0,0,0,0
    Reveal/conceal
      reveal = 0: characters between the Conceal control code and the next
        colour control code are replaced by spaces
      reveal = 1: all characters are displayed
    Default is reveal = 0.

  VDU 23,18,3,black_emable,0,0,0,0,0,0
    Enable/disable black foreground colour control codes
      black_enable = 0: control codes &80 and &90 do nothing
      black_enable = 1: control code &80 selects black text, control code
        &90 selects black graphics
    Default is black_enable = 0.

  I have performed some timing tests on the rendering of complete teletext
  pages grabbed from the teletext server. These show that the new code
  generally imposes a 2x speed hit. However, when using the VDU 23,18,1
  suspend function, this improves to a 20% speed increase when compared to
  the old low-resolution code. Better still, because the framebuffer is only
  being updated for the final stage of this process, the screen *appears* to
  be updated some 3x faster than with the old code!

  A comment on the VDU variable Log2BPC is in order: in previous kernels,
  this was able unambiguously to refer to both the framebuffer width of a
  character in bytes, and the framebuffer width of an "addressable pixel" in
  bits; this no longer works with the 16-pixel wide teletext font. Bearing
  in mind that future kernels may support Unicode system fonts where the
  width varies from character to character, I have chosen to fix Log2BPC to
  the "addressable pixel" definition.

Admin:
  Requires HdrSrc 0.89 and (for non-desktop builds) Interlace 0.61. A monitor
  definition file containing a definition for a 640x500 screen mode is also
  required; version 0.40 of ModeFiles contains a suitable mode for STB-400.

  Tested fairly rigourously on an Ursula build, a Lazarus build and an
  STB-400 build, using genuine teletext pages and Yellow River Kingdom.

Version 5.30. Tagged as 'Kernel-5_30'
@
text
@d134 14
a147 2
        BIC     R11, R11, #&F8000000
        ORR     R11, R11, #&08000000    ; force it to a type 1 (1bpp) sprite
d151 6
a159 2
        MOV     R10, R11
        BL      PushModeInfoAnyMonitor
d216 1
a216 2
        ORRNE   R6, R6, #Flag_HardScrollDisabled ; if sprite then disable hard
        BICEQ   R6, R6, #Flag_HardScrollDisabled ; scroll, else enable it
a224 3
        CMP     R0, #3
        BNE     %FT65                   ; which is 8bpp ?

d230 4
d235 1
a235 1
        BNE     %FT65
d237 1
a237 1
        ORR     R6, R6, #Flag_FullPalette
d240 30
a269 2
        MOV     R7, #255
        STR     R7, [WsPtr, #NColour]   ; and set the number of colours
d272 1
a272 1
        TST     R6, #Flag_DoubleVertical
d282 1
a282 1
        TST     R6, #Flag_Teletext
d286 1
a286 1
        TST     R6, #Flag_NonGraphic
d311 2
a312 2
        TST     R6, #Flag_Teletext      ; in teletext mode
        MOVNE   R7, R7, LSL #1          ; characters are 16 pixels
d316 1
a316 1
        TST     R6, #Flag_BBCGapMode    ; is it a BBC gap mode ?
d322 4
d331 1
a331 1
        TST     R6, #Flag_DoubleVertical
d335 1
a335 1
        TST     R6, #Flag_GapMode
d341 1
a341 1
        TST     R6, #Flag_Teletext
d386 4
d403 1
a403 1
        TST     R1, #Flag_Teletext              ; is it teletext ?
d417 7
a423 2
 [ STB		; Change made by TMD 29-May-96, to stop cursor flashing before interlace module has
		; fixed up LineLength on Service_SwitchingOutputToSprite
d428 1
a428 1
        BL      PostWrchCursor				; it should now be safe to restore the cursor
d589 3
@


4.4.2.1
log
@second attempt at handling lack of h/w scroll

Version 5.35, 4.79.2.10. Tagged as 'Kernel-5_35-4_79_2_10'
@
text
@d201 1
@


4.4.2.2
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a530 3

;       Compress  TotalScreenSize, MaxMode, ScreenEndAddr - refer to screen always

@


4.4.2.3
log
@Added 256-colour version of the (high-resolution only) teletext code,
and support for teletext when hardware scroll is disabled. Both are required
for Tungsten.
Turned off the module init/final service calls, since we still don't have an
allocation for them.
Upped the OS version number to 5.01.

Version 5.35, 4.79.2.53. Tagged as 'Kernel-5_35-4_79_2_53'
@
text
@a276 4
      [ TTX256
        TST     R6, #Flag_Teletext      ; unless it's teletext
        MOVNE   R7, #&07                ; in which case still use colour 7
      ]
@


4.4.2.4
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@a340 4
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
      ]
@


4.4.2.5
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d372 2
a373 2
 [ STB          ; Change made by TMD 29-May-96, to stop cursor flashing before interlace module has
                ; fixed up LineLength on Service_SwitchingOutputToSprite
d378 1
a378 1
        BL      PostWrchCursor                          ; it should now be safe to restore the cursor
@


4.4.2.6
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@d134 2
a135 14
        AND     R10, R11, #15<<27
        TEQ     R10, #SpriteType_RISCOS5<<27
        BEQ     %FT21
        TST     R11, #&80000000
        BIC     R11, R11, #&F8000000    ; wipe existing sprite type
        ORREQ   R11, R11, #SpriteType_New1bpp<<27 ; force to 1bpp
        ORRNE   R11, R11, #SpriteType_New8bpp<<27 ; force to 8bpp
        B       %FT23
21
        TST     R11, #&80000000
        AND     R11, R11, #&F0          ; preserve DPI fields, modeflags + original type must go
        ORR     R11, R11, #1+(SpriteType_RISCOS5<<27) ; mark as RO5 format
        ORREQ   R11, R11, #SpriteType_New1bpp<<20 ; force to 1bpp
        ORRNE   R11, R11, #SpriteType_New8bpp<<20 ; force to 8bpp
d139 2
a143 6
        STRVS   R0, [WsPtr, #RetnReg0]
        Pull    "PC", VS

        STR     R9, [WsPtr, #ScreenStart]
        STR     R11, [WsPtr, #ModeNo]           ; new mode number

d200 1
a200 1
        ORRNE   R6, R6, #ModeFlag_HardScrollDisabled ; if sprite then disable hard
d220 1
a220 1
        ORR     R6, R6, #ModeFlag_FullPalette
d227 1
a227 1
        TST     R6, #ModeFlag_DoubleVertical
d237 1
a237 1
        TST     R6, #ModeFlag_Teletext
d241 1
a241 1
        TST     R6, #ModeFlag_NonGraphic
d266 2
a267 2
        TST     R6, #ModeFlag_Teletext  ; in teletext mode
        MOVNE   R7, R7, LSL #1          ; characters are 16 pixels, not 8
d271 1
a271 1
        TST     R6, #ModeFlag_BBCGapMode ; is it a BBC gap mode ?
d278 1
a278 1
        TST     R6, #ModeFlag_Teletext  ; unless it's teletext
d286 1
a286 1
        TST     R6, #ModeFlag_DoubleVertical
d290 1
a290 1
        TST     R6, #ModeFlag_GapMode
d296 1
a296 1
        TST     R6, #ModeFlag_Teletext
d358 1
a358 1
        TST     R1, #ModeFlag_Teletext          ; is it teletext ?
@


4.4.2.7
log
@ModeFlag_GreyscalePalette handling improvements. Issue service calls on certain GraphicsV events. Sprite tweaks and fixes.
Detail:
  hdr/VduExt - Add reason codes used by Service_DisplayChanged & Service_DisplayStatus
  s/vdu/vdugrafg - Remove dependency on SpriteReason_BadReasonCode; just use the size of our lookup table instead. Alter SpriteOp lookup table so that unimplemented ops return an error instead of doing nothing. Fix PutSprite incorrectly using the slow GCOL action plotter if a request was made to plot a sprite using its mask but the sprite has none.
  s/vdu/vdugrafl - Update screen redirection handling to set ModeFlag_GreyscalePalette if switching output to a sprite with a greyscale palette or a RISC OS Select alpha mask. Restore the flag to its correct value when restoring screen output.
  s/vdu/vdupalxx - Update ModeFlag_GreyscalePalette in realtime as the palette is changed
  s/vdu/vduswis - Issue Service_DisplayChanged during OS_ScreenMode 11. Issue Service_DisplayStatus during OS_ScreenMode 65 & 66.
Admin:
  Tested on Iyonix, BB-xM


Version 5.35, 4.79.2.210. Tagged as 'Kernel-5_35-4_79_2_210'
@
text
@d216 1
a216 1
        ORRNE   R6, R6, #ModeFlag_HardScrollDisabled ; if sprite then disable hard scroll
d225 3
a232 4

        CMP     R0, #3
        BNE     %FT51                   ; which is 8bpp ?

d234 1
a234 1
        BNE     %FT51
d239 2
a240 30
        MOV     LR, #255
        STR     LR, [WsPtr, #NColour]   ; and set the number of colours
51
        LDRB    LR, [WsPtr, #SpriteMaskSelect]
        TEQ     LR, #SpriteReason_SwitchOutputToSprite
        BEQ     %FT52
        LDR     LR, [R2, #spMode]
        TST     LR, #&80000000
        ORRNE   R6, R6, #ModeFlag_GreyscalePalette+ModeFlag_FullPalette ; alpha masks are 256 greyscale
        STRNE   R6, [WsPtr, #ModeFlags]
        MOVNE   LR, #255
        STRNE   LR, [WsPtr, #NColour]
        B       %FT65
52
        ; Redirecting to sprite image, check for greyscale palette
        CMP     R0, #3
        BHI     %FT65
        TSTEQ   R6, #ModeFlag_FullPalette ; 63 colour can't be greyscale
        TEQNE   R7, #0                    ; If no palette then (probably) also not greyscale
        BEQ     %FT65                   
        ADD     R8, R2, #spPalette
53
        LDR     LR, [R8], #4
        EOR     LR, LR, LR, LSL #8
        CMP     LR, #&10000
        BHS     %FT65
        SUBS    R7, R7, #4
        BGT     %BT53
        ORR     R6, R6, #ModeFlag_GreyscalePalette
        STR     R6, [WsPtr, #ModeFlags]        
a387 5
        ; If we've just switched back to the screen, make sure the greyscale palette flag is accurate. Easiest way is to copy DisplayModeFlags into ModeFlags.
        LDR     R2, [WsPtr, #VduSprite]
        TEQ     R2, #0
        LDREQ   R2, [WsPtr, #DisplayModeFlags]
        STREQ   R2, [WsPtr, #ModeFlags]
@


4.4.2.3.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@a340 4
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
      ]
@


4.3
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d266 6
d292 4
@


4.2
log
@Kernel merged
@
text
@d372 1
a372 1
        BICS    PC, R14, #V_bit
d382 1
a382 1
        ORRS    PC, R14, #V_bit
@


4.2.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d376 1
d380 1
d553 9
@


4.2.2.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d355 8
d369 1
@


4.2.2.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d355 8
d369 1
@


4.1
log
@Initial revision
@
text
@d66 1
a66 1
; word directly. 
d132 1
a132 1
        
d135 2
a136 2
        ORR     R11, R11, #&08000000    ; force it to a type 1 (1bpp) sprite 
23        
d177 1
a177 1
                             
d225 1
a225 1
        STR     R7, [WsPtr, #NColour]   ; and set the number of colours 
d355 8
d369 1
d539 4
a542 4
           
        CompMult  FgPattern, 4*8         
        CompMult  BgPattern, 4*8         
                              
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d66 1
a66 1
; word directly.
d132 1
a132 1

d135 2
a136 2
        ORR     R11, R11, #&08000000    ; force it to a type 1 (1bpp) sprite
23
d177 1
a177 1

d225 1
a225 1
        STR     R7, [WsPtr, #NColour]   ; and set the number of colours
a354 8
 [ {TRUE}	; Change made by TMD 29-May-96, to stop cursor flashing before interlace module has
		; fixed up LineLength on Service_SwitchingOutputToSprite
        MOV     R1, #Service_SwitchingOutputToSprite    ; issue the service *first*
        ADD     R2, WsPtr, #VduOutputCurrentState
        LDMIA   R2, {R2-R5}                             ; load the registers that were in R0-R3 on entry
        IssueService
        BL      PostWrchCursor				; it should now be safe to restore the cursor
 |
a360 1
 ]
d530 4
a533 4

        CompMult  FgPattern, 4*8
        CompMult  BgPattern, 4*8

@


4.1.5.1
log
@Import from SrcFiler
@
text
@d66 1
a66 1
; word directly.
d132 1
a132 1

d135 2
a136 2
        ORR     R11, R11, #&08000000    ; force it to a type 1 (1bpp) sprite
23
d177 1
a177 1

d225 1
a225 1
        STR     R7, [WsPtr, #NColour]   ; and set the number of colours
a354 8
 [ {TRUE}	; Change made by TMD 29-May-96, to stop cursor flashing before interlace module has
		; fixed up LineLength on Service_SwitchingOutputToSprite
        MOV     R1, #Service_SwitchingOutputToSprite    ; issue the service *first*
        ADD     R2, WsPtr, #VduOutputCurrentState
        LDMIA   R2, {R2-R5}                             ; load the registers that were in R0-R3 on entry
        IssueService
        BL      PostWrchCursor				; it should now be safe to restore the cursor
 |
a360 1
 ]
d530 4
a533 4

        CompMult  FgPattern, 4*8
        CompMult  BgPattern, 4*8

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

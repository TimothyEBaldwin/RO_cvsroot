head	4.5;
access;
symbols
	Kernel-6_15:4.5
	Kernel-6_14:4.5
	Kernel-6_01-3:4.5
	Kernel-6_13:4.5
	Kernel-6_12:4.5
	Kernel-6_11:4.5
	Kernel-6_10:4.5
	Kernel-6_09:4.5
	Kernel-6_08-4_129_2_10:4.4.2.1
	Kernel-6_08-4_129_2_9:4.4.2.1
	Kernel-6_08:4.5
	Kernel-6_07:4.5
	Kernel-6_06:4.5
	Kernel-6_05-4_129_2_8:4.4.2.1
	Kernel-6_05:4.5
	Kernel-6_04:4.5
	Kernel-6_03:4.5
	Kernel-6_01-2:4.5
	Kernel-6_01-4_146_2_1:4.5
	Kernel-6_02:4.5
	Kernel-6_01-1:4.5
	Kernel-6_01:4.5
	Kernel-6_00:4.5
	Kernel-5_99:4.5
	Kernel-5_98:4.5
	Kernel-5_97-4_129_2_7:4.4.2.1
	Kernel-5_97:4.5
	Kernel-5_96:4.5
	Kernel-5_95:4.5
	Kernel-5_94:4.5
	Kernel-5_93:4.5
	Kernel-5_92:4.5
	Kernel-5_91:4.5
	Kernel-5_90:4.5
	Kernel-5_89-4_129_2_6:4.4.2.1
	Kernel-5_89:4.5
	Kernel-5_88-4_129_2_5:4.4.2.1
	Kernel-5_88-4_129_2_4:4.4.2.1
	Kernel-5_88:4.5
	Kernel-5_87:4.4
	Kernel-5_86-4_129_2_3:4.4
	Kernel-5_86-4_129_2_2:4.4
	Kernel-5_86-4_129_2_1:4.4
	Kernel-5_86:4.4
	SMP:4.4.0.2
	SMP_bp:4.4
	Kernel-5_85:4.4
	Kernel-5_54-1:4.4
	Kernel-5_84:4.4
	Kernel-5_83:4.4
	Kernel-5_82:4.4
	Kernel-5_81:4.4
	Kernel-5_80:4.4
	Kernel-5_79:4.4
	Kernel-5_78:4.4
	Kernel-5_77:4.4
	Kernel-5_76:4.4
	Kernel-5_75:4.4
	Kernel-5_74:4.4
	Kernel-5_73:4.4
	Kernel-5_72:4.4
	Kernel-5_71:4.4
	Kernel-5_70:4.4
	Kernel-5_69:4.4
	Kernel-5_68:4.4
	Kernel-5_67:4.4
	Kernel-5_66:4.4
	Kernel-5_65:4.4
	Kernel-5_64:4.4
	Kernel-5_63:4.4
	Kernel-5_62:4.4
	Kernel-5_61:4.4
	Kernel-5_60:4.4
	Kernel-5_59:4.4
	Kernel-5_58:4.4
	Kernel-5_57:4.4
	Kernel-5_56:4.4
	Kernel-5_55:4.4
	Kernel-5_54:4.4
	Kernel-5_53:4.4
	Kernel-5_52:4.4
	Kernel-5_51:4.4
	Kernel-5_50:4.4
	Kernel-5_49:4.4
	HAL_merge:4.3.2.5
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.3.2.5
	Kernel-5_35-4_79_2_326:4.3.2.5
	Kernel-5_35-4_79_2_325:4.3.2.5
	Kernel-5_35-4_79_2_324:4.3.2.5
	Kernel-5_35-4_79_2_323:4.3.2.5
	Kernel-5_35-4_79_2_322:4.3.2.5
	Kernel-5_35-4_79_2_321:4.3.2.5
	Kernel-5_35-4_79_2_320:4.3.2.5
	Kernel-5_35-4_79_2_319:4.3.2.5
	Kernel-5_35-4_79_2_318:4.3.2.5
	Kernel-5_35-4_79_2_317:4.3.2.5
	Kernel-5_35-4_79_2_316:4.3.2.5
	Kernel-5_35-4_79_2_315:4.3.2.5
	Kernel-5_35-4_79_2_314:4.3.2.5
	Kernel-5_35-4_79_2_313:4.3.2.5
	Kernel-5_35-4_79_2_312:4.3.2.5
	Kernel-5_35-4_79_2_311:4.3.2.5
	Kernel-5_35-4_79_2_310:4.3.2.5
	Kernel-5_35-4_79_2_309:4.3.2.5
	Kernel-5_35-4_79_2_308:4.3.2.5
	Kernel-5_35-4_79_2_307:4.3.2.5
	Kernel-5_35-4_79_2_306:4.3.2.5
	Kernel-5_35-4_79_2_305:4.3.2.5
	Kernel-5_35-4_79_2_304:4.3.2.5
	Kernel-5_35-4_79_2_303:4.3.2.5
	Kernel-5_35-4_79_2_302:4.3.2.5
	Kernel-5_35-4_79_2_301:4.3.2.5
	Kernel-5_35-4_79_2_300:4.3.2.5
	Kernel-5_35-4_79_2_299:4.3.2.5
	Kernel-5_35-4_79_2_298:4.3.2.5
	Kernel-5_35-4_79_2_297:4.3.2.5
	Kernel-5_35-4_79_2_296:4.3.2.5
	Kernel-5_35-4_79_2_295:4.3.2.5
	Kernel-5_35-4_79_2_294:4.3.2.5
	Kernel-5_35-4_79_2_293:4.3.2.5
	Kernel-5_35-4_79_2_292:4.3.2.5
	Kernel-5_35-4_79_2_291:4.3.2.5
	Kernel-5_35-4_79_2_290:4.3.2.5
	Kernel-5_35-4_79_2_289:4.3.2.5
	Kernel-5_35-4_79_2_288:4.3.2.5
	Kernel-5_35-4_79_2_287:4.3.2.5
	Kernel-5_35-4_79_2_286:4.3.2.5
	Kernel-5_35-4_79_2_285:4.3.2.5
	Kernel-5_35-4_79_2_284:4.3.2.5
	Kernel-5_35-4_79_2_283:4.3.2.5
	Kernel-5_35-4_79_2_282:4.3.2.5
	Kernel-5_35-4_79_2_281:4.3.2.5
	Kernel-5_35-4_79_2_280:4.3.2.5
	Kernel-5_35-4_79_2_279:4.3.2.5
	Kernel-5_35-4_79_2_278:4.3.2.5
	Kernel-5_35-4_79_2_277:4.3.2.5
	Kernel-5_35-4_79_2_276:4.3.2.5
	Kernel-5_35-4_79_2_275:4.3.2.5
	Kernel-5_35-4_79_2_274:4.3.2.5
	Kernel-5_35-4_79_2_273:4.3.2.5
	Kernel-5_35-4_79_2_272:4.3.2.5
	Kernel-5_35-4_79_2_271:4.3.2.5
	Kernel-5_35-4_79_2_270:4.3.2.5
	Kernel-5_35-4_79_2_269:4.3.2.5
	Kernel-5_35-4_79_2_268:4.3.2.5
	Kernel-5_35-4_79_2_267:4.3.2.5
	Kernel-5_35-4_79_2_266:4.3.2.5
	Kernel-5_35-4_79_2_265:4.3.2.5
	Kernel-5_35-4_79_2_264:4.3.2.5
	Kernel-5_35-4_79_2_263:4.3.2.5
	Kernel-5_35-4_79_2_262:4.3.2.5
	Kernel-5_35-4_79_2_261:4.3.2.5
	Kernel-5_35-4_79_2_260:4.3.2.5
	Kernel-5_35-4_79_2_259:4.3.2.5
	Kernel-5_35-4_79_2_258:4.3.2.5
	Kernel-5_35-4_79_2_257:4.3.2.5
	Kernel-5_35-4_79_2_256:4.3.2.5
	Kernel-5_35-4_79_2_255:4.3.2.5
	Kernel-5_35-4_79_2_254:4.3.2.5
	Kernel-5_35-4_79_2_253:4.3.2.5
	Kernel-5_35-4_79_2_252:4.3.2.5
	Kernel-5_35-4_79_2_251:4.3.2.5
	Kernel-5_35-4_79_2_250:4.3.2.5
	Kernel-5_35-4_79_2_249:4.3.2.5
	Kernel-5_35-4_79_2_248:4.3.2.5
	Kernel-5_35-4_79_2_247:4.3.2.5
	Kernel-5_35-4_79_2_246:4.3.2.5
	Kernel-5_35-4_79_2_245:4.3.2.5
	Kernel-5_35-4_79_2_244:4.3.2.5
	Kernel-5_35-4_79_2_243:4.3.2.5
	Kernel-5_35-4_79_2_242:4.3.2.5
	Kernel-5_35-4_79_2_241:4.3.2.5
	Kernel-5_35-4_79_2_240:4.3.2.5
	Kernel-5_35-4_79_2_239:4.3.2.5
	Kernel-5_35-4_79_2_238:4.3.2.5
	Kernel-5_35-4_79_2_237:4.3.2.5
	Kernel-5_35-4_79_2_236:4.3.2.5
	Kernel-5_35-4_79_2_235:4.3.2.5
	Kernel-5_35-4_79_2_234:4.3.2.5
	Kernel-5_35-4_79_2_233:4.3.2.5
	Kernel-5_35-4_79_2_232:4.3.2.5
	Kernel-5_35-4_79_2_231:4.3.2.5
	Kernel-5_35-4_79_2_230:4.3.2.5
	Kernel-5_35-4_79_2_229:4.3.2.5
	Kernel-5_35-4_79_2_228:4.3.2.5
	Kernel-5_35-4_79_2_227:4.3.2.5
	Kernel-5_35-4_79_2_226:4.3.2.5
	Kernel-5_35-4_79_2_225:4.3.2.5
	Kernel-5_35-4_79_2_224:4.3.2.5
	Kernel-5_35-4_79_2_223:4.3.2.5
	Kernel-5_35-4_79_2_222:4.3.2.5
	Kernel-5_35-4_79_2_221:4.3.2.4
	Kernel-5_35-4_79_2_220:4.3.2.4
	Kernel-5_35-4_79_2_219:4.3.2.4
	Kernel-5_35-4_79_2_218:4.3.2.4
	Kernel-5_35-4_79_2_217:4.3.2.4
	Kernel-5_35-4_79_2_216:4.3.2.4
	Kernel-5_35-4_79_2_215:4.3.2.4
	Kernel-5_35-4_79_2_214:4.3.2.4
	Kernel-5_35-4_79_2_213:4.3.2.4
	Kernel-5_35-4_79_2_212:4.3.2.4
	Kernel-5_35-4_79_2_211:4.3.2.4
	Kernel-5_35-4_79_2_210:4.3.2.4
	Kernel-5_35-4_79_2_209:4.3.2.4
	Kernel-5_35-4_79_2_208:4.3.2.4
	Kernel-5_35-4_79_2_207:4.3.2.4
	Kernel-5_35-4_79_2_206:4.3.2.4
	Kernel-5_35-4_79_2_205:4.3.2.4
	Kernel-5_35-4_79_2_204:4.3.2.4
	Kernel-5_35-4_79_2_203:4.3.2.4
	Kernel-5_35-4_79_2_202:4.3.2.4
	Kernel-5_35-4_79_2_201:4.3.2.4
	Kernel-5_35-4_79_2_200:4.3.2.4
	Kernel-5_35-4_79_2_199:4.3.2.4
	Kernel-5_35-4_79_2_198:4.3.2.4
	Kernel-5_35-4_79_2_197:4.3.2.4
	Kernel-5_35-4_79_2_196:4.3.2.4
	Kernel-5_35-4_79_2_195:4.3.2.4
	Kernel-5_35-4_79_2_194:4.3.2.4
	Kernel-5_35-4_79_2_193:4.3.2.4
	Kernel-5_35-4_79_2_192:4.3.2.4
	Kernel-5_35-4_79_2_191:4.3.2.4
	Kernel-5_35-4_79_2_190:4.3.2.4
	Kernel-5_35-4_79_2_189:4.3.2.4
	Kernel-5_35-4_79_2_188:4.3.2.4
	Kernel-5_35-4_79_2_187:4.3.2.4
	Kernel-5_35-4_79_2_186:4.3.2.4
	Kernel-5_35-4_79_2_185:4.3.2.4
	Kernel-5_35-4_79_2_184:4.3.2.4
	Kernel-5_35-4_79_2_183:4.3.2.4
	Kernel-5_35-4_79_2_182:4.3.2.4
	Kernel-5_35-4_79_2_181:4.3.2.4
	Kernel-5_35-4_79_2_180:4.3.2.4
	Kernel-5_35-4_79_2_179:4.3.2.4
	Kernel-5_35-4_79_2_178:4.3.2.4
	Kernel-5_35-4_79_2_177:4.3.2.4
	Kernel-5_35-4_79_2_176:4.3.2.4
	Kernel-5_35-4_79_2_175:4.3.2.4
	Kernel-5_35-4_79_2_174:4.3.2.4
	Kernel-5_35-4_79_2_173:4.3.2.3
	Kernel-5_35-4_79_2_172:4.3.2.3
	Kernel-5_35-4_79_2_171:4.3.2.3
	Kernel-5_35-4_79_2_170:4.3.2.3
	Kernel-5_35-4_79_2_169:4.3.2.3
	Kernel-5_35-4_79_2_168:4.3.2.3
	Kernel-5_35-4_79_2_167:4.3.2.3
	Kernel-5_35-4_79_2_166:4.3.2.3
	Kernel-5_35-4_79_2_165:4.3.2.3
	RPi_merge:4.3.2.3
	Kernel-5_35-4_79_2_147_2_23:4.3.2.3
	Kernel-5_35-4_79_2_147_2_22:4.3.2.3
	Kernel-5_35-4_79_2_147_2_21:4.3.2.3
	Kernel-5_35-4_79_2_147_2_20:4.3.2.3
	Kernel-5_35-4_79_2_147_2_19:4.3.2.3
	Kernel-5_35-4_79_2_147_2_18:4.3.2.3
	Kernel-5_35-4_79_2_164:4.3.2.3
	Kernel-5_35-4_79_2_163:4.3.2.3
	Kernel-5_35-4_79_2_147_2_17:4.3.2.3
	Kernel-5_35-4_79_2_147_2_16:4.3.2.3
	Kernel-5_35-4_79_2_147_2_15:4.3.2.3
	Kernel-5_35-4_79_2_162:4.3.2.3
	Kernel-5_35-4_79_2_161:4.3.2.3
	Kernel-5_35-4_79_2_147_2_14:4.3.2.3
	Kernel-5_35-4_79_2_147_2_13:4.3.2.3
	Kernel-5_35-4_79_2_160:4.3.2.3
	Kernel-5_35-4_79_2_159:4.3.2.3
	Kernel-5_35-4_79_2_158:4.3.2.3
	Kernel-5_35-4_79_2_157:4.3.2.3
	Kernel-5_35-4_79_2_156:4.3.2.3
	Kernel-5_35-4_79_2_147_2_12:4.3.2.3
	Kernel-5_35-4_79_2_147_2_11:4.3.2.3
	Kernel-5_35-4_79_2_155:4.3.2.3
	Kernel-5_35-4_79_2_147_2_10:4.3.2.3
	Kernel-5_35-4_79_2_154:4.3.2.3
	Kernel-5_35-4_79_2_153:4.3.2.3
	Kernel-5_35-4_79_2_147_2_9:4.3.2.3
	Kernel-5_35-4_79_2_152:4.3.2.3
	Kernel-5_35-4_79_2_151:4.3.2.3
	Kernel-5_35-4_79_2_147_2_8:4.3.2.3
	Kernel-5_35-4_79_2_147_2_7:4.3.2.3
	Kernel-5_35-4_79_2_150:4.3.2.3
	Kernel-5_35-4_79_2_147_2_6:4.3.2.3
	Kernel-5_35-4_79_2_147_2_5:4.3.2.3
	Kernel-5_35-4_79_2_149:4.3.2.3
	Kernel-5_35-4_79_2_147_2_4:4.3.2.3
	Kernel-5_35-4_79_2_147_2_3:4.3.2.3
	Kernel-5_35-4_79_2_148:4.3.2.3
	Kernel-5_35-4_79_2_147_2_2:4.3.2.3
	Kernel-5_35-4_79_2_147_2_1:4.3.2.3
	RPi:4.3.2.3.0.2
	RPi_bp:4.3.2.3
	Kernel-5_35-4_79_2_98_2_52_2_1:4.3
	alees_Kernel_dev:4.3.0.8
	alees_Kernel_dev_bp:4.3
	Kernel-5_35-4_79_2_147:4.3.2.3
	Kernel-5_35-4_79_2_146:4.3.2.3
	Kernel-5_35-4_79_2_145:4.3.2.3
	Kernel-5_35-4_79_2_144:4.3.2.3
	Kernel-5_35-4_79_2_143:4.3.2.2
	Kernel-5_35-4_79_2_142:4.3.2.2
	Kernel-5_35-4_79_2_141:4.3.2.2
	Kernel-5_35-4_79_2_140:4.3.2.2
	Kernel-5_35-4_79_2_139:4.3.2.2
	Kernel-5_35-4_79_2_138:4.3.2.2
	Kernel-5_35-4_79_2_137:4.3.2.2
	Kernel-5_35-4_79_2_136:4.3.2.2
	Kernel-5_35-4_79_2_135:4.3.2.2
	Kernel-5_35-4_79_2_134:4.3.2.2
	Kernel-5_35-4_79_2_133:4.3.2.2
	Kernel-5_35-4_79_2_132:4.3.2.2
	Kernel-5_35-4_79_2_131:4.3.2.2
	Kernel-5_35-4_79_2_130:4.3.2.2
	Kernel-5_35-4_79_2_129:4.3.2.2
	Kernel-5_35-4_79_2_128:4.3.2.2
	Kernel-5_35-4_79_2_127:4.3.2.2
	Kernel-5_35-4_79_2_126:4.3.2.2
	Kernel-5_35-4_79_2_125:4.3.2.1
	Kernel-5_35-4_79_2_124:4.3
	Kernel-5_35-4_79_2_123:4.3
	Cortex_merge:4.3
	Kernel-5_35-4_79_2_122:4.3
	Kernel-5_35-4_79_2_98_2_54:4.3
	Kernel-5_35-4_79_2_98_2_53:4.3
	Kernel-5_35-4_79_2_98_2_52:4.3
	Kernel-5_35-4_79_2_98_2_51:4.3
	Kernel-5_35-4_79_2_98_2_50:4.3
	Kernel-5_35-4_79_2_98_2_49:4.3
	Kernel-5_35-4_79_2_98_2_48:4.3
	Kernel-5_35-4_79_2_121:4.3
	Kernel-5_35-4_79_2_98_2_47:4.3
	Kernel-5_35-4_79_2_120:4.3
	Kernel-5_35-4_79_2_98_2_46:4.3
	Kernel-5_35-4_79_2_119:4.3
	Kernel-5_35-4_79_2_98_2_45:4.3
	Kernel-5_35-4_79_2_98_2_44:4.3
	Kernel-5_35-4_79_2_118:4.3
	Kernel-5_35-4_79_2_98_2_43:4.3
	Kernel-5_35-4_79_2_117:4.3
	Kernel-5_35-4_79_2_116:4.3
	Kernel-5_35-4_79_2_98_2_42:4.3
	Kernel-5_35-4_79_2_115:4.3
	Kernel-5_35-4_79_2_98_2_41:4.3
	Kernel-5_35-4_79_2_98_2_40:4.3
	Kernel-5_35-4_79_2_114:4.3
	Kernel-5_35-4_79_2_98_2_39:4.3
	Kernel-5_35-4_79_2_98_2_38:4.3
	Kernel-5_35-4_79_2_113:4.3
	Kernel-5_35-4_79_2_112:4.3
	Kernel-5_35-4_79_2_98_2_37:4.3
	Kernel-5_35-4_79_2_98_2_36:4.3
	Kernel-5_35-4_79_2_98_2_35:4.3
	Kernel-5_35-4_79_2_98_2_34:4.3
	Kernel-5_35-4_79_2_98_2_33:4.3
	Kernel-5_35-4_79_2_98_2_32:4.3
	Kernel-5_35-4_79_2_98_2_31:4.3
	Kernel-5_35-4_79_2_98_2_30:4.3
	Kernel-5_35-4_79_2_98_2_29:4.3
	Kernel-5_35-4_79_2_98_2_28:4.3
	Kernel-5_35-4_79_2_98_2_27:4.3
	Kernel-5_35-4_79_2_98_2_26:4.3
	Kernel-5_35-4_79_2_111:4.3
	Kernel-5_35-4_79_2_98_2_25:4.3
	Kernel-5_35-4_79_2_98_2_24:4.3
	Kernel-5_35-4_79_2_98_2_23:4.3
	Kernel-5_35-4_79_2_110:4.3
	Kernel-5_35-4_79_2_98_2_22:4.3
	Kernel-5_35-4_79_2_109:4.3
	Kernel-5_35-4_79_2_98_2_21:4.3
	Kernel-5_35-4_79_2_98_2_20:4.3
	Kernel-5_35-4_79_2_108:4.3
	Kernel-5_35-4_79_2_107:4.3
	Kernel-5_35-4_79_2_98_2_19:4.3
	Kernel-5_35-4_79_2_98_2_18:4.3
	Kernel-5_35-4_79_2_98_2_17:4.3
	Kernel-5_35-4_79_2_98_2_16:4.3
	Kernel-5_35-4_79_2_98_2_15:4.3
	Kernel-5_35-4_79_2_106:4.3
	Kernel-5_35-4_79_2_105:4.3
	Kernel-5_35-4_79_2_104:4.3
	Kernel-5_35-4_79_2_98_2_14:4.3
	Kernel-5_35-4_79_2_98_2_13:4.3
	Kernel-5_35-4_79_2_98_2_12:4.3
	Kernel-5_35-4_79_2_98_2_11:4.3
	Kernel-5_35-4_79_2_98_2_10:4.3
	Kernel-5_35-4_79_2_98_2_9:4.3
	Kernel-5_35-4_79_2_103:4.3
	Kernel-5_35-4_79_2_102:4.3
	Kernel-5_35-4_79_2_98_2_8:4.3
	Kernel-5_35-4_79_2_98_2_7:4.3
	Kernel-5_35-4_79_2_98_2_6:4.3
	Kernel-5_35-4_79_2_98_2_5:4.3
	Kernel-5_35-4_79_2_98_2_4:4.3
	Kernel-5_35-4_79_2_101:4.3
	Kernel-5_35-4_79_2_100:4.3
	Kernel-5_35-4_79_2_99:4.3
	Kernel-5_35-4_79_2_98_2_3:4.3
	Kernel-5_35-4_79_2_98_2_2:4.3
	Kernel-5_35-4_79_2_98_2_1:4.3
	Cortex:4.3.0.4
	Cortex_bp:4.3
	Kernel-5_35-4_79_2_98:4.3
	Kernel-5_35-4_79_2_97:4.3
	Kernel-5_35-4_79_2_96:4.3
	Kernel-5_35-4_79_2_95:4.3
	Kernel-5_35-4_79_2_94:4.3
	Kernel-5_35-4_79_2_93:4.3
	Kernel-5_35-4_79_2_92:4.3
	Kernel-5_35-4_79_2_91:4.3
	Kernel-5_35-4_79_2_90:4.3
	Kernel-5_35-4_79_2_89:4.3
	Kernel-5_35-4_79_2_88:4.3
	Kernel-5_35-4_79_2_87:4.3
	Kernel-5_35-4_79_2_86:4.3
	Kernel-5_35-4_79_2_85:4.3
	Kernel-5_35-4_79_2_84:4.3
	Kernel-5_35-4_79_2_83:4.3
	Kernel-5_35-4_79_2_82:4.3
	Kernel-5_35-4_79_2_81:4.3
	Kernel-5_35-4_79_2_80:4.3
	Kernel-5_35-4_79_2_79:4.3
	Kernel-5_35-4_79_2_78:4.3
	Kernel-5_35-4_79_2_77:4.3
	RO_5_07:4.3
	Kernel-5_35-4_79_2_76:4.3
	Kernel-5_35-4_79_2_75:4.3
	Kernel-5_35-4_79_2_74:4.3
	Kernel-5_35-4_79_2_73:4.3
	Kernel-5_35-4_79_2_72:4.3
	Kernel-5_35-4_79_2_71:4.3
	Kernel-5_35-4_79_2_70:4.3
	Kernel-5_35-4_79_2_69:4.3
	Kernel-5_35-4_79_2_68:4.3
	Kernel-5_35-4_79_2_67:4.3
	Kernel-5_35-4_79_2_66:4.3
	Kernel-5_35-4_79_2_65:4.3
	Kernel-5_35-4_79_2_64:4.3
	Kernel-5_35-4_79_2_63:4.3
	Kernel-5_35-4_79_2_62:4.3
	Kernel-5_35-4_79_2_61:4.3
	Kernel-5_35-4_79_2_59:4.3
	Kernel-5_35-4_79_2_58:4.3
	Kernel-5_35-4_79_2_57:4.3
	Kernel-5_35-4_79_2_56:4.3
	Kernel-5_35-4_79_2_55:4.3
	Kernel-5_35-4_79_2_54:4.3
	Kernel-5_35-4_79_2_53:4.3
	Kernel-5_35-4_79_2_52:4.3
	Kernel-5_35-4_79_2_51:4.3
	Kernel-5_35-4_79_2_50:4.3
	Kernel-5_35-4_79_2_49:4.3
	Kernel-5_35-4_79_2_48:4.3
	Kernel-5_47:4.3
	Kernel-5_46-4_90_2_1:4.3
	nbingham_Kernel_FastNC_dev_bp:4.3
	nbingham_Kernel_FastNC_dev:4.3.0.6
	Kernel-5_46:4.3
	Kernel-5_45:4.3
	Kernel-5_35-4_79_2_47:4.3
	Kernel-5_35-4_79_2_46:4.3
	Kernel-5_35-4_79_2_45:4.3
	Kernel-5_35-4_79_2_44:4.3
	Kernel-5_35-4_79_2_25_2_2:4.3
	Kernel-5_35-4_79_2_43:4.3
	Kernel-5_35-4_79_2_42:4.3
	Kernel-5_35-4_79_2_41:4.3
	Kernel-5_35-4_79_2_40:4.3
	Kernel-5_35-4_79_2_39:4.3
	Kernel-5_35-4_79_2_38:4.3
	Kernel-5_35-4_79_2_37:4.3
	Kernel-5_35-4_79_2_36:4.3
	Kernel-5_35-4_79_2_35:4.3
	Kernel-5_35-4_79_2_34:4.3
	Kernel-5_35-4_79_2_33:4.3
	Kernel-5_35-4_79_2_32:4.3
	Kernel-5_44:4.3
	Kernel-5_35-4_79_2_25_2_1:4.3
	Kernel-5_43:4.3
	Kernel-5_35-4_79_2_31:4.3
	Kernel-5_35-4_79_2_30:4.3
	Kernel-5_35-4_79_2_29:4.3
	Kernel-5_35-4_79_2_28:4.3
	Kernel-5_35-4_79_2_27:4.3
	Kernel-5_35-4_79_2_26:4.3
	Kernel-5_42:4.3
	Kernel-5_41:4.3
	Kernel-5_40:4.3
	Kernel-5_35-4_79_2_25:4.3
	Kernel-5_35-4_79_2_24:4.3
	Kernel-5_35-4_79_2_23:4.3
	Kernel-5_35-4_79_2_22:4.3
	Kernel-5_35-4_79_2_21:4.3
	Kernel-5_35-4_79_2_20:4.3
	Kernel-5_35-4_79_2_19:4.3
	Kernel-5_35-4_79_2_18:4.3
	Kernel-5_35-4_79_2_17:4.3
	Kernel-5_35-4_79_2_16:4.3
	Kernel-5_35-4_79_2_15:4.3
	Kernel-5_35-4_79_2_14:4.3
	Kernel-5_39:4.3
	Kernel-5_13-4_52_2_1:4.2
	Bethany:4.2.0.8
	Kernel-5_38:4.3
	Kernel-5_35-4_79_2_13:4.3
	Kernel-5_35-4_79_2_12:4.3
	Kernel-5_35-4_79_2_11:4.3
	Kernel-5_37:4.3
	Kernel-5_35-4_79_2_10:4.3
	Kernel-5_35-4_79_2_9:4.3
	Kernel-5_36:4.3
	Kernel-5_35-4_79_2_8:4.3
	Kernel-5_35-4_79_2_7:4.3
	Kernel-5_35-4_79_2_6:4.3
	Kernel-5_35-4_79_2_5:4.3
	Kernel-5_35-4_79_2_4:4.3
	Kernel-5_35-4_79_2_3:4.3
	Kernel-5_35-4_79_2_2:4.3
	dellis_autobuild_BaseSW:4.3
	Kernel-5_35-4_79_2_1:4.3
	HAL:4.3.0.2
	Kernel-5_35:4.3
	Kernel-5_34:4.3
	Kernel-5_33:4.3
	Kernel-5_32:4.3
	Kernel-5_31:4.3
	Kernel-5_30:4.3
	Kernel-5_29:4.3
	Kernel-5_28:4.3
	Kernel-5_27:4.3
	Kernel-5_26:4.3
	Kernel-5_25:4.3
	Kernel-5_24:4.3
	Kernel-5_23:4.3
	Kernel-5_22:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Kernel-5_21:4.2
	Kernel-5_20:4.2
	Kernel-5_19:4.2
	Kernel-5_18:4.2
	Kernel-5_17:4.2
	Kernel-5_16:4.2
	Kernel-5_15:4.2
	Kernel-5_14:4.2
	Kernel-5_13:4.2
	Kernel-5_12:4.2
	Kernel-5_11:4.2
	Kernel-5_10:4.2
	Kernel-5_09:4.2
	Kernel-5_08:4.2
	Kernel-5_07:4.2
	Kernel-5_06:4.2
	Kernel-5_05:4.2
	Kernel-5_04:4.2
	Kernel-5_03:4.2
	Kernel-5_02:4.2
	Kernel-5_01:4.2
	Kernel-5_00:4.2
	Kernel-4_99:4.2
	Kernel-4_98:4.2
	Kernel-4_97:4.2
	Kernel-4_96:4.2
	Kernel-4_95:4.2
	Kernel-4_94:4.2
	Kernel-4_93:4.2
	Kernel-4_92:4.2
	Kernel-4_91:4.2
	Kernel-4_90:4.2
	dcotton_autobuild_BaseSW:4.3
	Kernel-4_89:4.2
	Kernel-4_88:4.2
	Kernel-4_87:4.2
	Kernel-4_86:4.2
	Kernel-4_85:4.2
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.1.2.1
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.1.2.1
	Ursula_RiscPC_bp:4.2.2.1
	Kernel-4_83:4.2
	Kernel-4_82:4.2
	Kernel-4_81:4.2
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.2
	Ursula_merge:4.2
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.2.2.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	mstphens_Kernel-3_80:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2017.08.27.08.05.06;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	bG9imA70bimYdP4A;

4.4
date	2016.06.30.20.08.08;	author jlee;	state Exp;
branches
	4.4.2.1;
next	4.3;
commitid	IWoXxARWeuLDOwcz;

4.3
date	2000.04.04.14.27.29;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.14.07.01;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.16;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	2017.08.31.18.47.02;	author jlee;	state Exp;
branches;
next	;
commitid	e0d3gZHfENrcEo5A;

4.3.2.1
date	2011.11.27.12.34.45;	author rsprowson;	state Exp;
branches;
next	4.3.2.2;
commitid	QtdLV6zjuPNxdYIv;

4.3.2.2
date	2011.11.27.12.54.06;	author rsprowson;	state Exp;
branches;
next	4.3.2.3;
commitid	qUSTS070aqq3kYIv;

4.3.2.3
date	2012.03.25.09.19.37;	author rsprowson;	state Exp;
branches;
next	4.3.2.4;
commitid	8lr6mqMI2AotjfYv;

4.3.2.4
date	2012.10.28.16.51.46;	author rsprowson;	state Exp;
branches;
next	4.3.2.5;
commitid	ruXZqdTJKJ85Qaqw;

4.3.2.5
date	2014.04.20.17.00.21;	author jlee;	state Exp;
branches;
next	;
commitid	6eesW4yWEAvSyrxx;

4.2.2.1
date	97.09.09.13.33.04;	author mstphens;	state Exp;
branches
	4.2.2.1.2.1;
next	4.2.2.2;

4.2.2.2
date	98.09.24.13.17.03;	author mstphens;	state Exp;
branches;
next	;

4.2.2.1.2.1
date	98.11.23.14.59.05;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.16;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.59.54;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.10.52;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.27;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Add UUID output formatter to conversions
OS_ConvertVariform 15 outputs 128b numbers per RFC4122.

Version 5.88. Tagged as 'Kernel-5_88'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => Convrsions : various number to string routines

despatchConvert ROUT

        ; Pick off the non table driven ones
        CMP     R11, #OS_ConvertVariform
        BNE     %FT10
        Push    "lr"
        BL      VariformInternal
        Pull    "lr"
        B       SLVK_TestV
10
        CMP     R11, #OS_ConvertStandardDateAndTime
        BEQ     StandardDateTime_Code
        CMP     R11, #OS_ConvertDateAndTime
        BEQ     DateTime_Code

        ASSERT  OS_ConvertFixedFileSize > OS_ConvertFixedNetStation
        CMP     R11, #OS_ConvertFixedFileSize
        BGE     FileSize_Code
        CMP     R11, #OS_ConvertFixedNetStation
        BGE     NetStation_Code

        ; Use SWI number as index into tables mapping to OS_ConvertVariform
        Push    "r0, r3-r4, lr"
        MOV     r0, sp

        SUB     r4, r11, #OS_ConvertHex1 - 3
        ADR     r14, ConvertSizesTable
        LDRB    r3, [r14, r4]
        ADR     r14, ConvertTypesTable
        LDRB    r4, [r14, r4, LSR #2]
        
        BL      VariformOutput
        ADD     sp, sp, #4
        Pull    "r3-r4, lr"
        B       SLVK_TestV

ConvertSizesTable
        DCB     0, 0, 0, 1, 2, 4, 6, 8, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4
        ASSERT  (. - ConvertSizesTable) :AND: 3 = 0
ConvertTypesTable
        DCB     ConvertToHex, ConvertToHex, ConvertToCardinal, ConvertToInteger
        DCB     ConvertToBinary, ConvertToSpacedCardinal, ConvertToSpacedInteger
        ALIGN

TenTimesTable
        DCD     1                       ; 10^0
        DCD     10
        DCD     100
        DCD     1000
        DCD     10000
        DCD     100000
        DCD     1000000
        DCD     10000000
        DCD     100000000
        DCD     1000000000              ; 10^9
TenTimesBigTable
        DCQ     10000000000             ; 10^10
        DCQ     100000000000
        DCQ     1000000000000
        DCQ     10000000000000
        DCQ     100000000000000
        DCQ     1000000000000000
        DCQ     10000000000000000
        DCQ     100000000000000000
        DCQ     1000000000000000000     ; 10^18

CommaPositions
        DCD     2_01001001001001001001001001001000

SuffixSI
        DCB     "byte"        
PrefixSI
        DCB     " kMGTPE"               ; units/kilo/mega/giga/tera/peta/exa
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; VariformInternal
; ----------------
; The guts behind OS_ConvertVariform but callable as a subroutine
; In  : R0 pointer to input value (word alignment)
;       R1 pointer to buffer
;       R2 max buffer length, or -ve to read space required
;       R3 bytes to use from input value (or nybbles if hex output reqd)
;       R4 type to convert to
; Out : R0 pointer to buffer
;       R1 pointer to terminator
;       R2 free bytes in buffer, or NOT space required if R2 -ve on entry
;       V Set if buffer overflow

VariformInternal
        ; Check if it's a read space operation
        MOVS    r2, r2
        BPL     VariformOutput

VariformCount
        ; Some of them are calculable
        TEQ     r4, #ConvertToBinary
        MOVEQ   r2, r3, LSL #3          ; 8 output chars for every 1 input byte
        BEQ     %FT30
        TEQ     r4, #ConvertToHex
        TEQNE   r4, #ConvertToHexLowercase
        MOVEQ   r2, r3, LSL #1          ; 2 output chars for every 1 input nybble
        BEQ     %FT30
        TEQ     r4, #ConvertToFixedFileSize
        MOVEQ   r2, #4 + 1 + 1 + 5      ; Always '1234 kbytes'
        BEQ     %FT30
        TEQ     r4, #ConvertToEUI
        ADDEQ   r2, r3, r3, LSL #1      ; 3 output chars for every 1 input byte (inc term)
        SUBEQ   r2, r2, #1              ; Don't count the terminator
        BEQ     %FT30
        TEQ     r4, #ConvertToUUID
        MOVEQ   r2, #(16 * 2) + 4       ; 128b in hex with 4 hyphens
        BEQ     %FT30
10
        ; A hard length to know, just do it
        Push    "r1, lr"
        SUB     sp, sp, #44             ; Longest is currently IPv6 output
        MOV     r1, sp
        MOV     r2, #44
        BL      VariformOutput
        SUB     r2, r1, r0              ; Length = term - start
        ADD     sp, sp, #44
        Pull    "r1, lr"
        ; Fall through
30
        MVN     r2, r2
40
        ADRL    r0, ErrorBlock_BuffOverflow
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "pc"
      |
        SETV
        MOV     pc, lr
      ]

VariformOutputChar
        TEQ     r2, #0
        BEQ     %BT40
        CMP     r0, #0                  ; Clears V too
        STREQB  r0, [r1]
        STRNEB  r0, [r1], #1            ; Adjust pointers except for terminating null
        SUBNE   r2, r2, #1
        MOV     pc, lr

VariformOutput ROUT
        Push    "lr"
        TEQ     r3, #0                  ; Ask for nothing, get a null string
        BNE     %FT10
        MOV     r0, #0
        BL      VariformOutputChar
        MOVVC   r0, r1
        Pull    "pc"
10
        ASSERT  ConvertToHex = 0
        CMP     r4, #(VariformHighest - VariformLowest) / 4
        ADDCC   pc, pc, r4, LSL #2
        BCS     VariBadConv
VariformLowest
        B       VariformOutputBinHex    ; ConvertToHex           
        B       VariformOutputDec       ; ConvertToCardinal      
        B       VariformOutputDec       ; ConvertToInteger       
        B       VariformOutputBinHex    ; ConvertToBinary        
        B       VariformOutputDecSpaced ; ConvertToSpacedCardinal
        B       VariformOutputDecSpaced ; ConvertToSpacedInteger
        B       VariformOutputDecPunct  ; ConvertToPunctCardinal
        B       VariformOutputDecPunct  ; ConvertToPunctInteger
        B       VariformOutputFileSize  ; ConvertToFixedFileSize
        B       VariformOutputFileSize  ; ConvertToFileSize
        B       VariformOutputDotColon  ; ConvertToIPv4          
        B       VariformOutputDotColon  ; ConvertToEUI           
        B       VariformOutputIPv6      ; ConvertToIPv6
        B       VariformOutputShortIPv6 ; ConvertToShortestIPv6  
        B       VariformOutputBinHex    ; ConvertToHexLowercase  
        B       VariformOutputUUID      ; ConvertToUUID  
VariformHighest

VariBadConv
        ADR     r0, ErrorBlock_UnConv   ; Unsupported conversion
        B       %FT20
        MakeErrorBlock UnConv
        
VariBadNumb
        ADRL    r0, ErrorBlock_BadNumb  ; Bad number
20
      [ International
        BL      TranslateError
      |
        SETV
      ]
        Pull    "pc"

VariformOutputDecPunct ROUT
        Push    "r0-r1"
        MOV     r0, #-1
        MOV     r1, #1
        SWI     XTerritory_ReadSymbols
        STRVS   r0, [sp]
        Pull    "r0-r1, pc", VS
        LDRB    r10, [r0]               ; Thousands separator
        Pull    "r0-r1"
        B       %FT10

VariformOutputDecSpaced
        MOV     r10, #' '               ; Spaces between 1000's
        B       %FT10
        
VariformOutputDec
        MOV     r10, #0                 ; No gaps between 1000's
10
        CMP     r3, #8                  ; Deal with up to 2^(8*8) or 64 bit
        BHI     VariBadNumb

        Push    "r1, r5-r9"
        ADD     r12, r0, r3             ; Input block
        MOV     r14, r3
        MOV     r5, #0
        MOV     r6, #0
20
        LDRB    r0, [r12, #-1]!
        CMP     r14, #4
        ORRHI   r6, r0, r6, LSL #8      ; Hi input word
        ORRLS   r5, r0, r5, LSL #8      ; Lo input word
        SUBS    r14, r14, #1
        BNE     %BT20

        TEQ     r4, #ConvertToInteger
        TEQNE   r4, #ConvertToSpacedInteger
        TEQNE   r4, #ConvertToPunctInteger
        BNE     %FT40                   ; Treat unsigned

        TEQ     r3, #4
        MOVEQ   r6, r5, ASR #31         ; Extend lo to hi
        ANDS    r11, r3, #3
        BEQ     %FT30                   ; For 4 & 8, no further action
        RSB     r11, r11, #4
        MOV     r11, r11, LSL #3        ; Sign extend shift of (4 - (length MOD 4)) * 8 bit
        CMP     r3, #4
        MOVHI   r6, r6, LSL r11
        MOVHI   r6, r6, ASR r11
        MOVLS   r5, r5, LSL r11
        MOVLS   r5, r5, ASR r11
        MOVLS   r6, r5, ASR #31         ; Extend lo to hi too
30
        CMP     r6, #0                  ; Is it overall negative?
        BPL     %FT50
        MOV     r0, #'-'
        BL      VariformOutputChar
        Pull    "r1, r5-r9, pc", VS
        MVN     r5, r5
        MVN     r6, r6
        ADDS    r5, r5, #1
        ADC     r6, r6, #0              ; Take ABS(r5,r6)
40
        TEQ     r6, #0
50
        MOVEQ   r11, #9                 ; Maximum power of 10 to consider
        MOVNE   r11, #18
        MOV     r9, #0                  ; Supress leading zeros
60
        MOV     r0, #'0'                ; This digit
        CMP     r11, #10
        ADRCC   r12, TenTimesTable
        LDRCC   r7, [r12, r11, LSL #2]
        MOVCC   r8, #0
        ADRCS   r12, TenTimesBigTable - (10 * 8)
        LDRCS   r7, [r12, r11, LSL #3]!
        LDRCS   r8, [r12, #4]
70
        SUBS    r5, r5, r7
        SBCS    r6, r6, r8
        ADDPL   r0, r0, #1              ; Subtracted OK
        BPL     %BT70

        ADDS    r5, r5, r7
        ADC     r6, r6, r8              ; Correct the undershoot
        TEQ     r9, #0
        SUBEQS  r9, r0, #'0'            ; Reevaluate supression if supressing
        BEQ     %FT80
        BL      VariformOutputChar
        Pull    "r1, r5-r9, pc", VS
        MOV     r14, #1
        MOV     r14, r14, LSL r11
        LDR     r0, CommaPositions
        TST     r14, r0                 ; V still clear
        MOVNE   r0, r10
        BLNE    VariformOutputChar
        Pull    "r1, r5-r9, pc", VS
80
        SUBS    r11, r11, #1
        BNE     %BT60

        ADD     r0, r5, #'0'            ; Units column is simple
        BL      VariformOutputChar
        MOVVC   r0, #0
        BLVC    VariformOutputChar 
        Pull    "r1, r5-r9, pc", VS
        Pull    "r0, r5-r9, pc"

VariformOutputFileSize ROUT
        CMP     r3, #8                  ; Deal with up to 2^(8*8) or 64 bit
        BHI     VariBadNumb
        
        Push    "r1, r5-r6"
        ADD     r12, r0, r3             ; Input block
        MOV     r14, r3
        MOV     r5, #0
        MOV     r6, #0
10
        LDRB    r0, [r12, #-1]!
        CMP     r14, #4
        ORRHI   r6, r0, r6, LSL #8      ; Hi input word
        ORRLS   r5, r0, r5, LSL #8      ; Lo input word
        SUBS    r14, r14, #1
        BNE     %BT10

        MOV     r10, #0                 ; SI unit index
20
        CMP     r6, #1
        CMPCC   r5, #4096               ; Keep dividing until < 4096
        BCC     %FT30
        MOV     r14, r6, LSL #22
        MOV     r6, r6, LSR #10
        MOVS    r5, r5, LSR #10
        ORR     r5, r14, r5
        ADCS    r5, r5, #0              ; Round up lost bit
        ADC     r6, r6, #0
        ADD     r10, r10, #1            ; Next 10^3 up
        B       %BT20
30
        TEQ     r4, #ConvertToFileSize
        BEQ     %FT50                   ; Don't do leading spaces

        MOV     r0, #' '                ; Do leading spaces
        CMP     r5, #1000
        BLCC    VariformOutputChar
        CMP     r5, #100
        BLCC    VariformOutputChar
        CMP     r5, #10
        BLCC    VariformOutputChar
        Pull    "r1, r5-r6, pc", VS
50
        Push    "r3-r5, r10"
        ADD     r0, sp, #8              ; Use R5
        MOV     r3, #2
        MOV     r4, #ConvertToCardinal
        BL      VariformOutput
        Pull    "r3-r5, r10"

        MOVVC   r0, #' '                ; Always need that space
        BLVC    VariformOutputChar
        Pull    "r1, r5-r6, pc", VS

        ADR     r14, PrefixSI
        LDRB    r0, [r14, r10]
        TEQ     r4, #ConvertToFileSize
        MOVNE   r10, #' '
        MOVEQ   r10, #0
        TEQEQ   r0, #' '
        MOVEQ   r0, #0                  ; Supress padding SI unit too
        BL      VariformOutputChar      ; Catch overflows when doing the suffix

        LDR     r0, SuffixSI
60
        BL      VariformOutputChar
        Pull    "r1, r5-r6, pc", VS
        MOVS    r0, r0, LSR #8
        BNE     %BT60

        CMP     r5, #1                  ; I am the one and only
        MOVNE   r0, #'s'
        MOVEQ   r0, r10
        BL      VariformOutputChar

        MOVVC   r0, #0                  ; Terminate
        BLVC    VariformOutputChar
        Pull    "r1, r5-r6, pc", VS
        Pull    "r0, r5-r6, pc"

VariformOutputShortIPv6 ROUT
        TST     r3, #1                  ; Must be a halfword multiple
        BNE     VariBadNumb

        Push    "r1, r3-r9"
        MOV     r12, r0                 ; Input block
        MOV     r10, #0                 ; Index loop
        MOV     r5, #0                  ; Set thisstart = 0
        MOV     r6, #0                  ;     thisrun = 0
        MOV     r7, #0                  ; Set maxstart = length
        MOV     r8, #0                  ;     maxrun = 0
        MOV     r9, #2_10               ; Set last != 0, current = 0
10
        LDRB    r11, [r12], #1          ; Hi
        LDRB    r14, [r12], #1          ; Lo
        ORRS    r14, r14, r11, LSL #8

        ORRNE   r9, r9, #2_01
        ANDS    r9, r9, #3              
        ADDEQ   r6, r6, #1              ; Case 2_00 : last & current zero -> in a run
                                        ; Case 2_01 : last is zero, current is not -> end of a run
        CMP     r9, #2_10               ; Case 2_10 : last is nonzero, current is -> start of a run
        MOVEQ   r6, #1                  ; Case 2_11 : not interesting
        MOVEQ   r5, r10

        CMP     r6, r8                  ; max = MAX(max, this)
        MOVCS   r8, r6
        MOVCS   r7, r5                  

        MOV     r9, r9, LSL #1          ; last = current
        ADD     r10, r10, #2
        TEQ     r10, r3
        BNE     %BT10

        MOV     r4, #ConvertToIPv6
        MOV     r5, r0                  ; Keep original start
        CMP     r8, #1                  ; Longest run was only 1, don't compact this
        MOVLS   r7, r3                  ; Make maxstart = length
        BLS     %FT30

        ADD     r8, r7, r8, LSL #1      ; maxstart + maxcount
        
        SUB     r3, r3, r8              ; Do length - (maxstart + maxcount) to the end
        ADD     r0, r0, r8              ; At original start + (maxstart + maxcount)
        BL      VariformOutput

        MOVVC   r0, #':'                ; Skip maxcount, abbreviate to '::'
        BLVC    VariformOutputChar
        BLVC    VariformOutputChar
30
        MOVVC   r3, r7                  ; Lowest maxstart bytes
        MOVVC   r0, r5                  ; From original start
        BLVC    VariformOutput

        Pull    "r1, r3-r9, pc", VS
        Pull    "r0, r3-r9, pc"

VariformOutputIPv6
        TST     r3, #1                  ; Must be a halfword multiple
        BNE     VariBadNumb

        Push    "r1, r3"
        ADD     r12, r0, r3             ; Input block
10
        LDRB    r11, [r12, #-1]!        ; Hi
        LDRB    r0, [r12, #-1]!         ; Lo
        ORR     r0, r0, r11, LSL #8

        Push    "r3-r4, r12"
        MOV     r3, #1                  ; Must output at least 1 digit
        MOVS    r0, r0, LSR #4
        ADDNE   r3, r3, #1
        MOVS    r0, r0, LSR #4
        ADDNE   r3, r3, #1
        MOVS    r0, r0, LSR #4
        ADDNE   r3, r3, #1
        MOV     r4, #ConvertToHexLowercase
        MOV     r0, r12
        BL      VariformOutput          ; Up to 4 nybbles please
        Pull    "r3-r4, r12"
        Pull    "r1, r3, pc", VS

        SUBS    r3, r3, #2
        MOVNE   r0, #':'                ; Separator
20
        MOVEQ   r0, #0                  ; Terminator
        BL      VariformOutputChar
        Pull    "r1, r3, pc", VS

        TEQ     r3, #0
        Pull    "r0, r3, pc", EQ        ; Done
        B       %BT10                   ; More

VariformOutputUUID
        TEQ     r3, #16                 ; Must be exactly 128b
        BNE     VariBadNumb

        Push    "r1, r3"
        MOV     r12, r0                 ; Input block
10
        Push    "r3-r4, r12"
        MOV     r3, #2
        MOV     r4, #ConvertToHexLowercase
        MOV     r0, r12
        BL      VariformOutput          ; 2 lowercase nybbles please
        Pull    "r3-r4, r12"
        Pull    "r1, r3, pc", VS

        TEQ     r3, #17 - 4
        TEQNE   r3, #17 - 6
        TEQNE   r3, #17 - 8
        TEQNE   r3, #17 - 10
        MOVEQ   r0, #"-"                ; Separator
        BLEQ    VariformOutputChar
20
        SUBS    r3, r3, #1
        ADDNE   r12, r12, #1
        BNE     %BT10                   ; More

        MOV     r0, #0                  ; Terminator
        BL      VariformOutputChar
        Pull    "r1, r3, pc", VS
        Pull    "r0, r3, pc"            ; Done

VariformOutputDotColon ROUT
        Push    "r1, r3-r4"
        ADD     r12, r0, r3             ; Input block
        TEQ     r4, #ConvertToIPv4
        MOVEQ   r4, #ConvertToCardinal
        MOVEQ   r10, #'.'
        MOVNE   r4, #ConvertToHex
        MOVNE   r10, #':'
10
        LDRB    r11, [r12, #-1]!        ; Not actually used

        Push    "r3, r10, r12"
        TEQ     r4, #ConvertToHex
        MOVEQ   r3, #2                  ; Two nybbles please
        MOVNE   r3, #1                  ; One octet please
        MOV     r0, r12
        BL      VariformOutput
        Pull    "r3, r10, r12"
        Pull    "r1, r3-r4, pc", VS

        SUBS    r3, r3, #1
        MOVNE   r0, r10                 ; Separator
        MOVEQ   r0, #0                  ; Terminator
        BL      VariformOutputChar
        Pull    "r1, r3-r4, pc", VS

        TEQ     r3, #0
        Pull    "r0, r3-r4, pc", EQ     ; Done
        B       %BT10                   ; More

VariformOutputBinHex ROUT
        Push    "r1, r5"
        TEQ     r4, #ConvertToBinary
        MOVEQ   r5, #1                  ; Step size in bits
        MOVNE   r5, #4
        ADDEQ   r12, r0, r3             ; Input block
        ADDNE   r12, r3, #1
        ADDNE   r12, r0, r12, LSR #1    ; Input block adjusted for nybbles and bytes
        MOVEQ   r10, r3, LSL #3
        MOVNE   r10, r3, LSL #2         ; Total bit count
10
        TEQ     r10, #0
        BNE     %FT20
        MOV     r0, #0
        BL      VariformOutputChar      ; Terminate even if nothing
        Pull    "r1, r5, pc", VS
        Pull    "r0, r5, pc"
20
        LDRB    r11, [r12, #-1]!        ; Current byte
        TST     r10, #7
        MOVEQ   r11, r11, LSL #24       ; Work at top for LSL and LSR
        MOVNE   r11, r11, LSL #28       ; Partial nybble
30
        RSB     r0, r5, #32             ; Shift of 8 - step + 24
        MOV     r0, r11, LSR r0
        CMP     r0, #10
        ADDCC   r0, r0, #'0'
        ADDCS   r0, r0, #'A' - 10
        TEQ     r4, #ConvertToHexLowercase
        ORREQ   r0, r0, #&20            ; Lowercasify (0-9 unaffected)
        BL      VariformOutputChar
        Pull    "r1, r5, pc", VS

        MOV     r11, r11, LSL r5
        SUB     r10, r10, r5
        TST     r10, #7
        BNE     %BT30
        B       %BT10                   ; Either the end or need a new byte

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_BinaryToDecimal
; ------------------
; Convert int32_t to string SWI (with no terminator)
; prefixed '-' if negative, leading zeros always stripped.
; In  : R0 signed 32-bit integer
;       R1 pointer to buffer
;       R2 max buffer length
; Out : R0, R1 unmodified
;       R2 actual chars given
;       V Set if buffer overflow

BinaryToDecimal_Code ROUT
        Push    "R0, R3-R5"
        MOV     R12, R2                 ; Keep buffer length
        MOV     R2, #0
        CMP     R0, #0
        BPL     %FT01
        SUBS    R12, R12, #1            ; Check enough buffer for '-'
        BMI     %FT10
        MOV     R11, #"-"
        STRB    R11, [R1]               ; Place the '-'
        MOV     R2, #1
        RSB     R0, R0, #0

        ; now do digits.
01      RSB     R0, R0, #0              ; get negative so minint works.
        ADRL    R3, TenTimesTable
        MOV     R10, #9                 ; max entry 10^9
        MOV     R4, #0                  ; non-0 had flag
02      LDR     R11, [R3, R10, LSL #2]
        MOV     R5, #-1                 ; digit value
03      ADDS    R0, R0, R11
        ADD     R5, R5, #1
        BLE     %BT03
        SUB     R0, R0, R11
        CMP     R5, #0
        CMPEQ   R4, #0
        BNE     %FT05                   ; put digit
04      SUBS    R10, R10, #1
        BPL     %BT02                   ; next digit
        CMP     R4, #0
        BEQ     %FT05                   ; finished, nothing output, must be '0'
        Pull    "R0, R3-R5"
        B       SLVK

05      SUBS    R12, R12, #1
        BMI     %FT10                   ; naff Exit
        ADD     R5, R5, #"0"
        MOV     R4, #-1                 ; set flag, a non-zero had
        STRB    R5, [R1, R2]
        ADD     R2, R2, #1
        B       %BT04
10
        ADRL    R0, BufferOFloError
    [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
    ]
        ADD     SP, SP, #4              ; discard R0 in
        Pull    "R3-R5"
        B       SLVK_SetV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_ConvertFileSize
; OS_ConvertFixedFileSize
; -----------------------
; Do length as xxxx bytes or xxxx kbytes or xxxx Mbytes
; In  : R0 file size in bytes
;       R1 pointer to buffer
;       R2 max buffer length
; Out : R0 pointer to buffer
;       R1 pointer to terminator
;       R2 free bytes in buffer
;       V Set if buffer overflow

FileSize_Code ROUT
        Push    "r0, r3-r4, lr"
        MOV     r0, sp

        MOVEQ   r4, #ConvertToFixedFileSize
        MOVNE   r4, #ConvertToFileSize

        MOV     r3, #4                  ; Always 4 bytes
        
        BL      VariformOutput
        ADD     sp, sp, #4
        Pull    "r3-r4, lr"
        B       SLVK_TestV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_ConvertNetStation
; OS_ConvertFixedNetStation
; -------------------------
; EcoNet conversions of the form 'nnn.sss' for the fixed variant, or shorter
; In  : R0 pointer to two word net/station number block
;       R1 pointer to buffer
;       R2 max buffer length
; Out : R0 pointer to buffer
;       R1 pointer to terminator
;       R2 free bytes in buffer
;       V Set if buffer overflow

rStn    RN      10
rNet    RN      12
NetStation_Code ROUT
        Push    "r1, r9, lr"

        ASSERT  rStn < rNet
        LDMIA   r0, { rStn, rNet }
        CMP     rNet, #256
        ADRCS   r0, ErrorBlock_BadNetwork
        BCS     %FT40

        CMP     rStn, #0
        CMPNE   rStn, #256
        ADRCS   r0, ErrorBlock_BadStation
        BCS     %FT40

        TEQ     r11, #OS_ConvertNetStation
        MOVNE   r9, #' '                ; Select padding
        MOVEQ   r9, #0
        BL      NetToDec
        BVS     %FT30

        MOV     r0, #'.'                ; Dot normally
        CMP     rNet, #1                ; Prepare carry
        TEQ     r11, #OS_ConvertNetStation
        BNE     %FT10
        MOVCC   r0, #0                  ; Nothing for net of zero
        MOV     r9, #0                  ; Then no padding regardless
        B       %FT20
10
        MOVCC   r0, #' '                ; Space next if net of zero
        MOVCC   r9, #' '                ; Prepad with space
        MOVCS   r9, #'0'                ; or 0
20
        BL      VariformOutputChar
        MOVVC   rNet, rStn
        BLVC    NetToDec                ; Includes terminator
30
        Pull    "r0, r9, lr", VC
        Pull    "r1, r9, lr", VS
        B       SLVK_TestV
40
      [ International
        BL      TranslateError
        Pull    "r1, r9, lr"
        B       SLVK_SetV
      |
        Pull    "r1, r9, lr"
        B       SLVK_SetV
      ]

NetToDec
        Push    "lr"
        MOV     r0, r9
        CMP     rNet, #100
        BLCC    VariformOutputChar
        CMP     rNet, #10
        BLCC    VariformOutputChar

        TEQ     rNet, #0                ; Can't have a station of zero anyway
        BNE     %FT50
        BL      VariformOutputChar      ; Pad instead of "0"
        Pull    "pc"
50
        MOV     r0, rNet
        SWI     XOS_ConvertCardinal1
        Pull    "pc"

        MakeInternatErrorBlock BadNetwork,,BadNet        

        MakeInternatErrorBlock BadStation,,BadStn

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_ConvertStandardDateAndTime
; -----------------------------
; Convert from 5-byte cs representation to format specified in <SYS$DateFormat>
; In  : R0 -> time block
;       R1 -> buffer to accept conversion
;       R2 = size of buffer
;
; Out : R0 = input value of R1, or error block
;       R1 = updated pointer to buffer
;       R2 = updated size of buffer
;       V Set if error

StandardDateTime_Code ROUT
        Push    "R3, R14"
        MOVS    R3, R2                  ; Territory SWI wants things one register up
        BMI     %FT10                   ; Actively reject unlikely buffer sizes        
        MOV     R2, R1
        MOV     R1, R0
        MOV     R0, #-1                 ; Use configured territory
        SWI     XTerritory_ConvertStandardDateAndTime
        Pull    "R3, R14"
        B       SLVK_TestV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_ConvertDateAndTime
; ---------------------
; Convert from 5-byte cs representation to format specified by user
; In  : R0 -> time block
;       R1 -> buffer to accept conversion
;       R2 = size of buffer
;       R3 -> format string
;
; Out : R0 = input value of R1, or error block
;       R1 = updated pointer to buffer
;       R2 = updated size of buffer
;       V Set if error

DateTime_Code
        Push    "R3-R4, R14"
        MOV     R4, R3                  ; Territory SWI wants things one register up.
        MOVS    R3, R2
        BMI     %FT10                   ; Actively reject unlikely buffer sizes
        MOV     R2, R1
        MOV     R1, R0
        MOV     R0, #-1                 ; Use configured territory.
        SWI     XTerritory_ConvertDateAndTime
        Pull    "R3-R4, R14"
        B       SLVK_TestV
10
        ADRL    R0, ErrorBlock_BuffOverflow
      [ International
        BL      TranslateError
      ]
        B       SLVK_SetV

        END
@


4.4
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@d127 3
d191 2
a192 1
        B       VariformOutputBinHex    ; ConvertToHexLowercase  
d490 31
@


4.4.2.1
log
@Merge in latest changes from main branch


Version 5.88, 4.129.2.4. Tagged as 'Kernel-5_88-4_129_2_4'
@
text
@a126 3
        TEQ     r4, #ConvertToUUID
        MOVEQ   r2, #(16 * 2) + 4       ; 128b in hex with 4 hyphens
        BEQ     %FT30
a188 1
        B       VariformOutputUUID      ; ConvertToUUID  
a485 31
VariformOutputUUID
        TEQ     r3, #16                 ; Must be exactly 128b
        BNE     VariBadNumb

        Push    "r1, r3"
        MOV     r12, r0                 ; Input block
10
        Push    "r3-r4, r12"
        MOV     r3, #2
        MOV     r4, #ConvertToHexLowercase
        MOV     r0, r12
        BL      VariformOutput          ; 2 lowercase nybbles please
        Pull    "r3-r4, r12"
        Pull    "r1, r3, pc", VS

        TEQ     r3, #17 - 4
        TEQNE   r3, #17 - 6
        TEQNE   r3, #17 - 8
        TEQNE   r3, #17 - 10
        MOVEQ   r0, #"-"                ; Separator
        BLEQ    VariformOutputChar
20
        SUBS    r3, r3, #1
        ADDNE   r12, r12, #1
        BNE     %BT10                   ; More

        MOV     r0, #0                  ; Terminator
        BL      VariformOutputChar
        Pull    "r1, r3, pc", VS
        Pull    "r0, r3, pc"            ; Done

@


4.3
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d15 1
a15 1
        TTL     => Convrsions : varicose number->string routines
d19 12
a30 1
        MOV     r12, #0                 ; All conversions want initial cnt = 0
d32 3
d36 114
a149 1
        BGE     EconetStation
d151 8
a158 39
        Push    "R1, lr"
        SUB     R10, R11, #OS_ConvertHex1 + 1
        BIC     R10, R10, #3
        ADD     PC, PC, R10
        B       Hex_Output       ; one digit     : -4
        B       Hex_Output       ; 2,3,4,8 digits:  0
        B       Cardinal_Output                  ;  4
        B       Signed_Output                    ;  8
        B       Binary_Output                    ; 12
        B       Cardinal_Spaced_Output           ; 16
        B       Signed_Spaced_Output             ; 20

Hex_Output ROUT

        SUBS    R11, R11, #OS_ConvertHex1
        MOVNE   R11, R11, LSL #3
        MOVEQ   R11, #4
        MOV     R0, R0, ROR R11

01      MOV     R0, R0, ROR #28
        AND     R10, R0, #&F
        CMP     R10, #10
        ADDGE   R10, R10, #"A"-10
        ADDLT   R10, R10, #"0"
        BL      addconvchar
        BVS     naffconversion
        SUBS    R11, R11, #4
        BNE     %BT01

endconversion
        MOVVC   R10, #0
        BLVC    addconvchar
        BVS     naffconversion

        Pull    "R0, lr"
        SUB     R2, R2, R12
        ADD     R2, R2, #1              ; null not really a char.
        SUB     R1, R1, #1
        ExitSWIHandler
d160 39
a198 3
naffconversion
        ADRL    R0, ErrorBlock_BuffOverflow
naffconversion_ErrorSet
d201 2
d204 350
a553 2
        Pull    "R1, lr"
        B       SLVK_SetV
d555 24
a578 1
Binary_Output ROUT
d580 2
a581 23
        SUB     R11, R11, #OS_ConvertBinary1-1
        MOV     R11, R11, LSL #3
        MOV     R0, R0, ROR R11
01      MOV     R0, R0, ROR #31
        AND     R10, R0, #1
        ADD     R10, R10, #"0"
        BL      addconvchar
        BVS     naffconversion
        SUBS    R11, R11, #1
        BNE     %BT01
        B       endconversion


; cardinal output very similar to BinaryToDecimal

Cardinal_Output ROUT

        SUB     R11, R11, #OS_ConvertCardinal1-1
        MOV     R11, R11, LSL #3
        MOV     R10, #-1
        MOV     R10, R10, LSL R11
        BIC     R0, R0, R10
        Push    "R3-R5"
d583 1
a583 1
        MOV     R5, #9                  ; max entry
d585 7
a591 7
02      LDR     R11, [R3, R5, LSL #2]
        MOV     R10, #"0"-1             ; digit value
03      SUBS    R0, R0, R11
        ADD     R10, R10, #1
        BCS     %BT03
        ADD     R0, R0, R11
        CMP     R10, #"0"
d593 2
a594 3
        BNE     %FT04                   ; put digit

05      SUBS    R5, R5, #1
d597 19
a615 1
        BEQ     %FT04                   ; R5 must be 0
d617 1
a617 62
        B       endconversion

04      MOV     R4, #-1
        BL      addconvchar
        BVC     %BT05
        Pull    "R3-R5"
        B       naffconversion


Signed_Output ROUT

        SUB     R11, R11, #OS_ConvertInteger1-1
        MOV     R11, R11, LSL #3
        AND     R11, R11, #31
        RSB     R11, R11, #32
        AND     R11, R11, #31
        MOV     R0, R0, LSL R11
        MOV     R0, R0, ASR R11
        MOV     R12, R2
        SWI     XOS_BinaryToDecimal
        MOVVS   r2, r12
        ADDVC   R1, R1, R2
        Swap    R2, R12, VC
        B       endconversion


Cardinal_Spaced_Output ROUT
Signed_Spaced_Output

        SUB     sp, sp, #12             ; get 12 byte buffer
        Push    "r1,r2,lr"
        LDR     r10,code_of_swi
        ADD     r10,r10,r11
        ADD     r1, sp, #3*4
        MOV     r2, #12
        SWI     XOS_CallASWI
        RSB     r0, r2, #12            ; bytes got
        Pull    "r1,r2,lr"
        MOV     R12, #0
        MOV     R11, sp
01      LDRB    R10, [R11], #1
        BL      addconvchar
        BVS     space_conv_exit
        SUBS    R0, R0, #1
        BEQ     space_conv_exit
        CMP     R10, #"-"
        BEQ     %BT01
        CMP     R0, #3
        CMPNE   R0, #6
        CMPNE   R0, #9
        BNE     %BT01
        MOV     R10, #" "
        BL      addconvchar
        BVC     %BT01

space_conv_exit
        ADD     sp, sp, #12
        B       endconversion

code_of_swi
        DCD     XOS_ConvertCardinal1 - OS_ConvertSpacedCardinal1

d620 25
a644 15
; R1 current buffer pos
; R12 character count, R2 character limit
; R10 character

addconvchar ROUT

        CMP     R2, R12
        BLE     addconvcharoverflow

        ADD     R12, R12, #1
        STRB    R10, [R1], #1
        RETURNVC

addconvcharoverflow
        RETURNVS
d647 62
a708 1
; EcoNet conversions
d710 7
a716 1
EconetStation ROUT
d718 8
a725 2
        CMP     R11, #OS_ConvertFixedFileSize
        BGE     FileSizeConversion
d727 1
a727 39
        Push    "R1, lr"
        Push    "R0"
        LDR     R0, [R0, #4]
        CMP     R0, #256
        BHS     invalidnetworknumber
        MOV     R10, #" "
        BL      doabyte
        BVS     %FT01
        CMP     R10, #"0"
        MOVEQ   R10, #"."
        CMPNE   R11, #OS_ConvertFixedNetStation
        BLEQ    addconvchar
        CMP     R10, #"."
        MOVEQ   R10, #"0"

01
        Pull    "R0"
        BVS     naffconversion
        LDR     R0, [R0]
        CMP     R0, #0
        CMPNE   R0, #256
        BHS     invalidstationnumber
        BL      doabyte
        B       endconversion

invalidnetworknumber
        INC     sp, 4                           ; Pull    "R0"
        ADR     R0, ErrorBlock_BadNetwork
        B       naffconversion_ErrorSet

invalidstationnumber
        ADR     R0, ErrorBlock_BadStation
        B       naffconversion_ErrorSet

ErrorBlock_BadNetwork
        DCD     ErrorNumber_BadNetwork
        DCB     "BadNet"                        ; The token for the Global message
        DCB     0
        ALIGN
d729 1
a729 35
ErrorBlock_BadStation
        DCD     ErrorNumber_BadStation
        DCB     "BadStn"                        ; The token for the Global message
        DCB     0
        ALIGN

doabyte ROUT
 ; R0 is byte, R11 SWI number (to indicate pad or not)
 ; return VS for oflo
        Push    "lr"
        CMP     R11, #OS_ConvertNetStation
        BEQ     %FT03
        CMP     R0, #100
        BGE     %FT03
        BL      addconvchar
        Pull    "PC", VS
02      CMP     R0, #10
        BGE     %FT03
        BL      addconvchar
        Pull    "PC", VS
03      CMP     R0, #0
        BNE     %FT01
        CMP     R11, #OS_ConvertNetStation
        Pull    "PC", EQ
        Pull    "lr"
        B       addconvchar

01      MOV     R10, R2
        SUB     R2, R2, R12         ; bytes left
        SWI     XOS_BinaryToDecimal
        ADD     R12, R12, R2
        ADD     R1, R1, R2
        MOV     R2, R10
        MOV     R10, #"0"
        Pull    "PC"
d732 22
a753 103
; Do length as xxxx bytes or xxxx Kbytes or xxxx Mbytes

; In    r0 = size in bytes
;       r1 -> buffer
;       r2 = buffer length
;       r12 = 0

; Out   r0 = r1in
;       r1 -> terminating zero
;       r2 = amount of buffer left

FileSizeConversion ROUT

        Push    "r1, lr"

        Push    "r4-r7"
        SUB     sp, sp, #16             ; May need temp frame

        MOV     r4, #0                  ; No char by default
        CMP     r0, #4096               ; Only go to 'K' format if > 4K
        MOVCS   r4, #"K"                ; Kilo
        MOVCSS  r0, r0, LSR #10         ; /1024
        ADC     r0, r0, #0              ; Round up iff divided and bit fell out
        CMP     r0, #4096               ; Only go to 'M' format if > 4M
        MOVCS   r4, #"M"                ; Mega
        MOVCSS  r0, r0, LSR #10         ; /1024 again
        ADC     r0, r0, #0              ; Round up iff divided and bit fell out

; No need to go to 'G' format as 2^32 = 4096M!

        MOV     r5, r0                  ; Remember for prettiness

        CMP     r11, #OS_ConvertFixedFileSize
        BNE     %FT50

        Push    "r1, r2"                ; Remembering state
        ADD     r1, sp, #4*2            ; Point to our temp buffer
        MOV     r2, #16
        SWI     XOS_BinaryToDecimal     ; This will not give error
        MOV     r7, r2                  ; Number of chars to do
        RSBS    r6, r2, #4              ; Number of spaces needed
        Pull    "r1, r2"
        BLE     %FT39

30      MOV     r10, #" "
        BL      addconvchar
        BVS     %FA95
        SUBS    r6, r6, #1
        BNE     %BT30

39      MOV     r6, sp                  ; Stick string in punter's buffer
40      LDRB    r10, [r6], #1
        BL      addconvchar
        BVS     %FA95
        SUBS    r7, r7, #1
        BNE     %BT40

        B       %FT60


50      MOV     r12, r2                 ; No padding on LHS, easy case
        SWI     XOS_BinaryToDecimal
        MOVVS   r2, r12
        ADDVC   r1, r1, r2
        Swap    r2, r12, VC

60      MOVVC   r10, #" "
        BLVC    addconvchar
        BVS     %FA95

        MOVS    r10, r4                 ; Char to print ? VClear
        BNE     %FT70

        CMP     r11, #OS_ConvertFixedFileSize ; VClear
        BNE     %FT75

        MOV     r10, #" "               ; Need to pad in middle

70      BL      addconvchar

75      MOVVC   r10, #"b"               ; 'byte'
        BLVC    addconvchar
        MOVVC   r10, #"y"
        BLVC    addconvchar
        MOVVC   r10, #"t"
        BLVC    addconvchar
        MOVVC   r10, #"e"
        BLVC    addconvchar
        BVS     %FA95

        CMP     r5, #1                  ; Prettify (unpluralisationism). VClear
        MOVNE   r10, #"s"
        BNE     %FT90

        CMP     r11, #OS_ConvertFixedFileSize ; VClear
        BNE     %FA95
        MOV     r10, #" "               ; Need to pad to right

90      BL      addconvchar

95      ADD     sp, sp, #16
        Pull    "r4-r7"
        B       endconversion
d756 30
@


4.3.2.1
log
@Conversions rationalisation.
Delete pmf/convdate, moved to conversions.
Moved OS_BinaryToDecimal to conversions.
Remove OS_ConvertHex16 and friends.
Add OS_ConvertVariform skeleton.
Tidied conversions.

Version 5.35, 4.79.2.125. Tagged as 'Kernel-5_35-4_79_2_125'
@
text
@d15 1
a15 1
        TTL     => Convrsions : various number to string routines
d19 1
a19 2
        ; All conversions want initial count = 0
        MOV     r12, #0
a20 12
        ; Pick off the non table driven ones
        CMP     R11, #OS_ConvertVariform
        BEQ     Variform_Code

        CMP     R11, #OS_ConvertStandardDateAndTime
        BEQ     StandardDateTime_Code
        CMP     R11, #OS_ConvertDateAndTime
        BEQ     DateTime_Code

        ASSERT  OS_ConvertFixedFileSize > OS_ConvertFixedNetStation
        CMP     R11, #OS_ConvertFixedFileSize
        BGE     FileSize_Code
d22 1
a22 1
        BGE     NetStation_Code
a24 1
        ; Chop into groups of 4 and use a table
d28 7
a34 7
        B       Hex_Code                ; -4 Hex1
        B       Hex_Code                ;  0 Hex2/4/6/8
        B       Cardinal_Code           ;  4
        B       Signed_Code             ;  8
        B       Binary_Code             ; 12
        B       Cardinal_Spaced_Code    ; 16
        B       Signed_Spaced_Code      ; 20
d36 1
a36 1
Hex_Code ROUT
d62 1
a62 1
        B       SLVK
d73 1
a73 1
Binary_Code ROUT
d87 4
a90 1
Cardinal_Code ROUT
d124 2
a125 1
Signed_Code ROUT
d141 3
a143 2
Cardinal_Spaced_Code ROUT
Signed_Spaced_Code
d178 1
d180 5
a184 11
; OS_ConvertNetStation
; OS_ConvertFixedNetStation
; -------------------------
; EcoNet conversions of the form 'nnn.sss' for the fixed variant, or shorter
; In  : R0 pointer to two word net/station number block
;       R1 pointer to buffer
;       R2 max buffer length
; Out : R0 pointer to buffer
;       R1 pointer to terminator
;       R2 free bytes in buffer
;       V Set if buffer overflow
d186 17
a202 1
NetStation_Code ROUT
d206 1
a206 1
        LDR     R0, [R0, #4]                    ; network number
d218 1
d222 1
a222 1
        LDR     R0, [R0, #0]                    ; station number
d230 1
a230 1
        ADD     sp, sp, #4                      ; Pull    "R0"
d251 2
a252 2
        ; R0 is byte, R11 SWI number (to indicate pad or not)
        ; return VS for oflo
d272 1
a272 1
        SUB     R2, R2, R12                     ; bytes left
a279 10
addconvchar ROUT
        ; R1 current buffer pos
        ; R12 character count, R2 character limit
        ; R10 character
        CMP     R2, R12
        RETURNVS LE
        ADD     R12, R12, #1
        STRB    R10, [R1], #1
        RETURNVC

d281 1
a281 23
; OS_ConvertDateAndTime
; ---------------------
; Convert from 5-byte cs representation to format specified in <SYS$DateFormat>
; In  : R0 -> time block
;       R1 -> buffer to accept conversion
;       R2 = size of buffer
;       R3 -> format string
;
; Out : R0 = input value of R1, or error block
;       R1 = updated pointer to buffer
;       R2 = updated size of buffer
;       V Set if error

StandardDateTime_Code ROUT

        Push    "R3,R14"
        MOV     R3, R2                  ; Territory SWI wants things one register up
        MOV     R2, R1
        MOV     R1, R0
        MOV     R0, #-1                 ; Use configured territory
        SWI     XTerritory_ConvertStandardDateAndTime
        Pull    "R3, R14"
        B       SLVK_TestV
d283 8
a290 25
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_ConvertDateAndTime
; ---------------------
; Convert from 5-byte cs representation to format specified by user
; In  : R0 -> time block
;       R1 -> buffer to accept conversion
;       R2 = size of buffer
;       R3 -> format string
;
; Out : R0 = input value of R1, or error block
;       R1 = updated pointer to buffer
;       R2 = updated size of buffer
;       V Set if error

DateTime_Code ROUT

        Push    "R4, R14"
        MOV     R4, R3                  ; Territory SWI wants things one register up.
        MOV     R3, R2
        MOV     R2, R1
        MOV     R1, R0
        MOV     R0, #-1                 ; Use configured territory.
        SWI     XTerritory_ConvertDateAndTime
        Pull    "R4, R14"
        B       SLVK_TestV
d292 1
a292 12
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_ConvertFileSize
; OS_ConvertFixedFileSize
; -----------------------
; Do length as xxxx bytes or xxxx kbytes or xxxx Mbytes
; In  : R0 file size in bytes
;       R1 pointer to buffer
;       R2 max buffer length
; Out : R0 pointer to buffer
;       R1 pointer to terminator
;       R2 free bytes in buffer
;       V Set if buffer overflow
d294 1
a294 1
FileSize_Code ROUT
a295 1
        Push    "r1, lr"
d300 2
a301 2
        CMP     r0, #4096               ; Only go to 'k' format if > 4k
        MOVCS   r4, #"k"
d305 1
a305 1
        MOVCS   r4, #"M"
d309 1
a309 1
        ; No need to go to 'G' format as 2^32 = 4096M!
a383 23
       
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_ConvertVariform
; ------------------
; Convert some value into some string
; In  : R0 pointer to input value (word alignment)
;       R1 pointer to buffer
;       R2 max buffer length, or -ve to read space required
;       R3 bytes to use from input value (or nybbles if hex output reqd)
;       R4 type to convert to
; Out : R0 pointer to buffer
;       R1 pointer to terminator
;       R2 free bytes in buffer, or NOT space required if R2 -ve on entry
;       V Set if buffer overflow

Variform_Code ROUT

        MOVS    r2, r2
        MVNMI   r2, #0
        BMI     SLVK

        Push    "R0, lr"
        B       endconversion
a385 75
; OS_BinaryToDecimal
; ------------------
; Convert int32_t to string SWI (with no terminator)
; prefixed '-' if negative, leading zeros always stripped.
; In  : R0 signed 32-bit integer
;       R1 pointer to buffer
;       R2 max buffer length
; Out : R0, R1 unmodified
;       R2 actual chars given
;       V Set if buffer overflow

BinaryToDecimal_Code ROUT

        Push    "R0, R3-R5"
        MOV     R12, R2                 ; Keep buffer length
        MOV     R2, #0
        CMP     R0, #0
        BPL     %FT01
        SUBS    R12, R12, #1            ; Check enough buffer for '-'
        BMI     %FT10
        MOV     R11, #"-"
        STRB    R11, [R1]               ; Place the '-'
        MOV     R2, #1
        RSB     R0, R0, #0

        ; now do digits.
01      RSB     R0, R0, #0              ; get negative so minint works.
        ADR     R3, TenTimesTable
        MOV     R10, #9                 ; max entry 10^9
        MOV     R4, #0                  ; non-0 had flag
02      LDR     R11, [R3, R10, LSL #2]
        MOV     R5, #-1                 ; digit value
03      ADDS    R0, R0, R11
        ADD     R5, R5, #1
        BLE     %BT03
        SUB     R0, R0, R11
        CMP     R5, #0
        CMPEQ   R4, #0
        BNE     %FT05                   ; put digit
04      SUBS    R10, R10, #1
        BPL     %BT02                   ; next digit
        CMP     R4, #0
        BEQ     %FT05                   ; finished, nothing output, must be '0'
        Pull    "R0, R3-R5"
        B       SLVK

05      SUBS    R12, R12, #1
        BMI     %FT10                   ; naff Exit
        ADD     R5, R5, #"0"
        MOV     R4, #-1                 ; set flag, a non-zero had
        STRB    R5, [R1, R2]
        ADD     R2, R2, #1
        B       %BT04
10
        ADRL    R0, BufferOFloError
    [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
    ]
        ADD     SP, SP, #4              ; discard R0 in
        Pull    "R3-R5"
        B       SLVK_SetV

TenTimesTable
        DCD     1
        DCD     10
        DCD     100
        DCD     1000
        DCD     10000
        DCD     100000
        DCD     1000000
        DCD     10000000
        DCD     100000000
        DCD     1000000000
@


4.3.2.2
log
@Added 'UnConv' error (see also HdrSrc).
Implement OS_ConvertVariform, internally the other conversions now just call it.
Add tester for Variform to 'Dev'.
Made block copy weirdness for XScale dependent on XScale arch flag.

Version 5.35, 4.79.2.126. Tagged as 'Kernel-5_35-4_79_2_126'
@
text
@d19 3
d24 2
a25 6
        BNE     %FT10
        Push    "lr"
        BL      VariformInternal
        Pull    "lr"
        B       SLVK_TestV
10
d37 40
a76 72
        ; Use SWI number as index into tables mapping to OS_ConvertVariform
        Push    "r0, r3-r4, lr"
        MOV     r0, sp

        SUB     r4, r11, #OS_ConvertHex1 - 3
        ADR     r14, ConvertSizesTable
        LDRB    r3, [r14, r4]
        ADR     r14, ConvertTypesTable
        LDRB    r4, [r14, r4, LSR #2]
        
        BL      VariformOutput
        ADD     sp, sp, #4
        Pull    "r3-r4, lr"
        B       SLVK_TestV

ConvertSizesTable
        DCB     0, 0, 0, 1, 2, 4, 6, 8, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4
        ASSERT  (. - ConvertSizesTable) :AND: 3 = 0
ConvertTypesTable
        DCB     ConvertToHex, ConvertToHex, ConvertToCardinal, ConvertToInteger
        DCB     ConvertToBinary, ConvertToSpacedCardinal, ConvertToSpacedInteger
        ALIGN

TenTimesTable
        DCD     1                       ; 10^0
        DCD     10
        DCD     100
        DCD     1000
        DCD     10000
        DCD     100000
        DCD     1000000
        DCD     10000000
        DCD     100000000
        DCD     1000000000              ; 10^9
TenTimesBigTable
        DCQ     10000000000             ; 10^10
        DCQ     100000000000
        DCQ     1000000000000
        DCQ     10000000000000
        DCQ     100000000000000
        DCQ     1000000000000000
        DCQ     10000000000000000
        DCQ     100000000000000000
        DCQ     1000000000000000000     ; 10^18

CommaPositions
        DCD     2_01001001001001001001001001001000

SuffixSI
        DCB     "byte"        
PrefixSI
        DCB     " kMGTPE"               ; units/kilo/mega/giga/tera/peta/exa
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; VariformInternal
; ----------------
; The guts behind OS_ConvertVariform but callable as a subroutine
; In  : R0 pointer to input value (word alignment)
;       R1 pointer to buffer
;       R2 max buffer length, or -ve to read space required
;       R3 bytes to use from input value (or nybbles if hex output reqd)
;       R4 type to convert to
; Out : R0 pointer to buffer
;       R1 pointer to terminator
;       R2 free bytes in buffer, or NOT space required if R2 -ve on entry
;       V Set if buffer overflow

VariformInternal
        ; Check if it's a read space operation
        MOVS    r2, r2
        BPL     VariformOutput
d78 3
a80 31
VariformCount
        ; Some of them are calculable
        TEQ     r4, #ConvertToBinary
        MOVEQ   r2, r3, LSL #3          ; 8 output chars for every 1 input byte
        BEQ     %FT30
        TEQ     r4, #ConvertToHex
        TEQNE   r4, #ConvertToHexLowercase
        MOVEQ   r2, r3, LSL #1          ; 2 output chars for every 1 input nybble
        BEQ     %FT30
        TEQ     r4, #ConvertToFixedFileSize
        MOVEQ   r2, #4 + 1 + 1 + 5      ; Always '1234 kbytes'
        BEQ     %FT30
        TEQ     r4, #ConvertToEUI
        ADDEQ   r2, r3, r3, LSL #1      ; 3 output chars for every 1 input byte (inc term)
        SUBEQ   r2, r2, #1              ; Don't count the terminator
        BEQ     %FT30
10
        ; A hard length to know, just do it
        Push    "r1, lr"
        SUB     sp, sp, #44             ; Longest is currently IPv6 output
        MOV     r1, sp
        MOV     r2, #44
        BL      VariformOutput
        SUB     r2, r1, r0              ; Length = term - start
        ADD     sp, sp, #44
        Pull    "r1, lr"
        ; Fall through
30
        MVN     r2, r2
40
        ADRL    r0, ErrorBlock_BuffOverflow
a81 1
        Push    "lr"
a82 4
        Pull    "pc"
      |
        SETV
        MOV     pc, lr
d84 2
d87 1
a87 8
VariformOutputChar
        TEQ     r2, #0
        BEQ     %BT40
        CMP     r0, #0                  ; Clears V too
        STREQB  r0, [r1]
        STRNEB  r0, [r1], #1            ; Adjust pointers except for terminating null
        SUBNE   r2, r2, #1
        MOV     pc, lr
d89 22
a110 424
VariformOutput ROUT
        Push    "lr"
        TEQ     r3, #0                  ; Ask for nothing, get a null string
        BNE     %FT10
        MOV     r0, #0
        BL      VariformOutputChar
        MOVVC   r0, r1
        Pull    "pc"
10
        ASSERT  ConvertToHex = 0
        CMP     r4, #(VariformHighest - VariformLowest) / 4
        ADDCC   pc, pc, r4, LSL #2
        BCS     VariBadConv
VariformLowest
        B       VariformOutputBinHex    ; ConvertToHex           
        B       VariformOutputDec       ; ConvertToCardinal      
        B       VariformOutputDec       ; ConvertToInteger       
        B       VariformOutputBinHex    ; ConvertToBinary        
        B       VariformOutputDecSpaced ; ConvertToSpacedCardinal
        B       VariformOutputDecSpaced ; ConvertToSpacedInteger
        B       VariformOutputDecPunct  ; ConvertToPunctCardinal
        B       VariformOutputDecPunct  ; ConvertToPunctInteger
        B       VariformOutputFileSize  ; ConvertToFixedFileSize
        B       VariformOutputFileSize  ; ConvertToFileSize
        B       VariformOutputDotColon  ; ConvertToIPv4          
        B       VariformOutputDotColon  ; ConvertToEUI           
        B       VariformOutputIPv6      ; ConvertToIPv6
        B       VariformOutputShortIPv6 ; ConvertToShortestIPv6  
        B       VariformOutputBinHex    ; ConvertToHexLowercase  
VariformHighest

VariBadConv
        ADR     r0, ErrorBlock_UnConv   ; Unsupported conversion
        B       %FT20
        MakeErrorBlock UnConv
        
VariBadNumb
        ADRL    r0, ErrorBlock_BadNumb  ; Bad number
20
      [ International
        BL      TranslateError
      |
        SETV
      ]
        Pull    "pc"

VariformOutputDecPunct ROUT
        Push    "r0-r1"
        MOV     r0, #-1
        MOV     r1, #1
        SWI     XTerritory_ReadSymbols
        STRVS   r0, [sp]
        Pull    "r0-r1, pc", VS
        LDRB    r10, [r0]               ; Thousands separator
        Pull    "r0-r1"
        B       %FT10

VariformOutputDecSpaced
        MOV     r10, #' '               ; Spaces between 1000's
        B       %FT10
        
VariformOutputDec
        MOV     r10, #0                 ; No gaps between 1000's
10
        CMP     r3, #8                  ; Deal with up to 2^(8*8) or 64 bit
        BHI     VariBadNumb

        Push    "r1, r5-r9"
        ADD     r12, r0, r3             ; Input block
        MOV     r14, r3
        MOV     r5, #0
        MOV     r6, #0
20
        LDRB    r0, [r12, #-1]!
        CMP     r14, #4
        ORRHI   r6, r0, r6, LSL #8      ; Hi input word
        ORRLS   r5, r0, r5, LSL #8      ; Lo input word
        SUBS    r14, r14, #1
        BNE     %BT20

        TEQ     r4, #ConvertToInteger
        TEQNE   r4, #ConvertToSpacedInteger
        TEQNE   r4, #ConvertToPunctInteger
        BNE     %FT40                   ; Treat unsigned

        TEQ     r3, #4
        MOVEQ   r6, r5, ASR #31         ; Extend lo to hi
        ANDS    r11, r3, #3
        BEQ     %FT30                   ; For 4 & 8, no further action
        RSB     r11, r11, #4
        MOV     r11, r11, LSL #3        ; Sign extend shift of (4 - (length MOD 4)) * 8 bit
        CMP     r3, #4
        MOVHI   r6, r6, LSL r11
        MOVHI   r6, r6, ASR r11
        MOVLS   r5, r5, LSL r11
        MOVLS   r5, r5, ASR r11
        MOVLS   r6, r5, ASR #31         ; Extend lo to hi too
30
        CMP     r6, #0                  ; Is it overall negative?
        BPL     %FT50
        MOV     r0, #'-'
        BL      VariformOutputChar
        Pull    "r1, r5-r9, pc", VS
        MVN     r5, r5
        MVN     r6, r6
        ADDS    r5, r5, #1
        ADC     r6, r6, #0              ; Take ABS(r5,r6)
40
        TEQ     r6, #0
50
        MOVEQ   r11, #9                 ; Maximum power of 10 to consider
        MOVNE   r11, #18
        MOV     r9, #0                  ; Supress leading zeros
60
        MOV     r0, #'0'                ; This digit
        CMP     r11, #10
        ADRCC   r12, TenTimesTable
        LDRCC   r7, [r12, r11, LSL #2]
        MOVCC   r8, #0
        ADRCS   r12, TenTimesBigTable - (10 * 8)
        LDRCS   r7, [r12, r11, LSL #3]!
        LDRCS   r8, [r12, #4]
70
        SUBS    r5, r5, r7
        SBCS    r6, r6, r8
        ADDPL   r0, r0, #1              ; Subtracted OK
        BPL     %BT70

        ADDS    r5, r5, r7
        ADC     r6, r6, r8              ; Correct the undershoot
        TEQ     r9, #0
        SUBEQS  r9, r0, #'0'            ; Reevaluate supression if supressing
        BEQ     %FT80
        BL      VariformOutputChar
        Pull    "r1, r5-r9, pc", VS
        MOV     r14, #1
        MOV     r14, r14, LSL r11
        LDR     r0, CommaPositions
        TST     r14, r0                 ; V still clear
        MOVNE   r0, r10
        BLNE    VariformOutputChar
        Pull    "r1, r5-r9, pc", VS
80
        SUBS    r11, r11, #1
        BNE     %BT60

        ADD     r0, r5, #'0'            ; Units column is simple
        BL      VariformOutputChar
        MOVVC   r0, #0
        BLVC    VariformOutputChar 
        Pull    "r1, r5-r9, pc", VS
        Pull    "r0, r5-r9, pc"

VariformOutputFileSize ROUT
        CMP     r3, #8                  ; Deal with up to 2^(8*8) or 64 bit
        BHI     VariBadNumb
        
        Push    "r1, r5-r6"
        ADD     r12, r0, r3             ; Input block
        MOV     r14, r3
        MOV     r5, #0
        MOV     r6, #0
10
        LDRB    r0, [r12, #-1]!
        CMP     r14, #4
        ORRHI   r6, r0, r6, LSL #8      ; Hi input word
        ORRLS   r5, r0, r5, LSL #8      ; Lo input word
        SUBS    r14, r14, #1
        BNE     %BT10

        MOV     r10, #0                 ; SI unit index
20
        CMP     r6, #1
        CMPCC   r5, #4096               ; Keep dividing until < 4096
        BCC     %FT30
        MOV     r14, r6, LSL #22
        MOV     r6, r6, LSR #10
        MOVS    r5, r5, LSR #10
        ORR     r5, r14, r5
        ADCS    r5, r5, #0              ; Round up lost bit
        ADC     r6, r6, #0
        ADD     r10, r10, #1            ; Next 10^3 up
        B       %BT20
30
        TEQ     r4, #ConvertToFileSize
        BEQ     %FT50                   ; Don't do leading spaces

        MOV     r0, #' '                ; Do leading spaces
        CMP     r5, #1000
        BLCC    VariformOutputChar
        CMP     r5, #100
        BLCC    VariformOutputChar
        CMP     r5, #10
        BLCC    VariformOutputChar
        Pull    "r1, r5-r6, pc", VS
50
        Push    "r3-r5, r10"
        ADD     r0, sp, #8              ; Use R5
        MOV     r3, #2
        MOV     r4, #ConvertToCardinal
        BL      VariformOutput
        Pull    "r3-r5, r10"

        MOVVC   r0, #' '                ; Always need that space
        BLVC    VariformOutputChar
        Pull    "r1, r5-r6, pc", VS

        ADR     r14, PrefixSI
        LDRB    r0, [r14, r10]
        TEQ     r4, #ConvertToFileSize
        MOVNE   r10, #' '
        MOVEQ   r10, #0
        TEQEQ   r0, #' '
        MOVEQ   r0, #0                  ; Supress padding SI unit too
        BL      VariformOutputChar      ; Catch overflows when doing the suffix

        LDR     r0, SuffixSI
60
        BL      VariformOutputChar
        Pull    "r1, r5-r6, pc", VS
        MOVS    r0, r0, LSR #8
        BNE     %BT60

        CMP     r5, #1                  ; I am the one and only
        MOVNE   r0, #'s'
        MOVEQ   r0, r10
        BL      VariformOutputChar

        MOVVC   r0, #0                  ; Terminate
        BLVC    VariformOutputChar
        Pull    "r1, r5-r6, pc", VS
        Pull    "r0, r5-r6, pc"

VariformOutputShortIPv6 ROUT
        TST     r3, #1                  ; Must be a halfword multiple
        BNE     VariBadNumb

        Push    "r1, r3-r9"
        MOV     r12, r0                 ; Input block
        MOV     r10, #0                 ; Index loop
        MOV     r5, #0                  ; Set thisstart = 0
        MOV     r6, #0                  ;     thisrun = 0
        MOV     r7, #0                  ; Set maxstart = length
        MOV     r8, #0                  ;     maxrun = 0
        MOV     r9, #2_10               ; Set last != 0, current = 0
10
        LDRB    r11, [r12], #1          ; Hi
        LDRB    r14, [r12], #1          ; Lo
        ORRS    r14, r14, r11, LSL #8

        ORRNE   r9, r9, #2_01
        ANDS    r9, r9, #3              
        ADDEQ   r6, r6, #1              ; Case 2_00 : last & current zero -> in a run
                                        ; Case 2_01 : last is zero, current is not -> end of a run
        CMP     r9, #2_10               ; Case 2_10 : last is nonzero, current is -> start of a run
        MOVEQ   r6, #1                  ; Case 2_11 : not interesting
        MOVEQ   r5, r10

        CMP     r6, r8                  ; max = MAX(max, this)
        MOVCS   r8, r6
        MOVCS   r7, r5                  

        MOV     r9, r9, LSL #1          ; last = current
        ADD     r10, r10, #2
        TEQ     r10, r3
        BNE     %BT10

        MOV     r4, #ConvertToIPv6
        MOV     r5, r0                  ; Keep original start
        CMP     r8, #1                  ; Longest run was only 1, don't compact this
        MOVLS   r7, r3                  ; Make maxstart = length
        BLS     %FT30

        ADD     r8, r7, r8, LSL #1      ; maxstart + maxcount
        
        SUB     r3, r3, r8              ; Do length - (maxstart + maxcount) to the end
        ADD     r0, r0, r8              ; At original start + (maxstart + maxcount)
        BL      VariformOutput

        MOVVC   r0, #':'                ; Skip maxcount, abbreviate to '::'
        BLVC    VariformOutputChar
        BLVC    VariformOutputChar
30
        MOVVC   r3, r7                  ; Lowest maxstart bytes
        MOVVC   r0, r5                  ; From original start
        BLVC    VariformOutput

        Pull    "r1, r3-r9, pc", VS
        Pull    "r0, r3-r9, pc"

VariformOutputIPv6
        TST     r3, #1                  ; Must be a halfword multiple
        BNE     VariBadNumb

        Push    "r1, r3"
        ADD     r12, r0, r3             ; Input block
10
        LDRB    r11, [r12, #-1]!        ; Hi
        LDRB    r0, [r12, #-1]!         ; Lo
        ORR     r0, r0, r11, LSL #8

        Push    "r3-r4, r12"
        MOV     r3, #1                  ; Must output at least 1 digit
        MOVS    r0, r0, LSR #4
        ADDNE   r3, r3, #1
        MOVS    r0, r0, LSR #4
        ADDNE   r3, r3, #1
        MOVS    r0, r0, LSR #4
        ADDNE   r3, r3, #1
        MOV     r4, #ConvertToHexLowercase
        MOV     r0, r12
        BL      VariformOutput          ; Up to 4 nybbles please
        Pull    "r3-r4, r12"
        Pull    "r1, r3, pc", VS

        SUBS    r3, r3, #2
        MOVNE   r0, #':'                ; Separator
20
        MOVEQ   r0, #0                  ; Terminator
        BL      VariformOutputChar
        Pull    "r1, r3, pc", VS

        TEQ     r3, #0
        Pull    "r0, r3, pc", EQ        ; Done
        B       %BT10                   ; More

VariformOutputDotColon ROUT
        Push    "r1, r3-r4"
        ADD     r12, r0, r3             ; Input block
        TEQ     r4, #ConvertToIPv4
        MOVEQ   r4, #ConvertToCardinal
        MOVEQ   r10, #'.'
        MOVNE   r4, #ConvertToHex
        MOVNE   r10, #':'
10
        LDRB    r11, [r12, #-1]!        ; Not actually used

        Push    "r3, r10, r12"
        TEQ     r4, #ConvertToHex
        MOVEQ   r3, #2                  ; Two nybbles please
        MOVNE   r3, #1                  ; One octet please
        MOV     r0, r12
        BL      VariformOutput
        Pull    "r3, r10, r12"
        Pull    "r1, r3-r4, pc", VS

        SUBS    r3, r3, #1
        MOVNE   r0, r10                 ; Separator
        MOVEQ   r0, #0                  ; Terminator
        BL      VariformOutputChar
        Pull    "r1, r3-r4, pc", VS

        TEQ     r3, #0
        Pull    "r0, r3-r4, pc", EQ     ; Done
        B       %BT10                   ; More

VariformOutputBinHex ROUT
        Push    "r1, r5"
        TEQ     r4, #ConvertToBinary
        MOVEQ   r5, #1                  ; Step size in bits
        MOVNE   r5, #4
        ADDEQ   r12, r0, r3             ; Input block
        ADDNE   r12, r3, #1
        ADDNE   r12, r0, r12, LSR #1    ; Input block adjusted for nybbles and bytes
        MOVEQ   r10, r3, LSL #3
        MOVNE   r10, r3, LSL #2         ; Total bit count
10
        TEQ     r10, #0
        BNE     %FT20
        MOV     r0, #0
        BL      VariformOutputChar      ; Terminate even if nothing
        Pull    "r1, r5, pc", VS
        Pull    "r0, r5, pc"
20
        LDRB    r11, [r12, #-1]!        ; Current byte
        TST     r10, #7
        MOVEQ   r11, r11, LSL #24       ; Work at top for LSL and LSR
        MOVNE   r11, r11, LSL #28       ; Partial nybble
30
        RSB     r0, r5, #32             ; Shift of 8 - step + 24
        MOV     r0, r11, LSR r0
        CMP     r0, #10
        ADDCC   r0, r0, #'0'
        ADDCS   r0, r0, #'A' - 10
        TEQ     r4, #ConvertToHexLowercase
        ORREQ   r0, r0, #&20            ; Lowercasify (0-9 unaffected)
        BL      VariformOutputChar
        Pull    "r1, r5, pc", VS

        MOV     r11, r11, LSL r5
        SUB     r10, r10, r5
        TST     r10, #7
        BNE     %BT30
        B       %BT10                   ; Either the end or need a new byte

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_BinaryToDecimal
; ------------------
; Convert int32_t to string SWI (with no terminator)
; prefixed '-' if negative, leading zeros always stripped.
; In  : R0 signed 32-bit integer
;       R1 pointer to buffer
;       R2 max buffer length
; Out : R0, R1 unmodified
;       R2 actual chars given
;       V Set if buffer overflow

BinaryToDecimal_Code ROUT
        Push    "R0, R3-R5"
        MOV     R12, R2                 ; Keep buffer length
        MOV     R2, #0
        CMP     R0, #0
        BPL     %FT01
        SUBS    R12, R12, #1            ; Check enough buffer for '-'
        BMI     %FT10
        MOV     R11, #"-"
        STRB    R11, [R1]               ; Place the '-'
        MOV     R2, #1
        RSB     R0, R0, #0

        ; now do digits.
01      RSB     R0, R0, #0              ; get negative so minint works.
        ADR     R3, TenTimesTable
        MOV     R10, #9                 ; max entry 10^9
d112 7
a118 7
02      LDR     R11, [R3, R10, LSL #2]
        MOV     R5, #-1                 ; digit value
03      ADDS    R0, R0, R11
        ADD     R5, R5, #1
        BLE     %BT03
        SUB     R0, R0, R11
        CMP     R5, #0
d120 3
a122 2
        BNE     %FT05                   ; put digit
04      SUBS    R10, R10, #1
d125 3
a127 3
        BEQ     %FT05                   ; finished, nothing output, must be '0'
        Pull    "R0, R3-R5"
        B       SLVK
d129 3
a131 15
05      SUBS    R12, R12, #1
        BMI     %FT10                   ; naff Exit
        ADD     R5, R5, #"0"
        MOV     R4, #-1                 ; set flag, a non-zero had
        STRB    R5, [R1, R2]
        ADD     R2, R2, #1
        B       %BT04
10
        ADRL    R0, BufferOFloError
    [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
    ]
        ADD     SP, SP, #4              ; discard R0 in
d133 1
a133 14
        B       SLVK_SetV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OS_ConvertFileSize
; OS_ConvertFixedFileSize
; -----------------------
; Do length as xxxx bytes or xxxx kbytes or xxxx Mbytes
; In  : R0 file size in bytes
;       R1 pointer to buffer
;       R2 max buffer length
; Out : R0 pointer to buffer
;       R1 pointer to terminator
;       R2 free bytes in buffer
;       V Set if buffer overflow
d135 1
a135 3
FileSize_Code ROUT
        Push    "r0, r3-r4, lr"
        MOV     r0, sp
d137 46
a182 2
        MOVEQ   r4, #ConvertToFixedFileSize
        MOVNE   r4, #ConvertToFileSize
d184 2
a185 6
        MOV     r3, #4                  ; Always 4 bytes
        
        BL      VariformOutput
        ADD     sp, sp, #4
        Pull    "r3-r4, lr"
        B       SLVK_TestV
a199 2
rStn    RN      10
rNet    RN      12
a200 1
        Push    "r1, r9, lr"
d202 32
a233 53
        ASSERT  rStn < rNet
        LDMIA   r0, { rStn, rNet }
        CMP     rNet, #256
        ADRCS   r0, ErrorBlock_BadNetwork
        BCS     %FT40

        CMP     rStn, #0
        CMPNE   rStn, #256
        ADRCS   r0, ErrorBlock_BadStation
        BCS     %FT40

        TEQ     r11, #OS_ConvertNetStation
        MOVNE   r9, #' '                ; Select padding
        MOVEQ   r9, #0
        BL      NetToDec
        BVS     %FT30

        MOV     r0, #'.'                ; Dot normally
        CMP     rNet, #1                ; Prepare carry
        TEQ     r11, #OS_ConvertNetStation
        BNE     %FT10
        MOVCC   r0, #0                  ; Nothing for net of zero
        MOV     r9, #0                  ; Then no padding regardless
        B       %FT20
10
        MOVCC   r0, #' '                ; Space next if net of zero
        MOVCC   r9, #' '                ; Prepad with space
        MOVCS   r9, #'0'                ; or 0
20
        BL      VariformOutputChar
        MOVVC   rNet, rStn
        BLVC    NetToDec                ; Includes terminator
30
        Pull    "r0, r9, lr", VC
        Pull    "r1, r9, lr", VS
        B       SLVK_TestV
40
      [ International
        BL      TranslateError
        Pull    "r1, r9, lr"
        B       SLVK_SetV
      |
        Pull    "r1, r9, lr"
        B       SLVK_SetV
      ]

NetToDec
        Push    "lr"
        MOV     r0, r9
        CMP     rNet, #100
        BLCC    VariformOutputChar
        CMP     rNet, #10
        BLCC    VariformOutputChar
a234 9
        TEQ     rNet, #0                ; Can't have a station of zero anyway
        BNE     %FT50
        BL      VariformOutputChar      ; Pad instead of "0"
        Pull    "pc"
50
        MOV     r0, rNet
        SWI     XOS_ConvertCardinal1
        Pull    "pc"
        
d237 1
a237 1
        DCB     "BadNet"                ; The token for the Global message
d243 1
a243 1
        DCB     "BadStn"                ; The token for the Global message
d247 40
d302 1
d327 1
d338 205
@


4.3.2.3
log
@Tighten up time conversions.
Convrsions.s:
Don't trash R4 in OS_ConvertDateAndTime
Reject buffer sizes > 2G (seems reasonable for a time string, and allows us to claw back a flag bit).
PMF/osword.s:
Just call Territory_ConvertDateAndTime directly since that's all OS_ConvertDateAndTime does.
Trim some now irrelevant comments and switched out code.

Version 5.35, 4.79.2.144. Tagged as 'Kernel-5_35-4_79_2_144'
@
text
@d740 2
a741 2
; OS_ConvertStandardDateAndTime
; -----------------------------
d746 1
d754 2
a755 3
        Push    "R3, R14"
        MOVS    R3, R2                  ; Territory SWI wants things one register up
        BMI     %FT10                   ; Actively reject unlikely buffer sizes        
d777 2
a778 2
DateTime_Code
        Push    "R3-R4, R14"
d780 1
a780 2
        MOVS    R3, R2
        BMI     %FT10                   ; Actively reject unlikely buffer sizes
d785 1
a785 1
        Pull    "R3-R4, R14"
a786 6
10
        ADRL    R0, ErrorBlock_BuffOverflow
      [ International
        BL      TranslateError
      ]
        B       SLVK_SetV
@


4.3.2.4
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d726 12
a737 4

        MakeInternatErrorBlock BadNetwork,,BadNet        

        MakeInternatErrorBlock BadStation,,BadStn
@


4.3.2.5
log
@Add OS_Memory 24 implementation. Change OS_ValidateAddress to use it. Fix kernel leaving the physical access MB in a messy state. Try and protect against infinite abort loops caused by bad environment handlers.
Detail:
  s/MemInfo - Added an implementation of ROL's OS_Memory 24 call. Unlike the old OS_ValidateAddress call, this call should successfully report the presence of all memory areas known to the kernel. It should also correctly indicate which parts of a sparse DA are mapped in, unlike the old OS_ValidateAddress implementation.
  s/ChangeDyn - Update dynamic area handling to construct a lookup table for mapping logical addresses to dynamic areas; this is used by OS_Memory 24 to quickly locate which DA(s) hit a given region
  s/AMBControl/main - Make sure lazy task swapping is marked as disabled when AMB_LazyMapIn is {FALSE} - required so that OS_Memory 24 will give application space the correct flags
  s/ArthurSWIs - Switch OS_ValidateAddress over to using OS_Memory 24, as per ROL. For compatibility, Service_ValidateAddress is still issued for any areas which the kernel doesn't recognise (currently, OS_Memory 24 doesn't issue any service calls itself)
  s/Convrsions - ADR -> ADRL to keep things happy
  s/HAL - Fix L2PT page allocation and RAM clear to release the physical access region once they're done with it
  s/Kernel - Make the error dispatcher validate the error handler code ptr & error buffer using OS_Memory 24 before attempting to use them. If they look bad, reset to default. Should prevent getting stuck in an infinite abort loop in some situations (e.g. as was the case with ticket 279). The system might not fully recover, but it's better than a hard crash.
  s/Middle - Rework data/prefetch/etc. abort handlers so that DumpyTheRegisters can validate the exception dump area via OS_Memory 24 before anything gets written to it. Should also help to prevent some infinite abort loops. Strip 26bit/pre-HAL code to make things a bit more readable.
  hdr/KernelWS - Update comment
Admin:
  Tested on BB-xM, Raspberry Pi


Version 5.35, 4.79.2.222. Tagged as 'Kernel-5_35-4_79_2_222'
@
text
@d582 1
a582 1
        ADRL    R3, TenTimesTable
@


4.2
log
@Kernel merged
@
text
@a144 1
  [ StrongARM
a176 44
  |
        Push    "R1, R2"
; copy our code into the stack (!!)
        ADR     R1, code_segment
        LDMIA   R1, {R1, R2, R12}
        ADD     R2, R2, R11
        Pull    "R10, R11"
        Push    "R1, R2, R12"

        SUB     sp, sp, #12             ; get 12 byte buffer
        MOV     R1, sp
        MOV     R2, #12
        MOV     lr, pc
        ADD     pc, sp, #12             ; oh for an "execute" instruction!
                                     ; note can't get VSet back from this "SWI"
        RSB     R0, R2, #12            ; bytes got
        MOV     R1, R10
        MOV     R2, R11
        MOV     R12, #0
        MOV     R11, sp
01      LDRB    R10, [R11], #1
        BL      addconvchar
        BVS     space_conv_exit
        SUBS    R0, R0, #1
        BEQ     space_conv_exit
        CMP     R10, #"-"
        BEQ     %BT01
        CMP     R0, #3
        CMPNE   R0, #6
        CMPNE   R0, #9
        BNE     %BT01
        MOV     R10, #" "
        BL      addconvchar
        BVC     %BT01

space_conv_exit
        ADD     sp, sp, #12+12
        B       endconversion

code_segment
        Push    "lr"
        SWI     XOS_ConvertCardinal1 - OS_ConvertSpacedCardinal1
        Pull    "PC"
  ]
d187 1
a187 1
        ORRLES  pc, lr, #V_bit
d191 4
a194 1
        BICS    pc, lr, #V_bit
@


4.2.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d67 1
d69 1
@


4.2.2.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d143 1
d176 44
@


4.2.2.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d143 1
d176 44
@


4.1
log
@Initial revision
@
text
@d145 34
a179 1

d221 2
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d145 1
a145 26
  [ StrongARM
        SUB     sp, sp, #12             ; get 12 byte buffer
        Push    "r1,r2,lr"
        LDR     r10,code_of_swi
        ADD     r10,r10,r11
        ADD     r1, sp, #3*4
        MOV     r2, #12
        SWI     XOS_CallASWI
        RSB     r0, r2, #12            ; bytes got
        Pull    "r1,r2,lr"
        MOV     R12, #0
        MOV     R11, sp
01      LDRB    R10, [R11], #1
        BL      addconvchar
        BVS     space_conv_exit
        SUBS    R0, R0, #1
        BEQ     space_conv_exit
        CMP     R10, #"-"
        BEQ     %BT01
        CMP     R0, #3
        CMPNE   R0, #6
        CMPNE   R0, #9
        BNE     %BT01
        MOV     R10, #" "
        BL      addconvchar
        BVC     %BT01
a146 8
space_conv_exit
        ADD     sp, sp, #12
        B       endconversion

code_of_swi
        DCD     XOS_ConvertCardinal1 - OS_ConvertSpacedCardinal1
  |
        Push    "R1, R2"
a187 2
  ]

@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

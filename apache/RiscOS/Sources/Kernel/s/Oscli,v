head	4.7;
access;
symbols
	Kernel-6_15:4.7
	Kernel-6_14:4.7
	Kernel-6_01-3:4.7
	Kernel-6_13:4.7
	Kernel-6_12:4.7
	Kernel-6_11:4.7
	Kernel-6_10:4.7
	Kernel-6_09:4.7
	Kernel-6_08-4_129_2_10:4.6.2.1
	Kernel-6_08-4_129_2_9:4.6.2.1
	Kernel-6_08:4.7
	Kernel-6_07:4.7
	Kernel-6_06:4.7
	Kernel-6_05-4_129_2_8:4.6.2.1
	Kernel-6_05:4.7
	Kernel-6_04:4.7
	Kernel-6_03:4.7
	Kernel-6_01-2:4.7
	Kernel-6_01-4_146_2_1:4.7
	Kernel-6_02:4.7
	Kernel-6_01-1:4.7
	Kernel-6_01:4.7
	Kernel-6_00:4.7
	Kernel-5_99:4.7
	Kernel-5_98:4.7
	Kernel-5_97-4_129_2_7:4.6.2.1
	Kernel-5_97:4.7
	Kernel-5_96:4.7
	Kernel-5_95:4.7
	Kernel-5_94:4.7
	Kernel-5_93:4.7
	Kernel-5_92:4.7
	Kernel-5_91:4.6
	Kernel-5_90:4.6
	Kernel-5_89-4_129_2_6:4.6
	Kernel-5_89:4.6
	Kernel-5_88-4_129_2_5:4.6
	Kernel-5_88-4_129_2_4:4.6
	Kernel-5_88:4.6
	Kernel-5_87:4.6
	Kernel-5_86-4_129_2_3:4.6
	Kernel-5_86-4_129_2_2:4.6
	Kernel-5_86-4_129_2_1:4.6
	Kernel-5_86:4.6
	SMP:4.6.0.2
	SMP_bp:4.6
	Kernel-5_85:4.6
	Kernel-5_54-1:4.6
	Kernel-5_84:4.6
	Kernel-5_83:4.6
	Kernel-5_82:4.6
	Kernel-5_81:4.6
	Kernel-5_80:4.6
	Kernel-5_79:4.6
	Kernel-5_78:4.6
	Kernel-5_77:4.6
	Kernel-5_76:4.6
	Kernel-5_75:4.6
	Kernel-5_74:4.6
	Kernel-5_73:4.6
	Kernel-5_72:4.6
	Kernel-5_71:4.6
	Kernel-5_70:4.6
	Kernel-5_69:4.6
	Kernel-5_68:4.6
	Kernel-5_67:4.6
	Kernel-5_66:4.6
	Kernel-5_65:4.6
	Kernel-5_64:4.6
	Kernel-5_63:4.6
	Kernel-5_62:4.6
	Kernel-5_61:4.6
	Kernel-5_60:4.6
	Kernel-5_59:4.6
	Kernel-5_58:4.6
	Kernel-5_57:4.6
	Kernel-5_56:4.6
	Kernel-5_55:4.6
	Kernel-5_54:4.6
	Kernel-5_53:4.6
	Kernel-5_52:4.6
	Kernel-5_51:4.6
	Kernel-5_50:4.5
	Kernel-5_49:4.5
	HAL_merge:4.3.2.12
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.3.2.12
	Kernel-5_35-4_79_2_326:4.3.2.12
	Kernel-5_35-4_79_2_325:4.3.2.12
	Kernel-5_35-4_79_2_324:4.3.2.12
	Kernel-5_35-4_79_2_323:4.3.2.12
	Kernel-5_35-4_79_2_322:4.3.2.12
	Kernel-5_35-4_79_2_321:4.3.2.12
	Kernel-5_35-4_79_2_320:4.3.2.12
	Kernel-5_35-4_79_2_319:4.3.2.12
	Kernel-5_35-4_79_2_318:4.3.2.12
	Kernel-5_35-4_79_2_317:4.3.2.12
	Kernel-5_35-4_79_2_316:4.3.2.12
	Kernel-5_35-4_79_2_315:4.3.2.12
	Kernel-5_35-4_79_2_314:4.3.2.12
	Kernel-5_35-4_79_2_313:4.3.2.12
	Kernel-5_35-4_79_2_312:4.3.2.12
	Kernel-5_35-4_79_2_311:4.3.2.12
	Kernel-5_35-4_79_2_310:4.3.2.12
	Kernel-5_35-4_79_2_309:4.3.2.12
	Kernel-5_35-4_79_2_308:4.3.2.12
	Kernel-5_35-4_79_2_307:4.3.2.12
	Kernel-5_35-4_79_2_306:4.3.2.12
	Kernel-5_35-4_79_2_305:4.3.2.12
	Kernel-5_35-4_79_2_304:4.3.2.12
	Kernel-5_35-4_79_2_303:4.3.2.12
	Kernel-5_35-4_79_2_302:4.3.2.12
	Kernel-5_35-4_79_2_301:4.3.2.12
	Kernel-5_35-4_79_2_300:4.3.2.12
	Kernel-5_35-4_79_2_299:4.3.2.12
	Kernel-5_35-4_79_2_298:4.3.2.12
	Kernel-5_35-4_79_2_297:4.3.2.12
	Kernel-5_35-4_79_2_296:4.3.2.12
	Kernel-5_35-4_79_2_295:4.3.2.12
	Kernel-5_35-4_79_2_294:4.3.2.12
	Kernel-5_35-4_79_2_293:4.3.2.12
	Kernel-5_35-4_79_2_292:4.3.2.12
	Kernel-5_35-4_79_2_291:4.3.2.12
	Kernel-5_35-4_79_2_290:4.3.2.12
	Kernel-5_35-4_79_2_289:4.3.2.12
	Kernel-5_35-4_79_2_288:4.3.2.12
	Kernel-5_35-4_79_2_287:4.3.2.12
	Kernel-5_35-4_79_2_286:4.3.2.12
	Kernel-5_35-4_79_2_285:4.3.2.12
	Kernel-5_35-4_79_2_284:4.3.2.12
	Kernel-5_35-4_79_2_283:4.3.2.12
	Kernel-5_35-4_79_2_282:4.3.2.12
	Kernel-5_35-4_79_2_281:4.3.2.12
	Kernel-5_35-4_79_2_280:4.3.2.12
	Kernel-5_35-4_79_2_279:4.3.2.12
	Kernel-5_35-4_79_2_278:4.3.2.12
	Kernel-5_35-4_79_2_277:4.3.2.12
	Kernel-5_35-4_79_2_276:4.3.2.12
	Kernel-5_35-4_79_2_275:4.3.2.12
	Kernel-5_35-4_79_2_274:4.3.2.12
	Kernel-5_35-4_79_2_273:4.3.2.12
	Kernel-5_35-4_79_2_272:4.3.2.12
	Kernel-5_35-4_79_2_271:4.3.2.12
	Kernel-5_35-4_79_2_270:4.3.2.12
	Kernel-5_35-4_79_2_269:4.3.2.12
	Kernel-5_35-4_79_2_268:4.3.2.12
	Kernel-5_35-4_79_2_267:4.3.2.12
	Kernel-5_35-4_79_2_266:4.3.2.12
	Kernel-5_35-4_79_2_265:4.3.2.12
	Kernel-5_35-4_79_2_264:4.3.2.12
	Kernel-5_35-4_79_2_263:4.3.2.12
	Kernel-5_35-4_79_2_262:4.3.2.12
	Kernel-5_35-4_79_2_261:4.3.2.12
	Kernel-5_35-4_79_2_260:4.3.2.12
	Kernel-5_35-4_79_2_259:4.3.2.12
	Kernel-5_35-4_79_2_258:4.3.2.12
	Kernel-5_35-4_79_2_257:4.3.2.12
	Kernel-5_35-4_79_2_256:4.3.2.12
	Kernel-5_35-4_79_2_255:4.3.2.12
	Kernel-5_35-4_79_2_254:4.3.2.12
	Kernel-5_35-4_79_2_253:4.3.2.12
	Kernel-5_35-4_79_2_252:4.3.2.12
	Kernel-5_35-4_79_2_251:4.3.2.12
	Kernel-5_35-4_79_2_250:4.3.2.12
	Kernel-5_35-4_79_2_249:4.3.2.12
	Kernel-5_35-4_79_2_248:4.3.2.12
	Kernel-5_35-4_79_2_247:4.3.2.12
	Kernel-5_35-4_79_2_246:4.3.2.12
	Kernel-5_35-4_79_2_245:4.3.2.12
	Kernel-5_35-4_79_2_244:4.3.2.12
	Kernel-5_35-4_79_2_243:4.3.2.12
	Kernel-5_35-4_79_2_242:4.3.2.12
	Kernel-5_35-4_79_2_241:4.3.2.12
	Kernel-5_35-4_79_2_240:4.3.2.12
	Kernel-5_35-4_79_2_239:4.3.2.12
	Kernel-5_35-4_79_2_238:4.3.2.12
	Kernel-5_35-4_79_2_237:4.3.2.12
	Kernel-5_35-4_79_2_236:4.3.2.12
	Kernel-5_35-4_79_2_235:4.3.2.12
	Kernel-5_35-4_79_2_234:4.3.2.12
	Kernel-5_35-4_79_2_233:4.3.2.12
	Kernel-5_35-4_79_2_232:4.3.2.12
	Kernel-5_35-4_79_2_231:4.3.2.12
	Kernel-5_35-4_79_2_230:4.3.2.12
	Kernel-5_35-4_79_2_229:4.3.2.12
	Kernel-5_35-4_79_2_228:4.3.2.12
	Kernel-5_35-4_79_2_227:4.3.2.12
	Kernel-5_35-4_79_2_226:4.3.2.12
	Kernel-5_35-4_79_2_225:4.3.2.12
	Kernel-5_35-4_79_2_224:4.3.2.12
	Kernel-5_35-4_79_2_223:4.3.2.12
	Kernel-5_35-4_79_2_222:4.3.2.12
	Kernel-5_35-4_79_2_221:4.3.2.12
	Kernel-5_35-4_79_2_220:4.3.2.12
	Kernel-5_35-4_79_2_219:4.3.2.12
	Kernel-5_35-4_79_2_218:4.3.2.12
	Kernel-5_35-4_79_2_217:4.3.2.12
	Kernel-5_35-4_79_2_216:4.3.2.12
	Kernel-5_35-4_79_2_215:4.3.2.12
	Kernel-5_35-4_79_2_214:4.3.2.12
	Kernel-5_35-4_79_2_213:4.3.2.12
	Kernel-5_35-4_79_2_212:4.3.2.12
	Kernel-5_35-4_79_2_211:4.3.2.12
	Kernel-5_35-4_79_2_210:4.3.2.12
	Kernel-5_35-4_79_2_209:4.3.2.12
	Kernel-5_35-4_79_2_208:4.3.2.12
	Kernel-5_35-4_79_2_207:4.3.2.12
	Kernel-5_35-4_79_2_206:4.3.2.12
	Kernel-5_35-4_79_2_205:4.3.2.12
	Kernel-5_35-4_79_2_204:4.3.2.12
	Kernel-5_35-4_79_2_203:4.3.2.12
	Kernel-5_35-4_79_2_202:4.3.2.12
	Kernel-5_35-4_79_2_201:4.3.2.12
	Kernel-5_35-4_79_2_200:4.3.2.12
	Kernel-5_35-4_79_2_199:4.3.2.12
	Kernel-5_35-4_79_2_198:4.3.2.12
	Kernel-5_35-4_79_2_197:4.3.2.12
	Kernel-5_35-4_79_2_196:4.3.2.12
	Kernel-5_35-4_79_2_195:4.3.2.12
	Kernel-5_35-4_79_2_194:4.3.2.12
	Kernel-5_35-4_79_2_193:4.3.2.12
	Kernel-5_35-4_79_2_192:4.3.2.12
	Kernel-5_35-4_79_2_191:4.3.2.12
	Kernel-5_35-4_79_2_190:4.3.2.12
	Kernel-5_35-4_79_2_189:4.3.2.12
	Kernel-5_35-4_79_2_188:4.3.2.12
	Kernel-5_35-4_79_2_187:4.3.2.12
	Kernel-5_35-4_79_2_186:4.3.2.12
	Kernel-5_35-4_79_2_185:4.3.2.12
	Kernel-5_35-4_79_2_184:4.3.2.12
	Kernel-5_35-4_79_2_183:4.3.2.12
	Kernel-5_35-4_79_2_182:4.3.2.12
	Kernel-5_35-4_79_2_181:4.3.2.12
	Kernel-5_35-4_79_2_180:4.3.2.12
	Kernel-5_35-4_79_2_179:4.3.2.12
	Kernel-5_35-4_79_2_178:4.3.2.12
	Kernel-5_35-4_79_2_177:4.3.2.12
	Kernel-5_35-4_79_2_176:4.3.2.12
	Kernel-5_35-4_79_2_175:4.3.2.12
	Kernel-5_35-4_79_2_174:4.3.2.12
	Kernel-5_35-4_79_2_173:4.3.2.11
	Kernel-5_35-4_79_2_172:4.3.2.11
	Kernel-5_35-4_79_2_171:4.3.2.11
	Kernel-5_35-4_79_2_170:4.3.2.11
	Kernel-5_35-4_79_2_169:4.3.2.11
	Kernel-5_35-4_79_2_168:4.3.2.11
	Kernel-5_35-4_79_2_167:4.3.2.11
	Kernel-5_35-4_79_2_166:4.3.2.11
	Kernel-5_35-4_79_2_165:4.3.2.11
	RPi_merge:4.3.2.11
	Kernel-5_35-4_79_2_147_2_23:4.3.2.11
	Kernel-5_35-4_79_2_147_2_22:4.3.2.11
	Kernel-5_35-4_79_2_147_2_21:4.3.2.11
	Kernel-5_35-4_79_2_147_2_20:4.3.2.11
	Kernel-5_35-4_79_2_147_2_19:4.3.2.11
	Kernel-5_35-4_79_2_147_2_18:4.3.2.11
	Kernel-5_35-4_79_2_164:4.3.2.11
	Kernel-5_35-4_79_2_163:4.3.2.11
	Kernel-5_35-4_79_2_147_2_17:4.3.2.11
	Kernel-5_35-4_79_2_147_2_16:4.3.2.11
	Kernel-5_35-4_79_2_147_2_15:4.3.2.11
	Kernel-5_35-4_79_2_162:4.3.2.11
	Kernel-5_35-4_79_2_161:4.3.2.11
	Kernel-5_35-4_79_2_147_2_14:4.3.2.11
	Kernel-5_35-4_79_2_147_2_13:4.3.2.11
	Kernel-5_35-4_79_2_160:4.3.2.11
	Kernel-5_35-4_79_2_159:4.3.2.11
	Kernel-5_35-4_79_2_158:4.3.2.11
	Kernel-5_35-4_79_2_157:4.3.2.11
	Kernel-5_35-4_79_2_156:4.3.2.11
	Kernel-5_35-4_79_2_147_2_12:4.3.2.11
	Kernel-5_35-4_79_2_147_2_11:4.3.2.11
	Kernel-5_35-4_79_2_155:4.3.2.11
	Kernel-5_35-4_79_2_147_2_10:4.3.2.11
	Kernel-5_35-4_79_2_154:4.3.2.11
	Kernel-5_35-4_79_2_153:4.3.2.11
	Kernel-5_35-4_79_2_147_2_9:4.3.2.11
	Kernel-5_35-4_79_2_152:4.3.2.11
	Kernel-5_35-4_79_2_151:4.3.2.11
	Kernel-5_35-4_79_2_147_2_8:4.3.2.11
	Kernel-5_35-4_79_2_147_2_7:4.3.2.11
	Kernel-5_35-4_79_2_150:4.3.2.11
	Kernel-5_35-4_79_2_147_2_6:4.3.2.11
	Kernel-5_35-4_79_2_147_2_5:4.3.2.11
	Kernel-5_35-4_79_2_149:4.3.2.11
	Kernel-5_35-4_79_2_147_2_4:4.3.2.11
	Kernel-5_35-4_79_2_147_2_3:4.3.2.11
	Kernel-5_35-4_79_2_148:4.3.2.11
	Kernel-5_35-4_79_2_147_2_2:4.3.2.11
	Kernel-5_35-4_79_2_147_2_1:4.3.2.11
	RPi:4.3.2.11.0.2
	RPi_bp:4.3.2.11
	Kernel-5_35-4_79_2_98_2_52_2_1:4.3.2.6.2.1
	alees_Kernel_dev:4.3.2.6.2.1.0.2
	alees_Kernel_dev_bp:4.3.2.6.2.1
	Kernel-5_35-4_79_2_147:4.3.2.11
	Kernel-5_35-4_79_2_146:4.3.2.11
	Kernel-5_35-4_79_2_145:4.3.2.11
	Kernel-5_35-4_79_2_144:4.3.2.11
	Kernel-5_35-4_79_2_143:4.3.2.11
	Kernel-5_35-4_79_2_142:4.3.2.11
	Kernel-5_35-4_79_2_141:4.3.2.11
	Kernel-5_35-4_79_2_140:4.3.2.11
	Kernel-5_35-4_79_2_139:4.3.2.11
	Kernel-5_35-4_79_2_138:4.3.2.11
	Kernel-5_35-4_79_2_137:4.3.2.11
	Kernel-5_35-4_79_2_136:4.3.2.10
	Kernel-5_35-4_79_2_135:4.3.2.10
	Kernel-5_35-4_79_2_134:4.3.2.9
	Kernel-5_35-4_79_2_133:4.3.2.9
	Kernel-5_35-4_79_2_132:4.3.2.9
	Kernel-5_35-4_79_2_131:4.3.2.9
	Kernel-5_35-4_79_2_130:4.3.2.9
	Kernel-5_35-4_79_2_129:4.3.2.9
	Kernel-5_35-4_79_2_128:4.3.2.9
	Kernel-5_35-4_79_2_127:4.3.2.8
	Kernel-5_35-4_79_2_126:4.3.2.8
	Kernel-5_35-4_79_2_125:4.3.2.8
	Kernel-5_35-4_79_2_124:4.3.2.8
	Kernel-5_35-4_79_2_123:4.3.2.7
	Cortex_merge:4.3.2.6.2.1
	Kernel-5_35-4_79_2_122:4.3.2.6
	Kernel-5_35-4_79_2_98_2_54:4.3.2.6.2.1
	Kernel-5_35-4_79_2_98_2_53:4.3.2.6.2.1
	Kernel-5_35-4_79_2_98_2_52:4.3.2.6.2.1
	Kernel-5_35-4_79_2_98_2_51:4.3.2.6.2.1
	Kernel-5_35-4_79_2_98_2_50:4.3.2.6.2.1
	Kernel-5_35-4_79_2_98_2_49:4.3.2.6.2.1
	Kernel-5_35-4_79_2_98_2_48:4.3.2.6.2.1
	Kernel-5_35-4_79_2_121:4.3.2.6
	Kernel-5_35-4_79_2_98_2_47:4.3.2.6
	Kernel-5_35-4_79_2_120:4.3.2.6
	Kernel-5_35-4_79_2_98_2_46:4.3.2.6
	Kernel-5_35-4_79_2_119:4.3.2.6
	Kernel-5_35-4_79_2_98_2_45:4.3.2.6
	Kernel-5_35-4_79_2_98_2_44:4.3.2.6
	Kernel-5_35-4_79_2_118:4.3.2.6
	Kernel-5_35-4_79_2_98_2_43:4.3.2.6
	Kernel-5_35-4_79_2_117:4.3.2.6
	Kernel-5_35-4_79_2_116:4.3.2.6
	Kernel-5_35-4_79_2_98_2_42:4.3.2.6
	Kernel-5_35-4_79_2_115:4.3.2.6
	Kernel-5_35-4_79_2_98_2_41:4.3.2.6
	Kernel-5_35-4_79_2_98_2_40:4.3.2.6
	Kernel-5_35-4_79_2_114:4.3.2.6
	Kernel-5_35-4_79_2_98_2_39:4.3.2.6
	Kernel-5_35-4_79_2_98_2_38:4.3.2.6
	Kernel-5_35-4_79_2_113:4.3.2.6
	Kernel-5_35-4_79_2_112:4.3.2.6
	Kernel-5_35-4_79_2_98_2_37:4.3.2.6
	Kernel-5_35-4_79_2_98_2_36:4.3.2.6
	Kernel-5_35-4_79_2_98_2_35:4.3.2.6
	Kernel-5_35-4_79_2_98_2_34:4.3.2.6
	Kernel-5_35-4_79_2_98_2_33:4.3.2.6
	Kernel-5_35-4_79_2_98_2_32:4.3.2.6
	Kernel-5_35-4_79_2_98_2_31:4.3.2.6
	Kernel-5_35-4_79_2_98_2_30:4.3.2.6
	Kernel-5_35-4_79_2_98_2_29:4.3.2.6
	Kernel-5_35-4_79_2_98_2_28:4.3.2.6
	Kernel-5_35-4_79_2_98_2_27:4.3.2.6
	Kernel-5_35-4_79_2_98_2_26:4.3.2.6
	Kernel-5_35-4_79_2_111:4.3.2.6
	Kernel-5_35-4_79_2_98_2_25:4.3.2.6
	Kernel-5_35-4_79_2_98_2_24:4.3.2.6
	Kernel-5_35-4_79_2_98_2_23:4.3.2.6
	Kernel-5_35-4_79_2_110:4.3.2.6
	Kernel-5_35-4_79_2_98_2_22:4.3.2.6
	Kernel-5_35-4_79_2_109:4.3.2.6
	Kernel-5_35-4_79_2_98_2_21:4.3.2.6
	Kernel-5_35-4_79_2_98_2_20:4.3.2.6
	Kernel-5_35-4_79_2_108:4.3.2.6
	Kernel-5_35-4_79_2_107:4.3.2.6
	Kernel-5_35-4_79_2_98_2_19:4.3.2.6
	Kernel-5_35-4_79_2_98_2_18:4.3.2.6
	Kernel-5_35-4_79_2_98_2_17:4.3.2.6
	Kernel-5_35-4_79_2_98_2_16:4.3.2.6
	Kernel-5_35-4_79_2_98_2_15:4.3.2.6
	Kernel-5_35-4_79_2_106:4.3.2.6
	Kernel-5_35-4_79_2_105:4.3.2.6
	Kernel-5_35-4_79_2_104:4.3.2.6
	Kernel-5_35-4_79_2_98_2_14:4.3.2.6
	Kernel-5_35-4_79_2_98_2_13:4.3.2.6
	Kernel-5_35-4_79_2_98_2_12:4.3.2.6
	Kernel-5_35-4_79_2_98_2_11:4.3.2.6
	Kernel-5_35-4_79_2_98_2_10:4.3.2.6
	Kernel-5_35-4_79_2_98_2_9:4.3.2.6
	Kernel-5_35-4_79_2_103:4.3.2.6
	Kernel-5_35-4_79_2_102:4.3.2.6
	Kernel-5_35-4_79_2_98_2_8:4.3.2.6
	Kernel-5_35-4_79_2_98_2_7:4.3.2.6
	Kernel-5_35-4_79_2_98_2_6:4.3.2.6
	Kernel-5_35-4_79_2_98_2_5:4.3.2.6
	Kernel-5_35-4_79_2_98_2_4:4.3.2.6
	Kernel-5_35-4_79_2_101:4.3.2.6
	Kernel-5_35-4_79_2_100:4.3.2.6
	Kernel-5_35-4_79_2_99:4.3.2.6
	Kernel-5_35-4_79_2_98_2_3:4.3.2.6
	Kernel-5_35-4_79_2_98_2_2:4.3.2.6
	Kernel-5_35-4_79_2_98_2_1:4.3.2.6
	Cortex:4.3.2.6.0.2
	Cortex_bp:4.3.2.6
	Kernel-5_35-4_79_2_98:4.3.2.6
	Kernel-5_35-4_79_2_97:4.3.2.6
	Kernel-5_35-4_79_2_96:4.3.2.6
	Kernel-5_35-4_79_2_95:4.3.2.6
	Kernel-5_35-4_79_2_94:4.3.2.6
	Kernel-5_35-4_79_2_93:4.3.2.6
	Kernel-5_35-4_79_2_92:4.3.2.6
	Kernel-5_35-4_79_2_91:4.3.2.6
	Kernel-5_35-4_79_2_90:4.3.2.6
	Kernel-5_35-4_79_2_89:4.3.2.6
	Kernel-5_35-4_79_2_88:4.3.2.6
	Kernel-5_35-4_79_2_87:4.3.2.6
	Kernel-5_35-4_79_2_86:4.3.2.6
	Kernel-5_35-4_79_2_85:4.3.2.6
	Kernel-5_35-4_79_2_84:4.3.2.6
	Kernel-5_35-4_79_2_83:4.3.2.6
	Kernel-5_35-4_79_2_82:4.3.2.6
	Kernel-5_35-4_79_2_81:4.3.2.6
	Kernel-5_35-4_79_2_80:4.3.2.6
	Kernel-5_35-4_79_2_79:4.3.2.6
	Kernel-5_35-4_79_2_78:4.3.2.6
	Kernel-5_35-4_79_2_77:4.3.2.6
	RO_5_07:4.3.2.6
	Kernel-5_35-4_79_2_76:4.3.2.6
	Kernel-5_35-4_79_2_75:4.3.2.6
	Kernel-5_35-4_79_2_74:4.3.2.6
	Kernel-5_35-4_79_2_73:4.3.2.6
	Kernel-5_35-4_79_2_72:4.3.2.6
	Kernel-5_35-4_79_2_71:4.3.2.6
	Kernel-5_35-4_79_2_70:4.3.2.6
	Kernel-5_35-4_79_2_69:4.3.2.6
	Kernel-5_35-4_79_2_68:4.3.2.6
	Kernel-5_35-4_79_2_67:4.3.2.6
	Kernel-5_35-4_79_2_66:4.3.2.6
	Kernel-5_35-4_79_2_65:4.3.2.6
	Kernel-5_35-4_79_2_64:4.3.2.6
	Kernel-5_35-4_79_2_63:4.3.2.6
	Kernel-5_35-4_79_2_62:4.3.2.6
	Kernel-5_35-4_79_2_61:4.3.2.6
	Kernel-5_35-4_79_2_59:4.3.2.6
	Kernel-5_35-4_79_2_58:4.3.2.6
	Kernel-5_35-4_79_2_57:4.3.2.6
	Kernel-5_35-4_79_2_56:4.3.2.6
	Kernel-5_35-4_79_2_55:4.3.2.6
	Kernel-5_35-4_79_2_54:4.3.2.6
	Kernel-5_35-4_79_2_53:4.3.2.6
	Kernel-5_35-4_79_2_52:4.3.2.6
	Kernel-5_35-4_79_2_51:4.3.2.6
	Kernel-5_35-4_79_2_50:4.3.2.6
	Kernel-5_35-4_79_2_49:4.3.2.6
	Kernel-5_35-4_79_2_48:4.3.2.6
	Kernel-5_47:4.3
	Kernel-5_46-4_90_2_1:4.3
	nbingham_Kernel_FastNC_dev_bp:4.3
	nbingham_Kernel_FastNC_dev:4.3.0.4
	Kernel-5_46:4.3
	Kernel-5_45:4.3
	Kernel-5_35-4_79_2_47:4.3.2.5
	Kernel-5_35-4_79_2_46:4.3.2.5
	Kernel-5_35-4_79_2_45:4.3.2.5
	Kernel-5_35-4_79_2_44:4.3.2.5
	Kernel-5_35-4_79_2_25_2_2:4.3.2.1
	Kernel-5_35-4_79_2_43:4.3.2.5
	Kernel-5_35-4_79_2_42:4.3.2.5
	Kernel-5_35-4_79_2_41:4.3.2.5
	Kernel-5_35-4_79_2_40:4.3.2.4
	Kernel-5_35-4_79_2_39:4.3.2.3
	Kernel-5_35-4_79_2_38:4.3.2.3
	Kernel-5_35-4_79_2_37:4.3.2.3
	Kernel-5_35-4_79_2_36:4.3.2.2
	Kernel-5_35-4_79_2_35:4.3.2.2
	Kernel-5_35-4_79_2_34:4.3.2.2
	Kernel-5_35-4_79_2_33:4.3.2.2
	Kernel-5_35-4_79_2_32:4.3.2.2
	Kernel-5_44:4.3
	Kernel-5_35-4_79_2_25_2_1:4.3.2.1
	Kernel-5_43:4.3
	Kernel-5_35-4_79_2_31:4.3.2.2
	Kernel-5_35-4_79_2_30:4.3.2.1
	Kernel-5_35-4_79_2_29:4.3.2.1
	Kernel-5_35-4_79_2_28:4.3.2.1
	Kernel-5_35-4_79_2_27:4.3.2.1
	Kernel-5_35-4_79_2_26:4.3.2.1
	Kernel-5_42:4.3
	Kernel-5_41:4.3
	Kernel-5_40:4.3
	Kernel-5_35-4_79_2_25:4.3.2.1
	Kernel-5_35-4_79_2_24:4.3.2.1
	Kernel-5_35-4_79_2_23:4.3.2.1
	Kernel-5_35-4_79_2_22:4.3.2.1
	Kernel-5_35-4_79_2_21:4.3.2.1
	Kernel-5_35-4_79_2_20:4.3.2.1
	Kernel-5_35-4_79_2_19:4.3.2.1
	Kernel-5_35-4_79_2_18:4.3.2.1
	Kernel-5_35-4_79_2_17:4.3.2.1
	Kernel-5_35-4_79_2_16:4.3.2.1
	Kernel-5_35-4_79_2_15:4.3.2.1
	Kernel-5_35-4_79_2_14:4.3.2.1
	Kernel-5_39:4.3
	Kernel-5_13-4_52_2_1:4.2
	Bethany:4.2.0.2
	Kernel-5_38:4.3
	Kernel-5_35-4_79_2_13:4.3.2.1
	Kernel-5_35-4_79_2_12:4.3.2.1
	Kernel-5_35-4_79_2_11:4.3.2.1
	Kernel-5_37:4.3
	Kernel-5_35-4_79_2_10:4.3.2.1
	Kernel-5_35-4_79_2_9:4.3.2.1
	Kernel-5_36:4.3
	Kernel-5_35-4_79_2_8:4.3.2.1
	Kernel-5_35-4_79_2_7:4.3.2.1
	Kernel-5_35-4_79_2_6:4.3.2.1
	Kernel-5_35-4_79_2_5:4.3.2.1
	Kernel-5_35-4_79_2_4:4.3.2.1
	Kernel-5_35-4_79_2_3:4.3.2.1
	Kernel-5_35-4_79_2_2:4.3.2.1
	dellis_autobuild_BaseSW:4.3
	Kernel-5_35-4_79_2_1:4.3.2.1
	HAL:4.3.0.2
	Kernel-5_35:4.3
	Kernel-5_34:4.3
	Kernel-5_33:4.3
	Kernel-5_32:4.3
	Kernel-5_31:4.3
	Kernel-5_30:4.3
	Kernel-5_29:4.3
	Kernel-5_28:4.3
	Kernel-5_27:4.3
	Kernel-5_26:4.3
	Kernel-5_25:4.3
	Kernel-5_24:4.3
	Kernel-5_23:4.3
	Kernel-5_22:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Kernel-5_21:4.2
	Kernel-5_20:4.2
	Kernel-5_19:4.2
	Kernel-5_18:4.2
	Kernel-5_17:4.2
	Kernel-5_16:4.2
	Kernel-5_15:4.2
	Kernel-5_14:4.2
	Kernel-5_13:4.2
	Kernel-5_12:4.2
	Kernel-5_11:4.2
	Kernel-5_10:4.2
	Kernel-5_09:4.2
	Kernel-5_08:4.2
	Kernel-5_07:4.2
	Kernel-5_06:4.2
	Kernel-5_05:4.2
	Kernel-5_04:4.2
	Kernel-5_03:4.2
	Kernel-5_02:4.2
	Kernel-5_01:4.2
	Kernel-5_00:4.2
	Kernel-4_99:4.2
	Kernel-4_98:4.2
	Kernel-4_97:4.2
	Kernel-4_96:4.2
	Kernel-4_95:4.2
	Kernel-4_94:4.2
	Kernel-4_93:4.2
	Kernel-4_92:4.2
	Kernel-4_91:4.2
	Kernel-4_90:4.2
	dcotton_autobuild_BaseSW:4.3
	Kernel-4_89:4.2
	Kernel-4_88:4.2
	Kernel-4_87:4.2
	Kernel-4_86:4.2
	Kernel-4_85:4.2
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.3
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.3
	Ursula_RiscPC_bp:4.1.4.3
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.3
	Ursula_RiscPC:4.1.4.3.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.3
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.3
	UrsulaBuild_FinalSoftload:4.1.4.3
	rthornb_UrsulaBuild-12Aug1998:4.1.4.3
	aglover_UrsulaBuild-05Aug1998:4.1.4.3
	rthornb_UrsulaBuild-29Jul1998:4.1.4.3
	rthornb_UrsulaBuild-22Jul1998:4.1.4.3
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.3
	rthornb_UrsulaBuild-07Jul1998:4.1.4.3
	rthornb_UrsulaBuild-17Jun1998:4.1.4.3
	rthornb_UrsulaBuild-03Jun1998:4.1.4.3
	rthornb_UrsulaBuild-27May1998:4.1.4.3
	mstphens_Kernel-3_80:4.1.4.3
	rthornb_UrsulaBuild-21May1998:4.1.4.3
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.3
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2017.12.02.14.53.08;	author jlee;	state Exp;
branches;
next	4.6;
commitid	bQl9qnnb10vEmkhA;

4.6
date	2016.06.30.20.59.46;	author jlee;	state Exp;
branches
	4.6.2.1;
next	4.5;
commitid	skOEjp3ipLHx6xcz;

4.5
date	2016.06.30.20.28.56;	author jlee;	state Exp;
branches;
next	4.4;
commitid	lMnWzoE9eJz3Wwcz;

4.4
date	2016.06.30.20.08.09;	author jlee;	state Exp;
branches;
next	4.3;
commitid	IWoXxARWeuLDOwcz;

4.3
date	2000.04.04.14.27.33;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	99.08.19.10.52.34;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.24;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2018.02.16.00.01.41;	author jlee;	state Exp;
branches;
next	;
commitid	L7HYXYTsWSFlZ0rA;

4.3.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2001.05.22.15.27.54;	author mstephen;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	2001.06.15.09.39.57;	author mstephen;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	2001.06.22.14.17.37;	author mstephen;	state Exp;
branches;
next	4.3.2.5;

4.3.2.5
date	2001.06.26.09.37.11;	author mstephen;	state Exp;
branches;
next	4.3.2.6;

4.3.2.6
date	2002.10.07.17.29.43;	author kbracey;	state Exp;
branches
	4.3.2.6.2.1;
next	4.3.2.7;

4.3.2.7
date	2011.11.26.21.11.16;	author jlee;	state Exp;
branches;
next	4.3.2.8;
commitid	cI3W0zbtALQG6TIv;

4.3.2.8
date	2011.11.27.11.48.10;	author rsprowson;	state Exp;
branches;
next	4.3.2.9;
commitid	OFgqaKhOb6swXXIv;

4.3.2.9
date	2011.12.10.19.03.47;	author jlee;	state Exp;
branches;
next	4.3.2.10;
commitid	tEbdTPC2UwO3XFKv;

4.3.2.10
date	2012.02.01.00.03.16;	author jlee;	state Exp;
branches;
next	4.3.2.11;
commitid	0EPfwxsrfyueWnRv;

4.3.2.11
date	2012.02.25.08.37.24;	author rsprowson;	state Exp;
branches;
next	4.3.2.12;
commitid	avzc6Nf2mNAL0wUv;

4.3.2.12
date	2012.10.28.16.51.46;	author rsprowson;	state Exp;
branches;
next	;
commitid	ruXZqdTJKJ85Qaqw;

4.3.2.6.2.1
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

4.1.1.1
date	96.11.05.09.41.24;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.58;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.33.32;	author mstphens;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.12.08.14.34.40;	author mstphens;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.03.26.11.26.02;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.41;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.54;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Fix 2x output stream redirection bugs
Detail:
  s/Oscli:
  - Reorder RemoveOscliCharJobs to avoid WrchV being left claimed while the output stream is being closed, to resolve ticket #420.
  - Register usage also tweaked a bit to make the code a bit shorter & easier to read
  - Fix RedirectWrch to deal with errors correctly. PSR save/restore macros were added to the routine during the 32bit conversion process, but (a) they were inadvertantly causing all errors to be ignored, and (b) they were redundant since WrchV has no special in/out requirements for the PSR flags
Admin:
  Tested on Pandaboard
  Ticket #420 fix based around Colin's fix from https://www.riscosopen.org/forum/forums/4/topics/5269


Version 5.92. Tagged as 'Kernel-5_92'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => Oscli - main Oscli code and system commands.

;
;mjs performance enhancements for Ursula (ChocolateOscli)
;
Oscli_CHashValMask        *       &1f                  ;32-wide Command hashing, for commands within kernel
Oscli_MHashValMask        *       &ff                  ;256-wide Module hashing, for command groups in other modules
                                                       ; - kernel cmd hashed tables must be reorganised if Oscli_CHashValMask is changed
                                                       ; - UtilityModule MUST be first in module chain, if hashing in use


        MACRO
$l      CheckUID $reg, $tmp
$l      LDR      $tmp, =ZeroPage
        LDR      $tmp, [$tmp, #OscliCBbotUID]
        CMP      $reg, $tmp
        MEND
; exits with HI if buffer OK.

;******************************************************************************
; redirection utility routines

; In:   R10 points at filename, V clear
;       R1 is type

; Out:  R0, R1, R12 corrupted, redirection done, flags preserved (or V set)

doredirect ROUT
           EntryS "R1, R2"
60         LDRB    R0, [R10], #1
           CMP     R0, #" "
           BEQ     %BT60
           MOV     R2, R1
           LDR     R1, =RedirectBuff
61         CMP     R0, #" "             ; we know it's terminated by space
           STRNEB  R0, [R1], #1
           LDRNEB  R0, [R10], #1
           BNE     %BT61
           SUB     R10, R10, #1
           MOV     R0, #13
           STRB    R0, [R1]
           LDR     R1, =RedirectBuff
           LDR     R0, =ZeroPage
           ASSERT  (ZeroPage :AND: 255) = 0
           CMP     R2, #&40
           LDREQB  R1, [R0, #RedirectInHandle]
           LDRNEB  R1, [R0, #RedirectOutHandle]
           STREQB  R0, [R0, #RedirectInHandle]
           STRNEB  R0, [R0, #RedirectOutHandle]
         [ ZeroPage <> 0
           MOV     R0, #0
         ]
           CMP     R1, #0
           SWINE   XOS_Find             ; close any previous File
           MOV     R12, R1              ; don't really care if handle was invalid
           LDR     R1, =RedirectBuff
           ORR     R0, R2, #open_mustopen + open_nodir
           SWI     XOS_Find             ; Open the File
           BVS     abort_redirect       ; bad name etc
           CMP     R0, #0               ; worked?
           BEQ     %FT63
           CMP     R2, #&40
           LDR     R1, =ZeroPage
           STREQB  R0, [R1, #RedirectInHandle]
           BEQ     %FT00
           STRNEB  R0, [R1, #RedirectOutHandle]
           MOVNE   R0, #WrchV
           ADRNEL  R1, RedirectWrch
           CMP     R12, #0              ; Ensure only vectored the once
           MOVEQ   R2, #0
           SWIEQ   XOS_Claim
           BVS     abort_redirect       ; Claim will leave "Sysheap full" msg.
00
           LDR     R2, [stack, #Proc_RegOffset]
           CMP     R2, #&C0
           EXITS   NE

; >> file, so move to EOF

           LDR     R1, =ZeroPage
           LDRB    R1, [R1, #RedirectOutHandle]
           MOV     R0, #2               ; read extent
           SWI     XOS_Args
           MOVVC   R0, #1               ; write ptr
           SWIVC   XOS_Args
           EXITS   VC

           B       abort_redirect

           MakeErrorBlock   RedirectFail

63         ADR     R0, ErrorBlock_RedirectFail
         [ International
           BL      TranslateError
         ]
abort_redirect                          ; current error set
           EXITVS


ParseRDNSpec        ROUT
; In : R11 points at string to test.
; Out : EQ/NE for "is it a rdnspec?". V always clear.
; If EQ : R11 points after filename
;         R10 points at start of filename
;         R1=&40 => redirect input,
;           =&80 => redirect output,
;           =&C0 => redirect & append output
         MOV        R1, #&40
01       LDRB       R10, [R11], #1
         CMP        R10, #" "
         BEQ        %BT01               ; skip leading spaces
         CMP        R10, #"<"
         BEQ        %FT04
         CMP        R10, #">"
         MOVNE      PC, lr
         MOV        R1, #&80
         LDRB       R10, [R11], #1
         CMP        R10, #">"
         MOVEQ      R1, #&C0
04       LDREQB     R10, [R11], #1
         CMP        R10, #" "
         MOVNE      PC, lr
         SUB        R10, R11, #1        ; filename start ptr
         Push      "R0"
02       LDRB       R0, [R11], #1
         CMP        R0, #" "
         BGT        %BT02
         Pull      "R0"
         MOV        PC, lr              ; it's EQ if had space at end.

         MakeErrorBlock StackFull

OscliStackFull
         ADR        R0, ErrorBlock_StackFull
       [ International
         BL         TranslateError
       |
         SETV                           ; In place of TranslateError
       ]
         Pull      "pc"

;******************************************************************************
; Main OSCLI code

VecOsCli ROUT

; first check for rheum on the stack.
; Oscli will have pushed 5 registers when it calls module code : let's
; guarantee 256 bytes (=64 registers) for the module code
; so check half a K left, leaving 236 bytes for any interrupt processing.

         CheckSpaceOnStack  512, OscliStackFull, R10

         Push      "R0-R2"      ; lr on stack from caller

; first skip * and space

01       LDRB       R10, [R0], #1
         CMP        R10, #" "
         CMPNE      R10, #"*"
         BEQ        %BT01
         CMP        R10, #"%"
         LDREQB     R10, [R0]           ; fixed 29-Mar-89; was LDREQ
         CMP        R10, #13
         CMPNE      R10, #10
         CMPNE      R10, #0
         CMPNE      R10, #"|"
         Pull      "R0-R2, PC", EQ   ; V clear return

; now check for redirection.
; Redirection setter ::= "{ " [ >= 1 Redirection spec] "}"
; where
; Redirection spec ::=  "> "filename" " | "< "filename" " | ">> "filename" "
; Also check terminator in first LongCLISize chars.
         SUB        R11, R0, #1
         MOV        R1, #0
         ADD        R2, R0, #LongCLISize
02       LDRB       R10, [R11], #1
         CMP        R11, R2
         BEQ        OscliLineTooLong
         CMP        R10, #13
         CMPNE      R10, #10
         CMPNE      R10, #0
         BEQ        %FT58
         CMP        R10, #""""
         EOREQ      R1, R1, R10
         CMP        R10, #"{"
         CMPEQ      R1, #0
         BNE        %BT02
         Push      "R11"
         LDRB       R10, [R11], #1
         CMP        R10, #" "
         BLEQ       ParseRDNSpec
         Pull      "R11", NE
         BNE        %BT02
60       BL         ParseRDNSpec
         BEQ        %BT60
         CMP        R10, #"}"
         Pull      "R11"
         BNE        %BT02
; R11 points 1 char after {
         Push      "R5, R6"
         BL         GetOscliBuffer    ; get a buffer
         SUB        R0, R0, #1
         MOV        R2, #0
50       LDRB       R10, [R0], #1
         CMP        R0, R11
         STRNEB     R10, [R5, R2]
         ADDNE      R2, R2, #1
         BNE        %BT50

61       BL         ParseRDNSpec
         BLEQ       doredirect
         BVS        RedirectionError  ; close any redirection set up
         BEQ        %BT61

53       LDRB       R10, [R11], #1
         CMP        R10, #" "
         BEQ        %BT53
         SUB        R11, R11, #1

52       LDRB       R10, [R11], #1
         STRB       R10, [R5, R2]
         ADD        R2, R2, #1
         CMP        R2, #OscliBuffSize
         BEQ        %FT51
         CMP        R10, #13
         CMPNE      R10, #10
         CMPNE      R10, #0
         BNE        %BT52
         MOV        R2, R6           ; buffer UID
         ADD        R0, R5, #1        ; point after 1st char.
         Pull      "R5, R6"
         B          %FT03

51       MOV       R2, R6            ; longer than 256
         ADR       R0, ErrorBlock_OscliLongLine
       [ International
         BL        TranslateError
       |
         SETV
       ]
RedirectionError
         BL        ReleaseBuff
         BL        OscliTidy        ; shut down the redirection just done.
         Pull     "R5, R6"
OscliFailure
         STR       R0, [stack]
         SETV
         Pull     "R0-R2, PC"

OscliLineTooLong
         ADR       R0, ErrorBlock_OscliLongLine
       [ International
         BL        TranslateError
       ]
         B         OscliFailure
         MakeErrorBlock  OscliLongLine

58       MOV       R2, #-1     ; naff buffer UID.
; Redirection dealt with. R0 points after 1st ch command
03
         Push     "R2"        ; save buffer UID

; now check for filing system name as prefix
         Push     "R3"
         MOV       R3, #0     ; j.i.c. fileswitch is dead!!
         SUB       R1, R0, #1
         MOV       R0, #FSControl_StarMinus
         SWI       XOS_FSControl

; here we have:
; V set if -nafffsname encountered
; VC: R2 = -1 if no fs name found
;     R3 = 0 if no specials encountered

         BVS       letmodprefatit
         CMP       R3, #0
         BEQ       letmodprefatit
         Pull     "R3"
         Push     "R2"        ; save "temp FS set" indicator
         ADR       R0, ErrorBlock_NoOscliSpecials
       [ International
         BL        TranslateError
       |
         SETV
       ]
         B         OscliExit
         MakeErrorBlock NoOscliSpecials

letmodprefatit
         Pull     "R3"
         Push     "R2"        ; save "temp FS set" indicator
         BL        CheckForModuleAsPrefix
         BVS       OscliExit

; special char checks
pfssss   LDRB      R10, [R1], #1
         CMP       R10, #" "
         BEQ       pfssss
         SUB       R0, R1, #1
         CMP       R2, #-1
         RSBLT     R11, R2, #0
         Push     "R2",LT
         BLT       OnlyOneModuleWanted

         CMP       R10, #"/"
         BEQ       %FT06

; see if skip macro expansion
         CMP       R10, #"%"
         LDREQB    R10, [R0], #1
         BEQ       %FT05

         CMP       R10, #"."    ; fudge .
         BEQ       %FT07

; try macro expansion : if find it, expand into a buffer.
; Also scan for parameters while expanding.
; R0 ptr to command, R10 first char.
; If success : Recursively call OSCLI for each line in expansion.

      Push  "R0, R3-R6"

  [ Oscli_QuickAliases
    ;
    ;at least make a vague attempt not to run like a drain - since we can do a binary
    ;chop search for an exactly known var name, do this unless command is abbreviated
    ;
      ADR    R6,AliasStr_QA
      LDR    R3,=AliasExpansionBuffer      ; construct the alias name here
      MOV    R5,#6
oqa_loop1                                  ; bung in "ALIAS$"
      LDRB   R4,[R6],#1
      STRB   R4,[R3],#1
      SUBS   R5,R5,#1
      BNE    oqa_loop1
      MOV    R6,R0
      ADRL   R2, Up_ItAndTerm_Check_Table
oqa_loop2                                  ; bung in command, upper cased
      LDRB   R4,[R6],#1
      CMP    R4,#&80                       ; char in table ?
      LDRCCB R4,[R2,R4]
      STRB   R4,[R3],#1
      CMP    R4,#0
      BNE    oqa_loop2
      LDRB   R4,[R3,#-2]                   ; pick up last char of command
      CMP    R4,#"."
      BEQ    oqa_treacletime               ; it's abbreviated, go to slow code
      LDR    R3,=AliasExpansionBuffer
      Push   "r6,r7"
      BL     VarFindIt_QA                  ; quick binary chop type stuff
      Pull   "r6,r7",EQ
      BEQ    oqa_quicksilvertime_noalias   ; no alias - carry on
;found alias
      MOV    R0,#-1                        ; special, VarFindIt skipping call (r5,r6,r7 from VarFindIt_QA)
      MOV    R1,R3                         ; output buffer
      MOV    R2,#LongCLISize
      MOV    R3,#0
      MOV    R4,#VarType_Expanded
      SWI    XOS_ReadVarVal                ; expand it
      Pull   "r6,r7"
      SUB    R6,R6,#1                      ; arg ptr
      B      oqa_quicksilvertime_alias
oqa_treacletime
;
  ] ;Oscli_Quickaliases

    [ International
      LDR    R3,=ZeroPage
      LDRB   R6,[R3,#ErrorSemaphore]            ; We are about to get lots of buffer overflow errors,
      SUB    R6,R6,#1
      STRB   R6,[R3,#ErrorSemaphore]
    ]
      MOV    R6, R0
      MOV    R3, #:LEN: "Alias$"
31    SUB    R3, R3, #:LEN: "Alias$"
      MOV    R2, #-1        ; negative length means just look for it.
      ADRL   R0, AliasStr
      SWI    XOS_ReadVarVal
      CMP    R2, #0         ; V always set anyway
   [ International
    [ ZeroPage = 0
      LDREQB R0,[R2,#ErrorSemaphore]
      ADDEQ  R0,R0,#1
      STREQB R0,[R2,#ErrorSemaphore]
    |
      LDREQ  R3,=ZeroPage
      LDREQB R0,[R3,#ErrorSemaphore]
      ADDEQ  R0,R0,#1
      STREQB R0,[R3,#ErrorSemaphore]
    ]
   ]
      BEQ    %FT10

      ADD   R3, R3, #:LEN: "Alias$"

; match $R6 with $R3

      MOV   R1, #0                         ; offset
32    LDRB  R4, [R6, R1]
      LDRB  R5, [R3, R1]
      CMP   R4, #&80                       ; in table ?
      ADRCCL R2, Up_ItAndTerm_Check_Table
      LDRCCB R4, [R2, R4]
      CMP   R4, #" "
      CMPLE R5, #" "
      BLE   %FT33
      UpperCase R5, R2
      CMP   R4, R5
      ADDEQ R1, R1, #1
      BEQ   %BT32
      CMP   R1, #0
      BEQ   %BT31                        ; failed
      CMP   R5, #" "
      BLE   %BT31
      CMP   R4, #"."
      BNE   %BT31
      ADD   R1, R1, #1
33
; success : copy name, read value

    [ International
      LDR   R4,=ZeroPage
      LDRB  R0,[R4,#ErrorSemaphore]
      ADD   R0,R0,#1
      STRB  R0,[R4,#ErrorSemaphore]     ; We can go back to translating errors.
    ]

      SUB   R3, R3, #:LEN: "Alias$"
99    LDR   R0, =AliasExpansionBuffer
      ADD   R6, R6, R1                       ; save arglist ptr
      MOV   R4, #0
34    LDRB  R5, [R3], #1
      STRB  R5, [R0, R4]
      ADD   R4, R4, #1
      CMP   R5, #0
      BNE   %BT34
      MOV   R1, R0               ; output buffer same as input!
      MOV   R2, #LongCLISize
      MOV   R3, #0
      MOV   R4, #VarType_Expanded
      SWI   XOS_ReadVarVal
  [ Oscli_QuickAliases
oqa_quicksilvertime_alias
  ]
      BVS   AliasOscliTooLong
      MOV   R3, #13
      STRB  R3, [R1, R2]

      MOV    R3, R1
      MOV    R0, R6              ; arglist
      MOV    R4, R2              ; no of chars got.
      BL     GetOscliBuffer      ; gives buffer ptr in R5, ID in R6
      MOV    R1, R5
      MOV    R2, #OscliBuffSize
      MOV    R5, #0
      SWI    XOS_SubstituteArgs32
      BVS    AliasOscliTooLong

; Whew! Now ready to recursively call OSCLI with all lines in the buffer.
      MOV    R0, R1
      ADD    R2, R1, R2
43    SWI    XOS_CLI
      BVS    %FT46
      CheckUID R6, R1    ; check buffer still valid.
      BLS    FailInAlias
44    LDRB   R1, [R0], #1
      CMP    R1, #13
      CMPNE  R1, #10
      CMPNE  R1, #0
      BNE    %BT44
      CMP    R0, R2
      BLO    %BT43
      MOV    R2, R6
      BL     ReleaseBuff ; release buffer, UID in R2
      Pull  "R0, R3-R6"
      CLRV
      B      OscliExit

      MakeErrorBlock  OscliTooHard

FailInAlias
      CheckUID R2, R1
      BLGT   ReleaseBuff
      ADR    R0, ErrorBlock_OscliTooHard
    [ International
      BL     TranslateError
    ]
46    STR    R0, [stack]
      Pull  "R0, R3-R6"
      SETV
      B      OscliExit

AliasOscliTooLong
      MOV    R2, R6            ; buffer UID
      BL     ReleaseBuff
      Pull  "R0, R3-R6"
      ADRL   R0, ErrorBlock_OscliLongLine
    [ International
      BL     TranslateError
    |
      SETV
    ]
      B      OscliExit

      LTORG

  [ Oscli_QuickAliases
AliasStr_QA = "ALIAS$", 0
  ]
AliasStr = "Alias$*", 0
AliasDot = "Alias$.", 0
      ALIGN

  [ Oscli_QuickAliases
oqa_quicksilvertime_noalias
  ]
10  ; Failed macro expansion.
         Pull   "R0, R3-R6"

; try for system command first.
05       LDRB      R1, [R0]                     ; quick check for . tho
         CMP       R1, #"."
         BEQ       PercentDot

  [ Oscli_HashedCommands
         BL        Oscli_cmd_hashsum            ; => hash value in r1
         LDR       r2,=ZeroPage
         STR       r1,[r2,#Oscli_CmdHashSum]
       [ ZeroPage <> 0
         MOV       r2,#0                        ; Must be zero for oscli_hlist_loop. Not entirely sure why!
       ]
         CMP       r1,#0
         BEQ       oscli_sysabbrevation
         BL        SysCommsHashedLookup
         B         oscli_syslook_done
oscli_sysabbrevation
  ]
         ADRL      R1, SysCommsModule
         MOV       R2, #SCHCTab-SysCommsModule
         SEC                                    ; carry set means sys module
         BL        ModCommsLookUp
oscli_syslook_done
         BCS       OscliExit

  [ Oscli_HashedCommands
         ;now try UtilityModule, if non-abbreviated command
         Push      "R2"
         LDR       r2,=ZeroPage
         LDR       r1,[r2,#Oscli_CmdHashSum]
         CMP       r1,#0
         Pull      "R2",EQ
         BEQ       oscli_modabbreviation
         BL        UtilCommsHashedLookup
         ADDCS     stack, stack, #4                  ;discard R2
         BCS       OscliExit
         ;now try list of modules on hash value
         LDR       r2,=ZeroPage
         LDR       r1,[r2,#Oscli_CmdHashSum]
         AND       r1,r1,#Oscli_MHashValMask
         LDR       r11,[r2,#Oscli_CmdHashLists]
         CMP       r11,#0
         LDRNE     r11,[r11,r1,LSL #2]
         CMPNE     r11,#0
         BEQ       %FT75
         Push      "r3,r4"
         ADD       r3,r11,#8
         LDR       r4,[r11,#4]
         ADD       r4,r4,#1
oscli_hlist_loop
         SUBS      r4,r4,#1
         Pull      "r3,r4",EQ
         BEQ       %FT75
         LDR       R2,[stack,#2*4]
         CMP       R2, #0
         Pull      "r3,r4",MI
         BMI       OneModule_Failed
         LDR       R11,[R3],#4
         LDR       R1, [R11, #Module_code_pointer]
         LDR       R2, [R1, #Module_HC_Table]
         CMP       R2, #0
         BEQ       oscli_hlist_loop
         LDR       R12, [R11, #Module_incarnation_list] ; preferred life
         ADD       R12, R12, #Incarnation_Workspace
         CLC
         BL        ModCommsLookUp
         BCC       oscli_hlist_loop
         Pull      "r3,r4"
         ADD       stack,stack,#4
         B         OscliExit
oscli_modabbreviation
  ] ;Oscli_HashedCommands

; now try looking round the modules.
         LDR       R11, =ZeroPage+Module_List
         Push     "R2"
74       LDR       R2, [stack]
         CMP       R2, #0
         BMI       OneModule_Failed
         LDR       R11, [R11, #Module_chain_Link]
         CMP       R11, #0
         BEQ       %FT75
OnlyOneModuleWanted
         LDR       R1, [R11, #Module_code_pointer]
         LDR       R2, [R1, #Module_HC_Table]
         CMP       R2, #0
         BEQ       %BT74
         LDR       R12, [R11, #Module_incarnation_list] ; preferred life
         ADD       R12, R12, #Incarnation_Workspace
         CLC
         BL        ModCommsLookUp
         BCC       %BT74
         ADD       stack, stack, #4           ; discard R2
         B         OscliExit

75
  ; not in a module : try for current filing system command
         STR       R0, [stack]                 ; pull R2, push R0
         MOV       R0, #FSControl_ReadModuleBase
         SWI       XOS_FSControl
         Pull     "R0"
         CMP       R1, #0
         BEQ       NoFSCommands                  ; no selected FS!
         MOV       R12, R2                       ; module's workspace ptr
         LDR       R2, [R1, #Module_HC_Table]
         CMP       R2, #0
         BEQ       SecondaryFSCTab
         ORR       R2, R2, #&80000000            ; FS command needed flag
         CLC
         BL        ModCommsLookUp
         BCC       SecondaryFSCTab
         B         OscliExit

SecondaryFSCTab
         Push     "R0"
         MOV       R0, #FSControl_ReadSecondaryModuleBase
         SWI       XOS_FSControl
         Pull     "R0"
         MOVVS     R1, #0
         CMP       R1, #0
         BEQ       NoFSCommands
         MOV       R12, R2                       ; module's workspace ptr
         LDR       R2, [R1, #Module_HC_Table]
         CMP       R2, #0
         BEQ       NoFSCommands
         ORR       R2, R2, #&80000000            ; FS command needed flag
         CLC
         BL        ModCommsLookUp
         BCC       NoFSCommands
         B         OscliExit

NoFSCommands
         MOV       R1, #Service_UKCommand
         BL        Issue_Service
         CMP       R1, #0
         BNE       UKCNotClaimed
         CMP       R0, #0                        ; any error?
         SETV      NE                            ; V clear if EQ
         B         OscliExit

OneModule_Failed
         ADD       stack, stack, #4
         ADRL      R0, ErrorBlock_BadCommand
      [  International
         BL        TranslateError
      |
         SETV
      ]
         B         OscliExit

UKCNotClaimed
         MOV       R1, R0
DoFSCV_Run
         MOV       R0, #FSControl_Run
71       SWI       XOS_FSControl
OscliExit
         Pull     "R2"
         SavePSR   R1
         Push     "R0"
         CMP       R2, #0                        ; -ve means no FS selected.
         MOVGE     R0, #FSControl_RestoreCurrent
         SWIGE     XOS_FSControl
         Pull     "R0"

         Pull     "R2"
         CMP       R2, #-1
         BEQ       %FT80
         BL        ReleaseBuff
         BL        RemoveOscliCharJobs  ; shut down redirection
80       TST       R1, #V_bit
         BNE       %FT81
         CLRV
         Pull     "R0-R2, pc"
81
         SETV
         ADD       sp, sp, #4
         Pull     "R1-R2, pc"

06       ADD       R1, R0, #1       ; */ so skip the /, do RUN reason code
         B         DoFSCV_Run

07
         Push     "R0, R3-R6"
         MOV       R6, R0
         ADRL      R0, AliasDot
         MOV       R3, #0
         MOV       R2, #-1         ; negative length means just look for it.
         SWI       XOS_ReadVarVal
         CMP       R2, #0          ; V always set anyway
         MOVNE     R1, #1          ; index to step past .
         BNE       %BT99
         Pull     "R0, R3-R6"
PercentDot                        ; entry for *%.
         ADD       R1, R0, #1
         MOV       R0, #FSControl_Cat   ; *., skip .
         B         %BT71

;***************************************************************************

  [ Oscli_HashedCommands
;
; - routine to compute hash value for unabbreviated commands
; - does not apply mask to hash value (since different hash widths are
;   required in different cases)
;
; hash value = sum of all chars of command, excluding terminator, all
;              chars being processed through Up_ItAndTerm_Check_Table
;
; entry:
; R0 -> command
; exit:
; R1 =  hash value, or 0 if invalid (abbreviation encountered)
;
Oscli_cmd_hashsum ROUT
         Push   "r0,r2-r3,lr"
         MOV    r1,#0
         ADRL   r2, Up_ItAndTerm_Check_Table
         B      %FT15
10
         ADD    r1,r1,r3
15
         LDRB   r3,[r0],#1
         CMP    r3,#&80
         LDRCCB r3,[r2,r3]
         CMP    r3,#"."
         BEQ    %FT30
         CMP    r3,#0
         BNE    %BT10
20
         Pull   "r0,r2-r3,PC"
30
         MOV    r1,#0
         Pull   "r0,r2-r3,PC"
;
;special entry of ModCommsLookUp, for hashed lookup of commands in SysCommsModule
;entry: R0 -> command, r1 = hash value of command
;
SysCommsHashedLookup ROUT
         Push   "R0, R2-R10, lr"
;
;first a fudge, to allow old syntax (no space before first, numeric, parameter)
;for *fx, *key, *opt and *tv - look for '&' or a numeric char at R0 + 2, 3 or 4
;
         MOV    R4, #2
schl_fudgeloop
         LDRB   R2, [R0,R4]
         CMP    R2, #' '
         BLS    schl_nofudge
         CMP    R2, #'&'
         BEQ    schl_fudge
         CMP    R2, #'0'
         BLO    schl_nofudgesofar
         CMP    R2, #'9'
         BLS    schl_fudge
schl_nofudgesofar
         ADD    R4, R4, #1
         CMP    R4, #4
         BLS    schl_fudgeloop
schl_nofudge
         ADRL   R2, SysCoHashedCmdTab
         AND    R4, R1,#Oscli_CHashValMask  ;hash value, masked for command hashing
         LDR    R2, [R2, R4, LSL #2]        ;command list for this hash value
         ADRL   R1, SysCommsModule
         CMP    R2, #1                      ;set carry if valid table entry
         BCS    ModCommsLookUp_AltEntry     ;note: carry set to indicate sys module
         Pull   "R0, R2-R10, pc"            ;bail if null hash table entry (with carry clear to indicate failure)         
schl_fudge
         ADRL   R1, SysCommsModule
         ADRL   R2, SHC_fudgeulike
         SUB    R2, R2, R1                          ;fudge command list (offset)
         SEC                                        ;carry set means sys module
         B      ModCommsLookUp_AltEntry

;
;special entry of ModCommsLookUp, for hashed lookup of commands in UtilityMod
;entry: R0 -> command, r1 = hash value of command
;

UtilCommsHashedLookup ROUT
         Push   "R0, R2-R10, lr"
         ADRL   R2, UtilHashedCmdTab
         AND    R4, R1,#Oscli_CHashValMask  ;hash value, masked for command hashing
         LDR    R2, [R2, R4, LSL #2]        ;command list for this hash value
         ADRL   R1, UtilityMod
         TEQ    R2, #0,2                    ;check R2 and clear carry
         BNE    ModCommsLookUp_AltEntry
         Pull   "R0, R2-R10, pc"            ;bail if null hash table entry
;
  ] ;Oscli_HashedCommands

;***************************************************************************

; Routine to look through a module table for a command, and call it.
; Set up R12 yourself if needed.
; R0 points at command to find
; R1 points at module
; R2 offset of command table : top bit set for "want FS command"
; C set means allow messy matching, i.e. it's the system command table

; Return C set if found and called, V flag from code called
; Might not return if module starts up as current object.

ModCommsLookUp ROUT
         Push   "R0, R2-R10, lr"
  [ Oscli_HashedCommands
ModCommsLookUp_AltEntry
  ]
         MOV     R4, #0   ; want all flags clear
         TEQ     R2, #0   ; don't corrupt C!
         MOVMI   R4, #FS_Command_Flag
         BICMI   R2, R2, #&80000000
         BL      FindItem
         BLCS    %FT05
         CLC                      ; clears C and V
         Pull   "R0, R2-R10, PC"
05
         Push    r4               ; save pointer in case needed for syntax mess

; check number of arguments, error with syntaxmessage if naff.

         ADD     R2, R2, R1       ; get R2 back to pointer.
         ADD     R0, R0, R3       ; point at terminator.
09       LDRB    R4, [R0], #1
         CMP     R4, #" "        ; skip spaces.
         BEQ     %BT09
         MOV     R3, R1          ; hang on to module ptr.
         MOV     R1, #0          ; no of parms.
         MOV     R7, #-1         ; flag for buffer got for GSTRANSing

         MOV     R6, R0
         SUB     R0, R0, #1

; Now we have :
; R0 -> commtail, ready for module
; R1 number of parameters
; R2 -> info block for command
; R3 -> module
; R4 current char
; R5 execute offset
; R6 working commtail ptr
; R7 -1 or buffer UID
; R8 becomes gstrans map
; R9 may be a workin gstrans map copy
; R10 may be a working buffer ptr for copying

         LDRB    R8, [R2, #5]    ; get gstrans_map
         MOVS    R9, R8
         BEQ     nogstransingta

         Push   "R2, R5, R6"
         BL      GetOscliBuffer
         MOV     R0, R5          ; buffer ptr
         MOV     R7, R6          ; buffer UID
         MOV     R10, #0         ; buffer offset for copying
         Pull   "R2, R5, R6"

nogstransingta
         CMP     R4, #13         ; check for more to scan
         CMPNE   R4, #10
         CMPNE   R4, #0
         BEQ     %FT12

         MOVS    R9, R9, LSR #1
         BCC     stripnextparm

    ; gstrans next ; scan afterwards for naffchars
         Push   "R0-R2"

         ADD     R1, R0, R10                  ; buffer pointer
         RSB     R2, R10, #OscliBuffSize      ; room left
         ORR     R2, R2, #GS_Spc_term

         SUB     R0, R6, #1                   ; parameter pointer
         SWI     XOS_GSTrans
         BCS     buffer_overflowed_oh_bother
         BVS     bad_string

         CMP     R2, #0
         BEQ     preversion_detectified       ; empty expansions are naff
         ADD     R10, R10, R2
         ADD     R6, R1, R2
nastycharscan
         LDRB    R2, [R1], #1
         CMP     R2, #&7F
         CMPNE   R2, #" "
         BLE     preversion_detectified
         CMP     R1, R6
         BLO     nastycharscan

         MOV     R6, R0
         Pull   "R0-R2"
         B       next_parameter

preversion_detectified
         ADR     R0, ErrorBlock_BadParmString
       [ International
         BL      TranslateError
       ]
         B       pgstcomm
buffer_overflowed_oh_bother
         ADRL    R0, ErrorBlock_OscliLongLine
       [ International
         BL      TranslateError
       ]
         B       pgstcomm
bad_string
         ADR     R0, ErrorBlock_BadParmString
       [ International
         BL      TranslateError
       ]
pgstcomm
         STR     R0, [stack]
         MOV     R2, R7
         BL      ReleaseBuff
         Pull   "R0-R2, r4"
         B       unpleasantness_in_ModCommsLookUp

         MakeErrorBlock   BadParmString

AddCharForGSTP
         CMP     R8, #0
         MOVEQ   PC, lr
         CMP     R10, #OscliBuffSize
         STRLTB  R4, [R0, R10]
         ADDLT   R10, R10, #1
         MOVLT   PC, lr
         Push   "R0-R2"
         B       buffer_overflowed_oh_bother

stripnextparm
         Push   "R11"
         CMP     R4, #""""
         MOVEQ   R11, #&80000000
         ORREQ   R1, R1, R11
         MOVNE   R11, #0
stripnextchar
         BL      AddCharForGSTP
         LDRB    R4, [R6], #1
         CMP     R4, #""""
         EOREQ   R1, R1, R11
         CMP     R4, #" "
         TSTEQ   R1, #&80000000
         BEQ     parmfinished
         CMP     R4, #13
         CMPNE   R4, #10
         CMPNE   R4, #0
         BNE     stripnextchar
parmfinished
         BIC     R1, R1, #&80000000
         Pull   "R11"

next_parameter
         MOV     R4, #" "
         BL      AddCharForGSTP
         SUB     R6, R6, #1

30       LDRB    R4, [R6], #1
         CMP     R4, #" "
         BEQ     %BT30

         ADD     R1, R1, #1
         B       nogstransingta  ; next parameter

  ; parameters counted : check number

12       BL      AddCharForGSTP   ; terminate the copy

         BIC     R1, R1, #&80000000
         LDR     R4, [R2, #4]
         MOV     R6, R4, LSR #16  ; max no parms
         AND     R6, R6, #&FF
         AND     R4, R4, #&FF     ; min no parms
         CMP     R1, R4
         CMPGE   R6, R1
         BLT     %FT11

   ; checks finished : call the man.

         Push   "R7"              ; j.i.c. module writer can't read

         MOV     lr, PC           ; make link
         ADD     PC, R3, R5       ; and call

         Pull   "R2, r4"
         BL      ReleaseBuff      ; discard buffer got for GSTRANSing

         MRS     R10, CPSR
         ORR     R10, R10, #C_bit ; set C carefully
         MSR     CPSR_f, R10
         STRVS   R0, [stack]
         Pull   "R0, R2-R10, pc"

; Return a command syntax error.  First issue Service_SyntaxError for translation
11
 [ International                  ; Internationalize syntax error messages
         Pull    "r4"             ; r4-> command string in module
         MOV     r1, #Service_SyntaxError ; r2->info block for command, r3->module
         BL      Issue_Service    ; Issue SyntaxError service for possible translation
         CMP     r1, #0           ; Service claimed?
         BEQ     unpleasantness_in_ModCommsLookUp ; Yes then r0-> error block

         Push    "r4"             ; Save -> command string
 ]

         LDR     r4, [r2, #4]
         MOV     r7, r2
         BL      GetOscliBuffer   ; get space for error
         MOV     R2, #ErrorNumber_BadNoParms
         STR     R2, [R5]
         LDR     R2, [R7, #8]
         CMP     R2, #0
         ADREQ   R0, %FT13        ; default error message
         ADDNE   R0, R2, R3       ; point at message
         ORREQ   r4, r4, #International_Help
         TST     r4, #International_Help
         ADREQL  r4, MOSdictionary
         BEQ     %FT37
         MOV     r7, r0
         SUB     sp, sp, #16
         LDR     r2, [r3, #-4]
         LDR     r0, [r3, #Module_MsgFile]
         TST     r0, #12,2
         CMPEQ   r0, #1
         CMPCS   r2, r0
         MOVLS   r0, #0
         BLS     %FT33
         ADD     r1, r3, r0
         MOV     r2, #0
         MOV     r0, sp
         SWI     XMessageTrans_OpenFile
         MOVVS   r0, #0
33       MOV     r1, r7
         MOV     r7, r0           ; Message file data block
         MOV     r2, #0
         SWI     XMessageTrans_Lookup
         ADDVS   r2, r0, #4
         SWI     XMessageTrans_Dictionary
         ADDVS   r2, r0, #4
         MOV     r4, r0
         MOV     r0, r2
         LDR     r2, [sp, #16]
         ADD     r1, r5, #4
         BL      expandsyntaxmessage
         MOVS    r0, r7           ; Close iff message file was used
         SWINE   XMessageTrans_CloseFile
         ADD     sp, sp, #16
         Pull    r2
         B       %FT39
37
         Pull    r2
         ADD     r1, r5, #4
         BL      expandsyntaxmessage
39
         MOV     r0, r5

unpleasantness_in_ModCommsLookUp
         STR     R0, [stack]
         MSR     CPSR_f, #V_bit+C_bit
         Pull   "R0, R2-R10, PC"
13
         DCB     "NumParm", 0

         ALIGN

expandsyntaxmessage
         LDRB    R3, [R0], #1
         CMP     r3, #TokenEscapeChar
         BEQ     esm_tok
         STRB    R3, [R1], #1
         CMP     R3, #0
         BNE     expandsyntaxmessage
         SUB     r1, r1, #1
         MOV     pc, lr

esm_tok  LDRB    r3, [r0], #1
         Push   "r0, lr"
         CMP     r3, #Token0    ; Token0 => use R2
         MOVEQ   r0, r2
         BEQ     esm001
         MOV     r0, r4
esmlp    SUBS    r3, r3, #1
         LDRNEB  r14, [r0]      ; ECN: Use R14 instead of R4 as using R4 corrupts
         ADDNE   r0, r0, r14    ; the dictionary pointer thus disallowing recursive tokens
         BNE     esmlp
         ADD     r0, r0, #1
esm001   BL      expandsyntaxmessage
         Pull   "r0, lr"
         B       expandsyntaxmessage

;---------------------------------------------------------------------------
; routine to just find a keyword in a table that has the flags specified.
; R0 points at command to find
; R1 points at module
; R2 offset of command table
; R4 word to EOR with flags : demand 0 result for match
; C set means allow messy matching, i.e. it's the system command table
; Uses R2-R5

; Return C set if found : R5 is execute offset, R3 length of string
; R2 is offset of execute offset of field found
; r4 is command pointer

FindItem ROUT
         Push   "R4, R6, R7"
         MRS     R7, CPSR         ; to remember C flag (32-bit clean)
         ADD     R2, R2, R1
         LDRB    R4, [R2]
         CMP     R4, #0
         BEQ     FindItem_EOTab
05       MOV     R3, #0           ; offset
01       LDRB    R4, [R0, R3]
         LDRB    R5, [R2, r3]
         CMP     R4, #&80         ; in table ?
         ADRCC   R6, Up_ItAndTerm_Check_Table
         LDRCCB  R4, [R6, R4]
         CMP     R4, #32
         CMPLE   R5, #32
         BLE     %FT04           ; matched, and we're at the terminator
         UpperCase R5, R6
         CMP     R4, R5
         ADDEQ   R3, R3, #1
         BEQ     %BT01
         CMP     R4, #"."        ; success if abbreviation
         BEQ     %FT02
         TST     R7, #C_bit      ; C flag on entry
         BEQ     %FT07           ; nomatch
         CMP     R5, #32
         BGT     %FT07
         CMP     R4, #"A"
         RSBGES  R6, R4, #"Z"
         BLT     %FT04             ; matched, at terminator
07       LDRB    R5, [R2], #1
         CMP     R5, #32
         BGT     %BT07             ; skip to terminator
         ADD     R2, R2, #3
         BIC     R2, R2, #3        ; ALIGN
06       ADD     R2, R2, #16       ; !!! DEPENDANT ON TABLE FORMAT!!!
         LDRB    R5, [R2]
         CMP     R5, #0
         BNE     %BT05
FindItem_EOTab
         Pull   "R4, R6, R7"
         CLC
         MOV     PC, lr            ; back with not found.

Up_ItAndTerm_Check_Table
; Table to uppercase and test for terminators for passed * commands
;      0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   =   0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0     ; 0
   =   0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0     ; 1
   =   0 , "!", 0 , "#" , 0, 0, 0, "'", "(", ")", "*" , "+", 0 , "-", ".", "/"    ; 2
   =  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", 0, ";", 0 , "=", 0 , "?"    ; 3
   =  "@@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O"    ; 4
   =  "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", 0, "]", 0, "_"    ; 5
   =  "`", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O"    ; 6
   =  "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "{", 0 , "}", "~", 0     ; 7

;  WHILE . < Up_ItAndTerm_Check_Table+256 ; top bit stuff done by CMP #&80
;   = . - Up_ItAndTerm_Check_Table
;  WEND                            ; entry for chars > 127 = char

02       CMP     R5, #32          ; only success if $R2 not terminated.
         BLE     %BT07
         ADD     R3, R3, #1       ; skip .
04       MOV     r6, r2
         ADD     r2, r2, r3
08       LDRB    R5, [R2], #1
         CMP     R5, #0
         BNE     %BT08            ; demand NULL terminator
         ADD     R2, R2, #3
         BIC     R2, R2, #3       ; ALIGN
         LDR     R5, [R2, #4]     ; get information word

         AND     R5, R5, #&C0000000 :AND::NOT:Help_Is_Code_Flag
                                  ; clear param numbers/low flags.
         LDR     R4, [stack]
         EORS    R5, R5, R4
         BNE     %BT06            ; flags don't match

         LDR     R5, [R2]         ; get Execute offset
         CMP     R5, #0
         BEQ     %BT06            ; not a command
         STR     r6, [stack]      ; return r4
         Pull   "R4, R6, R7"
         SUB     R2, R2, R1       ; get back to offset.
         SEC
         MOV     PC, lr

;****************************************************************************
; variegated routines
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

OscliInit
; circular buffer initialisation :
;  botUID := topUID := 0 ; currend := circbuffstart
; Redirection handles := 0
         LDR        R0, =ZeroPage
       [ ZeroPage = 0
         STR        R0, [R0, #OscliCBbotUID]
         STR        R0, [R0, #OscliCBtopUID]
       |
         MOV        R1, #0
         STR        R1, [R0, #OscliCBbotUID]
         STR        R1, [R0, #OscliCBtopUID]
       ]
         LDR        R1, =OscliCircBuffStart
         STR        R1, [R0, #OscliCBcurrend]
         ASSERT     (ZeroPage :AND: 255) = 0
         STRB       R0, [R0, #RedirectInHandle]
         STRB       R0, [R0, #RedirectOutHandle]
         MOV        PC, R14

; buffer is valid if botUID < UID


; GetOscliBuffer used in module handler to get error buffers - saves workspace!

GetOscliBuffer ROUT
 ; return ptr in R5 to next buffer in Oscli's circular job
 ; UID in R6
 ; corrupts R2

; currend +:= 256
      LDR    R2, =ZeroPage
      LDR    R5, [R2, #OscliCBcurrend]
      ADD    R5, R5, #OscliBuffSize

; IF currend >= circbufflimit
;  THEN currend := circbuffstart
      LDR    R6, =OscliCircBuffLimit
      CMP    R5, R6
      LDRHS  R5, =OscliCircBuffStart
      STR    R5, [R2, #OscliCBcurrend]

; topUID +:= 1
      LDR    R6, [R2, #OscliCBtopUID]
      ADD    R6, R6, #1
      STR    R6, [R2, #OscliCBtopUID]
; IF topUID > botUID + noBuffers
; THEN botUID +:= 1
      LDR    R5, [R2, #OscliCBbotUID]
      SUB    R2, R6, R5
      CMP    R2, #OscliNoBuffs
      LDR    R2, =ZeroPage
      ADDGE  R5, R5, #1
      STRGE  R5, [R2, #OscliCBbotUID]

; RETURN currend, topUID
      LDR    R5, [R2, #OscliCBcurrend]
      MOV    PC, lr


ReleaseBuff ; take UID in R2, check whether can step back topUID
     EntryS "R1-R4"
     LDR    R1, =ZeroPage
     LDR    R3, [R1, #OscliCBtopUID]
     LDR    R4, [R1, #OscliCBbotUID]
; IF UID = topUID AND topUID <> botUID
     CMP    R3, R4
     EXITS  EQ
     CMP    R2, R3
     EXITS  NE
; THEN $(
;    topUID -:= 1
     SUB    R3, R3, #1
     STR    R3, [R1, #OscliCBtopUID]

;    IF currend = circbuffstart THEN currend := circbufflimit
     LDR    R3, [R1, #OscliCBcurrend]
     LDR    R4, =OscliCircBuffStart
     CMP    R3, R4
     LDREQ  R3, =OscliCircBuffLimit
; currend -:= 256
     SUB    R3, R3, #OscliBuffSize
     STR    R3, [R1, #OscliCBcurrend]
     EXITS

        LTORG                   ; needed now not at top level

OscliRestoreFS
    Push    "R0, lr"
    MOV      R0, #FSControl_RestoreCurrent
    SWI      XOS_FSControl
    Pull    "R0, PC"

OscliTidy    ROUT  ; shut down redirection, restore permanent FS
     Push   "lr"
     BL      RemoveOscliCharJobs
     BL      OscliRestoreFS
     Pull   "PC"

RemoveOscliCharJobs ROUT
     Push   "R0-R2, lr"
     ; Release WrchV before attempting to close the file handles. This protects
     ; against output going missing if it happens during the close operation(s)
     ; E.g. if we're running in a task window and the output device uses
     ; OS_UpCall 6, our WrchV hook may be left installed when control is
     ; returned to the Wimp: https://www.riscosopen.org/tracker/tickets/420
     MOV     R2, #0
     MOV     R0, #WrchV
     ADR     R1, RedirectWrch
     SWI     XOS_Release
   [ ZeroPage <> 0
     LDR     R2, =ZeroPage
   ]
     LDRB    R1, [R2, #RedirectInHandle]
     CMP     R1, #0
     MOVNE   R0, #0
     STRNEB  R0, [R2, #RedirectInHandle]
     SWINE   XOS_Find
     LDRB    R1, [R2, #RedirectOutHandle]
     CMP     R1, #0
     MOVNE   R0, #0 ; May have got error (discarded)
     STRNEB  R0, [R2, #RedirectOutHandle]
     SWINE   XOS_Find
     CLRV
     Pull   "R0-R2, PC"

RedirectWrch ROUT
     Push   "R1"
     LDR     R1, =ZeroPage
     LDRB    R1, [R1, #RedirectOutHandle]
     SWI     XOS_BPut
     Pull   "R1, pc", VC
     BL      RemoveOscliCharJobs
     SETV
     Pull   "R1, pc"

; **************************************************************************
;
;       SWI OS_ChangeRedirection - Read/write redirection handles
;
; in:   R0 = new input  handle (0 => not redirected, -1 => leave alone)
;       R1 = new output handle (0 => not redirected, -1 => leave alone)
;
; out:  R0 = old input  handle (0 => not redirected)
;       R1 = old output handle (0 => not redirected)
;

ChangeRedirection ROUT
        LDR     R12, =ZeroPage
        LDRB    R10, [R12, #RedirectInHandle]
        LDRB    R11, [R12, #RedirectOutHandle]

; do input handle

        CMP     R0, #&100               ; if out of range then just read
        STRCCB  R0, [R12, #RedirectInHandle]

; do output handle

        CMP     R1, #&100               ; if out of range then just read
        BCS     %FT40

        STRB    R1, [R12, #RedirectOutHandle]
        CMP     R1, #1                  ; CS <=> (R1 non-zero)
        TEQ     R11, #0                 ; NE <=> (R11 non-zero)
        BHI     %FT40                   ; [both non-zero, skip]

        BCS     %FT30                   ; [just R1 non-zero, so claim]
        BEQ     %FT40                   ; [both zero, skip]

; R11 non-zero, R1 zero, so release vector

        Push    "R0-R2, lr"             ; set up registers for claim or release
        MOV     R0, #WrchV
        ADR     R1, RedirectWrch
        MOV     R2, #0
        SWI     XOS_Release
        STRVS   R0, [sp, #0*4]
        Pull    "R0-R2, lr"
        ORRVS   lr, lr, #V_bit
        ExitSWIHandler VS
        B       %FT40

; R11 zero, R1 non-zero, so claim vector

30
        Push    "R0-R2, lr"
        MOV     R0, #WrchV
        ADR     R1, RedirectWrch
        MOV     R2, #0
        SWI     XOS_Claim
        STRVS   R0, [sp, #0*4]
        Pull    "R0-R2, lr"
        ORRVS   lr, lr, #V_bit
        ExitSWIHandler VS

40
        MOV     R0, R10
        MOV     R1, R11
        ExitSWIHandler

;**************************************************************************
; Module selection
;  Entered with V set if FileSwitch found a - : must get module or give error
;  R2 >= 0 if filing system selected: do nothing
;  R1 -> command prefix
;  Out: R1 updated
;    R2 = -1: no module
;    R2 = -<larger>:  R2 is selected module node
;         Selected prefix also preferred

CheckForModuleAsPrefix ROUT
     EntryS "R0-R6"
     ADDVS   R1, R1, #1         ; skip -
     MOVVS   R2, #"-"
     BVS     %FT02
     CMP     R2, #-1
     BNE     %FT01
     MOV     R2, #":"           ; terminators for lookup

02   ADR     R5, %FT10
     STR     R1, [stack, #Proc_RegOffset + 4]
03   LDRB    R3, [R1], #1
     UpperCase R3, R4
     LDRB    R4, [R5], #1
     CMP     R3, R4
     BEQ     %BT03
     CMP     R4, #0
     LDRNE   R1, [stack, #Proc_RegOffset + 4]
     SUBEQ   R1, R1, #1
     MOV     R6, R1
     LDR     R1, =AliasExpansionBuffer
05   LDRB    R3, [R6], #1
     CMP     R3, #"."           ; disallow abbreviations: they're confusing!
     CMPNE   R3, #" "
     BLE     %FT01
     CMP     R3, R2
     STRNEB  R3, [R1], #1
     BNE     %BT05

     MOV     R3, #0
     STRB    R3, [R1]

     MOV     R0, #ModHandReason_LookupName
     LDR     R1, =AliasExpansionBuffer
     SWI     XOS_Module
     BVS     %FT01
     MOV     R2, R1
     LDR     R1, =AliasExpansionBuffer
     MOV     R0, #ModHandReason_MakePreferred
     SWI     XOS_Module

     LDR     R0, =ZeroPage+Module_List
04   LDR     R0, [R0]
     SUBS    R2, R2, #1
     BPL     %BT04
     MOV     R1, R6                 ; point at rest of command line.
     RSB     R2, R0, #0
     STR     R1, [stack, #Proc_RegOffset + 4]
     STR     R2, [stack, #Proc_RegOffset + 8]
     EXITS   VC

01
     EXITS                           ; return fileswitch error if set
10
     =      "MODULE#",0
     ALIGN

     LTORG

     END
@


4.6
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d1329 13
a1341 2
     LDR     R0, =ZeroPage
     LDRB    R1, [R0, #RedirectInHandle]
d1343 2
a1344 5
     ASSERT  (ZeroPage :AND: 255) = 0
     STRNEB  R0, [R0, #RedirectInHandle]
   [ ZeroPage <> 0
     MOV     R0, #0
   ] 
d1346 1
a1346 2
     LDR     R0, =ZeroPage ; May have got error (discarded)
     LDRB    R1, [R0, #RedirectOutHandle]
d1348 2
a1349 5
     ASSERT  (ZeroPage :AND: 255) = 0
     STRNEB  R0, [R0, #RedirectOutHandle]
   [ ZeroPage <> 0
     MOV     R0, #0 ; May have got error (discarded)
   ]
a1350 4
     MOV     R2, #0
     MOV     R0, #WrchV
     ADR     R1, RedirectWrch
     SWI     XOS_Release
d1355 1
a1355 2
     Push   "R1, R2"
     SavePSR R2
d1359 1
a1359 4
     RestPSR R2                     ; VClear in entry psr
     Pull   "R1, R2, pc", VC

RedirectError
d1361 2
a1362 3
     ORR     R2, R2, #V_bit
     RestPSR R2
     Pull   "R1, R2, pc"
@


4.6.2.1
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d1329 18
a1346 5
     ; Release WrchV before attempting to close the file handles. This protects
     ; against output going missing if it happens during the close operation(s)
     ; E.g. if we're running in a task window and the output device uses
     ; OS_UpCall 6, our WrchV hook may be left installed when control is
     ; returned to the Wimp: https://www.riscosopen.org/tracker/tickets/420
a1350 13
   [ ZeroPage <> 0
     LDR     R2, =ZeroPage
   ]
     LDRB    R1, [R2, #RedirectInHandle]
     CMP     R1, #0
     MOVNE   R0, #0
     STRNEB  R0, [R2, #RedirectInHandle]
     SWINE   XOS_Find
     LDRB    R1, [R2, #RedirectOutHandle]
     CMP     R1, #0
     MOVNE   R0, #0 ; May have got error (discarded)
     STRNEB  R0, [R2, #RedirectOutHandle]
     SWINE   XOS_Find
d1355 2
a1356 1
     Push   "R1"
d1360 4
a1363 1
     Pull   "R1, pc", VC
d1365 3
a1367 2
     SETV
     Pull   "R1, pc"
@


4.5
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a187 1
  [ LongCommandLines
a188 3
  |
; Also check terminator in first 256 chars.
  ]
a190 1
  [ LongCommandLines
a191 3
  |
         ADD        R2, R0, #256
  ]
a371 1
  [ LongCommandLines
a372 3
  |
      MOV    R2,#256
  ]
a453 1
  [ LongCommandLines
a454 3
  |
      MOV   R2, #256
  ]
@


4.4
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a153 1
       [ No26bitCode
a154 4
       |
         Pull      "lr"
         ORRS       PC, lr, #V_bit
       ]
a270 1
 [ No26bitCode
a272 4
 |
         Pull     "R0-R2, lr"
         ORRS      PC, lr, #V_bit
 ]
@


4.3
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a19 4
                          GBLL    Oscli_QuickAliases
                          GBLL    Oscli_HashedCommands
Oscli_QuickAliases        SETL    {TRUE} :LAND: ChocolateOscli   ;try to do a better job of checking for aliases
Oscli_HashedCommands      SETL    {TRUE} :LAND: ChocolateOscli   ;try to do a better job of finding commands
d28 1
a28 1
$l      MOV      $tmp, #0
d57 2
a58 1
           MOV     R0, #0
d64 3
d77 1
a77 1
           MOV     R1, #0
d94 1
a94 1
           MOV     R1, #0
d151 2
d154 1
a154 2
 [ No26bitCode
         SETV
d156 1
a156 1
 |
d159 1
a159 1
 ]
d193 3
d197 1
d200 3
d204 1
d267 2
d390 3
d394 1
d406 1
a406 1
      MOV    R3,#0
d418 2
a419 1
    [ International
d423 5
d429 1
d460 1
a460 1
      MOV   R4,#0
d476 3
d480 1
d497 2
a498 1
      SWI    XOS_SubstituteArgs
d553 1
a553 2
AliasDot = "Alias$"
dotstring = ".", 0
d569 1
a569 1
         MOV       r2,#0
d571 3
d590 1
a590 1
         MOV       r2,#0
d599 1
a599 1
         MOV       r2,#0
d636 1
a636 1
         MOV       R11, #Module_List
d715 1
a715 1
         MOV       R0, #FSControl_RUN
d756 1
a756 1
         MOV       R0, #FSControl_CAT   ; *., skip .
d821 1
d823 1
d825 3
a827 4
         ADRL   R2, SysCoHashedCmdTab
         LDR    R2, [R2, R4, LSL #2]        ;command list for this hash value
         SEC                                ;carry set means sys module
         B      ModCommsLookUp_AltEntry
d839 1
d842 1
d844 1
d846 3
a848 4
         ADRL   R2, UtilHashedCmdTab
         LDR    R2, [R2, R4, LSL #2]        ;command list for this hash value
         CLC
         B      ModCommsLookUp_AltEntry
d942 1
d948 2
a949 2
         CMP     R1, R10
         BLT     nastycharscan
d1048 1
a1048 1
         mrs    ,R10, CPSR
d1050 1
a1050 1
         msr    ,CPSR_f, R10
d1094 1
a1094 1
         MOV     r7, r0
d1105 1
a1105 1
         MOVS    r0, r7
d1119 1
a1119 1
         msr    ,CPSR_f, #V_bit+C_bit
d1124 1
a1124 1
        ALIGN
d1138 1
a1138 1
         CMP     r3, #0
d1144 1
a1144 1
         ADDNE   r0, r0, r14    ; the dictionary pointer thus disallowing recusive tokens
d1165 2
a1166 1
         Push   "R4, R6"
d1184 1
a1184 1
         CMP     R4, #"."         ; success if abbreviation
d1186 1
a1186 1
         TST     lr, #C_bit
d1203 1
a1203 1
         Pull   "R4, R6"
d1245 1
a1245 1
         Pull   "R4, R6"
d1258 2
a1259 1
         MOV        R0, #0
d1262 5
d1269 1
d1285 1
a1285 1
      MOV    R2, #0
d1305 1
a1305 1
      MOV    R2, #0
d1316 1
a1316 1
     MOV    R1, #0
d1355 1
a1355 1
     MOV     R0, #0
d1358 1
d1360 3
d1364 1
a1364 1
     MOV     R0, #0 ; May have got error (discarded)
d1367 1
d1369 3
d1383 1
a1383 1
     MOV     R1, #0
d1407 1
a1407 1
        MOV     R12, #0
d1414 1
a1414 5
        BCS     %FT20

        STRB    R0, [R12, #RedirectInHandle]

20
d1511 1
a1511 1
     MOV     R0, #Module_List
d1527 2
@


4.3.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d20 4
a808 1

d1015 1
a1015 1
         MRS     R10, CPSR
d1017 1
a1017 1
         MSR     CPSR_f, R10
d1086 1
a1086 1
         MSR     CPSR_f, #V_bit+C_bit
a1480 2

     LTORG
@


4.3.2.2
log
@Reimplement Lazy task swapping, an amusing idea from Ursula,
would have done it sooner but couldn't be bothered (humour).
Currently activates for all ARMs flagged as base-restored
abort model. No handling of eg. StrongARM pre-revT bug, but
then the kernel no longer runs on StrongARM (progress).
Still some details to fix: all aborts in current app space
assumed to be missing pages, but this must be fixed to
handle abort code in app space, things like debuggers
marking code read only.

Plus, small fixes:
  OS_Memory 8 returns vaguely useful info for RAM,VRAM
  in HAL build (temporary partial implementation)
  Broken handling of old BBC commands with (fx,tv etc)
  with no spaces fixed (fudgeulike code from Ursula,
  now 32-bit).

Version 5.35, 4.79.2.31. Tagged as 'Kernel-5_35-4_79_2_31'
@
text
@d1129 1
a1129 2
         Push   "R4, R6, R7"
         MRS     R7, CPSR         ; to remember C flag (32-bit clean)
d1147 1
a1147 1
         CMP     R4, #"."        ; success if abbreviation
d1149 1
a1149 1
         TST     R7, #C_bit      ; C flag on entry
d1166 1
a1166 1
         Pull   "R4, R6, R7"
d1208 1
a1208 1
         Pull   "R4, R6, R7"
@


4.3.2.3
log
@Merge in long command line support from Ursula kernel.
Look for LongCommandLine flag, command line size currently
set at 1k.
For HAL/32bit builds, the kernel buffer space is at high
(top bit set) address, which may break some code using signed
comparisons. So *beware* that there may be some latent
bugs in old kernel code using these buffers, not yet found.
One such bug, in s.Arthur2 found and fixed.
Tested moderately on ARM9 desktop build.
Lovely to reimplement things I did two and half years ago.

Version 5.35, 4.79.2.37. Tagged as 'Kernel-5_35-4_79_2_37'
@
text
@a187 3
  [ LongCommandLines
; Also check terminator in first LongCLISize chars.  
  |
a188 1
  ]
a190 3
  [ LongCommandLines
         ADD        R2, R0, #LongCLISize
  |
a191 1
  ]
a374 3
  [ LongCommandLines
      MOV    R2,#LongCLISize
  |
a375 1
  ]
a449 3
  [ LongCommandLines
      MOV   R2, #LongCLISize
  |
a450 1
  ]
d901 1
a901 1
         BCS     buffer_overflowed_oh_bother
a906 1
         ADD     R6, R1, R10
d912 2
a913 2
         CMP     R1, R6
         BLO     nastycharscan
d925 1
a925 1
buffer_overflowed_oh_bother
d953 1
a953 1
         B       buffer_overflowed_oh_bother
@


4.3.2.4
log
@fix bug in oscli gstrans handling (a problem provoked by
long command lines with top bit set buffer addresses
and not fixed properly). Problem was mistaken rejection
of gstrans'd parameters other than at beginning of
buffer.

Tested on simple desktop build for Risc PC

Version 5.35, 4.79.2.40. Tagged as 'Kernel-5_35-4_79_2_40'
@
text
@d923 1
a923 1
         ADD     R6, R1, R2
@


4.3.2.5
log
@1) Bring IOMD HAL more up to date. Add support for new
call HAL_CleanerSpace (preparation for StrongARM kernel
support).

2) In kernel, add HAL_CleanerSpace call (preparation for
StrongARM and XScale core support). Fix bug found with
ARMv3 support during test on Risc PC.

3) Implement new API for kernel SWIs that have used top
bits of addresses as flags. The new API has an extra
flag that must be set, so kernel can distinguish and
support both APIs. The reason for all this is that
addresses are 32-bits now, people, keep up there. Briefly:

  OS_HeapSort
    bit 31 of r0 set for new API, r1 is full 32-bit address
    flags move from r1 bits 31-29 to r0 bits 30-28

  OS_ReadLine
    bit 31 of r1 set for new API, r0 is full 32-bit address
    flags move from bits 31,30 of r0 to bits 30,29 of r1

  OS_SubstituteArgs
    bit 31 of r2 set for new API, r0 is full 32-bit address
    flag moves from bit 31 of r0 to bit 30 of r2

Tested on Risc PC and briefly on Customer A 2

Ta

Version 5.35, 4.79.2.41. Tagged as 'Kernel-5_35-4_79_2_41'
@
text
@a482 1
      ORR    R2, R2, #&80000000  ; new API (allows for 32-bit addresses)
@


4.3.2.6
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d189 1
a189 1
; Also check terminator in first LongCLISize chars.
d483 2
a484 2
      MOV    R5, #0
      SWI    XOS_SubstituteArgs32
@


4.3.2.7
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d28 1
a28 1
$l      LDR      $tmp, =ZeroPage
d57 1
a57 2
           LDR     R0, =ZeroPage
           ASSERT  (ZeroPage :AND: 255) = 0
a62 3
         [ ZeroPage <> 0
           MOV     R0, #0
         ]
d73 1
a73 1
           LDR     R1, =ZeroPage
d90 1
a90 1
           LDR     R1, =ZeroPage
d399 1
a399 1
      LDR    R3,=ZeroPage
d411 1
a411 2
   [ International
    [ ZeroPage = 0
a414 5
    |
      LDREQ  R3,=ZeroPage
      LDREQB R0,[R3,#ErrorSemaphore]
      ADDEQ  R0,R0,#1
      STREQB R0,[R3,#ErrorSemaphore]
a415 1
   ]
d446 1
a446 1
      LDR   R4,=ZeroPage
d556 1
a556 1
         LDR       r2,=ZeroPage
a557 3
       [ ZeroPage <> 0
         MOV       r2,#0                        ; Must be zero for oscli_hlist_loop. Not entirely sure why!
       ]
d574 1
a574 1
         LDR       r2,=ZeroPage
d583 1
a583 1
         LDR       r2,=ZeroPage
d620 1
a620 1
         LDR       R11, =ZeroPage+Module_List
d1240 1
a1240 2
         LDR        R0, =ZeroPage
       [ ZeroPage = 0
a1242 5
       |
         MOV        R1, #0
         STR        R1, [R0, #OscliCBbotUID]
         STR        R1, [R0, #OscliCBtopUID]
       ]
a1244 1
         ASSERT     (ZeroPage :AND: 255) = 0
d1260 1
a1260 1
      LDR    R2, =ZeroPage
d1280 1
a1280 1
      LDR    R2, =ZeroPage
d1291 1
a1291 1
     LDR    R1, =ZeroPage
d1330 1
a1330 1
     LDR     R0, =ZeroPage
a1332 1
     ASSERT  (ZeroPage :AND: 255) = 0
a1333 3
   [ ZeroPage <> 0
     MOV     R0, #0
   ] 
d1335 1
a1335 1
     LDR     R0, =ZeroPage ; May have got error (discarded)
a1337 1
     ASSERT  (ZeroPage :AND: 255) = 0
a1338 3
   [ ZeroPage <> 0
     MOV     R0, #0 ; May have got error (discarded)
   ]
d1350 1
a1350 1
     LDR     R1, =ZeroPage
d1374 1
a1374 1
        LDR     R12, =ZeroPage
d1482 1
a1482 1
     LDR     R0, =ZeroPage+Module_List
@


4.3.2.8
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d713 1
a713 1
         MOV       R0, #FSControl_Run
d754 1
a754 1
         MOV       R0, #FSControl_Cat   ; *., skip .
@


4.3.2.9
log
@Improve heap manager. Add heap testbed. Add dummy implementation of some OS_ScreenMode reason codes.
Detail:
  s/HeapMan, hdr/KernelWS - Heap manager improvements:
    - Errors generated by interrupted heap operations that are forced to complete by a OS_Heap call from the background are now cached in kernel workspace until the foreground task is resumed. This prevents them from being potentially overwritten by MessageTrans running out of background error buffers.
    - Added new OS_Heap reason code, #7 - Get area aligned. This allows areas of memory to be allocated at specific (power-of-2) alignments, and optionally without crossing a given (power-of-2) boundary. Alignment & boundary calculations are performed using logical addresses.
    - Removed the limitation that all free and allocated blocks must be a multiple of 8 bytes in length. This change was required in order to allow OS_Heap 7 to function correctly. Now the only requirements are that blocks must be multiples of 4 bytes in length, at 4 byte alignment, with a minimum length of 8 bytes. 4 extra padding bytes may still be added to the end of allocations in order to avoid creating 4-byte free blocks.
  s/HeapMan, TestSrc/HeapTest/Makefile, TestSrc/HeapTest/c/testbed, TestSrc/HeapTest/s/asm - Added heap testbed program. Can either use the OS_Heap SWI or directly include a copy of the Kernel's heap manager sources.
  s/vdudecl, s/vduswis - Added dummy implementations of OS_ScreenMode 4, 5 and 6. This prevents the Wimp generating lots of "Unknown OS_ScreenMode reason code" errors when redrawing the screen.
  s/Arthur3, s/Oscli - Moved dotstring closer to where it's used to avoid "ADRL out of range" errors in Tungsten build
Admin:
  Tested in OMAP3 ROM & Tungsten ROM softload.
  Heap testbed successfully performed over 400 million heap ops, so there shouldn't be any serious bugs in the new code (touch wood)


Version 5.35, 4.79.2.128. Tagged as 'Kernel-5_35-4_79_2_128'
@
text
@d550 2
a551 1
AliasDot = "Alias$.", 0
@


4.3.2.10
log
@Add null hash table entry checks to SysCommsModule & UtilityModule hash table lookup
Detail:
  s/Oscli - In SysCommsHashedLookup and UtilCommsHashedLookup, check for null hash table entries instead of just blindly calling ModCommsLookUp_AltEntry.
  This fixes an issue where a crash will occur iff:
  (a) You enter a command which has no entry in one of the two hash tables
  (b) The command is a valid command (with a code entry point) if you reinterpret the corresponding module header as a command table
  In reality, for recent versions of RISC OS 5, you'll get a crash only when trying to execute the command 's'. Some previous OS versions (e.g. 5.12) appear to have been immune to the crash.
  If (a) was true but (b) was false the bug would have also resulted in a small performance hit caused by attempting to scan the module headers for matching commands.
Admin:
  Tested in Tungsten & OMAP ROM builds
  's' no longer crashes, and commands included in the two hash tables still seem to function as normal.
  Fixes issue reported on forums:
  http://www.riscosopen.org/forum/forums/4/topics/902


Version 5.35, 4.79.2.135. Tagged as 'Kernel-5_35-4_79_2_135'
@
text
@d818 2
a820 1
         AND    R4, R1,#Oscli_CHashValMask  ;hash value, masked for command hashing
d822 2
a823 4
         ADRL   R1, SysCommsModule
         CMP    R2, #1                      ;set carry if valid table entry
         BCS    ModCommsLookUp_AltEntry     ;note: carry set to indicate sys module
         Pull   "R0, R2-R10, pc"            ;bail if null hash table entry (with carry clear to indicate failure)         
d838 2
a840 1
         AND    R4, R1,#Oscli_CHashValMask  ;hash value, masked for command hashing
d842 2
a843 4
         ADRL   R1, UtilityMod
         TEQ    R2, #0,2                    ;check R2 and clear carry
         BNE    ModCommsLookUp_AltEntry
         Pull   "R0, R2-R10, pc"            ;bail if null hash table entry
@


4.3.2.11
log
@Fix *SAVE syntax error message.
The text had cunning hardspaces in it so that the *HELP text lines up nicely using OS_PrettyPrint, but not taking into account that internationalised syntax errors don't use OS_PrettyPrint so output VDU31,31,31 and jumped all over the place.
Syntax message rephrased to fit on one line.
Syntax and help for *TV cleared up since the help text contained all the syntax information.
Spotted 2 wasted instructions in Oscli.s while investigating, added some comments too.

Version 5.35, 4.79.2.137. Tagged as 'Kernel-5_35-4_79_2_137'
@
text
@a150 2
       |
         SETV                           ; In place of TranslateError
d152 2
a153 1
       [ No26bitCode
d155 1
a155 1
       |
d158 1
a158 1
       ]
d1091 1
a1091 1
         MOV     r7, r0           ; Message file data block
d1102 1
a1102 1
         MOVS    r0, r7           ; Close iff message file was used
d1121 1
a1121 1
         ALIGN
d1135 1
a1135 1
         CMP     r3, #Token0    ; Token0 => use R2
d1141 1
a1141 1
         ADDNE   r0, r0, r14    ; the dictionary pointer thus disallowing recursive tokens
d1411 5
a1415 1
        STRCCB  R0, [R12, #RedirectInHandle]
@


4.3.2.12
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@a266 2
       |
         SETV
@


4.3.2.6.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d28 1
a28 1
$l      LDR      $tmp, =ZeroPage
d57 1
a57 2
           LDR     R0, =ZeroPage
           ASSERT  (ZeroPage :AND: 255) = 0
a62 3
         [ ZeroPage <> 0
           MOV     R0, #0
         ]
d73 1
a73 1
           LDR     R1, =ZeroPage
d90 1
a90 1
           LDR     R1, =ZeroPage
d399 1
a399 1
      LDR    R3,=ZeroPage
d411 1
a411 2
   [ International
    [ ZeroPage = 0
a414 5
    |
      LDREQ  R3,=ZeroPage
      LDREQB R0,[R3,#ErrorSemaphore]
      ADDEQ  R0,R0,#1
      STREQB R0,[R3,#ErrorSemaphore]
a415 1
   ]
d446 1
a446 1
      LDR   R4,=ZeroPage
d556 1
a556 1
         LDR       r2,=ZeroPage
a557 3
       [ ZeroPage <> 0
         MOV       r2,#0                        ; Must be zero for oscli_hlist_loop. Not entirely sure why!
       ]
d574 1
a574 1
         LDR       r2,=ZeroPage
d583 1
a583 1
         LDR       r2,=ZeroPage
d620 1
a620 1
         LDR       R11, =ZeroPage+Module_List
d1240 1
a1240 2
         LDR        R0, =ZeroPage
       [ ZeroPage = 0
a1242 5
       |
         MOV        R1, #0
         STR        R1, [R0, #OscliCBbotUID]
         STR        R1, [R0, #OscliCBtopUID]
       ]
a1244 1
         ASSERT     (ZeroPage :AND: 255) = 0
d1260 1
a1260 1
      LDR    R2, =ZeroPage
d1280 1
a1280 1
      LDR    R2, =ZeroPage
d1291 1
a1291 1
     LDR    R1, =ZeroPage
d1330 1
a1330 1
     LDR     R0, =ZeroPage
a1332 1
     ASSERT  (ZeroPage :AND: 255) = 0
a1333 3
   [ ZeroPage <> 0
     MOV     R0, #0
   ] 
d1335 1
a1335 1
     LDR     R0, =ZeroPage ; May have got error (discarded)
a1337 1
     ASSERT  (ZeroPage :AND: 255) = 0
a1338 3
   [ ZeroPage <> 0
     MOV     R0, #0 ; May have got error (discarded)
   ]
d1350 1
a1350 1
     LDR     R1, =ZeroPage
d1374 1
a1374 1
        LDR     R12, =ZeroPage
d1482 1
a1482 1
     LDR     R0, =ZeroPage+Module_List
@


4.2
log
@ChocolateSysVars and ChocolateOscli merged from Ursula.

Version 4.84. Tagged as 'Kernel-4_84'
@
text
@a29 3
        GBLL    redirectinkey
redirectinkey SETL True

d47 1
a47 2

           Push   "R1, R2, lr"
d79 1
a79 6
 [ redirectinkey
 BEQ %FT00
 |
           MOVEQ   R0, #RdchV
           ADREQL  R1, RedirectRdch
 ]
d88 1
a88 1
           LDR     R2, [stack]
d90 1
a90 1
           GRABS  "R1, R2, PC", NE
d100 1
a100 1
           GRABS  "R1, R2, PC", VC
d111 1
a111 2
           Pull   "R1, R2, lr"
           ORRS    PC, lr, #V_bit
d152 4
d158 1
d186 1
a186 1
         GRABS     "R0-R2, PC", EQ   ; V clear return
d265 4
d271 1
d553 1
a553 1
         TEQP      PC, #C_bit :OR: SVC_mode     ; carry set means sys module
d597 1
a597 1
         TEQP      PC, #SVC_mode              ; clear C
d622 1
a622 1
         TEQP      PC, #SVC_mode              ; clear C
d641 1
a641 1
         TEQP      PC, #SVC_mode                 ; clear C
d659 1
a659 1
         TEQP      PC, #SVC_mode                 ; clear C
d690 2
a691 1
         Push     "R0, PC"
d695 1
a695 1
         Pull     "R0, R1"
d703 7
a709 4
         STRNE     R0, [stack]           ; error pointer
         Pull     "R0-R2, lr"
         BICEQS    PC, lr, #V_bit
         ORRS      PC, lr, #V_bit
d796 1
a796 1
         TEQP   PC, #C_bit :OR: SVC_mode    ;carry set means sys module
d802 1
a802 1
         TEQP   PC, #C_bit :OR: SVC_mode            ;carry set means sys module
d815 1
a815 1
         TEQP   PC, #SVC_mode               ;clear C
d842 4
a845 2
         Pull   "R0, R2-R10, lr", CC
         BICCCS  PC, lr, #V_bit + C_bit
d1015 3
d1019 1
a1019 5
         Pull   "R0, R2-R10, lr"

         ORR     lr, lr, #C_bit
         BICVCS  PC, lr, #V_bit
         ORRS    PC, lr, #V_bit
d1086 2
a1087 2
         Pull   "R0, R2-R10, lr"
         ORRS    PC, lr, #V_bit+C_bit
d1170 2
a1171 1
         BICS    PC, lr, #C_bit   ; back with not found.
d1213 2
a1214 1
         ORRS    PC, lr, #C_bit
d1274 1
a1274 1
     Push  "R1-R4"
d1280 1
a1280 2
     Pull  "R1-R4",EQ
     MOVEQS PC, lr
d1282 1
a1282 2
     Pull  "R1-R4",NE
     MOVNES PC, lr
d1296 1
a1296 2
     Pull  "R1-R4"
     MOVS   PC, lr
a1324 5
 [ :LNOT: redirectinkey
     MOV     R0, #RdchV
     ADR     R1, RedirectRdch
     SWI     XOS_Release
 ]
d1328 2
a1329 28
     Pull   "R0-R2, PC",,^

 [ :LNOT: redirectinkey
RedirectRdch ROUT
     Push   "R1"
     MOV     R0, #0
     LDRB    R1, [R0, #ESC_Status]
     TST     R1, #1:SHL:6
     BNE     %FT01
     LDRB    R1, [R0, #RedirectInHandle]
     SWI     XOS_BGet
     BVS     RedirectError
     Pull   "R1, lr", CC
     BICCCS  PC, lr, #C_bit
01   ADR     R1, RedirectRdch
     MOV     R0, #RdchV
     Push   "R2"
     MOV     R2, #0
     SWI     XOS_Release
     Pull   "R2"
     MOV     R0, #0
     LDRB    R1, [R0, #RedirectInHandle]
     STRB    R0, [R0, #RedirectInHandle]
     SWI     XOS_Find
     Pull   "R1, lr"
     BICEQS  PC, lr, #C_bit     ; EQ/NE still Escape state!
     ORRNES  PC, lr, #C_bit
 ]
d1332 2
a1333 1
     Push   "R1"
d1337 2
a1338 1
     Pull   "R1, pc", VC, ^             ; VClear in stacked pc/psr
d1342 3
a1344 2
     Pull   "R1, lr"
     ORRS    PC, lr, #V_bit
a1368 35
 [ :LNOT: redirectinkey
        CMP     R0, #1                  ; CS <=> (R0 non-zero)
        TEQ     R10, #0                 ; NE <=> (R10 non-zero)
        BHI     %FT20                   ; [both non-zero, skip]

        BCS     %FT10                   ; [just R0 non-zero, so claim]
        BEQ     %FT20                   ; [both zero, skip]

; R10 non-zero, R0 zero, so release vector

        Push    "R0-R2, lr"             ; set up registers for claim or release
        MOV     R0, #RdchV
        ADR     R1, RedirectRdch
        MOV     R2, #0
        SWI     XOS_Release
        STRVS   R0, [sp, #0*4]
        Pull    "R0-R2, lr"
        ORRVS   lr, lr, #V_bit
        ExitSWIHandler VS
        B       %FT20

; R10 zero, R0 non-zero, so claim vector

10
        Push    "R0-R2, lr"
        MOV     R0, #RdchV
        ADR     R1, RedirectRdch
        MOV     R2, #0
        SWI     XOS_Claim
        STRVS   R0, [sp, #0*4]
        Pull    "R0-R2, lr"
        ORRVS   lr, lr, #V_bit
        ExitSWIHandler VS
 ]

d1426 1
a1426 1
     Push   "R0-R6, lr"
d1435 1
a1435 1
     STR     R1, [stack, #4]
d1442 1
a1442 1
     LDRNE   R1, [stack, #4]
d1472 3
a1474 3
     LDR     R0, [stack], #12       ; Pull R0, skip R1,R2
     Pull   "R3-R6, lr"
     BICS    PC, lr, #V_bit
d1477 1
a1477 1
     Pull   "R0-R6, PC",, ^    ; return fileswitch error if set
@


4.1
log
@Initial revision
@
text
@d17 13
d161 1
a161 1
       ]  
d345 45
d392 1
a392 1
      LDRB   R6,[R3,#ErrorSemaphore]            ; We are about to get lots of buffer overflow errors, 
d394 1
a394 1
      STRB   R6,[R3,#ErrorSemaphore]             
d400 1
a400 1
      ADR    R0, AliasStr
d458 3
d522 3
d530 3
d541 10
d555 1
d558 48
d713 1
a713 1
         ADR       R0, AliasDot
d728 90
d830 3
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d103 1
d105 1
d146 1
d148 1
d248 1
d250 1
d262 1
d264 1
d291 1
d293 3
d332 1
d337 1
d345 1
d349 1
d379 1
d384 1
d439 1
d441 1
d452 1
d454 3
d550 1
d552 3
d699 1
d701 1
d705 1
d707 1
d711 1
d713 1
d799 1
d807 1
@


4.1.4.2
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a16 13
;
;mjs performance enhancements for Ursula (ChocolateOscli)
;
                          GBLL    Oscli_QuickAliases
                          GBLL    Oscli_HashedCommands
Oscli_QuickAliases        SETL    {TRUE} :LAND: ChocolateOscli   ;try to do a better job of checking for aliases
Oscli_HashedCommands      SETL    {TRUE} :LAND: ChocolateOscli   ;try to do a better job of finding commands
Oscli_CHashValMask        *       &1f                  ;32-wide Command hashing, for commands within kernel
Oscli_MHashValMask        *       &ff                  ;256-wide Module hashing, for command groups in other modules
                                                       ; - kernel cmd hashed tables must be reorganised if Oscli_CHashValMask is changed
                                                       ; - UtilityModule MUST be first in module chain, if hashing in use


a319 45

  [ Oscli_QuickAliases
    ;
    ;at least make a vague attempt not to run like a drain - since we can do a binary
    ;chop search for an exactly known var name, do this unless command is abbreviated
    ;
      ADR    R6,AliasStr_QA
      LDR    R3,=AliasExpansionBuffer      ; construct the alias name here
      MOV    R5,#6
oqa_loop1                                  ; bung in "ALIAS$"
      LDRB   R4,[R6],#1
      STRB   R4,[R3],#1
      SUBS   R5,R5,#1
      BNE    oqa_loop1
      MOV    R6,R0
      ADRL   R2, Up_ItAndTerm_Check_Table
oqa_loop2                                  ; bung in command, upper cased
      LDRB   R4,[R6],#1
      CMP    R4,#&80                       ; char in table ?
      LDRCCB R4,[R2,R4]
      STRB   R4,[R3],#1
      CMP    R4,#0
      BNE    oqa_loop2
      LDRB   R4,[R3,#-2]                   ; pick up last char of command
      CMP    R4,#"."
      BEQ    oqa_treacletime               ; it's abbreviated, go to slow code
      LDR    R3,=AliasExpansionBuffer
      Push   "r6,r7"
      BL     VarFindIt_QA                  ; quick binary chop type stuff
      Pull   "r6,r7",EQ
      BEQ    oqa_quicksilvertime_noalias   ; no alias - carry on
;found alias
      MOV    R0,#-1                        ; special, VarFindIt skipping call (r5,r6,r7 from VarFindIt_QA)
      MOV    R1,R3                         ; output buffer
      MOV    R2,#256
      MOV    R3,#0
      MOV    R4,#VarType_Expanded
      SWI    XOS_ReadVarVal                ; expand it
      Pull   "r6,r7"
      SUB    R6,R6,#1                      ; arg ptr
      B      oqa_quicksilvertime_alias
oqa_treacletime
;
  ] ;Oscli_Quickaliases

d328 1
a328 1
      ADRL   R0, AliasStr
a376 1

a381 3
  [ Oscli_QuickAliases
oqa_quicksilvertime_alias
  ]
a436 3
  [ Oscli_QuickAliases
AliasStr_QA = "ALIAS$", 0
  ]
a441 3
  [ Oscli_QuickAliases
oqa_quicksilvertime_noalias
  ]
a449 10
  [ Oscli_HashedCommands
         BL        Oscli_cmd_hashsum            ; => hash value in r1
         MOV       r2,#0
         STR       r1,[r2,#Oscli_CmdHashSum]
         CMP       r1,#0
         BEQ       oscli_sysabbrevation
         BL        SysCommsHashedLookup
         B         oscli_syslook_done
oscli_sysabbrevation
  ]
a453 1
oscli_syslook_done
a455 48
  [ Oscli_HashedCommands
         ;now try UtilityModule, if non-abbreviated command
         Push      "R2"
         MOV       r2,#0
         LDR       r1,[r2,#Oscli_CmdHashSum]
         CMP       r1,#0
         Pull      "R2",EQ
         BEQ       oscli_modabbreviation
         BL        UtilCommsHashedLookup
         ADDCS     stack, stack, #4                  ;discard R2
         BCS       OscliExit
         ;now try list of modules on hash value
         MOV       r2,#0
         LDR       r1,[r2,#Oscli_CmdHashSum]
         AND       r1,r1,#Oscli_MHashValMask
         LDR       r11,[r2,#Oscli_CmdHashLists]
         CMP       r11,#0
         LDRNE     r11,[r11,r1,LSL #2]
         CMPNE     r11,#0
         BEQ       %FT75
         Push      "r3,r4"
         ADD       r3,r11,#8
         LDR       r4,[r11,#4]
         ADD       r4,r4,#1
oscli_hlist_loop
         SUBS      r4,r4,#1
         Pull      "r3,r4",EQ
         BEQ       %FT75
         LDR       R2,[stack,#2*4]
         CMP       R2, #0
         Pull      "r3,r4",MI
         BMI       OneModule_Failed
         LDR       R11,[R3],#4
         LDR       R1, [R11, #Module_code_pointer]
         LDR       R2, [R1, #Module_HC_Table]
         CMP       R2, #0
         BEQ       oscli_hlist_loop
         LDR       R12, [R11, #Module_incarnation_list] ; preferred life
         ADD       R12, R12, #Incarnation_Workspace
         TEQP      PC, #SVC_mode              ; clear C
         BL        ModCommsLookUp
         BCC       oscli_hlist_loop
         Pull      "r3,r4"
         ADD       stack,stack,#4
         B         OscliExit
oscli_modabbreviation
  ] ;Oscli_HashedCommands

d559 1
a559 1
         ADRL      R0, AliasDot
a573 63
  [ Oscli_HashedCommands
;
; - routine to compute hash value for unabbreviated commands
; - does not apply mask to hash value (since different hash widths are
;   required in different cases)
;
; hash value = sum of all chars of command, excluding terminator, all
;              chars being processed through Up_ItAndTerm_Check_Table
;
; entry:
; R0 -> command
; exit:
; R1 =  hash value, or 0 if invalid (abbreviation encountered)
;
Oscli_cmd_hashsum ROUT
         Push   "r0,r2-r3,lr"
         MOV    r1,#0
         ADRL   r2, Up_ItAndTerm_Check_Table
         B      %FT15
10
         ADD    r1,r1,r3
15
         LDRB   r3,[r0],#1
         CMP    r3,#&80
         LDRCCB r3,[r2,r3]
         CMP    r3,#"."
         BEQ    %FT30
         CMP    r3,#0
         BNE    %BT10
20
         Pull   "r0,r2-r3,PC"
30
         MOV    r1,#0
         Pull   "r0,r2-r3,PC"
;
;special entry of ModCommsLookUp, for hashed lookup of commands in SysCommsModule
;entry: R0 -> command, r1 = hash value of command
;
SysCommsHashedLookup ROUT
         Push   "R0, R2-R10, lr"
         AND    R4, R1,#Oscli_CHashValMask  ;hash value, masked for command hashing
         ADRL   R1, SysCommsModule
         ADRL   R2, SysCoHashedCmdTab
         LDR    R2, [R2, R4, LSL #2]        ;command list for this hash value
         TEQP   PC, #C_bit :OR: SVC_mode    ;carry set means sys module
         B      ModCommsLookUp_AltEntry
;
;special entry of ModCommsLookUp, for hashed lookup of commands in UtilityMod
;entry: R0 -> command, r1 = hash value of command
;
UtilCommsHashedLookup ROUT
         Push   "R0, R2-R10, lr"
         AND    R4, R1,#Oscli_CHashValMask  ;hash value, masked for command hashing
         ADRL   R1, UtilityMod
         ADRL   R2, UtilHashedCmdTab
         LDR    R2, [R2, R4, LSL #2]        ;command list for this hash value
         TEQP   PC, #SVC_mode               ;clear C
         B      ModCommsLookUp_AltEntry
;
  ] ;Oscli_HashedCommands

;***************************************************************************

a585 3
  [ Oscli_HashedCommands
ModCommsLookUp_AltEntry
  ]
d915 8
a922 8
   =   0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0                   ; 0
   =   0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0                   ; 1
   =   0 , "!", 0 , "#" , 0, 0, 0, "'", "(", ")", "*" , "+", 0 , "-", ".", "/"         ; 2
   =  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", 0, ";", 0 , "=", 0 , "?"       ; 3
   =  "@@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O"   ; 4
   =  "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", 0, "]", 0, "_"       ; 5
   =  "`", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O"   ; 6
   =  "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "{", 0 , "}", "~", 0      ; 7
@


4.1.4.3
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a192 3
  [ LongCommandLines
; Also check terminator in first LongCLISize chars.  
  |
a193 1
  ]
a195 3
  [ LongCommandLines
         ADD        R2, R0, #LongCLISize
  |
a196 1
  ]
d255 1
a255 1
51       MOV       R2, R6            ; longer than allowed
a366 3
  [ LongCommandLines
      MOV    R2,#LongCLISize
  |
a367 1
  ]
a436 3
  [ LongCommandLines
      MOV   R2, #LongCLISize
  |
a437 1
  ]
a740 20
;
;first a fudge, to allow old syntax (no space before first, numeric, parameter)
;for *fx, *key, *opt and *tv - look for '&' or a numeric char at R0 + 2, 3 or 4
;
         MOV    R4, #2
schl_fudgeloop
         LDRB   R2, [R0,R4]
         CMP    R2, #' '
         BLS    schl_nofudge
         CMP    R2, #'&'
         BEQ    schl_fudge
         CMP    R2, #'0'
         BLO    schl_nofudgesofar
         CMP    R2, #'9'
         BLS    schl_fudge
schl_nofudgesofar
         ADD    R4, R4, #1
         CMP    R4, #4
         BLS    schl_fudgeloop
schl_nofudge  
a746 7
schl_fudge
         ADRL   R1, SysCommsModule
         ADRL   R2, SHC_fudgeulike
         SUB    R2, R2, R1                          ;fudge command list (offset)
         TEQP   PC, #C_bit :OR: SVC_mode            ;carry set means sys module
         B      ModCommsLookUp_AltEntry

d844 1
a844 1
         BCS     buffer_overflowed_obother
d866 1
a866 1
buffer_overflowed_obother
d890 1
a890 1
         B       buffer_overflowed_obother
d1174 1
a1174 1
; currend +:= OscliBuffSize
d1226 1
a1226 1
; currend -:= OscliBuffSize
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.11;
access;
symbols
	Kernel-6_15:4.11
	Kernel-6_14:4.11
	Kernel-6_01-3:4.10
	Kernel-6_13:4.10
	Kernel-6_12:4.10
	Kernel-6_11:4.10
	Kernel-6_10:4.10
	Kernel-6_09:4.10
	Kernel-6_08-4_129_2_10:4.10
	Kernel-6_08-4_129_2_9:4.10
	Kernel-6_08:4.10
	Kernel-6_07:4.10
	Kernel-6_06:4.10
	Kernel-6_05-4_129_2_8:4.10
	Kernel-6_05:4.10
	Kernel-6_04:4.10
	Kernel-6_03:4.10
	Kernel-6_01-2:4.10
	Kernel-6_01-4_146_2_1:4.10
	Kernel-6_02:4.10
	Kernel-6_01-1:4.10
	Kernel-6_01:4.10
	Kernel-6_00:4.10
	Kernel-5_99:4.10
	Kernel-5_98:4.10
	Kernel-5_97-4_129_2_7:4.10
	Kernel-5_97:4.10
	Kernel-5_96:4.10
	Kernel-5_95:4.10
	Kernel-5_94:4.10
	Kernel-5_93:4.10
	Kernel-5_92:4.10
	Kernel-5_91:4.10
	Kernel-5_90:4.10
	Kernel-5_89-4_129_2_6:4.10
	Kernel-5_89:4.10
	Kernel-5_88-4_129_2_5:4.10
	Kernel-5_88-4_129_2_4:4.10
	Kernel-5_88:4.10
	Kernel-5_87:4.10
	Kernel-5_86-4_129_2_3:4.10
	Kernel-5_86-4_129_2_2:4.10
	Kernel-5_86-4_129_2_1:4.10
	Kernel-5_86:4.10
	SMP:4.10.0.2
	SMP_bp:4.10
	Kernel-5_85:4.10
	Kernel-5_54-1:4.10
	Kernel-5_84:4.10
	Kernel-5_83:4.10
	Kernel-5_82:4.10
	Kernel-5_81:4.10
	Kernel-5_80:4.10
	Kernel-5_79:4.10
	Kernel-5_78:4.10
	Kernel-5_77:4.10
	Kernel-5_76:4.10
	Kernel-5_75:4.10
	Kernel-5_74:4.10
	Kernel-5_73:4.10
	Kernel-5_72:4.10
	Kernel-5_71:4.10
	Kernel-5_70:4.10
	Kernel-5_69:4.10
	Kernel-5_68:4.10
	Kernel-5_67:4.10
	Kernel-5_66:4.10
	Kernel-5_65:4.10
	Kernel-5_64:4.10
	Kernel-5_63:4.10
	Kernel-5_62:4.10
	Kernel-5_61:4.10
	Kernel-5_60:4.10
	Kernel-5_59:4.10
	Kernel-5_58:4.10
	Kernel-5_57:4.10
	Kernel-5_56:4.10
	Kernel-5_55:4.10
	Kernel-5_54:4.10
	Kernel-5_53:4.9
	Kernel-5_52:4.9
	Kernel-5_51:4.9
	Kernel-5_50:4.8
	Kernel-5_49:4.8
	HAL_merge:4.6.2.8
	Kernel-5_48:4.7
	Kernel-5_35-4_79_2_327:4.6.2.8
	Kernel-5_35-4_79_2_326:4.6.2.8
	Kernel-5_35-4_79_2_325:4.6.2.8
	Kernel-5_35-4_79_2_324:4.6.2.8
	Kernel-5_35-4_79_2_323:4.6.2.8
	Kernel-5_35-4_79_2_322:4.6.2.8
	Kernel-5_35-4_79_2_321:4.6.2.8
	Kernel-5_35-4_79_2_320:4.6.2.8
	Kernel-5_35-4_79_2_319:4.6.2.8
	Kernel-5_35-4_79_2_318:4.6.2.8
	Kernel-5_35-4_79_2_317:4.6.2.8
	Kernel-5_35-4_79_2_316:4.6.2.8
	Kernel-5_35-4_79_2_315:4.6.2.8
	Kernel-5_35-4_79_2_314:4.6.2.8
	Kernel-5_35-4_79_2_313:4.6.2.8
	Kernel-5_35-4_79_2_312:4.6.2.8
	Kernel-5_35-4_79_2_311:4.6.2.8
	Kernel-5_35-4_79_2_310:4.6.2.8
	Kernel-5_35-4_79_2_309:4.6.2.8
	Kernel-5_35-4_79_2_308:4.6.2.8
	Kernel-5_35-4_79_2_307:4.6.2.8
	Kernel-5_35-4_79_2_306:4.6.2.8
	Kernel-5_35-4_79_2_305:4.6.2.8
	Kernel-5_35-4_79_2_304:4.6.2.8
	Kernel-5_35-4_79_2_303:4.6.2.8
	Kernel-5_35-4_79_2_302:4.6.2.8
	Kernel-5_35-4_79_2_301:4.6.2.8
	Kernel-5_35-4_79_2_300:4.6.2.8
	Kernel-5_35-4_79_2_299:4.6.2.8
	Kernel-5_35-4_79_2_298:4.6.2.8
	Kernel-5_35-4_79_2_297:4.6.2.8
	Kernel-5_35-4_79_2_296:4.6.2.8
	Kernel-5_35-4_79_2_295:4.6.2.8
	Kernel-5_35-4_79_2_294:4.6.2.8
	Kernel-5_35-4_79_2_293:4.6.2.8
	Kernel-5_35-4_79_2_292:4.6.2.8
	Kernel-5_35-4_79_2_291:4.6.2.8
	Kernel-5_35-4_79_2_290:4.6.2.8
	Kernel-5_35-4_79_2_289:4.6.2.8
	Kernel-5_35-4_79_2_288:4.6.2.8
	Kernel-5_35-4_79_2_287:4.6.2.8
	Kernel-5_35-4_79_2_286:4.6.2.8
	Kernel-5_35-4_79_2_285:4.6.2.8
	Kernel-5_35-4_79_2_284:4.6.2.8
	Kernel-5_35-4_79_2_283:4.6.2.8
	Kernel-5_35-4_79_2_282:4.6.2.8
	Kernel-5_35-4_79_2_281:4.6.2.8
	Kernel-5_35-4_79_2_280:4.6.2.8
	Kernel-5_35-4_79_2_279:4.6.2.8
	Kernel-5_35-4_79_2_278:4.6.2.8
	Kernel-5_35-4_79_2_277:4.6.2.8
	Kernel-5_35-4_79_2_276:4.6.2.8
	Kernel-5_35-4_79_2_275:4.6.2.8
	Kernel-5_35-4_79_2_274:4.6.2.8
	Kernel-5_35-4_79_2_273:4.6.2.8
	Kernel-5_35-4_79_2_272:4.6.2.8
	Kernel-5_35-4_79_2_271:4.6.2.8
	Kernel-5_35-4_79_2_270:4.6.2.8
	Kernel-5_35-4_79_2_269:4.6.2.8
	Kernel-5_35-4_79_2_268:4.6.2.8
	Kernel-5_35-4_79_2_267:4.6.2.8
	Kernel-5_35-4_79_2_266:4.6.2.8
	Kernel-5_35-4_79_2_265:4.6.2.8
	Kernel-5_35-4_79_2_264:4.6.2.8
	Kernel-5_35-4_79_2_263:4.6.2.8
	Kernel-5_35-4_79_2_262:4.6.2.8
	Kernel-5_35-4_79_2_261:4.6.2.8
	Kernel-5_35-4_79_2_260:4.6.2.8
	Kernel-5_35-4_79_2_259:4.6.2.8
	Kernel-5_35-4_79_2_258:4.6.2.8
	Kernel-5_35-4_79_2_257:4.6.2.8
	Kernel-5_35-4_79_2_256:4.6.2.8
	Kernel-5_35-4_79_2_255:4.6.2.8
	Kernel-5_35-4_79_2_254:4.6.2.8
	Kernel-5_35-4_79_2_253:4.6.2.8
	Kernel-5_35-4_79_2_252:4.6.2.8
	Kernel-5_35-4_79_2_251:4.6.2.8
	Kernel-5_35-4_79_2_250:4.6.2.8
	Kernel-5_35-4_79_2_249:4.6.2.8
	Kernel-5_35-4_79_2_248:4.6.2.8
	Kernel-5_35-4_79_2_247:4.6.2.8
	Kernel-5_35-4_79_2_246:4.6.2.8
	Kernel-5_35-4_79_2_245:4.6.2.8
	Kernel-5_35-4_79_2_244:4.6.2.8
	Kernel-5_35-4_79_2_243:4.6.2.8
	Kernel-5_35-4_79_2_242:4.6.2.8
	Kernel-5_35-4_79_2_241:4.6.2.8
	Kernel-5_35-4_79_2_240:4.6.2.8
	Kernel-5_35-4_79_2_239:4.6.2.8
	Kernel-5_35-4_79_2_238:4.6.2.8
	Kernel-5_35-4_79_2_237:4.6.2.8
	Kernel-5_35-4_79_2_236:4.6.2.8
	Kernel-5_35-4_79_2_235:4.6.2.8
	Kernel-5_35-4_79_2_234:4.6.2.8
	Kernel-5_35-4_79_2_233:4.6.2.8
	Kernel-5_35-4_79_2_232:4.6.2.8
	Kernel-5_35-4_79_2_231:4.6.2.8
	Kernel-5_35-4_79_2_230:4.6.2.8
	Kernel-5_35-4_79_2_229:4.6.2.8
	Kernel-5_35-4_79_2_228:4.6.2.8
	Kernel-5_35-4_79_2_227:4.6.2.8
	Kernel-5_35-4_79_2_226:4.6.2.8
	Kernel-5_35-4_79_2_225:4.6.2.8
	Kernel-5_35-4_79_2_224:4.6.2.8
	Kernel-5_35-4_79_2_223:4.6.2.8
	Kernel-5_35-4_79_2_222:4.6.2.8
	Kernel-5_35-4_79_2_221:4.6.2.8
	Kernel-5_35-4_79_2_220:4.6.2.8
	Kernel-5_35-4_79_2_219:4.6.2.8
	Kernel-5_35-4_79_2_218:4.6.2.8
	Kernel-5_35-4_79_2_217:4.6.2.8
	Kernel-5_35-4_79_2_216:4.6.2.8
	Kernel-5_35-4_79_2_215:4.6.2.7
	Kernel-5_35-4_79_2_214:4.6.2.7
	Kernel-5_35-4_79_2_213:4.6.2.7
	Kernel-5_35-4_79_2_212:4.6.2.7
	Kernel-5_35-4_79_2_211:4.6.2.7
	Kernel-5_35-4_79_2_210:4.6.2.7
	Kernel-5_35-4_79_2_209:4.6.2.7
	Kernel-5_35-4_79_2_208:4.6.2.7
	Kernel-5_35-4_79_2_207:4.6.2.7
	Kernel-5_35-4_79_2_206:4.6.2.7
	Kernel-5_35-4_79_2_205:4.6.2.7
	Kernel-5_35-4_79_2_204:4.6.2.7
	Kernel-5_35-4_79_2_203:4.6.2.7
	Kernel-5_35-4_79_2_202:4.6.2.7
	Kernel-5_35-4_79_2_201:4.6.2.7
	Kernel-5_35-4_79_2_200:4.6.2.7
	Kernel-5_35-4_79_2_199:4.6.2.7
	Kernel-5_35-4_79_2_198:4.6.2.7
	Kernel-5_35-4_79_2_197:4.6.2.7
	Kernel-5_35-4_79_2_196:4.6.2.7
	Kernel-5_35-4_79_2_195:4.6.2.7
	Kernel-5_35-4_79_2_194:4.6.2.7
	Kernel-5_35-4_79_2_193:4.6.2.7
	Kernel-5_35-4_79_2_192:4.6.2.7
	Kernel-5_35-4_79_2_191:4.6.2.7
	Kernel-5_35-4_79_2_190:4.6.2.7
	Kernel-5_35-4_79_2_189:4.6.2.7
	Kernel-5_35-4_79_2_188:4.6.2.7
	Kernel-5_35-4_79_2_187:4.6.2.7
	Kernel-5_35-4_79_2_186:4.6.2.7
	Kernel-5_35-4_79_2_185:4.6.2.7
	Kernel-5_35-4_79_2_184:4.6.2.7
	Kernel-5_35-4_79_2_183:4.6.2.7
	Kernel-5_35-4_79_2_182:4.6.2.7
	Kernel-5_35-4_79_2_181:4.6.2.7
	Kernel-5_35-4_79_2_180:4.6.2.7
	Kernel-5_35-4_79_2_179:4.6.2.7
	Kernel-5_35-4_79_2_178:4.6.2.7
	Kernel-5_35-4_79_2_177:4.6.2.7
	Kernel-5_35-4_79_2_176:4.6.2.7
	Kernel-5_35-4_79_2_175:4.6.2.7
	Kernel-5_35-4_79_2_174:4.6.2.7
	Kernel-5_35-4_79_2_173:4.6.2.7
	Kernel-5_35-4_79_2_172:4.6.2.7
	Kernel-5_35-4_79_2_171:4.6.2.7
	Kernel-5_35-4_79_2_170:4.6.2.7
	Kernel-5_35-4_79_2_169:4.6.2.7
	Kernel-5_35-4_79_2_168:4.6.2.7
	Kernel-5_35-4_79_2_167:4.6.2.7
	Kernel-5_35-4_79_2_166:4.6.2.7
	Kernel-5_35-4_79_2_165:4.6.2.7
	RPi_merge:4.6.2.6.2.1
	Kernel-5_35-4_79_2_147_2_23:4.6.2.6.2.1
	Kernel-5_35-4_79_2_147_2_22:4.6.2.6
	Kernel-5_35-4_79_2_147_2_21:4.6.2.6
	Kernel-5_35-4_79_2_147_2_20:4.6.2.6
	Kernel-5_35-4_79_2_147_2_19:4.6.2.6
	Kernel-5_35-4_79_2_147_2_18:4.6.2.6
	Kernel-5_35-4_79_2_164:4.6.2.7
	Kernel-5_35-4_79_2_163:4.6.2.7
	Kernel-5_35-4_79_2_147_2_17:4.6.2.6
	Kernel-5_35-4_79_2_147_2_16:4.6.2.6
	Kernel-5_35-4_79_2_147_2_15:4.6.2.6
	Kernel-5_35-4_79_2_162:4.6.2.7
	Kernel-5_35-4_79_2_161:4.6.2.7
	Kernel-5_35-4_79_2_147_2_14:4.6.2.6
	Kernel-5_35-4_79_2_147_2_13:4.6.2.6
	Kernel-5_35-4_79_2_160:4.6.2.7
	Kernel-5_35-4_79_2_159:4.6.2.7
	Kernel-5_35-4_79_2_158:4.6.2.7
	Kernel-5_35-4_79_2_157:4.6.2.7
	Kernel-5_35-4_79_2_156:4.6.2.7
	Kernel-5_35-4_79_2_147_2_12:4.6.2.6
	Kernel-5_35-4_79_2_147_2_11:4.6.2.6
	Kernel-5_35-4_79_2_155:4.6.2.7
	Kernel-5_35-4_79_2_147_2_10:4.6.2.6
	Kernel-5_35-4_79_2_154:4.6.2.7
	Kernel-5_35-4_79_2_153:4.6.2.7
	Kernel-5_35-4_79_2_147_2_9:4.6.2.6
	Kernel-5_35-4_79_2_152:4.6.2.7
	Kernel-5_35-4_79_2_151:4.6.2.7
	Kernel-5_35-4_79_2_147_2_8:4.6.2.6
	Kernel-5_35-4_79_2_147_2_7:4.6.2.6
	Kernel-5_35-4_79_2_150:4.6.2.6
	Kernel-5_35-4_79_2_147_2_6:4.6.2.6
	Kernel-5_35-4_79_2_147_2_5:4.6.2.6
	Kernel-5_35-4_79_2_149:4.6.2.6
	Kernel-5_35-4_79_2_147_2_4:4.6.2.6
	Kernel-5_35-4_79_2_147_2_3:4.6.2.6
	Kernel-5_35-4_79_2_148:4.6.2.6
	Kernel-5_35-4_79_2_147_2_2:4.6.2.6
	Kernel-5_35-4_79_2_147_2_1:4.6.2.6
	RPi:4.6.2.6.0.2
	RPi_bp:4.6.2.6
	Kernel-5_35-4_79_2_98_2_52_2_1:4.6.2.4.2.1
	alees_Kernel_dev:4.6.2.4.2.1.0.2
	alees_Kernel_dev_bp:4.6.2.4.2.1
	Kernel-5_35-4_79_2_147:4.6.2.6
	Kernel-5_35-4_79_2_146:4.6.2.6
	Kernel-5_35-4_79_2_145:4.6.2.6
	Kernel-5_35-4_79_2_144:4.6.2.6
	Kernel-5_35-4_79_2_143:4.6.2.6
	Kernel-5_35-4_79_2_142:4.6.2.6
	Kernel-5_35-4_79_2_141:4.6.2.6
	Kernel-5_35-4_79_2_140:4.6.2.6
	Kernel-5_35-4_79_2_139:4.6.2.6
	Kernel-5_35-4_79_2_138:4.6.2.6
	Kernel-5_35-4_79_2_137:4.6.2.6
	Kernel-5_35-4_79_2_136:4.6.2.6
	Kernel-5_35-4_79_2_135:4.6.2.6
	Kernel-5_35-4_79_2_134:4.6.2.6
	Kernel-5_35-4_79_2_133:4.6.2.6
	Kernel-5_35-4_79_2_132:4.6.2.6
	Kernel-5_35-4_79_2_131:4.6.2.6
	Kernel-5_35-4_79_2_130:4.6.2.6
	Kernel-5_35-4_79_2_129:4.6.2.6
	Kernel-5_35-4_79_2_128:4.6.2.6
	Kernel-5_35-4_79_2_127:4.6.2.6
	Kernel-5_35-4_79_2_126:4.6.2.6
	Kernel-5_35-4_79_2_125:4.6.2.6
	Kernel-5_35-4_79_2_124:4.6.2.6
	Kernel-5_35-4_79_2_123:4.6.2.5
	Cortex_merge:4.6.2.4.2.2
	Kernel-5_35-4_79_2_122:4.6.2.4
	Kernel-5_35-4_79_2_98_2_54:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_53:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_52:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_51:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_50:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_49:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_48:4.6.2.4.2.1
	Kernel-5_35-4_79_2_121:4.6.2.4
	Kernel-5_35-4_79_2_98_2_47:4.6.2.4
	Kernel-5_35-4_79_2_120:4.6.2.4
	Kernel-5_35-4_79_2_98_2_46:4.6.2.4
	Kernel-5_35-4_79_2_119:4.6.2.4
	Kernel-5_35-4_79_2_98_2_45:4.6.2.4
	Kernel-5_35-4_79_2_98_2_44:4.6.2.4
	Kernel-5_35-4_79_2_118:4.6.2.4
	Kernel-5_35-4_79_2_98_2_43:4.6.2.4
	Kernel-5_35-4_79_2_117:4.6.2.4
	Kernel-5_35-4_79_2_116:4.6.2.4
	Kernel-5_35-4_79_2_98_2_42:4.6.2.4
	Kernel-5_35-4_79_2_115:4.6.2.4
	Kernel-5_35-4_79_2_98_2_41:4.6.2.4
	Kernel-5_35-4_79_2_98_2_40:4.6.2.4
	Kernel-5_35-4_79_2_114:4.6.2.4
	Kernel-5_35-4_79_2_98_2_39:4.6.2.4
	Kernel-5_35-4_79_2_98_2_38:4.6.2.4
	Kernel-5_35-4_79_2_113:4.6.2.4
	Kernel-5_35-4_79_2_112:4.6.2.4
	Kernel-5_35-4_79_2_98_2_37:4.6.2.4
	Kernel-5_35-4_79_2_98_2_36:4.6.2.4
	Kernel-5_35-4_79_2_98_2_35:4.6.2.4
	Kernel-5_35-4_79_2_98_2_34:4.6.2.4
	Kernel-5_35-4_79_2_98_2_33:4.6.2.4
	Kernel-5_35-4_79_2_98_2_32:4.6.2.4
	Kernel-5_35-4_79_2_98_2_31:4.6.2.4
	Kernel-5_35-4_79_2_98_2_30:4.6.2.4
	Kernel-5_35-4_79_2_98_2_29:4.6.2.4
	Kernel-5_35-4_79_2_98_2_28:4.6.2.4
	Kernel-5_35-4_79_2_98_2_27:4.6.2.4
	Kernel-5_35-4_79_2_98_2_26:4.6.2.4
	Kernel-5_35-4_79_2_111:4.6.2.4
	Kernel-5_35-4_79_2_98_2_25:4.6.2.4
	Kernel-5_35-4_79_2_98_2_24:4.6.2.4
	Kernel-5_35-4_79_2_98_2_23:4.6.2.4
	Kernel-5_35-4_79_2_110:4.6.2.4
	Kernel-5_35-4_79_2_98_2_22:4.6.2.4
	Kernel-5_35-4_79_2_109:4.6.2.4
	Kernel-5_35-4_79_2_98_2_21:4.6.2.4
	Kernel-5_35-4_79_2_98_2_20:4.6.2.4
	Kernel-5_35-4_79_2_108:4.6.2.4
	Kernel-5_35-4_79_2_107:4.6.2.4
	Kernel-5_35-4_79_2_98_2_19:4.6.2.4
	Kernel-5_35-4_79_2_98_2_18:4.6.2.4
	Kernel-5_35-4_79_2_98_2_17:4.6.2.4
	Kernel-5_35-4_79_2_98_2_16:4.6.2.4
	Kernel-5_35-4_79_2_98_2_15:4.6.2.4
	Kernel-5_35-4_79_2_106:4.6.2.4
	Kernel-5_35-4_79_2_105:4.6.2.4
	Kernel-5_35-4_79_2_104:4.6.2.4
	Kernel-5_35-4_79_2_98_2_14:4.6.2.4
	Kernel-5_35-4_79_2_98_2_13:4.6.2.4
	Kernel-5_35-4_79_2_98_2_12:4.6.2.4
	Kernel-5_35-4_79_2_98_2_11:4.6.2.4
	Kernel-5_35-4_79_2_98_2_10:4.6.2.4
	Kernel-5_35-4_79_2_98_2_9:4.6.2.4
	Kernel-5_35-4_79_2_103:4.6.2.4
	Kernel-5_35-4_79_2_102:4.6.2.4
	Kernel-5_35-4_79_2_98_2_8:4.6.2.4
	Kernel-5_35-4_79_2_98_2_7:4.6.2.4
	Kernel-5_35-4_79_2_98_2_6:4.6.2.4
	Kernel-5_35-4_79_2_98_2_5:4.6.2.4
	Kernel-5_35-4_79_2_98_2_4:4.6.2.4
	Kernel-5_35-4_79_2_101:4.6.2.4
	Kernel-5_35-4_79_2_100:4.6.2.4
	Kernel-5_35-4_79_2_99:4.6.2.4
	Kernel-5_35-4_79_2_98_2_3:4.6.2.4
	Kernel-5_35-4_79_2_98_2_2:4.6.2.4
	Kernel-5_35-4_79_2_98_2_1:4.6.2.4
	Cortex:4.6.2.4.0.2
	Cortex_bp:4.6.2.4
	Kernel-5_35-4_79_2_98:4.6.2.4
	Kernel-5_35-4_79_2_97:4.6.2.4
	Kernel-5_35-4_79_2_96:4.6.2.4
	Kernel-5_35-4_79_2_95:4.6.2.4
	Kernel-5_35-4_79_2_94:4.6.2.4
	Kernel-5_35-4_79_2_93:4.6.2.4
	Kernel-5_35-4_79_2_92:4.6.2.4
	Kernel-5_35-4_79_2_91:4.6.2.4
	Kernel-5_35-4_79_2_90:4.6.2.4
	Kernel-5_35-4_79_2_89:4.6.2.4
	Kernel-5_35-4_79_2_88:4.6.2.4
	Kernel-5_35-4_79_2_87:4.6.2.4
	Kernel-5_35-4_79_2_86:4.6.2.4
	Kernel-5_35-4_79_2_85:4.6.2.4
	Kernel-5_35-4_79_2_84:4.6.2.4
	Kernel-5_35-4_79_2_83:4.6.2.4
	Kernel-5_35-4_79_2_82:4.6.2.4
	Kernel-5_35-4_79_2_81:4.6.2.4
	Kernel-5_35-4_79_2_80:4.6.2.4
	Kernel-5_35-4_79_2_79:4.6.2.4
	Kernel-5_35-4_79_2_78:4.6.2.4
	Kernel-5_35-4_79_2_77:4.6.2.4
	RO_5_07:4.6.2.4
	Kernel-5_35-4_79_2_76:4.6.2.4
	Kernel-5_35-4_79_2_75:4.6.2.4
	Kernel-5_35-4_79_2_74:4.6.2.4
	Kernel-5_35-4_79_2_73:4.6.2.4
	Kernel-5_35-4_79_2_72:4.6.2.4
	Kernel-5_35-4_79_2_71:4.6.2.4
	Kernel-5_35-4_79_2_70:4.6.2.4
	Kernel-5_35-4_79_2_69:4.6.2.4
	Kernel-5_35-4_79_2_68:4.6.2.4
	Kernel-5_35-4_79_2_67:4.6.2.4
	Kernel-5_35-4_79_2_66:4.6.2.4
	Kernel-5_35-4_79_2_65:4.6.2.4
	Kernel-5_35-4_79_2_64:4.6.2.4
	Kernel-5_35-4_79_2_63:4.6.2.4
	Kernel-5_35-4_79_2_62:4.6.2.4
	Kernel-5_35-4_79_2_61:4.6.2.4
	Kernel-5_35-4_79_2_59:4.6.2.4
	Kernel-5_35-4_79_2_58:4.6.2.4
	Kernel-5_35-4_79_2_57:4.6.2.4
	Kernel-5_35-4_79_2_56:4.6.2.4
	Kernel-5_35-4_79_2_55:4.6.2.4
	Kernel-5_35-4_79_2_54:4.6.2.4
	Kernel-5_35-4_79_2_53:4.6.2.4
	Kernel-5_35-4_79_2_52:4.6.2.4
	Kernel-5_35-4_79_2_51:4.6.2.4
	Kernel-5_35-4_79_2_50:4.6.2.3
	Kernel-5_35-4_79_2_49:4.6.2.3
	Kernel-5_35-4_79_2_48:4.6.2.3
	Kernel-5_47:4.6
	Kernel-5_46-4_90_2_1:4.6
	nbingham_Kernel_FastNC_dev_bp:4.6
	nbingham_Kernel_FastNC_dev:4.6.0.4
	Kernel-5_46:4.6
	Kernel-5_45:4.6
	Kernel-5_35-4_79_2_47:4.6.2.3
	Kernel-5_35-4_79_2_46:4.6.2.3
	Kernel-5_35-4_79_2_45:4.6.2.3
	Kernel-5_35-4_79_2_44:4.6.2.3
	Kernel-5_35-4_79_2_25_2_2:4.6.2.3
	Kernel-5_35-4_79_2_43:4.6.2.3
	Kernel-5_35-4_79_2_42:4.6.2.3
	Kernel-5_35-4_79_2_41:4.6.2.3
	Kernel-5_35-4_79_2_40:4.6.2.3
	Kernel-5_35-4_79_2_39:4.6.2.3
	Kernel-5_35-4_79_2_38:4.6.2.3
	Kernel-5_35-4_79_2_37:4.6.2.3
	Kernel-5_35-4_79_2_36:4.6.2.3
	Kernel-5_35-4_79_2_35:4.6.2.3
	Kernel-5_35-4_79_2_34:4.6.2.3
	Kernel-5_35-4_79_2_33:4.6.2.3
	Kernel-5_35-4_79_2_32:4.6.2.3
	Kernel-5_44:4.6
	Kernel-5_35-4_79_2_25_2_1:4.6.2.3
	Kernel-5_43:4.6
	Kernel-5_35-4_79_2_31:4.6.2.3
	Kernel-5_35-4_79_2_30:4.6.2.3
	Kernel-5_35-4_79_2_29:4.6.2.3
	Kernel-5_35-4_79_2_28:4.6.2.3
	Kernel-5_35-4_79_2_27:4.6.2.3
	Kernel-5_35-4_79_2_26:4.6.2.3
	Kernel-5_42:4.6
	Kernel-5_41:4.6
	Kernel-5_40:4.6
	Kernel-5_35-4_79_2_25:4.6.2.3
	Kernel-5_35-4_79_2_24:4.6.2.3
	Kernel-5_35-4_79_2_23:4.6.2.3
	Kernel-5_35-4_79_2_22:4.6.2.3
	Kernel-5_35-4_79_2_21:4.6.2.3
	Kernel-5_35-4_79_2_20:4.6.2.3
	Kernel-5_35-4_79_2_19:4.6.2.3
	Kernel-5_35-4_79_2_18:4.6.2.3
	Kernel-5_35-4_79_2_17:4.6.2.3
	Kernel-5_35-4_79_2_16:4.6.2.3
	Kernel-5_35-4_79_2_15:4.6.2.3
	Kernel-5_35-4_79_2_14:4.6.2.3
	Kernel-5_39:4.6
	Kernel-5_13-4_52_2_1:4.4
	Bethany:4.4.0.2
	Kernel-5_38:4.6
	Kernel-5_35-4_79_2_13:4.6.2.3
	Kernel-5_35-4_79_2_12:4.6.2.2
	Kernel-5_35-4_79_2_11:4.6.2.2
	Kernel-5_37:4.6
	Kernel-5_35-4_79_2_10:4.6.2.2
	Kernel-5_35-4_79_2_9:4.6.2.2
	Kernel-5_36:4.6
	Kernel-5_35-4_79_2_8:4.6.2.2
	Kernel-5_35-4_79_2_7:4.6.2.2
	Kernel-5_35-4_79_2_6:4.6.2.2
	Kernel-5_35-4_79_2_5:4.6.2.2
	Kernel-5_35-4_79_2_4:4.6.2.2
	Kernel-5_35-4_79_2_3:4.6.2.2
	Kernel-5_35-4_79_2_2:4.6.2.2
	dellis_autobuild_BaseSW:4.6
	Kernel-5_35-4_79_2_1:4.6.2.1
	HAL:4.6.0.2
	Kernel-5_35:4.6
	Kernel-5_34:4.6
	Kernel-5_33:4.6
	Kernel-5_32:4.6
	Kernel-5_31:4.5
	Kernel-5_30:4.5
	Kernel-5_29:4.5
	Kernel-5_28:4.5
	Kernel-5_27:4.5
	Kernel-5_26:4.5
	Kernel-5_25:4.5
	Kernel-5_24:4.5
	Kernel-5_23:4.5
	Kernel-5_22:4.4
	sbrodie_sedwards_16Mar2000:4.4
	Kernel-5_21:4.4
	Kernel-5_20:4.4
	Kernel-5_19:4.4
	Kernel-5_18:4.4
	Kernel-5_17:4.4
	Kernel-5_16:4.4
	Kernel-5_15:4.4
	Kernel-5_14:4.4
	Kernel-5_13:4.4
	Kernel-5_12:4.4
	Kernel-5_11:4.4
	Kernel-5_10:4.4
	Kernel-5_09:4.4
	Kernel-5_08:4.4
	Kernel-5_07:4.4
	Kernel-5_06:4.4
	Kernel-5_05:4.4
	Kernel-5_04:4.4
	Kernel-5_03:4.4
	Kernel-5_02:4.4
	Kernel-5_01:4.4
	Kernel-5_00:4.4
	Kernel-4_99:4.4
	Kernel-4_98:4.4
	Kernel-4_97:4.4
	Kernel-4_96:4.4
	Kernel-4_95:4.4
	Kernel-4_94:4.4
	Kernel-4_93:4.4
	Kernel-4_92:4.4
	Kernel-4_91:4.4
	Kernel-4_90:4.4
	dcotton_autobuild_BaseSW:4.6
	Kernel-4_89:4.4
	Kernel-4_88:4.4
	Kernel-4_87:4.4
	Kernel-4_86:4.4
	Kernel-4_85:4.4
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.4
	Kernel-4_84:4.4
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.4
	Ursula_RiscPC_bp:4.1.4.4
	Kernel-4_83:4.3
	Kernel-4_82:4.3
	Kernel-4_81:4.3
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.4
	Ursula_RiscPC:4.1.4.4.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.2
	Ursula_merge:4.1.4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.4
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.4
	UrsulaBuild_FinalSoftload:4.1.4.4
	rthornb_UrsulaBuild-12Aug1998:4.1.4.4
	aglover_UrsulaBuild-05Aug1998:4.1.4.4
	rthornb_UrsulaBuild-29Jul1998:4.1.4.4
	rthornb_UrsulaBuild-22Jul1998:4.1.4.4
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.4
	rthornb_UrsulaBuild-07Jul1998:4.1.4.4
	rthornb_UrsulaBuild-17Jun1998:4.1.4.4
	rthornb_UrsulaBuild-03Jun1998:4.1.4.4
	rthornb_UrsulaBuild-27May1998:4.1.4.4
	mstphens_Kernel-3_80:4.1.4.4
	rthornb_UrsulaBuild-21May1998:4.1.4.4
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.4
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.11
date	2018.11.07.22.28.10;	author jlee;	state Exp;
branches;
next	4.10;
commitid	Ub9LVqEF46x8X3ZA;

4.10
date	2016.07.24.10.50.44;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	x4yCuRzf90zVXyfz;

4.9
date	2016.06.30.20.59.46;	author jlee;	state Exp;
branches;
next	4.8;
commitid	skOEjp3ipLHx6xcz;

4.8
date	2016.06.30.20.28.56;	author jlee;	state Exp;
branches;
next	4.7;
commitid	lMnWzoE9eJz3Wwcz;

4.7
date	2016.06.30.20.08.09;	author jlee;	state Exp;
branches;
next	4.6;
commitid	IWoXxARWeuLDOwcz;

4.6
date	2000.08.18.09.31.45;	author sbrodie;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2000.04.04.14.27.34;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.08.19.10.52.37;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.08.03.09.59.12;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.10.01.07.42.53;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.26;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2000.10.02.08.52.20;	author kbracey;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2000.11.10.15.51.35;	author kbracey;	state Exp;
branches;
next	4.6.2.4;

4.6.2.4
date	2002.11.30.00.31.10;	author bavison;	state Exp;
branches
	4.6.2.4.2.1;
next	4.6.2.5;

4.6.2.5
date	2011.11.26.21.11.17;	author jlee;	state Exp;
branches;
next	4.6.2.6;
commitid	cI3W0zbtALQG6TIv;

4.6.2.6
date	2011.11.27.11.48.11;	author rsprowson;	state Exp;
branches
	4.6.2.6.2.1;
next	4.6.2.7;
commitid	OFgqaKhOb6swXXIv;

4.6.2.7
date	2012.05.26.09.00.29;	author rsprowson;	state Exp;
branches;
next	4.6.2.8;
commitid	EMsCe1GQBPXgdd6w;

4.6.2.8
date	2014.04.06.19.23.25;	author jlee;	state Exp;
branches;
next	;
commitid	EtypGk33aKVRNEvx;

4.6.2.4.2.1
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	4.6.2.4.2.2;
commitid	D7rzILnwRRSXoLuv;

4.6.2.4.2.2
date	2011.09.24.19.55.54;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.6.2.6.2.1
date	2012.09.18.15.50.03;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.1.1.1
date	96.11.05.09.41.26;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.01.27;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.05.23.13.06.59;	author kbracey;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.09.09.13.33.38;	author mstphens;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.12.08.14.34.45;	author mstphens;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.03.26.11.26.07;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.59;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.03;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.11
log
@Attempt to tidy up substitute screen mode selection logic
Detail:
  Over the years the OS's substitute screen mode selection logic has grown to be a tangled mess, and the logic it does implement isn't always very useful. Additionally, the kernel is structured in such a way that it can be hard for modules to override it.
  This set of changes aims to fix the many of the problems, by doing the following:
  - Moving all substitute mode selection logic out of the core VDU driver code and into a Service_ModeTranslation handler. This means you now only have one place in the kernel to look instead of several, and modules can override the behaviour by claiming/blocking the service call as appropriate.
  - Moving handling of the built-in VIDC lists out of the core VDU driver code and into a Service_ModeExtension handler. This means programs can now inspect these VIDC lists by issuing the right service call (although you are essentially limited to lists which the GraphicsV driver is OK with)
  - Moving *TV interlace & offset adjustment logic into the Service_ModeExtension handler, since they're legacy things which can be handled more cleanly for MDF/EDID (and the old code was poking memory the kernel didn't own)
  - Adding a Service_EnumerateScreenModes implementation, so that if you end up in the desktop with ScreenModes non-functional, the display manager at least has something useful to show you
  - Enhancing the handling of the built-in numbered modes so that they are now available in any colour depth; the Service_ModeExtension handler (and related handlers) treat the builtin VIDC lists as a set of mode timings, not a discrete set of modes
  - Substitute mode selection logic is a complete re-write. Instead of trying a handful of numbered fallback modes, it now tries:
    - Same mode but at higher colour depths
    - Same mode but at lower colour depths
    - Alternate resolutions (half-width mode with no double-pixel if original request was for double-pixel, and default resolution for monitor type)
  - Combined with the logic to allow the builtin VIDC lists to be used at any colour depth, this means that the kernel should now be able to find substitute modes for machines which lack support for <=8bpp modes (e.g. OMAP5)
  - Additionally the mode substitution code will attempt to retain as many properties of the originally requested mode as possible (eigen values, gap mode type, etc.)
  Other improvements:
  - The kernel now actually vets the builtin VIDC lists instead of assuming that they'll work (which also means they'll have the correct ExtraBytes value, where applicable)
  - The kernel now uses GraphicsV 19 (VetMode2) to vet the mode during the mode switch process, using the result to detect where the framebuffer will be placed. This allows for GraphicsV drivers to switch between DA 2 and external framestores on a per-mode basis.
  - The kernel now supports mode selectors which specify LineLength values which are larger than necessary; this will get translated to a suitable ExtraBytes control list item (+ combined with whatever padding the driver indicates is necessary via the VetMode2 result)
  File changes:
  - hdr/KernelWS - Reserve space for a VIDC list, since the Service_ModeExtension implementation typically can't use the built-in list as-is
  - s/Arthur3 - Issue Service_ModeFileChanged when the configured monitor type is changed, so that DisplayManager + friends are aware that the set of available modes has changed
  - s/GetAll - Fiddle with GETs a bit
  - s/MemMap2 - Extra LTORG
  - s/NewIRQs - Small routine to install/uninstall false VSync routine (previously from PushModeInfo, which wasn't really the appropriate place for it)
  - s/Utility - Hook up the extra service call handlers
  - s/vdu/legacymodes - New file containing the new service call implementations, and some related code
  - s/vdu/vdudecl - Move mode workspace definition here, from vdumodes
  - s/vdu/vdudriver - Remove assorted bits of mode substitution code. Plug in new bits for calling GraphicsV 19 during mode set, and deal with ExtraBytes/LineLength during PushModeInfo
  - s/vdu/vdumodes - Move some workspace definitions to s/vdu/vdudecl. Tweak how the builtin VIDC lists are stored.
  - s/vdu/vduswis - Rip out more mode substitution code. Issue Service_ModeFileChanged when monitor type is changed by OS_ScreenMode.
Admin:
  Tested on Raspberry Pi 3, Iyonix, IGEPv5


Version 6.14. Tagged as 'Kernel-6_14'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL  => Utility

; *****************************************************************************
; Arthur Utility commands

SysModules_Info ROUT     ; start of ROM modules chain
        &       EndOfKernel-SysModules_Info

UtilityMod
        &       StartSuper-UtilityMod
        &       0                               ; no initialisation
        &       Util_Die-UtilityMod
        &       Util_Service-UtilityMod         ; code to register printer buffer with Buffer manager
        &       UtilModTitle-UtilityMod
        &       UtilHelpStr-UtilityMod
        &       UtilHelpTab-UtilityMod
        &       &F00000
        &       Util_SWI-UtilityMod
        &       Util_SWITab-UtilityMod
        &       0
 [ International_Help <> 0
        &       MessageFileName-UtilityMod
 |
        &       0
 ]
        &       UtilFlags-UtilityMod

Util_SWITab
        =       "ARM",0
        =       "IMB",0
        =       "IMBRange",0
        =       0
        ALIGN

Module_BaseAddr SETA UtilityMod

  [ ChocolateService
    ;service table
    ;
        ASSERT Service_ModeExtension < Service_ModeTranslation
        ASSERT Service_ModeTranslation < Service_MessageFileClosed
        ASSERT Service_MessageFileClosed < Service_BufferStarting
        ASSERT Service_BufferStarting    < Service_TerritoryStarted
        ASSERT Service_TerritoryStarted  < Service_DeviceFSCloseRequest
        ASSERT Service_DeviceFSCloseRequest < Service_EnumerateScreenModes
        ASSERT Service_EnumerateScreenModes < Service_DisplayStatus
    ;

Util_ChocServTab
        DCD    0                            ;flags word
        DCD    Util_ChocService-UtilityMod  ;offset to handler
        DCD    Service_ModeExtension
        DCD    Service_ModeTranslation
   [ CacheCommonErrors
        DCD    Service_MessageFileClosed
   ]
        DCD    Service_BufferStarting       ;service 1
   [ CacheCommonErrors
        DCD    Service_TerritoryStarted
   ]
        DCD    Service_DeviceFSCloseRequest ;service 2
        DCD    Service_EnumerateScreenModes
        DCD    Service_DisplayStatus
        DCD    0                            ;terminator
        DCD    Util_ChocServTab-UtilityMod  ;table anchor
  ]
Util_Service ROUT
  [ ChocolateService
        MOV     r0, r0   ;magic instruction for new service table format
  ]
        TEQ     r1, #Service_ModeExtension
        TEQNE   r1, #Service_ModeTranslation
        TEQNE   r1, #Service_BufferStarting
        TEQNE   r1, #Service_DeviceFSCloseRequest
  [ CacheCommonErrors
        TEQNE   r1, #Service_TerritoryStarted
        TEQNE   r1, #Service_MessageFileClosed
  ]
        TEQNE   r1, #Service_EnumerateScreenModes
        TEQNE   r1, #Service_DisplayStatus
        MOVNE   pc, lr
  [ ChocolateService
    ;entry point excluding pre-rejection code
Util_ChocService
  ]
  [ CacheCommonErrors
        TEQ     r1, #Service_TerritoryStarted
        TEQNE   r1, #Service_MessageFileClosed
        BEQ     CacheCommonErrorsReinit
  ]
        TEQ     r1, #Service_DeviceFSCloseRequest
        BEQ     %FT10
        TEQ     r1, #Service_ModeExtension
        BEQ     HandleServiceModeExtension
        TEQ     r1, #Service_ModeTranslation
        BEQ     HandleServiceModeTranslation
        TEQ     r1, #Service_EnumerateScreenModes
        BEQ     HandleServiceEnumerateScreenModes
        TEQ     r1, #Service_DisplayStatus
        BEQ     HandleServiceDisplayStatus
        ; Else must be Service_BufferStarting
        Push    "r0-r3,lr"

; Register buffers with buffer manager in order of speed - first is fast

        MOV     r0, #BufferFlags_GenerateInputFull
        LDR     r1, =MouseBuff
        LDR     r2, =MouseBuff + MouseBuffSize
        MOV     r3, #Buff_Mouse
        SWI     XBuffer_Register                ; register mouse input buffer
        MOV     r0, #BufferFlags_GenerateInputFull :OR: BufferFlags_SendThresholdUpCalls
        LDR     r1, =RS423InBuff
        LDR     r2, =RS423InBuff + RS423InBuffSize
        MOV     r3, #Buff_RS423In
        SWI     XBuffer_Register                ; register serial input buffer

        MOV     r0, #BufferFlags_GenerateOutputEmpty
        LDR     r1, =RS423OutBuff
        LDR     r2, =RS423OutBuff + RS423OutBuffSize
        MOV     r3, #Buff_RS423Out
        SWI     XBuffer_Register                ; register serial output buffer

        LDR     r0, =ZeroPage                   ; used as index to PrinterBufferThing
        LDR     r1, [r0, #PrinterBufferAddr]    ; r1 -> start of buffer
        LDR     r2, [r0, #PrinterBufferSize]    ; r2 = size
        ADD     r2, r2, r1                      ; r2 -> end+1 of buffer
        MOV     r3, #Buff_Print
        MOV     r0, #BufferFlags_GenerateOutputEmpty
        SWI     XBuffer_Register                ; register the MOS's printer buffer

        Pull    "r0-r3,pc"

; service DeviceFSCloseRequest
; in:   r2 = handle we are requested to close
;       if r2 = PrinterActive (word) or SerialInHandle (byte) or SerialOutHandle (byte)
;       then zero appropriate variable and close file, then claim service
;       NB there is a disadvantage to doing it for SerialInHandle, in that it won't get
;       opened again, but we assume they accidentally left it in an fx2,2 state
;

10
        Push    "r0,r1,lr"
        LDR     lr, =ZeroPage
        MOV     r0, #0
        LDR     r1, [lr, #OsbyteVars + :INDEX: PrinterActive]
        TEQ     r1, r2
        STREQ   r0, [lr, #OsbyteVars + :INDEX: PrinterActive]
        BEQ     %FT20
        LDRB    r1, [lr, #OsbyteVars + :INDEX: SerialInHandle]
        TEQ     r1, r2
        STREQB  r0, [lr, #OsbyteVars + :INDEX: SerialInHandle]
        BEQ     %FT20
        LDRB    r1, [lr, #OsbyteVars + :INDEX: SerialOutHandle]
        TEQ     r1, r2
        Pull    "r0,r1,pc",NE                   ; if not any of these then exit preserving everything
        STRB    r0, [lr, #OsbyteVars + :INDEX: SerialOutHandle]
20
        SWI     XOS_Find                        ; close file, ignore errors (if we get an error it's closed anyway)
        LDR     r0, [sp], #8                    ; restore r0, junk r1
        MOV     r1, #Service_Serviced           ; indicate we closed it
        LDR     pc, [sp], #4                    ; exit


Util_Die   ROUT
           CMP   R10, #0
           MOVEQ PC, lr      ; non-fatal : can cope
           ADR   R0, %FT01
 [ International
           Push  "lr"
           BL    TranslateError
           Pull  "pc"
 |
           RETURNVS
 ]

01
           &     ErrorNumber_CantKill
 [ International
           =    "CantKill", 0
 |
           =    "Deleting the utility module is foolish", 0
 ]


UtilModTitle =  "UtilityModule", 0

UtilHelpStr  =  "MOS Utilities", 9, "$VersionNo", 0

  [ Oscli_HashedCommands
;
;***WARNING*** if commands are added or changed, UtilHashedCmdTab MUST be updated correspondingly
;
  ]
UtilHelpTab
           Command   Break,              0,  0, International_Help   ; just help
           Command   Cache,              1,  0, International_Help
           Command   ChangeDynamicArea,255,  0, International_Help
           Command   Configure,        255,  0, Help_Is_Code_Flag :OR: International_Help
           Command   Commands,           0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   Echo,             255,  0, International_Help
           Command   Error,            255,  1, International_Help
           Command   Eval,             255,  1, International_Help
           Command   FileCommands,       0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   GOS,                0,  0, International_Help
           Command   IF,               255,  2, International_Help
           Command   Ignore,             1,  0, International_Help
           Command   Modules,            0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   PowerOn,            0,  0, International_Help   ; just help
           Command   Reset,              0,  0, International_Help   ; just help
           Command   RMClear,            0,  0, International_Help
           Command   RMEnsure,         255,  2, International_Help
           Command   RMFaster,           1,  1, International_Help
           Command   RMInsert,           2,  1, International_Help
           Command   RMKill,             1,  1, International_Help
           Command   RMLoad,           255,  1, International_Help
           Command   RMReInit,         255,  1, International_Help
           Command   RMRun,            255,  1, International_Help
           Command   RMTidy,             0,  0, International_Help
           Command   ROMModules,         0,  0, International_Help
           Command   Set,              255,  2, International_Help
           Command   SetEval,          255,  2, International_Help
           Command   SetMacro,         255,  2, International_Help
           Command   Show,               1,  0, International_Help   ; *show = *show *
           Command   Status,           255,  0, International_Help
           Command   Syntax,             0,  0, International_Help
           Command   Time,               0,  0, International_Help
           Command   Unplug,             2,  0, International_Help
           Command   Unset,              1,  1, International_Help
           =   0

  [ Oscli_HashedCommands
;
; - Hashing table is 32 wide
; - Hashing function is:
;
;      hash = (sum of all chars of command, each upper-cased) & 0x1f
;
; - Order of commands in each hashed list is chosen as 'most common' first

; Table MUST be reorganised if hashing function changed, or command set altered
;
           ALIGN
UtilHashedCmdTab
;
;    ! 0,"UtilHashedCmdTab  at ":CC::STR:(UtilHashedCmdTab)
;
;First, 1 word per table entry, giving offset to hashed list on each hash value
;
           DCD       0                        ;null list on this hash value
           DCD       UHC_hash01 - UtilityMod
           DCD       UHC_hash02 - UtilityMod
           DCD       0
           DCD       UHC_hash04 - UtilityMod
           DCD       0
           DCD       UHC_hash06 - UtilityMod
           DCD       UHC_hash07 - UtilityMod
           DCD       UHC_hash08 - UtilityMod
           DCD       UHC_hash09 - UtilityMod
           DCD       UHC_hash0A - UtilityMod
           DCD       UHC_hash0B - UtilityMod
           DCD       UHC_hash0C - UtilityMod
           DCD       0
           DCD       0
           DCD       UHC_hash0F - UtilityMod
           DCD       0
           DCD       UHC_hash11 - UtilityMod
           DCD       0
           DCD       0
           DCD       UHC_hash14 - UtilityMod
           DCD       0
           DCD       0
           DCD       0
           DCD       0
           DCD       UHC_hash19 - UtilityMod
           DCD       0
           DCD       UHC_hash1B - UtilityMod
           DCD       0
           DCD       0
           DCD       UHC_hash1E - UtilityMod
           DCD       UHC_hash1F - UtilityMod
;
; Now the hashed lists
;
UHC_hash01
           Command   Show,               1,  0, International_Help
           =   0
           ALIGN
UHC_hash02
           Command   Configure,        255,  0, Help_Is_Code_Flag :OR: International_Help
           =   0
           ALIGN
UHC_hash04
           Command   ChangeDynamicArea,255,  0, International_Help
           Command   RMFaster,           1,  1, International_Help
           Command   Status,           255,  0, International_Help
           Command   Ignore,             1,  0, International_Help
           =   0
           ALIGN
UHC_hash06
           Command   RMClear,            0,  0, International_Help
           =   0
           ALIGN
UHC_hash07
           Command   ROMModules,         0,  0, International_Help
           =   0
           ALIGN
UHC_hash08
           Command   Eval,             255,  1, International_Help
           =   0
           ALIGN
UHC_hash09
           Command   GOS,                0,  0, International_Help
           =   0
           ALIGN
UHC_hash0A
           Command   RMReInit,         255,  1, International_Help
           Command   Error,            255,  1, International_Help
           =   0
           ALIGN
UHC_hash0B
           Command   RMKill,             1,  1, International_Help
           =   0
           ALIGN
UHC_hash0C
           Command   Set,              255,  2, International_Help
           =   0
           ALIGN
UHC_hash0F
           Command   IF,               255,  2, International_Help
           Command   Unset,              1,  1, International_Help
           Command   Time,               0,  0, International_Help
           =   0
           ALIGN
UHC_hash11
           Command   RMEnsure,         255,  2, International_Help
           =   0
           ALIGN
UHC_hash14
           Command   SetEval,          255,  2, International_Help
           Command   RMRun,            255,  1, International_Help
           Command   RMInsert,           2,  1, International_Help
           Command   Cache,              1,  0, International_Help
           =   0
           ALIGN
UHC_hash19
           Command   Modules,            0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   RMTidy,             0,  0, International_Help
           =   0
           ALIGN
UHC_hash1B
           Command   Unplug,             2,  0, International_Help
           =   0
           ALIGN
UHC_hash1E
           Command   SetMacro,         255,  2, International_Help
           =   0
           ALIGN
UHC_hash1F
           Command   RMLoad,           255,  1, International_Help
           Command   Echo,             255,  0, International_Help
           =   0
           ALIGN

  ] ;Oscli_HashedCommands

Configure_Syntax     * Module_BaseAddr
Commands_Code        * Module_BaseAddr
Commands_Syntax      * Module_BaseAddr
Syntax_Code          * Module_BaseAddr
Syntax_Syntax        * Module_BaseAddr
Echo_Syntax          * Module_BaseAddr
Status_Syntax        * Module_BaseAddr
FileCommands_Code    * Module_BaseAddr
FileCommands_Syntax  * Module_BaseAddr
Reset_Code           * Module_BaseAddr
Reset_Syntax         * Module_BaseAddr
Break_Code           * Module_BaseAddr
Break_Syntax         * Module_BaseAddr
PowerOn_Code         * Module_BaseAddr
PowerOn_Syntax       * Module_BaseAddr

RMFaster_Code
           Push "lr"
           MOV R1, R0
           MOV R0, #ModHandReason_LookupName
           SWI XOS_Module
           Pull "PC", VS
           CMP   R3, #ROM                 ; HS if R3 >= ROM
           BLO   RMFast_notinROM
 [ :LNOT:ROMatTop
           CMP   R3, #ROMLimit
           BHS   RMFast_notinROM
 ]
           MOV   R1, R3
           LDR   R2, [R1, #-4]
           MOV   R0, #ModHandReason_CopyArea
           SWI   XOS_Module
           Pull  PC

RMFast_notinROM
           ADRL R0, ErrorBlock_RMNotFoundInROM
         [ International
           BL   TranslateError
         ]
           Pull lr
           RETURNVS

RMKill_Code
           MOV R6, #ModHandReason_Delete

Rmcommon   Push "lr"
           MOV r1, r0
           MOV r0, r6
           SWI   XOS_Module
           Pull "PC"

RMLoad_Code
           MOV R6, #ModHandReason_Load
           B   Rmcommon

RMRun_Code
           MOV R6, #ModHandReason_Run
           B   Rmcommon

RMTidy_Code
           MOV R6, #ModHandReason_Tidy
           B   Rmcommon

RMClear_Code
           MOV R6, #ModHandReason_Clear
           B   Rmcommon

RMReInit_Code
           MOV R6, #ModHandReason_ReInit
           B   Rmcommon

Modules_Help   ROUT
          Push  "r2, r3, lr"
          LDR   r2, =ZeroPage                      ; Try our own message file before Global.
          LDR   r0, [r2, #KernelMessagesBlock]
          TEQ   r0, #0
          ADDNE r0, r2, #KernelMessagesBlock+4
          ADRL  r1, modules_help1
        [ ZeroPage <> 0
          MOV   r2, #0
        ]
          SWI   XMessageTrans_Lookup
          SWIVC XMessageTrans_Dictionary
          MOVVC r1, r0
          MOVVC r0, r2
          SWIVC XOS_PrettyPrint
          Pull  "r2, r3, PC", VS
          LDR    R1, =ZeroPage+Module_List
03        LDR    R1, [R1]
          CMP    R1, #0
          BEQ    %FT05
          LDR    R0, [R1, #Module_code_pointer]
          BL     PrintTitle
          BVC    %BT03
05        MOVVC  R0, #0
          Pull  "r2, r3, PC"

PrintTitle ; of module at R0 : corrupts R0
        Push  "R1, lr"
        LDR    R1, [R0, #Module_HelpStr]
        CMP    R1, #0
        ADREQ  R0, NoRIT
      [ International
        BLEQ   Write0_Translated
        ADDNE  R0, R1, R0
        SWINE  XOS_PrettyPrint
      |
        ADDNE  R0, R1, R0
        SWI    XOS_PrettyPrint
      ]
        SWIVC  XOS_NewLine
        Pull  "R1, PC"

Modules_Code ROUT
        Push   "R7, lr"

      [ International
        BL     WriteS_Translated
        =      "Modules:No. Position Workspace Name", 10, 13, 0
        ALIGN
      |
        SWI     XOS_WriteS
        =      "No. Position Workspace Name", 10, 13, 0
        ALIGN
      ]
        Pull   "R7, PC", VS

        MOV     R1, #0
        MOV     R2, #0
        MOV     R6, #0
        MOV     R7, #0
06
        SWI     XOS_ReadEscapeState
        Pull    "R7, lr", CS
        BCS     AckEscape
        MOV     R0, #ModHandReason_GetNames
        SWI     XOS_Module
        BVC     %FT07
        CLRV
        Pull   "R7, pc"              ; back, clearing V

07
        Push   "R1, R2"
        CMP     R6, #0
        MOVNE   R1, #0
        BNE     %FT02
        ADD     R7, R7, #1
        MOV     R0, R7
        LDR     R1, =GeneralMOSBuffer
        MOV     R2, #256
        SWI     XOS_ConvertCardinal2
        SUB     R1, R1, R0          ; characters in buffer
02      CMP     R1, #3
        SWILT   XOS_WriteI+" "
        BVS     %FT03
        ADDLT   R1, R1, #1
        BLT     %BT02
03
        Pull   "R1, R2"
        BVS     %FT04
        CMP     R6, #0
        SWIEQ   XOS_Write0
        SWIVC   XOS_WriteI+" "
        MOV     R0, R3
        BLVC    HexR0LongWord
        SWIVC   XOS_WriteI+" "
        MOV     R0, R4
        BLVC    HexR0LongWord
        SWIVC   XOS_WriteI+" "
        SWIVC   XOS_WriteI+" "
        BLVC    %FT01         ; title out
        SWIVC   XOS_NewLine
        BVC     %BT06
04
        Pull   "R7, PC"
01
        Push   "lr"
        LDR     R0, [R3, #Module_TitleStr]
        CMP     R0, #0
        ADDNE   R0, R3, R0
        ADREQ   R0, NoRIT
      [ International
        BLEQ    Write0_Translated
        SWINE   XOS_Write0
      |
        SWI     XOS_Write0
      ]
        Pull   "PC", VS
        CMP     R6, #0
        CMPEQ   R2, #0
        MOV     R6, R2
        Pull   "PC", EQ       ; only one incarnation
        SWI     XOS_WriteI + Postfix_Separator
        MOV     R0, R5
        SWIVC   XOS_Write0
        Pull   "PC"

      [ International
NoRIT   =   "Untitled:<Untitled>", 0
      |
NoRIT   =   "<Untitled>", 0
      ]
starstr =   "*", 13
        ALIGN



Show_Code
        CMP     r1, #0                  ; *show only?
        ADREQ   r0, starstr
        Entry   "r0,r7",8+256
        MRS     r7, CPSR

        ADD     r6, sp, #8              ; initial buffer for var expansions
        MOV     lr, #256+4
        STR     lr, [sp, #4]            ; fake heap block size
        MOV     lr, #&ffffffff
        STR     lr, [sp, #0]            ; inhibit page mode off on exit

        ; Read current VDU status and save it away
        MOVVC   r0, #117
        SWIVC   XOS_Byte
        STRVC   R1, [sp, #0]
        SWIVC   XOS_WriteI+14           ; paged mode on.
        BVS     ShowBang

        MOV     r3, #0          ; enumeration pointer
01
        LDR     r0, [sp, #Proc_RegOffset + 0*4]        ; wildcard
10
        MOV     r1, r6          ; 'heap' block
        LDR     r2, [r6, #-4]   ; block size
        SUB     r2, r2, #4
        MOV     r4, #0          ; no expansion
        SWI     XOS_ReadVarVal
        BVS     Show_ErrorReading

        ; Varname
        MOV     r0, r3
        SWI     XOS_Write0
        BVS     ShowBang

        ; (Number) or (Macro) as appropriate
        CMP     R4, #VarType_String
        BEQ     skipvalprt
      [ :LNOT: International
        SWI     XOS_WriteS
        =       " (", 0
        ALIGN
        BVS     ShowBang
      ]
        CMP     R4, #VarType_Number
        MOVEQ   R2, #256
        LDREQ   R0, [R1]
        SWIEQ   XOS_BinaryToDecimal
        ADREQ   R0, %FT02
        ADRHI   R0, %FT03
      [ International
        BLVC    Write0_Translated
      |
        SWIVC   XOS_Write0
        SWIVC   XOS_WriteI+")"
      ]
        BVS     ShowBang
skipvalprt
        ; " : "
        SWI     XOS_WriteS
        =       " : ", 0
        ALIGN
        BVS     ShowBang

        ; Now output the value's value
        MOV     R5, #-1
05      ADD     R5, R5, #1
        CMP     R5, R2
        BEQ     %FT06
        SWI     XOS_ReadEscapeState
        BLCS    AckEscape
        BVS     ShowBang
        LDRB    R0, [R1, R5]
        CMP     R0, #&7F
        MOVEQ   R0, #"?"-"@@"
        CMP     R0, #31
        ADDLE   R0, R0, #"@@"
        SWILE   XOS_WriteI+"|"
        BVS     ShowBang

        CMP     R0, #"|"
        CMPNE   R0, #""""
        CMPNE   R0, #"<"
        SWINE   XOS_WriteC
        BVS     ShowBang
        BNE     %BT05

        CMP     R4, #VarType_Macro
        SWINE   XOS_WriteI+"|"
        SWIVC   XOS_WriteC
        BVC     %BT05
ShowBang
        STR     r0, [sp, #Proc_RegOffset + 0*4]
        ORR     r7, r7, #V_bit                          ; CPSR in

Show_Exit
        ; Release buffer if necessary
        ADD     lr, sp, #8              ; stack buffer
        TEQ     r6, lr
        MOVNE   r0, #ModHandReason_Free
        MOVNE   r2, r6
        SWINE   XOS_Module

        ; Switch paged mode off if necessary
        LDR     lr, [sp, #0]
        TST     lr, #5
        SWIEQ   XOS_WriteI+15  ; paged mode off

        MSR     CPSR_f, r7
        EXIT

06      SWI     XOS_NewLine
        BVS     ShowBang
        B       %BT01

      [ International
02
        =       "Number:(Number)", 0
03
        =       "Macro:(Macro)", 0
      |
02
        =       "Number", 0
03
        =       "Macro", 0
      ]
        ALIGN

Show_ErrorReading
        ; Error from OS_ReadVarVal:
        ; VarCantFind - end of *show
        ; BuffOverflow - try and extend buffer
        ; other - return as error
        LDR     r5, [r0]
        LDR     lr, =ErrorNumber_VarCantFind
        TEQ     r5, lr
        BEQ     Show_Exit
        LDR     lr, =ErrorNumber_BuffOverflow
        TEQ     r5, lr
        BNE     ShowBang

        ; try and extend the buffer
        CLRV
        MOV     r1, r3                  ; actual name so retry gets this node exactly
        ADD     lr, sp, #8              ; stack buffer
        TEQ     r6, lr
        MOV     r0, #ModHandReason_Free
        MOV     r2, r6
        MOV     r6, lr                  ; to prevent any attempt at freeing in ShowBang
        SWINE   XOS_Module
        BVS     ShowBang

        MOV     r0, r1
        MOV     r1, #ARM_CC_Mask
        MOV     r2, #-1                 ; To sence size
        MOV     r3, #0                  ; 1st var
        MOV     r4, #0                  ; unexpanded
        SWI     XOS_ReadVarVal
        CLRV                            ; error will be buffer overflow
        MOV     r1, r3                  ; varname again
        MVN     r3, r2
        ADD     r3, r3, #&ff            ; round up to 256 byte boundary
        BIC     r3, r3, #&ff
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        BVS     ShowBang
        MOV     r6, r2
        MOV     r0, r1
        MOV     r3, #0                  ; restart from that node
        B       %BT10

Set_Code ROUT
        MOV    R4, #VarType_String
01
        Push  "lr"

        ; space terminated name in R0

        ; Skip name in R1
        MOV    R1, R0
02      LDRB   R2, [R1], #1
        CMP    R2, #" "
        BNE    %BT02

        ; Then skip spaces
03      LDRB   R2, [R1], #1
        CMP    R2, #" "
        BEQ    %BT03
        SUB    R1, R1, #1

        ; r2 +ve to set, r3 = 0 for 1st var
        MOV    R2, #1
        MOV    R3, #0
        SWI    XOS_SetVarVal
        Pull  "PC"

        LTORG

SetMacro_Code MOV    R4, #VarType_Macro
        B  %BT01

SetEval_Code MOV    R4, #VarType_Expanded
        B  %BT01

Unset_Code ROUT
        Push  "lr"
        MOV    R2, #-1
        MOV    R3, #0
01      SWI    XOS_SetVarVal
        BVC    %BT01
        CLRV
        Pull  "pc"

Echo_Code ROUT
        Push  "lr"
        MOV    R2, #GS_NoQuoteMess
        SWI    XOS_GSInit
01      SWI    XOS_GSRead
        BVS    %FT02
        MOVCC  R3, R0
        MOVCC  R0, R1
        SWICC  XOS_WriteC
        BVS    %FT02
        MOVCC  R0, R3
        BCC    %BT01
        SWI    XOS_NewLine
02
        Pull  "PC"

Commands_Help  ROUT
        Push  "R0, lr"         ; keep buffer pointer
        ADRL   R0, commands_helpstr
        MOV    R1, #0
KeyHelpCommon                  ; also used by *Configure
        Push   r1
; R2 & R3 can be junked here?
        MOV    r1, r0
        LDR    r2, =ZeroPage   ; Try our own message file before Global.
        LDR    r0, [r2, #KernelMessagesBlock]
        TEQ    r0, #0
        ADDNE  r0, r2, #KernelMessagesBlock+4
      [ ZeroPage <> 0
        MOV    r2, #0
      ]
        SWI    XMessageTrans_Lookup
        SWIVC  XMessageTrans_Dictionary
        MOVVC  r1, r0
        MOVVC  r0, r2
        SWIVC  XOS_PrettyPrint
        Pull   "r1,r3"         ; restore r1 and get buffer pointer
        Pull   "pc", VS        ; if error, exit
        MOV    r0, #0
        ADRL   R2, SysCommsModule
        BL     OneModuleK
        BVS    %FT10
        LDR    R6, =ZeroPage+Module_List
12      LDR    R6, [R6]
        CMP    R6, #0
        BEQ    %FT10
        LDR    R2, [R6, #Module_code_pointer]
        BL     OneModuleK
        BVC    %BT12
10      MOVVC  R0, #0
        Pull  "PC"

FileCommands_Help
        Push  "R0, lr"
        ADRL   R0, fscommands_helpstr
        MOV    R1, #FS_Command_Flag
        B      KeyHelpCommon

; take module code pointer in r2
;                    flags in r1
;    HelpBufferSize buffer in r3
;          string to print in r0

OneModuleK     ROUT
        Push  "r2-r7, lr"
        LDR    R4, [R2, #Module_HC_Table]
        CMP    R4, #0
        Pull  "r2-r7, PC", EQ       ; no table
        MOV    R7, #&80000000       ; flag
        MOV    R5, #0               ; buffer offset

        ADD    R2, R2, R4           ; point at table start.
03      MOV    R6, R2
        LDRB   R4, [R2]
        CMP    R4, #0
        BEQ    %FT06

04      LDRB   R4, [R6], #1
        CMP    R4, #0
        BNE    %BT04
        ADD    lr, R6, #3
        BIC    lr, lr, #3           ; align but leave r6 at end of command for below (05)
        LDR    R4, [lr, #0]         ; code offset
        CMP    r1, #-1              ; fudge?
        BEQ    %FT78
        CMP    R4, #0
        ADDEQ  R2, lr, #16
        BEQ    %BT03
        LDRB   R4, [lr, #7]
        BIC    R4, R4, #(Help_Is_Code_Flag:OR:International_Help) :SHR: 24
        CMP    R4, R1, LSR #24      ; move flags into bottom byte
79      ADDNE  R2, lr, #16
        BNE    %BT03
        TST    R7, #&80000000
        BEQ    %FT05
        SWI    XOS_NewLine
        SWIVC  XOS_NewLine
        BVS    %FT77
        MOV    r4, r0
        CMP    r0, #0
        BEQ    OneModuleK_PrintTitle ; Don't trust MessageTrans to preserve Z
        SWI    XMessageTrans_Dictionary
        Push   "r1"
        MOVVC  r1, r0
        MOVVC  r0, r4
        SWIVC  XOS_PrettyPrint
        Pull   "r1"
        B      %FT77
OneModuleK_PrintTitle
        LDR    r0, [stack]
        BL     PrintTitle
77
        MOVVC  r0, r4
        Pull  "r2-r7, PC", VS
        BIC    R7, R7, #&80000000
05
        SUB    lr, r6, r2
        RSB    r4, r5, #HelpBufferSize
        CMP    r4, lr                   ; have we got enough space for command+tab
        BCS    %FT07
        MOV    r4, #0                   ; no, so 0 terminate what we've got and print it
        SUB    r5, r5, #1               ; write 0 over trailing tab
        STRB   r4, [r3, r5]
        MOV    r4, r0
        MOV    r0, r3
        SWI    XOS_PrettyPrint
        SWIVC  XOS_NewLine
        Pull   "r2-r7,pc",VS
        MOV    r0, r4
        MOV    r5, #0                   ; start again with empty buffer
07
        LDRB   r4, [r2], #1             ; copy command
        CMP    r4, #0
        STRNEB r4, [r3, r5]
        ADDNE  r5, r5, #1
        BNE    %BT07
        MOV    r4, #TAB                 ; add tab
        STRB   r4, [r3, r5]
        ADD    r5, r5, #1
        ADD    r2, r2, #3+16            ; align and move on to next command
        BIC    r2, r2, #3
        B      %BT03

78      CMP    r4, #0
        B      %BT79

06      TST    R7, #&80000000
        Pull  "r2-r7, PC", NE
        Push  "R0"
        MOV    R0, #0
        SUB    R5, R5, #1
        STRB   R0, [R5, R3]
        MOV    R0, R3
        SWI    XOS_PrettyPrint
        STRVS  r0, [stack]
        Pull  "R0, r2-r7, PC"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

GOS_Code
        Push    lr
        MOV     r2, r0
        addr    R1, UtilModTitle
        MOV     R0, #ModHandReason_Enter
        SWI     XOS_Module
        Pull    pc

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; Deal with UtilityModule SWIs.
;
; The UtilityModule provides "OS-independent" SWIs. At present these are:
;
; SWI &F00000 (ARM_IMB)
; SWI &F00001 (ARM_IMBRange)
;
; as specified by the ARMv5 ARM (section 2.7.4 Prefetching and self-modifying
; code)

Util_SWI
        CMP     r11, #1
        BLO     SyncCodeAreasFull       ; (00) will do tail-call return from SWI
        BHI     Util_SWINotKnown        ; (02..3F)

; Ranged wotsit                           (01)
        Push    "r1,r2,lr"
        SUB     r2, r1, #4              ; convert from exclusive to inclusive
        MOV     r1, r0
        BL      SyncCodeAreasRange
        Pull    "r1,r2,pc"

Util_SWINotKnown
        ADR     r0, ErrorBlock_ModuleBadSWI
      [ International
        addr    r4, UtilModTitle
        B       TranslateError_UseR4
      |
        RETURNVS
      ]

        MakeErrorBlock ModuleBadSWI

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ChangeDynamicArea - moved here from the Task Manager as embedded devices
; tend not to have the Task Manager
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rmaarea         *       1               ; RMA area
screenarea      *       2               ; screen area
spritearea      *       3               ; sprite area
fontarea        *       4               ; font cache dynamic area number
ramfsarea       *       5               ; RAM disc area

                ^       0
vec_fontsize    #       4               ; fields in output vector
vec_spritesize  #       4
vec_ramfssize   #       4
vec_rmasize     #       4
vec_screensize  #       4
ss_outputvec    *       &100

Keydef  DCB     "FontSize/K,SpriteSize/K,RamFSSize/K,RMASize/K,ScreenSize/K"
        DCB     0
        ALIGN

; NB: R12 -> private word (don't use workspace, as it may not be present)

ChangeDynamicArea_Code  ROUT
        Push    "R11,LR"
        MOV     R11,sp                  ; remember stack for later
;
        SUB     sp,sp,#ss_outputvec     ; local workspace
;
; scan the comand line by calling OS_ReadArgs
;
        MOV     R1,R0                   ; R1 = input string
        ADR     R0,Keydef               ; R0 = key defion string
        MOV     R2,sp                   ; R2 = output vector
        MOV     R3,#ss_outputvec        ; R3 = max output vector length
        SWI     XOS_ReadArgs
;
; scan the resulting vector for known fields
;
        MOVVC   R0,#rmaarea
        LDRVC   R1,[sp,#vec_rmasize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#screenarea
        LDRVC   R1,[sp,#vec_screensize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#fontarea
        LDRVC   R1,[sp,#vec_fontsize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#spritearea
        LDRVC   R1,[sp,#vec_spritesize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#ramfsarea           ; NB: do RAMFS last so others get done if it fails
        LDRVC   R1,[sp,#vec_ramfssize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOV     sp,R11                  ; restore stack
        Pull    "R11,PC"

; In    R0 = dynamic area number
;       R1 -> string specifying size required (<=0 => don't bother)
; Out   calls OS_ChangeDynamicArea, which gives Service_MemoryMoved
;       this is intercepted, and sets [memoryupdated]
;       this causes a pollword event:
;           which calls set_memory for all memory slots
;           if the RAM disc slot size changes to/from 0
;               [ramfsflag] is set
;               unless dragging the ram slot bar:
;                   reramfsfiler re-ialises the RAMFSFiler
;                   otherwise it waits till the bar is dropped

changeR0R1      ROUT
        Push    "R0-R3,LR"

        CMP     R1,#0
        Pull    "R0-R3,PC",EQ

        SWI     XOS_ReadDynamicArea     ; R1 = current size of area
        MOVVC   R3,R1

        LDRVC   R1,[sp,#1*4]
        BLVC    getK                    ; R1 = new amount required

        LDRVC   R0,[sp,#0*4]
        SUBVC   R1,R1,R3                ; R1 = change required
        SWIVC   XOS_ChangeDynamicArea

        STRVS   R0,[sp]
        Pull    "R0-R3,PC"


; In    R1 --> string
; Out   R1 = parameter value (number)
; Errors: "Bad number"
;

getK    ROUT
        Push    "R2-R3,LR"
;
        MOV     R0,#10
        SWI     XOS_ReadUnsigned
        Pull    "R2-R3,PC",VS
;
        LDRB    R3,[R1]
        UpperCase R3, R14
        TEQ     R3,#"K"                 ; if terminator is "K" or "k",
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #10           ; multiply by 1024
        TEQ     R3,#"M"                 ; if terminator is "M" or "m",
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #20           ; multiply by 1048576
        TEQ     R3,#"G"                 ; if terminator is "G" or "g",
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #30           ; multiply by 1073741824
;
        LDRB    R14,[R1]                ; check terminator
        RSBS    R14,R14,#" "+1          ; ensure GT set if OK
        ADRLEL  R0,ErrorBlock_BadNumb   ; "Number not recognised"
      [ International
        BLLE    TranslateError
      ]
;
        MOVVC   R1,R2                   ; R1 = answer
        Pull    "R2-R3,PC"


UtilFlags DCD ModuleFlag_32bit

        END
@


4.10
log
@Resolve 2x header clashes
hdr/AHCIDevice:
  Remove this, since it clashes with the (differing API version number) copy exported by SATADriver. Post merging the Kernel back to the trunk the newer file datestamp has meant the wrong one gets exported during any ROM build which includes both components. Since the Kernel doesn't need AHCIDevice itself, it is left to the respective client (SATADriver or AHCIDriver in this case) to export them.
hdr/ModHand:
  Resolve the longstanding clash of Module_Title with the same named symbol that CMHG uses. There are very few assembler needing to look at the module header (Kernel, FileCore, Debugger, Podule) directly, but every C module which uses CMHG and wants one of the ModHandReason values ends up with a duplicate define.
  Obsolete Arthur era Module_LoadAddr value.
ArthurSWIs.s/MoreComms.s/NewReset.s/SWINaming.s/SysComms.s/Utility.s:
  Module_Title->Module_TitleStr.
ModHand.s:
  Module_Title->Module_TitleStr.
  Recode Module_LoadAddr using the file type from Hdr:FileTypes.
GetAlls.s:
  Drop unused NVRAM and PortMan headers. Add Hdr:FileTypes.

Version 5.54. Tagged as 'Kernel-5_54'
@
text
@d54 2
d59 2
a60 1
        ASSERT Service_DeviceFSCloseRequest < Service_DisplayStatus
d66 2
d76 1
d85 3
a87 1
        TEQ     r1, #Service_BufferStarting
d93 1
d107 6
@


4.9
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d542 1
a542 1
        LDR     R0, [R3, #Module_Title]
@


4.8
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a104 1
 [ MouseBufferManager
a109 1
 ]
@


4.7
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a39 1
 [ :LNOT: No32bitCode
a40 1
 ]
a1119 1
 [ :LNOT: No32bitCode
a1120 1
 ]
@


4.6
log
@  Improved the error cacheing.
  Removed DriversInKernel conditional.
Detail:
  If the territory changes or the resource file changes, the kernel
    will now decache all the cached error blocks so that next time
    they are required, they will be looked up again.
  The error cacheing is now a kernel build option and is always set
    to on.
  Removed one of the 5 error messages to be cached - it never seems
    to happen.  The remaining 4 are more frequent.
Admin:
  Tested in Ursula build.
  Cannot be used with HdrSrc 0.94.  HdrSrc 0.95 and later is required
    (or HdrSrc 0.93 and earlier subject to other kernel requirements)
  Requires MessageTrans 0.42 or later for correct operation when a
    replacement messages file is loaded.

Version 5.32. Tagged as 'Kernel-5_32'
@
text
@a16 1

d31 3
a33 3
        &       0
        &       0
        &       0
d44 7
d59 1
d73 1
d87 1
d98 5
a102 2
        TEQ     r1, #Service_BufferStarting
        BNE     %FT10
d126 1
a126 1
        MOV     r0, #0                          ; used as index to PrinterBufferThing
d146 1
d148 1
a148 1
        LDR     r1, [r0, #OsbyteVars + :INDEX: PrinterActive]
d150 1
a150 1
        STREQ   r0, [r0, #OsbyteVars + :INDEX: PrinterActive]
d152 1
a152 1
        LDRB    r1, [r0, #OsbyteVars + :INDEX: SerialInHandle]
d154 1
a154 1
        STREQB  r0, [r0, #OsbyteVars + :INDEX: SerialInHandle]
d156 1
a156 1
        LDRB    r1, [r0, #OsbyteVars + :INDEX: SerialOutHandle]
d159 1
a159 1
        STRB    r0, [r0, #OsbyteVars + :INDEX: SerialOutHandle]
d162 1
d164 1
a164 1
        Pull    "r0,lr,pc"                      ; restore r0, junk r1, and exit
d199 1
d345 1
d391 6
a396 2
           CMP   R3, #ROM
           BLT   RMFast_notinROM
d442 2
a443 2
          MOV   r0, #0                          ; Try our own message file before Global.
          LDR   r0, [r0, #KernelMessagesBlock]
d445 1
a445 1
          ADRNE r0, KernelMessagesBlock+4
d447 1
d449 1
d456 1
a456 1
          MOV    R1, #Module_List
d580 1
a580 1
        mrs    ,r7,CPSR
d684 1
a684 1
        msr    ,CPSR_f, r7
d702 1
d813 2
a814 2
        MOV    r0, #0          ; Try our own message file before Global.
        LDR    r0, [r0, #KernelMessagesBlock]
d816 2
a817 1
        ADRNE  r0, KernelMessagesBlock+4
d819 1
a824 1
        Pull   "r1,lr,PC", VS  ; if error, pull R1, junk stacked R0 and exit
d826 1
d831 1
a831 1
        MOV    R6, #Module_List
d853 1
a853 1
        Push  "r2-r6, lr"
d856 2
a857 2
        Pull  "r2-r6, PC", EQ       ; no table
        ORR    R3, R3, #&80000000   ; buffer position ptr and flag
d882 1
a882 1
        TST    R3, #&80000000
d891 1
a891 1
        STMDB  sp!, {r1}
d895 1
a895 1
        LDMIA  sp!, {r1}
d902 2
a903 2
        Pull  "r2-r6, PC", VS
        BIC    R3, R3, #&80000000
d916 1
a916 1
        Pull   "r2-r6,pc",VS
d935 2
a936 2
06      TST    R3, #&80000000
        Pull  "r2-r6, PC", NE
d944 1
a944 1
        Pull  "R0, r2-r6, PC"
d957 35
d1006 2
a1007 2
vec_rmasize	#	4
vec_screensize	#	4
d1010 1
a1010 1
Keydef  DCB     "FontSize/K,SpriteSize/K,RamFsSize/K,RMASize/K,ScreenSize/K"
d1071 1
a1071 1
        Pull    "R0-R3,PC",LE
d1099 1
a1099 1
        LDRB    R3,[R1]                 ; if terminator is "K" or "k",
d1101 1
a1101 1
        TEQ     R3,#"K"
d1104 6
@


4.6.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d17 1
d32 3
a34 3
        &       &F00000
        &       Util_SWI-UtilityMod
        &       Util_SWITab-UtilityMod
d37 1
a37 2
   ;     &       MessageFileName-UtilityMod
        &       UtilityMod
a44 7
Util_SWITab
        =       "ARM"
        =       "IMB"
        =       "IMBRange"
        =       0
        ALIGN

d558 1
a558 1
        MRS     r7, CPSR
d662 1
a662 1
        MSR     CPSR_f, r7
a679 1
        ALIGN
a929 35

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; Deal with UtilityModule SWIs.
;
; The UtilityModule provides "OS-independent" SWIs. At present these are:
;
; SWI &F00000 (ARM_IMB)
; SWI &F00001 (ARM_IMBRange)
;
; as specified by the ARMv5 ARM (section 2.7.4 Prefetching and self-modifying
; code)

Util_SWI
        CMP     r11, #1
        BLO     SyncCodeAreasFull       ; (00) will do tail-call return from SWI
        BHI     Util_SWINotKnown        ; (02..3F)

; Ranged wotsit                           (01)
        Push    "r1,r2,lr"
        SUB     r2, r1, #4              ; convert from exclusive to inclusive
        MOV     r1, r0
        BL      SyncCodeAreasRange
        Pull    "r1,r2,pc"

Util_SWINotKnown
        ADR     r0, ErrorBlock_ModuleBadSWI
      [ International
        addr    r4, UtilModTitle
        B       TranslateError_UseR4
      |
        RETURNVS
      ]

        MakeErrorBlock ModuleBadSWI
@


4.6.2.2
log
@More HAL work. IOMD HAL work in progress. Lots of my own little build
scripts. Don't touch this.

Version 5.35, 4.79.2.2. Tagged as 'Kernel-5_35-4_79_2_2'
@
text
@d46 3
a48 3
        =       "ARM",0
        =       "IMB",0
        =       "IMBRange",0
@


4.6.2.3
log
@Check-in of the few last-minute changes for the Customer L demo. Nothing
exciting, apart from an extended touchscreen API.

Version 5.35, 4.79.2.13. Tagged as 'Kernel-5_35-4_79_2_13'
@
text
@d36 2
a37 1
        &       MessageFileName-UtilityMod
@


4.6.2.4
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d381 2
a382 6
           CMP   R3, #ROM                 ; HS if R3 >= ROM
           BLO   RMFast_notinROM
 [ :LNOT:ROMatTop
           CMP   R3, #ROMLimit
           BHS   RMFast_notinROM
 ]
d835 1
a835 1
        Push  "r2-r7, lr"
d838 2
a839 2
        Pull  "r2-r7, PC", EQ       ; no table
        MOV    R7, #&80000000       ; flag
d864 1
a864 1
        TST    R7, #&80000000
d884 2
a885 2
        Pull  "r2-r7, PC", VS
        BIC    R7, R7, #&80000000
d898 1
a898 1
        Pull   "r2-r7,pc",VS
d917 2
a918 2
06      TST    R7, #&80000000
        Pull  "r2-r7, PC", NE
d926 1
a926 1
        Pull  "R0, r2-r7, PC"
d992 1
a992 1
Keydef  DCB     "FontSize/K,SpriteSize/K,RamFSSize/K,RMASize/K,ScreenSize/K"
d1053 1
a1053 1
        Pull    "R0-R3,PC",EQ
d1081 1
a1081 1
        LDRB    R3,[R1]
d1083 1
a1083 1
        TEQ     R3,#"K"                 ; if terminator is "K" or "k",
a1085 6
        TEQ     R3,#"M"                 ; if terminator is "M" or "m",
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #20           ; multiply by 1048576
        TEQ     R3,#"G"                 ; if terminator is "G" or "g",
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #30           ; multiply by 1073741824
@


4.6.2.5
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d120 1
a120 1
        LDR     r0, =ZeroPage                   ; used as index to PrinterBufferThing
a139 1
        LDR     lr, =ZeroPage
d141 1
a141 1
        LDR     r1, [lr, #OsbyteVars + :INDEX: PrinterActive]
d143 1
a143 1
        STREQ   r0, [lr, #OsbyteVars + :INDEX: PrinterActive]
d145 1
a145 1
        LDRB    r1, [lr, #OsbyteVars + :INDEX: SerialInHandle]
d147 1
a147 1
        STREQB  r0, [lr, #OsbyteVars + :INDEX: SerialInHandle]
d149 1
a149 1
        LDRB    r1, [lr, #OsbyteVars + :INDEX: SerialOutHandle]
d152 1
a152 1
        STRB    r0, [lr, #OsbyteVars + :INDEX: SerialOutHandle]
a154 1
        LDR     r0, [sp], #8                    ; restore r0, junk r1
d156 1
a156 1
        LDR     pc, [sp], #4                    ; exit
d432 2
a433 2
          LDR   r2, =ZeroPage                      ; Try our own message file before Global.
          LDR   r0, [r2, #KernelMessagesBlock]
d435 1
a435 1
          ADDNE r0, r2, #KernelMessagesBlock+4
a436 1
        [ ZeroPage <> 0
a437 1
        ]
d444 1
a444 1
          LDR    R1, =ZeroPage+Module_List
d801 2
a802 2
        LDR    r2, =ZeroPage   ; Try our own message file before Global.
        LDR    r0, [r2, #KernelMessagesBlock]
d804 1
a804 2
        ADDNE  r0, r2, #KernelMessagesBlock+4
      [ ZeroPage <> 0
a805 1
      ]
d811 1
a812 1
        Pull   "pc", VS        ; if error, exit
d817 1
a817 1
        LDR    R6, =ZeroPage+Module_List
d877 1
a877 1
        Push   "r1"
d881 1
a881 1
        Pull   "r1"
@


4.6.2.6
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d998 2
a999 2
vec_rmasize     #       4
vec_screensize  #       4
@


4.6.2.6.2.1
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@a192 1
           Command   Cache,              1,  0, International_Help
a337 1
           Command   Cache,              1,  0, International_Help
@


4.6.2.7
log
@Adoption of *CONFIGURE/STATUS CACHE commands
The kernel already looks after all other aspects of the ARM CPU, so can look after the cache control command too.
 HelpStrs.s:New tokens for help and syntax
 CmdHelp.s:UK help and syntax
 Arthur3.s:Tables updates for *CONFIGURE/STATUS, lined some stuff up, default error text sync'd with Hdr:NewErrors
 MoreComms.s:Parsing and doing of *CACHE
 Utility.s:Hashing table updated for *CACHE
Other minor changes
 hdr/Options:Bring 'MosVer' into the private header
 hdr/RISCOS:aasm aliases for SP removed, MainVars and MosVer made private, added definition of the start of application space
 HeapMan.s:Use of GRAB changed to Pull
 Offset of TutuCMOS changed for more informative PrintSoundCMOS
 PMF/osbyte.s:Use OsBytes header file in place of MainVars

Version 5.35, 4.79.2.151. Tagged as 'Kernel-5_35-4_79_2_151'
@
text
@a192 1
           Command   Cache,              1,  0, International_Help
a337 1
           Command   Cache,              1,  0, International_Help
@


4.6.2.8
log
@Improve Service_DisplayStatus, Service_DisplayChanged functionality
Detail:
  hdr/VduExt - Define new Service_DisplayChanged reason code for us to issue before anything actually happens. Define new Service_DisplayStatus reason codes for drivers to issue when they change their configuration/capabilities in some way.
  s/Utility - Listen out for Service_DisplayStatus
  s/vdu/vdudriver - When DisplayStatus_Changing/DisplayStatus_Changed is received for the current driver, translate into the appropriate DisplayChanged reason codes so that software which only cares about the current driver doesn't have two sets of service calls to listen out for
  s/vdu/vduswis - When switching driver in OS_ScreenMode 11, issue the new Service_DisplayChanged PreChanging reason code before we update the current GraphicsV driver VDU variable
Admin:
  Tested in Iyonix ROM softload


Version 5.35, 4.79.2.216. Tagged as 'Kernel-5_35-4_79_2_216'
@
text
@a58 1
        ASSERT Service_DeviceFSCloseRequest < Service_DisplayStatus
a71 1
        DCD    Service_DisplayStatus
a84 1
        TEQNE   r1, #Service_DisplayStatus
d95 2
a96 5
        TEQ     r1, #Service_DeviceFSCloseRequest
        BEQ     %FT10
        TEQ     r1, #Service_DisplayStatus
        BEQ     HandleServiceDisplayStatus
        ; Else must be Service_BufferStarting
@


4.6.2.4.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d120 1
a120 1
        LDR     r0, =ZeroPage                   ; used as index to PrinterBufferThing
a139 1
        LDR     lr, =ZeroPage
d141 1
a141 1
        LDR     r1, [lr, #OsbyteVars + :INDEX: PrinterActive]
d143 1
a143 1
        STREQ   r0, [lr, #OsbyteVars + :INDEX: PrinterActive]
d145 1
a145 1
        LDRB    r1, [lr, #OsbyteVars + :INDEX: SerialInHandle]
d147 1
a147 1
        STREQB  r0, [lr, #OsbyteVars + :INDEX: SerialInHandle]
d149 1
a149 1
        LDRB    r1, [lr, #OsbyteVars + :INDEX: SerialOutHandle]
d152 1
a152 1
        STRB    r0, [lr, #OsbyteVars + :INDEX: SerialOutHandle]
d432 2
a433 2
          LDR   r2, =ZeroPage                      ; Try our own message file before Global.
          LDR   r0, [r2, #KernelMessagesBlock]
d435 1
a435 1
          ADDNE r0, r2, #KernelMessagesBlock+4
a436 1
        [ ZeroPage <> 0
a437 1
        ]
d444 1
a444 1
          LDR    R1, =ZeroPage+Module_List
d801 2
a802 2
        LDR    r2, =ZeroPage   ; Try our own message file before Global.
        LDR    r0, [r2, #KernelMessagesBlock]
d804 1
a804 2
        ADDNE  r0, r2, #KernelMessagesBlock+4
      [ ZeroPage <> 0
a805 1
      ]
d817 1
a817 1
        LDR    R6, =ZeroPage+Module_List
@


4.6.2.4.2.2
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@a155 1
        LDR     r0, [sp], #8                    ; restore r0, junk r1
d157 1
a157 1
        LDR     pc, [sp], #4                    ; exit
d816 1
a817 1
        Pull   "pc", VS        ; if error, exit
d882 1
a882 1
        Push   "r1"
d886 1
a886 1
        Pull   "r1"
@


4.5
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a27 3
 [ DriversInKernel
        &       0                               ; no services ta
 |
a28 1
 ]
d41 3
a46 1
 [ :LNOT: DriversInKernel
d50 3
a52 1
        ASSERT Service_BufferStarting < Service_DeviceFSCloseRequest
d54 1
d58 3
d62 3
d75 4
d84 5
a151 1
 ]
d1054 5
@


4.4
log
@ChocolateSysVars and ChocolateOscli merged from Ursula.

Version 4.84. Tagged as 'Kernel-4_84'
@
text
@d68 1
a68 1
        MOVNES  pc, lr
d129 1
a129 1
        Pull    "r0,r1,pc",NE,^                 ; if not any of these then exit preserving everything
d134 1
a134 1
        Pull    "r0,lr,pc",,^                   ; restore r0, junk r1, and exit restoring flags
d147 1
a147 1
           ORRS  PC, lr, #V_bit
d374 1
a374 1
           ORRS PC, lr, #V_bit
d469 3
a471 2
        Pull   "R7, lr", VS
        BICVSS  PC, lr, #V_bit           ; back, clearing V
d473 1
d542 2
a543 1
        Entry   "r0",8+256
d560 1
a560 1
        LDR     r0, [sp, #Proc_LocalStack + 0*4]        ; wildcard
d631 2
a632 4
        STR     r0, [sp, #Proc_LocalStack + 0*4]
        LDR     lr, [sp, #Proc_LocalStack + 1*4]        ; lr in
        ORR     lr, lr, #V_bit
        STR     lr, [sp, #Proc_LocalStack + 1*4]
d647 2
a648 1
        EXITS
d654 12
a708 12
      [ International
02
        =       "Number:(Number)", 0
03
        =       "Macro:(Macro)", 0
      |
02
        =       "Number", 0
03
        =       "Macro", 0
      ]

d748 2
a749 2
        Pull  "lr"
        BICS   PC, lr, #V_bit
@


4.3
log
@* Added support for 24LC64 8K EEPROM (untested).
* Integrated Ursula fast service call dispatch code.
* Added Interruptible32bitModes from Ursula.
* Stopped allowing ROM modules (other than the Kernel/UtilityModule) to write
  to the hardware vectors in 26-bit mode.

Version 4.81. Tagged as 'Kernel-4_81'
@
text
@d163 5
d203 134
@


4.2
log
@Following changes folded in from the start of the Ursula branch:
CPU type messages internationalised.
"Unknown OS_PlatformFeatures reason code" internationalised.
RunningOnEmul flag tweaked.
MorrisIDString conditional removed.
New modules added to SWI list at the end of the chain, on grounds that
the first-registered modules are probably more important.
*ChangeDynamicArea moved into UtilityModule from TaskManager.

Version 4.65. Tagged as 'Kernel-4_65'
@
text
@d49 13
d63 3
d69 4
a72 1

@


4.1
log
@Initial revision
@
text
@d145 33
a177 32
           Command   Break,       0,  0, International_Help   ; just help
           Command   Configure, 255,  0, Help_Is_Code_Flag :OR: International_Help
           Command   Commands,    0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   Echo,      255,  0, International_Help
           Command   Error,     255,  1, International_Help
           Command   Eval,      255,  1, International_Help
           Command   FileCommands,0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   GOS,         0,  0, International_Help
           Command   IF,        255,  2, International_Help
           Command   Ignore,      1,  0, International_Help
           Command   Modules,     0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   PowerOn,     0,  0, International_Help   ; just help
           Command   Reset,       0,  0, International_Help   ; just help
           Command   RMClear,     0,  0, International_Help
           Command   RMEnsure,  255,  2, International_Help
           Command   RMFaster,    1,  1, International_Help
           Command   RMInsert,    2,  1, International_Help
           Command   RMKill,      1,  1, International_Help
           Command   RMLoad,    255,  1, International_Help
           Command   RMReInit,  255,  1, International_Help
           Command   RMRun,     255,  1, International_Help
           Command   RMTidy,      0,  0, International_Help
           Command   ROMModules,  0,  0, International_Help
           Command   Set,       255,  2, International_Help
           Command   SetEval,   255,  2, International_Help
           Command   SetMacro,  255,  2, International_Help
           Command   Show,        1,  0, International_Help   ; *show = *show *
           Command   Status,    255,  0, International_Help
           Command   Syntax,      0,  0, International_Help
           Command   Time,        0,  0, International_Help
           Command   Unplug,      2,  0, International_Help
           Command   Unset,       1,  1, International_Help
d755 124
@


4.1.4.1
log
@Module SWI chunks added to end of linked list on grounds that first loaded
modules are probably more important, so should be checked first.
Some RISC OS 3.70 bits internationalised.
*ChangeDynamicArea moved into UtilityModule from TaskManager.
@
text
@d145 32
a176 33
           Command   Break,              0,  0, International_Help   ; just help
           Command   ChangeDynamicArea,255,  0, International_Help
           Command   Configure,        255,  0, Help_Is_Code_Flag :OR: International_Help
           Command   Commands,           0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   Echo,             255,  0, International_Help
           Command   Error,            255,  1, International_Help
           Command   Eval,             255,  1, International_Help
           Command   FileCommands,       0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   GOS,                0,  0, International_Help
           Command   IF,               255,  2, International_Help
           Command   Ignore,             1,  0, International_Help
           Command   Modules,            0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   PowerOn,            0,  0, International_Help   ; just help
           Command   Reset,              0,  0, International_Help   ; just help
           Command   RMClear,            0,  0, International_Help
           Command   RMEnsure,         255,  2, International_Help
           Command   RMFaster,           1,  1, International_Help
           Command   RMInsert,           2,  1, International_Help
           Command   RMKill,             1,  1, International_Help
           Command   RMLoad,           255,  1, International_Help
           Command   RMReInit,         255,  1, International_Help
           Command   RMRun,            255,  1, International_Help
           Command   RMTidy,             0,  0, International_Help
           Command   ROMModules,         0,  0, International_Help
           Command   Set,              255,  2, International_Help
           Command   SetEval,          255,  2, International_Help
           Command   SetMacro,         255,  2, International_Help
           Command   Show,               1,  0, International_Help   ; *show = *show *
           Command   Status,           255,  0, International_Help
           Command   Syntax,             0,  0, International_Help
           Command   Time,               0,  0, International_Help
           Command   Unplug,             2,  0, International_Help
           Command   Unset,              1,  1, International_Help
a753 124

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ChangeDynamicArea - moved here from the Task Manager as embedded devices
; tend not to have the Task Manager
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rmaarea         *       1               ; RMA area
screenarea      *       2               ; screen area
spritearea      *       3               ; sprite area
fontarea        *       4               ; font cache dynamic area number
ramfsarea       *       5               ; RAM disc area

                ^       0
vec_fontsize    #       4               ; fields in output vector
vec_spritesize  #       4
vec_ramfssize   #       4
vec_rmasize	#	4
vec_screensize	#	4
ss_outputvec    *       &100

Keydef  DCB     "FontSize/K,SpriteSize/K,RamFsSize/K,RMASize/K,ScreenSize/K"
        DCB     0
        ALIGN

; NB: R12 -> private word (don't use workspace, as it may not be present)

ChangeDynamicArea_Code  ROUT
        Push    "R11,LR"
        MOV     R11,sp                  ; remember stack for later
;
        SUB     sp,sp,#ss_outputvec     ; local workspace
;
; scan the comand line by calling OS_ReadArgs
;
        MOV     R1,R0                   ; R1 = input string
        ADR     R0,Keydef               ; R0 = key defion string
        MOV     R2,sp                   ; R2 = output vector
        MOV     R3,#ss_outputvec        ; R3 = max output vector length
        SWI     XOS_ReadArgs
;
; scan the resulting vector for known fields
;
        MOVVC   R0,#rmaarea
        LDRVC   R1,[sp,#vec_rmasize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#screenarea
        LDRVC   R1,[sp,#vec_screensize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#fontarea
        LDRVC   R1,[sp,#vec_fontsize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#spritearea
        LDRVC   R1,[sp,#vec_spritesize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#ramfsarea           ; NB: do RAMFS last so others get done if it fails
        LDRVC   R1,[sp,#vec_ramfssize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOV     sp,R11                  ; restore stack
        Pull    "R11,PC"

; In    R0 = dynamic area number
;       R1 -> string specifying size required (<=0 => don't bother)
; Out   calls OS_ChangeDynamicArea, which gives Service_MemoryMoved
;       this is intercepted, and sets [memoryupdated]
;       this causes a pollword event:
;           which calls set_memory for all memory slots
;           if the RAM disc slot size changes to/from 0
;               [ramfsflag] is set
;               unless dragging the ram slot bar:
;                   reramfsfiler re-ialises the RAMFSFiler
;                   otherwise it waits till the bar is dropped

changeR0R1      ROUT
        Push    "R0-R3,LR"

        CMP     R1,#0
        Pull    "R0-R3,PC",LE

        SWI     XOS_ReadDynamicArea     ; R1 = current size of area
        MOVVC   R3,R1

        LDRVC   R1,[sp,#1*4]
        BLVC    getK                    ; R1 = new amount required

        LDRVC   R0,[sp,#0*4]
        SUBVC   R1,R1,R3                ; R1 = change required
        SWIVC   XOS_ChangeDynamicArea

        STRVS   R0,[sp]
        Pull    "R0-R3,PC"


; In    R1 --> string
; Out   R1 = parameter value (number)
; Errors: "Bad number"
;

getK    ROUT
        Push    "R2-R3,LR"
;
        MOV     R0,#10
        SWI     XOS_ReadUnsigned
        Pull    "R2-R3,PC",VS
;
        LDRB    R3,[R1]                 ; if terminator is "K" or "k",
        UpperCase R3, R14
        TEQ     R3,#"K"
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #10           ; multiply by 1024
;
        LDRB    R14,[R1]                ; check terminator
        RSBS    R14,R14,#" "+1          ; ensure GT set if OK
        ADRLEL  R0,ErrorBlock_BadNumb   ; "Number not recognised"
      [ International
        BLLE    TranslateError
      ]
;
        MOVVC   R1,R2                   ; R1 = answer
        Pull    "R2-R3,PC"
@


4.1.4.2
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d28 3
d32 1
d48 1
d60 1
d66 1
d117 1
d123 1
d127 3
d133 1
d135 3
d212 1
d214 1
d276 1
d280 4
d290 1
d294 5
d353 1
d356 3
d369 1
d371 3
d416 6
d428 1
d430 4
d537 1
d542 6
d771 2
a772 2
vec_rmasize     #       4
vec_screensize  #       4
d873 1
d875 1
@


4.1.4.3
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a127 5
  [ Oscli_HashedCommands
;
;***WARNING*** if commands are added or changed, UtilHashedCmdTab MUST be updated correspondingly
;
  ]
a162 137

  [ Oscli_HashedCommands
;
; - Hashing table is 32 wide
; - Hashing function is: 
;
;      hash = (sum of all chars of command, each upper-cased) & 0x1f
;
; - Order of commands in each hashed list is chosen as 'most common' first

; Table MUST be reorganised if hashing function changed, or command set altered
;
           ALIGN
UtilHashedCmdTab
;
;     ! 0,"UtilHashedCmdTab  at ":CC::STR:(UtilHashedCmdTab)
;
;First, 1 word per table entry, giving offset to hashed list on each hash value
;
           DCD       0                        ;null list on this hash value
           DCD       UHC_hash01 - UtilityMod
           DCD       UHC_hash03 - UtilityMod
           DCD       UHC_hash02 - UtilityMod
           DCD       UHC_hash04 - UtilityMod
           DCD       0
           DCD       UHC_hash06 - UtilityMod
           DCD       UHC_hash07 - UtilityMod
           DCD       UHC_hash08 - UtilityMod
           DCD       UHC_hash09 - UtilityMod
           DCD       UHC_hash0A - UtilityMod
           DCD       UHC_hash0B - UtilityMod
           DCD       UHC_hash0C - UtilityMod
           DCD       0
           DCD       0
           DCD       UHC_hash0F - UtilityMod
           DCD       0
           DCD       UHC_hash11 - UtilityMod
           DCD       0
           DCD       0
           DCD       UHC_hash14 - UtilityMod
           DCD       0
           DCD       0
           DCD       0
           DCD       0
           DCD       UHC_hash19 - UtilityMod
           DCD       0
           DCD       UHC_hash1B - UtilityMod
           DCD       0
           DCD       0
           DCD       UHC_hash1E - UtilityMod
           DCD       UHC_hash1F - UtilityMod
;
; Now the hashed lists
;
UHC_hash01
           Command   Show,               1,  0, International_Help
           =   0
           ALIGN
UHC_hash02
           Command   Configure,        255,  0, Help_Is_Code_Flag :OR: International_Help
           =   0
           ALIGN
UHC_hash03
           Command   ChangeDynamicArea,255,  0, International_Help
           =   0
           ALIGN
UHC_hash04
           Command   RMFaster,           1,  1, International_Help
           Command   Status,           255,  0, International_Help
           Command   Ignore,             1,  0, International_Help
           =   0
           ALIGN
UHC_hash06
           Command   RMClear,            0,  0, International_Help
           =   0
           ALIGN
UHC_hash07
           Command   ROMModules,         0,  0, International_Help
           =   0
           ALIGN
UHC_hash08
           Command   Eval,             255,  1, International_Help
           =   0
           ALIGN
UHC_hash09
           Command   GOS,                0,  0, International_Help
           =   0
           ALIGN
UHC_hash0A
           Command   RMReInit,         255,  1, International_Help
           Command   Error,            255,  1, International_Help
           =   0
           ALIGN
UHC_hash0B
           Command   RMKill,             1,  1, International_Help
           =   0
           ALIGN
UHC_hash0C
           Command   Set,              255,  2, International_Help
           =   0
           ALIGN
UHC_hash0F
           Command   IF,               255,  2, International_Help
           Command   Unset,              1,  1, International_Help
           Command   Time,               0,  0, International_Help
           =   0
           ALIGN
UHC_hash11
           Command   RMEnsure,         255,  2, International_Help
           =   0
           ALIGN
UHC_hash14
           Command   SetEval,          255,  2, International_Help
           Command   RMRun,            255,  1, International_Help
           Command   RMInsert,           2,  1, International_Help
           =   0
           ALIGN
UHC_hash19
           Command   Modules,            0,  0, Help_Is_Code_Flag :OR: International_Help
           Command   RMTidy,             0,  0, International_Help
           =   0
           ALIGN
UHC_hash1B
           Command   Unplug,             2,  0, International_Help
           =   0
           ALIGN
UHC_hash1E
           Command   SetMacro,         255,  2, International_Help
           =   0
           ALIGN
UHC_hash1F
           Command   RMLoad,           255,  1, International_Help
           Command   Echo,             255,  0, International_Help
           =   0
           ALIGN

  ] ;Oscli_HashedCommands
@


4.1.4.4
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a43 13
  [ ChocolateService
    ;service table
    ;
        ASSERT Service_BufferStarting < Service_DeviceFSCloseRequest
    ;
Util_ChocServTab
        DCD    0                            ;flags word
        DCD    Util_ChocService-UtilityMod  ;offset to handler
        DCD    Service_BufferStarting       ;service 1
        DCD    Service_DeviceFSCloseRequest ;service 2
        DCD    0                            ;terminator
        DCD    Util_ChocServTab-UtilityMod  ;table anchor
  ]
a44 3
  [ ChocolateService
        MOV     r0, r0   ;magic instruction for new service table format
  ]
d48 1
a48 4
  [ ChocolateService
    ;entry point excluding pre-rejection code
Util_ChocService
  ]
d183 1
a183 1
;    ! 0,"UtilHashedCmdTab  at ":CC::STR:(UtilHashedCmdTab)
d189 1
a190 1
           DCD       0
d230 4
a234 1
           Command   ChangeDynamicArea,255,  0, International_Help
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

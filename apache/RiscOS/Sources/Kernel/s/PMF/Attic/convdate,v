head	4.4;
access;
symbols
	Kernel-5_35-4_79_2_98_2_52_2_1:4.3
	alees_Kernel_dev:4.3.0.8
	alees_Kernel_dev_bp:4.3
	Kernel-5_35-4_79_2_124:4.3
	Kernel-5_35-4_79_2_123:4.3
	Cortex_merge:4.3
	Kernel-5_35-4_79_2_122:4.3
	Kernel-5_35-4_79_2_98_2_54:4.3
	Kernel-5_35-4_79_2_98_2_53:4.3
	Kernel-5_35-4_79_2_98_2_52:4.3
	Kernel-5_35-4_79_2_98_2_51:4.3
	Kernel-5_35-4_79_2_98_2_50:4.3
	Kernel-5_35-4_79_2_98_2_49:4.3
	Kernel-5_35-4_79_2_98_2_48:4.3
	Kernel-5_35-4_79_2_121:4.3
	Kernel-5_35-4_79_2_98_2_47:4.3
	Kernel-5_35-4_79_2_120:4.3
	Kernel-5_35-4_79_2_98_2_46:4.3
	Kernel-5_35-4_79_2_119:4.3
	Kernel-5_35-4_79_2_98_2_45:4.3
	Kernel-5_35-4_79_2_98_2_44:4.3
	Kernel-5_35-4_79_2_118:4.3
	Kernel-5_35-4_79_2_98_2_43:4.3
	Kernel-5_35-4_79_2_117:4.3
	Kernel-5_35-4_79_2_116:4.3
	Kernel-5_35-4_79_2_98_2_42:4.3
	Kernel-5_35-4_79_2_115:4.3
	Kernel-5_35-4_79_2_98_2_41:4.3
	Kernel-5_35-4_79_2_98_2_40:4.3
	Kernel-5_35-4_79_2_114:4.3
	Kernel-5_35-4_79_2_98_2_39:4.3
	Kernel-5_35-4_79_2_98_2_38:4.3
	Kernel-5_35-4_79_2_113:4.3
	Kernel-5_35-4_79_2_112:4.3
	Kernel-5_35-4_79_2_98_2_37:4.3
	Kernel-5_35-4_79_2_98_2_36:4.3
	Kernel-5_35-4_79_2_98_2_35:4.3
	Kernel-5_35-4_79_2_98_2_34:4.3
	Kernel-5_35-4_79_2_98_2_33:4.3
	Kernel-5_35-4_79_2_98_2_32:4.3
	Kernel-5_35-4_79_2_98_2_31:4.3
	Kernel-5_35-4_79_2_98_2_30:4.3
	Kernel-5_35-4_79_2_98_2_29:4.3
	Kernel-5_35-4_79_2_98_2_28:4.3
	Kernel-5_35-4_79_2_98_2_27:4.3
	Kernel-5_35-4_79_2_98_2_26:4.3
	Kernel-5_35-4_79_2_111:4.3
	Kernel-5_35-4_79_2_98_2_25:4.3
	Kernel-5_35-4_79_2_98_2_24:4.3
	Kernel-5_35-4_79_2_98_2_23:4.3
	Kernel-5_35-4_79_2_110:4.3
	Kernel-5_35-4_79_2_98_2_22:4.3
	Kernel-5_35-4_79_2_109:4.3
	Kernel-5_35-4_79_2_98_2_21:4.3
	Kernel-5_35-4_79_2_98_2_20:4.3
	Kernel-5_35-4_79_2_108:4.3
	Kernel-5_35-4_79_2_107:4.3
	Kernel-5_35-4_79_2_98_2_19:4.3
	Kernel-5_35-4_79_2_98_2_18:4.3
	Kernel-5_35-4_79_2_98_2_17:4.3
	Kernel-5_35-4_79_2_98_2_16:4.3
	Kernel-5_35-4_79_2_98_2_15:4.3
	Kernel-5_35-4_79_2_106:4.3
	Kernel-5_35-4_79_2_105:4.3
	Kernel-5_35-4_79_2_104:4.3
	Kernel-5_35-4_79_2_98_2_14:4.3
	Kernel-5_35-4_79_2_98_2_13:4.3
	Kernel-5_35-4_79_2_98_2_12:4.3
	Kernel-5_35-4_79_2_98_2_11:4.3
	Kernel-5_35-4_79_2_98_2_10:4.3
	Kernel-5_35-4_79_2_98_2_9:4.3
	Kernel-5_35-4_79_2_103:4.3
	Kernel-5_35-4_79_2_102:4.3
	Kernel-5_35-4_79_2_98_2_8:4.3
	Kernel-5_35-4_79_2_98_2_7:4.3
	Kernel-5_35-4_79_2_98_2_6:4.3
	Kernel-5_35-4_79_2_98_2_5:4.3
	Kernel-5_35-4_79_2_98_2_4:4.3
	Kernel-5_35-4_79_2_101:4.3
	Kernel-5_35-4_79_2_100:4.3
	Kernel-5_35-4_79_2_99:4.3
	Kernel-5_35-4_79_2_98_2_3:4.3
	Kernel-5_35-4_79_2_98_2_2:4.3
	Kernel-5_35-4_79_2_98_2_1:4.3
	Cortex:4.3.0.4
	Cortex_bp:4.3
	Kernel-5_35-4_79_2_98:4.3
	Kernel-5_35-4_79_2_97:4.3
	Kernel-5_35-4_79_2_96:4.3
	Kernel-5_35-4_79_2_95:4.3
	Kernel-5_35-4_79_2_94:4.3
	Kernel-5_35-4_79_2_93:4.3
	Kernel-5_35-4_79_2_92:4.3
	Kernel-5_35-4_79_2_91:4.3
	Kernel-5_35-4_79_2_90:4.3
	Kernel-5_35-4_79_2_89:4.3
	Kernel-5_35-4_79_2_88:4.3
	Kernel-5_35-4_79_2_87:4.3
	Kernel-5_35-4_79_2_86:4.3
	Kernel-5_35-4_79_2_85:4.3
	Kernel-5_35-4_79_2_84:4.3
	Kernel-5_35-4_79_2_83:4.3
	Kernel-5_35-4_79_2_82:4.3
	Kernel-5_35-4_79_2_81:4.3
	Kernel-5_35-4_79_2_80:4.3
	Kernel-5_35-4_79_2_79:4.3
	Kernel-5_35-4_79_2_78:4.3
	Kernel-5_35-4_79_2_77:4.3
	RO_5_07:4.3
	Kernel-5_35-4_79_2_76:4.3
	Kernel-5_35-4_79_2_75:4.3
	Kernel-5_35-4_79_2_74:4.3
	Kernel-5_35-4_79_2_73:4.3
	Kernel-5_35-4_79_2_72:4.3
	Kernel-5_35-4_79_2_71:4.3
	Kernel-5_35-4_79_2_70:4.3
	Kernel-5_35-4_79_2_69:4.3
	Kernel-5_35-4_79_2_68:4.3
	Kernel-5_35-4_79_2_67:4.3
	Kernel-5_35-4_79_2_66:4.3
	Kernel-5_35-4_79_2_65:4.3
	Kernel-5_35-4_79_2_64:4.3
	Kernel-5_35-4_79_2_63:4.3
	Kernel-5_35-4_79_2_62:4.3
	Kernel-5_35-4_79_2_61:4.3
	Kernel-5_35-4_79_2_59:4.3
	Kernel-5_35-4_79_2_58:4.3
	Kernel-5_35-4_79_2_57:4.3
	Kernel-5_35-4_79_2_56:4.3
	Kernel-5_35-4_79_2_55:4.3
	Kernel-5_35-4_79_2_54:4.3
	Kernel-5_35-4_79_2_53:4.3
	Kernel-5_35-4_79_2_52:4.3
	Kernel-5_35-4_79_2_51:4.3
	Kernel-5_35-4_79_2_50:4.3
	Kernel-5_35-4_79_2_49:4.3
	Kernel-5_35-4_79_2_48:4.3
	Kernel-5_47:4.3
	Kernel-5_46-4_90_2_1:4.3
	nbingham_Kernel_FastNC_dev_bp:4.3
	nbingham_Kernel_FastNC_dev:4.3.0.6
	Kernel-5_46:4.3
	Kernel-5_45:4.3
	Kernel-5_35-4_79_2_47:4.3
	Kernel-5_35-4_79_2_46:4.3
	Kernel-5_35-4_79_2_45:4.3
	Kernel-5_35-4_79_2_44:4.3
	Kernel-5_35-4_79_2_25_2_2:4.3
	Kernel-5_35-4_79_2_43:4.3
	Kernel-5_35-4_79_2_42:4.3
	Kernel-5_35-4_79_2_41:4.3
	Kernel-5_35-4_79_2_40:4.3
	Kernel-5_35-4_79_2_39:4.3
	Kernel-5_35-4_79_2_38:4.3
	Kernel-5_35-4_79_2_37:4.3
	Kernel-5_35-4_79_2_36:4.3
	Kernel-5_35-4_79_2_35:4.3
	Kernel-5_35-4_79_2_34:4.3
	Kernel-5_35-4_79_2_33:4.3
	Kernel-5_35-4_79_2_32:4.3
	Kernel-5_44:4.3
	Kernel-5_35-4_79_2_25_2_1:4.3
	Kernel-5_43:4.3
	Kernel-5_35-4_79_2_31:4.3
	Kernel-5_35-4_79_2_30:4.3
	Kernel-5_35-4_79_2_29:4.3
	Kernel-5_35-4_79_2_28:4.3
	Kernel-5_35-4_79_2_27:4.3
	Kernel-5_35-4_79_2_26:4.3
	Kernel-5_42:4.3
	Kernel-5_41:4.3
	Kernel-5_40:4.3
	Kernel-5_35-4_79_2_25:4.3
	Kernel-5_35-4_79_2_24:4.3
	Kernel-5_35-4_79_2_23:4.3
	Kernel-5_35-4_79_2_22:4.3
	Kernel-5_35-4_79_2_21:4.3
	Kernel-5_35-4_79_2_20:4.3
	Kernel-5_35-4_79_2_19:4.3
	Kernel-5_35-4_79_2_18:4.3
	Kernel-5_35-4_79_2_17:4.3
	Kernel-5_35-4_79_2_16:4.3
	Kernel-5_35-4_79_2_15:4.3
	Kernel-5_35-4_79_2_14:4.3
	Kernel-5_39:4.3
	Kernel-5_13-4_52_2_1:4.2
	Bethany:4.2.0.2
	Kernel-5_38:4.3
	Kernel-5_35-4_79_2_13:4.3
	Kernel-5_35-4_79_2_12:4.3
	Kernel-5_35-4_79_2_11:4.3
	Kernel-5_37:4.3
	Kernel-5_35-4_79_2_10:4.3
	Kernel-5_35-4_79_2_9:4.3
	Kernel-5_36:4.3
	Kernel-5_35-4_79_2_8:4.3
	Kernel-5_35-4_79_2_7:4.3
	Kernel-5_35-4_79_2_6:4.3
	Kernel-5_35-4_79_2_5:4.3
	Kernel-5_35-4_79_2_4:4.3
	Kernel-5_35-4_79_2_3:4.3
	Kernel-5_35-4_79_2_2:4.3
	dellis_autobuild_BaseSW:4.3
	Kernel-5_35-4_79_2_1:4.3
	HAL:4.3.0.2
	Kernel-5_35:4.3
	Kernel-5_34:4.3
	Kernel-5_33:4.3
	Kernel-5_32:4.3
	Kernel-5_31:4.3
	Kernel-5_30:4.3
	Kernel-5_29:4.3
	Kernel-5_28:4.3
	Kernel-5_27:4.3
	Kernel-5_26:4.3
	Kernel-5_25:4.3
	Kernel-5_24:4.3
	Kernel-5_23:4.3
	Kernel-5_22:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Kernel-5_21:4.2
	Kernel-5_20:4.2
	Kernel-5_19:4.2
	Kernel-5_18:4.2
	Kernel-5_17:4.2
	Kernel-5_16:4.2
	Kernel-5_15:4.2
	Kernel-5_14:4.2
	Kernel-5_13:4.2
	Kernel-5_12:4.2
	Kernel-5_11:4.2
	Kernel-5_10:4.2
	Kernel-5_09:4.2
	Kernel-5_08:4.2
	Kernel-5_07:4.2
	Kernel-5_06:4.2
	Kernel-5_05:4.2
	Kernel-5_04:4.2
	Kernel-5_03:4.2
	Kernel-5_02:4.2
	Kernel-5_01:4.2
	Kernel-5_00:4.2
	Kernel-4_99:4.2
	Kernel-4_98:4.2
	Kernel-4_97:4.2
	Kernel-4_96:4.2
	Kernel-4_95:4.2
	Kernel-4_94:4.2
	Kernel-4_93:4.2
	Kernel-4_92:4.2
	Kernel-4_91:4.2
	Kernel-4_90:4.2
	dcotton_autobuild_BaseSW:4.3
	Kernel-4_89:4.2
	Kernel-4_88:4.2
	Kernel-4_87:4.2
	Kernel-4_86:4.2
	Kernel-4_85:4.2
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.2
	Kernel-4_82:4.2
	Kernel-4_81:4.2
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.2
	Kernel-4_63-1_1_2_4:4.1.7.2
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.2
	Kernel-4_65:4.2
	Ursula_merge:4.1
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.2
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2016.06.30.20.08.15;	author jlee;	state dead;
branches;
next	4.3;
commitid	IWoXxARWeuLDOwcz;

4.3
date	2000.04.04.14.27.35;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	98.09.30.08.42.44;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.27;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2011.11.27.12.34.58;	author rsprowson;	state dead;
branches;
next	;
commitid	QtdLV6zjuPNxdYIv;

4.1.1.1
date	96.11.05.09.41.27;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.01.42;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.05;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.03;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.05;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	98.09.08.15.25.02;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.PMF.ConvDate

        MACRO
        CDATT   $mnemonic, $stackoffset, $digits
        ASSERT  (:LEN: "$mnemonic") = 2
        ASSERT  ((CDAT$mnemonic-(CDATBranch+8)) :AND: &FFFFFC03) = 0
        ASSERT  ($stackoffset >=0) :LAND: ($stackoffset < 64)
        LCLA    digits
        [       "$digits"=""
digits  SETA    2
        |
digits  SETA    $digits
        ]
        ASSERT  (digits >= 1) :LAND: (digits <= 3)

        DCB     digits :OR: ($stackoffset :SHL: 2)
        DCB     (CDAT$mnemonic-(CDATBranch+8)) :SHR: 2
        =       "$mnemonic"
        MEND

; *****************************************************************************
;
;       ConvertStandardDateAndTime - Convert from 5-byte cs representation to
;                                    format specified in <SYS$DateFormat>
;
; in:   R0 -> time block
;       [R0, #0..4] = 5-byte centisecond representation
;       R1 -> buffer to accept conversion
;       R2 = size of buffer
;
; out:  V=0 => successful conversion
;       R0 = input value of R1
;       R1 = updated pointer to buffer
;       R2 = updated size of buffer
;
;       V=1 => failed conversion
;       R0 -> error block
;       R1 = input value of R1
;       R2 = input value of R2
;


ConvertStandardDateAndTime ROUT
; KJB 980908 - International version just calls TerrMgr (as documented in PRM!)
        Push    "R3,R14"

        MOV     R3,R2                   ; Territory SWI wants things one register up.
        MOV     R2,R1
        MOV     R1,R0
        MOV     R0,#-1                  ; Use configured territory.
        SWI     XTerritory_ConvertStandardDateAndTime
        Pull    "R3,R14"
        ORRVS   R14, R14, #V_bit        ; set V in R14 for exit
        ExitSWIHandler

; *****************************************************************************
;
;       ConvertDateAndTime - Convert from 5-byte cs representation to
;                            format specified by user
;
; in:   R0 -> time block
;       [R0, #0..4] = 5-byte centisecond representation
;       R1 -> buffer to accept conversion
;       R2 = size of buffer
;       R3 -> format string
;
; out:  V=0 => successful conversion
;       R0 = input value of R1
;       R1 = updated pointer to buffer
;       R2 = updated size of buffer
;
;       V=1 => failed conversion
;       R0 -> error block
;       R1 = input value of R1
;       R2 = input value of R2
;

ConvertDateAndTime ROUT

        Push    "R4,R14"


        MOV     R4,R3                   ; Territory SWI wants things one register up.
        MOV     R3,R2
        MOV     R2,R1
        MOV     R1,R0
        MOV     R0,#-1                  ; Use configured territory.
        SWI     XTerritory_ConvertDateAndTime
        Pull    "R4,R14"
        ORRVS   R14, R14, #V_bit        ; set V in R14 for exit
        ExitSWIHandler

        LTORG

        END
@


4.3
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@@


4.3.2.1
log
@Conversions rationalisation.
Delete pmf/convdate, moved to conversions.
Moved OS_BinaryToDecimal to conversions.
Remove OS_ConvertHex16 and friends.
Add OS_ConvertVariform skeleton.
Tidied conversions.

Version 5.35, 4.79.2.125. Tagged as 'Kernel-5_35-4_79_2_125'
@
text
@@


4.2
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d58 1
a58 1
      [ {TRUE}                          ; KJB 980908 - International version just calls TerrMgr (as documented in PRM!)
a68 53
      |
        BIC     R10, R13, #&00FF
        BIC     R10, R10, #&7F00        ; R10 -> assumed start of stack
        SUB     R10, R13, R10           ; R10 := free space on stack
        CMP     R10, #&200              ; to be on the safe side
        BCS     %FT10

; not enough stack for operation

        ADR     R0, ErrorBlock_CDATStackOverflow
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        SWI     XOS_GenerateError
        ORR     R14, R14, #V_bit
        ExitSWIHandler

        MakeErrorBlock CDATStackOverflow

10
        SUB     R13, R13, #&100         ; room for reading <SYS$DateFormat>
        Push    "R0-R4, R14"
        ADR     R0, DateFormatVarName   ; R0 -> "SYS$DateFormat"
        ADD     R1, R13, #6*4           ; R1 -> buffer for string
        MOV     R2, #255                ; R2 = maximum length of string
        MOV     R3, #0                  ; not wild carding
        MOV     R4, #VarType_Expanded   ; convert to string
        SWI     XOS_ReadVarVal
        BVS     %FT30
        MOV     R0, #0
        STRB    R0, [R1, R2]            ; terminate string with zero
        MOV     R3, R1                  ; R3 -> format string
        Pull    "R0-R2"
        SWI     XOS_ConvertDateAndTime
        Pull    "R3,R4, R14"
20
        ADD     R13, R13, #&100
        ORRVS   R14, R14, #V_bit
        ExitSWIHandler

; format specifier not found

30
        ADD     R13, R13, #4            ; throw away stacked R0
        Pull    "R1-R4, R14"
        B       %BT20

DateFormatVarName
        =       "SYS$DateFormat",0
        ALIGN
      ]
a93 1
      [ {TRUE}                          ; International vesion just calls territory manager.
a106 403
      |
        Push    "R1-R11, R14"

        LDRB    R4, [R0, #0]            ; read the 5 byte value to convert
        LDRB    R5, [R0, #1]
        ORR     R4, R4, R5, LSL #8
        LDRB    R5, [R0, #2]
        ORR     R4, R4, R5, LSL #16
        LDRB    R5, [R0, #3]
        ORR     R4, R4, R5, LSL #24     ; R4 contains bottom 4 bytes
        LDRB    R5, [R0, #4]            ; R5 contains 5th byte

        MOV     R6, R4, LSR #8
        ORR     R6, R6, R5, LSL #24     ; R6 := centiseconds DIV 256
        LDR     R7, =ticksperday/256    ; (ticksperday is a multiple of 256)
        DivRem  R8, R6, R7, R9          ; R8 = number of days since 1900
        AND     R4, R4, #&FF            ; R4 := centiseconds MOD 256
        ORR     R6, R4, R6, LSL #8      ; R6 := centiseconds today

; first work out bits from R6

        LDR     R7, =ticksperhour
        DivRem  R4, R6, R7, R9          ; R4 := hours
        LDR     R7, =ticksperminute
        DivRem  R5, R6, R7, R9          ; R5 := minutes
        LDR     R7, =tickspersecond
        DivRem  R10, R6, R7, R9         ; R10 := seconds
                                        ; R6 := centiseconds
        Push    "R4,R5,R6,R10"

; now work out bits from R8

        ADD     R11, R8, #1             ; R11 := fudged copy of days since 1900
        MOV     R5, #7
        DivRem  R6, R11, R5, R7         ; R11 := days MOD 7 (ie day of week)
        ADD     R11, R11, #1            ; make in range 1..7

        MOV     R5, #00                 ; units of years = 00
        MOV     R4, #19                 ; hundreds of years = 19
10
        MOV     R6, #0                  ; 0 if not a leap year
        TST     R5, #3                  ; if not divis by 4 then not leap year
        BNE     %FT30
        TEQ     R5, #0                  ; elif not divis by 100 then leap
        BNE     %FT20
        TST     R4, #3                  ; elif not divis by 400 then not leap
        BNE     %FT30
20
        MOV     R6, #1                  ; 1 if leap year
30
        LDR     R7, =365                ; normally take off 365 days per year
        ADD     R7, R7, R6              ; extra day if leap year

        SUBS    R8, R8, R7              ; try taking off 365 or 366 days
        BCC     %FT40                   ; [failed the subtract]
        ADD     R5, R5, #1              ; increment year if successful
        CMP     R5, #100
        MOVEQ   R5, #0
        ADDEQ   R4, R4, #1
        B       %BT10

40
        ADD     R8, R8, R7              ; add back on if we couldn't do it
                                        ; R8 is day of year (0..365)
        Push    "R4,R5"                 ; push yearhi, yearlo

        ADD     R7, R8, #1              ; R7 = day number in range 1-366
        Push    "R7, R11"               ; push d-o-y, d-o-w

; now compute week number

        SUBS    R7, R11, #2             ; dow (Sun=-1, Mon=0,... ,Sat=5)
        ADDCC   R7, R7, #7              ; dow (Mon=0,... ,Sun=6)
        SUB     R7, R8, R7              ; day-of-year no. of start of week

        ADD     R7, R7, #6              ; work out week number as if
                                        ; 1st part week is week 0
        MOV     R10, #7
        DivRem  R11, R7, R10, R9        ; R11 = week number (0..53)
                                        ; R7 (remainder) indicates dayofweek
                                        ; of start of year (Mon=6,Tue=5..Sun=0)
        CMP     R7, #3                  ; if year starts on Mon..Thu
        ADDCS   R11, R11, #1            ; then 1st part week is week 1

        TEQ     R7, #4                  ; if a Wednesday
        TEQEQ   R6, #1                  ; in a leap year
        TEQNE   R7, #3                  ; or a Thursday in any year
        MOVEQ   R9, #53                 ; then allow 53 weeks in year
        MOVNE   R9, #52                 ; else only 52 weeks
        CMP     R11, R9                 ; if more than this
        MOVHI   R11, #1                 ; then week 1 of next year

        TEQ     R11, #0                 ; if not week 0
        BNE     %FT45                   ; then finished

        CMP     R7, #1                  ; HI => Fri, EQ => Sat, CC => Sun
        ADC     R11, R11, #52           ; Fri => 53, Sun => 52, Sat => dunno
        BNE     %FT45

; 1st day of year is Saturday
; if previous year was leap, then is week 53, else is week 52

        SUBS    R5, R5, #1              ; decrement year
        MOVCC   R5, #99
        SUBCC   R4, R4, #1

        TST     R5, #3                  ; if not divis by 4 then not leap year
        BNE     %FT42
        TEQ     R5, #0                  ; elif not divis by 100 then leap
        BNE     %FT45
        TST     R4, #3                  ; elif not divis by 400 then not leap
42
        MOVNE   R11, #52                ; not leap, so must be week 52
45
        Push    "R11"                   ; push weekno

        ADRL    R7, MonthLengths+1      ; R7 -> Jan(31) (Feb is stored as 29)
        EOR     R6, R6, #1              ; R6 = 1 <=> not a leap year
        MOV     R9, #1                  ; month number (1 = Jan)
50
        LDRB    R10, [R7], #1           ; get next month
        CMP     R9, #2                  ; if we're trying for Feb
        SUBEQ   R10, R10, R6            ; and not leap then subtract a day
        SUBS    R8, R8, R10             ; subtract off month value
        ADDCS   R9, R9, #1              ; if successful month +:= 1
        BCS     %BT50

        ADD     R8, R8, R10             ; add the month back on if we failed
        ADD     R8, R8, #1              ; day of month in range 1..31

        Push    "R8,R9"                 ; push d-o-m, month
CDATMainLoop
        SUBS    R2, R2, #1              ; decrement buffer size
        BCC     CDATBufferError         ; error: buffer too small
        LDRB    R0, [R3], #1            ; get byte from format string
        TEQ     R0, #"%"                ; is it a escape sequence ?
        BEQ     %FT65                   ; yes, then do specially
        STRB    R0, [R1], #1            ; no, then store in output buffer
        TEQ     R0, #0                  ; end of format string ?
        BNE     CDATMainLoop            ; no, then loop

; end of format string, so finish

        SUB     R1, R1, #1              ; make R1 point to 0 byte

        ADD     R13, R13, #11*4         ; junk dom,month,woy,doy
                                        ; junk dow,yearhi,yearlo,hours
                                        ; junk mins,secs,centisecs

        Pull    "R0,R3"                 ; R0 := input R1; junk input R2
        Pull    "R3-R11, R14"           ; restore other registers
        ExitSWIHandler                  ; and exit

; come here if run out of buffer space for string

CDATBufferError
        ADR     R0, ErrorBlock_CDATBufferOverflow ; point R0 to error block
CDATError
        ADD     R13, R13, #11*4         ; junk dom,month,woy,doy
                                        ; junk dow,yearhi,yearlo,hours
                                        ; junk mins,secs,centisecs
        Pull    "R1-R11,R14"            ; restore all registers apart from R0
        ORR     R14, R14, #V_bit        ; set V in R14 for exit
        ExitSWIHandler

        MakeErrorBlock CDATBufferOverflow

        MakeErrorBlock CDATBadField

; process "%" escape sequences

65
        LDRB    R0, [R3], #1            ; get next character
        TEQ     R0, #"0"                ; if char = "0"
        MOVEQ   R0, #0                  ; convert to <0>
        TEQNE   R0, #"%"                ; or if char = "%", store "%"
        STREQB  R0, [R1], #1            ; store <0> or "%"
        BEQ     CDATMainLoop            ; and loop

        UpperCase R0, R5                ; convert character to upper case
        EORS    R7, R0, #"Z"            ; zero if we have "Z" specifier
        BNE     %FT67                   ; not "Z"

        LDRB    R0, [R3], #1            ; is "Z", so get another char
        UpperCase R0, R5                ; convert character to upper case
67
        TEQ     R0, #0                  ; are they a wally!
        BEQ     CDATFieldError          ; yes, then bomb out (avoid data abort)

        LDRB    R4, [R3], #1            ; get next char
        UpperCase R4, R5                ; and convert that to upper case

        ORR     R0, R0, R4, LSL #8      ; 2 chars in bottom two bytes

        ADR     R4, CDATEscTab          ; point to table
        ADR     R5, CDATEscTabEnd       ; end of table
70
        TEQ     R4, R5                  ; are we at end of table
CDATFieldError
        ADREQ   R0, ErrorBlock_CDATBadField
        BEQ     CDATError               ; yes, then invalid escape sequence
        LDR     R6, [R4], #4            ; chars in top two bytes
        EOR     R6, R6, R0, LSL #16     ; if match, then must be < 1:SHL:16
        CMP     R6, #(1 :SHL: 16)
        BCS     %BT70                   ; no match, so loop

; found mnemonic match

        AND     R0, R6, #&03            ; R0 = number of digits to print
        AND     R4, R6, #&FC            ; R4 = stack offset
        LDR     R4, [R13, R4]           ; R4 = data item
        MOV     R6, R6, LSR #8          ; R6 = code offset in words
CDATBranch
        ADD     PC, PC, R6, LSL #2      ; go to routine

CDATEscTab
        CDATT   DY, 0
        CDATT   ST, 0
        CDATT   MN, 1
        CDATT   MO, 1
        CDATT   M3, 1
        CDATT   WK, 2
        CDATT   DN, 3, 3
        CDATT   WN, 4, 1
        CDATT   W3, 4, 1
        CDATT   WE, 4, 1
        CDATT   CE, 5
        CDATT   YR, 6
        CDATT   24, 7
        CDATT   12, 7
        CDATT   AM, 7
        CDATT   PM, 7
        CDATT   MI, 8
        CDATT   CS, 9
        CDATT   SE, 10
CDATEscTabEnd

; routine to print R0 digits of the number held in R4,
; R7=0 <=> suppress leading zeroes

CDATDY
CDATMN
CDATWK
CDATDN
CDATWN
CDATCE
CDATYR
CDAT24
CDATMI
CDATCS
CDATSE
CDATDecR4 ROUT
        ADD     R2, R2, #1              ; undo initial subtract
        ADR     R6, PowersOfTen
10
        MOV     R5, #0
        TEQ     R0, #1                  ; if on last digit
        MOVEQ   R7, #1                  ; definitely don't suppress
20
        LDRB    R8, [R6, R0]            ; get power of ten to subtract
        SUBS    R4, R4, R8              ; subtract value
        ADDCS   R5, R5, #1
        BCS     %BT20
        ADD     R4, R4, R8              ; undo failed subract

        ORRS    R7, R7, R5              ; Z => suppress it
        BEQ     %FT30                   ; [suppressing]

        ORR     R5, R5, #"0"            ; convert to ASCII digit
        SUBS    R2, R2, #1              ; one less space in buffer
        BCC     CDATBufferError
        STRB    R5, [R1], #1            ; store character
30
        SUBS    R0, R0, #1              ; next digit
        BNE     %BT10                   ; [another digit to do]
        B       CDATMainLoop

PowersOfTen
        =       0, 1, 10, 100
        ALIGN

; Hours in 12 hour format

CDAT12
        CMP     R4, #12                 ; if in range 12..23
        SUBCS   R4, R4, #12             ; then make in range 00..11
        TEQ     R4, #0                  ; if 00
        MOVEQ   R4, #12                 ; then make 12
        B       CDATDecR4

; AM or PM indication

CDATAM
CDATPM
        CMP     R4, #12                 ; if earlier than 12 o'clock
        ADRCC   R4, CDATamstr           ; then am
        ADRCS   R4, CDATpmstr           ; else pm
CDATdostr
        LDRB    R0, [R4], #1            ; get byte from string
        TEQ     R0, #0                  ; if zero, then end of string
        BEQ     CDATMainLoop            ; so loop
CDATdostrloop
        STRB    R0, [R1], #1            ; we know there's room for one char
CDATdostr2
        LDRB    R0, [R4], #1            ; get byte from string
        TEQ     R0, #0                  ; if zero, then end of string
        BEQ     CDATMainLoop            ; so loop
        SUBS    R2, R2, #1              ; dec R2 for next char
        BCS     CDATdostrloop           ; OK to do another char
        B       CDATBufferError         ; ran out of buffer space

CDATST
        TEQ     R4, #1
        TEQNE   R4, #21
        TEQNE   R4, #31
        ADREQ   R4, CDATststr
        BEQ     CDATdostr
        TEQ     R4, #2
        TEQNE   R4, #22
        ADREQ   R4, CDATndstr
        BEQ     CDATdostr
        TEQ     R4, #3
        TEQNE   R4, #23
        ADREQ   R4, CDATrdstr
        ADRNE   R4, CDATthstr
        B       CDATdostr

CDATW3
        ADRL    R0, DayNameTable-4      ; Sun is 1
        B       CDATdo3
CDATM3
        ADRL    R0, MonthNameTable-4    ; Jan is month 1
CDATdo3
        ADD     R4, R0, R4, LSL #2      ; point to short month name
        LDRB    R0, [R4], #1            ; get 1st char of month
        BIC     R0, R0, #&20            ; upper case
        STRB    R0, [R1], #1            ; and store
        B       CDATdostr2              ; then do rest

CDATWE
        ADD     R4, R4, #12             ; skip months
CDATMO
        ADR     R0, LongMonthTable-1    ; Jan is month 1
        LDRB    R4, [R0, R4]            ; get offset to month string
        ADD     R4, R0, R4              ; point to start of string
        B       CDATdostr

CDATamstr
        =       "am", 0
CDATpmstr
        =       "pm", 0
CDATststr
        =       "st", 0
CDATndstr
        =       "nd", 0
CDATrdstr
        =       "rd", 0
CDATthstr
        =       "th", 0

LongMonthTable
        =       LongJan-(LongMonthTable-1)
        =       LongFeb-(LongMonthTable-1)
        =       LongMar-(LongMonthTable-1)
        =       LongApr-(LongMonthTable-1)
        =       LongMay-(LongMonthTable-1)
        =       LongJun-(LongMonthTable-1)
        =       LongJul-(LongMonthTable-1)
        =       LongAug-(LongMonthTable-1)
        =       LongSep-(LongMonthTable-1)
        =       LongOct-(LongMonthTable-1)
        =       LongNov-(LongMonthTable-1)
        =       LongDec-(LongMonthTable-1)
        =       LongSun-(LongMonthTable-1)
        =       LongMon-(LongMonthTable-1)
        =       LongTue-(LongMonthTable-1)
        =       LongWed-(LongMonthTable-1)
        =       LongThu-(LongMonthTable-1)
        =       LongFri-(LongMonthTable-1)
        =       LongSat-(LongMonthTable-1)

LongJan =       "January", 0
LongFeb =       "February", 0
LongMar =       "March", 0
LongApr =       "April", 0
LongMay =       "May", 0
LongJun =       "June", 0
LongJul =       "July", 0
LongAug =       "August", 0
LongSep =       "September", 0
LongOct =       "October", 0
LongNov =       "November", 0
LongDec =       "December", 0
LongSun =       "Sunday", 0
LongMon =       "Monday", 0
LongTue =       "Tuesday", 0
LongWed =       "Wednesday", 0
LongThu =       "Thursday", 0
LongFri =       "Friday", 0
LongSat =       "Saturday", 0

        ALIGN
      ]
@


4.1
log
@Initial revision
@
text
@d58 12
d121 1
d146 1
a146 1
          
d156 1
a156 1
        SWI     XTerritory_ConvertDateAndTime      
d562 1
a562 1
        ALIGN                
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d67 1
d71 1
d134 1
a134 2
; International vesion just calls territory manager.

d148 403
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Changes to cope with territories where %w3, %dy or %m3 are not the normal
lengths. To wit:

* Code variables Sys$Time, Sys$Date, Sys$Year don't assume field lengths.
* *Time doesn't assume OS_Word 14,0 output length is 24.
* OS_ConvertStandardDateAndTime now really does call the Territory Manager.
* OS_Word 14,0 no longer gives a maximum buffer length of 24 when calling
  OS_ConvertDateAndTime.
* OS_Word 15 doesn't assume reason code = length of string - attempt is
  made to terminate based on maximum string length, but callers really should
  be supplied control-terminated strings. Other offending modules (eg BASIC)
  have been fixed where spotted.
@
text
@a57 12
      [ {TRUE}                          ; KJB 980908 - International version just calls TerrMgr (as documented in PRM!)
        Push    "R3,R14"

        MOV     R3,R2                   ; Territory SWI wants things one register up.
        MOV     R2,R1
        MOV     R1,R0
        MOV     R0,#-1                  ; Use configured territory.
        SWI     XTerritory_ConvertStandardDateAndTime
        Pull    "R3,R14"
        ORRVS   R14, R14, #V_bit        ; set V in R14 for exit
        ExitSWIHandler
      |
a108 1
      ]
d133 1
a133 1

d143 1
a143 1
        SWI     XTerritory_ConvertDateAndTime
d549 1
a549 1
        ALIGN
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

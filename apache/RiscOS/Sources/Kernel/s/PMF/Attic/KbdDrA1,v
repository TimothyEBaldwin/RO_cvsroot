head	4.3;
access;
symbols
	HAL_merge:4.1.8.1
	Kernel-5_48:4.2
	Kernel-5_35-4_79_2_327:4.1.8.1
	Kernel-5_35-4_79_2_326:4.1.8.1
	Kernel-5_35-4_79_2_325:4.1.8.1
	Kernel-5_35-4_79_2_324:4.1.8.1
	Kernel-5_35-4_79_2_323:4.1.8.1
	Kernel-5_35-4_79_2_322:4.1.8.1
	Kernel-5_35-4_79_2_321:4.1.8.1
	Kernel-5_35-4_79_2_320:4.1.8.1
	Kernel-5_35-4_79_2_319:4.1.8.1
	Kernel-5_35-4_79_2_318:4.1.8.1
	Kernel-5_35-4_79_2_317:4.1.8.1
	Kernel-5_35-4_79_2_316:4.1.8.1
	Kernel-5_35-4_79_2_315:4.1.8.1
	Kernel-5_35-4_79_2_314:4.1.8.1
	Kernel-5_35-4_79_2_313:4.1.8.1
	Kernel-5_35-4_79_2_312:4.1.8.1
	Kernel-5_35-4_79_2_311:4.1.8.1
	Kernel-5_35-4_79_2_310:4.1.8.1
	Kernel-5_35-4_79_2_309:4.1.8.1
	Kernel-5_35-4_79_2_308:4.1.8.1
	Kernel-5_35-4_79_2_307:4.1.8.1
	Kernel-5_35-4_79_2_306:4.1.8.1
	Kernel-5_35-4_79_2_305:4.1.8.1
	Kernel-5_35-4_79_2_304:4.1.8.1
	Kernel-5_35-4_79_2_303:4.1.8.1
	Kernel-5_35-4_79_2_302:4.1.8.1
	Kernel-5_35-4_79_2_301:4.1.8.1
	Kernel-5_35-4_79_2_300:4.1.8.1
	Kernel-5_35-4_79_2_299:4.1.8.1
	Kernel-5_35-4_79_2_298:4.1.8.1
	Kernel-5_35-4_79_2_297:4.1.8.1
	Kernel-5_35-4_79_2_296:4.1.8.1
	Kernel-5_35-4_79_2_295:4.1.8.1
	Kernel-5_35-4_79_2_294:4.1.8.1
	Kernel-5_35-4_79_2_293:4.1.8.1
	Kernel-5_35-4_79_2_292:4.1.8.1
	Kernel-5_35-4_79_2_291:4.1.8.1
	Kernel-5_35-4_79_2_290:4.1.8.1
	Kernel-5_35-4_79_2_289:4.1.8.1
	Kernel-5_35-4_79_2_288:4.1.8.1
	Kernel-5_35-4_79_2_287:4.1.8.1
	Kernel-5_35-4_79_2_286:4.1.8.1
	Kernel-5_35-4_79_2_285:4.1.8.1
	Kernel-5_35-4_79_2_284:4.1.8.1
	Kernel-5_35-4_79_2_283:4.1.8.1
	Kernel-5_35-4_79_2_282:4.1.8.1
	Kernel-5_35-4_79_2_281:4.1.8.1
	Kernel-5_35-4_79_2_280:4.1.8.1
	Kernel-5_35-4_79_2_279:4.1.8.1
	Kernel-5_35-4_79_2_278:4.1.8.1
	Kernel-5_35-4_79_2_277:4.1.8.1
	Kernel-5_35-4_79_2_276:4.1.8.1
	Kernel-5_35-4_79_2_275:4.1.8.1
	Kernel-5_35-4_79_2_274:4.1.8.1
	Kernel-5_35-4_79_2_273:4.1.8.1
	Kernel-5_35-4_79_2_272:4.1.8.1
	Kernel-5_35-4_79_2_271:4.1.8.1
	Kernel-5_35-4_79_2_270:4.1.8.1
	Kernel-5_35-4_79_2_269:4.1.8.1
	Kernel-5_35-4_79_2_268:4.1.8.1
	Kernel-5_35-4_79_2_267:4.1.8.1
	Kernel-5_35-4_79_2_266:4.1.8.1
	Kernel-5_35-4_79_2_265:4.1.8.1
	Kernel-5_35-4_79_2_264:4.1.8.1
	Kernel-5_35-4_79_2_263:4.1.8.1
	Kernel-5_35-4_79_2_262:4.1.8.1
	Kernel-5_35-4_79_2_261:4.1.8.1
	Kernel-5_35-4_79_2_260:4.1.8.1
	Kernel-5_35-4_79_2_259:4.1.8.1
	Kernel-5_35-4_79_2_258:4.1.8.1
	Kernel-5_35-4_79_2_257:4.1.8.1
	Kernel-5_35-4_79_2_256:4.1.8.1
	Kernel-5_35-4_79_2_255:4.1.8.1
	Kernel-5_35-4_79_2_254:4.1.8.1
	Kernel-5_35-4_79_2_253:4.1.8.1
	Kernel-5_35-4_79_2_252:4.1.8.1
	Kernel-5_35-4_79_2_251:4.1.8.1
	Kernel-5_35-4_79_2_250:4.1.8.1
	Kernel-5_35-4_79_2_249:4.1.8.1
	Kernel-5_35-4_79_2_248:4.1.8.1
	Kernel-5_35-4_79_2_247:4.1.8.1
	Kernel-5_35-4_79_2_246:4.1.8.1
	Kernel-5_35-4_79_2_245:4.1.8.1
	Kernel-5_35-4_79_2_244:4.1.8.1
	Kernel-5_35-4_79_2_243:4.1.8.1
	Kernel-5_35-4_79_2_242:4.1.8.1
	Kernel-5_35-4_79_2_241:4.1.8.1
	Kernel-5_35-4_79_2_240:4.1.8.1
	Kernel-5_35-4_79_2_239:4.1.8.1
	Kernel-5_35-4_79_2_238:4.1.8.1
	Kernel-5_35-4_79_2_237:4.1.8.1
	Kernel-5_35-4_79_2_236:4.1.8.1
	Kernel-5_35-4_79_2_235:4.1.8.1
	Kernel-5_35-4_79_2_234:4.1.8.1
	Kernel-5_35-4_79_2_233:4.1.8.1
	Kernel-5_35-4_79_2_232:4.1.8.1
	Kernel-5_35-4_79_2_231:4.1.8.1
	Kernel-5_35-4_79_2_230:4.1.8.1
	Kernel-5_35-4_79_2_229:4.1.8.1
	Kernel-5_35-4_79_2_228:4.1.8.1
	Kernel-5_35-4_79_2_227:4.1.8.1
	Kernel-5_35-4_79_2_226:4.1.8.1
	Kernel-5_35-4_79_2_225:4.1.8.1
	Kernel-5_35-4_79_2_224:4.1.8.1
	Kernel-5_35-4_79_2_223:4.1.8.1
	Kernel-5_35-4_79_2_222:4.1.8.1
	Kernel-5_35-4_79_2_221:4.1.8.1
	Kernel-5_35-4_79_2_220:4.1.8.1
	Kernel-5_35-4_79_2_219:4.1.8.1
	Kernel-5_35-4_79_2_218:4.1.8.1
	Kernel-5_35-4_79_2_217:4.1.8.1
	Kernel-5_35-4_79_2_216:4.1.8.1
	Kernel-5_35-4_79_2_215:4.1.8.1
	Kernel-5_35-4_79_2_214:4.1.8.1
	Kernel-5_35-4_79_2_213:4.1.8.1
	Kernel-5_35-4_79_2_212:4.1.8.1
	Kernel-5_35-4_79_2_211:4.1.8.1
	Kernel-5_35-4_79_2_210:4.1.8.1
	Kernel-5_35-4_79_2_209:4.1.8.1
	Kernel-5_35-4_79_2_208:4.1.8.1
	Kernel-5_35-4_79_2_207:4.1.8.1
	Kernel-5_35-4_79_2_206:4.1.8.1
	Kernel-5_35-4_79_2_205:4.1.8.1
	Kernel-5_35-4_79_2_204:4.1.8.1
	Kernel-5_35-4_79_2_203:4.1
	Kernel-5_35-4_79_2_202:4.1
	Kernel-5_35-4_79_2_201:4.1
	Kernel-5_35-4_79_2_200:4.1
	Kernel-5_35-4_79_2_199:4.1
	Kernel-5_35-4_79_2_198:4.1
	Kernel-5_35-4_79_2_197:4.1
	Kernel-5_35-4_79_2_196:4.1
	Kernel-5_35-4_79_2_195:4.1
	Kernel-5_35-4_79_2_194:4.1
	Kernel-5_35-4_79_2_193:4.1
	Kernel-5_35-4_79_2_192:4.1
	Kernel-5_35-4_79_2_191:4.1
	Kernel-5_35-4_79_2_190:4.1
	Kernel-5_35-4_79_2_189:4.1
	Kernel-5_35-4_79_2_188:4.1
	Kernel-5_35-4_79_2_187:4.1
	Kernel-5_35-4_79_2_186:4.1
	Kernel-5_35-4_79_2_185:4.1
	Kernel-5_35-4_79_2_184:4.1
	Kernel-5_35-4_79_2_183:4.1
	Kernel-5_35-4_79_2_182:4.1
	Kernel-5_35-4_79_2_181:4.1
	Kernel-5_35-4_79_2_180:4.1
	Kernel-5_35-4_79_2_179:4.1
	Kernel-5_35-4_79_2_178:4.1
	Kernel-5_35-4_79_2_177:4.1
	Kernel-5_35-4_79_2_176:4.1
	Kernel-5_35-4_79_2_175:4.1
	Kernel-5_35-4_79_2_174:4.1
	Kernel-5_35-4_79_2_173:4.1
	Kernel-5_35-4_79_2_172:4.1
	Kernel-5_35-4_79_2_171:4.1
	Kernel-5_35-4_79_2_170:4.1
	Kernel-5_35-4_79_2_169:4.1
	Kernel-5_35-4_79_2_168:4.1
	Kernel-5_35-4_79_2_167:4.1
	Kernel-5_35-4_79_2_166:4.1
	Kernel-5_35-4_79_2_165:4.1
	RPi_merge:4.1
	Kernel-5_35-4_79_2_147_2_23:4.1
	Kernel-5_35-4_79_2_147_2_22:4.1
	Kernel-5_35-4_79_2_147_2_21:4.1
	Kernel-5_35-4_79_2_147_2_20:4.1
	Kernel-5_35-4_79_2_147_2_19:4.1
	Kernel-5_35-4_79_2_147_2_18:4.1
	Kernel-5_35-4_79_2_164:4.1
	Kernel-5_35-4_79_2_163:4.1
	Kernel-5_35-4_79_2_147_2_17:4.1
	Kernel-5_35-4_79_2_147_2_16:4.1
	Kernel-5_35-4_79_2_147_2_15:4.1
	Kernel-5_35-4_79_2_162:4.1
	Kernel-5_35-4_79_2_161:4.1
	Kernel-5_35-4_79_2_147_2_14:4.1
	Kernel-5_35-4_79_2_147_2_13:4.1
	Kernel-5_35-4_79_2_160:4.1
	Kernel-5_35-4_79_2_159:4.1
	Kernel-5_35-4_79_2_158:4.1
	Kernel-5_35-4_79_2_157:4.1
	Kernel-5_35-4_79_2_156:4.1
	Kernel-5_35-4_79_2_147_2_12:4.1
	Kernel-5_35-4_79_2_147_2_11:4.1
	Kernel-5_35-4_79_2_155:4.1
	Kernel-5_35-4_79_2_147_2_10:4.1
	Kernel-5_35-4_79_2_154:4.1
	Kernel-5_35-4_79_2_153:4.1
	Kernel-5_35-4_79_2_147_2_9:4.1
	Kernel-5_35-4_79_2_152:4.1
	Kernel-5_35-4_79_2_151:4.1
	Kernel-5_35-4_79_2_147_2_8:4.1
	Kernel-5_35-4_79_2_147_2_7:4.1
	Kernel-5_35-4_79_2_150:4.1
	Kernel-5_35-4_79_2_147_2_6:4.1
	Kernel-5_35-4_79_2_147_2_5:4.1
	Kernel-5_35-4_79_2_149:4.1
	Kernel-5_35-4_79_2_147_2_4:4.1
	Kernel-5_35-4_79_2_147_2_3:4.1
	Kernel-5_35-4_79_2_148:4.1
	Kernel-5_35-4_79_2_147_2_2:4.1
	Kernel-5_35-4_79_2_147_2_1:4.1
	RPi:4.1.0.16
	RPi_bp:4.1
	Kernel-5_35-4_79_2_98_2_52_2_1:4.1
	alees_Kernel_dev:4.1.0.12
	alees_Kernel_dev_bp:4.1
	Kernel-5_35-4_79_2_147:4.1
	Kernel-5_35-4_79_2_146:4.1
	Kernel-5_35-4_79_2_145:4.1
	Kernel-5_35-4_79_2_144:4.1
	Kernel-5_35-4_79_2_143:4.1
	Kernel-5_35-4_79_2_142:4.1
	Kernel-5_35-4_79_2_141:4.1
	Kernel-5_35-4_79_2_140:4.1
	Kernel-5_35-4_79_2_139:4.1
	Kernel-5_35-4_79_2_138:4.1
	Kernel-5_35-4_79_2_137:4.1
	Kernel-5_35-4_79_2_136:4.1
	Kernel-5_35-4_79_2_135:4.1
	Kernel-5_35-4_79_2_134:4.1
	Kernel-5_35-4_79_2_133:4.1
	Kernel-5_35-4_79_2_132:4.1
	Kernel-5_35-4_79_2_131:4.1
	Kernel-5_35-4_79_2_130:4.1
	Kernel-5_35-4_79_2_129:4.1
	Kernel-5_35-4_79_2_128:4.1
	Kernel-5_35-4_79_2_127:4.1
	Kernel-5_35-4_79_2_126:4.1
	Kernel-5_35-4_79_2_125:4.1
	Kernel-5_35-4_79_2_124:4.1
	Kernel-5_35-4_79_2_123:4.1
	Cortex_merge:4.1
	Kernel-5_35-4_79_2_122:4.1
	Kernel-5_35-4_79_2_98_2_54:4.1
	Kernel-5_35-4_79_2_98_2_53:4.1
	Kernel-5_35-4_79_2_98_2_52:4.1
	Kernel-5_35-4_79_2_98_2_51:4.1
	Kernel-5_35-4_79_2_98_2_50:4.1
	Kernel-5_35-4_79_2_98_2_49:4.1
	Kernel-5_35-4_79_2_98_2_48:4.1
	Kernel-5_35-4_79_2_121:4.1
	Kernel-5_35-4_79_2_98_2_47:4.1
	Kernel-5_35-4_79_2_120:4.1
	Kernel-5_35-4_79_2_98_2_46:4.1
	Kernel-5_35-4_79_2_119:4.1
	Kernel-5_35-4_79_2_98_2_45:4.1
	Kernel-5_35-4_79_2_98_2_44:4.1
	Kernel-5_35-4_79_2_118:4.1
	Kernel-5_35-4_79_2_98_2_43:4.1
	Kernel-5_35-4_79_2_117:4.1
	Kernel-5_35-4_79_2_116:4.1
	Kernel-5_35-4_79_2_98_2_42:4.1
	Kernel-5_35-4_79_2_115:4.1
	Kernel-5_35-4_79_2_98_2_41:4.1
	Kernel-5_35-4_79_2_98_2_40:4.1
	Kernel-5_35-4_79_2_114:4.1
	Kernel-5_35-4_79_2_98_2_39:4.1
	Kernel-5_35-4_79_2_98_2_38:4.1
	Kernel-5_35-4_79_2_113:4.1
	Kernel-5_35-4_79_2_112:4.1
	Kernel-5_35-4_79_2_98_2_37:4.1
	Kernel-5_35-4_79_2_98_2_36:4.1
	Kernel-5_35-4_79_2_98_2_35:4.1
	Kernel-5_35-4_79_2_98_2_34:4.1
	Kernel-5_35-4_79_2_98_2_33:4.1
	Kernel-5_35-4_79_2_98_2_32:4.1
	Kernel-5_35-4_79_2_98_2_31:4.1
	Kernel-5_35-4_79_2_98_2_30:4.1
	Kernel-5_35-4_79_2_98_2_29:4.1
	Kernel-5_35-4_79_2_98_2_28:4.1
	Kernel-5_35-4_79_2_98_2_27:4.1
	Kernel-5_35-4_79_2_98_2_26:4.1
	Kernel-5_35-4_79_2_111:4.1
	Kernel-5_35-4_79_2_98_2_25:4.1
	Kernel-5_35-4_79_2_98_2_24:4.1
	Kernel-5_35-4_79_2_98_2_23:4.1
	Kernel-5_35-4_79_2_110:4.1
	Kernel-5_35-4_79_2_98_2_22:4.1
	Kernel-5_35-4_79_2_109:4.1
	Kernel-5_35-4_79_2_98_2_21:4.1
	Kernel-5_35-4_79_2_98_2_20:4.1
	Kernel-5_35-4_79_2_108:4.1
	Kernel-5_35-4_79_2_107:4.1
	Kernel-5_35-4_79_2_98_2_19:4.1
	Kernel-5_35-4_79_2_98_2_18:4.1
	Kernel-5_35-4_79_2_98_2_17:4.1
	Kernel-5_35-4_79_2_98_2_16:4.1
	Kernel-5_35-4_79_2_98_2_15:4.1
	Kernel-5_35-4_79_2_106:4.1
	Kernel-5_35-4_79_2_105:4.1
	Kernel-5_35-4_79_2_104:4.1
	Kernel-5_35-4_79_2_98_2_14:4.1
	Kernel-5_35-4_79_2_98_2_13:4.1
	Kernel-5_35-4_79_2_98_2_12:4.1
	Kernel-5_35-4_79_2_98_2_11:4.1
	Kernel-5_35-4_79_2_98_2_10:4.1
	Kernel-5_35-4_79_2_98_2_9:4.1
	Kernel-5_35-4_79_2_103:4.1
	Kernel-5_35-4_79_2_102:4.1
	Kernel-5_35-4_79_2_98_2_8:4.1
	Kernel-5_35-4_79_2_98_2_7:4.1
	Kernel-5_35-4_79_2_98_2_6:4.1
	Kernel-5_35-4_79_2_98_2_5:4.1
	Kernel-5_35-4_79_2_98_2_4:4.1
	Kernel-5_35-4_79_2_101:4.1
	Kernel-5_35-4_79_2_100:4.1
	Kernel-5_35-4_79_2_99:4.1
	Kernel-5_35-4_79_2_98_2_3:4.1
	Kernel-5_35-4_79_2_98_2_2:4.1
	Kernel-5_35-4_79_2_98_2_1:4.1
	Cortex:4.1.0.2
	Cortex_bp:4.1
	Kernel-5_35-4_79_2_98:4.1
	Kernel-5_35-4_79_2_97:4.1
	Kernel-5_35-4_79_2_96:4.1
	Kernel-5_35-4_79_2_95:4.1
	Kernel-5_35-4_79_2_94:4.1
	Kernel-5_35-4_79_2_93:4.1
	Kernel-5_35-4_79_2_92:4.1
	Kernel-5_35-4_79_2_91:4.1
	Kernel-5_35-4_79_2_90:4.1
	Kernel-5_35-4_79_2_89:4.1
	Kernel-5_35-4_79_2_88:4.1
	Kernel-5_35-4_79_2_87:4.1
	Kernel-5_35-4_79_2_86:4.1
	Kernel-5_35-4_79_2_85:4.1
	Kernel-5_35-4_79_2_84:4.1
	Kernel-5_35-4_79_2_83:4.1
	Kernel-5_35-4_79_2_82:4.1
	Kernel-5_35-4_79_2_81:4.1
	Kernel-5_35-4_79_2_80:4.1
	Kernel-5_35-4_79_2_79:4.1
	Kernel-5_35-4_79_2_78:4.1
	Kernel-5_35-4_79_2_77:4.1
	RO_5_07:4.1
	Kernel-5_35-4_79_2_76:4.1
	Kernel-5_35-4_79_2_75:4.1
	Kernel-5_35-4_79_2_74:4.1
	Kernel-5_35-4_79_2_73:4.1
	Kernel-5_35-4_79_2_72:4.1
	Kernel-5_35-4_79_2_71:4.1
	Kernel-5_35-4_79_2_70:4.1
	Kernel-5_35-4_79_2_69:4.1
	Kernel-5_35-4_79_2_68:4.1
	Kernel-5_35-4_79_2_67:4.1
	Kernel-5_35-4_79_2_66:4.1
	Kernel-5_35-4_79_2_65:4.1
	Kernel-5_35-4_79_2_64:4.1
	Kernel-5_35-4_79_2_63:4.1
	Kernel-5_35-4_79_2_62:4.1
	Kernel-5_35-4_79_2_61:4.1
	Kernel-5_35-4_79_2_59:4.1
	Kernel-5_35-4_79_2_58:4.1
	Kernel-5_35-4_79_2_57:4.1
	Kernel-5_35-4_79_2_56:4.1
	Kernel-5_35-4_79_2_55:4.1
	Kernel-5_35-4_79_2_54:4.1
	Kernel-5_35-4_79_2_53:4.1
	Kernel-5_35-4_79_2_52:4.1
	Kernel-5_35-4_79_2_51:4.1
	Kernel-5_35-4_79_2_50:4.1
	Kernel-5_35-4_79_2_49:4.1
	Kernel-5_35-4_79_2_48:4.1
	Kernel-5_47:4.1
	Kernel-5_46-4_90_2_1:4.1
	nbingham_Kernel_FastNC_dev_bp:4.1
	nbingham_Kernel_FastNC_dev:4.1.0.14
	Kernel-5_46:4.1
	Kernel-5_45:4.1
	Kernel-5_35-4_79_2_47:4.1
	Kernel-5_35-4_79_2_46:4.1
	Kernel-5_35-4_79_2_45:4.1
	Kernel-5_35-4_79_2_44:4.1
	Kernel-5_35-4_79_2_25_2_2:4.1
	Kernel-5_35-4_79_2_43:4.1
	Kernel-5_35-4_79_2_42:4.1
	Kernel-5_35-4_79_2_41:4.1
	Kernel-5_35-4_79_2_40:4.1
	Kernel-5_35-4_79_2_39:4.1
	Kernel-5_35-4_79_2_38:4.1
	Kernel-5_35-4_79_2_37:4.1
	Kernel-5_35-4_79_2_36:4.1
	Kernel-5_35-4_79_2_35:4.1
	Kernel-5_35-4_79_2_34:4.1
	Kernel-5_35-4_79_2_33:4.1
	Kernel-5_35-4_79_2_32:4.1
	Kernel-5_44:4.1
	Kernel-5_35-4_79_2_25_2_1:4.1
	Kernel-5_43:4.1
	Kernel-5_35-4_79_2_31:4.1
	Kernel-5_35-4_79_2_30:4.1
	Kernel-5_35-4_79_2_29:4.1
	Kernel-5_35-4_79_2_28:4.1
	Kernel-5_35-4_79_2_27:4.1
	Kernel-5_35-4_79_2_26:4.1
	Kernel-5_42:4.1
	Kernel-5_41:4.1
	Kernel-5_40:4.1
	Kernel-5_35-4_79_2_25:4.1
	Kernel-5_35-4_79_2_24:4.1
	Kernel-5_35-4_79_2_23:4.1
	Kernel-5_35-4_79_2_22:4.1
	Kernel-5_35-4_79_2_21:4.1
	Kernel-5_35-4_79_2_20:4.1
	Kernel-5_35-4_79_2_19:4.1
	Kernel-5_35-4_79_2_18:4.1
	Kernel-5_35-4_79_2_17:4.1
	Kernel-5_35-4_79_2_16:4.1
	Kernel-5_35-4_79_2_15:4.1
	Kernel-5_35-4_79_2_14:4.1
	Kernel-5_39:4.1
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.10
	Kernel-5_38:4.1
	Kernel-5_35-4_79_2_13:4.1
	Kernel-5_35-4_79_2_12:4.1
	Kernel-5_35-4_79_2_11:4.1
	Kernel-5_37:4.1
	Kernel-5_35-4_79_2_10:4.1
	Kernel-5_35-4_79_2_9:4.1
	Kernel-5_36:4.1
	Kernel-5_35-4_79_2_8:4.1
	Kernel-5_35-4_79_2_7:4.1
	Kernel-5_35-4_79_2_6:4.1
	Kernel-5_35-4_79_2_5:4.1
	Kernel-5_35-4_79_2_4:4.1
	Kernel-5_35-4_79_2_3:4.1
	Kernel-5_35-4_79_2_2:4.1
	dellis_autobuild_BaseSW:4.1
	Kernel-5_35-4_79_2_1:4.1
	HAL:4.1.0.8
	Kernel-5_35:4.1
	Kernel-5_34:4.1
	Kernel-5_33:4.1
	Kernel-5_32:4.1
	Kernel-5_31:4.1
	Kernel-5_30:4.1
	Kernel-5_29:4.1
	Kernel-5_28:4.1
	Kernel-5_27:4.1
	Kernel-5_26:4.1
	Kernel-5_25:4.1
	Kernel-5_24:4.1
	Kernel-5_23:4.1
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.1
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2016.06.30.20.29.02;	author jlee;	state dead;
branches;
next	4.2;
commitid	lMnWzoE9eJz3Wwcz;

4.2
date	2016.06.30.20.08.15;	author jlee;	state Exp;
branches;
next	4.1;
commitid	IWoXxARWeuLDOwcz;

4.1
date	96.11.05.09.41.28;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1
	4.1.8.1;
next	;

4.1.1.1
date	96.11.05.09.41.28;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.01.51;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.03;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.12;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.10;	author nturton;	state Exp;
branches;
next	;

4.1.8.1
date	2013.12.17.19.08.54;	author jlee;	state Exp;
branches;
next	;
commitid	mr92WavK9Mu4gwhx;


desc
@@


4.3
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.PMF.KbdDrA1

; Archimedes keyboard driver.

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date      Who Description
; ----      --- -----------
; 24-Feb-93 SMC Split from file "key".
;               Use generic keyboard/mouse interfaces.

K1ack   *       K1smak

        MACRO
$lab    RXonTXoff  $reg, $cond
$lab
        LDR$cond.B $reg, IRQMaskB
        BIC$cond   $reg, $reg, #KARTTxBit
        ORR$cond   $reg, $reg, #KARTRxBit
        STR$cond.B $reg, IRQMaskB
        MEND

        MACRO
$lab    TXonRXoff  $reg, $cond
$lab
        LDR$cond.B $reg, IRQMaskB
        BIC$cond   $reg, $reg, #KARTRxBit
        ORR$cond   $reg, $reg, #KARTTxBit
        STR$cond.B $reg, IRQMaskB
        MEND

        MACRO
$lab    RXon       $reg, $cond
$lab
        LDR$cond.B $reg, IRQMaskB
        ORR$cond   $reg, $reg, #KARTRxBit
        STR$cond.B $reg, IRQMaskB
        MEND

        MACRO
$lab    TXon       $reg, $cond
$lab
        LDR$cond.B $reg, IRQMaskB
        ORR$cond   $reg, $reg, #KARTTxBit
        STR$cond.B $reg, IRQMaskB
        MEND

        MACRO
$lab    TXoff      $reg, $cond
$lab
        LDR$cond.B $reg, IRQMaskB
        BIC$cond   $reg, $reg, #KARTTxBit
        STR$cond.B $reg, IRQMaskB
        MEND

        GBLS    irqregs
irqregs SETS    """R4-R10, PC"""

; *****************************************************************************
;
;       Start of code

ArthurKeyDriver

; *****************************************************************************
;
;       Initialise driver.
;
A1KeyInit
; Initialise the baud rate generator

        MOV     R12, #IOC
        MOV     R0, #1
        STRB    R0, Timer3Low
        MOV     R0, #0
        STRB    R0, Timer3High
        STRB    R0, Timer3Go

        STRB    R0, KARTTx              ; Write dummy byte

        MOV     R0, #&800
10
        SUBS    R0, R0, #1              ; copy Jon's loop
        BNE     %BT10

        LDRB    R0, KARTRx              ; Read dummy byte

 [ AssemblePointerV
        MOV     r0, #PointerV
        ADR     r1, A1Pointer
        Push    lr
        SWI     OS_Claim
        Pull    lr
 ]

 [ AssembleKEYV
        MOV     r0, #KEYV
        ADR     r1, A1KeyVec
        MOV     r2, r12
        Push    lr
        SWI     OS_Claim
        Pull    pc
 |
        MOV     pc, lr
 ]

; *****************************************************************************
;
;       Reset keyboard hardware.
;
A1Reset
        MOV     R0, #HRDRESET
        STRB    R0, ResetState

        ASSERT  HRDRESET = &FF
        STRB    R0, KeyRow              ; no key being received
        STRB    R0, Reply
        STRB    R0, LastKbId
        STRB    R0, KbIdHalf
        STRB    R0, RequestLED

        MOV     R0, #K1rqid
        STRB    R0, RequestKbId

        MOV     R0, #0
        STRB    R0, JustGotKbId
        STRB    R0, MouseCount          ; start with an X coordinate
        STRB    R0, SPDRec
        STRB    R0, RequestSPD
        STRB    R0, RequestMouse
 [ AssemblePointerV
        STR     r0, MouseXCount
        STR     r0, MouseYCount
 ]

        TXonRXoff       R0              ; enable Tx IRQ, disable Rx IRQ

        MOV     pc, lr

; *****************************************************************************
;
;       Handle enable and update LEDs (r1=state (bit 2=scroll, 1=num, 0=ctrl)).
;
;       In:     r0 = reason code 3 or 4
;               r1 = state (bit 2=scroll lock, 1=num lock, 0=caps lock) if r0=3
;               r12 = IOC
;
A1KeyVec
        TEQ     r0, #3                  ; if not set LED
        TEQNE   r0, #4                  ;     and not enable then
        MOVNE   pc, lr                  ;   pass it on

        Push    "r0,r1,r11,lr"

        MOV     r11, #KeyWorkSpace

        TEQ     r0, #4                  ; if enable then
        MOVEQ   r0, #0
        STREQB  r0, JustGotKbId         ;   clear flag
        RXon    r0, EQ                  ;   enable RX IRQs
        Pull    "r0,r1,r11,pc",EQ       ;   and pass on call

        LDRB    r0, KbId
        CMP     r0, #1                  ; if id >= 1 then new (C=1)
        BCS     %FT10

        TST     r1, #1
        MOVEQ   r1, #LEDOFF
        MOVNE   r1, #LEDON
10
        STRB    r1, RequestLED
        TXon    r0

        Pull    "r0,r1,r11,pc"

 [ AssemblePointerV

; *****************************************************************************
;
;       A1Pointer - Return mouse movements on PointerV poll.
;
;       In:     r0 = reason code 0
;               r1 = pointer device type (must be 0 for us)
;       Out:    r2 = signed 32-bit X movement
;               r3 = signed 32-bit Y movement
;
A1Pointer
        TEQ     r0, #0                  ; If not poll
        TEQEQ   r1, #0                  ;     or not type 0 then
        MOVNE   pc, lr                  ;   pass on call.

        LDR     r2, MouseXCount
        STR     r0, MouseXCount
        LDR     r3, MouseYCount
        STR     r0, MouseYCount

        Pull    pc                      ; Claim call.
 ]

; *****************************************************************************
;
;       IRQ routine
;
; in:   R2 = IOC request B flags
;       R0-R3, R11, R12 already saved, R14 irrelevant


        [ AssemblingArthur
IrqRx   ROUT
        Push    "R4-R10, R14"           ; stack regs if new MOS IRQ vector
        |
KeyIrq  ROUT
        TST     R2, #KARTTxBit          ; transmit empty ?
        BNE     IrqTx
        Push    "R4-R10"
        MOV     R12, #IOC               ; already set up in new IRQ scheme
        ]
        MOV     R11, #KeyWorkSpace

; Keyboard receive interrupt

; We now have to wait around for a period of 16 microseconds (or so they say)
; because of the hardware design.

; This is doubly annoying because I have no idea what speed this processor is
; going at, so I don't know how many S-cycles this is, and there aren't enough
; hardware timers around to waste one doing this thankless task.

; In addition, because I am on the IRQ vector, the other IRQ users have
; probably wasted at least 16 microseconds anyway - at least the code seems
; to work perfectly well without this delay loop.

; Nevertheless, until we can come up with a better solution, I shall do a
; delay of (about) 16*8 S-cycles.
;

        MOV     R0, #16*8/5             ; delay for an unspecified period
IrqRxDelayLoop
        SUBS    R0, R0, #1              ; this breaks my heart,
        BNE     IrqRxDelayLoop          ; it really does !

        LDRB    R0, KARTRx              ; get data byte
        LDRB    R1, ResetState          ; and what we sent last

        CMP     R0, #K1rak2             ; is it a reset thingy ?
        BCS     ProcessReset            ; [yes, so check it]

        CMP     R1, #K1rak2             ; are we resetting anyway ?
        BCS     IrqBadRx                ; if so then bad reset

        AND     R2, R0, #&F0            ; get reason code

        LDRB    R1, LastKbId            ; get last keyboard ID
        TEQ     R1, #&FF                ; is it valid yet ?
        BNE     ValidKbId               ; [yes, so we know what to expect]

        TEQ     R2, #IDTYPE             ; is it old keyboard id
        BEQ     IsOldKeyboard           ; [is old keyboard]

        BIC     R2, R2, #K1kbidmask     ; check for new keyboard id
        TEQ     R2, #K1kbid
        BNE     IrqBadRx                ; not a keyboard id, so reset

        AND     R1, R0, #K1kbidmask     ; get relevant bits
 [ AssembleA1KeyHandler
        ADRL    R0, NewKeyStruct
 ]
        B       AcknowledgeId

IsOldKeyboard
        AND     R0, R0, #&0F            ; get ID part
        LDRB    R1, KbIdHalf
        TST     R1, #&80
        STRNEB  R0, KbIdHalf            ; got half of keyboard id
        MOVNE   R0, #K1nack
        BNE     IrqRxAck

        ORR     R1, R1, R0, LSL #4      ; get full keyboard id
        MOV     R0, #&FF
        STRB    R0, KbIdHalf
 [ AssembleA1KeyHandler
        ADRL    R0, OldKeyStruct
 ]

AcknowledgeId
 [ AssembleA1KeyHandler
        LDRB    R8, LastKbId            ; get last keyboard id
        TEQ     R8, R1                  ; is it same
        STRNE   R0, KeyVec              ; if different, set up our handler
 ]
        MOV     R0, #&FF
        STRB    R0, JustGotKbId         ; tell TX handler to disable interrupts until KEYV enable call

 [ AssembleKEYV
        MOV     r0, #0
        MOV     r10, #KEYV
        BL      CallVector
 |
        BL      GotKbId
 ]

        B       IrqRxAckScan            ; send ack

; R1 = keyboard ID - now dispatch code

ValidKbId
        TEQ     R1, #0
        BNE     NewKeyboardDispatch

OldKeyboardDispatch
        TST     R0, #MMOVED             ; is it mouse data ?
        BNE     ProcessOldMouseData
        TEQ     R2, #KEYDOWN            ; is it key down ?
        BEQ     ProcessOldKeyDown
        TEQ     R2, #KEYUP              ; is it key up ?
        BEQ     ProcessOldKeyUp
        TEQ     R2, #SPDDONE            ; is it SPD data ?
        BEQ     ProcessOldSPDData
        B       IrqBadRx                ; spurious

NewKeyboardDispatch
        TST     R2, #K1notmousedata     ; is it mouse data ?
        BEQ     ProcessNewMouseData
        TEQ     R2, #K1kdda             ; is it key down ?
        BEQ     ProcessNewKeyDown
        TEQ     R2, #K1kuda             ; is it key up ?
        BEQ     ProcessNewKeyUp
        TEQ     R2, #K1pdat             ; is it SPD data ?
        BEQ     ProcessNewSPDData
        B       IrqBadRx                ; spurious


; *****************************************************************************
;
;       ProcessReset - Process reset code from keyboard
;
; in:   R0 = code from keyboard
;       R1 = ResetState

ProcessReset ROUT

; Check sequencing

        TEQ     R1, R0                  ; is reply what was expected
        BNE     IrqBadRx                ; no, so reset

; Now continue the sequence

        TEQ     R1, #K1rak2             ; end of sequence ?
        MOVEQ   R1, #K1nack             ; then send a nack
        SUBNE   R1, R1, #1              ; else next thing to go
        STRB    R1, ResetState          ; store back

        TXonRXoff R0

        Pull    $irqregs

IrqBadRx

; Restart the reset sequence

        BL      A1Reset
        Pull    $irqregs

; *****************************************************************************

ProcessOldSPDData
ProcessNewSPDData
        LDRB    R1, SPDRec
        SUBS    R1, R1, #1
        STRCSB  R1, SPDRec                      ; dec number to go (if not 0)

        LDRCS   R1, SPDoutput
        MOVCS   R1, R1, LSR #4
        ORRCS   R1, R1, R0, LSL #28             ; put in new data
        STRCS   R1, SPDoutput

        B       IrqRxAckScan

; *****************************************************************************

ProcessOldMouseData                     ; R0 = 01xx xxxx
        TST     R0, #&20                ; get sign bit of data (bit 5)
        BICEQ   R0, R0, #&40            ; move to bit 6 (where it is on new)
ProcessNewMouseData
        LDRB    R1, MouseCount
        ADR     R2, MouseDelta
        STRB    R0, [R2, R1]            ; no need to clear top bit

        EORS    R1, R1, #1              ; move to other coordinate
        STRB    R1, MouseCount

        MOVNE   R0, #K1back
        BNE     IrqRxAck

        LDRB    R3, [R2, #1]            ; get delta Y
        MOV     R3, R3, LSL #25         ; sign extend it
        MOV     R3, R3, ASR #25

        LDRB    R2, [R2]                ; get delta X
        MOV     R2, R2, LSL #25         ; sign extend it
        MOV     R2, R2, ASR #25

 [ AssemblePointerV
        LDR     r0, MouseXCount
        ADD     r0, r0, r2
        STR     r0, MouseXCount
        LDR     r0, MouseYCount
        ADD     r0, r0, r3
        STR     r0, MouseYCount
 |
        BL      ProcessMouseXY
 ]

        B       IrqRxAckScan

; *****************************************************************************

; in:   R1 = keyboard id

ProcessOldKeyDown
ProcessNewKeyDown ROUT
        LDRB    R2, KeyRow
        TEQ     R2, #&FF                ; have we had a row already ?
        STREQB  R0, KeyRow              ; no so store row
        MOVEQ   R0, #K1back
        BEQ     IrqRxAck                ; and acknowledge Rx

        EOR     R3, R0, R2              ; test if save movement type
        TST     R3, #&F0
        BNE     IrqBadRx                ; not same, so reset

        AND     R0, R0, #&0F            ; get new data
        AND     R2, R2, #&0F            ; and row data

        TEQ     R1, #0
        ORREQ   R2, R2, R0, LSL #4      ; old keyboard number
        ORRNE   R2, R0, R2, LSL #4      ; new key number

        MOV     R0, #&FF
        STRB    R0, KeyRow              ; reset 'had row' flag

        MOV     r0, #2                  ; indicate key down
        MOV     r1, r2
 [ AssembleKEYV
        MOV     r10, #KEYV
        BL      CallVector
        MOV     r12, #IOC
 |
        BL      GotKey
 ]

IrqRxAckScan

; Re-enable Tx interrupts and queue an acknowledge

        MOV     R0, #K1ack              ; either sack or smak as appropriate
IrqRxAck
        STRB    R0, Reply
        TXonRXoff       R0
        Pull    $irqregs                ; claimed irq, so grab link and PC

; *****************************************************************************

; in:   R1 = keyboard id

ProcessOldKeyUp
ProcessNewKeyUp ROUT
        LDRB    R2, KeyRow
        TEQ     R2, #&FF                ; have we had a row already ?
        STREQB  R0, KeyRow              ; no so store row
        MOVEQ   R0, #K1back
        BEQ     IrqRxAck                ; and acknowledge Rx

        EOR     R3, R0, R2              ; test if save movement type
        TST     R3, #&F0
        BNE     IrqBadRx                ; not same, so reset

        AND     R0, R0, #&0F            ; get new data
        AND     R2, R2, #&0F            ; and row data

        TEQ     R1, #0
        ORREQ   R2, R2, R0, LSL #4      ; old key number
        ORRNE   R2, R0, R2, LSL #4      ; new key number

        MOV     R0, #&FF
        STRB    R0, KeyRow              ; reset 'had row' flag

        MOV     r0, #1                  ; indicate key up
        MOV     r1, r2
 [ AssembleKEYV
        MOV     r10, #KEYV
        BL      CallVector
        MOV     r12, #IOC
 |
        BL      GotKey
 ]

        B       IrqRxAckScan

; *****************************************************************************

IrqTx   ROUT
        [ AssemblingArthur
        Push    "R4-R10, R14"           ; stack regs if new MOS IRQ vector
        |
        Push    "R4-R10"
        MOV     R12, #IOC               ; already set up in new IRQ scheme
        ]
        MOV     R11, #KeyWorkSpace

; First see if we're in a reset sequence

        LDRB    R0, ResetState          ; are we in a reset ?
        TEQ     R0, #0
        BEQ     %FT05                   ; not in a reset

        CMP     R0, #K1rak2             ; are we sending the reset nack ?
        BCS     %FT25                   ; no, just send reset code
        MOV     R1, #0                  ; yes, zero the reset state
        STRB    R1, ResetState
        STRB    R0, KARTTx
        Pull    $irqregs                ; don't disable TX

; Now see if any outstanding requests

05
        LDRB    R0, RequestSPD          ; is there an SPD request ?
        TEQ     R0, #0
        BEQ     %FT10                   ; [no SPD request]

        MOV     R1, #K1prst             ; code to send keyboard
        MOV     R2, #0                  ; no further SPD request
        STRB    R2, RequestSPD
        MOV     R2, #8
        STRB    R2, SPDRec              ; nibbles still to be sent/received
        STRB    R1, KARTTx              ; send the byte
        Pull    $irqregs                ; exit without disabling Tx

10
        LDRB    R0, RequestKbId         ; is there a pending keyboard request ?
        TEQ     R0, #0
        MOVNE   R1, #0
        STRNEB  R1, RequestKbId         ; no further request
        STRNEB  R0, KARTTx              ; send the byte
        Pull    $irqregs, NE            ; exit without disabling Tx

        LDRB    R0, RequestMouse        ; is there a pending mouse request ?
        TEQ     R0, #0
        MOVNE   R1, #0
        STRNEB  R1, RequestMouse        ; no further request
        STRNEB  R0, KARTTx
        Pull    $irqregs, NE            ; exit without disabling Tx

        LDRB    R0, RequestLED          ; is there a pending LED request ?
        TEQ     R0, #&FF
        MOVNE   R1, #&FF
        STRNEB  R1, RequestLED
        STRNEB  R0, KARTTx
        Pull    $irqregs, NE            ; exit without disabling Tx

        LDRB    R0, SPDRec              ; are we converting some SPD data
        TEQ     R0, #0
        BEQ     %FT20                   ; branch if not

        LDR     R1, SPDinput
        AND     R2, R1, #&F             ; get nybble to be sent
        ORR     R2, R2, #K1rqpd
        MOV     R1, R1, LSR #4          ; shift out the nybble sent
        STR     R1, SPDinput
        STRB    R2, KARTTx
        B       %FT30                   ; disable Tx, so we don't send another
                                        ; nibble before we get the conversion
20
        LDRB    R0, Reply
        TEQ     R0, #&FF
        BEQ     %FT30                   ; no reply to send
25
        STRB    R0, KARTTx              ; send the reply
        MOV     R0, #&FF
        STRB    R0, Reply               ; nothing else to send

        LDRB    R0, JustGotKbId
        TEQ     R0, #0                  ; if just got keyboard id then
        TXoff   R0, NE                  ;   disable all interrupts
        Pull    $irqregs, NE            ;   and wait for KEYV enable call
30
        RXonTXoff R0
        Pull    $irqregs

        END
@


4.2
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@@


4.1
log
@Initial revision
@
text
@a27 3
        [ PollMouse
K1ack   *       K1sack
        |
a28 1
        ]
@


4.1.8.1
log
@Strip out some old build switches
Detail:
  hdr/Options, s/ArthurSWIs, s/ChangeDyn, s/PMF/KbdDrA1, s/PMF/key, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdugrafhal, s/vdu/vdugrafv, s/vdu/vdumodes, s/vdu/vduwrch:
  - Strip out DoingVdu build switch (did nothing)
  - Strip out Japanese16BitSound switch (did nothing)
  - Strip out MakeModeSelectorsForModeNUmbers switch (altered the mode list structures, but there wasn't any code to do anything with the new data)
  - Strip out remaining uses of UseGraphicsV switch (now hardwired to {TRUE})
  - Strip out ShadowROM switch (altered FixedAreasTable to show the shadow mapping, but code to create the mapping is missing)
  - Strip out PollMouse switch (old Archimedes-era debug/development option)
Admin:
  Tested on BB-xM
  Builds to same binary as previous version


Version 5.35, 4.79.2.204. Tagged as 'Kernel-5_35-4_79_2_204'
@
text
@d28 3
d32 1
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d228 1
d231 7
d524 1
d526 4
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

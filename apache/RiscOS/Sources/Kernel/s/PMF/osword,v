head	4.5;
access;
symbols
	Kernel-6_14:4.5
	Kernel-6_01-3:4.5
	Kernel-6_13:4.5
	Kernel-6_12:4.5
	Kernel-6_11:4.5
	Kernel-6_10:4.5
	Kernel-6_09:4.5
	Kernel-6_08-4_129_2_10:4.5
	Kernel-6_08-4_129_2_9:4.5
	Kernel-6_08:4.5
	Kernel-6_07:4.5
	Kernel-6_06:4.5
	Kernel-6_05-4_129_2_8:4.5
	Kernel-6_05:4.5
	Kernel-6_04:4.5
	Kernel-6_03:4.5
	Kernel-6_01-2:4.5
	Kernel-6_01-4_146_2_1:4.5
	Kernel-6_02:4.5
	Kernel-6_01-1:4.5
	Kernel-6_01:4.5
	Kernel-6_00:4.5
	Kernel-5_99:4.5
	Kernel-5_98:4.5
	Kernel-5_97-4_129_2_7:4.5
	Kernel-5_97:4.5
	Kernel-5_96:4.5
	Kernel-5_95:4.5
	Kernel-5_94:4.5
	Kernel-5_93:4.5
	Kernel-5_92:4.5
	Kernel-5_91:4.5
	Kernel-5_90:4.5
	Kernel-5_89-4_129_2_6:4.5
	Kernel-5_89:4.5
	Kernel-5_88-4_129_2_5:4.5
	Kernel-5_88-4_129_2_4:4.5
	Kernel-5_88:4.5
	Kernel-5_87:4.5
	Kernel-5_86-4_129_2_3:4.5
	Kernel-5_86-4_129_2_2:4.5
	Kernel-5_86-4_129_2_1:4.5
	Kernel-5_86:4.5
	SMP:4.5.0.2
	SMP_bp:4.5
	Kernel-5_85:4.5
	Kernel-5_54-1:4.5
	Kernel-5_84:4.5
	Kernel-5_83:4.5
	Kernel-5_82:4.5
	Kernel-5_81:4.5
	Kernel-5_80:4.5
	Kernel-5_79:4.5
	Kernel-5_78:4.5
	Kernel-5_77:4.5
	Kernel-5_76:4.5
	Kernel-5_75:4.5
	Kernel-5_74:4.5
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.5
	Kernel-5_64:4.5
	Kernel-5_63:4.5
	Kernel-5_62:4.5
	Kernel-5_61:4.5
	Kernel-5_60:4.5
	Kernel-5_59:4.5
	Kernel-5_58:4.5
	Kernel-5_57:4.5
	Kernel-5_56:4.5
	Kernel-5_55:4.5
	Kernel-5_54:4.5
	Kernel-5_53:4.5
	Kernel-5_52:4.5
	Kernel-5_51:4.5
	Kernel-5_50:4.5
	Kernel-5_49:4.5
	HAL_merge:4.4.2.9
	Kernel-5_48:4.5
	Kernel-5_35-4_79_2_327:4.4.2.9
	Kernel-5_35-4_79_2_326:4.4.2.9
	Kernel-5_35-4_79_2_325:4.4.2.9
	Kernel-5_35-4_79_2_324:4.4.2.9
	Kernel-5_35-4_79_2_323:4.4.2.9
	Kernel-5_35-4_79_2_322:4.4.2.9
	Kernel-5_35-4_79_2_321:4.4.2.9
	Kernel-5_35-4_79_2_320:4.4.2.9
	Kernel-5_35-4_79_2_319:4.4.2.9
	Kernel-5_35-4_79_2_318:4.4.2.9
	Kernel-5_35-4_79_2_317:4.4.2.8
	Kernel-5_35-4_79_2_316:4.4.2.8
	Kernel-5_35-4_79_2_315:4.4.2.8
	Kernel-5_35-4_79_2_314:4.4.2.8
	Kernel-5_35-4_79_2_313:4.4.2.8
	Kernel-5_35-4_79_2_312:4.4.2.8
	Kernel-5_35-4_79_2_311:4.4.2.8
	Kernel-5_35-4_79_2_310:4.4.2.8
	Kernel-5_35-4_79_2_309:4.4.2.8
	Kernel-5_35-4_79_2_308:4.4.2.8
	Kernel-5_35-4_79_2_307:4.4.2.8
	Kernel-5_35-4_79_2_306:4.4.2.8
	Kernel-5_35-4_79_2_305:4.4.2.8
	Kernel-5_35-4_79_2_304:4.4.2.8
	Kernel-5_35-4_79_2_303:4.4.2.8
	Kernel-5_35-4_79_2_302:4.4.2.8
	Kernel-5_35-4_79_2_301:4.4.2.8
	Kernel-5_35-4_79_2_300:4.4.2.8
	Kernel-5_35-4_79_2_299:4.4.2.8
	Kernel-5_35-4_79_2_298:4.4.2.8
	Kernel-5_35-4_79_2_297:4.4.2.8
	Kernel-5_35-4_79_2_296:4.4.2.8
	Kernel-5_35-4_79_2_295:4.4.2.8
	Kernel-5_35-4_79_2_294:4.4.2.8
	Kernel-5_35-4_79_2_293:4.4.2.8
	Kernel-5_35-4_79_2_292:4.4.2.8
	Kernel-5_35-4_79_2_291:4.4.2.8
	Kernel-5_35-4_79_2_290:4.4.2.8
	Kernel-5_35-4_79_2_289:4.4.2.8
	Kernel-5_35-4_79_2_288:4.4.2.8
	Kernel-5_35-4_79_2_287:4.4.2.8
	Kernel-5_35-4_79_2_286:4.4.2.8
	Kernel-5_35-4_79_2_285:4.4.2.8
	Kernel-5_35-4_79_2_284:4.4.2.8
	Kernel-5_35-4_79_2_283:4.4.2.8
	Kernel-5_35-4_79_2_282:4.4.2.8
	Kernel-5_35-4_79_2_281:4.4.2.8
	Kernel-5_35-4_79_2_280:4.4.2.8
	Kernel-5_35-4_79_2_279:4.4.2.8
	Kernel-5_35-4_79_2_278:4.4.2.8
	Kernel-5_35-4_79_2_277:4.4.2.8
	Kernel-5_35-4_79_2_276:4.4.2.8
	Kernel-5_35-4_79_2_275:4.4.2.8
	Kernel-5_35-4_79_2_274:4.4.2.8
	Kernel-5_35-4_79_2_273:4.4.2.8
	Kernel-5_35-4_79_2_272:4.4.2.8
	Kernel-5_35-4_79_2_271:4.4.2.8
	Kernel-5_35-4_79_2_270:4.4.2.8
	Kernel-5_35-4_79_2_269:4.4.2.8
	Kernel-5_35-4_79_2_268:4.4.2.8
	Kernel-5_35-4_79_2_267:4.4.2.8
	Kernel-5_35-4_79_2_266:4.4.2.8
	Kernel-5_35-4_79_2_265:4.4.2.8
	Kernel-5_35-4_79_2_264:4.4.2.8
	Kernel-5_35-4_79_2_263:4.4.2.8
	Kernel-5_35-4_79_2_262:4.4.2.8
	Kernel-5_35-4_79_2_261:4.4.2.8
	Kernel-5_35-4_79_2_260:4.4.2.8
	Kernel-5_35-4_79_2_259:4.4.2.8
	Kernel-5_35-4_79_2_258:4.4.2.8
	Kernel-5_35-4_79_2_257:4.4.2.8
	Kernel-5_35-4_79_2_256:4.4.2.8
	Kernel-5_35-4_79_2_255:4.4.2.8
	Kernel-5_35-4_79_2_254:4.4.2.8
	Kernel-5_35-4_79_2_253:4.4.2.8
	Kernel-5_35-4_79_2_252:4.4.2.8
	Kernel-5_35-4_79_2_251:4.4.2.8
	Kernel-5_35-4_79_2_250:4.4.2.8
	Kernel-5_35-4_79_2_249:4.4.2.8
	Kernel-5_35-4_79_2_248:4.4.2.8
	Kernel-5_35-4_79_2_247:4.4.2.8
	Kernel-5_35-4_79_2_246:4.4.2.8
	Kernel-5_35-4_79_2_245:4.4.2.8
	Kernel-5_35-4_79_2_244:4.4.2.8
	Kernel-5_35-4_79_2_243:4.4.2.8
	Kernel-5_35-4_79_2_242:4.4.2.8
	Kernel-5_35-4_79_2_241:4.4.2.8
	Kernel-5_35-4_79_2_240:4.4.2.8
	Kernel-5_35-4_79_2_239:4.4.2.8
	Kernel-5_35-4_79_2_238:4.4.2.8
	Kernel-5_35-4_79_2_237:4.4.2.8
	Kernel-5_35-4_79_2_236:4.4.2.8
	Kernel-5_35-4_79_2_235:4.4.2.8
	Kernel-5_35-4_79_2_234:4.4.2.8
	Kernel-5_35-4_79_2_233:4.4.2.8
	Kernel-5_35-4_79_2_232:4.4.2.8
	Kernel-5_35-4_79_2_231:4.4.2.8
	Kernel-5_35-4_79_2_230:4.4.2.8
	Kernel-5_35-4_79_2_229:4.4.2.8
	Kernel-5_35-4_79_2_228:4.4.2.8
	Kernel-5_35-4_79_2_227:4.4.2.8
	Kernel-5_35-4_79_2_226:4.4.2.8
	Kernel-5_35-4_79_2_225:4.4.2.8
	Kernel-5_35-4_79_2_224:4.4.2.8
	Kernel-5_35-4_79_2_223:4.4.2.8
	Kernel-5_35-4_79_2_222:4.4.2.8
	Kernel-5_35-4_79_2_221:4.4.2.8
	Kernel-5_35-4_79_2_220:4.4.2.8
	Kernel-5_35-4_79_2_219:4.4.2.8
	Kernel-5_35-4_79_2_218:4.4.2.8
	Kernel-5_35-4_79_2_217:4.4.2.8
	Kernel-5_35-4_79_2_216:4.4.2.8
	Kernel-5_35-4_79_2_215:4.4.2.8
	Kernel-5_35-4_79_2_214:4.4.2.8
	Kernel-5_35-4_79_2_213:4.4.2.8
	Kernel-5_35-4_79_2_212:4.4.2.8
	Kernel-5_35-4_79_2_211:4.4.2.8
	Kernel-5_35-4_79_2_210:4.4.2.8
	Kernel-5_35-4_79_2_209:4.4.2.8
	Kernel-5_35-4_79_2_208:4.4.2.8
	Kernel-5_35-4_79_2_207:4.4.2.8
	Kernel-5_35-4_79_2_206:4.4.2.8
	Kernel-5_35-4_79_2_205:4.4.2.8
	Kernel-5_35-4_79_2_204:4.4.2.8
	Kernel-5_35-4_79_2_203:4.4.2.8
	Kernel-5_35-4_79_2_202:4.4.2.8
	Kernel-5_35-4_79_2_201:4.4.2.7
	Kernel-5_35-4_79_2_200:4.4.2.7
	Kernel-5_35-4_79_2_199:4.4.2.7
	Kernel-5_35-4_79_2_198:4.4.2.7
	Kernel-5_35-4_79_2_197:4.4.2.7
	Kernel-5_35-4_79_2_196:4.4.2.7
	Kernel-5_35-4_79_2_195:4.4.2.7
	Kernel-5_35-4_79_2_194:4.4.2.7
	Kernel-5_35-4_79_2_193:4.4.2.7
	Kernel-5_35-4_79_2_192:4.4.2.7
	Kernel-5_35-4_79_2_191:4.4.2.7
	Kernel-5_35-4_79_2_190:4.4.2.7
	Kernel-5_35-4_79_2_189:4.4.2.7
	Kernel-5_35-4_79_2_188:4.4.2.7
	Kernel-5_35-4_79_2_187:4.4.2.7
	Kernel-5_35-4_79_2_186:4.4.2.7
	Kernel-5_35-4_79_2_185:4.4.2.7
	Kernel-5_35-4_79_2_184:4.4.2.6
	Kernel-5_35-4_79_2_183:4.4.2.6
	Kernel-5_35-4_79_2_182:4.4.2.6
	Kernel-5_35-4_79_2_181:4.4.2.6
	Kernel-5_35-4_79_2_180:4.4.2.6
	Kernel-5_35-4_79_2_179:4.4.2.6
	Kernel-5_35-4_79_2_178:4.4.2.6
	Kernel-5_35-4_79_2_177:4.4.2.6
	Kernel-5_35-4_79_2_176:4.4.2.6
	Kernel-5_35-4_79_2_175:4.4.2.6
	Kernel-5_35-4_79_2_174:4.4.2.6
	Kernel-5_35-4_79_2_173:4.4.2.6
	Kernel-5_35-4_79_2_172:4.4.2.6
	Kernel-5_35-4_79_2_171:4.4.2.6
	Kernel-5_35-4_79_2_170:4.4.2.6
	Kernel-5_35-4_79_2_169:4.4.2.6
	Kernel-5_35-4_79_2_168:4.4.2.6
	Kernel-5_35-4_79_2_167:4.4.2.6
	Kernel-5_35-4_79_2_166:4.4.2.6
	Kernel-5_35-4_79_2_165:4.4.2.6
	RPi_merge:4.4.2.6
	Kernel-5_35-4_79_2_147_2_23:4.4.2.6
	Kernel-5_35-4_79_2_147_2_22:4.4.2.6
	Kernel-5_35-4_79_2_147_2_21:4.4.2.6
	Kernel-5_35-4_79_2_147_2_20:4.4.2.6
	Kernel-5_35-4_79_2_147_2_19:4.4.2.6
	Kernel-5_35-4_79_2_147_2_18:4.4.2.6
	Kernel-5_35-4_79_2_164:4.4.2.6
	Kernel-5_35-4_79_2_163:4.4.2.6
	Kernel-5_35-4_79_2_147_2_17:4.4.2.6
	Kernel-5_35-4_79_2_147_2_16:4.4.2.6
	Kernel-5_35-4_79_2_147_2_15:4.4.2.6
	Kernel-5_35-4_79_2_162:4.4.2.6
	Kernel-5_35-4_79_2_161:4.4.2.6
	Kernel-5_35-4_79_2_147_2_14:4.4.2.6
	Kernel-5_35-4_79_2_147_2_13:4.4.2.6
	Kernel-5_35-4_79_2_160:4.4.2.6
	Kernel-5_35-4_79_2_159:4.4.2.6
	Kernel-5_35-4_79_2_158:4.4.2.6
	Kernel-5_35-4_79_2_157:4.4.2.6
	Kernel-5_35-4_79_2_156:4.4.2.6
	Kernel-5_35-4_79_2_147_2_12:4.4.2.6
	Kernel-5_35-4_79_2_147_2_11:4.4.2.6
	Kernel-5_35-4_79_2_155:4.4.2.6
	Kernel-5_35-4_79_2_147_2_10:4.4.2.6
	Kernel-5_35-4_79_2_154:4.4.2.6
	Kernel-5_35-4_79_2_153:4.4.2.6
	Kernel-5_35-4_79_2_147_2_9:4.4.2.6
	Kernel-5_35-4_79_2_152:4.4.2.6
	Kernel-5_35-4_79_2_151:4.4.2.6
	Kernel-5_35-4_79_2_147_2_8:4.4.2.6
	Kernel-5_35-4_79_2_147_2_7:4.4.2.6
	Kernel-5_35-4_79_2_150:4.4.2.6
	Kernel-5_35-4_79_2_147_2_6:4.4.2.6
	Kernel-5_35-4_79_2_147_2_5:4.4.2.6
	Kernel-5_35-4_79_2_149:4.4.2.6
	Kernel-5_35-4_79_2_147_2_4:4.4.2.6
	Kernel-5_35-4_79_2_147_2_3:4.4.2.6
	Kernel-5_35-4_79_2_148:4.4.2.6
	Kernel-5_35-4_79_2_147_2_2:4.4.2.6
	Kernel-5_35-4_79_2_147_2_1:4.4.2.6
	RPi:4.4.2.6.0.2
	RPi_bp:4.4.2.6
	Kernel-5_35-4_79_2_98_2_52_2_1:4.4.2.2.2.5
	alees_Kernel_dev:4.4.2.2.2.5.0.2
	alees_Kernel_dev_bp:4.4.2.2.2.5
	Kernel-5_35-4_79_2_147:4.4.2.6
	Kernel-5_35-4_79_2_146:4.4.2.6
	Kernel-5_35-4_79_2_145:4.4.2.6
	Kernel-5_35-4_79_2_144:4.4.2.6
	Kernel-5_35-4_79_2_143:4.4.2.5
	Kernel-5_35-4_79_2_142:4.4.2.5
	Kernel-5_35-4_79_2_141:4.4.2.5
	Kernel-5_35-4_79_2_140:4.4.2.5
	Kernel-5_35-4_79_2_139:4.4.2.5
	Kernel-5_35-4_79_2_138:4.4.2.5
	Kernel-5_35-4_79_2_137:4.4.2.5
	Kernel-5_35-4_79_2_136:4.4.2.5
	Kernel-5_35-4_79_2_135:4.4.2.5
	Kernel-5_35-4_79_2_134:4.4.2.5
	Kernel-5_35-4_79_2_133:4.4.2.5
	Kernel-5_35-4_79_2_132:4.4.2.5
	Kernel-5_35-4_79_2_131:4.4.2.5
	Kernel-5_35-4_79_2_130:4.4.2.5
	Kernel-5_35-4_79_2_129:4.4.2.5
	Kernel-5_35-4_79_2_128:4.4.2.5
	Kernel-5_35-4_79_2_127:4.4.2.5
	Kernel-5_35-4_79_2_126:4.4.2.4
	Kernel-5_35-4_79_2_125:4.4.2.4
	Kernel-5_35-4_79_2_124:4.4.2.4
	Kernel-5_35-4_79_2_123:4.4.2.4
	Cortex_merge:4.4.2.2.2.6
	Kernel-5_35-4_79_2_122:4.4.2.3
	Kernel-5_35-4_79_2_98_2_54:4.4.2.2.2.6
	Kernel-5_35-4_79_2_98_2_53:4.4.2.2.2.6
	Kernel-5_35-4_79_2_98_2_52:4.4.2.2.2.5
	Kernel-5_35-4_79_2_98_2_51:4.4.2.2.2.5
	Kernel-5_35-4_79_2_98_2_50:4.4.2.2.2.5
	Kernel-5_35-4_79_2_98_2_49:4.4.2.2.2.5
	Kernel-5_35-4_79_2_98_2_48:4.4.2.2.2.5
	Kernel-5_35-4_79_2_121:4.4.2.3
	Kernel-5_35-4_79_2_98_2_47:4.4.2.2.2.4
	Kernel-5_35-4_79_2_120:4.4.2.3
	Kernel-5_35-4_79_2_98_2_46:4.4.2.2.2.4
	Kernel-5_35-4_79_2_119:4.4.2.3
	Kernel-5_35-4_79_2_98_2_45:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_44:4.4.2.2.2.4
	Kernel-5_35-4_79_2_118:4.4.2.3
	Kernel-5_35-4_79_2_98_2_43:4.4.2.2.2.4
	Kernel-5_35-4_79_2_117:4.4.2.3
	Kernel-5_35-4_79_2_116:4.4.2.3
	Kernel-5_35-4_79_2_98_2_42:4.4.2.2.2.4
	Kernel-5_35-4_79_2_115:4.4.2.3
	Kernel-5_35-4_79_2_98_2_41:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_40:4.4.2.2.2.4
	Kernel-5_35-4_79_2_114:4.4.2.3
	Kernel-5_35-4_79_2_98_2_39:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_38:4.4.2.2.2.4
	Kernel-5_35-4_79_2_113:4.4.2.3
	Kernel-5_35-4_79_2_112:4.4.2.3
	Kernel-5_35-4_79_2_98_2_37:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_36:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_35:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_34:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_33:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_32:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_31:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_30:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_29:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_28:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_27:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_26:4.4.2.2.2.4
	Kernel-5_35-4_79_2_111:4.4.2.3
	Kernel-5_35-4_79_2_98_2_25:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_24:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_23:4.4.2.2.2.4
	Kernel-5_35-4_79_2_110:4.4.2.3
	Kernel-5_35-4_79_2_98_2_22:4.4.2.2.2.4
	Kernel-5_35-4_79_2_109:4.4.2.3
	Kernel-5_35-4_79_2_98_2_21:4.4.2.2.2.4
	Kernel-5_35-4_79_2_98_2_20:4.4.2.2.2.3
	Kernel-5_35-4_79_2_108:4.4.2.3
	Kernel-5_35-4_79_2_107:4.4.2.3
	Kernel-5_35-4_79_2_98_2_19:4.4.2.2.2.3
	Kernel-5_35-4_79_2_98_2_18:4.4.2.2.2.3
	Kernel-5_35-4_79_2_98_2_17:4.4.2.2.2.3
	Kernel-5_35-4_79_2_98_2_16:4.4.2.2.2.3
	Kernel-5_35-4_79_2_98_2_15:4.4.2.2.2.3
	Kernel-5_35-4_79_2_106:4.4.2.2
	Kernel-5_35-4_79_2_105:4.4.2.2
	Kernel-5_35-4_79_2_104:4.4.2.2
	Kernel-5_35-4_79_2_98_2_14:4.4.2.2.2.3
	Kernel-5_35-4_79_2_98_2_13:4.4.2.2.2.3
	Kernel-5_35-4_79_2_98_2_12:4.4.2.2.2.3
	Kernel-5_35-4_79_2_98_2_11:4.4.2.2.2.3
	Kernel-5_35-4_79_2_98_2_10:4.4.2.2.2.2
	Kernel-5_35-4_79_2_98_2_9:4.4.2.2.2.2
	Kernel-5_35-4_79_2_103:4.4.2.2
	Kernel-5_35-4_79_2_102:4.4.2.2
	Kernel-5_35-4_79_2_98_2_8:4.4.2.2.2.2
	Kernel-5_35-4_79_2_98_2_7:4.4.2.2.2.1
	Kernel-5_35-4_79_2_98_2_6:4.4.2.2.2.1
	Kernel-5_35-4_79_2_98_2_5:4.4.2.2
	Kernel-5_35-4_79_2_98_2_4:4.4.2.2
	Kernel-5_35-4_79_2_101:4.4.2.2
	Kernel-5_35-4_79_2_100:4.4.2.2
	Kernel-5_35-4_79_2_99:4.4.2.2
	Kernel-5_35-4_79_2_98_2_3:4.4.2.2
	Kernel-5_35-4_79_2_98_2_2:4.4.2.2
	Kernel-5_35-4_79_2_98_2_1:4.4.2.2
	Cortex:4.4.2.2.0.2
	Cortex_bp:4.4.2.2
	Kernel-5_35-4_79_2_98:4.4.2.2
	Kernel-5_35-4_79_2_97:4.4.2.2
	Kernel-5_35-4_79_2_96:4.4.2.2
	Kernel-5_35-4_79_2_95:4.4.2.2
	Kernel-5_35-4_79_2_94:4.4.2.2
	Kernel-5_35-4_79_2_93:4.4.2.2
	Kernel-5_35-4_79_2_92:4.4.2.2
	Kernel-5_35-4_79_2_91:4.4.2.2
	Kernel-5_35-4_79_2_90:4.4.2.2
	Kernel-5_35-4_79_2_89:4.4.2.2
	Kernel-5_35-4_79_2_88:4.4.2.2
	Kernel-5_35-4_79_2_87:4.4.2.2
	Kernel-5_35-4_79_2_86:4.4.2.2
	Kernel-5_35-4_79_2_85:4.4.2.2
	Kernel-5_35-4_79_2_84:4.4.2.2
	Kernel-5_35-4_79_2_83:4.4.2.2
	Kernel-5_35-4_79_2_82:4.4.2.2
	Kernel-5_35-4_79_2_81:4.4.2.2
	Kernel-5_35-4_79_2_80:4.4.2.2
	Kernel-5_35-4_79_2_79:4.4.2.2
	Kernel-5_35-4_79_2_78:4.4.2.2
	Kernel-5_35-4_79_2_77:4.4.2.2
	RO_5_07:4.4.2.2
	Kernel-5_35-4_79_2_76:4.4.2.2
	Kernel-5_35-4_79_2_75:4.4.2.2
	Kernel-5_35-4_79_2_74:4.4.2.2
	Kernel-5_35-4_79_2_73:4.4.2.2
	Kernel-5_35-4_79_2_72:4.4.2.2
	Kernel-5_35-4_79_2_71:4.4.2.2
	Kernel-5_35-4_79_2_70:4.4.2.2
	Kernel-5_35-4_79_2_69:4.4.2.2
	Kernel-5_35-4_79_2_68:4.4.2.2
	Kernel-5_35-4_79_2_67:4.4.2.2
	Kernel-5_35-4_79_2_66:4.4.2.2
	Kernel-5_35-4_79_2_65:4.4.2.2
	Kernel-5_35-4_79_2_64:4.4.2.2
	Kernel-5_35-4_79_2_63:4.4.2.2
	Kernel-5_35-4_79_2_62:4.4.2.2
	Kernel-5_35-4_79_2_61:4.4.2.2
	Kernel-5_35-4_79_2_59:4.4.2.2
	Kernel-5_35-4_79_2_58:4.4.2.2
	Kernel-5_35-4_79_2_57:4.4.2.2
	Kernel-5_35-4_79_2_56:4.4.2.2
	Kernel-5_35-4_79_2_55:4.4.2.2
	Kernel-5_35-4_79_2_54:4.4.2.2
	Kernel-5_35-4_79_2_53:4.4.2.2
	Kernel-5_35-4_79_2_52:4.4.2.2
	Kernel-5_35-4_79_2_51:4.4.2.2
	Kernel-5_35-4_79_2_50:4.4.2.2
	Kernel-5_35-4_79_2_49:4.4.2.2
	Kernel-5_35-4_79_2_48:4.4.2.2
	Kernel-5_47:4.4
	Kernel-5_46-4_90_2_1:4.4
	nbingham_Kernel_FastNC_dev_bp:4.4
	nbingham_Kernel_FastNC_dev:4.4.0.6
	Kernel-5_46:4.4
	Kernel-5_45:4.4
	Kernel-5_35-4_79_2_47:4.4.2.1
	Kernel-5_35-4_79_2_46:4.4.2.1
	Kernel-5_35-4_79_2_45:4.4.2.1
	Kernel-5_35-4_79_2_44:4.4.2.1
	Kernel-5_35-4_79_2_25_2_2:4.4
	Kernel-5_35-4_79_2_43:4.4.2.1
	Kernel-5_35-4_79_2_42:4.4.2.1
	Kernel-5_35-4_79_2_41:4.4.2.1
	Kernel-5_35-4_79_2_40:4.4
	Kernel-5_35-4_79_2_39:4.4
	Kernel-5_35-4_79_2_38:4.4
	Kernel-5_35-4_79_2_37:4.4
	Kernel-5_35-4_79_2_36:4.4
	Kernel-5_35-4_79_2_35:4.4
	Kernel-5_35-4_79_2_34:4.4
	Kernel-5_35-4_79_2_33:4.4
	Kernel-5_35-4_79_2_32:4.4
	Kernel-5_44:4.4
	Kernel-5_35-4_79_2_25_2_1:4.4
	Kernel-5_43:4.4
	Kernel-5_35-4_79_2_31:4.4
	Kernel-5_35-4_79_2_30:4.4
	Kernel-5_35-4_79_2_29:4.4
	Kernel-5_35-4_79_2_28:4.4
	Kernel-5_35-4_79_2_27:4.4
	Kernel-5_35-4_79_2_26:4.4
	Kernel-5_42:4.4
	Kernel-5_41:4.4
	Kernel-5_40:4.4
	Kernel-5_35-4_79_2_25:4.4
	Kernel-5_35-4_79_2_24:4.4
	Kernel-5_35-4_79_2_23:4.4
	Kernel-5_35-4_79_2_22:4.4
	Kernel-5_35-4_79_2_21:4.4
	Kernel-5_35-4_79_2_20:4.4
	Kernel-5_35-4_79_2_19:4.4
	Kernel-5_35-4_79_2_18:4.4
	Kernel-5_35-4_79_2_17:4.4
	Kernel-5_35-4_79_2_16:4.4
	Kernel-5_35-4_79_2_15:4.4
	Kernel-5_35-4_79_2_14:4.4
	Kernel-5_39:4.4
	Kernel-5_13-4_52_2_1:4.3
	Bethany:4.3.0.2
	Kernel-5_38:4.4
	Kernel-5_35-4_79_2_13:4.4
	Kernel-5_35-4_79_2_12:4.4
	Kernel-5_35-4_79_2_11:4.4
	Kernel-5_37:4.4
	Kernel-5_35-4_79_2_10:4.4
	Kernel-5_35-4_79_2_9:4.4
	Kernel-5_36:4.4
	Kernel-5_35-4_79_2_8:4.4
	Kernel-5_35-4_79_2_7:4.4
	Kernel-5_35-4_79_2_6:4.4
	Kernel-5_35-4_79_2_5:4.4
	Kernel-5_35-4_79_2_4:4.4
	Kernel-5_35-4_79_2_3:4.4
	Kernel-5_35-4_79_2_2:4.4
	dellis_autobuild_BaseSW:4.4
	Kernel-5_35-4_79_2_1:4.4
	HAL:4.4.0.2
	Kernel-5_35:4.4
	Kernel-5_34:4.4
	Kernel-5_33:4.4
	Kernel-5_32:4.4
	Kernel-5_31:4.4
	Kernel-5_30:4.4
	Kernel-5_29:4.4
	Kernel-5_28:4.4
	Kernel-5_27:4.4
	Kernel-5_26:4.4
	Kernel-5_25:4.4
	Kernel-5_24:4.4
	Kernel-5_23:4.4
	Kernel-5_22:4.3
	sbrodie_sedwards_16Mar2000:4.3
	Kernel-5_21:4.3
	Kernel-5_20:4.3
	Kernel-5_19:4.3
	Kernel-5_18:4.3
	Kernel-5_17:4.3
	Kernel-5_16:4.3
	Kernel-5_15:4.3
	Kernel-5_14:4.3
	Kernel-5_13:4.3
	Kernel-5_12:4.3
	Kernel-5_11:4.3
	Kernel-5_10:4.3
	Kernel-5_09:4.3
	Kernel-5_08:4.3
	Kernel-5_07:4.3
	Kernel-5_06:4.3
	Kernel-5_05:4.3
	Kernel-5_04:4.3
	Kernel-5_03:4.3
	Kernel-5_02:4.3
	Kernel-5_01:4.3
	Kernel-5_00:4.3
	Kernel-4_99:4.3
	Kernel-4_98:4.3
	Kernel-4_97:4.3
	Kernel-4_96:4.3
	Kernel-4_95:4.3
	Kernel-4_94:4.3
	Kernel-4_93:4.3
	Kernel-4_92:4.3
	Kernel-4_91:4.3
	Kernel-4_90:4.3
	dcotton_autobuild_BaseSW:4.4
	Kernel-4_89:4.3
	Kernel-4_88:4.3
	Kernel-4_87:4.3
	Kernel-4_86:4.3
	Kernel-4_85:4.3
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1.2.1
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1.2.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.2
	Kernel-4_82:4.2
	Kernel-4_81:4.2
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1.2.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.2
	Kernel-4_63-1_1_2_4:4.1.7.2
	Kernel-4_67:4.2
	Kernel-4_66:4.2
	Kernel-4_63-1_1_2_3:4.1.7.2
	Kernel-4_65:4.2
	Ursula_merge:4.1
	Kernel-4_64:4.2
	mstphens_Kernel-3_81:4.1.4.2
	Kernel-4_63-1_1_2_2:4.1.7.2
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2016.06.30.20.08.16;	author jlee;	state Exp;
branches;
next	4.4;
commitid	IWoXxARWeuLDOwcz;

4.4
date	2000.04.04.14.27.38;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	99.08.24.09.37.04;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.09.30.08.42.50;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.31;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	2001.06.26.09.37.12;	author mstephen;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2002.10.07.17.29.44;	author kbracey;	state Exp;
branches
	4.4.2.2.2.1;
next	4.4.2.3;

4.4.2.3
date	2010.01.18.19.07.41;	author jballance;	state Exp;
branches;
next	4.4.2.4;

4.4.2.4
date	2011.11.26.21.11.24;	author jlee;	state Exp;
branches;
next	4.4.2.5;
commitid	cI3W0zbtALQG6TIv;

4.4.2.5
date	2011.11.27.19.18.18;	author rsprowson;	state Exp;
branches;
next	4.4.2.6;
commitid	iuIXfUOByAFYr0Jv;

4.4.2.6
date	2012.03.25.09.19.40;	author rsprowson;	state Exp;
branches;
next	4.4.2.7;
commitid	8lr6mqMI2AotjfYv;

4.4.2.7
date	2013.03.24.14.50.59;	author rsprowson;	state Exp;
branches;
next	4.4.2.8;
commitid	4o2qHvpiOCYJr3Jw;

4.4.2.8
date	2013.11.20.20.25.01;	author rsprowson;	state Exp;
branches;
next	4.4.2.9;
commitid	mPgx586MWbpUx3ex;

4.4.2.9
date	2016.05.08.17.11.12;	author jlee;	state Exp;
branches;
next	;
commitid	H8vGguuJRqFVxH5z;

4.4.2.2.2.1
date	2009.05.10.20.22.31;	author bavison;	state Exp;
branches;
next	4.4.2.2.2.2;

4.4.2.2.2.2
date	2009.05.17.01.34.40;	author bavison;	state Exp;
branches;
next	4.4.2.2.2.3;

4.4.2.2.2.3
date	2009.07.23.00.57.12;	author jlee;	state Exp;
branches;
next	4.4.2.2.2.4;

4.4.2.2.2.4
date	2010.01.24.02.35.26;	author jlee;	state Exp;
branches;
next	4.4.2.2.2.5;

4.4.2.2.2.5
date	2011.08.08.23.28.34;	author jlee;	state Exp;
branches;
next	4.4.2.2.2.6;
commitid	D7rzILnwRRSXoLuv;

4.4.2.2.2.6
date	2011.09.24.19.55.56;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.1.1.1
date	96.11.05.09.41.31;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.02.07;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.16;	author mstphens;	state Exp;
branches
	4.1.4.1.2.1;
next	4.1.4.2;

4.1.4.2
date	98.09.24.13.17.39;	author mstphens;	state Exp;
branches;
next	;

4.1.4.1.2.1
date	98.11.23.14.59.36;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.32;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.19;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	98.09.08.15.25.04;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.PMF.osword

; *****************************************************************************

        MACRO
        WordReturnV $cond

        ASSERT  "$cond"="" :LOR: "$cond"="VS"

        [ "$cond"=""
        LDRVC   R0,[R13]
        ]
        LDM$cond.IB R13,{R1-R4,R11,WsPtr}
        ADD$cond    R13,R13,#8*4 ; R0-R4,R11,WsPtr,R14
        LDR$cond    PC,[R13],#4

        MEND

; Main OsWord entry point
; R0,R1,R2 are parameters


OsWord
        Push    "R0-R4, R11, R12, R14"
        CMP     R0, #(WordTableEnd - WordTableStart) :SHR: 2
        BLLS    OsWordGo                        ; Call the subsid entry pt.
        LDMIA   R13, {R2-R4}                    ; R2=A, R3=X, R4=Y
        MOV     R1, #Service_UKWord             ; osword service reason
        CLRPSR  V_bit, R0                       ; in case there's no service
        BL      Issue_Service
        TEQ     R1, #0
        STMEQIA R13, {R2-R4}                    ; if claimed, then update
                                                ; returned R0-R2
        Pull    "R0-R4, R11, R12, PC"           ; pass V back from service

GoMyOsword
        CLRPSR  V_bit, R4
        Pull    "R0-R4, R11, R12"
        ADD     R13, R13, #4
        Pull    PC

; *****************************************************************************

OsWordGo ROUT
        BYTEWS  WsPtr
10                                              ; Point to despatch table
        ADD     PC, PC, R0, LSL #2              ; add in the action*4 and go
        &       0
        ASSERT  WordTableStart - %BT10 = 8

WordTableStart

        BAL     OsWord00
        BAL     OsWord01
        BAL     OsWord02
        BAL     OsWord03
        BAL     OsWord04
        BAL     OsWord05
        BAL     OsWord06
        BAL     OsWord07

        BAL     OsWord08
        BAL     OsWord09
        BAL     OsWord0A
        BAL     OsWord0B
        BAL     OsWord0C
        BAL     OsWord0D
        BAL     OsWord0E
        BAL     OsWord0F

        BAL     OsWord10
        BAL     OsWord11
        BAL     OsWord12
        BAL     OsWord13
        BAL     OsWord14
        BAL     OsWord15
        BAL     OsWord16

WordTableEnd

; *****************************************************************************
; That's All Folks
; *****************************************************************************

; *****************************************************************************
; The OsWord routines themselves
; *****************************************************************************

; Osword Zero : Input a line

OsWord00 ROUT
      [ NoARMv6 :LOR: NoUnaligned
        LDRB    R0, [R1, #0]            ; lo-byte of address
        LDRB    R2, [R1, #1]            ; hi-byte of address
        ORR     R0, R0, R2, LSL #8      ; R0 := address
      |
        ; Use unaligned load from ARMv6
        LDRH    R0, [R1]                ; 16-bit address(!)
      ]
        LDRB    R2, [R1, #3]            ; lo limit
        LDRB    R3, [R1, #4]            ; hi limit
        LDRB    R1, [R1, #2]            ; length of buffer
        MOV     R4, #0                  ; flags
        SWI     XOS_ReadLine32
        WordReturnV VS

        MOV     R2, R1                  ; put line length into R2
        Pull    "R0,R1,R3"              ; don't overwrite R2
        Pull    "R3, R4, R11, R12"
        ADD     R13, R13, #4
        Pull    PC

; *****************************************************************************

; Read/Write System Clock
; entered with IRQs off
; in:   R0 = 1 => read clock
;       R0 = 2 => write clock

OsWord01 ROUT
OsWord02 ROUT
        CMP     R0, #2                  ; C=1 <=> write clock
        LDRB    R0, TimerState
        EORCS   R0, R0, #&0F            ; if writing, then write to other state
                                        ; in case user resets in middle
        TEQ     R0, #5                  ; 5 => alpha, 10 => beta (C preserved)
        ADREQ   R2, TimerAlpha
        ADRNE   R2, TimerBeta
        Swap    R1, R2, CS              ; if writing then R2 is destination
      [ NoARMv6 :LOR: NoUnaligned
        MOV     R3, #5
10
        LDRB    R4, [R2], #1
        STRB    R4, [R1], #1
        SUBS    R3, R3, #1
        BNE     %BT10
      |
        ; Use unaligned load/store from ARMv6
        LDR     R3, [R2], #4
        LDRB    R4, [R2]
        STR     R3, [R1], #4
        STRB    R4, [R1]
      ]
        STRB    R0, TimerState          ; if writing, switch state
                                        ; (if reading, write current state)
        MyOsWord

; *****************************************************************************

; Read/Write Interval Timer
; entered with IRQs off
; in:   R0 = 3 => read interval timer
;       R0 = 4 => write interval timer

OsWord03 ROUT
OsWord04 ROUT
        CMP     R0, #4                  ; C=1 => write timer
        MOVCS   R2, R1                  ; if writing then R1 is source
        ADRCS   R1, IntervalTimer
        ADRCC   R2, IntervalTimer       ; else R2 is source
      [ NoARMv6 :LOR: NoUnaligned
        MOV     R0, #5
10
        LDRB    R3, [R2], #1
        STRB    R3, [R1], #1
        SUBS    R0, R0, #1
        BNE     %BT10
      |
        ; Use unaligned load/store from ARMv6
        LDR     R0, [R2], #4
        LDRB    R3, [R2]
        STR     R0, [R1], #4
        STRB    R3, [R1]
      ]
        MyOsWord

; *****************************************************************************

; Perform a SOUND command
OsWord07 ROUT
        TST     R1, #3
        BNE     %FT05
        LDMIA   R1, {R0,R1}
        SWI     XSound_ControlPacked
        MyOsWord
05

      [ NoARMv6 :LOR: NoUnaligned
; Block not word aligned, so push it on the stack

        SUB     R13, R13, #8            ; create stack frame of 8 bytes
        MOV     R0, #7
10
        LDRB    R2, [R1, R0]            ; copy block into stack frame
        STRB    R2, [R13, R0]
        SUBS    R0, R0, #1
        BCS     %BT10

        Pull    "R0, R1"                ; then pull stack frame into R0 and R1
      |
        ; Use unaligned load from ARMv6
        LDR     R0, [R1], #4
        LDR     R1, [R1]
      ]
        SWI     XSound_ControlPacked
        MyOsWord

; *****************************************************************************
; Read the logical colour of a Pixel ( BASIC's POINT function)
; Uses SWI ReadPoint

OsWord09 ROUT
        Push    R1                      ; save pointer

      [ NoARMv6 :LOR: NoUnaligned
        LDRB    R2, [R1, #0]            ; X lo-byte
        LDRB    R0, [R1, #1]            ; X hi-byte
        ORR     R0, R2, R0, LSL #8

        MOV     R0, R0, LSL #16         ; sign extend X
        MOV     R0, R0, ASR #16

        LDRB    R2, [R1, #2]            ; Y lo-byte
        LDRB    R1, [R1, #3]            ; Y hi-byte
        ORR     R1, R2, R1, LSL #8

        MOV     R1, R1, LSL #16         ; sign extend Y
        MOV     R1, R1, ASR #16
      |
        ; Use unaligned load from ARMv6
        LDRSH   R0, [R1], #2
        LDRSH   R1, [R1]
      ]

        SWI     XOS_ReadPoint   ; in: R0=X, R1=Y
                                ; out: R2=colour, R3=tint, R4=0/-1 (on/off)
        Pull    R1
        STRB    R2, [R1, #4]
        WordReturnV

; *****************************************************************************

; Read a character definition

OsWord0A ROUT
        ByteToNosbod DoReadFont
        MyOsWord

; *****************************************************************************

; Read the palette setting (VDU19,L,P,R,G,B)

OsWord0B ROUT
        ByteToNosbod DoReadPalette
        MyOsWord

; *****************************************************************************

; Write the palette setting (see VDU19)

OsWord0C ROUT
        ByteToNosbod DoSetPalette
        MyOsWord

; *****************************************************************************

; Read the last two graphics cursor positions

OsWord0D ROUT
        ByteToNosbod DoOsWord13
        MyOsWord

; *****************************************************************************

; Read CMOS clock

OsWord0E ROUT
        Push    "R5-R8, R14"            ; R0-R4 saved by Osword

        MOV     R4, R1                  ; pointer to the Osword Block

        LDRB    R0, [R4, #0]
        CMP     R0, #1
        BCC     OsWord0EAlpha
        BEQ     OsWord0EBeta
        CMP     R0, #3
        BCC     OsWord0EGamma
        BEQ     OsWord0EDelta

        Pull    "R5-R8, PC"             ; unknown option

; *****************************************************************************
;
;       OsWord0EAlpha - Read time as a string in the form
;       eg Wed,01 Jan 1986.12:34:56
;
; in:   R1 -> buffer for string
;

OsWord0EAlpha ROUT

        ADR     R0, RealTime            ; load snapshot of 5 bytes of real time
        LDMIA   R0, {R0, R2}            ; while IRQs are still off
        Push    "R0, R2"                ; save on stack
        CLRPSR  I_bit, R0               ; enable IRQs now

OSWord0EReturnString
        MOV     R0, #-1                 ; This territory
        MOV     R2, R1
        MOV     R1, R13                 ; point to stacked copy
; KJB 07-Sep-98: No-one is guaranteeing anywhere the length of %w3 or %m3 -
; see PRM 1-402 and 1-415. So give an indefinite buffer length here (making
; overflow the caller's problem - this call is obsolete anyway). Problem
; first noted with territory Japan, for which %m3 is potentially 5 bytes long.
        MOV     R3, #&10000000
        ADR     R4, TimeFormat
        SWI     XTerritory_ConvertDateAndTime
        ADD     R13, R13, #8            ; junk stack frame
        MOVVC   R0, #13                 ; if no error
        STRVCB  R0, [R1]                ; overwrite terminating 0 with CR

        Pull    "R5-R8,R14"
        WordReturnV

TimeFormat
        =       "%w3,%dy %m3 %ce%yr.%24:%mi:%se", 0
        ALIGN


; *****************************************************************************
;
;       OsWord0EBeta - Read time in BCD format
;
; in:   R4 -> parameter block
;
; out:  [R4, #0] = year         (00-99)
;       [R4, #1] = month        (01-12)
;       [R4, #2] = day of month (01-31)
;       [R4, #3] = day of week  (01-07) Sun=01
;       [R4, #4] = hours        (00-23)
;       [R4, #5] = minutes      (00-59)
;       [R4, #6] = seconds      (00-59)
;

OsWord0EBeta ROUT

        ADR     R0, RealTime            ; load snapshot of 5 bytes of real time
        LDMIA   R0, {R0, R2}            ; while IRQs are still off
        Push    "R0, R2"                ; save on stack
        CLRPSR  I_bit, R0               ; this may take some time

        MOV     R0,#-1
        MOV     R1,SP
        SUB     SP,SP,#36               ; Space for ordinals.
        MOV     R2,SP
        SWI     XTerritory_ConvertTimeToOrdinals
        ADDVS   SP,SP,#36+(2*4)
        BVS     OSWord0Eerror

;   [R2]    = CS.                     ; all values are for LOCAL time
;   [R2+4]  = Second
;   [R2+8]  = Minute
;   [R2+12] = Hour (out of 24)
;   [R2+16] = Day number in month.
;   [R2+20] = Month number in year.
;   [R2+24] = Year number.
;   [R2+28] = Day of week.
;   [R2+32] = Day of year

        LDR     R0,[R2,#24]             ; Get year
        LDR     R1,=1900
        SUB     R0,R0,R1
01
        CMP     R0,#100
        SUBGT   R0,R0,#100
        BGT     %BT01                   ; Get year MOD 100.

        STRB    R0,[R4,#0]              ; Store it.
        LDR     R0,[R2,#20]
        STRB    R0,[R4,#1]
        LDR     R0,[R2,#16]
        STRB    R0,[R4,#2]
        LDR     R0,[R2,#28]
        STRB    R0,[R4,#3]
        LDR     R0,[R2,#12]
        STRB    R0,[R4,#4]
        LDR     R0,[R2,#8]
        STRB    R0,[R4,#5]
        LDR     R0,[R2,#4]
        STRB    R0,[R4,#6]

        ADD     SP,SP,#36+(2*4)        ; junk stack frame and 5 byte time.


; now we have the time in hex in the parameter block
; so convert each item into BCD

        MOV     R1, #6                  ; seven bytes to convert

10
        LDRB    R0, [R4, R1]
        BL      HexToBCD
        STRB    R0, [R4, R1]
        SUBS    R1, R1, #1
        BPL     %BT10

        B       OsWord0Eend

; *****************************************************************************
;
;       OsWord0EGamma - Convert time in BCD format (at offsets 1..7)
;       into string format at offsets (0..24)
;
; in:   R4 -> BCD time
;

OsWord0EGamma ROUT

;build a block for Territory_ConvertOrdinalsToTime
;   [R2]    = CS.                     ; all values are for LOCAL time
;   [R2+4]  = Second
;   [R2+8]  = Minute
;   [R2+12] = Hour (out of 24)
;   [R2+16] = Day number in month.
;   [R2+20] = Month number in year.
;   [R2+24] = Year number.

        SUB     SP,SP,#28
        MOV     R2,SP
        MOV     R0,#0
        STR     R0,[R2]

        LDRB    R0,[R4,#7]              ; Seconds
        BL      BCDToHex
        STR     R0,[R2,#4]

        LDRB    R0,[R4,#6]              ; Minutes
        BL      BCDToHex
        STR     R0,[R2,#8]

        LDRB    R0,[R4,#5]              ; Hours
        BL      BCDToHex
        STR     R0,[R2,#12]

        LDRB    R0,[R4,#3]              ; Day of month
        BL      BCDToHex
        STR     R0,[R2,#16]

        LDRB    R0,[R4,#2]              ; Month
        BL      BCDToHex
        STR     R0,[R2,#20]


        LDRB    R0,[R4,#1]              ; Year
        BL      BCDToHex
        LDR     R1,=1900
        ADD     R0,R0,R1
        STR     R0,[R2,#24]

        MOV     R0,#-1
        ADD     R1,SP,#20               ; Put value on satck
        SWI     XTerritory_ConvertOrdinalsToTime
        ADDVS   SP,SP,#28
        BVS     OSWord0Eerror

        ADD     SP,SP,#20
        MOV     R1,R4
        B       OSWord0EReturnString    ; Now we have 5 byte value on stack,
                                        ; use same code as OSWord0EAlpha

; *****************************************************************************
;
;       OsWord0EDelta - Read 5-byte RealTime
;
; in:   R4 -> block
;
; out:  [R4, #0..4] = RealTime
;

OsWord0EDelta ROUT
        LDR     R1, RealTime +0
      [ NoARMv6 :LOR: NoUnaligned
        STRB    R1, [R4, #0]
        MOV     R1, R1, LSR #8
        STRB    R1, [R4, #1]
        MOV     R1, R1, LSR #8
        STRB    R1, [R4, #2]
        MOV     R1, R1, LSR #8
        STRB    R1, [R4, #3]
      |
        ; Use unaligned store from ARMv6
        STR     R1, [R4, #0]
      ]
        LDRB    R1, RealTime +4
        STRB    R1, [R4, #4]

; and drop thru to ...

OsWord0Eend
        Pull    "R5-R8, R14"
        MyOsWord

OSWord0Eerror
        Pull    "R5-R8, R14"
        WordReturnV

; *****************************************************************************

; Osword 15 (&0F) Write the Real Time Clock.
; Four different calls

OsWord0F ROUT
        CLRPSR  I_bit, R0               ; this may take some time

        Push    "R5-R10, R14"
        MOV     R4, R1                  ; Copy the parameter block pointer
        LDRB    R0, [R1]
        MOV     R9, #0

        TEQ     R0, #5                  ; write all of time (5-byte UTC)
        BEQ     OsWord0F_5byte

        TEQ     R0, #8                  ; write hours, minutes, seconds
        MOVEQ   R9, #1

        TEQ     R0, #15                 ; write day, date, month, year
        MOVEQ   R9, #2

        TEQ     R0, #24                 ; write all of time
        MOVEQ   R9, #3

        TEQ     R9, #0
        Pull    "R5-R10, PC", EQ        ; unknown call, pass it on

        TST     R9, #2
        BEQ     %FT01                   ; no date parsing

; KJB 980908 - can't assume length of date, as %w3, %dy and %m3 may be any length. Unfortunately,
; the string may not be terminated. Best we can do is plop a terminator at the maximum length position,
; which will at least cope with territories with fixed-length strings. Territories with variable length
; strings may work anyway, as territory modules are quite good at ignoring trailing junk. I've
; fixed things I've spotted that didn't terminate, such as BASIC.

        SUB     SP, SP, #48
        MOV     R0, #-1
        MOV     R2, SP                  ; R1 points to real memory - contents don't matter to us
        SWI     XTerritory_ReadCalendarInformation
        ADDVS   SP, SP, #48
        BVS     Bad0F

; need to work out maximum length of "%w3,%dy %m3 %ce%yr[.%24:%mi:%se]"
        TST     R9, #1
        MOVEQ   R0, #7                  ; length of ",  %ce%yr"
        MOVNE   R0, #16                 ; length of ",  %ce%yr.%24:%mi:%se"
        LDR     R10, [R2, #24]
        LDR     R14, [R2, #28]
        ADD     R0, R0, R10             ; + max length of %w3
        LDR     R10, [R2, #40]
        ADD     R0, R0, R14             ; + max length of %dy
        ADD     R0, R0, R10             ; + max length of %m3
        ADD     SP, SP, #48

01      ADD     r10, r0, #3+1           ; round up number of bytes in block to word boundary, including null terminator
        BIC     r10, r10, #3
        SUB     sp, sp, r10

        ADD     r2, r1, #1              ; point at actual string
        MOV     r1, #0
02
        LDRB    r14, [r2, r1]           ; copy string (not terminated) on stack
        STRB    r14, [sp, r1]
        ADD     r1, r1, #1
        TEQ     r1, r0                  ; have we copied all bytes of string?
        BNE     %BT02                   ; loop if not

        MOV     r14, #0                 ; null terminator
        STRB    r14, [sp, r0]

        MOV     r0,#-1                  ; set things up for territory SWI - r0 = -1 for current territory
        MOV     r1, r9                  ; r1 = reason code (1, 2 or 3)
        MOV     r2, sp                  ; r2 -> terminated string on stack
        SUB     sp, sp, #36             ; get space for result.
        MOV     r3, sp

        SWI     XTerritory_ConvertTimeStringToOrdinals
        ADDVS   sp, sp, #36             ; if error then junk return block
        ADDVS   sp, sp, r10             ; and junk variable length string on stack
        BVS     Bad0F

        CMP     r9, #2                  ; if writing everything just go to UTC conversion step
        BHI     %FT05

; We have the time but no date, or have the date but no time. Get the missing fields
; because changing the one can roll the other across a timezone.

        ADDLO   r7, sp, #0*4
        ADDEQ   r7, sp, #4*4
        LDMIA   r7, {r3-r6}             ; preserve the values we have converted

        ADR     r0, RealTime
        LDMIA   r0, {r0,r1}             ; LDM is atomic wrt interrupts

        Push    "r0,r1"                 ; put value on stack
        MOV     r0,#-1                  ; use configured territory.
        MOV     r1, sp
        ADD     r2, sp, #8
        SWI     XTerritory_ConvertTimeToOrdinals        ; get ordinals for current time
        ADDVS   sp, sp, #36+8           ; 36 from above + 8 for stacked 5 byte time
        ADDVS   sp, sp, r10             ; and junk string as well
        BVS     Bad0F
        ADD     sp, sp, #8              ; dump 5 byte time on TOS

        STMIA   r7, {r3-r6}             ; restore the values we have converted

05
; Now [SP] -> ordinals in local time, but we want time in UTC
; First convert the ordinals to 5 byte UTC time

        MOV     r0, #-1                 ; use configured territory.
        MOV     r2, sp                  ; r2 -> ordinals block
        SUB     sp, sp, #8              ; two more words to contain 5 byte time
        MOV     r1, sp
        SWI     XTerritory_ConvertOrdinalsToTime
        ADDVS   sp, sp, #36+8           ; 36 from above + 8 for 5 byte time
        ADDVS   sp, sp, r10             ; and junk string as well
        BVS     Bad0F

; Now we have a 5 byte UTC time, convert it to UTC ordinals

        MOV     r1, sp                  ; our 5 byte time
        ADD     r2, sp, #8              ; place to put ordinals
        SWI     XTerritory_ConvertTimeToUTCOrdinals
        ADDVS   sp, sp, #36+8           ; 36 bytes ordinals + 8 for 5 byte time
        ADDVS   sp, sp, r10             ; and junk string as well
        BVS     Bad0F

        ADD     sp, sp, #8              ; discard 5 byte time

10
; Load the registers. (SP->Ordinals)

        LDR     r8, [sp], #4            ; centiseconds
        LDR     r7, [sp], #4            ; seconds
        LDR     r1, [sp], #4            ; minutes
        Pull    "r0,r2,r3,r5"           ; hours, day of month, month, year
        ADD     sp, sp, #8              ; junk day of week, day of year
        ADD     sp, sp, r10             ; and string on stack
        DivRem  r6, r5, #100, r14       ; r5 = Year (lo), r6 = Year (hi)

        BL      SetTime                 ; also updates 5-byte RealTime

Bad0F                                   ; come here if setting invalid
        Pull    "R5-R10, R14"
        MyOsWord

OsWord0F_5byte
        SUB     SP, SP, #36
        ADD     R1, R1, #1              ; process the user's 5-byte block
        MOV     R2, SP
        SWI     XTerritory_ConvertTimeToUTCOrdinals
        ADDVS   SP, SP, #36
        BVS     Bad0F
        MOV     R10, #0                 ; no string on stack
        B       %BT10                   ; nip back in to the main handler

; *****************************************************************************

; Define hardware cursor size, shape and active point

OsWord15
        ByteToNosbod DoPointerStuff
        MyOsWord

; *****************************************************************************

; Set start of screen address (for VDU drivers and display)
; [R1, #0] = bit mask (bit0 set => change drivers; bit1 set => change display)
; [R1, #1..4] = byte offset from start of screen memory

OsWord16
        ByteToNosbod DoSetScreenStart
        MyOsWord

; **************************************************************************

; All the unused OS_Word calls

; Read Byte of I/O proc memory
OsWord05 ROUT
; Write byte of I/O proc memory
OsWord06 ROUT
; Define an ENVELOPE
OsWord08 ROUT
; Allocated to the net
OsWord10
OsWord11
OsWord12
OsWord13
OsWord14
        Unused

        LTORG

        END
@


4.4
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a16 2
maxword * &16                                   ; highest known osword

d25 1
a25 1
        Pull    "R0-R4,R11,WsPtr,link,PC", VC
d27 3
a29 2
        ADDVS   R13, R13, #4                    ; junk stacked R0
        Pull    "R1-R4,R11,WsPtr,link,PC", VS
d39 2
a40 2
        CMP     R0, #(maxword+1)
        BLCC    OsWordGo                        ; Call the subsid entry pt.
d44 1
a44 1
        IssueService
d52 3
a54 1
        Pull    "R0-R4, R11, R12, R14, PC"
d63 1
a63 3
        ASSERT  DespatchWord-%BT10 = 8

; *****************************************************************************
d65 1
a65 1
DespatchWord
d93 2
d106 1
d110 4
d117 2
a118 1
        SWI     XOS_ReadLine
d123 3
a125 1
        Pull    "R3, R4, R11, R12, R14, PC"
d144 1
d151 7
d175 1
d182 7
d202 1
d214 5
d223 1
a223 1
; Read the logical colour of a Pixel ( BASIC'S POINT function)
d229 1
d243 5
d284 2
a285 2
         ByteToNosbod DoOsWord13
         MyOsWord
d289 1
a289 2
; Osword 14 (&0E) -- Read Real Time Clock
; Four (was six) different calls
a290 1
; Read CMOS clock
a302 5
        [ {FALSE}
        CMP     R0, #5
        BCC     OsWord0EEpsilon
        BEQ     OsWord0EZeta            ; this is getting ridiculous !
        ]
a315 7
; TMD 30-May-89: We want to enable IRQs here, but OS_ConvertDateAndTime
; loads bytes out of the block, and if IRQs are on it might end using an
; inconsistent value, so we must make a copy of the block on the stack
; and use that. The label OsWord0EDandT was used by a commented out routine
; in file 'RealTime' which will have to be rewritten if it needs to be
; included again.

d320 1
d322 3
a324 1
        MOV     R0, R13                 ; point to stacked copy
d329 3
a331 3
        MOV     R2, #&10000000
        ADR     R3, TimeFormat
        SWI     XOS_ConvertDateAndTime
d496 1
d504 4
a521 24
;
;       GetDecimalPair - Get pair of decimal digits from [R4+R1+0..1]
;
; in:   R1 is offset from R4 to find 1st digit
;
; out:  if valid, R1=value of pair of digits, C=0
;       if invalid, R1=undefined, C=1
;       R10 is corrupted
;

GetDecimalPair ROUT
        LDRB    R10, [R1, R4]!          ; get hi-digit
        SUB     R10, R10, #"0"          ; put in range 0..9
        CMP     R10, #10                ; C=1 if bad digit
        ADD     R10, R10, R10, LSL #2   ; R10 = 5*hi

        LDRB    R1, [R1, #1]            ; get lo-digit
        SUB     R1, R1, #"0"            ; put in range 0..9
        CMPCC   R1, #10                 ; C=1 if bad digit
        ADD     R1, R1, R10, LSL #1     ; R1 = lo + 2*(5*hi)

        MOV     PC, R14

; *****************************************************************************
d524 1
a524 1
; Three different calls
d547 1
a547 12
        Pull    "R5-R10, PC", EQ         ; unknown call, pass it on

; first set up data in registers as follows :-
; R0 = hours
; R1 = minutes
; R2 = days
; R3 = months
; (R4 -> block)
; R5 = year(lo)
; R6 = year(hi)
; R7 = seconds
; R8 = centiseconds
d550 1
a550 1
        BEQ     %FT01
d604 5
a608 3
        CMP     r9, #2                  ; if just writing the date, write it !
        BEQ     %FT10
        BGT     %FT05                   ; if writing everything just get UTC time
d610 3
a612 2
; We only have the time from the string, we now need the date
; because changing the time may change it.
d619 1
a620 2
        LDMIA   r2, {r3-r6}             ; preserve time values from entry string
        MOV     r1, sp
d622 1
a622 1
        ADDVS   sp, sp, #44             ; 36 From above + 8 for 5 byte time
d626 2
a627 1
        STMIA   r2, {r3-r6}             ; restore the time we read from the string.
d638 1
a638 1
        ADDVS   sp, sp, #44             ; 36 From above + 8 for 5 byte time.
d647 1
a647 1
        ADDVS   sp, sp, #44             ; 36 bytes ordinals + 8 for 5 byte time.
d659 1
a659 1
        Pull    "r0,r2,r3,r5"           ; hours, day of month,  month, year
d662 1
a662 2
        MOV     r4, #100
        DivRem  r6, r5, r4, r14         ; r5 = Year (lo), r6 = Year (hi)
a679 40


; *****************************************************************************
;
;       CheckYear - Check for year wrap (if months have gone down)
;       and for leap year fudging
;

CheckYear ROUT
        Push    "R0,R1,R2,R14"
        MOV     R0, #5                  ; year address
        BL      ReadStraight
        MOV     R1, R0, LSR #6          ; year in range 0..3
        MOV     R0, #YearCMOS
        BL      Read
        AND     R2, R0, #3
        SUBS    R2, R1, R2              ; same year ?
        Pull    "R0,R1,R2,PC", EQ       ; [yes, so no bother]
        ADDCC   R2, R2, #4              ; if lower, then must be carry
        ADD     R2, R0, R2              ; new year value
        CMP     R2, #100
        BCC     %FT10                   ; no carry thru to next century

        SUB     R2, R2, #100
        MOV     R0, #YearCMOS +1
        BL      Read
        ADD     R1, R0, #1
        TEQ     R1, #100
        MOVEQ   R1, #0                  ; wrap century
        MOV     R0, #YearCMOS +1
        BL      Write
10
        MOV     R1, R2
        MOV     R0, #YearCMOS
        BL      Write

        BL      RTCToRealTime
        Pull    "R0,R1,R2,PC"


d716 2
@


4.4.2.1
log
@1) Bring IOMD HAL more up to date. Add support for new
call HAL_CleanerSpace (preparation for StrongARM kernel
support).

2) In kernel, add HAL_CleanerSpace call (preparation for
StrongARM and XScale core support). Fix bug found with
ARMv3 support during test on Risc PC.

3) Implement new API for kernel SWIs that have used top
bits of addresses as flags. The new API has an extra
flag that must be set, so kernel can distinguish and
support both APIs. The reason for all this is that
addresses are 32-bits now, people, keep up there. Briefly:

  OS_HeapSort
    bit 31 of r0 set for new API, r1 is full 32-bit address
    flags move from r1 bits 31-29 to r0 bits 30-28

  OS_ReadLine
    bit 31 of r1 set for new API, r0 is full 32-bit address
    flags move from bits 31,30 of r0 to bits 30,29 of r1

  OS_SubstituteArgs
    bit 31 of r2 set for new API, r0 is full 32-bit address
    flag moves from bit 31 of r0 to bit 30 of r2

Tested on Risc PC and briefly on Customer A 2

Ta

Version 5.35, 4.79.2.41. Tagged as 'Kernel-5_35-4_79_2_41'
@
text
@a110 1
        ORR     R1, R1, #&80000000      ; use the new API, for modernity
@


4.4.2.2
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d111 2
a112 2
        MOV     R4, #0                  ; flags
        SWI     XOS_ReadLine32
d687 1
a687 1
;       CheckYear - Check for year wrap (year in RTC <> year "YearCMOS")
d693 3
a695 20
        MOV     R0, #0
        LDRB    R0, [R0, #RTCFitted]
        TEQ     R0, #RTCAddressPHI
        MOVEQ   R1, #5
        MOVNE   R1, #6                  ; year address (dependant on RTC)
	SUB	R13, R13, #4
	STRB	R1, [R13]
	MOV	R1, R13
	ORR	R0, R0, #1:SHL:29
	MOV	R2, #1
        BL      IIC_Op
        ORR	R0, R0, #1
        BL	IIC_Op
        AND	R1, R0, #&FF
        LDRB	R0, [R13]
        ADD	R13, R13, #4

        TEQ     R1, #RTCAddressPHI+1
        MOVEQ   R1, R0, LSR #6
        ANDNE   R1, R0, #3              ; R1= year MOD 4
@


4.4.2.3
log
@modified s.PMF.osword to cope with the iyonix RTC operating in BCD
Also upissued to RISC OS 5.16 to release this in ROM
Detail:
  (list files and functions that have changed)
Admin:
tested at Castle (JB)
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 5.35, 4.79.2.107. Tagged as 'Kernel-5_35-4_79_2_107'
@
text
@d698 5
a702 4
        STRB    R1, [R13, #-4]!
        MOV     R1, R13
        ORR     R0, R0, #1:SHL:29
        MOV     R2, #1
d704 5
a708 4
        ORR     R0, R0, #1
        BL      IIC_Op
        AND     R1, R0, #&FF
        LDRB    R0, [R13], #4
d711 2
a712 3
        MOVEQ   R0, R0, LSR #6          ; R1= year MOD 4
        BLNE    BCDToHex
        MOV     R2, R0                  ; remember RTC value
d715 2
a716 8

        TEQ     R1, #RTCAddressPHI+1
        ANDEQ   R1, R0, #3
        MOVNE   R1, R0
        MOVEQ   R14,#4
        MOVNE   R14,#100

        SUBS    R2, R2, R1              ; same year ?
d718 1
a718 1
        ADDCC   R2, R2, R14             ; if lower, then must be carry
@


4.4.2.4
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d27 1
a27 1
        LDRVC   R0,[R13]
d29 2
a30 3
        LDM$cond.IB R13,{R1-R4,R11,WsPtr}
        ADD$cond    R13,R13,#8*4 ; R0-R4,R11,WsPtr,R14
        LDR$cond    PC,[R13],#4
d53 1
a53 3
        Pull    "R0-R4, R11, R12"
        ADD     R13, R13, #4
        Pull    PC
a104 1
      [ NoARMv6 :LOR: NoUnaligned
a107 4
      |
        ; Use unaligned load from ARMv6
        LDRH    R0, [R1]                ; 16-bit address(!)
      ]
d117 1
a117 3
        Pull    "R3, R4, R11, R12"
        ADD     R13, R13, #4
        Pull    PC
a135 1
      [ NoARMv6 :LOR: NoUnaligned
a141 7
      |
        ; Use unaligned load/store from ARMv6
        LDR     R3, [R2], #4
        LDRB    R4, [R2]
        STR     R3, [R1], #4
        STRB    R4, [R1]
      ]
a158 1
      [ NoARMv6 :LOR: NoUnaligned
a164 7
      |
        ; Use unaligned load/store from ARMv6
        LDR     R0, [R2], #4
        LDRB    R3, [R2]
        STR     R0, [R1], #4
        STRB    R3, [R1]
      ]
a177 1
      [ NoARMv6 :LOR: NoUnaligned
a188 5
      |
        ; Use unaligned load from ARMv6
        LDR     R0, [R1], #4
        LDR     R1, [R1]
      ]
a198 1
      [ NoARMv6 :LOR: NoUnaligned
a211 5
      |
        ; Use unaligned load from ARMv6
        LDRSH   R0, [R1], #2
        LDRSH   R1, [R1]
      ]
a470 1
      [ NoARMv6 :LOR: NoUnaligned
a477 4
      |
        ; Use unaligned store from ARMv6
        STR     R1, [R4, #0]
      ]
d693 2
a694 52
        LDR     R0, =ZeroPage
        LDR     R0, [R0, #RTCFitted]
 [ HAL
        CMP     R0, #2048
  [ RTCSupport
        BLO     %FT8
  |
        BLO     %FT15
  ] 
        ; Ask the RTC what it thinks the year is
        Push    "R3,R10,R12"
        MOV     R10, R0
        SUB     R13, R13, #RTCTimeStruct_BCD_Size
        MOV     R1, R13
        ADRL    R2, HALRTC_IICOp
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_RTCReadTime]
        ; Did we succeed?
        CMP     R0, #RTCRetCode_OK
        LDRB    R0, [R13, #RTCTimeStruct_BCD_YearLO]
        LDRB    R1, [R13, #RTCTimeStruct_BCD_YearHI]
        ADD     R13, R13, #RTCTimeStruct_BCD_Size
        LDRB    R2, [R10, #HALDevice_RTCFormatFlags]
        Pull    "R3,R10,R12"
        BNE     %FT15
        ASSERT  RTCFormatFlags_BCD_NeedsYearHelp = 1 :SHL: 2
        ASSERT  RTCFormatFlags_BCD_YearLOIsGood = 1 :SHL: 3
        AND     LR, R2, #RTCFormatFlags_BCD_NeedsYearHelp + RTCFormatFlags_BCD_YearLOIsGood
        MOVS    LR, LR, ROR #3 ; CC = good, CS+EQ = 2 bit, CS+NE = BCD
        ADDCS   R1, LR, #RTCAddressPHI+1 ; 2 bit=RTCAddressPHI+1, BCD!=RTCAddressPHI+1
        BCS     %FT9
        ; Year is reliable; convert R0 & R1 to ints and update CMOS if necessary.
        BL      BCDToHex
        MOV     R2, R1
        MOV     R1, R0 ; YearLO
        MOV     R0, #YearCMOS
        BL      Read
        CMP     R0, R1
        MOVNE   R0, #YearCMOS
        BLNE    Write
        MOV     R0, R2
        BL      BCDToHex
        MOV     R1, R0 ; YearHI
        MOV     R0, #YearCMOS+1
        BL      Read
        CMP     R0, R1
        MOVNE   R0, #YearCMOS+1
        BLNE    Write
        B       %FT15
8
 ] ; HAL
 [ RTCSupport :LOR: :LNOT: HAL
d709 1
a709 3
 ] ; RTCSupport :LOR: :LNOT: HAL
9
        MOVEQ   R0, R0, LSR #6          ; R0= year MOD 4.
d714 1
d740 1
a740 1
15
a780 2
        LTORG

@


4.4.2.5
log
@Rationalise some old switches.
Export less in hdr:RISCOS.
Delete unused GetDecimalPair routine.
Move CheckYear with other RTC stuff out of PMF/osword.
Hide DebugROMInit and DebugROMErrors in release (even numbered) versions.

Version 5.35, 4.79.2.127. Tagged as 'Kernel-5_35-4_79_2_127'
@
text
@d535 24
d561 1
a561 1
; Four different calls
d726 113
@


4.4.2.6
log
@Tighten up time conversions.
Convrsions.s:
Don't trash R4 in OS_ConvertDateAndTime
Reject buffer sizes > 2G (seems reasonable for a time string, and allows us to claw back a flag bit).
PMF/osword.s:
Just call Territory_ConvertDateAndTime directly since that's all OS_ConvertDateAndTime does.
Trim some now irrelevant comments and switched out code.

Version 5.35, 4.79.2.144. Tagged as 'Kernel-5_35-4_79_2_144'
@
text
@d17 2
d41 2
a42 2
        CMP     R0, #(WordTableEnd - WordTableStart) :SHR: 2
        BLLS    OsWordGo                        ; Call the subsid entry pt.
d65 3
a67 1
        ASSERT  WordTableStart - %BT10 = 8
d69 1
a69 1
WordTableStart
a96 2
WordTableEnd

d225 1
a225 1
; Read the logical colour of a Pixel ( BASIC's POINT function)
d291 3
a294 1

d307 5
d325 7
a335 1

d337 1
a337 3
        MOV     R0, #-1                 ; This territory
        MOV     R2, R1
        MOV     R1, R13                 ; point to stacked copy
d342 3
a344 3
        MOV     R3, #&10000000
        ADR     R4, TimeFormat
        SWI     XTerritory_ConvertDateAndTime
@


4.4.2.7
log
@Fix to localisation of OS_Word 15,15 when using nonzero timezones
The three subreasons were being dealt with as follows

8  - time only => convert time; read clock & convert that; mix; to UTC; set
15 - date only => convert date; to UTC; set
24 - both      => convert both; to UTC; set

So subreason 15 ended up setting the clock with the UTC date not taking into account any rollover/under due to the timezone. Now, the behaviour is

15 - date only => convert date; read clock & convert that; mix; to UTC; set

An example program to illustrate this is

 DIM block 128
 REM Example boundary case for -ve timezone
 REM *config.timezone -5
 REM TIME$="Sun,01 Jan 2013.19:01:00"

 REM Example boundary case for +ve timezone
 *config.timezone 5
 TIME$="Sun,01 Jan 2013.04:59:00"

 PRINT"Local => ";TIME$
 FOR i = 1 TO 31
  block?0=15
  $(block+1)="Sun,"+RIGHT$("0"+STR$i,2)+" Jan 2013"+CHR$0
  SYS"OS_Word",15,block
  OSCLI"echo <sys$time> <sys$date> <sys$year>"
 NEXT

Fault originates in Kernel-4_63-1_1_2_2.
Fixes ticket #230.

Version 5.35, 4.79.2.185. Tagged as 'Kernel-5_35-4_79_2_185'
@
text
@d547 12
a558 1
        Pull    "R5-R10, PC", EQ        ; unknown call, pass it on
d561 1
a561 1
        BEQ     %FT01                   ; no date parsing
d615 3
a617 5
        CMP     r9, #2                  ; if writing everything just go to UTC conversion step
        BHI     %FT05

; We have the time but no date, or have the date but no time. Get the missing fields
; because changing the one can roll the other across a timezone.
d619 2
a620 3
        ADDLO   r7, sp, #0*4
        ADDEQ   r7, sp, #4*4
        LDMIA   r7, {r3-r6}             ; preserve the values we have converted
d627 2
a629 1
        ADD     r2, sp, #8
d631 1
a631 1
        ADDVS   sp, sp, #36+8           ; 36 from above + 8 for stacked 5 byte time
d635 1
a635 2

        STMIA   r7, {r3-r6}             ; restore the values we have converted
d646 1
a646 1
        ADDVS   sp, sp, #36+8           ; 36 from above + 8 for 5 byte time
d655 1
a655 1
        ADDVS   sp, sp, #36+8           ; 36 bytes ordinals + 8 for 5 byte time
d667 1
a667 1
        Pull    "r0,r2,r3,r5"           ; hours, day of month, month, year
@


4.4.2.8
log
@Replace 1 line macro
IssueService -> BL Issue_Service.
@
text
@d44 1
a44 1
        BL      Issue_Service
d284 2
a285 2
        ByteToNosbod DoOsWord13
        MyOsWord
@


4.4.2.9
log
@Avoid unnecesssary remainder calculations
Detail:
  s/HeapSort, s/vdu/vdugrafc, s/vdu/vduswis - Avoid unnecessary remainder calculations in DivRem macro
  s/PMF/i2cutils, s/PMF/osword - Make use of DivRem's ability to accept a constant as the divisor
Admin:
  Tested on Cortex-A15


Version 5.35, 4.79.2.318. Tagged as 'Kernel-5_35-4_79_2_318'
@
text
@d662 2
a663 1
        DivRem  r6, r5, #100, r14       ; r5 = Year (lo), r6 = Year (hi)
@


4.4.2.2.2.1
log
@  Unaligned loads/stores optimised for ARMv6+
Detail:
  Having scanned the kernel source for unaligned load code fragments which
  would abort on ARMv6 and v7 and not having found any, I took the opportunity
  to give them build-time switches to use unaligned LDR((S)H)/STR(H)
  instructions if built for a new enough platform. Also added a couple of
  cases of LDRSB that will benefit v4 CPUs and a few instances of the v6
  SXTH instruction, but since objasm doesn't yet understand it (and when it
  does, not everyone will have upgraded) they are currently written as
  DCI statements.
  Most of the changes are to OS_Word handlers, which are notorious in that
  their input/output block is not word-aligned.
Admin:
  Not tested, but it should at least build.

Version 5.35, 4.79.2.98.2.6. Tagged as 'Kernel-5_35-4_79_2_98_2_6'
@
text
@a104 1
      [ NoARMv6
a107 4
      |
        ; Use unaligned load from ARMv6
        LDRH    R0, [R1]                ; 16-bit address(!)
      ]
a135 1
      [ NoARMv6
a141 7
      |
        ; Use unaligned load/store from ARMv6
        LDR     R3, [R2], #4
        LDRB    R4, [R2]
        STR     R3, [R1], #4
        STRB    R4, [R1]
      ]
a158 1
      [ NoARMv6
a164 7
      |
        ; Use unaligned load/store from ARMv6
        LDR     R0, [R2], #4
        LDRB    R3, [R2]
        STR     R0, [R1], #4
        STRB    R3, [R1]
      ]
a177 1
      [ NoARMv6
a188 5
      |
        ; Use unaligned load from ARMv6
        LDR     R0, [R1], #4
        LDR     R1, [R1]
      ]
a198 1
      [ NoARMv6
a211 5
      |
        ; Use unaligned load from ARMv6
        LDRSH   R0, [R1], #2
        LDRSH   R1, [R1]
      ]
a470 1
      [ NoARMv6
a477 4
      |
        ; Use unaligned store from ARMv6
        STR     R1, [R4, #0]
      ]
@


4.4.2.2.2.2
log
@  Miscellaneous v6-related updates
Detail:
 * Stopped calling the broken abort fixup code when running under VMSAv6.
   Might be desirable to update it, possibly farmed out to a separate module -
   still need to think about this.
 * Unaligned load optimisations can now be disabled by the global NoUnaligned
   flag for testing purposes.
 * Extended OS_ReadUnsigned to permit reading of 64-bit unsigned integers.
   See Docs.ReadUnsigned for more details. Also sped it up by using MLA
   (or UMLAL) for most digits rather than repeated addition.
 * Bugfix is OS_GSRead: an uninitialised r0 was being passed to
   OS_ReadUnsigned, causing undesirable effects on rare occasions.
Admin:
  Tested on a rev B7 beagleboard.

Version 5.35, 4.79.2.98.2.8. Tagged as 'Kernel-5_35-4_79_2_98_2_8'
@
text
@d105 1
a105 1
      [ NoARMv6 :LOR: NoUnaligned
d141 1
a141 1
      [ NoARMv6 :LOR: NoUnaligned
d172 1
a172 1
      [ NoARMv6 :LOR: NoUnaligned
d199 1
a199 1
      [ NoARMv6 :LOR: NoUnaligned
d226 1
a226 1
      [ NoARMv6 :LOR: NoUnaligned
d504 1
a504 1
      [ NoARMv6 :LOR: NoUnaligned
@


4.4.2.2.2.3
log
@Add HAL RTC support to Cortex branch of kernel, clean up RTCSupport code
Detail:
  HAL kernels (on the Cortex branch at least) now support HALDevice-based RTCs. If the kernels own RTC code is disabled or fails to detect an RTC, then after HAL_InitDevices is called the HALDevice list will be scanned for any HAL-resident RTC devices.
  Additionally, the RTCSupport flag (in Hdr:Machine.Machine), which was previously TRUE for all HAL kernels, can now be set to FALSE in HAL kernels to disable the kernels own IIC RTC code. This allows the unwanted legacy RTC code to be disabled for machines which are known to use HAL RTCs instead.
  hdr/RTCDevice - new header describing data structures used for HAL RTC device
  hdr/HALDevice - added RTCDevice device type, IIC serial bus type
  hdr/KernelWS - upgraded RTCFitted from a 1 byte field to 4 byte. It now stores either a null value (for no RTC), a value <2048 for an IIC RTC address, or a value >= 2048 for a RTCDevice ptr
  Makefile - added header export of hdr/RTCDevice
  s/GetAll - include hdr/RTCDevice
  s/NewReset - initialise HAL RTC after HAL_InitDevices if required
  s/PMF/i2cutils, s/PMF/osinit, s/PMF/osword - modifications to allow use of HAL RTC (and disallow use of builtin IIC RTC)
Admin:
  Tested on rev C2 beagleboard


Version 5.35, 4.79.2.98.2.11. Tagged as 'Kernel-5_35-4_79_2_98_2_11'
@
text
@d732 1
a732 47
        LDR     R0, [R0, #RTCFitted]
 [ HAL
	CMP	R0, #2048
  [ RTCSupport
	BLO	%FT8
  |
	BLO	%FT15
  ] 
	; Ask the RTC what it thinks the year is
	Push	"R3,R10,R12"
	MOV	R10, R0
	SUB	R13, R13, #RTCTimeStruct_BCD_Size
	MOV	R1, R13
	ADRL	R2, HALRTC_IICOp
	MOV	LR, PC
	LDR	PC, [R0, #HALDevice_RTCReadTime]
	; Did we succeed?
	CMP	R0, #RTCRetCode_OK
	LDRB	R0, [R13, #RTCTimeStruct_BCD_YearLO]
	LDRB	R1, [R13, #RTCTimeStruct_BCD_YearHI]
	ADD	R13, R13, #RTCTimeStruct_BCD_Size
	LDRB	R2, [R10, #HALDevice_RTCFormatFlags]
	Pull	"R3,R10,R12"
	BNE	%FT15
	TST	R2, #RTCFormatFlags_BCD_NeedsYearHelp
	BNE	%FT9
	; Year is reliable; convert R0 & R1 to ints and update CMOS if necessary.
	BL	BCDToHex
	MOV	R2, R1
	MOV	R1, R0 ; YearLO
	MOV	R0, #YearCMOS
	BL	Read
	CMP	R0, R1
	MOVNE	R0, #YearCMOS
	BLNE	Write
	MOV	R0, R2
	BL	BCDToHex
	MOV	R1, R0 ; YearHI
	MOV	R0, #YearCMOS+1
	BL	Read
	CMP	R0, R1
	MOVNE	R0, #YearCMOS+1
	BLNE	Write
	B	%FT15
8
 ] ; HAL
 [ RTCSupport :LOR: :LNOT: HAL
d750 1
a750 3
 ] ; RTCSupport :LOR: :LNOT: HAL
9
        ANDNE   R1, R0, #3              ; R1= year MOD 4. Note sharing of NE condition with HAL code.
d773 1
a773 1
15
@


4.4.2.2.2.4
log
@Migrate 2012 RTC fix to Cortex branch of kernel
Detail:
  s/PMF/osword - Migrate the 2012 RTC fix from the HAL branch to the Cortex branch, plus apply similar fix to the code that handles HAL RTC devices (via new YearLOIsGood flag)
  s/PMF/i2cutils - Update HAL RTC year handling to correctly treat YearLO as either 2-bit int or 2-digit BCD
  hdr/RTCDevice - Add YearLOIsGood flag, revise NeedsYearHelp description
Admin:
  Tested on rev C2 beagleboard. Code seems to behave as intended.


Version 5.35, 4.79.2.98.2.21. Tagged as 'Kernel-5_35-4_79_2_98_2_21'
@
text
@d734 1
a734 1
        CMP     R0, #2048
d736 1
a736 1
        BLO     %FT8
d738 1
a738 1
        BLO     %FT15
d740 36
a775 40
        ; Ask the RTC what it thinks the year is
        Push    "R3,R10,R12"
        MOV     R10, R0
        SUB     R13, R13, #RTCTimeStruct_BCD_Size
        MOV     R1, R13
        ADRL    R2, HALRTC_IICOp
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_RTCReadTime]
        ; Did we succeed?
        CMP     R0, #RTCRetCode_OK
        LDRB    R0, [R13, #RTCTimeStruct_BCD_YearLO]
        LDRB    R1, [R13, #RTCTimeStruct_BCD_YearHI]
        ADD     R13, R13, #RTCTimeStruct_BCD_Size
        LDRB    R2, [R10, #HALDevice_RTCFormatFlags]
        Pull    "R3,R10,R12"
        BNE     %FT15
        ASSERT  RTCFormatFlags_BCD_NeedsYearHelp = 1 :SHL: 2
        ASSERT  RTCFormatFlags_BCD_YearLOIsGood = 1 :SHL: 3
        AND     LR, R2, #RTCFormatFlags_BCD_NeedsYearHelp + RTCFormatFlags_BCD_YearLOIsGood
        MOVS    LR, LR, ROR #3 ; CC = good, CS+EQ = 2 bit, CS+NE = BCD
        ADDCS   R1, LR, #RTCAddressPHI+1 ; 2 bit=RTCAddressPHI+1, BCD!=RTCAddressPHI+1
        BCS     %FT9
        ; Year is reliable; convert R0 & R1 to ints and update CMOS if necessary.
        BL      BCDToHex
        MOV     R2, R1
        MOV     R1, R0 ; YearLO
        MOV     R0, #YearCMOS
        BL      Read
        CMP     R0, R1
        MOVNE   R0, #YearCMOS
        BLNE    Write
        MOV     R0, R2
        BL      BCDToHex
        MOV     R1, R0 ; YearHI
        MOV     R0, #YearCMOS+1
        BL      Read
        CMP     R0, R1
        MOVNE   R0, #YearCMOS+1
        BLNE    Write
        B       %FT15
d782 5
a786 4
        STRB    R1, [R13, #-4]!
        MOV     R1, R13
        ORR     R0, R0, #1:SHL:29
        MOV     R2, #1
d788 5
a792 4
        ORR     R0, R0, #1
        BL      IIC_Op
        AND     R1, R0, #&FF
        LDRB    R0, [R13], #4
d795 1
d798 1
a798 3
        MOVEQ   R0, R0, LSR #6          ; R0= year MOD 4.
        BLNE    BCDToHex
        MOV     R2, R0                  ; remember RTC value
d801 2
a802 7
        TEQ     R1, #RTCAddressPHI+1
        ANDEQ   R1, R0, #3
        MOVNE   R1, R0
        MOVEQ   R14,#4
        MOVNE   R14,#100

        SUBS    R2, R2, R1              ; same year ?
d804 1
a804 1
        ADDCC   R2, R2, R14             ; if lower, then must be carry
@


4.4.2.2.2.5
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d731 1
a731 1
        LDR     R0, =ZeroPage
a869 2
        LTORG

@


4.4.2.2.2.6
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d27 1
a27 1
        LDRVC   R0,[R13]
d29 2
a30 3
        LDM$cond.IB R13,{R1-R4,R11,WsPtr}
        ADD$cond    R13,R13,#8*4 ; R0-R4,R11,WsPtr,R14
        LDR$cond    PC,[R13],#4
d53 1
a53 3
        Pull    "R0-R4, R11, R12"
        ADD     R13, R13, #4
        Pull    PC
d122 1
a122 3
        Pull    "R3, R4, R11, R12"
        ADD     R13, R13, #4
        Pull    PC
@


4.3
log
@Added OS_Word 15,5 to set the real-time clock from a 5 byte UTC time.

Version 4.85. Tagged as 'Kernel-4_85'
@
text
@a22 1
        [ AssemblingArthur :LOR: ErrorsInR0
a31 3
        |
        Pull    "R0-R4, R11, R12, R14, PC", $cond
        ]
d171 5
a175 3
        LDMEQIA R1, {R0,R1}
        SWIEQ   XSound_ControlPacked
        MyOsWord EQ
a277 34
;       StoreHexPair - Store a hex number in R0 at R4+R6 (hi) and R4+R6+1 (lo)
;       Corrupts R5,R6

StoreHexPair
        Push    R14
        BL      HexToBCD
        Pull    R14
StoreBCDPair
        MOV     R5, R0, LSR #4
        ADD     R5, R5, #"0"
        STRB    R5, [R6, R4]!
        AND     R5, R0, #&0F
        ADD     R5, R5, #"0"
        STRB    R5, [R6, #1]
        MOV     PC, R14

; *****************************************************************************
;
;       StoreTLA - Store 3-letter alpha string in R0 at R4+R6+(0..2),
;       uppercasing first character
;
; out:  R0, R6 corrupt

StoreTLA
        BIC     R0, R0, #&20            ; upper case 1st char
        STRB    R0, [R6, R4]!           ; store 1st char
        MOV     R0, R0, LSR #8
        STRB    R0, [R6, #1]            ; store 2nd char
        MOV     R0, R0, LSR #8
        STRB    R0, [R6, #2]            ; store 3rd char
        MOV     PC, R14

; *****************************************************************************
;
a284 2
        [ {TRUE}
 [ Fix7
a306 7
 |
        ADR     R0, RealTime
        MOV     R2, #25                 ; 24 + CR terminator
        ADR     R3, TimeFormat
OsWord0EDandT
        SWI     XOS_ConvertDateAndTime
 ]
a316 74
        |
        CLRPSR  I_bit, R0       ; this may take some time

        BL      CheckYear       ; check for year wrap

        BL      ReadTime        ; read clock

        Push    "R5, R6"        ; save year lo and hi

; do the hours

        MOV     R6, #16         ; hours at offset 16 and 17
        BL      StoreHexPair

; do the minutes

        MOV     R0, R1
        MOV     R6, #19         ; minutes at offset 19 and 20
        BL      StoreHexPair

; do the seconds

        MOV     R0, R7
        MOV     R6, #22         ; seconds at offset 22 and 23
        BL      StoreHexPair

; do the day of month

        MOV     R0, R2
        MOV     R6, #4          ; day of month at offset 4 and 5
        BL      StoreHexPair

; now the month number is still in R3

        ADRL    R0, MonthNameTable-4    ; point to the entry
        LDR     R0, [R0, R3, LSL #2]  ; Get the data in the format "jan",0 etc.
        MOV     R6, #7                  ; store month at offsets 7,8,9
        BL      StoreTLA

; do the year

        Pull    "R7, R8"                ; R7=year lo, R8=year hi

        MOV     R0, R7
        MOV     R6, #13                 ; year(lo) at offsets 13 and 14
        BL      StoreHexPair

; do the high part of the year

        MOV     R0, R8
        MOV     R6, #11                 ; year(hi) at offsets 11 and 12
        BL      StoreHexPair

; now compute day of week from month, date, and year
; at the moment R7 = units of years, R8 = hundreds of years
; we want to compute (year MOD 400)

        MOVS    R8, R8, LSL #31         ; C=200, N=100
        ADDCS   R7, R7, #200
        ADDMI   R7, R7, #100

; R7 is now year MOD 400

        BL      DayOfTheWeek            ; Returns R0 = 0..6 for Sun..Sat

        ADR     R1, DayNameTable        ; Point to the correct entry
        LDR     R0, [R1, R0, LSL #2]    ; and get it (word)
        MOV     R6, #0                  ; day of week stored at offsets 0,1,2
        BL      StoreTLA

; do the format characters

        B       DoFormatChars
        ]
a334 2
     [ {TRUE}                           ; International version uses Territory manager.

a381 17
     |


        CLRPSR  I_bit, R0               ; this may take some time

        BL      CheckYear               ; check for year wrap

        BL      ReadTime                ; read the time

        STRB    R0, [R4, #4]            ; store hours in hex
        STRB    R1, [R4, #5]            ; store minutes in hex
        STRB    R2, [R4, #2]            ; store dayofmonth in hex
        STRB    R3, [R4, #1]            ; store month in hex
        STRB    R5, [R4, #0]            ; store year(lo) in hex
        STRB    R7, [R4, #6]            ; store seconds in hex

     ]
a394 21
     [ {FALSE}                          ; Done in territory for international version

        MOV     R7, R5                  ; R7 = year(lo)

; now compute day of week from month, date, and year
; at the moment R7 = units of years, R6 = hundreds of years
; we want to compute (year MOD 400)

        MOVS    R6, R6, LSL #31         ; C=200, N=100
        ADDCS   R7, R7, #200
        ADDMI   R7, R7, #100

; R7 is now year MOD 400

        BL      DayOfTheWeek            ; Returns R0 = 0..6 for Sun..Sat

        ADD     R0, R0, #1              ; put into range 1..7
        STRB    R0, [R4, #3]            ; (hex = BCD)

     ]

a406 1
        [ {TRUE}                        ; International version.
a457 82
      |

; do the seconds

        LDRB    R0, [R4, #7]
        MOV     R6, #22                 ; seconds at offset 22 and 23
        BL      StoreBCDPair

; do the minutes

        LDRB    R0, [R4, #6]
        MOV     R6, #19                 ; minutes at offset 19 and 20
        BL      StoreBCDPair

; do the hours

        LDRB    R0, [R4, #5]
        MOV     R6, #16                 ; hours at offset 16 and 17
        BL      StoreBCDPair

; do the year

        LDRB    R0, [R4, #1]
        MOV     R6, #13                 ; year(lo) at offsets 13 and 14
        BL      StoreBCDPair

        MOV     R0, #"1"
        STRB    R0, [R4, #11]           ; year(hi) at offsets 11 and 12
        MOV     R0, #"9"
        STRB    R0, [R4, #12]

; do the month

        LDRB    R0, [R4, #2]            ; get the month number
        BL      BCDToHex                ; make it hex
        ADR     R3, MonthNameTable-4    ; Point to entry (months start at 1)
        LDR     R0, [R3, R0, LSL #2]    ; Get the data in format "jan",0 etc
        MOV     R6, #7                  ; store month name at offsets 7,8,9
        BL      StoreTLA

; day-of-the-week

        LDRB    R3, [R4, #4]            ; day number in range 1..7
        ADR     R0, DayNameTable-4      ; point to correct dayname eg "Wed",0
        LDR     R0, [R0, R3, LSL #2]
        MOV     R6, #0                  ; store day name at offsets 0,1,2
        BL      StoreTLA

; do day of month

        LDRB    R0, [R4, #3]
        MOV     R6, #4                  ; day of month at offset 4 and 5
        BL      StoreBCDPair

; do the format characters

DoFormatChars
        MOV     R0, #","
        STRB    R0, [R4, #3]
        MOV     R0, #" "
        STRB    R0, [R4, #6]
        STRB    R0, [R4, #10]
        MOV     R0, #"."
        STRB    R0, [R4, #15]
        MOV     R0, #":"
        STRB    R0, [R4, #18]
        STRB    R0, [R4, #21]
        MOV     R0, #13
        STRB    R0, [R4, #24]

        B OsWord0Eend

DayNameTable
 = "sun",0
 = "mon",0
 = "tue",0
 = "wed",0
 = "thu",0
 = "fri",0
 = "sat",0

        ]
a681 1
; *****************************************************************************
a682 15
 [ {FALSE}      ; not needed for internationalised kernel
MonthNameTable
 = "jan",0
 = "feb",0
 = "mar",0
 = "apr",0
 = "may",0
 = "jun",0
 = "jul",0
 = "aug",0
 = "sep",0
 = "oct",0
 = "nov",0
 = "dec",0
 ]
a690 1
        [ NewClockChip
a720 162
        |
        Push    "R0-R8, R14"

        BL      ReadTime                ; R3 = clock month (in hex)

        MOV     R0, #MonthCMOS
        BL      Read                    ; R0 = CMOS RAM month

        CMP     R3, R0
        BLCC    HappyNewYear            ; The months have gone down

; now make sure that Feb 29th is dealt with correctly

        CMP     R3, #3                  ; if Jan or Feb then no problem
        BCC     %FT10

        MOV     R0, #LeapCMOS           ; if already fudged it
        BL      Read                    ; then no problem
        TEQ     R0, #0
        BNE     %FT10

        TST     R5, #3                  ; if year MOD 4 is not zero
        BNE     %FT10                   ; then no problem

        TEQ     R5, #0                  ; if not century start
        BNE     %FT20                   ; then is leap year

        TST     R6, #3                  ; else if not mult of 400
        BNE     %FT10                   ; then no problem

20                                      ; it is a leap year
        SUBS    R2, R2, #1              ; day := day-1
        SUBEQ   R3, R3, #1              ; if day=0 then month := month-1
        ADREQ   R4, MonthLengths
        LDREQB  R2, [R4, R3]            ; and day := last day of month

        MOV     R0, #-1                 ; don't change hours
        MOV     R1, #-1                 ; or minutes
        MOV     R7, #-1                 ; or seconds
        MOV     R8, #-1                 ; or centiseconds
        BL      SetTime

        MOV     R1, #1                  ; we have now fudged it
        MOV     R0, #LeapCMOS
        BL      Write

        MOV     R1, R3                  ; remember the month
        MOV     R0, #MonthCMOS
        BL      Write
10
        Pull    "R0-R8, PC"

; *****************************************************************************
;
;       HappyNewYear - Update the year
;
; in:   R3 = months
;       R5 = year(lo)
;       R6 = year(hi)
;
; out:  R5 = new year(lo)
;       R6 = new year(hi)

HappyNewYear ROUT
        Push    "R0,R1, R14"

        ADD     R5, R5, #1              ; R2 := new year(lo)
        TEQ     R5, #100
        BNE     %FT10                   ; [don't increment century]

        MOV     R5, #0                  ; wrap year
        ADD     R6, R6, #1              ; R1 := new year(hi)
        TEQ     R6, #100
        MOVEQ   R6, #0                  ; wrap century

        MOV     R1, R6
        MOV     R0, #YearCMOS+1
        BL      Write                   ; write year(hi)
10
        MOV     R1, R5
        MOV     R0, #YearCMOS
        BL      Write                   ; write year(lo)

        BL      RTCToRealTime           ; update 5-byte RealTime

        MOV     R1, R3
        MOV     R0, #MonthCMOS
        BL      Write                   ; write new months

        MOV     R1, #0
        MOV     R0, #LeapCMOS
        BL      Write                   ; clear leapyear flag

        Pull    "R0,R1, PC"

        ]

; *****************************************************************************

MonthLengths
 ;  F  J  F  M  A  M  J  J  A  S  O  N  D
 = 28,31,29,31,30,31,30,31,31,30,31,30,31
         ALIGN

; *****************************************************************************
;
;       DayOfTheWeek - Compute day of the week
;
; in:   R2 = day of the month
;       R3 = month
;       R7 = year MOD 400
;
; out:  R0 = day of week (0..6 = Sun..Sat) (I think!)
;       Other registers preserved
;

DayOfTheWeek
        Push    "R1,R4-R7, R14"
        SUB     R0, R2, #1              ; R0 = day of the month starting at 0
        ADR     R4, DaysToDate-4        ; adjust cos months start at 1
        LDR     R5, [R4, R3, LSL #2]    ; get the month start offset
        ADD     R0, R0, R5              ; number of days since start of year

; now adjust for this year being leap

        TST     R7, #3
        BNE     NotLeapYr               ; non-multiples of 3 are not leap

        TEQ     R7, #100
        TEQNE   R7, #200
        TEQNE   R7, #300
        BEQ     NotLeapYr               ; if 100 or 200 or 300 then not leap

IsLeapYr
        CMP     R3, #3                  ; is leap, so if March 1st or after
        ADDCS   R0, R0, #1              ; then add extra day
NotLeapYr
        TEQ     R7, #0                  ; if mult of 400
        MOVEQ   R7, #400                ; then set to 400
        ADD     R0, R0, R7              ; add one for each year

        SUB     R7, R7, #1              ; R7 = last year to cope with
        ADD     R0, R0, R7, LSR #2      ; add one for each leap year

        CMP     R7, #100                ; subtract one if counting year 100
        SUBCS   R0, R0, #1
        CMP     R7, #200                ; subtract one if counting year 200
        SUBCS   R0, R0, #1
        CMP     R7, #300                ; subtract one if counting year 300
        SUBCS   R0, R0, #1

;       ADD     R0, R0, #0              ; fudge factor cos 1 Jan 1986 is Wed
        MOV     R5, #7
        DivRem  R1, R0, R5, R6

        Pull    "R1,R4-R7, PC"

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DaysToDate
 & 0,31,59,90,120,151,181,212,243,273,304,334
;  J F  M  A  M   J   J   A   S   O   N   D
@


4.2
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d769 3
d784 10
a793 1
     [  {TRUE}                          ; international version uses Territory_ConvertTimeStringToOrdinals
a907 133
     |

; first set up data in registers as follows :-
; R0 = hours
; R1 = minutes
; R2 = days
; R3 = months
; (R4 -> block)
; R5 = year(lo)
; R6 = year(hi)
; R7 = seconds
; R8 = centiseconds

; first do the date part, if appropriate

        TST     R9, #2
        MOVEQ   R2, #-1                 ; if not doing date, set days,
        MOVEQ   R3, #-1                 ; months, year(lo), year(hi) to -1
        MOVEQ   R5, #-1
        MOVEQ   R6, #-1
        BEQ     %FT50                   ; [not doing date]

; do the months

        LDRB    R1, [R4, #8]            ; get first char
        ORR     R1, R1, #&20            ; lower case it
        LDRB    R2, [R4, #9]            ; get second char
        ORR     R2, R2, #&20            ; lower case it
        ORR     R1, R1, R2, LSL #8      ; merge
        LDRB    R2, [R4, #10]           ; get third char
        ORR     R2, R2, #&20            ; lower case it
        ORR     R1, R1, R2, LSL #16     ; merge

        ADR     R2, MonthNameTable-4    ; months start at 1
        MOV     R3, #12                 ; try December first
10
        LDR     R0, [R2, R3, LSL #2]    ; get month word
        TEQ     R0, R1
        SUBNES  R3, R3, #1              ; if not equal, decrement month
        BNE     %BT10                   ; and if non-zero, loop

        TEQ     R3, #0                  ; failed to match ?
        BEQ     Bad0F                   ; then ignore all

; R3 now contains the month number

; do the days

        MOV     R1, #5                  ; offset to days
        BL      GetDecimalPair
        BCS     Bad0F                   ; bad digits

        MOVS    R2, R1
        BEQ     Bad0F                   ; zero days not allowed

        ADR     R0, MonthLengths        ; now validate days against
        LDRB    R1, [R0, R3]            ; maximum number of days in that month
        CMP     R1, R2                  ; (29 for Feb) and eliminate if invalid
        BCC     Bad0F

; R2 now contains the days

; now do the years so we can check whether 29 Feb is legal

        MOV     R1, #12                 ; offset to year(hi)
        BL      GetDecimalPair
        MOVCC   R6, R1

        MOVCC   R1, #14                 ; offset to year(lo)
        BLCC    GetDecimalPair
        MOVCC   R5, R1

        BCS     Bad0F

; now check for Feb 29

        TEQ     R3, #2                  ; month = Feb ?
        TEQEQ   R2, #29                 ; and day = 29 ?
        BNE     %FT20                   ; [not 29 Feb]

        TST     R5, #3                  ; is year multiple of 4
        BNE     Bad0F                   ; no, then 29 Feb is bad

        TEQ     R5, #0                  ; is it a century year ?
        BNE     %FT20                   ; no, then 29 Feb is good

        TST     R6, #3                  ; is it a multiple of 400 ?
        BNE     Bad0F                   ; no, then 29 Feb is bad

20
        ADD     R4, R4, #16             ; move on to time part

; now do the time part, if appropriate

50
        TST     R9, #1
        MOVEQ   R0, #-1                 ; if not doing time, set hours,
        MOVEQ   R1, #-1                 ; minutes and seconds to -1
        MOVEQ   R7, #-1
        MOVEQ   R8, #-1
        BEQ     %FT80                   ; [not doing time part]

; do the seconds

        MOV     R1, #7                  ; offset to seconds
        BL      GetDecimalPair
        CMPCC   R1, #60
        MOVCC   R7, R1

; zero the centiseconds

        MOV     R8, #0

; do the hours

        MOVCC   R1, #1                  ; offset to hours
        BLCC    GetDecimalPair
        CMPCC   R1, #24
        MOVCC   R0, R1

; do the minutes

        MOVCC   R1, #4
        BLCC    GetDecimalPair
        CMPCC   R1, #60

        BCS     Bad0F
80

; we have now completely validated the settings

    ] ;International version.

d913 10
@


4.1
log
@Initial revision
@
text
@d337 5
a341 1
        MOV     R2, #25                 ; 24 + CR terminator
d481 1
a481 1
        SUB     R0,R0,R1                
d525 1
a525 1
     
d564 1
a564 1
OsWord0EGamma ROUT   
d601 2
a602 2
        
        LDRB    R0,[R4,#1]              ; Year 
d613 1
a613 1
                        
d783 29
a811 1
        ADD     r10, r0, #3+1           ; round up number of bytes in block to word boundary, including null terminator
d847 1
a847 1
          
d863 1
a863 1
                 
d880 2
a881 2
        BVS     Bad0F     
                               
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d23 1
d33 3
d270 5
d321 2
d341 7
d358 74
d450 1
d499 17
d529 20
d562 1
d614 82
d777 1
d864 132
d1005 15
@


4.1.4.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d658 3
d667 1
d697 97
@


4.1.4.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d658 3
d667 1
d697 97
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Changes to cope with territories where %w3, %dy or %m3 are not the normal
lengths. To wit:

* Code variables Sys$Time, Sys$Date, Sys$Year don't assume field lengths.
* *Time doesn't assume OS_Word 14,0 output length is 24.
* OS_ConvertStandardDateAndTime now really does call the Territory Manager.
* OS_Word 14,0 no longer gives a maximum buffer length of 24 when calling
  OS_ConvertDateAndTime.
* OS_Word 15 doesn't assume reason code = length of string - attempt is
  made to terminate based on maximum string length, but callers really should
  be supplied control-terminated strings. Other offending modules (eg BASIC)
  have been fixed where spotted.
@
text
@d337 1
a337 5
; KJB 07-Sep-98: No-one is guaranteeing anywhere the length of %w3 or %m3 -
; see PRM 1-402 and 1-415. So give an indefinite buffer length here (making
; overflow the caller's problem - this call is obsolete anyway). Problem
; first noted with territory Japan, for which %m3 is potentially 5 bytes long.
        MOV     R2, #&10000000
d477 1
a477 1
        SUB     R0,R0,R1
d521 1
a521 1

d560 1
a560 1
OsWord0EGamma ROUT
d597 2
a598 2

        LDRB    R0,[R4,#1]              ; Year
d609 1
a609 1

d779 1
a779 29
        TST     R9, #2
        BEQ     %FT01

; KJB 980908 - can't assume length of date, as %w3, %dy and %m3 may be any length. Unfortunately,
; the string may not be terminated. Best we can do is plop a terminator at the maximum length position,
; which will at least cope with territories with fixed-length strings. Territories with variable length
; strings may work anyway, as territory modules are quite good at ignoring trailing junk. I've
; fixed things I've spotted that didn't terminate, such as BASIC.

        SUB     SP, SP, #48
        MOV     R0, #-1
        MOV     R2, SP                  ; R1 points to real memory - contents don't matter to us
        SWI     XTerritory_ReadCalendarInformation
        ADDVS   SP, SP, #48
        BVS     Bad0F

; need to work out maximum length of "%w3,%dy %m3 %ce%yr[.%24:%mi:%se]"
        TST     R9, #1
        MOVEQ   R0, #7                  ; length of ",  %ce%yr"
        MOVNE   R0, #16                 ; length of ",  %ce%yr.%24:%mi:%se"
        LDR     R10, [R2, #24]
        LDR     R14, [R2, #28]
        ADD     R0, R0, R10             ; + max length of %w3
        LDR     R10, [R2, #40]
        ADD     R0, R0, R14             ; + max length of %dy
        ADD     R0, R0, R10             ; + max length of %m3
        ADD     SP, SP, #48

01      ADD     r10, r0, #3+1           ; round up number of bytes in block to word boundary, including null terminator
d815 1
a815 1

d831 1
a831 1

d848 2
a849 2
        BVS     Bad0F

@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

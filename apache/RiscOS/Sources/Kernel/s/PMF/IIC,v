head	4.2;
access;
symbols
	Kernel-6_14:4.2
	Kernel-6_01-3:4.2
	Kernel-6_13:4.2
	Kernel-6_12:4.2
	Kernel-6_11:4.2
	Kernel-6_10:4.2
	Kernel-6_09:4.2
	Kernel-6_08-4_129_2_10:4.2
	Kernel-6_08-4_129_2_9:4.2
	Kernel-6_08:4.2
	Kernel-6_07:4.2
	Kernel-6_06:4.2
	Kernel-6_05-4_129_2_8:4.2
	Kernel-6_05:4.2
	Kernel-6_04:4.2
	Kernel-6_03:4.2
	Kernel-6_01-2:4.2
	Kernel-6_01-4_146_2_1:4.2
	Kernel-6_02:4.2
	Kernel-6_01-1:4.2
	Kernel-6_01:4.2
	Kernel-6_00:4.2
	Kernel-5_99:4.2
	Kernel-5_98:4.2
	Kernel-5_97-4_129_2_7:4.2
	Kernel-5_97:4.2
	Kernel-5_96:4.2
	Kernel-5_95:4.2
	Kernel-5_94:4.2
	Kernel-5_93:4.2
	Kernel-5_92:4.2
	Kernel-5_91:4.2
	Kernel-5_90:4.2
	Kernel-5_89-4_129_2_6:4.2
	Kernel-5_89:4.2
	Kernel-5_88-4_129_2_5:4.2
	Kernel-5_88-4_129_2_4:4.2
	Kernel-5_88:4.2
	Kernel-5_87:4.2
	Kernel-5_86-4_129_2_3:4.2
	Kernel-5_86-4_129_2_2:4.2
	Kernel-5_86-4_129_2_1:4.2
	Kernel-5_86:4.2
	SMP:4.2.0.2
	SMP_bp:4.2
	Kernel-5_85:4.2
	Kernel-5_54-1:4.2
	Kernel-5_84:4.2
	Kernel-5_83:4.2
	Kernel-5_82:4.2
	Kernel-5_81:4.2
	Kernel-5_80:4.2
	Kernel-5_79:4.2
	Kernel-5_78:4.2
	Kernel-5_77:4.2
	Kernel-5_76:4.2
	Kernel-5_75:4.2
	Kernel-5_74:4.2
	Kernel-5_73:4.2
	Kernel-5_72:4.2
	Kernel-5_71:4.2
	Kernel-5_70:4.2
	Kernel-5_69:4.2
	Kernel-5_68:4.2
	Kernel-5_67:4.2
	Kernel-5_66:4.2
	Kernel-5_65:4.2
	Kernel-5_64:4.2
	Kernel-5_63:4.2
	Kernel-5_62:4.2
	Kernel-5_61:4.2
	Kernel-5_60:4.2
	Kernel-5_59:4.2
	Kernel-5_58:4.2
	Kernel-5_57:4.2
	Kernel-5_56:4.2
	Kernel-5_55:4.2
	Kernel-5_54:4.2
	Kernel-5_53:4.2
	Kernel-5_52:4.2
	Kernel-5_51:4.2
	Kernel-5_50:4.2
	Kernel-5_49:4.2
	HAL_merge:1.1.2.13
	Kernel-5_48:4.1
	Kernel-5_35-4_79_2_327:1.1.2.13
	Kernel-5_35-4_79_2_326:1.1.2.13
	Kernel-5_35-4_79_2_325:1.1.2.13
	Kernel-5_35-4_79_2_324:1.1.2.13
	Kernel-5_35-4_79_2_323:1.1.2.13
	Kernel-5_35-4_79_2_322:1.1.2.13
	Kernel-5_35-4_79_2_321:1.1.2.13
	Kernel-5_35-4_79_2_320:1.1.2.13
	Kernel-5_35-4_79_2_319:1.1.2.13
	Kernel-5_35-4_79_2_318:1.1.2.13
	Kernel-5_35-4_79_2_317:1.1.2.13
	Kernel-5_35-4_79_2_316:1.1.2.13
	Kernel-5_35-4_79_2_315:1.1.2.13
	Kernel-5_35-4_79_2_314:1.1.2.13
	Kernel-5_35-4_79_2_313:1.1.2.13
	Kernel-5_35-4_79_2_312:1.1.2.13
	Kernel-5_35-4_79_2_311:1.1.2.13
	Kernel-5_35-4_79_2_310:1.1.2.13
	Kernel-5_35-4_79_2_309:1.1.2.13
	Kernel-5_35-4_79_2_308:1.1.2.13
	Kernel-5_35-4_79_2_307:1.1.2.13
	Kernel-5_35-4_79_2_306:1.1.2.13
	Kernel-5_35-4_79_2_305:1.1.2.13
	Kernel-5_35-4_79_2_304:1.1.2.13
	Kernel-5_35-4_79_2_303:1.1.2.13
	Kernel-5_35-4_79_2_302:1.1.2.13
	Kernel-5_35-4_79_2_301:1.1.2.13
	Kernel-5_35-4_79_2_300:1.1.2.13
	Kernel-5_35-4_79_2_299:1.1.2.13
	Kernel-5_35-4_79_2_298:1.1.2.13
	Kernel-5_35-4_79_2_297:1.1.2.13
	Kernel-5_35-4_79_2_296:1.1.2.13
	Kernel-5_35-4_79_2_295:1.1.2.13
	Kernel-5_35-4_79_2_294:1.1.2.13
	Kernel-5_35-4_79_2_293:1.1.2.13
	Kernel-5_35-4_79_2_292:1.1.2.13
	Kernel-5_35-4_79_2_291:1.1.2.13
	Kernel-5_35-4_79_2_290:1.1.2.13
	Kernel-5_35-4_79_2_289:1.1.2.13
	Kernel-5_35-4_79_2_288:1.1.2.12
	Kernel-5_35-4_79_2_287:1.1.2.12
	Kernel-5_35-4_79_2_286:1.1.2.12
	Kernel-5_35-4_79_2_285:1.1.2.12
	Kernel-5_35-4_79_2_284:1.1.2.12
	Kernel-5_35-4_79_2_283:1.1.2.12
	Kernel-5_35-4_79_2_282:1.1.2.12
	Kernel-5_35-4_79_2_281:1.1.2.12
	Kernel-5_35-4_79_2_280:1.1.2.12
	Kernel-5_35-4_79_2_279:1.1.2.12
	Kernel-5_35-4_79_2_278:1.1.2.12
	Kernel-5_35-4_79_2_277:1.1.2.12
	Kernel-5_35-4_79_2_276:1.1.2.12
	Kernel-5_35-4_79_2_275:1.1.2.12
	Kernel-5_35-4_79_2_274:1.1.2.12
	Kernel-5_35-4_79_2_273:1.1.2.12
	Kernel-5_35-4_79_2_272:1.1.2.12
	Kernel-5_35-4_79_2_271:1.1.2.12
	Kernel-5_35-4_79_2_270:1.1.2.12
	Kernel-5_35-4_79_2_269:1.1.2.12
	Kernel-5_35-4_79_2_268:1.1.2.12
	Kernel-5_35-4_79_2_267:1.1.2.12
	Kernel-5_35-4_79_2_266:1.1.2.12
	Kernel-5_35-4_79_2_265:1.1.2.12
	Kernel-5_35-4_79_2_264:1.1.2.12
	Kernel-5_35-4_79_2_263:1.1.2.12
	Kernel-5_35-4_79_2_262:1.1.2.12
	Kernel-5_35-4_79_2_261:1.1.2.12
	Kernel-5_35-4_79_2_260:1.1.2.12
	Kernel-5_35-4_79_2_259:1.1.2.11
	Kernel-5_35-4_79_2_258:1.1.2.11
	Kernel-5_35-4_79_2_257:1.1.2.11
	Kernel-5_35-4_79_2_256:1.1.2.11
	Kernel-5_35-4_79_2_255:1.1.2.11
	Kernel-5_35-4_79_2_254:1.1.2.11
	Kernel-5_35-4_79_2_253:1.1.2.11
	Kernel-5_35-4_79_2_252:1.1.2.11
	Kernel-5_35-4_79_2_251:1.1.2.11
	Kernel-5_35-4_79_2_250:1.1.2.11
	Kernel-5_35-4_79_2_249:1.1.2.11
	Kernel-5_35-4_79_2_248:1.1.2.11
	Kernel-5_35-4_79_2_247:1.1.2.11
	Kernel-5_35-4_79_2_246:1.1.2.11
	Kernel-5_35-4_79_2_245:1.1.2.11
	Kernel-5_35-4_79_2_244:1.1.2.11
	Kernel-5_35-4_79_2_243:1.1.2.11
	Kernel-5_35-4_79_2_242:1.1.2.11
	Kernel-5_35-4_79_2_241:1.1.2.11
	Kernel-5_35-4_79_2_240:1.1.2.11
	Kernel-5_35-4_79_2_239:1.1.2.11
	Kernel-5_35-4_79_2_238:1.1.2.10
	Kernel-5_35-4_79_2_237:1.1.2.10
	Kernel-5_35-4_79_2_236:1.1.2.10
	Kernel-5_35-4_79_2_235:1.1.2.9
	Kernel-5_35-4_79_2_234:1.1.2.9
	Kernel-5_35-4_79_2_233:1.1.2.9
	Kernel-5_35-4_79_2_232:1.1.2.9
	Kernel-5_35-4_79_2_231:1.1.2.9
	Kernel-5_35-4_79_2_230:1.1.2.9
	Kernel-5_35-4_79_2_229:1.1.2.9
	Kernel-5_35-4_79_2_228:1.1.2.9
	Kernel-5_35-4_79_2_227:1.1.2.9
	Kernel-5_35-4_79_2_226:1.1.2.9
	Kernel-5_35-4_79_2_225:1.1.2.9
	Kernel-5_35-4_79_2_224:1.1.2.9
	Kernel-5_35-4_79_2_223:1.1.2.9
	Kernel-5_35-4_79_2_222:1.1.2.9
	Kernel-5_35-4_79_2_221:1.1.2.9
	Kernel-5_35-4_79_2_220:1.1.2.9
	Kernel-5_35-4_79_2_219:1.1.2.9
	Kernel-5_35-4_79_2_218:1.1.2.9
	Kernel-5_35-4_79_2_217:1.1.2.8
	Kernel-5_35-4_79_2_216:1.1.2.8
	Kernel-5_35-4_79_2_215:1.1.2.8
	Kernel-5_35-4_79_2_214:1.1.2.8
	Kernel-5_35-4_79_2_213:1.1.2.8
	Kernel-5_35-4_79_2_212:1.1.2.8
	Kernel-5_35-4_79_2_211:1.1.2.8
	Kernel-5_35-4_79_2_210:1.1.2.8
	Kernel-5_35-4_79_2_209:1.1.2.8
	Kernel-5_35-4_79_2_208:1.1.2.8
	Kernel-5_35-4_79_2_207:1.1.2.8
	Kernel-5_35-4_79_2_206:1.1.2.8
	Kernel-5_35-4_79_2_205:1.1.2.8
	Kernel-5_35-4_79_2_204:1.1.2.8
	Kernel-5_35-4_79_2_203:1.1.2.8
	Kernel-5_35-4_79_2_202:1.1.2.8
	Kernel-5_35-4_79_2_201:1.1.2.8
	Kernel-5_35-4_79_2_200:1.1.2.8
	Kernel-5_35-4_79_2_199:1.1.2.8
	Kernel-5_35-4_79_2_198:1.1.2.8
	Kernel-5_35-4_79_2_197:1.1.2.8
	Kernel-5_35-4_79_2_196:1.1.2.8
	Kernel-5_35-4_79_2_195:1.1.2.8
	Kernel-5_35-4_79_2_194:1.1.2.8
	Kernel-5_35-4_79_2_193:1.1.2.8
	Kernel-5_35-4_79_2_192:1.1.2.8
	Kernel-5_35-4_79_2_191:1.1.2.8
	Kernel-5_35-4_79_2_190:1.1.2.8
	Kernel-5_35-4_79_2_189:1.1.2.8
	Kernel-5_35-4_79_2_188:1.1.2.8
	Kernel-5_35-4_79_2_187:1.1.2.8
	Kernel-5_35-4_79_2_186:1.1.2.8
	Kernel-5_35-4_79_2_185:1.1.2.8
	Kernel-5_35-4_79_2_184:1.1.2.8
	Kernel-5_35-4_79_2_183:1.1.2.8
	Kernel-5_35-4_79_2_182:1.1.2.8
	Kernel-5_35-4_79_2_181:1.1.2.8
	Kernel-5_35-4_79_2_180:1.1.2.8
	Kernel-5_35-4_79_2_179:1.1.2.8
	Kernel-5_35-4_79_2_178:1.1.2.8
	Kernel-5_35-4_79_2_177:1.1.2.8
	Kernel-5_35-4_79_2_176:1.1.2.8
	Kernel-5_35-4_79_2_175:1.1.2.8
	Kernel-5_35-4_79_2_174:1.1.2.8
	Kernel-5_35-4_79_2_173:1.1.2.8
	Kernel-5_35-4_79_2_172:1.1.2.8
	Kernel-5_35-4_79_2_171:1.1.2.8
	Kernel-5_35-4_79_2_170:1.1.2.8
	Kernel-5_35-4_79_2_169:1.1.2.8
	Kernel-5_35-4_79_2_168:1.1.2.8
	Kernel-5_35-4_79_2_167:1.1.2.8
	Kernel-5_35-4_79_2_166:1.1.2.8
	Kernel-5_35-4_79_2_165:1.1.2.8
	RPi_merge:1.1.2.7.2.1
	Kernel-5_35-4_79_2_147_2_23:1.1.2.7.2.1
	Kernel-5_35-4_79_2_147_2_22:1.1.2.7.2.1
	Kernel-5_35-4_79_2_147_2_21:1.1.2.7
	Kernel-5_35-4_79_2_147_2_20:1.1.2.7
	Kernel-5_35-4_79_2_147_2_19:1.1.2.7
	Kernel-5_35-4_79_2_147_2_18:1.1.2.7
	Kernel-5_35-4_79_2_164:1.1.2.7
	Kernel-5_35-4_79_2_163:1.1.2.7
	Kernel-5_35-4_79_2_147_2_17:1.1.2.7
	Kernel-5_35-4_79_2_147_2_16:1.1.2.7
	Kernel-5_35-4_79_2_147_2_15:1.1.2.7
	Kernel-5_35-4_79_2_162:1.1.2.7
	Kernel-5_35-4_79_2_161:1.1.2.7
	Kernel-5_35-4_79_2_147_2_14:1.1.2.7
	Kernel-5_35-4_79_2_147_2_13:1.1.2.7
	Kernel-5_35-4_79_2_160:1.1.2.7
	Kernel-5_35-4_79_2_159:1.1.2.7
	Kernel-5_35-4_79_2_158:1.1.2.7
	Kernel-5_35-4_79_2_157:1.1.2.7
	Kernel-5_35-4_79_2_156:1.1.2.7
	Kernel-5_35-4_79_2_147_2_12:1.1.2.7
	Kernel-5_35-4_79_2_147_2_11:1.1.2.7
	Kernel-5_35-4_79_2_155:1.1.2.7
	Kernel-5_35-4_79_2_147_2_10:1.1.2.7
	Kernel-5_35-4_79_2_154:1.1.2.7
	Kernel-5_35-4_79_2_153:1.1.2.7
	Kernel-5_35-4_79_2_147_2_9:1.1.2.7
	Kernel-5_35-4_79_2_152:1.1.2.7
	Kernel-5_35-4_79_2_151:1.1.2.7
	Kernel-5_35-4_79_2_147_2_8:1.1.2.7
	Kernel-5_35-4_79_2_147_2_7:1.1.2.7
	Kernel-5_35-4_79_2_150:1.1.2.7
	Kernel-5_35-4_79_2_147_2_6:1.1.2.7
	Kernel-5_35-4_79_2_147_2_5:1.1.2.7
	Kernel-5_35-4_79_2_149:1.1.2.7
	Kernel-5_35-4_79_2_147_2_4:1.1.2.7
	Kernel-5_35-4_79_2_147_2_3:1.1.2.7
	Kernel-5_35-4_79_2_148:1.1.2.7
	Kernel-5_35-4_79_2_147_2_2:1.1.2.7
	Kernel-5_35-4_79_2_147_2_1:1.1.2.7
	RPi:1.1.2.7.0.2
	RPi_bp:1.1.2.7
	Kernel-5_35-4_79_2_98_2_52_2_1:1.1.2.6.2.3
	alees_Kernel_dev:1.1.2.6.2.3.0.2
	alees_Kernel_dev_bp:1.1.2.6.2.3
	Kernel-5_35-4_79_2_147:1.1.2.7
	Kernel-5_35-4_79_2_146:1.1.2.7
	Kernel-5_35-4_79_2_145:1.1.2.7
	Kernel-5_35-4_79_2_144:1.1.2.7
	Kernel-5_35-4_79_2_143:1.1.2.7
	Kernel-5_35-4_79_2_142:1.1.2.7
	Kernel-5_35-4_79_2_141:1.1.2.7
	Kernel-5_35-4_79_2_140:1.1.2.7
	Kernel-5_35-4_79_2_139:1.1.2.7
	Kernel-5_35-4_79_2_138:1.1.2.7
	Kernel-5_35-4_79_2_137:1.1.2.7
	Kernel-5_35-4_79_2_136:1.1.2.7
	Kernel-5_35-4_79_2_135:1.1.2.7
	Kernel-5_35-4_79_2_134:1.1.2.7
	Kernel-5_35-4_79_2_133:1.1.2.7
	Kernel-5_35-4_79_2_132:1.1.2.7
	Kernel-5_35-4_79_2_131:1.1.2.7
	Kernel-5_35-4_79_2_130:1.1.2.7
	Kernel-5_35-4_79_2_129:1.1.2.7
	Kernel-5_35-4_79_2_128:1.1.2.7
	Kernel-5_35-4_79_2_127:1.1.2.7
	Kernel-5_35-4_79_2_126:1.1.2.7
	Kernel-5_35-4_79_2_125:1.1.2.7
	Kernel-5_35-4_79_2_124:1.1.2.7
	Kernel-5_35-4_79_2_123:1.1.2.7
	Cortex_merge:1.1.2.6.2.3
	Kernel-5_35-4_79_2_122:1.1.2.6
	Kernel-5_35-4_79_2_98_2_54:1.1.2.6.2.3
	Kernel-5_35-4_79_2_98_2_53:1.1.2.6.2.3
	Kernel-5_35-4_79_2_98_2_52:1.1.2.6.2.3
	Kernel-5_35-4_79_2_98_2_51:1.1.2.6.2.3
	Kernel-5_35-4_79_2_98_2_50:1.1.2.6.2.3
	Kernel-5_35-4_79_2_98_2_49:1.1.2.6.2.3
	Kernel-5_35-4_79_2_98_2_48:1.1.2.6.2.3
	Kernel-5_35-4_79_2_121:1.1.2.6
	Kernel-5_35-4_79_2_98_2_47:1.1.2.6.2.2
	Kernel-5_35-4_79_2_120:1.1.2.6
	Kernel-5_35-4_79_2_98_2_46:1.1.2.6.2.2
	Kernel-5_35-4_79_2_119:1.1.2.6
	Kernel-5_35-4_79_2_98_2_45:1.1.2.6.2.2
	Kernel-5_35-4_79_2_98_2_44:1.1.2.6.2.2
	Kernel-5_35-4_79_2_118:1.1.2.6
	Kernel-5_35-4_79_2_98_2_43:1.1.2.6.2.2
	Kernel-5_35-4_79_2_117:1.1.2.6
	Kernel-5_35-4_79_2_116:1.1.2.6
	Kernel-5_35-4_79_2_98_2_42:1.1.2.6.2.2
	Kernel-5_35-4_79_2_115:1.1.2.6
	Kernel-5_35-4_79_2_98_2_41:1.1.2.6.2.2
	Kernel-5_35-4_79_2_98_2_40:1.1.2.6.2.2
	Kernel-5_35-4_79_2_114:1.1.2.6
	Kernel-5_35-4_79_2_98_2_39:1.1.2.6.2.2
	Kernel-5_35-4_79_2_98_2_38:1.1.2.6.2.2
	Kernel-5_35-4_79_2_113:1.1.2.6
	Kernel-5_35-4_79_2_112:1.1.2.6
	Kernel-5_35-4_79_2_98_2_37:1.1.2.6.2.2
	Kernel-5_35-4_79_2_98_2_36:1.1.2.6.2.2
	Kernel-5_35-4_79_2_98_2_35:1.1.2.6.2.2
	Kernel-5_35-4_79_2_98_2_34:1.1.2.6.2.2
	Kernel-5_35-4_79_2_98_2_33:1.1.2.6.2.2
	Kernel-5_35-4_79_2_98_2_32:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_31:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_30:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_29:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_28:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_27:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_26:1.1.2.6.2.1
	Kernel-5_35-4_79_2_111:1.1.2.6
	Kernel-5_35-4_79_2_98_2_25:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_24:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_23:1.1.2.6.2.1
	Kernel-5_35-4_79_2_110:1.1.2.6
	Kernel-5_35-4_79_2_98_2_22:1.1.2.6.2.1
	Kernel-5_35-4_79_2_109:1.1.2.6
	Kernel-5_35-4_79_2_98_2_21:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_20:1.1.2.6.2.1
	Kernel-5_35-4_79_2_108:1.1.2.6
	Kernel-5_35-4_79_2_107:1.1.2.6
	Kernel-5_35-4_79_2_98_2_19:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_18:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_17:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_16:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_15:1.1.2.6.2.1
	Kernel-5_35-4_79_2_106:1.1.2.6
	Kernel-5_35-4_79_2_105:1.1.2.6
	Kernel-5_35-4_79_2_104:1.1.2.6
	Kernel-5_35-4_79_2_98_2_14:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_13:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_12:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_11:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_10:1.1.2.6.2.1
	Kernel-5_35-4_79_2_98_2_9:1.1.2.6
	Kernel-5_35-4_79_2_103:1.1.2.6
	Kernel-5_35-4_79_2_102:1.1.2.6
	Kernel-5_35-4_79_2_98_2_8:1.1.2.6
	Kernel-5_35-4_79_2_98_2_7:1.1.2.6
	Kernel-5_35-4_79_2_98_2_6:1.1.2.6
	Kernel-5_35-4_79_2_98_2_5:1.1.2.6
	Kernel-5_35-4_79_2_98_2_4:1.1.2.6
	Kernel-5_35-4_79_2_101:1.1.2.6
	Kernel-5_35-4_79_2_100:1.1.2.6
	Kernel-5_35-4_79_2_99:1.1.2.6
	Kernel-5_35-4_79_2_98_2_3:1.1.2.6
	Kernel-5_35-4_79_2_98_2_2:1.1.2.6
	Kernel-5_35-4_79_2_98_2_1:1.1.2.6
	Cortex:1.1.2.6.0.2
	Cortex_bp:1.1.2.6
	Kernel-5_35-4_79_2_98:1.1.2.6
	Kernel-5_35-4_79_2_97:1.1.2.6
	Kernel-5_35-4_79_2_96:1.1.2.6
	Kernel-5_35-4_79_2_95:1.1.2.6
	Kernel-5_35-4_79_2_94:1.1.2.6
	Kernel-5_35-4_79_2_93:1.1.2.6
	Kernel-5_35-4_79_2_92:1.1.2.6
	Kernel-5_35-4_79_2_91:1.1.2.6
	Kernel-5_35-4_79_2_90:1.1.2.6
	Kernel-5_35-4_79_2_89:1.1.2.6
	Kernel-5_35-4_79_2_88:1.1.2.6
	Kernel-5_35-4_79_2_87:1.1.2.6
	Kernel-5_35-4_79_2_86:1.1.2.6
	Kernel-5_35-4_79_2_85:1.1.2.6
	Kernel-5_35-4_79_2_84:1.1.2.6
	Kernel-5_35-4_79_2_83:1.1.2.6
	Kernel-5_35-4_79_2_82:1.1.2.6
	Kernel-5_35-4_79_2_81:1.1.2.6
	Kernel-5_35-4_79_2_80:1.1.2.6
	Kernel-5_35-4_79_2_79:1.1.2.6
	Kernel-5_35-4_79_2_78:1.1.2.6
	Kernel-5_35-4_79_2_77:1.1.2.6
	RO_5_07:1.1.2.6
	Kernel-5_35-4_79_2_76:1.1.2.6
	Kernel-5_35-4_79_2_75:1.1.2.6
	Kernel-5_35-4_79_2_74:1.1.2.6
	Kernel-5_35-4_79_2_73:1.1.2.6
	Kernel-5_35-4_79_2_72:1.1.2.6
	Kernel-5_35-4_79_2_71:1.1.2.6
	Kernel-5_35-4_79_2_70:1.1.2.6
	Kernel-5_35-4_79_2_69:1.1.2.6
	Kernel-5_35-4_79_2_68:1.1.2.6
	Kernel-5_35-4_79_2_67:1.1.2.6
	Kernel-5_35-4_79_2_66:1.1.2.6
	Kernel-5_35-4_79_2_65:1.1.2.6
	Kernel-5_35-4_79_2_64:1.1.2.6
	Kernel-5_35-4_79_2_63:1.1.2.6
	Kernel-5_35-4_79_2_62:1.1.2.6
	Kernel-5_35-4_79_2_61:1.1.2.6
	Kernel-5_35-4_79_2_59:1.1.2.6
	Kernel-5_35-4_79_2_58:1.1.2.6
	Kernel-5_35-4_79_2_57:1.1.2.6
	Kernel-5_35-4_79_2_56:1.1.2.6
	Kernel-5_35-4_79_2_55:1.1.2.6
	Kernel-5_35-4_79_2_54:1.1.2.5
	Kernel-5_35-4_79_2_53:1.1.2.5
	Kernel-5_35-4_79_2_52:1.1.2.5
	Kernel-5_35-4_79_2_51:1.1.2.5
	Kernel-5_35-4_79_2_50:1.1.2.4
	Kernel-5_35-4_79_2_49:1.1.2.4
	Kernel-5_35-4_79_2_48:1.1.2.4
	Kernel-5_35-4_79_2_47:1.1.2.3
	Kernel-5_35-4_79_2_46:1.1.2.2
	Kernel-5_35-4_79_2_45:1.1.2.2
	Kernel-5_35-4_79_2_44:1.1.2.2
	Kernel-5_35-4_79_2_25_2_2:1.1.2.1
	Kernel-5_35-4_79_2_43:1.1.2.2
	Kernel-5_35-4_79_2_42:1.1.2.2
	Kernel-5_35-4_79_2_41:1.1.2.2
	Kernel-5_35-4_79_2_40:1.1.2.2
	Kernel-5_35-4_79_2_39:1.1.2.2
	Kernel-5_35-4_79_2_38:1.1.2.2
	Kernel-5_35-4_79_2_37:1.1.2.2
	Kernel-5_35-4_79_2_36:1.1.2.2
	Kernel-5_35-4_79_2_35:1.1.2.2
	Kernel-5_35-4_79_2_34:1.1.2.2
	Kernel-5_35-4_79_2_33:1.1.2.2
	Kernel-5_35-4_79_2_32:1.1.2.2
	Kernel-5_35-4_79_2_25_2_1:1.1.2.1
	Kernel-5_35-4_79_2_31:1.1.2.2
	Kernel-5_35-4_79_2_30:1.1.2.2
	Kernel-5_35-4_79_2_29:1.1.2.2
	Kernel-5_35-4_79_2_28:1.1.2.2
	Kernel-5_35-4_79_2_27:1.1.2.2
	Kernel-5_35-4_79_2_26:1.1.2.2
	Kernel-5_35-4_79_2_25:1.1.2.1
	Kernel-5_35-4_79_2_24:1.1.2.1
	Kernel-5_35-4_79_2_23:1.1.2.1
	Kernel-5_35-4_79_2_22:1.1.2.1
	Kernel-5_35-4_79_2_21:1.1.2.1
	Kernel-5_35-4_79_2_20:1.1.2.1
	Kernel-5_35-4_79_2_19:1.1.2.1
	HAL:1.1.0.2;
locks; strict;
comment	@# @;


4.2
date	2016.06.30.20.29.02;	author jlee;	state Exp;
branches;
next	4.1;
commitid	lMnWzoE9eJz3Wwcz;

4.1
date	2016.06.30.20.08.15;	author jlee;	state Exp;
branches;
next	1.1;
commitid	IWoXxARWeuLDOwcz;

1.1
date	2001.03.08.17.53.37;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.03.08.17.53.37;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.04.11.09.12.11;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.02.07.17.03.45;	author bavison;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.10.07.17.29.43;	author kbracey;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.11.30.00.31.11;	author bavison;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.01.27.15.25.36;	author kbracey;	state Exp;
branches
	1.1.2.6.2.1;
next	1.1.2.7;

1.1.2.7
date	2011.11.26.21.11.23;	author jlee;	state Exp;
branches
	1.1.2.7.2.1;
next	1.1.2.8;
commitid	cI3W0zbtALQG6TIv;

1.1.2.8
date	2012.09.18.22.01.18;	author jlee;	state Exp;
branches;
next	1.1.2.9;
commitid	eFa3Y1QY0MjZP3lw;

1.1.2.9
date	2014.04.14.19.22.51;	author rsprowson;	state Exp;
branches;
next	1.1.2.10;
commitid	I3FLhMw0FZGHxGwx;

1.1.2.10
date	2014.09.15.22.25.34;	author jlee;	state Exp;
branches;
next	1.1.2.11;
commitid	hm3PUFF80LIvBuQx;

1.1.2.11
date	2014.09.26.18.44.43;	author rsprowson;	state Exp;
branches;
next	1.1.2.12;
commitid	h9RGy0im7cYE1TRx;

1.1.2.12
date	2015.03.16.21.25.47;	author jlee;	state Exp;
branches;
next	1.1.2.13;
commitid	O3sJbVfbkfpiqSdy;

1.1.2.13
date	2015.09.20.20.18.54;	author jlee;	state Exp;
branches;
next	;
commitid	Kzwry9MWnYRF02Cy;

1.1.2.6.2.1
date	2009.07.17.00.19.57;	author jlee;	state Exp;
branches;
next	1.1.2.6.2.2;

1.1.2.6.2.2
date	2011.02.19.22.19.38;	author jlee;	state Exp;
branches;
next	1.1.2.6.2.3;

1.1.2.6.2.3
date	2011.08.08.23.28.34;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

1.1.2.7.2.1
date	2012.09.18.13.44.39;	author jlee;	state Exp;
branches;
next	;
commitid	2BntgJjnyfkD51lw;


desc
@@


4.2
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; 19-Feb-01  KJB   Separated IIC operations from NVMemory and RTC code
; 05-Feb-02  BJGA  Added re-entrant capability


PollMax         *       150     ; Number of times to poll for an Ack (increase if you
                                ; clock faster - need to allow 5ms for write cycle).


; Choose a lower limit on the number of ticks per clock phase based on the
; MaxI2Cspeed variable defined in Hdr:Machine.<Machine>
  [ MaxI2Cspeed >= 1000
I2Cticks        *       1
  |
  [ MaxI2Cspeed >= 400
I2Cticks        *       3
  |
I2Cticks        *       10
  ]
  ]


IICStackAlignment       *       7       ; log2 of stack size, also stack alignment
                                        ; current requirement is 19 words = 2_01001100 bytes

                ^       0
IICLink_Next    #       4
IICLink_Error   #       4
IICLink_Array   #       4
IICLink_Size    #       4

; SVC stack format, in descending address order:
;    16 bytes   first link (also bottom of stacked registers)
;     n bytes   align to address with bottom x bits set
; 2^x-4 bytes   align to address with bottom x bits clear (the local stack)
;     4 bytes   linked list head
;     4 bytes   linked list tail
;     4 bytes   original sp
;      .
;      .
;      .
;    16 bytes   another link (also bottom of stacked registers)
;     4 bytes   original sp

; IRQ stack format, in descending address order, for reference:
;     4 bytes   lr_irq-4 (interrupted PC)
;     4 bytes   r0
;     4 bytes   spsr_irq (interrupted CPSR)
;    20 bytes   r1-r3, r11, r12
;     4 bytes   IRQsema link


iicsp   RN      11
iiclr   RN      12


        MACRO
$label  iicBL   $destination, $cond
$label  MOV$cond iiclr, pc
        B$cond  $destination
        MEND

        MACRO
$label  iicPull $reglist, $cond, $hat
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   "$hat" = ""
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  LDR$cond $reglist, [iicsp], #4
        |
$label  LDM$cond.FD iicsp!, {$reglist}$hat
        ]
        MEND

        MACRO
$label  iicPush $reglist, $cond
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   {TRUE}
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  STR$cond $reglist, [iicsp, #-4]!
        |
$label  STM$cond.FD iicsp!, {$reglist}
        ]
        MEND



IICOpSWI
        Push    "R0-R3,sb,LR"
        ; Check bus index is valid
        AddressHAL
        CallHAL HAL_IICBuses
        MOV     LR, R0
        Pull    "R0-R3,sb"
        CMP     R1, LR, LSL #24         ; n.b. fails if we have 256 buses (unlikely!)
        BHS     %FT50
        ; Check descriptor ptr & count
        BICS    lr, R1, #&FF000000
        TEQNE   R0, #0
        BEQ     %FT50
        TST     R0, #3
        BNE     %FT50
        ; Params look vaguely sensible, call through to the core code
        BL      IIC_OpV
        Pull    LR
        B       SLVK_TestV
50
        ADRL    R0, ErrorBlock_BadParameters
    [ International
        BL     TranslateError
    |
        SETV
    ]
        Pull    LR
        B       SLVK_TestV        


; *****************************************************************************
;
; in:   R0 = device address (bit 0 set => read, clear => write)
;       R1 -> data block
;       R2 = length of data block
;
IIC_Op
        Push    "R0-R2,LR"
        Push    "R0-R2"                 ; soft copy for IIC_OpV to work on
        MOV     R0, R13
        MOV     R1, #1
        BL      IIC_OpV
        ADD     R13, R13, #12           ; junk soft copy
        Pull    "R0-R2,PC",VC
        ADD     R13, R13, #4
        Pull    "R1-R2,PC"

; *****************************************************************************
;
; IIC_OpV - perform IIC operations based on a list of descriptors
;
; in:   R0 -> array of transfer descriptors
;       R1 = bits 0-23: number of transfers
;            bits 24-31: bus number
;
; out:  transfer descriptors may be updated (beware)
;
; Transfer descriptor is 3 words: word 0 = device address (+direction)
;                                         (bit 29 signifies retry for response)
;                                         (bit 30 signifies checksum read only - ie fill in word 1 with
;                                          sum of bytes read)
;                                         (bit 31 signifies continued transfer - ie no start or address)
;                                 word 1 -> data block
;                                 word 2 = length of data block
IIC_OpV ROUT
        Push    "r0-r3,r6-r12,lr"
        MOV     lr, #0
        STR     lr, [sp, #-8]!
        MOV     r3, r1, LSR #24
        MRS     r10, CPSR
        BIC     r7, r10, #I32_bit :OR: F32_bit
        ORR     r8, r7, #I32_bit
      [ HAL
        AddressHAL
      |
        MOV     r9, #IOC
      ]
        LDR     r2, =ZeroPage+IRQsema
        MOV     r12, sp                 ; original sp, also pointer to link
        ORR     lr, r8, #2_10000
        MSR     CPSR_c, lr              ; IRQs off, force 32-bit mode

01      LDR     r2, [r2]
        TEQ     r2, #0
        BEQ     %FT50                   ; I²C code not in IRQ stack
        LDR     r6, [r2, #4*8]          ; interrupted PC
IIC_OpV_PCReference
        RSB     lr, pc, r6
        LDR     r0, =(interrupt_protected_end-4) - (IIC_OpV_PCReference+8)
        CMP     lr, r0
        RSBLES  lr, lr, #interrupt_protected_start - (IIC_OpV_PCReference+8)
        BGT     %BT01

        ; I²C code is already threaded
        LDR     r0, [r2, #4*4]          ; retrieve interrupted iicsp
        BIC     r0, r0, #(1:SHL:IICStackAlignment)-1
        LDR     r1, [r0, #-8]           ; old list tail
        LDRB    r11, [r1, #IICLink_Size+3] ; get bus number
        CMP     r11, r3
        BNE     %BT01                   ; wrong bus, don't add ourselves to this list
        
        Push    "r12"                   ; put original sp on stack for our exit routine
        STR     r12, [r0, #-8]          ; new list tail
        STR     r12, [r1, #IICLink_Next] ; point old link to new link
        ADR     r0, IIC_OpV_CommonExit
        STR     r0, [r2, #4*8]          ; poke IRQ stack so previous operation returns as though completed
        LDR     r0, [r2, #4*6]          ; get interrupted CPSR
        MSR     SPSR_cxsf, r0           ; stick it in SPSR (okay, because IRQs are off)
        LDR     r0, [r2, #4*7]
        LDMIB   r2, {r1-r3,r11,r12}
        MOVS    pc, r6                  ; copy SPSR to CPSR and resume execution

50      ; I²C code not currently threaded - create new environment
        ADD     iicsp, sp, #4
        BIC     iicsp, iicsp, #(1:SHL:IICStackAlignment)-1
        SUB     iicsp, iicsp, #4
        BIC     sp, iicsp, #(1:SHL:IICStackAlignment)-1
        Push    "r12"                   ; list head pointer
        Push    "r12"                   ; list tail pointer
        Push    "r12"                   ; original sp
        LDR     r0, [r12, #IICLink_Array]
        LDR     r1, [r12, #IICLink_Size]
        B       IICStart                ; start working through list

IIC_OpV_CommonExit
        MSR     CPSR_c, r10             ; restore original IRQ disable state
        LDR     sp, [sp]
        ADD     sp, sp, #4              ; skip next pointer
        Pull    "r0"
        CMP     r0, #0
        Pull    "r0-r3,r6-r12,pc", EQ
        SETV
        ADD     sp, sp, #4
        Pull    "r1-r3,r6-r12,pc"


interrupt_protected_start

; Protected routines register usage:
;   r0-r3   general purpose
;    r7     MRS style PSR with c bits = SVC26/32, IRQs/FIQs enabled
;    r8     MRS style PSR with c bits = SVC26/32, IRQs disabled, FIQs enabled
;    r9     IOC, or base of HAL workspace, depending on HAL switch
;    r11    stack pointer
;    r12    link register / general purpose
;    CPSR is also non-volatile

IICStart
        MSR     CPSR_c, r7              ; enable IRQs (inside protected code) - this may take some time
        ; drop through...

; *****************************************************************************
;
;       IICLoop - serial-execution outermost loop, stepping along pending IIC operations
;

IICLoop
     iicBL      IICDoOp
        MOVVC   r0, #0
        BIC     r1, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r2, [r1, #-4]           ; list head
        STR     r0, [r2, #IICLink_Error] ; set up return value
        MSR     CPSR_c, r8              ; disable IRQs while we work on the list
        LDR     r2, [r2]
        TEQ     r2, #0                  ; end of list?
        BEQ     IIC_OpV_CommonExit      ; finished!
        STR     r2, [r1, #-4]           ; update list head
        MSR     CPSR_c, r7              ; IRQs back on
        LDR     r0, [r2, #IICLink_Array]
        LDR     r1, [r2, #IICLink_Size] ; get next array
        B       IICLoop                 ; and loop

; *****************************************************************************
;
;       IICDoOp - main serial-execution entry point
;
; in:   R0 -> array of transfer descriptors
;       R1 = bits 0-23: number of transfers
;            bits 24-31: bus number
;
; out:  if V set, r0 -> error block
;       otherwise r0-r3,r12 may be corrupted
;

IICDoOp ROUT
        MOV     R1, R1, ROR #24         ; Move bus number to low byte
        MOV     R2, #0
     iicPush    "R1,R2,iiclr"           ; two words on stack are RepeatedStart flag and transfers remaining

        ; Get correct IICBus ptr in R2
        AND     R3, R1, #255
        MOV     iiclr, #IICBus_Size
        LDR     R2, =ZeroPage+IICBus_Base
        MLA     R2, R3, iiclr, R2

        MOV     R3, R0

        LDR     iiclr, [R2, #IICBus_Type]
        TST     iiclr, #IICFlag_HighLevel
        BNE     IIC_OpV_HAL             ; HAL can make use of a hardware IIC engine

05      LDR     R0, [iicsp]
        SUBS    R0, R0, #256
        BLT     %FT90
        STR     R0, [iicsp]

        LDMIA   R3!, {R0-R2}
        TST     R0, #1:SHL:31           ; skip start?
        BNE     %FT08

        LDR     iiclr, [iicsp, #4]
        TEQ     iiclr, #0
        MOV     iiclr, pc
        ADD     iiclr, iiclr, #8
        BEQ     Start
        BNE     RepeatedStart           ; these are effectively conditional BL's

        TST     R0, #1:SHL:29
        BNE     %FT06
     iicBL      TXAck                   ; transmit device address without retries
        B       %FT07

06
     iicBL      TXPollAck               ; transmit device address with retries
07      BVS     %FT80

08      MOV     iiclr, #1
        STR     iiclr, [iicsp, #4]
        TEQ     R2, #0
        BEQ     %BT05

        TST     R0, #1                  ; Z => write, NZ => read
        BNE     %FT20

; Write case
10      LDRB    R0, [R1], #1            ; read byte from data block
     iicBL      TXAck                   ; transmit, checking for ack
        BVS     %FT80
        SUBS    R2, R2, #1              ; decrement byte count
        BNE     %BT10                   ; loop until finished
        B       %BT05                   ; then next transfer

20      TST     R0, #1:SHL:30           ; checksum?
        BNE     %FT30

; Read case
21
     iicBL      RXByte                  ; read byte from bus
        STRB    R0, [R1], #1            ; store in data block
        MOV     R0, #1                  ; start with the assumption that it's the last byte, and so shouldn't be acknowledged
        SUBS    R2, R2, #1              ; is it last byte in this descriptor?
        MOVNES  R0, R0, LSR #2          ; no, so definitely needs acknowledging (with 0 bit)
                                        ; now Z is set, and C set => just read last byte for this descriptor
        LDRCS   iiclr, [iicsp]
        MOVCS   iiclr, iiclr, LSR #8
        TEQCS   iiclr, #0               ; if we've finished this descriptor, check for another transfer descriptor
                                        ; Z clear => last byte, and there is another descriptor
        LDRNE   iiclr, [R3]
        TSTNE   iiclr, #1:SHL:31        ; if appropriate, check if next descriptor is a continuation
        MOVNE   R0, #0                  ; if read is going to continue, we need to acknowledge
     iicBL      ClockData               ; but always send ack clock pulse
        BCC     %BT21
        B       %BT05                   ; next transfer

; Checksum case
30      MOV     R1, #0
31
     iicBL      RXByte                  ; read byte from bus
        ADD     R1, R1, R0
        MOV     R0, #1                  ; start with the assumption that it's the last byte, and so shouldn't be acknowledged
        SUBS    R2, R2, #1              ; is it last byte in this descriptor?
        MOVNES  R0, R0, LSR #2          ; no, so definitely needs acknowledging (with 0 bit)
                                        ; now Z is set, and C set => just read last byte for this descriptor
        LDRCS   iiclr, [iicsp]
        MOVCS   iiclr, iiclr, LSR #8
        TEQCS   iiclr, #0               ; if we've finished this descriptor, check for another transfer descriptor
                                        ; Z clear => last byte, and there is another descriptor
        LDRNE   iiclr, [R3]
        TSTNE   iiclr, #1:SHL:31        ; if appropriate, check if next descriptor is a continuation
        MOVNE   R0, #0                  ; if read is going to continue, we need to acknowledge
     iicBL      ClockData               ; but always send ack clock pulse
        BCC     %BT31
        STR     R1, [R3, #-8]           ; store checksum
        B       %BT05                   ; next transfer

90
     iicBL      Stop
IIC_ExitOK
        CLRV
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"

80
     iicBL      Stop
        LDRB    R0, [iicsp]
        MOV     R1, #IICBus_Size
        LDR     R2, =ZeroPage+IICBus_Base
        MLA     R2, R0, R1, R2
IIC_ExitNoAck
        MOV     R0, #0
        STR     R0, [R2, #IICBus_Status]
        ADR     R0, ErrorBlock_IIC_NoAcknowledge

IIC_ExitError
 [ International :LAND: {FALSE}
        ; KJB - problematical - this may be done very early, before SWI dispatch
        ; is ready, so we can't call MessageTrans. Think about this.
        ; BJGA - we also can't use TranslateError, because it doesn't conform to
        ; our calling standard (unless we turn interrupts off)
        BL      TranslateError
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"

        MakeInternatErrorBlock IIC_NoAcknowledge,, "NoAck:No acknowledge from IIC device"
 |
        SETV
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"

        MakeErrorBlock         IIC_NoAcknowledge
 ]



; *****************************************************************************
;
;       SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
;
; out:  r0,r1 corrupted
;

SetC1C0 ROUT
     iicPush    "r2,r3,iiclr"
 [ HAL
        MOV     R2, R1
        MOV     R1, R0
        BIC     r0, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r0, [r0, #-4]           ; list head
        LDRB    r0, [r0, #IICLink_Size+3] ; bus number
        MSR     CPSR_c, r8              ; IRQs off for use of ATPCS
        Push    "lr"
        CallHAL HAL_IICSetLines
        Pull    "lr"
        MSR     CPSR_c, r7              ; IRQs back on
 |
        ADD     R0, R0, R1, LSL #1      ; R0 := C0 + C1*2

        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy
        BIC     R1, R1, #&03                    ; clear clock and data
        ORR     R0, R1, R0                      ; put in new clock and data
        ORR     R0, R0, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R0, [R2, #IOCControlSoftCopy]   ; store back to soft copy

        MOV     R2, #IOC
        STRB    R0, [R2, #IOCControl]
 ]

      [ E2ROMSupport
        LDR     R0, =ZeroPage
        LDRB    R0, [R0, #NVRamSpeed]
        TEQ     R0, #0
        MOVEQ   R0, #10                         ; default value if speed not checked yet
      |
        MOV     R0, #10                         ; default to slowest value if we have E2ROMSupport is false
      ]
     iicBL      iicDoMicroDelay

     iicPull    "r2,r3,pc"

; *****************************************************************************
;
;       ReadC1C0 - Read clock and data lines to  R1 and R0 respectively
;
; out:  R0, R1 updated
;

ReadC1C0 ROUT
 [ HAL
     iicPush    "r2,r3,iiclr"
        BIC     r0, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r0, [r0, #-4]           ; list head
        LDRB    r0, [r0, #IICLink_Size+3] ; bus number 
        MSR     CPSR_c, r8              ; IRQs off for use of ATPCS
        Push    "lr"
        CallHAL HAL_IICReadLines
        Pull    "lr"
        MSR     CPSR_c, r7              ; IRQs back on
     iicPull    "r2,r3,pc"
 |
        LDRB    a1, [r9, #IOCControl]
        MOV     a2, a1, LSR #1
        AND     a1, a1, #1
        AND     a2, a2, #1
        MOV     pc, iiclr
 ]

; *****************************************************************************
;
;       iicDoMicroDelay - Delay for >= R0/2 microseconds, IIC calling standard
;
; in:   R0 = time delay in 1/2 microsecond units
;       On ARM600, we may or may not be in a 32-bit mode
;
; out:  R0,R1 corrupted
;

iicDoMicroDelay ROUT
  [ HAL
     iicPush    "a3,a4,iiclr"
        MOVS    a1, a1, LSR #1
        ADC     a1, a1, #0
        MSR     CPSR_c, r8              ; IRQs off for use of ATPCS
        Push    "lr"
        CallHAL HAL_CounterDelay
        Pull    "lr"
        MSR     CPSR_c, r7              ; IRQs back on
     iicPull    "a3,a4,pc"
  |
     iicPush    "iiclr"
        STRB    R0, [R9, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R9, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R9, #Timer0LR]     ; copy counter into output latch
        LDRB    iiclr, [R9, #Timer0CL]  ; iiclr := low output latch
        TEQ     iiclr, R1               ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, iiclr               ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

     iicPull    "pc"
  ]

        LTORG

; *****************************************************************************
;
;       ClockData - Clock a bit of data down the IIC bus
;
; in:   R0 = data bit
;
; out:  All registers preserved, including PSR
;

ClockData ROUT
     iicPush    "R0-R3,iiclr"
        MRS     R2,CPSR
        MOV     R3, R0

        MOV     R1, #0                  ; Clock lo
     iicBL      SetC1C0

; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling
        MSR     CPSR_c, r8

        MOV     R0, R3
        MOV     R1, #1                  ; Clock hi
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, R3
        MOV     R1, #0                  ; Clock lo
     iicBL      SetC1C0

        MSR     CPSR_cf,R2              ; Restore interrupts and flags
     iicPull    "R0-R3,PC"

; *****************************************************************************
;
;       Start - Send the Start signal
;
; out:  All registers preserved, PSR corrupted
;

Start   ROUT
     iicPush    "R0-R1,iiclr"

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.7 microsecs (1.3 for fast device)

        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
     iicBL      SetC1C0

     iicPull    "R0-R1,PC"

; *****************************************************************************
;
;       RepeatedStart - Send a Repeated Start signal
;
; out:  All registers preserved, PSR corrupted
;

RepeatedStart   ROUT
     iicPush    "R0-R1,iiclr"

        MOV     R0, #1
        MOV     R1, #0                  ; clock LO, data HI
     iicBL      SetC1C0

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.7 microsecs (1.3 for fast device)

        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
     iicBL      SetC1C0

     iicPull    "R0-R1,PC"

; *****************************************************************************
;
;       Acknowledge - Check acknowledge after transmitting a byte
;
; out:  All registers preserved
;       V=0 => acknowledge received
;       V=1 => no acknowledge received
;

Acknowledge ROUT
     iicPush    "R0-R2,iiclr"

        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
     iicBL      SetC1C0

 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        MSR     CPSR_c, R8
 ]
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

     iicBL      ReadC1C0
        MOV     R2, R0                  ; should be LO for correct acknowledge

        MOV     R0, #1
        MOV     R1, #0                  ; clock LO, data HI
     iicBL      SetC1C0

 [ {TRUE}
        MSR     CPSR_c, R7
 ]

        TST     R2, #1
        MRS     R2, CPSR
        BICEQ   R2, R2, #V_bit          ; clear V if correct acknowledge
        ORRNE   R2, R2, #V_bit          ; set V if no acknowledge
        MSR     CPSR_f, R2

     iicPull    "R0-R2,PC"

; *****************************************************************************
;
;       Stop - Send the Stop signal
;
; out:  All registers preserved, PSR corrupted
;

Stop    ROUT
     iicPush    "R0-R1,iiclr"

        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
     iicBL      SetC1C0

        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
     iicBL      SetC1C0

     iicPull    "R0-R1,PC"

; *****************************************************************************
;
;       TXByte - Transmit a byte
;
; in:   R0 = byte to be transmitted
;
; out:  All registers preserved, PSR corrupted
;

TXByte  ROUT
     iicPush    "R0-R2,iiclr"
        MOV     R1, #&80                ; 2^7 the bit mask
        MOV     R2, R0                  ; byte goes into R2
10
        ANDS    R0, R2, R1              ; zero if bit is zero
        MOVNE   R0, #1
     iicBL      ClockData               ; send the bit
        MOVS    R1, R1, LSR #1
        BNE     %BT10
     iicPull    "R0-R2,PC"

TXAck   ROUT
     iicPush    iiclr
     iicBL      TXByte
     iicPull    iiclr
        B       Acknowledge


; *****************************************************************************
;
;       TXPollAck - Transmit a byte and poll for acknowledge
;
;       This is intended for devices with a slow internal write cycle which
;       don't ack until the write cycle is finished ( eg ATMEL AT24C01A/x )
;
; in:   R0 = byte to be transmitted
;
; out:  All registers preserved
;

TXPollAck       ROUT
     iicPush    "R1,iiclr"
        MOV     R1, #1
10
     iicBL      TXByte
     iicBL      Acknowledge
     iicPull    "R1,PC",VC
        ADD     R1, R1, #1
        TEQ     R1, #PollMax
        BEQ     %FT90
 [      {FALSE}
        BREG    R1, "i2c tries:"
 ]
     iicBL      RepeatedStart
        B       %BT10
90
     iicPull    "R1,PC"

; *****************************************************************************
;
;       RXByte - Receive a byte
;
; out:  R0 = byte received
;       All other registers preserved, PSR corrupted
;

RXByte  ROUT
     iicPush    "R1-R3,iiclr"
        MOV     R3, #0                  ; byte:=0
        MOV     R2, #7

        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
     iicBL      SetC1C0
10
 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        MSR     CPSR_c, R8
 ]
        MOV     R0, #1                  ; pulse clock HI
        MOV     R1, #1
     iicBL      SetC1C0

     iicBL      ReadC1C0
        ADD     R3, R0, R3, LSL #1      ; byte:=byte*2+ SDA

        MOV     R0, #1                  ; return clock LO
        MOV     R1, #0
     iicBL      SetC1C0

 [ {TRUE}
        MSR     CPSR_c, R7
 ]
        SUBS    R2, R2, #1
        BCS     %BT10

        MOV     R0, R3                  ; return the result in R0
     iicPull    "R1-R3,PC"

; *****************************************************************************

IIC_OpV_HAL
;       R2 = IICBus ptr
;       R3 -> array of transfer descriptors
;       [iicsp, #0] = bits 0-7: bus number
;                     bits 8-31: number of transfers
;       [iicsp, #4] unused on entry, used to hold number of retries remaining
;       [iicsp, #8] = return address

        LDR     iiclr, [R2, #IICBus_Status]
        TEQ     iiclr, #0
        BNE     IIC_Busy

        LDR     iiclr, [R3]
        TST     iiclr, #1:SHL:29        ; retries reqd?
        MOVEQ   iiclr, #1               ; no,just try once
        BEQ     %FT15
        LDR     iiclr, [R2, #IICBus_Type]
        AND     iiclr, iiclr, #IICFlag_Fast+IICFlag_HighSpeed
        ASSERT  IICFlag_HighSpeed > IICFlag_Fast
        CMP     iiclr, #IICFlag_Fast
        MOV     iiclr, #PollMax
        MOVHS   iiclr, iiclr, LSL #2    ; 4x faster bus, 4x more retries
        ADDHI   iiclr, iiclr, iiclr, LSL #3 ; 34x faster bus, 36x more retries (slight over-estimate)
15
        STR     iiclr, [iicsp, #4]

IIC_OpV_HAL_Retry
        MOV     iiclr, #1
        STR     iiclr, [R2, #IICBus_Status]

     iicPush    "R2,R3"
        LDR     R1, [iicsp, #8]
        MOV     R2, R3
        AND     R0, R1, #255
        MOV     R1, R1, LSR #8
        MSR     CPSR_c, R8              ; IRQs off for use of ATPCS
        Push    "lr"
        CallHAL HAL_IICTransfer
        Pull    "lr"
        MSR     CPSR_c, R7              ; IRQs back on
     iicPull    "R2,R3"

20      TEQ     R0, #IICStatus_NoACK
        BEQ     IIC_NoAck
        TEQ     R0, #IICStatus_Busy
        BEQ     IIC_Busy
        TEQ     R0, #IICStatus_Completed
        STREQ   R0, [R2, #IICBus_Status] ; mark IIC system as free
        BEQ     IIC_ExitOK
        TEQ     R0, #IICStatus_InProgress
        BNE     IIC_Error
        LDR     R0, [R2, #IICBus_Status]
        B       %BT20

IIC_NoAck
        LDR     iiclr, [iicsp, #4]
        SUBS    iiclr, iiclr, #1
        STRNE   iiclr, [iicsp, #4]
        BNE     IIC_OpV_HAL_Retry       ; worth another go?
        B       IIC_ExitNoAck

IIC_Busy
        ADR     R0,IICBusy_Error
        B       IIC_ExitError

IICBusy_Error
        MakeErrorBlock  IIC_Busy

IIC_Error
        MOV     R0, #0
        STR     R0, [R2, #IICBus_Status]
        ADR     R0,IICError_Error
        B       IIC_ExitError

IICError_Error
        MakeErrorBlock  IIC_Error

interrupt_protected_end


IICIRQ
        ; R12 = bus number
        Push    "R8-R9,R14"
        LDR     R14,=ZeroPage
        AddressHAL R14

        ; Get IICBus ptr
        MOV     R0, #IICBus_Size
        ADD     R1, R14, #IICBus_Base
        MLA     R8, R12, R0, R1

        MOV     R0, R12
        CallHAL HAL_IICMonitorTransfer
        STR     R0, [R8, #IICBus_Status]
        LDR     R0, [R8, #IICBus_Device]
        CallHAL HAL_IRQClear
        Pull    "R8-R9,PC"

IICAbort
        Push    "R0-R3,R7,R8,R9,R11,R12,R14"
        MOV     R11,R13
        SUB     R13,R13,#(1:SHL:IICStackAlignment)+4
        MRS     R7,CPSR
        ORR     R8,R7,#I32_bit
 [ HAL
        AddressHAL
 |
        MOV     R9,#IOC
 ]
        CallHAL HAL_IICBuses
        SUBS    R0,R0,#1
        BLT     %FT20
        LDR     R1,=ZeroPage+IICBus_Base
        MOV     R12,#IICBus_Size
        MLA     R1,R12,R0,R1
        LDR     R12,[R1,#IICBus_Type]
        MOV     R0,R0,LSL #24
05
        TST     R12,#IICFlag_HighLevel
        BNE     %FT10
        ; Set up a fake transfer list for Start/Stop/TXAck to read the bus number from
        Push    "R0,R1"
        BIC     R0, iicsp, #(1:SHL:IICStackAlignment)-1
        STR     R13,[R0,#-4]
             
 [ {FALSE}
        MOV     R1,#16                          ; Two bytes in case RTC transmitting
35
     iicBL      Start                           ; Start/clock edge
     iicBL      Stop
        SUBS    R1,R1,#1
        BNE     %BT35
 |
     iicBL      Start
        MOV     R0, #1
     iicBL      TXAck
     iicBL      Stop
 ]
        Pull    "R0,R1"
10
        SUBS    R0,R0,#1<<24
        SUB     R1,R1,#IICBus_Size
        BGE     %BT05
20
        ADD     R13,R13,#(1:SHL:IICStackAlignment)+4
        Pull    "R0-R3,R7,R8,R9,R11,R12,PC"

IICInit
        Push    "R7-R9,R14"
        AddressHAL
        MOV     R7, #0
        LDR     R8, =ZeroPage+IICBus_Base
10
        CallHAL HAL_IICBuses
        CMP     R7, R0
        Pull    "R7-R9,R14",HS
        BHS     IICAbort ; Ensure any CMOS operation aborted
        MOV     a1, #0
        STR     a1, [R8, #IICBus_Status]
        MOV     a1, R7
        CallHAL HAL_IICType
        STR     a1, [R8, #IICBus_Type]
        TST     a1, #IICFlag_Background
        BEQ     %FT20
        MOV     a1, R7
        CallHAL HAL_IICDevice
        STR     a1, [R8, #IICBus_Device]
        CallHAL HAL_IRQEnable
20
        ADD     R7, R7, #1
        ADD     R8, R8, #IICBus_Size
        B       %BT10

; We need to retain a version of DoMicroDelay with standard calling conventions, because
; it is called from elsewhere in the kernel. But it can't live inside the protected
; region above in case it's interrupted by a routine that does an IIC operation.

; *****************************************************************************
;
;       DoMicroDelay - Delay for >= R0/2 microseconds
;
; in:   R0 = time delay in 1/2 microsecond units
;       R2 -> IOC
;       On ARM600, we may or may not be in a 32-bit mode
;
; out:  R0,R1 corrupted
;

DoMicroDelay ROUT
  [ HAL
        Push    "a3,a4,sb,ip,lr"
        AddressHAL
        MOVS    a1, a1, LSR #1
        ADC     a1, a1, #0
        CallHAL HAL_CounterDelay
        Pull    "a3,a4,sb,ip,pc"
  |
        Push    R14
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R14, [R2, #Timer0CL]    ; R14 := low output latch
        TEQ     R14, R1                 ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R14                 ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

        Pull    PC
  ]

        END
@


4.1
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a562 1
 [ No26bitCode
a564 3
 |
     iicPush    "R0-R1,R3,iiclr"
 ]
a583 1
 [ No26bitCode
a585 3
 |
     iicPull    "R0-R1,R3,PC",,^
 ]
@


1.1
log
@file IIC was initially added on branch HAL.
@
text
@d1 1043
@


1.1.2.1
log
@Added some missing IIC and USB files.
An attempt to do NVMemory by using part of the Flash that the OS is sitting
in for Customer L. Programming algorithm works, but I'm not confident that the
Kernel does the right thing yet.

Version 5.35, 4.79.2.19. Tagged as 'Kernel-5_35-4_79_2_19'
@
text
@a0 610
; Copyright 2001 Pace Micro Technology plc
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; 19-Feb-01  KJB   Separated IIC operations from NVMemory and RTC code


PollMax		*	150	; Number of times to poll for an Ack (increase if you clock faster - need to
                                ; allow 5ms for write cycle).


; Choose a lower limit on the number of ticks per clock phase based on the
; MaxI2Cspeed variable defined in Hdr:Machine.<Machine>
  [ MaxI2Cspeed >= 1000
I2Cticks        *       1
  |
  [ MaxI2Cspeed >= 400
I2Cticks        *       3
  |
I2Cticks        *       10
  ]
  ]

IICOpSWI
        Push    LR
        BL      IIC_OpV
        Pull    LR
        B       SLVK_TestV


; *****************************************************************************

; in:   R0 = device address (bit 0 set => read, clear => write)
;       R1 -> data block
;       R2 = length of data block
;
IIC_Op
        Push    "R0-R2,LR"
        Push    "R0-R2"                 ; soft copy for IIC_OpV to work on
        MOV     R0, R13
        MOV     R1, #1
        BL      IIC_OpV
        ADD     R13, R13, #12           ; junk soft copy
        Pull    "R0-R2,PC",VC
        ADD     R13, R13, #4
        Pull    "R1-R2,PC"

; *****************************************************************************

; in:   R0 -> array of transfer descriptors
;       R1 = number of transfers
;
; out:  transfer descriptors may be updated (beware)
;
; transfer descriptor is 3 words: word 0 = device address (+direction)
;                                         (bit 29 signifies retry for response)
;                                         (bit 30 signifies checksum read only - ie fill in word 1 with
;                                          sum of bytes read)
;                                         (bit 31 signifies continued transfer - ie no start or address)
;                                 word 1 -> data block
;                                 word 2 = length of data block
IIC_OpV ROUT
        Push    "R0-R7,R10,R11,LR"
        MOV     R7, #0
        MRS     R6, CPSR
        BIC     R5, R6, #I32_bit
        MSR     CPSR_c, R5              ; enable interrupts - this may take some time

        MOV     R4, R0
        MOV     R5, R1

05      SUBS    R5, R5, #1
        BCC     %FT90

        LDMIA   R4!, {R0-R2}
        TST     R0, #1:SHL:31           ; skip start?
        BNE     %FT08

        TEQ     R7,#0
        BLEQ    Start
        TEQ     R7,#0
        BLNE    RepeatedStart

        TST     R0, #1:SHL:29
        BNE     %FT06
        BL      TXAck                   ; transmit device address without retries
        B       %FT07

06      BL      TXPollAck               ; transmit device address with retries
07      BVS     %FT80

08      MOV     R7, #1
        MOV     R11, R1
        MOVS    R10, R2
        BEQ     %BT05

        TST     R0, #1                  ; Z => write, NZ => read
        BNE     %FT20

; Write case
10      LDRB    R0, [R11], #1           ; read byte from data block
        BL      TXAck                   ; transmit, checking for ack
        BVS     %FT80
        SUBS    R10, R10, #1            ; decrement byte count
        BNE     %BT10                   ; loop until finished
        B       %BT05                   ; then next transfer

20      TST     R0, #1:SHL:30           ; checksum?
        BNE     %FT30

; Read case
21      BL      RXByte                  ; read byte from bus
        STRB    R0, [R11], #1           ; store in data block
        SUBS    R10, R10, #1            ; is it last byte ?
        MOVNE   R0, #0                  ; no, then acknowledge with 0 bit
        MOVEQ   R0, #1                  ; yes, then don't acknowledge
        BL      ClockData               ; but always send ack clock pulse
        BNE     %BT21
        B       %BT05                   ; next transfer

; Checksum case
30      MOV     R11, #0
31
        BL      RXByte                  ; read byte from bus
        ADD     R11, R11, R0
        SUBS    R10, R10, #1
        MOVNE   R0, #0                  ; no, then acknowledge with 0 bit
        MOVEQ   R0, #1                  ; yes, then don't acknowledge
        BL      ClockData               ; but always send ack clock pulse
        BNE     %BT31
        STR     R11, [R4, #-8]          ; store checksum
        B       %BT05                   ; next transfer

90      BL      Stop
        CLRV
        MSR     CPSR_c, R6              ; restore interrupts
        Pull    "R0-R7,R10,R11,PC"

80      BL      Stop
        ADR     R0, ErrorBlock_IIC_NoAcknowledge
 [ International
        BL      TranslateError
 |
        SETV
 ]
        ADD     R13, R13, #4
        Pull    "R1-R7,R10,R11,PC"

        MakeErrorBlock IIC_NoAcknowledge

; *****************************************************************************
;
;	SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
;
; out:	ATPCS
;

SetC1C0 ROUT
        Push    "R9,R14"
 [ HAL
        AddressHAL
        MOV     R2, R1
        MOV     R1, R0
        MOV     R0, #0
        CallHAL HAL_IICSetLines
 |
	ADD	R0, R0, R1, LSL #1	; R0 := C0 + C1*2

	MOV	R2, #0				; prepare to index soft copy
	LDRB	R1, [R2, #IOCControlSoftCopy]	; read soft copy
	BIC	R1, R1, #&03			; clear clock and data
	ORR	R0, R1, R0			; put in new clock and data
	ORR	R0, R0, #&C0			; make sure two test bits are
						; always set to 1 !
	STRB	R0, [R2, #IOCControlSoftCopy]	; store back to soft copy

	MOV	R2, #IOC
	STRB	R0, [R2, #IOCControl]
 ]

      [ E2ROMSupport
        MOV	R0, #0
        LDRB	R0, [R0, #NVRamSpeed]
        TEQ     R0, #0
        MOVEQ   R0, #10                         ; default value if speed not checked yet
      |
        MOV     R0, #10                         ; default to slowest value if we have E2ROMSupport is false
      ]
	BL	DoMicroDelay

        Pull    "R9,PC"

; *****************************************************************************
;
;	ReadC1C0 - Read clock and data lines to  R1 and R0 respectively
;
; out:	R0, R1 updated - otherwise ATPCS
;

ReadC1C0 ROUT
 [ HAL
        Push    "sb,lr"
        AddressHAL
        CallHAL HAL_IICReadLines
        Pull    "sb,pc"
 |
        MOV     a3, #IOC
        LDRB    a1, [a3, #IOCControl]
        MOV     a2, a1, LSR #1
        AND     a1, a1, #1
        AND     a2, a2, #1
        MOV     pc, lr
 ]

; *****************************************************************************
;
;	DoMicroDelay - Delay for >= R0/2 microseconds
;
; in:	R0 = time delay in 1/2 microsecond units
;	R2 -> IOC
;	On ARM600, we may or may not be in a 32-bit mode
;
; out:	R0,R1 corrupted
;

DoMicroDelay ROUT
  [ HAL
        Push    "a3,a4,sb,ip,lr"
        AddressHAL
        MOVS    a1, a1, LSR #1
        ADC     a1, a1, #0
        CallHAL HAL_CounterDelay
        Pull    "a3,a4,sb,ip,pc"
  |
        Push    R14
	STRB	R0, [R2, #Timer0LR]	; copy counter into output latch
	LDRB	R1, [R2, #Timer0CL]	; R1 := low output latch
10
	STRB	R0, [R2, #Timer0LR]	; copy counter into output latch
	LDRB	R14, [R2, #Timer0CL]	; R14 := low output latch
	TEQ	R14, R1			; unchanged ?
	BEQ	%BT10			; then loop
	MOV	R1, R14			; copy anyway
	SUBS	R0, R0, #1		; decrement count
	BNE	%BT10			; loop if not finished

	Pull	PC
  ]

	LTORG

; *****************************************************************************
;
;	ClockData - Clock a bit of data down the IIC bus
;
; in:	R0 = data bit
;
; out:	All registers preserved, including PSR
;

ClockData ROUT
 [ No26bitCode
	Push	"R0-R3,R4,R5,R12,R14"
        MRS     R4,CPSR
 |
	Push	"R0-R3,R5,R12,R14"
 ]
        MOV     R5, R0

	MOV	R1, #0			; Clock lo
	BL	SetC1C0

 [ No26bitCode
        ORR     R1,R4,#I32_bit
        MSR     CPSR_c,R1
 |
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

	MOV	R1,PC
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
 ]
        MOV     R0, R5
	MOV	R1, #1			; Clock hi
	BL	SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, R5
	MOV	R1, #0			; Clock lo
	BL	SetC1C0

 [ No26bitCode
        MSR     CPSR_cf,R4              ; Restore interrupts
        Pull    "R0-R3,R4,R5,R12,PC"
 |
	Pull	"R0-R3,R5,R12,PC",,^
 ]

ClockData0 ROUT				; Clock a zero bit
	Push	"R0, R14"
	MOV	R0, #0
	BL	ClockData               ; preserves PSR
	Pull	"R0, PC"

; *****************************************************************************
;
;	Start - Send the Start signal
;
; out:	All registers preserved, including PSR
;

Start	ROUT
 [ No26bitCode
	Push	"R0-R3,R4,R12,R14"
        MRS     R4, CPSR
 |
	Push	"R0-R3,R12,R14"
 ]

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0

; Delay here must be >= 4.7 microsecs (1.3 for fast device)

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
	BL	SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
	BL	SetC1C0

 [ No26bitCode
        MSR     CPSR_f, R4
	Pull	"R0-R3,R4,R12,PC"
 |
	Pull	"R0-R3,R12,PC",,^
 ]

; *****************************************************************************
;
;	RepeatedStart - Send a Repeated Start signal
;
; out:	All registers preserved, including PSR
;

RepeatedStart	ROUT
 [ No26bitCode
	Push	"R0-R3,R4,R12,R14"
        MRS     R4, CPSR
 |
	Push	"R0-R3,R12,R14"
 ]

        MOV     R0, #1
        MOV     R1, #0                  ; clock LO, data HI
        BL      SetC1C0

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0

; Delay here must be >= 4.7 microsecs (1.3 for fast device)

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
	BL	SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
	BL	SetC1C0

 [ No26bitCode
        MSR     CPSR_f, R4
	Pull	"R0-R3,R4,R12,PC"
 |
	Pull	"R0-R3,R12,PC",,^
 ]

; *****************************************************************************
;
;	Acknowledge - Check acknowledge after transmitting a byte
;
; out:	All registers preserved
;	V=0 => acknowledge received
;	V=1 => no acknowledge received
;

Acknowledge ROUT
	Push	"R0-R4,R12,R14"

	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
	BL	SetC1C0

 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        MRS     R1,CPSR
        Push    "R1"
        ORR     R1,R1,#I32_bit
        MSR     CPSR_c,R1
 ]
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

        BL      ReadC1C0
        MOV     R4, R0                  ; should be LO for correct acknowledge

	MOV  	R0, #1
	MOV  	R1, #0			; clock LO, data HI
	BL  	SetC1C0

 [ {TRUE}
	Pull	"R1"
	MSR     CPSR_c,R1
 ]

        TST     R4, #1
        MRS     R2, CPSR
	BICEQ	R2, R2, #V_bit		; clear V if correct acknowledge
	ORRNE	R2, R2, #V_bit		; set V if no acknowledge
        MSR     CPSR_f, R2

	Pull	"R0-R4,R12,PC"

; *****************************************************************************
;
;	Stop - Send the Stop signal
;
; out:	All registers preserved, including PSR
;

Stop	ROUT
 [ No26bitCode
	Push	"R0-R3,R4,R12,R14"
        MRS     R4, CPSR
 |
	Push	"R0-R3,R12,R14"
 ]

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
	BL	SetC1C0

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
	BL	SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0

 [ No26bitCode
        MSR     CPSR_f, R2
	Pull	"R0-R3,R4,R12,PC"
 |
	Pull	"R0-R3,R12,PC",,^
 ]

; *****************************************************************************
;
;	TXByte - Transmit a byte
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved, including PSR
;

TXByte	ROUT
 [ No26bitCode
	Push	"R0-R3,R14"
        MRS     R3, CPSR
 |
	Push	"R0-R2,R14"
 ]
	MOV	R1, #&80		; 2^7 the bit mask
	MOV	R2, R0			; byte goes into R2
10
	ANDS	R0, R2, R1		; zero if bit is zero
	MOVNE	R0, #1
	BL	ClockData		; send the bit
	MOVS	R1, R1, LSR #1
	BNE	%BT10
 [ No26bitCode
        MSR     CPSR_f, R3
	Pull	"R0-R3,PC"
 |
	Pull	"R0-R2,PC",,^
 ]

TXAck	ROUT
	Push	R14
	BL	TXByte
        Pull    R14
	B	Acknowledge


; *****************************************************************************
;
;	TXPollAck - Transmit a byte and poll for acknowledge
;
;	This is intended for devices with a slow internal write cycle which
;	don't ack until the write cycle is finished ( eg ATMEL AT24C01A/x )
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved
;

TXPollAck	ROUT
	Push	"R1,R14"
	MOV	R1, #1
10
	BL	TXByte
	BL	Acknowledge
        Pull    "R1,PC",VC
        ADD     R1, R1, #1
	TEQ	R1, #PollMax
        BEQ     %FT90
 [	{FALSE}
	BREG	R1, "i2c tries:"
 ]
        BL      RepeatedStart
        B       %BT10
90
	Pull	"R1,PC"

; *****************************************************************************
;
;	RXByte - Receive a byte
;
; out:	R0 = byte received
;	All other registers preserved, including PSR
;

RXByte	ROUT
 [ No26bitCode
	Push	"R1-R6,R12,R14"
        MRS     R5, CPSR
 |
	Push	"R1-R4, R6, R12, R14"
 ]
	MOV	R6, #0			; byte:=0
	MOV	R4, #7

	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
	BL	SetC1C0
10
 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        MRS     R1,CPSR
        Push    "R1"
        ORR     R1,R1,#I32_bit
        MSR     CPSR_c,R1
 ]
	MOV	R0, #1			; pulse clock HI
	MOV	R1, #1
	BL	SetC1C0

        BL      ReadC1C0
        ADD     R6, R0, R6, LSL #1      ; byte:=byte*2+ SDA

	MOV	R0, #1			; return clock LO
	MOV	R1, #0
	BL	SetC1C0

 [ {TRUE}
	Pull	"R1"
	MSR     CPSR_c,R1
 ]
	SUBS	R4, R4, #1
	BCS	%BT10

	MOV	R0, R6			; return the result in R0
 [ No26bitCode
        MSR     CPSR_f, R5
	Pull	"R1-R6, R12, PC"
 |
	Pull	"R1-R4, R6, R12, PC",,^
 ]

        END

@


1.1.2.2
log
@Various fixes to NVMemory code. Really needs to be re-engineered.

Version 5.35, 4.79.2.26. Tagged as 'Kernel-5_35-4_79_2_26'
@
text
@d151 1
a151 4
 [ International :LAND: {FALSE}
        ; KJB - problematical - this may be done very early, before SWI dispatch
        ; is ready, so we can't call MessageTrans. Also, the MakeErrorBlock seems
        ; to not be giving us a token (sigh). Think about this.
@


1.1.2.3
log
@  IIC code is now re-entrant. Also a bugfix.
Detail:
  I pinched the IIC code from here to build MPEGDriver-0_32-1_33_2_2; now
  that I've added re-entrancy there (MPEGDriver-0_32-1_33_2_4), I'm folding
  the changes back in here, in case it's ever of use to someone else.
  Re-entrancy is achieved by restricting register use to r0-r3,r10,r11,CPSR
  so that re-entered code can complete any pending IIC operation by
  pulling those registers from the IRQ stack, before executing the new
  operation.
  The bugfix is regarding a continued read transaction - previously, the
  final byte read of a read transaction was never acknowledged; it needs to
  be acknowledged if it is immediately followed by another read transaction
  without its own repeated Start condition.
Admin:
  Tested as part of MPEGDriver, but not as part of a kernel build.

Version 5.35, 4.79.2.47. Tagged as 'Kernel-5_35-4_79_2_47'
@
text
@a15 1
; 05-Feb-02  BJGA  Added re-entrant capability
a33 81

IICStackAlignment       *       7       ; log2 of stack size, also stack alignment
                                        ; current requirement is 19 words = 2_01001100 bytes

                ^       0
IICLink_Next    #       4
IICLink_Error   #       4
IICLink_Array   #       4
IICLink_Size    #       4

; SVC stack format, in descending address order:
;    16 bytes   first link (also bottom of stacked registers)
;     n bytes   align to address with bottom x bits set
; 2^x-4 bytes   align to address with bottom x bits clear (the local stack)
;     4 bytes   linked list head
;     4 bytes   linked list tail
;     4 bytes   original sp
;      .
;      .
;      .
;    16 bytes   another link (also bottom of stacked registers)
;     4 bytes   original sp

; IRQ stack format, in descending address order, for reference:
;     4 bytes   lr_irq-4 (interrupted PC)
;     4 bytes   r0
;     4 bytes   spsr_irq (interrupted CPSR)
;    20 bytes   r1-r3, r11, r12
;     4 bytes   IRQsema link


iicsp   RN      11
iiclr   RN      12


        MACRO
$label  iicBL   $destination, $cond
$label  MOV$cond iiclr, pc
        B$cond  $destination
        MEND

        MACRO
$label  iicPull $reglist, $cond, $hat
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   "$hat" = ""
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  LDR$cond $reglist, [iicsp], #4
        |
$label  LDM$cond.FD iicsp!, {$reglist}$hat
        ]
        MEND

        MACRO
$label  iicPush $reglist, $cond
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   {TRUE}
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  STR$cond $reglist, [iicsp, #-4]!
        |
$label  STM$cond.FD iicsp!, {$reglist}
        ]
        MEND



d73 5
a77 116
        Push    "r0-r3,r6-r12,lr"
        MOV     lr, #0
        STR     lr, [sp, #-8]!
        MRS     r10, CPSR
        BIC     r7, r10, #I32_bit :OR: F32_bit
        ORR     r8, r7, #I32_bit
      [ HAL
        AddressHAL
      |
        MOV     r9, #IOC
      ]
        MOV     r2, #IRQsema
        MOV     r12, sp                 ; original sp, also pointer to link
        ORR     lr, r8, #2_10000
        MSR     CPSR_c, lr              ; IRQs off, force 32-bit mode

01      LDR     r2, [r2]
        TEQ     r2, #0
        BEQ     %FT50                   ; I²C code not in IRQ stack
        LDR     r6, [r2, #4*8]          ; interrupted PC
IIC_OpV_PCReference
        RSB     lr, pc, r6
        LDR     r0, =(interrupt_protected_end-4) - (IIC_OpV_PCReference+8)
        CMP     lr, r0
        RSBLES  lr, lr, #interrupt_protected_start - (IIC_OpV_PCReference+8)
        BGT     %BT01

        ; I²C code is already threaded
        Push    "r12"                   ; put original sp on stack for our exit routine
        LDR     r0, [r2, #4*4]          ; retrieve interrupted iicsp
        BIC     r0, r0, #(1:SHL:IICStackAlignment)-1
        LDR     r1, [r0, #-8]           ; old list tail
        STR     r12, [r0, #-8]          ; new list tail
        STR     r12, [r1, #IICLink_Next] ; point old link to new link
        ADR     r0, IIC_OpV_CommonExit
        STR     r0, [r2, #4*8]          ; poke IRQ stack so previous operation returns as though completed
        LDR     r0, [r2, #4*6]          ; get interrupted CPSR
        MSR     SPSR_cxsf, r0           ; stick it in SPSR (okay, because IRQs are off)
        LDR     r0, [r2, #4*7]
        LDMIB   r2, {r1-r3,r11,r12}
        MOVS    pc, r6                  ; copy SPSR to CPSR and resume execution

50      ; I²C code not currently threaded - create new environment
        ADD     iicsp, sp, #4
        BIC     iicsp, iicsp, #(1:SHL:IICStackAlignment)-1
        SUB     iicsp, iicsp, #4
        BIC     sp, iicsp, #(1:SHL:IICStackAlignment)-1
        Push    "r12"                   ; list head pointer
        Push    "r12"                   ; list tail pointer
        Push    "r12"                   ; original sp
        LDR     r0, [r12, #IICLink_Array]
        LDR     r1, [r12, #IICLink_Size]
        B       IICStart                ; start working through list

IIC_OpV_CommonExit
        MSR     CPSR_c, r10             ; restore original IRQ disable state
        LDR     sp, [sp]
        ADD     sp, sp, #4              ; skip next pointer
        Pull    "r0"
        CMP     r0, #0
        Pull    "r0-r3,r6-r12,pc", EQ
        SETV
        ADD     sp, sp, #4
        Pull    "r1-r3,r6-r12,pc"


interrupt_protected_start

; Protected routines register usage:
;   r0-r3   general purpose
;    r7     MRS style PSR with c bits = SVC26/32, IRQs/FIQs enabled
;    r8     MRS style PSR with c bits = SVC26/32, IRQs disabled, FIQs enabled
;    r9     IOC, or base of HAL workspace, depending on HAL switch
;    r11    stack pointer
;    r12    link register / general purpose
;    CPSR is also non-volatile

IICStart
        MSR     CPSR_c, r7              ; enable IRQs (inside protected code) - this may take some time
        ; drop through...

; *****************************************************************************
;
;       IICLoop - serial-execution outermost loop, stepping along pending IIC operations
;

IICLoop
     iicBL      IICDoOp
        MOVVC   r0, #0
        BIC     r1, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r2, [r1, #-4]           ; list head
        STR     r0, [r2, #IICLink_Error] ; set up return value
        MSR     CPSR_c, r8              ; disable IRQs while we work on the list
        LDR     r2, [r2]
        TEQ     r2, #0                  ; end of list?
        BEQ     IIC_OpV_CommonExit      ; finished!
        STR     r2, [r1, #-4]           ; update list head
        MSR     CPSR_c, r7              ; IRQs back on
        LDR     r0, [r2, #IICLink_Array]
        LDR     r1, [r2, #IICLink_Size] ; get next array
        B       IICLoop                 ; and loop

; *****************************************************************************
;
;       IICDoOp - main serial-execution entry point
;
; in:   R0 -> array of transfer descriptors
;       R1 = number of transfers
;
; out:  if V set, r0 -> error block
;       otherwise r0-r3,r12 may be corrupted
;

IICDoOp ROUT
        MOV     R2, #0
     iicPush    "R1,R2,iiclr"           ; two words on stack are RepeatedStart flag and transfers remaining
d79 2
a80 1
        MOV     R3, R0
d82 1
a82 2
05      LDR     R0, [iicsp]
        SUBS    R0, R0, #1
a83 1
        STR     R0, [iicsp]
d85 1
a85 1
        LDMIA   R3!, {R0-R2}
d89 4
a92 6
        LDR     iiclr, [iicsp, #4]
        TEQ     iiclr, #0
        MOV     iiclr, pc
        ADD     iiclr, iiclr, #8
        BEQ     Start
        BNE     RepeatedStart           ; these are effectively conditional BL's
d96 1
a96 1
     iicBL      TXAck                   ; transmit device address without retries
d99 1
a99 2
06
     iicBL      TXPollAck               ; transmit device address with retries
d102 3
a104 3
08      MOV     iiclr, #1
        STR     iiclr, [iicsp, #4]
        TEQ     R2, #0
d111 2
a112 2
10      LDRB    R0, [R1], #1            ; read byte from data block
     iicBL      TXAck                   ; transmit, checking for ack
d114 1
a114 1
        SUBS    R2, R2, #1              ; decrement byte count
d122 7
a128 15
21
     iicBL      RXByte                  ; read byte from bus
        STRB    R0, [R1], #1            ; store in data block
        MOV     R0, #1                  ; start with the assumption that it's the last byte, and so shouldn't be acknowledged
        SUBS    R2, R2, #1              ; is it last byte in this descriptor?
        MOVNES  R0, R0, LSR #2          ; no, so definitely needs acknowledging (with 0 bit)
                                        ; now Z is set, and C set => just read last byte for this descriptor
        LDRCS   iiclr, [iicsp]
        TEQCS   iiclr, #0               ; if we've finished this descriptor, check for another transfer descriptor
                                        ; Z clear => last byte, and there is another descriptor
        LDRNE   iiclr, [R3]
        TSTNE   iiclr, #1:SHL:31        ; if appropriate, check if next descriptor is a continuation
        MOVNE   R0, #0                  ; if read is going to continue, we need to acknowledge
     iicBL      ClockData               ; but always send ack clock pulse
        BCC     %BT21
d132 1
a132 1
30      MOV     R1, #0
d134 8
a141 15
     iicBL      RXByte                  ; read byte from bus
        ADD     R1, R1, R0
        MOV     R0, #1                  ; start with the assumption that it's the last byte, and so shouldn't be acknowledged
        SUBS    R2, R2, #1              ; is it last byte in this descriptor?
        MOVNES  R0, R0, LSR #2          ; no, so definitely needs acknowledging (with 0 bit)
                                        ; now Z is set, and C set => just read last byte for this descriptor
        LDRCS   iiclr, [iicsp]
        TEQCS   iiclr, #0               ; if we've finished this descriptor, check for another transfer descriptor
                                        ; Z clear => last byte, and there is another descriptor
        LDRNE   iiclr, [R3]
        TSTNE   iiclr, #1:SHL:31        ; if appropriate, check if next descriptor is a continuation
        MOVNE   R0, #0                  ; if read is going to continue, we need to acknowledge
     iicBL      ClockData               ; but always send ack clock pulse
        BCC     %BT31
        STR     R1, [R3, #-8]           ; store checksum
d144 1
a144 2
90
     iicBL      Stop
d146 2
a147 2
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"
d149 1
a149 2
80
     iicBL      Stop
d153 2
a154 3
        ; is ready, so we can't call MessageTrans. Think about this.
        ; BJGA - we also can't use TranslateError, because it doesn't conform to
        ; our calling standard (unless we turn interrupts off)
d159 2
a160 2
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"
d162 1
a162 1
        MakeInternatErrorBlock IIC_NoAcknowledge,, "NoAck:No acknowledge from IIC device"
d168 1
a168 1
; out:  r0,r1 corrupted
d172 1
a172 1
     iicPush    "r2,r3,iiclr"
d174 1
a177 1
        MRS     CPSR_c, r8              ; IRQs off for use of ATPCS
a178 1
        MRS     CPSR_c, r7              ; IRQs back on
d202 1
a202 1
     iicBL      iicDoMicroDelay
d204 1
a204 1
     iicPull    "r2,r3,pc"
d210 1
a210 1
; out:	R0, R1 updated
d215 2
a216 2
     iicPush    "r2,r3,iiclr"
        MRS     CPSR_c, r8              ; IRQs off for use of ATPCS
d218 1
a218 2
        MRS     CPSR_c, r7              ; IRQs back on
     iicPull    "r2,r3,pc"
d220 2
a221 1
        LDRB    a1, [r9, #IOCControl]
d225 1
a225 1
        MOV     pc, iiclr
d230 1
a230 1
;       iicDoMicroDelay - Delay for >= R0/2 microseconds, IIC calling standard
d233 1
d239 1
a239 1
iicDoMicroDelay ROUT
d241 2
a242 1
     iicPush    "a3,a4,iiclr"
a244 1
        MRS     CPSR_c, r8              ; IRQs off for use of ATPCS
d246 1
a246 2
        MRS     CPSR_c, r7              ; IRQs back on
     iicPull    "a3,a4,pc"
d248 3
a250 3
     iicPush    "iiclr"
        STRB    R0, [R9, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R9, #Timer0CL]     ; R1 := low output latch
d252 7
a258 7
        STRB    R0, [R9, #Timer0LR]     ; copy counter into output latch
        LDRB    iiclr, [R9, #Timer0CL]  ; iiclr := low output latch
        TEQ     iiclr, R1               ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, iiclr               ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished
d260 1
a260 1
     iicPull    "pc"
d263 1
a263 1
        LTORG
d276 2
a277 2
     iicPush    "R0-R3,iiclr"
        MRS     R2,CPSR
d279 1
a279 1
     iicPush    "R0-R1,R3,iiclr"
d281 1
a281 1
        MOV     R3, R0
d284 1
a284 1
     iicBL      SetC1C0
d286 4
a291 1
        MSR     CPSR_c, r8
d293 5
a297 1
        MOV     R0, R3
d299 1
a299 1
     iicBL      SetC1C0
d303 1
a303 1
        MOV     R0, R3
d305 1
a305 1
     iicBL      SetC1C0
d308 2
a309 2
        MSR     CPSR_cf,R2              ; Restore interrupts and flags
     iicPull    "R0-R3,PC"
d311 1
a311 1
     iicPull    "R0-R1,R3,PC",,^
d314 6
d324 1
a324 1
; out:	All registers preserved, PSR corrupted
d328 6
a333 1
     iicPush    "R0-R1,iiclr"
d337 1
a337 1
     iicBL      SetC1C0
d343 1
a343 1
     iicBL      SetC1C0
d349 1
a349 1
     iicBL      SetC1C0
d351 6
a356 1
     iicPull    "R0-R1,PC"
d362 1
a362 1
; out:	All registers preserved, PSR corrupted
d366 6
a371 1
     iicPush    "R0-R1,iiclr"
d375 1
a375 1
     iicBL      SetC1C0
d379 1
a379 1
     iicBL      SetC1C0
d385 1
a385 1
     iicBL      SetC1C0
d391 1
a391 1
     iicBL      SetC1C0
d393 6
a398 1
     iicPull    "R0-R1,PC"
d410 1
a410 1
     iicPush    "R0-R2,iiclr"
d414 1
a414 1
     iicBL      SetC1C0
d420 4
a423 1
        MSR     CPSR_c, R8
d427 1
a427 1
     iicBL      SetC1C0
d431 2
a432 2
     iicBL      ReadC1C0
        MOV     R2, R0                  ; should be LO for correct acknowledge
d436 1
a436 1
     iicBL      SetC1C0
d439 2
a440 1
        MSR     CPSR_c, R7
d443 1
a443 1
        TST     R2, #1
d449 1
a449 1
     iicPull    "R0-R2,PC"
d455 1
a455 1
; out:	All registers preserved, PSR corrupted
d459 6
a464 1
     iicPush    "R0-R1,iiclr"
d468 1
a468 1
     iicBL      SetC1C0
d472 1
a472 1
     iicBL      SetC1C0
d478 1
a478 1
     iicBL      SetC1C0
d480 6
a485 1
     iicPull    "R0-R1,PC"
d493 1
a493 1
; out:	All registers preserved, PSR corrupted
d497 6
a502 1
     iicPush    "R0-R2,iiclr"
d508 1
a508 1
     iicBL      ClockData               ; send the bit
d511 6
a516 1
     iicPull    "R0-R2,PC"
d519 3
a521 3
     iicPush    iiclr
     iicBL      TXByte
     iicPull    iiclr
d538 1
a538 1
     iicPush    "R1,iiclr"
d541 3
a543 3
     iicBL      TXByte
     iicBL      Acknowledge
     iicPull    "R1,PC",VC
d550 1
a550 1
     iicBL      RepeatedStart
d553 1
a553 1
     iicPull    "R1,PC"
d560 1
a560 1
;	All other registers preserved, PSR corrupted
d564 8
a571 3
     iicPush    "R1-R3,iiclr"
        MOV     R3, #0                  ; byte:=0
        MOV     R2, #7
d575 1
a575 1
     iicBL      SetC1C0
d581 4
a584 1
        MSR     CPSR_c, R8
d588 1
a588 1
     iicBL      SetC1C0
d590 2
a591 2
     iicBL      ReadC1C0
        ADD     R3, R0, R3, LSL #1      ; byte:=byte*2+ SDA
d595 1
a595 1
     iicBL      SetC1C0
d598 2
a599 1
        MSR     CPSR_c, R7
d601 1
a601 1
        SUBS    R2, R2, #1
d604 7
a610 2
	MOV	R0, R3			; return the result in R0
     iicPull    "R1-R3,PC"
d612 1
a613 43
interrupt_protected_end


; We need to retain a version of DoMicroDelay with standard calling conventions, because
; it is called from elsewhere in the kernel. But it can't live inside the protected
; region above in case it's interrupted by a routine that does an IIC operation.

; *****************************************************************************
;
;       DoMicroDelay - Delay for >= R0/2 microseconds
;
; in:   R0 = time delay in 1/2 microsecond units
;       R2 -> IOC
;       On ARM600, we may or may not be in a 32-bit mode
;
; out:  R0,R1 corrupted
;

DoMicroDelay ROUT
  [ HAL
        Push    "a3,a4,sb,ip,lr"
        AddressHAL
        MOVS    a1, a1, LSR #1
        ADC     a1, a1, #0
        CallHAL HAL_CounterDelay
        Pull    "a3,a4,sb,ip,pc"
  |
        Push    R14
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R14, [R2, #Timer0CL]    ; R14 := low output latch
        TEQ     R14, R1                 ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R14                 ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

        Pull    PC
  ]

        END
@


1.1.2.4
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d19 2
a20 2
PollMax		*	150	; Number of times to poll for an Ack (increase if you
				; clock faster - need to allow 5ms for write cycle).
d124 1
a124 1
;
d141 1
a141 3
;
; IIC_OpV - perform IIC operations based on a list of descriptors
;
d147 1
a147 1
; Transfer descriptor is 3 words: word 0 = device address (+direction)
a273 4
        LDR     iiclr, [R2, #IICType]
        TST     iiclr, #IICFlag_HighLevel
	BNE	IIC_OpV_HAL             ; HAL can make use of a hardware IIC engine

a357 1
IIC_ExitOK
a363 3
IIC_ExitNoAck
	MOV	R0, #0
	STR	R0, [R0, #IICStatus]
a364 2

IIC_ExitError
d392 1
a392 2
        MSR     CPSR_c, r8              ; IRQs off for use of ATPCS
        Push    "lr"
d394 1
a394 2
        Pull    "lr"
        MSR     CPSR_c, r7              ; IRQs back on
d432 1
a432 2
        MSR     CPSR_c, r8              ; IRQs off for use of ATPCS
        Push    "lr"
d434 1
a434 2
        Pull    "lr"
        MSR     CPSR_c, r7              ; IRQs back on
d459 1
a459 2
        MSR     CPSR_c, r8              ; IRQs off for use of ATPCS
        Push    "lr"
d461 1
a461 2
        Pull    "lr"
        MSR     CPSR_c, r7              ; IRQs back on
a756 73
; *****************************************************************************

IIC_OpV_HAL
;       R2 = 0
;       R3 -> array of transfer descriptors
;       [iicsp, #0] = number of transfers
;       [iicsp, #4] unused on entry, used to hold number of retries remaining
;       [iicsp, #8] = return address

        LDR	iiclr, [R2, #IICStatus]
        TEQ     iiclr, #0
        BNE     IIC_Busy

        LDR     iiclr, [R3]
        TST     iiclr, #1:SHL:29        ; retries reqd?
        MOVNE   iiclr, #PollMax
        MOVEQ   iiclr, #1      		; no,just try once
        STR     iiclr, [iicsp, #4]

IIC_OpV_HAL_Retry
        MOV	iiclr, #1
        STR	iiclr, [R2, #IICStatus]

     iicPush    "R3"
        MOV     R0, #0
        LDR     R1, [iicsp, #4]
        MOV     R2, R3
        MSR     CPSR_c, R8              ; IRQs off for use of ATPCS
        Push    "lr"
	CallHAL	HAL_IICTransfer
        Pull    "lr"
        MSR     CPSR_c, R7              ; IRQs back on
     iicPull    "R3"
        MOV     R2, #0

20      TEQ     R0, #2
        BEQ     IIC_NoAck
        TEQ     R0, #3
        BEQ     IIC_Busy
        TEQ     R0, #0
        STREQ   R0, [R2, #IICStatus]    ; mark IIC system as free
        BEQ     IIC_ExitOK
        TEQ     R0, #1
        BNE     IIC_Error
        LDR     R0, [R2, #IICStatus]
        B       %BT20

IIC_NoAck
        LDR     iiclr, [iicsp, #4]
        SUBS    iiclr, iiclr, #1
        STRNE   iiclr, [iicsp, #4]
        BNE     IIC_OpV_HAL_Retry       ; worth another go?
        B       IIC_ExitNoAck

IIC_Busy
        ADR     R0,IICBusy_Error
        B       IIC_ExitError

IICBusy_Error
        DCD     &12345 ; Fix me
        =       "IIC busy", 0
        ALIGN

IIC_Error
	MOV	R0, #0
	STR	R0, [R0, #IICStatus]
        ADR     R0,IICError_Error
        B       IIC_ExitError

IICError_Error
        DCD     &12345 ; Fix me
        =       "IIC error", 0
        ALIGN
a759 54

IICIRQ
        Push    "R9,R14"
        MOV     R9, R12
        MOV	R0, #0
        CallHAL HAL_IICMonitorTransfer
        MOV     R12, #0
        STR     R0, [R12, #IICStatus]
        Pull    "R9,PC"

IICAbort
        Push    "R7,R8,R9,R11,R12"
        MOV     R11,R13
        SUB     R13,R13,#&80
        MRS     R7,CPSR
        ORR     R8,R7,#I32_bit
 [ HAL
        AddressHAL
 |
        MOV     R9,#IOC
 ]
 [ {FALSE}
        MOV     R1,#16                          ; Two bytes in case RTC transmitting
35
     iicBL      Start                           ; Start/clock edge
     iicBL      Stop
        SUBS    R1,R1,#1
        BNE     %BT35
 |
     iicBL      Start
        MOV     R0, #1
     iicBL      TXAck
     iicBL      Stop
 ]
        Pull    "R7,R8,R9,R11,R12"
        MOV     PC,R14

IICInit
        Push    "R9,R14"
        AddressHAL
        MOV     a1, #0
        CallHAL HAL_IICType
        MOV     a2, #0
        STR     a1, [a2, #IICType]
        TST     a1, #IICFlag_Background
        Pull    "R9,PC",EQ
        SUB     sp, sp, #12
        MOV     a1, sp
        MOV     a2, #0
        CallHAL HAL_IICDevice
        LDR     a1, [sp]
        CallHAL HAL_IRQEnable
        ADD     sp, sp, #12
        Pull    "R9,PC"
@


1.1.2.5
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d834 3
a836 1
        MakeErrorBlock  IIC_Busy
d845 3
a847 1
        MakeErrorBlock  IIC_Error
a884 1
        ADD     R13,R13,#&80
@


1.1.2.6
log
@Support for keys held down in the HAL at power on.
*Configure ANYTHINGsize was broken due to not setting R0 to ReadUnsigned
IIC ack message uninternationalised
OS_Memory was saying we only had 4M of RAM
VDU4 scrolling when output was switched to sprite was causing corruption
on use of CTRL-J and CTRL-K
Default SystemSize CMOS set to 32k

Version 5.35, 4.79.2.55. Tagged as 'Kernel-5_35-4_79_2_55'
@
text
@d19 2
a20 2
PollMax         *       150     ; Number of times to poll for an Ack (increase if you
                                ; clock faster - need to allow 5ms for write cycle).
d278 1
a278 1
        BNE     IIC_OpV_HAL             ; HAL can make use of a hardware IIC engine
d372 2
a373 2
        MOV     R0, #0
        STR     R0, [R0, #IICStatus]
a382 4
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"

        MakeInternatErrorBlock IIC_NoAcknowledge,, "NoAck:No acknowledge from IIC device"
d385 1
d389 1
a389 4
        MakeErrorBlock         IIC_NoAcknowledge
 ]


d393 1
a393 1
;       SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
d410 1
a410 1
        ADD     R0, R0, R1, LSL #1      ; R0 := C0 + C1*2
d412 7
a418 7
        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy
        BIC     R1, R1, #&03                    ; clear clock and data
        ORR     R0, R1, R0                      ; put in new clock and data
        ORR     R0, R0, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R0, [R2, #IOCControlSoftCopy]   ; store back to soft copy
d420 2
a421 2
        MOV     R2, #IOC
        STRB    R0, [R2, #IOCControl]
d425 2
a426 2
        MOV     R0, #0
        LDRB    R0, [R0, #NVRamSpeed]
d438 1
a438 1
;       ReadC1C0 - Read clock and data lines to  R1 and R0 respectively
d440 1
a440 1
; out:  R0, R1 updated
d464 2
a465 2
; in:   R0 = time delay in 1/2 microsecond units
;       On ARM600, we may or may not be in a 32-bit mode
d467 1
a467 1
; out:  R0,R1 corrupted
d501 1
a501 1
;       ClockData - Clock a bit of data down the IIC bus
d503 1
a503 1
; in:   R0 = data bit
d505 1
a505 1
; out:  All registers preserved, including PSR
d517 1
a517 1
        MOV     R1, #0                  ; Clock lo
d525 1
a525 1
        MOV     R1, #1                  ; Clock hi
d531 1
a531 1
        MOV     R1, #0                  ; Clock lo
d543 1
a543 1
;       Start - Send the Start signal
d545 1
a545 1
; out:  All registers preserved, PSR corrupted
d548 1
a548 1
Start   ROUT
d551 2
a552 2
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
d557 2
a558 2
        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
d563 2
a564 2
        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
d571 1
a571 1
;       RepeatedStart - Send a Repeated Start signal
d573 1
a573 1
; out:  All registers preserved, PSR corrupted
d576 1
a576 1
RepeatedStart   ROUT
d583 2
a584 2
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
d589 2
a590 2
        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
d595 2
a596 2
        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
d603 1
a603 1
;       Acknowledge - Check acknowledge after transmitting a byte
d605 3
a607 3
; out:  All registers preserved
;       V=0 => acknowledge received
;       V=1 => no acknowledge received
d613 2
a614 2
        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
d623 2
a624 2
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
d632 2
a633 2
        MOV     R0, #1
        MOV     R1, #0                  ; clock LO, data HI
d642 2
a643 2
        BICEQ   R2, R2, #V_bit          ; clear V if correct acknowledge
        ORRNE   R2, R2, #V_bit          ; set V if no acknowledge
d650 1
a650 1
;       Stop - Send the Stop signal
d652 1
a652 1
; out:  All registers preserved, PSR corrupted
d655 1
a655 1
Stop    ROUT
d658 2
a659 2
        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
d662 2
a663 2
        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
d668 2
a669 2
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
d676 1
a676 1
;       TXByte - Transmit a byte
d678 1
a678 1
; in:   R0 = byte to be transmitted
d680 1
a680 1
; out:  All registers preserved, PSR corrupted
d683 1
a683 1
TXByte  ROUT
d685 2
a686 2
        MOV     R1, #&80                ; 2^7 the bit mask
        MOV     R2, R0                  ; byte goes into R2
d688 2
a689 2
        ANDS    R0, R2, R1              ; zero if bit is zero
        MOVNE   R0, #1
d691 2
a692 2
        MOVS    R1, R1, LSR #1
        BNE     %BT10
d695 1
a695 1
TXAck   ROUT
d699 1
a699 1
        B       Acknowledge
d704 1
a704 1
;       TXPollAck - Transmit a byte and poll for acknowledge
d706 2
a707 2
;       This is intended for devices with a slow internal write cycle which
;       don't ack until the write cycle is finished ( eg ATMEL AT24C01A/x )
d709 1
a709 1
; in:   R0 = byte to be transmitted
d711 1
a711 1
; out:  All registers preserved
d714 1
a714 1
TXPollAck       ROUT
d716 1
a716 1
        MOV     R1, #1
d722 1
a722 1
        TEQ     R1, #PollMax
d724 2
a725 2
 [      {FALSE}
        BREG    R1, "i2c tries:"
d734 1
a734 1
;       RXByte - Receive a byte
d736 2
a737 2
; out:  R0 = byte received
;       All other registers preserved, PSR corrupted
d740 1
a740 1
RXByte  ROUT
d745 2
a746 2
        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
d755 2
a756 2
        MOV     R0, #1                  ; pulse clock HI
        MOV     R1, #1
d762 2
a763 2
        MOV     R0, #1                  ; return clock LO
        MOV     R1, #0
d770 1
a770 1
        BCS     %BT10
d772 1
a772 1
        MOV     R0, R3                  ; return the result in R0
d784 1
a784 1
        LDR     iiclr, [R2, #IICStatus]
d791 1
a791 1
        MOVEQ   iiclr, #1               ; no,just try once
d795 2
a796 2
        MOV     iiclr, #1
        STR     iiclr, [R2, #IICStatus]
d804 1
a804 1
        CallHAL HAL_IICTransfer
d837 2
a838 2
        MOV     R0, #0
        STR     R0, [R0, #IICStatus]
d851 1
a851 1
        MOV     R0, #0
@


1.1.2.7
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d145 1
a145 2
;       R1 = bits 0-23: number of transfers
;            bits 24-31: bus number
a159 1
        MOV     r3, r1, LSR #24
d168 1
a168 1
        LDR     r2, =ZeroPage+IRQsema
d185 1
a188 5
        LDRB    r11, [r1, #IICLink_Size+3] ; get bus number
        CMP     r11, r3
        BNE     %BT01                   ; wrong bus, don't add ourselves to this list
        
        Push    "r12"                   ; put original sp on stack for our exit routine
d264 1
a264 2
;       R1 = bits 0-23: number of transfers
;            bits 24-31: bus number
a270 1
        MOV     R1, R1, ROR #24         ; Move xfer count to low byte
a273 6
        ; Get correct IICBus ptr in R2
        AND     R3, R1, #255
        MOV     iiclr, #IICBus_Size
        LDR     R2, =ZeroPage+IICBus_Base
        MLA     R2, R3, iiclr, R2

d276 1
a276 1
        LDR     iiclr, [R2, #IICBus_Type]
d281 2
a282 2
        SUBS    R0, R0, #256
        BLT     %FT90
a332 1
        MOVCS   iiclr, iiclr, LSR #8
a351 1
        MOVCS   iiclr, iiclr, LSR #8
a370 4
        LDRB    R0, [iicsp]
        MOV     R1, #IICBus_Size
        LDR     R2, =ZeroPage+IICBus_Base
        MLA     R2, R0, R1, R2
d373 1
a373 1
        STR     R0, [R2, #IICBus_Status]
d409 1
a409 3
        BIC     r0, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r0, [r0, #-4]           ; list head
        LDRB    r0, [r0, #IICLink_Size+3] ; bus number
d431 1
a431 1
        LDR     R0, =ZeroPage
a451 3
        BIC     r0, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r0, [r0, #-4]           ; list head
        LDRB    r0, [r0, #IICLink_Size+3] ; bus number 
d784 1
a784 1
;       R2 = IICBus ptr
d786 1
a786 2
;       [iicsp, #0] = bits 0-7: bus number
;                     bits 8-31: number of transfers
d790 1
a790 1
        LDR     iiclr, [R2, #IICBus_Status]
d802 1
a802 1
        STR     iiclr, [R2, #IICBus_Status]
d804 3
a806 2
     iicPush    "R2,R3"
        LDR     R1, [iicsp, #8]
a807 2
        AND     R0, R1, #255
        MOV     R1, R1, LSR #8
d813 2
a814 1
     iicPull    "R2,R3"
d821 1
a821 1
        STREQ   R0, [R2, #IICBus_Status] ; mark IIC system as free
d825 1
a825 1
        LDR     R0, [R2, #IICBus_Status]
d844 1
a844 1
        STR     R0, [R2, #IICBus_Status]
d855 3
a857 11
        ; R12 = bus number
        Push    "R8-R9,R14"
        LDR     R14,=ZeroPage
        AddressHAL R14

        ; Get IICBus ptr
        MOV     R0, #IICBus_Size
        ADD     R1, R14, #IICBus_Base
        MLA     R8, R12, R0, R1

        MOV     R0, R12
d859 3
a861 4
        STR     R0, [R8, #IICBus_Status]
        LDR     R0, [R8, #IICBus_Device]
        CallHAL HAL_IRQClear
        Pull    "R8-R9,PC"
d864 1
a864 1
        Push    "R0-R3,R7,R8,R9,R11,R12,R14"
d866 1
a866 1
        SUB     R13,R13,#(1:SHL:IICStackAlignment)+4
a873 16
        CallHAL HAL_IICBuses
        SUBS    R0,R0,#1
        BLT     %FT20
        LDR     R1,=ZeroPage+IICBus_Base
        MOV     R12,#IICBus_Size
        MLA     R1,R12,R0,R1
        LDR     R12,[R1,#IICBus_Type]
        MOV     R0,R0,LSL #24
05
        TST     R12,#IICFlag_HighLevel
        BNE     %FT10
        ; Set up a fake transfer list for Start/Stop/TXAck to read the bus number from
        Push    "R0,R1"
        BIC     R0, iicsp, #(1:SHL:IICStackAlignment)-1
        STR     R13,[R0,#-4]
             
d887 3
a889 8
        Pull    "R0,R1"
10
        SUBS    R0,R0,#1<<24
        SUB     R1,R1,#IICBus_Size
        BGE     %BT05
20
        ADD     R13,R13,#(1:SHL:IICStackAlignment)+4
        Pull    "R0-R3,R7,R8,R9,R11,R12,PC"
d892 1
a892 1
        Push    "R7-R9,R14"
d894 1
a894 8
        MOV     R7, #0
        LDR     R8, =ZeroPage+IICBus_Base
10
        CallHAL HAL_IICBuses
        CMP     R7, R0
        Pull    "R7-R9,R14",HS
        BHS     IICAbort ; Ensure any CMOS operation aborted
        MOV     a1, R7
d896 2
a897 1
        STR     a1, [R8, #IICBus_Type]
d899 1
a899 1
        BEQ     %FT20
d902 1
a902 1
        MOV     a2, R7
a904 1
        STR     a1, [R8, #IICBus_Device]
d907 1
a907 4
20
        ADD     R7, R7, #1
        ADD     R8, R8, #IICBus_Size
        B       %BT10
@


1.1.2.8
log
@Merge with RPi branch
Detail:
  Merge the RPi branch with the HAL branch, ending RPi branch development
  Brief summary of changes brought in:
  * Added HAL_VideoStartupMode to allow the HAL to specify a startup mode for the OS
  * Fixed addresses being sent to GraphicsV_SetDMAAddress being wrong for external framestores (addresses were given as if internal framestore was in use)
  * Add InverseTextTransparency option for limited compile-time support for targets where framebuffer alpha channel is important
  * Fix ConfiguredLanguage for non-Tungsten builds
  * Update ARMv6 CPU detection to read cache parameters from cache type register instead of using KnownCPUTable
  * Add HALDebugHexTX/TX2/TX4 debug routines for writing out numbers via HAL
  * Use HAL_TimerIRQClear when clearing timer 0 interrupt instead of just HAL_IRQClear
  * Initialise FileLangCMOS using defines from Hdr:FSNumbers instead of magic numbers. Use SDFS on M_ARM11ZF.
  * Improved software mouse pointer support; software pointer now removed & restored in some of the same places the text cursor is
  * Improve support for external framestores; driver is now able to grow/shrink/move the framestore on mode changes if bit 5 of GraphicsV_DisplayFeatures R0 is set
  * GraphicsV_FramestoreAddress now has a default claimant which calls HAL_VideoFramestoreAddress
Admin:
  Tested on Raspberry Pi, Iyonix, OMAP3, IOMD


Version 5.35, 4.79.2.165. Tagged as 'Kernel-5_35-4_79_2_165'
@
text
@d278 1
a278 1
        MOV     R1, R1, ROR #24         ; Move bus number to low byte
@


1.1.2.9
log
@Simplify HAL_IICDevice API
The only function to use the abandoned extensions to OS_ClaimDeviceVector, the 2nd & 3rd members of the structure never got used.
Change uses of HAL_IICDevice to pass in the bus, and expect the device number back.
Docs updated accordingly.

Version 5.35, 4.79.2.218. Tagged as 'Kernel-5_35-4_79_2_218'
@
text
@d962 3
a964 1
        MOV     a1, R7
d966 1
d969 1
@


1.1.2.10
log
@Fix IIC bus information being wiped by RAM clear
Detail:
  hdr/KernelWS - Enlarge the SkippedTables area to encompass IICBus_Base
  s/PMF/IIC - Manually set IICBus_Status of each bus to 0 within IICInit
Admin:
  Bug was introduced in Kernel-5_35-4_79_2_168 when IIC initialisation was moved to earlier in the ROM init sequence, but has gone unnoticed due to it only really affecting the high-level API (and none of the relevant HALs were relying on the kernel for the RAM clear)
  Tested on BB-xM with kernel RAM clear


Version 5.35, 4.79.2.236. Tagged as 'Kernel-5_35-4_79_2_236'
@
text
@a956 2
        MOV     a1, #0
        STR     a1, [R8, #IICBus_Status]
@


1.1.2.11
log
@Use IICStatus names
Not tagged.
@
text
@d842 1
a842 1
20      TEQ     R0, #IICStatus_NoACK
d844 1
a844 1
        TEQ     R0, #IICStatus_Busy
d846 1
a846 1
        TEQ     R0, #IICStatus_Completed
d849 1
a849 1
        TEQ     R0, #IICStatus_InProgress
@


1.1.2.12
log
@Add some basic parameter validation to OS_IICOp
Detail:
  s/PMF/IIC - OS_IICOp now does some basic validation of its parameters, to help avoid crashes, memory corruption, or bad IIC transfers being performed when invalid parameters are supplied
Admin:
  Tested on Pandaboard
  Fixes ticket #404
  https://www.riscosopen.org/tracker/tickets/404


Version 5.35, 4.79.2.260. Tagged as 'Kernel-5_35-4_79_2_260'
@
text
@d117 1
a117 15
        Push    "R0-R3,sb,LR"
        ; Check bus index is valid
        AddressHAL
        CallHAL HAL_IICBuses
        MOV     LR, R0
        Pull    "R0-R3,sb"
        CMP     R1, LR, LSL #24         ; n.b. fails if we have 256 buses (unlikely!)
        BHS     %FT50
        ; Check descriptor ptr & count
        BICS    lr, R1, #&FF000000
        TEQNE   R0, #0
        BEQ     %FT50
        TST     R0, #3
        BNE     %FT50
        ; Params look vaguely sensible, call through to the core code
a120 9
50
        ADRL    R0, ErrorBlock_BadParameters
    [ International
        BL     TranslateError
    |
        SETV
    ]
        Pull    LR
        B       SLVK_TestV        
@


1.1.2.13
log
@Take into account bus speed when determining IIC op max retry count
Detail:
  s/PMF/IIC - when dealing with IIC transfers which use the high-level HAL API, take into account the bus speed when calculating the max retry count. Otherwise if (e.g.) writing to CMOS we may give up before the device has recovered from the previous write (which is typically listed as a max time of 5ms)
Admin:
  Fixes issues with CMOS checksum not being updated correctly if using IIC bus speeds > 100khz


Version 5.35, 4.79.2.289. Tagged as 'Kernel-5_35-4_79_2_289'
@
text
@d845 1
a846 9
        BEQ     %FT15
        LDR     iiclr, [R2, #IICBus_Type]
        AND     iiclr, iiclr, #IICFlag_Fast+IICFlag_HighSpeed
        ASSERT  IICFlag_HighSpeed > IICFlag_Fast
        CMP     iiclr, #IICFlag_Fast
        MOV     iiclr, #PollMax
        MOVHS   iiclr, iiclr, LSL #2    ; 4x faster bus, 4x more retries
        ADDHI   iiclr, iiclr, iiclr, LSL #3 ; 34x faster bus, 36x more retries (slight over-estimate)
15
@


1.1.2.7.2.1
log
@Fix addresses sent to GraphicsV_SetDMAAddress when external framestore in use. Add ID for BCM2835 VDU HAL device.
Detail:
  hdr/KernelWS, s/vdu/vdudriver, s/vdu/vduwrch - Fixed wrong addresses being sent to GraphicsV_SetDMAAddress when an external framestore is in use. Previously VideoPhysAddr was being treated as if it was the base of screen memory, but that's only the case if an internal framestore is in use. Since VideoPhysAddr is part of PhysRamTable it's not possible to change it to point to an external framestore, so a new workspace variable, TrueVideoPhysAddr, is used instead.
  hdr/HALDevice - Added device ID for BCM2835 VDU device
  s/PMF/IIC - Corrected an incorrect comment in IICDoOp
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.22. Tagged as 'Kernel-5_35-4_79_2_147_2_22'
@
text
@d278 1
a278 1
        MOV     R1, R1, ROR #24         ; Move bus number to low byte
@


1.1.2.6.2.1
log
@Make Cortex kernel call HAL_IRQClear after servicing I2C interrupts
Detail:
  s/PMF/IIC - IICIRQ now calls HAL_IRQClear after HAL_IICMonitorTransfer, in order to make sure the IRQ controller is restarted.
Admin:
  Tested on rev C2 beagleboard


Version 5.35, 4.79.2.98.2.10. Tagged as 'Kernel-5_35-4_79_2_98_2_10'
@
text
@a860 8
        ; this is a bit ugly - we really need a way to pass the device number to IRQ handlers
        SUB     sp, sp, #12
        MOV     a1, sp
        MOV     a2, #0
        CallHAL HAL_IICDevice
        LDR     a1, [sp]
        CallHAL HAL_IRQClear
        ADD     sp, sp, #12
@


1.1.2.6.2.2
log
@Update OS_IICOp to support multiple IIC buses
Detail:
  OS_IICOp (and in turn, RISCOS_IICOpV) now treat the top byte of R1 as containing the IIC bus number, allowing multiple buses to be used.
  hdr/KernelWS - Changed workspace a bit so that the kernel can support up to IICBus_Count buses (currently 3), each with its own IICBus_* block.
  s/HAL - Update Reset_IRQ_Handler to cope with interrupts from all IIC buses instead of just the first. Fix/update RISCOS_IICOpV description.
  s/NewIRQs - Update InitialiseIRQ1Vtable to set up interrupt handlers for all IRQ-supporting IIC buses
  s/NewReset - Get rid of the IICAbort call that was just before IICInit. IICInit now calls IICAbort itself.
  s/PMF/IIC - Bulk of the changes. Code now uses the IICBus_ structures instead of the IICStatus and IICType variables. Re-entrancy code has been updated to take into account the possiblity of multiple buses; when OS_IICOp calls are nested, the IIC transfers will be added to bus-specific queues instead of all going in the same queue. However only one queue will be processed at a time.
  s/ChangeDyn - Workspace shuffling means a couple of MOV's needed to be swapped with LDR's when getting immediate constants
Admin:
  Tested with OMAP & IOMD ROM builds.
  Both high & low-level bus types seem to work OK, along with re-entrancy, both on the same bus and on a different bus.


Version 5.35, 4.79.2.98.2.33. Tagged as 'Kernel-5_35-4_79_2_98_2_33'
@
text
@d145 1
a145 2
;       R1 = bits 0-23: number of transfers
;            bits 24-31: bus number
a159 1
        MOV     r3, r1, LSR #24
d185 1
a188 5
        LDRB    r11, [r1, #IICLink_Size+3] ; get bus number
        CMP     r11, r3
        BNE     %BT01                   ; wrong bus, don't add ourselves to this list
        
        Push    "r12"                   ; put original sp on stack for our exit routine
d264 1
a264 2
;       R1 = bits 0-23: number of transfers
;            bits 24-31: bus number
a270 1
        MOV     R1, R1, ROR #24         ; Move xfer count to low byte
a273 6
        ; Get correct IICBus ptr in R2
        AND     R3, R1, #255
        MOV     iiclr, #IICBus_Size
        MOV     R2, #IICBus_Base
        MLA     R2, R3, iiclr, R2

d276 1
a276 1
        LDR     iiclr, [R2, #IICBus_Type]
d281 2
a282 2
        SUBS    R0, R0, #256
        BLT     %FT90
a332 1
        MOVCS   iiclr, iiclr, LSR #8
a351 1
        MOVCS   iiclr, iiclr, LSR #8
a370 4
        LDRB    R0, [iicsp]
        MOV     R1, #IICBus_Size
        MOV     R2, #IICBus_Base
        MLA     R2, R0, R1, R2
d373 1
a373 1
        STR     R0, [R2, #IICBus_Status]
d409 1
a409 3
        BIC     r0, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r0, [r0, #-4]           ; list head
        LDRB    r0, [r0, #IICLink_Size+3] ; bus number
a451 3
        BIC     r0, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r0, [r0, #-4]           ; list head
        LDRB    r0, [r0, #IICLink_Size+3] ; bus number 
d784 1
a784 1
;       R2 = IICBus ptr
d786 1
a786 2
;       [iicsp, #0] = bits 0-7: bus number
;                     bits 8-31: number of transfers
d790 1
a790 1
        LDR     iiclr, [R2, #IICBus_Status]
d802 1
a802 1
        STR     iiclr, [R2, #IICBus_Status]
d804 3
a806 2
     iicPush    "R2,R3"
        LDR     R1, [iicsp, #8]
a807 2
        AND     R0, R1, #255
        MOV     R1, R1, LSR #8
d813 2
a814 1
     iicPull    "R2,R3"
d821 1
a821 1
        STREQ   R0, [R2, #IICBus_Status] ; mark IIC system as free
d825 1
a825 1
        LDR     R0, [R2, #IICBus_Status]
d844 1
a844 1
        STR     R0, [R2, #IICBus_Status]
d855 3
a857 11
        ; R12 = bus number
        Push    "R8-R9,R14"
        MOV     R14,#0
        AddressHAL R14

        ; Get IICBus ptr
        MOV     R0, #IICBus_Size
        MOV     R1, #IICBus_Base
        MLA     R8, R12, R0, R1

        MOV     R0, R12
d859 8
a866 2
        STR     R0, [R8, #IICBus_Status]
        LDR     R0, [R8, #IICBus_Device]
d868 2
a869 1
        Pull    "R8-R9,PC"
d872 1
a872 1
        Push    "R0-R3,R7,R8,R9,R11,R12,R14"
d874 1
a874 1
        SUB     R13,R13,#(1:SHL:IICStackAlignment)+4
a881 16
        CallHAL HAL_IICBuses
        SUBS    R0,R0,#1
        BLT     %FT20
        MOV     R1,#IICBus_Base
        MOV     R12,#IICBus_Size
        MLA     R1,R12,R0,R1
        LDR     R12,[R1,#IICBus_Type]
        MOV     R0,R0,LSL #24
05
        TST     R12,#IICFlag_HighLevel
        BNE     %FT10
        ; Set up a fake transfer list for Start/Stop/TXAck to read the bus number from
        Push    "R0,R1"
        BIC     R0, iicsp, #(1:SHL:IICStackAlignment)-1
        STR     R13,[R0,#-4]
             
d895 3
a897 8
        Pull    "R0,R1"
10
        SUBS    R0,R0,#1<<24
        SUB     R1,R1,#IICBus_Size
        BGE     %BT05
20
        ADD     R13,R13,#(1:SHL:IICStackAlignment)+4
        Pull    "R0-R3,R7,R8,R9,R11,R12,PC"
d900 1
a900 1
        Push    "R7-R9,R14"
d902 1
a902 8
        MOV     R7, #0
        MOV     R8, #IICBus_Base
10
        CallHAL HAL_IICBuses
        CMP     R7, R0
        Pull    "R7-R9,R14",HS
        BHS     IICAbort ; Ensure any CMOS operation aborted
        MOV     a1, R7
d904 2
a905 1
        STR     a1, [R8, #IICBus_Type]
d907 1
a907 1
        BEQ     %FT20
d910 1
a910 1
        MOV     a2, R7
a912 1
        STR     a1, [R8, #IICBus_Device]
d915 1
a915 4
20
        ADD     R7, R7, #1
        ADD     R8, R8, #IICBus_Size
        B       %BT10
@


1.1.2.6.2.3
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d170 1
a170 1
        LDR     r2, =ZeroPage+IRQsema
d285 1
a285 1
        LDR     R2, =ZeroPage+IICBus_Base
d389 1
a389 1
        LDR     R2, =ZeroPage+IICBus_Base
d453 1
a453 1
        LDR     R0, =ZeroPage
d883 1
a883 1
        LDR     R14,=ZeroPage
d888 1
a888 1
        ADD     R1, R14, #IICBus_Base
d912 1
a912 1
        LDR     R1,=ZeroPage+IICBus_Base
d951 1
a951 1
        LDR     R8, =ZeroPage+IICBus_Base
@



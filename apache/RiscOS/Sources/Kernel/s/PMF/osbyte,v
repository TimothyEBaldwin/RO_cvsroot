head	4.16;
access;
symbols
	Kernel-6_15:4.16
	Kernel-6_14:4.16
	Kernel-6_01-3:4.16
	Kernel-6_13:4.16
	Kernel-6_12:4.16
	Kernel-6_11:4.16
	Kernel-6_10:4.16
	Kernel-6_09:4.16
	Kernel-6_08-4_129_2_10:4.14.2.2
	Kernel-6_08-4_129_2_9:4.14.2.2
	Kernel-6_08:4.16
	Kernel-6_07:4.16
	Kernel-6_06:4.16
	Kernel-6_05-4_129_2_8:4.14.2.2
	Kernel-6_05:4.16
	Kernel-6_04:4.16
	Kernel-6_03:4.16
	Kernel-6_01-2:4.16
	Kernel-6_01-4_146_2_1:4.16
	Kernel-6_02:4.16
	Kernel-6_01-1:4.16
	Kernel-6_01:4.16
	Kernel-6_00:4.16
	Kernel-5_99:4.16
	Kernel-5_98:4.15
	Kernel-5_97-4_129_2_7:4.14.2.1
	Kernel-5_97:4.15
	Kernel-5_96:4.15
	Kernel-5_95:4.15
	Kernel-5_94:4.15
	Kernel-5_93:4.15
	Kernel-5_92:4.15
	Kernel-5_91:4.15
	Kernel-5_90:4.15
	Kernel-5_89-4_129_2_6:4.14.2.1
	Kernel-5_89:4.15
	Kernel-5_88-4_129_2_5:4.14
	Kernel-5_88-4_129_2_4:4.14
	Kernel-5_88:4.14
	Kernel-5_87:4.14
	Kernel-5_86-4_129_2_3:4.14
	Kernel-5_86-4_129_2_2:4.14
	Kernel-5_86-4_129_2_1:4.14
	Kernel-5_86:4.14
	SMP:4.14.0.2
	SMP_bp:4.14
	Kernel-5_85:4.14
	Kernel-5_54-1:4.14
	Kernel-5_84:4.14
	Kernel-5_83:4.14
	Kernel-5_82:4.14
	Kernel-5_81:4.14
	Kernel-5_80:4.14
	Kernel-5_79:4.14
	Kernel-5_78:4.14
	Kernel-5_77:4.14
	Kernel-5_76:4.14
	Kernel-5_75:4.14
	Kernel-5_74:4.14
	Kernel-5_73:4.14
	Kernel-5_72:4.14
	Kernel-5_71:4.14
	Kernel-5_70:4.14
	Kernel-5_69:4.14
	Kernel-5_68:4.14
	Kernel-5_67:4.14
	Kernel-5_66:4.14
	Kernel-5_65:4.14
	Kernel-5_64:4.14
	Kernel-5_63:4.14
	Kernel-5_62:4.14
	Kernel-5_61:4.14
	Kernel-5_60:4.14
	Kernel-5_59:4.14
	Kernel-5_58:4.14
	Kernel-5_57:4.14
	Kernel-5_56:4.14
	Kernel-5_55:4.14
	Kernel-5_54:4.14
	Kernel-5_53:4.14
	Kernel-5_52:4.14
	Kernel-5_51:4.14
	Kernel-5_50:4.13
	Kernel-5_49:4.13
	HAL_merge:4.12.2.19
	Kernel-5_48:4.13
	Kernel-5_35-4_79_2_327:4.12.2.19
	Kernel-5_35-4_79_2_326:4.12.2.19
	Kernel-5_35-4_79_2_325:4.12.2.19
	Kernel-5_35-4_79_2_324:4.12.2.19
	Kernel-5_35-4_79_2_323:4.12.2.19
	Kernel-5_35-4_79_2_322:4.12.2.19
	Kernel-5_35-4_79_2_321:4.12.2.19
	Kernel-5_35-4_79_2_320:4.12.2.19
	Kernel-5_35-4_79_2_319:4.12.2.19
	Kernel-5_35-4_79_2_318:4.12.2.19
	Kernel-5_35-4_79_2_317:4.12.2.19
	Kernel-5_35-4_79_2_316:4.12.2.19
	Kernel-5_35-4_79_2_315:4.12.2.19
	Kernel-5_35-4_79_2_314:4.12.2.19
	Kernel-5_35-4_79_2_313:4.12.2.19
	Kernel-5_35-4_79_2_312:4.12.2.18
	Kernel-5_35-4_79_2_311:4.12.2.18
	Kernel-5_35-4_79_2_310:4.12.2.18
	Kernel-5_35-4_79_2_309:4.12.2.18
	Kernel-5_35-4_79_2_308:4.12.2.18
	Kernel-5_35-4_79_2_307:4.12.2.18
	Kernel-5_35-4_79_2_306:4.12.2.18
	Kernel-5_35-4_79_2_305:4.12.2.18
	Kernel-5_35-4_79_2_304:4.12.2.18
	Kernel-5_35-4_79_2_303:4.12.2.18
	Kernel-5_35-4_79_2_302:4.12.2.18
	Kernel-5_35-4_79_2_301:4.12.2.18
	Kernel-5_35-4_79_2_300:4.12.2.18
	Kernel-5_35-4_79_2_299:4.12.2.18
	Kernel-5_35-4_79_2_298:4.12.2.18
	Kernel-5_35-4_79_2_297:4.12.2.18
	Kernel-5_35-4_79_2_296:4.12.2.18
	Kernel-5_35-4_79_2_295:4.12.2.18
	Kernel-5_35-4_79_2_294:4.12.2.18
	Kernel-5_35-4_79_2_293:4.12.2.18
	Kernel-5_35-4_79_2_292:4.12.2.18
	Kernel-5_35-4_79_2_291:4.12.2.18
	Kernel-5_35-4_79_2_290:4.12.2.18
	Kernel-5_35-4_79_2_289:4.12.2.18
	Kernel-5_35-4_79_2_288:4.12.2.18
	Kernel-5_35-4_79_2_287:4.12.2.18
	Kernel-5_35-4_79_2_286:4.12.2.18
	Kernel-5_35-4_79_2_285:4.12.2.18
	Kernel-5_35-4_79_2_284:4.12.2.18
	Kernel-5_35-4_79_2_283:4.12.2.18
	Kernel-5_35-4_79_2_282:4.12.2.18
	Kernel-5_35-4_79_2_281:4.12.2.18
	Kernel-5_35-4_79_2_280:4.12.2.18
	Kernel-5_35-4_79_2_279:4.12.2.18
	Kernel-5_35-4_79_2_278:4.12.2.18
	Kernel-5_35-4_79_2_277:4.12.2.18
	Kernel-5_35-4_79_2_276:4.12.2.18
	Kernel-5_35-4_79_2_275:4.12.2.18
	Kernel-5_35-4_79_2_274:4.12.2.18
	Kernel-5_35-4_79_2_273:4.12.2.18
	Kernel-5_35-4_79_2_272:4.12.2.18
	Kernel-5_35-4_79_2_271:4.12.2.18
	Kernel-5_35-4_79_2_270:4.12.2.18
	Kernel-5_35-4_79_2_269:4.12.2.18
	Kernel-5_35-4_79_2_268:4.12.2.18
	Kernel-5_35-4_79_2_267:4.12.2.18
	Kernel-5_35-4_79_2_266:4.12.2.18
	Kernel-5_35-4_79_2_265:4.12.2.18
	Kernel-5_35-4_79_2_264:4.12.2.18
	Kernel-5_35-4_79_2_263:4.12.2.18
	Kernel-5_35-4_79_2_262:4.12.2.18
	Kernel-5_35-4_79_2_261:4.12.2.18
	Kernel-5_35-4_79_2_260:4.12.2.17
	Kernel-5_35-4_79_2_259:4.12.2.17
	Kernel-5_35-4_79_2_258:4.12.2.17
	Kernel-5_35-4_79_2_257:4.12.2.17
	Kernel-5_35-4_79_2_256:4.12.2.17
	Kernel-5_35-4_79_2_255:4.12.2.17
	Kernel-5_35-4_79_2_254:4.12.2.17
	Kernel-5_35-4_79_2_253:4.12.2.17
	Kernel-5_35-4_79_2_252:4.12.2.17
	Kernel-5_35-4_79_2_251:4.12.2.17
	Kernel-5_35-4_79_2_250:4.12.2.17
	Kernel-5_35-4_79_2_249:4.12.2.17
	Kernel-5_35-4_79_2_248:4.12.2.17
	Kernel-5_35-4_79_2_247:4.12.2.17
	Kernel-5_35-4_79_2_246:4.12.2.16
	Kernel-5_35-4_79_2_245:4.12.2.16
	Kernel-5_35-4_79_2_244:4.12.2.16
	Kernel-5_35-4_79_2_243:4.12.2.16
	Kernel-5_35-4_79_2_242:4.12.2.16
	Kernel-5_35-4_79_2_241:4.12.2.16
	Kernel-5_35-4_79_2_240:4.12.2.16
	Kernel-5_35-4_79_2_239:4.12.2.16
	Kernel-5_35-4_79_2_238:4.12.2.16
	Kernel-5_35-4_79_2_237:4.12.2.16
	Kernel-5_35-4_79_2_236:4.12.2.16
	Kernel-5_35-4_79_2_235:4.12.2.16
	Kernel-5_35-4_79_2_234:4.12.2.16
	Kernel-5_35-4_79_2_233:4.12.2.16
	Kernel-5_35-4_79_2_232:4.12.2.16
	Kernel-5_35-4_79_2_231:4.12.2.16
	Kernel-5_35-4_79_2_230:4.12.2.16
	Kernel-5_35-4_79_2_229:4.12.2.16
	Kernel-5_35-4_79_2_228:4.12.2.16
	Kernel-5_35-4_79_2_227:4.12.2.16
	Kernel-5_35-4_79_2_226:4.12.2.16
	Kernel-5_35-4_79_2_225:4.12.2.16
	Kernel-5_35-4_79_2_224:4.12.2.16
	Kernel-5_35-4_79_2_223:4.12.2.16
	Kernel-5_35-4_79_2_222:4.12.2.16
	Kernel-5_35-4_79_2_221:4.12.2.16
	Kernel-5_35-4_79_2_220:4.12.2.16
	Kernel-5_35-4_79_2_219:4.12.2.16
	Kernel-5_35-4_79_2_218:4.12.2.16
	Kernel-5_35-4_79_2_217:4.12.2.16
	Kernel-5_35-4_79_2_216:4.12.2.16
	Kernel-5_35-4_79_2_215:4.12.2.16
	Kernel-5_35-4_79_2_214:4.12.2.16
	Kernel-5_35-4_79_2_213:4.12.2.16
	Kernel-5_35-4_79_2_212:4.12.2.16
	Kernel-5_35-4_79_2_211:4.12.2.16
	Kernel-5_35-4_79_2_210:4.12.2.16
	Kernel-5_35-4_79_2_209:4.12.2.16
	Kernel-5_35-4_79_2_208:4.12.2.16
	Kernel-5_35-4_79_2_207:4.12.2.16
	Kernel-5_35-4_79_2_206:4.12.2.16
	Kernel-5_35-4_79_2_205:4.12.2.16
	Kernel-5_35-4_79_2_204:4.12.2.16
	Kernel-5_35-4_79_2_203:4.12.2.16
	Kernel-5_35-4_79_2_202:4.12.2.15
	Kernel-5_35-4_79_2_201:4.12.2.14
	Kernel-5_35-4_79_2_200:4.12.2.14
	Kernel-5_35-4_79_2_199:4.12.2.14
	Kernel-5_35-4_79_2_198:4.12.2.14
	Kernel-5_35-4_79_2_197:4.12.2.14
	Kernel-5_35-4_79_2_196:4.12.2.14
	Kernel-5_35-4_79_2_195:4.12.2.14
	Kernel-5_35-4_79_2_194:4.12.2.14
	Kernel-5_35-4_79_2_193:4.12.2.14
	Kernel-5_35-4_79_2_192:4.12.2.14
	Kernel-5_35-4_79_2_191:4.12.2.14
	Kernel-5_35-4_79_2_190:4.12.2.14
	Kernel-5_35-4_79_2_189:4.12.2.14
	Kernel-5_35-4_79_2_188:4.12.2.14
	Kernel-5_35-4_79_2_187:4.12.2.14
	Kernel-5_35-4_79_2_186:4.12.2.14
	Kernel-5_35-4_79_2_185:4.12.2.14
	Kernel-5_35-4_79_2_184:4.12.2.14
	Kernel-5_35-4_79_2_183:4.12.2.13
	Kernel-5_35-4_79_2_182:4.12.2.13
	Kernel-5_35-4_79_2_181:4.12.2.13
	Kernel-5_35-4_79_2_180:4.12.2.13
	Kernel-5_35-4_79_2_179:4.12.2.13
	Kernel-5_35-4_79_2_178:4.12.2.13
	Kernel-5_35-4_79_2_177:4.12.2.12
	Kernel-5_35-4_79_2_176:4.12.2.12
	Kernel-5_35-4_79_2_175:4.12.2.12
	Kernel-5_35-4_79_2_174:4.12.2.12
	Kernel-5_35-4_79_2_173:4.12.2.11
	Kernel-5_35-4_79_2_172:4.12.2.11
	Kernel-5_35-4_79_2_171:4.12.2.11
	Kernel-5_35-4_79_2_170:4.12.2.11
	Kernel-5_35-4_79_2_169:4.12.2.11
	Kernel-5_35-4_79_2_168:4.12.2.11
	Kernel-5_35-4_79_2_167:4.12.2.11
	Kernel-5_35-4_79_2_166:4.12.2.11
	Kernel-5_35-4_79_2_165:4.12.2.11
	RPi_merge:4.12.2.9.2.1
	Kernel-5_35-4_79_2_147_2_23:4.12.2.9.2.1
	Kernel-5_35-4_79_2_147_2_22:4.12.2.9
	Kernel-5_35-4_79_2_147_2_21:4.12.2.9
	Kernel-5_35-4_79_2_147_2_20:4.12.2.9
	Kernel-5_35-4_79_2_147_2_19:4.12.2.9
	Kernel-5_35-4_79_2_147_2_18:4.12.2.9
	Kernel-5_35-4_79_2_164:4.12.2.11
	Kernel-5_35-4_79_2_163:4.12.2.11
	Kernel-5_35-4_79_2_147_2_17:4.12.2.9
	Kernel-5_35-4_79_2_147_2_16:4.12.2.9
	Kernel-5_35-4_79_2_147_2_15:4.12.2.9
	Kernel-5_35-4_79_2_162:4.12.2.11
	Kernel-5_35-4_79_2_161:4.12.2.11
	Kernel-5_35-4_79_2_147_2_14:4.12.2.9
	Kernel-5_35-4_79_2_147_2_13:4.12.2.9
	Kernel-5_35-4_79_2_160:4.12.2.11
	Kernel-5_35-4_79_2_159:4.12.2.11
	Kernel-5_35-4_79_2_158:4.12.2.11
	Kernel-5_35-4_79_2_157:4.12.2.11
	Kernel-5_35-4_79_2_156:4.12.2.11
	Kernel-5_35-4_79_2_147_2_12:4.12.2.9
	Kernel-5_35-4_79_2_147_2_11:4.12.2.9
	Kernel-5_35-4_79_2_155:4.12.2.11
	Kernel-5_35-4_79_2_147_2_10:4.12.2.9
	Kernel-5_35-4_79_2_154:4.12.2.11
	Kernel-5_35-4_79_2_153:4.12.2.11
	Kernel-5_35-4_79_2_147_2_9:4.12.2.9
	Kernel-5_35-4_79_2_152:4.12.2.11
	Kernel-5_35-4_79_2_151:4.12.2.10
	Kernel-5_35-4_79_2_147_2_8:4.12.2.9
	Kernel-5_35-4_79_2_147_2_7:4.12.2.9
	Kernel-5_35-4_79_2_150:4.12.2.9
	Kernel-5_35-4_79_2_147_2_6:4.12.2.9
	Kernel-5_35-4_79_2_147_2_5:4.12.2.9
	Kernel-5_35-4_79_2_149:4.12.2.9
	Kernel-5_35-4_79_2_147_2_4:4.12.2.9
	Kernel-5_35-4_79_2_147_2_3:4.12.2.9
	Kernel-5_35-4_79_2_148:4.12.2.9
	Kernel-5_35-4_79_2_147_2_2:4.12.2.9
	Kernel-5_35-4_79_2_147_2_1:4.12.2.9
	RPi:4.12.2.9.0.2
	RPi_bp:4.12.2.9
	Kernel-5_35-4_79_2_98_2_52_2_1:4.12.2.5.2.2
	alees_Kernel_dev:4.12.2.5.2.2.0.2
	alees_Kernel_dev_bp:4.12.2.5.2.2
	Kernel-5_35-4_79_2_147:4.12.2.9
	Kernel-5_35-4_79_2_146:4.12.2.9
	Kernel-5_35-4_79_2_145:4.12.2.9
	Kernel-5_35-4_79_2_144:4.12.2.9
	Kernel-5_35-4_79_2_143:4.12.2.9
	Kernel-5_35-4_79_2_142:4.12.2.9
	Kernel-5_35-4_79_2_141:4.12.2.9
	Kernel-5_35-4_79_2_140:4.12.2.8
	Kernel-5_35-4_79_2_139:4.12.2.8
	Kernel-5_35-4_79_2_138:4.12.2.8
	Kernel-5_35-4_79_2_137:4.12.2.8
	Kernel-5_35-4_79_2_136:4.12.2.8
	Kernel-5_35-4_79_2_135:4.12.2.8
	Kernel-5_35-4_79_2_134:4.12.2.8
	Kernel-5_35-4_79_2_133:4.12.2.8
	Kernel-5_35-4_79_2_132:4.12.2.8
	Kernel-5_35-4_79_2_131:4.12.2.8
	Kernel-5_35-4_79_2_130:4.12.2.8
	Kernel-5_35-4_79_2_129:4.12.2.8
	Kernel-5_35-4_79_2_128:4.12.2.8
	Kernel-5_35-4_79_2_127:4.12.2.8
	Kernel-5_35-4_79_2_126:4.12.2.8
	Kernel-5_35-4_79_2_125:4.12.2.8
	Kernel-5_35-4_79_2_124:4.12.2.8
	Kernel-5_35-4_79_2_123:4.12.2.7
	Cortex_merge:4.12.2.5.2.3
	Kernel-5_35-4_79_2_122:4.12.2.6
	Kernel-5_35-4_79_2_98_2_54:4.12.2.5.2.3
	Kernel-5_35-4_79_2_98_2_53:4.12.2.5.2.3
	Kernel-5_35-4_79_2_98_2_52:4.12.2.5.2.2
	Kernel-5_35-4_79_2_98_2_51:4.12.2.5.2.2
	Kernel-5_35-4_79_2_98_2_50:4.12.2.5.2.2
	Kernel-5_35-4_79_2_98_2_49:4.12.2.5.2.2
	Kernel-5_35-4_79_2_98_2_48:4.12.2.5.2.2
	Kernel-5_35-4_79_2_121:4.12.2.6
	Kernel-5_35-4_79_2_98_2_47:4.12.2.5.2.1
	Kernel-5_35-4_79_2_120:4.12.2.6
	Kernel-5_35-4_79_2_98_2_46:4.12.2.5.2.1
	Kernel-5_35-4_79_2_119:4.12.2.6
	Kernel-5_35-4_79_2_98_2_45:4.12.2.5.2.1
	Kernel-5_35-4_79_2_98_2_44:4.12.2.5.2.1
	Kernel-5_35-4_79_2_118:4.12.2.6
	Kernel-5_35-4_79_2_98_2_43:4.12.2.5.2.1
	Kernel-5_35-4_79_2_117:4.12.2.6
	Kernel-5_35-4_79_2_116:4.12.2.6
	Kernel-5_35-4_79_2_98_2_42:4.12.2.5.2.1
	Kernel-5_35-4_79_2_115:4.12.2.6
	Kernel-5_35-4_79_2_98_2_41:4.12.2.5.2.1
	Kernel-5_35-4_79_2_98_2_40:4.12.2.5
	Kernel-5_35-4_79_2_114:4.12.2.5
	Kernel-5_35-4_79_2_98_2_39:4.12.2.5
	Kernel-5_35-4_79_2_98_2_38:4.12.2.5
	Kernel-5_35-4_79_2_113:4.12.2.5
	Kernel-5_35-4_79_2_112:4.12.2.5
	Kernel-5_35-4_79_2_98_2_37:4.12.2.5
	Kernel-5_35-4_79_2_98_2_36:4.12.2.5
	Kernel-5_35-4_79_2_98_2_35:4.12.2.5
	Kernel-5_35-4_79_2_98_2_34:4.12.2.5
	Kernel-5_35-4_79_2_98_2_33:4.12.2.5
	Kernel-5_35-4_79_2_98_2_32:4.12.2.5
	Kernel-5_35-4_79_2_98_2_31:4.12.2.5
	Kernel-5_35-4_79_2_98_2_30:4.12.2.5
	Kernel-5_35-4_79_2_98_2_29:4.12.2.5
	Kernel-5_35-4_79_2_98_2_28:4.12.2.5
	Kernel-5_35-4_79_2_98_2_27:4.12.2.5
	Kernel-5_35-4_79_2_98_2_26:4.12.2.5
	Kernel-5_35-4_79_2_111:4.12.2.5
	Kernel-5_35-4_79_2_98_2_25:4.12.2.5
	Kernel-5_35-4_79_2_98_2_24:4.12.2.5
	Kernel-5_35-4_79_2_98_2_23:4.12.2.5
	Kernel-5_35-4_79_2_110:4.12.2.5
	Kernel-5_35-4_79_2_98_2_22:4.12.2.5
	Kernel-5_35-4_79_2_109:4.12.2.5
	Kernel-5_35-4_79_2_98_2_21:4.12.2.5
	Kernel-5_35-4_79_2_98_2_20:4.12.2.5
	Kernel-5_35-4_79_2_108:4.12.2.5
	Kernel-5_35-4_79_2_107:4.12.2.5
	Kernel-5_35-4_79_2_98_2_19:4.12.2.5
	Kernel-5_35-4_79_2_98_2_18:4.12.2.5
	Kernel-5_35-4_79_2_98_2_17:4.12.2.5
	Kernel-5_35-4_79_2_98_2_16:4.12.2.5
	Kernel-5_35-4_79_2_98_2_15:4.12.2.5
	Kernel-5_35-4_79_2_106:4.12.2.5
	Kernel-5_35-4_79_2_105:4.12.2.5
	Kernel-5_35-4_79_2_104:4.12.2.5
	Kernel-5_35-4_79_2_98_2_14:4.12.2.5
	Kernel-5_35-4_79_2_98_2_13:4.12.2.5
	Kernel-5_35-4_79_2_98_2_12:4.12.2.5
	Kernel-5_35-4_79_2_98_2_11:4.12.2.5
	Kernel-5_35-4_79_2_98_2_10:4.12.2.5
	Kernel-5_35-4_79_2_98_2_9:4.12.2.5
	Kernel-5_35-4_79_2_103:4.12.2.5
	Kernel-5_35-4_79_2_102:4.12.2.5
	Kernel-5_35-4_79_2_98_2_8:4.12.2.5
	Kernel-5_35-4_79_2_98_2_7:4.12.2.5
	Kernel-5_35-4_79_2_98_2_6:4.12.2.5
	Kernel-5_35-4_79_2_98_2_5:4.12.2.5
	Kernel-5_35-4_79_2_98_2_4:4.12.2.5
	Kernel-5_35-4_79_2_101:4.12.2.5
	Kernel-5_35-4_79_2_100:4.12.2.5
	Kernel-5_35-4_79_2_99:4.12.2.5
	Kernel-5_35-4_79_2_98_2_3:4.12.2.5
	Kernel-5_35-4_79_2_98_2_2:4.12.2.5
	Kernel-5_35-4_79_2_98_2_1:4.12.2.5
	Cortex:4.12.2.5.0.2
	Cortex_bp:4.12.2.5
	Kernel-5_35-4_79_2_98:4.12.2.5
	Kernel-5_35-4_79_2_97:4.12.2.5
	Kernel-5_35-4_79_2_96:4.12.2.5
	Kernel-5_35-4_79_2_95:4.12.2.5
	Kernel-5_35-4_79_2_94:4.12.2.5
	Kernel-5_35-4_79_2_93:4.12.2.5
	Kernel-5_35-4_79_2_92:4.12.2.5
	Kernel-5_35-4_79_2_91:4.12.2.5
	Kernel-5_35-4_79_2_90:4.12.2.5
	Kernel-5_35-4_79_2_89:4.12.2.5
	Kernel-5_35-4_79_2_88:4.12.2.5
	Kernel-5_35-4_79_2_87:4.12.2.5
	Kernel-5_35-4_79_2_86:4.12.2.5
	Kernel-5_35-4_79_2_85:4.12.2.5
	Kernel-5_35-4_79_2_84:4.12.2.5
	Kernel-5_35-4_79_2_83:4.12.2.5
	Kernel-5_35-4_79_2_82:4.12.2.5
	Kernel-5_35-4_79_2_81:4.12.2.5
	Kernel-5_35-4_79_2_80:4.12.2.5
	Kernel-5_35-4_79_2_79:4.12.2.5
	Kernel-5_35-4_79_2_78:4.12.2.5
	Kernel-5_35-4_79_2_77:4.12.2.5
	RO_5_07:4.12.2.5
	Kernel-5_35-4_79_2_76:4.12.2.5
	Kernel-5_35-4_79_2_75:4.12.2.5
	Kernel-5_35-4_79_2_74:4.12.2.5
	Kernel-5_35-4_79_2_73:4.12.2.5
	Kernel-5_35-4_79_2_72:4.12.2.5
	Kernel-5_35-4_79_2_71:4.12.2.5
	Kernel-5_35-4_79_2_70:4.12.2.5
	Kernel-5_35-4_79_2_69:4.12.2.4
	Kernel-5_35-4_79_2_68:4.12.2.4
	Kernel-5_35-4_79_2_67:4.12.2.4
	Kernel-5_35-4_79_2_66:4.12.2.4
	Kernel-5_35-4_79_2_65:4.12.2.4
	Kernel-5_35-4_79_2_64:4.12.2.4
	Kernel-5_35-4_79_2_63:4.12.2.4
	Kernel-5_35-4_79_2_62:4.12.2.4
	Kernel-5_35-4_79_2_61:4.12.2.4
	Kernel-5_35-4_79_2_59:4.12.2.4
	Kernel-5_35-4_79_2_58:4.12.2.4
	Kernel-5_35-4_79_2_57:4.12.2.4
	Kernel-5_35-4_79_2_56:4.12.2.4
	Kernel-5_35-4_79_2_55:4.12.2.4
	Kernel-5_35-4_79_2_54:4.12.2.4
	Kernel-5_35-4_79_2_53:4.12.2.4
	Kernel-5_35-4_79_2_52:4.12.2.4
	Kernel-5_35-4_79_2_51:4.12.2.4
	Kernel-5_35-4_79_2_50:4.12.2.4
	Kernel-5_35-4_79_2_49:4.12.2.4
	Kernel-5_35-4_79_2_48:4.12.2.4
	Kernel-5_47:4.12
	Kernel-5_46-4_90_2_1:4.12
	nbingham_Kernel_FastNC_dev_bp:4.12
	nbingham_Kernel_FastNC_dev:4.12.0.4
	Kernel-5_46:4.12
	Kernel-5_45:4.12
	Kernel-5_35-4_79_2_47:4.12.2.4
	Kernel-5_35-4_79_2_46:4.12.2.4
	Kernel-5_35-4_79_2_45:4.12.2.4
	Kernel-5_35-4_79_2_44:4.12.2.4
	Kernel-5_35-4_79_2_25_2_2:4.12.2.4
	Kernel-5_35-4_79_2_43:4.12.2.4
	Kernel-5_35-4_79_2_42:4.12.2.4
	Kernel-5_35-4_79_2_41:4.12.2.4
	Kernel-5_35-4_79_2_40:4.12.2.4
	Kernel-5_35-4_79_2_39:4.12.2.4
	Kernel-5_35-4_79_2_38:4.12.2.4
	Kernel-5_35-4_79_2_37:4.12.2.4
	Kernel-5_35-4_79_2_36:4.12.2.4
	Kernel-5_35-4_79_2_35:4.12.2.4
	Kernel-5_35-4_79_2_34:4.12.2.4
	Kernel-5_35-4_79_2_33:4.12.2.4
	Kernel-5_35-4_79_2_32:4.12.2.4
	Kernel-5_44:4.12
	Kernel-5_35-4_79_2_25_2_1:4.12.2.4
	Kernel-5_43:4.12
	Kernel-5_35-4_79_2_31:4.12.2.4
	Kernel-5_35-4_79_2_30:4.12.2.4
	Kernel-5_35-4_79_2_29:4.12.2.4
	Kernel-5_35-4_79_2_28:4.12.2.4
	Kernel-5_35-4_79_2_27:4.12.2.4
	Kernel-5_35-4_79_2_26:4.12.2.4
	Kernel-5_42:4.12
	Kernel-5_41:4.12
	Kernel-5_40:4.12
	Kernel-5_35-4_79_2_25:4.12.2.4
	Kernel-5_35-4_79_2_24:4.12.2.4
	Kernel-5_35-4_79_2_23:4.12.2.4
	Kernel-5_35-4_79_2_22:4.12.2.4
	Kernel-5_35-4_79_2_21:4.12.2.4
	Kernel-5_35-4_79_2_20:4.12.2.4
	Kernel-5_35-4_79_2_19:4.12.2.4
	Kernel-5_35-4_79_2_18:4.12.2.4
	Kernel-5_35-4_79_2_17:4.12.2.4
	Kernel-5_35-4_79_2_16:4.12.2.4
	Kernel-5_35-4_79_2_15:4.12.2.4
	Kernel-5_35-4_79_2_14:4.12.2.4
	Kernel-5_39:4.12
	Kernel-5_13-4_52_2_1:4.9
	Bethany:4.9.0.2
	Kernel-5_38:4.12
	Kernel-5_35-4_79_2_13:4.12.2.4
	Kernel-5_35-4_79_2_12:4.12.2.3
	Kernel-5_35-4_79_2_11:4.12.2.3
	Kernel-5_37:4.12
	Kernel-5_35-4_79_2_10:4.12.2.3
	Kernel-5_35-4_79_2_9:4.12.2.3
	Kernel-5_36:4.12
	Kernel-5_35-4_79_2_8:4.12.2.3
	Kernel-5_35-4_79_2_7:4.12.2.2
	Kernel-5_35-4_79_2_6:4.12.2.2
	Kernel-5_35-4_79_2_5:4.12.2.2
	Kernel-5_35-4_79_2_4:4.12.2.2
	Kernel-5_35-4_79_2_3:4.12.2.2
	Kernel-5_35-4_79_2_2:4.12.2.1
	dellis_autobuild_BaseSW:4.12
	Kernel-5_35-4_79_2_1:4.12.2.1
	HAL:4.12.0.2
	Kernel-5_35:4.12
	Kernel-5_34:4.12
	Kernel-5_33:4.12
	Kernel-5_32:4.12
	Kernel-5_31:4.11
	Kernel-5_30:4.11
	Kernel-5_29:4.11
	Kernel-5_28:4.11
	Kernel-5_27:4.11
	Kernel-5_26:4.11
	Kernel-5_25:4.11
	Kernel-5_24:4.11
	Kernel-5_23:4.10
	Kernel-5_22:4.9
	sbrodie_sedwards_16Mar2000:4.9
	Kernel-5_21:4.9
	Kernel-5_20:4.9
	Kernel-5_19:4.9
	Kernel-5_18:4.9
	Kernel-5_17:4.9
	Kernel-5_16:4.9
	Kernel-5_15:4.9
	Kernel-5_14:4.9
	Kernel-5_13:4.9
	Kernel-5_12:4.9
	Kernel-5_11:4.9
	Kernel-5_10:4.9
	Kernel-5_09:4.9
	Kernel-5_08:4.9
	Kernel-5_07:4.9
	Kernel-5_06:4.8
	Kernel-5_05:4.8
	Kernel-5_04:4.8
	Kernel-5_03:4.8
	Kernel-5_02:4.8
	Kernel-5_01:4.8
	Kernel-5_00:4.8
	Kernel-4_99:4.8
	Kernel-4_98:4.8
	Kernel-4_97:4.8
	Kernel-4_96:4.7
	Kernel-4_95:4.7
	Kernel-4_94:4.7
	Kernel-4_93:4.6
	Kernel-4_92:4.6
	Kernel-4_91:4.6
	Kernel-4_90:4.6
	dcotton_autobuild_BaseSW:4.12
	Kernel-4_89:4.6
	Kernel-4_88:4.6
	Kernel-4_87:4.6
	Kernel-4_86:4.6
	Kernel-4_85:4.6
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.1.2.1
	Kernel-4_84:4.6
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.1.2.1
	Ursula_RiscPC_bp:4.2.2.1
	Kernel-4_83:4.6
	Kernel-4_82:4.6
	Kernel-4_81:4.6
	Kernel-4_80:4.6
	Kernel-4_79:4.6
	Kernel-4_78:4.6
	Kernel-4_77:4.6
	Kernel-4_76:4.6
	Kernel-4_75:4.6
	Kernel-4_74:4.6
	Kernel-4_73:4.6
	Kernel-4_72:4.6
	Kernel-4_71:4.6
	Kernel-4_70:4.5
	Kernel-4_69:4.5
	Kernel-4_68:4.5
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.2
	Kernel-4_63-1_1_2_4:4.1.7.2
	Kernel-4_67:4.4
	Kernel-4_66:4.3
	Kernel-4_63-1_1_2_3:4.1.7.2
	Kernel-4_65:4.3
	Ursula_merge:4.2
	Kernel-4_64:4.3
	mstphens_Kernel-3_81:4.2.2.2
	Kernel-4_63-1_1_2_2:4.1.7.2
	nicke_Kernel_4_62:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	nturton_v459:4.1.7.2
	nturton_v460:4.1.7.2
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	mstphens_Kernel-3_80:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	afrost_Boca-1_2-Beta:4.1.7.2
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.2
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.16
date	2018.03.25.21.01.03;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	gUttU6y9LCksLSvA;

4.15
date	2017.09.09.10.35.45;	author rool;	state Exp;
branches;
next	4.14;
commitid	SuZJGVb4fAmIDv6A;

4.14
date	2016.06.30.20.59.50;	author jlee;	state Exp;
branches
	4.14.2.1;
next	4.13;
commitid	skOEjp3ipLHx6xcz;

4.13
date	2016.06.30.20.08.16;	author jlee;	state Exp;
branches;
next	4.12;
commitid	IWoXxARWeuLDOwcz;

4.12
date	2000.08.18.09.31.45;	author sbrodie;	state Exp;
branches
	4.12.2.1;
next	4.11;

4.11
date	2000.04.13.10.37.29;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	2000.04.04.14.27.37;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	99.11.02.15.34.38;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.10.14.13.23.23;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.10.13.16.21.29;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.02.25.15.58.07;	author nturton;	state Exp;
branches;
next	4.5;

4.5
date	98.12.16.13.14.59;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.10.30.18.07.02;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.09.30.08.42.47;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.07.26;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.30;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.14.2.1
date	2017.09.10.11.27.25;	author jlee;	state Exp;
branches;
next	4.14.2.2;
commitid	EGooxXrB27MqTD6A;

4.14.2.2
date	2018.05.14.19.33.46;	author jlee;	state Exp;
branches;
next	;
commitid	wrVtYH84nAz1GiCA;

4.12.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.12.2.2;

4.12.2.2
date	2000.10.03.12.05.59;	author mstephen;	state Exp;
branches;
next	4.12.2.3;

4.12.2.3
date	2000.10.05.16.46.36;	author dellis;	state Exp;
branches;
next	4.12.2.4;

4.12.2.4
date	2000.11.10.15.51.35;	author kbracey;	state Exp;
branches;
next	4.12.2.5;

4.12.2.5
date	2004.06.21.17.37.30;	author bavison;	state Exp;
branches
	4.12.2.5.2.1;
next	4.12.2.6;

4.12.2.6
date	2011.07.31.13.48.16;	author jlee;	state Exp;
branches;
next	4.12.2.7;
commitid	o0Go7NdMMK4UrGtv;

4.12.2.7
date	2011.11.26.21.11.24;	author jlee;	state Exp;
branches;
next	4.12.2.8;
commitid	cI3W0zbtALQG6TIv;

4.12.2.8
date	2011.11.27.11.48.16;	author rsprowson;	state Exp;
branches;
next	4.12.2.9;
commitid	OFgqaKhOb6swXXIv;

4.12.2.9
date	2012.03.19.08.10.42;	author rsprowson;	state Exp;
branches
	4.12.2.9.2.1;
next	4.12.2.10;
commitid	v7TP289ZDzgL7tXv;

4.12.2.10
date	2012.05.26.09.00.32;	author rsprowson;	state Exp;
branches;
next	4.12.2.11;
commitid	EMsCe1GQBPXgdd6w;

4.12.2.11
date	2012.06.04.23.10.38;	author jlee;	state Exp;
branches;
next	4.12.2.12;
commitid	Fel7FC5bdci2Dr7w;

4.12.2.12
date	2012.10.28.16.51.49;	author rsprowson;	state Exp;
branches;
next	4.12.2.13;
commitid	ruXZqdTJKJ85Qaqw;

4.12.2.13
date	2012.12.05.01.16.22;	author jlee;	state Exp;
branches;
next	4.12.2.14;
commitid	jNXy5BkvBl5srYuw;

4.12.2.14
date	2013.03.24.10.16.27;	author rsprowson;	state Exp;
branches;
next	4.12.2.15;
commitid	UvakvUQoRMnwV1Jw;

4.12.2.15
date	2013.11.20.20.25.01;	author rsprowson;	state Exp;
branches;
next	4.12.2.16;
commitid	mPgx586MWbpUx3ex;

4.12.2.16
date	2013.12.15.21.34.07;	author jlee;	state Exp;
branches;
next	4.12.2.17;
commitid	KwuK29hKRyXO7hhx;

4.12.2.17
date	2014.11.13.22.19.19;	author rsprowson;	state Exp;
branches;
next	4.12.2.18;
commitid	w8sxKkSQnrGJF4Yx;

4.12.2.18
date	2015.03.29.16.17.34;	author jlee;	state Exp;
branches;
next	4.12.2.19;
commitid	CkLUvkbu9J2Eiwfy;

4.12.2.19
date	2016.04.05.19.36.38;	author jlee;	state Exp;
branches;
next	;
commitid	8RLqvkae1X7wpt1z;

4.12.2.5.2.1
date	2011.07.31.13.39.22;	author jlee;	state Exp;
branches;
next	4.12.2.5.2.2;
commitid	tnhfpNorgEFQoGtv;

4.12.2.5.2.2
date	2011.08.08.23.28.34;	author jlee;	state Exp;
branches;
next	4.12.2.5.2.3;
commitid	D7rzILnwRRSXoLuv;

4.12.2.5.2.3
date	2011.09.24.19.55.56;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.12.2.9.2.1
date	2012.09.18.15.50.07;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.2.2.1
date	97.09.09.13.34.12;	author mstphens;	state Exp;
branches
	4.2.2.1.2.1;
next	4.2.2.2;

4.2.2.2
date	98.09.24.13.17.36;	author mstphens;	state Exp;
branches;
next	;

4.2.2.1.2.1
date	98.11.23.14.59.32;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.30;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.01.59;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.26;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.15;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.18.13.39.03;	author scormie;	state Exp;
branches;
next	;


desc
@@


4.16
log
@Don't bother setting up R12 to point at IOC
This is now a HAL only kernel, and 0x3200000 is most likely somewhere in RAM.
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.PMF.osbyte
; New version of OSBYTE which claims the ByteV(ector) properly
; PMF 18/9/86
; Updates:
; Kernel
; Version  Date        Who  Why
; 2.01     15-June-90  JSR  Change OS_Byte 124/125/126 to update the CallBack_Flag byte
;                            correctly, rather than setting it to 1. The bug caused vector
;                            callbacks to be delayed over much when escape was pressed.
; ????     08-Feb-95   WT   Change OS_Byte 106 to support the new cursor storage method
;                            introduced for Stork LCD support.

OsbyteLowLimit * &6A    ; osbytes lower than this get Y set to 0
OsbyteVeryLow  * &1A    ; osbytes lower than this are all recognised
OsbyteKeyStatus * &CA   ; only OS_Byte variable which isn't pure any more!

; *****************************************************************************

        MACRO
        MyOsbyte $cond
        B$cond  GoMyOsbyte
        MEND

        MACRO
        MyOsWord $cond
        B$cond  GoMyOsword
        MEND

        MACRO
        Unused  $cond
        MOV$cond PC, R14 ; just return and let the next person have a go
        MEND

        MACRO
        ByteReturnV $cond
        ASSERT  "$cond"="" :LOR: "$cond"="VS"

        [ "$cond"=""
        LDRVC   R0,[R13]
        ]
        ADD$cond R13,R13,#4
        LDR$cond R3,[R13],#8 ; pull r3, junk r14
        LDR$cond PC,[R13],#4
        
        MEND

; Main OSbyte entry point
; R0,R1,R2 are parameters

OsByte
        Push    "R0, R3, R14"
        BL      OsByteGo                        ; Call the subsid entry pt.
        Pull    "R0,R3"
        Push    "R0-R4"
        LDMIA   R13, {R2-R4}                    ; R2=A, R3=X, R4=Y
        MOV     R1, #Service_UKByte             ; osbyte service reason
        BL      Issue_Service
        TEQ     R1, #0
        STMEQIA R13, {R2-R4}                    ; if claimed, then update
                                                ; returned R0-R2
        CLRPSR  V_bit, R3                       ; clear V flag

        Pull    R0
        ADRNE   R0, ErrorBlock_BadCommand       ; not claimed, R0 -> error
      [ International
        BLNE    TranslateError
      ]
        SWINE   XOS_GenerateError               ; set V if not claimed
        Pull    "R1-R4"
        ADD     SP,SP,#4
        Pull    "PC"

        MakeErrorBlock BadCommand

GoMyOsbyte
        CLRPSR  V_bit, R3
        Pull    "R0,R3"                 ; pull the world AND the PC to return
        ADD     SP,SP,#4
        Pull    "PC"


; *****************************************************************************

OsByteGo ROUT
        AND     R0, R0, #&FF            ; no funny business!
        SUBS    R3, R0, #OsbyteLowLimit ; is it a low one ?
        BCS     HiOsbyte
        MOV     R2, #0                  ; lo one, so set Y to 0
        CMP     R0, #OsbyteVeryLow      ; is it one we recognise ?
10
        ADDCC   PC, PC, R0, LSL #2      ; then go thru despatch table
        B       TryInternational        ; else issue unknown osbyte service
20
        ASSERT  %BT20-%BT10 = 8

        BAL     Osbyte00
        BAL     Osbyte01
        BAL     Osbyte02
        BAL     Osbyte03
        BAL     Osbyte04
        BAL     Osbyte05
        BAL     Osbyte06
        BAL     Osbyte07

        BAL     Osbyte08
        BAL     Osbyte09
        BAL     Osbyte0A
        BAL     Osbyte0B
        BAL     Osbyte0C
        BAL     Osbyte0D
        BAL     Osbyte0E
        BAL     Osbyte0F

        BAL     Osbyte10
        BAL     Osbyte11
        BAL     Osbyte12
        BAL     Osbyte13
        BAL     Osbyte14
        BAL     Osbyte15
        BAL     Osbyte16
        BAL     Osbyte17

        BAL     Osbyte18
        BAL     Osbyte19

HiOsbyte
        CMP     R0, #OsByte_BaseOfOSByteVarTable ; is it a variable ?
30
        ADDCC   PC, PC, R3, LSL #2
        B       DoOsbyteVar             ; yes, then do variable mangling
40
        ASSERT  %BT40-%BT30=8

        BAL     Osbyte6A
        BAL     Osbyte6B
        BAL     Osbyte6C
        BAL     Osbyte6D
        BAL     Osbyte6E
        BAL     Osbyte6F

        BAL     Osbyte70
        BAL     Osbyte71
        BAL     Osbyte72
        BAL     Osbyte73
        BAL     Osbyte74
        BAL     Osbyte75
        BAL     Osbyte76
        BAL     Osbyte77

        BAL     Osbyte78
        BAL     Osbyte79
        BAL     Osbyte7A
        BAL     Osbyte7B
        BAL     Osbyte7C
        BAL     Osbyte7D
        BAL     Osbyte7E
        BAL     Osbyte7F

        BAL     Osbyte80
        BAL     Osbyte81
        BAL     Osbyte82
        BAL     Osbyte83
        BAL     Osbyte84
        BAL     Osbyte85
        BAL     Osbyte86
        BAL     Osbyte87

        BAL     Osbyte88
        BAL     Osbyte89
        BAL     Osbyte8A
        BAL     Osbyte8B
        BAL     Osbyte8C
        BAL     Osbyte8D
        BAL     Osbyte8E
        BAL     Osbyte8F

        BAL     Osbyte90
        BAL     Osbyte91
        BAL     Osbyte92
        BAL     Osbyte93
        BAL     Osbyte94
        BAL     Osbyte95
        BAL     Osbyte96
        BAL     Osbyte97

        BAL     Osbyte98
        BAL     Osbyte99
        BAL     Osbyte9A
        BAL     Osbyte9B
        BAL     Osbyte9C
        BAL     Osbyte9D
        BAL     Osbyte9E
        BAL     Osbyte9F

        BAL     OsbyteA0
        BAL     OsbyteA1
        BAL     OsbyteA2
        BAL     OsbyteA3
        BAL     OsbyteA4
        BAL     OsbyteA5

TryInternational                        ; special ones in the middle
        TEQ     R0, #OsByte_Country
        BEQ     DoOsbyteSetCountry
        TEQ     R0, #OsByte_Alphabet
        BEQ     DoOsbyteSetAlphKey
        MOV     PC, R14

; *****************************************************************************

; The Osbyte routines themselves


; Mos version number and title string
; R1 = 0 -> give an error with and string MosTitle
; R1 <>0 -> RETURN with R1 = MosVer

; R2 is Preserved

Osbyte00 ROUT
        TEQ     R1, #0
        MOVNE   R1, #MosVer
        MyOsbyte NE
      [ UseNewFX0Error
        LDR     R0, =NewFX0Error
        LDR     LR, [R0]
        CMP     LR, #0
        ADREQ   R0, FX0Error ; Fall back to hardcoded string if new one isn't ready yet
      |
        ADR     R0, FX0Error
      ]
        SWI     XOS_GenerateError
        ByteReturnV

      [ UseNewFX0Error
InitNewFX0Error ROUT
        Push    "r0-r4,lr"
        MOV     r0, #ExtROMFooter_BuildDate
        BL      ExtendedROMFooter_FindTag
        CMP     r0, #0
        BEQ     %FT10
        MOV     r1, r0
        MOV     r0, #-1
        LDR     r2, =NewFX0Error+4
        MOV     r3, #?NewFX0Error - 4
        ADR     r4, NewFX0ErrorFormat
        SWI     XTerritory_ConvertDateAndTime
        ; Fill in error number on success
        LDRVC   r2, =NewFX0Error
        MOVVC   r3, #ErrorNumber_FX0
        STRVC   r3, [r2]
10
        Pull    "r0-r4,pc"
      ]

FX0Error
        &       ErrorNumber_FX0
        =       "$SystemName $VersionNo",0
      [ UseNewFX0Error
NewFX0ErrorFormat
        =       "$SystemName $VString (%dy %m3 %ce%yr)",0
      ]
        ALIGN

; *****************************************************************************

; Write User Flag
Osbyte01
V2B156
        ADD     R0, R0, #&F0            ; convert 1,5,6 to &F1,&F5,&F6
        B       DoOsbyteVar

; Select input stream
Osbyte02 ROUT
        AND     R0, R1, #1              ; new buffer id
        TEQ     R1, #0                  ; 0 => disable RXI
        Push    "r0"
        BNE     %FT10                   ; [enabling serial]

; disable serial by closing stream

        LDRB    r1, SerialInHandle
        TEQ     r1, #0
        MOVNE   r0, #0                  ; close file if handle non-zero
        STRNEB  r0, SerialInHandle      ; zero handle first
        SWINE   XOS_Find
        B       %FT20

; enable serial by opening stream

10
        LDRB    r0, SerialInHandle
        TEQ     r0, #0                  ; if a stream open already
        BNE     %FT20                   ; then skip

        SUB     sp, sp, #64
        MOV     r3, sp
        ADR     r1, SerialInFilename

12
        LDRB    r0, [r1], #1
        CMP     r0, #0
        STRNEB  r0, [r3], #1
        BNE     %BT12

        MOV     r0, #SerialOp_GetDeviceName
        SWI     XOS_SerialOp
        ; r1 should now be correct device name or preserved on error
        ; i.e. left pointing at our default name
        ADD     lr, sp, #63
14
        SUBS    r0, r1, lr                      ; Basic buffer overflow check
        LDRNEB  r0, [r1], #1
        CMPNE   r0, #0
        STRB    r0, [r3], #1
        BNE     %BT14
        
        MOV     r0, #open_read + open_mustopen
        MOV     r1, sp                  ; open serial stream for input
        SWI     XOS_Find
        STRVCB  r0, SerialInHandle      ; if did open then store handle
                                        ; (may store same value if already open, but who cares?)
        ADD     sp, sp, #64
20
        Pull    "r0"
        LDRB    R1, InputStream         ; old input stream
        STRB    R0, InputStream
        MyOsbyte

        LTORG

SerialInFilename
        =       "Devices#Buffer1:$.", 0, "Serial", 0
        ALIGN

; Select output stream
Osbyte03

Osbyte04                                ; select cursor keys actions
V2B34
        ADD     R0, R0, #&E9            ; convert 3,4 to &EC,&ED
        B       DoOsbyteVar

; Write Printer driver type
Osbyte05 ROUT
        BL      MakePrinterDormant      ; for netprint
        SavePSR R14                     ; for restoring I afterwards
10
        CLRPSR  I_bit, R3
 [ InterruptDelay
        NOP
        NOP
        NOP
        NOP
        NOP
 ]
        RestPSR R14                     ; restore old I

        LDR     R3, =ZeroPage
        LDRB    R3, [R3, #ESC_Status]
        TST     R3, #&40
        MyOsbyte NE                     ; ESCAPE, so don't change

        LDR     R3, PrinterActive
        TEQ     R3, #0
        BNE     %BT10                   ; still active, then loop

; insert code here to notify UPTVEC of change

        B       V2B156                  ; R0 = 5, update variable

; Write Printer Ignore Character
Osbyte06
        STRB    R2, NoIgnore            ; (R2=0) allow chars to be ignored
        B       V2B156

; Write RS423 receive rate
; Write RS432 transmit rate
Osbyte07
Osbyte08
        SUB     r0, r0, #2              ; 7 -> 5; 8 -> 6
        SWI     XOS_SerialOp
        MyOsbyte

; Write First Flash Time
Osbyte09
        MOV     R2, #1
; and drop thru to ...

; Write Second Flash Time
Osbyte0A                                        ; (R2=0)
Osbyte910
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
        ADD     R2, R2, R0
      ]
        MOV     R0, R1                          ; new period
        LDRB    R1, [R2, #OsbyteVars + :INDEX: SpacPeriod] ; get old state
        STRB    R0, [R2, #OsbyteVars + :INDEX: SpacPeriod] ; store new

        LDRB    R3, FlashCount
        TEQ     R3, #0                          ; are we frozen ?
        MyOsbyte NE                             ; no, then finish

        STRB    R0, FlashCount                  ; kick the counter
        ASSERT  (ZeroPage :AND: 255) = 0
        STRB    R2, FlashState                  ; force new state

        VDWS    WsPtr

        TEQ     R2, #0
        BEQ     ForceSecondState

        Push    "R1,R2"
        BL      DoFirstFlash
        Pull    "R1,R2"
        MyOsbyte

ForceSecondState
        Push    "R1,R2"
        BL      DoSecondFlash
        Pull    "R1,R2"
        MyOsbyte


; Write Keyboard Delay
Osbyte0B
V2BBC
        ADD     R0, R0, #(&C4-&0B)
        B       DoOsbyteVar

; Write Keyboard Rate
Osbyte0C
        TEQ     R1, #0
        BNE     V2BBC
        CLRPSR  I_bit, R0       ; this may take some time
        BL      ReadKeyDefaults
        MyOsbyte

; *****************************************************************************

; Disable / Enable Events
; R1 = Event number. Decrement/Increment semaphore for this event

Osbyte0D ROUT
Osbyte0E ROUT
        CMP     R1, #32                 ; if illegal event number
        MOVCS   R2, #&FF                ; then return + say was enabled
        BCS     %FT10

        ADD     R3, WsPtr, #:INDEX: EventSemaphores
        LDRB    R2, [R3, R1]            ; get semaphore for this event

        CMP     R0, #13                 ; 13 => disable, 14 => enable
        SUBEQ   R0, R2, #1              ; decrement semaphore
        ADDNE   R0, R2, #1              ; increment semaphore

        CMP     R2, #&FF                ; Z=1 => already saturated, so don't store back
        STRNEB  R0, [R3, R1]
10
        MOV     R1, R2                  ; R1 = R2 = old semaphore
        MyOsbyte

; *****************************************************************************

; Flush Buffer
Osbyte0F ROUT
        TEQ     R1, #0
        BNE     FlushInput
        BL      FlushAll
        MyOsbyte

; flush all buffers

FlushAll
        Push    R14
        MOV     R1, #(NBuffers-1)
10
        BL      FlushThis
        SUBS    R1, R1, #1
        BPL     %BT10
        Pull    PC

; flush input buffer

FlushInput
        LDROSB  R1, InputStream         ; get buffer id of input stream
        BL      FlushThis
        MyOsbyte

; *****************************************************************************

; Clear out the softkeys
Osbyte12 ROUT
        MOV     R0, #0
        STRB    R0, SoftKeyLen          ; purge current expansion
        LDR     R11, =ZeroPage+KeyWorkSpace ; can corrupt R11
        Push    R4
        MOV     R1, #15
10
        MOV     R3, R1
        BL      SetupKeyName            ; exits with R0 -> SoftKeyName
        MOV     R2, #-1                 ; destroy variable
        MOV     R3, #0                  ; context pointer 0
        MOV     R4, #0                  ; type irrelevant
        SWI     XOS_SetVarVal           ; V will be set if not present
        SUBS    R1, R1, #1
        BPL     %BT10
        Pull    R4
        MyOsbyte

; *****************************************************************************

; Wait for Vsync

Osbyte13 ROUT

        MRS     R3, CPSR                ; Interrupts disabled at the moment
        LDRB    R2, CFStime

10
        ; bug fix for MED-03165. Having a DPMS-blanked screen stopped printing.
        ; The reason is that HSyncs stop and VSyncs stop as a consequence,
        ; but the Hourglass module uses this call to wait for the next VSync
        ; before animating the hourglass.
        ; When the screen is DPMS-blanked this osbyte will now return
        ; immediately. This is equivalent to the operation of the DPMSUtils
        ; module shipped with OS 3.50.

        VDWS    LR

        LDRB    R0, [LR,#ScreenBlankFlag]
        LDRB    R1, [LR,#ScreenBlankDPMSState]

        TEQ     R0, #0                  ; NE => blanked
        TSTNE   R1, #1                  ; NE => blanked and DPMS turned off HSyncs
        MyOsbyte NE                     ; if true exit immediately

        ; Also, exit now if we don't have a driver active
        LDR     R0, [LR,#CurrentGraphicsVDriver]
        CMP     R0, #GraphicsVInvalid
        MyOsbyte EQ

; It is actually better to call Idle with interrupts disabled as it stops the interrupt
; going off on the way through the SWI dispatch and accidentally waiting for the next
; interrupt... The Idle will return when an interrupt is pending - it will be handled below
        LDR     R0, =ZeroPage
        LDRB    R0, [R0, #PortableFlags]
        TST     R0, #PortableFeature_Idle
        SWINE   XPortable_Idle

        BIC     R1, R3, #I32_bit
        MSR     CPSR_c, R1              ; CLI

   ;StrongARM core will not see interrupt unless disable is cleared for at least 5 cycles,
   ;in order to fill synchroniser pipe
 [ InterruptDelay
        NOP
        NOP
        NOP
        NOP
        NOP
 ]
        MSR     CPSR_c, R3              ; SEI
        LDRB    R1, CFStime
        TEQ     R1, R2
        MyOsbyte NE
        B       %BT10

; *****************************************************************************

; Restore font definitions
Osbyte14
        MOV     R1, #1                  ; start at character 1*32
        MOV     R2, #3                  ; do 3 pages
        B       ResetPartFont

; *****************************************************************************

; Flush Selected Buffer
Osbyte15        ROUT
;
; TMD 24-Apr-92: Don't check buffer number, as this prevents the flushing
; of buffer manager buffers.
;
;        CMP     R1, #NBuffers
;        BCS     %FT10                   ; invalid buffer number
        BL      FlushThis
;10
        MyOsbyte


FlushThis

; code inserted here to zero PrinterActive iff you are flushing the printer
; buffer and the print destination is not a stream one

        CMP     R1, #Buff_RS423Out      ; is it an input buffer ? (not mouse)
        BCS     %FT20                   ; no, then branch

        MOV     R0, #0
        STRB    R0, SoftKeyLen          ; kill soft key expansion
        STRB    R0, VDUqueueItems       ; flush VDU queue
20
        SETV                            ; indicate purge not count
        B       CnpEntry

; Reset Group of font definitions
Osbyte19 ROUT
        CMP     R1, #8
        MyOsbyte CS                     ; not in range 0..7, ignore
        TEQ     R1, #0

        MOVEQ   R1, #1                  ; if 0 then start at 1*32, do 7 pages
        MOVEQ   R2, #7

        MOVNE   R2, #1                  ; else start at n*32, do 1 page
ResetPartFont

; first offer to International module

        Push    "R1, R2, R4, R5"
        MOV     R4, R1, LSL #5          ; R4 = start character
        ADD     R5, R4, R2, LSL #5      ; R5 = end character+1
        SUB     R5, R5, #1              ; R5 = end character
        LDRB    R3, Alphabet
        MOV     R2, #Inter_Define
        BL      OfferInternationalService
        Pull    "R1, R2, R4, R5"
        MyOsbyte EQ                     ; if claimed, don't use hard font

        ByteToNosbod DoResetFont
        MyOsbyte

; *****************************************************************************

; Set country number
; in:   R1 = country number

DoOsbyteSetCountry ROUT
        TEQ     R1, #&7F                ; if 127, just read country
        LDREQB  R1, Country
        MyOsbyte EQ

        BL      GetCountry
        Push    R4
        BL      ConvertCNoToANo         ; convert country no. to alphabet no.
        Pull    R4, NE
        MOVNE   R1, #0                  ; if not claimed, return with X=0
        MyOsbyte NE

; was claimed, so have country number in R1 and R3, alphabet no. in R4

        LDRB    R1, Country             ; save old country
        STRB    R3, Country             ; store new country
        STRB    R4, Alphabet            ; and new alphabet
        BL      NewKeyboard             ; R3=new keyboard, R4=alphabet for it
        BL      SetAlphabet
        Pull    R4
        MyOsbyte

SetAlphabet
        Push    "R1,R5,R14"
        MOV     R2, #Inter_Define       ; now redefine the chars
        MOV     R3, R4
        MOV     R4, #32
        MOV     R5, #255
        BL      OfferInternationalService
        Pull    "R1,R5,PC"

ConvertCNoToANo
        MOV     R3, R1                  ; put country no. in R3
        MOV     R2, #Inter_CNoToANo
OfferInternationalService
        Push    R14
        MOV     R1, #Service_International
        BL      Issue_Service
        TEQ     R1, #0                  ; set Z flag if claimed
        Pull    PC

; Notify keyboard handler of new keyboard

NewKeyboard
        Push    "R1,R4,R14"
        STRB    R3, Keyboard
        STRB    R4, KeyAlphabet
        MOV     R2, #Inter_Keyboard
        BL      OfferInternationalService
        Pull    "R1,R4,PC"

; *****************************************************************************

; Set keyboard/alphabet for a particular country

DoOsbyteSetAlphKey ROUT
        TST     R1, #&80                ; if set then setting keyboard
        BNE     %FT10                   ; [setting keyboard]

; setting alphabet

        TEQ     R1, #&7F                ; 127 => just read alphabet
        LDREQB  R1, Alphabet
        MyOsbyte EQ

; 20/8/87 added code to do setting of default alphabet

        BL      GetCountry
        Push    R4
        BL      ConvertCNoToANo         ; try to convert R1 to alphabet number
        MOVNE   R4, R3                  ; if failed, try without converting
        BL      SetAlphabet             ; try to set this alphabet
        Pull    R4
        MOVNE   R1, #0                  ; if not claimed, return with X=0
        MyOsbyte NE

        LDRB    R1, Alphabet
        STRB    R3, Alphabet
        MyOsbyte

; setting keyboard

10
        AND     R1, R1, #&7F
        TEQ     R1, #&7F                ; 127 => just read keyboard
        LDREQB  R1, Keyboard
        MyOsbyte EQ

        BL      GetCountry
        Push    R4
        BL      ConvertCNoToANo         ; validating country no.
        Pull    R4, NE
        MOVNE   R1, #0                  ; if not claimed, return with X=0
        MyOsbyte NE

        LDRB    R1, Keyboard            ; load old keyboard
        BL      NewKeyboard             ; R3=new keyboard, R4=alphabet for it
        Pull    R4
        MyOsbyte

; *****************************************************************************

; All osbytes from &1A to &69 are unused (apart from international ones!)

; End of unused block

; Write pointer shape number, mouse linkage
;
; R1 = 0        => pointer off
; R1 = 1..4     => use pointer shape 1..4, linked to mouse
; R1 = &81..&84 => use pointer shape 1..4, unlinked
;
Osbyte6A
        VDWS    R0
        LDRB    R3, [R0, #PointerShapeNumber]   ; get old shape number
        AND     R2, R1, #&7F                    ; allow 0..4, &80..&84
        CMP     R2, #4
        BHI     %FT90                           ; ignore change if too high

        TEQ     R1, R3
        BEQ     %FT90                           ; same as old

        STRB    R1, [R0, #PointerShapeNumber]   ; will take effect on next vsync (UpdatePointer)

90      MOV     R1, R3
        MyOsbyte

; Set vdu driver's screen number
Osbyte70
        ByteToNosbod DoSetDriverBank
        MyOsbyte

; Set displayed screen number
Osbyte71
        ByteToNosbod DoSetDisplayBank
        MyOsbyte

; *SHADOW
Osbyte72
        MOV     R0, #&EF                ; redirect to shadow variable
        MOV     R2, #0
        B       DoOsbyteVar

; *****************************************************************************

; Read VDU Status
Osbyte75
        Push    R2
        ByteToNosbod DoReadVDUStatus
        Pull    R2
        MyOsbyte

; Reflect Keyboard Status In LEDs
Osbyte76
        LDR     R11, =ZeroPage+KeyWorkSpace
        BL      UpdateLEDs
        MyOsbyte

; Write Keys Pressed Info
Osbyte78
        BL      WriteKeysDown
        MyOsbyte

; Perform Keyboard Scan from 15
Osbyte7A
        MOV     R1, #&0F
; and drop thru to ...

; Perform Keyboard Scan
Osbyte79
        BL      BBCScanKeys
        MyOsbyte

; Inform OS Printer Driver going Dormant
Osbyte7B
        BL      MakePrinterDormant
        ByteReturnV

; Clear Escape Condition
Osbyte7C
        BL      DoOsbyte7C
        MyOsbyte

; Set Escape Condition
Osbyte7D
        BL      DoOsbyte7D
        MyOsbyte

DoOsbyte7C
        Push    "R11, R14"
        MOV     R11, #0
        B       Osbyte7C7D

DoOsbyte7D
        Push    "R11, R14"
        MOV     R11, #&FF
Osbyte7C7D
        LDR     R12, =ZeroPage+EscHan_ws
        STRB    R11, [R12, #ESC_Status-EscHan_ws]   ; set escape flag
        MOV     R14, PC
        LDMIA   R12, {R12, PC}
Exit7D
        TEQ     R12, #1
        Pull    "R11, PC", NE

        MRS     R11, CPSR                       ; Preserve old processor state
        ORR     R12, R11, #SVC_mode             ; Switch to SVC mode preserving IRQ_bit
        MSR     CPSR_c, R12
        Push    R14                             ; Preserve SVC_R14
        SWI     XOS_SetCallBack
        Pull    R14                             ; Restore SVC_R14
        MSR     CPSR_c, R11                     ; Switch back to original mode, with V_bit intact from SWI

        Pull    "R11, PC"

; Acknowledge ESCAPE
Osbyte7E ROUT
        LDR     R3, =ZeroPage
        LDRB    R3, [R3, #ESC_Status]
        TST     R3, #&40
        BEQ     NoESCToAck                      ; escape flag clear

        LDRB    R0, ESCeffect
        TEQ     R0, #0
        BNE     NoESCToAck                      ; escape effects disabled

        CLRPSR  I_bit, R0               ; enable interrupts (doing SOUNDs and
                                        ; closing files may take some time!)

        SWI     XSound_QInit
        BVS     %FT99                           ; no noises anyway!
        LDR     R0, =&01010008                  ; channel 8, amplitude &101
        MOV     R1, #&00010000                  ; pitch 0, duration 1
10
        SWI     XSound_ControlPacked
        BVS     %FT99                           ; (R0 would be corrupted)
        SUB     R0, R0, #1                      ; decrement channel
        TST     R0, #&FF                        ; if channel <> 0 then loop
        BNE     %BT10
99
        MOV     R0, #0

        STRB    R0, PageModeLineCount           ; zero line count

        LDRB    R1, ExecFileH
        CMP     R1, #0                          ; is EXEC file open (and V:=0)
        STRNEB  R0, ExecFileH                   ; if so, zero handle and close
                                                ; (will enable IRQs for me)
        SWINE   XOS_Find                        ; (R0=0, R1=handle)
        ByteReturnV VS                          ; if error then bomb out

        BL      FlushAll

NoESCToAck
        BL      DoOsbyte7C
        ANDS    R1, R3, #&40                    ; set R1 to 0 if wasn't escape,
        MOVNE   R1, #&FF                        ; &FF if was
        MyOsbyte


; Check for EOF
Osbyte7F
        MOV     R0, #OSArgs_EOFCheck
        SWI     XOS_Args                        ; result comes back in R2
        MOV     R1, R2
        ByteReturnV

; *****************************************************************************

; Read ADC or buffer status
Osbyte80
        AND     R1, R1, #&FF            ; no funny business

        TST     R1, #&80                ; is it ADVAL(-n)
        BEQ     AdvalPositive           ; no, then do adval(+ve)
        EOR     R1, R1, #&FF            ; convert to buffer number
        CLC                             ; (C:=0 and V:=0)
        TEQ     R1, #Buff_Mouse         ; is it mouse (only input buf >= 2) ?
        CMPNE   R1, #Buff_RS423Out ; C=1 <=> output buffer, so count spaces
                                        ; V=0, so will do count not purge

        ADR     R14, MyOsbyte80
CnpEntry
        Push    "R10,R12,R14"
        MOV     R10, #CNPV
        B       GoVec

MyOsbyte80
        MyOsbyte

AdvalPositive ROUT
        TEQ     R1, #7
        TEQNE   R1, #8
        Unused  NE

        Push    R11

        MOV     R11, R1                 ; save adval number
        SWI     XOS_Mouse
        Pull    R11, VS
        ByteReturnV VS

        TEQ     R11, #7
        MOVEQ   R1, R0                  ; R1 is required value

        MOV     R2, R1, LSR #8          ; put lo in R1, hi in R2
        AND     R1, R1, #&FF
        AND     R2, R2, #&FF

        Pull    R11
        MyOsbyte

; *****************************************************************************

; Perform INKEY operation
Osbyte81 ROUT
        TST     R2, #&80        ; is it negative inkey ?
        BEQ     %FT10           ; no, then not INKEY-256
        ANDS    R1, R1, #&FF    ; zero => INKEY(-256)
        MOVEQ   R1, #OSVersionID        ; then X := OS version number
        MOVEQ   R2, #0                  ; and  Y := 0
        MyOsbyte EQ             ; if was INKEY-256 then claim
10
        Push    R14             ; save return address for if passing on
        ADR     R14, My81
        Push    R14             ; stack 'claiming' return address
        BL      DoInkeyOp       ; R14 = 'passing on' return address
NotMy81                         ; DoInkeyOp passed it on

        Pull    "R3,R14"        ; Throw away 'claiming' return address
                                ; and restore real passing on return address
        Unused                  ; else pass it on still

My81
        Pull    R14             ; throw away real passing on address
        ByteReturnV


; *****************************************************************************

; Read Machine High Order Address
Osbyte82
        MOV     R1, #&FF                ; Pretend we're an I/O processor !
        MOV     R2, #&FF
        MyOsbyte

; *****************************************************************************

; Read OSHWM
Osbyte83
        LDRB    R2, OSHWM               ; Read from silly variable
        MOV     R1, #0                  ; lo-byte is 0
        MyOsbyte

; *****************************************************************************

; Read Text Cursor Position (input cursor if split)
Osbyte86
        ByteToNosbod DoReadPOSVPOSI     ; Results in R1, R2 (i.e. POS, VPOS)
        MyOsbyte

; *****************************************************************************

; Read Screen Mode and Character at text cursor position
Osbyte87
 [ {FALSE}
 ; The user's PSR is no longer there. In fact, it never was (or hasn't been
 ; for a long time), because the return address passed to the vector always
 ; had the I bit set.
        LDR     R3, [R13, #StackOffset] ; get user's psr
        ANDS    R3, R3, #I_bit          ; EQ => irqs were on
        CLRPSR  I_bit, R3, EQ           ; so clear I_bit now
 ]
 ; However, the SPSR _should_ have the user's interrupt state. If he had
 ; IRQs off, we will not have turned them back on, so neither we nor an
 ; interrupt routine will have called a a SWI, so SPSR will still be the
 ; SPSR from the original OS_Byte, with I set.
 ;
 ; If someone else is on ByteV, and passed it on, the rules say that they
 ; mustn't have enabled interrupts either, in which case any corrupted SPSR
 ; must still have I set.
 ;
 ; If the caller had interrupts enabled, an interrupt may have corrupted SPSR
 ; the worst effect of this is that we may not enable interrupts. So...
        MRS     R3, SPSR
        TST     R3, #I32_bit            ; EQ => IRQs were on
        MSREQ   CPSR_c, #SVC2632        ; so turn them on
        ByteToNosbod DoOSBYTE87         ; Results in R1, R2 (i.e. char, mode)
        MyOsbyte

; *****************************************************************************

; Insert Character Into Buffer
Osbyte8A
        BL      INSERT
        MyOsbyte

; *****************************************************************************

; Write Filing System Options : *OPT
Osbyte8B
        MOV     R0, #FSControl_Opt
        SWI     XOS_FSControl
        ByteReturnV

; *****************************************************************************

; Issue Paged ROM Service Request
Osbyte8F
        BL      Issue_Service
        MyOsbyte

; *****************************************************************************

; Select vertical screen shift and interlace option :*TV
Osbyte90
        LDRB    R0, TVVertical
        STRB    R1, TVVertical
        MOV     R1, R0                  ; old vertical in R1

        AND     R0, R2, #1
        LDRB    R2, TVInterlace         ; old interlace in R2
        STRB    R0, TVInterlace

        MyOsbyte

; *****************************************************************************

; Get Character From Buffer
Osbyte91
        CLRV                                    ; remove not examine
RemVEntry
        ADR     R14, MyOsbyte80
REMOVE
        Push    "R10,R12,R14"
        MOV     R10, #REMV
        B       GoVec

; *****************************************************************************

; Examine Buffer Status
Osbyte98
        SETV                                    ; examine not remove
        B       RemVEntry

; *****************************************************************************

; Insert Character Code Into buffer checking for ESCAPE
Osbyte99
        BL      DoInsertESC
        MyOsbyte

; *****************************************************************************

; Update pseudo 6850 control register and soft copy

Osbyte9C
        MOV     r0, #SerialOp_Modify6850        ; OS_SerialOp to modify 6850 control register
        SWI     XOS_SerialOp
        MyOsbyte

; *****************************************************************************

; 'Fast TUBE BPUT'

Osbyte9D
        MOV     R0, R1                  ; R0 := character
        MOV     R1, R2                  ; R1 := handle
        SWI     XOS_BPut
        ByteReturnV

; *****************************************************************************

; Read VDU Variable (0..15 implemented)
OsbyteA0
        ByteToNosbod DoReadVDUVariable
        MyOsbyte

; *****************************************************************************

; Read CMOS RAM
OsbyteA1    ; R1 = address , R2 = result
        CLRPSR  I_bit, R0       ; this may take some time
        MOV     R0, R1
        BL      Read            ; Read CMOS ram at address <R0>
        MOV     R2, R0          ; Result in R0, return in R2
        MyOsbyte

; Write CMOS RAM
OsbyteA2
        CLRPSR  I_bit, R0       ; this may take some time
        MOVS    R0, R1
        [ ProtectStationID
        ASSERT  NetStnCMOS = 0
        MyOsbyte EQ
        ]
        MOV     R1, R2
        BL      Write
        MOV     R1, R0          ; R1 is supposed to be preserved
        MyOsbyte

; *****************************************************************************

; OsByte 163,... applications call
OsbyteA3 ROUT
        TEQ     R1, #242
        Unused  NE                      ; not 242 - pass it on
        BL      %FT10
        MyOsbyte                        ; if come to here, has been claimed

10
        Push    R14
        ByteToNosbod DoOsbyte163_242
        Pull    R14                     ; if come to here, wasn't claimed
        Unused

; *****************************************************************************

; Read Output cursor Position
OsbyteA5
        ByteToNosbod DoReadPOSVPOSO     ; Result in R1,R2   (Horiz,vert)
        MyOsbyte

; *****************************************************************************
;
; All calls &A6 to &FF are implemented together.
; <NEW VALUE> = (<OLD VALUE> AND R2 ) EOR R1
; The old value is returned in R1 and the next location is returned in R2
;
; *****************************************************************************

DoOsbyteVar
        SUB     R0, R0, #OsByte_BaseOfOSByteVarTable
        LDRB    R3, [WsPtr, R0]         ; Load the byte
        AND     R11, R3, R2             ; Mangle it as required by the law
        EOR     R11, R11, R1            ; ................................
        MOV     R1, R3                  ; Return old value in R1

        TEQ     R0, #OsbyteKeyStatus - OsByte_BaseOfOSByteVarTable
        BEQ     DoOsbyteKeyStatus       ; sorry - it's not pure any more, mea culpa. KJB.

        STRB    R11, [R0, WsPtr]!       ; R0 +:= WsPtr
        LDRB    R2, [R0, #1]            ; Return contents of next loc in R2
        MyOsbyte

; Keyboard status (OS_Byte 202).
; on entry: R0 = OsbyteKeyStatus - OsByte_BaseOfOSByteVarTable
;           R1 = old value
;           R11 = new value
DoOsbyteKeyStatus ROUT
        Push    "R0-R3,R10"
        MOV     R10,#UpCallV            ; (Can't use OS_UpCall - it enables IRQs and we're documented as not doing so)
        MOV     R3,R11                  ; R3 = new value
        MOV     R2,R1                   ; R2 = old value
        MOV     R1,#0                   ; pre-change
        MOV     R0,#UpCall_KeyboardStatus
        BL      CallVector              ; go on then, interfere     (Corrupts R10 & WsPtr)

        LDR     R0, [R13]               ; get back original R0
      [ ZeroPage = 0
        STRB    R3, [R0, #OsbyteVars]!  ; R0 +:= WsPtr
      |
        LDR     R14, =ZeroPage+OsbyteVars
        STRB    R3, [R0, R14]!          ; R0 +:= WsPtr
      ]
        LDRB    R14, [R0, #1]           ; Return contents of next loc in R2
        STR     R14, [R13, #8]          ; by popping it on the stack

        TEQ     R2, R3                  ; don't bother with UpCall if it didn't change...

        MOVNE   R10,#UpCallV
        MOVNE   R1,#1                   ; post-change
        MOVNE   R0,#UpCall_KeyboardStatus
        BLNE    CallVector              ; can't do anything about it now...

        Pull    "R0-R3,R10"
        MyOsbyte

        LTORG

; All the unused OS_Byte calls

; ADC stuff
Osbyte10 ROUT
Osbyte11 ROUT
; Incr/Decr Polling Int
Osbyte16
Osbyte17
; Unused
Osbyte18
; Write 1MHz bus selection
Osbyte6B
; Write Usage of Shadow memory for normal access
Osbyte6C
; Make temporary filing system permanent
Osbyte6D
; &6E and &6F are reserved by 3rd parties
Osbyte6E
Osbyte6F
; &73 and &74 reserved for Electron
Osbyte73
Osbyte74
; Close SPOOL(ON) & EXEC files
Osbyte77
; Read top of USER RAM
Osbyte84
; Read top of user RAM for given mode
Osbyte85
; *CODE
Osbyte88
; *MOTOR
Osbyte89
; *TAPE
Osbyte8C
;  *ROM
Osbyte8D
; Enter Language ROM
Osbyte8E
; Access Mem.Map.IO &92..&97
Osbyte92
Osbyte93
Osbyte94
Osbyte95
Osbyte96
Osbyte97
; Write to VidULA & COPY
Osbyte9A
Osbyte9B
; Old Style Speech
Osbyte9E
Osbyte9F
; Check Processor Type
OsbyteA4
        Unused

; *****************************************************************************
;
;       GetCountry - Read country
;
; in:   R1 = country number or alphabet number
;
; out:  IF R1=0 THEN
;         R1:=Configured Country
;         IF R1=0 THEN
;           R1:=LastKbId
;           IF R1>=&20 THEN R1:=0
;         ENDIF
;       ENDIF
;
;       R0 undefined
;

GetCountry ROUT
        TEQ     R1, #0                          ; if not setting default, exit
        MOVNE   PC, R14

        Push    R14
        MOV     R0, #CountryCMOS                ; read configured country
        BL      Read
        MOVS    R1, R0                          ; if not Country Default, exit
        Pull    PC, NE

        LDR     R0, =ZeroPage+KeyWorkSpace
        LDRB    R1, [R0, #:INDEX: LastKbId]     ; read last valid keyboard id
        CMP     R1, #&20                        ; if <&20 then use this
        MOVCS   R1, #0                          ; else set to 0
        Pull    PC

        END
@


4.15
log
@Change module initialisation to be a two pass scheme
Detail:
  To make it easier to support arbitrary complexity keyboard controllers (eg. USB via DWCDriver on the Pi) have the kernel do the early keyboard recovery key press detection instead of the HAL.
  During the first pass those modules used for reading the keyboard are started, ignoring the CMOS frugal bits.
  The keyboard is then scanned for 3s, during which time the RAM is cleared (unless the HAL indicated it has already been done).
  During the second pass the remaining modules are started respecting the CMOS frugal bits. Any which were already started in the first pass are inserted into the new chain, so the keyboard is reset once and only once.

  Boot times, with a 300cs key scan time in NewReset.
  Risc PC with 160MB RAM (128+32+0).
  Times from turning on power to initial "beep", using a stopwatch.
                RISC OS 3.70 RISC OS 5.22 This OS
  ARM610        12.5         10.4         10.3
  ARM710        11.8         10.2         9.7
  StrongARM 233 11.1         9.5          8.4

  In NewReset.s:
  Remove old KbdScan code (leave Reset_IRQ_Handler for IIC only)
  If HAL_KbdScanDependencies returns a null string then present KbdDone flag and skip to full init.
  A few vestiges of soft resets removed.
  Do RAM clear when waiting for INKEY (being careful not to trash the running modules...).
  Clearing just the freepool on a 2GB Titanium cleared 7EFD6 pages (99.2%).

  In ModHand.s:
  2nd pass need to sneaky renumber the nodes (so *ROMModules is in the right order, frugal bits line up) without resetting the chain

  In HAL.s:
  Change ClearPhysRAM to ClearWkspRAM, such that it only clears the kernel workspace rather than all RAM. The bulk of the RAM is cleared during the keyboard scan by new function ClearFreePoolSection.
  Add a variant of Init_MapInRAM which clears the mapped in RAM too (as these very early claims will not be in the free pool when the RAM is cleared later).
  Remove HAL keyboard scan setup & IRQ handler.
  Fix bug in HALDebugHexTX2, the input value needs pre-shifting by 16b before continuing.

  In GetAll.s, PMF/osbyte.s:
  Use Hdr:Countries and Hdr:OsBytes for constants.

  In PMF/key.s, PMF/osinit.s:
  Relocate the key post init from PostInit to KeyPostInit.
  Changed PostInit to not tail call KeyPostInit so they can be called independently.

  In hdr/KernelWs:
  Improve comments, add InitWsStart label to refer to.

  In hdr/HALEntries:
  Add HAL_KbdScanDependencies.
  Delete KbdFlag exports.
  Took the opportunity to reorder some of the higher numbered HAL entries and re-grouping, specifically (112,120) (84,106,108,117).
Admin:
  Tested on an ARM6/ARM7/SA Risc PC, BeagleBoard xM, Iyonix, Pandaboard ES, Wandboard Quad, IPEGv5, Titanium, Pi 2 and 3.
  Requires corresponding HAL change.
  Submission for USB bounty.

Version 5.89. Tagged as 'Kernel-5_89'
@
text
@a808 1
        MOV     R12, #IOC
@


4.14
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@a28 2
OsbyteSetCountry * &46
OsbyteSetAlphKey * &47
d217 1
a217 1
        TEQ     R0, #OsbyteSetCountry
d219 1
a219 1
        TEQ     R0, #OsbyteSetAlphKey
@


4.14.2.1
log
@Merge latest changes from main branch

Version 5.89, 4.129.2.6. Tagged as 'Kernel-5_89-4_129_2_6'
@
text
@d29 2
d219 1
a219 1
        TEQ     R0, #OsByte_Country
d221 1
a221 1
        TEQ     R0, #OsByte_Alphabet
@


4.14.2.2
log
@Merge in latest changes from main branch

Version 6.05, 4.129.2.8. Tagged as 'Kernel-6_05-4_129_2_8'
@
text
@d809 1
@


4.13
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@d366 1
a366 1
 [ StrongARM
a559 1
 [ StorkPowerSave
a566 1
 ]
d573 1
a573 1
 [ StrongARM
@


4.12
log
@  Improved the error cacheing.
  Removed DriversInKernel conditional.
Detail:
  If the territory changes or the resource file changes, the kernel
    will now decache all the cached error blocks so that next time
    they are required, they will be looked up again.
  The error cacheing is now a kernel build option and is always set
    to on.
  Removed one of the 5 error messages to be cached - it never seems
    to happen.  The remaining 4 are more frequent.
Admin:
  Tested in Ursula build.
  Cannot be used with HdrSrc 0.94.  HdrSrc 0.95 and later is required
    (or HdrSrc 0.93 and earlier subject to other kernel requirements)
  Requires MessageTrans 0.42 or later for correct operation when a
    replacement messages file is loaded.

Version 5.32. Tagged as 'Kernel-5_32'
@
text
@a32 2
ArthurINKEY256 * &A7    ; INKEY-256 value

d55 1
a55 1
        Pull    "R0,R3,R14,PC", VC
d57 4
a60 2
        ADDVS   R13, R13, #4                    ; junk stacked R0
        Pull    "R3,R14,PC", VS
d73 1
a73 1
        IssueService
d80 1
a80 1
        ADRNE   R0, BadCommandError             ; not claimed, R0 -> error
d85 3
a87 1
        Pull    "R1-R4, R14, PC"
d89 1
a89 1
BadCommandError MakeErrorBlock BadCommand
d93 3
a95 1
        Pull    "R0,R3, R14,PC"           ; pull the world AND the PC to return
d143 1
a143 1
        CMP     R0, #MainVars           ; is it a variable ?
d240 6
d247 1
d251 21
d273 6
a278 2
        &       &F7
        =       "$MosTitle",0
d312 22
d335 1
a335 1
        ADR     r1, SerialInFilename    ; open serial stream for input
d339 1
d349 1
a349 1
        =       "Serial#Buffer1:", 0
d375 1
a375 1
        MOV     R3, #0
d409 4
d422 1
d464 1
a464 1
        MOVCS   R2, #0                  ; then return + say was disabled
d474 2
a475 2
        CMP     R0, #&100               ; C=1 => wrapped, so don't store back
        STRCCB  R0, [R3, R1]
d513 1
a513 1
        MOV     R11, #KeyWorkSpace      ; can corrupt R11
d534 2
a535 1
        mrs    ,R3, CPSR                ; Interrupts disabled at the moment
d537 1
d546 1
a546 1
        VDWS    R2
d548 2
a549 2
        LDRB    R0, [R2,#ScreenBlankFlag]
        LDRB    R1, [R2,#ScreenBlankDPMSState]
d555 15
a569 2
        LDRB    R2, CFStime
10
d571 1
a571 1
        msr    ,CPSR_c, R1              ; CLI
d582 1
a582 1
        msr    ,CPSR_c, R3              ; SEI
a585 11

 [ StorkPowerSave
; It is actually better to call Idle with interrupts disabled as it stops the interrupt
; going off on the way through the SWI dispatch and accidentally waiting for the next
; interrupt... The Idle will return when an interrupt is pending - it will be handled when
; we branch back up and enable interrupts.
        MOV     R0, #0
        LDRB    R0, [R0, #PortableFlags]
        TST     R0, #PortableFeature_Idle
        SWINE   XPortable_Idle
 ]
d695 1
a695 1
        IssueService
d778 1
a778 3
        STRNEB  R1, [R0, #PointerShapeNumber]
        MOVNE   R1, #1
        STRNEB  R1, [R0, #PointerShapeChanged]
d780 1
a780 1
        ; the shape will change on the next vsync
d812 1
a812 1
        MOV     R11, #KeyWorkSpace
d822 1
a822 1
; Perform Keyboard Scan from 16
d824 1
a824 1
        MOV     R1, #&10
d856 1
a856 1
        MOV     R12, #EscHan_ws
a861 1
 [ Version >= 201
d864 1
a864 1
        mrs    ,R11, CPSR                       ; Preserve old processor state
d866 1
a866 1
        msr    ,CPSR_c, R12
d870 1
a870 1
        msr    ,CPSR_c, R11                     ; Switch back to original mode, with V_bit intact from SWI
a872 4
 |
        STREQB  R12, [R12, #IRQ_CallBack_Flag-1]
 ]
        Pull    "R11, PC"
d876 1
a876 1
        MOV     R3, #0
d978 1
a978 1
        MOVEQ   R1, #ArthurINKEY256     ; then X := OS version number
d1043 1
a1043 1
        mrs    ,R3, SPSR
d1045 1
a1045 1
        msr EQ ,CPSR_c, #SVC2632        ; so turn them on
d1060 1
a1060 1
        MOV     R0, #FSControl_OPT
d1068 1
a1068 1
        IssueService
d1116 1
a1116 1
        MOV     r0, #7                          ; OS_SerialOp to modify 6850 control register
d1150 1
a1150 5
        [ E2ROMSupport
        MOVS	R0, R1
        |
        ANDS    R0, R1, #&FF    ; only look at bottom byte
        ]
d1152 1
a1154 13
        [ STB :LAND: :DEF: ObsoleteNC1CMOS
        ; Protect machine address CMOS (if not corrupt)
        ASSERT  EtherCheckCMOS = EtherAddrCMOS+6
        CMP     r0, #EtherAddrCMOS
        BLT     %FT10
        CMP     r0, #EtherCheckCMOS
        BGT     %FT10
        Push    "r0,r1"
        BL      GetMachineAddressCMOS
        Pull    "r0,r1"
        MyOsbyte EQ             ; don't allow write if address is valid
10
        ]
d1191 1
a1191 1
        SUB     R0, R0, #MainVars       ; Point to this block starting at &A6
d1196 4
a1199 2
        TEQ     R0, #OsbyteKeyStatus - MainVars    ; sorry - it's not pure any more.
        BEQ     DoOsbyteKeyStatus                  ; mea culpa. KJB.
d1205 1
a1205 1
; on entry: R0 = OsbyteKeyStatus - MainVars
d1218 1
d1220 4
d1321 1
a1321 1
        MOV     R0, #KeyWorkSpace
@


4.12.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d470 1
a470 1
        MRS     R3, CPSR                ; Interrupts disabled at the moment
d492 1
a492 1
        MSR     CPSR_c, R1              ; CLI
d503 1
a503 1
        MSR     CPSR_c, R3              ; SEI
d799 1
a799 1
        MRS     R11, CPSR                       ; Preserve old processor state
d801 1
a801 1
        MSR     CPSR_c, R12
d805 1
a805 1
        MSR     CPSR_c, R11                     ; Switch back to original mode, with V_bit intact from SWI
d982 1
a982 1
        MRS     R3, SPSR
d984 1
a984 1
        MSREQ   CPSR_c, #SVC2632        ; so turn them on
@


4.12.2.2
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@d710 3
a712 1
        BEQ     %FT90                           ; same as old
d714 1
a714 1
        STRB    R1, [R0, #PointerShapeNumber]   ; will take effect on next vsync (UpdatePointer)
@


4.12.2.3
log
@  Added HAL NVRAM support
Detail:
  Added the HAL NVRAM entries.
  Modified i2cutils to use the HAL entries for NVRAM and behave sensibly if the HAL reports that there is no NVRAM, in which case there must be a forced reset_cmos call so that the cache gets set up sensibly.
Admin:
  Tested under the RPC emulator and appears to be working correctly, although some calls to IIC are still being made in the no nvram case.

Version 5.35, 4.79.2.8. Tagged as 'Kernel-5_35-4_79_2_8'
@
text
@d1087 1
d1089 3
@


4.12.2.4
log
@Check-in of the few last-minute changes for the Customer L demo. Nothing
exciting, apart from an extended touchscreen API.

Version 5.35, 4.79.2.13. Tagged as 'Kernel-5_35-4_79_2_13'
@
text
@d33 2
d915 1
a915 1
        MOVEQ   R1, #OSVersionID        ; then X := OS version number
@


4.12.2.5
log
@  Bugfixes to OS_Bytes 13 and 14.
Detail:
  Event numbers greater than 31 are possible, it's just that OS_GenerateEvent
  doesn't bother cheking the event semaphores for them. However, the value
  returned in R1 from these OS_Bytes always indicated that such events were
  disabled. This suggests that OS_GenerateEvent was not always so, but the
  initials in comments there suggest the change was about RISC OS 3.0.
  The OS_Bytes now correctly reflect OS_GenerateEvent behaviour.
  Another bug fix is that once the event semaphores had saturated at 255,
  OS_Byte 13 was still happy to decrement the semaphore, so for example 256
  enables followed by 255 disables would have disabled the event.
Admin:
  Not tested.

Version 5.35, 4.79.2.70. Tagged as 'Kernel-5_35-4_79_2_70'
@
text
@d398 1
a398 1
        MOVCS   R2, #&FF                ; then return + say was enabled
d408 2
a409 2
        CMP     R2, #&FF                ; Z=1 => already saturated, so don't store back
        STRNEB  R0, [R3, R1]
@


4.12.2.6
log
@Update the method the HAL kernel uses to determine the UtilityModule & ROM dates
Detail:
  Three main changes:
  * On odd-numbered (i.e. development) versions of the module, the UtilityModule will now take its date from the VersionNum file instead of using a hard-coded date
  * All build versions now look for the new "extended ROM footer" (as created by romlinker 0.04+) at the end of the ROM image and use it to determine the ROM build date for return by OS_ReadSysInfo 9,2. Failing to find the build date in the footer will cause OS_ReadSysInfo 9,2 to return 0.
  * On odd-numbered versions, OS_Byte 0 will now use the ROM build date (as found in the extended footer) to generate the error block that's returned to the user. This seems OK as the PRM describes OS_Byte 0 as returning the "creation date of the operating system". Plus it's a convenient way of getting the ROM build date into the Switcher, since the switcher uses OS_Byte 0. If the extended footer can't be found (or if the string isn't initialised yet, e.g. before Service_PostInit) the code falls back to a hard-coded string containing the date from the VersionNum file.
  File changes:
  Makefile - Updated to not create the obsolete Time+Date file (previously used for the ROM build date)
  Version - Use date from VersionNum file for development builds
  hdr/Options - New UseNewFX0Error variable/option to make it easy to check which OS_Byte 0 variant should be enabled
  hdr/KernelWS - Added new string buffers & extended ROM footer pointer to workspace
  s/Middle - Updated OS_ReadSysInfo 9 code, and added utility functions for searching the extended ROM footer for certain tags
  s/NewReset - Added a couple of calls to initialise the new string buffers just prior to Service_PostInit. This is required since OS_Byte/OS_ReadSysInfo shouldn't enable interrupts, but date conversion relies on the Territory module, which may enable interrupts.
  s/PMF/osbyte - Updated OS_Byte 0 code
Admin:
  Tested in Tungsten ROM, with and without the extended footer present.


Version 5.35, 4.79.2.115. Tagged as 'Kernel-5_35-4_79_2_115'
@
text
@a233 6
      [ UseNewFX0Error
        LDR     R0, =NewFX0Error
        LDR     LR, [R0]
        CMP     LR, #0
        ADREQ   R0, FX0Error ; Fall back to hardcoded string if new one isn't ready yet
      |
a234 1
      ]
a237 21
      [ UseNewFX0Error
InitNewFX0Error ROUT
        Push    "r0-r4,lr"
        MOV     r0, #0
        BL      ExtendedROMFooter_FindTag
        CMP     r0, #0
        BEQ     %FT10
        MOV     r1, r0
        MOV     r0, #-1
        LDR     r2, =NewFX0Error+4
        MOV     r3, #?NewFX0Error - 4
        ADR     r4, NewFX0ErrorFormat
        SWI     XTerritory_ConvertDateAndTime
        ; Fill in error number on success
        LDRVC   r2, =NewFX0Error
        MOVVC   r3, #&7F
        STRVC   r3, [r2]
10
        Pull    "r0-r4,pc"
      ]

a240 4
      [ UseNewFX0Error
NewFX0ErrorFormat
        =       "$SystemName $VString (%dy %m3 %ce%yr)",0
      ]
@


4.12.2.7
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d55 1
a55 1
        LDRVC   R0,[R13]
d57 2
a58 4
        ADD$cond R13,R13,#4
        LDR$cond R3,[R13],#8 ; pull r3, junk r14
        LDR$cond PC,[R13],#4
        
d83 1
a83 3
        Pull    "R1-R4"
        ADD     SP,SP,#4
        Pull    "PC"
d89 1
a89 3
        Pull    "R0,R3"                 ; pull the world AND the PC to return
        ADD     SP,SP,#4
        Pull    "PC"
d346 1
a346 1
        LDR     R3, =ZeroPage
a379 4
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
        ADD     R2, R2, R0
      ]
a388 1
        ASSERT  (ZeroPage :AND: 255) = 0
d479 1
a479 1
        LDR     R11, =ZeroPage+KeyWorkSpace ; can corrupt R11
d543 1
a543 1
        LDR     R0, =ZeroPage
d774 1
a774 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d818 1
a818 1
        LDR     R12, =ZeroPage+EscHan_ws
d843 1
a843 1
        LDR     R3, =ZeroPage
a1194 1
      [ ZeroPage = 0
a1195 4
      |
        LDR     R14, =ZeroPage+OsbyteVars
        STRB    R3, [R0, R14]!          ; R0 +:= WsPtr
      ]
d1293 1
a1293 1
        LDR     R0, =ZeroPage+KeyWorkSpace
@


4.12.2.8
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d1038 1
a1038 1
        MOV     R0, #FSControl_Opt
d1128 1
a1128 1
        MOVS    R0, R1
@


4.12.2.9
log
@Correction to error number for *FX0
On odd numbered versions was coming out as 7F not F7.

Version 5.35, 4.79.2.141. Tagged as 'Kernel-5_35-4_79_2_141'
@
text
@d266 1
a266 1
        MOVVC   r3, #ErrorNumber_FX0
d273 1
a273 1
        &       ErrorNumber_FX0
@


4.12.2.9.2.1
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d143 1
a143 1
        CMP     R0, #OsByte_BaseOfOSByteVarTable ; is it a variable ?
d274 1
a274 1
        =       "$SystemName $VersionNo",0
a311 22
        SUB     sp, sp, #64
        MOV     r3, sp
        ADR     r1, SerialInFilename

12
        LDRB    r0, [r1], #1
        CMP     r0, #0
        STRNEB  r0, [r3], #1
        BNE     %BT12

        MOV     r0, #SerialOp_GetDeviceName
        SWI     XOS_SerialOp
        ; r1 should now be correct device name or preserved on error
        ; i.e. left pointing at our default name
        ADD     lr, sp, #63
14
        SUBS    r0, r1, lr                      ; Basic buffer overflow check
        LDRNEB  r0, [r1], #1
        CMPNE   r0, #0
        STRB    r0, [r3], #1
        BNE     %BT14
        
d313 1
a313 1
        MOV     r1, sp                  ; open serial stream for input
a316 1
        ADD     sp, sp, #64
d326 1
a326 1
        =       "Devices#Buffer1:$.", 0, "Serial", 0
d1094 1
a1094 1
        MOV     r0, #SerialOp_Modify6850        ; OS_SerialOp to modify 6850 control register
d1181 1
a1181 1
        SUB     R0, R0, #OsByte_BaseOfOSByteVarTable
d1186 2
a1187 4

        TEQ     R0, #OsbyteKeyStatus - OsByte_BaseOfOSByteVarTable
        BEQ     DoOsbyteKeyStatus       ; sorry - it's not pure any more, mea culpa. KJB.

d1193 1
a1193 1
; on entry: R0 = OsbyteKeyStatus - OsByte_BaseOfOSByteVarTable
@


4.12.2.10
log
@Adoption of *CONFIGURE/STATUS CACHE commands
The kernel already looks after all other aspects of the ARM CPU, so can look after the cache control command too.
 HelpStrs.s:New tokens for help and syntax
 CmdHelp.s:UK help and syntax
 Arthur3.s:Tables updates for *CONFIGURE/STATUS, lined some stuff up, default error text sync'd with Hdr:NewErrors
 MoreComms.s:Parsing and doing of *CACHE
 Utility.s:Hashing table updated for *CACHE
Other minor changes
 hdr/Options:Bring 'MosVer' into the private header
 hdr/RISCOS:aasm aliases for SP removed, MainVars and MosVer made private, added definition of the start of application space
 HeapMan.s:Use of GRAB changed to Pull
 Offset of TutuCMOS changed for more informative PrintSoundCMOS
 PMF/osbyte.s:Use OsBytes header file in place of MainVars

Version 5.35, 4.79.2.151. Tagged as 'Kernel-5_35-4_79_2_151'
@
text
@d143 1
a143 1
        CMP     R0, #OsByte_BaseOfOSByteVarTable ; is it a variable ?
d274 1
a274 1
        =       "$SystemName $VersionNo",0
d1181 1
a1181 1
        SUB     R0, R0, #OsByte_BaseOfOSByteVarTable
d1186 2
a1187 4

        TEQ     R0, #OsbyteKeyStatus - OsByte_BaseOfOSByteVarTable
        BEQ     DoOsbyteKeyStatus       ; sorry - it's not pure any more, mea culpa. KJB.

d1193 1
a1193 1
; on entry: R0 = OsbyteKeyStatus - OsByte_BaseOfOSByteVarTable
@


4.12.2.11
log
@Add new HAL entry, HAL_UARTDefault. Make use of Hdr:SerialOp & OS_SerialOp 10.
Detail:
  hdr/HALEntries - Brought in line with RPi branch, plus addition of new HAL_UARTDefault HAL entry, to allow DualSerial to determine which (if any) of the HAL UARTs should be the default UART accessed via OS_SerialOp
  s/GetAll - Add GET of Hdr:SerialOp
  s/PMF/osbyte - Use OS_SerialOp 10 when constructing filename to open for OS_Byte 2
Admin:
  Tested in OMAP3, Tungsten ROMs


Version 5.35, 4.79.2.152. Tagged as 'Kernel-5_35-4_79_2_152'
@
text
@a311 22
        SUB     sp, sp, #64
        MOV     r3, sp
        ADR     r1, SerialInFilename

12
        LDRB    r0, [r1], #1
        CMP     r0, #0
        STRNEB  r0, [r3], #1
        BNE     %BT12

        MOV     r0, #SerialOp_GetDeviceName
        SWI     XOS_SerialOp
        ; r1 should now be correct device name or preserved on error
        ; i.e. left pointing at our default name
        ADD     lr, sp, #63
14
        SUBS    r0, r1, lr                      ; Basic buffer overflow check
        LDRNEB  r0, [r1], #1
        CMPNE   r0, #0
        STRB    r0, [r3], #1
        BNE     %BT14
        
d313 1
a313 1
        MOV     r1, sp                  ; open serial stream for input
a316 1
        ADD     sp, sp, #64
d326 1
a326 1
        =       "Devices#Buffer1:$.", 0, "Serial", 0
d1094 1
a1094 1
        MOV     r0, #SerialOp_Modify6850        ; OS_SerialOp to modify 6850 control register
@


4.12.2.12
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@d80 1
a80 1
        ADRNE   R0, ErrorBlock_BadCommand       ; not claimed, R0 -> error
d89 1
a89 1
        MakeErrorBlock BadCommand
@


4.12.2.13
log
@Add support for new extended internal key codes, low level key codes, and key handler format
Detail:
  s/Middle - Added OS_ReadSysInfo 13 to allow the kernel to validate a key handler before the owner attempts to install it
  Resources/UK/Messages - Text for new "Bad key handler" error
  s/GetAll, s/PMF/Def - Get rid of now obsolete s/PMF/Def file. It only contained definitions for pre-HAL hardware, and for the key handler layout (now in Hdr:Keyboard)
  hdr/KeyWS - Increased size of KeysDown array so it can hold 768 keys instead of 160. Trim a couple of obsolete variables, and increase CurrKey/OldKey from 1 byte to 4 bytes.
  s/PMF/key, s/PMF/osbyte - Main bulk of the changes for the new key handling. All the important interfaces are now able to deal with extended (i.e. > 8 bit) internal key numbers, and the kernel is able to cope with key handlers which use 16 bit internal/low level key numbers instead of 8 bit.
Admin:
  Tested on Pandora & BB-xM
  Requires HdrSrc-2_20


Version 5.35, 4.79.2.178. Tagged as 'Kernel-5_35-4_79_2_178'
@
text
@d818 1
a818 1
; Perform Keyboard Scan from 15
d820 1
a820 1
        MOV     R1, #&0F
@


4.12.2.14
log
@Retire single use of DebugROMErrors
hdr/Options: Switch removed
s/Modhand: Switch removed, now considered equivalent to DebugROMInit. DebugROMInit changed so that the callback ordering is as expected, batched up until "callbacks" is hit after Service_PostInit.
PMF/osbyte: Redundant RISC OS 2.01 code deleted

Version 5.35, 4.79.2.184. Tagged as 'Kernel-5_35-4_79_2_184'
@
text
@d858 1
d870 4
@


4.12.2.15
log
@Replace 1 line macro
IssueService -> BL Issue_Service.
@
text
@d73 1
a73 1
        BL      Issue_Service
d691 1
a691 1
        BL      Issue_Service
d1064 1
a1064 1
        BL      Issue_Service
@


4.12.2.16
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@a552 5
        ; Also, exit now if we don't have a driver active
        LDR     R0, [R2,#CurrentGraphicsVDriver]
        CMP     R0, #GraphicsVInvalid
        MyOsbyte EQ

@


4.12.2.17
log
@Add a means to write NetStnCMOS in a HAL world
With ProtectStationID turned on there are no routes to writing the Econet station (or bottom octect of the IP address), a function previously fulfilled by the SetStation utility which pokes the hardware directly and doesn't fit into a HAL model.
Add a new subreason to OS_NVMemory to perform this role. This SWI appeared for RISC OS 5.00, and errors unsupported subreasons, so there's a means of run tim selecting its use by checking the platform class and trying the SWI. All RISC OS 5 based platforms can always be upgraded to this version, since they're all still being maintained.

hdr/Options: move the switch with the other options from osinit.s
i2cutils.c: new subreason

Ditch the 'ObsoleteNC1CMOS' switch, if it was obsolete for NC1, it's certainly obsolete now.
Ditch unmaintained messages files for Morris4/Omega/Ursula projects.
Tested on a Risc PC.

Version 5.35, 4.79.2.247. Tagged as 'Kernel-5_35-4_79_2_247'
@
text
@a1152 1
        ASSERT  NetStnCMOS = 0
d1155 13
@


4.12.2.18
log
@Fix OS_Byte 19 getting stuck if it's called just before the screen blanker activates. Add new OS_ReadSysInfo reason code for determining IIC bus count.
Detail:
  s/PMF/osbyte - For OS_Byte 19, move screen blanker check (and current GraphicsV driver check) inside the WFI loop so that the loop will terminate if the screen should blank (or current GraphicsV driver should die) before the next VSync occurs. Also move the Portable_Idle call to before the interrupt trigger - the old location meant that if the screen blanked we'd continue on to the Portable_Idle call and end up pointlessly stalling the system
  s/Middle - Add OS_ReadSysInfo 14, as a legitimate way of finding the number of IIC buses present on the system
Admin:
  Tested on Pandaboard


Version 5.35, 4.79.2.261. Tagged as 'Kernel-5_35-4_79_2_261'
@
text
@a534 1
        LDRB    R2, CFStime
a535 1
10
d544 1
a544 1
        VDWS    LR
d546 2
a547 2
        LDRB    R0, [LR,#ScreenBlankFlag]
        LDRB    R1, [LR,#ScreenBlankDPMSState]
d554 1
a554 1
        LDR     R0, [LR,#CurrentGraphicsVDriver]
d558 2
a559 10
 [ StorkPowerSave
; It is actually better to call Idle with interrupts disabled as it stops the interrupt
; going off on the way through the SWI dispatch and accidentally waiting for the next
; interrupt... The Idle will return when an interrupt is pending - it will be handled below
        LDR     R0, =ZeroPage
        LDRB    R0, [R0, #PortableFlags]
        TST     R0, #PortableFeature_Idle
        SWINE   XPortable_Idle
 ]

d576 11
@


4.12.2.19
log
@Add SWI error pointer validation, SeriousErrorV hooks, and OS_ReadSysInfo 15
Detail:
  Resources/UK/Messages, hdr/KernelWS, s/Kernel - On return from a SWI with V set, do some basic validity checks on the error pointer in order to try and catch buggy SWIs that return bad pointers or invalid error blocks. If a bad pointer is found we'll substitute it with a pointer to a different error block, which has the SWI number in the error message, to allow the user to identify the source of the problem. (There's also a chance we'll crash when investigating a bad pointer, but crashing here in the kernel is preferable to crashing elsewhere because R12 should still contain the SWI number)
  hdr/OSMisc - Define SeriousErrorV reason codes and extended ROM footer entry IDs
  hdr/Options - Remove HangWatch integration flag, obsolete now that SeriousErrorV is available
  s/ArthurSWIs - Keep defaultvectab up to date with vector allocations
  s/Middle - Update serious error handling to call SeriousErrorV at several key points. This allows for accurate crash dumps to be obtained, along with a mechanism to warn low-level components such as RTSupport that the privileged mode stacks are being flattened.
  s/Middle - Add OS_ReadSysInfo 15, for enumerating extended ROM footer entries
  s/PMF/osbyte - Update InitNewFX0Error to use the ROM footer entry ID defined in hdr/OSMisc
Admin:
  Tested on Pi 1B, 2B, 3B


Version 5.35, 4.79.2.313. Tagged as 'Kernel-5_35-4_79_2_313'
@
text
@d254 1
a254 1
        MOV     r0, #ExtROMFooter_BuildDate
@


4.12.2.5.2.1
log
@Update the method the Cortex kernel uses to determine the UtilityModule & ROM dates
Detail:
  Three main changes:
  * On odd-numbered (i.e. development) versions of the module, the UtilityModule will now take its date from the VersionNum file instead of using a hard-coded date.
  * All build versions now look for the new "extended ROM footer" (as created by romlinker 0.04+) at the end of the ROM image and use it to determine the ROM build date for return by OS_ReadSysInfo 9,2. Failing to find the build date in the footer will cause OS_ReadSysInfo 9,2 to return 0.
  * On odd-numbered versions, OS_Byte 0 will now use the ROM build date (as found in the extended footer) to generate the error block that's returned to the user. This seems OK as the PRM describes OS_Byte 0 as returning the "creation date of the operation system". Plus it's a convenient way of getting the ROM build date into the Switcher, since the switcher uses OS_Byte 0. If the extended footer can't be found (or if the string hasn't been initialised yet, e.g. before Service_PostInit) the code falls back to a hard-coded string containing the date from the VersionNum file.
  File changes:
  Makefile - Updated to not create the obsolete Time+Date file (previously used for the ROM build date)
  Version - Use date from VersionNum file for development builds
  hdr/Options - New UseNewFX0Error variable/option to make it easy to check which OS_Byte 0 variant should be enabled
  hdr/KernelWS - Added new string buffers & extended ROM footer pointer to workspace
  s/Middle - Updated OS_ReadSysInfo 9 code, and added utility functions for searching the extended ROM footer for certain tags
  s/NewReset - Added a couple of calls to initialise the new string buffers just prior to Service_PostInit. This is required since OS_Byte/OS_ReadSysInfo shouldn't enable interrupts, but date conversion relies on the Territory module, which may enable interrupts.
  s/PMF/osbyte - Updated OS_Byte 0 code
Admin:
  Tested in OMAP ROM, with and without the extended footer present.


Version 5.35, 4.79.2.98.2.41. Tagged as 'Kernel-5_35-4_79_2_98_2_41'
@
text
@a233 6
      [ UseNewFX0Error
        LDR     R0, =NewFX0Error
        LDR     LR, [R0]
        CMP     LR, #0
        ADREQ   R0, FX0Error ; Fall back to hardcoded string if new one isn't ready yet
      |
a234 1
      ]
a237 21
      [ UseNewFX0Error
InitNewFX0Error ROUT
        Push    "r0-r4,lr"
        MOV     r0, #0
        BL      ExtendedROMFooter_FindTag
        CMP     r0, #0
        BEQ     %FT10
        MOV     r1, r0
        MOV     r0, #-1
        LDR     r2, =NewFX0Error+4
        MOV     r3, #?NewFX0Error - 4
        ADR     r4, NewFX0ErrorFormat
        SWI     XTerritory_ConvertDateAndTime
        ; Fill in error number on success
        LDRVC   r2, =NewFX0Error
        MOVVC   r3, #&7F
        STRVC   r3, [r2]
10
        Pull    "r0-r4,pc"
      ]

a240 4
      [ UseNewFX0Error
NewFX0ErrorFormat
        =       "$SystemName $VString (%dy %m3 %ce%yr)",0
      ]
@


4.12.2.5.2.2
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d346 1
a346 1
        LDR     R3, =ZeroPage
a379 4
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
        ADD     R2, R2, R0
      ]
a388 1
        ASSERT  (ZeroPage :AND: 255) = 0
d479 1
a479 1
        LDR     R11, =ZeroPage+KeyWorkSpace ; can corrupt R11
d543 1
a543 1
        LDR     R0, =ZeroPage
d774 1
a774 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d818 1
a818 1
        LDR     R12, =ZeroPage+EscHan_ws
d843 1
a843 1
        LDR     R3, =ZeroPage
a1194 1
      [ ZeroPage = 0
a1195 4
      |
        LDR     R14, =ZeroPage+OsbyteVars
        STRB    R3, [R0, R14]!          ; R0 +:= WsPtr
      ]
d1293 1
a1293 1
        LDR     R0, =ZeroPage+KeyWorkSpace
@


4.12.2.5.2.3
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d55 1
a55 1
        LDRVC   R0,[R13]
d57 2
a58 4
        ADD$cond R13,R13,#4
        LDR$cond R3,[R13],#8 ; pull r3, junk r14
        LDR$cond PC,[R13],#4
        
d83 1
a83 3
        Pull    "R1-R4"
        ADD     SP,SP,#4
        Pull    "PC"
d89 1
a89 3
        Pull    "R0,R3"                 ; pull the world AND the PC to return
        ADD     SP,SP,#4
        Pull    "PC"
@


4.11
log
@* Run-time emulator detection added (no need for separate images). Needs an
  RPCEm update.
* Register allocation in default ErrorV handler fixed - problems occured when
  callbacks were triggered on way out.
* OS_Byte 19 didn't manipulate interrupt disable flag correctly in 26-bit
  builds.
* Stray bit of debugging left in sprite code many years ago removed.

Version 5.23. Not tagged
@
text
@a256 18
 [ DriversInKernel
        MOVNE   R1, #RXEN6850           ; else enable RXI
        MOV     R2, #(&FF :EOR: RXEN6850) ; AND mask (R1 = EOR mask)
        BL      ModifyControl6850       ; on exit, R1 = old control reg
        LDRB    R2, RS423conflag        ; R2 = new control reg
        Push    "R1, R2"
        BL      RSETX                   ; try to enable RX interrupts
        Pull    "R1, R2"
        TEQ     R1, R2
        BEQ     %FT10                   ; no change in RXI

        Push    R11                     ; now purge data register when going
        LDR     R11, =ACIA              ; from disabled -> enabled; (also
        LDRB    R1, ACIARxData          ; does it for enabled -> disabled, this
                                        ; is irrelevant)
        Pull    R11
10
 |
a282 1
 ]
a288 1
 [ :LNOT: DriversInKernel
a291 1
 ]
a333 11
 [ DriversInKernel
; Write RS423 receive rate
Osbyte07
        BL      DoOsbyte07
        MyOsbyte

; Write RS432 transmit rate
Osbyte08
        BL      DoOsbyte08
        MyOsbyte
 |
a340 122
 ]

 [ DriversInKernel
; Modified 30-Mar-88 to handle new baud rates
; Format of SerULAreg is as follows:-
; Bit   Contents
; 7     TX3     ; *** NEW ***
; 6     RX3     ; *** NEW ***
; 5     RX2
; 4     RX1
; 3     RX0
; 2     TX2
; 1     TX1
; 0     TX0

; FX7/8         RX/TX bits above        Baud
; value         3   2   1   0           rate
;
; 1             0   1   1   1           75
; 2             0   0   1   1           150
; 3             0   1   0   1           300
; 4             0   0   0   1           1200
; 5             0   1   1   0           2400
; 6             0   0   1   0           4800
; 7 or 0        0   1   0   0           9600
; 8             0   0   0   0           19200
; 9             1   0   1   1           50
; 10            1   1   0   1           109.92
; 11            1   0   0   1           134.58
; 12            1   1   1   0           600
; 13            1   0   1   0           1800
; 14            1   1   0   0           3600
; 15            1   0   0   0           7200
; 16            1   1   1   1           Undefined


DoOsbyte07 ROUT
        Push    "R11, R14"
        LDRB    R2, SerULAreg
        CMP     R1, #16+1
        BCS     %FT10                   ; invalid

        ADR     R3, SerBaudTable        ; point to silly serproc table
        LDRB    R3, [R3, R1]            ; get entry
        BIC     R0, R2, #&78            ; clear old bits
        ORR     R0, R0, R3, LSL #3      ; or in new bits
DoFx7or8
        STRB    R0, SerULAreg

; first set up the carry flag to indicate whether RX = TX

        AND     R1, R0, #&07            ; get Tx bits 0-2
        TST     R0, #&80
        ORRNE   R1, R1, #&08            ; R1 = Tx bits
        EOR     R3, R1, R0, LSR #3      ; EOR Rx and Tx bits
        AND     R3, R3, #15             ; ignore other bits
        CMP     R3, #1                  ; C=1 => different

; now program both RX and TX (start with TX)

        ADR     R3, TxBaudTable         ; (R1 = Tx bits)
        LDRB    R3, [R3, R1]

        MOV     R1, R0, LSR #3          ; R1 = RX bits for later
        AND     R1, R1, #15

        PHPSEI                          ; NB preserves carry
        LDR     R11, =ACIA
        LDRB    R0, ACIAControl         ; replace old baud bits with new
        AND     R0, R0, #(ACIASBN :OR: ACIAWL1 :OR: ACIAWL0)
        ORR     R0, R0, R3              ; external RX clock by default
        ORRCC   R0, R0, #&10            ; if RX=TX use internal RX clock
        STRB    R0, ACIAControl

        BCC     %FT20                   ; if RX=TX then we've finished

        ADR     R3, RxBaudTable         ; point to timer latch values table
        LDR     R3, [R3, R1, LSL #2]    ; get entry

        MOV     R0, #IOC
        STRB    R3, [R0, #Timer2LL]
        MOV     R3, R3, LSR #8
        STRB    R3, [R0, #Timer2LH]
        STRB    R3, [R0, #Timer2GO]
20
        PLP
10
        MOV     R1, R2                  ; R1 = R2 = "old serproc contents"
        Pull    "R11, PC"

DoOsbyte08
        Push    "R11, R14"
        LDRB    R2, SerULAreg
        CMP     R1, #16+1
        BCS     %BT10                   ; invalid

        ADR     R3, SerBaudTable        ; point to silly serproc table
        LDRB    R3, [R3, R1]            ; get entry
        BIC     R0, R2, #&87            ; clear old bits
        TST     R3, #8                  ; if bit 3 is set
        EORNE   R3, R3, #&88            ; then move to bit 7
        ORR     R0, R0, R3              ; OR in new bits
        B       DoFx7or8

        LTORG

SerBaudTable
        =       4, 7, 3, 5, 1, 6, 2, 4, 0       ; silly table for BBC compat
        =       11, 13, 9, 14, 10, 12, 8, 15

TxBaudTable  ; ordered on values in SerBaudTable
        =       Baud19200, Baud1200, Baud4800, Baud150
        =       Baud9600, Baud300, Baud2400, Baud75
        =       Baud7200, Baud135, Baud1800, Baud50
        =       Baud3600, Baud110, Baud600, BaudUndef
        ALIGN

RxBaudTable  ; ordered on values in SerBaudTable
        &       2, 51, 12, 416, 6, 207, 25, 832
        &       8, 463, 34, 1249, 16, 568, 103, 0

 ]
a547 10
 [ DriversInKernel
        TEQ     R1, #Buff_Print         ; is it the printer buffer ?
        BNE     %FT15                   ; no, then skip

        LDRB    R0, PrinterDrivType     ; if printer type 0, 1 or 2
        CMP     R0, #3
        MOVCC   R0, #0                  ; then mark printer dormant
        STRCC   R0, PrinterActive
15
 ]
@


4.10
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d624 1
a624 1
        SavePSR R3                      ; Interrupts disabled at the moment
d657 1
a657 1
        RestPSR R3                      ; SEI
d663 1
a663 1
; It is actually better to call Idle with interrupts disabled as it stops us the interrupt
@


4.9
log
@OS_ReadSysInfo 2 now reports whether the IIC bus is fast (in bit 24 of R2),
and whether I/O clocks should be stopped when idling the processor (bit 25).
OS_Byte 19 is a bit more careful in its use of Portable_Idle - an edge case
where the vsync interrupt was already pending now returns immediately.

Version 5.07. Tagged as 'Kernel-5_07'
@
text
@a36 10
        GBLS    ByteRegs
        GBLA    StackOffset
        [ AssemblingArthur :LOR: Module
ByteRegs SETS    ""
StackOffset SETA 4*4            ; stack offset in osbyte routines to user pc
        |
ByteRegs SETS    "R11, WsPtr,"
StackOffset SETA 6*4            ; stack offset in osbyte routines to user pc
        ]

a53 2
        [ AssemblingArthur :LOR: ErrorsInR0

d57 1
a57 1
        Pull    "R0,R3,$ByteRegs R14,PC", VC
d60 1
a60 5
        Pull    "R3,$ByteRegs R14,PC", VS

        |
        Pull    "R0,R3,$ByteRegs R14,PC", $cond        ; for GenError systems
        ]
d67 1
a67 2
        [       AssemblingArthur :LOR: Module
        Push    "R0, R3, $ByteRegs R14"
d85 1
a85 1
        Pull    "R1-R4, $ByteRegs R14, PC"
a87 5
        |
        Push    "R0, R3, $ByteRegs R14"
        BL      OsByteGo
        Pull    "R0, R3, $ByteRegs PC"        ; no services, so pass it on
        ]
d91 1
a91 1
        Pull    "R0,R3, $ByteRegs R14,PC" ; pull the world AND the PC to return
a96 3
        [ :LNOT: AssemblingArthur :LAND: :LNOT: Module
        BYTEWS  WsPtr
        ]
d325 1
a325 1
        MOV     R14, PC                 ; for restoring I afterwards
d327 9
a335 3
        MVN     R3, #I_bit
        TSTP    R3, PC                  ; CLI
        TEQP    R14, #0                 ; restore old I
d624 1
a624 1
        MOV     R3, PC
d645 2
a646 1
        TEQP    R3, #I_bit              ; CLI
d657 1
a657 2

        TEQP    R3, #0                  ; SEI
d803 1
a803 1
        Pull    "R1,R4,PC",,^
a865 1
 [ LCDSupport           ;Must copy the shape from the buffer image into the 'current' buffer (ie create 4 instances)
a866 10

;;;don't do a wait for vsync
;;; [ Fix8
;;;        CLRPSR  I_bit, R0                       ; could take some time
;;; ]
;;;        MOV     R3, R1                          ; OS_Byte 19 corrupts R1 & R2 (why oh why oh why oh why oh why...)
;;;        MOV     R0, #19                         ; wait for vsync, so we change
;;;        SWI     XOS_Byte                        ; cleanly (ignore errors)
;;;        MOV     R1, R3

d870 9
a878 30
        CMP     R2, #4+1
        STRCCB  R1, [R0, #PointerShapeNumber]
        MOV     R1, R3
        MyOsbyte CS                             ;Leave if pointer shape was out of range
        CMP     R2, #0
        MyOsbyte EQ                             ;Leave if pointer shape was 'off'

        Push    "r0-r12,r14"
        SUB     R2, R2, #1                      ;Now in range 0-3
        LDR     R0, =CursorData
        MOV     R1, R0                          ;R1 points to 1st current image
        ADD     R0, R0, #&400                   ;R0 points to the start of the buffer images
        ADD     R0, R0, R2, LSL #8              ;Now, it points to the source buffer image
        ADD     R2, R1, #&100                   ;R2 points to 2nd current image
        ADD     R3, R2, #&F8                    ;R3 points to 3rd current image (top line will get lost, on purpose!)
        ADD     R4, R3, #&100                   ;R4 points to 4th current image (correct wrt 3rd image)

;StrongARM note: cursor area is now marked cacheable/bufferable (so that SWI despatch etc. is also)
;However, since the area for the current cursor (@@ CursorData, &400 bytes) is never read by RISC OS,
;it can never be in the cache, so there is no need to clean the write-back cache to force the new data
;out. All that remain is the write buffer, but this will drain quickly without help.
;
        ADD     R5, R0, #&100                   ;R5 is the end address.
11      LDMIA   R0!, {R6-R12,R14}
        STMIA   R1!, {R6-R12,R14}
        STMIA   R2!, {R6-R12,R14}
        STMIA   R3!, {R6-R12,R14}
        STMIA   R4!, {R6-R12,R14}
        CMP     R0, R5
        BNE     %BT11                           ;Keep going, more to do
d880 1
a880 10
        Pull    "r0-r12,r14"
        MyOsbyte                                ;This is a silly macro!
 |
Osbyte6A
        VDWS    R0
        LDRB    R3, [R0, #PointerShapeNumber]   ; get old shape number
        AND     R2, R1, #&7F                    ; allow 0..4, &80..&84
        CMP     R2, #4+1
        STRCCB  R1, [R0, #PointerShapeNumber]
        MOV     R1, R3
a881 1
 ]
a953 1
        [ AssemblingArthur :LOR: Module
a957 6
        |
        MOV     R12, #0
        STRB    R11, [R12, #ESC_Status]         ; set escape flag
        MOV     R14, PC                         ; ADRS R14, Exit7D
        LDR     PC, [R12, #EscHan]
        ]
d963 1
a963 1
        MOV     R11, PC                         ; Preserve old processor state
d965 1
a965 2
        TEQP    R12, #0
        NOP
a967 1
        ORRVS   R11, R11, #V_bit                ; Preserve V_bit
d969 1
a969 2
        TEQP    R11, #0                         ; Switch back to original mode, with V_bit intact from SWI
        NOP
a990 1
        [ AssemblingArthur :LOR: Module
a1002 1
        ]
d1127 4
a1130 1
 [ Fix6
d1135 14
@


4.8
log
@Call to Portable_Idle in OS_Byte 19 was corrupting R14.

Version 4.97. Tagged as 'Kernel-4_97'
@
text
@d660 1
a660 1
        BNE     %FT20                   ; if true exit immediately
d668 1
a668 7
 [ StorkPowerSave
        NOP
        MOV     R0, #0
        LDRB    R0, [R0, #PortableFlags]
        TST     R0, #PortableFeature_Idle
        SWINE   XPortable_Idle
 |
d679 13
a691 3
        BEQ     %BT10
20
        MyOsbyte
@


4.7
log
@Kernel was accidentally storing PortableFlags in the wrong place.
Now calls XPortable_Idle, not Portable_Idle in key-wait code.
Calls Portable_Idle in OS_Byte 19.

Version 4.94. Tagged as 'Kernel-4_94'
@
text
@d643 1
a643 1
        MOV     R14, PC
d664 1
a664 1
        TEQP    R14, #I_bit             ; CLI
d682 1
a682 1
        TEQP    R14, #0                 ; SEI
@


4.6
log
@Disabled references to old NC1 CMOS locations using the flag
ObsoleteNC1CMOS (like the CMOS header file).

Version 4.71. Tagged as 'Kernel-4_71'
@
text
@d662 1
a662 1
        LDRB    R0, CFStime
d665 1
a665 1
 [ StrongARM
d668 7
d681 1
d684 1
a684 1
        TEQ     R1, R0
@


4.5
log
@Actually issue upcalls when OS_Byte 202 is called.

Version 4.68. Tagged as 'Kernel-4_68'
@
text
@d1305 1
a1305 1
        [ STB
@


4.4
log
@OS_Byte 129 0 255 now reports &A7 for STB build (because it _is_ a
RISC OS 3.7 generation kernel).
CMOS no longer gets scrambled when reset in STB build.
UpCall_KeyboardStatus now issued when OS_Byte 202 called or when keyboard
status byte is changed by other means (such as pressing Caps Lock).

Version 4.67. Tagged as 'Kernel-4_67'
@
text
@a1358 1
  [ {FALSE}
a1360 1
  ]
a1364 1
 [ {FALSE}
d1370 2
a1371 1
        Push    "R0-R3"
d1376 1
a1376 2
        SWI     XOS_UpCall              ; go on then, interfere
        BVS     %FT10
d1379 1
a1379 1
        STRB    R3, [R0, WsPtr]!        ; R0 +:= WsPtr
d1385 1
d1388 3
a1390 3
        SWINE   XOS_UpCall              ; can't do anything about it now...
10
        Pull    "R0-R3"
a1391 1
  ]
@


4.3
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d31 1
a31 1
OsbyteWrchDests * &EC   ; only OS_Byte variable which isn't pure any more!
a32 3
         [ STB
ArthurINKEY256 * &A6    ; INKEY-256 value
         |
a33 1
         ]
d879 1
a879 1
;;; ]                                                                       
d1359 4
a1364 13
 [ {FALSE}                              ; This code didn't work in 3.00 because R0 isn't the offset from MainVars
                                        ; anymore - anyway, the code is not needed because the kernel closes the
                                        ; stream on an open request.
        TEQ     R0, #OsbyteWrchDests-MainVars
        MyOsbyte NE                     ; fast exit if not setting wrch destinations
        TST     R11, #1                 ; is serial output now disabled
        MyOsbyte NE
        LDRB    R1, SerialOutHandle     ; see if serial stream open
        TEQ     R1, #0                  ; if it is
        MOVNE   R0, #0                  ; then close it
        STRNEB  R0, SerialOutHandle     ; zeroing handle beforehand
        SWINE   XOS_Find
 ]
d1366 29
@


4.2
log
@Kernel merged
@
text
@d1301 3
d1305 1
@


4.2.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d33 5
a37 1
ArthurINKEY256  * OSVersionID   ; INKEY-256 value
d43 1
d46 4
d68 1
d78 3
d87 1
d102 1
d104 1
d109 5
d123 3
d286 18
d330 1
d337 1
d341 1
d378 11
d396 34
d432 87
d713 10
d881 1
d883 1
d1007 1
d1012 6
d1054 1
d1067 1
d1192 1
d1196 1
d1361 13
@


4.2.2.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d492 1
d500 1
d1104 13
@


4.2.2.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d492 1
d500 1
d1104 13
@


4.1
log
@Initial revision
@
text
@d24 2
d33 1
d35 3
d330 1
a330 1
 ] 
d547 1
a547 1
                                         
d562 1
a562 1
Osbyte0C  
d647 2
a648 2
        MOV     R14, PC               
        
d651 1
a651 1
        ; but the Hourglass module uses this call to wait for the next VSync 
d653 1
a653 1
        ; When the screen is DPMS-blanked this osbyte will now return 
d661 1
a661 1
        
d665 1
a665 1
        
d669 9
d682 1
a682 1
20        
d877 45
d923 3
d934 1
d955 1
a955 1
Osbyte75    
d1059 1
a1059 1
10        
d1075 1
a1075 1
        SWINE   XOS_Find                        ; (R0=0, R1=handle) 
d1160 1
a1160 1
My81                      
d1299 1
a1299 1
OsbyteA2 
d1305 13
d1319 1
a1319 1
        BL      Write      
d1341 1
a1341 1
OsbyteA5                                       
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a1240 12

        ; Protect machine address CMOS (if not corrupt)
        ASSERT  EtherCheckCMOS = EtherAddrCMOS+6
        CMP     r0, #EtherAddrCMOS
        BLT     %FT10
        CMP     r0, #EtherCheckCMOS
        BGT     %FT10
        Push    "r0,r1"
        BL      GetMachineAddressCMOS
        Pull    "r0,r1"
        MyOsbyte EQ             ; don't allow write if address is valid
10
@


4.1.7.2
log
@Allow CMOS write locations to be >&FF.
@
text
@a1236 3
        [ E2ROMSupport
        MOVS	R0, R1
        |
a1237 1
        ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a1240 12

        ; Protect machine address CMOS (if not corrupt)
        ASSERT  EtherCheckCMOS = EtherAddrCMOS+6
        CMP     r0, #EtherAddrCMOS
        BLT     %FT10
        CMP     r0, #EtherCheckCMOS
        BGT     %FT10
        Push    "r0,r1"
        BL      GetMachineAddressCMOS
        Pull    "r0,r1"
        MyOsbyte EQ             ; don't allow write if address is valid
10
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a23 2
; ????     08-Feb-95   WT   Change OS_Byte 106 to support the new cursor storage method
;                            introduced for Stork LCD support.
d31 1
a31 1
ArthurINKEY256 * &A7    ; INKEY-256 value
d324 1
a324 1
 ]
d541 1
a541 1

d556 1
a556 1
Osbyte0C
d641 2
a642 2
        MOV     R14, PC

d645 1
a645 1
        ; but the Hourglass module uses this call to wait for the next VSync
d647 1
a647 1
        ; When the screen is DPMS-blanked this osbyte will now return
d655 1
a655 1

d659 1
a659 1

a662 9
 [ StrongARM
   ;StrongARM core will not see interrupt unless disable is cleared for at least 5 cycles,
   ;in order to fill synchroniser pipe
        NOP
        NOP
        NOP
        NOP
        NOP
 ]
d667 1
a667 1
20
a861 11
 [ LCDSupport           ;Must copy the shape from the buffer image into the 'current' buffer (ie create 4 instances)
Osbyte6A

;;;don't do a wait for vsync
;;; [ Fix8
;;;        CLRPSR  I_bit, R0                       ; could take some time
;;; ]                                                                       
;;;        MOV     R3, R1                          ; OS_Byte 19 corrupts R1 & R2 (why oh why oh why oh why oh why...)
;;;        MOV     R0, #19                         ; wait for vsync, so we change
;;;        SWI     XOS_Byte                        ; cleanly (ignore errors)
;;;        MOV     R1, R3
a862 37
        VDWS    R0
        LDRB    R3, [R0, #PointerShapeNumber]   ; get old shape number
        AND     R2, R1, #&7F                    ; allow 0..4, &80..&84
        CMP     R2, #4+1
        STRCCB  R1, [R0, #PointerShapeNumber]
        MOV     R1, R3
        MyOsbyte CS                             ;Leave if pointer shape was out of range
        CMP     R2, #0
        MyOsbyte EQ                             ;Leave if pointer shape was 'off'

        Push    "r0-r12,r14"
        SUB     R2, R2, #1                      ;Now in range 0-3
        LDR     R0, =CursorData
        MOV     R1, R0                          ;R1 points to 1st current image
        ADD     R0, R0, #&400                   ;R0 points to the start of the buffer images
        ADD     R0, R0, R2, LSL #8              ;Now, it points to the source buffer image
        ADD     R2, R1, #&100                   ;R2 points to 2nd current image
        ADD     R3, R2, #&F8                    ;R3 points to 3rd current image (top line will get lost, on purpose!)
        ADD     R4, R3, #&100                   ;R4 points to 4th current image (correct wrt 3rd image)

;StrongARM note: cursor area is now marked cacheable/bufferable (so that SWI despatch etc. is also)
;However, since the area for the current cursor (@@ CursorData, &400 bytes) is never read by RISC OS,
;it can never be in the cache, so there is no need to clean the write-back cache to force the new data
;out. All that remain is the write buffer, but this will drain quickly without help.
;
        ADD     R5, R0, #&100                   ;R5 is the end address.
11      LDMIA   R0!, {R6-R12,R14}
        STMIA   R1!, {R6-R12,R14}
        STMIA   R2!, {R6-R12,R14}
        STMIA   R3!, {R6-R12,R14}
        STMIA   R4!, {R6-R12,R14}
        CMP     R0, R5
        BNE     %BT11                           ;Keep going, more to do

        Pull    "r0-r12,r14"
        MyOsbyte                                ;This is a silly macro!
 |
a870 1
 ]
d891 1
a891 1
Osbyte75
d995 1
a995 1
10
d1011 1
a1011 1
        SWINE   XOS_Find                        ; (R0=0, R1=handle)
d1096 1
a1096 1
My81
d1235 1
a1235 1
OsbyteA2
d1242 1
a1242 1
        BL      Write
d1264 1
a1264 1
OsbyteA5
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

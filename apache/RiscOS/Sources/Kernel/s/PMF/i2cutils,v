head	4.17;
access;
symbols
	Kernel-6_14:4.17
	Kernel-6_01-3:4.17
	Kernel-6_13:4.17
	Kernel-6_12:4.17
	Kernel-6_11:4.17
	Kernel-6_10:4.17
	Kernel-6_09:4.17
	Kernel-6_08-4_129_2_10:4.16.2.1
	Kernel-6_08-4_129_2_9:4.16.2.1
	Kernel-6_08:4.17
	Kernel-6_07:4.17
	Kernel-6_06:4.17
	Kernel-6_05-4_129_2_8:4.16.2.1
	Kernel-6_05:4.17
	Kernel-6_04:4.17
	Kernel-6_03:4.17
	Kernel-6_01-2:4.17
	Kernel-6_01-4_146_2_1:4.17
	Kernel-6_02:4.17
	Kernel-6_01-1:4.17
	Kernel-6_01:4.17
	Kernel-6_00:4.17
	Kernel-5_99:4.17
	Kernel-5_98:4.17
	Kernel-5_97-4_129_2_7:4.16.2.1
	Kernel-5_97:4.17
	Kernel-5_96:4.17
	Kernel-5_95:4.17
	Kernel-5_94:4.17
	Kernel-5_93:4.17
	Kernel-5_92:4.17
	Kernel-5_91:4.17
	Kernel-5_90:4.17
	Kernel-5_89-4_129_2_6:4.16.2.1
	Kernel-5_89:4.17
	Kernel-5_88-4_129_2_5:4.16
	Kernel-5_88-4_129_2_4:4.16
	Kernel-5_88:4.16
	Kernel-5_87:4.16
	Kernel-5_86-4_129_2_3:4.16
	Kernel-5_86-4_129_2_2:4.16
	Kernel-5_86-4_129_2_1:4.16
	Kernel-5_86:4.16
	SMP:4.16.0.2
	SMP_bp:4.16
	Kernel-5_85:4.16
	Kernel-5_54-1:4.16
	Kernel-5_84:4.16
	Kernel-5_83:4.16
	Kernel-5_82:4.16
	Kernel-5_81:4.16
	Kernel-5_80:4.16
	Kernel-5_79:4.16
	Kernel-5_78:4.16
	Kernel-5_77:4.16
	Kernel-5_76:4.16
	Kernel-5_75:4.16
	Kernel-5_74:4.16
	Kernel-5_73:4.16
	Kernel-5_72:4.16
	Kernel-5_71:4.16
	Kernel-5_70:4.16
	Kernel-5_69:4.16
	Kernel-5_68:4.16
	Kernel-5_67:4.16
	Kernel-5_66:4.16
	Kernel-5_65:4.16
	Kernel-5_64:4.16
	Kernel-5_63:4.16
	Kernel-5_62:4.16
	Kernel-5_61:4.16
	Kernel-5_60:4.16
	Kernel-5_59:4.16
	Kernel-5_58:4.16
	Kernel-5_57:4.16
	Kernel-5_56:4.16
	Kernel-5_55:4.16
	Kernel-5_54:4.16
	Kernel-5_53:4.16
	Kernel-5_52:4.16
	Kernel-5_51:4.16
	Kernel-5_50:4.16
	Kernel-5_49:4.15
	HAL_merge:4.11.2.34
	Kernel-5_48:4.14
	Kernel-5_35-4_79_2_327:4.11.2.34
	Kernel-5_35-4_79_2_326:4.11.2.34
	Kernel-5_35-4_79_2_325:4.11.2.34
	Kernel-5_35-4_79_2_324:4.11.2.34
	Kernel-5_35-4_79_2_323:4.11.2.34
	Kernel-5_35-4_79_2_322:4.11.2.34
	Kernel-5_35-4_79_2_321:4.11.2.34
	Kernel-5_35-4_79_2_320:4.11.2.34
	Kernel-5_35-4_79_2_319:4.11.2.34
	Kernel-5_35-4_79_2_318:4.11.2.34
	Kernel-5_35-4_79_2_317:4.11.2.33
	Kernel-5_35-4_79_2_316:4.11.2.33
	Kernel-5_35-4_79_2_315:4.11.2.33
	Kernel-5_35-4_79_2_314:4.11.2.33
	Kernel-5_35-4_79_2_313:4.11.2.33
	Kernel-5_35-4_79_2_312:4.11.2.33
	Kernel-5_35-4_79_2_311:4.11.2.33
	Kernel-5_35-4_79_2_310:4.11.2.33
	Kernel-5_35-4_79_2_309:4.11.2.33
	Kernel-5_35-4_79_2_308:4.11.2.33
	Kernel-5_35-4_79_2_307:4.11.2.33
	Kernel-5_35-4_79_2_306:4.11.2.33
	Kernel-5_35-4_79_2_305:4.11.2.33
	Kernel-5_35-4_79_2_304:4.11.2.33
	Kernel-5_35-4_79_2_303:4.11.2.33
	Kernel-5_35-4_79_2_302:4.11.2.33
	Kernel-5_35-4_79_2_301:4.11.2.33
	Kernel-5_35-4_79_2_300:4.11.2.33
	Kernel-5_35-4_79_2_299:4.11.2.33
	Kernel-5_35-4_79_2_298:4.11.2.32
	Kernel-5_35-4_79_2_297:4.11.2.31
	Kernel-5_35-4_79_2_296:4.11.2.31
	Kernel-5_35-4_79_2_295:4.11.2.31
	Kernel-5_35-4_79_2_294:4.11.2.31
	Kernel-5_35-4_79_2_293:4.11.2.31
	Kernel-5_35-4_79_2_292:4.11.2.31
	Kernel-5_35-4_79_2_291:4.11.2.31
	Kernel-5_35-4_79_2_290:4.11.2.31
	Kernel-5_35-4_79_2_289:4.11.2.30
	Kernel-5_35-4_79_2_288:4.11.2.29
	Kernel-5_35-4_79_2_287:4.11.2.28
	Kernel-5_35-4_79_2_286:4.11.2.28
	Kernel-5_35-4_79_2_285:4.11.2.28
	Kernel-5_35-4_79_2_284:4.11.2.28
	Kernel-5_35-4_79_2_283:4.11.2.28
	Kernel-5_35-4_79_2_282:4.11.2.28
	Kernel-5_35-4_79_2_281:4.11.2.28
	Kernel-5_35-4_79_2_280:4.11.2.28
	Kernel-5_35-4_79_2_279:4.11.2.28
	Kernel-5_35-4_79_2_278:4.11.2.28
	Kernel-5_35-4_79_2_277:4.11.2.28
	Kernel-5_35-4_79_2_276:4.11.2.28
	Kernel-5_35-4_79_2_275:4.11.2.28
	Kernel-5_35-4_79_2_274:4.11.2.28
	Kernel-5_35-4_79_2_273:4.11.2.28
	Kernel-5_35-4_79_2_272:4.11.2.28
	Kernel-5_35-4_79_2_271:4.11.2.28
	Kernel-5_35-4_79_2_270:4.11.2.28
	Kernel-5_35-4_79_2_269:4.11.2.28
	Kernel-5_35-4_79_2_268:4.11.2.28
	Kernel-5_35-4_79_2_267:4.11.2.28
	Kernel-5_35-4_79_2_266:4.11.2.28
	Kernel-5_35-4_79_2_265:4.11.2.28
	Kernel-5_35-4_79_2_264:4.11.2.28
	Kernel-5_35-4_79_2_263:4.11.2.28
	Kernel-5_35-4_79_2_262:4.11.2.28
	Kernel-5_35-4_79_2_261:4.11.2.28
	Kernel-5_35-4_79_2_260:4.11.2.28
	Kernel-5_35-4_79_2_259:4.11.2.28
	Kernel-5_35-4_79_2_258:4.11.2.28
	Kernel-5_35-4_79_2_257:4.11.2.28
	Kernel-5_35-4_79_2_256:4.11.2.28
	Kernel-5_35-4_79_2_255:4.11.2.27
	Kernel-5_35-4_79_2_254:4.11.2.27
	Kernel-5_35-4_79_2_253:4.11.2.27
	Kernel-5_35-4_79_2_252:4.11.2.27
	Kernel-5_35-4_79_2_251:4.11.2.27
	Kernel-5_35-4_79_2_250:4.11.2.27
	Kernel-5_35-4_79_2_249:4.11.2.27
	Kernel-5_35-4_79_2_248:4.11.2.27
	Kernel-5_35-4_79_2_247:4.11.2.27
	Kernel-5_35-4_79_2_246:4.11.2.26
	Kernel-5_35-4_79_2_245:4.11.2.26
	Kernel-5_35-4_79_2_244:4.11.2.26
	Kernel-5_35-4_79_2_243:4.11.2.26
	Kernel-5_35-4_79_2_242:4.11.2.26
	Kernel-5_35-4_79_2_241:4.11.2.26
	Kernel-5_35-4_79_2_240:4.11.2.26
	Kernel-5_35-4_79_2_239:4.11.2.26
	Kernel-5_35-4_79_2_238:4.11.2.25
	Kernel-5_35-4_79_2_237:4.11.2.25
	Kernel-5_35-4_79_2_236:4.11.2.25
	Kernel-5_35-4_79_2_235:4.11.2.25
	Kernel-5_35-4_79_2_234:4.11.2.25
	Kernel-5_35-4_79_2_233:4.11.2.25
	Kernel-5_35-4_79_2_232:4.11.2.25
	Kernel-5_35-4_79_2_231:4.11.2.25
	Kernel-5_35-4_79_2_230:4.11.2.25
	Kernel-5_35-4_79_2_229:4.11.2.25
	Kernel-5_35-4_79_2_228:4.11.2.25
	Kernel-5_35-4_79_2_227:4.11.2.25
	Kernel-5_35-4_79_2_226:4.11.2.25
	Kernel-5_35-4_79_2_225:4.11.2.25
	Kernel-5_35-4_79_2_224:4.11.2.25
	Kernel-5_35-4_79_2_223:4.11.2.25
	Kernel-5_35-4_79_2_222:4.11.2.25
	Kernel-5_35-4_79_2_221:4.11.2.25
	Kernel-5_35-4_79_2_220:4.11.2.25
	Kernel-5_35-4_79_2_219:4.11.2.25
	Kernel-5_35-4_79_2_218:4.11.2.25
	Kernel-5_35-4_79_2_217:4.11.2.25
	Kernel-5_35-4_79_2_216:4.11.2.25
	Kernel-5_35-4_79_2_215:4.11.2.25
	Kernel-5_35-4_79_2_214:4.11.2.25
	Kernel-5_35-4_79_2_213:4.11.2.25
	Kernel-5_35-4_79_2_212:4.11.2.25
	Kernel-5_35-4_79_2_211:4.11.2.25
	Kernel-5_35-4_79_2_210:4.11.2.25
	Kernel-5_35-4_79_2_209:4.11.2.25
	Kernel-5_35-4_79_2_208:4.11.2.25
	Kernel-5_35-4_79_2_207:4.11.2.25
	Kernel-5_35-4_79_2_206:4.11.2.25
	Kernel-5_35-4_79_2_205:4.11.2.25
	Kernel-5_35-4_79_2_204:4.11.2.25
	Kernel-5_35-4_79_2_203:4.11.2.25
	Kernel-5_35-4_79_2_202:4.11.2.25
	Kernel-5_35-4_79_2_201:4.11.2.24
	Kernel-5_35-4_79_2_200:4.11.2.24
	Kernel-5_35-4_79_2_199:4.11.2.24
	Kernel-5_35-4_79_2_198:4.11.2.24
	Kernel-5_35-4_79_2_197:4.11.2.24
	Kernel-5_35-4_79_2_196:4.11.2.24
	Kernel-5_35-4_79_2_195:4.11.2.24
	Kernel-5_35-4_79_2_194:4.11.2.24
	Kernel-5_35-4_79_2_193:4.11.2.24
	Kernel-5_35-4_79_2_192:4.11.2.24
	Kernel-5_35-4_79_2_191:4.11.2.24
	Kernel-5_35-4_79_2_190:4.11.2.24
	Kernel-5_35-4_79_2_189:4.11.2.24
	Kernel-5_35-4_79_2_188:4.11.2.24
	Kernel-5_35-4_79_2_187:4.11.2.24
	Kernel-5_35-4_79_2_186:4.11.2.24
	Kernel-5_35-4_79_2_185:4.11.2.24
	Kernel-5_35-4_79_2_184:4.11.2.24
	Kernel-5_35-4_79_2_183:4.11.2.24
	Kernel-5_35-4_79_2_182:4.11.2.23
	Kernel-5_35-4_79_2_181:4.11.2.23
	Kernel-5_35-4_79_2_180:4.11.2.23
	Kernel-5_35-4_79_2_179:4.11.2.22
	Kernel-5_35-4_79_2_178:4.11.2.22
	Kernel-5_35-4_79_2_177:4.11.2.22
	Kernel-5_35-4_79_2_176:4.11.2.22
	Kernel-5_35-4_79_2_175:4.11.2.22
	Kernel-5_35-4_79_2_174:4.11.2.22
	Kernel-5_35-4_79_2_173:4.11.2.22
	Kernel-5_35-4_79_2_172:4.11.2.22
	Kernel-5_35-4_79_2_171:4.11.2.22
	Kernel-5_35-4_79_2_170:4.11.2.22
	Kernel-5_35-4_79_2_169:4.11.2.22
	Kernel-5_35-4_79_2_168:4.11.2.22
	Kernel-5_35-4_79_2_167:4.11.2.22
	Kernel-5_35-4_79_2_166:4.11.2.22
	Kernel-5_35-4_79_2_165:4.11.2.22
	RPi_merge:4.11.2.22
	Kernel-5_35-4_79_2_147_2_23:4.11.2.22
	Kernel-5_35-4_79_2_147_2_22:4.11.2.22
	Kernel-5_35-4_79_2_147_2_21:4.11.2.22
	Kernel-5_35-4_79_2_147_2_20:4.11.2.22
	Kernel-5_35-4_79_2_147_2_19:4.11.2.22
	Kernel-5_35-4_79_2_147_2_18:4.11.2.22
	Kernel-5_35-4_79_2_164:4.11.2.22
	Kernel-5_35-4_79_2_163:4.11.2.22
	Kernel-5_35-4_79_2_147_2_17:4.11.2.22
	Kernel-5_35-4_79_2_147_2_16:4.11.2.22
	Kernel-5_35-4_79_2_147_2_15:4.11.2.22
	Kernel-5_35-4_79_2_162:4.11.2.22
	Kernel-5_35-4_79_2_161:4.11.2.22
	Kernel-5_35-4_79_2_147_2_14:4.11.2.22
	Kernel-5_35-4_79_2_147_2_13:4.11.2.22
	Kernel-5_35-4_79_2_160:4.11.2.22
	Kernel-5_35-4_79_2_159:4.11.2.22
	Kernel-5_35-4_79_2_158:4.11.2.22
	Kernel-5_35-4_79_2_157:4.11.2.22
	Kernel-5_35-4_79_2_156:4.11.2.22
	Kernel-5_35-4_79_2_147_2_12:4.11.2.22
	Kernel-5_35-4_79_2_147_2_11:4.11.2.22
	Kernel-5_35-4_79_2_155:4.11.2.22
	Kernel-5_35-4_79_2_147_2_10:4.11.2.22
	Kernel-5_35-4_79_2_154:4.11.2.22
	Kernel-5_35-4_79_2_153:4.11.2.22
	Kernel-5_35-4_79_2_147_2_9:4.11.2.22
	Kernel-5_35-4_79_2_152:4.11.2.22
	Kernel-5_35-4_79_2_151:4.11.2.22
	Kernel-5_35-4_79_2_147_2_8:4.11.2.22
	Kernel-5_35-4_79_2_147_2_7:4.11.2.22
	Kernel-5_35-4_79_2_150:4.11.2.22
	Kernel-5_35-4_79_2_147_2_6:4.11.2.22
	Kernel-5_35-4_79_2_147_2_5:4.11.2.22
	Kernel-5_35-4_79_2_149:4.11.2.22
	Kernel-5_35-4_79_2_147_2_4:4.11.2.22
	Kernel-5_35-4_79_2_147_2_3:4.11.2.22
	Kernel-5_35-4_79_2_148:4.11.2.22
	Kernel-5_35-4_79_2_147_2_2:4.11.2.22
	Kernel-5_35-4_79_2_147_2_1:4.11.2.22
	RPi:4.11.2.22.0.2
	RPi_bp:4.11.2.22
	Kernel-5_35-4_79_2_98_2_52_2_1:4.11.2.18.2.7
	alees_Kernel_dev:4.11.2.18.2.7.0.2
	alees_Kernel_dev_bp:4.11.2.18.2.7
	Kernel-5_35-4_79_2_147:4.11.2.22
	Kernel-5_35-4_79_2_146:4.11.2.22
	Kernel-5_35-4_79_2_145:4.11.2.22
	Kernel-5_35-4_79_2_144:4.11.2.22
	Kernel-5_35-4_79_2_143:4.11.2.22
	Kernel-5_35-4_79_2_142:4.11.2.22
	Kernel-5_35-4_79_2_141:4.11.2.22
	Kernel-5_35-4_79_2_140:4.11.2.22
	Kernel-5_35-4_79_2_139:4.11.2.22
	Kernel-5_35-4_79_2_138:4.11.2.22
	Kernel-5_35-4_79_2_137:4.11.2.22
	Kernel-5_35-4_79_2_136:4.11.2.22
	Kernel-5_35-4_79_2_135:4.11.2.22
	Kernel-5_35-4_79_2_134:4.11.2.22
	Kernel-5_35-4_79_2_133:4.11.2.22
	Kernel-5_35-4_79_2_132:4.11.2.22
	Kernel-5_35-4_79_2_131:4.11.2.22
	Kernel-5_35-4_79_2_130:4.11.2.22
	Kernel-5_35-4_79_2_129:4.11.2.22
	Kernel-5_35-4_79_2_128:4.11.2.22
	Kernel-5_35-4_79_2_127:4.11.2.22
	Kernel-5_35-4_79_2_126:4.11.2.22
	Kernel-5_35-4_79_2_125:4.11.2.22
	Kernel-5_35-4_79_2_124:4.11.2.22
	Kernel-5_35-4_79_2_123:4.11.2.21
	Cortex_merge:4.11.2.18.2.7
	Kernel-5_35-4_79_2_122:4.11.2.20
	Kernel-5_35-4_79_2_98_2_54:4.11.2.18.2.7
	Kernel-5_35-4_79_2_98_2_53:4.11.2.18.2.7
	Kernel-5_35-4_79_2_98_2_52:4.11.2.18.2.7
	Kernel-5_35-4_79_2_98_2_51:4.11.2.18.2.7
	Kernel-5_35-4_79_2_98_2_50:4.11.2.18.2.7
	Kernel-5_35-4_79_2_98_2_49:4.11.2.18.2.7
	Kernel-5_35-4_79_2_98_2_48:4.11.2.18.2.7
	Kernel-5_35-4_79_2_121:4.11.2.20
	Kernel-5_35-4_79_2_98_2_47:4.11.2.18.2.6
	Kernel-5_35-4_79_2_120:4.11.2.20
	Kernel-5_35-4_79_2_98_2_46:4.11.2.18.2.6
	Kernel-5_35-4_79_2_119:4.11.2.20
	Kernel-5_35-4_79_2_98_2_45:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_44:4.11.2.18.2.6
	Kernel-5_35-4_79_2_118:4.11.2.20
	Kernel-5_35-4_79_2_98_2_43:4.11.2.18.2.6
	Kernel-5_35-4_79_2_117:4.11.2.20
	Kernel-5_35-4_79_2_116:4.11.2.20
	Kernel-5_35-4_79_2_98_2_42:4.11.2.18.2.6
	Kernel-5_35-4_79_2_115:4.11.2.20
	Kernel-5_35-4_79_2_98_2_41:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_40:4.11.2.18.2.6
	Kernel-5_35-4_79_2_114:4.11.2.20
	Kernel-5_35-4_79_2_98_2_39:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_38:4.11.2.18.2.6
	Kernel-5_35-4_79_2_113:4.11.2.20
	Kernel-5_35-4_79_2_112:4.11.2.20
	Kernel-5_35-4_79_2_98_2_37:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_36:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_35:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_34:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_33:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_32:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_31:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_30:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_29:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_28:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_27:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_26:4.11.2.18.2.6
	Kernel-5_35-4_79_2_111:4.11.2.20
	Kernel-5_35-4_79_2_98_2_25:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_24:4.11.2.18.2.6
	Kernel-5_35-4_79_2_98_2_23:4.11.2.18.2.6
	Kernel-5_35-4_79_2_110:4.11.2.20
	Kernel-5_35-4_79_2_98_2_22:4.11.2.18.2.5
	Kernel-5_35-4_79_2_109:4.11.2.19
	Kernel-5_35-4_79_2_98_2_21:4.11.2.18.2.4
	Kernel-5_35-4_79_2_98_2_20:4.11.2.18.2.3
	Kernel-5_35-4_79_2_108:4.11.2.18
	Kernel-5_35-4_79_2_107:4.11.2.18
	Kernel-5_35-4_79_2_98_2_19:4.11.2.18.2.3
	Kernel-5_35-4_79_2_98_2_18:4.11.2.18.2.3
	Kernel-5_35-4_79_2_98_2_17:4.11.2.18.2.3
	Kernel-5_35-4_79_2_98_2_16:4.11.2.18.2.3
	Kernel-5_35-4_79_2_98_2_15:4.11.2.18.2.3
	Kernel-5_35-4_79_2_106:4.11.2.18
	Kernel-5_35-4_79_2_105:4.11.2.18
	Kernel-5_35-4_79_2_104:4.11.2.18
	Kernel-5_35-4_79_2_98_2_14:4.11.2.18.2.3
	Kernel-5_35-4_79_2_98_2_13:4.11.2.18.2.3
	Kernel-5_35-4_79_2_98_2_12:4.11.2.18.2.2
	Kernel-5_35-4_79_2_98_2_11:4.11.2.18.2.2
	Kernel-5_35-4_79_2_98_2_10:4.11.2.18.2.1
	Kernel-5_35-4_79_2_98_2_9:4.11.2.18.2.1
	Kernel-5_35-4_79_2_103:4.11.2.18
	Kernel-5_35-4_79_2_102:4.11.2.18
	Kernel-5_35-4_79_2_98_2_8:4.11.2.18
	Kernel-5_35-4_79_2_98_2_7:4.11.2.18
	Kernel-5_35-4_79_2_98_2_6:4.11.2.18
	Kernel-5_35-4_79_2_98_2_5:4.11.2.18
	Kernel-5_35-4_79_2_98_2_4:4.11.2.18
	Kernel-5_35-4_79_2_101:4.11.2.18
	Kernel-5_35-4_79_2_100:4.11.2.18
	Kernel-5_35-4_79_2_99:4.11.2.18
	Kernel-5_35-4_79_2_98_2_3:4.11.2.18
	Kernel-5_35-4_79_2_98_2_2:4.11.2.18
	Kernel-5_35-4_79_2_98_2_1:4.11.2.18
	Cortex:4.11.2.18.0.2
	Cortex_bp:4.11.2.18
	Kernel-5_35-4_79_2_98:4.11.2.18
	Kernel-5_35-4_79_2_97:4.11.2.17
	Kernel-5_35-4_79_2_96:4.11.2.17
	Kernel-5_35-4_79_2_95:4.11.2.17
	Kernel-5_35-4_79_2_94:4.11.2.17
	Kernel-5_35-4_79_2_93:4.11.2.17
	Kernel-5_35-4_79_2_92:4.11.2.17
	Kernel-5_35-4_79_2_91:4.11.2.17
	Kernel-5_35-4_79_2_90:4.11.2.17
	Kernel-5_35-4_79_2_89:4.11.2.17
	Kernel-5_35-4_79_2_88:4.11.2.17
	Kernel-5_35-4_79_2_87:4.11.2.17
	Kernel-5_35-4_79_2_86:4.11.2.17
	Kernel-5_35-4_79_2_85:4.11.2.17
	Kernel-5_35-4_79_2_84:4.11.2.17
	Kernel-5_35-4_79_2_83:4.11.2.16
	Kernel-5_35-4_79_2_82:4.11.2.16
	Kernel-5_35-4_79_2_81:4.11.2.16
	Kernel-5_35-4_79_2_80:4.11.2.16
	Kernel-5_35-4_79_2_79:4.11.2.16
	Kernel-5_35-4_79_2_78:4.11.2.16
	Kernel-5_35-4_79_2_77:4.11.2.16
	RO_5_07:4.11.2.16
	Kernel-5_35-4_79_2_76:4.11.2.16
	Kernel-5_35-4_79_2_75:4.11.2.16
	Kernel-5_35-4_79_2_74:4.11.2.15
	Kernel-5_35-4_79_2_73:4.11.2.14
	Kernel-5_35-4_79_2_72:4.11.2.14
	Kernel-5_35-4_79_2_71:4.11.2.14
	Kernel-5_35-4_79_2_70:4.11.2.13
	Kernel-5_35-4_79_2_69:4.11.2.13
	Kernel-5_35-4_79_2_68:4.11.2.13
	Kernel-5_35-4_79_2_67:4.11.2.13
	Kernel-5_35-4_79_2_66:4.11.2.13
	Kernel-5_35-4_79_2_65:4.11.2.13
	Kernel-5_35-4_79_2_64:4.11.2.13
	Kernel-5_35-4_79_2_63:4.11.2.13
	Kernel-5_35-4_79_2_62:4.11.2.13
	Kernel-5_35-4_79_2_61:4.11.2.13
	Kernel-5_35-4_79_2_59:4.11.2.13
	Kernel-5_35-4_79_2_58:4.11.2.13
	Kernel-5_35-4_79_2_57:4.11.2.13
	Kernel-5_35-4_79_2_56:4.11.2.13
	Kernel-5_35-4_79_2_55:4.11.2.13
	Kernel-5_35-4_79_2_54:4.11.2.13
	Kernel-5_35-4_79_2_53:4.11.2.13
	Kernel-5_35-4_79_2_52:4.11.2.13
	Kernel-5_35-4_79_2_51:4.11.2.13
	Kernel-5_35-4_79_2_50:4.11.2.12
	Kernel-5_35-4_79_2_49:4.11.2.12
	Kernel-5_35-4_79_2_48:4.11.2.12
	Kernel-5_47:4.13
	Kernel-5_46-4_90_2_1:4.13
	nbingham_Kernel_FastNC_dev_bp:4.13
	nbingham_Kernel_FastNC_dev:4.13.0.2
	Kernel-5_46:4.13
	Kernel-5_45:4.13
	Kernel-5_35-4_79_2_47:4.11.2.11
	Kernel-5_35-4_79_2_46:4.11.2.11
	Kernel-5_35-4_79_2_45:4.11.2.11
	Kernel-5_35-4_79_2_44:4.11.2.11
	Kernel-5_35-4_79_2_25_2_2:4.11.2.9
	Kernel-5_35-4_79_2_43:4.11.2.11
	Kernel-5_35-4_79_2_42:4.11.2.11
	Kernel-5_35-4_79_2_41:4.11.2.11
	Kernel-5_35-4_79_2_40:4.11.2.11
	Kernel-5_35-4_79_2_39:4.11.2.11
	Kernel-5_35-4_79_2_38:4.11.2.11
	Kernel-5_35-4_79_2_37:4.11.2.11
	Kernel-5_35-4_79_2_36:4.11.2.11
	Kernel-5_35-4_79_2_35:4.11.2.11
	Kernel-5_35-4_79_2_34:4.11.2.11
	Kernel-5_35-4_79_2_33:4.11.2.11
	Kernel-5_35-4_79_2_32:4.11.2.11
	Kernel-5_44:4.13
	Kernel-5_35-4_79_2_25_2_1:4.11.2.9
	Kernel-5_43:4.13
	Kernel-5_35-4_79_2_31:4.11.2.11
	Kernel-5_35-4_79_2_30:4.11.2.11
	Kernel-5_35-4_79_2_29:4.11.2.10
	Kernel-5_35-4_79_2_28:4.11.2.10
	Kernel-5_35-4_79_2_27:4.11.2.10
	Kernel-5_35-4_79_2_26:4.11.2.10
	Kernel-5_42:4.13
	Kernel-5_41:4.12
	Kernel-5_40:4.11
	Kernel-5_35-4_79_2_25:4.11.2.9
	Kernel-5_35-4_79_2_24:4.11.2.9
	Kernel-5_35-4_79_2_23:4.11.2.9
	Kernel-5_35-4_79_2_22:4.11.2.9
	Kernel-5_35-4_79_2_21:4.11.2.9
	Kernel-5_35-4_79_2_20:4.11.2.8
	Kernel-5_35-4_79_2_19:4.11.2.7
	Kernel-5_35-4_79_2_18:4.11.2.6
	Kernel-5_35-4_79_2_17:4.11.2.6
	Kernel-5_35-4_79_2_16:4.11.2.6
	Kernel-5_35-4_79_2_15:4.11.2.6
	Kernel-5_35-4_79_2_14:4.11.2.6
	Kernel-5_39:4.11
	Kernel-5_13-4_52_2_1:4.7
	Bethany:4.7.0.2
	Kernel-5_38:4.11
	Kernel-5_35-4_79_2_13:4.11.2.6
	Kernel-5_35-4_79_2_12:4.11.2.6
	Kernel-5_35-4_79_2_11:4.11.2.6
	Kernel-5_37:4.11
	Kernel-5_35-4_79_2_10:4.11.2.6
	Kernel-5_35-4_79_2_9:4.11.2.6
	Kernel-5_36:4.11
	Kernel-5_35-4_79_2_8:4.11.2.4
	Kernel-5_35-4_79_2_7:4.11.2.3
	Kernel-5_35-4_79_2_6:4.11.2.3
	Kernel-5_35-4_79_2_5:4.11.2.3
	Kernel-5_35-4_79_2_4:4.11.2.3
	Kernel-5_35-4_79_2_3:4.11.2.3
	Kernel-5_35-4_79_2_2:4.11.2.2
	dellis_autobuild_BaseSW:4.11
	Kernel-5_35-4_79_2_1:4.11.2.1
	HAL:4.11.0.2
	Kernel-5_35:4.11
	Kernel-5_34:4.10
	Kernel-5_33:4.10
	Kernel-5_32:4.9
	Kernel-5_31:4.9
	Kernel-5_30:4.9
	Kernel-5_29:4.9
	Kernel-5_28:4.9
	Kernel-5_27:4.9
	Kernel-5_26:4.9
	Kernel-5_25:4.9
	Kernel-5_24:4.9
	Kernel-5_23:4.9
	Kernel-5_22:4.8
	sbrodie_sedwards_16Mar2000:4.8
	Kernel-5_21:4.8
	Kernel-5_20:4.8
	Kernel-5_19:4.8
	Kernel-5_18:4.8
	Kernel-5_17:4.8
	Kernel-5_16:4.8
	Kernel-5_15:4.8
	Kernel-5_14:4.8
	Kernel-5_13:4.7
	Kernel-5_12:4.7
	Kernel-5_11:4.7
	Kernel-5_10:4.7
	Kernel-5_09:4.6
	Kernel-5_08:4.6
	Kernel-5_07:4.6
	Kernel-5_06:4.6
	Kernel-5_05:4.6
	Kernel-5_04:4.6
	Kernel-5_03:4.6
	Kernel-5_02:4.6
	Kernel-5_01:4.6
	Kernel-5_00:4.6
	Kernel-4_99:4.6
	Kernel-4_98:4.6
	Kernel-4_97:4.6
	Kernel-4_96:4.6
	Kernel-4_95:4.6
	Kernel-4_94:4.6
	Kernel-4_93:4.6
	Kernel-4_92:4.6
	Kernel-4_91:4.6
	Kernel-4_90:4.6
	dcotton_autobuild_BaseSW:4.13
	Kernel-4_89:4.5
	Kernel-4_88:4.4
	Kernel-4_87:4.4
	Kernel-4_86:4.4
	Kernel-4_85:4.4
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.1.2.1
	Kernel-4_84:4.4
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.1.2.1
	Ursula_RiscPC_bp:4.2.2.1
	Kernel-4_83:4.4
	Kernel-4_82:4.4
	Kernel-4_81:4.4
	Kernel-4_80:4.3
	Kernel-4_79:4.3
	Kernel-4_78:4.3
	Kernel-4_77:4.3
	Kernel-4_76:4.3
	Kernel-4_75:4.3
	Kernel-4_74:4.3
	Kernel-4_73:4.3
	Kernel-4_72:4.3
	Kernel-4_71:4.3
	Kernel-4_70:4.3
	Kernel-4_69:4.3
	Kernel-4_68:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.12
	Kernel-4_63-1_1_2_4:4.1.7.12
	Kernel-4_67:4.3
	Kernel-4_66:4.3
	Kernel-4_63-1_1_2_3:4.1.7.12
	Kernel-4_65:4.3
	Ursula_merge:4.2
	Kernel-4_64:4.3
	mstphens_Kernel-3_81:4.2.2.2
	Kernel-4_63-1_1_2_2:4.1.7.12
	nicke_Kernel_4_62:4.1.7.11
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	nturton_v459:4.1.7.10
	nturton_v460:4.1.7.10
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	mstphens_Kernel-3_80:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	afrost_Boca-1_2-Beta:4.1.7.10
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.10
	Spinner_B20_2:4.1.7.10
	Spinner_19_3:4.1.7.10
	Spinner_B18:4.1.7.10
	Spinner_B17:4.1.7.10
	Spinner_B15:4.1.7.10
	Spinner_B14:4.1.7.10
	Spinner_B13:4.1.7.10
	Spinner_B12:4.1.7.9
	Spinner_B10:4.1.7.9
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.8
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.4
	Spin_3Apr97:4.1.7.5
	ARTtmp:4.1.7.4.0.2
	Spin_merge:4.1.7.12
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.17
date	2017.09.09.10.15.59;	author rool;	state Exp;
branches;
next	4.16;
commitid	TduffhFf7pAzwv6A;

4.16
date	2016.06.30.20.42.08;	author jlee;	state Exp;
branches
	4.16.2.1;
next	4.15;
commitid	bDF3DCxdmyMD0xcz;

4.15
date	2016.06.30.20.29.02;	author jlee;	state Exp;
branches;
next	4.14;
commitid	lMnWzoE9eJz3Wwcz;

4.14
date	2016.06.30.20.08.16;	author jlee;	state Exp;
branches;
next	4.13;
commitid	IWoXxARWeuLDOwcz;

4.13
date	2001.04.10.12.51.05;	author dcotton;	state Exp;
branches;
next	4.12;

4.12
date	2001.04.10.07.46.24;	author dcotton;	state Exp;
branches;
next	4.11;

4.11
date	2000.09.08.14.15.21;	author rcathera;	state Exp;
branches
	4.11.2.1;
next	4.10;

4.10
date	2000.09.04.18.47.59;	author rcathera;	state Exp;
branches;
next	4.9;

4.9
date	2000.04.04.14.27.35;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2000.01.27.14.25.30;	author sbrodie;	state Exp;
branches;
next	4.7;

4.7
date	2000.01.26.11.38.49;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.09.29.17.09.30;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.09.23.16.47.45;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.08.03.09.59.14;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.09.30.08.42.45;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.07.23;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.28;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.16.2.1
date	2017.09.10.11.27.25;	author jlee;	state Exp;
branches;
next	;
commitid	EGooxXrB27MqTD6A;

4.11.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.11.2.2;

4.11.2.2
date	2000.10.02.08.52.20;	author kbracey;	state Exp;
branches;
next	4.11.2.3;

4.11.2.3
date	2000.10.03.12.05.59;	author mstephen;	state Exp;
branches;
next	4.11.2.4;

4.11.2.4
date	2000.10.05.16.46.36;	author dellis;	state Exp;
branches;
next	4.11.2.5;

4.11.2.5
date	2000.10.06.09.08.11;	author kbracey;	state Exp;
branches;
next	4.11.2.6;

4.11.2.6
date	2000.10.09.15.59.16;	author kbracey;	state Exp;
branches;
next	4.11.2.7;

4.11.2.7
date	2001.03.07.15.12.59;	author kbracey;	state Exp;
branches;
next	4.11.2.8;

4.11.2.8
date	2001.03.16.15.30.03;	author kbracey;	state Exp;
branches;
next	4.11.2.9;

4.11.2.9
date	2001.03.19.16.07.23;	author kbracey;	state Exp;
branches;
next	4.11.2.10;

4.11.2.10
date	2001.04.11.09.12.11;	author kbracey;	state Exp;
branches;
next	4.11.2.11;

4.11.2.11
date	2001.05.17.10.51.12;	author kbracey;	state Exp;
branches;
next	4.11.2.12;

4.11.2.12
date	2002.10.07.17.29.43;	author kbracey;	state Exp;
branches;
next	4.11.2.13;

4.11.2.13
date	2002.11.30.00.31.11;	author bavison;	state Exp;
branches;
next	4.11.2.14;

4.11.2.14
date	2004.06.25.15.07.14;	author kbracey;	state Exp;
branches;
next	4.11.2.15;

4.11.2.15
date	2004.09.06.22.48.00;	author jballance;	state Exp;
branches;
next	4.11.2.16;

4.11.2.16
date	2004.09.08.10.10.25;	author jballance;	state Exp;
branches;
next	4.11.2.17;

4.11.2.17
date	2005.03.21.16.43.29;	author kbracey;	state Exp;
branches;
next	4.11.2.18;

4.11.2.18
date	2008.12.22.02.03.22;	author bavison;	state Exp;
branches
	4.11.2.18.2.1;
next	4.11.2.19;

4.11.2.19
date	2010.02.02.01.03.02;	author jlee;	state Exp;
branches;
next	4.11.2.20;

4.11.2.20
date	2010.02.20.01.42.36;	author jlee;	state Exp;
branches;
next	4.11.2.21;

4.11.2.21
date	2011.11.26.21.11.23;	author jlee;	state Exp;
branches;
next	4.11.2.22;
commitid	cI3W0zbtALQG6TIv;

4.11.2.22
date	2011.11.27.11.48.14;	author rsprowson;	state Exp;
branches;
next	4.11.2.23;
commitid	OFgqaKhOb6swXXIv;

4.11.2.23
date	2013.01.10.21.19.12;	author rsprowson;	state Exp;
branches;
next	4.11.2.24;
commitid	F6D8WGw2f7PkWHzw;

4.11.2.24
date	2013.01.27.17.50.30;	author rsprowson;	state Exp;
branches;
next	4.11.2.25;
commitid	tDlfhdSfOxFReSBw;

4.11.2.25
date	2013.11.20.20.30.02;	author rsprowson;	state Exp;
branches;
next	4.11.2.26;
commitid	X1FKtc2EAz7Jz3ex;

4.11.2.26
date	2014.10.01.07.45.04;	author rsprowson;	state Exp;
branches;
next	4.11.2.27;
commitid	vfRh4u3dz58zdtSx;

4.11.2.27
date	2014.11.13.22.19.19;	author rsprowson;	state Exp;
branches;
next	4.11.2.28;
commitid	w8sxKkSQnrGJF4Yx;

4.11.2.28
date	2015.02.02.11.42.50;	author bavison;	state Exp;
branches;
next	4.11.2.29;
commitid	MtPWA0FVKUL1yq8y;

4.11.2.29
date	2015.09.08.00.11.44;	author jballance;	state Exp;
branches;
next	4.11.2.30;
commitid	1S5PhBtGLNSsInAy;

4.11.2.30
date	2015.09.18.17.05.30;	author rool;	state Exp;
branches;
next	4.11.2.31;
commitid	SE6VV5X7tFiZYKBy;

4.11.2.31
date	2015.09.24.22.01.32;	author jballance;	state Exp;
branches;
next	4.11.2.32;
commitid	V7Omi28VtT9SryCy;

4.11.2.32
date	2015.11.08.02.10.16;	author bavison;	state Exp;
branches;
next	4.11.2.33;
commitid	LS5ibOqZw7JypeIy;

4.11.2.33
date	2015.11.14.17.14.56;	author jlee;	state Exp;
branches;
next	4.11.2.34;
commitid	AQFG2wz0zKqWd5Jy;

4.11.2.34
date	2016.05.08.17.11.12;	author jlee;	state Exp;
branches;
next	;
commitid	H8vGguuJRqFVxH5z;

4.11.2.18.2.1
date	2009.06.15.23.56.10;	author bavison;	state Exp;
branches;
next	4.11.2.18.2.2;

4.11.2.18.2.2
date	2009.07.23.00.57.12;	author jlee;	state Exp;
branches;
next	4.11.2.18.2.3;

4.11.2.18.2.3
date	2009.09.30.22.30.53;	author jlee;	state Exp;
branches;
next	4.11.2.18.2.4;

4.11.2.18.2.4
date	2010.01.24.02.35.25;	author jlee;	state Exp;
branches;
next	4.11.2.18.2.5;

4.11.2.18.2.5
date	2010.02.02.01.13.50;	author jlee;	state Exp;
branches;
next	4.11.2.18.2.6;

4.11.2.18.2.6
date	2010.02.20.01.46.52;	author jlee;	state Exp;
branches;
next	4.11.2.18.2.7;

4.11.2.18.2.7
date	2011.08.08.23.28.34;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

4.2.2.1
date	97.09.09.13.34.07;	author mstphens;	state Exp;
branches
	4.2.2.1.2.1;
next	4.2.2.2;

4.2.2.2
date	98.09.24.13.17.29;	author mstphens;	state Exp;
branches;
next	;

4.2.2.1.2.1
date	98.11.23.14.59.26;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.28;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.01.47;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.08;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.07;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.14.18.19.44;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.03.18.13.38.03;	author scormie;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.03.18.14.01.33;	author scormie;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.03.25.19.42.53;	author scormie;	state Exp;
branches;
next	4.1.7.6;

4.1.7.6
date	97.04.28.18.41.26;	author scormie;	state Exp;
branches;
next	4.1.7.7;

4.1.7.7
date	97.04.29.09.58.23;	author scormie;	state Exp;
branches;
next	4.1.7.8;

4.1.7.8
date	97.04.30.10.32.27;	author scormie;	state Exp;
branches;
next	4.1.7.9;

4.1.7.9
date	97.05.15.16.33.44;	author scormie;	state Exp;
branches;
next	4.1.7.10;

4.1.7.10
date	97.06.12.16.52.09;	author tdobson;	state Exp;
branches;
next	4.1.7.11;

4.1.7.11
date	98.07.21.17.57.42;	author nturton;	state Exp;
branches;
next	4.1.7.12;

4.1.7.12
date	98.09.24.12.36.48;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.17
log
@Fix return value from MakeChecksum
Detail:
  Return the calculated checksum from MakeChecksum, like the comment says.
Admin:
  Spotted during code review (not tagged).
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.PMF.i2cutils

; Authors JBiggs (m2), PFellows, TDobson, AGodwin

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Name  Description
; ----       ----  -----------
; 28-Mar-95  JRH   Added support for E2ROMs and/or CMOS, conditioned on
;                  E2ROMSupport which is defined elsewhere
;                  Uses RTCFitted and NVRamSize in KernelWS
; 03-Jul-96  JRH   Took out code conditioned on :LNOT: NewClockChip
;                  Fixed support for E2ROM. E2 works in the same gross way as
;                  CMOS. Any E2 fitted > 256 bytes will not be accessed by these
;                  routines.
; 07-Dec-96  AMG   Renaissance. Leave this file as is, allowing the E2ROMSupport
;                  switch to disable non-STB bits
; 12-Jun-97  TMD   (Really) fix OTP access problem.
; 17-Sep-98  KJB   Add support for 16K 24C128 EEPROM.
; 21-Sep-98  KJB   Add OS_NVMemory SWI.
; 30-Jul-99  KJB   Add support for 8K 24C64 EEPROM.
; 23-Sep-99  KJB   Remove support for 24C64, add support for 4K and 8K protectable ATMEL parts.

PhysChecksum            *       (((CheckSumCMOS + &30) :MOD: &F0) + &10)

; Device addresses
RTCAddressPHI           *       &a0     ; Philips RTC + 240 byte CMOS
E2ROMAddress2K          *       &e0     ; 24C174 device - 2K
E2ROMAddress2K_OTP      *       &60     ; 24C174 device - OTP section
E2ROMAddress4K          *       &a4     ; 24C32 device - 4K (top 1K protectable)
E2ROMAddress8K_prot     *       &a2     ; 24C64 device - 8K (top 2K protectable)
E2ROMAddress8K          *       &ae     ; 24C64 device - 8K
E2ROMAddress16K         *       &a8     ; 24C128 device - 16K
E2ROMAddress32K         *       &a6     ; 24CS256 device - 32K (top 2K possibly OTP)


; *****************************************************************************
;
;       HexToBCD - Convert byte in hex to BCD
;
; in:   R0 = byte in hex
;
; out:  R0 = byte in BCD (ie R0 := (R0 DIV 10)*16 + R0 MOD 10)
;       All other registers preserved
;

HexToBCD ROUT
        Push    "R2, R14"
        DivRem  R2, R0, #10, R14                ; R2=R0 DIV 10; R0=R0 MOD 10
        ADD     R0, R0, R2, LSL #4
        Pull    "R2, PC"

; *****************************************************************************
;
;       BCDToHex - Convert byte in BCD to hex
;
; in:   R0 = byte in BCD (ie x*16 + y)
;
; out:  R0 = byte in hex (ie x*10 + y)
;       All other registers preserved
;

BCDToHex ROUT
        Push    "R14"
        MOV     R14, R0, LSR #4                 ; R14 := x
        ADD     R14, R14, R14, LSL #1           ; R14 := x*3
        SUB     R0, R0, R14, LSL #1             ; R0 := R0 - x*6 = x*10
        Pull    "PC"

; *****************************************************************************
;
;       HTBSR9 - hex to BCD and store at "next free byte" R9
;
HTBS9   ROUT
        Push    R14
        BL      HexToBCD
        STRB    R0, [R9], #1
        Pull    PC

; *****************************************************************************
;
;       Write - Write a byte of CMOS RAM specified by logical address
;
; in:   R0 = address in CMOS RAM
;       R1 = data
;
; out:  All registers preserved
;

WriteWithError ROUT
        Push    "R0-R4, R14"
        BL      MangleCMOSAddress
        BCC     %FT05

        ADD     R13, R13, #4            ; junk stacked R0
        ADR     R0, ErrorBlock_CoreNotWriteable
 [ International
        BL      TranslateError
 |
        SETV
 ]
        Pull    "R1-R4,PC"

        MakeErrorBlock CoreNotWriteable

WriteWithoutProtection                  ; allowing write to "OTP" and protected section
        Push    "R0-R4, R14"
        BL      MangleCMOSAddress
        Pull    "R0-R4, PC", CS         ; if invalid, then exit
        MOV     R2, R0
        MOV     R3, R1
        CMP     R0, #&10
        MOVLO   R4, #&1000000           ; don't change checksum for OTP
        BLO     %FT10
        B       %FT08                   ; do change checksum for protected region

Write
        Push    "R0-R4, R14"
        BL      MangleCMOSAddress
        Pull    "R0-R4, PC", CS         ; if invalid, then exit
05
  [ E2ROMSupport
        CMP     r0, #&10
        Pull    "R0-R4, PC", CC         ; don't write to OTP section
  ]

  [ E2ROMSupport
        LDR     R14, =ZeroPage          ; don't write to protected section
        LDRB    R14, [R14, #NVRamWriteSize]
        CMP     R0, R14, LSL #8         ; (note assumption that NVRamWriteSize is
        Pull    "R0-R4, PC", HS         ; outside mangled region).
  ]

        MOV     R2, R0
        MOV     R3, R1
08
 [ ChecksumCMOS
        BL      ReadStraight            ; calculate new checksum :
        MOV     R4, R0
        TEQ     R4, R3                  ; don't bother with write if
        Pull    "R0-R4, PC", EQ         ; oldcontents == newcontents

        MOV     R0, #PhysChecksum
        BL      ReadStraight
        SUB     R0, R0, R4              ; = oldsum - oldcontents
        ADD     R4, R0, R3              ;          + newcontents

        AND     R4, R4, #&FF
        CMPS    R2, #PhysChecksum       ; don't write new checksum ...
        ORREQ   R4, R4, #&1000000       ; if checksum is being written
 ]
10
        CMP     r2, #&100               ; check small cache limit
        BCS     %FT15
        LDR     R1, =ZeroPage+CMOSRAMCache      ; update cache, but always write to
        STRB    R3, [R1, R2]            ; real hardware as well
15

        Push    "R2,R3,sb,R12"
        AddressHAL
        CallHAL HAL_NVMemoryType
        AND     R0, R0, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_None

        ; If there's no NVmemory, all we have is the internal cache.
        Pull    "R2,R3,sb,R12", EQ
        Pull    "R0-R4,PC", EQ

        TEQ     R0, #NVMemoryFlag_HAL
        BNE     %FT20                   ; Go and do IIC stuff.

        ; Make the HAL call - we have to write the data into a buffer.
        Pull    "R0"
        STRB    R3, [sp, #-4]!
        MOV     R1, sp
        MOV     R2, #1
        CallHAL HAL_NVMemoryWrite
        TST     R4, #&1000000
        BNE     %FT18
        LDR     R1, =ZeroPage+CMOSRAMCache
        STRB    R4, [R1, #PhysChecksum]
        STRB    R4, [sp]
        MOV     R0, #PhysChecksum
        MOV     R1, sp
        MOV     R2, #1
        CallHAL HAL_NVMemoryWrite
18
        ADD     sp, sp, #4
        Pull    "R3,sb,R12"
        Pull    "R0-R4,PC"
20
        Pull    "R2,R3,sb,R12"


 [ E2ROMSupport
        MOV     R0, R2
        BL      GetI2CAddress           ; convert to device address + offset
        MOV     R2, R0                  ; save the offset
 |
        MOV     R1, #RTCAddressPHI
 ]


        AND     R0, R1, #&FF            ; device address for write
        ORR     R0, R0, #1:SHL:29       ; retry
        TST     R1, #&100               ; NE if two byte offset
        SUB     R13, R13, #4
        MOV     R14, R13
        MOVNE   R1, R2, LSR #8
        STRNEB  R1, [R14], #1           ; offset (MSB)
        STRB    R2, [R14], #1           ; offset (LSB)
        STRB    R3, [R14], #1           ; data
        MOV     R1, R13
        SUB     R2, R14, R13
        BL      IIC_Op
        ADD     R13, R13, #4

        [ ChecksumCMOS
        TST     R4, #&1000000           ; loop again to write new checksum
        MOV     R3, R4
        MOV     R2, #PhysChecksum
        ORR     R4, R4, #&1000000       ; but ensure it only happens once
        BEQ     %BT10
        ]
        Pull    "R0-R4, PC"

; *****************************************************************************
;
;       WriteBlock - Write a block of CMOS RAM specified by logical address
;
; in:   R0 = address in CMOS RAM
;       R1 = address to copy from
;       R2 = length
;
; out:  All registers preserved
;


WriteBlock ROUT
        Push    "R0-R4,R14"
  [     E2ROMSupport
        LDR     R14, =ZeroPage
        LDRB    R4, [R14, #NVRamWriteSize]
        LDRB    R14, [R14, #NVRamSize]
        MOV     R4, R4, LSL #8
        MOV     R14, R14, LSL #8
  |
        MOV     R14, #240
        MOV     R4, R14
  ]

        CMP     R0, R14
        BHS     %FT90

        ADDS    R3, R0, R2              ; R3 = end address - check unsigned overflow
        BCS     %FT90
        CMP     R3, R14
        BHI     %FT90

        CMP     R0, R4                  ; ignore writes totally outside writable area
        BHS     %FT80

        SUBS    R14, R3, R4
        SUBGT   R2, R2, R14             ; truncate writes partially outside writable area

        TEQ     R2, #0
        BEQ     %FT80

        CMP     R0, #CheckSumCMOS       ; are we going to write the checksum byte?
        BHI     %FT03
        CMP     R3, #CheckSumCMOS
        BHI     %FT05

03
; we're not writing the checksum byte manually, so we need to update it
        MOV     R4, R1
        MOV     R1, #0
        BL      ChecksumBlock           ; find the checksum of what we're about to
        ORR     R3, R1, #&80000000      ; overwrite
        MOV     R1, R4
        B       %FT08

05      MOV     R3, #0
08      MOV     R4, #0
10      BL      WriteSubBlock
        BVS     %FT80
        TEQ     R2, #0
        BNE     %BT10

        TST     R3, #&80000000          ; were we going to write the checksum?
        BEQ     %FT80

        MOV     R0, #CheckSumCMOS
        BL      Read                    ; get old checksum byte
        ADD     R0, R0, R4              ; add new data checksum
        SUB     R1, R0, R3              ; subtract old checksum
        MOV     R0, #CheckSumCMOS
        BL      Write                   ; write back new checksum

80
        Pull    "R0-R4,PC"

90
        ADD     SP, SP, #4              ; junk stacked R0
        ADR     R0, ErrorBlock_CoreNotWriteable
 [ International
        BL      TranslateError
 |
        SETV
 ]
        Pull    "R1-R4,PC"

; *****************************************************************************
;
;       WriteSubBlock - Write a block of CMOS RAM specified by logical address.
;                       Assumes the address is valid, and will only read as much
;                       as it can in a single IIC transaction.
;
; in:   R0 = address in CMOS RAM
;       R1 = address to copy from
;       R2 = length
;
; out:  R0-R2 updated to reflect the amount written.
;       R4 incremented by sum of bytes written.
;
WriteSubBlock ROUT
        Push    "R3,R5-R6,R14"
        MOV     R6, R4
; establish end of the current contiguous block, and the logical->physical address offset.
        CMP     R0, #1                  ; 00 -> 40 uncached
        MOVLO   R3, #1
        MOVLO   R4, #&40-&00
        BLO     %FT10
        CMP     R0, #&C0                ; [01..C0) -> [41..100) cached
        MOVLO   R3, #&C0
        MOVLO   R4, #&41-&01
        BLO     %FT10
        CMP     R0, #&F0                ; [C0..F0) -> [10..40) cached
        MOVLO   R3, #&F0
        MOVLO   R4, #&10-&C0
        BLO     %FT10
        CMP     R0, #&100
        ADDHS   R3, R0, R2              ; [100..) -> [100..) uncached
        MOVHS   R4, #0
        BHS     %FT10

; [F0..100) -> not written
        MOV     R3, #&100
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
        SUB     R14, R3, R0
        ADD     R0, R0, R14
        ADD     R1, R1, R14
        SUB     R2, R2, R14
        Pull    "R3,R5-R6,PC"

; R3 = logical end of current segment (exclusive)
; R4 = offset from logical to physical address for this segment
10
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
 [ E2ROMSupport
; R3 = logical end of possible transaction (exclusive). Now check we don't cross page boundaries.
        LDR     R14, =ZeroPage
        LDRB    R14, [R14, #NVRamPageSize]
        MOV     R5, #1
        MOV     R14, R5, LSL R14        ; R14 = (1<<pagesize)

        ADD     R5, R0, R4              ; R5 = physical start address
        ADD     R5, R5, R14
        SUB     R14, R14, #1
        BIC     R5, R5, R14             ; R5 = physical end of page with start address in
        SUB     R5, R5, R4              ; R5 = logical end of page with start address in

        CMP     R5, R3
        MOVLO   R3, R5                  ; adjust R3 to not cross page boundary
 ]

        CMP     R0, #&100               ; check it's a cacheable segment
        BHS     %FT15

        LDR     R14, =ZeroPage+CMOSRAMCache
        Push    "R3, R4"
        ADD     R3, R3, R4              ; R3 = physical end address
        ADD     R4, R4, R0              ; R4 = physical address
        ADD     R3, R3, R14             ; R3 = cache end address
        ADD     R4, R4, R14             ; R4 = cache address
        SUB     R14, R3, R4             ; R14 = bytes being written
        MOV     R5, R1                  ; remember R1
12      LDRB    R14, [R1], #1           ; update cache copy
        STRB    R14, [R4], #1
        CMP     R4, R3
        BLO     %BT12
        MOV     R1, R5                  ; restore R1, and continue to update real memory
        Pull    "R3, R4"
15
        Push    "R0-R2"
        ADD     R0, R0, R4              ; R0 = physical address
        Push    "sb, R12"
        MOV     R5, R0                  ; save address
        AddressHAL
        CallHAL HAL_NVMemoryType
        AND     R0, R0, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_None

        ; If there's no NVmemory, tough - we just return.
        Pull    "sb,R12", EQ
        Pull    "R0-R2", EQ
        MOVEQ   R2, #0                  ; nothing written
        Pull    "R3,R5-R6,PC", EQ

        TEQ     R0, #NVMemoryFlag_HAL
        MOV     R0, R5                  ; restore address
        BNE     %FT17                   ; do IIC things.

        ; Make the HAL call
        CallHAL HAL_NVMemoryWrite       ; returns bytes wrtten in R0
        MOV     R5, R0
        Pull    "sb,R12"

        Pull    "R0-R2"

        ADD     R0, R0, R5
        SUB     R2, R2, R5

16      SUBS    R5, R5, #1              ; update checksum
        LDRCSB  R14, [R1], #1
        ADDCS   R6, R6, R14
        BCS     %BT16
        MOV     R4, R6

        Pull    "R3,R5-R6,PC"

17
        Pull    "sb,R12"

  [     E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
  |
        MOV     R1, #RTCAddressPHI
  ]

        MOV     R2, R0                  ; save the offset
        SUB     R13, R13, #12*2+4
        MOV     R14, R13
        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8
        STRNEB  R0, [R14], #1           ; offset (MSB)
        STRB    R2, [R14], #1           ; offset (LSB)

        SUB     R14, R14, R13
        STR     R14, [R13, #12]         ; transfer 1 length

        AND     R14, R1, #&FF
        ORR     R0, R14, #1:SHL:29      ; (retry)
        STR     R0, [R13, #4]           ; transfer 1 address
        ORR     R14, R14, #1:SHL:31     ; (no repeated start)
        STR     R14, [R13, #16]         ; transfer 2 address
        STR     R13, [R13, #8]          ; transfer 1 data

        ADD     R14, R13, #12*2+4
        LDMIA   R14, {R0-R2}
        SUB     R5, R3, R0              ; R5 = bytes being written
        ADD     R0, R0, R5              ; update return R0
        SUB     R2, R2, R5              ; update return R2
        STMIB   R14, {R0,R2}

        STR     R1, [R13, #20]          ; transfer 2 data
        STR     R5, [R13, #24]          ; transfer 2 length
        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV

        LDR     R1, [R13, #20]          ; recover data pointer
        ADD     R13, R13, #12*2+4+4
20
        LDRB    R0, [R1], #1
        SUBS    R5, R5, #1
        ADD     R6, R6, R0              ; update checksum counter
        BNE     %BT20
                                        ; V clear
        MOV     R4, R6

        Pull    "R0,R2,R3,R5,R6,PC"

; *****************************************************************************
;
;       Read - Read a byte of CMOS RAM specified by logical address
;       ReadStraight - Read a byte of CMOS RAM specified by physical address
;       ReadWithError - Read a byte of CMOS RAM specified by logical address, giving error if out of range
;
; in:   R0 = address in CMOS RAM
;
; out:  R0 = data (illegal address return 0, or error for ReadWithError)
;       All other registers preserved
;

ReadStraight ROUT
        Push    "R1,R2,R14"
        B       %FT10

ReadWithError
        Push    "R1,R2,R14"
        BL      MangleCMOSAddress
        BCC     %FT10
        ADR     R0, ErrorBlock_CoreNotReadable
 [ International
        BL      TranslateError
 |
        SETV
 ]
        Pull    "R1,R2,PC"

        MakeErrorBlock CoreNotReadable

Read
        Push    "R1,R2,R14"
        BL      MangleCMOSAddress
        MOVCS   R0, #0                  ; pretend illegal addresses contain 0
        Pull    "R1,R2,PC", CS
10
        TEQ     R0, #&40                ; is it Econet station number
        BEQ     %FT15                   ; if so then don't use cache
        CMP     R0, #&10                ; don't cache the clock
  [     E2ROMSupport
        BHS     %FT13
        ; If our CMOS is actually inside an RTC, read direct (the cache is nonsense)
        LDR     R14, =ZeroPage
        LDRB    R14, [R14, #NVRamBase]
        TEQ     R14, #RTCAddressPHI
        BEQ     %FT15
  |
        BLO     %FT15
  ]
13      CMP     R0, #&100               ; check small cache limit
        LDRCC   R2, =ZeroPage+CMOSRAMCache ; if in range
        LDRCCB  R0, [R2, R0]            ; read from cache
        Pull    "R1,R2,PC", CC          ; and exit
15

; else drop thru into real CMOS reading code

        Push    "R3,R4,sb,R12"
        MOV     R4, R0                  ; save address
        AddressHAL
        CallHAL HAL_NVMemoryType
        AND     R0, R0, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_None

        ; If there's no NVmemory, pretend addresses contain 0
        Pull    "R3,R4,sb,R12", EQ
        MOVEQ   R0, #0
        Pull    "R1,R2,PC", EQ

        TEQ     R0, #NVMemoryFlag_HAL
        MOV     R0, R4                  ; restore address
        BNE     %FT20

        ; Make the HAL call - we have to provide a buffer.
        SUB     sp, sp, #4              ; make some space on the stack
        MOV     R1, sp
        MOV     R2, #1
        CallHAL HAL_NVMemoryRead
        LDRB    R0, [sp], #4            ; read back from stack and restore
        Pull    "R3,R4,sb,R12"
        Pull    "R1,R2,PC"

20
        Pull    "R3,R4, sb,R12"

  [     E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
  |
        MOV     R1, #RTCAddressPHI
  ]

        SUB     R13, R13, #2*12+4
        MOV     R14, R13
        TST     R1, #&100
        MOVNE   R2, R0, LSR #8
        STRNEB  R2, [R14], #1           ; offset (MSB)
        STRB    R0, [R14], #1           ; offset (LSB)
        SUB     R14, R14, R13
        STR     R13, [R13, #8]          ; transfer 1 data
        STR     R14, [R13, #12]         ; transfer 1 length
        AND     R14, R1, #&FF
        ORR     R2, R14, #1:SHL:29      ; retry
        STR     R2, [R13, #4]           ; transfer 1 address
        ORR     R14, R14, #1            ; device address for read
        STR     R14, [R13, #16]         ; transfer 2 address
        ADD     R14, R13, #3
        STR     R14, [R13, #20]         ; transfer 2 data
        MOV     R14, #1
        STR     R14, [R13, #24]         ; transfer 2 length
        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV
        LDRB    R0, [R13, #3]
        ADD     R13, R13, #2*12+4

        Pull    "R1,R2,PC"

; *****************************************************************************
;
;       ReadBlock - Read a block of CMOS RAM specified by logical address
;
; in:   R0 = address in CMOS RAM
;       R1 = address to copy to
;       R2 = length
;
; out:  All registers preserved
;


ReadBlock ROUT
        Push    "R0-R3,R14"
  [     E2ROMSupport
        LDR     R14, =ZeroPage
        LDRB    R14, [R14, #NVRamSize]
        MOV     R14, R14, LSL #8
  |
        MOV     R14, #240
  ]

        CMP     R0, R14
        BHS     %FT90

        ADDS    R3, R0, R2              ; R3 = end address - check unsigned overflow
        BCS     %FT90
        CMP     R3, R14
        BHI     %FT90

        TEQ     R2, #0
        BEQ     %FT80

10      BL      ReadSubBlock
        BVS     %FT80
        TEQ     R2, #0
        BNE     %BT10
80
        Pull    "R0-R3,PC"

90
        ADD     SP, SP, #4              ; junk stacked R0
        ADR     R0, ErrorBlock_CoreNotReadable
 [ International
        BL      TranslateError
 |
        SETV
 ]
        Pull    "R1-R3,PC"

; *****************************************************************************
;
;       ReadSubBlock - Read a block of CMOS RAM specified by logical address.
;                      Assumes the address is valid, and will only read as much
;                      as it can in a single IIC transaction.
;
; in:   R0 = address in CMOS RAM
;       R1 = address to copy to
;       R2 = length
;
; out:  R0-R2 updated to reflect the amount read.
;
ReadSubBlock ROUT
        Push    "R3-R5,R14"
; establish end of the current contiguous block, and the logical->physical address offset.
        CMP     R0, #1                  ; 00 -> 40 uncached
        MOVLO   R3, #1
        MOVLO   R4, #&40-&00
        BLO     %FT10
        CMP     R0, #&C0                ; [01..C0) -> [41..100) cached
        MOVLO   R3, #&C0
        MOVLO   R4, #&41-&01
        BLO     %FT10
        CMP     R0, #&F0                ; [C0..F0) -> [10..40) cached
        MOVLO   R3, #&F0
        MOVLO   R4, #&10-&C0
        BLO     %FT10
        CMP     R0, #&100               ; [F0..100) -> [00..10) cached
        MOVLO   R3, #&100
        MOVLO   R4, #&00-&F0
        ADDHS   R3, R0, R2              ; [100..) -> [100..) uncached
        MOVHS   R4, #0
; R3 = logical end of current segment (exclusive)
; R4 = offset from logical to physical address for this segment
10
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
; R3 = logical end of this transaction (exclusive)
        TEQ     R0, #0                  ; check it's a cacheable segment
        BEQ     %FT15
        CMP     R0, #&100
        BHS     %FT15

        LDR     R14, =ZeroPage+CMOSRAMCache
        ADD     R3, R3, R4              ; R3 = physical end address
        ADD     R4, R4, R0              ; R4 = physical address
        ADD     R3, R3, R14             ; R3 = cache end address
        ADD     R4, R4, R14             ; R4 = cache address
        SUB     R14, R3, R4             ; R14 = bytes being read
        ADD     R0, R0, R14             ; update return R0
        SUB     R2, R2, R14             ; update return R2

12      LDRB    R14, [R4], #1
        CMP     R4, R3
        STRB    R14, [R1], #1
        BLO     %BT12
        Pull    "R3-R5,PC"              ; V will be clear
15
        Push    "R0-R2"
        ADD     R0, R0, R4              ; R0 = physical start address
        ADD     R3, R3, R4              ; R3 = physical end address
        Push    "sb"
        SUB     R2, R3, R0
        MOV     R5, R0                  ; save address
        AddressHAL
        Push    "R1-R3,R12"
        CallHAL HAL_NVMemoryType
        Pull    "R1-R3,R12"
        AND     R0, R0, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_None

        ; If there's no NVmemory, tough - we just return.
        MOVEQ   R2, #0                  ; nothing read
        Pull    "sb", EQ
        Pull    "R3-R5,PC", EQ

        TEQ     R0, #NVMemoryFlag_HAL
        MOV     R0, R5                  ; restore address
        BNE     %FT17                   ; do IIC things.

        ; Make the HAL call
        Push    "R12"
        CallHAL HAL_NVMemoryRead        ; returns bytes read in R0
        Pull    "R12"
        MOV     R4, R0
        Pull    "sb"
        Pull    "R0-R2"
        ADD     R0, R0, R4
        ADD     R1, R1, R4
        SUB     R2, R2, R4
        Pull    "R3-R5,PC"

17
        Pull    "sb"

        SUB     R5, R3, R0              ; R5 = bytes being read

  [     E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
  |
        MOV     R1, #RTCAddressPHI
  ]


        MOV     R2, R0                  ; save the offset
        SUB     R13, R13, #12*2+4
        MOV     R14, R13
        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8
        STRNEB  R0, [R14], #1           ; offset (MSB)
        STRB    R2, [R14], #1           ; offset (LSB)

        SUB     R14, R14, R13
        STR     R14, [R13, #12]         ; transfer 1 length

        AND     R14, R1, #&FF
        ORR     R0, R14, #1:SHL:29      ; retry
        STR     R0, [R13, #4]           ; transfer 1 address
        ORR     R14, R14, #1            ; device address for read
        STR     R14, [R13, #16]         ; transfer 2 address
        STR     R13, [R13, #8]          ; transfer 1 data

        ADD     R14, R13, #12*2+4
        LDMIA   R14, {R0-R2}
        ADD     R0, R0, R5              ; update return R0
        SUB     R2, R2, R5              ; update return R2
        STMIB   R14, {R0,R2}

        STR     R1, [R13, #20]          ; transfer 2 data
        STR     R5, [R13, #24]          ; transfer 2 length
        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV

        LDR     R1, [R13, #20]          ; recover data pointer
        ADD     R1, R1, R5
        ADD     R13, R13, #12*2+4+4

        CLRV

        Pull    "R0,R2,R3-R5,PC"

; *****************************************************************************
;
;       ChecksumBlock - Checksum a block of CMOS RAM specified by logical address
;                       Assumes the address is valid.
;
; in:   R0 = address in CMOS RAM
;       R1 = initial checksum
;       R2 = length
;
; out:  R1 incremented by sum of bytes in range
;


ChecksumBlock ROUT
        Push    "R0,R2,R14"

10      BL      ChecksumSubBlock
        BVS     %FT80
        TEQ     R2, #0
        BNE     %BT10
80
        Pull    "R0,R2,PC"

; *****************************************************************************
;
;       ChecksumSubBlock - Checksum a block of CMOS RAM specified by logical address.
;                          Assumes the address is valid, and will only read as much
;                          as it can in a single IIC transaction. Skips over
;                          239 (the checksum byte itself), and 240-255 (OTP area).
;
; in:   R0 = address in CMOS RAM
;       R1 = initial checksum
;       R2 = length
;
; out:  R0-R2 updated to reflect the data read.
;
ChecksumSubBlock ROUT
        Push    "R3-R5,R14"
; establish end of the current contiguous block, and the logical->physical address offset.
        CMP     R0, #1                  ; 00 -> 40 uncached
        MOVLO   R3, #1
        MOVLO   R4, #&40-&00
        BLO     %FT10
        CMP     R0, #&C0                ; [01..C0) -> [41..100) cached
        MOVLO   R3, #&C0
        MOVLO   R4, #&41-&01
        BLO     %FT10
        CMP     R0, #&EF                ; [C0..EF) -> [10..3F) cached
        MOVLO   R3, #&EF
        MOVLO   R4, #&10-&C0
        BLO     %FT10
        CMP     R0, #&100
        ADDHS   R3, R0, R2              ; [100..) -> [100..) uncached
        MOVHS   R4, #0
        BHS     %FT10

;  [EF..100) -> not checksummed
        MOV     R3, #&100
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
        SUB     R14, R3, R0
        ADD     R0, R0, R14
        SUB     R2, R2, R14
        Pull    "R3-R5,PC"


; R3 = logical end of current segment (exclusive)
; R4 = offset from logical to physical address for this segment
10
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
; R3 = logical end of this transaction (exclusive)

        TEQ     R0, #0                  ; check it's a cacheable segment
        BEQ     %FT15
        CMP     R0, #&100
        BHS     %FT15

        LDR     R14, =ZeroPage+CMOSRAMCache
        ADD     R3, R3, R4              ; R3 = physical end address
        ADD     R4, R4, R0              ; R4 = physical address
        ADD     R3, R3, R14             ; R3 = cache end address
        ADD     R4, R4, R14             ; R4 = cache address
        SUB     R14, R3, R4             ; R14 = bytes being read
        ADD     R0, R0, R14             ; update return R0
        SUB     R2, R2, R14             ; update return R2

12      LDRB    R14, [R4], #1
        CMP     R4, R3
        ADD     R1, R1, R14
        BLO     %BT12
        Pull    "R3-R5,PC"
15
        Push    "R0-R2"
        ADD     R0, R0, R4              ; R0 = physical start address
        ADD     R3, R3, R4              ; R3 = physical end address
        Push    "sb,R12"
        MOV     R5, R0                  ; save address
        AddressHAL
        Push    "R1-R3"
        CallHAL HAL_NVMemoryType
        Pull    "R1-R3"
        AND     R4, R0, #NVMemoryFlag_Provision
        MOV     R0, R5                  ; restore address
        TEQ     R4, #NVMemoryFlag_None
        TEQNE   R4, #NVMemoryFlag_HAL
        BNE     %FT17                   ; do IIC things.

        SUB     R14, R3, R0
        LDR     R1, [R13,#8]
        LDR     R3, [R13,#16]
        ADD     R1, R1, R14
        SUB     R3, R3, R14
        STR     R1, [R13,#8]
        STR     R3, [R13,#16]

        TEQ     R4, #NVMemoryFlag_None
        ; If there's no NVmemory, tough - we just return.
        Pull    "sb,R12", EQ
        Pull    "R0-R5,PC", EQ

        Push    "R6"
        MOV     R4, #0
        ADD     R6, R5, R14
        SUB     R13, R13, #4
16
        MOV     R0, R5
        MOV     R1, sp
        MOV     R2, #1
        CallHAL HAL_NVMemoryRead
        LDRB    R14, [R13]
        ADD     R4, R4, R14
        ADD     R5, R5, #1
        TEQ     R5, R6
        BNE     %BT16
        ADD     R13, R13, #4
        Pull    "R6,sb,R12"
        Pull    "R0-R2"
        ADD     R1,R1,R4
        Pull    "R3-R5,PC"
17
        Pull    "sb,R12"
        SUB     R5, R3, R0              ; R5 = bytes being read

  [     E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
  |
        MOV     R1, #RTCAddressPHI
  ]

        MOV     R2, R0                  ; save the offset
        SUB     R13, R13, #12*2+4
        MOV     R14, R13
        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8
        STRNEB  R0, [R14], #1           ; offset (MSB)
        STRB    R2, [R14], #1           ; offset (LSB)

        SUB     R14, R14, R13
        STR     R14, [R13, #12]         ; transfer 1 length

        AND     R14, R1, #&FF
        ORR     R0, R14, #1:SHL:29      ; retry
        STR     R0, [R13, #4]           ; transfer 1 address
        ORR     R14, R14, #1            ; device address for read
        ORR     R14, R14, #1:SHL:30     ; checksum only please
        STR     R14, [R13, #16]         ; transfer 2 address
        STR     R13, [R13, #8]          ; transfer 1 data

        ADD     R14, R13, #12*2+4
        LDMIA   R14, {R0-R2}
        ADD     R0, R0, R5              ; update return R0
        SUB     R2, R2, R5              ; update return R2
        STMIB   R14, {R0,R2}
        MOV     R4, R1                  ; remember checksum

        STR     R5, [R13, #24]          ; transfer 2 length
        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV

        LDR     R1, [R13, #20]          ; read back checksum
        ADD     R1, R1, R4              ; update checksum
        ADD     R13, R13, #12*2+4+4

        Pull    "R0,R2,R3-R5,PC"

; *****************************************************************************
;
;       GetI2CAddress - Convert NVRam physical address to i2c device address
;                       and offset
;
; in:   R0 = NVRam physical address (&00..size of NVRam)
;
; out:  R0 preserved
;
;       C=0 => NVRam address is valid
;        R0 = physical address within i2c device
;        R1 = i2c device address for writing. Increment this device address
;             by 1 for reading. Bit 8 is set if device requires 2-byte physical address.
;
;       C=1 => NVRam address is out of range of CMOS or E2ROM chips
;        R0 preserved
;        R1 preserved

  [     E2ROMSupport
GetI2CAddress ROUT
        Push    "R14"
        LDR     R14, =ZeroPage          ; get no 256 byte blocks and calculate end address
        LDRB    R14, [R14, #NVRamSize]
        MOV     R14, R14, LSL #8
        CMP     R0, R14
        Pull    "PC",CS                 ; indicate invalid

; address is < end address -> is valid
        LDR     R1, =ZeroPage
        LDRB    R1, [R1, #NVRamBase]

        CMP     R14, #2*1024            ; is the device bigger than 2K? If so, new addressing scheme
        ORRHI   R1, R1, #&100           ; set magic bit => 2 byte address
        BHI     %FT50

        MOVS    R14, R0, LSR #8         ; put top bits of physical address into device address
        ORRNE   R1, R1, R14, LSL #1
        ANDNE   R0, R0, #&FF            ; and use address within 256 byte block
50
        CLC
        Pull    "PC"                    ; indicate valid

  ]

; *****************************************************************************
;
;       MangleCMOSAddress - Convert from logical to physical address
;
;       Doesn't check if address is larger than the amount of NVRam installed
;
; in:   R0 = logical address (&00...)
;
; out:  C=0 => valid logical address
;        R0 = physical address (&40..&FF,&10..&3F,&00..0F,&100..)
;
;       C=1 => invalid logical address
;        R0 preserved
;

MangleCMOSAddress ROUT
 [ E2ROMSupport
        Push    "R14"
        LDR     R14, =ZeroPage          ; read no 256 byte blocks and calculate end address
        LDRB    R14, [R14, #NVRamSize]
        MOV     R14, R14, LSL #8
        CMP     R0, R14                 ; if >= end address then
        Pull    "R14"
        MOVCS   PC, R14                 ;    invalid (exit C set)

        CMP     R0, #&100               ; if < end address && >= &100 then
        BLO     %FT05
        CLC
        MOV     PC, R14                 ;    valid (no mungeing)
 ]
05
        CMP     R0, #&F0                ; if < &100 && >= &f0 then
        [ E2ROMSupport
        BCC     %FT10
        SUB     R0, R0, #&F0            ;    map &F0->&FF to &00->0F for OTP section
        CLC
        MOV     PC, R14
        |
        MOVCS   PC, R14                 ;    invalid
        ]
10
        ADD     R0, R0, #&40            ; now in range &40..&13F
        CMP     R0, #&100
        SUBCS   R0, R0, #(&100-&10)     ; now in range &40..&FF, &10..&3F
        CLC
        MOV     PC, R14                 ; valid

; *****************************************************************************
;
;       ValChecksum - test to see if the CMOS checksum is OK
;
;       This routine performs MangleCMOSAddress inherently.
;
;       The checksum does not include physical locations &00->&0F, even
;       if they are OTP section (as this is usually used for a unique id
;       which will be different for every machine and can't be changed).
;
; in:   none
;
; out:  R0 = calculated checksum
;       Z       set if checksum is valid
;       All other registers preserved
;

  [ ChecksumCMOS

ValChecksum     Entry "R1-R2"

        MOV     R0, #0
        MOV     R1, #CMOSxseed
   [ E2ROMSupport
        LDR     R2, =ZeroPage           ; read number of 256 byte blocks and calculate end address
        LDRB    R2, [R2, #NVRamSize]
        MOV     R2, R2, LSL #8
   |
        MOV     R2, #240
   ]
        BL      ChecksumBlock

;
; R1 contains the actual checksum. Compare it with the recorded checksum
;
40
        MOV     R0, #CheckSumCMOS
        BL      Read
        AND     R2, R0, #&FF            ; value from checksum location
        AND     R0, R1, #&FF            ; calculated value into R0
        CMPS    R0, R2

        EXIT
  ]

; *****************************************************************************
;
;       MakeChecksum - calculate and write a correct checksum
;
; in:   none
;
; out:  R0 = calculated checksum
;       All other registers preserved
;

        [ ChecksumCMOS

MakeChecksum    ROUT
        Push    "R1-R2,R14"
        MOV     R0, #0
        MOV     R1, #CMOSxseed
  [ E2ROMSupport
        LDR     R2, =ZeroPage
        LDRB    R2, [R2, #NVRamSize]
        MOV     R2, R2, LSL #8
  |
        MOV     R2, #240
  ]
        BL      ChecksumBlock
        MOV     R0, #CheckSumCMOS
        BL      Write
        MOV     R0, R1
        Pull    "R1-R2,PC"
        ]

        LTORG

; *****************************************************************************
;
;       InitCMOSCache - Initialise cache of CMOS RAM
;  in: -
;
;  out: R0 = 0 for failure

InitCMOSCache   Entry "r1-r6, sb,r12"
    [   E2ROMSupport

        ; Need to set the slowest speed so we can probe
        LDR     R4, =ZeroPage
        MOV     R3, #10         ; Default speed setting (5s delays)
        STRB    R3, [R4, #NVRamSpeed]

        AddressHAL
        CallHAL HAL_NVMemoryType
        MOV     R5, R0
        ANDS    R0, R0, #NVMemoryFlag_Provision
        ASSERT  NVMemoryFlag_None = 0
        BEQ     InitCMOSCache_NoCMOS

        ; If it's only a maybe, then we probe
        TEQ     R0, #NVMemoryFlag_MaybeIIC
        BEQ     %FT03

        ; Else we read the size

        CallHAL HAL_NVMemorySize        ; returns number of bytes but..
        MOV     R0, R0, LSR#8           ; .. expecting no. of 256 blocks
        STRB    R0, [R4, #NVRamSize]

        TST     R5, #NVMemoryFlag_ProtectAtEnd
        STREQB  R0, [R4, #NVRamWriteSize]
        BEQ     %FT02
        CallHAL HAL_NVMemoryProtectedSize
        LDRB    R1, [R4, #NVRamSize]
        SUB     R0, R1, R0, LSR#8
        STRB    R0, [R4, #NVRamWriteSize]

02
        CallHAL HAL_NVMemoryPageSize    ; returns size in bytes but..
        TEQ     R0, #0                  ; .. expecting power of 2
        MVNEQ   R0, #0
        MOV     R1, #0
22      MOVS    R0, R0, LSR #1
        ADDNE   R1, R1, #1
        BNE     %BT22
        STRB    R1, [R4, #NVRamPageSize]

        CallHAL HAL_NVMemoryIICAddress
        STRB    R0, [R4, #NVRamBase]

        MOV     R0, #0
        CallHAL HAL_IICType
        MOV     R3, #10
        TST     R0, #IICFlag_Fast
        MOVNE   R3, #3
        TST     R0, #IICFlag_HighSpeed
        MOVNE   R3, #1
        STRB    R3, [R4, #NVRamSpeed]

        ; If we're using IIC then read in the cache manually
        AND     R0, R5, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_IIC
        BEQ     %FT06

        ; Else use HAL routine.
        MOV     R0, #0
        LDR     R1, =ZeroPage+CMOSRAMCache
        MOV     R2, #&100
        CallHAL HAL_NVMemoryRead
        TEQ     R0, #&100
        MOVNE   R0, #0                  ; Failure exit condition
        EXIT
03

;       No HAL,so determine what hardware we've got fitted by probing,
;       R4 holds the number of 256 byte blocks that we've found

        MOV     R3, #10         ; assume 100kHz to start with
        MOV     R5, #4          ; assume 16 byte page size to start with
        MOV     R6, #0          ; assume not protected

; Have we got a 2K device ?
        MOV     r1, #E2ROMAddress2K
        MOV     r0, #(E2ROMAddress2K+14)
        BL      DummyAccess
        MOVVC   R4, #8
        MOVVC   R3, #3          ; Fast speed setting (1.5s delays)
        BVC     %FT5

; Have we got a 16K device ?
        MOV     r1, #E2ROMAddress16K
        MOV     r0, #E2ROMAddress16K
        BL      DummyAccess
        MOVVC   R4, #64
        MOVVC   R5, #6          ; 64 byte page size
        MOVVC   R3, #3          ; Fast speed setting (1.5s delays)
        BVC     %FT5

; Have we got a 4K device?
        MOV     r1, #E2ROMAddress4K
        MOV     r0, #E2ROMAddress4K
        BL      DummyAccess
        MOVVC   R4, #16
        MOVVC   R6, #12         ; Only bottom 3K writable
        MOVVC   R5, #5          ; 32 byte page size
        MOVVC   R3, #3          ; Fast speed setting (1.5s delays)
        BVC     %FT5

; Have we got an 8K device?
        MOV     r1, #E2ROMAddress8K
        MOV     r0, #E2ROMAddress8K
        BL      DummyAccess
        MOVVC   R4, #32
        MOVVC   R5, #5          ; 32 byte page size
        MOVVC   R3, #3          ; Fast speed setting (1.5s delays)
        BVC     %FT5

; Have we got a protected 8K device?
        MOV     r1, #E2ROMAddress8K_prot
        MOV     r0, #E2ROMAddress8K_prot
        BL      DummyAccess
        MOVVC   R4, #32
        MOVVC   R6, #24         ; Only bottom 6K writable
        MOVVC   R5, #5          ; 32 byte page size
        MOVVC   R3, #3          ; Fast speed setting (1.5s delays)
        BVC     %FT5

; Have we got a 32K device?
        MOV     r1, #E2ROMAddress32K
        MOV     r0, #E2ROMAddress32K
        BL      DummyAccess
        MOVVC   R4, #128        ; 128,120,6,1
        MOVVC   R6, #120        ; Only bottom 30K writable
        MOVVC   R5, #6          ; 64 byte page size
        MOVVC   R3, #1          ; Hyper-fast speed setting (0.5s delays - 1MHz part)
        BVC     %FT5

; Any storage in the Philips RTC?
        MOV     R1, #RTCAddressPHI
        MOV     R0, #RTCAddressPHI
        BL      DummyAccess
        MOV     R5, #8          ; 256 byte page size for CMOS
        MOVVC   R4, #1
        BVC     %FT5

; We ain't got anything!
InitCMOSCache_NoCMOS
        LDR     R2, =ZeroPage
        MOV     R5, #8
        STRB    R5, [R2, #NVRamPageSize]        ; Act as though we have 256 bytes of
        MOV     R1, #1                          ; single page CMOS.
        STRB    R1, [R2, #NVRamSize]
        STRB    R1, [R2, #NVRamWriteSize]
        MOV     R0, #0          ; Exit failure
        EXIT

5
        ; Set the NVRam count
        LDR     R2, =ZeroPage
        STRB    R1, [R2, #NVRamBase]
        STRB    R4, [R2, #NVRamSize]
        STRB    R5, [R2, #NVRamPageSize]
        TEQ     R6, #0
        MOVEQ   R6, R4
        STRB    R6, [R2, #NVRamWriteSize]

        CMP     R3, #I2Cticks   ; clamp speed to maximum bus speed
        MOVLO   R3, #I2Cticks
        STRB    R3, [R2, #NVRamSpeed]
06
        ; Initialise the cache
        LDR     R3, =ZeroPage+CMOSRAMCache

        TEQ     R4, #8                  ; check for 2K part
        MOVNE   r0, #&00                ; if not, then start at 0 anyway and read non-OTP data into location 0..15
        BNE     %FT07
        BL      ReadOTPArea
        MOV     r0, #&10                ; read rest of it from 16 onwards
07
        BL      GetI2CAddress           ; and convert to device address and offset
        MOV     R2, R0                  ; save the offset
        MOV     R4, #&100               ; stop at &100
    |
        ; No E2ROM support, assume just a Philips RTC
        MOV     R1, #RTCAddressPHI
        MOV     R2, #&10
        MOV     R4, #&100               ; stop at address &100
        LDR     R3, =ZeroPage+CMOSRAMCache
    ]

        ; Note - R4 MUST be &100 to prevent crossover between 256-byte pages
        ; (for devices with multiple addresses)
09

        SUB     R13, R13, #2*12+4
        AND     R0, R1, #&FF
        STR     R0, [R13, #4]           ; transfer 1 address
        ADD     R0, R0, #1              ; read address
        STR     R0, [R13, #16]          ; transfer 2 address
        TST     R1, #&100               ; 2-byte address?
        MOV     R14, R13
        MOVNE   R0, R2, LSR #8
        STRNEB  R0, [R14], #1           ; memory word address (MSB)
        STRB    R2, [R14], #1           ; memory word address (LSB)
        STR     R13, [R13, #8]          ; transfer 1 data
        SUB     R14, R14, R13
        STR     R14, [R13, #12]         ; transfer 1 length
        ADD     R14, R3, R2
        STR     R14, [R13, #20]         ; transfer 2 data
        SUB     R14, R4, R2
        STR     R14, [R13, #24]         ; transfer 2 length

        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV

        ADD     R13, R13, #2*12+4
        MOV     R0, #1
        EXIT

   [ E2ROMSupport
ReadOTPArea Entry
        SUB     R13, R13, #2*12+4
        MOV     R0, #0
        STRB    R0, [R13, #0]           ; offset 0
        MOV     R0, #E2ROMAddress2K_OTP
        STR     R0, [R13, #4]           ; transfer 1 address
        STR     R13, [R13, #8]          ; transfer 1 data
        MOV     R0, #1
        STR     R0, [R13, #12]          ; transfer 1 length
        MOV     R0, #E2ROMAddress2K_OTP + 1
        STR     R0, [R13, #16]          ; transfer 2 address
        STR     R3, [R13, #20]          ; transfer 2 data
        MOV     R0, #16
        STR     R0, [R13, #24]          ; transfer 2 length
        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV
        ADD     R13, R13, #2*12+4
        EXIT
   ]

; *****************************************************************************
;
;       DummyAccess - do a dummy access of the specified device to find out
;                     if it is present
;
; in:   R0 = Write address of device
;
; out:  All registers preserved
;       V=0 => device is present
;       V=1 => device is not present

  [ E2ROMSupport
DummyAccess

 [ {TRUE}
        ; Blooming 80321 HW IIC can't do just START address STOP
        Entry   "R0-R2",4
        ORR     R0, R0, #1
        MOV     R1, R13
        MOV     R2, #1
        BL      IIC_Op
 |
        Entry   "R1,R2"
        MOV     R1, #0
        MOV     R2, #0
        BL      IIC_Op
 ]

        EXIT                            ; Exit with V set appropriately
  ]

; *****************************************************************************
;
;       SWI OS_NVMemory
;
; in:   R0 = reason code
;

NVMemorySWI     Entry
        BL      NVMemorySub
        PullEnv
        ORRVS   LR, LR, #V_bit
        ExitSWIHandler

NVMemorySub
        CMP     R0, #7
        ADDLS   PC, PC, R0, LSL #2
        B       NVMemory_Unknown
        B       NVMemory_Size
        B       NVMemory_Read
        B       NVMemory_Write
        B       NVMemory_ReadBlock
        B       NVMemory_WriteBlock
        B       NVMemory_Unknown        ; Reserved for Kernel-5_41 divergence
        B       NVMemory_ResetValue
        B       NVMemory_SetStation

NVMemory_Unknown
        ADRL    R0, ErrorBlock_HeapBadReason
      [ International
        Push    LR
        BL      TranslateError
        Pull    LR
      ]
        RETURNVS

; -----------------------------------------------------------------------------
; OS_NVMemory 0 - find NV memory size
;
; in:   R0 = 0
;
; out:  R1 = NV memory size in bytes
;
NVMemory_Size
    [ E2ROMSupport
      [ ZeroPage = 0
        LDRB    R1, [R0, #NVRamSize]
      |
        LDR     R1, =ZeroPage
        LDRB    R1, [R1, #NVRamSize]
      ]
        MOV     R1, R1, LSL #8
    |
        MOV     R1, #240
    ]
        MOV     PC, LR

; -----------------------------------------------------------------------------
; OS_NVMemory 1 - read a byte
;
; in:   R0 = 1
;       R1 = location
;
; out:  R2 = value
;
NVMemory_Read
        Entry   "R4"
        MRS     R4, CPSR
        BIC     R0, R4, #I32_bit
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
        MOV     R0, R1
        BL      ReadWithError
        MOVVC   R2, R0
        MOVVC   R0, #1          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        MSR     CPSR_cf, R4     ; restore interrupt state
        EXIT

; -----------------------------------------------------------------------------
; OS_NVMemory 2 - write a byte
;
; in:   R0 = 2
;       R1 = location
;       R2 = value
;
NVMemory_Write ROUT
      [ ProtectStationID
        TEQ     R1, #NetStnCMOS ; just ignore writes
        MOVEQ   PC, R14
      ]
        Entry   "R1,R4"
        MRS     R4, CPSR
        BIC     R0, R4, #I32_bit
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
        MOV     R0, R1
        MOV     R1, R2
        BL      WriteWithError
        MOVVC   R0, #2          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        MSR     CPSR_cf, R4     ; restore interrupt state
        EXIT

; -----------------------------------------------------------------------------
; OS_NVMemory 3 - read a block
;
; in:   R0 = 3
;       R1 = location
;       R2 = buffer
;       R3 = length
;
NVMemory_ReadBlock 
        Entry   "R1-R4"
        MRS     R4, CPSR
        BIC     R0, R4, #I32_bit
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
        MOV     R0, R1
        MOV     R1, R2
        MOV     R2, R3
        BL      ReadBlock
        MOVVC   R0, #3          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        MSR     CPSR_cf, R4     ; restore interrupt state
        EXIT

; -----------------------------------------------------------------------------
; OS_NVMemory 4 - write a block
;
; in:   R0 = 4
;       R1 = location
;       R2 = buffer
;       R3 = length
;
NVMemory_WriteBlock ROUT
        Entry   "R1-R4"
        MRS     R4, CPSR
        BIC     R0, R4, #I32_bit
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
      [ ProtectStationID
        ASSERT  NetStnCMOS = 0
        TEQ     R1, #NetStnCMOS
        BNE     %FT10
        ADD     R1, R1, #1
        ADD     R2, R2, #1
        TEQ     R3, #0
        SUBNE   R3, R3, #1      ; steer clear of station ID
      ]
10      MOV     R0, R1
        MOV     R1, R2
        MOV     R2, R3
        BL      WriteBlock
        MOVVC   R0, #4          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        MSR     CPSR_cf, R4     ; restore interrupt state
        EXIT

; -----------------------------------------------------------------------------
; OS_NVMemory 6 - query CMOS value that would be used on a Delete-Power-On reset
;
; in:   R0 = 6
;       R1 = location
;
; out:  R2 = value, or -1 if the value is unknown/untouched
;
NVMemory_ResetValue ROUT
        Entry   "R3"
        MOV     R2, #-1         ; assume outside our remit
        TEQ     R1, #NetStnCMOS
        EXIT    EQ
        ASSERT  CheckSumCMOS = CMOSLimit - 1
        CMP     R1, #CheckSumCMOS
        EXIT    CS

        TEQ     R1, #MouseCMOS
        BEQ     %FT20           ; code driven

        TEQ     R1, #PrintSoundCMOS
        BEQ     %FT30           ; code driven

        ADR     R3, DefaultCMOSTable
10
        LDRB    R2, [R3], #2    ; table is of location/value pairs...
        TEQ     R2, #&FF        ; ...terminated by &FF
        MOVEQ   R2, #0          ; not in the table, so must be zero
        EXIT    EQ
        TEQ     R2, R1          ; location match?
        LDREQB  R2, [R3, #-1]
        EXIT    EQ
        B       %BT10
20
      [ "$Machine"="IOMD" 
        Push    "R0-R1,R9,R12"
        AddressHAL
        MOV     R0, #0
        MOV     R1, #&400                    ; SSpace hopefully exists
        CallHAL HAL_ControllerAddress
        LDRB    R1, [R0, #IOMD_ID1]
        LDRB    R0, [R0, #IOMD_ID0]
        ORR     R0, R0, R1, LSL #8
        LDR     R1, =IOMD_Original
        TEQ     R0, R1                       ; Select quadrature or PS2 as appropriate
        MOVEQ   R2, #PointerDevice_QuadMouse ; Risc PC
        MOVNE   R2, #PointerDevice_PS2Mouse  ; A7000 et al
        Pull    "R0-R1,R9,R12"
      |
        ; Everyone else is on USB
        MOV     R2, #PointerDevice_USB
      ]
        EXIT
30
        MOV     R2, #2_10100100
                     ; ^^^       interpolate at low rates, 16 bit DAC, fully programmable rates
                     ;    ^^^^^  tbs chars valid, escape with GSTrans
        EXIT

; -----------------------------------------------------------------------------
; OS_NVMemory 7 - set station
;
; in:   R0 = 7
;       R1 = pointer to pass phrase
;       R2 = value
;
NVMemory_SetStation ROUT
        Entry   "R1-R4"
        MRS     R4, CPSR
        BIC     R0, R4, #I32_bit
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
      [ ProtectStationID
        MOV     R2, R1
10
        LDRB    R0, [R2], #1
        CMP     R0, #' '
        BCS     %BT10
        MOV     R3, #1
        SUB     R2, R2, #1
        MOV     R0, #0
        SWI     XOS_CRC
        EOR     R0, R0, #&009D
        EORS    R0, R0, #&2300
        MOVNE   R0, #-1         ; duff address to cause 'not writable' error
        ASSERT  NetStnCMOS = 0
        LDR     R1, [SP, #Proc_RegOffset + 4]
      |
        MOV     R0, #NetStnCMOS
        MOV     R1, R2
      ]
        BL      WriteWithError
        MOVVC   R0, #7          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        MSR     CPSR_cf, R4     ; restore interrupt state
        EXIT

DefaultCMOSTable
        ; Normal table
 [ :DEF: CMOS_Override
        $CMOS_Override
 ]
        DCB     KeyDelCMOS,         32
        DCB     FileLangCMOS,       fsnumber_adfs   ; ADFS
        DCB     FontCMOS,           64      ; KJB 13-Dec-02: Changed to 256K from 64K
        DCB     PigCMOS,            10
        DCB     KeyRepCMOS,         8
        DCB     RMASizeCMOS,        0
        DCB     SpriteSizeCMOS,     0
        DCB     SysHeapCMOS,        8
        DCB     MODETVCMOS,         &10     ; TV 0,1
        DCB     NetFSIDCMOS,        254
        DCB     NetPSIDCMOS,        235
        DCB     PSITCMOS,           (3:SHL:2) :OR: (1:SHL:5)
                                    ; Baud 3
                                    ;                Print 1

        DCB     DBTBCMOS,           (1:SHL:4) :OR: (4:SHL:5)
                                    ; Boot (changed from NoBoot 01-Sep-93)
                                    ;                Data 4

        DCB     StartCMOS,          (4:SHL:0) :OR: (2:SHL:3) :OR: (1:SHL:6) :OR: (0:SHL:7)
                                    ; ^              ^              ^              ^
                                    ; ADFS DR.4      NOCAPS         NODIR (moot)   NUM
        DCB     NewADFSCMOS+0,      &41     ; floppies=1, ST506=0, IDE=1 (changed 01-Sep-93)
        DCB     NewADFSCMOS+1,      4_3333  ; step 3 for each drive
        DCB     NewADFSCMOS+2,      1       ; ADFSBuffers 1
                                    
        DCB     SoundCMOS,          &F0     ; speaker on, volume 7, channel 1

        DCB     LanguageCMOS,       11      ; typically module number of 'Desktop'
        DCB     YearCMOS+0,         00
        DCB     YearCMOS+1,         20
        DCB     NetFilerCMOS,       (0:SHL:0) :OR: (1:SHL:1) :OR: (0:SHL:2)
                                    ; FS list order by name
                                    ;                Use $.Arthurlib
                                    ;                               Large icons

        DCB     DesktopCMOS,        2_01000000      ; verbose ON
        DCB     WimpFlagsCMOS,      2_01101111      ; instant effects, drags off screen
        DCB     ProtectionCMOS,     2_01110110      ; allow only peek and user RPC
        DCB     MouseStepCMOS,      2
        DCB     FileSwitchCMOS,     (1:SHL:0) :OR: (1:SHL:1) :OR: (0:SHL:2) :OR: (0:SHL:3) :OR: (0:SHL:6)
                                    ; Truncate names
                                    ;                Use DragASprite (changed 01-Sept-93)
                                    ;                               Interactive file copying
                                    ;                                              Wimp dither colours off
                                    ;                                                             Last shutdown ordinary

        DCB     DesktopFeaturesCMOS,(1:SHL:0) :OR: (8:SHL:1) :OR: (0:SHL:7)
                                    ; 3D look
                                    ;                Homerton.Medium
                                    ;                               Tiled window background

        DCB     SystemSpeedCMOS,    (0:SHL:0):OR:(0:SHL:1):OR:(1:SHL:2):OR:(0:SHL:3):OR:(1:SHL:4):OR:(0:SHL:5):OR:(1:SHL:6):OR:(0:SHL:7)
                                    ; AUN BootNet Disabled
                                    ;              AUN auto-station numbering off
                                    ;                           Delete-etc reset
                                    ;                                        Power saving off
                                    ;                                                     WimpMode auto
                                    ;                                                                  Cache on
                                    ;                                                                               Broadcast loader disabled
                                    ;                                                                                            Broadcast loader colours off
        DCB     FontMaxCMOS,        64        ; 4096k
        DCB     FontMax2CMOS,       36:EOR:12 ; 36 point
        DCB     FontMax3CMOS,       36:EOR:24 ; 36 point
        DCB     FontMax4CMOS,       16        ; 16 point
        DCB     AlarmAndTimeCMOS,   2_00010000           ; !Alarm autosave on
        DCB     FSLockCMOS+5,       &EA                  ; Checksum for no password
        DCB     SparrowMarker,      FreewayNoAutoAddress ; Stop Freeway assigning addresses to interfaces
        DCB     NetworkFlags,       LanManFStransport    ; LMTransport is NetBIOS over IP
        DCB     WimpDragMoveLimitCMOS, (1:SHL:7)         ; WimpIconiseButton
        DCB     CDROMFSCMOS,        &C1                  ; drives = 1, buffer size = 256K
        DCB     &FF
        ALIGN

        END
@


4.16
log
@Delete STB code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a desktop build):
  * STB
  * RO371Timings
  * NormalSpeedROMS
  * AutoSpeedROMS
  * RISCPCBurstMode
  * InterlacedPointer
  * ParallelFlashUpgrade (and s/FlashROM file)
  * Embedded_UI
  Some of the deleted code might be worth revisiting in future:
  * OS_ReadSysInfo 4 support for storing the MAC in alternate CMOS locations (including 2nd copy for error checking) or fetching via Service_MachineAddress
  * Mouse handling changes, possibly aimed at hiding the mouse pointer if a mouse isn't connected
  * More strict CMOS validation in s/NewReset
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.50. Tagged as 'Kernel-5_50'
@
text
@d1165 1
@


4.16.2.1
log
@Merge latest changes from main branch

Version 5.89, 4.129.2.6. Tagged as 'Kernel-5_89-4_129_2_6'
@
text
@a1164 1
        MOV     R0, R1
@


4.15
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a1622 8
    [ STB :LAND: :DEF: IOMD_C_PALNTSCType
        TEQ     R1, #TerritoryCMOS
        BEQ     %FT40           ; code driven
        TEQ     R1, #CountryCMOS
        BEQ     %FT41           ; code driven
        TEQ     R1, #TimeZoneCMOS
        BEQ     %FT42           ; code driven
    ]
a1657 20
    [ STB :LAND: :DEF: IOMD_C_PALNTSCType
40
        MOV     R2, #0                       ; PAL = territory UK
        MOV     R3, #49                      ; NTSC = territory USA
        B       %FT44
41
        MOV     R2, #1                       ; PAL = country UK
        MOV     R3, #48                      ; NTSC = country USA
        B       %FT44
42
        MOV     R2, #0                       ; PAL = 0 from UTC (GMT)
        MOV     R3, #&E0                     ; NTSC = -8 hours from UTC (USA Pacific)
        B       %FT44
44
        MOV     R14, #IOMD_Base
        LDRB    R14, [R14, #IOMD_CLINES]
        TST     R14, #IOMD_C_PALNTSCType
        MOVNE   R2, R3                       ; Select NTSC when line high
        EXIT
    ]
a1695 24
 [ ValidateCMOS :LAND: STB
DefaultCMOSTable
        ; Minimalist table
        DCB     KeyDelCMOS,         32
        DCB     KeyRepCMOS,         8
        DCB     MODETVCMOS,         &10                                     ; TV 0,1
        DCB     StartCMOS,          (1:SHL:7):OR:(2:SHL:3)                  ; NONUM, NOCAPS
        DCB     DBTBCMOS,           (1:SHL:4)                               ; Boot
        DCB     YearCMOS+0,         00
        DCB     YearCMOS+1,         20
      [ IOMD_C_MonitorType = 0 :LAND: IOMD_C_PALNTSCType = 0
        ; TV if we don't have a MonitorType auto-detect bit
        DCB     VduCMOS,            Sync_Separate :OR: MonitorType0
      |
        ; auto-detect if we have a MonitorType auto-detect bit
        DCB     VduCMOS,            Sync_Auto :OR: MonitorTypeAuto
      ]
        DCB     CountryCMOS,        1                                       ; UK
        DCB     MouseStepCMOS,      2
        DCB     SystemSpeedCMOS,    (1:SHL:2):OR:(1:SHL:4):OR:(0:SHL:5)
                                    ; Delete-etc reset
                                    ;              WimpMode auto
                                    ;                           Cache on
 |
a1722 1
      [ :LNOT: STB
a1723 1
      ]                             
a1752 11
      [ STB
        DCB     SystemSpeedCMOS,    (1:SHL:0):OR:(0:SHL:1):OR:(1:SHL:2):OR:(0:SHL:3):OR:(1:SHL:4):OR:(0:SHL:5):OR:(1:SHL:6):OR:(0:SHL:7)
                                    ; AUN ROMBoot Enabled
                                    ;              AUN auto-station numbering off
                                    ;                           Delete-etc reset
                                    ;                                        Power saving off
                                    ;                                                     WimpMode auto
                                    ;                                                                  Cache on
                                    ;                                                                               Broadcast loader disabled
                                    ;                                                                                            Broadcast loader colours off
      |
a1761 7
      ]

      [ STB
        ;       FontMaxCMOS                     yes, omitting is deliberate!
        DCB     FontMax2CMOS,       &2C       ; 32 point
        DCB     FontMax3CMOS,       &38       ; 32 point
      |
a1765 1
      ]
a1771 1
 ]
@


4.14
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a174 1
  [ HAL
a208 1
  ]
a416 1
  [ HAL
a453 1
  ]
a560 1
  [ HAL
a587 1
  ]
a732 1
  [ HAL
a765 1
  ]
a911 1
  [ HAL
a957 1
  ]
a1184 1
 [ HAL
a1245 1
 ]
d1468 1
a1468 5
  [ E2ROMSupport :LAND: :LNOT: HAL
        B       NVMemory_WriteSize
  |
        B       NVMemory_Unknown
  ]
a1600 21
; OS_NVMemory 5 - read/write value of NVRamWriteSize
;
; in:   R0 = 5
;       R1 = new value of NVRamWriteSize (in bytes, multiple of 256), or -1 to read
; out:  R1 = value of NVRamWriteSize (in bytes)
;
  [ E2ROMSupport :LAND: :LNOT: HAL

NVMemory_WriteSize ROUT
        Entry   "R2"
        LDR     R2, =ZeroPage
        CMP     R1, #-1
        LDREQB  R1, [R2, #NVRamWriteSize]
        MOVNE   R1, R1, LSR #8
        STRNEB  R1, [R2, #NVRamWriteSize]
        MOV     R1, R1, LSL #8             ; convert to bytes
        EXIT

  ] ; E2ROMSupport :LAND: :LNOT: HAL

; -----------------------------------------------------------------------------
a1641 1
    [ HAL
a1659 12
    |
        Push    "R0-R1"
        MOV     R3, #IOMD_Base
        LDRB    R1, [R3, #IOMD_ID1]
        LDRB    R0, [R3, #IOMD_ID0]
        ORR     R0, R0, R1, LSL #8
        LDR     R1, =IOMD_Original
        TEQ     R0, R1
        MOVEQ   R2, #PointerDevice_QuadMouse ; Risc PC
        MOVNE   R2, #PointerDevice_PS2Mouse  ; A7000 et al
        Pull    "R0-R1"
    ]
a1661 1
    [ HAL
a1664 29
    |
        Push    "R0-R1"
        MOV     R3, #IOMD_Base
        LDRB    R1, [R3, #IOMD_ID1]
        LDRB    R0, [R3, #IOMD_ID0]
        ORR     R0, R0, R1, LSL #8
        LDR     R1, =IOMD_7500
        TEQ     R0, R1
        LDRNE   R1, =IOMD_7500FE
        TEQNE   R0, R1
      [ STB
        MOVEQ   R2, #2_00000100              ; Cheapskates
      |
        MOVEQ   R2, #2_10100100              ; A7000 et al always have 16 bit sound
      ]
        BEQ     %FT31
        ; on Issue A's the protection bit is only weakly pulled up,
        ; so force it high, then read it back
        LDR     R3, =IOMD_MonitorType
        LDR     R1, [R3]
        ORR     R1, R1, #IOMD_SoundsystemLinkBit
        STR     R1, [R3]
        LDR     R1, [R3]
        TST     R1, #IOMD_SoundsystemLinkBit
        MOVEQ   R2, #2_10100100              ; if zero, must be Rimmer, so assume 16bit sound hardware present
        MOVNE   R2, #2_00000100              ; 8 bit sound on the motherboard (can't detect plugin upgrades)
31
        Pull    "R0-R1"
    ]
@


4.13
log
@    Previous version did not work.
Detail:
    Forgot to add a section of code when merging the work - the new reson
code would not work.
Admin:
    Built and tested this time ;-)

Version 5.42. Tagged as 'Kernel-5_42'
@
text
@d32 2
a33 2
; amg 7/12/96 Renaissance. Leave this file as is, allowing the E2ROMSupport
;             switch to disable non-STB bits
d40 1
a40 4
PhysChecksum	*	(((CheckSumCMOS + &30) :MOD: &F0) + &10)

PollMax		*	150	; Number of times to poll for an Ack (increase if you clock faster - need to
                                ; allow 5ms for write cycle).
d43 3
a45 5
RTCAddress		*	&a0     ; traditional RTC / 240 byte CMOS
  [	E2ROMSupport
E2ROMAddress		*	&a8     ; 24C08 device - 512 byte or 1K
E2ROMAddress2K		*	&e0     ; 24C174 device - 2K
E2ROMAddress2K_OTP	*	&60     ; 24C174 device - OTP section
d47 2
a48 1
E2ROMAddress8K          *       &a2     ; 24C64 device - 8K (top 2K protectable)
a50 1
  ]
a51 11
; Choose a lower limit on the number of ticks per clock phase based on the
; MaxI2Cspeed variable defined in Hdr:Machine.<Machine>
  [ MaxI2Cspeed >= 1000
I2Cticks        *       1
  |
  [ MaxI2Cspeed >= 400
I2Cticks        *       3
  |
I2Cticks        *       10
  ]
  ]
d55 1
a55 1
;	HexToBCD - Convert byte in hex to BCD
d57 1
a57 1
; in:	R0 = byte in hex
d59 2
a60 2
; out:	R0 = byte in BCD (ie R0 := (R0 DIV 10)*16 + R0 MOD 10)
;	All other registers preserved
d64 4
a67 5
	Push	"R1,R2, R14"
	MOV	R1, #10
	DivRem	R2, R0, R1, R14			; R2=R0 DIV 10; R0=R0 MOD 10
	ADD	R0, R0, R2, LSL #4
	Pull	"R1,R2, PC"
d71 1
a71 1
;	BCDToHex - Convert byte in BCD to hex
d73 1
a73 1
; in:	R0 = byte in BCD (ie x*16 + y)
d75 2
a76 2
; out:	R0 = byte in hex (ie x*10 + y)
;	All other registers preserved
d80 5
a84 5
	Push	"R14"
	MOV	R14, R0, LSR #4			; R14 := x
	ADD	R14, R14, R14, LSL #1		; R14 := x*3
	SUB	R0, R0, R14, LSL #1		; R0 := R0 - x*6 = x*10
	Pull	"PC"
d88 1
a88 3
;	SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
;
; out:	All registers preserved, including PSR
d90 5
a94 45

SetC1C0 ROUT
 [ No26bitCode
	Push	"R0-R3,R14"
        mrs    ,R3, CPSR
 |
	Push	"R0-R2,R14"
 ]
	ADD	R0, R0, R1, LSL #1	; R0 := C0 + C1*2

	[ AssemblingArthur :LOR: Module
	MOV	R2, #0				; prepare to index soft copy
	LDRB	R1, [R2, #IOCControlSoftCopy]	; read soft copy
	BIC	R1, R1, #&03			; clear clock and data
	ORR	R0, R1, R0			; put in new clock and data
	ORR	R0, R0, #&C0			; make sure two test bits are
						; always set to 1 !
	STRB	R0, [R2, #IOCControlSoftCopy]	; store back to soft copy
	|
	ORR	R0, R0, #&FC			; set other bits to 1
	]

	MOV	R2, #IOC
	STRB	R0, [R2, #IOCControl]

      [ E2ROMSupport
        [ :LNOT: :DEF: TestHarness
        MOV	R0, #0
        LDRB	R0, [R0, #NVRamSpeed]
        |
        LDRB	R0, NVSpeed
        ]
        TEQ     R0, #0
        MOVEQ   R0, #10                         ; default value if speed not checked yet
      |
        MOV     R0, #10                         ; default to slowest value if we have E2ROMSupport is false
      ]
	BL	DoMicroDelay

 [ No26bitCode
        msr    ,CPSR_f, R3
	Pull	"R0-R3,PC"
 |
	Pull	"R0-R2,PC",,^
 ]
d98 1
a98 1
;	DoMicroDelay - Delay for >= R0/2 microseconds
d100 2
a101 3
; in:	R0 = time delay in 1/2 microsecond units
;	R2 -> IOC
;	On ARM600, we may or may not be in a 32-bit mode
d103 1
a103 360
; out:	R0,R1 corrupted
;

DoMicroDelay ROUT
	Push	R14

	STRB	R0, [R2, #Timer0LR]	; copy counter into output latch
	LDRB	R1, [R2, #Timer0CL]	; R1 := low output latch
10
	STRB	R0, [R2, #Timer0LR]	; copy counter into output latch
	LDRB	R14, [R2, #Timer0CL]	; R14 := low output latch
	TEQ	R14, R1			; unchanged ?
	BEQ	%BT10			; then loop
	MOV	R1, R14			; copy anyway
	SUBS	R0, R0, #1		; decrement count
	BNE	%BT10			; loop if not finished

	Pull	PC

	LTORG

; *****************************************************************************
;
;	ClockData - Clock a bit of data down the IIC bus
;
; in:	R0 = data bit
;
; out:	All registers preserved, including PSR
;

ClockData ROUT
 [ No26bitCode
	Push	"R1,R2,R14"
        mrs    ,R2,CPSR
 |
	Push	"R1, R14"
 ]

	MOV	R1, #0			; Clock lo
	BL	SetC1C0

 [ No26bitCode
        ORR     R1,R2,#I32_bit
        msr    ,CPSR_c,R1
 |
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

	MOV	R1,PC
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
 ]
	MOV	R1, #1			; Clock hi
	BL	SetC1C0

; Delay here must be >= 4.0 microsecs

	MOV	R1, #0			; Clock lo
	BL	SetC1C0

 [ No26bitCode
        msr    ,CPSR_cf,R2              ; Restore interrupts
        Pull    "R1,R2,PC"
 |
	Pull	"R1, PC",,^
 ]

ClockData0 ROUT				; Clock a zero bit
	Push	"R0, R14"
	MOV	R0, #0
	BL	ClockData               ; preserves PSR
	Pull	"R0, PC"

; *****************************************************************************
;
;	Start - Send the Start signal
;
; out:	All registers preserved, including PSR
;

Start	ROUT
 [ No26bitCode
	Push	"R0-R3,R14"
        mrs    ,R3, CPSR
 |
	Push	"R0-R2,R14"
 ]

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0

; Delay here must be >= 4.7 microsecs (1.3 for fast device)

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
	BL	SetC1C0

 [ I2Cticks >= 10
; Hold start condition for BMU

	MOV	R2, #IOC
        MOV     R0, #10
	BL	DoMicroDelay
 ]

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
	BL	SetC1C0

 [ No26bitCode
        msr    ,CPSR_f, R3
	Pull	"R0-R3,PC"
 |
	Pull	"R0-R2,PC"
 ]

; *****************************************************************************
;
;	Acknowledge - Check acknowledge after transmitting a byte
;
; out:	All registers preserved
;	V=0 => acknowledge received
;	V=1 => no acknowledge received
;

Acknowledge ROUT
	Push	"R0-R2,R14"

	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
	BL	SetC1C0

 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        mrs    ,R1,CPSR
        Push    "R1"
        ORR     R1,R1,#I32_bit
        msr    ,CPSR_c,R1
 ]
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R2, #IOC
	LDRB	R2, [R2, #IOCControl]	; get the data from IOC

	MOV	R0, #0
	MOV	R1, #0			; clock lo
	BL	SetC1C0

 [ {TRUE}
	Pull	"R1"
	msr    ,CPSR_c,R1
 ]

	TST	R2, #1			; should be LO for correct acknowledge
        mrs    ,R2, CPSR
	BICEQ	R2, R2, #V_bit		; clear V if correct acknowledge
	ORRNE	R2, R2, #V_bit		; set V if no acknowledge
        msr    ,CPSR_f, R2

	Pull	"R0-R2,PC"

; *****************************************************************************
;
;	Stop - Send the Stop signal
;
; out:	All registers preserved, including PSR
;

Stop	ROUT
 [ No26bitCode
	Push	"R0-R2,R14"
        mrs    ,R2, CPSR
 |
	Push	"R0,R1,R14"
 ]

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
	BL	SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0

 [ No26bitCode
        msr    ,CPSR_f, R2
	Pull	"R0-R2,PC"
 |
	Pull	"R0,R1,PC",,^
 ]

; *****************************************************************************
;
;	TXByte - Transmit a byte
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved, including PSR
;

TXByte	ROUT
 [ No26bitCode
	Push	"R0-R3,R14"
        mrs    ,R3, CPSR
 |
	Push	"R0-R2,R14"
 ]
	MOV	R1, #&80		; 2^7 the bit mask
	MOV	R2, R0			; byte goes into R2
10
	ANDS	R0, R2, R1		; zero if bit is zero
	MOVNE	R0, #1
	BL	ClockData		; send the bit
	MOVS	R1, R1, LSR #1
	BNE	%BT10
 [ No26bitCode
        msr    ,CPSR_f, R3
	Pull	"R0-R3,PC"
 |
	Pull	"R0-R2,PC",,^
 ]

; *****************************************************************************
;
;	StartTXPollAck - Transmit start and a byte and poll for acknowledge
;
;	This is intended for devices with a slow internal write cycle which
;	don't ack until the write cycle is finished ( eg ATMEL AT24C01A/x )
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved, including PSR
;

StartTXPollAck	ROUT
 [ No26bitCode
	Push	"R1,R3,R14"
        mrs    ,R3, CPSR
 |
	Push	"R1,R14"
 ]
	MOV	R1, #0
10
	INC	R1
	CMP	R1, #PollMax
	Pull	"R1,pc", EQ

	BL	Start
	BL	TXByte
	BL	Acknowledge
	BVS	%BT10
 [	{FALSE}
	BREG	R1, "i2c tries:"
 ]
 [ No26bitCode
        msr    ,CPSR_f, R3
	Pull	"R1,R3,PC"
 |
	Pull	"R1,pc",,^
 ]

; *****************************************************************************
;
;	RXByte - Receive a byte
;
; out:	R0 = byte received
;	All other registers preserved, including PSR
;

RXByte	ROUT
 [ No26bitCode
	Push	"R1-R5, R14"
        mrs    ,R5, CPSR
 |
	Push	"R1-R4, R14"
 ]
	MOV	R3, #0			; byte:=0
	MOV	R2, #IOC
	MOV	R4, #7

	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
	BL	SetC1C0
10
 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        mrs    ,R1,CPSR
        Push    "R1"
        ORR     R1,R1,#I32_bit
        msr    ,CPSR_c,R1
 ]
	MOV	R0, #1			; pulse clock HI
	MOV	R1, #1
	BL	SetC1C0

	LDRB	R1, [R2, #IOCControl]	; get the data from IOC
	AND	R1, R1, #1
	ADD	R3, R1, R3, LSL #1	; byte:=byte*2+(IOC?0)AND1

	MOV	R0, #1			; return clock LO
	MOV	R1, #0
	BL	SetC1C0

 [ {TRUE}
	Pull	"R1"
	msr    ,CPSR_c,R1
 ]
	SUBS	R4, R4, #1
	BCS	%BT10

	MOV	R0, R3			; return the result in R0
 [ No26bitCode
        msr    ,CPSR_f, R5
	Pull	"R1-R5, PC"
 |
	Pull	"R1-R4, PC",,^
 ]

; *****************************************************************************

HTBTA	ROUT
	Push	R14
	BL	HexToBCD
	BL	TXAck
	Pull	PC

TXAck	ROUT
	Push	R14
	BL	TXByte
	BL	Acknowledge
	Pull	PC

CD0RBTH ROUT
	Push	R14
	BL	ClockData0
	BL	RXByte
	BL	BCDToHex
	Pull	PC

; *****************************************************************************
;
;	Write - Write a byte of CMOS RAM specified by logical address
;
; in:	R0 = address in CMOS RAM
;	R1 = data
;
; out:	All registers preserved
d134 3
a136 3
	Push	"R0-R4, R14"
	BL	MangleCMOSAddress
	Pull	"R0-R4, PC", CS		; if invalid, then exit
d144 1
a144 1
        MOV     R14, #0                 ; don't write to protected section
d150 2
a151 2
	MOV	R2, R0
	MOV	R3, R1
d154 13
a166 10
	BL	ReadStraight		; calculate new checksum :
	MOV	R4, R0
	MOV	R0, #PhysChecksum
	BL	ReadStraight
	SUB	R0, R0, R4		; = oldsum - oldcontents
	ADD	R4, R0, R3		;          + newcontents

	AND	R4, R4, #&FF
	CMPS	R2, #PhysChecksum	; don't write new checksum ...
	ORREQ	R4, R4, #&1000000	; if checksum is being written
d169 41
a209 7
 [ CacheCMOSRAM
	CMP	r2, #&100		; check small cache limit
	BCS	%FT15
  [ :LNOT: :DEF: TestHarness
	LDR	R1, =CMOSRAMCache	; update cache, but always write to
  |
        ADR     R1, i2cWorkSpace
d211 2
a212 3
	STRB	R3, [R1, R2]		; real hardware as well
15
 ]
d214 3
a216 3
	MOV	R0, R2
	BL	GetI2CAddress		; convert to device address + offset
	MOV	R2, R0			; save the offset
d218 1
a218 1
	MOV	R1, #RTCAddress
a220 2
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck
d222 22
a243 19
        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck

	AND	R0, R2, #&FF		; offset (LSB)
	BL	TXAck

	MOV	R0, R3			; data
	BL	TXAck

	BL	Stop
	[ ChecksumCMOS
	TST	R4, #&1000000		; loop again to write new checksum
	MOV	R3, R4
	MOV	R2, #PhysChecksum
	ORR	R4, R4, #&1000000	; but ensure it only happens once
	BEQ	%BT10
	]
	Pull	"R0-R4, PC"
d260 1
a260 2
        [ :LNOT: :DEF: TestHarness
        MOV	R14, #0
d262 1
a262 1
        LDRB	R14, [R14, #NVRamSize]
a263 4
        |
        LDRB	R14, NVSize
        MOV     R4, R14
        ]
d290 1
a290 1
        BHS     %FT05
d384 2
a385 6
        [ :LNOT: :DEF: TestHarness
        MOV	R14, #0
        LDRB	R14, [R14, #NVRamPageSize]
        |
        LDRB	R14, NVPageSize
        ]
a398 1
  [     CacheCMOSRAM
d402 1
a402 5
  [ :LNOT: :DEF: TestHarness
        LDR     R14, =CMOSRAMCache
  |
        ADR     R14, i2cWorkSpace
  ]
a415 1
  ]
d419 42
a460 2
  [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
d462 1
a462 1
	MOV	R1, #RTCAddress
d465 3
a467 4
	MOV	R2, R0			; save the offset
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck

d469 13
a481 2
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck
d483 2
a484 4
	AND	R0, R2, #&FF		; offset (LSB)
	BL	TXAck

        Pull    "R0-R2"
d488 10
a497 1
        Push    "R0,R2"
d500 1
a501 2
        BL      TXAck
        SUBS    R5, R5, #1
a503 2
	BL	Stop                    ; preserves flags

d506 1
a506 1
	Pull	"R0,R2,R3,R5,R6,PC"
d510 2
a511 2
;	Read - Read a byte of CMOS RAM specified by logical address
;	ReadStraight - Read a byte of CMOS RAM specified by physical address
d514 1
a514 1
; in:	R0 = address in CMOS RAM
d516 2
a517 2
; out:	R0 = data (illegal address return 0, or error for ReadWithError)
;	All other registers preserved
d521 2
a522 2
	Push	"R1,R2,R14"
	B	%FT10
d539 4
a542 4
	Push	"R1,R2,R14"
	BL	MangleCMOSAddress
	MOVCS	R0, #0			; pretend illegal addresses contain 0
	Pull	"R1,R2,PC", CS
d544 2
a545 3
  [	CacheCMOSRAM
	TEQ	R0, #&40		; is it Econet station number
	BEQ	%FT15	 		; if so then don't use cache
d549 5
a553 4
        MOV     R14, #0
        LDR     R14, [R14, #RTCFitted]
        TEQ     R14, #0
        BNE     %FT15
d557 4
a560 8
13	CMP	R0, #&100		; check small cache limit
  [ :LNOT: :DEF: TestHarness
	LDRCC	R2, =CMOSRAMCache	; if in range
  |
	ADRCC	R2, i2cWorkSpace
  ]
	LDRCCB	R0, [R2, R0]		; read from cache
	Pull	"R1,R2,PC", CC		; and exit
a563 1
  ]
d565 12
a576 5
  [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
  |
	MOV	R1, #RTCAddress
  ]
d578 3
a580 3
	MOV	R2, R0			; save the offset
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck
d582 8
a589 3
        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck
d591 3
a593 2
	AND	R0, R2, #&FF		; offset (LSB)
	BL	TXAck
d595 5
a599 1
	BL	Start
d601 23
a623 14
	ADD	R0, R1, #1		; device address for read
	BL	TXAck

	BL	RXByte			; returned in R0
	MOV	R2, R0			; copy to R2 for now

	MOV	R0, #1
	BL	ClockData

	BL	Stop

	MOV	R0, R2			; return the result

	Pull	"R1,R2,PC"
d625 1
d642 2
a643 6
        [ :LNOT: :DEF: TestHarness
        MOV	R14, #0
        LDRB	R14, [R14, #NVRamSize]
        |
        LDRB	R14, NVSize
        ]
a715 1
  [     CacheCMOSRAM
d721 1
a721 5
  [ :LNOT: :DEF: TestHarness
        LDR     R14, =CMOSRAMCache
  |
        ADR     R14, i2cWorkSpace
  ]
a734 1
  ]
d737 42
a778 3
        ADD     R0, R0, R4              ; R0 = physical address
  [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
d780 1
a780 1
	MOV	R1, #RTCAddress
a782 3
	MOV	R2, R0			; save the offset
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck
d784 3
d788 13
a800 2
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck
d802 5
a806 2
	AND	R0, R2, #&FF		; offset (LSB)
	BL	TXAck
d808 5
a812 1
	BL	Start
d814 3
a816 2
	ADD	R0, R1, #1		; device address for read
	BL	TXAck
d818 1
a818 15
        Pull    "R0-R2"
        SUB     R5, R3, R0              ; R5 = bytes being read
        ADD     R0, R0, R5              ; update return R0
        SUB     R2, R2, R5              ; update return R2
        Push    "R0,R2"
20
        BL      RXByte
        STRB    R0, [R1], #1
        SUBS    R5, R5, #1
        MOVNE   R0, #0                  ; not done - ACK byte
	MOVEQ   R0, #1                  ; done - no ACK
	BL	ClockData
        BNE     %BT20
                                        ; V will be clear
	BL	Stop
d820 1
a820 1
	Pull	"R0,R2,R3-R5,PC"
a844 1

a896 1
  [     CacheCMOSRAM
d902 1
a902 5
  [ :LNOT: :DEF: TestHarness
        LDR     R14, =CMOSRAMCache
  |
        ADR     R14, i2cWorkSpace
  ]
a915 1
  ]
d918 54
a971 3
        ADD     R0, R0, R4              ; R0 = physical address
  [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
d973 1
a973 1
	MOV	R1, #RTCAddress
d976 3
a978 4
	MOV	R2, R0			; save the offset
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck

d980 14
a993 2
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck
d995 2
a996 10
	AND	R0, R2, #&FF		; offset (LSB)
	BL	TXAck

	BL	Start

	ADD	R0, R1, #1		; device address for read
	BL	TXAck

        Pull    "R0-R2"
        SUB     R5, R3, R0              ; R5 = bytes being read
d999 7
a1005 9
        Push    "R0,R2"
20
        BL      RXByte
        ADD     R1, R1, R0
        SUBS    R5, R5, #1
        MOVNE   R0, #0                  ; not done - ACK byte
	MOVEQ   R0, #1                  ; done - no ACK
	BL	ClockData
        BNE     %BT20
d1007 3
a1009 1
	BL	Stop
d1011 1
a1011 1
	Pull	"R0,R2,R3-R5,PC"
d1015 2
a1016 2
;	GetI2CAddress - Convert NVRam physical address to i2c device address
;	                and offset
d1018 1
a1018 1
; in:	R0 = NVRam physical address (&00..size of NVRam)
d1020 1
a1020 1
; out:	R0 preserved
d1022 4
a1025 4
;	C=0 => NVRam address is valid
;	 R0 = physical address within i2c device
;	 R1 = i2c device address for writing. Increment this device address
;	      by 1 for reading. Bit 8 is set if device requires 2-byte physical address.
d1027 3
a1029 3
;	C=1 => NVRam address is out of range of CMOS or E2ROM chips
;	 R0 preserved
;	 R1 preserved
d1031 1
a1031 1
  [	E2ROMSupport
d1033 6
a1038 10
	Push	"R14"
	[ :LNOT: :DEF: TestHarness
	MOV	R14, #0			; get no 256 byte blocks and calculate end address
	LDRB	R14, [R14, #NVRamSize]
	|
	LDRB	R14, NVSize
	]
	MOV	R14, R14, LSL #8
	CMP	R0, R14
	Pull	"PC",CS 		; indicate invalid
d1041 2
a1042 13
	[ :LNOT: :DEF: TestHarness
	MOV	R1, #0
	LDRB	R1, [R1, #RTCFitted]
	|
	LDRB	R1, RTCFlag
	]
	TEQ	R1, #0
	MOVNE	R1, #RTCAddress
	[ :LNOT: :DEF: TestHarness
	LDREQB  R1, [R1, #NVRamBase]
	|
	LDREQB  R1, NVBase
	]
d1048 3
a1050 3
	MOVS	R14, R0, LSR #8		; put top bits of physical address into device address
	ORRNE	R1, R1, R14, LSL #1
	ANDNE	R0, R0, #&FF		; and use address within 256 byte block
d1053 1
a1053 1
	Pull	"PC"           		; indicate valid
a1056 1

d1059 1
a1059 1
;	MangleCMOSAddress - Convert from logical to physical address
d1061 1
a1061 1
;	Doesn't check if address is larger than the amount of NVRam installed
d1063 1
a1063 1
; in:	R0 = logical address (&00...)
d1065 2
a1066 2
; out:	C=0 => valid logical address
;	 R0 = physical address (&40..&FF,&10..&3F,&00..0F,&100..)
d1068 2
a1069 2
;	C=1 => invalid logical address
;	 R0 preserved
d1074 7
a1080 11
	Push	"R14"
	[ :LNOT: :DEF: TestHarness
	MOV	R14, #0			; read no 256 byte blocks and calculate end address
	LDRB	R14, [R14, #NVRamSize]
	|
	LDRB	R14, NVSize
	]
	MOV	R14, R14, LSL #8
	CMP	R0, R14			; if >= end address then
	Pull	"R14"
        MOVCS   PC, R14 		;    invalid (exit C set)
d1082 1
a1082 1
	CMP	R0, #&100		; if < end address && >= &100 then
d1088 1
a1088 1
	CMP	R0, #&F0		; if < &100 && >= &f0 then
d1098 3
a1100 3
	ADD	R0, R0, #&40		; now in range &40..&13F
	CMP	R0, #&100
	SUBCS	R0, R0, #(&100-&10)	; now in range &40..&FF, &10..&3F
d1106 1
a1106 1
;	ValChecksum - test to see if the CMOS checksum is OK
d1114 1
a1114 1
; in:	none
d1116 3
a1118 3
; out:	R0 = calculated checksum
;	Z	set if checksum is valid
;	All other registers preserved
d1123 1
a1123 1
ValChecksum	ENTRY "R1-R2"
d1128 3
a1130 7
	[ :LNOT: :DEF: TestHarness
	MOV	R2, #0			; read number of 256 byte blocks and calculate end address
	LDRB	R2, [R2, #NVRamSize]
	|
	LDRB	R2, NVSize
	]
	MOV	R2, R2, LSL #8
d1132 1
a1132 1
	MOV	R2, #240
d1140 5
a1144 5
	MOV	R0, #CheckSumCMOS
	BL	Read
	AND	R2, R0, #&FF		; value from checksum location
	AND	R0, R1, #&FF		; calculated value into R0
	CMPS	R0, R2
d1146 1
a1146 1
	EXIT
d1151 1
a1151 1
;	MakeChecksum - calculate and write a correct checksum
d1153 1
a1153 1
; in:	none
d1155 2
a1156 2
; out:	R0 = calculated checksum
;	All other registers preserved
d1159 1
a1159 1
	[ ChecksumCMOS
d1161 2
a1162 2
MakeChecksum	ROUT
	Push	"R1-R2,R14"
d1166 3
a1168 7
	[ :LNOT: :DEF: TestHarness
	MOV	R2, #0
	LDRB	R2, [R2, #NVRamSize]
	|
	LDRB	R2, NVSize
	]
	MOV	R2, R2, LSL #8
d1170 1
a1170 1
	MOV	R2, #240
d1173 4
a1176 4
	MOV	R0, #CheckSumCMOS
	BL	Write
	Pull	"R1-R2,PC"
	]
d1182 2
a1183 13
;	SetTime - Write the CMOS clock time and update 5-byte RealTime
;
; in:	UTC time:
;	R0 = hours
;	R1 = minutes
;	R2 = day of month
;	R3 = month
;	R5 = year (lo)
;	R6 = year (hi)
;	R7 = seconds
;	R8 = centiseconds
;
;	Any of the above, if -1, will not be written to
d1185 1
d1187 2
a1188 2
SetTime ROUT
	Push	"R4, R14"		; save registers
d1190 4
a1193 7
 [ E2ROMSupport
	[ :LNOT: :DEF: TestHarness
	MOV	R14, #0
	LDRB	R14, [R14, #RTCFitted]
	|
	LDRB	R14, RTCFlag
	]
d1195 35
a1229 2
        TEQ     R14, #0
        BNE     %FT20
d1231 2
a1232 1
; no RTC - just set soft copy
d1234 13
a1246 7
 [ :LNOT: :DEF: TestHarness
        BL      RegToRealTime
 ]
        Pull    "R4, PC"
 ]
20
; write year to CMOS RAM
d1248 9
a1256 139
	MOV	R4, R0			; save hours in R4

	Push	"R1"
	MOVS	R1, R5
	MOVPL	R0, #YearCMOS
	BLPL	Write
	MOVS	R1, R6
	MOVPL	R0, #YearCMOS+1
	BLPL	Write

	CMP	R4, #-1			; are we writing time ?
	Pull	"R1",EQ			; [no, then skip]
	BEQ	%FT30

	MOV	R0, #&01		; start at address 1
    [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R0, R1			; write address
    |
	MOV	R0, #RTCAddress
    ]
	Pull	"R1"
	BL	StartTXPollAck
	MOV	R0, #&01		; offset 1
	BL	TXAck
	MOV	R0, R8			; centiseconds
	BL	HTBTA
	MOV	R0, R7			; seconds
	BL	HTBTA
	MOV	R0, R1			; minutes
	BL	HTBTA
	MOV	R0, R4			; hours
	BL	HTBTA
	BL	Stop

30
	CMP	R2, #-1			; are we writing date ?
	BEQ	%FT40			; [no, then skip]

	MOV	R0, #&05		; start at address 5
    [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R0, R1			; write address
    |
	MOV	R0, #RTCAddress
    ]
	BL	StartTXPollAck
	MOV	R0, #&05		; offset 5
	BL	TXAck
	MOV	R0, R2			; day of month
	BL	HexToBCD
	ORR	R0, R0, R5, LSL #6	; year in bits 6,7; day in bits 0..5
	BL	TXAck
	MOV	R0, R3			; months
	BL	HTBTA
	BL	Stop

40
	MOV	R0, R4			; put hours back in R0
  [ :LNOT: :DEF: TestHarness
	BL	RTCToRealTime
  ]
	Pull	"R4, PC"

; *****************************************************************************
;
;	ReadTime - Read the CMOS clock time
;
; in:	-
;
; out:	R0 = hours
;	R1 = minutes
;	R2 = days
;	R3 = months
;	R5 = year (lo)
;	R6 = year (hi)
;	R7 = seconds
;	R8 = centiseconds
;

ReadTime ROUT
	Push	"R4, R14"

	MOV	R0, #&01		; start at address 1
    [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R0, R1			; write address
    |
	MOV	R0, #RTCAddress
    ]
	BL	StartTXPollAck
	MOV	R0, #&01		; offset 1
	BL	TXAck
	BL	Start
    [	E2ROMSupport
	ADD	R0, R1, #1		; read address
    |
	MOV	R0, #(RTCAddress+1)	; read address
    ]
	BL	TXAck
	BL	RXByte
	BL	BCDToHex
	MOV	R8, R0			; centiseconds
	BL	CD0RBTH
	MOV	R7, R0			; seconds
	BL	CD0RBTH
	MOV	R1, R0			; minutes
	BL	CD0RBTH
	MOV	R4, R0			; hours
	BL	ClockData0
	BL	RXByte
	AND	R0, R0, #&3F		; day of month (clear year bits)
	BL	BCDToHex
	MOV	R2, R0
	BL	ClockData0
	BL	RXByte
	AND	R0, R0, #&1F		; month (clear day of week bits)
	BL	BCDToHex
	MOV	R3, R0
	MOV	R0, #1
	BL	ClockData
	BL	Stop

	MOV	R0, #YearCMOS
	BL	Read
	MOV	R5, R0			; year (lo)

	MOV	R0, #YearCMOS+1
	BL	Read
	MOV	R6, R0			; year (hi)

	MOV	R0, R4			; put hours in R0

; Ensure day/month are non-zero, fixes RTCToRealTime
 [ {TRUE}				; LRust, fix RP-0370
	TEQ	R2, #0			; Valid day?
	MOVEQ	R2, #1			; No then force 1st
	TEQ	R3, #0			; Invalid month?
	MOVEQ	R3, #1			; Yes then force Jan
a1257 7
	Pull	"R4, PC"

; *****************************************************************************
;
;	InitCMOSCache - Initialise cache of CMOS RAM

  [	CacheCMOSRAM
d1259 2
a1260 2
InitCMOSCache	ENTRY "r0-r6"
    [	E2ROMSupport
a1261 23
; Need to set the slowest speed so we can probe

        MOV     R2, #0
        MOV     R3, #10         ; Default speed setting (5s delays)
	[ :LNOT: :DEF: TestHarness
        STRB    R3, [R2, #NVRamSpeed]
	|
        STRB    R3, NVSpeed
	]

;	First determine what hardware we've got fitted, R4 holds the number of
;	256 byte blocks that we've found

	; Have we got an RTC ?
	MOV	R0, #RTCAddress
	BL	DummyAccess
	MOVVS	R4, #0
	MOVVC	R4, #1
	[ :LNOT: :DEF: TestHarness
	STRB	R4, [R2, #RTCFitted]
	|
	STRB	R4, RTCFlag
	]
d1266 1
a1266 1
; Have we got a 2K E ?
d1268 3
a1270 3
	MOV	r0, #(E2ROMAddress2K+14)
	BL	DummyAccess
	MOVVC	R4, #8
d1272 1
a1272 18
	BVC	%FT5

; Have we got a 1K E ?
        MOV     r1, #E2ROMAddress
	MOV	r0, #(E2ROMAddress+6)
	BL	DummyAccess
	MOVVC	R4, #4
	BVC	%FT5

; Have we got 512 bytes of E ?
	MOV	r0, #(E2ROMAddress+2)
	BL	DummyAccess
	MOVVC	R4, #2
	BVC	%FT5

; Have we got a 16K device ? (Note that this probe would make a 24C08 device respond -
; but if we've gotten this far it would have to be a < 512 byte version; we've never
; used such a device).
d1274 1
d1276 3
a1278 3
	MOV	r0, #E2ROMAddress16K
	BL	DummyAccess
	MOVVC	R4, #64
a1283 1

d1285 3
a1287 3
	MOV	r0, #E2ROMAddress4K
	BL	DummyAccess
	MOVVC	R4, #16
d1294 7
d1302 5
a1306 4
        MOV     r1, #E2ROMAddress8K
	MOV	r0, #E2ROMAddress8K
	BL	DummyAccess
	MOVVC	R4, #32
a1312 1

d1320 9
d1330 10
a1339 2
        MOVVS   R1, #RTCAddress
        MOVVS   R5, #8          ; 256 byte page size for CMOS
d1342 4
a1345 4
	; Set the NVRam count
	[ :LNOT: :DEF: TestHarness
	STRB    R1, [R2, #NVRamBase]
	STRB	R4, [R2, #NVRamSize]
d1354 3
a1357 10
	LDR	R3, =CMOSRAMCache
	|
	STRB    R1, NVBase
	STRB	R4, NVSize
        STRB    R5, NVPageSize
        STRB    R3, NVSpeed
	ADR	R3, i2cWorkSpace
	]

	; Initialise the cache
d1359 1
a1359 1
	MOVNE	r0, #&00		; if not, then start at 0 anyway and read non-OTP data into location 0..15
d1361 2
a1362 2
	BL	ReadOTPArea
	MOV	r0, #&10		; read rest of it from 16 onwards
d1368 5
a1372 8
	MOV	R1, #RTCAddress
	MOV	R2, #&10
	MOV	R4, #&100		; stop at address &100
        [	:LNOT: :DEF: TestHarness
	LDR	R3, =CMOSRAMCache
        |
	ADR	R3, i2cWorkSpace
        ]
d1374 3
a1377 4
	BL	Start

	MOV	R0, R1			; write address
	BL	TXAck
d1379 5
d1385 15
a1399 2
        MOVNE   R0, R2, LSR #8          ; memory word address (MSB)
        BLNE    TXAck
d1401 3
a1403 44
	AND	R0, R2, #&FF		; memory word address (LSB)
	BL	TXAck

	BL	Start

	ORR	R0, R1, #1		; read address
	BL	TXAck

10
	BL	RXByte			; returned in R0
	STRB	R0, [R3, R2]
	ADD	R2, R2, #1		; increment R2 to phys. address
	CMP	R2, R4			; stop when we hit end address
	BGE	%FT20

	TST	R2, #&FF		; still in same 256 byte block?
	MOVNE	R0, #0			; yes => not done .. ACK that byte
	MOVEQ	R0, #1			; no => finish off reading block
	BL	ClockData
	BNE	%BT10			; yes => continue reading

   [ E2ROMSupport
	BL	Stop
	MOV	R0, R2			; in next 256 byte block so get device + address
	BL	GetI2CAddress
	B	%BT09			; and start next block
   ]
20
	MOV	R0, #1			; finish off reading block
	BL	ClockData
	BL	Stop

   [ E2ROMSupport
        TEQ     R4, #&100               ; have we reached the end?
        EXIT    EQ                      ; exit if so

        MOV     R0, R4                  ; start next block from R4
        MOV     R4, #&100               ; stop at &100
        BL      GetI2CAddress           ; convert to device address and offset
        MOV     R2, R0                  ; save the offset
        B       %BT09                   ; and go round again
   |
	EXIT
   ]
d1407 18
a1424 20
	BL	Start
	MOV	r0, #E2ROMAddress2K_OTP
	BL	TXAck
	MOV	r0, #0				; OTP memory word address
	BL	TXAck
	BL	Start
	MOV	r0, #E2ROMAddress2K_OTP + 1	; switch to read
	BL	TXAck
	MOV	r2, #0
10
	BL	RXByte
	STRB	r0, [r3, r2]
	ADD	r2, r2, #1
	TEQ	r2, #16
	MOVNE	r0, #0				; not done, so clock zero
	MOVEQ	r0, #1
	BL	ClockData
	BNE	%BT10
	BL	Stop
	EXIT
a1426 3
  ]


d1429 2
a1430 2
;	DummyAccess - do a dummy access of the specified device to find out
;	              if it is present
d1432 1
a1432 1
; in:	R0 = Write address of device
d1434 3
a1436 3
; out:	All registers preserved
;	V=0 => device is present
;	V=1 => device is not present
d1438 2
a1439 1
; Have we got an RTC ? do a read from location 0 to find out
d1441 13
a1453 2
  [ E2ROMSupport
DummyAccess	ENTRY
d1455 1
a1455 4
	BL	Start
	BL	TXAck			; do write and set V if no ack
	BL	Stop			; Doesn't change the PSR
	EXIT				; Exit with V set appropriately
d1465 1
a1465 1
NVMemorySWI     ENTRY
d1472 1
a1472 5
  [ E2ROMSupport
        CMP     R0, #5
  |
        CMP     R0, #4
  ]
d1480 1
a1480 1
  [ E2ROMSupport
d1482 2
d1485 2
d1490 1
a1490 1
 [ International
d1494 1
a1494 1
 ]
d1505 2
a1506 1
  [     E2ROMSupport
d1508 4
d1513 1
a1513 1
  |
d1515 1
a1515 1
  ]
d1527 2
a1528 2
        ENTRY   "R4"
        mrs    ,R4, CPSR
d1530 1
a1530 1
        msr    ,CPSR_c, R0      ; enable interrupts - this may take some time
d1536 1
a1536 1
        msr    ,CPSR_cf, R4     ; restore interrupt state
d1542 1
a1542 1
; in:   R0 = 1
d1547 2
a1548 2
        [ ProtectStationID
        TEQ     R1, #0          ; just ignore writes to byte 0
d1550 3
a1552 3
        ]
        ENTRY   "R1,R4"
        mrs    ,R4, CPSR
d1554 1
a1554 1
        msr    ,CPSR_c, R0      ; enable interrupts - this may take some time
d1560 1
a1560 1
        msr    ,CPSR_cf, R4     ; restore interrupt state
d1571 3
a1573 4
NVMemory_ReadBlock
        ENTRY   "R1-R4"
        MOV     R4, PC
        mrs    ,R4, CPSR
d1575 1
a1575 1
        msr    ,CPSR_c, R0      ; enable interrupts - this may take some time
d1582 1
a1582 1
        msr    ,CPSR_cf, R4     ; restore interrupt state
d1588 1
a1588 1
; in:   R0 = 3
d1594 2
a1595 2
        ENTRY   "R1-R4"
        mrs    ,R4, CPSR
d1597 4
a1600 3
        msr    ,CPSR_c, R0      ; enable interrupts - this may take some time
        [ ProtectStationID
        TEQ     R1, #0
d1606 1
a1606 1
        ]
d1613 1
a1613 1
        msr    ,CPSR_cf, R4     ; restore interrupt state
d1623 1
a1623 1
  [ E2ROMSupport
d1626 2
a1627 2
        ENTRY   "R2"
        MOV     R2, #0
d1635 293
a1927 1
  ] ; E2ROMSupport
d1929 1
a1929 1
	END
@


4.12
log
@    New OS_NVMemory reason code added.

Detail:
    OS_NVMemory 5 - read / write value of NVRamWriteSize
    in:  R0 = 5
         R1 = new value of NVRamWriteSize (in bytes, multiple of 256), or -1
              to return size.
    out: R1 = value of NVRamWriteSize
    This can be used to read and set the size of the protected area of NVRAM.
This is needed for Customer A 2, where there is a need to deprotect the protected
area so that NVRAM tags can be written.

Admin:
    Code by MStephens. Built and checked in by me ;-)

Version 5.41. Tagged as 'Kernel-5_41'
@
text
@d1896 3
d1900 1
@


4.11
log
@  Checked for occurences of NVRam specific workspace and put in guard condition
  [ E2ROMSupport
   .....
  ]
Detail:
  Changes to s.Middle (SysReadInfo routine that used #NVRamSpeed) and
  s.PMF.i2cutils #NVRamSpeed again
Admin:
  Compiles okay
  Requires HdrSrc-0_99 or greater (for MaxI2Cspeed variable)

Version 5.35. Tagged as 'Kernel-5_35'
@
text
@d1904 3
d2030 21
@


4.11.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d113 1
a113 1
        MRS     R3, CPSR
d149 1
a149 1
        MSR     CPSR_f, R3
d196 1
a196 1
        MRS     R2,CPSR
d206 1
a206 1
        MSR     CPSR_c,R1
d224 1
a224 1
        MSR     CPSR_cf,R2              ; Restore interrupts
d246 1
a246 1
        MRS     R3, CPSR
d276 1
a276 1
        MSR     CPSR_f, R3
d302 1
a302 1
        MRS     R1,CPSR
d305 1
a305 1
        MSR     CPSR_c,R1
d322 1
a322 1
	MSR     CPSR_c,R1
d326 1
a326 1
        MRS     R2, CPSR
d329 1
a329 1
        MSR     CPSR_f, R2
d343 1
a343 1
        MRS     R2, CPSR
d359 1
a359 1
        MSR     CPSR_f, R2
d377 1
a377 1
        MRS     R3, CPSR
d390 1
a390 1
        MSR     CPSR_f, R3
d411 1
a411 1
        MRS     R3, CPSR
d429 1
a429 1
        MSR     CPSR_f, R3
d446 1
a446 1
        MRS     R5, CPSR
d462 1
a462 1
        MRS     R1,CPSR
d465 1
a465 1
        MSR     CPSR_c,R1
d481 1
a481 1
	MSR     CPSR_c,R1
d488 1
a488 1
        MSR     CPSR_f, R5
d1383 1
a1383 1
ValChecksum	Entry "R1-R2"
d1637 1
a1637 1
InitCMOSCache	Entry "r0-r6"
d1874 1
a1874 1
DummyAccess	Entry
d1889 1
a1889 1
NVMemorySWI     Entry
d1939 2
a1940 2
        Entry   "R4"
        MRS     R4, CPSR
d1942 1
a1942 1
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
d1948 1
a1948 1
        MSR     CPSR_cf, R4     ; restore interrupt state
d1963 2
a1964 2
        Entry   "R1,R4"
        MRS     R4, CPSR
d1966 1
a1966 1
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
d1972 1
a1972 1
        MSR     CPSR_cf, R4     ; restore interrupt state
d1984 1
a1984 1
        Entry   "R1-R4"
d1986 1
a1986 1
        MRS     R4, CPSR
d1988 1
a1988 1
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
d1995 1
a1995 1
        MSR     CPSR_cf, R4     ; restore interrupt state
d2007 2
a2008 2
        Entry   "R1-R4"
        MRS     R4, CPSR
d2010 1
a2010 1
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
d2025 1
a2025 1
        MSR     CPSR_cf, R4     ; restore interrupt state
@


4.11.2.2
log
@More HAL work. IOMD HAL work in progress. Lots of my own little build
scripts. Don't touch this.

Version 5.35, 4.79.2.2. Tagged as 'Kernel-5_35-4_79_2_2'
@
text
@d107 1
a107 1
; out:	ATPCS
d111 3
a113 7
        Push    "R9,R14"
 [ HAL
        AddressHAL
        MOV     R2, R1
        MOV     R1, R0
        MOV     R0, #1
        CallHAL HAL_IICSetLines
d115 2
d119 1
d127 3
a132 1
 ]
d148 5
a152 22
        Pull    "R9,PC"

; *****************************************************************************
;
;	ReadC1C0 - Read clock and data lines to  R1 and R0 respectively
;
; out:	R0, R1 updated - otherwise ATPCS
;

ReadC1C0 ROUT
 [ HAL
        Push    "sb,lr"
        AddressHAL
        CallHAL HAL_IICReadLines
        Pull    "sb,pc"
 |
        MOV     a3, #IOC
        LDRB    a3, [a3, #IOCControl]
        MOV     a2, a1, LSR #1
        AND     a1, a1, #1
        AND     a2, a2, #1
        MOV     pc, lr
d167 2
a168 9
  [ HAL
        Push    "a3,a4,sb,ip,lr"
        AddressHAL
        MOVS    a1, a1, LSR #1
        ADC     a1, a1, #0
        CallHAL HAL_CounterDelay
        Pull    "a3,a4,sb,ip,pc"
  |
        Push    R14
a180 1
  ]
d195 2
a196 2
	Push	"R0-R3,R4,R5,R12,R14"
        MRS     R4,CPSR
d198 1
a198 1
	Push	"R0-R3,R5,R12,R14"
a199 1
        MOV     R5, R0
d205 1
a205 1
        ORR     R1,R4,#I32_bit
a214 1
        MOV     R0, R5
a219 1
        MOV     R0, R5
d224 2
a225 2
        MSR     CPSR_cf,R4              ; Restore interrupts
        Pull    "R0-R3,R4,R5,R12,PC"
d227 1
a227 1
	Pull	"R0-R3,R5,R12,PC",,^
d245 2
a246 2
	Push	"R0-R3,R4,R12,R14"
        MRS     R4, CPSR
d248 1
a248 1
	Push	"R0-R3,R12,R14"
d276 2
a277 2
        MSR     CPSR_f, R4
	Pull	"R0-R3,R4,R12,PC"
d279 1
a279 1
	Pull	"R0-R3,R12,PC"
d292 1
a292 1
	Push	"R0-R3,R12,R14"
d313 2
a314 2
        BL      ReadC1C0
        MOV     R2, R0
d331 1
a331 1
	Pull	"R0-R3,R12,PC"
d342 2
a343 2
	Push	"R0-R3,R4,R12,R14"
        MRS     R4, CPSR
d345 1
a345 1
	Push	"R0-R3,R12,R14"
d360 1
a360 1
	Pull	"R0-R3,R4,R12,PC"
d362 1
a362 1
	Pull	"R0-R3,R12,PC",,^
d445 1
a445 1
	Push	"R1-R6,R12,R14"
d448 1
a448 1
	Push	"R1-R4, R6, R12, R14"
d450 2
a451 1
	MOV	R6, #0			; byte:=0
d471 3
a473 2
        BL      ReadC1C0
        ADD     R6, R0, R6, LSL #1      ; byte:=byte*2+ SDA
d486 1
a486 1
	MOV	R0, R6			; return the result in R0
d489 1
a489 1
	Pull	"R1-R6, R12, PC"
d491 1
a491 1
	Pull	"R1-R4, R6, R12, PC",,^
@


4.11.2.3
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@d164 1
a164 1
        LDRB    a1, [a3, #IOCControl]
@


4.11.2.4
log
@  Added HAL NVRAM support
Detail:
  Added the HAL NVRAM entries.
  Modified i2cutils to use the HAL entries for NVRAM and behave sensibly if the HAL reports that there is no NVRAM, in which case there must be a forced reset_cmos call so that the cache gets set up sensibly.
Admin:
  Tested under the RPC emulator and appears to be working correctly, although some calls to IIC are still being made in the no nvram case.

Version 5.35, 4.79.2.8. Tagged as 'Kernel-5_35-4_79_2_8'
@
text
@d47 1
d55 1
a68 1

d116 1
a116 1
        MOV     R0, #0
d134 1
d137 3
d288 1
a289 2
        LDR	R0, =ZeroPage
        LDRB	R0, [R0, #NVRamSpeed]
d291 4
a294 4
    	CMP 	R0, #10
	MOVGE	R2, #IOC
        MOVGE   R0, #10
	BLGE	DoMicroDelay
d610 1
d613 1
d615 3
d620 1
a620 29

  [ HAL
    	Push	"R12,sb"
    	AddressHAL
    	MOV 	R12, R2
    	CallHAL	HAL_NVMemoryType
    	AND 	R0, R0, #NVMemoryFlag_Provision
    	TEQ 	R0, #NVMemoryFlag_None

    	; If there's no NVmemory, all we have is the internal cache.
    	Pull 	"R12,sb", EQ
	Pull	"R0-R4,PC", EQ

    	TEQ 	R0, #NVMemoryFlag_HAL
    	BNE 	%FT20	    	    	; Go and do IIC stuff.

    	; Make the HAL call - we have to write the data into a buffer.
    	Push	"R3"
    	MOV 	R0, R12
    	MOV 	R1, sp
    	MOV 	R2, #1
    	CallHAL	HAL_NVMemoryWrite
    	Pull	"R3"
    	Pull	"R12,sb"
    	Pull	"R0-R4,PC"
20
  ]


d667 1
d672 4
d796 1
d799 3
d815 1
d819 1
d821 3
d837 1
a840 31
  [ HAL
    	Push	"R12, sb"
    	MOV 	R5, R0	    	    	; save address
    	AddressHAL
    	CallHAL	HAL_NVMemoryType
    	AND 	R0, R0, #NVMemoryFlag_Provision
    	TEQ 	R0, #NVMemoryFlag_None

    	; If there's no NVmemory, tough - we just return.
    	Pull 	"R12,sb", EQ
    	Pull	"R0-R2", EQ
    	MOVEQ 	R2, #0	    	    	; nothing written
	Pull	"R3,R5-R6,PC", EQ

    	TEQ 	R0, #NVMemoryFlag_HAL
    	MOV 	R0, R5	    	    	; restore address
    	BNE 	%FT17	    	    	; do IIC things.

    	; Make the HAL call
    	CallHAL	HAL_NVMemoryWrite    	; returns bytes wrtten in R0
    	MOV 	R2, R0
    	ADD 	R0, R0, R2  	    	; update return R0
    	ADD 	R4, R4, R2
    	Pull	"R12,sb"
    	Pull	"R0-R2"
    	Pull	"R3,R5-R6,PC"

17
    	Pull	"sb"
  ]

d912 1
d926 1
d928 3
a935 28

  [ HAL
    	Push	"R4, sb"
    	MOV 	R4, R0	    	    	; save address
    	AddressHAL
    	CallHAL	HAL_NVMemoryType
    	AND 	R0, R0, #NVMemoryFlag_Provision
    	TEQ 	R0, #NVMemoryFlag_None

    	; If there's no NVmemory, pretend addresses contain 0
    	Pull 	"R4, sb", EQ
    	MOVEQ 	R0, #0
	Pull	"R1,R2,PC", EQ

    	TEQ 	R0, #NVMemoryFlag_HAL
    	MOV 	R0, R4	    	    	; restore address
    	BNE 	%FT20

    	; Make the HAL call - we have to provide a buffer.
    	SUB 	sp, sp, #4	    	; make some space on the stack
    	MOV 	R1, sp
    	MOV 	R2, #1
    	CallHAL	HAL_NVMemoryRead
    	LDRB 	R0, [sp], #4	    	; read back from stack and restore
    	Pull	"R4, sb"
    	Pull	"R1,R2,PC"

20
d988 1
d991 3
d1066 1
d1072 1
d1074 3
d1090 1
a1093 32
  [ HAL
    	Push	"sb"
    	MOV 	R5, R0	    	    	; save address
    	AddressHAL
    	Push	"R1-R3,R12"
    	CallHAL	HAL_NVMemoryType
    	Pull	"R1-R3,R12"
    	AND 	R0, R0, #NVMemoryFlag_Provision
    	TEQ 	R0, #NVMemoryFlag_None

    	; If there's no NVmemory, tough - we just return.
    	MOVEQ 	R2, #0	    	    	; nothing read
    	Pull 	"sb", EQ
	Pull	"R3-R5,PC", EQ

    	TEQ 	R0, #NVMemoryFlag_HAL
    	MOV 	R0, R5	    	    	; restore address
    	BNE 	%FT17	    	    	; do IIC things.

    	; Make the HAL call
    	Push	"R12"
    	CallHAL	HAL_NVMemoryRead    	; returns bytes read in R0
    	Pull	"R12"
    	MOV 	R2, R0
    	ADD 	R0, R0, R1  	    	; update return R0
    	Pull	"sb"
    	Pull	"R3-R5,PC"

17
    	Pull	"sb"
  ]

d1210 1
d1216 1
d1218 3
d1234 1
d1299 1
d1302 3
d1310 1
d1313 3
d1318 1
d1320 3
d1356 1
d1359 3
d1413 1
d1416 3
d1455 1
d1458 3
d1494 1
d1497 3
d1506 1
d1508 1
a1508 1

d1573 1
d1575 1
a1575 1

a1658 3
;  in: -
;
;  out: R0 = 0 for failure
d1660 3
a1662 1
InitCMOSCache	Entry "r1-r6, sb"
d1667 1
a1667 1
        LDR     R4, =ZeroPage
d1669 5
a1673 1
        STRB    R3, [R4, #NVRamSpeed]
a1677 43
 [ HAL
        AddressHAL
    	CallHAL	HAL_NVMemoryType
    	ANDS 	R0, R0, #NVMemoryFlag_Provision
    	EXIT	EQ
    	MOV 	R5, R0

    	; If it's only a maybe, then we probe
    	TEQ 	R5, #NVMemoryFlag_MaybeIIC
    	BEQ 	%FT03

    	; Else we read the size

    	CallHAL	HAL_NVMemorySize	; returns number of bytes but..
    	MOV 	R0, R0, LSR#8	    	; .. expecting no. of 256 blocks
    	STRB 	R0, [R4, #NVRamSize]

    	CallHAL	HAL_NVMemoryIICAddress
    	STRB 	R0, [R4, #NVRamBase]

    	MOV 	R0, #0
    	CallHAL	HAL_IICType
    	MOV 	R3, #10
    	TST 	R0, #IICFlag_Fast
    	MOVNE	R3, #3
    	TST 	R0, #IICFlag_HighSpeed
    	MOVNE	R3, #1
    	STRB	R3, [R4, #NVRamSpeed]

    	; If we're using IIC then read in the cache manually
    	TEQ 	R0, #NVMemoryFlag_IIC
    	BEQ   	%FT06

    	; Else use HAL routine.
    	MOV 	R0, #0
    	LDR 	R1, =CMOSRAMCache
    	MOV 	R2, #&100
    	CallHAL	HAL_NVMemoryRead
    	TEQ 	R0, #&100
    	MOVNE	R0, #0	    	    	; Failure exit condition
    	EXIT
03
 ]
a1679 1
    	LDR 	R2, =ZeroPage
d1683 1
d1685 3
a1687 1

a1755 1
    	BVC 	%FT5
d1758 1
a1758 9
        MOVVS   R0, #RTCAddress
    	BL  	DummyAccess
        MOV     R5, #8          ; 256 byte page size for CMOS
    	BVC 	%FT5

; We ain't got anything!
        STRB    R5, [R2, #NVRamPageSize]
    	MOV 	R0, #0	    	; Exit failure
    	EXIT
d1762 1
d1773 1
a1773 2
06
	; Initialise the cache
d1775 7
d1783 1
d1797 1
d1799 3
a1846 1
    	MOV 	R0, #1	    	    	; ensure exit success
d1881 3
@


4.11.2.5
log
@Wahey! This version gives you a display.

It says "Abort on data transfer".
@
text
@a636 1
        Pull    "R12,sb"
a993 1
        Pull    "R4, sb"
@


4.11.2.6
log
@More L7200 HAL work
@
text
@d1725 1
a1725 1
        BEQ     InitCMOSCache_NoCMOS
d1849 1
a1849 7
InitCMOSCache_NoCMOS
        LDR     R2, =ZeroPage
        MOV     R5, #8
        STRB    R5, [R2, #NVRamPageSize]        ; Act as though we have 256 bytes of
        MOV     R1, #1                          ; single page CMOS.
        STRB    R1, [R2, #NVRamSize]
        STRB    R1, [R2, #NVRamWriteSize]
@


4.11.2.7
log
@Customer L-y HAL-y IIC-y type stuff. It's great.
@
text
@d42 3
d55 12
d102 63
d167 9
d177 9
a185 1
HTBS9   ROUT
d187 348
a534 3
        BL      HexToBCD
        STRB    R0, [R9], #1
        Pull    PC
d613 1
a613 1
    	Push	"R2,R12,sb"
d615 1
d621 1
a621 1
    	Pull 	"R2,R12,sb", EQ
a627 1
        Pull    "R0"
d629 1
a629 5
    	MOV 	R1, sp
    	MOV 	R2, #1
    	CallHAL	HAL_NVMemoryWrite
        STR     R4, [sp]
        MOV     R0, #PhysChecksum
d649 2
d652 9
a660 13
        AND     R0, R1, #&FF            ; device address for write
        ORR     R0, R0, #1:SHL:29       ; retry
        TST     R1, #&100               ; NE if two byte offset
        SUB     R13, R13, #4
        MOV     R14, R13
        MOVNE   R1, R2, LSR #8
        STRNEB  R1, [R14], #1           ; offset (MSB)
        STRB    R2, [R14], #1           ; offset (LSB)
        STRB    R3, [R14], #1           ; data
        MOV     R1, R13
        SUB     R2, R14, R13
        BL      IIC_Op
        ADD     R13, R13, #4
d662 1
d883 4
a886 3
        MOV     R2, R0                  ; save the offset
        SUB     R13, R13, #12*2+4
        MOV     R14, R13
d888 5
a892 13
        MOVNE   R0, R2, LSR #8
        STRNEB  R0, [R14], #1           ; offset (MSB)
        STRB    R2, [R14], #1           ; offset (LSB)

        SUB     R14, R14, R13
        STR     R14, [R13, #12]         ; transfer 1 length

        AND     R14, R1, #&FF
        ORR     R0, R14, #1:SHL:29      ; (retry)
        STR     R0, [R13, #4]           ; transfer 1 address
        ORR     R14, R14, #1:SHL:31     ; (no repeated start)
        STR     R14, [R13, #16]         ; transfer 2 address
        STR     R13, [R13, #8]          ; transfer 1 data
d894 1
a894 2
        ADD     R14, R13, #12*2+4
        LDMIA   R14, {R0-R2}
d898 1
a898 10
        STMIB   R14, {R0,R2}

        STR     R1, [R13, #20]          ; transfer 2 data
        STR     R5, [R13, #24]          ; transfer 2 length
        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV

        LDR     R1, [R13, #20]          ; recover data pointer
        ADD     R13, R13, #12*2+4+4
d901 2
a903 1
        ADD     R6, R6, R0              ; update checksum counter
d906 2
d1004 25
a1028 21
        SUB     R13, R13, #2*12+4
        MOV     R14, R13
        TST     R1, #&100
        MOVNE   R2, R0, LSR #8
        STRNEB  R2, [R14], #1           ; offset (MSB)
        STRB    R0, [R14], #1           ; offset (LSB)
        SUB     R14, R14, R13
        STR     R13, [R13, #8]          ; transfer 1 data
        STR     R14, [R13, #12]         ; transfer 1 length
        AND     R14, R1, #&FF
        ORR     R2, R14, #1:SHL:29      ; retry
        STR     R2, [R13, #4]           ; transfer 1 address
        ORR     R14, R14, #1            ; device address for read
        STR     R14, [R13, #16]         ; transfer 2 address
        ADD     R14, R13, #3
        STR     R14, [R13, #20]         ; transfer 2 data
        MOV     R14, #1
        STR     R14, [R13, #24]         ; transfer 2 length
        BL      IIC_OpV
        LDRB    R0, [R13, #3]
        ADD     R13, R13, #2*12+4
d1182 3
a1185 3
        MOV     R2, R0                  ; save the offset
        SUB     R13, R13, #12*2+4
        MOV     R14, R13
d1187 7
a1193 13
        MOVNE   R0, R2, LSR #8
        STRNEB  R0, [R14], #1           ; offset (MSB)
        STRB    R2, [R14], #1           ; offset (LSB)

        SUB     R14, R14, R13
        STR     R14, [R13, #12]         ; transfer 1 length

        AND     R14, R1, #&FF
        ORR     R0, R14, #1:SHL:29      ; retry
        STR     R0, [R13, #4]           ; transfer 1 address
        ORR     R14, R14, #1            ; device address for read
        STR     R14, [R13, #16]         ; transfer 2 address
        STR     R13, [R13, #8]          ; transfer 1 data
d1195 4
a1198 2
        ADD     R14, R13, #12*2+4
        LDMIA   R14, {R0-R2}
d1202 11
a1212 13
        STMIB   R14, {R0,R2}

        STR     R1, [R13, #20]          ; transfer 2 data
        STR     R5, [R13, #24]          ; transfer 2 length
        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV

        LDR     R1, [R13, #20]          ; recover data pointer
        ADD     R1, R1, R5
        ADD     R13, R13, #12*2+4+4

        CLRV
a1313 47
  [ HAL
        ADD     R3, R3, R4
    	Push	"sb"
    	MOV 	R5, R0	    	    	; save address
    	AddressHAL
    	Push	"R1-R3,R12"
    	CallHAL	HAL_NVMemoryType
    	Pull	"R1-R3,R12"
    	AND 	R0, R0, #NVMemoryFlag_Provision
    	TEQ 	R0, #NVMemoryFlag_None

        SUB     R14, R3, R5
        LDMIB   R13, {R0-R2}
        ADD     R0, R0, R14
        MOV     R4, R1
        SUB     R2, R2, R14
        STMIB   R13, {R0-R2}

    	; If there's no NVmemory, tough - we just return.
    	Pull 	"sb", EQ
	Pull	"R0-R5,PC", EQ

    	TEQ 	R0, #NVMemoryFlag_HAL
    	MOV 	R0, R5	    	    	; restore address
    	BNE 	%FT17	    	    	; do IIC things.

        Push    "R6"
        MOV     R4, #0
        MOV     R6, R3
        SUB     R13, R13, #4
16
        MOV     R0, R5
        MOV     R1, sp
        MOV     R2, #1
        CallHAL HAL_NVMemoryRead
        LDRB    R14, [R13]
        ADD     R4, R4, R14
        ADD     R5, R5, #1
        TEQ     R5, R6
        BNE     %BT16
        ADD     R13, R13, #4
        Pull    "R6,sb"
        Pull    "R0-R2"
        ADD     R1,R1,R4
        Pull    "R3-R5,PC"
17
  ]
d1320 4
a1323 3
        MOV     R2, R0                  ; save the offset
        SUB     R13, R13, #12*2+4
        MOV     R14, R13
d1325 7
a1331 14
        MOVNE   R0, R2, LSR #8
        STRNEB  R0, [R14], #1           ; offset (MSB)
        STRB    R2, [R14], #1           ; offset (LSB)

        SUB     R14, R14, R13
        STR     R14, [R13, #12]         ; transfer 1 length

        AND     R14, R1, #&FF
        ORR     R0, R14, #1:SHL:29      ; retry
        STR     R0, [R13, #4]           ; transfer 1 address
        ORR     R14, R14, #1            ; device address for read
        ORR     R14, R14, #1:SHL:30     ; checksum only please
        STR     R14, [R13, #16]         ; transfer 2 address
        STR     R13, [R13, #8]          ; transfer 1 data
d1333 4
a1336 2
        ADD     R14, R13, #12*2+4
        LDMIA   R14, {R0-R2}
d1340 9
a1348 2
        STMIB   R14, {R0,R2}
        MOV     R4, R1                  ; remember checksum
d1350 1
a1350 8
        STR     R5, [R13, #24]          ; transfer 2 length
        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV

        LDR     R1, [R13, #20]          ; read back checksum
        ADD     R1, R1, R4              ; update checksum
        ADD     R13, R13, #12*2+4+4
d1543 1
a1543 1
	Push	"R4, R9, R14"		; save registers
d1556 1
a1556 1
        Pull    "R4, R9, PC"
d1575 1
a1575 15
	Pull	"R1"

        SUB     R13, R13, #8
        MOV     R9, R13
        MOV     R0, #&01                ; offset 1
        STRB    R0, [R9], #1
        MOV     R0, R8                  ; centiseconds
        BL      HTBS9
        MOV     R0, R7                  ; seconds
        BL      HTBS9
        MOV     R0, R1                  ; minutes
        BL      HTBS9
        MOV     R0, R4                  ; hours
        BL      HTBS9
        Push    "R0-R2"
a1576 1
	MOV	R0, #&01		; start at address 1
d1582 13
a1594 6
        ORR     R0, R0, #1:SHL:29       ; retry
        MOV     R1, R13
        SUB     R2, R9, R13
        BL      IIC_Op
        Pull    "R0-R2"
        ADD     R13, R13, #8
d1600 1
a1600 11
        SUB     R13, R13, #8
        MOV     R9, R13
        MOV     R0, #&05                ; offset 5
        STRB    R0, [R9], #1
        MOV     R0, R2                  ; day of month
        BL      HexToBCD
        ORR     R0, R0, R5, LSL #6      ; year in bits 6,7; day in bits 0..5
        STRB    R0, [R9], #1
        MOV     R0, R3                  ; months
        BL      HTBS9
        Push    "R0-R2"
a1601 1
	MOV	R0, #&05		; start at address 5
d1607 10
a1616 5
        ORR     R0, R0, #1:SHL:29       ; retry
        MOV     R1, R13
        SUB     R2, R9, R13
        BL      IIC_Op
        Pull    "R0-R2"
d1622 1
a1622 1
	Pull	"R4, R9, PC"
d1642 2
a1643 1
        SUB     R13, R13, #12*2+8
a1644 1
	MOV	R0, #&01		; start at address 1
d1650 32
a1681 38
        ORR     R14, R0, #1:SHL:29      ; retry
        STR     R14, [R13, #8]          ; transfer 1 address
        ADD     R0, R0, #1
        STR     R0, [R13, #20]          ; transfer 2 address
        MOV     R0, #&01                ; offset 1
        STRB    R0, [R13, #0]
        STR     R13, [R13, #12]         ; transfer 1 data
        STR     R0, [R13, #16]          ; transfer 1 length
        ADD     R0, R13, #1
        STR     R0, [R13, #24]          ; transfer 2 data
        MOV     R0, #6
        STR     R0, [R13, #28]          ; transfer 2 length

        ADD     R0, R13, #8
        MOV     R1, #2
        BL      IIC_OpV

        LDRB    R0, [R13, #1]
        BL      BCDToHex
        MOV     R8, R0                  ; centiseconds
        LDRB    R0, [R13, #2]
        BL      BCDToHex
        MOV     R7, R0                  ; seconds
        LDRB    R0, [R13, #3]
        BL      BCDToHex
        MOV     R1, R0                  ; minutes
        LDRB    R0, [R13, #4]
        BL      BCDToHex
        MOV     R4, R0                  ; hours
        LDRB    R0, [R13, #5]
        AND     R0, R0, #&3F            ; day of month (clear year bits)
        BL      BCDToHex
        MOV     R2, R0
        LDRB    R0, [R13, #6]
        AND     R0, R0, #&1F            ; month (clear day of week bits)
        BL      BCDToHex
        MOV     R3, R0
        ADD     R13, R13, #12*2+8
a1856 1
        STRB    R0, [R2, #RTCFitted]
a1889 3

        ; Note - R4 MUST be &100 to prevent crossover between 256-byte pages
        ; (for devices with multiple addresses)
d1891 1
d1893 2
a1895 5
        SUB     R13, R13, #2*12+4
        AND     R0, R1, #&FF
        STR     R0, [R13, #4]           ; transfer 1 address
        ADD     R0, R0, #1              ; read address
        STR     R0, [R13, #16]          ; transfer 2 address
d1897 48
a1944 19
        MOV     R14, R13
        MOVNE   R0, R2, LSR #8
        STRNEB  R0, [R14], #1           ; memory word address (MSB)
        STRB    R2, [R14], #1           ; memory word address (LSB)
        STR     R13, [R13, #8]          ; transfer 1 data
        SUB     R14, R14, R13
        STR     R14, [R13, #12]         ; transfer 1 length
        ADD     R14, R3, R2
        STR     R14, [R13, #20]         ; transfer 2 data
        SUB     R14, R4, R2
        STR     R14, [R13, #24]         ; transfer 2 length

        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV

        ADD     R13, R13, #2*12+4
        MOV     R0, #1
        EXIT
d1948 20
a1967 18
        SUB     R13, R13, #2*12+4
        MOV     R0, #0
        STRB    R0, [R13, #0]           ; offset 0
        MOV     R0, #E2ROMAddress2K_OTP
        STR     R0, [R13, #4]           ; transfer 1 address
        STR     R13, [R13, #8]          ; transfer 1 data
        MOV     R0, #1
        STR     R0, [R13, #12]          ; transfer 1 length
        MOV     R0, #E2ROMAddress2K_OTP + 1
        STR     R0, [R13, #16]          ; transfer 2 address
        STR     R3, [R13, #20]          ; transfer 2 data
        MOV     R0, #16
        STR     R0, [R13, #24]          ; transfer 2 length
        ADD     R0, R13, #4
        MOV     R1, #2
        BL      IIC_OpV
        ADD     R13, R13, #2*12+4
        EXIT
d1984 1
a1984 5
DummyAccess	Entry "R1,R2"

        MOV     R1, #0
        MOV     R2, #0
        BL      IIC_Op
d1986 3
@


4.11.2.8
log
@Hopefully working NVMemory on Customer L now.

Version 5.35, 4.79.2.20. Tagged as 'Kernel-5_35-4_79_2_20'
@
text
@a155 3
        TEQ     R4, R3                  ; don't bother with write if
        Pull    "R0-R4, PC", EQ         ; oldcontents == newcontents

d173 1
a173 1
    	Push	"R2,R3,sb,R12"
d180 1
a180 1
    	Pull 	"R2,R3,sb,R12", EQ
d188 1
a188 1
        STRB    R3, [sp, #-4]!
d192 1
a192 5
        TST     R4, #&1000000
        BNE     %FT18
        LDR     R1, =CMOSRAMCache
        STRB    R4, [R1, #PhysChecksum]
        STRB    R4, [sp]
d197 2
a198 3
18
    	ADD     sp, sp, #4
    	Pull	"R3,sb,R12"
d201 1
a201 1
        Pull    "R2,R3,sb,R12"
d412 1
a412 1
    	Push	"sb, R12"
d420 1
a420 1
    	Pull 	"sb,R12", EQ
d431 4
a434 3
        MOV     R5, R0
    	Pull	"sb,R12"

a435 9

        ADD     R0, R0, R5
        SUB     R2, R2, R5

16      SUBS    R5, R5, #1              ; update checksum
        LDRCS   R14, [R1], #1
        ADDCS   R4, R4, R14
        BCS     %BT16

d439 1
a439 1
    	Pull	"sb,R12"
d548 1
a548 1
    	Push	"R3,sb,R12"
d556 1
a556 1
    	Pull 	"R3,sb,R12", EQ
d570 1
a570 1
    	Pull	"R3,sb,R12"
d574 1
a574 1
        Pull    "R3, sb,R12"
a720 2
        ADD     R3, R3, R4
        SUB     R2, R3, R0
d742 2
a743 1
        MOV     R4, R0
a744 4
        Pull    "R0-R2"
        ADD     R0, R0, R4
        ADD     R1, R1, R4
        SUB     R2, R2, R4
d894 1
a894 1
        ADD     R0, R0, R4              ; R0 = physical start address
d896 2
a897 2
        ADD     R3, R3, R4              ; R3 = physical end address
    	Push	"sb,R12"
d900 1
a900 1
    	Push	"R1-R3"
d902 3
a904 4
    	Pull	"R1-R3"
    	AND 	R4, R0, #NVMemoryFlag_Provision
    	MOV 	R0, R5	    	    	; restore address
    	TEQ 	R4, #NVMemoryFlag_None
d906 6
a911 7
        SUB     R14, R3, R0
        LDR     R1, [R13,#8]
        LDR     R3, [R13,#16]
        ADD     R1, R1, R14
        SUB     R3, R3, R14
        STR     R1, [R13,#8]
        STR     R3, [R13,#16]
d914 1
a914 1
    	Pull 	"sb,R12", EQ
d917 2
a918 1
    	TEQ 	R4, #NVMemoryFlag_HAL
d923 1
a923 1
        ADD     R6, R5, R14
d936 1
a936 1
        Pull    "R6,sb,R12"
a940 1
        Pull    "sb,R12"
d1361 1
a1361 1
InitCMOSCache	Entry "r1-r6, sb,r12"
a1389 9
        TST     R5, #NVMemoryFlag_ProtectAtEnd
        STREQB  R0, [R4, #NVRamWriteSize]
        BEQ     %FT02
        CallHAL HAL_NVMemoryProtectedSize
        LDRB    R1, [R4, #NVRamSize]
        SUB     R0, R1, R0, LSR#8
        STRB    R0, [R4, #NVRamWriteSize]

02
@


4.11.2.9
log
@Block NVMemory write checksumming fixed.

Version 5.35, 4.79.2.21. Tagged as 'Kernel-5_35-4_79_2_21'
@
text
@d449 1
a449 1
        ADDCS   R6, R6, R14
a450 1
        MOV     R4, R6
@


4.11.2.10
log
@Various fixes to NVMemory code. Really needs to be re-engineered.

Version 5.35, 4.79.2.26. Tagged as 'Kernel-5_35-4_79_2_26'
@
text
@d44 1
d48 1
a48 2
E2ROMAddress8K_prot     *       &a2     ; 24C64 device - 8K (top 2K protectable)
E2ROMAddress8K          *       &ae     ; 24C64 device - 8K
d735 1
a735 2
        ADD     R0, R0, R4              ; R0 = physical start address
        ADD     R3, R3, R4              ; R3 = physical end address
d738 1
a772 2
        SUB     R5, R3, R0              ; R5 = bytes being read

d800 1
d917 1
a918 1
  [ HAL
a927 2
        TEQNE   R4, #NVMemoryFlag_HAL
        BNE     %FT17                   ; do IIC things.
a936 1
    	TEQ 	R4, #NVMemoryFlag_None
d941 3
a965 1
        SUB     R5, R3, R0              ; R5 = bytes being read
d993 1
d1469 17
a1485 1
; Have we got a 16K device ?
d1495 1
a1508 10
	BL	DummyAccess
	MOVVC	R4, #32
        MOVVC   R5, #5          ; 32 byte page size
        MOVVC   R3, #3          ; Fast speed setting (1.5s delays)
        BVC     %FT5

; Have we got a protected 8K device?

        MOV     r1, #E2ROMAddress8K_prot
	MOV	r0, #E2ROMAddress8K_prot
@


4.11.2.11
log
@* Fixed the IIC code.
* Kernel puts sensible default FIQ handler in through the HAL.
* Fix to temporary page uncaching code.

Version 5.35, 4.79.2.30. Tagged as 'Kernel-5_35-4_79_2_30'
@
text
@a617 2
        ADD     R0, R13, #4
        MOV     R1, #2
@


4.11.2.12
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d32 2
a33 2
; 07-Dec-96  AMG   Renaissance. Leave this file as is, allowing the E2ROMSupport
;                  switch to disable non-STB bits
d40 1
a40 1
PhysChecksum		*	(((CheckSumCMOS + &30) :MOD: &F0) + &10)
d43 1
a43 2
RTCAddressPHI		*	&a0     ; Philips RTC + 240 byte CMOS
RTCAddressDAL		*	&d0     ; Dallas RTC + 56 byte CMOS
d46 5
a50 5
E2ROMAddress4K		*	&a4     ; 24C32 device - 4K (top 1K protectable)
E2ROMAddress8K_prot	*	&a2     ; 24C64 device - 8K (top 2K protectable)
E2ROMAddress8K		*	&ae     ; 24C64 device - 8K
E2ROMAddress16K		*	&a8     ; 24C128 device - 16K
E2ROMAddress32K		*	&a6     ; 24CS256 device - 32K (top 2K possibly OTP)
d89 1
a89 3
;
;       HTBSR9 - hex to BCD and store at "next free byte" R9
;
d218 1
a218 1
	MOV	R1, #RTCAddressPHI
d462 1
a462 1
	MOV	R1, #RTCAddressPHI
d597 1
a597 1
	MOV	R1, #RTCAddressPHI
d780 1
a780 1
	MOV	R1, #RTCAddressPHI
a969 1

d973 1
a973 1
	MOV	R1, #RTCAddressPHI
d1042 4
a1045 4
	;LDRB	R1, [R1, #RTCFitted]    ; This causes a headache if both an RTC and NVRAM are fitted
	;TEQ	R1, #0
	;LDREQB  R1, [R1, #NVRamBase]   ; RTC overlaps bottom of NVRAM
	LDRB    R1, [R1, #NVRamBase]    ; RTC overlaps bottom of NVRAM
d1198 1
a1198 1
;	If R0,R2,R5 or R6 is -1 then the time,date,year,century (respectively) will not be written
d1202 5
a1206 1
	Push	"R4, R9-R10, R14"	; save registers
d1208 1
a1208 3
	LDR	R10, =ZeroPage
	LDRB	R10, [R10, #RTCFitted]
        TEQ     R10, #0			; no RTC - just set soft copy
d1211 2
a1213 1
        Pull    "R4, R9-R10, PC"
d1215 2
d1218 3
a1220 2
	Push	"R0-R2"
	MOV	R4, R0			; copy hours in R4
d1223 1
a1223 1
	MOVS	R1, R5                  ; year held seperately from the RTC
a1228 1
	Pull	"R1"
d1231 1
d1234 2
d1238 1
a1238 3
	TEQ	R10, #RTCAddressPHI
        MOVEQ   R0, #1                  ; offset to start of time (varies)
        MOVNE   R0, #0
d1240 2
a1241 2
        MOVEQ   R0, R8                  ; centiseconds (not for Dallas parts)
        BLEQ    HTBS9
d1248 14
a1261 4
        MOV	R6, R2
	BL	%FT45
	MOV	R2, R6			; preserve D-O-M for later
        ADD	R13, R13, #8
d1265 1
a1265 1
	BEQ	%FT40
d1269 1
a1269 5
	TEQ	R10, #RTCAddressPHI
	BNE     %FT35

	; Philips specific handling
        MOV     R0, #5                  ; offset 5
d1277 13
a1289 14
	B	%FT37
35
	; Dallas specific handling
	MOV	R0, #4                  ; offset 4
	STRB    R0, [R9], #1
	MOV     R0, R2
	BL	HTBS9
	MOV	R0, R3
	BL	HTBS9
	MOV	R0, R5
	BL	HTBS9			; don't bother setting the D-O-W
37
	BL      %FT45
	ADD	R13, R13, #8
d1292 4
a1295 12
	Pull    "R0-R2"
	BL	RTCToRealTime		; update RAM copy
	Pull	"R4, R9-R10, PC"

45
	MOV     R0, R10
        ORR     R0, R0, #1:SHL:29
        MOV     R1, R13
        SUB     R2, R9, R13
        Push    "R14"
        BL      IIC_Op                  ; write the prepared block with retries
	Pull    "PC"
d1315 9
a1323 5
        SUB     R13, R13, #(12*2)+6+1+1

        LDR	R14, =ZeroPage
        LDRB	R2, [R14, #RTCFitted]
        ORR     R14, R2, #1:SHL:29      ; retry
d1325 1
a1325 1
        ADD     R0, R14, #1
d1327 1
a1327 3
        TEQ	R2, #RTCAddressPHI
        MOVEQ   R0, #1			; PHI time starts at +1
        MOVNE   R0, #0			; DAL time starts at +0
d1329 1
a1329 2
        STR     R13, [R13, #12]         ; transfer 1 dataptr
        MOV     R0, #1
d1332 1
a1332 1
        STR     R0, [R13, #24]          ; transfer 2 dataptr
a1339 4
	TEQ     R2, #RTCAddressPHI
	BNE	%FT50

	; Philips specific read
d1360 1
a1360 20
	B	ReadTimeYear

50
	; Dallas specific read
        MOV     R8, #0                  ; centiseconds
        LDRB    R0, [R13, #1]
        BL      BCDToHex
        MOV     R7, R0                  ; seconds
        LDRB    R0, [R13, #2]
        BL      BCDToHex
        MOV     R1, R0                  ; minutes
        LDRB    R0, [R13, #3]
        BL      BCDToHex
        MOV     R4, R0                  ; hours
        LDRB    R0, [R13, #5]
        BL      BCDToHex
        MOV     R2, R0                  ; day of month
        LDRB    R0, [R13, #6]
        BL      BCDToHex
        MOV     R3, R0                  ; month
a1361 2
ReadTimeYear
	ADD     R13, R13, #(12*2)+6+1+1
d1365 1
d1372 3
a1374 1
	TEQ	R2, #0			; Ensure day/month are non-zero (LRust, fix RP-0370)
d1378 1
a1378 1

a1382 33
;       InitRTC - Force the clock into a known state (incase of new battery)
;
;  in:  R0 = RTC IIC address

InitRTC
	Push    "R0-R2, R14"
	SUB	R13, R13, #4
	MOV	R1, R13
	ORR     R0, R0, #1:SHL:29
	TEQ	R0, #RTCAddressPHI
	BEQ	%FT60
	MOV	R2, #0			; to write 0 to address ptr
	STRB	R2, [R1]
	MOV	R2, #1
	BL	IIC_Op
	ORR	R0, R0, #1
	BL	IIC_Op
	LDRB	R2, [R1]
	ANDS	R2, R2, #&80		; test clock disabled bit
	BEQ	%FT65
	EOR	R0, R0, #1
	DebugTX "Forced RTC on"
60
	MOV     R2, #0
	STR	R2, [R1]
	MOV	R2, #2			; to write 0 to control reg 0
	BL      IIC_Op
65
	ADD	R13, R13, #4
	Pull    "R0-R2, PC"

; *****************************************************************************
;
d1391 5
a1395 4
	; Need to set the slowest speed so we can probe
	LDR     R4, =ZeroPage
	MOV     R3, #10         ; Default speed setting (5s delays)
	STRB    R3, [R4, #NVRamSpeed]
d1397 2
a1398 12
	; Have we got an RTC ?
	LDR 	R2, =ZeroPage
	MOV	R4, #0
	MOV	R0, #RTCAddressPHI
	BL	DummyAccess
	BVC	%FT13
	MOV	R0, #RTCAddressDAL
	BL	DummyAccess
	STRVSB  R4, [R2, #RTCFitted]
13
	STRVCB  R0, [R2, #RTCFitted]
	BLVC    InitRTC
a1425 9
        CallHAL HAL_NVMemoryPageSize    ; returns size in bytes but..
        TEQ     R0, #0                  ; .. expecting power of 2
        MVNEQ   R0, #0
        MOV     R1, #0
22      MOVS    R0, R0, LSR #1
        ADDNE   R1, R1, #1
        BNE     %BT22
        STRB    R1, [R4, #NVRamPageSize]

a1438 1
        AND	R0, R5, #NVMemoryFlag_Provision
d1448 1
a1448 1
    	MOVNE	R0, #0			; Failure exit condition
d1452 7
a1458 3

;	No HAL,so determine what hardware we've got fitted by probing,
;	R4 holds the number of 256 byte blocks that we've found
d1464 1
a1464 1
; Have we got a 2K device ?
d1492 1
d1502 1
d1513 1
d1523 2
a1524 3
; Any storeage in the Philips RTC? (Dallas capacity is tiny,ignored)
        MOV     R1, #RTCAddressPHI
        MOV     R0, #RTCAddressPHI
d1537 2
a1538 1
    	MOV 	R0, #0		; Exit failure
d1567 4
a1570 5
    	; No E2ROM support,assume a Philips RTC
    	MOV	R1, #RTCAddressPHI
    	MOV	R2, #&10
    	MOV	R4, #&100		; stop at address &100
    	LDR	R3, =CMOSRAMCache
d1577 1
d1637 2
d1640 1
a1640 1
DummyAccess
a1641 9
 [ {TRUE}
        ; Blooming 80321 HW IIC can't do just START address STOP
	Entry   "R0-R2",4
        ORR     R0, R0, #1
        MOV     R1, R13
        MOV     R2, #1
        BL      IIC_Op
 |
	Entry   "R1,R2"
a1644 1
 ]
@


4.11.2.13
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d1413 1
a1415 1
	ORR     R0, R0, #1:SHL:29
a1427 1
	ORR     R0, R0, #1:SHL:29
d1454 1
a1454 1
	MOV	R0, #RTCAddressDAL
d1457 1
a1457 1
	MOV	R0, #RTCAddressPHI
@


4.11.2.14
log
@* Changed some STB switches to Embedded_UI
* Added use of CDVPoduleIRQs (from Hdr:Machine)
* Fixed checksum corruption in OS_NVMemory block writes ending just below
  the checksum byte.
* Fixed R4 corruption by OS_Byte 162 with certain HALs.

Version 5.35, 4.79.2.71. Tagged as 'Kernel-5_35-4_79_2_71'
@
text
@d293 1
a293 1
        BHI     %FT05
d568 1
a568 1
    	Push	"R3,R4,sb,R12"
d576 1
a576 1
    	Pull 	"R3,R4,sb,R12", EQ
d590 1
a590 1
    	Pull	"R3,R4,sb,R12"
d594 1
a594 1
        Pull    "R3,R4, sb,R12"
@


4.11.2.15
log
@   fix for invalid cmos checksum computation on iyonix
   new version date for 5.07
Detail:
   CheckSumBlock called IIC_OpV to checksum byte 0 of CMOS, but read back the
   resultant checksum from the wrong offset (#20.. new R1 value)..  now
   corrected to #24 as the correct offset (approx line 997).

Admin:
   tested at castle in iyonix
   castle added IP


Version 5.35, 4.79.2.74. Tagged as 'Kernel-5_35-4_79_2_74'
@
text
@d1011 1
a1011 1
        LDR     R1, [R13, #24]          ; read back checksum
@


4.11.2.16
log
@   reverse previous change to s.i2cutils .. the issue now tracked to
   Tungsten HAL IIC_Transfer not initialising the checksum
Detail:

Admin:
   tested at castle.. again!
   castle added IP


Version 5.35, 4.79.2.75. Tagged as 'Kernel-5_35-4_79_2_75'
@
text
@d1011 1
a1011 1
        LDR     R1, [R13, #20]          ; read back checksum
@


4.11.2.17
log
@Added option to disable RTC support (via Hdr:Machine).

Version 5.35, 4.79.2.84. Tagged as 'Kernel-5_35-4_79_2_84'
@
text
@a1454 1
     [  RTCSupport
a1463 3
     |
        STRB    R4, [R2, #RTCFitted]
     ]
@


4.11.2.18
log
@  Minor kernel updates
Detail:
  * Added some documentation on previously undocumented HAL calls
  * Corrected NVMemoryFlag_Provision bitmask to match documentation
  * Bugfix: NVMemoryFlag_ProtectAtEnd flag was being ignored
Admin:
  Not tested

Version 5.35, 4.79.2.98. Tagged as 'Kernel-5_35-4_79_2_98'
@
text
@a1471 1
    	MOV 	R5, R0
d1474 1
@


4.11.2.19
log
@Fix bug in InitCMOSCache that could cause CMOS to be errouneously reset if NVRAM is of type 'MaybeIIC'
Detail:
  s/PMF/i2cutils - Kernel was checking if the full IIC flags word was equal to MaybeIIC instead of just checking if the Provision bits equalled MaybeIIC. Thus if any of the additional flags were set along with MaybeIIC the kernel would have skipped the probing code, skipped the IIC code, and fallen through to using the (likely unimplemented) HAL interface for initialising the NVRAM cache.
Admin:
  Tested in IOMD build under RPCemu; kernel now takes the correct path for MaybeIIC + ProtectAtEnd.


Version 5.35, 4.79.2.109. Tagged as 'Kernel-5_35-4_79_2_109'
@
text
@d1477 1
a1477 1
    	TEQ 	R0, #NVMemoryFlag_MaybeIIC
@


4.11.2.20
log
@Fix detection of Philips RTC/NVRAM when MaybeIIC is in use
Detail:
  s/PMF/i2cutils - Although the code will detect the Philips RTC correctly, it was failing to set the device size in R4, causing CMOS RAM to be misread. This change fixes that.
Admin:
  Tested in IOMD HAL build on development version of RPCEmu.


Version 5.35, 4.79.2.110. Tagged as 'Kernel-5_35-4_79_2_110'
@
text
@a1599 1
        MOVVC   R4, #1     
@


4.11.2.21
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d147 1
a147 1
        LDR     R14, =ZeroPage          ; don't write to protected section
d174 1
a174 1
	LDR	R1, =ZeroPage+CMOSRAMCache	; update cache, but always write to
d200 1
a200 1
        LDR     R1, =ZeroPage+CMOSRAMCache
d263 1
a263 1
        LDR	R14, =ZeroPage
d387 1
a387 1
        LDR	R14, =ZeroPage
d405 1
a405 1
        LDR     R14, =ZeroPage+CMOSRAMCache
d451 1
a451 1
        LDRCSB  R14, [R1], #1
d552 1
a552 2
        ; If there's no RTC, read dummy values from the cache
        LDR     R14, =ZeroPage
d555 1
a555 1
        BNE     %FT15 
d560 1
a560 1
	LDRCC	R2, =ZeroPage+CMOSRAMCache ; if in range
d645 1
a645 1
        LDR	R14, =ZeroPage
d724 1
a724 1
        LDR     R14, =ZeroPage+CMOSRAMCache
d906 1
a906 1
        LDR     R14, =ZeroPage+CMOSRAMCache
d1038 1
a1038 1
	LDR	R14, =ZeroPage		; get no 256 byte blocks and calculate end address
d1045 2
a1046 2
	LDR	R1, =ZeroPage
	;LDR	R1, [R1, #RTCFitted]    ; This causes a headache if both an RTC and NVRAM are fitted
a1047 1
	;LDREQ	R1, =ZeroPage
d1083 1
a1083 1
	LDR	R14, =ZeroPage		; read no 256 byte blocks and calculate end address
d1136 1
a1136 1
	LDR	R2, =ZeroPage		; read number of 256 byte blocks and calculate end address
d1174 1
a1174 1
	LDR	R2, =ZeroPage
d1195 2
a1196 2
;	R2 = day of month (1-based)
;	R3 = month (1-based)
d1202 1
a1202 1
;	If R0,R2,R5 or R6 is -1 then the time,date,year,century (respectively) will not be written. However if R2=-1, R5 & R6 will also be -1, so only R0 (for time) and R2 (for D/M/Y) need checking.
d1209 1
a1209 67
	LDR	R10, [R10, #RTCFitted]
 [ HAL
        CMP	R10, #2048 ; Is it an I2C address or HALDevice_RTC ptr?
        BLO	%FT15
	Push	"R0-R3,R12"
	MOV	R4, R0			; copy hours in R4
        ; Prepare BCD data on stack
        ASSERT (RTCTimeStruct_BCD_Size :AND: 3)=0
        SUB	R13, R13, #RTCTimeStruct_BCD_Size
        MOV	R9, R13
        ; Ensure struct matches our setting order
        ASSERT RTCTimeStruct_BCD_Centiseconds = 0
        ASSERT RTCTimeStruct_BCD_Seconds = 1
        ASSERT RTCTimeStruct_BCD_Minutes = 2
        ASSERT RTCTimeStruct_BCD_Hours = 3
        ASSERT RTCTimeStruct_BCD_DayOfMonth = 4
        ASSERT RTCTimeStruct_BCD_Month = 5
        ASSERT RTCTimeStruct_BCD_YearLO = 6
        ASSERT RTCTimeStruct_BCD_YearHI = 7
        ; Are we setting the time?
        CMP	R4, #-1
        STREQ	R4, [R9], #4 ; Conveniently, 4 bytes of time info
        BEQ	%FT11
        MOV	R0, R8
        BL	HTBS9
        MOV	R0, R7
        BL	HTBS9
        MOV	R0, R1
        BL	HTBS9
        MOV	R0, R4
        BL	HTBS9
11
	; Are we setting the date?
	CMP	R2, #-1
	STREQ	R2, [R9], #4 ; Conveniently, 4 bytes of date info
	BEQ	%FT12
        LDRB	R1, [R10, #HALDevice_RTCFormatFlags]
        MOV	R0, R2
        TST	R1, #RTCFormatFlags_BCD_1BasedDay
        SUBEQ	R0, R0, #1
        BL	HTBS9
        TST	R1, #RTCFormatFlags_BCD_1BasedMonth
        MOV	R0, R3
        SUBEQ	R0, R0, #1
        BL	HTBS9
        TST	R1, #RTCFormatFlags_BCD_YearLOIsGood
        ANDEQ	R0, R5, #3 ; 2 bit YearLO
        STREQB	R0, [R9], #1
        MOVNE	R0, R5 ; BCD YearLO
        BLNE	HTBS9
        MOV	R0, R6
        BL	HTBS9
12
        SUB	R1, R9, #8
        MOV	R0, R10
        ADRL	R2, HALRTC_IICOp
        MOV	LR, PC
        LDR	PC, [R10, #HALDevice_RTCWriteTime]
	; Unfortunately, we don't do anything with the return code at the moment.
13
	ADD	R13, R13, #RTCTimeStruct_BCD_Size ; RTCTimeStruct
	Pull	"R0-R3,R12"
	BL	RTCToRealTime
	Pull	"R4, R9-R10, PC"
15
 ] ; HAL
 [ RTCSupport :LOR: :LNOT: HAL
d1212 1
a1212 1
 ]
d1215 1
a1215 1
 [ RTCSupport  :LOR: :LNOT: HAL
a1296 1
 ] ; RTCSupport :LOR: :LNOT: HAL
d1306 2
a1307 2
;	R2 = days (1-based)
;	R3 = months (1-based)
d1312 1
a1312 1
;	Note: For HAL RTCs, R0 will be negative on error. Other RTCs do not report errors and may just return garbage.
d1316 1
d1319 1
a1319 58
        LDR	R2, [R14, #RTCFitted]
 [ HAL
	CMP	R2, #2048 ; IIC address or RTCDevice ptr?
	BLO	%FT49
	Push	"R12"
	MOV	R6, R2
	MOV	R0, R2
	SUB	R13, R13, #RTCTimeStruct_BCD_Size
	MOV	R1, R13
	ADRL	R2, HALRTC_IICOp
	MOV	LR, PC
	LDR	PC, [R0, #HALDevice_RTCReadTime]
	; If there was an error, exit with a negative value in R0
	CMP	R0, #RTCRetCode_OK
	MVNNE	R0, #0
	ADDNE	R13, R13, #RTCTimeStruct_BCD_Size
	Pull	"R12",NE
	Pull	"R4,PC",NE
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Centiseconds]
	BL	BCDToHex
	MOV	R8, R0			; centiseconds
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Seconds]
	BL	BCDToHex
	MOV	R7, R0			; seconds
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Minutes]
	BL	BCDToHex
	MOV	R1, R0			; minutes
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Hours]
	BL	BCDToHex
	MOV	R4, R0			; hours
	LDRB	R0, [R13, #RTCTimeStruct_BCD_DayOfMonth]
	BL	BCDToHex
	LDRB	R12, [R6, #HALDevice_RTCFormatFlags]
	MOV	R2, R0
	TST	R12, #RTCFormatFlags_BCD_1BasedDay
	ADDEQ	R2, R2, #1		; days
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Month]
	BL	BCDToHex
	MOV	R3, R0
	TST	R12, #RTCFormatFlags_BCD_1BasedMonth
	ADDEQ	R3, R3, #1		; months
	LDRB	R0, [R13, #RTCTimeStruct_BCD_YearLO]
	BL	BCDToHex
	MOV	R5, R0			; year lo
	LDRB	R0, [R13, #RTCTimeStruct_BCD_YearHI]
	BL	BCDToHex
	; We're done with our stack data, remove it
	ADD	R13, R13, #RTCTimeStruct_BCD_Size
	MOV	R6, R0			; year hi
	; If the RTC can reliably store the year, we don't need to use the CMOS copy
	TST	R12, #RTCFormatFlags_BCD_NeedsYearHelp
	Pull	"R12"
	BEQ	DontReadTimeYear
	B	ReadTimeYear
49
 ] ; HAL
 [ RTCSupport :LOR: :LNOT: HAL
        SUB     R13, R13, #(12*2)+6+1+1
a1363 1
	ADD     R13, R13, #(12*2)+6+1+1
a1383 2
	ADD     R13, R13, #(12*2)+6+1+1
 ] ; RTCSupport :LOR: :LNOT: HAL
d1386 1
d1393 1
a1393 1
DontReadTimeYear
d1400 1
a1402 1
 [ RTCSupport :LOR: :LNOT: HAL
a1435 29
 ] ; RTCSupport :LOR: :LNOT: HAL


 [ HAL
; *****************************************************************************
;
;       HALRTC_IICOp - Wrapper for IIC_OpV to allow it to be called from HALDevice RTC drivers
;
;  in:  R0 = iic_transfer *
;	R1 = number of transfers
;	R2 = 'kernel workspace ptr' - currently unused
; out:  R0 = HAL_IICOp error code

HALRTC_IICOp
	Push	"R14"
	BL	IIC_OpV
	; Translate the RISC OS error code back into an IIC one we can pass to the driver
	LDRVS	R2, [R0]
	LDRVS	R1, =ErrorNumber_IIC_Busy
	MOV	R0, #5 ; EERROR
	TEQ	R2, R1 ; Won't modify V
	MOVEQ	R0, #3 ; EBUSY
	LDRVS	R1, =ErrorNumber_IIC_NoAcknowledge
	TEQ	R2, R1
	MOVEQ	R0, #2 ; ENOACK
	MOVVC	R0, #0 ; ECOMPLETED
	Pull	"PC"
 ]

d1453 2
a1454 1
	MOV	R2, #0
d1461 1
a1461 1
	STRVS   R2, [R4, #RTCFitted]
d1463 1
a1463 1
	STRVC   R0, [R4, #RTCFitted]
d1466 1
a1466 1
        STR     R2, [R4, #RTCFitted]
d1523 1
a1523 1
    	LDR 	R1, =ZeroPage+CMOSRAMCache
d1600 1
a1600 1
        MOVVC   R4, #1
d1628 1
a1628 1
	LDR	R3, =ZeroPage+CMOSRAMCache
d1644 1
a1644 1
    	LDR	R3, =ZeroPage+CMOSRAMCache
a1770 1
      [ ZeroPage = 0
a1771 4
      |
        LDR     R1, =ZeroPage
        LDRB    R1, [R1, #NVRamSize]
      ]
@


4.11.2.22
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d40 1
a40 1
PhysChecksum            *       (((CheckSumCMOS + &30) :MOD: &F0) + &10)
d43 9
a51 9
RTCAddressPHI           *       &a0     ; Philips RTC + 240 byte CMOS
RTCAddressDAL           *       &d0     ; Dallas RTC + 56 byte CMOS
E2ROMAddress2K          *       &e0     ; 24C174 device - 2K
E2ROMAddress2K_OTP      *       &60     ; 24C174 device - OTP section
E2ROMAddress4K          *       &a4     ; 24C32 device - 4K (top 1K protectable)
E2ROMAddress8K_prot     *       &a2     ; 24C64 device - 8K (top 2K protectable)
E2ROMAddress8K          *       &ae     ; 24C64 device - 8K
E2ROMAddress16K         *       &a8     ; 24C128 device - 16K
E2ROMAddress32K         *       &a6     ; 24CS256 device - 32K (top 2K possibly OTP)
d56 1
a56 1
;       HexToBCD - Convert byte in hex to BCD
d58 1
a58 1
; in:   R0 = byte in hex
d60 2
a61 2
; out:  R0 = byte in BCD (ie R0 := (R0 DIV 10)*16 + R0 MOD 10)
;       All other registers preserved
d65 5
a69 5
        Push    "R1,R2, R14"
        MOV     R1, #10
        DivRem  R2, R0, R1, R14                 ; R2=R0 DIV 10; R0=R0 MOD 10
        ADD     R0, R0, R2, LSL #4
        Pull    "R1,R2, PC"
d73 1
a73 1
;       BCDToHex - Convert byte in BCD to hex
d75 1
a75 1
; in:   R0 = byte in BCD (ie x*16 + y)
d77 2
a78 2
; out:  R0 = byte in hex (ie x*10 + y)
;       All other registers preserved
d82 5
a86 5
        Push    "R14"
        MOV     R14, R0, LSR #4                 ; R14 := x
        ADD     R14, R14, R14, LSL #1           ; R14 := x*3
        SUB     R0, R0, R14, LSL #1             ; R0 := R0 - x*6 = x*10
        Pull    "PC"
d101 1
a101 1
;       Write - Write a byte of CMOS RAM specified by logical address
d103 2
a104 2
; in:   R0 = address in CMOS RAM
;       R1 = data
d106 1
a106 1
; out:  All registers preserved
d137 3
a139 3
        Push    "R0-R4, R14"
        BL      MangleCMOSAddress
        Pull    "R0-R4, PC", CS         ; if invalid, then exit
d153 2
a154 2
        MOV     R2, R0
        MOV     R3, R1
d157 2
a158 2
        BL      ReadStraight            ; calculate new checksum :
        MOV     R4, R0
d162 8
a169 8
        MOV     R0, #PhysChecksum
        BL      ReadStraight
        SUB     R0, R0, R4              ; = oldsum - oldcontents
        ADD     R4, R0, R3              ;          + newcontents

        AND     R4, R4, #&FF
        CMPS    R2, #PhysChecksum       ; don't write new checksum ...
        ORREQ   R4, R4, #&1000000       ; if checksum is being written
d172 4
a175 4
        CMP     r2, #&100               ; check small cache limit
        BCS     %FT15
        LDR     R1, =ZeroPage+CMOSRAMCache      ; update cache, but always write to
        STRB    R3, [R1, R2]            ; real hardware as well
d179 9
a187 9
        Push    "R2,R3,sb,R12"
        AddressHAL
        CallHAL HAL_NVMemoryType
        AND     R0, R0, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_None

        ; If there's no NVmemory, all we have is the internal cache.
        Pull    "R2,R3,sb,R12", EQ
        Pull    "R0-R4,PC", EQ
d189 2
a190 2
        TEQ     R0, #NVMemoryFlag_HAL
        BNE     %FT20                   ; Go and do IIC stuff.
d192 1
a192 1
        ; Make the HAL call - we have to write the data into a buffer.
d195 3
a197 3
        MOV     R1, sp
        MOV     R2, #1
        CallHAL HAL_NVMemoryWrite
d204 3
a206 3
        MOV     R1, sp
        MOV     R2, #1
        CallHAL HAL_NVMemoryWrite
d208 3
a210 3
        ADD     sp, sp, #4
        Pull    "R3,sb,R12"
        Pull    "R0-R4,PC"
d217 3
a219 3
        MOV     R0, R2
        BL      GetI2CAddress           ; convert to device address + offset
        MOV     R2, R0                  ; save the offset
d221 1
a221 1
        MOV     R1, #RTCAddressPHI
d239 8
a246 8
        [ ChecksumCMOS
        TST     R4, #&1000000           ; loop again to write new checksum
        MOV     R3, R4
        MOV     R2, #PhysChecksum
        ORR     R4, R4, #&1000000       ; but ensure it only happens once
        BEQ     %BT10
        ]
        Pull    "R0-R4, PC"
d263 1
a263 1
        LDR     R14, =ZeroPage
d265 1
a265 1
        LDRB    R14, [R14, #NVRamSize]
d387 2
a388 2
        LDR     R14, =ZeroPage
        LDRB    R14, [R14, #NVRamPageSize]
d423 16
a438 12
        Push    "sb, R12"
        MOV     R5, R0                  ; save address
        AddressHAL
        CallHAL HAL_NVMemoryType
        AND     R0, R0, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_None

        ; If there's no NVmemory, tough - we just return.
        Pull    "sb,R12", EQ
        Pull    "R0-R2", EQ
        MOVEQ   R2, #0                  ; nothing written
        Pull    "R3,R5-R6,PC", EQ
d440 2
a441 6
        TEQ     R0, #NVMemoryFlag_HAL
        MOV     R0, R5                  ; restore address
        BNE     %FT17                   ; do IIC things.

        ; Make the HAL call
        CallHAL HAL_NVMemoryWrite       ; returns bytes wrtten in R0
d443 1
a443 1
        Pull    "sb,R12"
d445 1
a445 1
        Pull    "R0-R2"
d456 1
a456 1
        Pull    "R3,R5-R6,PC"
d459 1
a459 1
        Pull    "sb,R12"
d462 2
a463 2
  [     E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
d465 1
a465 1
        MOV     R1, #RTCAddressPHI
d509 1
a509 1
        Pull    "R0,R2,R3,R5,R6,PC"
d513 2
a514 2
;       Read - Read a byte of CMOS RAM specified by logical address
;       ReadStraight - Read a byte of CMOS RAM specified by physical address
d517 1
a517 1
; in:   R0 = address in CMOS RAM
d519 2
a520 2
; out:  R0 = data (illegal address return 0, or error for ReadWithError)
;       All other registers preserved
d524 2
a525 2
        Push    "R1,R2,R14"
        B       %FT10
d542 4
a545 4
        Push    "R1,R2,R14"
        BL      MangleCMOSAddress
        MOVCS   R0, #0                  ; pretend illegal addresses contain 0
        Pull    "R1,R2,PC", CS
d547 2
a548 2
        TEQ     R0, #&40                ; is it Econet station number
        BEQ     %FT15                   ; if so then don't use cache
d560 4
a563 4
13      CMP     R0, #&100               ; check small cache limit
        LDRCC   R2, =ZeroPage+CMOSRAMCache ; if in range
        LDRCCB  R0, [R2, R0]            ; read from cache
        Pull    "R1,R2,PC", CC          ; and exit
d569 24
a592 24
        Push    "R3,R4,sb,R12"
        MOV     R4, R0                  ; save address
        AddressHAL
        CallHAL HAL_NVMemoryType
        AND     R0, R0, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_None

        ; If there's no NVmemory, pretend addresses contain 0
        Pull    "R3,R4,sb,R12", EQ
        MOVEQ   R0, #0
        Pull    "R1,R2,PC", EQ

        TEQ     R0, #NVMemoryFlag_HAL
        MOV     R0, R4                  ; restore address
        BNE     %FT20

        ; Make the HAL call - we have to provide a buffer.
        SUB     sp, sp, #4              ; make some space on the stack
        MOV     R1, sp
        MOV     R2, #1
        CallHAL HAL_NVMemoryRead
        LDRB    R0, [sp], #4            ; read back from stack and restore
        Pull    "R3,R4,sb,R12"
        Pull    "R1,R2,PC"
d598 2
a599 2
  [     E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
d601 1
a601 1
        MOV     R1, #RTCAddressPHI
d628 1
a628 1
        Pull    "R1,R2,PC"
d646 2
a647 2
        LDR     R14, =ZeroPage
        LDRB    R14, [R14, #NVRamSize]
d744 1
a744 1
        Push    "sb"
d746 21
a766 21
        MOV     R5, R0                  ; save address
        AddressHAL
        Push    "R1-R3,R12"
        CallHAL HAL_NVMemoryType
        Pull    "R1-R3,R12"
        AND     R0, R0, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_None

        ; If there's no NVmemory, tough - we just return.
        MOVEQ   R2, #0                  ; nothing read
        Pull    "sb", EQ
        Pull    "R3-R5,PC", EQ

        TEQ     R0, #NVMemoryFlag_HAL
        MOV     R0, R5                  ; restore address
        BNE     %FT17                   ; do IIC things.

        ; Make the HAL call
        Push    "R12"
        CallHAL HAL_NVMemoryRead        ; returns bytes read in R0
        Pull    "R12"
d768 1
a768 1
        Pull    "sb"
d773 1
a773 1
        Pull    "R3-R5,PC"
d776 1
a776 1
        Pull    "sb"
d781 2
a782 2
  [     E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
d784 1
a784 1
        MOV     R1, #RTCAddressPHI
d824 1
a824 1
        Pull    "R0,R2,R3-R5,PC"
d926 9
a934 9
        Push    "sb,R12"
        MOV     R5, R0                  ; save address
        AddressHAL
        Push    "R1-R3"
        CallHAL HAL_NVMemoryType
        Pull    "R1-R3"
        AND     R4, R0, #NVMemoryFlag_Provision
        MOV     R0, R5                  ; restore address
        TEQ     R4, #NVMemoryFlag_None
d946 4
a949 4
        TEQ     R4, #NVMemoryFlag_None
        ; If there's no NVmemory, tough - we just return.
        Pull    "sb,R12", EQ
        Pull    "R0-R5,PC", EQ
d975 2
a976 2
  [     E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
d978 1
a978 1
        MOV     R1, #RTCAddressPHI
d1016 1
a1016 1
        Pull    "R0,R2,R3-R5,PC"
d1020 2
a1021 2
;       GetI2CAddress - Convert NVRam physical address to i2c device address
;                       and offset
d1023 1
a1023 1
; in:   R0 = NVRam physical address (&00..size of NVRam)
d1025 1
a1025 1
; out:  R0 preserved
d1027 4
a1030 4
;       C=0 => NVRam address is valid
;        R0 = physical address within i2c device
;        R1 = i2c device address for writing. Increment this device address
;             by 1 for reading. Bit 8 is set if device requires 2-byte physical address.
d1032 3
a1034 3
;       C=1 => NVRam address is out of range of CMOS or E2ROM chips
;        R0 preserved
;        R1 preserved
d1036 1
a1036 1
  [     E2ROMSupport
d1038 6
a1043 6
        Push    "R14"
        LDR     R14, =ZeroPage          ; get no 256 byte blocks and calculate end address
        LDRB    R14, [R14, #NVRamSize]
        MOV     R14, R14, LSL #8
        CMP     R0, R14
        Pull    "PC",CS                 ; indicate invalid
d1046 6
a1051 6
        LDR     R1, =ZeroPage
        ;LDR    R1, [R1, #RTCFitted]    ; This causes a headache if both an RTC and NVRAM are fitted
        ;TEQ    R1, #0
        ;LDREQ  R1, =ZeroPage
        ;LDREQB  R1, [R1, #NVRamBase]   ; RTC overlaps bottom of NVRAM
        LDRB    R1, [R1, #NVRamBase]    ; RTC overlaps bottom of NVRAM
d1057 3
a1059 3
        MOVS    R14, R0, LSR #8         ; put top bits of physical address into device address
        ORRNE   R1, R1, R14, LSL #1
        ANDNE   R0, R0, #&FF            ; and use address within 256 byte block
d1062 1
a1062 1
        Pull    "PC"                    ; indicate valid
d1069 1
a1069 1
;       MangleCMOSAddress - Convert from logical to physical address
d1071 1
a1071 1
;       Doesn't check if address is larger than the amount of NVRam installed
d1073 1
a1073 1
; in:   R0 = logical address (&00...)
d1075 2
a1076 2
; out:  C=0 => valid logical address
;        R0 = physical address (&40..&FF,&10..&3F,&00..0F,&100..)
d1078 2
a1079 2
;       C=1 => invalid logical address
;        R0 preserved
d1084 7
a1090 7
        Push    "R14"
        LDR     R14, =ZeroPage          ; read no 256 byte blocks and calculate end address
        LDRB    R14, [R14, #NVRamSize]
        MOV     R14, R14, LSL #8
        CMP     R0, R14                 ; if >= end address then
        Pull    "R14"
        MOVCS   PC, R14                 ;    invalid (exit C set)
d1092 1
a1092 1
        CMP     R0, #&100               ; if < end address && >= &100 then
d1098 1
a1098 1
        CMP     R0, #&F0                ; if < &100 && >= &f0 then
d1108 3
a1110 3
        ADD     R0, R0, #&40            ; now in range &40..&13F
        CMP     R0, #&100
        SUBCS   R0, R0, #(&100-&10)     ; now in range &40..&FF, &10..&3F
d1116 1
a1116 1
;       ValChecksum - test to see if the CMOS checksum is OK
d1124 1
a1124 1
; in:   none
d1126 3
a1128 3
; out:  R0 = calculated checksum
;       Z       set if checksum is valid
;       All other registers preserved
d1133 1
a1133 1
ValChecksum     Entry "R1-R2"
d1138 3
a1140 3
        LDR     R2, =ZeroPage           ; read number of 256 byte blocks and calculate end address
        LDRB    R2, [R2, #NVRamSize]
        MOV     R2, R2, LSL #8
d1142 1
a1142 1
        MOV     R2, #240
d1150 5
a1154 5
        MOV     R0, #CheckSumCMOS
        BL      Read
        AND     R2, R0, #&FF            ; value from checksum location
        AND     R0, R1, #&FF            ; calculated value into R0
        CMPS    R0, R2
d1156 1
a1156 1
        EXIT
d1161 1
a1161 1
;       MakeChecksum - calculate and write a correct checksum
d1163 1
a1163 1
; in:   none
d1165 2
a1166 2
; out:  R0 = calculated checksum
;       All other registers preserved
d1169 1
a1169 1
        [ ChecksumCMOS
d1171 2
a1172 2
MakeChecksum    ROUT
        Push    "R1-R2,R14"
d1176 3
a1178 3
        LDR     R2, =ZeroPage
        LDRB    R2, [R2, #NVRamSize]
        MOV     R2, R2, LSL #8
d1180 1
a1180 1
        MOV     R2, #240
d1183 4
a1186 4
        MOV     R0, #CheckSumCMOS
        BL      Write
        Pull    "R1-R2,PC"
        ]
d1192 1
a1192 1
;       SetTime - Write the CMOS clock time and update 5-byte RealTime
d1194 9
a1202 9
; in:   UTC time:
;       R0 = hours
;       R1 = minutes
;       R2 = day of month (1-based)
;       R3 = month (1-based)
;       R5 = year (lo)
;       R6 = year (hi)
;       R7 = seconds
;       R8 = centiseconds
d1204 1
a1204 1
;       If R0,R2,R5 or R6 is -1 then the time,date,year,century (respectively) will not be written. However if R2=-1, R5 & R6 will also be -1, so only R0 (for time) and R2 (for D/M/Y) need checking.
d1208 1
a1208 1
        Push    "R4, R9-R10, R14"       ; save registers
d1210 2
a1211 2
        LDR     R10, =ZeroPage
        LDR     R10, [R10, #RTCFitted]
d1213 4
a1216 4
        CMP     R10, #2048 ; Is it an I2C address or HALDevice_RTC ptr?
        BLO     %FT15
        Push    "R0-R3,R12"
        MOV     R4, R0                  ; copy hours in R4
d1219 2
a1220 2
        SUB     R13, R13, #RTCTimeStruct_BCD_Size
        MOV     R9, R13
d1231 11
a1241 11
        CMP     R4, #-1
        STREQ   R4, [R9], #4 ; Conveniently, 4 bytes of time info
        BEQ     %FT11
        MOV     R0, R8
        BL      HTBS9
        MOV     R0, R7
        BL      HTBS9
        MOV     R0, R1
        BL      HTBS9
        MOV     R0, R4
        BL      HTBS9
d1243 20
a1262 20
        ; Are we setting the date?
        CMP     R2, #-1
        STREQ   R2, [R9], #4 ; Conveniently, 4 bytes of date info
        BEQ     %FT12
        LDRB    R1, [R10, #HALDevice_RTCFormatFlags]
        MOV     R0, R2
        TST     R1, #RTCFormatFlags_BCD_1BasedDay
        SUBEQ   R0, R0, #1
        BL      HTBS9
        TST     R1, #RTCFormatFlags_BCD_1BasedMonth
        MOV     R0, R3
        SUBEQ   R0, R0, #1
        BL      HTBS9
        TST     R1, #RTCFormatFlags_BCD_YearLOIsGood
        ANDEQ   R0, R5, #3 ; 2 bit YearLO
        STREQB  R0, [R9], #1
        MOVNE   R0, R5 ; BCD YearLO
        BLNE    HTBS9
        MOV     R0, R6
        BL      HTBS9
d1264 6
a1269 6
        SUB     R1, R9, #8
        MOV     R0, R10
        ADRL    R2, HALRTC_IICOp
        MOV     LR, PC
        LDR     PC, [R10, #HALDevice_RTCWriteTime]
        ; Unfortunately, we don't do anything with the return code at the moment.
d1271 4
a1274 4
        ADD     R13, R13, #RTCTimeStruct_BCD_Size ; RTCTimeStruct
        Pull    "R0-R3,R12"
        BL      RTCToRealTime
        Pull    "R4, R9-R10, PC"
d1278 1
a1278 1
        TEQ     R10, #0                 ; no RTC - just set soft copy
d1285 2
a1286 2
        Push    "R0-R2"
        MOV     R4, R0                  ; copy hours in R4
d1288 8
a1295 8
        Push    "R1"
        MOVS    R1, R5                  ; year held seperately from the RTC
        MOVPL   R0, #YearCMOS
        BLPL    Write
        MOVS    R1, R6
        MOVPL   R0, #YearCMOS+1
        BLPL    Write
        Pull    "R1"
d1297 2
a1298 2
        CMP     R4, #-1                 ; are we writing time ?
        BEQ     %FT30
d1302 1
a1302 1
        TEQ     R10, #RTCAddressPHI
d1314 4
a1317 4
        MOV     R6, R2
        BL      %FT45
        MOV     R2, R6                  ; preserve D-O-M for later
        ADD     R13, R13, #8
d1320 2
a1321 2
        CMP     R2, #-1                 ; are we writing date ?
        BEQ     %FT40
d1325 2
a1326 2
        TEQ     R10, #RTCAddressPHI
        BNE     %FT35
d1328 1
a1328 1
        ; Philips specific handling
d1337 1
a1337 1
        B       %FT37
d1339 9
a1347 9
        ; Dallas specific handling
        MOV     R0, #4                  ; offset 4
        STRB    R0, [R9], #1
        MOV     R0, R2
        BL      HTBS9
        MOV     R0, R3
        BL      HTBS9
        MOV     R0, R5
        BL      HTBS9                   ; don't bother setting the D-O-W
d1349 2
a1350 2
        BL      %FT45
        ADD     R13, R13, #8
d1353 3
a1355 3
        Pull    "R0-R2"
        BL      RTCToRealTime           ; update RAM copy
        Pull    "R4, R9-R10, PC"
d1358 1
a1358 1
        MOV     R0, R10
d1364 1
a1364 1
        Pull    "PC"
d1369 1
a1369 1
;       ReadTime - Read the CMOS clock time
d1371 1
a1371 1
; in:   -
d1373 9
a1381 9
; out:  R0 = hours
;       R1 = minutes
;       R2 = days (1-based)
;       R3 = months (1-based)
;       R5 = year (lo)
;       R6 = year (hi)
;       R7 = seconds
;       R8 = centiseconds
;       Note: For HAL RTCs, R0 will be negative on error. Other RTCs do not report errors and may just return garbage.
d1384 1
a1384 1
        Push    "R4, R14"
d1386 2
a1387 2
        LDR     R14, =ZeroPage
        LDR     R2, [R14, #RTCFitted]
d1389 52
a1440 52
        CMP     R2, #2048 ; IIC address or RTCDevice ptr?
        BLO     %FT49
        Push    "R12"
        MOV     R6, R2
        MOV     R0, R2
        SUB     R13, R13, #RTCTimeStruct_BCD_Size
        MOV     R1, R13
        ADRL    R2, HALRTC_IICOp
        MOV     LR, PC
        LDR     PC, [R0, #HALDevice_RTCReadTime]
        ; If there was an error, exit with a negative value in R0
        CMP     R0, #RTCRetCode_OK
        MVNNE   R0, #0
        ADDNE   R13, R13, #RTCTimeStruct_BCD_Size
        Pull    "R12",NE
        Pull    "R4,PC",NE
        LDRB    R0, [R13, #RTCTimeStruct_BCD_Centiseconds]
        BL      BCDToHex
        MOV     R8, R0                  ; centiseconds
        LDRB    R0, [R13, #RTCTimeStruct_BCD_Seconds]
        BL      BCDToHex
        MOV     R7, R0                  ; seconds
        LDRB    R0, [R13, #RTCTimeStruct_BCD_Minutes]
        BL      BCDToHex
        MOV     R1, R0                  ; minutes
        LDRB    R0, [R13, #RTCTimeStruct_BCD_Hours]
        BL      BCDToHex
        MOV     R4, R0                  ; hours
        LDRB    R0, [R13, #RTCTimeStruct_BCD_DayOfMonth]
        BL      BCDToHex
        LDRB    R12, [R6, #HALDevice_RTCFormatFlags]
        MOV     R2, R0
        TST     R12, #RTCFormatFlags_BCD_1BasedDay
        ADDEQ   R2, R2, #1              ; days
        LDRB    R0, [R13, #RTCTimeStruct_BCD_Month]
        BL      BCDToHex
        MOV     R3, R0
        TST     R12, #RTCFormatFlags_BCD_1BasedMonth
        ADDEQ   R3, R3, #1              ; months
        LDRB    R0, [R13, #RTCTimeStruct_BCD_YearLO]
        BL      BCDToHex
        MOV     R5, R0                  ; year lo
        LDRB    R0, [R13, #RTCTimeStruct_BCD_YearHI]
        BL      BCDToHex
        ; We're done with our stack data, remove it
        ADD     R13, R13, #RTCTimeStruct_BCD_Size
        MOV     R6, R0                  ; year hi
        ; If the RTC can reliably store the year, we don't need to use the CMOS copy
        TST     R12, #RTCFormatFlags_BCD_NeedsYearHelp
        Pull    "R12"
        BEQ     DontReadTimeYear
        B       ReadTimeYear
d1449 3
a1451 3
        TEQ     R2, #RTCAddressPHI
        MOVEQ   R0, #1                  ; PHI time starts at +1
        MOVNE   R0, #0                  ; DAL time starts at +0
d1465 2
a1466 2
        TEQ     R2, #RTCAddressPHI
        BNE     %FT50
d1468 1
a1468 1
        ; Philips specific read
d1489 2
a1490 2
        ADD     R13, R13, #(12*2)+6+1+1
        B       ReadTimeYear
d1493 1
a1493 1
        ; Dallas specific read
d1510 1
a1510 1
        ADD     R13, R13, #(12*2)+6+1+1
d1514 6
a1519 6
        MOV     R0, #YearCMOS
        BL      Read
        MOV     R5, R0                  ; year (lo)
        MOV     R0, #YearCMOS+1
        BL      Read
        MOV     R6, R0                  ; year (hi)
d1521 1
a1521 1
        MOV     R0, R4                  ; put hours in R0
d1523 5
a1527 5
        TEQ     R2, #0                  ; Ensure day/month are non-zero (LRust, fix RP-0370)
        MOVEQ   R2, #1                  ; No then force 1st
        TEQ     R3, #0                  ; Invalid month?
        MOVEQ   R3, #1                  ; Yes then force Jan
        Pull    "R4, PC"
d1537 17
a1553 17
        Push    "R0-R2, R14"
        SUB     R13, R13, #4
        MOV     R1, R13
        TEQ     R0, #RTCAddressPHI
        BEQ     %FT60
        ORR     R0, R0, #1:SHL:29
        MOV     R2, #0                  ; to write 0 to address ptr
        STRB    R2, [R1]
        MOV     R2, #1
        BL      IIC_Op
        ORR     R0, R0, #1
        BL      IIC_Op
        LDRB    R2, [R1]
        ANDS    R2, R2, #&80            ; test clock disabled bit
        BEQ     %FT65
        EOR     R0, R0, #1
        DebugTX "Forced RTC on"
d1555 5
a1559 5
        ORR     R0, R0, #1:SHL:29
        MOV     R2, #0
        STR     R2, [R1]
        MOV     R2, #2                  ; to write 0 to control reg 0
        BL      IIC_Op
d1561 2
a1562 2
        ADD     R13, R13, #4
        Pull    "R0-R2, PC"
d1572 2
a1573 2
;       R1 = number of transfers
;       R2 = 'kernel workspace ptr' - currently unused
d1577 13
a1589 13
        Push    "R14"
        BL      IIC_OpV
        ; Translate the RISC OS error code back into an IIC one we can pass to the driver
        LDRVS   R2, [R0]
        LDRVS   R1, =ErrorNumber_IIC_Busy
        MOV     R0, #5 ; EERROR
        TEQ     R2, R1 ; Won't modify V
        MOVEQ   R0, #3 ; EBUSY
        LDRVS   R1, =ErrorNumber_IIC_NoAcknowledge
        TEQ     R2, R1
        MOVEQ   R0, #2 ; ENOACK
        MOVVC   R0, #0 ; ECOMPLETED
        Pull    "PC"
d1595 1
a1595 1
;       InitCMOSCache - Initialise cache of CMOS RAM
d1600 2
a1601 2
InitCMOSCache   Entry "r1-r6, sb,r12"
    [   E2ROMSupport
d1603 4
a1606 4
        ; Need to set the slowest speed so we can probe
        LDR     R4, =ZeroPage
        MOV     R3, #10         ; Default speed setting (5s delays)
        STRB    R3, [R4, #NVRamSpeed]
d1608 2
a1609 2
        ; Have we got an RTC ?
        MOV     R2, #0
d1611 6
a1616 6
        MOV     R0, #RTCAddressDAL
        BL      DummyAccess
        BVC     %FT13
        MOV     R0, #RTCAddressPHI
        BL      DummyAccess
        STRVS   R2, [R4, #RTCFitted]
d1618 2
a1619 2
        STRVC   R0, [R4, #RTCFitted]
        BLVC    InitRTC
d1626 3
a1628 3
        CallHAL HAL_NVMemoryType
        MOV     R5, R0
        ANDS    R0, R0, #NVMemoryFlag_Provision
d1631 9
a1639 9
        ; If it's only a maybe, then we probe
        TEQ     R0, #NVMemoryFlag_MaybeIIC
        BEQ     %FT03

        ; Else we read the size

        CallHAL HAL_NVMemorySize        ; returns number of bytes but..
        MOV     R0, R0, LSR#8           ; .. expecting no. of 256 blocks
        STRB    R0, [R4, #NVRamSize]
d1659 2
a1660 16
        CallHAL HAL_NVMemoryIICAddress
        STRB    R0, [R4, #NVRamBase]

        MOV     R0, #0
        CallHAL HAL_IICType
        MOV     R3, #10
        TST     R0, #IICFlag_Fast
        MOVNE   R3, #3
        TST     R0, #IICFlag_HighSpeed
        MOVNE   R3, #1
        STRB    R3, [R4, #NVRamSpeed]

        ; If we're using IIC then read in the cache manually
        AND     R0, R5, #NVMemoryFlag_Provision
        TEQ     R0, #NVMemoryFlag_IIC
        BEQ     %FT06
d1662 22
a1683 8
        ; Else use HAL routine.
        MOV     R0, #0
        LDR     R1, =ZeroPage+CMOSRAMCache
        MOV     R2, #&100
        CallHAL HAL_NVMemoryRead
        TEQ     R0, #&100
        MOVNE   R0, #0                  ; Failure exit condition
        EXIT
d1687 2
a1688 2
;       No HAL,so determine what hardware we've got fitted by probing,
;       R4 holds the number of 256 byte blocks that we've found
d1696 3
a1698 3
        MOV     r0, #(E2ROMAddress2K+14)
        BL      DummyAccess
        MOVVC   R4, #8
d1700 1
a1700 1
        BVC     %FT5
d1704 3
a1706 3
        MOV     r0, #E2ROMAddress16K
        BL      DummyAccess
        MOVVC   R4, #64
d1713 3
a1715 3
        MOV     r0, #E2ROMAddress4K
        BL      DummyAccess
        MOVVC   R4, #16
d1723 3
a1725 3
        MOV     r0, #E2ROMAddress8K
        BL      DummyAccess
        MOVVC   R4, #32
d1732 3
a1734 3
        MOV     r0, #E2ROMAddress8K_prot
        BL      DummyAccess
        MOVVC   R4, #32
d1748 1
a1748 1
        BVC     %FT5
d1753 1
a1753 1
        BL      DummyAccess
d1756 1
a1756 1
        BVC     %FT5
d1766 2
a1767 2
        MOV     R0, #0          ; Exit failure
        EXIT
d1770 3
a1772 3
        ; Set the NVRam count
        STRB    R1, [R2, #NVRamBase]
        STRB    R4, [R2, #NVRamSize]
d1782 2
a1783 2
        ; Initialise the cache
        LDR     R3, =ZeroPage+CMOSRAMCache
d1786 1
a1786 1
        MOVNE   r0, #&00                ; if not, then start at 0 anyway and read non-OTP data into location 0..15
d1788 2
a1789 2
        BL      ReadOTPArea
        MOV     r0, #&10                ; read rest of it from 16 onwards
d1795 5
a1799 5
        ; No E2ROM support,assume a Philips RTC
        MOV     R1, #RTCAddressPHI
        MOV     R2, #&10
        MOV     R4, #&100               ; stop at address &100
        LDR     R3, =ZeroPage+CMOSRAMCache
d1856 2
a1857 2
;       DummyAccess - do a dummy access of the specified device to find out
;                     if it is present
d1859 1
a1859 1
; in:   R0 = Write address of device
d1861 3
a1863 3
; out:  All registers preserved
;       V=0 => device is present
;       V=1 => device is not present
d1870 1
a1870 1
        Entry   "R0-R2",4
d1876 1
a1876 1
        Entry   "R1,R2"
d1882 1
a1882 1
        EXIT                            ; Exit with V set appropriately
d2036 1
a2036 1
        END
@


4.11.2.23
log
@Add OS_NVMemory 6
Permits applications to query what value would be used in the event of a CMOS reset for a given configure value. Notably, the configure plugins will use this in favour of 'ResetCMOS'.
hdr/Options: retire the 'Select16BitSound' switch, add comment for ChecksumCMOS switch
hdr/KernelWS: DuffEntry and Nowhere moved here
Kernel.s: Unused OSMD removed, retire single use of SPIRQ in favour of r13_irq
Middle.s: Retire SPIRQ
NewReset.s: Trim out 300+ lines of CMOS reset defaults, call OS_NVMemory 6 instead
PMF/i2cutils.s: CMOS reset default code and table moved here with refactoring
Note, the previous code preserved YearCMOS during the zeroing, only to unconditionally write it later - so have removed it from the zeroing step.
Note, the locations 80-111 are now considered as system CMOS in the allocations hence are now wiped too (previously they got skipped as user CMOS during R-power-on).

Tested on OMAP3 ROM with delete-power-on and R-power-on variants, and a simple BASIC program to read locations 0-255 via OS_NVMemory.

Version 5.35, 4.79.2.180. Tagged as 'Kernel-5_35-4_79_2_180'
@
text
@d1899 1
a1899 1
        CMP     R0, #6
a1906 2
        B       NVMemory_Unknown        ; Reserved for Kernel-5_41 divergence
        B       NVMemory_ResetValue
d1910 1
a1910 1
      [ International
d1914 1
a1914 1
      ]
d1925 1
a1925 1
    [ E2ROMSupport
d1933 1
a1933 1
    |
d1935 1
a1935 1
    ]
d1962 1
a1962 1
; in:   R0 = 2
d1967 2
a1968 2
      [ ProtectStationID
        TEQ     R1, #NetStnCMOS ; just ignore writes
d1970 1
a1970 1
      ]
d1993 1
d2009 1
a2009 1
; in:   R0 = 4
d2019 2
a2020 3
      [ ProtectStationID
        ASSERT  NetStnCMOS = 0
        TEQ     R1, #NetStnCMOS
d2026 1
a2026 1
      ]
a2035 273
; -----------------------------------------------------------------------------
; OS_NVMemory 6 - query CMOS value that would be used on a Delete-Power-On reset
;
; in:   R0 = 6
;       R1 = location
;
; out:  R2 = value, or -1 if the value is unknown/untouched
;
NVMemory_ResetValue ROUT
        Entry   "R3"
        MOV     R2, #-1         ; assume outside our remit
        TEQ     R1, #NetStnCMOS
        EXIT    EQ
        ASSERT  CheckSumCMOS = CMOSLimit - 1
        CMP     R1, #CheckSumCMOS
        EXIT    CS

        TEQ     R1, #MouseCMOS
        BEQ     %FT20           ; code driven

        TEQ     R1, #PrintSoundCMOS
        BEQ     %FT30           ; code driven

    [ STB :LAND: IOMD_C_PALNTSCType <> 0
        TEQ     R1, #TerritoryCMOS
        BEQ     %FT40           ; code driven
        TEQ     R1, #CountryCMOS
        BEQ     %FT41           ; code driven
        TEQ     R1, #TimeZoneCMOS
        BEQ     %FT42           ; code driven
      [ :DEF: ObsoleteNC1CMOS
        TEQ     R1, #MiscellaneousNCCMOS
        BEQ     %FT43           ; code driven
      ]
    ]
        ADR     R3, DefaultCMOSTable
10
        LDRB    R2, [R3], #2    ; table is of location/value pairs...
        TEQ     R2, #&FF        ; ...terminated by &FF
        MOVEQ   R2, #0          ; not in the table, so must be zero
        EXIT    EQ
        TEQ     R2, R1          ; location match?
        LDREQB  R2, [R3, #-1]
        EXIT    EQ
        B       %BT10
20
    [ HAL
      [ M_32 ; M_32 used for IOMD based machines, select quadrature or PS2 as appropriate
        Push    "R0-R1,R9,R12"
        AddressHAL
        MOV     R0, #0
        MOV     R1, #&400                    ; SSpace hopefully exists
        CallHAL HAL_ControllerAddress
        LDRB    R1, [R0, #IOMD_ID1]
        LDRB    R0, [R0, #IOMD_ID0]
        ORR     R0, R0, R1, LSL #8
        LDR     R1, =IOMD_Original
        TEQ     R0, R1
        MOVEQ   R2, #PointerDevice_QuadMouse ; Risc PC
        MOVNE   R2, #PointerDevice_PS2Mouse  ; A7000 et al
        Pull    "R0-R1,R9,R12"
      |
        ; Everyone else is on USB
        MOV     R2, #PointerDevice_USB
      ]
    |
        Push    "R0-R1"
        MOV     R3, #IOMD_Base
        LDRB    R1, [R3, #IOMD_ID1]
        LDRB    R0, [R3, #IOMD_ID0]
        ORR     R0, R0, R1, LSL #8
        LDR     R1, =IOMD_Original
        TEQ     R0, R1
        MOVEQ   R2, #PointerDevice_QuadMouse ; Risc PC
        MOVNE   R2, #PointerDevice_PS2Mouse  ; A7000 et al
        Pull    "R0-R1"
    ]
        EXIT
30
    [ HAL
        MOV     R2, #2_10100100
                     ; ^^^       interpolate at low rates, 16 bit DAC, fully programmable rates
                     ;    ^^^^^  tbs chars valid, escape with GSTrans
    |
        Push    "R0-R1"
        MOV     R3, #IOMD_Base
        LDRB    R1, [R3, #IOMD_ID1]
        LDRB    R0, [R3, #IOMD_ID0]
        ORR     R0, R0, R1, LSL #8
        LDR     R1, =IOMD_7500
        TEQ     R0, R1
        LDRNE   R1, =IOMD_7500FE
        TEQNE   R0, R1
      [ STB
        MOVEQ   R2, #2_00000100              ; Cheapskates
      |
        MOVEQ   R2, #2_10100100              ; A7000 et al always have 16 bit sound
      ]
        BEQ     %FT31
        ; on Issue A's the protection bit is only weakly pulled up,
        ; so force it high, then read it back
        LDR     R3, =IOMD_MonitorType
        LDR     R1, [R3]
        ORR     R1, R1, #IOMD_SoundsystemLinkBit
        STR     R1, [R3]
        LDR     R1, [R3]
        TST     R1, #IOMD_SoundsystemLinkBit
        MOVEQ   R2, #2_10100100              ; if zero, must be Rimmer, so assume 16bit sound hardware present
        MOVNE   R2, #2_00000100              ; 8 bit sound on the motherboard (can't detect plugin upgrades)
31
        Pull    "R0-R1"
    ]
        EXIT
    [ STB :LAND: IOMD_C_PALNTSCType <> 0
40
        MOV     R2, #0                       ; PAL = territory UK
        MOV     R3, #49                      ; NTSC = territory USA
        B       %FT44
41
        MOV     R2, #1                       ; PAL = country UK
        MOV     R3, #48                      ; NTSC = country USA
        B       %FT44
42
        MOV     R2, #0                       ; PAL = 0 from UTC (GMT)
        MOV     R3, #&E0                     ; NTSC = -8 hours from UTC (USA Pacific)
        B       %FT44
      [ :DEF: ObsoleteNC1CMOS
43
        MOV     R2, #0                       ; PAL = A4 paper size
        MOV     R3, #1                       ; NTSC = US letter paper size
      ]
44
        MOV     R14, #IOMD_Base
        LDRB    R14, [R14, #IOMD_CLINES]
        TST     R14, #IOMD_C_PALNTSCType
        MOVNE   R2, R3                       ; Select NTSC when line high
        EXIT
    ]

 [ ValidateCMOS :LAND: STB
DefaultCMOSTable
        ; Minimalist table
        DCB     KeyDelCMOS,         32
        DCB     KeyRepCMOS,         8
        DCB     MODETVCMOS,         &10                                     ; TV 0,1
        DCB     StartCMOS,          (1:SHL:7):OR:(2:SHL:3)                  ; NONUM, NOCAPS
        DCB     DBTBCMOS,           (1:SHL:4)                               ; Boot
        DCB     YearCMOS+0,         00
        DCB     YearCMOS+1,         20
      [ IOMD_C_MonitorType = 0 :LAND: IOMD_C_PALNTSCType = 0
        ; TV if we don't have a MonitorType auto-detect bit
        DCB     VduCMOS,            Sync_Separate :OR: MonitorType0
      |
        ; auto-detect if we have a MonitorType auto-detect bit
        DCB     VduCMOS,            Sync_Auto :OR: MonitorTypeAuto
      ]
        DCB     CountryCMOS,        1                                       ; UK
        DCB     MouseStepCMOS,      2
        DCB     SystemSpeedCMOS,    (1:SHL:2):OR:(1:SHL:4):OR:(0:SHL:5)
                                    ; Delete-etc reset
                                    ;              WimpMode auto
                                    ;                           Cache on
 |
DefaultCMOSTable
        ; Normal table
        DCB     KeyDelCMOS,         32
    [ M_CortexA8 :LOR: M_CortexA9
        DCB     FileLangCMOS,       fsnumber_SCSIFS ; SCSIFS for OMAP3, etc.
    |                               
      [ M_ARM11ZF                   
        DCB     FileLangCMOS,       fsnumber_SDFS   ; SDFS for Pi, etc.
      |                             
        DCB     FileLangCMOS,       fsnumber_adfs   ; ADFS
      ]
    ]
        DCB     FontCMOS,           64      ; KJB 13-Dec-02: Changed to 256K from 64K
        DCB     PigCMOS,            10
        DCB     KeyRepCMOS,         8
        DCB     RMASizeCMOS,        0
        DCB     SpriteSizeCMOS,     0
        DCB     SysHeapCMOS,        8
        DCB     MODETVCMOS,         &10     ; TV 0,1
        DCB     NetFSIDCMOS,        254
        DCB     NetPSIDCMOS,        235
        DCB     PSITCMOS,           (3:SHL:2) :OR: (1:SHL:5)
                                    ; Baud 3
                                    ;                Print 1

        DCB     DBTBCMOS,           (1:SHL:4) :OR: (4:SHL:5)
                                    ; Boot (changed from NoBoot 01-Sep-93)
                                    ;                Data 4

        DCB     StartCMOS,          (4:SHL:0) :OR: (2:SHL:3) :OR: (1:SHL:6) :OR: (0:SHL:7)
                                    ; ^              ^              ^              ^
                                    ; ADFS DR.4      NOCAPS         NODIR (moot)   NUM
      [ :LNOT: STB
        DCB     NewADFSCMOS+0,      &41     ; floppies=1, ST506=0, IDE=1 (changed 01-Sep-93)
      ]                             
        DCB     NewADFSCMOS+1,      4_3333  ; step 3 for each drive
        DCB     NewADFSCMOS+2,      1       ; ADFSBuffers 1
                                    
        DCB     SoundCMOS,          &F0     ; speaker on, volume 7, channel 1

        DCB     LanguageCMOS,       ConfiguredLang
        DCB     YearCMOS+0,         00
        DCB     YearCMOS+1,         20
        DCB     NetFilerCMOS,       (0:SHL:0) :OR: (1:SHL:1) :OR: (0:SHL:2)
                                    ; FS list order by name
                                    ;                Use $.Arthurlib
                                    ;                               Large icons

        DCB     DesktopCMOS,        2_01000000      ; verbose ON
        DCB     WimpFlagsCMOS,      2_01101111      ; instant effects, drags off screen
        DCB     ProtectionCMOS,     2_01110110      ; allow only peek and user RPC
        DCB     MouseStepCMOS,      2
        DCB     FileSwitchCMOS,     (1:SHL:0) :OR: (1:SHL:1) :OR: (0:SHL:2) :OR: (0:SHL:3) :OR: (0:SHL:6)
                                    ; Truncate names
                                    ;                Use DragASprite (changed 01-Sept-93)
                                    ;                               Interactive file copying
                                    ;                                              Wimp dither colours off
                                    ;                                                             Last shutdown ordinary

        DCB     DesktopFeaturesCMOS,(1:SHL:0) :OR: (8:SHL:1) :OR: (0:SHL:7)
                                    ; 3D look
                                    ;                Homerton.Medium
                                    ;                               Tiled window background

      [ STB
        DCB     SystemSpeedCMOS,    (1:SHL:0):OR:(0:SHL:1):OR:(1:SHL:2):OR:(0:SHL:3):OR:(1:SHL:4):OR:(0:SHL:5):OR:(1:SHL:6):OR:(0:SHL:7)
                                    ; AUN ROMBoot Enabled
                                    ;              AUN auto-station numbering off
                                    ;                           Delete-etc reset
                                    ;                                        Power saving off
                                    ;                                                     WimpMode auto
                                    ;                                                                  Cache on
                                    ;                                                                               Broadcast loader disabled
                                    ;                                                                                            Broadcast loader colours off
      |
        DCB     SystemSpeedCMOS,    (0:SHL:0):OR:(0:SHL:1):OR:(1:SHL:2):OR:(0:SHL:3):OR:(1:SHL:4):OR:(0:SHL:5):OR:(1:SHL:6):OR:(0:SHL:7)
                                    ; AUN BootNet Disabled
                                    ;              AUN auto-station numbering off
                                    ;                           Delete-etc reset
                                    ;                                        Power saving off
                                    ;                                                     WimpMode auto
                                    ;                                                                  Cache on
                                    ;                                                                               Broadcast loader disabled
                                    ;                                                                                            Broadcast loader colours off
      ]

      [ STB
        ;       FontMaxCMOS                     yes, omitting is deliberate!
        DCB     FontMax2CMOS,       &2C       ; 32 point
        DCB     FontMax3CMOS,       &38       ; 32 point
      |
        DCB     FontMaxCMOS,        64        ; 4096k
        DCB     FontMax2CMOS,       36:EOR:12 ; 36 point
        DCB     FontMax3CMOS,       36:EOR:24 ; 36 point
        DCB     FontMax4CMOS,       16        ; 16 point
      ]
        DCB     AlarmAndTimeCMOS,   2_00010000           ; !Alarm autosave on
        DCB     FSLockCMOS+5,       &EA                  ; Checksum for no password
        DCB     SparrowMarker,      FreewayNoAutoAddress ; Stop Freeway assigning addresses to interfaces
        DCB     NetworkFlags,       LanManFStransport    ; LMTransport is NetBIOS over IP
        DCB     WimpDragMoveLimitCMOS, (1:SHL:7)         ; WimpIconiseButton
      [ M_CortexA8 :LOR: M_CortexA9 :LOR: M_ARM11ZF
        DCB     CDROMFSCMOS,        &C0                  ; drives = 0, buffer size = 256K
      |
        DCB     CDROMFSCMOS,        &C1                  ; drives = 1, buffer size = 256K
      ]
 ]
        DCB     &FF
        ALIGN

@


4.11.2.24
log
@Adopt some switches from Hdr:Machine/Machine
SystemName, ROMSizeOffset, HAL32, HAL26 only used here, moved here.
Remove uses of "M_" booleans, apparently that's bad form.
Fix SWIDespatch_Size for the non thumb capable case (was ASSERTing).
Swapped UserMemStart for AppSpaceStart.
Removed last use of OldComboSupport (pre Medusa!).
Removed switch 'CDVPoduleIRQs', a correction to the machine definitions mean this can now simply be switched on NumberOfPodules (previously, IOMD couldn't chain podule interrupts).
Take out disabled sub interrupt support - it's in CVS if you want to try to get it working.
Moved ConfiguredLang to 11 for everyone, it only matters if !Boot fails, and no harm in making it common for 5.xx onwards.

Version 5.35, 4.79.2.183. Tagged as 'Kernel-5_35-4_79_2_183'
@
text
@d2061 1
a2061 1
    [ STB :LAND: :DEF: IOMD_C_PALNTSCType
d2085 1
a2085 1
      [ "$Machine"="IOMD" 
d2095 1
a2095 1
        TEQ     R0, R1                       ; Select quadrature or PS2 as appropriate
d2151 1
a2151 1
    [ STB :LAND: :DEF: IOMD_C_PALNTSCType
d2204 1
a2204 1
    [ "$Machine"="CortexA8" :LOR: "$Machine"="CortexA9"
d2207 1
a2207 1
      [ "$Machine"="ARM11ZF"
d2241 1
a2241 1
        DCB     LanguageCMOS,       11      ; typically module number of 'Desktop'
d2302 1
a2302 1
      [ "$Machine"="CortexA8" :LOR: "$Machine"="CortexA9" :LOR: "$Machine"="ARM11ZF"
@


4.11.2.25
log
@Migrate RTC driver out of the kernel
The kernel will use RTC_Read and RTC_Write to access the hardware clock, while maintaining the software clock as before.
Makefile: header export is now in the RTC module's sources
KernelWS: remove RTCFitted flag
NewReset: sync the time after the module init
i2cutils: deleted clock chip code
osinit: move OS_ResyncTime into PMF/realtime
realtime: mostly packages up ordinals and calls the respective SWI

Tested on IOMD softload.

Version 5.35, 4.79.2.202. Tagged as 'Kernel-5_35-4_79_2_202'
@
text
@d44 1
d88 1
d552 1
a552 1
        ; If our CMOS is actually inside an RTC, read direct (the cache is nonsense)
d554 3
a556 3
        LDRB    R14, [R14, #NVRamBase]
        TEQ     R14, #RTCAddressPHI
        BEQ     %FT15
d630 1
d849 1
d1047 5
a1051 1
        LDRB    R1, [R1, #NVRamBase]
d1066 1
d1192 403
d1608 16
d1750 1
a1750 1
; Any storage in the Philips RTC?
d1795 1
a1795 1
        ; No E2ROM support, assume just a Philips RTC
@


4.11.2.26
log
@Fix for spurious IIC access when probing
When HAL_NVMemoryType reports NVMemoryFlag_MaybeIIC the kernel tries to probe a number of common/known addresses on startup, however the result of the probe is stored around line 1346 without a value value for zero page in R2.
This is sufficiently early on that the default data abort handler (from when probing the ARM's abort model) is still in place so the stores are silently skipped.
Due to the RAM clear the NVRamBase (and size) are 0, which later on in ValChecksum result in a zero length IIC probe to address &01.
Now, R2 is initialised.

Version 5.35, 4.79.2.239. Tagged as 'Kernel-5_35-4_79_2_239'
@
text
@a1200 1
        ASSERT  NVMemoryFlag_None = 0
a1342 1
        LDR     R2, =ZeroPage
@


4.11.2.27
log
@Add a means to write NetStnCMOS in a HAL world
With ProtectStationID turned on there are no routes to writing the Econet station (or bottom octect of the IP address), a function previously fulfilled by the SetStation utility which pokes the hardware directly and doesn't fit into a HAL model.
Add a new subreason to OS_NVMemory to perform this role. This SWI appeared for RISC OS 5.00, and errors unsupported subreasons, so there's a means of run tim selecting its use by checking the platform class and trying the SWI. All RISC OS 5 based platforms can always be upgraded to this version, since they're all still being maintained.

hdr/Options: move the switch with the other options from osinit.s
i2cutils.c: new subreason

Ditch the 'ObsoleteNC1CMOS' switch, if it was obsolete for NC1, it's certainly obsolete now.
Ditch unmaintained messages files for Morris4/Omega/Ursula projects.
Tested on a Risc PC.

Version 5.35, 4.79.2.247. Tagged as 'Kernel-5_35-4_79_2_247'
@
text
@d1473 1
a1473 1
        CMP     R0, #7
a1482 1
        B       NVMemory_SetStation
d1567 1
a1567 1
NVMemory_ReadBlock 
d1642 4
d1738 5
a1750 37
; -----------------------------------------------------------------------------
; OS_NVMemory 7 - set station
;
; in:   R0 = 7
;       R1 = pointer to pass phrase
;       R2 = value
;
NVMemory_SetStation ROUT
        Entry   "R1-R4"
        MRS     R4, CPSR
        BIC     R0, R4, #I32_bit
        MSR     CPSR_c, R0      ; enable interrupts - this may take some time
      [ ProtectStationID
        MOV     R2, R1
10
        LDRB    R0, [R2], #1
        CMP     R0, #' '
        BCS     %BT10
        MOV     R3, #1
        SUB     R2, R2, #1
        MOV     R0, #0
        SWI     XOS_CRC
        EOR     R0, R0, #&009D
        EORS    R0, R0, #&2300
        MOVNE   R0, #-1         ; duff address to cause 'not writable' error
        ASSERT  NetStnCMOS = 0
        LDR     R1, [SP, #Proc_RegOffset + 4]
      |
        MOV     R0, #NetStnCMOS
        MOV     R1, R2
      ]
        BL      WriteWithError
        MOVVC   R0, #7          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        MSR     CPSR_cf, R4     ; restore interrupt state
        EXIT

@


4.11.2.28
log
@  Add Raspberry Pi 2 support
Detail:
  The Raspberry Pi ROM now joins the IOMD ROM in supporting multiple
  architectures, in this case ARMv6 and ARMv7. This has been achieved by
  creating a new machine type specific for Raspberry Pi. The old ARM11ZF
  machine type remains for builds that are ARM11-only.

Version 5.35, 4.79.2.256. Tagged as 'Kernel-5_35-4_79_2_256'
@
text
@d1810 1
a1810 1
      [ "$Machine"="ARM11ZF" :LOR: "$Machine"="RPi"
d1905 1
a1905 1
      [ "$Machine"="CortexA8" :LOR: "$Machine"="CortexA9" :LOR: "$Machine"="ARM11ZF" :LOR: "$Machine"="RPi"
@


4.11.2.29
log
@  Updated some CMOS default settings for 'CortexA9' builds
Detail:
  default SCSIFSDrive to 4, and both FontMax and FontSize to their
  max values. (the machines in question have a min of 512Meg of ram -
  being miserly with font caches is unhelpful)
Admin:
  tested on iMx6

Version 5.35, 4.79.2.288. Tagged as 'Kernel-5_35-4_79_2_288'
@
text
@d1568 1
a1568 1
NVMemory_ReadBlock
d1656 1
a1656 1
      [ "$Machine"="IOMD"
d1809 1
a1809 1
    |
d1812 1
a1812 1
      |
a1815 3
    [ "$Machine"="CortexA9"
        DCB     FontCMOS,           255     ; Changed to 1016k from 256K for modern machines
    |
a1816 1
    ]
d1838 1
a1838 1
      ]
d1841 1
a1841 1

a1894 3
      [ "$Machine"="CortexA9"
        DCB     FontMaxCMOS,        255       ; 16380k
      |
a1895 1
      ]
a1909 3
      [ "$Machine"="CortexA9"
        DCB     SCSIFSDrivesCMOS,   &20                  ; default to SCSIFS Drive 4
      ]
@


4.11.2.30
log
@Restore safe defaults
Detail:
  Ideally, $Machine would only exist within Hdr:Machine, they define a class of machines which in turn requires the lowest common denominator. It doesn't encode any capabilities about the class (eg. amount of memory, screen capabilities, peripherals).
Admin:
  Fixes report of Pandaboard no longer booting, since it has no drive 4.
@
text
@d1568 1
a1568 1
NVMemory_ReadBlock 
d1656 1
a1656 1
      [ "$Machine"="IOMD" 
d1809 1
a1809 1
    |                               
d1812 1
a1812 1
      |                             
d1816 3
d1820 1
d1842 1
a1842 1
      ]                             
d1845 1
a1845 1
                                    
d1899 3
d1903 1
d1918 3
@


4.11.2.31
log
@Change some default CMOS settings, using custom build switch
Detail:
  Default to SCSI::4 for boot driver is custom switch at buildtime
  (EnforceSCSI4) is defined. 2 fontcache items also defaulted with this switch
Admin:
  tested on iMx6


Version 5.35, 4.79.2.290. Tagged as 'Kernel-5_35-4_79_2_290'
@
text
@a1815 3
    [ EnforceSCSI4
        DCB     FontCMOS,           255     ; Changed to 1016k from 256K for modern machines
    |
a1816 1
    ]
a1894 3
      [ EnforceSCSI4
        DCB     FontMaxCMOS,        255       ; 16380k
      |
a1895 1
      ]
a1909 3
      [ EnforceSCSI4
        DCB     SCSIFSDrivesCMOS,   &20                  ; default to SCSIFS Drive 4
      ]
@


4.11.2.32
log
@  New method to control default CMOS settings
Detail:
  Rather than fill the Kernel sources with an ever-increasing number of
  platform-specific switches to control the default CMOS settings, this
  change introduces a variable which passes the requirements direct from
  the Components file to the Kernel. Since it uses a comma-separated list
  of address/value pairs, it is inherently extensible. All the symbolic
  names of addresses from Hdr:CMOS are available, and any valid objasm
  expression can be used for the value.
Admin:
  This removes the need for the EnforceSCSI4 switch, and leaves almost
  no uses of the Machine variable in the Kernel either.


Version 5.35, 4.79.2.298. Tagged as 'Kernel-5_35-4_79_2_298'
@
text
@d1807 6
d1814 5
d1820 1
d1899 3
d1903 1
d1913 3
d1917 4
a1920 3
 ]
 [ :DEF: CMOS_Override
        $CMOS_Override
@


4.11.2.33
log
@Fix overriding of default CMOS settings. Reserve HAL device ID for the official Raspberry Pi touchscreen/display.
Detail:
  s/PMF/i2cutils - Move $CMOS_Override to the start of DefaultCMOSTable, so that it can be used to override values which are already in the table (since NVMemory_ResetValue stops its search on the first address match)
  hdr/HALDevice - Add new Touchscreen device type and reserve an ID for the official Pi touchscreen controller
Admin:
  Tested on Raspberry Pi
  Fixes filesystem incorrectly defaulting to ADFS


Version 5.35, 4.79.2.299. Tagged as 'Kernel-5_35-4_79_2_299'
@
text
@a1805 3
 [ :DEF: CMOS_Override
        $CMOS_Override
 ]
d1899 3
@


4.11.2.34
log
@Avoid unnecesssary remainder calculations
Detail:
  s/HeapSort, s/vdu/vdugrafc, s/vdu/vduswis - Avoid unnecessary remainder calculations in DivRem macro
  s/PMF/i2cutils, s/PMF/osword - Make use of DivRem's ability to accept a constant as the divisor
Admin:
  Tested on Cortex-A15


Version 5.35, 4.79.2.318. Tagged as 'Kernel-5_35-4_79_2_318'
@
text
@d64 3
a66 2
        Push    "R2, R14"
        DivRem  R2, R0, #10, R14                ; R2=R0 DIV 10; R0=R0 MOD 10
d68 1
a68 1
        Pull    "R2, PC"
@


4.11.2.18.2.1
log
@  Fix bugs and inefficiencies revealed by unaligned data audit
Detail:
  s.PMF.i2cutils line 454: this LDR of byte values was harmless (bits 8
    upwards are discarded later) but slower than an LDRB on ARMv6 or later.
  s.PMF.i2cutils line 556: should have loaded RTCFitted using LDRB. Looks
    like effect would have been to reduce utilisation of CMOS cache.
  s.vdu.vduswis line 1500: mistakenly accessing ExternalFramestore using LDR.
    I don't think the intention was to prevent the screen DA being resized
    while screen memory was claimed, but that was the effect.
  s.vdu.vduwrch line 3106: this LDR of a 1-byte variable was harmless (only
    used for testing bit 4) but slower than an LDRB on ARMv6 or later.
  CPU version is no longer specified in the makefile - it's better to inherit
  it from the build environment now that we actually set it appropriately.
Admin:
  Built and briefly tested.

Version 5.35, 4.79.2.98.2.9. Tagged as 'Kernel-5_35-4_79_2_98_2_9'
@
text
@d451 1
a451 1
        LDRCSB  R14, [R1], #1
d553 1
a553 1
        LDRB    R14, [R14, #RTCFitted]
@


4.11.2.18.2.2
log
@Add HAL RTC support to Cortex branch of kernel, clean up RTCSupport code
Detail:
  HAL kernels (on the Cortex branch at least) now support HALDevice-based RTCs. If the kernels own RTC code is disabled or fails to detect an RTC, then after HAL_InitDevices is called the HALDevice list will be scanned for any HAL-resident RTC devices.
  Additionally, the RTCSupport flag (in Hdr:Machine.Machine), which was previously TRUE for all HAL kernels, can now be set to FALSE in HAL kernels to disable the kernels own IIC RTC code. This allows the unwanted legacy RTC code to be disabled for machines which are known to use HAL RTCs instead.
  hdr/RTCDevice - new header describing data structures used for HAL RTC device
  hdr/HALDevice - added RTCDevice device type, IIC serial bus type
  hdr/KernelWS - upgraded RTCFitted from a 1 byte field to 4 byte. It now stores either a null value (for no RTC), a value <2048 for an IIC RTC address, or a value >= 2048 for a RTCDevice ptr
  Makefile - added header export of hdr/RTCDevice
  s/GetAll - include hdr/RTCDevice
  s/NewReset - initialise HAL RTC after HAL_InitDevices if required
  s/PMF/i2cutils, s/PMF/osinit, s/PMF/osword - modifications to allow use of HAL RTC (and disallow use of builtin IIC RTC)
Admin:
  Tested on rev C2 beagleboard


Version 5.35, 4.79.2.98.2.11. Tagged as 'Kernel-5_35-4_79_2_98_2_11'
@
text
@a551 1
        ; If there's no RTC, read dummy values from the cache
d553 1
a553 1
        LDR     R14, [R14, #RTCFitted]
d555 1
a555 1
        BNE     %FT15 
d1046 1
a1046 1
	;LDR	R1, [R1, #RTCFitted]    ; This causes a headache if both an RTC and NVRAM are fitted
d1195 2
a1196 2
;	R2 = day of month (1-based)
;	R3 = month (1-based)
d1202 1
a1202 1
;	If R0,R2,R5 or R6 is -1 then the time,date,year,century (respectively) will not be written. However if R2=-1, R5 & R6 will also be -1, so only R0 (for time) and R2 (for D/M/Y) need checking.
d1209 1
a1209 64
	LDR	R10, [R10, #RTCFitted]
 [ HAL
        CMP	R10, #2048 ; Is it an I2C address or HALDevice_RTC ptr?
        BLO	%FT15
	Push	"R0-R3,R12"
	MOV	R4, R0			; copy hours in R4
        ; Prepare BCD data on stack
        ASSERT (RTCTimeStruct_BCD_Size :AND: 3)=0
        SUB	R13, R13, #RTCTimeStruct_BCD_Size
        MOV	R9, R13
        ; Ensure struct matches our setting order
        ASSERT RTCTimeStruct_BCD_Centiseconds = 0
        ASSERT RTCTimeStruct_BCD_Seconds = 1
        ASSERT RTCTimeStruct_BCD_Minutes = 2
        ASSERT RTCTimeStruct_BCD_Hours = 3
        ASSERT RTCTimeStruct_BCD_DayOfMonth = 4
        ASSERT RTCTimeStruct_BCD_Month = 5
        ASSERT RTCTimeStruct_BCD_YearLO = 6
        ASSERT RTCTimeStruct_BCD_YearHI = 7
        ; Are we setting the time?
        CMP	R4, #-1
        STREQ	R4, [R9], #4 ; Conveniently, 4 bytes of time info
        BEQ	%FT11
        MOV	R0, R8
        BL	HTBS9
        MOV	R0, R7
        BL	HTBS9
        MOV	R0, R1
        BL	HTBS9
        MOV	R0, R4
        BL	HTBS9
11
	; Are we setting the date?
	CMP	R2, #-1
	STREQ	R2, [R9], #4 ; Conveniently, 4 bytes of date info
	BEQ	%FT12
        LDRB	R1, [R10, #HALDevice_RTCFormatFlags]
        MOV	R0, R2
        TST	R1, #RTCFormatFlags_BCD_1BasedDay
        SUBEQ	R0, R0, #1
        BL	HTBS9
        TST	R1, #RTCFormatFlags_BCD_1BasedMonth
        MOV	R0, R3
        SUBEQ	R0, R0, #1
        BL	HTBS9
        MOV	R0, R5
        BL	HTBS9
        MOV	R0, R6
        BL	HTBS9
12
        SUB	R1, R9, #8
        MOV	R0, R10
        ADRL	R2, HALRTC_IICOp
        MOV	LR, PC
        LDR	PC, [R10, #HALDevice_RTCWriteTime]
	; Unfortunately, we don't do anything with the return code at the moment.
13
	ADD	R13, R13, #RTCTimeStruct_BCD_Size ; RTCTimeStruct
	Pull	"R0-R3,R12"
	BL	RTCToRealTime
	Pull	"R4, R9-R10, PC"
15
 ] ; HAL
 [ RTCSupport :LOR: :LNOT: HAL
d1212 1
a1212 1
 ]
d1215 1
a1215 1
 [ RTCSupport  :LOR: :LNOT: HAL
a1296 1
 ] ; RTCSupport :LOR: :LNOT: HAL
d1306 2
a1307 2
;	R2 = days (1-based)
;	R3 = months (1-based)
d1312 1
a1312 1
;	Note: Returns garbage if no RTC, or an error occurs!
d1316 1
d1319 1
a1319 54
        LDR	R2, [R14, #RTCFitted]
 [ HAL
	CMP	R2, #2048 ; IIC address or RTCDevice ptr?
	BLO	%FT49
	Push	"R12"
	MOV	R6, R2
	MOV	R0, R2
	SUB	R13, R13, #RTCTimeStruct_BCD_Size
	MOV	R1, R13
	ADRL	R2, HALRTC_IICOp
	MOV	LR, PC
	LDR	PC, [R0, #HALDevice_RTCReadTime]
	; Not really much point checking the error code since we have no way of returning an error to the caller
	; So just read the junk data and be done with it
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Centiseconds]
	BL	BCDToHex
	MOV	R8, R0			; centiseconds
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Seconds]
	BL	BCDToHex
	MOV	R7, R0			; seconds
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Minutes]
	BL	BCDToHex
	MOV	R1, R0			; minutes
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Hours]
	BL	BCDToHex
	MOV	R4, R0			; hours
	LDRB	R0, [R13, #RTCTimeStruct_BCD_DayOfMonth]
	BL	BCDToHex
	LDRB	R12, [R6, #HALDevice_RTCFormatFlags]
	MOV	R2, R0
	TST	R12, #RTCFormatFlags_BCD_1BasedDay
	ADDEQ	R2, R2, #1		; days
	LDRB	R0, [R13, #RTCTimeStruct_BCD_Month]
	BL	BCDToHex
	MOV	R3, R0
	TST	R12, #RTCFormatFlags_BCD_1BasedMonth
	ADDEQ	R3, R3, #1		; months
	LDRB	R0, [R13, #RTCTimeStruct_BCD_YearLO]
	BL	BCDToHex
	MOV	R5, R0			; year lo
	LDRB	R0, [R13, #RTCTimeStruct_BCD_YearHI]
	BL	BCDToHex
	; We're done with our stack data, remove it
	ADD	R13, R13, #RTCTimeStruct_BCD_Size
	MOV	R6, R0			; year hi
	; If the RTC can reliably store the year, we don't need to use the CMOS copy
	TST	R12, #RTCFormatFlags_BCD_NeedsYearHelp
	Pull	"R12"
	BEQ	DontReadTimeYear
	B	ReadTimeYear
49
 ] ; HAL
 [ RTCSupport :LOR: :LNOT: HAL
        SUB     R13, R13, #(12*2)+6+1+1
a1363 1
	ADD     R13, R13, #(12*2)+6+1+1
a1383 2
	ADD     R13, R13, #(12*2)+6+1+1
 ] ; RTCSupport :LOR: :LNOT: HAL
d1386 1
d1393 1
a1393 1
DontReadTimeYear
d1400 1
a1402 1
 [ RTCSupport :LOR: :LNOT: HAL
a1435 29
 ] ; RTCSupport :LOR: :LNOT: HAL


 [ HAL
; *****************************************************************************
;
;       HALRTC_IICOp - Wrapper for IIC_OpV to allow it to be called from HALDevice RTC drivers
;
;  in:  R0 = iic_transfer *
;	R1 = number of transfers
;	R2 = 'kernel workspace ptr' - currently unused
; out:  R0 = HAL_IICOp error code

HALRTC_IICOp
	Push	"R14"
	BL	IIC_OpV
	; Translate the RISC OS error code back into an IIC one we can pass to the driver
	LDRVS	R2, [R0]
	LDRVS	R1, =ErrorNumber_IIC_Busy
	MOV	R0, #5 ; EERROR
	TEQ	R2, R1 ; Won't modify V
	MOVEQ	R0, #3 ; EBUSY
	LDRVS	R1, =ErrorNumber_IIC_NoAcknowledge
	TEQ	R2, R1
	MOVEQ	R0, #2 ; ENOACK
	MOVVC	R0, #0 ; ECOMPLETED
	Pull	"PC"
 ]

d1461 1
a1461 1
	STRVS   R4, [R2, #RTCFitted]
d1463 1
a1463 1
	STRVC   R0, [R2, #RTCFitted]
d1466 1
a1466 1
        STR     R4, [R2, #RTCFitted]
@


4.11.2.18.2.3
log
@Update Cortex kernel to cope correctly with HAL RTC errors
Detail:
  The kernel will now attempt to cope with errors returned by HAL RTC devices - For RTC read operations, instead of just loading random garbage, the bad result will now be ignored and the soft 5-byte time left unaltered.
Admin:
  Tested on rev C2 beagleboard. Year now correctly defaults to 1970 instead of 1900 if the OMAP3 RTC driver returns an error because the RTC isn't running yet.


Version 5.35, 4.79.2.98.2.13. Tagged as 'Kernel-5_35-4_79_2_98_2_13'
@
text
@d1377 1
a1377 1
;	Note: For HAL RTCs, R0 will be negative on error. Other RTCs do not report errors and may just return garbage.
d1395 2
a1396 6
	; If there was an error, exit with a negative value in R0
	CMP	R0, #RTCRetCode_OK
	MVNNE	R0, #0
	ADDNE	R13, R13, #RTCTimeStruct_BCD_Size
	Pull	"R12",NE
	Pull	"R4,PC",NE
@


4.11.2.18.2.4
log
@Migrate 2012 RTC fix to Cortex branch of kernel
Detail:
  s/PMF/osword - Migrate the 2012 RTC fix from the HAL branch to the Cortex branch, plus apply similar fix to the code that handles HAL RTC devices (via new YearLOIsGood flag)
  s/PMF/i2cutils - Update HAL RTC year handling to correctly treat YearLO as either 2-bit int or 2-digit BCD
  hdr/RTCDevice - Add YearLOIsGood flag, revise NeedsYearHelp description
Admin:
  Tested on rev C2 beagleboard. Code seems to behave as intended.


Version 5.35, 4.79.2.98.2.21. Tagged as 'Kernel-5_35-4_79_2_98_2_21'
@
text
@d1255 2
a1256 5
        TST	R1, #RTCFormatFlags_BCD_YearLOIsGood
        ANDEQ	R0, R5, #3 ; 2 bit YearLO
        STREQB	R0, [R9], #1
        MOVNE	R0, R5 ; BCD YearLO
        BLNE	HTBS9
@


4.11.2.18.2.5
log
@Fix bug in InitCMOSCache that could cause CMOS to be erroneously reset if NVRAM is of type 'MaybeIIC' (Cortex branch)
Detail:
  s/PMF/i2cutils - Kernel was checking if the full IIC flags word was equal to MaybeIIC instead of just checking if the Provision bits equalled MaybeIIC. Thus if any of the additional flags were set along with MaybeIIC the kernel would have skipped the probing code, skipped the IIC code, and then fallen through to using the (likely unimplemented) HAL interface for initialising the NVRAM cache.
Admin:
  Fix tested in HAL branch in IOMD build under RPCemu; kernel now takes the correct path for MaybeIIC + ProtectAtEnd.


Version 5.35, 4.79.2.98.2.22. Tagged as 'Kernel-5_35-4_79_2_98_2_22'
@
text
@d1632 1
a1632 1
    	TEQ 	R0, #NVMemoryFlag_MaybeIIC
@


4.11.2.18.2.6
log
@Fix detection of Philips RTC/NVRAM when MaybeIIC is in use (Cortex branch)
Detail:
  s/PMF/i2cutils - Although the code will detect the Philips RTC correctly, it was failing to set the device size in R4, causing CMOS RAM to be misread. This change fixes that.
Admin:
  Not tested; however it's identical to the fix applied to the HAL branch


Version 5.35, 4.79.2.98.2.23. Tagged as 'Kernel-5_35-4_79_2_98_2_23'
@
text
@a1754 1
        MOVVC   R4, #1
@


4.11.2.18.2.7
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d147 1
a147 1
        LDR     R14, =ZeroPage          ; don't write to protected section
d174 1
a174 1
	LDR	R1, =ZeroPage+CMOSRAMCache	; update cache, but always write to
d200 1
a200 1
        LDR     R1, =ZeroPage+CMOSRAMCache
d263 1
a263 1
        LDR	R14, =ZeroPage
d387 1
a387 1
        LDR	R14, =ZeroPage
d405 1
a405 1
        LDR     R14, =ZeroPage+CMOSRAMCache
d553 1
a553 1
        LDR     R14, =ZeroPage
d561 1
a561 1
	LDRCC	R2, =ZeroPage+CMOSRAMCache ; if in range
d646 1
a646 1
        LDR	R14, =ZeroPage
d725 1
a725 1
        LDR     R14, =ZeroPage+CMOSRAMCache
d907 1
a907 1
        LDR     R14, =ZeroPage+CMOSRAMCache
d1039 1
a1039 1
	LDR	R14, =ZeroPage		; get no 256 byte blocks and calculate end address
d1046 1
a1046 1
	LDR	R1, =ZeroPage
a1048 1
	;LDREQ	R1, =ZeroPage
d1084 1
a1084 1
	LDR	R14, =ZeroPage		; read no 256 byte blocks and calculate end address
d1137 1
a1137 1
	LDR	R2, =ZeroPage		; read number of 256 byte blocks and calculate end address
d1175 1
a1175 1
	LDR	R2, =ZeroPage
d1608 2
a1609 1
	MOV	R2, #0
d1616 1
a1616 1
	STRVS   R2, [R4, #RTCFitted]
d1618 1
a1618 1
	STRVC   R0, [R4, #RTCFitted]
d1621 1
a1621 1
        STR     R2, [R4, #RTCFitted]
d1678 1
a1678 1
    	LDR 	R1, =ZeroPage+CMOSRAMCache
d1783 1
a1783 1
	LDR	R3, =ZeroPage+CMOSRAMCache
d1799 1
a1799 1
    	LDR	R3, =ZeroPage+CMOSRAMCache
a1925 1
      [ ZeroPage = 0
a1926 4
      |
        LDR     R1, =ZeroPage
        LDRB    R1, [R1, #NVRamSize]
      ]
@


4.10
log
@  Added 32K EEPROM support.
  New routine in i2cutils that allows access to protected sections such as
  MAC address
  OS_ReadSysInfo 4 now checks both copies MACAddress if MACNVRAM2copies is set
Detail:
  32K EEPROM has to be configured with IIC address &A6 (i.e wired up on the pcb)
  ClockNVMemoryFast has been replaced with MaxI2Cspeed so that several different
  rates can be used depending on the devices on the IIC bus.
Admin:
  Need to implement routine that can use one copy of the MAC address to
  replace the other in the event of it being corrupted.


Version 5.33. Tagged as 'Kernel-5_33'
@
text
@d134 1
d143 3
@


4.9
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d54 13
a133 1
 [ ClockNVMemoryFast
a141 3
 |
        MOV     R0, #10                         ; 5s delay
 ]
d257 1
a257 1
 [ :LNOT: ClockNVMemoryFast
d537 11
d567 1
a1638 1
      [ ClockNVMemoryFast
a1644 1
      ]
d1659 1
a1667 1
      [ ClockNVMemoryFast
a1668 1
      ]
a1692 1
      [ ClockNVMemoryFast
a1693 1
      ]
a1703 1
      [ ClockNVMemoryFast
a1704 1
      ]
a1714 1
      [ ClockNVMemoryFast
d1716 3
a1718 1
      ]
d1720 9
a1728 1
	MOVVS   R1, #RTCAddress
d1740 3
a1742 1
      [ ClockNVMemoryFast
d1744 1
a1744 1
      ]
a1749 1
      [ ClockNVMemoryFast
a1750 1
      ]
@


4.8
log
@  Conditional assembly fixed.
Detail:
  If E2ROMSupport is {FALSE} then the kernel fails to build due to the
    use a symbols that are only defined if E2ROMSupport is {TRUE}.  This
    is now fixed by stopping the symbols being used where they should not
    be (NVRAM and RTC related symbols).
Admin:
  Built.

Version 5.14. Tagged as 'Kernel-5_14'
@
text
@d98 4
d103 1
d135 4
d140 1
d181 4
d186 1
d191 4
a194 1
 [ {TRUE}
d210 4
d215 1
d220 2
a221 2
	BL	ClockData
	Pull	"R0, PC",,^
d231 4
d236 1
d262 6
a267 1
	Pull	"R0-R2,PC",,^
d289 4
a292 4
	MOV	R1,PC
	Push	"R1"
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
d309 1
a309 1
	TEQP	PC,R1
d313 1
a313 1
	MOV	R2, PC
d316 1
a316 1
	TEQP	R2, #0
d328 4
d333 1
d345 4
d350 1
d362 4
d367 1
d376 4
d381 1
d396 4
d401 1
d415 4
d420 1
d431 4
d436 1
d449 4
a452 4
	MOV	R1,PC
	Push	"R1"
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
d468 1
a468 1
	TEQP	PC,R1
d474 4
d479 1
d521 2
d524 1
a524 2
        Pull    "R1-R4,R14"
        ORRS    PC, LR, #V_bit
d688 2
d691 1
a691 3
95
        Pull    "R1-R4,LR"
        ORRS    PC, LR, #V_bit
d819 2
a820 2

	BL	Stop
d824 1
a824 1
	Pull	"R0,R2,R3,R5,R6,PC",,^
d849 2
d852 1
a852 2
        Pull    "R1,R2,R14"
        ORRS    PC, LR, #V_bit
d865 11
a875 1
	CMP	R0, #&100		; check small cache limit
d972 2
d975 1
a975 3
95
        Pull    "R1-R3,LR"
        ORRS    PC, LR, #V_bit
d1039 1
a1039 1
        Pull    "R3-R5,PC",,^
d1079 1
a1079 1

d1082 1
a1082 1
	Pull	"R0,R2,R3-R5,PC",,^
d1257 1
a1257 2
	Pull	"R14",CS
	ORRCSS	PC, R14, #C_bit		; indicate invalid
d1282 2
a1283 2
	Pull	"R14"
	BICS	PC, R14, #C_bit		; indicate valid
d1315 1
a1315 1
	ORRCSS	PC, R14, #C_bit		;    invalid
d1318 3
a1320 1
	BICCSS	PC, R14, #C_bit		;    valid (no mungeing)
d1322 1
a1322 1

d1325 4
a1328 2
        SUBCS   R0, R0, #&F0            ;    map &F0->&FF to &00->0F for OTP section
        BICCSS  PC, R14, #C_bit
d1330 1
a1330 1
	ORRCSS	PC, R14, #C_bit		;    invalid
d1332 1
a1332 1

d1336 2
a1337 1
	BICS	PC, R14, #C_bit		; valid
d1885 1
a1885 1
        ORRS    PC, LR, #V_bit
d1901 1
a1901 1
        MOVS    PC, LR
d1913 3
a1915 2
        MOV     R4, PC
        TEQP    PC, #SVC_mode   ; enable interrupts - this may take some time
d1921 1
a1921 1
        TEQP    PC, R4          ; restore interrupt state
d1937 3
a1939 2
        MOV     R4, PC
        TEQP    PC, #SVC_mode   ; enable interrupts - this may take some time
d1945 1
a1945 1
        TEQP    PC, R4          ; restore interrupt state
d1959 3
a1961 1
        TEQP    PC, #SVC_mode   ; enable interrupts - this may take some time
d1968 1
a1968 1
        TEQP    PC, R4          ; restore interrupt state
d1981 3
a1983 2
        MOV     R4, PC
        TEQP    PC, #SVC_mode   ; enable interrupts - this may take some time
d1998 1
a1998 1
        TEQP    PC, R4          ; restore interrupt state
@


4.7
log
@Kernel now always assumes that 4K and 8K ATMEL EEPROM devices have their top
quarter write protected, even if IOMD_C_EEPROMProtect isn't set.

Version 5.10. Tagged as 'Kernel-5_10'
@
text
@d464 1
d469 1
d1273 1
d1281 3
d1315 1
d1323 3
d1354 1
d1371 1
a1371 1

@


4.6
log
@* Meaning of FEIOSpeedHalf was accidentally inverted.
* Wasn't allowing writes to most of EEPROM.
* Old prototype OS_SetTime SWI code removed.
* MPEGPoduleNTSCNotPALMask option support removed to simplify things a bit.
* Now can cope with a system with a PAL/NTSC link, but no monitor detect line.
* Default PAL & NTSC modes now always 12 & 46 respectively.
* Kernel now knows about monitor type 8 (NTSC) - modes 44-46 (640x200) are
  available.
* STB/NC CMOS test removed from POST pending further investigation.

Version 4.90. Tagged as 'Kernel-4_90'
@
text
@a1585 1
      [ IOMD_C_EEPROMProtect <> 0
a1586 1
      ]
a1598 1
      [ IOMD_C_EEPROMProtect <> 0
a1599 1
      ]
@


4.5
log
@Added support for ATMEL 4K and 8K EEPROM parts, including write protection
of top quarter. Untested.
Added support for ARM7500FE IO clock divide by 2.

Version 4.89. Tagged as 'Kernel-4_89'
@
text
@d466 1
a466 1
        CMP     R0, R14                 ; (note assumption that NVRamWriteSize is
d545 1
a1322 32

; *****************************************************************************
;
;       OS_SetTime - Set the real-time clock
;
; in:   R0 = pointer to 5 byte UTC time
;
; out:  R0 preserved
;

SetTimeSWI ROUT
        Push    "R0-R8"
        SUB     SP, SP, #36
        MOV     R1, R0
        MOV     R2, SP
        SWI     XTerritory_ConvertTimeToUTCOrdinals
        ADDVS   SP, SP, #36+4
        Pull    "R1-R8", VS
        ExitSWIHandler VS
        LDR     R8, [SP], #4    ; centiseconds
        LDR     R7, [SP], #4    ; seconds
        LDR     R1, [SP], #4    ; minutes
        Pull    "R0,R2,R3,R5"   ; hours, day, month, year
        ADD     SP, SP, #8      ; junk day of week and year
        MOV     R4, #100
        DivRem  R6, R5, R4, R14 ; R5 = year (lo), R6 = year (hi)

        BL      SetTime

        STRVS   R0,[SP]
        Pull    "R0-R8"
        ExitSWIHandler
@


4.4
log
@* Added support for 24LC64 8K EEPROM (untested).
* Integrated Ursula fast service call dispatch code.
* Added Interruptible32bitModes from Ursula.
* Stopped allowing ROM modules (other than the Kernel/UtilityModule) to write
  to the hardware vectors in 26-bit mode.

Version 4.81. Tagged as 'Kernel-4_81'
@
text
@d38 1
d51 2
a52 1
E2ROMAddress8K          *       &a2     ; 24C64 device - 8K
d464 5
d543 1
d547 1
d552 1
d563 6
d1325 32
d1543 1
a1543 1
InitCMOSCache	ENTRY "r0-r5"
d1572 1
d1611 15
d1632 3
d1649 3
@


4.3
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d37 1
d50 1
d1560 13
@


4.2
log
@Kernel merged
@
text
@d34 3
d40 2
a41 1
PollMax		*	&f	; Number of times to poll for an Ack
d44 1
a44 1
RTCAddress	* &a0
d46 4
a49 1
E2ROMAddress	* &a8
a51 6
; i2cWorkSpace is defined elsewhere to point somewhere sensible when debugging
  [ :LNOT: :DEF: TestHarness
i2cWorkSpace	* 0
  ]
	

d112 12
a123 1
	MOV	R0, #10			; delay for >= 10/2 microsecs
d210 1
a210 1
; Delay here must be >= 4.0 microsecs
d216 1
a216 1
 [ {TRUE}
d220 1
a220 1
	MOV	R0,#10
d224 1
a224 1
; Delay here must be >= 4.7 microsecs
d261 1
a261 1
; Delay here must be >= 4.0 microsecs
d297 1
a297 1
; Delay here must be >= 4.0 microsecs
d316 1
a317 1
	MOV	R1, #&80		; 2^7 the bit mask
d435 16
a450 1
Write	ROUT
d454 5
d476 6
a481 3
	ADR	R1, CMOSRAMCache-16	; update cache, but always write to
  [ :DEF: TestHarness
	ADD	R1, R1, #i2cWorkSpace
d484 1
d497 5
a501 1
	MOV	R0, R2			; offset
d519 214
d735 1
d739 1
a739 1
; out:	R0 = data (illegal address return 0)
d747 13
d769 5
a773 5
	CMP	R0, #&10		; don't cache values < &10
	ADRCS	R2, CMOSRAMCache-&10	; if in range

  [ :DEF: TestHarness
	ADD	R2, R2, #i2cWorkSpace
d775 2
a776 2
	LDRCSB	R0, [R2, R0]		; read from cache
	Pull	"R1,R2,PC", CS		; and exit
d792 5
a796 1
	MOV	R0, R2			; offset
d816 306
d1131 1
a1131 1
;	C=0 => NVRam address is valid 
d1134 1
a1134 1
;	      by 1 for reading.
d1142 10
a1151 1
	CMP	R0, #&100
d1154 3
a1156 2
; address is <&100 -> is valid
	MOV	R1, #i2cWorkSpace
d1158 10
a1167 3
	TEQ	R1, #1
	MOVEQ	R1, #RTCAddress
	MOVNE	R1, #E2ROMAddress
d1169 9
d1179 1
d1189 1
a1189 1
; in:	R0 = logical address (&00..&EF, &100..)
d1191 2
a1192 2
; out:	C=0 => valid logical address (ie not &F0..&FF)
;	 R0 = physical address (&40..&FF,&10..&3F,&100..)
d1194 1
a1194 1
;	C=1 => invalid logical address (ie &F0..&FF)
d1199 24
a1222 2
	CMP	R0, #&F0		; if address &f0 or above
	ORRCSS	PC, R14, #C_bit		; indicate invalid
d1227 1
a1227 1
	BICS	PC, R14, #C_bit		; indicate valid
a1228 1
		
d1233 5
a1237 2
;       This routine performs MangleCMOSAddress inherently, and
;       assumes the checksum is the last logical location.
d1248 1
a1248 1
ValChecksum	ENTRY "R1,R2,R3"
d1250 10
a1259 20
	MOV	R3, #CMOSxseed
    [ E2ROMSupport
	MOV	R0, #&40
	BL	GetI2CAddress		; r1 = device address, r0 = offset
	MOV	R2, R0			; save the offset
    |
	MOV	R2, #&40
	MOV	R1, #RTCAddress
    ]
10
	MOV	R0, R1	 		; device write address
	BL	StartTXPollAck
	
	MOV	R0, R2			; memory offset
	BL	TXAck

	BL	Start

	ADD	R0, R1, #1		; device read address
	BL	TXAck
d1262 1
a1262 3
; Read data from locations &40 through &FF, then
; loop back to &10 (we have to write the address again) and read
; on until &3E .. thus missing out the checksum location.
d1264 3
a1266 28
20
	BL	RXByte			; returned in R0
	ADD	R3, R3, R0		; accumulate into R3

	ADD	R2, R2, #1		; increment R2 to phys. address
	TEQ	R2, #&100		; limit
	BEQ	%30
	TEQ	R2, #PhysChecksum	; or until checksum.
	BEQ	%30			; then we're finished

	MOV	R0, #0			; not done .. ACK that byte
	BL	ClockData
	B	%BT20			; .. and continue reading

30
	MOV	R0, #1			; finish off reading block
	BL	ClockData
	BL	Stop

        TST     R2, #&100		; either go back for bytes 10 - 3f
        MOVNE   R2, #&10		; or finish up completely.
	BNE	%BT10

;
; R3 contains the actual checksum. Compare it with the recorded checksum
;
	MOV	R0, #PhysChecksum
	BL	ReadStraight
d1268 1
a1268 1
	AND	R0, R3, #&FF		; calculated value into R0
d1272 1
a1272 1
  ]				 
d1287 11
a1297 3
	Push	R14
	BL	ValChecksum
	MOV	R1, R0
d1300 1
a1300 1
	Pull	PC
d1303 2
d1325 18
d1493 1
a1493 1
InitCMOSCache	ENTRY "r0-r3"
d1496 13
a1508 1
;	First determine what hardware we've got fitted, R3 holds the number of
d1510 1
a1510 1
	
d1514 18
a1531 4
	MOVVS	R3, #0
	MOVVC	R3, #1
	MOV	R2, #i2cWorkSpace
	STRB	R3, [R2, #RTCFitted]
d1534 1
d1537 1
a1537 1
	ADDVC	R3, R3, #4
d1543 1
a1543 1
	ADDVC	R3, R3, #4
d1546 6
a1551 2
; Have we got any E ?
	MOV	r0, #(E2ROMAddress)
d1553 7
a1559 1
	ADDVC	R3, R3, #1
d1561 1
d1563 17
a1579 1
5	STRB	R3, [R2, #NVRamSize]
d1582 9
a1590 3
	MOV	R0, #&10
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R2, R0			; save the offset
d1594 6
d1601 1
a1601 5
	ADR	R3, CMOSRAMCache-16

    [	:DEF: TestHarness
	ADD	R3, R3, #i2cWorkSpace
    ]
d1607 5
a1611 1
	MOV	R0, R2			; memory word address
d1616 1
a1616 1
	ADD	R0, R1, #1		; read address
d1623 2
a1624 2
	CMP	R2, #&100
	BEQ	%FT20
d1626 3
a1628 1
	MOV	R0, #0			; not done .. ACK that byte
d1630 8
a1637 1
	B	%BT10			; .. and continue reading
d1642 11
d1654 25
d1700 1
a1700 1
	BL	TXAck			; do write and set V if no ack 
d1704 141
@


4.2.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d35 1
a35 1
PhysChecksum    *       (((CheckSumCMOS + &30) :MOD: &F0) + &10)
d37 1
a37 1
PollMax         *       &f      ; Number of times to poll for an Ack
d40 3
a42 3
RTCAddress      * &a0
  [     E2ROMSupport
E2ROMAddress    * &a8
d47 1
a47 1
i2cWorkSpace    * 0
d49 1
a49 1
        
d53 1
a53 1
;       HexToBCD - Convert byte in hex to BCD
d55 1
a55 1
; in:   R0 = byte in hex
d57 2
a58 2
; out:  R0 = byte in BCD (ie R0 := (R0 DIV 10)*16 + R0 MOD 10)
;       All other registers preserved
d62 5
a66 5
        Push    "R1,R2, R14"
        MOV     R1, #10
        DivRem  R2, R0, R1, R14                 ; R2=R0 DIV 10; R0=R0 MOD 10
        ADD     R0, R0, R2, LSL #4
        Pull    "R1,R2, PC"
d70 1
a70 1
;       BCDToHex - Convert byte in BCD to hex
d72 1
a72 1
; in:   R0 = byte in BCD (ie x*16 + y)
d74 2
a75 2
; out:  R0 = byte in hex (ie x*10 + y)
;       All other registers preserved
d79 5
a83 5
        Push    "R14"
        MOV     R14, R0, LSR #4                 ; R14 := x
        ADD     R14, R14, R14, LSL #1           ; R14 := x*3
        SUB     R0, R0, R14, LSL #1             ; R0 := R0 - x*6 = x*10
        Pull    "PC"
d87 1
a87 1
;       SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
d89 1
a89 1
; out:  All registers preserved, including PSR
d93 2
a94 2
        Push    "R0-R2,R14"
        ADD     R0, R0, R1, LSL #1      ; R0 := C0 + C1*2
d96 11
a106 7
        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy
        BIC     R1, R1, #&03                    ; clear clock and data
        ORR     R0, R1, R0                      ; put in new clock and data
        ORR     R0, R0, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R0, [R2, #IOCControlSoftCopy]   ; store back to soft copy
d108 2
a109 2
        MOV     R2, #IOC
        STRB    R0, [R2, #IOCControl]
d111 2
a112 2
        MOV     R0, #10                 ; delay for >= 10/2 microsecs
        BL      DoMicroDelay
d114 1
a114 1
        Pull    "R0-R2,PC",,^
d118 1
a118 1
;       DoMicroDelay - Delay for >= R0/2 microseconds
d120 3
a122 3
; in:   R0 = time delay in 1/2 microsecond units
;       R2 -> IOC
;       On ARM600, we may or may not be in a 32-bit mode
d124 1
a124 1
; out:  R0,R1 corrupted
d128 1
a128 1
        Push    R14
d130 2
a131 2
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
d133 7
a139 7
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R14, [R2, #Timer0CL]    ; R14 := low output latch
        TEQ     R14, R1                 ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R14                 ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished
d141 1
a141 1
        Pull    PC
d143 1
a143 1
        LTORG
d147 1
a147 1
;       ClockData - Clock a bit of data down the IIC bus
d149 1
a149 1
; in:   R0 = data bit
d151 1
a151 1
; out:  All registers preserved, including PSR
d155 1
a155 1
        Push    "R1, R14"
d157 2
a158 2
        MOV     R1, #0                  ; Clock lo
        BL      SetC1C0
d160 1
d164 6
a169 6
        MOV     R1,PC
        ORR     R1,R1,#I_bit
        TEQP    PC,R1

        MOV     R1, #1                  ; Clock hi
        BL      SetC1C0
d173 2
a174 2
        MOV     R1, #0                  ; Clock lo
        BL      SetC1C0
d176 1
a176 1
        Pull    "R1, PC",,^
d178 5
a182 5
ClockData0 ROUT                         ; Clock a zero bit
        Push    "R0, R14"
        MOV     R0, #0
        BL      ClockData
        Pull    "R0, PC",,^
d186 1
a186 1
;       Start - Send the Start signal
d188 1
a188 1
; out:  All registers preserved, including PSR
d191 2
a192 2
Start   ROUT
        Push    "R0-R2,R14"
d194 3
a196 3
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SetC1C0
d200 3
a202 3
        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SetC1C0
d204 1
d207 4
a210 3
        MOV     R2, #IOC
        MOV     R0,#10
        BL      DoMicroDelay
d214 3
a216 3
        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
        BL      SetC1C0
d218 1
a218 1
        Pull    "R0-R2,PC",,^
d222 1
a222 1
;       Acknowledge - Check acknowledge after transmitting a byte
d224 3
a226 3
; out:  All registers preserved
;       V=0 => acknowledge received
;       V=1 => no acknowledge received
d230 1
a230 1
        Push    "R0-R2,R14"
d232 3
a234 3
        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        BL      SetC1C0
d236 1
d240 8
a247 8
        MOV     R1,PC
        Push    "R1"
        ORR     R1,R1,#I_bit
        TEQP    PC,R1

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SetC1C0
d251 2
a252 2
        MOV     R2, #IOC
        LDRB    R2, [R2, #IOCControl]   ; get the data from IOC
d254 8
a261 3
        MOV     R0, #0
        MOV     R1, #0                  ; clock lo
        BL      SetC1C0
d263 5
a267 2
        Pull    "R1"
        TEQP    PC,R1
d269 1
a269 7
        TST     R2, #1                  ; should be LO for correct acknowledge
        MOV     R2, PC
        BICEQ   R2, R2, #V_bit          ; clear V if correct acknowledge
        ORRNE   R2, R2, #V_bit          ; set V if no acknowledge
        TEQP    R2, #0

        Pull    "R0-R2,PC"
d273 1
a273 1
;       Stop - Send the Stop signal
d275 1
a275 1
; out:  All registers preserved, including PSR
d278 2
a279 2
Stop    ROUT
        Push    "R0,R1,R14"
d281 3
a283 3
        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SetC1C0
d287 3
a289 3
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SetC1C0
d291 1
a291 1
        Pull    "R0,R1,PC",,^
d295 1
a295 1
;       TXByte - Transmit a byte
d297 1
a297 1
; in:   R0 = byte to be transmitted
d299 1
a299 1
; out:  All registers preserved, including PSR
d302 4
a305 4
TXByte  ROUT
        Push    "R0-R2,R14"
        MOV     R2, R0                  ; byte goes into R2
        MOV     R1, #&80                ; 2^7 the bit mask
d307 6
a312 6
        ANDS    R0, R2, R1              ; zero if bit is zero
        MOVNE   R0, #1
        BL      ClockData               ; send the bit
        MOVS    R1, R1, LSR #1
        BNE     %BT10
        Pull    "R0-R2,PC",,^
d316 1
a316 1
;       StartTXPollAck - Transmit start and a byte and poll for acknowledge
d318 2
a319 2
;       This is intended for devices with a slow internal write cycle which
;       don't ack until the write cycle is finished ( eg ATMEL AT24C01A/x )
d321 1
a321 1
; in:   R0 = byte to be transmitted
d323 1
a323 1
; out:  All registers preserved, including PSR
d326 3
a328 3
StartTXPollAck  ROUT
        Push    "R1,R14"
        MOV     R1, #0
d330 12
a341 9
        INC     R1
        CMP     R1, #PollMax
        Pull    "R1,pc", EQ

        BL      Start
        BL      TXByte
        BL      Acknowledge
        BVS     %BT10
        Pull    "R1,pc",,^
d345 1
a345 1
;       RXByte - Receive a byte
d347 2
a348 2
; out:  R0 = byte received
;       All other registers preserved, including PSR
d351 5
a355 5
RXByte  ROUT
        Push    "R1-R4, R14"
        MOV     R3, #0                  ; byte:=0
        MOV     R2, #IOC
        MOV     R4, #7
d357 3
a359 3
        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        BL      SetC1C0
d361 1
d365 23
a387 4
        MOV     R1,PC
        Push    "R1"
        ORR     R1,R1,#I_bit
        TEQP    PC,R1
d389 2
a390 20
        MOV     R0, #1                  ; pulse clock HI
        MOV     R1, #1
        BL      SetC1C0

        LDRB    R1, [R2, #IOCControl]   ; get the data from IOC
        AND     R1, R1, #1
        ADD     R3, R1, R3, LSL #1      ; byte:=byte*2+(IOC?0)AND1

        MOV     R0, #1                  ; return clock LO
        MOV     R1, #0
        BL      SetC1C0

        Pull    "R1"
        TEQP    PC,R1

        SUBS    R4, R4, #1
        BCS     %BT10

        MOV     R0, R3                  ; return the result in R0
        Pull    "R1-R4, PC",,^
d394 5
a398 5
HTBTA   ROUT
        Push    R14
        BL      HexToBCD
        BL      TXAck
        Pull    PC
d400 5
a404 5
TXAck   ROUT
        Push    R14
        BL      TXByte
        BL      Acknowledge
        Pull    PC
d407 5
a411 5
        Push    R14
        BL      ClockData0
        BL      RXByte
        BL      BCDToHex
        Pull    PC
d415 1
a415 1
;       Write - Write a byte of CMOS RAM specified by logical address
d417 2
a418 2
; in:   R0 = address in CMOS RAM
;       R1 = data
d420 1
a420 1
; out:  All registers preserved
d423 4
a426 4
Write   ROUT
        Push    "R0-R4, R14"
        BL      MangleCMOSAddress
        Pull    "R0-R4, PC", CS         ; if invalid, then exit
d428 2
a429 2
        MOV     R2, R0
        MOV     R3, R1
d431 10
a440 10
        BL      ReadStraight            ; calculate new checksum :
        MOV     R4, R0
        MOV     R0, #PhysChecksum
        BL      ReadStraight
        SUB     R0, R0, R4              ; = oldsum - oldcontents
        ADD     R4, R0, R3              ;          + newcontents

        AND     R4, R4, #&FF
        CMPS    R2, #PhysChecksum       ; don't write new checksum ...
        ORREQ   R4, R4, #&1000000       ; if checksum is being written
d443 2
a444 1
        ADR     R1, CMOSRAMCache-16     ; update cache, but always write to
d446 1
a446 1
        ADD     R1, R1, #i2cWorkSpace
d448 2
a449 1
        STRB    R3, [R1, R2]            ; real hardware as well
d451 3
a453 3
        MOV     R0, R2
        BL      GetI2CAddress           ; convert to device address + offset
        MOV     R2, R0                  ; save the offset
d455 1
a455 1
        MOV     R1, #RTCAddress
d458 2
a459 2
        MOV     R0, R1                  ; device address for write
        BL      StartTXPollAck
d461 2
a462 2
        MOV     R0, R2                  ; offset
        BL      TXAck
d464 2
a465 2
        MOV     R0, R3                  ; data
        BL      TXAck
d467 9
a475 9
        BL      Stop
        [ ChecksumCMOS
        TST     R4, #&1000000           ; loop again to write new checksum
        MOV     R3, R4
        MOV     R2, #PhysChecksum
        ORR     R4, R4, #&1000000       ; but ensure it only happens once
        BEQ     %BT10
        ]
        Pull    "R0-R4, PC"
d479 2
a480 2
;       Read - Read a byte of CMOS RAM specified by logical address
;       ReadStraight - Read a byte of CMOS RAM specified by physical address
d482 1
a482 1
; in:   R0 = address in CMOS RAM
d484 2
a485 2
; out:  R0 = data (illegal address return 0)
;       All other registers preserved
d489 2
a490 2
        Push    "R1,R2,R14"
        B       %FT10
d493 4
a496 4
        Push    "R1,R2,R14"
        BL      MangleCMOSAddress
        MOVCS   R0, #0                  ; pretend illegal addresses contain 0
        Pull    "R1,R2,PC", CS
d498 5
a502 4
        TEQ     R0, #&40                ; is it Econet station number
        BEQ     %FT15                   ; if so then don't use cache
        CMP     R0, #&10                ; don't cache values < &10
        ADRCS   R2, CMOSRAMCache-&10    ; if in range
d505 1
a505 1
        ADD     R2, R2, #i2cWorkSpace
d507 2
a508 2
        LDRCSB  R0, [R2, R0]            ; read from cache
        Pull    "R1,R2,PC", CS          ; and exit
d512 1
d514 2
a515 2
  [     E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
d517 1
a517 1
        MOV     R1, #RTCAddress
d520 3
a522 3
        MOV     R2, R0                  ; save the offset
        MOV     R0, R1                  ; device address for write
        BL      StartTXPollAck
d524 2
a525 2
        MOV     R0, R2                  ; offset
        BL      TXAck
d527 1
a527 1
        BL      Start
d529 2
a530 2
        ADD     R0, R1, #1              ; device address for read
        BL      TXAck
d532 2
a533 2
        BL      RXByte                  ; returned in R0
        MOV     R2, R0                  ; copy to R2 for now
d535 2
a536 2
        MOV     R0, #1
        BL      ClockData
d538 1
a538 1
        BL      Stop
d540 1
a540 1
        MOV     R0, R2                  ; return the result
d542 1
a542 1
        Pull    "R1,R2,PC"
d546 2
a547 2
;       GetI2CAddress - Convert NVRam physical address to i2c device address
;                       and offset
d549 1
a549 1
; in:   R0 = NVRam physical address (&00..size of NVRam)
d551 1
a551 1
; out:  R0 preserved
d553 4
a556 4
;       C=0 => NVRam address is valid 
;        R0 = physical address within i2c device
;        R1 = i2c device address for writing. Increment this device address
;             by 1 for reading.
d558 3
a560 3
;       C=1 => NVRam address is out of range of CMOS or E2ROM chips
;        R0 preserved
;        R1 preserved
d562 1
a562 1
  [     E2ROMSupport
d564 2
a565 2
        CMP     R0, #&100
        ORRCSS  PC, R14, #C_bit         ; indicate invalid
d568 5
a572 5
        MOV     R1, #i2cWorkSpace
        LDRB    R1, [R1, #RTCFitted]
        TEQ     R1, #1
        MOVEQ   R1, #RTCAddress
        MOVNE   R1, #E2ROMAddress
d574 1
a574 1
        BICS    PC, R14, #C_bit         ; indicate valid
d580 1
a580 1
;       MangleCMOSAddress - Convert from logical to physical address
d582 1
a582 1
;       Doesn't check if address is larger than the amount of NVRam installed
d584 1
a584 1
; in:   R0 = logical address (&00..&EF, &100..)
d586 2
a587 2
; out:  C=0 => valid logical address (ie not &F0..&FF)
;        R0 = physical address (&40..&FF,&10..&3F,&100..)
d589 2
a590 2
;       C=1 => invalid logical address (ie &F0..&FF)
;        R0 preserved
d594 2
a595 2
        CMP     R0, #&F0                ; if address &f0 or above
        ORRCSS  PC, R14, #C_bit         ; indicate invalid
d597 4
a600 4
        ADD     R0, R0, #&40            ; now in range &40..&13F
        CMP     R0, #&100
        SUBCS   R0, R0, #(&100-&10)     ; now in range &40..&FF, &10..&3F
        BICS    PC, R14, #C_bit         ; indicate valid
d602 1
a602 1
                
d605 1
a605 1
;       ValChecksum - test to see if the CMOS checksum is OK
d610 1
a610 1
; in:   none
d612 3
a614 3
; out:  R0 = calculated checksum
;       Z       set if checksum is valid
;       All other registers preserved
d619 1
a619 1
ValChecksum     ENTRY "R1,R2,R3"
d621 1
a621 1
        MOV     R3, #CMOSxseed
d623 3
a625 3
        MOV     R0, #&40
        BL      GetI2CAddress           ; r1 = device address, r0 = offset
        MOV     R2, R0                  ; save the offset
d627 2
a628 2
        MOV     R2, #&40
        MOV     R1, #RTCAddress
d631 5
a635 5
        MOV     R0, R1                  ; device write address
        BL      StartTXPollAck
        
        MOV     R0, R2                  ; memory offset
        BL      TXAck
d637 1
a637 1
        BL      Start
d639 2
a640 2
        ADD     R0, R1, #1              ; device read address
        BL      TXAck
d648 2
a649 2
        BL      RXByte                  ; returned in R0
        ADD     R3, R3, R0              ; accumulate into R3
d651 9
a659 9
        ADD     R2, R2, #1              ; increment R2 to phys. address
        TEQ     R2, #&100               ; limit
        BEQ     %30
        TEQ     R2, #PhysChecksum       ; or until checksum.
        BEQ     %30                     ; then we're finished

        MOV     R0, #0                  ; not done .. ACK that byte
        BL      ClockData
        B       %BT20                   ; .. and continue reading
d662 7
a668 7
        MOV     R0, #1                  ; finish off reading block
        BL      ClockData
        BL      Stop

        TST     R2, #&100               ; either go back for bytes 10 - 3f
        MOVNE   R2, #&10                ; or finish up completely.
        BNE     %BT10
d673 5
a677 5
        MOV     R0, #PhysChecksum
        BL      ReadStraight
        AND     R2, R0, #&FF            ; value from checksum location
        AND     R0, R3, #&FF            ; calculated value into R0
        CMPS    R0, R2
d679 2
a680 2
        EXIT
  ]                              
d684 1
a684 1
;       MakeChecksum - calculate and write a correct checksum
d686 1
a686 1
; in:   none
d688 2
a689 2
; out:  R0 = calculated checksum
;       All other registers preserved
d692 1
a692 1
        [ ChecksumCMOS
d694 8
a701 8
MakeChecksum    ROUT
        Push    R14
        BL      ValChecksum
        MOV     R1, R0
        MOV     R0, #CheckSumCMOS
        BL      Write
        Pull    PC
        ]
d705 1
a705 1
;       SetTime - Write the CMOS clock time and update 5-byte RealTime
d707 9
a715 9
; in:   UTC time:
;       R0 = hours
;       R1 = minutes
;       R2 = day of month
;       R3 = month
;       R5 = year (lo)
;       R6 = year (hi)
;       R7 = seconds
;       R8 = centiseconds
d717 1
a717 1
;       Any of the above, if -1, will not be written to
d721 1
a721 1
        Push    "R4, R14"               ; save registers
d725 1
a725 1
        MOV     R4, R0                  ; save hours in R4
d727 16
a742 16
        Push    "R1"
        MOVS    R1, R5
        MOVPL   R0, #YearCMOS
        BLPL    Write
        MOVS    R1, R6
        MOVPL   R0, #YearCMOS+1
        BLPL    Write

        CMP     R4, #-1                 ; are we writing time ?
        Pull    "R1",EQ                 ; [no, then skip]
        BEQ     %FT30

        MOV     R0, #&01                ; start at address 1
    [   E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
        MOV     R0, R1                  ; write address
d744 1
a744 1
        MOV     R0, #RTCAddress
d746 13
a758 13
        Pull    "R1"
        BL      StartTXPollAck
        MOV     R0, #&01                ; offset 1
        BL      TXAck
        MOV     R0, R8                  ; centiseconds
        BL      HTBTA
        MOV     R0, R7                  ; seconds
        BL      HTBTA
        MOV     R0, R1                  ; minutes
        BL      HTBTA
        MOV     R0, R4                  ; hours
        BL      HTBTA
        BL      Stop
d761 2
a762 2
        CMP     R2, #-1                 ; are we writing date ?
        BEQ     %FT40                   ; [no, then skip]
d764 4
a767 4
        MOV     R0, #&05                ; start at address 5
    [   E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
        MOV     R0, R1                  ; write address
d769 1
a769 1
        MOV     R0, #RTCAddress
d771 10
a780 10
        BL      StartTXPollAck
        MOV     R0, #&05                ; offset 5
        BL      TXAck
        MOV     R0, R2                  ; day of month
        BL      HexToBCD
        ORR     R0, R0, R5, LSL #6      ; year in bits 6,7; day in bits 0..5
        BL      TXAck
        MOV     R0, R3                  ; months
        BL      HTBTA
        BL      Stop
d783 1
a783 1
        MOV     R0, R4                  ; put hours back in R0
d785 1
a785 1
        BL      RTCToRealTime
d787 1
a787 1
        Pull    "R4, PC"
d791 1
a791 1
;       ReadTime - Read the CMOS clock time
d793 1
a793 1
; in:   -
d795 8
a802 8
; out:  R0 = hours
;       R1 = minutes
;       R2 = days
;       R3 = months
;       R5 = year (lo)
;       R6 = year (hi)
;       R7 = seconds
;       R8 = centiseconds
d806 1
a806 1
        Push    "R4, R14"
d808 4
a811 4
        MOV     R0, #&01                ; start at address 1
    [   E2ROMSupport
        BL      GetI2CAddress           ; convert to device address and offset
        MOV     R0, R1                  ; write address
d813 1
a813 1
        MOV     R0, #RTCAddress
d815 6
a820 6
        BL      StartTXPollAck
        MOV     R0, #&01                ; offset 1
        BL      TXAck
        BL      Start
    [   E2ROMSupport
        ADD     R0, R1, #1              ; read address
d822 1
a822 1
        MOV     R0, #(RTCAddress+1)     ; read address
d824 31
a854 31
        BL      TXAck
        BL      RXByte
        BL      BCDToHex
        MOV     R8, R0                  ; centiseconds
        BL      CD0RBTH
        MOV     R7, R0                  ; seconds
        BL      CD0RBTH
        MOV     R1, R0                  ; minutes
        BL      CD0RBTH
        MOV     R4, R0                  ; hours
        BL      ClockData0
        BL      RXByte
        AND     R0, R0, #&3F            ; day of month (clear year bits)
        BL      BCDToHex
        MOV     R2, R0
        BL      ClockData0
        BL      RXByte
        AND     R0, R0, #&1F            ; month (clear day of week bits)
        BL      BCDToHex
        MOV     R3, R0
        MOV     R0, #1
        BL      ClockData
        BL      Stop

        MOV     R0, #YearCMOS
        BL      Read
        MOV     R5, R0                  ; year (lo)

        MOV     R0, #YearCMOS+1
        BL      Read
        MOV     R6, R0                  ; year (hi)
d856 1
a856 1
        MOV     R0, R4                  ; put hours in R0
d859 7
a865 7
                                        ; LRust, fix RP-0370
        TEQ     R2, #0                  ; Valid day?
        MOVEQ   R2, #1                  ; No then force 1st
        TEQ     R3, #0                  ; Invalid month?
        MOVEQ   R3, #1                  ; Yes then force Jan

        Pull    "R4, PC"
d869 1
a869 1
;       InitCMOSCache - Initialise cache of CMOS RAM
d871 1
d873 2
a874 2
InitCMOSCache   ENTRY "r0-r3"
    [   E2ROMSupport
d876 10
a885 10
;       First determine what hardware we've got fitted, R3 holds the number of
;       256 byte blocks that we've found
        
        ; Have we got an RTC ?
        MOV     R0, #RTCAddress
        BL      DummyAccess
        MOVVS   R3, #0
        MOVVC   R3, #1
        MOV     R2, #i2cWorkSpace
        STRB    R3, [R2, #RTCFitted]
d888 4
a891 4
        MOV     r0, #(E2ROMAddress+6)
        BL      DummyAccess
        ADDVC   R3, R3, #4
        BVC     %FT5
d894 4
a897 4
        MOV     r0, #(E2ROMAddress+2)
        BL      DummyAccess
        ADDVC   R3, R3, #4
        BVC     %FT5
d900 11
a910 11
        MOV     r0, #(E2ROMAddress)
        BL      DummyAccess
        ADDVC   R3, R3, #1

        ; Set the NVRam count
5       STRB    R3, [R2, #NVRamSize]

        ; Initialise the cache
        MOV     R0, #&10
        BL      GetI2CAddress           ; convert to device address and offset
        MOV     R2, R0                  ; save the offset
d912 2
a913 2
        MOV     R1, #RTCAddress
        MOV     R2, #&10
d915 1
a915 1
        ADR     R3, CMOSRAMCache-16
d917 2
a918 2
    [   :DEF: TestHarness
        ADD     R3, R3, #i2cWorkSpace
d920 1
a920 1
        BL      Start
d922 2
a923 2
        MOV     R0, R1                  ; write address
        BL      TXAck
d925 2
a926 2
        MOV     R0, R2                  ; memory word address
        BL      TXAck
d928 1
a928 1
        BL      Start
d930 2
a931 2
        ADD     R0, R1, #1              ; read address
        BL      TXAck
d934 9
a942 9
        BL      RXByte                  ; returned in R0
        STRB    R0, [R3, R2]
        ADD     R2, R2, #1              ; increment R2 to phys. address
        CMP     R2, #&100
        BEQ     %FT20

        MOV     R0, #0                  ; not done .. ACK that byte
        BL      ClockData
        B       %BT10                   ; .. and continue reading
d944 4
a947 4
        MOV     R0, #1                  ; finish off reading block
        BL      ClockData
        BL      Stop
        EXIT
d949 1
d954 2
a955 2
;       DummyAccess - do a dummy access of the specified device to find out
;                     if it is present
d957 1
a957 1
; in:   R0 = Write address of device
d959 3
a961 3
; out:  All registers preserved
;       V=0 => device is present
;       V=1 => device is not present
d966 1
a966 1
DummyAccess     ENTRY
d968 4
a971 4
        BL      Start
        BL      TXAck                   ; do write and set V if no ack 
        BL      Stop                    ; Doesn't change the PSR
        EXIT                            ; Exit with V set appropriately
d974 1
a974 1
        END
@


4.2.2.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d415 1
a415 1

d426 1
d451 1
d457 1
d598 1
d661 1
d673 2
d682 1
a951 350


; *****************************************************************************

;
; Code for Serial Presence Detect (SPD) on SDRAM  (Phoebe)
;
; code cannot use any RAM, and must work with MMU off, in 32-bit mode
;
; To read a byte of the EEPROM, call:
;   first SPD_PreRead with R0 containing the I2C address of the eeprom.
;   then  SPD_Read with R0 containing the byte to read and r1 the I2C address.
;
; Register corruption:
;   SPD_PreRead - r0 r1 r2 r3 r4 r5 r6       r9 r10 r11 r12
;   SPD_Read    - r0 r1 r2 r3 r4 r5 r6    r8 r9 r10 r11 r12
;
;   Start       - r0 r1 r2 r3                       r11 r12
;   TXByte      - r0 r1 r2 r3 r4 r5 r6          r10 r11 r12
;   RXByte      -    r1 r2 r3 r4 r5                 r11 r12
;   CheckAck    - r0 r1 r2 r3 r4                    r11 r12
;   Stop        - r0 r1 r2 r3                       r11 r12
;   ClockData   -    r1    r3    r5 r6          r10 r11


; *****************************************************************************
; SPD_PreRead - Call before each attempt to read a byte
;
;  In: r0 = Address of slave I2C device
;
; Out: Corrupts - r0, r1, r2, r3, r4, r5, r6, r9, r10, r11, r12
;      VS = No acknowledge from I2C device
;      VC = Okay.
;

SPD_PreRead

         MOV    r9, lr
         
         MOV    r4, r0
         BL     SPD_Start             ; Start
         MOV    r0, r4                ; slave address is in r8
         BL     SPD_TXByte
         BL     SPD_CheckAck          ; Ack

         MOV    pc, r9


; *****************************************************************************
; SPD_ReadValue - read a byte from the EEPROM
;
;  In: r0 = byte to read ('word address')
;      r1 = slave address
;
; Out: r0 = value
;      Corrupts - r0, r1, r2, r3, r4, r5, r6, r8, r9, r10, r11, r12
;

SPD_ReadValue

         MOV    r9, lr                ; store lr
         MOV    r8, r1                ; store slave address

         BL     SPD_TXByte            ; transmit word address (entered in r0)
         BL     SPD_CheckAck          ; Ack

         BL     SPD_Start             ; Start
         MOV    r0, r8                ; r8 contains slave address
         ADD    r0, r0, #1            ; Set bit 0 for read         
         BL     SPD_TXByte            ; Slave address
         BL     SPD_CheckAck          ; Ack

         BL     SPD_RXByte            ; Data
         MOV    r8, r0                ; store received byte in r8

         MOV    r0, #1                ; Last byte, then don't acknowledge
         BL     SPD_ClockData         ; but always send ack clock pulse
         
         BL     SPD_Stop              ; Stop

         MOV    r0, r8                ; return value in r0
         MOV    pc, r9

         
; *****************************************************************************
;
; SPD_Start - Send the Start signal
;
; Out: Corrupted - r0, r1, r2, r3, r11, r12
;

SPD_Start ROUT

        MOV     r12, lr                 ; r12 is link register

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SPD_SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SPD_SetC1C0

; Hold start condition for BMU

        MOV     R2, #IOC
        MOV     R0,#10
        BL      SPD_DoMicroDelay

; Delay here must be >= 4.7 microsecs

        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
        BL      SPD_SetC1C0

        MOV     pc, r12                 ; return address is in r12


; *****************************************************************************
;
; SPD_Stop - Send the Stop signal
;
; Out: Corrupted - r0, r1, r2, r3, r11, r12
;

SPD_Stop ROUT

        MOV     r12, lr                 ; r12 contains link register

        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SPD_SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SPD_SetC1C0

        MOV     pc, r12                 ; return address is in r12


; *****************************************************************************
;
; SPD_CheckAck - Check acknowledge after transmitting a byte
;
; Out: V=0 => acknowledge received
;      V=1 => no acknowledge received
;      Corrupted - r0, r1, r2, r3, r4, r11, r12

SPD_CheckAck ROUT

        MOV     r12, lr                 ; r12 is link register

        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        BL      SPD_SetC1C0

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SPD_SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R2, #IOC
        LDRB    R4, [R2, #IOCControl]   ; get the data from IOC

        MOV     R0, #0
        MOV     R1, #0                  ; clock lo
        BL      SPD_SetC1C0

        CLRV
        TST     R4, #1                  ; should be LO for correct acknowledge
        SETV    NE

        MOV     pc, r12                 ; r12 contains return address


; *****************************************************************************
;
; SPD_SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
;
;  In: r0 = data line value (0 or 1)
;      r1 = clock line value (0 or 1)
;
; Out: Corrupted - r0, r1, r2, r3, r11
;

SPD_SetC1C0 ROUT

        MOV     r11, r14                ; r11 is link register
                
        ADD     R0, R0, R1, LSL #1      ; R0 := C0 + C1*2

        MOV     R2, #0                          ; prepare to index soft copy
        MOV     r1, #0
        BIC     R1, R1, #&03                    ; clear clock and data
        ORR     R0, R1, R0                      ; put in new clock and data
        ORR     R0, R0, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        MOV     R2, #IOC
        STRB    R0, [R2, #IOCControl]

        MOV     R0, #10                 ; delay for >= 10/2 microsecs
        BL      SPD_DoMicroDelay

        MOV     pc, r11


; *****************************************************************************
;
; SPD_DoMicroDelay - Delay for >= R0/2 microseconds
;
;  In: R0 = time delay in 1/2 microsecond units
;      R2 -> IOC
;      On ARM600, we may or may not be in a 32-bit mode
;
; Out: Corrupted - r0, r1, r3
;

SPD_DoMicroDelay ROUT

        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R3, [R2, #Timer0CL]     ; R3 := low output latch
        TEQ     R3, R1                  ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R3                  ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

        MOV     pc, lr                  ; return address is in r3


; *****************************************************************************
;
; SPD_TXByte - Transmit a byte
;
;  In: R0 = byte to be transmitted
;
; Out: Corrupted - r0, r1, r2, r3, r4, r5, r6, r10, r11, r12
;

SPD_TXByte ROUT

        MOV     r12, lr                 ; r12 is link register

        MOV     R2, R0                  ; byte goes into R2
        MOV     R4, #&80                ; 2^7 the bit mask
10
        ANDS    R0, R2, R4              ; zero if bit is zero
        MOVNE   R0, #1
        BL      SPD_ClockData           ; send the bit
        MOVS    R4, R4, LSR #1
        BNE     %BT10

        MOV     pc, r12


; *****************************************************************************
;
; SPD_ClockData - Clock a bit of data down the IIC bus
;
;  In: R0 = data bit
;
; Out: Corrupted - r1, r3, r5, r6, r10, r11
;      Preserved - r0, r2

SPD_ClockData ROUT

        MOV     r10, lr                 ; r10 is link register
        MOV     r5, r0                  ; preserve r0 in r5
        MOV     r6, r2                  ; preserve r2 in r6

        MOV     R1, #0                  ; Clock lo
        BL      SPD_SetC1C0

        MOV     r0, r5
        MOV     R1, #1                  ; Clock hi
        BL      SPD_SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     r0, r5
        MOV     R1, #0                  ; Clock lo
        BL      SPD_SetC1C0

        MOV     r0, r5                  ; restore r0
        MOV     r2, r6                  ; restore r2

        MOV     pc, r10

; *****************************************************************************
;
; SPD_RXByte - Receive a byte
;
; Out: R0 = byte received
;      Corrupted - r1, r2, r3, r4, r5, r11, r12
;

SPD_RXByte ROUT

        MOV     r12, lr                 ; r12 contains link register
        
        MOV     R3, #0                  ; byte:=0
        MOV     R2, #IOC
        MOV     R4, #7

        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        MOV     r5, r3
        BL      SPD_SetC1C0
        MOV     r3, r5
10
        MOV     R0, #1                  ; pulse clock HI
        MOV     R1, #1

        MOV     r5, r3
        BL      SPD_SetC1C0

        ; Wait for high clock bit
20      LDRB    r0, [r2, #IOCControl]
        TST     r0, #i2c_clock_bit
        BEQ     %BT20
        
        MOV     r0, #10
        BL      SPD_DoMicroDelay
        MOV     r3, r5

        LDRB    R1, [R2, #IOCControl]   ; get the data from IOC
        AND     R1, R1, #1
        ADD     R3, R1, R3, LSL #1      ; byte:=byte*2+(IOC?0)AND1

        MOV     R0, #1                  ; return clock LO
        MOV     R1, #0
        MOV     r5, r3
        BL      SPD_SetC1C0
        MOV     r3, r5

        SUBS    R4, R4, #1
        BCS     %BT10

        MOV     R0, R3                  ; return the result in R0

        MOV     pc, r12                 ; r12 contains return address

@


4.2.2.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d415 1
a415 1

d426 1
d451 1
d457 1
d598 1
d661 1
d673 2
d682 1
a951 350


; *****************************************************************************

;
; Code for Serial Presence Detect (SPD) on SDRAM  (Phoebe)
;
; code cannot use any RAM, and must work with MMU off, in 32-bit mode
;
; To read a byte of the EEPROM, call:
;   first SPD_PreRead with R0 containing the I2C address of the eeprom.
;   then  SPD_Read with R0 containing the byte to read and r1 the I2C address.
;
; Register corruption:
;   SPD_PreRead - r0 r1 r2 r3 r4 r5 r6       r9 r10 r11 r12
;   SPD_Read    - r0 r1 r2 r3 r4 r5 r6    r8 r9 r10 r11 r12
;
;   Start       - r0 r1 r2 r3                       r11 r12
;   TXByte      - r0 r1 r2 r3 r4 r5 r6          r10 r11 r12
;   RXByte      -    r1 r2 r3 r4 r5                 r11 r12
;   CheckAck    - r0 r1 r2 r3 r4                    r11 r12
;   Stop        - r0 r1 r2 r3                       r11 r12
;   ClockData   -    r1    r3    r5 r6          r10 r11


; *****************************************************************************
; SPD_PreRead - Call before each attempt to read a byte
;
;  In: r0 = Address of slave I2C device
;
; Out: Corrupts - r0, r1, r2, r3, r4, r5, r6, r9, r10, r11, r12
;      VS = No acknowledge from I2C device
;      VC = Okay.
;

SPD_PreRead

         MOV    r9, lr
         
         MOV    r4, r0
         BL     SPD_Start             ; Start
         MOV    r0, r4                ; slave address is in r8
         BL     SPD_TXByte
         BL     SPD_CheckAck          ; Ack

         MOV    pc, r9


; *****************************************************************************
; SPD_ReadValue - read a byte from the EEPROM
;
;  In: r0 = byte to read ('word address')
;      r1 = slave address
;
; Out: r0 = value
;      Corrupts - r0, r1, r2, r3, r4, r5, r6, r8, r9, r10, r11, r12
;

SPD_ReadValue

         MOV    r9, lr                ; store lr
         MOV    r8, r1                ; store slave address

         BL     SPD_TXByte            ; transmit word address (entered in r0)
         BL     SPD_CheckAck          ; Ack

         BL     SPD_Start             ; Start
         MOV    r0, r8                ; r8 contains slave address
         ADD    r0, r0, #1            ; Set bit 0 for read         
         BL     SPD_TXByte            ; Slave address
         BL     SPD_CheckAck          ; Ack

         BL     SPD_RXByte            ; Data
         MOV    r8, r0                ; store received byte in r8

         MOV    r0, #1                ; Last byte, then don't acknowledge
         BL     SPD_ClockData         ; but always send ack clock pulse
         
         BL     SPD_Stop              ; Stop

         MOV    r0, r8                ; return value in r0
         MOV    pc, r9

         
; *****************************************************************************
;
; SPD_Start - Send the Start signal
;
; Out: Corrupted - r0, r1, r2, r3, r11, r12
;

SPD_Start ROUT

        MOV     r12, lr                 ; r12 is link register

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SPD_SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SPD_SetC1C0

; Hold start condition for BMU

        MOV     R2, #IOC
        MOV     R0,#10
        BL      SPD_DoMicroDelay

; Delay here must be >= 4.7 microsecs

        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
        BL      SPD_SetC1C0

        MOV     pc, r12                 ; return address is in r12


; *****************************************************************************
;
; SPD_Stop - Send the Stop signal
;
; Out: Corrupted - r0, r1, r2, r3, r11, r12
;

SPD_Stop ROUT

        MOV     r12, lr                 ; r12 contains link register

        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SPD_SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SPD_SetC1C0

        MOV     pc, r12                 ; return address is in r12


; *****************************************************************************
;
; SPD_CheckAck - Check acknowledge after transmitting a byte
;
; Out: V=0 => acknowledge received
;      V=1 => no acknowledge received
;      Corrupted - r0, r1, r2, r3, r4, r11, r12

SPD_CheckAck ROUT

        MOV     r12, lr                 ; r12 is link register

        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        BL      SPD_SetC1C0

        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SPD_SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R2, #IOC
        LDRB    R4, [R2, #IOCControl]   ; get the data from IOC

        MOV     R0, #0
        MOV     R1, #0                  ; clock lo
        BL      SPD_SetC1C0

        CLRV
        TST     R4, #1                  ; should be LO for correct acknowledge
        SETV    NE

        MOV     pc, r12                 ; r12 contains return address


; *****************************************************************************
;
; SPD_SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
;
;  In: r0 = data line value (0 or 1)
;      r1 = clock line value (0 or 1)
;
; Out: Corrupted - r0, r1, r2, r3, r11
;

SPD_SetC1C0 ROUT

        MOV     r11, r14                ; r11 is link register
                
        ADD     R0, R0, R1, LSL #1      ; R0 := C0 + C1*2

        MOV     R2, #0                          ; prepare to index soft copy
        MOV     r1, #0
        BIC     R1, R1, #&03                    ; clear clock and data
        ORR     R0, R1, R0                      ; put in new clock and data
        ORR     R0, R0, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        MOV     R2, #IOC
        STRB    R0, [R2, #IOCControl]

        MOV     R0, #10                 ; delay for >= 10/2 microsecs
        BL      SPD_DoMicroDelay

        MOV     pc, r11


; *****************************************************************************
;
; SPD_DoMicroDelay - Delay for >= R0/2 microseconds
;
;  In: R0 = time delay in 1/2 microsecond units
;      R2 -> IOC
;      On ARM600, we may or may not be in a 32-bit mode
;
; Out: Corrupted - r0, r1, r3
;

SPD_DoMicroDelay ROUT

        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R3, [R2, #Timer0CL]     ; R3 := low output latch
        TEQ     R3, R1                  ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R3                  ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

        MOV     pc, lr                  ; return address is in r3


; *****************************************************************************
;
; SPD_TXByte - Transmit a byte
;
;  In: R0 = byte to be transmitted
;
; Out: Corrupted - r0, r1, r2, r3, r4, r5, r6, r10, r11, r12
;

SPD_TXByte ROUT

        MOV     r12, lr                 ; r12 is link register

        MOV     R2, R0                  ; byte goes into R2
        MOV     R4, #&80                ; 2^7 the bit mask
10
        ANDS    R0, R2, R4              ; zero if bit is zero
        MOVNE   R0, #1
        BL      SPD_ClockData           ; send the bit
        MOVS    R4, R4, LSR #1
        BNE     %BT10

        MOV     pc, r12


; *****************************************************************************
;
; SPD_ClockData - Clock a bit of data down the IIC bus
;
;  In: R0 = data bit
;
; Out: Corrupted - r1, r3, r5, r6, r10, r11
;      Preserved - r0, r2

SPD_ClockData ROUT

        MOV     r10, lr                 ; r10 is link register
        MOV     r5, r0                  ; preserve r0 in r5
        MOV     r6, r2                  ; preserve r2 in r6

        MOV     R1, #0                  ; Clock lo
        BL      SPD_SetC1C0

        MOV     r0, r5
        MOV     R1, #1                  ; Clock hi
        BL      SPD_SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     r0, r5
        MOV     R1, #0                  ; Clock lo
        BL      SPD_SetC1C0

        MOV     r0, r5                  ; restore r0
        MOV     r2, r6                  ; restore r2

        MOV     pc, r10

; *****************************************************************************
;
; SPD_RXByte - Receive a byte
;
; Out: R0 = byte received
;      Corrupted - r1, r2, r3, r4, r5, r11, r12
;

SPD_RXByte ROUT

        MOV     r12, lr                 ; r12 contains link register
        
        MOV     R3, #0                  ; byte:=0
        MOV     R2, #IOC
        MOV     R4, #7

        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        MOV     r5, r3
        BL      SPD_SetC1C0
        MOV     r3, r5
10
        MOV     R0, #1                  ; pulse clock HI
        MOV     R1, #1

        MOV     r5, r3
        BL      SPD_SetC1C0

        ; Wait for high clock bit
20      LDRB    r0, [r2, #IOCControl]
        TST     r0, #i2c_clock_bit
        BEQ     %BT20
        
        MOV     r0, #10
        BL      SPD_DoMicroDelay
        MOV     r3, r5

        LDRB    R1, [R2, #IOCControl]   ; get the data from IOC
        AND     R1, R1, #1
        ADD     R3, R1, R3, LSL #1      ; byte:=byte*2+(IOC?0)AND1

        MOV     R0, #1                  ; return clock LO
        MOV     R1, #0
        MOV     r5, r3
        BL      SPD_SetC1C0
        MOV     r3, r5

        SUBS    R4, R4, #1
        BCS     %BT10

        MOV     R0, R3                  ; return the result in R0

        MOV     pc, r12                 ; r12 contains return address

@


4.1
log
@Initial revision
@
text
@d19 31
a49 1
PhysChecksum    *       (((CheckSumCMOS + &30) :MOD: &F0) + &10)
d53 1
a53 1
;       HexToBCD - Convert byte in hex to BCD
d55 1
a55 1
; in:   R0 = byte in hex
d57 2
a58 2
; out:  R0 = byte in BCD (ie R0 := (R0 DIV 10)*16 + R0 MOD 10)
;       All other registers preserved
d62 5
a66 5
        Push    "R1,R2, R14"
        MOV     R1, #10
        DivRem  R2, R0, R1, R14                 ; R2=R0 DIV 10; R0=R0 MOD 10
        ADD     R0, R0, R2, LSL #4
        Pull    "R1,R2, PC"
d70 1
a70 1
;       BCDToHex - Convert byte in BCD to hex
d72 1
a72 1
; in:   R0 = byte in BCD (ie x*16 + y)
d74 2
a75 2
; out:  R0 = byte in hex (ie x*10 + y)
;       All other registers preserved
d79 5
a83 5
        Push    "R14"
        MOV     R14, R0, LSR #4         ; R14 := x
        ADD     R14, R14, R14, LSL #1   ; R14 := x*3
        SUB     R0, R0, R14, LSL #1     ; R0 := R0 - x*6 = x*10
        Pull    "PC"
d87 1
a87 1
;       SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
d89 1
a89 1
; out:  All registers preserved, including PSR
d93 2
a94 2
        Push    "R0-R2,R14"
        ADD     R0, R0, R1, LSL #1              ; R0 := C0 + C1*2
d96 11
a106 11
        [ AssemblingArthur :LOR: Module
        MOV     R2, #0                          ; prepare to index soft copy
        LDRB    R1, [R2, #IOCControlSoftCopy]   ; read soft copy
        BIC     R1, R1, #&03                    ; clear clock and data
        ORR     R0, R1, R0                      ; put in new clock and data
        ORR     R0, R0, #&C0                    ; make sure two test bits are
                                                ; always set to 1 !
        STRB    R0, [R2, #IOCControlSoftCopy]   ; store back to soft copy
        |
        ORR     R0, R0, #&FC                    ; set other bits to 1
        ]
d108 2
a109 2
        MOV     R2, #IOC
        STRB    R0, [R2, #IOCControl]
d111 2
a112 2
        MOV     R0, #10                         ; delay for >= 10/2 microsecs
        BL      DoMicroDelay
d114 1
a114 1
        Pull    "R0-R2,PC",,^
d118 1
a118 1
;       DoMicroDelay - Delay for >= R0/2 microseconds
d120 3
a122 3
; in:   R0 = time delay in 1/2 microsecond units
;       R2 -> IOC
;       On ARM600, we may or may not be in a 32-bit mode
d124 1
a124 1
; out:  R0,R1 corrupted
d128 1
a128 1
        Push    R14
d130 2
a131 2
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
d133 7
a139 7
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R14, [R2, #Timer0CL]    ; R14 := low output latch
        TEQ     R14, R1                 ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, R14                 ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished
d141 1
a141 1
        Pull    PC
d143 1
a143 1
        LTORG
d147 1
a147 1
;       ClockData - Clock a bit of data down the IIC bus
d149 1
a149 1
; in:   R0 = data bit
d151 1
a151 1
; out:  All registers preserved, including PSR
d155 1
a155 1
        Push    "R1, R14"
d157 2
a158 2
        MOV     R1, #0                  ; Clock lo
        BL      SetC1C0
d164 3
a166 3
        MOV     R1,PC
        ORR     R1,R1,#I_bit
        TEQP    PC,R1
d168 2
a169 2
        MOV     R1, #1                  ; Clock hi
        BL      SetC1C0
d173 2
a174 2
        MOV     R1, #0                  ; Clock lo
        BL      SetC1C0
d176 1
a176 1
        Pull    "R1, PC",,^
d178 5
a182 5
ClockData0 ROUT                                 ; Clock a zero bit
        Push    "R0, R14"
        MOV     R0, #0
        BL      ClockData
        Pull    "R0, PC",,^
d186 1
a186 1
;       Start - Send the Start signal
d188 1
a188 1
; out:  All registers preserved, including PSR
d191 2
a192 2
Start   ROUT
        Push    "R0-R2,R14"
d194 3
a196 3
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SetC1C0
d200 3
a202 3
        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SetC1C0
d207 3
a209 3
        MOV     R2, #IOC
        MOV     R0,#10
        BL      DoMicroDelay
d214 3
a216 3
        MOV     R0, #0                  ; clock LO, data LO
        MOV     R1, #0
        BL      SetC1C0
d218 1
a218 1
        Pull    "R0-R2,PC",,^
d222 1
a222 1
;       Acknowledge - Check acknowledge after transmitting a byte
d224 3
a226 3
; out:  All registers preserved
;       V=0 => acknowledge received
;       V=1 => no acknowledge received
d230 1
a230 1
        Push    "R0-R2,R14"
d232 3
a234 3
        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        BL      SetC1C0
d240 8
a247 8
        MOV     R1,PC
        Push    "R1"
        ORR     R1,R1,#I_bit
        TEQP    PC,R1
 ]
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SetC1C0
d251 2
a252 2
        MOV     R2, #IOC
        LDRB    R2, [R2, #IOCControl]   ; get the data from IOC
d254 3
a256 3
        MOV     R0, #0
        MOV     R1, #0                  ; clock lo
        BL      SetC1C0
d259 2
a260 2
        Pull    "R1"
        TEQP    PC,R1
d263 5
a267 5
        TST     R2, #1                  ; should be LO for correct acknowledge
        MOV     R2, PC
        BICEQ   R2, R2, #V_bit          ; clear V if correct acknowledge
        ORRNE   R2, R2, #V_bit          ; set V if no acknowledge
        TEQP    R2, #0
d269 1
a269 1
        Pull    "R0-R2,PC"
d273 1
a273 1
;       Stop - Send the Stop signal
d275 1
a275 1
; out:  All registers preserved, including PSR
d278 2
a279 2
Stop    ROUT
        Push    "R0,R1,R14"
d281 3
a283 3
        MOV     R0, #0                  ; clock HI, data LO
        MOV     R1, #1
        BL      SetC1C0
d287 14
a300 3
        MOV     R0, #1                  ; clock HI, data HI
        MOV     R1, #1
        BL      SetC1C0
d302 11
a312 1
        Pull    "R0,R1,PC",,^
d316 4
a319 1
;       TXByte - Transmit a byte
d321 1
a321 1
; in:   R0 = byte to be transmitted
d323 1
a323 1
; out:  All registers preserved, including PSR
d326 3
a328 4
TXByte  ROUT
        Push    "R0-R2,R14"
        MOV     R2, R0                  ; byte goes into R2
        MOV     R1, #&80                ; 2^7   the bit mask
d330 12
a341 6
        ANDS    R0, R2, R1              ; zero if bit is zero
        MOVNE   R0, #1
        BL      ClockData               ; send the bit
        MOVS    R1, R1, LSR #1
        BNE     %BT10
        Pull    "R0-R2,PC",,^
d345 1
a345 1
;       RXByte - Receive a byte
d347 2
a348 2
; out:  R0 = byte received
;       All other registers preserved, including PSR
d351 5
a355 5
RXByte  ROUT
        Push    "R1-R4, R14"
        MOV     R3, #0                  ; byte:=0
        MOV     R2, #IOC
        MOV     R4, #7
d357 3
a359 3
        MOV     R0, #1                  ; clock LO, data HI
        MOV     R1, #0
        BL      SetC1C0
d365 16
a380 16
        MOV     R1,PC
        Push    "R1"
        ORR     R1,R1,#I_bit
        TEQP    PC,R1
 ]
        MOV     R0, #1                  ; pulse clock HI
        MOV     R1, #1
        BL      SetC1C0

        LDRB    R1, [R2, #IOCControl]   ; get the data from IOC
        AND     R1, R1, #1
        ADD     R3, R1, R3, LSL #1      ; byte:=byte*2+(IOC?0)AND1

        MOV     R0, #1                  ; return clock LO
        MOV     R1, #0
        BL      SetC1C0
d383 2
a384 2
        Pull    "R1"
        TEQP    PC,R1
d386 19
a404 2
        SUBS    R4, R4, #1
        BCS     %BT10
d406 6
a411 2
        MOV     R0, R3                  ; return the result in R0
        Pull    "R1-R4, PC",,^
d415 1
a415 1
;       Write - Write a byte of CMOS RAM specified by logical address
d417 2
a418 2
; in:   R0 = address in CMOS RAM
;       R1 = data
d420 1
a420 1
; out:  All registers preserved
d423 4
a426 4
Write   ROUT
        Push    "R0-R4, R14"
        BL      MangleCMOSAddress
        Pull    "R0-R4, PC", CS        ; if invalid, then exit
d428 9
a436 9
        MOV     R2, R0
        MOV     R3, R1
    [ ChecksumCMOS
        BL      ReadStraight            ; calculate new checksum :
        MOV     R4, R0
        MOV     R0, #PhysChecksum
        BL      ReadStraight
        SUB     R0, R0, R4              ; = oldsum - oldcontents
        ADD     R4, R0, R3              ;          + newcontents
d438 4
a441 4
        AND     R4, R4, #&FF
        CMPS    R2, #PhysChecksum       ; don't write new checksum ...
        ORREQ   R4, R4, #&100           ; if checksum is being written
    ]
d444 12
a455 2
        ADR     R0, CMOSRAMCache-16     ; update cache, but always write to
        STRB    R3, [R0, R2]            ; real hardware as well
a456 1
        BL      Start
d458 2
a459 2
        MOV     R0, #&A0
        BL      TXAck
d461 15
a475 15
        MOV     R0, R2                  ; address
        BL      TXAck

        MOV     R0, R3                  ; data
        BL      TXAck

        BL      Stop
    [ ChecksumCMOS
        TST     R4, #&100               ; loop again to write new checksum
        MOV     R3, R4
        MOV     R2, #PhysChecksum
        ORR     R4, R4, #&100           ; but ensure it only happens once
        BEQ     %BT10
    ]
        Pull    "R0-R4, PC"
d479 2
a480 2
;       Read - Read a byte of CMOS RAM specified by logical address
;       ReadStraight - Read a byte of CMOS RAM specified by physical address
d482 1
a482 1
; in:   R0 = address in CMOS RAM
d484 2
a485 2
; out:  R0 = data (illegal address return 0)
;       All other registers preserved
d489 2
a490 2
        Push    "R1,R2,R14"
        B       %FT10
d493 4
a496 4
        Push    "R1,R2,R14"
        BL      MangleCMOSAddress
        MOVCS   R0, #0          ; pretend illegal addresses contain 0
        Pull    "R1,R2,PC", CS
d498 8
a505 8
 [ CacheCMOSRAM
        TEQ     R0, #&40                ; is it Econet station number
        BEQ     %FT15                   ; if so then don't use cache
  [ {FALSE}                             ; CMOS read debugging
        MOV     R1, #0
        LDR     R1, [R1]                ; if !0 < &100 then it's a handle to bput to
        CMP     R1, #&100
        SWICC   XOS_BPut
d507 2
a508 4
        CMP     R0, #&10                ; only cache values &10..&3F,&41..&FF
        ADRCS   R2, CMOSRAMCache-&10    ; if in range
        LDRCSB  R0, [R2, R0]            ; read from cache
        Pull    "R1,R2,PC", CS          ; and exit
d512 1
a512 1
 ]
d514 5
a518 1
        MOV     R2,R0           ; save the address
d520 3
a522 1
        BL      Start
d524 2
a525 2
        MOV     R0, #&A0
        BL      TXAck
d527 1
a527 2
        MOV     R0, R2          ; address
        BL      TXAck
d529 2
a530 1
        BL      Start
d532 2
a533 2
        MOV     R0, #&A1
        BL      TXAck
d535 2
a536 2
        BL      RXByte          ; returned in R0
        MOV     R2, R0          ; copy to R2 for now
d538 1
a538 2
        MOV     R0, #1
        BL      ClockData
d540 1
a540 1
        BL      Stop
d542 1
a542 3
        MOV     R0, R2          ; return the result

        Pull    "R1,R2,PC"
d546 2
a547 1
;       MangleCMOSAddress - Convert from logical to physical CMOS address
d549 1
a549 1
; in:   R0 = logical address (&00..&FF)
d551 1
a551 2
; out:  C=0 => valid logical address (ie &00..&EF)
;       R0 = physical address (&40..&FF,&10..&3F)
d553 4
a556 2
;       C=1 => invalid logical address (ie &F0..&FF)
;       R0 preserved
d558 18
a576 7
MangleCMOSAddress ROUT
        CMP     R0, #&F0
        ORRCSS  PC, R14, #C_bit         ; indicate invalid
        ADD     R0, R0, #&40            ; now in range &40..&13F
        CMP     R0, #&100
        SUBCS   R0, R0, #(&100-&10)     ; now in range &40..&FF, &10..&3F
        BICS    PC, R14, #C_bit         ; indicate valid
d579 13
d593 3
a595 11
HTBTA   ROUT
        Push    R14
        BL      HexToBCD
        BL      TXAck
        Pull    PC

TXAck   ROUT
        Push    R14
        BL      TXByte
        BL      Acknowledge
        Pull    PC
d597 4
a600 6
CD0RBTH ROUT
        Push    R14
        BL      ClockData0
        BL      RXByte
        BL      BCDToHex
        Pull    PC
d602 1
d605 2
a606 1
;       ValChecksum - test to see if the CMOS checksum is OK
d610 1
a610 1
; in:   none
d612 3
a614 3
; out:  R0 = calculated checksum
;       Z    set if checksum is valid
;       All other registers preserved
d617 1
a617 1
    [ ChecksumCMOS
d619 1
a619 2
ValChecksum     ROUT
        Push    "R1,R2,R3,R14"
d621 9
a629 4
        MOV     R2, #&40
        MOV     R3, #CMOSxseed
;
; Write a memory word address to the 8583
d631 5
a635 1
        BL      Start
d637 1
a637 2
        MOV     R0, #&A0        ; 8583 write address
        BL      TXAck
d639 2
a640 2
        MOV     R0, R2          ; memory word address
        BL      TXAck
a641 4
        BL      Start

        MOV     R0, #&A1        ; 8583 read address
        BL      TXAck
d643 1
a643 1
; Read data from the 8583 from locations &40 through &FF, then
d648 12
a659 2
        BL      RXByte          ; returned in R0
        ADD     R3, R3, R0      ; accumulate into R3
a660 9
        ADD     R2, R2, #1      ; increment R2 to phys. address
        TST     R2, #&100       ; limit, or until checksum.
        BNE     %30
        CMPS    R2, #PhysChecksum
        BEQ     %30

        MOV     R0, #0          ; not done .. ACK that byte
        BL      ClockData
        B       %BT20           ; .. and continue reading
d662 7
a668 6
        MOV     R0, #1          ; finish off reading block
        BL      ClockData
        BL      Stop
        TST     R2, #&100       ; either go back for bytes 10 - 3f
        MOVNE   R2, #&10        ; or finish up completely.
        BNE     %BT10
d673 5
a677 5
        MOV     R0, #PhysChecksum
        BL      ReadStraight
        AND     R2, R0, #&FF    ; value from checksum location
        AND     R0, R3, #&FF    ; calculated value into R0
        CMPS    R0, R2
d679 2
a680 2
        Pull    "R1,R2,R3,PC"
    ]                                 
d684 1
a684 1
;       MakeChecksum - calculate and write a correct checksum
d686 1
a686 1
; in:   none
d688 2
a689 2
; out:  R0 = calculated checksum
;       All other registers preserved
d692 1
a692 1
    [ ChecksumCMOS
d694 8
a701 8
MakeChecksum    ROUT
        Push    R14
        BL      ValChecksum
        MOV     R1, R0
        MOV     R0, #CheckSumCMOS
        BL      Write
        Pull    PC
    ]
d705 1
a705 1
;       SetTime - Write the CMOS clock time
d707 9
a715 8
; in:   R0 = hours
;       R1 = minutes
;       R2 = day of month
;       R3 = month
;       R5 = year (lo)
;       R6 = year (hi)
;       R7 = seconds
;       R8 = centiseconds
d717 1
a717 1
;       Any of the above, if -1, will not be written to
d721 1
a721 1
        Push    "R4, R14"               ; save registers
d723 1
a723 21
        [ :LNOT: NewClockChip
        CMP     R1, #-1                 ; test if setting mins
        BEQ     %FT10                   ; [no, then skip]

        Push    R0
        MOV     R7, #0                  ; zero seconds and centiseconds
        MOV     R8, #0
        STRB    R8, CentiTime
        STRB    R7, SecondsTime
        STRB    R7, SecondsDirty        ; seconds are in sync now

        BL      Start
        MOV     R0, #&D0
        BL      TXAck
        MOV     R0, #&20                ; zero the seconds on the chip
        BL      TXAck
        BL      Stop
        Pull    R0
10
        CMP     R3, #-1                 ; test if setting months
        BEQ     %FT20                   ; [no, then skip]
d725 1
a725 14
        Push    "R0,R1"
        MOV     R1, R3
        MOV     R0, #MonthCMOS
        BL      Write                   ; remember last updated months

        CMP     R3, #2                  ; if Jan
        CMPEQ   R2, #28                 ; or Feb 1..28
        MOVLS   R1, #0                  ; not had 29th of Feb
        MOVHI   R1, #1                  ; have had 29th of Feb
        MOV     R0, #LeapCMOS
        BL      Write                   ; set 29thFeb flag
        Pull    "R0,R1"
20
        ]
d727 32
a758 1
; write year to CMOS RAM
a759 40
        Push    "R0,R1"
        MOVS    R1, R5
        MOVPL   R0, #YearCMOS
        BLPL    Write
        MOVS    R1, R6
        MOVPL   R0, #YearCMOS+1
        BLPL    Write
        Pull    "R0,R1"

        MOV     R4, R0                  ; save hours in R4
        CMP     R4, #-1                 ; are we writing time ?
        BEQ     %FT30                   ; [no, then skip]

        [ NewClockChip
        BL      Start
        MOV     R0, #&A0
        BL      TXAck
        MOV     R0, #1                  ; start at address 1
        BL      TXAck
        MOV     R0, R8                  ; centiseconds
        BL      HTBTA
        MOV     R0, R7                  ; seconds
        BL      HTBTA
        MOV     R0, R1                  ; minutes
        BL      HTBTA
        MOV     R0, R4                  ; hours
        BL      HTBTA
        BL      Stop
        |
        BL      Start
        MOV     R0, #&D0
        BL      TXAck
        MOV     R0, #0                  ; start at address 0
        BL      TXAck
        MOV     R0, R4                  ; hours
        BL      HTBTA
        MOV     R0, R1                  ; minutes
        BL      HTBTA
        BL      Stop
        ]
d761 20
a780 2
        CMP     R2, #-1                 ; are we writing date ?
        BEQ     %FT40                   ; [no, then skip]
a781 25
        [ NewClockChip
        BL      Start
        MOV     R0, #&A0
        BL      TXAck
        MOV     R0, #5                  ; start at address 5
        BL      TXAck
        MOV     R0, R2                  ; day of month
        BL      HexToBCD
        ORR     R0, R0, R5, LSL #6      ; year in bits 6,7; day in bits 0..5
        BL      TXAck
        MOV     R0, R3                  ; months
        BL      HTBTA
        BL      Stop
        |
        BL      Start
        MOV     R0, #&D0
        BL      TXAck
        MOV     R0, #2                  ; start at address 2
        BL      TXAck
        MOV     R0, R2                  ; days
        BL      HTBTA
        MOV     R0, R3                  ; months
        BL      HTBTA
        BL      Stop
        ]
d783 5
a787 4
        MOV     R0, R4                  ; put hours back in R0
        BL      RTCToRealTime

        Pull    "R4, PC"
d791 1
a791 1
;       ReadTime - Read the CMOS clock time
d793 1
a793 1
; in:   -
d795 8
a802 8
; out:  R0 = hours
;       R1 = minutes
;       R2 = days
;       R3 = months
;       R5 = year (lo)
;       R6 = year (hi)
;       R7 = seconds
;       R8 = centiseconds
d806 1
a806 1
        Push    "R4, R14"
d808 47
a854 63
        [ NewClockChip
        BL      Start
        MOV     R0, #&A0
        BL      TXAck
        MOV     R0, #&01                ; start at address 1
        BL      TXAck
        BL      Start
        MOV     R0, #&A1
        BL      TXAck
        BL      RXByte
        BL      BCDToHex
        MOV     R8, R0                  ; centiseconds
        BL      CD0RBTH
        MOV     R7, R0                  ; seconds
        BL      CD0RBTH
        MOV     R1, R0                  ; minutes
        BL      CD0RBTH
        MOV     R4, R0                  ; hours
        BL      ClockData0
        BL      RXByte
        AND     R0, R0, #&3F            ; day of month (clear year bits)
        BL      BCDToHex
        MOV     R2, R0
        BL      ClockData0
        BL      RXByte
        AND     R0, R0, #&1F            ; month (clear day of week bits)
        BL      BCDToHex
        MOV     R3, R0
        MOV     R0, #1
        BL      ClockData
        BL      Stop
        |
        BL      Start
        MOV     R0, #&D0
        BL      TXAck
        MOV     R0, #&00                ; start at address 0
        BL      TXAck
        BL      Start
        MOV     R0, #&D1
        BL      TXAck
        BL      RXByte
        BL      BCDToHex
        MOV     R4, R0          ; hours
        BL      CD0RBTH
        MOV     R1, R0          ; minutes
        BL      CD0RBTH
        MOV     R2, R0          ; days
        BL      CD0RBTH
        MOV     R3, R0          ; months
        MOV     R0, #1
        BL      ClockData
        BL      Stop
        LDRB    R7, SecondsTime
        LDRB    R8, CentiTime
        ]

        MOV     R0, #YearCMOS
        BL      Read
        MOV     R5, R0          ; year (lo)

        MOV     R0, #YearCMOS+1
        BL      Read
        MOV     R6, R0          ; year (hi)
d856 1
a856 1
        MOV     R0, R4          ; put hours in R0
d859 5
a863 5
 [ {TRUE}                               ; LRust, fix RP-0370
        TEQ     R2, #0                  ; Valid day?
        MOVEQ   R2, #1                  ; No then force 1st
        TEQ     R3, #0                  ; Invalid month?
        MOVEQ   R3, #1                  ; Yes then force Jan
d865 1
a865 1
        Pull    "R4, PC"
d869 1
a869 1
;       InitCMOSCache - Initialise cache of CMOS RAM
d871 1
a871 1
 [ CacheCMOSRAM
d873 43
a915 3
InitCMOSCache   ENTRY "r0-r3"
        MOV     R2, #16
        ADR     R3, CMOSRAMCache-16
d917 4
a920 1
        BL      Start
d922 2
a923 2
        MOV     R0, #&A0        ; 8583 write address
        BL      TXAck
d925 2
a926 2
        MOV     R0, R2          ; memory word address
        BL      TXAck
d928 1
a928 1
        BL      Start
d930 2
a931 2
        MOV     R0, #&A1        ; 8583 read address
        BL      TXAck
d934 9
a942 9
        BL      RXByte          ; returned in R0
        STRB    R0, [R3, R2]
        ADD     R2, R2, #1      ; increment R2 to phys. address
        CMP     R2, #&100
        BEQ     %FT20

        MOV     R0, #0          ; not done .. ACK that byte
        BL      ClockData
        B       %BT10           ; .. and continue reading
d944 7
a950 4
        MOV     R0, #1          ; finish off reading block
        BL      ClockData
        BL      Stop
        EXIT
d952 23
a974 2
 ]
        END
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d19 1
a19 29
; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Name  Description
; ----       ----  -----------
; 28-Mar-95  JRH   Added support for E2ROMs and/or CMOS, conditioned on
;                  E2ROMSupport which is defined elsewhere
;                  Uses RTCFitted and NVRamSize in KernelWS
; 03-Jul-96  JRH   Took out code conditioned on :LNOT: NewClockChip
;                  Fixed support for E2ROM. E2 works in the same gross way as
;                  CMOS. Any E2 fitted > 256 bytes will not be accessed by these
;                  routines.

PhysChecksum	*	(((CheckSumCMOS + &30) :MOD: &F0) + &10)

PollMax		*	&f	; Number of times to poll for an Ack

; Device addresses
RTCAddress	* &a0
  [	E2ROMSupport
E2ROMAddress	* &a8
  ]

; i2cWorkSpace is defined elsewhere to point somewhere sensible when debugging
  [ :LNOT: :DEF: TestHarness
i2cWorkSpace	* 0
  ]
	
d23 1
a23 1
;	HexToBCD - Convert byte in hex to BCD
d25 1
a25 1
; in:	R0 = byte in hex
d27 2
a28 2
; out:	R0 = byte in BCD (ie R0 := (R0 DIV 10)*16 + R0 MOD 10)
;	All other registers preserved
d32 5
a36 5
	Push	"R1,R2, R14"
	MOV	R1, #10
	DivRem	R2, R0, R1, R14			; R2=R0 DIV 10; R0=R0 MOD 10
	ADD	R0, R0, R2, LSL #4
	Pull	"R1,R2, PC"
d40 1
a40 1
;	BCDToHex - Convert byte in BCD to hex
d42 1
a42 1
; in:	R0 = byte in BCD (ie x*16 + y)
d44 2
a45 2
; out:	R0 = byte in hex (ie x*10 + y)
;	All other registers preserved
d49 5
a53 5
	Push	"R14"
	MOV	R14, R0, LSR #4			; R14 := x
	ADD	R14, R14, R14, LSL #1		; R14 := x*3
	SUB	R0, R0, R14, LSL #1		; R0 := R0 - x*6 = x*10
	Pull	"PC"
d57 1
a57 1
;	SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
d59 1
a59 1
; out:	All registers preserved, including PSR
d63 2
a64 2
	Push	"R0-R2,R14"
	ADD	R0, R0, R1, LSL #1	; R0 := C0 + C1*2
d66 11
a76 11
	[ AssemblingArthur :LOR: Module
	MOV	R2, #0				; prepare to index soft copy
	LDRB	R1, [R2, #IOCControlSoftCopy]	; read soft copy
	BIC	R1, R1, #&03			; clear clock and data
	ORR	R0, R1, R0			; put in new clock and data
	ORR	R0, R0, #&C0			; make sure two test bits are
						; always set to 1 !
	STRB	R0, [R2, #IOCControlSoftCopy]	; store back to soft copy
	|
	ORR	R0, R0, #&FC			; set other bits to 1
	]
d78 2
a79 2
	MOV	R2, #IOC
	STRB	R0, [R2, #IOCControl]
d81 2
a82 2
	MOV	R0, #10			; delay for >= 10/2 microsecs
	BL	DoMicroDelay
d84 1
a84 1
	Pull	"R0-R2,PC",,^
d88 1
a88 1
;	DoMicroDelay - Delay for >= R0/2 microseconds
d90 3
a92 3
; in:	R0 = time delay in 1/2 microsecond units
;	R2 -> IOC
;	On ARM600, we may or may not be in a 32-bit mode
d94 1
a94 1
; out:	R0,R1 corrupted
d98 1
a98 1
	Push	R14
d100 2
a101 2
	STRB	R0, [R2, #Timer0LR]	; copy counter into output latch
	LDRB	R1, [R2, #Timer0CL]	; R1 := low output latch
d103 7
a109 7
	STRB	R0, [R2, #Timer0LR]	; copy counter into output latch
	LDRB	R14, [R2, #Timer0CL]	; R14 := low output latch
	TEQ	R14, R1			; unchanged ?
	BEQ	%BT10			; then loop
	MOV	R1, R14			; copy anyway
	SUBS	R0, R0, #1		; decrement count
	BNE	%BT10			; loop if not finished
d111 1
a111 1
	Pull	PC
d113 1
a113 1
	LTORG
d117 1
a117 1
;	ClockData - Clock a bit of data down the IIC bus
d119 1
a119 1
; in:	R0 = data bit
d121 1
a121 1
; out:	All registers preserved, including PSR
d125 1
a125 1
	Push	"R1, R14"
d127 2
a128 2
	MOV	R1, #0			; Clock lo
	BL	SetC1C0
d134 3
a136 3
	MOV	R1,PC
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
d138 2
a139 2
	MOV	R1, #1			; Clock hi
	BL	SetC1C0
d143 2
a144 2
	MOV	R1, #0			; Clock lo
	BL	SetC1C0
d146 1
a146 1
	Pull	"R1, PC",,^
d148 5
a152 5
ClockData0 ROUT				; Clock a zero bit
	Push	"R0, R14"
	MOV	R0, #0
	BL	ClockData
	Pull	"R0, PC",,^
d156 1
a156 1
;	Start - Send the Start signal
d158 1
a158 1
; out:	All registers preserved, including PSR
d161 2
a162 2
Start	ROUT
	Push	"R0-R2,R14"
d164 3
a166 3
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0
d170 3
a172 3
	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
	BL	SetC1C0
d177 3
a179 3
	MOV	R2, #IOC
	MOV	R0,#10
	BL	DoMicroDelay
d184 3
a186 3
	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
	BL	SetC1C0
d188 1
a188 1
	Pull	"R0-R2,PC",,^
d192 1
a192 1
;	Acknowledge - Check acknowledge after transmitting a byte
d194 3
a196 3
; out:	All registers preserved
;	V=0 => acknowledge received
;	V=1 => no acknowledge received
d200 1
a200 1
	Push	"R0-R2,R14"
d202 3
a204 3
	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
	BL	SetC1C0
d210 8
a217 8
	MOV	R1,PC
	Push	"R1"
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
 ]
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0
d221 2
a222 2
	MOV	R2, #IOC
	LDRB	R2, [R2, #IOCControl]	; get the data from IOC
d224 3
a226 3
	MOV	R0, #0
	MOV	R1, #0			; clock lo
	BL	SetC1C0
d229 2
a230 2
	Pull	"R1"
	TEQP	PC,R1
d233 5
a237 5
	TST	R2, #1			; should be LO for correct acknowledge
	MOV	R2, PC
	BICEQ	R2, R2, #V_bit		; clear V if correct acknowledge
	ORRNE	R2, R2, #V_bit		; set V if no acknowledge
	TEQP	R2, #0
d239 1
a239 1
	Pull	"R0-R2,PC"
d243 1
a243 1
;	Stop - Send the Stop signal
d245 1
a245 1
; out:	All registers preserved, including PSR
d248 2
a249 2
Stop	ROUT
	Push	"R0,R1,R14"
d251 3
a253 3
	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
	BL	SetC1C0
d257 3
a259 14
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0

	Pull	"R0,R1,PC",,^

; *****************************************************************************
;
;	TXByte - Transmit a byte
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved, including PSR
;
d261 1
a261 11
TXByte	ROUT
	Push	"R0-R2,R14"
	MOV	R2, R0			; byte goes into R2
	MOV	R1, #&80		; 2^7 the bit mask
10
	ANDS	R0, R2, R1		; zero if bit is zero
	MOVNE	R0, #1
	BL	ClockData		; send the bit
	MOVS	R1, R1, LSR #1
	BNE	%BT10
	Pull	"R0-R2,PC",,^
d265 1
a265 4
;	StartTXPollAck - Transmit start and a byte and poll for acknowledge
;
;	This is intended for devices with a slow internal write cycle which
;	don't ack until the write cycle is finished ( eg ATMEL AT24C01A/x )
d267 1
a267 1
; in:	R0 = byte to be transmitted
d269 1
a269 1
; out:	All registers preserved, including PSR
d272 4
a275 3
StartTXPollAck	ROUT
	Push	"R1,R14"
	MOV	R1, #0
d277 6
a282 12
	INC	R1
	CMP	R1, #PollMax
	Pull	"R1,pc", EQ

	BL	Start
	BL	TXByte
	BL	Acknowledge
	BVS	%BT10
 [	{FALSE}
	BREG	R1, "i2c tries:"
 ]
	Pull	"R1,pc",,^
d286 1
a286 1
;	RXByte - Receive a byte
d288 2
a289 2
; out:	R0 = byte received
;	All other registers preserved, including PSR
d292 5
a296 5
RXByte	ROUT
	Push	"R1-R4, R14"
	MOV	R3, #0			; byte:=0
	MOV	R2, #IOC
	MOV	R4, #7
d298 3
a300 3
	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
	BL	SetC1C0
d306 16
a321 16
	MOV	R1,PC
	Push	"R1"
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
 ]
	MOV	R0, #1			; pulse clock HI
	MOV	R1, #1
	BL	SetC1C0

	LDRB	R1, [R2, #IOCControl]	; get the data from IOC
	AND	R1, R1, #1
	ADD	R3, R1, R3, LSL #1	; byte:=byte*2+(IOC?0)AND1

	MOV	R0, #1			; return clock LO
	MOV	R1, #0
	BL	SetC1C0
d324 2
a325 2
	Pull	"R1"
	TEQP	PC,R1
d327 2
a328 19
	SUBS	R4, R4, #1
	BCS	%BT10

	MOV	R0, R3			; return the result in R0
	Pull	"R1-R4, PC",,^

; *****************************************************************************

HTBTA	ROUT
	Push	R14
	BL	HexToBCD
	BL	TXAck
	Pull	PC

TXAck	ROUT
	Push	R14
	BL	TXByte
	BL	Acknowledge
	Pull	PC
d330 2
a331 6
CD0RBTH ROUT
	Push	R14
	BL	ClockData0
	BL	RXByte
	BL	BCDToHex
	Pull	PC
d335 1
a335 1
;	Write - Write a byte of CMOS RAM specified by logical address
d337 2
a338 2
; in:	R0 = address in CMOS RAM
;	R1 = data
d340 1
a340 1
; out:	All registers preserved
d343 4
a346 4
Write	ROUT
	Push	"R0-R4, R14"
	BL	MangleCMOSAddress
	Pull	"R0-R4, PC", CS		; if invalid, then exit
d348 9
a356 9
	MOV	R2, R0
	MOV	R3, R1
 [ ChecksumCMOS
	BL	ReadStraight		; calculate new checksum :
	MOV	R4, R0
	MOV	R0, #PhysChecksum
	BL	ReadStraight
	SUB	R0, R0, R4		; = oldsum - oldcontents
	ADD	R4, R0, R3		;          + newcontents
d358 4
a361 4
	AND	R4, R4, #&FF
	CMPS	R2, #PhysChecksum	; don't write new checksum ...
	ORREQ	R4, R4, #&1000000	; if checksum is being written
 ]
d364 2
a365 12
	ADR	R1, CMOSRAMCache-16	; update cache, but always write to
  [ :DEF: TestHarness
	ADD	R1, R1, #i2cWorkSpace
  ]
	STRB	R3, [R1, R2]		; real hardware as well
 ]
 [ E2ROMSupport
	MOV	R0, R2
	BL	GetI2CAddress		; convert to device address + offset
	MOV	R2, R0			; save the offset
 |
	MOV	R1, #RTCAddress
d367 1
d369 2
a370 2
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck
d372 15
a386 15
	MOV	R0, R2			; offset
	BL	TXAck

	MOV	R0, R3			; data
	BL	TXAck

	BL	Stop
	[ ChecksumCMOS
	TST	R4, #&1000000		; loop again to write new checksum
	MOV	R3, R4
	MOV	R2, #PhysChecksum
	ORR	R4, R4, #&1000000	; but ensure it only happens once
	BEQ	%BT10
	]
	Pull	"R0-R4, PC"
d390 2
a391 2
;	Read - Read a byte of CMOS RAM specified by logical address
;	ReadStraight - Read a byte of CMOS RAM specified by physical address
d393 1
a393 1
; in:	R0 = address in CMOS RAM
d395 2
a396 2
; out:	R0 = data (illegal address return 0)
;	All other registers preserved
d400 2
a401 2
	Push	"R1,R2,R14"
	B	%FT10
d404 4
a407 4
	Push	"R1,R2,R14"
	BL	MangleCMOSAddress
	MOVCS	R0, #0			; pretend illegal addresses contain 0
	Pull	"R1,R2,PC", CS
d409 8
a416 8
  [	CacheCMOSRAM
	TEQ	R0, #&40		; is it Econet station number
	BEQ	%FT15	 		; if so then don't use cache
	CMP	R0, #&10		; don't cache values < &10
	ADRCS	R2, CMOSRAMCache-&10	; if in range

  [ :DEF: TestHarness
	ADD	R2, R2, #i2cWorkSpace
d418 4
a421 2
	LDRCSB	R0, [R2, R0]		; read from cache
	Pull	"R1,R2,PC", CS		; and exit
d425 3
a427 1
  ]
d429 1
a429 5
  [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
  |
	MOV	R1, #RTCAddress
  ]
d431 2
a432 3
	MOV	R2, R0			; save the offset
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck
d434 2
a435 2
	MOV	R0, R2			; offset
	BL	TXAck
d437 1
a437 1
	BL	Start
d439 2
a440 2
	ADD	R0, R1, #1		; device address for read
	BL	TXAck
d442 2
a443 2
	BL	RXByte			; returned in R0
	MOV	R2, R0			; copy to R2 for now
d445 2
a446 2
	MOV	R0, #1
	BL	ClockData
d448 1
a448 1
	BL	Stop
d450 1
a450 1
	MOV	R0, R2			; return the result
d452 1
a452 1
	Pull	"R1,R2,PC"
d456 1
a456 2
;	GetI2CAddress - Convert NVRam physical address to i2c device address
;	                and offset
d458 1
a458 1
; in:	R0 = NVRam physical address (&00..size of NVRam)
d460 2
a461 1
; out:	R0 preserved
d463 2
a464 4
;	C=0 => NVRam address is valid 
;	 R0 = physical address within i2c device
;	 R1 = i2c device address for writing. Increment this device address
;	      by 1 for reading.
a465 18
;	C=1 => NVRam address is out of range of CMOS or E2ROM chips
;	 R0 preserved
;	 R1 preserved

  [	E2ROMSupport
GetI2CAddress ROUT
	CMP	R0, #&100
	ORRCSS	PC, R14, #C_bit		; indicate invalid

; address is <&100 -> is valid
	MOV	R1, #i2cWorkSpace
	LDRB	R1, [R1, #RTCFitted]
	TEQ	R1, #1
	MOVEQ	R1, #RTCAddress
	MOVNE	R1, #E2ROMAddress

	BICS	PC, R14, #C_bit		; indicate valid
  ]
d467 7
a475 13
;
;	MangleCMOSAddress - Convert from logical to physical address
;
;	Doesn't check if address is larger than the amount of NVRam installed
;
; in:	R0 = logical address (&00..&EF, &100..)
;
; out:	C=0 => valid logical address (ie not &F0..&FF)
;	 R0 = physical address (&40..&FF,&10..&3F,&100..)
;
;	C=1 => invalid logical address (ie &F0..&FF)
;	 R0 preserved
;
d477 11
a487 3
MangleCMOSAddress ROUT
	CMP	R0, #&F0		; if address &f0 or above
	ORRCSS	PC, R14, #C_bit		; indicate invalid
d489 6
a494 4
	ADD	R0, R0, #&40		; now in range &40..&13F
	CMP	R0, #&100
	SUBCS	R0, R0, #(&100-&10)	; now in range &40..&FF, &10..&3F
	BICS	PC, R14, #C_bit		; indicate valid
a495 1
		
d498 1
a498 2
;	ValChecksum - test to see if the CMOS checksum is OK
;
d502 1
a502 1
; in:	none
d504 3
a506 3
; out:	R0 = calculated checksum
;	Z	set if checksum is valid
;	All other registers preserved
d509 1
a509 1
  [ ChecksumCMOS
d511 2
a512 1
ValChecksum	ENTRY "R1,R2,R3"
d514 4
a517 9
	MOV	R3, #CMOSxseed
    [ E2ROMSupport
	MOV	R0, #&40
	BL	GetI2CAddress		; r1 = device address, r0 = offset
	MOV	R2, R0			; save the offset
    |
	MOV	R2, #&40
	MOV	R1, #RTCAddress
    ]
d519 1
a519 5
	MOV	R0, R1	 		; device write address
	BL	StartTXPollAck
	
	MOV	R0, R2			; memory offset
	BL	TXAck
d521 2
a522 1
	BL	Start
d524 2
a525 2
	ADD	R0, R1, #1		; device read address
	BL	TXAck
d527 4
d532 1
a532 1
; Read data from locations &40 through &FF, then
d537 2
a538 12
	BL	RXByte			; returned in R0
	ADD	R3, R3, R0		; accumulate into R3

	ADD	R2, R2, #1		; increment R2 to phys. address
	TEQ	R2, #&100		; limit
	BEQ	%30
	TEQ	R2, #PhysChecksum	; or until checksum.
	BEQ	%30			; then we're finished

	MOV	R0, #0			; not done .. ACK that byte
	BL	ClockData
	B	%BT20			; .. and continue reading
d540 9
d550 6
a555 7
	MOV	R0, #1			; finish off reading block
	BL	ClockData
	BL	Stop

        TST     R2, #&100		; either go back for bytes 10 - 3f
        MOVNE   R2, #&10		; or finish up completely.
	BNE	%BT10
d560 5
a564 5
	MOV	R0, #PhysChecksum
	BL	ReadStraight
	AND	R2, R0, #&FF		; value from checksum location
	AND	R0, R3, #&FF		; calculated value into R0
	CMPS	R0, R2
d566 2
a567 2
	EXIT
  ]				 
d571 1
a571 1
;	MakeChecksum - calculate and write a correct checksum
d573 1
a573 1
; in:	none
d575 2
a576 2
; out:	R0 = calculated checksum
;	All other registers preserved
d579 1
a579 1
	[ ChecksumCMOS
d581 8
a588 8
MakeChecksum	ROUT
	Push	R14
	BL	ValChecksum
	MOV	R1, R0
	MOV	R0, #CheckSumCMOS
	BL	Write
	Pull	PC
	]
d592 1
a592 1
;	SetTime - Write the CMOS clock time and update 5-byte RealTime
d594 8
a601 9
; in:	UTC time:
;	R0 = hours
;	R1 = minutes
;	R2 = day of month
;	R3 = month
;	R5 = year (lo)
;	R6 = year (hi)
;	R7 = seconds
;	R8 = centiseconds
d603 1
a603 1
;	Any of the above, if -1, will not be written to
d607 1
a607 1
	Push	"R4, R14"		; save registers
d609 21
a629 1
; write year to CMOS RAM
d631 14
a644 1
	MOV	R4, R0			; save hours in R4
d646 1
a646 32
	Push	"R1"
	MOVS	R1, R5
	MOVPL	R0, #YearCMOS
	BLPL	Write
	MOVS	R1, R6
	MOVPL	R0, #YearCMOS+1
	BLPL	Write

	CMP	R4, #-1			; are we writing time ?
	Pull	"R1",EQ			; [no, then skip]
	BEQ	%FT30

	MOV	R0, #&01		; start at address 1
    [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R0, R1			; write address
    |
	MOV	R0, #RTCAddress
    ]
	Pull	"R1"
	BL	StartTXPollAck
	MOV	R0, #&01		; offset 1
	BL	TXAck
	MOV	R0, R8			; centiseconds
	BL	HTBTA
	MOV	R0, R7			; seconds
	BL	HTBTA
	MOV	R0, R1			; minutes
	BL	HTBTA
	MOV	R0, R4			; hours
	BL	HTBTA
	BL	Stop
d648 40
d689 2
a690 2
	CMP	R2, #-1			; are we writing date ?
	BEQ	%FT40			; [no, then skip]
d692 28
a719 17
	MOV	R0, #&05		; start at address 5
    [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R0, R1			; write address
    |
	MOV	R0, #RTCAddress
    ]
	BL	StartTXPollAck
	MOV	R0, #&05		; offset 5
	BL	TXAck
	MOV	R0, R2			; day of month
	BL	HexToBCD
	ORR	R0, R0, R5, LSL #6	; year in bits 6,7; day in bits 0..5
	BL	TXAck
	MOV	R0, R3			; months
	BL	HTBTA
	BL	Stop
d721 1
a721 6
40
	MOV	R0, R4			; put hours back in R0
  [ :LNOT: :DEF: TestHarness
	BL	RTCToRealTime
  ]
	Pull	"R4, PC"
d725 1
a725 1
;	ReadTime - Read the CMOS clock time
d727 1
a727 1
; in:	-
d729 8
a736 8
; out:	R0 = hours
;	R1 = minutes
;	R2 = days
;	R3 = months
;	R5 = year (lo)
;	R6 = year (hi)
;	R7 = seconds
;	R8 = centiseconds
d740 1
a740 1
	Push	"R4, R14"
d742 63
a804 47
	MOV	R0, #&01		; start at address 1
    [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R0, R1			; write address
    |
	MOV	R0, #RTCAddress
    ]
	BL	StartTXPollAck
	MOV	R0, #&01		; offset 1
	BL	TXAck
	BL	Start
    [	E2ROMSupport
	ADD	R0, R1, #1		; read address
    |
	MOV	R0, #(RTCAddress+1)	; read address
    ]
	BL	TXAck
	BL	RXByte
	BL	BCDToHex
	MOV	R8, R0			; centiseconds
	BL	CD0RBTH
	MOV	R7, R0			; seconds
	BL	CD0RBTH
	MOV	R1, R0			; minutes
	BL	CD0RBTH
	MOV	R4, R0			; hours
	BL	ClockData0
	BL	RXByte
	AND	R0, R0, #&3F		; day of month (clear year bits)
	BL	BCDToHex
	MOV	R2, R0
	BL	ClockData0
	BL	RXByte
	AND	R0, R0, #&1F		; month (clear day of week bits)
	BL	BCDToHex
	MOV	R3, R0
	MOV	R0, #1
	BL	ClockData
	BL	Stop

	MOV	R0, #YearCMOS
	BL	Read
	MOV	R5, R0			; year (lo)

	MOV	R0, #YearCMOS+1
	BL	Read
	MOV	R6, R0			; year (hi)
d806 1
a806 1
	MOV	R0, R4			; put hours in R0
d809 5
a813 5
 [ {TRUE}				; LRust, fix RP-0370
	TEQ	R2, #0			; Valid day?
	MOVEQ	R2, #1			; No then force 1st
	TEQ	R3, #0			; Invalid month?
	MOVEQ	R3, #1			; Yes then force Jan
d815 1
a815 1
	Pull	"R4, PC"
d819 1
a819 1
;	InitCMOSCache - Initialise cache of CMOS RAM
d821 1
a821 1
  [	CacheCMOSRAM
d823 3
a825 43
InitCMOSCache	ENTRY "r0-r3"
    [	E2ROMSupport

;	First determine what hardware we've got fitted, R3 holds the number of
;	256 byte blocks that we've found
	
	; Have we got an RTC ?
	MOV	R0, #RTCAddress
	BL	DummyAccess
	MOVVS	R3, #0
	MOVVC	R3, #1
	MOV	R2, #i2cWorkSpace
	STRB	R3, [R2, #RTCFitted]

; Have we got a 1K E ?
	MOV	r0, #(E2ROMAddress+6)
	BL	DummyAccess
	ADDVC	R3, R3, #4
	BVC	%FT5

; Have we got 512 bytes of E ?
	MOV	r0, #(E2ROMAddress+2)
	BL	DummyAccess
	ADDVC	R3, R3, #4
	BVC	%FT5

; Have we got any E ?
	MOV	r0, #(E2ROMAddress)
	BL	DummyAccess
	ADDVC	R3, R3, #1

	; Set the NVRam count
5	STRB	R3, [R2, #NVRamSize]

	; Initialise the cache
	MOV	R0, #&10
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R2, R0			; save the offset
    |
	MOV	R1, #RTCAddress
	MOV	R2, #&10
    ]
	ADR	R3, CMOSRAMCache-16
d827 1
a827 4
    [	:DEF: TestHarness
	ADD	R3, R3, #i2cWorkSpace
    ]
	BL	Start
d829 2
a830 2
	MOV	R0, R1			; write address
	BL	TXAck
d832 2
a833 2
	MOV	R0, R2			; memory word address
	BL	TXAck
d835 1
a835 1
	BL	Start
d837 2
a838 2
	ADD	R0, R1, #1		; read address
	BL	TXAck
d841 9
a849 9
	BL	RXByte			; returned in R0
	STRB	R0, [R3, R2]
	ADD	R2, R2, #1		; increment R2 to phys. address
	CMP	R2, #&100
	BEQ	%FT20

	MOV	R0, #0			; not done .. ACK that byte
	BL	ClockData
	B	%BT10			; .. and continue reading
d851 4
a854 4
	MOV	R0, #1			; finish off reading block
	BL	ClockData
	BL	Stop
	EXIT
d856 2
a857 26
  ]


; *****************************************************************************
;
;	DummyAccess - do a dummy access of the specified device to find out
;	              if it is present
;
; in:	R0 = Write address of device
;
; out:	All registers preserved
;	V=0 => device is present
;	V=1 => device is not present

; Have we got an RTC ? do a read from location 0 to find out

  [ E2ROMSupport
DummyAccess	ENTRY

	BL	Start
	BL	TXAck			; do write and set V if no ack 
	BL	Stop			; Doesn't change the PSR
	EXIT				; Exit with V set appropriately
  ]

	END
@


4.1.7.2
log
@Extended to read/write full 1K EEPROM.
Full 1K is also cached if FullCMOSRAMCache is true.
@
text
@d43 6
d302 1
a303 1
	MOV	R2, R0			; byte goes into R2
d442 3
a444 8
  [ :LNOT: FullCMOSRAMCache
	CMP	r2, #&100		; check small cache limit
	BCS	%FT15
  ]
  [ :LNOT: :DEF: TestHarness
	LDR	R1, =CMOSRAMCache-16	; update cache, but always write to
  |
        ADR     R1, i2cWorkSpace-16
a446 1
15
a498 4
    [	:LNOT: FullCMOSRAMCache
	CMP	R0, #&100		; check small cache limit
	BCS	%FT15
    ]
d500 4
a503 4
  [ :LNOT: :DEF: TestHarness
	LDRCS	R2, =CMOSRAMCache-&10	; if in range
  |
	ADRCS	R2, i2cWorkSpace-&10
d562 1
a562 6
	Push	"R14"
	MOV	R14, #0			; get no 256 byte blocks and calculate end address
	LDR	R14, [R14, #NVRamSize]
	MOV	R14, R14, LSL #8
	CMP	R0, R14
	Pull	"R14",CS
d565 2
a566 2
; address is < end address -> is valid
	MOV	R1, #0
a571 5
	MOVS	R14, R0, LSR #8		; put top two bits of physical address into device address
	ORRNE	R1, R1, R14, LSL #1
	ANDNE	R0, R0, #&FF		; and use address within 256 byte block

	Pull	"R14"
d591 3
a593 14
MangleCMOSAddress
	Push	"R14"
	MOV	R14, #0			; read no 256 byte blocks and calculate end address
	LDR	R14, [R14, #NVRamSize]
	MOV	R14, R14, LSL #8
	CMP	R0, R14			; if >= end address then
	Pull	"R14"
	ORRCSS	PC, R14, #C_bit		;    invalid

	CMP	R0, #&100		; if < end address && >= &100 then
	BICCSS	PC, R14, #C_bit		;    valid (no mungeing)

	CMP	R0, #&F0		; if < &100 && >= &f0 then
	ORRCSS	PC, R14, #C_bit		;    invalid
d598 1
a598 1
	BICCSS	PC, R14, #C_bit		; valid
d600 1
d617 1
a617 1
ValChecksum	ENTRY "R1-R4"
a623 3
	MOV	R4, #0			; read number of 256 byte blocks and calculate end address
	LDR	R4, [R4, #NVRamSize]
	MOV	R4, R4, LSL #8
a626 1
	MOV	R4, #&100		; end address is always &100
d641 1
a641 1
; Read data from locations &40 through to the end address, then
d650 1
a650 1
	TEQ	R2, R4			; limit
d655 1
a655 3
	TST	R2, #&FF		; still in same 256 byte block?
	MOVNE	R0, #0			; yes => not done .. ACK that byte
	MOVEQ	R0, #1			; no => finish off reading block
d657 1
a657 6
	BNE	%BT20			; yes => continue reading

	BL	Stop
	MOV	R0, R2			; in next 256 byte block so get device + address
	BL	GetI2CAddress
	B	%BT10			; and start next block
d664 3
a666 3
        TEQ     R2, R4			; either go back for bytes 10 - 3f
        MOVEQ   R2, #&10		; or finish up completely.
	BEQ	%BT10
a700 2
        LTORG

d871 1
a871 1
InitCMOSCache	ENTRY "r0-r4"
d874 1
a874 1
;	First determine what hardware we've got fitted, R4 holds the number of
d880 4
a883 4
	MOVVS	R4, #0
	MOVVC	R4, #1
	MOV	R2, #0
	STRB	R4, [R2, #RTCFitted]
d888 1
a888 1
	MOVVC	R4, #4
d894 1
a894 1
	MOVVC	R4, #2
d900 1
a900 1
	MOVVC	R4, #1
d903 1
a903 8
5	STRB	R4, [R2, #NVRamSize]

	[ FullCMOSRAMCache
	; Calculate address at which to stop
	MOV	R4, R4, LSL #8		; number of 256 byte blocks * 256
	|
	MOV     R4, #&100		; stop at address &100
	]
a911 1
	MOV	R4, #&100		; stop at address &100
d913 4
a916 4
    [	:LNOT: :DEF: TestHarness
	LDR	R3, =CMOSRAMCache-16
    |
	ADR	R3, i2cWorkSpace-16
a917 1
09
d935 2
a936 2
	CMP	R2, R4			; stop when we hit end address
	BGE	%FT20
d938 1
a938 3
	TST	R2, #&FF		; still in same 256 byte block?
	MOVNE	R0, #0			; yes => not done .. ACK that byte
	MOVEQ	R0, #1			; no => finish off reading block
d940 1
a940 6
	BNE	%BT10			; yes => continue reading

	BL	Stop
	MOV	R0, R2			; in next 256 byte block so get device + address
	BL	GetI2CAddress
	B	%BT09			; and start next block
@


4.1.7.3
log
@Fixed bug in MangleCMOSAddress.
@
text
@d623 1
a623 1
	BICS	PC, R14, #C_bit		; valid
@


4.1.7.4
log
@Fixed a bug andmodified TestHarness support.
@
text
@a566 1
	[ :LNOT: :DEF: TestHarness
d568 1
a568 4
	LDRB	R14, [R14, #NVRamSize]
	|
	LDRB	R14, NVSize
	]
a574 1
	[ :LNOT: :DEF: TestHarness
a576 3
	|
	LDRB	R1, RTCFlag
	]
a606 1
	[ :LNOT: :DEF: TestHarness
d608 1
a608 4
	LDRB	R14, [R14, #NVRamSize]
	|
	LDRB	R14, NVSize
	]
a647 1
	[ :LNOT: :DEF: TestHarness
d649 1
a649 4
	LDRB	R4, [R4, #NVRamSize]
	|
	LDRB	R4, NVSize
	]
a919 1
	[ :LNOT: :DEF: TestHarness
a920 3
	|
	STRB	R4, RTCFlag
	]
a938 1
5
d940 1
a940 5
	[ :LNOT: :DEF: TestHarness
	STRB	R4, [R2, #NVRamSize]
	|
	STRB	R4, NVSize
	]
@


4.1.7.5
log
@Fixed NV-RAM reset on every boot bug - hopefully!
@
text
@d658 1
a658 1
	BL	GetI2CAddress		; In: r0 = physical addr, Out: r1 = device address, r0 = offset
d673 1
a673 1
	MOV	R0, R1			; device write address
d675 1
a675 1

a704 1
   [ E2ROMSupport
d709 1
a709 1
   ]
d715 3
a717 8
	TEQ	R2, R4			; either go back for bytes 10 - 3f
	BNE	%FT40
	MOV	R2, #&10		; or finish up completely.
   [ E2ROMSupport
	MOV	R0, R2
	BL	GetI2CAddress
   ]
	B	%BT10
a721 1
40
a1014 1
   [ E2ROMSupport
a1018 1
   ]
@


4.1.7.6
log
@Added support for 2K EEPROM.
@
text
@d35 1
a35 1
PollMax		*	45	; Number of times to poll for an Ack
a40 1
E2ROMAddress2K  * &e0
a418 4
  [ E2ROMSupport
        CMP     r2, #&10
        Pull    "R0-R4, PC", CC         ; don't write to OTP section
  ]
d585 3
a587 7
	TEQ	R1, #0
	MOVNE	R1, #RTCAddress
	[ :LNOT: :DEF: TestHarness
	LDREQB  R1, [R1, #NVRamBase]
	|
	LDREQB  R1, NVBase
	]
d589 1
a589 1
	MOVS	R14, R0, LSR #8		; put top bits of physical address into device address
d604 1
a604 1
; in:	R0 = logical address (&00...)
d606 2
a607 2
; out:	C=0 => valid logical address
;	 R0 = physical address (&40..&FF,&00..&3F,&100..)
d609 1
a609 1
;	C=1 => invalid logical address
a629 4
        [ E2ROMSupport
        SUBCS   R0, R0, #&F0            ;    map &F0->&FF to &00->0F for OTP section
        BICCSS  PC, R14, #C_bit
        |
a630 1
        ]
d641 2
a642 5
;       This routine performs MangleCMOSAddress inherently.
;
;       The checksum does not include physical locations &00->&0F, even
;       if they are OTP section (as this is usually used for a unique id
;       which will be different for every machine).
d716 1
a716 1
	TEQ	R2, R4			; either finish up completely
d718 1
a718 1
	MOV	R2, #&10		; or go back for bytes 10 - 3E.
a948 7
; Have we got a 2K E ?
        MOV     r1, #E2ROMAddress2K
	MOV	r0, #(E2ROMAddress2K+14)
	BL	DummyAccess
	MOVVC	R4, #8
	BVC	%FT5

a949 1
        MOV     r1, #E2ROMAddress
a964 1
	MOVVS   R1, #RTCAddress
a968 1
	STRB    R1, [R2, #NVRamBase]
a970 1
	STRB    R1, NVBase
d982 1
a982 1
	MOV	R0, #&10                ; we don't cache &00->&0F, even if they are OTP section
@


4.1.7.7
log
@Prevent writes to OTP section (would corrupt checksum).
@
text
@d421 1
a421 1
        CMP     r0, #&10
d659 1
a659 1
;       which will be different for every machine and can't be changed).
@


4.1.7.8
log
@Removed FullCMOSRAMCache support.
Increased cache size to 256 bytes.
Read OTP section of 2K EEPROM into cache.
@
text
@d441 1
d444 1
d446 1
a446 1
	LDR	R1, =CMOSRAMCache	; update cache, but always write to
d448 1
a448 1
        ADR     R1, i2cWorkSpace
d504 1
d506 3
d510 1
a510 1
	LDRCC	R2, =CMOSRAMCache	; if in range
d512 1
a512 1
	ADRCC	R2, i2cWorkSpace
d514 2
a515 2
	LDRCCB	R0, [R2, R0]		; read from cache
	Pull	"R1,R2,PC", CC		; and exit
a996 1
	LDR	R3, =CMOSRAMCache
d1000 7
a1006 1
	ADR	R3, i2cWorkSpace
d1010 3
a1012 11
        MOV     R0, #&00                ; start at &00
        
        TEQ     R4, #8                  ; if 2K part then

        MOVEQ   R1, #&60                ; special control byte for security access
        MOVEQ   R4, #&10                ; stop at &10

        MOVNE   R4, #&100               ; otherwise stop at &100
        BLNE    GetI2CAddress           ; and convert to device address and offset
        
        MOV     R2, R0                  ; save the offset
d1017 5
a1021 5
        [	:LNOT: :DEF: TestHarness
	LDR	R3, =CMOSRAMCache
        |
	ADR	R3, i2cWorkSpace
        ]
a1059 11

   [ E2ROMSupport
        TEQ     R4, #&100               ; have we reached the end?
        EXIT    EQ                      ; exit if so

        MOV     R0, R4                  ; start next block from R4
        MOV     R4, #&100               ; stop at &100
        BL      GetI2CAddress           ; convert to device address and offset
        MOV     R2, R0                  ; save the offset
        B       %BT09                   ; and go round again
   |
a1060 1
   ]
@


4.1.7.9
log
@Fixed access to OTP section of 2K EEPROM.
@
text
@d999 2
a1001 1
        BNE     %FT07
d1003 6
a1008 6
        BL      Start                   ; send special control byte for security access
        MOV     R0, #&61
        BL      TXAck
07
        MOV     R0, #&00                ; start at &00
        BL      GetI2CAddress           ; and convert to device address and offset
a1009 1
        MOV     R4, #&100               ; stop at &100
d1031 1
a1031 1
	ORR	R0, R1, #1		; read address
@


4.1.7.10
log
@TMD 12-Jun-97: Hopefully *really* fix the OTP access!
@
text
@a31 1
; 12-Jun-97  TMD   (Really) fix OTP access problem.
d38 1
a38 1
RTCAddress		*	&a0
d40 2
a41 3
E2ROMAddress		*	&a8
E2ROMAddress2K		*	&e0
E2ROMAddress2K_OTP	*	&60
d554 1
a554 1
;	C=0 => NVRam address is valid
d747 1
a747 1
  ]
d947 1
a947 1

d999 1
a999 2
        TEQ     R4, #8                  ; check for 2K part
	MOVNE	r0, #&00		; if not, then start at 0 anyway and read non-OTP data into location 0..15
d1001 4
a1004 2
	BL	ReadOTPArea
	MOV	r0, #&10		; read rest of it from 16 onwards
d1006 1
a1070 24
   [ E2ROMSupport
ReadOTPArea Entry
	BL	Start
	MOV	r0, #E2ROMAddress2K_OTP
	BL	TXAck
	MOV	r0, #0				; OTP memory word address
	BL	TXAck
	BL	Start
	MOV	r0, #E2ROMAddress2K_OTP + 1	; switch to read
	BL	TXAck
	MOV	r2, #0
10
	BL	RXByte
	STRB	r0, [r3, r2]
	ADD	r2, r2, #1
	TEQ	r2, #16
	MOVNE	r0, #0				; not done, so clock zero
	MOVEQ	r0, #1
	BL	ClockData
	BNE	%BT10
	BL	Stop
	EXIT
   ]

d1091 1
a1091 1
	BL	TXAck			; do write and set V if no ack
@


4.1.7.11
log
@Added SWI OS_VIDCDivider, and vdu variable PixelRate for better video mode
support.  Fixed to build for Risc PC.
@
text
@a618 1
 [ E2ROMSupport
a632 1
 ]
@


4.1.7.12
log
@Support added for 24LC128 16K EEPROM device.
OS_NVMemory SWI added to allow block operations on non-volatile memory.
Kernel can clock memory device at 400kHz for greater throughput.
Safeguards added to stop the device being accessed when the clock is changed
and the device doesn't have an RTC.
Changed to use srccommit.

Version 4.63, 1.1.2.2. Tagged as 'Kernel-4_63-1_1_2_2'
@
text
@a32 2
; 17-Sep-98  KJB   Add support for 16K 24C128 EEPROM.
; 21-Sep-98  KJB   Add OS_NVMemory SWI.
d36 1
a36 2
PollMax		*	150	; Number of times to poll for an Ack (increase if you clock faster - need to
                                ; allow 5ms for write cycle).
d39 1
a39 1
RTCAddress		*	&a0     ; traditional RTC / 240 byte CMOS
d41 3
a43 4
E2ROMAddress		*	&a8     ; 24C08 device - 512 byte or 1K
E2ROMAddress2K		*	&e0     ; 24C174 device - 2K
E2ROMAddress2K_OTP	*	&60     ; 24C174 device - OTP section
E2ROMAddress16K         *       &a8     ; 24C128 device - 16K
d106 1
a106 12
 [ ClockNVMemoryFast
        [ :LNOT: :DEF: TestHarness
        MOV	R0, #0
        LDRB	R0, [R0, #NVRamSpeed]
        |
        LDRB	R0, NVSpeed
        ]
        TEQ     R0, #0
        MOVEQ   R0, #10                         ; default value if speed not checked yet
 |
        MOV     R0, #10                         ; 5s delay
 ]
d193 1
a193 1
; Delay here must be >= 4.7 microsecs (1.3 for fast device)
d199 1
a199 1
 [ :LNOT: ClockNVMemoryFast
d203 1
a203 1
        MOV     R0, #10
d207 1
a207 1
; Delay here must be >= 4.0 microsecs (0.6 for fast device)
d244 1
a244 1
; Delay here must be >= 4.0 microsecs (0.6 for fast device)
d280 1
a280 1
; Delay here must be >= 4.0 microsecs (0.6 for fast device)
d418 1
a418 16
WriteWithError ROUT
        Push    "R0-R4, R14"
        BL      MangleCMOSAddress
        BCC     %FT05

        ADD     R13, R13, #4            ; junk stacked R0
        ADR     R0, ErrorBlock_CoreNotWriteable
 [ International
        BL      TranslateError
 ]
        Pull    "R1-R4,R14"
        ORRS    PC, LR, #V_bit

        MakeErrorBlock CoreNotWriteable

Write
a421 1
05
d464 1
a464 5
        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck

	AND	R0, R2, #&FF		; offset (LSB)
a481 214
;       WriteBlock - Write a block of CMOS RAM specified by logical address
;
; in:   R0 = address in CMOS RAM
;       R1 = address to copy from
;       R2 = length
;
; out:  All registers preserved
;


WriteBlock ROUT
        Push    "R0-R4,R14"
  [     E2ROMSupport
        [ :LNOT: :DEF: TestHarness
        MOV	R14, #0
        LDRB	R14, [R14, #NVRamSize]
        |
        LDRB	R14, NVSize
        ]
        MOV     R14, R14, LSL #8
  |
        MOV     R14, #240
  ]

        CMP     R0, R14
        BHS     %FT90

        ADDS    R3, R0, R2              ; R3 = end address - check unsigned overflow
        BCS     %FT90
        CMP     R3, R14
        BHI     %FT90

        TEQ     R2, #0
        BEQ     %FT80

        CMP     R0, #CheckSumCMOS       ; are we going to write the checksum byte?
        BHI     %FT03
        CMP     R3, #CheckSumCMOS
        BHS     %FT05

03
; we're not writing the checksum byte manually, so we need to update it
        MOV     R4, R1
        MOV     R1, #0
        BL      ChecksumBlock           ; find the checksum of what we're about to
        ORR     R3, R1, #&80000000      ; overwrite
        MOV     R1, R4
        B       %FT08

05      MOV     R3, #0
08      MOV     R4, #0
10      BL      WriteSubBlock
        BVS     %FT80
        TEQ     R2, #0
        BNE     %BT10

        TST     R3, #&80000000          ; were we going to write the checksum?
        BEQ     %FT80

        MOV     R0, #CheckSumCMOS
        BL      Read                    ; get old checksum byte
        ADD     R0, R0, R4              ; add new data checksum
        SUB     R1, R0, R3              ; subtract old checksum
        MOV     R0, #CheckSumCMOS
        BL      Write                   ; write back new checksum

80
        Pull    "R0-R4,PC"

90
        ADD     SP, SP, #4              ; junk stacked R0
        ADR     R0, ErrorBlock_CoreNotWriteable
 [ International
        BL      TranslateError
 ]
95
        Pull    "R1-R4,LR"
        ORRS    PC, LR, #V_bit

; *****************************************************************************
;
;       WriteSubBlock - Write a block of CMOS RAM specified by logical address.
;                       Assumes the address is valid, and will only read as much
;                       as it can in a single IIC transaction.
;
; in:   R0 = address in CMOS RAM
;       R1 = address to copy from
;       R2 = length
;
; out:  R0-R2 updated to reflect the amount written.
;       R4 incremented by sum of bytes written.
;
WriteSubBlock ROUT
        Push    "R3,R5-R6,R14"
        MOV     R6, R4
; establish end of the current contiguous block, and the logical->physical address offset.
        CMP     R0, #1                  ; 00 -> 40 uncached
        MOVLO   R3, #1
        MOVLO   R4, #&40-&00
        BLO     %FT10
        CMP     R0, #&C0                ; [01..C0) -> [41..100) cached
        MOVLO   R3, #&C0
        MOVLO   R4, #&41-&01
        BLO     %FT10
        CMP     R0, #&F0                ; [C0..F0) -> [10..40) cached
        MOVLO   R3, #&F0
        MOVLO   R4, #&10-&C0
        BLO     %FT10
        CMP     R0, #&100
        ADDHS   R3, R0, R2              ; [100..) -> [100..) uncached
        MOVHS   R4, #0
        BHS     %FT10

; [F0..100) -> not written
        MOV     R3, #&100
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
        SUB     R14, R3, R0
        ADD     R0, R0, R14
        ADD     R1, R1, R14
        SUB     R2, R2, R14
        Pull    "R3,R5-R6,PC"

; R3 = logical end of current segment (exclusive)
; R4 = offset from logical to physical address for this segment
10
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
 [ E2ROMSupport
; R3 = logical end of possible transaction (exclusive). Now check we don't cross page boundaries.
        [ :LNOT: :DEF: TestHarness
        MOV	R14, #0
        LDRB	R14, [R14, #NVRamPageSize]
        |
        LDRB	R14, NVPageSize
        ]
        MOV     R5, #1
        MOV     R14, R5, LSL R14        ; R14 = (1<<pagesize)

        ADD     R5, R0, R4              ; R5 = physical start address
        ADD     R5, R5, R14
        SUB     R14, R14, #1
        BIC     R5, R5, R14             ; R5 = physical end of page with start address in
        SUB     R5, R5, R4              ; R5 = logical end of page with start address in

        CMP     R5, R3
        MOVLO   R3, R5                  ; adjust R3 to not cross page boundary
 ]

  [     CacheCMOSRAM
        CMP     R0, #&100               ; check it's a cacheable segment
        BHS     %FT15

  [ :LNOT: :DEF: TestHarness
        LDR     R14, =CMOSRAMCache
  |
        ADR     R14, i2cWorkSpace
  ]
        Push    "R3, R4"
        ADD     R3, R3, R4              ; R3 = physical end address
        ADD     R4, R4, R0              ; R4 = physical address
        ADD     R3, R3, R14             ; R3 = cache end address
        ADD     R4, R4, R14             ; R4 = cache address
        SUB     R14, R3, R4             ; R14 = bytes being written
        MOV     R5, R1                  ; remember R1
12      LDRB    R14, [R1], #1           ; update cache copy
        STRB    R14, [R4], #1
        CMP     R4, R3
        BLO     %BT12
        MOV     R1, R5                  ; restore R1, and continue to update real memory
        Pull    "R3, R4"
  ]
15
        Push    "R0-R2"
        ADD     R0, R0, R4              ; R0 = physical address
  [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
  |
	MOV	R1, #RTCAddress
  ]

	MOV	R2, R0			; save the offset
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck

        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck

	AND	R0, R2, #&FF		; offset (LSB)
	BL	TXAck

        Pull    "R0-R2"
        SUB     R5, R3, R0              ; R5 = bytes being written
        ADD     R0, R0, R5              ; update return R0
        SUB     R2, R2, R5              ; update return R2
        Push    "R0,R2"
20
        LDRB    R0, [R1], #1
        ADD     R6, R6, R0              ; update checksum counter
        BL      TXAck
        SUBS    R5, R5, #1
        BNE     %BT20

	BL	Stop

        MOV     R4, R6

	Pull	"R0,R2,R3,R5,R6,PC",,^

; *****************************************************************************
;
a483 1
;       ReadWithError - Read a byte of CMOS RAM specified by logical address, giving error if out of range
d487 1
a487 1
; out:	R0 = data (illegal address return 0, or error for ReadWithError)
a494 13
ReadWithError
        Push    "R1,R2,R14"
        BL      MangleCMOSAddress
        BCC     %FT10
        ADR     R0, ErrorBlock_CoreNotReadable
 [ International
        BL      TranslateError
 ]
        Pull    "R1,R2,R14"
        ORRS    PC, LR, #V_bit

        MakeErrorBlock CoreNotReadable

d527 1
a527 5
        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck

	AND	R0, R2, #&FF		; offset (LSB)
a546 306

; *****************************************************************************
;
;       ReadBlock - Read a block of CMOS RAM specified by logical address
;
; in:   R0 = address in CMOS RAM
;       R1 = address to copy to
;       R2 = length
;
; out:  All registers preserved
;


ReadBlock ROUT
        Push    "R0-R3,R14"
  [     E2ROMSupport
        [ :LNOT: :DEF: TestHarness
        MOV	R14, #0
        LDRB	R14, [R14, #NVRamSize]
        |
        LDRB	R14, NVSize
        ]
        MOV     R14, R14, LSL #8
  |
        MOV     R14, #240
  ]

        CMP     R0, R14
        BHS     %FT90

        ADDS    R3, R0, R2              ; R3 = end address - check unsigned overflow
        BCS     %FT90
        CMP     R3, R14
        BHI     %FT90

        TEQ     R2, #0
        BEQ     %FT80

10      BL      ReadSubBlock
        BVS     %FT80
        TEQ     R2, #0
        BNE     %BT10
80
        Pull    "R0-R3,PC"

90
        ADD     SP, SP, #4              ; junk stacked R0
        ADR     R0, ErrorBlock_CoreNotReadable
 [ International
        BL      TranslateError
 ]
95
        Pull    "R1-R3,LR"
        ORRS    PC, LR, #V_bit

; *****************************************************************************
;
;       ReadSubBlock - Read a block of CMOS RAM specified by logical address.
;                      Assumes the address is valid, and will only read as much
;                      as it can in a single IIC transaction.
;
; in:   R0 = address in CMOS RAM
;       R1 = address to copy to
;       R2 = length
;
; out:  R0-R2 updated to reflect the amount read.
;
ReadSubBlock ROUT
        Push    "R3-R5,R14"
; establish end of the current contiguous block, and the logical->physical address offset.
        CMP     R0, #1                  ; 00 -> 40 uncached
        MOVLO   R3, #1
        MOVLO   R4, #&40-&00
        BLO     %FT10
        CMP     R0, #&C0                ; [01..C0) -> [41..100) cached
        MOVLO   R3, #&C0
        MOVLO   R4, #&41-&01
        BLO     %FT10
        CMP     R0, #&F0                ; [C0..F0) -> [10..40) cached
        MOVLO   R3, #&F0
        MOVLO   R4, #&10-&C0
        BLO     %FT10
        CMP     R0, #&100               ; [F0..100) -> [00..10) cached
        MOVLO   R3, #&100
        MOVLO   R4, #&00-&F0
        ADDHS   R3, R0, R2              ; [100..) -> [100..) uncached
        MOVHS   R4, #0
; R3 = logical end of current segment (exclusive)
; R4 = offset from logical to physical address for this segment
10
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
; R3 = logical end of this transaction (exclusive)
  [     CacheCMOSRAM
        TEQ     R0, #0                  ; check it's a cacheable segment
        BEQ     %FT15
        CMP     R0, #&100
        BHS     %FT15

  [ :LNOT: :DEF: TestHarness
        LDR     R14, =CMOSRAMCache
  |
        ADR     R14, i2cWorkSpace
  ]
        ADD     R3, R3, R4              ; R3 = physical end address
        ADD     R4, R4, R0              ; R4 = physical address
        ADD     R3, R3, R14             ; R3 = cache end address
        ADD     R4, R4, R14             ; R4 = cache address
        SUB     R14, R3, R4             ; R14 = bytes being read
        ADD     R0, R0, R14             ; update return R0
        SUB     R2, R2, R14             ; update return R2

12      LDRB    R14, [R4], #1
        CMP     R4, R3
        STRB    R14, [R1], #1
        BLO     %BT12
        Pull    "R3-R5,PC",,^
  ]
15
        Push    "R0-R2"
        ADD     R0, R0, R4              ; R0 = physical address
  [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
  |
	MOV	R1, #RTCAddress
  ]

	MOV	R2, R0			; save the offset
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck

        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck

	AND	R0, R2, #&FF		; offset (LSB)
	BL	TXAck

	BL	Start

	ADD	R0, R1, #1		; device address for read
	BL	TXAck

        Pull    "R0-R2"
        SUB     R5, R3, R0              ; R5 = bytes being read
        ADD     R0, R0, R5              ; update return R0
        SUB     R2, R2, R5              ; update return R2
        Push    "R0,R2"
20
        BL      RXByte
        STRB    R0, [R1], #1
        SUBS    R5, R5, #1
        MOVNE   R0, #0                  ; not done - ACK byte
	MOVEQ   R0, #1                  ; done - no ACK
	BL	ClockData
        BNE     %BT20

	BL	Stop

	Pull	"R0,R2,R3-R5,PC",,^

; *****************************************************************************
;
;       ChecksumBlock - Checksum a block of CMOS RAM specified by logical address
;                       Assumes the address is valid.
;
; in:   R0 = address in CMOS RAM
;       R1 = initial checksum
;       R2 = length
;
; out:  R1 incremented by sum of bytes in range
;


ChecksumBlock ROUT
        Push    "R0,R2,R14"

10      BL      ChecksumSubBlock
        BVS     %FT80
        TEQ     R2, #0
        BNE     %BT10
80
        Pull    "R0,R2,PC"


; *****************************************************************************
;
;       ChecksumSubBlock - Checksum a block of CMOS RAM specified by logical address.
;                          Assumes the address is valid, and will only read as much
;                          as it can in a single IIC transaction. Skips over
;                          239 (the checksum byte itself), and 240-255 (OTP area).
;
; in:   R0 = address in CMOS RAM
;       R1 = initial checksum
;       R2 = length
;
; out:  R0-R2 updated to reflect the data read.
;
ChecksumSubBlock ROUT
        Push    "R3-R5,R14"
; establish end of the current contiguous block, and the logical->physical address offset.
        CMP     R0, #1                  ; 00 -> 40 uncached
        MOVLO   R3, #1
        MOVLO   R4, #&40-&00
        BLO     %FT10
        CMP     R0, #&C0                ; [01..C0) -> [41..100) cached
        MOVLO   R3, #&C0
        MOVLO   R4, #&41-&01
        BLO     %FT10
        CMP     R0, #&EF                ; [C0..EF) -> [10..3F) cached
        MOVLO   R3, #&EF
        MOVLO   R4, #&10-&C0
        BLO     %FT10
        CMP     R0, #&100
        ADDHS   R3, R0, R2              ; [100..) -> [100..) uncached
        MOVHS   R4, #0
        BHS     %FT10

;  [EF..100) -> not checksummed
        MOV     R3, #&100
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
        SUB     R14, R3, R0
        ADD     R0, R0, R14
        SUB     R2, R2, R14
        Pull    "R3-R5,PC"


; R3 = logical end of current segment (exclusive)
; R4 = offset from logical to physical address for this segment
10
        ADD     R14, R0, R2
        CMP     R3, R14
        MOVHI   R3, R14
; R3 = logical end of this transaction (exclusive)

  [     CacheCMOSRAM
        TEQ     R0, #0                  ; check it's a cacheable segment
        BEQ     %FT15
        CMP     R0, #&100
        BHS     %FT15

  [ :LNOT: :DEF: TestHarness
        LDR     R14, =CMOSRAMCache
  |
        ADR     R14, i2cWorkSpace
  ]
        ADD     R3, R3, R4              ; R3 = physical end address
        ADD     R4, R4, R0              ; R4 = physical address
        ADD     R3, R3, R14             ; R3 = cache end address
        ADD     R4, R4, R14             ; R4 = cache address
        SUB     R14, R3, R4             ; R14 = bytes being read
        ADD     R0, R0, R14             ; update return R0
        SUB     R2, R2, R14             ; update return R2

12      LDRB    R14, [R4], #1
        CMP     R4, R3
        ADD     R1, R1, R14
        BLO     %BT12
        Pull    "R3-R5,PC"
  ]
15
        Push    "R0-R2"
        ADD     R0, R0, R4              ; R0 = physical address
  [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
  |
	MOV	R1, #RTCAddress
  ]

	MOV	R2, R0			; save the offset
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck

        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8          ; offset (MSB)
        BLNE    TXAck

	AND	R0, R2, #&FF		; offset (LSB)
	BL	TXAck

	BL	Start

	ADD	R0, R1, #1		; device address for read
	BL	TXAck

        Pull    "R0-R2"
        SUB     R5, R3, R0              ; R5 = bytes being read
        ADD     R0, R0, R5              ; update return R0
        SUB     R2, R2, R5              ; update return R2
        Push    "R0,R2"
20
        BL      RXByte
        ADD     R1, R1, R0
        SUBS    R5, R5, #1
        MOVNE   R0, #0                  ; not done - ACK byte
	MOVEQ   R0, #1                  ; done - no ACK
	BL	ClockData
        BNE     %BT20

	BL	Stop

	Pull	"R0,R2,R3-R5,PC"

d559 1
a559 1
;	      by 1 for reading. Bit 8 is set if device requires 2-byte physical address.
a593 4
        CMP     R14, #2*1024            ; is the device bigger than 2K? If so, new addressing scheme
        ORRHI   R1, R1, #&100           ; set magic bit => 2 byte address
        BHI     %FT50

d597 1
a597 1
50
a599 1

d612 1
a612 1
;	 R0 = physical address (&40..&FF,&10..&3F,&00..0F,&100..)
d618 1
a618 1
MangleCMOSAddress ROUT
d668 1
a668 1
ValChecksum	ENTRY "R1-R2"
d670 5
a674 2
        MOV     R0, #0
        MOV     R1, #CMOSxseed
d676 2
a677 2
	MOV	R2, #0			; read number of 256 byte blocks and calculate end address
	LDRB	R2, [R2, #NVRamSize]
d679 1
a679 1
	LDRB	R2, NVSize
d681 58
a738 2
	MOV	R2, R2, LSL #8
        BL      ChecksumBlock
d741 1
a741 1
; R1 contains the actual checksum. Compare it with the recorded checksum
d744 2
a745 2
	MOV	R0, #CheckSumCMOS
	BL	Read
d747 1
a747 1
	AND	R0, R1, #&FF		; calculated value into R0
d766 3
a768 11
	Push	"R1-R2,R14"
        MOV     R0, #0
        MOV     R1, #CMOSxseed
	[ :LNOT: :DEF: TestHarness
	MOV	R2, #0
	LDRB	R2, [R2, #NVRamSize]
	|
	LDRB	R2, NVSize
	]
	MOV	R2, R2, LSL #8
        BL      ChecksumBlock
d771 1
a771 1
	Pull	"R1-R2,PC"
a795 18
	[ :LNOT: :DEF: TestHarness
	MOV	R14, #0
	LDRB	R14, [R14, #RTCFitted]
	|
	LDRB	R14, RTCFlag
	]

        TEQ     R14, #0
        BNE     %FT20

; no RTC - just set soft copy

 [ :LNOT: :DEF: TestHarness
        BL      RegToRealTime
 ]
        Pull    "R4, PC"

20
d946 1
a946 1
InitCMOSCache	ENTRY "r0-r5"
a948 12
; Need to set the slowest speed so we can probe

        MOV     R2, #0
      [ ClockNVMemoryFast
        MOV     R3, #10         ; Default speed setting (5s delays)
	[ :LNOT: :DEF: TestHarness
        STRB    R3, [R2, #NVRamSpeed]
	|
        STRB    R3, NVSpeed
	]
      ]

d957 1
a962 1
        MOV     R5, #4          ; assume 16 byte page size to start with
a968 3
      [ ClockNVMemoryFast
        MOVVC   R3, #3          ; Fast speed setting (1.5s delays)
      ]
d984 2
a985 6
; Have we got a 16K device ? (Note that this probe would make a 24C08 device respond -
; but if we've gotten this far it would have to be a < 512 byte version; we've never
; used such a device).

        MOV     r1, #E2ROMAddress16K
	MOV	r0, #E2ROMAddress16K
d987 1
a987 5
	MOVVC	R4, #64
        MOVVC   R5, #6          ; 64 byte page size
      [ ClockNVMemoryFast
        MOVVC   R3, #3          ; Fast speed setting (1.5s delays)
      ]
a988 1
        MOVVS   R5, #8          ; 256 byte page size for CMOS
a994 4
        STRB    R5, [R2, #NVRamPageSize]
      [ ClockNVMemoryFast
        STRB    R3, [R2, #NVRamSpeed]
      ]
a998 4
        STRB    R5, NVPageSize
      [ ClockNVMemoryFast
        STRB    R3, NVSpeed
      ]
d1028 1
a1028 5
        TST     R1, #&100               ; 2-byte address?
        MOVNE   R0, R2, LSR #8          ; memory word address (MSB)
        BLNE    TXAck

	AND	R0, R2, #&FF		; memory word address (LSB)
a1120 141

; *****************************************************************************
;
;       SWI OS_NVMemory
;
; in:   R0 = reason code
;

NVMemorySWI     ENTRY
        BL      NVMemorySub
        PullEnv
        ORRVS   LR, LR, #V_bit
        ExitSWIHandler

NVMemorySub
        CMP     R0, #4
        ADDLS   PC, PC, R0, LSL #2
        B       NVMemory_Unknown
        B       NVMemory_Size
        B       NVMemory_Read
        B       NVMemory_Write
        B       NVMemory_ReadBlock
        B       NVMemory_WriteBlock

NVMemory_Unknown
        ADRL    R0, ErrorBlock_HeapBadReason
 [ International
        Push    LR
        BL      TranslateError
        Pull    LR
 ]
        ORRS    PC, LR, #V_bit

; -----------------------------------------------------------------------------
; OS_NVMemory 0 - find NV memory size
;
; in:   R0 = 0
;
; out:  R1 = NV memory size in bytes
;
NVMemory_Size
  [     E2ROMSupport
        LDRB    R1, [R0, #NVRamSize]
        MOV     R1, R1, LSL #8
  |
        MOV     R1, #240
  ]
        MOVS    PC, LR

; -----------------------------------------------------------------------------
; OS_NVMemory 1 - read a byte
;
; in:   R0 = 1
;       R1 = location
;
; out:  R2 = value
;
NVMemory_Read
        ENTRY   "R4"
        MOV     R4, PC
        TEQP    PC, #SVC_mode   ; enable interrupts - this may take some time
        MOV     R0, R1
        BL      ReadWithError
        MOVVC   R2, R0
        MOVVC   R0, #1          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        TEQP    PC, R4          ; restore interrupt state
        EXIT

; -----------------------------------------------------------------------------
; OS_NVMemory 2 - write a byte
;
; in:   R0 = 1
;       R1 = location
;       R2 = value
;
NVMemory_Write ROUT
        [ ProtectStationID
        TEQ     R1, #0          ; just ignore writes to byte 0
        MOVEQ   PC, R14
        ]
        ENTRY   "R1,R4"
        MOV     R4, PC
        TEQP    PC, #SVC_mode   ; enable interrupts - this may take some time
        MOV     R0, R1
        MOV     R1, R2
        BL      WriteWithError
        MOVVC   R0, #2          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        TEQP    PC, R4          ; restore interrupt state
        EXIT

; -----------------------------------------------------------------------------
; OS_NVMemory 3 - read a block
;
; in:   R0 = 3
;       R1 = location
;       R2 = buffer
;       R3 = length
;
NVMemory_ReadBlock
        ENTRY   "R1-R4"
        MOV     R4, PC
        TEQP    PC, #SVC_mode   ; enable interrupts - this may take some time
        MOV     R0, R1
        MOV     R1, R2
        MOV     R2, R3
        BL      ReadBlock
        MOVVC   R0, #3          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        TEQP    PC, R4          ; restore interrupt state
        EXIT

; -----------------------------------------------------------------------------
; OS_NVMemory 4 - write a block
;
; in:   R0 = 3
;       R1 = location
;       R2 = buffer
;       R3 = length
;
NVMemory_WriteBlock ROUT
        ENTRY   "R1-R4"
        MOV     R4, PC
        TEQP    PC, #SVC_mode   ; enable interrupts - this may take some time
        [ ProtectStationID
        TEQ     R1, #0
        BNE     %FT10
        ADD     R1, R1, #1
        ADD     R2, R2, #1
        TEQ     R3, #0
        SUBNE   R3, R3, #1      ; steer clear of station ID
        ]
10      MOV     R0, R1
        MOV     R1, R2
        MOV     R2, R3
        BL      WriteBlock
        MOVVC   R0, #4          ; must preserve R0
        ORRVS   R4, R4, #V_bit
        TEQP    PC, R4          ; restore interrupt state
        EXIT
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d19 1
a19 29
; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Name  Description
; ----       ----  -----------
; 28-Mar-95  JRH   Added support for E2ROMs and/or CMOS, conditioned on
;                  E2ROMSupport which is defined elsewhere
;                  Uses RTCFitted and NVRamSize in KernelWS
; 03-Jul-96  JRH   Took out code conditioned on :LNOT: NewClockChip
;                  Fixed support for E2ROM. E2 works in the same gross way as
;                  CMOS. Any E2 fitted > 256 bytes will not be accessed by these
;                  routines.

PhysChecksum	*	(((CheckSumCMOS + &30) :MOD: &F0) + &10)

PollMax		*	&f	; Number of times to poll for an Ack

; Device addresses
RTCAddress	* &a0
  [	E2ROMSupport
E2ROMAddress	* &a8
  ]

; i2cWorkSpace is defined elsewhere to point somewhere sensible when debugging
  [ :LNOT: :DEF: TestHarness
i2cWorkSpace	* 0
  ]
	
d23 1
a23 1
;	HexToBCD - Convert byte in hex to BCD
d25 1
a25 1
; in:	R0 = byte in hex
d27 2
a28 2
; out:	R0 = byte in BCD (ie R0 := (R0 DIV 10)*16 + R0 MOD 10)
;	All other registers preserved
d32 5
a36 5
	Push	"R1,R2, R14"
	MOV	R1, #10
	DivRem	R2, R0, R1, R14			; R2=R0 DIV 10; R0=R0 MOD 10
	ADD	R0, R0, R2, LSL #4
	Pull	"R1,R2, PC"
d40 1
a40 1
;	BCDToHex - Convert byte in BCD to hex
d42 1
a42 1
; in:	R0 = byte in BCD (ie x*16 + y)
d44 2
a45 2
; out:	R0 = byte in hex (ie x*10 + y)
;	All other registers preserved
d49 5
a53 5
	Push	"R14"
	MOV	R14, R0, LSR #4			; R14 := x
	ADD	R14, R14, R14, LSL #1		; R14 := x*3
	SUB	R0, R0, R14, LSL #1		; R0 := R0 - x*6 = x*10
	Pull	"PC"
d57 1
a57 1
;	SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
d59 1
a59 1
; out:	All registers preserved, including PSR
d63 2
a64 2
	Push	"R0-R2,R14"
	ADD	R0, R0, R1, LSL #1	; R0 := C0 + C1*2
d66 11
a76 11
	[ AssemblingArthur :LOR: Module
	MOV	R2, #0				; prepare to index soft copy
	LDRB	R1, [R2, #IOCControlSoftCopy]	; read soft copy
	BIC	R1, R1, #&03			; clear clock and data
	ORR	R0, R1, R0			; put in new clock and data
	ORR	R0, R0, #&C0			; make sure two test bits are
						; always set to 1 !
	STRB	R0, [R2, #IOCControlSoftCopy]	; store back to soft copy
	|
	ORR	R0, R0, #&FC			; set other bits to 1
	]
d78 2
a79 2
	MOV	R2, #IOC
	STRB	R0, [R2, #IOCControl]
d81 2
a82 2
	MOV	R0, #10			; delay for >= 10/2 microsecs
	BL	DoMicroDelay
d84 1
a84 1
	Pull	"R0-R2,PC",,^
d88 1
a88 1
;	DoMicroDelay - Delay for >= R0/2 microseconds
d90 3
a92 3
; in:	R0 = time delay in 1/2 microsecond units
;	R2 -> IOC
;	On ARM600, we may or may not be in a 32-bit mode
d94 1
a94 1
; out:	R0,R1 corrupted
d98 1
a98 1
	Push	R14
d100 2
a101 2
	STRB	R0, [R2, #Timer0LR]	; copy counter into output latch
	LDRB	R1, [R2, #Timer0CL]	; R1 := low output latch
d103 7
a109 7
	STRB	R0, [R2, #Timer0LR]	; copy counter into output latch
	LDRB	R14, [R2, #Timer0CL]	; R14 := low output latch
	TEQ	R14, R1			; unchanged ?
	BEQ	%BT10			; then loop
	MOV	R1, R14			; copy anyway
	SUBS	R0, R0, #1		; decrement count
	BNE	%BT10			; loop if not finished
d111 1
a111 1
	Pull	PC
d113 1
a113 1
	LTORG
d117 1
a117 1
;	ClockData - Clock a bit of data down the IIC bus
d119 1
a119 1
; in:	R0 = data bit
d121 1
a121 1
; out:	All registers preserved, including PSR
d125 1
a125 1
	Push	"R1, R14"
d127 2
a128 2
	MOV	R1, #0			; Clock lo
	BL	SetC1C0
d134 3
a136 3
	MOV	R1,PC
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
d138 2
a139 2
	MOV	R1, #1			; Clock hi
	BL	SetC1C0
d143 2
a144 2
	MOV	R1, #0			; Clock lo
	BL	SetC1C0
d146 1
a146 1
	Pull	"R1, PC",,^
d148 5
a152 5
ClockData0 ROUT				; Clock a zero bit
	Push	"R0, R14"
	MOV	R0, #0
	BL	ClockData
	Pull	"R0, PC",,^
d156 1
a156 1
;	Start - Send the Start signal
d158 1
a158 1
; out:	All registers preserved, including PSR
d161 2
a162 2
Start	ROUT
	Push	"R0-R2,R14"
d164 3
a166 3
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0
d170 3
a172 3
	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
	BL	SetC1C0
d177 3
a179 3
	MOV	R2, #IOC
	MOV	R0,#10
	BL	DoMicroDelay
d184 3
a186 3
	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
	BL	SetC1C0
d188 1
a188 1
	Pull	"R0-R2,PC",,^
d192 1
a192 1
;	Acknowledge - Check acknowledge after transmitting a byte
d194 3
a196 3
; out:	All registers preserved
;	V=0 => acknowledge received
;	V=1 => no acknowledge received
d200 1
a200 1
	Push	"R0-R2,R14"
d202 3
a204 3
	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
	BL	SetC1C0
d210 8
a217 8
	MOV	R1,PC
	Push	"R1"
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
 ]
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0
d221 2
a222 2
	MOV	R2, #IOC
	LDRB	R2, [R2, #IOCControl]	; get the data from IOC
d224 3
a226 3
	MOV	R0, #0
	MOV	R1, #0			; clock lo
	BL	SetC1C0
d229 2
a230 2
	Pull	"R1"
	TEQP	PC,R1
d233 5
a237 5
	TST	R2, #1			; should be LO for correct acknowledge
	MOV	R2, PC
	BICEQ	R2, R2, #V_bit		; clear V if correct acknowledge
	ORRNE	R2, R2, #V_bit		; set V if no acknowledge
	TEQP	R2, #0
d239 1
a239 1
	Pull	"R0-R2,PC"
d243 1
a243 1
;	Stop - Send the Stop signal
d245 1
a245 1
; out:	All registers preserved, including PSR
d248 2
a249 2
Stop	ROUT
	Push	"R0,R1,R14"
d251 3
a253 3
	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
	BL	SetC1C0
d257 3
a259 14
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
	BL	SetC1C0

	Pull	"R0,R1,PC",,^

; *****************************************************************************
;
;	TXByte - Transmit a byte
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved, including PSR
;
d261 1
a261 11
TXByte	ROUT
	Push	"R0-R2,R14"
	MOV	R2, R0			; byte goes into R2
	MOV	R1, #&80		; 2^7 the bit mask
10
	ANDS	R0, R2, R1		; zero if bit is zero
	MOVNE	R0, #1
	BL	ClockData		; send the bit
	MOVS	R1, R1, LSR #1
	BNE	%BT10
	Pull	"R0-R2,PC",,^
d265 1
a265 4
;	StartTXPollAck - Transmit start and a byte and poll for acknowledge
;
;	This is intended for devices with a slow internal write cycle which
;	don't ack until the write cycle is finished ( eg ATMEL AT24C01A/x )
d267 1
a267 1
; in:	R0 = byte to be transmitted
d269 1
a269 1
; out:	All registers preserved, including PSR
d272 4
a275 3
StartTXPollAck	ROUT
	Push	"R1,R14"
	MOV	R1, #0
d277 6
a282 12
	INC	R1
	CMP	R1, #PollMax
	Pull	"R1,pc", EQ

	BL	Start
	BL	TXByte
	BL	Acknowledge
	BVS	%BT10
 [	{FALSE}
	BREG	R1, "i2c tries:"
 ]
	Pull	"R1,pc",,^
d286 1
a286 1
;	RXByte - Receive a byte
d288 2
a289 2
; out:	R0 = byte received
;	All other registers preserved, including PSR
d292 5
a296 5
RXByte	ROUT
	Push	"R1-R4, R14"
	MOV	R3, #0			; byte:=0
	MOV	R2, #IOC
	MOV	R4, #7
d298 3
a300 3
	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
	BL	SetC1C0
d306 16
a321 16
	MOV	R1,PC
	Push	"R1"
	ORR	R1,R1,#I_bit
	TEQP	PC,R1
 ]
	MOV	R0, #1			; pulse clock HI
	MOV	R1, #1
	BL	SetC1C0

	LDRB	R1, [R2, #IOCControl]	; get the data from IOC
	AND	R1, R1, #1
	ADD	R3, R1, R3, LSL #1	; byte:=byte*2+(IOC?0)AND1

	MOV	R0, #1			; return clock LO
	MOV	R1, #0
	BL	SetC1C0
d324 2
a325 2
	Pull	"R1"
	TEQP	PC,R1
d327 2
a328 19
	SUBS	R4, R4, #1
	BCS	%BT10

	MOV	R0, R3			; return the result in R0
	Pull	"R1-R4, PC",,^

; *****************************************************************************

HTBTA	ROUT
	Push	R14
	BL	HexToBCD
	BL	TXAck
	Pull	PC

TXAck	ROUT
	Push	R14
	BL	TXByte
	BL	Acknowledge
	Pull	PC
d330 2
a331 6
CD0RBTH ROUT
	Push	R14
	BL	ClockData0
	BL	RXByte
	BL	BCDToHex
	Pull	PC
d335 1
a335 1
;	Write - Write a byte of CMOS RAM specified by logical address
d337 2
a338 2
; in:	R0 = address in CMOS RAM
;	R1 = data
d340 1
a340 1
; out:	All registers preserved
d343 4
a346 4
Write	ROUT
	Push	"R0-R4, R14"
	BL	MangleCMOSAddress
	Pull	"R0-R4, PC", CS		; if invalid, then exit
d348 9
a356 9
	MOV	R2, R0
	MOV	R3, R1
 [ ChecksumCMOS
	BL	ReadStraight		; calculate new checksum :
	MOV	R4, R0
	MOV	R0, #PhysChecksum
	BL	ReadStraight
	SUB	R0, R0, R4		; = oldsum - oldcontents
	ADD	R4, R0, R3		;          + newcontents
d358 4
a361 4
	AND	R4, R4, #&FF
	CMPS	R2, #PhysChecksum	; don't write new checksum ...
	ORREQ	R4, R4, #&1000000	; if checksum is being written
 ]
d364 2
a365 12
	ADR	R1, CMOSRAMCache-16	; update cache, but always write to
  [ :DEF: TestHarness
	ADD	R1, R1, #i2cWorkSpace
  ]
	STRB	R3, [R1, R2]		; real hardware as well
 ]
 [ E2ROMSupport
	MOV	R0, R2
	BL	GetI2CAddress		; convert to device address + offset
	MOV	R2, R0			; save the offset
 |
	MOV	R1, #RTCAddress
d367 1
d369 2
a370 2
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck
d372 15
a386 15
	MOV	R0, R2			; offset
	BL	TXAck

	MOV	R0, R3			; data
	BL	TXAck

	BL	Stop
	[ ChecksumCMOS
	TST	R4, #&1000000		; loop again to write new checksum
	MOV	R3, R4
	MOV	R2, #PhysChecksum
	ORR	R4, R4, #&1000000	; but ensure it only happens once
	BEQ	%BT10
	]
	Pull	"R0-R4, PC"
d390 2
a391 2
;	Read - Read a byte of CMOS RAM specified by logical address
;	ReadStraight - Read a byte of CMOS RAM specified by physical address
d393 1
a393 1
; in:	R0 = address in CMOS RAM
d395 2
a396 2
; out:	R0 = data (illegal address return 0)
;	All other registers preserved
d400 2
a401 2
	Push	"R1,R2,R14"
	B	%FT10
d404 4
a407 4
	Push	"R1,R2,R14"
	BL	MangleCMOSAddress
	MOVCS	R0, #0			; pretend illegal addresses contain 0
	Pull	"R1,R2,PC", CS
d409 8
a416 8
  [	CacheCMOSRAM
	TEQ	R0, #&40		; is it Econet station number
	BEQ	%FT15	 		; if so then don't use cache
	CMP	R0, #&10		; don't cache values < &10
	ADRCS	R2, CMOSRAMCache-&10	; if in range

  [ :DEF: TestHarness
	ADD	R2, R2, #i2cWorkSpace
d418 4
a421 2
	LDRCSB	R0, [R2, R0]		; read from cache
	Pull	"R1,R2,PC", CS		; and exit
d425 3
a427 1
  ]
d429 1
a429 5
  [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
  |
	MOV	R1, #RTCAddress
  ]
d431 2
a432 3
	MOV	R2, R0			; save the offset
	MOV	R0, R1			; device address for write
	BL	StartTXPollAck
d434 2
a435 2
	MOV	R0, R2			; offset
	BL	TXAck
d437 1
a437 1
	BL	Start
d439 2
a440 2
	ADD	R0, R1, #1		; device address for read
	BL	TXAck
d442 2
a443 2
	BL	RXByte			; returned in R0
	MOV	R2, R0			; copy to R2 for now
d445 2
a446 2
	MOV	R0, #1
	BL	ClockData
d448 1
a448 1
	BL	Stop
d450 1
a450 1
	MOV	R0, R2			; return the result
d452 1
a452 1
	Pull	"R1,R2,PC"
d456 1
a456 2
;	GetI2CAddress - Convert NVRam physical address to i2c device address
;	                and offset
d458 1
a458 1
; in:	R0 = NVRam physical address (&00..size of NVRam)
d460 2
a461 1
; out:	R0 preserved
d463 2
a464 4
;	C=0 => NVRam address is valid 
;	 R0 = physical address within i2c device
;	 R1 = i2c device address for writing. Increment this device address
;	      by 1 for reading.
a465 18
;	C=1 => NVRam address is out of range of CMOS or E2ROM chips
;	 R0 preserved
;	 R1 preserved

  [	E2ROMSupport
GetI2CAddress ROUT
	CMP	R0, #&100
	ORRCSS	PC, R14, #C_bit		; indicate invalid

; address is <&100 -> is valid
	MOV	R1, #i2cWorkSpace
	LDRB	R1, [R1, #RTCFitted]
	TEQ	R1, #1
	MOVEQ	R1, #RTCAddress
	MOVNE	R1, #E2ROMAddress

	BICS	PC, R14, #C_bit		; indicate valid
  ]
d467 7
a475 13
;
;	MangleCMOSAddress - Convert from logical to physical address
;
;	Doesn't check if address is larger than the amount of NVRam installed
;
; in:	R0 = logical address (&00..&EF, &100..)
;
; out:	C=0 => valid logical address (ie not &F0..&FF)
;	 R0 = physical address (&40..&FF,&10..&3F,&100..)
;
;	C=1 => invalid logical address (ie &F0..&FF)
;	 R0 preserved
;
d477 11
a487 3
MangleCMOSAddress ROUT
	CMP	R0, #&F0		; if address &f0 or above
	ORRCSS	PC, R14, #C_bit		; indicate invalid
d489 6
a494 4
	ADD	R0, R0, #&40		; now in range &40..&13F
	CMP	R0, #&100
	SUBCS	R0, R0, #(&100-&10)	; now in range &40..&FF, &10..&3F
	BICS	PC, R14, #C_bit		; indicate valid
a495 1
		
d498 1
a498 2
;	ValChecksum - test to see if the CMOS checksum is OK
;
d502 1
a502 1
; in:	none
d504 3
a506 3
; out:	R0 = calculated checksum
;	Z	set if checksum is valid
;	All other registers preserved
d509 1
a509 1
  [ ChecksumCMOS
d511 2
a512 1
ValChecksum	ENTRY "R1,R2,R3"
d514 4
a517 9
	MOV	R3, #CMOSxseed
    [ E2ROMSupport
	MOV	R0, #&40
	BL	GetI2CAddress		; r1 = device address, r0 = offset
	MOV	R2, R0			; save the offset
    |
	MOV	R2, #&40
	MOV	R1, #RTCAddress
    ]
d519 1
a519 5
	MOV	R0, R1	 		; device write address
	BL	StartTXPollAck
	
	MOV	R0, R2			; memory offset
	BL	TXAck
d521 2
a522 1
	BL	Start
d524 2
a525 2
	ADD	R0, R1, #1		; device read address
	BL	TXAck
d527 4
d532 1
a532 1
; Read data from locations &40 through &FF, then
d537 2
a538 12
	BL	RXByte			; returned in R0
	ADD	R3, R3, R0		; accumulate into R3

	ADD	R2, R2, #1		; increment R2 to phys. address
	TEQ	R2, #&100		; limit
	BEQ	%30
	TEQ	R2, #PhysChecksum	; or until checksum.
	BEQ	%30			; then we're finished

	MOV	R0, #0			; not done .. ACK that byte
	BL	ClockData
	B	%BT20			; .. and continue reading
d540 9
d550 6
a555 7
	MOV	R0, #1			; finish off reading block
	BL	ClockData
	BL	Stop

        TST     R2, #&100		; either go back for bytes 10 - 3f
        MOVNE   R2, #&10		; or finish up completely.
	BNE	%BT10
d560 5
a564 5
	MOV	R0, #PhysChecksum
	BL	ReadStraight
	AND	R2, R0, #&FF		; value from checksum location
	AND	R0, R3, #&FF		; calculated value into R0
	CMPS	R0, R2
d566 2
a567 2
	EXIT
  ]				 
d571 1
a571 1
;	MakeChecksum - calculate and write a correct checksum
d573 1
a573 1
; in:	none
d575 2
a576 2
; out:	R0 = calculated checksum
;	All other registers preserved
d579 1
a579 1
	[ ChecksumCMOS
d581 8
a588 8
MakeChecksum	ROUT
	Push	R14
	BL	ValChecksum
	MOV	R1, R0
	MOV	R0, #CheckSumCMOS
	BL	Write
	Pull	PC
	]
d592 1
a592 1
;	SetTime - Write the CMOS clock time and update 5-byte RealTime
d594 8
a601 9
; in:	UTC time:
;	R0 = hours
;	R1 = minutes
;	R2 = day of month
;	R3 = month
;	R5 = year (lo)
;	R6 = year (hi)
;	R7 = seconds
;	R8 = centiseconds
d603 1
a603 1
;	Any of the above, if -1, will not be written to
d607 1
a607 1
	Push	"R4, R14"		; save registers
d609 21
a629 1
; write year to CMOS RAM
d631 14
a644 1
	MOV	R4, R0			; save hours in R4
d646 1
a646 32
	Push	"R1"
	MOVS	R1, R5
	MOVPL	R0, #YearCMOS
	BLPL	Write
	MOVS	R1, R6
	MOVPL	R0, #YearCMOS+1
	BLPL	Write

	CMP	R4, #-1			; are we writing time ?
	Pull	"R1",EQ			; [no, then skip]
	BEQ	%FT30

	MOV	R0, #&01		; start at address 1
    [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R0, R1			; write address
    |
	MOV	R0, #RTCAddress
    ]
	Pull	"R1"
	BL	StartTXPollAck
	MOV	R0, #&01		; offset 1
	BL	TXAck
	MOV	R0, R8			; centiseconds
	BL	HTBTA
	MOV	R0, R7			; seconds
	BL	HTBTA
	MOV	R0, R1			; minutes
	BL	HTBTA
	MOV	R0, R4			; hours
	BL	HTBTA
	BL	Stop
d648 40
d689 2
a690 2
	CMP	R2, #-1			; are we writing date ?
	BEQ	%FT40			; [no, then skip]
d692 28
a719 17
	MOV	R0, #&05		; start at address 5
    [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R0, R1			; write address
    |
	MOV	R0, #RTCAddress
    ]
	BL	StartTXPollAck
	MOV	R0, #&05		; offset 5
	BL	TXAck
	MOV	R0, R2			; day of month
	BL	HexToBCD
	ORR	R0, R0, R5, LSL #6	; year in bits 6,7; day in bits 0..5
	BL	TXAck
	MOV	R0, R3			; months
	BL	HTBTA
	BL	Stop
d721 1
a721 6
40
	MOV	R0, R4			; put hours back in R0
  [ :LNOT: :DEF: TestHarness
	BL	RTCToRealTime
  ]
	Pull	"R4, PC"
d725 1
a725 1
;	ReadTime - Read the CMOS clock time
d727 1
a727 1
; in:	-
d729 8
a736 8
; out:	R0 = hours
;	R1 = minutes
;	R2 = days
;	R3 = months
;	R5 = year (lo)
;	R6 = year (hi)
;	R7 = seconds
;	R8 = centiseconds
d740 1
a740 1
	Push	"R4, R14"
d742 63
a804 47
	MOV	R0, #&01		; start at address 1
    [	E2ROMSupport
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R0, R1			; write address
    |
	MOV	R0, #RTCAddress
    ]
	BL	StartTXPollAck
	MOV	R0, #&01		; offset 1
	BL	TXAck
	BL	Start
    [	E2ROMSupport
	ADD	R0, R1, #1		; read address
    |
	MOV	R0, #(RTCAddress+1)	; read address
    ]
	BL	TXAck
	BL	RXByte
	BL	BCDToHex
	MOV	R8, R0			; centiseconds
	BL	CD0RBTH
	MOV	R7, R0			; seconds
	BL	CD0RBTH
	MOV	R1, R0			; minutes
	BL	CD0RBTH
	MOV	R4, R0			; hours
	BL	ClockData0
	BL	RXByte
	AND	R0, R0, #&3F		; day of month (clear year bits)
	BL	BCDToHex
	MOV	R2, R0
	BL	ClockData0
	BL	RXByte
	AND	R0, R0, #&1F		; month (clear day of week bits)
	BL	BCDToHex
	MOV	R3, R0
	MOV	R0, #1
	BL	ClockData
	BL	Stop

	MOV	R0, #YearCMOS
	BL	Read
	MOV	R5, R0			; year (lo)

	MOV	R0, #YearCMOS+1
	BL	Read
	MOV	R6, R0			; year (hi)
d806 1
a806 1
	MOV	R0, R4			; put hours in R0
d809 5
a813 5
 [ {TRUE}				; LRust, fix RP-0370
	TEQ	R2, #0			; Valid day?
	MOVEQ	R2, #1			; No then force 1st
	TEQ	R3, #0			; Invalid month?
	MOVEQ	R3, #1			; Yes then force Jan
d815 1
a815 1
	Pull	"R4, PC"
d819 1
a819 1
;	InitCMOSCache - Initialise cache of CMOS RAM
d821 1
a821 1
  [	CacheCMOSRAM
d823 3
a825 43
InitCMOSCache	ENTRY "r0-r3"
    [	E2ROMSupport

;	First determine what hardware we've got fitted, R3 holds the number of
;	256 byte blocks that we've found
	
	; Have we got an RTC ?
	MOV	R0, #RTCAddress
	BL	DummyAccess
	MOVVS	R3, #0
	MOVVC	R3, #1
	MOV	R2, #i2cWorkSpace
	STRB	R3, [R2, #RTCFitted]

; Have we got a 1K E ?
	MOV	r0, #(E2ROMAddress+6)
	BL	DummyAccess
	ADDVC	R3, R3, #4
	BVC	%FT5

; Have we got 512 bytes of E ?
	MOV	r0, #(E2ROMAddress+2)
	BL	DummyAccess
	ADDVC	R3, R3, #4
	BVC	%FT5

; Have we got any E ?
	MOV	r0, #(E2ROMAddress)
	BL	DummyAccess
	ADDVC	R3, R3, #1

	; Set the NVRam count
5	STRB	R3, [R2, #NVRamSize]

	; Initialise the cache
	MOV	R0, #&10
	BL	GetI2CAddress		; convert to device address and offset
	MOV	R2, R0			; save the offset
    |
	MOV	R1, #RTCAddress
	MOV	R2, #&10
    ]
	ADR	R3, CMOSRAMCache-16
d827 1
a827 4
    [	:DEF: TestHarness
	ADD	R3, R3, #i2cWorkSpace
    ]
	BL	Start
d829 2
a830 2
	MOV	R0, R1			; write address
	BL	TXAck
d832 2
a833 2
	MOV	R0, R2			; memory word address
	BL	TXAck
d835 1
a835 1
	BL	Start
d837 2
a838 2
	ADD	R0, R1, #1		; read address
	BL	TXAck
d841 9
a849 9
	BL	RXByte			; returned in R0
	STRB	R0, [R3, R2]
	ADD	R2, R2, #1		; increment R2 to phys. address
	CMP	R2, #&100
	BEQ	%FT20

	MOV	R0, #0			; not done .. ACK that byte
	BL	ClockData
	B	%BT10			; .. and continue reading
d851 4
a854 4
	MOV	R0, #1			; finish off reading block
	BL	ClockData
	BL	Stop
	EXIT
d856 2
a857 26
  ]


; *****************************************************************************
;
;	DummyAccess - do a dummy access of the specified device to find out
;	              if it is present
;
; in:	R0 = Write address of device
;
; out:	All registers preserved
;	V=0 => device is present
;	V=1 => device is not present

; Have we got an RTC ? do a read from location 0 to find out

  [ E2ROMSupport
DummyAccess	ENTRY

	BL	Start
	BL	TXAck			; do write and set V if no ack 
	BL	Stop			; Doesn't change the PSR
	EXIT				; Exit with V set appropriately
  ]

	END
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.12;
access;
symbols
	Kernel-6_15:4.12
	Kernel-6_14:4.12
	Kernel-6_01-3:4.12
	Kernel-6_13:4.12
	Kernel-6_12:4.12
	Kernel-6_11:4.12
	Kernel-6_10:4.12
	Kernel-6_09:4.12
	Kernel-6_08-4_129_2_10:4.9.2.3
	Kernel-6_08-4_129_2_9:4.9.2.3
	Kernel-6_08:4.12
	Kernel-6_07:4.12
	Kernel-6_06:4.12
	Kernel-6_05-4_129_2_8:4.9.2.3
	Kernel-6_05:4.12
	Kernel-6_04:4.12
	Kernel-6_03:4.12
	Kernel-6_01-2:4.12
	Kernel-6_01-4_146_2_1:4.12
	Kernel-6_02:4.12
	Kernel-6_01-1:4.12
	Kernel-6_01:4.12
	Kernel-6_00:4.12
	Kernel-5_99:4.12
	Kernel-5_98:4.11
	Kernel-5_97-4_129_2_7:4.9.2.2
	Kernel-5_97:4.11
	Kernel-5_96:4.11
	Kernel-5_95:4.11
	Kernel-5_94:4.10
	Kernel-5_93:4.10
	Kernel-5_92:4.10
	Kernel-5_91:4.10
	Kernel-5_90:4.10
	Kernel-5_89-4_129_2_6:4.9.2.1
	Kernel-5_89:4.10
	Kernel-5_88-4_129_2_5:4.9
	Kernel-5_88-4_129_2_4:4.9
	Kernel-5_88:4.9
	Kernel-5_87:4.9
	Kernel-5_86-4_129_2_3:4.9
	Kernel-5_86-4_129_2_2:4.9
	Kernel-5_86-4_129_2_1:4.9
	Kernel-5_86:4.9
	SMP:4.9.0.2
	SMP_bp:4.9
	Kernel-5_85:4.9
	Kernel-5_54-1:4.9
	Kernel-5_84:4.9
	Kernel-5_83:4.9
	Kernel-5_82:4.9
	Kernel-5_81:4.9
	Kernel-5_80:4.9
	Kernel-5_79:4.9
	Kernel-5_78:4.9
	Kernel-5_77:4.9
	Kernel-5_76:4.9
	Kernel-5_75:4.9
	Kernel-5_74:4.9
	Kernel-5_73:4.9
	Kernel-5_72:4.9
	Kernel-5_71:4.9
	Kernel-5_70:4.9
	Kernel-5_69:4.9
	Kernel-5_68:4.9
	Kernel-5_67:4.9
	Kernel-5_66:4.9
	Kernel-5_65:4.9
	Kernel-5_64:4.9
	Kernel-5_63:4.9
	Kernel-5_62:4.9
	Kernel-5_61:4.9
	Kernel-5_60:4.9
	Kernel-5_59:4.9
	Kernel-5_58:4.9
	Kernel-5_57:4.9
	Kernel-5_56:4.9
	Kernel-5_55:4.9
	Kernel-5_54:4.9
	Kernel-5_53:4.9
	Kernel-5_52:4.9
	Kernel-5_51:4.9
	Kernel-5_50:4.8
	Kernel-5_49:4.8
	HAL_merge:4.6.2.11
	Kernel-5_48:4.7
	Kernel-5_35-4_79_2_327:4.6.2.11
	Kernel-5_35-4_79_2_326:4.6.2.11
	Kernel-5_35-4_79_2_325:4.6.2.11
	Kernel-5_35-4_79_2_324:4.6.2.11
	Kernel-5_35-4_79_2_323:4.6.2.11
	Kernel-5_35-4_79_2_322:4.6.2.11
	Kernel-5_35-4_79_2_321:4.6.2.11
	Kernel-5_35-4_79_2_320:4.6.2.11
	Kernel-5_35-4_79_2_319:4.6.2.11
	Kernel-5_35-4_79_2_318:4.6.2.11
	Kernel-5_35-4_79_2_317:4.6.2.11
	Kernel-5_35-4_79_2_316:4.6.2.11
	Kernel-5_35-4_79_2_315:4.6.2.11
	Kernel-5_35-4_79_2_314:4.6.2.11
	Kernel-5_35-4_79_2_313:4.6.2.11
	Kernel-5_35-4_79_2_312:4.6.2.11
	Kernel-5_35-4_79_2_311:4.6.2.11
	Kernel-5_35-4_79_2_310:4.6.2.11
	Kernel-5_35-4_79_2_309:4.6.2.11
	Kernel-5_35-4_79_2_308:4.6.2.11
	Kernel-5_35-4_79_2_307:4.6.2.11
	Kernel-5_35-4_79_2_306:4.6.2.11
	Kernel-5_35-4_79_2_305:4.6.2.11
	Kernel-5_35-4_79_2_304:4.6.2.11
	Kernel-5_35-4_79_2_303:4.6.2.11
	Kernel-5_35-4_79_2_302:4.6.2.11
	Kernel-5_35-4_79_2_301:4.6.2.11
	Kernel-5_35-4_79_2_300:4.6.2.11
	Kernel-5_35-4_79_2_299:4.6.2.11
	Kernel-5_35-4_79_2_298:4.6.2.11
	Kernel-5_35-4_79_2_297:4.6.2.11
	Kernel-5_35-4_79_2_296:4.6.2.11
	Kernel-5_35-4_79_2_295:4.6.2.11
	Kernel-5_35-4_79_2_294:4.6.2.11
	Kernel-5_35-4_79_2_293:4.6.2.11
	Kernel-5_35-4_79_2_292:4.6.2.11
	Kernel-5_35-4_79_2_291:4.6.2.11
	Kernel-5_35-4_79_2_290:4.6.2.11
	Kernel-5_35-4_79_2_289:4.6.2.11
	Kernel-5_35-4_79_2_288:4.6.2.11
	Kernel-5_35-4_79_2_287:4.6.2.11
	Kernel-5_35-4_79_2_286:4.6.2.11
	Kernel-5_35-4_79_2_285:4.6.2.11
	Kernel-5_35-4_79_2_284:4.6.2.11
	Kernel-5_35-4_79_2_283:4.6.2.11
	Kernel-5_35-4_79_2_282:4.6.2.11
	Kernel-5_35-4_79_2_281:4.6.2.11
	Kernel-5_35-4_79_2_280:4.6.2.11
	Kernel-5_35-4_79_2_279:4.6.2.11
	Kernel-5_35-4_79_2_278:4.6.2.11
	Kernel-5_35-4_79_2_277:4.6.2.11
	Kernel-5_35-4_79_2_276:4.6.2.11
	Kernel-5_35-4_79_2_275:4.6.2.11
	Kernel-5_35-4_79_2_274:4.6.2.11
	Kernel-5_35-4_79_2_273:4.6.2.11
	Kernel-5_35-4_79_2_272:4.6.2.11
	Kernel-5_35-4_79_2_271:4.6.2.11
	Kernel-5_35-4_79_2_270:4.6.2.11
	Kernel-5_35-4_79_2_269:4.6.2.11
	Kernel-5_35-4_79_2_268:4.6.2.11
	Kernel-5_35-4_79_2_267:4.6.2.11
	Kernel-5_35-4_79_2_266:4.6.2.11
	Kernel-5_35-4_79_2_265:4.6.2.11
	Kernel-5_35-4_79_2_264:4.6.2.11
	Kernel-5_35-4_79_2_263:4.6.2.11
	Kernel-5_35-4_79_2_262:4.6.2.11
	Kernel-5_35-4_79_2_261:4.6.2.11
	Kernel-5_35-4_79_2_260:4.6.2.11
	Kernel-5_35-4_79_2_259:4.6.2.11
	Kernel-5_35-4_79_2_258:4.6.2.11
	Kernel-5_35-4_79_2_257:4.6.2.11
	Kernel-5_35-4_79_2_256:4.6.2.11
	Kernel-5_35-4_79_2_255:4.6.2.11
	Kernel-5_35-4_79_2_254:4.6.2.11
	Kernel-5_35-4_79_2_253:4.6.2.11
	Kernel-5_35-4_79_2_252:4.6.2.11
	Kernel-5_35-4_79_2_251:4.6.2.11
	Kernel-5_35-4_79_2_250:4.6.2.11
	Kernel-5_35-4_79_2_249:4.6.2.11
	Kernel-5_35-4_79_2_248:4.6.2.11
	Kernel-5_35-4_79_2_247:4.6.2.11
	Kernel-5_35-4_79_2_246:4.6.2.11
	Kernel-5_35-4_79_2_245:4.6.2.11
	Kernel-5_35-4_79_2_244:4.6.2.11
	Kernel-5_35-4_79_2_243:4.6.2.11
	Kernel-5_35-4_79_2_242:4.6.2.11
	Kernel-5_35-4_79_2_241:4.6.2.11
	Kernel-5_35-4_79_2_240:4.6.2.11
	Kernel-5_35-4_79_2_239:4.6.2.11
	Kernel-5_35-4_79_2_238:4.6.2.11
	Kernel-5_35-4_79_2_237:4.6.2.11
	Kernel-5_35-4_79_2_236:4.6.2.11
	Kernel-5_35-4_79_2_235:4.6.2.11
	Kernel-5_35-4_79_2_234:4.6.2.11
	Kernel-5_35-4_79_2_233:4.6.2.11
	Kernel-5_35-4_79_2_232:4.6.2.11
	Kernel-5_35-4_79_2_231:4.6.2.11
	Kernel-5_35-4_79_2_230:4.6.2.11
	Kernel-5_35-4_79_2_229:4.6.2.11
	Kernel-5_35-4_79_2_228:4.6.2.11
	Kernel-5_35-4_79_2_227:4.6.2.11
	Kernel-5_35-4_79_2_226:4.6.2.11
	Kernel-5_35-4_79_2_225:4.6.2.11
	Kernel-5_35-4_79_2_224:4.6.2.11
	Kernel-5_35-4_79_2_223:4.6.2.11
	Kernel-5_35-4_79_2_222:4.6.2.11
	Kernel-5_35-4_79_2_221:4.6.2.11
	Kernel-5_35-4_79_2_220:4.6.2.11
	Kernel-5_35-4_79_2_219:4.6.2.11
	Kernel-5_35-4_79_2_218:4.6.2.11
	Kernel-5_35-4_79_2_217:4.6.2.11
	Kernel-5_35-4_79_2_216:4.6.2.11
	Kernel-5_35-4_79_2_215:4.6.2.11
	Kernel-5_35-4_79_2_214:4.6.2.11
	Kernel-5_35-4_79_2_213:4.6.2.11
	Kernel-5_35-4_79_2_212:4.6.2.11
	Kernel-5_35-4_79_2_211:4.6.2.11
	Kernel-5_35-4_79_2_210:4.6.2.11
	Kernel-5_35-4_79_2_209:4.6.2.11
	Kernel-5_35-4_79_2_208:4.6.2.11
	Kernel-5_35-4_79_2_207:4.6.2.11
	Kernel-5_35-4_79_2_206:4.6.2.11
	Kernel-5_35-4_79_2_205:4.6.2.11
	Kernel-5_35-4_79_2_204:4.6.2.11
	Kernel-5_35-4_79_2_203:4.6.2.10
	Kernel-5_35-4_79_2_202:4.6.2.10
	Kernel-5_35-4_79_2_201:4.6.2.9
	Kernel-5_35-4_79_2_200:4.6.2.9
	Kernel-5_35-4_79_2_199:4.6.2.9
	Kernel-5_35-4_79_2_198:4.6.2.9
	Kernel-5_35-4_79_2_197:4.6.2.9
	Kernel-5_35-4_79_2_196:4.6.2.9
	Kernel-5_35-4_79_2_195:4.6.2.9
	Kernel-5_35-4_79_2_194:4.6.2.9
	Kernel-5_35-4_79_2_193:4.6.2.9
	Kernel-5_35-4_79_2_192:4.6.2.9
	Kernel-5_35-4_79_2_191:4.6.2.9
	Kernel-5_35-4_79_2_190:4.6.2.9
	Kernel-5_35-4_79_2_189:4.6.2.9
	Kernel-5_35-4_79_2_188:4.6.2.9
	Kernel-5_35-4_79_2_187:4.6.2.9
	Kernel-5_35-4_79_2_186:4.6.2.9
	Kernel-5_35-4_79_2_185:4.6.2.9
	Kernel-5_35-4_79_2_184:4.6.2.9
	Kernel-5_35-4_79_2_183:4.6.2.9
	Kernel-5_35-4_79_2_182:4.6.2.9
	Kernel-5_35-4_79_2_181:4.6.2.9
	Kernel-5_35-4_79_2_180:4.6.2.9
	Kernel-5_35-4_79_2_179:4.6.2.9
	Kernel-5_35-4_79_2_178:4.6.2.9
	Kernel-5_35-4_79_2_177:4.6.2.8
	Kernel-5_35-4_79_2_176:4.6.2.8
	Kernel-5_35-4_79_2_175:4.6.2.8
	Kernel-5_35-4_79_2_174:4.6.2.8
	Kernel-5_35-4_79_2_173:4.6.2.8
	Kernel-5_35-4_79_2_172:4.6.2.8
	Kernel-5_35-4_79_2_171:4.6.2.8
	Kernel-5_35-4_79_2_170:4.6.2.8
	Kernel-5_35-4_79_2_169:4.6.2.8
	Kernel-5_35-4_79_2_168:4.6.2.8
	Kernel-5_35-4_79_2_167:4.6.2.8
	Kernel-5_35-4_79_2_166:4.6.2.8
	Kernel-5_35-4_79_2_165:4.6.2.8
	RPi_merge:4.6.2.8.2.2
	Kernel-5_35-4_79_2_147_2_23:4.6.2.8.2.2
	Kernel-5_35-4_79_2_147_2_22:4.6.2.8.2.2
	Kernel-5_35-4_79_2_147_2_21:4.6.2.8.2.2
	Kernel-5_35-4_79_2_147_2_20:4.6.2.8.2.2
	Kernel-5_35-4_79_2_147_2_19:4.6.2.8.2.1
	Kernel-5_35-4_79_2_147_2_18:4.6.2.8.2.1
	Kernel-5_35-4_79_2_164:4.6.2.8
	Kernel-5_35-4_79_2_163:4.6.2.8
	Kernel-5_35-4_79_2_147_2_17:4.6.2.8.2.1
	Kernel-5_35-4_79_2_147_2_16:4.6.2.8.2.1
	Kernel-5_35-4_79_2_147_2_15:4.6.2.8.2.1
	Kernel-5_35-4_79_2_162:4.6.2.8
	Kernel-5_35-4_79_2_161:4.6.2.8
	Kernel-5_35-4_79_2_147_2_14:4.6.2.8.2.1
	Kernel-5_35-4_79_2_147_2_13:4.6.2.8.2.1
	Kernel-5_35-4_79_2_160:4.6.2.8
	Kernel-5_35-4_79_2_159:4.6.2.8
	Kernel-5_35-4_79_2_158:4.6.2.8
	Kernel-5_35-4_79_2_157:4.6.2.8
	Kernel-5_35-4_79_2_156:4.6.2.8
	Kernel-5_35-4_79_2_147_2_12:4.6.2.8.2.1
	Kernel-5_35-4_79_2_147_2_11:4.6.2.8.2.1
	Kernel-5_35-4_79_2_155:4.6.2.8
	Kernel-5_35-4_79_2_147_2_10:4.6.2.8.2.1
	Kernel-5_35-4_79_2_154:4.6.2.8
	Kernel-5_35-4_79_2_153:4.6.2.8
	Kernel-5_35-4_79_2_147_2_9:4.6.2.8.2.1
	Kernel-5_35-4_79_2_152:4.6.2.8
	Kernel-5_35-4_79_2_151:4.6.2.8
	Kernel-5_35-4_79_2_147_2_8:4.6.2.8.2.1
	Kernel-5_35-4_79_2_147_2_7:4.6.2.8.2.1
	Kernel-5_35-4_79_2_150:4.6.2.8
	Kernel-5_35-4_79_2_147_2_6:4.6.2.8.2.1
	Kernel-5_35-4_79_2_147_2_5:4.6.2.8.2.1
	Kernel-5_35-4_79_2_149:4.6.2.8
	Kernel-5_35-4_79_2_147_2_4:4.6.2.8.2.1
	Kernel-5_35-4_79_2_147_2_3:4.6.2.8.2.1
	Kernel-5_35-4_79_2_148:4.6.2.8
	Kernel-5_35-4_79_2_147_2_2:4.6.2.8.2.1
	Kernel-5_35-4_79_2_147_2_1:4.6.2.8.2.1
	RPi:4.6.2.8.0.2
	RPi_bp:4.6.2.8
	Kernel-5_35-4_79_2_98_2_52_2_1:4.6.2.6.2.1.2.1
	alees_Kernel_dev:4.6.2.6.2.1.0.2
	alees_Kernel_dev_bp:4.6.2.6.2.1
	Kernel-5_35-4_79_2_147:4.6.2.8
	Kernel-5_35-4_79_2_146:4.6.2.8
	Kernel-5_35-4_79_2_145:4.6.2.8
	Kernel-5_35-4_79_2_144:4.6.2.8
	Kernel-5_35-4_79_2_143:4.6.2.8
	Kernel-5_35-4_79_2_142:4.6.2.8
	Kernel-5_35-4_79_2_141:4.6.2.8
	Kernel-5_35-4_79_2_140:4.6.2.8
	Kernel-5_35-4_79_2_139:4.6.2.8
	Kernel-5_35-4_79_2_138:4.6.2.8
	Kernel-5_35-4_79_2_137:4.6.2.7
	Kernel-5_35-4_79_2_136:4.6.2.7
	Kernel-5_35-4_79_2_135:4.6.2.7
	Kernel-5_35-4_79_2_134:4.6.2.7
	Kernel-5_35-4_79_2_133:4.6.2.7
	Kernel-5_35-4_79_2_132:4.6.2.7
	Kernel-5_35-4_79_2_131:4.6.2.7
	Kernel-5_35-4_79_2_130:4.6.2.7
	Kernel-5_35-4_79_2_129:4.6.2.7
	Kernel-5_35-4_79_2_128:4.6.2.7
	Kernel-5_35-4_79_2_127:4.6.2.7
	Kernel-5_35-4_79_2_126:4.6.2.7
	Kernel-5_35-4_79_2_125:4.6.2.7
	Kernel-5_35-4_79_2_124:4.6.2.7
	Kernel-5_35-4_79_2_123:4.6.2.7
	Cortex_merge:4.6.2.6.2.2
	Kernel-5_35-4_79_2_122:4.6.2.6
	Kernel-5_35-4_79_2_98_2_54:4.6.2.6.2.2
	Kernel-5_35-4_79_2_98_2_53:4.6.2.6.2.2
	Kernel-5_35-4_79_2_98_2_52:4.6.2.6.2.1
	Kernel-5_35-4_79_2_98_2_51:4.6.2.6.2.1
	Kernel-5_35-4_79_2_98_2_50:4.6.2.6.2.1
	Kernel-5_35-4_79_2_98_2_49:4.6.2.6.2.1
	Kernel-5_35-4_79_2_98_2_48:4.6.2.6.2.1
	Kernel-5_35-4_79_2_121:4.6.2.6
	Kernel-5_35-4_79_2_98_2_47:4.6.2.6
	Kernel-5_35-4_79_2_120:4.6.2.6
	Kernel-5_35-4_79_2_98_2_46:4.6.2.6
	Kernel-5_35-4_79_2_119:4.6.2.6
	Kernel-5_35-4_79_2_98_2_45:4.6.2.6
	Kernel-5_35-4_79_2_98_2_44:4.6.2.6
	Kernel-5_35-4_79_2_118:4.6.2.6
	Kernel-5_35-4_79_2_98_2_43:4.6.2.6
	Kernel-5_35-4_79_2_117:4.6.2.6
	Kernel-5_35-4_79_2_116:4.6.2.6
	Kernel-5_35-4_79_2_98_2_42:4.6.2.6
	Kernel-5_35-4_79_2_115:4.6.2.6
	Kernel-5_35-4_79_2_98_2_41:4.6.2.6
	Kernel-5_35-4_79_2_98_2_40:4.6.2.6
	Kernel-5_35-4_79_2_114:4.6.2.6
	Kernel-5_35-4_79_2_98_2_39:4.6.2.6
	Kernel-5_35-4_79_2_98_2_38:4.6.2.6
	Kernel-5_35-4_79_2_113:4.6.2.6
	Kernel-5_35-4_79_2_112:4.6.2.6
	Kernel-5_35-4_79_2_98_2_37:4.6.2.6
	Kernel-5_35-4_79_2_98_2_36:4.6.2.6
	Kernel-5_35-4_79_2_98_2_35:4.6.2.6
	Kernel-5_35-4_79_2_98_2_34:4.6.2.6
	Kernel-5_35-4_79_2_98_2_33:4.6.2.6
	Kernel-5_35-4_79_2_98_2_32:4.6.2.6
	Kernel-5_35-4_79_2_98_2_31:4.6.2.6
	Kernel-5_35-4_79_2_98_2_30:4.6.2.6
	Kernel-5_35-4_79_2_98_2_29:4.6.2.6
	Kernel-5_35-4_79_2_98_2_28:4.6.2.6
	Kernel-5_35-4_79_2_98_2_27:4.6.2.6
	Kernel-5_35-4_79_2_98_2_26:4.6.2.6
	Kernel-5_35-4_79_2_111:4.6.2.6
	Kernel-5_35-4_79_2_98_2_25:4.6.2.6
	Kernel-5_35-4_79_2_98_2_24:4.6.2.6
	Kernel-5_35-4_79_2_98_2_23:4.6.2.6
	Kernel-5_35-4_79_2_110:4.6.2.6
	Kernel-5_35-4_79_2_98_2_22:4.6.2.6
	Kernel-5_35-4_79_2_109:4.6.2.6
	Kernel-5_35-4_79_2_98_2_21:4.6.2.6
	Kernel-5_35-4_79_2_98_2_20:4.6.2.6
	Kernel-5_35-4_79_2_108:4.6.2.6
	Kernel-5_35-4_79_2_107:4.6.2.6
	Kernel-5_35-4_79_2_98_2_19:4.6.2.6
	Kernel-5_35-4_79_2_98_2_18:4.6.2.6
	Kernel-5_35-4_79_2_98_2_17:4.6.2.6
	Kernel-5_35-4_79_2_98_2_16:4.6.2.6
	Kernel-5_35-4_79_2_98_2_15:4.6.2.6
	Kernel-5_35-4_79_2_106:4.6.2.6
	Kernel-5_35-4_79_2_105:4.6.2.6
	Kernel-5_35-4_79_2_104:4.6.2.6
	Kernel-5_35-4_79_2_98_2_14:4.6.2.6
	Kernel-5_35-4_79_2_98_2_13:4.6.2.6
	Kernel-5_35-4_79_2_98_2_12:4.6.2.6
	Kernel-5_35-4_79_2_98_2_11:4.6.2.6
	Kernel-5_35-4_79_2_98_2_10:4.6.2.6
	Kernel-5_35-4_79_2_98_2_9:4.6.2.6
	Kernel-5_35-4_79_2_103:4.6.2.6
	Kernel-5_35-4_79_2_102:4.6.2.6
	Kernel-5_35-4_79_2_98_2_8:4.6.2.6
	Kernel-5_35-4_79_2_98_2_7:4.6.2.6
	Kernel-5_35-4_79_2_98_2_6:4.6.2.6
	Kernel-5_35-4_79_2_98_2_5:4.6.2.6
	Kernel-5_35-4_79_2_98_2_4:4.6.2.6
	Kernel-5_35-4_79_2_101:4.6.2.6
	Kernel-5_35-4_79_2_100:4.6.2.6
	Kernel-5_35-4_79_2_99:4.6.2.6
	Kernel-5_35-4_79_2_98_2_3:4.6.2.6
	Kernel-5_35-4_79_2_98_2_2:4.6.2.6
	Kernel-5_35-4_79_2_98_2_1:4.6.2.6
	Cortex:4.6.2.6.0.2
	Cortex_bp:4.6.2.6
	Kernel-5_35-4_79_2_98:4.6.2.6
	Kernel-5_35-4_79_2_97:4.6.2.6
	Kernel-5_35-4_79_2_96:4.6.2.6
	Kernel-5_35-4_79_2_95:4.6.2.6
	Kernel-5_35-4_79_2_94:4.6.2.6
	Kernel-5_35-4_79_2_93:4.6.2.6
	Kernel-5_35-4_79_2_92:4.6.2.6
	Kernel-5_35-4_79_2_91:4.6.2.6
	Kernel-5_35-4_79_2_90:4.6.2.6
	Kernel-5_35-4_79_2_89:4.6.2.6
	Kernel-5_35-4_79_2_88:4.6.2.6
	Kernel-5_35-4_79_2_87:4.6.2.6
	Kernel-5_35-4_79_2_86:4.6.2.6
	Kernel-5_35-4_79_2_85:4.6.2.6
	Kernel-5_35-4_79_2_84:4.6.2.6
	Kernel-5_35-4_79_2_83:4.6.2.6
	Kernel-5_35-4_79_2_82:4.6.2.6
	Kernel-5_35-4_79_2_81:4.6.2.6
	Kernel-5_35-4_79_2_80:4.6.2.6
	Kernel-5_35-4_79_2_79:4.6.2.6
	Kernel-5_35-4_79_2_78:4.6.2.6
	Kernel-5_35-4_79_2_77:4.6.2.6
	RO_5_07:4.6.2.6
	Kernel-5_35-4_79_2_76:4.6.2.6
	Kernel-5_35-4_79_2_75:4.6.2.6
	Kernel-5_35-4_79_2_74:4.6.2.6
	Kernel-5_35-4_79_2_73:4.6.2.6
	Kernel-5_35-4_79_2_72:4.6.2.6
	Kernel-5_35-4_79_2_71:4.6.2.6
	Kernel-5_35-4_79_2_70:4.6.2.6
	Kernel-5_35-4_79_2_69:4.6.2.6
	Kernel-5_35-4_79_2_68:4.6.2.6
	Kernel-5_35-4_79_2_67:4.6.2.6
	Kernel-5_35-4_79_2_66:4.6.2.6
	Kernel-5_35-4_79_2_65:4.6.2.5
	Kernel-5_35-4_79_2_64:4.6.2.5
	Kernel-5_35-4_79_2_63:4.6.2.5
	Kernel-5_35-4_79_2_62:4.6.2.5
	Kernel-5_35-4_79_2_61:4.6.2.5
	Kernel-5_35-4_79_2_59:4.6.2.4
	Kernel-5_35-4_79_2_58:4.6.2.4
	Kernel-5_35-4_79_2_57:4.6.2.4
	Kernel-5_35-4_79_2_56:4.6.2.3
	Kernel-5_35-4_79_2_55:4.6.2.3
	Kernel-5_35-4_79_2_54:4.6.2.3
	Kernel-5_35-4_79_2_53:4.6.2.3
	Kernel-5_35-4_79_2_52:4.6.2.3
	Kernel-5_35-4_79_2_51:4.6.2.3
	Kernel-5_35-4_79_2_50:4.6.2.2
	Kernel-5_35-4_79_2_49:4.6.2.2
	Kernel-5_35-4_79_2_48:4.6.2.2
	Kernel-5_47:4.6
	Kernel-5_46-4_90_2_1:4.6
	nbingham_Kernel_FastNC_dev_bp:4.6
	nbingham_Kernel_FastNC_dev:4.6.0.4
	Kernel-5_46:4.6
	Kernel-5_45:4.6
	Kernel-5_35-4_79_2_47:4.6.2.1
	Kernel-5_35-4_79_2_46:4.6.2.1
	Kernel-5_35-4_79_2_45:4.6.2.1
	Kernel-5_35-4_79_2_44:4.6.2.1
	Kernel-5_35-4_79_2_25_2_2:4.6.2.1
	Kernel-5_35-4_79_2_43:4.6.2.1
	Kernel-5_35-4_79_2_42:4.6.2.1
	Kernel-5_35-4_79_2_41:4.6.2.1
	Kernel-5_35-4_79_2_40:4.6.2.1
	Kernel-5_35-4_79_2_39:4.6.2.1
	Kernel-5_35-4_79_2_38:4.6.2.1
	Kernel-5_35-4_79_2_37:4.6.2.1
	Kernel-5_35-4_79_2_36:4.6.2.1
	Kernel-5_35-4_79_2_35:4.6.2.1
	Kernel-5_35-4_79_2_34:4.6.2.1
	Kernel-5_35-4_79_2_33:4.6.2.1
	Kernel-5_35-4_79_2_32:4.6.2.1
	Kernel-5_44:4.6
	Kernel-5_35-4_79_2_25_2_1:4.6.2.1
	Kernel-5_43:4.6
	Kernel-5_35-4_79_2_31:4.6.2.1
	Kernel-5_35-4_79_2_30:4.6.2.1
	Kernel-5_35-4_79_2_29:4.6.2.1
	Kernel-5_35-4_79_2_28:4.6.2.1
	Kernel-5_35-4_79_2_27:4.6.2.1
	Kernel-5_35-4_79_2_26:4.6.2.1
	Kernel-5_42:4.6
	Kernel-5_41:4.6
	Kernel-5_40:4.6
	Kernel-5_35-4_79_2_25:4.6.2.1
	Kernel-5_35-4_79_2_24:4.6.2.1
	Kernel-5_35-4_79_2_23:4.6.2.1
	Kernel-5_35-4_79_2_22:4.6.2.1
	Kernel-5_35-4_79_2_21:4.6.2.1
	Kernel-5_35-4_79_2_20:4.6.2.1
	Kernel-5_35-4_79_2_19:4.6.2.1
	Kernel-5_35-4_79_2_18:4.6.2.1
	Kernel-5_35-4_79_2_17:4.6.2.1
	Kernel-5_35-4_79_2_16:4.6.2.1
	Kernel-5_35-4_79_2_15:4.6.2.1
	Kernel-5_35-4_79_2_14:4.6.2.1
	Kernel-5_39:4.6
	Kernel-5_13-4_52_2_1:4.4
	Bethany:4.4.0.2
	Kernel-5_38:4.6
	Kernel-5_35-4_79_2_13:4.6.2.1
	Kernel-5_35-4_79_2_12:4.6.2.1
	Kernel-5_35-4_79_2_11:4.6.2.1
	Kernel-5_37:4.6
	Kernel-5_35-4_79_2_10:4.6.2.1
	Kernel-5_35-4_79_2_9:4.6.2.1
	Kernel-5_36:4.6
	Kernel-5_35-4_79_2_8:4.6.2.1
	Kernel-5_35-4_79_2_7:4.6.2.1
	Kernel-5_35-4_79_2_6:4.6.2.1
	Kernel-5_35-4_79_2_5:4.6.2.1
	Kernel-5_35-4_79_2_4:4.6.2.1
	Kernel-5_35-4_79_2_3:4.6.2.1
	Kernel-5_35-4_79_2_2:4.6.2.1
	dellis_autobuild_BaseSW:4.6
	Kernel-5_35-4_79_2_1:4.6.2.1
	HAL:4.6.0.2
	Kernel-5_35:4.6
	Kernel-5_34:4.6
	Kernel-5_33:4.6
	Kernel-5_32:4.6
	Kernel-5_31:4.5
	Kernel-5_30:4.5
	Kernel-5_29:4.5
	Kernel-5_28:4.5
	Kernel-5_27:4.5
	Kernel-5_26:4.5
	Kernel-5_25:4.5
	Kernel-5_24:4.5
	Kernel-5_23:4.5
	Kernel-5_22:4.4
	sbrodie_sedwards_16Mar2000:4.4
	Kernel-5_21:4.4
	Kernel-5_20:4.4
	Kernel-5_19:4.4
	Kernel-5_18:4.4
	Kernel-5_17:4.4
	Kernel-5_16:4.4
	Kernel-5_15:4.4
	Kernel-5_14:4.4
	Kernel-5_13:4.4
	Kernel-5_12:4.4
	Kernel-5_11:4.4
	Kernel-5_10:4.4
	Kernel-5_09:4.4
	Kernel-5_08:4.4
	Kernel-5_07:4.4
	Kernel-5_06:4.4
	Kernel-5_05:4.4
	Kernel-5_04:4.4
	Kernel-5_03:4.4
	Kernel-5_02:4.4
	Kernel-5_01:4.4
	Kernel-5_00:4.4
	Kernel-4_99:4.4
	Kernel-4_98:4.4
	Kernel-4_97:4.4
	Kernel-4_96:4.4
	Kernel-4_95:4.3
	Kernel-4_94:4.3
	Kernel-4_93:4.2
	Kernel-4_92:4.2
	Kernel-4_91:4.2
	Kernel-4_90:4.2
	dcotton_autobuild_BaseSW:4.6
	Kernel-4_89:4.2
	Kernel-4_88:4.2
	Kernel-4_87:4.2
	Kernel-4_86:4.2
	Kernel-4_85:4.2
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.1.2.1
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.1.2.1
	Ursula_RiscPC_bp:4.1.4.1
	Kernel-4_83:4.2
	Kernel-4_82:4.2
	Kernel-4_81:4.2
	Kernel-4_80:4.2
	Kernel-4_79:4.2
	Kernel-4_78:4.2
	Kernel-4_77:4.2
	Kernel-4_76:4.2
	Kernel-4_75:4.2
	Kernel-4_74:4.2
	Kernel-4_73:4.2
	Kernel-4_72:4.2
	Kernel-4_71:4.2
	Kernel-4_70:4.2
	Kernel-4_69:4.2
	Kernel-4_68:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1.2.1
	Ursula_RiscPC:4.1.4.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.2
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	mstphens_Kernel-3_80:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.12
date	2018.03.25.21.01.02;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	gUttU6y9LCksLSvA;

4.11
date	2018.02.03.18.41.41;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	VwdJDuE1iBptBrpA;

4.10
date	2017.09.09.10.35.45;	author rool;	state Exp;
branches;
next	4.9;
commitid	SuZJGVb4fAmIDv6A;

4.9
date	2016.06.30.20.59.50;	author jlee;	state Exp;
branches
	4.9.2.1;
next	4.8;
commitid	skOEjp3ipLHx6xcz;

4.8
date	2016.06.30.20.29.02;	author jlee;	state Exp;
branches;
next	4.7;
commitid	lMnWzoE9eJz3Wwcz;

4.7
date	2016.06.30.20.08.16;	author jlee;	state Exp;
branches;
next	4.6;
commitid	IWoXxARWeuLDOwcz;

4.6
date	2000.08.18.09.31.45;	author sbrodie;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2000.04.04.14.27.36;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.10.14.12.18.23;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.10.13.16.21.28;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.10.30.18.07.01;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.29;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.9.2.1
date	2017.09.10.11.27.25;	author jlee;	state Exp;
branches;
next	4.9.2.2;
commitid	EGooxXrB27MqTD6A;

4.9.2.2
date	2018.02.16.00.01.43;	author jlee;	state Exp;
branches;
next	4.9.2.3;
commitid	L7HYXYTsWSFlZ0rA;

4.9.2.3
date	2018.05.14.19.33.46;	author jlee;	state Exp;
branches;
next	;
commitid	wrVtYH84nAz1GiCA;

4.6.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2002.10.07.17.29.44;	author kbracey;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2002.11.30.00.31.11;	author bavison;	state Exp;
branches;
next	4.6.2.4;

4.6.2.4
date	2003.02.28.19.20.16;	author bavison;	state Exp;
branches;
next	4.6.2.5;

4.6.2.5
date	2003.12.02.16.02.06;	author bavison;	state Exp;
branches;
next	4.6.2.6;

4.6.2.6
date	2004.05.06.16.02.04;	author kbracey;	state Exp;
branches
	4.6.2.6.2.1;
next	4.6.2.7;

4.6.2.7
date	2011.11.26.21.11.23;	author jlee;	state Exp;
branches;
next	4.6.2.8;
commitid	cI3W0zbtALQG6TIv;

4.6.2.8
date	2012.02.25.16.19.40;	author jlee;	state Exp;
branches
	4.6.2.8.2.1;
next	4.6.2.9;
commitid	ad3WnPntkzrizyUv;

4.6.2.9
date	2012.12.05.01.16.22;	author jlee;	state Exp;
branches;
next	4.6.2.10;
commitid	jNXy5BkvBl5srYuw;

4.6.2.10
date	2013.11.20.20.25.00;	author rsprowson;	state Exp;
branches;
next	4.6.2.11;
commitid	mPgx586MWbpUx3ex;

4.6.2.11
date	2013.12.17.19.08.54;	author jlee;	state Exp;
branches;
next	;
commitid	mr92WavK9Mu4gwhx;

4.6.2.6.2.1
date	2011.08.08.23.28.34;	author jlee;	state Exp;
branches
	4.6.2.6.2.1.2.1;
next	4.6.2.6.2.2;
commitid	D7rzILnwRRSXoLuv;

4.6.2.6.2.2
date	2011.09.24.19.55.56;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.6.2.6.2.1.2.1
date	2012.05.10.03.09.56;	author bavison;	state Exp;
branches;
next	;
commitid	HTVG5Da5tRqSM74w;

4.6.2.8.2.1
date	2012.05.10.03.28.08;	author bavison;	state Exp;
branches;
next	4.6.2.8.2.2;
commitid	kuJoT3AcfB16T74w;

4.6.2.8.2.2
date	2012.09.07.23.05.54;	author jlee;	state Exp;
branches;
next	;
commitid	Ik0jMROsIiH5yEjw;

4.1.1.1
date	96.11.05.09.41.29;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.01.53;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.34.08;	author mstphens;	state Exp;
branches
	4.1.4.1.2.1;
next	4.1.4.2;

4.1.4.2
date	98.09.24.13.17.31;	author mstphens;	state Exp;
branches;
next	;

4.1.4.1.2.1
date	98.11.23.14.59.29;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.14;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.11;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Don't bother setting up R12 to point at IOC
This is now a HAL only kernel, and 0x3200000 is most likely somewhere in RAM.
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.PMF.Key

; ARTHUR keyboard code

; Authors       Tim Dobson, Jon Thackray
; Started       13-Oct-86

; ************************************************************
; ***    C h a n g e   L i s t  (better late than never!)  ***
; ************************************************************

; Date      Who Description
; ----      --- -----------
; 17-Feb-88     Added Sam's code to call the callback vector in RDCH/INKEY
;                idle loop
; 02-Mar-88     Initialise KeyVec to NewKeyStruct before the keyboard has told
;                us its ID, so Sam can call INKEY(-ve) with no keyboard
; 13-Apr-88     Fixed RDCH from RS423 if treating as keyboard, getting NUL+char
;                (didn't try to reenable RTS on 2nd char)
; 11-Jun-88     Put input redirection where it was needed really. SKS
; 12-Aug-88     Read mouse position from buffer forces inside bounding box
; 02-Sep-88     Buffered mouse coords stored in absolute terms, not relative to
;                origin at time of click. Made relative after reading out and
;                clipping to bounding box. Mouse event coords are still relative
;                to origin at time of click.
; 06-Feb-91     LastLED added to stop unnecessary LED transmissions
;
; 24-Feb-93 SMC Split off Archimedes keyboard driver into file KbdDrA1.
;               Split off mouse stuff into file mouse.
;               Added new interfaces for generic keyboard driver.
; 23-Aug-93 SMC GotKbId now sets KbId but remembers the last in LastKbId.
; 24-Aug-93 SMC Key handler can now get keyboard stuff going.
; 18-Nov-93 SMC Fixed bug in key handler stuff (no handler => KeyVec=-1).
; 25-Nov-93 SMC Key handler and keyboard driver now trigger each other correctly.
; 25-Apr-94 RCM ReadCh modified for Stork's power saving scheme.
;
; 28-Apr-04 JWB Added magic switch to turn off kernel kbd debounce
;               r2 on KEYV vector 0 = 'NoKd' to disable debounce


; *****************************************************************************
;
;       Entry point for keyboard code - Initialisation
;

KeyInit ROUT
        LDR     R11, =ZeroPage+KeyWorkSpace
        Push    R14

        WritePSRc I_bit :OR: SVC_mode, R14

        MOV     R0, #-1                 ; no default key handler
        STR     R0, KeyVec

        MOV     R0, #&FF                ; indicate no previous keyboard id
        STRB    R0, LastKbId
        STRB    R0, KbId

        BL      ClearKbd

        Pull    PC                      ; go back to user

; *****************************************************************************
;
;       KeyPostInit - Called after modules have initialised
;

KeyPostInit ROUT
        Push    R14
        BYTEWS  WsPtr

        MOV     R0, #TerritoryNum_UK    ; indicate keyboard UK
        MOV     R1, #ISOAlphabet_Latin1 ; indicate alphabet Latin1
        STRB    R0, Keyboard
        STRB    R1, Alphabet
        STRB    R1, KeyAlphabet         ; alphabet corresponding to keyboard

        LDR     R11, =ZeroPage+KeyWorkSpace
        PHPSEI                          ; disable interrupts round this bit
        Push    R14                     ; save I_bit indication
        LDRB    R1, LastKbId
        TEQ     R1, #KeyboardID_None    ; if no keyboard initialised yet then
        LDREQB  R1, KbId                ;   try now
        BLEQ    GotKbId
        Pull    R14                     ; restore I_bit indication
        PLP                             ; set I_bit from this

        MOV     R0, #OsByte_Country
        LDROSB  R1, Country
        SWI     XOS_Byte
        Pull    PC

; *****************************************************************************

ClearKbd ROUT
        Entry   "R1-R2"

        MOV     R0, #&FF
        STR     R0, CurrKey             ; no current key
        STR     R0, OldKey
        STRB    R0, LastLED

; Set up keyboard table

        MOV     R0, #0                  ; All keys up
        MOV     R1, #?KeysDown
        ADR     R2, KeysDown
10
        SUBS    R1, R1, #4
        STR     R0, [R2], #4
        BNE     %BT10

        EXIT

; *****************************************************************************
;
;       UpdateLEDs - Update the LED(s) from the keyboard status byte
;
; in:   R11 -> keyboard workspace
;
; out:  R0, R1 corrupted
;

UpdateLEDs ROUT
        LDRB    r0, KbId                ; get keyboard id
        TEQ     r0, #&FF                ; if not found yet
        MOVEQ   pc, lr                  ; then exit

        LDROSB  r0, KeyBdStatus         ; Build current LED state byte.
        TST     r0, #KBStat_NoCapsLock
        MOVEQ   r1, #1
        MOVNE   r1, #0
        TST     r0, #KBStat_NoNumLock
        ORREQ   r1, r1, #2
        TST     r0, #KBStat_ScrollLock
        ORRNE   r1, r1, #4

        ; fall through
        ASSERT  . = SetLEDs

; *****************************************************************************
;
;       SetLEDs - Set the LED(s) to a specific value
;
; in:   R1 = desired LED state (bit 0 = caps lock, 1 = num lock, 2 = scroll lock)
;       R11 -> keyboard workspace
;
; out:  R0, R1 corrupted
;

SetLEDs
        LDRB    r0, LastLED             ; Only update if different.
        TEQ     r0, r1
        MOVEQ   pc,lr

        STRB    r1, LastLED

        MOV     r0, #3
        Push    "r10-r12,lr"
        MRS     r11, CPSR               ; Save current PSR.
        ORR     r10, r11, #SVC_mode + I32_bit
        MSR     CPSR_c, r10             ; Call KEYV in SVC mode, no IRQs.
        MOV     r10, #KEYV
        Push    "lr"                    ; Save SVC lr.
        BL      CallVector
        Pull    "lr"                    ; Restore SVC lr.
        MSR     CPSR_cf, r11            ; Go back to old mode.
        NOP
        Pull    "r10-r12,pc"

; *****************************************************************************
;
;       LEDsOn - Turn on all the LEDs
;
; out:  all registers preserved
;

LEDsOn  Push    "r0,r1,r11,lr"
        MOV     r1, #7
        LDR     r11, =ZeroPage+KeyWorkSpace
        BL      SetLEDs
        Pull    "r0,r1,r11,pc"

; *****************************************************************************
;
;       LEDsOff - Restore the LEDs to keyboard status
;
; out:  all registers preserved
;

LEDsOff Push    "r0,r1,r11,lr"
        LDR     r11, =ZeroPage+KeyWorkSpace
        BL      UpdateLEDs
        Pull    "r0,r1,r11,pc"

; *****************************************************************************
;
;       Handle new keyboard id.
;       In:     r1 = keyboard id
;               r2 = magic 'NoKd' to disable kernel debouncing
;               r11 = KeyWorkSpace
;       Out:    preserve flags
;
GotKbId
        EntryS

        STRB    r1, KbId                ; Store the new keyboard id.

        LDR     r0, KeyVec
        Push    r0                      ; Save old key handler so we know if it's changed.

        LDR     lr, NoKbMagic
        TEQ     r2, lr
        MOVNE   lr, #0
        STRB    lr, NoDebounce          ; remember kernel debounce switch

        LDRB    r8, LastKbId
        TEQ     r8, r1                  ; If we have a different keyboard id then

        BLNE    IssueKeyboardService    ;   issue service.

        LDR     lr, KeyVec              ; Get possibly new key handler.
        Pull    r0                      ; And old handler.
        TEQ     r0, lr                  ; If key handler has not changed then
        BLEQ    KeyboardEnable          ;   handler has not initialised with OS_InstallKeyHandler so we try.

        EXITS


NoKbMagic DCD   &4e6f4b64               ; Magic of NoKd to signal no kernel
                                        ;   debounce


; *****************************************************************************
; Initialise keyboard handler and enable keyboard driver.
;
; In:   r1 = keyboard id
;
KeyboardEnable
        Push    lr

        BL      ClearKbd

        LDR     r0, KeyVec
        CMP     r0, #-1                 ; If no key handler
        LDRNEB  r1, KbId                ;     or no keyboard yet then
        TEQNE   r1, #&FF
        Pull    pc, EQ                  ;   can't initialise.

        STRB    r1, LastKbId            ; Remember last keyboard id that initialised.

        LDR     r8, [r0, #KeyHandler_Init] ; Initialise key handler.
        ADD     r8, r8, r0
        BL      CallUserKeyCode

        MOV     r0, #4                  ; Initialise keyboard driver.
        MOV     r10, #KEYV
        BL      CallVector
        Pull    pc

; *****************************************************************************
;
;       Default KEYV handler (deal with keyboard id, keys up/down).
;
;       In:     r0 = reason code 0
;               r1 = keyboard id
;               r2 = magic 'NoKd' if kernel debouncing to be disabled
;       or
;               r0 = reason code 1 or 2
;               r1 = key code
;
KeyVector ROUT
        CMP     r0, #3                  ; If not id/key up/key down then
        Pull    pc, CS                  ;  just claim call.

        Push    "r0-r12"

        LDR     r11, =ZeroPage+KeyWorkSpace

        TEQ     r0, #0                  ; If keyboard id then
        BLEQ    GotKbId                 ;   handle it
        Pull    "r0-r12,pc",EQ          ;   and claim call.

        MOV     r2, r1
        SUB     r1, r0, #1

        CMP     R2, #?KeysDown*8
        BCS     %FT05
        ADR     R0, KeysDown
        MOV     lr, R2, LSR #5
        LDR     lr, [R0, lr, LSL #2]!   ; load appropriate word
        MOV     R3, #&80000000          ; index 0 is in top bit
        TEQ     r1, #0
        BNE     %FT03

        TST     lr, R3, ROR R2          ; if going up and key already up (keyboard reinitialised) then
        BEQ     %FT50                   ;   nothing to do
        B       %FT04                   ; else clear flag, generate event etc.
03
        TST     lr, R3, ROR R2          ; if going down and key already down (weird) then
        BNE     %FT50                   ;   nothing to do else...
04
        EOR     lr, lr, R3, ROR R2      ; switch state of flag
        STR     lr, [R0]                ; store back
05
        BL      KeyboardEvent           ; generate key up/down event

        BL      CheckForShiftingKey
        BCC     %FT10                   ; [not shifting key]

        BL      CallSpecialReturnNChars
        B       %FT50

10
        TEQ     r1, #0                  ; if key up then
        BEQ     %FT30                   ;   go and deal with it

        LDR     R0, CurrKey
        TEQ     R0, #&FF                ; have we got a current key ?
        BEQ     %FT20

        LDR     R1, OldKey
        TEQ     R1, #&FF                ; have we got an old key ?
        BNE     %FT50                   ; ignore new - we've got 2 down already

        STR     R0, OldKey              ; make current key old
20
        STR     R2, CurrKey             ; update current
        LDRB    r1, NoDebounce          ; check debouncing?
        TEQ     r1, #0
        MOVEQ   R0, #2                  ; Eq.. normal kernel debounce
        MOVNE   R0, #0                  ; NE.. no kernel debounce
        STRB    R0, Debouncing
        LDROSB  R0, KeyRepDelay, NE     ; and load delay
        STRB    R0, AutoRepeatCount     ; generate char after 2 100Hz ticks

        MOVNE   r1,#2                   ; mark as first key
        BLNE    GenerateChar            ; R2 = key number

        B       %FT50

30
        LDR     R0, OldKey
        TEQ     R0, R2                  ; is it old key going up ?
        BNE     %FT40

; Old key going up

        LDR     R0, CurrKey             ; current key is one to ignore in scan
        BL      ScanKeys

        STRPL   R0, OldKey              ; found key, so current -> old
        BPL     %BT20                   ; and R2 -> current

        MOV     R0, #&FF                ; else mark old key invalid
        STR     R0, OldKey
        B       %FT50                   ; and return

40
        LDR     R1, CurrKey
        TEQ     R1, R2                  ; is it current key going up ?
        BNE     %FT50                   ; not interested if not

        BL      ScanKeys                ; R0 was OldKey
        BPL     %BT20                   ; was a key so make that current

        MOV     R2, #&FF
        STR     R2, CurrKey             ; mark current key up

50
        Pull    "r0-r12,pc"

; *****************************************************************************
;
;       KeyboardEvent - Generate key up/down event
;
; in:   R1 = 0 for up, 1 for down
;       R2 = key index
;

KeyboardEvent ROUT
        LDRB    R3, KbId                ; tell event user the keyboard id
        MOV     R0, #Event_Keyboard
        B       OSEVEN

; *****************************************************************************
;
;       Scan keyboard for keys down, ignoring key number R0 and shifting keys
;
; in:   R0 = key number to ignore
;
; out:  N=0 => R2 = key number found
;       N=1 => no key found; R2 = -1
;       R0 preserved
;

ScanKeys ROUT
        Push    "R0, R14"
        ADR     R1, KeysDown
        MOV     R2, #(?KeysDown/4)-1
10
        TEQ     R2, #&200/32
        MOVEQ   R2, #4                  ; skip extension key range &100
        LDR     R3, [R1, R2, LSL #2]    ; get the word
        TEQ     R3, #0                  ; if any keys in this down, skip
        BNE     %FT20
15
        SUBS    R2, R2, #1              ; N=1 last time round
        BPL     %BT10
        Pull    "R0, PC"

20
        MOV     R2, R2, LSL #5          ; multiply by 32
        ADD     R2, R2, #32             ; and add 32
30
        TEQ     R3, #0                  ; no more bits ?
        MOVEQ   R2, R2, LSR #5          ; then reset R2 to word offset
        BEQ     %BT15                   ; and continue word loop
        SUB     R2, R2, #1              ; decrement key number
        MOVS    R3, R3, LSR #1          ; shift out bit
        BCC     %BT30

        CMP     R2, R0                  ; is it old key (C=1 if it is)
        BLNE    CheckForShiftingKeyR0R3 ; check that it's not shifting key
        BCS     %BT30                   ; C=1 => invalid, so loop

        TEQ     R2, #0                  ; N := 0
        Pull    "R0, PC"

; *****************************************************************************
;
;       CheckForShiftingKey - either going down or going up
;
; in:   R2 = key number
;
; out:  C=1 <=> is shifting key, so don't set current key etc
;       R0 -> key structure
;       R4 = shifting key index, or 0 if not shifting key
;       R3,R5 undefined
;       R1,R2,R6-R12 preserved
;

CheckForShiftingKeyR0R3 ROUT              ; version that saves R0, for ScanKeys
        Push    "R0,R3,R14"
        BL      CheckForShiftingKey
        Pull    "R0,R3,PC"

CheckForShiftingKey ROUT
        LDR     R0, KeyVec
        CMP     R0, #-1
        MOVEQ   PC, R14
        LDR     R3, [R0, #KeyHandler_KeyTranSize] ; maximum internal key number +1
        TST     R3, #KeyHandler_HasFlags
        BIC     R3, R3, #KeyHandler_HasFlags
        LDRNE   R5, [R0, #KeyHandler_Flags]
        TSTNE   R5, #KeyHandler_Flag_Wide
        BNE     %FT20                   ; Use wide version of routine

        CMP     R2, R3                  ; is it outside table ?
        LDRCC   R3, [R0, #KeyHandler_KeyTran] ; no, R3 := offset to keytran
        ADDCC   R3, R3, R0              ; R3 -> keytran
        LDRCC   R3, [R3, R2, LSL #2]    ; R3 = table word for this key
        CMNCC   R3, #1                  ; C=1 <=> outside table or is special
        MOVCC   PC, R14                 ; can't be shifting key

        LDR     R3, [R0, #KeyHandler_ShiftingList] ; R3 = offset to shifting key list
        LDRB    R4, [R3, R0]!           ; R4 = length of shifting key list
        TEQ     R4, #0
10
        LDRNEB  R5, [R3, R4]
        TEQNE   R5, R2
        SUBNES  R4, R4, #1
        BNE     %BT10

        CMP     R4, #1                  ; C=1 <=> shifting key
        MOV     PC, R14                 ; not one of the shifting keys

20
        CMP     R2, R3                  ; is it outside table ?
        LDRCC   R3, [R0, #KeyHandler_KeyTran] ; no, R3 := offset to keytran
        ADDCC   R3, R3, R0              ; R3 -> keytran
        LDRCC   R4, =&FF00FF00
        ADDCC   R3, R3, R2, LSL #3      ; R3 = table address for this key
        LDMCCIA R3, {R3, R5}            ; R3, R5 = table entry for this key
        EORCC   R3, R3, R4
        EORCC   R5, R5, R4
        ANDCC   R3, R3, R5
        CMNCC   R3, #1                  ; C=1 <=> outside table or is special
        MOVCC   PC, R14                 ; can't be shifting key

        LDR     R3, [R0, #KeyHandler_ShiftingList] ; R3 = offset to shifting key list
      [ NoARMv4
        LDRB    R4, [R3, R0]!
        LDRB    R5, [R3, #1]
        ORRS    R4, R4, R5, LSL #8      ; R4 = length of shifting key list
      |
        LDRH    R4, [R3, R0]!
        TEQ     R4, #0                  ; R4 = length of shifting key list
      ]
30
      [ NoARMv4
        ASSERT  :LNOT: NoUnaligned
        LDRNE   R5, [R3, R4, LSL #1]
        MOVNE   R5, R5, LSL #16
        TEQNE   R5, R2, LSL #16
      |
        ADDNE   R5, R3, R4, LSL #1
        LDRNEH  R5, [R5]
        TEQNE   R5, R2
      ]
        SUBNES  R4, R4, #1
        BNE     %BT30

        CMP     R4, #1                  ; C=1 <=> shifting key
        MOV     PC, R14                 ; not one of the shifting keys

; *****************************************************************************
;
;       CallSpecialCode - Call code for a special key
;
; in:   R0 -> Key structure
;       R1 = 0 for up, 1 for down (shifting keys); 2 for first, 3 for repeat
;       R2 = key number
;

CallSpecialCode ROUT
        LDR     R3, [R0, #KeyHandler_KeyTranSize]
        ADR     R6, NullCharList
        TST     R3, #KeyHandler_HasFlags
        LDRNE   R3, [R0, #KeyHandler_Flags]
        TSTNE   R3, #KeyHandler_Flag_Wide
        LDR     R3, [R0, #KeyHandler_SpecialList] ; R3 = offset to special list
        BNE     CallSpecialCodeWide
        LDRB    R4, [R3, R0]!           ; R4 = length of special list
        TEQ     R4, #0
        MOVEQ   PC, R14                 ; no special keys, so can't be one
10
        LDRB    R5, [R3, R4]
        TEQ     R5, R2
        BEQ     %FT20
        SUBS    R4, R4, #1
        BNE     %BT10
        MOV     PC, R14

CallSpecialCodeWide
      [ NoARMv4
        LDRB    R4, [R3, R0]!
        LDRB    R5, [R3], #1
        ORR     R4, R4, R5, LSL #8      ; R4 = length of special list
      |
        LDRH    R4, [R3, R0]!           ; R4 = length of special list
      ]
        TEQ     R4, #0
        MOVEQ   PC, R14                 ; no special keys, so can't be one
15
        LDHA    R5, R3, R4, R8
        TEQ     R5, R2
        BEQ     %FT20
        SUBS    R4, R4, #1
        BNE     %BT15
        MOV     PC, R14

20
        LDR     R3, [R0, #KeyHandler_SpecialCodeTable] ; R3 = offset to special table
        ADD     R3, R3, R0              ; R3 -> special code table
        SUB     R5, R3, #4              ; 0th entry is for 1st special

        LDR     R8, [R5, R4, LSL #2]    ; R8 = offset to code for this special
        ADD     R8, R8, R3              ; R8 = address of code for this special
        ADR     R3, ReturnVector

; and drop thru to ...

CallUserKeyCode ROUT
        Push    R14
        LDROSB  R5, KeyBdStatus
        LDRB    R7, PendingAltType
        Push    R5
        BL      %FT10
        Pull    R12
        STRB    R7, PendingAltType
        TEQ     R5, R12
        BLNE    OfferKeyStatusUpCall
        STROSB  R5, KeyBdStatus, R12
        Pull    R14
        B       UpdateLEDs

10
        ADRL    R12, UserKeyWorkSpace
        MOV     PC, R8

NullCharList
        =       0
        ALIGN

ReturnVector
        B       MouseButtonChange
        B       DoBreakKey

; On entry: R5 = new status, R12 = old
; On exit:  R5 = new new status, R12 corrupt, all other registers preserved
OfferKeyStatusUpCall
        Entry   "R0-R3,R10,R11"
        MRS     R11, CPSR
        ORR     R10, R11, #SVC_mode + I32_bit
        MSR     CPSR_c, R10
        Push    "R14"
        MOV     R10, #UpCallV
        MOV     R3, R5                        ; new value
        MOV     R2, R12                       ; old value
        MOV     R1, #0                        ; pre-change
        MOV     R0, #UpCall_KeyboardStatus
        BL      CallVector
        MOV     R5, R3                        ; R5 = value, after interference
10      TEQ     R5, R2
        MOVNE   R10, #UpCallV
        MOVNE   R1, #1                        ; post-change
        MOVNE   R0, #UpCall_KeyboardStatus
        BLNE    CallVector
        Pull    "R14"
        MSR     CPSR_cf, R11
        NOP
        EXIT

OfferPostKeyStatusUpCall
        ALTENTRY
        MRS     R11, CPSR
        ORR     R10, R11, #SVC_mode + I32_bit
        MSR     CPSR_c, R10
        Push    "R14"
        MOV     R3, R5
        MOV     R2, R12
        B       %BT10


; *****************************************************************************
;
;       Centisecond tick routine
;

CentiSecondTick ROUT
        Push    "R11, R14"
        LDR     R11, =ZeroPage+KeyWorkSpace

        LDR     R0, InkeyCounter
        SUBS    R0, R0, #1              ; decrement
        STRCS   R0, InkeyCounter        ; store back unless was frozen at 0

        LDR     R2, CurrKey
        TEQ     R2, #&FF
        Pull    "R11,PC", EQ            ; no current key, so no auto-repeat

        BL      UpdateLEDs              ; update LEDs from keyboard status

        LDRB    R0, AutoRepeatCount
        SUBS    R0, R0, #1              ; decrement count (if frozen then C:=0)
        STRHIB  R0, AutoRepeatCount ; store back if now non-zero and not frozen
        Pull    "R11,PC", NE            ; return if non-zero or was frozen

        LDRB    R1, Debouncing          ; get debounce flag
        TEQ     R1, #0

        STRNEB  R0, Debouncing          ; if not zero, zero it
        LDROSB  R0, KeyRepDelay, NE     ; and load delay
        MOVNE   R1, #2                  ; indicate first time

        LDROSB  R0, KeyRepRate, EQ      ; if zero, then load repeat
        MOVEQ   R1, #3                  ; indicate subsequent time

        STRB    R0, AutoRepeatCount     ; in any case, store back

        Push    "R4-R10"                ; save registers
        BL      GenerateChar            ; R2 = key number
        Pull    "R4-R11,PC"

; *****************************************************************************
;
;       DoBreakKey - Called by key handler when break key up or down
;
; in:   R0 -> key structure
;       R1 = 0 for up, 1 for down (shouldn't be 2 or 3)
;       R2 = ARM internal key number
;       R3 = address of ReturnVector
;       R4 = special number 1..n
;       R5 = keyboard status
;
; out:  R6 -> list of chars to return
;

DoBreakKey ROUT
        TST     R5, #KBStat_ShiftEngaged        ; shift down ?
        MOVEQ   R3, #31
        MOVNE   R3, #29

        TST     R5, #KBStat_CtrlEngaged         ; ctrl down ?
        BICNE   R3, R3, #4

        LDROSB  R2, BREAKvector
        MOVS    R2, R2, LSL R3                  ; put relevant bits in C,N

        MOVCS   PC, R14                         ; 2 or 3 => ignore
        BPL     %FT10                           ; 0 => do a reset

        TEQ     R1, #1                          ; is it key down ?
        ADREQ   R6, EscList                     ; yes, return ESCAPE
        MOV     PC, R14                         ; else just return

10
        TEQ     R1, #0                          ; is it key up ?
        MOVNE   PC, R14                         ; no, then return

; This entry point is used by new SWI OS_Reset (TMD 06-Jan-94)
; If it's break on the keyboard R0 <> the magic 'power off' word,when '&OFF' is
; passed in R0 the power will be turned off assuming the hardware supports it

PerformReset

        Push    R0
        WritePSRc F_bit+I_bit+SVC_mode, R14

        BL      IICAbort                        ; Ensure any CMOS operation aborted
        MOV     R1, #Service_PreReset           ; offer the pre-reset service
        BL      Issue_Service

        WritePSRc F_bit+I_bit+SVC_mode, R14     ; just in case!
        Pull    R0

        LDR     R1, PowerDownMagic
        TEQ     R0, R1
        BNE     %FT15
        AddressHAL
        MOV     a1, #0
        LDR     a2, =L1PT
        CallHAL HAL_Reset
15
        B       CONT_Break                      ; If we can't turn the power off,we may end up back here anyway

EscList
        =       1, &1B
        ALIGN
PowerDownMagic
        DCD     &46464F26

; *****************************************************************************
;
;       Generate a character in keyboard buffer, if necessary
;
; in:   R1 = 2 if first press; 3 if repetition
;       R2 = key number
;

GenerateChar ROUT
        Push    R14
        LDR     R0, KeyVec
        CMP     R0, #-1
        Pull    PC,EQ
        LDR     R5, [R0, #KeyHandler_KeyTranSize] ; get size
        BIC     R3, R5, #KeyHandler_HasFlags
        CMP     R2, R3                          ; if outside table
        BCS     %FT04                           ; then assume special

        LDR     R3, [R0, #KeyHandler_KeyTran]   ; R3 = offset to KeyTran
        ADD     R3, R3, R0                      ; R3 -> KeyTran

        TST     R5, #KeyHandler_HasFlags
        LDRNE   R6, [R0, #KeyHandler_Flags]
        TSTNE   R6, #KeyHandler_Flag_Wide
        MOVEQ   R6, #1
        MOVNE   R6, #2
        ADDNE   R3, R3, R2, LSL #2

; now modify for CTRL and SHIFT

        LDROSB  R5, KeyBdStatus

        TST     R5, #KBStat_CtrlEngaged
        ADDNE   R3, R3, R6, LSL #1

        TST     R5, #KBStat_ShiftEngaged
        ADDNE   R3, R3, R6

        TEQ     R6, #1
      [ NoARMv4
        ASSERT  :LNOT: NoUnaligned
        LDR     R3, [R3, R2, LSL #2]            ; get real code
        MOVNE   R3, R3, LSL #16
        ANDEQ   R3, R3, #255
        MOVNE   R3, R3, LSR #16
      |
        ADD     R3, R3, R2, LSL #2
        LDREQB  R3, [R3]
        LDRNEH  R3, [R3]
      ]

; apply CAPS lock modifying

        BIC     R6, R3, #&20                    ; get upper-case code
        CMP     R6, #"A"
        RSBCSS  R6, R6, #"Z"                    ; is it alphabetic ?
        BCC     %FT20

        TST     R5, #KBStat_ShiftEnable         ; if SHCAPS
        EORNE   R3, R3, #&20                    ; then swap case

        TSTEQ   R5, #KBStat_NoCapsLock          ; else if CAPS
        BICEQ   R3, R3, #&20                    ; force upper case
20
        TEQ     R3, #&FF                        ; is it a special ?
        BEQ     %FT04                           ; [yes, so skip]

        LDROSB  R6, ESCch                       ; if ESCAPE character
        TEQ     R3, R6
        LDROSB  R6, ESCaction, EQ               ; and normal ESCAPE action
        TEQEQ   R6, #0
        LDROSB  R6, ESCBREAK, EQ                ; and ESCAPE not disabled
        TSTEQ   R6, #1
        BNE     %FT21

        TST     R5, #KBStat_PendingAlt
        BEQ     %FT21
        MOV     R5, R12
        BIC     R5, R5, #KBStat_PendingAlt      ; then cancel pending alt
        BL      OfferPostKeyStatusUpCall        ; don't let them interfere
        STROSB  R5, KeyBdStatus, R6             ; and store back

21      TST     R5, #KBStat_PendingAlt          ; is there a pending Alt ?
        BNE     ProcessPendingAlt

        TEQ     R3, #0                          ; is it NUL ?
        BNE     %FT10                           ; no, so skip

        ADR     R6, NULNULList                  ; then insert NUL NUL
        B       ReturnNChars

CallSpecialReturnNChars
        Push    R14
        CMP     R0, #-1
        Pull    PC,EQ
04
        BL      CallSpecialCode

ReturnNChars
        LDRB    R3, [R6], #1                    ; R1 = count of characters

; TMD 25-Sep-89: Fix bug which resulted in Break key (acting as Escape) not
; working if buffer was full - only count spaces if more than 1 character going
; into buffer

 [ {TRUE}
        CMP     R3, #1
        Pull    PC, CC                          ; no chars, so exit now
        BEQ     %FT05                           ; only 1 char, don't count
 |
        TEQ     R3, #0                          ; no chars?
        Pull    PC, EQ                          ; then exit now
 ]

        MOV     R1, #Buff_Key
        CMP     PC, #0                          ; C=1, V=0 so count spaces
        BL      CnpEntry
        ORR     R1, R1, R2, LSL #8              ; R1 = number of spaces
        CMP     R3, R1                          ; are there enough ?
        Pull    PC, HI                          ; no, then forget them

05
        LDRB    R2, [R6], #1                    ; send chars
        BL      InsertKeyZCOE                   ; one at a time
        SUBS    R3, R3, #1
        BNE     %BT05
        Pull    PC

10
        Pull    R14                             ; restore stacked R14
        MOV     R2, R3

; and drop thru to ...

; *****************************************************************************
;
;       InsertKeyZCOE - Insert key zeroing count on escape
;
; in:   R2 = character
;

InsertKeyZCOE
        LDROSB  R0, KeyBdDisable                ; disable insertion of codes ?
        TEQ     R0, #0
        MOVNE   PC, R14                         ; [disabled]
        LDROSB  R0, ESCch                       ; escape character
        TEQ     R0, R2                          ; if is esc char
        LDROSB  R0, ESCaction, EQ
        TEQEQ   R0, #0                          ; and FX229,0

        STREQB  R0, AutoRepeatCount             ; then zero repeat counter

; and drop thru to ...

; *****************************************************************************
;
;       RDCHS - Insert character into keyboard buffer
;
; in:   R2 = character
;

RDCHS   ROUT
        MOV     R1, #Buff_Key                   ; keyboard buffer id

; Insert character R2 into buffer R1, checking for escape character

        B       DoInsertESC

; *****************************************************************************

NULNULList                                      ; list for returning NUL NUL
        =       2, 0, 0
        ALIGN

; *****************************************************************************

ProcessPendingAlt
        ADR     R6, NullCharList
        LDR     R8, [R0, #KeyHandler_PendingAltCode]
        ADD     R8, R8, R0
        BL      CallUserKeyCode
        B       ReturnNChars

; *****************************************************************************
;
;       Read character entry point
;
; in:   -
; out:  R0 = character
;       C=1 => ESCAPE
;       R1-R13 preserved
;

NewRdch
        Push    "R1-R4,R11"
        LDR     R11, =ZeroPage+KeyWorkSpace
        MOV     R4, #1                  ; indicate RDCH not INKEY
        BL      RdchInkey
        Pull    "R1-R4,R11,PC"

; *****************************************************************************
;
;       RDCH/INKEY
;
; in:   R4 = 0  => INKEY
;       R4 <> 0 => RDCH                 ; *** TMD This changed 25-Apr-91 ***
;
; out:  V=1 => error (and possibly R0 -> error block if you're lucky!)
;

RdchInkey Entry

; Enable interrupts so that keyboard can work properly

        WritePSRc SVC_mode, r1

        LDR     r1, =ZeroPage
        LDRB    r1, [r1, #RedirectInHandle]
        TEQ     r1, #0
        BEQ     %FT10

; Tutu doesn't believe that an escape condition should break redirection
; - similar to exec if you turn off escape ack side-effects

        SWI     XOS_BGet                ; get byte from redirection handle
        BVS     RedirectBadExit
        BCC     ReturnChar              ; (C=0)

; EOF, so close redirect file and read from exec file or keyboard

; stop redirecting, BEFORE closing file, in case the CLOSE gets an error

        LDR     r0, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
        STRB    r0, [r0, #RedirectInHandle] ; Convenient, huh ?
        SWI     XOS_Find                ; close file (R0=0, R1=handle)
        EXIT    VS

10

; First check for EXEC file

        LDROSB  R1, ExecFileH           ; read EXEC handle
        TEQ     R1, #0
        BEQ     %FT20                   ; no exec file

        SWI     XOS_BGet                ; get byte from exec handle
        BVS     ExecBadExit
        BCC     ReturnChar              ; (C=0)

; EOF, so close exec file and read from keyboard

; stop EXECing, BEFORE closing file, in case the CLOSE gets an error

        ASSERT (ZeroPage :AND: 255) = 0
        STROSB  R0, ExecFileH, R0       ; (STROSB sets temp reg to 0)
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
        SWI     XOS_Find                ; close file (R0=0, R1=handle)
        EXIT    VS
20
        Push    "R5,R6"
        LDR     R5, =ZeroPage
        LDRB    R5, [R5, #PortableFlags] ; 0 if not a portable, else Portable_Features result

RdchLoop
        LDR     R0, =ZeroPage
        LDRB    R0, [R0, #ESC_Status]
        MOVS    R0, R0, LSL #(32-6)     ; shift relevant bit into carry
        MOVCS   R0, #27                 ; escape detected
        BCS     ReturnChar2

        LDROSB  R1, InputStream         ; 0 => keyboard, 1 => RS423
        BL      RDCHG
        BCC     ReturnChar2

; Sam's hack to call the callback vector if appropriate

        LDR     R0, =ZeroPage
        LDRB    R14, [R0, #CallBack_Flag]
        TST     R14, #CBack_VectorReq
        BLNE    process_callback_chain

; here endeth the hack

        TEQ     R4, #0                  ; EQ => inkey, NE => rdch
        LDREQ   R0, InkeyCounter        ; if inkey
        TEQEQ   R0, #0                  ; and count expired
        BEQ     InkeyTimeout

        TST     R5, #PortableFeature_Idle
        SWINE   XPortable_Idle
        TST     R5, #PowerSave
        BNE     RdchLoop                ; if we've gone slow already, then loop
        TST     R5, #PortableFeature_Speed
        BEQ     RdchLoop                ; if speed change doesn't work, then loop
        MOV     R0, #1                  ; go slow
        MOV     R1, #0
        SWI     XPortable_Speed         ; out: R0 = old speed, R1 = new speed
        ORRVC   R5, R5, #PowerSave      ; if OK, indicate power save mode
        MOVVC   R6, R0                  ; and remember old speed
        LDRVS   R5, =ZeroPage           ; if got error, then indicate we don't want to try again
        ASSERT  (ZeroPage :AND: 255) = 0
        STRVSB  R5, [R5, #PortableFlags] ; and store this back for future RDCHs
        B       RdchLoop

InkeyTimeout
        MOV     R0, #&FF                ; indicate timeout
        SEC                             ; and set carry
ReturnChar2
        ASSERT  PowerSave < 256
        TST     R5, #PowerSave          ; NB preserves carry
        BLNE    RestoreSpeed
        Pull    "R5,R6"
ReturnChar
        CLRPSR  V_bit, R14
        EXIT

RestoreSpeed EntryS "R0"
        MOV     R0, R6                  ; restore old speed
        MOV     R1, #0                  ; AND mask of 0
        SWI     XPortable_Speed
        EXITS                           ; restore R0 and carry

ExecBadExit                             ; got an error from BGET
        Push    R0                      ; save error pointer
        ASSERT (ZeroPage :AND: 255) = 0
        STROSB  R0, ExecFileH, R0       ; (STROSB sets temp reg to 0)
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
        SWI     XOS_Find                ; close file (R0=0, R1=handle)
        Pull    "R1, R14"               ; pull registers
        MOVVC   R0, R1                  ; if closed OK, then restore old error
        SETV                            ; still indicate error
        MOV     PC, R14

RedirectBadExit                         ; got an error from BGET
        BL      RemoveOscliCharJobs     ; preserves r0
        SETV                            ; still indicate error
        Pull    "PC"                    ; pull register

; *****************************************************************************
;
;       RDCHG - Fetch character from input buffer
;       Expand soft keys as necessary
;       Pass cursor control keys to VDU driver
;       Return carry set if character not available
;
; in:   R1 = input buffer id (0 => keyboard, 1 => RS423)

RDCHG   ROUT
        Push    R14

; insert check here for ECONET interception of RDCH

RDCHNM
        LDROSB  R0, SoftKeyLen          ; are we expanding a soft key
        TEQ     R0, #0
        BEQ     RDCHG1                  ; not expanding

        LDROSB  R2, RS423mode
        TST     R1, R2                  ; if RS423 and 8 bit data
        BNE     RDCHG1                  ; ignore soft keys

        LDR     R2, SoftKeyPtr
        LDRB    R2, [R2, -R0]           ; get character out of buffer

        SUB     R0, R0, #1              ; decrement character count
        STROSB  R0, SoftKeyLen, R3      ; store back

        MOV     R0, R2                  ; put character in R0
        CLC                             ; and exit with carry clear
        Pull    PC

RDCHG1
        BL      KeyREMOVECheckRS423     ; remove character, if none, exit CS

        LDROSB  R2, RS423mode           ; 0 => treat RS423 as keyboard
        TST     R1, R2                  ; NZ => let RS423 deliver 8-bit codes
        BNE     RDCHGCLC

        TEQ     R0, #0                  ; is it NUL ?
        BNE     %FT10

        BL      KeyREMOVECheckRS423     ; get another char, if none then
                                        ; spurious, so ignore

        TEQ     R0, #0                  ; is it NUL NUL ?
        BNE     RDCHGCLC                ; no, then return this character

      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
      ]
        LDRB    R2, [R0, #OsbyteVars + :INDEX: IPbufferCh]!
                                        ; R0 was 0, so now -> 1st of 8 keybases
        ADD     R3, R0, #8
05
        TEQ     R2, #2                  ; is this key base = 2 ?
        MOVEQ   R0, #0                  ; if so then return NUL NUL
        BEQ     ReturnNULR0
        LDRB    R2, [R0, #1]!           ; load next key base
        TEQ     R0, R3                  ; if not tried all of them
        BNE     %BT05                   ; then loop
        MOV     R0, #0                  ; no special key bases,
                                        ; so just return NUL
10
        TST     R0, #&80
        BEQ     RDCHGCLC

; now check for cursor key movement

        AND     R3, R0, #&0F            ; save bottom nybble
        CMP     R3, #&0B                ; is it a cursor key ?
        BCC     NotCursorKey

        TST     R0, #&40                ; don't let Cx-Fx be cursor keys
        BNE     NotCursorKey

        LDROSB  R2, CurEdit             ; FX 4 state
        CMP     R2, #1
        ADDLS   R0, R3, #&87-&0B        ; 0 or 1 => force in range &87-&8B
        BCC     ItsCursorEdit           ; 0 => cursor edit
        BEQ     RDCHGCLC                ; 1 => return these codes

NotCursorKey
        MOV     R0, R0, LSR #4
        EOR     R0, R0, #&0C            ; 4..7, 0..3
      [ ZeroPage = 0
        LDRB    R2, [R0, #OsbyteVars+IPbufferCh-OSBYTEFirstVar]
      |
        LDR     R2, =ZeroPage+OsbyteVars+IPbufferCh-OSBYTEFirstVar
        LDRB    R2, [R0, R2]
      ]
                                        ; get key variable
        CMP     R2, #1                  ; is it 0 (ignore) or 1 (softkey)
        BCC     RDCHG1                  ; get another char if 0

        BEQ     ExpandSoftKey           ; expand soft key if 1

        TEQ     R2, #2                  ; is it special Compact option ?
        EOREQ   R0, R0, #&0C            ; undo that mangling !
        ORREQ   R0, R3, R0, LSL #4      ; if so, then return NUL <code>
        BEQ     ReturnNULR0

        ADD     R0, R2, R3              ; add offset to base
        AND     R0, R0, #&FF            ; make it wrap

RDCHGCLC
        CLC
        Pull    PC


ItsCursorEdit
        LDROSB  R2, WrchDest
        TST     R2, #2                  ; if wrch not to VDU
        BNE     RDCHG1                  ; then ignore character

        Push    "R1,R4-R12"
        VDWS    WsPtr
        BL      DoCursorEdit
        Pull    "R1,R4-R12"

        BCS     RDCHG1                  ; no character yet, so loop
        Pull    PC                      ; NB carry clear - no ESCAPE !

; *****************************************************************************
;
;       ReturnNULR0 - Return NUL followed by R0 from RDCH
;

ReturnNULR0 ROUT
        ADR     R2, SoftKeyExpand       ; store code in SoftKeyExpand +0
        STRB    R0, [R2], #1            ; and set ptr to SoftKeyExpand +1
        STR     R2, SoftKeyPtr
        MOV     R2, #1                  ; set key length to 1
        STROSB  R2, SoftKeyLen, R0      ; (sets R0 to 0!)
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
        B       RDCHGCLC                ; return NUL as first character

; *****************************************************************************

KeyREMOVECheckRS423 ROUT
        Push    R14
        BL      KeyREMOVE
        ADDCS   R13, R13, #4            ; pull stacked R14 if CS
        Pull    PC

; *****************************************************************************

KeyREMOVE
        Push    "R10,R12,R14"
        CLRV                                    ; do remove not examine
        MOV     R10, #REMV
        B       GoVec


; expand a soft key as a variable (R3 = key number)

ExpandSoftKey ROUT
        Push    "R1,R4"
        BL      SetupKeyName
        ADR     R1, SoftKeyExpand
        MOV     R2, #255                        ; max length of string
        MOV     R3, #0                          ; no name pointer
        MOV     R4, #VarType_Expanded
        SWI     XOS_ReadVarVal

        Pull    "R1,R4", VS
        BVS     RDCHG1                          ; no string or bad

        STROSB  R2, SoftKeyLen, R0              ; store length (may be zero)
        ADD     R1, R1, R2                      ; R1 -> last char+1
        STR     R1, SoftKeyPtr
        Pull    "R1,R4"
        B       RDCHNM                          ; try to expand it

KeyName
        =       keyprefix,0
        ALIGN

; *****************************************************************************
;
;       SetupKeyName - Set up the name <keyprefix><n><0> in SoftKeyName
;
; in:   R11 -> KeyWS
;       R3 = key number
;
; out:  R0 -> SoftKeyName, which contains <keyprefix><n><0>
;       R2-R4 corrupted
;

SetupKeyName ROUT
        ADR     R2, KeyName
        ADR     R0, SoftKeyName
10
        LDRB    R4, [R2], #1                    ; copy keyprefix in
        TEQ     R4, #0
        STRNEB  R4, [R0], #1
        BNE     %BT10                           ; now put digits at R0

        ORR     R3, R3, #"0"
        CMP     R3, #"9"+1

        MOVCS   R2, #"1"                        ; if >=10 then put in "1"
        STRCSB  R2, [R0], #1
        SUBCS   R3, R3, #10                     ; and subtract 10

        STRB    R3, [R0], #1
        STRB    R4, [R0]                        ; (R4=0) terminate

        ADR     R0, SoftKeyName
        MOV     PC, R14

; *****************************************************************************
;
;       DoInkeyOp - Perform INKEY

DoInkeyOp
        TST     R2, #&80                ; INKEY(+ve) ?
        BNE     NewInkeyNeg

NewInkeyPos
        Push    R4
        LDR     R11, =ZeroPage+KeyWorkSpace
        AND     R1, R1, #&FF            ; no funny business
        AND     R2, R2, #&FF            ; ditto
        ORR     R1, R1, R2, LSL #8      ; get combined count
        STR     R1, InkeyCounter

        MOV     R4, #0                  ; indicate inkey not rdch
        BL      RdchInkey

        MOV     R1, R0                  ; make X the character
        MOVCC   R2, #0                  ; Y := 0 if normal exit
        MOVCS   R2, R0                  ; Y := &1B or &FF for ESC or timeout

        Pull    "R4,PC"                 ; return preserving V and R0

NewInkeyNeg
        EOR     R1, R1, #&7F            ; invert bits for scan call
        EOR     R2, R2, #&7F
        BL      BBCScanKeys
        Pull    PC

; *****************************************************************************
;
;       BBCScanKeys - Test individual key or scan for key depression
;
; in:   R1 = 0..&7F => scan keyboard from BBC internal key R1+(R2<<8)
; out:  C=0 => R1 = BBC internal key found
;       C=1 => R1 = &FF (no key found)
;
; in:   R1 = &80..&FF => test if BBC internal key ((R1+(R2<<8)) EOR &80) is down
; out:  C=0, R1=R2=&00 => key is up
;       C=1, R1=R2=&FF => key is down
;

BBCScanKeys ROUT
        Push    "R10, R11, LR"
        LDR     R11, =ZeroPage+KeyWorkSpace
        AND     R1, R1, #&FF            ; trap wallies

        AND     R10, R2, #&7F

        LDR     R2, KeyVec

        TST     R1, #&80                ; >=&80 => test single key
                                        ; < &80 => scan for key
        BEQ     DoBBCScan               ; [is scanning not testing]

        ADD     R0, R2, #1
        CMP     R0, #1                  ; if no key handler then
        MOVCC   R1, #0                  ;   return key up (C=0)
        BCC     ExitBBCTest

        TEQ     R1, #&80+13             ; extension range?
        TEQNE   R1, #&80+15             
        BEQ     DoBBCTestExtension

        LDR     R0, [R2, #KeyHandler_InkeyTran]
        ADD     R0, R2, R0              ; R0 -> InkeyTran or InkeyTran2

        ADD     R0, R0, #4 * &FF        ; R0 -> InkeyTran+4*&FF
        LDR     R0, [R0, -R1, LSL #2]   ; get word of indexes into KeysDown

        LDR     R10, [R2, #KeyHandler_KeyTranSize]
        TST     R10, #KeyHandler_HasFlags
        LDRNE   R10, [R2, #KeyHandler_Flags]
        TSTNE   R10, #KeyHandler_Flag_Wide
        MOVNE   R2, #&FF0000
        BNE     DoBBCTestWide

        MOV     R2, #&FF000000
02
        CMP     R0, #-1                 ; is it all FF's
        MOVEQ   R1, #0                  ; if so then none of keys down
        BEQ     %FT04

        AND     R1, R0, #&FF            ; just get bottom byte
        ADR     R3, KeysDown            ; look up in KeysDown
        MOV     R1, R1, LSR #5
        LDR     R3, [R3, R1, LSL #2]    ; get word of 32 bits
        AND     R1, R0, #31
        MOV     R3, R3, LSL R1          ; put relevant bit into top bit
        MOVS    R1, R3, LSR #31         ; R1 = 0 if up, 1 if down
        ORREQ   R0, R2, R0, LSR #8      ; shift down, putting FF in top byte
        BEQ     %BT02

04
        CMP     R1, #1                  ; C=1 <=> at least one of keys down
        MOVCC   R1, #0
        MOVCS   R1, #&FF
        MOV     R2, R1
ExitBBCTest
        Pull    "R10, R11, PC"

DoBBCTestWide
        MOV     R1, R0, LSL #16         ; get bottom entry
        CMP     R1, #&FF0000            ; is it FF?
        MOVEQ   R1, #0                  ; if so then none of keys down
        BEQ     %BT04

        ADR     R3, KeysDown            ; look up in KeysDown
        MOV     R1, R1, LSR #5+16
        LDR     R3, [R3, R1, LSL #2]    ; get word of 32 bits
        AND     R1, R0, #31
        MOV     R3, R3, LSL R1          ; put relevant bit into top bit
        MOVS    R1, R3, LSR #31         ; R1 = 0 if up, 1 if down
        ORREQ   R0, R2, R0, LSR #16     ; shift down, putting FF in top entry
        BEQ     DoBBCTestWide
        B       %BT04

DoBBCTestExtension
        TST     R1, #2
        ADDEQ   R10, R10, #&100 ; EQ -> (R1 AND &7F) = 13
        ADDNE   R10, R10, #&200 ; NE -> (R1 AND &7F) = 15
        ADR     R3, KeysDown
        MOV     R1, R10, LSR #5
        LDR     R3, [R3, R1, LSL #2]
        AND     R1, R10, #31
        MOV     R3, R3, LSL R1
        MOV     R1, R3, LSR #31
        B       %BT04

DoBBCScan       ROUT
        CMP     R2, #-1                 ; if no key handler then
        MOVEQ   r1, #&FF                ;   return all keys up (C=1)
        BEQ     ExitBBCTest
        Push    "R4, R5"

        ; Check for extension key range and include R10 if necessary
        TEQ     R1, #13
        TEQNE   R1, #15
        ORREQ   R1, R1, R10, LSL #8

        LDR     R0, [R2, #KeyHandler_InkeyTran]
        ADD     R0, R2, R0              ; R0 -> InkeyTran or InkeyTran2

        ADD     R0, R0, #4 * &7F        ; R0 -> InkeyTran+4*&7F

        LDR     R4, [R2, #KeyHandler_KeyTranSize]
        TST     R4, #KeyHandler_HasFlags
        LDRNE   R4, [R2, #KeyHandler_Flags]
        TSTNE   R4, #KeyHandler_Flag_Wide
        MOVNE   R4, #&FF0000
        BNE     DoBBCScanWide

        MOV     R4, #&FF000000
10
        AND     R3, R1, #&7F-2
        TEQ     R3, #13                 ; 13 or 15?
        BLEQ    DoBBCScanExtension      ; handle extension range scan
        LDR     R3, [R0, -R1, LSL #2]   ; get word of indexes into KeysDown
15
        CMP     R3, #-1                 ; all FFs ?
        BEQ     %FT18                   ; then not one of these keys

        AND     R5, R3, #&FF
        ADR     R2, KeysDown
        MOV     R5, R5, LSR #5
        LDR     R2, [R2, R5, LSL #2]    ; get word of bits
        AND     R5, R3, #31
        MOV     R2, R2, LSL R5          ; put relevant bit into top bit
        MOVS    R5, R2, LSR #31         ; R5 = 0 for up, 1 for down
        BNE     ExitBBCScan             ; [down, so stop]
        ORR     R3, R4, R3, LSR #8      ; up -> shift down putting FF in top
        B       %BT15
18
        ADD     R1, R1, #1              ; go to next key
        TEQ     R1, #&80                ; if not run out of keys
        BNE     %BT10                   ; then loop
        MOV     R1, #&FF                ; indicate no key
ExitBBCScan
        MOV     R2, #0
        TEQ     R1, #&FF
        MOVEQ   R2, #C_bit
        MSR     CPSR_f, R2              ; C=0 <=> found key
        Pull    "R4,R5,R10,R11,PC"

DoBBCScanWide   ROUT
        AND     R3, R1, #&7F-2
        TEQ     R3, #13                 ; 13 or 15?
        BLEQ    DoBBCScanExtension      ; handle extension range scan
        LDR     R3, [R0, -R1, LSL #2]   ; get word of indexes into KeysDown
15
        MOV     R5, R3, LSL #16         ; get bottom entry
        CMP     R5, #&FF0000            ; is it FF?
        BEQ     %FT18                   ; then not one of these keys

        ADR     R2, KeysDown
        MOV     R5, R5, LSR #5+16
        LDR     R2, [R2, R5, LSL #2]    ; get word of bits
        AND     R5, R3, #31
        MOV     R2, R2, LSL R5          ; put relevant bit into top bit
        MOVS    R5, R2, LSR #31         ; R5 = 0 for up, 1 for down
        BNE     ExitBBCScan             ; [down, so stop]
        ORR     R3, R4, R3, LSR #16     ; up -> shift down putting FF in top
        B       %BT15
18
        ADD     R1, R1, #1              ; go to next key
        TEQ     R1, #&80                ; if not run out of keys
        BNE     DoBBCScanWide           ; then loop
        MOV     R1, #&FF                ; indicate no key
        B       ExitBBCScan

DoBBCScanExtension ROUT
        ; R2, R3, R5, R10 corruptible
        ; Return to LR if no key found
        MOV     R10, R1, LSR #8
        TST     R1, #2
        ADDEQ   R10, R10, #&100 ; EQ -> (R1 AND &7F) = 13
        ADDNE   R10, R10, #&200 ; NE -> (R1 AND &7F) = 15
        ADR     R2, KeysDown
10
        MOV     R3, R10, LSR #5
        LDR     R3, [R2, R3, LSL #2]
        AND     R5, R10, #31
        MOVS    R3, R3, LSL R5
        BNE     %FT20                   ; found one

        BIC     R10, R10, #31           ; skip to next word
        ADD     R10, R10, #32
        TEQ     R10, #&300
        BNE     %BT10
        ; Ran out of extension keys
        MOV     R1, #16
        MOV     PC, LR

20
      [ NoARMv5
        CMP     R3, #1<<16
        ADDLO   R10, R10, #16
        MOVLO   R3, R3, LSL #16
        CMP     R3, #1<<24
        ADDLO   R10, R10, #8
        MOVLO   R3, R3, LSL #8
        CMP     R3, #1<<28
        ADDLO   R10, R10, #4
        MOVLO   R3, R3, LSL #4
        CMP     R3, #1<<30
        ADDLO   R10, R10, #2
        MOVLO   R3, R3, LSL #2
        TST     R3, #1<<31
        ADDEQ   R10, R10, #1
      |
        CLZ     R3, R3
        ADD     R10, R10, R3
      ]
        ; Convert back to inkey key
        TST     R10, #&100
        MOVNE   R1, #13
        MOVEQ   R1, #15
        ORR     R1, R1, R10, LSL #8
        BIC     R1, R1, #&FF0000
        B       ExitBBCScan
        

; *****************************************************************************
;
;       Write keys down information
;
; in:   R1 = Current key (in BBC internal key format)
;       R2 = Old key     (------------""------------)
;
; out:  R1, R2 preserved
;       R3 corrupt
;
; Note: Doesn't deal with extended key numbers
;

WriteKeysDown ROUT
        Push    R14
        LDR     R11, =ZeroPage+KeyWorkSpace
        AND     R0, R1, #&FF            ; mask off any extension bits
        BL      ConvertInternalKey
        STR     R0, CurrKey
        AND     R0, R2, #&FF
        BL      ConvertInternalKey
        STR     R0, OldKey
        Pull    PC

; in:   R0 = INKEY code EOR &FF
; out:  R0 = internal low level key number
;       R3 corrupt
ConvertInternalKey ROUT
        TST     R0, #&80                ; if not in range &80..&FF
        MOVEQ   R0, #&FF                ; return value &FF (key not valid)
        MOVEQ   PC, R14

        EOR     R0, R0, #&7F            ; else convert to inkey value
        
        LDR     R3, KeyVec
        CMP     R3, #-1                 ; if no key handler then
        MOVEQ   R0, #&FF                ;   return no key
        MOVEQ   PC, R14

        Push    R4
        LDR     R4, [R3, #KeyHandler_KeyTranSize]
        TST     R4, #KeyHandler_HasFlags
        LDRNE   R4, [R3, #KeyHandler_Flags]
        TSTNE   R4, #KeyHandler_Flag_Wide

        LDR     R4, [R3, #KeyHandler_InkeyTran]
        ADD     R3, R3, R0, LSL #2

        SUB     R3, R3, #&80*4          ; R3 -> InkeyTran-4*&80

      [ NoARMv4
        LDRB    R0, [R3, R4]!           ; convert to ARM internal key
                                        ; (just get 1st key for this key)
        LDRNEB  R4, [R3, #1]
        ORRNE   R0, R0, R4, LSL #8
      |
        LDREQB  R0, [R3, R4]
        LDRNEH  R0, [R3, R4]
      ]
        Pull    R4
        MOV     PC, R14


; *****************************************************************************
;
;       InstallKeyHandler - Install user key handler
;
; in:   R0 = new key handler
;        0 => just read old key handler
;        1 => just read keyboard id
;
; out:  R0 = old key handler, or
;       R0 = keyboard id if R0 was 1 on entry (&FF => no keyboard id yet)
;

InstallKeyHandler ROUT
        MRS     R11, CPSR
        ORR     R11, R11, #I32_bit
        MSR     CPSR_c, R11             ; disable IRQs

        LDR     R11, =ZeroPage+KeyWorkSpace
        TEQ     R0, #1                  ; asking for keyboard id ?
        LDREQB  R0, KbId                ; then load it
        ExitSWIHandler EQ               ; and exit

        LDR     R10, KeyVec             ; R10 -> old key handler
        TEQ     R0, #0                  ; if not just reading it
        STRNE   R0, KeyVec              ; then store new one
        MOV     R0, R10                 ; R0 -> old key handler
        ExitSWIHandler EQ               ; exit if just reading

        Push    "R0-R12,LR"
        BL      KeyboardEnable
        Pull    "R0-R12,LR"
        ExitSWIHandler

; *****************************************************************************
;
;       IssueKeyboardService - Issue keyboard handler service
;
; in:   R11 -> KeyWorkSpace
;
; out:  R0 preserved
;

IssueKeyboardService
        Push    "R0,R14"
        MOV     R1, #Service_KeyHandler
        LDRB    R2, KbId
        BL      Issue_Service
        Pull    "R0,PC"

        LTORG

        END
@


4.11
log
@Recover gracefully from a completely blank set of CMOS
Newly born boards have all 0xFF's in their CMOS (EEPROM), but the new order of keyboard scan did
  Init -> Scan keyboard -> Check (or wipe) CMOS
and would therefore leave 0xFF's in a select few kernel workspace areas and OS_Byte values.
Defer the init which reads CMOS until after the check/wipe step. Only the screen area size is now done early, but MassageScreenSize clamps that properly anyway.

Arthur3.s: Relocate stranded function SetupPrinterBuffer to osinit.
PMF/key.s: Drop support for SoftReset.
PMF/osinit.s: Stuff in hardcoded defaults at early init. Retrieve the proper ones later. Take ownership of SystemSprite/RamFS/Font Manager dynamic areas (deferrable).
vdudriver.s: Use symbolic name.
NewReset.s: Defer SystemSprite/RamFS/Font Manager area creation, MouseInit, Read(Hard)CMOSDefaults until later.
hdr/Options: Delete unused IgnoreVRAM. Remove MaxRAMFS_Size now PMPs make it not useful. Shuffle ARM6Support/XScaleMiniCache/XScaleJTAGDebug to be adjacent to their definitions.

Tested by filling first 256 bytes with 0xFF and powering up. Reset now completes, OS_Byte variables look sensible.

Version 5.95. Tagged as 'Kernel-5_95'
@
text
@a653 1
; out:  R12 corrupted
a657 1
        MOV     R12, #IOC
a763 1
;       R12 -> IOC
@


4.10
log
@Change module initialisation to be a two pass scheme
Detail:
  To make it easier to support arbitrary complexity keyboard controllers (eg. USB via DWCDriver on the Pi) have the kernel do the early keyboard recovery key press detection instead of the HAL.
  During the first pass those modules used for reading the keyboard are started, ignoring the CMOS frugal bits.
  The keyboard is then scanned for 3s, during which time the RAM is cleared (unless the HAL indicated it has already been done).
  During the second pass the remaining modules are started respecting the CMOS frugal bits. Any which were already started in the first pass are inserted into the new chain, so the keyboard is reset once and only once.

  Boot times, with a 300cs key scan time in NewReset.
  Risc PC with 160MB RAM (128+32+0).
  Times from turning on power to initial "beep", using a stopwatch.
                RISC OS 3.70 RISC OS 5.22 This OS
  ARM610        12.5         10.4         10.3
  ARM710        11.8         10.2         9.7
  StrongARM 233 11.1         9.5          8.4

  In NewReset.s:
  Remove old KbdScan code (leave Reset_IRQ_Handler for IIC only)
  If HAL_KbdScanDependencies returns a null string then present KbdDone flag and skip to full init.
  A few vestiges of soft resets removed.
  Do RAM clear when waiting for INKEY (being careful not to trash the running modules...).
  Clearing just the freepool on a 2GB Titanium cleared 7EFD6 pages (99.2%).

  In ModHand.s:
  2nd pass need to sneaky renumber the nodes (so *ROMModules is in the right order, frugal bits line up) without resetting the chain

  In HAL.s:
  Change ClearPhysRAM to ClearWkspRAM, such that it only clears the kernel workspace rather than all RAM. The bulk of the RAM is cleared during the keyboard scan by new function ClearFreePoolSection.
  Add a variant of Init_MapInRAM which clears the mapped in RAM too (as these very early claims will not be in the free pool when the RAM is cleared later).
  Remove HAL keyboard scan setup & IRQ handler.
  Fix bug in HALDebugHexTX2, the input value needs pre-shifting by 16b before continuing.

  In GetAll.s, PMF/osbyte.s:
  Use Hdr:Countries and Hdr:OsBytes for constants.

  In PMF/key.s, PMF/osinit.s:
  Relocate the key post init from PostInit to KeyPostInit.
  Changed PostInit to not tail call KeyPostInit so they can be called independently.

  In hdr/KernelWs:
  Improve comments, add InitWsStart label to refer to.

  In hdr/HALEntries:
  Add HAL_KbdScanDependencies.
  Delete KbdFlag exports.
  Took the opportunity to reorder some of the higher numbered HAL entries and re-grouping, specifically (112,120) (84,106,108,117).
Admin:
  Tested on an ARM6/ARM7/SA Risc PC, BeagleBoard xM, Iyonix, Pandaboard ES, Wandboard Quad, IPEGv5, Titanium, Pi 2 and 3.
  Requires corresponding HAL change.
  Submission for USB bounty.

Version 5.89. Tagged as 'Kernel-5_89'
@
text
@a101 4
        LDROSB  R1, LastBREAK           ; is it a soft reset ?
        TEQ     R1, #SoftReset
        Pull    PC, EQ                  ; if so, then exit

@


4.9
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d84 8
d96 1
a96 1
        TEQ     R1, #&FF                ; if no keyboard initialised yet then
d103 1
a103 1
        TEQ     R1, #0
d106 1
a106 1
        MOV     R0, #OsbyteSetCountry
@


4.9.2.1
log
@Merge latest changes from main branch

Version 5.89, 4.129.2.6. Tagged as 'Kernel-5_89-4_129_2_6'
@
text
@a83 8
        BYTEWS  WsPtr

        MOV     R0, #TerritoryNum_UK    ; indicate keyboard UK
        MOV     R1, #ISOAlphabet_Latin1 ; indicate alphabet Latin1
        STRB    R0, Keyboard
        STRB    R1, Alphabet
        STRB    R1, KeyAlphabet         ; alphabet corresponding to keyboard

d88 1
a88 1
        TEQ     R1, #KeyboardID_None    ; if no keyboard initialised yet then
d95 1
a95 1
        TEQ     R1, #SoftReset
d98 1
a98 1
        MOV     R0, #OsByte_Country
@


4.9.2.2
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d102 4
@


4.9.2.3
log
@Merge in latest changes from main branch

Version 6.05, 4.129.2.8. Tagged as 'Kernel-6_05-4_129_2_8'
@
text
@d654 1
d659 1
d766 1
@


4.8
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a53 3
        GBLL    MouseBufferFix
MouseBufferFix SETL {TRUE}

a65 4
 [ Keyboard_Type = "A1A500"
        BL      A1KeyInit
 ]

a74 4
 [ Keyboard_Type = "A1A500"
        BL      A1Reset
 ]

a168 1
 [ AssembleKEYV
a179 7
 |
  [ Keyboard_Type = "A1A500"
        B       A1KeyVec
  |
        MOV     pc, lr
  ]
 ]
a266 1
 [ AssembleKEYV
a268 5
 |
  [ Keyboard_Type = "A1A500"
        BL      A1KeyVec
  ]
 ]
a270 1
 [ AssembleKEYV
a292 4
 |
GotKey ROUT
        Push    lr
 ]
a380 1
 [ AssembleKEYV
a381 3
 |
        Pull    pc
 ]
a720 1
        [ AssemblingArthur
a748 3
        |
        MOV     PC, R14                         ; do nowt
        ]
a1020 1
 [ StorkPowerSave
a1021 3
 |
        LDRB    R5, [R5, #PortableFlag] ; 0 if want to try issuing SWI, 1 if know it's hopeless
 ]
a1035 1
        [ AssemblingArthur
a1039 1
        ]
a1047 1
 [ StorkPowerSave
a1061 12
 |
        CMP     R5, #1                  ; if we've gone slow already (2), or there's no portable module (1), then loop
        BCS     RdchLoop
        MOV     R0, #1                  ; go slow
        MOV     R1, #0                  ; ignore old speed
        SWI     XPortable_Speed         ; out: R0 = old speed, R1 = new speed
        MOVVC   R5, #2                  ; if OK, indicate we've successfully gone slow
        MOVVC   R6, R0                  ; and remember old speed
        LDRVS   R5, =ZeroPage+1         ; if got error, then indicate we don't want to try again
        ASSERT  (ZeroPage :AND: 255) = 0
        STRVSB  R5, [R5, #PortableFlag-1] ; and store this back for future RDCHs
 ]
d1068 1
a1068 1
 [ StorkPowerSave
a1070 4
 |
        TEQ     R5, #2                  ; NB preserves carry
        BLEQ    RestoreSpeed
 ]
a1216 1
        [ AssemblingArthur
a1218 3
        |
        BL      DCE10
        ]
a1223 6
        [ :LNOT: AssemblingArthur
DCE10
        MOV     R1, #VduDriver
        ADD     PC, R1, #CursorEdit
        ]

@


4.7
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a777 4
        [ :LNOT: HAL
        LDR     r0, =&83900000                  ; Address in IOMD to force power off
        LDR     r0, [r0]
        |
a781 1
        ]
@


4.6
log
@  Improved the error cacheing.
  Removed DriversInKernel conditional.
Detail:
  If the territory changes or the resource file changes, the kernel
    will now decache all the cached error blocks so that next time
    they are required, they will be looked up again.
  The error cacheing is now a kernel build option and is always set
    to on.
  Removed one of the 5 error messages to be cached - it never seems
    to happen.  The remaining 4 are more frequent.
Admin:
  Tested in Ursula build.
  Cannot be used with HdrSrc 0.94.  HdrSrc 0.95 and later is required
    (or HdrSrc 0.93 and earlier subject to other kernel requirements)
  Requires MessageTrans 0.42 or later for correct operation when a
    replacement messages file is loaded.

Version 5.32. Tagged as 'Kernel-5_32'
@
text
@d51 2
d64 1
a64 1
        MOV     R11, #KeyWorkSpace
d95 1
a95 1
        MOV     R11, #KeyWorkSpace
d117 1
a117 1
        Push    R14
d120 2
a121 2
        STRB    R0, CurrKey             ; no current key
        STRB    R0, OldKey
d127 6
a132 5
        STR     R0, KeysDown            ; zero 160 bits = 5 words
        STR     R0, KeysDown +4
        STR     R0, KeysDown +8
        STR     R0, KeysDown +12
        STR     R0, KeysDown +16
d134 1
a134 1
        Pull    PC
a140 1
;       R12 -> IOC
d159 14
d182 1
a182 1
        mrs    ,r11, CPSR               ; Save current PSR.
d184 1
a184 1
        msr    ,CPSR_c, r10             ; Call KEYV in SVC mode, no IRQs.
d189 1
a189 1
        msr    ,CPSR_cf, r11            ; Go back to old mode.
d202 25
d229 1
d241 5
d248 1
d258 5
d281 1
a281 1
        LDR     r8, [r0, #KVInit]       ; Initialise key handler.
d303 1
d314 1
a314 1
        MOV     r11, #KeyWorkSpace
d327 1
a327 1
        CMP     R2, #&A0
d358 1
a358 1
        LDRB    R0, CurrKey
d362 1
a362 1
        LDRB    R1, OldKey
d366 1
a366 1
        STRB    R0, OldKey              ; make current key old
d368 5
a372 2
        STRB    R2, CurrKey             ; update current
        MOV     R0, #2
d374 1
d377 3
d383 1
a383 1
        LDRB    R0, OldKey
d389 1
a389 1
        LDRB    R0, CurrKey             ; current key is one to ignore in scan
d392 1
a392 1
        STRPLB  R0, OldKey              ; found key, so current -> old
d396 1
a396 1
        STRB    R0, OldKey
d400 1
a400 1
        LDRB    R1, CurrKey
d407 2
a408 1
        STRB    R2, CurrKey             ; mark current key up (R2 = -1)
d444 1
a444 1
        MOV     R2, #4
d446 2
d496 7
a502 1
        LDR     R3, [R0, #KVKeyTranSize] ; maximum internal key number +1
d504 1
a504 1
        LDRCC   R3, [R0, #KVKeyTran]    ; no, R3 := offset to keytran
d510 1
a510 1
        LDR     R3, [R0, #KVShiftingList] ; R3 = offset to shifting key list
d522 39
d571 1
d573 5
a577 1
        LDR     R3, [R0, #KVSpecialList] ; R3 = offset to special list
d589 18
d608 1
a608 1
        LDR     R3, [R0, #KVSpecialCodeTable] ; R3 = offset to special table
a629 1
        MOV     R12, #IOC
d648 1
a648 1
        mrs    ,R11, CPSR
d650 1
a650 1
        msr    ,CPSR_c, R10
d665 1
a665 1
        msr    ,CPSR_cf, R11
d671 1
a671 1
        mrs    ,R11, CPSR
d673 2
a674 1
        msr    ,CPSR_c, R10
d688 1
a688 1
        MOV     R11, #KeyWorkSpace
a690 6
        [ PollMouse
        MOV     R0, #K1rqmp
        STRB    R0, RequestMouse
        TXon    R0
        ]

d695 1
a695 1
        LDRB    R2, CurrKey
d760 2
d765 1
a765 2
; offer the pre-reset service

d768 3
a770 10
; Ensure any CMOS operation aborted

        MOV     R1,#16                          ; Two bytes in case RTC transmitting
20      BL      Start                           ; Start/clock edge
        BL      Stop
        SUBS    R1,R1,#1
        BNE     %BT20

        MOV     R1, #Service_PreReset
        IssueService
d773 1
d775 14
a788 1
        B       CONT_Break
d796 2
d813 2
a814 1
        LDR     R3, [R0, #KVKeyTranSize]        ; get size
d818 1
a818 1
        LDR     R3, [R0, #KVKeyTran]            ; R3 = offset to KeyTran
d821 7
d833 1
a833 1
        ADDNE   R3, R3, #2
d836 1
a836 1
        ADDNE   R3, R3, #1
d838 12
a849 1
        LDRB    R3, [R3, R2, LSL #2]            ; get real code
d876 5
a880 4
        MOVNE   R5, R12
        BICNE   R5, R5, #KBStat_PendingAlt      ; then cancel pending alt
        BLNE    OfferPostKeyStatusUpCall        ; don't let them interfere
        STROSB  R5, KeyBdStatus, R6, NE         ; and store back
d893 2
d978 1
a978 1
        LDR     R8, [R0, #KVPendingAltCode]
d995 1
a995 1
        MOV     R11, #KeyWorkSpace
d1016 1
a1016 1
        MOV     r1, #0
d1032 2
a1033 1
        MOV     r0, #0
d1054 1
d1056 3
d1063 1
a1063 1
        MOV     R5, #0
d1071 1
a1071 1
        MOV     R0, #0
d1084 1
a1084 1
        MOV     R0, #0
d1109 2
a1110 1
        MOVVS   R5, #0                  ; if got error, then indicate we don't want to try again
d1120 2
a1121 1
        MOVVS   R5, #1                  ; if got error, then indicate we don't want to try again
d1150 1
d1152 3
d1215 3
d1252 1
d1254 4
d1311 3
d1321 1
a1321 1
        Pull    "R14, PC", CS           ; pull stacked R14 if CS
d1400 1
a1400 1
        MOV     R11, #KeyWorkSpace
d1417 1
d1425 1
a1425 1
; in:   R1 = 0..&7F => scan keyboard from BBC internal key R1
d1429 1
a1429 1
; in:   R1 = &80..&FF => test if BBC internal key (R1 EOR &80) is down
d1435 2
a1436 2
        Push    R11
        MOV     R11, #KeyWorkSpace
d1439 2
d1450 1
a1450 1
        BCC     ExitBBCScan
d1452 5
a1456 1
        LDR     R0, [R2, #KVInkeyTran]
d1461 8
d1484 1
d1490 30
a1519 3
ExitBBCScan
        Pull    R11
        MOV     PC, R14
d1521 1
a1521 1
DoBBCScan
d1524 9
a1532 2
        BEQ     ExitBBCScan
        LDR     R0, [R2, #KVInkeyTran]
a1534 1
        Push    "R4, R5"
d1536 8
d1546 3
d1561 1
a1561 1
        BNE     %FT20                   ; [down, so stop]
d1569 56
d1626 27
a1652 3
        CMP     R1, #&FF                ; C=0 <=> found key
        Pull    "R4,R5,R11"
        MOV     PC, R14
d1662 3
d1669 2
a1670 2
        MOV     R11, #KeyWorkSpace
        MOV     R0, R1
d1672 2
a1673 2
        STRB    R0, CurrKey
        MOV     R0, R2
d1675 1
a1675 1
        STRB    R0, OldKey
d1678 4
a1681 1
ConvertInternalKey
d1687 1
a1687 1
        Push    R4
d1692 9
a1700 3
        LDR     R4, [R3, #KVInkeyTran]
        ADD     R3, R3, R4              ; R3 -> InkeyTran or InkeyTran2
        Pull    R4
d1704 2
a1705 1
        LDRB    R0, [R3, R0, LSL #2]    ; convert to ARM internal key
d1707 7
d1730 1
a1730 1
        mrs    ,R11, CPSR
d1732 1
a1732 1
        msr    ,CPSR_c, R11             ; disable IRQs
d1734 1
a1734 1
        MOV     R11, #KeyWorkSpace
d1763 1
a1763 1
        IssueService
d1766 1
@


4.6.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d166 1
a166 1
        MRS     r11, CPSR               ; Save current PSR.
d168 1
a168 1
        MSR     CPSR_c, r10             ; Call KEYV in SVC mode, no IRQs.
d173 1
a173 1
        MSR     CPSR_cf, r11            ; Go back to old mode.
d517 1
a517 1
        MRS     R11, CPSR
d519 1
a519 1
        MSR     CPSR_c, R10
d534 1
a534 1
        MSR     CPSR_cf, R11
d540 1
a540 1
        MRS     R11, CPSR
d542 1
a542 1
        MSR     CPSR_c, R10
d1390 1
a1390 1
        MRS     R11, CPSR
d1392 1
a1392 1
        MSR     CPSR_c, R11             ; disable IRQs
@


4.6.2.2
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a156 15
        ; fall through
        ASSERT  . = SetLEDs

; *****************************************************************************
;
;       SetLEDs - Set the LED(s) to a specific value
;
; in:   R1 = desired LED state (bit 0 = caps lock, 1 = num lock, 2 = scroll lock)
;       R11 -> keyboard workspace
;       R12 -> IOC
;
; out:  R0, R1 corrupted
;

SetLEDs
a185 25
;       LEDsOn - Turn on all the LEDs
;
; out:  all registers preserved
;

LEDsOn  Push    "r0,r1,r11,lr"
        MOV     r1, #7
        MOV     r11, #KeyWorkSpace
        BL      SetLEDs
        Pull    "r0,r1,r11,pc"

; *****************************************************************************
;
;       LEDsOff - Restore the LEDs to keyboard status
;
; out:  all registers preserved
;

LEDsOff Push    "r0,r1,r11,lr"
        MOV     r11, #KeyWorkSpace
        BL      UpdateLEDs
        Pull    "r0,r1,r11,pc"

; *****************************************************************************
;
d643 5
a647 1
        BL      IICAbort
@


4.6.2.3
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@a673 2
; If it's break on the keyboard R0 <> the magic 'power off' word,when '&OFF' is
; passed in R0 the power will be turned off assuming the hardware supports it
d677 2
a678 1
        Push    R0
d680 6
a685 3
        
        BL      IICAbort                        ; Ensure any CMOS operation aborted
        MOV     R1, #Service_PreReset           ; offer the pre-reset service
a688 1
        Pull    R0
d690 1
a690 13
        LDR     R1, PowerDownMagic
        TEQ     R0, R1
        BNE     %FT15
        [ :LNOT: HAL
        LDR     r0, =&83900000                  ; Address in IOMD to force power off
        LDR     r0, [r0]
        |
        AddressHAL
        MOV     a1, #0
        CallHAL HAL_Reset
        ]
15
        B       CONT_Break                      ; If we can't turn the power off,we may end up back here anyway
a697 2
PowerDownMagic
        DCD     &46464F26
@


4.6.2.4
log
@Should fix Alt-Escape so that it (a) clears the PendingAlt bit again, and
(b) doesn't unbalance the SVC stack.

Version 5.35, 4.79.2.57. Tagged as 'Kernel-5_35-4_79_2_57'
@
text
@a582 1
        Push    "R14"
d681 1
a681 1

d770 4
a773 5
        BEQ     %FT21
        MOV     R5, R12
        BIC     R5, R5, #KBStat_PendingAlt      ; then cancel pending alt
        BL      OfferPostKeyStatusUpCall        ; don't let them interfere
        STROSB  R5, KeyBdStatus, R6             ; and store back
@


4.6.2.5
log
@Fixed bug in KeyV handling: if it was called before the keyboard handler was
installed, it would abort reading from an address that used to be in the
logical copy of physical space on an IOMD machine. This manifested itself
during software-initiated resets as an abort during ROM init, leaving you
with an apparently dead machine.

Version 5.35, 4.79.2.61. Tagged as 'Kernel-5_35-4_79_2_61'
@
text
@a787 2
        CMP     R0, #-1
        Pull    PC,EQ
@


4.6.2.6
log
@* HAL can choose to limit amount of screen memory to allocate
  [Not fully implemented - for now leaves at least 16MB free if only
  one RAM area; was 1MB].
* Added HAL_USBControllerInfo, HAL_MonitorLeadID and HAL_Video_Render.
* Added HAL->OS call OS_IICOpV.
* OS_MMUControl now allows independent control of I and C bits.
* Added facility to deactivate keyboard debounce (magic word "NoKd" in
  R2 in KeyV 0).
* Fixed problem with RAM amounts not a multiple of 4MB.
* Supremacy bit (in VDU 19) now sets all 8 bits of supremacy.
* Added PaletteV 14 (reads gamma tables).
* Added Supremacy transfer functions (like gamma correction, but for
  supremacy). Allows easy global supremacy effects in a mode-independent
  fashion. Controlled with PaletteV 15,16.
* Added modes 50-53 (320x240, 1,2,4,8bpp). Intended for small LCD.
* Added 13.5kHz versions of TV modes (selected by Hdr:Machine).
* Upped desktop version to 5.06.

Version 5.35, 4.79.2.66. Tagged as 'Kernel-5_35-4_79_2_66'
@
text
@a50 2
; 28-Apr-04 JWB Added magic switch to turn off kernel kbd debounce
;               r2 on KEYV vector 0 = 'NoKd' to disable debounce
a227 1
;               r2 = magic 'NoKd' to disable kernel debouncing
a238 5
        LDR     lr, NoKbMagic
        TEQ     r2, lr
        MOVNE   lr, #0
        STRB    lr, NoDebounce          ; remember kernel debounce switch

a240 1

a249 5

NoKbMagic DCD   &4e6f4b64               ; Magic of NoKd to signal no kernel
                                        ;   debounce


a289 1
;               r2 = magic 'NoKd' if kernel debouncing to be disabled
d355 1
a355 4
        LDRB    r1, NoDebounce          ; check debouncing?
        TEQ     r1, #0
        MOVEQ   R0, #2                  ; Eq.. normal kernel debounce
        MOVNE   R0, #0                  ; NE.. no kernel debounce
a356 1
        LDROSB  R0, KeyRepDelay, NE     ; and load delay
a357 3

        MOVNE   r1,#2                   ; mark as first key
        BLNE    GenerateChar            ; R2 = key number
@


4.6.2.7
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d64 1
a64 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d95 1
a95 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d210 1
a210 1
        LDR     r11, =ZeroPage+KeyWorkSpace
d222 1
a222 1
        LDR     r11, =ZeroPage+KeyWorkSpace
d315 1
a315 1
        LDR     r11, =ZeroPage+KeyWorkSpace
d619 1
a619 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d912 1
a912 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d933 1
a933 1
        LDR     r1, =ZeroPage
d949 1
a949 2
        LDR     r0, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
a969 1
        ASSERT (ZeroPage :AND: 255) = 0
a970 3
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
d975 1
a975 1
        LDR     R5, =ZeroPage
d983 1
a983 1
        LDR     R0, =ZeroPage
d996 1
a996 1
        LDR     R0, =ZeroPage
d1021 1
a1021 2
        LDRVS   R5, =ZeroPage           ; if got error, then indicate we don't want to try again
        ASSERT  (ZeroPage :AND: 255) = 0
d1031 1
a1031 2
        LDRVS   R5, =ZeroPage+1         ; if got error, then indicate we don't want to try again
        ASSERT  (ZeroPage :AND: 255) = 0
a1059 1
        ASSERT (ZeroPage :AND: 255) = 0
a1060 3
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
a1120 3
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
      ]
a1154 1
      [ ZeroPage = 0
a1155 4
      |
        LDR     R2, =ZeroPage+OsbyteVars+IPbufferCh-OSBYTEFirstVar
        LDRB    R2, [R0, R2]
      ]
a1208 3
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
d1216 1
a1216 1
        ADDCS   R13, R13, #4            ; pull stacked R14 if CS
d1295 1
a1295 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d1330 1
a1330 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d1421 1
a1421 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d1469 1
a1469 1
        LDR     R11, =ZeroPage+KeyWorkSpace
a1500 1
        LTORG
@


4.6.2.8
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@a720 1
        LDR     a2, =L1PT
@


4.6.2.9
log
@Add support for new extended internal key codes, low level key codes, and key handler format
Detail:
  s/Middle - Added OS_ReadSysInfo 13 to allow the kernel to validate a key handler before the owner attempts to install it
  Resources/UK/Messages - Text for new "Bad key handler" error
  s/GetAll, s/PMF/Def - Get rid of now obsolete s/PMF/Def file. It only contained definitions for pre-HAL hardware, and for the key handler layout (now in Hdr:Keyboard)
  hdr/KeyWS - Increased size of KeysDown array so it can hold 768 keys instead of 160. Trim a couple of obsolete variables, and increase CurrKey/OldKey from 1 byte to 4 bytes.
  s/PMF/key, s/PMF/osbyte - Main bulk of the changes for the new key handling. All the important interfaces are now able to deal with extended (i.e. > 8 bit) internal key numbers, and the kernel is able to cope with key handlers which use 16 bit internal/low level key numbers instead of 8 bit.
Admin:
  Tested on Pandora & BB-xM
  Requires HdrSrc-2_20


Version 5.35, 4.79.2.178. Tagged as 'Kernel-5_35-4_79_2_178'
@
text
@d117 1
a117 1
        Entry   "R1-R2"
d120 2
a121 2
        STR     R0, CurrKey             ; no current key
        STR     R0, OldKey
d127 5
a131 6
        MOV     R1, #?KeysDown
        ADR     R2, KeysDown
10
        SUBS    R1, R1, #4
        STR     R0, [R2], #4
        BNE     %BT10
d133 1
a133 1
        EXIT
d140 1
d168 1
d282 1
a282 1
        LDR     r8, [r0, #KeyHandler_Init] ; Initialise key handler.
d328 1
a328 1
        CMP     R2, #?KeysDown*8
d359 1
a359 1
        LDR     R0, CurrKey
d363 1
a363 1
        LDR     R1, OldKey
d367 1
a367 1
        STR     R0, OldKey              ; make current key old
d369 1
a369 1
        STR     R2, CurrKey             ; update current
d384 1
a384 1
        LDR     R0, OldKey
d390 1
a390 1
        LDR     R0, CurrKey             ; current key is one to ignore in scan
d393 1
a393 1
        STRPL   R0, OldKey              ; found key, so current -> old
d397 1
a397 1
        STR     R0, OldKey
d401 1
a401 1
        LDR     R1, CurrKey
d408 1
a408 2
        MOV     R2, #&FF
        STR     R2, CurrKey             ; mark current key up
d444 1
a444 1
        MOV     R2, #(?KeysDown/4)-1
a445 2
        TEQ     R2, #&200/32
        MOVEQ   R2, #4                  ; skip extension key range &100
d494 1
a494 7
        LDR     R3, [R0, #KeyHandler_KeyTranSize] ; maximum internal key number +1
        TST     R3, #KeyHandler_HasFlags
        BIC     R3, R3, #KeyHandler_HasFlags
        LDRNE   R5, [R0, #KeyHandler_Flags]
        TSTNE   R5, #KeyHandler_Flag_Wide
        BNE     %FT20                   ; Use wide version of routine

d496 1
a496 1
        LDRCC   R3, [R0, #KeyHandler_KeyTran] ; no, R3 := offset to keytran
d502 1
a502 1
        LDR     R3, [R0, #KeyHandler_ShiftingList] ; R3 = offset to shifting key list
a513 39
20
        CMP     R2, R3                  ; is it outside table ?
        LDRCC   R3, [R0, #KeyHandler_KeyTran] ; no, R3 := offset to keytran
        ADDCC   R3, R3, R0              ; R3 -> keytran
        LDRCC   R4, =&FF00FF00
        ADDCC   R3, R3, R2, LSL #3      ; R3 = table address for this key
        LDMCCIA R3, {R3, R5}            ; R3, R5 = table entry for this key
        EORCC   R3, R3, R4
        EORCC   R5, R5, R4
        ANDCC   R3, R3, R5
        CMNCC   R3, #1                  ; C=1 <=> outside table or is special
        MOVCC   PC, R14                 ; can't be shifting key

        LDR     R3, [R0, #KeyHandler_ShiftingList] ; R3 = offset to shifting key list
      [ NoARMv4
        LDRB    R4, [R3, R0]!
        LDRB    R5, [R3, #1]
        ORRS    R4, R4, R5, LSL #8      ; R4 = length of shifting key list
      |
        LDRH    R4, [R3, R0]!
        TEQ     R4, #0                  ; R4 = length of shifting key list
      ]
30
      [ NoARMv4
        ASSERT  :LNOT: NoUnaligned
        LDRNE   R5, [R3, R4, LSL #1]
        MOVNE   R5, R5, LSL #16
        TEQNE   R5, R2, LSL #16
      |
        ADDNE   R5, R3, R4, LSL #1
        LDRNEH  R5, [R5]
        TEQNE   R5, R2
      ]
        SUBNES  R4, R4, #1
        BNE     %BT30

        CMP     R4, #1                  ; C=1 <=> shifting key
        MOV     PC, R14                 ; not one of the shifting keys

a523 1
        LDR     R3, [R0, #KeyHandler_KeyTranSize]
d525 1
a525 5
        TST     R3, #KeyHandler_HasFlags
        LDRNE   R3, [R0, #KeyHandler_Flags]
        TSTNE   R3, #KeyHandler_Flag_Wide
        LDR     R3, [R0, #KeyHandler_SpecialList] ; R3 = offset to special list
        BNE     CallSpecialCodeWide
a536 18
CallSpecialCodeWide
      [ NoARMv4
        LDRB    R4, [R3, R0]!
        LDRB    R5, [R3], #1
        ORR     R4, R4, R5, LSL #8      ; R4 = length of special list
      |
        LDRH    R4, [R3, R0]!           ; R4 = length of special list
      ]
        TEQ     R4, #0
        MOVEQ   PC, R14                 ; no special keys, so can't be one
15
        LDHA    R5, R3, R4, R8
        TEQ     R5, R2
        BEQ     %FT20
        SUBS    R4, R4, #1
        BNE     %BT15
        MOV     PC, R14

d538 1
a538 1
        LDR     R3, [R0, #KeyHandler_SpecialCodeTable] ; R3 = offset to special table
d560 1
d632 1
a632 1
        LDR     R2, CurrKey
d750 1
a750 2
        LDR     R5, [R0, #KeyHandler_KeyTranSize] ; get size
        BIC     R3, R5, #KeyHandler_HasFlags
d754 1
a754 1
        LDR     R3, [R0, #KeyHandler_KeyTran]   ; R3 = offset to KeyTran
a756 7
        TST     R5, #KeyHandler_HasFlags
        LDRNE   R6, [R0, #KeyHandler_Flags]
        TSTNE   R6, #KeyHandler_Flag_Wide
        MOVEQ   R6, #1
        MOVNE   R6, #2
        ADDNE   R3, R3, R2, LSL #2

d762 1
a762 1
        ADDNE   R3, R3, R6, LSL #1
d765 1
a765 1
        ADDNE   R3, R3, R6
d767 1
a767 12
        TEQ     R6, #1
      [ NoARMv4
        ASSERT  :LNOT: NoUnaligned
        LDR     R3, [R3, R2, LSL #2]            ; get real code
        MOVNE   R3, R3, LSL #16
        ANDEQ   R3, R3, #255
        MOVNE   R3, R3, LSR #16
      |
        ADD     R3, R3, R2, LSL #2
        LDREQB  R3, [R3]
        LDRNEH  R3, [R3]
      ]
d896 1
a896 1
        LDR     R8, [R0, #KeyHandler_PendingAltCode]
a1334 1
        EOR     R2, R2, #&7F
d1342 1
a1342 1
; in:   R1 = 0..&7F => scan keyboard from BBC internal key R1+(R2<<8)
d1346 1
a1346 1
; in:   R1 = &80..&FF => test if BBC internal key ((R1+(R2<<8)) EOR &80) is down
d1352 1
a1352 1
        Push    "R10, R11, LR"
a1355 2
        AND     R10, R2, #&7F

d1365 1
a1365 5
        BCC     ExitBBCTest

        TEQ     R1, #&80+13             ; extension range?
        TEQNE   R1, #&80+15             
        BEQ     DoBBCTestExtension
d1367 1
a1367 1
        LDR     R0, [R2, #KeyHandler_InkeyTran]
a1371 8

        LDR     R10, [R2, #KeyHandler_KeyTranSize]
        TST     R10, #KeyHandler_HasFlags
        LDRNE   R10, [R2, #KeyHandler_Flags]
        TSTNE   R10, #KeyHandler_Flag_Wide
        MOVNE   R2, #&FF0000
        BNE     DoBBCTestWide

a1386 1

d1392 3
a1394 2
ExitBBCTest
        Pull    "R10, R11, PC"
d1396 1
a1396 29
DoBBCTestWide
        MOV     R1, R0, LSL #16         ; get bottom entry
        CMP     R1, #&FF0000            ; is it FF?
        MOVEQ   R1, #0                  ; if so then none of keys down
        BEQ     %BT04

        ADR     R3, KeysDown            ; look up in KeysDown
        MOV     R1, R1, LSR #5+16
        LDR     R3, [R3, R1, LSL #2]    ; get word of 32 bits
        AND     R1, R0, #31
        MOV     R3, R3, LSL R1          ; put relevant bit into top bit
        MOVS    R1, R3, LSR #31         ; R1 = 0 if up, 1 if down
        ORREQ   R0, R2, R0, LSR #16     ; shift down, putting FF in top entry
        BEQ     DoBBCTestWide
        B       %BT04

DoBBCTestExtension
        TST     R1, #2
        ADDEQ   R10, R10, #&100 ; EQ -> (R1 AND &7F) = 13
        ADDNE   R10, R10, #&200 ; NE -> (R1 AND &7F) = 15
        ADR     R3, KeysDown
        MOV     R1, R10, LSR #5
        LDR     R3, [R3, R1, LSL #2]
        AND     R1, R10, #31
        MOV     R3, R3, LSL R1
        MOV     R1, R3, LSR #31
        B       %BT04

DoBBCScan       ROUT
d1399 2
a1400 9
        BEQ     ExitBBCTest
        Push    "R4, R5"

        ; Check for extension key range and include R10 if necessary
        TEQ     R1, #13
        TEQNE   R1, #15
        ORREQ   R1, R1, R10, LSL #8

        LDR     R0, [R2, #KeyHandler_InkeyTran]
d1403 1
a1404 8

        LDR     R4, [R2, #KeyHandler_KeyTranSize]
        TST     R4, #KeyHandler_HasFlags
        LDRNE   R4, [R2, #KeyHandler_Flags]
        TSTNE   R4, #KeyHandler_Flag_Wide
        MOVNE   R4, #&FF0000
        BNE     DoBBCScanWide

a1406 3
        AND     R3, R1, #&7F-2
        TEQ     R3, #13                 ; 13 or 15?
        BLEQ    DoBBCScanExtension      ; handle extension range scan
d1419 1
a1419 1
        BNE     ExitBBCScan             ; [down, so stop]
a1426 56
ExitBBCScan
        MOV     R2, #0
        TEQ     R1, #&FF
        MOVEQ   R2, #C_bit
        MSR     CPSR_f, R2              ; C=0 <=> found key
        Pull    "R4,R5,R10,R11,PC"

DoBBCScanWide   ROUT
        AND     R3, R1, #&7F-2
        TEQ     R3, #13                 ; 13 or 15?
        BLEQ    DoBBCScanExtension      ; handle extension range scan
        LDR     R3, [R0, -R1, LSL #2]   ; get word of indexes into KeysDown
15
        MOV     R5, R3, LSL #16         ; get bottom entry
        CMP     R5, #&FF0000            ; is it FF?
        BEQ     %FT18                   ; then not one of these keys

        ADR     R2, KeysDown
        MOV     R5, R5, LSR #5+16
        LDR     R2, [R2, R5, LSL #2]    ; get word of bits
        AND     R5, R3, #31
        MOV     R2, R2, LSL R5          ; put relevant bit into top bit
        MOVS    R5, R2, LSR #31         ; R5 = 0 for up, 1 for down
        BNE     ExitBBCScan             ; [down, so stop]
        ORR     R3, R4, R3, LSR #16     ; up -> shift down putting FF in top
        B       %BT15
18
        ADD     R1, R1, #1              ; go to next key
        TEQ     R1, #&80                ; if not run out of keys
        BNE     DoBBCScanWide           ; then loop
        MOV     R1, #&FF                ; indicate no key
        B       ExitBBCScan

DoBBCScanExtension ROUT
        ; R2, R3, R5, R10 corruptible
        ; Return to LR if no key found
        MOV     R10, R1, LSR #8
        TST     R1, #2
        ADDEQ   R10, R10, #&100 ; EQ -> (R1 AND &7F) = 13
        ADDNE   R10, R10, #&200 ; NE -> (R1 AND &7F) = 15
        ADR     R2, KeysDown
10
        MOV     R3, R10, LSR #5
        LDR     R3, [R2, R3, LSL #2]
        AND     R5, R10, #31
        MOVS    R3, R3, LSL R5
        BNE     %FT20                   ; found one

        BIC     R10, R10, #31           ; skip to next word
        ADD     R10, R10, #32
        TEQ     R10, #&300
        BNE     %BT10
        ; Ran out of extension keys
        MOV     R1, #16
        MOV     PC, LR

d1428 3
a1430 27
      [ NoARMv5
        CMP     R3, #1<<16
        ADDLO   R10, R10, #16
        MOVLO   R3, R3, LSL #16
        CMP     R3, #1<<24
        ADDLO   R10, R10, #8
        MOVLO   R3, R3, LSL #8
        CMP     R3, #1<<28
        ADDLO   R10, R10, #4
        MOVLO   R3, R3, LSL #4
        CMP     R3, #1<<30
        ADDLO   R10, R10, #2
        MOVLO   R3, R3, LSL #2
        TST     R3, #1<<31
        ADDEQ   R10, R10, #1
      |
        CLZ     R3, R3
        ADD     R10, R10, R3
      ]
        ; Convert back to inkey key
        TST     R10, #&100
        MOVNE   R1, #13
        MOVEQ   R1, #15
        ORR     R1, R1, R10, LSL #8
        BIC     R1, R1, #&FF0000
        B       ExitBBCScan
        
a1439 3
;       R3 corrupt
;
; Note: Doesn't deal with extended key numbers
d1445 1
a1445 1
        AND     R0, R1, #&FF            ; mask off any extension bits
d1447 2
a1448 2
        STR     R0, CurrKey
        AND     R0, R2, #&FF
d1450 1
a1450 1
        STR     R0, OldKey
d1453 1
a1453 4
; in:   R0 = INKEY code EOR &FF
; out:  R0 = internal low level key number
;       R3 corrupt
ConvertInternalKey ROUT
d1459 1
a1459 1
        
d1464 3
a1466 9

        Push    R4
        LDR     R4, [R3, #KeyHandler_KeyTranSize]
        TST     R4, #KeyHandler_HasFlags
        LDRNE   R4, [R3, #KeyHandler_Flags]
        TSTNE   R4, #KeyHandler_Flag_Wide

        LDR     R4, [R3, #KeyHandler_InkeyTran]
        ADD     R3, R3, R0, LSL #2
d1470 1
a1470 2
      [ NoARMv4
        LDRB    R0, [R3, R4]!           ; convert to ARM internal key
a1471 7
        LDRNEB  R4, [R3, #1]
        ORRNE   R0, R0, R4, LSL #8
      |
        LDREQB  R0, [R3, R4]
        LDRNEH  R0, [R3, R4]
      ]
        Pull    R4
@


4.6.2.10
log
@Replace 1 line macro
IssueService -> BL Issue_Service.
@
text
@d776 1
a776 1
        BL      Issue_Service
d1769 1
a1769 1
        BL      Issue_Service
@


4.6.2.11
log
@Strip out some old build switches
Detail:
  hdr/Options, s/ArthurSWIs, s/ChangeDyn, s/PMF/KbdDrA1, s/PMF/key, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdugrafhal, s/vdu/vdugrafv, s/vdu/vdumodes, s/vdu/vduwrch:
  - Strip out DoingVdu build switch (did nothing)
  - Strip out Japanese16BitSound switch (did nothing)
  - Strip out MakeModeSelectorsForModeNUmbers switch (altered the mode list structures, but there wasn't any code to do anything with the new data)
  - Strip out remaining uses of UseGraphicsV switch (now hardwired to {TRUE})
  - Strip out ShadowROM switch (altered FixedAreasTable to show the shadow mapping, but code to create the mapping is missing)
  - Strip out PollMouse switch (old Archimedes-era debug/development option)
Admin:
  Tested on BB-xM
  Builds to same binary as previous version


Version 5.35, 4.79.2.204. Tagged as 'Kernel-5_35-4_79_2_204'
@
text
@d691 6
@


4.6.2.8.2.1
log
@  Merge of Raspberry Pi support code against latest kernel
Detail:
  This is a new branch from the current tip of the HAL branch, incorporating
  the changes received from Adrian Lees. The same caveats apply - this is a
  work in progress and will not work on any other platform at present.
Admin:
  Builds, but not tested.

Version 5.35, 4.79.2.147.2.1. Tagged as 'Kernel-5_35-4_79_2_147_2_1'
@
text
@a1093 17

  [ {FALSE}
  STMFD sp!,{R1-R12,R14}
  MOV a1, #0
  AddressHAL a1
  SUB sp,sp,#4
  MOV a2,sp
  CallHAL HAL_UARTReceiveByte
  LDR a2,[sp],#4
  TST a2,#1
  BNE %FT00
  SEC
  LDMFD sp!,{R1-R12,PC}
00
  CLC
  LDMFD sp!,{R1-R12,PC}
  ]
@


4.6.2.8.2.2
log
@Clean up remaining kernel hacks
Detail:
  Docs/RPiNotes - Deleted, contents no longer relevant
  s/HAL, s/Kernel, s/vdu/vduswis, s/pmf/key - Cleaned up debug code
  s/NewIRQs - No need to piggy back on timer 0 IRQ to generate a fake VSync; PushModeInfo already claims/releases TickerV as appropriate if video driver doesn't provide a VSync IRQ.
  s/NewReset - Re-enable LookForHALRTC call, the stack imbalance bug was fixed before the Pi changes were merged in
  s/vdu/vducursoft - Streamline PostWrchCursor a bit by only preserving R14 around RestorePointer if the software pointer is in use
  s/vdu/vdudriver - Amend ModeChangeSub improvements to ensure old external framestore handling logic is used if driver doesn't support framestore growth/realloc
Admin:
  Tested on Raspberry Pi with high processor vectors
  Kernel now looks to be in a good state for merging back into HAL branch
  Note - Software mouse pointer support in vducursoft only checks HALVideoFeatures, so doesn't take into account the capabilities of any GraphicsV driver that may be in use.


Version 5.35, 4.79.2.147.2.20. Tagged as 'Kernel-5_35-4_79_2_147_2_20'
@
text
@d1094 17
@


4.6.2.6.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d64 1
a64 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d95 1
a95 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d210 1
a210 1
        LDR     r11, =ZeroPage+KeyWorkSpace
d222 1
a222 1
        LDR     r11, =ZeroPage+KeyWorkSpace
d315 1
a315 1
        LDR     r11, =ZeroPage+KeyWorkSpace
d619 1
a619 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d912 1
a912 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d933 1
a933 1
        LDR     r1, =ZeroPage
d949 1
a949 2
        LDR     r0, =ZeroPage
        ASSERT  (ZeroPage :AND: 255) = 0
a969 1
        ASSERT (ZeroPage :AND: 255) = 0
a970 3
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
d975 1
a975 1
        LDR     R5, =ZeroPage
d983 1
a983 1
        LDR     R0, =ZeroPage
d996 1
a996 1
        LDR     R0, =ZeroPage
d1021 1
a1021 2
        LDRVS   R5, =ZeroPage           ; if got error, then indicate we don't want to try again
        ASSERT  (ZeroPage :AND: 255) = 0
d1031 1
a1031 2
        LDRVS   R5, =ZeroPage+1         ; if got error, then indicate we don't want to try again
        ASSERT  (ZeroPage :AND: 255) = 0
a1059 1
        ASSERT (ZeroPage :AND: 255) = 0
a1060 3
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
a1120 3
      [ ZeroPage <> 0
        LDR     R0, =ZeroPage
      ]
a1154 1
      [ ZeroPage = 0
a1155 4
      |
        LDR     R2, =ZeroPage+OsbyteVars+IPbufferCh-OSBYTEFirstVar
        LDRB    R2, [R0, R2]
      ]
a1208 3
      [ ZeroPage <> 0
        MOV     R0, #0
      ]
d1295 1
a1295 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d1330 1
a1330 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d1421 1
a1421 1
        LDR     R11, =ZeroPage+KeyWorkSpace
d1469 1
a1469 1
        LDR     R11, =ZeroPage+KeyWorkSpace
a1500 1
        LTORG
@


4.6.2.6.2.1.2.1
log
@  Support for Raspberry Pi / BCM2835
Detail:
  Falls into two main areas: graphics support and ARM11 core support.
  A work in progress - in many cases the code changes need to be replaced
  with an alternative mechanism which will permit the kernel to still function
  on other platforms. Adrian marked these with "!!!" comments - I have added
  ! directives as well so that they don't get forgotten about.
Admin:
  Changes received from Adrian Lees. This revision represents the code largely
  as delivered, and is placed on its own branch (forked off from the version
  from which he worked). It is intended for reference. It doesn't build against
  current headers - this is likely to require a merge with the other changes
  to the kernel since that time.

Version 5.35, 4.79.2.98.2.52.2.1. Tagged as 'Kernel-5_35-4_79_2_98_2_52_2_1'
@
text
@a1092 17

  [ {FALSE}
  STMFD sp!,{R1-R12,R14}
  MOV a1, #0
  AddressHAL a1
  SUB sp,sp,#4
  MOV a2,sp
  CallHAL HAL_UARTReceiveByte
  LDR a2,[sp],#4
  TST a2,#1
  BNE %FT00
  SEC
  LDMFD sp!,{R1-R12,PC}
00
  CLC
  LDMFD sp!,{R1-R12,PC}
  ]
@


4.6.2.6.2.2
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d1238 1
a1238 1
        ADDCS   R13, R13, #4            ; pull stacked R14 if CS
@


4.5
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a1141 11

; new code inserted here 14/8/87 to try to reenable RTS for RS423 input

 [ DriversInKernel
        TEQ     R1, #1                  ; RS423 input ?
        Pull    PC, NE                  ; no, then exit
        Push    "R0,R1,R12"             ; preserve char + buffer id + R12
        BYTEWS  R12
        BL      RSETX                   ; reenable RTS if now enough spaces
        Pull    "R0,R1,R12, PC"         ; restore char, buffer id and exit
 |
a1142 1
 ]
@


4.4
log
@Fixed error in RDCH speed restoring logic.
When screen is blanked, DACs are turned off (60mA saving).
If DPMS state 3 comes on, sync lines are set low.

Version 4.96. Tagged as 'Kernel-4_96'
@
text
@a55 5
        [ :LNOT: AssemblingArthur
        GBLL    redirectinkey
redirectinkey   SETL    {FALSE}
        ]

d65 1
a65 6
        [ AssemblingArthur
        TEQP PC,#I_bit :OR: SVC_mode
        |
        SWI     OS_IntOff
        SWI     OS_EnterOS
        ]
a70 10
        [ :LNOT: AssemblingArthur
        MOV     R0, #RdchV
        ADRL    R1, NewRdch
        SWI     OS_Claim
        ]

 [ AssembleA1KeyHandler
        ADRL    R0, NewKeyStruct        ; point to new structure for now
        STR     R0, KeyVec
 |
a72 1
 ]
a83 5
        [ :LNOT: AssemblingArthur
        TEQP    PC, #I_bit
        MOV     R0, R0
        ]

d166 3
a168 2
        MOV     r11, pc                 ; Save current PSR.
        TEQP    pc, #SVC_mode + I_bit   ; Call KEYV in SVC mode, no IRQs.
d173 1
a173 1
        TEQP    r11, #0                 ; Go back to old mode.
d192 1
a192 1
        Push    lr
d208 1
a208 1
        Pull    pc,,^
a429 1
 [ :LNOT: AssembleA1KeyHandler
a431 1
 ]
d517 3
a519 3
        MOV     R11, PC
        TEQP    PC, #SVC_mode + I_bit
        NOP
d534 1
a534 1
        TEQP    R11, #0
d536 1
a536 1
        EXITS
d540 3
a542 2
        MOV     R11, PC
        TEQP    PC, #SVC_mode + I_bit
d639 1
a639 1
        TEQP    PC, #ARM_CC_Mask                ; set FI bits, SVC mode
d652 2
a653 2
        TEQP    PC, #ARM_CC_Mask                ; set FI bits, SVC mode
                                                ; just in case!
a674 1
 [ :LNOT: AssembleA1KeyHandler
a676 1
 ]
d852 1
a852 1
RdchInkey ENTRY
d856 1
a856 1
        TEQP    pc, #SVC_mode
a857 1
 [ redirectinkey
a879 1
 ]
d977 1
a977 1
RestoreSpeed ENTRY "R0"
d989 2
a990 1
        ORRS    PC, R14, #V_bit         ; still indicate error
a991 1
 [ redirectinkey
d994 2
a995 3
        Pull    "R14"                   ; pull register
        ORRS    PC, R14, #V_bit         ; still indicate error
 ]
a1275 1
 [ :LNOT: AssembleA1KeyHandler
a1279 1
 ]
a1310 1
 [ :LNOT: AssembleA1KeyHandler
a1313 1
 ]
a1374 1
 [ :LNOT: AssembleA1KeyHandler
a1377 1
 ]
d1402 3
a1404 3
        MOV     R11, PC
        TST     R11, #I_bit
        TEQEQP  R11, #I_bit             ; disable IRQs
d1428 1
a1428 1
; out:  R0,PSR preserved
d1436 1
a1436 1
        Pull    "R0,PC",,^
@


4.3
log
@Kernel was accidentally storing PortableFlags in the wrong place.
Now calls XPortable_Idle, not Portable_Idle in key-wait code.
Calls Portable_Idle in OS_Byte 19.

Version 4.94. Tagged as 'Kernel-4_94'
@
text
@d995 4
d1001 1
@


4.2
log
@OS_Byte 129 0 255 now reports &A7 for STB build (because it _is_ a
RISC OS 3.7 generation kernel).
CMOS no longer gets scrambled when reset in STB build.
UpCall_KeyboardStatus now issued when OS_Byte 202 called or when keyboard
status byte is changed by other means (such as pressing Caps Lock).

Version 4.67. Tagged as 'Kernel-4_67'
@
text
@d966 1
a966 1
        SWINE   Portable_Idle
@


4.1
log
@Initial revision
@
text
@d107 1
a107 1
        MOVNV   R0, R0
d517 1
d519 1
d521 2
d540 34
d746 7
a752 2
        BICEQ   R5, R5, #KBStat_PendingAlt      ; then cancel pending alt
        STROSB  R5, KeyBdStatus, R6, EQ         ; and store back
d754 1
a754 1
        TST     R5, #KBStat_PendingAlt          ; is there a pending Alt ?
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d56 4
d70 1
d72 4
d81 5
d105 4
d617 1
d643 3
d732 1
d736 4
d907 1
d912 1
d1089 1
d1092 3
d1100 5
d1128 8
d1137 1
@


4.1.4.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d68 5
d87 5
d184 3
d188 1
d244 3
@


4.1.4.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d68 5
d87 5
d184 3
d188 1
d244 3
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

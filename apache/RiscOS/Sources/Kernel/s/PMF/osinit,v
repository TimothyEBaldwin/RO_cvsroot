head	4.26;
access;
symbols
	Kernel-6_15:4.26
	Kernel-6_14:4.26
	Kernel-6_01-3:4.25
	Kernel-6_13:4.26
	Kernel-6_12:4.26
	Kernel-6_11:4.26
	Kernel-6_10:4.26
	Kernel-6_09:4.26
	Kernel-6_08-4_129_2_10:4.22.2.4
	Kernel-6_08-4_129_2_9:4.22.2.4
	Kernel-6_08:4.26
	Kernel-6_07:4.26
	Kernel-6_06:4.25
	Kernel-6_05-4_129_2_8:4.22.2.3
	Kernel-6_05:4.25
	Kernel-6_04:4.25
	Kernel-6_03:4.25
	Kernel-6_01-2:4.25
	Kernel-6_01-4_146_2_1:4.25
	Kernel-6_02:4.25
	Kernel-6_01-1:4.25
	Kernel-6_01:4.25
	Kernel-6_00:4.25
	Kernel-5_99:4.25
	Kernel-5_98:4.24
	Kernel-5_97-4_129_2_7:4.22.2.2
	Kernel-5_97:4.24
	Kernel-5_96:4.24
	Kernel-5_95:4.24
	Kernel-5_94:4.23
	Kernel-5_93:4.23
	Kernel-5_92:4.23
	Kernel-5_91:4.23
	Kernel-5_90:4.23
	Kernel-5_89-4_129_2_6:4.22.2.1
	Kernel-5_89:4.23
	Kernel-5_88-4_129_2_5:4.22
	Kernel-5_88-4_129_2_4:4.22
	Kernel-5_88:4.22
	Kernel-5_87:4.22
	Kernel-5_86-4_129_2_3:4.22
	Kernel-5_86-4_129_2_2:4.22
	Kernel-5_86-4_129_2_1:4.22
	Kernel-5_86:4.22
	SMP:4.22.0.2
	SMP_bp:4.22
	Kernel-5_85:4.22
	Kernel-5_54-1:4.21
	Kernel-5_84:4.22
	Kernel-5_83:4.22
	Kernel-5_82:4.22
	Kernel-5_81:4.22
	Kernel-5_80:4.22
	Kernel-5_79:4.22
	Kernel-5_78:4.22
	Kernel-5_77:4.22
	Kernel-5_76:4.22
	Kernel-5_75:4.22
	Kernel-5_74:4.22
	Kernel-5_73:4.22
	Kernel-5_72:4.22
	Kernel-5_71:4.22
	Kernel-5_70:4.22
	Kernel-5_69:4.22
	Kernel-5_68:4.22
	Kernel-5_67:4.22
	Kernel-5_66:4.22
	Kernel-5_65:4.22
	Kernel-5_64:4.22
	Kernel-5_63:4.22
	Kernel-5_62:4.22
	Kernel-5_61:4.22
	Kernel-5_60:4.22
	Kernel-5_59:4.22
	Kernel-5_58:4.22
	Kernel-5_57:4.22
	Kernel-5_56:4.22
	Kernel-5_55:4.22
	Kernel-5_54:4.21
	Kernel-5_53:4.21
	Kernel-5_52:4.21
	Kernel-5_51:4.21
	Kernel-5_50:4.20
	Kernel-5_49:4.19
	HAL_merge:4.17.2.29
	Kernel-5_48:4.18
	Kernel-5_35-4_79_2_327:4.17.2.29
	Kernel-5_35-4_79_2_326:4.17.2.29
	Kernel-5_35-4_79_2_325:4.17.2.29
	Kernel-5_35-4_79_2_324:4.17.2.29
	Kernel-5_35-4_79_2_323:4.17.2.29
	Kernel-5_35-4_79_2_322:4.17.2.29
	Kernel-5_35-4_79_2_321:4.17.2.29
	Kernel-5_35-4_79_2_320:4.17.2.29
	Kernel-5_35-4_79_2_319:4.17.2.29
	Kernel-5_35-4_79_2_318:4.17.2.29
	Kernel-5_35-4_79_2_317:4.17.2.29
	Kernel-5_35-4_79_2_316:4.17.2.29
	Kernel-5_35-4_79_2_315:4.17.2.29
	Kernel-5_35-4_79_2_314:4.17.2.29
	Kernel-5_35-4_79_2_313:4.17.2.29
	Kernel-5_35-4_79_2_312:4.17.2.29
	Kernel-5_35-4_79_2_311:4.17.2.29
	Kernel-5_35-4_79_2_310:4.17.2.29
	Kernel-5_35-4_79_2_309:4.17.2.29
	Kernel-5_35-4_79_2_308:4.17.2.29
	Kernel-5_35-4_79_2_307:4.17.2.29
	Kernel-5_35-4_79_2_306:4.17.2.29
	Kernel-5_35-4_79_2_305:4.17.2.29
	Kernel-5_35-4_79_2_304:4.17.2.29
	Kernel-5_35-4_79_2_303:4.17.2.29
	Kernel-5_35-4_79_2_302:4.17.2.29
	Kernel-5_35-4_79_2_301:4.17.2.29
	Kernel-5_35-4_79_2_300:4.17.2.29
	Kernel-5_35-4_79_2_299:4.17.2.29
	Kernel-5_35-4_79_2_298:4.17.2.29
	Kernel-5_35-4_79_2_297:4.17.2.29
	Kernel-5_35-4_79_2_296:4.17.2.29
	Kernel-5_35-4_79_2_295:4.17.2.29
	Kernel-5_35-4_79_2_294:4.17.2.29
	Kernel-5_35-4_79_2_293:4.17.2.29
	Kernel-5_35-4_79_2_292:4.17.2.29
	Kernel-5_35-4_79_2_291:4.17.2.29
	Kernel-5_35-4_79_2_290:4.17.2.29
	Kernel-5_35-4_79_2_289:4.17.2.29
	Kernel-5_35-4_79_2_288:4.17.2.29
	Kernel-5_35-4_79_2_287:4.17.2.29
	Kernel-5_35-4_79_2_286:4.17.2.29
	Kernel-5_35-4_79_2_285:4.17.2.29
	Kernel-5_35-4_79_2_284:4.17.2.29
	Kernel-5_35-4_79_2_283:4.17.2.29
	Kernel-5_35-4_79_2_282:4.17.2.29
	Kernel-5_35-4_79_2_281:4.17.2.29
	Kernel-5_35-4_79_2_280:4.17.2.29
	Kernel-5_35-4_79_2_279:4.17.2.29
	Kernel-5_35-4_79_2_278:4.17.2.29
	Kernel-5_35-4_79_2_277:4.17.2.29
	Kernel-5_35-4_79_2_276:4.17.2.29
	Kernel-5_35-4_79_2_275:4.17.2.29
	Kernel-5_35-4_79_2_274:4.17.2.29
	Kernel-5_35-4_79_2_273:4.17.2.29
	Kernel-5_35-4_79_2_272:4.17.2.28
	Kernel-5_35-4_79_2_271:4.17.2.28
	Kernel-5_35-4_79_2_270:4.17.2.28
	Kernel-5_35-4_79_2_269:4.17.2.28
	Kernel-5_35-4_79_2_268:4.17.2.28
	Kernel-5_35-4_79_2_267:4.17.2.28
	Kernel-5_35-4_79_2_266:4.17.2.28
	Kernel-5_35-4_79_2_265:4.17.2.28
	Kernel-5_35-4_79_2_264:4.17.2.28
	Kernel-5_35-4_79_2_263:4.17.2.28
	Kernel-5_35-4_79_2_262:4.17.2.28
	Kernel-5_35-4_79_2_261:4.17.2.28
	Kernel-5_35-4_79_2_260:4.17.2.28
	Kernel-5_35-4_79_2_259:4.17.2.28
	Kernel-5_35-4_79_2_258:4.17.2.28
	Kernel-5_35-4_79_2_257:4.17.2.28
	Kernel-5_35-4_79_2_256:4.17.2.28
	Kernel-5_35-4_79_2_255:4.17.2.28
	Kernel-5_35-4_79_2_254:4.17.2.28
	Kernel-5_35-4_79_2_253:4.17.2.28
	Kernel-5_35-4_79_2_252:4.17.2.28
	Kernel-5_35-4_79_2_251:4.17.2.28
	Kernel-5_35-4_79_2_250:4.17.2.28
	Kernel-5_35-4_79_2_249:4.17.2.28
	Kernel-5_35-4_79_2_248:4.17.2.28
	Kernel-5_35-4_79_2_247:4.17.2.28
	Kernel-5_35-4_79_2_246:4.17.2.27
	Kernel-5_35-4_79_2_245:4.17.2.27
	Kernel-5_35-4_79_2_244:4.17.2.27
	Kernel-5_35-4_79_2_243:4.17.2.27
	Kernel-5_35-4_79_2_242:4.17.2.27
	Kernel-5_35-4_79_2_241:4.17.2.27
	Kernel-5_35-4_79_2_240:4.17.2.27
	Kernel-5_35-4_79_2_239:4.17.2.27
	Kernel-5_35-4_79_2_238:4.17.2.27
	Kernel-5_35-4_79_2_237:4.17.2.27
	Kernel-5_35-4_79_2_236:4.17.2.27
	Kernel-5_35-4_79_2_235:4.17.2.27
	Kernel-5_35-4_79_2_234:4.17.2.27
	Kernel-5_35-4_79_2_233:4.17.2.27
	Kernel-5_35-4_79_2_232:4.17.2.27
	Kernel-5_35-4_79_2_231:4.17.2.27
	Kernel-5_35-4_79_2_230:4.17.2.27
	Kernel-5_35-4_79_2_229:4.17.2.27
	Kernel-5_35-4_79_2_228:4.17.2.27
	Kernel-5_35-4_79_2_227:4.17.2.27
	Kernel-5_35-4_79_2_226:4.17.2.27
	Kernel-5_35-4_79_2_225:4.17.2.26
	Kernel-5_35-4_79_2_224:4.17.2.26
	Kernel-5_35-4_79_2_223:4.17.2.26
	Kernel-5_35-4_79_2_222:4.17.2.26
	Kernel-5_35-4_79_2_221:4.17.2.26
	Kernel-5_35-4_79_2_220:4.17.2.26
	Kernel-5_35-4_79_2_219:4.17.2.25
	Kernel-5_35-4_79_2_218:4.17.2.25
	Kernel-5_35-4_79_2_217:4.17.2.25
	Kernel-5_35-4_79_2_216:4.17.2.25
	Kernel-5_35-4_79_2_215:4.17.2.25
	Kernel-5_35-4_79_2_214:4.17.2.25
	Kernel-5_35-4_79_2_213:4.17.2.25
	Kernel-5_35-4_79_2_212:4.17.2.25
	Kernel-5_35-4_79_2_211:4.17.2.25
	Kernel-5_35-4_79_2_210:4.17.2.25
	Kernel-5_35-4_79_2_209:4.17.2.25
	Kernel-5_35-4_79_2_208:4.17.2.25
	Kernel-5_35-4_79_2_207:4.17.2.25
	Kernel-5_35-4_79_2_206:4.17.2.25
	Kernel-5_35-4_79_2_205:4.17.2.25
	Kernel-5_35-4_79_2_204:4.17.2.25
	Kernel-5_35-4_79_2_203:4.17.2.25
	Kernel-5_35-4_79_2_202:4.17.2.24
	Kernel-5_35-4_79_2_201:4.17.2.23
	Kernel-5_35-4_79_2_200:4.17.2.22
	Kernel-5_35-4_79_2_199:4.17.2.22
	Kernel-5_35-4_79_2_198:4.17.2.22
	Kernel-5_35-4_79_2_197:4.17.2.22
	Kernel-5_35-4_79_2_196:4.17.2.22
	Kernel-5_35-4_79_2_195:4.17.2.22
	Kernel-5_35-4_79_2_194:4.17.2.22
	Kernel-5_35-4_79_2_193:4.17.2.22
	Kernel-5_35-4_79_2_192:4.17.2.21
	Kernel-5_35-4_79_2_191:4.17.2.21
	Kernel-5_35-4_79_2_190:4.17.2.21
	Kernel-5_35-4_79_2_189:4.17.2.21
	Kernel-5_35-4_79_2_188:4.17.2.21
	Kernel-5_35-4_79_2_187:4.17.2.21
	Kernel-5_35-4_79_2_186:4.17.2.21
	Kernel-5_35-4_79_2_185:4.17.2.21
	Kernel-5_35-4_79_2_184:4.17.2.21
	Kernel-5_35-4_79_2_183:4.17.2.21
	Kernel-5_35-4_79_2_182:4.17.2.20
	Kernel-5_35-4_79_2_181:4.17.2.20
	Kernel-5_35-4_79_2_180:4.17.2.20
	Kernel-5_35-4_79_2_179:4.17.2.20
	Kernel-5_35-4_79_2_178:4.17.2.20
	Kernel-5_35-4_79_2_177:4.17.2.20
	Kernel-5_35-4_79_2_176:4.17.2.20
	Kernel-5_35-4_79_2_175:4.17.2.20
	Kernel-5_35-4_79_2_174:4.17.2.20
	Kernel-5_35-4_79_2_173:4.17.2.20
	Kernel-5_35-4_79_2_172:4.17.2.20
	Kernel-5_35-4_79_2_171:4.17.2.20
	Kernel-5_35-4_79_2_170:4.17.2.20
	Kernel-5_35-4_79_2_169:4.17.2.19
	Kernel-5_35-4_79_2_168:4.17.2.19
	Kernel-5_35-4_79_2_167:4.17.2.19
	Kernel-5_35-4_79_2_166:4.17.2.18
	Kernel-5_35-4_79_2_165:4.17.2.18
	RPi_merge:4.17.2.16.2.1
	Kernel-5_35-4_79_2_147_2_23:4.17.2.16.2.1
	Kernel-5_35-4_79_2_147_2_22:4.17.2.16
	Kernel-5_35-4_79_2_147_2_21:4.17.2.16
	Kernel-5_35-4_79_2_147_2_20:4.17.2.16
	Kernel-5_35-4_79_2_147_2_19:4.17.2.16
	Kernel-5_35-4_79_2_147_2_18:4.17.2.16
	Kernel-5_35-4_79_2_164:4.17.2.18
	Kernel-5_35-4_79_2_163:4.17.2.18
	Kernel-5_35-4_79_2_147_2_17:4.17.2.16
	Kernel-5_35-4_79_2_147_2_16:4.17.2.16
	Kernel-5_35-4_79_2_147_2_15:4.17.2.16
	Kernel-5_35-4_79_2_162:4.17.2.18
	Kernel-5_35-4_79_2_161:4.17.2.17
	Kernel-5_35-4_79_2_147_2_14:4.17.2.16
	Kernel-5_35-4_79_2_147_2_13:4.17.2.16
	Kernel-5_35-4_79_2_160:4.17.2.17
	Kernel-5_35-4_79_2_159:4.17.2.17
	Kernel-5_35-4_79_2_158:4.17.2.16
	Kernel-5_35-4_79_2_157:4.17.2.16
	Kernel-5_35-4_79_2_156:4.17.2.16
	Kernel-5_35-4_79_2_147_2_12:4.17.2.16
	Kernel-5_35-4_79_2_147_2_11:4.17.2.16
	Kernel-5_35-4_79_2_155:4.17.2.16
	Kernel-5_35-4_79_2_147_2_10:4.17.2.16
	Kernel-5_35-4_79_2_154:4.17.2.16
	Kernel-5_35-4_79_2_153:4.17.2.16
	Kernel-5_35-4_79_2_147_2_9:4.17.2.16
	Kernel-5_35-4_79_2_152:4.17.2.16
	Kernel-5_35-4_79_2_151:4.17.2.16
	Kernel-5_35-4_79_2_147_2_8:4.17.2.16
	Kernel-5_35-4_79_2_147_2_7:4.17.2.16
	Kernel-5_35-4_79_2_150:4.17.2.16
	Kernel-5_35-4_79_2_147_2_6:4.17.2.16
	Kernel-5_35-4_79_2_147_2_5:4.17.2.16
	Kernel-5_35-4_79_2_149:4.17.2.16
	Kernel-5_35-4_79_2_147_2_4:4.17.2.16
	Kernel-5_35-4_79_2_147_2_3:4.17.2.16
	Kernel-5_35-4_79_2_148:4.17.2.16
	Kernel-5_35-4_79_2_147_2_2:4.17.2.16
	Kernel-5_35-4_79_2_147_2_1:4.17.2.16
	RPi:4.17.2.16.0.2
	RPi_bp:4.17.2.16
	Kernel-5_35-4_79_2_98_2_52_2_1:4.17.2.14.2.5
	alees_Kernel_dev:4.17.2.14.2.5.0.2
	alees_Kernel_dev_bp:4.17.2.14.2.5
	Kernel-5_35-4_79_2_147:4.17.2.16
	Kernel-5_35-4_79_2_146:4.17.2.16
	Kernel-5_35-4_79_2_145:4.17.2.16
	Kernel-5_35-4_79_2_144:4.17.2.16
	Kernel-5_35-4_79_2_143:4.17.2.16
	Kernel-5_35-4_79_2_142:4.17.2.16
	Kernel-5_35-4_79_2_141:4.17.2.16
	Kernel-5_35-4_79_2_140:4.17.2.16
	Kernel-5_35-4_79_2_139:4.17.2.16
	Kernel-5_35-4_79_2_138:4.17.2.16
	Kernel-5_35-4_79_2_137:4.17.2.16
	Kernel-5_35-4_79_2_136:4.17.2.16
	Kernel-5_35-4_79_2_135:4.17.2.16
	Kernel-5_35-4_79_2_134:4.17.2.16
	Kernel-5_35-4_79_2_133:4.17.2.16
	Kernel-5_35-4_79_2_132:4.17.2.16
	Kernel-5_35-4_79_2_131:4.17.2.16
	Kernel-5_35-4_79_2_130:4.17.2.16
	Kernel-5_35-4_79_2_129:4.17.2.16
	Kernel-5_35-4_79_2_128:4.17.2.16
	Kernel-5_35-4_79_2_127:4.17.2.16
	Kernel-5_35-4_79_2_126:4.17.2.16
	Kernel-5_35-4_79_2_125:4.17.2.16
	Kernel-5_35-4_79_2_124:4.17.2.16
	Kernel-5_35-4_79_2_123:4.17.2.15
	Cortex_merge:4.17.2.14.2.5
	Kernel-5_35-4_79_2_122:4.17.2.14
	Kernel-5_35-4_79_2_98_2_54:4.17.2.14.2.5
	Kernel-5_35-4_79_2_98_2_53:4.17.2.14.2.5
	Kernel-5_35-4_79_2_98_2_52:4.17.2.14.2.5
	Kernel-5_35-4_79_2_98_2_51:4.17.2.14.2.5
	Kernel-5_35-4_79_2_98_2_50:4.17.2.14.2.5
	Kernel-5_35-4_79_2_98_2_49:4.17.2.14.2.5
	Kernel-5_35-4_79_2_98_2_48:4.17.2.14.2.5
	Kernel-5_35-4_79_2_121:4.17.2.14
	Kernel-5_35-4_79_2_98_2_47:4.17.2.14.2.4
	Kernel-5_35-4_79_2_120:4.17.2.14
	Kernel-5_35-4_79_2_98_2_46:4.17.2.14.2.4
	Kernel-5_35-4_79_2_119:4.17.2.14
	Kernel-5_35-4_79_2_98_2_45:4.17.2.14.2.4
	Kernel-5_35-4_79_2_98_2_44:4.17.2.14.2.4
	Kernel-5_35-4_79_2_118:4.17.2.14
	Kernel-5_35-4_79_2_98_2_43:4.17.2.14.2.4
	Kernel-5_35-4_79_2_117:4.17.2.14
	Kernel-5_35-4_79_2_116:4.17.2.14
	Kernel-5_35-4_79_2_98_2_42:4.17.2.14.2.4
	Kernel-5_35-4_79_2_115:4.17.2.14
	Kernel-5_35-4_79_2_98_2_41:4.17.2.14.2.4
	Kernel-5_35-4_79_2_98_2_40:4.17.2.14.2.4
	Kernel-5_35-4_79_2_114:4.17.2.14
	Kernel-5_35-4_79_2_98_2_39:4.17.2.14.2.4
	Kernel-5_35-4_79_2_98_2_38:4.17.2.14.2.4
	Kernel-5_35-4_79_2_113:4.17.2.14
	Kernel-5_35-4_79_2_112:4.17.2.14
	Kernel-5_35-4_79_2_98_2_37:4.17.2.14.2.4
	Kernel-5_35-4_79_2_98_2_36:4.17.2.14.2.4
	Kernel-5_35-4_79_2_98_2_35:4.17.2.14.2.3
	Kernel-5_35-4_79_2_98_2_34:4.17.2.14.2.2
	Kernel-5_35-4_79_2_98_2_33:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_32:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_31:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_30:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_29:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_28:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_27:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_26:4.17.2.14.2.1
	Kernel-5_35-4_79_2_111:4.17.2.14
	Kernel-5_35-4_79_2_98_2_25:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_24:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_23:4.17.2.14.2.1
	Kernel-5_35-4_79_2_110:4.17.2.14
	Kernel-5_35-4_79_2_98_2_22:4.17.2.14.2.1
	Kernel-5_35-4_79_2_109:4.17.2.14
	Kernel-5_35-4_79_2_98_2_21:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_20:4.17.2.14.2.1
	Kernel-5_35-4_79_2_108:4.17.2.14
	Kernel-5_35-4_79_2_107:4.17.2.14
	Kernel-5_35-4_79_2_98_2_19:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_18:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_17:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_16:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_15:4.17.2.14.2.1
	Kernel-5_35-4_79_2_106:4.17.2.14
	Kernel-5_35-4_79_2_105:4.17.2.14
	Kernel-5_35-4_79_2_104:4.17.2.14
	Kernel-5_35-4_79_2_98_2_14:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_13:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_12:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_11:4.17.2.14.2.1
	Kernel-5_35-4_79_2_98_2_10:4.17.2.14
	Kernel-5_35-4_79_2_98_2_9:4.17.2.14
	Kernel-5_35-4_79_2_103:4.17.2.14
	Kernel-5_35-4_79_2_102:4.17.2.14
	Kernel-5_35-4_79_2_98_2_8:4.17.2.14
	Kernel-5_35-4_79_2_98_2_7:4.17.2.14
	Kernel-5_35-4_79_2_98_2_6:4.17.2.14
	Kernel-5_35-4_79_2_98_2_5:4.17.2.14
	Kernel-5_35-4_79_2_98_2_4:4.17.2.14
	Kernel-5_35-4_79_2_101:4.17.2.14
	Kernel-5_35-4_79_2_100:4.17.2.14
	Kernel-5_35-4_79_2_99:4.17.2.14
	Kernel-5_35-4_79_2_98_2_3:4.17.2.14
	Kernel-5_35-4_79_2_98_2_2:4.17.2.14
	Kernel-5_35-4_79_2_98_2_1:4.17.2.14
	Cortex:4.17.2.14.0.2
	Cortex_bp:4.17.2.14
	Kernel-5_35-4_79_2_98:4.17.2.14
	Kernel-5_35-4_79_2_97:4.17.2.14
	Kernel-5_35-4_79_2_96:4.17.2.14
	Kernel-5_35-4_79_2_95:4.17.2.14
	Kernel-5_35-4_79_2_94:4.17.2.14
	Kernel-5_35-4_79_2_93:4.17.2.14
	Kernel-5_35-4_79_2_92:4.17.2.14
	Kernel-5_35-4_79_2_91:4.17.2.14
	Kernel-5_35-4_79_2_90:4.17.2.14
	Kernel-5_35-4_79_2_89:4.17.2.14
	Kernel-5_35-4_79_2_88:4.17.2.14
	Kernel-5_35-4_79_2_87:4.17.2.14
	Kernel-5_35-4_79_2_86:4.17.2.14
	Kernel-5_35-4_79_2_85:4.17.2.14
	Kernel-5_35-4_79_2_84:4.17.2.14
	Kernel-5_35-4_79_2_83:4.17.2.14
	Kernel-5_35-4_79_2_82:4.17.2.14
	Kernel-5_35-4_79_2_81:4.17.2.14
	Kernel-5_35-4_79_2_80:4.17.2.13
	Kernel-5_35-4_79_2_79:4.17.2.13
	Kernel-5_35-4_79_2_78:4.17.2.13
	Kernel-5_35-4_79_2_77:4.17.2.13
	RO_5_07:4.17.2.13
	Kernel-5_35-4_79_2_76:4.17.2.13
	Kernel-5_35-4_79_2_75:4.17.2.13
	Kernel-5_35-4_79_2_74:4.17.2.13
	Kernel-5_35-4_79_2_73:4.17.2.13
	Kernel-5_35-4_79_2_72:4.17.2.13
	Kernel-5_35-4_79_2_71:4.17.2.13
	Kernel-5_35-4_79_2_70:4.17.2.13
	Kernel-5_35-4_79_2_69:4.17.2.13
	Kernel-5_35-4_79_2_68:4.17.2.13
	Kernel-5_35-4_79_2_67:4.17.2.13
	Kernel-5_35-4_79_2_66:4.17.2.13
	Kernel-5_35-4_79_2_65:4.17.2.12
	Kernel-5_35-4_79_2_64:4.17.2.12
	Kernel-5_35-4_79_2_63:4.17.2.12
	Kernel-5_35-4_79_2_62:4.17.2.12
	Kernel-5_35-4_79_2_61:4.17.2.12
	Kernel-5_35-4_79_2_59:4.17.2.12
	Kernel-5_35-4_79_2_58:4.17.2.12
	Kernel-5_35-4_79_2_57:4.17.2.12
	Kernel-5_35-4_79_2_56:4.17.2.12
	Kernel-5_35-4_79_2_55:4.17.2.12
	Kernel-5_35-4_79_2_54:4.17.2.12
	Kernel-5_35-4_79_2_53:4.17.2.12
	Kernel-5_35-4_79_2_52:4.17.2.12
	Kernel-5_35-4_79_2_51:4.17.2.12
	Kernel-5_35-4_79_2_50:4.17.2.12
	Kernel-5_35-4_79_2_49:4.17.2.12
	Kernel-5_35-4_79_2_48:4.17.2.12
	Kernel-5_47:4.17
	Kernel-5_46-4_90_2_1:4.17.4.1
	nbingham_Kernel_FastNC_dev_bp:4.17
	nbingham_Kernel_FastNC_dev:4.17.0.4
	Kernel-5_46:4.17
	Kernel-5_45:4.17
	Kernel-5_35-4_79_2_47:4.17.2.11
	Kernel-5_35-4_79_2_46:4.17.2.11
	Kernel-5_35-4_79_2_45:4.17.2.10
	Kernel-5_35-4_79_2_44:4.17.2.10
	Kernel-5_35-4_79_2_25_2_2:4.17.2.9
	Kernel-5_35-4_79_2_43:4.17.2.10
	Kernel-5_35-4_79_2_42:4.17.2.10
	Kernel-5_35-4_79_2_41:4.17.2.10
	Kernel-5_35-4_79_2_40:4.17.2.10
	Kernel-5_35-4_79_2_39:4.17.2.10
	Kernel-5_35-4_79_2_38:4.17.2.10
	Kernel-5_35-4_79_2_37:4.17.2.9
	Kernel-5_35-4_79_2_36:4.17.2.9
	Kernel-5_35-4_79_2_35:4.17.2.9
	Kernel-5_35-4_79_2_34:4.17.2.9
	Kernel-5_35-4_79_2_33:4.17.2.9
	Kernel-5_35-4_79_2_32:4.17.2.9
	Kernel-5_44:4.17
	Kernel-5_35-4_79_2_25_2_1:4.17.2.9
	Kernel-5_43:4.17
	Kernel-5_35-4_79_2_31:4.17.2.9
	Kernel-5_35-4_79_2_30:4.17.2.9
	Kernel-5_35-4_79_2_29:4.17.2.9
	Kernel-5_35-4_79_2_28:4.17.2.9
	Kernel-5_35-4_79_2_27:4.17.2.9
	Kernel-5_35-4_79_2_26:4.17.2.9
	Kernel-5_42:4.17
	Kernel-5_41:4.17
	Kernel-5_40:4.17
	Kernel-5_35-4_79_2_25:4.17.2.9
	Kernel-5_35-4_79_2_24:4.17.2.9
	Kernel-5_35-4_79_2_23:4.17.2.9
	Kernel-5_35-4_79_2_22:4.17.2.9
	Kernel-5_35-4_79_2_21:4.17.2.9
	Kernel-5_35-4_79_2_20:4.17.2.9
	Kernel-5_35-4_79_2_19:4.17.2.9
	Kernel-5_35-4_79_2_18:4.17.2.8
	Kernel-5_35-4_79_2_17:4.17.2.8
	Kernel-5_35-4_79_2_16:4.17.2.7
	Kernel-5_35-4_79_2_15:4.17.2.7
	Kernel-5_35-4_79_2_14:4.17.2.7
	Kernel-5_39:4.17
	Kernel-5_13-4_52_2_1:4.15
	Bethany:4.15.0.2
	Kernel-5_38:4.17
	Kernel-5_35-4_79_2_13:4.17.2.7
	Kernel-5_35-4_79_2_12:4.17.2.7
	Kernel-5_35-4_79_2_11:4.17.2.7
	Kernel-5_37:4.17
	Kernel-5_35-4_79_2_10:4.17.2.7
	Kernel-5_35-4_79_2_9:4.17.2.6
	Kernel-5_36:4.17
	Kernel-5_35-4_79_2_8:4.17.2.4
	Kernel-5_35-4_79_2_7:4.17.2.3
	Kernel-5_35-4_79_2_6:4.17.2.2
	Kernel-5_35-4_79_2_5:4.17.2.2
	Kernel-5_35-4_79_2_4:4.17.2.1
	Kernel-5_35-4_79_2_3:4.17.2.1
	Kernel-5_35-4_79_2_2:4.17.2.1
	dellis_autobuild_BaseSW:4.17
	Kernel-5_35-4_79_2_1:4.17.2.1
	HAL:4.17.0.2
	Kernel-5_35:4.17
	Kernel-5_34:4.17
	Kernel-5_33:4.17
	Kernel-5_32:4.17
	Kernel-5_31:4.17
	Kernel-5_30:4.17
	Kernel-5_29:4.17
	Kernel-5_28:4.17
	Kernel-5_27:4.17
	Kernel-5_26:4.17
	Kernel-5_25:4.17
	Kernel-5_24:4.17
	Kernel-5_23:4.17
	Kernel-5_22:4.16
	sbrodie_sedwards_16Mar2000:4.15
	Kernel-5_21:4.15
	Kernel-5_20:4.15
	Kernel-5_19:4.15
	Kernel-5_18:4.15
	Kernel-5_17:4.15
	Kernel-5_16:4.15
	Kernel-5_15:4.15
	Kernel-5_14:4.15
	Kernel-5_13:4.15
	Kernel-5_12:4.15
	Kernel-5_11:4.15
	Kernel-5_10:4.15
	Kernel-5_09:4.15
	Kernel-5_08:4.15
	Kernel-5_07:4.15
	Kernel-5_06:4.15
	Kernel-5_05:4.14
	Kernel-5_04:4.13
	Kernel-5_03:4.13
	Kernel-5_02:4.13
	Kernel-5_01:4.13
	Kernel-5_00:4.13
	Kernel-4_99:4.12
	Kernel-4_98:4.12
	Kernel-4_97:4.11
	Kernel-4_96:4.11
	Kernel-4_95:4.11
	Kernel-4_94:4.10
	Kernel-4_93:4.9
	Kernel-4_92:4.9
	Kernel-4_91:4.8
	Kernel-4_90:4.7
	dcotton_autobuild_BaseSW:4.17
	Kernel-4_89:4.6
	Kernel-4_88:4.6
	Kernel-4_87:4.6
	Kernel-4_86:4.6
	Kernel-4_85:4.6
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.3.2.1.2.1
	Kernel-4_84:4.6
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.3.2.1.2.1
	Ursula_RiscPC_bp:4.3.2.1
	Kernel-4_83:4.6
	Kernel-4_82:4.6
	Kernel-4_81:4.6
	Kernel-4_80:4.6
	Kernel-4_79:4.6
	Kernel-4_78:4.6
	Kernel-4_77:4.6
	Kernel-4_76:4.6
	Kernel-4_75:4.6
	Kernel-4_74:4.6
	Kernel-4_73:4.6
	Kernel-4_72:4.6
	Kernel-4_71:4.6
	Kernel-4_70:4.6
	Kernel-4_69:4.5
	Kernel-4_68:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.1.2.1
	Ursula_RiscPC:4.3.2.1.0.2
	Kernel-4_63-1_1_2_5:4.1.7.6
	Kernel-4_63-1_1_2_4:4.1.7.6
	Kernel-4_67:4.4
	Kernel-4_66:4.4
	Kernel-4_63-1_1_2_3:4.1.7.6
	Kernel-4_65:4.4
	Ursula_merge:4.3
	Kernel-4_64:4.4
	mstphens_Kernel-3_81:4.3.2.2
	Kernel-4_63-1_1_2_2:4.1.7.6
	nicke_Kernel_4_62:4.1.7.6
	rthornb_UrsulaBuild-19Aug1998:4.3.2.1
	UrsulaBuild_FinalSoftload:4.3.2.1
	rthornb_UrsulaBuild-12Aug1998:4.3.2.1
	aglover_UrsulaBuild-05Aug1998:4.3.2.1
	rthornb_UrsulaBuild-29Jul1998:4.3.2.1
	rthornb_UrsulaBuild-22Jul1998:4.3.2.1
	nturton_v459:4.1.7.5
	nturton_v460:4.1.7.6
	rthornb_UrsulaBuild-15Jul1998:4.3.2.1
	rthornb_UrsulaBuild-07Jul1998:4.3.2.1
	rthornb_UrsulaBuild-17Jun1998:4.3.2.1
	rthornb_UrsulaBuild-03Jun1998:4.3.2.1
	rthornb_UrsulaBuild-27May1998:4.3.2.1
	mstphens_Kernel-3_80:4.3.2.1
	rthornb_UrsulaBuild-21May1998:4.3.2.1
	afrost_Boca-1_2-Beta:4.1.7.6
	rthornb_UrsulaBuild_01May1998:4.3.2.1
	afrost_NC2_Generic:4.1.7.5
	Spinner_B20_2:4.1.7.5
	Spinner_19_3:4.1.7.5
	Spinner_B18:4.1.7.5
	Spinner_B17:4.1.7.5
	Spinner_B15:4.1.7.5
	Spinner_B14:4.1.7.5
	Spinner_B13:4.1.7.5
	Spinner_B12:4.1.7.5
	Spinner_B10:4.1.7.5
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.2
	Spin_3Apr97:4.1.7.3
	ARTtmp:4.1.7.2.0.2
	Spin_merge:4.1.7.6
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.26
date	2018.06.16.13.29.45;	author rool;	state Exp;
branches;
next	4.25;
commitid	k3HPMJpkVeRoBvGA;

4.25
date	2018.03.25.21.05.17;	author rsprowson;	state Exp;
branches;
next	4.24;
commitid	IkZPwNjh3MM7NSvA;

4.24
date	2018.02.03.18.41.41;	author rsprowson;	state Exp;
branches;
next	4.23;
commitid	VwdJDuE1iBptBrpA;

4.23
date	2017.09.09.10.35.45;	author rool;	state Exp;
branches;
next	4.22;
commitid	SuZJGVb4fAmIDv6A;

4.22
date	2016.08.02.18.01.15;	author rsprowson;	state Exp;
branches
	4.22.2.1;
next	4.21;
commitid	kashyUwnzLSn3Lgz;

4.21
date	2016.06.30.20.59.50;	author jlee;	state Exp;
branches;
next	4.20;
commitid	skOEjp3ipLHx6xcz;

4.20
date	2016.06.30.20.42.08;	author jlee;	state Exp;
branches;
next	4.19;
commitid	bDF3DCxdmyMD0xcz;

4.19
date	2016.06.30.20.29.02;	author jlee;	state Exp;
branches;
next	4.18;
commitid	lMnWzoE9eJz3Wwcz;

4.18
date	2016.06.30.20.08.16;	author jlee;	state Exp;
branches;
next	4.17;
commitid	IWoXxARWeuLDOwcz;

4.17
date	2000.04.04.14.27.37;	author kbracey;	state Exp;
branches
	4.17.2.1
	4.17.4.1;
next	4.16;

4.16
date	2000.03.23.16.40.48;	author bavison;	state Exp;
branches;
next	4.15;

4.15
date	99.11.01.12.16.46;	author kbracey;	state Exp;
branches;
next	4.14;

4.14
date	99.10.29.16.10.06;	author kbracey;	state Exp;
branches;
next	4.13;

4.13
date	99.10.19.14.48.03;	author kbracey;	state Exp;
branches;
next	4.12;

4.12
date	99.10.18.16.15.34;	author kbracey;	state Exp;
branches;
next	4.11;

4.11
date	99.10.13.17.00.57;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	99.10.13.16.21.31;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	99.10.07.11.09.25;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.10.01.15.32.31;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.09.29.17.09.31;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.02.15.17.53.37;	author nturton;	state Exp;
branches;
next	4.5;

4.5
date	99.02.09.10.57.42;	author nturton;	state Exp;
branches;
next	4.4;

4.4
date	98.09.30.08.42.49;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.05.51.55;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.14.07.28;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.30;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.22.2.1
date	2017.09.10.11.27.25;	author jlee;	state Exp;
branches;
next	4.22.2.2;
commitid	EGooxXrB27MqTD6A;

4.22.2.2
date	2018.02.16.00.01.43;	author jlee;	state Exp;
branches;
next	4.22.2.3;
commitid	L7HYXYTsWSFlZ0rA;

4.22.2.3
date	2018.05.14.19.33.46;	author jlee;	state Exp;
branches;
next	4.22.2.4;
commitid	wrVtYH84nAz1GiCA;

4.22.2.4
date	2018.07.07.13.15.16;	author jlee;	state Exp;
branches;
next	;
commitid	xZcbvu8u7pqAQcJA;

4.17.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.17.2.2;

4.17.2.2
date	2000.10.05.13.54.49;	author kbracey;	state Exp;
branches;
next	4.17.2.3;

4.17.2.3
date	2000.10.05.16.20.01;	author kbracey;	state Exp;
branches;
next	4.17.2.4;

4.17.2.4
date	2000.10.05.16.46.36;	author dellis;	state Exp;
branches;
next	4.17.2.5;

4.17.2.5
date	2000.10.06.09.08.12;	author kbracey;	state Exp;
branches;
next	4.17.2.6;

4.17.2.6
date	2000.10.10.10.54.17;	author mstephen;	state Exp;
branches;
next	4.17.2.7;

4.17.2.7
date	2000.10.16.11.55.38;	author kbracey;	state Exp;
branches;
next	4.17.2.8;

4.17.2.8
date	2001.02.13.09.36.05;	author kbracey;	state Exp;
branches;
next	4.17.2.9;

4.17.2.9
date	2001.03.07.15.12.59;	author kbracey;	state Exp;
branches;
next	4.17.2.10;

4.17.2.10
date	2001.06.18.14.49.47;	author mstephen;	state Exp;
branches;
next	4.17.2.11;

4.17.2.11
date	2001.07.11.09.35.20;	author dcotton;	state Exp;
branches;
next	4.17.2.12;

4.17.2.12
date	2002.10.07.17.29.44;	author kbracey;	state Exp;
branches;
next	4.17.2.13;

4.17.2.13
date	2004.05.06.16.02.04;	author kbracey;	state Exp;
branches;
next	4.17.2.14;

4.17.2.14
date	2004.11.02.00.48.03;	author jballance;	state Exp;
branches
	4.17.2.14.2.1;
next	4.17.2.15;

4.17.2.15
date	2011.11.26.21.11.24;	author jlee;	state Exp;
branches;
next	4.17.2.16;
commitid	cI3W0zbtALQG6TIv;

4.17.2.16
date	2011.11.27.11.48.16;	author rsprowson;	state Exp;
branches
	4.17.2.16.2.1;
next	4.17.2.17;
commitid	OFgqaKhOb6swXXIv;

4.17.2.17
date	2012.07.04.17.50.53;	author rsprowson;	state Exp;
branches;
next	4.17.2.18;
commitid	BwjRc3GMlaDwTgbw;

4.17.2.18
date	2012.07.09.21.25.47;	author jlee;	state Exp;
branches;
next	4.17.2.19;
commitid	tMQ3DznBtuTlVVbw;

4.17.2.19
date	2012.09.30.08.46.19;	author rsprowson;	state Exp;
branches;
next	4.17.2.20;
commitid	oaVP9UztPt2m3xmw;

4.17.2.20
date	2012.10.07.20.49.08;	author rsprowson;	state Exp;
branches;
next	4.17.2.21;
commitid	ocaIVgVgiiMpPunw;

4.17.2.21
date	2013.01.27.17.50.30;	author rsprowson;	state Exp;
branches;
next	4.17.2.22;
commitid	tDlfhdSfOxFReSBw;

4.17.2.22
date	2013.07.31.07.02.55;	author rsprowson;	state Exp;
branches;
next	4.17.2.23;
commitid	ynQoUvWVB9V4IAZw;

4.17.2.23
date	2013.11.16.12.30.18;	author rsprowson;	state Exp;
branches;
next	4.17.2.24;
commitid	9tijEFmxNuG63vdx;

4.17.2.24
date	2013.11.20.20.30.02;	author rsprowson;	state Exp;
branches;
next	4.17.2.25;
commitid	X1FKtc2EAz7Jz3ex;

4.17.2.25
date	2013.12.15.21.34.08;	author jlee;	state Exp;
branches;
next	4.17.2.26;
commitid	KwuK29hKRyXO7hhx;

4.17.2.26
date	2014.04.18.14.10.53;	author jlee;	state Exp;
branches;
next	4.17.2.27;
commitid	4EaaKIpUowBKGaxx;

4.17.2.27
date	2014.06.01.10.15.48;	author jlee;	state Exp;
branches;
next	4.17.2.28;
commitid	QTz6wSc2iYaoYNCx;

4.17.2.28
date	2014.11.13.22.19.19;	author rsprowson;	state Exp;
branches;
next	4.17.2.29;
commitid	w8sxKkSQnrGJF4Yx;

4.17.2.29
date	2015.08.05.21.51.36;	author jlee;	state Exp;
branches;
next	;
commitid	SpZpzVH47zb408wy;

4.17.2.14.2.1
date	2009.07.23.00.57.12;	author jlee;	state Exp;
branches;
next	4.17.2.14.2.2;

4.17.2.14.2.2
date	2011.02.20.01.08.49;	author jlee;	state Exp;
branches;
next	4.17.2.14.2.3;

4.17.2.14.2.3
date	2011.02.20.01.24.14;	author jlee;	state Exp;
branches;
next	4.17.2.14.2.4;

4.17.2.14.2.4
date	2011.03.19.18.25.05;	author jlee;	state Exp;
branches;
next	4.17.2.14.2.5;
commitid	Na7ovxBALQiWhucv;

4.17.2.14.2.5
date	2011.08.08.23.28.34;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

4.17.2.16.2.1
date	2012.09.18.15.50.07;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.17.4.1
date	2002.07.25.15.30.00;	author nbingham;	state Exp;
branches;
next	;

4.3.2.1
date	97.09.09.13.34.14;	author mstphens;	state Exp;
branches
	4.3.2.1.2.1;
next	4.3.2.2;

4.3.2.2
date	98.09.24.13.17.38;	author mstphens;	state Exp;
branches;
next	;

4.3.2.1.2.1
date	98.11.23.14.59.33;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.30;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.02.04;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.08.09.32;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.16.46.11;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.12.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.04.18;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.13.15.02.38;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.04.03.15.32.50;	author tdobson;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.05.12.10.44.44;	author scormie;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.05.14.12.01.15;	author nturton;	state Exp;
branches;
next	4.1.7.6;

4.1.7.6
date	97.12.11.14.01.33;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.26
log
@Various kernel cleanups
Detail:
  NewReset.s: Remove warning about soft reset, this is not supported any longer
  MsgCode.s: Reload LR after potentially changing mode
  PMF/osinit.s: Delete vestiges of soft reset support
Admin:
  Submission from Timothy Baldwin.

Version 6.07. Tagged as 'Kernel-6_07'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > $.Source.PMF.osinit

; *****************************************************************************

ExecuteInit ROUT
        Push    R14

       ; Point to OsbyteVars
       ; and initialise them

        BYTEWS  WsPtr

        LDRB    R4, LastBREAK           ; 1 => power-on, 2 => hard
        CMP     R4, #PowerOnReset
        ADREQ   R2, PowerOnResetVars
        ADRNE   R2, HardResetVars

        MOV     R3, #0
        STR     R3, TimerAlpha +0       ; zero both copies of TIME
        STR     R3, TimerAlpha +4
        STR     R3, TimerBeta +0
        STR     R3, TimerBeta +4

        MOV     R1, #32                 ; default FX11 and FX12
        STRB    R1, KeyRepDelay
        MOV     R1, #8
        STRB    R1, KeyRepRate

        MOV     R1, WsPtr               ; start at the beginning
        ADR     R11, ByteVarInitTable

ByteVarInitLoop
        LDRB    R0, [R11], #1           ; copy a byte from table
        STRB    R0, [R1], #1            ; to vars
        TEQ     R1, R2                  ; at end ?
        BNE     ByteVarInitLoop         ; [no, then loop]

        STRB    R3, NoIgnore            ; zero NoIgnore
        STRB    R4, LastBREAK           ; put LastBREAK back

; Initialise buffer pointers

        LDR     R0, =ZeroPage+4*(NBuffers-1) ; index to pointer
        MOV     R1, #0                  ; value to store
        MOV     R2, #NBuffers-1
BuffPtrInitLoop
        STR     R1, [R0, #BuffInPtrs]
        STR     R1, [R0, #BuffOutPtrs]
        SUB     R0, R0, #4
        SUBS    R2, R2, #1
        BPL     BuffPtrInitLoop

; mark printer as dormant

        STR     R1, PrinterActive       ; (R1=0)

; initialise SpriteSize to zero (fixes bug MED-00811)

        LDR     R2, =ZeroPage
        STR     R1, [R2, #SpriteSize]

; Initialise event semaphores

        ADR     R0, EventSemaphores
        ADD     R2, R0, #32
10
        STR     R1, [R0], #4            ; clear all 32 event semaphores
        TEQ     R0, R2
        BNE     %BT10

        STRB    R1, FlashState
        STRB    R1, SerialInHandle      ; zero serial handles
        STRB    R1, SerialOutHandle

; Initialise LatchB and soft copy

;        MOV     R1, #0          ; AND with 0 (was omitted on earlier MOS) ; R1 already zero
        MOV     R0, #0          ; EOR with 0
        BL      UpdateLatchB

        LDR     R1, =ZeroPage
        MOV     R0, #4_3330             ; Assume VGA during osinit
        STRB    R0, [R1, #MonitorLeadType]

        BL      ReadUniqueID

        Push    "r9,r12"
        AddressHAL
        MOV     R0, #0
        CallHAL HAL_TimerDevice
        MOV     R4, R0
        CallHAL HAL_IRQClear            ; clear timer 0 IRQ
        MOV     R0, R4
        CallHAL HAL_IRQEnable           ; enable timer 0 IRQ
        Pull    "r9,r12"

; The RTC driver is later on in the module chain, or missing, for now default the
; system time to UNIX epoch + 1 day (so time() doesn't return -1)
secs0070 *      (86400*(365*70+18))     ; from time() in risc_oslib.c.armsys
        LDR     R7, =(secs0070 * 100)   ; centiseconds LSW
        MOV     R8, #&33                ; centiseconds MSW
        BL      Store5ByteInRealTime

; insert soft key 10
        MOV     R2, #&CA
        BL      RDCHS
        Pull    PC

        LTORG

; *****************************************************************************
;
;       InitHostedDAs - Set up the dynamic areas that we kindly host on
;       behalf of other parts of the OS (SpriteUtils, RamFS, Font Manager)

InitHostedDAs
        Push    "r0-r12, lr"

        ; SpriteArea
        MOV     r0, #SpriteSizeCMOS     ; find out how much spritesize configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size

        MOV     r1, #ChangeDyn_SpriteArea ; Area number
        MOV     r3, #-1                 ; Base address dynamic
        MOV     r4, #AreaFlags_Sprites  ; Area flags
        MOV     r5, #16*1024*1024       ; Maximum size (changed from -1, address space preservation)
        ADRL    r6, DynAreaHandler_Sprites ; Pointer to handler
        MOV     r7, #-1                 ; Use base address as workspace ptr
        ADRL    r8, AreaName_SpriteArea ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!

        ; RAMDisc
        MOV     r1, #ChangeDyn_RamFS    ; Area number
        MOV     r3, #-1                 ; Base address dynamic
        ARM_read_ID r4
        AND     r4, r4, #&F000
        CMP     r4, #&A000
        MOVEQ   r4, #AreaFlags_RAMDisc_SA ; Area flags, if StrongARM  (introduced for Ursula)
        MOVNE   r4, #AreaFlags_RAMDisc  ; Area flags
      [ PMPRAMFS
        MOV     r5, #PMPRAMFS_Size*4096
        ORR     r4, r4, #DynAreaFlags_PMP
        MOV     r2, #0
        ORR     r4, r4, #DynAreaFlags_NeedsSpecificPages
        MOV     r9, #0
      |
        MOV     r0, #RAMDiscCMOS        ; find out how much RAM disc configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size
        MOV     r5, #128*1024*1024      ; A trade off between nice big disc and complete waste of address space
      ]
        ADRL    r6, DynAreaHandler_RAMDisc ; Pointer to handler
        MOV     r7, #-1                 ; Use base address as workspace ptr
        ADRL    r8, AreaName_RAMDisc    ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
      [ PMPRAMFS
        ; Currently, physical memory pools must be created with 0 size, then resized afterwards
        MOV     r0, #RAMDiscCMOS        ; find out how much RAM disc configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size
        MOVS    r1, r2
        MOV     r0, #ChangeDyn_RamFS
        SWINE   XOS_ChangeDynamicArea
      ]

        ; FontArea
        MOV     r0, #FontCMOS           ; find out how much font cache configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size

        MOV     r1, #ChangeDyn_FontArea ; Area number
        MOV     r3, #-1                 ; Base address dynamic
        MOV     r4, #AreaFlags_FontArea ; Area flags
        MOV     r5, #32*1024*1024       ; Maximum size changed from -1 for Ursula (limit address
                                        ; space usage on large memory machines)
        ADRL    r6, DynAreaHandler_FontArea ; Pointer to handler
        MOV     r7, #-1                 ; Use base address as workspace ptr
        ADRL    r8, AreaName_FontArea   ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!

        Pull    "r0-r12, pc"

; *****************************************************************************
;
;       ReadHardCMOSDefaults - Read CMOS values for a hard/power-on reset
;       On entry WsPtr -> BYTEWS

ReadHardCMOSDefaults
        Push    R14

        MOV     R0, #PigCMOS
        BL      Read
        STRB    R0, PrinterIgnore

        MOV     R0, #PSITCMOS
        BL      Read
        TST     R0, #2                  ; NoIgnore bit
        MOVEQ   R1, #0
        MOVNE   R1, #&80
        STRB    R1, NoIgnore

        MOV     R1, R0, LSR #5          ; printer type now in bits 0..2
        STRB    R1, PrinterDrivType

        MOV     R0, #MODETVCMOS
        BL      Read
        MOV     R2, R0, LSR #4          ; bit0:=interlace, bits 1-3 := vertical
        AND     R1, R2, #1
        STRB    R1, TVInterlace
        MOV     R2, R2, LSL #31-3       ; bits 29-31 := vertical
        MOV     R2, R2, ASR #29         ; sign extend
        STRB    R2, TVVertical

        MOV     R0, #DBTBCMOS
        BL      Read
        LDRB    R1, StartOptions
        TST     R0, #&10                ; bit 4 = boot bit
        ORREQ   R1, R1, #8              ; noboot => set bit 3
        BICNE   R1, R1, #8              ; boot => clear bit 3
        STRB    R1, StartOptions

        LDR     R2, =ZeroPage+VduDriverWorkSpace+CursorFlags
        ANDS    R1, R0, #8              ; noscroll bit - put 0 or 1
        MOVNE   R1, #1                  ; in bottom byte of CursorFlags
        STRB    R1, [R2]                ; leave other bytes alone

        MOV     R0, #CountryCMOS        ; read country CMOS and store in var
        BL      Read                    ; but don't bind 'Default' to a fixed
        STRB    R0, Country             ; country at this stage

        BL      SetUpPrinterBuffer
        Pull    PC

; *****************************************************************************
;
;       ReadCMOSDefaults - Read CMOS values for any reset
;       On entry WsPtr -> BYTEWS

ReadCMOSDefaults
        Push    R14

        MOV     R0, #DBTBCMOS
        BL      Read
        TST     R0, #2                  ; NZ => loud
        MOVEQ   R1, #&D0                ; (quiet)
        MOVNE   R1, #&90                ; (LOUD)
        STRB    R1, BELLinfo

        MOV     R0, #StartCMOS
        BL      Read
        MOVS    R1, R0, LSL #(32-5)     ; bit 5 -> carry, bit 4 -> N bit
        MOVPL   R1, #KBStat_NoShiftLock + KBStat_ShiftEnable ; SHCAPS
        MOVMI   R1, #KBStat_NoShiftLock + KBStat_NoCapsLock  ; NOCAPS
        MOVCS   R1, #KBStat_NoShiftLock                      ; CAPS
        TST     R0, #1:SHL:7                                 ; [NO]NUM
        ORRNE   R1, R1, #KBStat_NoNumLock
        BICEQ   R1, R1, #KBStat_NoNumLock
        STRB    R1, KeyBdStatus
        LDR     R11, =ZeroPage+KeyWorkSpace
        BL      UpdateLEDs

        MOV     R0, #SystemSpeedCMOS
        BL      Read
        TST     R0, #&20                ; Cache off when b5 set
        LDR     R2, =:NOT: (MMUC_I + MMUC_C + MMUC_W)
        LDRNE   R1, =0
        LDREQ   R1, =MMUC_I + MMUC_C + MMUC_W
        MOV     R0, #MMUCReason_ModifyControl
        BL      MMUControlSub
        
        BL      Read_Configd_MonitorType
        LDR     r1, =ZeroPage+VduDriverWorkSpace+CurrentMonitorType ; set current to default
        STR     r0, [r1]

        Pull    R14

; and drop thru to ...

ReadKeyDefaults
        Push    R14

        MOV     R0, #KeyDelCMOS         ; Read the default out of CMOS RAM
        BL      Read                    ; comes back in R0
        STRB    R0, KeyRepDelay

        MOV     R0, #KeyRepCMOS         ; Read the default out of CMOS RAM
        BL      Read                    ; comes back in R0
        STRB    R0, KeyRepRate

        Pull    PC

; *****************************************************************************
;
;       PostInit - Called by Sam after modules have been initialised
;

PostInit ROUT
        Push    R14
        BYTEWS  WsPtr

        SWI     XPortable_ReadFeatures
        BVC     %FT01

        MOV     R0, #0
        MOV     R1, #0
        SWI     XPortable_Speed         ; attempt to make the portable go fast!
        MOVVC   R1, #PortableFeature_Speed
        MOVVS   R1, #0
01
        AND     R1, R1, #(PortableFeature_Speed :OR: PortableFeature_Idle :OR: PortableFeature_Stop)
        LDR     R0, =ZeroPage
        STRB    R1, [R0, #PortableFlags]
        Pull    PC

; *****************************************************************************
;
;       SetUpPrinterBuffer - create the printer buffer

SetUpPrinterBuffer Entry "r1-r3"
        MOV     r0, #PrinterBufferCMOS
        BL      Read
        LDR     r2, =ZeroPage
        LDR     r2, [r2, #Page_Size]
        MULS    r3, r2, r0
        BEQ     %FT10                           ; if zero, then use default area & size

        BL      ClaimSysHeapNode                ; else claim space from system heap
        BVC     %FT20                           ; if no error then OK, else use default
10
        LDR     r2, =PrintBuff                  ; use default buffer
        MOV     r3, #PrintBuffSize
20
        LDR     r0, =ZeroPage
        STR     r2, [r0, #PrinterBufferAddr]
        STR     r3, [r0, #PrinterBufferSize]
        EXIT

; *****************************************************************************
;
;       UpdateLatchB - update latch B and soft copy
;
;       LATCHB := (LATCHB AND R1) EOR R0
;

UpdateLatchB
        Push    "R2, R3, R14"
        PHPSEI                                ; disable IRQ

        LDR     R2, =ZeroPage
        LDRB    R3, [R2, #LatchBSoftCopy]
        AND     R3, R3, R1
        EOR     R3, R3, R0
        STRB    R3, [R2, #LatchBSoftCopy]

        PLP
        Pull    "R2, R3, PC"

; The initial values for all of the osbyte variables
; as decreed by arthur.

ByteVarInitTable
                        ; The main osbyte variables, accessed
                        ; via calls &A6 to &FF

  DCW OsbyteVars-&A6    ; VarStart  #  2     ; &A6,&A7
  = 0,0                 ; ROMPtr    #  2     ; &A8,&A9
  = 0,0                 ; ROMInfo   #  2     ; &AA,&AB
  = 0,0                 ; KBTran    #  2     ; &AC,&AD
  = 0,0                 ; VDUvars   #  2     ; &AE,&AF
                        ;
  = 0                   ; CFStime   #  1     ; &B0
  = 0                   ; InputStream #  1   ; &B1
  = &FF                 ; KeyBdSema #  1     ; &B2
                        ;
  = &00                 ; ROMPollSema # 1    ; &B3
  = &80                 ; OSHWM     #  1     ; &B4 (hi-byte of &8000)
                        ;
  = 1                   ; RS423mode #  1     ; &B5
  = 0                   ; NoIgnore  #  1     ; &B6
  = &00                 ; CFSRFS    #  1     ; &B7
  = &00,&00             ; VULAcopy  #  2     ; &B8,&B9
                        ;
  = &00                 ; ROMatBRK  #  1     ; &BA
  = &FF                 ; BASICROM  #  1     ; &BB
                        ;
  = &04                 ; ADCchanel #  1     ; &BC
  = &04                 ; ADCmaxchn #  1     ; &BD
  = &00                 ; ADCconv   #  1     ; &BE
                        ;
  = &FF                 ; RS432use     #  1  ; &BF
  = &42                 ; RS432conflag #  1  ; &C0
                        ;
  = &19                 ; FlashCount # 1     ; &C1
  = &19                 ; SpacPeriod # 1     ; &C2
  = &19                 ; MarkPeriod # 1     ; &C3
                        ;
  = &32                 ; KeyRepDelay # 1    ; &C4
  = &08                 ; KeyRepRate  # 1    ; &C5
                        ;
  = &00                 ; ExecFileH   # 1    ; &C6
  = &00                 ; SpoolFileH  # 1    ; &C7
                        ;
  = &00                 ; ESCBREAK    # 1    ; &C8 (200)
                        ;
  = &00                 ; KeyBdDisable # 1   ; &C9
  = &34                 ; KeyBdStatus  # 1   ; &CA
                        ;
  = &11                 ; RS423HandShake # 1 ; &CB
  = &00                 ; RS423InputSupr # 1 ; &CC
  = &00                 ; RS423CFSFlag   # 1 ; &CD
                        ;
  = &00                 ; EconetOScall # 1   ; &CE
  = &00                 ; EconetOSrdch # 1   ; &CF
  = &00                 ; EconetOSwrch # 1   ; &D0
                        ;
  = &00                 ; SpeechSupr # 1     ; &D1
  = &00                 ; SoundSupr # 1      ; &D2
                        ;
  = &01                 ; BELLchannel # 1    ; &D3
  = &90                 ; BELLinfo    # 1    ; &D4
  = &64                 ; BELLfreq    # 1    ; &D5
  = &06                 ; BELLdur     # 1    ; &D6
                        ;
  = &81                 ; StartMessSupr # 1  ; &D7
                        ;
  = &00                 ; SoftKeyLen # 1     ; &D8
                        ;
  = &00                 ; PageModeLineCount # 1          ; &D9
                        ;
  = &00                 ; VDUqueueItems # 1  ; &DA
                        ;
  = &09                 ; TABch # 1          ; &DB
  = &1B                 ; ESCch # 1          ; &DC
                        ;
  = &01,&D0,&E0,&F0     ; IPbufferCh # 4     ; &DD,&DE,&DF,&E0
  = &01,&80,&90,&00     ; RedKeyCh   # 4     ; &E1,&E2,&E3,&E4
                        ;
  = &00                 ; ESCaction  # 1     ; &E5
  = &00                 ; ESCeffect  # 1     ; &E6
                        ;
  = &00                 ; u6522IRQ # 1       ; &E7
  = &00                 ; s6850IRQ # 1       ; &E8
  = &00                 ; s6522IRQ # 1       ; &E9
                        ;
  = &00                 ; TubeFlag # 1       ; &EA
                        ;
  = &00                 ; SpeechFlag # 1     ; &EB
                        ;
  = &00                 ; WrchDest # 1       ; &EC
  = &00                 ; CurEdit  # 1       ; &ED
                        ;

  = &30                 ; KeyBase            ; &EE
  = &01                 ; Shadow             ; &EF
  = &00                 ; Country            ; &F0
                        ;
  = &00                 ; UserFlag # 1       ; &F1
                        ;
  = &64                 ; SerULAreg # 1      ; &F2
                        ;
  = &05                 ; TimerState # 1     ; &F3
                        ;
  = &FF                 ; SoftKeyConsist # 1 ; &F4
                        ;
  = &01                 ; PrinterDrivType   # 1          ; &F5
  = &0A                 ; PrinterIgnore     # 1          ; &F6
                        ;
  = &01,&00,&00         ; BREAKvector # 3    ; &F7,&F8,&F9
                        ;
  = &00                 ; DRIVER             ; &FA
  = &00                 ; DISPLAY            ; &FB
                        ;
  = &FF                 ; LangROM # 1        ; &FC
                        ;
  = &01                 ; LastBREAK # 1      ; &FD
                        ;
  = &0F                 ; KeyOpt # 1         ; &FE
                        ;
  = &08                 ; StartOptions # 1   ; &FF
                        ;
                        ;
ByteVarInitTableEnd

ByteVarInitTableSize * ByteVarInitTableEnd - ByteVarInitTable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        LTORG

oldirqowner & IRQ

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       TranslateMonitorLeadType - Determine monitor type and default mode + sync from monitor lead type
;
; in:   Monitor lead type in variable MonitorLeadType (surprisingly!)
;
; out:  r3 = default mode to use
;       r4 = default monitortype to use
;       r5 = default sync to use
;

TranslateMonitorLeadType Entry "r0-r2"
      [ ZeroPage = 0
        MOV     r1, #Service_MonitorLeadTranslation
        LDRB    r2, [r1, #MonitorLeadType-Service_MonitorLeadTranslation]
      |
        LDR     r2, =ZeroPage
        MOV     r1, #Service_MonitorLeadTranslation
        LDRB    r2, [r2, #MonitorLeadType]
      ]
        SWI     XOS_ServiceCall
        TEQ     r1, #0                          ; if service claimed, then exit with these numbers
        EXIT    EQ

        ADR     r0, MonitorLeadList
10
        LDR     r14, [r0], #4
        EOR     r1, r2, r14, LSR #24            ; differences
        EOR     r14, r14, #&FF000000            ; make don't cares into zero
        TST     r14, #&C0000000
        BICEQ   r1, r1, #&C0                    ; knock out difference pairs if don't care
        TST     r14, #&30000000
        BICEQ   r1, r1, #&30
        TST     r14, #&0C000000
        BICEQ   r1, r1, #&0C
        TST     r14, #&03000000
        BICEQ   r1, r1, #&03
        TEQ     r1, #0                          ; if still have differences, then loop
        BNE     %BT10

        MOV     r0, #&FF
        AND     r3, r0, r14                     ; mode in bits 0..7
        AND     r4, r0, r14, LSR #8             ; monitortype in bits 8..15
        AND     r5, r0, r14, LSR #16            ; sync in bits 16..23

        ; Give the current GraphicsV driver a chance to specify a better mode
        ; than whatever we've picked here
        Push    "r4"
        MOV     r0, r3
        VDWS    r4
        LDR     r4, [r4, #CurrentGraphicsVDriver]
        MOV     r4, r4, LSL #24
        ORR     r4, r4, #GraphicsV_StartupMode
        BL      CallGraphicsV
        Pull    "r4"
        MOV     r3, r0
        EXIT

        MACRO
        MonitorLeadItem $lead, $mode, $monitortype, $sync
        ASSERT $lead < 256
        ASSERT $mode < 256
        ASSERT $monitortype < 256
        ASSERT $sync < 256
        DCD     (($lead):SHL:24):OR:(($sync):SHL:16):OR:(($monitortype):SHL:8):OR:($mode)
        MEND


MonitorLeadList
        ; KJB - changed default modes to 256 colours
        MonitorLeadItem 4_3330,  28, 3, 0                       ; VGA-capable monitors
        MonitorLeadItem 4_3111,  28, 5, 0                       ; Nothing - try LCD (fudge fudge)
        MonitorLeadItem 4_3333,  15, 0, 1                       ; Others - assume TV standard


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ReadUniqueID - Read unique machine ID
;

ReadUniqueID
        Entry   "r0-r3,r9,r12"
        AddressHAL
        ; Check for extended ID first
        MOV     r0, #0
        CallHAL HAL_ExtMachineID
        CMP     r0, #0
        BEQ     %FT10
        MOV     r2, sp
        SUB     r0, r2, r0
        BIC     r0, r0, #3
        MOV     sp, r0
        Push    "r0,r2" ; Remember old SP, buffer pointer
        CallHAL HAL_ExtMachineID
        Pull    "r1"
        MOV     r2, #0
        MOV     r3, #0
05
        ; Construct the 7 byte machine ID using this simple algorithm:
        ; EOR each extended ID byte with the low byte of the 7 byte ID,
        ; then rotate left 7 bits
        LDRB    r12, [r1], #1
        EOR     r2, r2, r12
        AND     r12, r3, #&fe0000
        MOV     r3, r3, LSL #7
        ORR     r3, r3, r2, LSR #25
        MOV     r2, r2, LSL #7
        ORR     r2, r2, r12, LSR #17
        SUBS    r0, r0, #1
        BNE     %BT05
        LDR     sp, [sp] ; Restore SP
      [ ZeroPage <> 0
        LDR     r0, =ZeroPage
      ]
        STR     r2, [r0, #RawMachineID+0]
        STR     r3, [r0, #RawMachineID+4]
        ; Abuse CheckCRC to calculate CRC byte
        BL      CheckCRC
        LDR     r0, =ZeroPage
        STRB    r2, [r0, #RawMachineID+7]
        EXIT
        
10
        CallHAL HAL_MachineID
        LDR     r3, =ZeroPage
        STR     r0, [r3, #RawMachineID+0]
        STR     r1, [r3, #RawMachineID+4]
        BL      CheckCRC
        BVS     IDError
        EXIT

IDError
        DebugTX "Machine ID duff,zero substituted"
        MOV     r0, #0
      [ ZeroPage = 0
        STR     r0, [r0, #RawMachineID+0]       ; indicate no ID by putting zero here
        STR     r0, [r0, #RawMachineID+4]
      |
        LDR     lr, =ZeroPage
        STR     r0, [lr, #RawMachineID+0]       ; indicate no ID by putting zero here
        STR     r0, [lr, #RawMachineID+4]
      ]
        EXIT

CheckCRC ROUT
        ; Note: artificial ID generator relies on the required CRC being returned in R2!
        LDR     r1, =ZeroPage+RawMachineID      ; pointer to current byte
        MOV     r2, #0
        MOV     r3, #7                          ; number of bytes to do
10
        LDRB    r4, [r1], #1
        EOR     r2, r2, r4
        MOV     r4, #8                          ; number of bits to do
20
        MOVS    r2, r2, LSR #1                  ; shift bit out into carry
        EORCS   r2, r2, #&8C                    ; feedback carry into other bits
        SUBS    r4, r4, #1                      ; one less bit to do
        BNE     %BT20                           ; loop until done whole byte
        SUBS    r3, r3, #1                      ; one less byte to do
        BNE     %BT10                           ; loop until done all 7 bytes
        LDRB    r4, [r1], #1                    ; read CRC
        CMP     r4, r2                          ; if correct
        MOVEQ   pc, lr                          ; exit (V clear)
        RETURNVS                                ; else exit indicating error

        LTORG

        END
@


4.25
log
@Fix for num lock oddity at power on when configured off
The default OS_Byte value enabled num lock, but this was passed to the keyboard *before* a decision to wipe the CMOS (and hence potentially override it) was made.
This left the LED on until a key was pressed, regardless of the configured state.
Change the default OS_Byte value to be off so there's only one transition (off->on, or off->off), and refresh the keyboard after the validity of CMOS has been made.
Ref: https://www.riscosopen.org/forum/forums/4/topics/10400

Version 5.99. Tagged as 'Kernel-5_99'
@
text
@d27 2
a28 5
        LDRB    R1, LastBREAK           ; 0 => soft, 1 => power-on, 2 => hard
        CMP     R1, #PowerOnReset
        ASSERT  SoftReset < PowerOnReset
        ASSERT  PowerOnReset < ControlReset 
        ADRCC   R2, SoftResetVars
d30 1
a30 1
        ADRHI   R2, HardResetVars
d32 5
a36 7
        LDRCCB  R3, NoIgnore            ; preserve NoIgnore over soft reset
        MOVCS   R3, #0                  ; if hard or power-on reset, zero it
        STRCS   R3, TimerAlpha +0       ; and zero both copies of TIME
        STRCS   R3, TimerAlpha +4
        STRCS   R3, TimerBeta +0
        STRCS   R3, TimerBeta +4
        MOV     R4, R1                  ; preserve LastBREAK
d52 1
a52 1
        STRB    R3, NoIgnore            ; put NoIgnore back
a313 3
        LDRB    R0, LastBREAK           ; get reset type
        TEQ     R0, #SoftReset
        BEQ     %FT10                   ; [soft reset, skip]
a326 1
10
@


4.24
log
@Recover gracefully from a completely blank set of CMOS
Newly born boards have all 0xFF's in their CMOS (EEPROM), but the new order of keyboard scan did
  Init -> Scan keyboard -> Check (or wipe) CMOS
and would therefore leave 0xFF's in a select few kernel workspace areas and OS_Byte values.
Defer the init which reads CMOS until after the check/wipe step. Only the screen area size is now done early, but MassageScreenSize clamps that properly anyway.

Arthur3.s: Relocate stranded function SetupPrinterBuffer to osinit.
PMF/key.s: Drop support for SoftReset.
PMF/osinit.s: Stuff in hardcoded defaults at early init. Retrieve the proper ones later. Take ownership of SystemSprite/RamFS/Font Manager dynamic areas (deferrable).
vdudriver.s: Use symbolic name.
NewReset.s: Defer SystemSprite/RamFS/Font Manager area creation, MouseInit, Read(Hard)CMOSDefaults until later.
hdr/Options: Delete unused IgnoreVRAM. Remove MaxRAMFS_Size now PMPs make it not useful. Shuffle ARM6Support/XScaleMiniCache/XScaleJTAGDebug to be adjacent to their definitions.

Tested by filling first 256 bytes with 0xFF and powering up. Reset now completes, OS_Byte variables look sensible.

Version 5.95. Tagged as 'Kernel-5_95'
@
text
@d278 2
d429 1
a429 1
  = &30                 ; KeyBdStatus  # 1   ; &CA
@


4.23
log
@Change module initialisation to be a two pass scheme
Detail:
  To make it easier to support arbitrary complexity keyboard controllers (eg. USB via DWCDriver on the Pi) have the kernel do the early keyboard recovery key press detection instead of the HAL.
  During the first pass those modules used for reading the keyboard are started, ignoring the CMOS frugal bits.
  The keyboard is then scanned for 3s, during which time the RAM is cleared (unless the HAL indicated it has already been done).
  During the second pass the remaining modules are started respecting the CMOS frugal bits. Any which were already started in the first pass are inserted into the new chain, so the keyboard is reset once and only once.

  Boot times, with a 300cs key scan time in NewReset.
  Risc PC with 160MB RAM (128+32+0).
  Times from turning on power to initial "beep", using a stopwatch.
                RISC OS 3.70 RISC OS 5.22 This OS
  ARM610        12.5         10.4         10.3
  ARM710        11.8         10.2         9.7
  StrongARM 233 11.1         9.5          8.4

  In NewReset.s:
  Remove old KbdScan code (leave Reset_IRQ_Handler for IIC only)
  If HAL_KbdScanDependencies returns a null string then present KbdDone flag and skip to full init.
  A few vestiges of soft resets removed.
  Do RAM clear when waiting for INKEY (being careful not to trash the running modules...).
  Clearing just the freepool on a 2GB Titanium cleared 7EFD6 pages (99.2%).

  In ModHand.s:
  2nd pass need to sneaky renumber the nodes (so *ROMModules is in the right order, frugal bits line up) without resetting the chain

  In HAL.s:
  Change ClearPhysRAM to ClearWkspRAM, such that it only clears the kernel workspace rather than all RAM. The bulk of the RAM is cleared during the keyboard scan by new function ClearFreePoolSection.
  Add a variant of Init_MapInRAM which clears the mapped in RAM too (as these very early claims will not be in the free pool when the RAM is cleared later).
  Remove HAL keyboard scan setup & IRQ handler.
  Fix bug in HALDebugHexTX2, the input value needs pre-shifting by 16b before continuing.

  In GetAll.s, PMF/osbyte.s:
  Use Hdr:Countries and Hdr:OsBytes for constants.

  In PMF/key.s, PMF/osinit.s:
  Relocate the key post init from PostInit to KeyPostInit.
  Changed PostInit to not tail call KeyPostInit so they can be called independently.

  In hdr/KernelWs:
  Improve comments, add InitWsStart label to refer to.

  In hdr/HALEntries:
  Add HAL_KbdScanDependencies.
  Delete KbdFlag exports.
  Took the opportunity to reorder some of the higher numbered HAL entries and re-grouping, specifically (112,120) (84,106,108,117).
Admin:
  Tested on an ARM6/ARM7/SA Risc PC, BeagleBoard xM, Iyonix, Pandaboard ES, Wandboard Quad, IPEGv5, Titanium, Pi 2 and 3.
  Requires corresponding HAL change.
  Submission for USB bounty.

Version 5.89. Tagged as 'Kernel-5_89'
@
text
@d28 3
a30 1
        CMP     R1, #1
d43 5
d76 5
d100 3
a102 3
        LDRB    R0, LastBREAK
        TEQ     R0, #0
        BEQ     %FT20
a103 1
        BL      ReadMachineType
a104 3
        BL      ReadHardCMOSDefaults
20
        BL      ReadCMOSDefaults
d132 72
d205 1
a205 1
;       NB must be called in supervisor mode
d256 1
a256 1
;       NB must be called in supervisor mode
d318 1
a318 1
        TEQ     R0, #0
d338 23
a514 12
;       ReadMachineType - Determine machine type and store it in IOSystemType
;

ReadMachineType Entry "r0-r12"
        LDR     r1, =ZeroPage
        MOV     r0, #4_3330                             ; Assume VGA during osinit
        STRB    r0, [r1, #MonitorLeadType]

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
@


4.22
log
@Remove a dead function
CheckBits is a hangover from when the kernel used to read the monitor ID lines on a Risc PC, no longer called with a HAL.
@
text
@d243 1
a243 1
;
a252 7

        MOV     R0, #1                  ; indicate keyboard UK
        MOV     R1, #101                ; indicate alphabet Latin1
        STRB    R0, Keyboard
        STRB    R1, Alphabet
        STRB    R1, KeyAlphabet         ; alphabet corresponding to keyboard

d254 1
a254 2
        Pull    R14
        B       KeyPostInit
@


4.22.2.1
log
@Merge latest changes from main branch

Version 5.89, 4.129.2.6. Tagged as 'Kernel-5_89-4_129_2_6'
@
text
@d243 1
a243 1

d253 7
d261 2
a262 1
        Pull    PC
@


4.22.2.2
log
@Merge in latest changes from main branch

Version 5.97, 4.129.2.7. Tagged as 'Kernel-5_97-4_129_2_7'
@
text
@d28 1
a28 3
        CMP     R1, #PowerOnReset
        ASSERT  SoftReset < PowerOnReset
        ASSERT  PowerOnReset < ControlReset 
a40 5
        MOV     R1, #32                 ; default FX11 and FX12
        STRB    R1, KeyRepDelay
        MOV     R1, #8
        STRB    R1, KeyRepRate

a68 5
; initialise SpriteSize to zero (fixes bug MED-00811)

        LDR     R2, =ZeroPage
        STR     R1, [R2, #SpriteSize]

d88 3
a90 3
        LDR     R1, =ZeroPage
        MOV     R0, #4_3330             ; Assume VGA during osinit
        STRB    R0, [R1, #MonitorLeadType]
d92 1
d94 3
a123 72
;       InitHostedDAs - Set up the dynamic areas that we kindly host on
;       behalf of other parts of the OS (SpriteUtils, RamFS, Font Manager)

InitHostedDAs
        Push    "r0-r12, lr"

        ; SpriteArea
        MOV     r0, #SpriteSizeCMOS     ; find out how much spritesize configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size

        MOV     r1, #ChangeDyn_SpriteArea ; Area number
        MOV     r3, #-1                 ; Base address dynamic
        MOV     r4, #AreaFlags_Sprites  ; Area flags
        MOV     r5, #16*1024*1024       ; Maximum size (changed from -1, address space preservation)
        ADRL    r6, DynAreaHandler_Sprites ; Pointer to handler
        MOV     r7, #-1                 ; Use base address as workspace ptr
        ADRL    r8, AreaName_SpriteArea ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!

        ; RAMDisc
        MOV     r1, #ChangeDyn_RamFS    ; Area number
        MOV     r3, #-1                 ; Base address dynamic
        ARM_read_ID r4
        AND     r4, r4, #&F000
        CMP     r4, #&A000
        MOVEQ   r4, #AreaFlags_RAMDisc_SA ; Area flags, if StrongARM  (introduced for Ursula)
        MOVNE   r4, #AreaFlags_RAMDisc  ; Area flags
      [ PMPRAMFS
        MOV     r5, #PMPRAMFS_Size*4096
        ORR     r4, r4, #DynAreaFlags_PMP
        MOV     r2, #0
        ORR     r4, r4, #DynAreaFlags_NeedsSpecificPages
        MOV     r9, #0
      |
        MOV     r0, #RAMDiscCMOS        ; find out how much RAM disc configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size
        MOV     r5, #128*1024*1024      ; A trade off between nice big disc and complete waste of address space
      ]
        ADRL    r6, DynAreaHandler_RAMDisc ; Pointer to handler
        MOV     r7, #-1                 ; Use base address as workspace ptr
        ADRL    r8, AreaName_RAMDisc    ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!
      [ PMPRAMFS
        ; Currently, physical memory pools must be created with 0 size, then resized afterwards
        MOV     r0, #RAMDiscCMOS        ; find out how much RAM disc configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size
        MOVS    r1, r2
        MOV     r0, #ChangeDyn_RamFS
        SWINE   XOS_ChangeDynamicArea
      ]

        ; FontArea
        MOV     r0, #FontCMOS           ; find out how much font cache configured
        BL      GetConfiguredSize       ; in: r0 = CMOS address, out: r2 = size

        MOV     r1, #ChangeDyn_FontArea ; Area number
        MOV     r3, #-1                 ; Base address dynamic
        MOV     r4, #AreaFlags_FontArea ; Area flags
        MOV     r5, #32*1024*1024       ; Maximum size changed from -1 for Ursula (limit address
                                        ; space usage on large memory machines)
        ADRL    r6, DynAreaHandler_FontArea ; Pointer to handler
        MOV     r7, #-1                 ; Use base address as workspace ptr
        ADRL    r8, AreaName_FontArea   ; Title string - node will have to be reallocated
                                        ; after module init, to internationalise it
        BL      DynArea_Create          ; ignore any error, we're stuffed if we get one!

        Pull    "r0-r12, pc"

; *****************************************************************************
;
d125 1
a125 1
;       On entry WsPtr -> BYTEWS
d176 1
a176 1
;       On entry WsPtr -> BYTEWS
d238 1
a238 1
        TEQ     R0, #SoftReset
a257 23
;       SetUpPrinterBuffer - create the printer buffer

SetUpPrinterBuffer Entry "r1-r3"
        MOV     r0, #PrinterBufferCMOS
        BL      Read
        LDR     r2, =ZeroPage
        LDR     r2, [r2, #Page_Size]
        MULS    r3, r2, r0
        BEQ     %FT10                           ; if zero, then use default area & size

        BL      ClaimSysHeapNode                ; else claim space from system heap
        BVC     %FT20                           ; if no error then OK, else use default
10
        LDR     r2, =PrintBuff                  ; use default buffer
        MOV     r3, #PrintBuffSize
20
        LDR     r0, =ZeroPage
        STR     r2, [r0, #PrinterBufferAddr]
        STR     r3, [r0, #PrinterBufferSize]
        EXIT

; *****************************************************************************
;
d412 12
@


4.22.2.3
log
@Merge in latest changes from main branch

Version 6.05, 4.129.2.8. Tagged as 'Kernel-6_05-4_129_2_8'
@
text
@a277 2
        LDR     R11, =ZeroPage+KeyWorkSpace
        BL      UpdateLEDs
d427 1
a427 1
  = &34                 ; KeyBdStatus  # 1   ; &CA
@


4.22.2.4
log
@Merge latest changes from HEAD

Version 6.08, 4.129.2.9. Tagged as 'Kernel-6_08-4_129_2_9'
@
text
@d27 5
a31 2
        LDRB    R4, LastBREAK           ; 1 => power-on, 2 => hard
        CMP     R4, #PowerOnReset
d33 1
a33 1
        ADRNE   R2, HardResetVars
d35 7
a41 5
        MOV     R3, #0
        STR     R3, TimerAlpha +0       ; zero both copies of TIME
        STR     R3, TimerAlpha +4
        STR     R3, TimerBeta +0
        STR     R3, TimerBeta +4
d57 1
a57 1
        STRB    R3, NoIgnore            ; zero NoIgnore
d319 3
d335 1
@


4.21
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@a429 19
CheckBits ROUT
        AND     r8, r10, r5, LSR #12            ; bits that were H-L-L
        BIC     r8, r8, r6                      ; bits that are H-L-L-L
        ORR     r5, r5, r8, LSL #16             ; OR into bits that could be hsync
        ORR     r8, r5, r5, LSR #4
        AND     r8, r6, r8, LSR #8              ; bits that just went H-L-H or H-L-L-H
        AND     r8, r8, r5, LSR #16             ; bits that just went H-L-H or H-L-L-H and could have been hsync
        ORR     r5, r5, r8, LSL #20             ; they're definitely random now
        BIC     r5, r5, r8, LSL #16             ; and they're definitely not hsync now
        AND     r8, r5, #&FF :SHL: 4            ; get H bits, and H-L bits
        BIC     r8, r8, r6, LSL #4              ; knock out bits that were H and are now H
        BIC     r8, r8, r6, LSL #8              ; knock out bits that were H-L and are now H
        BIC     r5, r5, #&FF :SHL: 8            ; knock out all H-L and H-L-L bits
        ORR     r5, r5, r8, LSL #4              ; put in new H-L and H-L-L bits
        BIC     r5, r5, #&F :SHL: 4             ; knock out old H bits
        ORR     r5, r5, r6, LSL #4              ; put in new H bits
        BIC     r5, r5, r5, LSR #20             ; knock out H bits if we know it's random
        MOV     pc, lr

@


4.20
log
@Delete STB code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a desktop build):
  * STB
  * RO371Timings
  * NormalSpeedROMS
  * AutoSpeedROMS
  * RISCPCBurstMode
  * InterlacedPointer
  * ParallelFlashUpgrade (and s/FlashROM file)
  * Embedded_UI
  Some of the deleted code might be worth revisiting in future:
  * OS_ReadSysInfo 4 support for storing the MAC in alternate CMOS locations (including 2nd copy for error checking) or fetching via Service_MachineAddress
  * Mouse handling changes, possibly aimed at hiding the mouse pointer if a mouse isn't connected
  * More strict CMOS validation in s/NewReset
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.50. Tagged as 'Kernel-5_50'
@
text
@a207 1
 [ ModeSelectors
a210 1
 ]
a240 1
 [ StorkPowerSave
a252 5
 |
        LDR     r0, =ZeroPage           ; allow SWI Portable_Speed to be issued
        ASSERT  (ZeroPage :AND: 255) = 0
        STRB    r0, [r0, #PortableFlag]
 ]
a253 1
        [ BleedinDaveBell
a255 4
        |
        MOV     R0, #2                  ; indicate keyboard Master
        MOV     R1, #100                ; indicate alphabet Bfont
        ]
@


4.19
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a530 20
  [ STB
   [ IOMD_C_MonitorType = 0                                     ; no auto-detect bit
     [ IOMD_C_PALNTSCType = 0                                   ; no PAL/NTSC bits:
        MonitorLeadItem 4_3333,  12, 0, 1                       ; PAL TV assumed
     | ; IOMD_C_PALNTSCType = 0
        MonitorLeadItem 4_0333,  12, 0, 1                       ; PAL TV
        MonitorLeadItem 4_1333,  46, 8, 1                       ; NTSC TV
     ] ; IOMD_C_PALNTSCType = 0
   |
     [ :LNOT: ChrontelSupport
       [ IOMD_C_PALNTSCType = 0                                 ; no PAL/NTSC bits:
        MonitorLeadItem 4_3331,  12, 0, 1                       ; PAL TV assumed
       | ; IOMD_C_PALNTSCType = 0                               ; wealth of bits:
        MonitorLeadItem 4_0331,  12, 0, 1                       ; PAL TV
        MonitorLeadItem 4_1331,  46, 8, 1                       ; NTSC TV
       ] ; IOMD_C_PALNTSCType = 0
     ] ; :LNOT: ChrontelSupport
   ] ; IOMD_C_MonitorType = 0
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
  | ; STB
a534 1
  ]; STB
@


4.18
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a87 16
  [ HAL
; This has already been done much earlier in initialisation
  |
; set up IOC timer 0 before we read from CMOS (cos it uses timer for delays)

        MOV     R1, #IOC
        LDR     R0, =20000-1    ; R0 = Timer delay (units of 0.5 microsecond)
                                ; 20000*0.5E-6 = 0.01 Seconds 100Hz
                                ; TMD 21-May-93: "-1" correction applied

        STRB    R0, [R1, #Timer0LL]     ; Set up the delay
        MOV     R0, R0, LSR #8
        STRB    R0, [R1, #Timer0LH]
        STRB    R0, [R1, #Timer0GO]     ; and start the ticks
   ]

a97 14
 [ :LNOT: HAL
 [ StorkPowerSave
        BL      PowerHardware           ;On Stork, ensure Combo chip, Winnie, Floppy etc are powered
 ]
 [ Keyboard_Type <> "RCMM"              ; On RCMM machines, this is done in SetUpKbd.
        [ STB
        BL      ConfigureCombo
        |
        BL      Configure37C665         ;RiscPC, Kryten and Stork use only SMC 37C665
        ]
 ] ; <> "RCMM"
 ]

 [ HAL
a106 14
 |
        MOV     R1, #IOC

        MOV     r0, #timer0_bit :OR: vsync_bit
        STRB    R0, [R1, #IOCIRQCLRA]   ; clear pending tim0, vsync irqs (+ pack irq if appropriate)
        LDRB    R0, [R1, #IOCIRQMSKA]
        ORR     R0, R0, #timer0_bit :OR: vsync_bit
        STRB    R0, [R1, #IOCIRQMSKA]   ; Enable timer 0 + vsync irqs
 ]

 [ :LNOT: HAL
        MOV     R0, #0
        STRB    R0, [R1, #IOMD_ATODICR] ; power down the A to D convertor
 ]
a296 31
        [ :LNOT: STB :LAND: :LNOT: HAL
; *****************************************************************************
;
;       UpdateMonitorTypeLatch - update monitor type latch and soft copy
;
;       Returns the result in R4

UpdateMonitorTypeLatch
        Push    "R2, R3, R14"
        MRS     R14, CPSR
        ORR     R2, R14, #I32_bit
        MSR     CPSR_c, R2              ; disable IRQ

        LDR     R2, =ZeroPage
        LDRB    R3, [R2, #CLine_Softcopy]
        MOV     R3, #1                  ;Set our bit only
        STRB    R3, [R2, #CLine_Softcopy]

        MOV     R2, #IOMD_Base
        STRB    R3, [R2, #IOMD_CLINES]  ;Write the new reg out
        LDRB    R3, [R2, #IOMD_CLINES]  ;Read it back

        AND     R4, R3, #1              ;Clear all but our bit into R4

        MSR     CPSR_cf, R14            ;Re-enable IRQ, restore flags
        Pull    "R2, R3, PC"


; *****************************************************************************
        ]

a436 1
  [ HAL
a441 221
  |
        MOV     r12, #IOMD_Base
        LDRB    r0, [r12, #IOMD_ID0]
        LDRB    r11, [r12, #IOMD_ID1]
        ORR     r0, r0, r11, LSL #8
        LDR     r11, =IOMD_Original
        TEQ     r0, r11
        MOVEQ   r11, #0                                 ; assume Medusa
        MOVNE   r11, #IOST_7500                         ; else assume Morris
        TEQ     r11, #IOST_7500                         ; and set EQ if Morris to do conditional stuff below
;
; On Kryten,    Morris pin Event2 is tied low so bit Nevent2 is a ONE
; On Stork,     Morris pin Event2 is tied high so bit Nevent2 is a ZERO
; On STB/NCD,   Morris pin Event2 is tied high so bit Nevent2 is a ZERO, but we don't have a LCD
;               controller or battery manager so we'll not set IOST_BATMAN
;
        LDREQB  r0, [r12, #IOMD_IRQSTD]         ;EQ, Morris
   [ BatManSupport
        TSTEQ   r0, #IOMD_Nevent2_bit
        ORREQ   r11, r11, #IOST_BATMAN          ;EQ, Stork ie Morris & BATMAN
   ]
        ORR     r0, r11, #IOST_IOEB             ; pretend we've got IOEB
;
; r11 holds  0                        for  IOMD   (Risc PC)
;        or  IOST_7500                for  Morris (Kryten, Falcon, Omega)
;        or  IOST_7500 + IOST_BATMAN  for  Morris (Stork)

        MOV     r1, #0                          ; normal Hsync and address pointer
        LDRB    r3, [r1, #IOSystemType]
        AND     r3, r3, #IOST_COMBOMASK         ; preserve combo type which may already
        ORR     r3, r3, r0                      ; be in there on RCMM machines
        STRB    r3, [r1, #IOSystemType]

; now read monitor lead type.

        TEQ     r0, #0                          ; no IOEB
        MOVEQ   r2, #&FF                        ; then return all ones for monitor lead type
        BEQ     %FT90

      [ MPEGPoduleNTSCNotPALMask <> 0
        !       1, "Sorry, I don't do MPEGPoduleNTSCNotPALMask any more"
      ]

        [ STB
        LDR     r0, =VIDC                       ; on VIDC20 we invert HSYNC by writing to External Register

    [ IOMD_C_MonitorType <> 0
        ASSERT  (IOMD_C_MonitorType = (1<<0))   ; this code only understands auto-detect in bit 0
    ]
        TST     R11, #IOST_7500
        LDREQ   r3, =IOMD_MonitorType           ; Not Morris, address is in old place
        LDRNE   r3, =(IOMD_Base + IOMD_CLINES)

        LDR     r1, =VIDCExternal+Ext_InvertCompVSYNC+Ext_DACsOn+Ext_ERegExt ; normal HSYNC value
        STR     r1, [r0]
        ORR     r2, r1, #Ext_InvertHSYNC        ; value for inverted HSYNC

        LDRB    r4, [r3]                        ; base value
  [ MorrisSupport
    [ IOMD_C_PALNTSCType <> 0
        ASSERT  (IOMD_C_PALNTSCType = (1<<4))   ; this code only understands PAL/NTSC auto-detect in bit 4
        AND     r4, r4, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
        ORR     r4, r4, r4, LSR #1              ; Shift PAL/NTSC bit into bit 3
        AND     r4, r4, #&0F                    ; only use bits 0..3
    |
        AND     r4, r4, #IOMD_C_MonitorType     ; only one bit
    ]
  |
        AND     r4, r4, #&0F                    ; only use bits 0..3
  ]
        MOV     r5, #0                          ; bits 0..3   = bits which have ever changed
                                                ; bits 4..7   = bits whose deinverted value was high last time
                                                ; bits 8..11  = bits whose deinverted value just went high-low
                                                ; bits 12..15 = bits whose deinverted value just went high-low-low
                                                ; bits 16..19 = bits which could be hsync
                                                ;  ie after every high-low there was low-low (after deinversion)
                                                ; bits 20..23 = bits which are definitely random
        MOV     r10, #&0F                       ; used inside CheckBits
        MOV     r12, #256                       ; number of iterations
20
        STR     r2, [r0]
        LDRB    r6, [r3]                        ; read value with inverted sync
        STR     r1, [r0]
        LDRB    r7, [r3]                        ; read value with normal sync

  [ MorrisSupport
    [ IOMD_C_PALNTSCType <> 0
        AND     r6, r6, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
        ORR     r6, r6, r6, LSR #1              ; Shift PAL/NTSC bit into bit 3
        AND     r6, r6, #&0F                    ; only use bits 0..3
        AND     r7, r7, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
        ORR     r7, r7, r7, LSR #1              ; Shift PAL/NTSC bit into bit 3
        AND     r7, r7, #&0F                    ; only use bits 0..3
    |
        AND     r6, r6, #IOMD_C_MonitorType     ; only one bit
        AND     r7, r7, #IOMD_C_MonitorType
    ]
  |
        AND     r6, r6, #&0F                    ; only use bits 0..3
        AND     r7, r7, #&0F
  ]
        EOR     r8, r6, r4                      ; bits which have changed from steady value to inverted one
        ORR     r5, r5, r8                      ; OR into mask of bits which have ever changed
        EOR     r8, r7, r4                      ; bits which have changed from steady value to normal one
        ORR     r5, r5, r8                      ; OR into mask of bits which have ever changed
        EOR     r6, r6, #&0F                    ; deinvert inverted value
        BL      CheckBits                       ; call check routine with first value
        MOV     r6, r7
        BL      CheckBits                       ; call check routine with second value
        SUBS    r12, r12, #1
        BNE     %BT20
        | ; STB

        LDR     r0, =VIDC                       ; on VIDC20 we invert HSYNC by writing to External Register
        LDR     r3, =IOMD_MonitorType

        LDR     r1, =VIDCExternal+Ext_InvertCompVSYNC+Ext_DACsOn+Ext_ERegExt ; normal HSYNC value
        STR     r1, [r0]
        ORR     r2, r1, #Ext_InvertHSYNC        ; value for inverted HSYNC

 [ MorrisSupport
        TST     R11, #IOST_7500
        BLNE    UpdateMonitorTypeLatch          ;Result back in R4
        LDREQB  r4, [r3]
 |
        LDRB    r4, [r3]                        ; base value
 ]
        AND     r4, r4, #&0F                    ; only use bits 0..3
        MOV     r5, #0                          ; bits 0..3   = bits which have ever changed
                                                ; bits 4..7   = bits whose deinverted value was high last time
                                                ; bits 8..11  = bits whose deinverted value just went high-low
                                                ; bits 12..15 = bits whose deinverted value just went high-low-low
                                                ; bits 16..19 = bits which could be hsync
                                                ;  ie after every high-low there was low-low (after deinversion)
                                                ; bits 20..23 = bits which are definitely random
        MOV     r10, #&0F                       ; used inside CheckBits
        MOV     r12, #256                       ; number of iterations
20
        STR     r2, [r0]

 [ MorrisSupport
        TST     R11, #IOST_7500
        BLNE    UpdateMonitorTypeLatch          ;Result back in R4
        MOVNE   r6, r4
        LDREQB  r6, [r3]
 |
        LDRB    r6, [r3]                        ; read value with inverted sync
 ]

        STR     r1, [r0]

 [ MorrisSupport
        TST     R11, #IOST_7500
        BLNE    UpdateMonitorTypeLatch          ;Result back in R4
        MOVNE   r7,r4
        LDREQB  r7,[r3]
 |
        LDRB    r7, [r3]                        ; read value with normal sync
 ]
        AND     r6, r6, #&0F
        AND     r7, r7, #&0F
        EOR     r8, r6, r4                      ; bits which have changed from steady value to inverted one
        ORR     r5, r5, r8                      ; OR into mask of bits which have ever changed
        EOR     r8, r7, r4                      ; bits which have changed from steady value to normal one
        ORR     r5, r5, r8                      ; OR into mask of bits which have ever changed
        EOR     r6, r6, #&0F                    ; deinvert inverted value
        BL      CheckBits                       ; call check routine with first value
        MOV     r6, r7
        BL      CheckBits                       ; call check routine with second value
        SUBS    r12, r12, #1
        BNE     %BT20



        ] ; STB

; now process result

        LDR     r1, =VIDCExternal+Ext_InvertCompVSYNC+Ext_InvertCompHSYNC+Ext_DACsOn+Ext_ERegExt        ; put back default value
        STR     r1, [r0]

        BIC     r4, r4, r5                      ; don't put port value in for bits that have changed
        BIC     r5, r5, r5, LSR #16             ; make bits 0..3 of r5 indicate random bits

        ANDS    r2, r4, #1                      ; for each bit pair 00 => low, 01 => high, 10 => Hsync, 11 => random
        TST     r5, #1 :SHL: 16
        MOVNE   r2, #2 :SHL: 0
        TST     r5, #1
        MOVNE   r2, #3 :SHL: 0

        TST     r4, #2
        ORRNE   r2, r2, #1 :SHL: 2
        TST     r5, #2 :SHL: 16
        ORRNE   r2, r2, #2 :SHL: 2
        TST     r5, #2
        ORRNE   r2, r2, #3 :SHL: 2

        TST     r4, #4
        ORRNE   r2, r2, #1 :SHL: 4
        TST     r5, #4 :SHL: 16
        ORRNE   r2, r2, #2 :SHL: 4
        TST     r5, #4
        ORRNE   r2, r2, #3 :SHL: 4

        TST     r4, #8
        ORRNE   r2, r2, #1 :SHL: 6
        TST     r5, #8 :SHL: 16
        ORRNE   r2, r2, #2 :SHL: 6
        TST     r5, #8
        ORRNE   r2, r2, #3 :SHL: 6

  [ {FALSE}
        ASSERT  IOMD_MonitorIDMask = 1
        AND     r2, r2, #3                      ; only bit 0 of ID valid on IOMD-based systems
  ]

90
        MOV     r1, #0
        STRB    r2, [r1, #MonitorLeadType]
        EXIT
  ]
a557 309
 [ StorkPowerSave :LAND: :LNOT: HAL
;
; List of latch addresses and initial values.
;
PowerTab
        DCD     HWLatchPA, InitLatchPA
        DCD     HWLatchPB, InitLatchPB
        DCD     HWLatchMC, InitLatchMC
        DCD     HWLatchMA, InitLatchMA
        DCD     0

PowerHardware           ;On Stork, ensure Combo chip, Winnie, Floppy etc are powered
        Entry "r0,r1"

        MOV     r0, #0
        LDRB    lr, [r0, #IOSystemType]
        TST     lr, #IOST_BATMAN
        EXIT    EQ              ;EQ, not Stork, so hardware already powered
;
; On Stork.
;
; Now would be a good time to hit the power control latches
; to ensure everything is powered up.
;
        ADR     R14, PowerTab
05
        LDMIA   R14!, {R0, R1}
        TEQ     R0, #0
        STRNEB  R1, [R0]
        BNE     %BT05

10
        EXIT
 ]

 [ :LNOT: HAL
        [ STB
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ConfigureCombo - Configure SMC 665/669 or UMC 8669 if present
;

ComboBase       *       &03010000       ; Base address of combo chip = PC/AT I/O 000H

; SMC-type stuff
SMC_CSR         *       &03F0 * 4       ; Configuration Select Register (CSR)
SMC_CSRalt669   *       &0370 * 4       ; Alternative Configuration Select Register on SMC 669
                                        ; (this register is used if RTS2 is high on reset, which we don't have direct control of)
SMC_config      *       &55             ; value to write to enter configuration mode
SMC_endconfig   *       &AA             ; value to write to end configuration mode
SMC_IDreg       *       &0D             ; device ID register
SMC_data        *       &03F1 * 4       ; Configuration Access Port (data)
SMC_665         *       &65             ; 665 ID
SMC_669         *       &03             ; 669 ID

; UMC-type stuff
UMC_CSR         *       &0108 * 4       ; Configuration Select Register (CSR)
UMC_config      *       &AA             ; value to write to enter configuration mode
UMC_endconfig   *       &55             ; value to write to end configuration mode
UMC_data        *       &0109 * 4       ; Configuration Access Port (data)


;
; Configure SMC 37C665/669 or UMC8669 combo chip
;

ConfigureCombo Entry "r0-r2"
        WritePSRc SVC_mode + I_bit + F_bit, R0  ; Disable FIQ and IRQ
        LDR     r0, =ComboBase          ; R0->  Base address of combo chip

; See if we have a SMC665/669 and try to configure it
        ADD     r2, r0, #SMC_CSR        ; first try in normal place

        MOV     lr, #SMC_config
        STRB    lr, [r2]                ; Write &55 to CSR twice
        STRB    lr, [r2]                ; to enter configuration mode

        MOV     lr, #SMC_IDreg
        STRB    lr, [r2]
        LDRB    lr, [r2, #SMC_data-SMC_CSR]
        TEQ     lr, #SMC_665            ; 665 ?
        ADREQ   r1, ConfigSMC665Table
        BEQ     %FT20
        TEQ     lr, #SMC_669            ; 669 ?
        BEQ     %FT18

; Not a SMC chip at the normal place, but the SMC 669 may move its configuration registers
; to &370 if RTS2 was high on trailing edge of reset, so try there

        ADD     r2, r0, #SMC_CSRalt669

        MOV     lr, #SMC_config
        STRB    lr, [r2]                ; Write &55 to CSR twice
        STRB    lr, [r2]                ; to enter configuration mode

        MOV     lr, #SMC_IDreg
        STRB    lr, [r2]
        LDRB    lr, [r2, #SMC_data-SMC_CSR]
        TEQ     lr, #SMC_669            ; 669 ?
        BEQ     %FT18

; Not a SMC chip that we recognise, maybe we have a UMC8669
        ADR     r1, ConfigUMC8669Table
10
        LDRB    lr, [r1], #1            ; get "Index Entry Valid"
        STRB    lr, [r0, #UMC_CSR]
        TEQ     lr, #UMC_endconfig      ; end of table?
        BEQ     %FT12
        LDRB    lr, [r1], #1            ; get config index
        STRB    lr, [r0, #UMC_CSR]
        LDRB    lr, [r1], #1            ; get config data
        STRB    lr, [r0, #UMC_data]     ; and write it
        BNE     %BT10

12
; UMC8669 is not self-identifying, so see if what we wrote is still there
        MOV     lr, #UMC_config
        STRB    lr, [r0, #UMC_CSR]      ; Write &AA to enter config mode
        MOV     lr, #&C0
        STRB    lr, [r0, #UMC_CSR]      ; CR0
        LDRB    r2, [r0, #UMC_data]
        MOV     lr, #UMC_endconfig      ; maybe don't need to do this
        STRB    lr, [r0, #UMC_CSR]      ; exit config mode
        TEQ     r2, #2_00111110         ; Value for CR0 from ConfigUMC8669Table

        MOVEQ   r1, #IOST_UMC669
        MOVNE   r1, #0                  ; Don't know what this is, give up
        B       %FT30

;       SMC config loop
18
        ADR     r1, ConfigSMC669Table
20
        LDRB    lr, [r1], #1                    ; get config index
        STRB    lr, [r2]
        TEQ     lr, #SMC_endconfig              ; end of table?
        LDRNEB  lr, [r1], #1                    ; if not then get config data
        STRNEB  lr, [r2, #SMC_data-SMC_CSR]     ; and write it
        BNE     %BT20

        LDRB    r1, [r1]                        ; pull chip ID out of table

;       Record type of chip found
30
        MOV     r0, #0
        LDRB    lr, [r0, #IOSystemType]
        BIC     lr, lr, #IOST_COMBOMASK
        ORR     lr, lr, r1
        STRB    lr, [r0, #IOSystemType]

        WritePSRc SVC_mode + I_bit, lr  ; Restore IRQ/FIQ state
        EXIT


ConfigSMC665Table
 [ ComboIRQsActiveHigh
        DCB     &01, 2_10010111         ; Enable config, COM3@@338, COM4@@238, IRQs active hi,
                                        ; // is extended & powered @@278
 |
        DCB     &01, 2_10000111         ; Enable config, COM3@@338, COM4@@238, IRQs active low,
                                        ; // is extended & powered @@278
 ]
        DCB     &02, 2_11011100         ; COM2 powered & enabled @@2F8, COM1 powered & enabled @@3F8
                                        ; (default)
        DCB     &03, 2_01111000         ; floppy stuff (default)
        DCB     &04, 2_00000011         ; EPP v1.9, MIDI disabled, normal //floppy,
                                        ; // uses ECP & EPP modes
        DCB     &05, 0                  ; 4 drive support, don't swap drives, normal density,
                                        ; FDC burst mode, IDE@@1F0-7,3F6-7, FDC@@3F0-7 (default)
;       DCB     &06, &FF                ; floppy drive types (default)
;       DCB     &07, 0                  ; don't auto-powerdown anything (default)
;       DCB     &08, 0                  ; ADRA7:4 address decode (default)
;       DCB     &09, 0                  ; ADRA10:8 address decode (default)
;       DCB     &0A, 0                  ; FIFO threshold for ECP // = ??? (default)
;       DCB     &0B, 0                  ; floppy data rates (default)
;       DCB     &0C, 0                  ; UART2 & UART1 standard speed, UART2 standard mode,
                                        ; UART2 full duplex, XMIT active hi, RCV active hi (default)
        DCB     &00, 2_10111011         ; Valid config, OSC & BR on, FDC enabled & powered,
                                        ; IDE AT & enabled
        DCB     SMC_endconfig           ; Exit config mode
        DCB     IOST_37C665             ; Handy place to keep ID

ConfigSMC669Table
        DCB     &01, 2_10010100         ; Enable config, // is extended, // is  powered
        DCB     &02, 2_10001000         ; COM2 powered, COM1 powered (default)
        DCB     &03, 2_01110000         ; floppy stuff (bit 3 now reserved)
        DCB     &04, 2_00000011         ; IR rx&tx on COM2 rx & tx pins, EPP v1.9, MIDI disabled,
                                        ; normal //floppy, uses ECP & EPP modes
        DCB     &05, 0                  ; 4 drive support, don't swap drives, normal density,
                                        ; FDC burst mode (default)
;       DCB     &06, &FF                ; floppy drive types (default)
;       DCB     &07, 0                  ; don't auto-powerdown anything
;       DCB     &08, 0                  ; ADRA7:4 address decode (default)
;       DCB     &09, 0                  ; ADRx disabled, ADRA10:8 address decode (default)
;       DCB     &0A, 0                  ; FIFO threshold for ECP // = ??? (default)
;       DCB     &0B, 0                  ; floppy data rates (default)
;       DCB     &0C, 0                  ; UART2 & UART1 standard speed, UART2 standard mode,
                                        ; UART2 full duplex, XMIT active hi, RCV active hi (default)
 [ ComboClock14MHz
;       DCB     &10, 2_00000000         ; 14.318MHz input to PLL (default)
 |
        DCB     &10, 2_01000000         ; 24MHz input to PLL
 ]
;       DCB     &1E, &80                ; GAMECS disabled (default)
;       DCB     &1F, 0                  ; floppy drive types (default)
        DCB     &20, &FC                ; FDC@@3F0-7
        DCB     &21, &7C                ; IDE@@1F0-7
        DCB     &22, &FD                ; IDE Alternate Status Register @@3F6
        DCB     &23, &9E                ; //@@278
        DCB     &24, &FE                ; COM1@@3F8
        DCB     &25, &BE                ; COM2@@2F8
        DCB     &26, 0                  ; no FDC DMA, no // DMA (default)
        DCB     &27, 2_01100101         ; FDC uses IRQ_F, // uses IRQ_E
        DCB     &28, 2_01000011         ; UART1 uses IRQ_D, UART2 uses IRQ_C
        DCB     &29, 0                  ; IRQIN does not use any IRQ_x (default)
        DCB     &00, 2_10001010         ; Valid config, FDC powered, IDE enabled
        DCB     SMC_endconfig           ; Exit config mode
        DCB     IOST_37C669

ConfigUMC8669Table
        DCB     UMC_config, &C0, 2_00111110     ; IR full-duplex, games off, IDE on,
                                                ; // in EPP & ECP mode, UART2 on, UART1 on, FDC off
        DCB     UMC_config, &C1, 2_00101111     ; Direct access PnP register, Disable PnP,
                                                ; IDE@@1F0-7,3F6-7, //@@278, COM2@@2F8, COM1@@3F8,
                                                ; FDC@@3F0-7
        DCB     UMC_config, &C2, 2_10000001     ; Not supspended, IR unselected/disabled,
                                                ; don't swap floppy, IBM mode floppy,
                                                ; floppy is R/W (default)
        DCB     UMC_endconfig, 0                ; Exit config mode

        ALIGN
        |
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       Configure82C710 - Configure 82C710/82C711/SMC 665 if present
;

; 82C710 stuff

CnTbase         *       &03010000       ; Base address of 82C710 = PC/AT I/O 000H
CRI710          *       &0390
CRI710Off       *       CRI710*4        ; 82C710 Configuration Register Index port
CAP710Off       *       CRI710Off +4    ; 82C710 Configuration Access Port (data)
ConRegA710      *       &02FA*4
ConRegB710      *       &03FA*4

CRI711Off       *       &03F0*4         ; 82C711 Configuration Register Index port
CAP711Off       *       CRI711Off +4    ; 82C711 Configuration Access Port (data)


ConfigSMCTable
        DCB     &01, 2_10000111         ; Enable config read, IRQ active low, parallel powered/extended, default addr.
        DCB     &02, 2_00011100         ; 2nd serial port disabled, 1st enabled at &3F8
        DCB     &03, &78                ; extra stuff for SMC
        DCB     &04, 2_00000011         ; allow extended parallel port modes
        DCB     &05, 0
        DCB     &06, &FF
        DCB     &07, 0
        DCB     &08, 0
        DCB     &09, 0
        DCB     &0A, 0
        DCB     &00, 2_10111011         ; Valid config, OSC/BR on, FDC enabled/powered, IDE AT,enabled
        DCB     &AA, 0                  ; Exit config mode

        ALIGN

;
; Simplified version of Configure82C710 programs SMC 37C665 only.
;
Configure37C665 Entry "r0,r1"
        WritePSRc SVC_mode + I_bit + F_bit, r0 ; Disable FIQ and IRQ
        LDR     r0, =CnTbase            ; R0-> SMC 665 base address

; First try to configure the SMC665

        MOV     lr, #&55
        STRB    lr, [r0, #CRI711Off]    ; Write &55 to CRI711 twice
        STRB    lr, [r0, #CRI711Off]    ; to enter configuration mode

        MOV     lr, #&0D                ; Check for SMC 665
        STRB    lr, [r0, #CRI711Off]
        LDRB    lr, [r0, #CAP711Off]
        TEQ     lr, #&65
        MOVNE   r1, #0                  ;NE: not a SMC 665 this should never happen
        BNE     %FT30                   ;NE: on a RiscPC, Kryten or Stork

        ADR     r1, ConfigSMCTable      ; R1-> SMC 665 configuration data
20
        LDRB    lr, [r1], #1            ; get config index
        STRB    lr, [r0, #CRI711Off]
        TEQ     lr, #&AA                ; end of table?
        LDRNEB  lr, [r1], #1            ; if not then get config data
        STRNEB  lr, [r0, #CAP711Off]    ; and write it
        BNE     %BT20

        MOV     r1, #IOST_37C665
30
        MOV     r0, #0
        LDRB    lr, [r0, #IOSystemType]
        BIC     lr, lr, #IOST_COMBOMASK
        ORR     lr, lr, r1
        STRB    lr, [r0, #IOSystemType]

        WritePSRc SVC_mode + I_bit, lr  ; Restore IRQ/FIQ state
        EXIT

        ]
 ] ; :LNOT: HAL

a562 1
 [ HAL
d609 1
a609 175
        STR     r1, [r3, #RawMachineID+4]       ; now fall through and check the CRC below
 |

defaultlatch *  20000-1 ; TMD 21-May-93: "-1" correction applied
Tsyc         *  5       ; time between frames - minimum of 1s, so give it a bit more
Trstl        *  500     ; time reset pulse held low - minimum of 480s, so give it a bit more
Trsth        *  500     ; time reset pulse held high - minimum of 480s, so give it a bit more
Tlow0        *  80      ; time for write0 low - min 60s, max 120s
Tlow1        *  5       ; time for write1 low - min 1s, max 15s
Tslot        *  90      ; time for total read/write slot - min 60s, max 120s
Trdlow       *  5       ; time for read slot low before release - min 1s, max 15s
Trddat       *  3       ; time after read slot high before read it

        ASSERT  Tslot-Tlow0 > Tsyc
        ASSERT  Trdlow+Trddat < 15

; Macro to set wire to a given state, and optionally count transitions (starting at low) while waiting for a given time

        MACRO
        SetWire $hilo, $time, $monstate, $count
        LCLS    reg
      [ "$hilo"="LOW"
reg     SETS    "r4"
      |
        ASSERT  "$hilo"="HIGH"
reg     SETS    "r5"
      ]
   [ ($time) = 0
        STRB    $reg, [r1, #IOCControl]         ; set appropriate level on line
   |
        ASSERT  ($time) < 32768
        MOV     r12, #(($time)*2):AND:&FF
        STRB    r12, [r1, #Timer0LL]            ; program low latch
        MOV     r12, #(($time)*2):SHR:8
        STRB    r12, [r1, #Timer0LH]            ; program high latch
        STRB    $reg, [r1, #IOCControl]         ; set appropriate level on line
        STRB    r12, [r1, #Timer0GO]            ; and start timer
        LDRB    r12, [r1, #IOCIRQSTAA]          ; dummy instruction to avoid bug in IOC
        LDRB    r12, [r1, #IOCIRQSTAA]          ; dummy instruction (repeated for FE)
        STRB    r11, [r1, #IOCIRQCLRA]          ; immediately clear IRQ bit
        [ "$monstate"<>""
        MOV     $monstate, #0
        ]
        [ "$count"<>""
        MOV     $count, #0
        ]
10
        LDRB    r12, [r1, #IOCIRQSTAA]
        TST     r12, r11
        [ "$count"<>""
        ADDEQ   $count, $count, #1
        ]
      [ "$monstate"=""
        BEQ     %BT10                                   ; not timed out, so just loop
      |
        BNE     %FT30                                   ; timed out
        LDRB    r12, [r1, #IOCControl]
        TST     r12, #IOEB_unique_machine_ID_bit
        BEQ     %BT10                                   ; if still low then loop to 10

        ADD     $monstate, $monstate, #1                ; increment number of transitions
20
        LDRB    r12, [r1, #IOCIRQSTAA]
        TST     r12, r11
        [ "$count"<>""
        ADDEQ   $count, $count, #1
        ]
        BNE     %FT30                                   ; timed out
        LDRB    r12, [r1, #IOCControl]
        TST     r12, #IOEB_unique_machine_ID_bit
        BNE     %BT20                                   ; if still high then loop to 20
        ADD     $monstate, $monstate, #1                ; increment number of transitions
        B       %BT10
30
      ]
   ]
        MEND

RestoreIOCState Entry
        STRB    r3, [r1, #IOCControl]                   ; put back old value
        MOV     r12, #defaultlatch :AND: &FF
        STRB    r12, [r1, #Timer0LL]                    ; and restore old timer 0 latch values
        MOV     r12, #defaultlatch :SHR: 8
        STRB    r12, [r1, #Timer0LH]
        STRB    r12, [r1, #Timer0GO]
        WritePSRc SVC_mode + I_bit, lr                  ; restore old interrupt state
        EXIT

SendResetPulse ROUT
        SetWire HIGH, Tsyc
        SetWire LOW, Trstl,,r6
        SetWire HIGH, Trsth,r10
        TEQ     r6, #0
      [ :DEF: DebugOneWireBus
        ADREQ   r0, IOCBugHappenedError
      ]
        BEQ     %FT05
        CMP     r10, #3                                 ; H-L-H is ok
        MOVEQ   pc, lr                                  ; V clear
      [ :DEF: DebugOneWireBus
        ADRHI   r0, TooManyTransitionsError             ; H-L-H-L...
        CMP     r10, #2
        ADREQ   r0, NeverWentHighAgainError             ; H-L
        CMP     r10, #1
        ADREQ   r0, NeverWentLowError                   ; H
        ADRCC   r0, NeverWentHighError                  ; stayed low permanently even though we released it
      ]
05
        SETV
        MOV     pc, lr

      [ :DEF: DebugOneWireBus
NeverWentHighError
        =       "Never went high", 0
NeverWentLowError
        =       "Never went low", 0
NeverWentHighAgainError
        =       "Never went high again", 0
TooManyTransitionsError
        =       "Too many transitions", 0
IOCBugHappenedError
        =       "IOC bug happened", 0
        ALIGN
      ]

SendCommandWord ROUT
        CLRV
        LDR     r6, =&10F               ; &0F is command word
10
        MOVS    r6, r6, LSR #1
        MOVEQ   pc, lr
        BCS     SendOne
        SetWire LOW, Tlow0
        SetWire HIGH, Tslot-Tlow0
        B       %BT10

SendOne
        SetWire LOW, Tlow1
        SetWire HIGH, Tslot-Tlow1
        B       %BT10

GetAByte ROUT
        MOV     r6, #&80
10
        SetWire LOW, Trdlow
        SetWire HIGH, Trddat
        LDRB    r10, [r1, #IOCControl]
        SetWire HIGH, Tslot-Trdlow-Trddat
        MOVS    r10, r10, LSR #IOEB_ID_bit_number+1    ; move bit into carry
        MOVS    r6, r6, RRX
        BCC     %BT10
        MOV     r6, r6, LSR #24
        MOV     pc, lr

ReadUniqueID    Entry "r0-r12"
        MOV     r0, #0
        LDR     r1, =IOC
        WritePSRc SVC_mode + I_bit + F_bit, r3
        LDRB    r3, [r0, #IOCControlSoftCopy]
        BIC     r4, r3, #IOEB_unique_machine_ID_bit     ; r4 is value to pull ID line low
        ORR     r5, r3, #IOEB_unique_machine_ID_bit     ; r5 is value to pull ID line high
        MOV     r11, #timer0_bit
        BL      SendResetPulse
        BVS     ResetFailed
        BL      SendCommandWord

        MOV     r7, #-8                                 ; -no. of bytes to store = 8 bits type + 48 bits ID + 8 bits checksum
10
        BL      GetAByte
        STRB    r6, [r7, #RawMachineID+8]
        ADDS    r7, r7, #1
        BNE     %BT10

        BL      RestoreIOCState
 ] ; HAL
a613 5
      [ :LNOT: HAL
ResetFailed
        BL      RestoreIOCState
      ]

@


4.17
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@a16 16
        GBLL    ErrorsInR0
ErrorsInR0 SETL Module                  ; if FALSE, use XOS_GenerateError for
                                        ; RAM version
                                        ; if TRUE, return error ptr in R0

        GBLL    ProtectStationID        ; if TRUE, disallow OSBYTE &A2,0,n
ProtectStationID SETL {TRUE}:LAND::LNOT:STB

 [ STB
	; STB and NC machines probably want Num lock off.
KBStat_Default	*	KBStat_NoShiftLock :OR: KBStat_NoNumLock
 |
	; Desktop machines probably want Num lock on.
KBStat_Default	*	KBStat_NoShiftLock
 ]

d55 1
a55 1
        MOV     R0, #4*(NBuffers-1)     ; index to pointer
d57 1
d61 2
a62 1
        SUBS    R0, R0, #4
d88 3
d102 1
d114 1
a121 1
 [ IO_Type = "IOMD"
a122 3
 |
        BL      Configure82C710         ;Earlier code copes with 82C710,82C711 and 37C665
 ]
d125 1
d127 11
d145 1
d147 1
a147 1
 [ IO_Type = "IOMD"
d152 6
a157 17
 [ E2ROMSupport :LAND: STB
; Don't set time to value held in RTC if the RTC chip is not fitted
; system time will default to epoch: Midnight 1st Jan 1900
	MOV	R1, #0
	LDRB	R0, [r1, #RTCFitted]
	TEQ	R0, #1
	BEQ	%FT28
; Set default time to UNIX epoch (1970) +1day not RISCOS epoch (1900) so time() doesn't return -1
secs0070 *	(86400*(365*70+18))	; from time() in risc_oslib.c.armsys
	LDR	R7, =(secs0070 * 100)	; centiseconds LSW
	MOV	R8, #&33		; centiseconds MSW
	BL	Store5ByteInRealTime
	B	%FT30
28
 ]
        BL      CheckYear               ; check for year wrap scenario
        BL      RTCToRealTime
a159 1
30
d205 1
a205 1
        LDR     R2, =VduDriverWorkSpace+CursorFlags
d234 8
a241 5
        MOVS    R0, R0, LSL #(32-5)     ; bit 5 -> carry, bit 4 -> N bit
        MOVPL   R0, #KBStat_Default + KBStat_ShiftEnable    ; SHCAPS
        MOVMI   R0, #KBStat_Default + KBStat_NoCapsLock     ; NOCAPS
        MOVCS   R0, #KBStat_Default                         ; CAPS
        STRB    R0, KeyBdStatus
d243 9
d254 1
a254 1
        LDR     r1, =VduDriverWorkSpace+CurrentMonitorType ; set current to default
d298 1
a298 1
        MOV     R0, #0
d301 2
a302 1
        MOV     r0, #0                  ; allow SWI Portable_Speed to be issued
a320 18
	[ :LNOT: STB
; *****************************************************************************
;
;       SWI OS_ResyncTime
;
; in:   r0  = 0 - Real time clock soft copy only
;       r0 <> 0   reserved for future expansion
;
; out:  r0 preserved
;
ResyncTimeSWI
        Push    "LR"
        BL      CheckYear               ;may have been frozen over new year!
        BL      RTCToRealTime
        Pull    "LR"
        ExitSWIHandler
	]

d332 1
a332 1
        MOV     R2, #0
a337 5
 [ IO_Type <> "IOMD"                          ; there ain't no Latch B on IOMD!
        LDR     R2, =LatchB
        STRB    R3, [R2]
 ]

d341 1
a341 1
        [ :LNOT: STB
d350 1
a350 1
        mrs    ,R14, CPSR
d352 1
a352 1
        msr    ,CPSR_c, R2              ; disable IRQ
d354 1
a354 1
        MOV     R2, #0
d365 1
a365 1
        msr    ,CPSR_cf, R14            ;Re-enable IRQ, restore flags
d420 1
a420 1
  = KBStat_Default      ; KeyBdStatus  # 1   ; &CA
d511 8
a518 1
ReadMachineType ENTRY "r0-r12"
d520 13
a532 13
	LDRB	r0, [r12, #IOMD_ID0]
	LDRB	r11, [r12, #IOMD_ID1]
	ORR	r0, r0, r11, LSL #8
	LDR	r11, =IOMD_Original
	TEQ	r0, r11
	MOVEQ	r11, #0					; assume Medusa
	MOVNE	r11, #IOST_7500				; else assume Morris
	TEQ	r11, #IOST_7500				; and set EQ if Morris to do conditional stuff below
;
; On Kryten,	Morris pin Event2 is tied low so bit Nevent2 is a ONE
; On Stork,	Morris pin Event2 is tied high so bit Nevent2 is a ZERO
; On STB/NCD,	Morris pin Event2 is tied high so bit Nevent2 is a ZERO, but we don't have a LCD
; 		controller or battery manager so we'll not set IOST_BATMAN
d565 1
a565 1
	ASSERT	(IOMD_C_MonitorType = (1<<0))	; this code only understands auto-detect in bit 0
d567 2
a568 2
	TST     R11, #IOST_7500
        LDREQ	r3, =IOMD_MonitorType		; Not Morris, address is in old place
d578 3
a580 3
	ASSERT	(IOMD_C_PALNTSCType = (1<<4))	; this code only understands PAL/NTSC auto-detect in bit 4
	AND	r4, r4, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
	ORR	r4, r4, r4, LSR #1		; Shift PAL/NTSC bit into bit 3
d583 1
a583 1
	AND	r4, r4, #IOMD_C_MonitorType	; only one bit
d605 2
a606 2
	AND	r6, r6, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
	ORR	r6, r6, r6, LSR #1		; Shift PAL/NTSC bit into bit 3
d608 2
a609 2
	AND	r7, r7, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
	ORR	r7, r7, r7, LSR #1		; Shift PAL/NTSC bit into bit 3
d612 2
a613 2
	AND	r6, r6, #IOMD_C_MonitorType	; only one bit
	AND	r7, r7, #IOMD_C_MonitorType
d729 1
a729 1
  [ IO_Type = "IOMD" :LAND: {FALSE}
d738 1
d770 2
a771 1
TranslateMonitorLeadType ENTRY "r0-r2"
d774 5
d803 12
d826 1
a826 1
 [ IO_Type = "IOMD"
d829 2
a830 2
   [ IOMD_C_MonitorType = 0					; no auto-detect bit
     [ IOMD_C_PALNTSCType = 0					; no PAL/NTSC bits:
d838 1
a838 1
       [ IOMD_C_PALNTSCType = 0					; no PAL/NTSC bits:
d840 1
a840 1
       | ; IOMD_C_PALNTSCType = 0				; wealth of bits:
d846 1
a846 1
	MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
d848 4
a851 2
        MonitorLeadItem 4_3330,  27, 3, 0                       ; VGA-capable monitors
        MonitorLeadItem 4_3333,  12, 0, 1                       ; Others - assume TV standard
a852 8
 | ;IO_Type = "IOMD"
MonitorLead_MonoVGA     *       4_3101
MonitorLead_ColourVGA   *       4_3110
MonitorLead_ColourSVGA  *       4_3010          ; should be type 4, but for the LiteOn we bodge it to 1
MonitorLead_Multisync   *       4_3211
MonitorLead_TV          *       4_3112
MonitorLead_NoConnect   *       4_3111
MonitorLead_Undefined   *       4_3333
a853 7
MonitorLeadList
        MonitorLeadItem MonitorLead_Multisync,  27, 1, 1
        MonitorLeadItem MonitorLead_MonoVGA,    27, 3, 0
        MonitorLeadItem MonitorLead_ColourVGA,  27, 3, 0
        MonitorLeadItem MonitorLead_ColourSVGA, 27, 1, 0        ; bodge for LiteOn (should be 27, 4, 0)
        MonitorLeadItem MonitorLead_Undefined,  12, 0, 1        ; used for all other combinations
 ]
d855 1
a855 1
 [ StorkPowerSave
d867 1
a867 1
        ENTRY "r0,r1"
d890 1
d897 1
a897 1
ComboBase	*	&03010000       ; Base address of combo chip = PC/AT I/O 000H
d900 9
a908 9
SMC_CSR		*	&03F0 * 4	; Configuration Select Register (CSR)
SMC_CSRalt669	*	&0370 * 4	; Alternative Configuration Select Register on SMC 669
					; (this register is used if RTS2 is high on reset, which we don't have direct control of)
SMC_config	*	&55		; value to write to enter configuration mode
SMC_endconfig	*	&AA		; value to write to end configuration mode
SMC_IDreg	*	&0D		; device ID register
SMC_data	*	&03F1 * 4	; Configuration Access Port (data)
SMC_665		*	&65		; 665 ID
SMC_669		*	&03		; 669 ID
d911 4
a914 4
UMC_CSR		*	&0108 * 4	; Configuration Select Register (CSR)
UMC_config	*	&AA		; value to write to enter configuration mode
UMC_endconfig	*	&55		; value to write to end configuration mode
UMC_data	*	&0109 * 4	; Configuration Access Port (data)
d919 1
a919 2
; Note that older devices (eg 82C710, 82C711, SMC651) are no longer supported
	ASSERT	:LNOT: OldComboSupport
d921 1
a921 1
ConfigureCombo ENTRY "r0-r2"
d923 1
a923 1
        LDR     r0, =ComboBase		; R0->  Base address of combo chip
d926 1
a926 1
	ADD	r2, r0, #SMC_CSR	; first try in normal place
d929 2
a930 2
        STRB    lr, [r2]		; Write &55 to CSR twice
        STRB    lr, [r2]		; to enter configuration mode
d935 5
a939 5
        TEQ     lr, #SMC_665		; 665 ?
	ADREQ	r1, ConfigSMC665Table
	BEQ	%FT20
        TEQ     lr, #SMC_669		; 669 ?
	BEQ	%FT18
d944 1
a944 1
        ADD	r2, r0, #SMC_CSRalt669
d947 2
a948 2
        STRB    lr, [r2]		; Write &55 to CSR twice
        STRB    lr, [r2]		; to enter configuration mode
d953 2
a954 2
        TEQ     lr, #SMC_669		; 669 ?
	BEQ	%FT18
d957 1
a957 1
	ADR	r1, ConfigUMC8669Table
d959 1
a959 1
        LDRB    lr, [r1], #1		; get "Index Entry Valid"
d961 3
a963 3
        TEQ     lr, #UMC_endconfig	; end of table?
	BEQ	%FT12
        LDRB    lr, [r1], #1		; get config index
d965 2
a966 2
        LDRB	lr, [r1], #1		; get config data
        STRB	lr, [r0, #UMC_data]	; and write it
d972 11
a982 11
        STRB    lr, [r0, #UMC_CSR]	; Write &AA to enter config mode
	MOV	lr, #&C0
        STRB    lr, [r0, #UMC_CSR]	; CR0
	LDRB	r2, [r0, #UMC_data]
        MOV     lr, #UMC_endconfig	; maybe don't need to do this
        STRB    lr, [r0, #UMC_CSR]	; exit config mode
	TEQ	r2, #2_00111110		; Value for CR0 from ConfigUMC8669Table

        MOVEQ	r1, #IOST_UMC669
	MOVNE	r1, #0			; Don't know what this is, give up
        B	%FT30
d984 1
a984 1
;	SMC config loop
d986 1
a986 1
	ADR	r1, ConfigSMC669Table
d988 1
a988 1
        LDRB    lr, [r1], #1			; get config index
d990 3
a992 3
        TEQ     lr, #SMC_endconfig		; end of table?
        LDRNEB  lr, [r1], #1			; if not then get config data
        STRNEB  lr, [r2, #SMC_data-SMC_CSR]	; and write it
d997 1
a997 1
;	Record type of chip found
d1011 2
a1012 2
	DCB     &01, 2_10010111		; Enable config, COM3@@338, COM4@@238, IRQs active hi,
					; // is extended & powered @@278
d1014 2
a1015 2
	DCB     &01, 2_10000111		; Enable config, COM3@@338, COM4@@238, IRQs active low,
					; // is extended & powered @@278
d1017 15
a1031 15
	DCB     &02, 2_11011100		; COM2 powered & enabled @@2F8, COM1 powered & enabled @@3F8
					; (default)
	DCB     &03, 2_01111000		; floppy stuff (default)
        DCB     &04, 2_00000011		; EPP v1.9, MIDI disabled, normal //floppy,
					; // uses ECP & EPP modes
	DCB     &05, 0			; 4 drive support, don't swap drives, normal density,
					; FDC burst mode, IDE@@1F0-7,3F6-7, FDC@@3F0-7 (default)
;	DCB     &06, &FF		; floppy drive types (default)
;	DCB     &07, 0			; don't auto-powerdown anything (default)
;	DCB     &08, 0			; ADRA7:4 address decode (default)
;	DCB     &09, 0			; ADRA10:8 address decode (default)
;	DCB     &0A, 0			; FIFO threshold for ECP // = ??? (default)
;	DCB	&0B, 0			; floppy data rates (default)
;	DCB	&0C, 0			; UART2 & UART1 standard speed, UART2 standard mode,
					; UART2 full duplex, XMIT active hi, RCV active hi (default)
d1033 2
a1034 2
					; IDE AT & enabled
        DCB     SMC_endconfig		; Exit config mode
d1038 15
a1052 15
	DCB     &01, 2_10010100         ; Enable config, // is extended, // is  powered
	DCB     &02, 2_10001000         ; COM2 powered, COM1 powered (default)
	DCB     &03, 2_01110000		; floppy stuff (bit 3 now reserved)
	DCB     &04, 2_00000011		; IR rx&tx on COM2 rx & tx pins, EPP v1.9, MIDI disabled,
					; normal //floppy, uses ECP & EPP modes
	DCB     &05, 0			; 4 drive support, don't swap drives, normal density,
					; FDC burst mode (default)
;	DCB     &06, &FF		; floppy drive types (default)
;	DCB     &07, 0			; don't auto-powerdown anything
;	DCB     &08, 0			; ADRA7:4 address decode (default)
;	DCB     &09, 0			; ADRx disabled, ADRA10:8 address decode (default)
;	DCB     &0A, 0			; FIFO threshold for ECP // = ??? (default)
;	DCB	&0B, 0			; floppy data rates (default)
;	DCB	&0C, 0			; UART2 & UART1 standard speed, UART2 standard mode,
					; UART2 full duplex, XMIT active hi, RCV active hi (default)
d1054 1
a1054 1
;	DCB	&10, 2_00000000		; 14.318MHz input to PLL (default)
d1056 1
a1056 1
	DCB	&10, 2_01000000		; 24MHz input to PLL
d1058 12
a1069 12
;	DCB	&1E, &80		; GAMECS disabled (default)
;	DCB	&1F, 0			; floppy drive types (default)
	DCB	&20, &FC		; FDC@@3F0-7
	DCB	&21, &7C		; IDE@@1F0-7
	DCB	&22, &FD		; IDE Alternate Status Register @@3F6
	DCB	&23, &9E		; //@@278
	DCB	&24, &FE		; COM1@@3F8
	DCB	&25, &BE		; COM2@@2F8
	DCB	&26, 0			; no FDC DMA, no // DMA (default)
	DCB	&27, 2_01100101		; FDC uses IRQ_F, // uses IRQ_E
	DCB	&28, 2_01000011		; UART1 uses IRQ_D, UART2 uses IRQ_C
	DCB	&29, 0			; IRQIN does not use any IRQ_x (default)
d1071 1
a1071 1
        DCB     SMC_endconfig		; Exit config mode
d1075 9
a1083 9
	DCB     UMC_config, &C0, 2_00111110	; IR full-duplex, games off, IDE on,
						; // in EPP & ECP mode, UART2 on, UART1 on, FDC off
	DCB     UMC_config, &C1, 2_00101111	; Direct access PnP register, Disable PnP,
						; IDE@@1F0-7,3F6-7, //@@278, COM2@@2F8, COM1@@3F8,
						; FDC@@3F0-7
	DCB     UMC_config, &C2, 2_10000001	; Not supspended, IR unselected/disabled,
						; don't swap floppy, IBM mode floppy,
						; floppy is R/W (default)
        DCB     UMC_endconfig, 0		; Exit config mode
a1104 113
 [ IO_Type <> "IOMD"
Configure82C710 ENTRY "r0,r1"
        MOV     r0, #0
        LDRB    lr, [r0, #IOSystemType]
        TST     lr, #IOST_IOEB          ; no IOEB, then don't bother
        EXIT    EQ

        WritePSRc SVC_mode + I_bit + F_bit, r0  ; Disable FIQ and IRQ
        LDR     r0, =CnTbase            ; R0-> 82C710 base address

; First try to configure 82C711 or SMC665

        MOV     lr, #&55
        STRB    lr, [r0, #CRI711Off]    ; Write &55 to CRI711 twice
        STRB    lr, [r0, #CRI711Off]    ; to enter configuration mode

        MOV     lr, #&0D                ; Check for SMC 665
        STRB    lr, [r0, #CRI711Off]
        LDRB    lr, [r0, #CAP711Off]
        TEQ     lr, #&65
        ADREQ   r1, ConfigSMCTable      ; different table for SMC 665
        ADRNE   r1, Config711Table      ; R1-> 82C711 configuration data
        Push    "lr"                    ; need to test for 665 again
20
        LDRB    lr, [r1], #1            ; get config index
        STRB    lr, [r0, #CRI711Off]
        TEQ     lr, #&AA                ; end of table?
        LDRNEB  lr, [r1], #1            ; if not then get config data
        STRNEB  lr, [r0, #CAP711Off]    ; and write it
        BNE     %BT20

        Pull    "lr"
        TEQ     lr, #&65                ; if we configured SMC 665 then
        MOVEQ   r1, #IOST_37C665        ;   set flag in IOSystemType
        BEQ     %FT30                   ;   and no need to faff about for 710/711

; Now try to configure 82C710 (won't work on 711)

        MOV     lr, #&55                ; Magic number from 82C710 data sheet
        STRB    lr, [r0, #ConRegA710]   ; Start configuration mode
        MVN     lr, lr                  ; Complement the magic number
        STRB    lr, [r0, #ConRegB710]
        MOV     lr, #&36                ; Another magic number from C&T
        STRB    lr, [r0, #ConRegB710]
        MOV     r1, #CRI710 /4          ; 82C710 configuration address /4
        STRB    r1, [r0, #ConRegB710]   ; Write configuration address
        MVN     lr, r1                  ; Complement the data
        STRB    lr, [r0, #ConRegA710]   ; Complete configuration sequence

        ADR     r1, Config710Table      ; R1-> 82C710 configuration data
10
        LDRB    lr, [r1], #1            ; Get next 82C710 config reg index, R1++
        STRB    lr, [r0, #CRI710Off]    ; Write index
        TEQ     lr, #&0F                ; Configuration register selected?
        LDRB    lr, [r1], #1            ; Get config data, R1++
        STRB    lr, [r0, #CAP710Off]    ; Write config data
        BNE     %BT10                   ; Repeat until config register written

; now if we're on 82C710 then 1st serial port is at &3F8
; and if we're on 82C711 then 1st serial port is at &2F8

        STRB    lr, [r0, #&2FF * 4]     ; store &AA in serial scratchpad register for 82C711 port 1
        MOV     lr, #&55
        STRB    lr, [r0, #&3FF * 4]     ; store &55 in serial scratchpad register for 82C710
        STRB    lr, [r0, #CRI711Off]    ; Write &55 to CRI711 twice
        STRB    lr, [r0, #CRI711Off]    ; to reenter configuration mode
        MOV     lr, #&02                ; select config register 2
        STRB    lr, [r0, #CRI711Off]
        MOV     lr, #2_00011100         ; move 1st serial port to &3F8
        STRB    lr, [r0, #CAP711Off]
        MOV     lr, #&AA
        STRB    lr, [r0, #CRI711Off]    ; exit config mode

        MOV     r1, #0                  ; by default no 82C710 or 82C711
        LDRB    lr, [r0, #&3FF * 4]     ; read scratchpad register
        TEQ     lr, #&55                ; &55 => 82C710
        MOVEQ   r1, #IOST_82C710
        TEQ     lr, #&AA
        MOVEQ   r1, #IOST_82C711
30
        MOV     r0, #0
        LDRB    lr, [r0, #IOSystemType]
        BIC     lr, lr, #IOST_COMBOMASK
        ORR     lr, lr, r1
        STRB    lr, [r0, #IOSystemType]

        WritePSRc SVC_mode + I_bit, lr  ; Restore IRQ/FIQ state
        EXIT
 ]

 [ IO_Type <> "IOMD"
Config710Table ; Index, Data            ; 82C710 configuration data
        DCB     &01, 2_01000000         ; Bi-dir parallel
        DCB     &02, 2_00001000         ; Default, UART clock
        DCB     &04, &FE                ; Default, UART base address= &3F8 (COM1)
        DCB     &06, &9E                ; Default, Parallel base address= &278 (LPT3)
        DCB     &09, &9E                ; GPCS=&278 (so writes to printer control go to PAL too)
        DCB     &0A, 2_00001010         ; GPCS A1=1 (to detect printer control), GPCS enabled
        DCB     &0B, 2_01110000         ; IRQs active lo, GPCS is an o/p
        DCB     &0C, 2_10100001         ; IDE/FDC enabled, mouse disabled
        DCB     &0D, 0                  ; Default, mouse address
        DCB     &0E, 2_00000000         ; Default, test modes disabled
        DCB     &00, 2_10101100         ; Valid config, OSC/BR on, Ser/Par enable
        DCB     &0F, 0                  ; Write config register == end of list

Config711Table
        DCB     &01, 2_10000111         ; Enable config read, IRQ active low, parallel powered/extended, default addr.
        DCB     &02, 2_00001101         ; 2nd serial port disabled, 1st enabled at &2F8 (to be moved to &3F8 later)
        DCB     &03, 0                  ; Test mode disabled
        DCB     &00, 2_10111011         ; Valid config, OSC/BR on, FDC enabled/powered, IDE AT,enabled
        DCB     &AA, 0                  ; Exit config mode
 ]

a1120 1
 [ IO_Type = "IOMD"
d1124 1
a1124 1
Configure37C665 ENTRY "r0,r1"
a1159 1
 ]
d1162 1
a1162 1

d1168 50
a1217 1
; 10-Dec-93  BCockburn  Modified to leave raw 64 bit ID from chip in RawMachineID
d1220 8
a1227 9

Tsyc    *       5       ; time between frames - minimum of 1s, so give it a bit more
Trstl   *       500     ; time reset pulse held low - minimum of 480s, so give it a bit more
Trsth   *       500     ; time reset pulse held high - minimum of 480s, so give it a bit more
Tlow0   *       80      ; time for write0 low - min 60s, max 120s
Tlow1   *       5       ; time for write1 low - min 1s, max 15s
Tslot   *       90      ; time for total read/write slot - min 60s, max 120s
Trdlow  *       5       ; time for read slot low before release - min 1s, max 15s
Trddat  *       3       ; time after read slot high before read it
d1237 1
a1237 1
 [ "$hilo"="LOW"
d1239 1
a1239 1
 |
d1242 2
a1243 2
 ]
 [ ($time) = 0
d1245 1
a1245 1
 |
d1256 1
a1256 1
  [ "$monstate"<>""
d1258 2
a1259 2
  ]
  [ "$count"<>""
d1261 1
a1261 1
  ]
d1265 1
a1265 1
  [ "$count"<>""
d1267 2
a1268 2
  ]
  [ "$monstate"=""
d1270 1
a1270 1
  |
d1280 1
a1280 1
   [ "$count"<>""
d1282 1
a1282 1
   ]
d1290 2
a1291 2
  ]
 ]
d1294 1
a1294 33
ReadUniqueID    ENTRY "r0-r12"
        MOV     r0, #0
        LDR     r1, =IOC
        WritePSRc SVC_mode + I_bit + F_bit, r3
        LDRB    r3, [r0, #IOCControlSoftCopy]
        BIC     r4, r3, #IOEB_unique_machine_ID_bit     ; r4 is value to pull ID line low
        ORR     r5, r3, #IOEB_unique_machine_ID_bit     ; r5 is value to pull ID line high
        MOV     r11, #timer0_bit
        BL      SendResetPulse
        BVS     ResetFailed
        BL      SendCommandWord

        MOV     r7, #-8                                 ; -no. of bytes to store = 8 bits type + 48 bits ID + 8 bits checksum
10
        BL      GetAByte
        STRB    r6, [r7, #RawMachineID+8]
        ADDS    r7, r7, #1
        BNE     %BT10

        BL      RestoreIOCState
        BL      CheckCRC
        BVS     IDError
        EXIT

ResetFailed
        BL      RestoreIOCState
IDError
        MOV     r0, #0
        STR     r0, [r0, #RawMachineID+0]            ; indicate no ID by putting zero here
        STR     r0, [r0, #RawMachineID+4]
        EXIT

RestoreIOCState ENTRY
d1309 3
a1311 1
;        ADREQ   r0, IOCBugHappenedError
d1315 8
a1322 6
;        ADRHI   r0, TooManyTransitionsError             ; H-L-H-L...
;        CMP     r10, #2
;        ADREQ   r0, NeverWentHighAgainError             ; H-L
;        CMP     r10, #1
;        ADREQ   r0, NeverWentLowError                   ; H
;        ADRCC   r0, NeverWentHighError                  ; stayed low permanently even though we released it
d1327 1
a1327 1
 [ {FALSE} ; only for debugging
d1339 1
a1339 1
 ]
d1370 43
d1414 2
a1415 1
        LDR     r1, =RawMachineID               ; pointer to current byte
@


4.17.4.1
log
@  Patch to s/PMF/osinit to support FastNC
Detail:
  FastNC has different serial init to all other boxes.
Admin:
  Tested on FastNC using Products/Ursula rev 1.196 as a base build.


Version 5.46, 4.90.2.1. Tagged as 'Kernel-5_46-4_90_2_1'
@
text
@d1260 1
a1260 1
        TEQ     lr, #&AA                ; 'AA' value on FastNC.  '65' on everything else :-(
@


4.17.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d372 1
a372 1
        MRS     R14, CPSR
d374 1
a374 1
        MSR     CPSR_c, R2              ; disable IRQ
d387 1
a387 1
        MSR     CPSR_cf, R14            ;Re-enable IRQ, restore flags
d533 1
a533 1
ReadMachineType Entry "r0-r12"
d784 1
a784 1
TranslateMonitorLeadType Entry "r0-r2"
d876 1
a876 1
        Entry "r0,r1"
d930 1
a930 1
ConfigureCombo Entry "r0-r2"
d1115 1
a1115 1
Configure82C710 Entry "r0,r1"
d1247 1
a1247 1
Configure37C665 Entry "r0,r1"
d1370 1
a1370 1
ReadUniqueID    Entry "r0-r12"
d1402 1
a1402 1
RestoreIOCState Entry
@


4.17.2.2
log
@More HAL work. IOMD HAL fleshed out somewhat - system gets most of the way
through initialisation.

Version 5.35, 4.79.2.5. Tagged as 'Kernel-5_35-4_79_2_5'
@
text
@a101 3
  [ HAL
; This has already been done much earlier in initialisation
  |
a112 1
   ]
a123 1
 [ :LNOT: HAL
a137 1
 ]
a138 15
 [ HAL
        AddressHAL
        MOV     R0, #0
        CallHAL HAL_TimerDevice
        MOV     R4, R0
        CallHAL HAL_VideoFlybackDevice
        MOV     R5, R0
        CallHAL HAL_IRQClear            ; clear vsync IRQ
        MOV     R0, R4
        CallHAL HAL_IRQClear            ; clear timer 0 IRQ
        MOV     R0, R5
        CallHAL HAL_IRQEnable           ; enable vsync IRQ
        MOV     R0, R4
        CallHAL HAL_IRQEnable           ; enable timer 0 IRQ
 |
a145 1
 ]
d147 1
a147 1
 [ :LNOT: HAL :LAND: IO_Type = "IOMD"
a533 10
  [ HAL
        MOV     r2, #4_3333
        MOV     r1, #0
        STRB    r2, [r1, #MonitorLeadType]

        MOV     r2, #0
        STRB    r2, [r1, #IOSystemType]

        EXIT
  |
a752 1
  ]
a1286 10
 [ HAL
ReadUniqueID
        Entry   "r0-r3,r9,r12"
        AddressHAL
        CallHAL HAL_MachineID
        MOV     r3, #0
        STR     r0, [r3, #RawMachineID+0]
        STR     r1, [r3, #RawMachineID+4]
        EXIT
 |
a1493 1
 ] ; HAL
@


4.17.2.3
log
@Interrupt handling tweaks.

Version 5.35, 4.79.2.7. Tagged as 'Kernel-5_35-4_79_2_7'
@
text
@a145 1
        Push    "r9,r12"
a158 1
        Pull    "r9,r12"
@


4.17.2.4
log
@  Added HAL NVRAM support
Detail:
  Added the HAL NVRAM entries.
  Modified i2cutils to use the HAL entries for NVRAM and behave sensibly if the HAL reports that there is no NVRAM, in which case there must be a forced reset_cmos call so that the cache gets set up sensibly.
Admin:
  Tested under the RPC emulator and appears to be working correctly, although some calls to IIC are still being made in the no nvram case.

Version 5.35, 4.79.2.8. Tagged as 'Kernel-5_35-4_79_2_8'
@
text
@d176 1
a176 1
 [ STB
@


4.17.2.5
log
@Wahey! This version gives you a display.

It says "Abort on data transfer".
@
text
@d559 1
a559 1
        MOV     r2, #4_3330
@


4.17.2.6
log
@set mode working with LCD
@
text
@d559 1
a559 2
        ;MOV     r2, #4_3330                     ; Fudge 1 - VGA
        MOV     r2, #4_3111                     ; Fudge 2 - no connection - will do LCD
a879 1
        MonitorLeadItem 4_3111,  27, 5, 0                       ; Nothing - try LCD (fudge fudge)
a895 1
        MonitorLeadItem MonitorLead_NoConnect,  27, 5, 0
@


4.17.2.7
log
@More stuff. Up to the desktop now; cache on, working keyboard. Some source
restructuring to start to make splitting it up into several object files more
feasible.
@
text
@d387 1
a387 1
        [ :LNOT: STB :LAND: :LNOT: HAL
@


4.17.2.8
log
@Various L7200 tweaks, plus working ARM920T code.

Version 5.35, 4.79.2.17. Tagged as 'Kernel-5_35-4_79_2_17'
@
text
@d880 3
a882 4
        ; KJB - changed default modes to 256 colours
        MonitorLeadItem 4_3330,  28, 3, 0                       ; VGA-capable monitors
        MonitorLeadItem 4_3111,  28, 5, 0                       ; Nothing - try LCD (fudge fudge)
        MonitorLeadItem 4_3333,  15, 0, 1                       ; Others - assume TV standard
@


4.17.2.9
log
@Customer L-y HAL-y IIC-y type stuff. It's great.
@
text
@d176 1
d190 1
d344 1
d360 1
@


4.17.2.10
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d26 2
a27 2
        ; STB and NC machines probably want Num lock off.
KBStat_Default  *       KBStat_NoShiftLock :OR: KBStat_NoNumLock
d29 2
a30 2
        ; Desktop machines probably want Num lock on.
KBStat_Default  *       KBStat_NoShiftLock
d136 1
d138 3
d171 1
a171 1
 [ :LNOT: HAL
d178 4
a181 4
        MOV     R1, #0
        LDRB    R0, [r1, #RTCFitted]
        TEQ     R0, #1
        BEQ     %FT28
d183 5
a187 5
secs0070 *      (86400*(365*70+18))     ; from time() in risc_oslib.c.armsys
        LDR     R7, =(secs0070 * 100)   ; centiseconds LSW
        MOV     R8, #&33                ; centiseconds MSW
        BL      Store5ByteInRealTime
        B       %FT30
d375 5
d566 13
a578 13
        LDRB    r0, [r12, #IOMD_ID0]
        LDRB    r11, [r12, #IOMD_ID1]
        ORR     r0, r0, r11, LSL #8
        LDR     r11, =IOMD_Original
        TEQ     r0, r11
        MOVEQ   r11, #0                                 ; assume Medusa
        MOVNE   r11, #IOST_7500                         ; else assume Morris
        TEQ     r11, #IOST_7500                         ; and set EQ if Morris to do conditional stuff below
;
; On Kryten,    Morris pin Event2 is tied low so bit Nevent2 is a ONE
; On Stork,     Morris pin Event2 is tied high so bit Nevent2 is a ZERO
; On STB/NCD,   Morris pin Event2 is tied high so bit Nevent2 is a ZERO, but we don't have a LCD
;               controller or battery manager so we'll not set IOST_BATMAN
d611 1
a611 1
        ASSERT  (IOMD_C_MonitorType = (1<<0))   ; this code only understands auto-detect in bit 0
d613 2
a614 2
        TST     R11, #IOST_7500
        LDREQ   r3, =IOMD_MonitorType           ; Not Morris, address is in old place
d624 3
a626 3
        ASSERT  (IOMD_C_PALNTSCType = (1<<4))   ; this code only understands PAL/NTSC auto-detect in bit 4
        AND     r4, r4, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
        ORR     r4, r4, r4, LSR #1              ; Shift PAL/NTSC bit into bit 3
d629 1
a629 1
        AND     r4, r4, #IOMD_C_MonitorType     ; only one bit
d651 2
a652 2
        AND     r6, r6, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
        ORR     r6, r6, r6, LSR #1              ; Shift PAL/NTSC bit into bit 3
d654 2
a655 2
        AND     r7, r7, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
        ORR     r7, r7, r7, LSR #1              ; Shift PAL/NTSC bit into bit 3
d658 2
a659 2
        AND     r6, r6, #IOMD_C_MonitorType     ; only one bit
        AND     r7, r7, #IOMD_C_MonitorType
d775 1
a775 1
  [ {FALSE}
d854 1
a854 1

d857 2
a858 2
   [ IOMD_C_MonitorType = 0                                     ; no auto-detect bit
     [ IOMD_C_PALNTSCType = 0                                   ; no PAL/NTSC bits:
d866 1
a866 1
       [ IOMD_C_PALNTSCType = 0                                 ; no PAL/NTSC bits:
d868 1
a868 1
       | ; IOMD_C_PALNTSCType = 0                               ; wealth of bits:
d874 1
a874 1
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
d881 8
d890 8
d940 1
a940 1
ComboBase       *       &03010000       ; Base address of combo chip = PC/AT I/O 000H
d943 9
a951 9
SMC_CSR         *       &03F0 * 4       ; Configuration Select Register (CSR)
SMC_CSRalt669   *       &0370 * 4       ; Alternative Configuration Select Register on SMC 669
                                        ; (this register is used if RTS2 is high on reset, which we don't have direct control of)
SMC_config      *       &55             ; value to write to enter configuration mode
SMC_endconfig   *       &AA             ; value to write to end configuration mode
SMC_IDreg       *       &0D             ; device ID register
SMC_data        *       &03F1 * 4       ; Configuration Access Port (data)
SMC_665         *       &65             ; 665 ID
SMC_669         *       &03             ; 669 ID
d954 4
a957 4
UMC_CSR         *       &0108 * 4       ; Configuration Select Register (CSR)
UMC_config      *       &AA             ; value to write to enter configuration mode
UMC_endconfig   *       &55             ; value to write to end configuration mode
UMC_data        *       &0109 * 4       ; Configuration Access Port (data)
d963 1
a963 1
        ASSERT  :LNOT: OldComboSupport
d967 1
a967 1
        LDR     r0, =ComboBase          ; R0->  Base address of combo chip
d970 1
a970 1
        ADD     r2, r0, #SMC_CSR        ; first try in normal place
d973 2
a974 2
        STRB    lr, [r2]                ; Write &55 to CSR twice
        STRB    lr, [r2]                ; to enter configuration mode
d979 5
a983 5
        TEQ     lr, #SMC_665            ; 665 ?
        ADREQ   r1, ConfigSMC665Table
        BEQ     %FT20
        TEQ     lr, #SMC_669            ; 669 ?
        BEQ     %FT18
d988 1
a988 1
        ADD     r2, r0, #SMC_CSRalt669
d991 2
a992 2
        STRB    lr, [r2]                ; Write &55 to CSR twice
        STRB    lr, [r2]                ; to enter configuration mode
d997 2
a998 2
        TEQ     lr, #SMC_669            ; 669 ?
        BEQ     %FT18
d1001 1
a1001 1
        ADR     r1, ConfigUMC8669Table
d1003 1
a1003 1
        LDRB    lr, [r1], #1            ; get "Index Entry Valid"
d1005 3
a1007 3
        TEQ     lr, #UMC_endconfig      ; end of table?
        BEQ     %FT12
        LDRB    lr, [r1], #1            ; get config index
d1009 2
a1010 2
        LDRB    lr, [r1], #1            ; get config data
        STRB    lr, [r0, #UMC_data]     ; and write it
d1016 11
a1026 11
        STRB    lr, [r0, #UMC_CSR]      ; Write &AA to enter config mode
        MOV     lr, #&C0
        STRB    lr, [r0, #UMC_CSR]      ; CR0
        LDRB    r2, [r0, #UMC_data]
        MOV     lr, #UMC_endconfig      ; maybe don't need to do this
        STRB    lr, [r0, #UMC_CSR]      ; exit config mode
        TEQ     r2, #2_00111110         ; Value for CR0 from ConfigUMC8669Table

        MOVEQ   r1, #IOST_UMC669
        MOVNE   r1, #0                  ; Don't know what this is, give up
        B       %FT30
d1028 1
a1028 1
;       SMC config loop
d1030 1
a1030 1
        ADR     r1, ConfigSMC669Table
d1032 1
a1032 1
        LDRB    lr, [r1], #1                    ; get config index
d1034 3
a1036 3
        TEQ     lr, #SMC_endconfig              ; end of table?
        LDRNEB  lr, [r1], #1                    ; if not then get config data
        STRNEB  lr, [r2, #SMC_data-SMC_CSR]     ; and write it
d1041 1
a1041 1
;       Record type of chip found
d1055 2
a1056 2
        DCB     &01, 2_10010111         ; Enable config, COM3@@338, COM4@@238, IRQs active hi,
                                        ; // is extended & powered @@278
d1058 2
a1059 2
        DCB     &01, 2_10000111         ; Enable config, COM3@@338, COM4@@238, IRQs active low,
                                        ; // is extended & powered @@278
d1061 15
a1075 15
        DCB     &02, 2_11011100         ; COM2 powered & enabled @@2F8, COM1 powered & enabled @@3F8
                                        ; (default)
        DCB     &03, 2_01111000         ; floppy stuff (default)
        DCB     &04, 2_00000011         ; EPP v1.9, MIDI disabled, normal //floppy,
                                        ; // uses ECP & EPP modes
        DCB     &05, 0                  ; 4 drive support, don't swap drives, normal density,
                                        ; FDC burst mode, IDE@@1F0-7,3F6-7, FDC@@3F0-7 (default)
;       DCB     &06, &FF                ; floppy drive types (default)
;       DCB     &07, 0                  ; don't auto-powerdown anything (default)
;       DCB     &08, 0                  ; ADRA7:4 address decode (default)
;       DCB     &09, 0                  ; ADRA10:8 address decode (default)
;       DCB     &0A, 0                  ; FIFO threshold for ECP // = ??? (default)
;       DCB     &0B, 0                  ; floppy data rates (default)
;       DCB     &0C, 0                  ; UART2 & UART1 standard speed, UART2 standard mode,
                                        ; UART2 full duplex, XMIT active hi, RCV active hi (default)
d1077 2
a1078 2
                                        ; IDE AT & enabled
        DCB     SMC_endconfig           ; Exit config mode
d1082 15
a1096 15
        DCB     &01, 2_10010100         ; Enable config, // is extended, // is  powered
        DCB     &02, 2_10001000         ; COM2 powered, COM1 powered (default)
        DCB     &03, 2_01110000         ; floppy stuff (bit 3 now reserved)
        DCB     &04, 2_00000011         ; IR rx&tx on COM2 rx & tx pins, EPP v1.9, MIDI disabled,
                                        ; normal //floppy, uses ECP & EPP modes
        DCB     &05, 0                  ; 4 drive support, don't swap drives, normal density,
                                        ; FDC burst mode (default)
;       DCB     &06, &FF                ; floppy drive types (default)
;       DCB     &07, 0                  ; don't auto-powerdown anything
;       DCB     &08, 0                  ; ADRA7:4 address decode (default)
;       DCB     &09, 0                  ; ADRx disabled, ADRA10:8 address decode (default)
;       DCB     &0A, 0                  ; FIFO threshold for ECP // = ??? (default)
;       DCB     &0B, 0                  ; floppy data rates (default)
;       DCB     &0C, 0                  ; UART2 & UART1 standard speed, UART2 standard mode,
                                        ; UART2 full duplex, XMIT active hi, RCV active hi (default)
d1098 1
a1098 1
;       DCB     &10, 2_00000000         ; 14.318MHz input to PLL (default)
d1100 1
a1100 1
        DCB     &10, 2_01000000         ; 24MHz input to PLL
d1102 12
a1113 12
;       DCB     &1E, &80                ; GAMECS disabled (default)
;       DCB     &1F, 0                  ; floppy drive types (default)
        DCB     &20, &FC                ; FDC@@3F0-7
        DCB     &21, &7C                ; IDE@@1F0-7
        DCB     &22, &FD                ; IDE Alternate Status Register @@3F6
        DCB     &23, &9E                ; //@@278
        DCB     &24, &FE                ; COM1@@3F8
        DCB     &25, &BE                ; COM2@@2F8
        DCB     &26, 0                  ; no FDC DMA, no // DMA (default)
        DCB     &27, 2_01100101         ; FDC uses IRQ_F, // uses IRQ_E
        DCB     &28, 2_01000011         ; UART1 uses IRQ_D, UART2 uses IRQ_C
        DCB     &29, 0                  ; IRQIN does not use any IRQ_x (default)
d1115 1
a1115 1
        DCB     SMC_endconfig           ; Exit config mode
d1119 9
a1127 9
        DCB     UMC_config, &C0, 2_00111110     ; IR full-duplex, games off, IDE on,
                                                ; // in EPP & ECP mode, UART2 on, UART1 on, FDC off
        DCB     UMC_config, &C1, 2_00101111     ; Direct access PnP register, Disable PnP,
                                                ; IDE@@1F0-7,3F6-7, //@@278, COM2@@2F8, COM1@@3F8,
                                                ; FDC@@3F0-7
        DCB     UMC_config, &C2, 2_10000001     ; Not supspended, IR unselected/disabled,
                                                ; don't swap floppy, IBM mode floppy,
                                                ; floppy is R/W (default)
        DCB     UMC_endconfig, 0                ; Exit config mode
d1149 113
d1278 1
d1318 1
@


4.17.2.11
log
@    Change for Customer M build.

Detail:
    The Kernel now sets "ProtectStationID" on the basis of the Embedded_UI
flag, rather than the STB flag, so you're able to set the bottom byte of your
IP address in IPConfig.

Admin:
    Untested.

Version 5.35, 4.79.2.46. Tagged as 'Kernel-5_35-4_79_2_46'
@
text
@d23 1
a23 1
ProtectStationID SETL {TRUE}:LAND::LNOT:Embedded_UI
@


4.17.2.12
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d148 2
a149 3
        CMP     R0, #-1
        MOVNE   R5, R0
        CallHAL HAL_IRQClear, NE        ; clear vsync IRQ
d173 6
a178 1
; system time will default to UNIX epoch + 1 day (so time() doesn't return -1)
a179 5

        MOV     R1, #0
        LDRB    R0, [R1, #RTCFitted]
        TEQ     R0, #0                  ; when zero,no RTC
        BNE     %FT28
d348 1
a348 2
        Push    "R12,LR"
        BYTEWS	WsPtr
d351 1
a351 1
        Pull    "R12,LR"
d546 2
a547 2
        MOV     r2, #4_3330                     ; Fudge 1 - VGA
        ;MOV     r2, #4_3111                     ; Fudge 2 - no connection - will do LCD
a1181 5
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       ReadUniqueID - Read unique machine ID
;

d1189 2
a1190 1
        STR     r1, [r3, #RawMachineID+4]       ; now fall through and check the CRC below
d1193 6
d1200 9
a1208 8
Tsyc         *  5       ; time between frames - minimum of 1s, so give it a bit more
Trstl        *  500     ; time reset pulse held low - minimum of 480s, so give it a bit more
Trsth        *  500     ; time reset pulse held high - minimum of 480s, so give it a bit more
Tlow0        *  80      ; time for write0 low - min 60s, max 120s
Tlow1        *  5       ; time for write1 low - min 1s, max 15s
Tslot        *  90      ; time for total read/write slot - min 60s, max 120s
Trdlow       *  5       ; time for read slot low before release - min 1s, max 15s
Trddat       *  3       ; time after read slot high before read it
d1218 1
a1218 1
      [ "$hilo"="LOW"
d1220 1
a1220 1
      |
d1223 2
a1224 2
      ]
   [ ($time) = 0
d1226 1
a1226 1
   |
d1237 1
a1237 1
        [ "$monstate"<>""
d1239 2
a1240 2
        ]
        [ "$count"<>""
d1242 1
a1242 1
        ]
d1246 1
a1246 1
        [ "$count"<>""
d1248 2
a1249 2
        ]
      [ "$monstate"=""
d1251 1
a1251 1
      |
d1261 1
a1261 1
        [ "$count"<>""
d1263 1
a1263 1
        ]
d1271 2
a1272 2
      ]
   ]
d1275 32
d1322 1
a1322 3
      [ :DEF: DebugOneWireBus
        ADREQ   r0, IOCBugHappenedError
      ]
d1326 6
a1331 8
      [ :DEF: DebugOneWireBus
        ADRHI   r0, TooManyTransitionsError             ; H-L-H-L...
        CMP     r10, #2
        ADREQ   r0, NeverWentHighAgainError             ; H-L
        CMP     r10, #1
        ADREQ   r0, NeverWentLowError                   ; H
        ADRCC   r0, NeverWentHighError                  ; stayed low permanently even though we released it
      ]
d1336 1
a1336 1
      [ :DEF: DebugOneWireBus
d1348 1
a1348 1
      ]
a1378 37
ReadUniqueID    Entry "r0-r12"
        MOV     r0, #0
        LDR     r1, =IOC
        WritePSRc SVC_mode + I_bit + F_bit, r3
        LDRB    r3, [r0, #IOCControlSoftCopy]
        BIC     r4, r3, #IOEB_unique_machine_ID_bit     ; r4 is value to pull ID line low
        ORR     r5, r3, #IOEB_unique_machine_ID_bit     ; r5 is value to pull ID line high
        MOV     r11, #timer0_bit
        BL      SendResetPulse
        BVS     ResetFailed
        BL      SendCommandWord

        MOV     r7, #-8                                 ; -no. of bytes to store = 8 bits type + 48 bits ID + 8 bits checksum
10
        BL      GetAByte
        STRB    r6, [r7, #RawMachineID+8]
        ADDS    r7, r7, #1
        BNE     %BT10

        BL      RestoreIOCState
 ] ; HAL
        BL      CheckCRC
        BVS     IDError
        EXIT

      [ :LNOT: HAL
ResetFailed
        BL      RestoreIOCState
      ]

IDError
        DebugTX "Machine ID duff,zero substituted"
        MOV     r0, #0
        STR     r0, [r0, #RawMachineID+0]       ; indicate no ID by putting zero here
        STR     r0, [r0, #RawMachineID+4]
        EXIT

d1399 1
@


4.17.2.13
log
@* HAL can choose to limit amount of screen memory to allocate
  [Not fully implemented - for now leaves at least 16MB free if only
  one RAM area; was 1MB].
* Added HAL_USBControllerInfo, HAL_MonitorLeadID and HAL_Video_Render.
* Added HAL->OS call OS_IICOpV.
* OS_MMUControl now allows independent control of I and C bits.
* Added facility to deactivate keyboard debounce (magic word "NoKd" in
  R2 in KeyV 0).
* Fixed problem with RAM amounts not a multiple of 4MB.
* Supremacy bit (in VDU 19) now sets all 8 bits of supremacy.
* Added PaletteV 14 (reads gamma tables).
* Added Supremacy transfer functions (like gamma correction, but for
  supremacy). Allows easy global supremacy effects in a mode-independent
  fashion. Controlled with PaletteV 15,16.
* Added modes 50-53 (320x240, 1,2,4,8bpp). Intended for small LCD.
* Added 13.5kHz versions of TV modes (selected by Hdr:Machine).
* Upped desktop version to 5.06.

Version 5.35, 4.79.2.66. Tagged as 'Kernel-5_35-4_79_2_66'
@
text
@d548 2
a549 5
        MOV     r0, #4_3330                     ; Fudge 1 - VGA
;        MOV     r0, #4_3111                     ; Fudge 2 - no connection - will do LCD

        AddressHAL
        CallHAL HAL_MonitorLeadID
d551 1
a551 1
        STRB    r0, [r1, #MonitorLeadType]
@


4.17.2.14
log
@     several mode:
     1: default ticker based vsync generated whenever no device present to do so
     2: graphicsv handling and spec updated to use the hi 8 bits in the
        reason code (R4) to define the display number. Kernel only knows
        of display 0
Detail:
Admin:
     tested castle  castle added ip


Version 5.35, 4.79.2.81. Tagged as 'Kernel-5_35-4_79_2_81'
@
text
@a146 4
        CallHAL HAL_IRQClear            ; clear timer 0 IRQ
        MOV     R0, R4
        CallHAL HAL_IRQEnable           ; enable timer 0 IRQ

d151 6
a156 3
        CMP     R5, #-1
        MOVNE   R0, R5
        CallHAL HAL_IRQEnable, NE       ; enable vsync IRQ
@


4.17.2.15
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d71 1
a71 1
        LDR     R0, =ZeroPage+4*(NBuffers-1) ; index to pointer
d178 2
a179 2
        LDR     R1, =ZeroPage
        LDR     R0, [R1, #RTCFitted]
d237 1
a237 1
        LDR     R2, =ZeroPage+VduDriverWorkSpace+CursorFlags
d274 1
a274 1
        LDR     r1, =ZeroPage+VduDriverWorkSpace+CurrentMonitorType ; set current to default
d318 1
a318 1
        LDR     R0, =ZeroPage
d321 1
a321 2
        LDR     r0, =ZeroPage           ; allow SWI Portable_Speed to be issued
        ASSERT  (ZeroPage :AND: 255) = 0
d368 1
a368 1
        LDR     R2, =ZeroPage
d390 1
a390 1
        LDR     R2, =ZeroPage
d554 1
a554 1
        LDR     r1, =ZeroPage
a813 1
      [ ZeroPage = 0
a815 5
      |
        LDR     r2, =ZeroPage
        MOV     r1, #Service_MonitorLeadTranslation
        LDRB    r2, [r2, #MonitorLeadType]
      ]
d880 1
a880 1
 [ StorkPowerSave :LAND: :LNOT: HAL
d1197 1
a1197 13
        ; Check for extended ID first
        MOV     r0, #0
        CallHAL HAL_ExtMachineID
        CMP     r0, #0
        BEQ     %FT10
        MOV     r2, sp
        SUB     r0, r2, r0
        BIC     r0, r0, #3
        MOV     sp, r0
        Push    "r0,r2" ; Remember old SP, buffer pointer
        CallHAL HAL_ExtMachineID
        Pull    "r1"
        MOV     r2, #0
a1198 28
05
        ; Construct the 7 byte machine ID using this simple algorithm:
        ; EOR each extended ID byte with the low byte of the 7 byte ID,
        ; then rotate left 7 bits
        LDRB    r12, [r1], #1
        EOR     r2, r2, r12
        AND     r12, r3, #&fe0000
        MOV     r3, r3, LSL #7
        ORR     r3, r3, r2, LSR #25
        MOV     r2, r2, LSL #7
        ORR     r2, r2, r12, LSR #17
        SUBS    r0, r0, #1
        BNE     %BT05
        LDR     sp, [sp] ; Restore SP
      [ ZeroPage <> 0
        LDR     r0, =ZeroPage
      ]
        STR     r2, [r0, #RawMachineID+0]
        STR     r3, [r0, #RawMachineID+4]
        ; Abuse CheckCRC to calculate CRC byte
        BL      CheckCRC
        LDR     r0, =ZeroPage
        STRB    r2, [r0, #RawMachineID+7]
        EXIT
        
10
        CallHAL HAL_MachineID
        LDR     r3, =ZeroPage
a1386 1
      [ ZeroPage = 0
a1388 5
      |
        LDR     lr, =ZeroPage
        STR     r0, [lr, #RawMachineID+0]       ; indicate no ID by putting zero here
        STR     r0, [lr, #RawMachineID+4]
      ]
d1392 1
a1392 2
        ; Note: artificial ID generator relies on the required CRC being returned in R2!
        LDR     r1, =ZeroPage+RawMachineID      ; pointer to current byte
@


4.17.2.16
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d352 1
a352 1
        BYTEWS  WsPtr
@


4.17.2.16.2.1
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d550 5
a555 1
        MOV     r0, #4_3330                             ; Assume VGA during osinit
d558 1
a558 1
        MOV     r2, #0                                  ; Deprecated, just zero it
@


4.17.2.17
log
@Make GraphicsV_IICOp more consistent
No accepts  r0 = b31-24 set 0
                 b23-16 fully qualified IIC address
                 b15-0  starting offset
            r1 = buffer pointer
            r2 = number of bytes to tranfer
            r4 = b31-24 display number
                 b23-16 head
                 b15-0  reason code (=14)
Now returns r0 = result codes as per HAL_IICTransfer()
            r1 = buffer pointer incremented by number of bytes transferred
            r2 = number of bytes *not* transferred
            r4 = 0
Removed '_' after Video in entry numbers to be consistent with other HAL entry naming, and HAL_VideoFlybackDevice.
Added IICStatus return numbers to Hdr:HALEntries.
Stop calling HAL_MonitorLeadID as only IOMD implemented it - just guess VGA until the graphics driver says otherwise.

Version 5.35, 4.79.2.159. Tagged as 'Kernel-5_35-4_79_2_159'
@
text
@d550 6
a555 1
        MOV     r0, #4_3330                             ; Assume VGA during osinit
d558 1
a558 1
        MOV     r2, #0                                  ; Deprecated, just zero it
@


4.17.2.18
log
@Fix hang on startup with high processor vectors
Detail:
  s/PMF/osinit - MonitorLeadType is now stored in ZeroPage again, instead of at whatever R1 happens to point at (which seemed to be 0 when I tried it)
Admin:
  Tested on BB-xM with high processor vectors


Version 5.35, 4.79.2.162. Tagged as 'Kernel-5_35-4_79_2_162'
@
text
@a549 1
        LDR     r1, =ZeroPage
@


4.17.2.19
log
@Add *CONFIGURE [No]Num for control over the num lock state
STB default = off, desktop default = on.
Collapsed single use of 'ErrorsInR0' switch.

Version 5.35, 4.79.2.167. Tagged as 'Kernel-5_35-4_79_2_167'
@
text
@d17 5
d25 8
d266 5
a270 8
        MOVS    R1, R0, LSL #(32-5)     ; bit 5 -> carry, bit 4 -> N bit
        MOVPL   R1, #KBStat_NoShiftLock + KBStat_ShiftEnable ; SHCAPS
        MOVMI   R1, #KBStat_NoShiftLock + KBStat_NoCapsLock  ; NOCAPS
        MOVCS   R1, #KBStat_NoShiftLock                      ; CAPS
        TST     R0, #1:SHL:7                                 ; [NO]NUM
        ORRNE   R1, R1, #KBStat_NoNumLock
        BICEQ   R1, R1, #KBStat_NoNumLock
        STRB    R1, KeyBdStatus
d457 1
a457 1
  = &30                 ; KeyBdStatus  # 1   ; &CA
@


4.17.2.20
log
@Actually pay attention to configured cache preferences
The kernel recently took back ownership of the *CACHE command and it's configure counterpart, but wasn't reading the CMOS value on startup.
Spotted while looking at bus transactions on IOMD, and wondering where they all are, then realising it's all running from the cache.

Version 5.35, 4.79.2.170. Tagged as 'Kernel-5_35-4_79_2_170'
@
text
@a261 9
        MOV     R0, #SystemSpeedCMOS
        BL      Read
        TST     R0, #&20                ; Cache off when b5 set
        LDR     R2, =:NOT: (MMUC_I + MMUC_C + MMUC_W)
        LDRNE   R1, =0
        LDREQ   R1, =MMUC_I + MMUC_C + MMUC_W
        MOV     R0, #MMUCReason_ModifyControl
        BL      MMUControlSub
        
@


4.17.2.21
log
@Adopt some switches from Hdr:Machine/Machine
SystemName, ROMSizeOffset, HAL32, HAL26 only used here, moved here.
Remove uses of "M_" booleans, apparently that's bad form.
Fix SWIDespatch_Size for the non thumb capable case (was ASSERTing).
Swapped UserMemStart for AppSpaceStart.
Removed last use of OldComboSupport (pre Medusa!).
Removed switch 'CDVPoduleIRQs', a correction to the machine definitions mean this can now simply be switched on NumberOfPodules (previously, IOMD couldn't chain podule interrupts).
Take out disabled sub interrupt support - it's in CVS if you want to try to get it working.
Moved ConfiguredLang to 11 for everyone, it only matters if !Boot fails, and no harm in making it common for 5.xx onwards.

Version 5.35, 4.79.2.183. Tagged as 'Kernel-5_35-4_79_2_183'
@
text
@d945 2
a946 1
;
@


4.17.2.22
log
@Announce an RTC sync with a service call
Step changes in RealTime are now accompanied by a service call. Note the initial read isn't announced, mainly because this is before the module chain is started so nobody's listening anyway.

Version 5.35, 4.79.2.193. Tagged as 'Kernel-5_35-4_79_2_193'
@
text
@d350 1
a350 1
        Push    "R1,R12,LR"
d354 1
a354 3
        MOV     R1, #Service_RTCSynchronised
        IssueService
        Pull    "R1,R12,LR"
@


4.17.2.23
log
@Little kernel patches
hdr/ExportVals: the copyright header insertion got a bit confused with some of the file contents
TickEvents.s: a bad merge from Ursula branch 4.1.4.2 to trunk 4.2 left behind unmatched push/pull where TickIrqReenter had been removed
hdr/Options & NewIRQs.s: collapse remaining TickIrqReenter switches
osinit.s: when ZeroPage is in a top bit set address only the last buffer pointer would get zeroed

Tip offs from eagle eyed Tim Baldwin.

Version 5.35, 4.79.2.201. Tagged as 'Kernel-5_35-4_79_2_201'
@
text
@a59 1
        MOV     R2, #NBuffers-1
d63 1
a63 2
        SUB     R0, R0, #4
        SUBS    R2, R2, #1
@


4.17.2.24
log
@Migrate RTC driver out of the kernel
The kernel will use RTC_Read and RTC_Write to access the hardware clock, while maintaining the software clock as before.
Makefile: header export is now in the RTC module's sources
KernelWS: remove RTCFitted flag
NewReset: sync the time after the module init
i2cutils: deleted clock chip code
osinit: move OS_ResyncTime into PMF/realtime
realtime: mostly packages up ordinals and calls the respective SWI

Tested on IOMD softload.

Version 5.35, 4.79.2.202. Tagged as 'Kernel-5_35-4_79_2_202'
@
text
@d163 2
a164 2
; The RTC driver is later on in the module chain, or missing, for now default the
; system time to UNIX epoch + 1 day (so time() doesn't return -1)
d166 5
d174 4
d180 1
d344 19
@


4.17.2.25
log
@Assorted GraphicsV improvements
Detail:
  This set of changes:
  * Adds basic support for multiple GraphicsV drivers, by way of some new OS_ScreenMode reason codes for registering/deregistering, selecting and enumerating drivers (11, 64-68)
  * Tidies up handling of HAL video calls so that the HAL calls will be transformed into a bona fide GraphicsV driver if they're implemented
  * Changes handling of 16bpp gamma table entries so that they're sent to GraphicsV in a generic form instead of in a VIDC-specific form
  * Adds a new GraphicsV call and defines new VIDC list items to allow GraphicsV drivers to utilise the new pixel formats
  File changes:
  * h/VIDCList, hdr/VIDCList, Makefile - Add new header export containing VIDC list type 3 definitions, to avoid repeated definitions in other components
  * Resources/UK/Messages - Add new GraphicsV/OS_ScreenMode error strings and some missing processor type strings
  * hdr/KernelWS - Clean up some pre-GraphicsV definitions, and add new workspace locations for storing the current GraphicsV driver number and the driver list
  * hdr/Options - Remove obsolete InverseTextTransparency option
  * hdr/VduExt - Add VDU variable 192 for storing GraphicsV driver number (same as ROL's VideoV driver number). Remove old 'Flag_*' mode flag definitions (use new 'ModeFlag_*' defintions instead). Add new OS_ScreenMode reason codes.
  * s/ARM600, s/VMSAv6, s/vdu/vdu23, s/vdu/vdugrafa, s/vdu/vdugrafd, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduwrch - Strip out pre-GraphicsV code. Update GraphicsV code to use correct driver number.
  * s/ArthurSWIs - Pass the default GraphicsV claimant the VduDriverWorkSpace instead of ZeroPage
  * s/Getall - Add Hdr:VIDCList and s/vdu/VduGrafHAL to list of GETs
  * s/NewIRQs - Remove HAL VSync IRQ initialisation, is now handled by grafvhal. Remove old HAL VsyncIRQ entry point, all VSyncs are now handled by VsyncIRQ_ExtEntry.
  * s/PMF/osbyte - Stop OS_Byte 19 waiting forever if no video driver is active
  * s/PMF/osinit - Remove HAL VSync IRQ initialisation, is now handled by grafvhal
  * s/vdu/vducursoft - Use new workspace variable names and flag names
  * s/vdu/vdudecl - Remove old HALDAG_* definitions, GVDAG_* definitions are used instead. Add definition of the per-driver workspace structure and flags.
  * s/vdu/vdudriver - Remove pre-GraphicsV code. Update InitialiseMode to check for and initialise a HAL driver. Use cached driver features word in a few places instead of calling GraphicsV each time. Update PalIndexTable to disable VIDC mangling of 16bpp gamma tables.
  * s/vdu/vdugrafv, s/vdu/vdugrafhal - HAL<->GraphicsV code split off into its own file (vdugrafhal). Default GraphicsV claimant now only deals with VSync events for the active driver.
  * s/vdu/vdumodes - Get rid of old VIDC List type 3 definiton; now in hdr/VIDCList
  * s/vdu/vduswis - Added OS_ScreenMode reason codes 11 and 64-68 for registering, deregistering, selecting and enumerating GraphicsV drivers. Update mode set code to not bother checking if the driver supports the pixel format; instead we assume that the driver's vet mode call will do the check for us.
Admin:
  Tested in Tungsten, IOMD, OMAP3 & BCM2835 ROMs
  Requires HdrSrc-2_38 and updated video driver modes


Version 5.35, 4.79.2.203. Tagged as 'Kernel-5_35-4_79_2_203'
@
text
@d139 8
@


4.17.2.26
log
@Change handling of GraphicsV_StartupMode. Fix OS_CheckModeValid for variable framestore case.
Detail:
  s/PMF/osinit, s/vdu/vdudriver - Move GraphicsV_StartupMode call from InitialiseMode to TranslateMonitorLeadType. This means (a) it'll only be used if the CMOS mode is set to 'auto' and (b) the returned mode can more easily be read by other modules via OS_ReadSysInfo 1.
  s/vdu/vduswis - Make OS_CheckModeValid act as if we have practically unlimited screen memory if using a GraphcisV driver with variable external framestore. In this case it's the driver should have already OK'd the memory requirements from within the VetMode call issued by FindOKMode - although the check won't be fully valid if we're checking for a shadow mode as the driver currently isn't told how many screen banks are required.
Admin:
  Tested on Raspberry Pi
  OS_CheckModeValid fix ensures valid modes which require large amounts of VRAM are reported correctly when we're currently in a low-memory mode


Version 5.35, 4.79.2.220. Tagged as 'Kernel-5_35-4_79_2_220'
@
text
@a808 11

        ; Give the current GraphicsV driver a chance to specify a better mode
        ; than whatever we've picked here
        Push    "r4"
        MOV     r0, r3
        VDWS    r4
        LDR     r4, [r4, #CurrentGraphicsVDriver]
        ORR     r4, r4, #GraphicsV_StartupMode
        BL      CallGraphicsV
        Pull    "r4"
        MOV     r3, r0
@


4.17.2.27
log
@Fix GraphicsV_StartupMode call. Fix HiProcVecs build.
Detail:
  s/MemInfo - Fixed typo causing build error with HiProcVecs/zero page relocated kernel
  s/PMF/osinit - Fix the call to GraphicsV_StartupMode to work correctly with non-zero driver numbers
Admin:
  Tested on BB-xM with high processor vectors


Version 5.35, 4.79.2.226. Tagged as 'Kernel-5_35-4_79_2_226'
@
text
@a815 1
        MOV     r4, r4, LSL #24
@


4.17.2.28
log
@Add a means to write NetStnCMOS in a HAL world
With ProtectStationID turned on there are no routes to writing the Econet station (or bottom octect of the IP address), a function previously fulfilled by the SetStation utility which pokes the hardware directly and doesn't fit into a HAL model.
Add a new subreason to OS_NVMemory to perform this role. This SWI appeared for RISC OS 5.00, and errors unsupported subreasons, so there's a means of run tim selecting its use by checking the platform class and trying the SWI. All RISC OS 5 based platforms can always be upgraded to this version, since they're all still being maintained.

hdr/Options: move the switch with the other options from osinit.s
i2cutils.c: new subreason

Ditch the 'ObsoleteNC1CMOS' switch, if it was obsolete for NC1, it's certainly obsolete now.
Ditch unmaintained messages files for Morris4/Omega/Ursula projects.
Tested on a Risc PC.

Version 5.35, 4.79.2.247. Tagged as 'Kernel-5_35-4_79_2_247'
@
text
@d17 3
@


4.17.2.29
log
@Improve support for VMSAv6 cache policies & memory types. Expose raw ARMops via OS_MMUControl & cache information via OS_PlatformFeatures.
Detail:
  Docs/HAL/ARMop_API - Document two new ARMops: Cache_Examine and IMB_List
  hdr/KernelWS - Shuffle workspace round a bit to allow space for the two new ARMops. IOSystemType now deleted (has been deprecated and fixed at 0 for some time)
  s/ARM600 - Cosmetic changes to BangCam to make it clearer what's going on. Add OS_MMUControl 2 (get ARMop) implementation.
  s/ARMops - Switch out different ARMop implementations and XCB tables depending on MMU model - helps reduce assembler warnings and make it clearer what code paths are and aren't possible. Add implementations of the two new ARMops. Simplify ARM_Analyse_Fancy by removing some tests which we know will have certain results. Use CCSIDR constants in ARMv7 ARMops instead of magic numbers. Update XCB table comments, and add a new table for VMSAv6
  s/ChangeDyn - Define constant for the new NCB 'idempotent' cache policy (VMSAv6 normal, non-cacheable memory)
  s/HAL - Use CCSIDR constants instead of magic numbers. Extend RISCOS_MapInIO to allow the TEX bits to be specified.
  s/Kernel - OS_PlatformFeatures 33 (read cache information) implementation (actually, just calls through to an ARMop)
  s/MemInfo - Modify VMSAv6 OS_Memory 0 cache/uncache implementation to use the XCB table instead of modifying L2_C directly. This allows the cacheability to be changed without affecting the memory type - important for e.g. unaligned accesses to work correctly. Implement cache policy support for OS_Memory 13.
  s/Middle - Remove IOSystemType from OS_ReadSysInfo 6.
  s/VMSAv6 - Make sure BangCam uses the XCB table for working out the attributes of temp-uncacheable pages instead of manipulating L2_C directly. Add OS_MMUControl 2 implementation.
  s/AMBControl/memmap - Update VMSAv6 page table pokeing to use XCB table
  s/PMF/osinit - Remove IOSystemType reference, and switch out some pre-HAL code that was trying to use IOSystemType.
Admin:
  Tested on Iyonix, ARM11, Cortex-A7, -A8, -A9, -A15
  Note that contrary to the comments in the source the default NCB policy currently maps to VMSAv6 Device memory type (as per previous kernel versions). This is just a temporary measure, and it will be switched over to Normal, non-cacheable once appropriate memory barriers have been added to the affected IO code.


Version 5.35, 4.79.2.273. Tagged as 'Kernel-5_35-4_79_2_273'
@
text
@d517 3
a892 1
 [ :LNOT: HAL
a1163 1
 ] ; :LNOT: HAL
@


4.17.2.14.2.1
log
@Add HAL RTC support to Cortex branch of kernel, clean up RTCSupport code
Detail:
  HAL kernels (on the Cortex branch at least) now support HALDevice-based RTCs. If the kernels own RTC code is disabled or fails to detect an RTC, then after HAL_InitDevices is called the HALDevice list will be scanned for any HAL-resident RTC devices.
  Additionally, the RTCSupport flag (in Hdr:Machine.Machine), which was previously TRUE for all HAL kernels, can now be set to FALSE in HAL kernels to disable the kernels own IIC RTC code. This allows the unwanted legacy RTC code to be disabled for machines which are known to use HAL RTCs instead.
  hdr/RTCDevice - new header describing data structures used for HAL RTC device
  hdr/HALDevice - added RTCDevice device type, IIC serial bus type
  hdr/KernelWS - upgraded RTCFitted from a 1 byte field to 4 byte. It now stores either a null value (for no RTC), a value <2048 for an IIC RTC address, or a value >= 2048 for a RTCDevice ptr
  Makefile - added header export of hdr/RTCDevice
  s/GetAll - include hdr/RTCDevice
  s/NewReset - initialise HAL RTC after HAL_InitDevices if required
  s/PMF/i2cutils, s/PMF/osinit, s/PMF/osword - modifications to allow use of HAL RTC (and disallow use of builtin IIC RTC)
Admin:
  Tested on rev C2 beagleboard


Version 5.35, 4.79.2.98.2.11. Tagged as 'Kernel-5_35-4_79_2_98_2_11'
@
text
@d179 1
a179 1
        LDR     R0, [R1, #RTCFitted]
@


4.17.2.14.2.2
log
@Add OS_ReadSysInfo reason codes 11 (read debug info) & 12 (read extended machine ID)
Detail:
  OS_ReadSysInfo 10 is left unimplemented since it's a bit fiddly for us.
  OS_ReadSysInfo 11 is compatible with ROL's implementation, exposing HAL_DebugTX and HAL_DebugRX if the HAL provides them.
  See here for 10,11 docs: http://select.riscos.com/prm/core/osreadsysinfo.html
  OS_ReadSysInfo 12 is a new call to return the 'extended machine ID', to allow the HAL to specify the format & validity of the ID.
  If the HAL responds to the new HAL_ExtMachineID call then it's assumed that no old-style machine ID is present. The Kernel will generate an old-style ID using the contents of the extended ID, and use that with OS_ReadSysInfo 2/5.
  New software should use OS_ReadSysInfo 12 in preference to 2/5.
  s/Middle - Updated OS_ReadSysInfo SWI
  s/PMF/osinit - New old-style machine ID initialisation code
  hdr/HALEntries - Added new HAL_ExtMachineID entry
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.34. Tagged as 'Kernel-5_35-4_79_2_98_2_34'
@
text
@a1196 37
        ; Check for extended ID first
        MOV     r0, #0
        CallHAL HAL_ExtMachineID
        CMP     r0, #0
        BEQ     %FT10
        MOV     r2, sp
        SUB     r1, r2, r0
        BIC     r1, r1, #3
        MOV     sp, r1
        Push    "r1,r2" ; Remember old SP, buffer pointer
        CallHAL HAL_ExtMachineID
        Pull    "r1"
        MOV     r2, #0
        MOV     r3, #0
05
        ; Construct the 7 byte machine ID using this simple algorithm:
        ; EOR each extended ID byte with the low byte of the 7 byte ID,
        ; then rotate left 7 bits
        LDRB    r12, [r1], #1
        EOR     r2, r2, r12
        AND     r12, r3, #&fe0000
        MOV     r3, r3, LSL #7
        ORR     r3, r3, r2, LSR #25
        MOV     r2, r2, LSL #7
        ORR     r2, r2, r12, LSR #17
        SUBS    r0, r0, #1
        BNE     %BT05
        LDR     sp, [sp] ; Restore SP
        STR     r2, [r0, #RawMachineID+0]
        STR     r3, [r0, #RawMachineID+4]
        ; Abuse CheckCRC to calculate CRC byte
        BL      CheckCRC
        MOV     r0, #0
        STRB    r2, [r0, #RawMachineID+7]
        EXIT
        
10
a1391 1
        ; Note: artificial ID generator relies on the required CRC being returned in R2!
@


4.17.2.14.2.3
log
@Tweak HAL_ExtMachineID to take the buffer pointer in R0 instead of R1
Detail:
  s/Middle, s/PMF/osinit - Kernel now passes the buffer pointer to the HAL in R0 instead of R1, for ATPCS compliance.
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.35. Tagged as 'Kernel-5_35-4_79_2_98_2_35'
@
text
@d1203 4
a1206 4
        SUB     r0, r2, r0
        BIC     r0, r0, #3
        MOV     sp, r0
        Push    "r0,r2" ; Remember old SP, buffer pointer
@


4.17.2.14.2.4
log
@Add ID's for CPUClk HAL device. Trim dead code.
Detail:
  hdr/HALDevice - Added device type & ID for new CPUClk device, as used by the new OMAP3 HAL/PortableHAL versions.
  s/PMF/osinit - Disable a block of dead code that was getting compiled in.
Admin:
  Tested on rev C2 BB, rev A2 BB-xM, rev C1 TouchBook
  These changes are needed by the latest OMAP3 HAL & PortableHAL versions.


Version 5.35, 4.79.2.98.2.36. Tagged as 'Kernel-5_35-4_79_2_98_2_36'
@
text
@d880 1
a880 1
 [ StorkPowerSave :LAND: :LNOT: HAL
@


4.17.2.14.2.5
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d71 1
a71 1
        LDR     R0, =ZeroPage+4*(NBuffers-1) ; index to pointer
d178 1
a178 1
        LDR     R1, =ZeroPage
d237 1
a237 1
        LDR     R2, =ZeroPage+VduDriverWorkSpace+CursorFlags
d274 1
a274 1
        LDR     r1, =ZeroPage+VduDriverWorkSpace+CurrentMonitorType ; set current to default
d318 1
a318 1
        LDR     R0, =ZeroPage
d321 1
a321 2
        LDR     r0, =ZeroPage           ; allow SWI Portable_Speed to be issued
        ASSERT  (ZeroPage :AND: 255) = 0
d368 1
a368 1
        LDR     R2, =ZeroPage
d390 1
a390 1
        LDR     R2, =ZeroPage
d554 1
a554 1
        LDR     r1, =ZeroPage
a813 1
      [ ZeroPage = 0
a815 5
      |
        LDR     r2, =ZeroPage
        MOV     r1, #Service_MonitorLeadTranslation
        LDRB    r2, [r2, #MonitorLeadType]
      ]
a1224 3
      [ ZeroPage <> 0
        LDR     r0, =ZeroPage
      ]
d1229 1
a1229 1
        LDR     r0, =ZeroPage
d1235 1
a1235 1
        LDR     r3, =ZeroPage
a1423 1
      [ ZeroPage = 0
a1425 5
      |
        LDR     lr, =ZeroPage
        STR     r0, [lr, #RawMachineID+0]       ; indicate no ID by putting zero here
        STR     r0, [lr, #RawMachineID+4]
      ]
d1430 1
a1430 1
        LDR     r1, =ZeroPage+RawMachineID      ; pointer to current byte
@


4.16
log
@  Monotonic time was returned with a 1 cs error in certain circumstances.
Detail:
  Most of the centisecond timers were incremented very early in the Timer0
  interrupt routine, but MetroGnome was incremented after we had called
  TickerV. Routines on TickerV are allowed to enable interrupts, so any
  interrupt routines that use OS_ReadMonotonicTime and IRQRQA are unable to
  accurately determine if the monotonic time is one tick out-of-date or not.
  MetroGnome is now incremented with the other timers.
Admin:
  Tested with the timer code in STB-400 MPEGDriver.

Version 5.22. Tagged as 'Kernel-5_22'
@
text
@a101 6
 [ DriversInKernel
        MOV     R1, #DIVRESET6850       ; reset 6551
        MOV     R2, #0
        BL      ModifyControl6850
 ]

a138 15
 [ DriversInKernel
; reset ACIA

        LDR     R11, =ACIA

        LDRB    R0, ACIAStatus          ; set up DCD, DSR bits in SerialFlags
        AND     R0, R0, #(ACIADSR :OR: ACIADCD)
        MOV     R0, R0, LSL #DCDDSRShift
        STR     R0, SerialFlags         ; other bits are zero

        LDRB    R0, ACIACommand
        ORR     R0, R0, #ACIADTR        ; enable transmit and receive
        STRB    R0, ACIACommand
 ]

a140 16
        [ :LNOT: NewClockChip
        MOV     R0, #0
        STRB    R0, SecondsTime         ; zero seconds and centiseconds
        STRB    R0, CentiTime

        LDRB    R0, [R1, #IOCControl]   ; load IOC control register
        AND     R0, R0, #rtc_minutes_bit
        STRB    R0, MinTick             ; Initialise the minute odd/even flag

        MOV     R0, #1
        STRB    R0, SecondsDirty        ; mark the seconds as dirty (non-zero)
        ]

 [ DriversInKernel
        MOV     R0, #timer0_bit :OR: pack_bit :OR: vsync_bit
 |
a141 1
 ]
a146 6
 [ DriversInKernel
        LDRB    R0, [R1, #IOCIRQMSKB]   ; enable 6551 interrupt
        ORR     R0, R0, #serial_bit
        STRB    R0, [R1, #IOCIRQMSKB]
 ]

a225 1
 [ :LNOT: DriversInKernel
a226 1
 ]
a236 12
 [ DriversInKernel
        MOV     R0, #PSITCMOS
        BL      Read
        MOV     R1, R0, LSR #2          ; baud bits now in bits 0..2
        AND     R1, R1, #7              ; 0 => 75, ... ,7 => 19200
        ADD     R1, R1, #1              ; 1 => 75, ... ,8 => 19200
        Push    R1
        BL      DoOsbyte07
        Pull    R1
        BL      DoOsbyte08
 ]

a243 8
 [ DriversInKernel
        MOV     R1, R0, LSR #5          ; bits 5..7 -> bits 0..2
        MOV     R1, R1, LSL #2          ; put in bits 2..4
        ORR     R1, R1, #&42            ; or in default 6850 bits
        MOV     R2, #0                  ; replace old value
        BL      ModifyControl6850
 ]

d347 1
a347 3
        MOV     R14, PC
        ORR     R2, R14, #I_bit
        TEQP    R2, #0                  ; disable IRQ
d360 1
a360 1
        TEQP    R14, #0
d372 3
a374 3
        MOV     R14, PC
        ORR     R2, R14, #I_bit
        TEQP    R2, #0                  ; disable IRQ
d387 1
a387 1
        TEQP    R14, #0                 ;Re-enable IRQ
a533 2
 [ IO_Type = "IOMD"
  [ MorrisSupport
a534 1
   [ {TRUE} ; ARM7500FE support
a542 8
   |
        LDRB    r0, [r12, #IOMD_ID0]
        CMP     r0, #&E7
        LDRB    r0, [r12, #IOMD_ID1]
        CMPEQ   r0, #&5B
        MOVEQ   r11, #IOST_7500                         ;EQ, Morris
        MOVNE   r11, #0                                 ;NE, assume Medusa
   ]
d559 1
a559 26
  |
        MOV     r0, #IOST_IOEB                  ; pretend we've got IOEB
  ]
 |
        TEQP    pc, #SVC_mode + I_bit + F_bit   ; disable IRQs and FIQs
        MOVNV   r0, r0
        LDR     r1, =IOEB_ASICPresent
        MOV     r0, #&FA
        STRB    r0, [r1]
        LDRB    r0, [r1]
        TEQP    pc, #SVC_mode + I_bit
        AND     r0, r0, #&0F
        TEQ     r0, #5                          ; must read 5 is ASIC present
        MOVNE   r0, #0                          ; no IOEB, LC or 82C710
        BNE     %FT10

; there is an IOEB ASIC present, so it's safe to test for LC ASIC

        LDR     r1, =LC_ASICPresent
        LDRB    r0, [r1]
        AND     r0, r0, #&0E                    ; bits 3210 should be 010x
        TEQ     r0, #&04
        MOVNE   r0, #IOST_IOEB                  ; IOEB but no LC
        MOVEQ   r0, #IOST_IOEB :OR: IOST_LC     ; IOEB and LC
10
 ]
a578 1
  [ MorrisSupport				; On Morris, monitor auto-detect has been moved to IOMD_CLINES
a584 3
  |
        LDR     r3, =IOMD_MonitorType
  ] ; MorrisSupport
a645 1
 [ VIDC_Type = "VIDC20"
a646 4
 |
        LDR     r0, =VIDCClockSelect            ; on VIDC1 we write to latch instead
 ]
 [ IO_Type = "IOMD"
a647 3
 |
        LDR     r3, =IOEB_MonitorType
 ]
a648 1
 [ VIDC_Type = "VIDC20"
a651 4
 |
        STRB    r1, [r0]                        ; set up normal Hsync
        MOV     r2, #4                          ; inverted Hsync
 ]
a670 1
 [ VIDC_Type = "VIDC20"
a671 3
 |
        STRB    r2, [r0]
 ]
a681 1
 [ VIDC_Type = "VIDC20"
a682 3
 |
        STRB    r1, [r0]
 ]
d931 1
a931 1
        TEQP    pc, #SVC_mode + I_bit + F_bit   ; Disable FIQ and IRQ
d1014 1
a1014 1
        TEQP    pc, #SVC_mode + I_bit   ; Restore IRQ/FIQ state
d1121 1
a1121 1
        TEQP    pc, #SVC_mode + I_bit + F_bit   ; Disable FIQ and IRQ
d1200 1
a1200 1
        TEQP    pc, #SVC_mode + I_bit   ; Restore IRQ/FIQ state
d1248 1
a1248 1
        TEQP    pc, #SVC_mode + I_bit + F_bit   ; Disable FIQ and IRQ
d1281 1
a1281 1
        TEQP    pc, #SVC_mode + I_bit   ; Restore IRQ/FIQ state
d1373 1
a1373 1
        TEQP    pc, #SVC_mode + I_bit + F_bit
d1409 1
a1409 1
        TEQP    pc, #SVC_mode + I_bit                   ; restore old interrupt state
d1418 1
a1418 1
        ORREQS  pc, lr, #V_bit
d1420 1
a1420 1
        BICEQS  pc, lr, #V_bit
d1427 3
a1429 1
        ORRS    pc, lr, #V_bit
d1446 1
d1450 1
a1450 1
        BICEQS  pc, lr, #V_bit
d1472 1
a1472 1
        BICS    pc, lr, #V_bit
d1490 3
a1492 3
        TEQ     r4, r2                          ; if incorrect
        ORRNES  pc, lr, #V_bit                  ; then exit indicating error
        BICS    pc, lr, #V_bit
@


4.15
log
@OS_ReadSysInfo 3 was incorrectly reporting a 37C665 as a 37C669.

Version 5.06. Tagged as 'Kernel-5_06'
@
text
@d497 1
a497 1
  = 0   ;&19            ; FlashCount # 1     ; &C1      /* changed to fx 9 0 by RCM 31/10/91 */
d499 1
a499 1
  = 0   ;&19            ; MarkPeriod # 1     ; &C3      /* changed to fx 9 0 by RCM 31/10/91 */
@


4.14
log
@Ensured that interrupts in C and D registers masked on reset.
Power down A to D convertors on reset.

Version 5.05. Tagged as 'Kernel-5_05'
@
text
@d1133 1
a1133 1
        MOV     r1, #IOST_37C669
d1172 2
a1173 1
        DCB     SMC_endconfig, 0	; Exit config mode
d1209 2
a1210 1
        DCB     SMC_endconfig, 0	; Exit config mode
@


4.13
log
@RCMM changes made the Kernel not report the type of I/O chip fitted correctly.
This has been fixed. In addition, SMC669 and UMC669 chips are reported as
a different chip configuration by OS_ReadSysInfo 3 (values 4 and 5
respectively).
A few assertions added to catch the remaining cases where the RCMM stuff
won't work - those cases will involve a bit more reordering of hardware
initialisation.

Version 5.00. Tagged as 'Kernel-5_00'
@
text
@d191 5
@


4.12
log
@Added RCMM keyboard support for Delete-power on, Ctrl-reset etc etc.
Right arrow on a remote also acts as Delete.

Version 4.98. Tagged as 'Kernel-4_98'
@
text
@d129 1
a129 1
 [ Keyboard_Type <> "RCMM"              ; On RCMM machines, this is done in SetUpKbd
d133 1
d660 4
a663 1
        STRB    r0, [r1, #IOSystemType]
d1113 1
a1113 2
        				;665s and 669s offer the same features as far as
        MOVEQ	r1, #IOST_37C665	; OS_ReadSysInfo(3) is concerned, so use same value for both
d1127 2
a1128 2
        					;665s and 669s offer the same features as far as
        MOV     r1, #IOST_37C665		; OS_ReadSysInfo(3) is concerned, so use same value for both
d1134 1
a1134 1
        BIC     lr, lr, #IOST_82C710 :OR: IOST_82C711 :OR: IOST_37C665
d1318 1
a1318 1
        BIC     lr, lr, #IOST_82C710 :OR: IOST_82C711 :OR: IOST_37C665
d1399 1
a1399 1
        BIC     lr, lr, #IOST_82C710 :OR: IOST_82C711 :OR: IOST_37C665
@


4.11
log
@Second attempt to fix PortableFlags corruption.

Version 4.95. Tagged as 'Kernel-4_95'
@
text
@d129 1
d142 1
@


4.10
log
@Kernel was accidentally storing PortableFlags in the wrong place.
Now calls XPortable_Idle, not Portable_Idle in key-wait code.
Calls Portable_Idle in OS_Byte 19.

Version 4.94. Tagged as 'Kernel-4_94'
@
text
@d356 1
@


4.9
log
@Kernel now uses PortManager to set TV_Mode GPIO line, and updates it on
every mode change, rather than doing it once based on the monitor lead ID.
Requires PortManager, and required if PortManager is present.

Version 4.92. Tagged as 'Kernel-4_92'
@
text
@d355 2
a356 2
        AND     R0, R1, #(PortableFeature_Speed :OR: PortableFeature_Idle :OR: PortableFeature_Stop)
        STRB    r0, [r0, #PortableFlags]
@


4.8
log
@Added ComboClock14MHz switch - only supported by SMC669.

Version 4.91. Tagged as 'Kernel-4_91'
@
text
@d422 1
a422 23
        [ STB
; *****************************************************************************
;
;       UpdateCLines - update IOMD_CLINES 8bit IO port
; In:
;	r3: new value
;	r4: mask of bits to set
;
; Out:
;	All regs preserved

UpdateCLines ENTRY "r0, r1"
	LDR	r0, =(IOMD_Base + IOMD_CLINES)
	LDRB	r1, [r0]
	ORR	r1, r1, #IOMD_C_ReadMask	; Set readable bits
	BIC	r1, r1, r4			; Clear bits to write
	ORR	r1, r1, r3			; Set bits to write
	STRB	r1, [r0]
	EXIT


; *****************************************************************************
        |
a865 8
  [ STB :LAND: IOMD_C_TVMode <> 0				; set the TVMode to 0 (VGA) if id bits1,0 != 01 (TV)
        AND	r3, r2, #2_11			; bits we're interested in
	CMP	r3, #2_01			; TV?
	BEQ	%FT90				; yes
	MOV	r3, #0
	MOV	r4, #IOMD_C_TVMode
	BL	UpdateCLines
  ]
@


4.7
log
@* Meaning of FEIOSpeedHalf was accidentally inverted.
* Wasn't allowing writes to most of EEPROM.
* Old prototype OS_SetTime SWI code removed.
* MPEGPoduleNTSCNotPALMask option support removed to simplify things a bit.
* Now can cope with a system with a PAL/NTSC link, but no monitor detect line.
* Default PAL & NTSC modes now always 12 & 46 respectively.
* Kernel now knows about monitor type 8 (NTSC) - modes 44-46 (640x200) are
  available.
* STB/NC CMOS test removed from POST pending further investigation.

Version 4.90. Tagged as 'Kernel-4_90'
@
text
@d1209 5
a1213 1
	DCB	&10, 2_01000000		; 24MHz input to PLL (*not* default)
@


4.6
log
@Num lock on by default on STB/NC products.

Version 4.70. Tagged as 'Kernel-4_70'
@
text
@d686 4
d694 3
d699 1
a699 18
    [ IOMD_C_MonitorType = 0			; Monitor auto-detect not supported:
     [ MPEGPoduleNTSCNotPALMask <> 0
	BEQ	%FT15				; not an IOMD-style machine, so skip any STB stuff
	LDR	r3, =MPEGPoduleNTSCNotPALAddress ; point at podule status register
	LDRB	r2, [r3]
	TST	r2, #MPEGPoduleNTSCNotPALMask	; test PAL/NTSC bit
	MOVEQ	r2, #4_0331			; if bit clear then PAL TV
	MOVNE	r2, #4_1331			; if bit set then NTSC TV
	B	%FT90
15
     |
        MOVNE	r2, #&FF                        ; then return all ones for monitor lead type
        BNE	%FT90
     ]
    |
	ASSERT	(IOMD_C_MonitorType = (1<<0))	; this code only understands auto-detect in bit 0
	LDRNE	r3, =(IOMD_Base + IOMD_CLINES)
    ]
d702 1
a702 1
  ]
d762 1
a762 1
        |
d846 1
a846 1
        ]
d973 6
a978 4
    [ MPEGPoduleNTSCNotPALMask <> 0
        MonitorLeadItem 4_0331,  50, 0, 0                       ; PAL TV interlaced overscanned
        MonitorLeadItem 4_1331,  58, 8, 0                       ; NTSC TV interlaced overscanned
    ]
d984 2
a985 2
        MonitorLeadItem 4_0331,  50, 0, 0                       ; PAL TV interlaced overscanned
        MonitorLeadItem 4_1331,  58, 8, 0                       ; NTSC TV interlaced overscanned
@


4.5
log
@ROM speed not taken from the Machine header file.  POST can now exist
in a softloaded OS, since it searches for a zero word in the ROM
instead of using one within the POST when trying to communicate with
the POST adapter (the zero word must be in ROM).  Fixed to build on
non-chrontel STB/NC products.  Lots of duplicate code merged in
MemSize.  MemSize copes better with the softload case, and is less
willing to use the region the OS occupies as video memory, or
page tables.  POST is now ON (memory tests disabled).
OS_ReadSysInfo 4 now uses the NVRAM module to access the ethernet
address in NVRAM/CMOS, so that the availability/location of the
MAC address can be changed.  CMOS location 0 is now unprotected on
STB/NC products to try to stop people poking the hardware directly.
Fixed a CMOS resetting problem on STBs where the value expected in a
location was different from the value written on a CMOS reset, so the
CMOS would be reset every time...

Version 4.69. Tagged as 'Kernel-4_69'
@
text
@d25 8
d305 3
a307 3
        MOVPL   R0, #KBStat_NoShiftLock + KBStat_ShiftEnable    ; SHCAPS
        MOVMI   R0, #KBStat_NoShiftLock + KBStat_NoCapsLock     ; NOCAPS
        MOVCS   R0, #KBStat_NoShiftLock                         ; CAPS
d523 1
a523 1
  = &20                 ; KeyBdStatus  # 1   ; &CA
@


4.4
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d23 1
a23 1
ProtectStationID SETL {TRUE}
@


4.3
log
@RISC OS 3.71 kernel changes merged.
Not fully tested on all hardware permutations.
@
text
@d47 1
d59 1
a977 3
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
    |
        MonitorLeadItem 4_3333,  28, 3, 0                       ; assume VGA-capable monitors 256 colours
d980 2
a981 1
     [ IOMD_C_PALNTSCType = 0					; no PAL/NTSC bits:
d983 1
a983 2
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
     |								; wealth of bits:
d986 5
a990 4
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
     ]
   ]
  |
d993 1
a993 1
  ]
d1056 2
d1077 1
a1077 1
ConfigureCombo ENTRY "r0,r1"
d1082 2
d1085 2
a1086 2
        STRB    lr, [r0, #SMC_CSR]	; Write &55 to CSR twice
        STRB    lr, [r0, #SMC_CSR]	; to enter configuration mode
d1089 2
a1090 2
        STRB    lr, [r0, #SMC_CSR]
        LDRB    lr, [r0, #SMC_data]
d1095 16
a1110 2
	ADREQ	r1, ConfigSMC669Table
	BEQ	%FT20
d1142 2
d1145 5
a1149 5
        LDRB    lr, [r1], #1		; get config index
        STRB    lr, [r0, #SMC_CSR]
        TEQ     lr, #SMC_endconfig	; end of table?
        LDRNEB  lr, [r1], #1		; if not then get config data
        STRNEB  lr, [r0, #SMC_data]	; and write it
d1151 2
a1152 2
        				;665s and 669s offer the same features as far as
        MOV     r1, #IOST_37C665	; OS_ReadSysInfo(3) is concerned, so use same value for both
d1196 1
a1196 1
	DCB     &03, 2_01111000		; floppy stuff (default)
d1209 1
@


4.3.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d92 5
d128 1
d132 14
d162 3
d166 1
d172 5
d181 4
a184 4
        MOV     R1, #0
        LDRB    R0, [r1, #RTCFitted]
        TEQ     R0, #1
        BEQ     %FT28
d186 5
a190 5
secs0070 *      (86400*(365*70+18))     ; from time() in risc_oslib.c.armsys
        LDR     R7, =(secs0070 * 100)   ; centiseconds LSW
        MOV     R8, #&33                ; centiseconds MSW
        BL      Store5ByteInRealTime
        B       %FT30
d252 1
d254 1
d265 11
d284 7
d300 1
d304 1
d367 1
a367 1
        [ :LNOT: STB
d383 1
a383 1
        ]
d405 2
d417 2
a418 2
;       r3: new value
;       r4: mask of bits to set
d421 1
a421 1
;       All regs preserved
d424 7
a430 7
        LDR     r0, =(IOMD_Base + IOMD_CLINES)
        LDRB    r1, [r0]
        ORR     r1, r1, #IOMD_C_ReadMask        ; Set readable bits
        BIC     r1, r1, r4                      ; Clear bits to write
        ORR     r1, r1, r3                      ; Set bits to write
        STRB    r1, [r0]
        EXIT
d608 10
a617 1

d619 6
a624 8
        LDRB    r11, [r12, #IOMD_ID1]
        ORR     r0, r0, r11, LSL #8
        LDR     r11, =IOMD_Original
        TEQ     r0, r11
        MOVEQ   r11, #0                                 ; assume Medusa
        MOVNE   r11, #IOST_7500                         ; else assume Morris
        TEQ     r11, #IOST_7500                         ; and set EQ if Morris to do conditional stuff below

d626 4
a629 4
; On Kryten,    Morris pin Event2 is tied low so bit Nevent2 is a ONE
; On Stork,     Morris pin Event2 is tied high so bit Nevent2 is a ZERO
; On STB/NCD,   Morris pin Event2 is tied high so bit Nevent2 is a ZERO, but we don't have a LCD
;               controller or battery manager so we'll not set IOST_BATMAN
d645 21
d679 4
a682 4
  [ MorrisSupport                               ; On Morris, monitor auto-detect has been moved to IOMD_CLINES
        TST     R11, #IOST_7500
        LDREQ   r3, =IOMD_MonitorType           ; Not Morris, address is in old place
    [ IOMD_C_MonitorType = 0                    ; Monitor auto-detect not supported:
d684 7
a690 7
        BEQ     %FT15                           ; not an IOMD-style machine, so skip any STB stuff
        LDR     r3, =MPEGPoduleNTSCNotPALAddress ; point at podule status register
        LDRB    r2, [r3]
        TST     r2, #MPEGPoduleNTSCNotPALMask   ; test PAL/NTSC bit
        MOVEQ   r2, #4_0331                     ; if bit clear then PAL TV
        MOVNE   r2, #4_1331                     ; if bit set then NTSC TV
        B       %FT90
d693 2
a694 2
        MOVNE   r2, #&FF                        ; then return all ones for monitor lead type
        BNE     %FT90
d697 2
a698 2
        ASSERT  (IOMD_C_MonitorType = (1<<0))   ; this code only understands auto-detect in bit 0
        LDRNE   r3, =(IOMD_Base + IOMD_CLINES)
d711 3
a713 3
        ASSERT  (IOMD_C_PALNTSCType = (1<<4))   ; this code only understands PAL/NTSC auto-detect in bit 4
        AND     r4, r4, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
        ORR     r4, r4, r4, LSR #1              ; Shift PAL/NTSC bit into bit 3
d716 1
a716 1
        AND     r4, r4, #IOMD_C_MonitorType     ; only one bit
d738 2
a739 2
        AND     r6, r6, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
        ORR     r6, r6, r6, LSR #1              ; Shift PAL/NTSC bit into bit 3
d741 2
a742 2
        AND     r7, r7, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
        ORR     r7, r7, r7, LSR #1              ; Shift PAL/NTSC bit into bit 3
d745 2
a746 2
        AND     r6, r6, #IOMD_C_MonitorType     ; only one bit
        AND     r7, r7, #IOMD_C_MonitorType
d767 1
d772 1
d780 2
d805 1
d820 1
d888 7
a894 7
  [ STB :LAND: IOMD_C_TVMode <> 0                               ; set the TVMode to 0 (VGA) if id bits1,0 != 01 (TV)
        AND     r3, r2, #2_11                   ; bits we're interested in
        CMP     r3, #2_01                       ; TV?
        BEQ     %FT90                           ; yes
        MOV     r3, #0
        MOV     r4, #IOMD_C_TVMode
        BL      UpdateCLines
d972 1
a972 1
   [ IOMD_C_MonitorType = 0                                     ; no auto-detect bit
d981 1
a981 1
     [ IOMD_C_PALNTSCType = 0                                   ; no PAL/NTSC bits:
d984 1
a984 1
     |                                                          ; wealth of bits:
d995 14
d1052 1
a1052 1
ComboBase       *       &03010000       ; Base address of combo chip = PC/AT I/O 000H
d1055 7
a1061 7
SMC_CSR         *       &03F0 * 4       ; Configuration Select Register (CSR)
SMC_config      *       &55             ; value to write to enter configuration mode
SMC_endconfig   *       &AA             ; value to write to end configuration mode
SMC_IDreg       *       &0D             ; device ID register
SMC_data        *       &03F1 * 4       ; Configuration Access Port (data)
SMC_665         *       &65             ; 665 ID
SMC_669         *       &03             ; 669 ID
d1064 4
a1067 4
UMC_CSR         *       &0108 * 4       ; Configuration Select Register (CSR)
UMC_config      *       &AA             ; value to write to enter configuration mode
UMC_endconfig   *       &55             ; value to write to end configuration mode
UMC_data        *       &0109 * 4       ; Configuration Access Port (data)
d1073 1
a1073 1
        ASSERT  :LNOT: OldComboSupport
d1077 1
a1077 1
        LDR     r0, =ComboBase          ; R0->  Base address of combo chip
d1081 2
a1082 2
        STRB    lr, [r0, #SMC_CSR]      ; Write &55 to CSR twice
        STRB    lr, [r0, #SMC_CSR]      ; to enter configuration mode
d1087 6
a1092 6
        TEQ     lr, #SMC_665            ; 665 ?
        ADREQ   r1, ConfigSMC665Table
        BEQ     %FT20
        TEQ     lr, #SMC_669            ; 669 ?
        ADREQ   r1, ConfigSMC669Table
        BEQ     %FT20
d1095 1
a1095 1
        ADR     r1, ConfigUMC8669Table
d1097 1
a1097 1
        LDRB    lr, [r1], #1            ; get "Index Entry Valid"
d1099 3
a1101 3
        TEQ     lr, #UMC_endconfig      ; end of table?
        BEQ     %FT12
        LDRB    lr, [r1], #1            ; get config index
d1103 2
a1104 2
        LDRB    lr, [r1], #1            ; get config data
        STRB    lr, [r0, #UMC_data]     ; and write it
d1110 12
a1121 12
        STRB    lr, [r0, #UMC_CSR]      ; Write &AA to enter config mode
        MOV     lr, #&C0
        STRB    lr, [r0, #UMC_CSR]      ; CR0
        LDRB    r2, [r0, #UMC_data]
        MOV     lr, #UMC_endconfig      ; maybe don't need to do this
        STRB    lr, [r0, #UMC_CSR]      ; exit config mode
        TEQ     r2, #2_00111110         ; Value for CR0 from ConfigUMC8669Table

                                        ;665s and 669s offer the same features as far as
        MOVEQ   r1, #IOST_37C665        ; OS_ReadSysInfo(3) is concerned, so use same value for both
        MOVNE   r1, #0                  ; Don't know what this is, give up
        B       %FT30
d1123 1
a1123 1
;       SMC config loop
d1125 1
a1125 1
        LDRB    lr, [r1], #1            ; get config index
d1127 3
a1129 3
        TEQ     lr, #SMC_endconfig      ; end of table?
        LDRNEB  lr, [r1], #1            ; if not then get config data
        STRNEB  lr, [r0, #SMC_data]     ; and write it
d1131 2
a1132 2
                                        ;665s and 669s offer the same features as far as
        MOV     r1, #IOST_37C665        ; OS_ReadSysInfo(3) is concerned, so use same value for both
d1134 1
a1134 1
;       Record type of chip found
d1148 2
a1149 2
        DCB     &01, 2_10010111         ; Enable config, COM3@@338, COM4@@238, IRQs active hi,
                                        ; // is extended & powered @@278
d1151 2
a1152 2
        DCB     &01, 2_10000111         ; Enable config, COM3@@338, COM4@@238, IRQs active low,
                                        ; // is extended & powered @@278
d1154 15
a1168 15
        DCB     &02, 2_11011100         ; COM2 powered & enabled @@2F8, COM1 powered & enabled @@3F8
                                        ; (default)
        DCB     &03, 2_01111000         ; floppy stuff (default)
        DCB     &04, 2_00000011         ; EPP v1.9, MIDI disabled, normal //floppy,
                                        ; // uses ECP & EPP modes
        DCB     &05, 0                  ; 4 drive support, don't swap drives, normal density,
                                        ; FDC burst mode, IDE@@1F0-7,3F6-7, FDC@@3F0-7 (default)
;       DCB     &06, &FF                ; floppy drive types (default)
;       DCB     &07, 0                  ; don't auto-powerdown anything (default)
;       DCB     &08, 0                  ; ADRA7:4 address decode (default)
;       DCB     &09, 0                  ; ADRA10:8 address decode (default)
;       DCB     &0A, 0                  ; FIFO threshold for ECP // = ??? (default)
;       DCB     &0B, 0                  ; floppy data rates (default)
;       DCB     &0C, 0                  ; UART2 & UART1 standard speed, UART2 standard mode,
                                        ; UART2 full duplex, XMIT active hi, RCV active hi (default)
d1170 2
a1171 2
                                        ; IDE AT & enabled
        DCB     SMC_endconfig, 0        ; Exit config mode
d1174 27
a1200 27
        DCB     &01, 2_10010100         ; Enable config, // is extended, // is  powered
        DCB     &02, 2_10001000         ; COM2 powered, COM1 powered (default)
        DCB     &03, 2_01111000         ; floppy stuff (default)
        DCB     &04, 2_00000011         ; IR rx&tx on COM2 rx & tx pins, EPP v1.9, MIDI disabled,
                                        ; normal //floppy, uses ECP & EPP modes
        DCB     &05, 0                  ; 4 drive support, don't swap drives, normal density,
                                        ; FDC burst mode (default)
;       DCB     &06, &FF                ; floppy drive types (default)
;       DCB     &07, 0                  ; don't auto-powerdown anything
;       DCB     &08, 0                  ; ADRA7:4 address decode (default)
;       DCB     &09, 0                  ; ADRx disabled, ADRA10:8 address decode (default)
;       DCB     &0A, 0                  ; FIFO threshold for ECP // = ??? (default)
;       DCB     &0B, 0                  ; floppy data rates (default)
;       DCB     &0C, 0                  ; UART2 & UART1 standard speed, UART2 standard mode,
                                        ; UART2 full duplex, XMIT active hi, RCV active hi (default)
;       DCB     &1E, &80                ; GAMECS disabled (default)
;       DCB     &1F, 0                  ; floppy drive types (default)
        DCB     &20, &FC                ; FDC@@3F0-7
        DCB     &21, &7C                ; IDE@@1F0-7
        DCB     &22, &FD                ; IDE Alternate Status Register @@3F6
        DCB     &23, &9E                ; //@@278
        DCB     &24, &FE                ; COM1@@3F8
        DCB     &25, &BE                ; COM2@@2F8
        DCB     &26, 0                  ; no FDC DMA, no // DMA (default)
        DCB     &27, 2_01100101         ; FDC uses IRQ_F, // uses IRQ_E
        DCB     &28, 2_01000011         ; UART1 uses IRQ_D, UART2 uses IRQ_C
        DCB     &29, 0                  ; IRQIN does not use any IRQ_x (default)
d1202 1
a1202 1
        DCB     SMC_endconfig, 0        ; Exit config mode
d1205 9
a1213 9
        DCB     UMC_config, &C0, 2_00111110     ; IR full-duplex, games off, IDE on,
                                                ; // in EPP & ECP mode, UART2 on, UART1 on, FDC off
        DCB     UMC_config, &C1, 2_00101111     ; Direct access PnP register, Disable PnP,
                                                ; IDE@@1F0-7,3F6-7, //@@278, COM2@@2F8, COM1@@3F8,
                                                ; FDC@@3F0-7
        DCB     UMC_config, &C2, 2_10000001     ; Not supspended, IR unselected/disabled,
                                                ; don't swap floppy, IBM mode floppy,
                                                ; floppy is R/W (default)
        DCB     UMC_endconfig, 0                ; Exit config mode
d1236 87
d1326 20
d1550 13
@


4.3.2.1.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d92 12
a103 1
; note that Timer0 is already set up, so CMOS reads will be ok
d117 8
a125 14
Combo_eh
        MOV     r1,#IOMD_Base
        LDRB    r0,[r1,#IOMD_ID0]
  [ IOMD2Support
        TEQ     r0,#IOMD_IOMD2    :AND: &FF
        BEQ     Combo_Phoebe
  ]
  [ IOMD1Support
        TEQ     r0,#IOMD_Original :AND: &FF
        TEQNE   r0,#IOMD_7500     :AND: &FF
        TEQNE   r0,#IOMD_7500FE   :AND: &FF
        BEQ     Combo_IOMD1
  ]
        B       Combo_eh                    ;deliberate hang up
a126 4
  [ IOMD1Support
;
Combo_IOMD1
        BL      Configure37C665                  ;RiscPC, Kryten and Stork use only SMC 37C665
d128 14
d143 1
a143 1
        STRB    R0, [R1, #IOCIRQCLRA]            ; clear pending tim0, vsync irqs (+ pack irq if appropriate)
d146 1
a146 2
        STRB    R0, [R1, #IOCIRQMSKA]            ; Enable timer 0 + vsync irqs
        B       Combo_done
a147 1
  ] ;IOMD1Support
d149 15
a163 17
  [ IOMD2Support
;
Combo_Phoebe
        BL      ConfigureSMC672                  ;Phoebe uses only SMC 672
        MOV     r1, #IOMD_Base
        MOV     r0, #(1:SHL:6)                   ;vsync is bit 6  
        ORR     r0, r0, #(1:SHL:16)              ;timer0 is bit 16
        STR     r0, [r1, #IOMD2_INTREQ]          ;clear any pending vsync, timer0
        LDR     r0, [r1, #IOMD2_INTENBL]
        ORR     r0, r0, #(1:SHL:6)
        ORR     r0, r0, #(1:SHL:16)
        STR     r0, [r1, #IOMD2_INTENBL]         ;enable vsync and timer0 irqs

  ] ;IOMD2Support

;
Combo_done
d316 1
d332 1
d353 3
d359 23
d410 1
a548 1
;                         also does monitor lead type
d552 2
d555 1
a555 1
10
d557 7
a563 15
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     RMT_Phoebe                            ; IOMD2 (Phoebe)
        TEQ     r0, #IOMD_Original :AND: &FF
        BEQ     RMT_Medusa                            ; IOMD1 (Risc PC)
        TEQ     r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BEQ     RMT_Morris                            ; 7500 (A7000) or 7500FE (A7000+)
        B       %BT10                                 ; deliberate panic hang-up (unrecognised IOMD)

RMT_Phoebe
        MOV     r0, #IOST_IOEB                        ; pretend we've got IOEB
        MOV     r1, #0
        STRB    r0, [r1, #IOSystemType]
        MOV     r2, #0                                ; we can't do monitor lead detect, so assume VGA capable monitor
        B       %FT90
a564 10
RMT_Medusa
        MOV     r11, #0
        TEQ     r11, #1                               ; set NE for conditional stuff below
        B       RMT_common

RMT_Morris
        MOV     r11, #IOST_7500
        TEQ     r11, #IOST_7500                       ; set EQ for conditional stuff below
;
RMT_common
d568 2
d581 5
a585 1

d595 2
d598 86
d685 3
d689 2
d692 1
d696 2
d699 1
d703 3
d717 1
d719 4
d727 5
d733 4
d741 3
d757 4
d796 1
d799 1
d801 8
d882 1
d884 20
d906 3
a908 1

d945 1
d948 1
a948 1
;       ConfigureSMC672 - Configure SMC 672 (assumes we are on Phoebe)
d951 1
a951 1
  [ IOMD2Support
d953 8
a960 1
ComboBase         *       &03010000     ; Base address of combo chip = PC/AT I/O 000H
d962 5
a966 7
SMC_CSR           *       &03F0 * 4     ; Configuration Select Register (CSR)
SMC_config        *       &55           ; value to write to enter configuration mode
SMC_endconfig     *       &AA           ; value to write to end configuration mode
SMC_IDreg         *       &0D           ; device ID register
SMC_data          *       &03F1 * 4     ; Configuration Access Port (data)
SMC_672           *       &40           ; 672 ID
SMC_672_IDreg     *       &20
a967 3
command_RESETPS2  *  &AA
PS2_COMMAND       *  &64*4 
PS2_DATA          *  &60*4
d969 6
a974 1
ConfigureSMC672 ENTRY "r0,r1"
d976 1
a976 1
        LDR     r0, =ComboBase                  ; R0->  Base address of combo chip
d978 1
a978 1
; See if we have a SMC672 and try to configure it
d980 1
d983 1
a983 1
        MOV     lr, #SMC_672_IDreg
d986 2
a987 2
        TEQ     lr, #SMC_672            ; 672
        ADREQ   r1, ConfigSMC672Table
d989 16
d1006 14
a1019 2
; Not a SMC chip that we recognise
        MOV     r1, #0                  ; Don't know what this is, give up
d1030 1
a1030 1
                                        ;665s, 669s and 672s offer the same features as far as
d1034 1
a1040 20
; reset PS2 uC, just in case (eg. kbd activity during warm reset)
;
        LDR     lr, =ComboBase
        MOV     r0, #command_RESETPS2
        STRB    r0, [lr, #PS2_COMMAND]
20      LDRB    r0, [lr, #PS2_COMMAND]
        ANDS    r0, r0, #1
        BEQ     %BT20                   ;Wait until something comes back
        LDRB    r0, [lr, #PS2_DATA]

;       enable external interrupt 10 (ei10), wired as combo SMI interrupt
;
        MOV     r0, #IOMD_Base
        MOV     lr, #1 :SHL: 10
        STR     lr, [r0,#IOMD2_INTREQ]  ; clear any spurious level interrupt on ei10
        LDR     lr, [r0,#IOMD2_INTENBL]
        ORR     lr, lr, #1 :SHL: 10
        STR     lr, [r0,#IOMD2_INTENBL] ; enable ei10

30
d1044 57
a1100 64
ConfigSMC672Table
;Floppy Drive (8 regs, 3F0-3F7)
        DCB     &07, 0                  ; Config the FDC first.
        DCB     &60, &03                ; Address MSP
        DCB     &61, &F0                ; Address LSP
        DCB     &70, &05                ; Use IRQ6
        DCB     &74, &01                ; DMA channel 1
        DCB     &F0, 2_01001100         ; FDC cfg - Normal, Burst, AT-interface, Noswap, push-pull, active
        DCB     &F1, 2_00000000         ; FDC cfg - default
        DCB     &F2, 2_11111111         ; FDC cfg - default again
        DCB     &F4, 2_00000000
        DCB     &F5, 2_00000000
        DCB     &30, 2_00000001         ; Enable it

;Serial Port 1 (8 regs, 3F8-3FF)
        DCB     &07, &04                ; Config Serial Port 1
        DCB     &60, &03                ; Address MSP
        DCB     &61, &F8                ; Address LSP
        DCB     &70, &07                ; IRQ 7
        DCB     &74, &04                ; No DMA
        DCB     &F0, 2_00000000         ; No MIDI, HighSpeed disabled, Use unique IRQ
        DCB     &30, 2_00000001         ; Enable it

;Serial Port 2 (8 regs, 2F8-2FF)
        DCB     &07, &05                ; Config Serial Port 2
        DCB     &60, &02                ; Address MSP
        DCB     &61, &F8                ; Address LSP
        DCB     &70, &04                ; Use IRQ4
        DCB     &74, &04                ; No DMA
        DCB     &F0, 2_00000000         ; No MIDI, HighSpeed disabled
        DCB     &30, 2_00000001         ; Enable it

;Parallel Port (8 regs, 278-27F)
        DCB     &07, &03
        DCB     &60, &02                ; Address MSP
        DCB     &61, &78                ; Address LSP
        DCB     &70, &03                ; IRQ3         ;wired to ei11 on IOMD2
        DCB     &F0, &3B
        DCB     &30, 2_00000001         ; Enable it

;PS2 Port (8 regs, xx8-xxF)
        DCB     &07, &07                ; Config PS2 Port
        DCB     &70, &01                ; KIRQ (IRQ1)
        DCB     &72, &0C                ; MIRQ (IRQ12)
        DCB     &30, 2_00000001         ; Enable it

;SIRQs
        DCB     &07, &08                ; Config Serial Interrupts

;interrupt enables group 1, bits 2..4 are serial2,serial1,floppy (parallel on irq3)
        DCB     &B4, &00                ; serial2,serial1,floppy disabled (leave to device drivers)

;interrupt enables group 2, bits 0..2 are mouse,keyboard,IR (bit 7 enables SMI output on pin)
        DCB     &B5, &83                ; mouse,keyboard enabled (leave IR to device driver)

        DCB     &C0, &02                ; pin multiplex control
        DCB     &30, 2_00000001         ; Enable it

;Global Config
        DCB     &03, 2_10000011         ; EA, readable
        DCB     &22, 2_00111001         ; Finally, power up: SP2, SP1, PP1, FDC
;       DCB     &23, 2_00000000         ; Turn 'intelligent power management' off
;       DCB     &24, 2_00000100         ; PLL on, Osc on, BRG on.
        
d1103 10
a1112 1
  ] ;IOMD2Support
d1114 2
d1118 2
a1119 4

  [ IOMD1Support

; Configure37C665 - programs SMC 37C665 (assumes IOMD1 desktop platforms)
d1133 8
a1140 1
ConfigSMC665Table
d1156 3
d1177 1
a1177 1
        ADR     r1, ConfigSMC665Table   ; R1-> SMC 665 configuration data
d1196 3
a1199 1
  ] ;IOMD1Support
d1207 1
a1207 2

defaultlatch * T0Ticker100Hz
@


4.3.2.2
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d92 12
a103 1
; note that Timer0 is already set up, so CMOS reads will be ok
d117 8
a125 14
Combo_eh
        MOV     r1,#IOMD_Base
        LDRB    r0,[r1,#IOMD_ID0]
  [ IOMD2Support
        TEQ     r0,#IOMD_IOMD2    :AND: &FF
        BEQ     Combo_Phoebe
  ]
  [ IOMD1Support
        TEQ     r0,#IOMD_Original :AND: &FF
        TEQNE   r0,#IOMD_7500     :AND: &FF
        TEQNE   r0,#IOMD_7500FE   :AND: &FF
        BEQ     Combo_IOMD1
  ]
        B       Combo_eh                    ;deliberate hang up
a126 4
  [ IOMD1Support
;
Combo_IOMD1
        BL      Configure37C665                  ;RiscPC, Kryten and Stork use only SMC 37C665
d128 14
d143 1
a143 1
        STRB    R0, [R1, #IOCIRQCLRA]            ; clear pending tim0, vsync irqs (+ pack irq if appropriate)
d146 1
a146 2
        STRB    R0, [R1, #IOCIRQMSKA]            ; Enable timer 0 + vsync irqs
        B       Combo_done
a147 1
  ] ;IOMD1Support
d149 15
a163 17
  [ IOMD2Support
;
Combo_Phoebe
        BL      ConfigureSMC672                  ;Phoebe uses only SMC 672
        MOV     r1, #IOMD_Base
        MOV     r0, #(1:SHL:6)                   ;vsync is bit 6  
        ORR     r0, r0, #(1:SHL:16)              ;timer0 is bit 16
        STR     r0, [r1, #IOMD2_INTREQ]          ;clear any pending vsync, timer0
        LDR     r0, [r1, #IOMD2_INTENBL]
        ORR     r0, r0, #(1:SHL:6)
        ORR     r0, r0, #(1:SHL:16)
        STR     r0, [r1, #IOMD2_INTENBL]         ;enable vsync and timer0 irqs

  ] ;IOMD2Support

;
Combo_done
d316 1
d332 1
d353 3
d359 23
d410 1
a548 1
;                         also does monitor lead type
d552 2
d555 1
a555 1
10
d557 7
a563 15
        TEQ     r0, #IOMD_IOMD2    :AND: &FF
        BEQ     RMT_Phoebe                            ; IOMD2 (Phoebe)
        TEQ     r0, #IOMD_Original :AND: &FF
        BEQ     RMT_Medusa                            ; IOMD1 (Risc PC)
        TEQ     r0, #IOMD_7500     :AND: &FF
        TEQNE   r0, #IOMD_7500FE   :AND: &FF
        BEQ     RMT_Morris                            ; 7500 (A7000) or 7500FE (A7000+)
        B       %BT10                                 ; deliberate panic hang-up (unrecognised IOMD)

RMT_Phoebe
        MOV     r0, #IOST_IOEB                        ; pretend we've got IOEB
        MOV     r1, #0
        STRB    r0, [r1, #IOSystemType]
        MOV     r2, #0                                ; we can't do monitor lead detect, so assume VGA capable monitor
        B       %FT90
a564 10
RMT_Medusa
        MOV     r11, #0
        TEQ     r11, #1                               ; set NE for conditional stuff below
        B       RMT_common

RMT_Morris
        MOV     r11, #IOST_7500
        TEQ     r11, #IOST_7500                       ; set EQ for conditional stuff below
;
RMT_common
d568 2
d581 5
a585 1

d595 2
d598 86
d685 3
d689 2
d692 1
d696 2
d699 1
d703 3
d717 1
d719 4
d727 5
d733 4
d741 3
d757 4
d796 1
d799 1
d801 8
d882 1
d884 20
d906 3
a908 1

d945 1
d948 1
a948 1
;       ConfigureSMC672 - Configure SMC 672 (assumes we are on Phoebe)
d951 1
a951 1
  [ IOMD2Support
d953 8
a960 1
ComboBase         *       &03010000     ; Base address of combo chip = PC/AT I/O 000H
d962 5
a966 7
SMC_CSR           *       &03F0 * 4     ; Configuration Select Register (CSR)
SMC_config        *       &55           ; value to write to enter configuration mode
SMC_endconfig     *       &AA           ; value to write to end configuration mode
SMC_IDreg         *       &0D           ; device ID register
SMC_data          *       &03F1 * 4     ; Configuration Access Port (data)
SMC_672           *       &40           ; 672 ID
SMC_672_IDreg     *       &20
a967 3
command_RESETPS2  *  &AA
PS2_COMMAND       *  &64*4 
PS2_DATA          *  &60*4
d969 6
a974 1
ConfigureSMC672 ENTRY "r0,r1"
d976 1
a976 1
        LDR     r0, =ComboBase                  ; R0->  Base address of combo chip
d978 1
a978 1
; See if we have a SMC672 and try to configure it
d980 1
d983 1
a983 1
        MOV     lr, #SMC_672_IDreg
d986 2
a987 2
        TEQ     lr, #SMC_672            ; 672
        ADREQ   r1, ConfigSMC672Table
d989 16
d1006 14
a1019 2
; Not a SMC chip that we recognise
        MOV     r1, #0                  ; Don't know what this is, give up
d1030 1
a1030 1
                                        ;665s, 669s and 672s offer the same features as far as
d1034 1
a1040 20
; reset PS2 uC, just in case (eg. kbd activity during warm reset)
;
        LDR     lr, =ComboBase
        MOV     r0, #command_RESETPS2
        STRB    r0, [lr, #PS2_COMMAND]
20      LDRB    r0, [lr, #PS2_COMMAND]
        ANDS    r0, r0, #1
        BEQ     %BT20                   ;Wait until something comes back
        LDRB    r0, [lr, #PS2_DATA]

;       enable external interrupt 10 (ei10), wired as combo SMI interrupt
;
        MOV     r0, #IOMD_Base
        MOV     lr, #1 :SHL: 10
        STR     lr, [r0,#IOMD2_INTREQ]  ; clear any spurious level interrupt on ei10
        LDR     lr, [r0,#IOMD2_INTENBL]
        ORR     lr, lr, #1 :SHL: 10
        STR     lr, [r0,#IOMD2_INTENBL] ; enable ei10

30
d1044 57
a1100 64
ConfigSMC672Table
;Floppy Drive (8 regs, 3F0-3F7)
        DCB     &07, 0                  ; Config the FDC first.
        DCB     &60, &03                ; Address MSP
        DCB     &61, &F0                ; Address LSP
        DCB     &70, &05                ; Use IRQ6
        DCB     &74, &01                ; DMA channel 1
        DCB     &F0, 2_01001100         ; FDC cfg - Normal, Burst, AT-interface, Noswap, push-pull, active
        DCB     &F1, 2_00000000         ; FDC cfg - default
        DCB     &F2, 2_11111111         ; FDC cfg - default again
        DCB     &F4, 2_00000000
        DCB     &F5, 2_00000000
        DCB     &30, 2_00000001         ; Enable it

;Serial Port 1 (8 regs, 3F8-3FF)
        DCB     &07, &04                ; Config Serial Port 1
        DCB     &60, &03                ; Address MSP
        DCB     &61, &F8                ; Address LSP
        DCB     &70, &07                ; IRQ 7
        DCB     &74, &04                ; No DMA
        DCB     &F0, 2_00000000         ; No MIDI, HighSpeed disabled, Use unique IRQ
        DCB     &30, 2_00000001         ; Enable it

;Serial Port 2 (8 regs, 2F8-2FF)
        DCB     &07, &05                ; Config Serial Port 2
        DCB     &60, &02                ; Address MSP
        DCB     &61, &F8                ; Address LSP
        DCB     &70, &04                ; Use IRQ4
        DCB     &74, &04                ; No DMA
        DCB     &F0, 2_00000000         ; No MIDI, HighSpeed disabled
        DCB     &30, 2_00000001         ; Enable it

;Parallel Port (8 regs, 278-27F)
        DCB     &07, &03
        DCB     &60, &02                ; Address MSP
        DCB     &61, &78                ; Address LSP
        DCB     &70, &03                ; IRQ3         ;wired to ei11 on IOMD2
        DCB     &F0, &3B
        DCB     &30, 2_00000001         ; Enable it

;PS2 Port (8 regs, xx8-xxF)
        DCB     &07, &07                ; Config PS2 Port
        DCB     &70, &01                ; KIRQ (IRQ1)
        DCB     &72, &0C                ; MIRQ (IRQ12)
        DCB     &30, 2_00000001         ; Enable it

;SIRQs
        DCB     &07, &08                ; Config Serial Interrupts

;interrupt enables group 1, bits 2..4 are serial2,serial1,floppy (parallel on irq3)
        DCB     &B4, &00                ; serial2,serial1,floppy disabled (leave to device drivers)

;interrupt enables group 2, bits 0..2 are mouse,keyboard,IR (bit 7 enables SMI output on pin)
        DCB     &B5, &83                ; mouse,keyboard enabled (leave IR to device driver)

        DCB     &C0, &02                ; pin multiplex control
        DCB     &30, 2_00000001         ; Enable it

;Global Config
        DCB     &03, 2_10000011         ; EA, readable
        DCB     &22, 2_00111001         ; Finally, power up: SP2, SP1, PP1, FDC
;       DCB     &23, 2_00000000         ; Turn 'intelligent power management' off
;       DCB     &24, 2_00000100         ; PLL on, Osc on, BRG on.
        
d1103 10
a1112 1
  ] ;IOMD2Support
d1114 2
d1118 2
a1119 4

  [ IOMD1Support

; Configure37C665 - programs SMC 37C665 (assumes IOMD1 desktop platforms)
d1133 8
a1140 1
ConfigSMC665Table
d1156 3
d1177 1
a1177 1
        ADR     r1, ConfigSMC665Table   ; R1-> SMC 665 configuration data
d1196 3
a1199 1
  ] ;IOMD1Support
d1207 1
a1207 2

defaultlatch * T0Ticker100Hz
@


4.2
log
@Kernel merged
@
text
@d131 1
a131 1
        
d619 1
a619 1
        CMP     r0, #&98
d843 3
a845 3
        
        
        
d1405 1
a1405 1
        
@


4.1
log
@Initial revision
@
text
@d122 3
d130 2
a131 1

d178 15
d197 1
a197 1

d367 18
d412 19
d432 3
d463 1
d608 10
d624 1
d626 4
a629 2
; On Kryten, Morris pin Event2 is tied low so bit Nevent2 is a ONE
; On Stork, Morris pin Event2 is tied high so bit Nevent2 is a ZERO
d631 2
a632 1
        LDREQB  r0, [r12, #IOMD_IRQSTD]                 ;EQ, Morris
d634 3
a636 3
        ORREQ   r11, r11, #IOST_BATMAN                  ;EQ, Stork ie Morris & BATMAN

        ORR     r0, r11, #IOST_IOEB                     ; pretend we've got IOEB
d639 1
a639 1
;        or  IOST_7500                for  Morris (Kryten)
d642 1
a642 1
        MOV     r0, #IOST_IOEB                          ; pretend we've got IOEB
d645 1
a645 1
        TEQP    pc, #SVC_mode + I_bit + F_bit           ; disable IRQs and FIQs
d653 2
a654 2
        TEQ     r0, #5                                  ; must read 5 is ASIC present
        MOVNE   r0, #0                                  ; no IOEB, LC or 82C710
d661 1
a661 1
        AND     r0, r0, #&0E                            ; bits 3210 should be 010x
d663 2
a664 2
        MOVNE   r0, #IOST_IOEB                          ; IOEB but no LC
        MOVEQ   r0, #IOST_IOEB :OR: IOST_LC             ; IOEB and LC
d667 1
a667 1
        MOV     r1, #0                                  ; normal Hsync and address pointer
d670 1
a670 1
; now read monitor lead type
d672 2
a673 2
        TEQ     r0, #0                                  ; no IOEB
        MOVEQ   r2, #&FF                                ; then return all ones for monitor lead type
d676 88
d843 4
a849 1
 [ VIDC_Type = "VIDC20"
a851 1
 ]
d883 1
a883 1
 [ IO_Type = "IOMD"
d886 1
a886 1
 ]
d888 8
d971 20
d993 2
a994 1
 |
d1046 171
d1405 3
d1451 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@d122 5
a126 1
        BL      ConfigureCombo
a173 15
 [ E2ROMSupport
; Don't set time to value held in RTC if the RTC chip is not fitted
; system time will default to epoch: Midnight 1st Jan 1900
	MOV	R1, #0
	LDRB	R0, [r1, #RTCFitted]
	TEQ	R0, #1
	BEQ	%FT28
; Set default time to UNIX epoch (1970) +1day not RISCOS epoch (1900) so time() doesn't return -1
secs0070 *	(86400*(365*70+18))	; from time() in risc_oslib.c.armsys
	LDR	R7, =(secs0070 * 100)	; centiseconds LSW
	MOV	R8, #&33		; centiseconds MSW
	BL	Store5ByteInRealTime
	B	%FT30
28
 ]
d178 1
a178 1
30
d378 23
a400 16
;       UpdateCLines - update IOMD_CLINES 8bit IO port
; In:
;	r3: new value
;	r4: mask of bits to set
;
; Out:
;	All regs preserved

UpdateCLines ENTRY "r0, r1"
	LDR	r0, =(IOMD_Base + IOMD_CLINES)
	LDRB	r1, [r0]
	ORR	r1, r1, #IOMD_C_ReadMask	; Set readable bits
	BIC	r1, r1, r4			; Clear bits to write
	ORR	r1, r1, r3			; Set bits to write
	STRB	r1, [r0]
	EXIT
a547 10
   [ {TRUE} ; ARM7500FE support
	LDRB	r0, [r12, #IOMD_ID0]
	LDRB	r11, [r12, #IOMD_ID1]
	ORR	r0, r0, r11, LSL #8
	LDR	r11, =IOMD_Original
	TEQ	r0, r11
	MOVEQ	r11, #0					; assume Medusa
	MOVNE	r11, #IOST_7500				; else assume Morris
	TEQ	r11, #IOST_7500				; and set EQ if Morris to do conditional stuff below
   |
a553 1
   ]
d555 2
a556 4
; On Kryten,	Morris pin Event2 is tied low so bit Nevent2 is a ONE
; On Stork,	Morris pin Event2 is tied high so bit Nevent2 is a ZERO
; On STB/NCD,	Morris pin Event2 is tied high so bit Nevent2 is a ZERO, but we don't have a LCD
; 		controller or battery manager so we'll not set IOST_BATMAN
d558 1
a558 2
        LDREQB  r0, [r12, #IOMD_IRQSTD]         ;EQ, Morris
   [ BatManSupport
d560 3
a562 3
        ORREQ   r11, r11, #IOST_BATMAN          ;EQ, Stork ie Morris & BATMAN
   ]
        ORR     r0, r11, #IOST_IOEB             ; pretend we've got IOEB
d565 1
a565 1
;        or  IOST_7500                for  Morris (Kryten, Falcon, Omega)
d568 1
a568 1
        MOV     r0, #IOST_IOEB                  ; pretend we've got IOEB
d571 1
a571 1
        TEQP    pc, #SVC_mode + I_bit + F_bit   ; disable IRQs and FIQs
d579 2
a580 2
        TEQ     r0, #5                          ; must read 5 is ASIC present
        MOVNE   r0, #0                          ; no IOEB, LC or 82C710
d587 1
a587 1
        AND     r0, r0, #&0E                    ; bits 3210 should be 010x
d589 2
a590 2
        MOVNE   r0, #IOST_IOEB                  ; IOEB but no LC
        MOVEQ   r0, #IOST_IOEB :OR: IOST_LC     ; IOEB and LC
d593 1
a593 1
        MOV     r1, #0                          ; normal Hsync and address pointer
d596 1
a596 1
; now read monitor lead type.
d598 2
a599 2
        TEQ     r0, #0                          ; no IOEB
        MOVEQ   r2, #&FF                        ; then return all ones for monitor lead type
d602 1
d604 4
a607 12

  [ MorrisSupport				; On Morris, monitor auto-detect has been moved to IOMD_CLINES
	TST     R11, #IOST_7500
        LDREQ	r3, =IOMD_MonitorType		; Not Morris, address is in old place
    [ IOMD_C_MonitorType = 0			; Monitor auto-detect not supported:
        MOVNE	r2, #&FF                        ; then return all ones for monitor lead type
        BNE	%FT90
    |
	ASSERT	(IOMD_C_MonitorType = (1<<0))	; this code only understands auto-detect in bit 0
	LDRNE	r3, =(IOMD_Base + IOMD_CLINES)
    ]
  |
d609 3
a611 1
  ]
d613 1
d617 4
d622 5
d628 1
a628 10
  [ MorrisSupport
    [ IOMD_C_PALNTSCType <> 0
	ASSERT	(IOMD_C_PALNTSCType = (1<<4))	; this code only understands PAL/NTSC auto-detect in bit 4
	AND	r4, r4, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
	ORR	r4, r4, r4, LSR #1		; Shift PAL/NTSC bit into bit 3
        AND     r4, r4, #&0F                    ; only use bits 0..3
    |
	AND	r4, r4, #IOMD_C_MonitorType	; only one bit
    ]
  |
a629 1
  ]
d640 1
d642 10
d653 3
d657 10
d668 2
a669 15

  [ MorrisSupport
    [ IOMD_C_PALNTSCType <> 0
	AND	r6, r6, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
	ORR	r6, r6, r6, LSR #1		; Shift PAL/NTSC bit into bit 3
        AND     r6, r6, #&0F                    ; only use bits 0..3
	AND	r7, r7, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
	ORR	r7, r7, r7, LSR #1		; Shift PAL/NTSC bit into bit 3
        AND     r7, r7, #&0F                    ; only use bits 0..3
    |
	AND	r6, r6, #IOMD_C_MonitorType	; only one bit
	AND	r7, r7, #IOMD_C_MonitorType
    ]
  |
        AND     r6, r6, #&0F                    ; only use bits 0..3
a670 1
  ]
d684 1
d687 1
d719 1
a719 1
  [ IO_Type = "IOMD" :LAND: {FALSE}
d722 1
a722 1
  ]
a723 8
  [ IOMD_C_TVMode <> 0				; set the TVMode to 0 (VGA) if id bits1,0 != 01 (TV)
        AND	r3, r2, #2_11			; bits we're interested in
	CMP	r3, #2_01			; TV?
	BEQ	%FT90				; yes
	MOV	r3, #0
	MOV	r4, #IOMD_C_TVMode
	BL	UpdateCLines
  ]
d799 3
a801 13
   [ IOMD_C_MonitorType = 0					; no auto-detect bit
        MonitorLeadItem 4_3333,  28, 3, 0                       ; assume VGA-capable monitors 256 colours
   |
     [ IOMD_C_PALNTSCType = 0					; no PAL/NTSC bits:
        MonitorLeadItem 4_3331,  12, 0, 1                       ; PAL TV assumed
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
     |								; wealth of bits:
        MonitorLeadItem 4_0331,  50, 0, 0                       ; PAL TV interlaced overscanned
        MonitorLeadItem 4_1331,  58, 8, 0                       ; NTSC TV interlaced overscanned
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
     ]
   ]
 | ;IO_Type = "IOMD"
d855 1
a855 1
;       ConfigureCombo - Configure SMC 665/669 or UMC 8669 if present
d858 1
a858 1
ComboBase	*	&03010000       ; Base address of combo chip = PC/AT I/O 000H
d860 6
a865 8
; SMC-type stuff
SMC_CSR		*	&03F0 * 4	; Configuration Select Register (CSR)
SMC_config	*	&55		; value to write to enter configuration mode
SMC_endconfig	*	&AA		; value to write to end configuration mode
SMC_IDreg	*	&0D		; device ID register
SMC_data	*	&03F1 * 4	; Configuration Access Port (data)
SMC_665		*	&65		; 665 ID
SMC_669		*	&03		; 669 ID
d867 2
a868 5
; UMC-type stuff
UMC_CSR		*	&0108 * 4	; Configuration Select Register (CSR)
UMC_config	*	&AA		; value to write to enter configuration mode
UMC_endconfig	*	&55		; value to write to end configuration mode
UMC_data	*	&0109 * 4	; Configuration Access Port (data)
d871 6
a876 4
;
; Configure SMC 37C665/669 or UMC8669 combo chip
; Note that older devices (eg 82C710, 82C711, SMC651) are no longer supported
	ASSERT	:LNOT: OldComboSupport
a877 1
ConfigureCombo ENTRY "r0,r1"
d879 1
a879 1
        LDR     r0, =ComboBase		; R0->  Base address of combo chip
d881 1
a881 14
; See if we have a SMC665/669 and try to configure it
        MOV     lr, #SMC_config
        STRB    lr, [r0, #SMC_CSR]	; Write &55 to CSR twice
        STRB    lr, [r0, #SMC_CSR]	; to enter configuration mode

        MOV     lr, #SMC_IDreg
        STRB    lr, [r0, #SMC_CSR]
        LDRB    lr, [r0, #SMC_data]
        TEQ     lr, #SMC_665		; 665 ?
	ADREQ	r1, ConfigSMC665Table
	BEQ	%FT20
        TEQ     lr, #SMC_669		; 669 ?
	ADREQ	r1, ConfigSMC669Table
	BEQ	%FT20
d883 11
a893 30
; Not a SMC chip that we recognise, maybe we have a UMC8669
	ADR	r1, ConfigUMC8669Table
10
        LDRB    lr, [r1], #1		; get "Index Entry Valid"
        STRB    lr, [r0, #UMC_CSR]
        TEQ     lr, #UMC_endconfig	; end of table?
	BEQ	%FT12
        LDRB    lr, [r1], #1		; get config index
        STRB    lr, [r0, #UMC_CSR]
        LDRB	lr, [r1], #1		; get config data
        STRB	lr, [r0, #UMC_data]	; and write it
        BNE     %BT10

12
; UMC8669 is not self-identifying, so see if what we wrote is still there
        MOV     lr, #UMC_config
        STRB    lr, [r0, #UMC_CSR]	; Write &AA to enter config mode
	MOV	lr, #&C0
        STRB    lr, [r0, #UMC_CSR]	; CR0
	LDRB	r2, [r0, #UMC_data]
        MOV     lr, #UMC_endconfig	; maybe don't need to do this
        STRB    lr, [r0, #UMC_CSR]	; exit config mode
	TEQ	r2, #2_00111110		; Value for CR0 from ConfigUMC8669Table

        				;665s and 669s offer the same features as far as
        MOVEQ	r1, #IOST_37C665	; OS_ReadSysInfo(3) is concerned, so use same value for both
	MOVNE	r1, #0			; Don't know what this is, give up
        B	%FT30

;	SMC config loop
d895 5
a899 5
        LDRB    lr, [r1], #1		; get config index
        STRB    lr, [r0, #SMC_CSR]
        TEQ     lr, #SMC_endconfig	; end of table?
        LDRNEB  lr, [r1], #1		; if not then get config data
        STRNEB  lr, [r0, #SMC_data]	; and write it
a900 2
        				;665s and 669s offer the same features as far as
        MOV     r1, #IOST_37C665	; OS_ReadSysInfo(3) is concerned, so use same value for both
d902 48
a949 1
;	Record type of chip found
d959 38
d998 1
d1000 29
a1028 63
ConfigSMC665Table
	DCB     &01, 2_10010111		; Enable config, COM3@@338, COM4@@238, IRQs active hi,
					; // is extended & powered @@278
	DCB     &02, 2_11011100		; COM2 powered & enabled @@2F8, COM1 powered & enabled @@3F8
					; (default)
	DCB     &03, 2_01111000		; floppy stuff (default)
        DCB     &04, 2_00000011		; EPP v1.9, MIDI disabled, normal //floppy,
					; // uses ECP & EPP modes
	DCB     &05, 0			; 4 drive support, don't swap drives, normal density,
					; FDC burst mode, IDE@@1F0-7,3F6-7, FDC@@3F0-7 (default)
;	DCB     &06, &FF		; floppy drive types (default)
;	DCB     &07, 0			; don't auto-powerdown anything (default)
;	DCB     &08, 0			; ADRA7:4 address decode (default)
;	DCB     &09, 0			; ADRA10:8 address decode (default)
;	DCB     &0A, 0			; FIFO threshold for ECP // = ??? (default)
;	DCB	&0B, 0			; floppy data rates (default)
;	DCB	&0C, 0			; UART2 & UART1 standard speed, UART2 standard mode,
					; UART2 full duplex, XMIT active hi, RCV active hi (default)
        DCB     &00, 2_10111011         ; Valid config, OSC & BR on, FDC enabled & powered,
					; IDE AT & enabled
        DCB     SMC_endconfig, 0	; Exit config mode

ConfigSMC669Table
	DCB     &01, 2_10010100         ; Enable config, // is extended, // is  powered
	DCB     &02, 2_10001000         ; COM2 powered, COM1 powered (default)
	DCB     &03, 2_01111000		; floppy stuff (default)
	DCB     &04, 2_00000011		; IR rx&tx on COM2 rx & tx pins, EPP v1.9, MIDI disabled,
					; normal //floppy, uses ECP & EPP modes
	DCB     &05, 0			; 4 drive support, don't swap drives, normal density,
					; FDC burst mode (default)
;	DCB     &06, &FF		; floppy drive types (default)
;	DCB     &07, 0			; don't auto-powerdown anything
;	DCB     &08, 0			; ADRA7:4 address decode (default)
;	DCB     &09, 0			; ADRx disabled, ADRA10:8 address decode (default)
;	DCB     &0A, 0			; FIFO threshold for ECP // = ??? (default)
;	DCB	&0B, 0			; floppy data rates (default)
;	DCB	&0C, 0			; UART2 & UART1 standard speed, UART2 standard mode,
					; UART2 full duplex, XMIT active hi, RCV active hi (default)
;	DCB	&1E, &80		; GAMECS disabled (default)
;	DCB	&1F, 0			; floppy drive types (default)
	DCB	&20, &FC		; FDC@@3F0-7
	DCB	&21, &7C		; IDE@@1F0-7
	DCB	&22, &FD		; IDE Alternate Status Register @@3F6
	DCB	&23, &9E		; //@@278
	DCB	&24, &FE		; COM1@@3F8
	DCB	&25, &BE		; COM2@@2F8
	DCB	&26, 0			; no FDC DMA, no // DMA (default)
	DCB	&27, 2_01100101		; FDC uses IRQ_F, // uses IRQ_E
	DCB	&28, 2_01000011		; UART1 uses IRQ_D, UART2 uses IRQ_C
	DCB	&29, 0			; IRQIN does not use any IRQ_x (default)
        DCB     &00, 2_10001010         ; Valid config, FDC powered, IDE enabled
        DCB     SMC_endconfig, 0	; Exit config mode

ConfigUMC8669Table
	DCB     UMC_config, &C0, 2_00111110	; IR full-duplex, games off, IDE on,
						; // in EPP & ECP mode, UART2 on, UART1 on, FDC off
	DCB     UMC_config, &C1, 2_00101111	; Direct access PnP register, Disable PnP,
						; IDE@@1F0-7,3F6-7, //@@278, COM2@@2F8, COM1@@3F8,
						; FDC@@3F0-7
	DCB     UMC_config, &C2, 2_10000001	; Not supspended, IR unselected/disabled,
						; don't swap floppy, IBM mode floppy,
						; floppy is R/W (default)
        DCB     UMC_endconfig, 0		; Exit config mode
d1030 7
a1036 1
        ALIGN
d1038 3
a1083 1
        LDRB    r12, [r1, #IOCIRQSTAA]          ; dummy instruction (repeated for FE)
@


4.1.7.2
log
@Added support for Chrontel device.
@
text
@a821 1
      [ :LNOT: ChrontelSupport
a822 1
      ]
@


4.1.7.3
log
@TMD: Updated SMC 669 configuration to:
 a) try both 3F0 and 370 as configuration select registers, as the 669 uses
    either, based on the state of the RTS line in UART2 on reset, which is
    probably indeterminate in an NC;
 b) set bit 6 of configuration register 0x10, to cope with having a 24MHz
    input to the PLL;
 c) clear bit 3 of configuration register 0x03, since this is now reserved
    (it used to be 'Drive Opt 0').
@
text
@a892 2
SMC_CSRalt669	*	&0370 * 4	; Alternative Configuration Select Register on SMC 669
					; (this register is used if RTS2 is high on reset, which we don't have direct control of)
d912 1
a912 1
ConfigureCombo ENTRY "r0-r2"
a916 2
	ADD	r2, r0, #SMC_CSR	; first try in normal place

d918 2
a919 2
        STRB    lr, [r2]		; Write &55 to CSR twice
        STRB    lr, [r2]		; to enter configuration mode
d922 2
a923 2
        STRB    lr, [r2]
        LDRB    lr, [r2, #SMC_data-SMC_CSR]
d928 2
a929 16
	BEQ	%FT18

; Not a SMC chip at the normal place, but the SMC 669 may move its configuration registers
; to &370 if RTS2 was high on trailing edge of reset, so try there

        ADD	r2, r0, #SMC_CSRalt669

        MOV     lr, #SMC_config
        STRB    lr, [r2]		; Write &55 to CSR twice
        STRB    lr, [r2]		; to enter configuration mode

        MOV     lr, #SMC_IDreg
        STRB    lr, [r2]
        LDRB    lr, [r2, #SMC_data-SMC_CSR]
        TEQ     lr, #SMC_669		; 669 ?
	BEQ	%FT18
a960 2
18
	ADR	r1, ConfigSMC669Table
d962 5
a966 5
        LDRB    lr, [r1], #1			; get config index
        STRB    lr, [r2]
        TEQ     lr, #SMC_endconfig		; end of table?
        LDRNEB  lr, [r1], #1			; if not then get config data
        STRNEB  lr, [r2, #SMC_data-SMC_CSR]	; and write it
d968 2
a969 2
        					;665s and 669s offer the same features as far as
        MOV     r1, #IOST_37C665		; OS_ReadSysInfo(3) is concerned, so use same value for both
d1008 1
a1008 1
	DCB     &03, 2_01110000		; floppy stuff (bit 3 now reserved)
a1020 1
	DCB	&10, 2_01000000		; 24MHz input to PLL (*not* default)
@


4.1.7.4
log
@Make last reset type reflect the true state of the last reset (power-on or
hard - soft resets still disabled).
@
text
@a46 1
        MOVNE   R4, R1                  ; preserve LastBREAK
a57 1
        STRB    R4, LastBREAK           ; put LastBREAK back
@


4.1.7.5
log
@Store reset type, even for POR.
@
text
@d47 1
a47 1
        MOV     R4, R1                  ; preserve LastBREAK
@


4.1.7.6
log
@Fixed to use HCLK for built-in video modes on NC with Chrontel
@
text
@d820 5
a824 3
   [ IOMD_C_MonitorType <> 0					; auto-detect bit present
     [ :LNOT: ChrontelSupport
       [ IOMD_C_PALNTSCType = 0					; no PAL/NTSC bits:
d826 3
a828 1
       | ; IOMD_C_PALNTSCType <> 0				; wealth of bits:
d831 3
a833 4
       ] ; IOMD_C_PALNTSCType <> 0
     ] ; :LNOT: ChrontelSupport
   ] ; IOMD_C_MonitorType <> 0
	MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
@


4.1.5.1
log
@Import from SrcFiler
@
text
@d122 5
a126 1
        BL      ConfigureCombo
a173 15
 [ E2ROMSupport
; Don't set time to value held in RTC if the RTC chip is not fitted
; system time will default to epoch: Midnight 1st Jan 1900
	MOV	R1, #0
	LDRB	R0, [r1, #RTCFitted]
	TEQ	R0, #1
	BEQ	%FT28
; Set default time to UNIX epoch (1970) +1day not RISCOS epoch (1900) so time() doesn't return -1
secs0070 *	(86400*(365*70+18))	; from time() in risc_oslib.c.armsys
	LDR	R7, =(secs0070 * 100)	; centiseconds LSW
	MOV	R8, #&33		; centiseconds MSW
	BL	Store5ByteInRealTime
	B	%FT30
28
 ]
d178 1
a178 1
30
d378 23
a400 16
;       UpdateCLines - update IOMD_CLINES 8bit IO port
; In:
;	r3: new value
;	r4: mask of bits to set
;
; Out:
;	All regs preserved

UpdateCLines ENTRY "r0, r1"
	LDR	r0, =(IOMD_Base + IOMD_CLINES)
	LDRB	r1, [r0]
	ORR	r1, r1, #IOMD_C_ReadMask	; Set readable bits
	BIC	r1, r1, r4			; Clear bits to write
	ORR	r1, r1, r3			; Set bits to write
	STRB	r1, [r0]
	EXIT
a547 10
   [ {TRUE} ; ARM7500FE support
	LDRB	r0, [r12, #IOMD_ID0]
	LDRB	r11, [r12, #IOMD_ID1]
	ORR	r0, r0, r11, LSL #8
	LDR	r11, =IOMD_Original
	TEQ	r0, r11
	MOVEQ	r11, #0					; assume Medusa
	MOVNE	r11, #IOST_7500				; else assume Morris
	TEQ	r11, #IOST_7500				; and set EQ if Morris to do conditional stuff below
   |
a553 1
   ]
d555 2
a556 4
; On Kryten,	Morris pin Event2 is tied low so bit Nevent2 is a ONE
; On Stork,	Morris pin Event2 is tied high so bit Nevent2 is a ZERO
; On STB/NCD,	Morris pin Event2 is tied high so bit Nevent2 is a ZERO, but we don't have a LCD
; 		controller or battery manager so we'll not set IOST_BATMAN
d558 1
a558 2
        LDREQB  r0, [r12, #IOMD_IRQSTD]         ;EQ, Morris
   [ BatManSupport
d560 3
a562 3
        ORREQ   r11, r11, #IOST_BATMAN          ;EQ, Stork ie Morris & BATMAN
   ]
        ORR     r0, r11, #IOST_IOEB             ; pretend we've got IOEB
d565 1
a565 1
;        or  IOST_7500                for  Morris (Kryten, Falcon, Omega)
d568 1
a568 1
        MOV     r0, #IOST_IOEB                  ; pretend we've got IOEB
d571 1
a571 1
        TEQP    pc, #SVC_mode + I_bit + F_bit   ; disable IRQs and FIQs
d579 2
a580 2
        TEQ     r0, #5                          ; must read 5 is ASIC present
        MOVNE   r0, #0                          ; no IOEB, LC or 82C710
d587 1
a587 1
        AND     r0, r0, #&0E                    ; bits 3210 should be 010x
d589 2
a590 2
        MOVNE   r0, #IOST_IOEB                  ; IOEB but no LC
        MOVEQ   r0, #IOST_IOEB :OR: IOST_LC     ; IOEB and LC
d593 1
a593 1
        MOV     r1, #0                          ; normal Hsync and address pointer
d596 1
a596 1
; now read monitor lead type.
d598 2
a599 2
        TEQ     r0, #0                          ; no IOEB
        MOVEQ   r2, #&FF                        ; then return all ones for monitor lead type
d602 1
d604 4
a607 23

  [ MorrisSupport				; On Morris, monitor auto-detect has been moved to IOMD_CLINES
	TST     R11, #IOST_7500
        LDREQ	r3, =IOMD_MonitorType		; Not Morris, address is in old place
    [ IOMD_C_MonitorType = 0			; Monitor auto-detect not supported:
     [ MPEGPoduleNTSCNotPALMask <> 0
	BEQ	%FT15				; not an IOMD-style machine, so skip any STB stuff
	LDR	r3, =MPEGPoduleNTSCNotPALAddress ; point at podule status register
	LDRB	r2, [r3]
	TST	r2, #MPEGPoduleNTSCNotPALMask	; test PAL/NTSC bit
	MOVEQ	r2, #4_0331			; if bit clear then PAL TV
	MOVNE	r2, #4_1331			; if bit set then NTSC TV
	B	%FT90
15
     |
        MOVNE	r2, #&FF                        ; then return all ones for monitor lead type
        BNE	%FT90
     ]
    |
	ASSERT	(IOMD_C_MonitorType = (1<<0))	; this code only understands auto-detect in bit 0
	LDRNE	r3, =(IOMD_Base + IOMD_CLINES)
    ]
  |
d609 3
a611 1
  ]
d613 1
d617 4
d622 5
d628 1
a628 10
  [ MorrisSupport
    [ IOMD_C_PALNTSCType <> 0
	ASSERT	(IOMD_C_PALNTSCType = (1<<4))	; this code only understands PAL/NTSC auto-detect in bit 4
	AND	r4, r4, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
	ORR	r4, r4, r4, LSR #1		; Shift PAL/NTSC bit into bit 3
        AND     r4, r4, #&0F                    ; only use bits 0..3
    |
	AND	r4, r4, #IOMD_C_MonitorType	; only one bit
    ]
  |
a629 1
  ]
d640 1
d642 10
d653 3
d657 10
d668 2
a669 15

  [ MorrisSupport
    [ IOMD_C_PALNTSCType <> 0
	AND	r6, r6, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
	ORR	r6, r6, r6, LSR #1		; Shift PAL/NTSC bit into bit 3
        AND     r6, r6, #&0F                    ; only use bits 0..3
	AND	r7, r7, #(IOMD_C_MonitorType :OR: IOMD_C_PALNTSCType)
	ORR	r7, r7, r7, LSR #1		; Shift PAL/NTSC bit into bit 3
        AND     r7, r7, #&0F                    ; only use bits 0..3
    |
	AND	r6, r6, #IOMD_C_MonitorType	; only one bit
	AND	r7, r7, #IOMD_C_MonitorType
    ]
  |
        AND     r6, r6, #&0F                    ; only use bits 0..3
a670 1
  ]
d684 1
d687 1
d719 1
a719 1
  [ IO_Type = "IOMD" :LAND: {FALSE}
d722 1
a722 1
  ]
a723 8
  [ IOMD_C_TVMode <> 0				; set the TVMode to 0 (VGA) if id bits1,0 != 01 (TV)
        AND	r3, r2, #2_11			; bits we're interested in
	CMP	r3, #2_01			; TV?
	BEQ	%FT90				; yes
	MOV	r3, #0
	MOV	r4, #IOMD_C_TVMode
	BL	UpdateCLines
  ]
d799 3
a801 19
   [ IOMD_C_MonitorType = 0					; no auto-detect bit
    [ MPEGPoduleNTSCNotPALMask <> 0
        MonitorLeadItem 4_0331,  50, 0, 0                       ; PAL TV interlaced overscanned
        MonitorLeadItem 4_1331,  58, 8, 0                       ; NTSC TV interlaced overscanned
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
    |
        MonitorLeadItem 4_3333,  28, 3, 0                       ; assume VGA-capable monitors 256 colours
    ]
   |
     [ IOMD_C_PALNTSCType = 0					; no PAL/NTSC bits:
        MonitorLeadItem 4_3331,  12, 0, 1                       ; PAL TV assumed
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
     |								; wealth of bits:
        MonitorLeadItem 4_0331,  50, 0, 0                       ; PAL TV interlaced overscanned
        MonitorLeadItem 4_1331,  58, 8, 0                       ; NTSC TV interlaced overscanned
        MonitorLeadItem 4_3333,  28, 3, 0                       ; VGA-capable monitors 256 colours
     ]
   ]
 | ;IO_Type = "IOMD"
d855 1
a855 1
;       ConfigureCombo - Configure SMC 665/669 or UMC 8669 if present
d858 1
a858 1
ComboBase	*	&03010000       ; Base address of combo chip = PC/AT I/O 000H
d860 6
a865 8
; SMC-type stuff
SMC_CSR		*	&03F0 * 4	; Configuration Select Register (CSR)
SMC_config	*	&55		; value to write to enter configuration mode
SMC_endconfig	*	&AA		; value to write to end configuration mode
SMC_IDreg	*	&0D		; device ID register
SMC_data	*	&03F1 * 4	; Configuration Access Port (data)
SMC_665		*	&65		; 665 ID
SMC_669		*	&03		; 669 ID
d867 2
a868 5
; UMC-type stuff
UMC_CSR		*	&0108 * 4	; Configuration Select Register (CSR)
UMC_config	*	&AA		; value to write to enter configuration mode
UMC_endconfig	*	&55		; value to write to end configuration mode
UMC_data	*	&0109 * 4	; Configuration Access Port (data)
d871 6
a876 4
;
; Configure SMC 37C665/669 or UMC8669 combo chip
; Note that older devices (eg 82C710, 82C711, SMC651) are no longer supported
	ASSERT	:LNOT: OldComboSupport
a877 1
ConfigureCombo ENTRY "r0,r1"
d879 1
a879 1
        LDR     r0, =ComboBase		; R0->  Base address of combo chip
d881 1
a881 14
; See if we have a SMC665/669 and try to configure it
        MOV     lr, #SMC_config
        STRB    lr, [r0, #SMC_CSR]	; Write &55 to CSR twice
        STRB    lr, [r0, #SMC_CSR]	; to enter configuration mode

        MOV     lr, #SMC_IDreg
        STRB    lr, [r0, #SMC_CSR]
        LDRB    lr, [r0, #SMC_data]
        TEQ     lr, #SMC_665		; 665 ?
	ADREQ	r1, ConfigSMC665Table
	BEQ	%FT20
        TEQ     lr, #SMC_669		; 669 ?
	ADREQ	r1, ConfigSMC669Table
	BEQ	%FT20
d883 11
a893 30
; Not a SMC chip that we recognise, maybe we have a UMC8669
	ADR	r1, ConfigUMC8669Table
10
        LDRB    lr, [r1], #1		; get "Index Entry Valid"
        STRB    lr, [r0, #UMC_CSR]
        TEQ     lr, #UMC_endconfig	; end of table?
	BEQ	%FT12
        LDRB    lr, [r1], #1		; get config index
        STRB    lr, [r0, #UMC_CSR]
        LDRB	lr, [r1], #1		; get config data
        STRB	lr, [r0, #UMC_data]	; and write it
        BNE     %BT10

12
; UMC8669 is not self-identifying, so see if what we wrote is still there
        MOV     lr, #UMC_config
        STRB    lr, [r0, #UMC_CSR]	; Write &AA to enter config mode
	MOV	lr, #&C0
        STRB    lr, [r0, #UMC_CSR]	; CR0
	LDRB	r2, [r0, #UMC_data]
        MOV     lr, #UMC_endconfig	; maybe don't need to do this
        STRB    lr, [r0, #UMC_CSR]	; exit config mode
	TEQ	r2, #2_00111110		; Value for CR0 from ConfigUMC8669Table

        				;665s and 669s offer the same features as far as
        MOVEQ	r1, #IOST_37C665	; OS_ReadSysInfo(3) is concerned, so use same value for both
	MOVNE	r1, #0			; Don't know what this is, give up
        B	%FT30

;	SMC config loop
d895 5
a899 5
        LDRB    lr, [r1], #1		; get config index
        STRB    lr, [r0, #SMC_CSR]
        TEQ     lr, #SMC_endconfig	; end of table?
        LDRNEB  lr, [r1], #1		; if not then get config data
        STRNEB  lr, [r0, #SMC_data]	; and write it
a900 2
        				;665s and 669s offer the same features as far as
        MOV     r1, #IOST_37C665	; OS_ReadSysInfo(3) is concerned, so use same value for both
d902 48
a949 1
;	Record type of chip found
d959 38
d998 1
d1000 29
a1028 68
ConfigSMC665Table
 [ ComboIRQsActiveHigh
	DCB     &01, 2_10010111		; Enable config, COM3@@338, COM4@@238, IRQs active hi,
					; // is extended & powered @@278
 |
	DCB     &01, 2_10000111		; Enable config, COM3@@338, COM4@@238, IRQs active low,
					; // is extended & powered @@278
 ]
	DCB     &02, 2_11011100		; COM2 powered & enabled @@2F8, COM1 powered & enabled @@3F8
					; (default)
	DCB     &03, 2_01111000		; floppy stuff (default)
        DCB     &04, 2_00000011		; EPP v1.9, MIDI disabled, normal //floppy,
					; // uses ECP & EPP modes
	DCB     &05, 0			; 4 drive support, don't swap drives, normal density,
					; FDC burst mode, IDE@@1F0-7,3F6-7, FDC@@3F0-7 (default)
;	DCB     &06, &FF		; floppy drive types (default)
;	DCB     &07, 0			; don't auto-powerdown anything (default)
;	DCB     &08, 0			; ADRA7:4 address decode (default)
;	DCB     &09, 0			; ADRA10:8 address decode (default)
;	DCB     &0A, 0			; FIFO threshold for ECP // = ??? (default)
;	DCB	&0B, 0			; floppy data rates (default)
;	DCB	&0C, 0			; UART2 & UART1 standard speed, UART2 standard mode,
					; UART2 full duplex, XMIT active hi, RCV active hi (default)
        DCB     &00, 2_10111011         ; Valid config, OSC & BR on, FDC enabled & powered,
					; IDE AT & enabled
        DCB     SMC_endconfig, 0	; Exit config mode

ConfigSMC669Table
	DCB     &01, 2_10010100         ; Enable config, // is extended, // is  powered
	DCB     &02, 2_10001000         ; COM2 powered, COM1 powered (default)
	DCB     &03, 2_01111000		; floppy stuff (default)
	DCB     &04, 2_00000011		; IR rx&tx on COM2 rx & tx pins, EPP v1.9, MIDI disabled,
					; normal //floppy, uses ECP & EPP modes
	DCB     &05, 0			; 4 drive support, don't swap drives, normal density,
					; FDC burst mode (default)
;	DCB     &06, &FF		; floppy drive types (default)
;	DCB     &07, 0			; don't auto-powerdown anything
;	DCB     &08, 0			; ADRA7:4 address decode (default)
;	DCB     &09, 0			; ADRx disabled, ADRA10:8 address decode (default)
;	DCB     &0A, 0			; FIFO threshold for ECP // = ??? (default)
;	DCB	&0B, 0			; floppy data rates (default)
;	DCB	&0C, 0			; UART2 & UART1 standard speed, UART2 standard mode,
					; UART2 full duplex, XMIT active hi, RCV active hi (default)
;	DCB	&1E, &80		; GAMECS disabled (default)
;	DCB	&1F, 0			; floppy drive types (default)
	DCB	&20, &FC		; FDC@@3F0-7
	DCB	&21, &7C		; IDE@@1F0-7
	DCB	&22, &FD		; IDE Alternate Status Register @@3F6
	DCB	&23, &9E		; //@@278
	DCB	&24, &FE		; COM1@@3F8
	DCB	&25, &BE		; COM2@@2F8
	DCB	&26, 0			; no FDC DMA, no // DMA (default)
	DCB	&27, 2_01100101		; FDC uses IRQ_F, // uses IRQ_E
	DCB	&28, 2_01000011		; UART1 uses IRQ_D, UART2 uses IRQ_C
	DCB	&29, 0			; IRQIN does not use any IRQ_x (default)
        DCB     &00, 2_10001010         ; Valid config, FDC powered, IDE enabled
        DCB     SMC_endconfig, 0	; Exit config mode

ConfigUMC8669Table
	DCB     UMC_config, &C0, 2_00111110	; IR full-duplex, games off, IDE on,
						; // in EPP & ECP mode, UART2 on, UART1 on, FDC off
	DCB     UMC_config, &C1, 2_00101111	; Direct access PnP register, Disable PnP,
						; IDE@@1F0-7,3F6-7, //@@278, COM2@@2F8, COM1@@3F8,
						; FDC@@3F0-7
	DCB     UMC_config, &C2, 2_10000001	; Not supspended, IR unselected/disabled,
						; don't swap floppy, IBM mode floppy,
						; floppy is R/W (default)
        DCB     UMC_endconfig, 0		; Exit config mode
d1030 7
a1036 1
        ALIGN
d1038 3
a1083 1
        LDRB    r12, [r1, #IOCIRQSTAA]          ; dummy instruction (repeated for FE)
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a349 16
;       SWI OS_ResyncTime
;
; in:   r0  = 0 - Real time clock soft copy only
;       r0 <> 0   reserved for future expansion
;
; out:  r0 preserved
;
ResyncTimeSWI
        Push    "LR"
        BL      CheckYear               ;may have been frozen over new year!
        BL      RTCToRealTime
        Pull    "LR"
        ExitSWIHandler

; *****************************************************************************
;
@


4.1.3.2
log
@RISC OS 3.71 version taken
@
text
@d565 1
a565 1
        CMP     r0, #&E7
d567 3
a569 4
        CMPEQ   r0, #&D4
        MOVEQ   r11, #0                         ;EQ, Medusa
	BEQ	rmtype_nomorris
        MOV     r11, #IOST_7500                 ;NE, assume Morris
d574 2
a575 2
        LDRB    r0, [r12, #IOMD_IRQSTD]                 ;Morris
        TST     r0, #IOMD_Nevent2_bit
a577 1
rmtype_nomorris
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d565 1
a565 1
        CMP     r0, #&E7
d567 3
a569 4
        CMPEQ   r0, #&D4
        MOVEQ   r11, #0                         ;EQ, Medusa
	BEQ	rmtype_nomorris
        MOV     r11, #IOST_7500                 ;NE, assume Morris
d574 2
a575 2
        LDRB    r0, [r12, #IOMD_IRQSTD]                 ;Morris
        TST     r0, #IOMD_Nevent2_bit
a577 1
rmtype_nomorris
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

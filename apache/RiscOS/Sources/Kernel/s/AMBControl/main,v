head	4.4;
access;
symbols
	Kernel-6_14:4.4
	Kernel-6_01-3:4.4
	Kernel-6_13:4.4
	Kernel-6_12:4.4
	Kernel-6_11:4.4
	Kernel-6_10:4.4
	Kernel-6_09:4.4
	Kernel-6_08-4_129_2_10:4.4
	Kernel-6_08-4_129_2_9:4.4
	Kernel-6_08:4.4
	Kernel-6_07:4.4
	Kernel-6_06:4.4
	Kernel-6_05-4_129_2_8:4.4
	Kernel-6_05:4.4
	Kernel-6_04:4.4
	Kernel-6_03:4.4
	Kernel-6_01-2:4.4
	Kernel-6_01-4_146_2_1:4.4
	Kernel-6_02:4.4
	Kernel-6_01-1:4.4
	Kernel-6_01:4.4
	Kernel-6_00:4.4
	Kernel-5_99:4.4
	Kernel-5_98:4.4
	Kernel-5_97-4_129_2_7:4.4
	Kernel-5_97:4.4
	Kernel-5_96:4.4
	Kernel-5_95:4.4
	Kernel-5_94:4.4
	Kernel-5_93:4.4
	Kernel-5_92:4.4
	Kernel-5_91:4.4
	Kernel-5_90:4.4
	Kernel-5_89-4_129_2_6:4.4
	Kernel-5_89:4.4
	Kernel-5_88-4_129_2_5:4.4
	Kernel-5_88-4_129_2_4:4.4
	Kernel-5_88:4.4
	Kernel-5_87:4.4
	Kernel-5_86-4_129_2_3:4.4
	Kernel-5_86-4_129_2_2:4.4
	Kernel-5_86-4_129_2_1:4.4
	Kernel-5_86:4.4
	SMP:4.4.0.2
	SMP_bp:4.4
	Kernel-5_85:4.4
	Kernel-5_54-1:4.2
	Kernel-5_84:4.4
	Kernel-5_83:4.4
	Kernel-5_82:4.4
	Kernel-5_81:4.4
	Kernel-5_80:4.4
	Kernel-5_79:4.4
	Kernel-5_78:4.4
	Kernel-5_77:4.4
	Kernel-5_76:4.4
	Kernel-5_75:4.4
	Kernel-5_74:4.4
	Kernel-5_73:4.4
	Kernel-5_72:4.4
	Kernel-5_71:4.4
	Kernel-5_70:4.4
	Kernel-5_69:4.4
	Kernel-5_68:4.4
	Kernel-5_67:4.4
	Kernel-5_66:4.4
	Kernel-5_65:4.3
	Kernel-5_64:4.3
	Kernel-5_63:4.3
	Kernel-5_62:4.3
	Kernel-5_61:4.3
	Kernel-5_60:4.3
	Kernel-5_59:4.3
	Kernel-5_58:4.3
	Kernel-5_57:4.3
	Kernel-5_56:4.3
	Kernel-5_55:4.3
	Kernel-5_54:4.2
	Kernel-5_53:4.2
	Kernel-5_52:4.2
	Kernel-5_51:4.2
	Kernel-5_50:4.2
	Kernel-5_49:4.2
	HAL_merge:4.1.3.1.8.6
	Kernel-5_48:4.2
	Kernel-5_35-4_79_2_327:4.1.3.1.8.6
	Kernel-5_35-4_79_2_326:4.1.3.1.8.6
	Kernel-5_35-4_79_2_325:4.1.3.1.8.6
	Kernel-5_35-4_79_2_324:4.1.3.1.8.6
	Kernel-5_35-4_79_2_323:4.1.3.1.8.6
	Kernel-5_35-4_79_2_322:4.1.3.1.8.6
	Kernel-5_35-4_79_2_321:4.1.3.1.8.6
	Kernel-5_35-4_79_2_320:4.1.3.1.8.6
	Kernel-5_35-4_79_2_319:4.1.3.1.8.6
	Kernel-5_35-4_79_2_318:4.1.3.1.8.6
	Kernel-5_35-4_79_2_317:4.1.3.1.8.6
	Kernel-5_35-4_79_2_316:4.1.3.1.8.6
	Kernel-5_35-4_79_2_315:4.1.3.1.8.6
	Kernel-5_35-4_79_2_314:4.1.3.1.8.6
	Kernel-5_35-4_79_2_313:4.1.3.1.8.6
	Kernel-5_35-4_79_2_312:4.1.3.1.8.6
	Kernel-5_35-4_79_2_311:4.1.3.1.8.6
	Kernel-5_35-4_79_2_310:4.1.3.1.8.6
	Kernel-5_35-4_79_2_309:4.1.3.1.8.6
	Kernel-5_35-4_79_2_308:4.1.3.1.8.6
	Kernel-5_35-4_79_2_307:4.1.3.1.8.6
	Kernel-5_35-4_79_2_306:4.1.3.1.8.6
	Kernel-5_35-4_79_2_305:4.1.3.1.8.6
	Kernel-5_35-4_79_2_304:4.1.3.1.8.6
	Kernel-5_35-4_79_2_303:4.1.3.1.8.6
	Kernel-5_35-4_79_2_302:4.1.3.1.8.6
	Kernel-5_35-4_79_2_301:4.1.3.1.8.6
	Kernel-5_35-4_79_2_300:4.1.3.1.8.6
	Kernel-5_35-4_79_2_299:4.1.3.1.8.6
	Kernel-5_35-4_79_2_298:4.1.3.1.8.6
	Kernel-5_35-4_79_2_297:4.1.3.1.8.6
	Kernel-5_35-4_79_2_296:4.1.3.1.8.6
	Kernel-5_35-4_79_2_295:4.1.3.1.8.6
	Kernel-5_35-4_79_2_294:4.1.3.1.8.6
	Kernel-5_35-4_79_2_293:4.1.3.1.8.6
	Kernel-5_35-4_79_2_292:4.1.3.1.8.6
	Kernel-5_35-4_79_2_291:4.1.3.1.8.6
	Kernel-5_35-4_79_2_290:4.1.3.1.8.6
	Kernel-5_35-4_79_2_289:4.1.3.1.8.6
	Kernel-5_35-4_79_2_288:4.1.3.1.8.6
	Kernel-5_35-4_79_2_287:4.1.3.1.8.6
	Kernel-5_35-4_79_2_286:4.1.3.1.8.5
	Kernel-5_35-4_79_2_285:4.1.3.1.8.5
	Kernel-5_35-4_79_2_284:4.1.3.1.8.5
	Kernel-5_35-4_79_2_283:4.1.3.1.8.5
	Kernel-5_35-4_79_2_282:4.1.3.1.8.5
	Kernel-5_35-4_79_2_281:4.1.3.1.8.5
	Kernel-5_35-4_79_2_280:4.1.3.1.8.5
	Kernel-5_35-4_79_2_279:4.1.3.1.8.5
	Kernel-5_35-4_79_2_278:4.1.3.1.8.5
	Kernel-5_35-4_79_2_277:4.1.3.1.8.5
	Kernel-5_35-4_79_2_276:4.1.3.1.8.5
	Kernel-5_35-4_79_2_275:4.1.3.1.8.5
	Kernel-5_35-4_79_2_274:4.1.3.1.8.5
	Kernel-5_35-4_79_2_273:4.1.3.1.8.5
	Kernel-5_35-4_79_2_272:4.1.3.1.8.5
	Kernel-5_35-4_79_2_271:4.1.3.1.8.5
	Kernel-5_35-4_79_2_270:4.1.3.1.8.5
	Kernel-5_35-4_79_2_269:4.1.3.1.8.5
	Kernel-5_35-4_79_2_268:4.1.3.1.8.5
	Kernel-5_35-4_79_2_267:4.1.3.1.8.5
	Kernel-5_35-4_79_2_266:4.1.3.1.8.5
	Kernel-5_35-4_79_2_265:4.1.3.1.8.5
	Kernel-5_35-4_79_2_264:4.1.3.1.8.5
	Kernel-5_35-4_79_2_263:4.1.3.1.8.5
	Kernel-5_35-4_79_2_262:4.1.3.1.8.5
	Kernel-5_35-4_79_2_261:4.1.3.1.8.5
	Kernel-5_35-4_79_2_260:4.1.3.1.8.5
	Kernel-5_35-4_79_2_259:4.1.3.1.8.5
	Kernel-5_35-4_79_2_258:4.1.3.1.8.5
	Kernel-5_35-4_79_2_257:4.1.3.1.8.5
	Kernel-5_35-4_79_2_256:4.1.3.1.8.5
	Kernel-5_35-4_79_2_255:4.1.3.1.8.5
	Kernel-5_35-4_79_2_254:4.1.3.1.8.5
	Kernel-5_35-4_79_2_253:4.1.3.1.8.5
	Kernel-5_35-4_79_2_252:4.1.3.1.8.5
	Kernel-5_35-4_79_2_251:4.1.3.1.8.5
	Kernel-5_35-4_79_2_250:4.1.3.1.8.5
	Kernel-5_35-4_79_2_249:4.1.3.1.8.5
	Kernel-5_35-4_79_2_248:4.1.3.1.8.5
	Kernel-5_35-4_79_2_247:4.1.3.1.8.5
	Kernel-5_35-4_79_2_246:4.1.3.1.8.5
	Kernel-5_35-4_79_2_245:4.1.3.1.8.5
	Kernel-5_35-4_79_2_244:4.1.3.1.8.5
	Kernel-5_35-4_79_2_243:4.1.3.1.8.5
	Kernel-5_35-4_79_2_242:4.1.3.1.8.5
	Kernel-5_35-4_79_2_241:4.1.3.1.8.5
	Kernel-5_35-4_79_2_240:4.1.3.1.8.5
	Kernel-5_35-4_79_2_239:4.1.3.1.8.5
	Kernel-5_35-4_79_2_238:4.1.3.1.8.5
	Kernel-5_35-4_79_2_237:4.1.3.1.8.5
	Kernel-5_35-4_79_2_236:4.1.3.1.8.5
	Kernel-5_35-4_79_2_235:4.1.3.1.8.5
	Kernel-5_35-4_79_2_234:4.1.3.1.8.5
	Kernel-5_35-4_79_2_233:4.1.3.1.8.5
	Kernel-5_35-4_79_2_232:4.1.3.1.8.5
	Kernel-5_35-4_79_2_231:4.1.3.1.8.5
	Kernel-5_35-4_79_2_230:4.1.3.1.8.5
	Kernel-5_35-4_79_2_229:4.1.3.1.8.5
	Kernel-5_35-4_79_2_228:4.1.3.1.8.5
	Kernel-5_35-4_79_2_227:4.1.3.1.8.5
	Kernel-5_35-4_79_2_226:4.1.3.1.8.5
	Kernel-5_35-4_79_2_225:4.1.3.1.8.5
	Kernel-5_35-4_79_2_224:4.1.3.1.8.5
	Kernel-5_35-4_79_2_223:4.1.3.1.8.5
	Kernel-5_35-4_79_2_222:4.1.3.1.8.5
	Kernel-5_35-4_79_2_221:4.1.3.1.8.4
	Kernel-5_35-4_79_2_220:4.1.3.1.8.4
	Kernel-5_35-4_79_2_219:4.1.3.1.8.4
	Kernel-5_35-4_79_2_218:4.1.3.1.8.4
	Kernel-5_35-4_79_2_217:4.1.3.1.8.4
	Kernel-5_35-4_79_2_216:4.1.3.1.8.4
	Kernel-5_35-4_79_2_215:4.1.3.1.8.4
	Kernel-5_35-4_79_2_214:4.1.3.1.8.4
	Kernel-5_35-4_79_2_213:4.1.3.1.8.4
	Kernel-5_35-4_79_2_212:4.1.3.1.8.4
	Kernel-5_35-4_79_2_211:4.1.3.1.8.4
	Kernel-5_35-4_79_2_210:4.1.3.1.8.4
	Kernel-5_35-4_79_2_209:4.1.3.1.8.4
	Kernel-5_35-4_79_2_208:4.1.3.1.8.4
	Kernel-5_35-4_79_2_207:4.1.3.1.8.4
	Kernel-5_35-4_79_2_206:4.1.3.1.8.4
	Kernel-5_35-4_79_2_205:4.1.3.1.8.4
	Kernel-5_35-4_79_2_204:4.1.3.1.8.4
	Kernel-5_35-4_79_2_203:4.1.3.1.8.4
	Kernel-5_35-4_79_2_202:4.1.3.1.8.4
	Kernel-5_35-4_79_2_201:4.1.3.1.8.4
	Kernel-5_35-4_79_2_200:4.1.3.1.8.4
	Kernel-5_35-4_79_2_199:4.1.3.1.8.4
	Kernel-5_35-4_79_2_198:4.1.3.1.8.4
	Kernel-5_35-4_79_2_197:4.1.3.1.8.4
	Kernel-5_35-4_79_2_196:4.1.3.1.8.4
	Kernel-5_35-4_79_2_195:4.1.3.1.8.4
	Kernel-5_35-4_79_2_194:4.1.3.1.8.4
	Kernel-5_35-4_79_2_193:4.1.3.1.8.4
	Kernel-5_35-4_79_2_192:4.1.3.1.8.4
	Kernel-5_35-4_79_2_191:4.1.3.1.8.4
	Kernel-5_35-4_79_2_190:4.1.3.1.8.4
	Kernel-5_35-4_79_2_189:4.1.3.1.8.4
	Kernel-5_35-4_79_2_188:4.1.3.1.8.4
	Kernel-5_35-4_79_2_187:4.1.3.1.8.4
	Kernel-5_35-4_79_2_186:4.1.3.1.8.4
	Kernel-5_35-4_79_2_185:4.1.3.1.8.4
	Kernel-5_35-4_79_2_184:4.1.3.1.8.4
	Kernel-5_35-4_79_2_183:4.1.3.1.8.4
	Kernel-5_35-4_79_2_182:4.1.3.1.8.4
	Kernel-5_35-4_79_2_181:4.1.3.1.8.4
	Kernel-5_35-4_79_2_180:4.1.3.1.8.4
	Kernel-5_35-4_79_2_179:4.1.3.1.8.4
	Kernel-5_35-4_79_2_178:4.1.3.1.8.4
	Kernel-5_35-4_79_2_177:4.1.3.1.8.4
	Kernel-5_35-4_79_2_176:4.1.3.1.8.4
	Kernel-5_35-4_79_2_175:4.1.3.1.8.4
	Kernel-5_35-4_79_2_174:4.1.3.1.8.4
	Kernel-5_35-4_79_2_173:4.1.3.1.8.4
	Kernel-5_35-4_79_2_172:4.1.3.1.8.4
	Kernel-5_35-4_79_2_171:4.1.3.1.8.4
	Kernel-5_35-4_79_2_170:4.1.3.1.8.4
	Kernel-5_35-4_79_2_169:4.1.3.1.8.4
	Kernel-5_35-4_79_2_168:4.1.3.1.8.4
	Kernel-5_35-4_79_2_167:4.1.3.1.8.4
	Kernel-5_35-4_79_2_166:4.1.3.1.8.4
	Kernel-5_35-4_79_2_165:4.1.3.1.8.4
	RPi_merge:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_23:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_22:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_21:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_20:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_19:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_18:4.1.3.1.8.4
	Kernel-5_35-4_79_2_164:4.1.3.1.8.4
	Kernel-5_35-4_79_2_163:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_17:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_16:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_15:4.1.3.1.8.4
	Kernel-5_35-4_79_2_162:4.1.3.1.8.4
	Kernel-5_35-4_79_2_161:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_14:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_13:4.1.3.1.8.4
	Kernel-5_35-4_79_2_160:4.1.3.1.8.4
	Kernel-5_35-4_79_2_159:4.1.3.1.8.4
	Kernel-5_35-4_79_2_158:4.1.3.1.8.4
	Kernel-5_35-4_79_2_157:4.1.3.1.8.4
	Kernel-5_35-4_79_2_156:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_12:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_11:4.1.3.1.8.4
	Kernel-5_35-4_79_2_155:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_10:4.1.3.1.8.4
	Kernel-5_35-4_79_2_154:4.1.3.1.8.4
	Kernel-5_35-4_79_2_153:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_9:4.1.3.1.8.4
	Kernel-5_35-4_79_2_152:4.1.3.1.8.4
	Kernel-5_35-4_79_2_151:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_8:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_7:4.1.3.1.8.4
	Kernel-5_35-4_79_2_150:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_6:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_5:4.1.3.1.8.4
	Kernel-5_35-4_79_2_149:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_4:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_3:4.1.3.1.8.4
	Kernel-5_35-4_79_2_148:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_2:4.1.3.1.8.4
	Kernel-5_35-4_79_2_147_2_1:4.1.3.1.8.4
	RPi:4.1.3.1.8.4.0.2
	RPi_bp:4.1.3.1.8.4
	Kernel-5_35-4_79_2_98_2_52_2_1:4.1.3.1.8.3.2.1
	alees_Kernel_dev:4.1.3.1.8.3.2.1.0.2
	alees_Kernel_dev_bp:4.1.3.1.8.3.2.1
	Kernel-5_35-4_79_2_147:4.1.3.1.8.4
	Kernel-5_35-4_79_2_146:4.1.3.1.8.4
	Kernel-5_35-4_79_2_145:4.1.3.1.8.4
	Kernel-5_35-4_79_2_144:4.1.3.1.8.4
	Kernel-5_35-4_79_2_143:4.1.3.1.8.4
	Kernel-5_35-4_79_2_142:4.1.3.1.8.4
	Kernel-5_35-4_79_2_141:4.1.3.1.8.4
	Kernel-5_35-4_79_2_140:4.1.3.1.8.4
	Kernel-5_35-4_79_2_139:4.1.3.1.8.4
	Kernel-5_35-4_79_2_138:4.1.3.1.8.4
	Kernel-5_35-4_79_2_137:4.1.3.1.8.4
	Kernel-5_35-4_79_2_136:4.1.3.1.8.4
	Kernel-5_35-4_79_2_135:4.1.3.1.8.4
	Kernel-5_35-4_79_2_134:4.1.3.1.8.4
	Kernel-5_35-4_79_2_133:4.1.3.1.8.4
	Kernel-5_35-4_79_2_132:4.1.3.1.8.4
	Kernel-5_35-4_79_2_131:4.1.3.1.8.4
	Kernel-5_35-4_79_2_130:4.1.3.1.8.4
	Kernel-5_35-4_79_2_129:4.1.3.1.8.4
	Kernel-5_35-4_79_2_128:4.1.3.1.8.4
	Kernel-5_35-4_79_2_127:4.1.3.1.8.4
	Kernel-5_35-4_79_2_126:4.1.3.1.8.4
	Kernel-5_35-4_79_2_125:4.1.3.1.8.4
	Kernel-5_35-4_79_2_124:4.1.3.1.8.4
	Kernel-5_35-4_79_2_123:4.1.3.1.8.4
	Cortex_merge:4.1.3.1.8.3.2.1
	Kernel-5_35-4_79_2_122:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_54:4.1.3.1.8.3.2.1
	Kernel-5_35-4_79_2_98_2_53:4.1.3.1.8.3.2.1
	Kernel-5_35-4_79_2_98_2_52:4.1.3.1.8.3.2.1
	Kernel-5_35-4_79_2_98_2_51:4.1.3.1.8.3.2.1
	Kernel-5_35-4_79_2_98_2_50:4.1.3.1.8.3.2.1
	Kernel-5_35-4_79_2_98_2_49:4.1.3.1.8.3.2.1
	Kernel-5_35-4_79_2_98_2_48:4.1.3.1.8.3.2.1
	Kernel-5_35-4_79_2_121:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_47:4.1.3.1.8.3
	Kernel-5_35-4_79_2_120:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_46:4.1.3.1.8.3
	Kernel-5_35-4_79_2_119:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_45:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_44:4.1.3.1.8.3
	Kernel-5_35-4_79_2_118:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_43:4.1.3.1.8.3
	Kernel-5_35-4_79_2_117:4.1.3.1.8.3
	Kernel-5_35-4_79_2_116:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_42:4.1.3.1.8.3
	Kernel-5_35-4_79_2_115:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_41:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_40:4.1.3.1.8.3
	Kernel-5_35-4_79_2_114:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_39:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_38:4.1.3.1.8.3
	Kernel-5_35-4_79_2_113:4.1.3.1.8.3
	Kernel-5_35-4_79_2_112:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_37:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_36:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_35:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_34:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_33:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_32:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_31:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_30:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_29:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_28:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_27:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_26:4.1.3.1.8.3
	Kernel-5_35-4_79_2_111:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_25:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_24:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_23:4.1.3.1.8.3
	Kernel-5_35-4_79_2_110:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_22:4.1.3.1.8.3
	Kernel-5_35-4_79_2_109:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_21:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_20:4.1.3.1.8.3
	Kernel-5_35-4_79_2_108:4.1.3.1.8.3
	Kernel-5_35-4_79_2_107:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_19:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_18:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_17:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_16:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_15:4.1.3.1.8.3
	Kernel-5_35-4_79_2_106:4.1.3.1.8.3
	Kernel-5_35-4_79_2_105:4.1.3.1.8.3
	Kernel-5_35-4_79_2_104:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_14:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_13:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_12:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_11:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_10:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_9:4.1.3.1.8.3
	Kernel-5_35-4_79_2_103:4.1.3.1.8.3
	Kernel-5_35-4_79_2_102:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_8:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_7:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_6:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_5:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_4:4.1.3.1.8.3
	Kernel-5_35-4_79_2_101:4.1.3.1.8.3
	Kernel-5_35-4_79_2_100:4.1.3.1.8.3
	Kernel-5_35-4_79_2_99:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_3:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_2:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98_2_1:4.1.3.1.8.3
	Cortex:4.1.3.1.8.3.0.2
	Cortex_bp:4.1.3.1.8.3
	Kernel-5_35-4_79_2_98:4.1.3.1.8.3
	Kernel-5_35-4_79_2_97:4.1.3.1.8.3
	Kernel-5_35-4_79_2_96:4.1.3.1.8.3
	Kernel-5_35-4_79_2_95:4.1.3.1.8.3
	Kernel-5_35-4_79_2_94:4.1.3.1.8.3
	Kernel-5_35-4_79_2_93:4.1.3.1.8.3
	Kernel-5_35-4_79_2_92:4.1.3.1.8.3
	Kernel-5_35-4_79_2_91:4.1.3.1.8.3
	Kernel-5_35-4_79_2_90:4.1.3.1.8.3
	Kernel-5_35-4_79_2_89:4.1.3.1.8.3
	Kernel-5_35-4_79_2_88:4.1.3.1.8.3
	Kernel-5_35-4_79_2_87:4.1.3.1.8.3
	Kernel-5_35-4_79_2_86:4.1.3.1.8.3
	Kernel-5_35-4_79_2_85:4.1.3.1.8.3
	Kernel-5_35-4_79_2_84:4.1.3.1.8.3
	Kernel-5_35-4_79_2_83:4.1.3.1.8.3
	Kernel-5_35-4_79_2_82:4.1.3.1.8.3
	Kernel-5_35-4_79_2_81:4.1.3.1.8.3
	Kernel-5_35-4_79_2_80:4.1.3.1.8.3
	Kernel-5_35-4_79_2_79:4.1.3.1.8.3
	Kernel-5_35-4_79_2_78:4.1.3.1.8.3
	Kernel-5_35-4_79_2_77:4.1.3.1.8.3
	RO_5_07:4.1.3.1.8.3
	Kernel-5_35-4_79_2_76:4.1.3.1.8.3
	Kernel-5_35-4_79_2_75:4.1.3.1.8.3
	Kernel-5_35-4_79_2_74:4.1.3.1.8.3
	Kernel-5_35-4_79_2_73:4.1.3.1.8.3
	Kernel-5_35-4_79_2_72:4.1.3.1.8.3
	Kernel-5_35-4_79_2_71:4.1.3.1.8.3
	Kernel-5_35-4_79_2_70:4.1.3.1.8.3
	Kernel-5_35-4_79_2_69:4.1.3.1.8.3
	Kernel-5_35-4_79_2_68:4.1.3.1.8.3
	Kernel-5_35-4_79_2_67:4.1.3.1.8.3
	Kernel-5_35-4_79_2_66:4.1.3.1.8.3
	Kernel-5_35-4_79_2_65:4.1.3.1.8.3
	Kernel-5_35-4_79_2_64:4.1.3.1.8.3
	Kernel-5_35-4_79_2_63:4.1.3.1.8.3
	Kernel-5_35-4_79_2_62:4.1.3.1.8.3
	Kernel-5_35-4_79_2_61:4.1.3.1.8.3
	Kernel-5_35-4_79_2_59:4.1.3.1.8.3
	Kernel-5_35-4_79_2_58:4.1.3.1.8.3
	Kernel-5_35-4_79_2_57:4.1.3.1.8.3
	Kernel-5_35-4_79_2_56:4.1.3.1.8.3
	Kernel-5_35-4_79_2_55:4.1.3.1.8.3
	Kernel-5_35-4_79_2_54:4.1.3.1.8.3
	Kernel-5_35-4_79_2_53:4.1.3.1.8.3
	Kernel-5_35-4_79_2_52:4.1.3.1.8.3
	Kernel-5_35-4_79_2_51:4.1.3.1.8.3
	Kernel-5_35-4_79_2_50:4.1.3.1.8.3
	Kernel-5_35-4_79_2_49:4.1.3.1.8.3
	Kernel-5_35-4_79_2_48:4.1.3.1.8.3
	Kernel-5_47:4.1.3.1
	Kernel-5_46-4_90_2_1:4.1.3.1
	nbingham_Kernel_FastNC_dev_bp:4.1.3.1
	nbingham_Kernel_FastNC_dev:4.1.3.1.0.12
	Kernel-5_46:4.1.3.1
	Kernel-5_45:4.1.3.1
	Kernel-5_35-4_79_2_47:4.1.3.1.8.3
	Kernel-5_35-4_79_2_46:4.1.3.1.8.3
	Kernel-5_35-4_79_2_45:4.1.3.1.8.3
	Kernel-5_35-4_79_2_44:4.1.3.1.8.3
	Kernel-5_35-4_79_2_25_2_2:4.1.3.1.8.1
	Kernel-5_35-4_79_2_43:4.1.3.1.8.3
	Kernel-5_35-4_79_2_42:4.1.3.1.8.3
	Kernel-5_35-4_79_2_41:4.1.3.1.8.2
	Kernel-5_35-4_79_2_40:4.1.3.1.8.2
	Kernel-5_35-4_79_2_39:4.1.3.1.8.2
	Kernel-5_35-4_79_2_38:4.1.3.1.8.2
	Kernel-5_35-4_79_2_37:4.1.3.1.8.2
	Kernel-5_35-4_79_2_36:4.1.3.1.8.2
	Kernel-5_35-4_79_2_35:4.1.3.1.8.2
	Kernel-5_35-4_79_2_34:4.1.3.1.8.2
	Kernel-5_35-4_79_2_33:4.1.3.1.8.2
	Kernel-5_35-4_79_2_32:4.1.3.1.8.2
	Kernel-5_44:4.1.3.1
	Kernel-5_35-4_79_2_25_2_1:4.1.3.1.8.1
	Kernel-5_43:4.1.3.1
	Kernel-5_35-4_79_2_31:4.1.3.1.8.2
	Kernel-5_35-4_79_2_30:4.1.3.1.8.1
	Kernel-5_35-4_79_2_29:4.1.3.1.8.1
	Kernel-5_35-4_79_2_28:4.1.3.1.8.1
	Kernel-5_35-4_79_2_27:4.1.3.1.8.1
	Kernel-5_35-4_79_2_26:4.1.3.1.8.1
	Kernel-5_42:4.1.3.1
	Kernel-5_41:4.1.3.1
	Kernel-5_40:4.1.3.1
	Kernel-5_35-4_79_2_25:4.1.3.1.8.1
	Kernel-5_35-4_79_2_24:4.1.3.1.8.1
	Kernel-5_35-4_79_2_23:4.1.3.1.8.1
	Kernel-5_35-4_79_2_22:4.1.3.1.8.1
	Kernel-5_35-4_79_2_21:4.1.3.1.8.1
	Kernel-5_35-4_79_2_20:4.1.3.1.8.1
	Kernel-5_35-4_79_2_19:4.1.3.1.8.1
	Kernel-5_35-4_79_2_18:4.1.3.1.8.1
	Kernel-5_35-4_79_2_17:4.1.3.1.8.1
	Kernel-5_35-4_79_2_16:4.1.3.1.8.1
	Kernel-5_35-4_79_2_15:4.1.3.1.8.1
	Kernel-5_35-4_79_2_14:4.1.3.1.8.1
	Kernel-5_39:4.1.3.1
	Kernel-5_13-4_52_2_1:4.1.3.1
	Bethany:4.1.3.1.0.10
	Kernel-5_38:4.1.3.1
	Kernel-5_35-4_79_2_13:4.1.3.1.8.1
	Kernel-5_35-4_79_2_12:4.1.3.1.8.1
	Kernel-5_35-4_79_2_11:4.1.3.1
	Kernel-5_37:4.1.3.1
	Kernel-5_35-4_79_2_10:4.1.3.1
	Kernel-5_35-4_79_2_9:4.1.3.1
	Kernel-5_36:4.1.3.1
	Kernel-5_35-4_79_2_8:4.1.3.1
	Kernel-5_35-4_79_2_7:4.1.3.1
	Kernel-5_35-4_79_2_6:4.1.3.1
	Kernel-5_35-4_79_2_5:4.1.3.1
	Kernel-5_35-4_79_2_4:4.1.3.1
	Kernel-5_35-4_79_2_3:4.1.3.1
	Kernel-5_35-4_79_2_2:4.1.3.1
	dellis_autobuild_BaseSW:4.1.3.1
	Kernel-5_35-4_79_2_1:4.1.3.1
	HAL:4.1.3.1.0.8
	Kernel-5_35:4.1.3.1
	Kernel-5_34:4.1.3.1
	Kernel-5_33:4.1.3.1
	Kernel-5_32:4.1.3.1
	Kernel-5_31:4.1.3.1
	Kernel-5_30:4.1.3.1
	Kernel-5_29:4.1.3.1
	Kernel-5_28:4.1.3.1
	Kernel-5_27:4.1.3.1
	Kernel-5_26:4.1.3.1
	Kernel-5_25:4.1.3.1
	Kernel-5_24:4.1.3.1
	Kernel-5_23:4.1.3.1
	Kernel-5_22:4.1.3.1
	sbrodie_sedwards_16Mar2000:4.1.3.1
	Kernel-5_21:4.1.3.1
	Kernel-5_20:4.1.3.1
	Kernel-5_19:4.1.3.1
	Kernel-5_18:4.1.3.1
	Kernel-5_17:4.1.3.1
	Kernel-5_16:4.1.3.1
	Kernel-5_15:4.1.3.1
	Kernel-5_14:4.1.3.1
	Kernel-5_13:4.1.3.1
	Kernel-5_12:4.1.3.1
	Kernel-5_11:4.1.3.1
	Kernel-5_10:4.1.3.1
	Kernel-5_09:4.1.3.1
	Kernel-5_08:4.1.3.1
	Kernel-5_07:4.1.3.1
	Kernel-5_06:4.1.3.1
	Kernel-5_05:4.1.3.1
	Kernel-5_04:4.1.3.1
	Kernel-5_03:4.1.3.1
	Kernel-5_02:4.1.3.1
	Kernel-5_01:4.1.3.1
	Kernel-5_00:4.1.3.1
	Kernel-4_99:4.1.3.1
	Kernel-4_98:4.1.3.1
	Kernel-4_97:4.1.3.1
	Kernel-4_96:4.1.3.1
	Kernel-4_95:4.1.3.1
	Kernel-4_94:4.1.3.1
	Kernel-4_93:4.1.3.1
	Kernel-4_92:4.1.3.1
	Kernel-4_91:4.1.3.1
	Kernel-4_90:4.1.3.1
	dcotton_autobuild_BaseSW:4.1.3.1
	Kernel-4_89:4.1.3.1
	Kernel-4_88:4.1.3.1
	Kernel-4_87:4.1.3.1
	Kernel-4_86:4.1.3.1
	Kernel-4_85:4.1.3.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.3.1.2.3
	Kernel-4_84:4.1.3.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.3.1.2.3
	Ursula_RiscPC_bp:4.1.3.1.2.3
	Kernel-4_83:4.1.3.1
	Kernel-4_82:4.1.3.1
	Kernel-4_81:4.1.3.1
	Kernel-4_80:4.1.3.1
	Kernel-4_79:4.1.3.1
	Kernel-4_78:4.1.3.1
	Kernel-4_77:4.1.3.1
	Kernel-4_76:4.1.3.1
	Kernel-4_75:4.1.3.1
	Kernel-4_74:4.1.3.1
	Kernel-4_73:4.1.3.1
	Kernel-4_72:4.1.3.1
	Kernel-4_71:4.1.3.1
	Kernel-4_70:4.1.3.1
	Kernel-4_69:4.1.3.1
	Kernel-4_68:4.1.3.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.3.1.2.3
	Ursula_RiscPC:4.1.3.1.2.3.0.2
	Kernel-4_67:4.1.3.1
	Kernel-4_66:4.1.3.1
	Kernel-4_65:4.1.3.1
	Ursula_merge:4.1.3.1
	Kernel-4_64:4.1.3.1
	mstphens_Kernel-3_81:4.1.3.1.2.3
	rthornb_UrsulaBuild-19Aug1998:4.1.3.1.2.3
	UrsulaBuild_FinalSoftload:4.1.3.1.2.3
	rthornb_UrsulaBuild-12Aug1998:4.1.3.1.2.3
	aglover_UrsulaBuild-05Aug1998:4.1.3.1.2.3
	rthornb_UrsulaBuild-29Jul1998:4.1.3.1.2.3
	rthornb_UrsulaBuild-22Jul1998:4.1.3.1.2.3
	rthornb_UrsulaBuild-15Jul1998:4.1.3.1.2.3
	rthornb_UrsulaBuild-07Jul1998:4.1.3.1.2.3
	rthornb_UrsulaBuild-17Jun1998:4.1.3.1.2.3
	rthornb_UrsulaBuild-03Jun1998:4.1.3.1.2.3
	rthornb_UrsulaBuild-27May1998:4.1.3.1.2.3
	mstphens_Kernel-3_80:4.1.3.1.2.3
	rthornb_UrsulaBuild-21May1998:4.1.3.1.2.3
	rthornb_UrsulaBuild_01May1998:4.1.3.1.2.3
	afrost_NC2_Generic:4.1.3.1
	Daytona:4.1.3.1.0.6
	Daytona_bp:4.1.3.1
	Ursula_bp:4.1.3.1
	Ursula:4.1.3.1.0.2
	RO_3_71:4.1.3.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	StrongARM:4.1.3;
locks; strict;
comment	@# @;


4.4
date	2016.12.13.16.42.53;	author jlee;	state Exp;
branches;
next	4.3;
commitid	aGog9bB8f4QKlQxz;

4.3
date	2016.08.02.22.10.47;	author jlee;	state Exp;
branches;
next	4.2;
commitid	CnQYuUGzojQfrMgz;

4.2
date	2016.06.30.20.08.12;	author jlee;	state Exp;
branches;
next	4.1;
commitid	IWoXxARWeuLDOwcz;

4.1
date	96.11.06.02.01.34;	author nturton;	state Exp;
branches
	4.1.3.1;
next	;

4.1.3.1
date	96.11.06.02.01.34;	author nturton;	state Exp;
branches
	4.1.3.1.2.1
	4.1.3.1.8.1;
next	;

4.1.3.1.2.1
date	97.05.21.09.30.32;	author mstphens;	state Exp;
branches;
next	4.1.3.1.2.2;

4.1.3.1.2.2
date	97.09.09.13.33.53;	author mstphens;	state Exp;
branches;
next	4.1.3.1.2.3;

4.1.3.1.2.3
date	98.03.26.11.26.15;	author mstphens;	state Exp;
branches;
next	;

4.1.3.1.8.1
date	2000.11.10.14.41.16;	author mstephen;	state Exp;
branches;
next	4.1.3.1.8.2;

4.1.3.1.8.2
date	2001.05.22.15.27.55;	author mstephen;	state Exp;
branches;
next	4.1.3.1.8.3;

4.1.3.1.8.3
date	2001.06.27.14.16.27;	author mstephen;	state Exp;
branches
	4.1.3.1.8.3.2.1;
next	4.1.3.1.8.4;

4.1.3.1.8.4
date	2011.11.26.21.11.20;	author jlee;	state Exp;
branches;
next	4.1.3.1.8.5;
commitid	cI3W0zbtALQG6TIv;

4.1.3.1.8.5
date	2014.04.20.17.00.24;	author jlee;	state Exp;
branches;
next	4.1.3.1.8.6;
commitid	6eesW4yWEAvSyrxx;

4.1.3.1.8.6
date	2015.09.06.18.45.17;	author jlee;	state Exp;
branches;
next	;
commitid	9JoJW3FhqXIqWdAy;

4.1.3.1.8.3.2.1
date	2011.08.08.23.28.30;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;


desc
@@


4.4
log
@Reimplement AMBControl ontop of the PMP system
Detail:
  With this set of changes, each AMB node is now the owner of a fake DANode which is linked to a PMP.
  From a user's perspective the behaviour of AMBControl is the same as before, but rewriting it to use PMPs internally offers the following (potential) benefits:
  * Reduction in the amount of code which messes with the CAM & page tables, simplifying future work/maintenance. Some of the AMB ops (grow, shrink) now just call through to OS_ChangeDynamicArea. However all of the old AMB routines were well-optimised, so to avoid a big performance hit for common operations not all of them have been removed (e.g. mapslot / mapsome). Maybe one day these optimal routines will be made available for use by regular PMP DAs.
  * Removal of the slow Service_MemoryMoved / Service_PagesSafe handlers that had to do page list fixup after the core kernel had reclaimed/moved pages. Since everything is a PMP, the kernel will now deal with this on behalf of AMB.
  * Removal of a couple of other slow code paths (e.g. Do_AMB_MakeUnsparse calls from OS_ChangeDynamicArea)
  * Potential for more flexible mapping of application space in future, e.g. sparse allocation of memory to the wimp slot
  * Simpler transition to an ASID-based task swapping scheme on ARMv6+?
  Other changes of note:
  * AMB_LazyMapIn switch has been fixed up to work correctly (i.e. turning it off now disables lazy task swapping and all associated code instead of producing a build error)
  * The DANode for the current app should be accessed via the GetAppSpaceDANode macro. This will either return the current AMB DANode, or AppSpaceDANode (if e.g. pre-Wimp). However be aware that AppSpaceDANode retains the legacy behaviour of having a base + size relative to &0, while the AMB DANodes (identifiable via the PMP flag) are sane and have their base + size relative to &8000.
  * Mostly-useless DebugAborts switch removed
  * AMBPhysBin (page number -> phys addr lookup table) removed. Didn't seem to give any tangible performance benefit, and was imposing hidden restrictions on memory usage (all phys RAM fragments in PhysRamTable must be multiple of 512k). And if it really was a good optimisation, surely it should have been applied to all areas of the kernel, not just AMB!
  Other potential future improvements:
  * Turn the fake DANodes into real dynamic areas, reducing the amount of special code needed in some places, but allow the DAs to be hidden from OS_DynamicArea 3 so that apps/users won't get too confused
  * Add a generic abort trapping system to PMPs/DAs (lazy task swapping abort handler is still a special case)
  File changes:
  - s/ARM600, s/VMSAv6, s/ExtraSWIs - Remove DebugAborts
  - s/ArthurSWIs - Remove AMB service call handler dispatch
  - s/ChangeDyn - AMB_LazyMapIn switch fixes. Add alternate internal entry points for some PMP ops to allow the DANode to be specified (used by AMB)
  - s/Exceptions - Remove DebugAborts, AMB_LazyMapIn switch fixes
  - s/Kernel - Define GetAppSpaceDANode macro, AMB_LazyMapIn switch fix
  - s/MemInfo - AMB_LazyMapIn switch fixes
  - s/AMBControl/AMB - Update GETs
  - s/AMBControl/Memory - Remove block size quantisation, AMB_BlockResize (page list blocks are now allocated by PMP code)
  - s/AMBControl/Options - Remove PhysBin definitions, AMBMIRegWords (moved to Workspace file), AMB_LimpidFreePool switch. Add AMB_Debug switch.
  - s/AMBControl/Workspace - Update AMBNode to contain an embedded DANode. Move AMBMIRegWords here from Options file.
  - s/AMBControl/allocate - Fake DA node initialisation
  - s/AMBControl/deallocate - Add debug output
  - s/AMBControl/growp, growshrink, mapslot, mapsome, shrinkp - Rewrite to use PMP ops where possible, add debug output
  - s/AMBControl/main - Remove PhysBin initialisation. Update the enumerate/mjs_info call.
  - s/AMBControl/memmap - Low-level memory mapping routines updated or rewritten as appropriate.
  - s/AMBControl/readinfo - Update to cope with DANode
  - s/AMBControl/service - Remove old service call handlers
  - s/AMBControl/handler - DA handler for responding to PMP calls from OS_ChangeDynamicArea; just calls through to growpages/shrinkpages as appropriate.
Admin:
  Tested on pretty much everything currently supported


Version 5.66. Tagged as 'Kernel-5_66'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

; > s.main 

;;; Initialisation
;
AMBControl_Init
        Push    "R0-R4,R12,LR"

;claim main workspace
        LDR     R3,=AMBmaxwork
        BL      ClaimSysHeapNode
;;;     BVS     err_cantclaim - this should not happen

;don't store ws pointer till end of initialise - service routines must
;know when initialise is not yet complete
;
        MOV     R12,R2      

;zero-init workspace
        MOV     R1,#0
        LDR     R3,=AMBmaxwork
        ADD     R3,R3,R2
00
        STR     R1,[R2],#4
        CMP     R2,R3
        BLO     %BT00        

;claim block for handle array
        MOV     R3,#(AMBInitialMaxNodes:SHL:2)
        BL      ClaimSysHeapNode
;;;     BVS     err_cantclaim
        STR     R2,AMBNodeHandles

;put all handles on free list (entry 0 is used as hdr of free list)
        MOV     R0,#1
        MOV     R1,#AMBInitialMaxNodes
        STR     R1,AMBNhandles
01
        STR     R0,[R2],#4
        ADD     R0,R0,#1
        CMP     R0,R1
        BNE     %BT01
        MOV     R0,#0       ; = end of list
        STR     R0,[R2]

;init any other workspace that shouldn't init as 0
        ADR     R1,AMBAnchorNode
        STR     R1,[R1,#AMBNode_prev]  ;anchor prev initially -> anchor (empty list)
        STR     R1,[R1,#AMBNode_next]  ;anchor next initially -> anchor (empty list)
  [ AMB_LazyMapIn
        LDR     R0,=ZeroPage
        LDR     R0,[R0,#ProcessorFlags]
        TST     R0,#CPUFlag_BaseRestored
        MOVEQ   R1,#AMBFlag_LazyMapIn_disable  ;laziness not supported if we can't trivially restart after abort (because we're lazy!)
        MOVNE   R1,#0                          ;yipee, laziness enabled (and not suspended)
        TST     R0,#CPUFlag_AbortRestartBroken ;but wait! can't use for bugged chips (eg. pre rev T StrongARM)
        MOVNE   R1,#AMBFlag_LazyMapIn_disable
        STR     R1,AMBFlags

; Calculate default page flags
        MOV     R0, #0
        MOV     R1, #0
        GetPTE  R0, 4K, R0, R1
        STR     R0,AMBPageFlags
  |
        MOV     R1,#AMBFlag_LazyMapIn_disable
        STR     R1,AMBFlags
  ]
        LDR     R0,=ZeroPage+AMBControl_ws
        STR     R12,[R0]               ;now initialisation is complete

        Pull    "R0-R4,R12,PC"


; OS_AMBControl SWI handler
; entry:
;   R0 = reason code (bits 0..7) and flags (bits 8..31), flags depend on reason
;   other regs. depend on reason code
; exit:
;   R0 preserved
;   other regs. depend on reason code

AMBControlSWI
        LDR     R12,=ZeroPage+AMBControl_ws
        LDR     R12,[R12]
 
        AND     R11,R0,#&FF
        CMP     R11,#(reasons0-reasons1)/4
        ADDCC   PC,PC,R11,LSL #2        ;Despatch if within a suitable range
        B       reasons1
reasons0
        B       allocate     ;0
        B       deallocate   ;1
        B       growshrink   ;2
        B       mapslot      ;3
        B       readinfo     ;4
  [ AMB_LazyMapIn
        B       laziness     ;5
  |
        B       reserved     ;5
  ]
        B       reserved     ;6
        B       reserved     ;7
        B       mjs_info     ;8 - system reason code, dumps info to buffer
reasons1
        ADR     R0,err_badreason
        B       SLVK_SetV


  [ AMB_LazyMapIn
;
;entry: R0=5 (reason),R1=1 for lazy on, 0 for lazy off, -1 to read lazy only
;exit: R1=new lazy value, after any restrictions of platform applied
;
;action: if reading only, if lazy disabled, or if new state = current, do nothing
;        if state is changing, map out any current node, change state, map in any current node
;
laziness ROUT
       Push    "R2-R3,LR"
       CMP     R1,#-1
       BEQ     %FT20
       LDR     R2,AMBFlags                      ;R2 := current flags
       TST     R2,#AMBFlag_LazyMapIn_disable    ;disable is permanent
       BNE     %FT20
       CMP     R1,#0
       MOV     R1,R2
       ORREQ   R1,R1,#AMBFlag_LazyMapIn_suspend
       BICNE   R1,R1,#AMBFlag_LazyMapIn_suspend ;R1 := new flags
       EOR     R3,R1,R2
       TST     R3,#AMBFlag_LazyMapIn_suspend    ;is suspend status changing?
       BEQ     %FT20
       LDR     R3,AMBMappedInNode
       CMP     R3,#0
       BEQ     %FT10
       Push    "R0-R3"
       MOV     R0,#3
       MOV     R1,#-1
       LDR     R2,[R3,#AMBNode_handle]
       SWI     XOS_AMBControl                   ;map out current node
       Pull    "R0-R3"
10
       STR     R1,AMBFlags
       CMP     R3,#0
       BEQ     %FT20
       Push    "R0-R3"
       MOV     R0,#3
       MOV     R1,#0
       LDR     R2,[R3,#AMBNode_handle]
       SWI     XOS_AMBControl                   ;map in current node
       Pull    "R0-R3"
20
       LDR     R1,AMBFlags
       TST     R1,#AMBFlag_LazyMapIn_disable :OR: AMBFlag_LazyMapIn_suspend
       MOVEQ   R1,#1
       MOVNE   R1,#0
       Pull    "R2-R3,LR"
       B       SLVK
;
  ] ;AMB_LazyMapIn


;entry: R0=8 (reason),R1 -> buffer (say 4k for up to 255 tasks)
;exit: buffer filled:
;       0   Ntasks
;       4   Handle of mapped in task (or 0)
;       8   Handle 1
;      12   Npages 1
;      16   Logical address 1
;      20   PPL 1
;      24   Handle 2
;      28   Npages 2
;      32   Logical address 2
;      36   PPL 2
;      ...
mjs_info
       Push    "R1-R7,LR"
       LDR     R2,AMBNtasks
       STR     R2,[R1],#4
       LDR     R2,AMBMappedInNode
       CMP     R2,#0
       LDRNE   R2,[R2,#AMBNode_handle]
       STR     R2,[R1],#4
       ADR     R2,AMBAnchorNode
       MOV     R7,R2
       LDR     LR,=DynAreaFlags_AccessMask
01
       LDR     R2,[R2,#AMBNode_next]
       CMP     R2,R7
       BEQ     %FT02
       LDR     R3,[R2,#AMBNode_handle]
       LDR     R4,[R2,#AMBNode_DANode+DANode_PMPSize]
       LDR     R5,[R2,#AMBNode_DANode+DANode_Base]
       LDR     R6,[R2,#AMBNode_DANode+DANode_Flags]
       AND     R6,R6,LR
       STMIA   R1!,{R3-R6}
       B       %BT01
02
       Pull    "R1-R7,LR"
       B       SLVK

reserved
       ADR     R0,err_reserved
       B       SLVK_SetV

;;; errors (sod internationalisation)

err_badreason
        DCD     0
        DCB     "bad AMBControl reason code",0
        ALIGN

err_reserved
        DCD     0
        DCB     "reserved AMBControl reason code",0
        ALIGN

err_nomorehandles
        DCD     0
        DCB     "AMBControl handles exhausted",0
        ALIGN

   END
@


4.3
log
@Add support for shareable pages and additional access privileges
Detail:
  This set of changes:
  * Refactors page table entry encoding/decoding so that it's (mostly) performed via functions in the MMU files (s.ARM600, s.VMSAv6) rather than on an ad-hoc basis as was the case previously
  * Page table entry encoding/decoding performed during ROM init is also handled via the MMU functions, which resolves some cases where the wrong cache policy was in use on ARMv6+
  * Adds basic support for shareable pages - on non-uniprocessor systems all pages will be marked as shareable (however, we are currently lacking ARMops which broadcast cache maintenance operations to other cores, so safe sharing of cacheable regions isn't possible yet)
  * Adds support for the VMSA XN flag and the "privileged ROM" access permission. These are exposed via RISC OS access privileges 4 and above, taking advantage of the fact that 4 bits have always been reserved for AP values but only 4 values were defined
  * Adds OS_Memory 17 and 18 to convert RWX-style access flags to and from RISC OS access privelege numbers; this allows us to make arbitrary changes to the mappings of AP values 4+ between different OS/hardware versions, and allows software to more easily cope with cases where the most precise AP isn't available (e.g. no XN on <=ARMv5)
  * Extends OS_Memory 24 (CheckMemoryAccess) to return executability information
  * Adds exported OSMem header containing definitions for OS_Memory and OS_DynamicArea
  File changes:
  - Makefile - export C and assembler versions of hdr/OSMem
  - Resources/UK/Messages - Add more text for OS_Memory errors
  - hdr/KernelWS - Correct comment regarding DCacheCleanAddress. Allocate workspace for MMU_PPLTrans and MMU_PPLAccess.
  - hdr/OSMem - New file containing exported OS_Memory and OS_DynamicArea constants, and public page flags
  - hdr/Options - Reduce scope of ARM6support to only cover builds which require ARMv3 support
  - s/AMBControl/Workspace - Clarify AMBNode_PPL usage
  - s/AMBControl/growp, mapslot, mapsome, memmap - Use AreaFlags_ instead of AP_
  - s/AMBControl/main, memmap - Use GetPTE instead of generating page table entry manually
  - s/ARM600 - Remove old coments relating to lack of stack. Update BangCam to use GetPTE. Update PPL tables, removing PPLTransL1 (L1 entries are now derived from L2 table on demand) and adding a separate table for ARM6. Implement the ARM600 versions of the Get*PTE ('get page table entry') and Decode*Entry functions
  - s/ARMops - Add Init_PCBTrans function to allow relevant MMU_PPLTrans/MMU_PCBTrans pointers to be set up during the pre-MMU stage of ROM init. Update ARM_Analyse to set up the pointers that are used post MMU init.
  - s/ChangeDyn - Move a bunch of flags to hdr/OSMem. Rename the AP_ dynamic area flags to AreaFlags_ to avoid name clashes and confusion with the page table AP_ values exported by Hdr:MEMM.ARM600/Hdr:MEMM.VMSAv6. Also generate the relevant flags for OS_Memory 24 so that it can refer to the fixed areas by their name instead of hardcoding the permissions.
  - s/GetAll - GET Hdr:OSMem
  - s/HAL - Change initial page table setup to use DA/page flags and GetPTE instead of building page table entries manually. Simplify AllocateL2PT by removing the requirement for the user to supply the access perimssions that will be used for the area; instead for ARM6 we just assume that cacheable memory is the norm and set L1_U for any L1 entry we create here.
  - s/Kernel - Add GetPTE macro (for easier integration of Get*PTE functions) and GenPPLAccess macro (for easy generation of OS_Memory 24 flags)
  - s/MemInfo - Fixup OS_Memory 0 to not fail on seeing non-executable pages. Implement OS_Memory 17 & 18. Tidy up some error generation. Make OS_Memory 13 use GetPTE. Extend OS_Memory 24 to return (non-) executability information, to use the named CMA_ constants generated by s/ChangeDyn, and to use the Decode*Entry functions when it's necessary to decode page table entries.
  - s/NewReset - Use AreaFlags_ instead of AP_
  - s/VMSAv6 - Remove old comments relating to lack of stack. Update BangCam to use GetPTE. Update PPL tables, removing PPLTransL1 (L1 entries are now derived from L2 table on demand) and adding a separate table for shareable pages. Implement the VMSAv6 versions of the Get*PTE and Decode*Entry functions.
Admin:
  Tested on Raspberry Pi 1, Raspberry Pi 3, Iyonix, RPCEmu (ARM6 & ARM7), comparing before and after CAM and page table dumps to check for any unexpected differences


Version 5.55. Tagged as 'Kernel-5_55'
@
text
@a59 28
;claim block for PhysBin array
        LDR     R3,=ZeroPage+MaxCamEntry
        LDR     R3,[R3]
        ADD     R3,R3,#1                   ;no. of RAM pages extant
        MOV     R3,R3,LSR #AMBPhysBinShift ;no. of bin entries reqd.
        STR     R3,AMBPhysBinEntries
        MOV     R3,R3,LSL #2               ;1 word per entry
        BL      ClaimSysHeapNode
;;;     BVS     err_cantclaim
        STR     R2,AMBPhysBin

;init PhysBin
        LDR     R0,=ZeroPage+PhysRamTable
        LDR     R3,AMBPhysBin
        LDR     R4,AMBPhysBinEntries
        LDMIA   R0!,{R1,R2}             ;address,size of first physical fragment
        MOV     R2,R2,LSR #Log2PageSize ;no. pages in fragment
        B       %FT04
03
        ADD     R1,R1,#(1:SHL:(Log2PageSize+AMBPhysBinShift)) ;next bin address
        SUBS    R2,R2,#(1:SHL:AMBPhysBinShift)                ;no. pages binned
        LDMLEIA R0!,{R1,R2}             ;address,size of next physical fragment
        MOVLE   R2,R2,LSR #Log2PageSize ;no. pages in fragment
04
        STR     R1,[R3],#4
        SUBS    R4,R4,#1
        BNE     %BT03

d199 1
d205 4
a208 3
       LDR     R4,[R2,#AMBNode_Npages]
       LDR     R5,[R2,#AMBNode_startaddr]
       LDR     R6,[R2,#AMBNode_PPL]
@


4.2
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@d103 4
a106 14
        LDR     r2,=ZeroPage
    [ MEMM_Type = "VMSAv6"
        ADRL    r1,PPLTrans
    |
        LDR     r1, [r2, #ProcessorFlags]
        TST     r1, #CPUFlag_ExtendedPages
        ADREQL  r1, PPLTrans
        ADRNEL  r1, PPLTransX
    ]
        LDR     r3,[r1]                     ; Page type + access flags
        LDR     r2,[r2,#MMU_PCBTrans]
        LDRB    r2,[r2]                     ; Cacheability + other attribs
        ORR     r3,r3,r2
        STR     r3,AMBPageFlags
@


4.1
log
@Initial revision
@
text
@d16 1
a16 3
; AMBControl - takes care of application memory management (for Wimp)

;Nov 95 - Started by mjs
d23 1
d26 1
a26 1
;;;        BVS     err_cantclaim - this should not happen
d33 10
a42 1
;block for handle array
d45 1
a45 1
;;;        BVS     err_cantclaim
d60 2
a61 2
;block for PhysBin array
        LDR     R3,=MaxCamEntry
d68 1
a68 1
;;;        BVS     err_cantclaim
d72 1
a72 1
        MOV     R0,#PhysRamTable
d88 1
a88 4
; init anchor node stuff etc.
        MOV     R0,#0
        STR     R0,AMBNtasks
        STR     R0,AMBMappedInNode
d90 33
a122 11
        MOV     R3,R1
        STR     R0,[R1],#4  ; node id = 0 for ank node (not a real node!)
        STR     R0,[R1],#4  ; handle = 0
        STR     R3,[R1],#4  ; prev (starts -> ank node)
        STR     R3,[R1],#4  ; next (starts -> ank node)
        STR     R0,[R1],#4  ; Npages
        STR     R0,[R1],#4  ; startaddr
        STR     R0,[R1],#4  ; PPL

        MOV     R0,#AMBControl_ws
        STR     R12,[R0]           ;now initialisation is complete
d136 1
a136 1
        MOV     R12,#AMBControl_ws
d149 3
d153 1
d162 52
a256 5
;;;err_cantclaim
;;;        DCD     0
;;;        DCB     "AMBControl failed to claim workspace",0
;;;        ALIGN

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.3.1.8.1
log
@reintroduce Ursula AMBControl, recoded with generic ARMop style, not debugged yet

Version 5.35, 4.79.2.12. Tagged as 'Kernel-5_35-4_79_2_12'
@
text
@d16 3
a18 1
; > s.main 
a24 1
;claim main workspace
d27 1
a27 1
;;;     BVS     err_cantclaim - this should not happen
d34 1
a34 10
;zero-init workspace
        MOV     R1,#0
        LDR     R3,=AMBmaxwork
        ADD     R3,R3,R2
00
        STR     R1,[R2],#4
        CMP     R2,R3
        BLO     %BT00        

;claim block for handle array
d37 1
a37 1
;;;     BVS     err_cantclaim
d52 1
a52 1
;claim block for PhysBin array
d60 1
a60 1
;;;     BVS     err_cantclaim
d80 4
a83 1
;init any other workspace that shouldn't init as 0
d85 9
a93 11
        STR     R1,[R1,#AMBNode_prev]  ;anchor prev initially -> anchor (empty list)
        STR     R1,[R1,#AMBNode_next]  ;anchor next initially -> anchor (empty list)
  [ AMB_LazyMapIn
        ; currently always disable, need to sort out when abort fix up is supported
        ; and for which ARMs
        ;
        ! 0, "AMBControl currently always disables LazyMapIn (needs abort handler hooks)"
        ;
        MOV     R1,#AMBFlag_LazyMapIn_disable
        STR     R1,AMBFlags
  ]
d95 1
a95 1
        STR     R12,[R0]               ;now initialisation is complete
a121 3
  [ AMB_LazyMapIn
        B       laziness     ;5
  |
a122 1
  ]
a130 52
  [ AMB_LazyMapIn
;
;entry: R0=5 (reason),R1=1 for lazy on, 0 for lazy off, -1 to read lazy only
;exit: R1=new lazy value, after any restrictions of platform applied
;
;action: if reading only, if lazy disabled, or if new state = current, do nothing
;        if state is changing, map out any current node, change state, map in any current node
;
laziness ROUT
       Push    "R2-R3,LR"
       CMP     R1,#-1
       BEQ     %FT20
       LDR     R2,AMBFlags                      ;R2 := current flags
       TST     R2,#AMBFlag_LazyMapIn_disable    ;disable is permanent
       BNE     %FT20
       CMP     R1,#0
       MOV     R1,R2
       ORREQ   R1,R1,#AMBFlag_LazyMapIn_suspend
       BICNE   R1,R1,#AMBFlag_LazyMapIn_suspend ;R1 := new flags
       EOR     R3,R1,R2
       TST     R3,#AMBFlag_LazyMapIn_suspend    ;is suspend status changing?
       BEQ     %FT20
       LDR     R3,AMBMappedInNode
       CMP     R3,#0
       BEQ     %FT10
       Push    "R0-R3"
       MOV     R0,#3
       MOV     R1,#-1
       LDR     R2,[R3,#AMBNode_handle]
       SWI     XOS_AMBControl                   ;map out current node
       Pull    "R0-R3"
10
       STR     R1,AMBFlags
       CMP     R3,#0
       BEQ     %FT20
       Push    "R0-R3"
       MOV     R0,#3
       MOV     R1,#0
       LDR     R2,[R3,#AMBNode_handle]
       SWI     XOS_AMBControl                   ;map in current node
       Pull    "R0-R3"
20
       LDR     R1,AMBFlags
       TST     R1,#AMBFlag_LazyMapIn_disable :OR: AMBFlag_LazyMapIn_suspend
       MOVEQ   R1,#1
       MOVNE   R1,#0
       Pull    "R2-R3,LR"
       B       SLVK
;
  ] ;AMB_LazyMapIn


d173 5
@


4.1.3.1.8.2
log
@Reimplement Lazy task swapping, an amusing idea from Ursula,
would have done it sooner but couldn't be bothered (humour).
Currently activates for all ARMs flagged as base-restored
abort model. No handling of eg. StrongARM pre-revT bug, but
then the kernel no longer runs on StrongARM (progress).
Still some details to fix: all aborts in current app space
assumed to be missing pages, but this must be fixed to
handle abort code in app space, things like debuggers
marking code read only.

Plus, small fixes:
  OS_Memory 8 returns vaguely useful info for RAM,VRAM
  in HAL build (temporary partial implementation)
  Broken handling of old BBC commands with (fx,tv etc)
  with no spaces fixed (fudgeulike code from Ursula,
  now 32-bit).

Version 5.35, 4.79.2.31. Tagged as 'Kernel-5_35-4_79_2_31'
@
text
@d93 6
a98 5
        MOV     R0,#0
        LDR     R0,[R0,#ProcessorFlags]
        TST     R0,#CPUFlag_BaseRestored
        MOVEQ   R1,#AMBFlag_LazyMapIn_disable  ;laziness not supported if we can't trivially restart after abort (because we're lazy!)
        MOVNE   R1,#0                          ;yipee, laziness enabled (and not suspended)
@


4.1.3.1.8.3
log
@StrongARM is back, and this time it's provisional!

IOMD HAL:
  enables fast clock for StrongARM on Medusa h/w

Kernel:
  ARMops for StrongARM implemented. Tested moderately on
  HAL/32-bit minimal desktop build for Risc PC. Could do
  with more testing later. eg. does reentrant cache
  cleaning support really work?
  Lazy task swapping is enabled for revT or later, wahey.

Version 5.35, 4.79.2.42. Tagged as 'Kernel-5_35-4_79_2_42'
@
text
@a97 2
        TST     R0,#CPUFlag_AbortRestartBroken ;but wait! can't use for bugged chips (eg. pre rev T StrongARM)
        MOVNE   R1,#AMBFlag_LazyMapIn_disable
@


4.1.3.1.8.4
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d61 1
a61 1
        LDR     R3,=ZeroPage+MaxCamEntry
d72 1
a72 1
        LDR     R0,=ZeroPage+PhysRamTable
d93 1
a93 1
        LDR     R0,=ZeroPage
d102 1
a102 1
        LDR     R0,=ZeroPage+AMBControl_ws
d117 1
a117 1
        LDR     R12,=ZeroPage+AMBControl_ws
@


4.1.3.1.8.5
log
@Add OS_Memory 24 implementation. Change OS_ValidateAddress to use it. Fix kernel leaving the physical access MB in a messy state. Try and protect against infinite abort loops caused by bad environment handlers.
Detail:
  s/MemInfo - Added an implementation of ROL's OS_Memory 24 call. Unlike the old OS_ValidateAddress call, this call should successfully report the presence of all memory areas known to the kernel. It should also correctly indicate which parts of a sparse DA are mapped in, unlike the old OS_ValidateAddress implementation.
  s/ChangeDyn - Update dynamic area handling to construct a lookup table for mapping logical addresses to dynamic areas; this is used by OS_Memory 24 to quickly locate which DA(s) hit a given region
  s/AMBControl/main - Make sure lazy task swapping is marked as disabled when AMB_LazyMapIn is {FALSE} - required so that OS_Memory 24 will give application space the correct flags
  s/ArthurSWIs - Switch OS_ValidateAddress over to using OS_Memory 24, as per ROL. For compatibility, Service_ValidateAddress is still issued for any areas which the kernel doesn't recognise (currently, OS_Memory 24 doesn't issue any service calls itself)
  s/Convrsions - ADR -> ADRL to keep things happy
  s/HAL - Fix L2PT page allocation and RAM clear to release the physical access region once they're done with it
  s/Kernel - Make the error dispatcher validate the error handler code ptr & error buffer using OS_Memory 24 before attempting to use them. If they look bad, reset to default. Should prevent getting stuck in an infinite abort loop in some situations (e.g. as was the case with ticket 279). The system might not fully recover, but it's better than a hard crash.
  s/Middle - Rework data/prefetch/etc. abort handlers so that DumpyTheRegisters can validate the exception dump area via OS_Memory 24 before anything gets written to it. Should also help to prevent some infinite abort loops. Strip 26bit/pre-HAL code to make things a bit more readable.
  hdr/KernelWS - Update comment
Admin:
  Tested on BB-xM, Raspberry Pi


Version 5.35, 4.79.2.222. Tagged as 'Kernel-5_35-4_79_2_222'
@
text
@a100 3
  |
        MOV     R1,#AMBFlag_LazyMapIn_disable
        STR     R1,AMBFlags
@


4.1.3.1.8.6
log
@Misc memory management tweaks & fixes
Detail:
  s/ChangeDyn - Fix OS_DynamicArea 20 to work properly with sparse & PMP DAs. It now checks against the max extent of the area rather than the current size; this matches the logic used for checking fixed system workspace areas. The call only determines the ownership of a logical address, and it's considered the caller's responsibility to check if there's actually a page at the given address.
  s/ChangeDyn - Revise OS_DynamicArea 25 to remove the redundant 'PMP page flags' entry, and to allow pages to be looked up by either PMP page index, phys page number, or DA page index
  s/ChangeDyn - Tidy up InitDynamicAreas by adding the NextFreePage routine to help determine the next page to be added to the free pool.
  s/AMBControl/Workspace, s/AMBControl/main, s/AMBControl/memmap - Fix lazy mapping in of pages to use the correct L2PT flags for the default CB cache policy
  s/AMBControl/allocate - Get rid of magic constant when extracting page flags from DA flags, and make note of the fact that assorted bits of code ignore the flags
  s/AMBControl/growp, s/AMBControl/shrinkp - Reverse the page order when growing/shrinking areas, to match OS_ChangeDynamicArea. This helps both DAs and application space to have pages allocated to them in contiguous physical order - which in turn helps produce shorter, more optimal scatter lists for DMA
Admin:
  Tested on Pandaboard


Version 5.35, 4.79.2.287. Tagged as 'Kernel-5_35-4_79_2_287'
@
text
@a100 16

; Calculate default page flags
        LDR     r2,=ZeroPage
    [ MEMM_Type = "VMSAv6"
        ADRL    r1,PPLTrans
    |
        LDR     r1, [r2, #ProcessorFlags]
        TST     r1, #CPUFlag_ExtendedPages
        ADREQL  r1, PPLTrans
        ADRNEL  r1, PPLTransX
    ]
        LDR     r3,[r1]                     ; Page type + access flags
        LDR     r2,[r2,#MMU_PCBTrans]
        LDRB    r2,[r2]                     ; Cacheability + other attribs
        ORR     r3,r3,r2
        STR     r3,AMBPageFlags
@


4.1.3.1.8.3.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d61 1
a61 1
        LDR     R3,=ZeroPage+MaxCamEntry
d72 1
a72 1
        LDR     R0,=ZeroPage+PhysRamTable
d93 1
a93 1
        LDR     R0,=ZeroPage
d102 1
a102 1
        LDR     R0,=ZeroPage+AMBControl_ws
d117 1
a117 1
        LDR     R12,=ZeroPage+AMBControl_ws
@


4.1.3.1.2.1
log
@Added following enhancements:

 - Chocolate screen mapping (section mapped and cached), StrongARM only
   Phoebe h/w (IOMD 2) will have register to assist this, but code currently
   relies on data abort mechanism to keep screen up to date wrt write-back
   data cache.

 - Chocolate AMBControl task switching (lazy page mapping), StrongARM only
   Improves task swapping speed. There appears to be a StrongAEM silicon
   bug rev 2 and 3) which means that LDMIB rn, {regs includind rn} cannot
   be reliably restarted after a data abort. This stuffs Chocolate AMBControl
   (awaiting response from Digital).

Both enhancements need more work to complete for Phoebe. Chocolate AMBControl
may well have to be made dormant because of silicon bug.

Note that this kernel *will* cause problems with task switching on StrongARM,
unless Chocolate task switching is disabled via !Flavour application.
@
text
@d16 3
a18 1
; > s.main 
a24 1
;claim main workspace
d27 1
a27 1
;;;     BVS     err_cantclaim - this should not happen
d34 1
a34 10
;zero-init workspace
        MOV     R1,#0
        LDR     R3,=AMBmaxwork
        ADD     R3,R3,R2
00
        STR     R1,[R2],#4
        CMP     R2,R3
        BLO     %BT00        

;claim block for handle array
d37 1
a37 1
;;;     BVS     err_cantclaim
d52 1
a52 1
;claim block for PhysBin array
d60 1
a60 1
;;;     BVS     err_cantclaim
d80 4
a83 1
;init any other workspace that shouldn't init as 0
d85 9
a93 11
        STR     R1,[R1,#AMBNode_prev]  ;anchor prev initially -> anchor (empty list)
        STR     R1,[R1,#AMBNode_next]  ;anchor next initially -> anchor (empty list)
  [ AMB_LazyMapIn
    ;only allowed for StrongARM (abort fix up  = nightmare for ARM 6,7, who cares about ARM8)
    ;
        ARM_read_ID R1
        AND     R1,R1,#&F000
        CMP     R1,#&A000
        MOVNE   R1,#AMBFlag_LazyMapIn_disable
        STRNE   R1,AMBFlags
  ]
d95 1
a95 1
        STR     R12,[R0]               ;now initialisation is complete
a121 3
  [ AMB_LazyMapIn
        B       laziness     ;5
  |
a122 1
  ]
a130 52
  [ AMB_LazyMapIn
;
;entry: R0=5 (reason),R1=1 for lazy on, 0 for lazy off, -1 to read lazy only
;exit: R1=new lazy value, after any restrictions of platform applied
;
;action: if reading only, if lazy disabled, or if new state = current, do nothing
;        if state is changing, map out any current node, change state, map in any current node
;
laziness ROUT
       Push    "R2-R3,LR"
       CMP     R1,#-1
       BEQ     %FT20
       LDR     R2,AMBFlags                      ;R2 := current flags
       TST     R2,#AMBFlag_LazyMapIn_disable    ;disable is permanent
       BNE     %FT20
       CMP     R1,#0
       MOV     R1,R2
       ORREQ   R1,R1,#AMBFlag_LazyMapIn_suspend
       BICNE   R1,R1,#AMBFlag_LazyMapIn_suspend ;R1 := new flags
       EOR     R3,R1,R2
       TST     R3,#AMBFlag_LazyMapIn_suspend    ;is suspend status changing?
       BEQ     %FT20
       LDR     R3,AMBMappedInNode
       CMP     R3,#0
       BEQ     %FT10
       Push    "R0-R3"
       MOV     R0,#3
       MOV     R1,#-1
       LDR     R2,[R3,#AMBNode_handle]
       SWI     XOS_AMBControl                   ;map out current node
       Pull    "R0-R3"
10
       STR     R1,AMBFlags
       CMP     R3,#0
       BEQ     %FT20
       Push    "R0-R3"
       MOV     R0,#3
       MOV     R1,#0
       LDR     R2,[R3,#AMBNode_handle]
       SWI     XOS_AMBControl                   ;map in current node
       Pull    "R0-R3"
20
       LDR     R1,AMBFlags
       TST     R1,#AMBFlag_LazyMapIn_disable :OR: AMBFlag_LazyMapIn_suspend
       MOVEQ   R1,#1
       MOVNE   R1,#0
       Pull    "R2-R3,LR"
       B       SLVK
;
  ] ;AMB_LazyMapIn


d173 5
@


4.1.3.1.2.2
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@a97 6
    [ SALDMIBbroken
        ;for StrongARM, suspend LazyMapIn, since this can go pop for apps which use offending form of LDMIB
        MOVEQ   R1,#AMBFlag_LazyMapIn_suspend
        MOVNE   R1,#AMBFlag_LazyMapIn_disable
        STR     R1,AMBFlags
    |
a99 1
    ]
@


4.1.3.1.2.3
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@d96 8
a103 2
        AND     R0,R1,#&F000
        CMP     R0,#&A000
a105 9
    [ SALDMIBbroken
        ;for StrongARM of old enough revision, suspend LazyMapIn, since this can go pop
        ;for apps which use offending form of LDMIB
        BNE     %FT05     
        AND     R0,R1,#&F
        CMP     R0,#SALDMIBfixedrev
        MOVLO   R1,#AMBFlag_LazyMapIn_suspend
        STRLO   R1,AMBFlags
05
@

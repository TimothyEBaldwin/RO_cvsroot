head	4.9;
access;
symbols
	Kernel-6_14:4.9
	Kernel-6_01-3:4.9
	Kernel-6_13:4.9
	Kernel-6_12:4.9
	Kernel-6_11:4.9
	Kernel-6_10:4.9
	Kernel-6_09:4.9
	Kernel-6_08-4_129_2_10:4.9
	Kernel-6_08-4_129_2_9:4.9
	Kernel-6_08:4.9
	Kernel-6_07:4.9
	Kernel-6_06:4.9
	Kernel-6_05-4_129_2_8:4.9
	Kernel-6_05:4.9
	Kernel-6_04:4.9
	Kernel-6_03:4.9
	Kernel-6_01-2:4.9
	Kernel-6_01-4_146_2_1:4.9
	Kernel-6_02:4.9
	Kernel-6_01-1:4.9
	Kernel-6_01:4.9
	Kernel-6_00:4.9
	Kernel-5_99:4.9
	Kernel-5_98:4.9
	Kernel-5_97-4_129_2_7:4.9
	Kernel-5_97:4.9
	Kernel-5_96:4.9
	Kernel-5_95:4.9
	Kernel-5_94:4.9
	Kernel-5_93:4.9
	Kernel-5_92:4.9
	Kernel-5_91:4.9
	Kernel-5_90:4.9
	Kernel-5_89-4_129_2_6:4.9
	Kernel-5_89:4.9
	Kernel-5_88-4_129_2_5:4.9
	Kernel-5_88-4_129_2_4:4.9
	Kernel-5_88:4.9
	Kernel-5_87:4.9
	Kernel-5_86-4_129_2_3:4.9
	Kernel-5_86-4_129_2_2:4.9
	Kernel-5_86-4_129_2_1:4.9
	Kernel-5_86:4.9
	SMP:4.9.0.2
	SMP_bp:4.9
	Kernel-5_85:4.9
	Kernel-5_54-1:4.8
	Kernel-5_84:4.9
	Kernel-5_83:4.9
	Kernel-5_82:4.9
	Kernel-5_81:4.9
	Kernel-5_80:4.9
	Kernel-5_79:4.9
	Kernel-5_78:4.9
	Kernel-5_77:4.8
	Kernel-5_76:4.8
	Kernel-5_75:4.8
	Kernel-5_74:4.8
	Kernel-5_73:4.8
	Kernel-5_72:4.8
	Kernel-5_71:4.8
	Kernel-5_70:4.8
	Kernel-5_69:4.8
	Kernel-5_68:4.8
	Kernel-5_67:4.8
	Kernel-5_66:4.8
	Kernel-5_65:4.8
	Kernel-5_64:4.8
	Kernel-5_63:4.8
	Kernel-5_62:4.8
	Kernel-5_61:4.8
	Kernel-5_60:4.8
	Kernel-5_59:4.8
	Kernel-5_58:4.8
	Kernel-5_57:4.8
	Kernel-5_56:4.8
	Kernel-5_55:4.8
	Kernel-5_54:4.8
	Kernel-5_53:4.8
	Kernel-5_52:4.8
	Kernel-5_51:4.8
	Kernel-5_50:4.7
	Kernel-5_49:4.7
	HAL_merge:4.6.2.10
	Kernel-5_48:4.7
	Kernel-5_35-4_79_2_327:4.6.2.10
	Kernel-5_35-4_79_2_326:4.6.2.10
	Kernel-5_35-4_79_2_325:4.6.2.10
	Kernel-5_35-4_79_2_324:4.6.2.10
	Kernel-5_35-4_79_2_323:4.6.2.10
	Kernel-5_35-4_79_2_322:4.6.2.10
	Kernel-5_35-4_79_2_321:4.6.2.10
	Kernel-5_35-4_79_2_320:4.6.2.10
	Kernel-5_35-4_79_2_319:4.6.2.10
	Kernel-5_35-4_79_2_318:4.6.2.10
	Kernel-5_35-4_79_2_317:4.6.2.10
	Kernel-5_35-4_79_2_316:4.6.2.10
	Kernel-5_35-4_79_2_315:4.6.2.10
	Kernel-5_35-4_79_2_314:4.6.2.10
	Kernel-5_35-4_79_2_313:4.6.2.10
	Kernel-5_35-4_79_2_312:4.6.2.10
	Kernel-5_35-4_79_2_311:4.6.2.10
	Kernel-5_35-4_79_2_310:4.6.2.10
	Kernel-5_35-4_79_2_309:4.6.2.10
	Kernel-5_35-4_79_2_308:4.6.2.10
	Kernel-5_35-4_79_2_307:4.6.2.10
	Kernel-5_35-4_79_2_306:4.6.2.10
	Kernel-5_35-4_79_2_305:4.6.2.10
	Kernel-5_35-4_79_2_304:4.6.2.10
	Kernel-5_35-4_79_2_303:4.6.2.10
	Kernel-5_35-4_79_2_302:4.6.2.10
	Kernel-5_35-4_79_2_301:4.6.2.10
	Kernel-5_35-4_79_2_300:4.6.2.10
	Kernel-5_35-4_79_2_299:4.6.2.10
	Kernel-5_35-4_79_2_298:4.6.2.10
	Kernel-5_35-4_79_2_297:4.6.2.10
	Kernel-5_35-4_79_2_296:4.6.2.10
	Kernel-5_35-4_79_2_295:4.6.2.10
	Kernel-5_35-4_79_2_294:4.6.2.10
	Kernel-5_35-4_79_2_293:4.6.2.10
	Kernel-5_35-4_79_2_292:4.6.2.10
	Kernel-5_35-4_79_2_291:4.6.2.10
	Kernel-5_35-4_79_2_290:4.6.2.10
	Kernel-5_35-4_79_2_289:4.6.2.10
	Kernel-5_35-4_79_2_288:4.6.2.10
	Kernel-5_35-4_79_2_287:4.6.2.10
	Kernel-5_35-4_79_2_286:4.6.2.10
	Kernel-5_35-4_79_2_285:4.6.2.10
	Kernel-5_35-4_79_2_284:4.6.2.10
	Kernel-5_35-4_79_2_283:4.6.2.10
	Kernel-5_35-4_79_2_282:4.6.2.10
	Kernel-5_35-4_79_2_281:4.6.2.10
	Kernel-5_35-4_79_2_280:4.6.2.10
	Kernel-5_35-4_79_2_279:4.6.2.10
	Kernel-5_35-4_79_2_278:4.6.2.10
	Kernel-5_35-4_79_2_277:4.6.2.10
	Kernel-5_35-4_79_2_276:4.6.2.10
	Kernel-5_35-4_79_2_275:4.6.2.10
	Kernel-5_35-4_79_2_274:4.6.2.10
	Kernel-5_35-4_79_2_273:4.6.2.10
	Kernel-5_35-4_79_2_272:4.6.2.10
	Kernel-5_35-4_79_2_271:4.6.2.10
	Kernel-5_35-4_79_2_270:4.6.2.10
	Kernel-5_35-4_79_2_269:4.6.2.10
	Kernel-5_35-4_79_2_268:4.6.2.10
	Kernel-5_35-4_79_2_267:4.6.2.10
	Kernel-5_35-4_79_2_266:4.6.2.10
	Kernel-5_35-4_79_2_265:4.6.2.10
	Kernel-5_35-4_79_2_264:4.6.2.10
	Kernel-5_35-4_79_2_263:4.6.2.10
	Kernel-5_35-4_79_2_262:4.6.2.10
	Kernel-5_35-4_79_2_261:4.6.2.10
	Kernel-5_35-4_79_2_260:4.6.2.10
	Kernel-5_35-4_79_2_259:4.6.2.10
	Kernel-5_35-4_79_2_258:4.6.2.10
	Kernel-5_35-4_79_2_257:4.6.2.10
	Kernel-5_35-4_79_2_256:4.6.2.10
	Kernel-5_35-4_79_2_255:4.6.2.10
	Kernel-5_35-4_79_2_254:4.6.2.10
	Kernel-5_35-4_79_2_253:4.6.2.10
	Kernel-5_35-4_79_2_252:4.6.2.10
	Kernel-5_35-4_79_2_251:4.6.2.10
	Kernel-5_35-4_79_2_250:4.6.2.10
	Kernel-5_35-4_79_2_249:4.6.2.10
	Kernel-5_35-4_79_2_248:4.6.2.10
	Kernel-5_35-4_79_2_247:4.6.2.10
	Kernel-5_35-4_79_2_246:4.6.2.10
	Kernel-5_35-4_79_2_245:4.6.2.10
	Kernel-5_35-4_79_2_244:4.6.2.9
	Kernel-5_35-4_79_2_243:4.6.2.9
	Kernel-5_35-4_79_2_242:4.6.2.9
	Kernel-5_35-4_79_2_241:4.6.2.9
	Kernel-5_35-4_79_2_240:4.6.2.9
	Kernel-5_35-4_79_2_239:4.6.2.9
	Kernel-5_35-4_79_2_238:4.6.2.9
	Kernel-5_35-4_79_2_237:4.6.2.9
	Kernel-5_35-4_79_2_236:4.6.2.9
	Kernel-5_35-4_79_2_235:4.6.2.9
	Kernel-5_35-4_79_2_234:4.6.2.9
	Kernel-5_35-4_79_2_233:4.6.2.9
	Kernel-5_35-4_79_2_232:4.6.2.9
	Kernel-5_35-4_79_2_231:4.6.2.9
	Kernel-5_35-4_79_2_230:4.6.2.9
	Kernel-5_35-4_79_2_229:4.6.2.9
	Kernel-5_35-4_79_2_228:4.6.2.9
	Kernel-5_35-4_79_2_227:4.6.2.9
	Kernel-5_35-4_79_2_226:4.6.2.9
	Kernel-5_35-4_79_2_225:4.6.2.9
	Kernel-5_35-4_79_2_224:4.6.2.9
	Kernel-5_35-4_79_2_223:4.6.2.9
	Kernel-5_35-4_79_2_222:4.6.2.9
	Kernel-5_35-4_79_2_221:4.6.2.9
	Kernel-5_35-4_79_2_220:4.6.2.9
	Kernel-5_35-4_79_2_219:4.6.2.9
	Kernel-5_35-4_79_2_218:4.6.2.9
	Kernel-5_35-4_79_2_217:4.6.2.9
	Kernel-5_35-4_79_2_216:4.6.2.9
	Kernel-5_35-4_79_2_215:4.6.2.9
	Kernel-5_35-4_79_2_214:4.6.2.9
	Kernel-5_35-4_79_2_213:4.6.2.9
	Kernel-5_35-4_79_2_212:4.6.2.9
	Kernel-5_35-4_79_2_211:4.6.2.9
	Kernel-5_35-4_79_2_210:4.6.2.9
	Kernel-5_35-4_79_2_209:4.6.2.9
	Kernel-5_35-4_79_2_208:4.6.2.9
	Kernel-5_35-4_79_2_207:4.6.2.9
	Kernel-5_35-4_79_2_206:4.6.2.9
	Kernel-5_35-4_79_2_205:4.6.2.9
	Kernel-5_35-4_79_2_204:4.6.2.9
	Kernel-5_35-4_79_2_203:4.6.2.9
	Kernel-5_35-4_79_2_202:4.6.2.9
	Kernel-5_35-4_79_2_201:4.6.2.9
	Kernel-5_35-4_79_2_200:4.6.2.9
	Kernel-5_35-4_79_2_199:4.6.2.9
	Kernel-5_35-4_79_2_198:4.6.2.9
	Kernel-5_35-4_79_2_197:4.6.2.9
	Kernel-5_35-4_79_2_196:4.6.2.9
	Kernel-5_35-4_79_2_195:4.6.2.9
	Kernel-5_35-4_79_2_194:4.6.2.9
	Kernel-5_35-4_79_2_193:4.6.2.9
	Kernel-5_35-4_79_2_192:4.6.2.9
	Kernel-5_35-4_79_2_191:4.6.2.9
	Kernel-5_35-4_79_2_190:4.6.2.9
	Kernel-5_35-4_79_2_189:4.6.2.9
	Kernel-5_35-4_79_2_188:4.6.2.9
	Kernel-5_35-4_79_2_187:4.6.2.9
	Kernel-5_35-4_79_2_186:4.6.2.9
	Kernel-5_35-4_79_2_185:4.6.2.9
	Kernel-5_35-4_79_2_184:4.6.2.9
	Kernel-5_35-4_79_2_183:4.6.2.9
	Kernel-5_35-4_79_2_182:4.6.2.9
	Kernel-5_35-4_79_2_181:4.6.2.9
	Kernel-5_35-4_79_2_180:4.6.2.9
	Kernel-5_35-4_79_2_179:4.6.2.9
	Kernel-5_35-4_79_2_178:4.6.2.9
	Kernel-5_35-4_79_2_177:4.6.2.9
	Kernel-5_35-4_79_2_176:4.6.2.9
	Kernel-5_35-4_79_2_175:4.6.2.9
	Kernel-5_35-4_79_2_174:4.6.2.9
	Kernel-5_35-4_79_2_173:4.6.2.9
	Kernel-5_35-4_79_2_172:4.6.2.9
	Kernel-5_35-4_79_2_171:4.6.2.9
	Kernel-5_35-4_79_2_170:4.6.2.9
	Kernel-5_35-4_79_2_169:4.6.2.9
	Kernel-5_35-4_79_2_168:4.6.2.9
	Kernel-5_35-4_79_2_167:4.6.2.9
	Kernel-5_35-4_79_2_166:4.6.2.9
	Kernel-5_35-4_79_2_165:4.6.2.9
	RPi_merge:4.6.2.9
	Kernel-5_35-4_79_2_147_2_23:4.6.2.9
	Kernel-5_35-4_79_2_147_2_22:4.6.2.9
	Kernel-5_35-4_79_2_147_2_21:4.6.2.9
	Kernel-5_35-4_79_2_147_2_20:4.6.2.9
	Kernel-5_35-4_79_2_147_2_19:4.6.2.9
	Kernel-5_35-4_79_2_147_2_18:4.6.2.9
	Kernel-5_35-4_79_2_164:4.6.2.9
	Kernel-5_35-4_79_2_163:4.6.2.9
	Kernel-5_35-4_79_2_147_2_17:4.6.2.9
	Kernel-5_35-4_79_2_147_2_16:4.6.2.9
	Kernel-5_35-4_79_2_147_2_15:4.6.2.9
	Kernel-5_35-4_79_2_162:4.6.2.9
	Kernel-5_35-4_79_2_161:4.6.2.9
	Kernel-5_35-4_79_2_147_2_14:4.6.2.9
	Kernel-5_35-4_79_2_147_2_13:4.6.2.9
	Kernel-5_35-4_79_2_160:4.6.2.9
	Kernel-5_35-4_79_2_159:4.6.2.9
	Kernel-5_35-4_79_2_158:4.6.2.9
	Kernel-5_35-4_79_2_157:4.6.2.9
	Kernel-5_35-4_79_2_156:4.6.2.9
	Kernel-5_35-4_79_2_147_2_12:4.6.2.9
	Kernel-5_35-4_79_2_147_2_11:4.6.2.9
	Kernel-5_35-4_79_2_155:4.6.2.9
	Kernel-5_35-4_79_2_147_2_10:4.6.2.9
	Kernel-5_35-4_79_2_154:4.6.2.9
	Kernel-5_35-4_79_2_153:4.6.2.9
	Kernel-5_35-4_79_2_147_2_9:4.6.2.9
	Kernel-5_35-4_79_2_152:4.6.2.9
	Kernel-5_35-4_79_2_151:4.6.2.9
	Kernel-5_35-4_79_2_147_2_8:4.6.2.9
	Kernel-5_35-4_79_2_147_2_7:4.6.2.9
	Kernel-5_35-4_79_2_150:4.6.2.9
	Kernel-5_35-4_79_2_147_2_6:4.6.2.9
	Kernel-5_35-4_79_2_147_2_5:4.6.2.9
	Kernel-5_35-4_79_2_149:4.6.2.9
	Kernel-5_35-4_79_2_147_2_4:4.6.2.9
	Kernel-5_35-4_79_2_147_2_3:4.6.2.9
	Kernel-5_35-4_79_2_148:4.6.2.9
	Kernel-5_35-4_79_2_147_2_2:4.6.2.9
	Kernel-5_35-4_79_2_147_2_1:4.6.2.9
	RPi:4.6.2.9.0.2
	RPi_bp:4.6.2.9
	Kernel-5_35-4_79_2_98_2_52_2_1:4.6.2.4.2.3
	alees_Kernel_dev:4.6.2.4.2.3.0.2
	alees_Kernel_dev_bp:4.6.2.4.2.3
	Kernel-5_35-4_79_2_147:4.6.2.9
	Kernel-5_35-4_79_2_146:4.6.2.9
	Kernel-5_35-4_79_2_145:4.6.2.9
	Kernel-5_35-4_79_2_144:4.6.2.9
	Kernel-5_35-4_79_2_143:4.6.2.9
	Kernel-5_35-4_79_2_142:4.6.2.9
	Kernel-5_35-4_79_2_141:4.6.2.9
	Kernel-5_35-4_79_2_140:4.6.2.9
	Kernel-5_35-4_79_2_139:4.6.2.9
	Kernel-5_35-4_79_2_138:4.6.2.9
	Kernel-5_35-4_79_2_137:4.6.2.9
	Kernel-5_35-4_79_2_136:4.6.2.9
	Kernel-5_35-4_79_2_135:4.6.2.9
	Kernel-5_35-4_79_2_134:4.6.2.9
	Kernel-5_35-4_79_2_133:4.6.2.9
	Kernel-5_35-4_79_2_132:4.6.2.9
	Kernel-5_35-4_79_2_131:4.6.2.9
	Kernel-5_35-4_79_2_130:4.6.2.9
	Kernel-5_35-4_79_2_129:4.6.2.9
	Kernel-5_35-4_79_2_128:4.6.2.9
	Kernel-5_35-4_79_2_127:4.6.2.9
	Kernel-5_35-4_79_2_126:4.6.2.9
	Kernel-5_35-4_79_2_125:4.6.2.9
	Kernel-5_35-4_79_2_124:4.6.2.8
	Kernel-5_35-4_79_2_123:4.6.2.7
	Cortex_merge:4.6.2.4.2.3
	Kernel-5_35-4_79_2_122:4.6.2.6
	Kernel-5_35-4_79_2_98_2_54:4.6.2.4.2.3
	Kernel-5_35-4_79_2_98_2_53:4.6.2.4.2.3
	Kernel-5_35-4_79_2_98_2_52:4.6.2.4.2.3
	Kernel-5_35-4_79_2_98_2_51:4.6.2.4.2.3
	Kernel-5_35-4_79_2_98_2_50:4.6.2.4.2.3
	Kernel-5_35-4_79_2_98_2_49:4.6.2.4.2.3
	Kernel-5_35-4_79_2_98_2_48:4.6.2.4.2.3
	Kernel-5_35-4_79_2_121:4.6.2.6
	Kernel-5_35-4_79_2_98_2_47:4.6.2.4.2.2
	Kernel-5_35-4_79_2_120:4.6.2.6
	Kernel-5_35-4_79_2_98_2_46:4.6.2.4.2.2
	Kernel-5_35-4_79_2_119:4.6.2.5
	Kernel-5_35-4_79_2_98_2_45:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_44:4.6.2.4.2.2
	Kernel-5_35-4_79_2_118:4.6.2.5
	Kernel-5_35-4_79_2_98_2_43:4.6.2.4.2.2
	Kernel-5_35-4_79_2_117:4.6.2.5
	Kernel-5_35-4_79_2_116:4.6.2.5
	Kernel-5_35-4_79_2_98_2_42:4.6.2.4.2.2
	Kernel-5_35-4_79_2_115:4.6.2.5
	Kernel-5_35-4_79_2_98_2_41:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_40:4.6.2.4.2.2
	Kernel-5_35-4_79_2_114:4.6.2.5
	Kernel-5_35-4_79_2_98_2_39:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_38:4.6.2.4.2.2
	Kernel-5_35-4_79_2_113:4.6.2.5
	Kernel-5_35-4_79_2_112:4.6.2.5
	Kernel-5_35-4_79_2_98_2_37:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_36:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_35:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_34:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_33:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_32:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_31:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_30:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_29:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_28:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_27:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_26:4.6.2.4.2.2
	Kernel-5_35-4_79_2_111:4.6.2.5
	Kernel-5_35-4_79_2_98_2_25:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_24:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_23:4.6.2.4.2.2
	Kernel-5_35-4_79_2_110:4.6.2.5
	Kernel-5_35-4_79_2_98_2_22:4.6.2.4.2.2
	Kernel-5_35-4_79_2_109:4.6.2.5
	Kernel-5_35-4_79_2_98_2_21:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_20:4.6.2.4.2.2
	Kernel-5_35-4_79_2_108:4.6.2.5
	Kernel-5_35-4_79_2_107:4.6.2.5
	Kernel-5_35-4_79_2_98_2_19:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_18:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_17:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_16:4.6.2.4.2.2
	Kernel-5_35-4_79_2_98_2_15:4.6.2.4.2.2
	Kernel-5_35-4_79_2_106:4.6.2.5
	Kernel-5_35-4_79_2_105:4.6.2.4
	Kernel-5_35-4_79_2_104:4.6.2.4
	Kernel-5_35-4_79_2_98_2_14:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_13:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_12:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_11:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_10:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_9:4.6.2.4.2.1
	Kernel-5_35-4_79_2_103:4.6.2.4
	Kernel-5_35-4_79_2_102:4.6.2.4
	Kernel-5_35-4_79_2_98_2_8:4.6.2.4.2.1
	Kernel-5_35-4_79_2_98_2_7:4.6.2.4
	Kernel-5_35-4_79_2_98_2_6:4.6.2.4
	Kernel-5_35-4_79_2_98_2_5:4.6.2.4
	Kernel-5_35-4_79_2_98_2_4:4.6.2.4
	Kernel-5_35-4_79_2_101:4.6.2.4
	Kernel-5_35-4_79_2_100:4.6.2.4
	Kernel-5_35-4_79_2_99:4.6.2.4
	Kernel-5_35-4_79_2_98_2_3:4.6.2.4
	Kernel-5_35-4_79_2_98_2_2:4.6.2.4
	Kernel-5_35-4_79_2_98_2_1:4.6.2.4
	Cortex:4.6.2.4.0.2
	Cortex_bp:4.6.2.4
	Kernel-5_35-4_79_2_98:4.6.2.4
	Kernel-5_35-4_79_2_97:4.6.2.4
	Kernel-5_35-4_79_2_96:4.6.2.4
	Kernel-5_35-4_79_2_95:4.6.2.4
	Kernel-5_35-4_79_2_94:4.6.2.4
	Kernel-5_35-4_79_2_93:4.6.2.4
	Kernel-5_35-4_79_2_92:4.6.2.4
	Kernel-5_35-4_79_2_91:4.6.2.4
	Kernel-5_35-4_79_2_90:4.6.2.4
	Kernel-5_35-4_79_2_89:4.6.2.4
	Kernel-5_35-4_79_2_88:4.6.2.4
	Kernel-5_35-4_79_2_87:4.6.2.4
	Kernel-5_35-4_79_2_86:4.6.2.4
	Kernel-5_35-4_79_2_85:4.6.2.4
	Kernel-5_35-4_79_2_84:4.6.2.4
	Kernel-5_35-4_79_2_83:4.6.2.4
	Kernel-5_35-4_79_2_82:4.6.2.4
	Kernel-5_35-4_79_2_81:4.6.2.4
	Kernel-5_35-4_79_2_80:4.6.2.4
	Kernel-5_35-4_79_2_79:4.6.2.4
	Kernel-5_35-4_79_2_78:4.6.2.4
	Kernel-5_35-4_79_2_77:4.6.2.4
	RO_5_07:4.6.2.4
	Kernel-5_35-4_79_2_76:4.6.2.4
	Kernel-5_35-4_79_2_75:4.6.2.4
	Kernel-5_35-4_79_2_74:4.6.2.4
	Kernel-5_35-4_79_2_73:4.6.2.4
	Kernel-5_35-4_79_2_72:4.6.2.4
	Kernel-5_35-4_79_2_71:4.6.2.4
	Kernel-5_35-4_79_2_70:4.6.2.4
	Kernel-5_35-4_79_2_69:4.6.2.4
	Kernel-5_35-4_79_2_68:4.6.2.4
	Kernel-5_35-4_79_2_67:4.6.2.4
	Kernel-5_35-4_79_2_66:4.6.2.4
	Kernel-5_35-4_79_2_65:4.6.2.4
	Kernel-5_35-4_79_2_64:4.6.2.4
	Kernel-5_35-4_79_2_63:4.6.2.4
	Kernel-5_35-4_79_2_62:4.6.2.4
	Kernel-5_35-4_79_2_61:4.6.2.4
	Kernel-5_35-4_79_2_59:4.6.2.4
	Kernel-5_35-4_79_2_58:4.6.2.4
	Kernel-5_35-4_79_2_57:4.6.2.4
	Kernel-5_35-4_79_2_56:4.6.2.4
	Kernel-5_35-4_79_2_55:4.6.2.3
	Kernel-5_35-4_79_2_54:4.6.2.3
	Kernel-5_35-4_79_2_53:4.6.2.3
	Kernel-5_35-4_79_2_52:4.6.2.3
	Kernel-5_35-4_79_2_51:4.6.2.3
	Kernel-5_35-4_79_2_50:4.6.2.2
	Kernel-5_35-4_79_2_49:4.6.2.2
	Kernel-5_35-4_79_2_48:4.6.2.2
	Kernel-5_47:4.6
	Kernel-5_46-4_90_2_1:4.6
	nbingham_Kernel_FastNC_dev_bp:4.6
	nbingham_Kernel_FastNC_dev:4.6.0.4
	Kernel-5_46:4.6
	Kernel-5_45:4.6
	Kernel-5_35-4_79_2_47:4.6.2.2
	Kernel-5_35-4_79_2_46:4.6.2.2
	Kernel-5_35-4_79_2_45:4.6.2.2
	Kernel-5_35-4_79_2_44:4.6.2.2
	Kernel-5_35-4_79_2_25_2_2:4.6.2.1
	Kernel-5_35-4_79_2_43:4.6.2.2
	Kernel-5_35-4_79_2_42:4.6.2.2
	Kernel-5_35-4_79_2_41:4.6.2.2
	Kernel-5_35-4_79_2_40:4.6.2.2
	Kernel-5_35-4_79_2_39:4.6.2.2
	Kernel-5_35-4_79_2_38:4.6.2.2
	Kernel-5_35-4_79_2_37:4.6.2.2
	Kernel-5_35-4_79_2_36:4.6.2.1
	Kernel-5_35-4_79_2_35:4.6.2.1
	Kernel-5_35-4_79_2_34:4.6.2.1
	Kernel-5_35-4_79_2_33:4.6.2.1
	Kernel-5_35-4_79_2_32:4.6.2.1
	Kernel-5_44:4.6
	Kernel-5_35-4_79_2_25_2_1:4.6.2.1
	Kernel-5_43:4.6
	Kernel-5_35-4_79_2_31:4.6.2.1
	Kernel-5_35-4_79_2_30:4.6.2.1
	Kernel-5_35-4_79_2_29:4.6.2.1
	Kernel-5_35-4_79_2_28:4.6.2.1
	Kernel-5_35-4_79_2_27:4.6.2.1
	Kernel-5_35-4_79_2_26:4.6.2.1
	Kernel-5_42:4.6
	Kernel-5_41:4.6
	Kernel-5_40:4.6
	Kernel-5_35-4_79_2_25:4.6.2.1
	Kernel-5_35-4_79_2_24:4.6.2.1
	Kernel-5_35-4_79_2_23:4.6.2.1
	Kernel-5_35-4_79_2_22:4.6.2.1
	Kernel-5_35-4_79_2_21:4.6.2.1
	Kernel-5_35-4_79_2_20:4.6.2.1
	Kernel-5_35-4_79_2_19:4.6.2.1
	Kernel-5_35-4_79_2_18:4.6.2.1
	Kernel-5_35-4_79_2_17:4.6.2.1
	Kernel-5_35-4_79_2_16:4.6.2.1
	Kernel-5_35-4_79_2_15:4.6.2.1
	Kernel-5_35-4_79_2_14:4.6.2.1
	Kernel-5_39:4.6
	Kernel-5_13-4_52_2_1:4.5
	Bethany:4.5.0.2
	Kernel-5_38:4.6
	Kernel-5_35-4_79_2_13:4.6.2.1
	Kernel-5_35-4_79_2_12:4.6.2.1
	Kernel-5_35-4_79_2_11:4.6.2.1
	Kernel-5_37:4.6
	Kernel-5_35-4_79_2_10:4.6.2.1
	Kernel-5_35-4_79_2_9:4.6.2.1
	Kernel-5_36:4.6
	Kernel-5_35-4_79_2_8:4.6.2.1
	Kernel-5_35-4_79_2_7:4.6.2.1
	Kernel-5_35-4_79_2_6:4.6.2.1
	Kernel-5_35-4_79_2_5:4.6.2.1
	Kernel-5_35-4_79_2_4:4.6.2.1
	Kernel-5_35-4_79_2_3:4.6.2.1
	Kernel-5_35-4_79_2_2:4.6.2.1
	dellis_autobuild_BaseSW:4.6
	Kernel-5_35-4_79_2_1:4.6.2.1
	HAL:4.6.0.2
	Kernel-5_35:4.6
	Kernel-5_34:4.6
	Kernel-5_33:4.6
	Kernel-5_32:4.6
	Kernel-5_31:4.6
	Kernel-5_30:4.6
	Kernel-5_29:4.6
	Kernel-5_28:4.6
	Kernel-5_27:4.6
	Kernel-5_26:4.6
	Kernel-5_25:4.6
	Kernel-5_24:4.6
	Kernel-5_23:4.6
	Kernel-5_22:4.5
	sbrodie_sedwards_16Mar2000:4.5
	Kernel-5_21:4.5
	Kernel-5_20:4.5
	Kernel-5_19:4.5
	Kernel-5_18:4.5
	Kernel-5_17:4.5
	Kernel-5_16:4.5
	Kernel-5_15:4.5
	Kernel-5_14:4.5
	Kernel-5_13:4.5
	Kernel-5_12:4.5
	Kernel-5_11:4.5
	Kernel-5_10:4.5
	Kernel-5_09:4.5
	Kernel-5_08:4.5
	Kernel-5_07:4.4
	Kernel-5_06:4.4
	Kernel-5_05:4.4
	Kernel-5_04:4.4
	Kernel-5_03:4.4
	Kernel-5_02:4.4
	Kernel-5_01:4.4
	Kernel-5_00:4.4
	Kernel-4_99:4.4
	Kernel-4_98:4.4
	Kernel-4_97:4.4
	Kernel-4_96:4.4
	Kernel-4_95:4.4
	Kernel-4_94:4.4
	Kernel-4_93:4.4
	Kernel-4_92:4.4
	Kernel-4_91:4.4
	Kernel-4_90:4.4
	dcotton_autobuild_BaseSW:4.6
	Kernel-4_89:4.4
	Kernel-4_88:4.4
	Kernel-4_87:4.4
	Kernel-4_86:4.4
	Kernel-4_85:4.4
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.2.2.3
	Kernel-4_84:4.4
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.2.2.3
	Ursula_RiscPC_bp:4.2.2.3
	Kernel-4_83:4.3
	Kernel-4_82:4.3
	Kernel-4_81:4.3
	Kernel-4_80:4.3
	Kernel-4_79:4.3
	Kernel-4_78:4.3
	Kernel-4_77:4.3
	Kernel-4_76:4.3
	Kernel-4_75:4.3
	Kernel-4_74:4.3
	Kernel-4_73:4.3
	Kernel-4_72:4.3
	Kernel-4_71:4.3
	Kernel-4_70:4.3
	Kernel-4_69:4.3
	Kernel-4_68:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.3
	Ursula_RiscPC:4.2.2.3.0.2
	Kernel-4_63-1_1_2_5:4.1.7.3
	Kernel-4_63-1_1_2_4:4.1.7.3
	Kernel-4_67:4.3
	Kernel-4_66:4.3
	Kernel-4_63-1_1_2_3:4.1.7.3
	Kernel-4_65:4.3
	Ursula_merge:4.2
	Kernel-4_64:4.3
	mstphens_Kernel-3_81:4.2.2.3
	Kernel-4_63-1_1_2_2:4.1.7.3
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.3
	UrsulaBuild_FinalSoftload:4.2.2.3
	rthornb_UrsulaBuild-12Aug1998:4.2.2.3
	aglover_UrsulaBuild-05Aug1998:4.2.2.3
	rthornb_UrsulaBuild-29Jul1998:4.2.2.3
	rthornb_UrsulaBuild-22Jul1998:4.2.2.3
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.3
	rthornb_UrsulaBuild-07Jul1998:4.2.2.3
	rthornb_UrsulaBuild-17Jun1998:4.2.2.3
	rthornb_UrsulaBuild-03Jun1998:4.2.2.3
	rthornb_UrsulaBuild-27May1998:4.2.2.3
	mstphens_Kernel-3_80:4.2.2.3
	rthornb_UrsulaBuild-21May1998:4.2.2.3
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.2.2.3
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula_bp:4.2
	Ursula:4.2.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.3
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2017.02.11.20.17.34;	author jlee;	state Exp;
branches;
next	4.8;
commitid	QToh8YrKffYRBzFz;

4.8
date	2016.06.30.20.59.45;	author jlee;	state Exp;
branches;
next	4.7;
commitid	skOEjp3ipLHx6xcz;

4.7
date	2016.06.30.20.08.07;	author jlee;	state Exp;
branches;
next	4.6;
commitid	IWoXxARWeuLDOwcz;

4.6
date	2000.04.04.14.27.27;	author kbracey;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	99.12.01.12.26.03;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.08.19.10.52.24;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.09.30.08.42.27;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.14.06.56;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.11;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2000.09.15.12.38.00;	author kbracey;	state Exp;
branches;
next	4.6.2.2;

4.6.2.2
date	2001.06.15.09.39.56;	author mstephen;	state Exp;
branches;
next	4.6.2.3;

4.6.2.3
date	2002.11.30.00.31.06;	author bavison;	state Exp;
branches;
next	4.6.2.4;

4.6.2.4
date	2003.02.21.20.21.54;	author bavison;	state Exp;
branches
	4.6.2.4.2.1;
next	4.6.2.5;

4.6.2.5
date	2009.11.06.23.13.17;	author jlee;	state Exp;
branches;
next	4.6.2.6;

4.6.2.6
date	2011.08.07.00.05.00;	author jlee;	state Exp;
branches;
next	4.6.2.7;
commitid	1LhiU7JeG3NwFvuv;

4.6.2.7
date	2011.11.26.21.11.14;	author jlee;	state Exp;
branches;
next	4.6.2.8;
commitid	cI3W0zbtALQG6TIv;

4.6.2.8
date	2011.11.27.11.48.08;	author rsprowson;	state Exp;
branches;
next	4.6.2.9;
commitid	OFgqaKhOb6swXXIv;

4.6.2.9
date	2011.11.27.12.34.45;	author rsprowson;	state Exp;
branches;
next	4.6.2.10;
commitid	QtdLV6zjuPNxdYIv;

4.6.2.10
date	2014.11.04.20.50.35;	author jlee;	state Exp;
branches;
next	;
commitid	OWXm1SCwfvvhtUWx;

4.6.2.4.2.1
date	2009.05.17.01.34.37;	author bavison;	state Exp;
branches;
next	4.6.2.4.2.2;

4.6.2.4.2.2
date	2009.11.06.23.17.45;	author jlee;	state Exp;
branches;
next	4.6.2.4.2.3;

4.6.2.4.2.3
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	;
commitid	D7rzILnwRRSXoLuv;

4.2.2.1
date	97.09.09.13.32.56;	author mstphens;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	97.12.08.14.34.14;	author mstphens;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	98.03.26.11.25.21;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.11;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.01.59.38;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.10.41;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.19;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	98.09.08.15.24.59;	author kbracey;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	98.09.08.15.37.33;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Fix incorrect OS_SynchroniseCodeAreas call
Detail:
  s/Arthur2 - When installing a code system variable, a register fumble resulted in OS_SynchroniseCodeAreas being called with a bogus address range. Fix it.
Admin:
  Tested on Pandaboard


Version 5.78. Tagged as 'Kernel-5_78'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL  => Arthur2

;        GET  $.Hdr.Variables  - got at start

        MACRO
$l      GSVarGetWSpace
$l      LDR     R12, =GSVarWSpace
        MEND

;mjs performance enhancements for Ursula (ChocolateSysVars)
;
                          GBLL    SysVars_QuickContext
                          GBLL    SysVars_StickyNodes
SysVars_QuickContext      SETL    {TRUE} :LAND: ChocolateSysVars   ;avoid abysmal O(n*n) enumeration of vars
SysVars_StickyNodes       SETL    {TRUE} :LAND: ChocolateSysVars   ;attempt to avoid lots of SysHeap operations,
                                                                   ;especially grows and shrinks

SysVars_Vindex_NStart     * 256   ;initial no. of vars supported by index
SysVars_Vindex_NBump      *  32   ;additional no. of vars each time index size is bumped up

  [ SysVars_QuickContext
;
;format of block anchored at VariableList
;
                     ^   0
SysVars_LastContext  #   4                    ;last var table index for last context ptr returned, or -1 if invalid
SysVars_VTableOffset #   0
;
;immediately followed by table data as in old code:
;  1 word   = total number of variables (N)
;  N words  = ptrs to variable blocks (sorted table)
;
  ]

  [ SysVars_StickyNodes
SysVars_StickyNode_UnitSize *  32             ;quantise node size to multiples of this many bytes
                                              ;(must be multiple of 8, and power of 2)
SysVars_StickyNode_Log2US   *   5             ;Log2 of unit size
SysVars_StickyNode_MaxSize  * 320             ;maximum size of node that may stick (be retained on removal as active node)
;
;There are currently 10 words allocated in kernel workspace for sticky pointers
      ASSERT  SysVars_StickyNode_UnitSize*10 = SysVars_StickyNode_MaxSize
  ]

        GBLL    DebugSysVars
DebugSysVars SETL {FALSE}


;-----------------------------------------------------------------------------------
;
; This file covers:
;   System variables:
;     InitVariables
;     OS_ReadVarVal
;     OS_SetVarVal
;   GSTrans:
;     OS_GSInit
;     OS_GSRead
;     OS_GSTrans
; These have been grouped because GSTrans makes direct use of the system variables'
; structures.
;
; The system variables are stored as a one way sorted alphabetically linked list hanging
; off the zero-page location VariableList:
;
; VariableList---->sorted table of pointers to variable blocks (QuickIndex) - format as above
;
; The end is indicated by the link having the value 0.
;
; Each variable is stored in one block in the system heap (block will be word aligned). The
; format of each block is:
;
; No. Bytes     Use
; N+1           Variable's name (length N, plus terminator).
; 1             Variable's type:
;                       0       string
;                       1       number
;                       2       macro
;                       3       expanded (not valid within sysvar structure)
;                       16      code
; M             data - depends on the variable's type
;
; The structure of the data is as follows:
;
; Type 0 - string
; Bytes         Use
; 3             Length (N)
; N             the bytes of the string - may contain any characters
;
; Type 1 - number
; Bytes         Use
; 4             its value (not necessarily word aligned)
;
; Type 2 - macro
; Bytes         Use
; 3             Length (N)
; N             the bytes of the string - must be a valid GSTransable string
;                       including terminator
;
; Type 16 - code
; Bytes         Use
; x             Sufficient to word align...
; 4             Write entry
; 4             Read entry
; N             The rest of the code

InitVariables  ROUT
        Push    "lr"

        ; Blank the sysvar list
        MOV     R0, #0
        LDR     R12, =ZeroPage+VariableList
        STR     R0, [R12]

        ; Set up the preset system variables
        ADR     R0, SystemVarList       ; R0 pointer to name
01      MOV     R1, R0
        LDRB    R2, [R1], #1
        CMP     R2, #0
        Pull    "PC", EQ
02      LDRB    R3, [R1], #1
        CMP     R3, #0
        BNE     %BT02
        LDRB    R4, [R1], #1            ; get type
        ADD     R1, R1, #3
        BIC     R1, R1, #3
        LDR     R2, [R1], #4
        SWI     XOS_SetVarVal
        ADD     R0, R1, R2
        B       %BT01

        LTORG

; System vars have Thunks :
; read thunk returns R0 ptr to string, R2 length. R1 corruptible
; set thunk takes R1 ptr to value, R2 length. Value is always a string.
; Can corrupt R1, R2, R4, R10-12

; The list of nodes to copy into RAM :
; name, 0 , type, ALIGN, size of value, value

SystemVarList  ROUT
        =       "Sys$$Time", 0, VarType_Code
        ALIGN
        &       sv2-.-4
        LDR     PC, %FT01
        LDR     PC, %FT02
01
        &       SetTimeVar
02
        &       ReadTimeVar

sv2     =       "Sys$$Year", 0, VarType_Code
        ALIGN
        &       sv3-.-4
        LDR     PC, %FT03
        LDR     PC, %FT04
03
        &       SetYear
04
        &       ReadYear

sv3     =       "Sys$$Date", 0, VarType_Code
        ALIGN
        &       sv4-.-4
        LDR     PC, %FT05
        LDR     PC, %FT06
05
        &       SetDate
06
        &       ReadDate

sv4     =       "Sys$$ReturnCode", 0, VarType_Code
        ALIGN
        &       sv5-.-4
        LDR     PC, %FT07
        LDR     PC, %FT08
07
        &       SetRC
08
        &       ReadRC

sv5     =       "Sys$$RCLimit", 0, VarType_Code
        ALIGN
        &       sv6-.-4
        LDR     PC, %FT09
        LDR     PC, %FT10
09
        &       SetRCL
10
        &       ReadRCL

sv6     =       "Alias$.", 0, VarType_String
        ALIGN
        &       sv7-.-4
        =       "Cat ", 10

sv7     =       "Sys$$DateFormat", 0, VarType_String
        ALIGN
        &       sv8-.-4

        [ {TRUE}
        =       "%24:%mi:%se %dy-%m3-%ce%yr", 10
        |
        =       "%w3,%dy %m3 %ce%yr.%24:%mi:%se", 10
        ]

sv8     =       0

SysTimeFormat
        =       "%24:%mi:%se", 0
SysDateFormat
        =       "%w3,%dy %m3", 0
SysYearFormat
        =       "%ce%yr", 0

        ALIGN

; Now the code for our system variables.

ReadTimeVar
        ADR     R0, SysTimeFormat
        B       ReadTimeFormatted
SetTimeVar ROUT
        CMP     R2, #&FE
        BHI     TimeVarTooLong
        Push    "R0, lr"
        LDR     R12, =SysVarWorkSpace
        MOV     R11, #8
        STRB    R11, [R12], #1
        MOV     R10, #0
        STRB    R10, [R12, R2]
        MOV     R10, R2
01      SUBS    R10, R10, #1
        LDRPLB  R11, [R1, R10]
        STRPLB  R11, [R12, R10]
        BPL     %BT01
        SUB     R1, R12, #1
        MOV     R0, #15
        SWI     XOS_Word
        STRVS   R0, [R13]
        Pull    "R0, PC"

TimeVarTooLong
        ADRL    R0, ErrorBlock_VarTooLong
      [ International
        B       TranslateError
      |
        RETURNVS
      ]

ReadYear
        ADR     R0, SysYearFormat
        B       ReadTimeFormatted
SetYear ROUT
        CMP     R2, #4
        BHI     TimeVarTooLong
        Push    "R0, lr"
        Push    "R1,R2"
        ADR     R0, SetYearPrefixFormat
        BL      ReadTimeFormatted
        ADD     R12, R0, R2             ; R12 -> position to copy year to
        Pull    "R1,R2"
        BVS     %FT02
        MOV     R10, #0
        STRB    R10, [R12, R2]
        MOV     R10, R2
01      SUBS    R10, R10, #1
        LDRPLB  R11, [R1, R10]
        STRPLB  R11, [R12, R10]
        BPL     %BT01
        SUB     R1, R0, #1
        MOV     R0, #15
        STRB    R0, [R1]
        SWI     XOS_Word
02      STRVS   R0, [R13]
        Pull    "R0, PC"

ReadDate
        ADR     R0, SysDateFormat
        B       ReadTimeFormatted
SetDate ROUT
        CMP     R2, #&F8
        BHI     TimeVarTooLong
        Push    "R0, lr"
        LDR     R12, =SysVarWorkSpace
        MOV     R11, #15
        STRB    R11, [R12], #1
        MOV     R10, #0
        STRB    R10, [R12, R2]
        MOV     R10, R2
01      SUBS    R10, R10, #1
        LDRPLB  R11, [R1, R10]
        STRPLB  R11, [R12, R10]
        BPL     %BT01
        ADD     R1, R12, R2
        ADR     R0, SetDateSuffixFormat ; append year to supplied date
        Push    "R12"
        BL      ReadTimeFormattedAtR1
        Pull    "R12"
        SUB     R1, R12, #1
        MOV     R0, #15
        SWI     XOS_Word
        STRVS   R0, [R13]
        Pull    "R0, PC"


; in: R0 = format string
; out: R0 -> time string (0 terminated)
;      R2 = length of string (excluding terminator)
;      R1 corrupt
ReadTimeFormatted ROUT
        Push    "R3,R4,LR"
        LDR     R12, =SysVarWorkSpace
        ADD     R2, R12, #1
01      MOV     R4, R0
        SUB     R13, R13, #8
        MOV     R1, R13
        MOV     R0, #3
        STRB    R0, [R1]
        MOV     R0, #14
        SWI     XOS_Word
        BVS     %FT02
        MOV     R0, #-1
        MOV     R1, R13
        MOV     R3, #?SysVarWorkSpace-1
        SWI     XTerritory_ConvertDateAndTime
02      ADD     R13, R13, #8
        SUBVC   R2, R1, R0
        Pull    "R3,R4,PC"

; in: R0 = format string
;     R1 -> output buffer
; out: R0 -> time string (0 terminated)
;      R1 corrupt
;      R2 = length of string (excluding terminator)
ReadTimeFormattedAtR1
        Push    "R3,R4,LR"
        MOV     R2, R1
        B       %BT01

ReadRC  ROUT
        LDR     R0, =ZeroPage
        LDR     R0, [R0, #ReturnCode]
        B       ReadNumSysVar
SetRC   Push    "lr"
        BL      SetNumSysVar
        LDR     R4, =ZeroPage+ReturnCode
        STR     R2, [R4]
        LDR     R4, =ZeroPage+RCLimit
        LDR     R4, [R4]
        CMP     R2, R4
        BHI     %FT03
        CLRV    
        Pull    "PC"
03      ADRGT   R0, ErrorBlock_RCExc
        ADRLT   R0, ErrorBlock_RCNegative
      [ International
        BL      TranslateError
      |
        SETV
      ]

        Pull    "PC"
SetYearPrefixFormat
        =       "%w3,%dy %m3 ", 0
SetDateSuffixFormat
        =       " %ce%yr", 0
        ALIGN

        MakeErrorBlock RCExc
        MakeErrorBlock RCNegative

ReadRCL LDR     R0, =ZeroPage
        LDR     R0, [R0, #RCLimit]
ReadNumSysVar
        Push    "lr"
        LDR     R12, =SysVarWorkSpace
        MOV     R1, R12
        MOV     R2, #256
        SWI     XOS_BinaryToDecimal
        MOV     R0, R1
        Pull    "PC"
SetRCL  Push    "lr"
        BL      SetNumSysVar
        LDR     R4, =ZeroPage+RCLimit
        CMP     R2, #0                  ; can't set -ve RCLimit
        RSBMIS  R2, R2, #0
        MOVMI   R2, #0                  ; BIC of MININT
        STR     R2, [R4]
        Pull    "PC"

        LTORG

SetNumSysVar    ROUT ; R1 ptr to string, R2 string length
        Push    "lr"
        SUBS    R2, R2, #1
        ADDMI   R2, R2, #1              ; give 0 in R2 for bad length.
        Pull    "PC", MI
        LDR     R12, =SysVarWorkSpace
03      LDRB    R10, [R1], #1           ; copy into a buffer so we can terminate it.
        STRB    R10, [R12], #1
        SUBS    R2, R2, #1
        BPL     %BT03
        MOV     R10, #13
        STRB    R10, [R12], #1
        LDR     R1, =SysVarWorkSpace
        LDRB    R10, [R1]
        MOV     R12, #0
        CMP     R10, #"-"
        MOVEQ   R12, #-1
        CMPNE   R10, #"+"
        ADDEQ   R1, R1, #1
        MOV     R0, #0
        SWI     XOS_ReadUnsigned
        CMP     R12, #0
        RSBMI   R2, R2, #0
        Pull    "PC"


;*****************************************************************************
; GSINIT, GSREAD, GSTRANS

; To enable GSTrans nesting to stand a chance of working don't flatten the
; stack every FSINIT. Instead, pick up the stack pointer (any value is OK)
; and wrap at 255. Stack overflow occurs if you increment the pointer to
; where it started for this GSINIT, and stack underflow occurs if you
; decrement the pointer when it is currently equal to stack limit.
; The stack limit is held in the environment value, R2.
; The stack is empty ascending.
        GBLL    GS_BufferNotStack
GS_BufferNotStack SETL {TRUE}

; some semi-arbitrary flags
GS_NoQuoteMess   * 1 :SHL: 31   ; flags passed in from user
GS_NoVBarStuff   * 1 :SHL: 30
GS_Spc_term      * 1 :SHL: 29   ; clear if user requested terminate on space
GS_In_String     * 1 :SHL: 28   ; set if waiting for closing "
GS_ReadingString * 1 :SHL: 27   ; set if reading chars from a string var.
GS_Macroing      * 1 :SHL: 26   ; set if reading chars from a macro
 [ GS_BufferNotStack
        ASSERT  GS_StackPtr_Lim = &80
GS_StackLimitBits * 7
GS_StackLimitPos * 19           ; The bit position of the LSB of the byte
                                ; which holds the stack limit
; bits 0-18 hold the string length for string transfers
 |
; bits 24-25 are unused
; bits 0-23 hold the string length for string transfers
 ]

; After GSINIT, R2 has these flags, and if expanding a count in the low byte

GSINIT  ROUT
;  In  : R0 pointer to string to expand
;        R2 has flags :
;          Bit 29 set means space is a terminator
;          Bit 30 set means | characters will not be molested
;          Bit 31 set means don't mess with quotes

;  Out : R0, R2 are values to pass back in to GSREAD
;        R1 is the first non-blank character
;        EQ means char is CR or LF, i.e. string is empty.

        ; Enable interupts as we've no right to have them disabled here
        WritePSRc SVC_mode, R1

 [ GS_BufferNotStack
        AND     R2, R2, #GS_NoQuoteMess :OR: GS_NoVBarStuff :OR: GS_Spc_term
                                        ; get caller's flags
 ]

; If no tokens to expand then don't reset evaluation stack
; This prevents conflict with modules opening messages files at lower levels

        Push    "r0"
10      LDRB    r1, [r0], #1
        CMP     r1, #13
        CMPNE   r1, #10
        CMPNE   r1, #0
        Pull    "r0",EQ
        BEQ     %FT20                   ; Jump if end of string, nothing to expand

        TEQ     r1, #"<"                ; Possibly something to expand?
        BNE     %BT10                   ; No then try next
        Pull    "r0"

; Expansion may be necessary so flatten evaluation stack

 [ GS_BufferNotStack
        GSVarGetWSpace
        LDRB    R1, [R12, #GS_StackPtr]
        AND     R1, R1, #(GS_StackPtr_Lim-1)     ; Ensure we remain in range
        STRB    R1, [R12, #GS_StackPtr]
        ORR     R2, R2, R1, LSL #GS_StackLimitPos
 |
        MOV     R1, #0
        GSVarGetWSpace
        STRB    R1, [R12, #GS_StackPtr] ; no stacked R0s
 ]

20
 [ GS_BufferNotStack
 |
        AND     R2, R2, #GS_NoQuoteMess :OR: GS_NoVBarStuff :OR: GS_Spc_term
                                        ; get caller's flags
 ]
        EOR     R2, R2, #GS_Spc_term    ; and invert for convenience

01      LDRB    R1, [R0], #1
        CMP     R1, #" "
        BEQ     %BT01
        TST     R2, #GS_NoQuoteMess
        CMPEQ   R1, #""""
        SUBNE   R0, R0, #1              ; dec if went too far
        ORREQ   R2, R2, #GS_In_String   ; set flag if in string
        CMP     R1, #13
        CMPNE   R1, #10
        CMPNE   R1, #0
        ORREQ   lr, lr, #Z_bit          ; and move EQ/NE to return pc
        BICNE   lr, lr, #Z_bit
        ExitSWIHandler

        LTORG

; -----------------------------------------------------------------------------


GSREAD  ROUT
;  In  : R0, R2 from last GSREAD/GSINIT
;  Out : R1 character, R0, R2 updated.
;        VS => "Bad String" error
;        CS => string ended (in which case R1 = terminator)

        ; enable interupts as (a) they'll get enabled by a <thing> entry
        ; and (b) GSREAD may take some time
        WritePSRc SVC_mode, R10

        BIC     lr, lr, #C_bit
        MOV     R10, #0
        TST     R2, #GS_ReadingString
        BNE     GSREAD_RStringGetNextByte         ; take byte from stringvar

GSREAD_XPandGetNextByte
        LDRB    R1, [R0], #1
        CMP     R1, #13
        CMPNE   R1, #10
        CMPNE   R1, #0
        BEQ     GSREAD_XPandGotToEnd
        CMP     R1, #" "
        BEQ     GSREAD_XPandGotSpace
        BLT     GSREAD_BadStringError   ; bad string : control code in string
        CMP     R1, #""""
        BEQ     GSREAD_XPandGotQuote
        CMP     R1, #"|"
        TSTEQ   R2, #GS_NoVBarStuff
        BEQ     GSREAD_WorkOutBarChar
        CMP     R1, #"<"
        BNE     GSREAD_ReturnWithChar   ; OS_Exit with valid character

; got to try and get a variable value.
        Push    "R0, R2, lr"
        LDRB    R1, [R0]
        CMP     R1, #">"
        CMPNE   R1, #" "
        BEQ     GSREAD_AngleBraDaftSoIsnt  ; <> and < > are silly.

        ; Copy angle bracketed thing checking for correct termination
        ; OS_SetVarValue requires system variable names to be space or control
        ; terminated, so we shall discard anything which violates that rule
        GSVarGetWSpace
        ADD     R12, R12, #GSNameBuff
        MOV     R11, #0
20      LDRB    R1, [R0], #1
        STRB    R1, [R12], #1
        ADD     R11, R11, #1
        CMP     R1, #">"
        BEQ     %FT25
        CMP     R11, #?GSNameBuff
        CMPNE   R1, #" "
        TSTNE   R1, #&E0                ; i.e. EQ if <32
        BNE     %BT20
        B       GSREAD_AngleBraDaftSoIsnt

25
        ; Check for number first
        MOV     R1, #0
        STRB    R1, [R12, #-1]          ; terminate it
        SUB     R1, R12, R11            ; pointer to name or number
        Push    "R0"
        MOV     R0, #10
        SWI     XOS_ReadUnsigned        ; check for number
        Pull    "R0"
        BVS     GSREAD_AngledThingAintNumber   ; silly - has to be name
        LDRB    R1, [R1]                ; check terminated by the null
        CMP     R1, #0
        BNE     GSREAD_AngledThingAintNumber
        MOV     R1, R2                  ; character value
        ADD     stack, stack, #4        ; discard old R0 value.
        Pull    "R2, lr"
        B       GSREAD_ReturnWithChar   ; exit-R1's the char value.

GSREAD_AngledThingAintNumber
        ; R0, R2, lr on stack
        Push    "R0, R3, R4, R10"       ; corrupted by VarFindIt
        MOV     R3, #0                  ; context ptr
        SUB     R0, R12, R11            ; name ptr
        BL      VarFindIt
        Pull    "R0, R3, R4, R10", EQ   ; not found mate
        BEQ     GSREAD_AngledThingNotThere  ; return null expansion
; well, we've found it - better stack old R0
        Pull    "R0"
        GSVarGetWSpace
 [ GS_BufferNotStack
        LDRB    r1, [r12, #GS_StackPtr]
        LDR     r2, [sp, #4*4]          ; r3,r4,r10,r0,r2,lr on stack, hence r2 retrieved
        MOV     r2, r2, ASL #32-(GS_StackLimitPos+GS_StackLimitBits)
        SUB     r2, r2, #1:SHL:(32-GS_StackLimitBits)
        TEQ     r1, r2, LSR #32-GS_StackLimitBits
        BEQ     GSREAD_CantNestMore
 |
        LDRB    R1, [R12, #GS_StackPtr]
        CMP     R1, #GS_StackPtr_Lim
        BHS     GSREAD_CantNestMore
 ]
        ADD     R12, R12, #GS_Stack
        STR     R0, [R12, R1, LSL #2]
        ADD     R1, R1, #1
 [ GS_BufferNotStack
        AND     R1, R1, #(GS_StackPtr_Lim-1)
 ]
        STRB    R1, [R12, #GS_StackPtr-GS_Stack]
        MOV     R0, R4
        LDRB    R1, [R0], #1            ; type
        CMP     R1, #VarType_Code
        BEQ     GSREAD_CallCodeVar
        CMP     R1, #VarType_Number
        LDRB    R1, [R0], #1

        LDRB    R3, [R0], #1
        ORR     R1, R1, R3, LSL #8
        LDRB    R3, [R0], #1
        ORR     R1, R1, R3, LSL #16

        BLO     GSREAD_GotVarAsString
        BHI     GSREAD_GotMacroVar
        LDRB    R3, [R0], #1
        ORR     R1, R1, R3, LSL #24
        MOV     R0, R1
        ADD     R1, R12, #GSNameBuff-GS_Stack
        MOV     R2, #256
        SWI     XOS_BinaryToDecimal
        MOV     R0, R1
        MOV     R1, R2

; it's a string variable, by now.
GSREAD_GotVarAsString
        Pull    "R3, R4, R10"
        ADD     stack, stack, #4        ; discard that R0
        Pull    "R2, lr"
        CMP     R1, #0
        BEQ     ZeroLengthVar
        ORR     R2, R2, R1              ; old flags+new count
        ORR     R2, R2, #GS_ReadingString
        LDRB    R1, [R0], #1
        B       GSREAD_ReturnWithChar

GSREAD_GotMacroVar
        ; Macro - R0 is now the ptr to the macro value.
        Pull    "R3, R4, R10"
        ADD     stack, stack, #4
        Pull    "R2, lr"
        ORR     R2, R2, #GS_Macroing
        B       GSREAD_XPandGetNextByte ; loop, transforming chars.

GSREAD_CantNestMore
        Pull    "R3, R4, R10"           ; no room to stack pointer, so don't expand
GSREAD_AngledThingNotThere
        ADD     stack, stack, #4        ; skip R0 - return null string
        Pull    "R2, lr"
        B       GSREAD_XPandGetNextByte ; get next char

GSREAD_AngleBraDaftSoIsnt
        Pull    "R0, R2, lr"
        MOV     R1, #"<"
        B       GSREAD_ReturnWithChar   ; failed to get sensible variable

GSREAD_XPandGotToEnd
        TST     R2, #GS_In_String       ; got CR or LF
        BNE     GSREAD_BadStringError   ; bad string
        TST     R2, #GS_Macroing
GSREAD_GotToAnEnd
        ORREQ   lr, lr, #C_bit          ; got terminator
        ExitSWIHandler EQ

        ; Nest out by one level
        GSVarGetWSpace
        LDRB    R11, [R12, #GS_StackPtr]
 [ GS_BufferNotStack
        SUB     R11, R11, #1
        AND     R11, R11, #(GS_StackPtr_Lim-1)
        MOV     r2, r2, ROR #GS_StackLimitPos+GS_StackLimitBits
        TEQ     r11, r2, LSR #32-GS_StackLimitBits
        MOV     r2, r2, ROR #32-(GS_StackLimitPos+GS_StackLimitBits)
 |
        SUBS    R11, R11, #1
 ]
        BICEQ   R2, R2, #GS_Macroing
        STRB    R11, [R12, #GS_StackPtr]
        ADD     R12, R12, #GS_Stack
        LDR     R0, [R12, R11, LSL #2]
        B       GSREAD_XPandGetNextByte ; return to prevstring

GSREAD_XPandGotSpace
        TST     R2, #(GS_In_String :OR: GS_Spc_term :OR: GS_Macroing)
                                        ; got space : check termination
        BEQ     GSREAD_GotToAnEnd       ; terminates

GSREAD_ReturnWithChar
        ORR     R1, R1, R10             ; valid character
        ExitSWIHandler

GSREAD_XPandGotQuote
        TST     R2, #GS_In_String
        BEQ     GSREAD_ReturnWithChar   ; if not in string, " is valid.
        LDRB    R1, [R0], #1
        CMP     R1, #""""               ; "" in string?
        BEQ     GSREAD_ReturnWithChar   ; yup


; TMD 25-Sep-89: Fix termination here

10
        CMP     R1, #" "
        LDREQB  R1, [R0], #1
        BEQ     %BT10
        SUB     R0, R0, #1
        ORR     lr, lr, #C_bit          ; got terminator (second ")
        ExitSWIHandler                  ; and out

GSREAD_WorkOutBarChar
        LDRB    R1, [R0], #1            ; got |, do traditional escaping
        CMP     R1, #"|"
        CMPNE   R1, #""""
        CMPNE   R1, #"<"
        BEQ     GSREAD_ReturnWithChar   ; || gives |, |" gives ", |< gives <
        CMP     R1, #"?"
        MOVEQ   R1, #&7F                ; delete
        BEQ     GSREAD_ReturnWithChar   ; valid ch
        CMP     R1, #"!"
        MOVEQ   R10, #&80
        BEQ     GSREAD_XPandGetNextByte ; tbs char
        CMP     R1, #" "
        BLT     GSREAD_BadStringError   ; OS_Control character is naff
        CMP     R1, #&7F                ; CTRL-delete is delete
        EORGT   R1, R1, #&20            ; softkey
        BGE     GSREAD_ReturnWithChar   ; now valid ch
        CMP     R1, #"`"                ; CTRL-` = CTRL-_
        MOVEQ   R1, #"_"
        CMP     R1, #"@@"
        ANDGE   R1, R1, #&1F            ; transform if @@<=ch<delete
        B       GSREAD_ReturnWithChar

GSREAD_RStringGetNextByte
        SUB     R2, R2, #1              ; we're reading a string
  [ GS_BufferNotStack
        MOVS    R12, R2, ASL #32-GS_StackLimitPos
  |
        ANDS    r12, r2, #&00ffffff
  ]
        LDRNEB  R1, [R0], #1            ; and this is already expanded
        ExitSWIHandler NE               ; so finished
ZeroLengthVar
        GSVarGetWSpace
        LDRB    R0, [R12, #GS_StackPtr] ; pull an R0 from our stack
        SUB     R0, R0, #1
 [ GS_BufferNotStack
        AND     R0, R0, #(GS_StackPtr_Lim-1)
 ]
        STRB    R0, [R12, #GS_StackPtr]
        ADD     R12, R12, #GS_Stack
        LDR     R0, [R12, R0, LSL #2]
        BIC     R2, R2, #GS_ReadingString
        B       GSREAD_XPandGetNextByte

GSREAD_BadStringError
        ADR     R0, BadStrErr
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        ORR     lr, lr, #V_bit :OR: C_bit
        ExitSWIHandler

BadStrErr
        MakeErrorBlock BadString

GSREAD_CallCodeVar
        ADD     R0, R0, #3 + 4          ; 3 to ALIGN, 4 to get to read entry
        MOV     lr, PC                  ; get link
        BIC     PC, R0, #3              ; call entrypoint to Read Thunk
        MOV     R1, R2
        B       GSREAD_GotVarAsString

; ---------------------------------------------------------------------------


GSTRANS ROUT                    ; enables interrupts
; In   : R0 ptr to input string
       ; R1 ptr to Out buffer
       ; R2 max number of chars, with flags at top.

; Out  : R0 points at terminator
       ; R1 unchanged
       ; R2 Number of chars got,
       ;  C set if too many chars
       ;  V set if bad string.

        BIC     lr, lr, #C_bit
        Push    "R1, R3-R5, lr"
        WritePSRc SVC_mode, R3          ; enable ints.

        MOV     R3, R1                  
        MOV     R4, R1                  ; two copies of start ptr
        BIC     R5, R2, #&E0000000      
        ADD     R5, R5, R1              ; 1st byte we can't write to.
        SWI     XOS_GSInit              
01      CMP     R3, R5                  
        BHS     %FT03                   ; no rheum for byte.
        SWI     XOS_GSRead              
        BVS     %FT02                   ; bad string
        STRB    R1, [R3], #1            
        BCC     %BT01                   
04      SUB     R2, R3, R4              ; no chars got
        SUB     R2, R2, #1              
        Pull    "R1, R3-R5, lr"         
        ExitSWIHandler

02      SUB     R2, R3, R4              
        Pull    "R1, R3-R5, lr"         
        B       SLVK_SetV               ; bad string: error set by GSRead

03      SUB     R2, R3, R4
        Pull    "R1, R3-R5, lr"
        ORR     lr, lr, #C_bit          ; buffer overflow
        ExitSWIHandler

;****************************************************************************
; Read/Write variables
; Also the binary->decimal SWI.
; All the var SWIs enable interrupts - they all take quite a while.

; First the lookup SWI, ReadVarValue
; In:
;   R0 -> name; maybe wildcarded (* and #)
;   R1 -> buffer
;   R2 = buffer max length
;   R3 = 0 or pointer to name returned from previous ReadVarVal
;   R4 = VarType_Expanded or something else

; Out:
;  Not found:
;   R0 -> VarCantFind error
;   R1 unaltered
;   R2 = 0
;   R3,r4 trashed
;   VSet
;  Found, r2 < 0 and r4 <> VarType_Expanded on entry:
;   R0, R1 unaltered
;   R2 = NOT length of value
;   R3 -> name of variable (0-terminated)
;   R4 = type of result
;  Found, r2 < 0 and r4 = VarType_Expanded on entry:
;   R0, R1 unaltered
;   R2 = -ve
;   R3 -> name of variable (0-terminated)
;   R4 = type of result
;  Found, r2 >= 0 on entry:
;   R0, R1 unaltered
;   R2 no chars got
;   R3 -> name of variable. Can be passed to this SWI to continue enumeration
;      of wildcard.
;   R4 type of result (VarType_String, VarType_Number, VarType_Macro)
;   VSet if buffer overflowed (R0->error block)

 [ Oscli_QuickAliases
;  R0 in = -1 is special case: skip call to VarFindIt (r5,r6,r7 in supply r3,r4,r12)
 ]

ReadVarValue ROUT
        WritePSRc SVC_mode, r11         ; enable interupts (mode remains unchanged)
        Entry   "r0,r1"

        MOV     r11, r4

  [ Oscli_QuickAliases
        CMP     r0, #-1
        BNE     rvv_noqaspecialentry
        MOV     r3,r5
        MOV     r4,r6
        MOV     r12,r7
        B       rvv_qaspecialentry
rvv_noqaspecialentry
  ]

        BL      VarFindIt               ; name=r0,context=r3 -> name found in node=r3,r4=after namein,r12=prev
        BEQ     RVVNotFound

  [ Oscli_QuickAliases
rvv_qaspecialentry
  ]
        ; Regardless of expanded or not - always call the code to get value
        LDRB    lr, [r4], #1
        TEQ     lr, #VarType_Code
        BEQ     ReadVarVal_CallCode

        ; Check whether expanded value wanted and pick up found variable's type
        TEQ     r11, #VarType_Expanded
        MOV     r11, r4
        MOV     r4, lr
        BEQ     ReadVarVal_ExpandedWanted

        ; Unexpanded value wanted....

        ; If number then want 4 bytes, else however many there are in the varval
        TEQ     r4, #VarType_Number
        MOVEQ   r10, #4

ReadVarVal_CopyStringVarToUserBuffer
        ; R1 -> user buffer
        ; R2 = user buffer size
        ; R3 -> name of sysvar found
        ; R4 = sysvar type to return
        ; R10 = length to transfer to user buffer (EQ only)
        ; R11 -> length byte(s) of sysvar (NE only)
        ;     -> bytes string to transfer (EQ only)
        LDRNEB  r10, [r11], #1
        LDRNEB  lr, [r11], #1
        ORRNE   r10, r10, lr, ASL #8
        LDRNEB  lr, [r11], #1
        ORRNE   r10, r10, lr, ASL #16

ReadVarVal_CopyR10BytesToUserBuffer
        ; R1 -> user buffer
        ; R2 = user buffer size
        ; R3 -> name of sysvar found
        ; R4 = type byte to be returned
        ; R10 = bytes to be copied
        ; R11 -> bytes to be copied

        CMP     R10, R2
        BGT     ReadVarVal_BufWillOFlow

VarNoOFlo
        ; Guaranteed the the buffer won't overflow now
        MOV     R2, R10                 ; bytes he's gonna get
; now copy R10 bytes into buffer
02      SUBS    R10, R10, #1
        LDRPLB  R12, [R11, R10]
        STRPLB  R12, [R1, R10]
        BPL     %BT02

ReadVarVal_OKExit
        PullEnv
        ExitSWIHandler

ReadVarVal_BufWillOFlow
        ; Have determined that the buffer will overflow, so generate an error
        ; and shorten down to the buffer's size
        ADR     r0, BufferOFloError
    [ International
        BL      TranslateError
    ]
        STR     r0, [stack, #Proc_LocalStack + 0*4]
        LDR     lr, [stack, #Proc_LocalStack + 2*4]
        ORR     lr, lr, #V_bit     ; set for return
        STR     lr, [stack, #Proc_LocalStack + 2*4]

        ; ensure NOT length returned in r2 when returning with r2<0 on entry
        CMP     r2, #0
        MVNMI   r10, r10
        MOVPL   r10, r2
        B       VarNoOFlo

BufferOFloError
        MakeErrorBlock BuffOverflow

ReadVarVal_CallCode
        Push    "r0-r2"                 ; read sysvar : r4 points after type
        ADD     r11, r4, #3 + 4         ; 3 to align and 4 to get to read entry
        MOV     lr, pc                  ; construct link
        BIC     pc, r11, #3             ; call read code in var
        MOV     r11, r0                 ; ptr to value
        MOV     r10, r2                 ; no of chars.
        Pull    "r0-r2"

        ; error may be returned from reading the var val
        MOVVS   r0, r11
        BVS     ReadVarVal_TestVExit

        MOV     r4, #VarType_String
        B       ReadVarVal_CopyR10BytesToUserBuffer

ReadVarVal_ExpandedWanted
        ; Request for expanded value....

        ; Check for number, string or macro
        CMP     R4, #VarType_Number
        BLT     ReadVarVal_CopyStringVarToUserBuffer
        BEQ     ReadVarVal_FoundNumber

; macro - gstrans it. R1 buffer ptr, r2 max chars, R11+1 ptr to value.
; Macros have a terminator after their value, to allow GSTRANS.

        CMP     r2, #0                  ; if negative, then don't call GSTrans because bits 29..31 have
        MVNMI   r10, r2                 ; return r2 out by this method
        BMI     ReadVarVal_BufWillOFlow ; a special meaning - just branch back to the normal overflow code

        ADD     r0, r11, #3             ; skip length
        SWI     XOS_GSTrans
        BVS     ReadVarVal_TestVExit
        BCC     ReadVarVal_OKExit

        ADR     R0, BufferOFloError
      [ International
        BL      TranslateError
      ]
        B       ReadVarVal_SetVExit


ReadVarVal_FoundNumber
        ; Found a number - extract its value and convert to string
        LDRB    R0, [R11], #1           ; number - convert to string.
        LDRB    R12, [R11], #1
        ORR     R0, R0, R12, LSL #8
        LDRB    R12, [R11], #1
        ORR     R0, R0, R12, LSL #16
        LDRB    R12, [R11]
        ORR     R0, R0, R12, LSL #24

        ; got number in R0, buffptr in R1, max chars in R2
        SWI     XOS_BinaryToDecimal

        MOV     r4, #VarType_String

ReadVarVal_TestVExit
        STRVS   r0, [stack, #Proc_LocalStack + 0*4]
        PullEnv
        B       SLVK_TestV

RVVNotFound
 [ International
        MOV     r4, r0
        ADR     r0, RVVNFError
        BL      TranslateError_UseR4
 |
        ADR     R0, RVVNFError
 ]
        MOV     r2, #0                  ; indicate not found.

ReadVarVal_SetVExit
        STR     r0, [stack, #Proc_LocalStack + 0*4]
        PullEnv
        B       SLVK_SetV               ; general error return

RVVNFError
        MakeErrorBlock VarCantFind


; *****************************************************************************
; SWI OS_SetVarVal : create/update/destroy a variable.

; In:   R0 pointer to name (can be wildcarded for update/delete)
;             ctrl/char or space terminated
;       R1 pointer to value. String values must be CR or LF terminated.
;       R2 negative means destroy the variable. +ve is update/create
;       R3 name pointer or 0
;       R4 type.
;
;  Evaluation of value : this depends on the type.
;  VarType_String   : GSTRANS the given value
;  VarType_Number   : Value is a 4 byte (signed) integer
;  VarType_Macro    : Copy value (may be GSTRANSed on use)
;  VarType_Expanded : the value is a string which should be evaluated as an
;                     expression. Variable is then numeric or string
;  VarType_LiteralString : Copy the given value as a string
;
;  VarType_Code     : R2 is the length of the code to copy in, including
;                     padding to align the code.
;                     Can only delete sysvars if R4 = VarType_Code

; Out:  R3 new name pointer (so can delete all occurrences of f*, etc.
;          slightly more efficiently).
;       R4 type created for expressions
;       V set for :
;          1) bad name  (creation of wildcarded names is banned)
;          2) Bad string from GSTRANS
;          3) Bad macro value (control codes not allowed)
;          4) Bad expression from ReadExpression
;          5) Can't find (for deletion)
;          6) Not enough room to create/update it (system heap full)
;          7) Value too long (variables are limited to 256 bytes in length)
;          8) Bad type (update/create)


 [ DebugSysVars
SysVar_Write0 Entry "r0,r1"
        MOV     r1, r0
10
        LDRB    r0, [r1], #1
        CMP     r0, #" "
        EXIT    LO
        SWI     XOS_WriteC
        B       %BT10

 ]

SetVarValue
        ; enable IRQs
        WritePSRc SVC_mode, r10

        Entry   "r0,r1,r2,r4,r5,r6,r9"

 [ DebugSysVars
        SWI     XOS_WriteS
        =       "SetVarVal ",0
        BL      SysVar_Write0
        SWI     XOS_NewLine
 ]

        MOV     r9, stack
        MOV     r10, r4

        CMP     r2, #0
        BMI     SetVarVal_DeleteIt

        ; Range check type
        CMP     r10, #VarType_Code
        CMPNE   r10, #VarType_LiteralString
        ADRHIL  r0, ErrorBlock_BadVarType
        BHI     SetVarValBadExit_Translate

        ; Always expand a VarType_Expanded:
        TEQ     r10, #VarType_Expanded
        BNE     SetVarVal_AintExpanded

        ; Process VarType_Expanded

        MOV     r0, stack, LSR #20      ; SVC stack base assumed on 1M boundary
        SUB     r0, sp, r0, LSL #20     ; amount of stack left
        CMP     r0, #LongCLISize + 2048 ; insist on 2k left after long buffer
        MOVHS   r2, #LongCLISize        ; ok, got a long buffer
        MOVLO   r2, #256                ; stack full-ish, use a 256 buffer and hope it's big enough
        SUB     stack, stack, r2

        MOV     r0, r1                  ; ptr to expression
        MOV     r1, stack
        SWI     XOS_EvaluateExpression
        BVS     SetVarVal_TestVExit
        TEQ     r1, #0   ; integer?
        MOVNE   r10, #VarType_LiteralString
        MOVEQ   r10, #VarType_Number
        STREQ   r2, [stack]
        MOVEQ   r2, #4
        STR     r10, [r9, #3*4]         ; r4 out
        MOV     r1, stack
        LDR     r0, [r9, #0*4]

SetVarVal_AintExpanded

        ; Setting a variable
        BL      VarFindIt
        BNE     SetVarVal_NodeAlreadyExists

        ; Node missing....

        ; Check variable name has no wildcards
        SUB     r4, r0, #1
05
        LDRB    lr, [r4, #1]!
        CMP     lr, #"#"
        CMPNE   lr, #"*"
        CMPNE   lr, #" "
        BHI     %BT05
        CMP     lr, #"#"
        CMPNE   lr, #"*"
        CMPNE   r4, r0
        ADREQL  r0, ErrorBlock_BadVarNam
        BEQ     SetVarValBadExit_Translate     ; error no. 1)

        ; R12 index of 1st entry in QuickIndex >= the entry we're interested in
        MOV     r3, #0                  ; To indicate absence of current
        B       SetVarVal_CreateNode

SetVarVal_NodeAlreadyExists
        MOV     r0, r3                  ; If already there use that's name in case supplied name wildcarded
        LDRB    lr, [r4]
        TEQ     lr, #VarType_Code
        BNE     SetVarVal_CreateNode
        TEQ     r10, #VarType_Code
        BEQ     SetVarVal_CreateNode

        ; Assign non code value to code node
        CMP     r10, #VarType_Number
        BHI     SetVarVal_AssignToCodeDoIt

        BLO     SetVarVal_AssignStringToCode

        SUB     stack, stack, #256      ; buffer
        MOV     r2, #256

        ; Assign a number to the code variable
        LDRB    r0, [r1], #1
        LDRB    lr, [r1], #1
        ORR     r0, r0, lr, LSL #8
        LDRB    lr, [r1], #1
        ORR     r0, r0, lr, LSL #16
        LDRB    lr, [r1], #1
        ORR     r0, r0, lr, LSL #24
        MOV     r1, stack
        SWI     XOS_BinaryToDecimal

        B       SetVarVal_AssignToCodeDoIt

SetVarVal_AssignStringToCode

        MOV     r0, stack, LSR #20      ; SVC stack base assumed on 1M boundary
        SUB     r0, sp, r0, LSL #20     ; amount of stack left
        CMP     r0, #LongCLISize + 2048 ; insist on 2k left after long buffer
        MOVHS   r2, #LongCLISize        ; ok, got a long buffer
        MOVLO   r2, #256                ; stack full-ish, use a 256 buffer and hope it's big enough
        SUB     stack, stack, r2

        ; Expand string to stack frame then do it
        MOV     r0, r1
        MOV     r1, stack
        SWI     XOS_GSTrans
        BVS     SetVarVal_TestVExit
        ADRCSL  r0, ErrorBlock_VarTooLong
        BCS     SetVarValBadExit_Translate

SetVarVal_AssignToCodeDoIt

        ADDS    r4, r4, #3 + 1          ; skip type, add 3 for ALIGN , clear V
        MOV     lr, PC
        BIC     PC, R4, #3              ; complete align and call

        B       SetVarVal_TestVExit


SetVarVal_CreateNode
        ; Create a node
        ;
        ; r0 -> name (already confirmed non-wildcarded)
        ; r1 -> value
        ; r2 = length (where appropriate)
        ; r3 = this or 0
        ; r10 = type
        ; r12 = insertion point

        MOV     r5, r1
        MOV     r6, r3

        ; first work out the length of those things we can work the length of

        ; Header and name...
        MOV     r3, #0                  ;accumulator for length of things we know
        MOV     r1, r0
10
        LDRB    lr, [r1], #1
        ADD     r3, r3, #1
        CMP     lr, #" "
        BHI     %BT10

;r3 is now name length +1 for terminator
        ADD     r3, r3, #1              ;add in 1 for the type byte

        ; Deal with number and string type
        CMP     r10, #VarType_Number
        ADDLO   r3, r3, #64             ; only an initial guess for the string type
        ADDEQ   r3, r3, #4
        MOVEQ   r2, #4
        BLS     SetVarVal_GotInitialLength

        CMP     r10, #VarType_Code
        ADDEQ   r3, r3, #3              ; ALIGN
        BICEQ   r3, r3, #3
        ADDEQ   r3, r3, r2              ; code
        BEQ     SetVarVal_GotInitialLength

        TEQ     r10, #VarType_LiteralString
        BEQ     %FT20

        ; Macro - strlen and check the value is vaguely OK
        MOV     r2, r5
15
        LDRB    lr, [r2], #1
        CMP     lr, #" "
        BHS     %BT15
        TEQ     lr, #0                  ; must terminate with NUL, CR or LF
        TEQNE   lr, #10
        TEQNE   lr, #13
        ADRNE   r0, ErrorBlock_BadMacVal
        BNE     SetVarValBadExit_Translate
        SUB     r2, r2, r5
20
        ADD     r3, r3, r2
        ADD     r3, r3, #3              ; for the length bytes

SetVarVal_GotInitialLength
        ; r0 -> node's name
        ; r2 = value length (Number, Macro and Code)
        ; r3 = node length needed (maybe initial guess for Strings)
        ; r5 -> value (r1 in)
        ; r6 -> name of node to be replaced (0 if no node being replaced)
        ; r10 = value's type (String, Number, Macro or Code)
        ; r12 -> insertion point

        Push    "r0-r2"
  [ SysVars_StickyNodes
        ADD     r3,r3,#SysVars_StickyNode_UnitSize-1
        BIC     r3,r3,#SysVars_StickyNode_UnitSize-1  ;so we don't fight sticky routines over sizes
        BL      SysVars_ClaimVNode
  |
        BL      ClaimSysHeapNode
  ]
        Pull    "r0-r2",VS
        BVS     SetVarVal_VarNoRoom

        ; Got a heap block - fill it in

        ; Copy name

        MOV     r4, r2
        LDR     r0,[sp]
25
        LDRB    lr, [r0], #1
        CMP     lr, #" "
        MOVLS   lr, #0
        STRB    lr, [r4], #1
        BHI     %BT25

        LDR     r1,[sp,#8]
        ADD     sp,sp,#12               ; balances push r0-r2 above - value length (entry r2) now in r1

        ; Variable's type
        TEQ     r10, #VarType_LiteralString
        MOVEQ   lr, #VarType_String
        MOVNE   lr, r10
        STRB    lr, [r4], #1

        TEQ     r10, #VarType_String
        BEQ     SetVarVal_FillInString

        TEQ     r10, #VarType_Code
        ADDEQ   r4, r4, #3
        BICEQ   r4, r4, #3
        Push    "r4",EQ ; Remember start of code block for code variables
        TEQNE   r10, #VarType_Number
        BEQ     SetVarVal_CopyR1BytesToR4

        ; For macro type fill in a length
        TEQ     r10, #VarType_Macro
        SUBEQ   r1, r1, #1              ; ghastly fudge to avoid display of terminator
        STRB    r1, [r4], #1
        MOV     r1, r1, ROR #8
        STRB    r1, [r4], #1
        MOV     r1, r1, ROR #8
        STRB    r1, [r4], #1
        MOV     r1, r1, ROR #16
        ADDEQ   r1, r1, #1              ; undo ghastly fudge

        B       %FT35
30
        LDRB    lr, [r5], #1
        STRB    lr, [r4], #1
35
SetVarVal_CopyR1BytesToR4
        SUBS    r1, r1, #1
        BHS     %BT30

        TEQ     r10, #VarType_Code
        BNE     SetVarVal_NewNodeReady

        Pull    "r1" ; Grab pointer to start of code block
        Push    "r0,r2"
        MOV     r0,#1
        MOV     r2,r4
        SWI     XOS_SynchroniseCodeAreas
        Pull    "r0,r2"
        B       SetVarVal_NewNodeReady

SetVarVal_FillInString
        ; Here's the real smart bit of code

        ; The idea is this:
        ; Instead of GSTransing, we GSInit and GSRead ourselves. When the
        ; block gets full expand it and carry on. At the end the block is shrunk to fit.

        ADD     r4, r4, #3              ; for the length bytes
        MOV     r11, r4                 ; preserve location of string start for when we've done
        MOV     r0, r5                  ; r1 in
        MOV     r5, r2
        MOV     r2, #0
        SWI     XOS_GSInit
        BVS     SetVarVal_DisasterExpandingString
        B       %FT45

40
        SWI     XOS_GSRead
        BVS     SetVarVal_DisasterExpandingBadString
        BCS     SetVarVal_StringFinishedExpanding
        STRB    r1, [r4], #1
        CMP     r4, r3
        BLO     %BT40

        ; Run out of room in this block - stretch it
        Push    "r0-r2"
        MOV     r0, #HeapReason_ExtendBlock
        MOV     r2, r5
        MOV     r3, #64                 ;should be a multiple of StickyNode_UnitSize if SysVars_StickyNodes TRUE
  [ SysVars_StickyNodes
        BL      SysVars_ExpandOrShrinkVNode
  |
        BL      DoSysHeapOpWithExtension
  ]
        STRVS   r0, [sp]
        SUBVC   lr, r2, r5
        ADDVC   r4, r4, lr
        ADDVC   r11, r11, lr
        MOVVC   r5, r2
        Pull    "r0-r2"
        BVS     SetVarVal_DisasterExpandingString

45
        LDR     r3, [r5, #-4]           ; The heap block's size
  [ SysVars_StickyNodes
        SUB     r3, r3, #8              ; the amount we're allowed to use
  |
        SUB     r3, r3, #4              ; the amount we're allowed to use
  ]
        ADD     r3, r3, r5              ; the block's end
        B       %BT40

SetVarVal_StringFinishedExpanding

        ; Shorten block to required size
        MOV     r0, #HeapReason_ExtendBlock
  [ SysVars_StickyNodes
        Push    "r4"
        ADD     r4, r4, #SysVars_StickyNode_UnitSize-1
        BIC     r4, r4, #SysVars_StickyNode_UnitSize-1  ;so we don't fight over sticky sizes
        SUB     r3, r4, r3
        Pull    "r4"
        MOV     r2, r5
        BL      SysVars_ExpandOrShrinkVNode
  |
        SUB     r3, r4, r3
        MOV     r2, r5
        BL      DoSysHeapOpWithExtension
  ]
        BVS     SetVarVal_DisasterExpandingString

        ; Relocate pointers
        SUB     lr, r2, r5
        ADD     r4, r4, lr
        ADD     r11, r11, lr

        ; Work out ultimate size and store it
        SUB     lr, r4, r11
        STRB    lr, [r11, #-3]
        MOV     lr, lr, LSR #8
        STRB    lr, [r11, #-2]
        MOV     lr, lr, LSR #8
        STRB    lr, [r11, #-1]

SetVarVal_NewNodeReady
        ; r2 -> new node
        ; r6 -> old node's name (or is 0 if no old node)
        ; r12 = insertion point

 [ DebugSysVars
        Push    "r0,r1,r2"
        SUB     sp, sp, #12
        MOV     r0, r2
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        SWI     XOS_Write0
        SWI     XOS_WriteI+" "
        MOV     r0, r6
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        SWI     XOS_Write0
        SWI     XOS_WriteI+" "
        MOV     r0, r12
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        SWI     XOS_Write0
        SWI     XOS_WriteI+" "
        ADD     sp, sp, #12
        Pull    "r0,r1,r2"
 ]
        LDR     r11, =ZeroPage+VariableList
        LDR     r10, [r11]
  [ SysVars_QuickContext
        TEQ     r10,#0
        ADDNE   r10,r10,#SysVars_VTableOffset
  ]
        MOV     r5, r2
        TEQ     r6, #0
        BEQ     SetVarVal_Insertion

 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-straight replace-",0
 ]

        MOV     r2, r6
  [ SysVars_StickyNodes
        BL      SysVars_FreeVNode
  |
        BL      FreeSysHeapNode
  ]
        B       SetVarVal_Replace

SetVarVal_Insertion
 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-insert-",0
 ]
        TEQ     r10, #0
        BNE     SetVarVal_PossibleExtend

 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-create index-",0
 ]

  [ SysVars_QuickContext
        ; SysVars_Vindex_NStart nodes, 1 word for the count, plus data before table
        MOV     r3, #SysVars_Vindex_NStart*4
        ADD     r3, r3, #4+SysVars_VTableOffset
  |
        MOV     r3, #(10*4)+4           ; 10 nodes and 1 word for the count
  ]
        BL      ClaimSysHeapNode        ; this is not a variable node (its the index)
        BVS     SetVarVal_NoRoomForIndex
  [ SysVars_QuickContext
        MOV     r10,#-1
        STR     r10, [r2, #SysVars_LastContext]    ; initialise last context as invalid
  ]
        MOV     r10, r2
        MOV     r4, #0
        B       SetVarVal_DoInsertNewBlock

SetVarVal_PossibleExtend
 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-extend index-",0
 ]
        LDR     r4, [r10]
  [ SysVars_QuickContext
        LDR     lr, [r10, #-(4+SysVars_VTableOffset)] ; Block length, from heap block
        SUB     lr, lr, #4+4+SysVars_VTableOffset     ; 4 for heap adjustment, 4 for entry count word, plus name buffer
  |
        LDR     lr, [r10, #-4]          ; Block length, from heap block
        SUB     lr, lr, #4+4            ; 4 for heap adjustment and 4 for entry count word
  ]
        CMP     lr, r4, ASL #2
        BHI     SetVarVal_DoInsert      ; we've got room with this block

 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-do extend-",0
 ]

        MOV     r0, #HeapReason_ExtendBlock
  [ SysVars_QuickContext
        SUB     r2, r10, #SysVars_VTableOffset
        MOV     r3, #SysVars_Vindex_NBump*4     ; room for SysVars_Vindex_NBump more nodes
  |
        MOV     r2, r10
        MOV     r3, #40                 ; room for 10 more nodes
  ]
        BL      DoSysHeapOpWithExtension        ;not a variable node (expanding index)
        BVS     SetVarVal_NoRoomForIndex

        MOV     r10, r2

SetVarVal_DoInsertNewBlock
        STR     r10, [r11]
  [ SysVars_QuickContext
        ADD     r10,r10,#SysVars_VTableOffset
  ]
SetVarVal_DoInsert
 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-doinsert-",0
 ]
        ADD     r0, r10, r12, ASL #2    ; insertion point
        ADD     r1, r10, r4, ASL #2     ; rover
        B       SetVarVal_DoInsertEnd

SetVarVal_DoInsertStart
        LDR     lr, [r1], #-4
        STR     lr, [r1, #8]

SetVarVal_DoInsertEnd
        CMP     r1, r0
        BHS     SetVarVal_DoInsertStart

        ADD     r4, r4, #1
        STR     r4, [r10]

SetVarVal_Replace
 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-doreplace-",0
 ]
        STR     r5, [r10, r12, ASL #2]
 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-done-",0
 ]

        ; All done
        B       SetVarVal_TestVExit

SetVarVal_DeleteIt
        BL      VarFindIt

        ; Error if not found
        ADREQL  r0, ErrorBlock_VarCantFind ; V set no. 1)
        BEQ     SetVarValBadExit_Translate
        ; Check if found vartype code that the supplied vartype was code too
        LDRB    lr, [r4]
        TEQ     lr, #VarType_Code
        BNE     %FT80

        TEQ     r10, #VarType_Code
        BNE     SetVarVal_TestVExit
80
        LDR     r11, =ZeroPage+VariableList
        LDR     r10, [r11]
  [ SysVars_QuickContext
        ADD     r10,r10,#SysVars_VTableOffset
  ]
        LDR     r4, [r10]
        ADD     r0, r10, r12, ASL #2    ; rover
        ADD     r1, r10, r4, ASL #2     ; end
        B       SetVarVal_DoRemoveEnd
SetVarVal_DoRemoveStart
        LDR     lr, [r0, #4]!
        STR     lr, [r0, #-4]
SetVarVal_DoRemoveEnd
        CMP     r0, r1
        BLO     SetVarVal_DoRemoveStart
        MOV     r2, r3
  [ SysVars_StickyNodes
        BL      SysVars_FreeVNode
  |
        BL      FreeSysHeapNode
  ]

        ; Reduce number of nodes
        SUB     r4, r4, #1
        STR     r4, [r10]

        ; Construct best guess context ptr to be prev node (if present)
        TEQ     r12, #1
        SUBHI   r12, r12, #1
        LDRHI   r3, [r10, r12, ASL #2]
        MOVLS   r3, #0


SetVarVal_TestVExit
        MOV     stack, r9
        STRVS   r0, [stack]
        PullEnv
        B       SLVK_TestV

SetVarValBadExit_Translate
 [ International
        BL      TranslateError
 ]
SetVarValBadExit_NoTranslate
        SETV
        B       SetVarVal_TestVExit

SetVarVal_DisasterExpandingString
SetVarVal_NoRoomForIndex
        MOV     r2, r5
        BL      FreeSysHeapNode         ;forget stickiness (return node to heap is best here)
SetVarVal_VarNoRoom
        ADR     r0, ErrorBlock_VarNoRoom
        B       SetVarValBadExit_Translate

SetVarVal_DisasterExpandingBadString
        Push    "r0"                    ; Save bad string error
        MOV     r2, r5
        BL      FreeSysHeapNode         ;forget stickiness (return node to heap is best here)
        Pull    "r0"
        SETV
        B       SetVarVal_TestVExit

        MakeErrorBlock BadVarType
        MakeErrorBlock BadVarNam
        MakeErrorBlock VarTooLong
        MakeErrorBlock BadMacVal
        MakeErrorBlock VarNoRoom


; *****************************************************************************
; Utility routines.

; -----------------------------------------------------------------------------
;
; VarFindIt
;
; In
;    r0 -> (wildcard) name of variable to find
;    r3 = context pointer
;
; Out
;    r3 = name pointer
;    r4 = pointer after name terminator
;    r12 = insertion point (1st node >= this node)
;    NE if found, EQ if not found
;
VarFindIt Entry "r0,r1,r2,r5,r6,r7,r8,r9,r10,r11"

; validate R3 by looking down the list to see if we find it.
; Crude, but effective!

 [ DebugSysVars
        SWI     XOS_WriteS
        =       "VarFindIt(",0
        BL      SysVar_Write0
 ]

        LDR     r9, =ZeroPage+VariableList
        LDR     r9, [r9]
        TEQ     r9, #0
  [ SysVars_QuickContext
        LDRNE   r12,[r9,#SysVars_LastContext]
        MOVEQ   r12,#-1                           ;r12 = var table index for last context, or -1 if notvalid/notthere
        ADDNE   r9,r9,#SysVars_VTableOffset
  ]
        LDRNE   r8, [r9]
        MOVEQ   r8, #0
        TEQ     r3, #0
        BEQ     %FT20

 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-scan-",0
 ]
        ; r3 non-zero - scan list for entry

  [ SysVars_QuickContext
        ;massive short cut - see if context is the last context we returned
        CMP     r12, r8                 ;if not valid, or higher than current number of vars, forget it
        BHI     %FT04
        LDR     lr, [r9, r12, ASL #2]
        CMP     lr, r3
        BEQ     %FT70
04
        ;no such luck - scan list anyway
  ]

        ADD     r12, r8, #1
        B       %FT10
05
        LDR     lr, [r9, r12, ASL #2]
        CMP     lr, r3
        BEQ     %FT70                   ; continue scan down list
10
        SUBS    r12, r12, #1
        BHI     %BT05

20
 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-wildcheck-",0
 ]
        ; not found in scan - check for name being wildcarded

        MOV     r10, r0
25
        LDRB    lr, [r10], #1
        TEQ     lr, #"*"
        TEQNE   lr, #"#"
        BEQ     %FT65
        CMP     lr, #" "
        BHI     %BT25

 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-bchop-",0
 ]

        ; Name not wildcarded - do binary chop search
        ORRS    r7, r8, r8, LSR #1
        ORR     r7, r7, r7, LSR #2
        ORR     r7, r7, r7, LSR #4
        ORR     r7, r7, r7, LSR #8
        ORR     r7, r7, r7, LSR #16
        BICS    r7, r7, r7, LSR #1      ; least 2^n <= number of entries
        MOV     r6, #0

        B       %FT60
40
        ADD     r5, r6, r7
        CMP     r5, r8
        BHI     %FT55

        MOV     r1, r0
        LDR     r4, [r9, r5, ASL #2]

45
        LDRB    r2, [r1], #1
        CMP     r2, #" "
        MOVLS   r2, #0
        LDRB    r3, [r4], #1
        CMP     r3, #" "
        MOVLS   r3, #0
        UpperCase R2,LR
        UpperCase R3,LR
        CMP     r3, r2
        BNE     %FT50
        CMP     r3, #0
        BNE     %BT45

50
        MRSHS   r10, CPSR               ; preserve last HS result we got
        MOVHS   r11, r4
        MOVLO   r6, r5
55
        MOVS    r7, r7, LSR #1
60
        BNE     %BT40

        ; We always want the element above.
        ; If r6<r8 then we want the preserved result
        ; else we want the result HI
        ADD     r6, r6, #1
        CMP     r6, r8
        LDRLS   r3, [r9, r6, ASL #2]
  [ SysVars_QuickContext
        ASSERT  SysVars_LastContext = SysVars_VTableOffset - 4
        STRLS   r6, [r9, #-4]           ;save var table index for context we're returning, in LastContext
  ]
        MOVLS   r4, r11
        MOVHI   r3, #0
        MSRLS   CPSR_f, r10

 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-complete-",0
        SWI     XOS_NewLine
 ]
        MOV     r12, r6
        TOGPSR  Z_bit, lr
        EXIT

65
 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-listscan-",0
        SWI     XOS_NewLine
 ]
        ; Scan down list looking for wildmatch
        MOV     r12, #0
70
        ADD     r12, r12, #1
        CMP     r12, r8
        BHI     %FT90                   ; end of list reached
        LDR     r4, [r9, r12, ASL #2]
        BL      WildMatch               ; trashes r10,r11
        BNE     %BT70

80
 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-complete-",0
        SWI     XOS_NewLine
 ]
        ; Found
        ; r4->name end
        ; r12 = entry number
        LDR     r3, [r9, r12, ASL #2]
  [ SysVars_QuickContext
        ASSERT  SysVars_LastContext = SysVars_VTableOffset - 4
        STR     r12, [r9, #-4]          ;save var table index for context we're returning, in LastContext
  ]
        MOVS    r12, r12                ; set NE
        EXIT

90
        ; Not found
 [ DebugSysVars
        SWI     XOS_WriteS
        =       "-not found-",0
        SWI     XOS_NewLine
 ]
        MOV     r12, #1
        MOVS    r3, #0
        EXIT

WildMatch ROUT
; In  : R0 is wildcard spec ptr, R4 is name ptr.
;       Wild Terminators are any ch <=" ", name terminator 0
;       Wildcards are *, #
; Out : EQ/NE for match (EQ if matches)
;       R4 points after name terminator for found
;       R0 preserved, R10, 11 corrupted

        Push    "R0-R3"
        MOV     R11, #0                 ; this is the wild backtrack pointer
        MOV     R3, #0                  ; and this is the name backtrack ptr.
01      LDRB    R1, [R0], #1            ; nextwild
        CMP     R1, #"*"
        BEQ     %FT02                   ; IF nextwild = "*"
        LDRB    R2, [R4], #1            ; nextname
        CMP     R2, #0
        BEQ     %FT03
        UpperCase R1, R10
        UpperCase R2, R10
        CMP     R1, R2                  ; IF nextwild=nextname
        CMPNE   R1, #"#"                ;   OR nextwild = #  (terminator checked already)
        BEQ     %BT01                   ; THEN LOOP (stepped already)
        MOV     R0, R11                 ; try backtrack
        MOVS    R4, R3                  ; if * had at all
        BNE     %FT02
        CMP     PC, #0                  ; set NE
04      Pull    "R0-R3"                 ; return NE (failed)
        MOV     PC, lr

03      CMP     R1, #" "                ; name terminated : has wildcard?
        BHI     %BA04                   ; note HI has NE set.
        CMP     R1, R1                  ; set EQ
        Pull    "R0-R3"
        MOV     PC, lr

02      MOV     R11, R0                 ; wild backtrack ptr is char after *
        LDRB    R1, [R0], #1            ; step wild
        CMP     R1, #"*"
        BEQ     %BT02                   ; fujj **
        UpperCase R1, R10
05      LDRB    R2, [R4], #1            ; step name
        CMP     R2, #0                  ; terminator?
        BEQ     %BT03
        UpperCase R2, R10
        CMP     R1, R2
        CMPNE   R1, #"#"                ; match if #
        BNE     %BT05
        MOV     R3, R4                  ; name backtrack ptr is char after match
        B       %BT01                   ; LOOP


  [ Oscli_QuickAliases

;routines to speed up alias checking for OS_CLI

;VarFindIt_QA - similar to VarFindIt
;
; In
;    r3 -> non-wildcarded, already upper-cased name of var to find
;          will be of form ALIAS$<whatever>
;
; Out
;    r5 = name pointer (equivalent to r3 for VarFindIt
;    r6 = pointer after name terminator (equivalent to r4 for VarFindIt)
;    r7 = insertion point (equivalent to r12 for VarFindIt)
;    NE if found, EQ if not found
;
VarFindIt_QA ROUT
        Push    "r0,r1,r2,r3,r4,r8,r9,r10,r11,LR"
        MOV     r0, r3
        LDR     r9, =ZeroPage+VariableList
        LDR     r9, [r9]
        TEQ     r9,#0
        BEQ     %FT99                   ;exit with EQ (not found)
  [ SysVars_QuickContext
        ADD     r9,r9,#SysVars_VTableOffset
  ]
        LDR     r8, [r9]

        ; do binary chop search
        ORRS    r7, r8, r8, LSR #1
        ORR     r7, r7, r7, LSR #2
        ORR     r7, r7, r7, LSR #4
        ORR     r7, r7, r7, LSR #8
        ORR     r7, r7, r7, LSR #16
        BICS    r7, r7, r7, LSR #1      ; least 2^n <= number of entries
        MOV     r6, #0

        B       %FT60
40
        ADD     r5, r6, r7
        CMP     r5, r8
        BHI     %FT55

        MOV     r1, r0
        LDR     r4, [r9, r5, ASL #2]

45
        LDRB    r2, [r1], #1
        CMP     r2, #" "
        MOVLS   r2, #0
        LDRB    r3, [r4], #1
        CMP     r3, #" "
        MOVLS   r3, #0
        UpperCase R3,LR
        CMP     r3, r2
        BNE     %FT50
        CMP     r3, #0
        BNE     %BT45

50
        MRSHS   r10, CPSR               ; preserve last HS result we got
        MOVHS   r11, r4
        MOVLO   r6, r5
55
        MOVS    r7, r7, LSR #1
60
        BNE     %BT40

        ; We always want the element above.
        ; If r6<r8 then we want the preserved result
        ; else we want the result HI
        ADD     r6, r6, #1
        CMP     r6, r8
        LDRLS   r5, [r9, r6, ASL #2]

        ; don't want to save context in this version of routine

        MOV     r7, r6
        MOVLS   r6, r11
        MOVHI   r5, #0
        MSRLS   CPSR_f, r10

        TOGPSR  Z_bit, lr
99
        Pull    "r0,r1,r2,r3,r4,r8,r9,r10,r11,PC"


  ] ;Oscli_QuickAliases

  [ SysVars_StickyNodes
;
; SysVars_ClaimVNode
;
; entry: R3 = size required
; exit:  R2 = address of allocated node, or V set for error
;
; if R3  > max sticky size, just delegates to ClaimSysHeapNode
; if R3 <= max sticky size, rounds up to next unit size, and attempts to pick
;    up sticky node of that size - if not found, gets one from heap (now of size that can
;    stick on free)
;
SysVars_ClaimVNode ROUT
        Push    "r0,r1,r3,LR"
        CMP     r3,#SysVars_StickyNode_MaxSize
        BHI     %FT80                                         ;too big for sticky node
        ADD     r3,r3,#SysVars_StickyNode_UnitSize-1
        BIC     r3,r3,#SysVars_StickyNode_UnitSize-1          ;round up to unit size
        LDR     r1,=ZeroPage+SysVars_StickyPointers
        LDR     r2,[r1,r3,LSR #(SysVars_StickyNode_Log2US-2)] ;sticky pointer for this size
        CMP     r2,#0                                         ;also clears V
        BEQ     %FT80
        MOV     LR,#0
        STR     LR,[r1,r3,LSR #(SysVars_StickyNode_Log2US-2)] ;used it
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        LDR     r0,=ZeroPage
        LDR     r1,[r0,#mjsSHNT_vcs_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_vcs_total]
        Pull    "r0-r2"
  ]
        Pull    "r0,r1,r3,PC"
80      BL      ClaimSysHeapNode
        STRVS   r0,[SP]
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        LDR     r0,=ZeroPage
        LDR     r1,[r0,#mjsSHNT_vch_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_vch_total]
        Pull    "r0-r2"
  ]
        Pull    "r0,r1,r3,PC"

;
; SysVars_FreeVNode
;
; entry: R2 = address of node to free (must be valid)
; exit:  -
;        OR V set, error
;
; - checks size of node (uses internal knowledge of Heap blocks - naughty!)
; - if size is a sticky size, and the corresponding sticky pointer is 0, retains it,
;   else delegates to FreeSysHeapNode
;
SysVars_FreeVNode
        Push    "r0,r1,r3,LR"
        LDR     r1,[r2,#-4]                                   ;pick up OS_Heap's size word
        SUB     r1,r1,#8                                      ;sticky sizes will be 8 less than heap sizes
        CMP     r1,#SysVars_StickyNode_MaxSize                ;is it too big?
        BHI     %FT80
        TST     r1,#SysVars_StickyNode_UnitSize-1             ;is it a multiple of unit size
        BNE     %FT80
        LDR     r3,=ZeroPage+SysVars_StickyPointers
        LDR     LR,[r3,r1,LSR #(SysVars_StickyNode_Log2US-2)] ;sticky pointer for this size
        CMP     LR,#0
        STREQ   r2,[r3,r1,LSR #(SysVars_StickyNode_Log2US-2)] ;stick!
80
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        LDR     r0,=ZeroPage
        LDREQ   r1,[r0,#mjsSHNT_vfs_total]
        LDRNE   r1,[r0,#mjsSHNT_vfh_total]
        ADD     r1,r1,#1
        STREQ   r1,[r0,#mjsSHNT_vfs_total]
        STRNE   r1,[r0,#mjsSHNT_vfh_total]
        Pull    "r0-r2"
  ]
        BLNE    FreeSysHeapNode
        STRVS   r0,[SP]
        Pull    "r0,r1,r3,PC"

;
; SysVars_ExpandOrShrinkVNode
;
; entry: R2 = address of block
;        R3 = change of size required in bytes (signed integer)
; exit:  R2 = address of block, which may have changed (block moved/copied)
;        OR V set, error returned
;
; - checks size of node (uses internal knowledge of Heap blocks - naughty!)
; - assumes all VNodes currently less than MaxSize and of sticky size *must* be stickily
;   allocated nodes (so that maximum current size that could be presumed by client is heap
;   size minus 8, rather than minus 4)
; - if new size is small enough to be a sticky node, attempts to return a sticky node,
;   without doing an OS_Heap grow or shrink, else delegates to DoSysHeapOpWithExtension
;
SysVars_ExpandOrShrinkVNode
        Push    "r0,r1,r3-r6,LR"
        LDR     r5,[r2,#-4]                                   ;pick up OS_Heap's size word
        SUB     r5,r5,#4                                      ;usable sizes are 4 less than heap sizes
        ADD     r4,r5,r3                                      ;putative new size
        CMP     r4,#SysVars_StickyNode_MaxSize                ;is it too big?
        BHI     %FT90
        SUB     r6,r5,#4                                      ;sticky sizes will be 8 less than heap sizes
        SUB     r4,r4,#4
        ADD     r4,r4,#SysVars_StickyNode_UnitSize-1
        BIC     r4,r4,#SysVars_StickyNode_UnitSize-1          ;round up to unit size
        CMP     r4,r6                                         ;same as current size?
        BEQ     %FT55
        LDR     r1,=ZeroPage+SysVars_StickyPointers
        LDR     LR,[r1,r4,LSR #(SysVars_StickyNode_Log2US-2)] ;sticky pointer for this size
        CMP     LR,#0
        BEQ     %FT40
        MOV     r3,#0
        STR     r3,[r1,r4,LSR #(SysVars_StickyNode_Log2US-2)] ;used it
        MOV     r5,r2
        MOV     r2,LR
        B       %FT50
40
        MOV     r5,r2
        MOV     r3,r4
        BL      SysVars_ClaimVNode
        BVS     %FT95
50      ;copy min(r6,r4) bytes (multiple of 8) from old node at r5 to new node at r2
        CMP     r4,r6
        MOVLO   r6,r4
        MOV     r3,r2
        MOV     LR,r5
52
        LDMIA   LR!,{r0,r1}
        STMIA   r3!,{r0,r1}
        SUBS    r6,r6,#8
        BGT     %BT52
        MOV     r6,r2
        MOV     r2,r5
        BL      SysVars_FreeVNode
        MOV     r2,r6
        BVS     %FT95
55
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        LDR     r0,=ZeroPage
        LDR     r1,[r0,#mjsSHNT_vxs_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_vxs_total]
        Pull    "r0-r2"
  ]
        CLRV
        Pull    "r0,r1,r3-r6,PC"
90
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        LDR     r0,=ZeroPage
        LDR     r1,[r0,#mjsSHNT_vxh_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_vxh_total]
        Pull    "r0-r2"
  ]
        MOV     r0,#HeapReason_ExtendBlock
        BL      DoSysHeapOpWithExtension
95
        STRVS   r0,[SP]
        Pull    "r0,r1,r3-r6,PC"

  ] ;SysVars_StickyNodes

        LTORG

        END
@


4.8
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d1403 1
a1403 1
        MOV     r1,r4
@


4.7
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a241 1
 [ GSWorkspaceInKernelBuffers
a242 4
 |
        GSVarGetWSpace
        ADD     R12, R12, #GSNameBuff
 ]
a299 1
 [ GSWorkspaceInKernelBuffers
a300 4
 |
        GSVarGetWSpace
        ADD     R12, R12, #GSNameBuff
 ]
a327 1
 [ GSWorkspaceInKernelBuffers
a329 4
 |
        GSVarGetWSpace
        ADD     R2, R12, #GSNameBuff+1  ; This code copied from OsWord0EAlpha
 ]
a339 1
 [ GSWorkspaceInKernelBuffers
a340 3
 |
        MOV     R3, #?GSNameBuff-1
 ]
a391 1
 [ GSWorkspaceInKernelBuffers
a393 4
 |
        GSVarGetWSpace
        ADD     R1, R12, #GSNameBuff
 ]
a413 1
 [ GSWorkspaceInKernelBuffers
a414 3
 |
        LDR     R12, =GSNameBuff+GSVarWSpace
 ]
a420 1
 [ GSWorkspaceInKernelBuffers
a421 3
 |
        LDR     R1, =GSNameBuff+GSVarWSpace
 ]
a1163 1
  [ LongCommandLines
a1169 4
  |
        SUB     stack, stack, #256
        MOV     r2, #256
  ]
a1241 1
  [ LongCommandLines
a1247 4
  |
        SUB     stack, stack, #256
        MOV     r2, #256
  ]
@


4.6
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d21 1
a21 1
$l      LDR R12, =GSVarWSpace
a73 1
;   OS_BinaryToDecimal
d75 1
a75 1
; structures and OS_BinaryToDecimal is used by readvarval.
d122 1
a122 1
        Push  "lr"
d125 3
a127 3
        MOV    R0, #0
        LDR    R12, =VariableList
        STR    R0, [R12]
d130 15
a144 15
        ADR    R0, SystemVarList       ; R0 pointer to name
01      MOV    R1, R0
        LDRB   R2, [R1], #1
        CMP    R2, #0
        Pull  "PC", EQ
02      LDRB   R3, [R1], #1
        CMP    R3, #0
        BNE    %BT02
        LDRB   R4, [R1], #1            ; get type
        ADD    R1, R1, #3
        BIC    R1, R1, #3
        LDR    R2, [R1], #4
        SWI    XOS_SetVarVal
        ADD    R0, R1, R2
        B      %BT01
d157 1
a157 1
        =     "Sys$$Time", 0, VarType_Code
d159 3
a161 3
        &      sv2-.-4
        LDR    PC, %FT01
        LDR    PC, %FT02
d163 1
a163 1
        &    SetTimeVar
d165 1
a165 1
        &    ReadTimeVar
d167 1
a167 1
sv2     =     "Sys$$Year", 0, VarType_Code
d169 3
a171 3
        &      sv3-.-4
        LDR    PC, %FT03
        LDR    PC, %FT04
d173 1
a173 1
        &    SetYear
d175 1
a175 1
        &    ReadYear
d177 1
a177 1
sv3     =     "Sys$$Date", 0, VarType_Code
d179 3
a181 3
        &      sv4-.-4
        LDR    PC, %FT05
        LDR    PC, %FT06
d183 1
a183 1
        &    SetDate
d185 1
a185 1
        &    ReadDate
d187 1
a187 1
sv4     =     "Sys$$ReturnCode", 0, VarType_Code
d189 3
a191 3
        &      sv5-.-4
        LDR    PC, %FT07
        LDR    PC, %FT08
d193 1
a193 1
        &    SetRC
d195 1
a195 1
        &    ReadRC
d197 1
a197 1
sv5     =     "Sys$$RCLimit", 0, VarType_Code
d199 3
a201 3
        &      sv6-.-4
        LDR    PC, %FT09
        LDR    PC, %FT10
d203 1
a203 1
        &    SetRCL
d205 1
a205 1
        &    ReadRCL
d207 1
a207 1
sv6     =     "Alias$.", 0, VarType_String
d209 2
a210 2
        &      sv7-.-4
        =     "Cat ", 10
d212 1
a212 1
sv7     =     "Sys$$DateFormat", 0, VarType_String
d214 1
a214 1
        &      sv8-.-4
d217 1
a217 1
        =     "%24:%mi:%se %dy-%m3-%ce%yr", 10
d219 1
a219 1
        =     "%w3,%dy %m3 %ce%yr.%24:%mi:%se", 10
d222 1
a222 1
sv8     =      0
d225 1
a225 1
        =     "%24:%mi:%se", 0
d227 1
a227 1
        =     "%w3,%dy %m3", 0
d229 1
a229 1
        =     "%ce%yr", 0
d236 2
a237 2
        ADR    R0, SysTimeFormat
        B      ReadTimeFormatted
d239 6
a244 3
        CMP    R2, #&FE
        BHI    TimeVarTooLong
        Push  "R0, lr"
d246 16
a261 15
        ADD    R12, R12, #GSNameBuff
        MOV    R11, #8
        STRB   R11, [R12], #1
        MOV    R10, #0
        STRB   R10, [R12, R2]
        MOV    R10, R2
01      SUBS   R10, R10, #1
        LDRPLB R11, [R1, R10]
        STRPLB R11, [R12, R10]
        BPL    %BT01
        SUB    R1, R12, #1
        MOV    R0, #15
        SWI    XOS_Word
        STRVS  R0, [R13]
        Pull  "R0, PC"
d264 1
a264 1
        ADRL   R0, ErrorBlock_VarTooLong
d266 1
a266 1
        B      TranslateError
d272 2
a273 2
        ADR    R0, SysYearFormat
        B      ReadTimeFormatted
d275 22
a296 22
        CMP    R2, #4
        BHI    TimeVarTooLong
        Push  "R0, lr"
        Push  "R1,R2"
        ADR    R0, SetYearPrefixFormat
        BL     ReadTimeFormatted
        ADD    R12, R0, R2              ; R12 -> position to copy year to
        Pull  "R1,R2"
        BVS    %FT02
        MOV    R10, #0
        STRB   R10, [R12, R2]
        MOV    R10, R2
01      SUBS   R10, R10, #1
        LDRPLB R11, [R1, R10]
        STRPLB R11, [R12, R10]
        BPL    %BT01
        SUB    R1, R0, #1
        MOV    R0, #15
        STRB   R0, [R1]
        SWI    XOS_Word
02      STRVS  R0, [R13]
        Pull  "R0, PC"
d299 2
a300 2
        ADR    R0, SysDateFormat
        B      ReadTimeFormatted
d302 6
a307 3
        CMP    R2, #&F8
        BHI    TimeVarTooLong
        Push  "R0, lr"
d309 21
a329 20
        ADD    R12, R12, #GSNameBuff
        MOV    R11, #15
        STRB   R11, [R12], #1
        MOV    R10, #0
        STRB   R10, [R12, R2]
        MOV    R10, R2
01      SUBS   R10, R10, #1
        LDRPLB R11, [R1, R10]
        STRPLB R11, [R12, R10]
        BPL    %BT01
        ADD    R1, R12, R2
        ADR    R0, SetDateSuffixFormat          ; append year to supplied date
        Push  "R12"
        BL     ReadTimeFormattedAtR1
        Pull  "R12"
        SUB    R1, R12, #1
        MOV    R0, #15
        SWI    XOS_Word
        STRVS  R0, [R13]
        Pull  "R0, PC"
d337 5
a341 1
        Push  "R3,R4,LR"
d343 21
a363 16
        ADD    R2, R12, #GSNameBuff+1   ; This code copied from OsWord0EAlpha
01      MOV    R4, R0
        SUB    R13, R13, #8
        MOV    R1, R13
        MOV    R0, #3
        STRB   R0, [R1]
        MOV    R0, #14
        SWI    XOS_Word
        BVS    %FT02
        MOV    R0, #-1
        MOV    R1, R13
        MOV    R3, #?GSNameBuff-1
        SWI    XTerritory_ConvertDateAndTime
02      ADD    R13, R13, #8
        SUBVC  R2, R1, R0
        Pull  "R3,R4,PC"
d371 3
a373 3
        Push  "R3,R4,LR"
        MOV    R2, R1
        B      %BT01
d376 15
a390 15
        MOV    R0, #0
        LDR    R0, [R0, #ReturnCode]
        B      ReadNumSysVar
SetRC   Push  "lr"
        BL     SetNumSysVar
        LDR    R4, =ReturnCode
        STR    R2, [R4]
        LDR    R4, =RCLimit
        LDR    R4, [R4]
        CMP    R2, R4
        BHI    %FT03
        CLRV
        Pull  "PC"
03      ADRGT  R0, ErrorBlock_RCExc
        ADRLT  R0, ErrorBlock_RCNegative
d392 1
a392 1
        BL     TranslateError
d397 1
a397 1
        Pull  "PC"
d399 1
a399 1
        =     "%w3,%dy %m3 ", 0
d401 1
a401 1
        =     " %ce%yr", 0
d407 2
a408 2
ReadRCL MOV    R0, #0
        LDR    R0, [R0, #RCLimit]
d410 5
a414 1
        Push  "lr"
d416 14
a429 13
        ADD    R1, R12, #GSNameBuff
        MOV    R2, #256
        SWI    XOS_BinaryToDecimal
        MOV    R0, R1
        Pull  "PC"
SetRCL  Push  "lr"
        BL     SetNumSysVar
        LDR    R4, =RCLimit
        CMP    R2, #0              ; can't set -ve RCLimit
        RSBMIS R2, R2, #0
        MOVMI  R2, #0              ; BIC of MININT
        STR    R2, [R4]
        Pull  "PC"
d433 32
a464 24
SetNumSysVar   ROUT ; R1 ptr to string, R2 string length
        Push  "lr"
        SUBS   R2, R2, #1
        ADDMI  R2, R2, #1     ; give 0 in R2 for bad length.
        Pull  "PC", MI
        LDR    R12, =GSNameBuff+GSVarWSpace
03      LDRB   R10, [R1], #1        ; copy into a buffer so we can terminate it.
        STRB   R10, [R12], #1
        SUBS   R2, R2, #1
        BPL    %BT03
        MOV    R10, #13
        STRB   R10, [R12], #1
        LDR    R1, =GSNameBuff+GSVarWSpace
        LDRB   R10, [R1]
        MOV    R12, #0
        CMP    R10, #"-"
        MOVEQ  R12, #-1
        CMPNE  R10, #"+"
        ADDEQ  R1, R1, #1
        MOV    R0, #0
        SWI    XOS_ReadUnsigned
        CMP    R12, #0
        RSBMI  R2, R2, #0
        Pull  "PC"
d516 1
a516 1
                                      ; get caller's flags
d545 1
a545 1
        STRB    R1, [R12, #GS_StackPtr]     ; no stacked R0s
d552 1
a552 1
                                      ; get caller's flags
d561 2
a562 2
        SUBNE   R0, R0, #1            ; dec if went too far
        ORREQ   R2, R2, #GS_In_String ; set flag if in string
d566 1
a566 1
        ORREQ   lr, lr, #Z_bit    ; and move EQ/NE to return pc
d570 2
d615 2
a622 5
        CMP     R11, #255
        CMPNE   R1, #13
        CMPNE   R1, #10
        CMPNE   R1, #0
        BEQ     GSREAD_AngleBraDaftSoIsnt
d624 4
d629 1
d631 1
d637 1
d652 2
a653 2
        MOV     R3, #0                 ; context ptr
        SUB     R0, R12, R11           ; name ptr
d655 1
a655 1
        Pull    "R0, R3, R4, R10", EQ    ; not found mate
d680 1
a680 1
        LDRB    R1, [R0], #1          ; type
d705 1
a705 1
        ADD     stack, stack, #4      ; discard that R0
d709 1
a709 1
        ORR     R2, R2, R1            ; old flags+new count
d720 1
a720 1
        B       GSREAD_XPandGetNextByte   ; loop, transforming chars.
d725 1
a725 1
        ADD     stack, stack, #4       ; skip R0 - return null string
d727 1
a727 1
        B       GSREAD_XPandGetNextByte   ; get next char
d735 2
a736 2
        TST     R2, #GS_In_String      ; got CR or LF
        BNE     GSREAD_BadStringError  ; bad string
d758 1
a758 1
        B       GSREAD_XPandGetNextByte    ; return to prevstring
d763 1
a763 1
        BEQ     GSREAD_GotToAnEnd      ; terminates
d792 1
a792 1
        BEQ     GSREAD_ReturnWithChar  ; || gives |, |" gives ", |< gives <
d794 2
a795 2
        MOVEQ   R1, #&7F              ; delete
        BEQ     GSREAD_ReturnWithChar ; valid ch
d801 4
a804 4
        CMP     R1, #&7F              ; CTRL-delete is delete
        EORGT   R1, R1, #&20           ; softkey
        BGE     GSREAD_ReturnWithChar ; now valid ch
        CMP     R1, #"`"              ; CTRL-` = CTRL-_
d807 1
a807 1
        ANDGE   R1, R1, #&1F           ; transform if @@<=ch<delete
d811 1
a811 1
        SUB     R2, R2, #1            ; we're reading a string
d817 2
a818 2
        LDRNEB  R1, [R0], #1          ; and this is already expanded
        ExitSWIHandler NE          ; so finished
d846 3
a848 3
        ADD     R0, R0, #3 + 4  ; 3 to ALIGN, 4 to get to read entry
        MOV     lr, PC          ; get link
        BIC     PC, R0, #3      ; call entrypoint to Read Thunk
d866 1
a866 1
        BIC      lr, lr, #C_bit
d868 1
a868 1
        WritePSRc SVC_mode, R3             ; enable ints.
d870 14
a883 14
        MOV      R3, R1
        MOV      R4, R1                    ; two copies of start ptr
        BIC      R5, R2, #&E0000000
        ADD      R5, R5, R1                 ; 1st byte we can't write to.
        SWI      XOS_GSInit
01      CMP      R3, R5
        BGE      %FT03                    ; no rheum for byte.
        SWI      XOS_GSRead
        BVS      %FT02                    ; bad string
        STRB     R1, [R3], #1
        BCC      %BT01
04      SUB      R2, R3, R4                 ; no chars got
        SUB      R2, R2, #1
        Pull    "R1, R3-R5, lr"
d886 2
a887 2
02      SUB      R2, R3, R4
        Pull    "R1, R3-R5, lr"
d890 1
a890 1
03      SUB      R2, R3, R4
d892 1
a892 1
        ORR      lr, lr, #C_bit          ; buffer overflow
d938 1
a938 1
        WritePSRc SVC_mode, r11 ; enable interupts (mode remains unchanged)
d953 1
a953 1
        BL      VarFindIt       ; name=r0,context=r3 -> name found in node=r3,r4=after namein,r12=prev
d1003 1
a1003 1
        MOV     R2, R10           ; bytes he's gonna get
d1062 3
a1064 3
        CMP     r2, #0          ; if negative, then don't call GSTrans because bits 29..31 have
        MVNMI   r10, r2         ; return r2 out by this method
        BMI     ReadVarVal_BufWillOFlow  ; a special meaning - just branch back to the normal overflow code
d1080 1
a1080 1
        LDRB    R0, [R11], #1       ; number - convert to string.
a1115 76
;***************************************************************************

; The convert number to string SWI
; In  : R0 signed 32-bit integer
;       R1 pointer to buffer
;       R2 max buffer length
; Out : R0, R1 unmodified
;       R2 actual chars given
;       V Set if buffer overflow

; Format : - if negative, leading zeros stripped.

CvtToDecimal ROUT
        Push    "R0, R3-R5"
        MOV     R12, R2
        MOV     R2, #0
        CMP     R0, #0
        BPL     %FT01
        SUBS    R12, R12, #1
        BMI     %FT10
        MOV     R11, #"-"
        STRB    R11, [R1]
        MOV     R2, #1
        RSB     R0, R0, #0

; now do digits.

01      RSB     R0, R0, #0          ; get negative so minint works.
        ADR     R3, TenTimesTable
        MOV     R10, #9            ; max entry
        MOV     R4, #0             ; non-0 had flag
02      LDR     R11, [R3, R10, LSL #2]
        MOV     R5, #-1            ; digit value
03      ADDS    R0, R0, R11
        ADD     R5, R5, #1
        BLE     %BT03
        SUB     R0, R0, R11
        CMP     R5, #0
        CMPEQ   R4, #0
        BNE     %FT04             ; put digit
05      SUBS    R10, R10, #1
        BPL     %BT02             ; next digit
        CMP     R4, #0
        BEQ     %FT04             ; R5 must be 0
        Pull    "R0, R3-R5"
        ExitSWIHandler

04      SUBS    R12, R12, #1
        BMI     %FT10             ; naff Exit
        ADD     R5, R5, #"0"
        MOV     R4, #-1
        STRB    R5, [R1, R2]
        ADD     R2, R2, #1
        B       %BT05
10
        ADR     R0, BufferOFloError
    [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
    ]
        Pull    "R3"              ; discard R0 in
        Pull    "R3-R5"
        B       SLVK_SetV

TenTimesTable
      &        1
      &        10
      &        100
      &        1000
      &        10000
      &        100000
      &        1000000
      &        10000000
      &        100000000
      &        1000000000
d1196 8
d1206 1
d1248 1
a1248 1
        MOV     r0, r3          ; If already there use that's name in case supplied name wildcarded
d1261 1
a1261 1
        SUB     stack, stack, #256   ;buffer
d1279 8
d1289 1
d1401 1
a1401 1
        ADD     sp,sp,#12                      ; balances push r0-r2 above - value length (entry r2) now in r1
d1415 1
d1421 1
a1421 1
        SUBEQ   r1, r1, #1                      ; ghastly fudge to avoid display of terminator
d1428 1
a1428 1
        ADDEQ   r1, r1, #1                      ; undo ghastly fudge
a1429 1
SetVarVal_CopyR1BytesToR4
d1435 1
d1439 9
d1478 1
a1478 1
        MOV     r3, #64     ;should be a multiple of StickyNode_UnitSize if SysVars_StickyNodes TRUE
d1563 1
a1563 1
        LDR     r11, =VariableList
d1604 1
a1604 1
        MOV     r3, #(10*4)+4                      ; 10 nodes and 1 word for the count
d1606 1
a1606 1
        BL      ClaimSysHeapNode                   ; this is not a variable node (its the index)
d1626 2
a1627 2
        LDR     lr, [r10, #-4]                        ; Block length, from heap block
        SUB     lr, lr, #4+4                          ; 4 for heap adjustment and 4 for entry count word
d1643 1
a1643 1
        MOV     r3, #40                         ; room for 10 more nodes
d1645 1
a1645 1
        BL      DoSysHeapOpWithExtension   ;not a variable node (expanding index)
d1703 1
a1703 1
        LDR     r11, =VariableList
d1801 1
a1801 1
        LDR     r9, =VariableList
d1822 1
a1822 1
        CMP     r12, r8               ;if not valid, or higher than current number of vars, forget it
d1895 1
a1895 1
        mrs     HS, r10, CPSR           ; preserve last HS result we got
d1911 1
a1911 1
        STRLS   r6, [r9, #-4]            ;save var table index for context we're returning, in LastContext
d1915 1
a1915 1
        msr     LS, CPSR_f, r10
d1979 3
a1981 3
        MOV     R11, #0         ; this is the wild backtrack pointer
        MOV     R3, #0          ; and this is the name backtrack ptr.
01      LDRB    R1, [R0], #1    ; nextwild
d1983 2
a1984 2
        BEQ     %FT02           ; IF nextwild = "*"
        LDRB    R2, [R4], #1    ; nextname
d1989 5
a1993 5
        CMP     R1, R2          ; IF nextwild=nextname
        CMPNE   R1, #"#"        ;   OR nextwild = #  (terminator checked already)
        BEQ     %BT01           ; THEN LOOP (stepped already)
        MOV     R0, R11         ; try backtrack
        MOVS    R4, R3          ; if * had at all
d1995 2
a1996 2
        CMP     PC, #0          ; set NE
04      Pull    "R0-R3"         ; return NE (failed)
d1999 3
a2001 3
03      CMP     R1, #" "        ; name terminated : has wildcard?
        BHI     %BA04           ; note HI has NE set.
        CMP     R1, R1          ; set EQ
d2005 2
a2006 2
02      MOV     R11, R0         ; wild backtrack ptr is char after *
        LDRB    R1, [R0], #1    ; step wild
d2008 1
a2008 1
        BEQ     %BT02           ; fujj **
d2010 2
a2011 2
05      LDRB    R2, [R4], #1    ; step name
        CMP     R2, #0          ; terminator?
d2015 1
a2015 1
        CMPNE   R1, #"#"        ; match if #
d2017 2
a2018 2
        MOV     R3, R4          ; name backtrack ptr is char after match
        B       %BT01           ; LOOP
d2040 1
a2040 1
        LDR     r9, =VariableList
d2043 1
a2043 1
        BEQ     %FT99             ;exit with EQ (not found)
d2081 1
a2081 1
        mrs     HS, r10, CPSR           ; preserve last HS result we got
d2095 3
a2097 5
;don't want to save context in this version of routine
;  [ SysVars_QuickContext
;        ASSERT  SysVars_LastContext = SysVars_VTableOffset - 4
;        STRLS   r6, [r9, #-4]            ;save var table index for context we're returning, in LastContext
;  ]
d2101 1
a2101 1
        msr     LS, CPSR_f, r10
d2128 1
a2128 1
        MOV     r1,#SysVars_StickyPointers
d2136 1
a2136 1
        MOV     r0,#0
d2147 1
a2147 1
        MOV     r0,#0
d2174 1
a2174 1
        MOV     r3,#SysVars_StickyPointers
d2181 1
a2181 1
        MOV     r0,#0
d2221 1
a2221 1
        MOV     r1,#SysVars_StickyPointers
d2253 1
a2253 1
        MOV     r0,#0
d2264 1
a2264 1
        MOV     r0,#0
@


4.6.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d1908 1
a1908 1
        MRSHS   r10, CPSR               ; preserve last HS result we got
d1928 1
a1928 1
        MSRLS   CPSR_f, r10
d2094 1
a2094 1
        MRSHS   r10, CPSR               ; preserve last HS result we got
d2116 1
a2116 1
        MSRLS   CPSR_f, r10
@


4.6.2.2
log
@Merge in long command line support from Ursula kernel.
Look for LongCommandLine flag, command line size currently
set at 1k.
For HAL/32bit builds, the kernel buffer space is at high
(top bit set) address, which may break some code using signed
comparisons. So *beware* that there may be some latent
bugs in old kernel code using these buffers, not yet found.
One such bug, in s.Arthur2 found and fixed.
Tested moderately on ARM9 desktop build.
Lovely to reimplement things I did two and half years ago.

Version 5.35, 4.79.2.37. Tagged as 'Kernel-5_35-4_79_2_37'
@
text
@a1236 8
  [ LongCommandLines
        MOV     r0, stack, LSR #20      ; SVC stack base assumed on 1M boundary
        SUB     r0, sp, r0, LSL #20     ; amount of stack left
        CMP     r0, #LongCLISize + 2048 ; insist on 2k left after long buffer
        MOVHS   r2, #LongCLISize        ; ok, got a long buffer
        MOVLO   r2, #256                ; stack full-ish, use a 256 buffer and hope it's big enough
        SUB     stack, stack, r2
  |
a1238 1
  ]
a1310 8
  [ LongCommandLines
        MOV     r0, stack, LSR #20      ; SVC stack base assumed on 1M boundary
        SUB     r0, sp, r0, LSL #20     ; amount of stack left
        CMP     r0, #LongCLISize + 2048 ; insist on 2k left after long buffer
        MOVHS   r2, #LongCLISize        ; ok, got a long buffer
        MOVLO   r2, #256                ; stack full-ish, use a 256 buffer and hope it's big enough
        SUB     stack, stack, r2
  |
a1312 1
  ]
@


4.6.2.3
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d841 1
a841 1
        BHS      %FT03                    ; no rheum for byte.
@


4.6.2.4
log
@  Miscellaneous stuff.
Detail:
  * Merged in the change to RISC OS 4.02 kernel that moved the GSTrans
    workspace out of scratch space.
  * Fixed a few bugs in callback postponement, and interrupt holes in
    callback dispatch. See Docs.CallbackChange for full info.
  * Fixed SystemSizeCMOS to SysHeapCMOS - wouldn't build as was.
  * Added an export of a C version of Hdr:HALDevice, based on the Hdr2H
    translation but with an additional struct definition. Required by
    SoundControl 1.00.
  * Added some additional location and ID allocations to Hdr:HALDevice.
    Required by today's HAL and SoundControl.
Admin:
  Partially tested.

Version 5.35, 4.79.2.56. Tagged as 'Kernel-5_35-4_79_2_56'
@
text
@a242 3
 [ GSWorkspaceInKernelBuffers
        LDR    R12, =SysVarWorkSpace
 |
a244 1
 ]
a301 3
 [ GSWorkspaceInKernelBuffers
        LDR    R12, =SysVarWorkSpace
 |
a303 1
 ]
a330 4
 [ GSWorkspaceInKernelBuffers
        LDR    R12, =SysVarWorkSpace
        ADD    R2, R12, #1
 |
a332 1
 ]
a342 3
 [ GSWorkspaceInKernelBuffers
        MOV    R3, #?SysVarWorkSpace-1
 |
a343 1
 ]
a394 4
 [ GSWorkspaceInKernelBuffers
        LDR    R12, =SysVarWorkSpace
        MOV    R1, R12
 |
a396 1
 ]
a416 3
 [ GSWorkspaceInKernelBuffers
        LDR    R12, =SysVarWorkSpace
 |
a417 1
 ]
a423 3
 [ GSWorkspaceInKernelBuffers
        LDR    R1, =SysVarWorkSpace
 |
a424 1
 ]
a539 2

        LTORG
@


4.6.2.5
log
@Fix bug when creating code variables via OS_SetVarVal (HAL branch)
Detail:
  OS_SetVarVal was failing to call XOS_SynchroniseCodeAreas after copying the code variables code block into the system heap. This has now been fixed.
Admin:
  Fix tested in Cortex branch on rev C2 beagleboard. Debugger module now shows the right register names instead of ofla!


Version 5.35, 4.79.2.106. Tagged as 'Kernel-5_35-4_79_2_106'
@
text
@a1487 1
        Push    "r4",EQ ; Remember start of code block for code variables
d1502 1
a1507 1
SetVarVal_CopyR1BytesToR4
a1510 9
        TEQ     r10, #VarType_Code
        BNE     SetVarVal_NewNodeReady

        Pull    "r1" ; Grab pointer to start of code block
        Push    "r0,r2"
        MOV     r0,#1
        MOV     r1,r4
        SWI     XOS_SynchroniseCodeAreas
        Pull    "r0,r2"
@


4.6.2.6
log
@Merge over some changes from the Cortex branch
Detail:
  hdr/ARMops - Reserve OS_PlatformFeatures 0 bit 20 for indicating whether high processor vectors are in use
  s/Kernel - Add local definitions of BYTEWS, LDROSB, STROSB, VDWS macros (previously in Hdr:Macros)
  s/MoreComms - Fix potential buffer overflow when filling error buffer (although GSTrans shouldn't overflow the buffer in the first place?)
  s/Arthur2 - GSRead number detection fix
  s/ArthurSWIs - Updated OS_ReadUnsigned to support reading 64bit numbers
  Docs/ReadUnsigned - Docs for the updated OS_ReadUnsigned interface
Admin:
  Untested!
  Needs HdrSrc 1.86


Version 5.35, 4.79.2.120. Tagged as 'Kernel-5_35-4_79_2_120'
@
text
@a634 1
        MOV     R0, #10
@


4.6.2.7
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d127 1
a127 1
        LDR    R12, =ZeroPage+VariableList
d377 1
a377 1
        LDR    R0, =ZeroPage
d382 1
a382 1
        LDR    R4, =ZeroPage+ReturnCode
d384 1
a384 1
        LDR    R4, =ZeroPage+RCLimit
d408 1
a408 1
ReadRCL LDR    R0, =ZeroPage
d425 1
a425 1
        LDR    R4, =ZeroPage+RCLimit
d1637 1
a1637 1
        LDR     r11, =ZeroPage+VariableList
d1777 1
a1777 1
        LDR     r11, =ZeroPage+VariableList
d1875 1
a1875 1
        LDR     r9, =ZeroPage+VariableList
d2114 1
a2114 1
        LDR     r9, =ZeroPage+VariableList
d2204 1
a2204 1
        LDR     r1,=ZeroPage+SysVars_StickyPointers
d2212 1
a2212 1
        LDR     r0,=ZeroPage
d2223 1
a2223 1
        LDR     r0,=ZeroPage
d2250 1
a2250 1
        LDR     r3,=ZeroPage+SysVars_StickyPointers
d2257 1
a2257 1
        LDR     r0,=ZeroPage
d2297 1
a2297 1
        LDR     r1,=ZeroPage+SysVars_StickyPointers
d2329 1
a2329 1
        LDR     r0,=ZeroPage
d2340 1
a2340 1
        LDR     r0,=ZeroPage
@


4.6.2.8
log
@Reindent Arthur2.
Expand tabs.
Swap DCI for instructions now Objasm 4 is out.
Symbols for FSControl_CAT/RUN/OPT changed to non Arthur definitions.
Still boots on IOMD class, no other testing.

Version 5.35, 4.79.2.124. Tagged as 'Kernel-5_35-4_79_2_124'
@
text
@d21 1
a21 1
$l      LDR     R12, =GSVarWSpace
d123 1
a123 1
        Push    "lr"
d126 3
a128 3
        MOV     R0, #0
        LDR     R12, =ZeroPage+VariableList
        STR     R0, [R12]
d131 15
a145 15
        ADR     R0, SystemVarList       ; R0 pointer to name
01      MOV     R1, R0
        LDRB    R2, [R1], #1
        CMP     R2, #0
        Pull    "PC", EQ
02      LDRB    R3, [R1], #1
        CMP     R3, #0
        BNE     %BT02
        LDRB    R4, [R1], #1            ; get type
        ADD     R1, R1, #3
        BIC     R1, R1, #3
        LDR     R2, [R1], #4
        SWI     XOS_SetVarVal
        ADD     R0, R1, R2
        B       %BT01
d158 1
a158 1
        =       "Sys$$Time", 0, VarType_Code
d160 3
a162 3
        &       sv2-.-4
        LDR     PC, %FT01
        LDR     PC, %FT02
d164 1
a164 1
        &       SetTimeVar
d166 1
a166 1
        &       ReadTimeVar
d168 1
a168 1
sv2     =       "Sys$$Year", 0, VarType_Code
d170 3
a172 3
        &       sv3-.-4
        LDR     PC, %FT03
        LDR     PC, %FT04
d174 1
a174 1
        &       SetYear
d176 1
a176 1
        &       ReadYear
d178 1
a178 1
sv3     =       "Sys$$Date", 0, VarType_Code
d180 3
a182 3
        &       sv4-.-4
        LDR     PC, %FT05
        LDR     PC, %FT06
d184 1
a184 1
        &       SetDate
d186 1
a186 1
        &       ReadDate
d188 1
a188 1
sv4     =       "Sys$$ReturnCode", 0, VarType_Code
d190 3
a192 3
        &       sv5-.-4
        LDR     PC, %FT07
        LDR     PC, %FT08
d194 1
a194 1
        &       SetRC
d196 1
a196 1
        &       ReadRC
d198 1
a198 1
sv5     =       "Sys$$RCLimit", 0, VarType_Code
d200 3
a202 3
        &       sv6-.-4
        LDR     PC, %FT09
        LDR     PC, %FT10
d204 1
a204 1
        &       SetRCL
d206 1
a206 1
        &       ReadRCL
d208 1
a208 1
sv6     =       "Alias$.", 0, VarType_String
d210 2
a211 2
        &       sv7-.-4
        =       "Cat ", 10
d213 1
a213 1
sv7     =       "Sys$$DateFormat", 0, VarType_String
d215 1
a215 1
        &       sv8-.-4
d218 1
a218 1
        =       "%24:%mi:%se %dy-%m3-%ce%yr", 10
d220 1
a220 1
        =       "%w3,%dy %m3 %ce%yr.%24:%mi:%se", 10
d223 1
a223 1
sv8     =       0
d226 1
a226 1
        =       "%24:%mi:%se", 0
d228 1
a228 1
        =       "%w3,%dy %m3", 0
d230 1
a230 1
        =       "%ce%yr", 0
d237 2
a238 2
        ADR     R0, SysTimeFormat
        B       ReadTimeFormatted
d240 3
a242 3
        CMP     R2, #&FE
        BHI     TimeVarTooLong
        Push    "R0, lr"
d244 1
a244 1
        LDR     R12, =SysVarWorkSpace
d247 1
a247 1
        ADD     R12, R12, #GSNameBuff
d249 14
a262 14
        MOV     R11, #8
        STRB    R11, [R12], #1
        MOV     R10, #0
        STRB    R10, [R12, R2]
        MOV     R10, R2
01      SUBS    R10, R10, #1
        LDRPLB  R11, [R1, R10]
        STRPLB  R11, [R12, R10]
        BPL     %BT01
        SUB     R1, R12, #1
        MOV     R0, #15
        SWI     XOS_Word
        STRVS   R0, [R13]
        Pull    "R0, PC"
d265 1
a265 1
        ADRL    R0, ErrorBlock_VarTooLong
d267 1
a267 1
        B       TranslateError
d273 2
a274 2
        ADR     R0, SysYearFormat
        B       ReadTimeFormatted
d276 22
a297 22
        CMP     R2, #4
        BHI     TimeVarTooLong
        Push    "R0, lr"
        Push    "R1,R2"
        ADR     R0, SetYearPrefixFormat
        BL      ReadTimeFormatted
        ADD     R12, R0, R2             ; R12 -> position to copy year to
        Pull    "R1,R2"
        BVS     %FT02
        MOV     R10, #0
        STRB    R10, [R12, R2]
        MOV     R10, R2
01      SUBS    R10, R10, #1
        LDRPLB  R11, [R1, R10]
        STRPLB  R11, [R12, R10]
        BPL     %BT01
        SUB     R1, R0, #1
        MOV     R0, #15
        STRB    R0, [R1]
        SWI     XOS_Word
02      STRVS   R0, [R13]
        Pull    "R0, PC"
d300 2
a301 2
        ADR     R0, SysDateFormat
        B       ReadTimeFormatted
d303 3
a305 3
        CMP     R2, #&F8
        BHI     TimeVarTooLong
        Push    "R0, lr"
d307 1
a307 1
        LDR     R12, =SysVarWorkSpace
d310 1
a310 1
        ADD     R12, R12, #GSNameBuff
d312 19
a330 19
        MOV     R11, #15
        STRB    R11, [R12], #1
        MOV     R10, #0
        STRB    R10, [R12, R2]
        MOV     R10, R2
01      SUBS    R10, R10, #1
        LDRPLB  R11, [R1, R10]
        STRPLB  R11, [R12, R10]
        BPL     %BT01
        ADD     R1, R12, R2
        ADR     R0, SetDateSuffixFormat ; append year to supplied date
        Push    "R12"
        BL      ReadTimeFormattedAtR1
        Pull    "R12"
        SUB     R1, R12, #1
        MOV     R0, #15
        SWI     XOS_Word
        STRVS   R0, [R13]
        Pull    "R0, PC"
d338 1
a338 1
        Push    "R3,R4,LR"
d340 2
a341 2
        LDR     R12, =SysVarWorkSpace
        ADD     R2, R12, #1
d344 1
a344 1
        ADD     R2, R12, #GSNameBuff+1  ; This code copied from OsWord0EAlpha
d346 10
a355 10
01      MOV     R4, R0
        SUB     R13, R13, #8
        MOV     R1, R13
        MOV     R0, #3
        STRB    R0, [R1]
        MOV     R0, #14
        SWI     XOS_Word
        BVS     %FT02
        MOV     R0, #-1
        MOV     R1, R13
d357 1
a357 1
        MOV     R3, #?SysVarWorkSpace-1
d359 1
a359 1
        MOV     R3, #?GSNameBuff-1
d361 4
a364 4
        SWI     XTerritory_ConvertDateAndTime
02      ADD     R13, R13, #8
        SUBVC   R2, R1, R0
        Pull    "R3,R4,PC"
d372 3
a374 3
        Push    "R3,R4,LR"
        MOV     R2, R1
        B       %BT01
d377 15
a391 15
        LDR     R0, =ZeroPage
        LDR     R0, [R0, #ReturnCode]
        B       ReadNumSysVar
SetRC   Push    "lr"
        BL      SetNumSysVar
        LDR     R4, =ZeroPage+ReturnCode
        STR     R2, [R4]
        LDR     R4, =ZeroPage+RCLimit
        LDR     R4, [R4]
        CMP     R2, R4
        BHI     %FT03
        CLRV    
        Pull    "PC"
03      ADRGT   R0, ErrorBlock_RCExc
        ADRLT   R0, ErrorBlock_RCNegative
d393 1
a393 1
        BL      TranslateError
d398 1
a398 1
        Pull    "PC"
d400 1
a400 1
        =       "%w3,%dy %m3 ", 0
d402 1
a402 1
        =       " %ce%yr", 0
d408 2
a409 2
ReadRCL LDR     R0, =ZeroPage
        LDR     R0, [R0, #RCLimit]
d411 1
a411 1
        Push    "lr"
d413 2
a414 2
        LDR     R12, =SysVarWorkSpace
        MOV     R1, R12
d417 1
a417 1
        ADD     R1, R12, #GSNameBuff
d419 12
a430 12
        MOV     R2, #256
        SWI     XOS_BinaryToDecimal
        MOV     R0, R1
        Pull    "PC"
SetRCL  Push    "lr"
        BL      SetNumSysVar
        LDR     R4, =ZeroPage+RCLimit
        CMP     R2, #0                  ; can't set -ve RCLimit
        RSBMIS  R2, R2, #0
        MOVMI   R2, #0                  ; BIC of MININT
        STR     R2, [R4]
        Pull    "PC"
d434 5
a438 5
SetNumSysVar    ROUT ; R1 ptr to string, R2 string length
        Push    "lr"
        SUBS    R2, R2, #1
        ADDMI   R2, R2, #1              ; give 0 in R2 for bad length.
        Pull    "PC", MI
d440 1
a440 1
        LDR     R12, =SysVarWorkSpace
d442 1
a442 1
        LDR     R12, =GSNameBuff+GSVarWSpace
d444 6
a449 6
03      LDRB    R10, [R1], #1           ; copy into a buffer so we can terminate it.
        STRB    R10, [R12], #1
        SUBS    R2, R2, #1
        BPL     %BT03
        MOV     R10, #13
        STRB    R10, [R12], #1
d451 1
a451 1
        LDR     R1, =SysVarWorkSpace
d453 1
a453 1
        LDR     R1, =GSNameBuff+GSVarWSpace
d455 11
a465 11
        LDRB    R10, [R1]
        MOV     R12, #0
        CMP     R10, #"-"
        MOVEQ   R12, #-1
        CMPNE   R10, #"+"
        ADDEQ   R1, R1, #1
        MOV     R0, #0
        SWI     XOS_ReadUnsigned
        CMP     R12, #0
        RSBMI   R2, R2, #0
        Pull    "PC"
d517 1
a517 1
                                        ; get caller's flags
d546 1
a546 1
        STRB    R1, [R12, #GS_StackPtr] ; no stacked R0s
d553 1
a553 1
                                        ; get caller's flags
d562 2
a563 2
        SUBNE   R0, R0, #1              ; dec if went too far
        ORREQ   R2, R2, #GS_In_String   ; set flag if in string
d567 1
a567 1
        ORREQ   lr, lr, #Z_bit          ; and move EQ/NE to return pc
d650 2
a651 2
        MOV     R3, #0                  ; context ptr
        SUB     R0, R12, R11            ; name ptr
d653 1
a653 1
        Pull    "R0, R3, R4, R10", EQ   ; not found mate
d678 1
a678 1
        LDRB    R1, [R0], #1            ; type
d703 1
a703 1
        ADD     stack, stack, #4        ; discard that R0
d707 1
a707 1
        ORR     R2, R2, R1              ; old flags+new count
d718 1
a718 1
        B       GSREAD_XPandGetNextByte ; loop, transforming chars.
d723 1
a723 1
        ADD     stack, stack, #4        ; skip R0 - return null string
d725 1
a725 1
        B       GSREAD_XPandGetNextByte ; get next char
d733 2
a734 2
        TST     R2, #GS_In_String       ; got CR or LF
        BNE     GSREAD_BadStringError   ; bad string
d756 1
a756 1
        B       GSREAD_XPandGetNextByte ; return to prevstring
d761 1
a761 1
        BEQ     GSREAD_GotToAnEnd       ; terminates
d790 1
a790 1
        BEQ     GSREAD_ReturnWithChar   ; || gives |, |" gives ", |< gives <
d792 2
a793 2
        MOVEQ   R1, #&7F                ; delete
        BEQ     GSREAD_ReturnWithChar   ; valid ch
d799 4
a802 4
        CMP     R1, #&7F                ; CTRL-delete is delete
        EORGT   R1, R1, #&20            ; softkey
        BGE     GSREAD_ReturnWithChar   ; now valid ch
        CMP     R1, #"`"                ; CTRL-` = CTRL-_
d805 1
a805 1
        ANDGE   R1, R1, #&1F            ; transform if @@<=ch<delete
d809 1
a809 1
        SUB     R2, R2, #1              ; we're reading a string
d815 2
a816 2
        LDRNEB  R1, [R0], #1            ; and this is already expanded
        ExitSWIHandler NE               ; so finished
d844 3
a846 3
        ADD     R0, R0, #3 + 4          ; 3 to ALIGN, 4 to get to read entry
        MOV     lr, PC                  ; get link
        BIC     PC, R0, #3              ; call entrypoint to Read Thunk
d864 1
a864 1
        BIC     lr, lr, #C_bit
d866 1
a866 1
        WritePSRc SVC_mode, R3          ; enable ints.
d868 14
a881 14
        MOV     R3, R1                  
        MOV     R4, R1                  ; two copies of start ptr
        BIC     R5, R2, #&E0000000      
        ADD     R5, R5, R1              ; 1st byte we can't write to.
        SWI     XOS_GSInit              
01      CMP     R3, R5                  
        BHS     %FT03                   ; no rheum for byte.
        SWI     XOS_GSRead              
        BVS     %FT02                   ; bad string
        STRB    R1, [R3], #1            
        BCC     %BT01                   
04      SUB     R2, R3, R4              ; no chars got
        SUB     R2, R2, #1              
        Pull    "R1, R3-R5, lr"         
d884 2
a885 2
02      SUB     R2, R3, R4              
        Pull    "R1, R3-R5, lr"         
d888 1
a888 1
03      SUB     R2, R3, R4
d890 1
a890 1
        ORR     lr, lr, #C_bit          ; buffer overflow
d936 1
a936 1
        WritePSRc SVC_mode, r11         ; enable interupts (mode remains unchanged)
d951 1
a951 1
        BL      VarFindIt               ; name=r0,context=r3 -> name found in node=r3,r4=after namein,r12=prev
d1001 1
a1001 1
        MOV     R2, R10                 ; bytes he's gonna get
d1060 3
a1062 3
        CMP     r2, #0                  ; if negative, then don't call GSTrans because bits 29..31 have
        MVNMI   r10, r2                 ; return r2 out by this method
        BMI     ReadVarVal_BufWillOFlow ; a special meaning - just branch back to the normal overflow code
d1078 1
a1078 1
        LDRB    R0, [R11], #1           ; number - convert to string.
d1180 10
a1189 10
      &         1
      &         10
      &         100
      &         1000
      &         10000
      &         100000
      &         1000000
      &         10000000
      &         100000000
      &         1000000000
d1322 1
a1322 1
        MOV     r0, r3                  ; If already there use that's name in case supplied name wildcarded
d1335 1
a1335 1
        SUB     stack, stack, #256      ; buffer
d1475 1
a1475 1
        ADD     sp,sp,#12               ; balances push r0-r2 above - value length (entry r2) now in r1
d1495 1
a1495 1
        SUBEQ   r1, r1, #1              ; ghastly fudge to avoid display of terminator
d1502 1
a1502 1
        ADDEQ   r1, r1, #1              ; undo ghastly fudge
d1552 1
a1552 1
        MOV     r3, #64                 ;should be a multiple of StickyNode_UnitSize if SysVars_StickyNodes TRUE
d1678 1
a1678 1
        MOV     r3, #(10*4)+4           ; 10 nodes and 1 word for the count
d1680 1
a1680 1
        BL      ClaimSysHeapNode        ; this is not a variable node (its the index)
d1700 2
a1701 2
        LDR     lr, [r10, #-4]          ; Block length, from heap block
        SUB     lr, lr, #4+4            ; 4 for heap adjustment and 4 for entry count word
d1717 1
a1717 1
        MOV     r3, #40                 ; room for 10 more nodes
d1719 1
a1719 1
        BL      DoSysHeapOpWithExtension        ;not a variable node (expanding index)
d1896 1
a1896 1
        CMP     r12, r8                 ;if not valid, or higher than current number of vars, forget it
d1985 1
a1985 1
        STRLS   r6, [r9, #-4]           ;save var table index for context we're returning, in LastContext
d2053 3
a2055 3
        MOV     R11, #0                 ; this is the wild backtrack pointer
        MOV     R3, #0                  ; and this is the name backtrack ptr.
01      LDRB    R1, [R0], #1            ; nextwild
d2057 2
a2058 2
        BEQ     %FT02                   ; IF nextwild = "*"
        LDRB    R2, [R4], #1            ; nextname
d2063 5
a2067 5
        CMP     R1, R2                  ; IF nextwild=nextname
        CMPNE   R1, #"#"                ;   OR nextwild = #  (terminator checked already)
        BEQ     %BT01                   ; THEN LOOP (stepped already)
        MOV     R0, R11                 ; try backtrack
        MOVS    R4, R3                  ; if * had at all
d2069 2
a2070 2
        CMP     PC, #0                  ; set NE
04      Pull    "R0-R3"                 ; return NE (failed)
d2073 3
a2075 3
03      CMP     R1, #" "                ; name terminated : has wildcard?
        BHI     %BA04                   ; note HI has NE set.
        CMP     R1, R1                  ; set EQ
d2079 2
a2080 2
02      MOV     R11, R0                 ; wild backtrack ptr is char after *
        LDRB    R1, [R0], #1            ; step wild
d2082 1
a2082 1
        BEQ     %BT02                   ; fujj **
d2084 2
a2085 2
05      LDRB    R2, [R4], #1            ; step name
        CMP     R2, #0                  ; terminator?
d2089 1
a2089 1
        CMPNE   R1, #"#"                ; match if #
d2091 2
a2092 2
        MOV     R3, R4                  ; name backtrack ptr is char after match
        B       %BT01                   ; LOOP
d2117 1
a2117 1
        BEQ     %FT99                   ;exit with EQ (not found)
d2169 5
a2173 3

        ; don't want to save context in this version of routine

@


4.6.2.9
log
@Conversions rationalisation.
Delete pmf/convdate, moved to conversions.
Moved OS_BinaryToDecimal to conversions.
Remove OS_ConvertHex16 and friends.
Add OS_ConvertVariform skeleton.
Tidied conversions.

Version 5.35, 4.79.2.125. Tagged as 'Kernel-5_35-4_79_2_125'
@
text
@d74 1
d76 1
a76 1
; structures.
d1114 76
@


4.6.2.10
log
@Make OS_GSTrans be more sensible about what it treats as system variables
Detail:
  s/Arthur2 - OS_GSTrans now uses the same rules as OS_SetVarValue when deciding whether text within angle brackets is a valid system variable name or not. In particular spaces in the middle of a variable name are no longer considered valid, so expressions such as "*If 0<1 AND 1>0 then echo true" now have the expected result
  Also replaced the magic constant used for the name buffer length with a proper symbolic value, and tweaked its handling a bit in order to increase the maximum permissible variable name length from 253 chars to 255 (although OS_SetVarVal allows longer)
Admin:
  Tested on Iyonix
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/4/topics/2912


Version 5.35, 4.79.2.245. Tagged as 'Kernel-5_35-4_79_2_245'
@
text
@a614 2
        ; OS_SetVarValue requires system variable names to be space or control
        ; terminated, so we shall discard anything which violates that rule
d621 5
a626 4
        BEQ     %FT25
        CMP     R11, #?GSNameBuff
        CMPNE   R1, #" "
        TSTNE   R1, #&E0                ; i.e. EQ if <32
a627 1
        B       GSREAD_AngleBraDaftSoIsnt
a628 1
25
@


4.6.2.4.2.1
log
@  Miscellaneous v6-related updates
Detail:
 * Stopped calling the broken abort fixup code when running under VMSAv6.
   Might be desirable to update it, possibly farmed out to a separate module -
   still need to think about this.
 * Unaligned load optimisations can now be disabled by the global NoUnaligned
   flag for testing purposes.
 * Extended OS_ReadUnsigned to permit reading of 64-bit unsigned integers.
   See Docs.ReadUnsigned for more details. Also sped it up by using MLA
   (or UMLAL) for most digits rather than repeated addition.
 * Bugfix is OS_GSRead: an uninitialised r0 was being passed to
   OS_ReadUnsigned, causing undesirable effects on rare occasions.
Admin:
  Tested on a rev B7 beagleboard.

Version 5.35, 4.79.2.98.2.8. Tagged as 'Kernel-5_35-4_79_2_98_2_8'
@
text
@a634 1
        MOV     R0, #10
@


4.6.2.4.2.2
log
@Fix bug when creating code variables via OS_SetVarVal, remove errant line from s.ARM600, automatically enable alignment exceptions if NoUnaligned is TRUE (Cortex branch)
Detail:
  s/ARM600 - Removed an errant line that could have caused problems if the ARM600 MMU model was used with the WB_CR7_Lx cache type
  s/Arthur2 - OS_SetVarVal was failing to call XOS_SynchroniseCodeAreas after copying the code variables code block into the system heap. This has now been fixed.
  s/HAL - Alignment exceptions are now automatically enabled when the kernel is built with the NoUnaligned option turned on.
Admin:
  Tested on rev C2 beagleboard. OS_SetVarVal fix means the Debugger module now shows the right register names instead of ofla!


Version 5.35, 4.79.2.98.2.15. Tagged as 'Kernel-5_35-4_79_2_98_2_15'
@
text
@a1488 1
        Push    "r4",EQ ; Remember start of code block for code variables
d1503 1
a1508 1
SetVarVal_CopyR1BytesToR4
a1511 9
        TEQ     r10, #VarType_Code
        BNE     SetVarVal_NewNodeReady

        Pull    "r1" ; Grab pointer to start of code block
        Push    "r0,r2"
        MOV     r0,#1
        MOV     r1,r4
        SWI     XOS_SynchroniseCodeAreas
        Pull    "r0,r2"
@


4.6.2.4.2.3
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d127 1
a127 1
        LDR    R12, =ZeroPage+VariableList
d377 1
a377 1
        LDR    R0, =ZeroPage
d382 1
a382 1
        LDR    R4, =ZeroPage+ReturnCode
d384 1
a384 1
        LDR    R4, =ZeroPage+RCLimit
d408 1
a408 1
ReadRCL LDR    R0, =ZeroPage
d425 1
a425 1
        LDR    R4, =ZeroPage+RCLimit
d1637 1
a1637 1
        LDR     r11, =ZeroPage+VariableList
d1777 1
a1777 1
        LDR     r11, =ZeroPage+VariableList
d1875 1
a1875 1
        LDR     r9, =ZeroPage+VariableList
d2114 1
a2114 1
        LDR     r9, =ZeroPage+VariableList
d2204 1
a2204 1
        LDR     r1,=ZeroPage+SysVars_StickyPointers
d2212 1
a2212 1
        LDR     r0,=ZeroPage
d2223 1
a2223 1
        LDR     r0,=ZeroPage
d2250 1
a2250 1
        LDR     r3,=ZeroPage+SysVars_StickyPointers
d2257 1
a2257 1
        LDR     r0,=ZeroPage
d2297 1
a2297 1
        LDR     r1,=ZeroPage+SysVars_StickyPointers
d2329 1
a2329 1
        LDR     r0,=ZeroPage
d2340 1
a2340 1
        LDR     r0,=ZeroPage
@


4.5
log
@*Set Sys$Year would scramble the time. It would also fail to internationalise
the error generated by *Set Year 20000.
Tested on a 32-bit system - changes grafted back on to 26-bit Kernel.

Version 5.08. Tagged as 'Kernel-5_08'
@
text
@d265 1
a265 1
        ORRS   PC, LR, #V_bit
d370 4
a373 3
        Pull  "lr", LS
        BICLSS PC, lr, #V_bit
        ADRGT  R0, ErrorBlock_RCExc
d483 1
a483 1
        TEQP    pc, #SVC_mode
d552 1
a552 1
        TEQP    pc, #SVC_mode
d833 1
a833 1
        TEQP     PC, #SVC_mode             ; enable ints.
d903 1
a903 1
        TEQP    PC, #SVC_mode   ; enable interupts (mode remains unchanged)
d1208 1
a1208 1
        TEQP    pc, #SVC_mode
d1908 1
a1908 1
        MOVHS   r10, pc                 ; preserve last HS result we got
d1928 1
a1928 1
        TEQLSP  pc, r10
d1936 1
a1936 2
        MOV     lr, pc
        TEQP    lr, #Z_bit
d2094 1
a2094 1
        MOVHS   r10, pc                 ; preserve last HS result we got
d2116 1
a2116 1
        TEQLSP  pc, r10
d2118 1
a2118 2
        MOV     lr, pc
        TEQP    lr, #Z_bit
@


4.4
log
@ChocolateSysVars and ChocolateOscli merged from Ursula.

Version 4.84. Tagged as 'Kernel-4_84'
@
text
@d262 3
d266 1
d382 1
a382 1
        =     "%w3, %dy-%m3-", 0
d384 1
a384 1
        =     "-%ce%yr", 0
d1755 1
d1757 1
@


4.3
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d24 24
a47 2
        GBLL    LongVars
LongVars SETL {TRUE}            ; Long system variables (>255 chars)
d49 9
a57 2
        GBLL    QuickIndex
QuickIndex SETL {TRUE}          ; Quick index to binary chop on lookup
a62 1

d81 1
a81 5
 [ QuickIndex
; VariableList---->sorted table of pointers to variable blocks
 |
; VariableList---->1st variable--->2nd variable--....-->last variable--->||
 ]
d85 2
a86 1
; Each variable is stored in one block in the system heap. The format of each block is:
d88 2
a89 5
; Bytes         Use
 [ :LNOT: QuickIndex
; 4             Link. Points to next variable in the list. 0 indicates no more.
 ]
; N+1           Variable's name (length N with terminator).
d102 1
a102 1
; 1             Length (N)
d111 1
a111 1
; 1             Length (N)
a645 1
 [ LongVars
a652 10
 |
        BLO     GSREAD_GotVarAsString
        BHI     GSREAD_GotMacroVar

        ; Got number var
        LDRB    R3, [R0], #1          ; number - build value
        ORR     R1, R1, R3, LSL #8
        LDRB    R3, [R0], #1
        ORR     R1, R1, R3, LSL #16
 ]
a735 1
 [ Fix16
a743 6
 |

10      LDRB    R1, [R0], #1
        CMP     R1, #" "
        BEQ     %BT10
 ]
a771 1
 [ LongVars
a776 3
 |
        TST     R2, #&FF
 ]
a859 16
; Variable storage format is dead simple - linear list!
; It's not even ordered in any fashion.
; List has fixed section of system vars that cannot die.

; Node format : Link, Name bytes, 0 terminator (so Write0able), type byte,
;               then 4 bytes for numeric
;               or  length byte, value bytes for string/macro.
;               then a CR if it's a macro variable.

 [ QuickIndex
VNameOff *  0
 |
VarLink  *  0
VNameOff *  4
 ]

d893 4
d903 10
d916 3
a943 1
 [ LongVars
a948 3
 |
        LDRNEB  r10, [r11], #1
 ]
a1025 1
 [ LongVars
a1026 3
 |
        ADD     r0, r11, #1             ; skip length
 ]
a1188 1
 [ LongVars
d1231 1
d1233 1
a1236 1
        MOV     r2, #256
a1269 1
 [ QuickIndex
a1270 24
 |
        ; Variable name OK, find where in list we want to insert it

        LDR     r12, =VariableList
        LDR     r11, [r12]
        CMP     r11, #0
        B       %FT08

06
        MOV     r3, r0
        ADD     r4, r11, #VNameOff
07
        LDRB    r5, [r3], #1
        LDRB    r6, [r4], #1
        CMP     r5, r6                  ; can't hit terminator :
        BEQ     %BT07                   ; not same as any on list
        MOVHI   r12, r11
        LDRHI   r11, [r12, #VarLink]
        CMPHI   r11, #0
08
        BHI     %BT06

        ; r12 now ready as pointer to prev
 ]
d1286 3
a1288 2
        ; For both string and number give ourselves a stack frame
        SUB     stack, stack, #256
a1290 2
        BLO     SetVarVal_AssignStringToCode

d1306 3
a1333 1
 [ QuickIndex
a1334 3
 |
        ; r12 = prev
 ]
d1342 1
a1342 1
        MOV     r3, #VNameOff + 1       ; Add one for the type byte
d1350 3
d1355 1
a1355 1
        ADDLO   r3, r3, #50             ; only an initial guess for the string type
a1391 1
 [ QuickIndex
a1392 3
 |
        ; r12 -> prev node
 ]
d1394 6
a1399 1
        Push    "r0,r2"
d1401 2
a1403 1
        Pull    "r0,r1"
d1408 3
a1410 1
        ADD     r4, r2, #VNameOff
d1418 3
d1486 4
a1489 1
        MOV     r3, #64
d1491 1
d1502 3
d1506 1
d1514 9
d1526 1
a1544 1
 [ QuickIndex
a1545 3
 |
        ; r12 -> prevP
 ]
a1570 1
 [ QuickIndex
d1573 4
d1586 4
a1589 1
        SUB     r2, r6, #VNameOff
d1591 1
d1606 9
a1614 2
        MOV     r3, #44         ; 10 nodes and 1 for the count
        BL      ClaimSysHeapNode
d1616 4
d1630 7
a1636 2
        LDR     lr, [r10, #-4]          ; Block length
        SUB     lr, lr, #4+4            ; 4 for heap adjustment and 4 for entry count word
d1646 4
d1651 3
a1653 2
        MOV     r3, #40                 ; room for 10 more nodes
        BL      DoSysHeapOpWithExtension
d1660 3
a1692 12
 |
        ; Remove old node and place new node in its place
        TEQ     r6, #0
        LDRNE   lr, [r6, #-VNameOff]
        LDREQ   lr, [r12]
        STR     lr, [r2]
        STR     r2, [r12]

        ; If old node present then junk it
        SUBNE   r2, r6, #VNameOff
        BLNE    FreeSysHeapNode
 ]
a1702 1

a1710 1
 [ QuickIndex
d1713 3
d1726 4
a1729 1
        SUB     r2, r3, #VNameOff
d1731 1
a1739 1
        ASSERT  VNameOff = 0
a1742 9
 |
        ; Unlink node from chain
        SUB     r3, r3, #VNameOff
        LDR     r11, [r3, #VarLink]
        STR     r11, [r12, #VarLink]
        MOV     R2, R3                   ; node ptr.
        BL      FreeSysHeapNode
        ADD     R3, R12, #VNameOff       ; our best guess at a context ptr
 ]
d1752 1
d1759 1
a1759 1
        BL      FreeSysHeapNode
d1767 1
a1767 1
        BL      FreeSysHeapNode
a1777 298
 |
SetVarValue ROUT

        Push    "R1, R2, R4, lr"
        CheckSpaceOnStack  512, SVStackFull, r12
        SUB     stack, stack, #256      ; buffer space

        CMP     R2, #0
        BMI     SetVarVal_GotValueToBuffer ; deletion

; now range check type
        CMP     R4, #VarType_Code
        BEQ     SetVarVal_GotValueToBuffer
        CMP     R4, #VarType_Expanded
        BGT     SetVarVal_TypeNaff

; now get the value, before destroying anything
        BEQ     SetVarVal_AssignExpanded ; evaluate an expression
        CMP     R4, #VarType_Number
        MOVEQ   R2, #3                  ; numbers use type byte as one byte.
        BEQ     SetVarVal_GotValueToBuffer
        BGT     SetVarVal_ValidateMacroValue
; string : GSTRANS it.
        Push    "R0"
        MOV     R0, R1                  ; source ptr.
        ADD     R1, stack, #4
        MOV     R2, #255
        SWI     XOS_GSTrans
        BVS     VarBadStrErr
        Pull    "R0"
        BCC     SetVarVal_GotValueToBuffer

SetVarVal_GotValueToBufferButItsTooLong
        LDR     lr, [Stack, #4*3+256]   ; V set no. 3): value too long
        ORR     lr, lr, #V_bit          ; Poke V into stacked lr!
        STR     lr, [Stack, #4*3+256]

SetVarVal_GotValueToBuffer
; now got R1 pointer to value, R2 = value length
        BL      VarFindIt
        BEQ     SetVarVal_NodeNotFound

        ; Check whether we're assigning a Code value to a Code variable
        LDRB    R10, [R4]              ; get type
        CMP     R10, #VarType_Code
        BNE     %FT30
        LDR     R10, [Stack, #4*2+256]
        CMP     R10, #VarType_Code
        BNE     SetVarVal_AssignNonCodeToCode

30
        ; We are assigning a code value to a code variable
        ;               OR any value to a non-code variable

        ; deleting?
        CMP     R2, #0
        BMI     SetVarVal_GotToJunkOldNode  ; just delete it.

        ; Assigning....
        LDR     R11, [R3, #-(VNameOff+4)] ; real no of bytes in heap node
        SUB     R11, R11, #VNameOff+4+2
        ADD     R11, R11, R3
        SUB     R11, R11, R4             ; take off bytes in name
        CMP     R11, R2
        BGT     SetVarVal_NodeReadyToCopyInValue
; let's copy the name, in case orig source wildcarded.
        LDR     R0, =GSVarWSpace+GSNameBuff
        MOV     R10, R3
15      LDRB    R11, [R10], #1
        STRB    R11, [R0], #1
        CMP     R11, #0
        BNE     %BT15
        LDR     R0, =GSVarWSpace+GSNameBuff

SetVarVal_GotToJunkOldNode
; got to delete old node (too small). R12 previous, R3-VNameOff is this.
        SUB     R3, R3, #VNameOff
        LDR     R11, [R3, #VarLink]
        STR     R11, [R12, #VarLink]     ; chain updated
        Push    "R0-R2"
        MOV     R2, R3                   ; node ptr.
        BL      FreeSysHeapNode
        Pull    "R0-R2"                   ; node gone
        ADD     R3, R12, #VNameOff       ; our best guess at a context ptr
        CMP     R2, #0                   ; delete?
        BMI     SetVarValueTestExit      ; yup - exit.

SetVarVal_MakeNewNode
; here, R2 is value length, R0 ptr to name. Validate name while finding length
        MOV     R10, #0
16      LDRB    R11, [R0, R10]
        ADD     R10, R10, #1
        CMP     R11, #"#"
        CMPNE   R11, #"*"
        BEQ     SetVarVal_BadVarName     ; error no. 1)
        CMP     R11, #32
        BGT     %BT16
        CMP     R10, #1
        BEQ     SetVarVal_BadVarName     ; 0 char name also naff
; now got R10 name length. Calculate node size
        ADD     R11, R10, R2
        ADD     R11, R11, #VNameOff+2    ; link+name terminator+type
        Push    "R0-R3"
        MOV     R3, R11
        BL      ClaimSysHeapNode         ; corrupts R12
        MOV     R4, R2
        Pull    "R0-R3"
        BVS     SetVarSysHeapFull
; now need to find correct alphabetic position on chain.
        LDR     R12, =VariableList
        LDR     R11, [R12]
; R4 node to insert, R12 prevnode, R11 nextnode
        Push    "R5, R6"
31      CMP     R11, #0
        BEQ     %FT33
        ADD     R11, R11, #VNameOff
        MOV     R10, #-1
32      ADD     R10, R10, #1
        LDRB    R5, [R0, R10]
        LDRB    R6, [R11, R10]
        CMP     R5, R6                 ; can't hit terminator :
        BEQ     %BT32                 ; not same as any on list
        SUB     R11, R11, #VNameOff
        MOVGT   R12, R11
        LDRGT   R11, [R12, #VarLink]
        BGT     %BT31

33
        ; Link node into list
        STR     R11, [R4, #VarLink]
        STR     R4, [R12, #VarLink]     ; new entry in
        Pull    "R5, R6"

        ; Copy name to node
        ADD     R4, R4, #VNameOff
18      LDRB    R11, [R0], #1
        STRB    R11, [R4], #1
        CMP     R11, #32
        BGT     %BT18
        MOV     R11, #0
        STRB    R11, [R4, #-1]

SetVarVal_NodeReadyToCopyInValue
; now easy: just copy new value in. R2 bytes, from (R1).R4 points to type

        LDR     R10, [stack, #2*4+256]  ; get original type back
        STRB    R10, [R4], #1           ; put type in
        CMP     R10, #VarType_Macro
        SUBEQ   R2, R2, #1              ; fudge macro terminators
        CMP     R10, #VarType_Code
        ADDEQ   R4, R4, #3              ; align for code.
        BICEQ   R4, R4, #3
        CMP     R10, #VarType_Number
        MOVEQ   R2, #4
        CMPNE   R10, #VarType_Code   ; no length for numbers, sysvars
        STRNEB  R2, [R4], #1
        CMP     R10, #VarType_Macro
        ADDEQ   R2, R2, #1
05      SUBS    R2, R2, #1
        BMI     SetVarValueTestExit    ; finished
        LDRB    R10, [R1, R2]
        STRB    R10, [R4, R2]
        B       %BT05

SetVarSysHeapFull
        ADR     r0, ErrorBlock_VarNoRoom ; VS no. 2)
        B       SetVarValueBadExit_256Translate

        MakeErrorBlock VarNoRoom

SetVarVal_ValidateMacroValue
        MOV     R2, #0
13      CMP     R2, #255
        BGT     SetVarVal_GotValueToBufferButItsTooLong
        LDRB    R10, [R1, R2]           ; it's a macro: check for bad chars.
        ADD     R2, R2, #1
        CMP     R10, #31
        BGT     %BT13
        CMP     R10, #13
        CMPNE   R10, #10
        CMPNE   R10, #0
        BEQ     SetVarVal_GotValueToBuffer

        ADR     r0, ErrorBlock_BadMacVal
        B       SetVarValueBadExit_256Translate

        MakeErrorBlock BadMacVal

SetVarVal_BadVarName
        ADR     r0, ErrorBlock_BadVarNam ; VS no. 2)
        B       SetVarValueBadExit_256Translate

        MakeErrorBlock BadVarNam

SetVarVal_NodeNotFound
        CMP     R2, #0        ; no node for it, test whether deletion
        BPL     SetVarVal_MakeNewNode

        ADRL    r0, ErrorBlock_VarCantFind ; V set no. 1)
        B       SetVarValueBadExit_256Translate


SetVarVal_AssignNonCodeToCode
        CMP     R2, #0
        BMI     SetVarValueTestExit ; deletion's a NOP, when wrong type given
        LDR     R10, [stack, #2*4+256] ; get original type back
        CMP     R10, #VarType_Number
        BNE     %FT25
        MOV     R10, R0
        LDRB    R0, [R1], #1
        LDRB    R2, [R1], #1
        ORR     R0, R0, R2, LSL #8
        LDRB    R2, [R1], #1
        ORR     R0, R0, R2, LSL #16
        LDRB    R2, [R1], #1
        ORR     R0, R0, R2, LSL #24
        ADD     R1, stack, #0
        MOV     R2, #256
        SWI     XOS_BinaryToDecimal
        MOV     R0, R10        ; force string value.
25      ADDS    R4, R4, #4      ; skip type, add 3 , clear V
        MOV     lr, PC
        BIC     PC, R4, #3      ; complete align and call

; set thunk must take R1 ptr to value, R2 value length

        BVS     SetVarValueBadExit_256

SetVarValueTestExit
        ADD     stack, stack, #256
        LDR     R10, [stack, #2*4]
        TEQ     R10, #VarType_Code
        MOVEQ   R1,R0
        MOVEQ   R0,#0
        SWIEQ   XOS_SynchroniseCodeAreas  ; 'fraid so
        MOVEQ   R0,R1
        Pull    "R1, R2, R4, lr"
        TST     lr, #V_bit
        ADRNE   R0, ErrorBlock_VarTooLong
      [ International
        Push    "lr",NE
        BLNE    TranslateError
        Pull    "lr",NE
      ]
        ExitSWIHandler

        MakeErrorBlock VarTooLong

SetVarVal_AssignExpanded
        Push    "R0"
        MOV     R0, R1   ; ptr to expression
        ADD     R1, stack, #4
        MOV     R2, #256
        SWI     XOS_EvaluateExpression
        BVS     NarffExpression
        CMP     R1, #0   ; integer?
        MOVEQ   R4, #VarType_Number
        MOVNE   R4, #VarType_String
        BNE     %FT40
        ADD     R1, stack, #8
        STR     R2, [R1]
        MOV     R2, #3
40
        Pull    "R0"
        STR     R4, [stack, #2*4+256]  ; update original type
        B       SetVarVal_GotValueToBuffer


NarffExpression
        ADD     stack, stack, #256+4    ; discard an r0 and buffer
        Pull    "R1, R2, r4, lr"
        B       SLVK_SetV

SetVarVal_TypeNaff

        ADR     R0, ErrorBlock_BadVarType ; V set no. 4)
        B       SetVarValueBadExit_256Translate

        MakeErrorBlock BadVarType

VarBadStrErr
        Pull    "R1"

SetVarValueBadExit_256Translate
        BL      TranslateError

SetVarValueBadExit_256
        ADD     stack, stack, #256
        B       SetVarValueBadExit

SVStackFull
        ADRL    r0, ErrorBlock_StackFull
        BL      TranslateError

SetVarValueBadExit
        Pull    "R1, R2, R4, lr"
        B       SLVK_SetV
 ]
d1787 1
a1787 1
;    r0 -> (wildcard) name of varibale to find
a1792 1
 [ QuickIndex
a1793 3
 |
;    r12 = address of previous node
 ]
a1795 1
 [ QuickIndex
d1810 5
d1825 12
d1853 1
d1899 1
d1915 4
d1959 4
a1962 1
        ASSERT  VNameOff = 0
a1975 28
 |
VarFindIt Entry "r10,r11"

; validate R3 by looking down the chain to see if we find it.
; Crude, but effective!

        CMP     R3, #0
        BEQ     %FT03
        SUB     R3, R3, #VNameOff         ; step back to chain ptr
        LDR     R11, =VariableList
        LDR     R11, [R11]
02      CMP     R11, #0
        CMPNE   R11, R3
        LDRNE   R11, [R11, #VarLink]
        BNE     %BT02
        CMP     R11, #0
03      LDREQ   R3, =VariableList
01      MOV     R12, R3                  ; keep previous for creation
        LDR     R3, [R3, #VarLink]        ; step on
        CMP     R3, #0
        EXIT    EQ                      ; failed
        ADD     R4, R3, #VNameOff
        BL      WildMatch               ; trashes r10,r11
        BNE     %BT01
        ADDS    R3, R3, #VNameOff       ; get node ptr and set NE
        EXIT                            ; and back with got.
 ]

d2026 261
@


4.2
log
@Kernel merged
@
text
@d164 1
a164 1
        &    ReadClock
d203 7
d215 2
a216 5
        Push  "lr"       ; Subr to read hh:mm:ss from clock
        BL     ReadClock
        ADD    R0, R0, #16
        MOV    R2, #8
        Pull  "PC"
d218 2
d225 6
a230 4
        MOV    R10, #7
01      LDRB   R11, [R1, R10]
        STRB   R11, [R12, R10]
        SUBS   R10, R10, #1
d235 1
d238 4
d243 2
a244 5
        Push  "lr"       ; Subr to read yyyy from clock
        BL     ReadClock
        ADD    R0, R0, #11
        MOV    R2, #4
        Pull  "PC"
d246 40
a285 12
        MOV    R2, #3    ; no chars -1
        MOV    R4, #11   ; offset -1
SetYD   Push  "R0-R2, lr"
        BL     ReadClock
        MOV    R10, #15
        STRB   R10, [R0, #-1]
        ADD    R0, R0, R4
        LDR    R1, [stack, #4]
        LDR    R2, [stack, #8]
01      LDRB   R10, [R1, R2]
        STRB   R10, [R0, R2]
        SUBS   R2, R2, #1
d287 6
a292 2
        SUB    R1, R0, R4
        SUB    R1, R1, #1
d295 2
a296 1
        Pull  "R0-R2, PC"
d298 13
a310 5
ReadClock
        Push  "lr"
        GSVarGetWSpace       ; Subr to read ddd, nn mmm from clock
        ADD    R1, R12, #GSNameBuff+1
        MOV    R0, #0
d314 18
a331 6
        MOV    R0, R1
        MOV    R2, #10      ; no. of chars.
        Pull  "PC"
SetDate MOV    R2, #9
        MOV    R4, #0
        B      SetYD
d353 1
d355 6
d822 1
a822 1
       ; R2 Number of chars got, 
d864 1
a864 1
; Node format : Link, Name bytes, 0 terminator (so Write0able), type byte, 
d1206 1
a1206 1
 
@


4.2.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d195 1
d197 3
d285 1
d287 3
d655 1
d664 6
d724 1
d728 1
d911 1
d913 1
d969 1
d971 1
d996 1
d1000 3
d1069 1
d1073 1
d1942 1
d1946 1
@


4.2.2.2
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@d24 2
a25 10
;mjs performance enhancements for Ursula (ChocolateSysVars)
;
                          GBLL    SysVars_QuickContext
                          GBLL    SysVars_StickyNodes
SysVars_QuickContext      SETL    {TRUE} :LAND: ChocolateSysVars   ;avoid abysmal O(n*n) enumeration of vars
SysVars_StickyNodes       SETL    {TRUE} :LAND: ChocolateSysVars   ;attempt to avoid lots of SysHeap operations,
                                                                   ;especially grows and shrinks

SysVars_Vindex_NStart     * 256   ;initial no. of vars supported by index
SysVars_Vindex_NBump      *  32   ;additional no. of vars each time index size is bumped up
d27 2
a28 13
  [ SysVars_QuickContext
;
;format of block anchored at VariableList
;
                     ^   0
SysVars_LastContext  #   4                    ;last var table index for last context ptr returned, or -1 if invalid
SysVars_VTableOffset #   0
;
;immediately followed by table data as in old code:
;  1 word   = total number of variables (N)
;  N words  = ptrs to variable blocks (sorted table)
;
  ]
d30 2
a31 9
  [ SysVars_StickyNodes
SysVars_StickyNode_UnitSize *  32             ;quantise node size to multiples of this many bytes
                                              ;(must be multiple of 8, and power of 2)
SysVars_StickyNode_Log2US   *   5             ;Log2 of unit size
SysVars_StickyNode_MaxSize  * 320             ;maximum size of node that may stick (be retained on removal as active node)
;
;There are currently 10 words allocated in kernel workspace for sticky pointers
      ASSERT  SysVars_StickyNode_UnitSize*10 = SysVars_StickyNode_MaxSize 
  ]
a32 2
        GBLL                      DebugSysVars
DebugSysVars                      SETL {FALSE}
d53 5
a57 1
; VariableList---->sorted table of pointers to variable blocks (QuickIndex) - format as above
d61 1
a61 2
; Each variable is stored in one block in the system heap (block will be word aligned). The
; format of each block is:
d63 5
a67 2
; No. Bytes     Use
; N+1           Variable's name (length N, plus terminator).
d80 1
a80 1
; 3             Length (N)
d89 1
a89 1
; 3             Length (N)
d546 1
d554 10
d683 1
d689 3
d773 16
a821 4
 [ Oscli_QuickAliases
;  R0 in = -1 is special case: skip call to VarFindIt (r5,r6,r7 in supply r3,r4,r12)
 ]

a827 10
  [ Oscli_QuickAliases
        CMP     r0, #-1
        BNE     rvv_noqaspecialentry
        MOV     r3,r5
        MOV     r4,r6
        MOV     r12,r7
        B       rvv_qaspecialentry
rvv_noqaspecialentry
  ]

a830 3
  [ Oscli_QuickAliases
rvv_qaspecialentry
  ]
d856 1
d862 3
a893 1
  [ InternationaliseCommonSilentErrors
a894 3
  |
        SETV
  ]
d940 1
d942 3
a949 1
  [ InternationaliseCommonSilentErrors
a950 1
  ]
a975 1
  [ InternationaliseCommonSilentErrors
a977 3
  |
        BL      RVVError_R4isnameptr
  ]
a984 31
  [ :LNOT: InternationaliseCommonSilentErrors
RVVError_R4isnameptr ROUT
        Push    "r1-r4,lr"
        MOV     r0, #0
        LDR     r0, [r0, #CommonSilentError_ws]
        CMP     r0, #0          ;just in case
        ADREQ   r0, RVVNFError
        BEQ     %FT20
        CMP     r4,#0
        ADREQ   r4,RVVError_R4isnameptr_nullname
        LDR     r1, [r0]        ;offset to where we should copy name
        ADD     r1, r0, r1
        LDR     r2, [r0,#4]     ;max buffer size for name
        ADD     r0,r0,#8        ;r0 points to error block
10
        LDRB    r3,[r4],#1
        CMP     r2,#1
        MOVLS   r3,#0
        CMP     r3,#32
        MOVLOS  r3,#0
        STRB    r3,[r1],#1
        SUB     r2,r2,#1
        BNE     %BT10
20
        SETV
        Pull    "r1-r4,pc"
RVVError_R4isnameptr_nullname
        DCB     "<null>",0
        ALIGN
  ]

d1099 1
d1180 1
d1182 24
d1267 1
d1269 3
d1279 1
a1279 1
        MOV     r3, #0                  ;accumulator for length of things we know
a1286 3
;r3 is now name length +1 for terminator
        ADD     r3, r3, #1              ;add in 1 for the type byte

d1289 1
a1289 1
        ADDLO   r3, r3, #64             ; only an initial guess for the string type
d1326 1
d1328 3
d1332 1
a1332 6
        Push    "r0-r2"
  [ SysVars_StickyNodes
        ADD     r3,r3,#SysVars_StickyNode_UnitSize-1
        BIC     r3,r3,#SysVars_StickyNode_UnitSize-1  ;so we don't fight sticky routines over sizes
        BL      SysVars_ClaimVNode
  |
a1333 2
  ]
        Pull    "r0-r2",VS
d1335 1
d1340 1
a1340 3

        MOV     r4, r2
        LDR     r0,[sp]
a1347 3
        LDR     r1,[sp,#8]
        ADD     sp,sp,#12                      ; balances push r0-r2 above - value length (entry r2) now in r1

d1413 1
a1413 4
        MOV     r3, #64     ;should be a multiple of StickyNode_UnitSize if SysVars_StickyNodes TRUE
  [ SysVars_StickyNodes
        BL      SysVars_ExpandOrShrinkVNode
  |
a1414 1
  ]
a1424 3
  [ SysVars_StickyNodes
        SUB     r3, r3, #8              ; the amount we're allowed to use
  |
a1425 1
  ]
a1432 4
  [ SysVars_StickyNodes
        Push    "r4"
        ADD     r4, r4, #SysVars_StickyNode_UnitSize-1
        BIC     r4, r4, #SysVars_StickyNode_UnitSize-1  ;so we don't fight over sticky sizes
a1433 1
        Pull    "r4"
a1434 4
        BL      SysVars_ExpandOrShrinkVNode
  |
        SUB     r3, r4, r3
        MOV     r2, r5 
a1435 1
  ]
d1454 1
d1456 3
d1484 1
a1486 4
  [ SysVars_QuickContext
        TEQ     r10,#0
        ADDNE   r10,r10,#SysVars_VTableOffset
  ]
d1496 1
a1496 4
        MOV     r2, r6
  [ SysVars_StickyNodes
        BL      SysVars_FreeVNode
  |
a1497 1
  ]
d1512 2
a1513 9

  [ SysVars_QuickContext
        ; SysVars_Vindex_NStart nodes, 1 word for the count, plus data before table
        MOV     r3, #SysVars_Vindex_NStart*4
        ADD     r3, r3, #4+SysVars_VTableOffset
  |
        MOV     r3, #(10*4)+4                      ; 10 nodes and 1 word for the count
  ]
        BL      ClaimSysHeapNode                   ; this is not a variable node (its the index)
a1514 4
  [ SysVars_QuickContext
        MOV     r10,#-1
        STR     r10, [r2, #SysVars_LastContext]    ; initialise last context as invalid
  ]
d1525 2
a1526 7
  [ SysVars_QuickContext
        LDR     lr, [r10, #-(4+SysVars_VTableOffset)] ; Block length, from heap block
        SUB     lr, lr, #4+4+SysVars_VTableOffset     ; 4 for heap adjustment, 4 for entry count word, plus name buffer
  |
        LDR     lr, [r10, #-4]                        ; Block length, from heap block
        SUB     lr, lr, #4+4                          ; 4 for heap adjustment and 4 for entry count word
  ]
a1535 4
  [ SysVars_QuickContext
        SUB     r2, r10, #SysVars_VTableOffset
        MOV     r3, #SysVars_Vindex_NBump*4     ; room for SysVars_Vindex_NBump more nodes
  |
d1537 2
a1538 3
        MOV     r3, #40                         ; room for 10 more nodes
  ]
        BL      DoSysHeapOpWithExtension   ;not a variable node (expanding index)
a1544 3
  [ SysVars_QuickContext
        ADD     r10,r10,#SysVars_VTableOffset
  ]
d1575 12
d1597 1
d1606 1
a1608 3
  [ SysVars_QuickContext
        ADD     r10,r10,#SysVars_VTableOffset
  ]
d1619 1
a1619 4
        MOV     r2, r3
  [ SysVars_StickyNodes
        BL      SysVars_FreeVNode
  |
a1620 1
  ]
d1629 1
d1633 9
a1650 1
SetVarValBadExit_NoTranslate
d1657 1
a1657 1
        BL      FreeSysHeapNode         ;forget stickiness (return node to heap is best here)
d1665 1
a1665 1
        BL      FreeSysHeapNode         ;forget stickiness (return node to heap is best here)
d1676 296
d1981 1
a1981 1
;    r0 -> (wildcard) name of variable to find
d1987 1
d1989 3
d1994 1
a2008 5
  [ SysVars_QuickContext
        LDRNE   r12,[r9,#SysVars_LastContext]
        MOVEQ   r12,#-1                           ;r12 = var table index for last context, or -1 if notvalid/notthere
        ADDNE   r9,r9,#SysVars_VTableOffset
  ]
a2018 12

  [ SysVars_QuickContext
        ;massive short cut - see if context is the last context we returned
        CMP     r12, r8               ;if not valid, or higher than current number of vars, forget it
        BHI     %FT04
        LDR     lr, [r9, r12, ASL #2]
        CMP     lr, r3
        BEQ     %FT70
04
        ;no such luck - scan list anyway
  ]

a2034 1

a2079 1

a2094 4
  [ SysVars_QuickContext
        ASSERT  SysVars_LastContext = SysVars_VTableOffset - 4
        STRLS   r6, [r9, #-4]            ;save var table index for context we're returning, in LastContext
  ]
d2135 1
a2135 4
  [ SysVars_QuickContext
        ASSERT  SysVars_LastContext = SysVars_VTableOffset - 4
        STR     r12, [r9, #-4]          ;save var table index for context we're returning, in LastContext
  ]
d2149 28
a2226 261


  [ Oscli_QuickAliases

;routines to speed up alias checking for OS_CLI

;VarFindIt_QA - similar to VarFindIt
;
; In
;    r3 -> non-wildcarded, already upper-cased name of var to find
;          will be of form ALIAS$<whatever>
;
; Out
;    r5 = name pointer (equivalent to r3 for VarFindIt
;    r6 = pointer after name terminator (equivalent to r4 for VarFindIt)
;    r7 = insertion point (equivalent to r12 for VarFindIt)
;    NE if found, EQ if not found
;
VarFindIt_QA ROUT
        Push    "r0,r1,r2,r3,r4,r8,r9,r10,r11,LR"
        MOV     r0, r3
        LDR     r9, =VariableList
        LDR     r9, [r9]
        TEQ     r9,#0
        BEQ     %FT99             ;exit with EQ (not found)
  [ SysVars_QuickContext
        ADD     r9,r9,#SysVars_VTableOffset
  ]
        LDR     r8, [r9]

        ; do binary chop search
        ORRS    r7, r8, r8, LSR #1
        ORR     r7, r7, r7, LSR #2
        ORR     r7, r7, r7, LSR #4
        ORR     r7, r7, r7, LSR #8
        ORR     r7, r7, r7, LSR #16
        BICS    r7, r7, r7, LSR #1      ; least 2^n <= number of entries
        MOV     r6, #0

        B       %FT60
40
        ADD     r5, r6, r7
        CMP     r5, r8
        BHI     %FT55

        MOV     r1, r0
        LDR     r4, [r9, r5, ASL #2]

45
        LDRB    r2, [r1], #1
        CMP     r2, #" "
        MOVLS   r2, #0
        LDRB    r3, [r4], #1
        CMP     r3, #" "
        MOVLS   r3, #0
        UpperCase R3,LR
        CMP     r3, r2
        BNE     %FT50
        CMP     r3, #0
        BNE     %BT45

50
        MOVHS   r10, pc                 ; preserve last HS result we got
        MOVHS   r11, r4
        MOVLO   r6, r5
55
        MOVS    r7, r7, LSR #1
60
        BNE     %BT40

        ; We always want the element above.
        ; If r6<r8 then we want the preserved result
        ; else we want the result HI
        ADD     r6, r6, #1
        CMP     r6, r8
        LDRLS   r5, [r9, r6, ASL #2]
;don't want to save context in this version of routine
;  [ SysVars_QuickContext
;        ASSERT  SysVars_LastContext = SysVars_VTableOffset - 4
;        STRLS   r6, [r9, #-4]            ;save var table index for context we're returning, in LastContext
;  ]
        MOV     r7, r6
        MOVLS   r6, r11
        MOVHI   r5, #0
        TEQLSP  pc, r10

        MOV     lr, pc
        TEQP    lr, #Z_bit
99
        Pull    "r0,r1,r2,r3,r4,r8,r9,r10,r11,PC"


  ] ;Oscli_QuickAliases

  [ SysVars_StickyNodes
;
; SysVars_ClaimVNode
;
; entry: R3 = size required
; exit:  R2 = address of allocated node, or V set for error
;
; if R3  > max sticky size, just delegates to ClaimSysHeapNode
; if R3 <= max sticky size, rounds up to next unit size, and attempts to pick
;    up sticky node of that size - if not found, gets one from heap (now of size that can
;    stick on free)
;
SysVars_ClaimVNode ROUT
        Push    "r0,r1,r3,LR"
        CMP     r3,#SysVars_StickyNode_MaxSize
        BHI     %FT80                                         ;too big for sticky node
        ADD     r3,r3,#SysVars_StickyNode_UnitSize-1
        BIC     r3,r3,#SysVars_StickyNode_UnitSize-1          ;round up to unit size
        MOV     r1,#SysVars_StickyPointers
        LDR     r2,[r1,r3,LSR #(SysVars_StickyNode_Log2US-2)] ;sticky pointer for this size
        CMP     r2,#0                                         ;also clears V
        BEQ     %FT80
        MOV     LR,#0
        STR     LR,[r1,r3,LSR #(SysVars_StickyNode_Log2US-2)] ;used it
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        MOV     r0,#0
        LDR     r1,[r0,#mjsSHNT_vcs_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_vcs_total]
        Pull    "r0-r2"
  ]
        Pull    "r0,r1,r3,PC"
80      BL      ClaimSysHeapNode
        STRVS   r0,[SP]
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        MOV     r0,#0
        LDR     r1,[r0,#mjsSHNT_vch_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_vch_total]
        Pull    "r0-r2"
  ]
        Pull    "r0,r1,r3,PC"

;
; SysVars_FreeVNode
;
; entry: R2 = address of node to free (must be valid)
; exit:  -
;        OR V set, error
;
; - checks size of node (uses internal knowledge of Heap blocks - naughty!)
; - if size is a sticky size, and the corresponding sticky pointer is 0, retains it,
;   else delegates to FreeSysHeapNode
;
SysVars_FreeVNode
        Push    "r0,r1,r3,LR"
        LDR     r1,[r2,#-4]                                   ;pick up OS_Heap's size word
        SUB     r1,r1,#8                                      ;sticky sizes will be 8 less than heap sizes
        CMP     r1,#SysVars_StickyNode_MaxSize                ;is it too big?
        BHI     %FT80
        TST     r1,#SysVars_StickyNode_UnitSize-1             ;is it a multiple of unit size
        BNE     %FT80
        MOV     r3,#SysVars_StickyPointers
        LDR     LR,[r3,r1,LSR #(SysVars_StickyNode_Log2US-2)] ;sticky pointer for this size
        CMP     LR,#0
        STREQ   r2,[r3,r1,LSR #(SysVars_StickyNode_Log2US-2)] ;stick!
80
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        MOV     r0,#0
        LDREQ   r1,[r0,#mjsSHNT_vfs_total]
        LDRNE   r1,[r0,#mjsSHNT_vfh_total]
        ADD     r1,r1,#1
        STREQ   r1,[r0,#mjsSHNT_vfs_total]
        STRNE   r1,[r0,#mjsSHNT_vfh_total]
        Pull    "r0-r2"
  ]
        BLNE    FreeSysHeapNode
        STRVS   r0,[SP]
        Pull    "r0,r1,r3,PC"

;
; SysVars_ExpandOrShrinkVNode
;
; entry: R2 = address of block
;        R3 = change of size required in bytes (signed integer)
; exit:  R2 = address of block, which may have changed (block moved/copied)
;        OR V set, error returned
;
; - checks size of node (uses internal knowledge of Heap blocks - naughty!)
; - assumes all VNodes currently less than MaxSize and of sticky size *must* be stickily
;   allocated nodes (so that maximum current size that could be presumed by client is heap
;   size minus 8, rather than minus 4)
; - if new size is small enough to be a sticky node, attempts to return a sticky node,
;   without doing an OS_Heap grow or shrink, else delegates to DoSysHeapOpWithExtension
;
SysVars_ExpandOrShrinkVNode
        Push    "r0,r1,r3-r6,LR"
        LDR     r5,[r2,#-4]                                   ;pick up OS_Heap's size word
        SUB     r5,r5,#4                                      ;usable sizes are 4 less than heap sizes
        ADD     r4,r5,r3                                      ;putative new size
        CMP     r4,#SysVars_StickyNode_MaxSize                ;is it too big?
        BHI     %FT90
        SUB     r6,r5,#4                                      ;sticky sizes will be 8 less than heap sizes
        SUB     r4,r4,#4
        ADD     r4,r4,#SysVars_StickyNode_UnitSize-1
        BIC     r4,r4,#SysVars_StickyNode_UnitSize-1          ;round up to unit size
        CMP     r4,r6                                         ;same as current size?
        BEQ     %FT55
        MOV     r1,#SysVars_StickyPointers
        LDR     LR,[r1,r4,LSR #(SysVars_StickyNode_Log2US-2)] ;sticky pointer for this size
        CMP     LR,#0
        BEQ     %FT40
        MOV     r3,#0
        STR     r3,[r1,r4,LSR #(SysVars_StickyNode_Log2US-2)] ;used it
        MOV     r5,r2
        MOV     r2,LR
        B       %FT50
40
        MOV     r5,r2
        MOV     r3,r4
        BL      SysVars_ClaimVNode
        BVS     %FT95
50      ;copy min(r6,r4) bytes (multiple of 8) from old node at r5 to new node at r2
        CMP     r4,r6
        MOVLO   r6,r4
        MOV     r3,r2
        MOV     LR,r5
52
        LDMIA   LR!,{r0,r1}
        STMIA   r3!,{r0,r1}
        SUBS    r6,r6,#8
        BGT     %BT52
        MOV     r6,r2
        MOV     r2,r5
        BL      SysVars_FreeVNode
        MOV     r2,r6
        BVS     %FT95  
55
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        MOV     r0,#0
        LDR     r1,[r0,#mjsSHNT_vxs_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_vxs_total]
        Pull    "r0-r2"
  ]
        CLRV
        Pull    "r0,r1,r3-r6,PC"
90
  [ mjsSysHeapNodesTrace
        Push    "r0-r2"
        MOV     r0,#0
        LDR     r1,[r0,#mjsSHNT_vxh_total]
        ADD     r1,r1,#1
        STR     r1,[r0,#mjsSHNT_vxh_total]
        Pull    "r0-r2"
  ]
        MOV     r0,#HeapReason_ExtendBlock
        BL      DoSysHeapOpWithExtension
95
        STRVS   r0,[SP]
        Pull    "r0,r1,r3-r6,PC"

  ] ;SysVars_StickyNodes
@


4.2.2.3
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a1181 9

  [ LongCommandLines
        MOV     r0, stack, LSR #20      ; SVC stack base assumed on 1M boundary
        SUB     r0, sp, r0, LSL #20     ; amount of stack left
        CMP     r0, #LongCLISize + 2048 ; insist on 2k left after long buffer
        MOVHS   r2, #LongCLISize        ; ok, got a long buffer
        MOVLO   r2, #256                ; stack full-ish, use a 256 buffer and hope it's big enough
        SUB     stack, stack, r2
  |
a1182 2
        MOV     r2, #256
  ]
d1186 1
d1236 4
a1241 3
        SUB     stack, stack, #256   ;buffer
        MOV     r2, #256

a1255 12

  [ LongCommandLines
        MOV     r0, stack, LSR #20      ; SVC stack base assumed on 1M boundary
        SUB     r0, sp, r0, LSL #20     ; amount of stack left
        CMP     r0, #LongCLISize + 2048 ; insist on 2k left after long buffer
        MOVHS   r2, #LongCLISize        ; ok, got a long buffer
        MOVLO   r2, #256                ; stack full-ish, use a 256 buffer and hope it's big enough
        SUB     stack, stack, r2
  |
        SUB     stack, stack, #256
        MOV     r2, #256
  ]
@


4.1
log
@Initial revision
@
text
@d1933 6
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Changes to cope with territories where %w3, %dy or %m3 are not the normal
lengths. To wit:

* Code variables Sys$Time, Sys$Date, Sys$Year don't assume field lengths.
* *Time doesn't assume OS_Word 14,0 output length is 24.
* OS_ConvertStandardDateAndTime now really does call the Territory Manager.
* OS_Word 14,0 no longer gives a maximum buffer length of 24 when calling
  OS_ConvertDateAndTime.
* OS_Word 15 doesn't assume reason code = length of string - attempt is
  made to terminate based on maximum string length, but callers really should
  be supplied control-terminated strings. Other offending modules (eg BASIC)
  have been fixed where spotted.
@
text
@d164 1
a164 1
        &    ReadDate
a202 7
SysTimeFormat
        =     "%24:%mi:%se", 0
SysDateFormat
        =     "%w3,%dy %m3", 0
SysYearFormat
        =     "%ce%yr", 0

d208 5
a212 2
        ADR    R0, SysTimeFormat
        B      ReadTimeFormatted
a213 2
        CMP    R2, #&FE
        BHI    TimeVarTooLong
d219 4
a222 6
        MOV    R10, #0
        STRB   R10, [R12, R2]
        MOV    R10, R2
01      SUBS   R10, R10, #1
        LDRPLB R11, [R1, R10]
        STRPLB R11, [R12, R10]
a226 1
        STRVS  R0, [R13]
a228 4
TimeVarTooLong
        ADRL   R0, ErrorBlock_VarTooLong
        ORRS   PC, LR, #V_bit

d230 5
a234 2
        ADR    R0, SysYearFormat
        B      ReadTimeFormatted
d236 12
a247 15
        CMP    R2, #4
        BHI    TimeVarTooLong
        Push  "R0, lr"
        Push  "R1,R2"
        ADR    R0, SetYearPrefixFormat
        BL     ReadTimeFormatted
        ADD    R12, R0, R2              ; R12 -> position to copy year to
        Pull  "R1,R2"
        BVS    %FT02
        MOV    R10, #0
        STRB   R10, [R12, R2]
        MOV    R10, R2
01      SUBS   R10, R10, #1
        LDRPLB R11, [R1, R10]
        STRPLB R11, [R12, R10]
d249 2
a250 1
        SUB    R1, R0, #1
a251 1
        STRB   R0, [R1]
d253 1
a253 2
02      STRVS  R0, [R13]
        Pull  "R0, PC"
d255 5
a259 44
ReadDate
        ADR    R0, SysDateFormat
        B      ReadTimeFormatted
SetDate ROUT
        CMP    R2, #&F8
        BHI    TimeVarTooLong
        Push  "R0, lr"
        GSVarGetWSpace
        ADD    R12, R12, #GSNameBuff
        MOV    R11, #15
        STRB   R11, [R12], #1
        MOV    R10, #0
        STRB   R10, [R12, R2]
        MOV    R10, R2
01      SUBS   R10, R10, #1
        LDRPLB R11, [R1, R10]
        STRPLB R11, [R12, R10]
        BPL    %BT01
        ADD    R1, R12, R2
        ADR    R0, SetDateSuffixFormat          ; append year to supplied date
        Push  "R12"
        BL     ReadTimeFormattedAtR1
        Pull  "R12"
        SUB    R1, R12, #1
        MOV    R0, R1
        SWI    XOS_Write0
        MOV    R0, #15
        SWI    XOS_Word
        STRVS  R0, [R13]
        Pull  "R0, PC"


; in: R0 = format string
; out: R0 -> time string (0 terminated)
;      R2 = length of string (excluding terminator)
;      R1 corrupt
ReadTimeFormatted ROUT
        Push  "R3,R4,LR"
        GSVarGetWSpace
        ADD    R2, R12, #GSNameBuff+1   ; This code copied from OsWord0EAlpha
01      MOV    R4, R0
        SUB    R13, R13, #8
        MOV    R1, R13
        MOV    R0, #3
d263 6
a268 18
        BVS    %FT02
        MOV    R0, #-1
        MOV    R1, R13
        MOV    R3, #?GSNameBuff-1
        SWI    XTerritory_ConvertDateAndTime
02      ADD    R13, R13, #8
        SUBVC  R2, R1, R0
        Pull  "R3,R4,PC"

; in: R0 = format string
;     R1 -> output buffer
; out: R0 -> time string (0 terminated)
;      R1 corrupt
;      R2 = length of string (excluding terminator)
ReadTimeFormattedAtR1
        Push  "R3,R4,LR"
        MOV    R2, R1
        B      %BT01
a289 1

a290 6
SetYearPrefixFormat
        =     "%w3, %dy-%m3-", 0
SetDateSuffixFormat
        =     "-%ce%yr", 0
        ALIGN

d752 1
a752 1
       ; R2 Number of chars got,
d794 1
a794 1
; Node format : Link, Name bytes, 0 terminator (so Write0able), type byte,
d1136 1
a1136 1

@


4.1.7.3
log
@Oops - left a bit of debugging in
@
text
@d293 2
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a1932 6
        LDR     R10, [stack, #2*4]
        TEQ     R10, #VarType_Code
        MOVEQ   R1,R0
        MOVEQ   R0,#0
        SWIEQ   XOS_SynchroniseCodeAreas  ; 'fraid so
        MOVEQ   R0,R1
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

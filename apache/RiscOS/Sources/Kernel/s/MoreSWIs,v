head	4.5;
access;
symbols
	Kernel-6_15:4.5
	Kernel-6_14:4.5
	Kernel-6_01-3:4.5
	Kernel-6_13:4.5
	Kernel-6_12:4.5
	Kernel-6_11:4.5
	Kernel-6_10:4.5
	Kernel-6_09:4.5
	Kernel-6_08-4_129_2_10:4.5
	Kernel-6_08-4_129_2_9:4.5
	Kernel-6_08:4.5
	Kernel-6_07:4.5
	Kernel-6_06:4.5
	Kernel-6_05-4_129_2_8:4.5
	Kernel-6_05:4.5
	Kernel-6_04:4.5
	Kernel-6_03:4.5
	Kernel-6_01-2:4.5
	Kernel-6_01-4_146_2_1:4.5
	Kernel-6_02:4.5
	Kernel-6_01-1:4.5
	Kernel-6_01:4.5
	Kernel-6_00:4.5
	Kernel-5_99:4.5
	Kernel-5_98:4.5
	Kernel-5_97-4_129_2_7:4.5
	Kernel-5_97:4.5
	Kernel-5_96:4.5
	Kernel-5_95:4.5
	Kernel-5_94:4.5
	Kernel-5_93:4.5
	Kernel-5_92:4.5
	Kernel-5_91:4.5
	Kernel-5_90:4.5
	Kernel-5_89-4_129_2_6:4.5
	Kernel-5_89:4.5
	Kernel-5_88-4_129_2_5:4.5
	Kernel-5_88-4_129_2_4:4.5
	Kernel-5_88:4.5
	Kernel-5_87:4.5
	Kernel-5_86-4_129_2_3:4.5
	Kernel-5_86-4_129_2_2:4.5
	Kernel-5_86-4_129_2_1:4.5
	Kernel-5_86:4.5
	SMP:4.5.0.2
	SMP_bp:4.5
	Kernel-5_85:4.5
	Kernel-5_54-1:4.5
	Kernel-5_84:4.5
	Kernel-5_83:4.5
	Kernel-5_82:4.5
	Kernel-5_81:4.5
	Kernel-5_80:4.5
	Kernel-5_79:4.5
	Kernel-5_78:4.5
	Kernel-5_77:4.5
	Kernel-5_76:4.5
	Kernel-5_75:4.5
	Kernel-5_74:4.5
	Kernel-5_73:4.5
	Kernel-5_72:4.5
	Kernel-5_71:4.5
	Kernel-5_70:4.5
	Kernel-5_69:4.5
	Kernel-5_68:4.5
	Kernel-5_67:4.5
	Kernel-5_66:4.5
	Kernel-5_65:4.5
	Kernel-5_64:4.5
	Kernel-5_63:4.5
	Kernel-5_62:4.5
	Kernel-5_61:4.5
	Kernel-5_60:4.5
	Kernel-5_59:4.5
	Kernel-5_58:4.5
	Kernel-5_57:4.5
	Kernel-5_56:4.5
	Kernel-5_55:4.5
	Kernel-5_54:4.5
	Kernel-5_53:4.5
	Kernel-5_52:4.5
	Kernel-5_51:4.5
	Kernel-5_50:4.5
	Kernel-5_49:4.5
	HAL_merge:4.3.2.10
	Kernel-5_48:4.4
	Kernel-5_35-4_79_2_327:4.3.2.10
	Kernel-5_35-4_79_2_326:4.3.2.10
	Kernel-5_35-4_79_2_325:4.3.2.10
	Kernel-5_35-4_79_2_324:4.3.2.10
	Kernel-5_35-4_79_2_323:4.3.2.10
	Kernel-5_35-4_79_2_322:4.3.2.10
	Kernel-5_35-4_79_2_321:4.3.2.10
	Kernel-5_35-4_79_2_320:4.3.2.10
	Kernel-5_35-4_79_2_319:4.3.2.10
	Kernel-5_35-4_79_2_318:4.3.2.10
	Kernel-5_35-4_79_2_317:4.3.2.10
	Kernel-5_35-4_79_2_316:4.3.2.10
	Kernel-5_35-4_79_2_315:4.3.2.10
	Kernel-5_35-4_79_2_314:4.3.2.10
	Kernel-5_35-4_79_2_313:4.3.2.10
	Kernel-5_35-4_79_2_312:4.3.2.10
	Kernel-5_35-4_79_2_311:4.3.2.10
	Kernel-5_35-4_79_2_310:4.3.2.10
	Kernel-5_35-4_79_2_309:4.3.2.10
	Kernel-5_35-4_79_2_308:4.3.2.10
	Kernel-5_35-4_79_2_307:4.3.2.10
	Kernel-5_35-4_79_2_306:4.3.2.10
	Kernel-5_35-4_79_2_305:4.3.2.10
	Kernel-5_35-4_79_2_304:4.3.2.10
	Kernel-5_35-4_79_2_303:4.3.2.10
	Kernel-5_35-4_79_2_302:4.3.2.10
	Kernel-5_35-4_79_2_301:4.3.2.10
	Kernel-5_35-4_79_2_300:4.3.2.10
	Kernel-5_35-4_79_2_299:4.3.2.10
	Kernel-5_35-4_79_2_298:4.3.2.10
	Kernel-5_35-4_79_2_297:4.3.2.10
	Kernel-5_35-4_79_2_296:4.3.2.10
	Kernel-5_35-4_79_2_295:4.3.2.10
	Kernel-5_35-4_79_2_294:4.3.2.10
	Kernel-5_35-4_79_2_293:4.3.2.10
	Kernel-5_35-4_79_2_292:4.3.2.10
	Kernel-5_35-4_79_2_291:4.3.2.10
	Kernel-5_35-4_79_2_290:4.3.2.10
	Kernel-5_35-4_79_2_289:4.3.2.10
	Kernel-5_35-4_79_2_288:4.3.2.10
	Kernel-5_35-4_79_2_287:4.3.2.10
	Kernel-5_35-4_79_2_286:4.3.2.10
	Kernel-5_35-4_79_2_285:4.3.2.10
	Kernel-5_35-4_79_2_284:4.3.2.10
	Kernel-5_35-4_79_2_283:4.3.2.10
	Kernel-5_35-4_79_2_282:4.3.2.10
	Kernel-5_35-4_79_2_281:4.3.2.10
	Kernel-5_35-4_79_2_280:4.3.2.10
	Kernel-5_35-4_79_2_279:4.3.2.10
	Kernel-5_35-4_79_2_278:4.3.2.10
	Kernel-5_35-4_79_2_277:4.3.2.10
	Kernel-5_35-4_79_2_276:4.3.2.10
	Kernel-5_35-4_79_2_275:4.3.2.10
	Kernel-5_35-4_79_2_274:4.3.2.10
	Kernel-5_35-4_79_2_273:4.3.2.10
	Kernel-5_35-4_79_2_272:4.3.2.10
	Kernel-5_35-4_79_2_271:4.3.2.10
	Kernel-5_35-4_79_2_270:4.3.2.10
	Kernel-5_35-4_79_2_269:4.3.2.10
	Kernel-5_35-4_79_2_268:4.3.2.10
	Kernel-5_35-4_79_2_267:4.3.2.10
	Kernel-5_35-4_79_2_266:4.3.2.10
	Kernel-5_35-4_79_2_265:4.3.2.10
	Kernel-5_35-4_79_2_264:4.3.2.10
	Kernel-5_35-4_79_2_263:4.3.2.10
	Kernel-5_35-4_79_2_262:4.3.2.10
	Kernel-5_35-4_79_2_261:4.3.2.10
	Kernel-5_35-4_79_2_260:4.3.2.10
	Kernel-5_35-4_79_2_259:4.3.2.10
	Kernel-5_35-4_79_2_258:4.3.2.10
	Kernel-5_35-4_79_2_257:4.3.2.10
	Kernel-5_35-4_79_2_256:4.3.2.10
	Kernel-5_35-4_79_2_255:4.3.2.10
	Kernel-5_35-4_79_2_254:4.3.2.10
	Kernel-5_35-4_79_2_253:4.3.2.10
	Kernel-5_35-4_79_2_252:4.3.2.10
	Kernel-5_35-4_79_2_251:4.3.2.10
	Kernel-5_35-4_79_2_250:4.3.2.10
	Kernel-5_35-4_79_2_249:4.3.2.10
	Kernel-5_35-4_79_2_248:4.3.2.10
	Kernel-5_35-4_79_2_247:4.3.2.10
	Kernel-5_35-4_79_2_246:4.3.2.10
	Kernel-5_35-4_79_2_245:4.3.2.10
	Kernel-5_35-4_79_2_244:4.3.2.10
	Kernel-5_35-4_79_2_243:4.3.2.10
	Kernel-5_35-4_79_2_242:4.3.2.10
	Kernel-5_35-4_79_2_241:4.3.2.10
	Kernel-5_35-4_79_2_240:4.3.2.10
	Kernel-5_35-4_79_2_239:4.3.2.10
	Kernel-5_35-4_79_2_238:4.3.2.10
	Kernel-5_35-4_79_2_237:4.3.2.10
	Kernel-5_35-4_79_2_236:4.3.2.10
	Kernel-5_35-4_79_2_235:4.3.2.10
	Kernel-5_35-4_79_2_234:4.3.2.10
	Kernel-5_35-4_79_2_233:4.3.2.10
	Kernel-5_35-4_79_2_232:4.3.2.10
	Kernel-5_35-4_79_2_231:4.3.2.10
	Kernel-5_35-4_79_2_230:4.3.2.10
	Kernel-5_35-4_79_2_229:4.3.2.10
	Kernel-5_35-4_79_2_228:4.3.2.10
	Kernel-5_35-4_79_2_227:4.3.2.10
	Kernel-5_35-4_79_2_226:4.3.2.10
	Kernel-5_35-4_79_2_225:4.3.2.10
	Kernel-5_35-4_79_2_224:4.3.2.10
	Kernel-5_35-4_79_2_223:4.3.2.10
	Kernel-5_35-4_79_2_222:4.3.2.10
	Kernel-5_35-4_79_2_221:4.3.2.10
	Kernel-5_35-4_79_2_220:4.3.2.10
	Kernel-5_35-4_79_2_219:4.3.2.10
	Kernel-5_35-4_79_2_218:4.3.2.10
	Kernel-5_35-4_79_2_217:4.3.2.10
	Kernel-5_35-4_79_2_216:4.3.2.10
	Kernel-5_35-4_79_2_215:4.3.2.10
	Kernel-5_35-4_79_2_214:4.3.2.10
	Kernel-5_35-4_79_2_213:4.3.2.10
	Kernel-5_35-4_79_2_212:4.3.2.10
	Kernel-5_35-4_79_2_211:4.3.2.10
	Kernel-5_35-4_79_2_210:4.3.2.10
	Kernel-5_35-4_79_2_209:4.3.2.10
	Kernel-5_35-4_79_2_208:4.3.2.10
	Kernel-5_35-4_79_2_207:4.3.2.10
	Kernel-5_35-4_79_2_206:4.3.2.10
	Kernel-5_35-4_79_2_205:4.3.2.10
	Kernel-5_35-4_79_2_204:4.3.2.9
	Kernel-5_35-4_79_2_203:4.3.2.9
	Kernel-5_35-4_79_2_202:4.3.2.9
	Kernel-5_35-4_79_2_201:4.3.2.9
	Kernel-5_35-4_79_2_200:4.3.2.9
	Kernel-5_35-4_79_2_199:4.3.2.9
	Kernel-5_35-4_79_2_198:4.3.2.9
	Kernel-5_35-4_79_2_197:4.3.2.9
	Kernel-5_35-4_79_2_196:4.3.2.9
	Kernel-5_35-4_79_2_195:4.3.2.9
	Kernel-5_35-4_79_2_194:4.3.2.9
	Kernel-5_35-4_79_2_193:4.3.2.9
	Kernel-5_35-4_79_2_192:4.3.2.9
	Kernel-5_35-4_79_2_191:4.3.2.9
	Kernel-5_35-4_79_2_190:4.3.2.9
	Kernel-5_35-4_79_2_189:4.3.2.9
	Kernel-5_35-4_79_2_188:4.3.2.9
	Kernel-5_35-4_79_2_187:4.3.2.9
	Kernel-5_35-4_79_2_186:4.3.2.9
	Kernel-5_35-4_79_2_185:4.3.2.9
	Kernel-5_35-4_79_2_184:4.3.2.9
	Kernel-5_35-4_79_2_183:4.3.2.9
	Kernel-5_35-4_79_2_182:4.3.2.9
	Kernel-5_35-4_79_2_181:4.3.2.9
	Kernel-5_35-4_79_2_180:4.3.2.9
	Kernel-5_35-4_79_2_179:4.3.2.9
	Kernel-5_35-4_79_2_178:4.3.2.9
	Kernel-5_35-4_79_2_177:4.3.2.9
	Kernel-5_35-4_79_2_176:4.3.2.9
	Kernel-5_35-4_79_2_175:4.3.2.9
	Kernel-5_35-4_79_2_174:4.3.2.9
	Kernel-5_35-4_79_2_173:4.3.2.8
	Kernel-5_35-4_79_2_172:4.3.2.8
	Kernel-5_35-4_79_2_171:4.3.2.8
	Kernel-5_35-4_79_2_170:4.3.2.8
	Kernel-5_35-4_79_2_169:4.3.2.8
	Kernel-5_35-4_79_2_168:4.3.2.8
	Kernel-5_35-4_79_2_167:4.3.2.8
	Kernel-5_35-4_79_2_166:4.3.2.8
	Kernel-5_35-4_79_2_165:4.3.2.8
	RPi_merge:4.3.2.8
	Kernel-5_35-4_79_2_147_2_23:4.3.2.8
	Kernel-5_35-4_79_2_147_2_22:4.3.2.8
	Kernel-5_35-4_79_2_147_2_21:4.3.2.8
	Kernel-5_35-4_79_2_147_2_20:4.3.2.8
	Kernel-5_35-4_79_2_147_2_19:4.3.2.8
	Kernel-5_35-4_79_2_147_2_18:4.3.2.8
	Kernel-5_35-4_79_2_164:4.3.2.8
	Kernel-5_35-4_79_2_163:4.3.2.8
	Kernel-5_35-4_79_2_147_2_17:4.3.2.8
	Kernel-5_35-4_79_2_147_2_16:4.3.2.8
	Kernel-5_35-4_79_2_147_2_15:4.3.2.8
	Kernel-5_35-4_79_2_162:4.3.2.8
	Kernel-5_35-4_79_2_161:4.3.2.8
	Kernel-5_35-4_79_2_147_2_14:4.3.2.8
	Kernel-5_35-4_79_2_147_2_13:4.3.2.8
	Kernel-5_35-4_79_2_160:4.3.2.8
	Kernel-5_35-4_79_2_159:4.3.2.8
	Kernel-5_35-4_79_2_158:4.3.2.8
	Kernel-5_35-4_79_2_157:4.3.2.8
	Kernel-5_35-4_79_2_156:4.3.2.8
	Kernel-5_35-4_79_2_147_2_12:4.3.2.8
	Kernel-5_35-4_79_2_147_2_11:4.3.2.8
	Kernel-5_35-4_79_2_155:4.3.2.8
	Kernel-5_35-4_79_2_147_2_10:4.3.2.8
	Kernel-5_35-4_79_2_154:4.3.2.8
	Kernel-5_35-4_79_2_153:4.3.2.8
	Kernel-5_35-4_79_2_147_2_9:4.3.2.8
	Kernel-5_35-4_79_2_152:4.3.2.8
	Kernel-5_35-4_79_2_151:4.3.2.8
	Kernel-5_35-4_79_2_147_2_8:4.3.2.8
	Kernel-5_35-4_79_2_147_2_7:4.3.2.8
	Kernel-5_35-4_79_2_150:4.3.2.8
	Kernel-5_35-4_79_2_147_2_6:4.3.2.8
	Kernel-5_35-4_79_2_147_2_5:4.3.2.8
	Kernel-5_35-4_79_2_149:4.3.2.8
	Kernel-5_35-4_79_2_147_2_4:4.3.2.8
	Kernel-5_35-4_79_2_147_2_3:4.3.2.8
	Kernel-5_35-4_79_2_148:4.3.2.8
	Kernel-5_35-4_79_2_147_2_2:4.3.2.8
	Kernel-5_35-4_79_2_147_2_1:4.3.2.8
	RPi:4.3.2.8.0.2
	RPi_bp:4.3.2.8
	Kernel-5_35-4_79_2_98_2_52_2_1:4.3.2.5.2.1
	alees_Kernel_dev:4.3.2.5.2.1.0.2
	alees_Kernel_dev_bp:4.3.2.5.2.1
	Kernel-5_35-4_79_2_147:4.3.2.8
	Kernel-5_35-4_79_2_146:4.3.2.8
	Kernel-5_35-4_79_2_145:4.3.2.8
	Kernel-5_35-4_79_2_144:4.3.2.8
	Kernel-5_35-4_79_2_143:4.3.2.8
	Kernel-5_35-4_79_2_142:4.3.2.8
	Kernel-5_35-4_79_2_141:4.3.2.8
	Kernel-5_35-4_79_2_140:4.3.2.8
	Kernel-5_35-4_79_2_139:4.3.2.8
	Kernel-5_35-4_79_2_138:4.3.2.8
	Kernel-5_35-4_79_2_137:4.3.2.8
	Kernel-5_35-4_79_2_136:4.3.2.8
	Kernel-5_35-4_79_2_135:4.3.2.8
	Kernel-5_35-4_79_2_134:4.3.2.8
	Kernel-5_35-4_79_2_133:4.3.2.8
	Kernel-5_35-4_79_2_132:4.3.2.7
	Kernel-5_35-4_79_2_131:4.3.2.7
	Kernel-5_35-4_79_2_130:4.3.2.7
	Kernel-5_35-4_79_2_129:4.3.2.7
	Kernel-5_35-4_79_2_128:4.3.2.7
	Kernel-5_35-4_79_2_127:4.3.2.7
	Kernel-5_35-4_79_2_126:4.3.2.6
	Kernel-5_35-4_79_2_125:4.3.2.6
	Kernel-5_35-4_79_2_124:4.3.2.6
	Kernel-5_35-4_79_2_123:4.3.2.6
	Cortex_merge:4.3.2.5.2.2
	Kernel-5_35-4_79_2_122:4.3.2.5
	Kernel-5_35-4_79_2_98_2_54:4.3.2.5.2.2
	Kernel-5_35-4_79_2_98_2_53:4.3.2.5.2.2
	Kernel-5_35-4_79_2_98_2_52:4.3.2.5.2.1
	Kernel-5_35-4_79_2_98_2_51:4.3.2.5.2.1
	Kernel-5_35-4_79_2_98_2_50:4.3.2.5.2.1
	Kernel-5_35-4_79_2_98_2_49:4.3.2.5.2.1
	Kernel-5_35-4_79_2_98_2_48:4.3.2.5.2.1
	Kernel-5_35-4_79_2_121:4.3.2.5
	Kernel-5_35-4_79_2_98_2_47:4.3.2.5
	Kernel-5_35-4_79_2_120:4.3.2.5
	Kernel-5_35-4_79_2_98_2_46:4.3.2.5
	Kernel-5_35-4_79_2_119:4.3.2.5
	Kernel-5_35-4_79_2_98_2_45:4.3.2.5
	Kernel-5_35-4_79_2_98_2_44:4.3.2.5
	Kernel-5_35-4_79_2_118:4.3.2.5
	Kernel-5_35-4_79_2_98_2_43:4.3.2.5
	Kernel-5_35-4_79_2_117:4.3.2.5
	Kernel-5_35-4_79_2_116:4.3.2.5
	Kernel-5_35-4_79_2_98_2_42:4.3.2.5
	Kernel-5_35-4_79_2_115:4.3.2.5
	Kernel-5_35-4_79_2_98_2_41:4.3.2.5
	Kernel-5_35-4_79_2_98_2_40:4.3.2.5
	Kernel-5_35-4_79_2_114:4.3.2.5
	Kernel-5_35-4_79_2_98_2_39:4.3.2.5
	Kernel-5_35-4_79_2_98_2_38:4.3.2.5
	Kernel-5_35-4_79_2_113:4.3.2.5
	Kernel-5_35-4_79_2_112:4.3.2.5
	Kernel-5_35-4_79_2_98_2_37:4.3.2.5
	Kernel-5_35-4_79_2_98_2_36:4.3.2.5
	Kernel-5_35-4_79_2_98_2_35:4.3.2.5
	Kernel-5_35-4_79_2_98_2_34:4.3.2.5
	Kernel-5_35-4_79_2_98_2_33:4.3.2.5
	Kernel-5_35-4_79_2_98_2_32:4.3.2.5
	Kernel-5_35-4_79_2_98_2_31:4.3.2.5
	Kernel-5_35-4_79_2_98_2_30:4.3.2.5
	Kernel-5_35-4_79_2_98_2_29:4.3.2.5
	Kernel-5_35-4_79_2_98_2_28:4.3.2.5
	Kernel-5_35-4_79_2_98_2_27:4.3.2.5
	Kernel-5_35-4_79_2_98_2_26:4.3.2.5
	Kernel-5_35-4_79_2_111:4.3.2.5
	Kernel-5_35-4_79_2_98_2_25:4.3.2.5
	Kernel-5_35-4_79_2_98_2_24:4.3.2.5
	Kernel-5_35-4_79_2_98_2_23:4.3.2.5
	Kernel-5_35-4_79_2_110:4.3.2.5
	Kernel-5_35-4_79_2_98_2_22:4.3.2.5
	Kernel-5_35-4_79_2_109:4.3.2.5
	Kernel-5_35-4_79_2_98_2_21:4.3.2.5
	Kernel-5_35-4_79_2_98_2_20:4.3.2.5
	Kernel-5_35-4_79_2_108:4.3.2.5
	Kernel-5_35-4_79_2_107:4.3.2.5
	Kernel-5_35-4_79_2_98_2_19:4.3.2.5
	Kernel-5_35-4_79_2_98_2_18:4.3.2.5
	Kernel-5_35-4_79_2_98_2_17:4.3.2.5
	Kernel-5_35-4_79_2_98_2_16:4.3.2.5
	Kernel-5_35-4_79_2_98_2_15:4.3.2.5
	Kernel-5_35-4_79_2_106:4.3.2.5
	Kernel-5_35-4_79_2_105:4.3.2.5
	Kernel-5_35-4_79_2_104:4.3.2.5
	Kernel-5_35-4_79_2_98_2_14:4.3.2.5
	Kernel-5_35-4_79_2_98_2_13:4.3.2.5
	Kernel-5_35-4_79_2_98_2_12:4.3.2.5
	Kernel-5_35-4_79_2_98_2_11:4.3.2.5
	Kernel-5_35-4_79_2_98_2_10:4.3.2.5
	Kernel-5_35-4_79_2_98_2_9:4.3.2.5
	Kernel-5_35-4_79_2_103:4.3.2.5
	Kernel-5_35-4_79_2_102:4.3.2.5
	Kernel-5_35-4_79_2_98_2_8:4.3.2.5
	Kernel-5_35-4_79_2_98_2_7:4.3.2.5
	Kernel-5_35-4_79_2_98_2_6:4.3.2.5
	Kernel-5_35-4_79_2_98_2_5:4.3.2.5
	Kernel-5_35-4_79_2_98_2_4:4.3.2.5
	Kernel-5_35-4_79_2_101:4.3.2.5
	Kernel-5_35-4_79_2_100:4.3.2.5
	Kernel-5_35-4_79_2_99:4.3.2.5
	Kernel-5_35-4_79_2_98_2_3:4.3.2.5
	Kernel-5_35-4_79_2_98_2_2:4.3.2.5
	Kernel-5_35-4_79_2_98_2_1:4.3.2.5
	Cortex:4.3.2.5.0.2
	Cortex_bp:4.3.2.5
	Kernel-5_35-4_79_2_98:4.3.2.5
	Kernel-5_35-4_79_2_97:4.3.2.5
	Kernel-5_35-4_79_2_96:4.3.2.5
	Kernel-5_35-4_79_2_95:4.3.2.5
	Kernel-5_35-4_79_2_94:4.3.2.5
	Kernel-5_35-4_79_2_93:4.3.2.5
	Kernel-5_35-4_79_2_92:4.3.2.5
	Kernel-5_35-4_79_2_91:4.3.2.5
	Kernel-5_35-4_79_2_90:4.3.2.5
	Kernel-5_35-4_79_2_89:4.3.2.5
	Kernel-5_35-4_79_2_88:4.3.2.5
	Kernel-5_35-4_79_2_87:4.3.2.5
	Kernel-5_35-4_79_2_86:4.3.2.5
	Kernel-5_35-4_79_2_85:4.3.2.5
	Kernel-5_35-4_79_2_84:4.3.2.5
	Kernel-5_35-4_79_2_83:4.3.2.5
	Kernel-5_35-4_79_2_82:4.3.2.5
	Kernel-5_35-4_79_2_81:4.3.2.5
	Kernel-5_35-4_79_2_80:4.3.2.5
	Kernel-5_35-4_79_2_79:4.3.2.5
	Kernel-5_35-4_79_2_78:4.3.2.5
	Kernel-5_35-4_79_2_77:4.3.2.5
	RO_5_07:4.3.2.5
	Kernel-5_35-4_79_2_76:4.3.2.5
	Kernel-5_35-4_79_2_75:4.3.2.5
	Kernel-5_35-4_79_2_74:4.3.2.5
	Kernel-5_35-4_79_2_73:4.3.2.5
	Kernel-5_35-4_79_2_72:4.3.2.5
	Kernel-5_35-4_79_2_71:4.3.2.5
	Kernel-5_35-4_79_2_70:4.3.2.5
	Kernel-5_35-4_79_2_69:4.3.2.5
	Kernel-5_35-4_79_2_68:4.3.2.5
	Kernel-5_35-4_79_2_67:4.3.2.5
	Kernel-5_35-4_79_2_66:4.3.2.5
	Kernel-5_35-4_79_2_65:4.3.2.5
	Kernel-5_35-4_79_2_64:4.3.2.5
	Kernel-5_35-4_79_2_63:4.3.2.5
	Kernel-5_35-4_79_2_62:4.3.2.5
	Kernel-5_35-4_79_2_61:4.3.2.5
	Kernel-5_35-4_79_2_59:4.3.2.5
	Kernel-5_35-4_79_2_58:4.3.2.5
	Kernel-5_35-4_79_2_57:4.3.2.5
	Kernel-5_35-4_79_2_56:4.3.2.5
	Kernel-5_35-4_79_2_55:4.3.2.5
	Kernel-5_35-4_79_2_54:4.3.2.5
	Kernel-5_35-4_79_2_53:4.3.2.5
	Kernel-5_35-4_79_2_52:4.3.2.5
	Kernel-5_35-4_79_2_51:4.3.2.5
	Kernel-5_35-4_79_2_50:4.3.2.4
	Kernel-5_35-4_79_2_49:4.3.2.4
	Kernel-5_35-4_79_2_48:4.3.2.4
	Kernel-5_47:4.3
	Kernel-5_46-4_90_2_1:4.3
	nbingham_Kernel_FastNC_dev_bp:4.3
	nbingham_Kernel_FastNC_dev:4.3.0.4
	Kernel-5_46:4.3
	Kernel-5_45:4.3
	Kernel-5_35-4_79_2_47:4.3.2.3
	Kernel-5_35-4_79_2_46:4.3.2.3
	Kernel-5_35-4_79_2_45:4.3.2.3
	Kernel-5_35-4_79_2_44:4.3.2.3
	Kernel-5_35-4_79_2_25_2_2:4.3.2.1
	Kernel-5_35-4_79_2_43:4.3.2.3
	Kernel-5_35-4_79_2_42:4.3.2.3
	Kernel-5_35-4_79_2_41:4.3.2.3
	Kernel-5_35-4_79_2_40:4.3.2.2
	Kernel-5_35-4_79_2_39:4.3.2.2
	Kernel-5_35-4_79_2_38:4.3.2.2
	Kernel-5_35-4_79_2_37:4.3.2.2
	Kernel-5_35-4_79_2_36:4.3.2.2
	Kernel-5_35-4_79_2_35:4.3.2.2
	Kernel-5_35-4_79_2_34:4.3.2.2
	Kernel-5_35-4_79_2_33:4.3.2.2
	Kernel-5_35-4_79_2_32:4.3.2.2
	Kernel-5_44:4.3
	Kernel-5_35-4_79_2_25_2_1:4.3.2.1
	Kernel-5_43:4.3
	Kernel-5_35-4_79_2_31:4.3.2.2
	Kernel-5_35-4_79_2_30:4.3.2.2
	Kernel-5_35-4_79_2_29:4.3.2.1
	Kernel-5_35-4_79_2_28:4.3.2.1
	Kernel-5_35-4_79_2_27:4.3.2.1
	Kernel-5_35-4_79_2_26:4.3.2.1
	Kernel-5_42:4.3
	Kernel-5_41:4.3
	Kernel-5_40:4.3
	Kernel-5_35-4_79_2_25:4.3.2.1
	Kernel-5_35-4_79_2_24:4.3.2.1
	Kernel-5_35-4_79_2_23:4.3.2.1
	Kernel-5_35-4_79_2_22:4.3.2.1
	Kernel-5_35-4_79_2_21:4.3.2.1
	Kernel-5_35-4_79_2_20:4.3.2.1
	Kernel-5_35-4_79_2_19:4.3.2.1
	Kernel-5_35-4_79_2_18:4.3.2.1
	Kernel-5_35-4_79_2_17:4.3.2.1
	Kernel-5_35-4_79_2_16:4.3.2.1
	Kernel-5_35-4_79_2_15:4.3.2.1
	Kernel-5_35-4_79_2_14:4.3.2.1
	Kernel-5_39:4.3
	Kernel-5_13-4_52_2_1:4.2
	Bethany:4.2.0.2
	Kernel-5_38:4.3
	Kernel-5_35-4_79_2_13:4.3.2.1
	Kernel-5_35-4_79_2_12:4.3.2.1
	Kernel-5_35-4_79_2_11:4.3.2.1
	Kernel-5_37:4.3
	Kernel-5_35-4_79_2_10:4.3.2.1
	Kernel-5_35-4_79_2_9:4.3.2.1
	Kernel-5_36:4.3
	Kernel-5_35-4_79_2_8:4.3.2.1
	Kernel-5_35-4_79_2_7:4.3.2.1
	Kernel-5_35-4_79_2_6:4.3.2.1
	Kernel-5_35-4_79_2_5:4.3.2.1
	Kernel-5_35-4_79_2_4:4.3.2.1
	Kernel-5_35-4_79_2_3:4.3.2.1
	Kernel-5_35-4_79_2_2:4.3.2.1
	dellis_autobuild_BaseSW:4.3
	Kernel-5_35-4_79_2_1:4.3.2.1
	HAL:4.3.0.2
	Kernel-5_35:4.3
	Kernel-5_34:4.3
	Kernel-5_33:4.3
	Kernel-5_32:4.3
	Kernel-5_31:4.3
	Kernel-5_30:4.3
	Kernel-5_29:4.3
	Kernel-5_28:4.3
	Kernel-5_27:4.3
	Kernel-5_26:4.3
	Kernel-5_25:4.3
	Kernel-5_24:4.3
	Kernel-5_23:4.3
	Kernel-5_22:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Kernel-5_21:4.2
	Kernel-5_20:4.2
	Kernel-5_19:4.2
	Kernel-5_18:4.2
	Kernel-5_17:4.2
	Kernel-5_16:4.2
	Kernel-5_15:4.2
	Kernel-5_14:4.2
	Kernel-5_13:4.2
	Kernel-5_12:4.2
	Kernel-5_11:4.2
	Kernel-5_10:4.2
	Kernel-5_09:4.2
	Kernel-5_08:4.2
	Kernel-5_07:4.2
	Kernel-5_06:4.2
	Kernel-5_05:4.2
	Kernel-5_04:4.2
	Kernel-5_03:4.2
	Kernel-5_02:4.2
	Kernel-5_01:4.2
	Kernel-5_00:4.2
	Kernel-4_99:4.2
	Kernel-4_98:4.2
	Kernel-4_97:4.2
	Kernel-4_96:4.2
	Kernel-4_95:4.2
	Kernel-4_94:4.2
	Kernel-4_93:4.2
	Kernel-4_92:4.2
	Kernel-4_91:4.2
	Kernel-4_90:4.2
	dcotton_autobuild_BaseSW:4.3
	Kernel-4_89:4.2
	Kernel-4_88:4.2
	Kernel-4_87:4.2
	Kernel-4_86:4.2
	Kernel-4_85:4.2
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1.4.2
	Kernel-4_84:4.2
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1.4.2
	Ursula_RiscPC_bp:4.1.4.2
	Kernel-4_83:4.2
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.2
	Ursula_RiscPC:4.1.4.2.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1.4.2
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.2
	UrsulaBuild_FinalSoftload:4.1.4.2
	rthornb_UrsulaBuild-12Aug1998:4.1.4.2
	aglover_UrsulaBuild-05Aug1998:4.1.4.2
	rthornb_UrsulaBuild-29Jul1998:4.1.4.2
	rthornb_UrsulaBuild-22Jul1998:4.1.4.2
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.2
	rthornb_UrsulaBuild-07Jul1998:4.1.4.2
	rthornb_UrsulaBuild-17Jun1998:4.1.4.2
	rthornb_UrsulaBuild-03Jun1998:4.1.4.2
	rthornb_UrsulaBuild-27May1998:4.1.4.2
	mstphens_Kernel-3_80:4.1.4.2
	rthornb_UrsulaBuild-21May1998:4.1.4.2
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1.4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2016.06.30.20.28.56;	author jlee;	state Exp;
branches;
next	4.4;
commitid	lMnWzoE9eJz3Wwcz;

4.4
date	2016.06.30.20.08.09;	author jlee;	state Exp;
branches;
next	4.3;
commitid	IWoXxARWeuLDOwcz;

4.3
date	2000.04.04.14.27.32;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	99.08.17.11.16.24;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.22;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	2001.05.17.10.51.11;	author kbracey;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	2001.06.26.09.37.11;	author mstephen;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	2002.10.07.17.29.42;	author kbracey;	state Exp;
branches;
next	4.3.2.5;

4.3.2.5
date	2002.11.30.00.31.09;	author bavison;	state Exp;
branches
	4.3.2.5.2.1;
next	4.3.2.6;

4.3.2.6
date	2011.11.26.21.11.16;	author jlee;	state Exp;
branches;
next	4.3.2.7;
commitid	cI3W0zbtALQG6TIv;

4.3.2.7
date	2011.11.27.19.18.16;	author rsprowson;	state Exp;
branches;
next	4.3.2.8;
commitid	iuIXfUOByAFYr0Jv;

4.3.2.8
date	2012.01.15.08.22.22;	author rsprowson;	state Exp;
branches;
next	4.3.2.9;
commitid	b6tNv5QPTHakffPv;

4.3.2.9
date	2012.10.28.16.51.46;	author rsprowson;	state Exp;
branches;
next	4.3.2.10;
commitid	ruXZqdTJKJ85Qaqw;

4.3.2.10
date	2013.12.17.19.14.14;	author jlee;	state Exp;
branches;
next	;
commitid	BWyEB17f7eMWhwhx;

4.3.2.5.2.1
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	4.3.2.5.2.2;
commitid	D7rzILnwRRSXoLuv;

4.3.2.5.2.2
date	2011.09.24.19.55.54;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.1.1.1
date	96.11.05.09.41.22;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.43;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.09.09.13.33.26;	author mstphens;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.12.08.14.34.33;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.28;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.46;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => MoreSWIs

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;  SubstituteArgs
;    in:  R0 -> arglist (space delimited args, terminated by 10,13,0)
;         R1 -> buffer
;         R2 =  bufflen
;         R3 -> string to mangle
;         R4 =  no of chars in $R3
;    out: R2 =  no of chars in buffer

XOS_SubstituteArgs_code
        Push    "r5,lr"
        MOV     r5, #0
        SWI     XOS_SubstituteArgs32
        Pull    "r5,lr"
        B       SLVK_TestV

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;  SubstituteArgs32
;    in:  R0 -> arglist (space delimited args, terminated by 10,13,0)
;         R1 -> buffer
;         R2 =  bufflen
;         R3 -> string to mangle
;         R4 =  no of chars in $R3
;         R5 = flags
;               top bit set => don't append unused part of line
;    out: R2 =  no of chars in buffer

XOS_SubstituteArgs32_code ROUT

      WritePSRc SVC_mode, R12   ; enable IRQs
      NOP
      Push   "R0-R8, lr"
      ADD     R8, R4, R3

; try and get parameter positions.
; Items starting with " can have spaces in

      MOV   R6, #0       ; parameter number
      LDR   R12, =MacExStartPtrs
      LDR   R4, =MacExEndPtrs
35    LDRB  R5, [R0], #1
      CMP   R5, #" "
      BEQ   %BT35
      MOV   R2, #" "
      CMP   R5, #""""
      MOVEQ R2, #""""       ; quoted param
      CMP   r6, #10         ; "rest of line" item?
      MOVEQ r2, #-1         ; terminate on EOL only
      SUB   R0, R0, #1
      STR   R0, [R12, R6, LSL #2]
      CMP   r5, #""""
      ADDEQ R0, R0, #1
36    LDRB  R5, [R0], #1
      BL    suba_chktrm
      CMPNE R5, R2
      BNE   %BT36
      CMP   R5, #""""
      LDREQB R5, [R0]
      CMPEQ R5, #""""   ; check for "" in string
      ADDEQ R0, R0, #1
      BEQ   %BT36
      CMP   R2, #""""
      SUBNE R0, R0, #1
      STR   R0, [R4, R6, LSL #2]
      ADD   R6, R6, #1
      CMP   R6, #11           ; Parameters 0-9 and a "rest" set.
      BNE   %BT35

; Keep track of highest param used, so can tack any unused stuff on end.
; R3 points at string to get chars from
; R12 at start ptrs
; R4 at end ptrs

      MOV    R6, #0          ; count.
      MOV    R7, #0          ; highest param used.
      LDR    R2, [stack, #4*2]
37    BL     suba_getchar
      BEQ    %FT41
      CMP    R5, #"%"
      BEQ    %FT44
38    BL     suba_addchar
      B      %BT37

PCnotparm
      ADD    R5, R5, #"0"
      MOV    R11, R5
      MOV    R5, #"%"
      BL     suba_addchar
      MOV    R5, R11
      B      %BT38

44    BL     suba_getchar
      MOVEQ  R5, #"%"
      BEQ    %FT40
      CMP    R5, #"%"
      BEQ    %BT38
      CMP    R5, #"*"
      BEQ    DoStarParams
      SUBS   R5, R5, #"0"
      BMI    PCnotparm
      CMP    R5, #9
      BGT    PCnotparm

; itsa parameter! Get ptrs from R12, R4
      CMP    R5, R7
      ADDGE  R7, R5, #1
      LDR    R11, [R4, R5, LSL #2]
CopyToR11FromParamR5
      LDR    R10, [R12, R5, LSL #2]  ; start ptr
39    LDRB   R5, [R10], #1
      CMP    R10, R11
      BGT    %BT37
      BL     suba_addchar
      B      %BT39

DoStarParams ; had %* : find limits to copy between
      BL     suba_getchar
      BEQ    PCStarTerminates
      SUBS   R5, R5, #"0"
      BMI    PCStarNoDigit
      CMP    R5, #9
      MOVLE  R7, #11                  ; flag * used
      LDRLE  R11, [R4, #10*4]         ; always to EOL
      BLE    CopyToR11FromParamR5
PCStarNoDigit
      ADD    R5, R5, #"0"
      MOV    R11, R5
      MOV    R5, #"%"
      BL     suba_addchar
      MOV    R5, #"*"
      BL     suba_addchar
      MOV    R5, R11
      B      %BT38

PCStarTerminates
      MOV    R5, #"%"
      BL     suba_addchar
      MOV    R5, #"*"
40    BL     suba_addchar
41    CMP    r7, #11
      LDREQ  r12, [r4, #10*4]        ; no more to copy
      BEQ    %FT42
      LDR    r0, [stack, #4*5]
      CMP    r0, #0
      LDRPL  R12, [R12, R7, LSL #2]  ; ptr to rest of command line : copy
      LDRMI  r12, [r4, #10*4]        ; caller wants no appending.
42    LDRB   R5, [R12], #1
      BL     suba_addchar
      BL     suba_chktrm
      BNE    %BT42

      STR    R6, [stack, #4*2]
      Pull  "R0-R8, lr"
      ExitSWIHandler

suba_addchar
      EntryS
      ADD    R6, R6, #1
      CMP    R6, R2
      STRNEB R5, [R1], #1
      EXITS  NE

      PullEnv

      ADRL   R0, ErrorBlock_BuffOverflow
    [ International
      BL     TranslateError
    ]
      STR    R0, [stack]
      Pull  "R0-R8, lr"
      B     SLVK_SetV

suba_getchar
      CMP    R3, R8
      LDRNEB R5, [R3], #1
      MOV    PC, lr

suba_chktrm
      CMP   R5, #13
      CMPNE R5, #10
      CMPNE R5, #0
      MOV   PC, lr

      LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Take R0 as pointer to null-terminated string, print it
; with line breaks before words that won't fit on the current line.
; CR forces a newline. TAB=tab to next column of 8. CHR$31 = hard space
; <27,n> => substitute nth dictionary entry:
;  dictionary is pointed at by r1, consists of a list of null-terminated
;  strings, with preceding length bytes.
; 0th dictentry => use string at r2.

XOS_PrettyPrint_code ROUT

; Inside here, r1 is the current string pointer
;              R3 is the linelength to format to
;              R4 is the current position in the line.
;              r6 is the return addr in word counting
;              r7 is the r1 restore value in reading word length
;              r8 is used in dictionary selection in getbytepp
;              r9 is the stack restoration level for exiting.
;              r11 is the dictionary pointer (0 means use MOS dict)
;              r12 is the special token pointer

          WritePSRc SVC_mode, r11

          Push   "r0-r9, lr"

          BL      ReadWindowWidth    ; read linelength
          MOV     R3, R0
          MOV     R0, #165           ; read output cursor
          SWI     XOS_Byte
          ORR     R4, R1, #&80000000 ; no leading space even if in line.
          LDMFD   stack, {r1, r11, r12}   ; reload strptr, dictptr, tokptr
          CMP     r11, #0
          ADREQL  r11, MOSdictionary
          MOV     r9, stack

; loop over all words
01        BL      getwordlength
          CMP     R2, #0
          BNE     %FT03
          BL      getbytepp
          B       %FT21                ; null word - test for done
03
          CMP     R4, #0
          ADDGT   R2, R2, #1           ; allow for separator
          ADD     R0, R2, R4
          BIC     R0, R0, #&80000000   ; clear R4 flag
          CMP     R0, R3
          BLE     %FT10
          CMP     R4, #0
          SUBGT   R2, R2, #1          ; remove leading space length
          MOV     R4, #0              ; if word too long to fit, do newline
          SWI     XOS_NewLine
          BVS     exitpp

10        CMP     R4, #0
          BIC     R4, R4, #&80000000  ; clear "no leading space" flag
          ADD     R4, R4, R2
          SUBGT   R2, R2, #1
          SWIGT   XOS_WriteI+" "    ; output separator if not 1st on line
          BVS     exitpp

04        BL      getbytepp
          CMP     R0, #31           ; hard space?
          MOVEQ   R0, #" "
          SWI     XOS_WriteC
          BVS     exitpp
          SUBS    R2, R2, #1
          BNE     %BT04

21        CMP     R0, #13
          MOVEQ   R4, #0
          SWIEQ   XOS_NewLine
          BVS     exitpp

          CMP     R0, #TAB
          BEQ     %FT20
          CMP     R0, #0
          BNE     %BT01

exitpp    MOV     stack, r9
          STRVS   r0, [stack]
          Pull   "r0-r9,lr"
          B      SLVK_TestV

; TAB had: align to next multiple of 8
20        BIC     R4, R4, #&80000000
   ; first want to get next word length, to see if it's worth doing
          ADD     R5, R4, #8
          BIC     R5, R5, #7
          SUB     R5, R5, R4           ; spaces for this tab

24        BL      getwordlength
          CMP     R2, #0
          BNE     %FT23              ; got the word
          BL      getbytepp
          CMP     R0, #13
          BEQ     %BT21              ; TAB, CR - whalley!
          CMP     R0, #TAB
          SUBNE   R5, R5, #1         ; leading spaces, junk ignored
          ADDEQ   R5, R5, #8         ; multiple tabs OK tho.
          CMP     r0, #0             ; terminator?
          BNE     %BT24              ; only case to allow zero-length word
          SUB     r1, r1, #1         ; we know this rewinds OK

23        ADD     R0, R4, R5
          ADD     R0, R0, R2
          CMP     R0, R3
          MOVGT   R0, #13           ; next tab stop too far : newline
          BGT     %BT21
22        SWI     XOS_WriteI+" "
          BVS     exitpp
          ADD     R4, R4, #1
          SUBS    r5, r5, #1
          BNE     %BT22
          ORR     R4, R4, #&80000000 ; set top bit to disable leading space
          B       %BT01

getwordlength
          MOV     r6, lr
          MOV     r10, r9            ; first copy context
          MOV     r2, stack
          MOV     r7, r1
copycontextpp
          CMP     r9, r2
          LDRNE   r0, [r9, #-4]!
          Push    r0, NE
          BNE     copycontextpp

          MOV     r2, #0             ; word length
02        BL      getbytepp
          CMP     R0, #31
          CMPNE   R0, #" "+1
          ADDGE   r2, r2, #1
          BGE     %BT02
          MOV     r1, r7
          MOV     stack, r9
          MOV     r9, r10
          MOV     pc, r6

getbytepp LDRB    r0, [r1], #1
          CMP     r0, #TokenEscapeChar
          BEQ     gettokenpp
          CMP     r0, #0
          MOVNE   pc, lr
          CMP     stack, r9
          MOVHS   pc, lr
          Pull    r1                ; back to previous token
          B       getbytepp

gettokenpp
          LDRB    r0, [r1], #1      ; tokno
          Push    r1                ; save context
          CMP     r0, #0
          MOVEQ   r1, r12
          BEQ     getbytepp
          MOV     r1, r11
gtoklp    SUBS    r0, r0, #1
          LDRNEB  r8, [r1]
          ADDNE   r1, r1, r8
          BNE     gtoklp
          ADD     r1, r1, #1
          B       getbytepp

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ReadWindowWidth ROUT    ; read "number of chars printable after Newline
                        ;       before we're on the next line"
        MOV     R0, #VduExt_WindowWidth
ReadVduVarForSam
        Push   "R0, R1, lr"      ; R1 reserves space
        MOV     R0, #-1
        STR     R0, [stack, #4]  ; overwrite R1 value
        MOV     R0, sp
        MOV     R1, sp
        SWI     XOS_ReadVduVariables
        LDR     R0, [sp], #8
        LDR     pc, [sp], #4

;*****************************************************************************
; R0 -> envstring, R1 -> 5 byte time

WriteEnv_SWICode ROUT ; for debugger use
        CMP     R0, #0
        BEQ     %FT01
        LDR     R10, =EnvString
        MOV     R11, R0
02      LDRB    R12, [R11], #1
        CMP     R12, #" "
        MOVLT   R12, #0
        STRB    R12, [R10], #1
        BGE     %BT02

01      CMP     R1, #0
        ExitSWIHandler EQ
        LDR     R10, =ZeroPage+EnvTime
        MOV     R11, #4
03      LDRB    R12, [R1, R11]
        STRB    R12, [R10, R11]
        SUBS    R11, R11, #1
        BPL     %BT03
        ExitSWIHandler

;*****************************************************************************

; LET RdArgs() BE
;  R0 ptr to key defn string
;  R1 ptr to command line to decode
;  R2 ptr to workspace
;  R3 size of workspace
; Returns R3 size left

; Flags used in initial args decoding

AFlag       *  1:SHL:8     ; flags shifted up a byte; avoid looking like chars.
KFlag       *  1:SHL:9
SFlag       *  1:SHL:10
EFlag       *  1:SHL:11
GFlag       *  1:SHL:12
UnsetBase   *  &FF000000   ; only if all bits set (cannot be RAM address)

PresentFlag *  &7FFFFFFF
AbsentFlag  *  0

; Type flags

EndType     *   0
FlagType    *   1
KeywordType *   2
ItemType    *   3

RdArgs_SWICode ROUT

      WritePSRc SVC_mode, R10

      Push   "R4, R8, R9, lr"
      MOV     R10, R2             ; R10 points at next available word
      MOV     R12, R0
01    MOV     R11, #UnsetBase
      SUBS    R3, R3, #4
      BMI     %FT99               ; insufficient space
      STR     R11, [R10], #4
02    LDRB    R11, [R12], #1
      CMP     R11, #"/"
      BNE     %FT03
      LDRB    R11, [R12], #1
      UpperCase R11, R9
      CMP     R11, #"A"
      MOVEQ   R11, #AFlag
      CMP     R11, #"K"
      MOVEQ   R11, #KFlag
      CMP     R11, #"S"
      MOVEQ   R11, #SFlag
      CMP     R11, #"E"
      MOVEQ   R11, #EFlag
      CMP     R11, #"G"
      MOVEQ   R11, #GFlag
      CMP     R11, #256
      LDRGE   R9, [R10, #-4]
      ORRGE   R9, R11, R9
      STRGE   R9, [R10, #-4]
03
      CMP     R11, #","
      BEQ     %BT01
      CMP     R11, #" "
      BGE     %BT02

; Initialisation complete: all flags set, R10 implies number of args.
      MOV     R8, R10

10    BL      RdItem
      BVS     %FT90
      CMP     R12, #KeywordType
      BNE     %FT11
      ADD     R11, R2, R4, LSL #2           ; keyword ptr
      BL      RdItem
      BVS     %FT90
      CMP     R12, #ItemType
      BNE     %FT98
      BL      SetKeyword
      BVS     %FT90
      B       %BT10

11    CMP     R12, #ItemType
      BNE     %FT12

; next positional arg := itemptr

      MOV     R11, R2
20    CMP     R11, R8
      BEQ     %FT98               ; no more positional args
      LDR     R12, [R11], #4
      CMP     R12, #UnsetBase
      BLO     %BT20
      TST     R12, #KFlag :OR: SFlag
      BNE     %BT20
      SUB     R11, R11, #4
      BL      SetKeyword
      BVS     %FT90
      B       %BT10

12    CMP     R12, #EndType
      BNE     %BT10

; postscan to check all /a args set.
      MOV     R12, R2
30    CMP     R12, R8
      BEQ     %FT31
      LDR     R11, [R12], #4
      CMP     R11, #UnsetBase
      BLO     %BT30
      TST     R11, #AFlag
      BNE     %FT98          ; bum args error
      MOV     R11, #AbsentFlag
      STR     R11, [R12, #-4]     ; force "not present"
      B       %BT30

31
      Pull   "R4, R8, R9, lr"
      ExitSWIHandler

98    ADR     R0, ErrorBlock_BadParameters
    [ International
      BL      TranslateError
    ]
      B       %FT90

99    ADRL    R0, ErrorBlock_BuffOverflow
    [ International
      BL      TranslateError
    ]
90
      Pull   "R4, R8, R9, lr"
      B      SLVK_SetV

      MakeErrorBlock BadParameters
      MakeErrorBlock ArgRepeated
      ALIGN

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; RdItem: strips next item from command line
; In:  R1 -> cmd line
; Out: R1 updated
;      R12 contains type
;      R4 contains ptr for Item, argno for Flag/Keyword
; VS means buffer full
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

RdItem    ROUT
      Push  "R1, R7, R8, lr"
      MOV    R8, #0              ; not demanding new arg
01    LDRB   R12, [R1], #1
      CMP    R12, #" "
      BEQ    %BT01
      BGE    %FT33
      MOV    R12, #EndType
      CLRV
      Pull  "R1, R7, R8, PC"
33
      CMP    R12, #""""
      BEQ    ohnoitsquotedargumentsagain

      CMP    R12, #"-"      ; options?
      BNE    %FT02          ; nope - boring item
05    BL     GetArg
      LDRVS  R1, [stack]
      BVS    %FT02          ; not recognised - boring item
      STR    R1, [stack]    ; new restore value.
      MRS    R12, CPSR
      Push   R12            ; save EQ/NE
      LDR    R12, [R2, R4, LSL #2]
      CMP    R12, #UnsetBase
      BHS    %FT34
      ADR    R0, ErrorBlock_ArgRepeated
    [ International
      BL     TranslateError
    |
      SETV
    ]
      ADD    stack, stack, #4 ; discard PSR
      Pull  "R1, R7, R8, PC"
34
      ANDS   R12, R12, #SFlag
      BNE    %FT35
      MOV    R12, #KeywordType
      ADD    stack, stack, #4 ; discard PSR
      CLRV
      Pull  "R1, R7, R8, PC"
35
      MOV    R12, #PresentFlag
      STR    R12, [R2, R4, LSL #2]

; now deal with flag elision: if nextchar valid keyword char, rescan
      Pull   R12
      TST    R12, #Z_bit
      BEQ    %FT20          ; GetArg returned NE, so not single char abbr
      Push  "R2, R3"
      LDRB   R2, [R1]
      BL     CheckR2OKChar
      Pull  "R2, R3"
      MOVEQ  R8, #1        ; MUST get another arg
      BEQ    %BT05
20    MOV    R12, #FlagType
      CLRV
      Pull  "R1, R7, R8, PC"

02    CMP    R8, #0
      BEQ    %FT39
      ADR    R0, ErrorBlock_BadParameters
    [ International
      BL     TranslateError
    |
      SETV
    ]
      Pull  "R1, R7, R8, PC"
39
   ; copy arg until <" "

      MOV    R7, #" "
      SUB    R1, R1, #1
06    MOV    R4, R10
03    LDRB   R12, [R1], #1
      CMP    R12, R7
      CMPNE  R12, #" "-1
      BLE    %FT04
10
      SUBS   R3, R3, #1
      STRPLB R12, [R10], #1
      BPL    %BT03
23
      ADRL   R0, ErrorBlock_BuffOverflow
    [ International
      BL     TranslateError
    |
      SETV
    ]
      Pull  "R1, R7, R8, PC"

04    CMP    R7, #""""
      BNE    %FT07
      CMP    R12, #""""
      BNE    %FT08
      LDRB   R12, [R1], #1
      CMP    R12, #""""
      BEQ    %BT10
07    MOV    R12, #0            ; terminate
      SUBS   R3, R3, #1
      BMI    %BT23
      STRB   R12, [R10], #1
      MOV    R12, #ItemType
      SUB    R1, R1, #1
      STR    R1, [stack]
      CLRV
      Pull  "R1, R7, R8, PC"

ohnoitsquotedargumentsagain
      MOV    R7, #""""
      B      %BT06

08    ADRL   R0, ErrorBlock_BadString
    [ International
      BL     TranslateError
    |
      SETV
    ]
      Pull  "R1, R7, R8, PC"

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; GetArg
; Look through keys: allow only full match on first pass, then
;  single char abbreviation on second pass
; Return V set if not key, EQ if single letter abbreviation
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

GetArg    ROUT
; In:  R0 ptr to keystring
;      R1 ptr to potential option.
; Out: VS if nomatch or
;      R1 updated
;      R4 argument number

      Push   "R0-R3, R5-R6, lr"
      MOV     R6, #-1             ; pass number
20    MOV     R4, #0

01    LDRB    R2, [R0], #1
      CMP     R2, #" "
      BEQ     %BT01

02    BL      CheckR2OKChar
      BNE     %FT03             ; matched in full
      LDRB    R3, [R1], #1
      UpperCase R2, R5
      UpperCase R3, R5
      CMP     R2, R3
      LDREQB  R2, [R0], #1
      BEQ     %BT02

      CMP     R6, #0
      BLT     %FT04

; 2nd pass: allow abbreviation
; IF single char abbreviation THEN success ELSE skip
      LDR     R2, [stack, #4]
      SUB     R2, R1, R2          ; length of match+1
      CMP     R2, #2
      SUBEQ   R1, R1, #1
      BEQ     %FT13               ; success

; skip to next keyword
04    LDRB    R2, [R0], #1
      CMP     R2, #" "
      BLT     %FT05
      CMP     R2, #","
      ADDEQ   R4, R4, #1
      CMPNE   R2, #"="
      BNE     %BT04
      LDR     R1, [stack, #4]
      B       %BT01

03  ; NE on first pass: check input string terminated OK
      LDRB    R2, [R1]            ; check for end of input word
      BL      CheckR2OKChar
      BNE     %FT13               ; yaay! full & correct match
      SUB     R0, R0, #1
      B       %BT04

05    ADDS    R6, R6, #1
      LDMLEFD stack, {R0, R1}
      BLE     %BT20
      SETV
      Pull   "R0-R3, R5-R6, PC"   ; back with failure

13    STR     R1, [stack, #4]
      CLRPSR  V_bit, R0           ; clrV (just)
      Pull   "R0-R3, R5-R6, PC"   ; back with success

CheckR2OKChar ROUT
      CMP     R2, #"A"
      RSBGES  R3, R2, #"Z"
      BGE     %FT50
      CMP     R2, #"a"
      RSBGES  R3, R2, #"z"
      BGE     %FT50
      CMP     R2, #"0"
      RSBGES  R3, R2, #"9"
      BGE     %FT50
      CMP     R2, #"_"
      MOV     PC, lr
50    CMP     R0, R0            ; set EQ
      MOV     PC, lr

;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SetKeyword    ROUT
; R11 ptr at keyword flags
; R4 ptr to value
      Push   "R0-R2, R5, R6, lr"
      LDR     R0, [R11]
      TST     R0, #EFlag :OR: GFlag
      STR     R4, [R11]           ; result will always be here anyway
      BEQ     %FT01
      SUB     R5, R10, R4         ; length of value
      ADD     R3, R3, R5          ; increase free space
      ADD     R2, R5, #11         ; round up to nearest word, then 1
      BIC     R2, R2, #3

      MOV     R6, stack            ; STR stack, [stack, -R2]! is unpredictable
      STR     R6, [stack, -R2]!    ; reserve stack frame

      ADD     R2, stack, #4        ; input value ptr
03    LDRB    R6, [R4, R5]
      STRB    R6, [R2, R5]
      SUBS    R5, R5, #1
      BPL     %BT03               ; copy the value

      TST     R0, #EFlag
      MOV     R0, R2
      BNE     %FT02
      ADD     R1, R4, #2          ; free space pointer
      SUBS    R3, R3, #2
      MOV     R2, R3
      BMI     %FT04
      ORR     R2, R2, #1:SHL:31
      SWI     XOS_GSTrans
05    SUB     R3, R3, R2
      ADD     R10, R1, R2        ; update freespace pointer
      STRB    R2, [R1, #-2]
      MOV     R2, R2, LSR #8
      STRB    R2, [R1, #-1]
      BCS     %FT04

90    LDR     stack, [stack, #0]  ; unwind frame (and don't let AAsm use
      STRVS   R0, [stack]         ;   postindexed!!!)
      Pull   "R0-R2, R5, R6,PC"

04    ADRL    R0, ErrorBlock_BuffOverflow
    [ International
      BL      TranslateError
    |
      SETV
    ]
      B       %BT90

02    ADD     R1, R4, #3        ; free space pointer
      SUBS    R3, R3, #3        ; adjust for type (1 byte) + length (2 bytes)
      BMI     %BT04
      MOV     R2, R3
      SWI     XOS_EvaluateExpression
      BVS     %BT90
      TEQ     R1, #0, 2         ; if non-zero, then string, so update length
      MOVNE   R14, #1           ; set type byte to definitely non-zero
      STRNEB  R14, [R4]
      BNE     %BT05             ; (C=0 so no buffer overflow, V=0 from SWI)
      STRB    R1, [R4]          ; set type byte to zero (=> integer)
      SUBS    R3, R3, #5
      BMI     %BT04
      STRB    R2, [R4, #1]
      MOV     R2, R2, LSR #8
      STRB    R2, [R4, #2]
      MOV     R2, R2, LSR #8
      STRB    R2, [R4, #3]
      MOV     R2, R2, LSR #8
      STRB    R2, [R4, #4]
      ADD     R10, R4, #5
      B       %BT90

01
      CLRV
      Pull   "R0-R2, R5, R6,PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ReadRAMFSLimits
; Return R0 start, R1 end (i.e. 1st byte out of area)

ReadRAMFSLimits_Code ROUT
        Push    "lr"
        MOV     r0, #ChangeDyn_RamFS
        SWI     XOS_ReadDynamicArea     ; out: r0 = base, r1 = current size
        Pull    "lr"
        ADDVC   r1, r1, r0              ; if no error, make r1 -> after end
        ORRVS   lr, lr, #V_bit          ; if error, then set V_bit on return
        ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ExitAndDie
; r0-r2 parameters for Exit
; r3 pointer to module name

TerminateAndSodOff ROUT

        Push    "r0-r2"
        LDR     r10, =ZeroPage
      [ ZeroPage = 0
        STR     r10, [r10, #Curr_Active_Object]
      |
        MOV     r14, #0
        STR     r14, [r10, #Curr_Active_Object]
      ]
        MOV     r1, r3
        MOV     r0, #ModHandReason_Delete
        SWI     XOS_Module
        Pull    "r0-r2"
        SWI     XOS_Exit

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; AddCallBack entry to callback vector
; r0 address to call
; r1 workspace ptr

AddCallBack_Code  ROUT

      Push   "r0-r3, lr"
  [ ChocolateSysHeap
      ASSERT  ChocolateCBBlocks = ChocolateBlockArrays + 0
      LDR     r3,=ZeroPage+ChocolateBlockArrays
      LDR     r3,[r3,#0]
      BL      ClaimChocolateBlock
      MOVVS   r3, #12
      BLVS    ClaimSysHeapNode
  |
      MOV     r3, #12
      BL      ClaimSysHeapNode
  ]
      BVS     %FT99
      Pull   "r0, r1"
      LDR     r10, =ZeroPage
      WritePSRc SVC_mode+I_bit, r3      ; IRQs off while holding context.
      LDR     r3, [r10, #CallBack_Vector]
 [ {TRUE}
      STR     r3, [r2, #0]
      STMIB   r2, {r0, r1}
      STR     r2, [r10, #CallBack_Vector]
      Pull   "r2, r3, lr"
 |
      STR     r3, [r2], #4
      STMIA   r2, {r0, r1}
      SUB     r2, r2, #4
      STR     r2, [r10, #CallBack_Vector]
      Pull   "r2, r3, lr"
      MOV     r10, #0
 ]
      LDRB    r11, [r10, #CallBack_Flag]
      ORR     r11, r11, #CBack_VectorReq
      STRB    r11, [r10, #CallBack_Flag]
      B       SLVK

99      STR     r0, [stack]
        Pull    "r0-r3, lr"
        B       SLVK_SetV

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;       RemoveCallBack - Entry for SWI OS_RemoveCallBack
;
;       Removes an entry on the callback vector before it has been called
;
; in:   r0 = address that would have been called
;       r1 = workspace ptr
;
; out:  -
;

RemoveCallBack ROUT
        Push    "r2-r4"
        SavePSR r10                     ; save old I bit
10
        WritePSRc SVC_mode+I_bit, r11   ; disable IRQs while looking at list
        LDR     r11, =ZeroPage
        LDR     r2, [r11, #CallBack_Vector]! ; r11 -> prev, r2 -> this
20
        TEQ     r2, #0
        Pull    "r2-r4", EQ
        ExitSWIHandler EQ

        LDMIA   r2, {r3,r4,r12}         ; r3 -> next, r4 = addr, r12 = ws
        TEQ     r4, r0                  ; check if correct address
        TEQEQ   r12, r1                 ; and correct ws ptr
        MOVNE   r11, r2                 ; if not, then prev:=this
        MOVNE   r2, r3                  ; and this:=next
        BNE     %BT20                   ; and loop

        STR     r3, [r11]               ; prev.link := next
        RestPSR r10                     ; safe now to restore IRQ status

        Push    "r0, r1, lr"            ; now free this node
  [ ChocolateSysHeap
        ASSERT  ChocolateCBBlocks = ChocolateBlockArrays + 0
        LDR     r1,=ZeroPage+ChocolateBlockArrays
        LDR     r1,[r1,#0]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
        BL      FreeSysHeapNode         ; and then start again (NB we must
                                        ; restart from head of list again, as
                                        ; enabling IRQs could have changed list
  ]
        STRVS   r0, [sp, #0]
        Pull    "r0, r1, lr"
        BVC     %BT10

        Pull    "r2-r4"                 ; had an error while releasing block
        ORR     lr, lr, #V_bit
        ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_Confirm

; If pointer visible, change pointer shape and look at mouse keys too.
;                     Flush mouse buffer first.
; Wait until key pressed.
; Returns: (lowercased) character in r0 (if mouse scanned, LH button = 'y',
;                                        other buttons = 'n')
; C set for Escape condition
; EQ set if r0 = 'y'

 [ International
confirm_yn      DCB "YesNo:yn",0        ; Token to lookup message for Yes/No
 |
confirm_yn      DCB "yn"
 ]
ptr_confirm     DCB "ptr_confirm",0     ; Wimp's confirm pointer sprite shape
confirm_scale   DCD 1,1,1,1             ; Scaling factor for sprite op
Confirm_Code ROUT
        WritePSRc SVC_mode, r10         ; enable IRQs
        Push   "r0-r7, lr"

; Lookup the symbols for Y/N

        ADR     r0, confirm_yn
 [ International
        BL      FindToken               ; Lookup in messages, use default if error
 ]
        LDRB    r1, [r0], #1            ; Y character
        LDRB    r2, [r0], #1            ; N character
        ORR     r1, r1, r2, LSL #8
        Push    "r1"                    ; Y=[sp], N=[sp+1]

; Save current pointer selected

        MOV     r0, #106
        MOV     r1, #255                ; read pointer state
        SWI     XOS_Byte
        BVS     confirm_error
        BIC     r2, r1, #&80
        MOV     r10, r1
        TST     r10, #15                ; Pointer enabled?
        BEQ     confirm_waitloop        ; Jump if not

; Find Wimp's "ptr_confirm" sprite, searching first RMA then ROM

        SWI     XWimp_BaseOfSprites
        MOVVS   r10, #0                 ; If error then don't use mouse
        BVS     confirm_waitloop        ; And jump to poll keyboard

        MOV     r11, r0                 ; Save -> ROM sprites, r1 -> RMA sprites
        ADR     r2, ptr_confirm         ; -> sprite name
        MOV     r0, #&128               ; Read sprite info
        SWI     XOS_SpriteOp
        BVC     %FT10                   ; Jump if sprite in RMA

        ADR     r2, ptr_confirm         ; -> sprite name
        MOV     r1, r11                 ; -> ROM sprites
        MOV     r0, #&128               ; Read sprite info
        SWI     XOS_SpriteOp
        MOVVS   r10, #0                 ; If error then don't use mouse
        BVS     confirm_waitloop        ; And jump to poll keyboard

; Set pointer shape from the sprite area found (r1)

10      MOV     r7, #0                  ; No pixel translation
        ADR     r6, confirm_scale       ; pointer scaling factor (1:1)
        MOV     r5, #0                  ; y hot spot offset
        MOV     r4, #0                  ; x hot spot offset
        MOV     r3, #&23                ; No palette, shape 3
        ADR     r2, ptr_confirm         ; -> sprite name
        MOV     r0, #&124               ; Set pointer shape
        SWI     XOS_SpriteOp            ; Ignore errors

        MOV     r0, #21
        MOV     r1, #9
        SWI     XOS_Byte                ; flush mouse buffer

        MOV     r0, #&C4
        MOV     r1, #0
        MOV     r2, #255
        SWI     XOS_Byte                ; read current repeat rate.
        LDR     r0, =ZeroPage
        LDR     r0, [r0, #MetroGnome]
        ADD     r11, r1, r0             ; time to wait for

confirm_mouserepeat
        SWI     XOS_Mouse
        CMP     r2, #0                  ; any buttons down?
        BEQ     confirm_waitloop

        CMP     r3, r11
        BMI     confirm_mouserepeat

confirm_waitloop
        MOV     r0, #129
        MOV     r1, #1
        MOV     r2, #0
        SWI     XOS_Byte                ; scan for key
        BVS     confirm_error
        CMP     r2, #255
        BNE     confirm_gotkey

        TST     r10, #15
        BEQ     confirm_waitloop        ; no mouse scan wanted.

        SWI     XOS_Mouse
        BVS     confirm_error
        CMP     r2, #0
        BEQ     confirm_waitloop

        TST     r2, #4                  ; LH button?
        LDRNEB  r1, [sp]                ; Yes
        LDREQB  r1, [sp, #1]            ; No

confirm_gotkey
        CMP     r2, #&1B                ; ESCAPE or normal char read ?
        ORREQ   r11, r1, #&100
        MOVNE   r11, r1
        LowerCase r11, r1

        TSTS    r10, #15                ; Was pointer changed?
        MOV     r1, r10
        MOV     r0, #106
        SWINE   XOS_Byte                ; Yes then restore shape

        Pull   "r10"                    ; r10=YN
        AND     r10, r10, #&ff          ; Retain Y byte
        Pull   "r0-r7, lr"
        BIC     lr, lr, #C_bit :OR: Z_bit ; SKS. Punter lr has VClear
        AND     r0, r11, #&FF
        TST     r11, #&100              ; ESCAPE condition ? (SKS)
        ORRNE   lr, lr, #C_bit
        CMP     r0, r10
        ORREQ   lr, lr, #Z_bit
        B       SLVK

confirm_error
        ADD     sp, sp, #4              ; Drop YN
        STR     r0, [stack]
        Pull    "r0-r7, lr"
        B       SLVK_SetV


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = continuation crc (0 to start)
;       r1 -> start of core
;       r2 -> end of core
;       r3 = increment (typically 1, 2 or 4), but can be -ve

; Out   r0 = crc so far

CRC_Code ROUT

        [ {TRUE}
        WritePSRc SVC_mode, r10         ; Could take a long time

        Push    "r3, r14"
        TEQ     r3, #0                  ; is increment 0? - if so, it's silly
        BEQ     %FT80                   ; so return error, rather than going on forever

        MOV     r10, r1
        MOV     r12, #&A000             ; CRC EOR pattern = &A001
        ORR     r12, r12, #&0001
10
        CMP     r10, r2                 ; Finished ?
        BEQ     %FA90                   ; Must be exact end, allows -ve offset

        LDRB    r14, [r10], r3
        EOR     r0, r0, r14             ; EOR the data with current crc lo
        CMP     r10, r2                 ; length might be odd so check again
        MOVEQ   r11, #8                 ; if equal then only do 8 bits
        BEQ     %FT20

        LDRB    r14, [r10], r3
        EOR     r0, r0, r14, LSL #8     ; EOR the data with current crc hi
        MOV     r11, #16                ; do 16 bits

20
        MOVS    r0, r0, LSR #1          ; acc >>= 1; CS/CC
        EORCS   r0, r0, r12             ; CS -> eor, CC -> ok
        SUBS    r11, r11, #1            ; 8 bits per byte
        BNE     %BT20
        B       %BT10

80
        ADRL    r0, ErrorBlock_BadParameters    ; return "Bad parameters" error
 [ International
        BL      TranslateError
 ]
        Pull    "r3, r14"
        B       SLVK_SetV

90
        Pull    "r3, r14"
        ExitSWIHandler
        |
        WritePSRc SVC_mode, r10         ; Could take a long time

        Push    "r3, r4, lr"
        MOV     r10, r1
        MOV     r12, #&A000             ; CRC EOR pattern = &A001
        ORR     r12, r12, #&0001
        MOV     r14, #1                 ; A single bit to be shifted

10      CMP     r10, r2                 ; Finished ?
        BEQ     %FA90                   ; Must be exact end, allows -ve offset

        LDRB    r4, [r10], r3
        MOV     r11, #0                 ; Go round the bits

20      TST     r4, r14, LSL r11        ; Is data bit = carry ?; NE/EQ
        BEQ     %FT30

        MOVS    r0, r0, LSR #1          ; acc >>= 1; CS/CC
        EORCC   r0, r0, r12             ; NE, CC -> eor, NE, CS -> ok
        B       %FT40

30      MOVS    r0, r0, LSR #1          ; acc >>= 1; CS/CC
        EORCS   r0, r0, r12             ; EQ, CS -> eor, EQ, CC -> ok

40      ADD     r11, r11, #1            ; 8 bits per byte
        CMP     r11, #8
        BLO     %BT20

        B       %BT10

90      Pull    "r3, r4, lr"
        ExitSWIHandler
        ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        END
@


4.4
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a19 3
 [ :LNOT:No26bitCode
;               top bit set => don't append unused part of line
 ]
a27 1
 [ No26bitCode
a28 4
 |
        BIC     r0, r0, #&80000000
        AND     r5, r0, #&80000000
 ]
@


4.3
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d20 1
d22 1
d29 24
a52 1
XOS_SubstituteArgs_code ROUT
d55 1
a55 1

a56 1
      BIC     r0, r0, #&80000000
d167 1
a167 1
      LDR    r0, [stack]
d385 2
a386 1
        Pull   "R0, R14, PC"
d404 1
a404 1
        LDR     R10, =EnvTime
d428 3
a430 2
UnsetFlag   *  1:SHL:31
PresentFlag * -1 :AND::NOT:UnsetFlag
d447 1
a447 1
01    MOV     R11, #UnsetFlag
d501 2
a502 2
      TST     R12, #UnsetFlag
      BEQ     %BT20
d518 2
a519 2
      TST     R11, #UnsetFlag
      BEQ     %BT30
d577 1
a577 1
      mrs   ,R12, CPSR
d580 2
a581 2
      TST    R12, #UnsetFlag
      BNE    %FT34
d585 2
a588 1
      SETV
d620 2
a622 1
      SETV
d642 2
a644 1
      SETV
d671 2
a673 1
      SETV
d776 2
a777 1
      STR     stack, [stack, -R2]! ; reserve stack frame
d862 2
a863 1
        MOV     r10, #0
d865 4
d885 1
a885 1
      MOV     r3,#ChocolateBlockArrays
d896 1
a896 1
      MOV     r10, #0
d899 1
a899 1
 [ True
d938 1
a938 1
        MOV     r11, #0
d958 1
a958 1
        MOV     r1,#ChocolateBlockArrays
d1057 1
a1057 1
        MOV     r0, #0
@


4.3.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d551 1
a551 1
      MRS    R12, CPSR
@


4.3.2.2
log
@* Fixed the IIC code.
* Kernel puts sensible default FIQ handler in through the HAL.
* Fix to temporary page uncaching code.

Version 5.35, 4.79.2.30. Tagged as 'Kernel-5_35-4_79_2_30'
@
text
@d746 1
a746 2
      MOV     R6, stack            ; STR stack, [stack, -R2]! is unpredictable
      STR     R6, [stack, -R2]!    ; reserve stack frame
@


4.3.2.3
log
@1) Bring IOMD HAL more up to date. Add support for new
call HAL_CleanerSpace (preparation for StrongARM kernel
support).

2) In kernel, add HAL_CleanerSpace call (preparation for
StrongARM and XScale core support). Fix bug found with
ARMv3 support during test on Risc PC.

3) Implement new API for kernel SWIs that have used top
bits of addresses as flags. The new API has an extra
flag that must be set, so kernel can distinguish and
support both APIs. The reason for all this is that
addresses are 32-bits now, people, keep up there. Briefly:

  OS_HeapSort
    bit 31 of r0 set for new API, r1 is full 32-bit address
    flags move from r1 bits 31-29 to r0 bits 30-28

  OS_ReadLine
    bit 31 of r1 set for new API, r0 is full 32-bit address
    flags move from bits 31,30 of r0 to bits 30,29 of r1

  OS_SubstituteArgs
    bit 31 of r2 set for new API, r0 is full 32-bit address
    flag moves from bit 31 of r0 to bit 30 of r2

Tested on Risc PC and briefly on Customer A 2

Ta

Version 5.35, 4.79.2.41. Tagged as 'Kernel-5_35-4_79_2_41'
@
text
@a18 3
;
; mjs June 2001, API redefined to allow for full 32-bit addresses
;
d20 1
d22 1
a22 3
;         R2 =  bufflen, plus flags in top 2 bits
;                 bit 31 *must* be set to indicate new API, supporting full 32-bit addresses
;                 bit 30 set => don't append unused part of line
a26 5
; For backward compatibility, supports old API assuming addresses
; safe (top bit of address in r0 clear). The old API uses r0
; bit 31 to specify flag as in bit 30 of r2 above.
;

d32 1
a32 4

      TST     R2, #&80000000      ; check for old API
      BICEQ   R0, R0, #&80000000  ; zap old API flag bit from address if so
     
d76 1
a76 2
      LDR    R2, [stack, #4*2]   ;r2in
      BIC    R2, R2, #&C0000000  ;buffer length
d143 4
a146 7
      LDR    r0, [stack, #4*2]       ; r2in
      TST    r0, #&80000000          ; check for old/new API
      LDREQ  r0, [stack, #4*0]       ; if old, get r0in
      MOVEQ  r0, r0, LSR #1          ; and shift r0in bit 31 (old flag) to bit 30 (new flag)
      TST    r0, #&40000000
      LDREQ  R12, [R12, R7, LSL #2]  ; ptr to rest of command line : copy
      LDRNE  r12, [r4, #10*4]        ; caller wants no appending.
@


4.3.2.4
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d19 3
a22 3
 [ :LNOT:No26bitCode
;               top bit set => don't append unused part of line
 ]
d24 3
a26 1
;         R2 =  bufflen
d31 4
a34 11
XOS_SubstituteArgs_code
        Push    "r5,lr"
 [ No26bitCode
        MOV     r5, #0
 |
        BIC     r0, r0, #&80000000
        AND     r5, r0, #&80000000
 ]
        SWI     XOS_SubstituteArgs32
        Pull    "r5,lr"
        B       SLVK_TestV
d36 1
a36 12
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;  SubstituteArgs32
;    in:  R0 -> arglist (space delimited args, terminated by 10,13,0)
;         R1 -> buffer
;         R2 =  bufflen
;         R3 -> string to mangle
;         R4 =  no of chars in $R3
;         R5 = flags
;               top bit set => don't append unused part of line
;    out: R2 =  no of chars in buffer

XOS_SubstituteArgs32_code ROUT
d41 4
d88 2
a89 1
      LDR    R2, [stack, #4*2]
d156 7
a162 4
      LDR    r0, [stack, #4*5]
      CMP    r0, #0
      LDRPL  R12, [R12, R7, LSL #2]  ; ptr to rest of command line : copy
      LDRMI  r12, [r4, #10*4]        ; caller wants no appending.
@


4.3.2.5
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d427 2
a428 3
UnsetBase   *  &FF000000   ; only if all bits set (cannot be RAM address)

PresentFlag *  &7FFFFFFF
d445 1
a445 1
01    MOV     R11, #UnsetBase
d499 2
a500 2
      CMP     R12, #UnsetBase
      BLO     %BT20
d516 2
a517 2
      CMP     R11, #UnsetBase
      BLO     %BT30
d578 2
a579 2
      CMP    R12, #UnsetBase
      BHS    %FT34
@


4.3.2.6
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d385 1
a385 2
        LDR     R0, [sp], #8
        LDR     pc, [sp], #4
d403 1
a403 1
        LDR     R10, =ZeroPage+EnvTime
d857 1
a857 1
        LDR     r10, =ZeroPage
d875 1
a875 1
      LDR     r3,=ZeroPage+ChocolateBlockArrays
d886 1
a886 1
      LDR     r10, =ZeroPage
d928 1
a928 1
        LDR     r11, =ZeroPage
d948 1
a948 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d1047 1
a1047 1
        LDR     r0, =ZeroPage
@


4.3.2.7
log
@Rationalise some old switches.
Export less in hdr:RISCOS.
Delete unused GetDecimalPair routine.
Move CheckYear with other RTC stuff out of PMF/osword.
Hide DebugROMInit and DebugROMErrors in release (even numbered) versions.

Version 5.35, 4.79.2.127. Tagged as 'Kernel-5_35-4_79_2_127'
@
text
@d890 1
a890 1
 [ {TRUE}
@


4.3.2.8
log
@Add a NOP after the mode change in MoreSWIs.s to sync with CallASWI module.
Add two more DebugTX in the reset sequence to announce power on reset and CMOS reset code paths.
In STB land the range of permitted dates is extended from 2020 (a bit close!) to 2037 when Unix time wraps.

Version 5.35, 4.79.2.133. Tagged as 'Kernel-5_35-4_79_2_133'
@
text
@d55 1
a55 1
      NOP
@


4.3.2.9
log
@Review of Internation switch
Variously the call to TranslateError was either followed (outside the switch) by an unnecessary SETV, or missing SETV for the non international case.
Added DMA controller HAL device for IOMD.

Version 5.35, 4.79.2.174. Tagged as 'Kernel-5_35-4_79_2_174'
@
text
@a584 2
    |
      SETV
d587 1
d619 1
a619 1
    |
a620 1
    ]
d640 1
a640 1
    |
a641 1
    ]
d668 1
a668 1
    |
a669 1
    ]
@


4.3.2.10
log
@Fix CAO pointer being reset incorrectly when calling OS_ExitAndDie with zero page relocation enabled
Detail:
  s/MoreSWIs - OS_ExitAndDie now correctly sets the CAO to zero when ZeroPage is non-zero
Admin:
  Tested on BB-xM with high processor vectors
  Issue originally spotted by Sprow


Version 5.35, 4.79.2.205. Tagged as 'Kernel-5_35-4_79_2_205'
@
text
@a862 1
      [ ZeroPage = 0
a863 4
      |
        MOV     r14, #0
        STR     r14, [r10, #Curr_Active_Object]
      ]
@


4.3.2.5.2.1
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d403 1
a403 1
        LDR     R10, =ZeroPage+EnvTime
d857 1
a857 1
        LDR     r10, =ZeroPage
d875 1
a875 1
      LDR     r3,=ZeroPage+ChocolateBlockArrays
d886 1
a886 1
      LDR     r10, =ZeroPage
d928 1
a928 1
        LDR     r11, =ZeroPage
d948 1
a948 1
        LDR     r1,=ZeroPage+ChocolateBlockArrays
d1047 1
a1047 1
        LDR     r0, =ZeroPage
@


4.3.2.5.2.2
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d385 1
a385 2
        LDR     R0, [sp], #8
        LDR     pc, [sp], #4
@


4.2
log
@Ursula ChocolateSysHeap and 128-entry SWI hash table incorporated.

Version 4.83. Tagged as 'Kernel-4_83'
@
text
@d29 1
a29 1
      TEQP    PC, #SVC_mode     ; enable IRQs
d157 1
d161 3
a163 1
      MOVNES PC, lr
d184 2
d207 1
a207 1
          TEQP    PC, #SVC_mode
d224 4
a227 3
          BLEQ    getbytepp
          BEQ     %FT21                ; null word - test for done

d329 1
a329 1
          MOVNES  pc, lr
d331 1
a331 1
          MOVHSS  pc, lr
d416 1
a416 1
      TEQP    PC, #SVC_mode
d537 5
a541 4
      MOVLT  R12, #EndType
      Pull  "R1, R7, R8, lr", LT
      BICLTS PC, lr, #V_bit

d551 2
a552 1
      Push   PC             ; save EQ/NE
d555 2
a556 1
      ADREQ   R0, ErrorBlock_ArgRepeated
d558 1
a558 1
      BLEQ   TranslateError
d560 4
a563 4
      ADDEQ  stack, stack, #4 ; discard PC
      Pull  "R1, R7, R8, lr", EQ
      ORREQS PC, lr, #V_bit

d565 6
a570 5
      MOVEQ  R12, #KeywordType
      ADDEQ  stack, stack, #4 ; discard PC
      Pull  "R1, R7, R8, lr",EQ
      BICEQS PC, lr, #V_bit

d585 2
a586 2
      Pull  "R1, R7, R8, lr"
      BICS   PC, lr, #V_bit
d589 2
a590 1
      ADRNE  R0, ErrorBlock_BadParameters
d592 1
a592 1
      BLNE   TranslateError
d594 3
a596 3
      Pull  "R1, R7, R8, lr", NE
      ORRNES PC, lr, #V_bit

d615 2
a616 2
      Pull  "R1, R7, R8, lr"
      ORRS   PC, lr, #V_bit     ; overflow
d632 2
a633 2
      Pull  "R1, R7, R8, lr"
      BICS   PC, lr, #V_bit
d643 2
a644 2
      Pull  "R1, R7, R8, lr"
      ORRS   PC, lr, #V_bit
d709 2
a710 2
      Pull   "R0-R3, R5-R6, lr"
      ORRS    PC, lr, #V_bit      ; back with failure
d713 1
a713 2
      MVN     R0, #V_bit
      TSTP    R0, PC              ; clrV (just)
d719 1
a719 1
      ORRGES  PC, lr, #Z_bit
d722 1
a722 1
      ORRGES  PC, lr, #Z_bit
d725 1
a725 1
      ORRGES  PC, lr, #Z_bit
d727 3
a729 2
      BICNES  PC, lr, #Z_bit
      ORRS    PC, lr, #Z_bit
d772 1
a772 3
      Pull   "R0-R2, R5, R6,lr"
      BICVCS  PC, lr, #V_bit
      ORRS    PC, lr, #V_bit
d806 2
a807 2
      Pull   "R0-R2, R5, R6,lr"
      BICS    PC, lr, #V_bit
a814 1
 [ NewStyle_RAMDisc
a820 6
 |
        MOV     R0, #RAMDiscAddress
        MOV     R1, #0
        LDR     R1, [R1, #RAMDiscSize]
        ADD     R1, R1, R0
 ]
d861 1
a861 1
      TEQP    PC, #SVC_mode+I_bit       ; IRQs off while holding context.
d899 1
a899 1
        MOV     r10, PC                 ; save old I bit
d901 1
a901 1
        TEQP    PC, #SVC_mode+I_bit     ; disable IRQs while looking at list
d917 1
a917 1
        TEQP    r10, #0                 ; safe now to restore IRQ status
d950 1
d952 3
d958 1
a958 1
        TEQP    pc, #SVC_mode           ; enable IRQs
d964 1
d966 1
d1094 1
a1094 1
        TEQP    pc, #SVC_mode           ; Could take a long time
d1136 1
a1136 1
        TEQP    pc, #SVC_mode           ; Could take a long time
@


4.1
log
@Initial revision
@
text
@d240 1
a240 1
          
d478 1
a478 1
12    CMP     R12, #EndType 
d845 8
d855 1
d918 7
d928 1
d995 1
a995 1
                
@


4.1.4.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d163 1
d165 1
d499 1
d501 1
d505 1
d507 1
d548 1
d550 1
d580 1
d582 1
d601 1
d603 1
d629 1
d631 1
d766 1
d768 3
d806 1
d813 6
d1068 1
d1101 1
d1103 1
d1110 11
d1122 22
@


4.1.4.2
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a819 8
  [ ChocolateSysHeap
      ASSERT  ChocolateCBBlocks = ChocolateBlockArrays + 0
      MOV     r3,#ChocolateBlockArrays
      LDR     r3,[r3,#0]
      BL      ClaimChocolateBlock
      MOVVS   r3, #12
      BLVS    ClaimSysHeapNode
  |
a821 1
  ]
a883 7
  [ ChocolateSysHeap
        ASSERT  ChocolateCBBlocks = ChocolateBlockArrays + 0
        MOV     r1,#ChocolateBlockArrays
        LDR     r1,[r1,#0]
        BL      FreeChocolateBlock
        BLVS    FreeSysHeapNode
  |
a886 1
  ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

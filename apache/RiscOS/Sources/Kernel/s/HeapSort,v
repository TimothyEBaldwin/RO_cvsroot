head	4.3;
access;
symbols
	Kernel-6_14:4.3
	Kernel-6_01-3:4.3
	Kernel-6_13:4.3
	Kernel-6_12:4.3
	Kernel-6_11:4.3
	Kernel-6_10:4.3
	Kernel-6_09:4.3
	Kernel-6_08-4_129_2_10:4.3
	Kernel-6_08-4_129_2_9:4.3
	Kernel-6_08:4.3
	Kernel-6_07:4.3
	Kernel-6_06:4.3
	Kernel-6_05-4_129_2_8:4.3
	Kernel-6_05:4.3
	Kernel-6_04:4.3
	Kernel-6_03:4.3
	Kernel-6_01-2:4.3
	Kernel-6_01-4_146_2_1:4.3
	Kernel-6_02:4.3
	Kernel-6_01-1:4.3
	Kernel-6_01:4.3
	Kernel-6_00:4.3
	Kernel-5_99:4.3
	Kernel-5_98:4.3
	Kernel-5_97-4_129_2_7:4.3
	Kernel-5_97:4.3
	Kernel-5_96:4.3
	Kernel-5_95:4.3
	Kernel-5_94:4.3
	Kernel-5_93:4.3
	Kernel-5_92:4.3
	Kernel-5_91:4.3
	Kernel-5_90:4.3
	Kernel-5_89-4_129_2_6:4.3
	Kernel-5_89:4.3
	Kernel-5_88-4_129_2_5:4.3
	Kernel-5_88-4_129_2_4:4.3
	Kernel-5_88:4.3
	Kernel-5_87:4.3
	Kernel-5_86-4_129_2_3:4.3
	Kernel-5_86-4_129_2_2:4.3
	Kernel-5_86-4_129_2_1:4.3
	Kernel-5_86:4.3
	SMP:4.3.0.2
	SMP_bp:4.3
	Kernel-5_85:4.3
	Kernel-5_54-1:4.3
	Kernel-5_84:4.3
	Kernel-5_83:4.3
	Kernel-5_82:4.3
	Kernel-5_81:4.3
	Kernel-5_80:4.3
	Kernel-5_79:4.3
	Kernel-5_78:4.3
	Kernel-5_77:4.3
	Kernel-5_76:4.3
	Kernel-5_75:4.3
	Kernel-5_74:4.3
	Kernel-5_73:4.3
	Kernel-5_72:4.3
	Kernel-5_71:4.3
	Kernel-5_70:4.3
	Kernel-5_69:4.3
	Kernel-5_68:4.3
	Kernel-5_67:4.3
	Kernel-5_66:4.3
	Kernel-5_65:4.3
	Kernel-5_64:4.3
	Kernel-5_63:4.3
	Kernel-5_62:4.3
	Kernel-5_61:4.3
	Kernel-5_60:4.3
	Kernel-5_59:4.3
	Kernel-5_58:4.3
	Kernel-5_57:4.3
	Kernel-5_56:4.3
	Kernel-5_55:4.3
	Kernel-5_54:4.3
	Kernel-5_53:4.3
	Kernel-5_52:4.3
	Kernel-5_51:4.3
	Kernel-5_50:4.3
	Kernel-5_49:4.3
	HAL_merge:4.2.2.6
	Kernel-5_48:4.3
	Kernel-5_35-4_79_2_327:4.2.2.6
	Kernel-5_35-4_79_2_326:4.2.2.6
	Kernel-5_35-4_79_2_325:4.2.2.6
	Kernel-5_35-4_79_2_324:4.2.2.6
	Kernel-5_35-4_79_2_323:4.2.2.6
	Kernel-5_35-4_79_2_322:4.2.2.6
	Kernel-5_35-4_79_2_321:4.2.2.6
	Kernel-5_35-4_79_2_320:4.2.2.6
	Kernel-5_35-4_79_2_319:4.2.2.6
	Kernel-5_35-4_79_2_318:4.2.2.6
	Kernel-5_35-4_79_2_317:4.2.2.5
	Kernel-5_35-4_79_2_316:4.2.2.5
	Kernel-5_35-4_79_2_315:4.2.2.5
	Kernel-5_35-4_79_2_314:4.2.2.5
	Kernel-5_35-4_79_2_313:4.2.2.5
	Kernel-5_35-4_79_2_312:4.2.2.5
	Kernel-5_35-4_79_2_311:4.2.2.5
	Kernel-5_35-4_79_2_310:4.2.2.5
	Kernel-5_35-4_79_2_309:4.2.2.5
	Kernel-5_35-4_79_2_308:4.2.2.5
	Kernel-5_35-4_79_2_307:4.2.2.5
	Kernel-5_35-4_79_2_306:4.2.2.5
	Kernel-5_35-4_79_2_305:4.2.2.5
	Kernel-5_35-4_79_2_304:4.2.2.5
	Kernel-5_35-4_79_2_303:4.2.2.5
	Kernel-5_35-4_79_2_302:4.2.2.5
	Kernel-5_35-4_79_2_301:4.2.2.5
	Kernel-5_35-4_79_2_300:4.2.2.5
	Kernel-5_35-4_79_2_299:4.2.2.5
	Kernel-5_35-4_79_2_298:4.2.2.5
	Kernel-5_35-4_79_2_297:4.2.2.5
	Kernel-5_35-4_79_2_296:4.2.2.5
	Kernel-5_35-4_79_2_295:4.2.2.5
	Kernel-5_35-4_79_2_294:4.2.2.5
	Kernel-5_35-4_79_2_293:4.2.2.5
	Kernel-5_35-4_79_2_292:4.2.2.5
	Kernel-5_35-4_79_2_291:4.2.2.5
	Kernel-5_35-4_79_2_290:4.2.2.5
	Kernel-5_35-4_79_2_289:4.2.2.5
	Kernel-5_35-4_79_2_288:4.2.2.5
	Kernel-5_35-4_79_2_287:4.2.2.5
	Kernel-5_35-4_79_2_286:4.2.2.5
	Kernel-5_35-4_79_2_285:4.2.2.5
	Kernel-5_35-4_79_2_284:4.2.2.5
	Kernel-5_35-4_79_2_283:4.2.2.5
	Kernel-5_35-4_79_2_282:4.2.2.5
	Kernel-5_35-4_79_2_281:4.2.2.5
	Kernel-5_35-4_79_2_280:4.2.2.5
	Kernel-5_35-4_79_2_279:4.2.2.5
	Kernel-5_35-4_79_2_278:4.2.2.5
	Kernel-5_35-4_79_2_277:4.2.2.5
	Kernel-5_35-4_79_2_276:4.2.2.5
	Kernel-5_35-4_79_2_275:4.2.2.5
	Kernel-5_35-4_79_2_274:4.2.2.5
	Kernel-5_35-4_79_2_273:4.2.2.5
	Kernel-5_35-4_79_2_272:4.2.2.5
	Kernel-5_35-4_79_2_271:4.2.2.5
	Kernel-5_35-4_79_2_270:4.2.2.5
	Kernel-5_35-4_79_2_269:4.2.2.5
	Kernel-5_35-4_79_2_268:4.2.2.5
	Kernel-5_35-4_79_2_267:4.2.2.5
	Kernel-5_35-4_79_2_266:4.2.2.5
	Kernel-5_35-4_79_2_265:4.2.2.5
	Kernel-5_35-4_79_2_264:4.2.2.5
	Kernel-5_35-4_79_2_263:4.2.2.5
	Kernel-5_35-4_79_2_262:4.2.2.5
	Kernel-5_35-4_79_2_261:4.2.2.5
	Kernel-5_35-4_79_2_260:4.2.2.5
	Kernel-5_35-4_79_2_259:4.2.2.5
	Kernel-5_35-4_79_2_258:4.2.2.5
	Kernel-5_35-4_79_2_257:4.2.2.5
	Kernel-5_35-4_79_2_256:4.2.2.5
	Kernel-5_35-4_79_2_255:4.2.2.5
	Kernel-5_35-4_79_2_254:4.2.2.5
	Kernel-5_35-4_79_2_253:4.2.2.5
	Kernel-5_35-4_79_2_252:4.2.2.5
	Kernel-5_35-4_79_2_251:4.2.2.5
	Kernel-5_35-4_79_2_250:4.2.2.5
	Kernel-5_35-4_79_2_249:4.2.2.5
	Kernel-5_35-4_79_2_248:4.2.2.5
	Kernel-5_35-4_79_2_247:4.2.2.5
	Kernel-5_35-4_79_2_246:4.2.2.5
	Kernel-5_35-4_79_2_245:4.2.2.5
	Kernel-5_35-4_79_2_244:4.2.2.5
	Kernel-5_35-4_79_2_243:4.2.2.5
	Kernel-5_35-4_79_2_242:4.2.2.5
	Kernel-5_35-4_79_2_241:4.2.2.5
	Kernel-5_35-4_79_2_240:4.2.2.5
	Kernel-5_35-4_79_2_239:4.2.2.5
	Kernel-5_35-4_79_2_238:4.2.2.5
	Kernel-5_35-4_79_2_237:4.2.2.5
	Kernel-5_35-4_79_2_236:4.2.2.5
	Kernel-5_35-4_79_2_235:4.2.2.5
	Kernel-5_35-4_79_2_234:4.2.2.5
	Kernel-5_35-4_79_2_233:4.2.2.5
	Kernel-5_35-4_79_2_232:4.2.2.5
	Kernel-5_35-4_79_2_231:4.2.2.5
	Kernel-5_35-4_79_2_230:4.2.2.5
	Kernel-5_35-4_79_2_229:4.2.2.5
	Kernel-5_35-4_79_2_228:4.2.2.5
	Kernel-5_35-4_79_2_227:4.2.2.5
	Kernel-5_35-4_79_2_226:4.2.2.5
	Kernel-5_35-4_79_2_225:4.2.2.5
	Kernel-5_35-4_79_2_224:4.2.2.5
	Kernel-5_35-4_79_2_223:4.2.2.5
	Kernel-5_35-4_79_2_222:4.2.2.5
	Kernel-5_35-4_79_2_221:4.2.2.5
	Kernel-5_35-4_79_2_220:4.2.2.5
	Kernel-5_35-4_79_2_219:4.2.2.5
	Kernel-5_35-4_79_2_218:4.2.2.5
	Kernel-5_35-4_79_2_217:4.2.2.5
	Kernel-5_35-4_79_2_216:4.2.2.5
	Kernel-5_35-4_79_2_215:4.2.2.5
	Kernel-5_35-4_79_2_214:4.2.2.5
	Kernel-5_35-4_79_2_213:4.2.2.5
	Kernel-5_35-4_79_2_212:4.2.2.5
	Kernel-5_35-4_79_2_211:4.2.2.5
	Kernel-5_35-4_79_2_210:4.2.2.5
	Kernel-5_35-4_79_2_209:4.2.2.5
	Kernel-5_35-4_79_2_208:4.2.2.5
	Kernel-5_35-4_79_2_207:4.2.2.5
	Kernel-5_35-4_79_2_206:4.2.2.5
	Kernel-5_35-4_79_2_205:4.2.2.5
	Kernel-5_35-4_79_2_204:4.2.2.5
	Kernel-5_35-4_79_2_203:4.2.2.5
	Kernel-5_35-4_79_2_202:4.2.2.5
	Kernel-5_35-4_79_2_201:4.2.2.5
	Kernel-5_35-4_79_2_200:4.2.2.5
	Kernel-5_35-4_79_2_199:4.2.2.5
	Kernel-5_35-4_79_2_198:4.2.2.5
	Kernel-5_35-4_79_2_197:4.2.2.5
	Kernel-5_35-4_79_2_196:4.2.2.5
	Kernel-5_35-4_79_2_195:4.2.2.5
	Kernel-5_35-4_79_2_194:4.2.2.5
	Kernel-5_35-4_79_2_193:4.2.2.5
	Kernel-5_35-4_79_2_192:4.2.2.5
	Kernel-5_35-4_79_2_191:4.2.2.5
	Kernel-5_35-4_79_2_190:4.2.2.5
	Kernel-5_35-4_79_2_189:4.2.2.5
	Kernel-5_35-4_79_2_188:4.2.2.5
	Kernel-5_35-4_79_2_187:4.2.2.5
	Kernel-5_35-4_79_2_186:4.2.2.5
	Kernel-5_35-4_79_2_185:4.2.2.5
	Kernel-5_35-4_79_2_184:4.2.2.5
	Kernel-5_35-4_79_2_183:4.2.2.5
	Kernel-5_35-4_79_2_182:4.2.2.5
	Kernel-5_35-4_79_2_181:4.2.2.5
	Kernel-5_35-4_79_2_180:4.2.2.5
	Kernel-5_35-4_79_2_179:4.2.2.5
	Kernel-5_35-4_79_2_178:4.2.2.5
	Kernel-5_35-4_79_2_177:4.2.2.5
	Kernel-5_35-4_79_2_176:4.2.2.5
	Kernel-5_35-4_79_2_175:4.2.2.5
	Kernel-5_35-4_79_2_174:4.2.2.5
	Kernel-5_35-4_79_2_173:4.2.2.5
	Kernel-5_35-4_79_2_172:4.2.2.5
	Kernel-5_35-4_79_2_171:4.2.2.5
	Kernel-5_35-4_79_2_170:4.2.2.5
	Kernel-5_35-4_79_2_169:4.2.2.5
	Kernel-5_35-4_79_2_168:4.2.2.5
	Kernel-5_35-4_79_2_167:4.2.2.5
	Kernel-5_35-4_79_2_166:4.2.2.5
	Kernel-5_35-4_79_2_165:4.2.2.5
	RPi_merge:4.2.2.5
	Kernel-5_35-4_79_2_147_2_23:4.2.2.5
	Kernel-5_35-4_79_2_147_2_22:4.2.2.5
	Kernel-5_35-4_79_2_147_2_21:4.2.2.5
	Kernel-5_35-4_79_2_147_2_20:4.2.2.5
	Kernel-5_35-4_79_2_147_2_19:4.2.2.5
	Kernel-5_35-4_79_2_147_2_18:4.2.2.5
	Kernel-5_35-4_79_2_164:4.2.2.5
	Kernel-5_35-4_79_2_163:4.2.2.5
	Kernel-5_35-4_79_2_147_2_17:4.2.2.5
	Kernel-5_35-4_79_2_147_2_16:4.2.2.5
	Kernel-5_35-4_79_2_147_2_15:4.2.2.5
	Kernel-5_35-4_79_2_162:4.2.2.5
	Kernel-5_35-4_79_2_161:4.2.2.5
	Kernel-5_35-4_79_2_147_2_14:4.2.2.5
	Kernel-5_35-4_79_2_147_2_13:4.2.2.5
	Kernel-5_35-4_79_2_160:4.2.2.5
	Kernel-5_35-4_79_2_159:4.2.2.5
	Kernel-5_35-4_79_2_158:4.2.2.5
	Kernel-5_35-4_79_2_157:4.2.2.5
	Kernel-5_35-4_79_2_156:4.2.2.5
	Kernel-5_35-4_79_2_147_2_12:4.2.2.5
	Kernel-5_35-4_79_2_147_2_11:4.2.2.5
	Kernel-5_35-4_79_2_155:4.2.2.5
	Kernel-5_35-4_79_2_147_2_10:4.2.2.5
	Kernel-5_35-4_79_2_154:4.2.2.5
	Kernel-5_35-4_79_2_153:4.2.2.5
	Kernel-5_35-4_79_2_147_2_9:4.2.2.5
	Kernel-5_35-4_79_2_152:4.2.2.5
	Kernel-5_35-4_79_2_151:4.2.2.5
	Kernel-5_35-4_79_2_147_2_8:4.2.2.5
	Kernel-5_35-4_79_2_147_2_7:4.2.2.5
	Kernel-5_35-4_79_2_150:4.2.2.5
	Kernel-5_35-4_79_2_147_2_6:4.2.2.5
	Kernel-5_35-4_79_2_147_2_5:4.2.2.5
	Kernel-5_35-4_79_2_149:4.2.2.5
	Kernel-5_35-4_79_2_147_2_4:4.2.2.5
	Kernel-5_35-4_79_2_147_2_3:4.2.2.5
	Kernel-5_35-4_79_2_148:4.2.2.5
	Kernel-5_35-4_79_2_147_2_2:4.2.2.5
	Kernel-5_35-4_79_2_147_2_1:4.2.2.5
	RPi:4.2.2.5.0.2
	RPi_bp:4.2.2.5
	Kernel-5_35-4_79_2_98_2_52_2_1:4.2.2.3
	alees_Kernel_dev:4.2.2.3.0.4
	alees_Kernel_dev_bp:4.2.2.3
	Kernel-5_35-4_79_2_147:4.2.2.5
	Kernel-5_35-4_79_2_146:4.2.2.5
	Kernel-5_35-4_79_2_145:4.2.2.5
	Kernel-5_35-4_79_2_144:4.2.2.5
	Kernel-5_35-4_79_2_143:4.2.2.5
	Kernel-5_35-4_79_2_142:4.2.2.5
	Kernel-5_35-4_79_2_141:4.2.2.5
	Kernel-5_35-4_79_2_140:4.2.2.5
	Kernel-5_35-4_79_2_139:4.2.2.5
	Kernel-5_35-4_79_2_138:4.2.2.5
	Kernel-5_35-4_79_2_137:4.2.2.4
	Kernel-5_35-4_79_2_136:4.2.2.4
	Kernel-5_35-4_79_2_135:4.2.2.4
	Kernel-5_35-4_79_2_134:4.2.2.4
	Kernel-5_35-4_79_2_133:4.2.2.4
	Kernel-5_35-4_79_2_132:4.2.2.4
	Kernel-5_35-4_79_2_131:4.2.2.4
	Kernel-5_35-4_79_2_130:4.2.2.4
	Kernel-5_35-4_79_2_129:4.2.2.4
	Kernel-5_35-4_79_2_128:4.2.2.4
	Kernel-5_35-4_79_2_127:4.2.2.4
	Kernel-5_35-4_79_2_126:4.2.2.3
	Kernel-5_35-4_79_2_125:4.2.2.3
	Kernel-5_35-4_79_2_124:4.2.2.3
	Kernel-5_35-4_79_2_123:4.2.2.3
	Cortex_merge:4.2.2.3
	Kernel-5_35-4_79_2_122:4.2.2.3
	Kernel-5_35-4_79_2_98_2_54:4.2.2.3
	Kernel-5_35-4_79_2_98_2_53:4.2.2.3
	Kernel-5_35-4_79_2_98_2_52:4.2.2.3
	Kernel-5_35-4_79_2_98_2_51:4.2.2.3
	Kernel-5_35-4_79_2_98_2_50:4.2.2.3
	Kernel-5_35-4_79_2_98_2_49:4.2.2.3
	Kernel-5_35-4_79_2_98_2_48:4.2.2.3
	Kernel-5_35-4_79_2_121:4.2.2.3
	Kernel-5_35-4_79_2_98_2_47:4.2.2.3
	Kernel-5_35-4_79_2_120:4.2.2.3
	Kernel-5_35-4_79_2_98_2_46:4.2.2.3
	Kernel-5_35-4_79_2_119:4.2.2.3
	Kernel-5_35-4_79_2_98_2_45:4.2.2.3
	Kernel-5_35-4_79_2_98_2_44:4.2.2.3
	Kernel-5_35-4_79_2_118:4.2.2.3
	Kernel-5_35-4_79_2_98_2_43:4.2.2.3
	Kernel-5_35-4_79_2_117:4.2.2.3
	Kernel-5_35-4_79_2_116:4.2.2.3
	Kernel-5_35-4_79_2_98_2_42:4.2.2.3
	Kernel-5_35-4_79_2_115:4.2.2.3
	Kernel-5_35-4_79_2_98_2_41:4.2.2.3
	Kernel-5_35-4_79_2_98_2_40:4.2.2.3
	Kernel-5_35-4_79_2_114:4.2.2.3
	Kernel-5_35-4_79_2_98_2_39:4.2.2.3
	Kernel-5_35-4_79_2_98_2_38:4.2.2.3
	Kernel-5_35-4_79_2_113:4.2.2.3
	Kernel-5_35-4_79_2_112:4.2.2.3
	Kernel-5_35-4_79_2_98_2_37:4.2.2.3
	Kernel-5_35-4_79_2_98_2_36:4.2.2.3
	Kernel-5_35-4_79_2_98_2_35:4.2.2.3
	Kernel-5_35-4_79_2_98_2_34:4.2.2.3
	Kernel-5_35-4_79_2_98_2_33:4.2.2.3
	Kernel-5_35-4_79_2_98_2_32:4.2.2.3
	Kernel-5_35-4_79_2_98_2_31:4.2.2.3
	Kernel-5_35-4_79_2_98_2_30:4.2.2.3
	Kernel-5_35-4_79_2_98_2_29:4.2.2.3
	Kernel-5_35-4_79_2_98_2_28:4.2.2.3
	Kernel-5_35-4_79_2_98_2_27:4.2.2.3
	Kernel-5_35-4_79_2_98_2_26:4.2.2.3
	Kernel-5_35-4_79_2_111:4.2.2.3
	Kernel-5_35-4_79_2_98_2_25:4.2.2.3
	Kernel-5_35-4_79_2_98_2_24:4.2.2.3
	Kernel-5_35-4_79_2_98_2_23:4.2.2.3
	Kernel-5_35-4_79_2_110:4.2.2.3
	Kernel-5_35-4_79_2_98_2_22:4.2.2.3
	Kernel-5_35-4_79_2_109:4.2.2.3
	Kernel-5_35-4_79_2_98_2_21:4.2.2.3
	Kernel-5_35-4_79_2_98_2_20:4.2.2.3
	Kernel-5_35-4_79_2_108:4.2.2.3
	Kernel-5_35-4_79_2_107:4.2.2.3
	Kernel-5_35-4_79_2_98_2_19:4.2.2.3
	Kernel-5_35-4_79_2_98_2_18:4.2.2.3
	Kernel-5_35-4_79_2_98_2_17:4.2.2.3
	Kernel-5_35-4_79_2_98_2_16:4.2.2.3
	Kernel-5_35-4_79_2_98_2_15:4.2.2.3
	Kernel-5_35-4_79_2_106:4.2.2.3
	Kernel-5_35-4_79_2_105:4.2.2.3
	Kernel-5_35-4_79_2_104:4.2.2.3
	Kernel-5_35-4_79_2_98_2_14:4.2.2.3
	Kernel-5_35-4_79_2_98_2_13:4.2.2.3
	Kernel-5_35-4_79_2_98_2_12:4.2.2.3
	Kernel-5_35-4_79_2_98_2_11:4.2.2.3
	Kernel-5_35-4_79_2_98_2_10:4.2.2.3
	Kernel-5_35-4_79_2_98_2_9:4.2.2.3
	Kernel-5_35-4_79_2_103:4.2.2.3
	Kernel-5_35-4_79_2_102:4.2.2.3
	Kernel-5_35-4_79_2_98_2_8:4.2.2.3
	Kernel-5_35-4_79_2_98_2_7:4.2.2.3
	Kernel-5_35-4_79_2_98_2_6:4.2.2.3
	Kernel-5_35-4_79_2_98_2_5:4.2.2.3
	Kernel-5_35-4_79_2_98_2_4:4.2.2.3
	Kernel-5_35-4_79_2_101:4.2.2.3
	Kernel-5_35-4_79_2_100:4.2.2.3
	Kernel-5_35-4_79_2_99:4.2.2.3
	Kernel-5_35-4_79_2_98_2_3:4.2.2.3
	Kernel-5_35-4_79_2_98_2_2:4.2.2.3
	Kernel-5_35-4_79_2_98_2_1:4.2.2.3
	Cortex:4.2.2.3.0.2
	Cortex_bp:4.2.2.3
	Kernel-5_35-4_79_2_98:4.2.2.3
	Kernel-5_35-4_79_2_97:4.2.2.3
	Kernel-5_35-4_79_2_96:4.2.2.3
	Kernel-5_35-4_79_2_95:4.2.2.3
	Kernel-5_35-4_79_2_94:4.2.2.3
	Kernel-5_35-4_79_2_93:4.2.2.3
	Kernel-5_35-4_79_2_92:4.2.2.3
	Kernel-5_35-4_79_2_91:4.2.2.3
	Kernel-5_35-4_79_2_90:4.2.2.3
	Kernel-5_35-4_79_2_89:4.2.2.3
	Kernel-5_35-4_79_2_88:4.2.2.3
	Kernel-5_35-4_79_2_87:4.2.2.3
	Kernel-5_35-4_79_2_86:4.2.2.3
	Kernel-5_35-4_79_2_85:4.2.2.3
	Kernel-5_35-4_79_2_84:4.2.2.3
	Kernel-5_35-4_79_2_83:4.2.2.3
	Kernel-5_35-4_79_2_82:4.2.2.3
	Kernel-5_35-4_79_2_81:4.2.2.3
	Kernel-5_35-4_79_2_80:4.2.2.3
	Kernel-5_35-4_79_2_79:4.2.2.3
	Kernel-5_35-4_79_2_78:4.2.2.3
	Kernel-5_35-4_79_2_77:4.2.2.3
	RO_5_07:4.2.2.3
	Kernel-5_35-4_79_2_76:4.2.2.3
	Kernel-5_35-4_79_2_75:4.2.2.3
	Kernel-5_35-4_79_2_74:4.2.2.3
	Kernel-5_35-4_79_2_73:4.2.2.3
	Kernel-5_35-4_79_2_72:4.2.2.3
	Kernel-5_35-4_79_2_71:4.2.2.3
	Kernel-5_35-4_79_2_70:4.2.2.3
	Kernel-5_35-4_79_2_69:4.2.2.3
	Kernel-5_35-4_79_2_68:4.2.2.3
	Kernel-5_35-4_79_2_67:4.2.2.3
	Kernel-5_35-4_79_2_66:4.2.2.3
	Kernel-5_35-4_79_2_65:4.2.2.3
	Kernel-5_35-4_79_2_64:4.2.2.3
	Kernel-5_35-4_79_2_63:4.2.2.3
	Kernel-5_35-4_79_2_62:4.2.2.3
	Kernel-5_35-4_79_2_61:4.2.2.3
	Kernel-5_35-4_79_2_59:4.2.2.3
	Kernel-5_35-4_79_2_58:4.2.2.3
	Kernel-5_35-4_79_2_57:4.2.2.3
	Kernel-5_35-4_79_2_56:4.2.2.3
	Kernel-5_35-4_79_2_55:4.2.2.3
	Kernel-5_35-4_79_2_54:4.2.2.3
	Kernel-5_35-4_79_2_53:4.2.2.3
	Kernel-5_35-4_79_2_52:4.2.2.3
	Kernel-5_35-4_79_2_51:4.2.2.3
	Kernel-5_35-4_79_2_50:4.2.2.3
	Kernel-5_35-4_79_2_49:4.2.2.3
	Kernel-5_35-4_79_2_48:4.2.2.3
	Kernel-5_47:4.2
	Kernel-5_46-4_90_2_1:4.2
	nbingham_Kernel_FastNC_dev_bp:4.2
	nbingham_Kernel_FastNC_dev:4.2.0.4
	Kernel-5_46:4.2
	Kernel-5_45:4.2
	Kernel-5_35-4_79_2_47:4.2.2.2
	Kernel-5_35-4_79_2_46:4.2.2.2
	Kernel-5_35-4_79_2_45:4.2.2.2
	Kernel-5_35-4_79_2_44:4.2.2.2
	Kernel-5_35-4_79_2_25_2_2:4.2.2.1
	Kernel-5_35-4_79_2_43:4.2.2.2
	Kernel-5_35-4_79_2_42:4.2.2.2
	Kernel-5_35-4_79_2_41:4.2.2.2
	Kernel-5_35-4_79_2_40:4.2.2.1
	Kernel-5_35-4_79_2_39:4.2.2.1
	Kernel-5_35-4_79_2_38:4.2.2.1
	Kernel-5_35-4_79_2_37:4.2.2.1
	Kernel-5_35-4_79_2_36:4.2.2.1
	Kernel-5_35-4_79_2_35:4.2.2.1
	Kernel-5_35-4_79_2_34:4.2.2.1
	Kernel-5_35-4_79_2_33:4.2.2.1
	Kernel-5_35-4_79_2_32:4.2.2.1
	Kernel-5_44:4.2
	Kernel-5_35-4_79_2_25_2_1:4.2.2.1
	Kernel-5_43:4.2
	Kernel-5_35-4_79_2_31:4.2.2.1
	Kernel-5_35-4_79_2_30:4.2.2.1
	Kernel-5_35-4_79_2_29:4.2.2.1
	Kernel-5_35-4_79_2_28:4.2.2.1
	Kernel-5_35-4_79_2_27:4.2.2.1
	Kernel-5_35-4_79_2_26:4.2.2.1
	Kernel-5_42:4.2
	Kernel-5_41:4.2
	Kernel-5_40:4.2
	Kernel-5_35-4_79_2_25:4.2.2.1
	Kernel-5_35-4_79_2_24:4.2.2.1
	Kernel-5_35-4_79_2_23:4.2.2.1
	Kernel-5_35-4_79_2_22:4.2.2.1
	Kernel-5_35-4_79_2_21:4.2.2.1
	Kernel-5_35-4_79_2_20:4.2.2.1
	Kernel-5_35-4_79_2_19:4.2.2.1
	Kernel-5_35-4_79_2_18:4.2.2.1
	Kernel-5_35-4_79_2_17:4.2.2.1
	Kernel-5_35-4_79_2_16:4.2.2.1
	Kernel-5_35-4_79_2_15:4.2.2.1
	Kernel-5_35-4_79_2_14:4.2.2.1
	Kernel-5_39:4.2
	Kernel-5_13-4_52_2_1:4.1
	Bethany:4.1.0.10
	Kernel-5_38:4.2
	Kernel-5_35-4_79_2_13:4.2.2.1
	Kernel-5_35-4_79_2_12:4.2.2.1
	Kernel-5_35-4_79_2_11:4.2.2.1
	Kernel-5_37:4.2
	Kernel-5_35-4_79_2_10:4.2.2.1
	Kernel-5_35-4_79_2_9:4.2.2.1
	Kernel-5_36:4.2
	Kernel-5_35-4_79_2_8:4.2.2.1
	Kernel-5_35-4_79_2_7:4.2.2.1
	Kernel-5_35-4_79_2_6:4.2.2.1
	Kernel-5_35-4_79_2_5:4.2.2.1
	Kernel-5_35-4_79_2_4:4.2.2.1
	Kernel-5_35-4_79_2_3:4.2.2.1
	Kernel-5_35-4_79_2_2:4.2.2.1
	dellis_autobuild_BaseSW:4.2
	Kernel-5_35-4_79_2_1:4.2.2.1
	HAL:4.2.0.2
	Kernel-5_35:4.2
	Kernel-5_34:4.2
	Kernel-5_33:4.2
	Kernel-5_32:4.2
	Kernel-5_31:4.2
	Kernel-5_30:4.2
	Kernel-5_29:4.2
	Kernel-5_28:4.2
	Kernel-5_27:4.2
	Kernel-5_26:4.2
	Kernel-5_25:4.2
	Kernel-5_24:4.2
	Kernel-5_23:4.2
	Kernel-5_22:4.1
	sbrodie_sedwards_16Mar2000:4.1
	Kernel-5_21:4.1
	Kernel-5_20:4.1
	Kernel-5_19:4.1
	Kernel-5_18:4.1
	Kernel-5_17:4.1
	Kernel-5_16:4.1
	Kernel-5_15:4.1
	Kernel-5_14:4.1
	Kernel-5_13:4.1
	Kernel-5_12:4.1
	Kernel-5_11:4.1
	Kernel-5_10:4.1
	Kernel-5_09:4.1
	Kernel-5_08:4.1
	Kernel-5_07:4.1
	Kernel-5_06:4.1
	Kernel-5_05:4.1
	Kernel-5_04:4.1
	Kernel-5_03:4.1
	Kernel-5_02:4.1
	Kernel-5_01:4.1
	Kernel-5_00:4.1
	Kernel-4_99:4.1
	Kernel-4_98:4.1
	Kernel-4_97:4.1
	Kernel-4_96:4.1
	Kernel-4_95:4.1
	Kernel-4_94:4.1
	Kernel-4_93:4.1
	Kernel-4_92:4.1
	Kernel-4_91:4.1
	Kernel-4_90:4.1
	dcotton_autobuild_BaseSW:4.2
	Kernel-4_89:4.1
	Kernel-4_88:4.1
	Kernel-4_87:4.1
	Kernel-4_86:4.1
	Kernel-4_85:4.1
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.1
	Kernel-4_84:4.1
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.1
	Ursula_RiscPC_bp:4.1
	Kernel-4_83:4.1
	Kernel-4_82:4.1
	Kernel-4_81:4.1
	Kernel-4_80:4.1
	Kernel-4_79:4.1
	Kernel-4_78:4.1
	Kernel-4_77:4.1
	Kernel-4_76:4.1
	Kernel-4_75:4.1
	Kernel-4_74:4.1
	Kernel-4_73:4.1
	Kernel-4_72:4.1
	Kernel-4_71:4.1
	Kernel-4_70:4.1
	Kernel-4_69:4.1
	Kernel-4_68:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.1
	Kernel-4_66:4.1
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.1
	Ursula_merge:4.1
	Kernel-4_64:4.1
	mstphens_Kernel-3_81:4.1
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	mstphens_Kernel-3_80:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula_bp:4.1
	Ursula:4.1.0.4
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2016.06.30.20.08.08;	author jlee;	state Exp;
branches;
next	4.2;
commitid	IWoXxARWeuLDOwcz;

4.2
date	2000.04.04.14.27.30;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.41.19;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	2001.06.26.09.37.11;	author mstephen;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	2002.10.07.17.29.41;	author kbracey;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	2011.11.27.19.18.15;	author rsprowson;	state Exp;
branches;
next	4.2.2.5;
commitid	iuIXfUOByAFYr0Jv;

4.2.2.5
date	2012.02.25.16.19.37;	author jlee;	state Exp;
branches;
next	4.2.2.6;
commitid	ad3WnPntkzrizyUv;

4.2.2.6
date	2016.05.08.17.11.10;	author jlee;	state Exp;
branches;
next	;
commitid	H8vGguuJRqFVxH5z;

4.1.1.1
date	96.11.05.09.41.19;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.11;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.00;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.32;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        SUBT    > HeapSort

; Old API - same as OS_HeapSort32 but flags in top bits of r1

; Just to make this more confusing, the old API always behaves as if bit 31
; of r1 mirrors bit 30 (ie. bit 30 set forces bit 31 set, see PRM 5a-662), so
; we preserve this for old API, but do originally intended thing for new API.

HeapSortRoutine
        Push    "r1,r7,lr"
        AND     r7, r1, #2_011 :SHL: 29
        BIC     r1, r1, #2_111 :SHL: 29
        TST     r7, #1 :SHL: 30
        ORRNE   r7, r7, #1 :SHL: 31
        SWI     XOS_HeapSort32
        Pull    "r1,r7,lr"
        B       SLVK_TestV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; HeapSort routine. Borrowed from Knuth by Tutu. Labels h(i) correspond to
; steps in the algorithm.

; In    r0 = n
;       r1 = array(n) of word size objects (r2 determines type)
;       r2 = address of comparison procedure
;              Special cases:
;                0 -> treat r(n) as array of cardinal
;                1 -> treat r(n) as array of integer
;                2 -> treat r(n) as array of cardinal*
;                3 -> treat r(n) as array of integer*
;                4 -> treat r(n) as array of char* (case insensitive)
;                5 -> treat r(n) as array of char* (case sensitive)
;       r3 = wsptr for comparison procedure (only needed if r2 > 5)
;       r4 = array(n) of things (only needed if r7 & &C0000000)
;       r5 = sizeof(element)    ( ---------  ditto  ---------- )
;       r6 = address of temp slot (only needed if r5 > 16K or r7 & &20000000)
;       r7 = flags
;              bit 31 set -> use r4,r5 on postpass
;              bit 30 set -> build (r1) from r4,r5 in prepass
;              bit 29 set -> use r6 as temp slot

; r10-r12 trashable

hs_array RN     r4
hs_procadr RN   r5
hs_i    RN      r6
hs_j    RN      r7
hs_K    RN      r8
hs_R    RN      r9
hs_l    RN      r10
hs_r    RN      r11
;wp     RN      r12

        GBLL DebugHeapSort
DebugHeapSort SETL {FALSE}

; User sort procedure entered in SVC mode, interrupts enabled
; r0 = contents of array(1)
; r1 = contents of array(2)
; r0-r3 may be trashed
; wp = value requested (trash at your peril; you'll get the bad one next time)

; User sort procedure returns:
;       LT: if f(r0)  < f(r1)
;       GE: if f(r0) => f(r1)
; (ie. N_bit and V_bit only considered)

HeapSortRoutine32 ROUT

        CMP     r0, #2                  ; 0 or 1 elements? No data moved either
        ExitSWIHandler LO               ; VClear in lr and psr

        Push    "r0-r3, hs_array, hs_procadr, hs_i, hs_j, hs_K, hs_R, lr"

        CLRPSR  I_bit, r14              ; Enable interrupts (may take ages)

 [ DebugHeapSort
        STR     r0, ndump               ; For debugging porpoises
 ]
        TST     r7, #1 :SHL: 30         ; Are we to build the pointer array?
        BEQ     %FT01

; Build array of pointers to data blocks for the punter if he desires this
; (lazy slobs abound ...)

; for (i=0; i<n; i++) r(i) = &block + i*sizeof(element);

        MOV     r10, r0                 ; n
        MOV     r14, r1                 ; r14 -> base of pointer array
00      STR     r4, [r14], #4
        ADD     r4, r4, r5              ; r4 += sizeof(element)
        SUBS    r10, r10, #1
        BNE     %BT00


01      SUB     hs_array, r1, #4        ; HeapSort assumes r(1..n) not (0..n-1)

        MOV     hs_procadr, r2          ; Put proc address where we need it

        CMP     hs_procadr, #6          ; Special procedure ?
        ADRLO   r14, hs_Procedures
        LDRLO   hs_procadr, [r14, hs_procadr, LSL #2]
        ADDLO   hs_procadr, hs_procadr, r14

        MOV     wp, r3                  ; Can now use r3 temp. Keep set up
                                        ; for speed during execution

        MOV     hs_l, r0, LSR #1        ; l = floor(n/2) + 1
        ADD     hs_l, hs_l, #1
        MOV     hs_r, r0                ; r = n


h2      CMP     hs_l, #1
        BEQ     %FT10

        SUB     hs_l, hs_l, #1
        LDR     hs_R, [hs_array, hs_l, LSL #2] ; R = R(l)
        MOV     hs_K, hs_R
        B       %FT20

10      LDR     hs_R, [hs_array, hs_r, LSL #2] ; R = R(r)
        MOV     hs_K, hs_R
        LDR     r14, [hs_array, #4]     ; R(r) = R(1)
        STR     r14, [hs_array, hs_r, LSL #2]
        SUB     hs_r, hs_r, #1
        CMP     hs_r, #1                ; IF r=1 THEN R(1) = R
        STREQ   hs_R, [hs_array, #4]
20
 [ DebugHeapSort
 BL DoDebug
 ]

        CMP     hs_r, #1
        BEQ     %FT90                   ; [finished sorting the array]


h3      MOV     hs_j, hs_l


h4      MOV     hs_i, hs_j
        MOV     hs_j, hs_j, LSL #1

 [ DebugHeapSort
 DREG hs_i," i ",cc
 DREG hs_j," j "
 ]
        CMP     hs_j, hs_r
        BEQ     h6
        BHI     h8


h5      LDR     r0, [hs_array, hs_j, LSL #2]
                                        ; IF K(R(j)) < K(R(j+1)) THEN j +:= 1
        ADD     r14, hs_j, #1
        LDR     r1, [hs_array, r14, LSL #2]

      [ NoARMv5
        MOV     lr, pc                  ; r0, r1 for comparison
        MOV     pc, hs_procadr
      |
        BLX     hs_procadr
      ]

        ADDLT   hs_j, hs_j, #1          ; Assumes signed comparison done <<<<<<


h6      MOV     r0, hs_K                ; IF K >= K(R(j)) THEN h8
        LDR     r1, [hs_array, hs_j, LSL #2]

      [ NoARMv5
        MOV     lr, pc                  ; r0, r1 for comparison
        MOV     pc, hs_procadr
      |
        BLX     hs_procadr
      ]

        LDRLT   r14, [hs_array, hs_j, LSL #2] ; R(i) = R(j)
        STRLT   r14, [hs_array, hs_i, LSL #2]
        BLT     h4


h8      STR     hs_R, [hs_array, hs_i, LSL #2] ; R(i) = R
        B       h2


; Array now sorted into order

90      LDR     r14, [sp, #4*7]         ; r7in
        TST     r14, #1 :SHL: 31
        BEQ     %FA99                   ; [no shuffle required, exit]

; Reorder the blocks according to the sorted array of pointers

        LDR     r2, [sp, #4*1]          ; r2 -> list of pointers (r1in)

        ADD     r1, sp, #4*4
        LDMIA   r1, {r1, r8, r9}        ; r4,r5,r6in
                                        ; r1 -> list of blocks
 [ DebugHeapSort
 DREG r2, "pointer array   "
 DREG r1, "base of blocks  "
 DREG r8, "sizeof(element) "
 ]
        MOV     r3, r2                  ; r3 -> first item of current cycle
        LDR     r0, [sp, #0*4]          ; r0 = n
        ADD     r6, r2, r0, LSL #2      ; r6 -> end of array of pointers
        TST     r14, #1 :SHL: 29        ; punter forcing use of his temp slot?
        BNE     %FT94                   ; fine by me!
        CMP     r8, #ScratchSpaceSize
        LDRLS   r9, =ScratchSpace       ; r9 -> temp slot (normally ScratchSpc)
94
 [ DebugHeapSort
 DREG r9, "temp slot       "
 ]

91      SUB     r14, r3, r2
        MOV     r14, r14, LSR #2        ; r14 = index (0..n-1) of current item
        MLA     r4, r14, r8, r1         ; r4 -> current block

        MOV     r5, r3                  ; r5 -> current item
        BL      MoveToTempSlot          ; save first block in temp slot

92      LDR     r7, [r5]                ; r7 -> next block
        MOV     r14, #0
        STR     r14, [r5]               ; mark item 'done'

        SUB     r5, r7, r1              ; r14 := index of next item (r8 pres.)
        DivRem  r14, r5, r8, r0, norem  ; r5,r0 corrupt
        ADD     r5, r2, r14, LSL #2     ; r5 -> next item
 [ DebugHeapSort
 DREG r7, "  next block "
 DREG r5, "   next item "
 ]

        CMP     r5, r3                  ; reached start of cycle?
        MOVEQ   r7, r9                  ; get back from temp slot if last one
        BL      MoveFromGivenSlot       ; corrupts flags, but preserves r5, r3...

        CMP     r5, r3
        MOVNE   r4, r7                  ; update r4 (current block)
        BNE     %BT92

93      LDR     r14, [r3, #4]!          ; skip already-copied items
        CMP     r3, r6
        BCS     %FA99                   ; [reached end]
        CMP     r14, #0
        BEQ     %BT93

        B       %BT91                   ; [found one that hasn't been copied]


; No error return from HeapSort

99      Pull    "r0-r3, hs_array, hs_procadr, hs_i, hs_j, hs_K, hs_R, lr"

; SWIHandler exit takes flags + mode from lr, not psr !!!

        ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r4 -> element to be copied
;       r8 = sizeof(element)
;       r9 -> temp slot

; Out   all preserved

MoveToTempSlot Entry "r4, r8, r9"

        TST     r4, #3                  ; If base and element size wordy
        TSTEQ   r8, #3                  ; then do faster copy. Also temp wordy
        BNE     %FT01

00      SUBS    r8, r8, #4
        LDRPL   r14, [r4], #4
        STRPL   r14, [r9], #4
        BPL     %BT00
        EXIT

01      SUBS    r8, r8, #1
        LDRPLB  r14, [r4], #1
        STRPLB  r14, [r9], #1
        BPL     %BT01
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r4 -> where element is to be copied
;       r7 -> element to be copied
;       r8 = sizeof(element)

; Out   all preserved

MoveFromGivenSlot Entry "r4, r7, r8"

        TST     r4, #3                  ; If dest and element size wordy
        TSTEQ   r8, #3                  ; then do faster copy. Also src wordy
        BNE     %FT01

00      SUBS    r8, r8, #4
        LDRPL   r14, [r7], #4
        STRPL   r14, [r4], #4
        BPL     %BT00
        EXIT

01      SUBS    r8, r8, #1
        LDRPLB  r14, [r7], #1
        STRPLB  r14, [r4], #1
        BPL     %BT01
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Built-in sorting procedures

hs_Procedures

        DCD     hs_CardinalCMP    - hs_Procedures
        DCD     hs_IntegerCMP     - hs_Procedures
        DCD     hs_CardinalPtrCMP - hs_Procedures
        DCD     hs_IntegerPtrCMP  - hs_Procedures
        DCD     hs_StringCMP      - hs_Procedures
        DCD     hs_StringSensCMP  - hs_Procedures

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0, r1 -> cardinals

; Out   flags set on (*r0) - (*r1)

hs_CardinalPtrCMP

        LDR     r0, [r0]
        LDR     r1, [r1]

; .............................................................................
; In    r0, r1 = cardinals

; Out   flags set on r0 - r1

hs_CardinalCMP

        CMP     r0, r1
        MSRCS   CPSR_f, #C_bit      ; CS -> GE (nv)
        MSRCC   CPSR_f, #N_bit      ; CC -> LT (Nv)
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0, r1 -> integers

; Out   flags set on (*r0) - (*r1)

hs_IntegerPtrCMP

        LDR     r0, [r0]
        LDR     r1, [r1]

; .............................................................................
; In    r0, r1 = integers

; Out   flags set on r0 - r1

hs_IntegerCMP

        CMP     r0, r1
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Case-insensitive string comparison

; In    r0, r1 -> strings - CtrlChar terminated (NB. Must be same CtrlChar !)

; Out   flags set on (char *)(r0) - (char *)(r1) compare

hs_StringCMP ROUT

10      LDRB    r2, [r0], #1
        LowerCase r2, r12
        LDRB    r3, [r1], #1
        LowerCase r3, r12
        CMP     r2, r3                  ; Differ ?
        MOVNE   pc, lr                  ; GE or LT
        CMP     r2, #space-1            ; Finished ?
        BHI     %BT10

        CMP     r2, r2                  ; return EQ (also GE)
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Case-sensitive string comparison

; In    r0, r1 -> strings - CtrlChar terminated (NB. Must be same CtrlChar !)

; Out   flags set on (char *)(r0) - (char *)(r1)

hs_StringSensCMP ROUT

10      LDRB    r2, [r0], #1
        LDRB    r3, [r1], #1
        CMP     r2, r3                  ; Differ ?
        MOVNE   pc, lr                  ; GE or LT
        CMP     r2, #space-1            ; Finished ?
        BHI     %BT10

        CMP     r2, r2                  ; return EQ (also GE)
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        LTORG

        END
@


4.2
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d17 16
a38 3
;              bit 31 set -> use r4,r5 on postpass
;              bit 30 set -> build (r1) from r4,r5 in prepass
;              bit 29 set -> use r6 as temp slot
d48 1
a48 1
;       r4 = array(n) of things (only needed if r1 & 0xC0000000)
d50 5
a54 1
;       r6 = address of temp slot (only needed if r5 > 16K or r1 & 0x20000000)
d68 3
d82 1
a82 1
HeapSortRoutine ROUT
d91 1
a91 1
 [ False
d94 1
a94 2
        TST     r1, #1 :SHL: 30         ; Are we to build the pointer array?
        BIC     r1, r1, #2_111 :SHL: 29 ; Take out flag bits for now
d143 1
a143 1
 [ False
d157 1
a157 1
 [ False
d171 1
d174 3
d184 1
d187 3
d202 2
a203 2
90      LDR     r14, [sp, #4*1]         ; r1in
        TST     r14, #1 :SHL: 30
d208 1
a208 2
        BIC     r2, r14, #2_111 :SHL: 29 ; r2 -> list of pointers
                                        ; keep r14 ok for below
d213 1
a213 1
 [ False
d226 1
a226 1
 [ False
d242 1
a242 1
        DivRem  r14, r5, r8, r0         ; r5,r0 corrupt
d244 1
a244 1
 [ False
d281 1
a281 1
MoveToTempSlot ENTRY "r4, r8, r9"
d306 1
a306 1
MoveFromGivenSlot ENTRY "r4, r7, r8"
d354 2
a355 2
        msr CS, CPSR_f, #C_bit      ; CS -> GE (nv)
        msr CC, CPSR_f, #N_bit      ; CC -> LT (Nv)
@


4.2.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d255 1
a255 1
MoveToTempSlot Entry "r4, r8, r9"
d280 1
a280 1
MoveFromGivenSlot Entry "r4, r7, r8"
d328 2
a329 2
        MSRCS   CPSR_f, #C_bit      ; CS -> GE (nv)
        MSRCC   CPSR_f, #N_bit      ; CC -> LT (Nv)
@


4.2.2.2
log
@1) Bring IOMD HAL more up to date. Add support for new
call HAL_CleanerSpace (preparation for StrongARM kernel
support).

2) In kernel, add HAL_CleanerSpace call (preparation for
StrongARM and XScale core support). Fix bug found with
ARMv3 support during test on Risc PC.

3) Implement new API for kernel SWIs that have used top
bits of addresses as flags. The new API has an extra
flag that must be set, so kernel can distinguish and
support both APIs. The reason for all this is that
addresses are 32-bits now, people, keep up there. Briefly:

  OS_HeapSort
    bit 31 of r0 set for new API, r1 is full 32-bit address
    flags move from r1 bits 31-29 to r0 bits 30-28

  OS_ReadLine
    bit 31 of r1 set for new API, r0 is full 32-bit address
    flags move from bits 31,30 of r0 to bits 30,29 of r1

  OS_SubstituteArgs
    bit 31 of r2 set for new API, r0 is full 32-bit address
    flag moves from bit 31 of r0 to bit 30 of r2

Tested on Risc PC and briefly on Customer A 2

Ta

Version 5.35, 4.79.2.41. Tagged as 'Kernel-5_35-4_79_2_41'
@
text
@d21 1
a21 7
;mjs June 2001, API adjusted to allow for full 32-bit addresses

; In    r0 = n (maximum of 268,435,455), and flags in top 4 bits
;              bit 31 *must* be set, flagging new API to allow full 32-bit addresses
;              bit 30 set -> use r4,r5 on postpass
;              bit 29 set -> build (r1) from r4,r5 in prepass
;              bit 28 set -> use r6 as temp slot
d23 3
d35 1
a35 1
;       r4 = array(n) of things (only needed if r0 & &60000000)
d37 1
a37 9
;       r6 = address of temp slot (only needed if r5 > 16K or r0 & &10000000)

;For backward compatibility, supports old API assuming addresses are safe
;(specifically, that address in r1 does not have any of top 3 bits set)
;
;The old API uses bits 31-29 of r1 to mean the equivalent of bits 30-28 of r0
;as defined above. Just to make this more confusing, the old API always behaves
;as if bit 31 of r1 mirrors bit 30 (ie. bit 30 set forces bit 31 set, see PRM 5a-662),
;so we preserve this for old API, but do originally intended thing for new API.
d64 1
a64 3
        BIC     r10, r0, #&F0000000     ; n (zapping flag bits)

        CMP     r10, #2                 ; 0 or 1 elements? No data moved either
d74 2
a75 8

        TST     r0, #&80000000          ; test old/new API
        MOVNE   r10, r0                 ; new, flags are in r0
        BICNE   r0, r0, #&F0000000      ; zap new flags
        MOVEQ   r10, r1, LSR #1         ; old, flags are in r1, 1 bit to left
        BICEQ   r1, r1, #&E0000000      ; zap old flags

        TST     r10, #&20000000         ; Are we to build the pointer array?
d90 1
d175 2
a176 12
90      LDR     r14, [sp, #4*0]         ; r0in
        LDR     r2, [sp, #4*1]          ; r1in
        TST     r14, #&80000000         ; check for old/new API
        ANDEQ   r8, r2, #&E0000000
        ORREQ   r14, r14, r8, LSR #1    ; old, munge old flag bits into r14
        BICEQ   r2, r2, #&E0000000      ; clear from r2

        ORREQ   r14, r14, #&40000000    ; ho hum fudge to make old bit 31 mirror
        TSTEQ   r14, #&20000000         ; old bit 30 if using old API (behave as errata
        BICEQ   r14, r14, #&40000000    ; in PRM 5a-662)

        TST     r14, #&40000000         ; check for postpass
d181 3
d193 1
a193 1
        BIC     r0, r14, #&F0000000     ; r0 = n
d195 1
a195 1
        TST     r14, #&10000000         ; punter forcing use of his temp slot?
@


4.2.2.3
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a16 16
; Old API - same as OS_HeapSort32 but flags in top bits of r1

; Just to make this more confusing, the old API always behaves as if bit 31
; of r1 mirrors bit 30 (ie. bit 30 set forces bit 31 set, see PRM 5a-662), so
; we preserve this for old API, but do originally intended thing for new API.

HeapSortRoutine
        Push    "r1,r7,lr"
        AND     r7, r1, #2_011 :SHL: 29
        BIC     r1, r1, #2_111 :SHL: 29
        TST     r7, #1 :SHL: 30
        ORRNE   r7, r7, #1 :SHL: 31
        SWI     XOS_HeapSort32
        Pull    "r1,r7,lr"
        B       SLVK_TestV

d21 7
a27 1
; In    r0 = n
d38 1
a38 1
;       r4 = array(n) of things (only needed if r7 & &C0000000)
d40 9
a48 5
;       r6 = address of temp slot (only needed if r5 > 16K or r7 & &20000000)
;       r7 = flags
;              bit 31 set -> use r4,r5 on postpass
;              bit 30 set -> build (r1) from r4,r5 in prepass
;              bit 29 set -> use r6 as temp slot
d73 3
a75 1
HeapSortRoutine32 ROUT
d77 1
a77 1
        CMP     r0, #2                  ; 0 or 1 elements? No data moved either
d87 8
a94 1
        TST     r7, #1 :SHL: 30         ; Are we to build the pointer array?
a108 1

d193 12
a204 2
90      LDR     r14, [sp, #4*7]         ; r7in
        TST     r14, #1 :SHL: 31
a208 2
        LDR     r2, [sp, #4*1]          ; r2 -> list of pointers (r1in)

d218 1
a218 1
        LDR     r0, [sp, #0*4]          ; r0 = n
d220 1
a220 1
        TST     r14, #1 :SHL: 29        ; punter forcing use of his temp slot?
@


4.2.2.4
log
@Rationalise some old switches.
Export less in hdr:RISCOS.
Delete unused GetDecimalPair routine.
Move CheckYear with other RTC stuff out of PMF/osword.
Hide DebugROMInit and DebugROMErrors in release (even numbered) versions.

Version 5.35, 4.79.2.127. Tagged as 'Kernel-5_35-4_79_2_127'
@
text
@a67 3
        GBLL DebugHeapSort
DebugHeapSort SETL {FALSE}

d88 1
a88 1
 [ DebugHeapSort
d140 1
a140 1
 [ DebugHeapSort
d154 1
a154 1
 [ DebugHeapSort
d202 1
a202 1
 [ DebugHeapSort
d215 1
a215 1
 [ DebugHeapSort
d233 1
a233 1
 [ DebugHeapSort
@


4.2.2.5
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@a170 1
      [ NoARMv5
a172 3
      |
        BLX     hs_procadr
      ]
a179 1
      [ NoARMv5
a181 3
      |
        BLX     hs_procadr
      ]
@


4.2.2.6
log
@Avoid unnecesssary remainder calculations
Detail:
  s/HeapSort, s/vdu/vdugrafc, s/vdu/vduswis - Avoid unnecessary remainder calculations in DivRem macro
  s/PMF/i2cutils, s/PMF/osword - Make use of DivRem's ability to accept a constant as the divisor
Admin:
  Tested on Cortex-A15


Version 5.35, 4.79.2.318. Tagged as 'Kernel-5_35-4_79_2_318'
@
text
@d242 1
a242 1
        DivRem  r14, r5, r8, r0, norem  ; r5,r0 corrupt
@


4.1
log
@Initial revision
@
text
@d69 1
a69 2
        MVN     r14, #I_bit             ; Enable interrupts (may take ages)
        TSTP    r14, pc
a163 3
 [ True ; 1.73+ optimisation, faster in all cases
                                        ; Assumes signed comparison done <<<<<<
;h7
a166 8
 |
        BGE     h8                      ; Assumes signed comparison done <<<<<<

;h7
        LDR     r14, [hs_array, hs_j, LSL #2] ; R(i) = R(j)
        STR     r14, [hs_array, hs_i, LSL #2]
        B       h4
 ]
d225 1
a225 1
        BL      MoveFromGivenSlot       ; preserves flags
d227 1
d265 1
a265 1
        EXITS
d271 1
a271 1
        EXITS
d290 1
a290 1
        EXITS
d296 1
a296 1
        EXITS
d328 3
a330 3
        BICCSS  pc, lr, #N_bit :OR: V_bit       ; CS -> GE (nv)
        BIC     lr, lr, #V_bit
        ORRS    pc, lr, #N_bit                  ; CC -> LT (Nv)
d370 2
a371 1
        BICS    pc, lr, #N_bit :OR: V_bit ; GE
d389 2
a390 1
        BICS    pc, lr, #N_bit :OR: V_bit ; GE
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

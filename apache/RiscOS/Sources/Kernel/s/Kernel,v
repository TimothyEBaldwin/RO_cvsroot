head	4.24;
access;
symbols
	Kernel-6_15:4.24
	Kernel-6_14:4.24
	Kernel-6_01-3:4.23
	Kernel-6_13:4.24
	Kernel-6_12:4.24
	Kernel-6_11:4.24
	Kernel-6_10:4.24
	Kernel-6_09:4.24
	Kernel-6_08-4_129_2_10:4.23.2.1
	Kernel-6_08-4_129_2_9:4.23.2.1
	Kernel-6_08:4.24
	Kernel-6_07:4.24
	Kernel-6_06:4.24
	Kernel-6_05-4_129_2_8:4.23.2.1
	Kernel-6_05:4.24
	Kernel-6_04:4.24
	Kernel-6_03:4.23
	Kernel-6_01-2:4.23
	Kernel-6_01-4_146_2_1:4.23
	Kernel-6_02:4.23
	Kernel-6_01-1:4.23
	Kernel-6_01:4.23
	Kernel-6_00:4.23
	Kernel-5_99:4.23
	Kernel-5_98:4.23
	Kernel-5_97-4_129_2_7:4.23
	Kernel-5_97:4.23
	Kernel-5_96:4.23
	Kernel-5_95:4.23
	Kernel-5_94:4.23
	Kernel-5_93:4.23
	Kernel-5_92:4.23
	Kernel-5_91:4.23
	Kernel-5_90:4.23
	Kernel-5_89-4_129_2_6:4.23
	Kernel-5_89:4.23
	Kernel-5_88-4_129_2_5:4.23
	Kernel-5_88-4_129_2_4:4.23
	Kernel-5_88:4.23
	Kernel-5_87:4.23
	Kernel-5_86-4_129_2_3:4.23
	Kernel-5_86-4_129_2_2:4.23
	Kernel-5_86-4_129_2_1:4.23
	Kernel-5_86:4.23
	SMP:4.23.0.2
	SMP_bp:4.23
	Kernel-5_85:4.23
	Kernel-5_54-1:4.17
	Kernel-5_84:4.23
	Kernel-5_83:4.23
	Kernel-5_82:4.23
	Kernel-5_81:4.23
	Kernel-5_80:4.23
	Kernel-5_79:4.23
	Kernel-5_78:4.23
	Kernel-5_77:4.23
	Kernel-5_76:4.22
	Kernel-5_75:4.22
	Kernel-5_74:4.22
	Kernel-5_73:4.22
	Kernel-5_72:4.22
	Kernel-5_71:4.22
	Kernel-5_70:4.21
	Kernel-5_69:4.21
	Kernel-5_68:4.21
	Kernel-5_67:4.21
	Kernel-5_66:4.21
	Kernel-5_65:4.20
	Kernel-5_64:4.19
	Kernel-5_63:4.19
	Kernel-5_62:4.18
	Kernel-5_61:4.18
	Kernel-5_60:4.18
	Kernel-5_59:4.18
	Kernel-5_58:4.18
	Kernel-5_57:4.18
	Kernel-5_56:4.18
	Kernel-5_55:4.18
	Kernel-5_54:4.17
	Kernel-5_53:4.17
	Kernel-5_52:4.17
	Kernel-5_51:4.17
	Kernel-5_50:4.16
	Kernel-5_49:4.15
	HAL_merge:4.12.2.47
	Kernel-5_48:4.14
	Kernel-5_35-4_79_2_327:4.12.2.47
	Kernel-5_35-4_79_2_326:4.12.2.46
	Kernel-5_35-4_79_2_325:4.12.2.46
	Kernel-5_35-4_79_2_324:4.12.2.46
	Kernel-5_35-4_79_2_323:4.12.2.46
	Kernel-5_35-4_79_2_322:4.12.2.46
	Kernel-5_35-4_79_2_321:4.12.2.46
	Kernel-5_35-4_79_2_320:4.12.2.46
	Kernel-5_35-4_79_2_319:4.12.2.46
	Kernel-5_35-4_79_2_318:4.12.2.45
	Kernel-5_35-4_79_2_317:4.12.2.45
	Kernel-5_35-4_79_2_316:4.12.2.45
	Kernel-5_35-4_79_2_315:4.12.2.44
	Kernel-5_35-4_79_2_314:4.12.2.43
	Kernel-5_35-4_79_2_313:4.12.2.42
	Kernel-5_35-4_79_2_312:4.12.2.41
	Kernel-5_35-4_79_2_311:4.12.2.41
	Kernel-5_35-4_79_2_310:4.12.2.41
	Kernel-5_35-4_79_2_309:4.12.2.41
	Kernel-5_35-4_79_2_308:4.12.2.41
	Kernel-5_35-4_79_2_307:4.12.2.41
	Kernel-5_35-4_79_2_306:4.12.2.41
	Kernel-5_35-4_79_2_305:4.12.2.41
	Kernel-5_35-4_79_2_304:4.12.2.41
	Kernel-5_35-4_79_2_303:4.12.2.41
	Kernel-5_35-4_79_2_302:4.12.2.41
	Kernel-5_35-4_79_2_301:4.12.2.41
	Kernel-5_35-4_79_2_300:4.12.2.41
	Kernel-5_35-4_79_2_299:4.12.2.41
	Kernel-5_35-4_79_2_298:4.12.2.41
	Kernel-5_35-4_79_2_297:4.12.2.41
	Kernel-5_35-4_79_2_296:4.12.2.41
	Kernel-5_35-4_79_2_295:4.12.2.41
	Kernel-5_35-4_79_2_294:4.12.2.41
	Kernel-5_35-4_79_2_293:4.12.2.41
	Kernel-5_35-4_79_2_292:4.12.2.41
	Kernel-5_35-4_79_2_291:4.12.2.41
	Kernel-5_35-4_79_2_290:4.12.2.41
	Kernel-5_35-4_79_2_289:4.12.2.41
	Kernel-5_35-4_79_2_288:4.12.2.41
	Kernel-5_35-4_79_2_287:4.12.2.41
	Kernel-5_35-4_79_2_286:4.12.2.41
	Kernel-5_35-4_79_2_285:4.12.2.41
	Kernel-5_35-4_79_2_284:4.12.2.41
	Kernel-5_35-4_79_2_283:4.12.2.41
	Kernel-5_35-4_79_2_282:4.12.2.41
	Kernel-5_35-4_79_2_281:4.12.2.41
	Kernel-5_35-4_79_2_280:4.12.2.41
	Kernel-5_35-4_79_2_279:4.12.2.41
	Kernel-5_35-4_79_2_278:4.12.2.40
	Kernel-5_35-4_79_2_277:4.12.2.40
	Kernel-5_35-4_79_2_276:4.12.2.40
	Kernel-5_35-4_79_2_275:4.12.2.40
	Kernel-5_35-4_79_2_274:4.12.2.40
	Kernel-5_35-4_79_2_273:4.12.2.40
	Kernel-5_35-4_79_2_272:4.12.2.39
	Kernel-5_35-4_79_2_271:4.12.2.39
	Kernel-5_35-4_79_2_270:4.12.2.38
	Kernel-5_35-4_79_2_269:4.12.2.38
	Kernel-5_35-4_79_2_268:4.12.2.38
	Kernel-5_35-4_79_2_267:4.12.2.38
	Kernel-5_35-4_79_2_266:4.12.2.38
	Kernel-5_35-4_79_2_265:4.12.2.38
	Kernel-5_35-4_79_2_264:4.12.2.38
	Kernel-5_35-4_79_2_263:4.12.2.38
	Kernel-5_35-4_79_2_262:4.12.2.38
	Kernel-5_35-4_79_2_261:4.12.2.38
	Kernel-5_35-4_79_2_260:4.12.2.38
	Kernel-5_35-4_79_2_259:4.12.2.38
	Kernel-5_35-4_79_2_258:4.12.2.38
	Kernel-5_35-4_79_2_257:4.12.2.38
	Kernel-5_35-4_79_2_256:4.12.2.38
	Kernel-5_35-4_79_2_255:4.12.2.38
	Kernel-5_35-4_79_2_254:4.12.2.38
	Kernel-5_35-4_79_2_253:4.12.2.38
	Kernel-5_35-4_79_2_252:4.12.2.38
	Kernel-5_35-4_79_2_251:4.12.2.38
	Kernel-5_35-4_79_2_250:4.12.2.38
	Kernel-5_35-4_79_2_249:4.12.2.38
	Kernel-5_35-4_79_2_248:4.12.2.38
	Kernel-5_35-4_79_2_247:4.12.2.38
	Kernel-5_35-4_79_2_246:4.12.2.38
	Kernel-5_35-4_79_2_245:4.12.2.38
	Kernel-5_35-4_79_2_244:4.12.2.38
	Kernel-5_35-4_79_2_243:4.12.2.38
	Kernel-5_35-4_79_2_242:4.12.2.38
	Kernel-5_35-4_79_2_241:4.12.2.38
	Kernel-5_35-4_79_2_240:4.12.2.38
	Kernel-5_35-4_79_2_239:4.12.2.38
	Kernel-5_35-4_79_2_238:4.12.2.38
	Kernel-5_35-4_79_2_237:4.12.2.38
	Kernel-5_35-4_79_2_236:4.12.2.38
	Kernel-5_35-4_79_2_235:4.12.2.38
	Kernel-5_35-4_79_2_234:4.12.2.38
	Kernel-5_35-4_79_2_233:4.12.2.38
	Kernel-5_35-4_79_2_232:4.12.2.38
	Kernel-5_35-4_79_2_231:4.12.2.38
	Kernel-5_35-4_79_2_230:4.12.2.38
	Kernel-5_35-4_79_2_229:4.12.2.38
	Kernel-5_35-4_79_2_228:4.12.2.38
	Kernel-5_35-4_79_2_227:4.12.2.38
	Kernel-5_35-4_79_2_226:4.12.2.38
	Kernel-5_35-4_79_2_225:4.12.2.38
	Kernel-5_35-4_79_2_224:4.12.2.38
	Kernel-5_35-4_79_2_223:4.12.2.38
	Kernel-5_35-4_79_2_222:4.12.2.38
	Kernel-5_35-4_79_2_221:4.12.2.37
	Kernel-5_35-4_79_2_220:4.12.2.37
	Kernel-5_35-4_79_2_219:4.12.2.37
	Kernel-5_35-4_79_2_218:4.12.2.37
	Kernel-5_35-4_79_2_217:4.12.2.37
	Kernel-5_35-4_79_2_216:4.12.2.37
	Kernel-5_35-4_79_2_215:4.12.2.37
	Kernel-5_35-4_79_2_214:4.12.2.36
	Kernel-5_35-4_79_2_213:4.12.2.36
	Kernel-5_35-4_79_2_212:4.12.2.36
	Kernel-5_35-4_79_2_211:4.12.2.36
	Kernel-5_35-4_79_2_210:4.12.2.36
	Kernel-5_35-4_79_2_209:4.12.2.36
	Kernel-5_35-4_79_2_208:4.12.2.36
	Kernel-5_35-4_79_2_207:4.12.2.35
	Kernel-5_35-4_79_2_206:4.12.2.35
	Kernel-5_35-4_79_2_205:4.12.2.35
	Kernel-5_35-4_79_2_204:4.12.2.35
	Kernel-5_35-4_79_2_203:4.12.2.35
	Kernel-5_35-4_79_2_202:4.12.2.35
	Kernel-5_35-4_79_2_201:4.12.2.35
	Kernel-5_35-4_79_2_200:4.12.2.35
	Kernel-5_35-4_79_2_199:4.12.2.35
	Kernel-5_35-4_79_2_198:4.12.2.35
	Kernel-5_35-4_79_2_197:4.12.2.35
	Kernel-5_35-4_79_2_196:4.12.2.35
	Kernel-5_35-4_79_2_195:4.12.2.35
	Kernel-5_35-4_79_2_194:4.12.2.35
	Kernel-5_35-4_79_2_193:4.12.2.35
	Kernel-5_35-4_79_2_192:4.12.2.35
	Kernel-5_35-4_79_2_191:4.12.2.35
	Kernel-5_35-4_79_2_190:4.12.2.35
	Kernel-5_35-4_79_2_189:4.12.2.35
	Kernel-5_35-4_79_2_188:4.12.2.35
	Kernel-5_35-4_79_2_187:4.12.2.35
	Kernel-5_35-4_79_2_186:4.12.2.35
	Kernel-5_35-4_79_2_185:4.12.2.35
	Kernel-5_35-4_79_2_184:4.12.2.35
	Kernel-5_35-4_79_2_183:4.12.2.35
	Kernel-5_35-4_79_2_182:4.12.2.35
	Kernel-5_35-4_79_2_181:4.12.2.35
	Kernel-5_35-4_79_2_180:4.12.2.35
	Kernel-5_35-4_79_2_179:4.12.2.34
	Kernel-5_35-4_79_2_178:4.12.2.34
	Kernel-5_35-4_79_2_177:4.12.2.34
	Kernel-5_35-4_79_2_176:4.12.2.34
	Kernel-5_35-4_79_2_175:4.12.2.34
	Kernel-5_35-4_79_2_174:4.12.2.34
	Kernel-5_35-4_79_2_173:4.12.2.34
	Kernel-5_35-4_79_2_172:4.12.2.34
	Kernel-5_35-4_79_2_171:4.12.2.34
	Kernel-5_35-4_79_2_170:4.12.2.34
	Kernel-5_35-4_79_2_169:4.12.2.34
	Kernel-5_35-4_79_2_168:4.12.2.34
	Kernel-5_35-4_79_2_167:4.12.2.34
	Kernel-5_35-4_79_2_166:4.12.2.34
	Kernel-5_35-4_79_2_165:4.12.2.34
	RPi_merge:4.12.2.29.2.8
	Kernel-5_35-4_79_2_147_2_23:4.12.2.29.2.8
	Kernel-5_35-4_79_2_147_2_22:4.12.2.29.2.7
	Kernel-5_35-4_79_2_147_2_21:4.12.2.29.2.7
	Kernel-5_35-4_79_2_147_2_20:4.12.2.29.2.7
	Kernel-5_35-4_79_2_147_2_19:4.12.2.29.2.6
	Kernel-5_35-4_79_2_147_2_18:4.12.2.29.2.6
	Kernel-5_35-4_79_2_164:4.12.2.33
	Kernel-5_35-4_79_2_163:4.12.2.33
	Kernel-5_35-4_79_2_147_2_17:4.12.2.29.2.5
	Kernel-5_35-4_79_2_147_2_16:4.12.2.29.2.5
	Kernel-5_35-4_79_2_147_2_15:4.12.2.29.2.5
	Kernel-5_35-4_79_2_162:4.12.2.33
	Kernel-5_35-4_79_2_161:4.12.2.33
	Kernel-5_35-4_79_2_147_2_14:4.12.2.29.2.4
	Kernel-5_35-4_79_2_147_2_13:4.12.2.29.2.4
	Kernel-5_35-4_79_2_160:4.12.2.33
	Kernel-5_35-4_79_2_159:4.12.2.33
	Kernel-5_35-4_79_2_158:4.12.2.33
	Kernel-5_35-4_79_2_157:4.12.2.33
	Kernel-5_35-4_79_2_156:4.12.2.32
	Kernel-5_35-4_79_2_147_2_12:4.12.2.29.2.4
	Kernel-5_35-4_79_2_147_2_11:4.12.2.29.2.4
	Kernel-5_35-4_79_2_155:4.12.2.32
	Kernel-5_35-4_79_2_147_2_10:4.12.2.29.2.4
	Kernel-5_35-4_79_2_154:4.12.2.32
	Kernel-5_35-4_79_2_153:4.12.2.32
	Kernel-5_35-4_79_2_147_2_9:4.12.2.29.2.4
	Kernel-5_35-4_79_2_152:4.12.2.31
	Kernel-5_35-4_79_2_151:4.12.2.31
	Kernel-5_35-4_79_2_147_2_8:4.12.2.29.2.4
	Kernel-5_35-4_79_2_147_2_7:4.12.2.29.2.4
	Kernel-5_35-4_79_2_150:4.12.2.31
	Kernel-5_35-4_79_2_147_2_6:4.12.2.29.2.4
	Kernel-5_35-4_79_2_147_2_5:4.12.2.29.2.3
	Kernel-5_35-4_79_2_149:4.12.2.30
	Kernel-5_35-4_79_2_147_2_4:4.12.2.29.2.2
	Kernel-5_35-4_79_2_147_2_3:4.12.2.29.2.1
	Kernel-5_35-4_79_2_148:4.12.2.30
	Kernel-5_35-4_79_2_147_2_2:4.12.2.29.2.1
	Kernel-5_35-4_79_2_147_2_1:4.12.2.29.2.1
	RPi:4.12.2.29.0.2
	RPi_bp:4.12.2.29
	Kernel-5_35-4_79_2_98_2_52_2_1:4.12.2.22.2.4.2.1
	alees_Kernel_dev:4.12.2.22.2.4.0.2
	alees_Kernel_dev_bp:4.12.2.22.2.4
	Kernel-5_35-4_79_2_147:4.12.2.29
	Kernel-5_35-4_79_2_146:4.12.2.29
	Kernel-5_35-4_79_2_145:4.12.2.29
	Kernel-5_35-4_79_2_144:4.12.2.29
	Kernel-5_35-4_79_2_143:4.12.2.29
	Kernel-5_35-4_79_2_142:4.12.2.29
	Kernel-5_35-4_79_2_141:4.12.2.29
	Kernel-5_35-4_79_2_140:4.12.2.29
	Kernel-5_35-4_79_2_139:4.12.2.29
	Kernel-5_35-4_79_2_138:4.12.2.29
	Kernel-5_35-4_79_2_137:4.12.2.28
	Kernel-5_35-4_79_2_136:4.12.2.28
	Kernel-5_35-4_79_2_135:4.12.2.28
	Kernel-5_35-4_79_2_134:4.12.2.28
	Kernel-5_35-4_79_2_133:4.12.2.28
	Kernel-5_35-4_79_2_132:4.12.2.28
	Kernel-5_35-4_79_2_131:4.12.2.28
	Kernel-5_35-4_79_2_130:4.12.2.28
	Kernel-5_35-4_79_2_129:4.12.2.28
	Kernel-5_35-4_79_2_128:4.12.2.28
	Kernel-5_35-4_79_2_127:4.12.2.28
	Kernel-5_35-4_79_2_126:4.12.2.27
	Kernel-5_35-4_79_2_125:4.12.2.26
	Kernel-5_35-4_79_2_124:4.12.2.25
	Kernel-5_35-4_79_2_123:4.12.2.25
	Cortex_merge:4.12.2.22.2.4
	Kernel-5_35-4_79_2_122:4.12.2.24
	Kernel-5_35-4_79_2_98_2_54:4.12.2.22.2.4
	Kernel-5_35-4_79_2_98_2_53:4.12.2.22.2.4
	Kernel-5_35-4_79_2_98_2_52:4.12.2.22.2.4
	Kernel-5_35-4_79_2_98_2_51:4.12.2.22.2.4
	Kernel-5_35-4_79_2_98_2_50:4.12.2.22.2.4
	Kernel-5_35-4_79_2_98_2_49:4.12.2.22.2.4
	Kernel-5_35-4_79_2_98_2_48:4.12.2.22.2.4
	Kernel-5_35-4_79_2_121:4.12.2.24
	Kernel-5_35-4_79_2_98_2_47:4.12.2.22.2.3
	Kernel-5_35-4_79_2_120:4.12.2.24
	Kernel-5_35-4_79_2_98_2_46:4.12.2.22.2.3
	Kernel-5_35-4_79_2_119:4.12.2.23
	Kernel-5_35-4_79_2_98_2_45:4.12.2.22.2.2
	Kernel-5_35-4_79_2_98_2_44:4.12.2.22.2.2
	Kernel-5_35-4_79_2_118:4.12.2.23
	Kernel-5_35-4_79_2_98_2_43:4.12.2.22.2.2
	Kernel-5_35-4_79_2_117:4.12.2.23
	Kernel-5_35-4_79_2_116:4.12.2.23
	Kernel-5_35-4_79_2_98_2_42:4.12.2.22.2.1
	Kernel-5_35-4_79_2_115:4.12.2.23
	Kernel-5_35-4_79_2_98_2_41:4.12.2.22.2.1
	Kernel-5_35-4_79_2_98_2_40:4.12.2.22.2.1
	Kernel-5_35-4_79_2_114:4.12.2.23
	Kernel-5_35-4_79_2_98_2_39:4.12.2.22.2.1
	Kernel-5_35-4_79_2_98_2_38:4.12.2.22.2.1
	Kernel-5_35-4_79_2_113:4.12.2.23
	Kernel-5_35-4_79_2_112:4.12.2.23
	Kernel-5_35-4_79_2_98_2_37:4.12.2.22.2.1
	Kernel-5_35-4_79_2_98_2_36:4.12.2.22
	Kernel-5_35-4_79_2_98_2_35:4.12.2.22
	Kernel-5_35-4_79_2_98_2_34:4.12.2.22
	Kernel-5_35-4_79_2_98_2_33:4.12.2.22
	Kernel-5_35-4_79_2_98_2_32:4.12.2.22
	Kernel-5_35-4_79_2_98_2_31:4.12.2.22
	Kernel-5_35-4_79_2_98_2_30:4.12.2.22
	Kernel-5_35-4_79_2_98_2_29:4.12.2.22
	Kernel-5_35-4_79_2_98_2_28:4.12.2.22
	Kernel-5_35-4_79_2_98_2_27:4.12.2.22
	Kernel-5_35-4_79_2_98_2_26:4.12.2.22
	Kernel-5_35-4_79_2_111:4.12.2.23
	Kernel-5_35-4_79_2_98_2_25:4.12.2.22
	Kernel-5_35-4_79_2_98_2_24:4.12.2.22
	Kernel-5_35-4_79_2_98_2_23:4.12.2.22
	Kernel-5_35-4_79_2_110:4.12.2.23
	Kernel-5_35-4_79_2_98_2_22:4.12.2.22
	Kernel-5_35-4_79_2_109:4.12.2.23
	Kernel-5_35-4_79_2_98_2_21:4.12.2.22
	Kernel-5_35-4_79_2_98_2_20:4.12.2.22
	Kernel-5_35-4_79_2_108:4.12.2.23
	Kernel-5_35-4_79_2_107:4.12.2.23
	Kernel-5_35-4_79_2_98_2_19:4.12.2.22
	Kernel-5_35-4_79_2_98_2_18:4.12.2.22
	Kernel-5_35-4_79_2_98_2_17:4.12.2.22
	Kernel-5_35-4_79_2_98_2_16:4.12.2.22
	Kernel-5_35-4_79_2_98_2_15:4.12.2.22
	Kernel-5_35-4_79_2_106:4.12.2.23
	Kernel-5_35-4_79_2_105:4.12.2.23
	Kernel-5_35-4_79_2_104:4.12.2.23
	Kernel-5_35-4_79_2_98_2_14:4.12.2.22
	Kernel-5_35-4_79_2_98_2_13:4.12.2.22
	Kernel-5_35-4_79_2_98_2_12:4.12.2.22
	Kernel-5_35-4_79_2_98_2_11:4.12.2.22
	Kernel-5_35-4_79_2_98_2_10:4.12.2.22
	Kernel-5_35-4_79_2_98_2_9:4.12.2.22
	Kernel-5_35-4_79_2_103:4.12.2.23
	Kernel-5_35-4_79_2_102:4.12.2.23
	Kernel-5_35-4_79_2_98_2_8:4.12.2.22
	Kernel-5_35-4_79_2_98_2_7:4.12.2.22
	Kernel-5_35-4_79_2_98_2_6:4.12.2.22
	Kernel-5_35-4_79_2_98_2_5:4.12.2.22
	Kernel-5_35-4_79_2_98_2_4:4.12.2.22
	Kernel-5_35-4_79_2_101:4.12.2.23
	Kernel-5_35-4_79_2_100:4.12.2.23
	Kernel-5_35-4_79_2_99:4.12.2.23
	Kernel-5_35-4_79_2_98_2_3:4.12.2.22
	Kernel-5_35-4_79_2_98_2_2:4.12.2.22
	Kernel-5_35-4_79_2_98_2_1:4.12.2.22
	Cortex:4.12.2.22.0.2
	Cortex_bp:4.12.2.22
	Kernel-5_35-4_79_2_98:4.12.2.22
	Kernel-5_35-4_79_2_97:4.12.2.22
	Kernel-5_35-4_79_2_96:4.12.2.22
	Kernel-5_35-4_79_2_95:4.12.2.22
	Kernel-5_35-4_79_2_94:4.12.2.22
	Kernel-5_35-4_79_2_93:4.12.2.22
	Kernel-5_35-4_79_2_92:4.12.2.22
	Kernel-5_35-4_79_2_91:4.12.2.22
	Kernel-5_35-4_79_2_90:4.12.2.22
	Kernel-5_35-4_79_2_89:4.12.2.22
	Kernel-5_35-4_79_2_88:4.12.2.22
	Kernel-5_35-4_79_2_87:4.12.2.22
	Kernel-5_35-4_79_2_86:4.12.2.22
	Kernel-5_35-4_79_2_85:4.12.2.22
	Kernel-5_35-4_79_2_84:4.12.2.22
	Kernel-5_35-4_79_2_83:4.12.2.22
	Kernel-5_35-4_79_2_82:4.12.2.22
	Kernel-5_35-4_79_2_81:4.12.2.22
	Kernel-5_35-4_79_2_80:4.12.2.22
	Kernel-5_35-4_79_2_79:4.12.2.22
	Kernel-5_35-4_79_2_78:4.12.2.22
	Kernel-5_35-4_79_2_77:4.12.2.22
	RO_5_07:4.12.2.22
	Kernel-5_35-4_79_2_76:4.12.2.22
	Kernel-5_35-4_79_2_75:4.12.2.22
	Kernel-5_35-4_79_2_74:4.12.2.22
	Kernel-5_35-4_79_2_73:4.12.2.22
	Kernel-5_35-4_79_2_72:4.12.2.22
	Kernel-5_35-4_79_2_71:4.12.2.22
	Kernel-5_35-4_79_2_70:4.12.2.22
	Kernel-5_35-4_79_2_69:4.12.2.22
	Kernel-5_35-4_79_2_68:4.12.2.22
	Kernel-5_35-4_79_2_67:4.12.2.22
	Kernel-5_35-4_79_2_66:4.12.2.22
	Kernel-5_35-4_79_2_65:4.12.2.21
	Kernel-5_35-4_79_2_64:4.12.2.21
	Kernel-5_35-4_79_2_63:4.12.2.21
	Kernel-5_35-4_79_2_62:4.12.2.21
	Kernel-5_35-4_79_2_61:4.12.2.21
	Kernel-5_35-4_79_2_59:4.12.2.21
	Kernel-5_35-4_79_2_58:4.12.2.21
	Kernel-5_35-4_79_2_57:4.12.2.21
	Kernel-5_35-4_79_2_56:4.12.2.21
	Kernel-5_35-4_79_2_55:4.12.2.20
	Kernel-5_35-4_79_2_54:4.12.2.19
	Kernel-5_35-4_79_2_53:4.12.2.19
	Kernel-5_35-4_79_2_52:4.12.2.19
	Kernel-5_35-4_79_2_51:4.12.2.19
	Kernel-5_35-4_79_2_50:4.12.2.18
	Kernel-5_35-4_79_2_49:4.12.2.18
	Kernel-5_35-4_79_2_48:4.12.2.17
	Kernel-5_47:4.13
	Kernel-5_46-4_90_2_1:4.13
	nbingham_Kernel_FastNC_dev_bp:4.13
	nbingham_Kernel_FastNC_dev:4.13.0.2
	Kernel-5_46:4.13
	Kernel-5_45:4.13
	Kernel-5_35-4_79_2_47:4.12.2.16
	Kernel-5_35-4_79_2_46:4.12.2.16
	Kernel-5_35-4_79_2_45:4.12.2.16
	Kernel-5_35-4_79_2_44:4.12.2.16
	Kernel-5_35-4_79_2_25_2_2:4.12.2.12
	Kernel-5_35-4_79_2_43:4.12.2.16
	Kernel-5_35-4_79_2_42:4.12.2.16
	Kernel-5_35-4_79_2_41:4.12.2.16
	Kernel-5_35-4_79_2_40:4.12.2.16
	Kernel-5_35-4_79_2_39:4.12.2.16
	Kernel-5_35-4_79_2_38:4.12.2.16
	Kernel-5_35-4_79_2_37:4.12.2.15
	Kernel-5_35-4_79_2_36:4.12.2.15
	Kernel-5_35-4_79_2_35:4.12.2.15
	Kernel-5_35-4_79_2_34:4.12.2.15
	Kernel-5_35-4_79_2_33:4.12.2.15
	Kernel-5_35-4_79_2_32:4.12.2.14
	Kernel-5_44:4.12
	Kernel-5_35-4_79_2_25_2_1:4.12.2.12
	Kernel-5_43:4.12
	Kernel-5_35-4_79_2_31:4.12.2.14
	Kernel-5_35-4_79_2_30:4.12.2.13
	Kernel-5_35-4_79_2_29:4.12.2.12
	Kernel-5_35-4_79_2_28:4.12.2.12
	Kernel-5_35-4_79_2_27:4.12.2.12
	Kernel-5_35-4_79_2_26:4.12.2.12
	Kernel-5_42:4.12
	Kernel-5_41:4.12
	Kernel-5_40:4.12
	Kernel-5_35-4_79_2_25:4.12.2.12
	Kernel-5_35-4_79_2_24:4.12.2.12
	Kernel-5_35-4_79_2_23:4.12.2.12
	Kernel-5_35-4_79_2_22:4.12.2.12
	Kernel-5_35-4_79_2_21:4.12.2.12
	Kernel-5_35-4_79_2_20:4.12.2.12
	Kernel-5_35-4_79_2_19:4.12.2.12
	Kernel-5_35-4_79_2_18:4.12.2.11
	Kernel-5_35-4_79_2_17:4.12.2.11
	Kernel-5_35-4_79_2_16:4.12.2.11
	Kernel-5_35-4_79_2_15:4.12.2.11
	Kernel-5_35-4_79_2_14:4.12.2.11
	Kernel-5_39:4.12
	Kernel-5_13-4_52_2_1:4.8
	Bethany:4.8.0.2
	Kernel-5_38:4.12
	Kernel-5_35-4_79_2_13:4.12.2.10
	Kernel-5_35-4_79_2_12:4.12.2.9
	Kernel-5_35-4_79_2_11:4.12.2.9
	Kernel-5_37:4.12
	Kernel-5_35-4_79_2_10:4.12.2.7
	Kernel-5_35-4_79_2_9:4.12.2.7
	Kernel-5_36:4.12
	Kernel-5_35-4_79_2_8:4.12.2.5
	Kernel-5_35-4_79_2_7:4.12.2.5
	Kernel-5_35-4_79_2_6:4.12.2.5
	Kernel-5_35-4_79_2_5:4.12.2.4
	Kernel-5_35-4_79_2_4:4.12.2.3
	Kernel-5_35-4_79_2_3:4.12.2.3
	Kernel-5_35-4_79_2_2:4.12.2.2
	dellis_autobuild_BaseSW:4.12
	Kernel-5_35-4_79_2_1:4.12.2.1
	HAL:4.12.0.2
	Kernel-5_35:4.12
	Kernel-5_34:4.12
	Kernel-5_33:4.12
	Kernel-5_32:4.12
	Kernel-5_31:4.12
	Kernel-5_30:4.12
	Kernel-5_29:4.12
	Kernel-5_28:4.12
	Kernel-5_27:4.12
	Kernel-5_26:4.12
	Kernel-5_25:4.12
	Kernel-5_24:4.10
	Kernel-5_23:4.9
	Kernel-5_22:4.8
	sbrodie_sedwards_16Mar2000:4.8
	Kernel-5_21:4.8
	Kernel-5_20:4.8
	Kernel-5_19:4.8
	Kernel-5_18:4.8
	Kernel-5_17:4.8
	Kernel-5_16:4.8
	Kernel-5_15:4.8
	Kernel-5_14:4.8
	Kernel-5_13:4.8
	Kernel-5_12:4.8
	Kernel-5_11:4.8
	Kernel-5_10:4.8
	Kernel-5_09:4.8
	Kernel-5_08:4.8
	Kernel-5_07:4.8
	Kernel-5_06:4.8
	Kernel-5_05:4.8
	Kernel-5_04:4.8
	Kernel-5_03:4.8
	Kernel-5_02:4.8
	Kernel-5_01:4.8
	Kernel-5_00:4.8
	Kernel-4_99:4.8
	Kernel-4_98:4.8
	Kernel-4_97:4.8
	Kernel-4_96:4.8
	Kernel-4_95:4.8
	Kernel-4_94:4.8
	Kernel-4_93:4.8
	Kernel-4_92:4.8
	Kernel-4_91:4.8
	Kernel-4_90:4.8
	dcotton_autobuild_BaseSW:4.12
	Kernel-4_89:4.8
	Kernel-4_88:4.8
	Kernel-4_87:4.8
	Kernel-4_86:4.8
	Kernel-4_85:4.8
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.3.2.5.2.1
	Kernel-4_84:4.8
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.3.2.5.2.1
	Ursula_RiscPC_bp:4.3.2.5
	Kernel-4_83:4.8
	Kernel-4_82:4.7
	Kernel-4_81:4.7
	Kernel-4_80:4.6
	Kernel-4_79:4.6
	Kernel-4_78:4.6
	Kernel-4_77:4.6
	Kernel-4_76:4.6
	Kernel-4_75:4.6
	Kernel-4_74:4.6
	Kernel-4_73:4.6
	Kernel-4_72:4.6
	Kernel-4_71:4.6
	Kernel-4_70:4.6
	Kernel-4_69:4.6
	Kernel-4_68:4.6
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.5.2.1
	Ursula_RiscPC:4.3.2.5.0.2
	Kernel-4_63-1_1_2_5:4.1.7.3
	Kernel-4_63-1_1_2_4:4.1.7.3
	Kernel-4_67:4.6
	Kernel-4_66:4.6
	Kernel-4_63-1_1_2_3:4.1.7.3
	Kernel-4_65:4.6
	Ursula_merge:4.3.2.1
	Kernel-4_64:4.5
	mstphens_Kernel-3_81:4.3.2.6
	Kernel-4_63-1_1_2_2:4.1.7.3
	nicke_Kernel_4_62:4.1.7.2
	rthornb_UrsulaBuild-19Aug1998:4.3.2.5
	UrsulaBuild_FinalSoftload:4.3.2.5
	rthornb_UrsulaBuild-12Aug1998:4.3.2.5
	aglover_UrsulaBuild-05Aug1998:4.3.2.5
	rthornb_UrsulaBuild-29Jul1998:4.3.2.5
	rthornb_UrsulaBuild-22Jul1998:4.3.2.5
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.3.2.5
	rthornb_UrsulaBuild-07Jul1998:4.3.2.5
	rthornb_UrsulaBuild-17Jun1998:4.3.2.5
	rthornb_UrsulaBuild-03Jun1998:4.3.2.5
	rthornb_UrsulaBuild-27May1998:4.3.2.5
	mstphens_Kernel-3_80:4.3.2.5
	rthornb_UrsulaBuild-21May1998:4.3.2.5
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.3.2.5
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.3
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.24
date	2018.04.24.18.43.47;	author jlee;	state Exp;
branches;
next	4.23;
commitid	KGf9l84CSTjL2JzA;

4.23
date	2017.02.09.20.43.12;	author rsprowson;	state Exp;
branches
	4.23.2.1;
next	4.22;
commitid	g0y4kUhbpTcDOjFz;

4.22
date	2016.12.13.19.41.12;	author jlee;	state Exp;
branches;
next	4.21;
commitid	XeVhUEC50BLVkRxz;

4.21
date	2016.12.13.16.42.50;	author jlee;	state Exp;
branches;
next	4.20;
commitid	aGog9bB8f4QKlQxz;

4.20
date	2016.12.04.13.25.18;	author jlee;	state Exp;
branches;
next	4.19;
commitid	QOhJ3VPbDNVVxFwz;

4.19
date	2016.10.26.20.00.03;	author jlee;	state Exp;
branches;
next	4.18;
commitid	IYqAWNN21Gg5ZGrz;

4.18
date	2016.08.02.22.10.43;	author jlee;	state Exp;
branches;
next	4.17;
commitid	CnQYuUGzojQfrMgz;

4.17
date	2016.06.30.20.59.46;	author jlee;	state Exp;
branches;
next	4.16;
commitid	skOEjp3ipLHx6xcz;

4.16
date	2016.06.30.20.42.05;	author jlee;	state Exp;
branches;
next	4.15;
commitid	bDF3DCxdmyMD0xcz;

4.15
date	2016.06.30.20.28.55;	author jlee;	state Exp;
branches;
next	4.14;
commitid	lMnWzoE9eJz3Wwcz;

4.14
date	2016.06.30.20.08.08;	author jlee;	state Exp;
branches;
next	4.13;
commitid	IWoXxARWeuLDOwcz;

4.13
date	2002.02.18.16.42.26;	author bavison;	state Exp;
branches;
next	4.12;

4.12
date	2000.04.20.14.57.28;	author kbracey;	state Exp;
branches
	4.12.2.1;
next	4.11;

4.11
date	2000.04.17.14.22.52;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	2000.04.13.10.37.27;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	2000.04.04.14.27.30;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	99.08.17.11.16.21;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	99.08.03.09.59.03;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	98.10.01.07.42.42;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	98.09.30.08.42.33;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.07.21.15.56.55;	author nturton;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.05.51.51;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.14.07.05;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.19;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.23.2.1
date	2018.05.14.19.33.43;	author jlee;	state Exp;
branches;
next	;
commitid	wrVtYH84nAz1GiCA;

4.12.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.12.2.2;

4.12.2.2
date	2000.10.02.08.52.19;	author kbracey;	state Exp;
branches;
next	4.12.2.3;

4.12.2.3
date	2000.10.03.12.05.59;	author mstephen;	state Exp;
branches;
next	4.12.2.4;

4.12.2.4
date	2000.10.05.13.54.49;	author kbracey;	state Exp;
branches;
next	4.12.2.5;

4.12.2.5
date	2000.10.05.14.33.00;	author mstephen;	state Exp;
branches;
next	4.12.2.6;

4.12.2.6
date	2000.10.06.09.08.11;	author kbracey;	state Exp;
branches;
next	4.12.2.7;

4.12.2.7
date	2000.10.09.15.59.15;	author kbracey;	state Exp;
branches;
next	4.12.2.8;

4.12.2.8
date	2000.10.20.14.58.21;	author kbracey;	state Exp;
branches;
next	4.12.2.9;

4.12.2.9
date	2000.10.20.15.48.04;	author mstephen;	state Exp;
branches;
next	4.12.2.10;

4.12.2.10
date	2000.11.10.15.51.35;	author kbracey;	state Exp;
branches;
next	4.12.2.11;

4.12.2.11
date	2001.01.09.17.17.32;	author mstephen;	state Exp;
branches;
next	4.12.2.12;

4.12.2.12
date	2001.03.07.15.12.57;	author kbracey;	state Exp;
branches;
next	4.12.2.13;

4.12.2.13
date	2001.05.17.10.51.11;	author kbracey;	state Exp;
branches;
next	4.12.2.14;

4.12.2.14
date	2001.05.22.15.27.54;	author mstephen;	state Exp;
branches;
next	4.12.2.15;

4.12.2.15
date	2001.06.11.11.33.32;	author kbracey;	state Exp;
branches;
next	4.12.2.16;

4.12.2.16
date	2001.06.18.14.49.44;	author mstephen;	state Exp;
branches;
next	4.12.2.17;

4.12.2.17
date	2002.10.07.17.29.41;	author kbracey;	state Exp;
branches;
next	4.12.2.18;

4.12.2.18
date	2002.10.16.17.23.13;	author bavison;	state Exp;
branches;
next	4.12.2.19;

4.12.2.19
date	2002.11.30.00.31.08;	author bavison;	state Exp;
branches;
next	4.12.2.20;

4.12.2.20
date	2003.01.27.15.25.34;	author kbracey;	state Exp;
branches;
next	4.12.2.21;

4.12.2.21
date	2003.02.21.20.21.54;	author bavison;	state Exp;
branches;
next	4.12.2.22;

4.12.2.22
date	2004.05.06.16.02.02;	author kbracey;	state Exp;
branches
	4.12.2.22.2.1;
next	4.12.2.23;

4.12.2.23
date	2009.04.15.18.28.31;	author bavison;	state Exp;
branches;
next	4.12.2.24;

4.12.2.24
date	2011.08.07.00.05.00;	author jlee;	state Exp;
branches;
next	4.12.2.25;
commitid	1LhiU7JeG3NwFvuv;

4.12.2.25
date	2011.11.26.21.11.15;	author jlee;	state Exp;
branches;
next	4.12.2.26;
commitid	cI3W0zbtALQG6TIv;

4.12.2.26
date	2011.11.27.12.34.45;	author rsprowson;	state Exp;
branches;
next	4.12.2.27;
commitid	QtdLV6zjuPNxdYIv;

4.12.2.27
date	2011.11.27.12.54.07;	author rsprowson;	state Exp;
branches;
next	4.12.2.28;
commitid	qUSTS070aqq3kYIv;

4.12.2.28
date	2011.11.27.19.18.15;	author rsprowson;	state Exp;
branches;
next	4.12.2.29;
commitid	iuIXfUOByAFYr0Jv;

4.12.2.29
date	2012.02.25.16.19.37;	author jlee;	state Exp;
branches
	4.12.2.29.2.1;
next	4.12.2.30;
commitid	ad3WnPntkzrizyUv;

4.12.2.30
date	2012.05.15.22.26.07;	author jlee;	state Exp;
branches;
next	4.12.2.31;
commitid	SLOA6hsE9XqE1S4w;

4.12.2.31
date	2012.05.21.19.31.39;	author rsprowson;	state Exp;
branches;
next	4.12.2.32;
commitid	oEtPURiKNEPMRC5w;

4.12.2.32
date	2012.06.18.20.17.55;	author rsprowson;	state Exp;
branches;
next	4.12.2.33;
commitid	KeuVX14bDnORde9w;

4.12.2.33
date	2012.07.01.21.26.41;	author rsprowson;	state Exp;
branches;
next	4.12.2.34;
commitid	K3GB4gteEYUubUaw;

4.12.2.34
date	2012.09.18.22.01.15;	author jlee;	state Exp;
branches;
next	4.12.2.35;
commitid	eFa3Y1QY0MjZP3lw;

4.12.2.35
date	2013.01.10.21.19.08;	author rsprowson;	state Exp;
branches;
next	4.12.2.36;
commitid	F6D8WGw2f7PkWHzw;

4.12.2.36
date	2014.01.19.12.32.47;	author jlee;	state Exp;
branches;
next	4.12.2.37;
commitid	ri8po2P2I8Js0Jlx;

4.12.2.37
date	2014.04.04.22.19.19;	author jballance;	state Exp;
branches;
next	4.12.2.38;
commitid	bAG8kI0jJo5cQpvx;

4.12.2.38
date	2014.04.20.17.00.21;	author jlee;	state Exp;
branches;
next	4.12.2.39;
commitid	6eesW4yWEAvSyrxx;

4.12.2.39
date	2015.07.17.00.28.26;	author jlee;	state Exp;
branches;
next	4.12.2.40;
commitid	s5cS0yKIca1Nvzty;

4.12.2.40
date	2015.08.05.21.51.31;	author jlee;	state Exp;
branches;
next	4.12.2.41;
commitid	SpZpzVH47zb408wy;

4.12.2.41
date	2015.08.14.22.02.31;	author jlee;	state Exp;
branches;
next	4.12.2.42;
commitid	6gyfvmM0cNZULhxy;

4.12.2.42
date	2016.04.05.19.36.35;	author jlee;	state Exp;
branches;
next	4.12.2.43;
commitid	8RLqvkae1X7wpt1z;

4.12.2.43
date	2016.04.06.21.02.08;	author jlee;	state Exp;
branches;
next	4.12.2.44;
commitid	v0nIS0nphnMTQB1z;

4.12.2.44
date	2016.04.14.21.22.14;	author jlee;	state Exp;
branches;
next	4.12.2.45;
commitid	hHFd2MvvwEATHD2z;

4.12.2.45
date	2016.04.14.21.26.05;	author jlee;	state Exp;
branches;
next	4.12.2.46;
commitid	dLnYrKw30yHdJD2z;

4.12.2.46
date	2016.05.19.21.03.49;	author jlee;	state Exp;
branches;
next	4.12.2.47;
commitid	7f3vfXP8BWCNt87z;

4.12.2.47
date	2016.06.15.19.24.52;	author jlee;	state Exp;
branches;
next	;
commitid	QoMRsy6vZNP34Baz;

4.12.2.22.2.1
date	2011.05.22.19.45.03;	author jlee;	state Exp;
branches;
next	4.12.2.22.2.2;
commitid	FcIrTQvrz0zQFIkv;

4.12.2.22.2.2
date	2011.08.01.19.54.10;	author jlee;	state Exp;
branches;
next	4.12.2.22.2.3;
commitid	m0TvirYe9M1urQtv;

4.12.2.22.2.3
date	2011.08.06.23.56.10;	author jlee;	state Exp;
branches;
next	4.12.2.22.2.4;
commitid	FftZtV6AJ7qwCvuv;

4.12.2.22.2.4
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches
	4.12.2.22.2.4.2.1;
next	;
commitid	D7rzILnwRRSXoLuv;

4.12.2.22.2.4.2.1
date	2012.05.10.03.09.52;	author bavison;	state Exp;
branches;
next	;
commitid	HTVG5Da5tRqSM74w;

4.12.2.29.2.1
date	2012.05.10.03.28.05;	author bavison;	state Exp;
branches;
next	4.12.2.29.2.2;
commitid	kuJoT3AcfB16T74w;

4.12.2.29.2.2
date	2012.05.18.10.27.03;	author bavison;	state Exp;
branches;
next	4.12.2.29.2.3;
commitid	OrHPEQzWGWdZWb5w;

4.12.2.29.2.3
date	2012.05.20.21.21.35;	author jballance;	state Exp;
branches;
next	4.12.2.29.2.4;
commitid	neZVFdyw3wNwvv5w;

4.12.2.29.2.4
date	2012.05.21.00.19.23;	author jballance;	state Exp;
branches;
next	4.12.2.29.2.5;
commitid	gUZFPbvrT1Xxuw5w;

4.12.2.29.2.5
date	2012.07.20.00.51.55;	author bavison;	state Exp;
branches;
next	4.12.2.29.2.6;
commitid	ELcSZZYPVgQ6Kedw;

4.12.2.29.2.6
date	2012.09.02.19.56.52;	author jlee;	state Exp;
branches;
next	4.12.2.29.2.7;
commitid	q3Bny0G3EqBdFZiw;

4.12.2.29.2.7
date	2012.09.07.23.05.52;	author jlee;	state Exp;
branches;
next	4.12.2.29.2.8;
commitid	Ik0jMROsIiH5yEjw;

4.12.2.29.2.8
date	2012.09.18.15.50.02;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.3.2.1
date	97.05.23.13.06.51;	author kbracey;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	97.09.09.13.33.13;	author mstphens;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	97.10.21.15.31.16;	author mstphens;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	97.12.08.14.34.28;	author mstphens;	state Exp;
branches;
next	4.3.2.5;

4.3.2.5
date	98.03.26.11.25.47;	author mstphens;	state Exp;
branches
	4.3.2.5.2.1;
next	4.3.2.6;

4.3.2.6
date	98.09.24.13.17.12;	author mstphens;	state Exp;
branches;
next	;

4.3.2.5.2.1
date	98.11.23.14.59.10;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.19;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.23;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.08.09.26;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.16.46.04;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.07;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.36;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	98.07.21.17.57.40;	author nturton;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	98.09.24.12.36.43;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.24
log
@Disable error block validity checks
Detail:
  The error block checks introduced in Kernel-5_35-4_79_2_313 are generating a few too many false positives and edge cases, so take the safe option of just disabling them rather than trying to tweak the rules further. Error pointers will still be checked, but the content of the error blocks will not.
  hdr/Options - Add CheckErrorBlocks switch so we can easily turn the code back on again in the future if necessary
  s/Kernel - Switch out all the code relating to error number checks, except for the dummy load of the first word of the error block, since that's still useful as a pointer validity check
  hdr/KernelWS - Revise SWIDespatch_Size definition so it's easier for it to cope with the various factors which may affect the despatcher size
Admin:
  Tested on PandaBoard
  Relevant discussion:
  https://www.riscosopen.org/forum/forums/11/topics/11133


Version 6.04. Tagged as 'Kernel-6_04'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => Kernel : SWI Despatch, simple SWIs
        SUBT    Arthur Variables
        OPT     4

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; handy macros:
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        MACRO
        DebugReg $reg, $str
    [ DebugHALTX
     Push "$reg"
     [ "$str" <> ""      
        BL      DebugHALPrint
        =       "$str", 0
        ALIGN
     ]
     bl  DebugHALPrintReg
    ]
        MEND

        MACRO
        DebugTX $str
    [ DebugHALTX
        BL      DebugHALPrint
        =       "$str", 13,10,00
        ALIGN
    ]
        MEND

        MACRO
$l      CheckSpaceOnStack   $space, $faildest, $tmp
$l      MOV     $tmp, sp, LSR #15       ; Stack base on 32K boundary
        SUB     $tmp, sp, $tmp, LSL #15 ; Amount of stack left
        CMP     $tmp, #$space           ; Must have at least this much left
        BMI     $faildest
        MEND

        MACRO
        assert  $condition
 [ :LNOT: ($condition)
 ! 1,"Assert failed: $condition"
 ]
        MEND

; **************************************
; ***  BYTEWS - Point to OsbyteVars  ***
; **************************************
        MACRO
$label  BYTEWS  $reg
$label  LDR     $reg,=ZeroPage+OsbyteVars
        MEND

; ***************************************
; ***  LDROSB - Load Osbyte variable  ***
; ***************************************
        MACRO
$label  LDROSB  $reg, $var, $cond
$label  LDR$cond $reg, =ZeroPage
        LDR$cond.B $reg, [$reg, #OsbyteVars+$var-OSBYTEFirstVar]
        MEND

; ****************************************
; ***  STROSB - Store Osbyte variable  ***
; ****************************************
        MACRO
$label  STROSB  $reg, $var, $temp, $cond
$label  LDR$cond $temp, =ZeroPage
        STR$cond.B $reg, [$temp, #OsbyteVars+$var-OSBYTEFirstVar]
        MEND

; ****************************************************
; ***  VDWS - Point to our new VduDriverWorkSpace  ***
; ****************************************************
        MACRO
$label  VDWS    $reg
$label  LDR     $reg, =ZeroPage+VduDriverWorkSpace
        MEND

; *******************************************************************
; ***  MyCLREX - Manually clear exclusive monitor                 ***
; ***  Consult the ARM ARM for details of when this is required!  ***
; *******************************************************************
        MACRO
        MyCLREX $temp1, $temp2
      [ NoARMv6
        ASSERT  :LNOT: SupportARMv6
        ; No action required
      ELIF NoARMK
        ; ARMv6, need dummy STREX
        ; Use the word below SP
        SUB     $temp1, r13, #4
        STREX   $temp2, $temp1, [$temp1]
      |
        ; ARMv6K+, have CLREX
        CLREX
      ]
        MEND

; *****************************************************
; ***  Call Get4KPTE/Get64KPTE/Get1MPTE functions,  ***
; ***  with arbitrary in/out regs                   ***
; *****************************************************
        MACRO
        GetPTE  $out, $size, $addr, $flags
        Push    "r0-r3,lr"
      [ $flags <> r1
        MOV     r1, $flags
      ]
      [ $addr <> r0
        ASSERT  $addr <> r1
        MOV     r0, $addr
      ]
        LDR     r3, =ZeroPage
        LDR     r2, [r3, #MMU_PPLTrans]
        LDR     r3, [r3, #MMU_PCBTrans]
        BL      Get$size.PTE
      [ :INDEX:$out < 4
        STR     r0, [sp, #:INDEX:$out * 4]
      |
        MOV     $out, r0
      ]
        Pull    "r0-r3,lr"
        MEND

; *******************************************************************
; ***  Convert RWX flags to OS_Memory 24 flags                    ***
; ***  N.B. this is using the inverted executability sense (i.e.  ***
; ***  bit set if executable) - see notes in CheckMemoryAccess    ***
; *******************************************************************
        MACRO
        GenPPLAccess $flags
        LCLA    access
access  SETA    0
      [ ($flags :AND: 1) <> 0
access  SETA    access :OR: CMA_Partially_UserXN
      ]                
      [ ($flags :AND: 2) <> 0
access  SETA    access :OR: CMA_Partially_UserW
      ]                
      [ ($flags :AND: 4) <> 0
access  SETA    access :OR: CMA_Partially_UserR
      ]                
      [ ($flags :AND: 8) <> 0
access  SETA    access :OR: CMA_Partially_PrivXN
      ]                
      [ ($flags :AND: 16) <> 0
access  SETA    access :OR: CMA_Partially_PrivW
      ]                
      [ ($flags :AND: 32) <> 0
access  SETA    access :OR: CMA_Partially_PrivR
      ]
        DCD     access
        MEND

; **********************************************************
; ***  PageTableSync - Sync the CPU after overwriting a  ***
; ***  faulting page table entry. Corrupts r0, lr.       ***
; **********************************************************
        MACRO
        PageTableSync$cond
    [ SyncPageTables
      [ MEMM_Type = "VMSAv6"
        ; DSB + ISB required to ensure effect of page table write is fully
        ; visible (after overwriting a faulting entry)
        myDSB   $cond,r0
        myISB   $cond,r0,,y
      |
        ; For < ARMv6 draining the write buffer should be sufficient
        ; (write-through or bufferable page tables)
        LDR$cond r0, =ZeroPage
        ARMop    DSB_ReadWrite,$cond,,r0 ; N.B. assume that this op won't corrupt NZCV
      ]
    ]
        MEND        

; one that builds a module command table entry:
; set Module_BaseAddr to module base before use.

                GBLA    Module_BaseAddr
Module_BaseAddr SETA    0

;

a1      RN      0
a2      RN      1
a3      RN      2
a4      RN      3
v1      RN      4
v2      RN      5
v3      RN      6
v4      RN      7
v5      RN      8
v6      RN      9
sb      RN      9
v7      RN      10
v8      RN      11

; Set sb up ready for CallHAL.
        MACRO
        AddressHAL $zero
 [ "$zero" <> ""
        LDR     sb, [$zero, #HAL_Workspace]
 |
        LDR     sb, =ZeroPage
        LDR     sb, [sb, #HAL_Workspace]
 ]
        MEND

; Calls the HAL. $rout is the routine. sb must have been set up by AddressHAL
        MACRO
        CallHAL $rout, $cond
        MOV$cond lr, pc
        LDR$cond pc, [sb, #-(EntryNo_$rout+1) * 4]
        MEND

; Checks whether a HAL routine exists. If it does, $ptr points to it, and Z is
; clear. lr corrupted.
        MACRO
        CheckHAL $rout, $ptr
      [ "$ptr"=""
        LDR     a1, [sb, #-(EntryNo_$rout+1) * 4]
        ADRL    lr, NullHALEntry
        TEQ     a1, lr
      |
        LDR     $ptr, [sb, #-(EntryNo_$rout+1) * 4]
        ADRL    lr, NullHALEntry
        TEQ     $ptr, lr
      ]
        MEND


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Various constants
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PageSize          * (4*1024)       ;MMU page size (normal pages)
Log2PageSize      * 12             ;for shifts

MinAplWork * 40*1024         ; minimum size of AplWork

; Fixed addresses

MEMCADR  * &03600000
        GBLL    ROMatTop
ROM      * &FC000000
ROMatTop SETL {TRUE}

; Manifests

CR * 13
LF * 10
space * " "

; Callback byte bits:
CBack_OldStyle  * 1
CBack_Postpone  * 2
CBack_VectorReq * 4

; AMBControl definitions - required by GetAppSpaceDANode macro

        GET     s.AMBControl.Options
        GET     s.AMBControl.Workspace

        MACRO
        GetAppSpaceDANode $out, $zero
      [ "$zero" <> ""
        LDR     $out, [$zero, #AMBControl_ws]
      |
        LDR     $out, =ZeroPage+AMBControl_ws
        LDR     $out, [$out]
      ]
        TEQ     $out, #0
        LDRNE   $out, [$out, #:INDEX:AMBMappedInNode]
        TEQNE   $out, #0
        ADDNE   $out, $out, #AMBNode_DANode
      [ "$zero" <> "" :LAND: "$zero" <> "$out"
        ADDEQ   $out, $zero, #AppSpaceDANode
      |
        LDREQ   $out, =ZeroPage+AppSpaceDANode
      ]
        MEND

        SUBT    Arthur Code
        OPT     4

        ORG     ROM + OSROM_HALSize

        AREA    |!!!!OSBase|,CODE,READONLY

        ENTRY                   ; Not really, but we need it to link
KernelBase

; *****************************************************************************
;
;  Now ready to start the code: off we go!
;
; *****************************************************************************

; RISC OS image header
RISCOS_Header
        =       "OSIm"
        DCD     OSHdrFlag_SupportsCompression
        DCD     OSROM_ImageSize*1024 - OSROM_HALSize
        DCD     RISCOS_Entries - RISCOS_Header
        DCD     (RISCOS_Entries_End - RISCOS_Entries) / 4
        DCD     OSROM_ImageSize*1024 - OSROM_HALSize
        DCD     0
        DCD     EndOfKernel - RISCOS_Header
        ASSERT  (. - RISCOS_Header) = OSHdr_size 

RISCOS_Entries
        DCD     RISCOS_InitARM   - RISCOS_Entries
        DCD     RISCOS_AddRAM    - RISCOS_Entries
        DCD     RISCOS_Start     - RISCOS_Entries
        DCD     RISCOS_MapInIO   - RISCOS_Entries
        DCD     RISCOS_AddDevice - RISCOS_Entries
        DCD     RISCOS_LogToPhys - RISCOS_Entries
        DCD     RISCOS_IICOpV    - RISCOS_Entries
RISCOS_Entries_End

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; This bit (up to EndFiq) is copied to location 0.  Processor vectors are
; indirected through 0 page locations so that they can be claimed using
; OS_ClaimProcessorVector.  IRQs are initially handled specially so that the
; keyboard can be handled during reset but the load is replaced with the
; standard one later on.

MOSROMVecs
        LDR     pc, MOSROMVecs+ProcVec_Branch0
        LDR     pc, MOSROMVecs+ProcVec_UndInst
        LDR     pc, MOSROMVecs+ProcVec_SWI
        LDR     pc, MOSROMVecs+ProcVec_PrefAb
        LDR     pc, MOSROMVecs+ProcVec_DataAb
        LDR     pc, MOSROMVecs+ProcVec_AddrEx
        LDR     pc, MOSROMVecs+InitIRQHandler
EndMOSROMVecs

        ASSERT  InitIRQHandler >= EndMOSROMVecs - MOSROMVecs

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; This is the table of default processor vectors which is copied to 0 page.

DefaultProcVecs
        &       Branch0_NoTrampoline
        &       UndPreVeneer
        &       SVC
        &       PAbPreVeneer
        &       DAbPreVeneer
        &       AdXPreVeneer
        &       Initial_IRQ_Code

        ASSERT  (.-DefaultProcVecs) = ProcVec_End-ProcVec_Start

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; These are preveneers which must be copied to 0 page locations so that the
; relevant handler can be branched to.  This is mainly for non-ARM600 platforms
; although the address exception preveneer (which should not actually be required
; on ARM600) is always copied.

DefaultPreVeneers
UndPreVeneer    *       ZeroPage+ProcVecPreVeneers+(.-DefaultPreVeneers)
        LDR     PC, DefaultPreVeneers-ProcVecPreVeneers+UndHan
   [ AMB_LazyMapIn
        DCD     0
   |
PAbPreVeneer    *       ZeroPage+ProcVecPreVeneers+(.-DefaultPreVeneers)
        LDR     PC, DefaultPreVeneers-ProcVecPreVeneers+PAbHan
   ]
        DCD     0
AdXPreVeneer    *       ZeroPage+ProcVecPreVeneers+(.-DefaultPreVeneers)
        LDR     PC, DefaultPreVeneers-ProcVecPreVeneers+AdXHan

        ASSERT  (.-DefaultPreVeneers) = ProcVecPreVeneersSize

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; This is the trampoline in the system heap used to handle branch through 0.

Branch0_Trampoline
        STR     r1, Branch0_Trampoline + Branch0_Trampoline_SavedR1
        STR     lr, Branch0_Trampoline + Branch0_Trampoline_SavedR14
        ADD     lr, pc, #4
        LDR     pc, .+4
        &       Branch0_FromTrampoline
Branch0_Trampoline_Init     * .-Branch0_Trampoline
Branch0_Trampoline_SavedR1  * .-Branch0_Trampoline
Branch0_Trampoline_SavedR14 * .-Branch0_Trampoline+4
Branch0_Trampoline_Size     * .-Branch0_Trampoline+8


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Now some initialised workspace/vectors that go at &100

; All the stuff from here to after the DirtyBranch instruction is read
; consecutively out of ROM, so don't put anything in between without changing
; the code


StartData
        ASSERT IRQ1V = &100
        & DefaultIRQ1V

        ASSERT ESC_Status = IRQ1V+4
        & &00FF0000       ; IOCControl set to FF on reset

        ASSERT IRQsema = ESC_Status+4
        & 0
EndData

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI return handler: checks callback
; no branches or interlocks in the common case: V clear, no callback

SVCDespatcher ROUT

SWIRelocation * SVCDespatcher-SWIDespatch

SLVK_SetV * {PC}-SWIRelocation

        ORR     lr, lr, #V_bit

SLVK_TestV * {PC}-SWIRelocation
 ! 0,"SLVK_TestV at ":CC:(:STR:SLVK_TestV)

        ORRVS   lr, lr, #V_bit

SLVK * {PC}-SWIRelocation
 ! 0,"SLVK       at ":CC:(:STR:SLVK)
Local_SLVK

        LDR     r12, [sp], #4
      [ ZeroPage = 0
        MOV     r10, #0
      |
        LDR     r10, SWIRelocationZeroPage
      ]
        MSR     CPSR_c, #I32_bit + SVC32_mode           ; IRQs off makes CallBackFlag atomic; 32bit so ready for SPSR use
        LDRB    r11, [r10, #CallBack_Flag]

        TST     lr, #V_bit
        BNE     %FT50

SWIReturnWithCallBackFlag * {PC}-SWIRelocation
 ! 0,"SWIReturnWithCallBackFlag at ":CC:(:STR:SWIReturnWithCallBackFlag)

40      TEQ     r11, #0

        MSREQ   SPSR_cxsf, lr
        LDREQ   lr, [sp], #4
        Pull    "r10-r12", EQ
        MOVEQS  pc, lr

        B       callback_checking + SWIRelocation

 ! 0,"VSetReturn at ":CC:(:STR:({PC}-SWIRelocation))
50
        ; Some programs abuse XOS_GenerateError by using it purely as a method
        ; to trigger callbacks, or to convert null terminated strings to BASIC
        ; strings. This means the R0 value might be complete garbage, and if we
        ; were to try checking it then bad things would happen.
        ; Luckily XOS_GenerateError is essentially a no-op as far as errors are
        ; concerned, so we can avoid crashing here (or corrupting the caller's
        ; R0 value) by simply ignoring the call.
        EOR     r10, r12, #Auto_Error_SWI_bit
        TEQ     r10, #OS_GenerateError
        BEQ     callback_checking + SWIRelocation       ; it's an X SWI, so jump straight to callback checks
        ; Attempt to detect bad error pointers - both to try and avoid crashing
        ; and to make bad pointers easier to debug
        CMP     r0, #&4000
        BLO     BadErrPtr + SWIRelocation
        TST     r0, #3
        LDREQ   r10, [r0]                               ; If we crash here, R12 will be the SWI number that returned the bad pointer (better than crashing later with no clue what SWI caused the problem)
      [ CheckErrorBlocks
        TSTEQ   r10, #&7f :SHL: 24                      ; Check reserved bits in error number
        BNE     BadErrPtr2 + SWIRelocation
      |
        BNE     BadErrPtr + SWIRelocation
      ]
BadErrPtrReturn * {PC}-SWIRelocation
        TST     r12, #Auto_Error_SWI_bit
        BNE     callback_checking + SWIRelocation       ; we need to do this for X errors even if the callback flags
                                                        ; are all clear, so that the postpone flag can be set

        B       VSet_GenerateError + SWIRelocation

      [ ZeroPage <> 0
SWIRelocationZeroPage
        DCD     ZeroPage
      ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; The SWI Despatch routine

SVC * {PC}-SWIRelocation

        Push    "r10-r12"
 [ SupportARMT
        MRS     r12, SPSR               ; r12 = saved PSR
        TST     r12, #T32_bit           ; depending on processor state (ARM/Thumb)
        LDREQ   r11, [r14, #-4]         ; extract SWI number to r11
        LDRNEB  r11, [r14, #-2]         ; (ordering to prevent interlocks)
        BICEQ   r11, r11, #&FF000000
 |
        LDR     r11, [r14, #-4]         ; extract SWI number to r11
        MRS     r12, SPSR               ; r12 = saved PSR
        BIC     r11, r11, #&FF000000    ; (ordering to prevent interlocks)
 ]

        Push    "r11,r14"               ; push SWI number and return address

        AND     r10, r12, #I32_bit+F32_bit
        ORR     r10, r10, #SVC2632      ; set IFTMMMMM = IF0x0011
        MSR     CPSR_c, r10             ; restore caller's IRQ state

        BIC     r14, r12, #V_bit        ; clear V (some SWIs need original PSR in r12)

SVC_CallASWI * {PC}-SWIRelocation       ; CallASWI,CallASWIR12 re-entry point

        BIC     r11, r11, #Auto_Error_SWI_bit

        CMP     r11, #OS_WriteI
        LDRLO   pc, [pc, r11, LSL #2]

        B       NotMainMOSSwi + SWIRelocation

 ASSERT {PC}-SVCDespatcher = SWIDespatch_Size

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; The SWI table

JTABLE  & SWIWriteC
        & SWIWriteS
        & SWIWrite0
        & SWINewLine

; next section is one where VectorNumber = SWINumber
        & VecSwiDespatch        ; readc
        & VecSwiDespatch        ; cli
        & NoIrqVecSwiDespatch   ; byte
        & NoIrqVecSwiDespatch   ; word
        & VecSwiDespatch        ; file
        & VecSwiDespatch        ; args
        & BGetSWI               ; bget
        & BPutSWI               ; bput
        & VecSwiDespatch        ; gbpb
        & VecSwiDespatch        ; find
        & ReadLineSWI

        & SCTRL
        & SWI_GetEnv_Code
        & SEXIT
        & SSTENV
        & SINTON
        & SINTOFF
        & SCALLB
        & SENTERSWI
        & SBRKPT
        & SBRKCT
        & SUNUSED
        & SSETMEMC
        & SSETCALL
        & VecMouse
        & HeapEntry
        & ModuleHandler
        & ClaimVector_SWICode
        & ReleaseVector_SWICode
        & ReadUnsigned_Routine
        & GenEvent
        & ReadVarValue
        & SetVarValue
        & GSINIT
        & GSREAD
        & GSTRANS
        & BinaryToDecimal_Code
        & FSControlSWI
        & ChangeDynamicSWI
        & GenErrorSWI
        & ReadEscapeSWI
        & ReadExpression
        & SwiSpriteOp
        & SWIReadPalette
        & Issue_Service_SWI
        & SWIReadVduVariables
        & SwiReadPoint
        & DoAnUpCall
        & CallAVector_SWI
        & SWIReadModeVariable
        & SWIRemoveCursors
        & SWIRestoreCursors
        & SWINumberToString_Code
        & SWINumberFromString_Code
        & ValidateAddress_Code
        & CallAfter_Code
        & CallEvery_Code
        & RemoveTickerEvent_Code
        & InstallKeyHandler
        & SWICheckModeValid
        & ChangeEnvironment
        & SWIClaimScreenMemory
        & ReadMetroGnome
        & XOS_SubstituteArgs_code
        & XOS_PrettyPrint_code
        & SWIPlot
        & SWIWriteN
        & Add_ToVector_SWICode
        & WriteEnv_SWICode
        & RdArgs_SWICode
        & ReadRAMFSLimits_Code
        & DeviceVector_Claim
        & DeviceVector_Release
        & Application_Delink
        & Application_Relink
        & HeapSortRoutine
        & TerminateAndSodOff
        & ReadMemMapInfo_Code
        & ReadMemMapEntries_Code
        & SetMemMapEntries_Code
        & AddCallBack_Code
        & ReadDefaultHandler
        & SWISetECFOrigin
        & SerialOp
        & ReadSysInfo_Code
        & Confirm_Code
        & SWIChangedBox
        & CRC_Code
        & ReadDynamicArea
        & SWIPrintChar
        & ChangeRedirection
        & RemoveCallBack
        & FindMemMapEntries_Code
        & SWISetColour
        & NoSuchSWI                     ; Added these to get round OS_ClaimSWI and
        & NoSuchSWI                     ; OS_ReleaseSWI (should not have been allocated here).
        & PointerSWI
        & ScreenModeSWI
        & DynamicAreaSWI
        & NoSuchSWI                     ; OS_AbortTrap
        & MemorySWI
        & ClaimProcVecSWI
        & PerformReset
        & MMUControlSWI
        & ResyncTimeSWI
        & PlatFeatSWI
        & SyncCodeAreasSWI
        & CallASWI
        & AMBControlSWI
        & CallASWIR12
; The following SWIs are not available in this kernel.
        & NoSuchSWI     ; SpecialControl
        & NoSuchSWI     ; EnterUSR32SWI
        & NoSuchSWI     ; EnterUSR26SWI
        & NoSuchSWI     ; VIDCDividerSWI
; End of unavailable SWIs.
        & NVMemorySWI
        & NoSuchSWI
        & NoSuchSWI
        & NoSuchSWI
        & HardwareSWI
        & IICOpSWI
        & SLEAVESWI
        & ReadLine32SWI
        & XOS_SubstituteArgs32_code
        & HeapSortRoutine32


 ASSERT (.-JTABLE)/4 = NCORESWIS
 ASSERT NCORESWIS < OS_ConvertStandardDateAndTime

; SWIs for time/date conversion are poked in specially

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; The fudge branch to exit a dirty SWI handler

DirtyBranch
        B       SLVK +DirtyBranch-BranchToSWIExit

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;SWI number passed in r10
CallASWI ROUT
        LDR     r11, [sp, #8]        ;pick-up target SWI code (r10 pushed by dispatcher)
        BIC     r11, r11, #&FF000000 ;just in case
        STR     r11, [sp, #0]        ;CallASWI now incognito as target SWI
        B       SVC_CallASWI         ;re-dispatch

;SWI number passed in r12 (better for C veneers)
CallASWIR12 ROUT
        LDR     r11, [sp, #16]       ;pick-up target SWI code (r12 pushed by dispatcher)
        BIC     r11, r11, #&FF000000 ;just in case
        STR     r11, [sp, #0]        ;CallASWIR12 now incognito as target SWI
        B       SVC_CallASWI         ;re-dispatch

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    return address, r10-r12 stacked, lr has SPSR for return

VSet_GenerateError ROUT

        Push    lr
        BIC     lr, lr, #&0F
        ORR     lr, lr, #SVC_mode
        MSR     CPSR_c, lr              ; Set caller's interrupt state and 26/32bitness
        MOV     r1, #Service_Error
        BL      Issue_Service

        MOV     r10, #ErrorV
        BL      CallVector              ; Normally gets to default handler...

        Pull    lr                      ; which raises error; otherwise just
        BIC     lr, lr, #V_bit          ; return with V clear: error claimed!

        LDR     r10, =ZeroPage          ; set up r10 and r11 as required
        MSR     CPSR_c, #I32_bit + SVC32_mode   ; IRQs off makes CallBackFlag atomic; 32bit so ready for SPSR use
        LDRB    r11, [r10, #CallBack_Flag]
        B       SWIReturnWithCallBackFlag

      [ CheckErrorBlocks
; In: r10-r12 stacked
;     r0 = error pointer
;     r10 = error number (maybe)
;     r11 = CallBack_Flag
;     r12 = SWI number
;     lr has SPSR for SWI return
BadErrPtr2
        TST     r0, #3                  ; Repeat pointer validity check; if this is OK we know we've arrived here because of a bad error number
        BNE     BadErrPtr
        ; With RISC OS 3.5+, Wimp_ReportError interprets error numbers with bits
        ; 24-29 set to 011011 as being a program error
        EOR     r10, r10, #27 :SHL: 24
        TST     r10, #&3F000000
        BEQ     BadErrPtrReturn
        ; The PRM describes FileCore as returning errors in the form &0001XXYY,
        ; where XX = filesystem number and YY = error code. However for disc
        ; errors it breaks this rule and uses error numbers of the form
        ; &ZZ01XXC7, where ZZ = disc error code and &C7 = "disc error". The
        ; obvious problem with this is that makes use of the reserved bits in
        ; the error number, so do an extra check here to detect that format of
        ; error number and allow it through.
        BIC     r10, r10, #&FF000000
        BIC     r10, r10, #&0000FF00
        EOR     r10, r10, #&00010000
        TEQ     r10, #&C7
        BEQ     BadErrPtrReturn
        ; Some types of error lookup code work by passing a bogus error number
        ; into MessageTrans_ErrorLookup and then fixing it up afterwards. To
        ; avoid breaking such code, and to maintain compatibility with
        ; "legitimate" [1] uses of this approach, we'll ignore any bad error
        ; numbers from XMessageTrans_ErrorLookup. Non-X form will still be
        ; caught, since there's no way the caller can expect to fix up the
        ; error number.
        ;
        ; [1] - The NVRAM module has a reserved bit set in its error numbers so
        ; that it knows it needs to translate them; after translation the bit is
        ; cleared. This does assume that the code in NVRAM will never see a
        ; translated error that has that reserved bit set - so is perhaps not
        ; entirely kosher (although the kernel now requires reserved bits to be
        ; clear too) - but it does avoid a redundant copy of the error token to
        ; the stack.
        LDR     r10, =XMessageTrans_ErrorLookup
        TEQ     r10, r12
        BEQ     BadErrPtrReturn
      ] ; CheckErrorBlocks
; In: r10-r12 stacked
;     r11 = CallBack_Flag
;     r12 = SWI number
;     lr has SPSR for SWI return
BadErrPtr ROUT
        Push    "r1-r4,lr"
        SUB     sp, sp, #12
        MOV     r1, sp
        MOV     r2, #12
        BIC     r0, r12, #Auto_Error_SWI_bit
        SWI     XOS_ConvertHex6         ; SWI argument is 00xxxxxx

        MOV     r4, r0                  ; now strip leading 0s
02      LDRB    r2, [r4], #1
        CMP     r2, #"0"
        BEQ     %BT02

        SUB     r4,r4,#1
        ADR     r0, ErrorBlock_BadErrPtr
        BL      TranslateError_UseR4
        ADD     sp, sp, #12
        Pull    "r1-r4,lr"
        B       BadErrPtrReturn

        MakeErrorBlock BadErrPtr

        LTORG

; ....................... default owner of ErrorV .............................
; In    r0  -> error in current error block

; Out   Exits to user's error handler routine as given by ErrHan
;       r1-r9 possibly corrupt. Indeed r10-r12 MAY be duff ... eg. REMOTE

ErrHandler ROUT

        BL      OscliTidy               ; close redirection, restore curr FS

        LDR     r10, =ZeroPage
        Push    "r0-r2"
        LDR     r1, [r10, #ErrHan]
        ; Check that the error handler points somewhere sensible
        ; Can be ROM or RAM or pretty much anywhere, but must be user-read
        ; Also require it to be word aligned, since we don't really support thumb
        MOV     r0, #24
        ADD     r2, r1, #4
        SWI     XOS_Memory
        TST     r1, #CMA_Completely_UserR
        TSTEQ   r2, #3
        BEQ     %FT05
        LDR     r1, [r10, #ErrBuf]
        MOV     r0, #24
        ADD     r2, r1, #256+4
        ; Must be SVC-writable, user+SVC readable, word aligned
        SWI     XOS_Memory
        AND     r1, r1, #CMA_Completely_UserR+CMA_Completely_PrivR+CMA_Completely_PrivW
        TEQ     r1, #CMA_Completely_UserR+CMA_Completely_PrivR+CMA_Completely_PrivW
        TSTEQ   r2, #3
        BEQ     %FT10
05
        BL      DEFHAN                  ; Restore default error (+escape) handler if the ones we've been given are obviously duff
10
        Pull    "r0-r2"
        LDR     r11, [r10, #ErrBuf]     ; Get pointer to error buffer

        LDR     sp_svc, =SVCSTK-4*4     ; Just below top of stack
        Pull    r14
        STR     r14, [r11], #4          ; Return PC for error

        LDR     r14, [r0], #4           ; Copy error number
        STR     r14, [r11], #4

        ; Copy error string - truncating at 252
        MOV     r12, #256-4

10      LDRB    r14, [r0], #1
        SUBS    r12, r12, #1
        MOVLS   r14, #0
        STRB    r14, [r11], #1
        TEQ     r14, #0
        BNE     %BT10

        LDR     r14, [r10, #ErrHan]     ; And go to error handler
        STR     r14, [r10, #Curr_Active_Object]
        LDR     r0,  [r10, #ErrHan_ws]  ; r0 is his wp

        MRS     r12, CPSR
        BIC     r12, r12, #I32_bit+F32_bit+&0F  ; USR26/32 mode, ARM, IRQs enabled

        MSR     CPSR_c, #I32_bit+SVC32_mode ; disable interrupts for SPSR use and CallBackFlag atomicity
        LDRB    r11, [r10, #CallBack_Flag]
        CMP     r11, #0
        MSREQ   SPSR_cxsf, r12

        Pull    "r10-r12", EQ
        MOVEQS  pc, r14                 ; USR mode, IRQs enabled

        Push    r14                     ; Stack return address
        MOV     r14, r12                ; Put PSR in R14
        B       Do_CallBack             ; Can't need postponement, r0,r14,stack
                                        ; such that callback code will normally
                                        ; call error handler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; check for CallBack possible
; r0 = SWI error ptr
; r11 = CallBack_Flag
; lr = PSR

callback_checking

        TST     lr, #I32_bit+&0F        ; user 26/32 mode, ints enabled?
        MSRNE   SPSR_cxsf, lr
        LDRNE   lr, [sp], #4
        Pull    "r10-r12", NE
        MOVNES  pc, lr                  ; Skip the branch for SVC code speed

; Further checks: postpone callback if returning V set and R0->RAM

        TST     lr, #V_bit              ; if no error then do callbacks
        LDR     r10, =ZeroPage
        BEQ     Do_CallBack
        TST     r11, #CBack_Postpone
        TSTNE   r11, #CBack_OldStyle :OR: CBack_VectorReq ; can only postpone if not already or if no callbacks pending
        BNE     Do_CallBack
 [ ROMatTop
        CMP     r0, #ROM
        BHS     Do_CallBack
 |
        CMP     r0, #ROM
        RSBHIS  r12, r0, #ROMLimit
        BHI     Do_CallBack
 ]
        ORR     r11, r11, #CBack_Postpone      ; signal to IRQs
        STRB    r11, [r10, #CallBack_Flag]
back_to_user
back_to_user_irqs_already_off
        MSR     SPSR_cxsf, lr
        LDR     lr, [sp], #4
        Pull    "r10-r12"
        MOVS    pc, lr

Do_CallBack                                    ; CallBack allowed:
        ; Entered in SVC32 mode with IRQs off, r10 = ZeroPage
        TST     r11, #CBack_Postpone
        BICNE   r11, r11, #CBack_Postpone
        STRNEB  r11, [r10, #CallBack_Flag]
Do_CallBack_postpone_already_clear
        TST     r11, #CBack_VectorReq          ; now process any vector entries
        MOV     r12,lr
        BLNE    process_callback_chain
        MOV     lr,r12

        MyCLREX r11, r12                       ; CLREX required for the case where transient callbacks have been triggered on exit from IRQ handling

        LDRB    r11, [r10, #CallBack_Flag]     ; non-transient callback may have been set during transient callbacks
        TST     r11, #CBack_OldStyle
        BEQ     back_to_user
; Check that SVC_sp is empty (apart from r14,r10-r12), i.e. system truly is idle

        LDR     r12, =SVCSTK-4*4                ; What SVC_sp should be if system idle
        CMP     sp, r12                         ; Stack empty?
        BLO     back_to_user                    ; No then no call back
        BIC     r11, r11, #CBack_OldStyle
        STRB    r11, [r10, #CallBack_Flag]

        LDR     R12, [R10, #CallBf]
        STR     r14, [r12, #4*16]             ; user PSR
        Pull    r14
        STR     r14, [r12, #4*15]             ; user PC
        MOV     r14, r12
        Pull   "r10-r12"
  [ SASTMhatbroken
        STMIA   r14!,{r0-r12}
        STMIA   r14,{r13,r14}^                ; user registers
        NOP                                   ; doesn't matter that r14 is different
  |
        STMIA   r14, {r0-r14}^                ; user registers
  ]

        LDR     R12, =ZeroPage+CallAd_ws
        LDMIA   R12, {R12, PC}                ; jump to CallBackHandler


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Also called from source.pmf.key, during readc

process_callback_chain ROUT

        Push   "r0-r6, r10-r12, lr"             ; save some for the callee too.
        MRS     r0, CPSR
        Push   "r0"
        LDR     r10, =ZeroPage

        MSR     CPSR_c, #I32_bit + SVC2632      ; ints off while flag updated
        LDRB    r11, [r10, #CallBack_Flag]
        BIC     r11, r11, #CBack_VectorReq
        STRB    r11, [r10, #CallBack_Flag]

01
        MSR     CPSR_c, #I32_bit + SVC2632      ; ints off while flag updated
        LDR     r2, [r10, #CallBack_Vector]
        TEQ     r2, #0
        Pull   "r0", EQ
        MSREQ   CPSR_c, r0                      ; restore original interrupt state and 32bitness
        Pull   "r0-r6, r10-r12, PC",EQ

        LDMIA   r2, {r1, r11, r12}             ; link, addr, r12
        MOV     r0, #HeapReason_Free
        STR     r1, [r10, #CallBack_Vector] ; Keep head valid

        MSR     CPSR_c, #SVC2632                ; enable ints for long bits

  [ ChocolateSysHeap
        ASSERT  ChocolateCBBlocks = ChocolateBlockArrays + 0
        LDR     r1, [r10, #ChocolateBlockArrays]
        BL      FreeChocolateBlock
        LDRVS   r1, =SysHeapStart
        SWIVS   XOS_Heap
  |
        LDR     r1, =SysHeapStart
        SWI     XOS_Heap
  ]
      [ NoARMv5
        MOV     lr, pc
        MOV     pc, r11                         ; call im, with given r12
      |
        BLX     r11                             ; call im, with given r12
      ]

        B       %BT01                           ; loop

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_WriteC

; In    r11 = 0 (look, up there ^) !

SWIWriteC ROUT

        MSR     CPSR_c, #SVC2632        ; enable interrupts

        Push    lr

 [ ROMatTop
      [ ZeroPage <> 0
        LDR     r11, =ZeroPage
      ]
        LDR     r11, [r11, #VecPtrTab+WrchV*4] ; load top node pointer
        CMP     r11, #ROM
        BCC     WrchThruVector
        Push    pc, CS                 ; need to get to ReturnFromVectoredWrch - push PC+12 (old ARM) or PC+8 (StrongARM)
        BCS     PMFWrchDirect
        MOV     R0,R0                  ; NOP for PC+8
 |
        B       WrchThruVector
 ]
ReturnFromVectoredWrch
        Pull    lr
        B       SLVK_TestV


WrchThruVector
        MOV     r10, #WrchV
        BL      CallVector
        B       ReturnFromVectoredWrch

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SWINewLine ROUT

        MOV     r11, lr
        SWI     XOS_WriteI+10
        SWIVC   XOS_WriteI+13
        MOV     lr, r11
        B       SLVK_TestV

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_WriteI+n

SWIWriteI ROUT

        MOV     r10, r0
        AND     r0, r11, #&FF
        MOV     r11, lr                 ; NB. Order !!!
        SWI     XOS_WriteC
        MOVVC   r0, r10
        MOV     lr, r11
        B       SLVK_TestV              ; return setting V

; .............................................................................
; define module SWI node format

ModSWINode_CallAddress * 0
ModSWINode_MListNode   * 4
ModSWINode_Link        * 8
ModSWINode_Number      * 12
ModSWINode_Size        * 16     ; not a field - the node size!

        MACRO
$l      ModSWIHashvalOffset     $swino, $startreg
     [ "$startreg"=""
$l      MOV     $swino, $swino, LSR #4
     |
$l      MOV     $swino, $startreg, LSR #4
     ]
        AND     $swino, $swino, #(ModuleSHT_Entries-1)*4
        MEND

        MACRO
$l      ModSWIHashval   $swino, $startreg
$l      ModSWIHashvalOffset $swino, $startreg
        ADD     $swino, $swino, #ModuleSWI_HashTab
      [ ZeroPage <> 0
        ASSERT ZeroPage = &FFFF0000
        ADD     $swino, $swino, #&FF000000
        ADD     $swino, $swino, #&00FF0000
      ]
        MEND



NotMainMOSSwi ; Continuation of SWI despatch

        CMP     R11, #&200
        BCC     SWIWriteI

; .............................................................................
; Look round RMs to see if they want it

ExtensionSWI ROUT

        Push    "lr"

        BIC     r12, r11, #Module_SWIChunkSize-1
        ModSWIHashvalOffset r10, r12
      [ ZeroPage = 0
        LDR     r10, [r10, #ModuleSWI_HashTab]
      |
        LDR     lr, =ZeroPage+ModuleSWI_HashTab
        LDR     r10, [r10, lr]
      ]
loopoverhashchain
        CMP     r10, #0
        BEQ     VectorUserSWI
        LDR     lr, [r10, #ModSWINode_Number]
        CMP     lr, r12
        LDRNE   r10, [r10, #ModSWINode_Link]
        BNE     loopoverhashchain

        LDMIA   r10, {r10, r12}
        LDR     r12, [r12, #Module_incarnation_list]  ; preferred life
        CMP     r12, #0
        ANDNE   r11, r11, #Module_SWIChunkSize-1
        ADDNE   r12, r12, #Incarnation_Workspace
        ADRNE   lr, %FT02
        MOVNE   pc, r10


VectorUserSWI                   ; Not in a module, so call vec
        MOV     r10, #UKSWIV    ; high SWI number still in R11
        BL      CallVector


02
        Pull    "lr"
        MRS     r10, CPSR
      [ NoARMT2
        BIC     lr, lr, #&FF000000      ; Can mangle any/all of punter flags
        AND     r10, r10, #&FF000000
        ORR     lr, lr, r10
      |
        MOV     r10, r10, LSR #24
        BFI     lr, r10, #24, #8        ; Can mangle any/all of punter flags
      ]
        B       SLVK

; ....................... default owner of UKSWIV .............................
; Call UKSWI handler
; Also used to call the upcall handler

; In    r12 = HiServ_ws (or UpCallHan_ws)

CallUpcallHandler
HighSWI ROUT                          ; no one on vec wants it: give to handler

        Pull    lr                    ; the link pointing at %BT02 to pass in.
        LDMIA   r12, {r12, pc}

; ........................ default UKSWI handler ..............................

NoSuchSWI ROUT

        Push    lr
        BL      NoHighSWIHandler
        Pull    lr
        B       SLVK_SetV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; .................... default Unused SWI handler .............................

NoHighSWIHandler ROUT

        LDR     r0, =ZeroPage
        LDR     r0, [r0, #IRQsema]
        CMP     r0, #0
        ADR     r0, ErrorBlock_NoSuchSWI ; Must return static error here
        BEQ     %FT01
        SETV
        MOV     pc, lr
01

; Not in IRQ: can safely build a dynamic error
      [ International
        Push    "r1-r4, lr"
        SUB     sp, sp,#12
        MOV     r1, sp
        MOV     r2, #12
        MOV     r0, r11
        SWI     XOS_ConvertHex6         ; SWI argument is 00xxxxxx

        MOV     r4, r0                  ; now strip leading 0s
02      LDRB    r2, [r4], #1
        CMP     r2, #"0"
        BEQ     %BT02

        SUB     r4,r4,#1
        ADR     r0, ErrorBlock_NoSuchSWI1
        BL      TranslateError_UseR4
        ADD     sp,sp,#12

        Pull    "r1-r4, lr"
        SETV
        MOV     pc, lr

        MakeErrorBlock NoSuchSWI1

      |
        Push    "r1-r3, lr"
        LDR     r1, =EnvString
        LDMIA   r0!, {r2, r3}           ; number, "SWI "
        STMIA   r1!, {r2, r3}
        MOV     r2, #"&"
        STRB    r2, [r1], #1
        MOV     r3, r0
        MOV     r0, r11
        MOV     r2, #256
        SWI     XOS_ConvertHex6         ; SWI argument is 00xxxxxx

; now strip leading 0s

        MOV     r1, r0
02      LDRB    r2, [r1], #1
        CMP     r2, #"0"
        BEQ     %BT02
        CMP     r2, #0
        ADDEQ   r1, r0, #1
        BEQ     %FT03
04      STRB    r2, [r0], #1
        LDRB    r2, [r1], #1
        CMP     r2, #0
        BNE     %BT04
        MOV     r1, r0
03      MOV     r2, #" "
01      STRB    r2, [r1], #1
        CMP     r2, #0
        LDRNEB  r2, [r3], #1
        BNE     %BT01

        Pull    "r1-r3, lr"
        LDR     r0, =EnvString
        SETV
        MOV     pc, lr
       ]

        MakeErrorBlock NoSuchSWI


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Fast SWI handlers for BGet and BPut caches

BGetSWI ROUT                            ; Done separately for highest speed

        Push    lr
        MOV     r10, #BGetV             ; Cache hit failed, call victor
        BL      CallVector
        Pull    lr                      ; Punter lr has VClear
        BIC     lr, lr, #C_bit          ; Copy C,V to punter lr
        ORRCS   lr, lr, #C_bit
        B       SLVK_TestV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BPutSWI ROUT                            ; Done separately for highest speed

        Push    "lr"
        MOV     r10, #BPutV                     ; Cache hit failed, call victor
        BL      CallVector
        Pull    "lr"                            ; Destack lr(VC)
        B       SLVK_TestV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI handlers for all the vectored SWIs that have vecnum=swinum

; All defined to affect C & V at most

FSControlSWI ROUT

        MOV     r11, #FSCV              ; Pretend to be vecnum = swinum swi
                                        ; and just drop through to ...

VecSwiDespatch ROUT

        Push    lr                      ; this is user's link (or PSR in 32-bit case)
        MOV     r10, r11                ; SWI number from R11->R10

        MRS     r11, CPSR
      [ NoARMT2
        AND     r14, r14, #&F0000000    ; extract caller's CCs
        BIC     r11, r11, #&F0000000    ; mask out ours
        BIC     r11, r11, #I32_bit      ; enable IRQs   
        ORR     r11, r11, r14           ; add in CCs
      |
        MOV     r14, r14, LSR #28
        BIC     r11, r11, #I32_bit      ; enable IRQs   
        BFI     r11, r14, #28, #4       ; add in caller's CCs
      ]
        MSR     CPSR_cf, r11            ; and set it all up

        BL      CallVector

; So the vectored routine can update the pushed link CCodes if wanted
; No update return is therefore LDMIA stack!, {PC}^ (sort of)
; Update return pulls lr, molests it, then MOVS PC, lr
; Note either return enables IRQ, FIQ

; ???? Is the DEFAULT owner allowed to corrupt r10,r11 IFF he claims it ????

        Pull    lr                      ; Punter lr has VClear
        BICCC   lr, lr, #C_bit          ; Copy C,V to punter lr
        ORRCS   lr, lr, #C_bit
        B       SLVK_TestV


NoIrqVecSwiDespatch ROUT

        Push    lr                      ; this is user's link
        MOV     r10, r11                ; SWI number from R11->R10
        MRS     r11, CPSR
      [ NoARMT2
        AND     r14, r14, #&F0000000    ; extract caller's CCs
        BIC     r11, r11, #&F0000000    ; mask out ours
        ORR     r11, r11, #I32_bit      ; disable IRQs
        ORR     r11, r11, r14           ; add in CCs
      |
        MOV     r14, r14, LSR #28
        ORR     r11, r11, #I32_bit      ; disable IRQs
        BFI     r11, r14, #28, #4       ; add in caller's CCs
      ]
        MSR     CPSR_cf, r11            ; and set it all up
        BL      CallVector
        Pull    lr                      ; Punter lr has VClear
        BICCC   lr, lr, #C_bit          ; Copy C,V to punter lr
        ORRCS   lr, lr, #C_bit
        B       SLVK_TestV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_GetEnv

SWI_GetEnv_Code ROUT

        LDR     r0, =EnvString
        LDR     r1, =ZeroPage
        LDR     r1, [r1, #MemLimit]
        LDR     r2, =ZeroPage+EnvTime
        B       SLVK

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_Exit

SEXIT ROUT

        BL      OscliTidy               ; shut redirection, restore FS

; now see if it's an abort Exit

        LDR     r12, ABEX
        CMP     r1, r12
        TSTEQ   r0, #3
        MOVNE   r2,  #0
        LDR     r12, =ZeroPage
        STR     r2,  [r12, #ReturnCode]
        LDR     r12, [r12, #RCLimit]
        CMP     r2, r12
        SWIHI   OS_GenerateError        ; really generate an error

        ADD     sp, sp, #8              ; junk SWI no and R14 on stack
        Pull    "r10-r12"
        LDR     r0, =ZeroPage
        LDR     lr, [r0, #SExitA]
        STR     lr, [r0, #Curr_Active_Object]
        LDR     r12, [r0, #SExitA_ws]
        LDR     sp_svc, =SVCSTK
        MRS     r0, CPSR
        MSR     CPSR_c, #I32_bit+SVC2632 ; IRQs off (to protect SPSR_svc)
        BIC     r0, r0, #I32_bit+F32_bit+&0F
        MSR     SPSR_cxsf, r0            ; Get ready for USR26/32, IRQs on
        MOVS    pc, lr                  ; lr->pc, SPSR->CPSR

ABEX    =       "ABEX"                  ; Picked up as word

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_CallBack: Set/read callback buffer and handler

SCALLB  MOV     r10, #CallBackHandler

handlecomm
        Push    "r2, r3, lr"
        MOV     r3, r0          ; buffer
        MOV     r0, r10
        BL      CallCESWI
        MOV     r0, r3
        Pull    "r2, r3, lr"
        B       SLVK_TestV

; .............................................................................
; SWI OS_BreakSet: Set/read breakpoint buffer and handler

SBRKCT  MOV     r10, #BreakPointHandler
        B       handlecomm

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_ReadEscapeState

ReadEscapeSWI ROUT

        LDR     r10, =ZeroPage
        LDRB    r10, [r10, #ESC_Status]
        TST     r10, #1 :SHL: 6
        BICEQ   lr, lr, #C_bit
        ORRNE   lr, lr, #C_bit
        B       SLVK

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_ServiceCall

Issue_Service_SWI ROUT

        Push    lr
        BL      Issue_Service
        Pull    lr
        B       SLVK

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_PlatformFeatures
;
;     r0 = reason code:
;          0 -> read code features
;          1 -> read MMU features (ROL, unimplemented here)
;          2-31 -> reserved just in case ROL have used them
;          32 -> read processor vectors location
;          33 -> read cache information
;          34 -> read CPU features
;          35 -> read routine to clear the exclusive monitor lock

PlatFeatSWI ROUT
        Push    lr
        CMP     r0, #OSPlatformFeatures_ReadProcessorVectors ;Is it a known reason code?
        BEQ     %FT30
        CMP     r0, #OSPlatformFeatures_ReadCacheInfo
        BEQ     %FT40
        CMP     r0, #OSPlatformFeatures_ReadCPUFeatures
        BEQ     PlatFeatSWI_ReadCPUFeatures
        CMP     r0, #OSPlatformFeatures_ReadClearExclusive
        BEQ     %FT50
        CMP     r0, #OSPlatformFeatures_ReadCodeFeatures
        BNE     %FT75                   ; No, so error

        ;Ok, it's the 'code_features' reason code.
      [ ZeroPage <> 0
        LDR     r0, =ZeroPage
      ]
        LDR     r0,[r0, #ProcessorFlags]
        TST     r0, #CPUFlag_InterruptDelay
        ADRNE   r1, platfeat_irqinsert  ;Yep, so point R1 to the delay routine
        MOVEQ   r1, #0
        Pull    lr
        B       SLVK                    ;Return

platfeat_irqinsert
        MOV     r0, r0
        MOV     r0, r0
        MOV     r0, r0
        MOV     r0, r0
        MOV     r0, r0
        MOV     pc, lr

30
        ; Return processor vectors base + size
        LDR     r0, =ProcVecs
        MOV     r1, #256                ; Currently only 256 bytes available for FIQ handlers
        Pull    lr
        B       SLVK

40
        ; Read cache information
        ; In:  r1 = cache level (0-based)
        ; Out: r0 = Flags
        ;           bits 0-2: cache type:
        ;              000 -> none
        ;              001 -> instruction
        ;              010 -> data
        ;              011 -> split
        ;              100 -> unified
        ;              1xx -> reserved
        ;           Other bits: reserved
        ;      r1 = D line length
        ;      r2 = D size
        ;      r3 = I line length
        ;      r4 = I size
        ;      r0-r4 = zero if cache level not present
        ARMop   Cache_Examine
        Pull    lr
        B       SLVK

50
        ; Read clear the exclusive routine
        LDR     r14, =ZeroPage
        LDR     r14, [r14, #ProcessorFlags]
        TST     r14, #CPUFlag_LoadStoreEx :OR: CPUFlag_LoadStoreClearExSizes
        ADRNE   r1, platfeat_clrex      ; Can set the lock, so point R1 to the clear routine
        MOVEQ   r1, #0
        Pull    lr
        B       SLVK

platfeat_clrex
        ; => SP = a full descending stack
        ;    LR = return address
        ; <= all registers preserved, lock cleared
        Push    "r0, lr"
        MyCLREX r0, r14
        Pull    "r0, pc"

75      ; Get here if bad reason
        ADR     R0, ErrorBlock_BadPlatReas
    [ International
        BL      TranslateError
    ]
        Pull    lr
        B       SLVK_SetV

        MakeErrorBlock BadPlatReas

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_GenerateError

GenErrorSWI * SLVK_SetV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        END
@


4.23
log
@Expose CLREX via OS_PlatformFeatures
To account for ARM changing their minds about how to clear the exclusive lock on different architectures, provide a function pointer with a known good implementation. This is similar to the run of NOPs returned by OS_PlatformFeatures 0 for those that need it.
If in the future any errata or similar are needed, then there's only 1 place to change it, plus clients don't need their own CPU type detection logic.

Version 5.77. Tagged as 'Kernel-5_77'
@
text
@d487 1
d490 3
d730 1
d775 1
@


4.23.2.1
log
@Merge in latest changes from main branch

Version 6.05, 4.129.2.8. Tagged as 'Kernel-6_05-4_129_2_8'
@
text
@a486 1
      [ CheckErrorBlocks
a488 3
      |
        BNE     BadErrPtr + SWIRelocation
      ]
a725 1
      [ CheckErrorBlocks
a769 1
      ] ; CheckErrorBlocks
@


4.22
log
@Implement support for cacheable pagetables
Detail:
  Modern ARMs (ARMv6+) introduce the possibility for the page table walk hardware to make use of the data cache(s) when performing memory accesses. This can significantly reduce the cost of a TLB miss on the system, and since the accesses are cache-coherent with the CPU it allows us to make the page tables cacheable for CPU (program) accesses also, improving the performance of page table manipulation by the OS.
  Even on ARMs where the page table walk can't use the data cache, it's been measured that page table manipulation operations can still benefit from placing the page tables in write-through or bufferable memory.
  So with that in mind, this set of changes updates the OS to allow cacheable/bufferable page tables to be used by the OS + MMU, using a system-appropriate cache policy.
  File changes:
  - hdr/KernelWS - Allocate workspace for storing the page flags that are to be used by the page tables
  - hdr/OSMem - Re-specify CP_CB_AlternativeDCache as having a different behaviour on ARMv6+ (inner write-through, outer write-back)
  - hdr/Options - Add CacheablePageTables option to allow switching back to non-cacheable page tables if necessary. Add SyncPageTables var which will be set {TRUE} if either the OS or the architecture requires a DSB after writing to a faulting page table entry.
  - s/ARM600, s/VMSAv6 - Add new SetTTBR & GetPageFlagsForCacheablePageTables functions. Update VMSAv6 for wider XCBTable (now 2 bytes per element)
  - s/ARMops - Update pre-ARMv7 MMU_Changing ARMops to drain the write buffer on entry if cacheable pagetables are in use (ARMv7+ already has this behaviour due to architectural requirements). For VMSAv6 Normal memory, change the way that the OS encodes the cache policy in the page table entries so that it's more compatible with the encoding used in the TTBR.
  - s/ChangeDyn - Update page table page flag handling to use PageTable_PageFlags. Make use of new PageTableSync macro.
  - s/Exceptions, s/AMBControl/memmap - Make use of new PageTableSync macro.
  - s/HAL - Update MMU initialisation sequence to make use of PageTable_PageFlags + SetTTBR
  - s/Kernel - Add PageTableSync macro, to be used after any write to a faulting page table entry
  - s/MemInfo - Update OS_Memory 0 page flag conversion. Update OS_Memory 24 to use new symbol for page table access permissions.
  - s/MemMap2 - Use PageTableSync. Add routines to enable/disable cacheable pagetables
  - s/NewReset - Enable cacheable pagetables once we're fully clear of the MMU initialision sequence (doing earlier would be trickier due to potential double-mapping)
Admin:
  Tested on pretty much everything currently supported
  Delivers moderate performance benefits to page table ops on old systems (e.g. 10% faster), astronomical benefits on some new systems (up to 8x faster)
  Stats: https://www.riscosopen.org/forum/forums/3/topics/2728?page=2#posts-58015


Version 5.71. Tagged as 'Kernel-5_71'
@
text
@d1436 1
d1446 2
d1449 1
a1449 1
        BNE     %FT50                   ;No, so send out a service call
d1499 6
a1504 9
  [ {FALSE}
        Push    "r1-r8"
        MOV     r1, #Service_UnknownPlatformFeatures
        Pull    "r2-r9"
        BL      Issue_Service
        CMP     r1, #0
        Push    "r2-r9"
        Pull    "r1-r8"
        BNE     %FT75
d1506 9
a1514 2
        B       SLVK                    ;Return
  ]
d1516 1
a1516 1
75      ;Get here if the service call isn't claimed.
@


4.21
log
@Reimplement AMBControl ontop of the PMP system
Detail:
  With this set of changes, each AMB node is now the owner of a fake DANode which is linked to a PMP.
  From a user's perspective the behaviour of AMBControl is the same as before, but rewriting it to use PMPs internally offers the following (potential) benefits:
  * Reduction in the amount of code which messes with the CAM & page tables, simplifying future work/maintenance. Some of the AMB ops (grow, shrink) now just call through to OS_ChangeDynamicArea. However all of the old AMB routines were well-optimised, so to avoid a big performance hit for common operations not all of them have been removed (e.g. mapslot / mapsome). Maybe one day these optimal routines will be made available for use by regular PMP DAs.
  * Removal of the slow Service_MemoryMoved / Service_PagesSafe handlers that had to do page list fixup after the core kernel had reclaimed/moved pages. Since everything is a PMP, the kernel will now deal with this on behalf of AMB.
  * Removal of a couple of other slow code paths (e.g. Do_AMB_MakeUnsparse calls from OS_ChangeDynamicArea)
  * Potential for more flexible mapping of application space in future, e.g. sparse allocation of memory to the wimp slot
  * Simpler transition to an ASID-based task swapping scheme on ARMv6+?
  Other changes of note:
  * AMB_LazyMapIn switch has been fixed up to work correctly (i.e. turning it off now disables lazy task swapping and all associated code instead of producing a build error)
  * The DANode for the current app should be accessed via the GetAppSpaceDANode macro. This will either return the current AMB DANode, or AppSpaceDANode (if e.g. pre-Wimp). However be aware that AppSpaceDANode retains the legacy behaviour of having a base + size relative to &0, while the AMB DANodes (identifiable via the PMP flag) are sane and have their base + size relative to &8000.
  * Mostly-useless DebugAborts switch removed
  * AMBPhysBin (page number -> phys addr lookup table) removed. Didn't seem to give any tangible performance benefit, and was imposing hidden restrictions on memory usage (all phys RAM fragments in PhysRamTable must be multiple of 512k). And if it really was a good optimisation, surely it should have been applied to all areas of the kernel, not just AMB!
  Other potential future improvements:
  * Turn the fake DANodes into real dynamic areas, reducing the amount of special code needed in some places, but allow the DAs to be hidden from OS_DynamicArea 3 so that apps/users won't get too confused
  * Add a generic abort trapping system to PMPs/DAs (lazy task swapping abort handler is still a special case)
  File changes:
  - s/ARM600, s/VMSAv6, s/ExtraSWIs - Remove DebugAborts
  - s/ArthurSWIs - Remove AMB service call handler dispatch
  - s/ChangeDyn - AMB_LazyMapIn switch fixes. Add alternate internal entry points for some PMP ops to allow the DANode to be specified (used by AMB)
  - s/Exceptions - Remove DebugAborts, AMB_LazyMapIn switch fixes
  - s/Kernel - Define GetAppSpaceDANode macro, AMB_LazyMapIn switch fix
  - s/MemInfo - AMB_LazyMapIn switch fixes
  - s/AMBControl/AMB - Update GETs
  - s/AMBControl/Memory - Remove block size quantisation, AMB_BlockResize (page list blocks are now allocated by PMP code)
  - s/AMBControl/Options - Remove PhysBin definitions, AMBMIRegWords (moved to Workspace file), AMB_LimpidFreePool switch. Add AMB_Debug switch.
  - s/AMBControl/Workspace - Update AMBNode to contain an embedded DANode. Move AMBMIRegWords here from Options file.
  - s/AMBControl/allocate - Fake DA node initialisation
  - s/AMBControl/deallocate - Add debug output
  - s/AMBControl/growp, growshrink, mapslot, mapsome, shrinkp - Rewrite to use PMP ops where possible, add debug output
  - s/AMBControl/main - Remove PhysBin initialisation. Update the enumerate/mjs_info call.
  - s/AMBControl/memmap - Low-level memory mapping routines updated or rewritten as appropriate.
  - s/AMBControl/readinfo - Update to cope with DANode
  - s/AMBControl/service - Remove old service call handlers
  - s/AMBControl/handler - DA handler for responding to PMP calls from OS_ChangeDynamicArea; just calls through to growpages/shrinkpages as appropriate.
Admin:
  Tested on pretty much everything currently supported


Version 5.66. Tagged as 'Kernel-5_66'
@
text
@d168 22
a189 1
        MEND                
@


4.20
log
@Update error block validity checks to cope with Wimp "program errors"
Detail:
  s/Kernel - With RISC OS 3.5, one of the ways Wimp_ReportError detects program errors is by bits 24-29 of the error number being set to 011011. Update our error block validity checks to allow that pattern through.
Admin:
  Tested on Raspberry Pi
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/3/topics/3540?page=2#posts-60089


Version 5.65. Tagged as 'Kernel-5_65'
@
text
@d253 1
a253 1
; Set up symbols for the SWIs which aren't really there yet
d255 21
d357 1
a357 1
   [ ChocolateAMB
@


4.19
log
@Don't flag FileCore disc error error numbers as being invalid
Detail:
  s/Kernel - FileCore breaks the usual error number rules for disc errors and uses numbers of the form &XX01YYC7, which was tripping up the sanity checks due to making use of the reserved bits 24-30. Add an extra rule to allow that form of errors through.
Admin:
  Tested on Raspberry Pi
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/3/topics/3540#posts-58635


Version 5.63. Tagged as 'Kernel-5_63'
@
text
@d684 6
d693 5
d709 1
a709 1
        BEQ     BadErrPtrReturn        
d729 1
@


4.18
log
@Add support for shareable pages and additional access privileges
Detail:
  This set of changes:
  * Refactors page table entry encoding/decoding so that it's (mostly) performed via functions in the MMU files (s.ARM600, s.VMSAv6) rather than on an ad-hoc basis as was the case previously
  * Page table entry encoding/decoding performed during ROM init is also handled via the MMU functions, which resolves some cases where the wrong cache policy was in use on ARMv6+
  * Adds basic support for shareable pages - on non-uniprocessor systems all pages will be marked as shareable (however, we are currently lacking ARMops which broadcast cache maintenance operations to other cores, so safe sharing of cacheable regions isn't possible yet)
  * Adds support for the VMSA XN flag and the "privileged ROM" access permission. These are exposed via RISC OS access privileges 4 and above, taking advantage of the fact that 4 bits have always been reserved for AP values but only 4 values were defined
  * Adds OS_Memory 17 and 18 to convert RWX-style access flags to and from RISC OS access privelege numbers; this allows us to make arbitrary changes to the mappings of AP values 4+ between different OS/hardware versions, and allows software to more easily cope with cases where the most precise AP isn't available (e.g. no XN on <=ARMv5)
  * Extends OS_Memory 24 (CheckMemoryAccess) to return executability information
  * Adds exported OSMem header containing definitions for OS_Memory and OS_DynamicArea
  File changes:
  - Makefile - export C and assembler versions of hdr/OSMem
  - Resources/UK/Messages - Add more text for OS_Memory errors
  - hdr/KernelWS - Correct comment regarding DCacheCleanAddress. Allocate workspace for MMU_PPLTrans and MMU_PPLAccess.
  - hdr/OSMem - New file containing exported OS_Memory and OS_DynamicArea constants, and public page flags
  - hdr/Options - Reduce scope of ARM6support to only cover builds which require ARMv3 support
  - s/AMBControl/Workspace - Clarify AMBNode_PPL usage
  - s/AMBControl/growp, mapslot, mapsome, memmap - Use AreaFlags_ instead of AP_
  - s/AMBControl/main, memmap - Use GetPTE instead of generating page table entry manually
  - s/ARM600 - Remove old coments relating to lack of stack. Update BangCam to use GetPTE. Update PPL tables, removing PPLTransL1 (L1 entries are now derived from L2 table on demand) and adding a separate table for ARM6. Implement the ARM600 versions of the Get*PTE ('get page table entry') and Decode*Entry functions
  - s/ARMops - Add Init_PCBTrans function to allow relevant MMU_PPLTrans/MMU_PCBTrans pointers to be set up during the pre-MMU stage of ROM init. Update ARM_Analyse to set up the pointers that are used post MMU init.
  - s/ChangeDyn - Move a bunch of flags to hdr/OSMem. Rename the AP_ dynamic area flags to AreaFlags_ to avoid name clashes and confusion with the page table AP_ values exported by Hdr:MEMM.ARM600/Hdr:MEMM.VMSAv6. Also generate the relevant flags for OS_Memory 24 so that it can refer to the fixed areas by their name instead of hardcoding the permissions.
  - s/GetAll - GET Hdr:OSMem
  - s/HAL - Change initial page table setup to use DA/page flags and GetPTE instead of building page table entries manually. Simplify AllocateL2PT by removing the requirement for the user to supply the access perimssions that will be used for the area; instead for ARM6 we just assume that cacheable memory is the norm and set L1_U for any L1 entry we create here.
  - s/Kernel - Add GetPTE macro (for easier integration of Get*PTE functions) and GenPPLAccess macro (for easy generation of OS_Memory 24 flags)
  - s/MemInfo - Fixup OS_Memory 0 to not fail on seeing non-executable pages. Implement OS_Memory 17 & 18. Tidy up some error generation. Make OS_Memory 13 use GetPTE. Extend OS_Memory 24 to return (non-) executability information, to use the named CMA_ constants generated by s/ChangeDyn, and to use the Decode*Entry functions when it's necessary to decode page table entries.
  - s/NewReset - Use AreaFlags_ instead of AP_
  - s/VMSAv6 - Remove old comments relating to lack of stack. Update BangCam to use GetPTE. Update PPL tables, removing PPLTransL1 (L1 entries are now derived from L2 table on demand) and adding a separate table for shareable pages. Implement the VMSAv6 versions of the Get*PTE and Decode*Entry functions.
Admin:
  Tested on Raspberry Pi 1, Raspberry Pi 3, Iyonix, RPCEmu (ARM6 & ARM7), comparing before and after CAM and page table dumps to check for any unexpected differences


Version 5.55. Tagged as 'Kernel-5_55'
@
text
@d685 14
d709 1
a709 1
        ; cleared. This does assume that the code in PortMan will never see a
d714 2
a715 3
        TST     r0, #3                  ; Repeat pointer validity check; if this is OK we know we've arrived here because of a bad error number
        LDREQ   r10, =XMessageTrans_ErrorLookup
        TEQEQ   r10, r12
@


4.17
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d114 56
@


4.16
log
@Delete STB code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a desktop build):
  * STB
  * RO371Timings
  * NormalSpeedROMS
  * AutoSpeedROMS
  * RISCPCBurstMode
  * InterlacedPointer
  * ParallelFlashUpgrade (and s/FlashROM file)
  * Embedded_UI
  Some of the deleted code might be worth revisiting in future:
  * OS_ReadSysInfo 4 support for storing the MAC in alternate CMOS locations (including 2nd copy for error checking) or fetching via Service_MachineAddress
  * Mouse handling changes, possibly aimed at hiding the mouse pointer if a mouse isn't connected
  * More strict CMOS validation in s/NewReset
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.50. Tagged as 'Kernel-5_50'
@
text
@a119 21
; Fake a 26-bit pc, given a PSR currently in lr (or reg), and the 32-bit address on
; the stack. The stacked address is pulled, and the result is left in lr.

        MACRO
        FakeLR  $temp, $dontpull, $reg
 [ "$reg" = ""
        AND     $temp,lr,#&F0000003
 |
        AND     $temp,$reg,#&F0000003
 ]
        AND     lr,lr,#I32_bit+F32_bit
        ORR     $temp,$temp,lr,LSL #IF32_26Shift
 [ "$dontpull" = "dontpull"
        LDR     lr,[sp]
 |
        LDR     lr,[sp],#4
 ]
        BIC     lr,lr,#ARM_CC_Mask
        ORR     lr,lr,$temp
        MEND

a121 80
    [ AddTubeBashers
 [ TubeType = Tube_Normal
DebugTUBE  * &03340000+3*&4000         ; tube in podule #3
; Tube register offsets
 ^ 0
R1STAT # 4
R1DATA # 4
 |
DebugTUBE * &03000000           ; simulator tube address
R1DATA * 0
 ]
   ]

; routine to stuff a char down the Tube
; should be inside above conditional, but AAsm winges pitifully.
     MACRO
$l   TubeChar $reg1, $reg2, $charset, $stackthere
  !  0, "TubeChar used."
$l
   [ "$stackthere"=""
   Push "$reg1, $reg2"
   ]
     LDR  $reg1, =DebugTUBE
 [ TubeType = Tube_Normal               ; normal tubes have status register, simulator one doesn't
01   LDRB $reg2, [$reg1, #R1STAT]
     TST $reg2, #&40
     BEQ %BT01
 ]
     $charset
     STRB $reg2, [$reg1, #R1DATA]
   [ "$stackthere"=""
   Pull "$reg1, $reg2"
   ]
     MEND

        MACRO
$l      TubeString $reg1, $reg2, $reg3, $string, $cc
        LDR     $reg1, =DebugTUBE
        ADR     $reg2, %FT20
10
 [ TubeType = Tube_Normal
        LDRB    $reg3, [$reg1, #R1STAT]
        TST     $reg3, #&40
        BEQ     %BT10
 ]

        LDRB    $reg3, [$reg2], #1
        TEQ     $reg3, #0
        STRNEB  $reg3, [$reg1, #R1DATA]
        BNE     %BT10
        B       %FT30
20
        =       "$string"
 [ "$cc" = ""
        =       10, 13
 ]
        =       0
        ALIGN
30
        MEND

        MACRO
$l      TubeDumpNoStack $dump, $t1, $t2, $t3
$l      MOV    $t1, #7
01
        ADRL   $t2, HexTable
        TubeChar $t3, $t2, "LDRB $t2, [$t2, $dump, LSR #28]", NoStack
        MOV    $dump, $dump, ROR #28
        SUBS   $t1, $t1, #1
        BPL    %BT01
        TubeChar $t3, $t2, "MOV $t2, #"" """, NoStack
        MEND

        MACRO
$l      TubeNewlNoStack $t1, $t2
$l      TubeChar $t1, $t2, "MOV $t2, #10", NoStack
        TubeChar $t1, $t2, "MOV $t2, #13", NoStack
        MEND


a185 8
VideoPhysRam *  &02000000               ; Amazing - it's in the same place!
DRAM0PhysRam *  &10000000               ; 4 DRAM banks
DRAM1PhysRam *  &14000000
DRAM2PhysRam *  &18000000
DRAM3PhysRam *  &1C000000
DRAMBaseAddressMask * &1C000000         ; used to mask off bits after stealing video RAM
SAMLength *     512*4                   ; SAM length in bytes for 1 bank of VRAM

a215 5
        GBLS    DoMorrisROMHeader
        GBLS    DoTestThings
DoMorrisROMHeader SETS ""
DoTestThings      SETS ""

a352 1
      [ FixCallBacks
a353 1
      ]
a363 3
      [ :LNOT: FixCallBacks
        MSREQ   CPSR_c, #I32_bit + SVC32_mode           ; IRQs off for SPSR use
      ]
a381 1
      [ FixCallBacks
a382 3
      |
        BEQ     %BT40
      ]
a392 1
      [ FixCallBacks
a394 3
      |
        BNE     %BT40
      ]
a545 1
 [ AssemblePointerV
a546 3
 |
        & NoSuchSWI
 ]
a550 1
 [ ProcessorVectors
a551 3
 |
        & NoSuchSWI
 ]
a554 1
 [ StrongARM
a559 7
 |
        & NoSuchSWI
        & NoSuchSWI
        & NoSuchSWI
        & NoSuchSWI
        & NoSuchSWI
 ]
a590 3
 [ StrongARM
;StrongARM needs these

a603 2
 ]

a610 1
      [ FixCallBacks
a613 1
      ]
a623 1
      [ FixCallBacks
a624 1
      ]
a732 5
      [ :LNOT: FixCallBacks
        LDRB    r11, [r10, #CallBack_Flag]
        CMP     r11, #0
      ]

a735 1
      [ FixCallBacks
a738 3
      |
        MSREQ   CPSR_c, #I32_bit+SVC32_mode ; disable interrupts for SPSR use
      ]
a758 3
      [ :LNOT: FixCallBacks             ; already entered with this CPSR
        MSRNE   CPSR_c, #I32_bit + SVC32_mode
      ]
a769 1
      [ FixCallBacks
a770 1
      ]
a779 4
      [ :LNOT: FixCallBacks
        MSR     CPSR_c, #I32_bit + SVC32_mode  ; ints off while flag updated
        LDRB    r11, [r10, #CallBack_Flag]
      ]
a782 3
      [ :LNOT: FixCallBacks                    ; already entered with this CPSR
        MSR     CPSR_c, #I32_bit + SVC32_mode
      ]
a789 1
      [ FixCallBacks
a794 1
      ]
a799 1
        ASSERT  FixCallBacks                   ; (clobbering r11)
a801 1
      [ FixCallBacks
a802 1
      ]
a804 1
 [ {TRUE}                                       ; LRust, Fix RP-0609
a809 2
 ]
      [ FixCallBacks
a810 5
      |
        MSR     CPSR_c, #I32_bit + SVC2632      ; ints off while flag updated
        LDRB    r11, [r10, #CallBack_Flag]
        BIC     r11, r11, #CBack_Postpone+CBack_OldStyle
      ]
a836 1
      [ FixCallBacks
a838 1
      ]
a849 1
      [ FixCallBacks
a851 3
      |
        MSREQ   CPSR_c, #SVC2632                ; ensure exit with ints on
      ]
a897 1
  [ StrongARM
a901 5
  |
        Push    pc, CS                 ; push address of ReturnFromVectoredWrch (PC+12)
        BCS     PMFWrchDirect
        BCC     WrchThruVector
  ]
a1302 1
 [ StrongARM
a1394 1
  ]
@


4.15
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a292 3
 [ STB
PhysExtROM *    &01000000               ; 2nd ROM bank starts at 16M
 ]
a688 3
 [ STB
        & NoSuchSWI
 |
a689 1
 ]
@


4.14
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a283 1
 [ HAL32 :LAND: {TRUE}
a285 4
 |
ROM      * &03800000
ROMLimit * &04000000
 ]
a296 6
 [ :LNOT: HAL
PhysSpaceSize * &20000000               ; IOMD physical map is 512M big
PhysROM *       &00000000               ; and real ROM starts at 0
EASISpacePhys * &08000000
EASISpace *     PhysSpace + EASISpacePhys
 ]
a314 1
  [ HAL
a315 3
  |
        ORG     ROM
  ]
a332 1
  [ HAL
a354 51
  |


 [ MorrisSupport
DoMorrisROMHeader SETS  " GET s.Morris"
 ]

; now include the test code, if there is any


 [ IncludeTestSrc
DoTestThings    SETS    " GET TestSrc.Begin"
 ]
        $DoTestThings

 [ IncludeTestSrc
DoMorrisROMHeader SETS  ""
 ]

        $DoMorrisROMHeader
  ]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; If there is no test code then we want a branch table at the start of ROM to
; handle reset and any aborts etc. in the reset code.
; If MorrisSupport we've already generated 16/32 ROM entry code, so skip this bit

  [ :LNOT: IncludeTestSrc :LAND: :LNOT: MorrisSupport :LAND: :LNOT: HAL
        LDR     pc, .+ResetIndirection ; load PC, PC relative
        B       UndInstInReset
        B       SWIInReset
        B       PrefAbInReset
        B       DataAbInReset
        B       AddrExInReset
        B       IRQInReset

UndInstInReset
        SUB     pc, pc, #8
SWIInReset
        SUB     pc, pc, #8
PrefAbInReset
        SUB     pc, pc, #8
DataAbInReset
        SUB     pc, pc, #8
AddrExInReset
        SUB     pc, pc, #8
IRQInReset
        SUB     pc, pc, #8
  ]

a394 1
 [ No26bitCode
a403 5
 |
        DCD     0
        DCD     0
        DCD     0
 ]
a423 12
 [ :LNOT: IncludeTestSrc :LAND: :LNOT: HAL

; We now waste space until the offset into the ROM is the same as the RAM address of ResetIndirection
; This is so that
;  a) on a reset, ROM is paged in at the bottom, so we jump to CONT, and
;  b) on a break, RAM is paged in at the bottom, so we jump to CONT_Break

        ASSERT  .-ROM <= ResetIndirection
        %       ResetIndirection-(.-ROM)
        &       CONT-ROM+PhysROM        ; address of reset code in physical space
 ]

a588 1
 [ No26bitCode
a589 3
 |
        & VecSwiDespatch        ; readline
 ]
a870 1
  [ No26bitCode
a873 6
  |
        LDR     sp_svc, =SVCSTK-5*4     ; Just below top of stack
        Pull    r14                     ; PSR will be on stack if error at top level
        FakeLR  r12                     ; Fake up the PC+PSR
        STR     r14, [r11], #4
  ]
a877 4
  [ HAL
        ; ref: https://www.riscosopen.org/tracker/tickets/201
        ; Trunk kernel was fixed to truncate at 248, but HAL has always used
        ; 252, and that's considered to be the way ahead.
a879 4
  |
        ; Copy error string - truncating at 248
        MOV     r12, #256-4-4
  ]
a888 3
  [ :LNOT: No26bitCode
        BIC     r14, r14, #ARM_CC_Mask
  ]
a989 4
 [ :LNOT:No26bitCode
        TST     r14, #&10                       ; must be returning to 26-bit
        BNE     back_to_user                    ; on 26-bit systems
 ]
a997 3
      [ :LNOT: No26bitCode
        MSR     CPSR_c, #I32_bit + SVC2632      ; back to 26-bit mode
      ]
a1006 1
  [ No26bitCode
a1009 4
  |
        FakeLR  r10
        STR     r14, [r12, #4*15]             ; user PC/PSR
  ]
d1030 1
a1030 1
      [ FixCallBacks :LAND: No26bitCode
a1044 1
      [ No26bitCode
a1051 3
      |
        Pull   "r0-r6, r10-r12, PC",EQ,^
      ]
a1184 2
      [ No26bitCode
        ASSERT  FixR9CorruptionInExtensionSWI
a1185 8
      |
        Push    "r9, lr"                        ; first construct the link to pass on.
        AND     r10, lr, #&F0000000             ; copy in user CCodes
        AND     r12, lr, #F32_bit+I32_bit       ; (inc. IRQ state)
        ORR     r10, r10, r12, LSL #IF32_26Shift
        ADR     lr, %FT02 + SVC_mode
        ORR     lr, lr, r10
      ]
a1197 1
 [ No26bitCode
a1199 4
 |
        LDR     r9, [r10, #ModSWINode_Number]
        CMP     r9, r12
 ]
a1205 6

 [ FixR9CorruptionInExtensionSWI:LAND::LNOT:No26bitCode
        Pull    "r9", NE                ; restore corrupted r9 before calling SWI handler
                                        ;RCM added 'NE' above to fix MED=04655
 ]

a1207 1
 [ No26bitCode
a1208 1
 ]
a1212 3
 [ FixR9CorruptionInExtensionSWI:LAND::LNOT:No26bitCode
        Pull    "r9"            ; restore corrupted r9 before calling UKSWIV
 ]
a1213 1
 [ No26bitCode
a1214 3
 |
        B       CallVector      ; lr still has user CCs (if 26bit) & points at%FT02
 ]
d1218 1
a1218 5
 [ FixR9CorruptionInExtensionSWI
        Pull    "lr"                    ; r9 already pulled off stack before calling SWI handler or UKSWIV
 |
        Pull    "r9,lr"
 ]
a1259 1
 [ No26bitCode
a1263 3
 |
        ORRNES  pc, lr, #V_bit
 ]
a1284 1
 [ No26bitCode
a1286 3
 |
        ORRS    pc, lr, #V_bit
 ]
a1323 1
 [ No26bitCode
a1325 3
 |
        ORRS    pc, lr, #V_bit
 ]
a1368 1
  [ No26bitCode
a1380 5
  |
        ORR     r14, lr, #SVC_mode
        BIC     r14, r14, #I_bit        ; Enable IRQs
        TEQP    r14, #0
  ]
a1400 1
  [ No26bitCode
a1412 4
  |
        ORR     r14, lr, #SVC_mode+I_bit ; Disable IRQ
        TEQP    r14, #0
  ]
a1440 1
 [ No26bitCode
a1441 3
 |
        TSTEQ   r0, #ARM_CC_Mask
 ]
a1455 1
 [ No26bitCode
a1460 3
 |
        BICS    pc, lr, #ARM_CC_Mask
 ]
@


4.13
log
@  New exports, and a bugfix to error handling.
Detail:
  * Hdr2H can cope with hdr.EnvNumbers, hdr.ModHand and hdr.Variables, so C
    versions of these headers are now exported (in addition to RISCOS.h,
    which has been exported for some time).
  * The default owner of ErrorV is responsible for filling in the error
    handler's buffer, but was failing to compensate for the PC word at the
    start of the buffer when truncating the error message, leading to
    possible overruns of the buffer.
Admin:
  Too trivial to test.

Version 5.45. Tagged as 'Kernel-5_45'
@
text
@d23 24
a46 3
         MACRO
$l       CheckSpaceOnStack   $space, $faildest, $tmp
 [ True ; SKS
d51 1
a51 8
 |
$l       MOV        $tmp, #32*1024   ; assume stack ends at next 32K boundary
         SUB        $tmp, $tmp, #1
         AND        $tmp, $tmp, stack
         CMP        $tmp, #$space
         BLT        $faildest
 ]
         MEND
d60 7
a66 2
; one that builds a module command table entry:
; set Module_BaseAddr to module base before use.
d68 8
a75 2
                GBLA    Module_BaseAddr
Module_BaseAddr SETA    0
d77 8
a84 1
;        Command $cmd, $max, $min   - declared in hdr.macros.
d86 7
a92 1
; debug macro: set the border colour
d94 4
d99 13
a111 16
$l      SetBorder  $reg1, $reg2, $red, $green, $blue, $delay
        ! 0, "Setborder used"
$l      LDR     $reg1, =VIDC
 [ VIDC_Type = "VIDC20"
; Note $reg, $green and $blue are 4 bit values
        LDR     $reg2, =&40000000+(($red)*&11)+(($green)*&1100)+(($blue)*&110000)
 |
        LDR     $reg2, =&40000000+ $red + $green *16 + $blue *256
 ]
        STR     $reg2, [$reg1]
 [ "$delay"<>""
        MOV     $reg1, #$delay
10
        SUBS    $reg1, $reg1, #1
        BNE     %BT10
 ]
d114 6
a140 12
; Ickle macros. We want to be able to turn IRQs on and off fast in the
; code in various places. To do this easily, have a name for the
; SVC26/32 mode we run in

 [ No26bitCode
USR2632 * USR32_mode
SVC2632 * SVC32_mode
 |
USR2632 * USR26_mode
SVC2632 * SVC26_mode
 ]

d222 49
d275 3
d282 9
a290 3
MEMCADR  * &3600000
ROM      * &3800000
OSMD     * &11111111
a297 2
PhysSpaceSize * &20000000               ; IOMD physical map is 512M big
PhysROM *       &00000000               ; and real ROM starts at 0
d302 3
d307 1
a314 4
; Registers

SPIRQ RN R13

a321 1
AbortTrapSWI * NoSuchSWI
d326 11
d343 29
a371 1
        ORG     ROM
a372 1
        GBLS    DoMorrisROMHeader
a375 2
 |
DoMorrisROMHeader SETS  ""
a379 1
        GBLS    DoTestThings
a382 2
 |
DoTestThings    SETS    ""
d391 1
d399 1
a399 2
  [ :LNOT: IncludeTestSrc :LAND: :LNOT: MorrisSupport
   [ ResetIndirected
a400 7
   |
    [ MEMC_Type = "IOMD"
        B       CONT                            ; PhysROM is at zero on IOMD
    |
        B       MOSROMVecs+CONT                 ; executed out of ROM or RAM
    ]
   ]
d436 2
a437 1
        LDR     pc, MOSROMVecs+InitKbdHandler
d439 1
a439 5
        MOV     r10, #IOC               ; we dunno what to do with it -
                                        ; so cut it off - right off!
        STRB    r10, [r10, #IOCFIQMSK]  ; :LSB: IOC = 0
        SUBS    pc, r14, #4
EndFiq
d445 1
a445 1
        &       RESET1
d463 1
a463 1
UndPreVeneer    *       ProcVecPreVeneers+(.-DefaultPreVeneers)
d465 4
a468 1
PAbPreVeneer    *       ProcVecPreVeneers+(.-DefaultPreVeneers)
d470 1
d477 1
a477 1
AdXPreVeneer    *       ProcVecPreVeneers+(.-DefaultPreVeneers)
d482 13
d496 2
a497 1
 [ ResetIndirected :LAND: :LNOT: IncludeTestSrc
d547 1
d550 1
d552 6
d568 4
a571 2
        msr EQ ,CPSR_c, #I32_bit + SVC32_mode           ; IRQs off for SPSR use
        msr EQ ,SPSR_cxsf, lr
d579 29
a607 1
50      TST     r12, #Auto_Error_SWI_bit
d609 1
d613 4
d624 2
a625 2
 [ No26bitCode
        mrs    ,r12, SPSR               ; r12 = saved PSR
d632 1
a632 1
        mrs    ,r12, SPSR               ; r12 = saved PSR
d640 1
a640 1
        msr    ,CPSR_c, r10             ; restore caller's IRQ state
d646 1
a646 2
        BICS    r11, r11, #Auto_Error_SWI_bit
        BEQ     SWIWriteC + SWIRelocation
d658 1
a658 1
JTABLE  & SWIWriteC             ; this entry never gets used (see ^)
d674 3
d678 1
d705 1
a705 1
        & CvtToDecimal
d772 1
a772 2
        & AbortTrapSWI
 [ CPU_Type = "ARM600"
a773 3
 |
        & NoSuchSWI
 ]
a779 1
 [ CPU_Type = "ARM600"
a780 3
 |
        & NoSuchSWI
 ]
d800 4
a803 3
	& NoSuchSWI	; SpecialControl
	& NoSuchSWI	; EnterUSR32SWI
	& NoSuchSWI	; EnterUSR26SWI
a804 6
; Should not cause any problems on any machine.  STB flag just to be safe though.
 [ STB :LAND: {TRUE}
	& VIDCDividerSWI
 |
	& NoSuchSWI
 ]
d806 9
a815 1
MaxSwi * (.-JTABLE)/4
d817 2
a818 1
 ASSERT MaxSwi < OS_ConvertStandardDateAndTime
d855 5
d869 4
a872 1
        MOV     r10, #0                 ; set up r10 and r11 as required
d876 45
d933 25
a957 1
        MOV     r10, #0
d974 7
d983 1
d999 1
d1002 1
d1004 1
a1004 1
        mrs    ,r12, CPSR
d1007 8
a1014 4
  [ :LNOT: NoSPSRcorruption
        msr EQ, CPSR_c, #I32_bit+SVC32_mode ; disable interrupts for SPSR use
  ]
        msr EQ, SPSR_cxsf, r12
d1027 3
d1034 4
a1037 2
        msr NE ,CPSR_c, #I32_bit + SVC32_mode
        msr NE ,SPSR_cxsf, lr
d1044 2
a1045 1
        TST     lr, #V_bit
d1047 6
a1052 2
        TST     r11, #CBack_Postpone    ; only one postponement
        BNE     Do_CallBack             ; allowed.
d1054 8
a1061 3
        BGE     Do_CallBack

        msr    ,CPSR_c, #I32_bit + SVC32_mode  ; ints off while flag updated
d1063 1
d1067 3
a1069 1
        msr    ,CPSR_c, #I32_bit + SVC32_mode
d1071 1
a1071 1
        msr    ,SPSR_cxsf, lr
d1077 7
d1089 6
d1104 2
a1105 2
        LDR     r11, =SVCSTK-4*4                ; What SVC_sp should be if system idle
        CMP     sp, r11                         ; Stack empty?
d1108 7
a1114 1
        msr    ,CPSR_c, #I32_bit + SVC2632      ; ints off while flag updated
d1117 1
d1120 1
a1120 2
        MOV     r12, #0
        LDR     R12, [R12, #CallBf]
d1139 1
a1139 1
        MOV     R12, #CallAd_ws
d1149 5
a1153 1
        MOV     r10, #0
d1155 1
a1155 1
        msr    ,CPSR_c, #I32_bit + SVC2632      ; ints off while flag updated
d1161 2
a1162 3
        msr    ,CPSR_c, #I32_bit + SVC2632      ; ints off while flag updated
        MOV     r2, #0
        LDR     r2, [r2, #CallBack_Vector]
d1165 6
a1170 1
        msr EQ ,CPSR_c, #SVC2632                ; ensure exit with ints on
d1176 1
a1176 1
        LDMIA   r2, {r10, r11, r12}             ; link, addr, r12
d1178 1
a1178 1
        STR     r10, [r0, #CallBack_Vector-HeapReason_Free] ; Keep head valid
d1180 1
a1180 1
        msr    ,CPSR_c, #SVC2632                ; enable ints for long bits
d1184 1
a1184 2
        MOV     r1,#ChocolateBlockArrays
        LDR     r1,[r1,#0]
d1192 1
a1192 1

d1195 3
d1210 1
a1210 1
        msr    ,CPSR_c, #SVC2632        ; enable interrupts
d1212 1
a1212 1
        STR     lr, [sp, #-4]!
d1214 4
d1230 3
d1289 5
a1307 1
        Push    "r9, lr"                        ; first construct the link to pass on.
d1309 2
a1310 1
        ADR     lr, %FT02
d1312 1
d1322 1
d1324 4
d1331 4
d1337 1
d1345 1
a1345 1
 [ FixR9CorruptionInExtensionSWI
d1352 3
d1359 1
a1359 1
 [ FixR9CorruptionInExtensionSWI
d1363 3
d1367 1
d1376 4
a1379 3
        mrs     AL, r10, CPSR
        BIC     lr, lr, #&F0000000      ; Can mangle any/all of punter NZCV flags
        AND     r10, r10, #&F0000000
d1381 4
d1413 1
a1413 1
        MOV     r0, #0
d1539 2
a1540 1
        mrs     AL, r11, CPSR
d1543 1
a1543 1
        BIC     r11, r11, #I32_bit      ; enable IRQs
d1545 6
a1550 1
        msr    ,CPSR_cf, r11            ; and set it all up
d1577 2
a1578 1
        mrs     AL, r11, CPSR
d1583 6
a1588 1
        msr     AL, CPSR_cf, r11        ; and set it all up
d1605 1
a1605 1
        MOV     r1, #0
d1607 1
a1607 1
        LDR     r2, =EnvTime
d1627 1
a1627 1
        MOV     r12, #0
d1635 1
a1635 1
        MOV     r0, #0
d1641 2
a1642 4
        mrs     AL, r0, CPSR
   [ :LNOT: NoSPSRcorruption
        msr    ,CPSR_c, #I32_bit+SVC2632 ; IRQs off (to protect SPSR_svc)
   ]
d1644 1
a1644 1
        msr     AL, SPSR_cxsf, r0       ; Get ready for USR26/32, IRQs on
d1652 2
d1679 1
a1679 1
        MOV     r10, #0
d1698 9
a1706 1
; SWI XOS_PlatformFeatures
d1710 7
a1716 1
        CMP     r0, #0                  ;Is it a known reason code?
d1720 5
a1724 2
        LDRB    r0,[r0, #ProcessorFlags]
        TST     r0, #2                  ;Is the 'no irq enable/disable' bit set?
d1738 28
a1772 1
        BNE     %FT75
d1775 2
d1781 1
a1781 1
        ADR     R0,platfeaterror
a1782 1
        Push    "lr"
a1783 1
        Pull    "lr"
d1785 1
d1788 1
a1788 8
platfeaterror
        &       0
    [ International
        =       "BadPlatReas", 0
    |
        =       "Unknown OS_PlatformFeatures reason code", 0
    ]
        ALIGN
@


4.12
log
@OS_CallASWI and OS_CallASWIR12 sped up by 4-6 cycles (depending on which ARM).
Some POST changes which got lost recommitted.

Version 5.24. Not tagged
@
text
@d726 2
a727 2
        ; Copy error string - truncating at 252
        MOV     r12, #256-4
@


4.12.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d96 12
a197 3
 [ HAL32
ROM      * &FC000000
 |
a198 1
 ]
d233 1
a237 11
  [ HAL
        ORG     ROM + 64*1024
  |
        ORG     ROM
  ]

        AREA    |!!!!OSBase|,CODE,READONLY

        ENTRY                   ; Not really, but we need it to link
KernelBase

d244 1
a244 5
  [ HAL
;        ORG     ROM + 64*1024
  |
;        ORG     ROM
  ]
a246 24
        GBLS    DoTestThings
DoMorrisROMHeader SETS ""
DoTestThings      SETS ""

  [ HAL
;        BIN     HAL.L7200.HAL

; RISC OS image header
RISCOS_Header
        =       "ROIm"
        DCD     0
        DCD     ROM
        DCD     1*1024*1024 - 64*1024
        DCD     RISCOS_Entries - RISCOS_Header
        DCD     (RISCOS_Entries_End - RISCOS_Entries) / 4

RISCOS_Entries
        DCD     RISCOS_InitARM - RISCOS_Entries
        DCD     RISCOS_AddRAM  - RISCOS_Entries
        DCD     RISCOS_Start   - RISCOS_Entries
RISCOS_Entries_End

  |

d250 2
d256 1
d260 2
d263 1
a268 2
  ]
        $DoTestThings
d277 1
a277 1
  [ :LNOT: IncludeTestSrc :LAND: :LNOT: MorrisSupport :LAND: :LNOT: HAL
d368 1
a368 1
 [ ResetIndirected :LAND: :LNOT: IncludeTestSrc :LAND: :LNOT: HAL
d405 3
a407 1
SLVK_SetV * SWIDespatch + {PC}-SVCDespatcher
d411 1
a411 1
SLVK_TestV * SWIDespatch + {PC}-SVCDespatcher
d416 1
a416 1
SLVK * SWIDespatch + {PC}-SVCDespatcher
a417 1
Local_SLVK
d426 1
a426 1
SWIReturnWithCallBackFlag * SWIDespatch + {PC}-SVCDespatcher
d431 2
a432 2
        MSREQ   CPSR_c, #I32_bit + SVC32_mode           ; IRQs off for SPSR use
        MSREQ   SPSR_cxsf, lr
d437 1
a437 5
 [ HAL
        BKPT 2
 |
        B       callback_checking + SVCDespatcher - SWIDespatch
 ]
d439 1
a439 1
 ! 0,"VSetReturn at ":CC:(:STR:(SWIDespatch + {PC}-SVCDespatcher))
d443 1
a443 5
 [ HAL
        BKPT 2
 |
        B       VSet_GenerateError + SVCDespatcher - SWIDespatch
 ]
d449 1
a449 1
SVC * SWIDespatch + {PC}-SVCDespatcher
d453 1
a453 1
        MRS     r12, SPSR               ; r12 = saved PSR
d460 1
a460 1
        MRS     r12, SPSR               ; r12 = saved PSR
d468 1
a468 1
        MSR     CPSR_c, r10             ; restore caller's IRQ state
d472 1
a472 1
SVC_CallASWI * SWIDespatch + {PC}-SVCDespatcher ; CallASWI,CallASWIR12 re-entry point
d475 1
a475 5
 [ HAL
        BKPT 2
 |
        BEQ     SWIWriteC + SVCDespatcher - SWIDespatch
 ]
d480 1
a480 5
 [ HAL
        BKPT 2
 |
        B       NotMainMOSSwi + SVCDespatcher - SWIDespatch
 ]
d597 1
a597 1
        & NoSuchSWI                     ; OS_AbortTrap
d645 1
a646 1
 ASSERT (.-JTABLE)/4 = MaxSwi
d655 1
a655 1
        B       Local_SLVK
d746 1
a746 1
        MRS     r12, CPSR
d749 4
a752 2
        MSREQ   CPSR_c, #I32_bit+SVC32_mode ; disable interrupts for SPSR use
        MSREQ   SPSR_cxsf, r12
d769 2
a770 2
        MSRNE   CPSR_c, #I32_bit + SVC32_mode
        MSRNE   SPSR_cxsf, lr
d784 1
a784 1
        MSR     CPSR_c, #I32_bit + SVC32_mode  ; ints off while flag updated
d789 1
a789 1
        MSR     CPSR_c, #I32_bit + SVC32_mode
d791 1
a791 1
        MSR     SPSR_cxsf, lr
d815 1
a815 1
        MSR     CPSR_c, #I32_bit + SVC2632      ; ints off while flag updated
d852 1
a852 1
        MSR     CPSR_c, #I32_bit + SVC2632      ; ints off while flag updated
d858 1
a858 1
        MSR     CPSR_c, #I32_bit + SVC2632      ; ints off while flag updated
d863 1
a863 1
        MSREQ   CPSR_c, #SVC2632                ; ensure exit with ints on
d873 1
a873 1
        MSR     CPSR_c, #SVC2632                ; enable ints for long bits
d901 1
a901 1
        MSR     CPSR_c, #SVC2632        ; enable interrupts
d1037 1
a1037 1
        MRS     r10, CPSR
d1195 1
a1195 1
        MRS     r11, CPSR
d1200 1
a1200 1
        MSR     CPSR_cf, r11            ; and set it all up
d1227 1
a1227 1
        MRS     r11, CPSR
d1232 1
a1232 1
        MSR     CPSR_cf, r11            ; and set it all up
d1285 4
a1288 2
        MRS     r0, CPSR
        MSR     CPSR_c, #I32_bit+SVC2632 ; IRQs off (to protect SPSR_svc)
d1290 1
a1290 1
        MSR     SPSR_cxsf, r0            ; Get ready for USR26/32, IRQs on
@


4.12.2.2
log
@More HAL work. IOMD HAL work in progress. Lots of my own little build
scripts. Don't touch this.

Version 5.35, 4.79.2.2. Tagged as 'Kernel-5_35-4_79_2_2'
@
text
@d262 1
a262 1
        =       "OSIm"
d264 1
a272 1
        DCD     RISCOS_MapInIO - RISCOS_Entries
a287 1
        $DoTestThings
d293 2
a295 1
  ]
a354 2

        ASSERT  InitKbdHandler >= EndFiq - MOSROMVecs
@


4.12.2.3
log
@partial video changes for kernel/HAL split
near-HAL code for VIDC/IOMD in vdu.vduhint
briefly tested in Ursula desktop build
still some kernel workspace dependency in near-HAL code

Version 5.35, 4.79.2.3. Tagged as 'Kernel-5_35-4_79_2_3'
@
text
@d676 3
a678 3
        & NoSuchSWI     ; SpecialControl
        & NoSuchSWI     ; EnterUSR32SWI
        & NoSuchSWI     ; EnterUSR26SWI
d681 2
a682 2
 [ STB :LAND: {FALSE}
        & VIDCDividerSWI
d684 1
a684 2
    ! 0, "mjsHAL - VIDCDividerSWI not implemented"
        & NoSuchSWI
@


4.12.2.4
log
@More HAL work. IOMD HAL fleshed out somewhat - system gets most of the way
through initialisation.

Version 5.35, 4.79.2.5. Tagged as 'Kernel-5_35-4_79_2_5'
@
text
@a176 30

a1      RN      0
a2      RN      1
a3      RN      2
a4      RN      3
v1      RN      4
v2      RN      5
v3      RN      6
v4      RN      7
v5      RN      8
v6      RN      9
sb      RN      9
v7      RN      10
v8      RN      11

; Set sb up ready for CallHAL.
        MACRO
        AddressHAL
        LDR     sb, =ZeroPage
        LDR     sb, [sb, #HAL_Workspace]
        MEND

; Calls the HAL. $rout is the routine. sb must have been set up by AddressHAL
        MACRO
        CallHAL $rout
        MOV     lr, pc
        LDR     pc, [sb, #-(EntryNo_$rout+1) * 4]
        MEND


@


4.12.2.5
log
@mjs macros switch on HAL for calling video code in HAL/pseudo HAL cases
vduhint code even more almost ready to move to HAL

Version 5.35, 4.79.2.6. Tagged as 'Kernel-5_35-4_79_2_6'
@
text
@a18 38
; -----------------------------------------------------------------------------
;
; mjs Oct 2000 kernel/HAL split
;
; macros that can be switched between doing real HAL calls and pseudo
; HAL calls with r9-> mjs pseudo HAL workspace
;
; these have been handy for interim HALising of kernel code in-situ
; (particularly used for video stuff), but can probably disappear later
;

  [ HAL

        MACRO
        mjsAddressHAL
        AddressHAL
        MEND

        MACRO
        mjsCallHAL $rout 
        CallHAL $rout
        MEND

  |

        MACRO
        mjsAddressHAL
        LDR     r9, =mjs_tempHALworkspace
        LDR     r9, [r9]                  ; sb -> pseudo HAL workspace
        MEND

        MACRO 
        mjsCallHAL $rout
        BL      $rout
        MEND

  ] ;HAL

@


4.12.2.6
log
@Wahey! This version gives you a display.

It says "Abort on data transfer".
@
text
@d38 1
a38 1
        mjsCallHAL $rout
d50 1
a50 1
        MACRO
a272 1
 [ :LNOT: HAL
a274 1
 ]
d532 3
d536 1
d542 3
d546 1
d578 3
d582 1
d587 3
d591 1
@


4.12.2.7
log
@More L7200 HAL work
@
text
@d232 1
a232 4
        AddressHAL $zero
 [ "$zero" <> ""
        LDR     sb, [$zero, #HAL_Workspace]
 |
a234 1
 ]
d254 1
a254 1
 [ HAL32 :LAND: {FALSE}
d334 1
a334 1
        DCD     OSROM_ImageSize*1024 - 64*1024
a741 4
        & NoSuchSWI
        & NoSuchSWI
        & NoSuchSWI
        & HardwareSWI
@


4.12.2.8
log
@Stuff. A bit of touchscreen, I expect, and probably some other bits too.
@
text
@a247 9
; Checks whether a HAL routine exits. If it does, a1 points to it (probably
; not useful), and Z is clear. lr corrupted.
        MACRO
        CheckHAL $rout
        LDR     a1, [sb, #-(EntryNo_$rout+1) * 4]
        ADRL    lr, NullHALEntry
        TEQ     a1, lr
        MEND

@


4.12.2.9
log
@more use of ARMops in page manipulation, change register usage of ARmops
tested by kernel boot to star prompt only

Version 5.35, 4.79.2.11. Tagged as 'Kernel-5_35-4_79_2_11'
@
text
@a261 3
PageSize          * (4*1024)       ;MMU page size (normal pages)
Log2PageSize      * 12             ;for shifts

@


4.12.2.10
log
@Check-in of the few last-minute changes for the Customer L demo. Nothing
exciting, apart from an extended touchscreen API.

Version 5.35, 4.79.2.13. Tagged as 'Kernel-5_35-4_79_2_13'
@
text
@d773 1
a773 1
        B       SLVK +DirtyBranch-BranchToSWIExit
@


4.12.2.11
log
@First attempt at ARM9 support, and general clean-up of old ARM-specific
code, now using vectored ARMops.
Not tested.

Version 5.35, 4.79.2.14. Tagged as 'Kernel-5_35-4_79_2_14'
@
text
@d1464 1
a1464 1
        LDR     r0,[r0, #ProcessorFlags]
@


4.12.2.12
log
@Customer L-y HAL-y IIC-y type stuff. It's great.
@
text
@a761 1
        & IICOpSWI
@


4.12.2.13
log
@* Fixed the IIC code.
* Kernel puts sensible default FIQ handler in through the HAL.
* Fix to temporary page uncaching code.

Version 5.35, 4.79.2.30. Tagged as 'Kernel-5_35-4_79_2_30'
@
text
@a434 1
EndMOSROMVecs
d436 7
a442 1
        ASSERT  InitKbdHandler >= EndMOSROMVecs - MOSROMVecs
@


4.12.2.14
log
@Reimplement Lazy task swapping, an amusing idea from Ursula,
would have done it sooner but couldn't be bothered (humour).
Currently activates for all ARMs flagged as base-restored
abort model. No handling of eg. StrongARM pre-revT bug, but
then the kernel no longer runs on StrongARM (progress).
Still some details to fix: all aborts in current app space
assumed to be missing pages, but this must be fixed to
handle abort code in app space, things like debuggers
marking code read only.

Plus, small fixes:
  OS_Memory 8 returns vaguely useful info for RAM,VRAM
  in HAL build (temporary partial implementation)
  Broken handling of old BBC commands with (fx,tv etc)
  with no spaces fixed (fudgeulike code from Ursula,
  now 32-bit).

Version 5.35, 4.79.2.31. Tagged as 'Kernel-5_35-4_79_2_31'
@
text
@a462 3
   [ ChocolateAMB
        DCD     0
   |
a464 1
   ]
@


4.12.2.15
log
@* Allows interrupt-driven use of PointerV (as well as polled).
* Allows HAL-driven software resets.
* Sound buffers corrected to be uncacheable.

Version 5.35, 4.79.2.33. Tagged as 'Kernel-5_35-4_79_2_33'
@
text
@d390 1
d392 7
d481 1
a481 1
 [ :LNOT: IncludeTestSrc :LAND: :LNOT: HAL
@


4.12.2.16
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d98 1
d101 3
d702 1
d704 3
d713 1
d715 3
@


4.12.2.17
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@d33 2
a34 2
        mjsAddressHAL $zero
        AddressHAL $zero
a41 8
        MACRO
        DebugTX $str
    [ DebugHALTX
        BL      DebugHALPrint
        =       "$str", 0
        ALIGN
    ]
        MEND
d239 3
a241 3
        CallHAL $rout, $cond
        MOV$cond lr, pc
        LDR$cond pc, [sb, #-(EntryNo_$rout+1) * 4]
d422 1
a422 1
        LDR     pc, MOSROMVecs+InitIRQHandler
d425 1
a425 1
        ASSERT  InitIRQHandler >= EndMOSROMVecs - MOSROMVecs
d574 2
a575 1
        BIC     r11, r11, #Auto_Error_SWI_bit
a602 3
 [ No26bitCode
        & ReadLineSWI
 |
a603 1
 ]
a741 4
        & SLEAVESWI
        & ReadLine32SWI
        & XOS_SubstituteArgs32_code
        & HeapSortRoutine32
d1083 1
d1085 1
a1085 2
        ASSERT  FixR9CorruptionInExtensionSWI
        Push    "lr"
a1086 1
        Push    "r9, lr"                        ; first construct the link to pass on.
a1099 4
 [ No26bitCode
        LDR     lr, [r10, #ModSWINode_Number]
        CMP     lr, r12
 |
a1101 1
 ]
d1109 1
a1109 1
 [ FixR9CorruptionInExtensionSWI:LAND::LNOT:No26bitCode
a1115 3
 [ No26bitCode
        ADRNE   lr, %FT02
 ]
d1120 1
a1120 1
 [ FixR9CorruptionInExtensionSWI:LAND::LNOT:No26bitCode
a1123 3
 [ No26bitCode
        BL      CallVector
 |
a1124 1
 ]
d1134 2
a1135 2
        BIC     lr, lr, #&FF000000      ; Can mangle any/all of punter flags
        AND     r10, r10, #&FF000000
a1391 2
        LTORG

d1445 1
a1445 1
        TST     r0, #CPUFlag_InterruptDelay
@


4.12.2.18
log
@  Mostly device stuff.
Detail:
  * Implemented OS_Hardware 2, 3 and 4 as described in Docs.HAL.NewAPI.
  * Added new OS->HAL and HAL->OS routines to register HAL devices with the
    OS during hard resets.
  * Updated Docs.HAL.NewAPI to correct inconsistencies, fill in missing
    definitions, and allow for interrupt sharing.
  * Now uses OS_LeaveOS to trigger callbacks after ROM module init.
Admin:
  Untested. Requires new HAL.

Version 5.35, 4.79.2.49. Tagged as 'Kernel-5_35-4_79_2_49'
@
text
@d359 4
a362 5
        DCD     RISCOS_InitARM   - RISCOS_Entries
        DCD     RISCOS_AddRAM    - RISCOS_Entries
        DCD     RISCOS_Start     - RISCOS_Entries
        DCD     RISCOS_MapInIO   - RISCOS_Entries
        DCD     RISCOS_AddDevice - RISCOS_Entries
@


4.12.2.19
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@d273 2
a274 3
MEMCADR  * &03600000
        GBLL    ROMatTop
 [ HAL32 :LAND: {TRUE}
a275 1
ROMatTop SETL {TRUE}
d277 1
a277 2
ROM      * &03800000
ROMLimit * &04000000
d440 1
a440 1
        &       Branch0_NoTrampoline
a476 14
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; This is the trampoline in the system heap used to handle branch through 0.

Branch0_Trampoline
        STR     r1, Branch0_Trampoline + Branch0_Trampoline_SavedR1
        STR     lr, Branch0_Trampoline + Branch0_Trampoline_SavedR14
        ADD     lr, pc, #4
        LDR     pc, .+4
        &       Branch0_FromTrampoline
Branch0_Trampoline_Init     * .-Branch0_Trampoline
Branch0_Trampoline_SavedR1  * .-Branch0_Trampoline
Branch0_Trampoline_SavedR14 * .-Branch0_Trampoline+4
Branch0_Trampoline_Size     * .-Branch0_Trampoline+8

d515 1
a515 3
SWIRelocation * SVCDespatcher-SWIDespatch

SLVK_SetV * {PC}-SWIRelocation
d519 1
a519 1
SLVK_TestV * {PC}-SWIRelocation
d524 1
a524 1
SLVK * {PC}-SWIRelocation
d535 1
a535 1
SWIReturnWithCallBackFlag * {PC}-SWIRelocation
d546 1
a546 1
        B       callback_checking + SWIRelocation
d548 1
a548 1
 ! 0,"VSetReturn at ":CC:(:STR:({PC}-SWIRelocation))
d552 1
a552 1
        B       VSet_GenerateError + SWIRelocation
d558 1
a558 1
SVC * {PC}-SWIRelocation
d581 1
a581 1
SVC_CallASWI * {PC}-SWIRelocation       ; CallASWI,CallASWIR12 re-entry point
d588 1
a588 1
        B       NotMainMOSSwi + SWIRelocation
d595 1
a595 1
JTABLE  & SWIWriteC
a892 4
 [ ROMatTop
        CMP     r0, #ROM
        BHS     Do_CallBack
 |
d894 1
a894 3
        RSBHIS  r12, r0, #ROMLimit
        BHI     Do_CallBack
 ]
d1015 1
a1015 1
        Push    lr
a1016 1
 [ ROMatTop
a1028 3
 |
        B       WrchThruVector
 ]
@


4.12.2.20
log
@Support for keys held down in the HAL at power on.
*Configure ANYTHINGsize was broken due to not setting R0 to ReadUnsigned
IIC ack message uninternationalised
OS_Memory was saying we only had 4M of RAM
VDU4 scrolling when output was switched to sprite was causing corruption
on use of CTRL-J and CTRL-K
Default SystemSize CMOS set to 32k

Version 5.35, 4.79.2.55. Tagged as 'Kernel-5_35-4_79_2_55'
@
text
@a366 1
        DCD     RISCOS_LogToPhys - RISCOS_Entries
@


4.12.2.21
log
@  Miscellaneous stuff.
Detail:
  * Merged in the change to RISC OS 4.02 kernel that moved the GSTrans
    workspace out of scratch space.
  * Fixed a few bugs in callback postponement, and interrupt holes in
    callback dispatch. See Docs.CallbackChange for full info.
  * Fixed SystemSizeCMOS to SysHeapCMOS - wouldn't build as was.
  * Added an export of a C version of Hdr:HALDevice, based on the Hdr2H
    translation but with an additional struct definition. Required by
    SoundControl 1.00.
  * Added some additional location and ID allocations to Hdr:HALDevice.
    Required by today's HAL and SoundControl.
Admin:
  Partially tested.

Version 5.35, 4.79.2.56. Tagged as 'Kernel-5_35-4_79_2_56'
@
text
@a549 3
      [ FixCallBacks
        MSR     CPSR_c, #I32_bit + SVC32_mode           ; IRQs off makes CallBackFlag atomic; 32bit so ready for SPSR use
      ]
a559 1
      [ :LNOT: FixCallBacks
a560 1
      ]
a569 4
      [ FixCallBacks
        BNE     callback_checking + SWIRelocation       ; we need to do this for X errors even if the callback flags
                                                        ; are all clear, so that the postpone flag can be set
      |
a570 1
      ]
a817 5
      [ FixCallBacks
        BIC     lr, lr, #&0F
        ORR     lr, lr, #SVC_mode
        MSR     CPSR_c, lr              ; Set caller's interrupt state and 26/32bitness
      ]
a827 3
      [ FixCallBacks
        MSR     CPSR_c, #I32_bit + SVC32_mode   ; IRQs off makes CallBackFlag atomic; 32bit so ready for SPSR use
      ]
a876 1
      [ :LNOT: FixCallBacks
a878 1
      ]
a882 5
      [ FixCallBacks
        MSR     CPSR_c, #I32_bit+SVC32_mode ; disable interrupts for SPSR use and CallBackFlag atomicity
        LDRB    r11, [r10, #CallBack_Flag]
        CMP     r11, #0
      |
a883 1
      ]
a900 1
      [ :LNOT: FixCallBacks             ; already entered with this CPSR
a901 1
      ]
d909 1
a909 1
        TST     lr, #V_bit              ; if no error then do callbacks
d911 2
a912 5
        TST     r11, #CBack_Postpone
      [ FixCallBacks
        TSTNE   r11, #CBack_OldStyle :OR: CBack_VectorReq ; can only postpone if not already or if no callbacks pending
      ]
        BNE     Do_CallBack
d921 1
a921 1
      [ :LNOT: FixCallBacks
a923 1
      ]
a926 1
      [ :LNOT: FixCallBacks                    ; already entered with this CPSR
a927 1
      ]
a934 7
      [ FixCallBacks
        ; Entered in SVC32 mode with IRQs off, r10 = 0
        TST     r11, #CBack_Postpone
        BICNE   r11, r11, #CBack_Postpone
        STRNEB  r11, [r10, #CallBack_Flag]
Do_CallBack_postpone_already_clear
      ]
a939 3
      [ FixCallBacks
        LDRB    r11, [r10, #CallBack_Flag]     ; non-transient callback may have been set during transient callbacks
      ]
d949 2
a950 2
        LDR     r12, =SVCSTK-4*4                ; What SVC_sp should be if system idle
        CMP     sp, r12                         ; Stack empty?
a952 6
      [ FixCallBacks
      [ :LNOT: No26bitCode
        MSR     CPSR_c, #I32_bit + SVC2632      ; back to 26-bit mode
      ]
        BIC     r11, r11, #CBack_OldStyle
      |
a955 1
      ]
a987 4
      [ FixCallBacks :LAND: No26bitCode
        MRS     r0, CPSR
        Push   "r0"
      ]
a1000 4
      [ FixCallBacks
        Pull   "r0", EQ
        MSREQ   CPSR_c, r0                      ; restore original interrupt state and 32bitness
      |
a1001 1
      ]
@


4.12.2.22
log
@* HAL can choose to limit amount of screen memory to allocate
  [Not fully implemented - for now leaves at least 16MB free if only
  one RAM area; was 1MB].
* Added HAL_USBControllerInfo, HAL_MonitorLeadID and HAL_Video_Render.
* Added HAL->OS call OS_IICOpV.
* OS_MMUControl now allows independent control of I and C bits.
* Added facility to deactivate keyboard debounce (magic word "NoKd" in
  R2 in KeyV 0).
* Fixed problem with RAM amounts not a multiple of 4MB.
* Supremacy bit (in VDU 19) now sets all 8 bits of supremacy.
* Added PaletteV 14 (reads gamma tables).
* Added Supremacy transfer functions (like gamma correction, but for
  supremacy). Allows easy global supremacy effects in a mode-independent
  fashion. Controlled with PaletteV 15,16.
* Added modes 50-53 (320x240, 1,2,4,8bpp). Intended for small LCD.
* Added 13.5kHz versions of TV modes (selected by Hdr:Machine).
* Upped desktop version to 5.06.

Version 5.35, 4.79.2.66. Tagged as 'Kernel-5_35-4_79_2_66'
@
text
@d252 1
a252 1
; Checks whether a HAL routine exists. If it does, a1 points to it (probably
a367 1
        DCD     RISCOS_IICOpV    - RISCOS_Entries
@


4.12.2.22.2.1
log
@Update Cortex branch of kernel to support HALSize env variable. Export C version of hdr.OSEntries.
Detail:
  Makefile - Now exports a C version of hdr.OSEntries, for use by the new HAL USB drivers
  s/GetAll, s/Kernel - The HALSize env variable is now used in place of hard-coded values for the HAL size
  s/HAL - Reset_IRQ_Handler now switches to SVC mode before calling HAL_KbdScanInterrupt, to allow the HAL USB drivers to re-enable interrupts if they wish.
  s/VMSAv6 - Deleted some obsolete definitions
Admin:
  Tested on rev C2 BB, A2 BB-xM, C1 TouchBook
  Needs latest BuildSys, Env, HdrSrc


Version 5.35, 4.79.2.98.2.37. Tagged as 'Kernel-5_35-4_79_2_98_2_37'
@
text
@d323 1
a323 1
        ORG     ROM + OSROM_HALSize
d340 1
a340 1
;        ORG     ROM + OSROM_HALSize
d357 1
a357 1
        DCD     OSROM_ImageSize*1024 - OSROM_HALSize
@


4.12.2.22.2.2
log
@Bring Cortex kernel branch in line with HAL branch
Detail:
  Makefile - Now uses ${PERL} for running perl
  s/Kernel - Now uses correct "Bad OS_PlatformFeatures reason code" error number
  s/MemInfo - Updated list of OS_Memory 9 controllers
Admin:
  OMAP3 ROM compiles OK; untested at runtime


Version 5.35, 4.79.2.98.2.43. Tagged as 'Kernel-5_35-4_79_2_98_2_43'
@
text
@a1565 1
        ASSERT  ZeroPage = 0
d1595 1
a1595 1
        ADR     R0, ErrorBlock_BadPlatReas
d1603 8
a1610 1
        MakeErrorBlock BadPlatReas
@


4.12.2.22.2.3
log
@Misc kernel updates
Detail:
  hdr/ARMops - Reserve OS_PlatformFeatures 0 bit 20 for indicating whether high processor vectors are in use
  s/Kernel - Add local definitions of BYTEWS, LDROSB, STROSB, VDWS macros (previously in Hdr:Macros)
  s/MoreComms - Fix potential buffer overflow when filling error buffer (although GSTrans shouldn't overflow the buffer in the first place?)
Admin:
  Tested on rev A2 BB-xM
  Requires HdrSrc 1.86


Version 5.35, 4.79.2.98.2.46. Tagged as 'Kernel-5_35-4_79_2_98_2_46'
@
text
@a91 34
; **************************************
; ***  BYTEWS - Point to OsbyteVars  ***
; **************************************
        MACRO
$label  BYTEWS  $reg
$label  LDR     $reg,=ZeroPage+OsbyteVars
        MEND

; ***************************************
; ***  LDROSB - Load Osbyte variable  ***
; ***************************************
        MACRO
$label  LDROSB  $reg, $var, $cond
$label  LDR$cond $reg, =ZeroPage
        LDR$cond.B $reg, [$reg, #OsbyteVars+$var-OSBYTEFirstVar]
        MEND

; ****************************************
; ***  STROSB - Store Osbyte variable  ***
; ****************************************
        MACRO
$label  STROSB  $reg, $var, $temp, $cond
$label  LDR$cond $temp, =ZeroPage
        STR$cond.B $reg, [$temp, #OsbyteVars+$var-OSBYTEFirstVar]
        MEND

; ****************************************************
; ***  VDWS - Point to our new VduDriverWorkSpace  ***
; ****************************************************
        MACRO
$label  VDWS    $reg
$label  LDR     $reg, =ZeroPage+VduDriverWorkSpace
        MEND

@


4.12.2.22.2.4
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@a583 1
      [ ZeroPage = 0
a584 3
      |
        LDR     r10, SWIRelocationZeroPage
      ]
a618 4
      [ ZeroPage <> 0
SWIRelocationZeroPage
        DCD     ZeroPage
      ]
d877 1
a877 1
        LDR     r10, =ZeroPage          ; set up r10 and r11 as required
d896 1
a896 1
        LDR     r10, =ZeroPage
d1044 2
a1045 1
        LDR     R12, [R10, #CallBf]
d1064 1
a1064 1
        LDR     R12, =ZeroPage+CallAd_ws
d1078 1
a1078 1
        LDR     r10, =ZeroPage
d1087 1
a1087 1
        LDR     r2, =ZeroPage
a1103 1
      [ ZeroPage = 0
a1104 4
      |
        LDR     r1, =ZeroPage
        STR     r10, [r1, #CallBack_Vector] ; Keep head valid
      ]
a1109 1
      [ ZeroPage = 0
a1111 3
      |
        LDR     r1, [r1, #ChocolateBlockArrays]
      ]
a1138 3
      [ ZeroPage <> 0
        LDR     r11, =ZeroPage
      ]
a1209 5
      [ ZeroPage <> 0
        ASSERT ZeroPage = &FFFF0000
        ADD     $swino, $swino, #&FF000000
        ADD     $swino, $swino, #&00FF0000
      ]
a1237 1
      [ ZeroPage = 0
a1238 4
      |
        LDR     lr, =ZeroPage+ModuleSWI_HashTab
        LDR     r10, [r10, lr]
      ]
d1319 1
a1319 1
        LDR     r0, =ZeroPage
d1499 1
a1499 1
        LDR     r1, =ZeroPage
d1501 1
a1501 1
        LDR     r2, =ZeroPage+EnvTime
d1521 1
a1521 1
        LDR     r12, =ZeroPage
d1529 1
a1529 1
        LDR     r0, =ZeroPage
d1573 1
a1573 1
        LDR     r10, =ZeroPage
d1600 1
a1600 3
      [ ZeroPage <> 0
        LDR     r0, =ZeroPage
      ]
@


4.12.2.22.2.4.2.1
log
@  Support for Raspberry Pi / BCM2835
Detail:
  Falls into two main areas: graphics support and ARM11 core support.
  A work in progress - in many cases the code changes need to be replaced
  with an alternative mechanism which will permit the kernel to still function
  on other platforms. Adrian marked these with "!!!" comments - I have added
  ! directives as well so that they don't get forgotten about.
Admin:
  Changes received from Adrian Lees. This revision represents the code largely
  as delivered, and is placed on its own branch (forked off from the version
  from which he worked). It is intended for reference. It doesn't build against
  current headers - this is likely to require a merge with the other changes
  to the kernel since that time.

Version 5.35, 4.79.2.98.2.52.2.1. Tagged as 'Kernel-5_35-4_79_2_98_2_52_2_1'
@
text
@a44 3
        ! 0, "FIXME: temporary code"
;!!!
  STR lr,[sp,#-4]!
a47 1
  LDR lr,[sp],#4
@


4.12.2.23
log
@  "Unknown OS_PlatformFeatures reason code" now has a non-zero error number.
Detail:
  Error number &1F3 allocated.
Admin:
  Requires HdrSrc 1.63.
  Fix supplied by Rob Sprowson.

Version 5.35, 4.79.2.99. Tagged as 'Kernel-5_35-4_79_2_99'
@
text
@a1565 1
        ASSERT  ZeroPage = 0
d1595 1
a1595 1
        ADR     R0, ErrorBlock_BadPlatReas
d1603 8
a1610 1
        MakeErrorBlock BadPlatReas
@


4.12.2.24
log
@Merge over some changes from the Cortex branch
Detail:
  hdr/ARMops - Reserve OS_PlatformFeatures 0 bit 20 for indicating whether high processor vectors are in use
  s/Kernel - Add local definitions of BYTEWS, LDROSB, STROSB, VDWS macros (previously in Hdr:Macros)
  s/MoreComms - Fix potential buffer overflow when filling error buffer (although GSTrans shouldn't overflow the buffer in the first place?)
  s/Arthur2 - GSRead number detection fix
  s/ArthurSWIs - Updated OS_ReadUnsigned to support reading 64bit numbers
  Docs/ReadUnsigned - Docs for the updated OS_ReadUnsigned interface
Admin:
  Untested!
  Needs HdrSrc 1.86


Version 5.35, 4.79.2.120. Tagged as 'Kernel-5_35-4_79_2_120'
@
text
@a91 34
; **************************************
; ***  BYTEWS - Point to OsbyteVars  ***
; **************************************
        MACRO
$label  BYTEWS  $reg
$label  LDR     $reg,=ZeroPage+OsbyteVars
        MEND

; ***************************************
; ***  LDROSB - Load Osbyte variable  ***
; ***************************************
        MACRO
$label  LDROSB  $reg, $var, $cond
$label  LDR$cond $reg, =ZeroPage
        LDR$cond.B $reg, [$reg, #OsbyteVars+$var-OSBYTEFirstVar]
        MEND

; ****************************************
; ***  STROSB - Store Osbyte variable  ***
; ****************************************
        MACRO
$label  STROSB  $reg, $var, $temp, $cond
$label  LDR$cond $temp, =ZeroPage
        STR$cond.B $reg, [$temp, #OsbyteVars+$var-OSBYTEFirstVar]
        MEND

; ****************************************************
; ***  VDWS - Point to our new VduDriverWorkSpace  ***
; ****************************************************
        MACRO
$label  VDWS    $reg
$label  LDR     $reg, =ZeroPage+VduDriverWorkSpace
        MEND

@


4.12.2.25
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d357 1
a357 1
        ORG     ROM + OSROM_HALSize
d374 1
a374 1
;        ORG     ROM + OSROM_HALSize
d391 1
a391 1
        DCD     OSROM_ImageSize*1024 - OSROM_HALSize
a583 1
      [ ZeroPage = 0
a584 3
      |
        LDR     r10, SWIRelocationZeroPage
      ]
a618 4
      [ ZeroPage <> 0
SWIRelocationZeroPage
        DCD     ZeroPage
      ]
d877 1
a877 1
        LDR     r10, =ZeroPage          ; set up r10 and r11 as required
d896 1
a896 1
        LDR     r10, =ZeroPage
d1044 2
a1045 1
        LDR     R12, [R10, #CallBf]
d1064 1
a1064 1
        LDR     R12, =ZeroPage+CallAd_ws
d1078 1
a1078 1
        LDR     r10, =ZeroPage
d1087 1
a1087 1
        LDR     r2, =ZeroPage
a1103 1
      [ ZeroPage = 0
a1104 4
      |
        LDR     r1, =ZeroPage
        STR     r10, [r1, #CallBack_Vector] ; Keep head valid
      ]
a1109 1
      [ ZeroPage = 0
a1111 3
      |
        LDR     r1, [r1, #ChocolateBlockArrays]
      ]
a1138 3
      [ ZeroPage <> 0
        LDR     r11, =ZeroPage
      ]
a1209 5
      [ ZeroPage <> 0
        ASSERT ZeroPage = &FFFF0000
        ADD     $swino, $swino, #&FF000000
        ADD     $swino, $swino, #&00FF0000
      ]
a1237 1
      [ ZeroPage = 0
a1238 4
      |
        LDR     lr, =ZeroPage+ModuleSWI_HashTab
        LDR     r10, [r10, lr]
      ]
d1319 1
a1319 1
        LDR     r0, =ZeroPage
d1499 1
a1499 1
        LDR     r1, =ZeroPage
d1501 1
a1501 1
        LDR     r2, =ZeroPage+EnvTime
d1521 1
a1521 1
        LDR     r12, =ZeroPage
d1529 1
a1529 1
        LDR     r0, =ZeroPage
d1573 1
a1573 1
        LDR     r10, =ZeroPage
d1600 1
a1600 3
      [ ZeroPage <> 0
        LDR     r0, =ZeroPage
      ]
@


4.12.2.26
log
@Conversions rationalisation.
Delete pmf/convdate, moved to conversions.
Moved OS_BinaryToDecimal to conversions.
Remove OS_ConvertHex16 and friends.
Add OS_ConvertVariform skeleton.
Tidied conversions.

Version 5.35, 4.79.2.125. Tagged as 'Kernel-5_35-4_79_2_125'
@
text
@d715 1
a715 1
        & BinaryToDecimal_Code
@


4.12.2.27
log
@Added 'UnConv' error (see also HdrSrc).
Implement OS_ConvertVariform, internally the other conversions now just call it.
Add tester for Variform to 'Dev'.
Made block copy weirdness for XScale dependent on XScale arch flag.

Version 5.35, 4.79.2.126. Tagged as 'Kernel-5_35-4_79_2_126'
@
text
@d1621 1
a1621 1
; SWI OS_PlatformFeatures
@


4.12.2.28
log
@Rationalise some old switches.
Export less in hdr:RISCOS.
Delete unused GetDecimalPair routine.
Move CheckYear with other RTC stuff out of PMF/osword.
Hide DebugROMInit and DebugROMErrors in release (even numbered) versions.

Version 5.35, 4.79.2.127. Tagged as 'Kernel-5_35-4_79_2_127'
@
text
@d69 3
a71 2
        MACRO
$l      CheckSpaceOnStack   $space, $faildest, $tmp
d76 8
a83 1
        MEND
d833 2
a834 2
 ASSERT (.-JTABLE)/4 = NCORESWIS
 ASSERT NCORESWIS < OS_ConvertStandardDateAndTime
@


4.12.2.29
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@d278 2
a279 2
; Checks whether a HAL routine exists. If it does, $ptr points to it, and Z is
; clear. lr corrupted.
d281 1
a281 2
        CheckHAL $rout, $ptr
      [ "$ptr"=""
a284 5
      |
        LDR     $ptr, [sb, #-(EntryNo_$rout+1) * 4]
        ADRL    lr, NullHALEntry
        TEQ     $ptr, lr
      ]
d365 6
d377 2
d382 1
a382 1
        DCD     OSHdrFlag_SupportsCompression
a385 4
        DCD     OSROM_ImageSize*1024 - OSROM_HALSize
        DCD     0
        DCD     EndOfKernel - RISCOS_Header
        ASSERT  (. - RISCOS_Header) = OSHdr_size 
d626 1
a626 1
 [ SupportARMT
d1086 2
a1087 1
        LDR     r2, [r10, #CallBack_Vector]
d1101 1
a1101 1
        LDMIA   r2, {r1, r11, r12}             ; link, addr, r12
d1103 6
a1108 1
        STR     r1, [r10, #CallBack_Vector] ; Keep head valid
d1114 6
a1119 1
        LDR     r1, [r10, #ChocolateBlockArrays]
d1127 1
a1127 1
      [ NoARMv5
a1129 3
      |
        BLX     r11                             ; call im, with given r12
      ]
a1308 1
      [ NoARMT2
a1311 4
      |
        MOV     r10, r10, LSR #24
        BFI     lr, r10, #24, #8        ; Can mangle any/all of punter flags
      ]
a1466 1
      [ NoARMT2
a1470 5
      |
        MOV     r14, r14, LSR #28
        BIC     r11, r11, #I32_bit      ; enable IRQs
        BFI     r11, r14, #28, #4       ; add in caller's CCs
      ]
a1498 1
      [ NoARMT2
a1502 5
      |
        MOV     r14, r14, LSR #28
        BIC     r11, r11, #I32_bit      ; enable IRQs
        BFI     r11, r14, #28, #4       ; add in caller's CCs
      ]
@


4.12.2.30
log
@Fix crashes on ARM6T2+ when OS_Byte/OS_Word are used from IRQ mode
Detail:
  s/Kernel - A bug introduced when adding the BFI optimisations meant that NoIrqVecSwiDespatch was enabling IRQs instead of disabling them, leading to lr_irq corruption and a potential crash if the SWIs were used from IRQ mode
Admin:
  Tested on rev A2 BB-xM
  Having KeyExtend loaded no longer causes random crashes during keyboard input
  Fixes issue reported on forums: http://www.riscosopen.org/forum/forums/4/topics/1024#posts-12004


Version 5.35, 4.79.2.148. Tagged as 'Kernel-5_35-4_79_2_148'
@
text
@d1511 1
a1511 1
        ORR     r11, r11, #I32_bit      ; disable IRQs
@


4.12.2.31
log
@Make Mike's macros permanent.
While the HAL and kernel were being split some temporary macros were used for the bits being worked on, after 12 years of use they're probably safe to adopt.
mjsCallHAL -> CallHAL; mjsAddressHAL -> AddressHAL; mjsHAL -> HAL.
OS_VIDCDividerSWI code now always does NoSuchSWI (had been switched out previously).
File vduhint.s no longer assembled (was empty).


Version 5.35, 4.79.2.150. Tagged as 'Kernel-5_35-4_79_2_150'
@
text
@d19 22
a40 3
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; handy macros:
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d50 18
a806 1
        & NoSuchSWI     ; VIDCDividerSWI
d808 7
@


4.12.2.32
log
@Make OS_Memory 8 return more correct values
The only fake result now is the hard ROM amount, which is hardwired to 4MB and might not be correct.
Unrelated changes
 hdr.HALDevice: Assign a device for VIDC20.
 hdr.KernelWS: Reorder into ascending order, remove legacy addresses.
 s.ARM600: Move PhysSpaceSize inside :LNOT:HAL switch.
 s.Kernel: Move PhysSpaceSize inside :LNOT:HAL switch.

Version 5.35, 4.79.2.153. Tagged as 'Kernel-5_35-4_79_2_153'
@
text
@d285 2
a291 2
PhysSpaceSize * &20000000               ; IOMD physical map is 512M big
PhysROM *       &00000000               ; and real ROM starts at 0
@


4.12.2.33
log
@Sort out SetBorder
NewReset.s:
The one remaining use of SetBorder was to denote the user asked for and got a CMOS reset, which in the HAL case emitted a warning because setting the border is potentially complicated/slow.
To solve this, the reset is noted and replaces the normal RISC OS banner with a warning message. The behaviour and text for this comes from the BBC Master, though the escape key is used in place of break since a reset isn't actually needed.
Moved the unused cputable inside its corresponding switch.
Two occurrences of WriteS_Translated would have executed the message in the V=1 case.
KernelWS/Resources:
Flag added to workspace, translation added to messages files.
Heapman.s:
Commented out use of SetBorder removed.
Kernel.s:
SetBorder macro removed.
Middle.s:
Switched out use of SetBorder removed.
Super1.s:
Conditional WriteS_Translated would try to execute the message in the opposite condition case.


Version 5.35, 4.79.2.157. Tagged as 'Kernel-5_35-4_79_2_157'
@
text
@d87 19
@


4.12.2.34
log
@Merge with RPi branch
Detail:
  Merge the RPi branch with the HAL branch, ending RPi branch development
  Brief summary of changes brought in:
  * Added HAL_VideoStartupMode to allow the HAL to specify a startup mode for the OS
  * Fixed addresses being sent to GraphicsV_SetDMAAddress being wrong for external framestores (addresses were given as if internal framestore was in use)
  * Add InverseTextTransparency option for limited compile-time support for targets where framebuffer alpha channel is important
  * Fix ConfiguredLanguage for non-Tungsten builds
  * Update ARMv6 CPU detection to read cache parameters from cache type register instead of using KnownCPUTable
  * Add HALDebugHexTX/TX2/TX4 debug routines for writing out numbers via HAL
  * Use HAL_TimerIRQClear when clearing timer 0 interrupt instead of just HAL_IRQClear
  * Initialise FileLangCMOS using defines from Hdr:FSNumbers instead of magic numbers. Use SDFS on M_ARM11ZF.
  * Improved software mouse pointer support; software pointer now removed & restored in some of the same places the text cursor is
  * Improve support for external framestores; driver is now able to grow/shrink/move the framestore on mode changes if bit 5 of GraphicsV_DisplayFeatures R0 is set
  * GraphicsV_FramestoreAddress now has a default claimant which calls HAL_VideoFramestoreAddress
Admin:
  Tested on Raspberry Pi, Iyonix, OMAP3, IOMD


Version 5.35, 4.79.2.165. Tagged as 'Kernel-5_35-4_79_2_165'
@
text
@d1407 1
a1407 1
        BIC     r11, r11, #I32_bit      ; enable IRQs   
d1411 1
a1411 1
        BIC     r11, r11, #I32_bit      ; enable IRQs   
@


4.12.2.35
log
@Add OS_NVMemory 6
Permits applications to query what value would be used in the event of a CMOS reset for a given configure value. Notably, the configure plugins will use this in favour of 'ResetCMOS'.
hdr/Options: retire the 'Select16BitSound' switch, add comment for ChecksumCMOS switch
hdr/KernelWS: DuffEntry and Nowhere moved here
Kernel.s: Unused OSMD removed, retire single use of SPIRQ in favour of r13_irq
Middle.s: Retire SPIRQ
NewReset.s: Trim out 300+ lines of CMOS reset defaults, call OS_NVMemory 6 instead
PMF/i2cutils.s: CMOS reset default code and table moved here with refactoring
Note, the previous code preserved YearCMOS during the zeroing, only to unconditionally write it later - so have removed it from the zeroing step.
Note, the locations 80-111 are now considered as system CMOS in the allocations hence are now wiped too (previously they got skipped as user CMOS during R-power-on).

Tested on OMAP3 ROM with delete-power-on and R-power-on variants, and a simple BASIC program to read locations 0-255 via OS_NVMemory.

Version 5.35, 4.79.2.180. Tagged as 'Kernel-5_35-4_79_2_180'
@
text
@d258 1
d283 4
@


4.12.2.36
log
@Fix some exception preveneers going to the wrong place when high processor vectors are enabled
Detail:
  s/Kernel - UndPreVeneer, PAbPreVeneer and AdXPreVeneer all need to take into account the location of ZeroPage. In reality UndPreVeneer is the only one that matters, as the other two aren't really used.
Admin:
  Tested on Raspberry Pi with high processor vectors
  Undefined instructions now generate errors correctly


Version 5.35, 4.79.2.208. Tagged as 'Kernel-5_35-4_79_2_208'
@
text
@d430 1
a430 1
UndPreVeneer    *       ZeroPage+ProcVecPreVeneers+(.-DefaultPreVeneers)
d435 1
a435 1
PAbPreVeneer    *       ZeroPage+ProcVecPreVeneers+(.-DefaultPreVeneers)
d444 1
a444 1
AdXPreVeneer    *       ZeroPage+ProcVecPreVeneers+(.-DefaultPreVeneers)
@


4.12.2.37
log
@  Correction to code to add GraphicsV_PixelFormats call to
  HAL graphics driver calls.  Added further debug capability
Detail:
  Added additional HAL call. minor code correction in hal graphicsv dispatcher
  Added DebugReg macro to aid debugging
Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 5.35, 4.79.2.215. Tagged as 'Kernel-5_35-4_79_2_215'
@
text
@d24 1
a24 1
        DebugReg $reg, $str
a25 2
     Push "$reg"
     [ "$str" <> ""      
a28 11
     ]
     bl  DebugHALPrintReg
    ]
        MEND

        MACRO
        DebugTX $str
    [ DebugHALTX
        BL      DebugHALPrint
        =       "$str", 13,10,00
        ALIGN
@


4.12.2.38
log
@Add OS_Memory 24 implementation. Change OS_ValidateAddress to use it. Fix kernel leaving the physical access MB in a messy state. Try and protect against infinite abort loops caused by bad environment handlers.
Detail:
  s/MemInfo - Added an implementation of ROL's OS_Memory 24 call. Unlike the old OS_ValidateAddress call, this call should successfully report the presence of all memory areas known to the kernel. It should also correctly indicate which parts of a sparse DA are mapped in, unlike the old OS_ValidateAddress implementation.
  s/ChangeDyn - Update dynamic area handling to construct a lookup table for mapping logical addresses to dynamic areas; this is used by OS_Memory 24 to quickly locate which DA(s) hit a given region
  s/AMBControl/main - Make sure lazy task swapping is marked as disabled when AMB_LazyMapIn is {FALSE} - required so that OS_Memory 24 will give application space the correct flags
  s/ArthurSWIs - Switch OS_ValidateAddress over to using OS_Memory 24, as per ROL. For compatibility, Service_ValidateAddress is still issued for any areas which the kernel doesn't recognise (currently, OS_Memory 24 doesn't issue any service calls itself)
  s/Convrsions - ADR -> ADRL to keep things happy
  s/HAL - Fix L2PT page allocation and RAM clear to release the physical access region once they're done with it
  s/Kernel - Make the error dispatcher validate the error handler code ptr & error buffer using OS_Memory 24 before attempting to use them. If they look bad, reset to default. Should prevent getting stuck in an infinite abort loop in some situations (e.g. as was the case with ticket 279). The system might not fully recover, but it's better than a hard crash.
  s/Middle - Rework data/prefetch/etc. abort handlers so that DumpyTheRegisters can validate the exception dump area via OS_Memory 24 before anything gets written to it. Should also help to prevent some infinite abort loops. Strip 26bit/pre-HAL code to make things a bit more readable.
  hdr/KernelWS - Update comment
Admin:
  Tested on BB-xM, Raspberry Pi


Version 5.35, 4.79.2.222. Tagged as 'Kernel-5_35-4_79_2_222'
@
text
@a844 24
        Push    "r0-r2"
        LDR     r1, [r10, #ErrHan]
        ; Check that the error handler points somewhere sensible
        ; Can be ROM or RAM or pretty much anywhere, but must be user-read
        ; Also require it to be word aligned, since we don't really support thumb
        MOV     r0, #24
        ADD     r2, r1, #4
        SWI     XOS_Memory
        TST     r1, #CMA_Completely_UserR
        TSTEQ   r2, #3
        BEQ     %FT05
        LDR     r1, [r10, #ErrBuf]
        MOV     r0, #24
        ADD     r2, r1, #256+4
        ; Must be SVC-writable, user+SVC readable, word aligned
        SWI     XOS_Memory
        AND     r1, r1, #CMA_Completely_UserR+CMA_Completely_PrivR+CMA_Completely_PrivW
        TEQ     r1, #CMA_Completely_UserR+CMA_Completely_PrivR+CMA_Completely_PrivW
        TSTEQ   r2, #3
        BEQ     %FT10
05
        BL      DEFHAN                  ; Restore default error (+escape) handler if the ones we've been given are obviously duff
10
        Pull    "r0-r2"
@


4.12.2.39
log
@Expose more areas via OS_ReadSysInfo 6 & OS_Memory 16. Expose processor vectors base + size via OS_PlatformFeatures.
Detail:
  hdr/KernelWS - Define processor vectors address. Currently same as ZeroPage, but in the future will differ for some machines.
  hdr/OSRSI6, s/Middle - Expose VecPtrTab & NVECTORS via OS_ReadSysInfo items 85 & 86
  s/Kernel - Add OS_PlatformFeatures 32, for returning the base + size of the processor vectors
  s/MemInfo - Add areas 12 thru 15 to OS_Memory 16, for reporting ZeroPage, ProcVecs, DebuggerSpace and ScratchSpace. The task manager can now use these for calculating memory usage instead of assuming 32K workspace from &0-&8000.
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.271. Tagged as 'Kernel-5_35-4_79_2_271'
@
text
@a1594 6
;
;     r0 = reason code:
;          0 -> read code features
;          1 -> read MMU features (ROL, unimplemented here)
;          2-31 -> reserved just in case ROL have used them
;          32 -> read processor vectors location
d1598 1
a1598 3
        CMP     r0, #32                 ;Is it a known reason code?
        BEQ     %FT30
        CMP     r0, #0
a1619 7
30
        ; Return processor vectors base + size
        LDR     r0, =ProcVecs
        MOV     r1, #256                ; Currently only 256 bytes available for FIQ handlers
        Pull    lr
        B       SLVK

@


4.12.2.40
log
@Improve support for VMSAv6 cache policies & memory types. Expose raw ARMops via OS_MMUControl & cache information via OS_PlatformFeatures.
Detail:
  Docs/HAL/ARMop_API - Document two new ARMops: Cache_Examine and IMB_List
  hdr/KernelWS - Shuffle workspace round a bit to allow space for the two new ARMops. IOSystemType now deleted (has been deprecated and fixed at 0 for some time)
  s/ARM600 - Cosmetic changes to BangCam to make it clearer what's going on. Add OS_MMUControl 2 (get ARMop) implementation.
  s/ARMops - Switch out different ARMop implementations and XCB tables depending on MMU model - helps reduce assembler warnings and make it clearer what code paths are and aren't possible. Add implementations of the two new ARMops. Simplify ARM_Analyse_Fancy by removing some tests which we know will have certain results. Use CCSIDR constants in ARMv7 ARMops instead of magic numbers. Update XCB table comments, and add a new table for VMSAv6
  s/ChangeDyn - Define constant for the new NCB 'idempotent' cache policy (VMSAv6 normal, non-cacheable memory)
  s/HAL - Use CCSIDR constants instead of magic numbers. Extend RISCOS_MapInIO to allow the TEX bits to be specified.
  s/Kernel - OS_PlatformFeatures 33 (read cache information) implementation (actually, just calls through to an ARMop)
  s/MemInfo - Modify VMSAv6 OS_Memory 0 cache/uncache implementation to use the XCB table instead of modifying L2_C directly. This allows the cacheability to be changed without affecting the memory type - important for e.g. unaligned accesses to work correctly. Implement cache policy support for OS_Memory 13.
  s/Middle - Remove IOSystemType from OS_ReadSysInfo 6.
  s/VMSAv6 - Make sure BangCam uses the XCB table for working out the attributes of temp-uncacheable pages instead of manipulating L2_C directly. Add OS_MMUControl 2 implementation.
  s/AMBControl/memmap - Update VMSAv6 page table pokeing to use XCB table
  s/PMF/osinit - Remove IOSystemType reference, and switch out some pre-HAL code that was trying to use IOSystemType.
Admin:
  Tested on Iyonix, ARM11, Cortex-A7, -A8, -A9, -A15
  Note that contrary to the comments in the source the default NCB policy currently maps to VMSAv6 Device memory type (as per previous kernel versions). This is just a temporary measure, and it will be switched over to Normal, non-cacheable once appropriate memory barriers have been added to the affected IO code.


Version 5.35, 4.79.2.273. Tagged as 'Kernel-5_35-4_79_2_273'
@
text
@a1600 1
;          33 -> read cache information
a1605 2
        CMP     r0, #33
        BEQ     %FT40
a1634 21
40
        ; Read cache information
        ; In:  r1 = cache level (0-based)
        ; Out: r0 = Flags
        ;           bits 0-2: cache type:
        ;              000 -> none
        ;              001 -> instruction
        ;              010 -> data
        ;              011 -> split
        ;              100 -> unified
        ;              1xx -> reserved
        ;           Other bits: reserved
        ;      r1 = D line length
        ;      r2 = D size
        ;      r3 = I line length
        ;      r4 = I size
        ;      r0-r4 = zero if cache level not present
        ARMop   Cache_Examine
        Pull    lr
        B       SLVK

@


4.12.2.41
log
@Replace WriteBuffer_Drain ARMop with a suite of memory barrier ARMops
Detail:
  - Docs/HAL/ARMop_API - Updated with documentation for the new ARMops.
  - s/ARMops - Set up pointers for the new memory barrier ARMops. Add full implementations for ARMv6 & ARMv7; older architectures should be able to get by with a mix of null ops & write buffer drain ops. Update ARMopPtrTable to validate structure against the list in hdr/OSMisc
  - hdr/KernelWS - Reserve workspace for new ARMops. Free up a bit of space by limiting ourselves to 2 cache levels with ARMv7. Remove some unused definitions.
  - hdr/OSMisc - New header defining OS_PlatformFeatures & OS_MMUControl reason codes, OS_PlatformFeatures 0 flags, and OS_MMUControl 2 ARMop indices
  - Makefile - Add export rules for OSMisc header
  - hdr/ARMops, s/ARM600, s/VMSAv6 - Remove CPUFlag_* and MMUCReason_* definitions. Update OS_MMUControl write buffer drain to use DSB_ReadWrite ARMop (which is what most existing write buffer drain implementations have been renamed to).
  - s/GetAll - Get Hdr:OSMisc
  - s/Kernel - Use OS_PlatformFeatures reason code symbols
  - s/vdu/vdudecl - Remove unused definition
Admin:
  Tested on ARM11, Cortex-A8, Cortex-A9


Version 5.35, 4.79.2.279. Tagged as 'Kernel-5_35-4_79_2_279'
@
text
@d1605 1
a1605 1
        CMP     r0, #OSPlatformFeatures_ReadProcessorVectors ;Is it a known reason code?
d1607 1
a1607 1
        CMP     r0, #OSPlatformFeatures_ReadCacheInfo
d1609 1
a1609 1
        CMP     r0, #OSPlatformFeatures_ReadCodeFeatures
@


4.12.2.42
log
@Add SWI error pointer validation, SeriousErrorV hooks, and OS_ReadSysInfo 15
Detail:
  Resources/UK/Messages, hdr/KernelWS, s/Kernel - On return from a SWI with V set, do some basic validity checks on the error pointer in order to try and catch buggy SWIs that return bad pointers or invalid error blocks. If a bad pointer is found we'll substitute it with a pointer to a different error block, which has the SWI number in the error message, to allow the user to identify the source of the problem. (There's also a chance we'll crash when investigating a bad pointer, but crashing here in the kernel is preferable to crashing elsewhere because R12 should still contain the SWI number)
  hdr/OSMisc - Define SeriousErrorV reason codes and extended ROM footer entry IDs
  hdr/Options - Remove HangWatch integration flag, obsolete now that SeriousErrorV is available
  s/ArthurSWIs - Keep defaultvectab up to date with vector allocations
  s/Middle - Update serious error handling to call SeriousErrorV at several key points. This allows for accurate crash dumps to be obtained, along with a mechanism to warn low-level components such as RTSupport that the privileged mode stacks are being flattened.
  s/Middle - Add OS_ReadSysInfo 15, for enumerating extended ROM footer entries
  s/PMF/osbyte - Update InitNewFX0Error to use the ROM footer entry ID defined in hdr/OSMisc
Admin:
  Tested on Pi 1B, 2B, 3B


Version 5.35, 4.79.2.313. Tagged as 'Kernel-5_35-4_79_2_313'
@
text
@d559 1
a559 11
50
        ; Attempt to detect bad error pointers - both to try and avoid crashing
        ; and to make bad pointers easier to debug
        CMP     r0, #&4000
        BLO     BadErrPtr + SWIRelocation
        TST     r0, #3
        LDREQ   r10, [r0]                               ; If we crash here, R12 will be the SWI number that returned the bad pointer (better than crashing later with no clue what SWI caused the problem)
        TSTEQ   r10, #&7f :SHL: 24                      ; Check reserved bits in error number
        BNE     BadErrPtr + SWIRelocation
BadErrPtrReturn * {PC}-SWIRelocation
        TST     r12, #Auto_Error_SWI_bit
a831 25
; In: r10-r12 stacked
;     r12 = SWI number
;     lr has SPSR for SWI return
BadErrPtr ROUT
        Push    "r1-r4,lr"
        SUB     sp, sp, #12
        MOV     r1, sp
        MOV     r2, #12
        BIC     r0, r12, #Auto_Error_SWI_bit
        SWI     XOS_ConvertHex6         ; SWI argument is 00xxxxxx

        MOV     r4, r0                  ; now strip leading 0s
02      LDRB    r2, [r4], #1
        CMP     r2, #"0"
        BEQ     %BT02

        SUB     r4,r4,#1
        ADR     r0, ErrorBlock_BadErrPtr
        BL      TranslateError_UseR4
        ADD     sp, sp, #12
        Pull    "r1-r4,lr"
        B       BadErrPtrReturn

        MakeErrorBlock BadErrPtr

a929 3
; r0 = SWI error ptr
; r11 = CallBack_Flag
; lr = PSR
a944 1
        LDR     r10, =ZeroPage
d977 1
a977 1
        ; Entered in SVC32 mode with IRQs off, r10 = ZeroPage
@


4.12.2.43
log
@Revise error pointer validity checks
Detail:
  s/Kernel, hdr/KernelWS - Avoid performing error pointer checks for XOS_GenerateError, since (a) it's a no-op as far as errors are concerned, and (b) many programs take advantage of that fact and abuse the SWI for other purposes (triggering callbacks, BASIC string conversion, etc.)
Admin:
  Tested on Raspberry Pi
  Fixes issue reported on forums with Sunfish crashing:
  https://www.riscosopen.org/forum/forums/5/topics/4060


Version 5.35, 4.79.2.314. Tagged as 'Kernel-5_35-4_79_2_314'
@
text
@a559 14
        ; Some programs abuse XOS_GenerateError by using it purely as a method
        ; to trigger callbacks, or to convert null terminated strings to BASIC
        ; strings. This means the R0 value might be complete garbage, and if we
        ; were to try checking it then bad things would happen.
        ; Luckily XOS_GenerateError is essentially a no-op as far as errors are
        ; concerned, so we can avoid crashing here (or corrupting the caller's
        ; R0 value) by simply ignoring the call.
        EOR     r10, r12, #Auto_Error_SWI_bit
        TEQ     r10, #OS_GenerateError
      [ FixCallBacks
        BEQ     callback_checking + SWIRelocation       ; it's an X SWI, so jump straight to callback checks
      |
        BEQ     %BT40
      ]
@


4.12.2.44
log
@Relax error pointer validity checks some more
Detail:
  s/Kernel - Some types of error lookup code work by passing a bogus error number into MessageTrans_ErrorLookup and then fixing it up afterwards. To avoid breaking such code, we'll now ignore any bad error numbers from XMessageTrans_ErrorLookup. However obviously bad pointers and the non-X form will still be caught.
Admin:
  Tested on Raspberry Pi 3
  (e.g.) SWI "XMessageTrans_Lookup","@@@@@@@@BadParm" now works


Version 5.35, 4.79.2.315. Tagged as 'Kernel-5_35-4_79_2_315'
@
text
@d581 1
a581 1
        BNE     BadErrPtr2 + SWIRelocation
a855 20
BadErrPtr2
        ; Some types of error lookup code work by passing a bogus error number
        ; into MessageTrans_ErrorLookup and then fixing it up afterwards. To
        ; avoid breaking such code, and to maintain compatibility with
        ; "legitimate" [1] uses of this approach, we'll ignore any bad error
        ; numbers from XMessageTrans_ErrorLookup. Non-X form will still be
        ; caught, since there's no way the caller can expect to fix up the
        ; error number.
        ;
        ; [1] - PortMan has a reserved bit set in its error numbers so that it
        ; knows it needs to translate them; after translation the bit is
        ; cleared. This does assume that the code in PortMan will never see a
        ; translated error that has that reserved bit set - so is perhaps not
        ; entirely kosher (although the kernel now requires reserved bits to be
        ; clear too) - but it does avoid a redundant copy of the error token to
        ; the stack.
        TST     r0, #3                  ; Repeat pointer validity check; if this is OK we know we've arrived here because of a bad error number
        LDREQ   r10, =XMessageTrans_ErrorLookup
        TEQEQ   r10, r12
        BEQ     BadErrPtrReturn
@


4.12.2.45
log
@Correction to comment - it's NVRAM, not PortMan

Version 5.35, 4.79.2.316. Tagged as 'Kernel-5_35-4_79_2_316'
@
text
@d865 2
a866 2
        ; [1] - The NVRAM module has a reserved bit set in its error numbers so
        ; that it knows it needs to translate them; after translation the bit is
@


4.12.2.46
log
@Add new OS_PlatformFeatures reason code for reading CPU features (inspired by ARMv6+ CPUID scheme). Add OS_ReadSysInfo 8 flags for indicating the alignment mode the ROM was built with. Fix long-standing bug with OS_PlatformFeatures when an unknown reason code is used.
Detail:
  s/CPUFeatures, hdr/OSMisc, hdr/KernelWS - Code and definitions for reading CPU features and reporting them via OS_PlatformFeatures 34. All the instruction set features which are exposed by the CPUID scheme and which are relevant to RISC OS are exposed, along with a few extra flags which we derive ourselves (e.g. things relating to < ARMv4, and some register usage restrictions in instructions). s/CPUFeatures is designed to be easily copyable into a future version of CallASWI without requiring any changes.
  s/ARMops - Read and cache CPU features during ARMop initialisation
  s/GetAll - GET new file
  s/Kernel - Hook up the CPU features code to OS_PlatformFeatures. Fix a long standing stack imbalance bug (fixed in RISC OS 3.8, but never merged back to our main branch) which meant that calling OS_PlatformFeatures with an invalid reason code would raise an error, even if it was the X form of the SWI that was called. Similar fix also applied to the unused service call code, along with a fix for the user's R1-R9 being corrupt (shuffled up one place) should an error have been generated.
  s/MemInfo - Extra LTORG needed to keep things happy
  s/Middle - Extend OS_ReadSysInfo 8 to include flags for indicating what memory alignment mode (if any) the OS relies upon. Together with OS_PlatformFeatures 34 this could e.g. be used by !CPUSetup to determine which options should be offered to the user.
Admin:
  Tested on Raspberry Pi 1, 2, 3


Version 5.35, 4.79.2.319. Tagged as 'Kernel-5_35-4_79_2_319'
@
text
@a1674 1
;          34 -> read CPU features
a1681 2
        CMP     r0, #OSPlatformFeatures_ReadCPUFeatures
        BEQ     PlatFeatSWI_ReadCPUFeatures
d1739 1
a1741 2
        BNE     %FT75
        Pull    lr
d1748 1
d1750 1
a1751 1
        Pull    lr
@


4.12.2.47
log
@Clear the exclusive monitor when returning to pre-empted code
Detail:
  s/Kernel - Add macro for CLREX, which uses a dummy STREX on basic ARMv6 machines. Clear the exclusive monitor after issuing transient callbacks, to cope with callbacks being triggered on exit from IRQ
  s/ArthurSWIs, s/HAL, s/NewIRQs - Clear the exclusive monitor on exit from IRQ handlers & default FIQ handler
  s/VMSAv6 - Clear the exclusive monitor on entry to the data abort pre-veneer
Admin:
  Tested on Raspberry Pi
  Non-transient callback handlers, custom abort handlers, FIQ handlers, and anything else which returns directly to interrupted user code is responsible for issuing its own CLREX if the code has done something that could have left the local monitor in the exclusive state (e.g. calling a SWI counts towards this, as there's no guarantee the monitor will be open on exit from the SWI)


Version 5.35, 4.79.2.327. Tagged as 'Kernel-5_35-4_79_2_327'
@
text
@a93 20
; *******************************************************************
; ***  MyCLREX - Manually clear exclusive monitor                 ***
; ***  Consult the ARM ARM for details of when this is required!  ***
; *******************************************************************
        MACRO
        MyCLREX $temp1, $temp2
      [ NoARMv6
        ASSERT  :LNOT: SupportARMv6
        ; No action required
      ELIF NoARMK
        ; ARMv6, need dummy STREX
        ; Use the word below SP
        SUB     $temp1, r13, #4
        STREX   $temp2, $temp1, [$temp1]
      |
        ; ARMv6K+, have CLREX
        CLREX
      ]
        MEND

a1060 3
        ASSERT  FixCallBacks                   ; (clobbering r11)
        MyCLREX r11, r12                       ; CLREX required for the case where transient callbacks have been triggered on exit from IRQ handling

@


4.12.2.29.2.1
log
@  Merge of Raspberry Pi support code against latest kernel
Detail:
  This is a new branch from the current tip of the HAL branch, incorporating
  the changes received from Adrian Lees. The same caveats apply - this is a
  work in progress and will not work on any other platform at present.
Admin:
  Builds, but not tested.

Version 5.35, 4.79.2.147.2.1. Tagged as 'Kernel-5_35-4_79_2_147_2_1'
@
text
@a44 3
        ! 0, "FIXME: temporary code"
;!!!
  STR lr,[sp,#-4]!
a47 1
  LDR lr,[sp],#4
@


4.12.2.29.2.2
log
@  Merged across the bugfix from the HAL branch, revision Kernel-5_35-4_79_2_148

Version 5.35, 4.79.2.147.2.4. Tagged as 'Kernel-5_35-4_79_2_147_2_4'
@
text
@d1515 1
a1515 1
        ORR     r11, r11, #I32_bit      ; disable IRQs
@


4.12.2.29.2.3
log
@  Changes to resolve some of the BCM2835 initial hacks
  1: Added HAL_FramebufferAddress entry.
  2: Minor mod the NoIrqVecSwiDispatch mods recently submitted. Improved coverage
  3: Added compile time switch InverseTextTransparency to toggle sense of text
  (pre-wimp) for use until correct transparency behaviour is introduced in the RPi
  start.elf.
  4: Ensured that if a non aligned frame buffer is reported, ALL of the space
  is actually mapped in.
Detail:
  (list files and functions that have changed)
Admin:
  builds and runs .. Still needs service_mode extension work to replace hard
  coded mode definition files
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 5.35, 4.79.2.147.2.5. Tagged as 'Kernel-5_35-4_79_2_147_2_5'
@
text
@a41 28

        MACRO
        DebugTXHex
        ! 0, "FIXME: jb temporary code"
;!!!
  STR lr,[sp,#-4]!
        BL      HALDebugHexTX
  LDR lr,[sp],#4
        MEND
        
        MACRO
        DebugTXHex4
        ! 0, "FIXME: temporary code"
;!!!
  STR lr,[sp,#-4]!
        BL      HALDebugHexTX4
  LDR lr,[sp],#4
        MEND
        
        MACRO
        DebugTXHex2
        ! 0, "FIXME: temporary code"
;!!!
  STR lr,[sp,#-4]!
        BL      HALDebugHexTX2
  LDR lr,[sp],#4
        MEND

d1473 1
a1473 1
        ORR     r11, r11, #I32_bit      ; disable IRQs   (cf J Lee mod)
d1477 1
a1477 1
        ORR     r11, r11, #I32_bit      ; disable IRQs   (cf J Lee mod)
@


4.12.2.29.2.4
log
@   reverse of mis-understood mod at VecSWIDespatch. mod only relevant at NoIRQ version
Detail:
  (list files and functions that have changed)
Admin:
  (highlight level of testing that has taken place)
  (bugfix number if appropriate)


Version 5.35, 4.79.2.147.2.6. Tagged as 'Kernel-5_35-4_79_2_147_2_6'
@
text
@d1501 1
a1501 1
        BIC     r11, r11, #I32_bit      ; enable IRQs   
d1505 1
a1505 1
        BIC     r11, r11, #I32_bit      ; enable IRQs   
@


4.12.2.29.2.5
log
@  Merged OS_Memory 8 changes across from HAL branch to RPi branch
Detail:
  Revisions Kernel-5_35-4_79_2_153 and Kernel-5_35-4_79_2_161 merged with one
  trivial conflict.
Admin:
  Confirmed that this builds, but not tested on hardware.

Version 5.35, 4.79.2.147.2.15. Tagged as 'Kernel-5_35-4_79_2_147_2_15'
@
text
@d354 2
a360 2
PhysSpaceSize * &20000000               ; IOMD physical map is 512M big
PhysROM *       &00000000               ; and real ROM starts at 0
@


4.12.2.29.2.6
log
@Preperation for working Raspberry Pi video driver
Detail:
  hdr/HALEntries - Add new HAL_Video_StartupMode HAL entry to allow the HAL to specify a startup mode
  s/HAL, s/Kernel - Tweaked debug routines
  s/vdu/vdudriver - Make use of HAL_Video_StartupMode in InitialiseMode to decide what initial mode should be. Clean up some hacks & debug. Improve handling of external framestores; if bit 5 of GraphicsV_DisplayFeatures r0 is set, the kernel will now allow the display driver to grow/shrink/move its framestore in response to mode changes.
  s/vdu/vdugrafv - Adjust default GV_FramestoreAddress implementation to only claim vector if HAL returns a framestore
  s/vdu/vduswis - Re-enable FindOKMode
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.18. Tagged as 'Kernel-5_35-4_79_2_147_2_18'
@
text
@d44 1
a44 1
        DebugTXHex $reg
d47 1
a47 2
  stmfd sp!,{a1,lr}
        mov     a1, $reg
d49 1
a49 1
  ldmfd sp!,{a1,lr}
d53 1
a53 1
        DebugTXHex4 $reg
d56 1
a56 2
  stmfd sp!,{a1,lr}
        mov     a1, $reg
d58 1
a58 1
  ldmfd sp!,{a1,lr}
d62 1
a62 1
        DebugTXHex2 $reg
d65 1
a65 2
  stmfd sp!,{a1,lr}
        mov     a1, $reg
d67 1
a67 1
  ldmfd sp!,{a1,lr}
@


4.12.2.29.2.7
log
@Clean up remaining kernel hacks
Detail:
  Docs/RPiNotes - Deleted, contents no longer relevant
  s/HAL, s/Kernel, s/vdu/vduswis, s/pmf/key - Cleaned up debug code
  s/NewIRQs - No need to piggy back on timer 0 IRQ to generate a fake VSync; PushModeInfo already claims/releases TickerV as appropriate if video driver doesn't provide a VSync IRQ.
  s/NewReset - Re-enable LookForHALRTC call, the stack imbalance bug was fixed before the Pi changes were merged in
  s/vdu/vducursoft - Streamline PostWrchCursor a bit by only preserving R14 around RestorePointer if the software pointer is in use
  s/vdu/vdudriver - Amend ModeChangeSub improvements to ensure old external framestore handling logic is used if driver doesn't support framestore growth/realloc
Admin:
  Tested on Raspberry Pi with high processor vectors
  Kernel now looks to be in a good state for merging back into HAL branch
  Note - Software mouse pointer support in vducursoft only checks HALVideoFeatures, so doesn't take into account the capabilities of any GraphicsV driver that may be in use.


Version 5.35, 4.79.2.147.2.20. Tagged as 'Kernel-5_35-4_79_2_147_2_20'
@
text
@d42 31
d76 3
d82 1
@


4.12.2.29.2.8
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d19 22
a40 3
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; handy macros:
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d50 18
d124 19
a806 1
        & NoSuchSWI     ; VIDCDividerSWI
d808 7
@


4.11
log
@Had one of those weekend brainstorms - managed to speed up SWI despatcher
_and_ add Thumb support to it.
Fixed OS_BreakPt - was confused by PC/PSR split.

Version 5.24. Not tagged
@
text
@a465 5
SVC_CallASWI * {PC}-SWIRelocation       ; CallASWI,CallASWIR12 re-entry point

        BICS    r11, r11, #Auto_Error_SWI_bit
        BEQ     SWIWriteC + SWIRelocation

d472 5
a897 1
;       r12 = SPSR
a902 1
        BIC     lr, r12, #V_bit         ; clear caller's V cos we didn't before
@


4.10
log
@* Run-time emulator detection added (no need for separate images). Needs an
  RPCEm update.
* Register allocation in default ErrorV handler fixed - problems occured when
  callbacks were triggered on way out.
* OS_Byte 19 didn't manipulate interrupt disable flag correctly in 26-bit
  builds.
* Stray bit of debugging left in sprite code many years ago removed.

Version 5.23. Not tagged
@
text
@d75 1
a75 1
; Fake a 26-bit pc, given a PSR currently in lr, and the 32-bit address on
d79 2
a80 1
        FakeLR  $temp, $dontpull
d82 3
d401 1
d419 4
a422 1
        LDR     r11, [sp], #4
d424 14
a437 1
        BEQ     %FT40
d440 2
a441 2
        TST     r11, #Auto_Error_SWI_bit
        BEQ     VSet_GenerateError + SWIRelocation
d443 1
a443 2
SWIReturn * {PC}-SWIRelocation
 ! 0,"SWIReturn  at ":CC:(:STR:SWIReturn)
a444 14
40      MOV     r10, #0
        LDRB    r11, [r10, #CallBack_Flag]
        CMP     r11, #0
        BNE     callback_checking + SWIRelocation

SWIReturnNoCallback * {PC}-SWIRelocation
 ! 0,"SWIReturnNoCallback at ":CC:(:STR:SWIReturnNoCallback)
back_to_user * SWIReturnNoCallback
        msr AL, CPSR_c, #I32_bit + SVC32_mode           ; IRQs off for SPSR use
back_to_user_irqs_already_off * {PC}-SWIRelocation
        msr     AL, SPSR_cxsf, lr
        LDR     lr, [sp], #4
        Pull    "r10-r12"
        MOVS    pc, lr
d452 14
a465 9
        LDR     r11, [r14, #-4]         ; r11 = calling instruction
        STR     r14, [r13, #-4]!        ; push return address
        mrs     AL, r14, SPSR           ; r14 = saved PSR

SVCContinue * {PC}-SWIRelocation

        BIC     r11, r11, #&FF000000
        STR     r11, [r13, #-4]!        ; push SWI number
        [ StrongARM
a466 1
        ]
d471 1
a471 1
        AND     r10, r14, #I32_bit+F32_bit
d473 1
a473 1
        msr     AL, CPSR_c, r10         ; restore caller's IRQ state
d475 1
a475 3
        CMP     r11, #OS_BreakPt
        CMPNE   r11, #OS_CallAVector
        BICNE   r14, r14, #V_bit        ; clear V unless BreakPoint/CallVector
d692 4
a695 1
        B       SWIReturn
d769 3
a771 1
 [ {FALSE} ; original code
a773 3
 |
        BNE     SWIReturnNoCallback     ; hey, it'll be in the cache (probably)
 ]
d788 7
a794 1
        B       back_to_user_irqs_already_off
d898 1
d904 2
a905 2
        BIC     lr, lr, #V_bit          ; clear caller's V cos we didn't before
        Push    lr
@


4.9
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d698 2
a699 2
        MOV     r12, #0
        LDR     r11, [r12, #ErrBuf]     ; Get pointer to error buffer
d708 1
a708 1
        FakeLR  r10                     ; Fake up the PC+PSR
d716 1
a716 1
        MOV     r10, #256-4
d719 1
a719 1
        SUBS    r10, r10, #1
d725 1
a725 1
        LDR     r14, [r12, #ErrHan]     ; And go to error handler
d729 2
a730 2
        STR     r14, [r12, #Curr_Active_Object]
        LDR     r0,  [r12, #ErrHan_ws]  ; r0 is his wp
d732 2
a733 2
        LDRB    r10, [r12, #CallBack_Flag]
        CMP     r10, #0
d735 2
a736 2
        mrs    ,r10, CPSR
        BIC     r10, r10, #I32_bit+F32_bit+&0F  ; USR26/32 mode, ARM, IRQs enabled
d741 1
a741 1
        msr     EQ, SPSR_cxsf, r10
d747 1
a747 1
        MOV     r14, r10                ; Put PSR in R14
@


4.8
log
@Ursula ChocolateSysHeap and 128-entry SWI hash table incorporated.

Version 4.83. Tagged as 'Kernel-4_83'
@
text
@d75 31
a196 1
 [ MEMC_Type = "IOMD"
d206 1
a206 1
PhysExtROM *	&01000000		; 2nd ROM bank starts at 16M
a210 6
 |
VideoPhysRam *  &02000000
PhysSpaceSize * &04000000               ; MEMC1 physical map is 64M big
PhysROM *       &03800000
PhysRamPhys *   &02000000               ; physical space starts here
 ]
a228 6
 [ :LNOT: ModeSelectors
ScreenModeSWI * NoSuchSWI
 ]
 [ :LNOT: NewCDA
DynamicAreaSWI * NoSuchSWI
 ]
a266 1
 [ ProcessorVectors
d307 3
a309 3
; OS_ClaimProcessorVector.  IRQs are initially handled by a branch so that the
; keyboard can be handled during reset but the branch is replaced with a load
; PC, PC relative later on.
d318 1
a318 1
        B       MOSROMVecs+IRQ_Test_CTRL_or_R_Pressed
d347 1
a347 1
  [ CPU_Type <> "ARM600"
d352 2
a353 3
DAbPreVeneer    *       ProcVecPreVeneers+(.-DefaultPreVeneers)
        LDR     PC, DefaultPreVeneers-ProcVecPreVeneers+DAbHan
  |
d357 1
a357 1
  ]
a362 41
 |

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; The bit to copy to 0
; - if no test software present, then it's at the start of the ROM and will get
; executed out of ROM, or from the RAM copy later on
; - if test software is present, then it's not at the start of the ROM, so the
; code will only work when copied to 0!

MOSROMVecs
  [ ResetIndirected
        LDR     pc, MOSROMVecs+ResetIndirection ; load PC, PC relative
  |
   [ MEMC_Type = "IOMD"
        B       CONT                            ; PhysROM is at zero on IOMD
   |
        B       MOSROMVecs+CONT                 ; executed out of ROM or RAM
                                                ; or not at all if test software present
   ]
  ]

  [ CPU_Type = "ARM600"
        B       MOSROMVecs+UndPreVeneer
        B       MOSROMVecs+SVC
        B       MOSROMVecs+PAbPreVeneer
        B       MOSROMVecs+DAbPreVeneer
  |
        LDR     PC, MOSROMVecs+UndHan
        B       MOSROMVecs+SVC
        LDR     PC, MOSROMVecs+PAbHan
        LDR     PC, MOSROMVecs+DAbHan
  ]
        LDR     PC, MOSROMVecs+AdXHan
        B       MOSROMVecs+IRQ_Test_CTRL_or_R_Pressed
        MOV     R10, #IOC               ; we dunno what to do with it -
                                        ; so cut it off - right off!
        STRB    R10, [R10, #IOCFIQMSK]  ; :LSB: IOC = 0
        SUBS    PC, R14, #4
EndFiq

 ]
d414 1
a414 1
        Pull    r11
d416 5
a420 1
        BNE     %FT50
d428 1
a428 5
        Pull    "r10-r12", EQ
        MOVEQS  pc, lr

        B       callback_checking + SWIRelocation

d430 9
a438 5
 ! 0,"VSetReturn at ":CC:(:STR:({PC}-SWIRelocation))
50      TST     r11, #Auto_Error_SWI_bit
        BNE     %BT40

        B       VSet_GenerateError + SWIRelocation
d445 4
a448 5
 [ CPU_Type = "ARM600"

; For now, branch back up to ROM to perform ARM600 contortions

        B       SVCARM600 + SWIRelocation
a451 6
 |
        Push    "r10-r12"
 ]

        BIC     r12, r14, #ARM_CC_Mask
        LDR     r11, [r12, #-4]
d453 1
a453 1
        Push    r11
d461 3
a463 2
        ORR     r10, r14, #SVC_mode
        TEQP    r10, #0                 ; restore caller's IRQ state
d470 1
a470 1
        LDRCC   pc, [pc, r11, LSL #2]
d656 1
a656 1
        LDR     r11, [sp, #4]        ;pick-up target SWI code (r10 pushed by dispatcher)
d663 1
a663 1
        LDR     r11, [sp, #12]       ;pick-up target SWI code (r12 pushed by dispatcher)
a668 24
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 [ CPU_Type = "ARM600"

; in: SVC32_mode
; For now, only allow SWIs to be executed from below 64M

        ALIGN   32   ;for efficient cache alignment

SVCARM600 ROUT
        Push    "r10-r12"               ; instruction normally done in SWI despatch area
        mrs     AL, r11, SPSR_all                       ; r11 = saved PSR
        AND     r12, r11, #&F0000003                    ; get saved NZCV and 26 bit modes
        ORR     lr, lr, r12
        AND     r12, r11, #I32_bit + F32_bit            ; extract I and F from new place
        ORR     lr, lr, r12, LSL #IF32_26Shift          ; lr = combined lr and psr

        SetMode SVC26_mode, r12                         ; now switch into SVC26

        B       SVCContinue             ; go back into the SWI despatch area

  ! 0, "SVCARM600 (for SWIdespatch) at ":CC::STR:(SVCARM600)

 ]
d671 1
a671 1
; In    r10-r12 stacked, lr has bits for return
d701 1
d703 1
a703 2
                                        ; Note gives WRONG pc if error
        Pull    r14                     ; generated by any but bottom SWI
d705 6
d726 1
d728 1
d735 8
d746 3
a748 1
        B       Do_CallBack             ; Can't need postponement, r0,r14
d757 2
a758 1
        TST     lr, #SVC_mode :OR: I_bit ; user mode, ints enabled?
d761 3
d771 1
a771 1
        CMP     r0, #32*1024*1024
d774 1
a774 1
        TEQP    PC, #SVC_mode+I_bit            ; ints off while flag updated
d778 1
a778 3
back_to_user
        Pull   "r10-r12"
        MOVS    PC, lr
d782 1
a782 1
        Push    lr, NE
d784 1
a784 1
        Pull    lr, NE
d788 4
d793 1
a793 1
; Check that SVC_sp is empty (apart from r10-r12), i.e. system truly is idle
d795 1
a795 1
        LDR     r11, =SVCSTK-3*4                ; What SVC_sp should be if system idle
d799 1
a799 1
        TEQP    PC, #SVC_mode+I_bit             ; ints off while flag updated
d806 3
a809 7
        MOV     r14, r12
        Pull   "r10-r12"
  [ SASTMhatbroken
        STMIA   r14!,{r0-r12}
        STMIA   r14,{r13,r14}^                ; user registers
        NOP
        SUB     r14,r14,#13*4
d811 2
a812 1
        STMIA   r14, {r0-r14}^                ; user registers
a813 53

        MOV     R12, #CallAd_ws
        LDMIA   R12, {R12, PC}                ; jump to CallBackHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Ursula:
; this is only used by the interrupt handler, to allow callbacks when
; foreground is 32-bit user, rather than 26-bit user
;
; currently only supports transient callbacks - traditional callback handler
; cannot be called because it contains its own 32-bit unaware return sequence
;

back_to_user32
        mrs    AL, r10, CPSR_all
        ORR    r10, r10, #I32_bit :OR: SVC32_mode ;move up to SVC32 from SVC26, interrupts off
        msr    AL, CPSR_all, r10
        Pull   "r10"
        msr    AL, SPSR_all, r10                  ;PSR for return, stacked by interrupt handler
        Pull   "r10-r12"
        MOVS    PC, lr                            ;return to address in lr, restoring CPSR from SPSR

Do_CallBack32                                  ; CallBack allowed:
        TST     r11, #CBack_VectorReq          ; now process any vector entries
        Push    lr, NE
        BLNE    process_callback_chain
        Pull    lr, NE

  [ {TRUE}   ;currently can't allow call to Callback handler

        B       back_to_user32

  |
        ;this won't work with traditional callback handler (which has its own
        ;return code that won't return successfully to 32-bit user mode)

        TST     r11, #CBack_OldStyle
        BEQ     back_to_user32

; Check that SVC_sp is empty (apart from r10-r12), i.e. system truly is idle
        LDR     r11, =SVCSTK-3*4                ; What SVC_sp should be if system idle
        CMP     sp, r11                         ; Stack empty?
        BLO     back_to_user32                  ; No then no call back

        TEQP    PC, #SVC_mode+I_bit             ; ints off while flag updated
        LDRB    r11, [r10, #CallBack_Flag]
        BIC     r11, r11, #CBack_Postpone+CBack_OldStyle
        STRB    r11, [r10, #CallBack_Flag]

        MOV     r12, #0
        LDR     R12, [R12, #CallBf]
        STR     r14, [r12, #4*15]             ; user PC
d819 1
a819 2
        NOP
        SUB     r14,r14,#13*4
a826 2
  ]

d836 1
a836 1
        TEQP    PC, #SVC_mode+I_bit             ; ints off while flag updated
d841 2
a842 1
01      TEQP    PC, #SVC_mode+I_bit             ; ints off while head updated
d846 4
d851 1
d857 1
a857 1
        TEQP    PC, #SVC_mode                   ; enable ints for long bits
d885 1
a885 1
        TEQP    pc, #SVC_mode           ; enable interrupts
d972 7
a978 2
        Push    "r9, lr"                ; first construct the link to pass on.
        AND     r10, lr, #&FC000000     ; copy in user CCodes (inc. IRQ state)
d981 1
a983 1
;        BIC     r12, r12, #Auto_Error_SWI_bit  ; r11 already has this bit knocked off
d1013 1
a1013 1
        B       CallVector      ; lr still has user CCs & points at%FT02
d1022 4
a1025 3
        BIC     lr, lr, #&F0000000      ; Can mangle any/all of punter flags
        MOV     r10, pc, LSR #(32-4)
        ORR     lr, lr, r10, LSL #(32-4)
d1050 1
d1058 6
d1065 1
a1067 1

d1087 4
d1092 1
d1130 4
d1135 1
a1145 1
 [ {FALSE}      ; Kernel now divorced from FileSwitch
a1146 29
        LDR     r12, =VecPtrTab
        LDR     r10, [r12, r11, LSL #2] ; Load top node pointer for vector
        CMP     r10, #ROM
        BCC     BGetThruVector

; Cache technology deemed to be ok (ensures consistent with ROM FileSwitch)

        LDMIB   r10, {wp}                       ; Get wp from vector node

 ASSERT :INDEX: BGet_shiftedbase = 0
 ASSERT :INDEX: BGet_bufferdata = 4
 ASSERT :INDEX: BGet_scb        = 8
 ASSERT :INDEX: BGet_shift      = 12
 ASSERT :INDEX: BGet_handle     = 16
        LDMIA   wp, {r0, r10, r11, r12, r14}    ; Get cached data
        TEQ     r14, r1                         ; BGet on cached handle ?
        LDREQ   r14, [r11, #:INDEX: scb_fileptr] ; Check fileptr in that buffer
        TEQEQ   r0, r14, LSR r12
        LDREQB  r0, [r10, r14]                  ; Get byte from buffer
        ADDEQ   r14, r14, #1
        STREQ   r14, [r11, #:INDEX: scb_fileptr] ; Increment fileptr
        Pull    lr, EQ                          ; Punter lr has VClear
        BICEQ   lr, lr, #C_bit                  ; CClear -> ~EOF
        BEQ     SLVK

BGetThruVector
 |
        Push    lr
 ]
a1157 32
 [ {FALSE}      ; Kernel now divorced from FileSwitch
        Push    "r9, lr"                ; Needs one other temp register
        LDR     r12, =VecPtrTab
        LDR     r10, [r12, r11, LSL #2] ; Load top node pointer for vector
        CMP     r10, #ROM
        BCC     BPutThruVector

; Cache technology deemed to be ok (ensures consistent with ROM FileSwitch)

        LDMIB   r10, {wp}                       ; Get wp from vector node
                                                ; NB. This is not normal wp
;       BPut_shiftedbase                        ; r9
 ASSERT BPut_bufferdata = BPut_shiftedbase + 4  ; r10
 ASSERT BPut_scb        = BPut_shiftedbase + 8  ; r11
 ASSERT BPut_shift      = BPut_shiftedbase + 12 ; r12
 ASSERT BPut_handle     = BPut_shiftedbase + 16 ; r14
        LDMIA   wp, {r9, r10, r11, r12, r14}    ; Get cached data
        TEQ     r14, r1                         ; BPut on cached handle ?
        LDREQ   r14, [r11, #:INDEX: scb_fileptr] ; Check fileptr in that buffer
        TEQEQ   r9, r14, LSR r12
        STREQB  r0, [r10, r14]                  ; Put byte to buffer
        ADDEQ   r14, r14, #1
        STREQ   r14, [r11, #:INDEX: scb_fileptr] ; Increment fileptr
        Pull    "r9, lr", EQ                    ; Destack punter r9 and lr(VC)
        BEQ     SLVK

BPutThruVector
        MOV     r10, #BPutV                     ; Cache hit failed, call victor
        BL      CallVector
        Pull    "r9, lr"                        ; Destack punter r9 and lr(VC)
        B       SLVK_TestV
 |
a1162 1
 ]
d1176 1
a1176 1
        Push    lr                      ; this is user's link
d1178 9
d1190 2
d1202 1
a1202 1
        BIC     lr, lr, #C_bit          ; Copy C,V to punter lr
d1211 8
d1221 1
d1224 1
a1224 1
        BIC     lr, lr, #C_bit          ; Copy C,V to punter lr
d1250 3
d1254 1
d1262 2
a1263 1
        Pull    "r9-r12"                ; junk R9
d1269 9
d1279 1
d1366 1
d1368 1
@


4.7
log
@* Added support for 24LC64 8K EEPROM (untested).
* Integrated Ursula fast service call dispatch code.
* Added Interruptible32bitModes from Ursula.
* Stopped allowing ROM modules (other than the Kernel/UtilityModule) to write
  to the hardware vectors in 26-bit mode.

Version 4.81. Tagged as 'Kernel-4_81'
@
text
@a926 7
 [ True
  [ Fix15

; TMD 11-Sep-89; used to free the wrong node here - usually would try to free
; a null node, and claimed node would not get freed - however, if more than one
; request, then it could free the 2nd node before it was used.

a937 7
        LDR     r1, =SysHeapStart
        SWI     XOS_Heap

        MOV     lr, pc
        MOV     pc, r11                         ; call im, with given r12

        B       %BT01                           ; loop
d939 7
a946 11
01      TEQP    PC, #SVC_mode+I_bit             ; ints off while head updated
        MOV     r10, #0
        LDR     r10, [r10, #CallBack_Vector]
        TEQ     r10, #0
        Pull   "r0-r6, r10-r12, PC",EQ,^

        LDMIA   r10, {r2, r11, r12}             ; link, addr, r12
        MOV     r0, #HeapReason_Free
        STR     r2, [r0, #CallBack_Vector-HeapReason_Free] ; Keep head valid

        TEQP    PC, #SVC_mode                   ; enable ints for long bits
d949 1
a955 19
  ]
 | ; old one

        TEQP    PC, #SVC_mode

        LDR     r10, [r10, #CallBack_Vector]
01      MOV     r2, r10                         ; for freeing
        LDMIA   r10, {r10, r11, r12}            ; link, addr, r12
        MOV     r0, #HeapReason_Free
        STR     r10, [r0, #CallBack_Vector-HeapReason_Free]
        LDR     r1, =SysHeapStart
        SWI     XOS_Heap
        MOV     lr, pc
        MOV     pc, r11                         ; call im
        CMP     r10, #0
        BNE     %BT01
        Pull   "r0-r6, r10-r12, PC",,^
 ]

d1031 1
a1031 1
        AND     $swino, $swino, #ModuleSHT_Entries*4-1
@


4.6
log
@Following changes folded in from the start of the Ursula branch:
CPU type messages internationalised.
"Unknown OS_PlatformFeatures reason code" internationalised.
RunningOnEmul flag tweaked.
MorrisIDString conditional removed.
New modules added to SWI list at the end of the chain, on grounds that
the first-registered modules are probably more important.
*ChangeDynamicArea moved into UtilityModule from TaskManager.

Version 4.65. Tagged as 'Kernel-4_65'
@
text
@d849 66
@


4.5
log
@Spinner branch merged.
Bandwidth limit for 7500FE fixed.
RO371Timings flag set to :LNOT:STB

Version 4.64. Tagged as 'Kernel-4_64'
@
text
@d1420 3
a1424 1
 ! 0,"amg: renaissance. WARNING! StrongARM conditional code has non-internationalised errors"
d1426 6
a1431 2
        DCD     0
        DCB     "bad OS_PlatformFeatures reason code",0
@


4.4
log
@Added a VDU variable, and 4 SWIs (3 from Ursula, 1 from Spinner)
@
text
@d651 1
d655 8
a662 2
	& NoSuchSWI	; VIDCDividerSWI

@


4.3
log
@RISC OS 3.71 kernel changes merged.
Not fully tested on all hardware permutations.
@
text
@d651 4
@


4.3.2.1
log
@Module SWI chunks added to end of linked list on grounds that first loaded
modules are probably more important, so should be checked first.
Some RISC OS 3.70 bits internationalised.
*ChangeDynamicArea moved into UtilityModule from TaskManager.
@
text
@a1408 3
    [ International
        BL      TranslateError
    ]
d1411 1
d1413 2
a1414 6
        &       0
    [ International
        =       "BadPlatReas", 0
    |
        =       "Unknown OS_PlatformFeatures reason code", 0
    ]
@


4.3.2.2
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d64 1
d182 4
d205 6
d249 2
d257 1
d259 7
d325 1
a325 1
; relevant handler can be branched to.  This was mainly for non-ARM600 platforms
d330 8
a337 1

d341 1
a341 1

d347 43
a389 1
 [ :LNOT: IncludeTestSrc
d466 2
d474 4
d617 1
d619 4
d624 3
d628 1
d630 3
a632 1

d687 2
d708 2
d808 2
a810 2
; LRust, Fix RP-0609
; Check that SVC_sp is empty (apart from r10-r12), i.e. system truly is idle
d814 1
a814 1

d851 1
d876 21
d1094 1
d1117 36
d1162 29
d1192 1
d1204 32
d1241 1
d1395 11
d1409 1
d1411 1
d1416 1
d1418 3
@


4.3.2.3
log
@1) Fixes and tidy ups:
   - mapping of Cur/Sys/Sound area done more elegantly, and soft CAM info
     is now consistent with it
   - cached screen cleaning on VSync performed *after* VSync events
   - comments at top of ARM600 modernised
   - Pages_Unsafe/Safe code fixed to work properly on StrongARM with
     pages that are involved in interrupts (there is no fix for ARM8,
     since that is unlikely to be needed - an ASSERT checks use of ARM8
   - OS_DynamicArea code souped up, to be much more efficient for large
     numbers of dynamic areas (see comments near top of ChangeDyn)
   - cached screen is now suspended on h/w scroll (avoids possible cache
     incoherency)
2) API changes:
   - new OS_Memory reason code (10) allows Wimp to inform kernel of
     Wimp_ClaimFreeMemory, and can control VRAM rescue (see below)
   - new OS_ReadSysInfo reason code (6) allows reading of kernel values
     (reserved for Acorn use, eg. for SoftLoad, ROMPatch)
   - new OS_DynamicArea reason codes (6 and 7) allow for more efficient
     monitoring of dynamic areas by TaskManager (reserved for Acorn use)
3) Changes for Phoebe:
   - kernel runs a VRAM rescue process, which ensures that any VRAM not
     used for the screen is reclaimed if necessary and sinks to the bottom
     of the Free Pool. This is important for Phoebe, where VRAM is slower
     than SDRAM, but does no harm on other platforms.
   - logical copy of physical RAM is removed from memory map. This frees
     up 256M of address space that will later be used for PCI on Phoebe,
     but should do no harm on other platforms (this space is marked
     private in PRMs, so 3rd parties should not use it).
@
text
@d166 8
a173 9
VideoPhysRam          *  &02000000      ; Amazing - it's in the same place!
DRAM0PhysRam          *  &10000000      ; 4 DRAM banks
DRAM1PhysRam          *  &14000000
DRAM2PhysRam          *  &18000000
DRAM3PhysRam          *  &1C000000
DRAMBaseAddressMask   *  &1C000000      ; used to mask off bits after stealing video RAM
PhysSpaceSize_Full    *  &20000000      ; IOMD physical map is 512M (starting at 0)
PhysSpaceSize_NoDRAM  *  &10000000      ; physical map excluding DRAM (starting at 0)
PhysROM               *  &00000000      ; and real ROM starts at 0
d175 1
a175 1
PhysExtROM *    &01000000               ; 2nd ROM bank starts at 16M
@


4.3.2.4
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a22 6
;mjs changed for Ursula:
; - old version assumed stack base on 32k alignment, but this also assumes stack
;   size of less than 32k - no good for SVC stack now
; - change the assumed alignment of base to 1M (as defined in PRM 5a-39)
;
         ASSERT (SysHeapChunkAddress :AND: &FFF00000) = SysHeapChunkAddress
d25 12
a36 4
$l       MOV     $tmp, sp, LSR #20       ; Stack base on 1M boundary
         SUB     $tmp, sp, $tmp, LSL #20 ; Amount of stack left
         CMP     $tmp, #$space           ; Must have at least this much left
         BMI     $faildest
d281 1
a281 1
        B       ResetIRQForwarding      ; changed for Ursula, to avoid need for shadow ROM
a286 5
RealEndFiq
ResetIRQForwarding                      ; we can't branch straight there in 32 bit
        LDR     pc, RIFaddress          ; mode (only +/32 Mb range available, and
RIFaddress                              ; we no longer map shodow ROM at top)
        &       IRQ_Test_CTRL_or_R_Pressed
d363 1
a363 1
 ! 0,"SLVK_TestV  at ":CC:(:STR:SLVK_TestV)
d368 1
a368 1
 ! 0,"SLVK        at ":CC:(:STR:SLVK)
d375 1
a375 1
 ! 0,"SWIReturn   at ":CC:(:STR:SWIReturn)
d386 1
a386 1
 ! 0,"VSetReturn  at ":CC:(:STR:({PC}-SWIRelocation))
d395 3
a397 1
 ! 0,"SWIDespatch at ":CC::STR:({PC}-SWIRelocation)
d399 3
a401 15
;mjs
;Performance enhancements for Ursula - SWI despatcher fights the flab
;  (reorganised to avoid branches to/from ROM, and saves redundant work by knowing
;  it is called in SVC32 mode).

;If SVCAlwaysClearsV is {TRUE}, despatch is sleeker (currently 3 instructions saved
;  for every SWI depatch), but any SWIs that need caller V have to get it from r10
;  (which has copy of SPSR), and such SWIs can only be OS_ SWIs. Currently only
;  OS_BreakPt and OS_CallAVector need this (and it only takes them 2 extra
;  instructions). If {FALSE}, the despatcher must grudgingly check for a list of
;  deviant SWIs that need caller V. Clearly, SVCAlwaysClearsV {TRUE} is much nicer,
;  but old method {FALSE} retained for info. 
;
                  GBLL  SVCAlwaysClearsV
SVCAlwaysClearsV  SETL  {TRUE}
d403 3
a405 9
SVC * {PC}-SWIRelocation
;
;we enter in SVC32 mode, so we can pick up SWI instruction more cleanly than old 26bit handler
;
;we are assuming RISC OS is still 26bit, so we munge down to that, and SWIs can only be called from lower 64M
;
        Push    "r10-r12"
        LDR     r11, [r14,#-4]                          ;pick up SWI instruction (bad news for data cache on StrongARM!)
        BIC     r11, r11, #&FF000000                    ;extract SWI number field
d407 3
a409 20
;
;now we munge ourself an equivalent 26bit LR
;
        mrs     AL, r10, SPSR_all                       ;r10 = saved PSR - may be used by OS_ SWIs that need caller V
  [ SVCAlwaysClearsV
        AND     r12, r10, #&E0000003                    ;get saved NZC and (26 bit) mode bits, clear V
  |
        AND     r12, r10, #&F0000003                    ;get saved NZCV and (26 bit) mode bits
  ]
        ORR     lr, lr, r12
        AND     r12, r10, #I32_bit + F32_bit            ;extract I and F bits
        ORR     lr, lr, r12, LSL #IF32_26Shift          ;lr = 26 bit equivalent
;
;now we drop down to SVC26 mode - we know we are currently in SVC32
;
        mrs     AL, r12, CPSR_all
        BIC     r12, r12, #&10                          ;zap the '32bit' bit
        msr     AL, CPSR_all, r12

SVC_CallASWI * {PC}-SWIRelocation                       ;CallASWI,CallASWIR12 re-entry point
d414 2
a415 2
        ORR     r12, r14, #SVC_mode
        TEQP    r12, #0                                 ;restore caller's IRQ state
a416 1
  [ :LNOT: SVCAlwaysClearsV
d419 1
a419 2
        BICNE   r14, r14, #V_bit                        ;clear V unless BreakPoint/CallVector
  ]
a425 2
;;; ! 1,"real SWIDespatch_Size = ":CC::STR:({PC}-SVCDespatcher)

d600 21
a776 9

  [ ChocolateSysHeap
        ASSERT  ChocolateCBBlocks = ChocolateBlockArrays + 0
        MOV     r1,#ChocolateBlockArrays
        LDR     r1,[r1,#0]
        BL      FreeChocolateBlock
        LDRVS   r1, =SysHeapStart
        SWIVS   XOS_Heap
  |
a778 1
  ]
a870 8

;SWI hash table:
;
;  <Hashval> = (swi_chunk_base >> 4) & ((ModuleSHT_Entries - 1)*4)
;
;  - where the swi chunk base will be a multiple of 64, and the Hashval is
;    a multiple of 4, since it indexes word entries in the table
;
d878 1
a878 1
        AND     $swino, $swino, #(ModuleSHT_Entries-1)*4 
@


4.3.2.5
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@a597 3
        & NoSuchSWI         ;Ursula does not implement OS_SpecialControl
        & EnterUSR32SWI
        & EnterUSR26SWI
a603 3
        & NoSuchSWI
        & NoSuchSWI
        & NoSuchSWI
a766 66
;
; Ursula:
; this is only used by the interrupt handler, to allow callbacks when
; foreground is 32-bit user, rather than 26-bit user
;
; currently only supports transient callbacks - traditional callback handler
; cannot be called because it contains its own 32-bit unaware return sequence
;

back_to_user32
        mrs    AL, r10, CPSR_all
        ORR    r10, r10, #I32_bit :OR: SVC32_mode ;move up to SVC32 from SVC26, interrupts off
        msr    AL, CPSR_all, r10
        Pull   "r10"
        msr    AL, SPSR_all, r10                  ;PSR for return, stacked by interrupt handler
        Pull   "r10-r12"
        MOVS    PC, lr                            ;return to address in lr, restoring CPSR from SPSR

Do_CallBack32                                  ; CallBack allowed:
        TST     r11, #CBack_VectorReq          ; now process any vector entries
        Push    lr, NE
        BLNE    process_callback_chain
        Pull    lr, NE

  [ {TRUE}   ;currently can't allow call to Callback handler

        B       back_to_user32

  |
        ;this won't work with traditional callback handler (which has its own
        ;return code that won't return successfully to 32-bit user mode)

        TST     r11, #CBack_OldStyle
        BEQ     back_to_user32

; Check that SVC_sp is empty (apart from r10-r12), i.e. system truly is idle
        LDR     r11, =SVCSTK-3*4                ; What SVC_sp should be if system idle
        CMP     sp, r11                         ; Stack empty?
        BLO     back_to_user32                  ; No then no call back

        TEQP    PC, #SVC_mode+I_bit             ; ints off while flag updated
        LDRB    r11, [r10, #CallBack_Flag]
        BIC     r11, r11, #CBack_Postpone+CBack_OldStyle
        STRB    r11, [r10, #CallBack_Flag]

        MOV     r12, #0
        LDR     R12, [R12, #CallBf]
        STR     r14, [r12, #4*15]             ; user PC
        MOV     r14, r12
        Pull   "r10-r12"
  [ SASTMhatbroken
        STMIA   r14!,{r0-r12}
        STMIA   r14,{r13,r14}^                ; user registers
        NOP
        SUB     r14,r14,#13*4
  |
        STMIA   r14, {r0-r14}^                ; user registers
  ]

        MOV     R12, #CallAd_ws
        LDMIA   R12, {R12, PC}                ; jump to CallBackHandler

  ]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d779 6
d814 18
a1229 24


EnterUSR32SWI
;
;a very unusual SWI - must exit in USR32, so cannot use normal SWI exit
;does not check for callbacks
;
        BIC     r10, r10, #V_bit + &0F   ;r10 has copy of SPSR from dispatcher
                                         ;clear V and bottom 4 mode bits
        ORR     r10, r10, #&10           ;now r10 is PSR we want to restore for USR32
        msr     AL, SPSR_all, r10        ;ready to restore PSR with a return from SVC32
        mrs     AL, r10, CPSR_all
        ORR     r10, r10, #&10           ;move up to SVC32 from SVC26
        msr     AL, CPSR_all, r10
        Pull    r11
        Pull    "r10-r12"                ;restore regs from SVC stack as for normal exit
        BIC     lr, lr, #&FC000003       ;return address
        MOVS    pc, lr                   ;return from SVC32 to USR32


EnterUSR26SWI
        BIC     lr,lr,#3                 ;26-bit user mode
        B       SLVK                     ;we can do normal exit for no error

@


4.3.2.5.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@d58 1
d61 2
d163 1
d165 1
a165 1
DRAM0PhysRam          *  &10000000      ; 4 DRAM banks for IOMD1, first 4 SDRAM banks for IOMD2
d169 3
a171 8
DRAM4PhysRam          *  &20000000      ; additional 4 SDRAM banks for IOMD2
DRAM5PhysRam          *  &24000000
DRAM6PhysRam          *  &28000000
DRAM7PhysRam          *  &2C000000
DRAMBaseAddressMask   *  &1C000000      ; used to mask off bits after stealing video RAM (IOMD1)
PhysSpaceSize_Full    *  &20000000      ; IOMD1 physical map is 512M (starting at 0)
PhysSpaceSize_IOMD2   *  &30000000      ; IOMD2 space including SDRAM (but excluding Cache flush, PCI)
PhysSpaceSize_NoDRAM  *  &10000000      ; physical map excluding DRAM (and excluding Cache flush, PCI if IOMD2) (starting at 0)
d173 3
d179 2
d214 1
d216 3
d240 1
d242 1
a242 3
; Because of Morris support, we've already generated 16/32 ROM entry code, so always skip this bit

  [ :LNOT: IncludeTestSrc :LAND: {FALSE}
d587 3
d591 2
d601 10
d627 1
d643 1
d896 1
d901 5
d1242 1
a1271 1
        Pull    lr
d1302 1
@


4.3.2.6
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@d58 1
d61 2
d163 1
d165 1
a165 1
DRAM0PhysRam          *  &10000000      ; 4 DRAM banks for IOMD1, first 4 SDRAM banks for IOMD2
d169 3
a171 8
DRAM4PhysRam          *  &20000000      ; additional 4 SDRAM banks for IOMD2
DRAM5PhysRam          *  &24000000
DRAM6PhysRam          *  &28000000
DRAM7PhysRam          *  &2C000000
DRAMBaseAddressMask   *  &1C000000      ; used to mask off bits after stealing video RAM (IOMD1)
PhysSpaceSize_Full    *  &20000000      ; IOMD1 physical map is 512M (starting at 0)
PhysSpaceSize_IOMD2   *  &30000000      ; IOMD2 space including SDRAM (but excluding Cache flush, PCI)
PhysSpaceSize_NoDRAM  *  &10000000      ; physical map excluding DRAM (and excluding Cache flush, PCI if IOMD2) (starting at 0)
d173 3
d179 2
d214 1
d216 3
d240 1
d242 1
a242 3
; Because of Morris support, we've already generated 16/32 ROM entry code, so always skip this bit

  [ :LNOT: IncludeTestSrc :LAND: {FALSE}
d587 3
d591 2
d601 10
d627 1
d643 1
d896 1
d901 5
d1242 1
a1271 1
        Pull    lr
d1302 1
@


4.2
log
@Kernel merged
@
text
@d825 6
d832 1
@


4.1
log
@Initial revision
@
text
@d175 3
d254 1
a254 1
; If MorrisSupport we've already generated 16/32 ROM entry code, so skip this bit 
d437 1
a437 1
 ! 0,"SLVK       at ":CC:(:STR:SLVK)      
d482 4
d633 19
d665 19
a683 2
; All the stuff from MOSROMVecs to here is read consecutively out of ROM,
; so don't put anything in between without changing the code
d692 2
d705 3
d924 7
a930 1
        Push    pc, CS                 ; push address of ReturnFromVectoredWrch
d933 1
a933 1

d1361 49
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a174 1
PhysExtROM *	&01000000		; 2nd ROM bank starts at 16M
@


4.1.7.2
log
@Added SWI OS_VIDCDivider, and vdu variable PixelRate for better video mode
support.  Fixed to build for Risc PC.
@
text
@a626 17
; The following SWIs are not available in this kernel.
	& NoSuchSWI	; ResyncTime
	& NoSuchSWI	; PlatformFeatures
	& NoSuchSWI	; SynchroniseCodeAreas
	& NoSuchSWI	; CallASWI
	& NoSuchSWI	; AMBControl
	& NoSuchSWI	; CallASWIR12
	& NoSuchSWI	; SpecialControl
	& NoSuchSWI	; EnterUSR32SWI
	& NoSuchSWI	; EnterUSR26SWI
; End of unavailable SWIs.
; Should not cause any problems on any machine.  STB flag just to be safe though.
 [ STB :LAND: {TRUE}
	& VIDCDividerSWI
 |
	& NoSuchSWI
 ]
@


4.1.7.3
log
@Support added for 24LC128 16K EEPROM device.
OS_NVMemory SWI added to allow block operations on non-volatile memory.
Kernel can clock memory device at 400kHz for greater throughput.
Safeguards added to stop the device being accessed when the clock is changed
and the device doesn't have an RTC.
Changed to use srccommit.

Version 4.63, 1.1.2.2. Tagged as 'Kernel-4_63-1_1_2_2'
@
text
@d252 1
a252 1
; If MorrisSupport we've already generated 16/32 ROM entry code, so skip this bit
d435 1
a435 1
 ! 0,"SLVK       at ":CC:(:STR:SLVK)
a643 1
        & NVMemorySWI
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a174 1
PhysExtROM *	&01000000		; 2nd ROM bank starts at 16M
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@d251 1
a251 1
; If MorrisSupport we've already generated 16/32 ROM entry code, so skip this bit
d434 1
a434 1
 ! 0,"SLVK       at ":CC:(:STR:SLVK)
a478 3

SVC_CallASWI * {PC}-SWIRelocation       ; CallASWI,CallASWIR12 re-entry point

a625 15
        & ResyncTimeSWI
 [ StrongARM
        & PlatFeatSWI  
        & SyncCodeAreasSWI
        & CallASWI
        & AMBControlSWI
        & CallASWIR12
 |
        & NoSuchSWI
        & NoSuchSWI
        & NoSuchSWI
        & NoSuchSWI
        & NoSuchSWI
 ]

d639 2
a640 17
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;StrongARM needs these

;SWI number passed in r10
CallASWI ROUT
        LDR     r11, [sp, #4]        ;pick-up target SWI code (r10 pushed by dispatcher)
        BIC     r11, r11, #&FF000000 ;just in case
        STR     r11, [sp, #0]        ;CallASWI now incognito as target SWI
        B       SVC_CallASWI         ;re-dispatch

;SWI number passed in r12 (better for C veneers)
CallASWIR12 ROUT
        LDR     r11, [sp, #12]       ;pick-up target SWI code (r12 pushed by dispatcher)
        BIC     r11, r11, #&FF000000 ;just in case
        STR     r11, [sp, #0]        ;CallASWIR12 now incognito as target SWI
        B       SVC_CallASWI         ;re-dispatch
a648 2
        ALIGN   32   ;for efficient cache alignment

a659 3

  ! 0, "SVCARM600 (for SWIdespatch) at ":CC::STR:(SVCARM600)

d876 1
a876 7
  [ StrongARM
        BCC     WrchThruVector
        Push    pc, CS                 ; need to get to ReturnFromVectoredWrch - push PC+12 (old ARM) or PC+8 (StrongARM)
        BCS     PMFWrchDirect
        MOV     R0,R0                  ; NOP for PC+8
  |
        Push    pc, CS                 ; push address of ReturnFromVectoredWrch (PC+12)
d879 1
a879 1
  ]
a1306 46

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI XOS_PlatformFeatures

PlatFeatSWI ROUT
        Push    lr
        CMP     r0, #0                  ;Is it a known reason code?
        BNE     %FT50                   ;No, so send out a service call

        ;Ok, it's the 'code_features' reason code.
        LDRB    r0,[r0, #ProcessorFlags]
        TST     r0, #2                  ;Is the 'no irq enable/disable' bit set?
        ADRNE   r1, platfeat_irqinsert  ;Yep, so point R1 to the delay routine
        MOVEQ   r1, #0
        Pull    lr
        B       SLVK                    ;Return

platfeat_irqinsert
        MOV     r0, r0
        MOV     r0, r0
        MOV     r0, r0
        MOV     r0, r0
        MOV     r0, r0
        MOV     pc, lr

50
  [ {FALSE}
        Push    "r1-r8"
        MOV     r1, #Service_UnknownPlatformFeatures
        Pull    "r2-r9"
        BL      Issue_Service
        CMP     r1, #0
        BNE     %FT75
        Push    "r2-r9"
        Pull    "r1-r8"
        B       SLVK                    ;Return
  ]

75      ;Get here if the service call isn't claimed.
        ADR     R0,platfeaterror
        B       SLVK_SetV

platfeaterror
        DCD     0
        DCB     "bad OS_PlatformFeatures reason code",0
        ALIGN
@


4.1.3.2
log
@RISC OS 3.71 version taken
@
text
@d631 1
a631 1
        & PlatFeatSWI
a814 6
  [ SASTMhatbroken
        STMIA   r14!,{r0-r12}
        STMIA   r14,{r13,r14}^                ; user registers
        NOP
        SUB     r14,r14,#13*4
  |
a815 1
  ]
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d631 1
a631 1
        & PlatFeatSWI
a814 6
  [ SASTMhatbroken
        STMIA   r14!,{r0-r12}
        STMIA   r14,{r13,r14}^                ; user registers
        NOP
        SUB     r14,r14,#13*4
  |
a815 1
  ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.24;
access;
symbols
	Kernel-6_15:4.24
	Kernel-6_14:4.24
	Kernel-6_01-3:4.24
	Kernel-6_13:4.24
	Kernel-6_12:4.24
	Kernel-6_11:4.24
	Kernel-6_10:4.24
	Kernel-6_09:4.24
	Kernel-6_08-4_129_2_10:4.23.2.1
	Kernel-6_08-4_129_2_9:4.23.2.1
	Kernel-6_08:4.24
	Kernel-6_07:4.24
	Kernel-6_06:4.24
	Kernel-6_05-4_129_2_8:4.23.2.1
	Kernel-6_05:4.24
	Kernel-6_04:4.24
	Kernel-6_03:4.24
	Kernel-6_01-2:4.24
	Kernel-6_01-4_146_2_1:4.24
	Kernel-6_02:4.24
	Kernel-6_01-1:4.24
	Kernel-6_01:4.24
	Kernel-6_00:4.24
	Kernel-5_99:4.24
	Kernel-5_98:4.24
	Kernel-5_97-4_129_2_7:4.23
	Kernel-5_97:4.23
	Kernel-5_96:4.23
	Kernel-5_95:4.23
	Kernel-5_94:4.23
	Kernel-5_93:4.23
	Kernel-5_92:4.23
	Kernel-5_91:4.23
	Kernel-5_90:4.23
	Kernel-5_89-4_129_2_6:4.23
	Kernel-5_89:4.23
	Kernel-5_88-4_129_2_5:4.23
	Kernel-5_88-4_129_2_4:4.23
	Kernel-5_88:4.23
	Kernel-5_87:4.23
	Kernel-5_86-4_129_2_3:4.23
	Kernel-5_86-4_129_2_2:4.23
	Kernel-5_86-4_129_2_1:4.23
	Kernel-5_86:4.23
	SMP:4.23.0.2
	SMP_bp:4.23
	Kernel-5_85:4.23
	Kernel-5_54-1:4.23
	Kernel-5_84:4.22
	Kernel-5_83:4.22
	Kernel-5_82:4.22
	Kernel-5_81:4.22
	Kernel-5_80:4.22
	Kernel-5_79:4.21
	Kernel-5_78:4.21
	Kernel-5_77:4.21
	Kernel-5_76:4.21
	Kernel-5_75:4.21
	Kernel-5_74:4.21
	Kernel-5_73:4.21
	Kernel-5_72:4.21
	Kernel-5_71:4.21
	Kernel-5_70:4.21
	Kernel-5_69:4.21
	Kernel-5_68:4.21
	Kernel-5_67:4.21
	Kernel-5_66:4.21
	Kernel-5_65:4.21
	Kernel-5_64:4.21
	Kernel-5_63:4.21
	Kernel-5_62:4.21
	Kernel-5_61:4.21
	Kernel-5_60:4.21
	Kernel-5_59:4.21
	Kernel-5_58:4.21
	Kernel-5_57:4.21
	Kernel-5_56:4.21
	Kernel-5_55:4.20
	Kernel-5_54:4.20
	Kernel-5_53:4.20
	Kernel-5_52:4.20
	Kernel-5_51:4.20
	Kernel-5_50:4.19
	Kernel-5_49:4.18
	HAL_merge:4.15.2.39
	Kernel-5_48:4.17
	Kernel-5_35-4_79_2_327:4.15.2.39
	Kernel-5_35-4_79_2_326:4.15.2.39
	Kernel-5_35-4_79_2_325:4.15.2.39
	Kernel-5_35-4_79_2_324:4.15.2.39
	Kernel-5_35-4_79_2_323:4.15.2.39
	Kernel-5_35-4_79_2_322:4.15.2.39
	Kernel-5_35-4_79_2_321:4.15.2.39
	Kernel-5_35-4_79_2_320:4.15.2.39
	Kernel-5_35-4_79_2_319:4.15.2.39
	Kernel-5_35-4_79_2_318:4.15.2.38
	Kernel-5_35-4_79_2_317:4.15.2.38
	Kernel-5_35-4_79_2_316:4.15.2.38
	Kernel-5_35-4_79_2_315:4.15.2.38
	Kernel-5_35-4_79_2_314:4.15.2.38
	Kernel-5_35-4_79_2_313:4.15.2.38
	Kernel-5_35-4_79_2_312:4.15.2.37
	Kernel-5_35-4_79_2_311:4.15.2.37
	Kernel-5_35-4_79_2_310:4.15.2.37
	Kernel-5_35-4_79_2_309:4.15.2.37
	Kernel-5_35-4_79_2_308:4.15.2.37
	Kernel-5_35-4_79_2_307:4.15.2.37
	Kernel-5_35-4_79_2_306:4.15.2.37
	Kernel-5_35-4_79_2_305:4.15.2.37
	Kernel-5_35-4_79_2_304:4.15.2.37
	Kernel-5_35-4_79_2_303:4.15.2.37
	Kernel-5_35-4_79_2_302:4.15.2.37
	Kernel-5_35-4_79_2_301:4.15.2.37
	Kernel-5_35-4_79_2_300:4.15.2.36
	Kernel-5_35-4_79_2_299:4.15.2.36
	Kernel-5_35-4_79_2_298:4.15.2.36
	Kernel-5_35-4_79_2_297:4.15.2.36
	Kernel-5_35-4_79_2_296:4.15.2.36
	Kernel-5_35-4_79_2_295:4.15.2.36
	Kernel-5_35-4_79_2_294:4.15.2.36
	Kernel-5_35-4_79_2_293:4.15.2.36
	Kernel-5_35-4_79_2_292:4.15.2.36
	Kernel-5_35-4_79_2_291:4.15.2.35
	Kernel-5_35-4_79_2_290:4.15.2.35
	Kernel-5_35-4_79_2_289:4.15.2.35
	Kernel-5_35-4_79_2_288:4.15.2.35
	Kernel-5_35-4_79_2_287:4.15.2.35
	Kernel-5_35-4_79_2_286:4.15.2.35
	Kernel-5_35-4_79_2_285:4.15.2.35
	Kernel-5_35-4_79_2_284:4.15.2.35
	Kernel-5_35-4_79_2_283:4.15.2.34
	Kernel-5_35-4_79_2_282:4.15.2.34
	Kernel-5_35-4_79_2_281:4.15.2.34
	Kernel-5_35-4_79_2_280:4.15.2.34
	Kernel-5_35-4_79_2_279:4.15.2.34
	Kernel-5_35-4_79_2_278:4.15.2.34
	Kernel-5_35-4_79_2_277:4.15.2.34
	Kernel-5_35-4_79_2_276:4.15.2.34
	Kernel-5_35-4_79_2_275:4.15.2.34
	Kernel-5_35-4_79_2_274:4.15.2.34
	Kernel-5_35-4_79_2_273:4.15.2.34
	Kernel-5_35-4_79_2_272:4.15.2.33
	Kernel-5_35-4_79_2_271:4.15.2.33
	Kernel-5_35-4_79_2_270:4.15.2.32
	Kernel-5_35-4_79_2_269:4.15.2.31
	Kernel-5_35-4_79_2_268:4.15.2.31
	Kernel-5_35-4_79_2_267:4.15.2.31
	Kernel-5_35-4_79_2_266:4.15.2.31
	Kernel-5_35-4_79_2_265:4.15.2.31
	Kernel-5_35-4_79_2_264:4.15.2.31
	Kernel-5_35-4_79_2_263:4.15.2.31
	Kernel-5_35-4_79_2_262:4.15.2.31
	Kernel-5_35-4_79_2_261:4.15.2.31
	Kernel-5_35-4_79_2_260:4.15.2.30
	Kernel-5_35-4_79_2_259:4.15.2.30
	Kernel-5_35-4_79_2_258:4.15.2.30
	Kernel-5_35-4_79_2_257:4.15.2.30
	Kernel-5_35-4_79_2_256:4.15.2.30
	Kernel-5_35-4_79_2_255:4.15.2.30
	Kernel-5_35-4_79_2_254:4.15.2.30
	Kernel-5_35-4_79_2_253:4.15.2.30
	Kernel-5_35-4_79_2_252:4.15.2.30
	Kernel-5_35-4_79_2_251:4.15.2.30
	Kernel-5_35-4_79_2_250:4.15.2.30
	Kernel-5_35-4_79_2_249:4.15.2.30
	Kernel-5_35-4_79_2_248:4.15.2.30
	Kernel-5_35-4_79_2_247:4.15.2.29
	Kernel-5_35-4_79_2_246:4.15.2.29
	Kernel-5_35-4_79_2_245:4.15.2.29
	Kernel-5_35-4_79_2_244:4.15.2.29
	Kernel-5_35-4_79_2_243:4.15.2.29
	Kernel-5_35-4_79_2_242:4.15.2.29
	Kernel-5_35-4_79_2_241:4.15.2.29
	Kernel-5_35-4_79_2_240:4.15.2.29
	Kernel-5_35-4_79_2_239:4.15.2.29
	Kernel-5_35-4_79_2_238:4.15.2.29
	Kernel-5_35-4_79_2_237:4.15.2.29
	Kernel-5_35-4_79_2_236:4.15.2.29
	Kernel-5_35-4_79_2_235:4.15.2.29
	Kernel-5_35-4_79_2_234:4.15.2.28
	Kernel-5_35-4_79_2_233:4.15.2.28
	Kernel-5_35-4_79_2_232:4.15.2.28
	Kernel-5_35-4_79_2_231:4.15.2.28
	Kernel-5_35-4_79_2_230:4.15.2.28
	Kernel-5_35-4_79_2_229:4.15.2.28
	Kernel-5_35-4_79_2_228:4.15.2.28
	Kernel-5_35-4_79_2_227:4.15.2.28
	Kernel-5_35-4_79_2_226:4.15.2.28
	Kernel-5_35-4_79_2_225:4.15.2.28
	Kernel-5_35-4_79_2_224:4.15.2.28
	Kernel-5_35-4_79_2_223:4.15.2.28
	Kernel-5_35-4_79_2_222:4.15.2.28
	Kernel-5_35-4_79_2_221:4.15.2.27
	Kernel-5_35-4_79_2_220:4.15.2.27
	Kernel-5_35-4_79_2_219:4.15.2.27
	Kernel-5_35-4_79_2_218:4.15.2.27
	Kernel-5_35-4_79_2_217:4.15.2.27
	Kernel-5_35-4_79_2_216:4.15.2.27
	Kernel-5_35-4_79_2_215:4.15.2.27
	Kernel-5_35-4_79_2_214:4.15.2.27
	Kernel-5_35-4_79_2_213:4.15.2.27
	Kernel-5_35-4_79_2_212:4.15.2.27
	Kernel-5_35-4_79_2_211:4.15.2.27
	Kernel-5_35-4_79_2_210:4.15.2.27
	Kernel-5_35-4_79_2_209:4.15.2.27
	Kernel-5_35-4_79_2_208:4.15.2.27
	Kernel-5_35-4_79_2_207:4.15.2.27
	Kernel-5_35-4_79_2_206:4.15.2.27
	Kernel-5_35-4_79_2_205:4.15.2.27
	Kernel-5_35-4_79_2_204:4.15.2.27
	Kernel-5_35-4_79_2_203:4.15.2.27
	Kernel-5_35-4_79_2_202:4.15.2.27
	Kernel-5_35-4_79_2_201:4.15.2.27
	Kernel-5_35-4_79_2_200:4.15.2.27
	Kernel-5_35-4_79_2_199:4.15.2.27
	Kernel-5_35-4_79_2_198:4.15.2.27
	Kernel-5_35-4_79_2_197:4.15.2.27
	Kernel-5_35-4_79_2_196:4.15.2.27
	Kernel-5_35-4_79_2_195:4.15.2.27
	Kernel-5_35-4_79_2_194:4.15.2.27
	Kernel-5_35-4_79_2_193:4.15.2.26
	Kernel-5_35-4_79_2_192:4.15.2.26
	Kernel-5_35-4_79_2_191:4.15.2.26
	Kernel-5_35-4_79_2_190:4.15.2.26
	Kernel-5_35-4_79_2_189:4.15.2.26
	Kernel-5_35-4_79_2_188:4.15.2.26
	Kernel-5_35-4_79_2_187:4.15.2.25
	Kernel-5_35-4_79_2_186:4.15.2.25
	Kernel-5_35-4_79_2_185:4.15.2.24
	Kernel-5_35-4_79_2_184:4.15.2.24
	Kernel-5_35-4_79_2_183:4.15.2.24
	Kernel-5_35-4_79_2_182:4.15.2.24
	Kernel-5_35-4_79_2_181:4.15.2.24
	Kernel-5_35-4_79_2_180:4.15.2.24
	Kernel-5_35-4_79_2_179:4.15.2.23
	Kernel-5_35-4_79_2_178:4.15.2.23
	Kernel-5_35-4_79_2_177:4.15.2.22
	Kernel-5_35-4_79_2_176:4.15.2.22
	Kernel-5_35-4_79_2_175:4.15.2.22
	Kernel-5_35-4_79_2_174:4.15.2.22
	Kernel-5_35-4_79_2_173:4.15.2.22
	Kernel-5_35-4_79_2_172:4.15.2.22
	Kernel-5_35-4_79_2_171:4.15.2.22
	Kernel-5_35-4_79_2_170:4.15.2.22
	Kernel-5_35-4_79_2_169:4.15.2.22
	Kernel-5_35-4_79_2_168:4.15.2.22
	Kernel-5_35-4_79_2_167:4.15.2.22
	Kernel-5_35-4_79_2_166:4.15.2.22
	Kernel-5_35-4_79_2_165:4.15.2.22
	RPi_merge:4.15.2.19.2.2
	Kernel-5_35-4_79_2_147_2_23:4.15.2.19.2.2
	Kernel-5_35-4_79_2_147_2_22:4.15.2.19.2.1
	Kernel-5_35-4_79_2_147_2_21:4.15.2.19.2.1
	Kernel-5_35-4_79_2_147_2_20:4.15.2.19.2.1
	Kernel-5_35-4_79_2_147_2_19:4.15.2.19.2.1
	Kernel-5_35-4_79_2_147_2_18:4.15.2.19.2.1
	Kernel-5_35-4_79_2_164:4.15.2.22
	Kernel-5_35-4_79_2_163:4.15.2.22
	Kernel-5_35-4_79_2_147_2_17:4.15.2.19.2.1
	Kernel-5_35-4_79_2_147_2_16:4.15.2.19.2.1
	Kernel-5_35-4_79_2_147_2_15:4.15.2.19.2.1
	Kernel-5_35-4_79_2_162:4.15.2.22
	Kernel-5_35-4_79_2_161:4.15.2.22
	Kernel-5_35-4_79_2_147_2_14:4.15.2.19.2.1
	Kernel-5_35-4_79_2_147_2_13:4.15.2.19.2.1
	Kernel-5_35-4_79_2_160:4.15.2.22
	Kernel-5_35-4_79_2_159:4.15.2.22
	Kernel-5_35-4_79_2_158:4.15.2.22
	Kernel-5_35-4_79_2_157:4.15.2.22
	Kernel-5_35-4_79_2_156:4.15.2.21
	Kernel-5_35-4_79_2_147_2_12:4.15.2.19.2.1
	Kernel-5_35-4_79_2_147_2_11:4.15.2.19.2.1
	Kernel-5_35-4_79_2_155:4.15.2.21
	Kernel-5_35-4_79_2_147_2_10:4.15.2.19.2.1
	Kernel-5_35-4_79_2_154:4.15.2.20
	Kernel-5_35-4_79_2_153:4.15.2.19
	Kernel-5_35-4_79_2_147_2_9:4.15.2.19
	Kernel-5_35-4_79_2_152:4.15.2.19
	Kernel-5_35-4_79_2_151:4.15.2.19
	Kernel-5_35-4_79_2_147_2_8:4.15.2.19
	Kernel-5_35-4_79_2_147_2_7:4.15.2.19
	Kernel-5_35-4_79_2_150:4.15.2.19
	Kernel-5_35-4_79_2_147_2_6:4.15.2.19
	Kernel-5_35-4_79_2_147_2_5:4.15.2.19
	Kernel-5_35-4_79_2_149:4.15.2.19
	Kernel-5_35-4_79_2_147_2_4:4.15.2.19
	Kernel-5_35-4_79_2_147_2_3:4.15.2.19
	Kernel-5_35-4_79_2_148:4.15.2.19
	Kernel-5_35-4_79_2_147_2_2:4.15.2.19
	Kernel-5_35-4_79_2_147_2_1:4.15.2.19
	RPi:4.15.2.19.0.2
	RPi_bp:4.15.2.19
	Kernel-5_35-4_79_2_98_2_52_2_1:4.15.2.13.2.7
	alees_Kernel_dev:4.15.2.13.2.7.0.2
	alees_Kernel_dev_bp:4.15.2.13.2.7
	Kernel-5_35-4_79_2_147:4.15.2.19
	Kernel-5_35-4_79_2_146:4.15.2.19
	Kernel-5_35-4_79_2_145:4.15.2.19
	Kernel-5_35-4_79_2_144:4.15.2.19
	Kernel-5_35-4_79_2_143:4.15.2.19
	Kernel-5_35-4_79_2_142:4.15.2.19
	Kernel-5_35-4_79_2_141:4.15.2.19
	Kernel-5_35-4_79_2_140:4.15.2.19
	Kernel-5_35-4_79_2_139:4.15.2.19
	Kernel-5_35-4_79_2_138:4.15.2.19
	Kernel-5_35-4_79_2_137:4.15.2.18
	Kernel-5_35-4_79_2_136:4.15.2.18
	Kernel-5_35-4_79_2_135:4.15.2.18
	Kernel-5_35-4_79_2_134:4.15.2.18
	Kernel-5_35-4_79_2_133:4.15.2.18
	Kernel-5_35-4_79_2_132:4.15.2.18
	Kernel-5_35-4_79_2_131:4.15.2.18
	Kernel-5_35-4_79_2_130:4.15.2.18
	Kernel-5_35-4_79_2_129:4.15.2.18
	Kernel-5_35-4_79_2_128:4.15.2.18
	Kernel-5_35-4_79_2_127:4.15.2.18
	Kernel-5_35-4_79_2_126:4.15.2.17
	Kernel-5_35-4_79_2_125:4.15.2.17
	Kernel-5_35-4_79_2_124:4.15.2.17
	Kernel-5_35-4_79_2_123:4.15.2.17
	Cortex_merge:4.15.2.13.2.8
	Kernel-5_35-4_79_2_122:4.15.2.16
	Kernel-5_35-4_79_2_98_2_54:4.15.2.13.2.8
	Kernel-5_35-4_79_2_98_2_53:4.15.2.13.2.8
	Kernel-5_35-4_79_2_98_2_52:4.15.2.13.2.7
	Kernel-5_35-4_79_2_98_2_51:4.15.2.13.2.7
	Kernel-5_35-4_79_2_98_2_50:4.15.2.13.2.7
	Kernel-5_35-4_79_2_98_2_49:4.15.2.13.2.7
	Kernel-5_35-4_79_2_98_2_48:4.15.2.13.2.7
	Kernel-5_35-4_79_2_121:4.15.2.16
	Kernel-5_35-4_79_2_98_2_47:4.15.2.13.2.6
	Kernel-5_35-4_79_2_120:4.15.2.15
	Kernel-5_35-4_79_2_98_2_46:4.15.2.13.2.5
	Kernel-5_35-4_79_2_119:4.15.2.15
	Kernel-5_35-4_79_2_98_2_45:4.15.2.13.2.5
	Kernel-5_35-4_79_2_98_2_44:4.15.2.13.2.4
	Kernel-5_35-4_79_2_118:4.15.2.15
	Kernel-5_35-4_79_2_98_2_43:4.15.2.13.2.3
	Kernel-5_35-4_79_2_117:4.15.2.14
	Kernel-5_35-4_79_2_116:4.15.2.14
	Kernel-5_35-4_79_2_98_2_42:4.15.2.13.2.3
	Kernel-5_35-4_79_2_115:4.15.2.14
	Kernel-5_35-4_79_2_98_2_41:4.15.2.13.2.3
	Kernel-5_35-4_79_2_98_2_40:4.15.2.13.2.2
	Kernel-5_35-4_79_2_114:4.15.2.13
	Kernel-5_35-4_79_2_98_2_39:4.15.2.13.2.2
	Kernel-5_35-4_79_2_98_2_38:4.15.2.13.2.2
	Kernel-5_35-4_79_2_113:4.15.2.13
	Kernel-5_35-4_79_2_112:4.15.2.13
	Kernel-5_35-4_79_2_98_2_37:4.15.2.13.2.2
	Kernel-5_35-4_79_2_98_2_36:4.15.2.13.2.2
	Kernel-5_35-4_79_2_98_2_35:4.15.2.13.2.2
	Kernel-5_35-4_79_2_98_2_34:4.15.2.13.2.1
	Kernel-5_35-4_79_2_98_2_33:4.15.2.13
	Kernel-5_35-4_79_2_98_2_32:4.15.2.13
	Kernel-5_35-4_79_2_98_2_31:4.15.2.13
	Kernel-5_35-4_79_2_98_2_30:4.15.2.13
	Kernel-5_35-4_79_2_98_2_29:4.15.2.13
	Kernel-5_35-4_79_2_98_2_28:4.15.2.13
	Kernel-5_35-4_79_2_98_2_27:4.15.2.13
	Kernel-5_35-4_79_2_98_2_26:4.15.2.13
	Kernel-5_35-4_79_2_111:4.15.2.13
	Kernel-5_35-4_79_2_98_2_25:4.15.2.13
	Kernel-5_35-4_79_2_98_2_24:4.15.2.13
	Kernel-5_35-4_79_2_98_2_23:4.15.2.13
	Kernel-5_35-4_79_2_110:4.15.2.13
	Kernel-5_35-4_79_2_98_2_22:4.15.2.13
	Kernel-5_35-4_79_2_109:4.15.2.13
	Kernel-5_35-4_79_2_98_2_21:4.15.2.13
	Kernel-5_35-4_79_2_98_2_20:4.15.2.13
	Kernel-5_35-4_79_2_108:4.15.2.13
	Kernel-5_35-4_79_2_107:4.15.2.13
	Kernel-5_35-4_79_2_98_2_19:4.15.2.13
	Kernel-5_35-4_79_2_98_2_18:4.15.2.13
	Kernel-5_35-4_79_2_98_2_17:4.15.2.13
	Kernel-5_35-4_79_2_98_2_16:4.15.2.13
	Kernel-5_35-4_79_2_98_2_15:4.15.2.13
	Kernel-5_35-4_79_2_106:4.15.2.13
	Kernel-5_35-4_79_2_105:4.15.2.13
	Kernel-5_35-4_79_2_104:4.15.2.13
	Kernel-5_35-4_79_2_98_2_14:4.15.2.13
	Kernel-5_35-4_79_2_98_2_13:4.15.2.13
	Kernel-5_35-4_79_2_98_2_12:4.15.2.13
	Kernel-5_35-4_79_2_98_2_11:4.15.2.13
	Kernel-5_35-4_79_2_98_2_10:4.15.2.13
	Kernel-5_35-4_79_2_98_2_9:4.15.2.13
	Kernel-5_35-4_79_2_103:4.15.2.13
	Kernel-5_35-4_79_2_102:4.15.2.13
	Kernel-5_35-4_79_2_98_2_8:4.15.2.13
	Kernel-5_35-4_79_2_98_2_7:4.15.2.13
	Kernel-5_35-4_79_2_98_2_6:4.15.2.13
	Kernel-5_35-4_79_2_98_2_5:4.15.2.13
	Kernel-5_35-4_79_2_98_2_4:4.15.2.13
	Kernel-5_35-4_79_2_101:4.15.2.13
	Kernel-5_35-4_79_2_100:4.15.2.13
	Kernel-5_35-4_79_2_99:4.15.2.13
	Kernel-5_35-4_79_2_98_2_3:4.15.2.13
	Kernel-5_35-4_79_2_98_2_2:4.15.2.13
	Kernel-5_35-4_79_2_98_2_1:4.15.2.13
	Cortex:4.15.2.13.0.2
	Cortex_bp:4.15.2.13
	Kernel-5_35-4_79_2_98:4.15.2.13
	Kernel-5_35-4_79_2_97:4.15.2.13
	Kernel-5_35-4_79_2_96:4.15.2.13
	Kernel-5_35-4_79_2_95:4.15.2.13
	Kernel-5_35-4_79_2_94:4.15.2.13
	Kernel-5_35-4_79_2_93:4.15.2.13
	Kernel-5_35-4_79_2_92:4.15.2.13
	Kernel-5_35-4_79_2_91:4.15.2.13
	Kernel-5_35-4_79_2_90:4.15.2.13
	Kernel-5_35-4_79_2_89:4.15.2.12
	Kernel-5_35-4_79_2_88:4.15.2.12
	Kernel-5_35-4_79_2_87:4.15.2.12
	Kernel-5_35-4_79_2_86:4.15.2.12
	Kernel-5_35-4_79_2_85:4.15.2.12
	Kernel-5_35-4_79_2_84:4.15.2.12
	Kernel-5_35-4_79_2_83:4.15.2.12
	Kernel-5_35-4_79_2_82:4.15.2.12
	Kernel-5_35-4_79_2_81:4.15.2.12
	Kernel-5_35-4_79_2_80:4.15.2.12
	Kernel-5_35-4_79_2_79:4.15.2.12
	Kernel-5_35-4_79_2_78:4.15.2.12
	Kernel-5_35-4_79_2_77:4.15.2.11
	RO_5_07:4.15.2.11
	Kernel-5_35-4_79_2_76:4.15.2.11
	Kernel-5_35-4_79_2_75:4.15.2.11
	Kernel-5_35-4_79_2_74:4.15.2.11
	Kernel-5_35-4_79_2_73:4.15.2.11
	Kernel-5_35-4_79_2_72:4.15.2.11
	Kernel-5_35-4_79_2_71:4.15.2.11
	Kernel-5_35-4_79_2_70:4.15.2.11
	Kernel-5_35-4_79_2_69:4.15.2.11
	Kernel-5_35-4_79_2_68:4.15.2.11
	Kernel-5_35-4_79_2_67:4.15.2.11
	Kernel-5_35-4_79_2_66:4.15.2.11
	Kernel-5_35-4_79_2_65:4.15.2.11
	Kernel-5_35-4_79_2_64:4.15.2.11
	Kernel-5_35-4_79_2_63:4.15.2.11
	Kernel-5_35-4_79_2_62:4.15.2.11
	Kernel-5_35-4_79_2_61:4.15.2.11
	Kernel-5_35-4_79_2_59:4.15.2.11
	Kernel-5_35-4_79_2_58:4.15.2.10
	Kernel-5_35-4_79_2_57:4.15.2.10
	Kernel-5_35-4_79_2_56:4.15.2.10
	Kernel-5_35-4_79_2_55:4.15.2.10
	Kernel-5_35-4_79_2_54:4.15.2.9
	Kernel-5_35-4_79_2_53:4.15.2.9
	Kernel-5_35-4_79_2_52:4.15.2.9
	Kernel-5_35-4_79_2_51:4.15.2.9
	Kernel-5_35-4_79_2_50:4.15.2.8
	Kernel-5_35-4_79_2_49:4.15.2.8
	Kernel-5_35-4_79_2_48:4.15.2.8
	Kernel-5_47:4.16
	Kernel-5_46-4_90_2_1:4.16
	nbingham_Kernel_FastNC_dev_bp:4.16
	nbingham_Kernel_FastNC_dev:4.16.0.2
	Kernel-5_46:4.16
	Kernel-5_45:4.16
	Kernel-5_35-4_79_2_47:4.15.2.7
	Kernel-5_35-4_79_2_46:4.15.2.7
	Kernel-5_35-4_79_2_45:4.15.2.7
	Kernel-5_35-4_79_2_44:4.15.2.7
	Kernel-5_35-4_79_2_25_2_2:4.15.2.4
	Kernel-5_35-4_79_2_43:4.15.2.7
	Kernel-5_35-4_79_2_42:4.15.2.7
	Kernel-5_35-4_79_2_41:4.15.2.7
	Kernel-5_35-4_79_2_40:4.15.2.6
	Kernel-5_35-4_79_2_39:4.15.2.6
	Kernel-5_35-4_79_2_38:4.15.2.6
	Kernel-5_35-4_79_2_37:4.15.2.5
	Kernel-5_35-4_79_2_36:4.15.2.5
	Kernel-5_35-4_79_2_35:4.15.2.5
	Kernel-5_35-4_79_2_34:4.15.2.5
	Kernel-5_35-4_79_2_33:4.15.2.5
	Kernel-5_35-4_79_2_32:4.15.2.4
	Kernel-5_44:4.16
	Kernel-5_35-4_79_2_25_2_1:4.15.2.4
	Kernel-5_43:4.16
	Kernel-5_35-4_79_2_31:4.15.2.4
	Kernel-5_35-4_79_2_30:4.15.2.4
	Kernel-5_35-4_79_2_29:4.15.2.4
	Kernel-5_35-4_79_2_28:4.15.2.4
	Kernel-5_35-4_79_2_27:4.15.2.4
	Kernel-5_35-4_79_2_26:4.15.2.4
	Kernel-5_42:4.15
	Kernel-5_41:4.15
	Kernel-5_40:4.15
	Kernel-5_35-4_79_2_25:4.15.2.4
	Kernel-5_35-4_79_2_24:4.15.2.4
	Kernel-5_35-4_79_2_23:4.15.2.4
	Kernel-5_35-4_79_2_22:4.15.2.4
	Kernel-5_35-4_79_2_21:4.15.2.4
	Kernel-5_35-4_79_2_20:4.15.2.4
	Kernel-5_35-4_79_2_19:4.15.2.4
	Kernel-5_35-4_79_2_18:4.15.2.4
	Kernel-5_35-4_79_2_17:4.15.2.4
	Kernel-5_35-4_79_2_16:4.15.2.4
	Kernel-5_35-4_79_2_15:4.15.2.4
	Kernel-5_35-4_79_2_14:4.15.2.4
	Kernel-5_39:4.15
	Kernel-5_13-4_52_2_1:4.8
	Bethany:4.8.0.2
	Kernel-5_38:4.15
	Kernel-5_35-4_79_2_13:4.15.2.4
	Kernel-5_35-4_79_2_12:4.15.2.4
	Kernel-5_35-4_79_2_11:4.15.2.4
	Kernel-5_37:4.15
	Kernel-5_35-4_79_2_10:4.15.2.4
	Kernel-5_35-4_79_2_9:4.15.2.3
	Kernel-5_36:4.15
	Kernel-5_35-4_79_2_8:4.15.2.2
	Kernel-5_35-4_79_2_7:4.15.2.1
	Kernel-5_35-4_79_2_6:4.15.2.1
	Kernel-5_35-4_79_2_5:4.15.2.1
	Kernel-5_35-4_79_2_4:4.15.2.1
	Kernel-5_35-4_79_2_3:4.15.2.1
	Kernel-5_35-4_79_2_2:4.15.2.1
	dellis_autobuild_BaseSW:4.15
	Kernel-5_35-4_79_2_1:4.15.2.1
	HAL:4.15.0.2
	Kernel-5_35:4.15
	Kernel-5_34:4.15
	Kernel-5_33:4.14
	Kernel-5_32:4.13
	Kernel-5_31:4.13
	Kernel-5_30:4.13
	Kernel-5_29:4.13
	Kernel-5_28:4.13
	Kernel-5_27:4.13
	Kernel-5_26:4.13
	Kernel-5_25:4.13
	Kernel-5_24:4.12
	Kernel-5_23:4.11
	Kernel-5_22:4.10
	sbrodie_sedwards_16Mar2000:4.10
	Kernel-5_21:4.10
	Kernel-5_20:4.10
	Kernel-5_19:4.10
	Kernel-5_18:4.10
	Kernel-5_17:4.10
	Kernel-5_16:4.9
	Kernel-5_15:4.9
	Kernel-5_14:4.8
	Kernel-5_13:4.8
	Kernel-5_12:4.8
	Kernel-5_11:4.8
	Kernel-5_10:4.8
	Kernel-5_09:4.8
	Kernel-5_08:4.7
	Kernel-5_07:4.7
	Kernel-5_06:4.6
	Kernel-5_05:4.6
	Kernel-5_04:4.6
	Kernel-5_03:4.6
	Kernel-5_02:4.6
	Kernel-5_01:4.6
	Kernel-5_00:4.5
	Kernel-4_99:4.4
	Kernel-4_98:4.4
	Kernel-4_97:4.4
	Kernel-4_96:4.4
	Kernel-4_95:4.4
	Kernel-4_94:4.4
	Kernel-4_93:4.4
	Kernel-4_92:4.4
	Kernel-4_91:4.4
	Kernel-4_90:4.4
	dcotton_autobuild_BaseSW:4.16
	Kernel-4_89:4.4
	Kernel-4_88:4.4
	Kernel-4_87:4.4
	Kernel-4_86:4.4
	Kernel-4_85:4.4
	sbrodie_UrsulaRiscPC_Kernel_19Aug99:4.3.2.4.2.1
	Kernel-4_84:4.4
	sbrodie_UrsulaRiscPC_Kernel_18Aug99:4.3.2.4.2.1
	Ursula_RiscPC_bp:4.3.2.4
	Kernel-4_83:4.4
	Kernel-4_82:4.4
	Kernel-4_81:4.4
	Kernel-4_80:4.4
	Kernel-4_79:4.4
	Kernel-4_78:4.4
	Kernel-4_77:4.4
	Kernel-4_76:4.4
	Kernel-4_75:4.4
	Kernel-4_74:4.4
	Kernel-4_73:4.4
	Kernel-4_72:4.4
	Kernel-4_71:4.4
	Kernel-4_70:4.4
	Kernel-4_69:4.4
	Kernel-4_68:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.4.2.1
	Ursula_RiscPC:4.3.2.4.0.2
	Kernel-4_63-1_1_2_5:4.1.7.1
	Kernel-4_63-1_1_2_4:4.1.7.1
	Kernel-4_67:4.3
	Kernel-4_66:4.3
	Kernel-4_63-1_1_2_3:4.1.7.1
	Kernel-4_65:4.3
	Ursula_merge:4.3
	Kernel-4_64:4.3
	mstphens_Kernel-3_81:4.3.2.5
	Kernel-4_63-1_1_2_2:4.1.7.1
	nicke_Kernel_4_62:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.3.2.4
	UrsulaBuild_FinalSoftload:4.3.2.4
	rthornb_UrsulaBuild-12Aug1998:4.3.2.4
	aglover_UrsulaBuild-05Aug1998:4.3.2.4
	rthornb_UrsulaBuild-29Jul1998:4.3.2.4
	rthornb_UrsulaBuild-22Jul1998:4.3.2.4
	nturton_v459:4.1.7.1
	nturton_v460:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.3.2.4
	rthornb_UrsulaBuild-07Jul1998:4.3.2.4
	rthornb_UrsulaBuild-17Jun1998:4.3.2.4
	rthornb_UrsulaBuild-03Jun1998:4.3.2.4
	rthornb_UrsulaBuild-27May1998:4.3.2.4
	mstphens_Kernel-3_80:4.3.2.4
	rthornb_UrsulaBuild-21May1998:4.3.2.4
	afrost_Boca-1_2-Beta:4.1.7.1
	rthornb_UrsulaBuild_01May1998:4.3.2.4
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula_bp:4.3
	Ursula:4.3.0.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.24
date	2018.02.21.21.16.20;	author jlee;	state Exp;
branches;
next	4.23;
commitid	mcudYbBpjbNFSLrA;

4.23
date	2017.06.18.11.18.42;	author rool;	state Exp;
branches
	4.23.2.1;
next	4.22;
commitid	qaj5Dxec3RVSxQVz;

4.22
date	2017.03.05.15.46.06;	author rool;	state Exp;
branches;
next	4.21;
commitid	dJn0Mnw2lDlTonIz;

4.21
date	2016.08.08.19.36.05;	author jlee;	state Exp;
branches;
next	4.20;
commitid	H8u6i41kmeEioxhz;

4.20
date	2016.06.30.20.59.46;	author jlee;	state Exp;
branches;
next	4.19;
commitid	skOEjp3ipLHx6xcz;

4.19
date	2016.06.30.20.42.05;	author jlee;	state Exp;
branches;
next	4.18;
commitid	bDF3DCxdmyMD0xcz;

4.18
date	2016.06.30.20.28.56;	author jlee;	state Exp;
branches;
next	4.17;
commitid	lMnWzoE9eJz3Wwcz;

4.17
date	2016.06.30.20.08.08;	author jlee;	state Exp;
branches;
next	4.16;
commitid	IWoXxARWeuLDOwcz;

4.16
date	2001.05.25.13.27.33;	author srevill;	state Exp;
branches;
next	4.15;

4.15
date	2000.09.07.18.41.24;	author rcathera;	state Exp;
branches
	4.15.2.1;
next	4.14;

4.14
date	2000.09.04.18.47.58;	author rcathera;	state Exp;
branches;
next	4.13;

4.13
date	2000.04.17.14.22.52;	author kbracey;	state Exp;
branches;
next	4.12;

4.12
date	2000.04.12.13.58.38;	author sbrodie;	state Exp;
branches;
next	4.11;

4.11
date	2000.04.04.14.27.31;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	2000.02.22.14.46.21;	author pskirrow;	state Exp;
branches;
next	4.9;

4.9
date	2000.02.02.11.59.08;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	2000.01.20.18.00.32;	author pskirrow;	state Exp;
branches;
next	4.7;

4.7
date	99.11.02.15.34.36;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	99.10.25.16.48.58;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	99.10.19.14.48.01;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.02.09.10.57.39;	author nturton;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.05.51.52;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.14.07.09;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.41.21;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.23.2.1
date	2018.05.14.19.33.43;	author jlee;	state Exp;
branches;
next	;
commitid	wrVtYH84nAz1GiCA;

4.15.2.1
date	2000.09.15.12.38.01;	author kbracey;	state Exp;
branches;
next	4.15.2.2;

4.15.2.2
date	2000.10.05.16.46.36;	author dellis;	state Exp;
branches;
next	4.15.2.3;

4.15.2.3
date	2000.10.09.15.59.15;	author kbracey;	state Exp;
branches;
next	4.15.2.4;

4.15.2.4
date	2000.10.16.11.55.38;	author kbracey;	state Exp;
branches;
next	4.15.2.5;

4.15.2.5
date	2001.06.11.11.33.32;	author kbracey;	state Exp;
branches;
next	4.15.2.6;

4.15.2.6
date	2001.06.18.14.49.44;	author mstephen;	state Exp;
branches;
next	4.15.2.7;

4.15.2.7
date	2001.06.26.09.37.11;	author mstephen;	state Exp;
branches;
next	4.15.2.8;

4.15.2.8
date	2002.10.07.17.29.41;	author kbracey;	state Exp;
branches;
next	4.15.2.9;

4.15.2.9
date	2002.11.30.00.31.08;	author bavison;	state Exp;
branches;
next	4.15.2.10;

4.15.2.10
date	2003.01.27.15.25.34;	author kbracey;	state Exp;
branches;
next	4.15.2.11;

4.15.2.11
date	2003.03.31.09.44.10;	author kbracey;	state Exp;
branches;
next	4.15.2.12;

4.15.2.12
date	2004.10.13.13.20.10;	author bavison;	state Exp;
branches;
next	4.15.2.13;

4.15.2.13
date	2005.09.16.15.48.08;	author srevill;	state Exp;
branches
	4.15.2.13.2.1;
next	4.15.2.14;

4.15.2.14
date	2011.07.31.13.48.13;	author jlee;	state Exp;
branches;
next	4.15.2.15;
commitid	o0Go7NdMMK4UrGtv;

4.15.2.15
date	2011.08.03.23.46.21;	author jlee;	state Exp;
branches;
next	4.15.2.16;
commitid	uz6Vep4mDx27F7uv;

4.15.2.16
date	2011.08.07.19.29.00;	author jlee;	state Exp;
branches;
next	4.15.2.17;
commitid	eaiKjtqFrPbS6Cuv;

4.15.2.17
date	2011.11.26.21.11.16;	author jlee;	state Exp;
branches;
next	4.15.2.18;
commitid	cI3W0zbtALQG6TIv;

4.15.2.18
date	2011.11.27.19.18.16;	author rsprowson;	state Exp;
branches;
next	4.15.2.19;
commitid	iuIXfUOByAFYr0Jv;

4.15.2.19
date	2012.02.25.16.19.37;	author jlee;	state Exp;
branches
	4.15.2.19.2.1;
next	4.15.2.20;
commitid	ad3WnPntkzrizyUv;

4.15.2.20
date	2012.06.21.07.59.24;	author rsprowson;	state Exp;
branches;
next	4.15.2.21;
commitid	IX8PhIHHo1Sy2y9w;

4.15.2.21
date	2012.06.26.20.35.57;	author jlee;	state Exp;
branches;
next	4.15.2.22;
commitid	QbbsHXeVebu94gaw;

4.15.2.22
date	2012.07.01.21.26.41;	author rsprowson;	state Exp;
branches;
next	4.15.2.23;
commitid	K3GB4gteEYUubUaw;

4.15.2.23
date	2012.12.05.01.16.19;	author jlee;	state Exp;
branches;
next	4.15.2.24;
commitid	jNXy5BkvBl5srYuw;

4.15.2.24
date	2013.01.10.21.19.09;	author rsprowson;	state Exp;
branches;
next	4.15.2.25;
commitid	F6D8WGw2f7PkWHzw;

4.15.2.25
date	2013.03.28.21.36.24;	author jlee;	state Exp;
branches;
next	4.15.2.26;
commitid	UN0GP6eB0LlNyBJw;

4.15.2.26
date	2013.04.07.17.29.23;	author jlee;	state Exp;
branches;
next	4.15.2.27;
commitid	iU1snv0XxarbSRKw;

4.15.2.27
date	2013.08.06.22.43.05;	author jlee;	state Exp;
branches;
next	4.15.2.28;
commitid	TOIaeUf2Q4rBIr0x;

4.15.2.28
date	2014.04.20.17.00.22;	author jlee;	state Exp;
branches;
next	4.15.2.29;
commitid	6eesW4yWEAvSyrxx;

4.15.2.29
date	2014.08.29.18.45.35;	author jlee;	state Exp;
branches;
next	4.15.2.30;
commitid	9jew7cvwwQoVVhOx;

4.15.2.30
date	2014.12.06.09.42.44;	author rsprowson;	state Exp;
branches;
next	4.15.2.31;
commitid	IIeZ2aoECRgpKX0y;

4.15.2.31
date	2015.03.29.16.17.31;	author jlee;	state Exp;
branches;
next	4.15.2.32;
commitid	CkLUvkbu9J2Eiwfy;

4.15.2.32
date	2015.07.13.18.58.43;	author jlee;	state Exp;
branches;
next	4.15.2.33;
commitid	5MW5L8DrRhNFM9ty;

4.15.2.33
date	2015.07.17.00.28.27;	author jlee;	state Exp;
branches;
next	4.15.2.34;
commitid	s5cS0yKIca1Nvzty;

4.15.2.34
date	2015.08.05.21.51.31;	author jlee;	state Exp;
branches;
next	4.15.2.35;
commitid	SpZpzVH47zb408wy;

4.15.2.35
date	2015.08.31.19.28.37;	author jlee;	state Exp;
branches;
next	4.15.2.36;
commitid	Ni3KL17bG70fnszy;

4.15.2.36
date	2015.10.07.20.31.01;	author jlee;	state Exp;
branches;
next	4.15.2.37;
commitid	WoBQRf5bYZBWwdEy;

4.15.2.37
date	2016.01.05.21.29.13;	author rsprowson;	state Exp;
branches;
next	4.15.2.38;
commitid	1c4UwSKrWAexXMPy;

4.15.2.38
date	2016.04.05.19.36.35;	author jlee;	state Exp;
branches;
next	4.15.2.39;
commitid	8RLqvkae1X7wpt1z;

4.15.2.39
date	2016.05.19.21.03.49;	author jlee;	state Exp;
branches;
next	;
commitid	7f3vfXP8BWCNt87z;

4.15.2.13.2.1
date	2011.02.20.01.08.45;	author jlee;	state Exp;
branches;
next	4.15.2.13.2.2;

4.15.2.13.2.2
date	2011.02.20.01.24.10;	author jlee;	state Exp;
branches;
next	4.15.2.13.2.3;

4.15.2.13.2.3
date	2011.07.31.13.39.19;	author jlee;	state Exp;
branches;
next	4.15.2.13.2.4;
commitid	tnhfpNorgEFQoGtv;

4.15.2.13.2.4
date	2011.08.03.23.52.04;	author jlee;	state Exp;
branches;
next	4.15.2.13.2.5;
commitid	LLn4KPy3Hjh5H7uv;

4.15.2.13.2.5
date	2011.08.04.20.01.07;	author jlee;	state Exp;
branches;
next	4.15.2.13.2.6;
commitid	hliJi7339nhRneuv;

4.15.2.13.2.6
date	2011.08.07.19.26.28;	author jlee;	state Exp;
branches;
next	4.15.2.13.2.7;
commitid	91YMAm9KaDtZ5Cuv;

4.15.2.13.2.7
date	2011.08.08.23.28.26;	author jlee;	state Exp;
branches;
next	4.15.2.13.2.8;
commitid	D7rzILnwRRSXoLuv;

4.15.2.13.2.8
date	2011.09.24.19.55.54;	author jlee;	state Exp;
branches;
next	;
commitid	kEjQnYmCIZvfIMAv;

4.15.2.19.2.1
date	2012.06.24.21.15.35;	author jlee;	state Exp;
branches;
next	4.15.2.19.2.2;
commitid	fa2KxQVB4EkKl0aw;

4.15.2.19.2.2
date	2012.09.18.15.50.02;	author jlee;	state Exp;
branches;
next	;
commitid	jeuxYpI6CQUxM1lw;

4.3.2.1
date	97.09.09.13.33.19;	author mstphens;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	97.10.21.15.31.20;	author mstphens;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	97.12.08.14.34.30;	author mstphens;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	98.03.26.11.25.50;	author mstphens;	state Exp;
branches
	4.3.2.4.2.1;
next	4.3.2.5;

4.3.2.5
date	98.09.24.13.17.14;	author mstphens;	state Exp;
branches;
next	;

4.3.2.4.2.1
date	98.11.23.14.59.14;	author mstphens;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.41.21;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.06.02.00.35;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.08.09.27;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.16.46.05;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.11.20;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.21.03.41;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.24
log
@Make it easier to debug aborts that were triggered by ABT/UND code
Detail:
  s/Middle - Tweak register dump generation so that it'll attempt to provide sensible R13 & R14 values if the abort came from the same mode that we're handling the abort in. R13 will be adjusted by however much data we've pushed onto the stack, and R14 will be set to &DEADDEAD to indicate that the CPU has corrupted it and we don't know what the original value was.
Admin:
  Tested on BB-xM


Version 5.98. Tagged as 'Kernel-5_98'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        TTL     => Middle

; Compatibility fudgery for OS_ReadLine and ReadLineV with 32-bit addresses

ReadLineSWI
        Push    "r4,lr"
        MOV     r4, #0
        SWI     XOS_ReadLine32
        Pull    "r4,lr"
        ; Pass back NZCV bits
        MRS     r11, CPSR
      [ NoARMT2
        BIC     lr,  lr,  #N_bit+Z_bit+C_bit+V_bit
        AND     r11, r11, #N_bit+Z_bit+C_bit+V_bit
        ORR     lr, lr, r11
      |
        ASSERT (N_bit+Z_bit+C_bit+V_bit)=&F0000000
        MOV     r11, r11, LSR #28
        BFI     lr, r11, #28, #4
      ]
        B       SLVK

ReadLine32SWI
        MOV     r11, #OS_ReadLine
        B       VecSwiDespatch

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; VecRdLine - Read line from input stream (OSWORD 0 equivalent)

; In    r0 -> buffer for characters
;       r1 =  max length of line (excluding carriage return)
;       r2 = lowest character put into buffer
;       r3 = highest character put into buffer
;       r4 = flags
;               bit 31 set means don't reflect characters that don't go in the buffer
;               bit 30 set means reflect with the character in R4
;               bits 7-0 = character to echo if r4 bit 30 is set
;       wp -> OsbyteVars

; Out   r0, r2, r3 corrupted
;       r1 = length of line (excluding carriage return)
;       C=0 => line terminated by return (CR or LF)
;       C=1 => line terminated by ESCAPE

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

VecRdLine ROUT

        Push    "R4-R7"

        MOV     R7, R4                  ; R7 = flags + echo byte
        MOV     R4, R0                  ; R4 -> buffer

        MOV     R6, #0                  ; R6 = index into buffer
        STRB    R6, PageModeLineCount   ; reset page lines

        B       %FT10
        LTORG

05
        SWI     XOS_WriteC
        BVS     ReadLine_Vset
10
        SWI     XOS_ReadC
        BVS     ReadLine_Vset
        BCS     %FT70                   ; ESCAPE

        LDRB    R5, WrchDest            ; does output include VDU ?
        TST     R5, #2
        BNE     %FT30                   ; no, then still buffer

        LDRB    R5, VDUqueueItems       ; is VDU queueing ?
        TEQ     R5, #0
        BNE     %BT05                   ; yes, then just print

30
        TEQ     R0, #127                ; is it DELETE ?
        TEQNE   R0, #8                  ; or backspace?
        BNE     %FT40                   ; no, then skip

        TEQ     R6, #0                  ; yes, then have we any chars ?
        BEQ     %BT10                   ; no, then loop
        SUB     R6, R6, #1              ; go back 1 char
        MOV     R0, #127
        B       %BT05                   ; print DEL and loop

40
        TEQ     R0, #21                 ; is it CTRL-U ?
        BNE     %FT50                   ; no, then skip

        TEQ     R6, #0                  ; yes, then have we any chars ?
        BEQ     %BT10                   ; no, then loop

45
        SWI     XOS_WriteI+127          ; print DELs to start of line
        BVS     ReadLine_Vset
        SUBS    R6, R6, #1
        BNE     %BT45
        B       %BT10                   ; then loop

50
        TEQ     R0, #13                 ; is it CR ?
        TEQNE   R0, #10                 ; or LF ?
        MOVEQ   r0, #13                 ; always store CR if so
        STRB    R0, [R4, R6]            ; store byte in buffer
        BEQ     %FT60                   ; Exit if either

        CMP     R6, R1                  ; is buffer full ?
        MOVCS   R0, #7                  ; if so, beep and loop
        BCS     %BT05

        CMP     R0, R2                  ; is char >= min ?
        CMPCS   R3, R0                  ; and char <= max ?
        ADDCS   R6, R6, #1              ; if so, then inc pointer
        BCS     %FT80
        TST     R7, #&80000000          ; no reflection
        BNE     %BT10                   ; of non-entered chars

80      TST     R7, #&40000000
        ANDNE   R0, R7, #&FF            ; echo char -> R0

        B       %BT05                   ; echo character

60      SWI     XOS_NewLine
        BVS     ReadLine_Vset

; insert code here to call NetVec with R0 = &0D

70
        CLRV
EndReadLine
        MOVVC   R0, R4                  ; restore R0
        LDR     R5, =ZeroPage
        LDRB    R5, [R5, #ESC_Status]
        MOVS    R5, R5, LSL #(32-6)     ; shift esc bit into carry

        MOV     R1, R6                  ; R1 := length
        Pull    "R4-R7, pc"             ; Always claiming vector

ReadLine_Vset
        SETV
        B       EndReadLine

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_Control (deprecated): set handlers

SCTRL   Push    "R0-R3, lr"

        WritePSRc SVC_mode+I_bit, R0    ; need IRQs off to get consistent state
        MOV     R0, #EventHandler
        MOV     R1, R3
        BL      CallCESWI
        STR     R1, [stack, #3*4]

        MOV     R0, #EscapeHandler
        LDR     R1, [stack, #2*4]
        BL      CallCESWI
        STR     R1, [stack, #2*4]

        MOV     R0, #ErrorHandler
        Pull    "R1, R3"
        BL      CallCESWI
        MOV     R0, R1
        MOV     R1, R3

        Pull    "R2, R3, lr"
        ExitSWIHandler


CallCESWI
        Push    lr
        MOV     r2, #0                  ; readonly
        SWI     XOS_ChangeEnvironment
        Pull    pc

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_SetEnv (deprecated): Environment setting

SSTENV  Push    "R0, R1, lr"
        WritePSRc SVC_mode+I_bit, R0    ; no irqs - want consistent set.
        MOV     R0, #AddressExceptionHandler
        MOV     R1, R7
        SWI     XOS_ChangeEnvironment
        MOV     R7, R1

        MOV     R0, #DataAbortHandler
        MOV     R1, R6
        SWI     XOS_ChangeEnvironment
        MOV     R6, R1

        MOV     R0, #PrefetchAbortHandler
        MOV     R1, R5
        SWI     XOS_ChangeEnvironment
        MOV     R5, R1

        MOV     R0, #UndefinedHandler
        MOV     R1, R4
        SWI     XOS_ChangeEnvironment
        MOV     R4, R1

        MOV     R0, #MemoryLimit
        LDR     R1, [stack, #4]
        SWI     XOS_ChangeEnvironment
        STR     R1, [stack, #4]

        MOV     R0, #ExitHandler
        Pull    "R1"
        BL      CallCESWI
        Push    "R1"

        LDR     R12, =ZeroPage
        LDR     R2, [R12, #RAMLIMIT]    ; this is read-only
        MOV     R3, #0                  ; never any Brazil-type buffering
                                        ; m2 tools will complain if there is!
        Pull    "R0, R1, lr"
        ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Change user state SWIs
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SINTON  BIC     lr, lr, #I32_bit
        ExitSWIHandler

SINTOFF ORR     lr, lr, #I32_bit
        ExitSWIHandler

SENTERSWI
        TST   lr, #2_11100
        ORREQ lr, lr, #SVC26_mode       ; 26-bit modes -> SVC26
        BICNE lr, lr, #2_11111
        ORRNE lr, lr, #SVC32_mode       ; others -> SVC32
        ExitSWIHandler

SLEAVESWI
        BIC   lr, lr, #2_01111
        ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_BreakPt: user breakpoint - unsuitable for debugging SVC mode code!

SBRKPT ROUT

        ADD     sp, sp, #4              ; discard stacked SWI number
        LDR     r10, =ZeroPage
        LDR     r10, [r10, #BrkBf]
        STR     r12, [r10, #16*4]       ; original PSR (with V)
        Pull    r14
        TST     r12, #T32_bit
        SUBEQ   r14, r14, #4
        SUBNE   r14, r14, #2            ; r14 = PC of the SWI
        TST     r12, #2_01111
        STR     r14, [r10, #15*4]       ; PC of the SWI put in.
        BNE     %FT01                   ; NE if not in user mode
        STR     r0, [r10], #4
        MOV     r0, r10
        LDMFD   sp, {r10-r12}

  [ SASTMhatbroken
        STMIA   r0!,{r1-r12}
        STMIA   r0, {r13_usr,r14_usr}^ ; user mode case done.
        SUB     r0, r0, #12*4
  |
        STMIA   r0, {r1-r12, r13_usr, r14_usr}^ ; user mode case done.
        NOP
  ]

10      LDR     stack, =SVCSTK
        LDR     r12, =ZeroPage+BrkAd_ws
        LDMIA   r12, {r12, pc}          ; call breakpoint handler

; Non-user mode case
01      AND     r11, r12, #2_01111      ; SVC26/SVC32 mode?
        TEQ     r11, #SVC_mode
        BEQ     %FT02                   ; [yes]

; Non-user, non-supervisor - must be IRQ, ABT, UND or SYS (no SWIs from FIQ)
        STR     r0, [r10], #4
        MOV     r0, r10
        BIC     r14, r12, #T32_bit      ; don't go into Thumb mode
        LDMFD   sp, {r10-r12}           ; Not banked
        MSR     CPSR_c, R14             ; get at registers r13 and r14
        STMIA   r0, {r1-r12}
        STR     sp, [r0, #12*4]
        STR     r14, [r0, #13*4]
        WritePSRc SVC_mode, r12
        B       %BT10

; Supervisor mode case
02      MOV     r14, r10                ; supervisor mode. R14 in buffer dead
        LDMFD   sp!, {r10-r12}
        STMIA   r14, {r0-r12}
        STR     r13, [r14, #13*4]
        LDR     r12, =&DEADDEAD
        STR     r12, [r14, #14*4]       ; mark R14 as dead
        B       %BT10

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_UnusedSWI (deprecated): Set the unused SWI handler

SUNUSED Push    "R1, lr"
        MOV     R1, R0
        MOV     R0, #UnusedSWIHandler
        SWI     XOS_ChangeEnvironment
        MOV     R0, R1
        Pull    "R1, lr"
        ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_SetCallBack: Set callback flag

SSETCALL ROUT

        MSR     CPSR_c, #I32_bit + SVC32_mode
        LDR     r10, =ZeroPage
        LDRB    r11, [r10, #CallBack_Flag]
        ORR     r11, r11, #CBack_OldStyle
        STRB    r11, [r10, #CallBack_Flag]
        ADD     sp, sp, #4              ; Skip saved R11
        B       back_to_user_irqs_already_off
                                        ; Do NOT exit via normal mechanism

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI read mouse information
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

VecMouse
     WritePSRc SVC_mode+I_bit, R10
     MOV   R10, #MouseV
     Push "lr"
     BL    CallVector
     Pull "lr"
     ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_SerialOp when not in kernel
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

SerialOp ROUT
        MOV     r10, #SerialV
        Push    lr
        BL      CallVector
        Pull    lr
        BICCC   lr, lr, #C_bit
        ORRCS   lr, lr, #C_bit
        B       SLVK_TestV

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Supervisor routines to set default handlers
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; Reset Error and Escape handlers

DEFHAN LDR  R1, =GeneralMOSBuffer         ; decent length error buffer
       ADR  R0, ERRORH
       ADR  R2, ESCAPH
       MOV  R3, #0
       MOV  R4, R14
       SWI  XOS_Control

       MOV  r0, #UpCallHandler
       ADR  r1, DefUpcallHandler
       MOV  r2, #0
       SWI  XOS_ChangeEnvironment

       MOV  PC, R4

; Reset Exception, Event, BreakPoint, UnusedSWI, Exit and CallBack handlers

DEFHN2 MOV  R12, R14
       MOV  R0, #0
       MOV  R1, #0
       MOV  R2, #0
       ADR  R3, EVENTH
       SWI  XOS_Control
       LDR  R0, =ZeroPage+DUMPER
       ADR  R1, NOCALL
       SWI  XOS_CallBack
       ADRL R0, CLIEXIT
       MOV  R1, #0
       MOV  R2, #0
       ADRL R4, UNDEF
       ADRL R5, ABORTP
       ADRL R6, ABORTD
       ADRL R7, ADDREX
       SWI  XOS_SetEnv
       LDR  R0, =ZeroPage+DUMPER
       ADR  R1, DEFBRK
       SWI  XOS_BreakCtrl
       ADRL R0, NoHighSWIHandler
       SWI  XOS_UnusedSWI
       MOV  PC, R12

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; system handlers
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DefUpcallHandler
ESCAPH
EVENTH  MOV     pc, lr


NOCALL  LDR     r0, =ZeroPage               ; default callback routine
        LDR     r14, [r0, #CallBf]
        LDR     r0, [r14, #4*16]
        MSR     SPSR_cxsf, r0
        LDMIA   r14, {r0-r12, r13_usr, r14_usr}^ ; load user's regs
        NOP
        LDR     r14, [r14, #4*15]
        MOVS    pc, r14


ERRORH ROUT

      [ International
        SWI     XOS_EnterOS

        LDR     R0,=ZeroPage+KernelMessagesBlock+4
        ADR     R1,ErrorToken
        MOV     R2,#0
        SWI     XMessageTrans_Lookup
        MOVVC   R12,R2
        ADRVS   R12,ErrorText

01
        LDRB    R0,[R12],#1
        CMP     R0,#32
        BLT     %FT99
        CMP     R0,#"%"
        SWINE   XOS_WriteC
        BVS     %FT99
        BNE     %BT01

        LDRB    R0,[R12],#1              ; Found a %
        CMP     R0,#32
        BLT     %FT99

        CMP     R0,#"0"
        LDREQ   R0,=GeneralMOSBuffer+8
        BEQ     %FT10
        CMP     R0,#"1"
        BNE     %BT01

        LDR     R3,=GeneralMOSBuffer+4
        LDR     R0,[R3]
        LDR     R1,=ZeroPage+MOSConvertBuffer
        MOV     R2,#12
        SWI     XOS_ConvertHex8

02
        LDRB    R1, [R0], #1
        CMP     R1, #"0"
        BEQ     %BT02
        CMP     R1, #0
        SUBEQ   R0, R0, #1
        SUB     R0, R0, #1

10
        SWI     XOS_Write0
        BVC     %BT01

99
        SWI     XOS_NewLine

        LDR     R0, =ZeroPage
        STRB    R0, [R0, #ErrorSemaphore]                 ; Enable error translation, in case we got here in the
                                                        ; middle of looking up an error

        B       GOSUPV                          ; switches back to User mode for us

ErrorToken      =       "Error:"
ErrorText       =       "Error: %0 (Error Number &%1)",0
        ALIGN
      |

        SWI     OS_WriteS
        =       10,13,"Error:",10,13, 0
        ALIGN
        LDR     r0, =GeneralMOSBuffer+4
        BL      PrintError
        B       GOSUPV
      ]


DEFBRK
      [ International
        WritePSRc 0, lr
        MOV     r0, r0
        LDR     r13, =ZeroPage
        LDR     r13, [r13, #BrkBf]
        LDR     r0, [r13, #15*4]
        LDR     r1, =GeneralMOSBuffer
        MOV     r2, #?GeneralMOSBuffer
        SWI     OS_ConvertHex8

; r0 -> address

        MOV     R4,R0
        LDR     R0,=ZeroPage+KernelMessagesBlock+4
        ADR     R1,BreakToken
        LDR     R2,=GeneralMOSBuffer+16
        MOV     R3,#256-16
        SWI     XMessageTrans_Lookup
        MOVVC   R0,R2
        ADRVS   R0,BreakText
        SWI     OS_Write0
        SWI     OS_NewLine

      |
        SWI     OS_WriteS
        = "Stopped at break point at &", 0
        ALIGN
        WritePSRc 0, lr
        MOV     r0, r0
        LDR     r13, =ZeroPage
        LDR     r13, [r13, #BrkBf]
        LDR     r0, [r13, #15*4]
        LDR     r1, =GeneralMOSBuffer
        MOV     r2, #?GeneralMOSBuffer
        SWI     OS_ConvertHex8
        SWI     OS_Write0
        SWI     OS_NewLine
      ]

Quit_Code
        SWI     OS_Exit

      [ International

BreakToken      =       "BreakPt:"
BreakText       =       "Stopped at break point at &%0",0
        ALIGN

      ]

PrintError
        MOV    R12, R14
        LDR    R10, [R0], #4
        SWI    XOS_Write0
        BVS    %FT02
      [ :LNOT: International
        SWI    XOS_WriteS
        =     " (Error number &", 0
        BVS    %FT02
      ]
        LDR    R1,=GeneralMOSBuffer
        MOV    R2, #&E0
        MOV    R0, R10
        SWI    XOS_ConvertHex8       ; can't fail!
01      LDRB   R1, [R0], #1
        CMP    R1, #"0"
        BEQ    %BT01
        CMP    R1, #0
        SUBEQ  R0, R0, #1
      [ International                   ; We might not have any stack so ..
        SUB    R11,R0, #1               ; R11 -> Error number
        LDR    R0, =ZeroPage+KernelMessagesBlock+4
        ADR    R1, PrintErrorString
        MOV    R2,#0                    ; Don't copy message
        SWI    XMessageTrans_Lookup
        ADRVS  R2,PrintErrorString+4    ; If no MessageTrans point at english text.
11
        LDRB   R0,[R2],#1
        CMP    R0,#32
        BLT    %FT13
        CMP    R0,#"%"
        SWINE  XOS_WriteC
        BVS    %FT13
        BNE    %BT11

        LDRB    R0,[R2],#1
        CMP     R0,#32
        BLT     %FT13                   ; Just in case the % is the last character !

        CMP     R0,#"0"                 ; We only know about %0
        BNE     %BT11

12
        LDRB    R0,[R11],#1              ; Print error number.
        CMP     R0,#32
        BLT     %BT11
        SWI     XOS_WriteC
        BVC     %BT12

13
      |
        SUB    R0, R0, #1
        SWI    XOS_Write0
        SWIVC  XOS_WriteI+")"
      ]
        SWIVC  XOS_NewLine
02      MOV    PC, R12

      [ International
PrintErrorString
        =     "Err: (Error number &%0)", 0
        ALIGN
      ]

        LTORG

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Exception handling

DumpyTheRegisters  ROUT
; R0 points at r8 in register dump. r0-r7, PC, PSR saved
; R1 is PSR
; R14 points at error block
; In ABT32 or UND32
        MOV     R7, R14                 ; put error address into unbanked register
        TST     R1, #&0F
  [ SASTMhatbroken
        STMEQIA R0!,{R8-R12}
        STMEQIA R0, {R13,R14}^        ; user mode case done.
        SUBEQ   R0, R0, #5*4
  |
        STMEQIA R0, {R8-R14}^         ; user mode case done.
  ]
        BEQ     UNDEF2

        MRS     R3, CPSR
        AND     R3, R3, #&0F

        ORR     R2, R1, #I32_bit :OR: F32_bit
        BIC     R2, R2, #T32_bit
        MSR     CPSR_c, R2              ; change into original mode
        STMIA   R0, {R8-R12}            ; save the banked registers

        AND     R2, R1, #&0F
        CMP     R2, R3                  ; did abort come from our abort-handling mode?
        MOV     R3, SP
        ADDEQ   R3, R3, #17*4           ; adjust stored SP if so
        LDREQ   R14, =&DEADDEAD         ; and mark R14 as corrupt
        STR     R3, [R0, #5*4]
        EORS    R2, R2, #FIQ_mode       ; Was we in FIQ ? Zero if so
        STR     R14, [R0, #6*4]
        
        BNE     UNDEF2
        MSR     CPSR_c, #I32_bit+F32_bit+ABT32_mode ; into ABT mode so we have a stack (try and preserve SVC stack for any exception dump that's produced)
        Push    "r0"
      [ ZeroPage <> 0
        LDR     R2, =ZeroPage
      ]
        AddressHAL R2
        CallHAL HAL_FIQDisableAll
        Pull    "r0"
UNDEF2
; ... and fall into
UNDEF1
        ; R0 points at R8 in register dump
        ; R7 points at error block
        MSR     CPSR_c, #I32_bit+F32_bit+ABT32_mode ; into ABT mode for exception dump
        SUB     R0, R0, #8*4            ; Make R0 sensible for vector
        MOV     R1, R7
        MOV     R2, #SeriousErrorV_Collect
        MOV     R10, #SeriousErrorV
        BL      CallVector

        MSR     CPSR_c, #I32_bit+F32_bit+SVC32_mode ; into SVC mode
        LDR     sp, =SVCSTK             ; Flatten superstack

        ; Check that ExceptionDump is safe to use
        Push    "R7"                    ; Preserve error ptr
        LDR     R4, =ZeroPage
        MOV     R3, R0
        LDR     R1, [R4, #ExceptionDump]
        MOV     R0, #24
        ADD     R2, R1, #17*4
        ; Must be SVC-writable, user+SVC readable, word aligned
        SWI     XOS_Memory
        AND     r1, r1, #CMA_Completely_UserR+CMA_Completely_PrivR+CMA_Completely_PrivW
        TEQ     r1, #CMA_Completely_UserR+CMA_Completely_PrivR+CMA_Completely_PrivW
        TSTEQ   r2, #3
        BEQ     %FT05
        ; Reset to default location. Unfortunately the Debugger module is a bit
        ; braindead and will only show the contents of the register dump located
        ; within its workspace, so resetting it to the kernel buffer isn't the
        ; best for debugging. But it's better than an infinite abort loop!
        MOV     R0, #ExceptionDumpArea
        LDR     R1, =ZeroPage+DUMPER
        SWI     XOS_ChangeEnvironment
05
        Pull    "R14"                   ; Restore error ptr

        ; Copy the dump from the stack to ExceptionDump
        LDR     R0, [R4, #ExceptionDump]
        LDMIA   R3!, {R1-R2,R4-R9}      ; R0-R7
        STMIA   R0!, {R1-R2,R4-R9}
        LDMIA   R3, {R1-R2,R4-R10}      ; R8-R15, PSR
        STMIA   R0, {R1-R2,R4-R10}

        SUB     R0, R0, #8*4
                                        ; try and put back user R10-R12
        Push    "R4-R6"                 ; for error handler to find on stack
        LDR     R1, [R0, #15*4]
        Push    R1

        LDR     R0, =GeneralMOSBuffer+128 ; so can do deviant sharing !

       [ International
        LDR     r10, =ZeroPage
        LDRB    r10, [r10, #ErrorSemaphore]
        TEQ     r10, #0                 ; if ok to translate error
        MOVEQ   r10, r14
        BEQ     %FT10
       ]

        LDR     r11, [r14], #4          ; Copy error number
        STR     r11, [r0], #4

01      LDRB    r11, [r14], #1          ; Copy error string
        STRB    r11, [r0], #1
        CMP     r11, #"%"               ; Test for "%" near end of string
        BNE     %BT01
10
        SUB     r1, r0, #1              ; point, ready for conversion

        LDR     R2, =GeneralMOSBuffer+?GeneralMOSBuffer
        SUB     r2, r2, r1              ; amount left in buffer

        LDR     R0, =ZeroPage
        LDR     R0, [R0, #ExceptionDump]
        LDR     R0, [R0, #15*4]         ; saved PC
        SWI     XOS_ConvertHex8

      [ International
        LDR     r4, =ZeroPage
        LDRB    r4, [r4, #ErrorSemaphore]
        TEQ     r4, #0
        LDRNE   R0, =GeneralMOSBuffer+128
        BNE     %FT20
        MOV     R4, R0
        MOV     R0, R10
        BL      TranslateError_UseR4
        ; If the exception dump processing takes too long then there's a good
        ; chance the error buffer MessageTrans gave us will get overwritten
        ; before we're able to call OS_GenerateError. Copy the error to the
        ; stack, then copy it back into a MessageTrans block before calling
        ; OS_GenerateError.
        EORS    R4, R0, R10 ; Did TranslateError work?
        BEQ     %FT20
        SUB     SP, SP, #256
        MOV     R4, SP
        MOV     R5, #4
        LDR     R6, [R0]
        STR     R6, [R4]
11
        LDRB    R6, [R0, R5]
        CMP     R6, #0
        STRB    R6, [R4, R5]
        ADD     R5, R5, #1
        BNE     %BT11
        MOV     R0, R4
20
      |
        LDR     R0, =GeneralMOSBuffer+128
      ]

        ; Flatten UND and ABT stacks, jic
        ; Also a convenient way of getting rid of the temp exception dump
        MRS     R2, CPSR
        BIC     R2, R2, #F32_bit + &1F
        ORR     R3, R2, #ABT32_mode
        MSR     CPSR_c, R3                      ; FIQs back on
        LDR     r13_abort, =ABTSTK
        ORR     R3, R2, #UND32_mode
        MSR     CPSR_c, R3
        LDR     r13_undef, =UNDSTK
        ORR     R3, R2, #IRQ32_mode
        MSR     CPSR_c, R3
        LDR     R1, =ZeroPage
      [ ZeroPage = 0
        STR     R1, [R1, #IRQsema]
      |
        MOV     R3, #0
        STR     R3, [R1, #IRQsema]
      ]
        LDR     r13_irq, =IRQSTK

        ; Trigger exception dump processing
        ORR     R3, R2, #SVC32_mode
        MSR     CPSR_c, R3

        ; Let everyone know that the stacks have been reset
        MOV     R2, #SeriousErrorV_Recover
        MOV     R10, #SeriousErrorV
        BL      CallVector

        ; Now enable IRQs and trigger exception dump processing
        MSR     CPSR_c, #SVC32_mode
        MOV     R2, #SeriousErrorV_Report
        MOV     R10, #SeriousErrorV
        BL      CallVector

      [ International
        ; Try and copy error block from stack back to MessageTrans
        LDR     R3, =ZeroPage
        LDRB    R3, [R3, #ErrorSemaphore]
        TEQ     R3, #0
        BNE     %FT30
        CMP     R4, #0 ; Check if original TranslateError call worked (if not, no error block to copy)
        BEQ     %FT30
        SWI     XMessageTrans_CopyError
        ; If TranslateError worked, assume MessageTrans_CopyError worked too
        ADD     SP, SP, #256
30
      ]
        SWI     OS_GenerateError

        LTORG

UNDEF ROUT
        ; In UND32 mode, with a stack
        ; Place exception dump on stack until we can be sure ExceptionDump is safe
        STR     R14, [SP, #-8]!
        SETPSR  F_bit :OR: I_bit, R14
        SUB     SP, SP, #17*4-8
        MOV     R14, SP
        STMIA   R14!, {R0-R7}
        MRS     R1, SPSR
        STR     R1, [R14, #(16-8)*4]            ; save PSR
        MOV     R0, R14
        BL      DumpyTheRegisters
        MakeErrorBlock UndefinedInstruction

ABORTP ROUT
        ; In ABT32 mode, with a stack
        STR     R14, [SP, #-8]!
        SETPSR  F_bit :OR: I_bit, R14
        SUB     SP, SP, #17*4-8
        MOV     R14, SP
        STMIA   R14!, {R0-R7}
        MRS     R1, SPSR
        STR     R1, [R14, #(16-8)*4]            ; save PSR
        MOV     R0, R14
        BL      DumpyTheRegisters
        MakeErrorBlock InstructionAbort

ABORTD ROUT
        ; In ABT32 mode, with a stack
        STR     R14, [SP, #-8]!
        SETPSR  F_bit :OR: I_bit, R14
        SUB     SP, SP, #17*4-8
        MOV     R14, SP
        STMIA   R14!, {R0-R7}
        MRS     R1, SPSR
        STR     R1, [R14, #(16-8)*4]            ; save PSR
        MOV     R0, R14
        BL      DumpyTheRegisters
        MakeErrorBlock DataAbort


ADDREX ROUT
; This really can't happen. Honest
        ; ??? in ABT32 mode, with a stack?
        STR     R14, [SP, #-8]!
        SETPSR  F_bit :OR: I_bit, R14
        SUB     SP, SP, #17*4-8
        MOV     R14, SP
        STMIA   R14!, {R0-R7}
        MRS     R1, SPSR
        STR     R1, [R14, #(16-8)*4]            ; save PSR
        MOV     R0, R14
        BL      DumpyTheRegisters
        MakeErrorBlock AddressException


; Can branch through zero in any mode
; We go through a trampoline which stores R1 and R14 (at R14 on entry)

Branch0_NoTrampoline_DummyRegs
        &       &DEADDEAD, &DEADDEAD
RESET1 ROUT
Branch0_NoTrampoline
        ADR     R14, Branch0_NoTrampoline_DummyRegs
Branch0_FromTrampoline

        LDR     R1, =ZeroPage
        LDR     R1, [R1, #ExceptionDump]
        STMIA   R1, {R0-R12}
        STR     R13, [R1, #13*4]
        LDR     R0, [R14, #0]
        STR     R0, [R1, #1*4]
        LDR     R0, [R14, #4]
        STR     R0, [R1, #14*4]
 [ XScaleJTAGDebug
        MRS     R0, CPSR
        AND     R0, R0, #&1F
        TEQ     R0, #&15        ; Debug mode?
        BNE     %FT20
        LDR     R13, =ZeroPage
        LDR     R0, [R13, #ProcessorFlags]
        ORR     R0, R0, #CPUFlag_XScaleJTAGconnected
        STR     R0, [R13, #ProcessorFlags]
        LDMIA   R1, {R0, R1}
        B       DebugStub
20
 ]
        MOV     R0, #0
        STR     R0, [R1, #15*4]
        MRS     R0, CPSR
        STR     R0, [R1, #16*4]
        SWI     XOS_EnterOS

        LDR     R0, =ZeroPage
        LDR     R0, [R0, #ExceptionDump]
        ADD     R0, R0, #8*4

        ADR     R7, ErrorBlock_BranchThrough0
        B       UNDEF1
        MakeErrorBlock BranchThrough0

 [ XScaleJTAGDebug
        ; Magic from the Multi-ICE User Guide
        ALIGN   32
DebugStub ROUT
        ARM_read_control R13
        AND     R13, R13, #MMUC_I
        ORR     R14, R14, R13, LSR #12
        ARM_read_control R13
        ORR     R13, R13, #MMUC_I
        ARM_write_control R13
        ADR     R13, DebugStubLine2
        MCR     p15, 0, R13, C7, C5, 1
        MCR     p15, 0, R13, C7, C5, 6
10      MRC     p14, 0, R15, C14, C0
        BVS     %BT10
        MOV     R13, #&00B00000
        MCR     p14, 0, R13, C8, C0
20      MRC     p14, 0, R15, C14, C0
        BPL     %BT20
        ARM_read_control R13
        TST     R14, #1
        BICEQ   R13, R13, #MMUC_I
        ARM_write_control R13
        MRC     p14, 0, R13, C9, C0
        MOV     PC, R13
        ALIGN   32
DebugStubLine2
        SPACE   32
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI to call the UpCall vector
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DoAnUpCall ROUT

        Push    lr                  ; better have one of these to pull later !
        MRS     r12, CPSR
      [ NoARMT2
        BIC     r12, r12, #&F0000000
        BIC     r12, r12, #I32_bit:OR:F32_bit
        AND     r10, lr, #&F0000000 ; copy user flags (I bit clear)
        ORR     r10, r10, r12
      |
        MOV     lr, lr, LSR #28
        BIC     r10, r12, #I32_bit:OR:F32_bit
        BFI     r10, lr, #28, #4 ; copy user flags (I bit clear)
      ]
        MSR     CPSR_cf, r10        ; ints on, stay in SVC mode, flags in psr
        MOV     r10, #UpCallV
        BL      CallVector
 [ NoARMT2
        Pull    lr
        BIC     lr, lr, #&F0000000
        MRS     R10, CPSR
        MOV     R10, R10, LSR #(32-4)
        ORR     lr, lr, R10, LSL #(32-4)
 |
        MRS     R10, CPSR
        Pull    lr
        MOV     R10, R10, LSR #28
        BFI     lr, R10, #28, #4
 ]
        ExitSWIHandler

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_ChangeEnvironment: Call the environment change vector
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ChangeEnvironment ROUT

        Push    lr
        MOV     R10, #ChangeEnvironmentV
        BL      CallVector
        Pull    lr
        B       SLVK_TestV


; ..... and the default handler .....

AdjustOurSet
        WritePSRc SVC_mode+I_bit, R14
        CMP     R0, #MaxEnvNumber
        BHI     AOS_Silly

  [ {FALSE}
        CMP     r0, #CallBackHandler
        BLEQ    testcallbackpending
  ]

        ADR     R10, AOS_Table
        ADD     R11, R0, R0, LSL #1   ; number * 3
        ADD     R10, R10, R11, LSL #2 ; point at entry

        MOV     R12, R1
        LDR     R11, [R10]
        CMP     R11, #0
        LDRNE   R1,  [R11]
        CMPNE   R12, #0
        STRNE   R12, [R11]

        MOV     R12, R2
        LDR     R11, [R10, #4]
        CMP     R11, #0
        LDRNE   R2,  [R11]
        CMPNE   R12, #0
        STRNE   R12, [R11]

        MOV     R12, R3
        LDR     R11, [R10, #8]
        CMP     R11, #0
        LDRNE   R3,  [R11]
        CMPNE   R12, #0
        STRNE   R12, [R11]

        Pull    pc

AOS_Silly
        ADR     r0, ErrorBlock_BadEnvNumber
      [ International
        BL      TranslateError
      ]
exit_AOS
        SETV
        Pull    "pc"
        MakeErrorBlock BadEnvNumber

AOS_Table
        &  ZeroPage+MemLimit     ;  MemoryLimit
        &  0
        &  0

        &  ZeroPage+UndHan       ; UndefinedHandler
        &  0
        &  0

        &  ZeroPage+PAbHan       ; PrefetchAbortHandler
        &  0
        &  0

        &  ZeroPage+DAbHan       ; DatabortHandler
        &  0
        &  0

        &  ZeroPage+AdXHan       ; AddressExceptionHandler
        &  0
        &  0

        &  0            ; OtherExceptionHandler
        &  0
        &  0

        &  ZeroPage+ErrHan       ; ErrorHandler
        &  ZeroPage+ErrHan_ws
        &  ZeroPage+ErrBuf

        &  ZeroPage+CallAd       ; CallBackHandler
        &  ZeroPage+CallAd_ws
        &  ZeroPage+CallBf

        &  ZeroPage+BrkAd        ; BreakPointHandler
        &  ZeroPage+BrkAd_ws
        &  ZeroPage+BrkBf

        &  ZeroPage+EscHan       ; EscapeHandler
        &  ZeroPage+EscHan_ws
        &  0

        &  ZeroPage+EvtHan       ; EventHandler
        &  ZeroPage+EvtHan_ws
        &  0

        &  ZeroPage+SExitA       ; ExitHandler
        &  ZeroPage+SExitA_ws
        &  0

        &  ZeroPage+HiServ       ; UnusedSWIHandler
        &  ZeroPage+HiServ_ws
        &  0

        &  ZeroPage+ExceptionDump ; ExceptionDumpArea
        &  0
        &  0

        &  ZeroPage+AplWorkSize  ; application space size
        &  0
        &  0

        &  ZeroPage+Curr_Active_Object
        &  0
        &  0

        &  ZeroPage+UpCallHan
        &  ZeroPage+UpCallHan_ws
        &  0

        assert (.-AOS_Table)/12 = MaxEnvNumber

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SWI OS_ReadDefaultHandler

; In    r0 = environment number

ReadDefaultHandler ROUT

        CMP     r0, #(dhte-defhantab)/12
        MOVHS   r0, #0                  ; return wally value
        ADD     r10, r0, r0, LSL #1     ; *3
        ADD     r10, pc, r10, LSL #2    ; *4 (pc = defhantab-4)
        LDMIB   r10, {r1-r3}            ; gives additional +4
        ExitSWIHandler

defhantab
     & 0                ; wally entry
     & 0
     & 0

     & UNDEF            ; UndefinedHandler
     & 0
     & 0

     & ABORTP           ; PrefetchAbortHandler
     & 0
     & 0

     & ABORTD           ; DataAbortHandler
     & 0
     & 0

     & ADDREX           ; AddressExceptionHandler
     & 0
     & 0

     & 0                ; OtherExceptionHandler
     & 0
     & 0

     & ERRORH           ; ErrorHandler
     & 0
     & GeneralMOSBuffer

     & NOCALL           ; CallBackHandler
     & 0
     & ZeroPage+DUMPER

     & DEFBRK           ; BreakPointHandler
     & 0
     & ZeroPage+DUMPER

     & ESCAPH           ; EscapeHandler
     & 0
     & GeneralMOSBuffer

     & EVENTH           ; EventHandler
     & 0
     & 0

     & CLIEXIT          ; ExitHandler
     & 0
     & 0

     & NoHighSWIHandler ; UnusedSWIHandler
     & 0
     & 0

     & 0                ; exception dump
     & 0
     & 0

     & 0                ; app space size
     & 0
     & 0

     & 0                ; cao pointer
     & 0
     & 0

     & DefUpcallHandler ; upcall handler
     & 0
     & 0

dhte

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 = sysinfo handle

; Out   r0 = sysinfo for r0in

ReadSysInfo_Code ROUT
        CMP     r0,#16 ;R0 > 15, so illegal value
        ADDLO   PC, PC, R0,LSL #2
        B       ReadSysInfo_InvalidReason

        B       %FT00
        B       %FT10
        B       %FT20
        B       %FT30
        B       %FT40
        B       %FT50
        B       %FT60
        B       %FT70
        B       %FT80
        B       %FT90
        B       ReadSysInfo_InvalidReason ; ROL's "read OS version" call
        B       %FT110
        B       %FT120
        B       %FT130
        B       %FT140
        B       %FT150

ReadSysInfo_InvalidReason
        ADR     r0, ErrorBlock_BadReadSysInfo
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        ORR     lr, lr, #V_bit
        ExitSWIHandler

        MakeErrorBlock BadReadSysInfo

; ReadSysInfo(0) - return configured screensize in r0

00
        Push    "r1, r2, lr"
        MOV     r0, #ReadCMOS
        MOV     r1, #ScreenSizeCMOS
        SWI     XOS_Byte
        AND     r0, r2, #&7F            ; top bit is reserved
        LDR     r10, =ZeroPage
        LDR     r10, [r10, #Page_Size]
        MUL     r0, r10, r0
        BL      MassageScreenSize       ; adjust for min and max or default values
        Pull    "r1, r2, lr"
        ExitSWIHandler

; ReadSysInfo(1) - returns configured mode/wimpmode in r0
;                          configured monitortype in r1
;                          configured sync in r2
;                          (all de-autofied)

10
        Push    "r3-r5, lr"
        BL      Read_Configd_Sync
        MOV     r2, r0
        LDR     r1, =ZeroPage+VduDriverWorkSpace+CurrentMonitorType      ; read current monitortype
        LDR     r1, [r1]
        TEQ     r1, #MonitorTypeEDID :SHR: MonitorTypeShift              ; equate EDID=auto in this context
        MOVEQ   r1, #-1
        BL      Read_Configd_Mode
        CMP     r0, #-1                         ; if none of the three are auto, don't bother with translation
        CMPNE   r1, #-1
        CMPNE   r2, #-1
        BNE     %FT15
        BL      TranslateMonitorLeadType        ; issue service or work it out ourselves
        CMP     r0, #-1                         ; if mode auto
        MOVEQ   r0, r3                          ; then replace with default
        CMP     r1, #-1                         ; if monitortype auto
        MOVEQ   r1, r4                          ; then replace with default
        CMP     r2, #-1                         ; if sync auto
        MOVEQ   r2, r5                          ; then replace with default
15
        Pull    "r3-r5, lr"
        ExitSWIHandler

; ReadSysInfo(2)
;
; in:   r0 = 2
;
; out:  r0 = hardware configuration word 0
;               bits 0-7 = special functions chip type
;                               0 => none
;                               1 => IOEB
;               bits 8-15 = I/O control chip type
;                               0 => IOC
;                               1 => IOMD
;                             255 => none
;               bits 16-23 = memory control chip type
;                               0 => MEMC1/MEMC1a
;                               1 => IOMD
;                             255 => none
;               bits 24-31 = video control chip type
;                               0 => VIDC1a
;                               1 => VIDC20
;                             255 => none
;       r1 = hardware configuration word 1
;               bits 0-7 = I/O chip type
;                               0 => absent
;                               1 => 82C710/711 or SMC'665 or similar
;               bits 8-31 reserved (set to 0)
;       r2 = hardware configuration word 2
;               bits 0-7 = LCD controller type
;                               0 => absent
;                               1 => present (type 1) eg A4 portable
;                               2 => present (type 2) eg Stork portable
;               bits 8-15 = IOMD variant (when marked as present in word 0)
;                               0 => IOMD
;                               1 => IOMDL ie ARM7500 (Morris)
;               bits 16-23 = VIDC20 variant (when marked as present in word 0)
;                               0 => VIDC20
;                               1 => VIDC2L ie ARM7500 (Morris)
;               bits 24-31 = miscellaneous flags
;                      bit 24   0 => IIC bus slow (100kHz)
;                               1 => IIC bus fast (400kHz)
;                      bit 25   0 => keep I/O clocks running during idle
;                               1 => stop I/O clocks during idle
;                      bits 26-31 reserved (set to 0)
;       r3 = word 0 of unique machine ID, or 0 if unavailable
;       r4 = word 1 of unique machine ID, or 0 if unavailable

20
        Push    "r9,r14"
        AddressHAL
        SUB     sp, sp, #12
        ADD     a1, sp, #0
        ADD     a2, sp, #4
        ADD     a3, sp, #8
        CallHAL HAL_HardwareInfo
        LDR     r12, =ZeroPage
        LDR     r3, [r12, #RawMachineID+0]
        LDR     r4, [r12, #RawMachineID+4]
        MOV     r3, r3, LSR #8                  ; lose first 8 bits
        ORR     r3, r3, r4, LSL #24             ; and put bits 0..7 of r3 into bits 24..31 of r2
        MOV     r4, r4, LSL #8                  ; lose CRC bits
        MOV     r4, r4, LSR #16                 ; and move the rest down to the bottom
        Pull    "r0-r2,r9,r14"
        ExitSWIHandler

; ReadSysInfo(3)
;
; in:   r0 = 3
;
; out:  r0 = I/O chip base features mask                710     711     665     669     UMC669
;               Bits 0..3   Base IDE type               1       1       1       1       1
;               Bits 4..7   Base FDC type               1       1       1       1       1
;               Bits 8..11  Base parallel type          1       1       1       1       1
;               Bits 12..15 Base 1st serial type        1       1       1       1       1
;               Bits 16..19 Base 2nd serial type        0       1       1       1       1
;               Bits 20..23 Base Config type            1       2       3       4       5
;               Bits 24..31 Reserved                    0       0       0       0       0
;
;       r1 = I/O chip extra features mask               710     711     665     669     UMC669
;               Bits 0..3   IDE extra features          0       0       0       0       0
;               Bits 4..7   FDC extra features          0       0       0       0       0
;               Bits 8..11  parallel extra features     0       0       1       1       1
;               Bits 12..15 1st serial extra features   0       0       1       1       1
;               Bits 16..19 2nd serial extra features   0       0       1       1       1
;               Bits 20..23 config extra features       0       0       0       0       0
;               Bits 24..31 Reserved                    0       0       0       0       0
;
;       r2-r4 undefined (reserved for future expansion)
;

30
        Push    "r9,r14"
        AddressHAL
        SUB     sp, sp, #8
        ADD     a1, sp, #0
        ADD     a2, sp, #4
        CallHAL HAL_SuperIOInfo
        Pull    "a1,a2,r9,r14"
        ExitSWIHandler

; ReadSysInfo(4)
;
; On entry:       r0 = 4 (reason code)
;
; On exit:        r0 = LS32bits of Ethernet Network Address (or 0)
;                 r1 = MS16bits of Ethernet Network Address (or 0)
;
; Use:            Code loaded from the dedicated Network Expansion Card or
;                 from a normal Expansion Card should use the value returned
;                 by this call in preference to a locally provided value.

40
        Push    "r2-r3,r9,r14"
        AddressHAL
        MOV     r0, #0
        CallHAL HAL_ExtMachineID
        Pull    "r2-r3,r9,r14"
        TEQ     r0, #0
        BNE     ExitNoEthernetAddress                   ; Extended machine ID is implemented - don't attempt to extract a MAC from RawMachineID, it's just a hash of the extended ID
        LDR     r0, =ZeroPage
        LDRB    r1, [ r0, #RawMachineID ]               ; The family byte
        TEQ     r1, #&81                                ; Excellent,a custom part - we'll use it
        BNE     ExitNoEthernetAddress
        LDR     r1, [ r0, #RawMachineID+4 ]             ; Acorn's ID and part#
        BIC     r1, r1, #&FF000000                      ; Remove the CRC
        LDR     r0, =&0050A4                            ; Acorn's ID is &005
        TEQ     r1, r0                                  ; Is this an Acorn part?
        LDR     r0, =ZeroPage
        BNE     %FT45
        LDR     r0, [ r0, #RawMachineID ]
        MOV     r0, r0, LSR #8                          ; Lose family byte
        LDR     r1, =&0000A4100000
        ADD     r0, r1, r0                              ; Add Acorn base Ethernet address to number from Dallas
        MOV     r1, #0                                  ; Top 16 bits are zero in Acorn's MAC address allocation
        ExitSWIHandler
45
        MOV     r1, r1, LSR #8                          ; It's unique,but not an Acorn part - extract MAC address verbatim
        Push    "r2"
        LDR     r2, [ r0, #RawMachineID ]
        MOV     r2, r2, LSR #8
        LDRB    r0, [r0, #RawMachineID+4]
        ORR     r0, r2, r0, LSL#24
        Pull    "r2"
        ExitSWIHandler

ExitNoEthernetAddress
        MOV     r0, #0
        MOV     r1, #0
        ExitSWIHandler

; ReadSysInfo(5)
;
; On entry:       r0 = 5 (reason code)
;
; On exit:        r0 = LSW of Raw data from unique id chip
;                 r1 = MSW of Raw data from unique id chip

50
        LDR     r0, =ZeroPage
        LDR     r1, [r0, #RawMachineID+4]
        LDR     r0, [r0, #RawMachineID+0]
        ExitSWIHandler

; ReadSysInfo(6) - read kernel values (Acorn use only; eg. SoftLoad, ROMPatch)
;
; On entry:       r0 =  6 (reason code)
;                 r1 -> input block, 1 word per entry, giving number of value required, terminated by -1
;           OR:   r1 =  0 if just 1 value is required, and this is to beturned in r2
;                 r2 -> output block, 1 word per entry, will be filled in on output
;           OR:   r2 =  number of single value required, if r1 = 0
;
; On exit:
;   if r1 entry != 0:
;         r0,r1,r2 preserved
;         output block filled in, filled in value(s) set to 0 if unrecognised/no longer meaningful value(s)
;   if r1 entry = 0:
;         r0,r1 preserved
;         r2 = single value required, or set to 0 if if unrecognised/no longer meaningful value
;
;  valid value numbers available - see table below
;

60
        Push    "r0-r4"
        ADR     r3,osri6_table
        CMP     r1,#0
        BEQ     %FT64
62
        LDR     r4,[r1],#4
        CMP     r4,#-1
        BEQ     %FT66
        CMP     r4,#osri6_maxvalue
        LDRLS   r0,[r3,r4,LSL #2]
        MOVHI   r0,#0
        ; Fix up the DevicesEnd values
        TEQ     r4,#OSRSI6_Danger_DevicesEnd
        TEQNE   r4,#OSRSI6_DevicesEnd
        STRNE   r0,[r2],#4
        BNE     %BT62
        LDR     r4,=ZeroPage
        LDR     r4,[r4,#IRQMax]
        ADD     r0,r0,r4,LSL #3
        ADD     r0,r0,r4,LSL #2
        STR     r0,[r2],#4
        B       %BT62
64
        CMP     r2,#osri6_maxvalue
        LDRLS   r0,[r3,r2,LSL #2]
        MOVHI   r0,#0
        ; Fix up the DevicesEnd values
        TEQ     r2,#OSRSI6_Danger_DevicesEnd
        TEQNE   r2,#OSRSI6_DevicesEnd
        LDREQ   r1,=ZeroPage
        LDREQ   r1,[r1,#IRQMax]
        ADDEQ   r0,r0,r1,LSL #3
        ADDEQ   r0,r0,r1,LSL #2
        STR     r0,[sp,#2*4]
66
        Pull    "r0-r4"
        ExitSWIHandler

osri6_table
    DCD  ZeroPage+CamEntriesPointer                   ;0
    DCD  ZeroPage+MaxCamEntry                         ;1
    DCD  PageFlags_Unavailable                        ;2
    DCD  ZeroPage+PhysRamTable                        ;3
    DCD  0                                            ;4 (was ARMA_Cleaner_flipflop)
    DCD  ZeroPage+TickNodeChain                       ;5
    DCD  ZeroPage+ROMModuleChain                      ;6
    DCD  ZeroPage+DAList                              ;7
    DCD  ZeroPage+AppSpaceDANode                      ;8
    DCD  ZeroPage+Module_List                         ;9
    DCD  ZeroPage+ModuleSHT_Entries                   ;10
    DCD  ZeroPage+ModuleSWI_HashTab                   ;11
    DCD  0                                            ;12 (was IOSystemType)
    DCD  L1PT                                         ;13
    DCD  L2PT                                         ;14
    DCD  UNDSTK                                       ;15
    DCD  SVCSTK                                       ;16
    DCD  SysHeapStart                                 ;17
    ; **DANGER** - this block conflicts with ROL's allocations
    ; ROL use:
    ; 18 = kernel messagetrans block
    ; 19 = error semaphore
    ; 20 = OS_PrettyPrint dictionary
    ; 21 = Timer 0 latch value
    ; 22 = FastTickerV counts per second
    ; 23 = Vector claimants table
    ; 24 = Number of vectors supported
    ; 25 = IRQSTK
    ; 26 = JTABLE-SWIRelocation
    ; 27 = Address of branch back to OS after SWIs
    DCD  JTABLE-SWIRelocation                         ;18 - relocated base of OS SWI despatch table
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;19 - relocated base of IRQ device head nodes
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;20 - relocated end of IRQ device head nodes. NOTE: Gets fixed up when read
    DCD  IRQSTK                                       ;21 - top of the IRQ stack
    DCD  SoundWorkSpace                               ;22 - workspace (8K) and buffers (2*4K)
    DCD  ZeroPage+IRQsema                             ;23 - the address of the IRQ semaphore
    %    (256-(.-osri6_table))
    ; Use 64+ for a repeat of the danger zone, and our new allocations
    DCD  JTABLE-SWIRelocation                         ;64 - relocated base of OS SWI despatch table
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;65 - relocated base of IRQ device head nodes
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;66 - relocated end of IRQ device head nodes. NOTE: Gets fixed up when read
    DCD  IRQSTK                                       ;67 - top of the IRQ stack
    DCD  SoundWorkSpace                               ;68 - workspace (8K) and buffers (2*4K)
    DCD  ZeroPage+IRQsema                             ;69 - the address of the IRQ semaphore
    ; New allocations
    DCD  ZeroPage+DomainId                            ;70 - current Wimp task handle
    DCD  ZeroPage+OsbyteVars-&A6                      ;71 - OS_Byte vars (previously available via OS_Byte &A6/VarStart)
    DCD  ZeroPage+VduDriverWorkSpace+FgEcfOraEor      ;72
    DCD  ZeroPage+VduDriverWorkSpace+BgEcfOraEor      ;73
    DCD  DebuggerSpace                                ;74
    DCD  DebuggerSpace_Size                           ;75
    DCD  ZeroPage+CannotReset                         ;76
    DCD  ZeroPage+MetroGnome                          ;77 - OS_ReadMonotonicTime
    DCD  ZeroPage+CLibCounter                         ;78
    DCD  ZeroPage+RISCOSLibWord                       ;79
    DCD  ZeroPage+CLibWord                            ;80
    DCD  ZeroPage+FPEAnchor                           ;81
    DCD  ZeroPage+ESC_Status                          ;82
    DCD  ZeroPage+VduDriverWorkSpace+ECFYOffset       ;83
    DCD  ZeroPage+VduDriverWorkSpace+ECFShift         ;84
    DCD  ZeroPage+VecPtrTab                           ;85
    DCD  NVECTORS                                     ;86
    DCD  1                                            ;87 CAM format: 0 = 8 bytes/entry, 1 = 16 bytes/entry
osri6_maxvalue * (.-4-osri6_table) :SHR: 2


; ReadSysInfo(7)  - read 32-bit Abort information for last unexpected abort
;                      (prefetch or data)
;
; On entry:       r0 =  6 (reason code)
;
; On exit:        r1 = 32-bit PC for last abort
;                 r2 = 32-bit PSR for last abort
;                 r3 = fault address for last abort (same as PC for prefetch abort)
;
70
        Push    "r0"
        LDR     r0, =ZeroPage+Abort32_dumparea
        LDMIA   r0, {r2, r3}
        LDR     r1, [r0,#2*4]
        Pull    "r0"
        ExitSWIHandler

; ReadSysInfo(8) - Returns summary information on host platform.
;
; On entry:
;    r0 = 8 (reason code 8)
;
; On exit:
;    r0 = platform class
;         currently defined classes are:
;            0 = unspecified platform (r1,r2 will be 0)
;            1 = Medusa   (currently returned for Risc PC only)
;            2 = Morris   (currently returned for A7000 only)
;            3 = Morris+  (currently returned for A7000+ only)
;            4 = Phoebe   (currently returned for Risc PC 2 only)
;            5 = HAL      (returned for machines running a HAL)
;            all other values currently reserved
;    r1 = 32 additional platform specifier flags (if defined)
;         bits 0..31 = value of flags 0..31 if defined, 0 if undefined
;    r2 = defined status of the 32 flags in r1
;         bits 0..31 = status of flags 0..31
;                      0 = flag is undefined in this OS version
;                      1 = flag is defined in this OS version
;
; The current flag definitions for r1 (1=supported, 0=unsupported) are :
;
;     0     = Podule expansion card(s)
;     1     = PCI expansion card(s)
;     2     = additional processor(s)
;     3     = software power off
;     4     = OS in RAM, else executing in ROM
;     5     = OS uses rotated loads          } If both clear and flagged as
;     6     = OS uses unaligned loads/stores } defined, OS makes no unaligned accesses
;     7..31 reserved (currently undefined)
;
80
        Push    "r9,r14"
        AddressHAL
        SUB     sp, sp, #8
        ADD     a2, sp, #0
        ADD     a3, sp, #4
        CallHAL HAL_PlatformInfo
        Pull    "a2,a3,r9,r14"
        MOV     r0, #5
    [ :LNOT: NoUnaligned
      [ :LNOT: NoARMv6
        ORR     r1, r1, #1:SHL:6 ; ARMv6+
      ELIF :LNOT: SupportARMv6
        ORR     r1, r1, #1:SHL:5 ; <=ARMv5
      ]
    ]
        ORR     r2, r2, #3:SHL:5
        ExitSWIHandler

; OS_ReadSysInfo 9 - Read ROM info
;
; On entry:
;    r0 = 9 (reason code 9)
;    r1 = item number to return
;
; On exit:
;    r0 = pointer to requested string (NULL terminated) or NULL if it wasn't found
;
; Currently defined item numbers are:
;
;    0   = OS name
;    1   = Part number
;    2   = Build date
;    3   = Dealer name
;    4   = User name
;    5   = User address
;    6   = Printable OS description
;    7   = Hardware platform

90
        CMP     R1, #0
        CMPNE   R1, #6
        ADREQ   R0, RSI9_OSname     ; The OS name or description
        BEQ     %FT95
        CMP     R1, #2              ; The build date (dynamically generated)
        BEQ     %FT92
        CMP     R1, #7              ; The hardware platform
        MOVNE   R0, #0              ; Other ones are unimplemented
        BNE     %FT95

        Push    "r1-r3,r9,lr"
        AddressHAL
        MOV     a1,#0               ; Return NULL if HAL doesn't implement it
        CallHAL HAL_PlatformName
        Pull    "r1-r3,r9,lr"
        B       %FT95
92
        LDR     R0, =ROMBuildDate
        LDRB    R1, [R0]
        CMP     R1, #0
        MOVNE   R1, #2              ; Restore R1
        BNE     %FT95
        ; Build date string hasn't been generated yet. Generate it.
        Push    "r0-r3,lr"
        MOV     R0, #ExtROMFooter_BuildDate
        BL      ExtendedROMFooter_FindTag
        CMP     R0, #0              ; Found it?
        STREQ   R0, [R13]
        BEQ     %FT93
        ; For compatability, make this string match the same format as the old
        ; string. Conveniently, this matches the format string used by OS_Word
        ; 14
        LDR     R1, [R13]
        MOV     R2, #?ROMBuildDate
        ADRL    R3, TimeFormat
        SWI     XOS_ConvertDateAndTime
        MOVVS   R0, #0
        STRVS   R0, [R13]
93
        Pull    "r0-r3,lr"
95
        ExitSWIHandler

; OS_ReadSysInfo 11 - Read debug information
;
; On entry:
;    r0 = 11 (reason code 11)
;
; On exit:
;    r0 = pointer to function for debug character output
;    r1 = pointer to function for debug character input
;     

110
        ; Check if both HAL_DebugTX and HAL_DebugRX are available
        Push    "r8-r9,r14"
        MOV     R8, #OSHW_LookupRoutine
        MOV     R9, #EntryNo_HAL_DebugTX
        SWI     XOS_Hardware
        MOVVC   R8, #OSHW_LookupRoutine
        MOVVC   R9, #EntryNo_HAL_DebugRX
        SWIVC   XOS_Hardware
        Pull    "r8-r9,r14"
        BVS     ReadSysInfo_InvalidReason        
        ADR     R0, RSI_DebugTX
        ADR     R1, RSI_DebugRX
        ExitSWIHandler

RSI_DebugTX
        ; In:
        ; R0 = char
        ; Privileged mode
        ; Out:
        ; R0-R3, PSR corrupt
        Push    "r9,r12,r14"
        AddressHAL
        CallHAL HAL_DebugTX
        Pull    "r9,r12,pc"

RSI_DebugRX
        ; In:
        ; Privileged mode
        ; Out:
        ; R0=char read, or -1
        ; R1-R3, PSR corrupt
        Push    "r9,r12,r14"
        AddressHAL
        CallHAL HAL_DebugRX
        Pull    "r9,r12,pc"

; OS_ReadSysInfo 12 - Read extended machine ID
;
; On entry:
;    r0 = 12 (reason code 12)
;    r1 = Pointer to word-aligned buffer, or 0 to read size
;
; On exit:
;    r0 = Size of extended machine ID, or 0 if none/corrupt
;    Buffer in R1 filled, if applicable
;

120
        Push    "r1-r3,r9,r14"
        AddressHAL
        MOV     R0, R1 ; HAL takes the buffer pointer in R0        
        CallHAL HAL_ExtMachineID
        Pull    "r1-r3,r9,r14"
        ExitSWIHandler

; OS_ReadSysInfo 13 - Validate key handler
;
; On entry:
;    r0 = 13 (reason code 13)
;    r1 = key handler address (0 to just return valid flags)
;
; On exit:
;    r0 = Mask of supported key handler flags
;         Or pointer to error block
;

130
        LDR     R0, =KeyHandler_Flag_Wide
        CMP     R1, #0
        ExitSWIHandler EQ
        Push    "R2"
        LDR     R2, [R1, #KeyHandler_KeyTranSize]
        TST     R2, #KeyHandler_HasFlags
        LDRNE   R2, [R1, #KeyHandler_Flags]
        BICNES  R2, R2, R0
        Pull    "R2"
        ExitSWIHandler EQ
        ADR     R0, ErrorBlock_BadKeyHandler
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        ORR     lr, lr, #V_bit
        ExitSWIHandler

        MakeErrorBlock BadKeyHandler

; OS_ReadSysInfo 14 - Return IIC bus count
;
; On entry:
;    r0 = 14 (reason code 14)
;
; On exit:
;    r0 = Number of IIC buses (as per HAL_IICBuses)
;

140
        Push    "r1-r3,sb,lr"
        AddressHAL
        CallHAL HAL_IICBuses
        Pull    "r1-r3,sb,lr"
        ExitSWIHandler

; OS_ReadSysInfo 15 - Enumerate extended ROM footer entries
;
; On entry:
;    r0 = 15 (reason code 15)
;    r1 = location to start (from previous call) or 0 to begin
;
; On exit:
;    r1 = data pointer, or 0 if end
;    r2 = entry ID (corrupt if r1 == 0)
;    r3 = entry length (corrupt if r1 == 0)

150
        Push    "lr"
        BL      ExtendedROMFooter_Find
        CMP     r0, #-1
        BEQ     %FT158
        MOV     lr, r0                  ; Footer end
        CMP     r1, #0
        LDREQ   r1, [lr]
        MOVEQ   r1, r1, LSL #16
        SUBEQ   r1, lr, r1, LSR #16     ; Footer start
        LDRNEB  r3, [r1, #-1]
        ADDNE   r1, r1, r3              ; If not starting enumeration, advance by length of previous entry
        CMP     r1, lr
        BEQ     %FT158
        LDRB    r2, [r1], #1
        LDRB    r3, [r1], #1
        B       %FT159
158
        MOV     r1, #0
159
        MOV     r0, #15
        Pull    "lr"
        ExitSWIHandler

;
; Extended ROM footer functions
;
; These operate on a new tag-based structure located at the end of the ROM
; image. Each entry consists of a one-byte ID, a one-byte length, and then N
; bytes of data. The length byte doesn't count the two initial header bytes.
;
; The end of the list is implicity terminated by a footer word; the footer word
; contains the length of the structure in the low two bytes (minus the length of
; the footer word), and a 16-bit CRC in the top two bytes (again, minus the
; footer word). The footer word will be word-aligned, but everything else is
; assumed to be byte aligned.
;
; Current tags:
;
; 0     ROM build date, stored as 5-byte time (length = 5)
; 1     Compressed ROM softload hint (length = 8). First word is negative
;       checksum of uncompressed image, second word is OS header offset.
; 2     Debug symbols offset (length = 4). Byte offset from the start of the ROM
;       to the debug symbols.
;

ExtendedROMFooter_Find  ROUT
        ; Find the header word for the extended ROM footer. Returns -1 if not found.
        Push    "r1-r4,lr"
        LDR     r4, =ZeroPage
        LDR     r0, [r4, #ExtendedROMFooter]
        CMP     r0, #0
        BNE     %FT10
        ; Examine the end of the ROM image
        ; Footer should be located just before the standard 20 byte footer
        LDR     r2, =ROM+OSROM_ImageSize*1024-24
        LDR     r1, [r2]
        CMP     r1, #-1
        MOVEQ   r0, r1
        BEQ     %FT09
        ; Check CRC
        MOV     r1, r1, LSL #16
        SUB     r1, r2, r1, LSR #16
        MOV     r3, #1
        SWI     XOS_CRC
        MOVVS   r0, #-1
        BVS     %FT09
        LDR     r1, [r2]
        CMP     r0, r1, LSR #16
        MOVNE   r0, #-1
        MOVEQ   r0, r2
09
        STR     r0, [r4, #ExtendedROMFooter]
10
        Pull    "r1-r4,pc"

ExtendedROMFooter_FindTag  ROUT
        ; Find the tag number given in R0.
        ; Returns data pointer in R0 & length in R1 on success.
        ; Returns 0 in R0 (and corrupt R1) for failure.
        Push    "r2-r3,lr"
        MOV     r2, r0
        BL      ExtendedROMFooter_Find
        CMP     r0, #-1
        BEQ     %FT09
        MOV     r3, r0
        LDR     r0, [r0]
        MOV     r0, r0, LSL #16
        SUB     r0, r3, r0, LSR #16
05
        CMP     r0, r3
        BEQ     %FT09
        LDRB    lr, [r0], #1
        LDRB    r1, [r0], #1
        CMP     lr, r2
        BEQ     %FT10
        ADD     r0, r0, r1
        B       %BT05
09
        MOV     r0, #0
10
        Pull    "r2-r3,pc"

RSI9_OSname    = "$SystemName $VString",0

        ALIGN
        LTORG

        END
@


4.23
log
@Fix to OS_ReadSysInfo 1
Detail:
  Prior to ScreenModes starting (when CurrentMonitorType becaomes 7) this SWI would return Auto as 31 for EDID rather than -1, as would be the case had ReadMultiField been called.
  Change to use -1 for consistency and so it gets translated to type 3 (VGA).
Admin:
  Submission from Willi Theiss.

Version 5.85. Tagged as 'Kernel-5_85'
@
text
@d635 3
d644 5
a648 1
        STR     SP, [R0, #5*4]
@


4.23.2.1
log
@Merge in latest changes from main branch

Version 6.05, 4.129.2.8. Tagged as 'Kernel-6_05-4_129_2_8'
@
text
@a634 3
        MRS     R3, CPSR
        AND     R3, R3, #&0F

d641 1
a641 5
        CMP     R2, R3                  ; did abort come from our abort-handling mode?
        MOV     R3, SP
        ADDEQ   R3, R3, #17*4           ; adjust stored SP if so
        LDREQ   R14, =&DEADDEAD         ; and mark R14 as corrupt
        STR     R3, [R0, #5*4]
@


4.22
log
@Extend MonitorType configure keyword
Detail:
  Accept a monitortype of 'EDID' (as distinct from 'Auto', which uses the ID pins) to force the kernel, via ScrModes, to use the native screen mode prior to executing the boot sequence.
  Required for discless boot, this also helps if the boot sequence fails, the desktop will be entered in the monitor's native resolution, or a fallback if GraphicsV rejects that.
  The allocation of the EDID monitor type has been carefully selected to degrade to 'Auto' when used with an older OS. That way the configuration in CMOS is safe to use with softloads on top of older physical ROMs.
  When OS_ScreenMode is queried return the 'Auto' type, ie. at an API level there's no distinction.
Admin:
  Requires HdrSrc-2_67.
  Submission for the EDID bounty.

Version 5.80. Tagged as 'Kernel-5_80'
@
text
@d1269 1
a1269 1
        MOVEQ   r1, #MonitorTypeAuto :SHR: MonitorTypeShift
@


4.21
log
@Fix OS_BreakPt when called from SVC mode
Detail:
  s/Middle - A mistake during the 32bit conversion process left OS_BreakPt attempting to use the PSR as the address of the register dump if the call came from SVC mode, most likely resulting in an abort.
Admin:
  Tested on Raspberry Pi
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/11/topics/6308#posts-56649


Version 5.56. Tagged as 'Kernel-5_56'
@
text
@d1268 2
@


4.20
log
@Delete lots of old switches
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * FixCallBacks
  * UseProcessTransfer
  * CanLiveOnROMCard
  * BleedinDaveBell
  * NewStyleEcfs
  * DoVdu23_0_12
  * LCDPowerCtrl
  * HostVdu
  * Print
  * EmulatorSupport
  * TubeInfo
  * AddTubeBashers
  * TubeChar, TubeString, TubeDumpNoStack, TubeNewlNoStack macros
  * FIQDebug
  * VCOstartfix
  * AssemblingArthur (n.b. still defined for safety with anything in Hdr: which uses it, but not used explicitly by the kernel)
  * MouseBufferFix
  * LCDInvert
  * LCDSupport
  * DoInitialiseMode
  * Interruptible32bitModes
  * MouseBufferManager
  * StrongARM (new CacheCleanerHack and InterruptDelay switches added to hdr/Options to cover some functionality that StrongARM previously covered)
  * SAcleanflushbroken
  * StrongARM_POST
  * IrqsInClaimRelease
  * CheckProtectionLink
  * GSWorkspaceInKernelBuffers
  * EarlierReentrancyInDAShrink
  * LongCommandLines
  * ECC
  * NoSPSRcorruption
  * RMTidyDoesNowt
  * RogerEXEY
  * StorkPowerSave
  * DebugForcedReset
  * AssembleKEYV
  * AssemblePointerV
  * ProcessorVectors
  * Keyboard_Type
  Assorted old files have also been deleted.
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.51. Tagged as 'Kernel-5_51'
@
text
@d304 1
a304 1
02      MOV     r14, r12                ; supervisor mode. R14 in buffer dead
@


4.19
log
@Delete STB code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a desktop build):
  * STB
  * RO371Timings
  * NormalSpeedROMS
  * AutoSpeedROMS
  * RISCPCBurstMode
  * InterlacedPointer
  * ParallelFlashUpgrade (and s/FlashROM file)
  * Embedded_UI
  Some of the deleted code might be worth revisiting in future:
  * OS_ReadSysInfo 4 support for storing the MAC in alternate CMOS locations (including 2nd copy for error checking) or fetching via Service_MachineAddress
  * Mouse handling changes, possibly aimed at hiding the mouse pointer if a mouse isn't connected
  * More strict CMOS validation in s/NewReset
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.50. Tagged as 'Kernel-5_50'
@
text
@a1265 1
 [ ModeSelectors
a1267 4
 |
        BL      Read_Configd_MonitorType
        MOV     r1, r0
 ]
@


4.18
log
@Delete pre-HAL and 26bit code
Detail:
  This change gets rid of the following switches from the source (picking appropriate code paths for a 32bit HAL build):
  * HAL
  * HAL26
  * HAL32
  * No26bitCode
  * No32bitCode
  * IncludeTestSrc
  * FixR9CorruptionInExtensionSWI
  Various old files have also been removed (POST code, Arc/STB keyboard drivers, etc.)
Admin:
  Identical binary to previous revision for IOMD & Raspberry Pi builds


Version 5.49. Tagged as 'Kernel-5_49'
@
text
@a1419 7
        [ STB
        TST     r0, #1:SHL:23                           ; Check not overflowed into secondary range
        BNE     ExitNoEthernetAddress
        MOV     r1, r0, LSR #24                         ; Check not overflowed out of Acorn's range
        TEQ     r1, #&A4
        BNE     ExitNoEthernetAddress
        ]
a1432 1
        [ :LNOT: STB
a1435 202
        |
        Push    "r2,lr"
        MOV     r1, #Service_MachineAddress             ; See if anyone else can provide it
        BL      Issue_Service
        TEQ     r1, #0
        MOVEQ   r1, r2
        BLNE    GetMachineAddressCMOS
        Pull    "r2,lr"
        ExitSWIHandler
        ]

 [ STB

NVRAM_TAG_MACAddress
        = "MACAddress", 0
NVRAM_TAG_MACAddressChecksum
        = "MACAddressChecksum", 0
NVRAM_TAG_MACAddress2nd
        = "MACAddress2nd", 0
NVRAM_TAG_MACAddressChecksum2nd
        = "MACAddressChecksum2nd", 0

        ALIGN

GetMachineAddressCMOS
; Out:  r0 = lower 4 bytes (or 0)
;       r1 = upper 2 bytes (or 0)
;       EQ => valid, NE => invalid
;
        Entry   "r2-r5", 8                              ; Preserve these + get 8 bytes workspace

        ADR     r0,NVRAM_TAG_MACAddress
        ADR     r3,NVRAM_TAG_MACAddressChecksum
        BL      CheckOneCopyOfMachineAddressCMOS        ; Get 1st copy of MAC in r0=low 4 bytes,
                                                        ; r1=upper 2 bytes of MAC in bytes 0,1  stored checksum in byte 2,  calculated checksum in byte 3
 [ MACNVRAM2copies
        MOV     r4,r0
        MOV     r5,r1

        ADR     r0,NVRAM_TAG_MACAddress2nd
        ADR     r3,NVRAM_TAG_MACAddressChecksum2nd
        BL      CheckOneCopyOfMachineAddressCMOS        ; Get 2nd copy of MAC

        CMP     r0,r4
        CMPEQ   r1,r5
        BNE     %FT41                                   ; Have different values - i.e one (possibly both) is wrong/broken
 ] ;two copies of MAC

        MOV     r2,r1,LSR#16                            ; move checksum values into low bytes
        AND     r3,r2,#&ff                              ; r3=stored checksum
        MOV     r2,r2,LSR#8                             ; r2=calculated checksum
        CMP     r2,r3                                   ; do the checksums match
        BNE     %FT43                                   ; if not then we have unrecoverable fault, both values identical but checksums broken
                                                        ; this would be the case for an unprogrammed CMOS
        MOV     r2,#&ff
        ORR     r2,r2,r2,LSL#8                          ; mask for removing checksums
        AND     r1,r1,r2                                ; #&0000ffff remove checksums from r1
        EXIT                                            ; return with valid MAC in r0,r1 and flags set to EQ by branch just above

 [ MACNVRAM2copies
;two copies differ
41
        MOV     r2,r5,LSR#16                            ; move checksum for 1st copy into low bytes
        AND     r3,r2,#&ff                              ; r3=stored checksum
        MOV     r2,r2,LSR#8                             ; r2=calculated checksum
        CMP     r2,r3                                   ; do the checksums match
        BEQ     %FT45                                   ; okay need to repair second set

        MOV     r2,r1,LSR#16                            ; move checksum for 2nd copy into low bytes
        AND     r3,r2,#&ff                              ; r3=stored checksum
        MOV     r2,r2,LSR#8                             ; r2=calculated checksum
        CMP     r2,r3                                   ; do the checksums match
        BEQ     %FT46                                   ; okay need to repair first set
 ]
;we arrive here if we have a situation from which no sensible MAC can be derived
;i) both values are broken
43
        MOV     r0,#0
        MOV     r1,#0
        EXIT                                            ;return with r0,r1 both zero to indicate no valid address, two possible paths here both have NE flags
 [ MACNVRAM2copies
;checksum is valid for first set so repair second set
45
        ADR     r3,NVRAM_TAG_MACAddress2nd
        ADR     r0,NVRAM_TAG_MACAddressChecksum2nd
        B       %FT47

;checksum is valid for second set so repair first set
46
        MOV     r4,r0                                   ;get values of 2nd set into write registers
        MOV     r5,r1
        ADR     r3,NVRAM_TAG_MACAddress
        ADR     r0,NVRAM_TAG_MACAddressChecksum

;store MAC (+ check sum) in r4,r5, and checksum in r2 to NVRAM tags given by r0 and r3
47
 [ 1=2
        ; forgot that NVRAM_Write will fail
        ; on locked locations such as .. the MAC addresses...
        ; this will be modified shortly to call a new SWI provided
        ; by the NVRAM module to turn a tag into an address and
        ; then perform the write using routines in the i2cutils
        ; section of the kernel.

        MOV     r1, sp                                  ;some workspace
        STRB    r2, [r1,#0]                             ;store the checksum
        MOV     r2, #1
        SWI     XNVRAM_Write
        ;TST     r0, #&80000000                          ; Check for errors
        ;BNE     %FT48                                   ; Oh dear

        BIC     r5,r5,#&ffff0000                        ;get rid of checksum - we already have a value in r2 extracted earlier
        MOV     r0,r3                                   ;NVRAM_TAG_MACAddress
        MOV     r1,sp                                   ;workspace

        MOV     r3,r5
        STRB    r3,[r1,#1]
        MOV     r3,r3,LSR#8
        STRB    r3,[r1,#0]
        MOV     r3,r4
        STRB    r3,[r1,#5]
        MOV     r3,r3,LSR#8
        STRB    r3,[r1,#4]
        MOV     r3,r3,LSR#8
        STRB    r3,[r1,#3]
        MOV     r3,r3,LSR#8
        STRB    r3,[r1,#2]

        MOV     r2,#6
        SWI     XNVRAM_Write
        ;TST     r0, #&80000000                          ; Check for errors
        ;BNE     %FT48                                   ; Oh dear
 ]
;return with the values from r4,r5 in r0,r1 and flags eq
;48
        MOV     r0,r4
        MOV     r1,r5
        CMP     r1,r1                                   ;make flags equal - is this required?
        EXIT

 ] ; MACNVRAM2copies

;On entry r0 points to MAC address Tag name
;         r3 points to Checksum Tag name
CheckOneCopyOfMachineAddressCMOS
        Entry   ,8

        MOV     r1, sp
        MOV     r2, #6
        SWI     XNVRAM_Read
        MOVVS   r0, #&ffffffff
        TST     r0, #&80000000                          ; Check for errors
        BNE     MachineAddressNVRAMError

        MOV     r0, r3
        ADD     r1, sp, #6
        MOV     r2, #1
        SWI     XNVRAM_Read
        MOVVS   r0, #&ffffffff
        TST     r0, #&80000000                          ; Check for errors
        BNE     MachineAddressNVRAMError

        MOV     r0, #0
        MOV     r1, #0

        LDRB    r3, [sp, #0]                            ; Get the first byte into checksum
        MOV     r1, r3, ASL #8                          ; Store into result

        LDRB    r2, [sp, #1]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        ORR     r1, r1, r2, ASL #0                      ; Store into the result

        LDRB    r2, [sp, #2]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        MOV     r0, r2, ASL #24                         ; Store into the result

        LDRB    r2, [sp, #3]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        ORR     r0, r0, r2, ASL #16                     ; Store into the result

        LDRB    r2, [sp, #4]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        ORR     r0, r0, r2, ASL #8                      ; Store into the result

        LDRB    r2, [sp, #5]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        ORR     r0, r0, r2, ASL #0                      ; Store into the result

        LDRB    r2, [sp, #6]                            ; Get the checksum
        AND     r3, r3, #&FF
        EOR     r3, r3, #&FF
        ORR     r1,r1,r2,LSL#16                            ;put stored checksum in byte 2
        ORR     r1,r1,r3,LSL#24                            ;put calculated checksum in byte 3
49
        EXIT

MachineAddressNVRAMError
        MOV     r0,#0
        MOV     r1,#0
        EXIT

 ]
@


4.17
log
@Merge HAL branch to trunk
Detail:
  This change merges the past 15+ years of HAL branch development back to the trunk.
  This is effectively the end for non-HAL builds of the kernel, as no attempt has been made to maintain it during this merge, and all non-HAL & non-32bit code will soon be removed anyway.
  Rather than list everything that's been added to the HAL branch, it's easier to describe the change in terms of the things that the HAL branch was lacking:
  * Trunk version of Docs/32bit contained updated comments for the SVC stack structure during ErrorV
  * Trunk version of s/HeapMan contained a tweak to try and reduce the number of small free blocks that are created
  * Trunk version of s/Kernel contained a change to only copy 248 bytes of the error string to the error buffer (down from 252 bytes), to take into account the extra 4 bytes needed by the PSR. However this goes against the decision that's been made in the HAL branch that the error buffer should be enlarged to 260 bytes instead (ref: https://www.riscosopen.org/tracker/tickets/201), so the HAL build will retain its current behaviour.
  * Trunk version of s/MsgCode had RMNot32bit error in the list of error messages to count when countmsgusage {TRUE}
  * Trunk version of s/PMF/i2cutils contained support for OS_Memory 5, "read/write value of NVRamWriteSize". Currently the HAL branch doesn't have a use for this (in particular, the correct NVRamWriteSize should be specified by the HAL, so there should be no need for software to change it at runtime), and so this code will remain switched out in the HAL build.
Admin:
  Tested on Raspberry Pi


Version 5.48. Tagged as 'Kernel-5_48'
@
text
@a18 1
 [ No26bitCode
a39 17
 |
ReadLine32SWI
        TST     r0, #ARM_CC_Mask-3
        BNE     %FT90
        AND     r11, r4, #ARM_CC_Mask
        ORR     r0, r0, r11
        Push    "r4,lr"
        AND     r4, r4, #&FF
        SWI     XOS_ReadLine
        Pull    "r4,lr"
        B       SLVK_TestV

90      Push    "lr"
        BL      SetErrorBadAddress
        Pull    "lr"
        B       SLVK_SetV
 ]
a44 4
 [ :LNOT:No26bitCode
;               bit 31 set means don't reflect characters that don't go in the buffer
;               bit 30 set means reflect with the character in R4
 ]
a47 1
 [ No26bitCode
a51 3
 |
;       r4 = character to echo if r1 bit 30 is set
 ]
a64 1
 [ No26bitCode
a66 7
 |
        AND     R7, R0, #&C0000000      ; extract flags
        AND     R4, R4, #&FF
        ORR     R7, R7, R4              ; got flags, potential echo byte in R7

        BIC     R4, R0, #ARM_CC_Mask-3  ; R4 -> buffer
 ]
a151 1
 [ No26bitCode
a152 7
 |
        Pull    "R4-R7, lr"             ; Always claiming vector
        BIC     lr, lr, #V_bit :OR: C_bit
        MOV     r12, pc
        AND     r12, r12, #V_bit :OR: C_bit
        ORRS    pc, lr, r12             ; back with C, V affected.
 ]
a260 1
  [ No26bitCode
a266 5
  |
        FakeLR  r11,,r12                ; r12+[sp] -> lr (r11 temp reg)
        SUB     r14, r14, #4            ; r14 = PC of the SWI
        TST     r14, #SVC_mode
  ]
a418 1
 [ No26bitCode
a420 1
 ]
a905 1
 [ No26bitCode
a909 9
 |
        MRS     R0, CPSR                        ; Fake up a combined PC+PSR (PC=0)
        AND     R1, R0, #I32_bit :OR: F32_bit
        AND     R0, R0, #&F0000003
        ORR     R0, R0, R1, LSL #IF32_26Shift
        MOV     R1, #0
        LDR     R1, [R1, #ExceptionDump]
        STR     R0, [R1, #15*4]
 ]
a919 9
 [ :LNOT: No26bitCode
BranchThroughZeroInstruction
 [ ProcessorVectors
        LDR     PC, .+ProcVec_Branch0
 |
        B       .+Branch0_Trampoline
 ]
 ]

a956 1
 [ No26bitCode
a968 4
 |
        AND     r10, lr, #&F0000000 ; copy user flags (I_bit clear)
        TEQP    r10, #SVC_mode      ; ints on, stay in SVC mode, flags in psr
 ]
a973 1
   [ No26bitCode
a975 3
   |
        MOV     R10, PC, LSR #(32-4)
   ]
a977 1
        ASSERT  No26bitCode
a1034 1
 [ No26bitCode
a1035 3
 |
        Pull    pc,,^
 ]
a1042 1
 [ No26bitCode
a1044 4
 |
        Pull    "lr"
        ORRS    pc, lr, #V_bit
 ]
a1333 16
; Bits in IOSystemType

IOST_COMBOMASK  * 7
IOST_82C710     * 1
IOST_82C711     * 2
IOST_37C665     * 3
IOST_37C669     * 4
IOST_UMC669     * 5
IOST_IOEB       * 8     ; On IOMD systems this really means IOMD.
IOST_LC         * 16
 [ MorrisSupport
IOST_7500       * 32    ;Running on ARM7500 (Morris) so actually IOMDL and VIDC2L
IOST_BATMAN     * 64    ;Stork keyboard/battery controller seems to be present
 ]

 [ HAL
a1350 35
 |
20
        MOV     r0, #0
        LDR     r3, [r0, #RawMachineID+0]
        LDR     r4, [r0, #RawMachineID+4]
        MOV     r3, r3, LSR #8                  ; lose first 8 bits
        ORR     r3, r3, r4, LSL #24             ; and put bits 0..7 of r3 into bits 24..31 of r2
        MOV     r4, r4, LSL #8                  ; lose CRC bits
        MOV     r4, r4, LSR #16                 ; and move the rest down to the bottom
        LDRB    r0, [r0, #IOSystemType]

        ANDS    r2, r0, #IOST_LC
        MOVNE   r2, #1                          ; make r2 0 or 1
 [ MorrisSupport
        TST     r0, #IOST_BATMAN
        MOVNE   r2, #2                          ;NE, its a Stork portable
        TST     r0, #IOST_7500
        ORRNE   r2, r2, #&00000100              ;NE, Morris based machine with IOMDL
        ORRNE   r2, r2, #&00010000              ;NE, and VIDC2L
 ]
        MOV     r1, #0
        LDRB    r1, [r1, #NVRamSpeed]

        SUB     r1, r1, #1                      ; catch zero = slow (just in case)
        CMP     r1, #3-1                        ; speed is 3 for 400kHz, 10 for 100kHz.
        ORRLS   r2, r2, #&01000000              ; indicate fast speed
 [ StopClocksDuringIdle
        ORR     r2, r2, #&02000000
 ]
        ANDS    r1, r0, #IOST_COMBOMASK
        MOVNE   r1, #1                          ; make r1 0 or 1

        LDR     r0, =&01010100
        ExitSWIHandler
 ]
a1377 1
 [ HAL
a1385 25
 |
        MOV     r0, #0                          ; used as index and as default value
        LDRB    r1, [r0, #IOSystemType]
        ANDS    r1, r1, #IOST_COMBOMASK
        TEQ     r1, #IOST_82C710
        LDREQ   r0, =&00101111
        MOVEQ   r1, #0
        TEQ     r1, #IOST_82C711
        LDREQ   r0, =&00211111
        MOVEQ   r1, #0
        CMP     r1, #IOST_37C665
 [ ReassignedIOMDInterrupts
; If the device numbers have been reassigned, we can't really call the devices compatible.
; Also, we've lost the floppy and hard disc interrupts, so mark as not present.
        LDRHS   r0, =&00022200
 |
        LDRHS   r0, =&00011111
 ]
        ORRHS   r0, r0, r1, LSL #20
        LDRHS   r1, =&00011100
        MOV     r2, #0
        MOV     r3, #0
        MOV     r4, #0
        ExitSWIHandler
 ]
a1835 1
 [ HAL
a1852 23
 |
        Push    "r3-r5"
        ADR     r3, %86
        MOV     r4, #IOMD_Base
        LDRB    r4, [r4, #IOMD_ID0]
82
        LDR     r5, [r3], #4
        TEQ     r5, #&80000000     ;terminator
        TEQNE   r5, r4
        LDMEQIA r3, {r0-r2}
        BEQ     %FT84
        ADD     r3, r3, #3*4
        B       %BT82
84
        Pull    "r3-r5"
        ExitSWIHandler
86
        DCD     IOMD_Original :AND: &FF,   1, &00000005, &0000000F
        DCD     IOMD_7500     :AND: &FF,   2, &00000001, &0000000F
        DCD     IOMD_7500FE   :AND: &FF,   3, &00000001, &0000000F
        DCD     IOMD_IOMD2    :AND: &FF,   4, &0000000F, &0000000F
        DCD     &80000000,                 0,         0,         0  ;terminator
 ]
@


4.16
log
@  Added a couple of new sub-reason codes to OS_ReadSysInfo 6;
  Optimised the default IrqV handler.
Detail:
  * OS_ReadSysInfo 6 tells grubby programs lots of grubby info. This
    has been extended to include:

      18 - relocated base of OS SWI despatch table
      19 - relocated base of IRQ device head nodes
      20 - relocated end of IRQ device head nodes
      21 - top of the IRQ stack

    These values are known to be useful for debugging purposes.

  * The default IrqV handler gets the device number times three on
    entry in R0. It then went through a loop subtracting three and
    incrementing a counter to divide by three.

    This has been replaced by four ARM instructions which should
    give the same results (three to divide by three and one to set
    R0 to zero - as the old code did).

    If the device number is outside the range 0..31, the new code
    may produce inaccurate results, but this should not happen.
Admin:
  Not tested ;)

Version 5.43. Tagged as 'Kernel-5_43'
@
text
@d17 42
d63 5
a67 1
;       r1 = max length of line (excluding carriage return)
d70 8
d80 2
a81 1
; Out   r1 = length of line (excluding carriage return)
a84 12
; ReadLine: suggested extensions (available RSN)
;
; are 1) stopping it reflecting control characters/characters not put in the
;        buffer
;     2) making any reflection print a given character (for hiding passwords
;        etc
;
; So, definition is :
;
; Top byte R0 contains flags :
;   Bit 31 set means don't reflect characters that don't go in the buffer
;   Bit 30 set means reflect with the character in R4
d90 5
d100 1
d164 2
a165 2
        CMP     R7, #0                  ; no reflection
        BMI     %BT10                   ; of non-entered chars
d167 1
a167 1
80      TST     R7, #1:SHL:30
d181 1
a181 1
        MOV     R5, #0
d267 1
a267 1
        MOV     R12, #0
d291 4
d301 1
a301 1
        MOV     r10, #0
d317 1
a317 1
        STMIA   r10!, {r0}
d331 1
a331 1
        MOV     r12, #BrkAd_ws
d340 1
a340 1
        STMIA   r10!, {r0}
d344 4
a347 2
        msr    ,CPSR_c, R14             ; get at registers r13 and r14
        STMIA   r0, {r1-r14}
d354 2
a355 1
        STMIA   r14, {r0-r13}
d376 2
a377 2
        msr    ,CPSR_c, #I32_bit + SVC32_mode
        MOV     r10, #0
d438 1
a438 1
       LDR  R0, =DUMPER
d444 2
a445 2
       ADR  R4, UNDEF
       ADR  R5, ABORTP
d449 1
a449 1
       LDR  R0, =DUMPER
d465 1
a465 1
NOCALL  MOV     r0, #0                  ; default callback routine
d469 1
a469 1
        msr    ,SPSR_cxsf, r0
d480 3
a482 1
        ADR     R0,KernelMessagesBlock+4
d510 1
a510 1
        LDR     R1,=MOSConvertBuffer
d529 1
a529 1
        MOV     R0, #0
d533 1
a533 1
        B       GOSUPV
d553 1
a553 1
        MOV     r13, #0
d563 1
a563 1
        ADR     R0,KernelMessagesBlock+4
d579 1
a579 1
        MOV     r13, #0
d621 1
a621 1
        ADR    R0, KernelMessagesBlock+4
d670 5
a674 3
  [ No26bitCode
; In ABT32 or UND32, PC, PSR already stored, PSR in R1
        MOV     R4, R14                 ; put error address into unbanked register
a675 6
  |
; In SVC26, fake 26-bit PC at 0
        LDR     R1, [R0, -R0]         ; PC when exception happened
        STR     R1, [R0, #(15-8)*4]   ; In the right slot now ...
        TST     R1, #SVC_mode
  ]
a684 1
  [ No26bitCode
d687 2
a688 2
        msr    ,CPSR_c, R2              ; change into original mode
        STMIA   R0, {R8-R14}            ; save the banked registers
d691 1
d693 11
a703 2
        MOVEQ   R3, #IOC
        STREQB  R2, [R3, #IOCFIQMSK]    ; Blow away all FIQ sources
a704 3
        msr    ,CPSR_c, #I32_bit+F32_bit+SVC32_mode ; into SVC mode

        MOV     R14, R4                 ; corrupt R14_SVC (but already saved if we were in SVC)
d707 8
a714 15
  |
        TST     R1, #1                ; SWI mode?
        TSTNE   R1, #2
        BNE     %FT02
        ORR     R1, R1, #I_bit :OR: F_bit
                                 ; keep interrupts off until handlers restored
        TEQP    R1, #0                  ; get at registers
        NOP
        STMIA   R0, {R8-R14}
        TEQP    PC, #SVC_mode :OR: I_bit :OR: F_bit
        AND     R1, R1, #SVC_mode
        EORS    R2, R1, #FIQ_mode       ; Was we in FIQ ? Zero if so
        MOVEQ   R3, #IOC
        STREQB  R2, [R3, #IOCFIQMSK]    ; Blow away all FIQ sources
        B       UNDEF1
d716 1
a716 5
02      STMIA   R0, {R8-R14}
; ... and fall into
UNDEF2
UNDEF1
  ]
d719 33
a751 5
        MOV     R0, #0
        LDR     R0, [R0, #ExceptionDump]
        ADD     R1, R0, #10*4           ; point at dumped R10
        LDMIA   R1, {R10-R12}           ; try and put back user registers
        Push    "R10-R12"               ; for error handler to find on stack
a754 6
        LDR     R0, BranchThroughZeroInstruction ; load the B RESET1 instr.
        STR     R0, [R1, -R1]           ; and store it at zero again

       [ :LNOT:No26bitCode
        BIC     R14, R14, #ARM_CC_Mask
       ]
d758 1
a758 1
        MOV     r10, #0
d778 1
a778 1
        MOV     R0, #0
a780 3
      [ :LNOT: No26bitCode
        BIC     R0, R0, #ARM_CC_Mask
      ]
d784 1
a784 1
        MOV     r4, #0
d788 24
a811 3
        MOVEQ   R4, R0
        MOVEQ   R0, R10
        BLEQ    TranslateError_UseR4
a815 1
      [ No26bitCode
d817 2
a818 1
        mrs    ,R2, CPSR
d821 1
a821 1
        msr    ,CPSR_c, R3                      ; FIQs back on
d824 1
a824 1
        msr    ,CPSR_c, R3
d827 4
a830 1
        msr    ,CPSR_c, R3
d832 32
a863 1
        TEQP    PC, #IRQ_mode+I_bit
a864 3
        MOV     R1, #0
        STR     R1, [R1, #IRQsema]
        LDR     SPIRQ, =IRQSTK
a869 1
 [ No26bitCode
d871 2
a872 1
        Push    R14
d874 2
a875 6
 |
        TEQP    pc, #F_bit :OR: I_bit :OR: SVC_mode ; FIQ off too
        STR     R14, [R0, -R0]
 ]
        MOV     R14, #0
        LDR     R14, [R14, #ExceptionDump]
d877 1
a877 2
 [ No26bitCode
        mrs    ,R1, SPSR
a878 3
        Pull    R0
        STR     R0, [R14, #(15-8)*4]            ; save PC
 ]
a883 1
 [ No26bitCode
d885 1
a885 1
        Push    R14
d887 2
a888 6
 |
        TEQP    pc, #F_bit :OR: I_bit :OR: SVC_mode ; FIQ off too
        STR     R14, [R0, -R0]
 ]
        MOV     R14, #0
        LDR     R14, [R14, #ExceptionDump]
d890 1
a890 2
 [ No26bitCode
        mrs    ,R1, SPSR
a891 3
        Pull    R0
        STR     R0, [R14, #(15-8)*4]            ; save PC
 ]
a893 1

a896 1
 [ No26bitCode
d898 1
a898 1
        Push    R14
d900 2
a901 6
 |
        TEQP    pc, #F_bit :OR: I_bit :OR: SVC_mode ; FIQ off too
        STR     R14, [R0, -R0]
 ]
        MOV     R14, #0
        LDR     R14, [R14, #ExceptionDump]
d903 1
a903 2
 [ No26bitCode
        mrs    ,R1, SPSR
a904 3
        Pull    R0
        STR     R0, [R14, #(15-8)*4]            ; save PC
 ]
d912 5
a916 9
 [ No26bitCode
        msr    ,CPSR_c, #F32_bit :OR: I32_bit :OR: SVC32_mode ; FIQ off too
        STR     R14, [R0, -R0]
 |
        TEQP    pc, #F_bit :OR: I_bit :OR: SVC_mode ; FIQ off too
        STR     R14, [R0, -R0]
 ]
        MOV     R14, #0
        LDR     R14, [R14, #ExceptionDump]
d918 2
a920 6
 [ No26bitCode
        mrs    ,R1, SPSR
        STR     R1, [R14, #(16-8)*4]            ; save PSR
        LDR     R14, [R0, -R0]
        STR     R14, [R14, #(15-8)*4]
 ]
a921 1

d926 1
d928 2
d931 3
d935 1
a935 2
        STR     R1, [R0, -R0]
        MOV     R1, #0
d937 19
a955 1
        STMIA   R1, {R0-R14}
d959 1
a959 1
        mrs    ,R0, CPSR
d962 1
a962 1
        mrs    ,R0, CPSR                        ; Fake up a combined PC+PSR (PC=0)
a969 2
        LDR     R0, [R0, -R0]
        STR     R0, [R1, #1*4]
d972 6
a977 1
        BL      UNDEF1
d980 1
d985 2
a986 1
        B       .+(RESET1-0)
d989 29
d1027 2
a1028 1
        mrs    ,r12, CPSR
d1033 6
a1038 1
        msr    ,CPSR_cf, r10        ; ints on, stay in SVC mode, flags in psr
d1045 1
d1048 2
a1049 2
 [ No26bitCode
        mrs    ,R10, CPSR
d1051 4
d1056 5
a1060 1
        MOV     R10, PC, LSR #(32-4)
a1061 1
        ORR     lr, lr, R10, LSL #(32-4)
d1084 1
a1084 1
  [ False
a1134 15
   [ False

testcallbackpending
        CMP     r1, #0                ; OK if only reading
        CMPEQ   r2, #0
        CMPEQ   r3, #0
        LDRNEB  r10, [r0, #CallBack_Flag-CallBackHandler]
        TSTNE   r10, #CBack_OldStyle
        MOVEQ   pc, r14
  SetBorder r0, r14, 15, 0, 0
        ADR     r0, ErrorBlock_CallbackPending
        B       exit_AOS
        MakeErrorBlock CallbackPending
   ]

d1136 1
a1136 1
        &  MemLimit     ;  MemoryLimit
d1140 1
a1140 1
        &  UndHan       ; UndefinedHandler
d1144 1
a1144 1
        &  PAbHan       ; PrefetchAbortHandler
d1148 1
a1148 1
        &  DAbHan       ; DatabortHandler
d1152 1
a1152 1
        &  AdXHan       ; AddressExceptionHandler
d1160 3
a1162 3
        &  ErrHan       ; ErrorHandler
        &  ErrHan_ws
        &  ErrBuf
d1164 3
a1166 3
        &  CallAd       ; CallBackHandler
        &  CallAd_ws
        &  CallBf
d1168 3
a1170 3
        &  BrkAd        ; BreakPointHandler
        &  BrkAd_ws
        &  BrkBf
d1172 2
a1173 2
        &  EscHan       ; EscapeHandler
        &  EscHan_ws
d1176 2
a1177 2
        &  EvtHan       ; EventHandler
        &  EvtHan_ws
d1180 2
a1181 2
        &  SExitA       ; ExitHandler
        &  SExitA_ws
d1184 2
a1185 2
        &  HiServ       ; UnusedSWIHandler
        &  HiServ_ws
d1188 1
a1188 1
        &  ExceptionDump ; ExceptionDumpArea
d1192 1
a1192 1
        &  AplWorkSize  ; application space size
d1196 1
a1196 1
        &  Curr_Active_Object
d1200 2
a1201 2
        &  UpCallHan
        &  UpCallHan_ws
d1251 1
a1251 1
     & DUMPER
d1255 1
a1255 1
     & DUMPER
d1297 3
a1299 15
        CMP     r0, #1
        BCC     %FT00                   ; r0 = 0
        BEQ     %FT10                   ; r0 = 1
        CMP     r0, #3
        BCC     %FT20                   ; r0 = 2
        BEQ     %FT30                   ; R0 = 3
        CMP     r0, #5
        BCC     %FT40                   ; R0 = 4
        BEQ     %FT50                   ; R0 = 5
        CMP     r0, #7
        BCC     %FT60                   ; R0 = 6
        BEQ     %FT70                   ; R0 = 7
        CMP     r0, #9
        BCC     %FT80                   ; R0 = 8
                                        ; R0 = 9 not allocated yet (BEQ %FT90)
d1301 16
a1316 1
        ;       R0 > 8, so illegal value
d1318 1
d1338 1
a1338 1
        MOV     r10, #0
d1355 1
a1355 1
        LDR     r1, =VduDriverWorkSpace+CurrentMonitorType      ; read current monitortype
d1388 1
d1392 1
d1396 1
d1407 1
a1407 1
;               bits 8-15 = IOMD variant
d1410 1
a1410 1
;               bits 16-23 = VIDC20 variant
d1436 20
a1474 1
 [ E2ROMSupport
d1477 1
a1477 3
 |
        MOV     r1,#I2Cticks                    ; defined in PMF.i2cutils
 ]
a1486 2
 [ IO_Type = "IOMD"
   [ VIDC_Type = "VIDC20"
d1488 1
a1488 9
   |
        LDR     r0, =&00010100
   ]
 |
        ANDS    r0, r0, #IOST_IOEB
        MOVNE   r0, #1                          ; make r1 0 or 1
   [ VIDC_Type = "VIDC20"
        ORR     r0, r0, #&01000000
   ]
a1489 1
        ExitSWIHandler
d1517 10
d1550 1
d1552 1
a1552 1
; OS_ReadSysInfo 4 (SWI &58)
d1556 2
a1557 2
; On exit:        r0 = LSW of Ethernet Network Address (or 0)
;                 r1 = MSW of Ethernet Network Address (or 0)
d1564 2
d1567 5
d1573 1
a1573 1
        TEQ     r1, #&81                                ; Is this a custom part?
a1575 1
  [  True
d1578 3
a1580 8
  | ; Version for no checking of Manufacture's ID
        MOV     r1, r1, LSL #20
        MOV     r1, r1, LSR #20                         ; Remove CRC and ID
        LDR     r0, =&0A4
  ]
        TEQ     r1, r0                                  ; Is this one of our chips?
        BNE     ExitNoEthernetAddress
        MOV     r0, #0
d1583 2
a1584 2
        LDR     r1, =&0000A4100000                      ; Base Ethernet address
        ADD     r0, r1, r0                              ; Add Dallas part to base
d1592 10
a1601 1
        MOV     r1, #0                                  ; Top 16 bits are zero
d1623 1
a1623 1
	= "MACAddress", 0
d1625 1
a1625 1
	= "MACAddressChecksum", 0
d1756 5
a1760 5
	MOV	r1, sp
	MOV	r2, #6
	SWI	XNVRAM_Read
	MOVVS	r0, #&ffffffff
	TST	r0, #&80000000				; Check for errors
d1764 2
a1765 2
	ADD	r1, sp, #6
	MOV	r2, #1
d1767 2
a1768 2
	MOVVS	r0, #&ffffffff
	TST	r0, #&80000000				; Check for errors
d1771 2
a1772 2
	MOV	r0, #0
	MOV	r1, #0
d1774 2
a1775 2
	LDRB	r3, [sp, #0]				; Get the first byte into checksum
	MOV	r1, r3, ASL #8				; Store into result
d1777 23
a1799 23
	LDRB	r2, [sp, #1]				; Get the next byte
	ADD	r3, r3, r2				; Add to the checksum
	ORR	r1, r1, r2, ASL #0			; Store into the result

	LDRB	r2, [sp, #2]				; Get the next byte
	ADD	r3, r3, r2				; Add to the checksum
	MOV	r0, r2, ASL #24				; Store into the result

	LDRB	r2, [sp, #3]				; Get the next byte
	ADD	r3, r3, r2				; Add to the checksum
	ORR	r0, r0, r2, ASL #16			; Store into the result

	LDRB	r2, [sp, #4]				; Get the next byte
	ADD	r3, r3, r2				; Add to the checksum
	ORR	r0, r0, r2, ASL #8			; Store into the result

	LDRB	r2, [sp, #5]				; Get the next byte
	ADD	r3, r3, r2				; Add to the checksum
	ORR	r0, r0, r2, ASL #0			; Store into the result

	LDRB	r2, [sp, #6]				; Get the checksum
	AND	r3, r3, #&FF
	EOR	r3, r3, #&FF
d1812 1
a1812 1
; OS_ReadSysInfo 5
d1816 2
a1817 2
; On exit:        r0 = LSW of Raw data from Dallas Chip
;                 r1 = MSW of Raw data from Dallas Chip
d1820 1
a1820 1
        MOV     r0, #0
d1825 1
a1825 1
; OS_ReadSysInfo 6  - read kernel values (Acorn use only; eg. SoftLoad, ROMPatch)
d1845 1
a1845 1
        Push    "r0-r3"
d1850 2
a1851 2
        LDR     r0,[r1],#4
        CMP     r0,#-1
d1853 2
a1854 1
        CMP     r0,#osri6_maxvalue
d1856 9
a1864 1
        LDRLS   r0,[r3,r0,LSL #2]
d1869 10
a1878 3
        MOVHI   r2,#0
        LDRLS   r2,[r3,r2,LSL #2]
        STR     r2,[sp,#2*4]
d1880 1
a1880 1
        Pull    "r0-r3"
d1884 2
a1885 2
    DCD  CamEntriesPointer                            ;0
    DCD  MaxCamEntry                                  ;1
d1887 10
a1896 10
    DCD  PhysRamTable                                 ;3
    DCD  ARMA_Cleaner_flipflop                        ;4
    DCD  TickNodeChain                                ;5
    DCD  ROMModuleChain                               ;6
    DCD  DAList                                       ;7
    DCD  AppSpaceDANode                               ;8
    DCD  Module_List                                  ;9
    DCD  ModuleSHT_Entries                            ;10
    DCD  ModuleSWI_HashTab                            ;11
    DCD  IOSystemType                                 ;12
d1902 12
d1916 1
a1916 1
    DCD  DefaultIRQ1V+(DeviceTables-DefaultIRQ1Vcode) ;20 - relocated end of IRQ device head nodes
d1918 29
d1950 2
a1951 2
; OS_ReadSysInfo 7  - read 32-bit Abort information for last unexpected abort
;                     (prefetch or data)
d1961 2
a1962 1
        LDR     r0, =Abort32_dumparea
a1963 2
        LDR     r2, [r0]
        LDR     r3, [r0,#4]
d1967 1
a1967 1
; OS_ReadSysInfo 8 - Returns summary information on host platform.
d1980 1
d1994 5
a1998 2
;     3     = auto power off
;     4..31 reserved (currently undefined)
d2001 19
d2036 1
a2036 1
        DCD     IOMD_Original :AND: &FF,   1, &00000001, &0000000F
d2041 65
d2107 24
d2132 207
@


4.15
log
@Fixed compile time error that occured if E2ROMSupport was false
(NVRamSpeed is not defined in the Kernel workspace so we need an
 alternative way to work the speed of the I2C bus - so I've used
 I2Cticks - defined in PMF.i2cutils)

Version 5.34. Tagged as 'Kernel-5_34'
@
text
@d1694 23
a1716 19
    DCD  CamEntriesPointer        ;0
    DCD  MaxCamEntry              ;1
    DCD  PageFlags_Unavailable    ;2
    DCD  PhysRamTable             ;3
    DCD  ARMA_Cleaner_flipflop    ;4
    DCD  TickNodeChain            ;5
    DCD  ROMModuleChain           ;6
    DCD  DAList                   ;7
    DCD  AppSpaceDANode           ;8
    DCD  Module_List              ;9
    DCD  ModuleSHT_Entries        ;10
    DCD  ModuleSWI_HashTab        ;11
    DCD  IOSystemType             ;12
    DCD  L1PT                     ;13
    DCD  L2PT                     ;14
    DCD  UNDSTK                   ;15
    DCD  SVCSTK                   ;16
    DCD  SysHeapStart             ;17
osri6_maxvalue * 17
@


4.15.2.1
log
@* Converted to building with ObjAsm (but still a single object file using ORG).
* Added ARM_IMB and ARM_IMBRange SWIs as recommended by ARMv5.
* Some early prototype HAL bits popped in - a lot of source restructuring still
  to come.
* New debug target creates an AIF image with debug information, and translates
  this into an ASCII object file for the 16702B logic analyser.

Version 5.35, 4.79.2.1. Tagged as 'Kernel-5_35-4_79_2_1'
@
text
@d291 1
a291 1
        MSR     CPSR_c, R14             ; get at registers r13 and r14
d320 1
a320 1
        MSR     CPSR_c, #I32_bit + SVC32_mode
d389 1
a389 1
       ADRL R5, ABORTP
d413 1
a413 1
        MSR     SPSR_cxsf, r0
d634 1
a634 1
        MSR     CPSR_c, R2              ; change into original mode
d642 1
a642 1
        MSR     CPSR_c, #I32_bit+F32_bit+SVC32_mode ; into SVC mode
d729 1
a729 1
        MRS     R2, CPSR
d732 1
a732 1
        MSR     CPSR_c, R3                      ; FIQs back on
d735 1
a735 1
        MSR     CPSR_c, R3
d738 1
a738 1
        MSR     CPSR_c, R3
d762 1
a762 1
        MRS     R1, SPSR
d784 1
a784 1
        MRS     R1, SPSR
d807 1
a807 1
        MRS     R1, SPSR
d820 1
a820 1
        MSR     CPSR_c, #F32_bit :OR: I32_bit :OR: SVC32_mode ; FIQ off too
d831 1
a831 1
        MRS     R1, SPSR
d852 1
a852 1
        MRS     R0, CPSR
d855 1
a855 1
        MRS     R0, CPSR                        ; Fake up a combined PC+PSR (PC=0)
d886 1
a886 1
        MRS     r12, CPSR
d891 1
a891 1
        MSR     CPSR_cf, r10        ; ints on, stay in SVC mode, flags in psr
d901 1
a901 1
        MRS     R10, CPSR
@


4.15.2.2
log
@  Added HAL NVRAM support
Detail:
  Added the HAL NVRAM entries.
  Modified i2cutils to use the HAL entries for NVRAM and behave sensibly if the HAL reports that there is no NVRAM, in which case there must be a forced reset_cmos call so that the cache gets set up sensibly.
Admin:
  Tested under the RPC emulator and appears to be working correctly, although some calls to IIC are still being made in the no nvram case.

Version 5.35, 4.79.2.8. Tagged as 'Kernel-5_35-4_79_2_8'
@
text
@d1308 1
d1311 3
a1313 1

@


4.15.2.3
log
@More L7200 HAL work
@
text
@a1288 16

 [ HAL
20
        Push    "r9,r14"
        AddressHAL
        SUB     sp, sp, #12
        ADD     a1, sp, #0
        ADD     a2, sp, #4
        ADD     a3, sp, #8
        CallHAL HAL_HardwareInfo
        MOV     r12, #0
        LDR     r3, [r12, #RawMachineID+0]
        LDR     r4, [r12, #RawMachineID+4]
        Pull    "r0-r2,r9,r14"
        ExitSWIHandler
 |
a1333 1
 ]
a1360 10
 [ HAL
        Push    "r9,r14"
        AddressHAL
        SUB     sp, sp, #8
        ADD     a1, sp, #0
        ADD     a2, sp, #4
        CallHAL HAL_SuperIOInfo
        Pull    "a1,a2,r9,r14"
        ExitSWIHandler
 |
a1383 1
 ]
@


4.15.2.4
log
@More stuff. Up to the desktop now; cache on, working keyboard. Some source
restructuring to start to make splitting it up into several object files more
feasible.
@
text
@a1787 6
 [ HAL
        MOV     r0, #5
        MOV     r1, #0
        MOV     r2, #0
        ExitSWIHandler
 |
a1808 1
 ]
@


4.15.2.5
log
@* Allows interrupt-driven use of PointerV (as well as polled).
* Allows HAL-driven software resets.
* Sound buffers corrected to be uncacheable.

Version 5.35, 4.79.2.33. Tagged as 'Kernel-5_35-4_79_2_33'
@
text
@a241 4
SLEAVESWI
        BIC   lr, lr, #2_01111
        ExitSWIHandler

@


4.15.2.6
log
@Reimplement enhancements to kernel Dynamic Area support from
Ursula. Quite a hairy code merge really, so let's hope it is
worth it to someone. What you get (back after 2 or 3 years):
- much more efficient for largish numbers of DAs (relevance
  to current build = approx 0)
- fancy reason codes to support fast update of
  Switcher bar display (relevance = 0)
- support for clamped maximum area sizes, to avoid address
  space exhaustion with big memory (relevance = 0)
- better implementation of shrinkable DAs, performance
  wise (if lots of DAs, relevance = approx 0)
- support for 'Sparse' DAs. Holey dynamic areas, Batman!
  (relevance, go on someone use the darned things)
Moderately development tested on HAL/32bit ARM9 desktop.
Note the Switcher should be compiled to use the new
reason codes 6&7, for fabled desktop builds.

Also, during this work, so I could see the wood for the
trees, redid some source code clean up, removing pre-Medusa
stuff (like I did about 3 years ago on Ursula, sigh). That's
why loads of source files have changed. The new DA stuff
is confined pretty much to hdr.KernelWS and s.ChangeDyn.

Ta.

Version 5.35, 4.79.2.38. Tagged as 'Kernel-5_35-4_79_2_38'
@
text
@d1340 2
d1343 10
d1727 1
a1727 1
    DCD  0                        ;4 (was ARMA_Cleaner_flipflop, no longer exists in HALised kernel)
@


4.15.2.7
log
@1) Bring IOMD HAL more up to date. Add support for new
call HAL_CleanerSpace (preparation for StrongARM kernel
support).

2) In kernel, add HAL_CleanerSpace call (preparation for
StrongARM and XScale core support). Fix bug found with
ARMv3 support during test on Risc PC.

3) Implement new API for kernel SWIs that have used top
bits of addresses as flags. The new API has an extra
flag that must be set, so kernel can distinguish and
support both APIs. The reason for all this is that
addresses are 32-bits now, people, keep up there. Briefly:

  OS_HeapSort
    bit 31 of r0 set for new API, r1 is full 32-bit address
    flags move from r1 bits 31-29 to r0 bits 30-28

  OS_ReadLine
    bit 31 of r1 set for new API, r0 is full 32-bit address
    flags move from bits 31,30 of r0 to bits 30,29 of r1

  OS_SubstituteArgs
    bit 31 of r2 set for new API, r0 is full 32-bit address
    flag moves from bit 31 of r0 to bit 30 of r2

Tested on Risc PC and briefly on Customer A 2

Ta

Version 5.35, 4.79.2.41. Tagged as 'Kernel-5_35-4_79_2_41'
@
text
@a19 2
;mjs June 2001, API redefined to support full 32-bit addresses

d21 1
a21 4
;       r1 =  max length of line (excluding carriage return), and flags in top 3 bits
;               bit 31 *must* be set to indicate new API supporting 32-bit addresses
;               bit 30 set means don't reflect characters that don't go in the buffer
;               bit 29 set means reflect with the character in R4     
a23 1
;       r4 = character to echo if r1 bit 29 is set
d26 1
a26 2
; Out   r0, r2, r3 corrupted
;       r1 = length of line (excluding carriage return)
d30 12
a41 4
; For backward compatibility, supports old API, assuming address in r0 is
; safe (has top 2 bits clear). The old API uses bits 31,30 of r0 to
; specify flags as in bits 30,29 of r1 above.

d47 1
a47 8

        TST     R1, #&80000000          ; check for old API
        ANDEQ   R7, R0, #&C0000000
        ORREQ   R1, R1, R7, LSR #1
        ORREQ   R1, R1, #&80000000
        BICEQ   R0, R0, #&C0000000      ; if so, munge into new API

        AND     R7, R1, #&E0000000      ; extract flags
d51 1
a51 2
        BIC     R1, R1, #&E0000000      ; zap flags
        MOV     R4, R0                  ; R4 -> buffer
d115 2
a116 2
        TST     R7, #&40000000          ; no reflection
        BNE     %BT10                   ; of non-entered chars
d118 1
a118 1
80      TST     R7, #&20000000
@


4.15.2.8
log
@Lots of Tungsten work.

Version 5.35, 4.79.2.48. Tagged as 'Kernel-5_35-4_79_2_48'
@
text
@a16 36
; Compatibility fudgery for OS_ReadLine and ReadLineV with 32-bit addresses

 [ No26bitCode
ReadLineSWI
        Push    "r4,lr"
        MOV     r4, #0
        SWI     XOS_ReadLine32
        Pull    "r4,lr"
        ; Pass back NZCV bits
        MRS     r11, CPSR
        BIC     lr,  lr,  #N_bit+Z_bit+C_bit+V_bit
        AND     r11, r11, #N_bit+Z_bit+C_bit+V_bit
        ORR     lr, lr, r11
        B       SLVK

ReadLine32SWI
        MOV     r11, #OS_ReadLine
        B       VecSwiDespatch
 |
ReadLine32SWI
        TST     r0, #ARM_CC_Mask-3
        BNE     %FT90
        AND     r11, r4, #ARM_CC_Mask
        ORR     r0, r0, r11
        Push    "r4,lr"
        AND     r4, r4, #&FF
        SWI     XOS_ReadLine
        Pull    "r4,lr"
        B       SLVK_TestV

90      Push    "lr"
        BL      SetErrorBadAddress
        Pull    "lr"
        B       SLVK_SetV
 ]

d20 2
d23 4
a26 5
 [ :LNOT:No26bitCode
;               bit 31 set means don't reflect characters that don't go in the buffer
;               bit 30 set means reflect with the character in R4
 ]
;       r1 =  max length of line (excluding carriage return)
d29 1
a29 8
 [ No26bitCode
;       r4 = flags
;               bit 31 set means don't reflect characters that don't go in the buffer
;               bit 30 set means reflect with the character in R4
;               bits 7-0 = character to echo if r4 bit 30 is set
 |
;       r4 = character to echo if r1 bit 30 is set
 ]
d37 4
d47 7
a53 5
 [ No26bitCode
        MOV     R7, R4                  ; R7 = flags + echo byte
        MOV     R4, R0                  ; R4 -> buffer
 |
        AND     R7, R0, #&C0000000      ; extract flags
d57 2
a58 2
        BIC     R4, R0, #ARM_CC_Mask-3  ; R4 -> buffer
 ]
a481 1
        SWI     XOS_EnterOS
d486 1
a486 1
        B       GOSUPV                          ; switches back to User mode for us
a859 14
 [ XScaleJTAGDebug
        MRS     R0, CPSR
        AND     R0, R0, #&1F
        TEQ     R0, #&15        ; Debug mode?
        BNE     %FT20
        MOV     R13, #0
        LDR     R0, [R13, #ProcessorFlags]
        ORR     R0, R0, #CPUFlag_XScaleJTAGconnected
        STR     R0, [R13, #ProcessorFlags]
        LDR     R0, [R1, #0]
        LDR     R1, [R0, -R0]
        B       DebugStub
20
 ]
a887 29
 [ XScaleJTAGDebug
        ; Magic from the Multi-ICE User Guide
        ALIGN   32
DebugStub ROUT
        ARM_read_control R13
        AND     R13, R13, #MMUC_I
        ORR     R14, R14, R13, LSR #12
        ARM_read_control R13
        ORR     R13, R13, #MMUC_I
        ARM_write_control R13
        ADR     R13, DebugStubLine2
        MCR     p15, 0, R13, C7, C5, 1
        MCR     p15, 0, R13, C7, C5, 6
10      MRC     p14, 0, R15, C14, C0
        BVS     %BT10
        MOV     R13, #&00B00000
        MCR     p14, 0, R13, C8, C0
20      MRC     p14, 0, R15, C14, C0
        BPL     %BT20
        ARM_read_control R13
        TST     R14, #1
        BICEQ   R13, R13, #MMUC_I
        ARM_write_control R13
        MRC     p14, 0, R13, C9, C0
        MOV     PC, R13
        ALIGN   32
DebugStubLine2
        SPACE   32
 ]
d1168 15
a1182 3
        CMP     r0,#10 ;R0 > 9, so illegal value
        ADDLO   PC, PC, R0,LSL #2
        B       ReadSysInfo_InvalidReason
d1184 1
a1184 10
        B       %FT00
        B       %FT10
        B       %FT20
        B       %FT30
        B       %FT40
        B       %FT50
        B       %FT60
        B       %FT70
        B       %FT80
        B       %FT90
a1185 1
ReadSysInfo_InvalidReason
a1312 4
        MOV     r3, r3, LSR #8                  ; lose first 8 bits
        ORR     r3, r3, r4, LSL #24             ; and put bits 0..7 of r3 into bits 24..31 of r2
        MOV     r4, r4, LSL #8                  ; lose CRC bits
        MOV     r4, r4, LSR #16                 ; and move the rest down to the bottom
d1412 1
a1412 1
; ReadSysInfo(4)
d1416 2
a1417 2
; On exit:        r0 = LS32bits of Ethernet Network Address (or 0)
;                 r1 = MS16bits of Ethernet Network Address (or 0)
d1426 1
a1426 1
        TEQ     r1, #&81                                ; Excellent,a custom part - we'll use it
d1429 1
d1432 7
a1438 1
        TEQ     r1, r0                                  ; Is this an Acorn part?
a1439 1
        BNE     %FT45
d1442 2
a1443 2
        LDR     r1, =&0000A4100000
        ADD     r0, r1, r0                              ; Add Acorn base Ethernet address to number from Dallas
d1451 1
a1451 10
        MOV     r1, #0                                  ; Top 16 bits are zero in Acorn's MAC address allocation
        ExitSWIHandler
45
        MOV     r1, r1, LSR #8                          ; It's unique,but not an Acorn part - extract MAC address verbatim
        Push    "r2"
        LDR     r2, [ r0, #RawMachineID ]
        MOV     r2, r2, LSR #8
        LDRB    r0, [r0, #RawMachineID+4]
        ORR     r0, r2, r0, LSL#24
        Pull    "r2"
d1473 1
a1473 1
        = "MACAddress", 0
d1475 1
a1475 1
        = "MACAddressChecksum", 0
d1606 5
a1610 5
        MOV     r1, sp
        MOV     r2, #6
        SWI     XNVRAM_Read
        MOVVS   r0, #&ffffffff
        TST     r0, #&80000000                          ; Check for errors
d1614 2
a1615 2
        ADD     r1, sp, #6
        MOV     r2, #1
d1617 2
a1618 2
        MOVVS   r0, #&ffffffff
        TST     r0, #&80000000                          ; Check for errors
d1621 2
a1622 2
        MOV     r0, #0
        MOV     r1, #0
d1624 2
a1625 2
        LDRB    r3, [sp, #0]                            ; Get the first byte into checksum
        MOV     r1, r3, ASL #8                          ; Store into result
d1627 23
a1649 23
        LDRB    r2, [sp, #1]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        ORR     r1, r1, r2, ASL #0                      ; Store into the result

        LDRB    r2, [sp, #2]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        MOV     r0, r2, ASL #24                         ; Store into the result

        LDRB    r2, [sp, #3]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        ORR     r0, r0, r2, ASL #16                     ; Store into the result

        LDRB    r2, [sp, #4]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        ORR     r0, r0, r2, ASL #8                      ; Store into the result

        LDRB    r2, [sp, #5]                            ; Get the next byte
        ADD     r3, r3, r2                              ; Add to the checksum
        ORR     r0, r0, r2, ASL #0                      ; Store into the result

        LDRB    r2, [sp, #6]                            ; Get the checksum
        AND     r3, r3, #&FF
        EOR     r3, r3, #&FF
d1662 1
a1662 1
; ReadSysInfo(5)
d1666 2
a1667 2
; On exit:        r0 = LSW of Raw data from unique id chip
;                 r1 = MSW of Raw data from unique id chip
d1675 1
a1675 1
; ReadSysInfo(6) - read kernel values (Acorn use only; eg. SoftLoad, ROMPatch)
d1739 2
a1740 2
; ReadSysInfo(7)  - read 32-bit Abort information for last unexpected abort
;                      (prefetch or data)
d1757 1
a1757 1
; ReadSysInfo(8) - Returns summary information on host platform.
a1769 1
;            5 = HAL      (returned for machines running a HAL)
d1809 1
a1809 1
        DCD     IOMD_Original :AND: &FF,   1, &00000005, &0000000F
a1815 31
; OS_ReadSysInfo 9 - Read ROM info
;
; On entry:
;    r0 = 9 (reason code 9)
;    r1 = item number to return
;
; On exit:
;    r0 = pointer to requested string (NULL terminated) or NULL if it wasn't found
;
; Currently defined item numbers are:
;
;    0   = OS name
;    1   = Part number
;    2   = Build date
;    3   = Dealer name
;    4   = User name
;    5   = User address

90
        CMP     R1, #0
        ADREQ   R0, RSI9_OSname     ; The OS name
        BEQ     %FT95
        CMP     R1, #2
        ADREQ   R0, RSI9_Builddate  ; The build date (dynamically generated)
        MOVNE   R0, #0              ; Other ones are unimplemented
95
        ExitSWIHandler

        GET    s.Time+Date
RSI9_OSname    = "$SystemName $VString",0
RSI9_Builddate = "$Builddate",0
a1816 1
        ALIGN
@


4.15.2.9
log
@  Commit of kernel as featured in release 5.00.
Detail:
  Lots of changes since last version, at least the following:
  * Updated OS timestamp, removed alpha status
  * Negative INKEY OS version changed to &AA
  * GraphicsV is now alocated vector number &2A
  * ROM moved up to &FC000000
  * Max application slot increased to 512 Mbytes (for now)
  * Max size of RMA increased to 256 Mbytes
  * RMA is now first-created dynamic area (so it gets lowest address after
    top of application slot)
  * OS_Memory 10 reimplemeted
  * New OS_ReadSysInfo 6 values 18-22 added
  * OS_ReadSysInfo 8 gains flag bit to indicate soft power-off
  * Misc internal top-bit-set-address fixes
  * *ChangeDynamicArea can take sizes in megabytes or gigabytes
  * Magic word "&off" in R0 passed to OS_Reset powers down if possible
  * Added acceleration: block copy; CLS; text window scroll up; rectangle
    fill
  * Disabled LED flashing in page mode (liable to crash)
  * Masked sprite plot and VDU 5 text avoids reading the screen if possible
  * Framestore made USR mode accessible
  * Fix for VDU 5,127 bug - now relies on font definitions being in extreme
    quarters of memory, rather than bottom half
  * Allocated 64-bit OS_Convert... SWIs
  * IIC errors use allocated error numbers
  * Looks for Dallas RTC before Philips RTC because we're using a Philips
    NVRAM device with the same ID
  * Fix to bug that meant the oscillator in the Dallas RTC wasn't enabled
  * Default mouse type (USB) changed to allocated number
  * Ram disc max size increased to 128 Mbytes (Ursula merge) and made
    cacheable for StrongARMs (not XScale)
  * Branch through zero handler now works in USR mode, by use of a
    trampoline in the system stack to allow PC-relative register storage
  * Address exception handler changed to not use 0 as workspace
  * OS_Memory 13 extended to allow specification of cacheability and access
    privileges
  * Added OS_Memory 16 to return important memory addresses
  * RISCOS_MapInIO() takes cacheable flag in bit 3, access permissions in
    bits 10 and 11, doubly-mapped flag in bit 20, and access permissions
    specified flag in bit 21
  * Bug fix in last version for application abort handlers didn't quite
    work; register shuffle required
  * "Module is not 32-bit compatible" error now reports the module name
  * Default configured language changed from 10 to 11 (now Desktop again)

Version 5.35, 4.79.2.51. Tagged as 'Kernel-5_35-4_79_2_51'
@
text
@a725 1
       [ :LNOT:No26bitCode
d729 1
d868 2
a869 3
        ; ??? in ABT32 mode, with a stack?
        Push    R14
        SETPSR  F_bit :OR: I_bit, R14
d877 1
d881 2
a882 2
        Pull    R0
        STR     R0, [R14, #(15-8)*4]
a883 1
        MOV     R0, R14
a889 1
; We go through a trampoline which stores R1 and R14 (at R14 on entry)
a890 2
Branch0_NoTrampoline_DummyRegs
        &       &DEADDEAD, &DEADDEAD
a891 3
Branch0_NoTrampoline
        ADR     R14, Branch0_NoTrampoline_DummyRegs
Branch0_FromTrampoline
d893 1
d896 1
a896 5
        STMIA   R1, {R0-R13}
        LDR     R0, [R14, #0]
        STR     R0, [R1, #1*4]
        LDR     R0, [R14, #4]
        STR     R0, [R1, #14*4]
d906 2
a907 1
        LDMIA   R1, {R0, R1}
d925 2
a926 1
        MOV     R0, #0
a931 1
 [ :LNOT: No26bitCode
d936 1
a936 2
        B       .+Branch0_Trampoline
 ]
d1789 1
a1790 1
        MOVHI   r0,#0
d1795 1
a1796 1
        MOVHI   r2,#0
d1803 19
a1821 24
    DCD  CamEntriesPointer                            ;0
    DCD  MaxCamEntry                                  ;1
    DCD  PageFlags_Unavailable                        ;2
    DCD  PhysRamTable                                 ;3
    DCD  0                                            ;4 (was ARMA_Cleaner_flipflop)
    DCD  TickNodeChain                                ;5
    DCD  ROMModuleChain                               ;6
    DCD  DAList                                       ;7
    DCD  AppSpaceDANode                               ;8
    DCD  Module_List                                  ;9
    DCD  ModuleSHT_Entries                            ;10
    DCD  ModuleSWI_HashTab                            ;11
    DCD  IOSystemType                                 ;12
    DCD  L1PT                                         ;13
    DCD  L2PT                                         ;14
    DCD  UNDSTK                                       ;15
    DCD  SVCSTK                                       ;16
    DCD  SysHeapStart                                 ;17
    DCD  JTABLE-SWIRelocation                         ;18 - relocated base of OS SWI despatch table
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;19 - relocated base of IRQ device head nodes
    DCD  DefaultIRQ1V+(DevicesEnd-DefaultIRQ1Vcode)   ;20 - relocated end of IRQ device head nodes
    DCD  IRQSTK                                       ;21 - top of the IRQ stack
    DCD  SoundWorkSpace                               ;22 - workspace (8K) and buffers (2*4K)
osri6_maxvalue * (.-4-osri6_table) :SHR: 2
a1835 1
        LDMIA   r0, {r2, r3}
d1837 2
d1869 1
a1869 1
;     3     = software power off
a1873 7
        Push    "r9,r14"
        AddressHAL
        SUB     sp, sp, #8
        ADD     a2, sp, #0
        ADD     a3, sp, #4
        CallHAL HAL_PlatformInfo
        Pull    "a2,a3,r9,r14"
d1875 2
@


4.15.2.10
log
@Support for keys held down in the HAL at power on.
*Configure ANYTHINGsize was broken due to not setting R0 to ReadUnsigned
IIC ack message uninternationalised
OS_Memory was saying we only had 4M of RAM
VDU4 scrolling when output was switched to sprite was causing corruption
on use of CTRL-J and CTRL-K
Default SystemSize CMOS set to 32k

Version 5.35, 4.79.2.55. Tagged as 'Kernel-5_35-4_79_2_55'
@
text
@d158 1
a158 1
        TST     R7, #&80000000          ; no reflection
d161 1
a161 1
80      TST     R7, #&40000000
@


4.15.2.11
log
@Huge update to L7200 HAL for Customer M 2 demo - now runs with 5.02 Kernel
used in Tungsten.
Added "fast" flash tool for Customer L, allowing ROMs to be sent serially at
115200 baud not 9600 baud.
Fix to VDU despatch for ARMv4 and later.
Fixes to power on delete keyboard and keyboard timeout
Implemented MemoryReadPhys and MemoryAmounts with the HAL.

Version 5.35, 4.79.2.59. Tagged as 'Kernel-5_35-4_79_2_59'
@
text
@d1884 1
a1884 2
;     4     = OS in RAM, else executing in ROM
;     5..31 reserved (currently undefined)
@


4.15.2.12
log
@  Bugfix and header change.
Detail:
  * I noticed in passing that the default exception handlers were broken for
    non-IOMD machines if the exception was raised in FIQ mode - unless you
    had a very large application slot, then the machine would lock up. Now
    properly HAL-ised.
  * Added a new event number, allocated for PRISM use back in June.
Admin:
  Not tested. However, it can't make the situation any worse!

Version 5.35, 4.79.2.78. Tagged as 'Kernel-5_35-4_79_2_78'
@
text
@a686 6
      [ HAL
        BNE     UNDEF2
        MSR     CPSR_c, #I32_bit+F32_bit+SVC32_mode ; into SVC mode so we have a stack
        AddressHAL R2
        CallHAL HAL_FIQDisableAll
      |
a688 1
      ]
a706 7
      [ HAL
        BNE     UNDEF1
        MOV     R4, R14                 ; R14_SVC will be corrupted by the HAL call
        AddressHAL R2
        CallHAL HAL_FIQDisableAll
        MOV     R14, R4
      |
a708 1
      ]
@


4.15.2.13
log
@Added IRQsema to the list of values which can be read back from
OS_ReadSysInfo 6 (subreason code is 23 for IRQsema). This will
be useful if zero page is ever protected and the IRQ semaphore
moved.

Version 5.35, 4.79.2.90. Tagged as 'Kernel-5_35-4_79_2_90'
@
text
@a1850 1
    DCD  IRQsema                                      ;23 - the address of the IRQ semaphore (may move if zero page is protected)
@


4.15.2.14
log
@Update the method the HAL kernel uses to determine the UtilityModule & ROM dates
Detail:
  Three main changes:
  * On odd-numbered (i.e. development) versions of the module, the UtilityModule will now take its date from the VersionNum file instead of using a hard-coded date
  * All build versions now look for the new "extended ROM footer" (as created by romlinker 0.04+) at the end of the ROM image and use it to determine the ROM build date for return by OS_ReadSysInfo 9,2. Failing to find the build date in the footer will cause OS_ReadSysInfo 9,2 to return 0.
  * On odd-numbered versions, OS_Byte 0 will now use the ROM build date (as found in the extended footer) to generate the error block that's returned to the user. This seems OK as the PRM describes OS_Byte 0 as returning the "creation date of the operating system". Plus it's a convenient way of getting the ROM build date into the Switcher, since the switcher uses OS_Byte 0. If the extended footer can't be found (or if the string isn't initialised yet, e.g. before Service_PostInit) the code falls back to a hard-coded string containing the date from the VersionNum file.
  File changes:
  Makefile - Updated to not create the obsolete Time+Date file (previously used for the ROM build date)
  Version - Use date from VersionNum file for development builds
  hdr/Options - New UseNewFX0Error variable/option to make it easy to check which OS_Byte 0 variant should be enabled
  hdr/KernelWS - Added new string buffers & extended ROM footer pointer to workspace
  s/Middle - Updated OS_ReadSysInfo 9 code, and added utility functions for searching the extended ROM footer for certain tags
  s/NewReset - Added a couple of calls to initialise the new string buffers just prior to Service_PostInit. This is required since OS_Byte/OS_ReadSysInfo shouldn't enable interrupts, but date conversion relies on the Territory module, which may enable interrupts.
  s/PMF/osbyte - Updated OS_Byte 0 code
Admin:
  Tested in Tungsten ROM, with and without the extended footer present.


Version 5.35, 4.79.2.115. Tagged as 'Kernel-5_35-4_79_2_115'
@
text
@d1960 2
a1961 1
        CMP     R1, #2              ; The build date (dynamically generated)
a1962 25
        BNE     %FT95
        LDR     R0, =ROMBuildDate
        LDRB    R1, [R0]
        CMP     R1, #0
        BNE     %FT94
        ; Build date string hasn't been generated yet. Generate it.
        Push    "r0,r2-r3,lr"
        MOV     R0, #0
        BL      ExtendedROMFooter_FindTag
        CMP     R0, #0              ; Found it?
        STREQ   R0, [R13]
        BEQ     %FT93
        ; For compatability, make this string match the same format as the old
        ; string. Conveniently, this matches the format string used by OS_Word
        ; 14
        LDR     R1, [R13]
        MOV     R2, #?ROMBuildDate
        ADRL    R3, TimeFormat
        SWI     XOS_ConvertDateAndTime
        MOVVS   R0, #0
        STRVS   R0, [R13]
93
        Pull    "r0,r2-r3,lr"
94
        MOV     R1, #2
d1966 1
a1966 75
;
; Extended ROM footer functions
;
; These operate on a new tag-based structure located at the end of the ROM
; image. Each entry consists of a one-byte ID, a one-byte length, and then N
; bytes of data. The length byte doesn't count the two initial header bytes.
;
; The end of the list is implicity terminated by a footer word; the footer word
; contains the length of the structure in the low two bytes (minus the length of
; the footer word), and a 16-bit CRC in the top two bytes (again, minus the
; footer word). The footer word will be word-aligned, but everything else is
; assumed to be byte aligned.
;
; Current tags:
;
; 0     ROM build date, stored as 5-byte time (length = 5)
;

ExtendedROMFooter_Find  ROUT
        ; Find the header word for the extended ROM footer. Returns -1 if not found.
        Push    "r1-r4,lr"
        LDR     r4, =ZeroPage
        LDR     r0, [r4, #ExtendedROMFooter]
        CMP     r0, #0
        BNE     %FT10
        ; Examine the end of the ROM image
        ; Footer should be located just before the standard 20 byte footer
        LDR     r2, =ROM+OSROM_ImageSize*1024-24
        LDR     r1, [r2]
        CMP     r1, #-1
        MOVEQ   r0, r1
        BEQ     %FT09
        ; Check CRC
        MOV     r1, r1, LSL #16
        SUB     r1, r2, r1, LSR #16
        MOV     r3, #1
        SWI     XOS_CRC
        MOVVS   r0, #-1
        BVS     %FT09
        LDR     r1, [r2]
        CMP     r0, r1, LSR #16
        MOVNE   r0, #-1
        MOVEQ   r0, r2
09
        STR     r0, [r4, #ExtendedROMFooter]
10
        Pull    "r1-r4,pc"

ExtendedROMFooter_FindTag  ROUT
        ; Find the tag number given in R0.
        ; Returns data pointer in R0 & length in R1 on success.
        ; Returns 0 in R0 (and corrupt R1) for failure.
        Push    "r2-r3,lr"
        MOV     r2, r0
        BL      ExtendedROMFooter_Find
        CMP     r0, #-1
        BEQ     %FT09
        MOV     r3, r0
        LDR     r0, [r0]
        MOV     r0, r0, LSL #16
        SUB     r0, r3, r0, LSR #16
05
        CMP     r0, r3
        BEQ     %FT09
        LDRB    lr, [r0], #1
        LDRB    r1, [r0], #1
        CMP     lr, r2
        BEQ     %FT10
        ADD     r0, r0, r1
        B       %BT05
09
        MOV     r0, #0
10
        Pull    "r2-r3,pc"

d1968 1
@


4.15.2.15
log
@Add new OS_ReadSysInfo 6 items codes. Change naming of PublicWS values.
Detail:
  s/Middle - Added some new OS_ReadSysInfo 6 items which are needed by the zero page relocation kernel. Also duplicated some existing entries to avoid conflicts with ROL's allocations.
  hdr/OSRSI6, Makefile - New header listing OS_ReadSysInfo 6 items
  hdr/PublicWS - Duplicated the workspace definitions for &0-&4000, but with a 'Legacy_' prefix to their names. Also added some new entries as needed by the zero page relocation kernel. Once existing modules have been updated to use OS_ReadSysInfo & the Legacy_ definitions, the old defs will be removed.
  hdr/KernelWS - Removed 'Export_' prefix from all the exported workspace values, since the kernel can now use the original names directly
  hdr/Options - Dummy HiProcVecs option so merging things will be a bit cleaner
Admin:
  Tested in ROM softload on Iyonix


Version 5.35, 4.79.2.118. Tagged as 'Kernel-5_35-4_79_2_118'
@
text
@d1828 2
a1829 2
    DCD  ZeroPage+CamEntriesPointer                   ;0
    DCD  ZeroPage+MaxCamEntry                         ;1
d1831 1
a1831 1
    DCD  ZeroPage+PhysRamTable                        ;3
d1833 8
a1840 8
    DCD  ZeroPage+TickNodeChain                       ;5
    DCD  ZeroPage+ROMModuleChain                      ;6
    DCD  ZeroPage+DAList                              ;7
    DCD  ZeroPage+AppSpaceDANode                      ;8
    DCD  ZeroPage+Module_List                         ;9
    DCD  ZeroPage+ModuleSHT_Entries                   ;10
    DCD  ZeroPage+ModuleSWI_HashTab                   ;11
    DCD  ZeroPage+IOSystemType                        ;12
a1845 12
    ; **DANGER** - this block conflicts with ROL's allocations
    ; ROL use:
    ; 18 = kernel messagetrans block
    ; 19 = error semaphore
    ; 20 = OS_PrettyPrint dictionary
    ; 21 = Timer 0 latch value
    ; 22 = FastTickerV counts per second
    ; 23 = Vector claimants table
    ; 24 = Number of vectors supported
    ; 25 = IRQSTK
    ; 26 = JTABLE-SWIRelocation
    ; 27 = Address of branch back to OS after SWIs
d1851 1
a1851 22
    DCD  ZeroPage+IRQsema                             ;23 - the address of the IRQ semaphore
    %    (256-(.-osri6_table))
    ; Use 64+ for a repeat of the danger zone, and our new allocations
    DCD  JTABLE-SWIRelocation                         ;64 - relocated base of OS SWI despatch table
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;65 - relocated base of IRQ device head nodes
    DCD  DefaultIRQ1V+(DevicesEnd-DefaultIRQ1Vcode)   ;66 - relocated end of IRQ device head nodes
    DCD  IRQSTK                                       ;67 - top of the IRQ stack
    DCD  SoundWorkSpace                               ;68 - workspace (8K) and buffers (2*4K)
    DCD  ZeroPage+IRQsema                             ;69 - the address of the IRQ semaphore
    ; New allocations
    DCD  ZeroPage+DomainId                            ;70 - current Wimp task handle
    DCD  ZeroPage+OsbyteVars-&A6                      ;71 - OS_Byte vars (previously available via OS_Byte &A6/VarStart)
    DCD  ZeroPage+VduDriverWorkSpace+FgEcfOraEor      ;72
    DCD  ZeroPage+VduDriverWorkSpace+BgEcfOraEor      ;73
    DCD  DebuggerSpace                                ;74
    DCD  DebuggerSpace_Size                           ;75
    DCD  ZeroPage+CannotReset                         ;76
    DCD  ZeroPage+MetroGnome                          ;77 - OS_ReadMonotonicTime
    DCD  ZeroPage+CLibCounter                         ;78
    DCD  ZeroPage+RISCOSLibWord                       ;79
    DCD  ZeroPage+CLibWord                            ;80
    DCD  ZeroPage+FPEAnchor                           ;81
@


4.15.2.16
log
@Add ESC_Status to list of OS_ReadSysInfo 6 items
Detail:
  hdr/OSRSI6, s/Middle - Added ESC_Status to the list of items that OS_ReadSysInfo 6 exports
Admin:
  Tested in ROM softload on Iyonix


Version 5.35, 4.79.2.121. Tagged as 'Kernel-5_35-4_79_2_121'
@
text
@a1884 1
    DCD  ZeroPage+ESC_Status                          ;82
@


4.15.2.17
log
@Merge Cortex kernel into HAL branch
Detail:
  This is a full merge of the Cortex kernel back into the HAL branch. Since the Cortex kernel is/was just a superset of the HAL branch, at this point in time both branches are identical.
  Main features the HAL branch gains from this merge:
  - ARMv6/ARMv7 support
  - High processor vectors/zero page relocation support
  - objasm 4 warning fixes
  - Improved HAL related functionality:
    - Support for HAL-driven RTCs instead of kernel-driven IIC based ones
    - Support for arbitrary size machine IDs
    - Support for multiple IIC busses
    - Support for any HAL size, instead of hardcoded 64k size
    - Probably some other stuff I've forgotten
  - Probably a few bug fixes here and there
Admin:
  Tested on BB-xM & Iyonix.
  Was successfully flashed to ROM on an Iyonix to test the Cortex branch implementation of the 2010 RTC bug fix.
  IOMD build untested - but has been known to work in the past.


Version 5.35, 4.79.2.123. Tagged as 'Kernel-5_35-4_79_2_123'
@
text
@d175 1
a175 1
        LDR     R5, =ZeroPage
d261 1
a261 1
        LDR     R12, =ZeroPage
d295 1
a295 1
        LDR     r10, =ZeroPage
d311 1
a311 1
        STR     r0, [r10], #4
d325 1
a325 1
        LDR     r12, =ZeroPage+BrkAd_ws
d334 1
a334 1
        STR     r0, [r10], #4
d339 1
a339 3
        STMIA   r0, {r1-r12}
        STR     sp, [r0, #12*4]
        STR     r14, [r0, #13*4]
d346 1
a346 2
        STMIA   r14, {r0-r12}
        STR     r13, [r14, #13*4]
d368 1
a368 1
        LDR     r10, =ZeroPage
d456 1
a456 1
NOCALL  LDR     r0, =ZeroPage               ; default callback routine
d471 1
a471 3
        SWI     XOS_EnterOS

        LDR     R0,=ZeroPage+KernelMessagesBlock+4
d499 1
a499 1
        LDR     R1,=ZeroPage+MOSConvertBuffer
d518 2
a519 1
        LDR     R0, =ZeroPage
d543 1
a543 1
        LDR     r13, =ZeroPage
d553 1
a553 1
        LDR     R0,=ZeroPage+KernelMessagesBlock+4
d569 1
a569 1
        LDR     r13, =ZeroPage
d611 1
a611 1
        LDR    R0, =ZeroPage+KernelMessagesBlock+4
d683 1
a683 1
        STMIA   R0, {R8-R12}            ; save the banked registers
a685 1
        STR     SP, [R0, #5*4]
d687 1
a687 3
        STR     R14, [R0, #6*4]
        
     [ HAL
a689 3
      [ ZeroPage <> 0
        LDR     R2, =ZeroPage
      ]
d692 1
a692 1
     |
d695 1
a695 1
     ]
d733 1
a733 1
        LDR     R0, =ZeroPage
d750 1
a750 1
        LDR     r10, =ZeroPage
d770 1
a770 1
        LDR     R0, =ZeroPage
d779 1
a779 1
        LDR     r4, =ZeroPage
d805 1
a805 2
        LDR     R1, =ZeroPage
      [ ZeroPage = 0
a806 4
      |
        MOV     R2, #0
        STR     R2, [R1, #IRQsema]
      ]
d821 1
a821 1
        LDR     R14, =ZeroPage
d843 1
a843 1
        LDR     R14, =ZeroPage
d866 1
a866 1
        LDR     R14, =ZeroPage
d890 1
a890 1
        LDR     R14, =ZeroPage
d915 1
a915 1
        LDR     R1, =ZeroPage
d917 1
a917 2
        STMIA   R1, {R0-R12}
        STR     R13, [R1, #13*4]
d927 1
a927 1
        LDR     R13, =ZeroPage
d1112 1
a1112 1
        &  ZeroPage+MemLimit     ;  MemoryLimit
d1116 1
a1116 1
        &  ZeroPage+UndHan       ; UndefinedHandler
d1120 1
a1120 1
        &  ZeroPage+PAbHan       ; PrefetchAbortHandler
d1124 1
a1124 1
        &  ZeroPage+DAbHan       ; DatabortHandler
d1128 1
a1128 1
        &  ZeroPage+AdXHan       ; AddressExceptionHandler
d1136 3
a1138 3
        &  ZeroPage+ErrHan       ; ErrorHandler
        &  ZeroPage+ErrHan_ws
        &  ZeroPage+ErrBuf
d1140 3
a1142 3
        &  ZeroPage+CallAd       ; CallBackHandler
        &  ZeroPage+CallAd_ws
        &  ZeroPage+CallBf
d1144 3
a1146 3
        &  ZeroPage+BrkAd        ; BreakPointHandler
        &  ZeroPage+BrkAd_ws
        &  ZeroPage+BrkBf
d1148 2
a1149 2
        &  ZeroPage+EscHan       ; EscapeHandler
        &  ZeroPage+EscHan_ws
d1152 2
a1153 2
        &  ZeroPage+EvtHan       ; EventHandler
        &  ZeroPage+EvtHan_ws
d1156 2
a1157 2
        &  ZeroPage+SExitA       ; ExitHandler
        &  ZeroPage+SExitA_ws
d1160 2
a1161 2
        &  ZeroPage+HiServ       ; UnusedSWIHandler
        &  ZeroPage+HiServ_ws
d1164 1
a1164 1
        &  ZeroPage+ExceptionDump ; ExceptionDumpArea
d1168 1
a1168 1
        &  ZeroPage+AplWorkSize  ; application space size
d1172 1
a1172 1
        &  ZeroPage+Curr_Active_Object
d1176 2
a1177 2
        &  ZeroPage+UpCallHan
        &  ZeroPage+UpCallHan_ws
d1273 1
a1273 1
        CMP     r0,#13 ;R0 > 12, so illegal value
a1286 3
        B       ReadSysInfo_InvalidReason ; ROL's "read OS version" call
        B       %FT110
        B       %FT120
d1308 1
a1308 1
        LDR     r10, =ZeroPage
d1325 1
a1325 1
        LDR     r1, =ZeroPage+VduDriverWorkSpace+CurrentMonitorType      ; read current monitortype
d1413 1
a1413 1
        LDR     r12, =ZeroPage
d1531 1
a1531 1
        LDR     r0, =ZeroPage
d1539 1
a1539 1
        LDR     r0, =ZeroPage
d1780 1
a1780 1
        LDR     r0, =ZeroPage
d1900 1
a1900 1
        LDR     r0, =ZeroPage+Abort32_dumparea
a2023 66
; OS_ReadSysInfo 11 - Read debug information
;
; On entry:
;    r0 = 11 (reason code 11)
;
; On exit:
;    r0 = pointer to function for debug character output
;    r1 = pointer to function for debug character input
;     

110
        ; Check if both HAL_DebugTX and HAL_DebugRX are available
        Push    "r8-r9,r14"
        MOV     R8, #1
        MOV     R9, #EntryNo_HAL_DebugTX
        SWI     XOS_Hardware
        MOVVC   R8, #1
        MOVVC   R9, #EntryNo_HAL_DebugRX
        SWIVC   XOS_Hardware
        Pull    "r8-r9,r14"
        BVS     ReadSysInfo_InvalidReason        
        ADR     R0, RSI_DebugTX
        ADR     R1, RSI_DebugRX
        ExitSWIHandler

RSI_DebugTX
        ; In:
        ; R0 = char
        ; Privileged mode
        ; Out:
        ; R0-R3, PSR corrupt
        Push    "r9,r12,r14"
        AddressHAL
        CallHAL HAL_DebugTX
        Pull    "r9,r12,pc"

RSI_DebugRX
        ; In:
        ; Privileged mode
        ; Out:
        ; R0=char read, or -1
        ; R1-R3, PSR corrupt
        Push    "r9,r12,r14"
        AddressHAL
        CallHAL HAL_DebugRX
        Pull    "r9,r12,pc"

; OS_ReadSysInfo 12 - Read extended machine ID
;
; On entry:
;    r0 = 12 (reason code 12)
;    r1 = Pointer to word-aligned buffer, or 0 to read size
;
; On exit:
;    r0 = Size of extended machine ID, or 0 if none/corrupt
;    Buffer in R1 filled, if applicable
;

120
        Push    "r1-r3,r9,r14"
        AddressHAL
        MOV     R0, R1 ; HAL takes the buffer pointer in R0        
        CallHAL HAL_ExtMachineID
        Pull    "r1-r3,r9,r14"
        ExitSWIHandler

@


4.15.2.18
log
@Rationalise some old switches.
Export less in hdr:RISCOS.
Delete unused GetDecimalPair routine.
Move CheckYear with other RTC stuff out of PMF/osword.
Hide DebugROMInit and DebugROMErrors in release (even numbered) versions.

Version 5.35, 4.79.2.127. Tagged as 'Kernel-5_35-4_79_2_127'
@
text
@d1061 1
a1061 1
  [ {FALSE}
d1112 1
a1112 1
   [ {FALSE}
@


4.15.2.19
log
@Add compressed ROM support. Make more use of ARMv5+ instructions. Other misc tweaks.
Detail:
  hdr/OSEntries, s/HAL, s/Kernel - Add compressed ROM support.
  With the current scheme, a compressed ROM will have everything except the HAL and kernel compressed.
  During the keyboard scan period the kernel will allocate some temporary decompression workspace and call the decompression stub that was appended to the ROM.
  The decompression stub is expected to perform in-place decompression of the ROM. Once decompression is complete the workspace will be freed and the page tables updated to make the ROM image readonly.
  It's the HAL's responsibility to make sure any compressed ROM is located in an area of physically contiguous RAM large enough to hold the uncompressed image.
  More info here: http://www.riscosopen.org/wiki/documentation/show/Compressed%20ROMs
  Makefile, h/OSEntries - Add C export of hdr/OSEntries
  hdr/HALDevice - Add device ID for Tungsten video device. Convert tabs to spaces for consistency.
  hdr/HALEntries, s/NewReset - Moved KbdFlag_* definitions to hdr/HALEntries so HALs can use them in their keyboard scan code
  s/ArthurSWIs, S/HAL, s/HeapSort, s/Kernel, s/MemInfo, s/Middle, s/NewIRQs, s/TickEvents, s/vdu/vdugrafb - Make use of BLX, BFI and long multiplies if the CPU supports them. Don't support SWI calls from thumb mode if the CPU doesn't support thumb.
  s/HAL - Made the LDMIA in Init_MapInRAM more sensible (register order was backwards). The old code did work, but wasn't doing what the comments described. Removed unused/unfinished HAL_Write0 function. Improve RISCOS_LogToPhys to check L1PT for any section mappings if the logical_to_physical call fails
  s/ModHand - Save one instruction by using ADR instead of MOV+ADD to compute lr
  s/NewReset, s/PMF/key - Pass L1PT to HAL_Reset to allow machines without hardware reset (e.g. IOMD) to perform resets by manually disabling the MMU and restarting the ROM
  s/vdu/vdudriver, s/vdu/vdugrafv - Use GVEntry macro borrowed from NVidia module for setting up the GraphicsV jump table. Make GraphicsV_ReadPaletteEntry call HAL_Video_ReadPaletteEntry if left unclaimed. Fixup GV_Render to only call HAL_Video_Render if the HAL call is implemented.
Admin:
  Tested with OMAP3, IOMD & Tungsten ROMs/softloads.


Version 5.35, 4.79.2.138. Tagged as 'Kernel-5_35-4_79_2_138'
@
text
@a26 1
      [ NoARMT2
a29 5
      |
        ASSERT (N_bit+Z_bit+C_bit+V_bit)=&F0000000
        MOV     r11, r11, LSR #28
        BFI     lr, r11, #28, #4
      ]
a1018 1
      [ NoARMT2
a1022 5
      |
        MOV     lr, lr, LSR #28
        BIC     r10, r12, #I32_bit:OR:F32_bit
        BFI     r10, lr, #28, #4 ; copy user flags (I bit clear)
      ]
a1029 1
 [ NoARMT2
d1032 1
a1032 1
   [ No26bitCode
d1035 1
a1035 1
   |
d1037 1
a1037 1
   ]
a1038 7
 |
        ASSERT  No26bitCode
        MRS     R10, CPSR
        Pull    lr
        MOV     R10, R10, LSR #28
        BFI     lr, R10, #28, #4
 ]
a2124 2
; 1     Compressed ROM softload hint (length = 8). First word is negative
;       checksum of uncompressed image, second word is OS header offset.
@


4.15.2.19.2.1
log
@Fix callback and breakpoint environment handlers to work with zero page relocation
Detail:
  s/Middle - Callback and breakpoint environment handler workspace is now specified as being ZeroPage relative
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.10. Tagged as 'Kernel-5_35-4_79_2_147_2_10'
@
text
@d438 1
a438 1
       LDR  R0, =ZeroPage+DUMPER
d449 1
a449 1
       LDR  R0, =ZeroPage+DUMPER
d1263 1
a1263 1
     & ZeroPage+DUMPER
d1267 1
a1267 1
     & ZeroPage+DUMPER
@


4.15.2.19.2.2
log
@Merge with HAL branch
Detail:
  Merge the HAL branch into the RPi branch, prior to merging RPi to HAL
  Brief summary of main changes brought in:
  * Added *cache functionality previously provided by ARM module
  * Added "CMOS RAM reset" message on startup when CMOS has been wiped by keypress
  * Renamed HAL Video entries from HAL_Video_XXX to HAL_VideoXXX
  * Dropped mjsHAL macros, GRAB/STASH macros
  * Fixed pseudo-VRAM allocation when machine has exactly 16MB of RAM
  * Added OS_Hardware 5
  * Use OS_SerialOp GetDeviceName for getting serial device name
  * Drop HAL_MonitorLeadID
  * Rework default GraphicsV_IICOp handler
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 5.35, 4.79.2.147.2.23. Tagged as 'Kernel-5_35-4_79_2_147_2_23'
@
text
@d1132 15
d2076 1
a2076 1
        MOV     R8, #OSHW_LookupRoutine
d2079 1
a2079 1
        MOVVC   R8, #OSHW_LookupRoutine
@


4.15.2.20
log
@Fix failure to boot with exactly 16MB of RAM
With no VRAM, in Kernerl.s.HAL line 370, the less than 16M case sets aside half the RAM as available for video (more than, it uses no more than 32M) but the exactly equals 16M case set aside none.
Add some exports to hdr.HALEntries to define the subreasons to OS_Hardware.

Version 5.35, 4.79.2.154. Tagged as 'Kernel-5_35-4_79_2_154'
@
text
@d2076 1
a2076 1
        MOV     R8, #OSHW_LookupRoutine
d2079 1
a2079 1
        MOVVC   R8, #OSHW_LookupRoutine
@


4.15.2.21
log
@Fix callback and breakpoint environment handlers to work with zero page relocation
Detail:
  s/Middle - Callback and breakpoint environment handler workspace is now specified as being ZeroPage relative
Admin:
  Untested, but same fix as on RPi branch


Version 5.35, 4.79.2.155. Tagged as 'Kernel-5_35-4_79_2_155'
@
text
@d438 1
a438 1
       LDR  R0, =ZeroPage+DUMPER
d449 1
a449 1
       LDR  R0, =ZeroPage+DUMPER
d1263 1
a1263 1
     & ZeroPage+DUMPER
d1267 1
a1267 1
     & ZeroPage+DUMPER
@


4.15.2.22
log
@Sort out SetBorder
NewReset.s:
The one remaining use of SetBorder was to denote the user asked for and got a CMOS reset, which in the HAL case emitted a warning because setting the border is potentially complicated/slow.
To solve this, the reset is noted and replaces the normal RISC OS banner with a warning message. The behaviour and text for this comes from the BBC Master, though the escape key is used in place of break since a reset isn't actually needed.
Moved the unused cputable inside its corresponding switch.
Two occurrences of WriteS_Translated would have executed the message in the V=1 case.
KernelWS/Resources:
Flag added to workspace, translation added to messages files.
Heapman.s:
Commented out use of SetBorder removed.
Kernel.s:
SetBorder macro removed.
Middle.s:
Switched out use of SetBorder removed.
Super1.s:
Conditional WriteS_Translated would try to execute the message in the opposite condition case.


Version 5.35, 4.79.2.157. Tagged as 'Kernel-5_35-4_79_2_157'
@
text
@d1132 15
@


4.15.2.23
log
@Add support for new extended internal key codes, low level key codes, and key handler format
Detail:
  s/Middle - Added OS_ReadSysInfo 13 to allow the kernel to validate a key handler before the owner attempts to install it
  Resources/UK/Messages - Text for new "Bad key handler" error
  s/GetAll, s/PMF/Def - Get rid of now obsolete s/PMF/Def file. It only contained definitions for pre-HAL hardware, and for the key handler layout (now in Hdr:Keyboard)
  hdr/KeyWS - Increased size of KeysDown array so it can hold 768 keys instead of 160. Trim a couple of obsolete variables, and increase CurrKey/OldKey from 1 byte to 4 bytes.
  s/PMF/key, s/PMF/osbyte - Main bulk of the changes for the new key handling. All the important interfaces are now able to deal with extended (i.e. > 8 bit) internal key numbers, and the kernel is able to cope with key handlers which use 16 bit internal/low level key numbers instead of 8 bit.
Admin:
  Tested on Pandora & BB-xM
  Requires HdrSrc-2_20


Version 5.35, 4.79.2.178. Tagged as 'Kernel-5_35-4_79_2_178'
@
text
@d1294 1
a1294 1
        CMP     r0,#14 ;R0 > 13, so illegal value
a1310 1
        B       %FT130
a2113 33
; OS_ReadSysInfo 13 - Validate key handler
;
; On entry:
;    r0 = 13 (reason code 13)
;    r1 = key handler address (0 to just return valid flags)
;
; On exit:
;    r0 = Mask of supported key handler flags
;         Or pointer to error block
;

130
        LDR     R0, =KeyHandler_Flag_Wide
        CMP     R1, #0
        ExitSWIHandler EQ
        Push    "R2"
        LDR     R2, [R1, #KeyHandler_KeyTranSize]
        TST     R2, #KeyHandler_HasFlags
        LDRNE   R2, [R1, #KeyHandler_Flags]
        BICNES  R2, R2, R0
        Pull    "R2"
        ExitSWIHandler EQ
        ADR     R0, ErrorBlock_BadKeyHandler
      [ International
        Push    "lr"
        BL      TranslateError
        Pull    "lr"
      ]
        ORR     lr, lr, #V_bit
        ExitSWIHandler

        MakeErrorBlock BadKeyHandler

@


4.15.2.24
log
@Add OS_NVMemory 6
Permits applications to query what value would be used in the event of a CMOS reset for a given configure value. Notably, the configure plugins will use this in favour of 'ResetCMOS'.
hdr/Options: retire the 'Select16BitSound' switch, add comment for ChecksumCMOS switch
hdr/KernelWS: DuffEntry and Nowhere moved here
Kernel.s: Unused OSMD removed, retire single use of SPIRQ in favour of r13_irq
Middle.s: Retire SPIRQ
NewReset.s: Trim out 300+ lines of CMOS reset defaults, call OS_NVMemory 6 instead
PMF/i2cutils.s: CMOS reset default code and table moved here with refactoring
Note, the previous code preserved YearCMOS during the zeroing, only to unconditionally write it later - so have removed it from the zeroing step.
Note, the locations 80-111 are now considered as system CMOS in the allocations hence are now wiped too (previously they got skipped as user CMOS during R-power-on).

Tested on OMAP3 ROM with delete-power-on and R-power-on variants, and a simple BASIC program to read locations 0-255 via OS_NVMemory.

Version 5.35, 4.79.2.180. Tagged as 'Kernel-5_35-4_79_2_180'
@
text
@d828 1
a828 1
        LDR     r13_irq, =IRQSTK
@


4.15.2.25
log
@Teach the kernel about different memory attributes
Detail:
  Briefly, this set of changes:
  * Adjusts PhysRamTable so that it retains the flags passed in by the HAL from OS_AddRAM (by storing them in the lower 12 bits of the size field)
  * Sorts the non-VRAM entries of PhysRamTable by speed and DMA capability, to ensure optimal memory allocation during OS startup.
  * Adjust the initial memory allocation logic to allow the cursor/sound chunk and HAL noncacheable workspace to come from DMA capable memory
  * Extends OS_Memory 12 to accept a 'must be DMA capable' flag in bit 8 of R0. This is the same as available in ROL's OS.
  * Extends OS_DynamicArea 0 to allow the creation of dynamic areas that automatically allocate from DMA capable memory. In ROL's OS this was done by setting bit 12 of R4, but we're using bits 12-14 for specifying the cache policy, so instead bit 15 is used.
  * Fixes OS_ReadSysInfo 6 to return the correct DevicesEnd value now that the IRQ/device limit is computed at runtime
  File changes:
  * hdr/OSEntries - Add definitions of the various flags passed to OS_AddRAM by the HAL. Add a new flag, NoDMA, for memory which can't be used for DMA.
  * hdr/KernelWS - Tidy PhysRamTable definition a bit by removing all the DRAM bank definitions except the first - this makes it easier to search for code which is interacting with the table. Remove VRAMFlags, it's redundant now that the flags are kept in the table. Add DMA allocation info to InitWs.
  * s/AMBControl/memmap - Updated to mask out the flags from PhysRamTable when reading RAM block sizes.
  * s/ARM600 - Strip out a lot of IOMD specific pre-HAL code.
  * s/ChangeDyn - Updated to cope with the flags stored in PhysRamTable. Implement support for DMA-capable dynamic areas. Rewrite InitDynamicAreas to insert pages into the free pool in the right order so that the fastest memory will be taken from it first.
  * s/GetAll, s/Middle - Fix OS_ReadSysInfo 6 to return the correct HAL-specific DevicesEnd value
  * s/HAL - Significant rework of initial RAM allocation code to allow the kernel workspace to come from the fastest DMA incapable RAM, while also allowing allocation of DMA capable memory for HAL NCNB workspace & kernel cursor/sound chunks. ClearPhysRAM rewritten as part of this.
  * s/MemInfo - Updated to cope with the flags stored in PhysRamTable. Add support for the new OS_Memory 12 flag. Update OS_Memory 7 to not assume PhysRamTable entries are sorted in address order, and rip out the old pre-HAL IOMD implementation.
  * s/NewReset - Remove GetPagesFromFreePool option, assume TRUE (as this has been the case for the past 10+ years). Revise a few comments and strip dead code. Update to cope with PhysRamTable flags.
  * s/VMSAv6 - Remove a couple of unused definitions
  * s/vdu/vdudriver - Update to cope with PhysRamTable flags
Admin:
  Tested in Kinetic RiscPC ROM softload, Iyonix softload, & OMAP3


Version 5.35, 4.79.2.186. Tagged as 'Kernel-5_35-4_79_2_186'
@
text
@d1830 1
a1830 1
        Push    "r0-r4"
d1835 2
a1836 2
        LDR     r4,[r1],#4
        CMP     r4,#-1
d1838 2
a1839 2
        CMP     r4,#osri6_maxvalue
        LDRLS   r0,[r3,r4,LSL #2]
a1840 9
        ; Fix up the DevicesEnd values
        TEQ     r4,#OSRSI6_Danger_DevicesEnd
        TEQNE   r4,#OSRSI6_DevicesEnd
        STRNE   r0,[r2],#4
        BNE     %BT62
        LDR     r4,=ZeroPage
        LDR     r4,[r4,#IRQMax]
        ADD     r0,r0,r4,LSL #3
        ADD     r0,r0,r4,LSL #2
d1845 3
a1847 10
        LDRLS   r0,[r3,r2,LSL #2]
        MOVHI   r0,#0
        ; Fix up the DevicesEnd values
        TEQ     r2,#OSRSI6_Danger_DevicesEnd
        TEQNE   r2,#OSRSI6_DevicesEnd
        LDREQ   r1,=ZeroPage
        LDREQ   r1,[r1,#IRQMax]
        ADDEQ   r0,r0,r1,LSL #3
        ADDEQ   r0,r0,r1,LSL #2
        STR     r0,[sp,#2*4]
d1849 1
a1849 1
        Pull    "r0-r4"
d1885 1
a1885 1
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;20 - relocated end of IRQ device head nodes. NOTE: Gets fixed up when read
d1893 1
a1893 1
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;66 - relocated end of IRQ device head nodes. NOTE: Gets fixed up when read
@


4.15.2.26
log
@Adjust handling of OS_ReadSysInfo 4
Detail:
  s/Middle - If the HAL provides an extended machine ID, make sure OS_ReadSysInfo 4 doesn't return a MAC address. This is because the old-style machine ID which the MAC is extracted from will be completely synthetic and is so known not to contain a MAC (even if it may look like it does)
Admin:
  Tested on BB-xM, Raspberry Pi


Version 5.35, 4.79.2.188. Tagged as 'Kernel-5_35-4_79_2_188'
@
text
@a1555 7
        Push    "r2-r3,r9,r14"
        AddressHAL
        MOV     r0, #0
        CallHAL HAL_ExtMachineID
        Pull    "r2-r3,r9,r14"
        TEQ     r0, #0
        BNE     ExitNoEthernetAddress                   ; Extended machine ID is implemented - don't attempt to extract a MAC from RawMachineID, it's just a hash of the extended ID
@


4.15.2.27
log
@Add support for the new RISC OS 5 style sprite mode word. Add partial support for alpha channel sprite masks. Implement OS_ScreenMode reasons 13-15
Detail:
  ECFShift/ECFYOffset:
  - hdr/PublicWS - Add ECFShift and ECFYOffset to list of public exports (SpriteExtend was using hardcoded values). Rearrange exports so that VduWorkspace exports are now labelled as such.
  - hdr/KernelWS - Make sure ECFShift & ECFYOffset match their exported locations
  - hdr/OSRSI6, s/Middle - Add OS_ReadSysInfo 6 items 83 & 84, for reading ECFYOffset and ECFShift locations
  Mode flags/VDU variables:
  - Makefile - Add hdr/VduExt to the C header exports
  - hdr/VduExt - Get rid of NotRVVTBarWobblyBits macro and defined VDU variables manually so that Hdr2H will handle them. Begin replacing overly generic 'Flag_*' mode flag definitions with 'ModeFlag_*' instead. Define new flags as required by the new screen/sprite modes. Add OS_ScreenMode reason codes and mode selector format (from s.vdu.vdudecl)
  - NewModes/NEWF2, NewModes/OldPSSrc, NewModes/PSSrc, s.vdu.vdu23, s.vdu.vducursoft, s.vdu.vdudriver, s.vdu.vdugrafg, s.vdu.vdugrafj, s.vdu.vdugrafl, s.vdu.vdumodes, s.vdu.vdupal10, s.vdu.vdupal20, s.vdu.vdupalette, s.vdu.vdupalxx, s.vdu.vduwrch - Renaming Flag_* to ModeFlag_*
  - s.vdu.vdudecl - Remove OS_ScreenMode reason codes & mode selector format definitions; these are now in hdr/VduExt. Flag_* -> ModeFlag_* renaming.
  - s.vdu.vdupalxx - Apply a greyscale palette in PV_SetDefaultPalette if the greyscale mode flag is set
  New sprite types:
  - s.vdu.vdudriver - Extend GenerateModeSelectorVars to deal with the wide mask flag, 64K sprites, and the new RISC OS 5 sprite mode word format.
  - s.vdu.vdugrafdec - Store more information about the sprite in the SprReadNColour ... SprLog2BPC block.
  - s.vdu.vdugrafg - Update SpriteVecHandler to be able to detect whether RISC OS 5 format sprites are allowed palettes. Update SetupSprModeData to store the extra sprite info that's defined in vdugrafdec. Update PutSprite to fault any sprites with wide masks - SpriteExtend must be used for that (once implemented!)
  - s.vdu.vdugrafh - Update WritePixelColour to avoid temporary poking of NColour VDU variable for 8bpp sprites. Correctly replicate data when writing to RISC OS 5 format sprites. Update ReadPixelMask, WritePixelMask, SpriteMaskAddr, GetMaskspWidth to deal with wide masks. Delete obsolete bounce_new_format_masks routine.
  - s.vdu.vdugrafi - Comment updated to reflect new reality
  - s.vdu.vdugrafj - Get rid of unused code block in CreateHeader/PostCreateHeader. Update SanitizeSGetMode to generate RISC OS 5 style sprite mode words where applicable. Update DecideMaskSize to rely on GetMaskspWidth for calculating mask width.
  - s.vdu.vdugrafl - Update SwitchOutputToSprite/SwitchOutputToMask to deal with the new sprite formats. Allow PushModeInfoAnyMonitor to fail.
  - s.vdu.vduswis - Extended OS_ReadModeVariable to cope with new sprite types
  Misc:
  - s.vdu.vdudriver - Fixed bug with VIDCList copying where any -1 value in the structure would terminate the copy, instead of only -1 as a control item number
  - s.vdu.vduswis - Implemented OS_ScreenMode 13 (Mode string to specifier), 14 (mode specifier to string), and 15 (set mode by string). Mostly as per ROL's specs, but minus support for teletext attributes, and plus support for new RISC OS 5 attributes (L... layout specifier, 4096 & 24bpp packed modes, etc.)
  - s.vdu.vduwrch - Pick correct default text colours for the new modes
Admin:
  Tested on BB-xM
  Part of an implementation of the Extended Framebuffer Format spec:
  http://www.riscosopen.org/wiki/documentation/show/Extended%20Framebuffer%20Format%20Specification


Version 5.35, 4.79.2.194. Tagged as 'Kernel-5_35-4_79_2_194'
@
text
@a1933 2
    DCD  ZeroPage+VduDriverWorkSpace+ECFYOffset       ;83
    DCD  ZeroPage+VduDriverWorkSpace+ECFShift         ;84
@


4.15.2.28
log
@Add OS_Memory 24 implementation. Change OS_ValidateAddress to use it. Fix kernel leaving the physical access MB in a messy state. Try and protect against infinite abort loops caused by bad environment handlers.
Detail:
  s/MemInfo - Added an implementation of ROL's OS_Memory 24 call. Unlike the old OS_ValidateAddress call, this call should successfully report the presence of all memory areas known to the kernel. It should also correctly indicate which parts of a sparse DA are mapped in, unlike the old OS_ValidateAddress implementation.
  s/ChangeDyn - Update dynamic area handling to construct a lookup table for mapping logical addresses to dynamic areas; this is used by OS_Memory 24 to quickly locate which DA(s) hit a given region
  s/AMBControl/main - Make sure lazy task swapping is marked as disabled when AMB_LazyMapIn is {FALSE} - required so that OS_Memory 24 will give application space the correct flags
  s/ArthurSWIs - Switch OS_ValidateAddress over to using OS_Memory 24, as per ROL. For compatibility, Service_ValidateAddress is still issued for any areas which the kernel doesn't recognise (currently, OS_Memory 24 doesn't issue any service calls itself)
  s/Convrsions - ADR -> ADRL to keep things happy
  s/HAL - Fix L2PT page allocation and RAM clear to release the physical access region once they're done with it
  s/Kernel - Make the error dispatcher validate the error handler code ptr & error buffer using OS_Memory 24 before attempting to use them. If they look bad, reset to default. Should prevent getting stuck in an infinite abort loop in some situations (e.g. as was the case with ticket 279). The system might not fully recover, but it's better than a hard crash.
  s/Middle - Rework data/prefetch/etc. abort handlers so that DumpyTheRegisters can validate the exception dump area via OS_Memory 24 before anything gets written to it. Should also help to prevent some infinite abort loops. Strip 26bit/pre-HAL code to make things a bit more readable.
  hdr/KernelWS - Update comment
Admin:
  Tested on BB-xM, Raspberry Pi


Version 5.35, 4.79.2.222. Tagged as 'Kernel-5_35-4_79_2_222'
@
text
@d444 1
a444 1
       ADRL R4, UNDEF
d670 2
a671 4
; R0 points at r8 in register dump. r0-r7, PC, PSR saved
; R1 is PSR
; R14 points at error block
; In ABT32 or UND32
d674 6
d689 1
d700 1
d708 4
d718 29
d749 5
a753 33
        ; Check that ExceptionDump is safe to use
        Push    "R14"                   ; Preserve error ptr
        LDR     R4, =ZeroPage
        MOV     R3, R0
        LDR     R1, [R4, #ExceptionDump]
        MOV     R0, #24
        ADD     R2, R1, #17*4
        ; Must be SVC-writable, user+SVC readable, word aligned
        SWI     XOS_Memory
        AND     r1, r1, #CMA_Completely_UserR+CMA_Completely_PrivR+CMA_Completely_PrivW
        TEQ     r1, #CMA_Completely_UserR+CMA_Completely_PrivR+CMA_Completely_PrivW
        TSTEQ   r2, #3
        BEQ     %FT05
        ; Reset to default location. Unfortunately the Debugger module is a bit
        ; braindead and will only show the contents of the register dump located
        ; within its workspace, so resetting it to the kernel buffer isn't the
        ; best for debugging. But it's better than an infinite abort loop!
        MOV     R0, #ExceptionDumpArea
        LDR     R1, =ZeroPage+DUMPER
        SWI     XOS_ChangeEnvironment
05
        Pull    "R14"

        ; Copy the dump from the stack to ExceptionDump
        LDR     R0, [R4, #ExceptionDump]
        LDMDB   R3, {R1-R2,R4-R9}       ; R0-R7
        STMIA   R0!, {R1-R2,R4-R9}
        LDMIA   R3, {R1-R2,R4-R10}      ; R8-R15, PSR
        STMIA   R0, {R1-R2,R4-R10}

        SUB     R0, R0, #8*4
                                        ; try and put back user R10-R12
        Push    "R4-R6"                 ; for error handler to find on stack
d757 6
d789 3
d806 1
a807 1
        ; Also a convenient way of getting rid of the temp exception dump
d818 3
d834 1
d836 1
a836 2
        ; Place exception dump on stack until we can be sure ExceptionDump is safe
        STR     R14, [SP, #-8]!
d838 6
a843 2
        SUB     SP, SP, #17*4-8
        MOV     R14, SP
d845 1
d848 3
d856 1
d858 1
a858 1
        STR     R14, [SP, #-8]!
d860 6
a865 2
        SUB     SP, SP, #17*4-8
        MOV     R14, SP
d867 1
d870 3
d875 1
d879 1
d881 1
a881 1
        STR     R14, [SP, #-8]!
d883 6
a888 2
        SUB     SP, SP, #17*4-8
        MOV     R14, SP
d890 1
d893 3
d903 1
d905 1
a905 1
        STR     R14, [SP, #-8]!
d907 6
a912 2
        SUB     SP, SP, #17*4-8
        MOV     R14, SP
d914 1
d917 3
d922 1
d971 1
a973 4
        LDR     R0, =ZeroPage
        LDR     R0, [R0, #ExceptionDump]
        ADD     R0, R0, #8*4

@


4.15.2.29
log
@Add more HAL USB definitions to hdr/HALEntries. Add debug option for calling HangWatch_Dump on serious errors.
Detail:
  hdr/HALEntries - Added definition of the struct returned by HAL_USBControllerInfo
  hdr/Options, s/Middle - Added the option to call HangWatch_Dump on serious errors
Admin:
  Tested on BB-xM


Version 5.35, 4.79.2.235. Tagged as 'Kernel-5_35-4_79_2_235'
@
text
@a704 7
      [ HangWatch
        ; Preserve some registers for inclusion in the HangWatch dump
        MOV     R2, R13
        MOV     R3, R14
        MRS     R5, SPSR
      ]

a709 4
      [ HangWatch
        SWI     &59283                  ; XHangWatch_Dump
      ]

@


4.15.2.30
log
@Fixes to HAL memory info calls and docs
MemInfo.s:
 Several places in this code called the HAL or other ATPCS defined functions like memset() and hoped that the overall result was V clear. If any of them accidentally set V (for example a CMP that straddles 0x80000000) you ended up trying to look up an international error at the address of the reason code to OS_Memory.
 Now, explicitly clear V in the non error cases where an ATPCS function was called.
 Change the HAL_PhysInfo call to expect a physical ROM size back as an inclusive range, to match the RAM range subreason code. Add 1 to correct for this. A value of 0 & 0 is taken to mean "no physical ROM" as before.
Middle.s:
 Document that 255 means "no IOMD" or "no VIDC", that's what the HALs have been using since year dot.

Version 5.35, 4.79.2.248. Tagged as 'Kernel-5_35-4_79_2_248'
@
text
@a1336 1
;                             255 => none
a1339 1
;                             255 => none
a1342 1
;                             255 => none
d1353 1
a1353 1
;               bits 8-15 = IOMD variant (when marked as present in word 0)
d1356 1
a1356 1
;               bits 16-23 = VIDC20 variant (when marked as present in word 0)
@


4.15.2.31
log
@Fix OS_Byte 19 getting stuck if it's called just before the screen blanker activates. Add new OS_ReadSysInfo reason code for determining IIC bus count.
Detail:
  s/PMF/osbyte - For OS_Byte 19, move screen blanker check (and current GraphicsV driver check) inside the WFI loop so that the loop will terminate if the screen should blank (or current GraphicsV driver should die) before the next VSync occurs. Also move the Portable_Idle call to before the interrupt trigger - the old location meant that if the screen blanked we'd continue on to the Portable_Idle call and end up pointlessly stalling the system
  s/Middle - Add OS_ReadSysInfo 14, as a legitimate way of finding the number of IIC buses present on the system
Admin:
  Tested on Pandaboard


Version 5.35, 4.79.2.261. Tagged as 'Kernel-5_35-4_79_2_261'
@
text
@d1248 1
a1248 1
        CMP     r0,#15 ;R0 > 14, so illegal value
a1265 1
        B       %FT140
a2129 16
; OS_ReadSysInfo 14 - Return IIC bus count
;
; On entry:
;    r0 = 14 (reason code 14)
;
; On exit:
;    r0 = Number of IIC buses (as per HAL_IICBuses)
;

140
        Push    "r1-r3,sb,lr"
        AddressHAL
        CallHAL HAL_IICBuses
        Pull    "r1-r3,sb,lr"
        ExitSWIHandler

@


4.15.2.32
log
@Fix software pointer being enabled when it isn't needed. Improve HangWatch support.
Detail:
  s/vdu/vdupointer - For any mode where the software pointer is usable, RestorePointer was restoring the software pointer regardless of whether it was in use at the time RemovePointer was called. This would cause both the software & hardware pointers to be briefly enabled at the same time, potentially causing flickering or other glitches. Fix the issue by making sure RestorePointer only restores if the software pointer was actually in use at the time RemovePointer was called. Also, attempt to deal with the situation where the pointer might have moved to a location where the software pointer is no longer required.
  s/Middle - Improve integration of HangWatch with the abort handler - avoid overwriting the top of the SVC stack so that it can be preserved for the HangWatch dump.
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.270. Tagged as 'Kernel-5_35-4_79_2_270'
@
text
@d715 2
a717 1
        LDR     sp, =SVCSTK-SVCStackSize+512 ; HangWatch doesn't need much stack space, so use the low part, as it's the area that's least likely to contain something useful to the dump
a720 2
        LDR     sp, =SVCSTK             ; Flatten superstack

@


4.15.2.33
log
@Expose more areas via OS_ReadSysInfo 6 & OS_Memory 16. Expose processor vectors base + size via OS_PlatformFeatures.
Detail:
  hdr/KernelWS - Define processor vectors address. Currently same as ZeroPage, but in the future will differ for some machines.
  hdr/OSRSI6, s/Middle - Expose VecPtrTab & NVECTORS via OS_ReadSysInfo items 85 & 86
  s/Kernel - Add OS_PlatformFeatures 32, for returning the base + size of the processor vectors
  s/MemInfo - Add areas 12 thru 15 to OS_Memory 16, for reporting ZeroPage, ProcVecs, DebuggerSpace and ScratchSpace. The task manager can now use these for calculating memory usage instead of assuming 32K workspace from &0-&8000.
Admin:
  Tested on Raspberry Pi


Version 5.35, 4.79.2.271. Tagged as 'Kernel-5_35-4_79_2_271'
@
text
@a1894 2
    DCD  ZeroPage+VecPtrTab                           ;85
    DCD  NVECTORS                                     ;86
@


4.15.2.34
log
@Improve support for VMSAv6 cache policies & memory types. Expose raw ARMops via OS_MMUControl & cache information via OS_PlatformFeatures.
Detail:
  Docs/HAL/ARMop_API - Document two new ARMops: Cache_Examine and IMB_List
  hdr/KernelWS - Shuffle workspace round a bit to allow space for the two new ARMops. IOSystemType now deleted (has been deprecated and fixed at 0 for some time)
  s/ARM600 - Cosmetic changes to BangCam to make it clearer what's going on. Add OS_MMUControl 2 (get ARMop) implementation.
  s/ARMops - Switch out different ARMop implementations and XCB tables depending on MMU model - helps reduce assembler warnings and make it clearer what code paths are and aren't possible. Add implementations of the two new ARMops. Simplify ARM_Analyse_Fancy by removing some tests which we know will have certain results. Use CCSIDR constants in ARMv7 ARMops instead of magic numbers. Update XCB table comments, and add a new table for VMSAv6
  s/ChangeDyn - Define constant for the new NCB 'idempotent' cache policy (VMSAv6 normal, non-cacheable memory)
  s/HAL - Use CCSIDR constants instead of magic numbers. Extend RISCOS_MapInIO to allow the TEX bits to be specified.
  s/Kernel - OS_PlatformFeatures 33 (read cache information) implementation (actually, just calls through to an ARMop)
  s/MemInfo - Modify VMSAv6 OS_Memory 0 cache/uncache implementation to use the XCB table instead of modifying L2_C directly. This allows the cacheability to be changed without affecting the memory type - important for e.g. unaligned accesses to work correctly. Implement cache policy support for OS_Memory 13.
  s/Middle - Remove IOSystemType from OS_ReadSysInfo 6.
  s/VMSAv6 - Make sure BangCam uses the XCB table for working out the attributes of temp-uncacheable pages instead of manipulating L2_C directly. Add OS_MMUControl 2 implementation.
  s/AMBControl/memmap - Update VMSAv6 page table pokeing to use XCB table
  s/PMF/osinit - Remove IOSystemType reference, and switch out some pre-HAL code that was trying to use IOSystemType.
Admin:
  Tested on Iyonix, ARM11, Cortex-A7, -A8, -A9, -A15
  Note that contrary to the comments in the source the default NCB policy currently maps to VMSAv6 Device memory type (as per previous kernel versions). This is just a temporary measure, and it will be switched over to Normal, non-cacheable once appropriate memory barriers have been added to the affected IO code.


Version 5.35, 4.79.2.273. Tagged as 'Kernel-5_35-4_79_2_273'
@
text
@d1847 1
a1847 1
    DCD  0                                            ;12 (was IOSystemType)
@


4.15.2.35
log
@Add initial support for "physical memory pools"
Detail:
  This set of changes adds support for "physical memory pools" (aka PMPs), a new type of dynamic area which allow physical pages to be claimed/allocated without mapping them in to the logical address space. PMPs have full control over which physical pages they use (similar to DAs which request specific physical pages), and also have full control over the logical mapping of their pages (which pages go where, and per-page access/cacheability control).
  Currently the OS makes use of two PMPs: one for the free pool (which now has a logical size of zero - freeing up gigabytes of logical space), and one for the RAM disc (logical size of 1MB, allowing for a physical size limited only by the amount of free memory)
  Implementing these changes has required a number of other changes to be made:
  * The CAM has been expanded from 8 bytes per entry to 16 bytes per entry, in order to allow each RAM page to store information about its PMP association
  * The system heap has been expanded to 32MB in size (from just under 4MB), in order to allow it to be used to store PMP page lists (1 word needed per page, but PMP pages may not always have physical pages assigned to them - so to allow multiple large PMPs to exist we need more than just 1 word per RAM page)
  * The &FA000000-&FBFFFFFF area of fixed kernel workspace has been shuffled around to accomodate the larger CAM, and the system heap is now located just above the RMA.
  * SoftResets code stripped out (unlikely we'll ever want to fix and re-enable it)
  * A couple of FastCDA options are now permanently on
  * Internal page flags shuffled around a bit. PageFlags_Unavailable now publicly exposed so that PMP clients can lock/unlock pages at will.
  * When OS_ChangeDynamicArea is asked to grow or shrink the free pool, it now implicitly converts it into a shrink or grow of application space (which is what would happen anyway). This simplifies the implementation; during a grow, pages (or replacement pages) are always sourced from the free pool, and during a shrink pages are always sent to the free pool.
  File changes:
  - hdr/KernelWS - Extend DANode structure. Describe CAM format. Adjust kernel workspace.
  - hdr/OSRSI6, s/Middle - Add new item to expose the CAM format
  - hdr/Options - Remove SoftResets switch. Add some PMP switches.
  - s/ARM600, s/VMSAv6 - Updated for new CAM format. Note that although the CAM stores PMP information, BangCamUpdate currently doesn't deal with updating that data - it's the caller's responsibility to do so where appropriate.
  - s/ChangeDyn - Lots of changes to implement PMP support, and to cope with the new CAM format.
  - s/HAL - Updated to cope with new CAM format, and lack of logical mapping of free pool.
  - s/MemInfo - Updated to cope with new CAM format. OS_Memory 0 updated to cope with converting PPN to PA for pages which are mapped out. OS_Memory 24 updated to decode the access permissions on a per-page basis for PMPs, and fixed its HWM usage for sparse DAs.
  - s/NewReset - Soft reset code and unused AddCamEntries function removed. Updated to cope with new CAM format, PMP free pool, PMP RAMFS
  - s/AMBControl/allocate - Update comment (RMA hasn't been used for AMBControl nodes for a long time)
  - s/AMBControl/growp, s/AMBControl/memmap, s/AMBControl/shrinkp - Update for new CAM format + PMP free pool
  - s/vdu/vdudriver - Strip out soft reset code.
Admin:
  Tested on Pandaboard
  This is just a first iteration of the PMP feature, with any luck future changes will improve functionality. This means APIs are subject to change as well.


Version 5.35, 4.79.2.284. Tagged as 'Kernel-5_35-4_79_2_284'
@
text
@a1896 1
    DCD  1                                            ;87 CAM format: 0 = 8 bytes/entry, 1 = 16 bytes/entry
@


4.15.2.36
log
@Fix handling of FIQ mode exceptions
Detail:
  s/Middle - When handling an FIQ-mode exception, protect the register dump pointer around the call to HAL_FIQDisableAll
Admin:
  Tested on Raspberry Pi
  Fixes data abort within kernel when an abort occurs is FIQ mode


Version 5.35, 4.79.2.292. Tagged as 'Kernel-5_35-4_79_2_292'
@
text
@a696 1
        Push    "r0"
a701 1
        Pull    "r0"
@


4.15.2.37
log
@Add OS_ReadSysInfo 9,6 and 9,7
Subreason 7 returns a string naming the HAL platform. Use HAL entry 97 to get this, and obsolete 97/98/99 in favour of using a HAL device. Line up the HAL video entries to match the others.
Subreason 6 is just back filling one ROL added, testing this on RISC OS Select just returned the OS name so we do the same now (same as subreason 0, not sure what ROL's distinction was for).
Allocate a HAL device for PATA IDE controllers, and the 2 known ones to date - Tungsten and IOMD systems.

Version 5.35, 4.79.2.301. Tagged as 'Kernel-5_35-4_79_2_301'
@
text
@a2002 2
;    6   = Printable OS description
;    7   = Hardware platform
d2006 1
a2006 2
        CMPNE   R1, #6
        ADREQ   R0, RSI9_OSname     ; The OS name or description
a2008 2
        BEQ     %FT92
        CMP     R1, #7              ; The hardware platform
a2010 8

        Push    "r1-r3,r9,lr"
        AddressHAL
        MOV     a1,#0               ; Return NULL if HAL doesn't implement it
        CallHAL HAL_PlatformName
        Pull    "r1-r3,r9,lr"
        B       %FT95
92
d2014 1
a2014 2
        MOVNE   R1, #2              ; Restore R1
        BNE     %FT95
d2016 1
a2016 1
        Push    "r0-r3,lr"
d2032 3
a2034 1
        Pull    "r0-r3,lr"
@


4.15.2.38
log
@Add SWI error pointer validation, SeriousErrorV hooks, and OS_ReadSysInfo 15
Detail:
  Resources/UK/Messages, hdr/KernelWS, s/Kernel - On return from a SWI with V set, do some basic validity checks on the error pointer in order to try and catch buggy SWIs that return bad pointers or invalid error blocks. If a bad pointer is found we'll substitute it with a pointer to a different error block, which has the SWI number in the error message, to allow the user to identify the source of the problem. (There's also a chance we'll crash when investigating a bad pointer, but crashing here in the kernel is preferable to crashing elsewhere because R12 should still contain the SWI number)
  hdr/OSMisc - Define SeriousErrorV reason codes and extended ROM footer entry IDs
  hdr/Options - Remove HangWatch integration flag, obsolete now that SeriousErrorV is available
  s/ArthurSWIs - Keep defaultvectab up to date with vector allocations
  s/Middle - Update serious error handling to call SeriousErrorV at several key points. This allows for accurate crash dumps to be obtained, along with a mechanism to warn low-level components such as RTSupport that the privileged mode stacks are being flattened.
  s/Middle - Add OS_ReadSysInfo 15, for enumerating extended ROM footer entries
  s/PMF/osbyte - Update InitNewFX0Error to use the ROM footer entry ID defined in hdr/OSMisc
Admin:
  Tested on Pi 1B, 2B, 3B


Version 5.35, 4.79.2.313. Tagged as 'Kernel-5_35-4_79_2_313'
@
text
@d674 1
a674 1
        MOV     R7, R14                 ; put error address into unbanked register
d696 1
a696 1
        MSR     CPSR_c, #I32_bit+F32_bit+ABT32_mode ; into ABT mode so we have a stack (try and preserve SVC stack for any exception dump that's produced)
d705 10
d717 4
a720 8
        ; R0 points at R8 in register dump
        ; R7 points at error block
        MSR     CPSR_c, #I32_bit+F32_bit+ABT32_mode ; into ABT mode for exception dump
        SUB     R0, R0, #8*4            ; Make R0 sensible for vector
        MOV     R1, R7
        MOV     R2, #SeriousErrorV_Collect
        MOV     R10, #SeriousErrorV
        BL      CallVector
a721 1
        MSR     CPSR_c, #I32_bit+F32_bit+SVC32_mode ; into SVC mode
d725 1
a725 1
        Push    "R7"                    ; Preserve error ptr
d745 1
a745 1
        Pull    "R14"                   ; Restore error ptr
d749 1
a749 1
        LDMIA   R3!, {R1-R2,R4-R9}      ; R0-R7
d793 3
a795 24
        BNE     %FT20
        MOV     R4, R0
        MOV     R0, R10
        BL      TranslateError_UseR4
        ; If the exception dump processing takes too long then there's a good
        ; chance the error buffer MessageTrans gave us will get overwritten
        ; before we're able to call OS_GenerateError. Copy the error to the
        ; stack, then copy it back into a MessageTrans block before calling
        ; OS_GenerateError.
        EORS    R4, R0, R10 ; Did TranslateError work?
        BEQ     %FT20
        SUB     SP, SP, #256
        MOV     R4, SP
        MOV     R5, #4
        LDR     R6, [R0]
        STR     R6, [R4]
11
        LDRB    R6, [R0, R5]
        CMP     R6, #0
        STRB    R6, [R4, R5]
        ADD     R5, R5, #1
        BNE     %BT11
        MOV     R0, R4
20
d816 2
a817 2
        MOV     R3, #0
        STR     R3, [R1, #IRQsema]
a819 29

        ; Trigger exception dump processing
        ORR     R3, R2, #SVC32_mode
        MSR     CPSR_c, R3

        ; Let everyone know that the stacks have been reset
        MOV     R2, #SeriousErrorV_Recover
        MOV     R10, #SeriousErrorV
        BL      CallVector

        ; Now enable IRQs and trigger exception dump processing
        MSR     CPSR_c, #SVC32_mode
        MOV     R2, #SeriousErrorV_Report
        MOV     R10, #SeriousErrorV
        BL      CallVector

      [ International
        ; Try and copy error block from stack back to MessageTrans
        LDR     R3, =ZeroPage
        LDRB    R3, [R3, #ErrorSemaphore]
        TEQ     R3, #0
        BNE     %FT30
        CMP     R4, #0 ; Check if original TranslateError call worked (if not, no error block to copy)
        BEQ     %FT30
        SWI     XMessageTrans_CopyError
        ; If TranslateError worked, assume MessageTrans_CopyError worked too
        ADD     SP, SP, #256
30
      ]
d931 1
a931 2
        ADR     R7, ErrorBlock_BranchThrough0
        B       UNDEF1
d1251 1
a1251 1
        CMP     r0,#16 ;R0 > 15, so illegal value
a1269 1
        B       %FT150
d2031 1
a2031 1
        MOV     R0, #ExtROMFooter_BuildDate
a2164 35
; OS_ReadSysInfo 15 - Enumerate extended ROM footer entries
;
; On entry:
;    r0 = 15 (reason code 15)
;    r1 = location to start (from previous call) or 0 to begin
;
; On exit:
;    r1 = data pointer, or 0 if end
;    r2 = entry ID (corrupt if r1 == 0)
;    r3 = entry length (corrupt if r1 == 0)

150
        Push    "lr"
        BL      ExtendedROMFooter_Find
        CMP     r0, #-1
        BEQ     %FT158
        MOV     lr, r0                  ; Footer end
        CMP     r1, #0
        LDREQ   r1, [lr]
        MOVEQ   r1, r1, LSL #16
        SUBEQ   r1, lr, r1, LSR #16     ; Footer start
        LDRNEB  r3, [r1, #-1]
        ADDNE   r1, r1, r3              ; If not starting enumeration, advance by length of previous entry
        CMP     r1, lr
        BEQ     %FT158
        LDRB    r2, [r1], #1
        LDRB    r3, [r1], #1
        B       %FT159
158
        MOV     r1, #0
159
        MOV     r0, #15
        Pull    "lr"
        ExitSWIHandler

a2182 2
; 2     Debug symbols offset (length = 4). Byte offset from the start of the ROM
;       to the debug symbols.
@


4.15.2.39
log
@Add new OS_PlatformFeatures reason code for reading CPU features (inspired by ARMv6+ CPUID scheme). Add OS_ReadSysInfo 8 flags for indicating the alignment mode the ROM was built with. Fix long-standing bug with OS_PlatformFeatures when an unknown reason code is used.
Detail:
  s/CPUFeatures, hdr/OSMisc, hdr/KernelWS - Code and definitions for reading CPU features and reporting them via OS_PlatformFeatures 34. All the instruction set features which are exposed by the CPUID scheme and which are relevant to RISC OS are exposed, along with a few extra flags which we derive ourselves (e.g. things relating to < ARMv4, and some register usage restrictions in instructions). s/CPUFeatures is designed to be easily copyable into a future version of CallASWI without requiring any changes.
  s/ARMops - Read and cache CPU features during ARMop initialisation
  s/GetAll - GET new file
  s/Kernel - Hook up the CPU features code to OS_PlatformFeatures. Fix a long standing stack imbalance bug (fixed in RISC OS 3.8, but never merged back to our main branch) which meant that calling OS_PlatformFeatures with an invalid reason code would raise an error, even if it was the X form of the SWI that was called. Similar fix also applied to the unused service call code, along with a fix for the user's R1-R9 being corrupt (shuffled up one place) should an error have been generated.
  s/MemInfo - Extra LTORG needed to keep things happy
  s/Middle - Extend OS_ReadSysInfo 8 to include flags for indicating what memory alignment mode (if any) the OS relies upon. Together with OS_PlatformFeatures 34 this could e.g. be used by !CPUSetup to determine which options should be offered to the user.
Admin:
  Tested on Raspberry Pi 1, 2, 3


Version 5.35, 4.79.2.319. Tagged as 'Kernel-5_35-4_79_2_319'
@
text
@d1996 1
a1996 3
;     5     = OS uses rotated loads          } If both clear and flagged as
;     6     = OS uses unaligned loads/stores } defined, OS makes no unaligned accesses
;     7..31 reserved (currently undefined)
a2007 8
    [ :LNOT: NoUnaligned
      [ :LNOT: NoARMv6
        ORR     r1, r1, #1:SHL:6 ; ARMv6+
      ELIF :LNOT: SupportARMv6
        ORR     r1, r1, #1:SHL:5 ; <=ARMv5
      ]
    ]
        ORR     r2, r2, #3:SHL:5
@


4.15.2.13.2.1
log
@Add OS_ReadSysInfo reason codes 11 (read debug info) & 12 (read extended machine ID)
Detail:
  OS_ReadSysInfo 10 is left unimplemented since it's a bit fiddly for us.
  OS_ReadSysInfo 11 is compatible with ROL's implementation, exposing HAL_DebugTX and HAL_DebugRX if the HAL provides them.
  See here for 10,11 docs: http://select.riscos.com/prm/core/osreadsysinfo.html
  OS_ReadSysInfo 12 is a new call to return the 'extended machine ID', to allow the HAL to specify the format & validity of the ID.
  If the HAL responds to the new HAL_ExtMachineID call then it's assumed that no old-style machine ID is present. The Kernel will generate an old-style ID using the contents of the extended ID, and use that with OS_ReadSysInfo 2/5.
  New software should use OS_ReadSysInfo 12 in preference to 2/5.
  s/Middle - Updated OS_ReadSysInfo SWI
  s/PMF/osinit - New old-style machine ID initialisation code
  hdr/HALEntries - Added new HAL_ExtMachineID entry
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.34. Tagged as 'Kernel-5_35-4_79_2_98_2_34'
@
text
@d1273 1
a1273 1
        CMP     r0,#13 ;R0 > 12, so illegal value
a1286 3
        B       ReadSysInfo_InvalidReason ; ROL's "read OS version" call
        B       %FT110
        B       %FT120
a1965 66
; OS_ReadSysInfo 11 - Read debug information
;
; On entry:
;    r0 = 11 (reason code 11)
;
; On exit:
;    r0 = pointer to function for debug character output
;    r1 = pointer to function for debug character input
;     

110
        ; Check if both HAL_DebugTX and HAL_DebugRX are available
        Push    "r8-r9,r14"
        MOV     R8, #1
        MOV     R9, #EntryNo_HAL_DebugTX
        SWI     XOS_Hardware
        MOVVC   R8, #1
        MOVVC   R9, #EntryNo_HAL_DebugRX
        SWIVC   XOS_Hardware
        Pull    "r8-r9,r14"
        BVS     ReadSysInfo_InvalidReason        
        ADR     R0, RSI_DebugTX
        ADR     R1, RSI_DebugRX
        ExitSWIHandler

RSI_DebugTX
        ; In:
        ; R0 = char
        ; Privileged mode
        ; Out:
        ; R0-R3, PSR corrupt
        Push    "r9,r12,r14"
        AddressHAL
        CallHAL HAL_DebugTX
        Pull    "r9,r12,pc"

RSI_DebugRX
        ; In:
        ; Privileged mode
        ; Out:
        ; R0=char read, or -1
        ; R1-R3, PSR corrupt
        Push    "r9,r12,r14"
        AddressHAL
        CallHAL HAL_DebugRX
        Pull    "r9,r12,pc"

; OS_ReadSysInfo 12 - Read extended machine ID
;
; On entry:
;    r0 = 12 (reason code 12)
;    r1 = Pointer to word-aligned buffer, or 0 to read size
;
; On exit:
;    r0 = Size of extended machine ID, or 0 if none/corrupt
;    Buffer in R1 filled, if applicable
;

120
        Push    "r1-r3,r9,r14"
        MOV     R0,#0 ; Set R0 to 0, in case HAL_ExtMachineID isn't implemented
        AddressHAL R0
        CallHAL HAL_ExtMachineID
        Pull    "r1-r3,r9,r14"
        ExitSWIHandler

@


4.15.2.13.2.2
log
@Tweak HAL_ExtMachineID to take the buffer pointer in R0 instead of R1
Detail:
  s/Middle, s/PMF/osinit - Kernel now passes the buffer pointer to the HAL in R0 instead of R1, for ATPCS compliance.
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.35. Tagged as 'Kernel-5_35-4_79_2_98_2_35'
@
text
@d2029 2
a2030 2
        AddressHAL
        MOV     R0, R1 ; HAL takes the buffer pointer in R0        
@


4.15.2.13.2.3
log
@Update the method the Cortex kernel uses to determine the UtilityModule & ROM dates
Detail:
  Three main changes:
  * On odd-numbered (i.e. development) versions of the module, the UtilityModule will now take its date from the VersionNum file instead of using a hard-coded date.
  * All build versions now look for the new "extended ROM footer" (as created by romlinker 0.04+) at the end of the ROM image and use it to determine the ROM build date for return by OS_ReadSysInfo 9,2. Failing to find the build date in the footer will cause OS_ReadSysInfo 9,2 to return 0.
  * On odd-numbered versions, OS_Byte 0 will now use the ROM build date (as found in the extended footer) to generate the error block that's returned to the user. This seems OK as the PRM describes OS_Byte 0 as returning the "creation date of the operation system". Plus it's a convenient way of getting the ROM build date into the Switcher, since the switcher uses OS_Byte 0. If the extended footer can't be found (or if the string hasn't been initialised yet, e.g. before Service_PostInit) the code falls back to a hard-coded string containing the date from the VersionNum file.
  File changes:
  Makefile - Updated to not create the obsolete Time+Date file (previously used for the ROM build date)
  Version - Use date from VersionNum file for development builds
  hdr/Options - New UseNewFX0Error variable/option to make it easy to check which OS_Byte 0 variant should be enabled
  hdr/KernelWS - Added new string buffers & extended ROM footer pointer to workspace
  s/Middle - Updated OS_ReadSysInfo 9 code, and added utility functions for searching the extended ROM footer for certain tags
  s/NewReset - Added a couple of calls to initialise the new string buffers just prior to Service_PostInit. This is required since OS_Byte/OS_ReadSysInfo shouldn't enable interrupts, but date conversion relies on the Territory module, which may enable interrupts.
  s/PMF/osbyte - Updated OS_Byte 0 code
Admin:
  Tested in OMAP ROM, with and without the extended footer present.


Version 5.35, 4.79.2.98.2.41. Tagged as 'Kernel-5_35-4_79_2_98_2_41'
@
text
@d1963 2
a1964 1
        CMP     R1, #2              ; The build date (dynamically generated)
a1965 25
        BNE     %FT95
        LDR     R0, =ROMBuildDate
        LDRB    R1, [R0]
        CMP     R1, #0
        BNE     %FT94
        ; Build date string hasn't been generated yet. Generate it.
        Push    "r0,r2-r3,lr"
        MOV     R0, #0
        BL      ExtendedROMFooter_FindTag
        CMP     R0, #0              ; Found it?
        STREQ   R0, [R13]
        BEQ     %FT93
        ; For compatability, make this string match the same format as the old
        ; string. Conveniently, this matches the format string used by OS_Word
        ; 14
        LDR     R1, [R13]
        MOV     R2, #?ROMBuildDate
        ADRL    R3, TimeFormat
        SWI     XOS_ConvertDateAndTime
        MOVVS   R0, #0
        STRVS   R0, [R13]
93
        Pull    "r0,r2-r3,lr"
94
        MOV     R1, #2
d2035 1
a2035 75
;
; Extended ROM footer functions
;
; These operate on a new tag-based structure located at the end of the ROM
; image. Each entry consists of a one-byte ID, a one-byte length, and then N
; bytes of data. The length byte doesn't count the two initial header bytes.
;
; The end of the list is implicity terminated by a footer word; the footer word
; contains the length of the structure in the low two bytes (minus the length of
; the footer word), and a 16-bit CRC in the top two bytes (again, minus the
; footer word). The footer word will be word-aligned, but everything else is
; assumed to be byte aligned.
;
; Current tags:
;
; 0     ROM build date, stored as 5-byte time (length = 5)
;

ExtendedROMFooter_Find  ROUT
        ; Find the header word for the extended ROM footer. Returns -1 if not found.
        Push    "r1-r4,lr"
        LDR     r4, =ZeroPage
        LDR     r0, [r4, #ExtendedROMFooter]
        CMP     r0, #0
        BNE     %FT10
        ; Examine the end of the ROM image
        ; Footer should be located just before the standard 20 byte footer
        LDR     r2, =ROM+OSROM_ImageSize*1024-24
        LDR     r1, [r2]
        CMP     r1, #-1
        MOVEQ   r0, r1
        BEQ     %FT09
        ; Check CRC
        MOV     r1, r1, LSL #16
        SUB     r1, r2, r1, LSR #16
        MOV     r3, #1
        SWI     XOS_CRC
        MOVVS   r0, #-1
        BVS     %FT09
        LDR     r1, [r2]
        CMP     r0, r1, LSR #16
        MOVNE   r0, #-1
        MOVEQ   r0, r2
09
        STR     r0, [r4, #ExtendedROMFooter]
10
        Pull    "r1-r4,pc"

ExtendedROMFooter_FindTag  ROUT
        ; Find the tag number given in R0.
        ; Returns data pointer in R0 & length in R1 on success.
        ; Returns 0 in R0 (and corrupt R1) for failure.
        Push    "r2-r3,lr"
        MOV     r2, r0
        BL      ExtendedROMFooter_Find
        CMP     r0, #-1
        BEQ     %FT09
        MOV     r3, r0
        LDR     r0, [r0]
        MOV     r0, r0, LSL #16
        SUB     r0, r3, r0, LSR #16
05
        CMP     r0, r3
        BEQ     %FT09
        LDRB    lr, [r0], #1
        LDRB    r1, [r0], #1
        CMP     lr, r2
        BEQ     %FT10
        ADD     r0, r0, r1
        B       %BT05
09
        MOV     r0, #0
10
        Pull    "r2-r3,pc"

d2037 1
@


4.15.2.13.2.4
log
@Add new OS_ReadSysInfo 6 items. Change naming of PublicWS values.
Detail:
  s/Middle - Added some new OS_ReadSysInfo 6 items which are needed by the zero page relocation kernel. Also duplicated some existing entries to avoid conflicts with ROL's allocations.
  hdr/OSRSI6, Makefile - New header listing OS_ReadSysInfo 6 items
  hdr/PublicWS - Duplicated the workspace definitions for &0-&4000, but with a 'Legacy_' prefix to their names. Also added some new entries as needed by the zero page relocation kernel. Once existing modules have been updated to use OS_ReadSysInfo 6 & the Legacy_ definitions, the old defs will be removed.
  hdr/KernelWS - Removed 'Export_' prefix from all the exported workspace values, since the kernel can now use the original names directly
  hdr/Options - Dummy HiProcVecs option so merging things will be a bit cleaner
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.44. Tagged as 'Kernel-5_35-4_79_2_98_2_44'
@
text
@d1831 2
a1832 2
    DCD  ZeroPage+CamEntriesPointer                   ;0
    DCD  ZeroPage+MaxCamEntry                         ;1
d1834 1
a1834 1
    DCD  ZeroPage+PhysRamTable                        ;3
d1836 8
a1843 8
    DCD  ZeroPage+TickNodeChain                       ;5
    DCD  ZeroPage+ROMModuleChain                      ;6
    DCD  ZeroPage+DAList                              ;7
    DCD  ZeroPage+AppSpaceDANode                      ;8
    DCD  ZeroPage+Module_List                         ;9
    DCD  ZeroPage+ModuleSHT_Entries                   ;10
    DCD  ZeroPage+ModuleSWI_HashTab                   ;11
    DCD  ZeroPage+IOSystemType                        ;12
a1848 12
    ; **DANGER** - this block conflicts with ROL's allocations
    ; ROL use:
    ; 18 = kernel messagetrans block
    ; 19 = error semaphore
    ; 20 = OS_PrettyPrint dictionary
    ; 21 = Timer 0 latch value
    ; 22 = FastTickerV counts per second
    ; 23 = Vector claimants table
    ; 24 = Number of vectors supported
    ; 25 = IRQSTK
    ; 26 = JTABLE-SWIRelocation
    ; 27 = Address of branch back to OS after SWIs
d1854 1
a1854 23
    DCD  ZeroPage+IRQsema                             ;23 - the address of the IRQ semaphore
    DCD  0
    DCD  IRQSTK                                       ;25 - Safe replacement for #21 (matches ROL)
    DCD  JTABLE-SWIRelocation                         ;26 - Safe replacement for #18 (matches ROL)
    %    (256-(.-osri6_table))
    ; Use 64+ for a repeat of of the remaining conflicts, and for our new allocs
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;64 - relocated base of IRQ device head nodes
    DCD  DefaultIRQ1V+(DevicesEnd-DefaultIRQ1Vcode)   ;65 - relocated end of IRQ device head nodes
    DCD  SoundWorkSpace                               ;66 - workspace (8K) and buffers (2*4K)
    DCD  ZeroPage+IRQsema                             ;67 - the address of the IRQ semaphore
    ; New allocations
    DCD  ZeroPage+DomainId                            ;68 - current Wimp task handle
    DCD  ZeroPage+OsbyteVars-&A6                      ;69 - OS_Byte vars (previously available via OS_Byte &A6/VarStart)
    DCD  ZeroPage+VduDriverWorkSpace+FgEcfOraEor      ;70
    DCD  ZeroPage+VduDriverWorkSpace+BgEcfOraEor      ;71
    DCD  DebuggerSpace                                ;72
    DCD  DebuggerSpace_Size                           ;73
    DCD  ZeroPage+CannotReset                         ;74
    DCD  ZeroPage+MetroGnome                          ;75 - OS_ReadMonotonicTime
    DCD  ZeroPage+CLibCounter                         ;76
    DCD  ZeroPage+RISCOSLibWord                       ;77
    DCD  ZeroPage+CLibWord                            ;78
    DCD  ZeroPage+FPEAnchor                           ;79
@


4.15.2.13.2.5
log
@Correct new OS_ReadSysInfo 6 item numbers
Detail:
  s/Middle - Correct the actual item numbers to match those defined in the header 9and those used in the HAL branch)
  hdr/OSRSI6 - Corrected ROM version numbere where the new items are available from
Admin:
  Untested!


Version 5.35, 4.79.2.98.2.45. Tagged as 'Kernel-5_35-4_79_2_98_2_45'
@
text
@d1867 3
d1871 5
a1875 7
    ; Use 64+ for a repeat of the danger zone, and our new allocations
    DCD  JTABLE-SWIRelocation                         ;64 - relocated base of OS SWI despatch table
    DCD  DefaultIRQ1V+(Devices-DefaultIRQ1Vcode)      ;65 - relocated base of IRQ device head nodes
    DCD  DefaultIRQ1V+(DevicesEnd-DefaultIRQ1Vcode)   ;66 - relocated end of IRQ device head nodes
    DCD  IRQSTK                                       ;67 - top of the IRQ stack
    DCD  SoundWorkSpace                               ;68 - workspace (8K) and buffers (2*4K)
    DCD  ZeroPage+IRQsema                             ;69 - the address of the IRQ semaphore
d1877 12
a1888 12
    DCD  ZeroPage+DomainId                            ;70 - current Wimp task handle
    DCD  ZeroPage+OsbyteVars-&A6                      ;71 - OS_Byte vars (previously available via OS_Byte &A6/VarStart)
    DCD  ZeroPage+VduDriverWorkSpace+FgEcfOraEor      ;72
    DCD  ZeroPage+VduDriverWorkSpace+BgEcfOraEor      ;73
    DCD  DebuggerSpace                                ;74
    DCD  DebuggerSpace_Size                           ;75
    DCD  ZeroPage+CannotReset                         ;76
    DCD  ZeroPage+MetroGnome                          ;77 - OS_ReadMonotonicTime
    DCD  ZeroPage+CLibCounter                         ;78
    DCD  ZeroPage+RISCOSLibWord                       ;79
    DCD  ZeroPage+CLibWord                            ;80
    DCD  ZeroPage+FPEAnchor                           ;81
@


4.15.2.13.2.6
log
@Add ESC_Status to list of OS_ReadSysInfo 6 items
Detail:
  hdr/OSRSI6, s/Middle - Added ESC_Status to the list of items that OS_ReadSysInfo 6 exports
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.47. Tagged as 'Kernel-5_35-4_79_2_98_2_47'
@
text
@a1887 1
    DCD  ZeroPage+ESC_Status                          ;82
@


4.15.2.13.2.7
log
@Add zero page relocation support
Detail:
  A whole mass of changes to add high processor vectors + zero page relocation support to the Cortex branch of the kernel
  At the moment the code can only cope with two ZeroPage locations, &0 and &FFFF0000. But with a bit more tweaking those restrictions can probably be lifted, allowing ZeroPage to be hidden at almost any address (assuming it's fixed at compile time). If I've done my job right, these restrictions should all be enforced by asserts.
  There's a new option, HiProcVecs, in hdr/Options to control whether high processor vectors are used. When enabling it and building a ROM, remember:
  * FPEmulator needs to be built with the FPEAnchor=High option specified in the components file (not FPEAnchorType=High as my FPEmulator commit comments suggested)
  * ShareFS needs unplugging/removing since it can't cope with it yet
  * Iyonix users will need to use the latest ROOL boot sequence, to ensure the softloaded modules are compatible (OMAP, etc. don't really softload much so they're OK with older sequences)
  * However VProtect also needs patching to fix a nasty bug there - http://www.riscosopen.org/tracker/tickets/294
  The only other notable thing I can think of is that the ProcessTransfer code in s/ARM600 & s/VMSAv6 is disabled if high processor vectors are in use (it's fairly safe to say that code is obsolete in HAL builds anyway?)
  Fun challenge for my successor: Try setting ZeroPage to &FFFF00FF (or similar) so its value can be loaded with MVN instead of LDR. Then use positive/negative address offsets to access the contents.
  File changes:
  - hdr/ARMops - Modified ARMop macro to take the ZeroPage pointer as a parameter instead of 'zero'
  - hdr/Copro15ops - Corrected $quick handling in myISB macro
  - hdr/Options - Added ideal setting for us to use for HiProcVecs
  - s/AMBControl/allocate, s/AMBControl/growp, s/AMBControl/mapslot, s/AMBControl/memmap, s/AMBControl/service, s/AMBControl/shrinkp, s/Arthur2, s/Arthur3, s/ArthurSWIs, s/ChangeDyn, s/ExtraSWIs, s/HAL, s/HeapMan, s/Kernel, s/MemInfo, s/Middle, s/ModHand, s/MoreSWIs, s/MsgCode, s/NewIRQs, s/NewReset, s/Oscli, s/PMF/buffer, s/PMF/IIC, s/PMF/i2cutils, s/PMF/key, s/PMF/mouse, s/PMF/osbyte, s/PMF/oseven, s/PMF/osinit, s/PMF/osword, s/PMF/oswrch, s/SWINaming, s/Super1, s/SysComms, s/TickEvents, s/Utility, s/vdu/vdu23, s/vdu/vdudriver, s/vdu/vdugrafl, s/vdu/vdugrafv, s/vdu/vdupalxx, s/vdu/vdupointer, s/vdu/vduswis, s/vdu/vduwrch - Lots of updates to deal with zero page relocation
  - s/ARM600 - UseProcessTransfer option. Zero page relocation support. Deleted pre-HAL ClearPhysRAM code to tidy the file up a bit.
  - s/ARMops - Zero page relocation support. Set CPUFlag_HiProcVecs when high vectors are in use.
  - s/KbdResPC - Disable compilation of dead code
  - s/VMSAv6 - UseProcessTransfer option. Zero page relocation support.
Admin:
  Tested with OMAP & Iyonix ROM softloads, both with high & low zero page.
  High zero page hasn't had extensive testing, but boot sequence + ROM apps seem to work.


Version 5.35, 4.79.2.98.2.48. Tagged as 'Kernel-5_35-4_79_2_98_2_48'
@
text
@d175 1
a175 1
        LDR     R5, =ZeroPage
d261 1
a261 1
        LDR     R12, =ZeroPage
d295 1
a295 1
        LDR     r10, =ZeroPage
d325 1
a325 1
        LDR     r12, =ZeroPage+BrkAd_ws
d368 1
a368 1
        LDR     r10, =ZeroPage
d456 1
a456 1
NOCALL  LDR     r0, =ZeroPage               ; default callback routine
d471 1
a471 3
        SWI     XOS_EnterOS

        LDR     R0,=ZeroPage+KernelMessagesBlock+4
d499 1
a499 1
        LDR     R1,=ZeroPage+MOSConvertBuffer
d518 2
a519 1
        LDR     R0, =ZeroPage
d543 1
a543 1
        LDR     r13, =ZeroPage
d553 1
a553 1
        LDR     R0,=ZeroPage+KernelMessagesBlock+4
d569 1
a569 1
        LDR     r13, =ZeroPage
d611 1
a611 1
        LDR    R0, =ZeroPage+KernelMessagesBlock+4
d687 1
a687 1
     [ HAL
a689 3
      [ ZeroPage <> 0
        LDR     R2, =ZeroPage
      ]
d692 1
a692 1
     |
d695 1
a695 1
     ]
d733 1
a733 1
        LDR     R0, =ZeroPage
d750 1
a750 1
        LDR     r10, =ZeroPage
d770 1
a770 1
        LDR     R0, =ZeroPage
d779 1
a779 1
        LDR     r4, =ZeroPage
d805 1
a805 2
        LDR     R1, =ZeroPage
      [ ZeroPage = 0
a806 4
      |
        MOV     R2, #0
        STR     R2, [R1, #IRQsema]
      ]
d821 1
a821 1
        LDR     R14, =ZeroPage
d843 1
a843 1
        LDR     R14, =ZeroPage
d866 1
a866 1
        LDR     R14, =ZeroPage
d890 1
a890 1
        LDR     R14, =ZeroPage
d915 1
a915 1
        LDR     R1, =ZeroPage
d927 1
a927 1
        LDR     R13, =ZeroPage
d1112 1
a1112 1
        &  ZeroPage+MemLimit     ;  MemoryLimit
d1116 1
a1116 1
        &  ZeroPage+UndHan       ; UndefinedHandler
d1120 1
a1120 1
        &  ZeroPage+PAbHan       ; PrefetchAbortHandler
d1124 1
a1124 1
        &  ZeroPage+DAbHan       ; DatabortHandler
d1128 1
a1128 1
        &  ZeroPage+AdXHan       ; AddressExceptionHandler
d1136 3
a1138 3
        &  ZeroPage+ErrHan       ; ErrorHandler
        &  ZeroPage+ErrHan_ws
        &  ZeroPage+ErrBuf
d1140 3
a1142 3
        &  ZeroPage+CallAd       ; CallBackHandler
        &  ZeroPage+CallAd_ws
        &  ZeroPage+CallBf
d1144 3
a1146 3
        &  ZeroPage+BrkAd        ; BreakPointHandler
        &  ZeroPage+BrkAd_ws
        &  ZeroPage+BrkBf
d1148 2
a1149 2
        &  ZeroPage+EscHan       ; EscapeHandler
        &  ZeroPage+EscHan_ws
d1152 2
a1153 2
        &  ZeroPage+EvtHan       ; EventHandler
        &  ZeroPage+EvtHan_ws
d1156 2
a1157 2
        &  ZeroPage+SExitA       ; ExitHandler
        &  ZeroPage+SExitA_ws
d1160 2
a1161 2
        &  ZeroPage+HiServ       ; UnusedSWIHandler
        &  ZeroPage+HiServ_ws
d1164 1
a1164 1
        &  ZeroPage+ExceptionDump ; ExceptionDumpArea
d1168 1
a1168 1
        &  ZeroPage+AplWorkSize  ; application space size
d1172 1
a1172 1
        &  ZeroPage+Curr_Active_Object
d1176 2
a1177 2
        &  ZeroPage+UpCallHan
        &  ZeroPage+UpCallHan_ws
d1311 1
a1311 1
        LDR     r10, =ZeroPage
d1328 1
a1328 1
        LDR     r1, =ZeroPage+VduDriverWorkSpace+CurrentMonitorType      ; read current monitortype
d1416 1
a1416 1
        LDR     r12, =ZeroPage
d1534 1
a1534 1
        LDR     r0, =ZeroPage
d1542 1
a1542 1
        LDR     r0, =ZeroPage
d1783 1
a1783 1
        LDR     r0, =ZeroPage
d1903 1
a1903 1
        LDR     r0, =ZeroPage+Abort32_dumparea
@


4.15.2.13.2.8
log
@Fix objasm 4 warnings
Detail:
  s/Arthur3, s/ChangeDyn, s/HAL, s/HeapMan, s/Middle, s/MoreSWIs, s/NewIRQs, s/Utility, s/VMSAv6, s/PMF/key, s/PMF/osbyte, s/PMF/osword, s/vdu/vdudecl, s/vdu/vdudriver, s/vdu/vduplot, s/vdu/vduwrch - Tweaked lots of LDM/STM instructions in order to get rid of the depracation/performance warnings
Admin:
  Tested on rev A2 BB-xM


Version 5.35, 4.79.2.98.2.53. Tagged as 'Kernel-5_35-4_79_2_98_2_53'
@
text
@d311 1
a311 1
        STR     r0, [r10], #4
d334 1
a334 1
        STR     r0, [r10], #4
d339 1
a339 3
        STMIA   r0, {r1-r12}
        STR     sp, [r0, #12*4]
        STR     r14, [r0, #13*4]
d346 1
a346 2
        STMIA   r14, {r0-r12}
        STR     r13, [r14, #13*4]
d684 1
a684 1
        STMIA   R0, {R8-R12}            ; save the banked registers
a686 1
        STR     SP, [R0, #5*4]
a687 2
        STR     R14, [R0, #6*4]
        
d926 1
a926 2
        STMIA   R1, {R0-R12}
        STR     R13, [R1, #13*4]
@


4.14
log
@  Added 32K EEPROM support.
  New routine in i2cutils that allows access to protected sections such as
  MAC address
  OS_ReadSysInfo 4 now checks both copies MACAddress if MACNVRAM2copies is set
Detail:
  32K EEPROM has to be configured with IIC address &A6 (i.e wired up on the pcb)
  ClockNVMemoryFast has been replaced with MaxI2Cspeed so that several different
  rates can be used depending on the devices on the IIC bus.
Admin:
  Need to implement routine that can use one copy of the MAC address to
  replace the other in the event of it being corrupted.


Version 5.33. Tagged as 'Kernel-5_33'
@
text
@d1308 1
d1311 3
@


4.13
log
@Had one of those weekend brainstorms - managed to speed up SWI despatcher
_and_ add Thumb support to it.
Fixed OS_BreakPt - was confused by PC/PSR split.

Version 5.24. Not tagged
@
text
@a1307 1
 [ ClockNVMemoryFast
a1312 1
 ]
d1442 13
a1454 1
        [ STB
d1460 117
a1576 1
	Entry	"r2,r3", 8				; Preserve these
a1577 1
	ADR	r0, NVRAM_TAG_MACAddress		; Read the MAC address
d1583 1
a1583 1
	BNE	%FT10
d1585 1
a1585 1
	ADR	r0, NVRAM_TAG_MACAddressChecksum	; Read the checksum
d1588 1
a1588 1
	SWI	NVRAM_Read
d1591 2
a1592 1
10
a1594 1
	BNE	%FT20					; Return zero on error
d1622 9
a1630 3
	TEQ	r2, r3					; Check against the computed value
	MOVNE	r0, #0					; Zero the MAC address on failure
	MOVNE	r1, #0
d1632 1
a1632 8
20
	EXIT

NVRAM_TAG_MACAddress
	= "MACAddress", 0
NVRAM_TAG_MACAddressChecksum
	= "MACAddressChecksum", 0
        ]
@


4.12
log
@  Bug fixes only.
Detail:
  "Podule" number now displayed again in *ROMModule output - flag
     preservation issue caused it to disappear in 5.23.
  *Eval output no longer misses its trailing space, neither do "Podule" or
    "Extn ROM" in *ROMModules output.
  Heap manager now works again in non-SVC modes.
  Exception dump now contains faked up 26-bit PC+PSR lookalike.
Admin:
  Assembled.
@
text
@d247 3
a249 3
        ADD     sp, sp, #4              ; discard stacked R11
        MOV     r12, #0
        LDR     r12, [r12, #BrkBf]
d251 6
a256 3
        STR     r14, [r12, #16*4]       ; PSR
        TST     r14, #&0F
        Pull    R14
d258 2
a259 1
        FakeLR  r11
d262 1
a262 2
        SUB     r14, R14, #4
        STR     r14, [r12, #15*4]       ; PC of the SWI put in.
d264 2
a265 2
        STMIA   r12!, {r0}
        MOV     r0, r12
d281 2
a282 2

01      AND     r11, r14, #&0F          ; SWI mode?
d286 6
a291 4
        STMIA   r12!, {r0}
        MOV     r0, r12
        LDMFD   sp, {r10-r12}           ; Not banked if IRQ mode
        msr    ,CPSR_c, R14             ; get at registers
d296 1
a296 1

d299 3
a301 1
        STMIA   r14, {r0-r14}
@


4.11
log
@  32-bit Kernel.

Details:
  The Kernel will now compile to produce a pure 32-bit system if No26bitCode is
  set to TRUE.
  If No26bitCode is FALSE, then the Kernel will be a standard 26-bit Kernel,
  although some internal changes have taken place to minimise compile
  switches between the two cases. See Docs.32bit for more technical info.

  The hardest part was the flood-fill...

Other changes:
  Pointer shape changes now take place on the next VSync, rather than actually
  WAITING for the VSync. Turning the Hourglass on shouldn't slow your machine
  down by 5% now :)

  Lots of really crusty pre-IOMD code removed.

Admin:
  Tested in 32 and 26-bit forms in a limited desktop build. Basically, this
  will need to see a lot of use to iron out difficulties. I'd like anyone who
  has a non-frozen project to at least attempt using this Kernel.

Version 5.23. Tagged as 'Kernel-5_23'
@
text
@d842 1
a844 1
 [ No26bitCode
d847 8
@


4.10
log
@  Removed redundant MACFROMNVRAM introduced in Kernel 5.09.

Detail:
  MACFROMNVRAM was intended to force the Kernel to fetch the MAC
  address from NVRAM for Customer F 5. In practice it is not needed
  as its main purpose was to avoid getting the MAC address from
  the RawMachineID but this will not happen in Customer F 5 as
  RawMachineID will not be set.

Admin:
  Not tested.
  MACFROMNVRAM will be removed from HdrSrc.

Version 5.17. Tagged as 'Kernel-5_17'
@
text
@d137 3
d145 1
d156 1
a156 1
        TEQP    PC, #SVC_mode+I_bit ; need IRQs off to get consistent state
d187 1
a187 1
        TEQP    PC, #SVC_mode+I_bit     ; no irqs - want consistent set.
d229 1
a229 1
SINTON  BIC     lr, lr, #I_bit
d232 1
a232 1
SINTOFF ORR     lr, lr, #I_bit
d235 5
a239 1
SENTERSWI ORR   lr, lr, #SVC_mode
d250 8
d260 1
a260 2
        TST     r14, #SVC_mode
        BNE     %FT01
d279 3
a281 3
01      TST     r14, #1                 ; SWI mode?
        TSTNE   r14, #2
        BNE     %FT02                   ; [yes]
d286 1
a286 2
        TEQP    pc, R14                 ; get at registers
        NOP
d288 1
a288 1
        TEQP    pc, #SVC_mode
d313 1
a313 1
        TEQP    pc, #SVC_mode+I_bit
d318 3
a320 3
        Pull    "r11"
        Pull    "r10-r12"
        MOVS    pc, lr                  ; Do NOT exit via normal mechanism
d327 1
a328 1
     TEQP  PC, #SVC_mode+I_bit ; no irqs
a333 1
 [ :LNOT: DriversInKernel
a345 1
 ]
d404 4
d486 1
a486 1
        TEQP    pc, #0
d512 1
a512 1
        TEQP    pc, #0
d591 1
a591 1
02      MOVS   PC, R12
d605 6
d614 1
d622 14
a635 1
        BEQ     UNDEF1
d637 4
a656 1

d658 4
a662 3
UNDEF1  LDR     sp, =SVCSTK             ; Flatten superstack

 [ ExceptionsAreErrors
d674 1
d676 1
d703 1
d705 1
d720 13
d734 1
a738 12
   |
        Push    R14
        BL      DEFHAN
        BL      DEFHN2
        Pull    R0
        TEQP    PC, #IRQ_mode
        NOP
        LDR     SPIRQ, =IRQSTK
        BIC     R0, R0, #ARM_CC_Mask
        SWI     OS_Write0
        B       UNDEF3
    ]
d743 5
d750 1
d754 6
a761 1
 [ ExceptionsAreErrors
a762 4
 |
        =       "Undefined instruction at ", 0
        ALIGN
 ]
d765 5
d772 1
d776 6
a784 1
 [ ExceptionsAreErrors
a785 4
 |
        =       "Abort on instruction fetch at ", 0
        ALIGN
 ]
d788 5
d795 1
d799 6
a806 1
 [ ExceptionsAreErrors
a807 4
 |
        =       "Abort on data transfer at ", 0
        ALIGN
 ]
d811 5
d818 1
d823 6
a830 1
 [ ExceptionsAreErrors
a831 4
 |
        =       "Address exception at ", 0
        ALIGN
 ]
d841 7
a847 1
        STMIA   R1, {R0-R15}
a851 1
 [ ExceptionsAreErrors
a853 11
 |
        LDR     sp, =SVCSTK
        TEQP    PC, #IRQ_mode
        LDR     SPIRQ, =IRQSTK
        TEQP    PC, #0
        BL      DEFHAN
        BL      DEFHN2
        SWI     OS_WriteS
        =      "Entering Supervisor because of branch through 0", 0
        B       UNDEF2
 ]
d870 8
d880 1
d885 4
d890 1
d910 1
a910 1
        TEQP    PC, #SVC_mode+I_bit
d944 3
d948 1
d956 4
d962 1
d1487 1
a1487 1
	EXITS
@


4.9
log
@  Added OS_ReadSysInfo 6, 7 and 8 from Ursula branch.
  Ensured that M_Phoebe builds set UtilityModule version to 4.00
Detail:
  The softload utility relies on the existence of the extra reason codes
    to OS_ReadSysInfo introduced in Ursula.  The main kernel now supports
    these too (they are simply interfaces to read kernel capabilities and
    configuration - eg. addresses and sizes of UND and SVC mode stacks)
  Avoid OS_ReadSysInfo 9 - ROL have used it for reading the ROM personality
    information (and it's not in our kernel)
  Added some of the new macros into Copro15ops required by the ABT dump
    area code (returned by OS_ReadSysInfo 7) and added the code into ARM600
    to store abort information there.
Admin:
  Required by softload utility for Ursula builds.
  Tested on Risc PC.

Version 5.15. Tagged as 'Kernel-5_15'
@
text
@a1291 1
 [ :LNOT: MACFROMNVRAM
a1320 1
 ]
d1323 1
a1323 1
        [ :LNOT: STB :LAND: :LNOT: MACFROMNVRAM
d1338 1
a1338 1
        [ STB :LOR: MACFROMNVRAM
@


4.8
log
@  Kernel reads Ethernet MAC address from NVRAM (and nowhere else) if
  MACFROMNVRAM is set. This is set in HdrSrc for Customer F machines.

Detail:
  If MACFROMNVRAM is TRUE then OS_ReadSysInfo 4 will read the Ethernet MAC
  Address from bytes 0-13 of the NVRAM area, instead of trying to read it
  from anywhere else. (14 bytes are ysed to store 2 copies and 2
  checksums).

  This is intended for use with a 24LC128 device (which has no OTP area
  and no clock).

  Note that these are physical addresses within the device. Logical
  addresses &F0-&FF map to physical addresses &00-&0F.

  A SetMac utility is provided in Customer F 5 !Boot.Utils to enable the MAC
  address to be programmed for prototypes and development machines.

  Since it is dangerous to rely on the NVRAM to hold our MAC address when
  it is not protected in any way, we store two copies of it, each with
  their own checksum. At present only the first copy is used, but the
  plan is to check both copies and both checksums.

Admin:
  This version of the Kernel needs Programmer/HdrSrc v0.68 or later.

  If MACFROMNVRAM is enabled, ensure that the MACADDRESS tag in the
  NVRAM file is set to point at &F0 and that MACADDRESSCHECKSUM
  is set to point at &F6. Both should have options L and P to ensure
  they are protected from NVRAM resets and other writes.

Version 5.09. Tagged as 'Kernel-5_09'
@
text
@d1060 6
d1067 1
a1067 1
        ;       R0 > 5, so illegal value
d1418 135
@


4.7
log
@OS_ReadSysInfo 2 now reports whether the IIC bus is fast (in bit 24 of R2),
and whether I/O clocks should be stopped when idling the processor (bit 25).
OS_Byte 19 is a bit more careful in its use of Portable_Idle - an edge case
where the vsync interrupt was already pending now returns immediately.

Version 5.07. Tagged as 'Kernel-5_07'
@
text
@d1286 1
d1316 1
d1319 1
a1319 1
        [ :LNOT: STB
d1334 1
a1334 1
        [ STB
@


4.6
log
@First attempt at a Kernel that handles ReassignedIOMDInterrupts.
If reassigned, ReadSysInfo3 returns &00x22200 in R0, to indicate that the
serial and parallel ports aren't compatible, and IDE and floppy are
unavailable.

Version 5.01. Tagged as 'Kernel-5_01'
@
text
@a1147 1
 [ MorrisSupport
d1154 6
a1159 4
;               bits 24-31 reserved (set to 0)
 |
;               bits 8-31 reserved (set to 0)
 ]
d1195 10
@


4.5
log
@RCMM changes made the Kernel not report the type of I/O chip fitted correctly.
This has been fixed. In addition, SMC669 and UMC669 chips are reported as
a different chip configuration by OS_ReadSysInfo 3 (values 4 and 5
respectively).
A few assertions added to catch the remaining cases where the RCMM stuff
won't work - those cases will involve a bit more reordering of hardware
initialisation.

Version 5.00. Tagged as 'Kernel-5_00'
@
text
@d1249 5
d1255 1
@


4.4
log
@ROM speed not taken from the Machine header file.  POST can now exist
in a softloaded OS, since it searches for a zero word in the ROM
instead of using one within the POST when trying to communicate with
the POST adapter (the zero word must be in ROM).  Fixed to build on
non-chrontel STB/NC products.  Lots of duplicate code merged in
MemSize.  MemSize copes better with the softload case, and is less
willing to use the region the OS occupies as video memory, or
page tables.  POST is now ON (memory tests disabled).
OS_ReadSysInfo 4 now uses the NVRAM module to access the ethernet
address in NVRAM/CMOS, so that the availability/location of the
MAC address can be changed.  CMOS location 0 is now unprotected on
STB/NC products to try to stop people poking the hardware directly.
Fixed a CMOS resetting problem on STBs where the value expected in a
location was different from the value written on a CMOS reset, so the
CMOS would be reset every time...

Version 4.69. Tagged as 'Kernel-4_69'
@
text
@d1164 8
a1171 5
IOST_IOEB       * 1     ; On IOMD systems this really means IOMD.
IOST_82C710     * 2
IOST_LC         * 4
IOST_82C711     * 8
IOST_37C665     * 16
d1195 1
a1195 1
        ANDS    r1, r0, #IOST_82C710 :OR: IOST_82C711 :OR: IOST_37C665
d1205 2
a1206 2
        ASSERT  IOST_IOEB = 1
        AND     r0, r0, #IOST_IOEB              ; and r0 0 or 1
d1217 8
a1224 8
; out:  r0 = I/O chip base features mask                710     711     665
;               Bits 0..3   Base IDE type               1       1       1
;               Bits 4..7   Base FDC type               1       1       1
;               Bits 8..11  Base parallel type          1       1       1
;               Bits 12..15 Base 1st serial type        1       1       1
;               Bits 16..19 Base 2nd serial type        0       1       1
;               Bits 20..23 Base Config type            1       2       3
;               Bits 24..31 Reserved                    0       0       0
d1226 8
a1233 8
;       r1 = I/O chip extra features mask               710     711     665
;               Bits 0..3   IDE extra features          0       0       0
;               Bits 4..7   FDC extra features          0       0       0
;               Bits 8..11  parallel extra features     0       0       1
;               Bits 12..15 1st serial extra features   0       0       1
;               Bits 16..19 2nd serial extra features   0       0       1
;               Bits 20..23 config extra features       0       0       0
;               Bits 24..31 Reserved                    0       0       0
d1241 11
a1251 9
        TST     r1, #IOST_82C710
        LDRNE   r0, =&00101111
        MOVNE   r1, #0
        TST     r1, #IOST_82C711
        LDRNE   r0, =&00211111
        MOVNE   r1, #0
        TST     r1, #IOST_37C665
        LDRNE   r0, =&00311111
        LDRNE   r1, =&00011100
@


4.3
log
@RISC OS 3.71 kernel changes merged.
Not fully tested on all hardware permutations.
@
text
@d1316 58
a1373 28
        Push    "r2-r5,lr"
        MOV     r1, #EtherAddrCMOS
        MOV     r2, #0                                  ; For lower 4 bytes
        MOV     r3, #0                                  ; For upper 2 bytes
        MOV     r4, #0                                  ; For checksum
        MOV     r5, #6                                  ; Read 6 bytes
01
        MOV     r0, r1
        BL      Read
        ADD     r1, r1, #1                              ; Move on to next byte
        MOV     lr, r2, LSR #24                         ; Get top byte of lower word
        ORR     r3, lr, r3, LSL #8                      ; and put it into bottom byte of upper word
        ORR     r2, r0, r2, LSL #8                      ; Put byte read into bottom byte of upper word
        ADD     r4, r4, r0                              ; Add byte to checksum
        SUBS    r5, r5, #1                              ; Any more bytes?
        BNE     %BT01

        ASSERT  EtherCheckCMOS = EtherAddrCMOS+6
        MOV     r0, r1                                  ; Read checksum byte
        BL      Read
        AND     r4, r4, #&FF                            ; Bottom byte of checksum
        EOR     r0, r0, #&FF                            ; should be inverted in CMOS
        TEQ     r0, r4
        MOVEQ   r0, r2                                  ; Use CMOS values if valid
        MOVEQ   r1, r3
        MOVNE   r0, #0                                  ; otherwise no address.
        MOVNE   r1, #0
        Pull    "r2-r5,pc"
a1374 1

@


4.3.2.1
log
@ 1 Simplify source by removing various long-standing compile flags
   and pre-Medusa h/w support

 2 Fix bug with Pages_Unsafe/Pages_Safe page moving for StrongARM
   (interrupt hole) - also better performance for StrongARM

 3 Improve perfromance of physical memory clear for StrongARM
   (make sure it uses burst write for STM)

 4 Suspend Chocolate task switching for StrongARM if SALDMIBbroken
   is TRUE
@
text
@d320 1
d333 1
d400 1
d457 9
d469 1
d492 15
d511 1
d517 1
d524 5
d538 1
d569 5
d577 1
d581 1
d622 1
d637 1
d643 1
d664 1
d672 3
d681 12
d704 1
d706 4
d720 1
d722 4
d735 1
d737 4
d752 1
d754 4
d772 1
d775 11
d788 1
d790 3
d866 1
d868 1
d1064 1
d1068 1
d1098 1
d1101 4
d1199 1
d1202 5
@


4.3.2.2
log
@1) Fixes and tidy ups:
   - mapping of Cur/Sys/Sound area done more elegantly, and soft CAM info
     is now consistent with it
   - cached screen cleaning on VSync performed *after* VSync events
   - comments at top of ARM600 modernised
   - Pages_Unsafe/Safe code fixed to work properly on StrongARM with
     pages that are involved in interrupts (there is no fix for ARM8,
     since that is unlikely to be needed - an ASSERT checks use of ARM8
   - OS_DynamicArea code souped up, to be much more efficient for large
     numbers of dynamic areas (see comments near top of ChangeDyn)
   - cached screen is now suspended on h/w scroll (avoids possible cache
     incoherency)
2) API changes:
   - new OS_Memory reason code (10) allows Wimp to inform kernel of
     Wimp_ClaimFreeMemory, and can control VRAM rescue (see below)
   - new OS_ReadSysInfo reason code (6) allows reading of kernel values
     (reserved for Acorn use, eg. for SoftLoad, ROMPatch)
   - new OS_DynamicArea reason codes (6 and 7) allow for more efficient
     monitoring of dynamic areas by TaskManager (reserved for Acorn use)
3) Changes for Phoebe:
   - kernel runs a VRAM rescue process, which ensures that any VRAM not
     used for the screen is reclaimed if necessary and sinks to the bottom
     of the Free Pool. This is important for Phoebe, where VRAM is slower
     than SDRAM, but does no harm on other platforms.
   - logical copy of physical RAM is removed from memory map. This frees
     up 256M of address space that will later be used for PCI on Phoebe,
     but should do no harm on other platforms (this space is marked
     private in PRMs, so 3rd parties should not use it).
@
text
@a959 2
        CMP     r0, #6
        BEQ     %FT60                   ; R0 = 6
d961 1
a961 1
        ;       R0 > 6, so illegal value
a1246 43

; OS_ReadSysInfo 6  - read kernel values (Acorn use only; eg. SoftLoad, ROMPatch)
;
; On entry:       r0 =  6 (reason code)
;                 r1 -> input block  - 1 word per entry, giving number of value required, terminated by -1
;                 r2 -> output block - 1 word per entry, will be filled in on output
;
; On exit:        r0,r1,r2 preserved
;                 output block filled in - filled in value set to 0 if unrecognised/no longer meaningful value
;
;  valid value numbers defined - see table below
;

60
        Push    "r0-r3"
        ADR     r3,osri6_table
62
        LDR     r0,[r1],#4
        CMP     r0,#-1
        BEQ     %FT64
        CMP     r0,#8
        MOVHI   r0,#0
        LDRLS   r0,[r3,r0,LSL #2]
        STR     r0,[r2],#4
        B       %BT62
64
        Pull    "r0-r3"
        ExitSWIHandler

osri6_maxvalue * 8
osri6_table
    DCD  CamEntriesPointer        ;0
    DCD  MaxCamEntry              ;1 
    DCD  PageFlags_Unavailable    ;2 
    DCD  PhysRamTable             ;3
    DCD  ARMA_Cleaner_flipflop    ;4
    DCD  TickNodeChain            ;5
    DCD  ROMModuleChain           ;6
    DCD  DAList                   ;7
    DCD  AppSpaceDANode           ;8


 
@


4.3.2.3
log
@Various speed ups
Memory map changes:
remove shadow ROM
move UNDEF stack, SoftCAM and MMU tables above 64M
expand RMA limit to 15M from 11M
expand SysHeap limit to 3M-32k from 2M-8k
expand SVC stack to 32k from 8k
partially protect kernel workspace from user access
protect SVC stack from user access
@
text
@a238 5
  [ SVCAlwaysClearsV
        TST     r10, #V_bit             ; caller's V is in R10 (from SPSR)
        ORRNE   r14, r14, #V_bit        ; now caller's V is preserved
  ]

d1253 2
a1254 4
;                 r1 -> input block, 1 word per entry, giving number of value required, terminated by -1
;           OR:   r1 =  0 if just 1 value is required, and this is to beturned in r2
;                 r2 -> output block, 1 word per entry, will be filled in on output
;           OR:   r2 =  number of single value required, if r1 = 0
d1256 2
a1257 7
; On exit:
;   if r1 entry != 0:
;         r0,r1,r2 preserved
;         output block filled in, filled in value(s) set to 0 if unrecognised/no longer meaningful value(s)
;   if r1 entry = 0:
;         r0,r1 preserved
;         r2 = single value required, or set to 0 if if unrecognised/no longer meaningful value
d1259 1
a1259 1
;  valid value numbers available - see table below
a1264 2
        CMP     r1,#0
        BEQ     %FT64
d1268 2
a1269 2
        BEQ     %FT66
        CMP     r0,#osri6_maxvalue
a1274 5
        CMP     r2,#osri6_maxvalue
        MOVHI   r2,#0
        LDRLS   r2,[r3,r2,LSL #2]
        STR     r2,[sp,#2*4]
66
d1278 1
a1288 11
    DCD  Module_List              ;9
    DCD  ModuleSHT_Entries        ;10
    DCD  ModuleSWI_HashTab        ;11
    DCD  IOSystemType             ;12
    DCD  L1PT                     ;13
    DCD  L2PT                     ;14
    DCD  UNDSTK                   ;15
    DCD  SVCSTK                   ;16
    DCD  SysHeapStart             ;17
osri6_maxvalue * 17

@


4.3.2.4
log
@added support for Sparse dynamic areas
fixed performance disaster caused by naff API for Shrinkable areas
implemented clamps for dynamic areas max size
configured kernel to not own or create RAMFS area (needs new RAMFS)
AMBControl now uses system heap for space, not RMA
AMBControl enables Lazy task swapping if running on rev T or better SA
kernel now assumes there could be code above 64M
SWIS for limited 32 bit user code support implemented
Long command lines implemented (1k instead of 256)
Fast service call distribution implemented (uses Ursula module format)
*fx,*key etc now allow missing space before first parameter
*configure is reinstated (bug fix)
@
text
@d965 2
a966 3
        CMP     r0, #7
        BCC     %FT60                   ; R0 = 6
        BEQ     %FT70                   ; R0 = 7
d968 1
a968 1
        ;       R0 > 7, so illegal value
a1318 17
; OS_ReadSysInfo 7  - read 32-bit Abort information for last unexpected abort
;                     (prefetch or data)
;
; On entry:       r0 =  6 (reason code)
;
; On exit:        r1 = 32-bit PC for last abort
;                 r2 = 32-bit PSR for last abort
;                 r3 = fault address for last abort (same as PC for prefetch abort)
;
70
        Push    "r0"
        LDR     r0, =Abort32_dumparea
        LDR     r1, [r0,#2*4]
        LDR     r2, [r0]
        LDR     r3, [r0,#4]
        Pull    "r0"
        ExitSWIHandler
d1320 1
@


4.3.2.4.2.1
log
@Changed compile switches, to build Ursula kernel for RPC and A7000(+),
switches now set as follows:
  ARM67Support      TRUE  (for 610,710,7500,7500FE)
  ARMSASupport      TRUE  (for StrongARM)
  ARMSASupport_RevS FALSE (for StrongARMs before rev S)
  IOMD1Support      TRUE  (for old machines)
  IOMD2Support      FALSE (They killed Phoebe!)
Version set to 4.00 (RISC OS 4)
This is the same as my last commit to the Ursula branch
@
text
@a967 3
        CMP     r0, #9
        BCC     %FT80                   ; R0 = 8
                                        ; R0 = 9 not allocated yet (BEQ %FT90)
d969 1
a969 1
        ;       R0 > 8, so illegal value
d1049 1
d1057 3
d1070 1
d1073 1
d1086 1
d1092 1
d1096 2
d1099 4
a1102 1

d1179 7
d1190 1
d1194 46
a1239 1

a1336 53

; OS_ReadSysInfo 8 - Returns summary information on host platform.
;
; On entry:
;    r0 = 8 (reason code 8)
;
; On exit:
;    r0 = platform class
;         currently defined classes are:
;            0 = unspecified platform (r1,r2 will be 0)
;            1 = Medusa   (currently returned for Risc PC only)
;            2 = Morris   (currently returned for A7000 only) 
;            3 = Morris+  (currently returned for A7000+ only)
;            4 = Phoebe   (currently returned for Risc PC 2 only)
;            all other values currently reserved
;    r1 = 32 additional platform specifier flags (if defined)
;         bits 0..31 = value of flags 0..31 if defined, 0 if undefined
;    r2 = defined status of the 32 flags in r1
;         bits 0..31 = status of flags 0..31
;                      0 = flag is undefined in this OS version
;                      1 = flag is defined in this OS version
;
; The current flag definitions for r1 (1=supported, 0=unsupported) are :
;
;     0     = Podule expansion card(s)
;     1     = PCI expansion card(s)
;     2     = additional processor(s)
;     3     = auto power off 
;     4..31 reserved (currently undefined)
;
80
        Push    "r3-r5"
        ADR     r3, %86
        MOV     r4, #IOMD_Base
        LDRB    r4, [r4, #IOMD_ID0]
82
        LDR     r5, [r3], #4
        TEQ     r5, #&80000000     ;terminator
        TEQNE   r5, r4
        LDMEQIA r3, {r0-r2}
        BEQ     %FT84
        ADD     r3, r3, #3*4
        B       %BT82
84
        Pull    "r3-r5"
        ExitSWIHandler
86
        DCD     IOMD_Original :AND: &FF,   1, &00000001, &0000000F
        DCD     IOMD_7500     :AND: &FF,   2, &00000001, &0000000F
        DCD     IOMD_7500FE   :AND: &FF,   3, &00000001, &0000000F
        DCD     IOMD_IOMD2    :AND: &FF,   4, &0000000F, &0000000F
        DCD     &80000000,                 0,         0,         0  ;terminator

@


4.3.2.5
log
@Phoebe aware version of kernel
Source currently builds for Phoebe only. Flipping source switches will
build for Risc PC and/or A7000(+) as well (or instead). Not tested
much on older platforms.
Known issues remaining:
 - on Phoebe, kernel does not always set up the video (new VCO)
   properly. It appears that anything via the display manager is ok,
   old modes are ok before a monitor definition is seen, but mode
   changes via applications in the desktop always/often (?) aren't.
   Most likely area for investigation is whether kernel catches all
   mode change routes for ensuring it programs the new VCO.
 - on Phoebe, kernel does not yet have the hooks to support multiple
   CPU(s) (to park the slaves and allow them to be used later). I
   have a technical note on this, which should be archived as part of
   the Ursula burial work.
 - on older platforms, the areas that need checking most are CMOS
   power on reset (when in ROM) and mode changes by all routes (since
   these areas are bent by Phoebe support)
Note that kernel currently builds for rev S or better StrongARM. The
switch ARMSASupport_RevS should be set false if building for Risc PC.
@
text
@a967 3
        CMP     r0, #9
        BCC     %FT80                   ; R0 = 8
                                        ; R0 = 9 not allocated yet (BEQ %FT90)
d969 1
a969 1
        ;       R0 > 8, so illegal value
d1049 1
d1057 3
d1070 1
d1073 1
d1086 1
d1092 1
d1096 2
d1099 4
a1102 1

d1179 7
d1190 1
d1194 46
a1239 1

a1336 53

; OS_ReadSysInfo 8 - Returns summary information on host platform.
;
; On entry:
;    r0 = 8 (reason code 8)
;
; On exit:
;    r0 = platform class
;         currently defined classes are:
;            0 = unspecified platform (r1,r2 will be 0)
;            1 = Medusa   (currently returned for Risc PC only)
;            2 = Morris   (currently returned for A7000 only) 
;            3 = Morris+  (currently returned for A7000+ only)
;            4 = Phoebe   (currently returned for Risc PC 2 only)
;            all other values currently reserved
;    r1 = 32 additional platform specifier flags (if defined)
;         bits 0..31 = value of flags 0..31 if defined, 0 if undefined
;    r2 = defined status of the 32 flags in r1
;         bits 0..31 = status of flags 0..31
;                      0 = flag is undefined in this OS version
;                      1 = flag is defined in this OS version
;
; The current flag definitions for r1 (1=supported, 0=unsupported) are :
;
;     0     = Podule expansion card(s)
;     1     = PCI expansion card(s)
;     2     = additional processor(s)
;     3     = auto power off 
;     4..31 reserved (currently undefined)
;
80
        Push    "r3-r5"
        ADR     r3, %86
        MOV     r4, #IOMD_Base
        LDRB    r4, [r4, #IOMD_ID0]
82
        LDR     r5, [r3], #4
        TEQ     r5, #&80000000     ;terminator
        TEQNE   r5, r4
        LDMEQIA r3, {r0-r2}
        BEQ     %FT84
        ADD     r3, r3, #3*4
        B       %BT82
84
        Pull    "r3-r5"
        ExitSWIHandler
86
        DCD     IOMD_Original :AND: &FF,   1, &00000001, &0000000F
        DCD     IOMD_7500     :AND: &FF,   2, &00000001, &0000000F
        DCD     IOMD_7500FE   :AND: &FF,   3, &00000001, &0000000F
        DCD     IOMD_IOMD2    :AND: &FF,   4, &0000000F, &0000000F
        DCD     &80000000,                 0,         0,         0  ;terminator

@


4.2
log
@Kernel merged
@
text
@d249 6
a254 4
    [ SAUBxferbroken
        NOP
        NOP
    ]
d257 1
a257 3
    [ SAUBxferbroken
        NOP
    ]
a391 4
  [ SAUBxferbroken
        NOP
        NOP
  ]
a393 3
  [ SAUBxferbroken
        NOP
  ]
d592 5
d598 1
@


4.1
log
@Initial revision
@
text
@d249 4
d254 4
d392 4
d398 3
d421 2
a422 2
        BVS     %FT99 
        BNE     %BT01 
d435 1
a435 1
        LDR     R0,[R3]       
d446 1
a446 1
        SUB     R0, R0, #1 
d456 1
a456 1
        STRB    R0, [R0, #ErrorSemaphore]                 ; Enable error translation, in case we got here in the 
d475 2
a476 2
DEFBRK  
      [ International 
d530 1
a530 1
        BVS    %FT02  
d568 1
a568 1
12                       
d663 2
a664 2
        SWI     XOS_ConvertHex8  
       
d898 1
a898 1
    
d1082 1
a1082 1
        AND     r0, r2, #&7F            ; top bit is reserved 
d1285 7
d1296 1
d1300 47
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a1269 5
        TST     r0, #1:SHL:23                           ; Check not overflowed into secondary range
        BNE     ExitNoEthernetAddress
        MOV     r1, r0, LSR #24                         ; Check not overflowed out of Acorn's range
        TEQ     r1, #&A4
        BNE     ExitNoEthernetAddress
d1274 2
a1275 7
        Push    "r2,lr"
        MOV     r1, #Service_MachineAddress             ; See if anyone else can provide it
        BL      Issue_Service
        TEQ     r1, #0
        MOVEQ   r1, r2
        BLNE    GetMachineAddressCMOS
        Pull    "r2,lr"
a1276 36


GetMachineAddressCMOS
; Out:  r0 = lower 4 bytes (or 0)
;       r1 = upper 2 bytes (or 0)
;       EQ => valid, NE => invalid
;
        Push    "r2-r5,lr"
        MOV     r1, #EtherAddrCMOS
        MOV     r2, #0                                  ; For lower 4 bytes
        MOV     r3, #0                                  ; For upper 2 bytes
        MOV     r4, #0                                  ; For checksum
        MOV     r5, #6                                  ; Read 6 bytes
01
        MOV     r0, r1
        BL      Read
        ADD     r1, r1, #1                              ; Move on to next byte
        MOV     lr, r2, LSR #24                         ; Get top byte of lower word
        ORR     r3, lr, r3, LSL #8                      ; and put it into bottom byte of upper word
        ORR     r2, r0, r2, LSL #8                      ; Put byte read into bottom byte of upper word
        ADD     r4, r4, r0                              ; Add byte to checksum
        SUBS    r5, r5, #1                              ; Any more bytes?
        BNE     %BT01

        ASSERT  EtherCheckCMOS = EtherAddrCMOS+6
        MOV     r0, r1                                  ; Read checksum byte
        BL      Read
        AND     r4, r4, #&FF                            ; Bottom byte of checksum
        EOR     r0, r0, #&FF                            ; should be inverted in CMOS
        TEQ     r0, r4
        MOVEQ   r0, r2                                  ; Use CMOS values if valid
        MOVEQ   r1, r3
        MOVNE   r0, #0                                  ; otherwise no address.
        MOVNE   r1, #0
        Pull    "r2-r5,pc"

@


4.1.5.1
log
@Import from SrcFiler
@
text
@a1269 5
        TST     r0, #1:SHL:23                           ; Check not overflowed into secondary range
        BNE     ExitNoEthernetAddress
        MOV     r1, r0, LSR #24                         ; Check not overflowed out of Acorn's range
        TEQ     r1, #&A4
        BNE     ExitNoEthernetAddress
d1274 2
a1275 7
        Push    "r2,lr"
        MOV     r1, #Service_MachineAddress             ; See if anyone else can provide it
        BL      Issue_Service
        TEQ     r1, #0
        MOVEQ   r1, r2
        BLNE    GetMachineAddressCMOS
        Pull    "r2,lr"
a1276 36


GetMachineAddressCMOS
; Out:  r0 = lower 4 bytes (or 0)
;       r1 = upper 2 bytes (or 0)
;       EQ => valid, NE => invalid
;
        Push    "r2-r5,lr"
        MOV     r1, #EtherAddrCMOS
        MOV     r2, #0                                  ; For lower 4 bytes
        MOV     r3, #0                                  ; For upper 2 bytes
        MOV     r4, #0                                  ; For checksum
        MOV     r5, #6                                  ; Read 6 bytes
01
        MOV     r0, r1
        BL      Read
        ADD     r1, r1, #1                              ; Move on to next byte
        MOV     lr, r2, LSR #24                         ; Get top byte of lower word
        ORR     r3, lr, r3, LSL #8                      ; and put it into bottom byte of upper word
        ORR     r2, r0, r2, LSL #8                      ; Put byte read into bottom byte of upper word
        ADD     r4, r4, r0                              ; Add byte to checksum
        SUBS    r5, r5, #1                              ; Any more bytes?
        BNE     %BT01

        ASSERT  EtherCheckCMOS = EtherAddrCMOS+6
        MOV     r0, r1                                  ; Read checksum byte
        BL      Read
        AND     r4, r4, #&FF                            ; Bottom byte of checksum
        EOR     r0, r0, #&FF                            ; should be inverted in CMOS
        TEQ     r0, r4
        MOVEQ   r0, r2                                  ; Use CMOS values if valid
        MOVEQ   r1, r3
        MOVNE   r0, #0                                  ; otherwise no address.
        MOVNE   r1, #0
        Pull    "r2-r5,pc"

@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a248 5

    [ SAUBxferbroken
        NOP
        NOP
    ]
a249 4
        NOP
    [ SAUBxferbroken
        NOP
    ]
a383 4
  [ SAUBxferbroken
        NOP
        NOP
  ]
a385 3
  [ SAUBxferbroken
        NOP
  ]
a584 3
  [ SAUBxferbroken
        NOP
  ]
@


4.1.3.2
log
@RISC OS 3.71 version taken
@
text
@d250 4
a253 5
  [ SASTMhatbroken
        STMIA   r0!,{r1-r12}
        STMIA   r0, {r13_usr,r14_usr}^ ; user mode case done.
        SUB     r0, r0, #12*4
  |
d256 3
a258 1
  ]
d393 4
d399 3
d422 2
a423 2
        BVS     %FT99
        BNE     %BT01
d436 1
a436 1
        LDR     R0,[R3]
d447 1
a447 1
        SUB     R0, R0, #1
d457 1
a457 1
        STRB    R0, [R0, #ErrorSemaphore]                 ; Enable error translation, in case we got here in the
d476 2
a477 2
DEFBRK
      [ International
d531 1
a531 1
        BVS    %FT02
d569 1
a569 1
12
a599 5
  [ SASTMhatbroken
        STMEQIA R0!,{R8-R12}
        STMEQIA R0, {R13,R14}^        ; user mode case done.
        SUBEQ   R0, R0, #5*4
  |
d601 2
d667 2
a668 2
        SWI     XOS_ConvertHex8

d902 1
a902 1

d1086 1
a1086 1
        AND     r0, r2, #&7F            ; top bit is reserved
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d250 4
a253 5
  [ SASTMhatbroken
        STMIA   r0!,{r1-r12}
        STMIA   r0, {r13_usr,r14_usr}^ ; user mode case done.
        SUB     r0, r0, #12*4
  |
d256 3
a258 1
  ]
d393 4
d399 3
d422 2
a423 2
        BVS     %FT99
        BNE     %BT01
d436 1
a436 1
        LDR     R0,[R3]
d447 1
a447 1
        SUB     R0, R0, #1
d457 1
a457 1
        STRB    R0, [R0, #ErrorSemaphore]                 ; Enable error translation, in case we got here in the
d476 2
a477 2
DEFBRK
      [ International
d531 1
a531 1
        BVS    %FT02
d569 1
a569 1
12
a599 5
  [ SASTMhatbroken
        STMEQIA R0!,{R8-R12}
        STMEQIA R0, {R13,R14}^        ; user mode case done.
        SUBEQ   R0, R0, #5*4
  |
d601 2
d667 2
a668 2
        SWI     XOS_ConvertHex8

d902 1
a902 1

d1086 1
a1086 1
        AND     r0, r2, #&7F            ; top bit is reserved
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

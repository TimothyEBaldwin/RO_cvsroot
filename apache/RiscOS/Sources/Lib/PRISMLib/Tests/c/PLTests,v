head	1.6;
access;
symbols
	PRISMLib-0_24:1.6
	PRISMLib-0_23:1.6
	PRISMLib-0_22:1.6
	PRISMLib-0_21:1.6
	PRISMLib-0_20:1.6
	PRISMLib-0_19:1.6
	PRISMLib-0_18:1.6
	PRISMLib-0_16:1.6
	PRISMLib-0_15:1.5
	PRISMLib-0_14:1.5
	PRISMLib-0_13:1.4
	PRISMLib-0_12:1.3
	PRISMLib-0_11:1.2
	PRISMLib-0_10:1.2
	PRISMLib-0_09:1.1;
locks; strict;
comment	@# @;


1.6
date	2005.06.16.09.46.04;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.11.12.07.03;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.10.10.56.16;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.09.13.06.31;	author ahodgkin;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.09.08.38.36;	author ahodgkin;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.06.15.44.53;	author ahodgkin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@  More re-entrancy, new job queue functions.
Detail:
  Errors.c is now fully re-entrant. New JobQueue.[c|h] functions, fully
  tested in the test harness, provide a fixed length queue of a fixed
  number of words per queue entry (specified at creation time). Done here
  rather than through a SWI API in e.g. PRISM as the addition function is
  inherently variable argument based, which does not translate well to
  SWIs (the alternative is to pass a pointer to a constructed queue entry
  which has to be copied in place - fiddly and less efficient). New
  function in Mechanism.h to send a PRISM service call, but this service
  call is looking like it'll be removed due to wider architecture
  revisions anyway - recommendation is to not call this new function as
  it will probably be removed soon.
Admin:
  Test harness updated to cover job queue functions.

Version 0.16. Tagged as 'PRISMLib-0_16'
@
text
@/* Copyright 2005 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************/
/* File:    PLTests.c                                         */
/*          (C) 2005 Tematic Ltd.                             */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Run some simple PRISMLib tests.                   */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 06-May-2005 (ADH): Created.                       */
/**************************************************************/

/* External inclusions */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>

#include <PRISMLib/PRISMLib.h>

/* Useful macros */

#define CHKERR(a) do                                                                    \
                  {                                                                     \
                    _kernel_oserror * e = (a);                                          \
                                                                                        \
                    if (e != NULL)                                                      \
                    {                                                                   \
                      fprintf(stderr, "\nError &%08X:\n'%s'\n", e->errnum, e->errmess); \
                      return EXIT_FAILURE;                                              \
                    }                                                                   \
                  }                                                                     \
                  while (0)

#define TSTERR(a) do                                                        \
                  {                                                         \
                    _kernel_oserror * e = (a);                              \
                                                                            \
                    if (e != NULL)                                          \
                    {                                                       \
                      printf("  OK: &%08X '%s'\n", e->errnum, e->errmess);  \
                    }                                                       \
                    else                                                    \
                    {                                                       \
                      CHKERR(prismlib_make_error((0x40), 1, "\"" #a "\"")); \
                    }                                                       \
                  }                                                         \
                  while (0)

/* Variables */

static bool            messages_opened     = false;

static uint32_t        local_realloc_count = 0;
static uint32_t        local_free_count    = 0;

static prismlib_lock_t lock1               = 0;
static prismlib_lock_t lock2               = 0;
static prismlib_lock_t lock3               = 0;

/* Local functions */

static void   shutdown_tests (void);
static void * local_realloc  (void * ptr, size_t size);
static void   local_free     (void * ptr);
static int    sort_ascending (const void * p1, const void * p2);

/**************************************************************/
/* main()                                                     */
/*                                                            */
/* Run the tests, returning EXIT_SUCCESS or EXIT_FAILURE as   */
/* appropriate.                                               */
/**************************************************************/

int main(void)
{
  /* The following things are not tested explicitly, but implicitly
   * as the test harness itself relies on them:
   *
   *   Errors
   *   Messages
   *
   * The following things are not tested as they are imported from
   * other locations and were tested there. It is assumed, due to
   * time pressures, that the import process introduced no errors.
   *
   *   RLists
   *   Timers
   *
   * The following things are not tested here as they have already
   * been in use in real code for some time and tested that way.
   *
   *   Errors
   *   Messages
   *   Mechanism
   *
   * The following things are untested due to time pressures:
   *
   *   TLV
   */

  printf("\nPRISMLib tests\n"
           "==============\n\n");

  /* Ensure we can tidy up properly */

  atexit(shutdown_tests);

  /* Get the Messages system up */

  CHKERR(prismlib_open_messages("Messages"));
  messages_opened = true;

  /* Test the Clients system */

  {
    prismlib_client_t client1, client2, client3;

    printf("Clients: Correct usage\n");

    CHKERR(prismlib_clients_register(1, &client1));
    CHKERR(prismlib_clients_register(2, &client2));
    CHKERR(prismlib_clients_register(3, &client3));

    CHKERR(prismlib_clients_deregister(1, &client1));
    CHKERR(prismlib_clients_deregister(2, &client2));
    CHKERR(prismlib_clients_deregister(3, &client3));

    printf("Clients: PASS\n");

    /* Try again, and this time do things that should raise errors */

    printf("Clients: Incorrect usage (a list of 'OK' errors should follow)\n");

    CHKERR(prismlib_clients_register(1, &client1));
    CHKERR(prismlib_clients_register(2, &client2));
    CHKERR(prismlib_clients_register(3, &client3));

    TSTERR(prismlib_clients_deregister(4, &client1));
    TSTERR(prismlib_clients_deregister(5, &client2));
    TSTERR(prismlib_clients_deregister(6, &client3));
    TSTERR(prismlib_clients_deregister(1, NULL));

    printf("Clients: PASS\n");
    printf("Clients: PASS ALL\n\n");
  }

  /* Test the Handles system */

  {
    prismlib_client_t client;
    uint32_t          value1 = (uint32_t) main;
    uint32_t          value2 = (uint32_t) shutdown_tests;
    uint32_t          value3 = 1;
    uint32_t          read1;
    uint32_t          read2;
    uint32_t          read3;
    uint16_t          handle1;
    uint16_t          handle2;
    uint16_t          handle3;

    /* Try just creating and destroying handles */

    printf("Handles: Correct usage (1)\n");

    CHKERR(prismlib_clients_register(1, &client));

    CHKERR(prismlib_handles_create(client, value1, &handle1));
    CHKERR(prismlib_handles_create(client, value2, &handle2));
    CHKERR(prismlib_handles_create(client, value3, &handle3));

    CHKERR(prismlib_handles_destroy(client, handle1));
    CHKERR(prismlib_handles_destroy(client, handle2));
    CHKERR(prismlib_handles_destroy(client, handle3));

    CHKERR(prismlib_handles_create(client, value1, &handle1));
    CHKERR(prismlib_handles_create(client, value2, &handle2));
    CHKERR(prismlib_handles_create(client, value3, &handle3));

    CHKERR(prismlib_handles_destroy(client, handle3));
    CHKERR(prismlib_handles_destroy(client, handle2));
    CHKERR(prismlib_handles_destroy(client, handle1));

    printf("Handles: PASS\n");

    /* Recreate the handles, and try reading the values back */

    printf("Handles: Correct usage (2)\n");

    CHKERR(prismlib_handles_create(client, value1, &handle1));
    CHKERR(prismlib_handles_create(client, value2, &handle2));
    CHKERR(prismlib_handles_create(client, value3, &handle3));

    CHKERR(prismlib_handles_read(client, handle1, &read1));
    CHKERR(prismlib_handles_read(client, handle2, &read2));
    CHKERR(prismlib_handles_read(client, handle3, &read3));

    if (
         read1 != value1 ||
         read2 != value2 ||
         read3 != value3
       )
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_handles_read()"));
    }

    CHKERR(prismlib_handles_read(client, handle1, NULL));
    CHKERR(prismlib_handles_read(client, handle2, NULL));
    CHKERR(prismlib_handles_read(client, handle3, NULL));

    printf("Handles: PASS\n");

    /* Try incorrect usage this time */

    printf("Handles: Incorrect usage (a list of 'OK' errors should follow)\n");

    CHKERR(prismlib_handles_create(client, value2, &handle2));

    TSTERR(prismlib_handles_create(NULL,   value1, &handle1));
    TSTERR(prismlib_handles_create(client, 0,      &handle1));
    TSTERR(prismlib_handles_create(client, 0,      NULL));

    TSTERR(prismlib_handles_read(NULL,   handle2,     &read2));
    TSTERR(prismlib_handles_read(client, 0,           &read2));
    TSTERR(prismlib_handles_read(client, handle2 + 1, &read2));

    TSTERR(prismlib_handles_destroy(NULL,   handle2));
    TSTERR(prismlib_handles_destroy(client, 0));
    TSTERR(prismlib_handles_destroy(client, handle2 + 1));

    CHKERR(prismlib_handles_destroy(client, handle2));

    printf("Handles: PASS\n");
    printf("Handles: PASS ALL\n\n");
  }

  /* Test interaction of the clients and handles systems */

  {
    prismlib_client_t client;
    uint32_t          value1 = (uint32_t) main;
    uint32_t          value2 = (uint32_t) shutdown_tests;
    uint32_t          value3 = 1;
    uint16_t          handle1;
    uint16_t          handle2;
    uint16_t          handle3;

    /* Try just creating and destroying handles */

    printf("Handles and clients: Correct usage\n");

    CHKERR(prismlib_clients_register(1, &client));

    CHKERR(prismlib_handles_create(client, value1, &handle1));
    CHKERR(prismlib_handles_create(client, value2, &handle2));
    CHKERR(prismlib_handles_create(client, value3, &handle3));

    /* Shut down the client, so that it has to destroy the handles
     * internally (test for a bug that existed in PRISMLib 0.11;
     * would get stuck in an infinite loop as the client handle
     * count was not decremented when handles got deleted).
     */

    CHKERR(prismlib_clients_deregister(1, &client));

    printf("Handles and clients: PASS\n");
    printf("Handles and clients: PASS ALL\n\n");
  }

  /* Test the Locks system */

  {
    printf("Locks: Correct usage\n");

    if (
         prismlib_locks_lock(&lock1) == false ||
         prismlib_locks_lock(&lock2) == false ||
         prismlib_locks_lock(&lock3) == false
       )
    {
      CHKERR(prismlib_make_error(0x40,
                                 1,
                                 "prismlib_locks_lock()"));
    }

    if (
         prismlib_locks_unlock(&lock1) == false ||
         prismlib_locks_unlock(&lock2) == false ||
         prismlib_locks_unlock(&lock3) == false
       )
    {
      CHKERR(prismlib_make_error(0x40,
                                 1,
                                 "prismlib_locks_unlock()"));
    }

    printf("Locks: PASS\n");

    /* Now incorrect usage - locking twice, NULL pointers etc.;
     * since the locks system expects to be called from SVC mode,
     * interrupt on/off should fail but the rest of the lock
     * algorithms otherwise work (a safe result, given we don't
     * really want to be turning interrupts off in a fragile
     * transient task like this...!).
     */

    printf("Locks: Incorrect usage\n");

    (void) prismlib_locks_lock(&lock1);
    (void) prismlib_locks_lock(&lock2);
    (void) prismlib_locks_lock(&lock3);

    if (
         prismlib_locks_lock(&lock1) == true ||
         prismlib_locks_lock(&lock2) == true ||
         prismlib_locks_lock(&lock3) == true ||
         prismlib_locks_lock(NULL)   == true
       )
    {
      CHKERR(prismlib_make_error(0x40,
                                 1,
                                 "prismlib_locks_lock()"));
    }

    (void) prismlib_locks_unlock(&lock1);
    (void) prismlib_locks_unlock(&lock2);
    (void) prismlib_locks_unlock(&lock3);

    if (
         prismlib_locks_unlock(&lock1) == true ||
         prismlib_locks_unlock(&lock2) == true ||
         prismlib_locks_unlock(&lock3) == true ||
         prismlib_locks_unlock(NULL)   == true
       )
    {
      CHKERR(prismlib_make_error(0x40,
                                 1,
                                 "prismlib_locks_unlock()"));
    }

    printf("Locks: PASS\n");
    printf("Locks: PASS ALL\n\n");
  }

  /* Test the Arrays system */

  {
    prismlib_nrarray_t * array1;
    prismlib_nrarray_t * array2;
    prismlib_nrarray_t * array3;
    void               * ptr1;
    void               * ptr2;
    void               * ptr3;
    int                  index, key, i;

    printf("Arrays: Correct usage\n");

    /* Allocate and destroy arrays with no initial entries */

    array1 = prismlib_nrarrays_create(0, sizeof(uint32_t), NULL, NULL); /* Should give 'realloc' and 'free' */
    array2 = prismlib_nrarrays_create(0, sizeof(uint32_t), NULL, NULL); /* Should give 'realloc' and 'free' */
    array3 = prismlib_nrarrays_create(0, sizeof(uint32_t), NULL, NULL); /* Should give 'realloc' and 'free' */

    prismlib_nrarrays_destroy(&array1);
    prismlib_nrarrays_destroy(&array2);
    prismlib_nrarrays_destroy(&array3);

    /* Allocate three arrays and change their sizes a bit */

    array1 = prismlib_nrarrays_create(4, sizeof(uint32_t), NULL,          NULL); /* Should give 'realloc' and 'free' */
    array2 = prismlib_nrarrays_create(4, sizeof(uint32_t), realloc,       free); /* Tests type compatibility         */
    array3 = prismlib_nrarrays_create(4, sizeof(uint32_t), local_realloc, local_free);

    if (array1 == NULL || array2 == NULL || array3 == NULL)
    {
      CHKERR(prismlib_make_error(0x100, 0));
    }

    CHKERR(prismlib_nrarrays_extend(array1, 4));     /* To give 8 entries  */
    CHKERR(prismlib_nrarrays_extend(array2, -4));    /* To leave 0 entries */
    CHKERR(prismlib_nrarrays_extend(array3, 2));     /* To give 6 entries  */

    CHKERR(prismlib_nrarrays_insert(array1, 2, 2));  /* To give 10 entries */
    CHKERR(prismlib_nrarrays_insert(array2, 2, 0));  /* To give 2 entries  */
    CHKERR(prismlib_nrarrays_insert(array3, 2, 6));  /* To give 8 entries  */

    CHKERR(prismlib_nrarrays_delete(array1, 4, 6));  /* To leave 6 entries */
    CHKERR(prismlib_nrarrays_delete(array2, 1, 0));  /* To leave 1 entry   */
    CHKERR(prismlib_nrarrays_delete(array3, 6, 1));  /* To leave 2 entries */

    if (
         prismlib_nrarrays_size(array1) != 6 ||
         prismlib_nrarrays_size(array2) != 1 ||
         prismlib_nrarrays_size(array3) != 2
       )
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrarrays_create(), prismlib_nrarrays_extend(), prismlib_nrarrays_insert() or prismlib_nrarrays_delete()"));
    }

    /* Try to get a pointer to the last element */

    ptr1 = prismlib_nrarrays_read(array1, 5);
    ptr2 = prismlib_nrarrays_read(array1, 0);
    ptr3 = prismlib_nrarrays_read(array1, 1);

    if (ptr1 == NULL || ptr2 == NULL || ptr3 == NULL)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrarrays_read()"));
    }

    *((uint32_t *) ptr1) = 1;
    *((uint32_t *) ptr2) = 2;
    *((uint32_t *) ptr3) = 3;

    /* Put values 6 to 1 into indices 0 to 5 of array 1 */

    for (i = 0; i < prismlib_nrarrays_size(array1); i++)
    {
      ptr1 = prismlib_nrarrays_read(array1, i);
      *((uint32_t *) ptr1) = prismlib_nrarrays_size(array1) - i;
    }

    /* Sort it, using a function that should produce an ascending result */

    prismlib_nrarrays_sort(array1, sort_ascending);

    /* Check the contents */

    for (i = 0; i < prismlib_nrarrays_size(array1); i++)
    {
      ptr1 = prismlib_nrarrays_read(array1, i);

      if (*((uint32_t *) ptr1) != i + 1)
      {
        CHKERR(prismlib_make_error(0x41,
                                   1,
                                   "prismlib_nrarrays_sort()"));
      }
    }

    /* Search the array */

    key   = 3;
    ptr1  = prismlib_nrarrays_read   (array1, 2); /* Should point to value of '3' */
    index = prismlib_nrarrays_search (array1, &key, sort_ascending);

    if (index != 2 || prismlib_nrarrays_read(array1, index) != ptr1)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrarrays_search()"));
    }

    /* OK, destroy the arrays */

    prismlib_nrarrays_destroy(&array1);
    prismlib_nrarrays_destroy(&array2);
    prismlib_nrarrays_destroy(&array3);

    /* We expect an allocation count of 5 - initial array structure
     * (1), initial entries (2), extend attempt (3), insert attempt
     * (4) and delete attempt (5). We expect a free count of 2 -
     * entries (1) and structure (2).
     */

    if (local_realloc_count != 5)
    {
      CHKERR(prismlib_make_error(0x42,
                                 1,
                                 "local_realloc_count"));
    }

    if (local_free_count != 2)
    {
      CHKERR(prismlib_make_error(0x42,
                                 1,
                                 "local_free_count"));
    }

    /* Hardly a comprehensive set of tests for correct usage, but it'll do for now */

    printf("Arrays: PASS\n");

    /* Simple set of incorrect usage tests */

    printf("Arrays: Incorrect usage (a list of 'OK' errors should follow)\n");

    array1 = prismlib_nrarrays_create(-1, 4,              NULL, NULL);
    array2 = prismlib_nrarrays_create(2,  0,              NULL, NULL);
    array3 = prismlib_nrarrays_create(4,  sizeof(void *), NULL, NULL); /* Should work! */

    if (array1 != NULL || array2 != NULL || array3 == NULL)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrarrays_create()"));
    }

    /* Populate the array */

    for (i = 0; i < prismlib_nrarrays_size(array3); i++)
    {
      ptr3 = prismlib_nrarrays_read(array3, i);
      *((uint32_t *) ptr3) = i + 1;
    }

    /* Test some bogus calls for appropriate modes of failure */

    TSTERR(prismlib_nrarrays_extend(NULL,   2));
    TSTERR(prismlib_nrarrays_extend(array3, -10));

    TSTERR(prismlib_nrarrays_insert(array3, 1, -1));
    TSTERR(prismlib_nrarrays_insert(array3, 1, 5));
    TSTERR(prismlib_nrarrays_insert(array3, 0, 2));

    TSTERR(prismlib_nrarrays_delete(array3, 1, -1));
    TSTERR(prismlib_nrarrays_delete(array3, 1, 5));
    TSTERR(prismlib_nrarrays_delete(array3, 0, 2));

    /* Shouldn't abort! */

    prismlib_nrarrays_destroy(NULL);

    /* At least this has a return value to test... */

    if (prismlib_nrarrays_size(NULL) != 0)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrarrays_size()"));
    }

    if (
         prismlib_nrarrays_read(NULL,   0)  != NULL ||
         prismlib_nrarrays_read(array3, -1) != NULL ||
         prismlib_nrarrays_read(array3, 4)  != NULL
       )
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrarrays_size()"));
    }

    /* Again, shouldn't abort */

    prismlib_nrarrays_sort(NULL,   sort_ascending);
    prismlib_nrarrays_sort(array3, NULL);

    /* Now search in the pre-filled, sorted array for things it shouldn't find */

    key = 0;

    if (
         prismlib_nrarrays_search(array3, &key, sort_ascending) != -1 ||
         prismlib_nrarrays_search(NULL,   &key, sort_ascending) != -1 ||
         prismlib_nrarrays_search(array3, NULL, sort_ascending) != -1 ||
         prismlib_nrarrays_search(array3, &key, NULL)           != -1
       )
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrarrays_search()"));
    }

    printf("Arrays: PASS\n");
    printf("Arrays: PASS ALL\n\n");
  }

  /* Test new facilities in the NRLists system */

  struct nrlist_test
  {
    struct nrlist_test * next;
    struct nrlist_test * prev;

    uint32_t             value;
  };

  {
    struct nrlist_test * head;
    struct nrlist_test * item1;
    struct nrlist_test * item2;
    struct nrlist_test * item3;

    printf("NRLists (limited tests): Correct usage\n");

    /* Add three items */

    CHKERR(prismlib_nrl_add_to_head((void **) &head, sizeof(*head)));
    item1 = head;
    CHKERR(prismlib_nrl_add_to_head((void **) &head, sizeof(*head)));
    item2 = head;
    CHKERR(prismlib_nrl_add_to_head((void **) &head, sizeof(*head)));
    item3 = head;

    /* Should be able to find them */

    if (
         prismlib_nrl_find(head, item1) == false ||
         prismlib_nrl_find(head, item2) == false ||
         prismlib_nrl_find(head, item3) == false
       )
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrl_find()"));
    }

    /* Remove an item */

    CHKERR(prismlib_nrl_remove((void **) &head, item2));

    /* Should be able to find two of them, but not the removed one */

    if (
         prismlib_nrl_find(head, item1) == false ||
         prismlib_nrl_find(head, item2) == true  ||
         prismlib_nrl_find(head, item3) == false
       )
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrl_find()"));
    }

    /* Remove the remaining items */

    CHKERR(prismlib_nrl_remove((void **) &head, item1));
    CHKERR(prismlib_nrl_remove((void **) &head, item3));

    /* Shouldn't be able to find anything now */

    if (
         prismlib_nrl_find(head, item1) == true ||
         prismlib_nrl_find(head, item2) == true ||
         prismlib_nrl_find(head, item3) == true
       )
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrl_find()"));
    }

    printf("NRLists (limited tests): PASS\n");

    /* Tests for robustness with incorrect usage */

    printf("NRLists (limited tests): Incorrect usage\n");

    CHKERR(prismlib_nrl_add_to_head((void **) &head, sizeof(*head)));
    item1 = head;

    if (
         prismlib_nrl_find(NULL, item1) == true ||
         prismlib_nrl_find(head, NULL)  == true ||
         prismlib_nrl_find(NULL, NULL)  == true
       )
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_nrl_find()"));
    }

    CHKERR(prismlib_nrl_remove((void **) &head, item1));

    printf("NRLists (limited tests): PASS\n");
    printf("NRLists (limited tests): PASS ALL\n\n");
  }

  /* Test the job queue system */

  {
    prismlib_jobqueue_t   queue;
    uint32_t            * job;
    int                   i;

    printf("Job queues: Correct usage\n");

    /* Three entries of two words each */

    CHKERR(prismlib_jobqueue_create(3,
                                    2,
                                    &queue));

    if (queue == 0)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_create()"));
    }

    /* Should be able to add entries three times */

    CHKERR(prismlib_jobqueue_add(queue,
                                 &job,
                                 0x12345678,
                                 0x87654321));

    if (job == NULL)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_add() (1)"));
    }

    CHKERR(prismlib_jobqueue_add(queue,
                                 &job,
                                 0x90abcdef,
                                 0xfedcba09));

    if (job == NULL)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_add() (2)"));
    }

    CHKERR(prismlib_jobqueue_add(queue,
                                 &job,
                                 0x567890ab,
                                 0xba098765));

    if (job == NULL)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_add() (3)"));
    }

    /* The third attempt should fail */

    CHKERR(prismlib_jobqueue_add(queue,
                                 &job,
                                 0xcdef1234,
                                 0x4321fedc));

    if (job != NULL)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_add() (4)"));
    }

    /* Should be able to read those back in order */

    CHKERR(prismlib_jobqueue_read(queue, &job));

    if (job == NULL || job[0] != 0x12345678 || job[1] != 0x87654321)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_read() (1)"));
    }

    CHKERR(prismlib_jobqueue_read(queue, &job));

    if (job == NULL || job[0] != 0x90abcdef || job[1] != 0xfedcba09)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_read() (2)"));
    }

    CHKERR(prismlib_jobqueue_read(queue, &job));

    if (job == NULL || job[0] != 0x567890ab || job[1] != 0xba098765)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_read() (3)"));
    }

    /* Third attempt should fail */

    CHKERR(prismlib_jobqueue_read(queue, &job));

    if (job != NULL)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_read() (4)"));
    }

    /* Add two jobs, remove one, add two more */

    CHKERR(prismlib_jobqueue_add(queue,
                                 &job,
                                 0x12345678,
                                 0x87654321));

    CHKERR(prismlib_jobqueue_add(queue,
                                 &job,
                                 0x90abcdef,
                                 0xfedcba09));

    CHKERR(prismlib_jobqueue_remove(queue));

    CHKERR(prismlib_jobqueue_add(queue,
                                 &job,
                                 0x567890ab,
                                 0xba098765));

    CHKERR(prismlib_jobqueue_add(queue,
                                 &job,
                                 0xcdef1234,
                                 0x4321fedc));

    if (job == NULL)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_add() (5)"));
    }

    /* Again, check that the jobs can be read back OK */

    CHKERR(prismlib_jobqueue_read(queue, &job));

    if (job == NULL || job[0] != 0x12345678 || job[1] != 0x87654321)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_read() (1)"));
    }

    CHKERR(prismlib_jobqueue_read(queue, &job));

    if (job == NULL || job[0] != 0x567890ab || job[1] != 0xba098765)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_read() (3)"));
    }

    CHKERR(prismlib_jobqueue_read(queue, &job));

    if (job == NULL || job[0] != 0xcdef1234 || job[1] != 0x4321fedc)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_read() (2)"));
    }

    /* Check we can write one, remove one, write one, read one
     * a few times
     */

    for (i = 0; i < 100; i++)
    {
      CHKERR(prismlib_jobqueue_add(queue,
                                   &job,
                                   0x12345678,
                                   0x87654321));

      if (job == NULL)
      {
        CHKERR(prismlib_make_error(0x41,
                                   1,
                                   "prismlib_jobqueue_add() (6)"));
      }

      CHKERR(prismlib_jobqueue_remove(queue));

      CHKERR(prismlib_jobqueue_add(queue,
                                   &job,
                                   0x90abcdef,
                                   0xfedcba09));

      if (job == NULL)
      {
        CHKERR(prismlib_make_error(0x41,
                                   1,
                                   "prismlib_jobqueue_add() (7)"));
      }

      CHKERR(prismlib_jobqueue_read(queue, &job));

      if (job == NULL || job[0] != 0x90abcdef || job[1] != 0xfedcba09)
      {
        CHKERR(prismlib_make_error(0x41,
                                   1,
                                   "prismlib_jobqueue_read() (2)"));
      }
    }

    /* Delete the queue */

    CHKERR(prismlib_jobqueue_delete(&queue));

    if (queue != 0)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_delete()"));
    }

    /* That's a fairly comprehensive set of tests, even if
     * some of the more edge-like use cases aren't necessarily
     * exercised.
     */

    printf("Job queues: PASS\n");

    /* Simple set of incorrect usage tests */

    printf("Job queues: Incorrect usage (a list of 'OK' errors should follow)\n");

    TSTERR(prismlib_jobqueue_create(0, 4, &queue));
    TSTERR(prismlib_jobqueue_create(4, 0, &queue));
    TSTERR(prismlib_jobqueue_create(4, 4, NULL));

    CHKERR(prismlib_jobqueue_create(4, 4, &queue));

    if (queue == 0)
    {
      CHKERR(prismlib_make_error(0x41,
                                 1,
                                 "prismlib_jobqueue_create()"));
    }

    /* Since the add function is varargs, we cannot expect errors
     * if we supply too many or two few extra parameters. Instead
     * just make sure that the fixed parameters are OK.
     */

    TSTERR(prismlib_jobqueue_add(NULL, &job, 1, 2, 3, 4));

    /* We haven't actually tested the OK use case of the second
     * parameter being NULL yet, so this does it in passing.
     */

    CHKERR(prismlib_jobqueue_add(queue, NULL, 1, 2, 3, 4));

    TSTERR(prismlib_jobqueue_remove(NULL));

    TSTERR(prismlib_jobqueue_read(NULL,  &job));
    TSTERR(prismlib_jobqueue_read(queue, NULL));

    TSTERR(prismlib_jobqueue_delete(NULL));

    CHKERR(prismlib_jobqueue_delete(&queue));

    /* All OK */

    printf("Job queues: PASS\n");
    printf("Job queues: PASS ALL\n\n");
  }

  /* Success! */

  printf("ALL TESTS PASSED\n\n");

  /* Let the atexit() handler deal with shutdown */

  return EXIT_SUCCESS;
}

/**************************************************************/
/* shutdown_tests()                                           */
/*                                                            */
/* Handler registered with atexit() that tidies up the tests  */
/* for early exit.                                            */
/**************************************************************/

static void shutdown_tests(void)
{
  (void) prismlib_locks_unlock(&lock1);
  (void) prismlib_locks_unlock(&lock2);
  (void) prismlib_locks_unlock(&lock3);

  if (messages_opened == true)
  {
    (void) prismlib_close_messages();
  }
}

/**************************************************************/
/* local_realloc()                                            */
/*                                                            */
/* Calls realloc(), incrementing a counter as it does so.     */
/* Parameters and return value as for realloc().              */
/**************************************************************/

static void * local_realloc(void * ptr, size_t size)
{
  local_realloc_count++;

  return realloc(ptr, size);
}

/**************************************************************/
/* local_free()                                               */
/*                                                            */
/* Calls free(), incrementing a counter as it does so.        */
/* Parameters and return value as for free().                 */
/**************************************************************/

static void local_free(void * ptr)
{
  local_free_count++;

  free(ptr);
}

/**************************************************************/
/* sort_ascending()                                           */
/*                                                            */
/* Function compatible with qsort() or bsearch() which sorts  */
/* the 32-bit unsigned integer quantities pointed to by the   */
/* input parameters into ascending numerical order.           */
/**************************************************************/

static int sort_ascending(const void * p1, const void * p2)
{
  /* Brain-dead comparison routine for clarity */

  if      (*((uint32_t *) p1) < *((uint32_t *) p2)) return -1;
  else if (*((uint32_t *) p1) > *((uint32_t *) p2)) return  1;
  else                                              return  0;
}
@


1.5
log
@  New function.
Detail:
  New NRLists.c function to find an element in a linked list (slow - just
  a simple linear search).
Admin:
  Test harness updated; all tests pass.

Version 0.14. Tagged as 'PRISMLib-0_14'
@
text
@d690 279
@


1.4
log
@  Unavoidable API chanGe to NRArrays. Debug test harness build option.
Detail:
  Function was taking an optional pointer to a routine that acted in the
  same way as 'malloc'. What it really needed was a routine that acted
  in the same way as 'realloc'. Meanwhile, the test harness can be built
  to run under DDT to pinpoint the location of a failure easily.
Admin:
  Test harness updated. Debug test harness build requires BuildSys 4.37.

Version 0.13. Tagged as 'PRISMLib-0_13'
@
text
@d589 101
@


1.3
log
@  Two bug fixes.
Detail:
  NRArrays, when asked to create an array with no initial items, would
  try to allocate zero bytes with malloc, get NULL back, and assume this
  represented an out of memory condition. It would then free the partial
  array structure, but since it hadn't filled in the field for the item
  it had just been mallocing yet, would fail as free() operated on some
  undefined value. Fixed: (1) sets field to NULL initially, (2) does not
  try to malloc zero byte quantities in the first place.

  The Handles system didn't quite work; it assumed return values for
  the handle array referred to array size rather than maximum handle
  value. As a result, the Clients system, when shutting down a client
  with active handles, got stuck in an infinite loop, repeatedly trying
  to release the penultimate handle rather than the last handle. Fixed in
  Clients.c with the offending structure member renamed to make its use
  more clear elsewhere.
Admin:
  Showed up whilst writing PFCBuffer. Test harness updated to catch both,
  though it tends to 'get away with' the free() of an uninitialised value,
  so frequently misses this bug even if present. The module no longer
  shows the failures it did, though, so both bugs appear to be fixed.

Version 0.12. Tagged as 'PRISMLib-0_12'
@
text
@d66 1
a66 1
static bool            messages_opened    = false;
d68 2
a69 2
static uint32_t        local_malloc_count = 0;
static uint32_t        local_free_count   = 0;
d71 3
a73 3
static prismlib_lock_t lock1              = 0;
static prismlib_lock_t lock2              = 0;
static prismlib_lock_t lock3              = 0;
d78 1
a78 1
static void * local_malloc   (size_t size);
d376 3
a378 3
    array1 = prismlib_nrarrays_create(0, sizeof(uint32_t), NULL, NULL); /* Should give 'malloc' and 'free' */
    array2 = prismlib_nrarrays_create(0, sizeof(uint32_t), NULL, NULL); /* Should give 'malloc' and 'free' */
    array3 = prismlib_nrarrays_create(0, sizeof(uint32_t), NULL, NULL); /* Should give 'malloc' and 'free' */
d386 3
a388 3
    array1 = prismlib_nrarrays_create(4, sizeof(uint32_t), NULL,         NULL); /* Should give 'malloc' and 'free' */
    array2 = prismlib_nrarrays_create(4, sizeof(uint32_t), malloc,       free); /* Tests type compatibility        */
    array3 = prismlib_nrarrays_create(4, sizeof(uint32_t), local_malloc, local_free);
d486 1
a486 1
    if (local_malloc_count != 5)
d490 1
a490 1
                                 "local_malloc_count"));
d618 1
a618 1
/* local_malloc()                                             */
d620 2
a621 2
/* Calls malloc(), incrementing a counter as it does so.      */
/* Parameters and return value as for malloc().               */
d624 1
a624 1
static void * local_malloc(size_t size)
d626 1
a626 1
  local_malloc_count++;
d628 1
a628 1
  return malloc(size);
@


1.2
log
@  API modification.
Detail:
  Since NRArrays is so new and nobody's using it yet, I decided to change
  the _new, _dispose and _ptr function calls to _create, _destroy and
  _read respectively, to be consistent with Handles.h and generally more
  easy to remember.
Admin:
  Builds, test harness runs and reports success.

Version 0.10. Tagged as 'PRISMLib-0_10'
@
text
@a110 1
   *
d253 33
d374 10
@


1.1
log
@  New functions; bug fixes; test harness.
Detail:
  New functions added in "NRArrays.c|h". Some shared kinds of function
  pointers turned into standard types and put into "FuncTypes.h" - not
  all function pointers used throughout are there, only shared ones at
  the moment (this may change in future). New test harness showed up
  a few bugs, mostly trivial (e.g. incorrect generation of an error
  message resulting in "%0" appearing instead of a parameter).
Admin:
  Tested :-) - test harness runs to completion. See Tests/!ReadMe to
  find out which things the test harness does or does not test. The
  test harness requires BuildSys 4.35.

Version 0.09. Tagged as 'PRISMLib-0_09'
@
text
@d344 3
a346 3
    array1 = prismlib_nrarrays_new(4, sizeof(uint32_t), NULL,         NULL); /* Should give 'malloc' and 'free' */
    array2 = prismlib_nrarrays_new(4, sizeof(uint32_t), malloc,       free); /* Tests type compatibility        */
    array3 = prismlib_nrarrays_new(4, sizeof(uint32_t), local_malloc, local_free);
d373 1
a373 1
                                 "prismlib_nrarrays_new(), prismlib_nrarrays_extend(), prismlib_nrarrays_insert() or prismlib_nrarrays_delete()"));
d378 3
a380 3
    ptr1 = prismlib_nrarrays_ptr(array1, 5);
    ptr2 = prismlib_nrarrays_ptr(array1, 0);
    ptr3 = prismlib_nrarrays_ptr(array1, 1);
d386 1
a386 1
                                 "prismlib_nrarrays_ptr()"));
d397 1
a397 1
      ptr1 = prismlib_nrarrays_ptr(array1, i);
d409 1
a409 1
      ptr1 = prismlib_nrarrays_ptr(array1, i);
d422 1
a422 1
    ptr1  = prismlib_nrarrays_ptr    (array1, 2); /* Should point to value of '3' */
d425 1
a425 1
    if (index != 2 || prismlib_nrarrays_ptr(array1, index) != ptr1)
d434 3
a436 3
    prismlib_nrarrays_dispose(&array1);
    prismlib_nrarrays_dispose(&array2);
    prismlib_nrarrays_dispose(&array3);
d466 3
a468 3
    array1 = prismlib_nrarrays_new(-1, 4,              NULL, NULL);
    array2 = prismlib_nrarrays_new(2,  0,              NULL, NULL);
    array3 = prismlib_nrarrays_new(4,  sizeof(void *), NULL, NULL); /* Should work! */
d474 1
a474 1
                                 "prismlib_nrarrays_new()"));
d481 1
a481 1
      ptr3 = prismlib_nrarrays_ptr(array3, i);
d500 1
a500 1
    prismlib_nrarrays_dispose(NULL);
d512 3
a514 3
         prismlib_nrarrays_ptr(NULL,   0)  != NULL ||
         prismlib_nrarrays_ptr(array3, -1) != NULL ||
         prismlib_nrarrays_ptr(array3, 4)  != NULL
@


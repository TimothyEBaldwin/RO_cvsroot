head	4.3;
access;
symbols
	RISC_OSLib-5_97:4.3
	RISC_OSLib-5_96:4.3
	RISC_OSLib-5_95:4.3
	RISC_OSLib-5_94:4.3
	RISC_OSLib-5_93:4.3
	RISC_OSLib-5_92:4.3
	RISC_OSLib-5_91:4.3
	RISC_OSLib-5_90:4.3
	RISC_OSLib-5_89:4.3
	RISC_OSLib-5_88:4.3
	RISC_OSLib-5_87:4.3
	RISC_OSLib-5_86-1:4.3
	RISC_OSLib-5_86:4.3
	RISC_OSLib-5_85:4.3
	RISC_OSLib-5_84:4.3
	RISC_OSLib-5_83-2:4.3
	RISC_OSLib-5_83-1:4.3
	RISC_OSLib-5_83:4.3
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.3
	RISC_OSLib-5_77:4.3
	RISC_OSLib-5_76:4.3
	RISC_OSLib-5_75:4.3
	RISC_OSLib-5_74:4.3
	RISC_OSLib-5_73:4.3
	RISC_OSLib-5_72:4.3
	RISC_OSLib-5_71:4.3
	RISC_OSLib-5_70:4.3
	RISC_OSLib-5_69:4.3
	RISC_OSLib-5_68:4.3
	RISC_OSLib-5_67:4.3
	RISC_OSLib-5_66:4.3
	RISC_OSLib-5_65:4.3
	RISC_OSLib-5_64:4.3
	RISC_OSLib-5_63:4.3
	RISC_OSLib-5_62:4.3
	RISC_OSLib-5_61:4.3
	RISC_OSLib-5_60:4.3
	RISC_OSLib-5_59:4.3
	RISC_OSLib-5_58:4.2
	RISC_OSLib-5_57:4.1
	RISC_OSLib-5_56:4.1
	RISC_OSLib-5_55:4.1
	RISC_OSLib-5_54:4.1
	RISC_OSLib-5_53:4.1
	RISC_OSLib-5_52:4.1
	RISC_OSLib-5_51:4.1
	RO_5_07:4.1
	RISC_OSLib-5_50:4.1
	RISC_OSLib-5_49:4.1
	RISC_OSLib-5_46-4_64_2_1:4.1
	NoInlineAsm:4.1.0.16
	RISC_OSLib-5_48:4.1
	RISC_OSLib-5_47:4.1
	RISC_OSLib-5_46:4.1
	RISC_OSLib-5_45:4.1
	RISC_OSLib-5_44:4.1
	RISC_OSLib-5_43:4.1
	RISC_OSLib-5_42:4.1
	RISC_OSLib-5_41:4.1
	RISC_OSLib-5_40:4.1
	RISC_OSLib-5_39:4.1
	RISC_OSLib-5_38:4.1
	RISC_OSLib-5_37:4.1
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2010.12.06.22.41.27;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2010.11.30.09.29.12;	author rsprowson;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.28;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.25.28;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.55.11;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.33.22;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.50.50;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Import of JPEG support code to RISC_OSLib.
Functionality to query, plot, and transform a JPEG file modelled on the functions provided in 'sprite.c/h'.
To be used to share more code between !Paint and !Draw.

Version 5.59. Tagged as 'RISC_OSLib-5_59'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/****************************************************************************
 * This source file was written by Acorn Computers Limited. It is part of   *
 * the RISCOS library for writing applications in C for RISC OS. It may be  *
 * used freely in the creation of programs for Archimedes. It should be     *
 * used with Acorn's C Compiler Release 3 or later.                         *
 *                                                                          *
 ***************************************************************************/

/*
 * Title  : sprite.h
 * Purpose: provide access to RISC OS sprite facilities
 *          
 */

#ifndef __sprite_h
#define __sprite_h

#ifndef __os_h
#include "os.h"
#endif

/* 
 * This file contains functions for performing operations on sprites.
 * For brevity only a brief description is given for each call. More details
 * can be found in the Programmer's Reference manual under the section on
 * Sprite SWIs.
 *
 */



/******** Simple operations, use no sprite area, no name/sprite pointer ***/

typedef enum
{
  sprite_nopalette  = 0,
  sprite_haspalette = 1
} sprite_palflag;

typedef struct
{
  int xmag,ymag,xdiv,ydiv;
} sprite_factors;

typedef char sprite_pixtrans; 




/* ----------------------------- sprite_screensave -------------------------
 * Save the current graphics window as a sprite file, with optional palette.
 * Equivalent to *ScreenSave.
 *
 */
extern os_error * sprite_screensave(const char *filename, sprite_palflag);
 
/* ---------------------------- sprite_screenload --------------------------
 * Load a sprite file onto the screen. Equivalent to *ScreenLoad.
 *
 */
extern os_error * sprite_screenload(const char *filename);



/****** Operations on either system/user area, no name/sprite pointer *****/

typedef struct /* Format of a sprite area control block */
{
  int size;
  int number;
  int sproff;
  int freeoff;
} sprite_area;

typedef struct /* Format of a sprite header */
{
  int  next;      /*  Offset to next sprite                */
  char name[12];  /*  Sprite name                          */
  int  width;     /*  Width in words-1      (0..639)       */
  int  height;    /*  Height in scanlines-1 (0..255/511)   */
  int  lbit;      /*  First bit used (left end of row)     */
  int  rbit;      /*  Last bit used (right end of row)     */
  int  image;     /*  Offset to sprite image               */
  int  mask;      /*  Offset to transparency mask          */
  int  mode;      /*  Mode sprite was defined in           */
                  /*  Palette data optionally follows here */
                  /*  in memory                            */
} sprite_header;

#define sprite_mainarea ((sprite_area *) 0)

typedef void * sprite_ptr;


/* ------------------------ sprite_area_initialise -------------------------
 * Initialise an area of memory as a sprite area 
 *
 */
void sprite_area_initialise(sprite_area *, int size);

/* ----------------------- sprite_area_readinfo ----------------------------
 * Read information from a sprite area control block
 *
 */
extern os_error * sprite_area_readinfo(sprite_area *, sprite_area *resultarea);

/* --------------------------- sprite_area_reinit --------------------------
 * Reinitialise a sprite area.
 * If system area, then equivalent to *SNew
 *
 */
extern os_error * sprite_area_reinit(sprite_area *);

/* --------------------------- sprite_area_load ----------------------------
 * Load a sprite file into a sprite area.
 * If system area, then equivalent to *SLoad
 *
 */
extern os_error * sprite_area_load(sprite_area *, const char *filename);
 
/* ---------------------------- sprite_area_merge --------------------------
 * Merge a sprite file with a sprite area.
 * If system area, then equivalent to *SMerge
 *
 */
extern os_error * sprite_area_merge(sprite_area *, const char *filename);
 
/* ---------------------------- sprite_area_save ---------------------------
 * Saves a sprite area as a sprite file.
 * If system area, then equivalent to *SSave
 *
 */
extern os_error * sprite_area_save(sprite_area *, const char *filename);

/* ---------------------------- sprite_getname -----------------------------
 * Return the name and length of name of the n'th sprite in a sprite area into 
 * a buffer.
 *
 */
extern os_error * sprite_getname(sprite_area *, void *buffer, int *length, int index);

/* ---------------------------- sprite_get ---------------------------------
 * Copy a rectangle of screen delimited by the last pair of graphics cursor
 * positions as a named sprite in a sprite area, optionally storing the
 * palette with the sprite.
 *
 */
extern os_error * sprite_get(sprite_area *, char *name, sprite_palflag);

/* ---------------------------- sprite_get_rp ------------------------------
 * Copy a rectangle of screen delimited by the last pair of graphics cursor
 * positions as a named sprite in a sprite area, optionally storing the
 * palette with the sprite. Address of sprite returned in resultaddress.
 *
 */
extern os_error * sprite_get_rp(sprite_area *, char *name, sprite_palflag,
                         sprite_ptr *resultaddress);

/* ---------------------------- sprite_get_given ---------------------------
 * Copy a rectangle of screen delimited by the given pair of graphics
 * coordinates as a named sprite in a sprite area, optionally storing the
 * palette with the sprite.
 *
 */
extern os_error * sprite_get_given(sprite_area *, char *name, sprite_palflag,
                            int x0, int y0, int x1, int y1);

/* --------------------------- sprite_get_given_rp -------------------------
 * Copy a rectangle of screen delimited by the given pair of graphics
 * coordinates as a named sprite in a sprite area, optionally storing the
 * palette with the sprite. Address of sprite returned in resultaddress.
 *
 */
extern os_error * sprite_get_given_rp(sprite_area *, char *name, sprite_palflag,
                               int x0, int y0, int x1, int y1,
                               sprite_ptr *resultaddress);

/* ------------------------------ sprite_create ----------------------------
 * Create a named sprite in a sprite area of specified size and screen mode,
 * optionally reserving space for palette data with the sprite.
 *
 */
extern os_error * sprite_create(sprite_area *, char *name, sprite_palflag,
                         int width, int height, int mode);

/* ------------------------------ sprite_create_rp -------------------------
 * Create a named sprite in a sprite area of specified size and screen mode,
 * optionally reserving space for palette data with the sprite.Address of
 * sprite returned in resultaddress.
 *
 */
extern os_error * sprite_create_rp(sprite_area *, char *name, sprite_palflag,
                            int width, int height, int mode,
                            sprite_ptr *resultaddress);


/*********** Operations on system/user area, name/sprite pointer **********/

typedef enum
{
  sprite_id_name = 0,
  sprite_id_addr = 0x74527053 /* 'Magic' number ("SpRt") to test against */
} sprite_type;

typedef struct
{
  union
  {
    char *     name; /* Can use either name of sprite or address (faster) */
    sprite_ptr addr;
  } s;
  sprite_type tag;   /* User must tag the use of this structure manually */
} sprite_id;


/* ----------------------------- sprite_select -----------------------------
 * Select the specified sprite for plotting using plot(0xed,x,y).
 *
 */
extern os_error * sprite_select(sprite_area *, sprite_id *);

/* ----------------------------- sprite_select_rp --------------------------
 * Select the specified sprite for plotting using plot(0xed,x,y). Address of
 * sprite returned in resultaddress.
 *
 */ 
extern os_error * sprite_select_rp(sprite_area *, sprite_id *,
                            sprite_ptr *resultaddress);

/* ----------------------------- sprite_delete -----------------------------
 * Delete the specified sprite.
 *
 */
extern os_error * sprite_delete(sprite_area *, sprite_id *);

/* ----------------------------- sprite_rename -----------------------------
 * Rename the specified sprite within the same sprite area.
 *
 */
extern os_error * sprite_rename(sprite_area *, sprite_id *, char *newname);

/* ----------------------------- sprite_copy -------------------------------
 * Copy the specified sprite as another named sprite in the same sprite area.
 *
 */
extern os_error * sprite_copy(sprite_area *, sprite_id *, char *copyname);

/* ----------------------------- sprite_put --------------------------------
 * Plot the specified sprite using the given GCOL action.
 *
 */
extern os_error * sprite_put(sprite_area *, sprite_id *, int gcol);

/* ----------------------------- sprite_put_given --------------------------
 * Plot the specified sprite at (x,y) using the given GCOL action.
 *
 */
extern os_error * sprite_put_given(sprite_area *, sprite_id *, int gcol,
                            int x, int y);

/* --------------------------- sprite_put_scaled ---------------------------
 * Plot the specified sprite at (x,y) using the given GCOL action, and scaled
 * using the given scale factors.
 *
 */
extern os_error * sprite_put_scaled(sprite_area *, sprite_id *, int gcol,
                            int x, int y,
                            sprite_factors *factors,
                            sprite_pixtrans pixtrans[]);

/* ---------------------------- sprite_put_greyscaled ----------------------
 * Plot the specified sprite at (x,y) using the given GCOL action, and 
 * greyscaled using the given scale factors.
 *
 */
extern os_error * sprite_put_greyscaled(sprite_area *, sprite_id *,
                            int x, int y,
                            sprite_factors *factors,
                            sprite_pixtrans pixtrans[]);

/* ----------------------------- sprite_put_mask ---------------------------
 * Plot the specified sprite mask in the background colour.
 *
 */
extern os_error * sprite_put_mask(sprite_area *, sprite_id *);

/* ----------------------------- sprite_put_mask_given ---------------------
 * Plot the specified sprite mask at (x,y) in the background colour. 
 *
 */
extern os_error * sprite_put_mask_given(sprite_area *, sprite_id *, int x, int y);

/* --------------------------- sprite_put_mask_scaled ----------------------
 * Plot the sprite mask at (x,y) scaled, using the background colour/action
 *
 */
extern os_error * sprite_put_mask_scaled(sprite_area *, sprite_id *,
                            int x, int y,
                            sprite_factors *factors);

/* ----------------------------- sprite_put_char_scaled --------------------
 * Paint char scaled at (x,y)
 *
 */
extern os_error * sprite_put_char_scaled(char ch,
                                  int x, int y,
                                  sprite_factors *factors);

/* ---------------------------- sprite_create_mask -------------------------
 * Create a mask definition for the specified sprite.
 *
 */
extern os_error * sprite_create_mask(sprite_area *, sprite_id *);

/* ---------------------------- sprite_remove_mask -------------------------
 * Remove the mask definition from the specified sprite.
 *
 */
extern os_error * sprite_remove_mask(sprite_area *, sprite_id *);

/* ---------------------------- sprite_insert_row --------------------------
 * Insert a row into the specified sprite at the given row.
 *
 */
extern os_error * sprite_insert_row(sprite_area *, sprite_id *, int row);

/* ---------------------------- sprite_delete_row --------------------------
 * Delete the given row from the specified sprite.
 *
 */
extern os_error * sprite_delete_row(sprite_area *, sprite_id *, int row);

/* ---------------------------- sprite_insert_column -----------------------
 * Insert a column into the specified sprite at the given column. 
 *
 */
extern os_error * sprite_insert_column(sprite_area *, sprite_id *, int column);

/* ---------------------------- sprite_delete_column -----------------------
 * Delete the given column from the specified sprite.
 *
 */
extern os_error * sprite_delete_column(sprite_area *, sprite_id *, int column);

/* ----------------------------- sprite_flip_x -----------------------------
 * Flip the specified sprite about the x axis
 *
 */
extern os_error * sprite_flip_x(sprite_area *, sprite_id *);

/* ----------------------------- sprite_flip_y -----------------------------
 * Flip the specified sprite about the y axis
 *
 */
extern os_error * sprite_flip_y(sprite_area *, sprite_id *);


typedef struct
{
 int width;
 int height;
 int mask;
 int mode;
} sprite_info;

/* -------------------------------- sprite_readsize ------------------------
 * Read the size information for the specified sprite_id
 *
 */
extern os_error * sprite_readsize(sprite_area *, sprite_id *,
                           sprite_info *resultinfo);

/* -------------------------------- sprite_readinfo ------------------------
 * Read the size information for the specified sprite_id, like the function
 * sprite_readsize except resultinfo is only updated if the sprite is found
 *
 */
extern os_error * sprite_readinfo(sprite_area *, sprite_id *,
                           sprite_info *resultinfo);

typedef struct
{
  int colour;
  int tint;
} sprite_colour;

/* ----------------------------- sprite_readpixel --------------------------
 * Read the colour of a given pixel in the specified sprite_id
 *
 */
extern os_error * sprite_readpixel(sprite_area *, sprite_id *,
                            int x, int y, sprite_colour *resultcolour);

/* ----------------------------- sprite_writepixel -------------------------
 * Write the colour of a given pixel in the specified sprite_id
 *
 */
extern os_error * sprite_writepixel(sprite_area *, sprite_id *,
                             int x, int y, sprite_colour *colour);


typedef enum
{
  sprite_masktransparent = 0,
  sprite_masksolid       = 1
} sprite_maskstate;

/* ------------------------------- sprite_readmask -------------------------
 * Read the state of a given pixel in the specified sprite mask
 *
 */
extern os_error * sprite_readmask(sprite_area *, sprite_id *,
                           int x, int y, sprite_maskstate *resultmaskstate);

/* ------------------------------- sprite_writemask ------------------------
 * Write the state of a given pixel in the specified sprite mask
 *
 */
extern os_error * sprite_writemask(sprite_area *, sprite_id *,
                            int x, int y, sprite_maskstate *maskstate);


typedef struct
        { int r[4];
        } sprite_state;

/* ----------------------------- sprite_restorestate -----------------------
 * Restores the old state after one of the sprite redirection calls
 *
 */
extern os_error *sprite_restorestate(sprite_state state);


/* ---------------------------- sprite_outputtosprite ----------------------
 * Redirect VDU output to a sprite, saving old state 
 *
 */
extern os_error *sprite_outputtosprite(sprite_area *area, sprite_id *id,
                                int *save_area, sprite_state *state);

/* ----------------------- sprite_outputtomask -----------------------------
 * Redirects output to a sprite's transparency mask, saving old state
 *
 */
extern os_error *sprite_outputtomask(sprite_area *area, sprite_id *id,
                              int *save_area, sprite_state *state);

/* --------------------------- sprite_outputtoscreen -----------------------
 * Redirect output back to screen, saving old state
 *
 */
extern os_error *sprite_outputtoscreen(int *save_area, sprite_state *state);

/* --------------------------- sprite_sizeof_spritecontext -----------------
 * Get size of save area needed to save sprite context.
 *
 */
extern os_error *sprite_sizeof_spritecontext(sprite_area *area, sprite_id *id,
                                      int *size);

/* ------------------------- sprite_sizeof_screencontext -------------------
 * Get size of save area needed to save screen context.
 *
 */
extern os_error *sprite_sizeof_screencontext(int *size);

/* ------------------------ sprite_removewastage ---------------------------
 * Removes left hand wastage from a sprite
 *
 */
extern os_error *sprite_removewastage(sprite_area *area, sprite_id *id);

/* ------------------------ sprite_change_size -----------------------------
 * General insert/delete rows/columns operations
 *
 */
extern os_error
  *sprite_change_size
  (sprite_area *area, sprite_id *id, BOOL rows, int at, int number);

/* Typedefs and functions for rotating sprites. */

typedef struct {int p0 [2], p1 [2], p2 [2], p3 [2];} sprite_pgm;
typedef int sprite_transmat [6];
typedef struct {int x0, y0, x1, y1;} sprite_box;

/* ------------------------ sprite_put_mask_trans ---------------------
 * Put a box from the mask in background colours through a transformation matrix
 *
 */
extern os_error
  *sprite_put_mask_trans
  (sprite_area *, sprite_id *, sprite_box *, sprite_transmat *);

/* ------------------------ sprite_put_mask_pgm -----------------------
 * Put a box from the mask in background colours to a parallelogram
 *
 */
extern os_error
  *sprite_put_mask_pgm
  (sprite_area *, sprite_id *, sprite_box *, sprite_pgm *);

/* ------------------------ sprite_put_trans --------------------------
 * Put a box from the sprite through a transformation matrix
 *
 */
extern os_error
  *sprite_put_trans
  (sprite_area *, sprite_id *, int gcol_action, sprite_box *, sprite_transmat *, sprite_pixtrans *);

/* ------------------------ sprite_put_pgm ----------------------------
 * Put a box from the sprite to a parallelogram
 *
 */
extern os_error
  *sprite_put_pgm
  (sprite_area *, sprite_id *, int gcol_action, sprite_box *, sprite_pgm *, sprite_pixtrans *);

#endif

/* end of sprite.h */
@


4.2
log
@Enable 2 functions in RISC_OSLib shared entry table.
Needed by !Paint 2.02.
Fix some easy warnings in wimp.c/sprite.c.
Add new function (not in the ROM version) 'wimp_baseofromsprites()'.
bbc_adval fixed to return -1 when no ADC fitted to match Electron behaviour.
Note: the 2 reenabled functions haven't been appended to the table, so anyone who linked a RAM application against 'romastubs' would need to relink.

Version 5.58. Tagged as 'RISC_OSLib-5_58'
@
text
@d29 2
a30 2
# ifndef __sprite_h
# define __sprite_h
d32 3
a34 3
# ifndef __os_h
# include "os.h"
# endif
d533 1
a533 1
# endif
@


4.1
log
@Initial revision
@
text
@d387 7
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

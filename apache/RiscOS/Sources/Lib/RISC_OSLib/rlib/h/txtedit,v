head	4.3;
access;
symbols
	RISC_OSLib-5_97:4.3
	RISC_OSLib-5_96:4.3
	RISC_OSLib-5_95:4.3
	RISC_OSLib-5_94:4.3
	RISC_OSLib-5_93:4.3
	RISC_OSLib-5_92:4.3
	RISC_OSLib-5_91:4.3
	RISC_OSLib-5_90:4.3
	RISC_OSLib-5_89:4.3
	RISC_OSLib-5_88:4.3
	RISC_OSLib-5_87:4.3
	RISC_OSLib-5_86-1:4.3
	RISC_OSLib-5_86:4.3
	RISC_OSLib-5_85:4.3
	RISC_OSLib-5_84:4.2
	RISC_OSLib-5_83-2:4.2
	RISC_OSLib-5_83-1:4.2
	RISC_OSLib-5_83:4.2
	RISC_OSLib-5_82:4.1
	RISC_OSLib-5_81:4.1
	RISC_OSLib-5_75-2:4.1
	RISC_OSLib-5_80:4.1
	RISC_OSLib-5_79:4.1
	RISC_OSLib-5_78:4.1
	RISC_OSLib-5_75-1:4.1
	RISC_OSLib-5_77:4.1
	RISC_OSLib-5_76:4.1
	RISC_OSLib-5_75:4.1
	RISC_OSLib-5_74:4.1
	RISC_OSLib-5_73:4.1
	RISC_OSLib-5_72:4.1
	RISC_OSLib-5_71:4.1
	RISC_OSLib-5_70:4.1
	RISC_OSLib-5_69:4.1
	RISC_OSLib-5_68:4.1
	RISC_OSLib-5_67:4.1
	RISC_OSLib-5_66:4.1
	RISC_OSLib-5_65:4.1
	RISC_OSLib-5_64:4.1
	RISC_OSLib-5_63:4.1
	RISC_OSLib-5_62:4.1
	RISC_OSLib-5_61:4.1
	RISC_OSLib-5_60:4.1
	RISC_OSLib-5_59:4.1
	RISC_OSLib-5_58:4.1
	RISC_OSLib-5_57:4.1
	RISC_OSLib-5_56:4.1
	RISC_OSLib-5_55:4.1
	RISC_OSLib-5_54:4.1
	RISC_OSLib-5_53:4.1
	RISC_OSLib-5_52:4.1
	RISC_OSLib-5_51:4.1
	RO_5_07:4.1
	RISC_OSLib-5_50:4.1
	RISC_OSLib-5_49:4.1
	RISC_OSLib-5_46-4_64_2_1:4.1
	NoInlineAsm:4.1.0.16
	RISC_OSLib-5_48:4.1
	RISC_OSLib-5_47:4.1
	RISC_OSLib-5_46:4.1
	RISC_OSLib-5_45:4.1
	RISC_OSLib-5_44:4.1
	RISC_OSLib-5_43:4.1
	RISC_OSLib-5_42:4.1
	RISC_OSLib-5_41:4.1
	RISC_OSLib-5_40:4.1
	RISC_OSLib-5_39:4.1
	RISC_OSLib-5_38:4.1
	RISC_OSLib-5_37:4.1
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2015.04.03.20.40.04;	author rsprowson;	state Exp;
branches;
next	4.2;
commitid	G8BXIPKUyzCGAbgy;

4.2
date	2014.07.31.08.24.13;	author rsprowson;	state Exp;
branches;
next	4.1;
commitid	jfGiiZxupMtuqvKx;

4.1
date	96.11.05.09.25.29;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.25.29;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.55.15;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.33.30;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.50.55;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Switch from ArcEdit style model to clipboard cut & paste model
The txt library part of RISC_OSLib was essentially contrary to everything Acorn was telling its developers, to use the global clipboard.
Additionally, support is added for swap case within a selection.
txt.h:
 Add a new charoption type 'txt_READONLY' to inform txt that the buffer is notionally read only, this is used to supress 'Paste' in the selection menu when appropriate.
 Correct some typos in the comments.
txt1.h:
 Kill off modula 2 dummy structure member.
txtar.h:
 Remove unused function export.
txtfile.h:
 Rename basicimport to be consistent with the text version of the same function. We use 'import' to denote RAM transfers and 'insert' to denote file/scrap transfers throughout.
txtmisc.h:
 Redundant internal functions removed.
txtundo.h:
 Add a new undo operation type 't' for swap case, to avoid polluting the undo buffer with an entire copy of the text where only the case changed.
 Kill off modula 2 double pointer requirement.
txtedit.h:
 Unused structure member 'selectctl' removed.
txt.c:
 Kill off modula 2 double pointer requirement.
txtar.c:
 Refactor message despatch with a switch statement so the save/load/open operations are explicitly checked for, in case the application enables other messages.
txtedit.c:
 Adopt MOVERWRITE, been enabled since 1988 so is probably good to keep.
 Dynamically generate the Select menu by first sending a clipboard request, and fading Paste if no reply comes back.
 Implement changed mouse selection logic.
 Implement different hotkeys and caret navigation.
 Implement copy and paste/replace operations.
 Implement swap case operation.
txtfile.c:
 Type corrections and function rename admin.
 Implement copy and paste/replace operation for detokenised BASIC.
txtmisc.c:
 Supporting functions for clipboard added, supporting functions for ArcEdit removed.
txtscrap.c:
 Make sure the caret is visible for programmatical zero sized selections.
txtundo.c:
 Allow suspension of undo during known complex operations, such as import via RAM transmit. This was a longstanding bug where the import buffer was grabbed in ~4k chunks (even if only 1 byte was being transferred) which in turn resulted in a +4000 undo insertion and a -3999 removal, which given the default undo buffer is only 5k would result in it failing the reversibility test, so no undo was possible.
 Now, during a RAM transmit undo is suspended until the total transfer size is known, and only that data is placed in the undo buffer (subject to the same 5k reversibility limit).
 Add new undo type 't' for swap case operation.
rlibdata.s:
 4 new ints and 1 new BOOL, so RlibSpace increases by 5.

Version 5.85. Tagged as 'RISC_OSLib-5_85'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/****************************************************************************
 * This source file was written by Acorn Computers Limited. It is part of   *
 * the RISCOS library for writing applications in C for RISC OS. It may be  *
 * used freely in the creation of programs for Archimedes. It should be     *
 * used with Acorn's C Compiler Release 3 or later.                         *
 *                                                                          *
 ***************************************************************************/

/* 
 * Title: txtedit.h
 * Purpose: Text editing facilities.
 *
 */

# ifndef __txtedit_h
# define __txtedit_h

# ifndef __txt_h
# include "txt.h"
# endif

# ifndef __typdat_h
# include "typdat.h"
# endif

#ifndef __menu_h
#include "menu.h"
#endif

#ifndef BOOL
#define BOOL int
#define TRUE 1
#define FALSE 0
#endif

/****************************** DATA TYPES *********************************/

typedef enum
  {
    txtedit_CHARSEL = 1, txtedit_WORDSEL = 2, txtedit_LINESEL = 4

  } txtedit_seltype;

typedef struct txtedit_state
  {
    txt             t;
    txt_marker      selpivot;       /* used in mouse op calculations */
    txtedit_seltype seltype;        /* used in mouse op calculations */
    int             selectrecent;   /* used in mouse op calculations */
#if FALSE
    int             selectctl;      /* used in mouse op calculations */
#endif
    char            filename[256];
    typdat          ty;
    struct txtedit_state *next;     /* chain of all of them. */
    BOOL            overwrite;
    BOOL            wordtab;
    BOOL            wordwrap;
  } txtedit_state;

typedef BOOL (*txtedit_update_handler)(char *, txtedit_state *, void *);
typedef void (*txtedit_close_handler)(char *, txtedit_state *, void *);
typedef BOOL (*txtedit_save_handler)(char *, txtedit_state *, void *);
typedef void (*txtedit_shutdown_handler)(void *);
typedef void (*txtedit_undofail_handler)(char *, txtedit_state *, void *);
typedef void (*txtedit_open_handler)(char *, txtedit_state *, void *);

/**************************** INTERFACE FUNCTIONS *************************/


/* --------------------------- txtedit_install -----------------------------
 * Description:   Installs an event handler for the txt t, thus making it
 *                an editable text.
 *
 * Parameters:    txt t -- the text object (created via txt_new)
 * Returns:       A pointer to the resulting txtedit_state.
 * Other Info:    none.
 *
 */

txtedit_state *txtedit_install(txt t);


/* ----------------------------- txtedit_new -------------------------------
 * Description:   Creates a new text object, loads the given file into it
 *                and the text can now be edited.
 *
 * Parameters:    char *filename -- the file to be loaded.
 *                int filetype -- filetype to be given if null filename
 * Returns:       a pointer to the txtedit_state for this text.
 * Other Info:    If the file cannot be found, then 0 is returned as a 
 *                result, and no text is created. If "filename" is a null
 *                pointer, then an editor window with no given file name
 *                will be constructed. If the file is already being edited,
 *                then a pointer to the existing txtedit_state is returned.
 *
 */

txtedit_state *txtedit_new(char *filename, int filetype);


/* ---------------------------- txtedit_dispose ----------------------------
 * Description:   Destroys the given text being edited.
 *
 * Parameters:    txtedit_state *s -- the text to be destroyed.
 * Returns:       void.
 * Other Info:    Note: this will ask no questions of the user before
 *                destroying the text.
 *
 */
 
void txtedit_dispose(txtedit_state *s);


/* --------------------------- txtedit_mayquit -----------------------------
 * Description:   Check if we may safely quit editing.
 *
 * Parameters:    void.
 * Returns:       TRUE if we may safely quit, otherwise FALSE.
 * Other Info:    If a text is being edited, then a dialogue box is displayed
 *                asking the user if he really wants to quit.
 *                This calls dboxquery(), and therefore requires the 
 *                template "query" as described in dboxquery.h.
 *
 */

BOOL txtedit_mayquit(void);


/* ----------------------------- txtedit_prequit ---------------------------
 * Description:   Deal with a PREQUIT message from the task manager.
 *
 * Parameters:    void.
 * Returns:       void.
 * Other Info:    Calls txtedit_mayquit(), to see if we may quit, if text
 *                is being edited. If user replies that we may quit, then
 *                all texts are disposed of, and this function sends an
 *                acknowledgement to the task manager.
 *
 */

void txtedit_prequit(void);


/* ---------------------------- txtedit_menu -------------------------------
 * Description:   Sets up a menu structure for the text being edited,
 *                tailored to its current state.
 *
 * Parameters:    txtedit_state * s -- the text's current state.
 * Returns:       a pointer to an appropriately formed menu structure
 * Other Info:    The menu created will have the same form as that displayed
 *                when mouse menu button is clicked on an !Edit window.
 *                (For !Edit version 1.00).
 *                Entries in the menu are set according to the supplied
 *                txtedit_state.
 */

menu txtedit_menu(txtedit_state *s);


/*------------------------------ txtedit_menuevent -------------------------
 * Description:   Apply a given menu hit to a given text.
 *
 * Parameters:    txtedit_state *s -- the text to which hit should be applied
 *                char *hit -- a menu hit string.
 * Returns:       void.
 * Other Info:    This can be called from a menu event handler.
 *
 */
    
void txtedit_menuevent(txtedit_state *s, char *hit);


/* --------------------------- txtedit_doimport ----------------------------
 * Description:   Import data into the specified txtedit object, from a file
 *                of a given type.
 *
 * Parameters:    txtedit_state *s -- the text object
 *                int filetype -- type of the file
 *                int estsize -- file's estimated size.
 * Returns:       TRUE if import completed successfully.
 * Other Info:    none.
 *
 */

BOOL txtedit_doimport(txtedit_state *s, int filetype, int estsize);


/* ------------------------- txtedit_doinsertfile --------------------------
 * Description:   Inserts a named file in a given text object.
 *
 * Parameters:    txtedit_state *s -- the text object
 *                char *filename -- the given file
 *                BOOL replaceifwasnull -- if set to TRUE then the text
 *                                         object will be considred to have
 *                                         come from "filename", ie. window
 *                                         title is updated.
 *
 * Returns:       void.
 * Other Info:    none.
 *
 */

void txtedit_doinsertfile(txtedit_state *s, char *filename, BOOL replaceifwasnull);

/* ------------------------ txtedit_settexttitle --------------------------
 * Description:   Updates the text window titles to reflect the state of
 *                the specified text object
 *
 * Parameters:    txtedit_state *s -- the text object
 * Returns:       void.
 * Other Info:    none.
 *
 */

void txtedit_settexttitle(txtedit_state *s);

/* ------------------------ txtedit_register_update_handler ---------------
 * Description:   Register a handler to be called when a text window is 
 *                modified
 *
 * Parameters:    txtedit_handler h -- the handler function
 *                void *handle      -- handle to be passed to the function
 * Returns:       previous handler
 * Other Info:    This routine will be called whenever a window's title bar
 *                is redrawn, and the text in the window has been modified.
 *                Note: this is not just called when the '*' first appears 
 *                in a window's title bar, but every time the title bar of a
 *                modified text window is redrawn (eg. when the filename
 *                changes or wordwrap is turned on/off etc).
 *                The handler function will be passed:
 *                       i) the filename for the window title
 *                      ii) the address of this 'txtedit_state'
 *                     iii) the handle registered with this function
 *                If the handler returns FALSE, then the last modification
 *                will be undone.  This is only possible if the modification
 *                is not greater than ~5kb.
 *                Calling with h == 0 removes the handler.
 *
 */

txtedit_update_handler txtedit_register_update_handler(txtedit_update_handler h, void *handle);


/* ------------------------ txtedit_register_save_handler ------------------
 * Description:   Register a handler to be called when a text window is 
 *                saved
 *
 * Parameters:    txtedit_handler h -- the handler function
 *                void *handle      -- handle to be passed to the function
 * Returns:       previous handler
 * Other Info:    This routine will be called whenever a text window is saved
 *                to file (NOT via RAM transfer).
 *                The handler function will be passed:
 *                       i) the filename for the window title
 *                      ii) the address of this 'txtedit_state'
 *                     iii) the handle registered with this function
 *                Calling with h == 0 removes the handler.
 *                Returning FALSE from your handler will abort the save
 *                operation.
 *
 */

txtedit_save_handler txtedit_register_save_handler(txtedit_save_handler h, 
                                                   void *handle);


/* ------------------------ txtedit_register_close_handler ----------------
 * Description:   Register a handler to be called when a modified text 
 *                window is closed
 *
 * Parameters:    txtedit_handler h -- the handler function
 *                void *handle      -- handle to be passed to the function
 * Returns:       previous handler
 * Other Info:    This routine will be called whenever a text
 *                window is closed.
 *                The handler function will be passed:
 *                       i) the filename for the window title
 *                      ii) the address of this 'txtedit_state'
 *                     iii) the handle registered with this function
 *                Calling with h == 0 removes the handler.
 *
 */

txtedit_close_handler txtedit_register_close_handler(txtedit_close_handler h,
                                                     void *handle);


/* ------------------------ txtedit_register_shutdown_handler --------------
 * Description:   Register a handler to be called when txtedit_prequit() is
 *                called. 
 *
 * Parameters:    txtedit_handler h -- the handler function
 *                void *handle      -- handle to be passed to the function
 * Returns:       previous handler
 * Other Info:    This routine will be called whenever txtedit_prequit() is
 *                called, and the user answers "yes" when asked if he really
 *                wants to quit edit, or no files have been modified.
 *                The handler function will be passed the handle
 *                registered with this function
 *                Calling with h == 0 removes the handler.
 *
 */

txtedit_shutdown_handler txtedit_register_shutdown_handler(txtedit_shutdown_handler h, void *handle);


/* ------------------------ txtedit_register_undofail_handler --------------
 * Description:   Register a handler to be called when your update_handler
 *                returned FALSE, and the undo buffer overflowed. 
 *
 * Parameters:    txtedit_handler h -- the handler function
 *                void *handle      -- handle to be passed to the function
 * Returns:       previous handler
 * Other Info:    This will be called when the modification made to an
 *                edited file cannot be undone (only in conjunction with
 *                an update handler).
 *                The handler function will be passed:
 *                       i) the filename for the window title
 *                      ii) the address of this 'txtedit_state'
 *                     iii) the handle registered with this function
 *                Calling with h == 0 removes the handler.
 *
 */

txtedit_undofail_handler txtedit_register_undofail_handler(txtedit_undofail_handler h, void *handle);


/* -------------------------- txtedit_register_open_handler -------------------
 * Description:   Register a handler to be called when a new txtedit_state is
 *                created. 
 *
 * Parameters:    txtedit_handler h -- the handler function
 *                void *handle      -- handle to be passed to the function
 * Returns:       previous handler
 * Other Info:    The handler function will be passed:
 *                       i) the filename for the window title
 *                      ii) the address of this 'txtedit_state'
 *                     iii) the handle registered with this function
 *                Calling with h == 0 removes the handler.
 *
 */

txtedit_open_handler txtedit_register_open_handler(txtedit_open_handler h, void *handle);


/* ---------------------------- txtedit_getstates --------------------------
 * Description:   Get a pointer to the list of current txtedit_states
 *
 * Parameters:    void.
 * Returns:       Pointer to the list of txtedit_states
 * Other Info:    The txtedit part of RISC_OSlib keeps a list of all
 *                txtedit_states created (via txtedit_new). This function
 *                allows access to this list
 *
 */

txtedit_state *txtedit_getstates(void);

/* ---------------------------- txtedit_setBASICaddresses ------------------
 * Description:   Initialises the internal pointers to BASIC's tokenising
 *                and detokenising routines. This is necessary before the
 *                txtedit module can tokenise and detokenise BASIC.
 *
 * Parameters:    int tokenise   -- the address of BASIC's tokeniser
 *                int detokenise -- the address of BASIC's detokeniser
 * Returns:       void.
 * Other Info:    These two addresses can be obtained from the short BASIC
 *                program inside !Edit, which sets two system variables.
 *
 */

void txtedit_setBASICaddresses(int tokenise, int detokenise);

/* ---------------------------- txtedit_setBASICstrip ----------------------
 * Description:   Sets the internal flag to indicate whether or not line
 *                numbers should be stripped from BASIC files being loaded.
 *
 * Parameters:    BOOL strip -- TRUE if line numbers should be stripped,
 *                              else FALSE
 * Returns:       void.
 * Other Info:    none.
 *
 */

void txtedit_setBASICstrip(BOOL strip);

/* ---------------------------- txtedit_setBASICincrement ------------------
 * Description:   Sets the increment to be used when creating line numbers.
 *
 * Parameters:    int increment
 * Returns:       void.
 * Other Info:    none.
 *
 */

void txtedit_setBASICincrement(int increment);

/* ---------------------------- txtedit_init -------------------------------
 * Description:   Initialise the txtedit module of the library
 *
 * Parameters:    void.
 * Returns:       void.
 * Other Info:    none.
 *
 */

void txtedit_init(void);

#endif

/* end txtedit.h */
@


4.2
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@d64 1
d66 1
@


4.1
log
@Initial revision
@
text
@a66 1
    int             deletepending;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

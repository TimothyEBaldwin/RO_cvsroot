head	4.5;
access;
symbols
	RISC_OSLib-5_97:4.5
	RISC_OSLib-5_96:4.5
	RISC_OSLib-5_95:4.5
	RISC_OSLib-5_94:4.5
	RISC_OSLib-5_93:4.5
	RISC_OSLib-5_92:4.5
	RISC_OSLib-5_91:4.5
	RISC_OSLib-5_90:4.5
	RISC_OSLib-5_89:4.5
	RISC_OSLib-5_88:4.5
	RISC_OSLib-5_87:4.5
	RISC_OSLib-5_86-1:4.5
	RISC_OSLib-5_86:4.5
	RISC_OSLib-5_85:4.5
	RISC_OSLib-5_84:4.5
	RISC_OSLib-5_83-2:4.5
	RISC_OSLib-5_83-1:4.5
	RISC_OSLib-5_83:4.5
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.3
	RISC_OSLib-5_77:4.3
	RISC_OSLib-5_76:4.3
	RISC_OSLib-5_75:4.3
	RISC_OSLib-5_74:4.3
	RISC_OSLib-5_73:4.3
	RISC_OSLib-5_72:4.3
	RISC_OSLib-5_71:4.3
	RISC_OSLib-5_70:4.3
	RISC_OSLib-5_69:4.3
	RISC_OSLib-5_68:4.3
	RISC_OSLib-5_67:4.3
	RISC_OSLib-5_66:4.3
	RISC_OSLib-5_65:4.3
	RISC_OSLib-5_64:4.3
	RISC_OSLib-5_63:4.3
	RISC_OSLib-5_62:4.3
	RISC_OSLib-5_61:4.3
	RISC_OSLib-5_60:4.3
	RISC_OSLib-5_59:4.3
	RISC_OSLib-5_58:4.3
	RISC_OSLib-5_57:4.3
	RISC_OSLib-5_56:4.3
	RISC_OSLib-5_55:4.3
	RISC_OSLib-5_54:4.3
	RISC_OSLib-5_53:4.3
	RISC_OSLib-5_52:4.3
	RISC_OSLib-5_51:4.3
	RO_5_07:4.3
	RISC_OSLib-5_50:4.3
	RISC_OSLib-5_49:4.3
	RISC_OSLib-5_46-4_64_2_1:4.3
	NoInlineAsm:4.3.0.2
	RISC_OSLib-5_48:4.3
	RISC_OSLib-5_47:4.3
	RISC_OSLib-5_46:4.3
	RISC_OSLib-5_45:4.3
	RISC_OSLib-5_44:4.2
	RISC_OSLib-5_43:4.2
	RISC_OSLib-5_42:4.2
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2014.08.23.21.27.31;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	oe7YyRjInqWq1xNx;

4.4
date	2014.07.31.08.24.08;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	jfGiiZxupMtuqvKx;

4.3
date	2003.01.16.12.43.31;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.49;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.11;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.11;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.53.43;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.30.23;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.26;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.14;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Minor rlib cleanups
dbox.c: address of cancelled by dereference
event.c: spelling
txtar.c: don't grab the caret when clicking toggle size
txtedit.c: use BOOL for a boolean
win.c: when looking at the behind window handle we want -1 not 'DUD' (which happens to be -1)
wimp.h: add comment about window handle -3
Retagged as RISC_OSLib-5_83.

Version 5.83. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.event
 * Purpose: central processing for window system events.
 * History: IDJ: 06-Feb-92: prepared for source release
 *
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdlib.h>

#include "trace.h"
#include "os.h"
#include "wimp.h"
#include "wimpt.h"
#include "win.h"
#include "menu.h"
#include "alarm.h"

#include "event.h"


/* --------- masking of events ---------- */

static wimp_emask event__mask = wimp_EMNULL;

void event_setmask (wimp_emask mask)
{
  event__mask = mask;
}


wimp_emask event_getmask (void)
{
  return (event__mask);
}


/* -------- attaching menus. -------- */

/* An event_w is in fact a wimp_w. */

typedef struct {
  menu m;
  event_menu_maker maker;
  event_menu_proc event;
  void *handle;
} mstr;

static BOOL event__attach(event_w w,
                          menu m, event_menu_maker menumaker,
                          event_menu_proc eventproc, void *handle)
{
  mstr *p = win_getmenuh(w);
  if (m == 0 && menumaker == 0)
  {
    /* cancelling */
    if (p != 0)
    { /* something to cancel */
      free(p);
      win_setmenuh(w, 0);
    }
  }
  else
  {
    if (p == 0) p = malloc(sizeof(mstr));
    if (p == 0) return FALSE;
    p->m = m;
    p->maker = menumaker;
    p->event = eventproc;
    p->handle = handle;
    win_setmenuh(w, p);
  }
  return TRUE;
}

BOOL event_attachmenu(event_w w, menu m, event_menu_proc eventproc, void* handle)
{
  return event__attach(w, m, 0, eventproc, handle);
}

BOOL event_attachmenumaker(event_w w, event_menu_maker menumaker, event_menu_proc eventproc, void *handle)
{
  return event__attach(w, 0, menumaker, eventproc, handle);
}

/* -------- Processing Events. -------- */

static wimp_w event__current_menu_window = 0;
  /* 0 if no menu currently visible */
static menu event__current_menu = NULL;
static BOOL event__current_destroy_after; /* set if we made the menu */
static int event__menux = 0;
static int event__menuy = 0;
static BOOL event__last_was_menu_hit = FALSE;
static BOOL event__recreation;

static BOOL event__process(wimp_eventstr *e)
{
  /* Look for submenu requests, and if found turn them into menu hits. */
  /* People wishing to respond can pick up the original from wimpt. */
  if (e->e == wimp_ESEND && e->data.msg.hdr.action == wimp_MMENUWARN)
  {
    int i;
    e->e = wimp_EMENU;
    i = 0;
    while ((e->data.menu[i] = e->data.msg.data.words[i+3]) != -1) i++;
    e->data.menu[i++] = 0;
    e->data.menu[i++] = -1;
  }

  /* Look for menu events */
  if (e->e == wimp_EBUT && (wimp_BMID & e->data.but.m.bbits) != 0)
  {
    /* set up a menu! */
    mstr *p;
    if (e->data.but.m.w <= -1) e->data.but.m.w = win_ICONBAR;
    p = win_getmenuh(e->data.but.m.w);
    if (p != 0)
    {
      wimp_menuhdr *m;
      event__current_menu_window = e->data.but.m.w;
      event__current_menu = p->m;
      event__current_destroy_after = FALSE;
      if (p->m != 0)
      {
        m = (wimp_menuhdr*) menu_syshandle(p->m);
      }
      else if (p->maker != 0)
      {
        event__current_destroy_after = FALSE;
        event__recreation = 0 ;
        event__current_menu = p->maker(p->handle);
        m = (wimp_menuhdr*) menu_syshandle(event__current_menu);
      }
      else
      {
        m = (wimp_menuhdr *) -1;
      }
      if (event__current_menu_window == win_ICONBAR)
      {
        /* move icon bar menus up a bit. */
        e->data.but.m.x -= 16 /* m->width/2 */;
        e->data.but.m.y = 96;
        {
          wimp_menuitem *mi = (wimp_menuitem*) (m + 1);
          while (1) {
            e->data.but.m.y += m->height + m->gap;
            if ((mi->flags & wimp_MLAST) != 0) break;
            mi++;
          }
        }
      }
      event__menux = e->data.but.m.x;
      event__menuy = e->data.but.m.y;
      wimpt_complain(wimp_create_menu((wimp_menustr*) m, e->data.but.m.x - 48, e->data.but.m.y));
      return FALSE;
    }
  }
  else if (e->e == wimp_EMENU && event__current_menu != NULL)
  {
    mstr *p;
    p = win_getmenuh(event__current_menu_window);
    if (p == 0)
    {
      /* if the menu registration has been cancelled,
      we hand the event on. */
    }
    else
    {
      int i;
      char a[20];
      for (i = 0; e->data.menu[i] != -1; i++) {a[i] = 1 + e->data.menu[i];}
      a[i] = 0;
      p->event(p->handle, a);
      event__last_was_menu_hit = TRUE; /* menu has still to be deleted. */
      return FALSE;
    }
  }

  if (e->e == wimp_ENULL)
  {
    int dummy_time;
    BOOL pending_alarm = alarm_next(&dummy_time);
    tracef0("Got a null\n");
    if (pending_alarm != 0 && dummy_time <= alarm_timenow())
    {
      tracef1("Calling alarm at %d\n", alarm_timenow());
      alarm_callnext();
    }

    if ((event_getmask() & wimp_EMNULL) != 0)
       return TRUE;
  }

  /* now process the event */
  if (win_processevent(e))
  {
    /* all is well, it was claimed */
  }
  else if (e->e == wimp_ENULL)
  {
    /* machine idle: say so */
    return TRUE;
  }
  else if (e->e == wimp_EOPEN)
  {
    /* Assume it's a menu being moved */
    wimpt_complain(wimp_open_wind(&e->data.o));
  }

  return FALSE;
}

static void event__poll(wimp_emask mask, wimp_eventstr *result)
{
  if (event__last_was_menu_hit && wimpt_last_event()->e == wimp_EMENU)
  {
    wimp_mousestr m;
    event__last_was_menu_hit = FALSE;
    wimpt_noerr(wimp_get_point_info(&m));
    if (0 != (wimp_BRIGHT & m.bbits))
    {
      /* An ADJ-hit. The menu should be recreated. */
      mstr *p = win_getmenuh(event__current_menu_window);
      if (p != 0)
      {
        wimp_menustr *m;
        event__current_menu = p->m;
        event__current_destroy_after = FALSE;
        if (p->m != 0)
        {
          m = (wimp_menustr*) menu_syshandle(p->m);
        } else if (p->maker != 0) {
          event__recreation = 1 ;
          event__current_menu = p->maker(p->handle);
          m = (wimp_menustr*) menu_syshandle(event__current_menu);
        }
        else
        {
          m = (wimp_menustr *) -1;
        }
        wimpt_complain(wimp_create_menu(m, event__menux, event__menuy));
      }
    }
  }
  tracef0("doing poll.\n");
  wimpt_complain(wimpt_poll(mask, result));
  tracef0("poll done.\n");
}

void event_process(void)
{
  tracef0("event_process.\n");
  if (win_activeno() == 0) exit(0); /* stop program */
  {
    wimp_eventstr e;
    event__poll(event_getmask(), &e);
    (void) event__process(&e);
  }
}

#ifndef UROM
BOOL event_anywindows()
{
  return(win_activeno() != 0);
}
#endif

void event_clear_current_menu(void) {
  event__current_menu = NULL;
  event__current_menu_window = 0;
  wimpt_noerr(wimp_create_menu((wimp_menustr*) -1, 0, 0));
}

BOOL event_is_menu_being_recreated(void)
{
 return event__recreation;
}

/* end */
@


4.4
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@d30 1
a30 1
 * Purpose: central processing for window sytem events.
@


4.3
log
@  Misc changes.
Detail:
  * Improved lookup of application Sprites file: uses Wimp_Extend 13 (in
    Wimps that support it) to work out the appropriate resolution suffix,
    and prefixes with "<Wimp$IconTheme>" to allow a future Theme Manager
    to operate.
  * Preserves attributes of any existing file when saving sprite or text
    files.
  * Changed two null menu handles from 0 to (doucmented) -1. Despite the
    fact that the Wimp is actually happy with 0 as a null handle here,
    this was reported as a fault.
  * Changed rlib.c.version to use VersionNum, deleted thereby-obsoleted
    rlib.h.VerIntern.version file. Not that rlib.c.version seems to be used
    at the moment.
  * Added Kevin's additions to the test directory.
Admin:
  Tested briefly.

Version 5.44. Not tagged
@
text
@d120 1
a120 1
static menu event__current_menu;
d189 1
a189 1
  else if (e->e == wimp_EMENU && event__current_menu != 0)
d300 2
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d167 1
a167 1
        m = 0;
d270 1
a270 1
          m = 0;
@


4.1
log
@Initial revision
@
text
@d15 18
a32 3
/* Title: -> c.event
 * Purpose: system-independent central processing for window sytem events.
 * ECN 08-May-91 #ifndefed out unused ROM functions
d47 1
a47 1
#include "alarm.h"    
d80 2
a81 1
  menu m, event_menu_maker menumaker, event_menu_proc eventproc, void *handle)
d84 5
a88 2
  if (m == 0 && menumaker == 0) { /* cancelling */
    if (p != 0) { /* something to cancel */
d91 4
a94 2
    };
  } else {
d102 1
a102 1
  };
d106 1
a106 2
BOOL event_attachmenu(event_w w,
  menu m, event_menu_proc eventproc, void* handle)
d111 1
a111 2
BOOL event_attachmenumaker(event_w w,
  event_menu_maker menumaker, event_menu_proc eventproc, void *handle)
d125 1
a125 1
static BOOL event__recreation ;
d131 2
a132 1
  if (e->e == wimp_ESEND && e->data.msg.hdr.action == wimp_MMENUWARN) {
d139 1
a139 1
  };
d142 2
a143 1
  if (e->e == wimp_EBUT && (wimp_BMID & e->data.but.m.bbits) != 0) {
d148 2
a149 1
    if (p != 0) {
d154 2
a155 1
      if (p->m != 0) {
d157 3
a159 1
      } else if (p->maker != 0) {
a160 1
          /* WRS: menu destruction taken out*/
d164 3
a166 1
      } else {
d168 3
a170 2
      };
      if (event__current_menu_window == win_ICONBAR) {
d180 3
a182 3
          };
        };
      };
d187 4
a190 2
    };
  } else if (e->e == wimp_EMENU && event__current_menu != 0) {
d193 2
a194 1
    if (p == 0) {
d197 3
a199 1
    } else {
d202 1
a202 1
      for (i = 0; e->data.menu[i] != -1; i++) {a[i] = 1 + e->data.menu[i];};
d207 2
a208 2
    };
  };
d224 1
a224 1
  
d226 2
a227 1
  if (win_processevent(e)) {
d229 3
a231 1
  } else if (e->e == wimp_ENULL) {
d234 3
a236 1
  } else if (e->e == wimp_EOPEN) {
d239 2
a240 2
  } else {
  };
d246 2
a247 1
  if (event__last_was_menu_hit && wimpt_last_event()->e == wimp_EMENU) {
d251 2
a252 1
    if (0 != (wimp_BRIGHT & m.bbits)) {
d255 2
a256 1
      if (p != 0) {
d260 2
a261 1
        if (p->m != 0) {
d267 3
a269 1
        } else {
d271 1
a271 1
        };
d273 3
a275 3
      };
    };
  };
d284 1
a284 1
  if (win_activeno() == 0) exit(0); /* stop program */ 
d289 1
a289 1
  };
d305 1
a305 1
 return event__recreation ;
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 3
a17 18
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.event
 * Purpose: central processing for window sytem events.
 * History: IDJ: 06-Feb-92: prepared for source release
 *
d32 1
a32 1
#include "alarm.h"
d65 1
a65 2
                          menu m, event_menu_maker menumaker,
                          event_menu_proc eventproc, void *handle)
d68 2
a69 5
  if (m == 0 && menumaker == 0)
  {
    /* cancelling */
    if (p != 0)
    { /* something to cancel */
d72 2
a73 4
    }
  }
  else
  {
d81 1
a81 1
  }
d85 2
a86 1
BOOL event_attachmenu(event_w w, menu m, event_menu_proc eventproc, void* handle)
d91 2
a92 1
BOOL event_attachmenumaker(event_w w, event_menu_maker menumaker, event_menu_proc eventproc, void *handle)
d106 1
a106 1
static BOOL event__recreation;
d112 1
a112 2
  if (e->e == wimp_ESEND && e->data.msg.hdr.action == wimp_MMENUWARN)
  {
d119 1
a119 1
  }
d122 1
a122 2
  if (e->e == wimp_EBUT && (wimp_BMID & e->data.but.m.bbits) != 0)
  {
d127 1
a127 2
    if (p != 0)
    {
d132 1
a132 2
      if (p->m != 0)
      {
d134 1
a134 3
      }
      else if (p->maker != 0)
      {
d136 1
d140 1
a140 3
      }
      else
      {
d142 2
a143 3
      }
      if (event__current_menu_window == win_ICONBAR)
      {
d153 3
a155 3
          }
        }
      }
d160 2
a161 4
    }
  }
  else if (e->e == wimp_EMENU && event__current_menu != 0)
  {
d164 1
a164 2
    if (p == 0)
    {
d167 1
a167 3
    }
    else
    {
d170 1
a170 1
      for (i = 0; e->data.menu[i] != -1; i++) {a[i] = 1 + e->data.menu[i];}
d175 2
a176 2
    }
  }
d192 1
a192 1

d194 1
a194 2
  if (win_processevent(e))
  {
d196 1
a196 3
  }
  else if (e->e == wimp_ENULL)
  {
d199 1
a199 3
  }
  else if (e->e == wimp_EOPEN)
  {
d202 2
a203 2
  }

d209 1
a209 2
  if (event__last_was_menu_hit && wimpt_last_event()->e == wimp_EMENU)
  {
d213 1
a213 2
    if (0 != (wimp_BRIGHT & m.bbits))
    {
d216 1
a216 2
      if (p != 0)
      {
d220 1
a220 2
        if (p->m != 0)
        {
d226 1
a226 3
        }
        else
        {
d228 1
a228 1
        }
d230 3
a232 3
      }
    }
  }
d241 1
a241 1
  if (win_activeno() == 0) exit(0); /* stop program */
d246 1
a246 1
  }
d262 1
a262 1
 return event__recreation;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.5;
access;
symbols
	RISC_OSLib-5_97:4.5
	RISC_OSLib-5_96:4.5
	RISC_OSLib-5_95:4.5
	RISC_OSLib-5_94:4.5
	RISC_OSLib-5_93:4.5
	RISC_OSLib-5_92:4.5
	RISC_OSLib-5_91:4.5
	RISC_OSLib-5_90:4.5
	RISC_OSLib-5_89:4.5
	RISC_OSLib-5_88:4.5
	RISC_OSLib-5_87:4.5
	RISC_OSLib-5_86-1:4.5
	RISC_OSLib-5_86:4.5
	RISC_OSLib-5_85:4.5
	RISC_OSLib-5_84:4.4
	RISC_OSLib-5_83-2:4.4
	RISC_OSLib-5_83-1:4.4
	RISC_OSLib-5_83:4.4
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.2
	RISC_OSLib-5_77:4.2
	RISC_OSLib-5_76:4.2
	RISC_OSLib-5_75:4.2
	RISC_OSLib-5_74:4.2
	RISC_OSLib-5_73:4.2
	RISC_OSLib-5_72:4.2
	RISC_OSLib-5_71:4.2
	RISC_OSLib-5_70:4.2
	RISC_OSLib-5_69:4.2
	RISC_OSLib-5_68:4.2
	RISC_OSLib-5_67:4.2
	RISC_OSLib-5_66:4.2
	RISC_OSLib-5_65:4.2
	RISC_OSLib-5_64:4.2
	RISC_OSLib-5_63:4.2
	RISC_OSLib-5_62:4.2
	RISC_OSLib-5_61:4.2
	RISC_OSLib-5_60:4.2
	RISC_OSLib-5_59:4.2
	RISC_OSLib-5_58:4.2
	RISC_OSLib-5_57:4.2
	RISC_OSLib-5_56:4.2
	RISC_OSLib-5_55:4.2
	RISC_OSLib-5_54:4.2
	RISC_OSLib-5_53:4.1
	RISC_OSLib-5_52:4.1
	RISC_OSLib-5_51:4.1
	RO_5_07:4.1
	RISC_OSLib-5_50:4.1
	RISC_OSLib-5_49:4.1
	RISC_OSLib-5_46-4_64_2_1:4.1
	NoInlineAsm:4.1.0.16
	RISC_OSLib-5_48:4.1
	RISC_OSLib-5_47:4.1
	RISC_OSLib-5_46:4.1
	RISC_OSLib-5_45:4.1
	RISC_OSLib-5_44:4.1
	RISC_OSLib-5_43:4.1
	RISC_OSLib-5_42:4.1
	RISC_OSLib-5_41:4.1
	RISC_OSLib-5_40:4.1
	RISC_OSLib-5_39:4.1
	RISC_OSLib-5_38:4.1
	RISC_OSLib-5_37:4.1
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2015.04.03.20.40.01;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	G8BXIPKUyzCGAbgy;

4.4
date	2014.07.31.08.24.09;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	jfGiiZxupMtuqvKx;

4.3
date	2013.10.24.20.03.55;	author rsprowson;	state Exp;
branches;
next	4.2;
commitid	8snV0tcFxVQyiAax;

4.2
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.17;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.25.17;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.20;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.31.36;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.50.03;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Switch from ArcEdit style model to clipboard cut & paste model
The txt library part of RISC_OSLib was essentially contrary to everything Acorn was telling its developers, to use the global clipboard.
Additionally, support is added for swap case within a selection.
txt.h:
 Add a new charoption type 'txt_READONLY' to inform txt that the buffer is notionally read only, this is used to supress 'Paste' in the selection menu when appropriate.
 Correct some typos in the comments.
txt1.h:
 Kill off modula 2 dummy structure member.
txtar.h:
 Remove unused function export.
txtfile.h:
 Rename basicimport to be consistent with the text version of the same function. We use 'import' to denote RAM transfers and 'insert' to denote file/scrap transfers throughout.
txtmisc.h:
 Redundant internal functions removed.
txtundo.h:
 Add a new undo operation type 't' for swap case, to avoid polluting the undo buffer with an entire copy of the text where only the case changed.
 Kill off modula 2 double pointer requirement.
txtedit.h:
 Unused structure member 'selectctl' removed.
txt.c:
 Kill off modula 2 double pointer requirement.
txtar.c:
 Refactor message despatch with a switch statement so the save/load/open operations are explicitly checked for, in case the application enables other messages.
txtedit.c:
 Adopt MOVERWRITE, been enabled since 1988 so is probably good to keep.
 Dynamically generate the Select menu by first sending a clipboard request, and fading Paste if no reply comes back.
 Implement changed mouse selection logic.
 Implement different hotkeys and caret navigation.
 Implement copy and paste/replace operations.
 Implement swap case operation.
txtfile.c:
 Type corrections and function rename admin.
 Implement copy and paste/replace operation for detokenised BASIC.
txtmisc.c:
 Supporting functions for clipboard added, supporting functions for ArcEdit removed.
txtscrap.c:
 Make sure the caret is visible for programmatical zero sized selections.
txtundo.c:
 Allow suspension of undo during known complex operations, such as import via RAM transmit. This was a longstanding bug where the import buffer was grabbed in ~4k chunks (even if only 1 byte was being transferred) which in turn resulted in a +4000 undo insertion and a -3999 removal, which given the default undo buffer is only 5k would result in it failing the reversibility test, so no undo was possible.
 Now, during a RAM transmit undo is suspended until the total transfer size is known, and only that data is placed in the undo buffer (subject to the same 5k reversibility limit).
 Add new undo type 't' for swap case operation.
rlibdata.s:
 4 new ints and 1 new BOOL, so RlibSpace increases by 5.

Version 5.85. Tagged as 'RISC_OSLib-5_85'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Title: c.txtundo
 * Purpose: Undo facilities for text objects
 * Author: W. Stoye
 * Status: system-independent
 * History:
 *   13-Oct-87: started
 *   02-Mar-88: WRS: implicit txtundo_init on any change to txt object.
 *   08-Mar-88: WRS: txtundo_commit added.
 *   14-Mar-88: WRS: undoing of selection added.
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "flex.h"
#include "trace.h"
#include "txt.h"
#include "EditIntern/txtundo.h"
#include "EditIntern/txt1.h"
#include "txtscrap.h"
#include "werr.h"

typedef struct txtundo__state {
  char *buf;
  int size;
  int head;       /* in [0..size-1] */
  int tail;       /* in [0..size-1], head==tail ? empty. */
  int ptr;        /* current pointer for undo/redo */
  BOOL withinundo;
  BOOL suspended;
} txtundo__state;
/*
  head==tail -> empty
  head -> first free for insertion
  tail -> last interesting byte
  ptr -> last thing ungot, so Undo starts with DEC(ptr)
*/

#define INITIAL_BUF_SIZE 20

/* -------- Debugging info -------- */

/* Can be omitted on "production" versions of things. */
#if TRACE

void txtundo__safewrch(char c)
{
  if (c == '*') tracef0(" *");
  else if (c >= 32 && c < 127) tracef1(":%c", c);
  else tracef1("%.2x", c);
}

void txtundo__tab(int by)
{
  int i;
  for (i=1; i<=by; i++) tracef0(" ");
}

void txtundo_pr(txtundo u)
{
  int i;
  tracef("Undo buffer:\n");
  if (u->size > 300)
    tracef(">>>>size=%i head=%i tail=%i ptr=%i\n",
      u->size, u->head, u->tail, u->ptr);
  else {
    /* zap the gap chars to make things clearer */
    if (u->tail > u->head) {
      for (i=u->head; i<=u->tail-1; i++) u->buf[i] = '*';
    } else if (u->tail <= u->head) {
      for (i=u->head; i<=u->size-1; i++) u->buf[i] = '*';
      for (i=0; i<u->tail; i++) u->buf[i] = '*';
    };
    tracef("   [");
    for (i=0; i<u->size; i++) txtundo__safewrch(u->buf[i]);
    tracef("]\n");
    txtundo__tab(2*u->head); tracef("head^^ (%i)\n", u->head);
    txtundo__tab(2*u->tail); tracef("tail^^ (%i)\n", u->tail);
    txtundo__tab(2*u->ptr); tracef(" ptr^^ (%i)\n", u->ptr);
  };
}
#endif
/* -------- Creation, Deletion -------- */

txtundo txtundo_new(void)
{
  txtundo u;
  u = malloc(sizeof(txtundo__state));
  if (u == 0) return 0;
  if (flex_alloc((void**) &(u->buf), INITIAL_BUF_SIZE) == 0) {
    free(u);
    return 0;
  };
  u->head = 0;
  u->tail = 0;
  u->size = INITIAL_BUF_SIZE;
  u->ptr = 0;
  u->withinundo = FALSE;
  u->suspended = FALSE;
  return u;
}

void txtundo_dispose(txtundo u)
{
  flex_free((flex_ptr) &u->buf);
  free(u);
}

void txtundo_setbufsize(txt t, int nbytes)
{
  txtundo u = t->undostate;
  int by;
  if (nbytes <= u->size) {
    by = 0;
  } else {
    by = nbytes - u->size;
  };
  if (flex_midextend((void**) &(u->buf), u->head, by)) {
    if (u->tail >= u->head) {u->tail += by;};
    if (u->ptr >= u->head) {u->ptr += by;};
    u->head += by;
    u->size += by;
  } else {
    /* he can't have the store, but it doesn't matter. */
    tracef0("Undo setbufsize didn't work.\n");
  };
}

void txtundo_purge_undo(txt t)
{
  /* very easy, just empty the buffer. */
  txtundo u = t->undostate;
  u->head = 0;
  u->tail = 0;
  u->ptr = 0; /* 20-Dec-88 WRS: otherwise, a following ReDo will get confused... */
}

BOOL txtundo_suspend_undo(txt t, BOOL newstate)
{
  BOOL oldstate;
  oldstate = t->undostate->suspended;
  t->undostate->suspended = newstate;
  return oldstate;
}

/* -------- Put operations. -------- */

void txtundo_putcode(txtundo u, char code)
{
  if (u->suspended) return;
  u->buf[u->head++] = code;
  if (u->head == u->size) u->head = 0;
  if (u->head == u->tail) {
    u->tail++;
    if (u->tail == u->size) u->tail = 0;
  };
  if (! u->withinundo) {
    /* If this update is generated outside an undo context then
    cancel any current chain of undos. */
    u->ptr = u->head;
  };
}

static int min(int a, int b) {return a < b ? a : b;}

void txtundo_putbytes(txtundo u, char* bytes, int n)
{
  int blocksize;
  if (u->suspended) return;
  if (n >= u->size) {
    /* We'll never be able to undo this, so forget it. */
    tracef1("Undo %i chars impossible, clearing.\n", n);
    u->head = 0;
    u->tail = 0;
  } else {
    while (1) {
      if (n == 0) break;
      blocksize = min(n, u->size - u->head);
      tracef1("Undo putbytes %i.\n", blocksize);
      (void) memcpy(/*to*/ &u->buf[u->head], /*from*/ bytes, blocksize);
      n -= blocksize;
      bytes += blocksize;
      if (u->tail >= u->head && u->tail <= u->head + blocksize) {
        u->tail = u->head + blocksize + 1;
        if (u->tail == u->size) u->tail = 0;
        if (u->tail == u->size + 1) u->tail = 1;
      };
      u->head += blocksize;
      if (u->head == u->size) {
        u->head = 0;
        if (u->tail == 0) u->tail = 1;
      };
    };
  };
}

void txtundo_putnumber(txtundo u, int n)
{
/* Chars will be picked up LS byte first, each byte contributing 7 bits, with
all but the last one having top bit set. */
  if (u->suspended) return;
  tracef1("undo putnumber %i.\n", n);
  txtundo_putcode(u, n % 128);
  while (1) {
    n = n / 128;
    if (n == 0) break;
    txtundo_putcode(u, 128 + n % 128);
  };
}

static char txtundo__charbefore(txtundo u, int p)
{
  if (p == 0) {
    return u->buf[u->size - 1];
  } else {
    return u->buf[p-1];
  };
}

void txtundo_separate_major_edits(txt t)
{
  txtundo u = t->undostate;
  if (u->suspended) return;
  if (u->head != u->tail && txtundo__charbefore(u, u->head) == 's') {
    /* already separated */
    tracef0("undo sepmajoredits, already separated.\n");
  } else {
    tracef0("undo sepmajoredits.\n");
    txtundo_putcode(u, 's');
  };
}

/* -------- Extract operations. -------- */

static int txtundo__count_ptr_to_tail(txtundo u)
/* e.g. bytes still extractable.
   Extraction happens below the poitner, e.g. starts at head.
   ptr==tail->nothing left.
*/
{
  if (u->ptr >= u->tail) {
    return u->ptr - u->tail;
  } else {
    return u->ptr + (u->size - u->tail);
  };
}

static int txtundo__count_ptr_to_head(txtundo u)
/* How much could be inserted with ptr remaining valid? Add 1 to this
because the buffer always clears one char ahead. */
{
  if (u->head < u->ptr) {
    return u->ptr - u->head;
  } else {
    return u->ptr + (u->size - u->head);
  };
}

static int txtundo__extractch(txtundo u, char *c /*out*/)
{
  if (u->ptr == u->tail) return 0;
  if (u->ptr == 0) u->ptr = u->size;
  *c = u->buf[--u->ptr];
  tracef2("Undo extract char %i from %i.\n", *c, u->ptr);
  return 1;
}

static int txtundo__extractnum(txtundo u, int *c /*out*/)
{
  char ch;
  *c = 0;
  while (1) {
    if (txtundo__extractch(u, &ch)) {
      if (ch < 128) {
        *c = *c * 128 + ch;
        return 1;
      } else {
        *c = *c * 128 + ch - 128;
      };
    } else {
      return 0;
    };
  };
}

static void txtundo__extractchars(txtundo u, int n, txt t)
/* There definitely are enough. Insert them into the Text. */
{
  int blocksize;
  int saven = n;
  int savehead = u->head;

  tracef1("Undo extractchars n=%i.\n", n);
  if (n == 0 || u->ptr == u->tail) return;
  while (n > 0) {
    if (u->ptr == 0) u->ptr = u->size;
    blocksize = u->ptr;
    if (u->tail < u->ptr) blocksize = u->ptr - u->tail;
    if (blocksize > n) blocksize = n;
    u->ptr -= blocksize;
    n -= blocksize;
    tracef2("undo reinserts %i chars from %i.\n",
      blocksize, u->ptr);
    txt_replacechars(t, 0, &(u->buf[u->ptr]), blocksize);
      /* This will recursively call back and adjust u-> */
    u->head = savehead;
  };
  txtundo_putnumber(u, saven);
  txtundo_putcode(u, 'd');
}
/* The savehead/saven business is in case we go round twice, to prevent this
one simple edit from becoming two and so gently swallowing more of the
undeletion buffer. the head=savehead is in the loop to prevent event to two
delete operations from piling up. */

/* -------- Undo operations. -------- */

void txtundo_init(txt t)
{
  txtundo u = t->undostate;
  u->ptr = u->head;
}

void txtundo_commit(txt t)
{
  txtundo u = t->undostate;
  u->head = u->ptr;
}

txtundo_result txtundo_undo(txt t)
{
  txtundo u = t->undostate;
  char code;
  int n;
  int saveptr = u->ptr;
  txtundo_result result;

  if (txtundo__extractch(u, &code) == 0) return txtundo_RANOUT;
  u->withinundo = TRUE;
  switch (code) {
  case 's':
    result = txtundo_MAJOR;
    break;
  case 't':
    result = txtundo_MINOR;
    if (txtscrap_selectowner() != NULL) {
      extern void txtedit_swapcase(txt); /* Not in public headers */
      txtedit_swapcase(t);
    }
    break;
  case 'm':
    if (txtundo__extractnum(u, &n) && txtundo__count_ptr_to_head(u) >= 5) {
      txt_setdot(t, n);
      result = txtundo_MINOR;
    } else {
      u->ptr = saveptr;
      result = txtundo_RANOUT;
    };
    break;
  case 'd':
    if (txtundo__extractnum(u, &n) && txtundo__count_ptr_to_head(u) >= 5+n) {
      txt_delete(t, n);
      result = txtundo_MINOR;
    } else {
      u->ptr = saveptr;
      result = txtundo_RANOUT;
    };
    break;
  case 'i':
    if (txtundo__extractnum(u, &n)
      && txtundo__count_ptr_to_tail(u) >= n
      && txtundo__count_ptr_to_head(u) >= 5+2*n)
      /* e.g. can extract them, and insertion will still be reversable. */
    {
      txtundo__extractchars(u, n, t);
      result = txtundo_MINOR;
    } else {
      u->ptr = saveptr;
      result = txtundo_RANOUT;
    };
    break;
  case 'l':
    { int n1;
      if (txtundo__extractnum(u, &n) && txtundo__extractnum(u, &n1)) {
        txtscrap_setselect(t, n, n1);
        result = txtundo_MINOR;
      } else {
        u->ptr = saveptr;
        result = txtundo_RANOUT;
      };
    };
    break;
  default:
    tracef1("Undo found a %i char.\n", code);
    u->ptr = saveptr;
    result = txtundo_RANOUT;
    break;
  };
  u->withinundo = FALSE;
  return result;
}

/* -------- Redo operations. -------- */

static int txtundo__skipop(txtundo u, int p)
/* Skip past a complete recorded operation. */
{
  int saveptr;
  char code;
  int result;
  int n;

  saveptr = u->ptr;
  u->ptr = p;
  if (txtundo__extractch(u, &code) == 0) {
    tracef0("Undo bug 1.\n");
  };
  switch (code) {
  case 's':
  case 't':
    break;
  case 'd':
    if (txtundo__extractnum(u, &n) == 0) tracef0("Undo bug 2.\n");
    break;
  case 'm':
    if (txtundo__extractnum(u, &n) == 0) tracef0("Undo bug 3.\n");
    break;
  case 'i':
    if (txtundo__extractnum(u, &n) == 0) tracef0("Undo bug 4.\n");
    if (u->ptr < n) {
      u->ptr = u->size + u->ptr - n;
    } else {
      u->ptr -= n;
    };
    break;
  case 'l':
    if (txtundo__extractnum(u, &n) == 0) tracef0("undo bug 5.\n");
    if (txtundo__extractnum(u, &n) == 0) tracef0("undo bug 6.\n");
    break;
  default:
    tracef0("Undo bug 5.\n");
  }
  result = u->ptr;
  u->ptr = saveptr;
  return result;
}

static int txtundo__skip_to_previous(txtundo u, int p, int *onebeforethat /*out*/)
{
  int p1;
  int p2;
  p1 = u->head;
  p2 = u->head;
  *onebeforethat = u->head;
  while (p1 != p) {
    *onebeforethat = p2;
    p2 = p1;
    p1 = txtundo__skipop(u, p1);
  }
  return p2;
}

txtundo_result txtundo_redo(txt t)
{
  txtundo u = t->undostate;
  int prev;
  int onebeforethat;
  txtundo_result res;

  if (u->ptr == u->head) return txtundo_RANOUT;
  u->withinundo = TRUE;
  u->ptr = txtundo__skip_to_previous(u, u->ptr, &onebeforethat);
  tracef2("Redo prev=%i before that=%i.\n", u->ptr, onebeforethat);
  prev = u->ptr;
  if (txtundo__charbefore(u, u->ptr) == 's') {
    /* undo a separator: no problem, done. */
  } else {
    u->ptr = u->head;
    res = txtundo_undo(t);
    u->head = u->ptr;
    u->ptr = prev;
  };
  if (onebeforethat == u->head) {
    res = txtundo_RANOUT;
  } else if (txtundo__charbefore(u, onebeforethat) == 's') {
    res = txtundo_MAJOR;
  } else {
    res = txtundo_MINOR;
  };
  u->withinundo = FALSE;
  return res;
}

/* end */
@


4.4
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@d49 1
d118 1
d122 1
a122 1
void txtundo_dispose(txtundo *u)
d124 2
a125 3
/* The extra * is for M2-compatibility: it will change. */
  flex_free((flex_ptr) &((*u)->buf));
  free(*u);
d148 1
a148 1
void txtundo_prevent_undo(txt t)
d157 8
d169 1
d188 1
d220 1
d242 1
d363 7
d439 1
@


4.3
log
@Some library fixes
Fix for problem passing long command lines via system(), while there are good arguments to leave the threshold at 255, non DDEUtils aware programs get brutally truncated command strings, and since the old threshold of 255 applied when the kernel handled 256 command lines, upping the limit to 1k is no worse than before.
Fix for Edit failing to draw lines of text longer than 192 characters (ticket #350). Several factors were conspiring here: on a mode change the window width in characters wasn't being clamped, whereas user entered limits in the menu were, then the internal buffer ("PAINTBUFSIZE") was too short so lines got truncated, and when larger than 256 got wrapped modulo 256 due to the use of an array of chars. Now set at compile time with BIG_WINDOW_SIZE_LIMIT with a new theoretical maximum of 8192. Currently limited to 480 since it uses stack variables.

In the C library:
 armsys.c: adapt the threshold at which to use DDEUtils based on the kernel version number
 scanf.c: squash a warning
 time.c: mark the table of month lengths as constant so we can claw back 13 words of static workspace without having to change the stubs

In RISC OS lib:
 bbc.c: remove local definitions of some SWI numbers
 template.c: squash a warning
 txt.c: delete Modula-2 support
 txt1.c: compare pointer with NULL not an integer
 txtar.c: introduce BIG_WINDOW_SIZE_LIMIT, rationalise a few sprintf's, mark private functions as static
 txtundo.c/txtedit.c: squash old style function warnings
 txtoptmenu.c: clamp the window width read from Edit$Options properly, delete long disabled code
 txtscrap.c: dead function deleted


Version 5.78. Tagged as 'RISC_OSLib-5_78'
@
text
@d123 1
a123 1
  flex_free((void**) &((*u)->buf));
@


4.2
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d103 1
a103 1
txtundo txtundo_new()
@


4.1
log
@Initial revision
@
text
@d34 7
a40 7
#include "h.flex"
#include "h.trace"
#include "h.txt"
#include "h.EditIntern.txtundo"
#include "h.EditIntern.txt1"
#include "h.txtscrap"
#include "h.werr"
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

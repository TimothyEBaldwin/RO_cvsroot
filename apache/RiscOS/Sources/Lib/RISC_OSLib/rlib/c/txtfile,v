head	4.8;
access;
symbols
	RISC_OSLib-5_97:4.8
	RISC_OSLib-5_96:4.8
	RISC_OSLib-5_95:4.8
	RISC_OSLib-5_94:4.8
	RISC_OSLib-5_93:4.8
	RISC_OSLib-5_92:4.8
	RISC_OSLib-5_91:4.8
	RISC_OSLib-5_90:4.8
	RISC_OSLib-5_89:4.8
	RISC_OSLib-5_88:4.8
	RISC_OSLib-5_87:4.8
	RISC_OSLib-5_86-1:4.8
	RISC_OSLib-5_86:4.8
	RISC_OSLib-5_85:4.8
	RISC_OSLib-5_84:4.6
	RISC_OSLib-5_83-2:4.6
	RISC_OSLib-5_83-1:4.6
	RISC_OSLib-5_83:4.6
	RISC_OSLib-5_82:4.5
	RISC_OSLib-5_81:4.5
	RISC_OSLib-5_75-2:4.5
	RISC_OSLib-5_80:4.5
	RISC_OSLib-5_79:4.5
	RISC_OSLib-5_78:4.5
	RISC_OSLib-5_75-1:4.5
	RISC_OSLib-5_77:4.5
	RISC_OSLib-5_76:4.5
	RISC_OSLib-5_75:4.5
	RISC_OSLib-5_74:4.5
	RISC_OSLib-5_73:4.5
	RISC_OSLib-5_72:4.5
	RISC_OSLib-5_71:4.5
	RISC_OSLib-5_70:4.5
	RISC_OSLib-5_69:4.5
	RISC_OSLib-5_68:4.5
	RISC_OSLib-5_67:4.5
	RISC_OSLib-5_66:4.5
	RISC_OSLib-5_65:4.5
	RISC_OSLib-5_64:4.5
	RISC_OSLib-5_63:4.5
	RISC_OSLib-5_62:4.5
	RISC_OSLib-5_61:4.5
	RISC_OSLib-5_60:4.5
	RISC_OSLib-5_59:4.5
	RISC_OSLib-5_58:4.5
	RISC_OSLib-5_57:4.5
	RISC_OSLib-5_56:4.5
	RISC_OSLib-5_55:4.5
	RISC_OSLib-5_54:4.5
	RISC_OSLib-5_53:4.4
	RISC_OSLib-5_52:4.4
	RISC_OSLib-5_51:4.4
	RO_5_07:4.4
	RISC_OSLib-5_50:4.4
	RISC_OSLib-5_49:4.4
	RISC_OSLib-5_46-4_64_2_1:4.3
	NoInlineAsm:4.3.0.2
	RISC_OSLib-5_48:4.3
	RISC_OSLib-5_47:4.3
	RISC_OSLib-5_46:4.3
	RISC_OSLib-5_45:4.3
	RISC_OSLib-5_44:4.2
	RISC_OSLib-5_43:4.1
	RISC_OSLib-5_42:4.1
	RISC_OSLib-5_41:4.1
	RISC_OSLib-5_40:4.1
	RISC_OSLib-5_39:4.1
	RISC_OSLib-5_38:4.1
	RISC_OSLib-5_37:4.1
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2015.04.03.22.43.46;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	4ZOxMlETYoK3gcgy;

4.7
date	2015.04.03.20.40.01;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	G8BXIPKUyzCGAbgy;

4.6
date	2014.07.31.08.24.09;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	jfGiiZxupMtuqvKx;

4.5
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.4;

4.4
date	2004.01.23.19.10.22;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2003.01.16.12.43.31;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2002.11.15.15.00.32;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.15;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.25.15;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.12;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.31.18;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.55;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Clean up pass
Trim any #if FALSE switches over a decade old, and keep #if TRUE.
Accept EDIT2 and FMTTEXT1 bracketed code.
Remove unused internal functions txt1_dooaction txt1_dosetoaction.
Retagged as RISC_OSLib-5_85.
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
  Purpose: File load and save operations for Text objects
  Author: WRS
  Status: under development
  History:
    18 August 87: started
    14/1/1988 converted to 'C'. AFP.
    22/03/88: igj: uses os_file to load/save objects
 *  13-Dec-89: WRS: msgs literal text put back in.
     7-Mar-91: PJC: support for BASIC files added
    27-Jun-91: IDJ: removed special case of zero length files, to force access rights checking
    10-Jul-91: IDJ/PJC: fixed bug in BASIC file saving
    19-Jul-91: IDJ: fix to guard against stack extension moving flex blocks
    31-Jul-91: PJC: more BASIC bug-fixes
*/

#define BOOL int
#define TRUE 1
#define FALSE 0

#define BASIC 1

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include "os.h"
#include "txt.h"
#include "typdat.h"

#if BASIC
#include "flex.h"
#include "swis.h"
#include "wimpt.h"
#include "txt.h"
#include "EditIntern/txtundo.h"
#include "EditIntern/txt1.h"
#include "txtedit.h"
#include "txtscrap.h"
#include "xfersend.h"
#include "xferrecv.h"
#endif

#include "EditIntern/txtfile.h"
#include "trace.h"
#include "werr.h"
#include "msgs.h"
#include "visdelay.h"
#include "VerIntern/messages.h"

void txtfile_buildnewtimestamp(typdat oldty, typdat *newty)
/* restamp the file with a current time/date stamp */

{
int block[2];
/* ignore call if untyped, thus preserving Load/Exec addresses */
if (((unsigned int)oldty.ld >> 20) >= 0xfff) /* it's got a type ! */
{
    block[0] = 3;
    os_word(14, &block);
    newty->ld = ((unsigned int) oldty.ld & 0xffffff00) + (block[1] & 0xff);
    newty->ex = block[0];
}
else
{
    newty->ld = oldty.ld;
    newty->ex = oldty.ex;
}
}


BOOL txtfile_insert(txt t, char *filename, int l, typdat *ty)
/* The insert operation works in two phases. First, find out the size of the
file and insert that much junk into it. Then, actually read the contents of
the file directly into the text object memory. It is important to take this
approach to reduce memory fragmentation when inserting very large files,
otherwise several extensions may be made to the object which significantly
zap store. */
/* Obviously, this has to happen with display turned off or the junk would
significantly mess things up... */
/* Where can one be sure to find a large supply of junk? We guess at our own
code, not necessarily good if some of the machine's memory is not readable...
*/

{

int n;
BOOL result = TRUE;
BOOL wasupdated = (txt_UPDATED & txt_charoptions(t)) != 0;
txt_index at;
char *a;
int size;
os_error *er;
os_filestr file;

if (l < 0) {

  file.action = 5;
  file.name = filename;

  er = os_file(&file);
  tracef0("the os_file 5 returned.\n");
  if (er != 0) { /* read info on pathname */
      werr(FALSE, er->errmess);
      return(0);
  };

  if (file.action != 1) { /* Did we find a file ? */
      werr(FALSE, msgs_lookup(MSGS_txt51), filename);
      return(0);
  };

  l = file.start;
};

/*if (l != 0)   IDJ: 27-Jun-91: removed this check to force load to be tried */
{
    txt_setcharoptions(t, txt_DISPLAY, 0);
    visdelay_begin();

    size = txt_size(t);

    /* 24-Oct-02 KJB: txt_replacechars now accepts a null pointer, and treats
    it as a request to insert the appropriate number of spaces */
    txt_replacechars(t, 0, NULL, l);

    if (l + size != txt_size(t)) {
      /* There isn't enough room. He will already have received an error
      message. Delete whatever rubbish we were able to insert, and return
      FALSE. */
      txt_delete(t, txt_size(t) - size);
      visdelay_end();
      txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY);
      if (! wasupdated) txt_setcharoptions(t, txt_UPDATED, 0);
      return FALSE;
    };
    at = txt_dot(t);
    txt_arrayseg(t, at, &a, &n);
    file.action = 0xff;  /* load named file */
    file.name = filename;
    file.loadaddr = (int) &a[0];
    file.execaddr = 0;

    er = os_file(&file);
    if (er != 0) { /* load into buffer */
        werr(FALSE, er->errmess);
        txt_delete(t, txt_size(t) - size);
        if (! wasupdated) txt_setcharoptions(t, txt_UPDATED, 0);
        result = FALSE;
    } else {
        ty->ld = file.loadaddr;  /* return type to client */
        ty->ex = file.execaddr;
    };

    visdelay_end();
    txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY);
};

return(result);
/* >>>> If it didn't work, how do I get an error message out? */

}



int txtfile_saverange(txt t, char *filename, typdat ty,
                      txt_index from, txt_index to)
/* This is much simpler than insert, we save the file */

{

int n, result, oldattribs = -1;
char *a;
os_filestr file;
txt_index wasat;
os_error *er;

if (to < 0) to = INT_MAX; /* >>>> M2 compatibility fudge! */

tracef2("From = %d  To = %d\n", (int)from, (int)to);

txt_setcharoptions(t, txt_DISPLAY, 0);
wasat = txt_dot(t);
txt_setdot(t, from);
txt_arrayseg(t, from, &a, &n);

if (to < from)
    result = TRUE;
else
{
    if (n > to - from)
        n = to - from;

    file.action = 17; /* Read cat info */
    file.name = filename;
    (void) os_file(&file);
    /* if something is already there,remember its attributes */
    if (file.action != 0) oldattribs = file.end;

    file.action = 0;  /* Save */
    file.loadaddr = ty.ld;
    file.execaddr = ty.ex;
    file.start = (int) &a[0];
    file.end = (int) &a[n];
    er = os_file(&file);
    if (er != 0) {
      werr(FALSE, er->errmess);
    };

    if (oldattribs != -1) {
      file.action = 4; /* Write attribs */
      file.end = oldattribs;
      (void) os_file(&file);
    };

    result = er == 0;
}

txt_setdot(t, wasat);
txt_setdisplayok(t);
return(result);

}

#if BASIC

extern void bastxt_detokenise(int output_buffer, int input_address, int *flag, int *detokeniser);
extern void bastxt_tokenise(char **output_buffer, char **input_buffer, int *line_number, int *tokeniser, int increment);

static char *sender_anchor;
static char *receiver_anchor;
static int   receiver_size;

static BOOL txtfile__basicimportdata(txt t, char **anchor, int input_size, int detok_addr, BOOL strip)
{
  BOOL result = TRUE;
  BOOL wasupdated = ((txt_UPDATED & txt_charoptions(t)) != 0);
  int size = input_size * 2;
  int in = 0;
  int out = 0;
  int c = 0;
  int d = 0;
  char *buff = NULL;
  char *previous_address = NULL;

  /* strategy is:

     1) flex a detok buffer that is 200% the size of the tokenised data
     2) detokenise a line into the detok buffer.
     3) if the line contained a line number reference, then if the user
        wants to try again with line numbers, restart at (2).
     4) loop to (2) until the end of the program has been reached.
     5) insert the detok buffer into the txt, watching for shifting
        anchors.

  */

  if (flex_alloc((flex_ptr)&buff, size)) {
    out = 0;
    in = 1; /* start at 1 to skip the initial CR */
    c = -1;

    visdelay_begin();
    while (c != 0) {
      c = strip;
      d = detok_addr;
      bastxt_detokenise((int)buff + out, (int)*anchor + in, &c, &d);
      if (c > 0) {
        /* update offsets NOW in case the blocks move ! */
        in = c - (int)*anchor;
        out = d - (int)buff - 1;
        if (out > size) {
          werr(0, msgs_lookup(MSGS_bas8), out - size);
        }
      }
      if (c == -1) {
        /* amg 30th August 1994, change err to be an os_error instead of   */
        /* a char[] - makes setting the error number tidier (it never used */
        /* to bother!                                                      */

        os_error err;

        /* line number reference found */
        visdelay_end();
        sprintf(err.errmess, msgs_lookup(MSGS_bas2));
        err.errnum = 0;
        os_swi3r(Wimp_ReportError, (int)&err, 3, (int)wimpt_programname(), NULL, &c, NULL);
        visdelay_begin();

        if (c == 1) {
          strip = FALSE;
          in = 1;
          out = 0;
        } else {
          c = 0; /* already deleted the insertions, so let's just exit */
          result = FALSE;
        }
      }
    }
    if (result) {
      txt_setcharoptions(t, txt_DISPLAY, 0);
      previous_address = buff;
      size = txt_size(t);
      txt_replacechars(t, 0, buff, out);
      if (txt_size(t) != out + size) {
        txt_delete(t, txt_size(t) - size);
        txt_setcharoptions(t, txt_UPDATED, wasupdated);
        result = FALSE;
      } else {
        if (buff != previous_address) {
          txt_replacechars(t, out, buff, out);
        }
      }
      txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY);
    }
    visdelay_end();
    flex_free((flex_ptr)&buff);
  } else {
    werr(0, msgs_lookup(MSGS_bas6));
    result = FALSE;
  }

  return(result);
}

static BOOL txtfile__basicimportbufferprocessor(char **buffer, int *size)
{
  /* this routine is called when the buffer is full,
     so copy the data into the flex buffer.
  */

  int new_size = receiver_size + *size;
  BOOL result;

  if (receiver_size == 0) {
    result = flex_alloc((flex_ptr)&receiver_anchor, *size);
  } else {
    result = flex_extend((flex_ptr)&receiver_anchor, new_size);
  }
  if (result) {
    memcpy(receiver_anchor + receiver_size, *buffer, *size);
    receiver_size = new_size;
  }
  return(result);
}

BOOL txtfile_basicimport(txtedit_state *s, BOOL insrep, int detokenise, BOOL strip)
{
  /* Plan of action is:
     1) import everything into a flex buffer
     2) detokenise and insert!
  */
  int last;
  BOOL result, undo;
  txt_index dot;
  int size, tsize;
  char *import_buffer = malloc(4096); /* do imports in 4K chunks */

  if (import_buffer == NULL) {
    werr(FALSE, msgs_lookup(MSGS_txt3));
    return(FALSE);
  }

  undo = txtundo_suspend_undo(s->t, TRUE);
  tsize = txt_size(s->t);
  dot = txt_dot(s->t);
  receiver_anchor = NULL; /* no imported data yet */
  receiver_size = 0;

  last = xferrecv_doimport(import_buffer, 4096, txtfile__basicimportbufferprocessor);
  if (last == -1) {
    result = FALSE;
  } else {
    if (txtfile__basicimportbufferprocessor(&import_buffer, &last)) {
      txtfile__basicimportdata(s->t, &receiver_anchor, receiver_size, detokenise, strip);
      result = TRUE;
    } else result = FALSE;
  }
  free(import_buffer);
  if (receiver_anchor != NULL)
    flex_free((flex_ptr)&receiver_anchor);

  if (result) {
    size = txt_size(s->t) - tsize; /* Delta */
    txt_setdot(s->t, dot);
    txtundo_suspend_undo(s->t, undo);
    txtundo_putnumber(s->t->undostate, size);
    txtundo_putcode(s->t->undostate, 'd');
    if (size == 0) {
      /* Nothing happened overall */
    } else {
      /* When insertion replaced a selection, must select the new
      insertion in its place. */
      if (insrep) {
        txtscrap_setselect(s->t, dot, dot + size);
      } else {
        txt_movedot(s->t, size);
        txt_show(s->t); /* Force a redraw so caret x/y is recalculated */
      }
    }
  }
  txtedit_settexttitle(s);
  txtundo_separate_major_edits(s->t);
  return(result);
}

BOOL txtfile_basicinsert(txt t, char *filename, int l, typdat *ty, int detokenise, BOOL strip)
{
  BOOL result = FALSE;
  os_error *er;
  os_filestr file;
  char *anchor;

  if (l > 0) {

    /* steps required are:

       1) flex enough memory to load the BASIC file in and load it.
       2) import the data
       3) when finished, release the original flex block

    */

    if (flex_alloc((flex_ptr)&anchor, l)) {
      file.action = 0xFF; /* load named file */
      file.name = filename;
      file.loadaddr = (int)anchor;
      file.execaddr = 0;

      er = os_file(&file);
      if (er != 0) {
        werr(FALSE, er->errmess);
        result = FALSE;
      } else {
        result = txtfile__basicimportdata(t, &anchor, file.start, detokenise, strip);
      }
      flex_free((flex_ptr)&anchor);
    } else {
      werr(0, msgs_lookup(MSGS_bas6));
      return(FALSE);
    }

    if (result) {
      ty->ld = file.loadaddr;  /* return type to client */
      ty->ex = file.execaddr;
    }
  }
  return(result);
}

#define tokenising_successful 0
#define tokenising_nomemory 1
#define tokenising_badlinenumbers 2

static int txtfile__basicdotokenising(txt t, txt_index from, txt_index to, int *end_ptr, int token_addr, int increment)
{
  char *a;
  char *output_buffer;
  char *input_buffer;
  int n;
  int line_number;
  int tokenise;
  int result = tokenising_successful;
  txt_index wasat;
  char *old_anchor;
  char *old_a;

  txt_setcharoptions(t, txt_DISPLAY, 0);
  wasat = txt_dot(t);
  txt_setdot(t,from);
  txt_arrayseg(t, from, &a, &n);
  if (to < from) {
    /* wacky incomprehensible test! */
    result = tokenising_successful;
  } else {
    if (n > to - from)
      n = to - from;
    n +=1;                                                  /* allow for a missing terminator */
    if (flex_alloc((flex_ptr)&sender_anchor, n)) {          /* get the buffer memory */
      int nn = 0, warning_issued = FALSE;
      char last_ch;
      line_number = 0;

      /* IDJ: fix to guard against stack extension moving flex blocks */
      txt_arrayseg(t, from, &a, &nn);
      *sender_anchor = 13;                                  /* all good BASIC programs start with CR */
      if (a[n-2] == 13 || a[n-2] == 10)                     /* if text is already terminated properly */
       n--;                                                 /* then decrement the count */
      last_ch = a[n-1];                                     /* ensure terminated by CR */
      a[n-1] = 13;                                          /* this is always done */

      visdelay_begin();

      txt_arrayseg(t, from, &input_buffer, &nn);
      output_buffer = sender_anchor + 1;
      old_a = input_buffer;
      old_anchor = sender_anchor;

      do
      {
        int sender_size, fixed_line_number, lines_flag;

        tokenise = token_addr;

        bastxt_tokenise(&output_buffer, &input_buffer, &line_number, &tokenise, increment);
        lines_flag = line_number & 0xC0000000;
        fixed_line_number = line_number & 0x3FFFFFFF;

        if (lines_flag == 0xC0000000)
        {
          if (!warning_issued)
          {
             werr(0, msgs_lookup(MSGS_basA), fixed_line_number);
             visdelay_begin();
             warning_issued = TRUE;
          }
        }
        if (tokenise & (1<<8))
        {
          werr(0, msgs_lookup(MSGS_bas3), fixed_line_number);
          visdelay_begin();
        }
        if ((tokenise & 255) == 1)
        {
          werr(0, msgs_lookup(MSGS_bas4), fixed_line_number);
          visdelay_begin();
        }
        if ((tokenise & ~255) != 0)
        {
          werr(0, msgs_lookup(MSGS_bas5), fixed_line_number);
          visdelay_begin();
        }

        /* check we've got at least 512 bytes free in the ouput
           buffer for next time around
        */
        sender_size = flex_size((flex_ptr)&sender_anchor);
        if (sender_size - (output_buffer - old_anchor) < 512)
        {
           if (flex_extend((flex_ptr)&sender_anchor, sender_size + 4096) == 0)
           {
              txt_arrayseg(t, from, &a, &nn);
              a[n-1] = last_ch;
              flex_free((flex_ptr)&sender_anchor);
              txt_setdot(t, wasat);
              txt_setdisplayok(t);
              return tokenising_nomemory;
           }
        }

        /* rationalise anchors BEFORE line number test 'cos it has a break */
        txt_arrayseg(t, from, &a, &nn);
        if (old_anchor != sender_anchor || old_a != a)
        {
           input_buffer = a + (input_buffer - old_a);
           output_buffer = sender_anchor + (output_buffer - old_anchor);
           old_a = a;
           old_anchor = sender_anchor;
        }

        if (fixed_line_number > 65279)
        {
          result = tokenising_badlinenumbers; /* failed to save correctly */
          break; /* to get us out of the while loop */
        }
      } while (input_buffer < a + n);
      a[n-1] = last_ch;
      *(output_buffer) = 255;
      *end_ptr = (output_buffer - sender_anchor + 1);
      if (result != tokenising_badlinenumbers)
        visdelay_end();
    } else {
      result = tokenising_nomemory;
    }
  }
  txt_setdot(t, wasat);
  txt_setdisplayok(t);
  return(result);
}

BOOL txtfile_basicsenderproc(txt t, int *maxbuf, txt_index from, txt_index to, int tokenise, int increment)
{
  int offset;
  int end_ptr;
  int segsize;

  switch (txtfile__basicdotokenising(t, from, to, &end_ptr, tokenise, increment))
  {
    case tokenising_successful:     offset = 0;
                                    while (offset < end_ptr)
                                    {
                                      segsize = (end_ptr - offset);
                                      if (segsize > *maxbuf) segsize = *maxbuf;
                                      if (! xfersend_sendbuf((char *)(sender_anchor + offset), segsize))
                                      {
                                        flex_free((flex_ptr)&sender_anchor);
                                        return(FALSE);
                                      }
                                      offset += segsize;
                                    }
                                    flex_free((flex_ptr)&sender_anchor);
                                    return(TRUE);
    case tokenising_nomemory:       werr(0, msgs_lookup(MSGS_bas7));
                                    break;
    case tokenising_badlinenumbers: werr(0, msgs_lookup(MSGS_bas9));
                                    flex_free((flex_ptr)&sender_anchor);
                                    break;
  }
  return(FALSE);
}

BOOL txtfile_savebasicrange(txt t, char *filename, typdat ty, txt_index from, txt_index to, int tokenise, int increment)
{
  int end_ptr;
  os_filestr file;
  os_error *er;
  BOOL result = TRUE;

  switch (txtfile__basicdotokenising(t, from, to, &end_ptr, tokenise, increment))
  {
    case tokenising_successful:     file.action = 0;
                                    file.name = filename;
                                    file.loadaddr = ty.ld;
                                    file.execaddr = ty.ex;
                                    file.start = (int)sender_anchor;
                                    file.end = (int)sender_anchor + end_ptr;
                                    er = os_file(&file);
                                    if (er != 0) {
                                      werr(FALSE, er->errmess);
                                    }
                                    result = er == 0;
                                    flex_free((flex_ptr)&sender_anchor);
                                    break;
    case tokenising_nomemory:       werr(0, msgs_lookup(MSGS_bas7));
                                    result = FALSE;
                                    break;
    case tokenising_badlinenumbers: werr(0, msgs_lookup(MSGS_bas9));
                                    flex_free((flex_ptr)&sender_anchor);
                                    result = FALSE;
                                    break;
  }
  return(result);
}

#endif
@


4.7
log
@Switch from ArcEdit style model to clipboard cut & paste model
The txt library part of RISC_OSLib was essentially contrary to everything Acorn was telling its developers, to use the global clipboard.
Additionally, support is added for swap case within a selection.
txt.h:
 Add a new charoption type 'txt_READONLY' to inform txt that the buffer is notionally read only, this is used to supress 'Paste' in the selection menu when appropriate.
 Correct some typos in the comments.
txt1.h:
 Kill off modula 2 dummy structure member.
txtar.h:
 Remove unused function export.
txtfile.h:
 Rename basicimport to be consistent with the text version of the same function. We use 'import' to denote RAM transfers and 'insert' to denote file/scrap transfers throughout.
txtmisc.h:
 Redundant internal functions removed.
txtundo.h:
 Add a new undo operation type 't' for swap case, to avoid polluting the undo buffer with an entire copy of the text where only the case changed.
 Kill off modula 2 double pointer requirement.
txtedit.h:
 Unused structure member 'selectctl' removed.
txt.c:
 Kill off modula 2 double pointer requirement.
txtar.c:
 Refactor message despatch with a switch statement so the save/load/open operations are explicitly checked for, in case the application enables other messages.
txtedit.c:
 Adopt MOVERWRITE, been enabled since 1988 so is probably good to keep.
 Dynamically generate the Select menu by first sending a clipboard request, and fading Paste if no reply comes back.
 Implement changed mouse selection logic.
 Implement different hotkeys and caret navigation.
 Implement copy and paste/replace operations.
 Implement swap case operation.
txtfile.c:
 Type corrections and function rename admin.
 Implement copy and paste/replace operation for detokenised BASIC.
txtmisc.c:
 Supporting functions for clipboard added, supporting functions for ArcEdit removed.
txtscrap.c:
 Make sure the caret is visible for programmatical zero sized selections.
txtundo.c:
 Allow suspension of undo during known complex operations, such as import via RAM transmit. This was a longstanding bug where the import buffer was grabbed in ~4k chunks (even if only 1 byte was being transferred) which in turn resulted in a +4000 undo insertion and a -3999 removal, which given the default undo buffer is only 5k would result in it failing the reversibility test, so no undo was possible.
 Now, during a RAM transmit undo is suspended until the total transfer size is known, and only that data is placed in the undo buffer (subject to the same 5k reversibility limit).
 Add new undo type 't' for swap case operation.
rlibdata.s:
 4 new ints and 1 new BOOL, so RlibSpace increases by 5.

Version 5.85. Tagged as 'RISC_OSLib-5_85'
@
text
@a136 1
#if TRUE
a139 25
#else
    /* 12-Dec-88 WRS */
    /* If there is not this much memory in the address space, this can go wrong!
    So, ask for it in smaller steps. */
    /* This is dreadful - there should be a txt_replacewith that takes a single
    char and a repeat count. */
    /* 23-Oct-89: it's still dreadful, but at least I load from the ROM now!
    So, it's actually much faster. */
    {
      int ll = l;
      int lastsize = txt_size(t);
      int thisblock;
      int nextsize;

      while (ll > 0) {
        thisblock = ll % 4000000;
        if (thisblock == 0) thisblock = 4000000;
        txt_replacechars(t, 0, (char*) 0x3800000, thisblock);
        nextsize = txt_size(t);
        if (lastsize + thisblock != nextsize) break; /* out of memory */
        lastsize = nextsize;
        ll -= thisblock;
      };
    };
#endif
a233 3
#if FALSE
txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY);
#else
a234 1
#endif
@


4.6
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@d49 1
d51 1
d53 1
d86 1
a86 1
int txtfile_insert(txt t, char *filename, int l, typdat *ty)
d118 1
a118 1
      werr(FALSE, &er->errmess[0]);
d186 1
a186 1
        werr(FALSE, &er->errmess[0]);
d189 1
a189 1
        result = 0;
d247 1
a247 1
      werr(FALSE, &er->errmess[0]);
d391 1
a391 1
BOOL txtfile_dobasicimport(txtedit_state *s, int estsize, int detokenise, BOOL strip)
d398 3
a400 1
  BOOL result;
d403 4
a406 1
  estsize = estsize;
d408 3
d414 21
a434 4
  if (import_buffer) {
    last = xferrecv_doimport(import_buffer, 4096, txtfile__basicimportbufferprocessor);
    if (last == -1) {
      result = FALSE;
d436 8
a443 4
      if (txtfile__basicimportbufferprocessor(&import_buffer, &last)) {
        txtfile__basicimportdata(s->t, &receiver_anchor, receiver_size, detokenise, strip);
        result = TRUE;
      } else result = FALSE;
a444 9
    free(import_buffer);
    if (receiver_anchor != NULL)
      flex_free((flex_ptr)&receiver_anchor);
    txtedit_settexttitle(s);
    txtundo_separate_major_edits(s->t);
    return(result);
  } else {
    werr(FALSE, msgs_lookup(MSGS_txt3));
    return(FALSE);
d446 3
d476 1
a476 1
        werr(FALSE, &er->errmess[0]);
d673 1
a673 1
                                      werr(FALSE, &er->errmess[0]);
@


4.5
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d137 1
a137 1
    txt_replacechars(t, 0, 0, l);
@


4.4
log
@<ctype.h> * isblank() added.
          * isprint() now true for non-breaking spaces
<math.h>  * FP_INFINITY corrected to FP_INFINITE
          * fma(), fmal(), llrint(), llrintf(), llrintl(),
            llround(), llroundf(), llroundl(),
            remquo(), remquof(), remquol() added.
          * added inlining for remainder() and fmaf() and various
            float functions.
          * math_errhandling removed pending overhaul - it was misleading.
          * expm1() and log1p() now provide decent (< 1 ulp) accuracy,
            rather than only being marginally better than exp(x)-1 and
            log(1+x).
          * new version of copysign() with standard calling conventions.
          * some C99 functions changed to use infinity/NaNs and exceptions
            for error handling - see comments in header file about the
            changes in progress.
<stdio.h>  * output from %a now correctly rounded
<stdlib.h> * strtof() and strtold() added.
<string.h> * strerror() no longer clears _kernel_last_oserror().

Version 5.49. Tagged as 'RISC_OSLib-5_49'
@
text
@d41 3
a43 3
#include "h.os"
#include "h.txt"
#include "h.typdat"
d46 7
a52 7
#include "h.flex"
#include "h.swis"
#include "h.wimpt"
#include "h.EditIntern.txtundo"
#include "h.txtedit"
#include "h.xfersend"
#include "h.xferrecv"
d55 6
a60 6
#include "h.EditIntern.txtfile"
#include "h.trace"
#include "h.werr"
#include "h.msgs"
#include "h.visdelay"
#include "h.verintern.messages"
d129 1
a129 1
    txt_setcharoptions(t, txt_DISPLAY, NULL);
d219 1
a219 1
txt_setcharoptions(t, txt_DISPLAY, NULL);
d342 1
a342 1
      txt_setcharoptions(t, txt_DISPLAY, NULL);
d486 1
a486 1
  txt_setcharoptions(t, txt_DISPLAY, NULL);
@


4.3
log
@  Misc changes.
Detail:
  * Improved lookup of application Sprites file: uses Wimp_Extend 13 (in
    Wimps that support it) to work out the appropriate resolution suffix,
    and prefixes with "<Wimp$IconTheme>" to allow a future Theme Manager
    to operate.
  * Preserves attributes of any existing file when saving sprite or text
    files.
  * Changed two null menu handles from 0 to (doucmented) -1. Despite the
    fact that the Wimp is actually happy with 0 as a null handle here,
    this was reported as a fault.
  * Changed rlib.c.version to use VersionNum, deleted thereby-obsoleted
    rlib.h.VerIntern.version file. Not that rlib.c.version seems to be used
    at the moment.
  * Added Kevin's additions to the test directory.
Admin:
  Tested briefly.

Version 5.44. Not tagged
@
text
@d62 1
a62 1
void txtfile_buildnewtimestamp(oldty, newty)
a64 2
typdat oldty, *newty;

d83 1
a83 1
int txtfile_insert(t, filename, l, ty)
a95 5
txt t;
char *filename;
int l;
typdat *ty;

d203 2
a204 1
int txtfile_saverange(t, filename, ty, from, to)
a206 5
txt t;
char *filename;
typdat ty;
txt_index from, to;

d230 1
a230 1
        
d246 1
a246 1
    
@


4.2
log
@ROM build fixed for 64-bit stuff.
PCI added to swis.h
alloc.c updated to handle bigger slots (new code merged from ARM libraries)
Various 32-bit fixes for backtracing, and general trap handling.
Polite "Application is not 32-bit compatible" message.
Headers <stdint.h> and <inttypes.h> fixed to work in non-C99 mode.
txt changed to do new-style Delete behaviour

Version 5.44. Tagged as 'RISC_OSLib-5_44'
@
text
@d220 1
a220 1
int n, result;
d241 2
a242 1
    file.action = 0;
d244 5
d257 7
@


4.1
log
@Initial revision
@
text
@d22 1
a22 1
    22/03/88: igj: uses os_file to load/save objects 
d27 1
a27 1
    19-Jul-91: IDJ: fix to guard against stack extension moving flex blocks 
d141 3
a143 1
#if FALSE
d315 1
a315 1
      if (c == -1) {  
d319 1
a319 1
        
d321 1
a321 1
        
d525 1
a525 1
        if (lines_flag == 0xC0000000) 
d527 1
a527 1
          if (!warning_issued) 
d534 1
a534 1
        if (tokenise & (1<<8)) 
d539 1
a539 1
        if ((tokenise & 255) == 1) 
d544 1
a544 1
        if ((tokenise & ~255) != 0) 
d577 1
a577 1
        if (fixed_line_number > 65279) 
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

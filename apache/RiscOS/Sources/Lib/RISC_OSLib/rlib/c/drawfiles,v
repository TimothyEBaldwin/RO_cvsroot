head	4.3;
access;
symbols
	RISC_OSLib-5_97:4.3
	RISC_OSLib-5_96:4.3
	RISC_OSLib-5_95:4.3
	RISC_OSLib-5_94:4.3
	RISC_OSLib-5_93:4.3
	RISC_OSLib-5_92:4.3
	RISC_OSLib-5_91:4.3
	RISC_OSLib-5_90:4.3
	RISC_OSLib-5_89:4.3
	RISC_OSLib-5_88:4.3
	RISC_OSLib-5_87:4.3
	RISC_OSLib-5_86-1:4.3
	RISC_OSLib-5_86:4.3
	RISC_OSLib-5_85:4.3
	RISC_OSLib-5_84:4.3
	RISC_OSLib-5_83-2:4.3
	RISC_OSLib-5_83-1:4.3
	RISC_OSLib-5_83:4.3
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.3
	RISC_OSLib-5_77:4.3
	RISC_OSLib-5_76:4.3
	RISC_OSLib-5_75:4.3
	RISC_OSLib-5_74:4.3
	RISC_OSLib-5_73:4.3
	RISC_OSLib-5_72:4.3
	RISC_OSLib-5_71:4.3
	RISC_OSLib-5_70:4.3
	RISC_OSLib-5_69:4.3
	RISC_OSLib-5_68:4.3
	RISC_OSLib-5_67:4.3
	RISC_OSLib-5_66:4.3
	RISC_OSLib-5_65:4.3
	RISC_OSLib-5_64:4.3
	RISC_OSLib-5_63:4.3
	RISC_OSLib-5_62:4.3
	RISC_OSLib-5_61:4.3
	RISC_OSLib-5_60:4.3
	RISC_OSLib-5_59:4.3
	RISC_OSLib-5_58:4.3
	RISC_OSLib-5_57:4.3
	RISC_OSLib-5_56:4.3
	RISC_OSLib-5_55:4.3
	RISC_OSLib-5_54:4.3
	RISC_OSLib-5_53:4.2
	RISC_OSLib-5_52:4.2
	RISC_OSLib-5_51:4.2
	RO_5_07:4.2
	RISC_OSLib-5_50:4.2
	RISC_OSLib-5_49:4.2
	RISC_OSLib-5_46-4_64_2_1:4.2
	NoInlineAsm:4.2.0.2
	RISC_OSLib-5_48:4.2
	RISC_OSLib-5_47:4.2
	RISC_OSLib-5_46:4.2
	RISC_OSLib-5_45:4.2
	RISC_OSLib-5_44:4.2
	RISC_OSLib-5_43:4.2
	RISC_OSLib-5_42:4.2
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	2009.05.31.17.58.58;	author pnaulls;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.48;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.10;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.10;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.53.37;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.30.13;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.21;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.13;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.3
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.DrawFiles
 * Purpose: utility functions used in rendering a draw objects
 * History: IDJ: 06-Feb-92: prepared for source release
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "os.h"
#include "bbc.h"
#include "sprite.h"
#include "font.h"
#include "swis.h"

#define scalefactor dr_scalefactor /* Name equivalence */
#include "DrawIntern/drawfile1.h"
#include "drawfdiag.h"
#include "DrawIntern/drawfile2.h"

/*=========================================================================*/

/* Return the address of the first path element in a path object */
/* this starts either after the path header (no dash pattern)    */
/* or after the dash pattern                                     */

path_movestr *address_pathstart(draw_objptr hdrptr)
{
  if (hdrptr.pathp->pathstyle.joincapwind & packmask_dashed)
    return (path_movestr*)
           &(hdrptr.pathp->data.dashelements[hdrptr.pathp->data.dashcount]);
  else
    return (path_movestr*)&hdrptr.pathp->data;
}


/* Return the address of the dash pattern of a path object */
/* or zero                                                 */

draw_dashstr *address_dashstart(draw_objptr hdrptr)
{
  if (hdrptr.pathp->pathstyle.joincapwind & packmask_dashed)
    return &hdrptr.pathp->data;
  else
    return 0;
}


/*=========================================================================*/
/* Code from c.drawDispl */


#define visible(A)  ((A.objhdrp->bbox.x0<=clip_x1) &&   \
                     (A.objhdrp->bbox.y0<=clip_y1) &&   \
                     (A.objhdrp->bbox.x1>=clip_x0) &&   \
                     (A.objhdrp->bbox.y1>=clip_y0)      \
                    )

/* ScaleT - for text position coords ('font_paint' takes graphics coords)  */
/* ScaleS - for sprite position coords ('put_sprite takes graphics coords) */
/* ScaleF - T.B.A                                                          */

#define scaleT(A,B) (((A)+ (int)(scalefactor*(double)(B)) ) >> 8)
#define scaleS(A,B) (((A)+ (int)(scalefactor*(double)(B)) ) >> 8)
#define scaleF(A)        ( (int)(scalefactor*(double)(A)/40) )

#pragma -s1

/* GCol(action,colour) where colour is BBGGRRxx (foreground colour) */

static os_error *displ_settruecol(int action,draw_coltyp colour)
{
  os_regset r;

  r.r[0] = colour;    /* BBGGRRxx    */
  r.r[3] = 0;         /* foreground  */
  r.r[4] = action;    /* GCol action */

  return(os_swix(ColourTrans_SetGCOL, &r)) ;
}


static os_error *displ_settruefontcol(font fonth, draw_coltyp foregrd,
                                           draw_coltyp backgrd
                              )
{
  os_regset r;

  r.r[0] = (int)fonth;
  r.r[1] = backgrd;   /* background BBGGRRxx (usually white) */
  r.r[2] = foregrd;   /* foreground BBGGRRxx                 */
  r.r[3] = 14;        /* max offset (magic number)  */

  return(os_swix(0x4074F/*ColourTrans_SetFontColour*/, &r)) ;
}

#pragma -s0


/* ------------------------------------------------------------------------- */

double scalefactor;

os_error *do_objpath(draw_objptr, int,int);
os_error *do_objsprite(draw_objptr hdrptr, int orgx,int orgy);
os_error *do_objtext(draw_objptr hdrptr, int orgx,int orgy);

/* Font catalogue - type defined in drawMenu */
static fontcatstr *fontcat;
static BOOL fontcatseen;

/* Record font catalogue */
void note_fontcat(draw_objptr hdrptr)
{
  int ptr = sizeof(draw_fontliststrhdr);
  int fontNum;
  int size = hdrptr.fontlistp->size;

  /* malloc fontcat to save static space for shared library */
  if (fontcat == 0) fontcat = (fontcatstr *)malloc(sizeof(fontcatstr));

  if (hdrptr.bytep == 0)
  {
    fontcatseen = FALSE;
    return;
  }

  fontcat->list_size = 0;
  while (ptr < size)
  {
    if ((fontNum = (int)hdrptr.bytep[ptr++]) == 0) break;
    fontcat->name[fontNum] = hdrptr.bytep + ptr;
    ptr += strlen(fontcat->name[fontNum]) + 1;
    if (fontNum > fontcat->list_size) fontcat->list_size = fontNum;
  }
  fontcat->menu_size = fontcat->list_size;
  fontcatseen = TRUE;
}

/* ------------------------------------------------------------------- */
/*                                                                     */
/* Draw the object 'hdrptr-> ' whose origin is (orgx,orgy)             */
/*                                                                     */
/*  The object is:                                                     */
/*    a PATH                                                           */
/*    a line of TEXT                                                   */
/*    a GROUPing of objects                                            */
/*                                                                     */
/*    (orgx,orgy) takes into acount window and scroll bar positions.   */
/*    (orgx,orgy) & clip(x0,y0,x1,y1) are in dBase coordinates.        */
/*                                                                     */
/* This version is modified from the one in c.drawDispl, to use a      */
/* different sort of error block, and to call the unknown object       */
/* handler if it has been defined. -> TRUE if no error                 */
/*                                                                     */
/* ------------------------------------------------------------------- */


BOOL  do_objects(draw_objptr hdrptr,draw_objptr limit, int orgx,int orgy,
                 int clip_x0,int clip_y0,int clip_x1,int clip_y1,
                 draw_error *err)
{ os_error *oserr = 0;
  BOOL     ok     = TRUE;

  for ( ; ok && hdrptr.bytep < limit.bytep;
          hdrptr.bytep += hdrptr.objhdrp->size)
    { switch (hdrptr.objhdrp->tag)
      {
        case draw_OBJTEXT:
          if (visible(hdrptr)) oserr = do_objtext(hdrptr, orgx,orgy);
          break;

        case draw_OBJPATH:
          if (visible(hdrptr)) oserr = do_objpath(hdrptr, orgx,orgy);
          break;

        case draw_OBJSPRITE:
          if (visible(hdrptr)) oserr = do_objsprite(hdrptr, orgx,orgy);
          break;

        case draw_OBJGROUP:
          if (visible(hdrptr))
            { draw_objptr objptr,objlim;

              objptr.bytep = hdrptr.bytep + sizeof(draw_groustr);
              objlim.bytep = hdrptr.bytep + hdrptr.objhdrp->size;

              /* Render the objects in the group */
              ok = do_objects(objptr,objlim, orgx,orgy,
                              clip_x0,clip_y0, clip_x1,clip_y1, err);
            }
          break;

        case draw_OBJTAGG:
          if (visible(hdrptr))
            { draw_objptr objptr,objlim;

              objptr.bytep = hdrptr.bytep + sizeof(draw_taggstrhdr);
              objlim.bytep = objptr.bytep + objptr.objhdrp->size;

              /* Render the (one) object within the tagged object */
              ok = do_objects(objptr,objlim, orgx,orgy,
                              clip_x0,clip_y0, clip_x1,clip_y1, err);
            }
          break;

        case draw_OBJTEXTCOL:
        {
          draw_bboxtyp clipBox;
          clipBox.x0 = clip_x0;
          clipBox.y0 = clip_y0;
          clipBox.x1 = clip_x1;
          clipBox.y1 = clip_y1;

          if (visible(hdrptr)) oserr = do_objtextcol(hdrptr, orgx, orgy,
                                                             &clipBox);
          break;
        }

        case draw_OBJTEXTAREA:
        {
          draw_bboxtyp clipBox;
          clipBox.x0 = clip_x0;
          clipBox.y0 = clip_y0;
          clipBox.x1 = clip_x1;
          clipBox.y1 = clip_y1;

          if (visible(hdrptr)) oserr = do_objtextarea(hdrptr, orgx, orgy,
                                                               &clipBox);
          break;
        }

        case draw_OBJFONTLIST:
          note_fontcat(hdrptr);
          break;

        default: /* Call unknown object handler, if there is one */
          if (visible(hdrptr) && dr_unknown_handler != NULL)
            ok = dr_unknown_handler((void*)hdrptr.bytep,
                                    dr_unknown_handle, err);
          break;
      }

      if (oserr)
      {
        DrawFile_OSError(err, *oserr);
        ok = FALSE;
        break;
      }
    }
  return(ok);
}


/* ------------------------------------------------------------------- */


/* Fill and/or outline a path */


static void displ_unpackpathstyle(draw_objptr hdrptr, draw_jointspec *jspecp)
{
  int joincapwind    = hdrptr.pathp->pathstyle.joincapwind;

  jspecp->join       = (joincapwind & packmask_join);
  jspecp->endcap     = (joincapwind & packmask_endcap) >> packshft_endcap;
  jspecp->startcap   = (joincapwind & packmask_startcap) >> packshft_startcap;
  jspecp->reserved   = 0;
  jspecp->mitrelimit = 0xA0000;  /* Mitre limit=10.0 (post script default) */
  jspecp->endtricapwid =
  jspecp->starttricapwid = (hdrptr.pathp->pathstyle.tricapwid << 4);
  jspecp->endtricaphei =
  jspecp->starttricaphei = (hdrptr.pathp->pathstyle.tricaphei << 4);
}



os_error *do_objpath(draw_objptr objhdr, int orgx, int orgy)
{ os_error *err = 0;
  os_regset r;

  draw_coltyp fillcol = objhdr.pathp->fillcolour; /* BBGGRRxx / 0xFFFFFFFF */
  draw_coltyp linecol = objhdr.pathp->pathcolour;
  int linewid         = objhdr.pathp->pathwidth;
  int joincapwind     = objhdr.pathp->pathstyle.joincapwind;

  int matrix[6];

  matrix[0] = matrix[3] = (int) (scalefactor*65536);
  matrix[1] = matrix[2] = 0;
  matrix[4] = orgx;
  matrix[5] = orgy;

  if (fillcol != TRANSPARENT)
  {                                                         /* fill the path */
    err = displ_settruecol(0,fillcol);
    if (err) return(err);

    r.r[0] = (int)address_pathstart(objhdr); /*&(objhdr.pathp->path);*/
    r.r[1] = 0x30 | ((joincapwind & packmask_windrule) >> 5);  /*winding rule*/
    r.r[2] = (int)&matrix[0];                       /* transformation matrix */
    r.r[3] = (int)(200/scalefactor);                             /* flatness */

    err = os_swix(Draw_Fill, &r);
    if (err) return(err);
  }

  if (linecol != TRANSPARENT)
  {                                                    /* stroke the outline */
    draw_jointspec jointspec;

    err = displ_settruecol(0,linecol);
    if (err) return(err);

    displ_unpackpathstyle(objhdr, &jointspec);

    r.r[0] = (int)address_pathstart(objhdr); /*&(objhdr.pathp->path);*/
    r.r[1] = 0x38;                                  /* fill (BBC) style      */
    r.r[2] = (int)&matrix[0];                       /* transformation matrix */
    r.r[3] = (int)(200/scalefactor);                /* flatness              */
    r.r[4] = linewid;                               /* line thickness        */
    r.r[5] = (int)&jointspec;                       /* line cap & join spec. */
    r.r[6] = (int)address_dashstart(objhdr);        /* dash pattern          */

    err = os_swix(Draw_Stroke, &r);
    if (err) return(err);
  }
  return(0);
}


/* ------------------------------------------------------------------- */


/* Set size & spacing of VDU5 characters, units are pixels */

os_error *displ_setVDU5charsize(int xsize,int ysize, int xspace,int yspace)
{ os_error *e;
  currentmode.gcharaltered = 1; /* so we restore before next pollwimp */

  e = bbc_vduq(23,17,7,2,xsize,xsize>>8,ysize,ysize>>8,0,0);
  if (!e) bbc_vduq(23,17,7,4,xspace,xspace>>8,yspace,yspace>>8,0,0);
  return(e);
}

/* Draw a line of text */

/* If the font can't be found (ie 'font disc not present' or font name  */
/* came from a fontlist object), use the system font. This seems kinder */
/* than aborting, or poping up an error box.                            */
/* Any other errors are passed back.                                    */

os_error *do_objtext(draw_objptr hdrptr, int orgx,int orgy)
{ os_error *err = 0;
  int textcol = hdrptr.textp->textcolour;
  int backgrd = hdrptr.textp->background; /* a hint (kludge) to font munger */

  if (textcol == TRANSPARENT) return(0); /* nothing to plot */

  if (fontcatseen && hdrptr.textp->textstyle.fontref)
    { font fonth;
      err = font_find(fontcat->name[hdrptr.textp->textstyle.fontref],
                      scaleF(hdrptr.textp->fsizex),
                      scaleF(hdrptr.textp->fsizey),
                      0,0,
                      &fonth
                     );
      if (!err)
        {
          err = font_setfont(fonth);

          if (!err)
            { err = displ_settruefontcol(fonth,textcol,backgrd);

              if (!err)
                err = font_paint(&hdrptr.textp->text[0],
                                 font_OSCOORDS | font_ABS,
                                 scaleT(orgx, hdrptr.textp->coord.x),
                                 scaleT(orgy, hdrptr.textp->coord.y)
                                );
            }
          (void) font_lose(fonth);
          return(err);
        }
    }


/* either system font specified, or fancy font could not be found */
/* so render in the system font (ie scaled VDU5 characters)       */
  { int xsize = (int)((scalefactor * hdrptr.textp->fsizex) /
                       currentmode.pixsizex);
    int ysize = (int)((scalefactor * hdrptr.textp->fsizey) /
                       currentmode.pixsizey);
    /* xsize,ysize in pixels. pixsizex,pixsizey in dBase coords per pixel */
    err = displ_settruecol(0,textcol);
    if (err) return(err);
    /* assume char base line is row 7 (of 8) */
    err = bbc_move(scaleT(orgx, hdrptr.textp->coord.x),
                   scaleT(orgy, hdrptr.textp->coord.y +
                                 7*(int)hdrptr.textp->fsizey/8)
                  );
    if (err) return(err);
    err = displ_setVDU5charsize(xsize,ysize, xsize,ysize);
    if (err) return(err);
    err = bbc_stringprint(&hdrptr.textp->text[0]);
  }
  return(err);
}



/*********************************************
 * Call the SWI to build a translation table *
 *********************************************/

#pragma -s1

static os_error *selecttable(int sourcemode, int *sourcepal, int destmode,
                      int *destpal, char *transtab)
{
 os_regset regs ;

 regs.r[0] = sourcemode ;
 regs.r[1] = (int) sourcepal ;
 regs.r[2] = destmode ;
 regs.r[3] = (int) destpal ;
 regs.r[4] = (int) transtab ;

 return (os_swix(ColourTrans_SelectTable, &regs));
}

#pragma -s0

/* plot a sprite */

os_error *do_objsprite(draw_objptr hdrptr, int orgx,int orgy)
{ os_error *err = 0;

  sprite_id      id;
  sprite_factors factors;

  int  palentries;
  int  *sourcepal;                /* Points to paltab OR =0 (no palette) */
  int  paltab[256];               /* for 1st flash colours in sprite     */
  char pixtrans[256];             /* pixel conversion tab                */

  id.tag    = sprite_id_addr;
  id.s.addr = &hdrptr.spritep->sprite;

  palentries = (hdrptr.spritep->sprite.image - sizeof(sprite_header))/8;
  if ((palentries > 256) || (palentries < 0)) palentries = 0;

  if (palentries == 0)
    sourcepal = 0;                /* no palette, use default for sprite.mode */
  else
    { int *from = hdrptr.spritep->palette;  /* sprites palette entries       */
      int *to   = paltab;                   /* have 1st & 2nd flash colours  */
      int i;                                /* extract ONLY 1st flash colour */

      for (i=palentries; i>0; i--) { *to++ = *from; from += 2; }

      sourcepal = paltab;    /* use sprite palette */
    }

  err = selecttable(hdrptr.spritep->sprite.mode, /* srce mode = sprite mode  */
                    sourcepal,             /* srce pal  = sprite/default pal */
                    -1,                    /* dest mode = current mode       */
                    (int*)-1,              /* dest pal  = current pal        */
                    &pixtrans[0]
                   );
  if (err) return(err);

  { sprite_id id;
    sprite_info info ;

    id.tag    = sprite_id_addr;
    id.s.addr = &hdrptr.spritep->sprite;

    (void)sprite_readsize((sprite_area*)0xFF, /* this op needs no spArea */
                          &id,                /* pass address of sprite  */
                          &info               /* result block            */
                         );

    factors.xmag = (int)((hdrptr.spritep->bbox.x1 - hdrptr.spritep->bbox.x0) *
                         scalefactor
                        );
    factors.xdiv = currentmode.pixsizex * info.width;
    factors.ymag = (int)((hdrptr.spritep->bbox.y1 - hdrptr.spritep->bbox.y0) *
                         scalefactor
                        );
    factors.ydiv = currentmode.pixsizey * info.height;
  }

  err = sprite_put_scaled((sprite_area*)0xFF, /* this op needs no spArea */
                          &id,                /* pass address of sprite  */
                          8,                  /* GcolAction=STORE thro mask */
                          scaleS(orgx, hdrptr.spritep->bbox.x0),
                          scaleS(orgy, hdrptr.spritep->bbox.y0),
                          &factors,
                          (sprite_pixtrans*)&pixtrans[0]
                        );
  return(err);
}

extern BOOL drawfiles_init(void);

BOOL drawfiles_init(void)
{
    return ((fontcat = malloc(sizeof(fontcatstr))) != 0);
}
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d38 5
a42 5
#include "h.os"
#include "h.bbc"
#include "h.sprite"
#include "h.font"
#include "h.swis"
d45 3
a47 3
#include "h.DrawIntern.drawfile1"
#include "h.drawfdiag"
#include "h.DrawIntern.drawfile2"
@


4.1
log
@Initial revision
@
text
@d15 17
a31 25
/****************************************************************************
 * This source file was written by Acorn Computers Limited. It is part of   *
 * the "DrawFile" library for rendering RISCOS Draw files from applications *
 * in C. It may be used freely in the creation of programs for Archimedes.  *
 * It should be used with Acorn's C Compiler Release 2 or later.            *
 *                                                                          *
 * No support can be given to programmers using this code and, while we     *
 * believe that it is correct, no correspondence can be entered into        *
 * concerning behaviour or bugs.                                            *
 *                                                                          *
 * Upgrades of this code may or may not appear, and while every effort will *
 * be made to keep such upgrades upwards compatible, no guarantees can be   *
 * given.                                                                   *
 ***************************************************************************/

/* -> c.DrawFiles
 *
 * DrawFile module, internal code
 * History:
 * Version 0.1: 15 Feb 89, DAHE: created
 *              13 May 91, ECN: Use SWI names instead of numbers
 *                              Stack checking off on selected functions
 *
 * This file consists of code taken from the !Draw version of files c.draw
 * and c.drawDispl for use in the DrawFile module (release 0.2).
a49 3
/* Code from c.draw */

/* The following are needed to shut the preprocessor up */
d54 1
a54 1
 
d184 1
a184 1
/* ------------------------------------------------------------------- */ 
d283 1
a283 1
/* ------------------------------------------------------------------- */ 
d314 1
a314 1
 
d360 1
a360 1
/* ------------------------------------------------------------------- */ 
d397 1
a397 1
        { 
d525 1
a525 1
                          scaleS(orgx, hdrptr.spritep->bbox.x0),  
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 25
a39 17
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.DrawFiles
 * Purpose: utility functions used in rendering a draw objects
 * History: IDJ: 06-Feb-92: prepared for source release
d58 3
d65 1
a65 1

d195 1
a195 1
/* ------------------------------------------------------------------- */
d294 1
a294 1
/* ------------------------------------------------------------------- */
d325 1
a325 1

d371 1
a371 1
/* ------------------------------------------------------------------- */
d408 1
a408 1
        {
d536 1
a536 1
                          scaleS(orgx, hdrptr.spritep->bbox.x0),
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

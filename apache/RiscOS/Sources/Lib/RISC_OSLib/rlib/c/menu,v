head	4.8;
access;
symbols
	RISC_OSLib-5_97:4.8
	RISC_OSLib-5_96:4.8
	RISC_OSLib-5_95:4.8
	RISC_OSLib-5_94:4.8
	RISC_OSLib-5_93:4.8
	RISC_OSLib-5_92:4.8
	RISC_OSLib-5_91:4.8
	RISC_OSLib-5_90:4.8
	RISC_OSLib-5_89:4.8
	RISC_OSLib-5_88:4.8
	RISC_OSLib-5_87:4.8
	RISC_OSLib-5_86-1:4.6
	RISC_OSLib-5_86:4.6
	RISC_OSLib-5_85:4.6
	RISC_OSLib-5_84:4.6
	RISC_OSLib-5_83-2:4.6
	RISC_OSLib-5_83-1:4.6
	RISC_OSLib-5_83:4.6
	RISC_OSLib-5_82:4.5
	RISC_OSLib-5_81:4.4
	RISC_OSLib-5_75-2:4.4
	RISC_OSLib-5_80:4.4
	RISC_OSLib-5_79:4.4
	RISC_OSLib-5_78:4.4
	RISC_OSLib-5_75-1:4.4
	RISC_OSLib-5_77:4.4
	RISC_OSLib-5_76:4.4
	RISC_OSLib-5_75:4.4
	RISC_OSLib-5_74:4.4
	RISC_OSLib-5_73:4.4
	RISC_OSLib-5_72:4.4
	RISC_OSLib-5_71:4.4
	RISC_OSLib-5_70:4.4
	RISC_OSLib-5_69:4.4
	RISC_OSLib-5_68:4.4
	RISC_OSLib-5_67:4.4
	RISC_OSLib-5_66:4.4
	RISC_OSLib-5_65:4.4
	RISC_OSLib-5_64:4.4
	RISC_OSLib-5_63:4.4
	RISC_OSLib-5_62:4.4
	RISC_OSLib-5_61:4.4
	RISC_OSLib-5_60:4.4
	RISC_OSLib-5_59:4.3
	RISC_OSLib-5_58:4.3
	RISC_OSLib-5_57:4.3
	RISC_OSLib-5_56:4.3
	RISC_OSLib-5_55:4.3
	RISC_OSLib-5_54:4.3
	RISC_OSLib-5_53:4.2
	RISC_OSLib-5_52:4.2
	RISC_OSLib-5_51:4.2
	RO_5_07:4.2
	RISC_OSLib-5_50:4.2
	RISC_OSLib-5_49:4.2
	RISC_OSLib-5_46-4_64_2_1:4.2
	NoInlineAsm:4.2.0.2
	RISC_OSLib-5_48:4.2
	RISC_OSLib-5_47:4.2
	RISC_OSLib-5_46:4.2
	RISC_OSLib-5_45:4.2
	RISC_OSLib-5_44:4.2
	RISC_OSLib-5_43:4.2
	RISC_OSLib-5_42:4.2
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2016.02.13.09.21.23;	author rool;	state Exp;
branches;
next	4.7;
commitid	lLmpwBqr2Bl9GJUy;

4.7
date	2016.01.30.09.52.38;	author rool;	state Exp;
branches;
next	4.6;
commitid	3yARm2CqvpIBiWSy;

4.6
date	2014.07.31.08.24.09;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	jfGiiZxupMtuqvKx;

4.5
date	2014.05.08.10.11.29;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	u7YoeZpupMfJIIzx;

4.4
date	2011.08.06.20.05.17;	author jlee;	state Exp;
branches;
next	4.3;
commitid	D9pXqV2mtIAhluuv;

4.3
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.52;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.12;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.12;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.53.51;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.30.38;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.34;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.14;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Remove arbitrary limits on menu sizes
Detail:
  When RISC_OSLib is used to generate menus using menu_new and menu_extend
  there are two (undocumented?) limits on the total menu size:
  - 64 items on a menu. Any more are silently ignored.
  - 1024 bytes of indirect text. Above this, any items have
    several bytes of random rubbish displayed in the menu entry.

  rlib.c.menu (r4.6) has been changed to:
  - remove menu_workarea which was on the stack, and caused limits.
  - only use malloc'd storage areas for the menu.
  - reduce the data copied by at least 50% by changing processing
    from: copy; update; copy
    to  : realloc extend (& copy?); update; realloc shrink (no copy).
  - remove the limits by adding more storage dynamically.
  - simplify code, which reduces the object code size by about 7%.
Admin:
  The changes have been tested on an Iyonix running RO5.23, and VRPC
  running RO4.39, with a large C program with about 80 menus.
  The only noticeable effects were beneficial.
  It has also been tested with artificially low ADDITEMS and ADDBYTES.
  Submission from Martin Avison.

Version 5.87. Tagged as 'RISC_OSLib-5_87'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.menu
 * Purpose: menu manipulation.
 * History: IDJ: 06-Feb-92: prepared for source release
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "os.h"
#include "wimp.h"
#include "werr.h"
#include "menu.h"

#include "sprite.h"
#include "resspr.h"
#include "msgs.h"
#include "VerIntern/messages.h"

typedef struct menu__str {
  wimp_menuhdr *m;         /* the wimp-level menu that we've built. */
  int nitems;              /* items in menu */
  void *entryspace;        /* for sub-menus, and entries with >12 chars */
  int nbytes;              /* bytes used in entryspace */
  int maxentrywidth;       /* used to set menu width */
  int maxitems;            /* max items for menu_new/extend */
  int maxbytes;            /* max bytes for menu_new/extend */
} menu__str;
/* concrete representation of abstract menu object */

/* The menu__str structure points to a RISCOS-style menu, and to a separate
buffer of workspace for sub-menu pointers and for string fields that
are >12 characters. The format of the entryspace is:
  each sub-Menu pointer
  a Menu(NIL) word
  each entry buffer
*/

static wimp_menuitem *menu__itemptr(menu m, int n)
/* Pointer to the nth item in the menu (starting at 0). */
{
  return(((wimp_menuitem*)(m->m + 1)) + n);
}

/* -------- Building RISC OS Menus. -------- */

/* The menu is assembled entry by entry in malloc'd storage.
The two main areas hold the menu block and the indirect data.
At the start of menu_new or menu_extend they are (re)allocated too
large, then shrunk using realloc before exit.
If realloc causes the indirect area to move, any indirect pointers
in the menu block are adjusted.
The total space is only limited by memory. */

/* The following set the amount of storage to be allocated in one go. */

#define ADDITEMS  32       /* items added in one chunk for menu block */
#define ADDBYTES 512       /* bytes added in one chunk for indirect text */


static void menu__disposespace(menu m)
{ /* Free two areas (header+icons & indirect data) for a complete menu */
  if (m->m != NULL) {
    free(m->m);
    m->m = 0;
  }
  if (m->entryspace != NULL) { /* can only happen with very new menu__strs. */
    free(m->entryspace);
    m->entryspace = 0;
  }
}

static void menu__checkmove(menu m, int moveoffset)
{ /* Move any indirect pointers in menu items by moveoffset */
  int i;

  for (i=0;i<m->nitems;i++) {
    wimp_menuitem *ptr = menu__itemptr(m, i);
    if (ptr->iconflags & wimp_INDIRECT) {
      ptr->data.indirecttext.buffer += moveoffset;
    }
  }
}

static void menu__realloc(menu m, int items, int bytes)
/* Change sizes for more (or less) menu items and bytes indirect data.
   Note areas may move when extended (or even shrunk?) */
{
  int  *oldesp; /* for old entryspace addr */

  if (items != 0) {
    m->maxitems += items;
    m->m = realloc(m->m, sizeof(wimp_menuhdr) + m->maxitems * sizeof(wimp_menuitem));
    if (m->m == NULL)
      werr(TRUE, msgs_lookup(MSGS_menu1)); /* not enough memory */
  }
  if (bytes != 0) {
    m->maxbytes += bytes;
    oldesp = m->entryspace;
    m->entryspace = realloc(m->entryspace, m->maxbytes);
    if (m->entryspace == NULL) {
      werr(TRUE, msgs_lookup(MSGS_menu1)); /* not enough memory */
    }
    if ((oldesp != m->entryspace) && (m->nitems>0)) {
      menu__checkmove(m, (int)m->entryspace - (int)oldesp);
    }
  }
}

/* -------- Creating menu descriptions. -------- */

static menu menu__initmenu(char *name)
{ /* Create and initialise menu structure, block and entryspace */
  menu m;
  int i;

  m = calloc(1,sizeof(menu__str));
  if (m == NULL) {
    werr(TRUE, msgs_lookup(MSGS_menu1));
  }

  menu__realloc(m, ADDITEMS, ADDBYTES);

  /* insert a NIL in the entrySpace to distinguish sub-Menu pointers
  from text space. */
  m->nbytes = 4;
  *((int*)m->entryspace) = 0;

  for (i=0; i<12; i++) {
    m->m->title[i] = name[i];
    if (name[i]==0) {break;}
  }
  m->m->tit_fcol = 7; /* title fore: black */
  m->m->tit_bcol = 2;  /* title back: grey */
  m->m->work_fcol = 7; /* entries fore */
  m->m->work_bcol = 0; /* entries back */
  m->m->width = i*16;  /* minimum value */
  m->m->height = 44;   /* per entry */
  m->m->gap = 0;       /* gap between entries, in OS units */
  return m;
}

static int menu__max(int a, int b)
  { if (a < b) {return(b);} else {return(a);} }

static wimp_menuitem *menu__additem(
  menu m /*out*/, char *name, int length)
/* Add an item to the end of a menu                    */
/* The returned pointer can be used to set flags, etc. */
{
  wimp_menuitem *ptr;
  if (m->nitems == m->maxitems) {
    menu__realloc(m, ADDITEMS, 0);
  }
  ptr = menu__itemptr(m, m->nitems++);
  ptr->flags = 0;
  ptr->submenu = (wimp_menustr*) -1;
  ptr->iconflags = wimp_ITEXT + wimp_IFILLED + wimp_IVCENTRE + (7*wimp_IFORECOL);
  if (length > m->maxentrywidth) {
    m->maxentrywidth = length;
    m->m->width = menu__max(m->m->width, 16 + length * 16);
      /* in OS units, 16 per char. */
  }
  if (length <= 12) {
    /* item can be directly in the icon, so copy to icon block. */
    int i;
    for (i=0; i<length; i++) {ptr->data.text[i] = name[i];}
    if (length < 12) {ptr->data.text[length] = 0;}
  } else {
    if (length+1+m->nbytes >= m->maxbytes) {
      /* new length over current maximum, so add storage */
      menu__realloc(m, 0, ADDBYTES);
    }
    /* space for length, so set up icon block to be indirect */
    ptr->iconflags += wimp_INDIRECT;
    ptr->data.indirecttext.buffer = ((char*)m->entryspace) + m->nbytes;
    ptr->data.indirecttext.validstring = (char*) -1;
    ptr->data.indirecttext.bufflen = 100;
    /* copy name into entryspace */
    (void) memmove(((char*)m->entryspace) + m->nbytes, name, length);
    m->nbytes += length + 1;
    ((char*)m->entryspace)[m->nbytes-1] = 0; /* terminate the string. */
  }
  return(ptr);
}

/* -------- Parsing Description Strings. -------- */

static void menu__syntax(void)
{
  /* General policy: be lenient on syntax errors, so do nothing */
}

typedef enum {
  TICK = 1,
  FADED = 2,
  DBOX = 4,
  NUM  = 8
} opt;

typedef enum {OPT, SEP, NAME, END} toktype;

typedef struct {
  char *s;
  toktype t;
  char ch;        /* last separator char encountered */
  opt opts;       /* last opts encountered */
  char *start;
  char *end;      /* last name encountered */
} parser;

static void menu__initparser(parser *p, char *s)
{
  p->s = s;
  p->ch = ',';
}

static void menu__getopt(parser *p)
{
  p->opts = 0;
  while (p->ch=='!' || p->ch=='~' || p->ch=='>' || p->ch=='#' || p->ch==' ') {
    if (p->ch=='!') {
      p->opts |= TICK;
    } else if (p->ch=='~') {
      p->opts |= FADED;
    } else if (p->ch=='#') {
      p->opts |= NUM;
    } else if (p->ch=='>') {
      p->opts |= DBOX;
    }
    p->ch=*p->s++;
  }
  p->s--;
}

static void menu__getname (parser *p)
{ /*Skip leading spaces*/
  while (p->ch == ' ')
    p->ch = *p->s++;

  p->start = p->s - 1;

  if (p->ch == '"')
  { /*Quoted string*/
    p->ch = *p->s++;

    p->start = p->s - 1;

    while (p->ch != 0 && p->ch != '"')
      p->ch = *p->s++;

    p->end = p->s - 1;

    if (p->ch == '"')
    { p->ch = *p->s++;

      /*Skip trailing spaces*/
      while (p->ch == ' ')
        p->ch = *p->s++;
    }

    if (p->ch != 0 && p->ch != ',' && p->ch != '|')
      p->ch = *p->s++;

    p->s--;
  }
  else
  { /*Non-quoted string*/
    p->start = p->s - 1;

    while (p->ch != 0 && p->ch != ',' && p->ch != '|')
      p->ch = *p->s++;

    p->end = --p->s;
  }
}

static toktype menu__gettoken(parser *p)
{
  p->ch = ' ';
  while (p->ch == ' ') p->ch = *p->s++;
  switch (p->ch) {
  case 0:
    p->t = END;
    break;
  case '!':
  case '~':
  case '>':
  case '#':
    p->t = OPT;
    menu__getopt(p);
    break;
  case ',':
  case '|':
    p->t = SEP;
    break;
  default:
    p->t = NAME;
    menu__getname(p);
    break;
  }
  return(p->t);
}

/* -------- Parsing and Extension. -------- */

static void menu__doextend(menu m, char *descr)
{
  parser p;
  toktype tok;
  wimp_menuitem *ptr;

  menu__initparser(&p, descr);
  tok = menu__gettoken(&p);
  if (tok==END) {
    /* do nothing */
  } else {
    if (tok==SEP) {
      if (m->nitems == 0) {
        menu__syntax();
      } else {
        if (p.ch == '|') {
          ptr = menu__itemptr(m, m->nitems-1);
          ptr->flags |= wimp_MSEPARATE;
        }
        tok = menu__gettoken(&p);
      }
    }
    while (1) {
      if (tok == OPT) {
        tok = menu__gettoken(&p); /* must be NAME, check below */
      } else {
        p.opts = 0;
      }
      if (p.t != NAME) {
        menu__syntax();
      } else {
        ptr = menu__additem(m, p.start, p.end - p.start);
        if ((TICK & p.opts) != 0) {
          ptr->flags |= wimp_MTICK;
        }
        if ((FADED & p.opts) != 0) {
          ptr->iconflags |= wimp_INOSELECT;
        }
        if ((NUM & p.opts) != 0) {
          ptr->iconflags |= (1<<20);
        }
        if ((DBOX & p.opts) != 0) {
          ptr->flags |= wimp_MSUBLINKMSG;
          ptr->submenu = (wimp_menustr*) 1;
        }
        tok = menu__gettoken(&p);
        if (tok == END) break;
        if (tok != SEP) {
          menu__syntax();
        } else {
          if (p.ch == '|') ptr->flags |= wimp_MSEPARATE;
        }
      }
      tok = menu__gettoken(&p);
    }
  }
}

/* -------- Entrypoints. -------- */

menu menu_new(char *name, char *descr)
{ /* Create a new menu from the list of entries in descr */
  menu m;
  wimp_menuitem *ptr;

  m = menu__initmenu(name);
  menu__doextend(m, descr); /* create menu entrie(s) from descr */
  menu__realloc(m, m->nitems-m->maxitems, m->nbytes-m->maxbytes); /* shrink */
  if (m->nitems > 0) {
    menu__itemptr(m, m->nitems-1)->flags |= wimp_MLAST; /* set last */
  }
  if (strlen(name) > 12) { /* check title */
      *(char **)m->m->title = name;
      ptr = menu__itemptr(m, 0);
      ptr->flags |= wimp_MINDIRECTED;
  }
  return m;
}

void menu_dispose(menu *m, int recursive)
{ /* Free the storage associated with a menu - and optionally submenus. */
  if (recursive != 0) {
    menu *a = (menu*) ((*m)->entryspace);
    while (1) {
      menu subm = *(a++);
      if (subm == 0) {break;}
      menu_dispose(&subm, 1);
    }
  }
  menu__disposespace(*m);
  free(*m);
}

void menu_extend(menu m, char *descr)
{ /* Add one (or more) items from descr to existing menu. */
  menu__realloc(m, ADDITEMS, ADDBYTES);
  menu__itemptr(m, m->nitems-1)->flags &= ~wimp_MLAST; /* unset last */
  menu__doextend(m, descr); /* add menu item(s) from descr */
  menu__realloc(m, m->nitems-m->maxitems, m->nbytes-m->maxbytes); /* shrink */
  if (m->nitems > 0) {
    menu__itemptr(m, m->nitems-1)->flags |= wimp_MLAST; /* set new last */
  }
}

void menu_setflags(menu m, int entry, int tick, int fade)
{ /* Set/Unset tick and fade flags on specific menu entry */
  wimp_menuitem *p;
  if (entry == 0) {return;}
  if (entry > m->nitems) {return;}
  p = menu__itemptr(m, entry-1);
  if (tick != 0) {
    p->flags |= wimp_MTICK;
  } else {
    p->flags &= ~wimp_MTICK;
  }
  if (fade != 0) {
    p->iconflags |= wimp_INOSELECT;
  } else {
    p->iconflags &= ~wimp_INOSELECT;
  }
}

void menu_setcolours(menu m, int entry, int fore, int back)
{
  wimp_menuitem *p;
  if (entry == 0) {return;}
  if (entry > m->nitems) {return;}
  p = menu__itemptr(m, entry-1);
  if (p->iconflags & wimp_IFONT) {return;} /* Dual field use */
  p->iconflags = (p->iconflags & ~((15 * wimp_IFORECOL) | (15 * wimp_IBACKCOL)))
                 | (fore * wimp_IFORECOL)
                 | (back * wimp_IBACKCOL);
}

void menu_make_writeable(menu m, int entry, char *buffer, int bufferlength,
                         char *validstring)
{
  wimp_menuitem *p;
  if (entry == 0) {return;}
  if (entry > m->nitems) {return;}
  p = menu__itemptr(m, entry-1);
  p->flags |= wimp_MWRITABLE ;
  p->iconflags |= wimp_BWRITABLE * wimp_IBTYPE + wimp_INDIRECT +
                  wimp_IHCENTRE + wimp_IVCENTRE + wimp_ITEXT ;
  p->data.indirecttext.buffer = buffer ;
  p->data.indirecttext.bufflen = bufferlength ;
  p->data.indirecttext.validstring = validstring ;
}


void menu_make_sprite(menu m, int entry, char *spritename)
{
  wimp_menuitem *p;
  if (entry == 0) {return;}
  if (entry > m->nitems) {return;}
  p = menu__itemptr(m, entry-1);


  p->iconflags &= ~wimp_ITEXT;
  p->iconflags |= wimp_INDIRECT+wimp_IVCENTRE+wimp_ISPRITE;
  p->data.indirectsprite.name = spritename;
  p->data.indirectsprite.spritearea = resspr_area();
  p->data.indirectsprite.nameisname = 1;
}


void menu_submenu(menu m, int place, menu submenu)
{ /* Link a submenu to an entry in a parent menu */
  wimp_menuitem *p = menu__itemptr(m, place-1);

  p->submenu = (wimp_menustr*) (submenu?submenu->m:NULL);
  menu__realloc(m, 0, sizeof(menu*));
  (void) memmove(
    /* to   */ ((menu*) m->entryspace) + 1, /* +4 bytes */
    /* from */ ((menu*) m->entryspace),
    m->nbytes);
  m->nbytes += sizeof(menu*);
  *((menu__str**)(m->entryspace)) = submenu;
  menu__checkmove(m, sizeof(menu*)); /* adjust indirect ptrs for insertion */
}

void *menu_syshandle(menu m)
{
  if (m != NULL)
    return (void *)m->m;
  return (void *)-1;  
}

/* end */
@


4.7
log
@Extra menu comments
Admin:
  Part of submission from Martin Avison. Not tagged.
@
text
@d50 1
a50 1
#include "Verintern/messages.h"
d58 2
d79 13
a91 4
/* The menu is assembled entry by entry in temporary workspace, then copied
to more precisely allocated store. The copying of menu structures is split
into the allocation of store and then the copying of data, so that the copy
into the larger buffer can share the latter half of the operation. */
d95 1
a95 1
  if (m->m != 0) {
d99 1
a99 1
  if (m->entryspace != 0) { /* can only happen with very new menu__strs. */
d105 2
a106 21
static void menu__preparecopy(menu from, menu to)
{
  /* Allocate space in the destination to suit the copy. */
  to->m = malloc(sizeof(wimp_menuhdr) + from->nitems * sizeof(wimp_menuitem));
  if (to->m == 0) {
    werr(TRUE, msgs_lookup(MSGS_menu1));
  }
  if (from->nbytes != 0) {
    to->entryspace = malloc(from->nbytes);
    if (to->entryspace == 0) {
      werr(TRUE, msgs_lookup(MSGS_menu1));
    }
  } else {
    to->entryspace = 0;
  }
}

static void menu__copydata(menu from, menu to)
/* Copy the data and lengths. Relocate indirection pointers. */
{
  int moveoffset;
d109 3
a111 10
  to->maxentrywidth = from->maxentrywidth;
  to->nitems = from->nitems;
  (void) memmove(to->m, from->m,
    sizeof(wimp_menuhdr) + from->nitems * sizeof(wimp_menuitem));
  to->nbytes = from->nbytes;
  moveoffset = ((char*)to->entryspace) - ((char*)from->entryspace);
  (void) memmove(to->entryspace, from->entryspace, from->nbytes);
  for (i=0;i<to->nitems;i++) {
    wimp_menuitem *ptr = menu__itemptr(to, i);
    if ((ptr->iconflags & wimp_INDIRECT) != 0) {
d117 22
a138 35
/* The work area is allocated on the stack, with the following limits: */

#define MAXITEMS 64       /* max size of a menu: surely OK. */
#define MAXENTRYSPACE 1024 /* space for building entries > 12 chars */

typedef struct {
  menu__str m;
  wimp_menuhdr menuhdr;
  wimp_menuitem menuitems[MAXITEMS];
  char entryspace[MAXENTRYSPACE];
} menu__workarea;

static void menu__initworkarea(menu__workarea *w)
{
  w->m.m = &w->menuhdr;
  w->m.nitems = 0;
  w->m.entryspace = &w->entryspace;
  w->m.maxentrywidth = 0;
  /* insert a NIL in the entrySpace to distinguish sub-Menu pointers
  from text space. */
  w->m.nbytes = 4;
  *((int*)w->entryspace) = 0;
}

static void menu__copytoworkarea(menu m /*in*/, menu__workarea *w /*out*/)
{
  menu__initworkarea(w);
  menu__copydata(m, &w->m);
  menu__itemptr(&w->m, w->m.nitems-1)->flags &= ~wimp_MLAST;
}

static void menu__copyworkarea(menu__workarea *w /*in*/, menu m /*out*/)
{
  if (w->m.nitems > 0) {
    menu__itemptr(&w->m, w->m.nitems-1)->flags |= wimp_MLAST;
a139 3
  menu__disposespace(m);
  menu__preparecopy(&w->m, m);
  menu__copydata(&w->m, m);
d144 1
a144 1
static void menu__initmenu(char *name, menu m /*out*/)
d146 1
d148 13
d172 1
d179 1
a179 1
  menu__workarea *w /*out*/, char *name, int length)
d184 4
a187 2
  if (w->m.nitems == MAXITEMS) {return(menu__itemptr(&w->m, MAXITEMS-1));}
  ptr = menu__itemptr(&w->m, w->m.nitems++);
d191 3
a193 3
  if (length > w->m.maxentrywidth) {
    w->m.maxentrywidth = length;
    w->m.m->width = menu__max(w->m.m->width, 16 + length * 16);
a200 3
  } else if (length+1+w->m.nbytes >= MAXENTRYSPACE) {
    /* no room for the text: unlikely */
    ptr = menu__itemptr(&w->m, w->m.nitems-1); /* fudge */
d202 4
d208 1
a208 1
    ptr->data.indirecttext.buffer = ((char*)w->m.entryspace) + w->m.nbytes;
d212 3
a214 3
    (void) memmove(((char*)w->m.entryspace) + w->m.nbytes, name, length);
    w->m.nbytes += length + 1;
    ((char*)w->m.entryspace)[w->m.nbytes-1] = 0; /* terminate the string. */
d339 1
a339 1
static void menu__doextend(menu__workarea *w, char *descr)
d351 1
a351 1
      if (w->m.nitems == 0) {
d355 1
a355 1
          ptr = menu__itemptr(&w->m, w->m.nitems-1);
d370 1
a370 1
        ptr = menu__additem(w, p.start, p.end - p.start);
a401 1
  menu__workarea menu__w;
d404 5
a408 6
  menu__initworkarea(&menu__w);
  menu__initmenu(name, &(menu__w.m));
  menu__doextend(&menu__w, descr);
  m = malloc(sizeof(menu__str));
  if (m == 0) {
    werr(TRUE, msgs_lookup(MSGS_menu1));
d410 1
a410 4
  m->m = 0;
  m->entryspace = 0;
  menu__copyworkarea(&menu__w, m);
  if (strlen(name) > 12) {
d434 7
a440 4
  menu__workarea menu__w;
  menu__copytoworkarea(m, &menu__w);
  menu__doextend(&menu__w, descr);
  menu__copyworkarea(&menu__w, m);
a506 1
  int i;
a507 1
  menu__workarea menu__w;
d510 1
a510 1
  menu__copytoworkarea(m, &menu__w);
d512 6
a517 13
    /* to */ ((menu*) menu__w.m.entryspace) + 1,
    /* from */ ((menu*) menu__w.m.entryspace),
    menu__w.m.nbytes);
  menu__w.m.nbytes += sizeof(menu*);
  *((menu__str**)(menu__w.m.entryspace)) = submenu;

  for (i=0; i<menu__w.m.nitems; i++) {
    p = menu__itemptr(&menu__w.m, i);
    if (((p->iconflags)&wimp_INDIRECT) != 0) {
      p->data.indirecttext.buffer += 4;
    }
  }
  menu__copyworkarea(&menu__w, m);
@


4.6
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@d54 1
a54 1
  int nitems;
d56 2
a57 2
  int nbytes;
  int maxentrywidth;
d83 1
a83 1
{
d176 1
a176 1
{
d196 1
d211 1
d219 1
d224 1
a281 1

d413 1
a413 1
{
d437 1
a437 1
{
d451 1
a451 1
{
d459 1
a459 1
{
d521 1
a521 1
{
@


4.5
log
@Check for NULL pointers before finding the syshandle
menu.c: if NULL return -1, this has the added advantage that a menu maker (see event_attachmenumaker) can return NULL to mean "no menu thanks" and not data abort in event.c
dbox.c: if NULL return 0, this is somewhat consistent with template_syshandle()
menu.h: typo in comment corrected

Version 5.82. Tagged as 'RISC_OSLib-5_82'
@
text
@d473 12
@


4.4
log
@Update to work with zero page relocation
Detail:
  clib/s/cl_stub, kernel/s/k_body, s/initmodule - Use OS_ReadSysInfo 6 to look up CLibWord/RISCOSLibWord/CLibCounter location each time it's needed instead of using hardcoded addresses. SWI overhead shouldn't be too bad since the zero page areas are rarely used.
  rlib/c/menu - Fix null pointer access when attempting to clear a submenu pointer via menu_submenu(...,...,NULL)
  s/h_workspc - Remove old local definitions of CLibCounter, RISCOSLibWorkSpace and CLibWorkSpace. Use Hdr:PublicWS instead.
Admin:
  Tested on rev A2 BB-xM


Version 5.60. Tagged as 'RISC_OSLib-5_60'
@
text
@d531 3
a533 1
  return (void *) m->m;
@


4.3
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d511 1
a511 1
  p->submenu = (wimp_menustr*) submenu->m;
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d42 9
a50 9
#include "h.os"
#include "h.wimp"
#include "h.werr"
#include "h.menu"

#include "h.sprite"
#include "h.resspr"
#include "h.msgs"
#include "h.verintern.messages"
@


4.1
log
@Initial revision
@
text
@d15 17
a31 6
/* Title: -> c.menu
 * Purpose: Portable menu manipulation.
 * Author: WRS
 * Status: experimental
 * History:
 *   24 August 87 -- started
d61 1
a61 1
/* The menu__str structure points to an Arthur-style menu, and to a separate
a68 3
/* >>>> Could perhaps improve by simplifying: squash everything into one
space area, and shift things up every time. */

d75 1
a75 1
/* -------- Building Arthur Menus. -------- */
a81 5
/* This situation would be improved if shifting/extendable store were used to
record menus, rather than the basic M2 allocation facilities. But,
performance is not believed particularly important for these facilities as
the delay will not be humanly discernable. */

d87 1
a87 1
  };
d91 1
a91 1
  };
d100 1
a100 1
  };
d105 1
a105 1
    };
d108 1
a108 1
  };
d128 2
a129 2
    };
  };
a140 1
/*  char itemspace[sizeof(wimp_menuhdr) + MAXITEMS*sizeof(wimp_menuitem)]; */
d180 1
a180 1
    if (name[i]==0) {break;};
a189 1
/* >>>> titles of more than 12 characters impossible */
d192 1
a192 1
  { if (a < b) {return(b);} else {return(a);}; }
a196 2
/* There's no point in being tough on errors: the menu is simply
truncated. */
d199 1
a199 1
  if (w->m.nitems == MAXITEMS) {return(menu__itemptr(&w->m, MAXITEMS-1));};
d211 2
a212 2
    for (i=0; i<length; i++) {ptr->data.text[i] = name[i];};
    if (length < 12) {ptr->data.text[length] = 0;};
d224 1
a224 1
  };
d271 1
a271 1
    };
d298 1
a298 1
      
d303 1
a303 1
    
d330 1
a330 1
  case '>':      
d343 1
a343 1
  };
a346 7
#if 0
static int menu__checktok(parser *p, toktype type)
{
  return(menu__gettoken(p) == type);
}
#endif

d367 1
a367 1
        };
d369 2
a370 2
      };
    };
d376 1
a376 1
      };
d383 1
a383 1
        };
d386 1
a386 1
        };
d389 1
a389 1
        };
d393 1
a393 1
        };
d400 2
a401 2
        };
      };
d403 2
a404 2
    };
  };
a408 5
/* >>>> Will large work areas on the stack cause stack overflow at the moment?
MenuWorkArea static for now. */

/* static menu__workarea menu__w; */

d421 1
a421 1
  };
d439 1
a439 1
      if (subm == 0) {break;};
d441 2
a442 2
    };
  };
d458 2
a459 2
  if (entry == 0) {return;};
  if (entry > m->nitems) {return;};
d465 1
a465 1
  };
d470 1
a470 1
  };
d477 2
a478 2
  if (entry == 0) {return;};
  if (entry > m->nitems) {return;};
d492 2
a493 2
  if (entry == 0) {return;};
  if (entry > m->nitems) {return;};
d524 2
a525 2
    };
  };
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 6
a20 17
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.menu
 * Purpose: menu manipulation.
 * History: IDJ: 06-Feb-92: prepared for source release
d50 1
a50 1
/* The menu__str structure points to a RISCOS-style menu, and to a separate
d58 3
d67 1
a67 1
/* -------- Building RISC OS Menus. -------- */
d74 5
d84 1
a84 1
  }
d88 1
a88 1
  }
d97 1
a97 1
  }
d102 1
a102 1
    }
d105 1
a105 1
  }
d125 2
a126 2
    }
  }
d138 1
d178 1
a178 1
    if (name[i]==0) {break;}
d188 1
d191 1
a191 1
  { if (a < b) {return(b);} else {return(a);} }
d196 2
d200 1
a200 1
  if (w->m.nitems == MAXITEMS) {return(menu__itemptr(&w->m, MAXITEMS-1));}
d212 2
a213 2
    for (i=0; i<length; i++) {ptr->data.text[i] = name[i];}
    if (length < 12) {ptr->data.text[length] = 0;}
d225 1
a225 1
  }
d272 1
a272 1
    }
d299 1
a299 1

d304 1
a304 1

d331 1
a331 1
  case '>':
d344 1
a344 1
  }
d348 7
d375 1
a375 1
        }
d377 2
a378 2
      }
    }
d384 1
a384 1
      }
d391 1
a391 1
        }
d394 1
a394 1
        }
d397 1
a397 1
        }
d401 1
a401 1
        }
d408 2
a409 2
        }
      }
d411 2
a412 2
    }
  }
d417 5
d434 1
a434 1
  }
d452 1
a452 1
      if (subm == 0) {break;}
d454 2
a455 2
    }
  }
d471 2
a472 2
  if (entry == 0) {return;}
  if (entry > m->nitems) {return;}
d478 1
a478 1
  }
d483 1
a483 1
  }
d490 2
a491 2
  if (entry == 0) {return;}
  if (entry > m->nitems) {return;}
d505 2
a506 2
  if (entry == 0) {return;}
  if (entry > m->nitems) {return;}
d537 2
a538 2
    }
  }
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

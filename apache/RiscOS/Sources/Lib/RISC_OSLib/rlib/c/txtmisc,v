head	4.5;
access;
symbols
	RISC_OSLib-5_97:4.5
	RISC_OSLib-5_96:4.5
	RISC_OSLib-5_95:4.5
	RISC_OSLib-5_94:4.5
	RISC_OSLib-5_93:4.5
	RISC_OSLib-5_92:4.5
	RISC_OSLib-5_91:4.5
	RISC_OSLib-5_90:4.5
	RISC_OSLib-5_89:4.5
	RISC_OSLib-5_88:4.5
	RISC_OSLib-5_87:4.5
	RISC_OSLib-5_86-1:4.5
	RISC_OSLib-5_86:4.5
	RISC_OSLib-5_85:4.5
	RISC_OSLib-5_84:4.3
	RISC_OSLib-5_83-2:4.3
	RISC_OSLib-5_83-1:4.3
	RISC_OSLib-5_83:4.3
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.3
	RISC_OSLib-5_77:4.3
	RISC_OSLib-5_76:4.3
	RISC_OSLib-5_75:4.3
	RISC_OSLib-5_74:4.3
	RISC_OSLib-5_73:4.3
	RISC_OSLib-5_72:4.3
	RISC_OSLib-5_71:4.3
	RISC_OSLib-5_70:4.3
	RISC_OSLib-5_69:4.3
	RISC_OSLib-5_68:4.3
	RISC_OSLib-5_67:4.3
	RISC_OSLib-5_66:4.3
	RISC_OSLib-5_65:4.3
	RISC_OSLib-5_64:4.3
	RISC_OSLib-5_63:4.3
	RISC_OSLib-5_62:4.3
	RISC_OSLib-5_61:4.3
	RISC_OSLib-5_60:4.3
	RISC_OSLib-5_59:4.3
	RISC_OSLib-5_58:4.3
	RISC_OSLib-5_57:4.3
	RISC_OSLib-5_56:4.3
	RISC_OSLib-5_55:4.3
	RISC_OSLib-5_54:4.3
	RISC_OSLib-5_53:4.2
	RISC_OSLib-5_52:4.2
	RISC_OSLib-5_51:4.2
	RO_5_07:4.2
	RISC_OSLib-5_50:4.2
	RISC_OSLib-5_49:4.2
	RISC_OSLib-5_46-4_64_2_1:4.1
	NoInlineAsm:4.1.0.16
	RISC_OSLib-5_48:4.1
	RISC_OSLib-5_47:4.1
	RISC_OSLib-5_46:4.1
	RISC_OSLib-5_45:4.1
	RISC_OSLib-5_44:4.1
	RISC_OSLib-5_43:4.1
	RISC_OSLib-5_42:4.1
	RISC_OSLib-5_41:4.1
	RISC_OSLib-5_40:4.1
	RISC_OSLib-5_39:4.1
	RISC_OSLib-5_38:4.1
	RISC_OSLib-5_37:4.1
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2015.04.03.22.43.46;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	4ZOxMlETYoK3gcgy;

4.4
date	2015.04.03.20.40.01;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	G8BXIPKUyzCGAbgy;

4.3
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.2;

4.2
date	2004.01.23.19.10.22;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.16;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.25.16;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.15;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.31.23;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.57;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Clean up pass
Trim any #if FALSE switches over a decade old, and keep #if TRUE.
Accept EDIT2 and FMTTEXT1 bracketed code.
Remove unused internal functions txt1_dooaction txt1_dosetoaction.
Retagged as RISC_OSLib-5_85.
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Title: txtmisc.c
 * Purpose: Search text for string.
 * Author: AFP
 * Status: system-independent
 * Requires:
 *   h.txt
 * History:
 *   16 Jul 87 -- started
 *   18 Dec 87: AFP: converted into C.
 *   02 Mar 88: WRS: improved use of trace.
 *   17 Mar 88: IGJ: txtmisc_formattxt added
 *    1 Jun 90: NDR: txtmisc wordwrap routines moved here from c.txtedit
 *    8 May 91: ECN: #ifndefed out unused ROM functions
 *   11 Jun 91: IDJ: expand tabs and CR<>LF now set modified flag
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include "werr.h"
#include "txt.h"
#include "flex.h"
#include "txtscrap.h"
#include "EditIntern/txtmisc.h"
#include "EditIntern/txtundo.h"
#include "trace.h"
#include "msgs.h"
#include "VerIntern/messages.h"

int txtmisc_alphach(char c)

/* We try to cover the letters with accents on them too. Is this right?
Not sure. */

{

return(((c >= 'a') && (c <= 'z')) ||
       ((c >= 'A') && (c <= 'Z')) ||
       ((c >= '0') && (c <= '9')) ||
       (c >= 128+64));

}

txt_index txtmisc_bow(txt t, txt_index i)

{

if (i > 0 && txt_charat(t, i - 1) == '\n')
     --i;
while (i > 0 && txtmisc_alphach(txt_charat(t, i - 1)) && txt_charat(t, i - 1) != '\n')
     --i;
while (i > 0 && !txtmisc_alphach(txt_charat(t, i - 1)) && txt_charat(t, i - 1) != '\n')
     --i;

return(i);

}




txt_index txtmisc_eow(txt t, txt_index i)

{

txt_index lim;

lim = txt_size(t);
if (i < lim && txt_charat(t, i) == '\n')
     ++i;
while (i < lim && txtmisc_alphach(txt_charat(t, i)) && txt_charat(t, i) != '\n')
     ++i;
while (i < lim && !txtmisc_alphach(txt_charat(t, i)) && txt_charat(t, i) != '\n')
     ++i;
return(i);

}



/* beginning of line */
txt_index txtmisc_bol(txt t, txt_index i)

{

while (i > 0 && (txt_charat(t, i - 1) != '\n'))
     --i;
return(i);

}



/* end of line */
txt_index txtmisc_eol(txt t, txt_index i)

{

txt_index lim;

lim = txt_size(t);

while (i < lim && (txt_charat(t, i) != '\n'))
     ++i;
return(i);

}


#ifndef UROM
int txtmisc_bof(txt t)
{

return(txt_dot(t) == 0);

}
#endif


int txtmisc_eof(txt t)
{
return(txt_dot(t) == txt_size(t));
}



unsigned txtmisc_currentlinenumber(txt t)

{

txt_index at;
unsigned size;
char *a;
int n,j,line;

size = txt_dot(t);
at = 0;
line = 1;

while (at != size)

     {
     txt_arrayseg(t, at, &a, &n);
     n = (n < size) ? n : size;
     for (j = 0; j < n; j++)
        if (a[j] == '\n')
          ++line;
     at += n;
     }
return(line);

}




void txtmisc_gotoline(txt t, unsigned l)

{

txt_index at;
unsigned size;
char *a;
int n,j=0;

if (l == 1) /* move to top of file */
  txt_setdot(t, 0);

if (l > 1)

  {

  size = txt_size(t);
  at = 0;
  while (at != size && l != 1)
       {
       txt_arrayseg(t, at, &a, &n);
       for (j = 0; (j < n && l != 1); j++)
           if (a[j] == '\n')
            --l;
       if (l != 1)
         {
         at += n;
         j = 0;
         }
       }

  txt_setdot(t, at+j);

  }
}


static int txtmisc_blackch(char c)

{
return(c != ' ' && c != '\n' && c != 0);
}

void txtmisc_tab(txt t)

/* This implementation is somewhat of a cheat, in that I move up
to the line above, hit cursor right a few times, and go back down
again. Various things can go wrong, e.g. with wrapped lines. In tests,
doing a tab with the line above wrapped is particularly noticable. */

{

txt_index to, dot;
int       topline;
BOOL      endoflineabove = FALSE;


txt_setcharoptions(t, txt_CARET, 0);

dot = txt_dot(t);

txt_movevertical(t, -1, NULL); /* move to line above */

topline = (dot == txt_dot(t)) ? 0 : 1;

dot = txt_dot(t);

to = dot;

while (txtmisc_blackch(txt_charat(t, to)))
     ++to;

if (txt_charat(t, to) == '\n') endoflineabove = TRUE;

while (txt_charat(t, to) == ' ')
     ++to;

txt_setdot(t, to);

if (topline)
  txt_movevertical(t, 1, NULL); /* and move back to line below again */

if (endoflineabove) txt_setdot(t, txtmisc_bol(t, txt_dot(t)));

txt_setcharoptions(t, txt_CARET, txt_CARET);

}

void txtmisc_tabcol(txt t) {
/* If the dot is at a newline then the whole thing is different: tabbing
affects the horizontal tab offset, rather than moving you in the file. There
is a problem in that you can't tell about the existing horizontal tab at the
txt interface: BUT YOU CAN, by inserting a space and seeing how many spaces
appear! Then undo this, and presto. */

  txt_index i = txt_dot(t);
  BOOL atnewline = txt_charatdot(t) == '\n' || txt_dot(t) == txt_size(t);
  int currentoffset = 0;

  if (atnewline) {
    txt_charoption opts = txt_charoptions(t);
    if ((txt_CARET & opts) != 0) txt_setcharoptions(t, txt_CARET, 0);
    txtundo_separate_major_edits(t);
    txt_insertchar(t, ' ');
    /* Turning off display loses your horizontal offset, so it must be done
    after the insertchar. */
    currentoffset = txt_dot(t) - i;
    while (txtundo_undo(t) == txtundo_MINOR); /* undo the insert. */
    txtundo_commit(t); /* totally forget the insertion and its reversal */
    if ((txt_CARET & opts) != 0) txt_setcharoptions(t, txt_CARET, txt_CARET);
  };

  while (i > 0 && txt_charat(t, i-1) != '\n') i--; /* i now start of line */
  i = txt_dot(t) - i; /* i now length of line */
  if (atnewline) i += currentoffset; /* i now current col position. */
  while (i >= 8) i -= 8; /* i now fraction of tab col that we stick out over */
  i = 8 - i; /* i now no of spaces to insert; */

  if (atnewline) {
    txt_movehorizontal(t, currentoffset + i);
  } else {
    txt_replacechars(t, 0, "        ", i);
    txt_movedot(t, i);
  };

}

void txtmisc_expandtabs(txt t)

{

char c, *spaces = "        ";
txt_index at, size, dot;
unsigned col, nspaces;

at = col = 0;
size = txt_size(t);
dot = txt_dot(t);
 txt_setcharoptions(t, txt_DISPLAY, 0);
while (at != size)
      {
      if ((c = txt_charat(t, at)) == '\n')
         {
         ++at;
         col = 0;
         }
      else if (c == 9)
         {
         txt_setdot(t, at);
         nspaces = 8 - col % 8;
         txt_replacechars(t, 1, spaces, nspaces);
         size += (nspaces - 1);
         if (at < dot)
            dot += (nspaces - 1);
         }
      else
         {
         ++at;
         ++col;
         }
      }
txt_setdot(t, dot);

txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY);
}



void txtmisc_indentregion(txt t, txt_index from, txt_index to, int by,
                          char *with)

{
unsigned cby, del, del1;
int big;
txt_marker savedot;

if (from != 0)
   {
   from = txtmisc_eol(t, txtmisc_bol(t, from - 1)); /* now on a NewLineCh. */
   ++from; /* now at the start of a line */
   }
to = (to < txt_size(t)) ? to : txt_size(t);
if (by == 0)
   return;

if (by > 0)
   {
   cby = (by < strlen(with)) ? by : strlen(with);
   del = 0;
   }
else
   {
   cby = 0;
   del = -1 * by;
   }
big = to > from + 1000;
if (big)
   txt_setcharoptions(t, txt_DISPLAY, 0);
txt_newmarker(t, &savedot);
while (from < to)
      {
      txt_setdot(t, from);
      if (txt_charatdot(t) != '\n')
         /* don't do anything to blank lines */
         {
         int linelen = txtmisc_eol(t, from) - from;
         del1 = (del < linelen) ? del : linelen; /* 22-Nov-88 WRS: bug fix. */
         txt_replacechars(t, del1, with, cby);
         to += cby;
         to -= del1;
         }
      if (cby > 0 && txt_selectstart(t) > txt_dot(t))
         /* only for first line: we fail to select inserted chars */
         txtscrap_setselect(t, txt_selectstart(t) - cby, txt_selectend(t));
      from = txtmisc_eol(t, from) + 1;
      /* the EOL is done twice because the Replace affects its value. */
      }
txt_movedottomarker(t, &savedot);
txt_disposemarker(t, &savedot);
if (big)
   txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY);
}


void txtmisc_exchangecrlf(txt t)

{

txt_index at;
unsigned size, j;
int n;
char *a, c;
BOOL updated = FALSE;

txt_setcharoptions(t, txt_DISPLAY, 0);
size = txt_size(t);
at = 0;
while (at != size)
      {
      txt_arrayseg(t, at, &a, &n);
      for (j = 0; j < n; j++)
          {
            if ((c = a[j]) == '\n')
            {
               updated = TRUE;
               a[j] = '\r';
            }
            if (c == '\r')
            {
               updated = TRUE;
               a[j] = '\n';
            }
          }
      at += n;
      }
txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY);
if (updated) txt_setcharoptions(t, txt_UPDATED, txt_UPDATED);
txtundo_purge_undo(t);
}

/* -------- Selection utilities. -------- */


txt_index txtmisc_furthestaway(txt t, txt_index from, txt_index a1,
                               txt_index a2)

{
t=t;
if (from <= (a1 + a2) / 2)
   return((a1 > a2) ? a1 : a2);
else
   return((a1 < a2) ? a1 : a2);
}


void txtmisc_select3(txt t, txt_index a1, txt_index a2, txt_index a3)

{

txt_index a4;

txtscrap_setselect(t, (a1 < (a4 = (a2 < a3) ? a2 : a3)) ? a1 : a4,
                   (a1 > (a4 = (a2 > a3) ? a2 : a3)) ? a1 : a4);
}


static BOOL txtmisc__linenonalpha(txt t, txt_index i) {
  char c = txt_charat(t, i);
  if (i > txt_size(t)) return FALSE;
  if (i < 0) return FALSE;
  if (txtmisc_alphach(c)) return FALSE;
  if (c == '\n') return FALSE;
  return TRUE;
}

void txtmisc_selectpointandword(txt t, txt_index point, txt_index word)

{

txt_index begin = word;
txt_index end = begin;
txt_index size = txt_size(t);

if (txtmisc_alphach(txt_charat(t, begin - 1))
    ||
    txtmisc_alphach(txt_charat(t, end)))
{
  /* We are pointed at a word. */
  while (begin > 0 && txtmisc_alphach(txt_charat(t, begin - 1))) begin--;
  while (txtmisc_alphach(txt_charat(t, end))) end++;
  if (txt_charat(t, end) == '\n' || end == size) {
    /* There is no whitespace after this word - gobble up whitespace before it. */
    while (txtmisc__linenonalpha(t, begin - 1)) begin--;
  } else {
    /* There is whitespace after this word - gobble it up (default case) */
    while (txtmisc__linenonalpha(t, end)) end++;
  };
} else {
  /* We are pointed at whitespace. */
  while (txtmisc__linenonalpha(t, begin - 1)) begin--;
  while (txtmisc__linenonalpha(t, end)) end++;
  if (begin == 0 || txt_charat(t, begin - 1) == '\n') {
    /* We are at the left end of a line - gobble up the word on the right */
    while (txtmisc_alphach(txt_charat(t, end))) end++;
  } else {
    /* Gobble up the word on the left (default case). */
    while (begin > 0 && txtmisc_alphach(txt_charat(t, begin - 1))) begin--;
  };
};

txtmisc_select3(t, point, begin, end);

}


void txtmisc_selectpointandline(txt t, txt_index point, txt_index line)

{

txt_index begin, end;

begin = txtmisc_bol(t, line);
end = 1 + txtmisc_eol(t, begin);
txtmisc_select3(t, point, begin, end);

}

/* -------- Wordwrap -------- */

/* This incorrectly resides in txtedit at the moment. */
void txtmisc_normalisepara(
  txt t,
  int parawidth
);

/* -------- Wordwrap. -------- */

#if WORDWRAP

BOOL txtmisc_paraend(txt t, txt_index i) {
  if (txt_size(t) <= i) return TRUE;
  if (txt_charat(t, i) != '\n') return FALSE;
  if (i == 0) return TRUE;
  if (txt_charat(t, i-1) == '\n') return TRUE;
  if (txt_size(t) == i+1) return TRUE;
/*  return strchr("\n .", txt_charat(t, i+1)) != 0; */
  {
    char ch = txt_charat(t, i+1);
    if (ch == '\n') return TRUE;
    if (ch == ' ') return TRUE;
    if (ch == '.') return TRUE;
    return FALSE;
  };
}

#ifndef UROM
BOOL txtmisc_parastart(txt t, txt_index i) {
  if (i == 0) return TRUE;
  if (txtmisc_paraend(t, i-1)) return TRUE;
  if (i == 1) return FALSE;
  return (txtmisc_paraend(t, i-2));
}
#endif

#ifndef UROM
txt_index txtmisc_bop(txt t, txt_index i) {
  while (!txtmisc_parastart(t, i)) {
    i = txtmisc_bol(t, i-1);
  };
  return i;
}
#endif

txt_index txtmisc_eop(txt t, txt_index i) {
  while (!txtmisc_paraend(t, i)) {
    i = txtmisc_eol(t, i+1);
  };
  return i;
}

void txtmisc_normalisepara(
  txt t,
  int parawidth
)
/* Usually called during typin (flag-controlled), after the insertion but before
the advancement of the caret. Normalise the characters from the caret to the
next end-of-paragraph, converting between spaces and newlines in order to
improve layout. Do this all in a separate memory block and then do a single
txt_replacechars in order to manufacture the resulting effect.

Bugs: limited buffer size
*/

#define PSIZ 512

/* It's reasonable to have a maximum on the amount that you're prepared to look
ahead. If the result ripples ahead more than this, tough luck. */
/* If parawidth is more than this it won't work very well. */

{
    char c[PSIZ];
    int paramax;
    int at = 0; /* index of current point into c. */
    int col = 0; /* column of current point. */
    txt_index dot;
    txt_index parastart;
    int minchange;
    int maxchange;
    int hascaret = txt_charoptions(t) & txt_CARET;
    BOOL modified = FALSE;
    BOOL bufoverflow = TRUE;

    tracef1("normalisepara width=%i.\n", parawidth);
    if (parawidth == 0) return; /* do no formatting. */

    dot = txt_dot(t);
    parastart = txtmisc_bol(t, dot);

    while (bufoverflow) {
      /* We only loop here if the paragraph is larger than PSIZ, e.g. our work
      buffer is not big enough. */
      int prevat = at;
      int prevcol = col;
      int prevprevat;
      int prevprevcol;

      /* col == dot's current column position. */
      tracef2("dot=%i, dot para start=%i.\n", dot, parastart);

      /* Fill the buffer from parastart to the next end of paragraph. */
      paramax = 0;
      while (paramax < PSIZ && !txtmisc_paraend(t, parastart + paramax)) {
        c[paramax] = txt_charat(t, parastart + paramax);
        paramax++;
      };
      /* c[paramax] is the final NewLineCh, or is beyond the end of file. */
      tracef1("paramax = %i.\n", paramax);

      minchange = paramax;
      maxchange = 0;
      /* c[minchange]..c[maxchange] must be updated in the text buffer. */

      while (1) {
        int nextwhite;
        int nextwhitecol;

        prevprevat = prevat;
        prevprevcol = prevcol;
        prevat = at;
        prevcol = col;

        while (c[at] != '\n' && c[at] != ' ' && at < paramax) { /* hop over word */
          at++;
          col++;
        };
        while ((c[at] == '\n' || c[at] == ' ') && at < paramax) { /* hop over gap */
          at++;
          col++;
        };
        if (at == paramax) {
          if (paramax != PSIZ) {
            bufoverflow = FALSE; /* "usual" exit route from the loop */
          };
          break;
        };
        /* We are now at the start of a word, at>0, or at==paramax cos the buffer's not big enough. */
        tracef2("word start: at=%i col=%i.\n", at, col);

        nextwhite = at;
        while (c[nextwhite] != '\n' && c[nextwhite] != ' ' && nextwhite < paramax) { /* find end of word */
          nextwhite++;
        };
        if (nextwhite == PSIZ) {
          /* the buffer's not big enough. */
          break;
        };
        nextwhitecol = col + nextwhite - at;

        at--; /* point at the whitespace before */
        if (nextwhitecol > parawidth) { /* or >= perhaps? */
          if (c[at] == ' ') { /* this should be a newline */
            c[at] = '\n';
            if (minchange > at) minchange = at;
            if (maxchange <= at) maxchange = at+1;
          };
        } else {
          if (c[at] == '\n') { /* this should be a space */
            c[at] = ' ';
            if (minchange > at) minchange = at;
            if (maxchange <= at) maxchange = at+1;
          };
        };
        if (c[at] == '\n') col = 0;
        at++; /* point at the word start */
      }; /* end while */

      if (minchange < maxchange) {
        /* there is some changing to do. */
        tracef2("update %i..%i.\n", minchange, maxchange);
        if ((! modified) && (hascaret != 0)) txt_setcharoptions(t, txt_CARET, 0);
        txt_setdot(t, parastart + minchange);

        /* At this point we'd like to just do the replace, but we also want to preserve
        the positioning of the selection start and end, if they are affected. */
        /* Arguably this should be a flag to replacechars - e.g. do not affect the position of
        markers within the replaced area? */
        {
          txt_index selstart = txt_selectstart(t);
          txt_index selend = txt_selectend(t);
          txt_index here = txt_dot(t);
          txt_replacechars(t, maxchange - minchange, &c[minchange], maxchange - minchange);
          if ((selstart >= here && selstart <= here + maxchange - minchange)
          || (selend >= here && selend <= here + maxchange - minchange)) {
            txt_setselect(t, selstart, selend);
          };
        };
        modified = TRUE;
      } else {
        tracef0("Not updating.\n");
      }; /* if */

      if (bufoverflow) { /* we're going to be looping. */
        if (prevat == 0) {
          /* a word longer than the buffer - don't really care as long as we advance */
          parastart += at;
          /* col stays as it is. */
        } else if (prevprevat == 0) {
          /* words so long that two words spans the buffer */
          parastart += prevat;
          col = prevcol;
        } else {
          /* normal case - go back two words, to ensure that we get all possible
          line breaks correct. */
          parastart += prevprevat;
          col = prevprevcol;
        };
        at = 0;
      };

    }; /* while */

    if (modified) {
      txt_setdot(t, dot);
      if (hascaret != 0) txt_setcharoptions(t, txt_CARET, txt_CARET);
    };
}
/* Should be able to go round again if the paragraph is bigger than the buffer. */

#endif

@


4.4
log
@Switch from ArcEdit style model to clipboard cut & paste model
The txt library part of RISC_OSLib was essentially contrary to everything Acorn was telling its developers, to use the global clipboard.
Additionally, support is added for swap case within a selection.
txt.h:
 Add a new charoption type 'txt_READONLY' to inform txt that the buffer is notionally read only, this is used to supress 'Paste' in the selection menu when appropriate.
 Correct some typos in the comments.
txt1.h:
 Kill off modula 2 dummy structure member.
txtar.h:
 Remove unused function export.
txtfile.h:
 Rename basicimport to be consistent with the text version of the same function. We use 'import' to denote RAM transfers and 'insert' to denote file/scrap transfers throughout.
txtmisc.h:
 Redundant internal functions removed.
txtundo.h:
 Add a new undo operation type 't' for swap case, to avoid polluting the undo buffer with an entire copy of the text where only the case changed.
 Kill off modula 2 double pointer requirement.
txtedit.h:
 Unused structure member 'selectctl' removed.
txt.c:
 Kill off modula 2 double pointer requirement.
txtar.c:
 Refactor message despatch with a switch statement so the save/load/open operations are explicitly checked for, in case the application enables other messages.
txtedit.c:
 Adopt MOVERWRITE, been enabled since 1988 so is probably good to keep.
 Dynamically generate the Select menu by first sending a clipboard request, and fading Paste if no reply comes back.
 Implement changed mouse selection logic.
 Implement different hotkeys and caret navigation.
 Implement copy and paste/replace operations.
 Implement swap case operation.
txtfile.c:
 Type corrections and function rename admin.
 Implement copy and paste/replace operation for detokenised BASIC.
txtmisc.c:
 Supporting functions for clipboard added, supporting functions for ArcEdit removed.
txtscrap.c:
 Make sure the caret is visible for programmatical zero sized selections.
txtundo.c:
 Allow suspension of undo during known complex operations, such as import via RAM transmit. This was a longstanding bug where the import buffer was grabbed in ~4k chunks (even if only 1 byte was being transferred) which in turn resulted in a +4000 undo insertion and a -3999 removal, which given the default undo buffer is only 5k would result in it failing the reversibility test, so no undo was possible.
 Now, during a RAM transmit undo is suspended until the total transfer size is known, and only that data is placed in the undo buffer (subject to the same 5k reversibility limit).
 Add new undo type 't' for swap case operation.
rlibdata.s:
 4 new ints and 1 new BOOL, so RlibSpace increases by 5.

Version 5.85. Tagged as 'RISC_OSLib-5_85'
@
text
@a49 3
#define EDIT2 1
/* 05-Jan-89: wordwrap facilities. */

a67 6
#if FALSE
while (i > 0 && txtmisc_alphach(txt_charat(t, i - 1)))
     --i;
while (i > 0 && !txtmisc_alphach(txt_charat(t, i - 1)))
     --i;
#else
a73 1
#endif
a88 6
#if FALSE
while (i < lim && txtmisc_alphach(txt_charat(t, i)))
     ++i;
while (i < lim && !txtmisc_alphach(txt_charat(t, i)))
     ++i;
#else
a94 1
#endif
a310 3
#if FALSE
int updated;
#endif
a313 3
#if FALSE
updated = ((txt_UPDATED & txt_charoptions(t)) != 0);
#endif
a339 6
#if FALSE
if (!updated)
  /* if it wasn't updated before, set this as still the case. */
  txt_setcharoptions(t, txt_UPDATED, NULL);
#endif

a436 96

#if EDIT2
#else

static BOOL txtmisc_iswhitespace(char c)

{
  return((c == '\n') || (c == ' '));
}


BOOL txtmisc_isparaend(txt t, txt_index at)

{
  if (at == txt_size(t)) return TRUE;
  if (txt_charat(t, at) == '\n') {
    if (at == txt_size(t) -1) return TRUE;
    {
      char nextch = txt_charat(t, at+1);
      return txtmisc_iswhitespace(nextch) || nextch == '.';
    };
  };
  return FALSE;
}


void txtmisc_formattext(txt t, int width)

/* format text a la Twin - if a line is longer than 80 characters split it
at word boundries by newlines, removing spaces, to give several lines of
80 or less cols */

{

txt_index at, wasat, sol, eol;

if (txt_charatdot(t) == '\n') {  /* >>>> 15-Nov-88 */
  txt_movedot(t, 1);
  return;
};

txt_setcharoptions(t, txt_DISPLAY, NULL);

at = txt_dot(t);
wasat = at;

while (!txtmisc_isparaend(t, at))
{
  if (txt_charat(t, at) == '\n')
  {
    txt_setdot(t, at);
    txt_replacechars(t, 1, " ", 1);
  }
  at++;
}

sol = txtmisc_bol(t, wasat);
eol = txtmisc_eol(t, wasat);

while (sol + width <= eol)  /* have we more than 76 chars on line ? */
{
  at = sol + width;
  while (at > sol && !txtmisc_iswhitespace(txt_charat(t, at)))
     --at;
  while (at > sol && txtmisc_iswhitespace(txt_charat(t, at - 1)))
     --at;
  if (at == sol) {
    /* A word longer than the width. Advance past this word. */
    while (at < txt_size(t) && ! txtmisc_iswhitespace(txt_charat(t, at)))
      ++at;
  };

#if TRUE
  if (at >= eol) break; /* 29-Nov-88: para with last line just right width, went wrong. */
#endif

  txt_setdot(t, at);          /* set the insertion point */
  txt_insertchar(t, '\n');    /* insert the new line */
  txt_movedot(t, 1);          /* advance past the NL */
  eol++;                      /* the eol is one further on */

  while (txtmisc_iswhitespace(txt_charatdot(t)))
  {
    txt_delete(t, 1);
    eol--;
  }
  sol = txt_dot(t);;
}

txt_setdot(t, wasat);                            /* set to where we started */
txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY); /* redisplay text */
txt_setdot(t, eol);                              /* set to end of line */
txt_movedot(t, 1);                               /* advance to next line */
}
#endif

a462 16
#if FALSE
void txtmisc_selectpointandword(txt t, txt_index point, txt_index word)

{

txt_index begin, end;

begin = txtmisc_bow(t, word);
if (begin != 0) begin = txtmisc_eow(t, begin); /* fix for start of file. */
end = txtmisc_eow(t, begin);
txtmisc_select3(t, point, begin, end);

}
#else
/* New, smarter version 07-Nov-89 */

a509 1
#endif
a523 2

#if EDIT2
a530 1
#endif
a612 3
#if FALSE
    parastart = txtmisc_bop(t, dot);
#else
a613 1
#endif
@


4.3
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d463 1
a463 1
txtundo_prevent_undo(t);
a666 9

void txtmisc_clearselection(void)

/* Clear any selection. */

{
txtscrap_setselect(NULL, 0, 0);
}

a676 186
/* -------- Operations on Selections -------- */

void txtmisc_deleteselection(int parawidth)

{

txt_marker m;
txt owner;

owner = txtscrap_selectowner();
if (owner != NULL && txt_selectset(owner))
   {
   txt_newmarker(owner, &m);
   txt_setdot(owner, txt_selectstart(owner));
   txt_delete(owner, txt_selectend(owner) - txt_selectstart(owner));
   txtmisc_normalisepara(owner, parawidth);
   txt_movedottomarker(owner, &m);
   txt_disposemarker(owner, &m);
   txtscrap_setselect(owner, 0, 0);
   }
}

#define BIG 256

static void movecopyselection(txt t, int deletesource, int parawidthsrc, int parawidthdst)

/* Two different techniques are used for small and for big operations. Small
ones are quicker to repaint. Bigger ones use FlexiStore as the transitory
space, this is tricky because inserting from FlexiStore might cause the
source to move under your feet if the object expands. */

{

unsigned size;
int n, stored, segsize;
txt owner;
char *a;
void *scrap;

owner = txtscrap_selectowner();
if (owner != NULL)
   {
   /* determine size */
   size = txt_selectend(owner) - txt_selectstart(owner);
   if (t == owner && deletesource &&
       txt_dot(t) >= txt_selectstart(t) && txt_dot(t) < txt_selectend(t))

     /* move with caret in the middle of select, do nothing */
     txt_setdot(t, txt_selectend(t));

   else

     {

     /* get temporary space */
     stored = TRUE;
     if (size <= BIG) {
        scrap = malloc(BIG);
        if (scrap == 0) {
          werr(FALSE, msgs_lookup(MSGS_txt48));
          return;
        };
     } else
        if (!flex_alloc(&scrap, size))
          {
          werr(NULL, msgs_lookup(MSGS_txt48));
          stored = FALSE;
          };
     tracef2("\nRequired size is %d, stored = %d.\n", size, stored);
     if (stored)
        {

        /* Copy the selection into the temporary store */
        n = 0;
        while (n != size)
              {
              txt_arrayseg(owner, txt_selectstart(owner) + n, &a, &segsize);
              segsize = (segsize < size - n) ? segsize : size - n;
              memcpy((char *)scrap + n, a, segsize);
              n += segsize;
              }

        /* Delete the source. */
        if (deletesource)
           txtmisc_deleteselection(parawidthsrc);
        /* >>>> dangerous? If t=owner, definitely a good move. */

        {
          int prevsize = txt_size(t);
          /* Insert the selection into the target */
          if (size <= BIG)
             {
             txt_replacechars(t, 0, scrap, size);
             tracef0("small MoveCopy.\n");
             }
          else
             {
             tracef0("large MoveCopy.\n");
             txtmisc_textinsertfromflexistore(t, &scrap, size);
             }
          if (txt_size(t) == prevsize + size) {
            /* managed to insert: not out of space. */

            /* The result becomes the selection */
            if (deletesource)
               txtscrap_setselect(t, txt_dot(t), txt_dot(t) + size);

            txtmisc_normalisepara(t, parawidthdst);
            /* NB we're relying on this not changing the size of what we've
            inserted: otherwise, moving past the insertion needs a marker. */

            /* Move past the result. */
            txt_movedot(t, size);

          };
        };

        /* deallocate temporary space */
        if (size <= BIG)
           free(scrap);
        else
           flex_free(&scrap);
        }
     }
   }
}


void txtmisc_moveselection(txt t, int parawidthsrc, int parawidthdst)

/* The selection is copied to the caret, then deleted at the source.
The new version is now the selection. */

{
movecopyselection(t, 1, parawidthsrc, parawidthdst);
}



void txtmisc_copyselection(txt t, int parawidth)

/* The selection is copied to the caret. The new version is now the
selection. */

{
movecopyselection(t, NULL, parawidth, parawidth);
}




int txtmisc_textinsertfromflexistore(txt t, flex_ptr anchor, unsigned n)

/* If we just did an insert and this caused an expand and we got moved, the
text would be taken from the wrong place. So, we must turn off display for
this one.

Return FALSE, with situation unchanged, if out of store. */

{
void *prevad;
int prevsize;

prevad = *anchor;
prevsize = txt_size(t);
txt_setcharoptions(t, txt_DISPLAY, 0);
txt_replacechars(t, 0, *anchor, n);
if (txt_size(t) != n + prevsize) {
  tracef0("not enough space.\n");
  txt_delete(t, txt_size(t) - prevsize);
  txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY);
  /* werr(FALSE, "Not enough space."); */
  /* 21-Nov-88 WRS: Failure will already have produced an error message. */
  return FALSE;
};
if (*anchor != prevad)
   {
   tracef0("Replace caused movement.\n");
   txt_replacechars(t, n, *anchor, n);
   }
txt_setcharoptions(t, txt_DISPLAY, txt_DISPLAY);
return(1);
}
/* >>>> do out of store stuff. */


@


4.2
log
@<ctype.h> * isblank() added.
          * isprint() now true for non-breaking spaces
<math.h>  * FP_INFINITY corrected to FP_INFINITE
          * fma(), fmal(), llrint(), llrintf(), llrintl(),
            llround(), llroundf(), llroundl(),
            remquo(), remquof(), remquol() added.
          * added inlining for remainder() and fmaf() and various
            float functions.
          * math_errhandling removed pending overhaul - it was misleading.
          * expm1() and log1p() now provide decent (< 1 ulp) accuracy,
            rather than only being marginally better than exp(x)-1 and
            log(1+x).
          * new version of copysign() with standard calling conventions.
          * some C99 functions changed to use infinity/NaNs and exceptions
            for error handling - see comments in header file about the
            changes in progress.
<stdio.h>  * output from %a now correctly rounded
<stdlib.h> * strtof() and strtold() added.
<string.h> * strerror() no longer clears _kernel_last_oserror().

Version 5.49. Tagged as 'RISC_OSLib-5_49'
@
text
@d40 9
a48 9
#include "h.werr"
#include "h.txt"
#include "h.flex"
#include "h.txtscrap"
#include "h.EditIntern.txtmisc"
#include "h.EditIntern.txtundo"
#include "h.trace"
#include "h.msgs"
#include "h.verintern.messages"
d251 1
a251 1
txt_setcharoptions(t, txt_CARET, NULL);
d338 1
a338 1
txt_setcharoptions(t, txt_DISPLAY, NULL);
d403 1
a403 1
   txt_setcharoptions(t, txt_DISPLAY, NULL);
d440 1
a440 1
txt_setcharoptions(t, txt_DISPLAY, NULL);
d851 1
a851 1
txt_setcharoptions(t, txt_DISPLAY, NULL);
@


4.1
log
@Initial revision
@
text
@d60 1
a60 1
return(((c >= 'a') && (c <= 'z')) || 
d67 1
a67 4
txt_index txtmisc_bow(t, i)

txt t;
txt_index i;
d92 1
a92 4
txt_index txtmisc_eow(t, i)

txt t;
txt_index i;
d118 2
a119 4
txt_index txtmisc_bol(t, i) /* beginning of line */

txt t;
txt_index i;
d131 2
a132 4
txt_index txtmisc_eol(t, i) /* end of line */

txt t;
txt_index i;
d148 1
a148 3
int txtmisc_bof(t)

txt t;
d153 1
a153 1
} 
d157 1
a157 3
int txtmisc_eof(t)

txt t;
d164 1
a164 3
unsigned txtmisc_currentlinenumber(t)

txt t;
a191 1
    
a192 1
void txtmisc_gotoline(t, l)
d194 1
a194 2
txt t;
unsigned l;
d228 1
a228 1
}    
d231 1
a231 3
static int txtmisc_blackch(c)

char c;
d237 1
a237 1
void txtmisc_tab(t)
a243 2
txt t;

d321 1
a321 3
void txtmisc_expandtabs(t)

txt t;
d338 1
a338 1
txt_setcharoptions(t, txt_DISPLAY, NULL); 
a370 1
   
a372 1
void txtmisc_indentregion(t, from, to, by, with)
d374 2
a375 4
txt t;
txt_index from, to;
int by;
char *with;
d430 1
a430 3
void txtmisc_exchangecrlf(t)

txt t; 
d470 1
a470 3
static BOOL txtmisc_iswhitespace(c)

char c;
d477 1
a477 4
BOOL txtmisc_isparaend(t, at)

txt t;
txt_index at;
d492 1
a492 3
void txtmisc_formattext(t, int width)

txt t;
d507 1
a507 1
txt_setcharoptions(t, txt_DISPLAY, NULL); 
d565 2
a566 4
txt_index txtmisc_furthestaway(t, from, a1, a2)

txt t;
txt_index from, a1, a2;
d577 1
a577 4
void txtmisc_select3(t, a1, a2, a3)

txt t;
txt_index a1, a2, a3;
d589 1
a589 4
void txtmisc_selectpointandword(t, point, word)

txt t;
txt_index point, word;
d613 1
a613 4
void txtmisc_selectpointandword(t, point, word)

txt t;
txt_index point, word;
d654 1
a654 4
void txtmisc_selectpointandline(t, point, line)

txt t;
txt_index point, line;
d668 1
a668 1
void txtmisc_clearselection()
d722 1
a722 1
char *a; 
d730 1
a730 1
   if (t == owner && deletesource && 
d732 1
a732 1
                
d737 1
a737 1
 
d837 1
a837 1
int txtmisc_textinsertfromflexistore(t, anchor, n)
a843 4

txt t;
flex_ptr anchor;
unsigned n;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

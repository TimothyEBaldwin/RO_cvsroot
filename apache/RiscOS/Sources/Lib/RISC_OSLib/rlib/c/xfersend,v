head	4.5;
access;
symbols
	RISC_OSLib-5_97:4.5
	RISC_OSLib-5_96:4.5
	RISC_OSLib-5_95:4.5
	RISC_OSLib-5_94:4.5
	RISC_OSLib-5_93:4.5
	RISC_OSLib-5_92:4.5
	RISC_OSLib-5_91:4.5
	RISC_OSLib-5_90:4.5
	RISC_OSLib-5_89:4.5
	RISC_OSLib-5_88:4.5
	RISC_OSLib-5_87:4.5
	RISC_OSLib-5_86-1:4.5
	RISC_OSLib-5_86:4.5
	RISC_OSLib-5_85:4.5
	RISC_OSLib-5_84:4.5
	RISC_OSLib-5_83-2:4.5
	RISC_OSLib-5_83-1:4.5
	RISC_OSLib-5_83:4.5
	RISC_OSLib-5_82:4.4
	RISC_OSLib-5_81:4.4
	RISC_OSLib-5_75-2:4.4
	RISC_OSLib-5_80:4.4
	RISC_OSLib-5_79:4.4
	RISC_OSLib-5_78:4.4
	RISC_OSLib-5_75-1:4.4
	RISC_OSLib-5_77:4.4
	RISC_OSLib-5_76:4.4
	RISC_OSLib-5_75:4.4
	RISC_OSLib-5_74:4.4
	RISC_OSLib-5_73:4.4
	RISC_OSLib-5_72:4.4
	RISC_OSLib-5_71:4.4
	RISC_OSLib-5_70:4.4
	RISC_OSLib-5_69:4.4
	RISC_OSLib-5_68:4.4
	RISC_OSLib-5_67:4.4
	RISC_OSLib-5_66:4.4
	RISC_OSLib-5_65:4.4
	RISC_OSLib-5_64:4.4
	RISC_OSLib-5_63:4.4
	RISC_OSLib-5_62:4.4
	RISC_OSLib-5_61:4.4
	RISC_OSLib-5_60:4.4
	RISC_OSLib-5_59:4.4
	RISC_OSLib-5_58:4.4
	RISC_OSLib-5_57:4.4
	RISC_OSLib-5_56:4.4
	RISC_OSLib-5_55:4.4
	RISC_OSLib-5_54:4.4
	RISC_OSLib-5_53:4.3
	RISC_OSLib-5_52:4.3
	RISC_OSLib-5_51:4.3
	RO_5_07:4.3
	RISC_OSLib-5_50:4.3
	RISC_OSLib-5_49:4.3
	RISC_OSLib-5_46-4_64_2_1:4.3
	NoInlineAsm:4.3.0.2
	RISC_OSLib-5_48:4.3
	RISC_OSLib-5_47:4.3
	RISC_OSLib-5_46:4.3
	RISC_OSLib-5_45:4.3
	RISC_OSLib-5_44:4.3
	RISC_OSLib-5_43:4.2
	RISC_OSLib-5_42:4.2
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2014.07.31.08.24.09;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	jfGiiZxupMtuqvKx;

4.4
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.15.15.00.32;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.59;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.30;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.31.55;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.50.12;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.16;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.xfersend
 * Purpose: generalised data transfer to a concurrent wimp program.
 * History: IDJ: 07-Feb-92: prepared for source release
 *
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#define USE_DRAGASPRITE 1

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "trace.h"
#include "swis.h"
#include "os.h"
#include "bbc.h"
#include "wimp.h"
#include "wimpt.h"
#include "win.h"
#include "dbox.h"
#include "xfersend.h"
#include "fileicon.h"
#include "werr.h"
#include "menu.h"
#include "event.h"
#include "msgs.h"
#include "dragasprit.h"
#include "VerIntern/messages.h"

static int xfersend__rcvbufsize;
static int xfersend__msgid = 0;           /* my_ref of last DataSave message */
static xfersend_saveproc xfersend__saveproc;
static xfersend_sendproc xfersend__sendproc;
static xfersend_printproc xfersend__printproc;
static int xfersend__filetype;
static void *xfersend__savehandle;
static int xfersend__estsize = 0;
static wimp_t xfersend__receiver;
static BOOL xfersend__fileissafe;
static char *xfersend__filename;  /*[256]*/

#ifdef SHARED_C_LIBRARY
static wimp_mousestr xfersend__mousestr = {0};
static wimp_msgstr xfersend__msg = {0};
#else
static wimp_mousestr xfersend__mousestr;
static wimp_msgstr xfersend__msg;
#endif

static BOOL xfersend__close = FALSE;
static wimp_w xfersend__w;

void xfersend_close_on_xfer (BOOL do_we_close, wimp_w w)
{
  xfersend__close = do_we_close;
  xfersend__w = w;
}

static void xfersend__winclose (void)
{
  wimp_eventdata e;
  e.o.w = xfersend__w;
  wimpt_noerr (wimp_sendwmessage (wimp_ECLOSE, (wimp_msgstr*) &e, e.o.w, -1));
}

#if USE_DRAGASPRITE
static BOOL xfersend__using_dragasprite (void)
{
  int r1, r2;

  r1 = 0x1c;
  os_byte (161, &r1, &r2);   /* read CMOS flag */
  return r2 & 0x02;
}
#endif

static int xfersend__suggest_leaf (wimp_msgdatasave *datasave)
{
  int i, tail, namelen;
  char name[256];
 
  if (xfersend__filename == NULL) xfersend__filename = malloc (256);
  strncpy (name, xfersend__filename, 256);
  namelen = tail = strlen (name); /* point at the zero */
  while (tail > 0 && name[tail-1] != '.' && name[tail-1] != ':')
    tail--;
 
  for (i = 0; tail <= namelen && i < (sizeof (datasave->leaf) - 1); i++)
    datasave->leaf[i] = name[tail++];
 
  datasave->leaf[i+1] = '\0';     /* force termination */
  tracef1 ("suggest leaf '%s'.\n", (int) datasave->leaf);
 
  return strlen(datasave->leaf) /* name */ + 1 /* terminator */;
}

static BOOL xfersend__unknowns (wimp_eventstr *e, void *handle)
{
  tracef1 ("xfersend raw event %i.\n", e->e);
  handle = handle;

  switch (e->e)
  {
    case wimp_EUSERDRAG:
    { /* finish my drag */
      tracef0 ("drag event received.\n");
#if USE_DRAGASPRITE
      if (xfersend__using_dragasprite ())
        dragasprite_stop ();
#endif
      wimp_get_point_info (&xfersend__mousestr);
      if (xfersend__mousestr.w != -1)
      {
        wimp_msgstr msg;
        int         leaflen;

        tracef1 ("drag to window %i: offer data.\n", xfersend__mousestr.w);
        leaflen = (xfersend__suggest_leaf(&msg.data.datasave) + 3) & ~3;
        msg.hdr.size = sizeof (wimp_msghdr)
                     + sizeof (wimp_msgdatasave)
                     - sizeof (msg.data.datasave.leaf)
                     + leaflen;
        msg.hdr.task = xfersend__mousestr.w;
        msg.hdr.your_ref = 0;
        msg.hdr.action = wimp_MDATASAVE;
        msg.data.datasave.w = xfersend__mousestr.w;
        msg.data.datasave.i = xfersend__mousestr.i;
        msg.data.datasave.x = xfersend__mousestr.x;
        msg.data.datasave.y = xfersend__mousestr.y;
        msg.data.datasave.type = xfersend__filetype;
        msg.data.datasave.estsize = xfersend__estsize;

        wimpt_noerr (wimp_sendwmessage (wimp_ESEND, &msg, xfersend__mousestr.w,
            xfersend__mousestr.i));
        xfersend__msgid = msg.hdr.my_ref; /* filled in by wimp. */
        /* We still get unknown events, so we'll get the reply sometime. */
      }
      else
        /* do nothing */
        tracef0 ("drag to no window: has no effect.\n");

      return TRUE;
    }
    break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
      tracef3 ("xfersend msg %x received: %i %i.\n",
          e->data.msg.hdr.action,e->data.msg.hdr.your_ref,xfersend__msgid);

      if (e->data.msg.hdr.your_ref == xfersend__msgid)
        switch (e->data.msg.hdr.action)
        {
          case wimp_MRAMFETCH:
            if (xfersend__sendproc != NULL)
            {
              xfersend__fileissafe = FALSE;

              /*He wants to do an in-core transfer, and we can do this. Note
                that this can't be other than the first response, as others
                are grabbed by sendbuf*/
              tracef0 ("ram transfer starting.\n");

              /* Prepare the reply record. */
              xfersend__msg = e->data.msg;
              xfersend__msg.hdr.your_ref = xfersend__msg.hdr.my_ref;
              xfersend__msg.hdr.action = wimp_MRAMTRANSMIT;
              xfersend__msg.data.ramtransmit.addr = e->data.msg.data.ramfetch.addr;
              xfersend__msg.data.ramtransmit.nbyteswritten = 0; /* so far. */
              xfersend__rcvbufsize = e->data.msg.data.ramfetch.nbytes;

              xfersend__receiver = e->data.msg.hdr.task;
              /*the copy in xfersend__msg.hdr.task is overwritten by the Wimp
                message sending */

              if (xfersend__sendproc (xfersend__savehandle, &xfersend__rcvbufsize))
              {
                /* See sendbuf for all the real work for this case... */

                tracef0 ("The send succeeded; send final RAMTRANSMIT.\n");

                /*We may have transferred some data but not yet told the
                  other end about it. xfersend__msg contains a final RAMTRANSMIT,
                  which does not quite fill his buffer (or we'd have sent it
                  already) thus signalling to him that the transfer is over.*/

                wimpt_noerr (wimp_sendmessage (wimp_ESEND, &xfersend__msg,
                    xfersend__receiver));
              }
              else
                tracef0 ("the send failed.\n");

              if (xfersend__close) xfersend__winclose ();
              return TRUE;
            }
          break;

          case wimp_MPrintFile: /* was dropped on a printer application*/
            /*From RISC O S 3.00, we always bounce this message. Printers will
              respond with a Message_DataSaveAck (if it wants a copy of the
              file), or Message_PrintTypeOdd (if it wants the file to be printed
              now).*/
            return TRUE;

          case wimp_MPrintTypeOdd: /*was dropped on a printer application with
              queue empty - print immediately*/
            if (xfersend__printproc != NULL)
            {
              wimp_t xfersend__printer;

              win_remove_unknown_event_processor (&xfersend__unknowns, 0);

              tracef0 ("immediate print request acceptable\n");
              xfersend__fileissafe = FALSE;

              /*Print the file now.*/
              (void) (*xfersend__printproc) (e->data.msg.data.print.name,
                  xfersend__savehandle);
                  /*reports errors, if any*/

              xfersend__printer = e->data.msg.hdr.task;
              xfersend__msg = e->data.msg;
              xfersend__msg.hdr.your_ref = xfersend__msg.hdr.my_ref;
              xfersend__msg.hdr.action = wimp_MPrintTypeKnown;
              wimpt_noerr (wimp_sendmessage (wimp_ESEND, &xfersend__msg,
                  xfersend__printer));
              if (xfersend__close) xfersend__winclose ();
            }
            /*If we weren't given a printproc, Printers' message bounces and
              it tries to copy the data away for printing via Message_
              DataSaveAck.*/

            /*In either case, the message has been handled successfully */
            return TRUE;
          break;

          case wimp_MPrintError:
            if (e->data.msg.hdr.size > 24)
              werr(FALSE, &e->data.msg.data.chars[4]);
            win_remove_unknown_event_processor (&xfersend__unknowns, 0);
            if (xfersend__close) xfersend__winclose ();
            return TRUE;
          break;

          case wimp_MDATASAVEOK:
            tracef4 ("datasaveok %i %i %i %i.\n",
                e->data.msg.hdr.size,
                e->data.msg.hdr.task,
                e->data.msg.hdr.your_ref,
                e->data.msg.hdr.my_ref);
            tracef4 ("datasaveok %x %x %x %x.\n",
                e->data.msg.data.words[0],
                e->data.msg.data.words[1],
                e->data.msg.data.words[2],
                e->data.msg.data.words[3]);
            tracef1 ("it's the datasaveok, to file '%s'.\n",
                (int) &e->data.msg.data.datasaveok.name[0]);

            win_remove_unknown_event_processor (&xfersend__unknowns, 0);

            tracef1 ("save to filename '%s'.\n",
                (int) &e->data.msg.data.datasaveok.name[0]);

            xfersend__fileissafe = e->data.msg.data.datasaveok.estsize >= 0;

            if (xfersend__saveproc != NULL &&
                xfersend__saveproc (&e->data.msg.data.datasaveok.name[0],
                xfersend__savehandle))
            { tracef0 ("the save succeeded: send dataload\n");

              xfersend__msg = e->data.msg;
                  /* sets hdr.size, data.w,i,x,y, size, name */
              xfersend__msg.hdr.your_ref = e->data.msg.hdr.my_ref;
              xfersend__msg.hdr.action = wimp_MDATALOAD;
              xfersend__msg.data.dataload.type = xfersend__filetype;
              wimpt_noerr (wimp_sendmessage (wimp_ESENDWANTACK, &xfersend__msg,
                  e->data.msg.hdr.task));
            }
            else
              /* he has already reported the error: nothing more to do. */
              tracef0 ("save was not successful.\n");

            if (xfersend__close) xfersend__winclose ();
            return xfersend__saveproc != NULL;
          break;
        }
    break;

    case wimp_EACK:
      /*If this is our Message_PrintSave being bounced, then we have to print the
         file now (according to the revised protocol 3 Apr '92). */
      if (e->data.msg.hdr.action == wimp_MPrintSave &&
          e->data.msg.hdr.my_ref == xfersend__msgid)
      {
        tracef0 ("no printer manager - printing direct\n");

        if (xfersend__printproc != NULL)
          (void) (*xfersend__printproc) (e->data.msg.data.print.name,
              xfersend__savehandle);
            /*This reports errors itself.*/
        else
          tracef0 ("no printing function supplied\n");

        return TRUE;
      }
    break;
  }
  return FALSE;
}

static int sendbuf__state;

static BOOL sendbuf__unknowns (wimp_eventstr *e, void *h)
{
 h = h;

 tracef4 ("sendbuf__unknowns %d %d %d %d\n",
          e->data.msg.hdr.my_ref, e->data.msg.hdr.your_ref,
          xfersend__msg.hdr.your_ref, xfersend__msg.hdr.my_ref);

 if ( (e->e == wimp_ESENDWANTACK || e->e == wimp_ESEND) &&
     e->data.msg.hdr.your_ref == xfersend__msg.hdr.my_ref &&
     e->data.msg.hdr.action == wimp_MRAMFETCH)
 {
  /* Prepare xfersend__msg as the next RAMTRANSMIT. Most of
  the fields are already set up. */

  xfersend__msg.data.ramtransmit.addr = e->data.msg.data.ramfetch.addr;
  xfersend__msg.data.ramtransmit.nbyteswritten = 0;
  xfersend__msg.hdr.your_ref = e->data.msg.hdr.my_ref;
  xfersend__rcvbufsize = e->data.msg.data.ramfetch.nbytes;

  tracef2 ("RAMFETCH received: continue with buffer at %x, size %d\n",
          (int) xfersend__msg.data.ramtransmit.addr, xfersend__rcvbufsize);

  sendbuf__state = 1;
  return TRUE;      /* We've had another RAMFETCH: off we go again */
 }

 if (e->e == wimp_EACK &&
    e->data.msg.hdr.my_ref == xfersend__msg.hdr.my_ref)
 {
  sendbuf__state = 2;
  tracef0 ("xfersend RAMTRANSMIT bounced; set failed state\n");
  return TRUE;/* our message bounced back; give up */
 }

 return FALSE;    /* we don't want it */
}


BOOL xfersend_sendbuf (char *buffer, int size)
{

/* Called by his sendproc when sending things in memory. The
reply record is in xfersend__msg. */

 tracef2 ("xfersend_sendbuf %i %i\n", (int) buffer, size);

 /* Make the data transfer */
 tracef3 ("transfer block of %d from %x to %x\n", size, (int) buffer,
          (int) (xfersend__msg.data.ramtransmit.addr +
            xfersend__msg.data.ramtransmit.nbyteswritten));

 wimpt_noerr (wimp_transferblock (wimpt_task (), buffer, xfersend__receiver,
      xfersend__msg.data.ramtransmit.addr +
      xfersend__msg.data.ramtransmit.nbyteswritten,
      size));

 /* record bytes to be sent to the other end */
 xfersend__msg.data.ramtransmit.nbyteswritten += size;
 xfersend__rcvbufsize -= size;

 /* if size != 0, there are still bytes to send. */

  if (xfersend__rcvbufsize > 0) return TRUE;

 tracef1 ("xfersend message has put %d into buffer\n",size);
 /* Tell him that you've done it */
 wimpt_noerr (wimp_sendmessage (wimp_ESENDWANTACK,
      &xfersend__msg,
      xfersend__receiver));

  /* Get his reply. Poll and despatch events until get nack or message */

 sendbuf__state = 0;

 win_add_unknown_event_processor (sendbuf__unknowns, 0);
 do event_process (); while (sendbuf__state == 0);
 win_remove_unknown_event_processor (sendbuf__unknowns, 0);

  /* This exit happens in the cases where the buffers at each end
      are of identical size. So, return for another call to sendbuf, or
      so that the sendbuf procedure can return. */

 return sendbuf__state != 2;  /* OK unless state = broken */
}

BOOL xfersend (int filetype, char *filename, int estsize,
   xfersend_saveproc saver, xfersend_sendproc sender, xfersend_printproc printer,
   wimp_eventstr *e, void *handle)

{
   wimp_wstate wstate;
   wimp_icon icon;
   wimp_w w = e->data.but.m.w;
   wimp_mousestr mouse_str;
   int
      x_limit = bbc_vduvar (bbc_XWindLimit) << bbc_vduvar (bbc_XEigFactor),
      y_limit = bbc_vduvar (bbc_YWindLimit) << bbc_vduvar (bbc_YEigFactor),
      x0, y0, x1, y1;
   int screen_x0;
   int screen_y0;

   xfersend__saveproc = saver;
   xfersend__sendproc = sender;
   xfersend__printproc = printer;
   xfersend__filetype = filetype;
   xfersend__estsize = estsize;
   xfersend__savehandle = handle;
   if (xfersend__filename == NULL) xfersend__filename = malloc (256);
   if (filename == NULL)
      strcpy (xfersend__filename, msgs_lookup (MSGS_xfersend2));
   else
      strncpy (xfersend__filename,filename,256);

   tracef0 ("Initiate a drag.\n");

   /*Find screen origin*/
   wimp_get_wind_state (w, &wstate);
   screen_x0 = wstate.o.box.x0 - wstate.o.x;
   screen_y0 = wstate.o.box.y1 - wstate.o.y;

   /*Get initial icon position*/
   wimp_get_icon_info (w, e->data.but.m.i, &icon);
   x0 = icon.box.x0 += screen_x0;
   y0 = icon.box.y0 += screen_y0;
   x1 = icon.box.x1 += screen_x0;
   y1 = icon.box.y1 += screen_y0;

#if USE_DRAGASPRITE
   if (xfersend__using_dragasprite ())
   {
      char *name;
      sprite_area *area;
      BOOL semi = TRUE;

      if (icon.flags & wimp_ITEXT)
      {  /* Indirect, sprite, text. Pick up the sprite name from
            the validation string */
         area = wimp_spritearea;
         name = icon.data.indirecttext.validstring;
         while (*name)
         {
           if (((*name == 'S') || (*name == 's')) && semi)
           {
              name++; break;
           }
           semi = (*name == ';');
           name++; 
         }
      }
      else
      {  /* Indirect, sprite, no text. As DragASprite always needs a
            sprite name, the 'nameisname' field is assumed non 0 */
         area = icon.data.indirectsprite.spritearea;
         name = icon.data.indirectsprite.name;
      }

      wimpt_complain (dragasprite_start (dragasprite_HJUSTIFY_CENTRE |
          dragasprite_VJUSTIFY_CENTRE | dragasprite_BOUNDTO_SCREEN |
          dragasprite_BOUND_POINTER | dragasprite_DROPSHADOW_PRESENT,
          area, name, &icon.box, NULL));
   }
   else   /* not using dragasprite */
   {
      /*Get pointer position to allow icon to be dragged partially off-screen */
      int mouse_x,mouse_y;
      wimp_dragstr dr;
      wimp_get_point_info (&mouse_str);
      mouse_x = mouse_str.x;
      mouse_y = mouse_str.y;

      /*Set up drag*/
      dr.window    = w; /*not relevant*/
      dr.type      = wimp_USER_FIXED;
      dr.box.x0    = x0;
      dr.box.y0    = y0;
      dr.box.x1    = x1;
      dr.box.y1    = y1;
      dr.parent.x0 = x0 - mouse_x; /*Expanded parent by box overlap*/
      dr.parent.y0 = y0 - mouse_y;
      dr.parent.x1 = x1 - mouse_x + x_limit;
      dr.parent.y1 = y1 - mouse_y + y_limit;
      wimp_drag_box (&dr);
   }
#else
   /*Get pointer position to allow icon to be dragged partially off-screen. */
   wimp_get_point_info (&mouse_str);
   mouse_x = mouse_str.x;
   mouse_y = mouse_str.y;

   /*Set up drag*/
   dr.window    = w; /*not relevant*/
   dr.type      = wimp_USER_FIXED;
   dr.box.x0    = x0;
   dr.box.y0    = y0;
   dr.box.x1    = x1;
   dr.box.y1    = y1;
   dr.parent.x0 = x0 - mouse_x; /*Expanded parent by box overlap*/
   dr.parent.y0 = y0 - mouse_y;
   dr.parent.x1 = x1 - mouse_x + x_limit;
   dr.parent.y1 = y1 - mouse_y + y_limit;
   wimp_drag_box (&dr);
#endif

   win_add_unknown_event_processor (&xfersend__unknowns, NULL);
   return TRUE;
}

BOOL xfersend_print (int type, char *filename, int estsize,
   xfersend_saveproc saver, xfersend_sendproc sender, xfersend_printproc printer,
   void *handle)

{
   xfersend__saveproc = saver;
   xfersend__sendproc = sender;
   xfersend__printproc = printer;
   xfersend__filetype = type;
   xfersend__estsize = estsize;
   xfersend__savehandle = handle;
   if (xfersend__filename == NULL &&
        (xfersend__filename = malloc (256)) == NULL)
      return FALSE;

   sprintf (xfersend__filename, "%.256s", filename != NULL ? filename:
       msgs_lookup (MSGS_xfersend2));

   /*Broadcast a PrintSave message. The printer will reply with PrintFile
     (which we ignore in RISC O S 3.00)), then DataSaveAck which is caught by
      xfersend__unknowns ().*/
   xfersend__msg.hdr.size = sizeof (wimp_msghdr) +
         sizeof (wimp_msgdatasave);
   xfersend__msg.hdr.your_ref = 0;
   xfersend__msg.hdr.action = wimp_MPrintSave;
   xfersend__msg.data.datasave.estsize = estsize; /*this is PrintSave not
         DataSave, but it matches (apart from w, i, x, y not used)*/
   xfersend__msg.data.datasave.type = type;
   sprintf (xfersend__msg.data.datasave.leaf, "%.*s",
         sizeof xfersend__msg.data.datasave.leaf - 1, xfersend__filename);

   tracef1 ("sending Message_PrintSave \"%s\"\n",
         xfersend__msg.data.datasave.leaf);
   wimpt_noerr (wimp_sendmessage (wimp_ESENDWANTACK, &xfersend__msg, NULL));

   tracef1 ("message id is %d\n", xfersend__msg.hdr.my_ref);
   xfersend__msgid = xfersend__msg.hdr.my_ref; /*Filled in by WIMP.*/

   tracef0 ("adding unknown event processor\n");
   win_add_unknown_event_processor (&xfersend__unknowns, NULL);

   return TRUE;
}

BOOL xfersend_pipe(int filetype, char *filename, int estsize,
                     xfersend_saveproc saver,
                     xfersend_sendproc sender,
                     xfersend_printproc printer,
                     wimp_eventstr *e, void *handle)
{
      xfersend__saveproc = saver;
      xfersend__sendproc = sender;
      xfersend__printproc = printer;
      xfersend__filetype = filetype;
      xfersend__estsize = estsize;
      xfersend__savehandle = handle;
      if (xfersend__filename == NULL) xfersend__filename = malloc (256);
      if (filename == NULL)
        strcpy (xfersend__filename, msgs_lookup (MSGS_xfersend2));
      else
        strncpy (xfersend__filename,filename,256);

      {
        wimp_msgstr msg;
        int         leaflen;

        leaflen = (xfersend__suggest_leaf(&msg.data.datasave) + 3) & ~3;
        msg.hdr.size = sizeof (wimp_msghdr)
                     + sizeof (wimp_msgdatasave)
                     - sizeof (msg.data.datasave.leaf)
                     + leaflen;
        msg.hdr.your_ref = e->data.msg.hdr.my_ref;
        msg.hdr.action = wimp_MDATASAVE;
        msg.data.datasave.w = e->data.msg.data.datarequest.w;
        msg.data.datasave.i = (wimp_i)e->data.msg.data.datarequest.h;
        msg.data.datasave.x = e->data.msg.data.datarequest.x;
        msg.data.datasave.y = e->data.msg.data.datarequest.y;
        msg.data.datasave.type = xfersend__filetype;
        msg.data.datasave.estsize = xfersend__estsize;

        wimpt_noerr (wimp_sendmessage (wimp_ESEND, &msg, e->data.msg.hdr.task));
        xfersend__msgid = msg.hdr.my_ref; /* filled in by wimp. */
      }

      win_add_unknown_event_processor (&xfersend__unknowns, 0);
      return TRUE;
}

BOOL xfersend_file_is_safe(void)
{
  return xfersend__fileissafe;
}

void xfersend_set_fileissafe(BOOL value)
{
  xfersend__fileissafe = value;
}

void xfersend_clear_unknowns(void)
{
  win_remove_unknown_event_processor (sendbuf__unknowns, 0);
  win_remove_unknown_event_processor (&xfersend__unknowns, 0);
}

int xfersend_read_last_ref(void)
{
  return xfersend__msgid;        /* my_ref of last DataSave message */
}

/* end xfersend.c */
@


4.4
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d62 1
a62 1
static int rcvbufsize;
a73 2
static int Unused; /*future expansion?*/

d87 2
a88 2
   xfersend__close = do_we_close;
   xfersend__w = w;
d93 3
a95 3
   wimp_eventdata e;
   e.o.w = xfersend__w;
   wimpt_noerr (wimp_sendwmessage (wimp_ECLOSE, (wimp_msgstr*) &e, e.o.w, -1));
d101 1
a101 1
   int r1, r2;
d103 3
a105 3
   r1 = 0x1c;
   os_byte (161, &r1, &r2);   /* read CMOS flag */
   return r2 & 0x02;
d109 20
d139 4
a142 4
      #if USE_DRAGASPRITE
        if (xfersend__using_dragasprite)
          dragasprite_stop ();
      #endif
d147 1
d150 5
a154 1
        msg.hdr.size = sizeof (wimp_msghdr) + sizeof (wimp_msgdatasave);
a164 18
        {
          int i, tail, namelen;
          char name[256];

          if (xfersend__filename == 0) xfersend__filename = malloc (256);
          strncpy (name,xfersend__filename,  256);
          tail = strlen (name); /* point at the zero */
          while (tail > 0 && name[tail-1] != '.' && name[tail-1] != ':')
               tail--;

          namelen = strlen(name);
          for (i = 0; tail <= namelen && i < 211; i++)
            msg.data.datasave.leaf[i] = name[tail++];

          msg.data.datasave.leaf[i+1] = '\0';     /* force termination */
          tracef1 ("suggest leaf '%s'.\n", (int) &msg.data.datasave.leaf[0]);
        }

d187 1
a187 1
            if (xfersend__sendproc != 0)
d202 1
a202 1
              rcvbufsize = e->data.msg.data.ramfetch.nbytes;
d208 1
a208 1
              if (xfersend__sendproc (xfersend__savehandle, &rcvbufsize))
d363 1
a363 1
  rcvbufsize = e->data.msg.data.ramfetch.nbytes;
d366 1
a366 1
          (int) xfersend__msg.data.ramtransmit.addr, rcvbufsize);
d404 1
a404 1
 rcvbufsize -= size;
d408 1
a408 1
  if (rcvbufsize > 0) return TRUE;
a445 4
#if USE_DRAGASPRITE
   char *name;
   sprite_area *area;
#endif
d453 2
a454 2
   if (xfersend__filename == 0) xfersend__filename = malloc (256);
   if (filename == 0)
d476 4
a479 1
      /* Find the sprite name and area */
d481 13
a493 2
      {  area = wimp_spritearea;
         name = strstr ( icon.data.indirecttext.validstring, ";s" ) + 2;
d496 3
a498 1
      {  area = icon.data.indirectsprite.spritearea;
d568 1
a568 1
   sprintf (xfersend__filename, "%.256s", filename != 0? filename:
a596 1
#ifndef UROM
d601 1
a601 1
                     void *handle, wimp_t task)
d609 2
a610 2
      if (xfersend__filename == 0) xfersend__filename = malloc (256);
      if (filename == 0)
d615 1
a615 1
        {
d617 1
d619 6
a624 3
        msg.hdr.size = sizeof (wimp_msghdr) + sizeof (wimp_msgdatasave);
        msg.hdr.task = task;
        msg.hdr.your_ref = 0;
d626 4
a629 4
        msg.data.datasave.w = 0; /* kludge, it's not being sent to a window!! */
        msg.data.datasave.i = 0;
        msg.data.datasave.x = 0;
        msg.data.datasave.y = 0;
d632 2
a633 16
        {
          int i, tail, namelen;
          char name[256];
          if (xfersend__filename == 0) xfersend__filename = malloc (256);
          strncpy (name,xfersend__filename,  256);
          tail = strlen (name); /* point at the zero */
          while (tail > 0 && name[tail-1] != '.' && name[tail-1] != ':')
               tail--;

          namelen = strlen(name);
          for (i = 0; /*i <= 10*/ tail <= namelen && i < 211; i++)
            msg.data.datasave.leaf[i] = name[tail++];
          msg.data.datasave.leaf[i+1] = '\0';     /* force termination */
          tracef1 ("suggest leaf '%s'.\n", (int) &msg.data.datasave.leaf[0]);
        };
        wimpt_noerr (wimp_sendmessage (wimp_ESEND, &msg, task));
a639 1
#endif
d653 2
a654 2
   win_remove_unknown_event_processor (sendbuf__unknowns, 0);
   win_remove_unknown_event_processor (&xfersend__unknowns, 0);
@


4.3
log
@ROM build fixed for 64-bit stuff.
PCI added to swis.h
alloc.c updated to handle bigger slots (new code merged from ARM libraries)
Various 32-bit fixes for backtracing, and general trap handling.
Polite "Application is not 32-bit compatible" message.
Headers <stdint.h> and <inttypes.h> fixed to work in non-C99 mode.
txt changed to do new-style Delete behaviour

Version 5.44. Tagged as 'RISC_OSLib-5_44'
@
text
@d60 1
a60 1
#include "h.verintern.messages"
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d77 2
a78 2
static wimp_mousestr xfersend__mousestr = {};
static wimp_msgstr xfersend__msg = {};
@


4.1
log
@Initial revision
@
text
@d15 15
a29 1
/* Title: -> c.xfersend
d31 2
a32 11
 * IDJ: 15-Jan-90: As war is about to break out in the Gulf, bug found 
 *                 in printing.  previously receiver variable unset
 *                 so everything worked except after RAM transfer
 *                 Now this should also be "re-entrant" even if client
 *                 polls wimp during printing.
 * ECN: 08-May-91: #ifndefed out unused ROM functions
 * IDJ: 01-Jul-91: don't truncate leafnames in xfersend 
 * JRC 5 Apr '92: New protocol for printing implemented in xfersend__unknowns ():
 *    now always queues for printing, printing immediately if necessary. Affects
 *    the use of xfersend_print () (extra argument) and xfersend () (the printproc
 *    is used if necessary).
d88 2
a89 1
{  xfersend__close = do_we_close;
d94 2
a95 1
{  wimp_eventdata e;
d112 2
a113 2

{ tracef1 ("xfersend raw event %i.\n", e->e);
d117 2
a118 1
  { case wimp_EUSERDRAG:
d127 2
a128 1
      { wimp_msgstr msg;
d142 2
a143 1
        { int i, tail;
d152 2
a153 1
          for (i = 0; /*i <= 10*/ tail <= strlen (name) && i < 211; i++)
d180 2
a181 1
        { case wimp_MRAMFETCH:
d183 3
a185 2
            { xfersend__fileissafe = FALSE;
            
d204 3
a206 2
              { /* See sendbuf for all the real work for this case... */
              
d213 1
a213 1
                  
a231 26
            #if 0
            /*what it used to do ...*/
            if (xfersend__printproc != 0)
            { int res;
              wimp_t xfersend__printer = 0;

              tracef0 ("print request acceptable\n");
              xfersend__fileissafe = FALSE;

              res = xfersend__printproc (&e->data.msg.data.print.name[0],
                  xfersend__savehandle);

              xfersend__printer = e->data.msg.hdr.task;
              xfersend__msg = e->data.msg;
              xfersend__msg.hdr.your_ref = xfersend__msg.hdr.my_ref;
              xfersend__msg.hdr.action =
              res >= 0 ? wimp_MDATALOAD : wimp_MWillPrint;
              xfersend__msg.data.print.type = res;  /* in case it's been saved */
              wimpt_noerr (wimp_sendmessage (wimp_ESEND, &xfersend__msg,
                  xfersend__printer));
              if (xfersend__close) xfersend__winclose ();
              return TRUE;
            }
            #endif
          break;

d235 3
a237 2
            { wimp_t xfersend__printer;
              
d260 1
a260 2
            /*In either case, the message has been handled successfully, and
               I finally get to fix this bug! J R C 4th Oct 1993*/
a263 2
          /* JSR 18-1-94 Added response to MPrintError */
          /* Only report error if there is one. J R C 21st Jan 1994*/
a291 1
              /* BUG before 4.13 */
a315 19
    #if FALSE
    /*This is a pile of garbage - never recognised cos msgid == my_ref, not
      your_ref!). In any case this is a silly error message and should not be
      displayed*/
    case wimp_EACK:
    if (e->data.msg.hdr.your_ref == xfersend__msgid &&
        e->data.msg.hdr.action == wimp_MDATALOAD)
    {
      /* It looks as if he hasn't acknowledged my DATALOAD acknowledge:
      thus it may be a loose scrap file, and must be deleted. */
      char a[256];
      tracef0 ("unack'd data load of temp file, so delete the file\n");
      werr (FALSE, msgs_lookup (MSGS_xfersend1));
      sprintf (a, "%%delete %s", &xfersend__msg.data.dataload.name[0]);
      os_cli (a);
    }
    return TRUE;
    #endif

d318 1
a318 1
         file now (according to the revised protocol 3 Apr '92). JRC.*/
d321 2
a322 1
      { tracef0 ("no printer manager - printing direct\n");
d330 1
a330 1
        
d430 2
a431 1
{  wimp_wstate wstate;
d474 2
a475 1
   {  /* Find the sprite name and area */
d491 2
a492 2
   {  /*Get pointer position to allow icon to be dragged
         partially off-screen. JRC 9 Nov '89*/
d510 1
a510 1
      wimp_drag_box (&dr);    
d513 1
a513 2
   /*Get pointer position to allow icon to be dragged
      partially off-screen. JRC 9 Nov '89*/
d529 1
a529 1
   wimp_drag_box (&dr);  
d540 2
a541 1
{  xfersend__saveproc = saver;
d581 1
a581 1
BOOL xfersend_pipe (int filetype, char *filename, int estsize,
a586 1

d598 1
a598 1
      
d606 1
a606 3
        msg.data.datasave.w = 0; /* kludge, it's not being sent to a
                                        window!! Hope the wimp doesn't
                                        check this */
d613 1
a613 1
          int i, tail;
d621 2
a622 1
          for (i = 0; /*i <= 10*/ tail <= strlen (name) && i < 211; i++)
d630 1
a630 1
  
d635 4
a638 3
                     
BOOL xfersend_file_is_safe ()
{  return xfersend__fileissafe;
d641 3
a643 2
void xfersend_set_fileissafe (BOOL value)
{  xfersend__fileissafe = value;
d646 1
a646 1
void xfersend_clear_unknowns (void)
d652 1
a652 1
int xfersend_read_last_ref (void)
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 1
a15 15
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.xfersend
d17 11
a27 2
 * History: IDJ: 07-Feb-92: prepared for source release
 *
d83 1
a83 2
{
   xfersend__close = do_we_close;
d88 1
a88 2
{
   wimp_eventdata e;
d105 2
a106 2
{
  tracef1 ("xfersend raw event %i.\n", e->e);
d110 1
a110 2
  {
    case wimp_EUSERDRAG:
d119 1
a119 2
      {
        wimp_msgstr msg;
d133 1
a133 2
        {
          int i, tail, namelen;
d142 1
a142 2
          namelen = strlen(name);
          for (i = 0; tail <= namelen && i < 211; i++)
d169 1
a169 2
        {
          case wimp_MRAMFETCH:
d171 2
a172 3
            {
              xfersend__fileissafe = FALSE;

d191 2
a192 3
              {
                /* See sendbuf for all the real work for this case... */

d199 1
a199 1

d218 26
d247 2
a248 3
            {
              wimp_t xfersend__printer;

d271 2
a272 1
            /*In either case, the message has been handled successfully */
d276 2
d306 1
d331 19
d352 1
a352 1
         file now (according to the revised protocol 3 Apr '92). */
d355 1
a355 2
      {
        tracef0 ("no printer manager - printing direct\n");
d363 1
a363 1

d463 1
a463 2
{
   wimp_wstate wstate;
d506 1
a506 2
   {
      /* Find the sprite name and area */
d522 2
a523 2
   {
      /*Get pointer position to allow icon to be dragged partially off-screen */
d541 1
a541 1
      wimp_drag_box (&dr);
d544 2
a545 1
   /*Get pointer position to allow icon to be dragged partially off-screen. */
d561 1
a561 1
   wimp_drag_box (&dr);
d572 1
a572 2
{
   xfersend__saveproc = saver;
d612 1
a612 1
BOOL xfersend_pipe(int filetype, char *filename, int estsize,
d618 1
d630 1
a630 1

d638 3
a640 1
        msg.data.datasave.w = 0; /* kludge, it's not being sent to a window!! */
d647 1
a647 1
          int i, tail, namelen;
d655 1
a655 2
          namelen = strlen(name);
          for (i = 0; /*i <= 10*/ tail <= namelen && i < 211; i++)
d663 1
a663 1

d668 3
a670 4

BOOL xfersend_file_is_safe(void)
{
  return xfersend__fileissafe;
d673 2
a674 3
void xfersend_set_fileissafe(BOOL value)
{
  xfersend__fileissafe = value;
d677 1
a677 1
void xfersend_clear_unknowns(void)
d683 1
a683 1
int xfersend_read_last_ref(void)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

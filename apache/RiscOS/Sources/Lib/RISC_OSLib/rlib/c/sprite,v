head	4.5;
access;
symbols
	RISC_OSLib-5_97:4.5
	RISC_OSLib-5_96:4.5
	RISC_OSLib-5_95:4.5
	RISC_OSLib-5_94:4.5
	RISC_OSLib-5_93:4.5
	RISC_OSLib-5_92:4.5
	RISC_OSLib-5_91:4.5
	RISC_OSLib-5_90:4.5
	RISC_OSLib-5_89:4.5
	RISC_OSLib-5_88:4.5
	RISC_OSLib-5_87:4.5
	RISC_OSLib-5_86-1:4.5
	RISC_OSLib-5_86:4.5
	RISC_OSLib-5_85:4.5
	RISC_OSLib-5_84:4.5
	RISC_OSLib-5_83-2:4.5
	RISC_OSLib-5_83-1:4.5
	RISC_OSLib-5_83:4.5
	RISC_OSLib-5_82:4.5
	RISC_OSLib-5_81:4.5
	RISC_OSLib-5_75-2:4.5
	RISC_OSLib-5_80:4.5
	RISC_OSLib-5_79:4.5
	RISC_OSLib-5_78:4.5
	RISC_OSLib-5_75-1:4.5
	RISC_OSLib-5_77:4.5
	RISC_OSLib-5_76:4.5
	RISC_OSLib-5_75:4.5
	RISC_OSLib-5_74:4.5
	RISC_OSLib-5_73:4.5
	RISC_OSLib-5_72:4.5
	RISC_OSLib-5_71:4.5
	RISC_OSLib-5_70:4.5
	RISC_OSLib-5_69:4.5
	RISC_OSLib-5_68:4.5
	RISC_OSLib-5_67:4.5
	RISC_OSLib-5_66:4.5
	RISC_OSLib-5_65:4.5
	RISC_OSLib-5_64:4.5
	RISC_OSLib-5_63:4.5
	RISC_OSLib-5_62:4.5
	RISC_OSLib-5_61:4.5
	RISC_OSLib-5_60:4.5
	RISC_OSLib-5_59:4.5
	RISC_OSLib-5_58:4.5
	RISC_OSLib-5_57:4.4
	RISC_OSLib-5_56:4.4
	RISC_OSLib-5_55:4.4
	RISC_OSLib-5_54:4.4
	RISC_OSLib-5_53:4.3
	RISC_OSLib-5_52:4.3
	RISC_OSLib-5_51:4.3
	RO_5_07:4.3
	RISC_OSLib-5_50:4.3
	RISC_OSLib-5_49:4.3
	RISC_OSLib-5_46-4_64_2_1:4.3
	NoInlineAsm:4.3.0.2
	RISC_OSLib-5_48:4.3
	RISC_OSLib-5_47:4.3
	RISC_OSLib-5_46:4.3
	RISC_OSLib-5_45:4.3
	RISC_OSLib-5_44:4.2
	RISC_OSLib-5_43:4.2
	RISC_OSLib-5_42:4.2
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2010.11.30.09.29.08;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.3;

4.3
date	2003.01.16.12.43.31;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.55;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.13;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.13;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.00;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.30.55;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.43;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.15;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Enable 2 functions in RISC_OSLib shared entry table.
Needed by !Paint 2.02.
Fix some easy warnings in wimp.c/sprite.c.
Add new function (not in the ROM version) 'wimp_baseofromsprites()'.
bbc_adval fixed to return -1 when no ADC fitted to match Electron behaviour.
Note: the 2 reenabled functions haven't been appended to the table, so anyone who linked a RAM application against 'romastubs' would need to relink.

Version 5.58. Tagged as 'RISC_OSLib-5_58'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/*
 * Title  : c.sprite
 * Purpose: provide access to RISC OS sprite facilities
 * History: IDJ: 07-Feb-92: prepared for source release
 *
 */

#include <stddef.h>
#include "os.h"

#include "sprite.h"


/* Basic primitive used by sprite_xxx calls */

#define OS_SpriteOp 0x2E

#define ScreenSave            2
#define ScreenLoad            3

#define ReadAreaCB            8  /* *SInfo */
#define ClearSprites          9  /* *SNew */
#define LoadSpriteFile        10 /* *SLoad <filename> */
#define MergeSpriteFile       11 /* *SMerge <filename> */
#define SaveSpriteFile        12 /* *SSave <filename> */
#define ReturnName            13
#define GetSprite             14 /* *SGet <n> */
#define CreateSprite          15
#define GetSpriteUserCoords   16

#define SelectSprite          24 /* *SChoose <n> [<m>] */
#define DeleteSprite          25 /* *SDelete <n> */
#define RenameSprite          26 /* *SRename */
#define CopySprite            27
#define PutSprite             28
#define CreateMask            29
#define RemoveMask            30
#define InsertRow             31
#define DeleteRow             32
#define FlipAboutXAxis        33
#define PutSpriteUserCoords   34
#define AppendSprite          35
#define SetPointerShape       36

#define ReadSpriteSize        40
#define ReadPixelColour       41
#define WritePixelColour      42
#define ReadPixelMask         43
#define WritePixelMask        44
#define InsertCol             45
#define DeleteCol             46
#define FlipAboutYAxis        47
#define PlotMask              48
#define PlotMaskUserCoords    49

#define PlotMaskScaled        50
#define PaintCharScaled       51
#define PutSpriteScaled       52
#define PutSpriteGreyScaled   53
#define RemoveLeftHandWastage 54
#define PlotMaskTransformed   55
#define PutSpriteTransformed  56
#define InsertDeleteRows      57
#define InsertDeleteColumns   58

#define SwitchOutputToSprite  60
#define SwitchOutputToMask    61
#define ReadSaveAreaSize      62

#define BadReasonCode         63

#pragma -s1

static os_error * sprite__op(os_regset *r)
{
  return os_swix(OS_SpriteOp, r);
}


/******** Simple operations, use no sprite area, no name/sprite pointer ***/

#ifndef UROM
os_error * sprite_screensave(const char *filename, sprite_palflag palflag)
{
  os_regset r;
  os_error *result;
  r.r[0] = 2;
/*r.r[1] unused */
  r.r[2] = (int) filename;
  r.r[3] = palflag;
  result = sprite__op(&r);
  return result;
}
#endif

#ifndef UROM
os_error * sprite_screenload(const char *filename)
{
  os_regset r;
  os_error *result;
  r.r[0] = 3;
/*r.r[1] unused */
  r.r[2] = (int) filename;
  result = sprite__op(&r);
  return result;
}
#endif

/****** Operations on either system/user area, no name/sprite pointer *****/

static void setfromarea(int op, sprite_area *area, os_regset *r)
{
  if (area == sprite_mainarea)
  {
    r->r[0] = op;
/*  r->r[1] unused */
  }
  else
  {
    r->r[0] = op + 256;
    r->r[1] = (int) area;
  }
}


void sprite_area_initialise(sprite_area *area, int length)
{
  area->size    = length; /* No SpriteOp to do this ! */
  area->number  = 0;
  area->sproff  = 16;
  area->freeoff = 16;
}


os_error * sprite_area_readinfo(sprite_area *area, sprite_area *resultarea)
{
  os_regset r;
  os_error *result;
  setfromarea(8, area, &r);
  result = sprite__op(&r);
  if (result == NULL) /* Only return result if no error */
  {
    resultarea->size    = r.r[2];
    resultarea->number  = r.r[3];
    resultarea->sproff  = r.r[4];
    resultarea->freeoff = r.r[5];
  }
  return result;
}


#ifndef UROM
os_error * sprite_area_reinit(sprite_area *area)
{
  os_regset r;
  os_error *result;
  setfromarea(9, area, &r);
  result = sprite__op(&r);
  return result;
}
#endif

os_error * sprite_area_save(sprite_area *area, const char *filename)
{
  os_regset r;
  os_error *result;
  os_filestr file;
  int oldattribs = -1;

  file.action = 17; /* Read cat info */
  file.name = (char *) filename;
  (void) os_file(&file);
  /* if something is already there,remember its attributes */
  if (file.action != 0) oldattribs = file.end;
  
  setfromarea(12, area, &r);
  r.r[2] = (int) filename;
  result = sprite__op(&r); /* Save */

  if (oldattribs != -1) {
    file.action = 4; /* Write attribs */
    file.end = oldattribs;
    (void) os_file(&file);
  };

  return result;
}


os_error * sprite_area_load(sprite_area *area, const char *filename)
{
  os_regset r;
  os_error *result;
  setfromarea(10, area, &r);
  r.r[2] = (int) filename;
  result = sprite__op(&r);
  return result;
}

#ifndef UROM
os_error * sprite_area_merge(sprite_area *area, const char *filename)
{
  os_regset r;
  os_error *result;
  setfromarea(11, area, &r);
  r.r[2] = (int) filename;
  result = sprite__op(&r);
  return result;
}
#endif

os_error * sprite_getname(sprite_area *area, void *buffer,
                          int *length, int index)
{
  os_regset r;
  os_error *result;
  setfromarea(13, area, &r);
  r.r[2] = (int) buffer;
  r.r[3] = *length;
  r.r[4] = index;
  result = sprite__op(&r);
  if (result == NULL) /* Only return result if no error */
  {
    *length = r.r[3];
  }
  return result;
}

#ifndef UROM
os_error * sprite_get(sprite_area *area, char *name, sprite_palflag palflag)
{
  os_regset r;
  os_error *result;
  setfromarea(14, area, &r);
  r.r[2] = (int) name;
  r.r[3] = palflag;
  result = sprite__op(&r);
  return result;
}
#endif

#ifndef UROM
os_error * sprite_get_rp(sprite_area *area, char *name, sprite_palflag palflag,
                         sprite_ptr *resultaddress)
{
  os_regset r;
  os_error *result;
  setfromarea(14, area, &r);
  r.r[2] = (int) name;
  r.r[3] = palflag;
  result = sprite__op(&r);
  if (result == NULL) /* Only return result if no error */
  {
    *resultaddress = (void *) r.r[2];
  }
  return result;
}
#endif

os_error * sprite_get_given(sprite_area *area, char *name,
                            sprite_palflag palflag,
                            int x0, int y0, int x1, int y1)
{
  os_regset r;
  os_error *result;
  setfromarea(16, area, &r);
  r.r[2] = (int) name;
  r.r[3] = palflag;
  r.r[4] = x0;
  r.r[5] = y0;
  r.r[6] = x1;
  r.r[7] = y1;
  result = sprite__op(&r);
  return result;
}

os_error * sprite_get_given_rp(sprite_area *area, char *name,
                               sprite_palflag palflag, int x0, int y0,
                               int x1, int y1, sprite_ptr *resultaddress)
{
  os_regset r;
  os_error *result;
  setfromarea(16, area, &r);
  r.r[2] = (int) name;
  r.r[3] = palflag;
  r.r[4] = x0;
  r.r[5] = y0;
  r.r[6] = x1;
  r.r[7] = y1;
  result = sprite__op(&r);
  if (result == NULL) /* Only return result if no error */
  {
    *resultaddress = (void *) r.r[2];
  }
  return result;
}

os_error * sprite_create(sprite_area *area, char *name, sprite_palflag palflag,
                         int width, int height, int mode)
{
  os_regset r;
  os_error *result;
  setfromarea(15, area, &r); /* NB. Not all done in numeric order !! */
  r.r[2] = (int) name;
  r.r[3] = palflag;
  r.r[4] = width;
  r.r[5] = height;
  r.r[6] = mode;
  result = sprite__op(&r);
  return result;
}

os_error * sprite_create_rp(sprite_area *area, char *name,
                            sprite_palflag palflag,
                            int width, int height, int mode,
                            sprite_ptr *resultaddress)
{
  os_regset r;
  os_error *result;
  setfromarea(15, area, &r); /* NB. Not all done in numeric order !! */
  r.r[2] = (int) name;
  r.r[3] = palflag;
  r.r[4] = width;
  r.r[5] = height;
  r.r[6] = mode;
  result = sprite__op(&r);
  if (result == NULL) /* Only return result if no error */
  {
    /* spriteop 15 doesn't return pointer to sprite in r2, so....*/
    /* select the sprite just created (gets its address in r2) */
    setfromarea(24, area, &r);
    r.r[2] = (int)name;
    result = sprite__op(&r);
    if (result == NULL)
       *resultaddress = (void *) r.r[2];
  }
  return result;
}

/*********** Operations on system/user area, name/sprite pointer **********/

/* Modify op if using sprite address is address, not name */
/* But only if using own sprite area */
static void setfromtag(int op, sprite_area *area, sprite_id *spr, os_regset *r)
{
  if (area == sprite_mainarea)
  {
    r->r[0] = op;
 /* r->r[1] unused */
  }
  else
  {
    r->r[1] = (int) area;
    if ((spr->tag) == sprite_id_addr)
    {
      r->r[0] = 512 + op;
      r->r[2] = (int) (spr->s.addr);
    }
    else
    {
      r->r[0] = 256 + op;
      r->r[2] = (int) (spr->s.name);
    }
  }
}

#ifndef UROM
os_error * sprite_readinfo(sprite_area *area, sprite_id *spr,
                           sprite_info *resultinfo)
{
  os_regset r;
  os_error *result;
  setfromtag(40, area, spr, &r);
  result = sprite__op(&r);
  if (result == NULL) /* Only return result if no error */
  {
    resultinfo->width  = r.r[3];
    resultinfo->height = r.r[4];
    resultinfo->mask   = r.r[5];
    resultinfo->mode   = r.r[6];
  }
  return result;
}
#endif

os_error * sprite_select(sprite_area *area, sprite_id *spr)
{
  os_regset r;
  os_error *result;
  setfromtag(24, area, spr, &r);
  result = sprite__op(&r);
  return result;
}


os_error * sprite_select_rp(sprite_area *area, sprite_id *spr,
                            sprite_ptr *resultaddress)
{
  os_regset r;
  os_error *result;
  setfromtag(24, area, spr, &r);
  result = sprite__op(&r);
  if (result == NULL) /* Only return result if no error */
  {
    *resultaddress = (void *) r.r[2];
  }
  return result;
}


os_error * sprite_delete(sprite_area *area, sprite_id *spr)
{
  os_regset r;
  os_error *result;
  setfromtag(25, area, spr, &r);
  result = sprite__op(&r);
  return result;
}


os_error * sprite_rename(sprite_area *area, sprite_id *spr, char *newname)
{
  os_regset r;
  os_error *result;
  setfromtag(26, area, spr, &r);
  r.r[3] = (int) newname;
  result = sprite__op(&r);
  return result;
}


os_error * sprite_copy(sprite_area *area, sprite_id *spr, char *copyname)
{
  os_regset r;
  os_error *result;
  setfromtag(27, area, spr, &r);
  r.r[3] = (int) copyname;
  result = sprite__op(&r);
  return result;
}

#ifndef UROM
os_error * sprite_put(sprite_area *area, sprite_id *spr, int gcol_action)
{
  os_regset r;
  os_error *result;
  setfromtag(28, area, spr, &r);
  r.r[5] = gcol_action;
  result = sprite__op(&r);
  return result;
}
#endif

os_error * sprite_put_given(sprite_area *area, sprite_id *spr, int gcol_action,
                            int x, int y)
{
  os_regset r;
  os_error *result;
  setfromtag(34, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  r.r[5] = gcol_action;
  result = sprite__op(&r);
  return result;
}

os_error * sprite_put_scaled(sprite_area *area, sprite_id *spr,
                             int gcol_action,
                             int x, int y,
                             sprite_factors *factors,
                             sprite_pixtrans *pixtrans)
{
  os_regset r;
  os_error *result;
  setfromtag(52, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  r.r[5] = gcol_action;
  r.r[6] = (int) factors;
  r.r[7] = (int) pixtrans;
  result = sprite__op(&r);
  return result;
}

#ifndef UROM
os_error * sprite_put_greyscaled(sprite_area *area, sprite_id *spr,
                                 int x, int y,
                                 sprite_factors *factors,
                                 sprite_pixtrans *pixtrans)
{
  os_regset r;
  os_error *result;
  setfromtag(53, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  r.r[5] = 0;                   /* doesn't support mask or gcol action */
  r.r[6] = (int) factors;
  r.r[7] = (int) pixtrans;
  result = sprite__op(&r);
  return result;
}
#endif

#ifndef UROM
os_error * sprite_put_mask(sprite_area *area, sprite_id *spr)
{
  os_regset r;
  os_error *result;
  setfromtag(48, area, spr, &r);
  result = sprite__op(&r);
  return result;
}
#endif

os_error * sprite_put_mask_given(sprite_area *area, sprite_id *spr,
                                 int x, int y)
{
  os_regset r;
  os_error *result;
  setfromtag(49, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  result = sprite__op(&r);
  return result;
}

#ifndef UROM
os_error * sprite_put_mask_scaled(sprite_area *area, sprite_id *spr,
                                  int x, int y,
                                  sprite_factors *factors)
{
  os_regset r;
  os_error *result;
  setfromtag(50, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  r.r[6] = (int) factors;
  result = sprite__op(&r);
  return result;
}
#endif

#ifndef UROM
os_error * sprite_put_char_scaled(char ch,
                                  int x, int y,
                                  sprite_factors *factors)
{
  os_regset r;
  os_error *result;
  r.r[0] = 51;
  r.r[1] = ch;
  r.r[3] = x;
  r.r[4] = y;
  r.r[6] = (int) factors;
  result = sprite__op(&r);
  return result;
}
#endif

os_error * sprite_create_mask(sprite_area *area, sprite_id *spr)
{
  os_regset r;
  os_error *result;
  setfromtag(29, area, spr, &r);
  result = sprite__op(&r);
  return result;
}


os_error * sprite_remove_mask(sprite_area *area, sprite_id *spr)
{
  os_regset r;
  os_error *result;
  setfromtag(30, area, spr, &r);
  result = sprite__op(&r);
  return result;
}

#ifndef UROM
os_error * sprite_insert_row(sprite_area *area, sprite_id *spr, int row)
{
  os_regset r;
  os_error *result;
  setfromtag(31, area, spr, &r);
  r.r[3] = row;
  result = sprite__op(&r);
  return result;
}
#endif

#ifndef UROM
os_error * sprite_delete_row(sprite_area *area, sprite_id *spr, int row)
{
  os_regset r;
  os_error *result;
  setfromtag(32, area, spr, &r);
  r.r[3] = row;
  result = sprite__op(&r);
  return result;
}
#endif

#ifndef UROM
os_error * sprite_insert_column(sprite_area *area, sprite_id *spr, int column)
{
  os_regset r;
  os_error *result;
  setfromtag(45, area, spr, &r);
  r.r[3] = column;
  result = sprite__op(&r);
  return result;
}
#endif

#ifndef UROM
os_error * sprite_delete_column(sprite_area *area, sprite_id *spr, int column)
{
  os_regset r;
  os_error *result;
  setfromtag(46, area, spr, &r);
  r.r[3] = column;
  result = sprite__op(&r);
  return result;
}
#endif

os_error * sprite_flip_x(sprite_area *area, sprite_id *spr)
{
  os_regset r;
  os_error *result;
  setfromtag(33, area, spr, &r);
  result = sprite__op(&r);
  return result;
}


os_error * sprite_flip_y(sprite_area *area, sprite_id *spr)
{
  os_regset r;
  os_error *result;
  setfromtag(47, area, spr, &r);
  result = sprite__op(&r);
  return result;
}

os_error * sprite_readsize(sprite_area *area, sprite_id *spr,
                           sprite_info *resultinfo)
{
  os_regset r;
  os_error *result;
  setfromtag(40, area, spr, &r);
  result = sprite__op(&r);
/* now copy returned data */
  resultinfo->width = r.r[3] ;
  resultinfo->height = r.r[4] ;
  resultinfo->mask = r.r[5] ;
  resultinfo->mode = r.r[6] ;
  return result;
}

os_error * sprite_readpixel(sprite_area *area, sprite_id *spr, int x, int y,
                            sprite_colour *resultcolour)
{
  os_regset r;
  os_error *result;
  setfromtag(41, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  result = sprite__op(&r);
  if (result == NULL) /* Only return result if no error */
  {
    resultcolour->colour = r.r[5];
    resultcolour->tint   = r.r[6];
  }
  return result;
}


os_error * sprite_writepixel(sprite_area *area, sprite_id *spr, int x, int y,
                            sprite_colour *colour)
{
  os_regset r;
  os_error *result;
  setfromtag(42, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  r.r[5] = colour->colour;
  r.r[6] = colour->tint;
  result = sprite__op(&r);
  return result;
}


os_error * sprite_readmask(sprite_area *area, sprite_id *spr, int x, int y,
                           sprite_maskstate *resultmaskstate)
{
  os_regset r;
  os_error *result;
  setfromtag(43, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  result = sprite__op(&r);
  if (result == NULL) /* Only return result if no error */
  {
    *resultmaskstate = (sprite_maskstate) r.r[5];
  }
  return result;
}


os_error * sprite_writemask(sprite_area *area, sprite_id *spr, int x, int y,
                            sprite_maskstate *maskstate)
{
  os_regset r;
  os_error *result;
  setfromtag(44, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  r.r[5] = (int) (*maskstate); /* Use pointer here for consistent interface */
  result = sprite__op(&r);
  return result;
}

#ifndef UROM
os_error *sprite_restorestate(sprite_state state)
{
  os_regset r;
  os_error *result;

  r.r[0] = state.r[0];
  r.r[1] = state.r[1];
  r.r[2] = state.r[2];
  r.r[3] = state.r[3];

  result = sprite__op(&r);
  return result;
}
#endif

#ifndef UROM
os_error *sprite_outputtosprite(sprite_area *area, sprite_id *id,
                                int *save_area, sprite_state *state)
{
  os_regset r;
  os_error *result;

  setfromtag(0x3c, area, id, &r);
  r.r[3] = (int) save_area;

  result = sprite__op(&r);
  if (result == NULL)
  {
    state->r[0] = r.r[0];
    state->r[1] = r.r[1];
    state->r[2] = r.r[2];
    state->r[3] = r.r[3];
  }
  return result;
}
#endif

#ifndef UROM
os_error *sprite_outputtomask(sprite_area *area, sprite_id *id,
                              int *save_area, sprite_state *state)
{
  os_regset r;
  os_error *result;

  setfromtag(0x3d, area, id, &r);
  r.r[3] = (int) save_area;

  result = sprite__op(&r);
  if (result == NULL)
  {
    state->r[0] = r.r[0];
    state->r[1] = r.r[1];
    state->r[2] = r.r[2];
    state->r[3] = r.r[3];
  }
  return result;
}
#endif

#ifndef UROM
os_error *sprite_outputtoscreen(int *save_area, sprite_state *state)
{
  os_regset r;
  os_error *result;

  r.r[0] = 0x3c;
  r.r[2] = 0;
  r.r[3] = (int)save_area;

  result = sprite__op(&r);
  if (result == NULL)
  {
    state->r[0] = r.r[0];
    state->r[1] = r.r[1];
    state->r[2] = r.r[2];
    state->r[3] = r.r[3];
  }
  return result;

}
#endif

#ifndef UROM
os_error *sprite_sizeof_spritecontext(sprite_area *area, sprite_id *id,
                                      int *size)
{
  os_regset r;
  os_error *result;

  setfromtag(0x3e, area, id, &r);

  result = sprite__op(&r);

  if (result == NULL)
    *size = r.r[3];

  return result;
}
#endif

#ifndef UROM
os_error *sprite_sizeof_screencontext(int *size)
{
  os_regset r;
  os_error *result;

  r.r[0] = 0x3e;
  r.r[2] = 0;

  result = sprite__op(&r);

  if (result == NULL)
    *size = r.r[3];

  return result;
}
#endif


os_error *sprite_removewastage(sprite_area *area, sprite_id *id)
{
  os_regset r;
  os_error *result;

  setfromtag(0x36, area, id, &r);

  result = sprite__op(&r);

  return result;
}


os_error  *sprite_change_size(sprite_area *area,
                              sprite_id *id,
                              BOOL rows,
                              int at,
                              int number)
{
  os_regset reg_set;
  setfromtag (rows? InsertDeleteRows: InsertDeleteColumns, area, id, &reg_set);
  reg_set.r [3] = at;
  reg_set.r [4] = number;
  return sprite__op (&reg_set);
}

os_error *sprite_put_mask_trans(sprite_area *area,
                                sprite_id *id,
                                sprite_box *box,
                                sprite_transmat *trans_mat)
{
  os_regset reg_set;
  setfromtag (PlotMaskTransformed, area, id, &reg_set);
  reg_set.r [3] = box == NULL? 0: 1 << 1;
  reg_set.r [4] = (int) box;
  reg_set.r [6] = (int) trans_mat;
  return sprite__op (&reg_set);
}

#ifndef UROM
os_error *sprite_put_mask_pgm(sprite_area *area,
                              sprite_id *id,
                              sprite_box *box,
                              sprite_pgm *pgm)
{
  os_regset reg_set;
  setfromtag (PlotMaskTransformed, area, id, &reg_set);
  reg_set.r [3] = (box == NULL? 0: 1 << 1) | (1 << 0);
  reg_set.r [4] = (int) box;
  reg_set.r [6] = (int) pgm;
  return sprite__op (&reg_set);
}
#endif

os_error *sprite_put_trans(sprite_area *area,
                           sprite_id *id,
                           int gcol_action,
                           sprite_box *box,
                           sprite_transmat *trans_mat,
                           sprite_pixtrans *pix_trans)
{
  os_regset reg_set;
  setfromtag (PutSpriteTransformed, area, id, &reg_set);
  reg_set.r [3] = box == NULL? 0: 1 << 1;
  reg_set.r [4] = (int) box;
  reg_set.r [5] = gcol_action;
  reg_set.r [6] = (int) trans_mat;
  reg_set.r [7] = (int) pix_trans;
  return sprite__op (&reg_set);
}

#ifndef UROM
os_error *sprite_put_pgm(sprite_area *area,
                         sprite_id *id,
                         int gcol_action,
                         sprite_box *box,
                         sprite_pgm *pgm,
                         sprite_pixtrans *pix_trans)
{
  os_regset reg_set;
  setfromtag (PutSpriteTransformed, area, id, &reg_set);
  reg_set.r [3] = (box == NULL? 0: 1 << 1) | (1 << 0);
  reg_set.r [4] = (int) box;
  reg_set.r [5] = gcol_action;
  reg_set.r [6] = (int) pgm;
  reg_set.r [7] = (int) pix_trans;
  return sprite__op (&reg_set);
}
#endif

#pragma -s0

/* end of c.sprite */
@


4.4
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@a481 1
#ifndef UROM
a493 1
#endif
d733 1
a733 1
    *resultmaskstate = r.r[5];
@


4.3
log
@  Misc changes.
Detail:
  * Improved lookup of application Sprites file: uses Wimp_Extend 13 (in
    Wimps that support it) to work out the appropriate resolution suffix,
    and prefixes with "<Wimp$IconTheme>" to allow a future Theme Manager
    to operate.
  * Preserves attributes of any existing file when saving sprite or text
    files.
  * Changed two null menu handles from 0 to (doucmented) -1. Despite the
    fact that the Wimp is actually happy with 0 as a null handle here,
    this was reported as a fault.
  * Changed rlib.c.version to use VersionNum, deleted thereby-obsoleted
    rlib.h.VerIntern.version file. Not that rlib.c.version seems to be used
    at the moment.
  * Added Kevin's additions to the test directory.
Admin:
  Tested briefly.

Version 5.44. Not tagged
@
text
@d37 1
a37 1
#include "h.os"
d39 1
a39 1
#include "h.sprite"
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d195 9
d206 8
a213 1
  result = sprite__op(&r);
@


4.1
log
@Initial revision
@
text
@d15 13
a27 14
/****************************************************************************
 * This source file was written by Acorn Computers Limited. It is part of   *
 * the "cwimp" library for writing applications in C for RISC OS. It may be *
 * used freely in the creation of programs for Archimedes. It should be     *
 * used with Acorn's C Compiler Release 2 or later.                         *
 *                                                                          *
 * No support can be given to programmers using this code and, while we     *
 * believe that it is correct, no correspondence can be entered into        *
 * concerning behaviour or bugs.                                            *
 *                                                                          *
 * Upgrades of this code may or may not appear, and while every effort will *
 * be made to keep such upgrades upwards compatible, no guarantees can be   *
 * given.                                                                   *
 ***************************************************************************/
d32 2
a33 6
 * Version: 0.1
 *        13_Apr-89 IDJ fixed header name stddef.h
 *        08-May-91 ECN #ifndefed out unused ROM functions
 *        13-May-91 ECN Turned stack checking off
 *        14-Jun-91 IDJ put readinfo and remove wastage back in
 *        28-Oct-94 AMcC Include sprite_get_given_rp in ROM lib (for Paint)
d116 1
a116 1
/*r.r[1] unused */  
d130 1
a130 1
/*r.r[1] unused */  
d341 1
a341 1
    /* Bug fix (IDJ) spriteop 15 doesn't return pointer to sprite in r2, so....*/
d783 1
a783 1
  setfromtag(0x3c, area, id, &r);
d807 1
a807 1
 
d838 1
a838 1
  
d864 1
a864 1
  
d871 7
a877 4
os_error
  *sprite_change_size
  (sprite_area *area, sprite_id *id, BOOL rows, int at, int number)
{ os_regset reg_set;
d879 1
a879 1
  reg_set.r [3] = at; 
d884 6
a889 4
os_error
  *sprite_put_mask_trans
  (sprite_area *area, sprite_id *id, sprite_box *box, sprite_transmat *trans_mat)
{ os_regset reg_set;
d898 6
a903 4
os_error
  *sprite_put_mask_pgm
  (sprite_area *area, sprite_id *id, sprite_box *box, sprite_pgm *pgm)
{ os_regset reg_set;
d912 8
a919 5
os_error
  *sprite_put_trans
  (sprite_area *area, sprite_id *id, int gcol_action, sprite_box *box,
    sprite_transmat *trans_mat, sprite_pixtrans *pix_trans)
{ os_regset reg_set;
d930 8
a937 5
os_error
  *sprite_put_pgm
  (sprite_area *area, sprite_id *id, int gcol_action, sprite_box *box,
    sprite_pgm *pgm, sprite_pixtrans *pix_trans)
{ os_regset reg_set;
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 14
a28 13
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/
d33 6
a38 2
 * History: IDJ: 07-Feb-92: prepared for source release
 *
d121 1
a121 1
/*r.r[1] unused */
d135 1
a135 1
/*r.r[1] unused */
d346 1
a346 1
    /* spriteop 15 doesn't return pointer to sprite in r2, so....*/
d788 1
a788 1
  setfromtag(0x3d, area, id, &r);
d812 1
a812 1

d843 1
a843 1

d869 1
a869 1

d876 4
a879 7
os_error  *sprite_change_size(sprite_area *area,
                              sprite_id *id,
                              BOOL rows,
                              int at,
                              int number)
{
  os_regset reg_set;
d881 1
a881 1
  reg_set.r [3] = at;
d886 4
a889 6
os_error *sprite_put_mask_trans(sprite_area *area,
                                sprite_id *id,
                                sprite_box *box,
                                sprite_transmat *trans_mat)
{
  os_regset reg_set;
d898 4
a901 6
os_error *sprite_put_mask_pgm(sprite_area *area,
                              sprite_id *id,
                              sprite_box *box,
                              sprite_pgm *pgm)
{
  os_regset reg_set;
d910 5
a914 8
os_error *sprite_put_trans(sprite_area *area,
                           sprite_id *id,
                           int gcol_action,
                           sprite_box *box,
                           sprite_transmat *trans_mat,
                           sprite_pixtrans *pix_trans)
{
  os_regset reg_set;
d925 5
a929 8
os_error *sprite_put_pgm(sprite_area *area,
                         sprite_id *id,
                         int gcol_action,
                         sprite_box *box,
                         sprite_pgm *pgm,
                         sprite_pixtrans *pix_trans)
{
  os_regset reg_set;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

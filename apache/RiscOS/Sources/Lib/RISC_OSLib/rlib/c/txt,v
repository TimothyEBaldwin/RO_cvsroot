head	4.5;
access;
symbols
	RISC_OSLib-5_97:4.5
	RISC_OSLib-5_96:4.5
	RISC_OSLib-5_95:4.5
	RISC_OSLib-5_94:4.5
	RISC_OSLib-5_93:4.5
	RISC_OSLib-5_92:4.5
	RISC_OSLib-5_91:4.5
	RISC_OSLib-5_90:4.5
	RISC_OSLib-5_89:4.5
	RISC_OSLib-5_88:4.5
	RISC_OSLib-5_87:4.5
	RISC_OSLib-5_86-1:4.5
	RISC_OSLib-5_86:4.5
	RISC_OSLib-5_85:4.5
	RISC_OSLib-5_84:4.3
	RISC_OSLib-5_83-2:4.3
	RISC_OSLib-5_83-1:4.3
	RISC_OSLib-5_83:4.3
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.2
	RISC_OSLib-5_77:4.2
	RISC_OSLib-5_76:4.2
	RISC_OSLib-5_75:4.2
	RISC_OSLib-5_74:4.2
	RISC_OSLib-5_73:4.2
	RISC_OSLib-5_72:4.2
	RISC_OSLib-5_71:4.2
	RISC_OSLib-5_70:4.2
	RISC_OSLib-5_69:4.2
	RISC_OSLib-5_68:4.2
	RISC_OSLib-5_67:4.2
	RISC_OSLib-5_66:4.2
	RISC_OSLib-5_65:4.2
	RISC_OSLib-5_64:4.2
	RISC_OSLib-5_63:4.2
	RISC_OSLib-5_62:4.2
	RISC_OSLib-5_61:4.2
	RISC_OSLib-5_60:4.2
	RISC_OSLib-5_59:4.2
	RISC_OSLib-5_58:4.2
	RISC_OSLib-5_57:4.2
	RISC_OSLib-5_56:4.2
	RISC_OSLib-5_55:4.2
	RISC_OSLib-5_54:4.2
	RISC_OSLib-5_53:4.1
	RISC_OSLib-5_52:4.1
	RISC_OSLib-5_51:4.1
	RO_5_07:4.1
	RISC_OSLib-5_50:4.1
	RISC_OSLib-5_49:4.1
	RISC_OSLib-5_46-4_64_2_1:4.1
	NoInlineAsm:4.1.0.16
	RISC_OSLib-5_48:4.1
	RISC_OSLib-5_47:4.1
	RISC_OSLib-5_46:4.1
	RISC_OSLib-5_45:4.1
	RISC_OSLib-5_44:4.1
	RISC_OSLib-5_43:4.1
	RISC_OSLib-5_42:4.1
	RISC_OSLib-5_41:4.1
	RISC_OSLib-5_40:4.1
	RISC_OSLib-5_39:4.1
	RISC_OSLib-5_38:4.1
	RISC_OSLib-5_37:4.1
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2015.04.03.22.43.46;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	4ZOxMlETYoK3gcgy;

4.4
date	2015.04.03.20.40.01;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	G8BXIPKUyzCGAbgy;

4.3
date	2013.10.24.20.03.55;	author rsprowson;	state Exp;
branches;
next	4.2;
commitid	8snV0tcFxVQyiAax;

4.2
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.14;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.25.14;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.04;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.31.02;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.46;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Clean up pass
Trim any #if FALSE switches over a decade old, and keep #if TRUE.
Accept EDIT2 and FMTTEXT1 bracketed code.
Remove unused internal functions txt1_dooaction txt1_dosetoaction.
Retagged as RISC_OSLib-5_85.
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Title: txt.c
 * Purpose: Text display object.
 * Author: WRS
 * History:
 *   16 July 87 -- started
 *   30-Nov-87: WRS: converted into C.
 *   02-Mar-88: WRS: convertion complete.
 *   08-May-91: ECN: #ifndefed out unused ROM functions
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdlib.h>
#include <stdarg.h>
#include "txt.h"
#include "EditIntern/txtundo.h"
#include "EditIntern/txt1.h"
#include "EditIntern/txt3.h"
#include "EditIntern/txtar.h"
#include "werr.h"
#include "trace.h"

/* The type txt__str is actually provided by module txt1 */
/* ----------------------------------------------------- */

/* Module Structure of text implementation:
   =======================================
There are three key modules. There are recursive dependencies so that
the Texts module itself does not betray its implementation.

txt:    does the lock grabbing (if necessary), then calls txt1
        (buffer manipulation) or procedures installed by the window
        implementation (probably txt2).
        System-independent, uncontrovertial.
        h.txt is the only public part of this whole thing.
txt1:   the horrid but system-independent buffer manipulation
        and display calls.
        h.txt1 also has the main internal data structures declared.
        calls window procedures for system-dependent display primitives.
txt2:   the system-dependent stuff, installs window procedures in the
        text object. Other implementations are possible.
        Calls txt1 for editing operations provoked by user events.

*/
txt txt_new(char *title)
{
  txt t;

  t = malloc(sizeof(txt1_str));
  if (t == 0) {
    tracef0("txt_new fails.\n");
    return 0;
  };
  t->oaction = txt_EXTEND;
  t->charoptionset = txt_DISPLAY + txt_CARET;
  if (! txt1_inittextbuffer(t)) {
    free(t);
    return 0;
  };
  t->inbufhead = 0;
  t->inbuftail = 0;
  t->eventproc = (txt_event_proc) 0;
  t->eventprochandle = 0;
  t->eventnest = 0;
  t->disposepending = FALSE;
  txt3_inittxt(t); /* cannot fail. */
  if (! txtar_initwindow(t, title)) {
    txt1_disposetextbuffer(t);
    free(t);
    return 0;
  };
  t->undostate = txtundo_new();
  if (t->undostate == 0) {
    txt3_disposeallwindows(t);
    txt1_disposetextbuffer(t);
    free(t);
    return 0;
  };
  return t;
}

void txt_show(txt t)
{
  while (txt3_foreachwindow(t)) {
    t->w->doshow(t);
  }
}

void txt_hide(txt t)
{
  while (txt3_foreachwindow(t)) {
    t->w->dohide(t);
  }
}

void txt_settitle(txt t, char* title)
{
  while (txt3_foreachwindow(t)) {
    t->w->dosettitle(t, title);
  }
}

void txt_dispose(txt *t)
{
  if ((*t)->eventnest == 0) {
    txt1_disposetextbuffer(*t);
    txt3_disposeallwindows(*t);
    txtundo_dispose((*t)->undostate);
    free(*t);
  } else {
    (*t)->disposepending = TRUE;
  };
}

/* -------- General control operations. -------- */

#ifndef UROM
int txt_bufsize(txt t)
{
  return txt1_dobufsize(t);
}
#endif

#ifndef UROM
BOOL txt_setbufsize(txt t, int size)
{
  return txt1_dosetbufsize(t, size);
}
#endif

txt_charoption txt_charoptions(txt t)
{
  return t->charoptionset;
}

void txt_setcharoptions(txt t, txt_charoption affect, txt_charoption values)
{
  txt1_dosetcharoptions(t, affect, values);
}

void txt_setdisplayok(txt t) {
  txt1_dosetdisplayok(t);
}

int txt_lastref(txt t)
{
  return t->last_ref;
}

void txt_setlastref(txt t, int newvalue)
{
  t->last_ref = newvalue;
}

/* -------- Operations on the array of characters. -------- */

txt_index txt_dot(txt t)
{
  return txt1_dodot(t);
}

txt_index txt_size(txt t) /* max value that dot can take */
{
  return txt1_dosize(t);
}

void txt_setdot(txt t, txt_index i)
{
  txt1_dosetdot(t, i);
}

void txt_movedot(txt t, int by)
{
  txt1_domovedot(t, by);
}

void txt_insertchar(txt t, char c)
{
  txt1_doinsertchar(t, c);
}

void txt_insertstring(txt t, char* s)
{
  txt1_doinsertstring(t, s);
}

void txt_delete(txt t, int n)
{
  txt1_dodelete(t, n);
}

void txt_replacechars(txt t, int ntodelete, char* chars, int n)
{
  txt1_doreplacechars(t, ntodelete, chars, n);
}

char txt_charatdot(txt t)
{
  return txt1_docharatdot(t);
}

char txt_charat(txt t, txt_index i)
{
  return txt1_docharat(t, i);
}

#ifndef UROM
void txt_charsatdot(txt t, char/*out*/ *buffer, int /*inout*/ *n)
{
  txt1_docharsatdot(t, buffer, n);
}
#endif

void txt_replaceatend(txt t, int ntodelete, char *buffer, int n)
{
  txt1_doreplaceatend(t, ntodelete, buffer, n);
}

/* -------- Layout-dependent Operations. -------- */

void txt_movevertical(txt t, int by, int caretstill)
{
  txt1_domovevertical(t, by, caretstill);
}

void txt_movehorizontal(txt t, int by)
{
  txt1_domovehorizontal(t, by);
}

int txt_visiblelinecount(txt t)
{
  return t->w->dovisiblelinecount(t);
}

#ifndef UROM
int txt_visiblecolcount(txt t)
{
  return t->w->dovisiblecolcount(t);
}
#endif

/* -------- Operations on Markers. -------- */

void txt_newmarker(txt t, txt_marker* m)
{
  txt1_donewmarker(t, (txt1_imarker*) m);
}

void txt_movemarker(txt t, txt_marker* m, txt_index to)
{
  txt1_domovemarker(t, (txt1_imarker*) m, to);
}

void txt_movedottomarker(txt t, txt_marker* m)
{
  txt1_domovedottomarker(t, (txt1_imarker*) m);
}

txt_index txt_indexofmarker(txt t, txt_marker* m)
{
  return txt1_doindexofmarker(t, (txt1_imarker*) m);
}

void txt_disposemarker(txt t, txt_marker* m)
{
  txt1_dodisposemarker(t, (txt1_imarker*) m);
}

/* -------- Operations on the selection. -------- */

BOOL txt_selectset(txt t)
{
  return txt1_doselectset(t);
}

txt_index txt_selectstart(txt t)
{
  return txt1_doselectstart(t);
}

txt_index txt_selectend(txt t)
{
  return txt1_doselectend(t);
}

void txt_setselect(txt t, txt_index start, txt_index end)
{
  txt1_dosetselect(t, start, end);
}

/* -------- Input from the user -------- */

txt_eventcode txt_get(txt t)
{
  return t->w->doget(t);
}

#ifndef UROM
int txt_queue(txt t)
{
  return t->w->doqueue(t);
}
#endif

void txt_unget(txt t, txt_eventcode code)
{
  t->w->dounget(t, code);
}

void txt_eventhandler(txt t, txt_event_proc e, void* handle)
{
  t->eventproc = e;
  t->eventprochandle = handle;
}

void txt_readeventhandler(txt t, txt_event_proc *proc, void **handle)
{
  *proc = t->eventproc;
  *handle = t->eventprochandle;
}

/* -------- Direct Access to the array of characters. -------- */

void txt_arrayseg(txt t, txt_index at, char **a, int *n)
{
  txt1_doarraysegment(t, at, a, n);
}

/* -------- System hook. -------- */

int txt_syshandle(txt t)
{
  return t->w->dosyshandle(t);
}

void txt_init(void)
{
  return;   /* @@@@@@ Do nothing for the moment (maybe one day) */
}

/* end */
@


4.4
log
@Switch from ArcEdit style model to clipboard cut & paste model
The txt library part of RISC_OSLib was essentially contrary to everything Acorn was telling its developers, to use the global clipboard.
Additionally, support is added for swap case within a selection.
txt.h:
 Add a new charoption type 'txt_READONLY' to inform txt that the buffer is notionally read only, this is used to supress 'Paste' in the selection menu when appropriate.
 Correct some typos in the comments.
txt1.h:
 Kill off modula 2 dummy structure member.
txtar.h:
 Remove unused function export.
txtfile.h:
 Rename basicimport to be consistent with the text version of the same function. We use 'import' to denote RAM transfers and 'insert' to denote file/scrap transfers throughout.
txtmisc.h:
 Redundant internal functions removed.
txtundo.h:
 Add a new undo operation type 't' for swap case, to avoid polluting the undo buffer with an entire copy of the text where only the case changed.
 Kill off modula 2 double pointer requirement.
txtedit.h:
 Unused structure member 'selectctl' removed.
txt.c:
 Kill off modula 2 double pointer requirement.
txtar.c:
 Refactor message despatch with a switch statement so the save/load/open operations are explicitly checked for, in case the application enables other messages.
txtedit.c:
 Adopt MOVERWRITE, been enabled since 1988 so is probably good to keep.
 Dynamically generate the Select menu by first sending a clipboard request, and fading Paste if no reply comes back.
 Implement changed mouse selection logic.
 Implement different hotkeys and caret navigation.
 Implement copy and paste/replace operations.
 Implement swap case operation.
txtfile.c:
 Type corrections and function rename admin.
 Implement copy and paste/replace operation for detokenised BASIC.
txtmisc.c:
 Supporting functions for clipboard added, supporting functions for ArcEdit removed.
txtscrap.c:
 Make sure the caret is visible for programmatical zero sized selections.
txtundo.c:
 Allow suspension of undo during known complex operations, such as import via RAM transmit. This was a longstanding bug where the import buffer was grabbed in ~4k chunks (even if only 1 byte was being transferred) which in turn resulted in a +4000 undo insertion and a -3999 removal, which given the default undo buffer is only 5k would result in it failing the reversibility test, so no undo was possible.
 Now, during a RAM transmit undo is suspended until the total transfer size is known, and only that data is placed in the undo buffer (subject to the same 5k reversibility limit).
 Add new undo type 't' for swap case operation.
rlibdata.s:
 4 new ints and 1 new BOOL, so RlibSpace increases by 5.

Version 5.85. Tagged as 'RISC_OSLib-5_85'
@
text
@a147 12
#if FALSE
txt_overflowaction txt_oaction(txt t)
{
  return txt1_dooaction(t);
}

void txt_setoaction(txt t, txt_overflowaction o)
{
  txt1_dosetoaction(t, o);
}
#endif

@


4.3
log
@Some library fixes
Fix for problem passing long command lines via system(), while there are good arguments to leave the threshold at 255, non DDEUtils aware programs get brutally truncated command strings, and since the old threshold of 255 applied when the kernel handled 256 command lines, upping the limit to 1k is no worse than before.
Fix for Edit failing to draw lines of text longer than 192 characters (ticket #350). Several factors were conspiring here: on a mode change the window width in characters wasn't being clamped, whereas user entered limits in the menu were, then the internal buffer ("PAINTBUFSIZE") was too short so lines got truncated, and when larger than 256 got wrapped modulo 256 due to the use of an array of chars. Now set at compile time with BIG_WINDOW_SIZE_LIMIT with a new theoretical maximum of 8192. Currently limited to 480 since it uses stack variables.

In the C library:
 armsys.c: adapt the threshold at which to use DDEUtils based on the kernel version number
 scanf.c: squash a warning
 time.c: mark the table of month lengths as constant so we can claw back 13 words of static workspace without having to change the stubs

In RISC OS lib:
 bbc.c: remove local definitions of some SWI numbers
 template.c: squash a warning
 txt.c: delete Modula-2 support
 txt1.c: compare pointer with NULL not an integer
 txtar.c: introduce BIG_WINDOW_SIZE_LIMIT, rationalise a few sprintf's, mark private functions as static
 txtundo.c/txtedit.c: squash old style function warnings
 txtoptmenu.c: clamp the window width read from Edit$Options properly, delete long disabled code
 txtscrap.c: dead function deleted


Version 5.78. Tagged as 'RISC_OSLib-5_78'
@
text
@d125 1
a125 1
    txtundo_dispose(&((*t)->undostate));
@


4.2
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@a370 302
/* -------- STUBS FOR M2. -------- */

#if FALSE
/* -------- Modula-2 equivalents. -------- */

txt Texts_New(char *title);

void Texts_Show(txt t);
void Texts_Hide(txt t);

void Texts_SetTitle(txt t, char* title);

void Texts_Dispose(txt *t);

/* -------- General control operations. -------- */

int Texts_BufSize(txt t);

int Texts_SetBufSize(txt t, int s);

txt_overflowaction Texts_OAction(txt);
void Texts_SetOAction(txt t, txt_overflowaction);

txt_charoption Texts_CharOptions(txt);
void Texts_SetCharOptions(txt t, txt_charoption affect, txt_charoption values);

/* -------- Operations on the array of characters. -------- */

txt_index Texts_Dot(txt);
txt_index Texts_Size(txt); /* max value that dot can take */
void Texts_SetDot(txt t, txt_index);
void Texts_MoveDot(txt t, int by);

void Texts_InsertChar(txt t, char);
void Texts_InsertString(txt t, char*);

void Texts_Delete(txt t, int);

void Texts_ReplaceChars(txt t, int ntodelete, char*, int n);

char Texts_CharAtDot(txt);
char Texts_CharAt(txt t, txt_index);
void Texts_CharsAtDot(txt t, char*/*out*/ buffer, int* /*inout*/ n);

/* -------- Layout-dependent Operations. -------- */

void Texts_MoveVertical(txt t, int by, int caretstill);

void Texts_MoveHorizontal(txt t, int by);

int Texts_VisibleLineCount(txt);

int Texts_VisibleColCount(txt);

/* -------- Operations on Markers. -------- */

void Texts_NewMarker(txt t, txt_marker*);

void Texts_MoveMarker(txt t, txt_marker*, txt_index to);

void Texts_MoveDotToMarker(txt t, txt_marker*);

txt_index Texts_IndexOfMarker(txt t, txt_marker*);

void Texts_DisposeMarker(txt t, txt_marker*);

/* -------- Operations on the selection. -------- */

int Texts_SelectSet(txt); /* returns 1 or 0 */
txt_index Texts_SelectStart(txt);
txt_index Texts_SelectEnd(txt);
void Texts_SetSelect(txt t, txt_index start, txt_index end);

/* -------- Input from the user -------- */

txt_eventcode Texts_Get(txt);

int Texts_Queue(txt);

void Texts_EventHandler(txt t, void(e)(txt,void*), void*);

/* -------- Direct Access to the array of characters. -------- */

void Texts_ArraySegment(txt t, txt_index at, char **a, int *n);

/* -------- System hook. -------- */

int Texts_SysHandle(txt);

/* end */


/*************************************/

txt txt_new(char *title)
{
  return(Texts_New(title));
}

void txt_show(txt t)
{
  Texts_Show(t);
}

void txt_hide(txt t)
{
  Texts_Hide(t);
}

void txt_settitle(txt t, char* title)
{
  Texts_SetTitle(t, title);
}

void txt_dispose(txt *t)
{
  Texts_Dispose(t);
}

/* -------- General control operations. -------- */

int txt_bufsize(txt t)
{
  return Texts_BufSize(t);
}

int txt_setbufsize(txt t, int size)
{
  return Texts_SetBufSize(t, size);
}

txt_overflowaction txt_oaction(txt t)
{
  return Texts_OAction(t);
}
void txt_setoaction(txt t, txt_overflowaction o)
{
  Texts_SetOAction(t, o);
}

txt_charoption txt_charoptions(txt t)
{
  return Texts_CharOptions(t);
}
void txt_setcharoptions(txt t, txt_charoption affect, txt_charoption values)
{
  Texts_SetCharOptions(t, affect, values);
}

/* -------- Operations on the array of characters. -------- */

txt_index txt_dot(txt t)
{
  return Texts_Dot(t);
}
txt_index txt_size(txt t) /* max value that dot can take */
{
  return Texts_Size(t);
}
void txt_setdot(txt t, txt_index i)
{
  Texts_SetDot(t, i);
}
void txt_movedot(txt t, int by)
{
  Texts_MoveDot(t, by);
}

void txt_insertchar(txt t, char c)
{
  Texts_InsertChar(t, c);
}
void txt_insertstring(txt t, char* s)
{
  Texts_InsertString(t, s);
}

void txt_delete(txt t, int n)
{
  Texts_Delete(t, n);
}

void txt_replacechars(txt t, int ntodelete, char* chars, int n)
{
  Texts_ReplaceChars(t, ntodelete, chars, n);
}

char txt_charatdot(txt t)
{
  return Texts_CharAtDot(t);
}
char txt_charat(txt t, txt_index i)
{
  return Texts_CharAt(t, i);
}
void txt_charsatdot(txt t, char/*out*/ *buffer, int /*inout*/ *n)
{
  Texts_CharsAtDot(t, buffer, n);
}

/* -------- Layout-dependent Operations. -------- */

void txt_movevertical(txt t, int by, int caretstill)
{
  Texts_MoveVertical(t,  by, caretstill);
}

void txt_movehorizontal(txt t, int by)
{
  Texts_MoveHorizontal(t, by);
}

int txt_visiblelinecount(txt t)
{
  return Texts_VisibleLineCount(t);
}

int txt_visiblecolcount(txt t)
{
  return Texts_VisibleColCount(t);
}

/* -------- Operations on Markers. -------- */

void txt_newmarker(txt t, txt_marker* m)
{
  Texts_NewMarker(t, m);
}

void txt_movemarker(txt t, txt_marker* m, txt_index to)
{
  Texts_MoveMarker(t, m, to);
}

void txt_movedottomarker(txt t, txt_marker* m)
{
  Texts_MoveDotToMarker(t, m);
}

txt_index txt_indexofmarker(txt t, txt_marker* m)
{
  return Texts_IndexOfMarker(t, m);
}

void txt_disposemarker(txt t, txt_marker* m)
{
  Texts_DisposeMarker(t, m);
}

/* -------- Operations on the selection. -------- */

int txt_selectset(txt t) /* returns 1 or 0 */
{
  return Texts_SelectSet(t);
}

txt_index txt_selectstart(txt t)
{
  return Texts_SelectStart(t);
}
txt_index txt_selectend(txt t)
{
  return Texts_SelectEnd(t);
}
void txt_setselect(txt t, txt_index start, txt_index end)
{
  Texts_SetSelect(t, start, end);
}

/* -------- Input from the user -------- */

txt_eventcode txt_get(txt t)
{
  return Texts_Get(t);
}

int txt_queue(txt t)
{
  return Texts_Queue(t);
}

void txt_eventhandler(txt t, void(e)(txt,void*), void* handle)
{
  Texts_EventHandler(t, e, handle);
}

/* -------- Direct Access to the array of characters. -------- */

void txt_arrayseg(txt t, txt_index at, char **a, int *n)
{
  Texts_ArraySegment(t, at, a, n);
}

/* -------- System hook. -------- */

int txt_syshandle(txt t)
{
  return Texts_SysHandle(t);
}


#endif
@


4.1
log
@Initial revision
@
text
@d32 7
a38 7
#include "h.txt"
#include "h.EditIntern.txtundo"
#include "h.EditIntern.txt1"
#include "h.EditIntern.txt3"
#include "h.EditIntern.txtar"
#include "h.werr"
#include "h.trace"
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

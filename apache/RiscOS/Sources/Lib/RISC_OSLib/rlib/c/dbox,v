head	4.8;
access;
symbols
	RISC_OSLib-5_97:4.8
	RISC_OSLib-5_96:4.8
	RISC_OSLib-5_95:4.8
	RISC_OSLib-5_94:4.8
	RISC_OSLib-5_93:4.8
	RISC_OSLib-5_92:4.8
	RISC_OSLib-5_91:4.8
	RISC_OSLib-5_90:4.8
	RISC_OSLib-5_89:4.8
	RISC_OSLib-5_88:4.8
	RISC_OSLib-5_87:4.8
	RISC_OSLib-5_86-1:4.7
	RISC_OSLib-5_86:4.7
	RISC_OSLib-5_85:4.7
	RISC_OSLib-5_84:4.7
	RISC_OSLib-5_83-2:4.7
	RISC_OSLib-5_83-1:4.7
	RISC_OSLib-5_83:4.7
	RISC_OSLib-5_82:4.5
	RISC_OSLib-5_81:4.4
	RISC_OSLib-5_75-2:4.4
	RISC_OSLib-5_80:4.4
	RISC_OSLib-5_79:4.4
	RISC_OSLib-5_78:4.4
	RISC_OSLib-5_75-1:4.4
	RISC_OSLib-5_77:4.4
	RISC_OSLib-5_76:4.4
	RISC_OSLib-5_75:4.4
	RISC_OSLib-5_74:4.4
	RISC_OSLib-5_73:4.4
	RISC_OSLib-5_72:4.4
	RISC_OSLib-5_71:4.4
	RISC_OSLib-5_70:4.4
	RISC_OSLib-5_69:4.4
	RISC_OSLib-5_68:4.4
	RISC_OSLib-5_67:4.4
	RISC_OSLib-5_66:4.4
	RISC_OSLib-5_65:4.4
	RISC_OSLib-5_64:4.4
	RISC_OSLib-5_63:4.4
	RISC_OSLib-5_62:4.4
	RISC_OSLib-5_61:4.4
	RISC_OSLib-5_60:4.4
	RISC_OSLib-5_59:4.4
	RISC_OSLib-5_58:4.4
	RISC_OSLib-5_57:4.4
	RISC_OSLib-5_56:4.4
	RISC_OSLib-5_55:4.4
	RISC_OSLib-5_54:4.4
	RISC_OSLib-5_53:4.3
	RISC_OSLib-5_52:4.3
	RISC_OSLib-5_51:4.3
	RO_5_07:4.3
	RISC_OSLib-5_50:4.3
	RISC_OSLib-5_49:4.3
	RISC_OSLib-5_46-4_64_2_1:4.3
	NoInlineAsm:4.3.0.2
	RISC_OSLib-5_48:4.3
	RISC_OSLib-5_47:4.3
	RISC_OSLib-5_46:4.3
	RISC_OSLib-5_45:4.3
	RISC_OSLib-5_44:4.3
	RISC_OSLib-5_43:4.3
	RISC_OSLib-5_42:4.3
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2016.02.07.16.35.15;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	TlF3STjWlU3Wg0Uy;

4.7
date	2014.08.23.21.27.31;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	oe7YyRjInqWq1xNx;

4.6
date	2014.07.31.08.24.08;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	jfGiiZxupMtuqvKx;

4.5
date	2014.05.08.10.11.29;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	u7YoeZpupMfJIIzx;

4.4
date	2009.05.31.17.58.58;	author pnaulls;	state Exp;
branches;
next	4.3;

4.3
date	2002.07.23.11.52.22;	author srevill;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.45;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.08;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.08;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.53.29;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.29.58;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.12;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.13;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.8
log
@Open colour picker menus in the right place
Function dboxtcol() always opens colour pickers as transient submenus (in the flags to ColourPicker_OpenDialogue, plus listening for the menus deleted message) but chose to open the dialogue at the current mouse pointer, so obscuring part of the menu rather than opening it where the Style Guide wants it.
wimp.h:
  Add a struct definition of menuwarn messages.
txtedit.c/dbox.c/ctl.c:
  Use the menuwarn struct rather than indexing the words[].
dboxtcol.c:
  Provided the last wimp event was the menu warning, use the x/y coordinates from that instead of the mouse pointer.
  Remove some local defines in favour of central ones.
  Make sure we use 0x80000000/0x7F000000 like the PRM says for the other 2 corners of the dialogue, not 0,0.
Tested in a disc build of !Draw.

Version 5.86. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: > c.dbox
 * Purpose: System-independent dialog boxes.
 * History: IDJ: 05-Feb-92: prepared for source release
 *
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <limits.h>

#include "trace.h"
#include "werr.h"
#include "os.h"
#include "akbd.h"
#include "wimp.h"
#include "wimpt.h"
#include "win.h"
#include "menu.h"
#include "event.h"
#include "dbox.h"
#include "res.h"
#include "sprite.h"
#include "resspr.h"
#include "template.h"
#include "alarm.h"
#include "msgs.h"
#include "VerIntern/messages.h"

typedef struct dbox__str {
  struct dbox__str *next;  /* if user wants to link dboxes into a list */
  wimp_w w;                /* only used in live dialog boxes */
  int posatcaret;          /* Every time it is shown, it appears "near" the
                            * caret.
                            */
  int showing;
  wimp_caretstr caretstr;   /* save between fillin's. */
  dbox_handler_proc eventproc;
  void *eventprochandle;
  dbox_raw_handler_proc raweventproc;
  void *raweventprochandle;

  dbox_field field;     /* button last pressed */
  int fieldwaiting;     /* a button waiting to be picked up */
  int eventdepth;       /* for delaying disposal */
  int disposepending;

  char name[12];
  char *workspace;
  int workspacesize;
  wimp_wind window;
  /* any icons follow directly after this. */
} dbox__str;
/* Abstraction: a dbox is really a dbox__str*. */

/* -------- Miscellaneous. -------- */

static dbox dbox__fromtemplate(template *from)
{
  dbox to;
  int j;
  int size = sizeof(dbox__str) + from->window.nicons * sizeof(wimp_icon);

  to = malloc(size);
  if (to == 0) return 0;

  /* --- copy relevant stuff from template --- */
  strncpy (to->name, from->name, 12);
  to->workspacesize = from->workspacesize;
  (void) memcpy(&to->window, &from->window, sizeof(wimp_wind) + from->window.nicons * sizeof(wimp_icon));

  /* --- allocate and copy workspace --- */
  if (to->workspacesize != 0)
  {
    to->workspace = malloc(to->workspacesize);
    if (to->workspace == 0)
    {
      free(to);
      return 0;
    }
    (void) memcpy(to->workspace, from->workspace, to->workspacesize);

    /* -- fix up indirect icon pointers -- */
    for (j=0; j<to->window.nicons; j++)
    {
      wimp_icon *i = ((wimp_icon *)(&to->window + 1)) + j;
      if ((i->flags & wimp_INDIRECT) != 0)
      {
        i->data.indirecttext.buffer += to->workspace - from->workspace;
        if ((i->flags & wimp_ITEXT) != 0 &&
            (int) (i->data.indirecttext.validstring) > 0)
          i->data.indirecttext.validstring += to->workspace - from->workspace;
      }
    }

    /* -- fix up indirect title pointer -- */
    if ((to->window.titleflags & wimp_INDIRECT) != 0)
      to->window.title.indirecttext.buffer += to->workspace - from->workspace;

  }

  return(to);

}


static void dbox__dispose(dbox d)
{
  if (d->workspacesize != 0) {
    free(d->workspace);
  }
  free(d);
}

static void dbox__dodispose(dbox d)
{
  win_register_event_handler(d->w, 0, 0);
  event_attachmenu(d->w, 0, 0, 0);
  if (d->showing) {
    win_activedec();
  }
  wimpt_noerr(wimp_delete_wind(d->w));
  dbox__dispose(d);
}


/* -------- Finding Icons. -------- */

/* useful icon flag masks, for searching for specific icon types */
#define BUTTON_IFLAGS (15 * wimp_IBTYPE)
#define WRITABLE_IFLAGS (wimp_BWRITABLE * wimp_IBTYPE)
#define WRITABLE2_IFLAGS (wimp_BWRITABLEDRAG * wimp_IBTYPE)
#define CLICK_IFLAGS (wimp_BCLICKDEBOUNCE * wimp_IBTYPE)
#define AUTO_IFLAGS (wimp_BCLICKAUTO * wimp_IBTYPE)
#define RELEASE_IFLAGS (wimp_BSELREL * wimp_IBTYPE)
#define ONOFF_IFLAGS (wimp_BSELDOUBLE * wimp_IBTYPE)
#define ONOFF2_IFLAGS (wimp_BCLICKSEL * wimp_IBTYPE)
#define MENU_IFLAGS (wimp_BSELNOTIFY * wimp_IBTYPE)

static BOOL dbox__findwritable(dbox d, wimp_i *j)
/* Starting at j, find the first writable (possibly j itself). Returns 0 if not found. */
{
  for (; (*j)<d->window.nicons; (*j)++) {
    wimp_icon *i = ((wimp_icon *) (&d->window + 1)) + *j;
    wimp_iconflags setting = i->flags & BUTTON_IFLAGS; 

    if ((setting == WRITABLE_IFLAGS)||(setting == WRITABLE2_IFLAGS)) {
      tracef1("Found icon %i.\n", *j);
      return TRUE;
    }
  }
  return FALSE;
}

static BOOL dbox__findwritablebefore(dbox d, wimp_i *j)
/* Find the first writable before j (excluding j itself). Returns 0 if not found. */
{
  while ((*j) != 0) {
    wimp_icon *i = ((wimp_icon *) (&d->window + 1)) + (--(*j));
    wimp_iconflags setting = i->flags & BUTTON_IFLAGS; 

    if ((setting == WRITABLE_IFLAGS)||(setting == WRITABLE2_IFLAGS)) {
      tracef1("Found icon %i.\n", *j);
      return TRUE;
    }
  }
  return FALSE;
}

/* -------- Icons and Fields. -------- */

static wimp_i dbox__fieldtoicon(dbox_field f)
{
  return(f);
}

static wimp_icon *dbox__iconhandletoptr(dbox d, wimp_i i)
{
  return(((wimp_icon*) (&d->window + 1)) + i);
}

static wimp_icon *dbox__fieldtoiconptr(dbox d, dbox_field f)
{
  return(dbox__iconhandletoptr(d, dbox__fieldtoicon(f)));
}

static wimp_iconflags dbox__ibutflags(wimp_icon *i)
{
  return(wimp_iconflags)(i->flags & BUTTON_IFLAGS);
}

static dbox_fieldtype dbox__iconfieldtype(wimp_icon *i)
{
  switch (dbox__ibutflags(i)) {
  case AUTO_IFLAGS:
  case RELEASE_IFLAGS:
  case CLICK_IFLAGS:
  case MENU_IFLAGS:
    return(dbox_FACTION);
  case ONOFF_IFLAGS:
  case ONOFF2_IFLAGS:
    return(dbox_FONOFF);
  case WRITABLE_IFLAGS:
    return(dbox_FINPUT);
  default:
    return(dbox_FOUTPUT);
  }
}

static BOOL dbox__has_action_button(dbox d)
{
   wimp_i j;

   for (j = 0; j < d->window.nicons; j++)
   {
     wimp_icon *i = ((wimp_icon*) (&d->window + 1)) + j;
     dbox_fieldtype t = dbox__iconfieldtype(i);

     if (t == dbox_FACTION || t == dbox_FONOFF || t == dbox_FINPUT)
        return TRUE;
   }

   return FALSE;
}


static int dbox__min(int a, int b) {if (a<b) {return(a);} else {return(b);}}


void dbox_fadefield (dbox d, dbox_field f)
{
  /* set shaded bit in iconflags */
  wimpt_noerr(wimp_set_icon_state (d->w, dbox__fieldtoicon(f),
                                   wimp_INOSELECT, wimp_INOSELECT));
}

void  dbox_unfadefield (dbox d, dbox_field f)
{
  /* unset shaded bit in iconflags */
  wimpt_noerr(wimp_set_icon_state(d->w, dbox__fieldtoicon(f),
                                  0, wimp_INOSELECT));
}

#ifndef UROM
void dbox_hidefield (dbox d, dbox_field f)
{
  /* set deleted bit in iconflags */
  wimpt_noerr(wimp_set_icon_state (d->w, dbox__fieldtoicon(f),
                                   wimp_IDELETED, wimp_IDELETED));
}

void  dbox_unhidefield (dbox d, dbox_field f)
{
  /* unset deleted bit in iconflags */
  wimpt_noerr(wimp_set_icon_state(d->w, dbox__fieldtoicon(f),
                                  0, wimp_IDELETED));
}
#endif

void dbox_setfield(dbox d, dbox_field f, char *value)
{
  wimp_icon *i = dbox__fieldtoiconptr(d, f);
  if ((i->flags & wimp_ITEXT) == 0)
  {
    tracef0("SetField of non-text.");
    /* Allowed, has no effect */
  }
  else
  {
    wimp_caretstr caret ;
    if ((i->flags & wimp_INDIRECT) != 0) {
      (void) memcpy(i->data.indirecttext.buffer, value,
        dbox__min(i->data.indirecttext.bufflen - 1,
                  strlen(value) + 1));
      i->data.indirecttext.buffer[i->data.indirecttext.bufflen-1] = 0;
    }
    else
    {
      (void) memcpy(&i->data.text[0], value, 12);
      i->data.text[11] = 0;
    }

    /* ensure that the caret moves correctly if it's in this icon */

    wimpt_noerr(wimp_get_caret_pos(&caret)) ;

    if (caret.w == d->w && caret.i == dbox__fieldtoicon(f))
    {
     int l = strlen((i->flags & wimp_INDIRECT) != 0 ?
                       i->data.indirecttext.buffer : i->data.text) ;

     if (caret.index > l) caret.index = l ;
     caret.height = -1;   /* calc from index */
         /*Fix MED-4747: was 'caret.height = caret.x = caret.y -1;' J R C
            28th Feb 1995*/
     wimpt_noerr(wimp_set_caret_pos(&caret)) ;
    }

    /* prod it, to cause redraw */
    wimpt_noerr(wimp_set_icon_state(d->w, dbox__fieldtoicon(f), 0, 0));
  }
}

void dbox_getfield(dbox d, dbox_field f, char *buffer, int size)
{
  wimp_icon *i = dbox__fieldtoiconptr(d, f);
  int j = 0;
  char *from;
  if ((i->flags & wimp_ITEXT) == 0) {
    tracef0("GetField of non-text.");
    /* Allowed, returns "". */
  } else {
    if ((i->flags & wimp_INDIRECT) != 0) {
      while (i->data.indirecttext.buffer[j] >= 32) {j++;}
      from = i->data.indirecttext.buffer;
    } else {
      while (i->data.text[j] >= 32 && j < 11) {j++;}
      from = &i->data.text[0];
    }
    if (j > size) {j = size;}
    tracef3("GetField copies %i from %i to %i.\n",
      j, (int) from, (int) buffer);
    (void) memcpy(buffer, from, j);
  }
  buffer[j] = 0;
  tracef1("GetField returns %s.\n", (int) buffer);
}

static int dbox__fieldlength(dbox d, dbox_field f)
{
  char a[255];
  dbox_getfield((dbox) d, f, a, 255);
  tracef1("got field %i in FieldLength.\n", f);
  return(strlen(a));
}

void dbox_setnumeric(dbox d, dbox_field f, int n)
{
  char a[20];
  wimp_icon *i = dbox__fieldtoiconptr(d, f);
  dbox_fieldtype ftype = dbox__iconfieldtype(i);

  switch (ftype) {
  case dbox_FONOFF:
  case dbox_FACTION:
      if (n)
        wimpt_noerr(wimp_set_icon_state(d->w, dbox__fieldtoicon(f),
          wimp_ISELECTED, wimp_ISELECTED));
      else
        wimpt_noerr(wimp_set_icon_state(d->w, dbox__fieldtoicon(f),
          0, wimp_ISELECTED));
      break;
  default:
      sprintf(a, "%i", n);
      dbox_setfield((dbox) d, f, a);
  }
}

int dbox_getnumeric(dbox d, dbox_field f)
{
  char a[20];
  int n;
  int i;
  int neg;
  int fail;
  wimp_icon *iptr = dbox__fieldtoiconptr(d, f);
  wimp_icon icon;

  if (dbox__iconfieldtype(iptr) == dbox_FONOFF) {
    wimpt_noerr(wimp_get_icon_info(d->w, dbox__fieldtoicon(f), &icon));
    if ((icon.flags & wimp_ISELECTED) != 0) {
      n = 1;
    } else {
      n = 0;
    }
  } else {
    dbox_getfield((dbox) d, f, a, 20);
    tracef1("dbox_getnumeric on '%s'\n",(int) a) ;
    n = 0;
    i = 0;
    neg = 0;
    fail = 0;
    while (1) {
      if (fail || a[i] == 0) {break;}
      if (a[i] == '-') {
        if (neg || (n!=0)) {fail = 1;} else {neg = 1;}
      } else if ((a[i] >= '0') && (a[i] <= '9')) {
        n = n * 10 + a[i] - '0';
      } else {
        tracef1("dbox_getnumeric fails with %d\n",a[i]) ;
        fail = 1;
      }
      i++;
    }
    if (neg) {n = -n;}
    if (fail) {n = 0;}
  }
  return(n);
}

/* -------- Arrival of events from DBoxes. -------- */

dbox_field dbox_get(dbox d)
{
  d->fieldwaiting = 0;
  return(d->field);
}

#ifndef UROM
dbox_field dbox_read(dbox d)
{
  return(d->field);
}
#endif

void dbox_eventhandler(dbox d, dbox_handler_proc handler, void* handle)
{
  d->eventproc = handler;
  d->eventprochandle = handle;
}

void dbox_raw_eventhandler(dbox d, dbox_raw_handler_proc handler, void *handle)
{
  d->raweventproc = handler;
  d->raweventprochandle = handle;
}

/* -------- Processing Wimp Events. -------- */

static void dbox__buttonclick(dbox d, dbox_field f)
{
  tracef1("Button click icon %i.\n", f);
  d->field = f;
  d->fieldwaiting = 1;
  if (d->eventproc != 0) {
    tracef0("obeying user event proc.\n");
    d->eventdepth++;
    d->eventproc((dbox) d, d->eventprochandle);
    d->eventdepth--;
    if (d->disposepending && d->eventdepth == 0) {
      tracef0("delayed dispose of DBox.\n");
      dbox__dodispose(d);
    }
  }
}

static BOOL dbox__hitbutton(dbox d, int button)
/* A button is an action button or an on/off switch. "button" counts only
such interesting buttons, button==0 -> the first one in the DBox. Find the
right icon. If an action, do it. If on/off, flip it. If button is too big, do
nothing. */
{
  wimp_icon *i;
  int j = 0; /* counts icons */
  dbox_fieldtype f;
  wimp_icon icon;
  BOOL icon_found = FALSE;

  for (j=0; j<d->window.nicons; j++) {
    i = dbox__iconhandletoptr(d, j);
    f = dbox__iconfieldtype(i);
    if (f == dbox_FACTION || f == dbox_FONOFF) {
      if (button == 0) {
        /* this is the right one */
        if (f == dbox_FACTION) {
          tracef1("buttonclick %i.\n", j);
          dbox__buttonclick(d, j);
        } else {
          /* on/off button */
          tracef1("Flip on/off %i.\n", j);
          (void) wimp_get_icon_info(d->w, j, &icon);
          if ((icon.flags & wimp_ISELECTED) != 0) {
            wimpt_noerr(wimp_set_icon_state(d->w, j, wimp_ISELECTED, 0));
          } else {
            wimpt_noerr(wimp_set_icon_state(d->w, j, wimp_ISELECTED, wimp_ISELECTED));
          }
          /* inverted the select bit. */
        }
        icon_found = TRUE;
        break;
      } else {
        /* right sort, but not this one. keep going. */
        button--;
      }
    } else {
      /* not the right sort of icon: keep going. */
    }
  }

  return icon_found;
}

static void dbox__wimp_event_handler(wimp_eventstr *e, void *handle)
{
  dbox d = (dbox) handle;
  wimp_caretstr c;

  if (d->raweventproc != 0) {
    BOOL done;
    tracef0("client-installed raw event handler.\n");
    d->eventdepth++;
    done = (d->raweventproc)(d, (void*) e, d->raweventprochandle);
    d->eventdepth--;
    if (d->disposepending && d->eventdepth == 0) {
      tracef0("delayed dispose of DBox.\n");
      dbox__dodispose(d);
      return;
    } else if (done) { /* this event has been processed. */
      return;
    }
  }

  switch (e->e) {
  case  wimp_ECLOSE:
      dbox__buttonclick(d, dbox_CLOSE); /* special button code */
      break;
  case wimp_EOPEN:
      wimpt_noerr(wimp_open_wind(&e->data.o));
      break;
  case wimp_EBUT:
      if ((wimp_BMID & e->data.but.m.bbits) != 0) {
        /* ignore it. */
        /* It will already have been intercepted (by Events) if there's
        a menu, otherwise we're not interested anyway. */
      } else if (e->data.but.m.i != (wimp_i) -1) {
        wimp_icon *i;
        /* ignore clicks not on icons. */
        i = dbox__iconhandletoptr(d, e->data.but.m.i);
        if (dbox__iconfieldtype(i) == dbox_FACTION) {
          /* avoid spurious double-click from on/off button! */
          dbox__buttonclick(d, e->data.but.m.i);
        }
      }
      break;
  case wimp_EKEY:
      wimpt_noerr(wimp_get_caret_pos(&c));
      switch (e->data.key.chcode) {
      case akbd_Fn+1:
      case akbd_Fn+2:
      case akbd_Fn+3:
      case akbd_Fn+4:
      case akbd_Fn+5:
      case akbd_Fn+6:
      case akbd_Fn+7:
      case akbd_Fn+8:
      case akbd_Fn+9:
          /* if fnkey matches icon number, do action, else pass it on
           * as a hotkey stroke
           */
          if (!dbox__hitbutton(d, e->data.key.chcode - (akbd_Fn+1)))
            wimp_processkey(e->data.key.chcode);
          break;

      case 13: /* return key */
          /* Simulate 'Kr' validation */
          tracef1("Caret is in icon %i.\n", c.i);
          c.i++;
          if (c.i >= d->window.nicons ||
              c.i == 0 ||
              !dbox__findwritable(d, &c.i)
               /* find a writable button */
             )
          {
            dbox__buttonclick(d, 0); /* should be first action button! */
          } else {
            c.height = -1;
            c.index = dbox__fieldlength(d, c.i);
            tracef2("Setting caret in icon %i index=%i.\n",
              c.i, c.index);
            wimpt_noerr(wimp_set_caret_pos(&c));
          }
          break;
      case 27: /* ESC key */
          dbox__buttonclick(d, dbox_CLOSE);
          break;
      case akbd_TabK:
      case akbd_DownK:
          /* Simulate 'Kta' validation */
          tracef1("Caret is in icon %i.\n", c.i);
          if (c.i == (wimp_i) -1) {
            /* do nothing */
          } else {
            c.i++;
            if (c.i >= d->window.nicons ||
                !dbox__findwritable(d, &c.i))
            {
              c.i = 0;
              if (dbox__findwritable(d, &c.i)) {
                /* bound to find at least the one you started on. */
              }
            }
            c.height = -1;
            c.index = dbox__fieldlength(d, c.i);
            tracef2("Setting caret in icon %i index=%i.\n",
              c.i, c.index);
            wimpt_noerr(wimp_set_caret_pos(&c));
          }
          break;
      case akbd_Sh + akbd_TabK:
      case akbd_UpK:
          /* Simulate 'Kta' validation */
          tracef1("Caret is in icon %i.\n", c.i);
          if (c.i == (wimp_i) -1) {
            /* do nothing */
          } else {
            if (!dbox__findwritablebefore(d, &c.i)) {
              c.i = d->window.nicons;
              if (dbox__findwritablebefore(d, &c.i)) {
                /* bound to find at least the one you started on. */
              }
            }
            c.height = -1;
            c.index = dbox__fieldlength(d, c.i);
            tracef2("Setting caret in icon %i index=%i.\n",
              c.i, c.index);
            wimpt_noerr(wimp_set_caret_pos(&c));
          }
          break;
      default:
          /* If not to a field and this is a letter, try matching it
          with the first chars of action buttons in this DBox. */
          if (e->data.key.chcode < 256)
              e->data.key.chcode = toupper(e->data.key.chcode);
          if (e->data.key.chcode < 256 && isalpha(e->data.key.chcode)) {
            wimp_icon i;
            wimp_i    j;
            for (j=0; j<d->window.nicons; j++) {
              tracef1("trying icon %i.\n", j);
              /* Need to get the live icon state from the Wimp as there
              might have been some hiding/fading going on since dbox_new() called. */
              wimpt_noerr(wimp_get_icon_info(d->w, j, &i));
              if (((i.flags & (wimp_ITEXT | wimp_IDELETED | wimp_INOSELECT)) == wimp_ITEXT)
              && dbox__iconfieldtype(&i) == dbox_FACTION) {
                char *targetptr;
                char target;
                BOOL found = FALSE;

                if (i.flags & wimp_INDIRECT) {
                  targetptr = i.data.indirecttext.buffer;
                } else {
                  targetptr = i.data.text;
                }

                while (1) {
                  target = *targetptr++;
                  if (target < ' ') break; /* Ctrl terminated */
                  if (target == e->data.key.chcode) {
                    tracef2("clicking on %i, %i.\n", j, target);
                    dbox__buttonclick(d, j);
                    found = TRUE;
                    break;
                  }
                  if (isupper(target)) break;
                }
                if (found) break;
                tracef2("no: target=%i,code=%i.\n",
                  target, e->data.key.chcode);
              }
            }
          } else {
            tracef1("Key code %i ignored.\n", e->data.key.chcode);
            wimp_processkey(e->data.key.chcode);
          }
      }
      break;
  default:
      /* do nothing */
      tracef3("DBoxes ignored event %i %i %i.\n",
        e->e, e->data.o.w, e->data.menu[1]);
  }
}

/* -------- New and Dispose. -------- */

dbox dbox_new(char *name)
{
  dbox d = dbox__fromtemplate(template_find(name));
  wimp_i j;
  if (d == 0) {
    werr(FALSE, msgs_lookup(MSGS_dbox1));
    return 0;
  }
  d->next = 0;
  d->posatcaret = (wimp_WTRESPASS & d->window.flags) != 0;
  d->window.flags &= ~wimp_WTRESPASS;
  { os_error *er;
    er = wimp_create_wind(&d->window, &d->w);
    if (er != 0) {
      werr(FALSE, er->errmess);
      dbox__dispose(d);
      return 0;
    }
  }
  d->eventproc = 0;
  d->raweventproc = 0;
  d->disposepending = 0;
  d->eventdepth = 0;
  d->fieldwaiting = 0;
  d->field = 0;
  d->showing = 0;
  win_register_event_handler(d->w, dbox__wimp_event_handler, d);
  tracef0("Template created.\n");
  j = 0;
  if (dbox__findwritable(d, &j)) {
    /* there is a writable icon to be found. */
    tracef1("Set caret in icon %i.\n", j);
    /* Default setting, used in FillIn */
    d->caretstr.w = d->w;
    d->caretstr.i = j;
    d->caretstr.x = 0;
    d->caretstr.y = 0;
    d->caretstr.height = -1;
    d->caretstr.index = INT_MAX;
  }
  return d;
}

static wimp_w dbox__submenu = 0;

static void dbox__doshow(dbox d, BOOL isstatic)
/* This is complicated by the following case: if the show is as a result
of a submenu message (e.g. that was the last message received) then we
open the dbox as a submenu rather than as a standalone window. */
{
  wimp_mousestr m;
  wimp_caretstr c;
  wimp_openstr o;
  wimp_wstate s;
  wimp_eventstr *e;

  if (d->showing) return;
  d->showing = TRUE;
  win_activeinc();

  e = wimpt_last_event();
  if (e->e == wimp_ESEND && e->data.msg.hdr.action == wimp_MMENUWARN) {
    /* this is a dbox that is actually part of the menu tree. */
    tracef0("opening submenu dbox.\n");
    dbox__submenu = d->w; /* there's only ever one. */
    wimp_create_submenu(
      (wimp_menustr*) d->w,
      e->data.msg.data.menuwarn.x,
      e->data.msg.data.menuwarn.y);
  } else {
    o.w = d->w;
    o.box = d->window.box;
    if (d->posatcaret) {
      /* move to near the caret. */
      if (wimpt_last_event_was_a_key()) {
        tracef0("Move DBox to near caret.\n");
        wimpt_noerr(wimp_get_caret_pos(&c));
        if (c.w != (wimp_w) -1) {
          wimpt_noerr(wimp_get_wind_state(c.w, &s));
          c.x = c.x + (s.o.box.x0 - s.o.x);
          c.y = c.y + (s.o.box.y1 - s.o.y);
        }
        m.x = c.x + 100; /* a little to the right */
        m.y = c.y - 120; /* a little down */
      } else {
        tracef0("Move DBox to near cursor.\n");
        wimpt_noerr(wimp_get_point_info(&m));
        m.x -= 48; /* try to be a bit into it. */
        m.y += 48;
      }
      tracef2("put box at (%i,%i).\n", m.x, m.y);
      o.box.y0 = m.y - (o.box.y1 - o.box.y0);
      o.box.x1 = m.x + (o.box.x1 - o.box.x0);
      o.box.y1 = m.y;
      o.box.x0 = m.x;
    }
    o.x = d->window.scx;
    o.y = d->window.scy;
    o.behind = (wimp_w) -1;

    if (isstatic) {
      wimpt_noerr(wimp_open_wind(&o));
    } else {
      dbox__submenu = d->w; /* there's only ever one. */
      wimp_create_menu((wimp_menustr*) d->w, o.box.x0, o.box.y1);
    }

    tracef0("Dialog box shown.\n");
  }
}

void dbox_show(dbox d) {
  dbox__doshow(d, FALSE);
}

void dbox_showstatic(dbox d) {
  dbox__doshow(d, TRUE);
}

void dbox_hide(dbox d)
{
  tracef0("dbox_hide.\n");
  if (! d->showing) {
    tracef0("dbox_hide, not showing.\n");
  } else {
    d->showing = FALSE;
    win_activedec();
    if (d->w == dbox__submenu) {
      wimp_wstate ws;
      tracef0("hiding submenu dbox.\n");
      wimpt_noerr(wimp_get_wind_state(d->w, &ws));
      dbox__submenu = 0;
      if ((ws.flags & wimp_WOPEN) == 0) {
        /* The dbox has been closed: presumably by the wimp. */
        /* Thus, there is nothing more to do. */
      } else {
        /* The dbox was closed without the menu tree knowing about it. */
        event_clear_current_menu();
        /* That will cause the menu system to close the dbox. */
      }
    } else {
      tracef0("hiding non-submenu dbox.\n");
      wimpt_noerr(wimp_close_wind(d->w));
    }
  }
}

void dbox_dispose(dbox *dd)
{
  dbox d = *dd;
  if (d->eventdepth != 0) {
    d->disposepending = 1;
  } else {
    if (d->showing) dbox_hide(d);
    dbox__dodispose(d);
  }
}

/* -------- Event processing. -------- */

/* We cheerfully allow the caret to go elsewhere, but we intercept any
keystroke events and divert them to the dbox. This allows e.g. find commands
to see where in the text they've got to so far. dboxes with no fill-in fields
do not even try to get the caret. */

static dbox_field dbox_fillin_loop(dbox d)
{
  wimp_eventstr e;
  int harmless;
  dbox_field result;
  wimp_wstate ws;

  while (1) {
    int null_at;
    if (alarm_next(&null_at) && (event_getmask() & wimp_EMNULL) != 0)
        wimpt_complain(wimp_pollidle(event_getmask() & ~wimp_EMNULL, &e, null_at));
    else
        wimpt_complain(wimp_poll(event_getmask(), &e));

    if (d->w == dbox__submenu) {
      wimpt_noerr(wimp_get_wind_state(d->w, &ws));
      if ((ws.flags & wimp_WOPEN) == 0) {
        tracef0("dbox has been closed for us!.\n");
        wimpt_fake_event(&e); /* stuff it back in the queue */
        if (e.e == wimp_EREDRAW) event_process();
        return dbox_CLOSE;
      }
    }

    switch (e.e) {
    case wimp_ENULL:
    case wimp_EREDRAW:
    case wimp_EPTRENTER:
    case wimp_EPTRLEAVE:
    case wimp_ESCROLL:
    case wimp_EOPEN:
    case wimp_EMENU:
    case wimp_ELOSECARET:
    case wimp_EGAINCARET:
    case wimp_EUSERDRAG:
        harmless = TRUE;
        break;
    case wimp_ECLOSE:
        harmless = e.data.o.w == d->w;
        break;
    case wimp_EKEY:
        /* Intercept all key events. */
        /* IDJ:11-Jun-91: stop useless dboxes
           stealing key presses */
        if (e.data.key.c.w != d->w && !dbox__has_action_button(d))
        {
           harmless = 0;
        }
        else
        {
           if (e.data.key.c.w != d->w) {
             e.data.key.c.w = d->w;
             e.data.key.c.i = (wimp_i) -1;
           }
           harmless = 1;
        }
        break;
    case wimp_EBUT:
        harmless = e.data.but.m.w == d->w;
        break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
#ifdef TRACE
        { int *i;
          tracef0("event in dbox:");
          for (i = (int*) &e; i != 12 + (int*) &e; i++) {
            tracef1(" %x", *i);
          }
          tracef0(".\n");
        }
#endif
        harmless = TRUE;
        if (e.data.msg.hdr.action == wimp_MPREQUIT) harmless = FALSE;
        break;
    default:
        harmless = 0;
    }
    if (harmless) {

#if TRACE
  if (e.e != wimp_ENULL) tracef1("harmless event %i.\n", e.e);
#endif

      wimpt_fake_event(&e);
      event_process();
    }
    else {
      tracef1("event %i causes DBoxes.FillIn to give up.\n", e.e);
      wimpt_fake_event(&e); /* stuff it back in the queue */
      result = dbox_CLOSE;
      break;
    }
    /* And keep going round until he presses a button. */
    if (d -> fieldwaiting) {result = dbox_get((dbox) d); break;}
  } /* loop */

  return(result);
}

dbox_field dbox_fillin(dbox d)
{
  wimp_i j = 0;

  if (dbox__findwritable(d, &j)) {
    tracef1("Set caret in icon %i.\n", j);
    d->caretstr.i = j;
    d->caretstr.x = 0;
    d->caretstr.y = 0;
    d->caretstr.height = -1;
    d->caretstr.index = dbox__min(d->caretstr.index, dbox__fieldlength(d, j));
    /* w, i already set up. */
    d->caretstr.index = dbox__fieldlength(d, j);
    wimpt_noerr(wimp_set_caret_pos(&d->caretstr));
  }

  return dbox_fillin_loop(d);
}

dbox_field dbox_fillin_fixedcaret(dbox d)
{
   wimp_i j = 0;
   wimp_caretstr caret;

   wimpt_noerr(wimp_get_caret_pos(&caret));
   if (dbox__findwritable(d, &j))
   {
      if (caret.w != d->w)
      {
         d->caretstr.i = j;
         d->caretstr.x = 0;
         d->caretstr.y = 0;
         d->caretstr.height = -1;
         d->caretstr.index = dbox__fieldlength(d, j);
         wimpt_noerr(wimp_set_caret_pos(&d->caretstr));
      }
   }
   return dbox_fillin_loop(d);
}


#ifndef UROM
dbox_field dbox_popup(char *name, char *message)
{
  dbox_field result;
  dbox d = dbox_new(name);

  if (!d) return 0;
  dbox_setfield(d, 1, message);
  dbox_show(d);
  result = dbox_fillin(d);
  dbox_dispose(&d);
  return(result);
}
#endif

BOOL dbox_persist(void) {
  wimp_mousestr m;
  wimpt_noerr(wimp_get_point_info(&m));
  return (m.bbits & wimp_BRIGHT) != 0;
}


/* -------- System Hook. -------- */

int dbox_syshandle(dbox d)
{
  if (d != NULL)
    return d->w;
  return (int)NULL;
}

/* -------- Initialisation. -------- */

void dbox_init(void)
{

  if (template_loaded() == FALSE)
      werr(0, msgs_lookup(MSGS_dbox2));
}
/* end */
@


4.7
log
@Minor rlib cleanups
dbox.c: address of cancelled by dereference
event.c: spelling
txtar.c: don't grab the caret when clicking toggle size
txtedit.c: use BOOL for a boolean
win.c: when looking at the behind window handle we want -1 not 'DUD' (which happens to be -1)
wimp.h: add comment about window handle -3
Retagged as RISC_OSLib-5_83.

Version 5.83. Not tagged
@
text
@d776 2
a777 2
      e->data.msg.data.words[1],
      e->data.msg.data.words[2]);
@


4.6
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@d723 1
a723 1
      werr(FALSE, &er->errmess[0]);
@


4.5
log
@Check for NULL pointers before finding the syshandle
menu.c: if NULL return -1, this has the added advantage that a menu maker (see event_attachmenumaker) can return NULL to mean "no menu thanks" and not data abort in event.c
dbox.c: if NULL return 0, this is somewhat consistent with template_syshandle()
menu.h: typo in comment corrected

Version 5.82. Tagged as 'RISC_OSLib-5_82'
@
text
@d166 1
d174 2
a175 3
static int dbox__findicon(dbox d, wimp_iconflags mask, wimp_iconflags settings, wimp_i *j)
/* Rather like SWI WhichIcon, but only finds the first. Returns 0 if not
found. */
d178 4
a181 2
    wimp_icon *i = ((wimp_icon*) (&d->window + 1)) + *j;
    if ((i->flags & mask) == settings) {
d183 1
a183 1
      return(1);
d186 1
a186 1
  return(0);
d189 2
a190 3
static int dbox__findiconbefore(dbox d,
  wimp_iconflags mask, wimp_iconflags settings, wimp_i *j)
/* Does not look at the current icon. */
d193 4
a196 2
    wimp_icon *i = ((wimp_icon*) (&d->window + 1)) + (--(*j));
    if ((i->flags & mask) == settings) {
d198 1
a198 1
      return(1);
d201 1
a201 1
  return(0);
a205 7
#ifndef UROM
static dbox_field dbox__icontofield(wimp_i i)
{
  return(i);
}
#endif

d223 1
a223 1
  return(i->flags & BUTTON_IFLAGS);
a265 1

a272 1

d278 15
a530 3
  wimp_icon *i;
  wimp_i j;
  char target;
d560 1
d589 1
d593 2
a594 2
              c.i < 0 ||
              0==dbox__findicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i)
d610 3
a612 1
      case  398: /* DOWN key */
d619 1
a619 1
                ! dbox__findicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i))
d622 1
a622 1
              if (dbox__findicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i)) {
d633 3
a635 1
      case  399: /* UP key */
d640 1
a640 2
            if (!dbox__findiconbefore(d,
                  WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i)) {
d642 1
a642 2
              if (dbox__findiconbefore(d,
                    WRITABLE_IFLAGS, WRITABLE_IFLAGS, &c.i)) {
d659 2
d663 5
a667 3
              i = dbox__iconhandletoptr(d, j);
              if ((i->flags & wimp_ITEXT) != 0
              && dbox__iconfieldtype(i) == dbox_FACTION) {
d669 1
d672 2
a673 2
                if ((i->flags & wimp_INDIRECT) != 0) {
                  targetptr = &i->data.indirecttext.buffer[0];
d675 1
a675 1
                  targetptr = &i->data.text[0];
d680 1
a680 1
                  if (target == 0) break;
d738 1
a738 1
  if (dbox__findicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &j)) {
d978 1
a978 1
  if (dbox__findicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &j)) {
d999 1
a999 1
   if (dbox__findicon(d, WRITABLE_IFLAGS, WRITABLE_IFLAGS, &j))
d1001 1
a1001 1
      if (caret.w != dbox_syshandle(d))
@


4.4
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d1026 3
a1028 1
  return(d->w);
@


4.3
log
@  Fixed to build with the latest cc (5.54) compiler.
Detail:
  This version now builds with cc-5_45. Note: it has not been verified as
  actually functioning correctly.
Admin:
  Tested in DSL Baseline build.

Version 5.42. Tagged as 'RISC_OSLib-5_42'
@
text
@d62 1
a62 1
#include "h.verintern.messages"
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d43 1
@


4.1
log
@Initial revision
@
text
@d15 14
d31 2
a32 7
 * History: 5-Feb-90: IDJ:  split off dbox_fillin_loop, to allow calling from dbox_fillin
 *                          and dbox_fillin_fixedcaret - the latter function doesn't move
 *                          caret to end of first writeable icon. Users of dbox_fillin
 *                          won't see any difference
 *         18-Mar-91: IDJ:  bug fix to dbox_fillin_fixedcaret (and a slight tidy to dbox_fillin)
 *         08-May-91: ECN:  #ifndefed out unused ROM functions
 *         11-Jun-91: IDJ:  fixed grabbing of key events by useless dboxes
d67 1
a67 1
                            * caret. 
d75 1
a75 1
  
d99 1
a99 1
  
d142 3
a144 1
  if (d->workspacesize != 0) {free(d->workspace);};
d152 3
a154 1
  if (d->showing) {win_activedec();};
d181 2
a182 2
    };
  };
d195 2
a196 2
    };
  };
d244 1
a244 1
  };
d251 1
a251 1
   for (j = 0; j < d->window.nicons; j++) 
d264 1
a264 1
static int dbox__min(int a, int b) {if (a<b) {return(a);} else {return(b);};}
d279 1
a279 1
  wimpt_noerr(wimp_set_icon_state(d->w, dbox__fieldtoicon(f), 
d305 1
a305 1
    };
d325 1
a325 1
  };
d338 1
a338 1
      while (i->data.indirecttext.buffer[j] >= 32) {j++;};
d341 1
a341 1
      while (i->data.text[j] >= 32 && j < 11) {j++;};
d343 2
a344 2
    };
    if (j > size) {j = size;};
d348 1
a348 1
  };
d380 1
a380 1
  };
d399 1
a399 1
    };
d408 1
a408 1
      if (fail || a[i] == 0) {break;};
d410 1
a410 1
        if (neg || (n!=0)) {fail = 1;} else {neg = 1;};
d416 1
a416 1
      };
d418 4
a421 4
    };
    if (neg) {n = -n;};
    if (fail) {n = 0;};
  };
d467 2
a468 2
    };
  };
d500 1
a500 1
          };
d502 1
a502 1
        };
d508 1
a508 1
      };
d511 2
a512 2
    };
  };
d537 2
a538 2
    };
  };
d558 2
a559 2
        };
      };
d579 1
a579 1
         
d596 1
a596 1
          };
d613 2
a614 2
              };
            };
d620 1
a620 1
          };
d633 2
a634 2
              };
            };
d640 1
a640 1
          };
d660 1
a660 1
                };
d670 1
a670 1
                  };
d672 1
a672 1
                };
d676 2
a677 2
              };
            };
d681 2
a682 2
          };
      };
d688 1
a688 1
  };
d700 1
a700 1
  };
d710 2
a711 2
    };
  };
d732 1
a732 1
  };
d774 1
a774 1
        };
d782 1
a782 1
      };
d788 1
a788 1
    };
d798 1
a798 1
    };
d801 1
a801 1
  };
d832 1
a832 1
      };
d836 2
a837 2
    };
  };
d848 1
a848 1
  };
d869 1
a869 1
    else 
d879 2
a880 2
      };
    };
d902 1
a902 1
        if (e.data.key.c.w != d->w && !dbox__has_action_button(d))  
d911 1
a911 1
           };
d926 1
a926 1
          };
d928 1
a928 1
        };
d935 1
a935 1
    };
d944 1
a944 1
    } 
d950 1
a950 1
    };
d952 2
a953 2
    if (d -> fieldwaiting) {result = dbox_get((dbox) d); break;};
  }; /* loop */
d972 1
a972 1
  };
d998 1
a998 1
   
d1019 1
a1019 1
 
d1032 1
a1032 1
 
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@a0 28
/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

d17 7
a23 2
 * History: IDJ: 05-Feb-92: prepared for source release
 *
d58 1
a58 1
                            * caret.
d66 1
a66 1

d90 1
a90 1

d133 1
a133 3
  if (d->workspacesize != 0) {
    free(d->workspace);
  }
d141 1
a141 3
  if (d->showing) {
    win_activedec();
  }
d168 2
a169 2
    }
  }
d182 2
a183 2
    }
  }
d231 1
a231 1
  }
d238 1
a238 1
   for (j = 0; j < d->window.nicons; j++)
d251 1
a251 1
static int dbox__min(int a, int b) {if (a<b) {return(a);} else {return(b);}}
d266 1
a266 1
  wimpt_noerr(wimp_set_icon_state(d->w, dbox__fieldtoicon(f),
d292 1
a292 1
    }
d312 1
a312 1
  }
d325 1
a325 1
      while (i->data.indirecttext.buffer[j] >= 32) {j++;}
d328 1
a328 1
      while (i->data.text[j] >= 32 && j < 11) {j++;}
d330 2
a331 2
    }
    if (j > size) {j = size;}
d335 1
a335 1
  }
d367 1
a367 1
  }
d386 1
a386 1
    }
d395 1
a395 1
      if (fail || a[i] == 0) {break;}
d397 1
a397 1
        if (neg || (n!=0)) {fail = 1;} else {neg = 1;}
d403 1
a403 1
      }
d405 4
a408 4
    }
    if (neg) {n = -n;}
    if (fail) {n = 0;}
  }
d454 2
a455 2
    }
  }
d487 1
a487 1
          }
d489 1
a489 1
        }
d495 1
a495 1
      }
d498 2
a499 2
    }
  }
d524 2
a525 2
    }
  }
d545 2
a546 2
        }
      }
d566 1
a566 1

d583 1
a583 1
          }
d600 2
a601 2
              }
            }
d607 1
a607 1
          }
d620 2
a621 2
              }
            }
d627 1
a627 1
          }
d647 1
a647 1
                }
d657 1
a657 1
                  }
d659 1
a659 1
                }
d663 2
a664 2
              }
            }
d668 2
a669 2
          }
      }
d675 1
a675 1
  }
d687 1
a687 1
  }
d697 2
a698 2
    }
  }
d719 1
a719 1
  }
d761 1
a761 1
        }
d769 1
a769 1
      }
d775 1
a775 1
    }
d785 1
a785 1
    }
d788 1
a788 1
  }
d819 1
a819 1
      }
d823 2
a824 2
    }
  }
d835 1
a835 1
  }
d856 1
a856 1
    else
d866 2
a867 2
      }
    }
d889 1
a889 1
        if (e.data.key.c.w != d->w && !dbox__has_action_button(d))
d898 1
a898 1
           }
d913 1
a913 1
          }
d915 1
a915 1
        }
d922 1
a922 1
    }
d931 1
a931 1
    }
d937 1
a937 1
    }
d939 2
a940 2
    if (d -> fieldwaiting) {result = dbox_get((dbox) d); break;}
  } /* loop */
d959 1
a959 1
  }
d985 1
a985 1

d1006 1
a1006 1

d1019 1
a1019 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.4;
access;
symbols
	RISC_OSLib-5_97:4.4
	RISC_OSLib-5_96:4.4
	RISC_OSLib-5_95:4.4
	RISC_OSLib-5_94:4.4
	RISC_OSLib-5_93:4.4
	RISC_OSLib-5_92:4.4
	RISC_OSLib-5_91:4.4
	RISC_OSLib-5_90:4.4
	RISC_OSLib-5_89:4.4
	RISC_OSLib-5_88:4.4
	RISC_OSLib-5_87:4.4
	RISC_OSLib-5_86-1:4.4
	RISC_OSLib-5_86:4.4
	RISC_OSLib-5_85:4.4
	RISC_OSLib-5_84:4.4
	RISC_OSLib-5_83-2:4.4
	RISC_OSLib-5_83-1:4.4
	RISC_OSLib-5_83:4.4
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.3
	RISC_OSLib-5_77:4.3
	RISC_OSLib-5_76:4.3
	RISC_OSLib-5_75:4.3
	RISC_OSLib-5_74:4.3
	RISC_OSLib-5_73:4.3
	RISC_OSLib-5_72:4.3
	RISC_OSLib-5_71:4.3
	RISC_OSLib-5_70:4.3
	RISC_OSLib-5_69:4.3
	RISC_OSLib-5_68:4.3
	RISC_OSLib-5_67:4.3
	RISC_OSLib-5_66:4.3
	RISC_OSLib-5_65:4.3
	RISC_OSLib-5_64:4.3
	RISC_OSLib-5_63:4.3
	RISC_OSLib-5_62:4.3
	RISC_OSLib-5_61:4.3
	RISC_OSLib-5_60:4.3
	RISC_OSLib-5_59:4.3
	RISC_OSLib-5_58:4.3
	RISC_OSLib-5_57:4.3
	RISC_OSLib-5_56:4.3
	RISC_OSLib-5_55:4.3
	RISC_OSLib-5_54:4.3
	RISC_OSLib-5_53:4.2
	RISC_OSLib-5_52:4.2
	RISC_OSLib-5_51:4.2
	RO_5_07:4.2
	RISC_OSLib-5_50:4.2
	RISC_OSLib-5_49:4.2
	RISC_OSLib-5_46-4_64_2_1:4.2
	NoInlineAsm:4.2.0.2
	RISC_OSLib-5_48:4.2
	RISC_OSLib-5_47:4.2
	RISC_OSLib-5_46:4.2
	RISC_OSLib-5_45:4.2
	RISC_OSLib-5_44:4.2
	RISC_OSLib-5_43:4.2
	RISC_OSLib-5_42:4.2
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2014.07.31.08.24.08;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	jfGiiZxupMtuqvKx;

4.3
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.50;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.11;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.11;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.53.45;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.30.26;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.28;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.14;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.flex
 * Purpose: provide memory allocation for interactive programs requiring
 *          large chunks of store.
 * History: IDJ: 06-Feb-92: prepared for source release
 */



#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#include "swis.h"

#include "os.h"
#include "werr.h"
#include "flex.h"
#include "trace.h"
#include "wimp.h"
#include "wimpt.h"
#include "msgs.h"
#include "VerIntern/messages.h"



static BOOL flex__initialised = FALSE;


/* This implementation goes above the original value of GetEnv,
to memory specifically requested from the Wimp. The heap is kept
totally compacted all the time, with pages being given back to
the Wimp whenever possible. */

typedef struct {
  flex_ptr anchor;      /* *anchor should point back to here. */
  int size;             /* in bytes. Exact size of logical area. */
                        /* then the actual store follows. */
} flex__rec;


static void flex__fail(int i)
{
#if TRACE
  char buff[16];
  sprintf(buff, "flex__fail %i", i);
  werr(TRUE, buff);
#else
  i = i; /* avoid compiler warning. */
  werr(TRUE, msgs_lookup(MSGS_flex1));
#endif
}


static void flex__check(void)
{
  if (!flex__initialised)
    werr(TRUE, msgs_lookup(MSGS_flex3));
}

/* macro to avoid stack usage */
#define roundup(n)  (0xfffffffc & (n + 3))

static char *flex__base;        /* lowest flex__rec - only for budging. */
static char *flex__freep;       /* free flex memory */
static char *flex__lim;         /* limit of flex memory */
/* From base upwards, it's divided into store blocks of
  a flex__rec
  the space
  align up to next word.
*/


static void flex__wimpslot(char **top)
{
  /* read/write the top of available memory. *top == 0 -> just read. */
  int dud = -1;
  int slot = ((int) *top);
  _kernel_swi_regs r;
  _kernel_oserror  *err;
  int memlim, appspace, oldmemlim;

  if (slot != -1) slot -= 0x8000;
  tracef1("flex__wimpslot in: %i.\n", slot);

  /* read memory limit value */
   r.r[0] = 0;
   r.r[1] = 0;
   r.r[2] = 0;
   err = _kernel_swi(OS_ChangeEnvironment, &r, &r);
   oldmemlim = memlim = r.r[1];

  /* read appspace value */
   r.r[0] = 14;  /* Application space */
   r.r[1] = 0;
   r.r[2] = 0;
   err = _kernel_swi(OS_ChangeEnvironment, &r, &r);
   appspace = r.r[1];
  /* set memory limit before slot size change ... */
   if(appspace > memlim)
   {
      r.r[0] = 0;
      r.r[1] = appspace;
      r.r[2] = 0;
      err = _kernel_swi(OS_ChangeEnvironment, &r, &r);
   }

  /* set wimpslot size (or read it) */
  wimpt_noerr(wimp_slotsize(&slot, &dud, &dud));
  *top = (char*) slot + 0x8000;

  /* .... and set memory limit back again */
  if (appspace > memlim)
  {
      r.r[0] = 0;
      r.r[1] = oldmemlim;
      r.r[2] = 0;
      err = _kernel_swi(OS_ChangeEnvironment, &r, &r);
   }

  tracef1("flex__wimpslot out: %i.\n", slot);
}



static BOOL flex__more(int n)
{
  /* Tries to get at least n more bytes, raising flex__lim and
  returning TRUE if it can. */
  char *prev = flex__lim;

  flex__lim += n;
  flex__wimpslot(&flex__lim);
  tracef4("flex__more, freep=%i prevlim=%i n=%i lim=%i.\n",
    (int) flex__freep, (int) prev, n, (int) flex__lim);

  if (flex__lim < prev + n)
  {
   tracef0("flex__more FAILS.\n");
   flex__lim = prev;             /* restore starting state:
                                    extra memory is useless */
   flex__wimpslot(&flex__lim);
   return FALSE ;
  }
  else return TRUE ;
}

static void flex__give(void) {
  /* Gives away memory, lowering flex__lim, if possible. */
#if TRACE
  int prev = (int) flex__lim;
#endif

  flex__lim = flex__freep;
  flex__wimpslot(&flex__lim);
  tracef3("flex__give, prev=%i freep=%i lim=%i.\n",
    prev, (int) flex__freep, (int) flex__lim);
}

static BOOL flex__ensure(int n) {
  n -= flex__lim - flex__freep;
  tracef3("flex__ensure %i: %x %x.\n", n, (int) flex__lim, (int) flex__freep);
  return (n <= 0 || flex__more(n));
}

BOOL flex_alloc(flex_ptr anchor, int n)
{
  flex__rec *p;

  tracef2("flex_alloc %x %i.\n", (int) anchor, n);

  flex__check();

  if (n < 0 || ! flex__ensure(sizeof(flex__rec) + roundup(n)))
  {
    *anchor = NULL;
    return FALSE;
  }

  p = (flex__rec*) flex__freep;
  flex__freep += sizeof(flex__rec) + roundup(n);

  p->anchor = anchor;
  p->size = n;
  *anchor = p + 1; /* sizeof(flex__rec), that is */
  return TRUE;
}

#if TRACE

static char *flex__start ;

/* show all flex pointers for debugging purposes */
void flex_display(void)
{
 flex__rec *p = (flex__rec *) flex__start ;

 tracef3("*****flex display: %x %x %x\n",
          (int) flex__start, (int) flex__freep, (int) flex__lim) ;
 while (1)
 {
  if ((int) p >= (int) flex__freep) break;

  tracef("flex block @@ %x->%x->%x",
        (int)p, (int)(p->anchor), (int)(*(p->anchor))) ;

  if (*(p->anchor) != p + 1) tracef("<<< bad block!");

  tracef("\n") ;
  p = (flex__rec*) (((char*) (p + 1)) + roundup(p->size));
 }
}

#endif

static void flex__reanchor(flex__rec *p, int by)
{
  /* Move all the anchors from p upwards. This is in anticipation
  of that block of the heap being shifted. */

  while (1) {
    if ((int) p >= (int) flex__freep) break;
   tracef1("flex__reanchor %x\n",(int) p) ;
    if (*(p->anchor) != p + 1) flex__fail(6);
    *(p->anchor) = ((char*) (p + 1)) + by;
    p = (flex__rec*) (((char*) (p + 1)) + roundup(p->size));
  }
}

void flex_free(flex_ptr anchor)
{
  flex__rec *p = ((flex__rec*) *anchor) - 1;
  int roundsize = roundup(p->size);
  flex__rec *next = (flex__rec*) (((char*) (p + 1)) + roundsize);

  tracef1("flex_free %i.\n", (int) anchor);
  flex__check();

  if (p->anchor != anchor)
  {
    flex__fail(0);
  }

  flex__reanchor(next, - (sizeof(flex__rec) + roundsize));

  memmove(
     p,
     next,
     flex__freep - (char*) next);

  flex__freep -= sizeof(flex__rec) + roundsize;

  flex__give();

  *anchor = NULL;
}

int flex_size(flex_ptr anchor)
{
  flex__rec *p = ((flex__rec*) *anchor) - 1;
  flex__check();
  if (p->anchor != anchor)
  {
    flex__fail(4);
  }
  return(p->size);
}

int flex_extend(flex_ptr anchor, int newsize)
{
  flex__rec *p = ((flex__rec*) *anchor) - 1;
  flex__check();
  return(flex_midextend(anchor, p->size, newsize - p->size));
}

BOOL flex_midextend(flex_ptr anchor, int at, int by)
{
  flex__rec *p;
  flex__rec *next;

  tracef3("flex_midextend %i at=%i by=%i.\n", (int) anchor, at, by);
  flex__check();

  p = ((flex__rec*) *anchor) - 1;
  if (p->anchor != anchor)
  {
    flex__fail(1);
  }
  if (at > p->size)
  {
    flex__fail(2);
  }
  if (by < 0 && (-by) > at)
  {
    flex__fail(3);
  }
  if (by == 0)
  {
    /* do nothing */
  } else if (by > 0)
  {
    /* extend */

    int growth = roundup(p->size + by) - roundup(p->size);
    /* Amount by which the block will actually grow. */

    if (! flex__ensure(growth))
    {
      return FALSE;
    }

    next = (flex__rec*) (((char*) (p + 1)) + roundup(p->size));
    /* The move has to happen in two parts because the moving
    of objects above is word-aligned, while the extension within
    the object may not be. */

    flex__reanchor(next, growth);

    memmove(
      ((char*) next) + roundup(growth),
      next,
      flex__freep - (char*) next);

    flex__freep += growth;

    memmove(
      ((char*) (p + 1)) + at + by,
      ((char*) (p + 1)) + at,
      p->size - at);
    p->size += by;

  }
  else
  {
    /* The block shrinks. */
    int shrinkage;

    next = (flex__rec*) (((char*) (p + 1)) + roundup(p->size));

    by = -by; /* a positive value now */
    shrinkage = roundup(p->size) - roundup(p->size - by);
      /* a positive value */

    memmove(
      ((char*) (p + 1)) + at - by,
      ((char*) (p + 1)) + at,
      p->size - at);
    p->size -= by;

    flex__reanchor(next, - shrinkage);

    memmove(
      ((char*) next) - shrinkage,
      next,
      flex__freep - (char*) next);

    flex__freep -= shrinkage;

    flex__give();

  }
  return TRUE;
}


/* stack checking off */
#pragma -s1

static int flex__budge(int n, void **a)
/* The underlying system asks us to move all flex store up (if n +ve) or
down by n bytes. If you succeed, put the store allocated in *a and return
the size. size >= roundup(n) on successful exit, and will be a multiple of
four. If you fail, return what we can.
If n is -ve, no result is required: success is assumed.
Significant stack saving done 13-12-89  -- IDJ
*/
{
  /* no need to check flex initialised */
#ifdef LIB_DEBUGGING
  { _kernel_swi_regs r;
    r.r[0] = 0x07;
    _kernel_swi(OS_WriteC, &r, &r);
  }
#endif

  if (n >= 0) /* all moving up */
  {
    int roundupn = roundup(n);
    int more = roundupn - (flex__lim - flex__freep);

    /* try to satisfy the request */
    if (more > 0)   /* ie we have to increase slot */
    {
        char *prev = flex__lim;
        flex__lim += more;

        /* in-line implementation (of flex__wimpslot)  */
        /*  to reduce stack requirements -- IDJ        */
        {
           int slot = ((int) flex__lim);
           _kernel_swi_regs r;
           _kernel_oserror  *err;
           int memlim, appspace, oldmemlim;

           if (slot != -1) slot -= 0x8000;

           /* read memory limit value */
           r.r[0] = 0;
           r.r[1] = 0;
           r.r[2] = 0;
           err = _kernel_swi(OS_ChangeEnvironment, &r, &r);
           oldmemlim = memlim = r.r[1];

           /* read appspace value */
           r.r[0] = 14;  /* Application space */
           r.r[1] = 0;
           r.r[2] = 0;
           err = _kernel_swi(OS_ChangeEnvironment, &r, &r);
           appspace = r.r[1];

           /* set memory limit before slot size change ... */
           if(appspace > memlim)
           {
              r.r[0] = 0;
              r.r[1] = appspace;
              r.r[2] = 0;
              err = _kernel_swi(OS_ChangeEnvironment, &r, &r);
           }

           /* set wimpslot size */
           /*wimpt_noerr(wimp_slotsize(&slot, &dud, &dud));*/
           r.r[0] = slot;
           r.r[1] = -1;
           err =_kernel_swi(Wimp_SlotSize, &r, &r);
           slot = r.r[0];

           flex__lim = (char*) slot + 0x8000;

           /* .... and set memory limit back again */
           if (appspace > memlim)
           {
              r.r[0] = 0;
              r.r[1] = oldmemlim;
              r.r[2] = 0;
              err = _kernel_swi(OS_ChangeEnvironment, &r, &r);
           }
        }

        /* if we couldn't satisfy it, still give back what we can, */
        /* _kernel_alloc may be able to use it!!!!!                */
        if (flex__lim < prev + more)
            roundupn = flex__lim - flex__freep; /*all we got*/
    }

    tracef0("flex__budge: moving up.\n");
    /*flex__reanchor((flex__rec*) flex__base, roundupn);*/
    {
         flex__rec *p = (flex__rec*)flex__base;
         while (1) {
              if ((int) p >= (int) flex__freep) break;
              tracef1("flex__reanchor %x\n",(int) p) ;
              *(p->anchor) = ((char*) (p + 1)) + roundupn;
              p = (flex__rec*) (((char*) (p + 1)) + roundup(p->size));
         }
     }
     memmove(
            flex__base + roundupn,
            flex__base,
            flex__freep - flex__base);
     *a = flex__base;
     flex__base += roundupn;
     flex__freep += roundupn;
     tracef1("flex__budge: success, %i bytes moved.\n", flex__freep - flex__base);
     return(roundupn);

  } else { /* all moving down */
    int roundupn = roundup(-n); /* a +ve value */

    tracef0("flex__budge: moving down.\n");
    /*flex__reanchor((flex__rec*) flex__base, -roundupn);*/
    {
         flex__rec *p = (flex__rec*)flex__base;
         while (1) {
              if ((int) p >= (int) flex__freep) break;
              tracef1("flex__reanchor %x\n",(int) p) ;
              *(p->anchor) = ((char*) (p + 1)) + roundupn;
              p = (flex__rec*) (((char*) (p + 1)) + roundup(p->size));
         }
    }
    memmove(
      flex__base - roundupn,
      flex__base,
      flex__freep - flex__base);
    flex__base -= roundupn;
    flex__freep -= roundupn;
    tracef0("flex__budge: moved down.\n");
  }
  return(0);
}

/* stack checks on again */
#pragma -s0


void flex_init(void)
{
  flex__lim = (char*) -1;
  flex__wimpslot(&flex__lim);

#if TRACE
  flex__start =
#endif

  flex__freep = flex__lim;
  flex__base = flex__freep;
  _kernel_register_slotextend(flex__budge);
  tracef1("flex__lim = %i.\n", (int) flex__lim);
  flex__initialised = TRUE;

  /* Check that we're in the Wimp environment. */
  {
    void *a;
    if (! flex_alloc(&a, 1)) {
      werr(TRUE, msgs_lookup(MSGS_flex2));
    }
    flex_free(&a);
  }

}

/* end */

@


4.3
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d45 1
a45 2
#include <kernel.h>
#include <swis.h>
d58 1
a58 1
static int flex__initialised = 0;
a74 1
  werr(TRUE, msgs_lookup(MSGS_flex1));
d76 3
a78 1
  i = *(int *)-4 ;     /* go bang! */
d81 1
d88 1
a88 1
  if(flex__initialised == 0)
d207 1
a207 1
    *anchor = 0;
d286 1
a286 1
  *anchor = 0;
d549 1
a549 1
  flex__initialised = 1;
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d48 8
a55 8
#include "h.os"
#include "h.werr"
#include "h.flex"
#include "h.trace"
#include "h.wimp"
#include "h.wimpt"
#include "h.msgs"
#include "h.verintern.messages"
@


4.1
log
@Initial revision
@
text
@d15 15
a29 1
/* Title  > c.flex
d31 2
a32 3
 *          large chunks of store. Such programs must respond to memory
 *          full errors, and must not suffer from fragmentation.
 * Version: 0.1
d35 1
a35 22
/****************************************************************************
 * This source file was written by Acorn Computers Limited. It is part of   *
 * the "cwimp" library for writing applications in C for RISC OS. It may be *
 * used freely in the creation of programs for Archimedes. It should be     *
 * used with Acorn's C Compiler Release 2 or later.                         *
 *                                                                          *
 * No support can be given to programmers using this code and, while we     *
 * believe that it is correct, no correspondence can be entered into        *
 * concerning behaviour or bugs.                                            *
 *                                                                          *
 * Upgrades of this code may or may not appear, and while every effort will *
 * be made to keep such upgrades upwards compatible, no guarantees can be   *
 * given.                                                                   *
 ***************************************************************************/

/*
 * Change list:
 *   18-Nov-88: If setting the slotsize fails, the original value is restored
 *   05-Dec-89: The concept of "budging" added. This allows the underlying C system to ask
 *     flex to move its base of memory up or down by an arbitrary amount. This
 *     allows malloc to grow and (if necessary) shrink.
 */
d57 1
a57 1
/* There are two alternative implementations in this file. */
a60 1
#if TRUE
d63 1
a63 2
to memory specifically requested from the Wimp (about which the
standard library, and malloc, know nothing). The heap is kept
d73 1
d84 1
d91 1
a91 5
/*static int roundup(int i) {
  return 0xfffffffc & (i + 3);
}*/

/* IDJ macro to avoid stack usage */
d104 1
a104 1
static void flex__wimpslot(char **top) 
d150 1
a150 1
      
d193 1
a193 1
  if (n <= 0 || flex__more(n)) return TRUE; else return FALSE;
d204 2
a205 1
  if (n < 0 || ! flex__ensure(sizeof(flex__rec) + roundup(n))) {
d208 1
a208 1
  };
d246 2
a247 1
static void flex__reanchor(flex__rec *p, int by) {
d257 1
a257 1
  };
d269 2
a270 1
  if (p->anchor != anchor) {
d272 1
a272 1
  };
d292 2
a293 1
  if (p->anchor != anchor) {
d315 2
a316 1
  if (p->anchor != anchor) {
d319 2
a320 1
  if (at > p->size) {
d323 2
a324 1
  if (by < 0 && (-by) > at) {
d327 2
a328 1
  if (by == 0) {
d330 3
a332 1
  } else if (by > 0) { /* extend */
d337 2
a338 1
    if (! flex__ensure(growth)) {
d340 1
a340 1
    };
d362 4
a365 1
  } else { /* The block shrinks. */
d391 1
a391 1
  };
d403 1
a403 1
four. If you fail, return what we can. 
d405 1
a405 1
Significant stack saving done 13-12-89  -- IDJ 
d420 1
a420 1
    
a426 4
#if 0
        flex__wimpslot(&flex__lim);
#endif 

d466 1
a466 1
           
d484 1
a484 1
    
d494 1
a494 1
         };
d518 1
a518 1
         };
d527 1
a527 1
  };
a534 8
#if 0
int flex_storefree(void)
{
  /* totally imaginary, controlled/displayed by OS. */
  return(0);
}
#endif

d555 1
a555 1
    };
a556 97
  };

}

#else

/* This is a temporary implementation, it simply goes to malloc.
Extension is done by copying, with the inevitable fragmentation resulting,
as you would expect. It is portable C, so would be useful when porting
to a different system. */

typedef struct {
  flex_ptr anchor;      /* *anchor should point back to here. */
  int size;             /* in bytes. Exact size of logical area. */
                        /* then the actual store follows. */
} flex__rec;

#define GUARDSPACE 10000
/* We always insist on this much being left before returning space from
flex. This guards against malloc falling over. */

static void flex__fail(int i)
{
  werr(TRUE, "fatal store error fl-1-%i.", i);
}

static int flex__min(int a, int b)
{
  if (a < b) {return(a);} else {return(b);};
}

int flex_alloc(flex_ptr anchor, int n)
{
  char *guard = malloc(GUARDSPACE);
  flex__rec *p;
  BOOL result;

  tracef2("flex_alloc %i %i.\n", (int) anchor, n);
  if (guard == 0) guard = malloc(GUARDSPACE);
  if (guard == 0) {
    *anchor = 0;
    return 0;
  };
  p = malloc(n + sizeof(flex__rec));
  if (p == 0) p = malloc(n + sizeof(flex__rec));
  if (p==0) {
    result = FALSE;
  } else {
    p->anchor = anchor;
    p->size = n;
    *anchor = p + 1; /* sizeof(flex__rec), that is */
    result = TRUE;
  };
  free(guard);
  if (result == 0) *anchor = 0;
  return result;
}

void flex_free(flex_ptr anchor)
{
  flex__rec *p = ((flex__rec*) *anchor) - 1;
  if (p->anchor != anchor) {
    flex__fail(0);
  }
  free(p);
  *anchor = 0;
}

int flex_size(flex_ptr anchor)
{
  flex__rec *p = ((flex__rec*) *anchor) - 1;
  if (p->anchor != anchor) {
    flex__fail(4);
  }
  return(p->size);
}

int flex_extend(flex_ptr anchor, int newsize)
{
  flex__rec *p = ((flex__rec*) *anchor) - 1;
  return(flex_midextend(anchor, p->size, newsize - p->size));
}

BOOL flex_midextend(flex_ptr anchor, int at, int by)
{
  char *guard = malloc(GUARDSPACE);
  flex__rec *p;
  BOOL result = TRUE;

  if (guard == 0) guard = malloc(GUARDSPACE);
  if (guard == 0) return FALSE;
  p = ((flex__rec*) *anchor) - 1;
  if (p->anchor != anchor) {
    flex__fail(1);
  }
  if (at > p->size) {
    flex__fail(2);
a557 27
  if (by < 0 && (-by) > at) {
    flex__fail(3);
  }
  if (by == 0) {
    /* do nothing */
  } else {
    flex__rec *p1 = malloc(p->size + by + sizeof(flex__rec));
    if (p1 == 0) p1 = malloc(p->size + by + sizeof(flex__rec));
    if (p1 == 0) {
      result = FALSE;
    } else {
      (void) memcpy(
        /* to */ p1 + 1,
        /* from */ p + 1,
        /* nbytes */ flex__min(at, at + by));
      (void) memcpy(
        /* to */ at + by + (char*) (p1 + 1),
        /* from */ at + (char*) (p1 + 1),
        /* nbytes */ p->size  - at);
      p1->anchor = anchor;
      p1->size = p->size + by;
      *anchor = p1 + 1;
    }
  };
  free(guard);
  return result;
}
a558 4
int flex_storefree(void)
{
  /* totally imaginary, at the moment. */
  return(0);
a559 11

void flex_init(void)
{
  char *guard = malloc(GUARDSPACE);
  char foo[10000];
  if (guard == 0) werr(TRUE, "Not enough space.");
  foo[123] = 0;
  free(guard);
}

#endif
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 1
a15 15
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.flex
d17 3
a19 2
 *          large chunks of store.
 * History: IDJ: 06-Feb-92: prepared for source release
d22 22
a43 1

d65 1
a65 1

d69 1
d72 2
a73 1
to memory specifically requested from the Wimp. The heap is kept
a82 1

a92 1

d99 5
a103 1
/* macro to avoid stack usage */
d116 1
a116 1
static void flex__wimpslot(char **top)
d162 1
a162 1

d205 1
a205 1
  return (n <= 0 || flex__more(n));
d216 1
a216 2
  if (n < 0 || ! flex__ensure(sizeof(flex__rec) + roundup(n)))
  {
d219 1
a219 1
  }
d257 1
a257 2
static void flex__reanchor(flex__rec *p, int by)
{
d267 1
a267 1
  }
d279 1
a279 2
  if (p->anchor != anchor)
  {
d281 1
a281 1
  }
d301 1
a301 2
  if (p->anchor != anchor)
  {
d323 1
a323 2
  if (p->anchor != anchor)
  {
d326 1
a326 2
  if (at > p->size)
  {
d329 1
a329 2
  if (by < 0 && (-by) > at)
  {
d332 1
a332 2
  if (by == 0)
  {
d334 1
a334 3
  } else if (by > 0)
  {
    /* extend */
d339 1
a339 2
    if (! flex__ensure(growth))
    {
d341 1
a341 1
    }
d363 1
a363 4
  }
  else
  {
    /* The block shrinks. */
d389 1
a389 1
  }
d401 1
a401 1
four. If you fail, return what we can.
d403 1
a403 1
Significant stack saving done 13-12-89  -- IDJ
d418 1
a418 1

d425 4
d468 1
a468 1

d486 1
a486 1

d496 1
a496 1
         }
d520 1
a520 1
         }
d529 1
a529 1
  }
d537 8
d565 1
a565 1
    }
d567 97
d665 27
d693 4
d698 11
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

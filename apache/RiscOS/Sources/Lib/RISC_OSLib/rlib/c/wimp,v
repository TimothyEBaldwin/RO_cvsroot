head	4.5;
access;
symbols
	RISC_OSLib-5_97:4.5
	RISC_OSLib-5_96:4.5
	RISC_OSLib-5_95:4.5
	RISC_OSLib-5_94:4.5
	RISC_OSLib-5_93:4.5
	RISC_OSLib-5_92:4.5
	RISC_OSLib-5_91:4.5
	RISC_OSLib-5_90:4.5
	RISC_OSLib-5_89:4.5
	RISC_OSLib-5_88:4.5
	RISC_OSLib-5_87:4.5
	RISC_OSLib-5_86-1:4.5
	RISC_OSLib-5_86:4.5
	RISC_OSLib-5_85:4.5
	RISC_OSLib-5_84:4.5
	RISC_OSLib-5_83-2:4.5
	RISC_OSLib-5_83-1:4.5
	RISC_OSLib-5_83:4.5
	RISC_OSLib-5_82:4.4
	RISC_OSLib-5_81:4.4
	RISC_OSLib-5_75-2:4.4
	RISC_OSLib-5_80:4.4
	RISC_OSLib-5_79:4.4
	RISC_OSLib-5_78:4.4
	RISC_OSLib-5_75-1:4.4
	RISC_OSLib-5_77:4.4
	RISC_OSLib-5_76:4.4
	RISC_OSLib-5_75:4.4
	RISC_OSLib-5_74:4.4
	RISC_OSLib-5_73:4.4
	RISC_OSLib-5_72:4.4
	RISC_OSLib-5_71:4.4
	RISC_OSLib-5_70:4.4
	RISC_OSLib-5_69:4.4
	RISC_OSLib-5_68:4.4
	RISC_OSLib-5_67:4.4
	RISC_OSLib-5_66:4.4
	RISC_OSLib-5_65:4.4
	RISC_OSLib-5_64:4.4
	RISC_OSLib-5_63:4.4
	RISC_OSLib-5_62:4.4
	RISC_OSLib-5_61:4.4
	RISC_OSLib-5_60:4.4
	RISC_OSLib-5_59:4.4
	RISC_OSLib-5_58:4.4
	RISC_OSLib-5_57:4.3
	RISC_OSLib-5_56:4.3
	RISC_OSLib-5_55:4.3
	RISC_OSLib-5_54:4.3
	RISC_OSLib-5_53:4.2
	RISC_OSLib-5_52:4.2
	RISC_OSLib-5_51:4.2
	RO_5_07:4.2
	RISC_OSLib-5_50:4.2
	RISC_OSLib-5_49:4.2
	RISC_OSLib-5_46-4_64_2_1:4.2
	NoInlineAsm:4.2.0.2
	RISC_OSLib-5_48:4.2
	RISC_OSLib-5_47:4.2
	RISC_OSLib-5_46:4.2
	RISC_OSLib-5_45:4.2
	RISC_OSLib-5_44:4.2
	RISC_OSLib-5_43:4.2
	RISC_OSLib-5_42:4.2
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2014.07.31.08.24.09;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	jfGiiZxupMtuqvKx;

4.4
date	2010.11.30.09.29.09;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.57;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.25;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.31.46;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.50.08;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.16;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.wimp
 * Purpose: C interface to RISC OS Wimp routines
 * History: IDJ: 07-Feb-92: prepared for source release
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "os.h"
#include "trace.h"
#ifndef __wimp_h
#define __WIMP_COMPILE
#include "wimp.h"
#endif

/*                          W I M P    S W I 's                            */
#define Initialise          0x000400C0
#define CreateWindow        0x000400C1
#define CreateIcon          0x000400C2
#define DeleteWindow        0x000400C3
#define DeleteIcon          0x000400C4
#define OpenWindow          0x000400C5
#define CloseWindow         0x000400C6
#define Poll                0x000400C7
#define RedrawWindow        0x000400C8
#define UpdateWindow        0x000400C9
#define GetRectangle        0x000400CA
#define GetWindowState      0x000400CB
#define GetWindowInfo       0x000400CC
#define SetIconState        0x000400CD
#define GetIconState        0x000400CE
#define GetPointerInfo      0x000400CF
#define DragBox             0x000400D0
#define ForceRedraw         0x000400D1
#define SetCaretPosition    0x000400D2
#define GetCaretPosition    0x000400D3
#define CreateMenu          0x000400D4
#define DecodeMenu          0x000400D5
#define WhichIcon           0x000400D6
#define SetExtent           0x000400D7
#define SetPointerShape     0x000400D8
#define OpenTemplate        0x000400D9
#define CloseTemplate       0x000400DA
#define LoadTemplate        0x000400DB
#define ProcessKey          0x000400DC
#define CloseDown           0x000400DD
#define StartTask           0x000400DE
#define ReportError         0x000400DF
#define GetWindowOutline    (0x000400c0+32)
#define PollIdle            (0x000400c0+33)
#define PlotIcon            (0x000400c0+34)
#define SetMode             (0x000400c0+35)
#define SetPalette          (0x000400c0+36)
#define ReadPalette         (0x000400c0+37)
#define SetColour           (0x000400c0+38)
#define SendMessage         (0x000400c0+39)
#define CreateSubMenu       (0x000400c0+40)
#define SpriteOp            (0x000400c0+41)
#define BaseOfSprites       (0x000400c0+42)
#define BlockCopy           (0x000400c0+43)
#define SlotSize            (0x000400c0+44)
#define ReadPixTrans        (0x000400c0+45)
#define ClaimFreeMemory     (0x000400c0+46)
#define CommandWindow       (0x000400c0+47)
#define TextColour          (0x000400c0+48)
#define TransferBlock       (0x000400c0+49)
#define ReadSysInfo         (0x000400c0+50)
#define SetFontColours      (0x000400c0+51)

#pragma -s1

#ifndef UROM
os_error *wimp_initialise (int *v)
{
  os_regset r;
  os_error *e;

  r.r[0] = 120;
  e = os_swix(Initialise, &r);
  *v =  r.r[0];
  return e;
}
#endif

#pragma -s0

#ifndef UROM
os_error *wimp_taskinit (char *name, int *version, wimp_t *t, wimp_msgaction *messages)
{
  os_regset r;
  os_error *e;

  r.r [0] = *version;
  r.r [1] = *(int *) "TASK";
  r.r [2] = (int) name;
  r.r [3] = (int) messages;

  e = os_swix (Initialise, &r);
  if (*version >= 300)
    free (messages);

  if (e == NULL)
  {
    *version = r.r [0];
    *t       = r.r [1];
  }

  return e;
}
#endif

#pragma -s1

os_error * wimp_create_wind(wimp_wind * w, wimp_w * result)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int)w;

  e = os_swix(CreateWindow, &r);

  *result = r.r[0];

  return(e);
}

os_error * wimp_create_icon(wimp_icreate * i, wimp_i * result)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int)i;

  e = os_swix(CreateIcon, &r);

  *result = r.r[0];

  return(e);
}

os_error * wimp_delete_wind(wimp_w w)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)&w;

    e = os_swix(DeleteWindow, &r);

    return(e);
}

os_error * wimp_delete_icon(wimp_w w, wimp_i i)
{
    os_regset r;
    os_error *e;
    int j[2];

    j[0] = (int)w;
    j[1] = (int)i;

    r.r[1] = (int) j;

    e = os_swix(DeleteIcon, &r);

    return(e);
}

os_error * wimp_open_wind(wimp_openstr * o)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)o;

    e = os_swix(OpenWindow, &r);

    return(e);
}


os_error * wimp_close_wind(wimp_w w)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)&w;

    e = os_swix(CloseWindow, &r);

    return(e);
}


os_error * wimp_redraw_wind(wimp_redrawstr * wr, int * result)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)wr;

    e = os_swix(RedrawWindow, &r);

    *result = r.r[0];

    return(e);
}


os_error * wimp_update_wind(wimp_redrawstr * wr, int * result)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)wr;

    e = os_swix(UpdateWindow, &r);

    *result = r.r[0];

    return(e);
}


os_error * wimp_get_rectangle(wimp_redrawstr * wr, int * result)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)wr;

    e = os_swix(GetRectangle, &r);

    *result = r.r[0];

    return(e);
}


os_error * wimp_get_wind_state(wimp_w w, wimp_wstate * result)
{
    os_regset r;
    os_error *e;

    result->o.w = w;

    r.r[1] = (int)result;

    e = os_swix(GetWindowState, &r);

    return(e);
}


os_error * wimp_get_wind_info(wimp_winfo * result)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)result;
    e = os_swix(GetWindowInfo, &r);

    return(e);
}


typedef struct {
  wimp_w    wind_h;
  wimp_i    icon_h;
  wimp_iconflags flags_v;
  wimp_iconflags flags_m;
} wimp_handles_and_flags;


os_error * wimp_set_icon_state(wimp_w w, wimp_i i,
     wimp_iconflags value, wimp_iconflags mask)
{
    os_regset r;
    os_error *e;
    wimp_handles_and_flags b;

    b.wind_h = w;
    b.icon_h = i;
    b.flags_v = value;
    b.flags_m = mask;

    r.r[1] = (int)&b;

    e = os_swix(SetIconState, &r);

    return(e);
}


typedef struct {
  wimp_w    wind_h;
  wimp_i    icon_h;
  wimp_icon icon_s;
} wimp_icon_and_handles;

os_error * wimp_get_icon_info(wimp_w w, wimp_i i, wimp_icon * result)
{
  os_regset r;
  os_error *e;
  wimp_icon_and_handles b;


  b.wind_h = w;
  b.icon_h = i;

  r.r[1] = (int)&b;

  e = os_swix(GetIconState, &r);

  *result = b.icon_s;

  return(e);
}


typedef struct {
  wimp_mousestr m;
  int dud;
} mstr;

os_error * wimp_get_point_info(wimp_mousestr * result)
{
  os_regset r;
  os_error *e;
  mstr m;

  r.r[1] = (int)&m;

  e = os_swix(GetPointerInfo, &r);

  *result = m.m;
  return(e);
}


os_error * wimp_drag_box(wimp_dragstr * d)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int)d;

  e = os_swix(DragBox, &r);

  return(e);
}


os_error * wimp_force_redraw(wimp_redrawstr * r)
{
  os_error *e;

  e = os_swix(ForceRedraw, (os_regset *)r);

  return(e);
}


os_error * wimp_set_caret_pos(wimp_caretstr * c)
{
  os_error *e;

  e = os_swix(SetCaretPosition, (os_regset *)c);

  return(e);
}


os_error * wimp_get_caret_pos(wimp_caretstr * c)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int)c;

  e = os_swix(GetCaretPosition, &r);

  return(e);
}


os_error * wimp_create_menu(wimp_menustr * m, int x, int y)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int)m;
  r.r[2] = x;
  r.r[3] = y;

  e = os_swix(CreateMenu, &r);

  return(e);
}

#ifndef UROM
os_error * wimp_decode_menu(wimp_menustr * m, void * p1, void * p2)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int)m;
  r.r[2] = (int)p1;
  r.r[3] = (int)p2;

  e = os_swix(DecodeMenu, &r);

  return(e);
}
#endif

os_error * wimp_which_icon(wimp_which_block * w, wimp_i * results)

{
  os_regset r;
  os_error *e;

  r.r[0] = w->window;
  r.r[2] = w->bit_mask;
  r.r[3] = w->bit_set;

  r.r[1] = (int)results;

  e = os_swix(WhichIcon, &r);

  return(e);
}

os_error * wimp_set_extent(wimp_redrawstr * wr)
{
  os_regset r;
  os_error *e;

  r.r[0] = wr->w;
  r.r[1] = (int)wr + 4;

  e = os_swix(SetExtent, &r);

  return(e);
}

#ifndef UROM
os_error * wimp_set_point_shape(wimp_pshapestr * p)

{
  os_error *e;

  e = os_swix(SetPointerShape, (os_regset *)p);

  return(e);
}
#endif


os_error * wimp_open_template(char * name)

{
  os_regset r;
  os_error *e;

  r.r[1] = (int)name;

  e = os_swix(OpenTemplate, &r);

  return(e);
}


os_error * wimp_close_template(void)
{
  os_regset r;
  os_error *e;

  e = os_swix(CloseTemplate, &r);

  return(e);
}


os_error * wimp_load_template(wimp_template * t)
{
  os_error *e;

  e = os_swix(LoadTemplate, (os_regset *)t);

  return(e);
}

os_error *wimp_processkey(int chcode)
{
  return os_swi1(ProcessKey, chcode);
}

#ifndef UROM
os_error * wimp_closedown(void)
{
  os_regset r;
  os_error *e;

  e = os_swix(CloseDown, &r);

  return(e);
}
#endif

os_error * wimp_taskclose(wimp_t t)
{
  os_regset r;
  os_error *e;

  r.r[0] = t;
  r.r[1] = 'T' +
          ('A' << 8) +
          ('S' << 16) +
          ('K' << 24);
    e = os_swix(CloseDown, &r);
    return e;
}

os_error *wimp_starttask(char *clicmd)
{
  os_regset r;
  os_error *e;

  r.r[0] = (int) clicmd;
  e = os_swix(StartTask, &r);
  return e;
}

os_error *wimp_getwindowoutline(wimp_redrawstr *re)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int) re;
  e = os_swix(GetWindowOutline, &r);
  return e;
}

os_error *wimp_ploticon(wimp_icon* i)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int) i;
  e = os_swix(PlotIcon, &r);
  return e;
}

#ifndef UROM
os_error *wimp_setmode(int mode)
{
  os_regset r;
  os_error *e;

  r.r[0] = mode;
  e = os_swix(SetMode, &r);
  return e;
}
#endif

os_error *wimp_readpalette(wimp_palettestr* p)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int) p;
  r.r[2] = *(int *) "TRUE";
  e = os_swix(ReadPalette, &r);

  return e;
}

#ifndef UROM
os_error *wimp_setpalette(wimp_palettestr* p)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int) p;
  e = os_swix(SetPalette, &r);
  return e;
}
#endif

os_error *wimp_setcolour(int colour)
{
  os_regset r;
  os_error *e;

  r.r[0] = colour;
  e = os_swix(SetColour, &r);
  return e;
}

#ifndef UROM
sprite_area *wimp_baseofsprites(void)
{
  os_regset r;
  os_error *e;

  e = os_swix(BaseOfSprites, &r);
  return (sprite_area *) r.r[1];
}
#endif

#ifndef UROM
sprite_area *wimp_baseofromsprites(void)
{
  os_regset r;
  os_error *e;

  e = os_swix(BaseOfSprites, &r);
  return (sprite_area *) r.r[0];
}
#endif

os_error *wimp_blockcopy(wimp_w w, wimp_box *source, int x, int y)
{
  os_regset r;

  r.r[0] = w;
  r.r[1] = source->x0;
  r.r[2] = source->y0;
  r.r[3] = source->x1;
  r.r[4] = source->y1;
  r.r[5] = x;
  r.r[6] = y;
  return os_swix(BlockCopy, &r);
}

os_error *wimp_reporterror(os_error* er, wimp_errflags flags, char *name)
{
  return os_swi3(os_X | ReportError, (int) er, flags, (int) name);
}

os_error *wimp_sendmessage(wimp_etype code, wimp_msgstr* m, wimp_t dest)
{
  return os_swi3(os_X | SendMessage, code, (int) m, dest);
}

os_error *wimp_sendwmessage(
  wimp_etype code, wimp_msgstr* m, wimp_w w, wimp_i i)
{
  return os_swi4(os_X | SendMessage, code, (int) m, w, i);
}

os_error *wimp_create_submenu(wimp_menustr *sub, int x, int y)
{
  os_regset r;
  os_error *e;

  r.r[1] = (int) sub;
  r.r[2] = x;
  r.r[3] = y;
  e = os_swix(CreateSubMenu, &r);
  return e;
}

os_error *wimp_slotsize(int *currentslot /*inout*/,
                        int *nextslot /*inout*/,
                        int *freepool /*out*/) {
  os_error *e;
  e = os_swi3r(SlotSize, *currentslot, *nextslot, 0,
               currentslot, nextslot, freepool);
  return e;
}

os_error *wimp_transferblock(
  wimp_t sourcetask,
  char *sourcebuf,
  wimp_t desttask,
  char *destbuf,
  int buflen)
{
  os_regset regs ;
  regs.r[0] = sourcetask ;
  regs.r[1] = (int) sourcebuf ;
  regs.r[2] = desttask ;
  regs.r[3] = (int) destbuf ;
  regs.r[4] = buflen ;
  regs.r[5] = 0 ;
  return os_swix(TransferBlock, &regs) ;
}

os_error *wimp_spriteop(int reason_code, char *name)
{
  os_regset r ;
  r.r[0] = reason_code ;
  r.r[2] = (int) name ;
  return os_swix(SpriteOp, &r) ;
}

os_error *wimp_spriteop_full(os_regset *r)
{
 return os_swix(SpriteOp, r) ;
}

os_error *wimp_setfontcolours(int foreground, int background)
{
  return os_swi3(os_X | SetFontColours, 0, background, foreground);
}

os_error *wimp_readpixtrans(sprite_area *area, sprite_id *id,
                         sprite_factors *factors, sprite_pixtrans *pixtrans)
{
  os_regset r;
  os_error *e;

  if ((area == sprite_mainarea) || (area == wimp_spritearea))
  {
    r.r[0] = 0x0000;
    r.r[2] = (int) id->s.name;
  }
  else if ((id->tag) == sprite_id_name)
  {
    r.r[0] = 0x0100;
    r.r[2] = (int) id->s.name;
  }
  else if ((id->tag) == sprite_id_addr)
  {
    r.r[0] = 0x0200;
    r.r[2] = (int) id->s.addr;
  }

  r.r[1] = (int) area;
  r.r[6] = (int) factors;
  r.r[7] = (int) pixtrans;

  e = os_swix(ReadPixTrans, &r);
  return(e);
}

#ifndef UROM
os_error *wimp_commandwindow(wimp_commandwind commandwindow)
{
  os_regset r;
  os_error *e;

  switch (commandwindow.tag)
  {
    case wimp_command_TITLE:
      r.r[0] = (int) commandwindow.title;
      break;
    case wimp_command_ACTIVE:
      r.r[0] = 1;
      break;
    case wimp_command_CLOSE_PROMPT:
      r.r[0] = 0;
      break;
    case wimp_command_CLOSE_NOPROMPT:
      r.r[0] = -1;
      break;
  }

  e = os_swix(CommandWindow, &r);

  return(e);
}
#endif

#pragma -s0

/* end */
@


4.4
log
@Enable 2 functions in RISC_OSLib shared entry table.
Needed by !Paint 2.02.
Fix some easy warnings in wimp.c/sprite.c.
Add new function (not in the ROM version) 'wimp_baseofromsprites()'.
bbc_adval fixed to return -1 when no ADC fitted to match Electron behaviour.
Note: the 2 reenabled functions haven't been appended to the table, so anyone who linked a RAM application against 'romastubs' would need to relink.

Version 5.58. Tagged as 'RISC_OSLib-5_58'
@
text
@d749 1
a749 1
  if ((area == (sprite_area *)0) || (area == (sprite_area *)1))
@


4.3
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@a604 1
  int i ;
d636 1
a636 1
void *wimp_baseofsprites(void)
d642 12
a653 1
  return (void*) r.r[1];
a742 1
#ifndef UROM
a771 1
#endif
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d43 1
a43 1
#include "trace .h"
@


4.1
log
@Initial revision
@
text
@d15 15
a29 1
/* Title  > c.wimp
d31 1
a31 3
 * ECN 08-May-91 #ifndefed out unused ROM functions
 * ECN 13-May-91 Turned off stack checking on selected functions
 * AMcC 28-Oct-94 Include wimp_ploticon and wimp_which_icon in ROM lib (for Paint)
a48 2
#define MessageTrans_ErrorLookup          0x41506

d107 3
d111 4
a114 7
{  os_regset r;
   os_error *e;

   r.r[0] = 120;
   e = os_swix(Initialise, &r);
   *v =  r.r[0];
   return e;
d121 1
a121 8
/* ECN: This used to be a simple veneer function, now it looks like the
 *      rest of RISC_OSLib, fortunately it does not appear to be used.
 *      Review!, some suggestions: remove call to malloc and have caller
 *      provide a buffer.
 */
os_error *wimp_taskinit (char *name, int *version,
                         wimp_t *t, wimp_msgaction *messages)

d123 2
a124 2
   os_regset r;
   os_error *e;
d126 8
a133 4
   r.r [0] = *version;
   r.r [1] = *(int *) "TASK";
   r.r [2] = (int) name;
   r.r [3] = (int) messages;
d135 5
a139 3
   e = os_swix (Initialise, &r);
   if (*version >= 300)
      free (messages);
d141 1
a141 6
   if (e == NULL)
   {  *version = r.r [0];
      *t       = r.r [1];
   }

   return e;
d149 2
d152 1
a152 6
os_regset r;
os_error *e;

r.r[1] = (int)w;

e = os_swix(CreateWindow, &r);
d154 1
a154 1
*result = r.r[0]; 
d156 1
a156 1
return(e);
d158 1
d163 2
d166 1
a166 6
os_regset r;
os_error *e;

r.r[1] = (int)i;

e = os_swix(CreateIcon, &r);
d168 1
a168 1
*result = r.r[0]; 
d170 1
a170 1
return(e);
d172 1
d177 2
d180 1
a180 2
os_regset r;
os_error *e;
d182 1
a182 5
r.r[1] = (int)&w;

e = os_swix(DeleteWindow, &r);

return(e);
d184 1
d189 3
d193 2
a194 8
os_regset r;
os_error *e;
int j[2];

j[0] = (int)w;
j[1] = (int)i;

r.r[1] = (int) j;
d196 1
a196 1
e = os_swix(DeleteIcon, &r);
d198 1
a198 1
return(e);
d200 1
d205 2
d208 1
a208 2
os_regset r;
os_error *e;
d210 1
a210 5
r.r[1] = (int)o;

e = os_swix(OpenWindow, &r);

return(e);
d212 1
d218 2
d221 1
a221 4
os_regset r;
os_error *e;

r.r[1] = (int)&w;
d223 1
a223 3
e = os_swix(CloseWindow, &r);

return(e);
d225 1
d231 2
d234 1
a234 4
os_regset r;
os_error *e;

r.r[1] = (int)wr;
d236 1
a236 1
e = os_swix(RedrawWindow, &r);
d238 1
a238 3
*result = r.r[0];

return(e);
d240 1
d246 2
d249 1
a249 4
os_regset r;
os_error *e;

r.r[1] = (int)wr;
d251 1
a251 1
e = os_swix(UpdateWindow, &r);
d253 1
a253 3
*result = r.r[0];

return(e);
d255 1
d261 2
d264 1
a264 4
os_regset r;
os_error *e;

r.r[1] = (int)wr;
d266 1
a266 1
e = os_swix(GetRectangle, &r);
d268 1
a268 3
*result = r.r[0];

return(e);
d270 1
d276 2
d279 1
a279 4
os_regset r;
os_error *e;

result->o.w = w;
d281 1
a281 1
r.r[1] = (int)result;
d283 1
a283 3
e = os_swix(GetWindowState, &r);

return(e);
d285 1
a289 1

d291 2
d294 2
a295 7
os_regset r;
os_error *e;

r.r[1] = (int)result;
e = os_swix(GetWindowInfo, &r);

return(e);
d297 1
d309 1
a309 1
os_error * wimp_set_icon_state(wimp_w w, wimp_i i, 
d312 3
d316 4
a319 3
os_regset r;
os_error *e;
wimp_handles_and_flags b;
d321 1
a321 4
b.wind_h = w;
b.icon_h = i;
b.flags_v = value;
b.flags_m = mask;
d323 1
a323 5
r.r[1] = (int)&b;

e = os_swix(SetIconState, &r);

return(e);
d325 1
a335 1

d337 3
a340 7
os_regset r;
os_error *e;
wimp_icon_and_handles b;


b.wind_h = w;
b.icon_h = i;
d342 2
a343 1
r.r[1] = (int)&b;
d345 1
a345 1
e = os_swix(GetIconState, &r);
d347 1
a347 1
*result = b.icon_s;
d349 1
a349 1
return(e);
d351 1
a360 1

d362 3
d366 1
a366 5
os_regset r;
os_error *e;
mstr m;

r.r[1] = (int)&m;
d368 1
a368 4
e = os_swix(GetPointerInfo, &r);

*result = m.m;
return(e);
d370 2
d377 2
d380 1
a380 4
os_regset r;
os_error *e;

r.r[1] = (int)d;
d382 1
a382 3
e = os_swix(DragBox, &r);

return(e);
d384 1
a388 1

d390 1
d392 1
a392 5
os_error *e;

e = os_swix(ForceRedraw, (os_regset *)r);

return(e);
d394 1
d400 1
d402 1
a402 5
os_error *e;

e = os_swix(SetCaretPosition, (os_regset *)c);

return(e);
d404 1
a408 1

d410 2
d413 1
a413 2
os_regset r;
os_error *e;
d415 1
a415 5
r.r[1] = (int)c;

e = os_swix(GetCaretPosition, &r);

return(e);
d417 1
a421 1

d423 2
d426 3
a428 2
os_regset r;
os_error *e;
d430 1
a430 7
r.r[1] = (int)m;
r.r[2] = x;
r.r[3] = y;

e = os_swix(CreateMenu, &r);

return(e);
d432 1
a436 1

d438 2
d441 3
a443 6
os_regset r;
os_error *e;

r.r[1] = (int)m;
r.r[2] = (int)p1;
r.r[3] = (int)p2;
d445 1
a445 3
e = os_swix(DecodeMenu, &r);

return(e);
d447 1
d454 2
d457 3
a459 6
os_regset r;
os_error *e;

r.r[0] = w->window;
r.r[2] = w->bit_mask;
r.r[3] = w->bit_set;
d461 1
a461 1
r.r[1] = (int)results;
d463 1
a463 3
e = os_swix(WhichIcon, &r);

return(e);
d465 1
d470 2
d473 2
a474 7
os_regset r;
os_error *e;

r.r[0] = wr->w;
r.r[1] = (int)wr + 4;

e = os_swix(SetExtent, &r);
d476 1
a476 1
return(e);
d478 1
d485 1
d487 1
a487 5
os_error *e;

e = os_swix(SetPointerShape, (os_regset *)p);

return(e);
d489 1
d497 2
d500 1
a500 4
os_regset r;
os_error *e;

r.r[1] = (int)name;
d502 1
a502 3
e = os_swix(OpenTemplate, &r);

return(e);
d504 1
d510 2
d513 1
a513 6
os_regset r;
os_error *e;

e = os_swix(CloseTemplate, &r);

return(e);
d515 1
a519 1

d521 1
d523 1
a523 5
os_error *e;

e = os_swix(LoadTemplate, (os_regset *)t);

return(e);
d525 1
d528 2
a529 1
os_error *wimp_processkey(int chcode) {
a534 1

d536 2
d539 1
a539 6
os_regset r;
os_error *e;

e = os_swix(CloseDown, &r);

return(e);
d541 1
a545 1

d547 2
a548 2
os_regset r;
os_error *e;
d550 7
a556 7
r.r[0] = t;
r.r[1] = 'T' +
        ('A' << 8) +
        ('S' << 16) +
        ('K' << 24);
  e = os_swix(CloseDown, &r);
  return e;
d608 1
a608 1
  r.r[2] = *(int *) "TRUE"; /*Fix MED-1878 J R C 20th Jan 1994*/
a610 8
  #if 0 /*don't do this*/
  for (i=0 ; i<20; i++)
  {
   int t = ((int *)p)[i] & 0xF0F0F0FF ;
   ((int *)p)[i] = t | ((t>>4) & 0xF0F0F00) ;
                   /* copy all the colour nibbles down, to scale by 17/16 */
  }
  #endif
d705 8
a712 8
 os_regset regs ;
 regs.r[0] = sourcetask ;
 regs.r[1] = (int) sourcebuf ;
 regs.r[2] = desttask ;
 regs.r[3] = (int) destbuf ;
 regs.r[4] = buflen ;
 regs.r[5] = 0 ;
 return os_swix(TransferBlock, &regs) ;
d717 4
a720 4
 os_regset r ;
 r.r[0] = reason_code ;
 r.r[2] = (int) name ;
 return os_swix(SpriteOp, &r) ;
d734 1
a734 1
os_error *wimp_readpixtrans(sprite_area *area, sprite_id *id, 
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 1
a15 15
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.wimp
d17 3
a19 1
 * History: IDJ: 07-Feb-92: prepared for source release
d37 2
a96 3
{
  os_regset r;
  os_error *e;
d98 7
a104 4
  r.r[0] = 120;
  e = os_swix(Initialise, &r);
  *v =  r.r[0];
  return e;
d111 8
a118 1
os_error *wimp_taskinit (char *name, int *version, wimp_t *t, wimp_msgaction *messages)
d120 7
a126 2
  os_regset r;
  os_error *e;
d128 3
a130 8
  r.r [0] = *version;
  r.r [1] = *(int *) "TASK";
  r.r [2] = (int) name;
  r.r [3] = (int) messages;

  e = os_swix (Initialise, &r);
  if (*version >= 300)
    free (messages);
d132 4
a135 5
  if (e == NULL)
  {
    *version = r.r [0];
    *t       = r.r [1];
  }
d137 1
a137 1
  return e;
a144 2
  os_regset r;
  os_error *e;
d146 6
a151 1
  r.r[1] = (int)w;
d153 1
a153 1
  e = os_swix(CreateWindow, &r);
d155 1
a155 1
  *result = r.r[0];
a156 1
  return(e);
a160 2
  os_regset r;
  os_error *e;
d162 6
a167 1
  r.r[1] = (int)i;
d169 1
a169 1
  e = os_swix(CreateIcon, &r);
d171 1
a171 1
  *result = r.r[0];
a172 1
  return(e);
a176 2
    os_regset r;
    os_error *e;
d178 2
a179 1
    r.r[1] = (int)&w;
d181 5
a185 1
    e = os_swix(DeleteWindow, &r);
a186 1
    return(e);
a190 3
    os_regset r;
    os_error *e;
    int j[2];
d192 8
a199 2
    j[0] = (int)w;
    j[1] = (int)i;
d201 1
a201 1
    r.r[1] = (int) j;
d203 1
a203 1
    e = os_swix(DeleteIcon, &r);
a204 1
    return(e);
a208 2
    os_regset r;
    os_error *e;
d210 2
a211 1
    r.r[1] = (int)o;
d213 5
a217 1
    e = os_swix(OpenWindow, &r);
a218 1
    return(e);
a223 2
    os_regset r;
    os_error *e;
d225 4
a228 1
    r.r[1] = (int)&w;
d230 3
a232 1
    e = os_swix(CloseWindow, &r);
a233 1
    return(e);
a238 2
    os_regset r;
    os_error *e;
d240 4
a243 1
    r.r[1] = (int)wr;
d245 1
a245 1
    e = os_swix(RedrawWindow, &r);
d247 3
a249 1
    *result = r.r[0];
a250 1
    return(e);
a255 2
    os_regset r;
    os_error *e;
d257 4
a260 1
    r.r[1] = (int)wr;
d262 1
a262 1
    e = os_swix(UpdateWindow, &r);
d264 3
a266 1
    *result = r.r[0];
a267 1
    return(e);
a272 2
    os_regset r;
    os_error *e;
d274 4
a277 1
    r.r[1] = (int)wr;
d279 1
a279 1
    e = os_swix(GetRectangle, &r);
d281 3
a283 1
    *result = r.r[0];
a284 1
    return(e);
a289 2
    os_regset r;
    os_error *e;
d291 4
a294 1
    result->o.w = w;
d296 1
a296 1
    r.r[1] = (int)result;
d298 3
a300 1
    e = os_swix(GetWindowState, &r);
a301 1
    return(e);
d306 1
a307 2
    os_regset r;
    os_error *e;
d309 7
a315 2
    r.r[1] = (int)result;
    e = os_swix(GetWindowInfo, &r);
a316 1
    return(e);
d328 1
a328 1
os_error * wimp_set_icon_state(wimp_w w, wimp_i i,
a330 3
    os_regset r;
    os_error *e;
    wimp_handles_and_flags b;
d332 3
a334 4
    b.wind_h = w;
    b.icon_h = i;
    b.flags_v = value;
    b.flags_m = mask;
d336 4
a339 1
    r.r[1] = (int)&b;
d341 5
a345 1
    e = os_swix(SetIconState, &r);
a346 1
    return(e);
d357 1
a358 3
  os_regset r;
  os_error *e;
  wimp_icon_and_handles b;
d360 7
d368 1
a368 2
  b.wind_h = w;
  b.icon_h = i;
d370 1
a370 1
  r.r[1] = (int)&b;
d372 1
a372 1
  e = os_swix(GetIconState, &r);
d374 1
a374 1
  *result = b.icon_s;
a375 1
  return(e);
d385 1
a386 3
  os_regset r;
  os_error *e;
  mstr m;
d388 7
a394 1
  r.r[1] = (int)&m;
d396 2
a397 1
  e = os_swix(GetPointerInfo, &r);
a398 2
  *result = m.m;
  return(e);
a403 2
  os_regset r;
  os_error *e;
d405 6
a410 1
  r.r[1] = (int)d;
d412 1
a412 1
  e = os_swix(DragBox, &r);
a413 1
  return(e);
d418 1
a419 1
  os_error *e;
d421 5
a425 1
  e = os_swix(ForceRedraw, (os_regset *)r);
a426 1
  return(e);
a431 1
  os_error *e;
d433 5
a437 1
  e = os_swix(SetCaretPosition, (os_regset *)c);
a438 1
  return(e);
d443 1
a444 2
  os_regset r;
  os_error *e;
d446 6
a451 1
  r.r[1] = (int)c;
d453 1
a453 1
  e = os_swix(GetCaretPosition, &r);
a454 1
  return(e);
d459 1
a460 2
  os_regset r;
  os_error *e;
d462 8
a469 3
  r.r[1] = (int)m;
  r.r[2] = x;
  r.r[3] = y;
d471 1
a471 1
  e = os_swix(CreateMenu, &r);
a472 1
  return(e);
d477 1
a478 2
  os_regset r;
  os_error *e;
d480 8
a487 3
  r.r[1] = (int)m;
  r.r[2] = (int)p1;
  r.r[3] = (int)p2;
d489 1
a489 1
  e = os_swix(DecodeMenu, &r);
a490 1
  return(e);
a496 2
  os_regset r;
  os_error *e;
d498 8
a505 3
  r.r[0] = w->window;
  r.r[2] = w->bit_mask;
  r.r[3] = w->bit_set;
d507 1
a507 1
  r.r[1] = (int)results;
d509 1
a509 1
  e = os_swix(WhichIcon, &r);
a510 1
  return(e);
a514 2
  os_regset r;
  os_error *e;
d516 7
a522 2
  r.r[0] = wr->w;
  r.r[1] = (int)wr + 4;
d524 1
a524 1
  e = os_swix(SetExtent, &r);
a525 1
  return(e);
a531 1
  os_error *e;
d533 5
a537 1
  e = os_swix(SetPointerShape, (os_regset *)p);
a538 1
  return(e);
a545 2
  os_regset r;
  os_error *e;
d547 6
a552 1
  r.r[1] = (int)name;
d554 1
a554 1
  e = os_swix(OpenTemplate, &r);
a555 1
  return(e);
a560 2
  os_regset r;
  os_error *e;
d562 6
a567 1
  e = os_swix(CloseTemplate, &r);
a568 1
  return(e);
d573 1
a574 1
  os_error *e;
d576 5
a580 1
  e = os_swix(LoadTemplate, (os_regset *)t);
a581 1
  return(e);
d584 1
a584 2
os_error *wimp_processkey(int chcode)
{
d590 1
a591 2
  os_regset r;
  os_error *e;
d593 6
a598 1
  e = os_swix(CloseDown, &r);
a599 1
  return(e);
d604 1
d606 2
a607 2
  os_regset r;
  os_error *e;
d609 7
a615 7
  r.r[0] = t;
  r.r[1] = 'T' +
          ('A' << 8) +
          ('S' << 16) +
          ('K' << 24);
    e = os_swix(CloseDown, &r);
    return e;
d667 1
a667 1
  r.r[2] = *(int *) "TRUE";
d670 8
d772 8
a779 8
  os_regset regs ;
  regs.r[0] = sourcetask ;
  regs.r[1] = (int) sourcebuf ;
  regs.r[2] = desttask ;
  regs.r[3] = (int) destbuf ;
  regs.r[4] = buflen ;
  regs.r[5] = 0 ;
  return os_swix(TransferBlock, &regs) ;
d784 4
a787 4
  os_regset r ;
  r.r[0] = reason_code ;
  r.r[2] = (int) name ;
  return os_swix(SpriteOp, &r) ;
d801 1
a801 1
os_error *wimp_readpixtrans(sprite_area *area, sprite_id *id,
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.6;
access;
symbols
	RISC_OSLib-5_97:4.6
	RISC_OSLib-5_96:4.6
	RISC_OSLib-5_95:4.6
	RISC_OSLib-5_94:4.6
	RISC_OSLib-5_93:4.6
	RISC_OSLib-5_92:4.6
	RISC_OSLib-5_91:4.6
	RISC_OSLib-5_90:4.6
	RISC_OSLib-5_89:4.6
	RISC_OSLib-5_88:4.6
	RISC_OSLib-5_87:4.6
	RISC_OSLib-5_86-1:4.6
	RISC_OSLib-5_86:4.6
	RISC_OSLib-5_85:4.6
	RISC_OSLib-5_84:4.6
	RISC_OSLib-5_83-2:4.5
	RISC_OSLib-5_83-1:4.5
	RISC_OSLib-5_83:4.5
	RISC_OSLib-5_82:4.4
	RISC_OSLib-5_81:4.4
	RISC_OSLib-5_75-2:4.4
	RISC_OSLib-5_80:4.4
	RISC_OSLib-5_79:4.4
	RISC_OSLib-5_78:4.4
	RISC_OSLib-5_75-1:4.4
	RISC_OSLib-5_77:4.4
	RISC_OSLib-5_76:4.4
	RISC_OSLib-5_75:4.4
	RISC_OSLib-5_74:4.4
	RISC_OSLib-5_73:4.4
	RISC_OSLib-5_72:4.4
	RISC_OSLib-5_71:4.4
	RISC_OSLib-5_70:4.4
	RISC_OSLib-5_69:4.4
	RISC_OSLib-5_68:4.4
	RISC_OSLib-5_67:4.4
	RISC_OSLib-5_66:4.4
	RISC_OSLib-5_65:4.4
	RISC_OSLib-5_64:4.4
	RISC_OSLib-5_63:4.4
	RISC_OSLib-5_62:4.4
	RISC_OSLib-5_61:4.4
	RISC_OSLib-5_60:4.4
	RISC_OSLib-5_59:4.4
	RISC_OSLib-5_58:4.4
	RISC_OSLib-5_57:4.4
	RISC_OSLib-5_56:4.4
	RISC_OSLib-5_55:4.4
	RISC_OSLib-5_54:4.4
	RISC_OSLib-5_53:4.3
	RISC_OSLib-5_52:4.3
	RISC_OSLib-5_51:4.3
	RO_5_07:4.3
	RISC_OSLib-5_50:4.3
	RISC_OSLib-5_49:4.3
	RISC_OSLib-5_46-4_64_2_1:4.3
	NoInlineAsm:4.3.0.2
	RISC_OSLib-5_48:4.3
	RISC_OSLib-5_47:4.3
	RISC_OSLib-5_46:4.3
	RISC_OSLib-5_45:4.3
	RISC_OSLib-5_44:4.3
	RISC_OSLib-5_43:4.2
	RISC_OSLib-5_42:4.2
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2015.04.03.19.21.09;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	U0s6ekpjDdEE9bgy;

4.5
date	2014.07.31.08.24.09;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	jfGiiZxupMtuqvKx;

4.4
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.15.15.00.32;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.58;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.29;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.31.53;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.50.11;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.16;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Extend rlib xferrecv API
Add xferrecv_last_ref to get hold of the Wimp message id of the request for a scrap file data save, when the RAM transfer gets no reply. This is useful to allow the data save to be distinguished from a file being dragged to an application, without having to resort to string compares against <wimp$scrap>.
SWIOptions:
 Also add RTC to SWI exports, and remove redundant ones.
armsys.c:
 Treat cmd_string as a pointer.
xferrecv.c/.h/rl_entries:
 New function xferrecv_last_ref.

Version 5.84. Tagged as 'RISC_OSLib-5_84'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.xferrecv
 * Purpose: general purpose import of data by dragging icon
 * History: IDJ: 07-Feb-92: prepared for source release
 *
 */

#include <string.h>
#include <stdio.h>
#include "swis.h"

#include "trace.h"
#include "os.h"
#include "bbc.h"
#include "wimp.h"
#include "wimpt.h"
#include "win.h"
#include "dbox.h"
#include "typdat.h"
#include "xfersend.h"
#include "fileicon.h"
#include "werr.h"
#include "menu.h"
#include "event.h"
#include "xferrecv.h"
#include "msgs.h"
#include "VerIntern/messages.h"

typedef enum
{
 xferrecv_state_Ask,
 xferrecv_state_Talk,
 xferrecv_state_Done,
 xferrecv_state_Broken
} xferrecv_stateval ;


static wimp_t xferrecv_sendertask ;

#ifdef SHARED_C_LIBRARY
static wimp_msgstr xferrecv_ack = {0};
#else
static wimp_msgstr xferrecv_ack;
#endif

static xferrecv_buffer_processor xferrecv_processbuff ;
static char *xferrecv_buffer ;
static int xferrecv_buffersize ;
static int xferrecv_state ;
static int xferrecv_msgid ;

static int scrap_ref = 0 ;
static int xferrecv__fileissafe ;

int xferrecv_checkinsert(char **filename)
{

 wimp_eventstr *e = wimpt_last_event();

 if ((e->e==wimp_ESENDWANTACK || e->e == wimp_ESEND) &&
     (e->data.msg.hdr.action == wimp_MDATALOAD ||
      e->data.msg.hdr.action == wimp_MDATAOPEN))
 {
  tracef4("xferrecv_checkinsert returning filetype %x: %d %d %d\n",
           e->data.msg.data.dataload.type,
           scrap_ref,e->data.msg.hdr.your_ref,e->data.msg.hdr.my_ref) ;
  xferrecv__fileissafe = e->data.msg.hdr.your_ref != scrap_ref ||
                         scrap_ref==0 ;
  xferrecv_ack.hdr.action = wimp_MDATALOADOK ;
  xferrecv_ack.hdr.size = sizeof(wimp_msghdr) ;
  xferrecv_sendertask = e->data.msg.hdr.task ;
  xferrecv_ack.hdr.your_ref = e->data.msg.hdr.my_ref ;
  *filename = e->data.msg.data.dataload.name ;
  return e->data.msg.data.dataload.type ;
 }
 else return -1 ;
}

void xferrecv_insertfileok(void)
{
/* An insert has been completed successfully. This sends an acknowledge back
   to the original application. */

 tracef0("xferrecv_insertfileok\n") ;

 if (!xferrecv__fileissafe)
 {
  tracef0("Must delete scrap file\n") ;
  os_cli("%remove <Wimp$Scrap>") ;
 }
 scrap_ref = 0 ;
 (void) wimp_sendmessage(wimp_ESEND, &xferrecv_ack, xferrecv_sendertask);
}

int xferrecv_checkprint(char **filename)
{
 wimp_eventstr *e = wimpt_last_event();

 if ((e->e==wimp_ESENDWANTACK || e->e == wimp_ESEND) &&
     (e->data.msg.hdr.action == wimp_MPrintTypeOdd))
 {
  tracef4("xferrecv_checkprint returning filetype %x: %d %d %d\n",
           e->data.msg.data.print.type,
           scrap_ref,e->data.msg.hdr.your_ref,e->data.msg.hdr.my_ref) ;

  xferrecv__fileissafe = 0 ;
  xferrecv_ack.hdr.action = wimp_MPrintTypeKnown ;
  xferrecv_ack.hdr.size = sizeof(wimp_msghdr)+sizeof(wimp_msgprint) ;
  xferrecv_sendertask = e->data.msg.hdr.task ;
  xferrecv_ack.hdr.your_ref = e->data.msg.hdr.my_ref ;
  *filename = e->data.msg.data.print.name ;
  return e->data.msg.data.print.type ;
 }
 else return -1 ;
}


void xferrecv_printfileok(int type)
{
 xferrecv_ack.data.print.type = type ;
 (void) wimp_sendmessage(wimp_ESEND, &xferrecv_ack, xferrecv_sendertask);
}

int xferrecv_checkimport(int *estsize)
{
 wimp_eventstr *e = wimpt_last_event();

 if ((e->e==wimp_ESENDWANTACK || e->e == wimp_ESEND) &&
     e->data.msg.hdr.action == wimp_MDATASAVE)
 {
  xferrecv_ack.hdr.size = sizeof(wimp_msghdr) + sizeof(wimp_msgdatasaveok) ;
  xferrecv_sendertask = e->data.msg.hdr.task ;
  xferrecv_ack.hdr.your_ref = e->data.msg.hdr.my_ref ;
  xferrecv_ack.hdr.action = wimp_MDATASAVEOK ;
  xferrecv_ack.data.datasaveok.w = e->data.msg.data.datasave.w ;
  xferrecv_ack.data.datasaveok.i = e->data.msg.data.datasave.i ;
  xferrecv_ack.data.datasaveok.x = e->data.msg.data.datasave.x ;
  xferrecv_ack.data.datasaveok.y = e->data.msg.data.datasave.y ;
  xferrecv_ack.data.datasaveok.type = e->data.msg.data.datasave.type ;
  *estsize = xferrecv_ack.data.datasaveok.estsize
           = e->data.msg.data.datasave.estsize ;

  tracef2("xferrecv_checkimport returning filetype %x from %d\n",
           e->data.msg.data.datasave.type,xferrecv_sendertask) ;

  return  xferrecv_ack.data.datasaveok.type = e->data.msg.data.datasave.type ;
 }
 else return -1 ;
}


static void  xferrecv_sendRAMFETCH(void)
{
 int size = xferrecv_ack.hdr.size ;
 wimp_msgaction action = xferrecv_ack.hdr.action ;
 char *addr = xferrecv_ack.data.ramfetch.addr ;
 int nbytes = xferrecv_ack.data.ramfetch.nbytes ;

 tracef2("xferrecv_sendRAMFETCH with buffer %x, size %d :",
          (int) xferrecv_buffer,xferrecv_buffersize) ;

 xferrecv_ack.hdr.size = sizeof(wimp_msghdr) + sizeof(wimp_msgramfetch) ;
 xferrecv_ack.hdr.action = wimp_MRAMFETCH ;
 xferrecv_ack.data.ramfetch.addr = xferrecv_buffer ;
 xferrecv_ack.data.ramfetch.nbytes = xferrecv_buffersize ;
 (void) wimp_sendmessage(wimp_ESENDWANTACK,
                         &xferrecv_ack,
                         xferrecv_sendertask);
 xferrecv_msgid = xferrecv_ack.hdr.my_ref ;

 tracef1(" ramfetch msg id %d\n",xferrecv_msgid) ;

 /* Put back the original ack */
 xferrecv_ack.data.ramfetch.nbytes=nbytes ;
 xferrecv_ack.data.ramfetch.addr=addr ;
 xferrecv_ack.hdr.action = action ;
 xferrecv_ack.hdr.size = size ;
}

static BOOL xferrecv_unknown_events(wimp_eventstr *e, void *handle)
{
 handle = handle ;

#if TRACE
 tracef("xferrecv_unknown_events %d %d %d %d %d\n",e->e,
         e->data.msg.hdr.action,e->data.msg.hdr.my_ref,
         e->data.msg.hdr.your_ref,xferrecv_msgid) ;
#endif

 if ((e->e == wimp_ESEND || e->e == wimp_ESENDWANTACK) &&
     e->data.msg.hdr.your_ref == xferrecv_msgid &&
     e->data.msg.hdr.action == wimp_MRAMTRANSMIT)
 {
  tracef2("xferrecv got ramtransmit of %d into %d\n",
          e->data.msg.data.ramtransmit.nbyteswritten,xferrecv_buffersize) ;
  if (e->data.msg.data.ramtransmit.nbyteswritten == xferrecv_buffersize
      && e->data.msg.data.ramtransmit.nbyteswritten != 0)
  {
   /* other end has filled our buffer; better try and allocate some more
      space */
   if (xferrecv_processbuff(&xferrecv_buffer, &xferrecv_buffersize))
   {
    /* can go on */
    tracef2("users buffer processor set buffer %x, size %d\n",
             (int) xferrecv_buffer, xferrecv_buffersize) ;

    xferrecv_ack.hdr.your_ref = e->data.msg.hdr.my_ref ;
    xferrecv_sendRAMFETCH() ;
    xferrecv_state = xferrecv_state_Talk ;
   }
   else
   {
    tracef0("users buffer processor failed: break down\n") ;
    xferrecv_state = xferrecv_state_Broken ;
   }
  }
  else
  {
   tracef0("xferrecv had final ramtransmit; set done state\n") ;
   xferrecv_buffersize = e->data.msg.data.ramtransmit.nbyteswritten ;
   xferrecv_state = xferrecv_state_Done ;
  }
 }
 else if (e->e == wimp_EACK && e->data.msg.hdr.my_ref == xferrecv_msgid)
 {
  tracef0("xferrecv ramfetch bounced: ") ;
  /* got our message back */
  if (xferrecv_state == xferrecv_state_Ask)
  {
   os_regset r ;
   tracef0("ask for Wimp$Scrap transfer\n") ;

   /* first check that variable exists */
   r.r[0] = (int) "Wimp$Scrap" ;
   r.r[1] = NULL ;
   r.r[2] = -1 ;
   r.r[3] = 0 ;
   r.r[4] = 0 ;          /* don't use 3 cos buffer size unsigned for macro expansion (fixed in 4.15) */
   os_swix(OS_ReadVarVal+os_X, &r) ;

   if (r.r[2]==0)
     werr(0,msgs_lookup(MSGS_xferrecv1)) ;
   else
   {
    strcpy(xferrecv_ack.data.datasaveok.name, "<Wimp$Scrap>") ;
    xferrecv_ack.data.datasaveok.estsize = -1 ; /* file is not safe with us */
    (void) wimp_sendmessage(wimp_ESEND, &xferrecv_ack, xferrecv_sendertask);
    scrap_ref = xferrecv_ack.hdr.my_ref ;
   }
  }
  else
  {
   tracef0("tell the user the protocol fell down\n") ;
   werr(0, msgs_lookup(MSGS_xferrecv2)) ;
  }
  xferrecv_state = xferrecv_state_Broken ;
 }
 else return FALSE ;

 return TRUE ;
}

int xferrecv_doimport(char *buf, int size, xferrecv_buffer_processor p)
{

/* Receives data into the buffer; calls the buffer processor if the buffer
   given becomes full. Returns -1 if the transaction failed, else the size
   of the final buffer that was transferred.
 */

 win_add_unknown_event_processor(xferrecv_unknown_events, 0) ;

 tracef0("xferrecv_doimport entered\n") ;
 xferrecv_processbuff = p ;
 xferrecv_buffer = buf ;
 xferrecv_buffersize = size ;
 xferrecv_sendRAMFETCH() ;
 xferrecv_state = xferrecv_state_Ask ;
 xferrecv__fileissafe = FALSE ;

 do
 {
  event_process() ;
 } while (xferrecv_state < xferrecv_state_Done) ;

 win_remove_unknown_event_processor(xferrecv_unknown_events, 0) ;

 return (xferrecv_state == xferrecv_state_Done ? xferrecv_buffersize : -1 ) ;
}

BOOL xferrecv_file_is_safe(void)
{
 return xferrecv__fileissafe ;
}

int xferrecv_last_ref(void)
{
 return scrap_ref ;
}

/* end */
@


4.5
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@d294 2
a295 1
   given becomes full. Returns TRUE if the transaction completed sucessfully.
d323 5
@


4.4
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d37 1
a55 2
#define OS_ReadVarVal 0x23

d181 2
d184 1
a184 2
 int size = xferrecv_ack.data.ramfetch.nbytes ;
 int action = xferrecv_ack.hdr.action ;
d189 1
d200 2
a202 1
 xferrecv_ack.data.ramfetch.nbytes=size ;
d204 1
d317 1
a317 1
BOOL xferrecv_file_is_safe()
@


4.3
log
@ROM build fixed for 64-bit stuff.
PCI added to swis.h
alloc.c updated to handle bigger slots (new code merged from ARM libraries)
Various 32-bit fixes for backtracing, and general trap handling.
Polite "Application is not 32-bit compatible" message.
Headers <stdint.h> and <inttypes.h> fixed to work in non-C99 mode.
txt changed to do new-style Delete behaviour

Version 5.44. Tagged as 'RISC_OSLib-5_44'
@
text
@d53 1
a53 1
#include "h.verintern.messages"
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d69 1
a69 1
static wimp_msgstr xferrecv_ack = {};
@


4.1
log
@Initial revision
@
text
@d15 15
a29 1
/* Title: -> c.xferrecv
d31 2
a32 3
 * History: IDJ: 20-Jun-91: end ram transfer on 0 bytes written as well as if not a buffer full
 * Requires:
 *  BOOL
d270 1
a270 1
    xferrecv_ack.data.datasaveok.estsize = -1 ; /* file is not safe with us */ 
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 1
a15 15
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.xferrecv
d17 3
a19 2
 * History: IDJ: 07-Feb-92: prepared for source release
 *
d257 1
a257 1
    xferrecv_ack.data.datasaveok.estsize = -1 ; /* file is not safe with us */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.4;
access;
symbols
	RISC_OSLib-5_97:4.4
	RISC_OSLib-5_96:4.4
	RISC_OSLib-5_95:4.4
	RISC_OSLib-5_94:4.4
	RISC_OSLib-5_93:4.4
	RISC_OSLib-5_92:4.4
	RISC_OSLib-5_91:4.4
	RISC_OSLib-5_90:4.4
	RISC_OSLib-5_89:4.4
	RISC_OSLib-5_88:4.4
	RISC_OSLib-5_87:4.4
	RISC_OSLib-5_86-1:4.4
	RISC_OSLib-5_86:4.4
	RISC_OSLib-5_85:4.4
	RISC_OSLib-5_84:4.4
	RISC_OSLib-5_83-2:4.4
	RISC_OSLib-5_83-1:4.4
	RISC_OSLib-5_83:4.4
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.3
	RISC_OSLib-5_77:4.3
	RISC_OSLib-5_76:4.3
	RISC_OSLib-5_75:4.3
	RISC_OSLib-5_74:4.3
	RISC_OSLib-5_73:4.3
	RISC_OSLib-5_72:4.3
	RISC_OSLib-5_71:4.3
	RISC_OSLib-5_70:4.3
	RISC_OSLib-5_69:4.3
	RISC_OSLib-5_68:4.3
	RISC_OSLib-5_67:4.3
	RISC_OSLib-5_66:4.3
	RISC_OSLib-5_65:4.3
	RISC_OSLib-5_64:4.3
	RISC_OSLib-5_63:4.3
	RISC_OSLib-5_62:4.3
	RISC_OSLib-5_61:4.3
	RISC_OSLib-5_60:4.3
	RISC_OSLib-5_59:4.3
	RISC_OSLib-5_58:4.3
	RISC_OSLib-5_57:4.3
	RISC_OSLib-5_56:4.3
	RISC_OSLib-5_55:4.3
	RISC_OSLib-5_54:4.3
	RISC_OSLib-5_53:4.2
	RISC_OSLib-5_52:4.2
	RISC_OSLib-5_51:4.2
	RO_5_07:4.2
	RISC_OSLib-5_50:4.2
	RISC_OSLib-5_49:4.2
	RISC_OSLib-5_46-4_64_2_1:4.2
	NoInlineAsm:4.2.0.2
	RISC_OSLib-5_48:4.2
	RISC_OSLib-5_47:4.2
	RISC_OSLib-5_46:4.2
	RISC_OSLib-5_45:4.2
	RISC_OSLib-5_44:4.2
	RISC_OSLib-5_43:4.2
	RISC_OSLib-5_42:4.2
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2014.08.23.21.27.31;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	oe7YyRjInqWq1xNx;

4.3
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.58;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.18;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.18;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.28;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.31.50;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.50.10;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.16;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Minor rlib cleanups
dbox.c: address of cancelled by dereference
event.c: spelling
txtar.c: don't grab the caret when clicking toggle size
txtedit.c: use BOOL for a boolean
win.c: when looking at the behind window handle we want -1 not 'DUD' (which happens to be -1)
wimp.h: add comment about window handle -3
Retagged as RISC_OSLib-5_83.

Version 5.83. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.win
 * Purpose: central control of window sytem events.
 * History: IDJ: 07-Feb-92: prepared for source release
 *
 */

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include "trace.h"
#include "os.h"
#include "wimp.h"
#include "werr.h"
#include "wimpt.h"
#include "event.h"
#include "msgs.h"
#include "VerIntern/messages.h"

#include "win.h"

/* -------- Keeping Track of All Windows. -------- */

/* At the moment, a simple linear array of all windows. */

typedef struct {
  wimp_w w;
  win_event_handler proc;
  void *handle;
  void *menuh;
} win__str;

#define MAXWINDOWS (32)
#define DUD (-1)

static win__str *win__allwindows; /*[MAXWINDOWS]*/
static int win__lim = 0; /* first unused index of win__allwindows */

static void win__register(wimp_w w, win_event_handler proc, void *handle)
{
  int i;
  for (i=0;; i++) {
    if (i == win__lim)
    {
       win__lim++;
       if (win__lim % MAXWINDOWS == 0)
       {  win__str *tmp_windows;
          if ((tmp_windows = realloc(win__allwindows, (win__lim+MAXWINDOWS)*sizeof(win__str))) == 0)
          {
             werr(0, msgs_lookup(MSGS_win1));
             /* return here to avoid trampling past end of win__allwindows */
             win__lim--;
             return;
          }
          win__allwindows = tmp_windows;
       }
       break;
    }

    if (win__allwindows[i].w == w) {break;}; /* found prev definition */
    if (win__allwindows[i].w == DUD) {break;}; /* found hole */
  }
  win__allwindows[i].w = w;
  win__allwindows[i].proc = proc;
  win__allwindows[i].handle = handle;
  win__allwindows[i].menuh = 0;
}

static void win__discard(wimp_w w)
{
  int i;
  for (i=0; i<win__lim; i++) {
    if (win__allwindows[i].w == w) {
      win__allwindows[i].w = DUD;
      break;
    };
  }
  while (win__lim > 0 && win__allwindows[win__lim-1].w == DUD) {
    /* decrease the limit if you can. */
    win__lim--;
  };
}

static win__str *win__find(wimp_w w)
{
  int i;
  for (i=0; i<win__lim; i++) {
    if (win__allwindows[i].w == w) {
      return(&win__allwindows[i]);
    };
  };
  return(0);
}

/* -------- Claiming Events. -------- */

void win_register_event_handler(
  wimp_w w, win_event_handler proc, void *handle)
{
  if (proc == 0) {
    win__discard(w);
  } else {
    win__register(w, proc, handle);
  }
}

typedef struct unknown_previewer
{
 struct unknown_previewer *link ;
 win_unknown_event_processor proc ;
 void *handle ;
} unknown_previewer ;

static wimp_w win__idle = DUD;
#define win__unknown_flag (('U'<<24)+('N'<<16)+('K'<<8)+'N')

static wimp_w win__unknown = DUD;
static unknown_previewer *win__unknown_previewer_list = 0 ;

void win_claim_idle_events(wimp_w w)
{
  tracef1("idle events -> %d\n",w) ;
  win__idle = w;
}

wimp_w win_idle_event_claimer(void)
{
  return(win__idle);
}

void win_claim_unknown_events(wimp_w w)
{
  win__unknown = w;
}

wimp_w win_unknown_event_claimer(void)
{
  return win__unknown;
}

void win_add_unknown_event_processor(win_unknown_event_processor p, void *h)
{
 unknown_previewer *block, *b;

 /* first check to see if fn already there */
 b = win__unknown_previewer_list ;
 while (b != 0)
 {
    if (b->proc == p && b->handle == h) return;
    b = b->link;
 }

 block = malloc(sizeof(unknown_previewer));
 if (block != 0)
 {
  block->link = win__unknown_previewer_list ;
  block->proc = p ;
  block->handle = h ;
  win__unknown_previewer_list = block ;
 }
}

void win_remove_unknown_event_processor(win_unknown_event_processor p,
                                        void *h)
{
   unknown_previewer *b, **pb;

   pb = &win__unknown_previewer_list ;

   while ((b = *pb) != 0)
   {
      if (b->proc == p && b->handle == h)
      {
         *pb = b->link;
         free(b);
         return;
      }
      pb = &(b->link);
   }
}

/* -------- Menus. -------- */

void win_setmenuh(wimp_w w, void *handle)
{
  win__str *p = win__find(w);
  if (p != 0) {p->menuh = handle;}
}

void *win_getmenuh(wimp_w w) /* 0 if not set */
{
  win__str *p = win__find(w);
  return(p==0 ? 0 : p->menuh);
}

/* -------- Processing Events. -------- */

BOOL win_processevent(wimp_eventstr *e)
{
  wimp_w w;
  win__str *p;

  switch (e->e) {

    case wimp_ENULL:
      w = win__idle;
      break;

    case wimp_EUSERDRAG:
      w = win__unknown_flag ;
      break;

    case wimp_EREDRAW: case wimp_ECLOSE: case wimp_EOPEN:
    case wimp_EPTRLEAVE: case wimp_EPTRENTER: case wimp_EKEY:
    case wimp_ESCROLL:
      w = e->data.o.w;
      break;

    case wimp_EBUT:
      w = e->data.but.m.w;
      if (w <= (wimp_w) -1) w = win_ICONBAR;
      break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
    /* Some standard messages we understand, and give to the right guy. */
      switch (e->data.msg.hdr.action) {
        case wimp_MCLOSEDOWN:
          tracef0("closedown message: for the moment, just do it.\n");
          exit(0);

        case wimp_MDATALOAD:
        case wimp_MDATASAVE:
          tracef1("data %s message arriving.\n",
             (int) (e->data.msg.hdr.action==wimp_MDATASAVE ? "save" : "load"));

          /* Note that we're assuming the window handle's the same position in
             both messages */
          if (e->data.msg.data.dataload.w < 0)
          {
            tracef0("data message to the icon bar.\n");
            w = win_ICONBARLOAD ;
          } else {
            w = e->data.msg.data.dataload.w;
          }
          break;

        case wimp_MHELPREQUEST:
          tracef1("help request for window %i.\n", e->data.msg.data.helprequest.m.w);
          w = e->data.msg.data.helprequest.m.w;
          if (w < 0) w = win_ICONBARLOAD;
          break;

        default:
            tracef1("unknown message type %i arriving.\n", e->data.msg.hdr.action);
            w = win__unknown_flag;
            if (w < 0) w = win_ICONBARLOAD;
      }
      break;

    default:
      w = win__unknown_flag;
  }

  if (w==win__unknown_flag || win__find(w) == 0)
  {
   unknown_previewer *pr ;
   for (pr = win__unknown_previewer_list; pr != 0; pr = pr->link)
   {
    if (pr->proc(e, pr->handle)) return TRUE ;
   }

   w = win__unknown ;
  }

  p = (w == DUD ? 0 : win__find(w));
  if (p != 0) {
    p->proc(e, p->handle);
    return TRUE;
  } else {
    return FALSE;
  }
}

/* -------- Termination. -------- */

static int win__active = 0;

void win_activeinc(void)
{
  win__active++;
}

void win_activedec(void)
{
  win__active--;
}

int win_activeno(void)
{
  return win__active;
}

/* -------- Giving away the caret. -------- */

void win_give_away_caret(void)
/* Whatever window is on top, just "open" it at its current position.
This should make it grab the caret, if it is interested. It doesn't really
matter if this routine has no effect, it just means that the user has to
click somewhere. */
{
  int i;
  for (i=0; i<win__lim; i++) {
    if (win__allwindows[i].w != DUD) {/* found a window */
      wimp_wstate s;
      wimp_eventstr e;
      tracef1("get state of window %i.", win__allwindows[i].w);
      (void) wimp_get_wind_state(win__allwindows[i].w, &s);
      tracef2("behind=%i flags=%i.\n", s.o.behind, s.flags);
      if (s.o.behind == -1 && (s.flags & wimp_WOPEN) != 0) {
        /* w is the top window */
        /* if it wants the caret, it will grab it. */
        tracef0("Opening it.\n");
        e.e = wimp_EOPEN;
        e.data.o = s.o;
        wimpt_fake_event(&e);
        break;
      }
    }
  }
}

/* ----------- reading event handler for window ----------- */
/* useful for intercepting events to txt windows */

BOOL win_read_eventhandler(wimp_w w, win_event_handler *p, void **handle)
{
  int i;
  for (i=0; i<win__lim; i++) {
    if (win__allwindows[i].w == w) {
      *p = win__allwindows[i].proc;
      *handle = win__allwindows[i].handle;
      return(TRUE);
    }
  }
  return(FALSE);
}

/* ----------- setting a window title ------------ */

void win_settitle(wimp_w w, char *newtitle)
{
  wimp_redrawstr r;
  wimp_winfo *winfo;

  if((winfo = malloc(sizeof(wimp_wind) + 200*sizeof(wimp_icon))) == 0)
    werr(TRUE, msgs_lookup(MSGS_win2));

  /* --- get the window's details --- */
    winfo->w = w;
    wimpt_noerr(wimp_get_wind_info(winfo));

  /* --- put the new title string in the title icon's buffer --- */
    strcpy(winfo->info.title.indirecttext.buffer, newtitle);

  /* --- invalidate the title bar in absolute coords --- */
    r.w = (wimp_w) -1;    /* absolute screen coords */
    r.box = winfo->info.box;
    r.box.y1 += 36;            /* tweak */
    r.box.y0 = r.box.y1 - 36;
    wimpt_noerr(wimp_force_redraw(&r));

  /* --- free space used to window info --- */
    free(winfo);
}

BOOL win_init(void)
{
    if (win__allwindows == 0)
    {
        return((win__allwindows = malloc(MAXWINDOWS*sizeof(win__str)))!=0);
    }
    else
        return TRUE;
}

/* end */
@


4.3
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d352 1
a352 1
      if (s.o.behind == DUD && (s.flags & wimp_WOPEN) != 0) {
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d43 8
a50 8
#include "h.trace"
#include "h.os"
#include "h.wimp"
#include "h.werr"
#include "h.wimpt"
#include "h.event"
#include "h.msgs"
#include "h.verintern.messages"
d52 1
a52 1
#include "h.win"
@


4.1
log
@Initial revision
@
text
@d15 15
a29 1
/* Title: -> c.win
d31 2
a32 18
 * Author: WRS
 * Status: under development
 * History:
 *   24 August 87 -- started
 *   02-Mar-88: WRS: use of BOOL
 *   02-Mar-88: WRS: drag events put in.
 *   05-Mar-88: WRS: data transfer messages routed.
 *   10-Mar-88: WRS: fix for icon bar events.
 *   15-Jun-88: APT: added knowledge of data transfer messages
 *   29-July-88: WRS: stuff about help request messages put in.
 *   29-Mar-89: IDJ: added test to win_process to pass hot-key events on to
 *                   unknown event handlers. (To help WRS in !Edit)
 *    1-Jun-89: IDJ: made win_claim_idle_events set the event mask
 *    6-Jun-89: IDJ: last minute hack -- added win_settitle
 *   15-Jun-89: IDJ: removed eventmask call from win_claim_idle_events()
 *   08-May-91: ECN: #ifndefed out unused ROM functions
 *   17-Jun-91: IDJ: remove static limit on num windows by reallocing
 *   28-Oct-94: AMcC Include win_event_handler in ROM lib (for Paint)
d75 1
a75 6
#if FALSE
    if (i == MAXWINDOWS) {
      werr(1, msgs_lookup(MSGS_win1));
    };
#endif
    if (i == win__lim) 
d77 2
a78 2
       win__lim++; 
       if (win__lim % MAXWINDOWS == 0) 
d136 1
a136 1
  };
d155 1
a155 4
  win__idle = w; 
#if FALSE
  event_setmask(event_getmask() & ~wimp_EMNULL);
#endif
d173 1
a173 2
void win_add_unknown_event_processor(win_unknown_event_processor p,
                                     void *h)
d177 1
a177 1
 /* IDJ:fix -- first check to see if fn already there */
d199 1
a199 1
                              
d219 1
a219 1
  if (p != 0) {p->menuh = handle;};
d234 1
a234 1
/*  tracef1("win_processevent %i.\n", e->e);  */
d236 22
a257 17
  case wimp_ENULL:
    w = win__idle;
    break;
  case wimp_EUSERDRAG:
    w = win__unknown_flag ;
    break;
  case wimp_EREDRAW: case wimp_ECLOSE: case wimp_EOPEN:
  case wimp_EPTRLEAVE: case wimp_EPTRENTER: case wimp_EKEY:
  case wimp_ESCROLL:
    w = e->data.o.w;
    break;
  case wimp_EBUT:
    w = e->data.but.m.w;
    if (w <= (wimp_w) -1) w = win_ICONBAR;
    break;
  case wimp_ESEND:
  case wimp_ESENDWANTACK:
d259 8
a266 7
    switch (e->data.msg.hdr.action) {
    case wimp_MCLOSEDOWN:
      tracef0("closedown message: for the moment, just do it.\n");
      exit(0);
    case wimp_MDATALOAD:
    case wimp_MDATASAVE:
      tracef1("data %s message arriving.\n",
d269 22
a290 14
      /* Note that we're assuming the window handle's the same position in
         both messages */
      if (e->data.msg.data.dataload.w < 0)
      {
        tracef0("data message to the icon bar.\n");
        w = win_ICONBARLOAD ;
      } else {
        w = e->data.msg.data.dataload.w;
      };
      break;
    case wimp_MHELPREQUEST:
      tracef1("help request for window %i.\n", e->data.msg.data.helprequest.m.w);
      w = e->data.msg.data.helprequest.m.w;
      if (w < 0) w = win_ICONBARLOAD;
d292 1
a293 1
      tracef1("unknown message type %i arriving.\n", e->data.msg.hdr.action);
d295 1
a295 6
      if (w < 0) w = win_ICONBARLOAD;
    };
    break;
  default:
    w = win__unknown_flag;
  };
a301 4
/*
    tracef2("Unknown event to previewer %x %x\n",
            (int)pr->proc,(int)pr->handle) ;
*/
d304 1
a304 3
/*
   tracef0("No previewer interested\n") ;
*/
d314 1
a314 1
  };
d346 1
a346 1
    if (win__allwindows[i].w != DUD) { /* found a window */
a355 5
        /* If we just wimp_open_wind, the wimp notices that nothing
        changes and so it ignores our call. So, fake it. This smells
        of bodge... But, this whole area of the wimp seems a bit wrong
        anyway. */
        /* (void) wimp_open_wind(&s.o); */
d360 3
a362 3
      };
    };
  };
d366 1
a366 1
/* IDJ 6-Feb-90 - useful for intercepting events to txt windows */
d376 2
a377 2
    };
  };
a390 1
tracef1("New title is %s\n", (int)newtitle);
a395 1
tracef1("Lib buffer is at %d\n", (int)winfo->info.title.indirecttext.buffer);
d401 1
a401 1
    r.box.y1 += 36;            /* yuk - tweaky */
d411 1
a411 1
    if (win__allwindows == 0) 
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 1
a15 15
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/* Title: c.win
d17 18
a34 2
 * History: IDJ: 07-Feb-92: prepared for source release
 *
d77 6
a82 1
    if (i == win__lim)
d84 2
a85 2
       win__lim++;
       if (win__lim % MAXWINDOWS == 0)
d143 1
a143 1
  }
d162 4
a165 1
  win__idle = w;
d183 2
a184 1
void win_add_unknown_event_processor(win_unknown_event_processor p, void *h)
d188 1
a188 1
 /* first check to see if fn already there */
d210 1
a210 1

d230 1
a230 1
  if (p != 0) {p->menuh = handle;}
d245 1
a245 1

d247 17
a263 22

    case wimp_ENULL:
      w = win__idle;
      break;

    case wimp_EUSERDRAG:
      w = win__unknown_flag ;
      break;

    case wimp_EREDRAW: case wimp_ECLOSE: case wimp_EOPEN:
    case wimp_EPTRLEAVE: case wimp_EPTRENTER: case wimp_EKEY:
    case wimp_ESCROLL:
      w = e->data.o.w;
      break;

    case wimp_EBUT:
      w = e->data.but.m.w;
      if (w <= (wimp_w) -1) w = win_ICONBAR;
      break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
d265 7
a271 8
      switch (e->data.msg.hdr.action) {
        case wimp_MCLOSEDOWN:
          tracef0("closedown message: for the moment, just do it.\n");
          exit(0);

        case wimp_MDATALOAD:
        case wimp_MDATASAVE:
          tracef1("data %s message arriving.\n",
d274 14
a287 22
          /* Note that we're assuming the window handle's the same position in
             both messages */
          if (e->data.msg.data.dataload.w < 0)
          {
            tracef0("data message to the icon bar.\n");
            w = win_ICONBARLOAD ;
          } else {
            w = e->data.msg.data.dataload.w;
          }
          break;

        case wimp_MHELPREQUEST:
          tracef1("help request for window %i.\n", e->data.msg.data.helprequest.m.w);
          w = e->data.msg.data.helprequest.m.w;
          if (w < 0) w = win_ICONBARLOAD;
          break;

        default:
            tracef1("unknown message type %i arriving.\n", e->data.msg.hdr.action);
            w = win__unknown_flag;
            if (w < 0) w = win_ICONBARLOAD;
      }
a288 1

d290 1
d292 6
a297 1
  }
d304 4
d310 3
a312 1

d322 1
a322 1
  }
d354 1
a354 1
    if (win__allwindows[i].w != DUD) {/* found a window */
d364 5
d373 3
a375 3
      }
    }
  }
d379 1
a379 1
/* useful for intercepting events to txt windows */
d389 2
a390 2
    }
  }
d404 1
d410 1
d416 1
a416 1
    r.box.y1 += 36;            /* tweak */
d426 1
a426 1
    if (win__allwindows == 0)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

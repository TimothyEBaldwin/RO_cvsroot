head	4.5;
access;
symbols
	RISC_OSLib-5_97:4.5
	RISC_OSLib-5_96:4.5
	RISC_OSLib-5_95:4.5
	RISC_OSLib-5_94:4.5
	RISC_OSLib-5_93:4.5
	RISC_OSLib-5_92:4.5
	RISC_OSLib-5_91:4.5
	RISC_OSLib-5_90:4.5
	RISC_OSLib-5_89:4.5
	RISC_OSLib-5_88:4.5
	RISC_OSLib-5_87:4.5
	RISC_OSLib-5_86-1:4.5
	RISC_OSLib-5_86:4.5
	RISC_OSLib-5_85:4.5
	RISC_OSLib-5_84:4.5
	RISC_OSLib-5_83-2:4.5
	RISC_OSLib-5_83-1:4.5
	RISC_OSLib-5_83:4.5
	RISC_OSLib-5_82:4.4
	RISC_OSLib-5_81:4.4
	RISC_OSLib-5_75-2:4.4
	RISC_OSLib-5_80:4.4
	RISC_OSLib-5_79:4.4
	RISC_OSLib-5_78:4.4
	RISC_OSLib-5_75-1:4.4
	RISC_OSLib-5_77:4.4
	RISC_OSLib-5_76:4.4
	RISC_OSLib-5_75:4.4
	RISC_OSLib-5_74:4.4
	RISC_OSLib-5_73:4.4
	RISC_OSLib-5_72:4.4
	RISC_OSLib-5_71:4.4
	RISC_OSLib-5_70:4.4
	RISC_OSLib-5_69:4.4
	RISC_OSLib-5_68:4.4
	RISC_OSLib-5_67:4.4
	RISC_OSLib-5_66:4.4
	RISC_OSLib-5_65:4.4
	RISC_OSLib-5_64:4.4
	RISC_OSLib-5_63:4.4
	RISC_OSLib-5_62:4.4
	RISC_OSLib-5_61:4.4
	RISC_OSLib-5_60:4.4
	RISC_OSLib-5_59:4.4
	RISC_OSLib-5_58:4.4
	RISC_OSLib-5_57:4.4
	RISC_OSLib-5_56:4.4
	RISC_OSLib-5_55:4.4
	RISC_OSLib-5_54:4.4
	RISC_OSLib-5_53:4.3
	RISC_OSLib-5_52:4.3
	RISC_OSLib-5_51:4.3
	RO_5_07:4.3
	RISC_OSLib-5_50:4.3
	RISC_OSLib-5_49:4.3
	RISC_OSLib-5_46-4_64_2_1:4.3
	NoInlineAsm:4.3.0.2
	RISC_OSLib-5_48:4.3
	RISC_OSLib-5_47:4.3
	RISC_OSLib-5_46:4.3
	RISC_OSLib-5_45:4.3
	RISC_OSLib-5_44:4.3
	RISC_OSLib-5_43:4.3
	RISC_OSLib-5_42:4.3
	RISC_OSLib-5_41:4.2
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.1.14.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2014.07.31.08.24.08;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	jfGiiZxupMtuqvKx;

4.4
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.3;

4.3
date	2002.07.23.11.52.22;	author srevill;	state Exp;
branches;
next	4.2;

4.2
date	2001.08.23.13.53.50;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.11;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.14.1;
next	;

4.1.1.1
date	96.11.05.09.25.11;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.53.46;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.30.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.49.30;	author nturton;	state Exp;
branches;
next	;

4.1.14.1
date	2001.07.02.15.01.14;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Some RISC_OSLib rlib enhancements
menu.c/menu.h:
Add a new menu_setcolours() function to allow the fore/background colour bits to be set on a menu entry.
colourmenu.c:
Use the new menu_setcolours() function instead of making assumptions about menu's internal structure layout.
dbox.c/dbox.h:
New functions dbox_hidefield and dbox_unhidefield added to complement the fade/unfade ones.
As dbox_findicon/findiconbefore are only ever used to find writables, rename them as such. Also, make them find writable (type 15) AND writable draggable (type 14) icons.
Allow navigation by tab/shift tab through icons like the Style Guide chapter 16 says we should. In fact it's a little odd that dbox is emulating 'Ktar' validation itself manually when the Wimp has done this since version 2.92, but maintaining it is less effort than going and checking all the templates.
Fix bug when looking for leading capital letter matches to complete a dbox, the previous code was looking at the cached copy of the icon flags in d->window rather than the ones the Wimp is actually showing on screen (as might have been modified by dbox_fadefield() for example), so it was possible to complete a dbox for an icon which wasn't visible or selectable.
Fix bug when looking for leading capital letter matches when the icon doesn't have any text - the template file format is defined as being 0x0D terminated. This would then lead to 'R' and 'S' being accepted as matches having run off the end of the text buffer and into the validation string (which usually contains an 'R' or 'S' validation first). Changed to accept any control terminator.
event.c:
When force closing the current menu, don't forget to set the two state variables back to 0.
fileicon.c/resspr.c/txt1.c/txtundo.c/wimp.c:
Use existing pointer type definitions.
flex.c:
Treat bools as bools and pointers as pointers.
Say something useful in an error box if flex fails its internal consistency check, rather than just data aborting.
font.c:
Remove ROM conditionals from around font_readdef() function, always include the function.
fontselect.c:
Use font_readdef() rather than local copies of the exact same function.
txtedit.c/txtfile.c/txtfind.c/txtedit.h:
Remove redundant 'deletepending' state variable, and confusion over 'selectrecent' being a bool.
Call os_byte directly rather than passing to os_cli("*FX").
Other minor tidy ups.
wimpt.c:
Mark messages list as a constant.
xferrecv.c:
Also preserve the size member while recycling the xferrecv_ack message block, rather than corrupting it as 256.
xfersend.c/xfersend.h:
Take out the leaf name formulator as a common function for the two places to use it. This also allows the function to return the length of the leaf name so the correct message block size can be used. Inspection with MsgMon/!Reporter was showing that all xfersend initiated saves were passing the leaf name padded to 256 with garbage.
Reindent a few functions.
Make the draggable sprite replacement follow the same validation string rules as the Wimp, previously only ";s" was accepted, so upper case 'S' and validation strings that start with the sprite validation didn't work.
xfersend_pipe() function prototype changed to match xfersend() more closely - not being able to respond to the context of a wimp_eventstr made this function practically unusable.
akbd.h:
Windows logo and menu keys defined.
flex.h/help.h/wimpt.h
Some typos in comments.
wimp.h:
Missing wimp message action codes and structure defs added for completeness.


Version 5.83. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/

/*
 * Title  : c.font
 * Purpose: access to RISC OS font facilities
 * History: IDJ: 06-Feb-92: prepared for source release
 */
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include "os.h"
#include "trace.h"
#include "msgs.h"
#include "wimp.h"
#include "font.h"
#include "VerIntern/messages.h"

/*                          F O N T    S W I 's                          */
#define CacheAddr            0x40080
#define FindFont             0x40081
#define LoseFont             0x40082
#define ReadDefn             0x40083
#define ReadInfo             0x40084
#define StringWidth          0x40085
#define Paint                0x40086
#define Caret                0x40087
#define ConverttoOS          0x40088
#define Converttopoints      0x40089
#define SetFont              0x4008A
#define CurrentFont          0x4008B
#define FutureFont           0x4008C
#define FindCaret            0x4008D
#define CharBBox             0x4008E
#define ReadScaleFactor      0x4008F
#define SetScaleFactor       0x40090
#define ListFonts            0x40091
#define SetFontColours       0x40092
#define SetPalette           0x40093
#define ReadThresholds       0x40094
#define SetThresholds        0x40095
#define FindCaretJ           0x40096
#define StringBBox           0x40097
#define ReadColourTable      0x40098
#define MakeBitmap           0x40099
#define UnCacheFile          0x4009A
#define SetFontMax           0x4009B
#define ReadFontMax          0x4009C
#define ReadFontPrefix       0x4009D
#define SwitchOutputToBuffer 0x4009E
#define ReadFontMetrics      0x4009F
#define DecodeMenu           0x400A0
#define ScanString           0x400A1
#define SetColourTable       0x400A2

#pragma -s1

#ifndef UROM
os_error *font_cacheaddress(int *version, int *cacheused,
                            int *cachesize)

{
    os_regset r;
    os_error *e;

    r.r[0] = 0;
    e = os_swix(CacheAddr, &r);

    if (!e)
    {
      *version = r.r[0];
      *cacheused = r.r[1];
      *cachesize = r.r[2];
    }

    return e;
}
#endif

os_error *font_find(char *name, int xsize, int ysize, int xres,
                    int yres, font *fontadd)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)name;
    r.r[2] = xsize;
    r.r[3] = ysize;
    r.r[4] = xres;
    r.r[5] = yres;

    e = os_swix(FindFont, &r);

    *fontadd = (font) r.r[0];

    return e;
}


os_error *font_lose(font f)
{
    os_regset r;
    os_error *e;

    r.r[0] = f;
    e = os_swix(LoseFont, &r);
    return e;
}


os_error * font_readdef(font f, font_def *d)

{
    os_regset r;
    os_error *e;

    r.r[0] = (int)f;
    r.r[1] = (int)&d->name;

    e = os_swix(ReadDefn, &r);

    d->xsize = r.r[2];
    d->ysize = r.r[3];
    d->xres = r.r[4];
    d->yres = r.r[5];
    d->usage = r.r[6];
    d->age = r.r[7];

    return(e);
}


os_error *font_readinfo(font f, font_info *i)
{
    os_regset r;
    os_error *e;

    r.r[0] = f;

    e = os_swix(ReadInfo, &r);

    i->minx = r.r[1];
    i->miny = r.r[2];
    i->maxx = r.r[3];
    i->maxy = r.r[4];

    return e;
}


os_error *font_strwidth(font_string *fs)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)fs->s;
    r.r[2] = fs->x;
    r.r[3] = fs->y;
    r.r[4] = fs->split;
    r.r[5] = fs->term;

    e = os_swix(StringWidth, &r);

    fs->x = r.r[2];
    fs->y = r.r[3];
    fs->split = r.r[4];
    fs->term = r.r[5];

    return e;
}


os_error *font_paint(char *s, int options, int x, int y)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)s;
    r.r[2] = options;
    r.r[3] = x;
    r.r[4] = y;

    e = os_swix(Paint, &r);

    return e;
}


#ifndef UROM
os_error *font_caret(int colour, int height, int flags, int x, int y)
{
    os_regset r;
    os_error *e;

    r.r[0] = colour;
    r.r[1] = height;
    r.r[2] = flags;
    r.r[3] = x;
    r.r[4] = y;

    e = os_swix(Caret, &r);

    return e;
}
#endif


os_error *font_converttoos(int x_inch, int y_inch, int *x_os,
                           int *y_os)
{
    os_regset r;
    os_error *e;

    r.r[1] = x_inch;
    r.r[2] = y_inch;

    e = os_swix(ConverttoOS, &r);

    *x_os = r.r[1];
    *y_os = r.r[2];

    return e;
}

#ifndef UROM
os_error *font_converttopoints(int x_os, int y_os, int *x_inch,
                               int *y_inch)
{
    os_regset r;
    os_error *e;

    r.r[1] = x_os;
    r.r[2] = y_os;

    e = os_swix(Converttopoints, &r);

    *x_inch = r.r[1];
    *y_inch = r.r[2];

    return e;
}
#endif

os_error *font_setfont(font f)
{
    os_regset r;
    os_error *e;

    r.r[0] = f;

    e = os_swix(SetFont, &r);

    return(e);
}

#ifndef UROM
os_error *font_current(font_state *f)
{
    os_regset r;
    os_error *e;

    e = os_swix(CurrentFont, &r);

    f->f = r.r[0];
    f->back_colour = r.r[1];
    f->fore_colour = r.r[2];
    f->offset = r.r[3];

    return(e);
}
#endif

#ifndef UROM
os_error *font_future(font_state *f)
{
    os_regset r;
    os_error *e;

    e = os_swix(FutureFont, &r);

    f->f = r.r[0];
    f->back_colour = r.r[1];
    f->fore_colour = r.r[2];
    f->offset = r.r[3];

    return(e);
}
#endif


os_error *font_findcaret(font_string *fs)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)fs->s;
    r.r[2] = fs->x;
    r.r[3] = fs->y;

    e = os_swix(FindCaret, &r);

    fs->x = r.r[2];
    fs->y = r.r[3];
    fs->split = r.r[4];
    fs->term = r.r[5];

    return e;
}


os_error *font_charbbox(font f, char ch, int options, font_info *i)
{
    os_regset r;
    os_error *e;

    r.r[0] = f;
    r.r[1] = ch;
    r.r[2] = options;

    e = os_swix(CharBBox, &r);

    i->minx = r.r[1];
    i->miny = r.r[2];
    i->maxx = r.r[3];
    i->maxy = r.r[4];

    return e;
}

#ifndef UROM
os_error *font_readscalefactor(int *x, int *y)
{
    os_regset r;
    os_error *e;

    e = os_swix(ReadScaleFactor, &r);

    *x = r.r[1];
    *y = r.r[2];

    return e;
}
#endif

#ifndef UROM
os_error *font_setscalefactor(int x, int y)
{
    os_regset r;
    os_error *e;

    r.r[1] = x;
    r.r[2] = y;

    e = os_swix(SetScaleFactor, &r);

    return e;
}
#endif

#ifndef UROM
os_error *font_list(char *a, int *count)
{
    os_regset r;
    os_error *e;
    int i;

    r.r[1] = (int)a;
    r.r[2] = *count;
    r.r[3] = -1;

    e = os_swix(ListFonts, &r);

    if (!e)

      {

      *count = r.r[2];
      i = 0;

      while (a[i] >= 32 && i <= 99)

           ++i;

      a[i] = 0;

      }

    else /* error return: probably some filing system error */

      *count = -1; /* signal end of list */

    return e;
}
#endif


os_error *font_setcolour(font f, int background, int foreground,
                         int offset)
{
    os_regset r;
    os_error *e;

    r.r[0] = f;
    r.r[1] = background;
    r.r[2] = foreground;
    r.r[3] = offset;

    e = os_swix(SetFontColours, &r);

    return e;
}

#ifndef UROM
os_error *font_setpalette(int background, int foreground, int offset,
                          int physical_back, int physical_fore)

{
    os_regset r;
    os_error *e;

    r.r[1] = background;
    r.r[2] = foreground;
    r.r[3] = offset;
    r.r[4] = physical_back;
    r.r[5] = physical_fore;

    e = os_swix(SetPalette, &r);

    return e;
}
#endif

#ifndef UROM
os_error *font_readthresholds(font_threshold *th)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)th;

    e = os_swix(ReadThresholds, &r);

    return e;
}
#endif

#ifndef UROM
os_error *font_setthresholds(font_threshold *th)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)th;

    e = os_swix(SetThresholds, &r);

    return e;
}
#endif

#ifndef UROM
os_error *font_findcaretj(font_string *fs, int offset_x, int offset_y)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)fs->s;
    r.r[2] = fs->x;
    r.r[3] = fs->y;
    r.r[4] = offset_x;
    r.r[5] = offset_y;

    e = os_swix(FindCaretJ, &r);

    fs->x = r.r[2];
    fs->y = r.r[3];
    fs->split = r.r[4];
    fs->term = r.r[5];

    return e;
}
#endif

os_error *font_stringbbox(char *s, font_info *fi)
{
    os_regset r;
    os_error *e;

    r.r[1] = (int)s;

    e = os_swix(StringBBox, &r);

    fi->minx = r.r[1];
    fi->miny = r.r[2];
    fi->maxx = r.r[3];
    fi->maxy = r.r[4];

    return e;
}

/*-----------------------------------------------------------------*/
/*Routines for conversion of fonts to Draw module path objects. See
   the documentation of SWI Font_SwitchOutputToBuffer.*/

os_error
   *font_output_to_null
   (  BOOL add_hints,
      BOOL output_skeleton,
      font_action_on_bitmap action_on_bitmap
   )

/*Redirects the output from font_paint to nowhere, in preparation for
   font_output_size.*/

{  os_regset reg_set;
   os_error *error;

   tracef0 ("font_output_to_null\n");

   reg_set.r [0] =
      1 /*no output*/ +
      (add_hints? 1 << 1: 0) +
      (output_skeleton? 1 << 2: 0) +
      (  action_on_bitmap == font_ERROR?
            1 << 4:
         action_on_bitmap == font_CONVERT?
            1 << 3:
            0
      );
   reg_set.r [1] = 8;

   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL)
      return error;

   return NULL;
}
/*-----------------------------------------------------------------*/
os_error *font_output_size (size_t *size_ptr)

/*Counts the size of the buffer that would have been written if the
   output had been to a buffer.*/

{  os_regset reg_set;
   os_error *error;

   tracef0 ("font_output_size\n");

   reg_set.r [0] =  0;
   reg_set.r [1] = -1;

   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL)
      return error;

   *size_ptr = reg_set.r [1];
   tracef1 ("font_output_size: made %d bytes of path\n", *size_ptr);
   return NULL;
}
/*-----------------------------------------------------------------*/

os_error
   *font_output_to_buffer
   (  drawmod_buffer *buff_ptr,
      BOOL add_hints,
      BOOL output_skeleton,
      font_action_on_bitmap action_on_bitmap
   )

/*Redirects the output to a buffer. A series of draw paths or groups
   is written.*/

{  os_regset reg_set;
   os_error *error;

   tracef0 ("font_output_to_buffer\n");

   reg_set.r [0] =
      (add_hints? 1 << 1: 0) +
      (output_skeleton? 1 << 2: 0) +
      (  action_on_bitmap == font_ERROR?
            1 << 4:
         action_on_bitmap == font_CONVERT?
            1 << 3:
            0
      );
   reg_set.r [1] = (int) buff_ptr;

   tracef1 ("font_output_to_buffer: path going to 0x%p\n", buff_ptr);
   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL)
      return error;

   return NULL;
}

/*-----------------------------------------------------------------*/

os_error *font_output_to_screen (void)

/*Redirects the output to the screen.*/

{  os_regset reg_set;
   os_error *error;

   tracef0 ("font_output_to_screen\n");

   reg_set.r [0] = 0;
   reg_set.r [1] = 0;

   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL)
      return error;

   return NULL;
}

#pragma -s0

/*-----------------------------------------------------------------*/

static os_error errbuff={0};

os_error *font_makemenu(wimp_menustr ** menup, char * tickitem, fontmenu_flags flags)
{
   os_regset r;
   os_error *error;

   tracef3 ("font_makemenu: *menup=0x%p, tickitem=0x%p, flags=%d\n", *menup, tickitem, flags);

   switch(flags) {

     case fontmenu_WithoutSystemFont:
          r.r[2] = (1<<19) + (1<<21);
          break;

     case fontmenu_WithSystemFont:
          r.r[2] = (1<<19) + (1<<20) + (1<<21);
          break;

     case fontmenu_Delete:
          if (*menup) { free(*menup); *menup = NULL; }
          return NULL;

     default:
          errbuff.errnum = 1;
          strcpy(errbuff.errmess,msgs_lookup(MSGS_fontmenu1));
          return(&errbuff);
   }

   r.r[1] = 0;        /* return size of buffer in R3 */
   r.r[4] = 0;        /* return size of buffer in R5 */
   r.r[6] = (int) tickitem;

   if ((error = os_swix (ListFonts, &r)) != NULL) return error;

   r.r[1] = (int) realloc(*menup,r.r[3] + r.r[5]);
   if (r.r[1]) {
     *menup = (wimp_menustr *)r.r[1];
   } else {
     errbuff.errnum = 1;
     strcpy(errbuff.errmess,msgs_lookup(MSGS_fontmenu2));
     return(&errbuff);
   }
   r.r[4] = r.r[1] + r.r[3];

   error = os_swix (ListFonts, &r);

   if (r.r[3] && !error) {
      *menup = (void *)r.r[1];
   } else {
      free(*menup);
      *menup = NULL;
   }

   return(error);
}

/*-----------------------------------------------------------------*/

extern os_error *font_decodemenu(wimp_menustr * menu, int * selections, char **resultp)
{
   os_regset r;
   os_error *error;

   tracef3 ("font_decodemenu: menu=0x%p, selection[0]=%d, old buffer=0x%p\n", menu, selections[0], *resultp);

   r.r[0] = 0;
   r.r[1] = (int) menu;
   r.r[2] = (int) selections;
   r.r[3] = 0;
   if ((error = os_swix(DecodeMenu,&r)) != NULL) return error;

   r.r[0] = 0;
   r.r[1] = (int) menu;
   r.r[2] = (int) selections;
   r.r[3] = (int) realloc(*resultp, r.r[4]);

   if (r.r [4] == 0)
   {  /*No selection made.*/
      *resultp = NULL;
      return NULL;
   }

   if (r.r[3]) {
     *resultp = (char *)r.r[3];
   } else {
     errbuff.errnum = 1;
     strcpy(errbuff.errmess,msgs_lookup(MSGS_fontmenu3));
     return(&errbuff);
   }

   return(os_swix(DecodeMenu,&r));
}

@


4.4
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@a135 1
#ifndef UROM
d156 1
a156 1
#endif
@


4.3
log
@  Fixed to build with the latest cc (5.54) compiler.
Detail:
  This version now builds with cc-5_45. Note: it has not been verified as
  actually functioning correctly.
Admin:
  Tested in DSL Baseline build.

Version 5.42. Tagged as 'RISC_OSLib-5_42'
@
text
@d37 6
a42 6
#include "h.os"
#include "h.trace"
#include "h.msgs"
#include "h.wimp"
#include "h.font"
#include "h.verintern.messages"
@


4.2
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d644 1
a644 1
static os_error errbuff={};
@


4.1
log
@Initial revision
@
text
@d15 13
a27 14
/****************************************************************************
 * This source file was written by Acorn Computers Limited. It is part of   *
 * the "cwimp" library for writing applications in C for RISC OS. It may be *
 * used freely in the creation of programs for Archimedes. It should be     *
 * used with Acorn's C Compiler Release 2 or later.                         *
 *                                                                          *
 * No support can be given to programmers using this code and, while we     *
 * believe that it is correct, no correspondence can be entered into        *
 * concerning behaviour or bugs.                                            *
 *                                                                          *
 * Upgrades of this code may or may not appear, and while every effort will *
 * be made to keep such upgrades upwards compatible, no guarantees can be   *
 * given.                                                                   *
 ***************************************************************************/
d32 1
a32 5
 * Version: 0.1
 *          13-Apr-89 IDJ  fixed params in font_charbbox
 *          09-Apr-91 PJC  fixed bug in font_decodemenu
 *          08-May-91 ECN  #ifndefed out unused ROM functions
 *          13-May-91 ECN  turned stack checking off on selected functions
a33 2

#ifndef __stddef_h
a34 2
#endif
#ifndef __stdlib_h
a35 2
#endif
#ifndef __string_h
a36 1
#endif
d84 2
a85 3
os_error *font_cacheaddress(version, cacheused, cachesize)

int *version, *cacheused, *cachesize;
d88 2
a89 2
os_regset r;
os_error *e;
d95 1
a95 2

      {
d99 1
a99 3
      }

return e;
d101 1
d105 2
a106 7
os_error *font_find(name, xsize, ysize, xres, yres, fontadd)

char *name;
int xsize, ysize; /* in 16ths of a point */
int xres, yres;   /* dots per inch of res: 0->use default */
font *fontadd;

d108 2
d111 5
a115 8
os_regset r;
os_error *e;

r.r[1] = (int)name;
r.r[2] = xsize;
r.r[3] = ysize;
r.r[4] = xres;
r.r[5] = yres;
d117 1
a117 1
e = os_swix(FindFont, &r);
d119 1
a119 1
*fontadd = (font) r.r[0];
d121 1
a121 1
return e;
a123 3
os_error *font_lose(f)

font f;
d125 1
d127 2
a128 2
os_regset r;
os_error *e;
d130 3
a132 3
r.r[0] = f;
e = os_swix(LoseFont, &r);
return e;
d137 1
a137 4
os_error * font_readdef(f, d)

font f;
font_def *d;
d140 2
d143 2
a144 5
os_regset r;
os_error *e;

r.r[0] = (int)f;
r.r[1] = (int)&d->name;
d146 1
a146 1
e = os_swix(ReadDefn, &r);
d148 6
a153 8
d->xsize = r.r[2];
d->ysize = r.r[3];
d->xres = r.r[4];
d->yres = r.r[5];
d->usage = r.r[6];
d->age = r.r[7];

return(e);
d155 1
d159 1
a159 5
os_error *font_readinfo(f, i)

font f;
font_info *i;

d161 2
d164 1
a164 6
os_regset r;
os_error *e;

r.r[0] = f;

e = os_swix(ReadInfo, &r);
d166 1
a166 4
i->minx = r.r[1];
i->miny = r.r[2];
i->maxx = r.r[3];
i->maxy = r.r[4];
d168 4
a171 1
return e;
d173 1
d177 1
a177 5

os_error *font_strwidth(fs)

font_string *fs;

d179 2
d182 5
a186 2
os_regset r;
os_error *e;
d188 1
a188 5
r.r[1] = (int)fs->s;
r.r[2] = fs->x;
r.r[3] = fs->y;
r.r[4] = fs->split;
r.r[5] = fs->term;
d190 4
a193 8
e = os_swix(StringWidth, &r);

fs->x = r.r[2];
fs->y = r.r[3];
fs->split = r.r[4];
fs->term = r.r[5];

return e;
d195 1
d199 1
a199 8



os_error *font_paint(s, options, x, y)

char *s;
int options, x, y;

d201 2
d204 4
a207 2
os_regset r;
os_error *e;
d209 1
a209 8
r.r[1] = (int)s;
r.r[2] = options;
r.r[3] = x;
r.r[4] = y;

e = os_swix(Paint, &r);

return e;
d211 1
d216 1
a216 4
os_error *font_caret(colour, height, flags, x, y)

int colour, height, flags, x, y;

d218 2
d221 5
a225 10
os_regset r;
os_error *e;

r.r[0] = colour;
r.r[1] = height;
r.r[2] = flags;
r.r[3] = x;
r.r[4] = y;

e = os_swix(Caret, &r);
d227 1
a227 1
return e;
d229 1
d234 2
a235 5
os_error *font_converttoos(x_inch, y_inch, x_os, y_os)

int x_inch, y_inch;
int *x_os, *y_os;

d237 2
d240 2
a241 5
os_regset r;
os_error *e;

r.r[1] = x_inch;
r.r[2] = y_inch;
d243 1
a243 1
e = os_swix(ConverttoOS, &r);
d245 2
a246 4
*x_os = r.r[1];
*y_os = r.r[2];

return e;
d248 1
d252 2
a253 5
os_error *font_converttopoints(x_os, y_os, x_inch, y_inch)

int x_os, y_os;
int *x_inch, *y_inch;

d255 2
d258 2
a259 5
os_regset r;
os_error *e;

r.r[1] = x_os;
r.r[2] = y_os;
d261 1
a261 1
e = os_swix(Converttopoints, &r);
d263 2
a264 4
*x_inch = r.r[1];
*y_inch = r.r[2];

return e;
d266 1
d270 1
a270 4
os_error *font_setfont(f)

font f;

d272 2
d275 1
a275 2
os_regset r;
os_error *e;
d277 1
a277 5
r.r[0] = f;

e = os_swix(SetFont, &r);

return(e);
d279 1
d283 1
a283 4
os_error *font_current(f)

font_state *f;

d285 2
d288 1
a288 9
os_regset r;
os_error *e;

e = os_swix(CurrentFont, &r);

f->f = r.r[0];
f->back_colour = r.r[1];
f->fore_colour = r.r[2];
f->offset = r.r[3];
d290 4
a293 1
return(e);
d295 1
d300 1
a300 4
os_error *font_future(f)

font_state *f;

d302 2
d305 1
a305 9
os_regset r;
os_error *e;

e = os_swix(FutureFont, &r);

f->f = r.r[0];
f->back_colour = r.r[1];
f->fore_colour = r.r[2];
f->offset = r.r[3];
d307 4
a310 1
return(e);
d312 1
d317 1
a317 4
os_error *font_findcaret(fs)

font_string *fs;

d319 2
d322 3
a324 6
os_regset r;
os_error *e;

r.r[1] = (int)fs->s;
r.r[2] = fs->x;
r.r[3] = fs->y;
d326 1
a326 1
e = os_swix(FindCaret, &r);
d328 4
a331 6
fs->x = r.r[2];
fs->y = r.r[3];
fs->split = r.r[4];
fs->term = r.r[5];

return e;
d333 1
a337 6

/*font f;
char ch;
int options;
font_info *i;*/

d339 2
d342 3
a344 2
os_regset r;
os_error *e;
d346 1
a346 3
r.r[0] = f;
r.r[1] = ch;
r.r[2] = options;
d348 4
a351 8
e = os_swix(CharBBox, &r);

i->minx = r.r[1];
i->miny = r.r[2];
i->maxx = r.r[3];
i->maxy = r.r[4];

return e;
d353 1
d357 1
a357 4
os_error *font_readscalefactor(x, y)

int *x, *y;

d359 2
d362 1
a362 4
os_regset r;
os_error *e;

e = os_swix(ReadScaleFactor, &r);
d364 2
a365 4
*x = r.r[1];
*y = r.r[2];

return e;
d367 1
d372 1
a372 4
os_error *font_setscalefactor(x, y)

int x, y;

d374 2
d377 2
a378 7
os_regset r;
os_error *e;

r.r[1] = x;
r.r[2] = y;

e = os_swix(SetScaleFactor, &r);
d380 1
a380 1
return e;
d382 1
d387 1
a387 5
os_error *font_list(a, count)

char *a;
int *count;

d389 3
d393 3
a395 3
os_regset r;
os_error *e;
int i;
d397 1
a397 3
r.r[1] = (int)a;
r.r[2] = *count;
r.r[3] = -1;
d399 1
a399 1
e = os_swix(ListFonts, &r);
d401 1
a401 1
if (!e)
d403 2
a404 1
  {
d406 1
a406 4
  *count = r.r[2];
  i = 0;
    
  while (a[i] >= 32 && i <= 99)
d408 1
a408 1
       ++i;
d410 1
a410 1
  a[i] = 0;
d412 1
a412 3
  }

else /* error return: probably some filing system error */
d414 1
a414 1
  *count = -1; /* signal end of list */
d416 1
a416 1
return e;
d418 1
d423 2
a424 5
os_error *font_setcolour(f, background, foreground, offset)

font f;
int background, foreground, offset;

d426 2
d429 4
a432 9
os_regset r;
os_error *e;

r.r[0] = f;
r.r[1] = background;
r.r[2] = foreground;
r.r[3] = offset;

e = os_swix(SetFontColours, &r);
d434 1
a434 1
return e;
d436 1
d440 2
a441 4
os_error *font_setpalette(background, foreground, offset, 
                          physical_back, physical_fore)

int background, foreground, offset, physical_back, physical_fore;
d444 2
d447 5
a451 10
os_regset r;
os_error *e;

r.r[1] = background;
r.r[2] = foreground;
r.r[3] = offset;
r.r[4] = physical_back;
r.r[5] = physical_fore;

e = os_swix(SetPalette, &r);
d453 1
a453 1
return e;
d455 1
d460 1
a460 4
os_error *font_readthresholds(th)

font_threshold *th;

d462 2
d465 1
a465 4
os_regset r;
os_error *e;

r.r[1] = (int)th;
d467 1
a467 3
e = os_swix(ReadThresholds, &r);

return e;
d469 1
d474 1
a474 4
os_error *font_setthresholds(th)

font_threshold *th;

d476 2
d479 1
a479 2
os_regset r;
os_error *e;
d481 1
a481 5
r.r[1] = (int)th;

e = os_swix(SetThresholds, &r);

return e;
d483 1
d488 1
a488 5
os_error *font_findcaretj(fs, offset_x, offset_y)

font_string *fs;
int offset_x, offset_y;

d490 2
d493 5
a497 2
os_regset r;
os_error *e;
d499 1
a499 5
r.r[1] = (int)fs->s;
r.r[2] = fs->x;
r.r[3] = fs->y;
r.r[4] = offset_x;
r.r[5] = offset_y;
d501 4
a504 8
e = os_swix(FindCaretJ, &r);

fs->x = r.r[2];
fs->y = r.r[3];
fs->split = r.r[4];
fs->term = r.r[5];

return e;
d506 1
d510 1
a510 5
os_error *font_stringbbox(s, fi)

char *s;
font_info *fi;

d512 2
d515 1
a515 6
os_regset r;
os_error *e;

r.r[1] = (int)s;

e = os_swix(StringBBox, &r);
d517 1
a517 4
fi->minx = r.r[1];
fi->miny = r.r[2];
fi->maxx = r.r[3];
fi->maxy = r.r[4];
d519 4
a522 1
return e;
d524 1
d558 1
a558 1
   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL) 
d566 1
a566 1
/*Counts the size of the buffer that would have been written if the 
d614 1
a614 1
   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL) 
d634 1
a634 1
   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL) 
@


4.1.14.1
log
@  Merge of multiple versions of RISC_OSLib.
Detail:
  This work may be incomplete - hence import on a branch.
  It has NOT been tested.
Admin:
  Might even build.


Version 5.33, 4.50.2.1. Tagged as 'RISC_OSLib-5_33-4_50_2_1'
@
text
@d15 14
a28 13
/************************************************************************/
/* © Acorn Computers Ltd, 1992.                                         */
/*                                                                      */
/* This file forms part of an unsupported source release of RISC_OSLib. */
/*                                                                      */
/* It may be freely used to create executable images for saleable       */
/* products but cannot be sold in source form or as an object library   */
/* without the prior written consent of Acorn Computers Ltd.            */
/*                                                                      */
/* If this file is re-distributed (even if modified) it should retain   */
/* this copyright notice.                                               */
/*                                                                      */
/************************************************************************/
d33 5
a37 1
 * History: IDJ: 06-Feb-92: prepared for source release
d39 2
d42 2
d45 2
d48 1
d96 3
a98 2
os_error *font_cacheaddress(int *version, int *cacheused,
                            int *cachesize)
d101 2
a102 2
    os_regset r;
    os_error *e;
d108 2
a109 1
    {
d113 3
a115 1
    }
a116 1
    return e;
d120 7
a126 2
os_error *font_find(char *name, int xsize, int ysize, int xres,
                    int yres, font *fontadd)
a127 2
    os_regset r;
    os_error *e;
d129 8
a136 5
    r.r[1] = (int)name;
    r.r[2] = xsize;
    r.r[3] = ysize;
    r.r[4] = xres;
    r.r[5] = yres;
d138 1
a138 1
    e = os_swix(FindFont, &r);
d140 1
a140 1
    *fontadd = (font) r.r[0];
d142 1
a142 1
    return e;
d145 3
a148 1
os_error *font_lose(font f)
d150 2
a151 2
    os_regset r;
    os_error *e;
d153 3
a155 3
    r.r[0] = f;
    e = os_swix(LoseFont, &r);
    return e;
d160 4
a163 1
os_error * font_readdef(font f, font_def *d)
a165 2
    os_regset r;
    os_error *e;
d167 5
a171 2
    r.r[0] = (int)f;
    r.r[1] = (int)&d->name;
d173 1
a173 1
    e = os_swix(ReadDefn, &r);
d175 8
a182 6
    d->xsize = r.r[2];
    d->ysize = r.r[3];
    d->xres = r.r[4];
    d->yres = r.r[5];
    d->usage = r.r[6];
    d->age = r.r[7];
a183 1
    return(e);
d187 5
a191 1
os_error *font_readinfo(font f, font_info *i)
a192 2
    os_regset r;
    os_error *e;
d194 6
a199 1
    r.r[0] = f;
d201 4
a204 1
    e = os_swix(ReadInfo, &r);
d206 1
a206 4
    i->minx = r.r[1];
    i->miny = r.r[2];
    i->maxx = r.r[3];
    i->maxy = r.r[4];
a207 1
    return e;
d211 5
a215 1
os_error *font_strwidth(font_string *fs)
a216 2
    os_regset r;
    os_error *e;
d218 2
a219 5
    r.r[1] = (int)fs->s;
    r.r[2] = fs->x;
    r.r[3] = fs->y;
    r.r[4] = fs->split;
    r.r[5] = fs->term;
d221 5
a225 1
    e = os_swix(StringWidth, &r);
d227 8
a234 4
    fs->x = r.r[2];
    fs->y = r.r[3];
    fs->split = r.r[4];
    fs->term = r.r[5];
a235 1
    return e;
d239 8
a246 1
os_error *font_paint(char *s, int options, int x, int y)
a247 2
    os_regset r;
    os_error *e;
d249 2
a250 4
    r.r[1] = (int)s;
    r.r[2] = options;
    r.r[3] = x;
    r.r[4] = y;
d252 8
a259 1
    e = os_swix(Paint, &r);
a260 1
    return e;
d265 4
a268 1
os_error *font_caret(int colour, int height, int flags, int x, int y)
a269 2
    os_regset r;
    os_error *e;
d271 10
a280 5
    r.r[0] = colour;
    r.r[1] = height;
    r.r[2] = flags;
    r.r[3] = x;
    r.r[4] = y;
d282 1
a282 1
    e = os_swix(Caret, &r);
a283 1
    return e;
d288 5
a292 2
os_error *font_converttoos(int x_inch, int y_inch, int *x_os,
                           int *y_os)
a293 2
    os_regset r;
    os_error *e;
d295 5
a299 2
    r.r[1] = x_inch;
    r.r[2] = y_inch;
d301 1
a301 1
    e = os_swix(ConverttoOS, &r);
d303 4
a306 2
    *x_os = r.r[1];
    *y_os = r.r[2];
a307 1
    return e;
d311 5
a315 2
os_error *font_converttopoints(int x_os, int y_os, int *x_inch,
                               int *y_inch)
a316 2
    os_regset r;
    os_error *e;
d318 5
a322 2
    r.r[1] = x_os;
    r.r[2] = y_os;
d324 1
a324 1
    e = os_swix(Converttopoints, &r);
d326 4
a329 2
    *x_inch = r.r[1];
    *y_inch = r.r[2];
a330 1
    return e;
d334 4
a337 1
os_error *font_setfont(font f)
a338 2
    os_regset r;
    os_error *e;
d340 2
a341 1
    r.r[0] = f;
d343 5
a347 1
    e = os_swix(SetFont, &r);
a348 1
    return(e);
d352 4
a355 1
os_error *font_current(font_state *f)
a356 2
    os_regset r;
    os_error *e;
d358 9
a366 1
    e = os_swix(CurrentFont, &r);
d368 1
a368 4
    f->f = r.r[0];
    f->back_colour = r.r[1];
    f->fore_colour = r.r[2];
    f->offset = r.r[3];
a369 1
    return(e);
d374 4
a377 1
os_error *font_future(font_state *f)
a378 2
    os_regset r;
    os_error *e;
d380 9
a388 1
    e = os_swix(FutureFont, &r);
d390 1
a390 4
    f->f = r.r[0];
    f->back_colour = r.r[1];
    f->fore_colour = r.r[2];
    f->offset = r.r[3];
a391 1
    return(e);
d396 4
a399 1
os_error *font_findcaret(font_string *fs)
a400 2
    os_regset r;
    os_error *e;
d402 6
a407 3
    r.r[1] = (int)fs->s;
    r.r[2] = fs->x;
    r.r[3] = fs->y;
d409 1
a409 1
    e = os_swix(FindCaret, &r);
d411 6
a416 4
    fs->x = r.r[2];
    fs->y = r.r[3];
    fs->split = r.r[4];
    fs->term = r.r[5];
a417 1
    return e;
d422 6
a428 2
    os_regset r;
    os_error *e;
d430 2
a431 3
    r.r[0] = f;
    r.r[1] = ch;
    r.r[2] = options;
d433 3
a435 1
    e = os_swix(CharBBox, &r);
d437 8
a444 4
    i->minx = r.r[1];
    i->miny = r.r[2];
    i->maxx = r.r[3];
    i->maxy = r.r[4];
a445 1
    return e;
d449 4
a452 1
os_error *font_readscalefactor(int *x, int *y)
a453 2
    os_regset r;
    os_error *e;
d455 4
a458 1
    e = os_swix(ReadScaleFactor, &r);
d460 4
a463 2
    *x = r.r[1];
    *y = r.r[2];
a464 1
    return e;
d469 4
a472 1
os_error *font_setscalefactor(int x, int y)
a473 2
    os_regset r;
    os_error *e;
d475 7
a481 2
    r.r[1] = x;
    r.r[2] = y;
d483 1
a483 1
    e = os_swix(SetScaleFactor, &r);
a484 1
    return e;
d489 5
a493 1
os_error *font_list(char *a, int *count)
a494 3
    os_regset r;
    os_error *e;
    int i;
d496 7
a502 3
    r.r[1] = (int)a;
    r.r[2] = *count;
    r.r[3] = -1;
d504 1
a504 1
    e = os_swix(ListFonts, &r);
d506 1
a506 1
    if (!e)
d508 1
a508 1
      {
d510 4
a513 2
      *count = r.r[2];
      i = 0;
d515 1
a515 1
      while (a[i] >= 32 && i <= 99)
d517 1
a517 1
           ++i;
d519 1
a519 1
      a[i] = 0;
d521 1
a521 1
      }
d523 1
a523 1
    else /* error return: probably some filing system error */
d525 1
a525 1
      *count = -1; /* signal end of list */
a526 1
    return e;
d531 5
a535 2
os_error *font_setcolour(font f, int background, int foreground,
                         int offset)
a536 2
    os_regset r;
    os_error *e;
d538 9
a546 4
    r.r[0] = f;
    r.r[1] = background;
    r.r[2] = foreground;
    r.r[3] = offset;
d548 1
a548 1
    e = os_swix(SetFontColours, &r);
a549 1
    return e;
d553 4
a556 2
os_error *font_setpalette(int background, int foreground, int offset,
                          int physical_back, int physical_fore)
a558 2
    os_regset r;
    os_error *e;
d560 10
a569 5
    r.r[1] = background;
    r.r[2] = foreground;
    r.r[3] = offset;
    r.r[4] = physical_back;
    r.r[5] = physical_fore;
d571 1
a571 1
    e = os_swix(SetPalette, &r);
a572 1
    return e;
d577 4
a580 1
os_error *font_readthresholds(font_threshold *th)
a581 2
    os_regset r;
    os_error *e;
d583 4
a586 1
    r.r[1] = (int)th;
d588 3
a590 1
    e = os_swix(ReadThresholds, &r);
a591 1
    return e;
d596 4
a599 1
os_error *font_setthresholds(font_threshold *th)
a600 2
    os_regset r;
    os_error *e;
d602 2
a603 1
    r.r[1] = (int)th;
d605 5
a609 1
    e = os_swix(SetThresholds, &r);
a610 1
    return e;
d615 5
a619 1
os_error *font_findcaretj(font_string *fs, int offset_x, int offset_y)
a620 2
    os_regset r;
    os_error *e;
d622 2
a623 5
    r.r[1] = (int)fs->s;
    r.r[2] = fs->x;
    r.r[3] = fs->y;
    r.r[4] = offset_x;
    r.r[5] = offset_y;
d625 5
a629 1
    e = os_swix(FindCaretJ, &r);
d631 8
a638 4
    fs->x = r.r[2];
    fs->y = r.r[3];
    fs->split = r.r[4];
    fs->term = r.r[5];
a639 1
    return e;
d643 5
a647 1
os_error *font_stringbbox(char *s, font_info *fi)
a648 2
    os_regset r;
    os_error *e;
d650 6
a655 1
    r.r[1] = (int)s;
d657 4
a660 1
    e = os_swix(StringBBox, &r);
d662 1
a662 4
    fi->minx = r.r[1];
    fi->miny = r.r[2];
    fi->maxx = r.r[3];
    fi->maxy = r.r[4];
a663 1
    return e;
d697 1
a697 1
   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL)
d705 1
a705 1
/*Counts the size of the buffer that would have been written if the
d753 1
a753 1
   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL)
d773 1
a773 1
   if ((error = os_swix (SwitchOutputToBuffer, &reg_set)) != NULL)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

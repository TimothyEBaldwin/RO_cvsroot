head	4.4;
access;
symbols
	RISC_OSLib-5_97:4.4
	RISC_OSLib-5_96:4.4
	RISC_OSLib-5_95:4.4
	RISC_OSLib-5_94:4.4
	RISC_OSLib-5_93:4.4
	RISC_OSLib-5_92:4.4
	RISC_OSLib-5_91:4.4
	RISC_OSLib-5_90:4.4
	RISC_OSLib-5_89:4.4
	RISC_OSLib-5_88:4.4
	RISC_OSLib-5_87:4.4
	RISC_OSLib-5_86-1:4.4
	RISC_OSLib-5_86:4.4
	RISC_OSLib-5_85:4.4
	RISC_OSLib-5_84:4.3
	RISC_OSLib-5_83-2:4.3
	RISC_OSLib-5_83-1:4.3
	RISC_OSLib-5_83:4.3
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.2
	RISC_OSLib-5_77:4.2
	RISC_OSLib-5_76:4.2
	RISC_OSLib-5_75:4.2
	RISC_OSLib-5_74:4.2
	RISC_OSLib-5_73:4.2
	RISC_OSLib-5_72:4.2
	RISC_OSLib-5_71:4.2
	RISC_OSLib-5_70:4.2
	RISC_OSLib-5_69:4.2
	RISC_OSLib-5_68:4.2
	RISC_OSLib-5_67:4.2
	RISC_OSLib-5_66:4.2
	RISC_OSLib-5_65:4.2
	RISC_OSLib-5_64:4.2
	RISC_OSLib-5_63:4.2
	RISC_OSLib-5_62:4.2
	RISC_OSLib-5_61:4.2
	RISC_OSLib-5_60:4.2
	RISC_OSLib-5_59:4.2
	RISC_OSLib-5_58:4.2
	RISC_OSLib-5_57:4.2
	RISC_OSLib-5_56:4.2
	RISC_OSLib-5_55:4.2
	RISC_OSLib-5_54:4.2
	RISC_OSLib-5_53:4.1
	RISC_OSLib-5_52:4.1
	RISC_OSLib-5_51:4.1
	RO_5_07:4.1
	RISC_OSLib-5_50:4.1
	RISC_OSLib-5_49:4.1
	RISC_OSLib-5_46-4_64_2_1:4.1
	NoInlineAsm:4.1.0.16
	RISC_OSLib-5_48:4.1
	RISC_OSLib-5_47:4.1
	RISC_OSLib-5_46:4.1
	RISC_OSLib-5_45:4.1
	RISC_OSLib-5_44:4.1
	RISC_OSLib-5_43:4.1
	RISC_OSLib-5_42:4.1
	RISC_OSLib-5_41:4.1
	RISC_OSLib-5_40:4.1
	RISC_OSLib-5_39:4.1
	RISC_OSLib-5_38:4.1
	RISC_OSLib-5_37:4.1
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2015.04.03.22.43.46;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	4ZOxMlETYoK3gcgy;

4.3
date	2013.10.24.20.03.55;	author rsprowson;	state Exp;
branches;
next	4.2;
commitid	8snV0tcFxVQyiAax;

4.2
date	2009.05.31.17.58.59;	author pnaulls;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.16;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.25.16;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.54.17;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.31.28;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.50.00;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@Clean up pass
Trim any #if FALSE switches over a decade old, and keep #if TRUE.
Accept EDIT2 and FMTTEXT1 bracketed code.
Remove unused internal functions txt1_dooaction txt1_dosetoaction.
Retagged as RISC_OSLib-5_85.
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
  Purpose: provide a menu for simple cosmetic alterations to a Text
           Arthur version.
  Author: WRS
  History:
    25 August 87 -- started
    25-Feb-88: WRS: converted to C, new trace usage.
    02-Mar-88: WRS: dbox form removed.
 *  13-Dec-89: WRS: msgs literal text put back in.
    12-Feb-90: IDJ: added menu entry to set max size of work area
    13-Feb-90: IDJ: limited work area width to 256 chars (you get 'echos' of text
                    appearing if width is much bigger - probably another display bug)
    16-Feb-90: IDJ: changed limit to 192 chars (display bugs start > 196 chars)
    02-Dec-90: IDJ: changed Wrap to Window wrap
    08-Apr-91: PJC: added facility to use new font manager menus
    07-Jun-91: IDJ: no font change when just click on font name
    14-Jun-91: IDJ: changed font menu to what it used to be, and made edit read
                    new fonts every menu open (so we can catch new fonts loaded)
*/

#define BOOL int
#define TRUE 1
#define FALSE 0

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "txt.h"
#include "os.h"
#include "wimp.h"
#include "wimpt.h"
#include "menu.h"
#include "EditIntern/txtar.h"
#include "dbox.h"
#include "event.h"
#include "EditIntern/txtoptmenu.h"
#include "visdelay.h"
#include "font.h"
#include "trace.h"
#include "werr.h"
#include "colourmenu.h"
#include "msgs.h"
#include "txtwin.h"
#include "VerIntern/messages.h"

#define MFont 1
#define MFontSize 2
#define MFontHeight 3
#define MLeading 4
#define MMargin 5
#define MInvert 6
#define MWrap 7
#define MForeground 8
#define MBackground 9
#ifdef BIG_WINDOWS
#define MWorkArea 10
#endif

static menu tmsize; /* the size menu */
static menu tmheight; /* height menu */
static menu tmleading; /* leading menu */
static menu tmmargin; /* margin menu */
#ifdef BIG_WINDOWS
static menu tmworkarea; /* window width in chars */
#endif
static char leadingbuf[10];
static char marginbuf[10];
#ifdef BIG_WINDOWS
static char widthbuf[10];
#endif

static wimp_menustr *font_menu = 0;
static char *font_hit = 0;
static int padding3;
static int padding4;

#define txtoptmenu__max(a,b) (((a)>(b))?(a):(b))
#define txtoptmenu__min(a,b) (((a)>(b))?(b):(a))

static wimp_menustr* txtoptmenu__fontmenu(void) {

  /* always rebuild the font menu */
  wimpt_complain(font_makemenu(&font_menu, NULL, fontmenu_WithSystemFont));

  return(font_menu);
}

static int sizes[] = {8, 10, 12, 14, 20};

static void txtoptmenu__setfontmenuflags(txtar_options *current) {
  int i;

  if (current->fixfont) {
    wimpt_complain(font_makemenu(&font_menu, (char *)1, fontmenu_WithSystemFont));
  } else {
    wimpt_complain(font_makemenu(&font_menu, current->fontname, fontmenu_WithSystemFont));
  }
  for (i = 1; i <= 5; i++) {
    menu_setflags(tmsize, i, current->fontwidth == sizes[i-1], FALSE);
    menu_setflags(tmheight, i, current->fontheight == sizes[i-1], FALSE);
  };
}

/* -------- Colour Menu. -------- */

static menu txtoptmenu_makecolourmenu(void)
{
  return colourmenu_make(msgs_lookup(MSGS_txt55), FALSE);
}

/* -------- Entire Menu. -------- */

static menu tm = 0;
static menu tm3;
static menu tm4;

static void txtoptmenu__makevaluemenu(menu m) {
wimp_menuhdr *sizemenu;
wimp_menuitem *sizeitem;

sizemenu = (wimp_menuhdr*) menu_syshandle(m);
sizemenu->width = 160;
  /* fix because of long entry messing things up. */
  /* >>>> change when size-of-system-font becomes available. */
sizeitem = (wimp_menuitem*) (sizemenu+1); /* points at first item. */
sizeitem += 5; /* point at last item. */
sizeitem->data.indirecttext.buffer[0] = 0;
sizeitem->data.indirecttext.validstring = "a0-9";
sizeitem->data.indirecttext.bufflen = 3; /* >>> new, to prevent huge numbers. */
sizeitem->flags |= wimp_MWRITABLE;
sizeitem->iconflags &= ~(wimp_IBTYPE * 0xF); /* clear button type field */
sizeitem->iconflags |= (wimp_IBTYPE * wimp_BWRITABLE); /* and set writable */
}

static void txtoptmenu__makeoriginal(void)
{

#ifdef BIG_WINDOWS
tm = menu_new(
  msgs_lookup(MSGS_txt62),
  msgs_lookup(MSGS_txt63));
#else
tm = menu_new(
  msgs_lookup(MSGS_txt62),
  msgs_lookup(MSGS_txt63));
#endif

tmsize = menu_new(
  msgs_lookup(MSGS_txt56),
  msgs_lookup(MSGS_txt57));
tmheight = menu_new(
  msgs_lookup(MSGS_txt58),
  msgs_lookup(MSGS_txt59));

tmleading = menu_new(msgs_lookup(MSGS_txt60), msgs_lookup(MSGS_txt72));
menu_make_writeable(tmleading, 1, leadingbuf, 3, "a0-9\\-");
menu_submenu(tm, MLeading, tmleading);

tmmargin = menu_new(msgs_lookup(MSGS_txt61),msgs_lookup(MSGS_txt72));
menu_make_writeable(tmmargin, 1, marginbuf, 3, "a0-9");
menu_submenu(tm, MMargin, tmmargin);

#ifdef BIG_WINDOWS
tmworkarea = menu_new(msgs_lookup("txt71"), "foofoofoo");
menu_make_writeable(tmworkarea, 1, widthbuf, 4, "a0-9");
menu_submenu(tm, MWorkArea, tmworkarea);
#endif

/* The final option (a writable menu entry) is so large that he's forced
to make it indirect. */
txtoptmenu__makevaluemenu(tmsize);
txtoptmenu__makevaluemenu(tmheight);
menu_submenu(tm, MFontSize, tmsize);
menu_submenu(tm, MFontHeight, tmheight);

tm3 = txtoptmenu_makecolourmenu();
menu_submenu(tm, MForeground, tm3);

tm4 = txtoptmenu_makecolourmenu();
menu_submenu(tm, MBackground, tm4);
}

static void txtoptmenu__setflags(txt t) {
  txtar_options o;
  int i;

  txtar_getoptions(t, &o);
/*  menu_setflags(tm, MFont, ! o.fixfont, FALSE); */
  menu_setflags(tm, MWrap, o.wraptowindow, FALSE);
  for (i = 1; i <= 16; i++) {
    menu_setflags(tm3, i, i - 1 == o.forecolour, FALSE);
    menu_setflags(tm4, i, i - 1 == o.backcolour, FALSE);
  };
  menu_setflags(tm, MFontSize, FALSE, o.fixfont);
  menu_setflags(tm, MFontHeight, FALSE, o.fixfont);
  txtoptmenu__setfontmenuflags(&o);
  sprintf(leadingbuf, "%i", o.leading);
  sprintf(marginbuf, "%i", o.margin);
#ifdef BIG_WINDOWS
  menu_setflags(tm, MWorkArea, o.big_windows, FALSE);
  sprintf(widthbuf, "%i", o.big_window_size);
#endif
}

static int getint(char *a, int dft) {
  int n = 0;
  while (1) {
    int ch = *a++;
    tracef1("found char %i.\n", ch);
    if (ch == 0) return n;
    if (ch >= '0' && ch <= '9') {
      n = n * 10 + ch - '0';
    } else {
      return dft;
    };
  };
}

static int txtoptmenu__fontmenuvalue(menu m, int item, int dft) {
  wimp_menuhdr *sizemenu;
  wimp_menuitem *sizeitem;

  switch (item) {
    default: return dft;
    case 1: return 8;
    case 2: return 10;
    case 3: return 12;
    case 4: return 14;
    case 5: return 20;
    case 6:
      tracef0("writable font size menu entry.\n");
      sizemenu = (wimp_menuhdr*) menu_syshandle(m);
      sizeitem = (wimp_menuitem*) (sizemenu+1); /* points at first item. */
      sizeitem += 5; /* point at last item. */
    return getint(sizeitem->data.indirecttext.buffer, dft);
  };
}

menu txtoptmenu_make(txt t) {
  if (tm == 0) txtoptmenu__makeoriginal();

 /* need to "magic" the font menu into the structure */
{ wimp_menuhdr *foo = (wimp_menuhdr*) menu_syshandle(tm);
  wimp_menuitem *item = (wimp_menuitem*) (foo+1);

  item += MFont-1;
  item->submenu = txtoptmenu__fontmenu();
}
  txtoptmenu__setflags(t);
  return tm;
}

void txtoptmenu_eventproc(txt t, char *s)
{

txtar_options o;
unsigned i;

if (s[0] == 0) {
  /* do nothing */
} else {
  txtar_getoptions(t, &o);

  if (s[0] == MFont) {
    if (s[1] == 1) {
      o.fixfont = TRUE;
    } else if (s[1] > 1) {
      /* we can't just copy the string 'cos it isn't linear any more */
      /* need to translate RISC_OSLib menu hits back into wimp menu hits */
      /* this is done by copying the chars back into ints, decrementing as we go */
      int selection[20];
      int i = 0;
      do {
       i++;
       selection[i-1] = s[i] - 1;
      } while (s[i] != 0);
      /* now get the string */
      wimpt_complain(font_decodemenu(font_menu, selection, &font_hit));
      o.fixfont = FALSE;
      strcpy(o.fontname, font_hit);
    };
    o.leading = 0; /* zeroed on any font change. */
  } else if (s[0] == MFontSize) {
    o.fixfont = FALSE;
    o.fontwidth = txtoptmenu__fontmenuvalue(tmsize, s[1], o.fontwidth);
    o.fontheight = o.fontwidth;
  } else if (s[0] == MFontHeight) {
    o.fixfont = FALSE;
    o.fontheight = txtoptmenu__fontmenuvalue(tmheight, s[1], o.fontheight);
  } else if (s[0] == MLeading) {
    if (leadingbuf[0] == '-') {
      o.leading = - getint(&leadingbuf[1], 0);
    } else {
      o.leading = getint(leadingbuf, 0);
    };
  } else if (s[0] == MMargin) {
    o.margin = getint(marginbuf, 0);
#ifdef BIG_WINDOWS
  } else if (s[0] == MWorkArea) {
    txtwin_setcurrentwindow(t);
    if (s[1] == 0) 
      o.big_windows = !o.big_windows;
    else
    { int i = getint(widthbuf, 0);
      if (i <= 0) i = 1;
      o.big_windows = TRUE;
      o.big_window_size = txtoptmenu__min(i, BIG_WINDOW_SIZE_LIMIT);
    }
#endif
  } else if (s[0] == MWrap) /* invert wrap bit */
     o.wraptowindow = !o.wraptowindow;

  else if (s[0] == MInvert) /* swap fore and back */

          {
          i = o.forecolour;
          o.forecolour = o.backcolour;
          o.backcolour = i;
          }

  else { /* foreground, background. */
    if (s[1] == 0)  /* he just clicked in main menu */
      ;    /* colours are fine */
    else if (s[0] == MForeground) {
      o.forecolour = s[1] - 1;
    } else if (s[0] == MBackground) {
      o.backcolour = s[1] - 1;
    };
  };

  txtar_setoptions(t, &o);

  }
}

/* If he's displaying in a font, he can go direct to the foreground colour
menu to set black-on-white or white-on-black. */

void txtoptmenu_init(void) {
  (void) txtoptmenu__fontmenu(); /* create the font menu */
}

/* end */
@


4.3
log
@Some library fixes
Fix for problem passing long command lines via system(), while there are good arguments to leave the threshold at 255, non DDEUtils aware programs get brutally truncated command strings, and since the old threshold of 255 applied when the kernel handled 256 command lines, upping the limit to 1k is no worse than before.
Fix for Edit failing to draw lines of text longer than 192 characters (ticket #350). Several factors were conspiring here: on a mode change the window width in characters wasn't being clamped, whereas user entered limits in the menu were, then the internal buffer ("PAINTBUFSIZE") was too short so lines got truncated, and when larger than 256 got wrapped modulo 256 due to the use of an array of chars. Now set at compile time with BIG_WINDOW_SIZE_LIMIT with a new theoretical maximum of 8192. Currently limited to 480 since it uses stack variables.

In the C library:
 armsys.c: adapt the threshold at which to use DDEUtils based on the kernel version number
 scanf.c: squash a warning
 time.c: mark the table of month lengths as constant so we can claw back 13 words of static workspace without having to change the stubs

In RISC OS lib:
 bbc.c: remove local definitions of some SWI numbers
 template.c: squash a warning
 txt.c: delete Modula-2 support
 txt1.c: compare pointer with NULL not an integer
 txtar.c: introduce BIG_WINDOW_SIZE_LIMIT, rationalise a few sprintf's, mark private functions as static
 txtundo.c/txtedit.c: squash old style function warnings
 txtoptmenu.c: clamp the window width read from Edit$Options properly, delete long disabled code
 txtscrap.c: dead function deleted


Version 5.78. Tagged as 'RISC_OSLib-5_78'
@
text
@a94 6
#if FALSE
  if (font_menu == 0) {
#endif

   /* always rebuild the font menu */
   wimpt_complain(font_makemenu(&font_menu, NULL, fontmenu_WithSystemFont));
d96 2
a98 3
#if FALSE
  }
#endif
a111 7
#if FALSE
  menu_setflags(tmsize, 1, current->fontwidth == 8, FALSE);
  menu_setflags(tmsize, 2, current->fontwidth == 10, FALSE);
  menu_setflags(tmsize, 3, current->fontwidth == 12, FALSE);
  menu_setflags(tmsize, 4, current->fontwidth == 14, FALSE);
  menu_setflags(tmsize, 5, current->fontwidth == 20, FALSE);
#else
a115 1
#endif
d152 1
a152 6
#if FALSE
tm = menu_new(
      "Display",
      "Font,Font size,Font height,Line spacing,Margin,Invert,Window wrap,Foreground,Background");
#else
#ifdef BIG_WINDOWS 
a160 1
#endif
a161 4
#if FALSE
tmsize = menu_new("Font size", "8,10,12,14,20,morethan12chars");
tmheight = menu_new("Font height", "8,10,12,14,20,morethan12chars");
#else
a167 1
#endif
a278 7
#if FALSE
    o.fixfont = FALSE;
    if (s[1] == 0) {
      /* He just clicked "font": go back to last one. */
    } else {
    }
#else
a296 1
#endif
a335 3
#if FALSE
    o.fixfont = TRUE;
#endif
@


4.2
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@a38 2
#define NewFontMenu TRUE

a59 6
void txtoptmenu_fontdbox(txt text);

#define MenuDescByteSize sizeof(wimp_menuhdr)
#define MenuItemByteSize sizeof(wimp_menuitem)


a85 2
#if NewFontMenu

d91 3
a108 41
#else

static menu font_menu = 0;
static int font_menu_size = 1;
static char **fonts = 0;
static int font_array_size = 0;

static menu txtoptmenu__fontmenu(void) {
  if (font_menu == 0) {
    char a[99];
    int i = 0;

    fonts = malloc(4 * sizeof(*fonts)); /* room for 4 fonts */
    if (fonts == 0) werr(TRUE, msgs_lookup(MSGS_txt52));
    font_array_size = 4;
    font_menu = menu_new(
      msgs_lookup(MSGS_txt53),
      msgs_lookup(MSGS_txt54));
    while (1) {
      font_list(&a[0], &i);
      tracef1("found font '%s'.\n", (int) &a[0]);
      if (i == -1) break;
      if (++font_menu_size >= font_array_size) {
        /* copy the fonts array to one twice the size */
        char **newfonts = malloc(2 * font_array_size * sizeof(*fonts));
        int i;
        if (newfonts == 0) werr(TRUE, msgs_lookup(MSGS_txt52));
        for (i = 0; i < font_array_size; i++) newfonts[i] = fonts[i];
        fonts = newfonts;
        font_array_size = font_array_size * 2;
      };
      fonts[font_menu_size] = malloc(1 + strlen(&a[0]));
      if (fonts[font_menu_size] == 0) werr(TRUE, msgs_lookup(MSGS_txt52));
      strcpy(fonts[font_menu_size], &a[0]);
      menu_extend(font_menu, &a[0]);
    };
  };
  return font_menu;
}
#endif

d113 1
a113 1
#if NewFontMenu
a118 8
#else
  menu_setflags(font_menu, 1, current->fixfont, FALSE);
  for (i = 2; i <= font_menu_size; i++) {
    menu_setflags(font_menu, i,
      (!current->fixfont) & (strcmp(current->fontname, fonts[i]) == 0),
      FALSE);
  };
#endif
d135 1
a135 1
static menu txtoptmenu_makecolourmenu()
d137 1
a137 1
return colourmenu_make(msgs_lookup(MSGS_txt55), FALSE);
a182 4
#ifndef NewFontMenu
menu_submenu(tm, MFont, txtoptmenu__fontmenu());
#endif

d281 1
a281 1
#if NewFontMenu
d283 2
a284 2
 { wimp_menuhdr *foo = (wimp_menuhdr*) menu_syshandle(tm);
   wimp_menuitem *item = (wimp_menuitem*) (foo+1);
d286 3
a288 4
   item += MFont-1;
   item->submenu = txtoptmenu__fontmenu();
 }
#endif
a314 1
#if NewFontMenu
a327 4
#else
      o.fixfont = FALSE;
      strcpy(o.fontname, fonts[s[1]]);
#endif
d353 1
a353 4
      if (i <= 0)
         i = 1;
      else if (i >= 192)
         i = 192;
d355 1
a355 1
      o.big_window_size = i;
@


4.1
log
@Initial revision
@
text
@d44 17
a60 17
#include "h.txt"
#include "h.os"
#include "h.wimp"
#include "h.wimpt"
#include "h.menu"
#include "h.EditIntern.txtar"
#include "h.dbox"
#include "h.event"
#include "h.EditIntern.txtoptmenu"
#include "h.visdelay"
#include "h.font"
#include "h.trace"
#include "h.werr"
#include "h.colourmenu"
#include "h.msgs"
#include "h.txtwin"
#include "h.verintern.messages"
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

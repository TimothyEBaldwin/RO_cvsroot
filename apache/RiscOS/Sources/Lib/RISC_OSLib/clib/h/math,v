head	4.10;
access;
symbols
	RISC_OSLib-5_97:4.10
	RISC_OSLib-5_96:4.10
	RISC_OSLib-5_95:4.10
	RISC_OSLib-5_94:4.10
	RISC_OSLib-5_93:4.10
	RISC_OSLib-5_92:4.10
	RISC_OSLib-5_91:4.10
	RISC_OSLib-5_90:4.10
	RISC_OSLib-5_89:4.10
	RISC_OSLib-5_88:4.10
	RISC_OSLib-5_87:4.10
	RISC_OSLib-5_86-1:4.10
	RISC_OSLib-5_86:4.10
	RISC_OSLib-5_85:4.10
	RISC_OSLib-5_84:4.10
	RISC_OSLib-5_83-2:4.10
	RISC_OSLib-5_83-1:4.10
	RISC_OSLib-5_83:4.10
	RISC_OSLib-5_82:4.10
	RISC_OSLib-5_81:4.10
	RISC_OSLib-5_75-2:4.10
	RISC_OSLib-5_80:4.10
	RISC_OSLib-5_79:4.10
	RISC_OSLib-5_78:4.10
	RISC_OSLib-5_75-1:4.10
	RISC_OSLib-5_77:4.10
	RISC_OSLib-5_76:4.10
	RISC_OSLib-5_75:4.10
	RISC_OSLib-5_74:4.10
	RISC_OSLib-5_73:4.9
	RISC_OSLib-5_72:4.9
	RISC_OSLib-5_71:4.9
	RISC_OSLib-5_70:4.9
	RISC_OSLib-5_69:4.9
	RISC_OSLib-5_68:4.9
	RISC_OSLib-5_67:4.9
	RISC_OSLib-5_66:4.9
	RISC_OSLib-5_65:4.9
	RISC_OSLib-5_64:4.9
	RISC_OSLib-5_63:4.9
	RISC_OSLib-5_62:4.9
	RISC_OSLib-5_61:4.9
	RISC_OSLib-5_60:4.9
	RISC_OSLib-5_59:4.9
	RISC_OSLib-5_58:4.9
	RISC_OSLib-5_57:4.9
	RISC_OSLib-5_56:4.9
	RISC_OSLib-5_55:4.9
	RISC_OSLib-5_54:4.9
	RISC_OSLib-5_53:4.9
	RISC_OSLib-5_52:4.9
	RISC_OSLib-5_51:4.8
	RO_5_07:4.8
	RISC_OSLib-5_50:4.8
	RISC_OSLib-5_49:4.7
	RISC_OSLib-5_46-4_64_2_1:4.6
	NoInlineAsm:4.6.0.2
	RISC_OSLib-5_48:4.6
	RISC_OSLib-5_47:4.6
	RISC_OSLib-5_46:4.6
	RISC_OSLib-5_45:4.5
	RISC_OSLib-5_44:4.5
	RISC_OSLib-5_43:4.5
	RISC_OSLib-5_42:4.5
	RISC_OSLib-5_41:4.5
	RISC_OSLib-5_40:4.5
	RISC_OSLib-5_39:4.4
	RISC_OSLib-5_38:4.3
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2012.10.12.22.20.04;	author bavison;	state Exp;
branches;
next	4.9;
commitid	2yBRiGPuRMmEa9ow;

4.9
date	2005.03.07.15.19.17;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2004.07.01.18.08.30;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2004.01.23.19.10.20;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2003.04.15.16.50.25;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2002.04.12.15.19.40;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2002.04.11.16.37.53;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2002.03.26.16.17.26;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2002.03.21.14.36.25;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.52;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.52;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.52.07;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.38;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.51;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@  Merged in a fix to <math.h> from C compiler
Detail:
  This change was first applied to the inbuilt headers in the C compiler at
  version 5.59 (07 Apr 2005), but was accidentally not copied into the
  RISC_OSLib version of math.h. Fortunately, this would only have affected
  anyone compiling software with the -jC: switch.
Admin:
  Untested, but should be a safe change.

Version 5.74. Tagged as 'RISC_OSLib-5_74'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma force_top_level
#pragma include_only_once

/* math.h: ISO 'C' (9899:1999) library header, section 7.12 */
/* Copyright (C) Codemist Ltd. */
/* Copyright (C) Acorn Computers Ltd. 1991 */
/* version 0.07 */

#ifndef __math_h
#define __math_h

typedef float float_t;
typedef double double_t;
   /* most efficient types at least as wide as float and double */

#ifndef HUGE_VAL
#  define HUGE_VAL __huge_val
#ifdef __cplusplus
#  define HUGE __huge_val
extern "C" const double HUGE_VAL;
#else
extern const double HUGE_VAL;
#endif
#endif
   /* HUGE_VAL equals DBL_MAX, and this is the return value for overflow */
   /* range errors in the C90 functions. Also, domain errors return */
   /* -HUGE_VAL = -DBL_MAX. */
   /* However, new C99 functions are in a state of flux. They may either */
   /* return DBL_MAX or INFINITY for range errors and either a NaN */
   /* or -DBL_MAX for domain errors, depending on how new the shared C */
   /* library is. Newer versions of the C library will use infinities and */
   /* NaNs for all the C99 functions, and will also have a parallel set of */
   /* C99 versions of the original C90 functions, so behaviour will */
   /* eventually be consistent within each mode, with HUGE_VAL set to */
   /* DBL_MAX for C90 mode and INFINITY for C99 mode. */
   /* See also math_errhandling below. */

#ifndef HUGE_VALL
#define HUGE_VALL ((long double) HUGE_VAL)
#endif
   /* long double is equivalent to double in Norcroft C, so all */
   /* long double functions just call their double counterpart. */

#ifndef __cplusplus
#ifndef HUGE_VALF
#  define HUGE_VALF INFINITY
#endif

#define INFINITY 0f_7F800000
   /* a constant expression of type float representing positive infinity */
#define NAN      0f_7FC00001
   /* a constant expression of type float representing a quiet NaN */

#define FP_ZERO      0
#define FP_SUBNORMAL 1
#define FP_NORMAL    2
#define FP_INFINITE  3
#define FP_NAN       4
   /* the mutually exclusive kinds of floating-point values for fpclassify */
#endif

#define FP_FAST_FMAF 1
   /* indicates that the fmaf function generally executes about as fast as */
   /* a multiply and an add of float operands. fma and fmal are slow. */

#define FP_ILOGB0    (-0x7FFFFFFF) /* -INT_MAX */
#define FP_ILOGBNAN  (~0x7FFFFFFF) /* INT_MIN */
   /* integer constant expressions whose values are returned by ilogb(x) */
   /* if x is zero or NaN, respectively. */

#define MATH_ERRNO 1
#define MATH_ERREXCEPT 2

#undef math_errhandling
   /* math_errhandling is not currently provided, as an indication that */
   /* this is in flux. At present, "invalid", "divide-by-zero" and */
   /* "overflow" traps are enabled by default, so to raise these would */
   /* cause SIGFPE. C90 does not allow <math.h> functions to do this, so */
   /* the functions present in C90 do not raise these exceptions. */
   /* They instead set errno to EDOM or ERANGE, as required by C90. */
   /* The new C99 functions do raise exceptions, and don't set errno. But */
   /* because this will (by default) lead to SIGFPE being raised, the */
   /* behaviour does not currently conform to the C99 standard. To avoid */
   /* the traps you can use feholdexcept(). A future C99 version of the */
   /* library will have all traps disabled by default, making these */
   /* functions conforming, and will have new versions of the C90 */
   /* functions which do raise exceptions. Note that some C99 functions */
   /* may still be using errno and DBL_MAX, but this will be changed (even */
   /* for existing clients) by newer Shared C libraries. The original C90 */
   /* functions will not change, to preserve compatibility for older */
   /* clients. See also HUGE_VAL above. */

/* #pragma STDC FP_CONTRACT ON|OFF|DEFAULT */
   /* The FP_CONTRACT pragma can be used to allow (if the state is "on") */
   /* or disallow (if the state is "off") the implementation to contract */
   /* expressions (refer to section 6.5 of the ISO standard). Each pragma */
   /* can occur either outside external declarations or preceding all */
   /* explicit declarations and statements inside a compound statement. */
   /* When outside external declarations, the pragma takes effect from its */
   /* occurrence until another FP_CONTRACT pragma is encountered, or until */
   /* the end of the translation unit. When inside a compound statement, */
   /* the pragma takes effect from its occurrence until another */
   /* FP_CONTRACT pragma is encountered (including within a nested */
   /* compound statement), or until the end of the compound statement; at */
   /* the end of a compound statement the state for the pragma is restored */
   /* to its condition just before the compound statement. If this pragma */
   /* is used in any other context, the behaviour is undefined. The */
   /* default state for this pragma is implementation-defined ("off" in */
   /* Norcroft C.). */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __cplusplus
/* None of this actually works, as the C++ system won't obey the
   force_fpargs_in_regs pragma */

#pragma no_side_effects
#pragma force_fpargs_in_regs
__caller_narrow int __fpclassifyf(float);
int __fpclassifyd(double);
__caller_narrow int __signbitf(float);
int __signbitd(double);
__caller_narrow float __copysignf(float,float);
double __copysignd(double,double);
#pragma no_force_fpargs_in_regs
#pragma side_effects

#ifdef __cplusplus
#define __classmacro(fn,r) (sizeof(r) == 4 ? __##fn##f((float)(r)) : \
                                             __##fn##d((double)(r)))
#else
#define __assertfp(r) ___assert(___typeof(r) == 0x002 ||\
                                ___typeof(r) == 0x202 ||\
                                ___typeof(r) == 0x402, \
                                "Illegal type used with classification macro")

#define __classmacro(fn,r) (__assertfp(r),\
                            ___typeof(r) == 0x402 ? __##fn##f((float)(r)) : \
                                                    __##fn##d((double)(r)))
#endif

#define fpclassify(r) __classmacro(fpclassify,(r))
   /* Returns: the value of the appropriate number classification macro */
#define isfinite(r)   (fpclassify(r) <= FP_NORMAL)
   /* Returns: a nonzero value if and only if its argument is finite */
#define isinf(r)      (fpclassify(r) == FP_INFINITE)
   /* Returns: a nonzero value if and only if its argument is infinite */
#define isnan(r)      (fpclassify(r) == FP_NAN)
   /* Returns: a nonzero value if and only if its argument is a NaN */
#define isnormal(r)   (fpclassify(r) == FP_NORMAL)
   /* Returns: a nonzero value if and only if its argument is normal */
#define signbit(r)    __classmacro(signbit,(r))
   /* Returns: a nonzero value if and only if its argument is negative */

#endif

double acos(double /*x*/);
float acosf(float /*x*/);
long double acosl(long double /*x*/);
   /* computes the principal value of the arc cosine of x */
   /* a domain error occurs for arguments not in the range -1 to 1 */
   /* Returns: the arc cosine in the range 0 to Pi. */
double asin(double /*x*/);
float asinf(float /*x*/);
long double asinl(long double /*x*/);
   /* computes the principal value of the arc sine of x */
   /* a domain error occurs for arguments not in the range -1 to 1 */
   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
double atan(double /*x*/);
float atanf(float /*x*/);
long double atanl(long double /*x*/);
   /* computes the principal value of the arc tangent of x */
   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
double atan2(double /*y*/, double /*x*/);
float atan2f(float /*y*/, float /*x*/);
long double atan2l(long double /*y*/, long double /*x*/);
   /* computes the principal value of the arc tangent of y/x, using the */
   /* signs of both arguments to determine the quadrant of the return */
   /* value */
   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
double cos(double /*x*/);
float cosf(float /*x*/);
long double cosl(long double /*x*/);
   /* computes the cosine of x (measured in radians). A large magnitude */
   /* argument may yield a result with little or no significance */
   /* Returns: the cosine value. */
double sin(double /*x*/);
float sinf(float /*x*/);
long double sinl(long double /*x*/);
   /* computes the sine of x (measured in radians). A large magnitude */
   /* argument may yield a result with little or no significance */
   /* Returns: the sine value. */
double tan(double /*x*/);
float tanf(float /*x*/);
long double tanl(long double /*x*/);
   /* computes the tangent of x (measured in radians). A large magnitude */
   /* argument may yield a result with little or no significance */
   /* Returns: the tangent value. */

double acosh(double /*x*/);
float acoshf(float /*x*/);
long double acoshl(long double /*x*/);
   /* computes the (non-negative) arc hyperbolic cosine of x. */
   /* A domain error occurs for arguments less than 1. */
   /* Returns: arcosh x in the interval [0,+inf] */
double asinh(double /*x*/);
float asinhf(float /*x*/);
long double asinhl(long double /*x*/);
   /* computes the arc hyperbolic sine of x. */
   /* Returns: arsinh x */
double atanh(double /*x*/);
float atanhf(float /*x*/);
long double atanhl(long double /*x*/);
   /* computes the arc hyperbolic tangent of x. A domain error occurs */
   /* for arguments not in the interval [-1,+1]. A range error occurs */
   /* if the argument equals -1 or +1. */
   /* Returns: artanh x */
double cosh(double /*x*/);
float coshf(float /*x*/);
long double coshl(long double /*x*/);
   /* computes the hyperbolic cosine of x. A range error occurs if the */
   /* magnitude of x is too large. */
   /* Returns: the hyperbolic cosine value. */
double sinh(double /*x*/);
float sinhf(float /*x*/);
long double sinhl(long double /*x*/);
   /* computes the hyperbolic sine of x. A range error occurs if the */
   /* magnitude of x is too large. */
   /* Returns: the hyperbolic sine value. */
double tanh(double /*x*/);
float tanhf(float /*x*/);
long double tanhl(long double /*x*/);
   /* computes the hyperbolic tangent of x. */
   /* Returns: the hyperbolic tangent value. */

double exp(double /*x*/);
float expf(float /*x*/);
long double expl(long double /*x*/);
   /* computes the base-e exponential of x. A range error occurs if the */
   /* magnitude of x is too large. */
   /* Returns: e^x */
double exp2(double /*x*/);
float exp2f(float /*x*/);
long double exp2l(long double /*x*/);
   /* computes the base-2 exponential of x. A range error occurs if the */
   /* magnitude of x is too large. */
   /* Returns: 2^x */
double expm1(double /*x*/);
float expm1f(float /*x*/);
long double expm1l(long double /*x*/);
   /* computes the base-e exponential of x, minus 1. A range error occurs if */
   /* the magnitude of x is too large. */
   /* Returns: e^x - 1 */
double frexp(double /*value*/, int * /*exp*/);
float frexpf(float /*value*/, int * /*exp*/);
long double frexpl(long double /*value*/, int * /*exp*/);
   /* breaks a floating-point number into a normalised fraction and an */
   /* integral power of 2. It stores the integer in the int object pointed */
   /* to by exp. */
   /* Returns: the value x, such that x is a double with magnitude in the */
   /* interval [0.5,1.0) or zero, and value equals x times 2 raised to the */
   /* power *exp. If value is zero, both parts of the result are zero. */
int ilogb(double /*x*/);
int ilogbf(float /*x*/);
int ilogbl(long double /*x*/);
   /* extracts the exponent of x as a signed int value. If x is zero it */
   /* computes the value FP_ILOGB0; if x is infinite it computes the value */
   /* INT_MAX; if x is a NaN it computes the value FP_ILOGBNAN; otherwise */
   /* it is equivalent to calling the corresponding logb function and */
   /* casting the returned value to type int. */
   /* Returns: the exponent of x as a signed int value. */
double ldexp(double /*x*/, int /*exp*/);
float ldexpf(float /*x*/, int /*exp*/);
long double ldexpl(long double /*x*/, int /*exp*/);
   /* multiplies a floating-point number by an integral power of 2. */
   /* A range error may occur. */
   /* Returns: the value of x times 2 raised to the power of exp. */
double log(double /*x*/);
float logf(float /*x*/);
long double logl(long double /*x*/);
   /* computes the base-e (natural) logarithm of x. A domain error occurs */
   /* if the argument is negative. A range error occurs if the argument is */
   /* zero. */
   /* Returns: the natural logarithm. */
double log10(double /*x*/);
float log10f(float /*x*/);
long double log10l(long double /*x*/);
   /* computes the base-ten (common) logarithm of x. A domain error occurs */
   /* if the argument is negative. A range error occurs if the argument is */
   /* zero. */
   /* Returns: the base-ten logarithm. */
double log1p(double /*x*/);
float log1pf(float /*x*/);
long double log1pl(long double /*x*/);
   /* computes the base-e (natural) logarithm of 1 plus the argument. A */
   /* domain error occurs if the argument is less than -1. A range error */
   /* occurs if the argument equals -1. */
   /* Returns: the natural logarithm of (1+x). */
double log2(double /*x*/);
float log2f(float /*x*/);
long double log2l(long double /*x*/);
   /* computes the base-two logarithm of x. A domain error occurs if the */
   /* argument is negative. A range error occurs if the argument is zero. */
   /* Returns: the base-two logarithm. */
double logb(double /*x*/);
float logbf(float /*x*/);
long double logbl(long double /*x*/);
   /* extracts the exponent of x, as a signed integer value in floating- */
   /* point format. If x is subnormal it is treated as though it were */
   /* normalised; thus, for positive finite x, */
   /*      1  <=  x * FLT_RADIX ^ -logb(x)  <  FLT_RADIX     */
   /* A range error occurs if the argument is zero. */
   /* Returns: the signed exponent of x */
double modf(double /*value*/, double * /*iptr*/);
float modff(float /*value*/, float * /*iptr*/);
long double modfl(long double /*value*/, long double * /*iptr*/);
   /* breaks the argument value into integral and fraction parts, each of */
   /* which has the same sign as the argument. It stores the integral part */
   /* as a double in the object pointed to by iptr. */
   /* Returns: the signed fractional part of value. */
double scalbn(double /*x*/, int /*n*/);
float scalbnf(float /*x*/, int /*n*/);
long double scalbnl(long double /*x*/, int /*n*/);
double scalbln(double /*x*/, long int /*n*/);
float scalblnf(float /*x*/, long int /*n*/);
long double scalblnl(long double /*x*/, long int /*n*/);
   /* computes x * FLT_RADIX^n efficiently. A range error may occur. */
   /* Returns: x * FLT_RADIX^n */

double cbrt(double /*x*/);
float cbrtf(float /*x*/);
long double cbrtl(long double /*x*/);
   /* computes the real cube root of x. */
   /* Returns: x^(1/3) */
#pragma no_side_effects
double fabs(double /*x*/);
float fabsf(float /*x*/);
long double fabsl(long double /*x*/);
   /* computes the absolute value of the floating-point number x. */
   /* Returns: the absolute value of x. */
#pragma side_effects
double hypot(double /*x*/, double /*y*/);
float hypotf(float /*x*/, float /*y*/);
long double hypotl(long double /*x*/, long double /*y*/);
   /* computes the square root of the sum of the squares of x and y, */
   /* without undue overflow or underflow. A range error may occur. */
   /* Returns: sqrt(x^2 + y^2) */
double pow(double /*x*/, double /*y*/);
float powf(float /*x*/, float /*y*/);
long double powl(long double /*x*/, long double /*y*/);
   /* computes x raised to the power of y. A domain error occurs if x is */
   /* zero and y is less than or equal to zero, or if x is negative and y */
   /* is not an integer. A range error may occur. */
   /* Returns: the value of x raised to the power of y. */
double sqrt(double /*x*/);
float sqrtf(float /*x*/);
long double sqrtl(long double /*x*/);
   /* computes the non-negative square root of x. A domain error occurs */
   /* if the argument is less than zero. */
   /* Returns: the value of the square root. */

double erf(double /*x*/);
float erff(float /*x*/);
long double erfl(long double /*x*/);
   /* computes the error function of x. */
   /* Returns: erf x = 2/sqrt(pi) * integral[0,x] (e^(-t^2)) dt */
double erfc(double /*x*/);
float erfcf(float /*x*/);
long double erfcl(long double /*x*/);
   /* computes the complementary error function of x. A range error occurs */
   /* if x is too large. */
   /* Returns: erfc x = 1 - erf x                                  */
   /*                 = 2/sqrt(pi) * integral[x,inf] (e^(-t^2)) dt */
double lgamma(double /*x*/);
float lgammaf(float /*x*/);
long double lgammal(long double /*x*/);
   /* computes the natural logarithm of the absolute value of gamma of x. */
   /* A range error occurs if x is too large. A range error occurs if x is */
   /* a negative integer or zero. */
   /* Returns: log |Gamma(x)| */
double tgamma(double /*x*/);
float tgammaf(float /*x*/);
long double tgammal(long double /*x*/);
   /* computes the gamma function of x. A domain error occurs if x is a */
   /* negative integer or if the result cannot be represented when x is */
   /* zero. A range error may occur if the magnitude of x is too large or */
   /* too small. */
   /* Returns: Gamma(x) */

double ceil(double /*x*/);
float ceilf(float /*x*/);
long double ceill(long double /*x*/);
   /* computes the smallest integer not less than x. */
   /* Returns: the smallest integer not less than x, expressed as a */
   /* floating-point number. */
double floor(double /*x*/);
float floorf(float /*x*/);
long double floorl(long double /*x*/);
   /* computes the largest integer not greater than x. */
   /* Returns: the largest integer not greater than x, expressed as a */
   /* floating-point number. */
#pragma no_side_effects
double nearbyint(double /*x*/);
float nearbyintf(float /*x*/);
long double nearbyintl(long double /*x*/);
   /* rounds its argument to an integer value, using the current rounding */
   /* direction. Does not raise the inexact exception. */
   /* Returns: the rounded integer value. */
#pragma side_effects
double rint(double /*x*/);
float rintf(float /*x*/);
long double rintl(long double /*x*/);
   /* rounds its argument to an integer value, using the current rounding */
   /* direction. Raises "inexact" if the result differs from the argument. */
   /* Returns: the rounded integer value. */
long int lrint(double /*x*/);
long int lrintf(float /*x*/);
long int lrintl(long double /*x*/);
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ >= 199901
long long int llrint(double /*x*/);
long long int llrintf(float /*x*/);
long long int llrintl(long double /*x*/);
#endif
#endif
   /* rounds its argument to an integer value, using the current rounding */
   /* direction. Raises "inexact" if the result differs from the argument. */
   /* Returns: the rounded integer value. */
#pragma no_side_effects
double round(double /*x*/);
float roundf(float /*x*/);
long double roundl(long double /*x*/);
   /* rounds its argument to the nearest integer value, rounding halfway */
   /* cases away from zero. */
   /* Returns: the rounded integer value. */
#pragma side_effects
long int lround(double /*x*/);
long int lroundf(float /*x*/);
long int lroundl(long double /*x*/);
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ >= 199901
long long int llround(double /*x*/);
long long int llroundf(float /*x*/);
long long int llroundl(long double /*x*/);
#endif
#endif
   /* rounds its argument to the nearest integer value, rounding halfway */
   /* cases away from zero. */
   /* Returns: the rounded integer value. */
double trunc(double /*x*/);
float truncf(float /*x*/);
long double truncl(long double /*x*/);
   /* rounds its argument to the integer value, nearest to but no larger */
   /* in magnitude than the argument. */
   /* Returns: the truncated integer value. */
double fmod(double /*x*/, double /*y*/);
float fmodf(float /*x*/, float /*y*/);
long double fmodl(long double /*x*/, long double /*y*/);
   /* computes the floating-point remainder of x/y. */
   /* Returns: the value x - n * y, for some integer n such that, if y is */
   /*          nonzero, the result has the same sign as x and magnitude */
   /*          less than the magnitude of y. If y is zero, a domain error */
   /*          occurs. */
double remainder(double /*x*/, double /*y*/);
float remainderf(float /*x*/, float /*y*/);
long double remainderl(long double /*x*/, long double /*y*/);
   /* computes the remainder x REM y required by IEEE 754 */
   /* Returns: x REM y */
double remquo(double /*x*/, double /*y*/, int * /*quo*/);
float remquof(float /*x*/, float /*y*/, int * /*quo*/);
long double remquol(long double /*x*/, long double /*y*/, int * /*quo*/);
   /* compute the same remainder as the remainder functions. In the object */
   /* pointed to by quo they store a value whose sign is the sign of x/y */
   /* and whose magnitude is congruent modulo 2^n to the magnitude of the */
   /* integral quotient of x/y, where n is an implementation-defined */
   /* integer greater than or equal to 3 (n=31 under RISC OS) */
   /* Returns: x REM y */

#pragma no_side_effects
double copysign(double /*x*/, double /*y*/);
float copysignf(float /*x*/, float /*y*/);
long double copysignl(long double /*x*/, long double /*y*/);
   /* produce a value with the magnitude of x and the sign of y. They */
   /* produce a NaN (with the sign of y) if x is a NaN. */
   /* Returns: a value with the magnitude of x and the sign of y. */
double nan(const char * /*tagp*/);
float nanf(const char * /*tagp*/);
long double nanl(const char * /*tagp*/);
   /* Returns: a quiet NaN, with content indicated through tagp. */
#pragma side_effects
double nextafter(double /*x*/, double /*y*/);
float nextafterf(float /*x*/, float /*y*/);
long double nextafterl(long double /*x*/, long double /*y*/);
   /* Returns: the next representable value in the specified format after */
   /*          x in the direction of y */
double nexttoward(double /*x*/, long double /*y*/);
float nexttowardf(float /*x*/, long double /*y*/);
long double nexttowardl(long double /*x*/, long double /*y*/);
   /* equivalent to the nextafter functions except that the second */
   /* parameter has type long double. */
double fdim(double /*x*/, double /*y*/);
float fdimf(float /*x*/, float /*y*/);
long double fdiml(long double /*x*/, long double /*y*/);
   /* determine the positive difference between their arguments: */
   /* { x-y if x > y  */
   /* { +0  if x <= y */
   /* A range error may occur. */
   /* Returns: the positive difference value. */
#pragma no_side_effects
double fmax(double /*x*/, double /*y*/);
float fmaxf(float /*x*/, float /*y*/);
long double fmaxl(long double /*x*/, long double /*y*/);
   /* Returns: the maximum numeric value of their arguments. */
double fmin(double /*x*/, double /*y*/);
float fminf(float /*x*/, float /*y*/);
long double fminl(long double /*x*/, long double /*y*/);
   /* Returns: the minimum numeric value of their arguments. */
#pragma side_effects

double fma(double /*x*/, double /*y*/, double /*z*/);
float fmaf(float /*x*/, float /*y*/, float /*z*/);
long double fmal(long double /*x*/, long double /*y*/, long double /*z*/);
   /* computes (x*y)+z, rounded as one ternary operation: it computes */
   /* the value (as if) to infinite precision and rounds once to the */
   /* result format, according to the rounding mode characterised by the */
   /* value of FLT_ROUNDS. */
   /* Returns: (x*y)+z, rounded as one ternary operation. */

#ifndef __cplusplus
#define isgreater(x,y)      ((x) __greater (y))
#define isgreaterequal(x,y) ((x) __greaterequal (y))
#define isless(x,y)         ((x) __less (y))
#define islessequal(x,y)    ((x) __lessequal (y))
#define islessgreater(x,y)  ((x) __lessgreater (y))
#define isunordered(x,y)    ((x) __unordered (y))
   /* quiet (non floating-point exception raising) versions of the */
   /* relational operators, and other comparison macros that facilitate */
   /* writing efficient code that accounts for NaNs without suffering the */
   /* "invalid" floating-point exception. */
#endif

/* Some functions can be safely inlined - appropriate macros defined here. */
/* float ones can't be inlined in C++ because of the odd calling */
/* convention. Some can't be inlined because they won't set errno - in */
/* future they will be inlined in C99 mode, once the real functions are */
/* consistent. Define __MATH_FORCE_INLINING if you don't care about errno */
/* vs exceptions. */
double __d_acos(double);
double __d_asin(double);
double __d_atan(double);
double __d_cos(double);
double __d_sin(double);
double __d_tan(double);
double __d_log(double);
double __d_lg10(double);
double __d_exp(double);
double __d_abs(double);
double __d_sqrt(double);
double __d_floor(double);
double __d_ceil(double);
double __d_trunc(double);
double __d_rint(double);
long int __d_lrint(double);
double __d_rem(double,double);
#ifdef __MATH_FORCE_INLINING
#  if __STDC_VERSION__ >= 199901
#define acos(x) __d_acos(x)
#define asin(x) __d_asin(x)
#define cos(x) __d_cos(x)
#define sin(x) __d_sin(x)
#define tan(x) __d_tan(x)
#define sqrt(x) __d_sqrt(x)
#define log(x) __d_log(x)
#define log10(x) __d_lg10(x)
#define exp(x) __d_exp(x)
#  endif
#endif
#define atan(x) __d_atan(x)
#ifdef __cplusplus
#  define fabs(x) __d_abs(x)
#else
#  define fabs(x) ((void) sizeof (fabs)(x), __abs (double) (x))
#endif
#define floor(x) __d_floor(x)
#define ceil(x) __d_ceil(x)
#define trunc(x) __d_trunc(x)
#define rint(x) __d_rint(x)
#define lrint(x) __d_lrint(x)
#define remainder(x,y) __d_rem(x,y)
#ifndef __cplusplus
__caller_narrow float __r_acos(float);
__caller_narrow float __r_asin(float);
__caller_narrow float __r_atan(float);
__caller_narrow float __r_sin(float);
__caller_narrow float __r_cos(float);
__caller_narrow float __r_tan(float);
__caller_narrow float __r_log(float);
__caller_narrow float __r_lg10(float);
__caller_narrow float __r_exp(float);
__caller_narrow float __r_abs(float);
__caller_narrow float __r_sqrt(float);
__caller_narrow float __r_floor(float);
__caller_narrow float __r_ceil(float);
__caller_narrow float __r_trunc(float);
__caller_narrow float __r_rint(float);
__caller_narrow long int __r_lrint(float);
__caller_narrow float __r_rem(float,float);
__caller_narrow float __r_fma(float,float,float);
#define copysign(x,y) __copysignd(x,y)
#define copysignf(x,y) __copysignf(x,y)
#define acosf(x) __r_acos(x)
#define asinf(x) __r_asin(x)
#define atanf(x) __r_atan(x)
#define sinf(x) __r_sin(x)
#define cosf(x) __r_cos(x)
#define tanf(x) __r_tan(x)
#define sqrtf(x) __r_sqrt(x)
#define logf(x) __r_log(x)
#define log10f(x) __r_lg10(x)
#define expf(x) __r_exp(x)
#define fabsf(x) ((void) sizeof (fabsf)(x), __abs (float) (x))
#define floorf(x) __r_floor(x)
#define ceilf(x) __r_ceil(x)
#define truncf(x) __r_trunc(x)
#define rintf(x) __r_rint(x)
#define lrintf(x) __r_lrint(x)
#define remainderf(x,y) __r_rem(x,y)
#define fmaf(x,y,z) __r_fma(x,y,z)
#endif

#ifdef __cplusplus
}
#endif

#endif

/* end of math.h */
@


4.9
log
@Added run-time and ISO C library support for C99 complex numbers.

Version 5.52. Tagged as 'RISC_OSLib-5_52'
@
text
@d595 5
a599 1
#define fabs(x) ((void) sizeof (fabs)(x), __abs (double) (x))
@


4.8
log
@New abs etc macros in <math.h> and <stdlib.h> made -pcc compatible.

Version 5.50. Tagged as 'RISC_OSLib-5_50'
@
text
@d21 1
a21 1
/* version 0.06 */
d73 1
a73 1
   /* the mutually exclusive kinds of floating-point values for fpclassify() */
d78 1
a78 1
   /* a multiply and an add of float operands. */
d82 2
a83 2
   /* integer constant expressions whose values are returned by ilogb(x) if */
   /* x is zero or NaN, respectively. */
d89 6
a94 6
   /* math_errhandling is not currently provided, as an indication that this */
   /* is in flux. At present, "invalid", "divide-by-zero" and "overflow" */
   /* traps are enabled by default, so to raise these would cause SIGFPE. */
   /* C90 does not allow <math.h> functions to do this, so the functions */
   /* that were present in C90 do not raise these exceptions. They instead */
   /* set errno to EDOM or ERANGE, as required by C90. */
d97 27
a123 9
   /* behaviour does not currently conform to the C99 standard. To avoid the */
   /* traps you can use feholdexcept(). A future C99 version of the library */
   /* will have all traps disabled by default, making these functions */
   /* conforming, and will have new versions of the C90 functions which do */
   /* raise exceptions. Note that some C99 functions may still be using */
   /* errno and DBL_MAX, but this will be changed (even for existing */
   /* clients) by newer Shared C libraries. The original C90 functions will */
   /* not change, to preserve compatibility for older clients. */
   /* See also HUGE_VAL above. */
d194 2
a195 1
   /* signs of both arguments to determine the quadrant of the return value */
d284 3
a286 3
   /* INT_MAX; if x is a NaN it computes the value FP_ILOGBNAN; otherwise it */
   /* is equivalent to calling the corresponding logb function and casting */
   /* the returned value to type int. */
d297 3
a299 2
   /* computes the base-e (natural) logarithm of x. A domain error occurs if */
   /* the argument is negative. A range error occurs if the argument is zero. */
d304 3
a306 2
   /* computes the base-ten (common) logarithm of x. A domain error occurs if */
   /* the argument is negative. A range error occurs if the argument is zero. */
d361 2
a362 2
   /* computes the square root of the sum of the squares of x and y, without */
   /* undue overflow or underflow. A range error may occur. */
d410 2
a411 1
   /* Returns: the smallest integer not less than x, expressed as a double. */
d416 2
a417 1
   /* Returns: the largest integer not greater than x, expressed as a double */
d435 2
d440 2
d456 2
d461 2
d469 2
a470 2
   /* rounds its argument to the integer value, nearest to but no larger in */
   /* magnitude than the argument. */
d489 4
a492 4
   /* pointed to by quo they store a value whose sign is the sign of x/y and */
   /* whose magnitude is congruent modulo 2^n to the magnitude of the */
   /* integral quotient of x/y, where n is an implementation-defined integer */
   /* greater than or equal to 3 (n=31 under RISC OS) */
d515 2
a516 2
   /* equivalent to the nextafter functions except that the second parameter */
   /* has type long double. */
d540 3
a542 3
   /* the value (as if) to infinite precision and rounds once to the result */
   /* format, according to the rounding mode characterised by the value of */
   /* FLT_ROUNDS. */
d559 5
a563 4
/* float ones can't be inlined in C++ because of the odd calling convention */
/* Some can't be inlined because they won't set errno - in future they */
/* will be inlined in C99 mode, once the real functions are consistent. */
/* Define __MATH_FORCE_INLINING if you don't care about errno vs exceptions. */
d573 1
d612 1
@


4.7
log
@<ctype.h> * isblank() added.
          * isprint() now true for non-breaking spaces
<math.h>  * FP_INFINITY corrected to FP_INFINITE
          * fma(), fmal(), llrint(), llrintf(), llrintl(),
            llround(), llroundf(), llroundl(),
            remquo(), remquof(), remquol() added.
          * added inlining for remainder() and fmaf() and various
            float functions.
          * math_errhandling removed pending overhaul - it was misleading.
          * expm1() and log1p() now provide decent (< 1 ulp) accuracy,
            rather than only being marginally better than exp(x)-1 and
            log(1+x).
          * new version of copysign() with standard calling conventions.
          * some C99 functions changed to use infinity/NaNs and exceptions
            for error handling - see comments in header file about the
            changes in progress.
<stdio.h>  * output from %a now correctly rounded
<stdlib.h> * strtof() and strtold() added.
<string.h> * strerror() no longer clears _kernel_last_oserror().

Version 5.49. Tagged as 'RISC_OSLib-5_49'
@
text
@d562 1
a562 1
#define fabs(x) ((void) sizeof fabs(x), __abs (double) (x))
d599 1
a599 1
#define fabsf(x) ((void) sizeof fabsf(x), __abs (float) (x))
@


4.6
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d21 1
a21 1
/* version 0.05 */
d39 12
d55 2
d63 1
a63 1
#define INFINITY 0f_7f800000
d65 1
a65 1
#define NAN      0f_7fc00001
d71 1
a71 1
#define FP_INFINITY  3
d76 6
a81 2
#define FP_ILOGB0    (-0x7fffffff) /* -INT_MAX */
#define FP_ILOGBNAN  (~0x7fffffff) /* INT_MIN */
d88 18
a105 2
#define math_errhandling MATH_ERRNO
   /* <math.h> functions just set errno - no exceptions are raised */
d121 2
d144 1
a144 1
#define isinf(r)      (fpclassify(r) == FP_INFINITY)
a165 1
   /* and -HUGE_VAL is returned. */
a195 1
   /*          if range error; returns HUGE_VAL. */
a220 1
   /*          if range error; returns HUGE_VAL. */
a226 2
   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
   /*          on the sign of the argument */
a238 2
   /*          if underflow range error; 0 is returned. */
   /*          if overflow range error; HUGE_VAL is returned. */
a244 2
   /*          if underflow range error; 0 is returned. */
   /*          if overflow range error; HUGE_VAL is returned. */
d258 1
a258 1
   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
d267 1
a267 1
   /* the returned value to type int. A range error occurs if x is 0. */
a274 1
   /*          if range error; HUGE_VAL is returned. */
d279 1
a279 2
   /* the argument is negative, and -HUGE_VAL is returned. A range error */
   /* occurs if the argument is zero. */
a280 1
   /*          if range error; -HUGE_VAL is returned. */
d307 1
a307 1
   /* A domain error occurs if the argument is zero. */
d311 1
a311 1
long double modfl(long double /*value*/, long double *  /*iptr*/);
d348 1
a348 1
   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
a349 2
   /*          if underflow range error; 0 is returned. */
   /*          if overflow range error; HUGE_VAL is returned. */
d354 1
a354 1
   /* if the argument is negative, and -HUGE_VAL returned. */
d366 1
a366 1
   /* if x is too large.
a384 1
#pragma no_side_effects
d395 1
d402 1
a408 1
#pragma side_effects
d412 3
d429 3
a434 1
#pragma no_side_effects
a440 1
#pragma side_effects
d445 1
a445 1
   /* Returns: the value x - i * y, for some integer i such that, if y is */
d448 1
a448 1
   /*          occurs and -HUGE_VAL is returned. */
d454 9
a464 2
#ifndef __cplusplus
#pragma force_fpargs_in_regs
d466 1
a466 1
__caller_narrow float copysignf(float /*x*/, float /*y*/);
a467 1
#pragma no_force_fpargs_in_regs
a470 1
#endif
d527 7
a533 1
/* Some functions can be safely inlined - appropriate macros defined here */
d537 5
a541 1
double __d_abs(double);
d547 5
a551 2
float __r_abs(float);
#define atan(x) __d_atan(x)
d554 8
d568 1
d570 2
d575 5
d585 6
d594 5
d605 2
@


4.5
log
@Lots of #ifndef __cplusplus added to <math.h>.

Version 5.40. Tagged as 'RISC_OSLib-5_40'
@
text
@d18 1
a18 1
/* math.h: ISO 'C' (9899:1999) library header, section 7.22 */
d21 1
a21 1
/* version 0.04 */
d40 4
d62 5
a72 2
/*#pragma no_side_effects*/

d83 4
a86 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __signbitf(float);
extern int __signbitd(double);
d91 2
a92 2
#define __classmacro(fn,r) (sizeof(r) == 4 ? __##fn##f(r) : \
                                             __##fn##d(r))
d100 2
a101 2
                            ___typeof(r) == 0x402 ? __##fn##f(r) : \
                                                    __##fn##d(r))
d119 3
a121 1
extern double acos(double /*x*/);
d125 3
a127 1
extern double asin(double /*x*/);
d132 3
a134 1
extern double atan(double /*x*/);
d137 3
a139 1
extern double atan2(double /*x*/, double /*y*/);
a141 1
   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
d143 3
a145 9

extern double __d_atan(double);
#define atan(x) __d_atan(x)
#ifndef __cplusplus
extern __caller_narrow float __r_atan(float);
#define atanf(x) __r_atan(x)
#endif

extern double cos(double /*x*/);
d149 3
a151 1
extern double sin(double /*x*/);
d155 3
a157 13

extern double __d_cos(double);
extern double __d_sin(double);
#define cos(x) __d_cos(x)
#define sin(x) __d_sin(x)
#ifndef __cplusplus
extern __caller_narrow float __r_sin(float);
extern __caller_narrow float __r_cos(float);
#define sinf(x) __r_sin(x)
#define cosf(x) __r_cos(x)
#endif

extern double tan(double /*x*/);
d163 21
a183 1
extern double cosh(double /*x*/);
d188 3
a190 1
extern double sinh(double /*x*/);
d196 3
a198 1
extern double tanh(double /*x*/);
d202 12
a213 2
extern double exp(double /*x*/);
   /* computes the exponential function of x. A range error occurs if the */
d215 1
a215 1
   /* Returns: the exponential value. */
d218 9
a226 1
extern double frexp(double /*value*/, int * /*exp*/);
d233 12
a244 1
extern double ldexp(double /*x*/, int /*exp*/);
d249 6
a254 4
extern double log(double /*x*/);
   /* computes the natural logarithm of x. A domain error occurs if the */
   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
   /* if the argument is zero. */
d257 17
a273 2
extern double log10(double /*x*/);
   /* computes the base-ten logarithm of x. A domain error occurs if the */
d275 13
a287 2
   /* Returns: the base-ten logarithm. */
extern double modf(double /*value*/, double * /*iptr*/);
d292 24
a315 3

extern double hypot(double /*x*/, double /*y*/);
extern float hypotf(float /*x*/, float /*y*/);
d317 1
a317 1
   /* undue overflow or underflow. A ronge error may occur. */
d319 3
a321 1
extern double pow(double /*x*/, double /*y*/);
d328 3
a330 1
extern double sqrt(double /*x*/);
d335 32
a366 6
extern double fabs(double /*x*/);
extern float fabsf(float /*x*/);
   /* computes the absolute value of the floating-point number x. */
   /* Returns: the absolute value of x. */
extern double ceil(double /*x*/);
extern float ceilf(float /*x*/);
d369 3
a371 2
extern double floor(double /*x*/);
extern float floorf(float /*x*/);
d374 3
a376 2
extern double nearbyint(double /*x*/);
extern float nearbyintf(float /*x*/);
d380 3
a382 2
extern double rint(double /*x*/);
extern float rintf(float /*x*/);
d386 4
a389 2
extern long int lrint(double /*x*/);
extern long int lrintf(float /*x*/);
d393 4
a396 2
extern double round(double /*x*/);
extern float roundf(float /*x*/);
d400 4
a403 2
extern long int lround(double /*x*/);
extern long int lroundf(float /*x*/);
d407 4
a410 2
extern double trunc(double /*x*/);
extern float truncf(float /*x*/);
d414 4
a417 1
extern double fmod(double /*x*/, double /*y*/);
d423 3
a425 2
extern double remainder(double /*x*/, double /*y*/);
extern float remainderf(float /*x*/, float /*y*/);
d429 1
a429 27
extern double __d_abs(double);
extern double __d_floor(double);
extern double __d_ceil(double);
extern double __d_trunc(double);
extern double __d_rint(double);
extern long int __d_lrint(double);
extern float __r_abs(float);
#define fabs(x) __d_abs(x)
#define floor(x) __d_floor(x)
#define ceil(x) __d_ceil(x)
#define trunc(x) __d_trunc(x)
#define rint(x) __d_rint(x)
#define lrint(x) __d_lrint(x)
#ifndef __cplusplus
extern __caller_narrow float __r_floor(float);
extern __caller_narrow float __r_ceil(float);
extern __caller_narrow float __r_trunc(float);
extern __caller_narrow float __r_rint(float);
extern __caller_narrow long int __r_lrint(float);
#define fabsf(x) __r_abs(x)
#define floorf(x) __r_floor(x)
#define ceilf(x) __r_ceil(x)
#define truncf(x) __r_trunc(x)
#define rintf(x) __r_rint(x)
#define lrintf(x) __r_lrint(x)
#endif

d432 3
a434 2
extern double copysign(double /*x*/, double /*y*/);
extern float copysignf(float /*x*/, float /*y*/);
d440 3
a442 2
extern double nan(const char * /*tagp*/);
extern float nanf(const char * /*tagp*/);
d444 4
a447 2
extern double nextafter(double /*x*/, double /*y*/);
extern float nextafterf(float /*x*/, float /*y*/);
d450 8
a457 2
extern double fdim(double /*x*/, double /*y*/);
extern float fdimf(float /*x*/, float /*y*/);
d463 4
a466 2
extern double fmax(double /*x*/, double /*y*/);
extern float fmaxf(float /*x*/, float /*y*/);
d468 3
a470 2
extern double fmin(double /*x*/, double /*y*/);
extern float fminf(float /*x*/, float /*y*/);
d472 10
d496 40
a538 2

#pragma side_effects
@


4.4
log
@* Added C99 functions floorf, ceilf, [l]rint[f], trunc[f], [l]round[f],
  nearbyint[f] and remainder[f].
* Added macros (only) for sinf, cosf, atanf.
* Requires cc 5.43

Version 5.39. Tagged as 'RISC_OSLib-5_39'
@
text
@d40 1
d56 1
d70 4
d110 2
d131 2
a133 1
#define atan(x) __d_atan(x)
d135 1
d146 1
d148 3
a151 1
extern double __d_cos(double);
a152 1
#define sin(x) __d_sin(x)
a153 1
#define cos(x) __d_cos(x)
d155 1
d289 7
a300 1
#define fabs(x) __d_abs(x)
a301 1
#define floor(x) __d_floor(x)
a302 1
#define ceil(x) __d_ceil(x)
a303 1
#define trunc(x) __d_trunc(x)
a304 1
#define rint(x) __d_rint(x)
a305 1
#define lrint(x) __d_lrint(x)
d307 1
d309 1
d317 1
d339 1
d350 1
@


4.3
log
@* Added C99 extensions to strftime(). All basic specifiers supported, but "E"
  and "O" modifiers ignored.
* strftime specifiers %c, %X and %x for "C" locale changed to match C99.
* Optimised hypot[f].
* Missing hypotf() declaration added to <math.h>.
* Fixed Shared C Library - inadvertent change to static data size meant it was
  incompatible with the stubs.

Version 5.38. Tagged as 'RISC_OSLib-5_38'
@
text
@d18 1
a18 1
/* math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5 */
d21 1
a21 1
/* version 0.03 */
d123 1
d125 1
d137 1
d139 1
d141 1
d143 1
a216 3
extern double ceil(double /*x*/);
   /* computes the smallest integer not less than x. */
   /* Returns: the smallest integer not less than x, expressed as a double. */
d221 6
a226 1
extern double floor(double /*d*/);
d229 30
d265 4
d271 11
a281 1
extern float  __r_abs(float);
d284 10
@


4.2
log
@Added the following C99 features:

  * snprintf(), vsnprintf(), vfscanf(), vscanf(), vsscanf()
  * hh, j, z and t printf length modifiers (indicating char, intmax_t, size_t
    and ptrdiff_t respectively)
  * Hexadecimal floating-point printing and scanning (%a/%A)
  * %F printf() specifier (upper-case form of %F)
  * Input/output of NaNs and Infinities
  * imaxdiv_t, imaxdiv(), strtoimax(), strtoumax() (simulated through macros)
  * <fenv.h>: feclearexcept(), fegetexceptflag(), feraiseexcept(),
              fesetexceptflag(), fetestexcept(), fegetround(), fesetround(),
              fegetenv(), feholdexcept(), fesetenv(), feupdateenv()
  * FLT_EVAL_METHOD, DECIMAL_DIG
  * hypot(), hypotf(), fabsf(), fdim(), fdimf(), fmax(), fmaxf(), fmin(),
    fminf()
  * INFINITY, NAN, fpclassify(), isfinite(), isinf(), isnan(), isnormal(),
    signbit(), copysign(), copysignf(), nan(), nanf(), nextafter(),
    nextafterf() isgreater(), isgreaterequal(), isless(), islessequal(),
    islessgreater(), isunordered()

This involves adding 36 new entries to the stubs. Current versions of the C
library will not fault client programs with such larger stubs, but will fill
in the extra entries with junk. Programs requiring the new functions will have
to RMEnsure this version of the Shared C Library.

This version of the C library has been fixed so that in future, any extra
unknown stubs entries will be filled in with a branch to zero, rather than
corrupted.

Requires cc 5.41 or later, both to build, and to make use of some of the extra
facilities.


Version 5.37. Tagged as 'RISC_OSLib-5_37'
@
text
@d195 1
@


4.1
log
@Initial revision
@
text
@d21 1
a21 1
/* version 0.02 */
d26 4
d40 22
d67 37
d194 4
d214 1
d228 1
d230 40
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.4;
access;
symbols
	RISC_OSLib-5_97:4.4
	RISC_OSLib-5_96:4.4
	RISC_OSLib-5_95:4.4
	RISC_OSLib-5_94:4.4
	RISC_OSLib-5_93:4.4
	RISC_OSLib-5_92:4.4
	RISC_OSLib-5_91:4.4
	RISC_OSLib-5_90:4.4
	RISC_OSLib-5_89:4.4
	RISC_OSLib-5_88:4.4
	RISC_OSLib-5_87:4.4
	RISC_OSLib-5_86-1:4.4
	RISC_OSLib-5_86:4.4
	RISC_OSLib-5_85:4.4
	RISC_OSLib-5_84:4.4
	RISC_OSLib-5_83-2:4.4
	RISC_OSLib-5_83-1:4.4
	RISC_OSLib-5_83:4.4
	RISC_OSLib-5_82:4.4
	RISC_OSLib-5_81:4.4
	RISC_OSLib-5_75-2:4.4
	RISC_OSLib-5_80:4.4
	RISC_OSLib-5_79:4.4
	RISC_OSLib-5_78:4.4
	RISC_OSLib-5_75-1:4.4
	RISC_OSLib-5_77:4.4
	RISC_OSLib-5_76:4.4
	RISC_OSLib-5_75:4.4
	RISC_OSLib-5_74:4.4
	RISC_OSLib-5_73:4.4
	RISC_OSLib-5_72:4.4
	RISC_OSLib-5_71:4.4
	RISC_OSLib-5_70:4.4
	RISC_OSLib-5_69:4.4
	RISC_OSLib-5_68:4.4
	RISC_OSLib-5_67:4.4
	RISC_OSLib-5_66:4.4
	RISC_OSLib-5_65:4.4
	RISC_OSLib-5_64:4.4
	RISC_OSLib-5_63:4.3
	RISC_OSLib-5_62:4.3
	RISC_OSLib-5_61:4.3
	RISC_OSLib-5_60:4.3
	RISC_OSLib-5_59:4.3
	RISC_OSLib-5_58:4.3
	RISC_OSLib-5_57:4.3
	RISC_OSLib-5_56:4.3
	RISC_OSLib-5_55:4.3
	RISC_OSLib-5_54:4.3
	RISC_OSLib-5_53:4.3
	RISC_OSLib-5_52:4.3
	RISC_OSLib-5_51:4.3
	RO_5_07:4.3
	RISC_OSLib-5_50:4.3
	RISC_OSLib-5_49:4.3
	RISC_OSLib-5_46-4_64_2_1:4.2
	NoInlineAsm:4.2.0.2
	RISC_OSLib-5_48:4.2
	RISC_OSLib-5_47:4.2
	RISC_OSLib-5_46:4.2
	RISC_OSLib-5_45:4.1
	RISC_OSLib-5_44:4.1
	RISC_OSLib-5_43:4.1
	RISC_OSLib-5_42:4.1
	RISC_OSLib-5_41:4.1
	RISC_OSLib-5_40:4.1
	RISC_OSLib-5_39:4.1
	RISC_OSLib-5_38:4.1
	RISC_OSLib-5_37:4.1
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2011.10.28.14.23.26;	author bavison;	state Exp;
branches;
next	4.3;
commitid	hIG6j26y6NoxM7Fv;

4.3
date	2004.01.23.19.10.20;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2003.04.15.16.50.25;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.53;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.53;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.52.15;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.50;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.58;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma force_top_level
#pragma include_only_once

/* string.h: ISO 'C' (9899:1999) library header, section 7.21 */
/* Copyright (C) Codemist Ltd. */
/* Copyright (C) Acorn Computers Ltd. 1991, 1992 */
/* version 2.01 */

/*
 * string.h declares one type and several functions, and defines one macro
 * useful for manipulating character arrays and other objects treated as
 * character arrays. Various methods are used for determining the lengths of
 * the arrays, but in all cases a char * or void * argument points to the
 * initial (lowest addresses) character of the array. If an array is written
 * beyond the end of an object, the behaviour is undefined.
 */

#ifndef __string_h
#define __string_h

#ifndef __size_t
#define __size_t 1
typedef unsigned int size_t;   /* from <stddef.h> */
#endif

#ifndef NULL
#  define NULL 0
#endif

#ifdef __cplusplus
#define restrict
extern "C" {
#else
#define restrict __restrict
#endif
char *strcpy(char * restrict /*s1*/, const char * restrict /*s2*/);
   /*
    * copies the string pointed to by s2 (including the terminating nul
    * character) into the array pointed to by s1. If copying takes place
    * between objects that overlap, the behaviour is undefined.
    * Returns: the value of s1.
    */
char *strncpy(char * restrict /*s1*/, const char * restrict /*s2*/,
              size_t /*n*/);
   /*
    * copies not more than n characters (characters that follow a null
    * character are not copied) from the array pointed to by s2 into the array
    * pointed to by s1. If copying takes place between objects that overlap,
    * the behaviour is undefined.
    * Returns: the value of s1.
    */

char *strcat(char * restrict /*s1*/, const char * restrict /*s2*/);
   /*
    * appends a copy of the string pointed to by s2 (including the terminating
    * null character) to the end of the string pointed to by s1. The initial
    * character of s2 overwrites the null character at the end of s1.
    * Returns: the value of s1.
    */
char *strncat(char * restrict /*s1*/, const char * restrict /*s2*/,
              size_t /*n*/);
   /*
    * appends not more than n characters (a null character and characters that
    * follow it are not appended) from the array pointed to by s2 to the end of
    * the string pointed to by s1. The initial character of s2 overwrites the
    * null character at the end of s1. A terminating null character is always
    * appended to the result.
    * Returns: the value of s1.
    */

/*
 * The sign of a nonzero value returned by the comparison functions is
 * determined by the sign of the difference between the values of the first
 * pair of characters (both interpreted as unsigned char) that differ in the
 * objects being compared.
 */

int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/);
   /*
    * compares the first n characters of the object pointed to by s1 to the
    * first n characters of the object pointed to by s2.
    * Returns: an integer greater than, equal to, or less than zero, according
    *          as the object pointed to by s1 is greater than, equal to, or
    *          less than the object pointed to by s2.
    */
int strcmp(const char * /*s1*/, const char * /*s2*/);
   /*
    * compares the string pointed to by s1 to the string pointed to by s2.
    * Returns: an integer greater than, equal to, or less than zero, according
    *          as the string pointed to by s1 is greater than, equal to, or
    *          less than the string pointed to by s2.
    */
int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/);
   /*
    * compares not more than n characters (characters that follow a null
    * character are not compared) from the array pointed to by s1 to the array
    * pointed to by s2.
    * Returns: an integer greater than, equal to, or less than zero, according
    *          as the string pointed to by s1 is greater than, equal to, or
    *          less than the string pointed to by s2.
    */
int strcoll(const char * /*s1*/, const char * /*s2*/);
   /*
    * compares the string pointed to by s1 to the string pointed to by s2, both
    * interpreted as appropriate to the LC_COLLATE category of the current
    * locale.
    * Returns: an integer greater than, equal to, or less than zero, according
    *          as the string pointed to by s1 is greater than, equal to, or
    *          less than the string pointed to by s2 when both are interpreted
    *          as appropriate to the current locale.
    */

size_t strxfrm(char * restrict /*s1*/, const char * restrict /*s2*/,
               size_t /*n*/);
   /*
    * transforms the string pointed to by s2 and places the resulting string
    * into the array pointed to by s1. The transformation function is such that
    * if the strcmp function is applied to two transformed strings, it returns
    * a value greater than, equal to or less than zero, corresponding to the
    * result of the strcoll function applied to the same two original strings.
    * No more than n characters are placed into the resulting array pointed to
    * by s1, including the terminating null character. If n is zero, s1 is
    * permitted to be a null pointer. If copying takes place between objects
    * that overlap, the behaviour is undefined.
    * Returns: The length of the transformed string is returned (not including
    *          the terminating null character). If the value returned is n or
    *          more, the contents of the array pointed to by s1 are
    *          indeterminate.
    */

char *strchr(const char * /*s*/, int /*c*/);
   /*
    * locates the first occurence of c (converted to an char) in the string
    * pointed to by s (including the terminating null character).
    * Returns: a pointer to the located character, or a null pointer if the
    *          character does not occur in the string.
    */
size_t strcspn(const char * /*s1*/, const char * /*s2*/);
   /*
    * computes the length of the initial segment of the string pointed to by s1
    * which consists entirely of characters not from the string pointed to by
    * s2. The terminating null character is not considered part of s2.
    * Returns: the length of the segment.
    */
char *strpbrk(const char * /*s1*/, const char * /*s2*/);
   /*
    * locates the first occurence in the string pointed to by s1 of any
    * character from the string pointed to by s2.
    * Returns: returns a pointer to the character, or a null pointer if no
    *          character form s2 occurs in s1.
    */
char *strrchr(const char * /*s*/, int /*c*/);
   /*
    * locates the last occurence of c (converted to a char) in the string
    * pointed to by s. The terminating null character is considered part of
    * the string.
    * Returns: returns a pointer to the character, or a null pointer if c does
    *          not occur in the string.
    */
size_t strspn(const char * /*s1*/, const char * /*s2*/);
   /*
    * computes the length of the initial segment of the string pointed to by s1
    * which consists entirely of characters from the string pointed to by S2
    * Returns: the length of the segment.
    */
char *strstr(const char * /*s1*/, const char * /*s2*/);
   /*
    * locates the first occurence in the string pointed to by s1 of the
    * sequence of characters (excluding the terminating null character) in the
    * string pointed to by s2.
    * Returns: a pointer to the located string, or a null pointer if the string
    *          is not found.
    */
char *strtok(char * restrict /*s1*/, const char * restrict /*s2*/);
   /*
    * A sequence of calls to the strtok function breaks the string pointed to
    * by s1 into a sequence of tokens, each of which is delimited by a
    * character from the string pointed to by s2. The first call in the
    * sequence has s1 as its first argument, and is followed by calls with a
    * null pointer as their first argument. The separator string pointed to by
    * s2 may be different from call to call.
    * The first call in the sequence searches for the first character that is
    * not contained in the current separator string s2. If no such character
    * is found, then there are no tokens in s1 and the strtok function returns
    * a null pointer. If such a character is found, it is the start of the
    * first token.
    * The strtok function then searches from there for a character that is
    * contained in the current separator string. If no such character is found,
    * the current token extends to the end of the string pointed to by s1, and
    * subsequent searches for a token will fail. If such a character is found,
    * it is overwritten by a null character, which terminates the current
    * token. The strtok function saves a pointer to the following character,
    * from which the next search for a token will start.
    * Each subsequent call, with a null pointer as the value for the first
    * argument, starts searching from the saved pointer and behaves as
    * described above.
    * Returns: pointer to the first character of a token, or a null pointer if
    *          there is no token.
    */

void *memcpy(void * restrict /*s1*/, const void * restrict /*s2*/,
             size_t /*n*/);
   /*
    * copies n characters from the object pointed to by s2 into the object
    * pointed to by s1. If copying takes place between objects that overlap,
    * the behaviour is undefined.
    * Returns: the value of s1.
    */
void *memmove(void * /*s1*/, const void * /*s2*/, size_t /*n*/);
   /*
    * copies n characters from the object pointed to by s2 into the object
    * pointed to by s1. Copying takes place as if the n characters from the
    * object pointed to by s2 are first copied into a temporary array of n
    * characters that does not overlap the objects pointed to by s1 and s2,
    * and then the n characters from the temporary array are copied into the
    * object pointed to by s1.
    * Returns: the value of s1.
    */
void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/);
   /*
    * locates the first occurence of c (converted to an unsigned char) in the
    * initial n characters (each interpreted as unsigned char) of the object
    * pointed to by s.
    * Returns: a pointer to the located character, or a null pointer if the
    *          character does not occur in the object.
    */
void *memset(void * /*s*/, int /*c*/, size_t /*n*/);
   /*
    * copies the value of c (converted to an unsigned char) into each of the
    * first n characters of the object pointed to by s.
    * Returns: the value of s.
    */

char *strerror(int /*errnum*/);
   /*
    * maps the error number in errnum to an error message string.
    * Returns: a pointer to the string, the contents of which are
    *          implementation-defined (under RISC OS the strings
    *          for the given errnums are as follows
    *          0       "No error (errno = 0)"
    *          EDOM    "EDOM - function argument out of range"
    *          ERANGE  "ERANGE - function result not representable"
    *          ESIGNUM "ESIGNUM - illegal signal number to signal() or raise()"
    *          EILSEQ  "EILSEQ - character encoding error"
    *          EOVERFLOW "EOVERFLOW - too large for data structure"
    *          EFBIG   "EFBIG - data written to file lost due to exceeding
    *                  file size limit"
    *          -1      Error message from _kernel_lastoserror(), if any,
    *                  else "unspecified error"
    *          others  "unknown error"
    *          ). The array pointed to shall not be
    *          modified by the program, but may be overwritten by a subsequent
    *          call to the strerror function.
    */
size_t strlen(const char * /*s*/);
   /*
    * computes the length of the string pointed to by s.
    * Returns: the number of characters that precede the terminating null
    *          character.
    */
#ifdef __cplusplus
}
#endif
#undef restrict

#endif

/* end of string.h */
@


4.3
log
@<ctype.h> * isblank() added.
          * isprint() now true for non-breaking spaces
<math.h>  * FP_INFINITY corrected to FP_INFINITE
          * fma(), fmal(), llrint(), llrintf(), llrintl(),
            llround(), llroundf(), llroundl(),
            remquo(), remquof(), remquol() added.
          * added inlining for remainder() and fmaf() and various
            float functions.
          * math_errhandling removed pending overhaul - it was misleading.
          * expm1() and log1p() now provide decent (< 1 ulp) accuracy,
            rather than only being marginally better than exp(x)-1 and
            log(1+x).
          * new version of copysign() with standard calling conventions.
          * some C99 functions changed to use infinity/NaNs and exceptions
            for error handling - see comments in header file about the
            changes in progress.
<stdio.h>  * output from %a now correctly rounded
<stdlib.h> * strtof() and strtold() added.
<string.h> * strerror() no longer clears _kernel_last_oserror().

Version 5.49. Tagged as 'RISC_OSLib-5_49'
@
text
@d258 4
@


4.2
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d21 1
a21 1
/* version 2.00 */
d45 1
d47 2
d50 1
a50 1
char *strcpy(char * /*s1*/, const char * /*s2*/);
d57 2
a58 1
char *strncpy(char * /*s1*/, const char * /*s2*/, size_t /*n*/);
d67 1
a67 1
char *strcat(char * /*s1*/, const char * /*s2*/);
d74 2
a75 1
char *strncat(char * /*s1*/, const char * /*s2*/, size_t /*n*/);
d127 2
a128 1
size_t strxfrm(char * /*s1*/, const char * /*s2*/, size_t /*n*/);
d188 1
a188 1
char *strtok(char * /*s1*/, const char * /*s2*/);
d215 2
a216 1
void *memcpy(void * /*s1*/, const void * /*s2*/, size_t /*n*/);
d244 1
a244 1
    * first n charactes of the object pointed to by s.
d252 2
a253 2
    *          implementation-defined (under RISCOS/Arthur/Brazil the strings
    *          for the given ernums are as follows
d258 3
a260 1
    *          others  "Error code (errno) %d has no associated message"
d274 1
@


4.1
log
@Initial revision
@
text
@d18 1
a18 1
/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
d47 1
a47 1
extern char *strcpy(char * /*s1*/, const char * /*s2*/);
d54 1
a54 1
extern char *strncpy(char * /*s1*/, const char * /*s2*/, size_t /*n*/);
d63 1
a63 1
extern char *strcat(char * /*s1*/, const char * /*s2*/);
d70 1
a70 1
extern char *strncat(char * /*s1*/, const char * /*s2*/, size_t /*n*/);
d87 1
a87 1
extern int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/);
d95 1
a95 1
extern int strcmp(const char * /*s1*/, const char * /*s2*/);
d102 1
a102 1
extern int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/);
d111 1
a111 1
extern int strcoll(const char * /*s1*/, const char * /*s2*/);
d122 1
a122 1
extern size_t strxfrm(char * /*s1*/, const char * /*s2*/, size_t /*n*/);
d139 1
a139 1
extern char *strchr(const char * /*s*/, int /*c*/);
d146 1
a146 1
extern size_t strcspn(const char * /*s1*/, const char * /*s2*/);
d153 1
a153 1
extern char *strpbrk(const char * /*s1*/, const char * /*s2*/);
d160 1
a160 1
extern char *strrchr(const char * /*s*/, int /*c*/);
d168 1
a168 1
extern size_t strspn(const char * /*s1*/, const char * /*s2*/);
d174 1
a174 1
extern char *strstr(const char * /*s1*/, const char * /*s2*/);
d182 1
a182 1
extern char *strtok(char * /*s1*/, const char * /*s2*/);
d209 1
a209 1
extern void *memcpy(void * /*s1*/, const void * /*s2*/, size_t /*n*/);
d216 1
a216 1
extern void *memmove(void * /*s1*/, const void * /*s2*/, size_t /*n*/);
d226 1
a226 1
extern void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/);
d234 1
a234 1
extern void *memset(void * /*s*/, int /*c*/, size_t /*n*/);
d241 1
a241 1
extern char *strerror(int /*errnum*/);
d256 1
a256 1
extern size_t strlen(const char * /*s*/);
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

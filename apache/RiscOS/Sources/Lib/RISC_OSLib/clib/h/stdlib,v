head	4.7;
access;
symbols
	RISC_OSLib-5_97:4.7
	RISC_OSLib-5_96:4.7
	RISC_OSLib-5_95:4.7
	RISC_OSLib-5_94:4.7
	RISC_OSLib-5_93:4.7
	RISC_OSLib-5_92:4.7
	RISC_OSLib-5_91:4.7
	RISC_OSLib-5_90:4.7
	RISC_OSLib-5_89:4.7
	RISC_OSLib-5_88:4.7
	RISC_OSLib-5_87:4.7
	RISC_OSLib-5_86-1:4.7
	RISC_OSLib-5_86:4.7
	RISC_OSLib-5_85:4.7
	RISC_OSLib-5_84:4.7
	RISC_OSLib-5_83-2:4.7
	RISC_OSLib-5_83-1:4.7
	RISC_OSLib-5_83:4.7
	RISC_OSLib-5_82:4.7
	RISC_OSLib-5_81:4.7
	RISC_OSLib-5_75-2:4.7
	RISC_OSLib-5_80:4.7
	RISC_OSLib-5_79:4.7
	RISC_OSLib-5_78:4.7
	RISC_OSLib-5_75-1:4.7
	RISC_OSLib-5_77:4.7
	RISC_OSLib-5_76:4.7
	RISC_OSLib-5_75:4.7
	RISC_OSLib-5_74:4.7
	RISC_OSLib-5_73:4.7
	RISC_OSLib-5_72:4.7
	RISC_OSLib-5_71:4.7
	RISC_OSLib-5_70:4.7
	RISC_OSLib-5_69:4.7
	RISC_OSLib-5_68:4.7
	RISC_OSLib-5_67:4.7
	RISC_OSLib-5_66:4.7
	RISC_OSLib-5_65:4.7
	RISC_OSLib-5_64:4.7
	RISC_OSLib-5_63:4.7
	RISC_OSLib-5_62:4.7
	RISC_OSLib-5_61:4.7
	RISC_OSLib-5_60:4.7
	RISC_OSLib-5_59:4.7
	RISC_OSLib-5_58:4.7
	RISC_OSLib-5_57:4.7
	RISC_OSLib-5_56:4.7
	RISC_OSLib-5_55:4.7
	RISC_OSLib-5_54:4.7
	RISC_OSLib-5_53:4.7
	RISC_OSLib-5_52:4.7
	RISC_OSLib-5_51:4.7
	RO_5_07:4.7
	RISC_OSLib-5_50:4.7
	RISC_OSLib-5_49:4.6
	RISC_OSLib-5_46-4_64_2_1:4.5
	NoInlineAsm:4.5.0.2
	RISC_OSLib-5_48:4.5
	RISC_OSLib-5_47:4.5
	RISC_OSLib-5_46:4.5
	RISC_OSLib-5_45:4.4
	RISC_OSLib-5_44:4.3
	RISC_OSLib-5_43:4.3
	RISC_OSLib-5_42:4.3
	RISC_OSLib-5_41:4.3
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2004.07.01.18.08.30;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2004.01.23.19.10.20;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2003.04.15.16.50.25;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2003.01.17.19.13.00;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2002.05.22.10.45.24;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2002.03.21.14.36.25;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.53;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.53;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.52.14;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.48;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.57;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@New abs etc macros in <math.h> and <stdlib.h> made -pcc compatible.

Version 5.50. Tagged as 'RISC_OSLib-5_50'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma force_top_level
#pragma include_only_once

/* stdlib.h: ISO 'C' (9899:1999) library header, section 7.20 */
/* Copyright (C) Codemist Ltd. */
/* Copyright (C) Acorn Computers Ltd., 1990, 1992 */
/* version 2.05 */

/*
 * stdlib.h declares four types, several general purpose functions,
 * and defines several macros.
 */

#ifndef __stdlib_h
#define __stdlib_h

#ifndef __size_t
#  define __size_t 1
   typedef unsigned int size_t;   /* from <stddef.h> */
#endif

#ifndef __wchar_t
   typedef int wchar_t;           /* from <stddef.h> */
#  define __wchar_t 1
#endif

#ifndef NULL
#  define NULL 0                  /* from <stddef.h> */
#endif

typedef struct div_t { int quot, rem; } div_t;
   /* type of the value returned by the div function. */
typedef struct ldiv_t { long int quot, rem; } ldiv_t;
   /* type of the value returned by the ldiv function. */
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ >= 199901
typedef struct lldiv_t { long long int quot, rem; } lldiv_t;
   /* type of the value returned by the lldiv function. */
#endif
#endif

#ifdef __EXIT_FAILURE
#  define EXIT_FAILURE __EXIT_FAILURE
   /*
    * an integral expression which may be used as an argument to the exit
    * function to return unsuccessful termination status to the host
    * environment.
    */
#else
#  define EXIT_FAILURE 1  /* unixoid */
#endif
#define EXIT_SUCCESS 0
   /*
    * an integral expression which may be used as an argument to the exit
    * function to return successful termination status to the host
    * environment.
    */

#define RAND_MAX 0x7FFFFFFF
   /*
    * an integral constant expression, the value of which is the maximum value
    * returned by the rand function.
    */
#define _ANSI_RAND_MAX 0x7fff /* for the so-called portable version rand() */
   /*
    * an integral constant expression, the value of which is the maximum value
    * returned by the _ANSI_rand function.
    */
#define MB_CUR_MAX 1
   /*
    * a positive integer expression whose value is the maximum number of bytes
    * in a multibyte character for the extended character set specified by the
    * current locale (category LC_CTYPE), and whose value is never greater
    * than MB_LEN_MAX.
    */

#ifdef __cplusplus
#define restrict
extern "C" {
#else
#define restrict __restrict
#endif
double atof(const char * /*nptr*/);
   /*
    * converts the initial part of the string pointed to by nptr to double
    * representation.
    * Returns: the converted value.
    */
int atoi(const char * /*nptr*/);
   /*
    * converts the initial part of the string pointed to by nptr to int
    * representation.
    * Returns: the converted value.
    */
long int atol(const char * /*nptr*/);
   /*
    * converts the initial part of the string pointed to by nptr to long int
    * representation.
    * Returns: the converted value.
    */
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ >= 199901
long long int atoll(const char * /*nptr*/);
   /*
    * converts the initial part of the string pointed to by nptr to long long
    * int representation.
    * Returns: the converted value.
    */
#endif
#endif

double strtod(const char *  restrict /*nptr*/,
                    char ** restrict /*endptr*/);
float strtof(const char *  restrict /*nptr*/,
                   char ** restrict /*endptr*/);
long double strtold(const char *  restrict /*nptr*/,
                          char ** restrict /*endptr*/);
   /*
    * convert the initial part of the string pointed to by nptr to double,
    * float and long double representation, respectively. First they decompose
    * the input string into three parts: an initial, possibly empty, sequence
    * of white-space characters (as specified by the isspace function), a
    * subject sequence resembling a floating point constant or representing an
    * infinity or NaN; and a final string of one or more unrecognised
    * characters, including the terminating null character of the input string.
    * Then they attempt to convert the subject sequence to a floating point
    * number, and return the result. A pointer to the final string is stored
    * in the object pointed to by endptr, provided that endptr is not a null
    * pointer.
    * Returns: the converted value if any. If no conversion could be performed,
    *          zero is returned. If the correct value is outside the range of
    *          representable values, plus or minus HUGE_VAL, HUGE_VALF, or
    *          HUGE_VALL is returned (according to the return type and sign of
    *          the value), and the value of the macro ERANGE is stored in errno.
    *          If the result underflows (ISO Standard, section 7.12.1), the
    *          functions return a value whose magnitude is no greater than the
    *          smallest normalised positive number in the return type, and the
    *          value of the macro ERANGE is stored in errno.
    */
long int strtol(const char *  restrict /*nptr*/,
                      char ** restrict /*endptr*/, int /*base*/);
   /*
    * converts the initial part of the string pointed to by nptr to long int
    * representation. First it decomposes the input string into three parts:
    * an initial, possibly empty, sequence of white-space characters (as
    * specified by the isspace function), a subject sequence resembling an
    * integer represented in some radix determined by the value of base, and a
    * final string of one or more unrecognised characters, including the
    * terminating null character of the input string. Then it attempts to
    * convert the subject sequence to an integer, and returns the result.
    * If the value of base is 0, the expected form of the subject sequence is
    * that of an integer constant (described in ISO Standard, section 6.4.4.1),
    * optionally preceeded by a '+' or '-' sign, but not including an integer
    * suffix. If the value of base is between 2 and 36, the expected form of
    * the subject sequence is a sequence of letters and digits representing an
    * integer with the radix specified by base, optionally preceeded by a plus
    * or minus sign, but not including an integer suffix. The letters from a
    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
    * whose ascribed values are less than that of the base are permitted. If
    * the value of base is 16, the characters 0x or 0X may optionally precede
    * the sequence of letters and digits following the sign if present.
    * A pointer to the final string is stored in the object
    * pointed to by endptr, provided that endptr is not a null pointer.
    * Returns: the converted value if any. If no conversion could be performed,
    *          zero is returned. If the correct value is outside the range of
    *          representable values, LONG_MAX or LONG_MIN is returned
    *          (according to the sign of the value), and the value of the
    *          macro ERANGE is stored in errno.
    */
unsigned long int strtoul(const char *  restrict /*nptr*/,
                                char ** restrict /*endptr*/, int /*base*/);
   /*
    * converts the initial part of the string pointed to by nptr to unsigned
    * long int representation. First it decomposes the input string into three
    * parts: an initial, possibly empty, sequence of white-space characters (as
    * determined by the isspace function), a subject sequence resembling an
    * unsigned integer represented in some radix determined by the value of
    * base, and a final string of one or more unrecognised characters,
    * including the terminating null character of the input string. Then it
    * attempts to convert the subject sequence to an unsigned integer, and
    * returns the result. If the value of base is zero, the expected form of
    * the subject sequence is that of an integer constant (described in ISO
    * Standard, section 6.4.4.1), optionally preceeded by a '+' or '-' sign, but
    * not including an integer suffix. If the value of base is between 2 and
    * 36, the expected form of the subject sequence is a sequence of letters
    * and digits representing an integer with the radix specified by base,
    * optionally preceeded by a '+' or '-' sign, but not including an integer
    * suffix. The letters from a (or A) through z (or Z) stand for the values
    * 10 to 35; only letters whose ascribed values are less than that of the
    * base are permitted. If the value of base is 16, the characters 0x or 0X
    * may optionally precede the sequence of letters and digits following the
    * sign, if present. A pointer to the final string is stored in the object
    * pointed to by endptr, provided that endptr is not a null pointer.
    * Returns: the converted value if any. If no conversion could be performed,
    *          zero is returned. If the correct value is outside the range of
    *          representable values, ULONG_MAX is returned, and the value of the
    *          macro ERANGE is stored in errno.
    */
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ >= 199901
long long int strtoll(const char *  restrict /*nptr*/,
                            char ** restrict /*endptr*/, int /*base*/);
   /*
    * converts the initial part of the string pointed to by nptr to long long
    * int representation. First it decomposes the input string into three parts:
    * an initial, possibly empty, sequence of white-space characters (as
    * specified by the isspace function), a subject sequence resembling an
    * integer represented in some radix determined by the value of base, and a
    * final string of one or more unrecognised characters, including the
    * terminating null character of the input string. Then it attempts to
    * convert the subject sequence to an integer, and returns the result.
    * If the value of base is 0, the expected form of the subject sequence is
    * that of an integer constant (described in ISO Standard, section 6.4.4.1),
    * optionally preceeded by a '+' or '-' sign, but not including an integer
    * suffix. If the value of base is between 2 and 36, the expected form of
    * the subject sequence is a sequence of letters and digits representing an
    * integer with the radix specified by base, optionally preceeded by a plus
    * or minus sign, but not including an integer suffix. The letters from a
    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
    * whose ascribed values are less than that of the base are permitted. If
    * the value of base is 16, the characters 0x or 0X may optionally precede
    * the sequence of letters and digits following the sign if present.
    * A pointer to the final string is stored in the object
    * pointed to by endptr, provided that endptr is not a null pointer.
    * Returns: the converted value if any. If no conversion could be performed,
    *          zero is returned. If the correct value is outside the range of
    *          representable values, LLONG_MAX or LLONG_MIN is returned
    *          (according to the sign of the value), and the value of the
    *          macro ERANGE is stored in errno.
    */
unsigned long long int strtoull(const char *  restrict /*nptr*/,
                                      char ** restrict /*endptr*/,
                                      int /*base*/);
   /*
    * converts the initial part of the string pointed to by nptr to unsigned
    * long long int representation. First it decomposes the input string into
    * three parts: an initial, possibly empty, sequence of white-space
    * characters (as determined by the isspace function), a subject sequence
    * resembling an unsigned integer represented in some radix determined by the
    * value of base, and a final string of one or more unrecognised characters,
    * including the terminating null character of the input string. Then it
    * attempts to convert the subject sequence to an unsigned integer, and
    * returns the result. If the value of base is zero, the expected form of
    * the subject sequence is that of an integer constant (described in ISO
    * Standard, section 6.4.4.1), optionally preceeded by a '+' or '-' sign, but
    * not including an integer suffix. If the value of base is between 2 and
    * 36, the expected form of the subject sequence is a sequence of letters
    * and digits representing an integer with the radix specified by base,
    * optionally preceeded by a '+' or '-' sign, but not including an integer
    * suffix. The letters from a (or A) through z (or Z) stand for the values
    * 10 to 35; only letters whose ascribed values are less than that of the
    * base are permitted. If the value of base is 16, the characters 0x or 0X
    * may optionally precede the sequence of letters and digits following the
    * sign, if present. A pointer to the final string is stored in the object
    * pointed to by endptr, provided that endptr is not a null pointer.
    * Returns: the converted value if any. If no conversion could be performed,
    *          zero is returned. If the correct value is outside the range of
    *          representable values, ULLONG_MAX is returned, and the value of
    *          the macro ERANGE is stored in errno.
    */
#endif
#endif

int rand(void);
   /*
    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
    * Uses an additive generator (Mitchell & Moore) of the form:
    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
    * This is described in section 3.2.2 of Knuth, vol 2. Its period is
    * in excess of 2^55 and its randomness properties, though unproven, are
    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
    * Returns: a pseudo-random integer.
    */
void srand(unsigned int /*seed*/);
   /*
    * uses its argument as a seed for a new sequence of pseudo-random numbers
    * to be returned by subsequent calls to rand. If srand is then called with
    * the same seed value, the sequence of pseudo-random numbers is repeated.
    * If rand is called before any calls to srand have been made, the same
    * sequence is generated as when srand is first called with a seed value
    * of 1.
    */
int _ANSI_rand(void);
   /*
    * The ANSI-defined 16-bit random number generator which computes
    * a sequence of pseudo-random integers in the range 0 to _ANSI_RAND_MAX.
    * Its properties are poor, though it IS very portable.
    * *** NOT AVAILABLE IN THE SHARED C LIBRARY ***
    * Returns: a pseudo-random integer.
    */
void _ANSI_srand(unsigned int /*seed*/);
   /*
    * Uses its argument as a seed for a new sequence of pseudo-random numbers
    * to be returned by subsequent calls to _ANSI_rand. If _ANSI_srand is then
    * called with the same seed value, the sequence of pseudo-random numbers
    * is repeated. If _ANSI_rand is called before any calls to _ANSI_srand have
    * been made, the same sequence is generated as when _ANSI_srand is first
    * called with a seed value of 1.
    * *** NOT AVAILABLE IN THE SHARED C LIBRARY ***
    */

#ifdef __cplusplus
#ifndef __malloc_h
#define __malloc_h

typedef char *malloc_t;

char *calloc(size_t /*nmemb*/, size_t /*size*/);
void free(void * /*ptr*/);
char *malloc(size_t /*size*/);
char *realloc(void * /*ptr*/, size_t /*size*/);
#endif
#else
void *calloc(size_t /*nmemb*/, size_t /*size*/);
   /*
    * allocates space for an array of nmemb objects, each of whose size is
    * 'size'. The space is initialised to all bits zero.
    * Returns: either a null pointer or a pointer to the allocated space.
    */
void free(void * /*ptr*/);
   /*
    * causes the space pointed to by ptr to be deallocated (i.e., made
    * available for further allocation). If ptr is a null pointer, no action
    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
    * calloc, malloc or realloc or if the space has been deallocated by a call
    * to free or realloc, the behaviour is undefined.
    */
void *malloc(size_t /*size*/);
   /*
    * allocates space for an object whose size is specified by 'size' and whose
    * value is indeterminate.
    * Returns: either a null pointer or a pointer to the allocated space.
    */
void *realloc(void * /*ptr*/, size_t /*size*/);
   /*
    * changes the size of the object pointed to by ptr to the size specified by
    * size. The contents of the object shall be unchanged up to the lesser of
    * the new and old sizes. If the new size is larger, the value of the newly
    * allocated portion of the object is indeterminate. If ptr is a null
    * pointer, the realloc function behaves like a call to malloc for the
    * specified size. Otherwise, if ptr does not match a pointer earlier
    * returned by calloc, malloc or realloc, or if the space has been
    * deallocated by a call to free or realloc, the behaviour is undefined.
    * If the space cannot be allocated, the object pointed to by ptr is
    * unchanged. If size is zero and ptr is not a null pointer, the object it
    * points to is freed.
    * Returns: either a null pointer or a pointer to the possibly moved
    *          allocated space.
    */
#endif

void abort(void);
   /*
    * causes abnormal program termination to occur, unless the signal SIGABRT
    * is being caught and the signal handler does not return. Whether open
    * output streams are flushed or open streams are closed or temporary files
    * removed is implementation-defined (under RISC OS all these occur).
    * An implementation-defined form of the status 'unsuccessful termination'
    * (1 under RISC OS) is returned to the host environment by means of a call
    * to raise(SIGABRT).
    */
int atexit(void (* /*func*/)(void));
   /*
    * registers the function pointed to by func, to be called without its
    * arguments at normal program termination. It is possible to register at
    * least 32 functions.
    * Returns: zero if the registration succeeds, nonzero if it fails.
    */

void exit(int /*status*/);
   /*
    * causes normal program termination to occur. If more than one call to the
    * exit function is executed by a program, the behaviour is undefined.
    * First, all functions registered by the atexit function are called, in the
    * reverse order of their registration.
    * Next, all open output streams are flushed, all open streams are closed,
    * and all files created by the tmpfile function are removed.
    * Finally, control is returned to the host environment. If the value of
    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
    * status 'successful termination' (0 under RISC OS) is returned. If the
    * value of status is EXIT_FAILURE, an implementation-defined form of the
    * status 'unsuccessful termination' (1 under RISC OS) is returned.
    * Otherwise the status returned is implementation-defined (the value of
    * status is returned under RISC OS).
    */

void _Exit(int /*status*/);
   /*
    * causes normal program termination to occur and control to be returned to
    * the host environment. No functions registered by the atexit function or
    * signal handlers registered by the signal function are called.
    * The status returned to the host environment is determined in the same
    * way as for the exit function.
    * Whether open streams with unwritten buffered data are flushed, open
    * streams are closed or temporary files are removed is implementation-
    * defined (under RISC OS all these occur).
    */

char *getenv(const char * /*name*/);
   /*
    * searches the environment list, provided by the host environment, for a
    * string that matches the string pointed to by name. The set of environment
    * names and the method for altering the environment list are
    * implementation-defined.
    * Returns: a pointer to a string associated with the matched list member.
    *          The array pointed to shall not be modified by the program, but
    *          may be overwritten by a subsequent call to the getenv function.
    *          If the specified name cannot be found, a null pointer is
    *          returned.
    */
int  system(const char * /*string*/);
   /*
    * passes the string pointed to by string to the host environment to be
    * executed by a command processor in an implementation-defined manner.
    * A null pointer may be used for string, to inquire whether a command
    * processor exists.
    *
    * Under RISC OS care must be taken when executing a command, that the
    * command does not overwrite the calling program. The string 'chain:' or
    * 'call:' may immediately precede the actual command. The effect of 'call:'
    * is the same as if 'call:' were not present, which is to attempt to return
    * to the calling program. The effect of 'chain:' is to make no attempt to
    * return to the calling program, but an attempt is made to call exit.
    *
    * Returns: If the argument is a null pointer, the system function returns
    *          non-zero only if a command processor is available. If the
    *          argument is not a null pointer, the system function returns an
    *          implementation-defined value (under RISC OS 0 is returned
    *          for success, -2 for failure to invoke the command and any other
    *          value is the return code from the executed command).
    */

void *bsearch(const void * /*key*/, const void * /*base*/,
              size_t /*nmemb*/, size_t /*size*/,
              int (* /*compar*/)(const void *, const void *));
   /*
    * searches an array of nmemb objects, the initial member of which is
    * pointed to by base, for a member that matches the object pointed to by
    * key. The size of each member of the array is specified by size.
    * The contents of the array shall be in ascending sorted order according to
    * a comparison function pointed to by compar, which is called with two
    * arguments that point to the key object and to an array member, in that
    * order. The function shall return an integer less than, equal to, or
    * greater than zero if the key object is considered, respectively, to be
    * less than, to match, or to be greater than the array member.
    * Returns: a pointer to a matching member of the array, or a null pointer
    *          if no match is found. If two members compare as equal, which
    *          member is matched is unspecified.
    */
void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
           int (* /*compar*/)(const void *, const void *));
   /*
    * sorts an array of nmemb objects, the initial member of which is pointed
    * to by base. The size of each object is specified by size.
    * The contents of the array shall be in ascending order according to a
    * comparison function pointed to by compar, which is called with two
    * arguments that point to the objects being compared. The function shall
    * return an integer less than, equal to, or greater than zero if the first
    * argument is considered to be respectively less than, equal to, or greater
    * than the second. If two members compare as equal, their order in the
    * sorted array is unspecified.
    */

int abs(int /*j*/);
   /*
    * computes the absolute value of an integer j. If the result cannot be
    * represented, the behaviour is undefined.
    * Returns: the absolute value.
    */
div_t div(int /*numer*/, int /*denom*/);
   /*
    * computes numer / denom and numer % denom in a single operation.
    * Returns: a structure of type div_t, comprising both the quotient and the
    *          remainder.
    */
long int labs(long int /*j*/);
   /*
    * computes the absolute value of an integer j. If the result cannot be
    * represented, the behaviour is undefined.
    * Returns: the absolute value.
    */
ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
   /*
    * computes numer / denom and numer % denom in a single operation.
    * Returns: a structure of type ldiv_t, comprising both the quotient and the
    *          remainder.
    */
#ifdef __STDC_VERSION__
#if __STDC_VERSION__ >= 199901
long long int llabs(long long int /*j*/);
   /*
    * computes the absolute value of an integer j. If the result cannot be
    * represented, the behaviour is undefined.
    * Returns: the absolute value.
    */
lldiv_t lldiv(long long int /*numer*/, long long int /*denom*/);
   /*
    * computes numer / denom and numer % denom in a single operation.
    * Returns: a structure of type lldiv_t, comprising both the quotient and the
    *          remainder.
    */
#endif
#endif

#ifndef __cplusplus
/* the sizeof expression performs the necessary type-checking */
#define abs(j)  ((void) sizeof (abs)(j), __abs (int) (j))
#define labs(j) ((void) sizeof (labs)(j), __abs (long int) (j))
#endif

/*
 * Multibyte Character Functions.
 * The behaviour of the multibyte character functions is affected by the
 * LC_CTYPE category of the current locale. For a state-dependent encoding,
 * each function is placed into its initial state by a call for which its
 * character pointer argument, s, is a null pointer. Subsequent calls with s
 * as other than a null pointer cause the internal state of the function to be
 * altered as necessary. A call with s as a null pointer causes these functions
 * to return a nonzero value if encodings have state dependency, and a zero
 * otherwise. After the LC_CTYPE category is changed, the shift state of these
 * functions is indeterminate.
 */
int mblen(const char * /*s*/, size_t /*n*/);
   /*
    * If s is not a null pointer, the mblen function determines the number of
    * bytes compromising the multibyte character pointed to by s. Except that
    * the shift state of the mbtowc function is not affected, it is equivalent
    * to   mbtowc((wchar_t *)0, s, n);
    * Returns: If s is a null pointer, the mblen function returns a nonzero or
    *          zero value, if multibyte character encodings, resepectively, do
    *          or do not have state-dependent encodings. If s is not a null
    *          pointer, the mblen function either returns a 0 (if s points to a
    *          null character), or returns the number of bytes that compromise
    *          the multibyte character (if the next n of fewer bytes form a
    *          valid multibyte character), or returns -1 (they do not form a
    *          valid multibyte character).
    */
int mbtowc(wchar_t * restrict /*pwc*/, const char * restrict /*s*/,
           size_t /*n*/);
   /*
    * If s is not a null pointer, the mbtowc function determines the number of
    * bytes that compromise the multibyte character pointed to by s. It then
    * determines the code for value of type wchar_t that corresponds to that
    * multibyte character. (The value of the code corresponding to the null
    * character is zero). If the multibyte character is valid and pwc is not a
    * null pointer, the mbtowc function stores the code in the object pointed
    * to by pwc. At most n bytes of the array pointed to by s will be examined.
    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
    *          zero value, if multibyte character encodings, resepectively, do
    *          or do not have state-dependent encodings. If s is not a null
    *          pointer, the mbtowc function either returns a 0 (if s points to
    *          a null character), or returns the number of bytes that
    *          compromise the converted multibyte character (if the next n of
    *          fewer bytes form a valid multibyte character), or returns -1
    *          (they do not form a valid multibyte character).
    */
int wctomb(char * /*s*/, wchar_t /*wchar*/);
   /*
    * determines the number of bytes need to represent the multibyte character
    * corresponding to the code whose value is wchar (including any change in
    * shift state). It stores the multibyte character representation in the
    * array object pointed to by s (if s is not a null pointer). At most
    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
    * wctomb function is left in the initial shift state).
    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
    *          zero value, if multibyte character encodings, resepectively, do
    *          or do not have state-dependent encodings. If s is not a null
    *          pointer, the wctomb function returns a -1 if the value of wchar
    *          does not correspond to a valid multibyte character, or returns
    *          the number of bytes that compromise the multibyte character
    *          corresponding to the value of wchar.
    */

/*
 * Multibyte String Functions.
 * The behaviour of the multibyte string functions is affected by the LC_CTYPE
 * category of the current locale.
 */
size_t mbstowcs(wchar_t * restrict /*pwcs*/, const char * restrict /*s*/,
                size_t /*n*/);
   /*
    * converts a sequence of multibyte character that begins in the initial
    * shift state from the array pointed to by s into a sequence of
    * corresponding codes and stores not more than n codes into the array
    * pointed to by pwcs. No multibyte character that follow a null character
    * (which is converted into a code with value zero) will be examined or
    * converted. Each multibyte character is converted as if by a call to
    * mbtowc function, except that the shift state of the mbtowc function is
    * not affected. No more than n elements will be modified in the array
    * pointed to by pwcs. If copying takes place between objects that overlap,
    * the behaviour is undefined.
    * Returns: If an invalid multibyte character is encountered, the mbstowcs
    *          function returns (size_t)-1. Otherwise, the mbstowcs function
    *          returns the number of array elements modified, not including
    *          a terminating zero code, if any.
    */
size_t wcstombs(char * restrict /*s*/, const wchar_t * restrict /*pwcs*/,
                size_t /*n*/);
   /*
    * converts a sequence of codes that correspond to multibyte characters
    * from the array pointed to by pwcs into a sequence of multibyte
    * characters that begins in the initial shift state and stores these
    * multibyte characters into the array pointed to by s, stopping if a
    * multibyte character would exceed the limit of n total bytes or if a
    * null character is stored. Each code is converted as if by a call to the
    * wctomb function, except that the shift state of the wctomb function is
    * not affected. No more than n elements will be modified in the array
    * pointed to by s. If copying takes place between objects that overlap,
    * the behaviour is undefined.
    * Returns: If a code is encountered that does not correspond to a valid
    *          multibyte character, the wcstombs function returns (size_t)-1.
    *          Otherwise, the wcstombs function returns the number of bytes
    *          modified, not including a terminating null character, if any.
    */
#ifdef __cplusplus
}
#endif
#undef restrict

#endif

/* end of stdlib.h */
@


4.6
log
@<ctype.h> * isblank() added.
          * isprint() now true for non-breaking spaces
<math.h>  * FP_INFINITY corrected to FP_INFINITE
          * fma(), fmal(), llrint(), llrintf(), llrintl(),
            llround(), llroundf(), llroundl(),
            remquo(), remquof(), remquol() added.
          * added inlining for remainder() and fmaf() and various
            float functions.
          * math_errhandling removed pending overhaul - it was misleading.
          * expm1() and log1p() now provide decent (< 1 ulp) accuracy,
            rather than only being marginally better than exp(x)-1 and
            log(1+x).
          * new version of copysign() with standard calling conventions.
          * some C99 functions changed to use infinity/NaNs and exceptions
            for error handling - see comments in header file about the
            changes in progress.
<stdio.h>  * output from %a now correctly rounded
<stdlib.h> * strtof() and strtold() added.
<string.h> * strerror() no longer clears _kernel_last_oserror().

Version 5.49. Tagged as 'RISC_OSLib-5_49'
@
text
@d521 2
a522 2
#define abs(j)  ((void) sizeof abs(j), __abs (int) (j))
#define labs(j) ((void) sizeof labs(j), __abs (long int) (j))
@


4.5
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d21 1
a21 1
/* version 2.03 */
d73 1
a73 1
#define RAND_MAX 0x7fffffff
d92 1
d94 2
d126 13
a138 7
double strtod(const char * /*nptr*/, char ** /*endptr*/);
   /*
    * converts the initial part of the string pointed to by nptr to double
    * representation. First it decomposes the input string into three parts:
    * an initial, possibly empty, sequence of white-space characters (as
    * specified by the isspace function), a subject sequence resembling a
    * floating point constant; and a final string of one or more unrecognised
d140 2
a141 2
    * Then it attempts to convert the subject sequence to a floating point
    * number, and returns the result. A pointer to the final string is stored
d146 7
a152 5
    *          representable values, plus or minus HUGE_VAL is returned
    *          (according to the sign of the value), and the value of the macro
    *          ERANGE is stored in errno. If the correct value would cause
    *          underflow, zero is returned and the value of the macro ERANGE is
    *          stored in errno.
d154 2
a155 1
long int strtol(const char * /*nptr*/, char **/*endptr*/, int /*base*/);
d184 2
a185 2
unsigned long int strtoul(const char * /*nptr*/,
                                char ** /*endptr*/, int /*base*/);
d215 1
a215 1
long long int strtoll(const char * restrict /*nptr*/,
d245 1
a245 1
unsigned long long int strtoull(const char * restrict /*nptr*/,
d552 2
a553 1
int mbtowc(wchar_t * /*pwc*/, const char * /*s*/, size_t /*n*/);
d593 2
a594 1
size_t mbstowcs(wchar_t * /*pwcs*/, const char * /*s*/, size_t /*n*/);
d611 2
a612 1
size_t wcstombs(char * /*s*/, const wchar_t * /*pwcs*/, size_t /*n*/);
d632 1
@


4.4
log
@Added atoll, strtoll, strtoull, strtoimax, strtoumax, imaxabs and imaxdiv
functions to the standard C library.

Version 5.45. Tagged as 'RISC_OSLib-5_45'
@
text
@d21 1
a21 1
/* version 2.01 */
d94 1
a94 1
extern double atof(const char * /*nptr*/);
d100 1
a100 1
extern int atoi(const char * /*nptr*/);
d106 1
a106 1
extern long int atol(const char * /*nptr*/);
d114 1
a114 1
extern long long int atoll(const char * /*nptr*/);
d123 1
a123 1
extern double strtod(const char * /*nptr*/, char ** /*endptr*/);
d143 1
a143 1
extern long int strtol(const char * /*nptr*/, char **/*endptr*/, int /*base*/);
d172 2
a173 2
extern unsigned long int strtoul(const char * /*nptr*/,
                                       char ** /*endptr*/, int /*base*/);
d203 2
a204 2
extern long long int strtoll(const char * restrict /*nptr*/,
                                   char ** restrict /*endptr*/, int /*base*/);
d233 3
a235 3
extern unsigned long long int strtoull(const char * restrict /*nptr*/,
                                             char ** restrict /*endptr*/,
                                             int /*base*/);
d266 1
a266 1
extern int rand(void);
d276 1
a276 1
extern void srand(unsigned int /*seed*/);
d285 1
a285 1
extern int _ANSI_rand(void);
d293 1
a293 1
extern void _ANSI_srand(unsigned int /*seed*/);
d310 4
a313 4
extern char *calloc(size_t /*nmemb*/, size_t /*size*/);
extern void free(void * /*ptr*/);
extern char *malloc(size_t /*size*/);
extern char *realloc(void * /*ptr*/, size_t /*size*/);
d316 1
a316 1
extern void *calloc(size_t /*nmemb*/, size_t /*size*/);
d322 1
a322 1
extern void free(void * /*ptr*/);
d330 1
a330 1
extern void *malloc(size_t /*size*/);
d336 1
a336 1
extern void *realloc(void * /*ptr*/, size_t /*size*/);
d354 1
a354 1
extern void abort(void);
d359 1
a359 1
    * removed is implementation-defined (under Arthur/Brazil all these occur).
d361 2
a362 2
    * (1 under Arthur/Brazil) is returned to the host environment by means
    * of a call to raise(SIGABRT).
d364 1
a364 1
extern int atexit(void (* /*func*/)(void));
d372 1
a372 1
extern void exit(int status);
d382 17
a398 5
    * status 'successful termination' (0 under Arthur/Brazil) is returned. If
    * the value of status is EXIT_FAILURE, an implementation-defined form of
    * the status 'unsuccessful termination' (1 under Arthur/Brazil) is
    * returned. Otherwise the status returned is implementation-defined (the
    * value of status is returned under Arthur/Brazil).
d401 1
a401 1
extern char *getenv(const char * /*name*/);
d413 1
a413 1
extern int  system(const char * /*string*/);
d420 1
a420 1
    * Under Arthur/Brazil care must be taken when executing a command, that the
d430 1
a430 1
    *          implementation-defined value (under Arthur/Brazil 0 is returned
d435 1
a435 1
extern void *bsearch(const void * /*key*/, const void * /*base*/,
d452 1
a452 1
extern void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
d466 1
a466 1
extern int abs(int /*j*/);
d472 1
a472 1
extern div_t div(int /*numer*/, int /*denom*/);
d478 1
a478 1
extern long int labs(long int /*j*/);
d484 1
a484 1
extern ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
d492 1
a492 1
extern long long int llabs(long long int /*j*/);
d498 1
a498 1
extern lldiv_t lldiv(long long int /*numer*/, long long int /*denom*/);
d507 6
d525 1
a525 1
extern int mblen(const char * /*s*/, size_t /*n*/);
d540 1
a540 1
extern int mbtowc(wchar_t * /*pwc*/, const char * /*s*/, size_t /*n*/);
d558 1
a558 1
extern int wctomb(char * /*s*/, wchar_t /*wchar*/);
d580 1
a580 1
extern size_t mbstowcs(wchar_t * /*pwcs*/, const char * /*s*/, size_t /*n*/);
d597 1
a597 1
extern size_t wcstombs(char * /*s*/, const wchar_t * /*pwcs*/, size_t /*n*/);
@


4.3
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@d21 1
a21 1
/* version 2.00 */
d112 10
d154 1
a154 1
    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
d184 2
a185 2
    * the subject sequence is that of an integer constant (described in ANSI
    * Draft, section 3.1.3.2), optionally preceeded by a '+' or '-' sign, but
d201 64
d271 1
a271 1
    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
d423 1
a423 1
extern void *bsearch(const void *key, const void * /*base*/,
d475 1
a475 1
    * Returns: a structure of type div_t, comprising both the quotient and the
d479 1
a479 1
#if __STDC_VERSION__ > 199901
d489 1
a489 1
    * Returns: a structure of type div_t, comprising both the quotient and the
@


4.2
log
@Added the following C99 features:

  * snprintf(), vsnprintf(), vfscanf(), vscanf(), vsscanf()
  * hh, j, z and t printf length modifiers (indicating char, intmax_t, size_t
    and ptrdiff_t respectively)
  * Hexadecimal floating-point printing and scanning (%a/%A)
  * %F printf() specifier (upper-case form of %F)
  * Input/output of NaNs and Infinities
  * imaxdiv_t, imaxdiv(), strtoimax(), strtoumax() (simulated through macros)
  * <fenv.h>: feclearexcept(), fegetexceptflag(), feraiseexcept(),
              fesetexceptflag(), fetestexcept(), fegetround(), fesetround(),
              fegetenv(), feholdexcept(), fesetenv(), feupdateenv()
  * FLT_EVAL_METHOD, DECIMAL_DIG
  * hypot(), hypotf(), fabsf(), fdim(), fdimf(), fmax(), fmaxf(), fmin(),
    fminf()
  * INFINITY, NAN, fpclassify(), isfinite(), isinf(), isnan(), isnormal(),
    signbit(), copysign(), copysignf(), nan(), nanf(), nextafter(),
    nextafterf() isgreater(), isgreaterequal(), isless(), islessequal(),
    islessgreater(), isunordered()

This involves adding 36 new entries to the stubs. Current versions of the C
library will not fault client programs with such larger stubs, but will fill
in the extra entries with junk. Programs requiring the new functions will have
to RMEnsure this version of the Shared C Library.

This version of the C library has been fixed so that in future, any extra
unknown stubs entries will be filled in with a branch to zero, rather than
corrupted.

Requires cc 5.41 or later, both to build, and to make use of some of the extra
facilities.


Version 5.37. Tagged as 'RISC_OSLib-5_37'
@
text
@d18 1
a18 1
/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
a44 2
#ifndef __div_t
#  define __div_t 1
a46 1
#endif
d49 6
d388 1
a388 5
    * computes the quotient and remainder of the division of the numerator
    * numer by the denominator denom. If the division is inexact, the resulting
    * quotient is the integer of lesser magnitude that is the nearest to the
    * algebraic quotient. If the result cannot be represented, the behaviour is
    * undefined; otherwise, quot * demon + rem shall equal numer.
d390 1
a390 3
    *          remainder. the structure shall contain the following members,
    *          in either order.
    *          int quot; int rem;
d394 1
a394 1
    * computes the absolute value of an long integer j. If the result cannot be
d400 3
a402 11
    * computes the quotient and remainder of the division of the numerator
    * numer by the denominator denom. If the division is inexact, the sign of
    * the resulting quotient is that of the algebraic quotient, and the
    * magnitude of the resulting quotient is the largest integer less than the
    * magnitude of the algebraic quotient. If the result cannot be represented,
    * the behaviour is undefined; otherwise, quot * demon + rem shall equal
    * numer.
    * Returns: a structure of type ldiv_t, comprising both the quotient and the
    *          remainder. the structure shall contain the following members,
    *          in either order.
    *          long int quot; long int rem;
d404 16
@


4.1
log
@Initial revision
@
text
@d45 2
d49 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

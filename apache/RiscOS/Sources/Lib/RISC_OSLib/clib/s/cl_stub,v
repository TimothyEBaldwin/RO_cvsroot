head	4.13;
access;
symbols
	RISC_OSLib-5_97:4.13
	RISC_OSLib-5_96:4.13
	RISC_OSLib-5_95:4.13
	RISC_OSLib-5_94:4.13
	RISC_OSLib-5_93:4.13
	RISC_OSLib-5_92:4.13
	RISC_OSLib-5_91:4.13
	RISC_OSLib-5_90:4.13
	RISC_OSLib-5_89:4.13
	RISC_OSLib-5_88:4.13
	RISC_OSLib-5_87:4.13
	RISC_OSLib-5_86-1:4.13
	RISC_OSLib-5_86:4.13
	RISC_OSLib-5_85:4.13
	RISC_OSLib-5_84:4.13
	RISC_OSLib-5_83-2:4.13
	RISC_OSLib-5_83-1:4.13
	RISC_OSLib-5_83:4.13
	RISC_OSLib-5_82:4.13
	RISC_OSLib-5_81:4.13
	RISC_OSLib-5_75-2:4.13
	RISC_OSLib-5_80:4.13
	RISC_OSLib-5_79:4.13
	RISC_OSLib-5_78:4.13
	RISC_OSLib-5_75-1:4.13
	RISC_OSLib-5_77:4.13
	RISC_OSLib-5_76:4.13
	RISC_OSLib-5_75:4.13
	RISC_OSLib-5_74:4.13
	RISC_OSLib-5_73:4.13
	RISC_OSLib-5_72:4.13
	RISC_OSLib-5_71:4.13
	RISC_OSLib-5_70:4.13
	RISC_OSLib-5_69:4.13
	RISC_OSLib-5_68:4.13
	RISC_OSLib-5_67:4.13
	RISC_OSLib-5_66:4.13
	RISC_OSLib-5_65:4.13
	RISC_OSLib-5_64:4.13
	RISC_OSLib-5_63:4.11
	RISC_OSLib-5_62:4.11
	RISC_OSLib-5_61:4.11
	RISC_OSLib-5_60:4.11
	RISC_OSLib-5_59:4.10
	RISC_OSLib-5_58:4.10
	RISC_OSLib-5_57:4.10
	RISC_OSLib-5_56:4.10
	RISC_OSLib-5_55:4.10
	RISC_OSLib-5_54:4.10
	RISC_OSLib-5_53:4.9
	RISC_OSLib-5_52:4.9
	RISC_OSLib-5_51:4.9
	RO_5_07:4.9
	RISC_OSLib-5_50:4.9
	RISC_OSLib-5_49:4.9
	RISC_OSLib-5_46-4_64_2_1:4.8
	NoInlineAsm:4.8.0.2
	RISC_OSLib-5_48:4.9
	RISC_OSLib-5_47:4.9
	RISC_OSLib-5_46:4.8
	RISC_OSLib-5_45:4.7
	RISC_OSLib-5_44:4.7
	RISC_OSLib-5_43:4.6
	RISC_OSLib-5_42:4.6
	RISC_OSLib-5_41:4.5
	RISC_OSLib-5_40:4.4
	RISC_OSLib-5_39:4.4
	RISC_OSLib-5_38:4.4
	RISC_OSLib-5_37:4.4
	RISC_OSLib-5_36:4.4
	RISC_OSLib-5_35:4.4
	RISC_OSLib-5_34:4.4
	RISC_OSLib-5_33-4_50_2_1:4.4
	sbrodie_dev:4.4.0.2
	sbrodie_dev_bp:4.4
	RISC_OSLib-5_33:4.4
	RISC_OSLib-5_32:4.4
	RISC_OSLib-5_31:4.4
	RISC_OSLib-5_30:4.4
	RISC_OSLib-5_29:4.4
	RISC_OSLib-5_28:4.4
	RISC_OSLib-5_27:4.4
	RISC_OSLib-5_26:4.4
	RISC_OSLib-5_25:4.4
	RISC_OSLib-5_24:4.3
	RISC_OSLib-5_01-4_16_2_5:4.2
	RISC_OSLib-5_23:4.3
	RISC_OSLib-5_22:4.3
	RISC_OSLib-5_21:4.3
	RISC_OSLib-5_20:4.3
	RISC_OSLib-5_19:4.3
	RISC_OSLib-5_18:4.3
	RISC_OSLib-5_17:4.3
	RISC_OSLib-5_16:4.3
	RISC_OSLib-5_15:4.3
	dellis_autobuild_BaseSW:4.3
	RISC_OSLib-5_14:4.3
	RISC_OSLib-5_13:4.3
	RISC_OSLib-5_12:4.3
	RISC_OSLib-5_01-4_16_2_4:4.2
	RISC_OSLib-5_11:4.3
	RISC_OSLib-5_01-4_16_2_3:4.2
	RISC_OSLib-5_01-4_16_2_2:4.2
	RISC_OSLib-5_10:4.3
	RISC_OSLib-5_01-4_16_2_1:4.2
	Bethany:4.2.0.4
	RISC_OSLib-5_09:4.3
	RISC_OSLib-5_08:4.3
	RISC_OSLib-5_07:4.3
	RISC_OSLib-5_06:4.3
	RISC_OSLib-4_97-4_12_2_8:4.2.2.4
	RISC_OSLib-5_05:4.2
	RISC_OSLib-5_04:4.2
	sbrodie_sedwards_16Mar2000:4.2
	RISC_OSLib-5_03:4.2
	RISC_OSLib-5_02:4.2
	RISC_OSLib-4_97-4_12_2_7:4.2.2.3
	RISC_OSLib-5_01:4.2
	RISC_OSLib-5_00:4.2
	RISC_OSLib-4_99:4.2
	RISC_OSLib-4_98:4.2
	RISC_OSLib-4_97-4_12_2_6:4.2.2.3
	RISC_OSLib-4_97-4_12_2_5:4.2.2.3
	RISC_OSLib-4_97-4_12_2_4:4.2.2.2
	RISC_OSLib-4_97-4_12_2_3:4.2.2.1
	RISC_OSLib-4_97-4_12_2_2:4.2
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.2
	kbracey_32bit:4.2.0.2
	kbracey_32bit_bp:4.2
	dcotton_autobuild_BaseSW:4.4
	RISC_OSLib-4_97:4.2
	RISC_OSLib-4_96:4.2
	RISC_OSLib-4_95:4.2
	RISC_OSLib-4_94:4.2
	RISC_OSLib-4_93:4.2
	RISC_OSLib-4_92:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	sforrest_daytona_appflash-0_31:4.2
	RISC_OSLib-4_91:4.2
	RISC_OSLib-4_90:4.2
	RISC_OSLib-4_89:4.2
	Ursula_merge:4.1.4.1
	RISC_OSLib-4_88:4.2
	RISC_OSLib-4_87:4.2
	blaughto_daytona_appflash-0_30:4.2
	rmanby_clib-4_86:4.2
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2011.11.12.01.12.19;	author bavison;	state Exp;
branches;
next	4.12;
commitid	BPjVlzYW1sAkVYGv;

4.12
date	2011.10.28.14.23.31;	author bavison;	state Exp;
branches;
next	4.11;
commitid	hIG6j26y6NoxM7Fv;

4.11
date	2011.08.06.20.05.10;	author jlee;	state Exp;
branches;
next	4.10;
commitid	D9pXqV2mtIAhluuv;

4.10
date	2009.05.31.17.58.55;	author pnaulls;	state Exp;
branches;
next	4.9;

4.9
date	2003.10.09.17.39.48;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2003.04.15.16.50.27;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2002.11.15.15.00.28;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2002.07.23.11.52.21;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2002.05.22.10.45.25;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.11.30.09.18.30;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.14.09.36;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.09.19.08.48.16;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.24.59;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	99.11.10.14.02.27;	author kbracey;	state Exp;
branches;
next	4.2.2.2;

4.2.2.2
date	99.11.10.16.59.06;	author kbracey;	state Exp;
branches;
next	4.2.2.3;

4.2.2.3
date	99.11.22.13.27.46;	author sbrodie;	state Exp;
branches;
next	4.2.2.4;

4.2.2.4
date	2000.05.09.13.58.51;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.24.59;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.52.48;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.03.26.12.14.40;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.28.50;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.48.31;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@  Fix stack imbalance in module stubs
Detail:
  A minus sign was missing - this meant that any module built using stubs
  from the last 2 weeks would branch through zero at the end of initialisation.
Admin:
  Modules now work again!

Retagged as 'RISC_OSLib-5_64'

Version 5.64. Not tagged
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; -*- Mode: Assembler -*-
;* Lastedit: 08 Mar 90 15:18:04 by Harry Meekings *
;* Shared C library: stub for clients to link with
;  2-Mar-89: IDJ: taken for RISC_OSLib purposes
;
; Copyright (C) Acorn Computers Ltd., 1988.
;

        GBLL    Brazil_Compatible
        GBLL    ModeMayBeNonUser
        GBLL    SharedLibrary

Brazil_Compatible  SETL  {FALSE}
ModeMayBeNonUser   SETL  {TRUE}
SharedLibrary      SETL  {TRUE}

        GET     h_Regs.s
        GET     h_Brazil.s
        GET     h_stubs.s
        GET     h_stack.s
        GET     h_workspc.s
        GET     clib.s.h_signal

        GET     Hdr:MsgTrans

        AREA    |Stub$$Code|, CODE, READONLY

        IMPORT  |__RelocCode|, WEAK
      [ Code_Destination <> "RAM"
        IMPORT  |_Shared_Lib_Module_SWI_Code|

        ; These in the RAM version are provided by the entry inclusions
        IMPORT  |_kernel_init|
        IMPORT  |_kernel_moduleinit|
        IMPORT  |_clib_initialise|
        IMPORT  |_kernel_entermodule|
        IMPORT  |TrapHandler|
        IMPORT  |UncaughtTrapHandler|
        IMPORT  |EventHandler|
        IMPORT  |UnhandledEventHandler|
        IMPORT  |_kernel_command_string|
        IMPORT  |_main|
      ]
      [ :DEF:AnsiLib
        IMPORT  |_kernel_moduleinit|
        IMPORT  |_clib_initialise|
        IMPORT  |_kernel_entermodule|
        IMPORT  |_AnsiLib_Module_Init_Statics|
      ]
        IMPORT  |Image$$RO$$Base|
        IMPORT  |RTSK$$Data$$Base|
        IMPORT  |RTSK$$Data$$Limit|
        IMPORT  |Image$$RW$$Base|
        IMPORT  |Image$$RW$$Limit|
        IMPORT  |Image$$ZI$$Base|
        IMPORT  |__root_stack_size|, WEAK
      [ :LNOT::DEF:AnsiLib
        IMPORT  |Stub$$Init$$Base|
      ]

        EXPORT  |_Lib$Reloc$Off|
        EXPORT  |_Mod$Reloc$Off|
        EXPORT  |_Lib$Reloc$Off$DP|

|_Lib$Reloc$Off|        *       -SL_Lib_Offset
|_Mod$Reloc$Off|        *       -SL_Client_Offset
|_Lib$Reloc$Off$DP|     *       ((-SL_Lib_Offset):SHR:2)+&F00
                                ; A version of _Lib$Reloc$Off suitable for
                                ; insertion into a DP instruction

 [ :LNOT::DEF:Module_Only :LAND: :LNOT::DEF:AnsiLib
        ENTRY

|_kernel_entrypoint|
        SWI     GetEnv
 [ APCS_Type <> "APCS-R" :LAND: Code_Destination = "RAM"
        MOV     sp, r1
        BL      EnsureCLib
;        SWIVS   GenerateError
 ]
        MOV     r2, r1
        LDR     r1, =|Image$$RW$$Limit|
        MOV     r3, #-1
        MOV     r4, #0
        MOV     r5, #-1                 ; no copying of our statics wanted

; need r1 pointer to workspace start
;      r2 pointer to workspace end
;      r3 pointer to the base of zero-init statics
;      r4 pointer to start of our statics to copy
;      r5 pointer to end of statics to copy
;      r6 = requested stack size (in K) << 16
;      r6 bit 0 indicates 32-bit mode

        LDR     r0, =|Stub$$Init$$Base|
;        ADR     r0, |_lib_init_table|
        LDR     r6, =|__root_stack_size|
        CMP     r6, #0
        MOVEQ   r6, #RootStackSize
        LDRNE   r6, [r6]
        MOV     r6, r6, ASR #10
        MOV     r6, r6, ASL #16
  [ APCS_Type <> "APCS-R"
        MOV     r14, #0
        MRS     r14, CPSR       ; will be a NOP for 26-bit only processors
        TST     r14, #&1C       ; all these bits are clear if 26-bit
        ORRNE   r6, r6, #1
  ]
  [ Code_Destination = "RAM"
     [ APCS_Type = "APCS-R"
        SWI     X:OR:Lib_Init + 1
     |
        SWI     X:OR:Lib_Init + 3
     ]
   |
        ; For ROM BL to the SWI code directly (yuck!)
     [ APCS_Type = "APCS-R"
        MOV     r11, #1         ; SWI offset 1 for APCS-R
     |
        MOV     r11, #3         ; SWI offset 3 for APCS-32
     ]
        SWI     EnterSVC
        BL      |_Shared_Lib_Module_SWI_Code|
        WritePSR USR_mode
  ]
; returns r1 stack base
;         r2 stack top (sp value)
;         r6 library version (but preserved if old library)
; other registers preserved
  [ Code_Destination = "RAM"
        BVC     NoCLibError
        LDR     r14, [r0, #0]
        LDR     r6, =Error_UnknownSWI
        TEQ     r14, r6                 ; V unaffected
        BEQ     OldSharedLibrary
  ]
        SWIVS   GenerateError

  [ Code_Destination = "RAM"
NoCLibError
        MOV     r6, r6, ASL #16
        CMP     r6, #LibraryVersionNumber :SHL: 16
        MOVGE   r4, r0
        ADRGE   r0, |_k_init_block|
        MOVGE   r3, #0
        BGE     |_kernel_init|

OldSharedLibrary
        ADR     r0, E_OldSharedLibrary
LookupError
        MOV     r3, r0
        ; Find ClibWord
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_CLibWord
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        LDREQ   r2, =Legacy_CLibWord
        MOV     r0, r3
        LDR     r1, [r2]
        TEQ     r1, #0
        SWIEQ   GenerateError           ; Can we borrow CLib's message file?
        ADD     r0, r0, #4
04      LDRB    r14, [r0], #1           ; Skip over default message
        TEQ     r14, #0
        BNE     %B04
        ADD     r0, r0, #3
        BIC     r0, r0, #3
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     MessageTrans_ErrorLookup

        ErrorBlock SharedLibraryNeeded, "Shared C library not loaded", C62
        ErrorBlock OldSharedLibrary, "Shared C library is out of date", C63
   |
        MOV     r4, r0
        ADR     r0, |_k_init_block|
        MOV     r3, #0
        B       |_kernel_init|
  ]
 ]


 [ :LNOT::DEF:Apps_Only
  [ ModeMayBeNonUser

|_kernel_moduleentry|
        ; r0 is non-0 if the module is to be capable of multiple instantiation
        ; (statics need copying) - if so, we must allocate RMA to hold them.
        ; Note that finalise always discards the RMA (whether fatal or not)
        ; so initialise always acquires it.  Is this reasonable?
        STR     r14, [sp, #-4]!
   [ APCS_Type <> "APCS-R" :LAND: Code_Destination = "RAM" :LAND: :LNOT::DEF:AnsiLib
        BL      EnsureCLib
;        LDMVSFD sp!, {pc}
   ]
        MOV     r9, r0                  ; save 'copy statics' flag
;      [ Code_Destination = "RAM"
; Old versions of RelocCode would "return" the last field of the
; relocation table (which would be -1) in R0. Current versions
; return the address of the relocation table.
        LDR     r0, =|__RelocCode|      ; if __RelocCode is present, call it and
        TEQ     r0, #0                  ; note the address of the relocation table
        MOVEQ   r0, #-1                 ; in r8, else just set r8 to -1
        BLNE    __RelocCode             ; BL<cond> 32-bit OK
        MOV     r8, r0
;      ]
        MOV     r4, #0
        MOV     r5, #-1
        CMP     r9, #0
        MOVEQ   r3, #fixedwssize

        LDRNE   r4, =|Image$$RW$$Base|
        LDRNE   r5, =|Image$$RW$$Limit|
        SUBNE   r3, r5, r4
        ADDNE   r3, r3, #fixedwssize
        MOV     r0, #Module_Claim
        SWI     Module
        LDRVS   pc, [sp], #4
        STR     r2, [r12]               ; set private word to address our data
        STR     r3, [r2]                ; first word is size

        MOV     r9, r12
        LDR     r12, [r12]
        ADD     r1, r12, #fixedwssize   ; Pointer to low end of block
        LDR     r2, [r12, #blocksize]
        ADD     r2, r2, r12             ; Pointer to high end of block
        LDR     r3, =|Image$$ZI$$Base|
 [ :DEF:AnsiLib
        BL      _AnsiLib_Module_Init_Statics
 |
        LDR     r0, =|Stub$$Init$$Base|
;        ADR     r0, |_lib_init_table|
        LDR     r6, =|__root_stack_size|
        CMP     r6, #0
        MOVEQ   r6, #RootStackSize :SHL: 6
        LDRNE   r6, [r6]
        MOV     r6, r6, ASR #10
        MOV     r6, r6, ASL #16
  [ APCS_Type <> "APCS-R"
        MOV     r14, #0
        MRS     r14, CPSR       ; will be a NOP for 26-bit only processors
        TST     r14, #&1C       ; all these bits are clear if 26-bit
        ORRNE   r6, r6, #1
  ]
      [ Code_Destination = "RAM"
       [ APCS_Type = "APCS-R"
        STMFD   sp!, {r8}
        SWI     X:OR:Lib_Init + 2
        LDMFD   sp!, {r8}               ; KJB - why preserve here???
       |
        SWI     X:OR:Lib_Init + 4
       ]
      |
        ; For ROM BL to the SWI code directly (yuck!)
        STMFD   r13!,{r8,r11,r12}
       [ APCS_Type = "APCS-R"
        MOV     r11,#2          ; SWI offset
       |
        MOV     r11,#4          ; SWI offset
       ]
        MOV     r12,#-3         ; A number liable to address exception if used
        BL      |_Shared_Lib_Module_SWI_Code|
        LDMFD   r13!,{r8,r11,r12}
      ]
 ]
        BVS     %F99

; [ Code_Destination = "RAM"
        ; Chunk of code to relocate all the pointers in the data area
        STMFD   sp!, {r1-r5}
        LDR     r1, [r12]
        CMP     r1, #12
        BEQ     %F80
        CMP     r8, #-1
        BEQ     %F80
        LDR     r1, =|Image$$RO$$Base|  ; r1 = pointer to code
        LDR     r2, =|Image$$RW$$Base|  ; r2 = pointer to data template in module code area
        ADD     r3, r12, #fixedwssize   ; r3 = pointer to our real data area (XXXX what if r0 was 0 on entry?? XXXX)
        SUB     r3, r3, r2              ; r3 = offset from data template to real data
        ADD     r1, r1, r3              ; r1 = code + data offset (odd, but saves work below)
70      LDR     r4, [r8], #4            ; get a word from the relocation table
        MOVS    r4, r4, ASR #2
        BMI     %F80                    ; if top bit set, it's the end of the table
        BCC     %B70                    ; if bit 1 not set, it's not a data relocation
        LDR     r5, [r1, r4, LSL #2]    ; read in the word to be relocated from the data area
        ADD     r5, r5, r3              ; add the magic offset
        STR     r5, [r1, r4, LSL #2]    ; and put it back
        B       %B70
80      LDMFD   sp!, {r1-r5}

 [ Code_Destination = "RAM" :LAND: :LNOT::DEF:AnsiLib
        MOV     r6, r6, ASL #16
        CMP     r6, #LibraryVersionNumber :SHL: 16
        BLT     OldSharedLibrary
 ]

        ADD     r8, r1, #SC_SLOffset+SL_Lib_Offset
        LDMIA   r8, {r7, r8}            ; move relocation offsets
        STMIB   r12, {r7, r8}           ; to standard place in RMA
        MOV     r4, r0
        ADR     r0, |_k_init_block|
        B       |_kernel_moduleinit|    ; Can't get error
99
        MOV     r1, r0                  ; Free workspace and return
        MOV     r0, #Module_Free        ; with error.
        MOV     r2, r12
        SWI     Module
        MOV     r0, #0
        STR     r0, [r9]
        MOV     r0, r1
      [ {CONFIG}=26
        LDMIA   sp!, {lr}
        ORRS    pc, lr, #V_bit
      |
        CMP     r0, #&80000000
        CMNVC   r0, #&80000000          ; Set V bit
        LDR     pc, [sp], #4
      ]

   [ APCS_Type <> "APCS-R" :LAND: Code_Destination = "RAM" :LAND: :LNOT::DEF:AnsiLib
EnsureCLib
        STMFD   sp!, {r0,lr}
;        ADR     r0, RMEnsure1
;        SWI     CLI
        ADR     r0, RMEnsure2
        SWI     CLI
;        ADRVC   r0, RMEnsure3
;        SWIVC   CLI
        ADRVC   r0, RMEnsure4
        SWIVC   CLI
;        ADRVC   r0, RMEnsure5
;        SWIVC   CLI
        ADRVC   r0, RMEnsure6
        SWIVC   CLI
;        ADRVC   r0, RMEnsure7
;        SWIVC   CLI
        STRVS   r0, [sp]
        LDMFD   sp!, {r0,pc}

;RMEnsure1
;        = "RMEnsure UtilityModule 3.10", 0
RMEnsure2
        = "RMEnsure UtilityModule 3.70 RMEnsure CallASWI 0.02 RMLoad System:Modules.CallASWI", 0
;RMEnsure3
;        = "RMEnsure UtilityModule 3.70 RMEnsure CallASWI 0.02", 0
RMEnsure4
        = "RMEnsure FPEmulator 4.03 RMLoad System:Modules.FPEmulator", 0
;RMEnsure5
;        = "RMEnsure FPEmulator 4.03", 0
RMEnsure6
        = "RMEnsure SharedCLibrary 5.17 RMLoad System:Modules.CLib", 0
;RMEnsure7
;        = "RMEnsure SharedCLibrary 5.34", 0
        ALIGN
   ]

        EXPORT  |_clib_initialisemodule|
|_clib_initialisemodule|
        STR     r14, [sp, #-4]!
        BL      |_kernel_moduleentry|
        LDRVS   pc, [sp], #4
        STR     r9, [sp, #-4]!          ; save preserved private word ptr
        BL      |_clib_initialise|
      [ {CONFIG}=26
        LDMFD   sp!, {r0, pc}^          ; return saved private word ptr
      |
        ADDS    r0, r0, #0              ; clear V
        LDMFD   sp!, {r0, pc}           ; return saved private word ptr
      ]

        EXPORT  |_clib_entermodule|
|_clib_entermodule|
        ; User-mode entry to a module.  The module's intialisation has always
        ; been called, so stubs have been patched and relocation entries are
        ; correct.  Almost everything can be done inside the shared library.
        ADR     r0, |_k_init_block|
        MOV     r8, r12
        MOV     r12, #-1
        LDR     r6, =|__root_stack_size|
        CMP     r6, #0
        MOVEQ   r6, #RootStackSize
        LDRNE   r6, [r6]
        B       |_kernel_entermodule|

  ]
 ]

|_k_init_block|
        &       |Image$$RO$$Base|
        &       |RTSK$$Data$$Base|
        &       |RTSK$$Data$$Limit|

        LTORG

 [ :LNOT::DEF:AnsiLib

        GET clib.s.cl_init

        LTORG

        AREA    |Stub$$Init|, CODE, READONLY

|_lib_init_table|
        &       1
        &       |_k_entries_start|
        &       |_k_entries_end|
        &       |_k_data_start|
        &       |_k_data_end|

        &       2
        &       |_clib_entries_start|
        &       |_clib_entries_end|
        &       |_clib_data_start|
        &       |_clib_data_end|

 [ :DEF:RISC_OSStubs
  [ Code_Destination = "ROM"
; rlib only available to ROM
        &       3
        &       |_rlib_entries_start|
        &       |_rlib_entries_end|
        &       |_rlib_data_start|
        &       |_rlib_data_end|
  ]
 ]

        AREA    |Stub$$InitEnd|, CODE, READONLY

        &       -1

        AREA    |Stub$$Entries|, CODE, READONLY

; Don't GET the stub entries if in ROM

        GBLS    GetRoundObjAsm
|_k_entries_start|
      [ Code_Destination = "RAM"
GetRoundObjAsm SETS "        GET     kernel.s.k_entries"
      |
GetRoundObjAsm SETS ""
      ]
$GetRoundObjAsm
|_k_entries_end|
      [ Code_Destination = "RAM" :LAND: APCS_Type <> "APCS-R"
        %       |_k_entries_end| - |_k_entries_start|
      ]

|_clib_entries_start|
      [ Code_Destination = "RAM"
GetRoundObjAsm SETS "        GET     clib.s.cl_entries"
      |
GetRoundObjAsm SETS ""
      ]
$GetRoundObjAsm
|_clib_entries_end|
      [ Code_Destination = "RAM" :LAND: APCS_Type <> "APCS-R"
        %       |_clib_entries_end| - |_clib_entries_start|
      ]

|_rlib_entries_start|
 [ Code_Destination = "RAM":LAND::DEF:RISC_OSStubs
GetRoundObjAsm SETS "        GET     rlib.s.rl_entries"
 |
GetRoundObjAsm SETS ""
 ]
$GetRoundObjAsm
|_rlib_entries_end|
      [ Code_Destination = "RAM" :LAND: APCS_Type <> "APCS-R"
        %       |_rlib_entries_end| - |_rlib_entries_start|
      ]

        AREA    |Stub$$Data|, DATA, NOINIT

|_k_data_start|
        GET     kernel.s.k_data
|_k_data_end|

|_clib_data_start|
        GET     clib.s.cl_data
        GET     clib.s.clibdata
|_clib_data_end|

        GBLS    Bodge1
        GBLS    Bodge2
|_rlib_data_start|
 [ :DEF:RISC_OSStubs
Bodge1 SETS " GET     rlib.s.rl_data"
Bodge2 SETS " GET     rlib.s.rlibdata"
 |
Bodge1 SETS ""
Bodge2 SETS ""
 ]
$Bodge1
$Bodge2
|_rlib_data_end|

 ] ; :LNOT::DEF:AnsiLib

        END
@


4.12
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@d381 1
a381 1
        STR     r9, [sp, #4]!           ; save preserved private word ptr
@


4.11
log
@Update to work with zero page relocation
Detail:
  clib/s/cl_stub, kernel/s/k_body, s/initmodule - Use OS_ReadSysInfo 6 to look up CLibWord/RISCOSLibWord/CLibCounter location each time it's needed instead of using hardcoded addresses. SWI overhead shouldn't be too bad since the zero page areas are rarely used.
  rlib/c/menu - Fix null pointer access when attempting to clear a submenu pointer via menu_submenu(...,...,NULL)
  s/h_workspc - Remove old local definitions of CLibCounter, RISCOSLibWorkSpace and CLibWorkSpace. Use Hdr:PublicWS instead.
Admin:
  Tested on rev A2 BB-xM


Version 5.60. Tagged as 'RISC_OSLib-5_60'
@
text
@d210 1
a210 1
        STMFD   sp!, {r14}
d237 1
a237 1
        LDMVSIA sp!, {pc}
d336 1
a336 1
        LDMIA   sp!, {pc}
d378 1
a378 1
        STMFD   sp!, {r14}
d380 2
a381 2
        LDMVSIA sp!, {pc}
        STMFD   sp!, {r9}               ; save preserved private word ptr
@


4.10
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d165 11
a175 2
        MOV     r4, #0
        LDR     r1, [r4, #CLibWorkSpace]
d185 1
@


4.9
log
@  Changes required for Customer W.
Detail:
  * Implemented the thread-safety mutex macros for the user mode heap.
  * Created ansilibm, a version of ansilib suitable for building modules.
  * Fixed an overestimation of the size of the workspace passed to
    SharedCLibrary_LibInitModule[APCS_32] by the stubs.
  * Fixed bug in SharedCLibrary_LibInitModule[APCS_32] regarding handling of
    non-reentrant modules - if module code was at a higher address than the
    module data, then all the intervening data would be pointlessly copied
    back over itself with no allowance for volatility.
  * Removed the bsearch source file, since it was only required for APCS-A
    which the library has not supported since the year 2000, and which the
    compiler is now no longer able to build.
Admin:
  ansilibm builds working modules, but thread safety has not been
  extensively tested.

Version 5.47. Tagged as 'RISC_OSLib-5_47'
@
text
@d31 5
a35 5
        GET     s.h_Regs
        GET     s.h_Brazil
        GET     s.h_stubs
        GET     s.h_stack
        GET     s.h_workspc
@


4.8
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d58 6
d71 1
d73 1
d85 1
a85 1
 [ :LNOT::DEF:Module_Only
d201 1
a201 1
   [ APCS_Type <> "APCS-R" :LAND: Code_Destination = "RAM"
d235 1
a235 1
        ADD     r2, r2, r1              ; Pointer to high end of block
d237 3
d274 1
d300 1
a300 1
 [ Code_Destination = "RAM"
d329 1
a329 1
   [ APCS_Type <> "APCS-R" :LAND: Code_Destination = "RAM"
d404 2
d505 2
@


4.7
log
@ROM build fixed for 64-bit stuff.
PCI added to swis.h
alloc.c updated to handle bigger slots (new code merged from ARM libraries)
Various 32-bit fixes for backtracing, and general trap handling.
Polite "Application is not 32-bit compatible" message.
Headers <stdint.h> and <inttypes.h> fixed to work in non-C99 mode.
txt changed to do new-style Delete behaviour

Version 5.44. Tagged as 'RISC_OSLib-5_44'
@
text
@d82 5
d193 4
d316 37
@


4.6
log
@  Fixed to build with the latest cc (5.54) compiler.
Detail:
  This version now builds with cc-5_45. Note: it has not been verified as
  actually functioning correctly.
Admin:
  Tested in DSL Baseline build.

Version 5.42. Tagged as 'RISC_OSLib-5_42'
@
text
@d190 3
d227 7
a233 1
        MOVS    r6, r6, ASL #16
d235 1
a236 1
       [ APCS_Type = "APCS-R"
d238 1
a241 1
        LDMFD   sp!, {r8}               ; KJB - why preserve here???
d262 2
a263 2
        CMP     r8, #0
        BMI     %F80
@


4.5
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@d65 1
a95 1
        IMPORT  |Stub$$Init$$Base|
@


4.4
log
@Stubs were using some 26/32-bit switching macros, which is invalid for a
component that has to work on all OS versions. Changed to use 26/32-bit
neutral code. Stubs issued in first 32-bit library release were using 26-bit
forms, but they should only go wrong on a 32-bit system in failure cases
(such as the SharedCLibrary being unplugged).

Version 5.25. Tagged as 'RISC_OSLib-5_25'
@
text
@d95 3
a97 1
        ADR     r0, |_lib_init_table|
d217 2
a218 1
        ADR     r0, |_lib_init_table|
d330 13
d367 2
a369 11

|_k_init_block|
        &       |Image$$RO$$Base|
        &       |RTSK$$Data$$Base|
        &       |RTSK$$Data$$Limit|

        LTORG

        GET clib.s.cl_init

        LTORG
@


4.3
log
@32-bit work merged from kbracey_32bit branch.

Version 5.06. Tagged as 'RISC_OSLib-5_06'
@
text
@d287 1
d289 6
a294 1
        RETURNVS
d303 4
a306 1
        CLRV
d308 1
@


4.2
log
@Stubs modified to support static data init in RAM and ROM modules.
@
text
@d35 1
d38 2
d93 1
d102 6
d109 1
a109 3
   [ Calling_Standard = "APCS_A"
        SWI     X:OR:Lib_Init
    |
d111 3
a113 1
   ]
d116 5
a120 5
   [ Calling_Standard = "APCS_A"
        MOV     r11, #0         ; SWI offset 0 for APCS A
    |
        MOV     r11, #1         ; SWI offset 1 for APCS R
   ]
d123 1
a123 1
        TEQP    pc, #0
d129 7
d139 1
d149 16
a164 1
        SWI     GenerateError
a175 1
OS_Module EQU &1e
d191 1
a191 1
        BLNE    __RelocCode
d224 1
d226 3
d233 1
d235 3
d288 1
a288 1
        ORRS    pc, lr, #&10000000
d297 2
a298 1
        LDMFD   sp!, {r0, pc}^          ; return saved private word ptr
d367 3
d379 3
d391 3
@


4.2.2.1
log
@_kernel_unwind now understands SFMFD instructions in function entry.
It also copes with STFE now - it was totally broken.
32-bit stubs and corresponding LibInit SWIs created.
All rather untested.

Version 4.97, 4.12.2.3. Tagged as 'RISC_OSLib-4_97-4_12_2_3'
@
text
@a89 1
;      r6 bit 0 indicates 32-bit mode
a97 6
  [ APCS_Type <> "APCS-R"
        MOV     r14, #0
        MRS     r14, CPSR       ; will be a NOP for 26-bit only processors
        TST     r14, #&1C       ; all these bits are clear if 26-bit
        ORRNE   r6, r6, #1
  ]
a101 1
     [ APCS_Type = "APCS-R"
a102 3
     |
        SWI     X:OR:Lib_Init + 3
     ]
a108 1
     [ APCS_Type = "APCS-R"
a109 3
     |
        MOV     r11, #3         ; SWI offset 3 for APCS 32
     ]
d113 1
a113 1
        WritePSR USR_mode
a118 7
  [ Code_Destination = "RAM"
        BVC     NoCLibError
        LDR     r14, [r0, #0]
        LDR     r6, =Error_UnknownSWI
        TEQ     r14, r6                 ; V unaffected
        BEQ     OldSharedLibrary
  ]
a121 1
NoCLibError
d143 1
a191 1
       [ APCS_Type = "APCS-R"
a192 3
       |
        SWI     X:OR:Lib_Init + 4
       ]
a196 1
       [ APCS_Type = "APCS-R"
a197 3
       |
        MOV     r11,#4          ; SWI offset
       ]
d248 1
a248 1
        RETURNVS
d257 1
a257 2
        CLRV
        LDMFD   sp!, {r0, pc}           ; return saved private word ptr
a325 3
      [ Code_Destination = "RAM" :LAND: APCS_Type <> "APCS-R"
        %       |_k_entries_end| - |_k_entries_start|
      ]
a334 3
      [ Code_Destination = "RAM" :LAND: APCS_Type <> "APCS-R"
        %       |_clib_entries_end| - |_clib_entries_start|
      ]
a343 3
      [ Code_Destination = "RAM" :LAND: APCS_Type <> "APCS-R"
        %       |_rlib_entries_end| - |_rlib_entries_start|
      ]
@


4.2.2.2
log
@Most of the obvious problems in the last check-in fixed. It now builds, at
least.
Stubs now correctly, and internationalisably, report "C library too old".
Both BL and LDR PC forms of branch table successfully created.
Tested on various existing 26-bit programs, and one 32-bit program tested.

Version 4.97, 4.12.2.4. Tagged as 'RISC_OSLib-4_97-4_12_2_4'
@
text
@a34 1
        GET     s.h_workspc
a36 2
        GET     Hdr:MsgTrans

d154 1
a154 16
LookupError
        MOV     r4, #0
        LDR     r1, [r4, #CLibWorkSpace]
        TEQ     r1, #0
        SWIEQ   GenerateError           ; Can we borrow CLib's message file?
        ADD     r0, r0, #4
04      LDRB    r14, [r0], #1           ; Skip over default message
        TEQ     r14, #0
        BNE     %B04
        ADD     r0, r0, #3
        BIC     r0, r0, #3
        MOV     r2, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     MessageTrans_ErrorLookup
@


4.2.2.3
log
@  Work in progress.  Do not use.
Detail:
  Many changes to use the APCS macros for function entry and exit so
    that the code can build for 32-bit environments.  Changes are NOT
    yet complete.
  Makefile rebuilds swis.h header file but only exports it if it has
    changed to avoid unnecessary rebuilding of nearly all C sources
    in a build.
Admin:
  Work in progress.  Do not use.

Version 4.97, 4.12.2.5. Tagged as 'RISC_OSLib-4_97-4_12_2_5'
@
text
@d199 1
a199 1
        BLNE    __RelocCode             ; BL<cond> 32-bit OK
@


4.2.2.4
log
@Features:

* APCS-32 support complete.
* APCS-A compatibility removed.
* Old ArthurLib code removed.
* _clib_version() now reports version from VersionNum.
* time() no longer does a run-time host check - I think we know we're not a BBC
  Master ARM second processor now.
* rename() now uses OS_FSControl 25 instead of *rename.
* getenv() can handle arbitrary length variables.
* Can now handle exceptions in 32-bit form of FPEmulator (on either 26 or 32
  bit systems).
* tmpnam() switches to SVC mode to access its zero page counter.
* Faster divide routines.

Admin:

  This will build all sorts of different things depending on the flags. See
  the Docs directory for details.

  As far as ROM builds are concerned, if using APCS-R, no changes are needed.
  If using APCS-32, the Shared C Library must be built as APCS-R to ensure
  compatibility with old binaries. To achieve this, pass in the option
  SCL_APCS="-APCS 3/26bit" in the Components file.

Version 4.97, 4.12.2.8. Tagged as 'RISC_OSLib-4_97-4_12_2_8'
@
text
@d109 3
d117 1
d120 3
d124 1
a124 1
        MOV     r11, #1         ; SWI offset 1 for APCS-R
d126 1
a126 1
        MOV     r11, #3         ; SWI offset 3 for APCS-32
d128 1
@


4.1
log
@Initial revision
@
text
@a38 1
      [ Code_Destination = "RAM"
d40 1
a40 1
      |
d155 7
a161 3
      [ Code_Destination = "RAM"
        BL      |__RelocCode|
      ]
d191 1
d193 1
d196 1
a196 1
        STMFD   r13!,{r11,r12}
d200 1
a200 1
        LDMFD   r13!,{r11,r12}
d204 23
d345 1
a345 1
        AREA    |Stub$$Data|, DATA
@


4.1.4.1
log
@* RISC_OSLib msgs module now closes its Messages files on exit.
* strerror/perror now call _kernel_last_oserror and use result
  if errno is unknown.
* _sys_open calls error-returning form of OS_Find so
  _kernel_last_oserror can return something meaningful after
  fopen fails
* All file handling calls set errno to -1 if a _kernel_osfind/
  _kernel_osgbpb etc call returns an error
* These three changes mean that the code sequence

         if ((fp = fopen(file, "rb")) == NULL) {
            perror(progname);
            return 1;
         }

  will now say something useful rather than "No error (errno=0)"
  This could now be used by socklib to get perror to work
  with errors generated by the Internet module.
* ANSILib now outputs proper messages, not just tokens.
@
text
@d39 1
d41 1
a41 1
      [ Code_Destination <> "RAM"
d156 3
a158 7
;      [ Code_Destination = "RAM"
        LDR     r0, =|__RelocCode|      ; if __RelocCode is present, call it and
        TEQ     r0, #0                  ; note the address of the relocation table
        MOVEQ   r0, #-1                 ; in r8, else just set r8 to -1
        BLNE    __RelocCode
        MOV     r8, r0
;      ]
a187 1
        STMFD   sp!, {r8}
a188 1
        LDMFD   sp!, {r8}               ; KJB - why preserve here???
d191 1
a191 1
        STMFD   r13!,{r8,r11,r12}
d195 1
a195 1
        LDMFD   r13!,{r8,r11,r12}
a198 23
; [ Code_Destination = "RAM"
        ; Chunk of code to relocate all the pointers in the data area
        STMFD   sp!, {r1-r5}
        LDR     r1, [r12]
        CMP     r1, #12
        BEQ     %F80
        CMP     r8, #0
        BMI     %F80
        LDR     r1, =|Image$$RO$$Base|  ; r1 = pointer to code
        LDR     r2, =|Image$$RW$$Base|  ; r2 = pointer to data template in module code area
        ADD     r3, r12, #fixedwssize   ; r3 = pointer to our real data area (XXXX what if r0 was 0 on entry?? XXXX)
        SUB     r3, r3, r2              ; r3 = offset from data template to real data
        ADD     r1, r1, r3              ; r1 = code + data offset (odd, but saves work below)
70      LDR     r4, [r8], #4            ; get a word from the relocation table
        MOVS    r4, r4, ASR #2
        BMI     %F80                    ; if top bit set, it's the end of the table
        BCC     %B70                    ; if bit 1 not set, it's not a data relocation
        LDR     r5, [r1, r4, LSL #2]    ; read in the word to be relocated from the data area
        ADD     r5, r5, r3              ; add the magic offset
        STR     r5, [r1, r4, LSL #2]    ; and put it back
        B       %B70
80      LDMFD   sp!, {r1-r5}

d317 1
a317 1
        AREA    |Stub$$Data|, DATA, NOINIT
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

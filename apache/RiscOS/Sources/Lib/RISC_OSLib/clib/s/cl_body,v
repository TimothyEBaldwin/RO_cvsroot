head	4.16;
access;
symbols
	RISC_OSLib-5_97:4.16
	RISC_OSLib-5_96:4.16
	RISC_OSLib-5_95:4.16
	RISC_OSLib-5_94:4.16
	RISC_OSLib-5_93:4.16
	RISC_OSLib-5_92:4.16
	RISC_OSLib-5_91:4.16
	RISC_OSLib-5_90:4.16
	RISC_OSLib-5_89:4.16
	RISC_OSLib-5_88:4.16
	RISC_OSLib-5_87:4.16
	RISC_OSLib-5_86-1:4.16
	RISC_OSLib-5_86:4.16
	RISC_OSLib-5_85:4.16
	RISC_OSLib-5_84:4.16
	RISC_OSLib-5_83-2:4.16
	RISC_OSLib-5_83-1:4.16
	RISC_OSLib-5_83:4.16
	RISC_OSLib-5_82:4.16
	RISC_OSLib-5_81:4.16
	RISC_OSLib-5_75-2:4.16
	RISC_OSLib-5_80:4.16
	RISC_OSLib-5_79:4.16
	RISC_OSLib-5_78:4.16
	RISC_OSLib-5_75-1:4.16
	RISC_OSLib-5_77:4.16
	RISC_OSLib-5_76:4.16
	RISC_OSLib-5_75:4.16
	RISC_OSLib-5_74:4.16
	RISC_OSLib-5_73:4.16
	RISC_OSLib-5_72:4.16
	RISC_OSLib-5_71:4.16
	RISC_OSLib-5_70:4.16
	RISC_OSLib-5_69:4.16
	RISC_OSLib-5_68:4.16
	RISC_OSLib-5_67:4.16
	RISC_OSLib-5_66:4.16
	RISC_OSLib-5_65:4.16
	RISC_OSLib-5_64:4.16
	RISC_OSLib-5_63:4.15
	RISC_OSLib-5_62:4.15
	RISC_OSLib-5_61:4.15
	RISC_OSLib-5_60:4.15
	RISC_OSLib-5_59:4.15
	RISC_OSLib-5_58:4.15
	RISC_OSLib-5_57:4.15
	RISC_OSLib-5_56:4.15
	RISC_OSLib-5_55:4.15
	RISC_OSLib-5_54:4.15
	RISC_OSLib-5_53:4.14
	RISC_OSLib-5_52:4.14
	RISC_OSLib-5_51:4.14
	RO_5_07:4.13
	RISC_OSLib-5_50:4.13
	RISC_OSLib-5_49:4.13
	RISC_OSLib-5_46-4_64_2_1:4.12
	NoInlineAsm:4.12.0.2
	RISC_OSLib-5_48:4.12
	RISC_OSLib-5_47:4.12
	RISC_OSLib-5_46:4.12
	RISC_OSLib-5_45:4.11
	RISC_OSLib-5_44:4.10
	RISC_OSLib-5_43:4.9
	RISC_OSLib-5_42:4.8
	RISC_OSLib-5_41:4.8
	RISC_OSLib-5_40:4.7
	RISC_OSLib-5_39:4.7
	RISC_OSLib-5_38:4.5
	RISC_OSLib-5_37:4.5
	RISC_OSLib-5_36:4.4
	RISC_OSLib-5_35:4.4
	RISC_OSLib-5_34:4.3
	RISC_OSLib-5_33-4_50_2_1:4.3
	sbrodie_dev:4.3.0.2
	sbrodie_dev_bp:4.3
	RISC_OSLib-5_33:4.3
	RISC_OSLib-5_32:4.3
	RISC_OSLib-5_31:4.3
	RISC_OSLib-5_30:4.3
	RISC_OSLib-5_29:4.3
	RISC_OSLib-5_28:4.2
	RISC_OSLib-5_27:4.2
	RISC_OSLib-5_26:4.2
	RISC_OSLib-5_25:4.2
	RISC_OSLib-5_24:4.2
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.2
	RISC_OSLib-5_22:4.2
	RISC_OSLib-5_21:4.2
	RISC_OSLib-5_20:4.2
	RISC_OSLib-5_19:4.2
	RISC_OSLib-5_18:4.2
	RISC_OSLib-5_17:4.2
	RISC_OSLib-5_16:4.2
	RISC_OSLib-5_15:4.2
	dellis_autobuild_BaseSW:4.2
	RISC_OSLib-5_14:4.2
	RISC_OSLib-5_13:4.2
	RISC_OSLib-5_12:4.2
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.2
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.2
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.2
	RISC_OSLib-5_08:4.2
	RISC_OSLib-5_07:4.2
	RISC_OSLib-5_06:4.2
	RISC_OSLib-4_97-4_12_2_8:4.1.10.3
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1.10.2
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1.10.2
	RISC_OSLib-4_97-4_12_2_5:4.1.10.2
	RISC_OSLib-4_97-4_12_2_4:4.1.10.1
	RISC_OSLib-4_97-4_12_2_3:4.1.10.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.3
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.16
date	2011.10.28.14.23.31;	author bavison;	state Exp;
branches;
next	4.15;
commitid	hIG6j26y6NoxM7Fv;

4.15
date	2009.05.31.17.58.55;	author pnaulls;	state Exp;
branches;
next	4.14;

4.14
date	2004.10.27.17.29.19;	author bavison;	state Exp;
branches;
next	4.13;

4.13
date	2004.01.23.19.10.21;	author kbracey;	state Exp;
branches;
next	4.12;

4.12
date	2003.04.15.16.50.26;	author kbracey;	state Exp;
branches;
next	4.11;

4.11
date	2003.01.17.19.13.00;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	2002.11.15.15.00.28;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	2002.08.12.13.35.14;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2002.05.22.10.45.25;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2002.04.11.16.51.43;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2002.04.11.16.37.53;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2002.03.21.14.36.25;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2002.01.29.16.03.35;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2001.04.06.14.29.04;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	2000.05.09.14.09.35;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.58;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.10.1;
next	;

4.1.1.1
date	96.11.05.09.24.58;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.52.38;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.28.31;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.48.21;	author nturton;	state Exp;
branches;
next	;

4.1.10.1
date	99.11.10.14.02.24;	author kbracey;	state Exp;
branches;
next	4.1.10.2;

4.1.10.2
date	99.11.22.13.27.44;	author sbrodie;	state Exp;
branches;
next	4.1.10.3;

4.1.10.3
date	2000.05.09.13.58.50;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.16
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; -*- Mode: Assembler -*-
;* Lastedit: 27 Mar 90 12:50:15 by Harry Meekings *
; body of shared C library (to sit on top of shared library kernel)
;
; Copyright (C) Acorn Computers Ltd., 1988.
;
; 23-Sep-94 AMcC  __rt_ symbols defined and exported (compatible with cc vsn 5 etc)
;

        GET     h_Stack.s

        GET     Hdr:Wimp
        GET     Hdr:TaskWindow

        GBLL    FloatingPointArgsInRegs
FloatingPointArgsInRegs SETL {FALSE}
        [ FloatingPointArgsInRegs
        ! 0, "WARNING: Floating point arguments ARE being passed in FP registers"
        ]

SIGFPE  *       2
SIGILL  *       3
SIGINT  *       4
SIGSEGV *       5
SIGSTAK *       7
SIGOSERROR *    10

ERANGE  *       2
EDOM    *       1

        EXPORT  TrapHandler
        EXPORT  UncaughtTrapHandler
        EXPORT  EventHandler
        EXPORT  UnhandledEventHandler

        MACRO
$Label  DisableFPInterrupts
        ; Disables all FP traps, remembering the trap mask in ip
        ; for subsequent reinstatement by ReEnableFPInterrupts.  (ip must
        ; therefore be left alone by the FP procedures which call this macro).
$Label  MOV     r1, #0
        RFS     ip
        WFS     r1
        MEND

        MACRO
$Label  CheckFPInterrupts $nocheck
        ; Sets r1 to the current fp flags.
        RFS     r1
        MEND

        MACRO
$Label  ReEnableFPInterrupts $nocheck
        ; Reinstates the exception mask state which prevailed before the call
        ; to DisableFPInterrupts; sets r1 to the current fp flags.
$Label
      [ "$nocheck"=""
        RFS     r1
      ]
        WFS     ip
        MEND

        IMPORT  |_signal_real_handler|
        IMPORT  |_armsys_lib_init|
        IMPORT  |_sys_msg|
        IMPORT  |_sys_msg_1|

        IMPORT  |_kernel_fpavailable|
        IMPORT  |_kernel_exittraphandler|
        IMPORT  |_kernel_setreturncode|

        IMPORT  |_kernel_exit|
        IMPORT  |_kernel_osbyte|
        IMPORT  |_kernel_osrdch|
        IMPORT  |_kernel_oswrch|
        IMPORT  |_kernel_osbget|
        IMPORT  |_kernel_osbput|
        IMPORT  |_kernel_osgbpb|
        IMPORT  |_kernel_osword|
        IMPORT  |_kernel_osfind|
        IMPORT  |_kernel_osfile|
        IMPORT  |_kernel_osargs|
        IMPORT  |_kernel_oscli|
        IMPORT  |_kernel_last_oserror|
        IMPORT  |_kernel_system|
        IMPORT  |_kernel_raise_error|

        IMPORT  |_kernel_udiv|
        IMPORT  |_kernel_urem|
        IMPORT  |_kernel_sdiv|
        IMPORT  |_kernel_srem|

        IMPORT  |_ll_sdiv|

        IMPORT  |_kernel_stkovf_split_0frame|
        IMPORT  |_kernel_stkovf_split|

        IMPORT  |_kernel_getmessage|

        EXPORT  |_clib_initialise|
        EXPORT  |x$stack_overflow|
        EXPORT  |x$stack_overflow_1|
        EXPORT  |_raise_stacked_interrupts|
        EXPORT  |x$divtest|
        EXPORT  |x$multiply|
        EXPORT  |_rd1chk|
        EXPORT  |_rd2chk|
        EXPORT  |_rd4chk|
        EXPORT  |_wr1chk|
        EXPORT  |_wr2chk|
        EXPORT  |_wr4chk|
        EXPORT  |_memcpy|
        EXPORT  |_memset|
        EXPORT  |_postmortem|
        EXPORT  |setjmp|
        EXPORT  |longjmp|
        EXPORT  |_exit|
        EXPORT  |_oswrch|
        EXPORT  |_osbget|
        EXPORT  |_osbput|
        EXPORT  |_osgbpb|
        EXPORT  |_osgbpb1|
        EXPORT  |_osrdch|
        EXPORT  |_osfind|
        EXPORT  |_osword|
        EXPORT  |_osfile|
        EXPORT  |_osfile1|
        EXPORT  |_osargs|
        EXPORT  |_oscli|
        EXPORT  |_osbyte|
        EXPORT  |_count|
        EXPORT  |_count1|
        EXPORT  |_default_sigstak_handler|
        EXPORT  |_SignalNumber|

        EXPORT  |_ldfp|
        EXPORT  |_stfp|

        EXPORT  |__fpclassifyf| [FPREGARGS]
        EXPORT  |__fpclassifyd| [FPREGARGS]
        EXPORT  |__signbitf| [FPREGARGS]
        EXPORT  |__signbitd| [FPREGARGS]
        EXPORT  |__copysignf| [FPREGARGS]
        EXPORT  |__copysignd| [FPREGARGS]
        EXPORT  copysign
        EXPORT  copysignf
        EXPORT  nextafter
        EXPORT  nextafterf
        EXPORT  nexttoward
        EXPORT  nexttowardf

        EXPORT  |__rt_stkovf_split_small|
        EXPORT  |__rt_stkovf_split_big|
        EXPORT  |__rt_divtest|
        EXPORT  |__rt_rd1chk|
        EXPORT  |__rt_rd2chk|
        EXPORT  |__rt_rd4chk|
        EXPORT  |__rt_wr1chk|
        EXPORT  |__rt_wr2chk|
        EXPORT  |__rt_wr4chk|

        EXPORT  div
        EXPORT  ldiv
        EXPORT  lldiv
        EXPORT  imaxdiv
        EXPORT  llabs
        EXPORT  imaxabs

        EXPORT  fmin
        EXPORT  fminf
        EXPORT  fmax
        EXPORT  fmaxf

        EXPORT  nearbyint
        EXPORT  nearbyintf
        EXPORT  round
        EXPORT  roundf
        EXPORT  lround
        EXPORT  lroundf
        EXPORT  remainder
        EXPORT  remainderf
        EXPORT  exp
        EXPORT  exp2
        EXPORT  exp2f
        EXPORT  log10
        EXPORT  log
        EXPORT  log2
        EXPORT  log2f
        EXPORT  sqrt
        EXPORT  cbrt
        EXPORT  cbrtf
        EXPORT  cos
        EXPORT  sin
        EXPORT  tan
        EXPORT  asin
        EXPORT  acos
        EXPORT  pow
        EXPORT  powf
        EXPORT  hypot
        EXPORT  hypotf

        GET     clib.s.h_signal

|_clib_initialise|
        FunctionEntry "r1,r2"
        LoadStaticBase ip, a4
        MOV     r0, #-1                 ; read max app space size
        SWI     XOS_ReadDynamicArea
        ADDVC   r2, r2, r0              ; if call works then get end of app space
        MOVVS   r2, #&01000000          ; if call fails then assume 16M
        STR     r2, [ip, #O_app_space_end]
        MOV     a4, #0
        STRB    a4, [ip, #O_inSignalHandler]
        BL      |_armsys_lib_init|
        MOV     a1, #0
        Return  "r1,r2"

 [ ModeMayBeNonUser
        IMPORT  |_lib_shutdown|
        EXPORT  |_clib_finalisemodule|
|_clib_finalisemodule|
        FunctionEntry "a1"
        BL      |_lib_shutdown|
        MOV     a1, #0
        BL      |_exit|
        LDR     r1, [sp], #4            ; free the RMA block addressed by
        MOV     r0, #Module_Free        ; our private word.
        LDR     r2, [r1]
        MOV     r3, #0
        STR     r3, [r1]
        SWI     Module
        [ {CONFIG}<>26
        CLRV    VS                      ; explicitly clear V for 32-bit call case
        ]
        Return
 ]

EventHandler Keep
        CMP     a1, #-1
        MOVNE   a1, #0          ; not interested in events other than escape
        Return  ,LinkNotStacked, NE

        STMFD   sp!, {a2, r14}
        MOV     a1, #SIGINT
        BL      |_signal_real_handler|
        LDMFD   sp!, {a2, r14}
        CMP     a1, #0
        Return  ,LinkNotStacked, EQ

        LoadStaticBase ip, a1
        LDR     a1, [ip, #O__interrupts_off]
        CMP     a1, #0
        MOV     a1, #SIGINT
        STRNE   a1, [ip, #O__saved_interrupt]
        BNE     %FT01
        STR     r14, [sp, #-4]!
        BL      raise
        LDR     r14, [sp], #4
01      MOV     a1, #1          ; we wish to handle it, but not just yet
        Return  ,LinkNotStacked

UnhandledEventHandler Keep
        CMP     a1, #-1
        MOVNE   a1, #0          ; not interested in events other than escape
        Return  ,LinkNotStacked, NE

        LoadStaticBase ip, a1
        LDR     a1, [ip, #O__interrupts_off]
        CMP     a1, #0
        MOV     a1, #SIGINT
        STRNE   a1, [ip, #O__saved_interrupt]
        BNE     %FT02
        STR     r14, [sp, #-4]!
        BL      raise
        LDR     r14, [sp], #4
02      MOV     a1, #1          ; we wish to handle it, but not just yet
        Return  ,LinkNotStacked

|_SignalNumber|
SignalNumber Keep
        ; nb required not to disturb a4
        MOV     a2, #SIGOSERROR
        CMP     a1, #Error_IllegalInstruction
        CMPNE   a1, #Error_PrefetchAbort
        CMPNE   a1, #Error_BranchThroughZero
        MOVEQ   a2, #SIGILL
        CMP     a1, #Error_DataAbort
        CMPNE   a1, #Error_AddressException
        MOVEQ   a2, #SIGSEGV
        LDR     a3, =Error_FPBase
        CMP     a1, a3
        ADD     a3, a3, #Error_FPLimit-Error_FPBase-1
        CMPHS   a3, a1
        MOVHS   a2, #SIGFPE
        CMP     a1, #Error_DivideByZero
        MOVEQ   a2, #SIGFPE
        CMP     a1, #Error_StackOverflow
        MOVEQ   a2, #SIGSTAK
        LDR     a3, =Error_ReadFail
        SUBS    a3, a1, a3
        CMPNE   a3, #Error_WriteFail-Error_ReadFail
        MOVEQ   a2, #SIGSEGV
        MOV     a1, a2
        Return  ,LinkNotStacked

UncaughtTrapHandler Keep
        STMFD   sp!, {a2, r14}
        MOV     a4, a1
        BL      SignalNumber
        LDMFD   sp!, {a2, r14}
        B       RaiseIt

|_raise_stacked_interrupts|            ; called by CLIB.
        LoadStaticBase ip, a1
        MOV     a2, #0
        STR     a2, [ip, #O__interrupts_off]
        LDR     a1, [ip, #O__saved_interrupt]
        CMPS    a1, #0
        Return  ,LinkNotStacked, EQ
        STR     a2, [ip, #O__saved_interrupt]
        B       raise

Finalise Keep
; (There'd better be a stack set up).
        IMPORT  |_lib_shutdown|
        B       |_lib_shutdown|

TrapHandler Keep
        MOV     a4, a1
        STMFD   sp!, {a2, a4, r14}
        BL      SignalNumber
        STR     a1, [sp, #-4]!
        BL      |_signal_real_handler|
        CMP     a1, #0
        LDMFD   sp!, {a1, a2, a4, r14}
        MOVEQ   a1, #0
        Return  ,LinkNotStacked, EQ

RaiseIt
        LoadStaticBase ip, a3
        MOV     a3, #1
        STRB    a3, [ip, #O_inSignalHandler]
        STMFD   sp!, {a2, a4}
        LDMIB   a2, {a2-v6}
        BL      raise               ; raise desired signal
Raised
        B       |_postmortem|       ; and if user insists on returning from
                                    ; signal handler, complain loudly!

div
ldiv
        FunctionEntry "a1"
        MOV     a1, a3
        BL      _kernel_sdiv        ; a1 := a2 / a1, a2 := a2 % a1
        Pull    "ip,lr"
        STMIA   ip, {a1,a2}
        Return  ,LinkNotStacked

imaxdiv NOP                     ; addresses have to be distinct :(
lldiv                           ; a1 -> result, a2 = num.l, a3=num.h, a4=den.l, den.h on stack
        FunctionEntry "a1"
        MOV     a1, a2
        MOV     a2, a3
        MOV     a3, a4
        LDR     a4, [sp, #8]
        BL      _ll_sdiv        ; (a1,a2) := (a1,a2) / (a3,a4), (a3,a4) := (a1,a2) % (a3,a4)
        Pull    "ip,lr"
        STMIA   ip, {a1-a4}
        Return  ,LinkNotStacked

imaxabs NOP                     ; addresses have to be distinct :(
llabs
        TEQ     a2, #0
        Return  ,LinkNotStacked,PL
        RSBS    a1, a1, #0
        RSC     a2, a2, #0
        Return  ,LinkNotStacked

|x$multiply|
; a1 := a2 * a1.
; a2, a3 can be scrambled.
        MUL     a1, a2, a1
        Return  ,LinkNotStacked

        IMPORT  |_kernel_copyerror|
        IMPORT  |_kernel_fault|
|__rt_divtest|
|x$divtest|
; test for division by zero (used when division is voided)
        TEQS    a1, #0
        Return  ,LinkNotStacked, NE
        STR     r0, [sp, #-4]!
        ADR     r0, E_DivideByZero
        B       |_kernel_fault|


|__rt_rd1chk|
|_rd1chk|
        FunctionEntry
        CMP     a1, #&8000
        BLT     readfail
        LoadStaticBase ip, lr
        LDR     lr, [ip, #O_app_space_end]
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
        B       readfail

|__rt_rd2chk|
|_rd2chk|
        FunctionEntry
        CMP     a1, #&8000
        BLT     readfail
        TST     a1, #1
        BNE     readfail
        LoadStaticBase ip, lr
        LDR     lr, [ip, #O_app_space_end]
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
        B       readfail

|__rt_rd4chk|
|_rd4chk|
        FunctionEntry
        CMP     a1, #&8000
        BLT     readfail
        TST     a1, #3
        BNE     readfail
        LoadStaticBase ip, lr
        LDR     lr, [ip, #O_app_space_end]
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
        B       readfail

|__rt_wr1chk|
|_wr1chk|
        FunctionEntry
        CMP     a1, #&8000
        BLT     writefail
        LoadStaticBase ip, lr
        LDR     lr, [ip, #O_app_space_end]
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
        B       writefail

|__rt_wr2chk|
|_wr2chk|
        FunctionEntry
        CMP     a1, #&8000
        BLT     writefail
        TST     a1, #1
        BNE     writefail
        LoadStaticBase ip, lr
        LDR     lr, [ip, #O_app_space_end]
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
        B       writefail

|__rt_wr4chk|
|_wr4chk|
        FunctionEntry
        CMP     a1, #&8000
        BLT     writefail
        TST     a1, #3
        BNE     writefail
        LoadStaticBase ip, lr
        LDR     lr, [ip, #O_app_space_end]
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
        ; and drop into writefail
writefail
        LDR     lr, [sp], #4
        STR     r0, [sp, #-4]!
        ADR     r0, E_WriteFail
        B       |_kernel_fault|

readfail
        LDR     lr, [sp], #4
        STR     r0, [sp, #-4]!
        ADR     r0, E_ReadFail
        B       |_kernel_fault|

        ErrorBlock DivideByZero, "Divide by zero", C06
        ErrorBlock ReadFail, "Illegal read", C07
        ErrorBlock WriteFail, "Illegal write", C08

        MACRO
        NOOP
        & 0
        MEND

; Note that the number of instructions is critical for the SUBLT, hence the NOOPs
|_memcpy|
        FunctionEntry "v1"
01      SUBS    a3, a3, #16
        SUBLT   pc, pc, a3, ASL #2
        LDMIA   a2!, {a4, v1, ip, lr}
        STMIA   a1!, {a4, v1, ip, lr}
        BGT     %B01
        Return  "v1"
        NOOP

        LDMIA   a2!, {a4, v1, ip}
        STMIA   a1!, {a4, v1, ip}
        Return  "v1"
        NOOP

        LDMIA   a2!, {a4, v1}
        STMIA   a1!, {a4, v1}
        Return  "v1"
        NOOP

        LDR     a4, [a2], #4
        STR     a4, [a1], #4
        Return  "v1"

; Note that the number of instructions is critical for the SUBLT
|_memset|
        FunctionEntry
        MOV     a4, a2
        MOV     ip, a2
        MOV     lr, a2
01      SUBS    a3, a3, #16
        SUBLT   pc, pc, a3, ASL #1
        STMIA   a1!, {a2, a4, ip, lr}
        BGT     %B01
        Return

        STMIA   a1!, {a2, a4, ip}
        Return

        STMIA   a1!, {a2, a4}
        Return

        STR     a4, [a1], #4
        Return

mesg    DCB     "mesg"
      [ :DEF:DEFAULT_TEXT
postmortem_title
        DCB     "Postmortem", 0
      ]
postmortem_tag
        DCB     "C65", 0
        ALIGN

        IMPORT  |_desktop_task|
        IMPORT  |_kernel_unwind|
        IMPORT  exit
|_postmortem|
        ; Prepare window manager for output
        ; First check this is a wimp task
        STMFD   sp!, {r0-r5, r14}
        [ :DEF:DEFAULT_TEXT
        ADR     r0, postmortem_title
        ADR     r1, postmortem_tag
        |
        ADR     r0, postmortem_tag
        ]
        BL      |_kernel_getmessage|
        MOV     r5, r0
postmortem0
        LDMFD   sp, {a1-a2}
        LDR     a3, mesg                ; if magic arg2 != "mesg"
        CMP     a2, a3                  ; then go straight onto postmortem
        BNE     postmortem1
        MOV     a2, r5                  ; if so, offer postmortem
        BL      |_sys_msg_1|
        TEQ     r4, #1
        TEQ     a1, #0                  ; if didn't display the button
        TEQNE   a1, #3                  ; or if he selected it, then carry on with postmortem
        MOVNE   a1, #1                  ; otherwise exit(EXIT_FAILURE)
        BNE     exit
postmortem1
        BL      _desktop_task
        TEQ     a1, #0
        BEQ     postmortem2
        LoadStaticAddress __iob + 2 * 40, a2, a3 ; a2 -> stderr
        LDR     r4, [a2, #20]           ; a2 = stderr->__file
        TEQ     r4, #0                  ; istty(stderr->__file)?
        BNE     postmortem2
        MOV     r0, r5                  ; if desktop, and stderr = tty
        SWI     XWimp_CommandWindow     ; then open command window,
        SWI     XOS_WriteI + 14         ; page mode on
postmortem2
        LDMFD   sp!, {r0-r5}
        BL      |_kernel_fpavailable|
        LDR     r14, [sp], #4
        CMP     a1, #0
        MOV     ip, sp
        SUBEQ   sp, sp, #12*4
        BEQ     postmortem_nofp
        STFE    f7, [sp, #-12]!
        STFE    f6, [sp, #-12]!
        STFE    f5, [sp, #-12]!
        STFE    f4, [sp, #-12]!
postmortem_nofp
        STR     sl, [sp, #-4]!
        STMFD   sp!, {v1-v6, fp, ip, r14}
        ADD     a4, sp, #21*4
        LDMDB   a4!, {v1-v6, ip}
        STMFD   sp!, {v1-v6, ip}
        LDMDB   a4!, {v1-v6, ip}
        STMFD   sp!, {v1-v6, ip}
        LDMDB   a4!, {v1-v6, ip}
        STMFD   sp!, {v1-v6, ip}
        SUB     sp, sp, #4
        MOV     v1, #4
02      SUBS    v1, v1, #1
        BLT     %F01
        ADD     a2, sp, #0
        ADD     a1, sp, #4
        BL      |_kernel_unwind|
        CMP     a1, #0
        BLE     %F01
        LDR     a1, [sp, #4+8*4]
        RemovePSRFromReg a1, a2         ; Remove PSR bits safely if necessary
        ADR     a2, Raised
        CMP     a1, a2
        BNE     %B02

        LDR     a1, [sp, #4+7*4]
        ADD     a2, sp, #4
        ADD     a3, sp, #4+21*4
        LDMIA   a3, {v1-v6}
        STMFD   sp!, {v1-v6}
        LDR     a4, [a1]
        LDMFD   a2!, {v1-v6, ip}
        STMIA   a3!, {v1-v6, ip}
        LDMFD   a2!, {v1-v6, ip}
        LDR     r14, [a3, #4]
        LDR     v2, [a4, #pc*4]
        STMIA   a3!, {v1-v6, ip}
        LDMFD   a2!, {v1-v6, ip}
        STMIA   a3!, {v1-v6, ip}
        LDR     a2, [a4, #r0*4]
        LDR     a1, [a1, #4]
        LDMFD   sp!, {v1-v6}
        B       %F02

01
        LDR     v1, [sp, #4+21*4]
        LDR     r14, [sp, #4+(21+8)*4]
        MOV     a1, #-1
        MOV     a2, #0
02
        ADD     sp, sp, #22*4
        MOV     a3, sp
        B       |_backtrace|
        ;MOV     a1, #&4000
        ;MOV     a2, #&4000
        ;MOV     a3, #&20
        ;MOV     a4, #&FF
        ;SWI     XOS_ReadLine
        ;MOVCS   a1, #124
        ;SWICS   XOS_Byte
        ;SWI     XWimp_CloseDown
        ;ADR     a1, debug_cmd
        ;SWI     XOS_CLI
        ;MOVVC   a1, #0
        ;LDRVS   a1, [a1]
        ;TEQ     a1, #0
        ;TEQNE   a1, #&11
        ;MOVEQ   a1, #-1
        ;SWIEQ   XWimp_CommandWindow
        ;MOV     a1, #1
        ;B       exit

debug_cmd
        DCB     "Debug", 0
        ALIGN

|__rt_stkovf_split_small|
|x$stack_overflow|
        B       |_kernel_stkovf_split_0frame|

|__rt_stkovf_split_big|
|x$stack_overflow_1|
        B       |_kernel_stkovf_split|

|_exit|
        [ No32bitCode
        TST     r14, #3
        |
        MRS     a4, CPSR
        TST     a4, #2_01111             ; EQ if USR26 or USR32
        ]
        BLEQ    |_kernel_setreturncode|  ; BL<cond> 32-bit OK
        B       |_kernel_exit|


        ^ 0
sj_v1   #       4
sj_v2   #       4
sj_v3   #       4
sj_v4   #       4
sj_v5   #       4
sj_v6   #       4
  [ {CONFIG}=26
sj_fp   #       4       ; Old APCS-A ordering, which we retain
sj_sp   #       4       ; for compatibility in the 26-bit case
sj_sl   #       4       ; (someone might poke jmp_bufs)
  |
sj_sl   #       4
sj_fp   #       4
sj_sp   #       4
 ]
sj_pc   #       4
sj_f4   #       3*4
sj_f5   #       3*4
sj_f6   #       3*4
sj_f7   #       3*4

|setjmp|
; save everything that might count as a register variable value.
  [ {CONFIG}=26
        STMIA   a1!, {v1-v6, fp, sp}
        STMIA   a1, {sl, lr}
        SUB     v1, a1, #sj_sl
  |
      [ {FALSE} ; this instruction is now deprecated
        STMIA   a1, {v1-v6, sl, fp, sp, lr}
      |
        STMIA   a1!, {v1-v6, sl, fp}
        STR     lr, [a1, #sj_pc - sj_sp]
        STR     sp, [a1], #-sj_sp
      ]
        MOV     v1, a1
  ]
        MOV     v2, lr
        BL      |_kernel_fpavailable|
        CMP     a1, #0
  [ {CONFIG}=26
        STFNEE  f4, [v1, #sj_f4]
        STFNEE  f5, [v1, #sj_f5]
        STFNEE  f6, [v1, #sj_f6]
        STFNEE  f7, [v1, #sj_f7]
  |
        SFMNE   f4, 4, [v1, #sj_f4]
  ]
        MOV     a1, #0
        MOV     lr, v2
        LDMIA   v1, {v1, v2}
        Return  ,LinkNotStacked

|longjmp|
        ADD     v1, a1, #sj_f4
        MOVS    v6, a2
        MOVEQ   v6, #1   ; result of setjmp == 1 on longjmp(env, 0)

        LoadStaticBase ip, a1
        LDRB    a1, [ip, #O_inSignalHandler]
        CMP     a1, #0
        MOVNE   a1, #0
        STRNEB  a1, [ip, #O_inSignalHandler]
        BLNE    |_kernel_exittraphandler|       ; BL<cond> 32-bit OK

        BL      |_kernel_fpavailable|
        CMP     a1, #0
 [ {CONFIG}=26
        LDFNEE  f7, [v1, #sj_f7-sj_f4]
        LDFNEE  f6, [v1, #sj_f6-sj_f4]
        LDFNEE  f5, [v1, #sj_f5-sj_f4]
        LDFNEE  f4, [v1, #sj_f4-sj_f4]
        LDMDB   v1!, {v2-v5}                    ; fudge for atomic {sp,sl,fp} update
        STMFD   sp!, {v2, v3}                   ; push fp, sp
        STR     v4, [sp, #-4]!                  ; push sl
        LDMFD   sp, {sl, fp, sp}
 |
        LFMNE   f4, 4, [v1, #sj_f4-sj_f4]
      [ {FALSE} ; this instruction is now deprecated
        LDMDB   v1!, {sl, fp, sp, lr}
      |
        LDR     lr, [v1, #sj_pc - sj_f4]!
        LDR     sp, [v1, #sj_sp - sj_pc]!
        LDMDB   v1!, {sl, fp}
      ]
        MOV     v5, lr
 ]

 [ ModeMayBeNonUser
   [ {CONFIG}=26
        MOV     a1, pc
        TST     a1, #3
   |
        MRS     a1, CPSR
        MOVS    a1, a1, LSL #28
        TEQHI   a1, #&F0000000                  ; EQ if USR26, USR32 or SYS32
   ]
        BNE     chunks_deallocated
 ]

        ; Now discard all unwanted stack chunks which are deallocatable.
        LDR     v2, [sl, #SC_next-SC_SLOffset]  ; first extension chunk
        ADD     v4, sl, #SC_next-SC_SLOffset    ; base of extension chain
        CMP     v2, #0
        BEQ     chunks_deallocated
deallocate_chunks
        LDR     ip, [v2, #SC_deallocate]
        LDR     v3, [v2, #SC_next]              ; chunk after next
        CMPS    ip, #0
        ADDEQ   v4, v2, #SC_next                ; if it can't be deallocated
        BEQ     deallocate_next_chunk           ; retain it
        MOV     a1, v2
        MOV     lr, pc                          ;) deallocate it if it can be
        MOV     pc, ip                          ;) deallocated, and update the
        STR     v3, [v4]                        ;) chain.
deallocate_next_chunk
        MOVS    v2, v3
        BNE     deallocate_chunks

chunks_deallocated
        MOV     lr, v5
        MOV     a1, v6
        LDMDB   v1, {v1-v6}

        Return  ,LinkNotStacked


|_oswrch|
        B       |_kernel_oswrch|

|_osbget|
        B       |_kernel_osbget|

|_osbput|
        B       |_kernel_osbput|

|_osgbpb|
        STMFD   sp!, {a3, a4, v1, v2, v3} ; v1-v3 just to reserve space
        STR     r14, [sp, #-4]!
        ADD     a3, sp, #4
        BL      |_kernel_osgbpb|
        CMP     a1, #-2
        LDRNE   a1, [sp, #8]            ; new value of len
        LDR     r14, [sp], #4
        ADD     sp, sp, #5*4
        Return  ,LinkNotStacked

|_osgbpb1|
        B       |_kernel_osgbpb|

|_osrdch|
        B       |_kernel_osrdch|

|_osword|
        B       |_kernel_osword|

|_osfind|
        B       |_kernel_osfind|

|_osfile|
        STMFD   sp!, {a3, a4, v1, v2}  ; v1,v2 just to reserve space
        STR     r14, [sp, #-4]!
        ADD     a3, sp, #4
        BL      |_kernel_osfile|
        LDR     r14, [sp], #4
        ADD     sp, sp, #4*4
        Return  ,LinkNotStacked

|_osfile1|
        B       |_kernel_osfile|

|_osargs|
        B       |_kernel_osargs|

|_oscli|
        B       |_kernel_oscli|

|_osbyte|
        B       |_kernel_osbyte|

        LTORG

; double _ldfp(void *x) converts packed decimal at x to a double

|_ldfp| DisableFPInterrupts
        LDFP    f0, [r0, #0]
        MVFD    f0, f0       ; (round to D format)
        ReEnableFPInterrupts
        TST     r1, #&F
        Return  ,LinkNotStacked, EQ
        TST     r1, #&7
        BNE     ldfp_overflow
        B       underflow_error

; void _stfp(double d, void *x) stores packed decimal at x
|_stfp|
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        STFP    f0, [r2, #0]
        |
        STFP    f0, [r0, #0]
        ]
        Return  ,LinkNotStacked

FP_ZERO      * 0
FP_SUBNORMAL * 1
FP_NORMAL    * 2
FP_INFINITE  * 3
FP_NAN       * 4

; These functions always take arguments in registers, to prevent
; signalling NaN problems. The wrapper macros ensure they are
; passed the correct type, so the initial store can't cause an
; exception.
|__fpclassifyf|
        STFS    f0, [sp, #-4]!
        LDR     r0, [sp], #4
        BICS    r0, r0, #&80000000      ; ignore sign; EQ if Exp and M == 0 (and r0 == 0 == FP_ZERO)
        ASSERT  FP_ZERO = 0
        Return  ,LinkNotStacked,EQ
        MOVS    r2, r0, LSR #23         ; R2 := Exp; EQ if Exp == 0
        MOVEQ   r0, #FP_SUBNORMAL
        Return  ,LinkNotStacked,EQ
        TEQ     r2, #&ff
        MOVNE   r0, #FP_NORMAL
        Return  ,LinkNotStacked,NE
        MOVS    r2, r0, LSL #9          ; R2 := M; EQ if M == 0
        MOVEQ   r0, #FP_INFINITE
        MOVNE   r0, #FP_NAN
        Return  ,LinkNotStacked

|__fpclassifyd|
        STFD    f0, [sp, #-8]!
        LDMIA   sp!, {r0, r1}
        BICS    r0, r0, #&80000000      ; ignore sign; EQ if Exp and MHi == 0
        TEQEQS  r1, #0                  ; EQ if Exp and M == 0 (and r0 == 0 == FP_ZERO)
        ASSERT  FP_ZERO = 0
        Return  ,LinkNotStacked,EQ
        MOVS    r2, r0, LSR #20         ; R2 := Exp; EQ if Exp == 0
        MOVEQ   r0, #FP_SUBNORMAL
        Return  ,LinkNotStacked,EQ
        ADDS    r0, r0, #&00100000      ; If Exp = &7FF then R0 := &800xxxxx, so MI
        MOVPL   r0, #FP_NORMAL
        Return  ,LinkNotStacked,PL
        ORRS    r0, r1, r0, LSL #1      ; Look for any non-zero bits (except top bit of R0)
        MOVEQ   r0, #FP_INFINITE
        MOVNE   r0, #FP_NAN
        Return  ,LinkNotStacked

|__signbitf|
        STFS    f0, [sp, #-4]!
        LDR     r0, [sp], #4
        MOV     r0, r0, LSR #31
        Return  ,LinkNotStacked

|__signbitd|
        STFD    f0, [sp, #-8]!
        LDR     r0, [sp], #8
        MOV     r0, r0, LSR #31
        Return  ,LinkNotStacked

        [ FloatingPointArgsInRegs
copysign
        ]
|__copysignd|
        STFD    f1, [sp, #-8]!
        LDR     r0, [sp], #8
        TEQ     r0, #0
        ABSD    f0, f0
        MNFMID  f0, f0
        Return  ,LinkNotStacked

        [ FloatingPointArgsInRegs
copysignf
        ]
|__copysignf|
        STFS    f1, [sp, #-4]!
        LDR     r1, [sp], #4
        TEQ     r1, #0              ; MI if y negative
        ABSS    f0, f0
        MNFMIS  f0, f0
        Return  ,LinkNotStacked

; Back to normal calling conventions

        [ :LNOT:FloatingPointArgsInRegs
copysign
        TEQ     r0, r2
        EORMI   r0, r0, #&80000000
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        Return  ,LinkNotStacked

copysignf
        ; Okay, arguments aren't caller-narrowed. However, narrowing
        ; _always_ preserves sign. Therefore safe to manipulate sign bits
        ; of double forms. If the MVFS triggers a signalling NaN, the
        ; quiet NaN result retains the sign of the (modified) signalling
        ; NaN.
        TEQ     r0, r2
        EORMI   r0, r0, #&80000000
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        MVFS    f0, f0
        Return  ,LinkNotStacked
        ]

nexttoward
        NOP
nextafter
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        CMF     f1, f0
        BEQ     copysign
        BGT     nextup
        BMI     nextdown
        ; unordered
        ADFD    f0, f0, f1              ; do the NaN propagation + exceptions
        Return  ,LinkNotStacked

nextup
        [ FloatingPointArgsInRegs
        STFD    f0, [sp, #-8]!
        LDMFD   sp!, {r0, r1}
        ]
        TEQ     r0, #0
        BPL     nextbigger
        BMI     nextsmaller_neg

nextdown
        [ FloatingPointArgsInRegs
        STFD    f0, [sp, #-8]!
        LDMFD   sp!, {r0, r1}
        ]
        TEQ     r0, #0
        BPL     nextsmaller_pos
        BMI     nextbigger

nextbigger
        CMN     r0, #&00100000
        Return  ,LinkNotStacked,CS      ; catch infinity (NaN already done)
        Return  ,LinkNotStacked,VS

nextbigger_finite
; For all finite cases (both +ve and -ve), it's just a 64-bit +1:
;
; 00000000 00000000 -> 00000000 00000001   0 => smallest subnormal
; 000FFFFF FFFFFFFF -> 00100000 00000000   largest subnormal => smallest normal
; 7FEFFFFF FFFFFFFF -> 7FF00000 00000000   largest normal => infinity
        ADDS    r1, r1, #1
        ADC     r0, r0, #0
        BIC     r2, r0, #&80000000
        CMN     r2, #&00100000
        BVS     nextbigger_ovf
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        CMP     r2, #&00100000
        BLO     nextafter_ufl
        Return  ,LinkNotStacked

nextbigger_ovf
        MUFS    f0,f0,#2                ; generate OVF+INX
        Return  ,LinkNotStacked

nextsmaller_pos
; 7FF00000 00000000 -> 7FEFFFFF FFFFFFFF   +infinity => largest +ve normal
; 00100000 00000000 -> 000FFFFF FFFFFFFF   smallest +ve normal => largest +ve subnormal
; 00000000 00000001 -> 00000000 00000000   smallest +ve subnormal => +0
; 00000000 00000000 -> FFFFFFFF FFFFFFFF      clears carry, so we can catch +0 => -ve case
        SUBS    r1, r1, #1
        SBCS    r0, r0, #0
        STMCSFD sp!, {r0, r1}
        LDFCSD  f0, [sp], #8
        LDFCCD  f0, tiny_neg            ; +0 => smallest -ve subnormal
        CMPCS   r0, #&00100000
        Return  ,LinkNotStacked,CS

nextafter_ufl
        LDFD    f1,tiny_pos             ; generate UFL+INX
        MUFD    f1,f1,#0.5
        Return  ,LinkNotStacked

nextsmaller_neg
; FFF00000 00000000 -> FFEFFFFF FFFFFFFF   -infinity => largest -ve normal
; 80100000 00000000 -> 800FFFFF FFFFFFFF   smallest -ve normal => largest -ve subnormal
; 80000000 00000001 -> 80000000 00000000   smallest -ve subnormal => -0
; 80000000 00000000 -> 7FFFFFFF FFFFFFFF      sets overflow, so we can catch -0 => +ve case
        SUBS    r1, r1, #1
        SBCS    r0, r0, #0
        STMVCFD sp!, {r0, r1}
        LDFVCD  f0, [sp], #8
        LDFVSD  f0, tiny_pos            ; -0 => smallest +ve subnormal
        CMPVC   r0, #&00100000
        Return  ,LinkNotStacked,VC
        B       nextafter_ufl

nextafterf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        MVFS    f1, f1
        [ :LNOT:FloatingPointArgsInRegs
        B       nexttowardf_2
        ]

nexttowardf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
nexttowardf_2
        MVFS    f0, f0
        CMF     f1, f0
        BEQ     copysignf
        BGT     nextupf
        BMI     nextdownf
        ; unordered
        ADFS    f0, f0, f1              ; do the NaN propagation + exceptions
        Return  ,LinkNotStacked

nextupf
        STFS    f0, [sp, #-4]!
        LDR     r0, [sp], #4
        TEQ     r0, #0
        BPL     nextbiggerf
        BMI     nextsmallerf_neg

nextdownf
        STFS    f0, [sp, #-4]!
        LDR     r0, [sp], #4
        TEQ     r0, #0
        BPL     nextsmallerf_pos
        BMI     nextbiggerf

nextbiggerf
        ADD     r1, r0, #&00800000      ; spot infinities - NaNs already
        TEQ     r0, r1                  ; caught in nexttowardf. Return
        Return  ,LinkNotStacked,MI      ; them unchanged (MI if +/-inf)

; For all finite cases (both +ve and -ve), it's just a 32-bit +1:
;
; 00000000 -> 00000001   0 => smallest subnormal
; 007FFFFF -> 00800000   largest subnormal => smallest normal
; 7F7FFFFF -> 7F800000   largest normal => infinity
        ADD     r0, r0, #1
        BIC     r2, r0, #&80000000
        CMN     r2, #&00800000
        BVS     nextbigger_ovf
        STR     r0, [sp, #-4]!
        LDFS    f0, [sp], #4
        CMP     r2, #&00800000
        BCC     nextafter_ufl
        Return  ,LinkNotStacked

nextsmallerf_pos
; 7F800000 -> 7F7FFFFF   +infinity => largest +ve normal
; 00800000 -> 007FFFFF   smallest +ve normal => largest +ve subnormal
; 00000001 -> 00000000   smallest +ve subnormal => +0
; 00000000 -> FFFFFFFF      clears carry, so we can catch +0 => -ve case
        SUBS    r0, r0, #1
        STRCS   r0, [sp, #-4]!
        LDFCSS  f0, [sp], #4
        LDFCCS  f0, tiny_negf           ; -0 => smallest +ve subnormal
        CMPCS   r0, #&00800000
        BCC     nextafter_ufl
        Return  ,LinkNotStacked

nextsmallerf_neg
; FF800000 -> FF7FFFFF   -infinity => largest -ve normal
; 80800000 -> 807FFFFF   smallest -ve normal => largest -ve subnormal
; 80000001 -> 80000000   smallest -ve subnormal => -0
; 80000000 -> 7FFFFFFF      sets overflow, so we can catch -0 => +ve case
        SUBS    r0, r0, #1
        STRVC   r0, [sp, #-4]!
        LDFVCS  f0, [sp], #4
        LDFVSS  f0, tiny_posf           ; -0 => smallest +ve subnormal
        CMPVC   r0, #&00800000
        BVS     nextafter_ufl
        Return  ,LinkNotStacked

tiny_neg
        DCD     &80000000
        DCD     &00000001
tiny_pos
        DCD     &00000000               ; shares next word
tiny_posf
        DCD     &00000001
tiny_negf
        DCD     &80000001

fmax
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        CMF     f1, f0
        MVFGTD  f0, f1
        BVS     fcmpnan
        Return  ,LinkNotStacked,NE
        ; Values are equal. Anding the sign bits will give nice behaviour
        ; for fmax(�0, �0).
        [ FloatingPointArgsInRegs
        STFD    f1, [sp, #-8]!
        STFD    f0, [sp, #-8]!
        LDMIA   sp!, {r0-r3}
        ]
        AND     r0, r0, r2
        STMFD   sp!, {r0,r1}
        LDFD    f0, [sp], #8
        Return  ,LinkNotStacked

fcmpnan CMF     f0, #0
        MVFVSD  f0, f1
        Return  ,LinkNotStacked

fmaxf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        MVFS    f0, f0
        MVFS    f1, f1
        CMF     f1, f0
        MVFGTS  f0, f1
        BVS     fcmpnanf
        Return  ,LinkNotStacked,NE
        [ FloatingPointArgsInRegs
        STFS    f1, [sp, #-4]!
        STFS    f0, [sp, #-4]!
        LDMIA   sp!, {r0-r1}
        ]
        AND     r0, r0, r1
        STR     r0, [sp, #-4]!
        LDFS    f0, [sp], #4
        Return  ,LinkNotStacked

fcmpnanf
        CMF     f0, #0
        MVFVSS  f0, f1
        Return  ,LinkNotStacked

fmin
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        CMF     f1, f0
        MVFMID  f0, f1
        BVS     fcmpnan
        Return  ,LinkNotStacked,NE
        ; Values are equal. Oring the sign bits will give nice behaviour
        ; for fmin(�0, �0).
        [ FloatingPointArgsInRegs
        STFD    f1, [sp, #-8]!
        STFD    f0, [sp, #-8]!
        LDMIA   sp!, {r0-r3}
        ]
        ORR     r0, r0, r2
        STMFD   sp!, {r0,r1}
        LDFD    f0, [sp], #8
        Return  ,LinkNotStacked

fminf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        MVFS    f0, f0
        MVFS    f1, f1
        CMF     f1, f0
        MVFMIS  f0, f1
        BVS     fcmpnanf
        Return  ,LinkNotStacked,NE
        [ FloatingPointArgsInRegs
        STFS    f1, [sp, #-4]!
        STFS    f0, [sp, #-4]!
        LDMIA   sp!, {r0-r1}
        ]
        ORR     r0, r0, r2
        STR     r0, [sp, #-4]!
        LDFS    f0, [sp], #4
        Return  ,LinkNotStacked

nearbyint
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0,r1}
        LDFD    f0, [sp], #8
        ]
        DisableFPInterrupts
        RNDD    f0, f0
        ReEnableFPInterrupts nocheck
        Return  ,LinkNotStacked

nearbyintf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0,r1}
        LDFD    f0, [sp], #8
        ]
        MVFS    f0, f0
        DisableFPInterrupts
        RNDS    f0, f0
        ReEnableFPInterrupts nocheck
        Return  ,LinkNotStacked

round
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0,r1}
        LDFD    f0, [sp], #8
        ]
        CMF     f0, #0
        Return  ,LinkNotStacked,EQ      ; return +/-0 intact
        DisableFPInterrupts             ; just to prevent "inexact"
        ABSMID  f0, f0
        ADFD    f0, f0, #0.5
        RNDDZ   f0, f0
        MNFMID  f0, f0
        ReEnableFPInterrupts nocheck
        Return  ,LinkNotStacked

roundf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0,r1}
        LDFD    f0, [sp], #8
        ]
        MVFS    f0, f0
        CMF     f0, #0
        Return  ,LinkNotStacked,EQ      ; return +/-0 intact
        DisableFPInterrupts             ; just to prevent "inexact"
        ABSMIS  f0, f0
        ADFS    f0, f0, #0.5
        RNDSZ   f0, f0
        MNFMIS  f0, f0
        ReEnableFPInterrupts nocheck
        Return  ,LinkNotStacked

lround
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0,r1}
        LDFD    f0, [sp], #8
        ]
lround2 RFS     ip
        AND     r2, ip, #&10            ; remember cumulative flag
        BIC     r1, ip, #&10            ; clear cumulative inexact flag
        WFS     r1
        FIX     r0, f0                  ; may trap - that's okay
        RFS     r1
        TST     r1, #&10                ; was inexact?
        BEQ     %FT10
        ; If we get here, we know inexact traps are disabled, and result is inexact
        CMF     f0, #0
        ADFGTD  f0, f0, #0.5            ; no new exceptions possible
        SUFMID  f0, f0, #0.5
        FIXZ    r0, f0
10      ORR     r1, r1, r2              ; re-cumulate inexact flag
        WFS     r1
        Return  ,LinkNotStacked

lroundf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0,r1}
        LDFD    f0, [sp], #8
        ]
        MVFS    f0, f0
        B       lround2

remainder
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        RMFD    f0, f0, f1
        Return  ,LinkNotStacked

remainderf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        MVFS    f0, f0
        MVFS    f1, f1
        RMFS    f0, f0, f1
        Return  ,LinkNotStacked

exp
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        EXPD    f0, f0
        ReEnableFPInterrupts
        TST     r1, #&0F
        Return  ,LinkNotStacked, EQ
        TST     r1, #8
        BNE     underflow_error
        B       huge_error

ldfp_overflow
        LDR     r0, [r0, #0]
        CMPS    r0, #0
        BPL     huge_error
huge_negative_result
        MOV     r0, #ERANGE
        LDFD    f0, negative_huge_val   ; @@@@@@@@!!!!
Set_errno
        LoadStaticAddress |__errno|, r1
        STR     r0, [r1, #0]
        Return  ,LinkNotStacked
negative_huge_val
        DCD     &FFEFFFFF               ; put constant where it is easy to find
        DCD     &FFFFFFFF

huge_error
        MOV     r0, #ERANGE
        LDFD    f0, huge_val            ; @@@@@@@@!!!!
        B       Set_errno
dbl_max
huge_val
        DCD     &7FEFFFFF               ; put constant where it is easy to find
        DCD     &FFFFFFFF
flt_max
        DCD     &7F7FFFFF

negative_error
        MOV     r0, #EDOM
        LDFD    f0, negative_huge_val   ; @@@@@@@@!!!!
        B       Set_errno

underflow_error
        MOV     r0, #ERANGE
;        MVFD    f0, #0
        B       Set_errno

log10
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        CMF     f0, #0
        BEQ     huge_negative_result
        BMI     negative_error
        LOGD    f0, f0
        Return  ,LinkNotStacked

log
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        CMF     f0, #0
        BEQ     huge_negative_result
        BMI     negative_error
        LGND    f0, f0
        Return  ,LinkNotStacked

log2
        [ FloatingPointArgsInRegs
        STFD    f0, [sp, #-8]!
        LDMFD   sp!, {r0, r1}
        |
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        ; Now argument is in both {r0,r1} and f0
        CMF     f0, #0
        BLE     log2_calc               ; for <=0 or NaN, just do normal log to get errors
        ; Argument is strictly positive and finite
        MOVS    r2, r0, LSR #20         ; r2 = exponent field
        BNE     %FT30
        ; Subnormal case - normalise
        MOV     r2, #1
10      ADDS    r1, r1, r1
        ADCS    r0, r0, r0
        SUB     r2, r2, #1
        TST     r0, #&00100000
        BEQ     %BT10
30      ORRS    r3, r1, r0, LSL #12     ; EQ if exact power of 2
        ; If exact, just convert exponent field to FP, else
        ; compute log2(e)*log(x)
        BEQ     log2_exact
log2_calc
        LDFE    f1, log2_e
        LGNE    f0, f0
        MUFD    f0, f0, f1
        Return  ,LinkNotStacked
log2_exact
        SUB     r2, r2, #&400
        ADD     r2, r2, #1
        TEQ     r2, #&400               ; EQ if infinity
        FLTNED  f0, r2
        Return  ,LinkNotStacked

log2f
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        MVFS    f0, f0
        STFS    f0, [sp, #-4]!
        LDR     r0, [sp], #4
        ; Now argument is in both r0 and f0
        CMF     f0, #0
        BLE     log2f_calc              ; for <=0 or NaN, just do normal log to get errors
        ; Argument is strictly positive and finite
        MOVS    r2, r0, LSR #23         ; r2 = exponent field
        MOV     r0, r0, LSL #9          ; r0 = fraction
        BNE     %FT30
        ; Subnormal case - normalise
        MOV     r2, #1
10      ADDS    r0, r0, r0
        SUB     r2, r2, #1
        BCC     %BT10
30      TEQ     r0, #0                  ; EQ if exact power of 2
        ; If exact, just convert exponent field to FP, else
        ; compute log2(e)*log(x)
        BEQ     log2f_exact
log2f_calc
        LDFE    f1, log2_e
        LGNE    f0, f0
        MUFS    f0, f0, f1
        Return  ,LinkNotStacked
log2f_exact
        SUB     r2, r2, #&400
        ADD     r2, r2, #1
        TEQ     r2, #&400               ; EQ if infinity
        FLTNES  f0, r2
        Return  ,LinkNotStacked

log2_e  DCD     &00003FFF, &B8AA3B29, &5C17F0BC
loge_2  DCD     &00003FFE, &B17217F7, &D1CF79AC

        IMPORT  scalbln
exp2
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        DisableFPInterrupts
        FIX     r0, f0
        ReEnableFPInterrupts
        ANDS    r1, r1, #&1F            ; inexact or invalid?
        BNE     exp2_inexact
        ; exp2 of an integer - can create an exact result using scalbn
        [ FloatingPointArgsInRegs
        MVFD    f0, #1
        |
        MOV     r2, r0
        ADR     r3, D_one
        LDMIA   r3, {r0,r1}
        ]
        B       scalbln
exp2_inexact
        LDFE    f1, loge_2
        MUFE    f0, f0, f1
        EXPD    f0, f0
        Return  ,LinkNotStacked

        IMPORT  scalblnf
exp2f
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        DisableFPInterrupts
        MVFS    f0, f0
        FIX     r0, f0
        ReEnableFPInterrupts
        ANDS    r1, r1, #&1F            ; inexact or invalid?
        BNE     exp2f_inexact
        ; exp2f of an integer - can create an exact result using scalbn
        [ FloatingPointArgsInRegs
        MVFS    f0, #1
        |
        MOV     r2, r0
        ADR     r3, D_one
        LDMIA   r3, {r0,r1}
        ]
        B       scalblnf
exp2f_inexact
        LDFE    f1, loge_2
        MUFE    f0, f0, f1
        EXPS    f0, f0
        Return  ,LinkNotStacked

D_one   DCFD    1
OneThird
        DCD     &00003FFD, &AAAAAAAA, &AAAAAAAB

sqrt
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        CMF     f0, #0
        BMI     negative_error          ; MI - <
        SQTGED  f0, f0                  ; GE - >=
        Return  ,LinkNotStacked

cbrt
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        CMF     f0, #0
        Return  ,LinkNotStacked,EQ
        LDFVCE  f1, OneThird
        ABSVCE  f0, f0
        POWVCD  f0, f0, f1
        MNFMID  f0, f0
        Return  ,LinkNotStacked

cbrtf
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        MVFS    f0, f0
        CMF     f0, #0
        Return  ,LinkNotStacked,EQ
        LDFVCE  f1, OneThird
        ABSVCE  f0, f0
        POWVCS  f0, f0, f1
        MNFMIS  f0, f0
        Return  ,LinkNotStacked

cos
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        COSD    f0, f0
        ReEnableFPInterrupts
        ; Only possible error is domain error (due to argument being too
        ; large for range reduction, ie |x| >= 2^31*pi in FPASC 1.13).
        TST     r1, #&07
        Return  ,LinkNotStacked, EQ
        B       negative_error

sin
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        SIND    f0, f0
        ReEnableFPInterrupts
        TST     r1, #&07
        Return  ,LinkNotStacked, EQ
        B       negative_error

tan
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        TAND    f0, f0
        ReEnableFPInterrupts
        TST     r1, #&07
        Return  ,LinkNotStacked, EQ
        TST     r1, #1
        BNE     negative_error
        B       huge_error

asin
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        ASND    f0, f0
        ReEnableFPInterrupts
        ; A range error is not possible; any error must be a domain error.
        ; (And the only plausible error flag is IVO, but I don't check).
        ; Dunno what result is sensible.
        TST     r1, #&07
        Return  ,LinkNotStacked, EQ
        B       negative_error

acos
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        ACSD    f0, f0
        ReEnableFPInterrupts
        ; A range error is not possible; any error must be a domain error.
        ; (And the only plausible error flag is IVO, but I don't check).
        ; Dunno what result is sensible.
        TST     r1, #&07
        Return  ,LinkNotStacked, EQ
        B       negative_error


pow
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1, r2, r3}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        |
        DisableFPInterrupts
        ]
        CMFE    f0, #0
        BEQ     POWFirstArgZero
        POWD    f0, f0, f1
        ReEnableFPInterrupts
        ; Plausibly, there may have been either an overflow or IVO error.
        ; I assume that the former is always a range error, and the latter
        ; corresponds to one of the possible C domain errors (first arg
        ; negative, second non-integer).
        ; (DVZ assumed impossible).
        TST     r1, #&0F
        Return  ,LinkNotStacked, EQ
        TST     r1, #1
        BNE     negative_error
        TST     r1, #8
        BNE     underflow_error
        B       huge_error

POWFirstArgZero
        CMFE    f1, #0
        MVFEQD  f0, #1              ; return 1.0 if both args 0.0
        ReEnableFPInterrupts
        Return  ,LinkNotStacked, GE
        B       negative_error

powf
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1, r2, r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        MVFS    f0, f0
        MVFS    f1, f1
        POWS    f0, f0, f1
        Return  ,LinkNotStacked

hypot
        [ FloatingPointArgsInRegs
        ABSD    f0, f0
        ABSD    f1, f1
        |
        BIC     r0, r0, #&80000000      ; faster than using ABS, even with FPA
        BIC     r2, r2, #&80000000
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        ADRL    r0, dbl_max             ; use dbl_max not inf to ensure FPA hardware used
        LDFD    f3, [r0]
        CMF     f0, f1
        BVS     hypot_nan
        MVFMID  f2, f0                  ; MI : <
        MVFMID  f0, f1
        MVFMID  f1, f2                  ; ensure f0 >= f1
        CMF     f0, #0                  ; if f0 == 0, then f1 == 0
        Return  ,LinkNotStacked, EQ     ;   divide will be invalid, bail out now
        CMF     f1, f3                  ; if f1 > dbl_max, then f0 == f1 == infinity
        Return  ,LinkNotStacked, GT     ;   divide will be invalid, bail out now
        DVFE    f2, f1, f0              ; 0 <= result <= 1; (only INX possible, not if F0=inf)
        MUFE    f2, f2, f2              ; (only INX possible)
        ADFE    f2, f2, #1              ; 1 <= result <= 2 (only INX possible)
        SQTE    f2, f2                  ; 1 <= result <= sqrt(2) (only INX possible)
        MUFD    f0, f0, f2              ; (OVF/INX possible)
        Return  ,LinkNotStacked
hypot_nan
        CMF     f1, f3
        MVFGTD  f0, f1
        CMFLE   f0, f3
        ADFLED  f0, f0, f1
        Return  ,LinkNotStacked


hypotf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
        ]
        ABSS    f0, f0
        ABSS    f1, f1
        ADRL    r0, flt_max
        LDFS    f3, [r0]
        CMF     f0, f1
        BVS     hypot_nan
        MVFMIS  f2, f0
        MVFMIS  f0, f1
        MVFMIS  f1, f2
        CMF     f0, #0                  ; if f0 == 0, then f1 == 0
        Return  ,LinkNotStacked, EQ     ;   divide will be invalid, bail out now
        CMF     f1, f3                  ; if f1 > flt_max, then f0 == f1 == infinity
        Return  ,LinkNotStacked, GT     ;   divide will be invalid, bail out now
        FDVE    f2, f1, f0
        MUFE    f2, f2, f2
        ADFE    f2, f2, #1
        SQTE    f2, f2
        MUFS    f0, f0, f2
        Return  ,LinkNotStacked
hypotf_nan
        CMF     f1, f3
        MVFGTS  f0, f1
        CMFLE   f0, f3
        ADFLES  f0, f0, f1
        Return  ,LinkNotStacked

|_count|                            ; used when profile option is enabled
        RemovePSRFromReg lr, ip
        LDR     ip, [lr, #0]
        ADD     ip, ip, #1
        STR     ip, [lr, #0]
        ADD     pc, lr, #4          ; condition codes are preserved because
                                    ; nothing in this code changes them!

; What follows is the newer version of support for the profile option,
; using extra space to record the position in the file that this
; count-point corresponds to.
|_count1|                           ; used when profile option is enabled
        RemovePSRFromReg lr, ip
        LDR     ip, [lr, #0]
        ADD     ip, ip, #1
        STR     ip, [lr, #0]
        ADD     pc, lr, #8          ; condition codes are preserved because
                                    ; nothing in this code changes them!


; Default stack overflow handler.

        ErrorBlock StackOverflow, "Stack overflow", C45

|_default_sigstak_handler|
        ADR     r0, E_StackOverflow
        BL      |_kernel_copyerror|
        B       |_kernel_raise_error|

        END
@


4.15
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d153 6
a158 6
        EXPORT  |__fpclassifyf|
        EXPORT  |__fpclassifyd|
        EXPORT  |__signbitf|
        EXPORT  |__signbitd|
        EXPORT  |__copysignf|
        EXPORT  |__copysignd|
d240 1
a240 1
        LDMFD   sp!, {r1}               ; free the RMA block addressed by
d270 1
a270 1
        STMFD   sp!, {r14}
d272 1
a272 1
        LDMFD   sp!, {r14}
d287 1
a287 1
        STMFD   sp!, {r14}
d289 1
a289 1
        LDMFD   sp!, {r14}
d346 1
a346 1
        STMFD   sp!, {a1}
d406 1
a406 1
        STMFD   sp!, {r0}
d485 2
a486 2
        LDMFD   sp!, {lr}
        STMFD   sp!, {r0}
d491 2
a492 2
        LDMFD   sp!, {lr}
        STMFD   sp!, {r0}
d526 2
a527 2
        LDMIA   a2!, {a4}
        STMIA   a1!, {a4}
d548 1
a548 1
        STMIA   a1!, {a4}
d601 1
a601 1
        LDMFD   sp!, {r14}
d734 1
d736 5
d784 1
d786 5
d844 1
a844 1
        STMFD   sp!, {r14}
d849 1
a849 1
        LDMFD   sp!, {r14}
d867 1
a867 1
        STMFD   sp!, {r14}
d870 1
a870 1
        LDMFD   sp!, {r14}
d1214 1
a1214 1
        ; for fmax(0, 0).
d1267 1
a1267 1
        ; for fmin(0, 0).
@


4.14
log
@  Bugfix and system mode support.
Detail:
  * Fixed signed pointer comparison: most top-bit-set pointers passed to
    _kernel_raise_error() were being translated into "Exit called"
  * Stack extension is now permitted in SYS mode; includes support in longjmp()
Admin:
  Verified that stack extension works.

Version 5.51. Tagged as 'RISC_OSLib-5_51'
@
text
@d24 1
a24 1
        GET     s.h_Stack
@


4.13
log
@<ctype.h> * isblank() added.
          * isprint() now true for non-breaking spaces
<math.h>  * FP_INFINITY corrected to FP_INFINITE
          * fma(), fmal(), llrint(), llrintf(), llrintl(),
            llround(), llroundf(), llroundl(),
            remquo(), remquof(), remquol() added.
          * added inlining for remainder() and fmaf() and various
            float functions.
          * math_errhandling removed pending overhaul - it was misleading.
          * expm1() and log1p() now provide decent (< 1 ulp) accuracy,
            rather than only being marginally better than exp(x)-1 and
            log(1+x).
          * new version of copysign() with standard calling conventions.
          * some C99 functions changed to use infinity/NaNs and exceptions
            for error handling - see comments in header file about the
            changes in progress.
<stdio.h>  * output from %a now correctly rounded
<stdlib.h> * strtof() and strtold() added.
<string.h> * strerror() no longer clears _kernel_last_oserror().

Version 5.49. Tagged as 'RISC_OSLib-5_49'
@
text
@d788 2
a789 1
        TST     a1, #2_01111                    ; EQ if USR26 or USR32
@


4.12
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d52 1
a52 1
        ; Disables all FP exceptions, remembering the exception mask in ip
d157 2
a187 2
        EXPORT  fmaf

a196 3
        EXPORT  expf
        EXPORT  expm1
        EXPORT  expm1f
a199 1
        EXPORT  log10f
a200 3
        EXPORT  logf
        EXPORT  log1p
        EXPORT  log1pf
a203 1
        EXPORT  sqrtf
d206 2
a208 1
        EXPORT  tanf
a209 1
        EXPORT  asinf
a210 1
        EXPORT  acosf
d879 1
a879 1
        ADFD    f0, f0, #0   ; (round to D format)
d901 1
a901 1
FP_INFINITY  * 3
d921 1
a921 1
        MOVEQ   r0, #FP_INFINITY
d939 1
a939 1
        MOVEQ   r0, #FP_INFINITY
d955 1
d957 2
d960 2
a961 2
        LDR     r2, [sp], #8
        TEQ     r2, #0              ; MI if y negative
d966 1
d968 2
d979 22
d1048 4
a1051 1
retval  STMFD   sp!, {r0, r1}
d1053 6
d1070 7
a1076 1
        LDFCCD  f0, tiny_neg            ; -0 => smallest +ve subnormal
d1089 3
a1091 1
        Return  ,LinkNotStacked
d1093 1
a1093 1
nexttowardf
d1099 4
a1102 8
        MVFS    f0, f0
        CMF     f1, f0
        BEQ     copysignf
        BGT     nextupf
        BMI     nextdownf
        ; unordered
        ADFS    f0, f0, f1              ; do the NaN propagation + exceptions
        Return  ,LinkNotStacked
d1104 1
a1104 1
nextafterf
d1110 1
a1111 1
        MVFS    f1, f1
d1137 1
a1137 1
                                        ; them unchanged (MI if +/-inf)
d1144 8
a1151 3
        ADDPL   r0, r0, #1
        STRPL   r0, [sp, #-4]!
        LDFPLS  f0, [sp], #4
d1163 2
d1176 2
d1184 1
a1184 1
        DCD     &00000000
d1198 14
a1211 1
        Return  ,LinkNotStacked,VC
d1226 16
a1241 2
        Return  ,LinkNotStacked,VC
        B       fcmpnan
d1251 13
a1263 2
        Return  ,LinkNotStacked,VC
        B       fcmpnan
d1275 6
a1280 8
        Return  ,LinkNotStacked,VC
        B       fcmpnan

fmaf
        [ :LNOT:FloatingPointArgsInRegs
        STMFD   sp!, {r0-r3}
        LDFD    f0, [sp], #8
        LDFD    f1, [sp], #8
d1282 3
a1284 6
        LDFD    f2, [sp, #0]
        MVFS    f0, f0
        MVFS    f1, f1
        MVFS    f2, f2
        MUFE    f0, f0, f1              ; totally accurate result
        ADFS    f0, f0, f2
a1396 1
exp_common
a1397 1
exp_exit
a1404 46
expf
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        MVFS    f0, f0
expf_common
        EXPS    f0, f0
expf_exit
        ReEnableFPInterrupts
        TST     r1, #&0F
        Return  ,LinkNotStacked, EQ
        TST     r1, #8
        BNE     underflow_error
        B       huge_errorf

; Mickey-mouse implementations, but they are still better than the user
; doing it, because of intermediate extended precision.
expm1
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        EXPE    f0, f0
        SUFD    f0, f0, #1
        B       exp_exit

expm1f
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        MVFS    f0, f0
        EXPE    f0, f0
        SUFS    f0, f0, #1
        B       expf_exit

d1424 1
d1428 2
a1429 15

huge_negative_resultf
        MOV     r0, #ERANGE
        LDFS    f0, negative_huge_valf
        B       Set_errno
negative_huge_valf
        DCD     &FF800000

huge_errorf
        MOV     r0, #ERANGE
        LDFS    f0, huge_valf
        B       Set_errno
huge_valf
infinity
        DCD     &7F800000
a1435 5
negative_errorf
        MOV     r0, #EDOM
        LDFS    f0, negative_huge_valf  ; @@@@@@@@!!!!
        B       Set_errno

a1451 12
log10f
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        MVFS    f0, f0
        CMF     f0, #0
        BEQ     huge_negative_resultf
        BMI     negative_errorf
        LOGGTS  f0, f0
        Return  ,LinkNotStacked

d1460 1
a1460 40
        LGNGTD  f0, f0
        Return  ,LinkNotStacked

logf
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        MVFS    f0, f0
        CMF     f0, #0
        BEQ     huge_negative_resultf
        BMI     negative_errorf
        LGNGTS  f0, f0
        Return  ,LinkNotStacked

; Mickey-mouse implementations, but they are still better than the user
; doing it, because of intermediate extended precision.
log1p
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        CNF     f0, #1
        BEQ     huge_negative_result
        BMI     negative_error
        ADFGTE  f0, f0, #1
        LGNGTD  f0, f0
        Return  ,LinkNotStacked

log1pf
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        MVFS    f0, f0
        CNF     f0, #1
        BEQ     huge_negative_result
        BMI     negative_error
        ADFGTE  f0, f0, #1
        LGNGTS  f0, f0
d1473 1
a1473 3
        BEQ     huge_negative_result
        BMI     negative_error
        Return  ,LinkNotStacked,VS
d1488 1
d1510 1
a1510 3
        BEQ     huge_negative_result
        BMI     negative_error
        Return  ,LinkNotStacked,VS
d1524 1
a1542 1
        DisableFPInterrupts
d1544 1
a1544 1
        |
a1545 1
        ]
d1547 1
a1547 1
        CheckFPInterrupts
a1550 1
        ReEnableFPInterrupts nocheck
d1562 2
a1563 1
        B       exp_common
a1568 1
        DisableFPInterrupts
d1570 1
a1570 1
        |
a1571 1
        ]
d1574 1
a1574 1
        CheckFPInterrupts
a1577 1
        ReEnableFPInterrupts nocheck
d1589 2
a1590 1
        B       expf_common
d1602 2
a1603 13
        BMI     negative_error
        SQTGED  f0, f0
        Return  ,LinkNotStacked

sqrtf
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        MVFS    f0, f0
        CMF     f0, #0
        BMI     negative_errorf
        SQTGES  f0, f0
d1633 1
a1633 1
tan
d1641 1
a1641 1
        TAND    f0, f0
d1643 2
d1647 1
a1647 1
        B       huge_error
d1649 1
a1649 1
tanf
d1657 1
a1657 2
        MVFS    f0, f0
        TANS    f0, f0
d1661 1
a1661 1
        B       huge_errorf
d1663 1
a1663 1
asin
d1671 1
a1671 1
        ASND    f0, f0
a1672 3
        ; A range error is not possible; any error must be a domain error.
        ; (And the only plausible error flag is IVO, but I don't check).
        ; Dunno what result is sensible.
d1675 3
a1677 1
        B       negative_error
d1679 1
a1679 1
asinf
d1687 1
a1687 2
        MVFS    f0, f0
        ASNS    f0, f0
d1694 1
a1694 2
        B       negative_errorf

a1712 18
acosf
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        DisableFPInterrupts
        LDFD    f0, [sp], #8
        |
        DisableFPInterrupts
        ]
        MVFS    f0, f0
        ACSS    f0, f0
        ReEnableFPInterrupts
        ; A range error is not possible; any error must be a domain error.
        ; (And the only plausible error flag is IVO, but I don't check).
        ; Dunno what result is sensible.
        TST     r1, #&07
        Return  ,LinkNotStacked, EQ
        B       negative_errorf

a1725 1
POWCommonExit
d1740 7
a1749 1
        DisableFPInterrupts
a1751 2
        |
        DisableFPInterrupts
a1754 2
        CMFE    f0, #0
        BEQ     POWFirstArgZero
d1756 1
a1756 8
        B       POWCommonExit

POWFirstArgZero
        CMFE    f1, #0
        MVFEQD  f0, #1              ; return 1.0 if both args 0.0
        ReEnableFPInterrupts
        Return  ,LinkNotStacked, GE
        B       negative_error
d1763 1
a1763 1
        BIC     r0, r0, #&80000000      ; faster than using ABS later
d1769 2
a1770 2
        ADRL    r0, infinity
        LDFS    f3, [r0]
d1773 1
a1773 1
        MVFMID  f2, f0
d1775 11
a1785 15
        MVFMID  f1, f2
        CMF     f0, #0
        CMFNE   f1, f3
        MVFEQD  f0, f1
        Return  ,LinkNotStacked, EQ
        DisableFPInterrupts
        DVFE    f2, f1, f0              ; 0 <= result <= 1; may as well use extra precision
        MUFE    f2, f2, f2
        ADFE    f2, f2, #1              ; 1 <= result <= 2
        SQTE    f2, f2                  ; 1 <= result <= sqrt(2)
        MUFD    f0, f0, f2              ; this may overflow, but only slightly
        ReEnableFPInterrupts
        TST     r1, #4
        Return  ,LinkNotStacked, EQ
        B       huge_error
d1787 4
a1790 4
        CMF     f0, f3
        CMFNE   f1, f3
        MVFEQD  f0, f3
        ADFNED  f0, f0, f1
d1802 1
a1802 1
        ADRL    r0, infinity
d1809 4
a1812 5
        CMF     f0, #0
        CMFNE   f1, f3
        MVFEQS  f0, f1
        Return  ,LinkNotStacked, EQ
        DisableFPInterrupts
d1818 1
a1818 4
        ReEnableFPInterrupts
        TST     r1, #4
        Return  ,LinkNotStacked, EQ
        B       huge_errorf
d1820 4
a1823 4
        CMF     f0, f3
        CMFNE   f1, f3
        MVFEQS  f0, f3
        ADFNES  f0, f0, f1
@


4.11
log
@Added atoll, strtoll, strtoull, strtoimax, strtoumax, imaxabs and imaxdiv
functions to the standard C library.

Version 5.45. Tagged as 'RISC_OSLib-5_45'
@
text
@d61 6
d161 2
d186 2
d197 5
d203 1
d205 5
d212 2
d215 1
d217 1
d219 1
d221 1
d882 1
d982 2
a1198 1
 [ {FALSE}
a1211 1
 ]
d1323 1
d1325 1
d1333 46
d1402 7
a1425 2
negative_huge_valf
        DCD     &FF800000               ; put constant where it is easy to find
d1437 1
a1437 1
        CMFE    f0, #0
d1443 12
d1460 93
a1552 1
        CMFE    f0, #0
d1555 23
a1577 1
        LGND    f0, f0
d1580 64
d1649 1
a1649 1
        CMFE    f0, #0
d1651 1
a1651 1
        SQTD    f0, f0
d1660 1
a1660 1
        CMFE    f0, #0
d1662 28
a1689 1
        SQTS    f0, f0
a1705 1
 [ {FALSE}
a1719 1
 ]
d1738 18
d1774 18
d1805 1
d1820 16
d1854 2
a1855 1
        LDFS    f3, infinity
d1891 2
a1892 1
        LDFS    f3, infinity
@


4.10
log
@ROM build fixed for 64-bit stuff.
PCI added to swis.h
alloc.c updated to handle bigger slots (new code merged from ARM libraries)
Various 32-bit fixes for backtracing, and general trap handling.
Polite "Application is not 32-bit compatible" message.
Headers <stdint.h> and <inttypes.h> fixed to work in non-C99 mode.
txt changed to do new-style Delete behaviour

Version 5.44. Tagged as 'RISC_OSLib-5_44'
@
text
@d169 1
d171 1
d355 1
a356 1
imaxdiv
d367 1
@


4.9
log
@  How did we not notice this before?
Detail:
  Fixed a stack imbalance in _memcpy that's been there since 32-bitting.
Admin:
  Not tested yet.

Version 5.43. Tagged as 'RISC_OSLib-5_43'
@
text
@d166 5
@


4.8
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@a481 1
        STMFD   sp!, {v1, lr}
@


4.7
log
@Stray test code removed. Retagged.
@
text
@d101 2
a340 1
imaxdiv
d348 18
@


4.6
log
@* Added C99 functions floorf, ceilf, [l]rint[f], trunc[f], [l]round[f],
  nearbyint[f] and remainder[f].
* Added macros (only) for sinf, cosf, atanf.
* Requires cc 5.43

Version 5.39. Tagged as 'RISC_OSLib-5_39'
@
text
@a1227 3
        FIX     r0, f0
        FIXM    r0, f0
        FIXP    r0, f0
@


4.5
log
@Added the following C99 features:

  * snprintf(), vsnprintf(), vfscanf(), vscanf(), vsscanf()
  * hh, j, z and t printf length modifiers (indicating char, intmax_t, size_t
    and ptrdiff_t respectively)
  * Hexadecimal floating-point printing and scanning (%a/%A)
  * %F printf() specifier (upper-case form of %F)
  * Input/output of NaNs and Infinities
  * imaxdiv_t, imaxdiv(), strtoimax(), strtoumax() (simulated through macros)
  * <fenv.h>: feclearexcept(), fegetexceptflag(), feraiseexcept(),
              fesetexceptflag(), fetestexcept(), fegetround(), fesetround(),
              fegetenv(), feholdexcept(), fesetenv(), feupdateenv()
  * FLT_EVAL_METHOD, DECIMAL_DIG
  * hypot(), hypotf(), fabsf(), fdim(), fdimf(), fmax(), fmaxf(), fmin(),
    fminf()
  * INFINITY, NAN, fpclassify(), isfinite(), isinf(), isnan(), isnormal(),
    signbit(), copysign(), copysignf(), nan(), nanf(), nextafter(),
    nextafterf() isgreater(), isgreaterequal(), isless(), islessequal(),
    islessgreater(), isunordered()

This involves adding 36 new entries to the stubs. Current versions of the C
library will not fault client programs with such larger stubs, but will fill
in the extra entries with junk. Programs requiring the new functions will have
to RMEnsure this version of the Shared C Library.

This version of the C library has been fixed so that in future, any extra
unknown stubs entries will be filled in with a branch to zero, rather than
corrupted.

Requires cc 5.41 or later, both to build, and to make use of some of the extra
facilities.


Version 5.37. Tagged as 'RISC_OSLib-5_37'
@
text
@d61 1
a61 1
$Label  ReEnableFPInterrupts
d64 4
a67 1
$Label  RFS     r1
d169 8
a176 2
        EXPORT  sin
        EXPORT  cos
d181 1
a182 1
        EXPORT  atan
d186 2
d1159 3
a1161 3
sin
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
d1164 3
a1166 1
        SIND    f0, f0
d1169 3
a1171 4
 [ {FALSE}
sinf
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
d1175 18
a1192 1
        SINS    f0, f0
a1193 1
 ]
d1195 52
a1246 3
cos
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
d1248 1
d1250 1
a1250 1
        COSD    f0, f0
d1253 3
a1255 4
 [ {FALSE}
cosf
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
d1257 1
d1260 2
a1261 1
        COSS    f0, f0
a1262 1
 ]
d1308 1
a1359 1
 [ {FALSE}
a1369 1
 ]
a1401 8
atan
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
        LDFD    f0, [sp], #8
        ]
        ATND    f0, f0
        Return  ,LinkNotStacked

d1470 74
@


4.4
log
@Abort and error handling massively overhauled:
  Aborts now give standard error messages (Abort on Data Transfer at... etc)
  *ShowRegs now filled in after aborts
  assert(), abort(), "free failed" and standard signal handlers now use Wimp
    error boxes if in the desktop
  Postmortem button on error boxes to view the postmortem

Also, x$multiply, x$divide, __rt_sdiv, x$remainder, x$udivide, __rt_udiv and
x$uremainder optimised.

Version 5.35. Tagged as 'RISC_OSLib-5_35'
@
text
@d142 9
d161 5
d326 9
d842 306
d1156 11
d1175 11
d1225 7
d1237 7
d1246 1
a1246 1
        MVFD    f0, #0
d1281 13
d1307 17
@


4.3
log
@  Fix for strcmp().
  Fix for RISC_OSLib res() function.
Detail:
  Version 4.89 featured an improved strcmp() routine that didn't actually
    work properly (bug #4085).  The return values had the wrong sign if this
    optimised code was used and the string contained top-bit set chars.
  Removed that rlib.s.asmdefs hack as the comment in the makefile suggested.
    Nothing needs it any more as the assembler sources that require it now
    get via a -PD argument.
  res_ prefix function was still wrong as it failed to detect valid but wrong
    filenames, hence the "Make$Path not defined" errors in the latest tools
    release.
Admin:
  Fixes Bugzilla bug #4085
  Should fix BaseSW's build problems too.

Version 5.29. Tagged as 'RISC_OSLib-5_29'
@
text
@d71 1
a106 3
        EXPORT  |x$udivide|
        EXPORT  |x$uremainder|
        EXPORT  |x$divide|
a107 1
        EXPORT  |x$remainder|
d137 1
a143 2
        EXPORT  |__rt_udiv|
        EXPORT  |__rt_sdiv|
d241 1
d316 2
a317 7
; sets a2 to 0 and a3 to a copy of the product.
        MOV     a3, #0
m0loop  MOVS    a2, a2, LSR #1
        ADDCS   a3, a3, a1
        ADD     a1, a1, a1
        BNE     m0loop
        MOV     a1, a3
a319 3
|x$remainder|
        B       |_kernel_srem|

d325 1
a325 1
        CMPS    a1, #0
a330 10
|__rt_sdiv|
|x$divide|
        B       |_kernel_sdiv|

|__rt_udiv|
|x$udivide|
        B       |_kernel_udiv|

|x$uremainder|
        B       |_kernel_urem|
a473 4
wimp_title
        DCB     "WindowManager", 0
utility_title
        DCB     "UtilityModule", 0
d482 1
a482 4
n_module_lookup  EQU 18
wimp_preinitflag EQU &80000000
zp_wimpdomain    EQU &ff8

d484 1
a488 55
        MOV     r0, #n_module_lookup
        ADR     r1, utility_title
        SWI     XOS_Module
        BVS     postmortem2
        LDR     r0, [r3, #5 * 4]
        MOV     r1, #0
        ADD     r0, r0, r3
postmortem3
        LDRB    r2, [r0], #1
        CMP     r2, #9
        ORREQ   r1, r1, #7
        ADD     r1, r1, #1
        CMP     r1, #16
        BCC     postmortem3
        LDRB    r1, [r0]
        SUB     r1, r1, #'0'
        LDRB    r2, [r0, #2]
        SUB     r2, r2, #'0'
        ADD     r1, r1, r1, LSL #2
        ADD     r1, r2, r1, LSL #1
        LDRB    r2, [r0, #3]
        SUB     r2, r2, #'0'
        ADD     r1, r1, r1, LSL #2
        ADD     r1, r2, r1, LSL #1
        CMP     r1, #202
        BCC     postmortem2
        MOV     r0, #0
        SWI     XTaskWindow_TaskInfo
        MOVVS   r0, #0
        CMP     r0, #0
        BNE     postmortem0
        MOV     r0, #3
        SWI     XWimp_ReadSysInfo
        BVS     postmortem0
        CMP     r0, #0
        BEQ     postmortem0
        B       postmortem4
postmortem2
        MOV     r0, #0
        SWI     XWimp_ReadSysInfo
        BVS     postmortem0
        CMP     r0, #0
        BEQ     postmortem0
        ; In desktop, now check Wimp_Initialise has been called
        MOV     r0, #n_module_lookup
        ADR     r1, wimp_title
        SWI     XOS_Module
        BVS     postmortem0
        MOV     r0, #0
        LDR     r0, [r0, #zp_wimpdomain]
        LDR     r0, [r4, r0]
        TST     r0, #wimp_preinitflag
        BNE     postmortem0
        ; If so reopen command window
postmortem4
d496 1
a496 1
        SWI     XWimp_CommandWindow
d498 23
a521 4
        LDR     a3, mesg
        CMP     a2, a3
        BLEQ    |_sys_msg|                      ; BL<cond> 32-bit OK
postmortem1
d585 22
@


4.2
log
@32-bit work merged from kbracey_32bit branch.

Version 5.06. Tagged as 'RISC_OSLib-5_06'
@
text
@a24 1
        GET     rlib.s.asmdefs
@


4.1
log
@Initial revision
@
text
@d27 9
a170 2
XOS_ReadDynamicArea     EQU     &2005c

d172 1
a172 1
        STMFD   sp!, {r1,r2,r14}
d183 1
a183 1
        LDMFD   sp!, {r1,r2,pc}^
d189 1
a189 1
        STMFD   sp!, {a1, r14}
d199 4
a202 1
        LDMFD   sp!, {pc}^
d208 1
a208 1
        MOVNES  pc, r14
d215 1
a215 1
        MOVEQS  pc, r14
d219 1
a219 1
        CMPS    a1, #0
a220 3
        STMEQFD sp!, {r14}
        BLEQ    raise
        LDMEQFD sp!, {r14}
d222 6
a227 2
        MOV     a1, #1          ; we wish to handle it, but not just yet
        MOVS    pc, r14
d232 1
a232 1
        MOVNES  pc, r14
d236 1
a236 1
        CMPS    a1, #0
a237 3
        STMEQFD sp!, {r14}
        BLEQ    raise
        LDMEQFD sp!, {r14}
d239 6
a244 2
        MOV     a1, #1          ; we wish to handle it, but not just yet
        MOVS    pc, r14
d270 1
a270 1
        MOVS    pc, r14
d272 21
d303 1
a303 1
        MOVEQS  pc, r14
a316 21
UncaughtTrapHandler Keep
        STMFD   sp!, {a2, r14}
        MOV     a4, a1
        BL      SignalNumber
        LDMFD   sp!, {a2, r14}
        B       RaiseIt

|_raise_stacked_interrupts|            ; called by CLIB.
        LoadStaticBase ip, a1
        MOV     a2, #0
        STR     a2, [ip, #O__interrupts_off]
        LDR     a1, [ip, #O__saved_interrupt]
        CMPS    a1, #0
        MOVEQS  pc, lr
        STR     a2, [ip, #O__saved_interrupt]
        B       raise

Finalise Keep
; (There'd better be a stack set up).
        IMPORT  |_lib_shutdown|
        B       |_lib_shutdown|
d327 1
a327 1
        MOVS    pc, lr
d338 1
a338 1
        MOVNES  pc, lr
d356 2
a357 2
        STMFD   sp!, {lr}
        CMPS    a1, #&8000
d361 2
a362 2
        CMPS    a1, lr                ; max app space size now read at initialisation
        LDMCCFD sp!, {pc}^
d367 2
a368 2
        STMFD   sp!, {lr}
        CMPS    a1, #&8000
d374 2
a375 2
        CMPS    a1, lr                ; max app space size now read at initialisation
        LDMCCFD sp!, {pc}^
d380 2
a381 2
        STMFD   sp!, {lr}
        CMPS    a1, #&8000
d387 2
a388 2
        CMPS    a1, lr                ; max app space size now read at initialisation
        LDMCCFD sp!, {pc}^
d393 2
a394 2
        STMFD   sp!, {lr}
        CMPS    a1, #&8000
d398 2
a399 2
        CMPS    a1, lr                ; max app space size now read at initialisation
        LDMCCFD sp!, {pc}^
d404 2
a405 2
        STMFD   sp!, {lr}
        CMPS    a1, #&8000
d411 2
a412 2
        CMPS    a1, lr                ; max app space size now read at initialisation
        LDMCCFD sp!, {pc}^
d417 2
a418 2
        STMFD   sp!, {lr}
        CMPS    a1, #&8000
d424 2
a425 2
        CMPS    a1, lr                ; max app space size now read at initialisation
        LDMCCFD sp!, {pc}^
d448 1
d450 1
d457 1
a457 1
        LDMFD   sp!, {v1, pc}^
d462 1
a462 1
        LDMFD   sp!, {v1, pc}^
d467 1
a467 1
        LDMFD   sp!, {v1, pc}^
d472 1
a472 1
        LDMFD   sp!, {v1, pc}^
d474 1
d476 1
a476 1
        STMFD   sp!, {lr}
d484 1
a484 1
        LDMFD   sp!, {pc}^
d487 1
a487 1
        LDMFD   sp!, {pc}^
d490 1
a490 1
        LDMFD   sp!, {pc}^
d493 1
a493 1
        LDMFD   sp!, {pc}^
a511 6
XOS_Module          EQU &2001e
XWimp_CommandWindow EQU &600ef
XWimp_ReadSysInfo   EQU &600f2

XTaskWindow_TaskInfo EQU &63380

d584 1
a584 2
        BNE     postmortem1
        BL      |_sys_msg|
d616 1
a616 1
        BIC     a1, a1, #&FC000003
d659 1
d661 5
a665 1
        BLEQ    |_kernel_setreturncode|
d676 6
d683 2
a684 2
sj_ap   #       4
sj_sl   #       4
d693 9
a701 14
; To make things harder, if this has been called through a compatibility
; veneer, longjump must return not to the veneer (which will attempt to
; use a link on the stack which is no longer there), but to its caller.
; This of course depends on intimate knowledge of what the compatibility
; veneer does.
        MOV     a2, lr
        MOV     ip, sp
        TST     fp, #APCSChange
        LDRNE   lr, [sp]
        ADDNE   ip, ip, #4
        STMIA   a1!, {v1-v6, fp, ip} ; save in two steps for calling-standard
        STMIA   a1!, {sl, lr}        ; independence.
        SUB     v1, a1, #sj_f4
        MOV     v2, a2
d704 8
a711 5
        BEQ     setjmp_return
        STFE    f4, [v1, #sj_f4]
        STFE    f5, [v1, #sj_f5]
        STFE    f6, [v1, #sj_f6]
        STFE    f7, [v1, #sj_f7]
a712 1
setjmp_return
d715 1
a715 1
        MOVS    pc, lr
d727 1
a727 1
        BLNE    |_kernel_exittraphandler|
d731 17
a747 21
        BEQ     longjmp_return
        LDFE    f7, [v1, #sj_f7-sj_f4]
        LDFE    f6, [v1, #sj_f6-sj_f4]
        LDFE    f5, [v1, #sj_f5-sj_f4]
        LDFE    f4, [v1, #sj_f4-sj_f4]
longjmp_return
        LDMDB   v1!, {r10, r12, r13, r14}   ; APCS_A fp, sp, sl
        MOV     v5, r14
        ; Done this way to make update of sp & sl sort of atomic.
        ; (Actually, non-atomic in a way the event-handler caller can
        ;  understand).
        ; Get stack description in correct APCS-R places.
        MOV     fp, r10
        MOV     sl, r13
        MOV     sp, r12
        ; Now discard all unwanted stack chunks which are deallocatable.
; Bug fix 26-Feb-91 ECN
; Added test to skip stack deallocation code in SVC mode!
; Previously this code caused a data abort.
; Maybe this code should be conditionalised as it should only apply to the
; shared c library.
d750 4
d755 1
d757 1
d763 1
d765 3
a767 1
        LDR     ip, [v2, #SC_deallocate]
d769 4
a772 5
        CMPS    ip, #0                          ;) deallocate it if it can be
        MOVNE   lr, pc                          ;) deallocated, and update the
        MOVNE   pc, ip                          ;) chain.
        STRNE   v3, [v4]                        ;)
        ADDEQ   v4, v2, #SC_next                ; else retain it
d777 1
a777 1
        MOV     r14, v5
d779 1
a779 6
        LDMDB   v1!, {v1-v6}
        TST     fp, #APCSChange
        MOVNE   r12, sp
        MOVNE   r13, sl
        MOVNE   r10, fp
        BICNE   r10, r10, #APCSChange           ; correct fp
d781 1
a781 1
        MOVS    pc, r14
d802 1
a802 1
        MOVS    pc, r14
d817 1
a817 1
        STMFD   sp!, {a3, a4}
d822 2
a823 2
        ADD     sp, sp, #8
        MOVS    pc, r14
d845 1
a845 1
        MOVEQS  pc, lr
d851 3
a853 1
|_stfp| STMFD   sp!, {r0, r1}
d856 4
a859 2
        MOVS    pc, lr

d861 3
a863 1
sin     STMFD   sp!, {r0, r1}
d865 1
d867 1
a867 1
        MOVS    pc, lr
d869 3
a871 1
cos     STMFD   sp!, {r0, r1}
d873 1
d875 1
a875 1
        MOVS    pc, lr
d877 3
a879 1
exp     STMFD   sp!, {r0, r1}
d882 3
d888 1
a888 1
        MOVEQS  pc, lr
d903 1
a903 1
        MOVS    pc, lr
d926 3
a928 1
log10   STMFD   sp!, {r0, r1}
d930 1
d935 1
a935 1
        MOVS    pc, lr
d937 3
a939 1
log     STMFD   sp!, {r0, r1}
d941 1
d946 1
a946 1
        MOVS    pc, lr
d948 3
a950 1
sqrt    STMFD   sp!, {r0, r1}
d952 1
d956 1
a956 1
        MOVS    pc, lr
d958 3
a960 1
tan     STMFD   sp!, {r0, r1}
d963 3
d969 1
a969 1
        MOVEQS  pc, lr
d972 3
a974 1
atan    STMFD   sp!, {r0, r1}
d976 1
d978 1
a978 1
        MOVS    pc, lr
d980 3
a982 1
asin    STMFD   sp!, {r0, r1}
d985 3
d994 1
a994 1
        MOVEQS  pc, lr
d998 3
a1000 1
acos    STMFD   sp!, {r0, r1}
d1003 3
d1012 1
a1012 1
        MOVEQS  pc, lr
d1016 3
a1018 1
pow     STMFD   sp!, {r0, r1, r2, r3}
d1022 3
d1035 1
a1035 1
        MOVEQS  pc, lr
d1046 1
a1046 1
        MOVGES  pc, lr
d1050 1
a1050 1
        BIC     lr, lr, #&FC000003  ; remove condition code bits
d1061 1
a1061 1
        BIC     lr, lr, #&FC000003  ; remove condition code bits
@


4.1.10.1
log
@_kernel_unwind now understands SFMFD instructions in function entry.
It also copes with STFE now - it was totally broken.
32-bit stubs and corresponding LibInit SWIs created.
All rather untested.

Version 4.97, 4.12.2.3. Tagged as 'RISC_OSLib-4_97-4_12_2_3'
@
text
@d162 2
d497 1
@


4.1.10.2
log
@  Work in progress.  Do not use.
Detail:
  Many changes to use the APCS macros for function entry and exit so
    that the code can build for 32-bit environments.  Changes are NOT
    yet complete.
  Makefile rebuilds swis.h header file but only exports it if it has
    changed to avoid unnecessary rebuilding of nearly all C sources
    in a build.
Admin:
  Work in progress.  Do not use.

Version 4.97, 4.12.2.5. Tagged as 'RISC_OSLib-4_97-4_12_2_5'
@
text
@a26 9
        GET     Hdr:Wimp
        GET     Hdr:TaskWindow

        GBLL    FloatingPointArgsInRegs
FloatingPointArgsInRegs SETL {FALSE}
        [ FloatingPointArgsInRegs
        ! 0, "WARNING: Floating point arguments ARE being passed in FP registers"
        ]

d163 1
a163 1
        FunctionEntry "r1,r2"
d174 1
a174 1
        Return  "r1,r2"
d180 1
a180 1
        FunctionEntry "a1"
d190 1
a190 4
        [ {CONFIG}<>26
        CLRV    VS                      ; explicitly clear V for 32-bit call case
        ]
        Return
d196 1
a196 1
        Return  ,LinkNotStacked, NE
d203 1
a203 1
        Return  ,LinkNotStacked, EQ
d207 1
a207 1
        CMP     a1, #0
d209 3
d213 2
a214 6
        BNE     %FT01
        STMFD   sp!, {r14}
        BL      raise
        LDMFD   sp!, {r14}
01      MOV     a1, #1          ; we wish to handle it, but not just yet
        Return  ,LinkNotStacked
d219 1
a219 1
        Return  ,LinkNotStacked, NE
d223 1
a223 1
        CMP     a1, #0
d225 3
d229 2
a230 6
        BNE     %FT02
        STMFD   sp!, {r14}
        BL      raise
        LDMFD   sp!, {r14}
02      MOV     a1, #1          ; we wish to handle it, but not just yet
        Return  ,LinkNotStacked
d256 1
a256 1
        Return  ,LinkNotStacked
a257 21
UncaughtTrapHandler Keep
        STMFD   sp!, {a2, r14}
        MOV     a4, a1
        BL      SignalNumber
        LDMFD   sp!, {a2, r14}
        B       RaiseIt

|_raise_stacked_interrupts|            ; called by CLIB.
        LoadStaticBase ip, a1
        MOV     a2, #0
        STR     a2, [ip, #O__interrupts_off]
        LDR     a1, [ip, #O__saved_interrupt]
        CMPS    a1, #0
        Return  ,LinkNotStacked, EQ
        STR     a2, [ip, #O__saved_interrupt]
        B       raise

Finalise Keep
; (There'd better be a stack set up).
        IMPORT  |_lib_shutdown|
        B       |_lib_shutdown|
d268 1
a268 1
        Return  ,LinkNotStacked, EQ
d282 21
d313 1
a313 1
        Return  ,LinkNotStacked
d324 1
a324 1
        Return  ,LinkNotStacked, NE
d342 2
a343 2
        FunctionEntry
        CMP     a1, #&8000
d347 2
a348 2
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
d353 2
a354 2
        FunctionEntry
        CMP     a1, #&8000
d360 2
a361 2
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
d366 2
a367 2
        FunctionEntry
        CMP     a1, #&8000
d373 2
a374 2
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
d379 2
a380 2
        FunctionEntry
        CMP     a1, #&8000
d384 2
a385 2
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
d390 2
a391 2
        FunctionEntry
        CMP     a1, #&8000
d397 2
a398 2
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
d403 2
a404 2
        FunctionEntry
        CMP     a1, #&8000
d410 2
a411 2
        CMP     a1, lr                ; max app space size now read at initialisation
        Return  ,,CC
a433 1
; Note that the number of instructions is critical for the SUBLT, hence the NOOPs
a434 1
        FunctionEntry "v1"
d441 1
a441 1
        Return  "v1"
d446 1
a446 1
        Return  "v1"
d451 1
a451 1
        Return  "v1"
d456 1
a456 1
        Return  "v1"
a457 1
; Note that the number of instructions is critical for the SUBLT
d459 1
a459 1
        FunctionEntry
d467 1
a467 1
        Return
d470 1
a470 1
        Return
d473 1
a473 1
        Return
d476 1
a476 1
        Return
d495 5
d572 2
a573 1
        BLEQ    |_sys_msg|                      ; BL<cond> 32-bit OK
d605 1
a605 1
        RemovePSRFromReg a1, a2         ; Remove PSR bits safely if necessary
a647 1
        [ No32bitCode
d649 1
a649 5
        |
        MRS     a4, CPSR
        TST     a4, #2_01111             ; EQ if USR26 or USR32
        ]
        BLEQ    |_kernel_setreturncode|  ; BL<cond> 32-bit OK
d678 1
a678 1
        TST     fp, #APCSChange         ; XXXX32
d696 1
a696 1
        Return  ,LinkNotStacked
d708 1
a708 1
        BLNE    |_kernel_exittraphandler|       ; BL<cond> 32-bit OK
a732 1
        [ No32bitCode
a734 4
        |
        MRS     a1, CPSR
        TST     a1, #2_01111                    ; EQ if USR26 or USR32
        ]
d757 1
a757 1
        TST     fp, #APCSChange                 ; XXXX32
d763 1
a763 1
        Return  ,LinkNotStacked
d784 1
a784 1
        Return  ,LinkNotStacked
d799 1
a799 1
        STMFD   sp!, {a3, a4, v1, v2}  ; v1,v2 just to reserve space
d804 2
a805 2
        ADD     sp, sp, #4*4
        Return  ,LinkNotStacked
d827 1
a827 1
        Return  ,LinkNotStacked, EQ
d833 1
a833 3
|_stfp|
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
d836 2
a837 4
        |
        STFP    f0, [r0, #0]
        ]
        Return  ,LinkNotStacked
d839 1
a839 3
sin
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a840 1
        ]
d842 1
a842 1
        Return  ,LinkNotStacked
d844 1
a844 3
cos
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a845 1
        ]
d847 1
a847 1
        Return  ,LinkNotStacked
d849 1
a849 3
exp
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a851 3
        |
        DisableFPInterrupts
        ]
d855 1
a855 1
        Return  ,LinkNotStacked, EQ
d870 1
a870 1
        Return  ,LinkNotStacked
d893 1
a893 3
log10
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a894 1
        ]
d899 1
a899 1
        Return  ,LinkNotStacked
d901 1
a901 3
log
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a902 1
        ]
d907 1
a907 1
        Return  ,LinkNotStacked
d909 1
a909 3
sqrt
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a910 1
        ]
d914 1
a914 1
        Return  ,LinkNotStacked
d916 1
a916 3
tan
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a918 3
        |
        DisableFPInterrupts
        ]
d922 1
a922 1
        Return  ,LinkNotStacked, EQ
d925 1
a925 3
atan
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a926 1
        ]
d928 1
a928 1
        Return  ,LinkNotStacked
d930 1
a930 3
asin
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a932 3
        |
        DisableFPInterrupts
        ]
d939 1
a939 1
        Return  ,LinkNotStacked, EQ
d943 1
a943 3
acos
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1}
a945 3
        |
        DisableFPInterrupts
        ]
d952 1
a952 1
        Return  ,LinkNotStacked, EQ
d956 1
a956 3
pow
        [ :LNOT: FloatingPointArgsInRegs
        STMFD   sp!, {r0, r1, r2, r3}
a959 3
        |
        DisableFPInterrupts
        ]
d970 1
a970 1
        Return  ,LinkNotStacked, EQ
d981 1
a981 1
        Return  ,LinkNotStacked, GE
d985 1
a985 1
        RemovePSRFromReg lr, ip
d996 1
a996 1
        RemovePSRFromReg lr, ip
@


4.1.10.3
log
@Features:

* APCS-32 support complete.
* APCS-A compatibility removed.
* Old ArthurLib code removed.
* _clib_version() now reports version from VersionNum.
* time() no longer does a run-time host check - I think we know we're not a BBC
  Master ARM second processor now.
* rename() now uses OS_FSControl 25 instead of *rename.
* getenv() can handle arbitrary length variables.
* Can now handle exceptions in 32-bit form of FPEmulator (on either 26 or 32
  bit systems).
* tmpnam() switches to SVC mode to access its zero page counter.
* Faster divide routines.

Admin:

  This will build all sorts of different things depending on the flags. See
  the Docs directory for details.

  As far as ROM builds are concerned, if using APCS-R, no changes are needed.
  If using APCS-32, the Shared C Library must be built as APCS-R to ensure
  compatibility with old binaries. To achieve this, pass in the option
  SCL_APCS="-APCS 3/26bit" in the Components file.

Version 4.97, 4.12.2.8. Tagged as 'RISC_OSLib-4_97-4_12_2_8'
@
text
@d676 2
a677 5
  [ {CONFIG}=26
sj_fp   #       4       ; Old APCS-A ordering, which we retain
sj_sp   #       4       ; for compatibility in the 26-bit case
sj_sl   #       4       ; (someone might poke jmp_bufs)
  |
a678 3
sj_fp   #       4
sj_sp   #       4
 ]
d687 14
a700 9
  [ {CONFIG}=26
        STMIA   a1!, {v1-v6, fp, sp}
        STMIA   a1, {sl, lr}
        SUB     v1, a1, #sj_sl
  |
        STMIA   a1, {v1-v6, sl, fp, sp, lr}
        MOV     v1, a1
  ]
        MOV     v2, lr
d703 5
a707 8
  [ {CONFIG}=26
        STFNEE  f4, [v1, #sj_f4]
        STFNEE  f5, [v1, #sj_f5]
        STFNEE  f6, [v1, #sj_f6]
        STFNEE  f7, [v1, #sj_f7]
  |
        SFMNE   f4, 4, [v1, #sj_f4]
  ]
d709 1
d728 22
a749 17
 [ {CONFIG}=26
        LDFNEE  f7, [v1, #sj_f7-sj_f4]
        LDFNEE  f6, [v1, #sj_f6-sj_f4]
        LDFNEE  f5, [v1, #sj_f5-sj_f4]
        LDFNEE  f4, [v1, #sj_f4-sj_f4]
        LDMDB   v1!, {v2-v5}                    ; fudge for atomic {sp,sl,fp} update
        STMFD   sp!, {v2, v3}                   ; push fp, sp
        STR     v4, [sp, #-4]!                  ; push sl
        LDMFD   sp, {sl, fp, sp}
 |
        LFMNE   f4, 4, [v1, #sj_f4-sj_f4]
        LDMDB   v1!, {sl, fp, sp, lr}
        MOV     v5, lr
 ]

 [ ModeMayBeNonUser
   [ {CONFIG}=26
d752 1
a752 1
   |
d755 1
a755 1
   ]
a756 1
 ]
a757 1
        ; Now discard all unwanted stack chunks which are deallocatable.
d763 1
a764 4
        LDR     v3, [v2, #SC_next]              ; chunk after next
        CMPS    ip, #0
        ADDEQ   v4, v2, #SC_next                ; if it can't be deallocated
        BEQ     deallocate_next_chunk           ; retain it
d766 5
a770 4
        MOV     lr, pc                          ;) deallocate it if it can be
        MOV     pc, ip                          ;) deallocated, and update the
        STR     v3, [v4]                        ;) chain.
deallocate_next_chunk
d775 1
a775 1
        MOV     lr, v5
d777 6
a782 1
        LDMDB   v1, {v1-v6}
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.5;
access;
symbols
	RISC_OSLib-5_97:4.5
	RISC_OSLib-5_96:4.5
	RISC_OSLib-5_95:4.5
	RISC_OSLib-5_94:4.5
	RISC_OSLib-5_93:4.5
	RISC_OSLib-5_92:4.5
	RISC_OSLib-5_91:4.5
	RISC_OSLib-5_90:4.5
	RISC_OSLib-5_89:4.4
	RISC_OSLib-5_88:4.4
	RISC_OSLib-5_87:4.4
	RISC_OSLib-5_86-1:4.4
	RISC_OSLib-5_86:4.4
	RISC_OSLib-5_85:4.4
	RISC_OSLib-5_84:4.4
	RISC_OSLib-5_83-2:4.4
	RISC_OSLib-5_83-1:4.4
	RISC_OSLib-5_83:4.4
	RISC_OSLib-5_82:4.4
	RISC_OSLib-5_81:4.4
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.4
	RISC_OSLib-5_79:4.4
	RISC_OSLib-5_78:4.4
	RISC_OSLib-5_75-1:4.3
	RISC_OSLib-5_77:4.3
	RISC_OSLib-5_76:4.3
	RISC_OSLib-5_75:4.3
	RISC_OSLib-5_74:4.3
	RISC_OSLib-5_73:4.3
	RISC_OSLib-5_72:4.3
	RISC_OSLib-5_71:4.3
	RISC_OSLib-5_70:4.3
	RISC_OSLib-5_69:4.3
	RISC_OSLib-5_68:4.2
	RISC_OSLib-5_67:4.1
	RISC_OSLib-5_66:4.1
	RISC_OSLib-5_65:4.1
	RISC_OSLib-5_64:4.1
	RISC_OSLib-5_63:4.1
	RISC_OSLib-5_62:4.1
	RISC_OSLib-5_61:4.1
	RISC_OSLib-5_60:4.1
	RISC_OSLib-5_59:4.1
	RISC_OSLib-5_58:4.1
	RISC_OSLib-5_57:4.1
	RISC_OSLib-5_56:4.1
	RISC_OSLib-5_55:4.1
	RISC_OSLib-5_54:4.1
	RISC_OSLib-5_53:4.1
	RISC_OSLib-5_52:4.1
	RISC_OSLib-5_51:4.1
	RO_5_07:4.1
	RISC_OSLib-5_50:4.1
	RISC_OSLib-5_49:4.1
	RISC_OSLib-5_46-4_64_2_1:4.1
	NoInlineAsm:4.1.0.16
	RISC_OSLib-5_48:4.1
	RISC_OSLib-5_47:4.1
	RISC_OSLib-5_46:4.1
	RISC_OSLib-5_45:4.1
	RISC_OSLib-5_44:4.1
	RISC_OSLib-5_43:4.1
	RISC_OSLib-5_42:4.1
	RISC_OSLib-5_41:4.1
	RISC_OSLib-5_40:4.1
	RISC_OSLib-5_39:4.1
	RISC_OSLib-5_38:4.1
	RISC_OSLib-5_37:4.1
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2016.05.14.12.28.37;	author rool;	state Exp;
branches;
next	4.4;
commitid	SD1SHLulN4j2Nr6z;

4.4
date	2013.10.24.20.03.49;	author rsprowson;	state Exp;
branches;
next	4.3;
commitid	8snV0tcFxVQyiAax;

4.3
date	2012.06.11.07.32.27;	author rsprowson;	state Exp;
branches;
next	4.2;
commitid	O2lGWYMHaZ6edg8w;

4.2
date	2012.05.28.18.04.03;	author rsprowson;	state Exp;
branches;
next	4.1;
commitid	psVvzYlFFIpQ9w6w;

4.1
date	96.11.05.09.24.50;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.50;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.58;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.28;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.41;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@[391] localtime() ignores manual timezone configuration
Detail:
  When in the default C locale localtime() would return the wrong time for nonzero timezones.
Admin:
  Tested with softloaded C library for each ROM release supported.
  Submission from Rick Murray.

Version 5.90. Tagged as 'RISC_OSLib-5_90'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* time.c: ANSI draft (X3J11 Oct 86) section 4.12 code */
/* Copyright (C) Codemist Ltd, 1988 */
/* version 0.02a */

#include <time.h>
#include <stdio.h>
#include <string.h>
#include <locale.h>

#include "kernel.h"
#include "territory.h"
#include "swis.h"

/* Array indices corresponding to the LC macros above */
#define N_LC_COLLATE  0
#define N_LC_CTYPE    1
#define N_LC_MONETARY 2
#define N_LC_NUMERIC  3
#define N_LC_TIME     4
#define N_LC_ALL      5

extern int __locales[5];

/* NB strftime() is in locale.c since it seems VERY locale-dependent      */

/* In NorCroft C time() yields the unix result of an unsigned int holding */
/* seconds since 1 Jan 1970.                                              */
/* clock() returns an unsigned int with ticks of cpu time.                */

/* N.B. clock() and time() are defined in armsys.c                        */

static const int monlen[13] = { 31,29,31,30,31,30,31,31,30,31,30,31,0x40000000 };

double difftime(time_t time1, time_t time0)
{   return (double)time1 - (double)time0;
}


static int tm_carry(int *a, int b, int q)
{   /* *a = (*a + b) % q, return (*a + b)/q.  Care with overflow.          */
    int aa = *a;
    int hi = (aa >> 16) + (b >> 16);    /* NB signed shift arithmetic here */
    int lo = (aa & 0xffff) + (b & 0xffff);
    lo += (hi % q) << 16;
    hi = hi / q;
    aa = lo % q;
    lo = lo / q;
    while (aa < 0)
    {   aa += q;
        lo -= 1;
    }
    *a = aa;        /* remainder is positive here */
    return (hi << 16) + lo;
}

static struct tm *time_to_tm(struct tm *_tms, time_t t, int dst)
{
    int i = 0, yr;

    /* unix time already in seconds (since 1-Jan-1970) ... */
    _tms->tm_sec = t % 60; t /= 60;
    _tms->tm_min = t % 60; t /= 60;
    _tms->tm_hour = t % 24; t /= 24;
/* The next line converts *timer arg into days since 1-Jan-1900 from t which
   now holds days since 1-Jan-1970.  Now there are really only 17 leap years
   in this range 04,08,...,68 but we use 18 so that we do not have to do
   special case code for 1900 which was not a leap year.  Of course this
   cannot give problems as pre-1970 times are not representable in *timer. */
    t += 70*365 + 18;
    _tms->tm_wday = t % 7;               /* it just happens to be so */
    yr = 4 * (t / (365*4+1)); t %= (365*4+1);
    if (t >= 366) yr += (t-1) / 365, t = (t-1) % 365;
    _tms->tm_year = yr; /* Add in magic timebase */
    _tms->tm_yday = t;
    if ((yr & 3) != 0 && t >= 31+28) t++;
    while (t >= monlen[i]) t -= monlen[i++];
    _tms->tm_mday = t+1;
    _tms->tm_mon = i;
    _tms->tm_isdst = dst;
    return _tms;
}

time_t mktime(struct tm *timeptr)
{   /* ISO9899 7.23.2.3 (2) says that the components may take ANY values   */
    /* and that somehow mktime() should normalise these into a form that   */
    /* is in range.  This leaves the question - what is month -9 or +123?  */
    /* the code below resolves by normalising from seconds upwards,        */
    /* propagating any carries up to the year component then checking for  */
    /* overflow.                                                           */
    /* Also note that struct tm is allowed to have signed values in it for */
    /* the purposes of this function even though normalized times all have */
    /* just positive entries.                                              */
    time_t t;
    int w, v, yday, offset, territory;
    int sec = timeptr->tm_sec;
    int min = timeptr->tm_min;
    int hour = timeptr->tm_hour;
    int mday = timeptr->tm_mday;
    int mon = timeptr->tm_mon;
    int year = timeptr->tm_year;
    int quadyear = 0;
    _kernel_swi_regs r;

    /* The next line is a simple test that detects some gross overflows    */
    if (year > 0x40000000 || year < -0x40000000) return (time_t)-1;

    /* Work out what the timezone/DST correction is */
    territory = __locales[N_LC_TIME];
    if (!territory) {
        r.r[0] = -1; /* If C locale use current configured territory */
    } else {
        r.r[0] = TERRITORY_EXTRACT(territory);
        r.r[1] = TERRITORY_TZ_EXTRACT(territory);
        r.r[4] = TERRITORY_TZ_API_EXT; /* If not supported, never mind */
    }
    if (_kernel_swi(Territory_ReadTimeZones, &r, &r) == NULL) {
        offset = (timeptr->tm_isdst > 0) ? r.r[3] : r.r[2];
        offset = offset / 100; /* centiseconds -> seconds */
    } else {
        offset = 0;
    }

    /* we really do have to propagate carries up it seems                  */
    /* careful about overflow for divide, but not carry add.               */
    w = tm_carry(&sec,-offset,60); /* leaves 0 <= sec < 60  */
    w = tm_carry(&min,w,60);       /* leaves 0 <= min < 60  */
    w = tm_carry(&hour,w,24);      /* leaves 0 <= hour < 24 */
    quadyear = tm_carry(&mday,w - 1,(4*365+1));  /* 0 <= mday < 4 years    */

    /* The next line can not possibly result in year overflowing since the */
    /* initial value was checked earlier and the month can only cause a    */
    /* carry of size up to MAXINT/12 with quadyear limited to MAXINT/365.  */
    year += quadyear*4 + tm_carry(&mon,0,12);
    /* at last the mday is in 0..4*365 and the mon in 0..11                */

#define notleapyear(year) (((year) & 3)!=0)
    /* Note that 1900 is not in the range of valid dates and so I will     */
    /* fudge the issue about it not being a leap year.                     */

    while (mday >= monlen[mon])
    {   mday -= monlen[mon++];
        if (mon==2 && notleapyear(year)) mday++;
        else if (mon == 12) mon = 0, year++;
    }
    if (mon==1 && mday==28 && notleapyear(year)) mon++, mday=0;

#define YEARS (0x7fffffff/60/60/24/365 + 1)
    if (year < 70 || year > 70+2*YEARS) return (time_t)-1;
#undef YEARS

    yday = mday;
    {   int i;
        for (i = 0; i<mon; i++) yday += monlen[i];
    }
    if (mon > 1 && notleapyear(year)) yday--;

    v = (365*4+1)*(year/4) + 365*(year & 3) + yday;
    if (!notleapyear(year)) v--;
    /* v is now the number of days since 1 Jan 1900, and I have subtracted */
    /* a sly 1 to adjust for 1900 not being a leap year.                   */

#undef notleapyear

    /* Adjust for a base at 1 Jan 1970 which is 17 leap years since 1900   */

#define DAYS ((70*365)+17)
    t = min + 60*(hour + 24*(v - DAYS));
#undef DAYS
    {   int thi = ((int)t >> 16)*60;
        int tlo = ((int)t & 0xffff)*60 + sec;
        thi += (tlo >> 16) & 0xffff;
        t = (time_t)((thi << 16) | (tlo & 0xffff));
        if ((thi & 0xffff0000) != 0) return (time_t)-1;
    }

    /* Update the local time block by reapplying timezone/DST              */
    {   long long sum;
        sum = t + (long long)offset;
        if ((time_t)sum != sum) return (time_t)-1;
        time_to_tm(timeptr, (time_t)sum, timeptr->tm_isdst);
    }

    return t;
    /* Now I know why Unix didn't have this                                */
}

char *asctime(const struct tm *timeptr)
{   static char _timebuf[26+(8+3*9+7)];  /* slop in case illegal args */
    sprintf(_timebuf, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
       "SunMonTueWedThuFriSat" + (timeptr -> tm_wday)*3,
       "JanFebMarAprMayJunJulAugSepOctNovDecBad" + (timeptr -> tm_mon)*3,
       timeptr -> tm_mday,
       timeptr -> tm_hour, timeptr -> tm_min, timeptr -> tm_sec,
       timeptr -> tm_year + 1900);
    return _timebuf;
}

char *ctime(const time_t *timer)
{   return asctime(localtime(timer));
}

struct tm *gmtime(const time_t *timer)
{
    static struct tm _tms;
    time_t t;

    t = *timer;
    if (t == (time_t)-1) {
        memset(&_tms, 0, sizeof(_tms));
        _tms.tm_mday = 1; /* 1st day of 1900 */
        return &_tms;
    }

    return time_to_tm(&_tms, t, 0); /* Gregorian calendar, no DST */
}

struct tm *localtime(const time_t *timer)
{
    time_t t;
    static struct tm _tms;
    int dst;
    int territory;
    int v;
    _kernel_swi_regs r;

    t = *timer;
    if (t == (time_t)-1) {
        memset(&_tms, 0, sizeof(_tms));
        _tms.tm_mday = 1; /* 1st day of 1900 */
        return &_tms;
    }

    /* Read CMOS for DST flag in bit 7 */
    dst = -1;
    v = _kernel_osbyte(161, 220 /* AlarmAndTimeCMOS */, 0);
    if (v >= 0)
        dst = v & 0x8000;

    territory = __locales[N_LC_TIME];
    if (!territory) {
        /* C locale uses currently configured offset */
        if (_kernel_swi(Territory_ReadCurrentTimeZone, &r, &r) == NULL) {
            t += r.r[1] / 100; /* centiseconds -> seconds */
        }
    } else {
        /* Specific locale */
        r.r[0] = TERRITORY_EXTRACT(territory);
        r.r[1] = TERRITORY_TZ_EXTRACT(territory);
        r.r[4] = TERRITORY_TZ_API_EXT; /* If not supported, never mind */
        if (_kernel_swi(Territory_ReadTimeZones, &r, &r) == NULL) {
            v = (dst == 0x8000) ? r.r[3] : r.r[2];
            t += v / 100; /* centiseconds -> seconds */
        }
    }

    /* Already corrected for locale, so just need to mangle it */
    /* into a suitable structure                               */
    return time_to_tm(&_tms, t, dst);
}

/* end of time.c */
@


4.4
log
@Some library fixes
Fix for problem passing long command lines via system(), while there are good arguments to leave the threshold at 255, non DDEUtils aware programs get brutally truncated command strings, and since the old threshold of 255 applied when the kernel handled 256 command lines, upping the limit to 1k is no worse than before.
Fix for Edit failing to draw lines of text longer than 192 characters (ticket #350). Several factors were conspiring here: on a mode change the window width in characters wasn't being clamped, whereas user entered limits in the menu were, then the internal buffer ("PAINTBUFSIZE") was too short so lines got truncated, and when larger than 256 got wrapped modulo 256 due to the use of an array of chars. Now set at compile time with BIG_WINDOW_SIZE_LIMIT with a new theoretical maximum of 8192. Currently limited to 480 since it uses stack variables.

In the C library:
 armsys.c: adapt the threshold at which to use DDEUtils based on the kernel version number
 scanf.c: squash a warning
 time.c: mark the table of month lengths as constant so we can claw back 13 words of static workspace without having to change the stubs

In RISC OS lib:
 bbc.c: remove local definitions of some SWI numbers
 template.c: squash a warning
 txt.c: delete Modula-2 support
 txt1.c: compare pointer with NULL not an integer
 txtar.c: introduce BIG_WINDOW_SIZE_LIMIT, rationalise a few sprintf's, mark private functions as static
 txtundo.c/txtedit.c: squash old style function warnings
 txtoptmenu.c: clamp the window width read from Edit$Options properly, delete long disabled code
 txtscrap.c: dead function deleted


Version 5.78. Tagged as 'RISC_OSLib-5_78'
@
text
@d256 4
a259 1
        r.r[0] = -1; /* If C locale use current configured territory */
d261 1
d265 4
a268 4
    }
    if (_kernel_swi(Territory_ReadTimeZones, &r, &r) == NULL) {
        v = (dst == 0x8000) ? r.r[3] : r.r[2];
        t += v / 100; /* centiseconds -> seconds */
@


4.3
log
@Make mktime() correct for local time.
Following an earlier fix, the logic of mktime() has turned out to need reviewing too.
To summarise
  time() -> a UTC time in seconds
  gmtime() -> breaks down a UTC time into components
  localtime() -> breaks down a UTC time into local components (tz + DST)
  mktime() -> converts local components back into UTC time, normalising
In mktime(), the current locale (via setlocale()) is considered and used to choose the timezone, assuming an appropriate territory module is loaded.
The value of the tm_isdst field is factored into the offset calculation.
However, mktime() is also defined as normalising the components of time and updating the caller's block with normalised values, in local time, so the local offset is reapplied at the end.

Moved time_to_tm up in the function so mktime() can use it.
Corrected/lined up some comments.
Also, mktime() no longer forces tm_isdst to -1, it preserves the user's value, so consecutive mktime()s are consistent.
Added test to "test/tzones.c", results compared with Windows XP.

Version 5.69. Tagged as 'RISC_OSLib-5_69'
@
text
@d47 1
a47 1
static int monlen[13] = { 31,29,31,30,31,30,31,31,30,31,30,31,0x40000000 };
@


4.2
log
@Add locale support for selecting timezones from C
armsys.c
  Ammended time() to match ISO9899 and just return UTC like it says.
  Inlined the single use of _bbctime() macro.
locale.c
  The timezone within a territory can now be specified as part of the setlocale() function.
  This uses a qualifier to the already accepted territory name, for an example see test/tzones.c
  Shock addition of some comments to the locale parsing function.
  To avoid needing to mess about with C library workspace the timezone and territory are encoded internally into 1 word, with 10 bits allowing up to 1024 territories worldwide.
  Ripple through to strftime().
time.c
  localtime() updated to respect locale selection.
test/file,gen_inputs,test64
  Copyright headers added.

Output compared with Windows XP using setlocale versus tzset to shift the program into Pacific time.

Version 5.68. Tagged as 'RISC_OSLib-5_68'
@
text
@d71 27
d99 6
a104 3
{   /* the Oct 1986 ANSI draft spec allows ANY values for the contents     */
    /* of timeptr.  This leave the question - what is month -9 or +123?    */
    /* the code below resolves it in one way:                              */
d109 1
a109 1
    int w, v, yday;
d117 3
a119 1
/* The next line applies a simple test that detects some gross overflows */
d122 16
d140 4
d145 3
a147 7
    w = tm_carry(&sec,0,60);    /* leaves 0 <= sec < 60  */
    w = tm_carry(&min,w,60);    /* leaves 0 <= min < 60  */
    w = tm_carry(&hour,w,24);   /* leaves 0 <= hour < 24 */
    quadyear = tm_carry(&mday,w - 1,(4*365+1));  /* 0 <= mday < 4 years    */
/* The next line can not possibly result in year overflowing since the     */
/* initial values was checked earlier and the month can only cause a       */
/* carry of size up to MAXINT/12 with quadyear limited to MAXINT/365.      */
d152 2
a153 2
/* Note that 1900 is not in the range of valid dates and so I will fudge   */
/* the issue about it not being a leap year.                               */
d174 2
a175 2
/* v is now the number of days since 1 Jan 1900, and I have subtracted a   */
/* sly 1 to adjust for 1900 not being a leap year.                         */
d179 1
a179 1
/* Adjust for a base at 1 Jan 1970                                       */
d181 1
a181 1
#define DAYS (17*(365*4+1)+2*365)
d191 6
a196 9
    timeptr->tm_sec = sec;
    timeptr->tm_min = min;
    timeptr->tm_hour = hour;
    timeptr->tm_mday = mday + 1;
    timeptr->tm_mon = mon;
    timeptr->tm_year = year;
    timeptr->tm_wday = (v + 1) % 7;
    timeptr->tm_yday = yday;
    timeptr->tm_isdst = -1;                  /* unavailable */
d199 1
a199 1
    /* Now I know why Unix didn't have this                              */
a216 27
static struct tm *time_to_tm(struct tm *_tms, time_t t, int dst)
{
    int i = 0, yr;

    /* unix time already in seconds (since 1-Jan-1970) ... */
    _tms->tm_sec = t % 60; t /= 60;
    _tms->tm_min = t % 60; t /= 60;
    _tms->tm_hour = t % 24; t /= 24;
/* The next line converts *timer arg into days since 1-Jan-1900 from t which
   now holds days since 1-Jan-1970.  Now there are really only 17 leap years
   in this range 04,08,...,68 but we use 18 so that we do not have to do
   special case code for 1900 which was not a leap year.  Of course this
   cannot give problems as pre-1970 times are not representable in *timer. */
    t += 70*365 + 18;
    _tms->tm_wday = t % 7;               /* it just happens to be so */
    yr = 4 * (t / (365*4+1)); t %= (365*4+1);
    if (t >= 366) yr += (t-1) / 365, t = (t-1) % 365;
    _tms->tm_year = yr; /* Add in magic timebase */
    _tms->tm_yday = t;
    if ((yr & 3) != 0 && t >= 31+28) t++;
    while (t >= monlen[i]) t -= monlen[i++];
    _tms->tm_mday = t+1;
    _tms->tm_mon = i;
    _tms->tm_isdst = dst;
    return _tms;
}

d252 1
a252 1
        dst = dst & 0x8000;
@


4.1
log
@Initial revision
@
text
@d45 1
a45 1
/* N.B. clock() and time() are defined in opsys.c                         */
d195 1
a195 1
    _tms->tm_isdst = dst;                  /* unavailable */
a202 3
    int territory, dst;
    int v;
    _kernel_swi_regs r;
a204 9
    territory = __locales[N_LC_TIME];
    if (!territory)
        territory = -1;
    /* Read CMOS Ram for DST flag in bit 7 of loc 0xdc */
    v = _kernel_osbyte(161, 0xdc, 0);
    dst = v & (1 << 15);
    r.r[0] = territory;
    _kernel_swi(Territory_ReadTimeZones, &r, &r);
    t -= (dst ? r.r[3] : r.r[2]) / 100;
d207 1
a207 1
        _tms.tm_mday = 1;
d210 2
a211 1
    return time_to_tm(&_tms, t, 0); /* No DST component */
a218 2
    int ordblock[9];
    unsigned bt[2];
d220 1
a220 1
    int i, v;
a222 1
/* treat unset dates as 1-Jan-1900 - any better ideas? */
d226 1
a226 1
        _tms.tm_mday = 1;
d229 2
a230 3
    territory = __locales[N_LC_TIME];
    if (!territory)        /* If C locale use current configured territory */
        territory = -1;
d232 1
a232 2
    /* Read CMOS Ram for DST flag in bit 7 of loc 0xdc */
    v = _kernel_osbyte(161, 0xdc, 0);
d234 13
a246 32
        dst = ((v >> 8) >> 7) & 1;
    r.r[0] = territory;
    if (!_kernel_swi(Territory_ReadTimeZones, &r, &r)) {
        v = r.r[2];
        if (dst) v = r.r[3];
        t -= v / 100;
    }
    bt[0] = 0;
    bt[1] = 0;
#define secs0070 (((unsigned)86400)*(365*70+17))  /* less than 2^32 */
    for (i = 0; i < 100; i++) {
        bt[0] += t;
        if (bt[0] < (unsigned)t)
            bt[1]++;
        bt[0] += secs0070;
        if (bt[0] < (unsigned)secs0070)
            bt[1]++;
    }
    r.r[0] = territory;
    r.r[1] = (int)bt;
    r.r[2] = (int)ordblock;
    if (!_kernel_swi(Territory_ConvertTimeToOrdinals, &r, &r)) {
        _tms.tm_sec = ordblock[1];
        _tms.tm_min = ordblock[2];
        _tms.tm_hour = ordblock[3];
        _tms.tm_mday = ordblock[4];
        _tms.tm_mon = ordblock[5] - 1;
        _tms.tm_year = ordblock[6] - 1900;
        _tms.tm_wday = ordblock[7] - 1;
        _tms.tm_yday = ordblock[8] - 1;
        _tms.tm_isdst = dst;
        return &_tms;
d248 3
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

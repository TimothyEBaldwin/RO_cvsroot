head	4.6;
access;
symbols
	RISC_OSLib-5_97:4.6
	RISC_OSLib-5_96:4.6
	RISC_OSLib-5_95:4.6
	RISC_OSLib-5_94:4.6
	RISC_OSLib-5_93:4.6
	RISC_OSLib-5_92:4.6
	RISC_OSLib-5_91:4.6
	RISC_OSLib-5_90:4.6
	RISC_OSLib-5_89:4.6
	RISC_OSLib-5_88:4.6
	RISC_OSLib-5_87:4.6
	RISC_OSLib-5_86-1:4.6
	RISC_OSLib-5_86:4.6
	RISC_OSLib-5_85:4.6
	RISC_OSLib-5_84:4.6
	RISC_OSLib-5_83-2:4.6
	RISC_OSLib-5_83-1:4.6
	RISC_OSLib-5_83:4.6
	RISC_OSLib-5_82:4.6
	RISC_OSLib-5_81:4.6
	RISC_OSLib-5_75-2:4.6
	RISC_OSLib-5_80:4.6
	RISC_OSLib-5_79:4.6
	RISC_OSLib-5_78:4.6
	RISC_OSLib-5_75-1:4.6
	RISC_OSLib-5_77:4.6
	RISC_OSLib-5_76:4.6
	RISC_OSLib-5_75:4.6
	RISC_OSLib-5_74:4.6
	RISC_OSLib-5_73:4.6
	RISC_OSLib-5_72:4.6
	RISC_OSLib-5_71:4.6
	RISC_OSLib-5_70:4.6
	RISC_OSLib-5_69:4.6
	RISC_OSLib-5_68:4.6
	RISC_OSLib-5_67:4.6
	RISC_OSLib-5_66:4.6
	RISC_OSLib-5_65:4.6
	RISC_OSLib-5_64:4.6
	RISC_OSLib-5_63:4.5
	RISC_OSLib-5_62:4.5
	RISC_OSLib-5_61:4.5
	RISC_OSLib-5_60:4.5
	RISC_OSLib-5_59:4.5
	RISC_OSLib-5_58:4.5
	RISC_OSLib-5_57:4.5
	RISC_OSLib-5_56:4.5
	RISC_OSLib-5_55:4.5
	RISC_OSLib-5_54:4.5
	RISC_OSLib-5_53:4.5
	RISC_OSLib-5_52:4.5
	RISC_OSLib-5_51:4.5
	RO_5_07:4.5
	RISC_OSLib-5_50:4.5
	RISC_OSLib-5_49:4.5
	RISC_OSLib-5_46-4_64_2_1:4.5
	NoInlineAsm:4.5.0.2
	RISC_OSLib-5_48:4.5
	RISC_OSLib-5_47:4.5
	RISC_OSLib-5_46:4.5
	RISC_OSLib-5_45:4.5
	RISC_OSLib-5_44:4.5
	RISC_OSLib-5_43:4.5
	RISC_OSLib-5_42:4.5
	RISC_OSLib-5_41:4.5
	RISC_OSLib-5_40:4.4
	RISC_OSLib-5_39:4.4
	RISC_OSLib-5_38:4.4
	RISC_OSLib-5_37:4.4
	RISC_OSLib-5_36:4.3
	RISC_OSLib-5_35:4.3
	RISC_OSLib-5_34:4.3
	RISC_OSLib-5_33-4_50_2_1:4.3
	sbrodie_dev:4.3.0.2
	sbrodie_dev_bp:4.3
	RISC_OSLib-5_33:4.3
	RISC_OSLib-5_32:4.3
	RISC_OSLib-5_31:4.3
	RISC_OSLib-5_30:4.3
	RISC_OSLib-5_29:4.3
	RISC_OSLib-5_28:4.3
	RISC_OSLib-5_27:4.3
	RISC_OSLib-5_26:4.3
	RISC_OSLib-5_25:4.3
	RISC_OSLib-5_24:4.3
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.3
	RISC_OSLib-5_22:4.3
	RISC_OSLib-5_21:4.3
	RISC_OSLib-5_20:4.3
	RISC_OSLib-5_19:4.3
	RISC_OSLib-5_18:4.3
	RISC_OSLib-5_17:4.3
	RISC_OSLib-5_16:4.2
	RISC_OSLib-5_15:4.2
	dellis_autobuild_BaseSW:4.2
	RISC_OSLib-5_14:4.2
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.3
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2011.10.28.14.23.18;	author bavison;	state Exp;
branches;
next	4.5;
commitid	hIG6j26y6NoxM7Fv;

4.5
date	2002.05.22.10.45.24;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2002.03.21.14.36.24;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.10.03.08.18.22;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.09.14.14.42.06;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.48;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.48;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.48;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.11;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.32;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* printf.c: ANSI draft (X3J11 Oct 86) part of section 4.9 code */
/* Copyright (C) Codemist Ltd., 1988                            */
/* version 0.05b */

/* printf and its friends return the number of characters planted. In    */
/* the case of sprintf this does not include the terminating '\0'.       */
/* Consider using ftell instead of charcount in printf (see scanf).      */
/* see c.ansilib re possible use of #define NO_FLOATING_POINT.           */


#define __system_io 1      /* makes stdio.h declare more */
/* sprintf wants to know about the system part of the FILE descriptor, but
   it doesn't need to know about _extradata */
typedef struct _extradata {void *dummy;} _extradata;

#include "hostsys.h"
#include "kernel.h"
#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>
#include <string.h>

#define intofdigit(x) ((x)-'0')

#ifndef _LJUSTIFY  /* allow 'flat' compilation of library */

/* The following typedef and type of __vfprintf must match  fpprintf.c  */
typedef int (*fp_print)(int ch, double *d, char buff[], int flags,
                        char **lvprefix, int *lvprecision, int *lvbefore_dot,
                        int *lvafter_dot);

/* HIDDEN EXPORTS */
int __vfprintf(FILE *p, const char *fmt, va_list args,
               fp_print fp_display_fn, int lf_terminates);
int _fprintf(FILE *fp, const char *fmt, ...);
int _printf(const char *fmt, ...);
int _sprintf(char *buff, const char *fmt, ...);
int _snprintf(char *buff, size_t n, const char *fmt, ...);
int _vfprintf(FILE *p, const char *fmt, va_list args);
int _vsprintf(char *buff, const char *fmt, va_list a);

/* The following take LF or 0 terminated format strings so they work     */
/* with format strings fetched from message files                        */
int _fprintf_lf(FILE *fp, const char *fmt, ...);
int _sprintf_lf(char *buff, const char *fmt, ...);

/* The following macros must match those in fpprintf.c:                  */
/* The code here tends to be a bit generous about meaningless flag       */
/* combinations of options in the format string - it chooses the set     */
/* that it likes and prints according to that style without commenting   */
/* on the redundant options.                                             */

#define _LJUSTIFY         01
#define _SIGNED           02
#define _BLANKER          04
#define _VARIANT         010
#define _PRECGIVEN       020
#define _LONGSPECIFIER   040
#define _SHORTSPEC      0100
#define _PADZERO        0200    /* *** DEPRECATED FEATURE *** */
#define _FPCONV         0400
#define _CHARSPEC      01000
#define _LONGLONGSPEC  02000

#endif  /* _LJUSTIFY */

#define pr_padding(ch, n, p)  while(--n>=0) charcount++, putc(ch, p);

#define pre_padding(p)                                                    \
        if (!(flags&_LJUSTIFY))                                           \
        {   char padchar = flags & _PADZERO ? '0' : ' ';                  \
            pr_padding(padchar, width, p); }

#define post_padding(p)                                                   \
        if (flags&_LJUSTIFY)                                              \
        {   pr_padding(' ', width, p); }

#ifdef never /* do it this way? */
static int pr_num(unsigned int v, int flags, char *prefix,
                   int width, int precision, FILE *p)
{}
#endif

static int printf_display(FILE *p, int flags, int ch, int precision, int width,
                   unsigned long long v, fp_print fp_display_fn, char *prefix,
                   char *hextab, double *d)
{
    int charcount = 0;
    int len = 0, before_dot = -1, after_dot = -1;
    char buff[32];       /* used to accumulate value to print    */
/* here at the end of the switch statement I gather together code that   */
/* is concerned with displaying integers.                                */
/* AM: maybe this would be better as a proc if we could get arg count down */
            if ((flags & _FPCONV+_PRECGIVEN)==0) precision = 1;
            switch (ch)
            {
    case 'p':
    case 'X':
    case 'x':   while(v!=0)
                {   buff[len++] = hextab[v & 0xf];
                    v = v >> 4;
                }
                break;
    case 'o':   while(v!=0)
                {   buff[len++] = '0' + (char)(v & 07);
                    v = v >> 3;
                }
                break;
    case 'u':
    case 'i':
    case 'd':   while (v != 0)
                {   unsigned long long vDiv10 = v / 10U;
                    buff[len++] = '0' + (char)(v - vDiv10 * 10U);
                    v = vDiv10;
                }
                break;

#ifndef NO_FLOATING_POINT
    case 'f':   case 'F':
    case 'g':   case 'G':
    case 'e':   case 'E':
    case 'a':   case 'A':
                len = fp_display_fn(ch, d, buff, flags,
/* The following arguments are set by fp_display_fn                      */
                                    &prefix, &precision,
                                    &before_dot, &after_dot);
                break;

#else
/* If floating point is not supported I display ALL %e, %f and %g        */
/* items as 0.0                                                          */
    default:    buff[0] = '0';
                buff[1] = '.';
                buff[2] = '0';
                len = 3;
                break;
#endif
            }
/* now work out how many leading '0's are needed for precision specifier */
/* _FPCONV is the case of FP printing in which case extra digits to make */
/* up the precision come within the number as marked by characters '<'   */
/* and '>' in the buffer.                                                */
            if (flags & _FPCONV)
            {   precision = 0;
                if (before_dot>0) precision = before_dot-1;
                if (after_dot>0) precision += after_dot-1;
            }
            else if ((precision -= len)<0) precision = 0;

/* and how much padding is needed */
            width -= (precision + len + strlen(prefix));

/* AM: ANSI appear (Oct 86) to suggest that the padding (even if with '0') */
/*     occurs before the possible sign!  Treat this as fatuous for now.    */
            if (!(flags & _PADZERO)) pre_padding(p);

            {   int c;                                      /* prefix    */
                while((c=*prefix++)!=0) { putc(c, p); charcount++; }
            }

            pre_padding(p);

/* floating point numbers are in buff[] the normal way around, while     */
/* integers have been pushed in with the digits in reverse order.        */
            if (flags & _FPCONV)
            {   int i, c;
                for (i = 0; i<len; i++)
                {   switch (c = buff[i])
                    {
            case '<':   pr_padding('0', before_dot, p);
                        break;
            case '>':   pr_padding('0', after_dot, p);
                        break;
            default:    putc(c, p);
                        charcount++;
                        break;
                    }
                }
            }
            else
            {   pr_padding('0', precision, p);
                charcount += len;
                while((len--)>0) putc(buff[len], p);
            }

/* By here if the padding has already been printed width will be zero    */
            post_padding(p);
            return charcount;
}

int __vfprintf(FILE *p, const char *fmt, va_list args,
              fp_print fp_display_fn, int lf_terminates)
/* ACN: I apologize for this function - it seems long and ugly. Some of  */
/*      that is dealing with all the jolly flag options available with   */
/*      printf, and rather a lot more is a cautious floating point print */
/*      package that takes great care to avoid the corruption of its     */
/*      input by rounding, and to generate consistent decimal versions   */
/*      of all possible values in all possible formats.                  */
{
    int ch, charcount = 0;
    while ((ch = *fmt++) != 0 && (!lf_terminates || ch != '\n'))
    {   if (ch != '%') { putc(ch,p); charcount++; }
        else
        {   int flags = 0, width = 0, precision = 0;
/* The initialisation of hextab is spurious in that it will be set       */
/* to a real string before use, but necessary in that passing unset      */
/* parameters to functions is illegal in C.                              */
            char *prefix, *hextab = 0;
            unsigned long long v;
#ifndef NO_FLOATING_POINT
            double d;
#endif
/* This decodes all the nasty flags and options associated with an       */
/* entry in the format list. For some entries many of these options      */
/* will be useless, but I parse them all the same.                       */
            for (;;)
            {   switch (ch = *fmt++)
                {
/* '-'  Left justify converted flag. Only relevant if width specified    */
/* explicitly and converted value is too short to fill it.               */
        case '-':   flags = _LJUSTIFY | (flags & ~_PADZERO);
                    continue;

/* '+'  Always print either '+' or '-' at start of numbers.              */
        case '+':   flags |= _SIGNED;
                    continue;

/* ' '  Print either ' ' or '-' at start of numbers.                     */
        case ' ':   flags |= _BLANKER;
                    continue;

/* '#'  Variant on main print routine (effect varies across different    */
/*      styles, but for instance %#x puts 0x on the front of displayed   */
/*      numbers.                                                         */
        case '#':   flags |= _VARIANT;
                    continue;

/* '0'  Leading blanks are printed as zeros                              */
/*        This is a *** DEPRECATED FEATURE *** (precision subsumes)      */
        case '0':   flags |= _PADZERO;
                    continue;

        default:    break;
                }
                break;
            }

            /* now look for 'width' spec */
            {   int t = 0;
                if (ch=='*')
                {   t = va_arg(args, int);
/* If a negative width is passed as an argument I take its absolute      */
/* value and use the negativeness to indicate the presence of the '-'    */
/* flag (left justification). If '-' was already specified I lose it.    */
                    if (t<0)
                    {   t = - t;
                        flags ^= _LJUSTIFY;
                    }
                    ch = *fmt++;
                }
                else
                {   while (isdigit(ch))
                    {   t = t*10 + intofdigit(ch);
                        ch = *fmt++;
                    }
                }
                width = t>=0 ? t : 0;                 /* disallow -ve arg */
            }
            if (ch == '.')                            /* precision spec */
            {   int t = 0;
                ch = *fmt++;
                if (ch=='*')
                {   t = va_arg(args, int);
                    ch = *fmt++;
                }
                else while (isdigit(ch))
                {   t = t*10 + intofdigit(ch);
                    ch = *fmt++;
                }
                if (t >= 0) flags |= _PRECGIVEN, precision = t;
            }
            if (ch=='l' || ch=='L' || ch=='z' || ch=='t')
/* 'l'  Indicate that a numeric argument is 'long'. Here int and long    */
/*      are the same (32 bits) and so I can ignore this flag!            */
/* 'L'  Marks floating arguments as being of type long double. Here this */
/*      is the same as just double, and so I can ignore the flag.        */
/* 'z'  Indicates that a numeric argument is 'size_t', or that a %n      */
/*      argument is a pointer to a size_t. We can ignore it.             */
/* 't'  Indicates that a numeric argument is 'ptrdiff_t', or that a %n   */
/*      argument is a pointer to a ptrdiff_t. We can ignore it.          */
            {   int last = ch;
                flags |= _LONGSPECIFIER;
                ch = *fmt++;
/* 'll' Indicates that a numeric argument is 'long long', or that a %n   */
/*      argument is a pointer to long long int.                          */
                if (ch=='l' && last =='l')
                {   flags |= _LONGLONGSPEC;
                    ch = *fmt++;
                }
            }
            else if (ch=='h')
/* 'h'  Indicates that an integer value is to be treated as short.        */
            {   flags |= _SHORTSPEC;
                ch = *fmt++;
/* 'hh' Indicates that an integer value is to be treated as char.        */
                if (ch=='h')
                {   flags |= _CHARSPEC;
                    ch = *fmt++;
                }
            }
            else if (ch=='j')
/* 'j'  Indicates that a numeric argument is '[u]intmax_t', or than a %n */
/*      argument is a pointer to intmax_t.                               */
            {   flags |= _LONGSPECIFIER|_LONGLONGSPEC;
                ch = *fmt++;
            }

/* Now the options have been decoded - I can process the main dispatch   */
            switch (ch)
            {

/* %c causes a single character to be fetched from the argument list     */
/* and printed. This is subject to padding.                              */
    case 'c':   ch = va_arg(args, int);
                /* drop through */

/* %? where ? is some character not properly defined as a command char   */
/* for printf causes ? to be displayed with padding and field widths     */
/* as specified by the various modifers. %% is handled by this general   */
/* mechanism.                                                            */
    default:    width--;                        /* char width is 1       */
                pre_padding(p);
                putc(ch, p);
                charcount++;
                post_padding(p);
                continue;

/* If a '%' occurs at the end of a format string (possibly with a few    */
/* width specifiers and qualifiers after it) I end up here with a '\0'   */
/* in my hand. Unless I do something special the fact that the format    */
/* string terminated gets lost...                                        */
/* Ditto for '\n' terminated strings. "%\n" doesn't mean anything anyway */
    case '\n':
    case 0:     fmt--;
                continue;

/* %n assigns the number of chars printed so far to the next arg (which  */
/* is expected to be of type (int *), or (long long *) if 'j' or 'll'.   */
    case 'n':   if (flags & _LONGLONGSPEC)
                {   long long *xp = va_arg(args, long long *);
                    *xp = charcount;
                }
                else
                {   int *xp = va_arg(args, int *);
                    *xp = charcount;
                }
                continue;

/* %s prints a string. If a precision is given it can limit the number   */
/* of characters taken from the string, and padding and justification    */
/* behave as usual.                                                      */
    case 's':   {   char *str = va_arg(args, char *);
                    int i, n;
                    if (flags&_PRECGIVEN) {
                      n = 0;
                      while ((n < precision) && (str[n] != 0)) n++;
                    } else
                      n = strlen(str);
                    width -= n;
                    pre_padding(p);
                    for (i=0; i<n; i++) putc(str[i], p);
                    charcount += n;
                    post_padding(p);
                }
                continue;

/* %x prints in hexadecimal. %X does the same, but uses upper case       */
/* when printing things that are not (decimal) digits.                   */
/* I can share some messy decoding here with the code that deals with    */
/* octal and decimal output via %o and %d.                               */
    case 'X':   v = (flags & _LONGLONGSPEC) ? va_arg(args, unsigned long long)
                                            : va_arg(args, unsigned int);
                if (flags & _SHORTSPEC) v = (unsigned short)v;
                if (flags & _CHARSPEC) v = (unsigned char)v;
                hextab = "0123456789ABCDEF";
                prefix = ((flags&_VARIANT) != 0 && v != 0)? "0X" : "";
                if (flags & _PRECGIVEN) flags &= ~_PADZERO;
                break;

    case 'x':   v = (flags & _LONGLONGSPEC) ? va_arg(args, unsigned long long)
                                            : va_arg(args, unsigned int);
                if (flags & _SHORTSPEC) v = (unsigned short)v;
                if (flags & _CHARSPEC) v = (unsigned char)v;
                hextab = "0123456789abcdef";
                prefix = ((flags&_VARIANT) != 0 && v != 0)? "0x" : "";
                if (flags & _PRECGIVEN) flags &= ~_PADZERO;
                break;

/* %p is for printing a pointer - I print it as a hex number with the    */
/* precision always forced to 8.                                         */
    case 'p':   v = (unsigned int)va_arg(args, void *);
                hextab = "0123456789abcdef";
                prefix = (flags&_VARIANT) ? "@@" : "";
                flags |= _PRECGIVEN;
                precision = 8;
                break;

    case 'o':   v = (flags & _LONGLONGSPEC) ? va_arg(args, unsigned long long)
                                            : va_arg(args, unsigned int);
                if (flags & _SHORTSPEC) v = (unsigned short)v;
                if (flags & _CHARSPEC) v = (unsigned char)v;
                prefix = (flags&_VARIANT) ? "0" : "";
                if (flags & _PRECGIVEN) flags &= ~_PADZERO;
                break;

    case 'u':   v = (flags & _LONGLONGSPEC) ? va_arg(args, unsigned long long)
                                            : va_arg(args, unsigned int);
                if (flags & _SHORTSPEC) v = (unsigned short)v;
                if (flags & _CHARSPEC) v = (unsigned char)v;
                prefix = "";
                if (flags & _PRECGIVEN) flags &= ~_PADZERO;
                break;

    case 'i':
    case 'd':   {   long long w;
                    w = (flags & _LONGLONGSPEC) ? va_arg(args, long long)
                                                : va_arg(args, int);
                    if (flags & _SHORTSPEC) w = (signed short)w;
                    if (flags & _CHARSPEC) w = (signed char)w;
                    if (w<0) v = 0ULL-w, prefix = "-";
                    else
                        v = w, prefix = (flags&_SIGNED) ? "+" :
                                        (flags&_BLANKER) ? " " : "";
                }
                if (flags & _PRECGIVEN) flags &= ~_PADZERO;
                break;

    case 'f':
    case 'F':
    case 'e':
    case 'E':
    case 'g':
    case 'G':
    case 'a':
    case 'A':   flags |= _FPCONV;
                if (!(flags & _PRECGIVEN)) precision = 6;
#ifndef NO_FLOATING_POINT
                d = va_arg(args, double);
                /* technically, for the call to printf_display() below to  */
                /* be legal and not reference an undefined variable we     */
                /* need to do the following (overwritten in fp_display_fn) */
                /* (It also stops dataflow analysis (-fa) complaining!)    */
                prefix = 0, hextab = 0, v = 0;
#else  /* NO_FLOATING_POINT */
                {   int w = va_arg(args, int);
                    w = va_arg(args, int);
/* If the pre-processor symbol FLOATING_POINT is not set I assume that   */
/* floating point is not available, and so support %e, %f, %g and %a     */
/* with a fragment of code that skips over the relevant argument.        */
/* I also assume that a double takes two int-sized arg positions.        */
                    prefix = (flags&_SIGNED) ? "+" :
                             (flags&_BLANKER) ? " " : "";
                }
#endif /* NO_FLOATING_POINT */
                break;

            }
            charcount += printf_display(p, flags, ch, precision, width, v,
                                        fp_display_fn, prefix, hextab, &d);
            continue;
        }
    }
    return ferror(p) && !(p->__flag & _IOSTRG) ? EOF : charcount;
}

static int no_fp_display(int ch, double *d, char buff[], int flags,
                         char **lvprefix, int *lvprecision, int *lvbefore_dot,
                         int *lvafter_dot)
{
    ch = ch;
    d = d;
    buff = buff;
    flags = flags;
    lvprefix = lvprefix;
    lvprecision = lvprecision;
    lvbefore_dot = lvbefore_dot;
    lvafter_dot = lvafter_dot;
    return 0;
}

int _fprintf(FILE *fp, const char *fmt, ...)
{
    va_list a;
    int n;

    va_start(a, fmt);
    n = __vfprintf(fp, fmt, a, no_fp_display, 0);
    va_end(a);
    return n;
}

int _fprintf_lf(FILE *fp, const char *fmt, ...)
{
    va_list a;
    int n;

    va_start(a, fmt);
    n = __vfprintf(fp, fmt, a, no_fp_display, 1);
    va_end(a);
    return n;
}

int _printf(const char *fmt, ...)
{
    va_list a;
    int n;
    va_start(a, fmt);
    n = __vfprintf(stdout, fmt, a, no_fp_display, 0);
    va_end(a);
    return n;
}

int _sprintf(char *buff, const char *fmt, ...)
{
    FILE hack;
    va_list a;
/*************************************************************************/
/* Note that this code interacts in a dubious way with the putc macro.   */
/*************************************************************************/
    int length;
    va_start(a, fmt);
    memclr(&hack, sizeof(FILE));
    hack.__flag = _IOSTRG+_IOWRITE;
    hack.__ptr = (unsigned char *)buff;
    hack.__ocnt = 0x7fffffff;
    length = __vfprintf(&hack, fmt, a, no_fp_display, 0);
    putc(0,&hack);
    va_end(a);
    return(length);
}

int _snprintf(char *buff, size_t n, const char *fmt, ...)
{
    FILE hack;
    va_list a;
/*************************************************************************/
/* Note that this code interacts in a dubious way with the putc macro.   */
/*************************************************************************/
    int length;
    va_start(a, fmt);
    memclr(&hack, sizeof(FILE));
    hack.__flag = _IOSTRG+_IOWRITE;
    hack.__ptr = (unsigned char *)buff;
    hack.__ocnt = n == 0 ? 0 : n-1;
    length = __vfprintf(&hack, fmt, a, no_fp_display, 0);
    if (n != 0) *hack.__ptr = 0;
    va_end(a);
    return(length);
}

int _sprintf_lf(char *buff, const char *fmt, ...)
{
    FILE hack;
    va_list a;
/*************************************************************************/
/* Note that this code interacts in a dubious way with the putc macro.   */
/*************************************************************************/
    int length;
    va_start(a, fmt);
    memclr(&hack, sizeof(FILE));
    hack.__flag = _IOSTRG+_IOWRITE;
    hack.__ptr = (unsigned char *)buff;
    hack.__ocnt = 0x7fffffff;
    length = __vfprintf(&hack, fmt, a, no_fp_display, 1);
    putc(0,&hack);
    va_end(a);
    return(length);
}

int _vfprintf(FILE *p, const char *fmt, va_list args)
{
    return __vfprintf(p, fmt, args, no_fp_display, 0);
}

int _vsprintf(char *buff, const char *fmt, va_list a)
{
    FILE hack;
/*************************************************************************/
/* Note that this code interacts in a dubious way with the putc macro.   */
/*************************************************************************/
    int length;
    memclr(&hack, sizeof(FILE));
    hack.__flag = _IOSTRG+_IOWRITE;
    hack.__ptr = (unsigned char *)buff;
    hack.__ocnt = 0x7fffffff;
    length = __vfprintf(&hack, fmt, a, no_fp_display, 0);
    putc(0,&hack);
    return(length);
}

/* End of printf.c */
@


4.5
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@d120 1
a120 1
                {   buff[len++] = '0' + (v & 07);
d128 1
a128 1
                    buff[len++] = '0' + v - vDiv10 * 10U;
@


4.4
log
@Added the following C99 features:

  * snprintf(), vsnprintf(), vfscanf(), vscanf(), vsscanf()
  * hh, j, z and t printf length modifiers (indicating char, intmax_t, size_t
    and ptrdiff_t respectively)
  * Hexadecimal floating-point printing and scanning (%a/%A)
  * %F printf() specifier (upper-case form of %F)
  * Input/output of NaNs and Infinities
  * imaxdiv_t, imaxdiv(), strtoimax(), strtoumax() (simulated through macros)
  * <fenv.h>: feclearexcept(), fegetexceptflag(), feraiseexcept(),
              fesetexceptflag(), fetestexcept(), fegetround(), fesetround(),
              fegetenv(), feholdexcept(), fesetenv(), feupdateenv()
  * FLT_EVAL_METHOD, DECIMAL_DIG
  * hypot(), hypotf(), fabsf(), fdim(), fdimf(), fmax(), fmaxf(), fmin(),
    fminf()
  * INFINITY, NAN, fpclassify(), isfinite(), isinf(), isnan(), isnormal(),
    signbit(), copysign(), copysignf(), nan(), nanf(), nextafter(),
    nextafterf() isgreater(), isgreaterequal(), isless(), islessequal(),
    islessgreater(), isunordered()

This involves adding 36 new entries to the stubs. Current versions of the C
library will not fault client programs with such larger stubs, but will fill
in the extra entries with junk. Programs requiring the new functions will have
to RMEnsure this version of the Shared C Library.

This version of the C library has been fixed so that in future, any extra
unknown stubs entries will be filled in with a branch to zero, rather than
corrupted.

Requires cc 5.41 or later, both to build, and to make use of some of the extra
facilities.


Version 5.37. Tagged as 'RISC_OSLib-5_37'
@
text
@d78 1
d100 1
a100 1
                   unsigned int v, fp_print fp_display_fn, char *prefix,
d127 1
a127 1
                {   unsigned int vDiv10 = _kernel_udiv10(v);
d224 1
a224 1
            unsigned int v;
d297 1
a297 1
            if (ch=='l' || ch=='L' || ch=='j' || ch=='z' || ch=='t')
a301 2
/* 'j'  Indicates that a numeric argument is 'intmax_t', or that a %n    */
/*      argument is a pointer to an intmax_t. We can ignore it.          */
d306 2
a307 1
            {   flags |= _LONGSPECIFIER;
d309 6
d317 1
a317 1
/* 'h' Indicates that an integer value is to be treated as short.        */
d320 1
d326 6
d363 7
a369 2
/* is expected to be of type (int *).                                    */
    case 'n':   {   int *xp = va_arg(args, int *);
d396 2
a397 1
    case 'X':   v = va_arg(args, int);
d405 2
a406 1
    case 'x':   v = va_arg(args, int);
d423 2
a424 1
    case 'o':   v = va_arg(args, int);
d431 2
a432 1
    case 'u':   v = va_arg(args, unsigned int);
d440 3
a442 1
    case 'd':   {   int w = va_arg(args, int);
d445 1
a445 1
                    if (w<0) v = 0U-w, prefix = "-";
@


4.3
log
@printf specifier %#x corrected to prepend "0x" instead of "0X".

Version 5.17. Tagged as 'RISC_OSLib-5_17'
@
text
@d53 1
d77 1
d133 1
a133 1
    case 'f':
d136 1
d296 1
a296 1
            if (ch=='l' || ch=='L')
d301 6
d314 4
d380 1
d388 1
d405 1
d412 1
d420 1
d430 1
d434 3
a436 1
    case 'G':   flags |= _FPCONV;
d449 2
a450 2
/* floating point is not available, and so support %e, %f and %g with    */
/* a fragment of code that skips over the relevant argument.             */
d464 1
a464 1
    return ferror(p) ? EOF : charcount;
d529 19
@


4.2
log
@  Fixed minor printf bug.
Detail:
  %#x shows a leading 0x (and %#X leads with 0X) only when the value
    to be displayed is NOT zero.
Admin:
  Cross-verified against: C89 standard; C9X standard; gcc 2.95 implementation.
  Built.

Version 5.14. Tagged as 'RISC_OSLib-5_14'
@
text
@d375 1
a375 1
                prefix = ((flags&_VARIANT) != 0 && v != 0)? "0X" : "";
@


4.1
log
@Initial revision
@
text
@d368 1
a368 1
                prefix = (flags&_VARIANT) ? "0X" : "";
d375 1
a375 1
                prefix = (flags&_VARIANT) ? "0x" : "";
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

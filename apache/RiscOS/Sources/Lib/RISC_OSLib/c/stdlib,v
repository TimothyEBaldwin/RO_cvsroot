head	4.7;
access;
symbols
	RISC_OSLib-5_97:4.7
	RISC_OSLib-5_96:4.7
	RISC_OSLib-5_95:4.7
	RISC_OSLib-5_94:4.7
	RISC_OSLib-5_93:4.7
	RISC_OSLib-5_92:4.7
	RISC_OSLib-5_91:4.7
	RISC_OSLib-5_90:4.7
	RISC_OSLib-5_89:4.7
	RISC_OSLib-5_88:4.7
	RISC_OSLib-5_87:4.7
	RISC_OSLib-5_86-1:4.7
	RISC_OSLib-5_86:4.7
	RISC_OSLib-5_85:4.7
	RISC_OSLib-5_84:4.7
	RISC_OSLib-5_83-2:4.7
	RISC_OSLib-5_83-1:4.7
	RISC_OSLib-5_83:4.7
	RISC_OSLib-5_82:4.7
	RISC_OSLib-5_81:4.7
	RISC_OSLib-5_75-2:4.7
	RISC_OSLib-5_80:4.7
	RISC_OSLib-5_79:4.7
	RISC_OSLib-5_78:4.7
	RISC_OSLib-5_75-1:4.7
	RISC_OSLib-5_77:4.7
	RISC_OSLib-5_76:4.7
	RISC_OSLib-5_75:4.7
	RISC_OSLib-5_74:4.7
	RISC_OSLib-5_73:4.7
	RISC_OSLib-5_72:4.7
	RISC_OSLib-5_71:4.7
	RISC_OSLib-5_70:4.7
	RISC_OSLib-5_69:4.7
	RISC_OSLib-5_68:4.7
	RISC_OSLib-5_67:4.7
	RISC_OSLib-5_66:4.7
	RISC_OSLib-5_65:4.7
	RISC_OSLib-5_64:4.7
	RISC_OSLib-5_63:4.7
	RISC_OSLib-5_62:4.7
	RISC_OSLib-5_61:4.7
	RISC_OSLib-5_60:4.7
	RISC_OSLib-5_59:4.7
	RISC_OSLib-5_58:4.7
	RISC_OSLib-5_57:4.7
	RISC_OSLib-5_56:4.7
	RISC_OSLib-5_55:4.7
	RISC_OSLib-5_54:4.7
	RISC_OSLib-5_53:4.7
	RISC_OSLib-5_52:4.6
	RISC_OSLib-5_51:4.6
	RO_5_07:4.6
	RISC_OSLib-5_50:4.6
	RISC_OSLib-5_49:4.6
	RISC_OSLib-5_46-4_64_2_1:4.6
	NoInlineAsm:4.6.0.2
	RISC_OSLib-5_48:4.6
	RISC_OSLib-5_47:4.6
	RISC_OSLib-5_46:4.6
	RISC_OSLib-5_45:4.5
	RISC_OSLib-5_44:4.5
	RISC_OSLib-5_43:4.5
	RISC_OSLib-5_42:4.5
	RISC_OSLib-5_41:4.5
	RISC_OSLib-5_40:4.4
	RISC_OSLib-5_39:4.4
	RISC_OSLib-5_38:4.4
	RISC_OSLib-5_37:4.4
	RISC_OSLib-5_36:4.3
	RISC_OSLib-5_35:4.3
	RISC_OSLib-5_34:4.3
	RISC_OSLib-5_33-4_50_2_1:4.3
	sbrodie_dev:4.3.0.2
	sbrodie_dev_bp:4.3
	RISC_OSLib-5_33:4.3
	RISC_OSLib-5_32:4.3
	RISC_OSLib-5_31:4.3
	RISC_OSLib-5_30:4.3
	RISC_OSLib-5_29:4.3
	RISC_OSLib-5_28:4.3
	RISC_OSLib-5_27:4.3
	RISC_OSLib-5_26:4.3
	RISC_OSLib-5_25:4.3
	RISC_OSLib-5_24:4.3
	RISC_OSLib-5_01-4_16_2_5:4.2
	RISC_OSLib-5_23:4.3
	RISC_OSLib-5_22:4.3
	RISC_OSLib-5_21:4.3
	RISC_OSLib-5_20:4.3
	RISC_OSLib-5_19:4.3
	RISC_OSLib-5_18:4.3
	RISC_OSLib-5_17:4.3
	RISC_OSLib-5_16:4.3
	RISC_OSLib-5_15:4.3
	dellis_autobuild_BaseSW:4.3
	RISC_OSLib-5_14:4.3
	RISC_OSLib-5_13:4.3
	RISC_OSLib-5_12:4.3
	RISC_OSLib-5_01-4_16_2_4:4.2
	RISC_OSLib-5_11:4.3
	RISC_OSLib-5_01-4_16_2_3:4.2
	RISC_OSLib-5_01-4_16_2_2:4.2
	RISC_OSLib-5_10:4.3
	RISC_OSLib-5_01-4_16_2_1:4.2
	Bethany:4.2.0.4
	RISC_OSLib-5_09:4.3
	RISC_OSLib-5_08:4.3
	RISC_OSLib-5_07:4.3
	RISC_OSLib-5_06:4.3
	RISC_OSLib-4_97-4_12_2_8:4.2.2.1
	RISC_OSLib-5_05:4.2
	RISC_OSLib-5_04:4.2
	sbrodie_sedwards_16Mar2000:4.2
	RISC_OSLib-5_03:4.2
	RISC_OSLib-5_02:4.2
	RISC_OSLib-4_97-4_12_2_7:4.2.2.1
	RISC_OSLib-5_01:4.2
	RISC_OSLib-5_00:4.2
	RISC_OSLib-4_99:4.2
	RISC_OSLib-4_98:4.2
	RISC_OSLib-4_97-4_12_2_6:4.2.2.1
	RISC_OSLib-4_97-4_12_2_5:4.2
	RISC_OSLib-4_97-4_12_2_4:4.2
	RISC_OSLib-4_97-4_12_2_3:4.2
	RISC_OSLib-4_97-4_12_2_2:4.2
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.2
	kbracey_32bit:4.2.0.2
	kbracey_32bit_bp:4.2
	dcotton_autobuild_BaseSW:4.3
	RISC_OSLib-4_97:4.2
	RISC_OSLib-4_96:4.2
	RISC_OSLib-4_95:4.2
	RISC_OSLib-4_94:4.2
	RISC_OSLib-4_93:4.2
	RISC_OSLib-4_92:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.2
	RISC_OSLib-4_91:4.2
	RISC_OSLib-4_90:4.2
	RISC_OSLib-4_89:4.2
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.2
	RISC_OSLib-4_87:4.2
	blaughto_daytona_appflash-0_30:4.2
	rmanby_clib-4_86:4.2
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2005.03.14.12.15.40;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2003.04.15.16.50.23;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2002.05.22.10.45.24;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2002.03.21.14.36.24;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.14.09.21;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.08.21.09.42.56;	author rmanby;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.24.49;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	99.11.23.13.42.44;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.24.49;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.55;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.24;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.39;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@* Improved stdio to allocate extra FILE objects beyond the static array of
  16. Number of open files now only limited by memory and the OS.
* FOPEN_MAX in <stdio.h> increased from 8 to 16 to reflect reality.
* Minor corrections to comments in <stdio.h>.
* Library shutdown tidied for modules. In particular, shutdown of I/O was
  broken for modules which had been entered as applications.

Version 5.53. Tagged as 'RISC_OSLib-5_53'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* stdlib.c: ANSI draft (X3J11 Oct 86) library, section 4.10 */
/* Copyright (C) Codemist Ltd, 1988 */
/* version 0.02a */

#include "hostsys.h"      /* for _terminateio(), and _exit() etc */
#include "kernel.h"
#include <stdlib.h>
#include <signal.h>

/* atof, atoi, atol, strtod, strtol, strtoul are implemented in scanf.c  */

/* mblen, mbtowc, wctomb, mbstowcs, wcstombs are implemented in locale.c */

/* div and ldiv are implemented in machine code */

static unsigned long int next = 1;

int _ANSI_rand(void)     /* This is the ANSI suggested portable code */
{
    next = next * 1103515245 + 12345;
    return (unsigned int) (next >> 16) % 32768;
}

void _ANSI_srand(unsigned int seed)
{
    next = seed;
}

/* Now the random-number generator that the world is expected to use */

static unsigned _random_number_seed[55] =
/* The values here are just those that would be put in this horrid
   array by a call to __srand(1). DO NOT CHANGE __srand() without
   making a corresponding change to these initial values.
*/
{   0x00000001, 0x66d78e85, 0xd5d38c09, 0x0a09d8f5, 0xbf1f87fb,
    0xcb8df767, 0xbdf70769, 0x503d1234, 0x7f4f84c8, 0x61de02a3,
    0xa7408dae, 0x7a24bde8, 0x5115a2ea, 0xbbe62e57, 0xf6d57fff,
    0x632a837a, 0x13861d77, 0xe19f2e7c, 0x695f5705, 0x87936b2e,
    0x50a19a6e, 0x728b0e94, 0xc5cc55ae, 0xb10a8ab1, 0x856f72d7,
    0xd0225c17, 0x51c4fda3, 0x89ed9861, 0xf1db829f, 0xbcfbc59d,
    0x83eec189, 0x6359b159, 0xcc505c30, 0x9cbc5ac9, 0x2fe230f9,
    0x39f65e42, 0x75157bd2, 0x40c158fb, 0x27eb9a3e, 0xc582a2d9,
    0x0569d6c2, 0xed8e30b3, 0x1083ddd2, 0x1f1da441, 0x5660e215,
    0x04f32fc5, 0xe18eef99, 0x4a593208, 0x5b7bed4c, 0x8102fc40,
    0x515341d9, 0xacff3dfa, 0x6d096cb5, 0x2bb3cc1d, 0x253d15ff
};

static int _random_j = 23, _random_k = 54;

int rand(void)
{
/* See Knuth vol 2 section 3.2.2 for a discussion of this random
   number generator.
*/
    unsigned int temp;
    temp = (_random_number_seed[_random_k] += _random_number_seed[_random_j]);
    if (--_random_j == 0) _random_j = 54, --_random_k;
    else if (--_random_k == 0) _random_k = 54;
    return (temp & 0x7fffffff);         /* result is a 31-bit value */
    /* It seems that it would not be possible, under ANSI rules, to */
    /* implement this as a 32-bit value. What a shame!              */
}

void srand(unsigned int seed)
{
/* This only allows you to put 32 bits of seed into the random sequence,
   but it is very improbable that you have any good source of randomness
   that good to start with anyway! A linear congruential generator
   started from the seed is used to expand from 32 to 32*55 bits.
*/
    int i;
    _random_j = 23;
    _random_k = 54;
    for (i = 0; i<55; i++)
    {   _random_number_seed[i] = seed + (seed >> 16);
/* This is not even a good way of setting the initial values.  For instance */
/* a better scheme would have r<n+1> = 7^4*r<n> mod (3^31-1).  Still I will */
/* leave this for now.                                                      */
        seed = 69069*seed + 1725307361;  /* computed modulo 2^32 */
    }
}

/* free, malloc, realloc etc are in the file alloc.c                     */

#define EXIT_LIMIT 33

typedef void (*vprocp)(void);
static union { vprocp p; int i; } _exitvector[EXIT_LIMIT] = { 0 };
       /* initialised so not in bss (or shared library trouble) */
static struct {
    char number_of_exit_functions;
    char alloc_finalised, io_finalised, getenv_finalised;
} exit_s;

void _exit_init(void)
{
    if (_kernel_client_is_module()) {
        /* leave SWI mode exit handlers in place. number_of_exit_functions
           is guaranteed reasonable */
        while (exit_s.number_of_exit_functions != 0)
            if (_exitvector[--exit_s.number_of_exit_functions].i & 3) {
                ++exit_s.number_of_exit_functions; break;
            }
    } else
        exit_s.number_of_exit_functions = 0;
    exit_s.alloc_finalised = 0; exit_s.io_finalised = 0; exit_s.getenv_finalised = 0;
}

int atexit(vprocp func)
{
    if (exit_s.number_of_exit_functions >= EXIT_LIMIT) return 1;    /* failure */
    _exitvector[exit_s.number_of_exit_functions++].i =
        (int) func + ((_kernel_processor_mode() & 0xF) != 0);
    return 0;                                                /* success */
}

void _lib_shutdown(void)
{
    int mode = ((_kernel_processor_mode() & 0xF) != 0);
    int ismodule = _kernel_client_is_module(); /* ie is module app, so not */
                                               /* total shutdown           */
    while (exit_s.number_of_exit_functions!=0) {
        vprocp fn = _exitvector[--exit_s.number_of_exit_functions].p;
        int flags = _exitvector[exit_s.number_of_exit_functions].i;
        if ((flags & 3) != mode) { ++exit_s.number_of_exit_functions; break; };
        /* Take extra care with fn ptr - consider Thumb */
        fn = (vprocp) ((unsigned) fn &~ 3);
        _call_client_0(fn);
    }
    /* ensure no recursion if finalisation fails */
    if (!exit_s.getenv_finalised && !ismodule)
    { exit_s.getenv_finalised = 1; _terminate_getenv(); }
    if (!exit_s.alloc_finalised)
    { exit_s.alloc_finalised = 1; _terminate_user_alloc(); }
    if (!exit_s.io_finalised)
    { exit_s.io_finalised = 1; _terminateio(); }
    if (ismodule) /* Want terminateio again for module part */
        exit_s.io_finalised = 0;
}


void exit(int n)
{
/* No longer calls _lib_shutdown: that is done as C finalisation called
   from _kernel_exit.
 */
    _exit(n);
}

void _Exit(int n)
{
/* Is this the best way of doing this? abort() probably shouldn't be calling
 * atexit functions either...
 */
    while (exit_s.number_of_exit_functions!=0) {
        int flags = _exitvector[exit_s.number_of_exit_functions].i;
        if ((flags & 3) != 0) { ++exit_s.number_of_exit_functions; break; };
    }
    _exit(n);
}

void abort(void)
{
    raise(SIGABRT);
    exit(1);
}

int (abs)(int x) { return abs(x); }

long int (labs)(long int x) { return labs(x); }

#if 0
/* Compiler generates poo code at the minute - in machine code for now */
long long int llabs(long long int x) {
    if (x<0) return (-x);
    else return x;
}
#endif


/* end of stdlib.c */
@


4.6
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d33 1
a33 1
int _ANSI_rand()     /* This is the ANSI suggested portable code */
d66 1
a66 1
int rand()
d111 1
a111 1
void _exit_init()
d133 1
a133 1
void _lib_shutdown()
d136 2
d142 2
d147 8
a154 3
    if (!exit_s.getenv_finalised) { exit_s.getenv_finalised = 1; _terminate_getenv(); }
    if (!exit_s.alloc_finalised) { exit_s.alloc_finalised = 1; _terminate_user_alloc(); }
    if (!exit_s.io_finalised) { exit_s.io_finalised = 1; _terminateio(); }
d178 1
a178 1
void abort()
@


4.5
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@d157 12
d175 1
a175 5
int abs(int x)
{
    if (x<0) return (-x);
    else return x;
}
d177 1
a177 5
long int labs(long int x)
{
    if (x<0) return (-x);
    else return x;
}
@


4.4
log
@Added the following C99 features:

  * snprintf(), vsnprintf(), vfscanf(), vscanf(), vsscanf()
  * hh, j, z and t printf length modifiers (indicating char, intmax_t, size_t
    and ptrdiff_t respectively)
  * Hexadecimal floating-point printing and scanning (%a/%A)
  * %F printf() specifier (upper-case form of %F)
  * Input/output of NaNs and Infinities
  * imaxdiv_t, imaxdiv(), strtoimax(), strtoumax() (simulated through macros)
  * <fenv.h>: feclearexcept(), fegetexceptflag(), feraiseexcept(),
              fesetexceptflag(), fetestexcept(), fegetround(), fesetround(),
              fegetenv(), feholdexcept(), fesetenv(), feupdateenv()
  * FLT_EVAL_METHOD, DECIMAL_DIG
  * hypot(), hypotf(), fabsf(), fdim(), fdimf(), fmax(), fmaxf(), fmin(),
    fminf()
  * INFINITY, NAN, fpclassify(), isfinite(), isinf(), isnan(), isnormal(),
    signbit(), copysign(), copysignf(), nan(), nanf(), nextafter(),
    nextafterf() isgreater(), isgreaterequal(), isless(), islessequal(),
    islessgreater(), isunordered()

This involves adding 36 new entries to the stubs. Current versions of the C
library will not fault client programs with such larger stubs, but will fill
in the extra entries with junk. Programs requiring the new functions will have
to RMEnsure this version of the Shared C Library.

This version of the C library has been fixed so that in future, any extra
unknown stubs entries will be filled in with a branch to zero, rather than
corrupted.

Requires cc 5.41 or later, both to build, and to make use of some of the extra
facilities.


Version 5.37. Tagged as 'RISC_OSLib-5_37'
@
text
@d104 1
a104 1
static union { vprocp p; int i; } _exitvector[EXIT_LIMIT] = {};
d174 8
@


4.3
log
@32-bit work merged from kbracey_32bit branch.

Version 5.06. Tagged as 'RISC_OSLib-5_06'
@
text
@d29 2
a172 20
}

div_t div(int numer, int denom)
{
/* This is a candidate for re-implementation in machine code so that the */
/* quotient and remainder can be computed all at once. However I am not  */
/* really convinced about the importance of the function so will not do  */
/* that yet!                                                             */
    div_t res;
    res.quot = numer / denom;
    res.rem  = numer % denom;
    return res;
}

ldiv_t ldiv(long int numer, long int denom)
{
    ldiv_t res;
    res.quot = numer / denom;
    res.rem  = numer % denom;
    return res;
@


4.2
log
@Fixed an RMA leak.

If a module written in C uses function getenv, buffer space
is allocated in the RMA. This buffer was never freed, leading
to RMA leakage when the module was 'RMKill'ed or 'RMReInit'ed.

Changes

 c.armsys
   added function _terminate_getenv to free the buffer

 c.stdlib
   added flag getenv_finalised to the exit_s structure

   initialised getenv_finalised in function _exit_init

   atexit tests getenv_finalised, calls _terminate_getenv

 s.version
   version string changed to 4.86 (27 Jul 1998)
@
text
@d127 1
a127 1
        (int) func + _kernel_processor_mode();
d133 1
a133 1
    int mode = _kernel_processor_mode();
d136 2
a137 1
        if (((int) fn) & 3 != mode) { ++exit_s.number_of_exit_functions; break; };
@


4.2.2.1
log
@More 32-bit compatibility added.  All the C code should now be OK.
Fixed some typos in kernel.s.k_body too.

Version 4.97, 4.12.2.6. Tagged as 'RISC_OSLib-4_97-4_12_2_6'
@
text
@d127 1
a127 1
        (int) func + ((_kernel_processor_mode() & 0xF) != 0);
d133 1
a133 1
    int mode = ((_kernel_processor_mode() & 0xF) != 0);
d136 1
a136 2
        int flags = _exitvector[exit_s.number_of_exit_functions].i;
        if ((flags & 3) != mode) { ++exit_s.number_of_exit_functions; break; };
@


4.1
log
@Initial revision
@
text
@d106 1
a106 1
    char alloc_finalised, io_finalised;
d120 1
a120 1
    exit_s.alloc_finalised = 0; exit_s.io_finalised = 0;
d140 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

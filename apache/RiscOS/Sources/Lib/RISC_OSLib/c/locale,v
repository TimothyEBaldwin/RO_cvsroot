head	4.6;
access;
symbols
	RISC_OSLib-5_97:4.6
	RISC_OSLib-5_96:4.6
	RISC_OSLib-5_95:4.6
	RISC_OSLib-5_94:4.6
	RISC_OSLib-5_93:4.6
	RISC_OSLib-5_92:4.6
	RISC_OSLib-5_91:4.6
	RISC_OSLib-5_90:4.6
	RISC_OSLib-5_89:4.6
	RISC_OSLib-5_88:4.6
	RISC_OSLib-5_87:4.6
	RISC_OSLib-5_86-1:4.6
	RISC_OSLib-5_86:4.6
	RISC_OSLib-5_85:4.6
	RISC_OSLib-5_84:4.6
	RISC_OSLib-5_83-2:4.6
	RISC_OSLib-5_83-1:4.6
	RISC_OSLib-5_83:4.6
	RISC_OSLib-5_82:4.6
	RISC_OSLib-5_81:4.6
	RISC_OSLib-5_75-2:4.6
	RISC_OSLib-5_80:4.6
	RISC_OSLib-5_79:4.6
	RISC_OSLib-5_78:4.6
	RISC_OSLib-5_75-1:4.6
	RISC_OSLib-5_77:4.6
	RISC_OSLib-5_76:4.6
	RISC_OSLib-5_75:4.6
	RISC_OSLib-5_74:4.6
	RISC_OSLib-5_73:4.6
	RISC_OSLib-5_72:4.6
	RISC_OSLib-5_71:4.6
	RISC_OSLib-5_70:4.6
	RISC_OSLib-5_69:4.6
	RISC_OSLib-5_68:4.6
	RISC_OSLib-5_67:4.5
	RISC_OSLib-5_66:4.5
	RISC_OSLib-5_65:4.5
	RISC_OSLib-5_64:4.5
	RISC_OSLib-5_63:4.4
	RISC_OSLib-5_62:4.4
	RISC_OSLib-5_61:4.4
	RISC_OSLib-5_60:4.4
	RISC_OSLib-5_59:4.4
	RISC_OSLib-5_58:4.4
	RISC_OSLib-5_57:4.4
	RISC_OSLib-5_56:4.4
	RISC_OSLib-5_55:4.4
	RISC_OSLib-5_54:4.4
	RISC_OSLib-5_53:4.4
	RISC_OSLib-5_52:4.4
	RISC_OSLib-5_51:4.4
	RO_5_07:4.4
	RISC_OSLib-5_50:4.4
	RISC_OSLib-5_49:4.4
	RISC_OSLib-5_46-4_64_2_1:4.4
	NoInlineAsm:4.4.0.2
	RISC_OSLib-5_48:4.4
	RISC_OSLib-5_47:4.4
	RISC_OSLib-5_46:4.4
	RISC_OSLib-5_45:4.4
	RISC_OSLib-5_44:4.4
	RISC_OSLib-5_43:4.4
	RISC_OSLib-5_42:4.4
	RISC_OSLib-5_41:4.4
	RISC_OSLib-5_40:4.3
	RISC_OSLib-5_39:4.3
	RISC_OSLib-5_38:4.3
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.2
	RISC_OSLib-5_35:4.2
	RISC_OSLib-5_34:4.2
	RISC_OSLib-5_33-4_50_2_1:4.2
	sbrodie_dev:4.2.0.6
	sbrodie_dev_bp:4.2
	RISC_OSLib-5_33:4.2
	RISC_OSLib-5_32:4.2
	RISC_OSLib-5_31:4.2
	RISC_OSLib-5_30:4.2
	RISC_OSLib-5_29:4.2
	RISC_OSLib-5_28:4.2
	RISC_OSLib-5_27:4.2
	RISC_OSLib-5_26:4.2
	RISC_OSLib-5_25:4.2
	RISC_OSLib-5_24:4.2
	RISC_OSLib-5_01-4_16_2_5:4.2
	RISC_OSLib-5_23:4.2
	RISC_OSLib-5_22:4.2
	RISC_OSLib-5_21:4.2
	RISC_OSLib-5_20:4.2
	RISC_OSLib-5_19:4.2
	RISC_OSLib-5_18:4.2
	RISC_OSLib-5_17:4.2
	RISC_OSLib-5_16:4.2
	RISC_OSLib-5_15:4.2
	dellis_autobuild_BaseSW:4.2
	RISC_OSLib-5_14:4.2
	RISC_OSLib-5_13:4.2
	RISC_OSLib-5_12:4.2
	RISC_OSLib-5_01-4_16_2_4:4.2
	RISC_OSLib-5_11:4.2
	RISC_OSLib-5_01-4_16_2_3:4.2
	RISC_OSLib-5_01-4_16_2_2:4.2
	RISC_OSLib-5_10:4.2
	RISC_OSLib-5_01-4_16_2_1:4.2
	Bethany:4.2.0.4
	RISC_OSLib-5_09:4.2
	RISC_OSLib-5_08:4.2
	RISC_OSLib-5_07:4.2
	RISC_OSLib-5_06:4.2
	RISC_OSLib-4_97-4_12_2_8:4.2
	RISC_OSLib-5_05:4.2
	RISC_OSLib-5_04:4.2
	sbrodie_sedwards_16Mar2000:4.2
	RISC_OSLib-5_03:4.2
	RISC_OSLib-5_02:4.2
	RISC_OSLib-4_97-4_12_2_7:4.2
	RISC_OSLib-5_01:4.2
	RISC_OSLib-5_00:4.2
	RISC_OSLib-4_99:4.2
	RISC_OSLib-4_98:4.2
	RISC_OSLib-4_97-4_12_2_6:4.2
	RISC_OSLib-4_97-4_12_2_5:4.2
	RISC_OSLib-4_97-4_12_2_4:4.2
	RISC_OSLib-4_97-4_12_2_3:4.2
	RISC_OSLib-4_97-4_12_2_2:4.2
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.2
	kbracey_32bit:4.2.0.2
	kbracey_32bit_bp:4.2
	dcotton_autobuild_BaseSW:4.2
	RISC_OSLib-4_97:4.2
	RISC_OSLib-4_96:4.2
	RISC_OSLib-4_95:4.2
	RISC_OSLib-4_94:4.2
	RISC_OSLib-4_93:4.2
	RISC_OSLib-4_92:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.2
	RISC_OSLib-4_90:4.2
	RISC_OSLib-4_89:4.2
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2012.05.28.18.04.03;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	psVvzYlFFIpQ9w6w;

4.5
date	2011.10.28.14.23.17;	author bavison;	state Exp;
branches;
next	4.4;
commitid	hIG6j26y6NoxM7Fv;

4.4
date	2002.05.22.10.45.24;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2002.03.26.16.17.26;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.10.01.09.14.14;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.48;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.48;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.46;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.07;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.30;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Add locale support for selecting timezones from C
armsys.c
  Ammended time() to match ISO9899 and just return UTC like it says.
  Inlined the single use of _bbctime() macro.
locale.c
  The timezone within a territory can now be specified as part of the setlocale() function.
  This uses a qualifier to the already accepted territory name, for an example see test/tzones.c
  Shock addition of some comments to the locale parsing function.
  To avoid needing to mess about with C library workspace the timezone and territory are encoded internally into 1 word, with 10 bits allowing up to 1024 territories worldwide.
  Ripple through to strftime().
time.c
  localtime() updated to respect locale selection.
test/file,gen_inputs,test64
  Copyright headers added.

Output compared with Windows XP using setlocale versus tzset to shift the program into Pacific time.

Version 5.68. Tagged as 'RISC_OSLib-5_68'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* locale.c: ANSI draft (X3J11 Oct 86) library header, section 4.3 */
/* Copyright (C) Codemist Ltd., 1988 */
/* version 0.01 */

#include <locale.h>
#include <stddef.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>  /* multibyte characters & strings */
#include <limits.h>  /* for CHAR_MAX */

#include "hostsys.h"
#include "kernel.h"
#include "territory.h"
#include "swis.h"

/* #define LC_COLLATE  1
   #define LC_CTYPE    2
   #define LC_MONETARY 4
   #define LC_NUMERIC  8
   #define LC_TIME    16
   #define LC_ALL     31
*/

/* Array indices corresponding to the LC macros above */
#define N_LC_COLLATE  0
#define N_LC_CTYPE    1
#define N_LC_MONETARY 2
#define N_LC_NUMERIC  3
#define N_LC_TIME     4
#define N_LC_MAX      5

extern int _sprintf_lf(char *buff, const char *fmt, ...);

extern int __locales[N_LC_MAX];
int __locales[N_LC_MAX] = {0, 0, 0, 0, 0};

/* lc initialised to C for default */
static struct lconv lc =
{".", "", "", "", "", "", "", "", "", "",
 CHAR_MAX,CHAR_MAX,CHAR_MAX,CHAR_MAX,CHAR_MAX,CHAR_MAX,CHAR_MAX,CHAR_MAX};

/* Tables used by strftime()                                             */

static char *abbrweek[]  = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
static char *fullweek[]  = { "Sunday", "Monday", "Tuesday", "Wednesday",
                             "Thursday", "Friday", "Saturday" };
static char *abbrmonth[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                             "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
static char *fullmonth[] = { "January", "February", "March", "April",
                             "May", "June", "July", "August",
                             "September", "October", "November", "December" };
static char *ampmname[]  = { "AM", "PM" };

extern void _set_ctype(int territory);

extern void _set_strcoll(int territory);

static void setlocales(int category, int *values)
{
    int j;

    for (j = 0; category != 0; category >>= 1, ++j) {
      if (category & 1) __locales[j] = values[j];
    }
}

static int getsymbol(int territory, int idx, int def)
{
  _kernel_swi_regs r;

  if (!territory)
    return def;
  r.r[0] = territory;
  r.r[1] = idx;
  if (!_kernel_swi(Territory_ReadSymbols, &r, &r))
    return r.r[0];
  return def;
}

static void _set_numeric(int territory)
{
    decimal_point = (char *)getsymbol(territory, 0, (int)".");
}

static void setlconv(int category, int *values)
{
  int territory;

  if (category & LC_MONETARY) {
    territory = values[N_LC_MONETARY];
    lc.int_curr_symbol =
        (char *)getsymbol(territory, TERRITORY_INT_CURR_SYMBOL, (int)"");
    lc.currency_symbol =
        (char *)getsymbol(territory, TERRITORY_CURRENCY_SYMBOL, (int)"");
    lc.mon_decimal_point =
        (char *)getsymbol(territory, TERRITORY_MON_DECIMAL_POINT, (int)"");
    lc.mon_thousands_sep =
        (char *)getsymbol(territory, TERRITORY_MON_THOUSANDS_SEP, (int)"");
    lc.mon_grouping =
        (char *)getsymbol(territory, TERRITORY_MON_GROUPING, (int)"");
    lc.positive_sign =
        (char *)getsymbol(territory, TERRITORY_POSITIVE_SIGN, (int)"");
    lc.negative_sign =
        (char *)getsymbol(territory, TERRITORY_NEGATIVE_SIGN, (int)"");
    lc.int_frac_digits =
        getsymbol(territory, TERRITORY_INT_FRAC_DIGITS, CHAR_MAX);
    lc.frac_digits =
        getsymbol(territory, TERRITORY_FRAC_DIGITS, CHAR_MAX);
    lc.p_cs_precedes =
        getsymbol(territory, TERRITORY_P_CS_PRECEDES, CHAR_MAX);
    lc.p_sep_by_space =
        getsymbol(territory, TERRITORY_P_SEP_BY_SPACE, CHAR_MAX);
    lc.n_cs_precedes =
        getsymbol(territory, TERRITORY_N_CS_PRECEDES, CHAR_MAX);
    lc.n_sep_by_space =
        getsymbol(territory, TERRITORY_N_SEP_BY_SPACE, CHAR_MAX);
    lc.p_sign_posn =
        getsymbol(territory, TERRITORY_P_SIGN_POSN, CHAR_MAX);
    lc.n_sign_posn =
        getsymbol(territory, TERRITORY_N_SIGN_POSN, CHAR_MAX);
  }
  if (category & LC_NUMERIC) {
    territory = values[N_LC_NUMERIC];
    lc.decimal_point =
        (char *)getsymbol(territory, TERRITORY_DECIMAL_POINT, (int)".");
    lc.thousands_sep =
        (char *)getsymbol(territory, TERRITORY_THOUSANDS_SEP, (int)"");
    lc.grouping =
        (char *)getsymbol(territory, TERRITORY_GROUPING, (int)"");
  }
}

#define LC_STR_SIZE 40

char *setlocale(int category, const char *locale)
{
    static char lc_str[LC_STR_SIZE];
    int tmp_locales[N_LC_MAX] = {0, 0, 0, 0, 0};
    _kernel_swi_regs r;
    char *s;
    int i, n, tz;

    /* I expect the category to be a bit-map - complain if out of range  */
    if (((unsigned)category > LC_ALL) || (category == 0))
      /* no can do... */
      return NULL;
    if (locale == NULL) {
      /* get locale */
      _sprintf_lf(lc_str, "=%d,%d,%d,%d,%d",
                  __locales[0], __locales[1], __locales[2], __locales[3], __locales[4]);
      return lc_str;
    } else {
      /* set locale */
      if (strcmp(locale, "ISO8859-1") == 0)
        locale = "UK";
      if (*locale == '=') {
        /* ISO9899 7.11.1.1 Parse the string as given by get locale */
        s = (char *)(locale + 1);
        for (i = 0; i < N_LC_MAX; i++) {
            n = 0;
            while (*s >= '0' && *s <= '9') {
                n = n * 10 + *s - '0';
                s++;
            }
            if (*s == ',') s++;
            tmp_locales[i] = n;
        }
      } else {
        if (*locale == 0 || strcmp(locale, "C") == 0) {
          /* ISO9899 7.11.1.1 Use "" for current locale, "C" for minimal locale */
          n = 0; tz = 0;
          if (!*locale && (_kernel_swi(Territory_Number, &r, &r) == NULL)) {
            n = r.r[0];
            r.r[1] = (int)lc_str;
            r.r[2] = LC_STR_SIZE;
            if (_kernel_swi(Territory_NumberToName, &r, &r) == NULL)
              locale = lc_str;
          }
        } else {
          /* Platform specific, permit the territory name and (optional) standard timezone */
          strncpy(lc_str, locale, LC_STR_SIZE - 1);
          s = strchr(lc_str, '/'); /* eg. "USA/PST" */
          if (s != NULL) *s = 0;
          r.r[0] = TERRITORY_UK;   /* Names must be in english */
          r.r[1] = (int)lc_str;
          if ((_kernel_swi(Territory_NameToNumber, &r, &r) != NULL) || (r.r[0] == 0))
            return NULL;           /* Don't know that name */
          n = r.r[0]; tz = 0;
          if (_kernel_swi(Territory_WriteDirection, &r, &r) != NULL)
            return NULL;           /* Check it's loaded (avoids Territory_Exists Z flag faff) */
          if (s != NULL) {
            locale = lc_str;       /* eg. "USA" */
            s++;                   /* eg. "PST" */
            if (*s) {              /* Null timezone taken as 0th */
              while (1) {
                r.r[0] = n;
                r.r[1] = tz;
                r.r[4] = (int)TERRITORY_TZ_API_EXT;
                if (_kernel_swi(Territory_ReadTimeZones, &r, &r) != NULL)
                  return NULL;     /* No more timezones to match */
                if (strcmp((char *)r.r[0], s) == 0)
                  break;           /* Exact match */
                if (r.r[4])
                  break;           /* Extended API not supported, use 0th */
                tz++;
              }
            }
          }
        }
        for (i = 0; i < N_LC_MAX; i++) {
          if (i == N_LC_TIME)
            tmp_locales[i] = TERRITORY_ENCODE(n, tz); /* Packed format */
          else
            tmp_locales[i] = n;
        }
      }
      setlocales(category, tmp_locales);
      setlconv(category, tmp_locales);
      if (category & LC_CTYPE)
        _set_ctype(tmp_locales[N_LC_CTYPE]);
      if (category & LC_COLLATE)
        _set_strcoll(tmp_locales[N_LC_COLLATE]);
      if (category & LC_NUMERIC)
        _set_numeric(tmp_locales[N_LC_NUMERIC]);
    }
    return (char *)locale;
}

struct lconv *localeconv(void)
{
  return &lc;
}

static int findweek(int yday, int startday, int today)
{
    int days_into_this_week = today - startday;
    int last_weekstart;
    if (days_into_this_week < 0) days_into_this_week += 7;
    last_weekstart = yday - days_into_this_week;
    if (last_weekstart <= 0) return 0;
    return last_weekstart/7 + 1;
}

#define CDT_BUFFSIZE 256

static char *getterritorytimeinfo(int territory, const struct tm *tt, char *fmt, char *buff, int swi)
{
    _kernel_swi_regs r;
    int  tm_block[7];
    long long utc_block;

    /* The tm struct came from either gmtime() or localtime() and therefore already     */
    /* has any timezone and daylight saving applied to it as implied by the choice of   */
    /* the 2 functions called. Therefore it needs converting as though it's UTC         */
    /* already. Note that Territory_ConvertOrdinalsToTime applies its own correction    */
    /* based on the active territory (not necessarily the same as the locale set for    */
    /* our client) and since there isn't a UTC equivalent of that SWI until             */
    /* Territory_ConvertTimeFormats comes along (which might not be available on the    */
    /* host OS) we must do the opposite correction to the calculated time. Sigh.        */
    tm_block[0] = 0;
    tm_block[1] = tt->tm_sec;
    tm_block[2] = tt->tm_min;
    tm_block[3] = tt->tm_hour;
    tm_block[4] = tt->tm_mday;
    tm_block[5] = tt->tm_mon + 1;
    tm_block[6] = tt->tm_year + 1900;
    r.r[0] = TERRITORY_UK;
    r.r[1] = (int)&utc_block;
    r.r[2] = (int)tm_block;
    if (_kernel_swi(Territory_ConvertOrdinalsToTime, &r, &r) != NULL)
        return "???";
    if (_kernel_swi(Territory_ReadCurrentTimeZone, &r, &r) != NULL)
        return "???";
    utc_block = utc_block + r.r[1];

    r.r[0] = TERRITORY_EXTRACT(territory);
    r.r[1] = (int)&utc_block;
    r.r[2] = (int)buff;
    r.r[3] = CDT_BUFFSIZE | (1<<30) | (1<<31); /* No DST, R5 cs offset */
    r.r[4] = (int)fmt;
    r.r[5] = 0;
    if (_kernel_swi(swi, &r, &r) != NULL)
        return "???";
    return buff;
}

static char *gettimeinfo(int territory, const struct tm *tt, char *fmt, char *buff)
{
    return getterritorytimeinfo(territory, tt, fmt, buff, Territory_ConvertDateAndTime);
}

static char *gettimedate(int territory, const struct tm *tt, char *buff, int swi)
{
    return getterritorytimeinfo(territory, tt, NULL, buff, swi);
}

static char *gettimezone(int territory, const struct tm *tt, char *buff, int numeric)
{
    _kernel_swi_regs r;

    if (tt->tm_isdst < 0)
        return ""; /* Undetermined */
    r.r[0] = TERRITORY_EXTRACT(territory);
    r.r[1] = TERRITORY_TZ_EXTRACT(territory);
    r.r[4] = (int)TERRITORY_TZ_API_EXT;
    if (_kernel_swi(Territory_ReadTimeZones, &r, &r) != NULL)
        return ""; /* Undetermined */
    if (numeric)
    {
        int offset = tt->tm_isdst ? r.r[3] : r.r[2];

        if (offset < 0)
            offset = -offset, buff[0] = '-';
        else
            buff[0] = '+';
        offset = (offset + 3000) / 6000; /* centiseconds -> minutes */
        sprintf(buff+1, "%.2d%.2d", offset / 60, offset % 60);
    }
    else
    {
        strcpy(buff, tt->tm_isdst ? (char *)r.r[1] : (char *)r.r[0]);
    }
    return buff;
}

static int getdaysinyear(int year)
{
    if (year % 4 != 0) return 365;
    if (year % 100 != 0) return 366;
    if (year % 400 != 0) return 365;
    return 366;
}

static void getiso8601week(char *buff, int spec, int year, int wday, int yday)
{
    int start_of_week, week;
    if (--wday < 0) wday += 7; /* convert from Sun = 0 to Mon = 0 */

    start_of_week = yday - wday; /* day number (-6 to 365) of start of this week */
    do
    {
        week = (start_of_week+7+3) / 7; /* basic week number (0-53) */
        if (week == 0)
        {
            /* This week belongs to last year - go round again */
            start_of_week += getdaysinyear(--year);
        }
        else if (week == 53 && start_of_week >= getdaysinyear(year)-3)
        {
            /* <=3 days of week 53 fall in this year, so we treat it as week 1 of next year */
            week = 1;
            ++year;
        }
    }
    while (week == 0);

    switch (spec)
    {
        case 'g': sprintf(buff, "%.2d", year % 100); break;
        case 'G': sprintf(buff, "%d", year); break;
        case 'V': sprintf(buff, "%.2d", week); break;
    }
}

size_t strftime(char *s, size_t maxsize, const char *fmt, const struct tm *tt)
{
    int p = 0, c;
    char *ss, buff[CDT_BUFFSIZE];
    int territory;

    if (maxsize==0) return 0;
    territory = __locales[N_LC_TIME];
#define push(ch) { s[p++]=(ch); if (p>=maxsize) return 0; }
    for (;;)
    {   switch (c = *fmt++)
        {
    case 0: s[p] = 0;
            return p;
    default:
            push(c);
            continue;
    case '%':
            ss = buff;
            c = *fmt++;
            if (c == 'E' || c == 'O') /* Ignore C99 modifiers */
                c = *fmt++;
            switch (c)
            {
        default:            /* Unknown directive - leave uninterpreted   */
                push('%');  /* NB undefined behaviour according to ANSI  */
                fmt--;
                continue;
        case 'a':
                if (territory)
                    ss = gettimeinfo(territory, tt, "%W3", buff);
                else
                    ss = abbrweek[tt->tm_wday];
                break;
        case 'A':
                if (territory)
                    ss = gettimeinfo(territory, tt, "%WE", buff);
                else
                    ss = fullweek[tt->tm_wday];
                break;
        case 'b': case 'h':
                if (territory)
                    ss = gettimeinfo(territory, tt, "%M3", buff);
                else
                    ss = abbrmonth[tt->tm_mon];
                break;
        case 'B':
                if (territory)
                    ss = gettimeinfo(territory, tt, "%MO", buff);
                else
                    ss = fullmonth[tt->tm_mon];
                break;
        case 'c':
                if (territory)
                    ss = gettimedate(territory, tt, ss, Territory_ConvertStandardDateAndTime);
                else
                    /* Format for "C" locale changed as per C99 "%a %b %e %T %Y" */
                    sprintf(ss, "%s %s %2d %.2d:%.2d:%.2d %d",
                                tt->tm_wday < 7U ? abbrweek[tt->tm_wday] : "???",
                                abbrmonth[tt->tm_mon], tt->tm_mday,
                                tt->tm_hour, tt->tm_min, tt->tm_sec, tt->tm_year + 1900);
                break;
        case 'C':
                sprintf(ss, "%.2d", (tt->tm_year + 1900) / 100);
                break;
        case 'd':
                sprintf(ss, "%.2d", tt->tm_mday);
                break;
        case 'D':
                sprintf(ss, "%.2d/%.2d/%.2d", tt->tm_mon + 1, tt->tm_mday, tt->tm_year % 100);
                break;
        case 'e':
                sprintf(ss, "%2d", tt->tm_mday);
                break;
        case 'F':
                sprintf(ss, "%d-%.2d-%2.d", tt->tm_year + 1900, tt->tm_mon + 1, tt->tm_mday);
                break;
        case 'g': case 'G': case 'V':
                getiso8601week(ss, c, tt->tm_year + 1900, tt->tm_wday, tt->tm_yday);
                break;
        case 'H':
                sprintf(ss, "%.2d", tt->tm_hour);
                break;
        case 'I':
                sprintf(ss, "%.2d", (tt->tm_hour + 11)%12 + 1);
                break;
        case 'j':
                sprintf(ss, "%.3d", tt->tm_yday + 1);
                break;
        case 'm':
                sprintf(ss, "%.2d", tt->tm_mon + 1);
                break;
        case 'M':
                sprintf(ss, "%.2d", tt->tm_min);
                break;
        case 'n':
                strcpy(ss, "\n");
                break;
        case 'p':
/* I am worried here re 12.00 AM/PM and times near same.                 */
                if (territory)
                    ss = gettimeinfo(territory, tt, "%AM", buff);
                else
                    ss = ampmname[tt->tm_hour >= 12];
                break;
        case 'r':
                if (territory)
                    ss = gettimeinfo(territory, tt, "%12:%MI:%SE %AM", buff);
                else
                    sprintf(ss, "%.2d:%.2d:%.2d %s",
                            (tt->tm_hour + 11) % 12 + 1, tt->tm_min, tt->tm_sec,
                            ampmname[tt->tm_hour >= 12]);
                break;
        case 'R':
                sprintf(ss, "%.2d:%.2d", tt->tm_hour, tt->tm_min);
                break;
        case 'S':
                sprintf(ss, "%.2d", tt->tm_sec);
                break;
        case 't':
                strcpy(ss, "\t");
                break;
        case 'T':
                sprintf(ss, "%.2d:%.2d:%.2d", tt->tm_hour, tt->tm_min, tt->tm_sec);
                break;
        case 'u':
                sprintf(ss, "%.1d", (tt->tm_wday + 6)%7 + 1);
                break;
        case 'U':
                sprintf(ss, "%.2d", findweek(tt->tm_yday, 0, tt->tm_wday));
                break;
        case 'w':
                sprintf(ss, "%.1d", tt->tm_wday);
                break;
        case 'W':
                sprintf(ss, "%.2d", findweek(tt->tm_yday, 1, tt->tm_wday));
                break;
        case 'x':
                if (territory)
                    ss = gettimedate(territory, tt, ss, Territory_ConvertStandardDate);
                else
                    /* Format for "C" locale changed as per C99 */
                    sprintf(ss, "%.2d/%.2d/%.2d",
                            tt->tm_mon + 1, tt->tm_mday, tt->tm_year % 100);
                break;
        case 'X':
                if (territory)
                    ss = gettimedate(territory, tt, ss, Territory_ConvertStandardTime);
                else
                    sprintf(ss, "%.2d:%.2d:%.2d",
                            tt->tm_hour, tt->tm_min, tt->tm_sec);
                break;
        case 'y':
                sprintf(ss, "%.2d", tt->tm_year % 100);
                break;
        case 'Y':
                sprintf(ss, "%d", tt->tm_year + 1900);
                break;
        case 'z': case 'Z':
                if (territory)
                    ss = gettimezone(territory, tt, buff, c == 'z');
                else
                    ss = "";
                break;
        case '%':
                push('%');
                continue;
            }
            while ((c = *ss++) != 0) push(c);
            continue;
        }
#undef push
    }
}

#define STATE_DEPENDENT_ENCODINGS 0

int mblen(const char *s, size_t n)
{   if (s == 0) return STATE_DEPENDENT_ENCODINGS;
/* @@@@@@ ANSI ambiguity: if n=0 and *s=0 then return 0 or -1?                 */
/* @@@@@@ LDS: for consistency with mbtowc, return -1                          */
    if (n == 0) return -1;
    if (*s == 0) return 0;
    return 1;
}

int mbtowc(wchar_t *pwc, const char *s, size_t n)
{   if (s == 0) return STATE_DEPENDENT_ENCODINGS;
/* @@@@@@ ANSI ambiguity: if n=0 and *s=0 then return 0 or -1?                 */
/* @@@@@@ LDS At most n chars of s are examined, ergo must return -1.          */
    if (n == 0) return -1;
    else
    {   wchar_t wc = *(unsigned char *)s;
        if (pwc) *pwc = wc;
        return (wc != 0);
    }
}

int wctomb(char *s, wchar_t w)
{   if (s == 0) return STATE_DEPENDENT_ENCODINGS;
/* @@@@@@ ANSI ambiguity: what return (and setting for s) if w == 0?           */
/* @@@@@@ LDS The CVS suggests return #chars stored; I agree this is rational. */
    if ((unsigned)w > (unsigned char)-1) return -1;
    *s = w;
    return 1;
}

size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n)
{
/* @@@@@@ ANSI ambiguity: if n=0 then is *s read?                              */
    size_t r = 0;
    for (; n != 0; n--)
    {   if ((pwcs[r] = ((unsigned char *)s)[r]) == 0) return r;
        r++;
    }
    return r;
}

size_t wcstombs(char *s, const wchar_t *pwcs, size_t n)
{
/* @@@@@@ ANSI ambiguity: if n=0 then is *pwcs read?  Also invalidity check?   */
    size_t r = 0;
    for (; n != 0; n--)
    {   wchar_t w = pwcs[r];
        if ((unsigned)w > (unsigned char)-1) return (size_t)-1;
        if ((s[r] = w) == 0) return r;
        r++;
    }
    return r;
}

/* end of locale.c */
@


4.5
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@d47 1
a47 1
#define N_LC_ALL      5
d51 2
a52 2
extern int __locales[5];
int __locales[5] = {0, 0, 0, 0, 0};
d155 1
a155 1
    int tmp_locales[5] = {0, 0, 0, 0, 0};
d158 1
a158 1
    int i, n;
d164 1
a164 1
    if (locale == 0) {
d174 1
d176 1
a176 1
        for (i = 0; i < 5; i++) {
d187 3
a189 2
          n = 0;
          if (!*locale && !_kernel_swi(Territory_Number, &r, &r)) {
d193 1
a193 1
            if (!_kernel_swi(Territory_NumberToName, &r, &r))
d197 35
a231 5
          r.r[0] = TERRITORY_UK;
          r.r[1] = (int)locale;
          if (_kernel_swi(Territory_NameToNumber, &r, &r) || r.r[0] == 0)
            return NULL;
          n = r.r[0];
a232 2
        for (i = 0; i < 5; i++)
          tmp_locales[i] = n;
d266 2
a267 2
    int tm_block[7];
    char utc_block[5];
d269 8
d285 1
a285 1
    r.r[1] = (int)utc_block;
d287 3
a289 1
    if (_kernel_swi(Territory_ConvertOrdinalsToTime, &r, &r))
d291 4
a294 2
    r.r[0] = territory;
    r.r[1] = (int)utc_block;
d296 1
a296 1
    r.r[3] = CDT_BUFFSIZE;
d298 2
a299 1
    if (_kernel_swi(swi, &r, &r))
d311 1
a311 1
    return getterritorytimeinfo(territory, tt, "", buff, swi);
d314 1
a314 1
static char *gettimezone(int territory, char *buff)
d317 19
a335 10
    int dst, offset;
    r.r[0] = 161;
    dst = _kernel_osbyte(161, 220, 0);
    if (dst < 0) return "";
    r.r[0] = territory;
    if (_kernel_swi(Territory_ReadTimeZones, &r, &r))
        return "";
    offset = dst & 0x8000 ? r.r[3] : r.r[2];
    if (offset < 0)
       offset = -offset, buff[0] = '-';
d337 3
a339 3
       buff[0] = '+';
    offset = (offset + 3000) / 6000; /* centiseconds -> minutes */
    sprintf(buff+1, "%.2d%.2d", offset / 60, offset % 60);
d343 1
a343 1
static int daysinyear(int year)
d363 1
a363 1
            start_of_week += daysinyear(--year);
d365 1
a365 1
        else if (week == 53 && start_of_week >= daysinyear(year)-3)
a410 1
                ss = abbrweek[tt->tm_wday];
d413 2
a416 1
                ss = fullweek[tt->tm_wday];
d419 2
a422 1
                ss = abbrmonth[tt->tm_mon];
d425 2
a428 1
                ss = fullmonth[tt->tm_mon];
d431 2
d435 4
a438 2
                /* Format for "C" locale changed as per C99 */
                if (!territory)
a442 5
                    /*sprintf(ss, "%02d %s %d %02d:%02d:%02d",
                        tt->tm_mday, abbrmonth[tt->tm_mon], tt->tm_year + 1900,
                        tt->tm_hour, tt->tm_min, tt->tm_sec);*/
                else
                    ss = gettimedate(territory, tt, ss, Territory_ConvertStandardDateAndTime);
a481 1
                ss = ampmname[tt->tm_hour >= 12];
d484 2
d488 3
a490 1
                if (!territory)
a493 2
                else
                    ss = gettimeinfo(territory, tt, "%12:%MI:%SE %AM", buff);
d520 2
a521 6
/* The next two had better agree with %c conversions                     */
                /* Format for "C" locale changed as per C99 */
                if (!territory)
                    /*sprintf(ss, "%02d %s %d",
                            tt->tm_mday, abbrmonth[tt->tm_mon], tt->tm_year + 1900);*/
                    sprintf(ss, "%.2d/%.2d/%.2d", tt->tm_mon + 1, tt->tm_mday, tt->tm_year % 100);
d523 3
a525 1
                    ss = gettimedate(territory, tt, ss, Territory_ConvertStandardDate);
d528 3
a530 1
                if (!territory)
a532 2
                else
                    ss = gettimedate(territory, tt, ss, Territory_ConvertStandardTime);
d540 1
a540 2
        case 'z':
                ss = "";
d542 3
a544 7
                    ss = gettimezone(territory, buff);
                break;
        case 'Z':
                /* No timezone exists here */
                ss = "";
                if (territory)
                    ss = gettimeinfo(territory, tt, "%TZ", buff);
@


4.4
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@d51 1
@


4.3
log
@* Added C99 extensions to strftime(). All basic specifiers supported, but "E"
  and "O" modifiers ignored.
* strftime specifiers %c, %X and %x for "C" locale changed to match C99.
* Optimised hypot[f].
* Missing hypotf() declaration added to <math.h>.
* Fixed Shared C Library - inadvertent change to static data size meant it was
  incompatible with the stubs.

Version 5.38. Tagged as 'RISC_OSLib-5_38'
@
text
@d381 2
a382 1
                                abbrweek[tt->tm_wday], abbrmonth[tt->tm_mon], tt->tm_mday,
@


4.2
log
@Ursula branch merged.
StrongARMfudge flag removed.
StrongARM compatibility set according to AMBKernel flag in Hdr:RISCOS
strftime %U and %W specifiers fixed for week 0.

Version 4.89. Tagged as 'RISC_OSLib-4_89'
@
text
@d270 59
d348 4
a351 1
            switch (c = *fmt++)
d367 1
a367 1
        case 'b':
d378 1
a378 1
/* Is this the locale-specific date & time format we want?               */
d380 4
a383 1
                    sprintf(ss, "%02d %s %d %02d:%02d:%02d",
d385 1
a385 1
                        tt->tm_hour, tt->tm_min, tt->tm_sec);
d389 3
d395 12
d422 3
d431 11
d445 9
d465 1
d467 3
a469 2
                    sprintf(ss, "%02d %s %d",
                            tt->tm_mday, abbrmonth[tt->tm_mon], tt->tm_year + 1900);
d475 1
a475 1
                    sprintf(ss, "%02d:%02d:%02d",
d485 5
@


4.1
log
@Initial revision
@
text
@d226 1
a226 1
    if (last_weekstart <= 0) return 1;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.10;
access;
symbols
	RISC_OSLib-5_97:4.10
	RISC_OSLib-5_96:4.10
	RISC_OSLib-5_95:4.10
	RISC_OSLib-5_94:4.10
	RISC_OSLib-5_93:4.10
	RISC_OSLib-5_92:4.10
	RISC_OSLib-5_91:4.10
	RISC_OSLib-5_90:4.10
	RISC_OSLib-5_89:4.10
	RISC_OSLib-5_88:4.10
	RISC_OSLib-5_87:4.10
	RISC_OSLib-5_86-1:4.10
	RISC_OSLib-5_86:4.10
	RISC_OSLib-5_85:4.10
	RISC_OSLib-5_84:4.10
	RISC_OSLib-5_83-2:4.10
	RISC_OSLib-5_83-1:4.10
	RISC_OSLib-5_83:4.10
	RISC_OSLib-5_82:4.10
	RISC_OSLib-5_81:4.10
	RISC_OSLib-5_75-2:4.10
	RISC_OSLib-5_80:4.10
	RISC_OSLib-5_79:4.10
	RISC_OSLib-5_78:4.10
	RISC_OSLib-5_75-1:4.10
	RISC_OSLib-5_77:4.10
	RISC_OSLib-5_76:4.10
	RISC_OSLib-5_75:4.10
	RISC_OSLib-5_74:4.10
	RISC_OSLib-5_73:4.10
	RISC_OSLib-5_72:4.10
	RISC_OSLib-5_71:4.10
	RISC_OSLib-5_70:4.10
	RISC_OSLib-5_69:4.10
	RISC_OSLib-5_68:4.10
	RISC_OSLib-5_67:4.10
	RISC_OSLib-5_66:4.10
	RISC_OSLib-5_65:4.10
	RISC_OSLib-5_64:4.10
	RISC_OSLib-5_63:4.9
	RISC_OSLib-5_62:4.9
	RISC_OSLib-5_61:4.9
	RISC_OSLib-5_60:4.9
	RISC_OSLib-5_59:4.9
	RISC_OSLib-5_58:4.9
	RISC_OSLib-5_57:4.9
	RISC_OSLib-5_56:4.9
	RISC_OSLib-5_55:4.9
	RISC_OSLib-5_54:4.9
	RISC_OSLib-5_53:4.9
	RISC_OSLib-5_52:4.9
	RISC_OSLib-5_51:4.9
	RO_5_07:4.9
	RISC_OSLib-5_50:4.9
	RISC_OSLib-5_49:4.9
	RISC_OSLib-5_46-4_64_2_1:4.9
	NoInlineAsm:4.9.0.2
	RISC_OSLib-5_48:4.9
	RISC_OSLib-5_47:4.9
	RISC_OSLib-5_46:4.9
	RISC_OSLib-5_45:4.8
	RISC_OSLib-5_44:4.8
	RISC_OSLib-5_43:4.8
	RISC_OSLib-5_42:4.8
	RISC_OSLib-5_41:4.8
	RISC_OSLib-5_40:4.8
	RISC_OSLib-5_39:4.8
	RISC_OSLib-5_38:4.8
	RISC_OSLib-5_37:4.8
	RISC_OSLib-5_36:4.8
	RISC_OSLib-5_35:4.8
	RISC_OSLib-5_34:4.8
	RISC_OSLib-5_33-4_50_2_1:4.8
	sbrodie_dev:4.8.0.2
	sbrodie_dev_bp:4.8
	RISC_OSLib-5_33:4.8
	RISC_OSLib-5_32:4.7
	RISC_OSLib-5_31:4.6
	RISC_OSLib-5_30:4.5
	RISC_OSLib-5_29:4.5
	RISC_OSLib-5_28:4.4
	RISC_OSLib-5_27:4.4
	RISC_OSLib-5_26:4.4
	RISC_OSLib-5_25:4.4
	RISC_OSLib-5_24:4.4
	RISC_OSLib-5_01-4_16_2_5:4.3
	RISC_OSLib-5_23:4.4
	RISC_OSLib-5_22:4.4
	RISC_OSLib-5_21:4.4
	RISC_OSLib-5_20:4.4
	RISC_OSLib-5_19:4.4
	RISC_OSLib-5_18:4.4
	RISC_OSLib-5_17:4.4
	RISC_OSLib-5_16:4.4
	RISC_OSLib-5_15:4.4
	dellis_autobuild_BaseSW:4.3
	RISC_OSLib-5_14:4.3
	RISC_OSLib-5_13:4.3
	RISC_OSLib-5_12:4.3
	RISC_OSLib-5_01-4_16_2_4:4.3
	RISC_OSLib-5_11:4.3
	RISC_OSLib-5_01-4_16_2_3:4.3
	RISC_OSLib-5_01-4_16_2_2:4.3
	RISC_OSLib-5_10:4.3
	RISC_OSLib-5_01-4_16_2_1:4.3
	Bethany:4.3.0.4
	RISC_OSLib-5_09:4.3
	RISC_OSLib-5_08:4.3
	RISC_OSLib-5_07:4.3
	RISC_OSLib-5_06:4.3
	RISC_OSLib-4_97-4_12_2_8:4.3
	RISC_OSLib-5_05:4.3
	RISC_OSLib-5_04:4.3
	sbrodie_sedwards_16Mar2000:4.3
	RISC_OSLib-5_03:4.3
	RISC_OSLib-5_02:4.3
	RISC_OSLib-4_97-4_12_2_7:4.3
	RISC_OSLib-5_01:4.3
	RISC_OSLib-5_00:4.3
	RISC_OSLib-4_99:4.3
	RISC_OSLib-4_98:4.3
	RISC_OSLib-4_97-4_12_2_6:4.3
	RISC_OSLib-4_97-4_12_2_5:4.3
	RISC_OSLib-4_97-4_12_2_4:4.3
	RISC_OSLib-4_97-4_12_2_3:4.3
	RISC_OSLib-4_97-4_12_2_2:4.3
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.3
	kbracey_32bit:4.3.0.2
	kbracey_32bit_bp:4.3
	dcotton_autobuild_BaseSW:4.8
	RISC_OSLib-4_97:4.3
	RISC_OSLib-4_96:4.2
	RISC_OSLib-4_95:4.2
	RISC_OSLib-4_94:4.2
	RISC_OSLib-4_93:4.2
	RISC_OSLib-4_92:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.3
	Ursula_RiscPC:4.1.4.3.0.2
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.2
	RISC_OSLib-4_90:4.2
	RISC_OSLib-4_89:4.2
	Ursula_merge:4.1.4.3
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.3
	UrsulaBuild_FinalSoftload:4.1.4.3
	rthornb_UrsulaBuild-12Aug1998:4.1.4.3
	aglover_UrsulaBuild-05Aug1998:4.1.4.3
	rthornb_UrsulaBuild-29Jul1998:4.1.4.3
	rthornb_UrsulaBuild-22Jul1998:4.1.4.3
	rthornb_UrsulaBuild-15Jul1998:4.1.4.3
	rthornb_UrsulaBuild-07Jul1998:4.1.4.3
	rthornb_UrsulaBuild-17Jun1998:4.1.4.3
	rthornb_UrsulaBuild-03Jun1998:4.1.4.3
	rthornb_UrsulaBuild-27May1998:4.1.4.3
	rthornb_UrsulaBuild-21May1998:4.1.4.3
	rthornb_UrsulaBuild_01May1998:4.1.4.3
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2011.10.28.14.23.18;	author bavison;	state Exp;
branches;
next	4.9;
commitid	hIG6j26y6NoxM7Fv;

4.9
date	2003.04.15.16.50.23;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2001.05.10.09.26.10;	author sbrodie;	state Exp;
branches;
next	4.7;

4.7
date	2001.04.17.13.23.50;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2001.04.11.14.40.50;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2001.04.06.14.29.04;	author sbrodie;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.02.10.46.57;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	99.09.22.10.23.21;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.10.01.09.14.16;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.50;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.50;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.56;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.05.29.11.28.35;	author kbracey;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.03.26.12.14.35;	author kbracey;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.03.26.16.08.45;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.26;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.39;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* string.c: ANSI draft (X3J11 Oct 86) library code, section 4.11 */
/* Copyright (C) Codemist Ltd., 1988                              */
/* Copyright (C) Advanced Risc Machines Ltd., 1991                */
/* version 3a */

/* Also the routine 'strerror' is in 'perror.c' rather than here */

/* 19-nov-86:  If _copywords is #define'd then all cmp/cpy/set (but not cat)
   routines use word operations if operands lie on a word boundary.
   Enabling this assumes sizeof(int)=sizeof(void*)=4 and byte addressing.
   memset and strlen do even better.  Beware however, memcpy and memmove
   also require length to be a multiple of 4 (change?).  Further beware that
   memmove makes assumptions about memory layout.
*/

#include "hostsys.h"               /* for BYTESEX_EVEN/BYTESEX_ODD         */
#include <stddef.h>                /* for size_t                           */
#include <string.h>

#include "kernel.h"
#include "territory.h"
#include "swis.h"

#define _chararg int               /* arg spec for char when ANSI says int */
#define _copywords 1               /* do fast cpy/cmp if word aligned      */

/* private export */

extern void _set_strcoll(int territory);

/* The following magic check was designed by A. Mycroft. It yields a     */
/* nonzero value if the argument w has a zero byte in it somewhere. The  */
/* messy constants have been unfolded a bit in this code so that they    */
/* get preloaded into registers before relevant loops.                   */

#ifdef _copywords  /* for safety */
#  define ONES_WORD   0x01010101
#  define EIGHTS_WORD 0x80808080
#  define nullbyte_prologue_() \
      int ones_word = ONES_WORD; int eights_word = ones_word << 7
#  define word_has_nullbyte(w) (((w) - ones_word) & ~(w) & eights_word)
#endif

/* copying functions */

#ifndef SEPARATE_MEMCPY

void *memcpy(void *a, const void *b, size_t n)
/* copy memory (upwards) - it is an errof for args to overlap. */
/* Relies on sizeof(int)=sizeof(void *) and byte addressing.   */
{
#ifdef _copywords
    /* do it fast if word aligned ... */
    if ((((int)a | (int)b | (int)n) & 3) == 0)
    { int *wa,*wb;
      n >>= 2;
      for (wa = (int *)a, wb = (int *)b; n-- > 0;) *wa++ = *wb++;
    }
    else
#endif
    { char *ca,*cb;
      for (ca = (char *)a, cb = (char *)b; n-- > 0;) *ca++ = *cb++;
    }
    return a;
}

void *memmove(void *a, const void *b, size_t n)
/* copy memory taking care of overlap */
/* Relies on sizeof(int)=sizeof(void *) and byte addressing.
   Also that memory does not wrap round for direction test. */
{
#ifdef _copywords
    /* do it fast if word aligned ... */
    if ((((int)a | (int)b | (int)n) & 3) == 0)
    { int *wa,*wb;
      n >>= 2;
      if (a < (void *)b)
         for (wa = (int *)a, wb = (int *)b; n-- > 0;) *wa++ = *wb++;
      else for (wa = n+(int *)a, wb = n+(int *)b; n-- > 0;) *--wa = *--wb;
    }
    else
#endif
    { char *ca,*cb;
      if (a < (void *)b)
         for (ca = (char *)a, cb = (char *)b; n-- > 0;) *ca++ = *cb++;
      else for (ca = n+(char *)a, cb = n+(char *)b; n-- > 0;) *--ca = *--cb;
    }
    return a;
}

#endif

#ifdef PLUS_APRM
/* Arthur library contains a more efficient coding of this in clib.s.cl_body */
void *_memcpy(void *a, const void *b, size_t n)
/* Used by compiler for structure assignments */
{
#ifdef PLUS_APRM
    int *wa = (int *)a, *wb = (int *)b;
    if ((int)wb & 2) {
      /* get source word-aligned */
      *((short *)wa) = *((short *)wb);
      wa = (int *)((short *)wa + 1);  wb = (int *)((short *)wb + 1);  n-= 2;
    }
    while (n >= 4) {*wa++ = *wb++;  n -= 4;}
    if (n) *((short *)wa) = *((short *)wb);
#else
    /*
     * copy memory assuming no overlap, word aligned etc.
     * Relies on sizeof(int)=sizeof(void *) and byte addressing.
     */
    int *wa, *wb;
    n >>= 2;
    for (wa = (int *)a, wb = (int *)b; n-- > 0;) *wa++ = *wb++;
#endif
    return a;
}
#endif

char *strcpy(char *a, const char *b)                 /* copy from b to a */
{   char *p = a;
#ifdef _copywords
    if ((((int)p | (int)b) & 3) == 0)
    {   int w;
        nullbyte_prologue_();
        while (w = *(int *)b, b += 4, !word_has_nullbyte(w))
            *(int *)p = w, p += 4;
/* This next piece of code relies on knowledge of the order of bytes     */
/* within a word.                                                        */
#ifdef BYTESEX_EVEN
        for (;;)
        {   if ((*p++ = w) == 0) return a;
            w >>= 8;
        }
#else
        for (;;)
/* I rather assume that shifts are fast operations here.                 */
        {   if ((*p++ = (w >> 24)) == 0) return a;
            w <<= 8;
        }
#endif
    }
#endif
    while ((*p++ = *b++) != 0);
    return a;
}

char *strncpy(char *a, const char *b, size_t n)
            /* as strcpy, but at most n chars */
            /* NB may not be nul-terminated   */
{   char *p = a;
#ifdef _copywords
    if ((((int)p | (int)b) & 3) == 0)
    {   int w;
        nullbyte_prologue_();
        while (n >= 4 && (w = *(int *)b, !word_has_nullbyte(w)))
            *(int *)p = w, p += 4, b += 4, n -= 4;
    }
/* Although the above code has fetched the last part-filled word I will  */
/* copy the last few bytes by steam in this case. The test on n and the  */
/* need for padding seem to make anything else seem too messy.           */
#endif
    while (n-- > 0)
        if ((*p++ = *b++) == 0)
        {   char c = 0;
            while (n-- > 0) *p++ = c;   /* ANSI says pad out with nul's */
            return a;
        }
    return a;
}

/* concatenation functions */

char *strcat(char *a, const char *b)    /* concatenate b on the end of a */
{   char *p = a;
    while (*p != 0) p++;
    while ((*p++ = *b++) != 0);
    return a;
}

char *strncat(char *a, const char *b, size_t n)
                                       /* as strcat, but at most n chars */
{   char *p = a;
    while (*p != 0) p++;
    while (n-- > 0)
        if ((*p++ = *b++) == 0) return a;
    *p = 0;
    return a;
}

/* comparison functions */

int memcmp(const void *a, const void *b, size_t n)
{   const unsigned char *ac = (const unsigned char *)a,
                        *bc = (const unsigned char *)b;
#ifdef _copywords
    if ((((int)ac | (int)bc) & 3) == 0)
    {   while (n >= 4 && *(int *)ac == *(int *)bc)
            ac += 4, bc += 4, n -= 4;
    }
#endif
    while (n-- > 0)
    {   unsigned char c1 = *ac++, c2 = *bc++;   /* unsigned cmp seems more intuitive */
        int d = c1 - c2;
        if (d != 0) return d;
    }
    return 0;
}

int strcmp(const char *a, const char *b) /* lexical comparison on strings */
{
#ifdef _copywords
#ifdef BYTESEX_EVEN
/* Improved little-endian ARM strcmp code by Ian Rickards, ARM Ltd. */
/* sbrodie (06/04/01): unfortunately, it breaks strcmp() semantics required by the library definition */
    if ((((int)a | (int)b) & 3) == 0)
    {   int w1, w2, res, rc;
        nullbyte_prologue_();
        do {
            w1 = *(int *)a, a += 4;
            w2 = *(int *)b, b += 4;
            res = w1 - w2;
            if (res != 0) goto strcmp_checkbytes;

        } while (!word_has_nullbyte(w1));
        return 0;

strcmp_checkbytes:
#  ifdef WANT_ARMS_BROKEN_STRCMP_FOR_TOP_BIT_SET_CHARACTERS
/* carry propagation in subtract means that no subtract-per-byte is needed */
        rc = res << 24;
        if (rc != 0) return rc;
        if ((w1 & 0xff) == 0) return rc;

        rc = res << 16;
        if (rc != 0) return rc;
        if ((w1 & 0xff00) == 0) return rc;

        rc = res << 8;
        if (rc != 0) return rc;
        if ((w1 & 0xff0000) == 0) return rc;

        return res;
#  else  /* WANT_ARMS_BROKEN_STRCMP_FOR_TOP_BIT_SET_CHARACTERS */
        /* res is guaranteed non-zero, so rc will not be zero, therefore the loop
         * will find the bit eventually.  The shifting is done to ensure that if it
         * is the top-byte that contains the difference, we don't lose the sign bit
         * on the subtraction.  Right-shift on signed integers implementation defined,
         * but because we mask w1 and w2 with res, whether ASL or LSL is used is irrelevant.
         */
        rc = 0xFF;
        for (;;) {
          if (((w1 | w2) & rc) == 0) return 0;
          if (rc & res) return (w1 & rc) - (w2 & rc);
          w1 >>= 1;
          w2 >>= 1;
          res >>= 1;
          rc <<= 7;
        }
#  endif /* WANT_ARMS_BROKEN_STRCMP_FOR_TOP_BIT_SET_CHARACTERS */
#else
    if ((((int)a | (int)b) & 3) == 0)
    {   int w1, w2;
        nullbyte_prologue_();
        do {
            w1 = *(int *)a, a += 4;
            w2 = *(int *)b, b += 4;
        } while (w1 == w2 && !word_has_nullbyte(w1));

        /* sbrodie added note: it gets away with these implementation-defined right
         * shifts only because of the masking with 0xff.
         */
        for (;;)
        {   char c1 = (w1 >> 24) & 0xff, c2 = (w2 >> 24) & 0xff;
            int d = c1 - c2;
            if (d != 0) return d;
            if (c1 == 0) return 0;
            w1 = w1 << 8; w2 = w2 << 8;
        }
#endif
    }
#endif
    {   char const *ap = a; /* in order to move ap from reg a1 */
        for (;;)
        {   char c1 = *ap++, c2 = *b++;
            int d = c1 - c2;
            if (d != 0) return d;
            if (c1 == 0) return d;     /* no need to check c2 */
        }
    }
}

int strncmp(const char *a, const char * b, size_t n)
                                        /* as strcmp, but at most n chars */
{
#ifdef _copywords
    if ((((int)a | (int)b) & 3) == 0)
    {   int w;
        nullbyte_prologue_();
        while (n >= 4 && (w = *(int *)a) == *(int *)b && !word_has_nullbyte(w))
            a += 4, b += 4, n -= 4;
    }
#endif
    while (n-- > 0)
    {   char c1 = *a++, c2 = *b++;
        int d = c1 - c2;
        if (d != 0) return d;
        if (c1 == 0) return 0;     /* no need to check c2 */
    }
    return 0;
}

static int strcoll_territory = 0;

size_t strxfrm(char *s1, const char *s2, size_t n)
{
    _kernel_swi_regs r;
    size_t l;

    if (strcoll_territory) {
        r.r[0] = strcoll_territory;
        r.r[1] = (int)s1;
        r.r[2] = (int)s2;
        r.r[3] = n;
        if (!_kernel_swi(Territory_TransformString, &r, &r))
            return r.r[0];
    }
    /* C locale or error from territory SWI */
    /* In C locale this should just *resemble* a less efficient strncpy().  */
    l = strlen(s2);
    for (; n != 0; n--)
        if ((*s1++ = *s2++) == 0) break;
    return l;
}

int strcoll(const char *a, const char *b)
{
    _kernel_swi_regs r;

    if (strcoll_territory == 0) return strcmp(a, b);  /* C locale */
    r.r[0] = strcoll_territory;
    r.r[1] = (int) a;
    r.r[2] = (int) b;
    r.r[3] = 0;
    if (_kernel_swi(Territory_Collate, &r, &r))
        return 0;

    return r.r[0];
}

void _set_strcoll(int territory)
{
    strcoll_territory = territory;
}

/* search functions - ordered more logically then in ANSI spec */

void *memchr(const void *s, _chararg ch, size_t n)
                                            /* first instance of ch in s */
{   const unsigned char *t = (const unsigned char *)s;
    unsigned char c1 = (unsigned char)ch;
    while (n-- > 0) if (*t == c1) return (void *)t; else t++;
    return 0;
}

/*  for the next two functions ANSI say you CAN search for '\0'.          */

char *strchr(const char *s, _chararg ch)
                                        /* find first instance of ch in s */
{   char c1 = (char)ch;
    for (;;)
    {   char c = *s++;
        if (c == c1) return (char *)s-1;
        if (c == 0) return 0;
    }
}

char *strrchr(const char *s, _chararg ch)  /* find last instance of ch in s */
{   const char *p = s;
    while (*p++ != 0) /* nothing */;
    {   char c1 = (char)ch;
        do { if (*--p == c1) return (char *)p; } while (p!=s);
    }
    return 0;
}

/* N.B. strspn(s,"")==0 & strcspn(s,"")==strlen(s) means that the next two
   fns are not quite symmetric.  */

size_t strspn(const char *s, const char *p)
                                        /* find first char in s not in p */
{   const char *ss, *pp;
    char ch;
    for (ss=s;;ss++)
    {   if ((ch = *ss) == 0) return ss-s;
        for (pp=p;;)
        {   char c1 = *pp++;
            if (c1 == 0) return ss-s;
            if (c1 == ch) break;
        }
    }
}

size_t strcspn(const char *s, const char *p)
                                     /* find first char in s that is in p */
{   const char *ss, *pp;
    char ch;
    for (ss=s;;ss++)
    {   char c1;
        if ((ch = *ss) == 0) return ss-s;
        for (pp=p; (c1 = *pp++) != 0; ) if (c1 == ch) return ss-s;
    }
}

char *strpbrk(const char *s, const char *p)
                                        /*  ditto, except ptr/NULL result */
{   const char *ss, *pp;
    char ch;
    for (ss=s;;ss++)
    {   char c1;
        if ((ch = *ss) == 0) return 0;
        for (pp=p; (c1 = *pp++) != 0; ) if (c1 == ch) return (char *)ss;
    }
}

char *strstr(const char *a, const char *b)
                              /* find first occurrence of b in a, or NULL */
{   int i;
    for (;;)
    {   for (i=0;; i++)
        {   char ch = b[i];
            if (ch == 0) return (char *)a;
            if (a[i] != ch) break;
        }
        if (*a++ == 0) return 0;
    }
}

char *strtok(char *s1, const char *s2)
{   static char *saves1 = "";
    char *s0;
    if (s1 == 0) s1 = saves1;                          /* use saved pointer */
    if (*(s1 += strspn(s1,s2)) == 0) s0 = 0;             /* no tokens */
    else { s0 = s1;
           if (*(s1 += strcspn(s1,s2)) != 0) *s1++ = 0;  /* insert 0 if nec */
         }
    return (saves1 = s1, s0);
}

/* Miscellaneous functions */

#ifndef SEPARATE_MEMSET

void *memset(void *s, _chararg c, size_t n)
{
    unsigned char *p = s;
    while (n > 0)
    {
#ifdef _copywords
        if (n >= 4 && ((int)p & 3) == 0)
        {   int w = 0x01010101 * (unsigned char)c;     /* duplicate 4 times */
            do *(int *)p = w, p += 4, n -= 4; while (n >= 4);
        }
        else
#endif
            *p++ = (unsigned char)c, n--;
    }
    return s;
}

#endif

char *strerror(int n)
{   static char v[80];
    return _strerror(n, v);
}

size_t strlen(const char *a)            /* find number of chars in a string */
{   const char *x = a + 1;
#ifdef _copywords
    int w;
    while ((int)a & 3)
    {   if (*a++ == 0) return a - x;
    }
    {
        nullbyte_prologue_();
        while (w = *(int *)a, a += 4, !word_has_nullbyte(w)) /* do nothing */;
        /* a now points one word after the one containing
           the terminating null */
    }
#ifdef BYTESEX_EVEN
    if ((w & 0xff) == 0)
        a -= 3;
    else if ((w & 0xff00) == 0)
        a -= 2;
    else if ((w & 0xff0000) == 0)
        a -= 1;
#else
    if ((w & 0xff000000) == 0)
        a -= 3;
    else if ((w & 0xff0000) == 0)
        a -= 2;
    else if ((w & 0xff00) == 0)
        a -= 1;
#endif
#else
    while (*a++ != 0);
#endif
    return a - x;
}

#include <errno.h>

char *_strerror(int n, char *v)
{
    switch (n)
    {   case 0:
            return _kernel_getmessage2("No error (errno = 0)", "C35", v, 80);
        case EDOM:
            return _kernel_getmessage2("EDOM - function argument out of range", "C36", v, 80);
        case ERANGE:
            return _kernel_getmessage2("ERANGE - function result not representable", "C37", v, 80);
        case ESIGNUM:
            return _kernel_getmessage2("ESIGNUM - illegal signal number to signal() or raise()", "C66", v, 80);
        case EILSEQ:
            return _kernel_getmessage2("EILSEQ - character encoding error", "C74", v, 80);
        case EOVERFLOW:
            return _kernel_getmessage2("EOVERFLOW - too large for data structure", "C75", v, 80);
        case EFBIG:
            return _kernel_getmessage2("EFBIG - data written to file lost due to exceeding file size limit", "C76", v, 80);
        default:
            return _hostos_error_string(n, v);
    }
}

/* End string.c */
@


4.9
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d539 6
@


4.8
log
@  Fix for strxfrm()
Detail:
  strxfrm was passing the buffers to the Territory module SWI the wrong
    way around so Territory_TransformString copied the destination over
    the source rather than vice versa!
Admin:
  Reported by <mailto:ian.foster@@gps.tandb.co.uk>
  Fixes Bugzilla bug #4375


Version 5.33. Tagged as 'RISC_OSLib-5_33'
@
text
@d352 1
a352 1
    int ret;
d355 5
a359 3
    if (_swix(Territory_Collate, _INR(0,3)|_OUT(0),
                                 strcoll_territory, a, b, 0,
                                 &ret))
d362 1
a362 1
    return ret;
@


4.7
log
@  Tidied up the strcmp() fix to remove an unused variable.
  Initialised so_far in stdio.c to remove compiler warning.
Admin:
  Built.  strcmptest() still indicates that strcmp() is working OK!

Version 5.32. Tagged as 'RISC_OSLib-5_32'
@
text
@d336 2
a337 2
        r.r[1] = (int)s2;
        r.r[2] = (int)s1;
@


4.6
log
@  strcmp() fix was broken.
Detail:
  This alternate implementation returned non-zero for equal strings,
    because the tidyup routine failed to stop examining the differing
    words when it found matching zero bytes.
Admin:
  Tested in softload C library, and in Lazarus ROM image.  strcmp()
    appears to be working per spec now.

Version 5.31. Tagged as 'RISC_OSLib-5_31'
@
text
@d265 1
a265 2
        rc = res & -res;
        res = 0xFF;
d267 2
a268 2
          if (((w1 | w2) & res) == 0) return 0;
          if (rc & res) return (w1 & res) - (w2 & res);
d271 2
a272 2
          rc >>= 1;
          res <<= 7;
@


4.5
log
@  Fix for strcmp().
  Fix for RISC_OSLib res() function.
Detail:
  Version 4.89 featured an improved strcmp() routine that didn't actually
    work properly (bug #4085).  The return values had the wrong sign if this
    optimised code was used and the string contained top-bit set chars.
  Removed that rlib.s.asmdefs hack as the comment in the makefile suggested.
    Nothing needs it any more as the assembler sources that require it now
    get via a -PD argument.
  res_ prefix function was still wrong as it failed to detect valid but wrong
    filenames, hence the "Make$Path not defined" errors in the latest tools
    release.
Admin:
  Fixes Bugzilla bug #4085
  Should fix BaseSW's build problems too.

Version 5.29. Tagged as 'RISC_OSLib-5_29'
@
text
@d268 1
@


4.4
log
@* Trailing garbage no longer appears after some perror() calls.
* Correction to static base location in modulewrap - was affecting some
  DSL 4000 video software.

Version 5.15. Tagged as 'RISC_OSLib-5_15'
@
text
@d229 1
d243 1
d258 17
d284 3
@


4.3
log
@  Fix for strcoll
Detail:
  Somebody had modified the SWI call to Territory_Collate to be done
    via _swix instead of _kernel_swi, but didn't remove the _kernel_swi_regs
    variable (r) and didn't change the function return value to return the
    new "ret" variable instead of r.r[0] which gives arbitrary results - in
    particular it confuses qsort.
Admin:
  Tested that it builds.

Version 4.97. Tagged as 'RISC_OSLib-4_97'
@
text
@d508 1
a508 1
            return _kernel_getmessage("No error (errno = 0)", "C35");
d510 1
a510 1
            return _kernel_getmessage("EDOM - function argument out of range", "C36");
d512 1
a512 1
            return _kernel_getmessage("ERANGE - function result not representable", "C37");
d514 1
a514 1
            return _kernel_getmessage("ESIGNUM - illegal signal number to signal() or raise()", "C66");
@


4.2
log
@Ursula branch merged.
StrongARMfudge flag removed.
StrongARM compatibility set according to AMBKernel flag in Hdr:RISCOS
strftime %U and %W specifiers fixed for week 0.

Version 4.89. Tagged as 'RISC_OSLib-4_89'
@
text
@a329 1
    _kernel_swi_regs r;
d338 1
a338 1
    return r.r[0];
@


4.1
log
@Initial revision
@
text
@a14 1

d16 2
a17 1
/* Copyright (C) A.C. Norman and A. Mycroft */
d60 1
a60 1
#ifndef SEPERATE_MEMCPY
d208 2
a209 1
{   const unsigned char *ac = a, *bc = b;
d227 30
d264 1
a264 9
#ifdef BYTESEX_EVEN
        for (;;)
        {   char c1 = w1 & 0xff, c2 = w2 & 0xff;
            int d = c1 - c2;
            if (d != 0) return d;
            if (c1 == 0) return 0;
            w1 = w1 >> 8; w2 = w2 >> 8;
        }
#else
d275 7
a281 5
    for (;;)
    {   char c1 = *a++, c2 = *b++;
        int d = c1 - c2;
        if (d != 0) return d;
        if (c1 == 0) return 0;     /* no need to check c2 */
d331 1
d334 3
a336 5
    r.r[0] = strcoll_territory;
    r.r[1] = (int)a;
    r.r[2] = (int)b;
    r.r[3] = 0;
    if (_kernel_swi(Territory_Collate, &r, &r))
d338 1
d351 1
a351 1
{   const unsigned char *t = s;
d443 2
d462 7
d503 19
a521 1
/* End string processing library */
@


4.1.4.1
log
@Improved strcmp and memset functions nicked from ARM's version of the
library.
@
text
@d15 1
d17 1
a17 2
/* Copyright (C) Codemist Ltd., 1988                              */
/* Copyright (C) Advanced Risc Machines Ltd., 1991                */
d60 1
a60 1
#ifndef SEPARATE_MEMCPY
d208 1
a208 2
{   const unsigned char *ac = (const unsigned char *)a,
                        *bc = (const unsigned char *)b;
a225 30
#ifdef BYTESEX_EVEN
/* Improved little-endian ARM strcmp code by Ian Rickards, ARM Ltd. */
    if ((((int)a | (int)b) & 3) == 0)
    {   int w1, w2, res, rc;
        nullbyte_prologue_();
        do {
            w1 = *(int *)a, a += 4;
            w2 = *(int *)b, b += 4;
            res = w1 - w2;
            if (res != 0) goto strcmp_checkbytes;

        } while (!word_has_nullbyte(w1));
        return 0;

strcmp_checkbytes:
/* carry propagation in subtract means that no subtract-per-byte is needed */
        rc = res << 24;
        if (rc != 0) return rc;
        if ((w1 & 0xff) == 0) return rc;

        rc = res << 16;
        if (rc != 0) return rc;
        if ((w1 & 0xff00) == 0) return rc;

        rc = res << 8;
        if (rc != 0) return rc;
        if ((w1 & 0xff0000) == 0) return rc;

        return res;
#else
d233 9
a241 1

d252 5
a256 7
    {   char const *ap = a; /* in order to move ap from reg a1 */
        for (;;)
        {   char c1 = *ap++, c2 = *b++;
            int d = c1 - c2;
            if (d != 0) return d;
            if (c1 == 0) return d;     /* no need to check c2 */
        }
a305 1
    int ret;
d308 5
a312 3
    if (_swix(Territory_Collate, _INR(0,3)|_OUT(0),
                                 strcoll_territory, a, b, 0,
                                 &ret))
a313 1

d326 1
a326 1
{   const unsigned char *t = (const unsigned char *)s;
a417 2
#ifndef SEPARATE_MEMSET

a433 2

#endif
@


4.1.4.2
log
@* RISC_OSLib msgs module now closes its Messages files on exit.
* strerror/perror now call _kernel_last_oserror and use result
  if errno is unknown.
* _sys_open calls error-returning form of OS_Find so
  _kernel_last_oserror can return something meaningful after
  fopen fails
* All file handling calls set errno to -1 if a _kernel_osfind/
  _kernel_osgbpb etc call returns an error
* These three changes mean that the code sequence

         if ((fp = fopen(file, "rb")) == NULL) {
            perror(progname);
            return 1;
         }

  will now say something useful rather than "No error (errno=0)"
  This could now be used by socklib to get perror to work
  with errors generated by the Internet module.
* ANSILib now outputs proper messages, not just tokens.
@
text
@a463 5
char *strerror(int n)
{   static char v[256];
    return _strerror(n, v);
}

d498 1
a498 19
#include <errno.h>

char *_strerror(int n, char *v)
{
    switch (n)
    {   case 0:
            return _kernel_getmessage("No error (errno = 0)", "C35");
        case EDOM:
            return _kernel_getmessage("EDOM - function argument out of range", "C36");
        case ERANGE:
            return _kernel_getmessage("ERANGE - function result not representable", "C37");
        case ESIGNUM:
            return _kernel_getmessage("ESIGNUM - illegal signal number to signal() or raise()", "C66");
        default:
            return _hostos_error_string(n, v);
    }
}

/* End string.c */
@


4.1.4.3
log
@Last check-in broke the stubs...
@
text
@d465 1
a465 1
{   static char v[80];
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.9;
access;
symbols
	RISC_OSLib-5_97:4.9
	RISC_OSLib-5_96:4.9
	RISC_OSLib-5_95:4.9
	RISC_OSLib-5_94:4.9
	RISC_OSLib-5_93:4.9
	RISC_OSLib-5_92:4.9
	RISC_OSLib-5_91:4.9
	RISC_OSLib-5_90:4.9
	RISC_OSLib-5_89:4.9
	RISC_OSLib-5_88:4.9
	RISC_OSLib-5_87:4.9
	RISC_OSLib-5_86-1:4.9
	RISC_OSLib-5_86:4.9
	RISC_OSLib-5_85:4.9
	RISC_OSLib-5_84:4.9
	RISC_OSLib-5_83-2:4.6
	RISC_OSLib-5_83-1:4.6
	RISC_OSLib-5_83:4.9
	RISC_OSLib-5_82:4.9
	RISC_OSLib-5_81:4.9
	RISC_OSLib-5_75-2:4.6
	RISC_OSLib-5_80:4.9
	RISC_OSLib-5_79:4.9
	RISC_OSLib-5_78:4.9
	RISC_OSLib-5_75-1:4.6
	RISC_OSLib-5_77:4.8
	RISC_OSLib-5_76:4.7
	RISC_OSLib-5_75:4.6
	RISC_OSLib-5_74:4.6
	RISC_OSLib-5_73:4.6
	RISC_OSLib-5_72:4.6
	RISC_OSLib-5_71:4.6
	RISC_OSLib-5_70:4.6
	RISC_OSLib-5_69:4.6
	RISC_OSLib-5_68:4.6
	RISC_OSLib-5_67:4.6
	RISC_OSLib-5_66:4.6
	RISC_OSLib-5_65:4.6
	RISC_OSLib-5_64:4.6
	RISC_OSLib-5_63:4.5
	RISC_OSLib-5_62:4.5
	RISC_OSLib-5_61:4.5
	RISC_OSLib-5_60:4.5
	RISC_OSLib-5_59:4.5
	RISC_OSLib-5_58:4.5
	RISC_OSLib-5_57:4.5
	RISC_OSLib-5_56:4.5
	RISC_OSLib-5_55:4.5
	RISC_OSLib-5_54:4.5
	RISC_OSLib-5_53:4.5
	RISC_OSLib-5_52:4.5
	RISC_OSLib-5_51:4.5
	RO_5_07:4.5
	RISC_OSLib-5_50:4.5
	RISC_OSLib-5_49:4.5
	RISC_OSLib-5_46-4_64_2_1:4.4
	NoInlineAsm:4.4.0.2
	RISC_OSLib-5_48:4.4
	RISC_OSLib-5_47:4.4
	RISC_OSLib-5_46:4.4
	RISC_OSLib-5_45:4.4
	RISC_OSLib-5_44:4.3
	RISC_OSLib-5_43:4.3
	RISC_OSLib-5_42:4.3
	RISC_OSLib-5_41:4.3
	RISC_OSLib-5_40:4.2
	RISC_OSLib-5_39:4.2
	RISC_OSLib-5_38:4.2
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2013.10.24.20.03.49;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	8snV0tcFxVQyiAax;

4.8
date	2013.03.24.08.06.50;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	sKrRgCgz4PD5d1Jw;

4.7
date	2013.03.20.08.34.48;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	L7rulQ2qjYwEuvIw;

4.6
date	2011.10.28.14.23.18;	author bavison;	state Exp;
branches;
next	4.5;
commitid	hIG6j26y6NoxM7Fv;

4.5
date	2004.01.23.19.10.19;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2003.01.17.19.12.59;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2002.05.22.10.45.24;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2002.03.21.14.36.24;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.49;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.49;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.50;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.13;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.34;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Some library fixes
Fix for problem passing long command lines via system(), while there are good arguments to leave the threshold at 255, non DDEUtils aware programs get brutally truncated command strings, and since the old threshold of 255 applied when the kernel handled 256 command lines, upping the limit to 1k is no worse than before.
Fix for Edit failing to draw lines of text longer than 192 characters (ticket #350). Several factors were conspiring here: on a mode change the window width in characters wasn't being clamped, whereas user entered limits in the menu were, then the internal buffer ("PAINTBUFSIZE") was too short so lines got truncated, and when larger than 256 got wrapped modulo 256 due to the use of an array of chars. Now set at compile time with BIG_WINDOW_SIZE_LIMIT with a new theoretical maximum of 8192. Currently limited to 480 since it uses stack variables.

In the C library:
 armsys.c: adapt the threshold at which to use DDEUtils based on the kernel version number
 scanf.c: squash a warning
 time.c: mark the table of month lengths as constant so we can claw back 13 words of static workspace without having to change the stubs

In RISC OS lib:
 bbc.c: remove local definitions of some SWI numbers
 template.c: squash a warning
 txt.c: delete Modula-2 support
 txt1.c: compare pointer with NULL not an integer
 txtar.c: introduce BIG_WINDOW_SIZE_LIMIT, rationalise a few sprintf's, mark private functions as static
 txtundo.c/txtedit.c: squash old style function warnings
 txtoptmenu.c: clamp the window width read from Edit$Options properly, delete long disabled code
 txtscrap.c: dead function deleted


Version 5.78. Tagged as 'RISC_OSLib-5_78'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* scanf.c: ANSI draft (X3J11 Oct 86) part of section 4.9 code */
/* Copyright (C) Codemist Ltd., 1988                           */

/* version 4a */
/* BEWARE: there are quite a few ambiguities/oddities in the Oct 86 ANSI   */
/* draft definition of scanf().                                            */
/* Memo: consider using ftell() (or rather fgetpos() for big file worries) */
/* one day instead of charcount below.  See also 'countgetc()'.            */
/* Memo 2: the code below always reads one char beyond the end of the      */
/* item to be converted.  The exception is '%c' (q.v.).                    */
/* The last char is then __backspace()'d.  This is done so avoid using up  */
/* the 1 char ungetc() guaranteed at all other times.                      */

#define __system_io 1    /* makes stdio.h declare more */
/* sscanf wants to know about the system part of the FILE descriptor */

#include "hostsys.h"
#include "kernel.h"
#include <stdio.h>       /* we define scanf for this        */
#include <stdlib.h>      /* and strtol/strtoul etc for this */
#include <inttypes.h>    /* and strtoimax/strtoumax for this */
#include <math.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <fenv.h>

/* HIDDEN IMPORT from stdio.c */
extern int __backspace(FILE *stream);  /* a strict R-inverse of getc() */

#define NOSTORE      01
#define LONG         02
#define SHORT        04
#define FIELDGIVEN  010
#define LONGDOUBLE  020
#define ALLOWSIGN   040    /* + or - acceptable to rd_int  */
#define DOTSEEN    0100    /* internal to rd_real */
#define NEGEXP     0200    /* internal to rd_real */
#define NUMOK      0400    /* ditto + rd_int */
#define NUMNEG    01000    /* ditto + rd_int */
#define CHAR      02000
#define LONGLONG  04000

#define countgetc(p) (charcount++, getc(p))


/* The next macros, with the help of the compiler, ensures that we can */
/* test for LONG and SHORT properly, but not general extra code.       */
#define isLONGLONG_(flag) ((flag) & LONGLONG)
#define isLONG_(flag) ((flag) & LONG && sizeof(int) != sizeof(long))
#define isSHORT_(flag) ((flag) & SHORT)
#define isCHAR_(flag) ((flag) & CHAR)
#define isLONGDOUBLE_(flag) \
    ((flag) & LONGDOUBLE && sizeof(double) != sizeof(long double))

#define CVTEOF     (-1)   /* used for eof return (!= any number of chars)   */
#define CVTFAIL    (-2)   /* used for error return (!= any number of chars) */

#define scanf_intofdigit(c) ((c) - '0')

static int ch_val(int ch, int radix)
{
    int val;
    /* Memo: beware that ANSI currently say a-z act as 10-35 for strtol() */
    /* etc.  The test below is isalpha() etc.  This means that this test  */
    /* may not work in a non-C locale where isalpha('{') may be true      */
    /* (e.g. Swedish ASCII).                                              */
    if ('A' == 193)  /* ebcdic */
        val = (isdigit(ch) ? (ch) - '0' :
               isalpha(ch) ? (ch |= 0x40,         /* quick ebcdic toupper */
                   ch <= 'I' ? ch - 'A' + 10 :
                   ch <= 'R' ? ch - 'J' + 19 :
                               ch - 'S' + 28) :
               -1);
    else
        val = (isdigit(ch) ? (ch) - '0' :
               islower(ch) ? (ch) - 'a' + 10 :
               isupper(ch) ? (ch) - 'A' + 10 :
               -1);
    return (val < radix ? val : -1);
}

static long int rd_int(FILE *p, va_list res, int flag, int radix, int field)
{   long int charcount = -1;                   /* allow for always ungetc */
    unsigned long long int n = 0;
    int ch;
    while (isspace(ch = countgetc(p)));        /* leading whitespace */
    if (ch == EOF) return CVTEOF;
    flag &= ~(NUMOK+NUMNEG);
    if (field > 0 && flag & ALLOWSIGN) switch (ch)
    {
case '-':   flag |= NUMNEG;
case '+':   ch = countgetc(p);
            field--;
            break;
    }
    if (field > 0 && ch=='0')
    {   flag |= NUMOK, field--;  /* starts with 0 - maybe octal or hex mode */
        ch = countgetc(p);
        if (field > 0 && (ch=='x' || ch=='X') && (radix==0 || radix==16))
        {   flag &= ~NUMOK, field--;
            ch = countgetc(p);
            radix = 16;
        }
        else if (radix == 0) radix = 8;
    }
    if (radix == 0) radix = 10;
    {   int digit;
        while (field > 0 && (digit = ch_val(ch, radix)) >= 0)
        {   flag |= NUMOK, field--;
            n = n*radix + digit;
            ch = countgetc(p);
        }
    }
    __backspace(p);
    if (!(flag & NUMOK)) return CVTFAIL;
    if (!(flag & NOSTORE))
    { /* This code is pretty specious on a 2's complement machine         */
      if (flag & ALLOWSIGN)
      { long long m = flag & NUMNEG ? -n : n;
        int *p = va_arg(res, int *);  /* rely on sizeof(int*)=sizeof(short*) */
        if isCHAR_(flag) *(signed char *)p = (signed char)m;
        else if isSHORT_(flag) *(short *)p = (short)m;
        else if isLONG_(flag) *(long *)p = (long)m;
        else if isLONGLONG_(flag) *(long long *)p = m;
        else *(int *)p = (int)m;
      }
      else  /* pointer case comes here too - with quite some type pun!  */
      { unsigned int *p = va_arg(res, unsigned int *);
            /* rely on sizeof(unsigned int *)==sizeof(unsigned short *) */
        if isCHAR_(flag) *(unsigned char *)p = (unsigned char)n;
        else if isSHORT_(flag) *(unsigned short *)p = (unsigned short)n;
        else if isLONG_(flag) *(unsigned long *)p = (unsigned long)n;
        else if isLONGLONG_(flag) *(unsigned long long *)p = n;
        else *(unsigned int *)p = (unsigned int)n;
      }
    }
    return charcount;
}

#ifndef NO_FLOATING_POINT

static float carefully_narrow(double l)
{
/* All the trouble I went to to detect potential overflow has to be re-  */
/* done here so that underflow and overflow do not occur during the      */
/* narrowing operation that is about to be done.                         */
    #pragma STDC FENV_ACCESS ON
    fenv_t env;
    float f;
    feholdexcept(&env);
    f = (float) l;
    if (fetestexcept(FE_UNDERFLOW|FE_OVERFLOW))
        errno = ERANGE;
    fesetenv(&env);
    return f;
}

/* Do the conversion work from hex to a double/float.
 * a[] is up to 19 hex digits, fed in at the bottom.
 * x is the exponent so far. Assumes non-zero input.
 */
static double cvthex(unsigned *a, int x, int flag)
{
    unsigned round, sticky;
    unsigned msb, lsw;
    int minx, maxx;

    /* Note parameters of the destination type */
    if (flag & LONG)
        msb = 0x00100000, lsw = 1, minx = -1022, maxx=1023, x += 20 + 64;
    else
        msb = 0x00800000, lsw = 0, minx = -126, maxx=127, x += 23 + 64;

    /* Normalise the input digits */
    if (a[0]==0 && a[1]==0)
    {   a[1] = a[2];
        a[2] = 0;
        x -= 32;
    }

    while ((a[0] & msb)==0)
    {   a[0] = (a[0]<<1) | (a[1]>>31);
        a[1] = (a[1]<<1) | (a[2]>>31);
        a[2] = a[2]<<1;
        x -= 1;
    }

    /* Check for total underflow */
    if (x < minx - 64)
    {   errno = ERANGE;
        return 0.0;
    }

    /* Denormalise if necessary */
    if (x < minx)
    {   do
        {   a[2] = (a[1]<<31) | (a[2]>>1) | (a[2]&1);
            a[1] = (a[0]<<31) | (a[1]>>1);
            a[0] =              (a[0]>>1);
        } while (++x < minx);
        x = minx - 1;
    }

    /* Proceed to round */
    round = a[lsw+1] >> 31;
    sticky = a[lsw+1] & 0x7fffffff;
    if (lsw == 0)
        sticky |= a[2];

    /* Round up if necessary */
    if (round)
    {   if (sticky || (a[lsw] & 1))
        {   if (++a[lsw] == 0)
                a[0]++;
            /* Renormalise if necessary */
            if (a[0] & (msb<<1))
            {   a[1] = (a[0]<<31) | (a[1]>>1);
                a[0] = (a[0]>>1);
                x += 1;
            }
            /* or convert denormalised to normalised */
            else if (x < minx && (a[0] & msb)) /* x will be minx-1 */
            {   x = minx;
                errno = ERANGE;
            }
        }
    }

    /* Indicate underflow (denormalised, and inaccurate - really should only
     * report underflow if inaccuracy DUE TO DENORMALISATION, but hey) */
    if (x < minx && (round || sticky))
        errno = ERANGE;

    /* Check for overflow */
    if (x > maxx)
    {   errno = ERANGE;
        return (flag & NUMNEG) ? -HUGE_VAL : HUGE_VAL;
    }

    if (flag & NUMNEG) a[0] |= 0x80000000;

    if (flag & LONG)
    {   a[0] = (a[0] &~ msb) | ((x+1023) << 20);
        return *(double *) a;
    }
    else
    {   a[0] = (a[0] &~ msb) | ((x+127) << 23);
        return *(float *) a;
    }
}

static double rd_naninf(FILE *p, int ch, int *flagp, int field, long int *charcountp)
{
    double l;
    long int charcount = *charcountp;
    int flag = *flagp;
    const char *match = (ch == 'n' || ch == 'N') ? "NAN" : "INFINITY";
    const char *m = match;

    while (field > 0)
    {   if (ch >= 'a' && ch <= 'z') ch += 'A'-'a';
        if (ch == *m && *m != '\0') {
           ch = countgetc(p);
           field--;
        }
        else break;
        m++;
    }

    if (*m == '\0' || (match[0] == 'I' && m == match+3))
    {
        flag |= NUMOK;
        if (match[0] == 'N')
        {
            if (field > 0 && ch == '(')
            {
                flag &=~ NUMOK;
                ch = countgetc(p);
                field--;
                while (field > 0)
                {    if (ch >= 'a' && ch <= 'z' ||
                         ch >= 'A' && ch <= 'Z' ||
                         ch >= '0' && ch <= '9' ||
                         ch == '_')
                     { ch = countgetc(p);
                       field--;
                     }
                     else if (ch == ')')
                     { ch = countgetc(p);
                       field--;
                       flag |= NUMOK;
                       break;
                     }
                     else break;
                }
            }
            l = flag & NUMNEG ? -NAN : NAN;
        }
        else
            l = flag & NUMNEG ? -INFINITY : INFINITY;
    }
    else
        l = HUGE_VAL;

    __backspace(p);

    *charcountp = charcount;
    *flagp = flag;
    return l;
}

#ifdef HOST_HAS_BCD_FLT

static long int rd_real(FILE *p, va_list res, int flag, int field)
{
    long int charcount = -1;                     /* allow for always ungetc */
    int ch, x = 0, ishex = 0;
    unsigned int a[3];            /* IEEE 'packed' format as per ACORN FPE2 */
    double l = 0.0;
    a[0] = a[1] = a[2] = 0;
    while (isspace(ch = countgetc(p)));  /* not counted towards field width */
    if (ch == EOF) return CVTEOF;
    flag &= ~(NUMOK+DOTSEEN+NUMNEG);
    if (field > 0) switch (ch)
    {
case '-':   flag |= NUMNEG;
case '+':   ch = countgetc(p);
            field--;
            break;
    }
    if (field > 0 && (ch == 'n' || ch == 'N' || ch == 'i' || ch == 'I'))
    {   l = rd_naninf(p, ch, &flag, field, &charcount);
        goto lready;
    }
    if (field >= 2 && ch == '0')
    {   ch = countgetc(p);
        field--;
        if (ch == 'x' || ch == 'X')
        {   ch = countgetc(p);
            field--;
            ishex = 1;
        }
        else
            /* We've swallowed the 0. No-one will care if we do this: */
            flag |= NUMOK;
    }
    while (field > 0)
    {   if ((ch==*decimal_point || ch=='.') && !(flag & DOTSEEN))
            flag |= DOTSEEN, field--;
        else if (isdigit(ch) || ishex && isxdigit(ch))
        {   flag |= NUMOK, field--;
            if ((a[0] & 0xf00) == 0)
            {   a[0] = (a[0]<<4) | (a[1]>>28);
                a[1] = (a[1]<<4) | (a[2]>>28);
                a[2] = (a[2]<<4) | (ishex ? ch_val(ch, 16) : scanf_intofdigit(ch));
                if (flag & DOTSEEN) x -= 1;
            }
            else
            {   if (ishex && ch != '0') a[2] |= 1;
                if (!(flag & DOTSEEN)) x += 1;
            }
        }
        else break;
        ch = countgetc(p);
    }
    if (ishex) x *= 4;
    /* we must unread the 'e' in (say) "+.e" as cannot be valid */
    if (field > 0 && (ishex && (ch == 'p' || ch == 'P') ||
                     !ishex && (ch == 'e' || ch == 'E')) && (flag & NUMOK))
    {   int x2 = 0;
        flag &= ~(NUMOK+NEGEXP), field--;
        switch (ch = countgetc(p))
        {
    case '-':   flag |= NEGEXP;
    case '+':   ch = countgetc(p);
                field--;
    default:    break;
        }
        while (field > 0 && isdigit(ch))
        {   flag |= NUMOK, field--;
            x2 = 10*x2 + scanf_intofdigit(ch);
            ch = countgetc(p);
        }
        if (flag & NEGEXP) x -= x2; else x += x2;
    }
    __backspace(p);
    if (a[0]==0 && a[1]==0 && a[2]==0) l = (flag & NUMNEG) ? -0.0 : 0.0;
    else if (ishex) l = cvthex(a, x, flag);
    else
    {   if (a[0]==0 && a[1]==0)
        {   a[1] = a[2];
            a[2] = 0;
            x -= 8;
        }
        while ((a[0] & 0xf00)==0)
        {   a[0] = (a[0]<<4) | (a[1]>>28);
            a[1] = (a[1]<<4) | (a[2]>>28);
            a[2] = a[2]<<4;
            x -= 1;
        }
        x += 18;    /* allow for position of decimal point in packed format */
        if (x < -999) l = 0.0, errno = ERANGE;
        else if (x > 999)
        {   if (flag & NUMNEG) l = -HUGE_VAL;
            else l = HUGE_VAL;
            errno = ERANGE;
        }
        else
        {   int xDiv10;
            if (x < 0) a[0] |= 0x40000000, x = -x;
            xDiv10 = _kernel_sdiv10(x);
            a[0] |= (x - xDiv10 * 10) << 12;
            x = xDiv10;
            xDiv10 = _kernel_sdiv10(x);
            a[0] |= (x - xDiv10 * 10) << 16;
            x = xDiv10;
            a[0] |= _kernel_srem(10, x) << 20;
            if (flag & NUMNEG) a[0] |= 0x80000000;
            l = _ldfp(a);       /* sets errno if necessary */
        }
    }
  lready:
    if (!(flag & NUMOK)) return CVTFAIL;
    if (flag & LONG)
    {   if (!(flag & NOSTORE))
        {   if (isLONGDOUBLE_(flag))
                *va_arg(res, long double *) = l;  /* not fully done */
            else
                *va_arg(res, double *) = l;
        }
    }
    else
    {   float f = carefully_narrow(l);
        /* treat overflow consistently whether or not stored */
        if (!(flag & NOSTORE)) *va_arg(res, float *) = f;
    }
    return charcount;
}

#else /* HOST_HAS_BCD_FLT */

static long int rd_real(FILE *p, va_list res, int flag, int field)
{
    long int charcount = -1;                     /* allow for always ungetc */
    int ch, x = 0, w;
    int i = 0;
    double l = 0.0, pten = 0.1;
    while (isspace(ch = countgetc(p)));  /* not counted towards field width */
    if (ch == EOF) return CVTEOF;
    flag &= ~(NUMOK+DOTSEEN+NUMNEG);
    if (field > 0) switch (ch)
    {
case '-':   flag |= NUMNEG;
case '+':   ch = countgetc(p);
            field--;
            break;
    }
/* I accumulate up to 6 (decimal) significant figures in the integer     */
/* variable i, and remaining digits in the floating point variable l.    */
    while (field > 0)
    {   if ((ch==*decimal_point || ch=='.') && !(flag & DOTSEEN))
            flag |= DOTSEEN, field--;
        else if (isdigit(ch))
        {   flag |= NUMOK, field--;
            if (i < 100000)
            {   i = 10*i + scanf_intofdigit(ch);
                if (flag & DOTSEEN) x -= 1;
            }
            else
            {   l += pten * scanf_intofdigit(ch);
                pten /= 10.0;
                if (!(flag & DOTSEEN)) x += 1;
            }
        }
        else break;
        ch = countgetc(p);
    }
    /* we must unread the 'e' in (say) "+.e" as cannot be valid */
    if (field > 0 && (ch == 'e' || ch == 'E') && (flag & NUMOK))
    {   int x2 = 0;
        flag &= ~(NUMOK+NEGEXP), field--;
        switch (ch = countgetc(p))
        {
    case '-':   flag |= NEGEXP;
    case '+':   ch = countgetc(p);
                field--;
    default:    break;
        }
        while (field > 0 && isdigit(ch))
        {   flag |= NUMOK, field--;
            x2 = 10*x2 + scanf_intofdigit(ch);
            ch = countgetc(p);
        }
        if (flag & NEGEXP) x -= x2; else x += x2;
    }
    __backspace(p);
/* The code that follows multiplies (i.l) by 10^x using one-and-a-half   */
/* precision arithmetic, with relevant scaling so that any over or under */
/* flow is deferred to the very last minute.                             */
    {   double d, dlow, d3, d3low;
        int bx = (10*x)/3, w1;
        l = ldexp(l, x-bx);
        d = ldexp((double)i, x-bx);
        dlow = 0.0;
        if (x < 0)
        {   w1 = -x;
            d3 = 0.2;
            d3low = 0.0;
            _fp_normalize(d3, d3low);
            d3low = (1.0 - 5.0*d3)/5.0;
        }
        else
        {   w1 = x;
            d3 = 5.0;
            d3low = 0.0;
        }
        if (w1!=0) for(;;)
        {   if ((w1&1)!=0)
            {   l *= (d3 + d3low);
                dlow = d*d3low + dlow*(d3 + d3low);
                d *= d3;
                _fp_normalize(d, dlow);
                if (w1==1) break;
            }
            d3low *= (2.0*d3 + d3low);
            d3 *= d3;
            _fp_normalize(d3, d3low);
            w1 = w1 >> 1;
        }
#ifdef IBMFLOAT
        l = l + dlow;
/* I want to set l to (l+d)*2^bx here.                                   */
/* At present d has lots of low zero bits, and l is much smaller.        */
        switch (bx & 3)
        {
    case 3:     l *= 8.0;   d *= 8.0;   break;
    case 2:     l *= 4.0;   d *= 4.0;   break;
    case 1:     l *= 2.0;   d *= 2.0;   break;
    case 0:                             break;
        }
        {   double ltemp = l + d;
            double err = +(d - ltemp) + l;
            ltemp = ltemp + +(err + err);   /* Achieves rounding         */
            l = frexp(ltemp, &w);
            w += (bx & ~3);
        }
#else
        l = l + dlow;
        l = l + d;
        l = frexp(l, &w);
        w += bx;
#endif
/* Now I check to see if the number would give a floating point overflow */
/* and if so I return HUGE_VAL, and set errno to ERANGE.                 */
/* ********* machine dependent integers ***********                      */
#ifdef IBMFLOAT
        if (w > (0x3f)*4)
#else
        if (w >= 0x7ff-0x3fe)
#endif
        {   if (flag & NUMNEG) l = -HUGE_VAL;
            else l = HUGE_VAL;
            errno = ERANGE;
        }
/* Underflows yield a zero result but set errno to ERANGE                */
#ifdef IBMFLOAT
        else if (w <= -(0x41*4) && l!=0.0)
#else
        else if (w <= -0x3fe && l!=0.0)
#endif
        {   l = 0.0;
            errno = ERANGE;
        }
        else
        {   if (flag & NUMNEG) l = -ldexp(l, w);
            else l = ldexp(l, w);
        }
    }
    if (!(flag & NUMOK)) return CVTFAIL;
    if (flag & LONG)
    {   if (!(flag & NOSTORE))
        {   if (isLONGDOUBLE_(flag))
                *va_arg(res, long double *) = l;  /* not fully done */
            else
                *va_arg(res, double *) = l;
        }   
    }
    else
    {   float f = carefully_narrow(l);
        /* treat overflow consistently whether or not stored */
        if (!(flag & NOSTORE)) *va_arg(res, float *) = f;
    }
    return charcount;
}



#endif /* HOST_HAS_BCD_FLT */

#endif /* NO_FLOATING_POINT */

/* Amalgamate the next two routines? */
static long int rd_string(FILE *p, va_list res, int flag, int field)
{   long int charcount = -1;                     /* allow for always ungetc */
    int ch; char *s = NULL;
    while (isspace(ch = countgetc(p)));  /* not counted towards field width */
    if (ch == EOF) return CVTEOF;                /* fail if EOF occurs here */
    if (!(flag & NOSTORE)) s = va_arg(res, char *);
    while (field > 0 && ch!=EOF && !isspace(ch))
    {   field--;
        if (!(flag & NOSTORE)) *s++ = ch;
        ch = countgetc(p);
    }
    __backspace(p);                               /* OK if ch == EOF         */
    if (!(flag & NOSTORE)) *s = 0;
    return charcount;
}

/* Can "%[blah]" match a zero-length string? No                            */
/* ISO9899 7.19.6.2 Matches a nonempty sequence of characters              */
static long int rd_string_map(FILE *p, va_list res, int flag, int field,
                              unsigned int charmap[])
{   long int charcount = -1;                     /* allow for always ungetc */
    int ch; char *s = NULL;
    if (!(flag & NOSTORE)) s = va_arg(res, char *);
    ch = countgetc(p);
    if (ch == EOF) return CVTEOF;
    while (field > 0 && ch != EOF && (charmap[ch/32] & (1uL<<(ch%32))) != 0)
    {   field--;
        if (!(flag & NOSTORE)) *s++ = ch;
        ch = countgetc(p);
    }
    __backspace(p);                               /* OK if ch == EOF         */
    if (charcount == 0) return CVTFAIL;
    if (!(flag & NOSTORE)) *s = 0;
    return charcount;
}

int vfscanf(FILE *p, const char *sfmt, va_list argv)
{
/* The next line is essential (see isspace() ANSI doc. and also use of
 * charmap[] below) if char is signed by default.
 * Our char is unsigned, but the following line should
 * just use the same register for fmt/sfmt and so cost nothing!
 */
    const unsigned char *fmt = (const unsigned char *)sfmt;
    int cnt = 0;
    long charcount = 0;
    for (;;)
    {   int fch;
        switch (fch = *fmt++)
        {
case 0:     return cnt;                        /* end of format string   */

default:    {   int ch;
                if (isspace(fch))              /* consolidate whitespace */
                {   int seen = 0;
                    while (isspace(fch = *fmt++));
                    fmt--;
/* N.B. isspace() must return 0 if its arg is '\0' or EOF.               */
                    while (isspace(ch = getc(p))) charcount++, seen = 1;
                    __backspace(p);
#ifdef never
/* The next line requires non empty whitespace to match format whilespace. */
/* Removed as incompatible with bsd unix (and other prior practice?).      */
                    if (!seen) return cnt;     /* require at least 1     */
#endif
                    continue;
                }
                else if ((ch = getc(p)) == fch)
                {   charcount++;
                    continue;
                }
                __backspace(p);  /* offending char is left unread         */
                if (ch == EOF && cnt == 0) return EOF;
                return cnt;     /* unmatched literal                     */
            }

case '%':   {   int field = 0, flag = 0;
                long int worked;
                if (*fmt == '*') fmt++, flag |= NOSTORE;
                while (isdigit(fch = *fmt++))
                {   if (field > INT_MAX/10) return cnt; /* overflow check */
                    field = field*10 + fch - '0';
                    if (field < 0) return cnt;         /* overflow check */
                    flag |= FIELDGIVEN;
                }
                if (!(flag & FIELDGIVEN)) field = INT_MAX;
                if (fch == 'l')
                {   fch = *fmt++;
                    if (fch == 'l') fch = *fmt++, flag |= LONGLONG;
                    else            flag |= LONG;
                }
                else if (fch == 'L') fch = *fmt++, flag |= LONG | LONGDOUBLE;
                else if (fch == 'h')
                {   fch = *fmt++, flag |= SHORT;
                    if (fch == 'h') fch = *fmt++, flag |= CHAR;
                }
                else if (fch == 'z' || fch == 't') fch = *fmt++;
                else if (fch == 'j') fch = *fmt++, flag |= LONGLONG;
                switch (fch)
                {
        default:    return cnt;         /* illegal conversion code       */
        case '%':   {   int ch = getc(p);
/* treat as fatuous the omission of '%' from non-skipping white space list */
                        if (ch == '%')
                        {   charcount++;
                            continue;
                        }
                        __backspace(p);  /* offending char is left unread */
                        if (ch == EOF && cnt == 0) return EOF;
                        return cnt;     /* unmatched literal '%'         */
                    }
        case 'c':   if (!(flag & FIELDGIVEN)) field = 1;
                    {   char *cp = NULL; int ch;
                        if (!(flag & NOSTORE)) cp = va_arg(argv, char *);
/* ANSI say no chars match -> failure.  Hence 0 width must always fail.     */
                        if (field == 0) return cnt;
                        for (; field > 0; field--)
/* The next line reflects the ANSI wording suggesting EXACTLY 'field' chars */
/* should be read.                                                          */
                        {   if ((ch = countgetc(p)) == EOF)
                                return cnt == 0 ? EOF : cnt;
                            if (!(flag & NOSTORE)) *cp++ = ch;
                        }
                    }
                    if (!(flag & NOSTORE)) cnt++; /* If conversion succeeds */
                    continue;
        case 'd':   worked = rd_int(p, argv, flag | ALLOWSIGN, 10, field);
                    break;
        case 'e':
        case 'E':
        case 'f':
        case 'F':
        case 'g':
        case 'G':
        case 'a':
        case 'A':
#ifndef NO_FLOATING_POINT
                    worked = rd_real(p, argv, flag, field);
#else
                    return(cnt);    /* Floating point not implemented    */
#endif
                    break;
        case 'i':   worked = rd_int(p, argv, flag | ALLOWSIGN, 0, field);
                    break;
/* %n assigns the number of characters read from the input so far - NOTE */
/* that this assignment is NOT influenced by the * flag and does NOT     */
/* count towards the value returned by scanf.  Note that h and l apply.  */
        case 'n':   if isCHAR_(flag) *va_arg(argv, char *) = (char)charcount;
                    else if isSHORT_(flag) *va_arg(argv, short *) = (short)charcount;
                    else if isLONG_(flag) *va_arg(argv, long *) = charcount;
                    else if isLONGLONG_(flag) *va_arg(argv, long long *) = charcount;
                    else *va_arg(argv, int *) = (int)charcount;
                    continue;
        case 'o':   worked = rd_int(p, argv, flag | ALLOWSIGN, 8, field);
                    break;
                    /* pointers are displayed in hex, but h,l,L ignored */
        case 'p':   worked = rd_int(p, argv, flag & ~(LONG|SHORT|CHAR), 16, field);
                    break;
        case 's':   worked = rd_string(p, argv, flag, field);
                    break;
        case 'u':   worked = rd_int(p, argv, flag, 10, field);
                    break;
        case 'x':
        case 'X':   worked = rd_int(p, argv, flag | ALLOWSIGN, 16, field);
                    break;
        case '[':   {   int negated = 0, i;
                        unsigned int charmap[8];
                        if ((fch = *fmt++) == '^') negated = 1, fch = *fmt++;
                        for (i=0; i<8; i++) charmap[i] = 0;
                        /* the 'do' next allows special treatment of %[]})] */
                        do { if (fch==0) return cnt;  /* %[... unterminated */
                             charmap[fch/32] |= 1u<<(fch%32);
                        } while ((fch = *fmt++) != ']');
                        if (negated) for (i=0; i<8; i++)
                            charmap[i] = ~charmap[i];
                        worked = rd_string_map(p, argv, flag, field, charmap);
                    }
                    break;
                }
                if (worked < 0)                  /* conversion failed       */
                     return worked == CVTEOF && cnt == 0 ? EOF : cnt;
                if (!(flag & NOSTORE)) cnt++;    /* another assignment made */
                charcount += worked;             /* chars were read anyway  */
                continue;
            }
        }
    }
}

int fscanf(FILE *fp, const char *fmt, ...)
{
    va_list a;
    int n;
    va_start(a, fmt);
    n = vfscanf(fp, fmt, a);
    va_end(a);
    return n;
}

int scanf(const char *fmt, ...)
{
    va_list a;
    int n;
    va_start(a, fmt);
    n = vfscanf(stdin, fmt, a);
    va_end(a);
    return n;
}

int vscanf(const char *fmt, va_list a)
{
    return vfscanf(stdin, fmt, a);
}

typedef struct __extradata {
  /*
   * BODGE BODGE BODGE BODGE
   * This structure is copied from c.stdio
   */
  unsigned char __a[2];
  long __b;
  unsigned char *__c;
  int __d;
  int __e;
  int __f;
#ifdef SUPPORT_WIDE
  int __g;
  mbstate_t __h;
#endif
} _extradata, *_extradatap;

int vsscanf(const char *buff, const char *fmt, va_list a)
{
/*************************************************************************/
/* Note that this code interacts in a dubious way with the getc macro.   */
/* Also ungetc.                                                          */
/*************************************************************************/

    FILE hack;
    _extradata extra;
    _extradatap extrap = &extra;
    int n;
    memclr(&hack, sizeof(FILE));
    memclr(extrap, sizeof(_extradata));
    hack.__flag = _IOSTRG+_IOREAD;
    hack.__ptr = hack.__base = (unsigned char *)buff;
    hack.__icnt = strlen(buff);
    hack.__extrap = extrap;
    n = vfscanf(&hack, fmt, a);
    return n;
}

int sscanf(const char *buff, const char *fmt, ...)
{
    va_list a;
    int n;
    va_start(a, fmt);
    n = vsscanf(buff, fmt, a);
    va_end(a);
    return n;
}

double strtod(const char *nptr, char **endptr)
{
    double d;
    int nchars, res;
/* Here I rely on scanf to set errno to ERANGE if the converted value is */
/* too big or too small.                                                 */
    res = sscanf(nptr, "%lf%n", &d, &nchars);
/* If the conversion failed that must be because there were no digits at */
/* all in the input.                                                     */
    if (res==EOF || res<1)
    {   if (endptr!=NULL) *endptr = (char *)nptr;
        return 0.0;
    }
    if (endptr!=NULL) *endptr = (char *)nptr + nchars;
    return d;
}

float strtof(const char *nptr, char **endptr)
{
    float f;
    int nchars, res;
/* Here I rely on scanf to set errno to ERANGE if the converted value is */
/* too big or too small.                                                 */
    res = sscanf(nptr, "%f%n", &f, &nchars);
/* If the conversion failed that must be because there were no digits at */
/* all in the input.                                                     */
    if (res==EOF || res<1)
    {   if (endptr!=NULL) *endptr = (char *)nptr;
        return 0.0F;
    }
    if (endptr!=NULL) *endptr = (char *)nptr + nchars;
    return f;
}

static unsigned long int _strtoul(const char *nsptr, char **endptr, int base)
{
    const unsigned char *nptr = (const unsigned char *)nsptr;  /* see scanf */
    int c, ok = 0, overflowed = 0;
    while ((c = *nptr++)!=0 && isspace(c));
    if (c=='0')
    {   ok = 1;
        c = *nptr++;
        if (c=='x' || c=='X')
        {   if (base==0 || base==16)
            {   ok = 0;
                base = 16;
                c = *nptr++;
            }
        }
        else if (base==0) base = 8;
    }
    if (base==0) base = 10;
    {   unsigned long dhigh = 0, dlow = 0;
        int digit;
        while ((digit = ch_val(c,base)) >= 0)
        {   ok = 1;
            dlow = base * dlow + digit;
            dhigh = base * dhigh + (dlow >> 16);
            dlow &= 0xffff;
            if (dhigh >= 0x10000) overflowed = 1;
            c = *nptr++;
        }
        if (endptr) *endptr = ok ? (char *)nptr-1 : (char *)nsptr;
                                                /* extra result */
        return overflowed ? (errno = ERANGE, ULONG_MAX)
                          : (dhigh << 16) | dlow;
    }
}

static unsigned long long int _strtoull(const char *nsptr, char **endptr, int base)
{
    const unsigned char *nptr = (const unsigned char *)nsptr;  /* see scanf */
    int c, ok = 0, overflowed = 0;
    while ((c = *nptr++)!=0 && isspace(c));
    if (c=='0')
    {   ok = 1;
        c = *nptr++;
        if (c=='x' || c=='X')
        {   if (base==0 || base==16)
            {   ok = 0;
                base = 16;
                c = *nptr++;
            }
        }
        else if (base==0) base = 8;
    }
    if (base==0) base = 10;
    {   unsigned long long dhigh = 0, dlow = 0;
        int digit;
        while ((digit = ch_val(c,base)) >= 0)
        {   ok = 1;
            dlow = base * dlow + digit;
            dhigh = base * dhigh + (dlow >> 32);
            dlow &= 0xffffffff;
            if (dhigh >= 0x100000000) overflowed = 1;
            c = *nptr++;
        }
        if (endptr) *endptr = ok ? (char *)nptr-1 : (char *)nsptr;
                                                /* extra result */
        return overflowed ? (errno = ERANGE, ULLONG_MAX)
                          : (dhigh << 32) | dlow;
    }
}

long int strtol(const char *nsptr, char **endptr, int base)
{
/* The specification in the ANSI information bulletin upsets me here:    */
/* strtol is of type long int, and 'if the correct value would cause     */
/* overflow LONG_MAX or LONG_MIN is returned'. Thus for hex input the    */
/* string 0x80000000 will be considered to have overflowed, and so will  */
/* be returned as LONG_MAX.                                              */
/* These days one should use strtoul for unsigned values, so some of     */
/* my worries go away.                                                   */

/* This code is NOT shared with the %i conversion in scanf for several   */
/* reasons: (a) here I deal with overflow in a silly way as noted above, */
/* (b) in scanf I have to deal with field width limitations, which does  */
/* not fit in neatly here (c) this functions scans an array of char,     */
/* while scanf reads from a stream - fudging these together seems too    */
/* much work, (d) here I have the option of specifying the radix, while  */
/* in scanf there seems to be no provision for that. Ah well!            */

    const unsigned char *nptr = (const unsigned char *)nsptr;  /* see scanf */
    int flag = 0, c;
    while ((c = *nptr++)!=0 && isspace(c));
    switch (c)
    {
case '-': flag |= NUMNEG;
          /* drop through */
case '+': break;
default:  nptr--;
          break;
    }
    {   char *endp;
        unsigned long ud = _strtoul((char *)nptr, &endp, base);
        if (endptr) *endptr = endp==(char *)nptr ? (char *)nsptr : endp;
/* The following lines depend on the fact that unsigned->int casts and   */
/* unary '-' cannot cause arithmetic traps.  Recode to avoid this?       */
        if (flag & NUMNEG)
            return (-(long)ud <= 0) ? -(long)ud : (errno = ERANGE, LONG_MIN);
        else
            return (+(long)ud >= 0) ? +(long)ud : (errno = ERANGE, LONG_MAX);
    }
}

unsigned long int strtoul(const char *nsptr, char **endptr, int base)
{
    const unsigned char *nptr = (const unsigned char *)nsptr;  /* see scanf */
    int flag = 0, c;
    int errno_saved = errno;
    while ((c = *nptr++)!=0 && isspace(c));
    switch (c)
    {
case '-': flag |= NUMNEG;
          /* drop through */
case '+': break;
default:  nptr--;
          break;
    }
    errno = 0;
    {   char *endp;
        unsigned long ud = _strtoul((char *)nptr, &endp, base);
        if (endptr) *endptr = endp==(char *)nptr ? (char *)nsptr : endp;
        if (errno == ERANGE) return ud;
        errno = errno_saved;
        if (flag & NUMNEG)
            return -ud;
        else
            return +ud;
    }
}

long long int strtoll(const char * restrict nsptr,
                      char ** restrict endptr, int base)
{
/* This code is NOT shared with the %i conversion in scanf for several   */
/* reasons: (a) here I deal with overflow in a silly way as noted above, */
/* (b) in scanf I have to deal with field width limitations, which does  */
/* not fit in neatly here (c) this functions scans an array of char,     */
/* while scanf reads from a stream - fudging these together seems too    */
/* much work, (d) here I have the option of specifying the radix, while  */
/* in scanf there seems to be no provision for that. Ah well!            */

    const unsigned char *nptr = (const unsigned char *)nsptr;  /* see scanf */
    int flag = 0, c;
    while ((c = *nptr++)!=0 && isspace(c));
    switch (c)
    {
case '-': flag |= NUMNEG;
          /* drop through */
case '+': break;
default:  nptr--;
          break;
    }
    {   char *endp;
        unsigned long long ud = _strtoull((char *)nptr, &endp, base);
        if (endptr) *endptr = endp==(char *)nptr ? (char *)nsptr : endp;
/* The following lines depend on the fact that unsigned->int casts and   */
/* unary '-' cannot cause arithmetic traps.  Recode to avoid this?       */
        if (flag & NUMNEG)
            return (-(long long)ud <= 0) ? -(long long)ud : (errno = ERANGE, LLONG_MIN);
        else
            return (+(long long)ud >= 0) ? +(long long)ud : (errno = ERANGE, LLONG_MAX);
    }
}

unsigned long long int strtoull(const char * restrict nsptr,
                                char ** restrict endptr, int base)
{
    const unsigned char *nptr = (const unsigned char *)nsptr;  /* see scanf */
    int flag = 0, c;
    int errno_saved = errno;
    while ((c = *nptr++)!=0 && isspace(c));
    switch (c)
    {
case '-': flag |= NUMNEG;
          /* drop through */
case '+': break;
default:  nptr--;
          break;
    }
    errno = 0;
    {   char *endp;
        unsigned long long ud = _strtoull((char *)nptr, &endp, base);
        if (endptr) *endptr = endp==(char *)nptr ? (char *)nsptr : endp;
        if (errno == ERANGE) return ud;
        errno = errno_saved;
        if (flag & NUMNEG)
            return -ud;
        else
            return +ud;
    }
}

#if INTMAX_MAX != LLONG_MAX || INTMAX_MIN != LLONG_MIN
#error New strtoimax needed
#endif
intmax_t strtoimax(const char * restrict nsptr,
                   char ** restrict endptr, int base)
{
    return strtoll(nsptr, endptr, base);
}

#if UINTMAX_MAX != ULLONG_MAX
#error New strtoumax needed
#endif
uintmax_t strtoumax(const char * restrict nsptr,
                    char ** restrict endptr, int base)
{
    return strtoull(nsptr, endptr, base);
}


double atof(const char *nptr)
{
    int save_errno = errno;
    double res = strtod(nptr, (char **)NULL);
    errno = save_errno;
    return res;
}

int atoi(const char *nptr)
{
    int save_errno = errno;
    long int res = strtol(nptr, (char **)NULL, 10);
    errno = save_errno;
    return (int)res;
}

long int atol(const char *nptr)
{
    int save_errno = errno;
    long int res = strtol(nptr, (char **)NULL, 10);
    errno = save_errno;
    return res;
}

long long int atoll(const char *nptr)
{
    int save_errno = errno;
    long long int res = strtoll(nptr, (char **)NULL, 10);
    errno = save_errno;
    return res;
}

/* end of scanf.c */
@


4.8
log
@Build fix
s/h_brazil: use Hdr:System instead of GETting them one at a time
c/scanf: type cast

Version 5.77. Tagged as 'RISC_OSLib-5_77'
@
text
@d793 1
a793 1
                             charmap[fch/32] |= 1uL<<(fch%32);
@


4.7
log
@Fix to scanf of a scanlist where no match occurs
In this situation, the conversion should fail.
Fixes ticket #252.

Version 5.76. Tagged as 'RISC_OSLib-5_76'
@
text
@d605 1
a605 1
        }
d641 1
a641 1
                              int charmap[])
d787 2
a788 1
        case '[':   {   int negated = 0, i, charmap[8];
@


4.6
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@d638 2
a639 2
/* Ambiguity in Oct 86 ANSI draft: can "%[x]" match a zero-length string?  */
/* p119 line 19 suggests no, p121 example suggests yes.  Treat as yes here */
d647 1
a647 1
    while (field > 0 && ch != EOF && (charmap[ch/32] & (1<<(ch%32))) != 0)
d653 1
d792 1
a792 1
                             charmap[fch/32] |= 1<<(fch%32);
@


4.5
log
@<ctype.h> * isblank() added.
          * isprint() now true for non-breaking spaces
<math.h>  * FP_INFINITY corrected to FP_INFINITE
          * fma(), fmal(), llrint(), llrintf(), llrintl(),
            llround(), llroundf(), llroundl(),
            remquo(), remquof(), remquol() added.
          * added inlining for remainder() and fmaf() and various
            float functions.
          * math_errhandling removed pending overhaul - it was misleading.
          * expm1() and log1p() now provide decent (< 1 ulp) accuracy,
            rather than only being marginally better than exp(x)-1 and
            log(1+x).
          * new version of copysign() with standard calling conventions.
          * some C99 functions changed to use infinity/NaNs and exceptions
            for error handling - see comments in header file about the
            changes in progress.
<stdio.h>  * output from %a now correctly rounded
<stdlib.h> * strtof() and strtold() added.
<string.h> * strerror() no longer clears _kernel_last_oserror().

Version 5.49. Tagged as 'RISC_OSLib-5_49'
@
text
@d845 4
@


4.4
log
@Added atoll, strtoll, strtoull, strtoimax, strtoumax, imaxabs and imaxdiv
functions to the standard C library.

Version 5.45. Tagged as 'RISC_OSLib-5_45'
@
text
@a888 1
        /* the cast is needed in prev. line.  See May 86 ANSI draft 3.2.2.4 */
d893 17
@


4.3
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@d36 1
d931 35
a1007 4
/*
 * I don't think the way negation is treated in this is right, but its closer
 *  than before
 */
a1024 2
/* ??? The following lines depend on the fact that unsigned->int casts and   */
/* ??? unary '-' cannot cause arithmetic traps.  Recode to avoid this?       */
d1028 65
a1092 2
          return (ud <= LONG_MAX) ? -(unsigned long)ud : (errno = ERANGE, ULONG_MAX);
        else return +(unsigned long)ud;
d1096 18
d1135 8
@


4.2
log
@Added the following C99 features:

  * snprintf(), vsnprintf(), vfscanf(), vscanf(), vsscanf()
  * hh, j, z and t printf length modifiers (indicating char, intmax_t, size_t
    and ptrdiff_t respectively)
  * Hexadecimal floating-point printing and scanning (%a/%A)
  * %F printf() specifier (upper-case form of %F)
  * Input/output of NaNs and Infinities
  * imaxdiv_t, imaxdiv(), strtoimax(), strtoumax() (simulated through macros)
  * <fenv.h>: feclearexcept(), fegetexceptflag(), feraiseexcept(),
              fesetexceptflag(), fetestexcept(), fegetround(), fesetround(),
              fegetenv(), feholdexcept(), fesetenv(), feupdateenv()
  * FLT_EVAL_METHOD, DECIMAL_DIG
  * hypot(), hypotf(), fabsf(), fdim(), fdimf(), fmax(), fmaxf(), fmin(),
    fminf()
  * INFINITY, NAN, fpclassify(), isfinite(), isinf(), isnan(), isnormal(),
    signbit(), copysign(), copysignf(), nan(), nanf(), nextafter(),
    nextafterf() isgreater(), isgreaterequal(), isless(), islessequal(),
    islessgreater(), isunordered()

This involves adding 36 new entries to the stubs. Current versions of the C
library will not fault client programs with such larger stubs, but will fill
in the extra entries with junk. Programs requiring the new functions will have
to RMEnsure this version of the Shared C Library.

This version of the C library has been fixed so that in future, any extra
unknown stubs entries will be filled in with a branch to zero, rather than
corrupted.

Requires cc 5.41 or later, both to build, and to make use of some of the extra
facilities.


Version 5.37. Tagged as 'RISC_OSLib-5_37'
@
text
@d59 1
d66 1
d102 1
a102 1
    unsigned long int n = 0;
d137 1
a137 1
      { long int m = flag & NUMNEG ? -n : n;
d141 2
a142 1
        else if isLONG_(flag) *(long *)p = m;
d149 3
a151 2
        if isSHORT_(flag) *(unsigned short *)p = (unsigned short)n;
        else if isLONG_(flag) *(unsigned long *)p = n;
d706 5
a710 1
                if (fch == 'l') fch = *fmt++, flag |= LONG;
d716 2
a717 1
                else if (fch == 'j' || fch == 'z' || fch == 't') fch = *fmt++;
d770 1
@


4.1
log
@Initial revision
@
text
@d43 1
d58 1
d67 1
d137 2
a138 1
        if isSHORT_(flag) *(short *)p = (short)m;
d145 1
a155 1
#ifdef IBMFLOAT
d158 105
a262 8
/* Maybe in scanf I should ROUND rather than TRUNCATE here...            */
    static const int amax = 0x7fffffff, amin = 0xffffffff;
    if (l >= (double)*(float *)&amax ||
        l <= (double)*(float *)&amin) return (float)l;
    else                                  /* above line avoids overflow  */
    {   float f = (float) l;              /* narrower version            */
        double lost = l - (double)f;      /* amount that was chopped off */
        return (float)(l + +(lost + lost));
a264 1
#else /* IBMFLOAT */
d266 46
a311 18
static float carefully_narrow(double l)
/* All the trouble I went to to detect potential overflow has to be re-  */
/* done here so that underflow and overflow do not occur during the      */
/* narrowing operation that is about to be done.                         */
/* *********** machine dependent code ************* (should not go here) */
    {   int w;
        (void)frexp(l, &w);     /* extract exponent */
        w = w + 0x7e;           /* exponent for single precision version */
        if (w<=0 && l!=0.0)
        {   errno = ERANGE;
            return 0.0f;
        }
        else if (w >= 0xff)
/* Overflow of single-precision values - fudge single precision infinity */
/* *********** machine dependent code ************* (should not go here) */
        {   static int posinf = 0x7f800000, neginf = 0xff800000;
            errno = ERANGE;
            return *(float *)(l >= 0.0 ? &posinf : &neginf);
d313 2
a314 1
        else return (float)l;  /* what we really wanted to do */
d316 9
a324 1
#endif /* IEEE */
d331 1
a331 1
    int ch, x = 0;
d345 16
d364 1
a364 1
        else if (isdigit(ch))
d369 1
a369 1
                a[2] = (a[2]<<4) | scanf_intofdigit(ch);
d372 4
a375 1
            else if (!(flag & DOTSEEN)) x += 1;
d380 1
d382 2
a383 1
    if (field > 0 && (ch == 'e' || ch == 'E') && (flag & NUMOK))
d401 2
a402 1
    if (a[0]==0 && a[1]==0 && a[2]==0) l = 0.0;
d436 1
d652 1
a652 2
/* It seems amazing that vfscanf is not available externally in ANSI */
static int vfscanf(FILE *p, const char *sfmt, va_list argv)
d704 5
a708 1
                else if (fch == 'h') fch = *fmt++, flag |= SHORT;
d742 1
d745 2
d758 2
a759 1
        case 'n':   if isSHORT_(flag) *va_arg(argv, short *) = (short)charcount;
d766 1
a766 1
        case 'p':   worked = rd_int(p, argv, flag & ~(LONG|SHORT), 16, field);
d818 5
d836 1
a836 1
int sscanf(const char *buff, const char *fmt, ...)
a842 1
    va_list a;
a846 1
    va_start(a, fmt);
d854 9
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

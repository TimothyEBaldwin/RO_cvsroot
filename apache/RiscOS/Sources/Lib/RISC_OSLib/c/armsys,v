head	4.22;
access;
symbols
	RISC_OSLib-5_97:4.22
	RISC_OSLib-5_96:4.22
	RISC_OSLib-5_95:4.21
	RISC_OSLib-5_94:4.21
	RISC_OSLib-5_93:4.21
	RISC_OSLib-5_92:4.21
	RISC_OSLib-5_91:4.21
	RISC_OSLib-5_90:4.21
	RISC_OSLib-5_89:4.21
	RISC_OSLib-5_88:4.21
	RISC_OSLib-5_87:4.21
	RISC_OSLib-5_86-1:4.21
	RISC_OSLib-5_86:4.21
	RISC_OSLib-5_85:4.20
	RISC_OSLib-5_84:4.20
	RISC_OSLib-5_83-2:4.19
	RISC_OSLib-5_83-1:4.19
	RISC_OSLib-5_83:4.19
	RISC_OSLib-5_82:4.19
	RISC_OSLib-5_81:4.19
	RISC_OSLib-5_75-2:4.18
	RISC_OSLib-5_80:4.19
	RISC_OSLib-5_79:4.19
	RISC_OSLib-5_78:4.19
	RISC_OSLib-5_75-1:4.18
	RISC_OSLib-5_77:4.18
	RISC_OSLib-5_76:4.18
	RISC_OSLib-5_75:4.18
	RISC_OSLib-5_74:4.18
	RISC_OSLib-5_73:4.18
	RISC_OSLib-5_72:4.18
	RISC_OSLib-5_71:4.17
	RISC_OSLib-5_70:4.17
	RISC_OSLib-5_69:4.17
	RISC_OSLib-5_68:4.17
	RISC_OSLib-5_67:4.16
	RISC_OSLib-5_66:4.16
	RISC_OSLib-5_65:4.16
	RISC_OSLib-5_64:4.15
	RISC_OSLib-5_63:4.14
	RISC_OSLib-5_62:4.14
	RISC_OSLib-5_61:4.14
	RISC_OSLib-5_60:4.14
	RISC_OSLib-5_59:4.14
	RISC_OSLib-5_58:4.14
	RISC_OSLib-5_57:4.14
	RISC_OSLib-5_56:4.14
	RISC_OSLib-5_55:4.14
	RISC_OSLib-5_54:4.14
	RISC_OSLib-5_53:4.14
	RISC_OSLib-5_52:4.14
	RISC_OSLib-5_51:4.14
	RO_5_07:4.14
	RISC_OSLib-5_50:4.14
	RISC_OSLib-5_49:4.14
	RISC_OSLib-5_46-4_64_2_1:4.13
	NoInlineAsm:4.13.0.2
	RISC_OSLib-5_48:4.14
	RISC_OSLib-5_47:4.13
	RISC_OSLib-5_46:4.13
	RISC_OSLib-5_45:4.12
	RISC_OSLib-5_44:4.12
	RISC_OSLib-5_43:4.11
	RISC_OSLib-5_42:4.11
	RISC_OSLib-5_41:4.11
	RISC_OSLib-5_40:4.11
	RISC_OSLib-5_39:4.11
	RISC_OSLib-5_38:4.11
	RISC_OSLib-5_37:4.11
	RISC_OSLib-5_36:4.11
	RISC_OSLib-5_35:4.11
	RISC_OSLib-5_34:4.10
	RISC_OSLib-5_33-4_50_2_1:4.9
	sbrodie_dev:4.9.0.2
	sbrodie_dev_bp:4.9
	RISC_OSLib-5_33:4.9
	RISC_OSLib-5_32:4.9
	RISC_OSLib-5_31:4.9
	RISC_OSLib-5_30:4.9
	RISC_OSLib-5_29:4.9
	RISC_OSLib-5_28:4.9
	RISC_OSLib-5_27:4.9
	RISC_OSLib-5_26:4.8
	RISC_OSLib-5_25:4.8
	RISC_OSLib-5_24:4.8
	RISC_OSLib-5_01-4_16_2_5:4.4
	RISC_OSLib-5_23:4.8
	RISC_OSLib-5_22:4.8
	RISC_OSLib-5_21:4.8
	RISC_OSLib-5_20:4.8
	RISC_OSLib-5_19:4.7
	RISC_OSLib-5_18:4.7
	RISC_OSLib-5_17:4.7
	RISC_OSLib-5_16:4.7
	RISC_OSLib-5_15:4.6
	dellis_autobuild_BaseSW:4.6
	RISC_OSLib-5_14:4.6
	RISC_OSLib-5_13:4.6
	RISC_OSLib-5_12:4.6
	RISC_OSLib-5_01-4_16_2_4:4.4
	RISC_OSLib-5_11:4.6
	RISC_OSLib-5_01-4_16_2_3:4.4
	RISC_OSLib-5_01-4_16_2_2:4.4
	RISC_OSLib-5_10:4.6
	RISC_OSLib-5_01-4_16_2_1:4.4
	Bethany:4.4.0.4
	RISC_OSLib-5_09:4.6
	RISC_OSLib-5_08:4.6
	RISC_OSLib-5_07:4.6
	RISC_OSLib-5_06:4.6
	RISC_OSLib-4_97-4_12_2_8:4.4.2.2
	RISC_OSLib-5_05:4.5
	RISC_OSLib-5_04:4.5
	sbrodie_sedwards_16Mar2000:4.5
	RISC_OSLib-5_03:4.5
	RISC_OSLib-5_02:4.5
	RISC_OSLib-4_97-4_12_2_7:4.4.2.1
	RISC_OSLib-5_01:4.4
	RISC_OSLib-5_00:4.4
	RISC_OSLib-4_99:4.4
	RISC_OSLib-4_98:4.4
	RISC_OSLib-4_97-4_12_2_6:4.4.2.1
	RISC_OSLib-4_97-4_12_2_5:4.4
	RISC_OSLib-4_97-4_12_2_4:4.4
	RISC_OSLib-4_97-4_12_2_3:4.4
	RISC_OSLib-4_97-4_12_2_2:4.4
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.4
	kbracey_32bit:4.4.0.2
	kbracey_32bit_bp:4.4
	dcotton_autobuild_BaseSW:4.10
	RISC_OSLib-4_97:4.4
	RISC_OSLib-4_96:4.4
	RISC_OSLib-4_95:4.4
	RISC_OSLib-4_94:4.4
	RISC_OSLib-4_93:4.4
	RISC_OSLib-4_92:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	sforrest_daytona_appflash-0_31:4.3
	RISC_OSLib-4_91:4.4
	RISC_OSLib-4_90:4.4
	RISC_OSLib-4_89:4.4
	Ursula_merge:4.2.2.1
	RISC_OSLib-4_88:4.3
	RISC_OSLib-4_87:4.3
	blaughto_daytona_appflash-0_30:4.3
	rmanby_clib-4_86:4.3
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.22
date	2018.06.10.22.59.55;	author jlee;	state Exp;
branches;
next	4.21;
commitid	Gm9P7LGkgxxZWMFA;

4.21
date	2015.06.30.01.16.34;	author jlee;	state Exp;
branches;
next	4.20;
commitid	jvZB6uMyaGIbkory;

4.20
date	2015.04.03.19.21.07;	author rsprowson;	state Exp;
branches;
next	4.19;
commitid	U0s6ekpjDdEE9bgy;

4.19
date	2013.10.24.20.03.49;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	8snV0tcFxVQyiAax;

4.18
date	2012.08.28.20.50.59;	author jlee;	state Exp;
branches;
next	4.17;
commitid	WCYE684PPsgM7miw;

4.17
date	2012.05.28.18.04.02;	author rsprowson;	state Exp;
branches;
next	4.16;
commitid	psVvzYlFFIpQ9w6w;

4.16
date	2011.11.26.13.04.54;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	oqcep4Kpl6STpQIv;

4.15
date	2011.10.28.14.23.17;	author bavison;	state Exp;
branches;
next	4.14;
commitid	hIG6j26y6NoxM7Fv;

4.14
date	2003.11.03.18.53.00;	author bavison;	state Exp;
branches;
next	4.13;

4.13
date	2003.04.15.16.50.23;	author kbracey;	state Exp;
branches;
next	4.12;

4.12
date	2002.11.15.15.00.26;	author kbracey;	state Exp;
branches;
next	4.11;

4.11
date	2002.01.29.16.03.34;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	2001.08.23.13.46.59;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	2001.02.22.13.10.50;	author sbrodie;	state Exp;
branches;
next	4.8;

4.8
date	2000.10.19.12.55.16;	author pskirrow;	state Exp;
branches;
next	4.7;

4.7
date	2000.10.02.14.29.31;	author sbrodie;	state Exp;
branches;
next	4.6;

4.6
date	2000.05.09.14.09.21;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2000.03.07.09.45.14;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.10.01.09.14.12;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	98.08.21.09.42.54;	author rmanby;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.16.51.48;	author nturton;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.24.46;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	99.11.23.13.42.43;	author sbrodie;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	2000.05.09.13.58.35;	author kbracey;	state Exp;
branches;
next	;

4.2.2.1
date	98.03.26.12.14.32;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.24.46;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.39;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.26.54;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.22;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.22
log
@Try and avoid blocking callbacks
Detail:
  The kernel has a 'callback postponement flag' which will be set whenever an X SWI, called from user mode, returns a pointer to an error (and the error block looks like it's in RAM).
  Although this flag will help prevent the error buffer from being overwritten by any errors generated by callbacks, it will also have the effect of blocking Alt-Break and CLib's Escape handler, due to them both being reliant on callbacks.
  Since the flag may persist for a long time, it can be dangerous to leave the OS in this state (the flag can only be cleared by a SWI call from user mode - which may never happen if the program is stuck in a bad state).
  So to combat this, CLib will now make some effort to try and avoid leaving the postponement flag in situations where it shouldn't be needed.
  File changes:
  - c/armsys:
    - Change _sys_flen to return 0 for TTY streams, since calling OS_Args for them isn't going to generate any useful result (previously it was generating an error, causing the postponement flag to be left set on entry to main())
    - Be extra vigilant when entering main() to make sure the callback postponement flag isn't set, just in case other checks don't resolve it
  - kernel/s/k_body:
    - Change CopyError to attempt to clear the callback postponement flag if we suspect it's set. We've just copied the error to our own buffer, so it should be our job to worry about preventing that buffer being prematurely overwritten, not the kernel's.
Admin:
  Tested on BB-xM
  'while (1) {}' (and similar variants) now multitasks in task windows and is no longer unkillable
  Fixes issue reported on forums:
  https://www.riscosopen.org/forum/forums/4/topics/11542#posts-79767


Version 5.96. Tagged as 'RISC_OSLib-5_96'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* armsys.c:  Copyright (C) Codemist Ltd., 1988       */
/* Copyright (C) Acorn Computers Ltd., 1988           */
/* Very ARM (and Brazil & Arthur) specific routines.  */

/* version 11 */

#define __system_io 1                           /* to get at flag bits */
#define _LARGEFILE64_SOURCE /* define 64-bit file pointer stuff in stdio.h */

#include "VersionNum"

#include "hostsys.h"                            /* things like _initio() */
#include "territory.h"
#include "kernel.h"
#include "swis.h"
#include <stdio.h>                              /* for EOF               */
#include <stdlib.h>                             /* for exit()            */
#include <ctype.h>                              /* isprint(), isspace()  */
#include <string.h>                             /* for strlen()          */
#include <time.h>                               /* for clock             */
#include <errno.h>
#include <stdbool.h>

/* IMPORTS */
extern int main(int argc, char **argv);         /* the point of it all   */
extern FILEHANDLE __dup(int new, int old);
extern void _ctype_init(void);
extern int _fprintf_lf(FILE *fp, const char *fmt, ...);
extern int _sprintf(char *buff, const char *fmt, ...);
extern int _sprintf_lf(char *buff, const char *fmt, ...);
extern _kernel_oserror *_kernel_peek_last_oserror(void);

/* HIDDEN EXPORTS */
void _main(char *s, int (*main)(int, char **));
void _backtrace(int why, int *address, _kernel_unwindblock *uwb);
const char *_clib_version(void);
int _sys_msg_1(const char *s, const char *but);
int _desktop_task(void);

#define str(x)  #x
#define xstr(x) str(x)
const char *_clib_version(void)
{
    return LIB_SHARED "C Library vsn " xstr(Module_Version) "/"
    #ifdef __APCS_32
           "32"
    #else
           "R"
    #endif
           " [" __DATE__ "]\n";
}
#undef str
#undef xstr

static int unused[15];

/* timing things... */

/* struct bbctime objects are used to hold bbc/brazil 5-byte timer value -
   conventionally centi-seconds since 1-Jan-1900.
*/

struct bbctime {unsigned int l,h;};

static clock_t _time0;

static clock_t _clock(void)
{   struct bbctime bt;
    _kernel_osword(1, (int *)&bt);
    return bt.l;
}

static void _clock_init(void)   /* private - for initialisation */
{   _time0 = _clock();
}

static void _clock_ignore(clock_t t)
/* ignores ticks from t to now - used to remove terminal input waits */
{   _time0 += (_clock() - _time0) - t;
}

/* Exported... */

clock_t clock(void)
{   return _clock() - _time0;     /* clock runs even if date not set */
}

time_t time(time_t *timer)
{
    /* ISO9899 7.23.1 (1) defines either 'calendar time' or 'local time'           */
    /* Local time is further defined as incorporating timezone and daylight saving */
    /* information, therefore calendar time is implicitly taken to mean UTC.       */
    /* ISO9899 7.23.2.4 (3) this function determines the calendar time.            */
    /* This implementation uses seconds since the UNIX epoch 01-Jan-1970.          */
    time_t result;
    struct bbctime bt, w, w2;

    bt.l = 3;                       /* 'request time' arg */
    _kernel_osword(14, (int *)&bt); /* read time as UTC 5 byte integer  */

    /* to two 3-byte things - for divide */
    w.h = ((bt.h & 255) << 8) | (bt.l >> 24);
    w.l = bt.l & 0xffffff;
    /* turn csecs to secs */
    w2.h = w.h / 100;
    w2.l = ((w.h % 100 << 24) | w.l) / 100;
    /* back to 8 byte binary */
    bt.h = w2.h >> 8;
    bt.l = (w2.h << 24) | w2.l;
    /* normalise to Jan70 instead of Jan00... */
#define secs0070 (((unsigned)86400)*(365*70+17))  /* less than 2^32 */
    if (bt.l < secs0070) bt.h--;
    bt.l -= secs0070;
    /* if high word is non-zero then date is unset/out of unix range... */
    result = bt.h ? -1 : bt.l;

    if (timer) *timer = result;
    return result;
}

/* system dependent I/O routines ... */

/* Riscos has a second distinguished FILEHANDLE value, to indicate that  */
/* a file is a keyboard and/or vdu, which can't be read or written using */
/* Riscos file operations (or at any rate, couldn't when the library was */
/* originally implemented).                                              */
#define TTYHANDLE 0

#define istty(fh) ((fh) == TTYHANDLE)

/*
 * We're a desktop task if we're in user mode, TaskWindow_TaskInfo 0 returns 0 (or an error),
 * and Wimp_ReadSysInfo 3 says we're in the desktop, and Wimp_ReadSysInfo 5 gives us a
 * task handle.
 */
int _desktop_task(void)
{
    _kernel_swi_regs r;
    if (_kernel_processor_mode() & 0xF) return 0;
    r.r[0] = 0;
    if (_kernel_swi(TaskWindow_TaskInfo, &r, &r) || r.r[0])
        return 0;
    r.r[0] = 3;
    _kernel_swi(Wimp_ReadSysInfo, &r, &r);
    if (r.r[0] == 0) return 0;
    r.r[0] = 5;
    _kernel_swi(Wimp_ReadSysInfo, &r, &r);
    return r.r[0];
}

static int _desktop_report(const char *s, const char *but)
{
    _kernel_swi_regs r;
    _kernel_oserror err, *e;
    char *p, *end;
    int flags, h = _desktop_task();
    if (h == 0) return 0;

    flags = 0x102; /* New error, cancel button */

    if ((e = _kernel_last_oserror()) != NULL && s == e->errmess)
    {
        flags |= 2 << 9;
        err = *e;
    }
    else
    {
        while (*s == ' ')
            s++;

        if (s[0] == '*') /* If leading '*'s then make it a serious one */
        {
            while (*s == '*' || *s == ' ') /* Strip off the '*'s */
                s++;
            flags |= 3 << 9;
            err.errnum = 0x1B << 24;
        }
        else
        {
            flags |= 2 << 9;
            err.errnum = 0;
        }

        for (p = err.errmess, end = err.errmess + sizeof err.errmess - 1; p < end && *s >= ' '; )
            *p++ = *s++;

        *p = '\0';
        err.errmess[0] = toupper(err.errmess[0]);
    }
    r.r[0] = h;
    if (_kernel_swi(TaskManager_TaskNameFromHandle, &r, &r) == 0)
        r.r[2] = r.r[0];
    else
        r.r[2] = 0;
    r.r[0] = (int) &err;
    r.r[1] = flags;
    r.r[3] = 0;
    r.r[4] = 1;
    r.r[5] = (int) but;
    if (_kernel_swi(Wimp_ReportError, &r, &r) == 0)
        return r.r[1];
    else
        return 0;
}

bool _sys__assert(const char *s, const char *expr, const char *func, const char *file, int line)
{
    char buffer[252];
    int len, funclen, exprlen, filelen;

    if (!istty(stderr->__file)) return false;

    if (!_desktop_task()) return false;

    if (strlen(s) > 200) return false; /* Be safe */

    len = func ? _sprintf(buffer, s, "", "", "", line)
               : _sprintf(buffer, s, "", "", line);
    funclen = func ? strlen(func) : 0;
    exprlen = strlen(expr);
    filelen = strlen(file);
    if (len + funclen + exprlen + filelen < 251)
    {
        func ? _sprintf(buffer, s, expr, func, file, line)
             : _sprintf(buffer, s, expr, file, line);
    }
    else
    {
        char expr2[200];
        char func2[50];
        char file2[100];

        #define min(a,b) a<b?a:b
        exprlen = min(exprlen, 199);
        funclen = min(funclen, 49);
        filelen = min(filelen, 99);
        filelen = min(filelen, 251-len-funclen-exprlen);
        if (filelen < 0) filelen = 0;
        funclen = min(funclen, 251-len-exprlen-filelen);
        if (funclen < 0) funclen = 0;
        exprlen = min(exprlen, 251-len-funclen-filelen);
        memcpy(expr2, expr, exprlen);
        memcpy(func2, func, funclen);
        memcpy(file2, file, filelen);
        expr2[exprlen]='\0';
        func2[funclen]='\0';
        file2[filelen]='\0';
        func ? _sprintf(buffer, s, expr2, func2, file2, line)
             : _sprintf(buffer, s, expr2, file2, line);
    }
    return _desktop_report(buffer, NULL);
}

static int _error_recursion;
int _sys_msg_1(const char *s, const char *but)
{
    if (istty(stderr->__file))
    {
        int r = _desktop_report(s, but);
        if (r) return r;
    }

    /* write out s carefully for intimate system use.                      */
    if ((stderr->__flag & _IOWRITE) && !_error_recursion)
    {
        _error_recursion = 1;
        fputc('\n', stderr);
        while (*s >= ' ')
            fputc(*s++, stderr);
        fputc('\n', stderr);
        _error_recursion = 0;
    }
    else
    {   _ttywrite((unsigned char *)"\n", 1, 0);
        _ttywrite((unsigned char *)s, strlen(s), 0);
        _ttywrite((unsigned char *)"\n", 1, 0);
    }

    return 0;
}

void _sys_msg(const char *s)
{
    _sys_msg_1(s, NULL);
}

#define LF '\n'
#define CR '\r'

static int isttyname(const char *s)
{   if (s[0] == ':' && (s[1]|0x20) == 't' && (s[2]|0x20) == 't' && s[3] == 0)
        return 1;   /* string specification (:tt) of terminal stream */
    return 0;
}

FILEHANDLE _sys_open(const char *filename, int openmode)
{ /* nasty magic number interface for openmode */
  static const int modtab[6] = { /* r = */ 0x04c, /* r+ = */ 0x0cc,
                                 /* w = */ 0x4cc, /* w+ = */ 0x4cc,
                                 /* a = */ 0x3cc, /* a+ = */ 0x3cc };
  if (isttyname(filename)) return TTYHANDLE;
  else {
    char *name = (char *)filename;                 /*  yuk yuk yuk yuk yuk  */
    FILEHANDLE fh;
    int size = 16 * 1024;                    /* first try for created files */
    int osmode = modtab[(openmode >> 1) & 7];    /* forget the 'b'inary bit */
    _kernel_osfile_block fb;

    /* maybe stamp file with current datestamp */
    if ((openmode & OPEN_T) ||                /* update timestamp requested */
        (openmode & OPEN_W) ||
        (openmode & ~OPEN_B) == OPEN_A)           /* or mode = w, w+, or a */
    {   if (_kernel_osfile(9, name, &fb) == _kernel_ERROR)
        {   if (_kernel_peek_last_oserror()->errnum == 0x108c9)
            {   errno = -1;
                return NONHANDLE;                       /* (Protected disc) */
            }
        }
    }
retry_open:
    fh = _kernel_osfind(osmode & 0xff, name);
    if (osmode <= 0x0cc) {                                       /* r or r+ */
      if (fh == _kernel_ERROR) errno = -1;
      return (fh <= 0) ? NONHANDLE :                           /* not found */
                         fh;
    } else if (fh > 0) {
      if ((osmode == 0x4cc) || (size == 0))
          if (_kernel_osargs(3, fh, 0) == _kernel_ERROR) {
              _kernel_osfind(0, (char *)fh);
              errno = -1;
              return NONHANDLE;
          }
      return fh;
    } else if (fh <= 0) {
        /* _kernel_osfile(11) creates an empty file of size 'size', of type */
        /* given by fb.load, stamped with the current date & time           */
      fb.load = (openmode & 1) ? 0xffd : 0xfff;              /* data : text */
      fb.start = 0;
      for (; ; size >>= 1) {
        if (size < 512) { errno = -1; return NONHANDLE; }
        fb.end = size;
        if (_kernel_osfile(11, name, &fb) > 0) break;
      }
      size = 0;
      goto retry_open;
    }
    if (fh == _kernel_ERROR) errno = -1;
    return NONHANDLE;
  }
}

int _sys_istty(FILE *stream)
{
    return istty(stream->__file);
}

int _sys_seek(FILEHANDLE fh, off64_t pos)
{
    if istty(fh) return 0;
#if 1
    /* Can't use _kernel_osargs, even for 32-bit file pointers, because it can't handle files of size 4G-2 .*/
    /* Use _kernel_swi instead so that _kernel_last_oserror is set up on failure like it always was. */
    _kernel_swi_regs r;
    r.r[0] = 1;
    r.r[1] = fh;
    r.r[2] = (unsigned int) pos;
    if (_kernel_swi(OS_Args, &r, &r) != NULL)
    {
        errno = -1;
        return _kernel_ERROR;
    }
    return 0;
#else
    {   int rc = _kernel_osargs(1, fh, (int)pos);
        if (rc == _kernel_ERROR) errno = -1;
        return rc;
    }
#endif
}

off64_t _sys_flen(FILEHANDLE fh)
{
    if istty(fh) return 0;
#if 1
    /* Can't use _kernel_osargs, even for 32-bit file pointers, because it can't handle files of size 4G-2 .*/
    /* Use _kernel_swi instead so that _kernel_last_oserror is set up on failure like it always was. */
    _kernel_swi_regs r;
    r.r[0] = 2;
    r.r[1] = fh;
    if (_kernel_swi(OS_Args, &r, &r) != NULL)
    {
        errno = -1;
        return _kernel_ERROR;
    }
    return (unsigned int) r.r[2];
#else
    int rc = _kernel_osargs(2, fh, 0);
    if (rc == _kernel_ERROR) errno = -1;
    return rc;
#endif
}

int _sys_write(FILEHANDLE fh, const unsigned char *buf, unsigned len, int mode)
{   if (istty(fh))
        return _ttywrite(buf, len, mode);
    else {
        _kernel_osgbpb_block b;
        b.dataptr = (void *)buf;
        b.nbytes = (int)len;
        if (_kernel_osgbpb(2, fh, &b) == _kernel_ERROR) {
            errno = -1;
            return _kernel_ERROR;
        } else
            return b.nbytes;
    }
}

int _sys_read(FILEHANDLE fh, unsigned char *buf, unsigned len, int mode)
{
    if (istty(fh))
        return _ttyread(buf, (int)len, mode);
    else {
        _kernel_osgbpb_block b;
        b.dataptr = (void *)buf;
        b.nbytes = (int)len;
        if (_kernel_osgbpb(4, fh, &b) == _kernel_ERROR) {
            errno = -1;
            return _kernel_ERROR;
        } else
            return b.nbytes;
    }
}

int _sys_ensure(FILEHANDLE fh)
{
    if (istty(fh)) return 0;
    {   int rc = _kernel_osargs(0xFF, fh, 0);
        if (rc == _kernel_ERROR) errno = -1;
        return rc;
    }
}

int _sys_close(FILEHANDLE fh)
{   if (istty(fh)) return 0;
    {   int rc = _kernel_osfind(0, (char *)fh);
        if (rc == _kernel_ERROR) errno = -1;
        return rc;
    }
}

int _ttywrite(const unsigned char *buf, unsigned int len, int flag)
/* behaves like Kgbpb, but outputs to console.                              */
/* if 'flag' has _IOBIN set then LF's ('\n's) do not have CR suffixed.      */
{   while (len-- > 0)
    {   int ch = *buf++;
        if (!(flag & _IOBIN)) {
          if (ch == '\n') {
            if (_kernel_oswrch(LF) < 0) return -1;
            ch = CR;
          } else if (ch < 32 && ch != 0x07 && ch != 0x08 && !isspace(ch)) {
            if (_kernel_oswrch('|') < 0) return -1;
            ch = (ch & 31) | 64;
          }
        }
        if (_kernel_oswrch(ch) < 0) return -1;
    }
    return 0;    /* number of chars unwritten */
}

int _ttyread(unsigned char *buff, int size, int flag)
{
/* behaviour similar to Kgbpb but reads from keyboard, performing local  */
/* edits as necessary.  Control chars echo as ^<upper case>.             */
/* AM: ignore clock ticks while waiting for keyboard                     */
/* If _IOBIN is set return 1st char read with no echo.
 * If _IONBF is set return 1st char read with echo.
 * Else read till CR LF ^D or EOF and return line.  Refuse echo if buffer full.
 */
    int count=0;
    time_t t = clock();
    do
    {   int ch;
        do {
            ch = _kernel_osrdch();
        } while (ch == -27) /* ESCAPE */;
        if (flag & _IOBIN && ch != EOF && ch != _kernel_ERROR)
            buff[count++] = ch;             /* binary - no echo */
        else switch (ch)
        {
case _kernel_ERROR:
case EOF:                                   /* see _osrdch for EOF */
case 0x04:  _clock_ignore(t);               /* ^D */
            return(0x80000000+size-count);
case '\n':                                  /* treat CR as LF */
case '\r':  if(count>=size) continue;
            _kernel_oswrch('\r'); _kernel_oswrch(LF);
            buff[count++] = '\n';
            _clock_ignore(t);
            return(size-count);
case 0x08:                                  /* BS     */
case 0x7f:  if(count!=0)                    /* rubout */
            {   _kernel_oswrch(0x7f);
                if (buff[--count] < ' ') _kernel_oswrch(0x7f);
            }
            break;
case 0x15:  while(count>0)                  /* ctrl-U kills line */
            {   _kernel_oswrch(0x7f);
                if (buff[--count] < ' ') _kernel_oswrch(0x7f);
            }
            break;
default:    if(count>=size) continue;
            if (ch < ' ' && ch != 0x07)
               _kernel_oswrch('|'), _kernel_oswrch(ch | '@@');
            else
               _kernel_oswrch(ch);
            buff[count++] = ch;
            break;
        }
    } while (!(flag & _IOBIN+_IONBF));
    _clock_ignore(t);
    return(size-count);
}

int remove(const char *pathname)
{
    _kernel_osfile_block fb;
    if (_kernel_osfile(6, pathname, &fb) <= 0) return 1;
    return 0;
}

int rename(const char *old, const char *new)
{
    _kernel_swi_regs r;
    r.r[0] = 25;
    r.r[1] = (int) old;
    r.r[2] = (int) new;
    if (_kernel_swi(OS_FSControl, &r, &r)) return 1;
    return 0;
}

void _sys_tmpnam_(char *name, int sig)
{
    if (_kernel_getenv("wimp$scrapdir", name, L_tmpnam-10) != NULL)
      strcpy(name, "$.tmp");
    name += strlen(name);
    sprintf(name, ".x%.8x", sig);
}

static char *_getenv_value;
static size_t _getenv_size;

char *getenv(const char *name)
{
    _kernel_swi_regs r, rout;
    _kernel_oserror *e;

    /* Allocate a buffer of 256 bytes if we don't already have one */
    if (_getenv_value == NULL)
    {
      _getenv_size=256;
      if ( (_getenv_value = _kernel_RMAalloc(_getenv_size)) == NULL)
      {
         _getenv_size = 0;
         return NULL;      /* Could not allocate buffer */
      }
    }

    /* Whilst we keep getting buffer overflow errors, try to extend the buffer
     * a bit and try again.  Note that you CANNOT rely on OS_ReadVarVal returning
     * (NOT length) in R2 since this doesn't work for number or macro variables.
     * It doesn't work.
     */

    r.r[0] = (int) name;
    r.r[3] = 0;
    r.r[4] = 3;
    do {
      /* Try to read into the current buffer */
      r.r[1] = (int) _getenv_value;
      r.r[2] = _getenv_size - 1;   /* Leave one byte in buffer for terminating null to be added later */
      if ((e = _kernel_swi(OS_ReadVarVal, &r, &rout)) != NULL)
      {
          /* What was the error? */
          if (e->errnum != 0x1E4)
              return NULL;   /* It wasn't buffer overflow, so return NULL */

          /* Buffer overflow occurred, so try to reallocate the buffer */
          _kernel_RMAfree(_getenv_value);
          _getenv_value = _kernel_RMAalloc(_getenv_size += 256);
          if (_getenv_value == NULL) {
              _getenv_size = 0;
              return NULL;
          }
      }
    } while (e);

    /* Terminate the value */
    _getenv_value[rout.r[2]] = '\0';

    return _getenv_value;
}

void _terminate_getenv(void)
{
    if (_getenv_value)
        _kernel_RMAfree(_getenv_value);

    _getenv_value = NULL;
}

#ifdef DDE
#define DDEUtils_SetCLSize 0x42581
#define DDEUtils_SetCL     0x42582
#define DDEUtils_FlushCL   0x4258B

static int _cli_limit;
#endif
int system(const char *string)
{
#define CALL  0
#define CHAIN 1
    int rc;
#ifdef DDE
    int type;
    char *cmd_string, *cmd;
    char *s, *t;
    _kernel_swi_regs r;
#endif
    int procmode = _kernel_processor_mode() & 0xF; /* Privileged mode iff procmode != 0 */
    if (string==NULL) return (procmode == 0);
    if (procmode != 0) return -2;
#ifdef DDE
    type = CALL;
#endif
    if ((string[0] | 0x20)=='c') {
      char c = string[1] | 0x20;
      if (c=='a') {
        if ((string[2] | 0x20)=='l' && (string[3] | 0x20)=='l' &&
            string[4]==':') string = string+5;
      } else if (c=='h') {
        if ((string[2] | 0x20)=='a' && (string[3] | 0x20)=='i' &&
            (string[4] | 0x20)=='n' && string[5]==':') {
          string = string+6;
#ifdef DDE
          type = CHAIN;
#else
          _lib_shutdown();
          _kernel_system(string, CHAIN);
          /* which never returns */
#endif
        }
      }
    }
#ifdef DDE
    cmd_string = NULL;
    if (strlen(string) >= _cli_limit) {
        s = (char *)string;
        while (*s == ' ') s++;
        cmd = s;
        while (*s > ' ') s++;
        while (*s == ' ') s++;
        r.r[0] = strlen(s) + 1;
        if (!_kernel_swi(DDEUtils_SetCLSize, &r, &r)) {
            r.r[0] = (int)s;
            if (!_kernel_swi(DDEUtils_SetCL, &r, &r)) {
                cmd_string = malloc(s - cmd + 1);
                if (cmd_string) {
                    s = cmd;
                    t = cmd_string;
                    while (*s > ' ') *t++ = *s++;
                    *t++ = 0;
                    string = cmd_string;
                }
            }
        }
    } else {
        _kernel_swi(DDEUtils_FlushCL, &r, &r);
    }
    if (type == CHAIN)
        _lib_shutdown();
    rc = _kernel_system(string, type);
    if (cmd_string != NULL)
        free(cmd_string);
#else
    rc = _kernel_system(string, CALL);
#endif
    if (rc != 0) return rc;
    else
    { char *env;
      env = getenv("Sys$ReturnCode");
      if (env == NULL) return 0;
      else return (atoi(env));
    }
    /* -2 Kernel Fail, 0 = OK. Any other = result code from subprogram exit */
#undef CALL
#undef CHAIN
}

char *decimal_point = ".";

void _armsys_lib_init(void)
{   char *stdinfile  = TTYFILENAME,
         *stdoutfile = TTYFILENAME,
         *stderrfile = TTYFILENAME;
    (void) unused;
    _getenv_value = NULL;
    _error_recursion = 0;
#ifdef DDE
    if ((_kernel_osbyte(129, 0, 255) & 0xFF) >= 0xA8)
        _cli_limit = 1024; /* Ursula long command lines */
    else
        _cli_limit = 256;  /* Pre Ursula shorter ones */
#endif
    _ctype_init();          /* C locale */
    _exit_init();           /* must happen before exit() can be called   */
    _signal_init();         /* had better be done pretty early           */
    _clock_init();          /* set Cpu time zero point                   */
    _init_alloc();          /* as had the allocator                      */
/* SIGINT events are not safe until about now.                           */
    _raise_stacked_interrupts();       /* enable SIGINT                  */
    if (!_kernel_client_is_module())
        _initio(stdinfile, stdoutfile, stderrfile);
}

void _main(char *s, int (*main)(int, char **))
#define LINE_SIZE 256
#define BAD_REDIRECTION {goto bad_redirection;}
#define NO_REDIRECTION goto no_redirection
{   char ch;
    static char **argv;
    static char *args;
    int curarg = 0, in_quotes = 0, was_quoted = 0;
    int after_file_name = 0, redirection = 0;
    int argc = 1, i = 0;
    int pre_digit = 0, dup_arg_1 = 0;
    char mode[2];

    while (s[i] != 0)
    {  while (isspace(s[i])) i++;
       while ((!isspace(s[i])) && s[i] != 0) i++;
       argc++;
    }
    argv = _sys_alloc(argc*sizeof(char *));
    args = _sys_alloc(++i);
    _init_user_alloc();

    i = 0; argc = 0;
    do
    {   ch = *s++;
        if (!in_quotes)
        {   if (ch == '"')
            {   was_quoted = in_quotes = 1;
                ch = *s++;
            }
            else if ((i == curarg) && (!after_file_name))
            {   char *next = s - 1;
                pre_digit = -1; dup_arg_1 = -1;
                mode[0] = 0; mode[1] = 0;
                if (*next >= '0' && *next <= '9') pre_digit = *next++ - '0';
                if ((*next == '>') || (*next == '<'))
                {   if (*next == '>') /* stdout or stderr */
                    {   mode[0] = 'w';
                        if (pre_digit == 0 || pre_digit > 2) BAD_REDIRECTION
                        else if (*++next == '>') { mode[0] = 'a'; next++; }
                    } else
                    {   char *p;
                        next++;
                        for (p = next; (*p != 0) && (*p != ' '); p++)
                            if (*p == '>') NO_REDIRECTION;
                        if (pre_digit > 0) BAD_REDIRECTION
                        mode[0] = 'r';
                    }
                    if (*next == '&')
                    {   if (pre_digit != -1) /* was a preceeding digit */
                        {   if ((pre_digit > 0) &&
                                ((*++next >= '0') && (*next <= '2')) &&
                                (*next++ == (pre_digit % 2 + 1) + '0'))
                            {   /* 2>&1 or 1>&2 */
                                mode[0] = 0; /* no fopen required */
                                dup_arg_1 = pre_digit;
                            } else BAD_REDIRECTION
                        } else /* no preceeding digit */
                        {   next++;
                            dup_arg_1 = 2;
                            pre_digit = (mode[0] != 'r'); /* default = 0 or 1 */                        }
                    }
                    else if (pre_digit == -1)
                        pre_digit = (mode[0] != 'r'); /* default = 0 or 1 */

                    if (mode[0] != 0)
                    {   after_file_name = 1;
                        while (isspace(*next)) next++;
                        if (*next == '"') { in_quotes = 1; next++; }
                    }
                    else if ((*next != 0) && (!isspace(*next)))
                        BAD_REDIRECTION
                    redirection = 1;
                    s = next; ch = *s++;
                }
            }
        }
        if (in_quotes)
        {   if ((ch == '\\') && ((*s == '"') || (*s == '\\')))
                ch = *s++;
            else
                while (ch == '"') {in_quotes = !in_quotes;  ch = *s++;}
        }

no_redirection:
        if (ch != 0 && (in_quotes || !isspace(ch)))
        {   args[i++] = ch;
            continue;
        }
        /* Assert: ((ch == 0) || (isspace(ch) && !in_quotes)) */
        /* ------- possible end of arg ---------------------- */
        if (i != curarg || was_quoted || (redirection && !after_file_name))
        {   /* end of arg */
            args[i++] = 0;
            if (redirection)
            {   if (after_file_name &&
                       freopen(&args[curarg], mode, &__iob[pre_digit]) == 0) {
                    _fprintf_lf(stderr,
                       _kernel_getmessage("can't open '%s' for I/O redirection", "C19"),
                       &args[curarg]);
                    fputc('\n', stderr);
                    exit(EXIT_FAILURE);
                }
                if ((dup_arg_1 > -1) &&
                    (__dup(dup_arg_1, dup_arg_1 % 2 + 1) != TTYHANDLE))
                {   /* data to go to file */
                    FILE *s_new = &__iob[dup_arg_1];
                    FILE *s_old = &__iob[dup_arg_1 % 2 + 1];
                    setvbuf(s_new, _sys_alloc(LINE_SIZE), _IOLBF, LINE_SIZE);
                    s_new->__flag |= _IOSBF;
                    setvbuf(s_old, _sys_alloc(LINE_SIZE), _IOLBF, LINE_SIZE);
                    s_old->__flag |= _IOSBF;
                }
                redirection = 0; after_file_name = 0; i = curarg;
            }
            else
            {   argv[argc++] = &args[curarg];
                curarg = i;
            }
        }
        if (ch != 0) { in_quotes = was_quoted = 0; }
    }
    while (ch != 0);

    if (in_quotes) {
        _fprintf_lf(stderr, _kernel_getmessage("missing double quotes", "C20"));
        fputc('\n', stderr);
        exit(EXIT_FAILURE);
    }

    /* Clear any callback postponement flag in the kernel - otherwise programs which execute no SWIs may be completely uninterruptible */
    _swix(OS_IntOn,0);

    argv[argc] = 0;      /* for ANSI spec */
    exit(/* hmm, relies on lots of things, but fast! */
         (argc > 0 && (*(int *)argv[0] & ~0x20202020) == *(int *)"RUN") ?
              _call_client_2(main, argc-1, argv+1) :
              _call_client_2(main, argc, argv));

bad_redirection:
    _fprintf_lf(stderr,
                _kernel_getmessage("unsupported or illegal I/O redirection '%s'", "C21"),
                --s);
    fputc('\n', stderr);
    exit(EXIT_FAILURE);
#undef NO_REDIRECTION
#undef LINE_SIZE
#undef BAD_REDIRECTION
}

static void p_in(unsigned int pc)
{
    _fprintf_lf(stderr, _kernel_getmessage("%x in ", "C22"), pc);
}

#define ERROR_ILLEGALREAD 0x80800ea0
#define ERROR_ILLEGALWRITE 0x80800ea1

void _backtrace(int why, int *address, _kernel_unwindblock *uwb)
{   /* all the messages in the following should go to stderr             */
    const unsigned int psr_mask = (_kernel_processor_mode() & 0x1C) != 0 ? 0 : 0xFC000003;
    FILE *err = stderr;
    char *lang = _kernel_language(uwb->pc);
    unsigned cl_base, cl_limit;
    _kernel_swi_regs r;

    r.r[0] = 18;
    r.r[1] = (int)"SharedCLibrary";
    cl_base = 0;
    cl_limit = 0;
    if (!_kernel_swi(OS_Module, &r, &r)) {
        cl_base = r.r[3];
        cl_limit = cl_base + *((int *)(cl_base - 4));
    }
    if (why==ERROR_ILLEGALREAD || why == ERROR_ILLEGALWRITE) {
        _fprintf_lf(err, _kernel_getmessage("(address %p)", "C23"), address);
        fputc('\n', err);
    } else {
        fputc('\n', err);
        _fprintf_lf(err, _kernel_getmessage("Postmortem requested", "C24"));
    }
    fputc('\n', err);

/* Now unwind the stack. I keep track of sp here (as well as fp), but for */
/* the moment I make no use of it.                                       */
    while (uwb->fp!=0)
    {   int *z, i, nargs, *argp;
        char *name = 0;
        int *fp = (int *) uwb->fp;
        _kernel_swi_regs r;
        if (lang && (lang[0]=='C') && (lang[1]==0)) {
            z = (int *)(fp[0] &~ psr_mask);
/* Check that when I save pc in a STM instruction it could save PC+8 or  */
/* PC+12 beyond the instruction.                                         */
            r.r[0] = 0;
            if (!_kernel_swi(OS_PlatformFeatures, &r, &r) && (r.r[0] & 8))
                z -= 2;
            else
                z -= 3;
/* If the word before the STM is itself STM sp!, {a1-a4} that shows      */
/* where I should find args, and suggests that there are >= 5.           */
/* (this needs to work whether sp is r12 or r13)                         */
            argp = fp+1;
            if ((*(z-1) & ~0x00010000) ==0xe92c000f) {
                nargs = 5;
            } else {
                int mask = *z & 0xffff;
/* Otherwise args were stored as part of the main STM. Find out where &  */
/* how many.                                                             */
                nargs = 0;
                while (mask != 0)
                {   argp--;
                    if (mask & 0xf) ++nargs;
                    mask ^= mask & (-mask);
                }
            }
/* Print args from the highest one downwards, in hex and decimal         */
            argp += nargs;
            while (nargs!=0) {
                int v = *(--argp);
                int carry;

                _fprintf_lf(err,
                            _kernel_getmessage("  Arg%d: %#.8x %d", "C25"),
                            nargs--, v, v);
/* Indirect through addresses that might be legal...                     */
                if (v && !(v & 3)) {
                    r.r[0] = (int)v;
                    r.r[1] = (int)v + 4 * 4 - 1;
                    if (!_kernel_swi_c(OS_ValidateAddress, &r, &r, &carry)) {
                        if (!carry) {
                            unsigned *vp = (unsigned *)v;

                            fprintf(err, " -> [%#.8x %#.8x %#.8x %#.8x]",
                                    vp[0], vp[1], vp[2], vp[3]);
                        }
                    }
                }
                fputc('\n', err);
            }
/* I search up to 10 words before the STM looking for the marker that    */
/* shows me where the function name is.                                  */
            for (i=0; i<10; i++)
            {   int w = *--z;
                if ((w & 0xffff0000) == 0xff000000)
                {   name = (char *)z - (w & 0xffff);
                    break;
                }
            }
            p_in(uwb->pc & ~psr_mask);
            if (name == 0)
            {   if ((unsigned)z >= cl_base && (unsigned)z < cl_limit)
                    _fprintf_lf(err, _kernel_getmessage("shared library function", "C26"));
                else
                    _fprintf_lf(err, _kernel_getmessage("anonymous function", "C27"));
            }
            else
                _fprintf_lf(err, _kernel_getmessage("function %s", "C28"), name);
        } else {
            p_in(uwb->pc & ~psr_mask);
            if (lang==NULL) {
                _fprintf_lf(err, _kernel_getmessage("unknown procedure", "C29"));
            } else {
                char *procname = _kernel_procname(uwb->pc);
                if (procname!=NULL) {
                    _fprintf_lf(err,
                                _kernel_getmessage("%s procedure %s", "C30"),
                                lang, procname);
                } else {
                    _fprintf_lf(err,
                                _kernel_getmessage("anonymous %s procedure", "C31"),
                                lang);
                }
            }
        }
        fputc('\n', err);
        if (_kernel_unwind(uwb, &lang) < 0) {
            fputc('\n', err);
            _fprintf_lf(err, _kernel_getmessage("stack overwritten", "C32"));
            fputc('\n', err);
            break;
        }
    }
    exit(EXIT_FAILURE);
}

/* end of armsys.c */
@


4.21
log
@Fix null pointer dereference in stack backtrace code
Detail:
  c/armsys - _kernel_language will return NULL if the PC was outside any known library language block, so make sure to check for that before dereferencing the pointer
Admin:
  Builds, untested


Version 5.86. Tagged as 'RISC_OSLib-5_86'
@
text
@d398 1
d870 3
@


4.20
log
@Extend rlib xferrecv API
Add xferrecv_last_ref to get hold of the Wimp message id of the request for a scrap file data save, when the RAM transfer gets no reply. This is useful to allow the data save to be distinguished from a file being dragged to an application, without having to resort to string compares against <wimp$scrap>.
SWIOptions:
 Also add RTC to SWI exports, and remove redundant ones.
armsys.c:
 Treat cmd_string as a pointer.
xferrecv.c/.h/rl_entries:
 New function xferrecv_last_ref.

Version 5.84. Tagged as 'RISC_OSLib-5_84'
@
text
@d926 1
a926 1
        if (lang[0]=='C' && lang[1]==0) {
@


4.19
log
@Some library fixes
Fix for problem passing long command lines via system(), while there are good arguments to leave the threshold at 255, non DDEUtils aware programs get brutally truncated command strings, and since the old threshold of 255 applied when the kernel handled 256 command lines, upping the limit to 1k is no worse than before.
Fix for Edit failing to draw lines of text longer than 192 characters (ticket #350). Several factors were conspiring here: on a mode change the window width in characters wasn't being clamped, whereas user entered limits in the menu were, then the internal buffer ("PAINTBUFSIZE") was too short so lines got truncated, and when larger than 256 got wrapped modulo 256 due to the use of an array of chars. Now set at compile time with BIG_WINDOW_SIZE_LIMIT with a new theoretical maximum of 8192. Currently limited to 480 since it uses stack variables.

In the C library:
 armsys.c: adapt the threshold at which to use DDEUtils based on the kernel version number
 scanf.c: squash a warning
 time.c: mark the table of month lengths as constant so we can claw back 13 words of static workspace without having to change the stubs

In RISC OS lib:
 bbc.c: remove local definitions of some SWI numbers
 template.c: squash a warning
 txt.c: delete Modula-2 support
 txt1.c: compare pointer with NULL not an integer
 txtar.c: introduce BIG_WINDOW_SIZE_LIMIT, rationalise a few sprintf's, mark private functions as static
 txtundo.c/txtedit.c: squash old style function warnings
 txtoptmenu.c: clamp the window width read from Edit$Options properly, delete long disabled code
 txtscrap.c: dead function deleted


Version 5.78. Tagged as 'RISC_OSLib-5_78'
@
text
@d669 1
a669 1
    cmd_string = 0;
d696 1
a696 1
    if (cmd_string)
@


4.18
log
@Fix "Task not known" error masking real error message in some situations
Detail:
  c/armsys - _desktop_report now always caches the error message in the local error block. This avoids the error potentially being overwritten with "Task not known" if TaskManager_TaskNameFromHandle fails.
Admin:
  Tested on Raspberry Pi


Version 5.72. Tagged as 'RISC_OSLib-5_72'
@
text
@d70 1
a70 1
static int unused[3];
d629 2
a631 1

d670 1
a670 1
    if (strlen(string) > 255) {
d722 6
@


4.17
log
@Add locale support for selecting timezones from C
armsys.c
  Ammended time() to match ISO9899 and just return UTC like it says.
  Inlined the single use of _bbctime() macro.
locale.c
  The timezone within a territory can now be specified as part of the setlocale() function.
  This uses a qualifier to the already accepted territory name, for an example see test/tzones.c
  Shock addition of some comments to the locale parsing function.
  To avoid needing to mess about with C library workspace the timezone and territory are encoded internally into 1 word, with 10 bits allowing up to 1024 territories worldwide.
  Ripple through to strftime().
time.c
  localtime() updated to respect locale selection.
test/file,gen_inputs,test64
  Copyright headers added.

Output compared with Windows XP using setlocale versus tzset to shift the program into Pacific time.

Version 5.68. Tagged as 'RISC_OSLib-5_68'
@
text
@d179 1
a203 2

        e = &err;
d210 1
a210 1
    r.r[0] = (int) e;
@


4.16
log
@Review use of StrongARM switch.
Was being used to conditionalise things which aren't really StrongARM related, now should be read as "support split I+D caches" switch.

Version 5.65. Tagged as 'RISC_OSLib-5_65'
@
text
@a79 2
#define _bbctime(bt) _kernel_osword(1, (int *)(bt))

d84 1
a84 1
    _bbctime(&bt);
a102 2
#define unbcd(a) (((a) & 0xf) + 10 * (((a)>>4) & 0xf))

d104 22
a125 30
/* this version gives the UNIX result of secs since 1-Jan-1970 */
{ time_t result;
  /*int mctype;*/
  struct bbctime bt, w, w2;
  unsigned v;
  _kernel_swi_regs r;

  bt.l = 3;                 /* 'request time' arg */
  _kernel_osword(14, (int *)&bt); /* read timer as 5 byte integer  */
  /* OS_Byte 0, 1 returns 6!!! so must look up Utility Module
   * version no. to find version of kernel.
   */
  v = 0;          /* Default to UTC if read timezone fails */
  if (!_kernel_swi(Territory_ReadCurrentTimeZone, &r, &r))
      v = r.r[1]; /* Offset from UTC to current TZ in cs */
  bt.l += v;      /* Unsigned addition */
  if (bt.l < v)   /* Carry == NOT Borrow */
      bt.h++;
  if (v & (1u << 31))
      bt.h--;     /* Sign extend */
/* to two 3-byte things - for divide */
  w.h = ((bt.h & 255) << 8) | (bt.l >> 24);
  w.l = bt.l & 0xffffff;
/* turn csecs to secs */
  w2.h = w.h / 100;
  w2.l = ((w.h % 100 << 24) | w.l) / 100;
/* back to 8 byte binary */
  bt.h = w2.h >> 8;
  bt.l = (w2.h << 24) | w2.l;
/* normalise to Jan70 instead of Jan00... */
d127 4
a130 4
  if (bt.l < secs0070) bt.h--;
  bt.l -= secs0070;
/* if high word is non-zero then date is unset/out of unix range... */
  result = bt.h ? -1 : bt.l;
d132 2
a133 2
  if (timer) *timer = result;
  return result;
@


4.15
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@d934 2
a935 2
/* Note that when I save pc in a STM instruction it points 12 beyond the */
/* instruction, not just 8! Unless it's a StrongARM or similar.          */
@


4.14
log
@  Ansilib improvements, and a bugfix to system()
Detail:
  * _kernel_irqs_disabled() is included in ansilib build, now needed for
    ARM 2 SWP replacement in c.alloc
  * _kernel_entrypoint() for ansilib now initialises relocation offsets in
    root stack chunk, necessary if linking with -zm object code
  * system() implementation now calls DDEUtils_FlushCL if starting a
    short command line - necessary in case previous system() call was a
    long command line directed at a DDE-unaware application
Admin:
  Ansilib changes tested, DDE change not expected to cause problems.

Version 5.47. Not tagged
@
text
@d23 1
d84 1
a84 1
static clock_t _clock()
d90 1
a90 1
static void _clock_init()   /* private - for initialisation */
d101 1
a101 1
clock_t clock()
d110 1
a110 1
  int mctype;
d163 1
a163 1
int _desktop_task()
d385 1
a385 1
int _sys_seek(FILEHANDLE fh, long pos)
d388 14
d406 1
d409 1
a409 1
long _sys_flen(FILEHANDLE fh)
d411 13
d427 1
d731 1
@


4.13
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d611 1
d672 2
@


4.12
log
@ROM build fixed for 64-bit stuff.
PCI added to swis.h
alloc.c updated to handle bigger slots (new code merged from ARM libraries)
Various 32-bit fixes for backtracing, and general trap handling.
Polite "Application is not 32-bit compatible" message.
Headers <stdint.h> and <inttypes.h> fixed to work in non-C99 mode.
txt changed to do new-style Delete behaviour

Version 5.44. Tagged as 'RISC_OSLib-5_44'
@
text
@d43 1
d164 1
a164 1
    int h = 0;
d166 9
a174 6
    _swix(TaskWindow_TaskInfo, _IN(0)|_OUT(0), 0, &h);
    if (h) return 0;
    _swix(Wimp_ReadSysInfo, _IN(0)|_OUT(0), 3, &h);
    if (h == 0) return 0;
    _swix(Wimp_ReadSysInfo, _IN(0)|_OUT(0), 5, &h);
    return h;
d179 1
a180 1
    const char *n = NULL;
d182 1
a182 1
    int flags, r, h = _desktop_task();
d217 14
a230 5
    _swix(TaskManager_TaskNameFromHandle, _IN(0)|_OUT(0), h, &n);

    r = 0;
    _swix(Wimp_ReportError, _INR(0,5)|_OUT(1), e, flags, n, NULL, 1, but, &r);
    return r;
d233 1
a233 1
bool _sys__assert(const char *s, const char *expr, const char *file, int line)
d236 1
a236 1
    int len, exprlen, filelen;
d244 3
a246 1
    len = sprintf(buffer, s, "", "", line);
d249 1
a249 1
    if (len + exprlen + filelen < 251)
d251 2
a252 1
        sprintf(buffer, s, expr, file, line);
d257 1
d262 1
d264 1
a264 1
        filelen = min(filelen, 251-len-exprlen);
d266 3
a268 1
        exprlen = min(exprlen, 251-len-filelen);
d270 1
d273 1
d275 2
a276 1
        sprintf(buffer, s, expr2, file2, line);
@


4.11
log
@Abort and error handling massively overhauled:
  Aborts now give standard error messages (Abort on Data Transfer at... etc)
  *ShowRegs now filled in after aborts
  assert(), abort(), "free failed" and standard signal handlers now use Wimp
    error boxes if in the desktop
  Postmortem button on error boxes to view the postmortem

Also, x$multiply, x$divide, __rt_sdiv, x$remainder, x$udivide, __rt_udiv and
x$uremainder optimised.

Version 5.35. Tagged as 'RISC_OSLib-5_35'
@
text
@d845 1
a845 1
    const unsigned int mask = (_kernel_processor_mode() & 0x1C) != 0 ? 0 : 0xFC000003;
d848 1
a848 1
    int cl_base, cl_limit;
d876 1
a876 1
            z = (int *)(fp[0] & 0x03fffffc);
d911 6
a916 5
                r.r[0] = (int)v;
                r.r[1] = (int)v + 4 * 4 - 1;
                if (!_kernel_swi_c(OS_ValidateAddress, &r, &r, &carry)) {
                    if (!carry && !(v & 3)) {
                        int *vp = (int *)v;
d918 3
a920 2
                        fprintf(err, " -> [%#.8x %#.8x %#.8x %#.8x]",
                                vp[0], vp[1], vp[2], vp[3]);
d934 1
a934 1
            p_in(uwb->pc & ~mask);
d936 1
a936 1
            {   if ((int)z >= cl_base && (int)z < cl_limit)
d944 1
a944 1
            p_in(uwb->pc & ~mask);
@


4.10
log
@* Merged in (via sbrodie's branch) public source release of RISC_OSLib.
* Fixed C library tty so it can output '\b' (backspace).
* Made offsetof() and va_arg() macros work with C++.

Version 5.34. Tagged as 'RISC_OSLib-5_34'
@
text
@d36 1
d44 1
d50 2
d156 102
d259 9
a267 2
void _sys_msg(const char *s)
{   /* write out s carefully for intimate system use.                      */
d282 7
d318 2
a319 3
        {   if (_kernel_last_oserror()->errnum == 0x108c9)
            {   (void)_kernel_osfile(9, name, &fb); /* to restore the error */
                errno = -1;
@


4.9
log
@  fwrite performance improved significantly.
  Another getenv() bug fixed.
Detail:
  stdio.c contains a vastly improved implementation of fwrite.
  hostsys.h declares _terminate_getenv to remove build warnings.
  armsys.c contains fix to getenv() to stop Omni dying.
Admin:
  Tested on desktop machine for over a week without incident, including
    several heavy fwrite users (WebServe, C compiler)
  fwrite change is documented in Doc/fwrite
  getenv() bug is Bugzilla bug #28

Version 5.27. Tagged as 'RISC_OSLib-5_27'
@
text
@d315 1
a315 1
          } else if (ch < 32 && ch != 0x07 && !isspace(ch)) {
@


4.8
log
@  Changed getenv to ensure it always allocates a buffer before calling
  OS_ReadVarVal.

Detail:
  getenv calls OS_ReadVarVal to read a system variable into a buffer.
  If the buffer is not big enough it increases the size of the buffer by
  256 bytes and tries again.
  However, the first time it was called, it would have no buffer and
  would call OS_ReadVarVal with r2=-1. The PRM says this "may" return an error
  which should be ignored, but if it did not return an error then getenv
  would not allocate a buffer and the call would fail.
  This change allocates a 256 byte buffer before OS_ReadVarVal is called.

Admin:
  Untested.

Version 5.20. Tagged as 'RISC_OSLib-5_20'
@
text
@d416 1
a416 1
      if ( (_getenv_value = malloc(_getenv_size)) == NULL)
d443 2
a444 2
          free(_getenv_value);
          _getenv_value = malloc(_getenv_size += 256);
d461 1
a461 1
        free(_getenv_value);
@


4.7
log
@  Uses SYMDEFS files to avoid xtentries(app) and symgen.
  Fixed bug in getenv() relating to macro and numeric system variables.
Detail:
  Uses SYMDEFS file to avoid messing around with generating little text
    files, generating assembler source, assembling it etc.  abssym et al
    are construct as symbol definition template files and then updated
    directly by the linker ready for export.  The linker can use these
    files directly without needing them to be assembled into AOF format.
  Fixed getenv so that it can read macro and numeric variables.  With these
    variable types, R2 does not equal -length of the variable value, so
    trying to obtain a variable with a larger value than any previously
    read variable would fail.  This is now fixed.
  This module will refuse to build without link 5.19 or later.
Admin:
  Requires Library 0.54 or later.

  This component will not build with Library 0.53 or earlier.

Version 5.16. Tagged as 'RISC_OSLib-5_16'
@
text
@d412 11
d428 1
d435 1
a435 1
      r.r[2] = _getenv_size - 1;
d438 1
a438 1
          /* If there was a buffer overflow... */
d440 1
a440 1
              return NULL;
d442 1
a442 1
          /* Try to reallocate the buffer */
@


4.6
log
@32-bit work merged from kbracey_32bit branch.

Version 5.06. Tagged as 'RISC_OSLib-5_06'
@
text
@d412 5
a416 8
    /* Make sure we have an initial buffer of 256 */
    if (_getenv_value == NULL) {
      _getenv_value = malloc(256);
      if (_getenv_value == NULL) return NULL;
      _getenv_size = 256;
    }

    /* Try to read into the current buffer */
a417 2
    r.r[1] = (int) _getenv_value;
    r.r[2] = _getenv_size - 1;
d420 9
a428 17
    if ((e = _kernel_swi(OS_ReadVarVal, &r, &rout)) != NULL)
    {
        /* If there was a buffer overflow... */
        if (e->errnum != 0x1E4)
            return NULL;

        /* ...find out how much space is required */
        r.r[2] = -1;
        _kernel_swi(OS_ReadVarVal, &r, &rout);
        if (rout.r[2] >= 0)
            return NULL;

        /* Try to reallocate the buffer */
        free(_getenv_value);
        _getenv_value = malloc(-rout.r[2]);
        if (_getenv_value == NULL)
            return NULL;
d430 9
a438 7
        /* And read again */
        _getenv_size = -rout.r[2];
        r.r[1] = (int) _getenv_value;
        r.r[2] = _getenv_size - 1;
        if (_kernel_swi(OS_ReadVarVal, &r, &rout) != NULL)
            return NULL;
    }
@


4.5
log
@Changed console output so that '\n' outputs VDU 10,13 rather than 13,10.
This is the standard RISC OS convention (cf OS_NewLine) - some apps assume
it when redirecting output.

Version 5.02. Tagged as 'RISC_OSLib-5_02'
@
text
@a19 3
/* NB to Lee, Alan etc - time() makes delicate tests to see what sort of   */
/* machine it is being used with & may need adjustment as time goes by...  */

d24 2
d52 8
a59 2
{   return  LIB_SHARED "C Library vsn " xstr(__LIB_VERSION) "/" LIB_APCS
            " [" __DATE__ "]\n";
d105 17
a121 57
  switch (mctype = _kernel_hostos())
  {
case 3:
    {   /* This is true if we are on a Master series machine, in which   */
        /* case there is a built-in real time clock to be used.          */
        char bcdclock[28]; /* leave lots of room for _osword() to use    */
        int i;
        bcdclock[0] = 1;        /* read in BCD format */
        _kernel_osword(14, (int *)bcdclock);
        /* convert to natural binary bytes */
        for (i = 0; i<7; i++) bcdclock[i] = unbcd(bcdclock[i]);
        i = bcdclock[0];                                     /* the year */
        if (i < 70) result = -1;  /* ANSI say (time)-1 if indeterminable */
        else
        {   int d = bcdclock[2] - 1, w = bcdclock[1], j;
            static int m[12] = { 31,29,31,30,31,30,31,31,30,31,30,31};
/* Months within the current year                                        */
            for (j = 1; j < w; j++) d += m[j-1];
/* Was this year a leap-year?                                            */
            if ((i & 3) != 0 && w >= 3) d -= 1;
            for (j = 70; j < i; j++)
                if ((j & 3) == 0) d += 366; else d += 365;
/* Now adjust by the number of seconds into that day that we are         */
            result = bcdclock[6] +
                     60 * (bcdclock[5] +
                           60 * (bcdclock[4] + 24 * d));
        }
    }
    break;

#ifdef never   /* I suppose one day the compiler should optimise these out */
case 7: /* Acorn Springboard */
case 1: /* Base level BBC micro - use 5-bit timer & assume set up for this  */
case 6: /* Archimedes */
#endif
default: /* a good a place as any for an unknown machine */
    {   struct bbctime bt, w, w2;
        if (mctype == 6)
        {
            unsigned v;
            _kernel_swi_regs r;

            bt.l = 3;                 /* presumably 'request time' arg */
            _kernel_osword(14, (int *)&bt); /* read timer as 5 byte integer  */
            /* OS_Byte 0, 1 returns 6!!! so must look up Utility Module
             * version no. to find version of kernel.
             */
            v = 0;          /* Default to UTC if read timezone fails */
            if (!_kernel_swi(Territory_ReadCurrentTimeZone, &r, &r))
                v = r.r[1]; /* Offset from UTC to current TZ in cs */
            bt.l += v;      /* Unsigned addition */
            if (bt.l < v)   /* Carry == NOT Borrow */
                bt.h++;
            if (v & (1u << 31))
                bt.h--;     /* Sign extend */
        }
        else _bbctime(&bt);
d123 2
a124 2
        w.h = ((bt.h & 255) << 8) | (bt.l >> 24);
        w.l = bt.l & 0xffffff;
d126 2
a127 2
        w2.h = w.h / 100;
        w2.l = ((w.h % 100 << 24) | w.l) / 100;
d129 2
a130 2
        bt.h = w2.h >> 8;
        bt.l = (w2.h << 24) | w2.l;
d133 2
a134 2
        if (bt.l < secs0070) bt.h--;
        bt.l -= secs0070;
d136 1
a136 5
        result = bt.h ? -1 : bt.l;
    }
    break;

  }
d388 5
a392 7
    char s[255];
    if (strlen(old)+strlen(new) >= 255-8) return 1;  /* tough */
    strcpy(s, "rename ");
    strcpy(&s[7], old);
    strcat(&s[7], " ");
    strcat(&s[8], new);
    if (_kernel_oscli(s) < 0) return 1;
d405 1
d409 46
a454 6
    if (_getenv_value == NULL) _getenv_value = malloc(256);
    if (_getenv_value == NULL ||
        _kernel_getenv(name, _getenv_value, 256) != NULL)
       return NULL;
    else
       return _getenv_value;
d481 3
a483 2
    if (string==NULL) return (_kernel_processor_mode() == 0);
    if (_kernel_processor_mode() != 0) return -2;
d715 1
a715 1
static void p_in(_kernel_unwindblock *uwb)
d717 1
a717 1
    _fprintf_lf(stderr, _kernel_getmessage("%x in ", "C22"), uwb->pc & ~0xfc000003);
d725 1
d812 1
a812 1
            p_in(uwb);
d822 1
a822 1
            p_in(uwb);
@


4.4
log
@Ursula branch merged.
StrongARMfudge flag removed.
StrongARM compatibility set according to AMBKernel flag in Hdr:RISCOS
strftime %U and %W specifiers fixed for week 0.

Version 4.89. Tagged as 'RISC_OSLib-4_89'
@
text
@d211 1
d347 1
a347 1
/* if 'flag' has _IOBIN set then LF's ('\n's) do not have CR prefixed.      */
d352 2
a353 2
            if (_kernel_oswrch('\r') < 0) return -1;
            ch = LF;
@


4.4.2.1
log
@More 32-bit compatibility added.  All the C code should now be OK.
Fixed some typos in kernel.s.k_body too.

Version 4.97, 4.12.2.6. Tagged as 'RISC_OSLib-4_97-4_12_2_6'
@
text
@d480 2
a481 3
    int procmode = _kernel_processor_mode() & 0xF; /* Privileged mode iff procmode != 0 */
    if (string==NULL) return (procmode == 0);
    if (procmode != 0) return -2;
d713 1
a713 1
static void p_in(unsigned int pc)
d715 1
a715 1
    _fprintf_lf(stderr, _kernel_getmessage("%x in ", "C22"), pc);
a722 1
    const unsigned int mask = (_kernel_processor_mode() & 0x1C) != 0 ? 0 : 0xFC000003;
d809 1
a809 1
            p_in(uwb->pc & ~mask);
d819 1
a819 1
            p_in(uwb->pc & ~mask);
@


4.4.2.2
log
@Features:

* APCS-32 support complete.
* APCS-A compatibility removed.
* Old ArthurLib code removed.
* _clib_version() now reports version from VersionNum.
* time() no longer does a run-time host check - I think we know we're not a BBC
  Master ARM second processor now.
* rename() now uses OS_FSControl 25 instead of *rename.
* getenv() can handle arbitrary length variables.
* Can now handle exceptions in 32-bit form of FPEmulator (on either 26 or 32
  bit systems).
* tmpnam() switches to SVC mode to access its zero page counter.
* Faster divide routines.

Admin:

  This will build all sorts of different things depending on the flags. See
  the Docs directory for details.

  As far as ROM builds are concerned, if using APCS-R, no changes are needed.
  If using APCS-32, the Shared C Library must be built as APCS-R to ensure
  compatibility with old binaries. To achieve this, pass in the option
  SCL_APCS="-APCS 3/26bit" in the Components file.

Version 4.97, 4.12.2.8. Tagged as 'RISC_OSLib-4_97-4_12_2_8'
@
text
@d20 3
a26 2
#include "VersionNum"

d53 2
a54 8
{
    return LIB_SHARED "C Library vsn " xstr(Module_Version) "/"
    #ifdef __APCS_32
           "32"
    #else
           "R"
    #endif
           " [" __DATE__ "]\n";
d100 57
a156 17
  struct bbctime bt, w, w2;
  unsigned v;
  _kernel_swi_regs r;

  bt.l = 3;                 /* 'request time' arg */
  _kernel_osword(14, (int *)&bt); /* read timer as 5 byte integer  */
  /* OS_Byte 0, 1 returns 6!!! so must look up Utility Module
   * version no. to find version of kernel.
   */
  v = 0;          /* Default to UTC if read timezone fails */
  if (!_kernel_swi(Territory_ReadCurrentTimeZone, &r, &r))
      v = r.r[1]; /* Offset from UTC to current TZ in cs */
  bt.l += v;      /* Unsigned addition */
  if (bt.l < v)   /* Carry == NOT Borrow */
      bt.h++;
  if (v & (1u << 31))
      bt.h--;     /* Sign extend */
d158 2
a159 2
  w.h = ((bt.h & 255) << 8) | (bt.l >> 24);
  w.l = bt.l & 0xffffff;
d161 2
a162 2
  w2.h = w.h / 100;
  w2.l = ((w.h % 100 << 24) | w.l) / 100;
d164 2
a165 2
  bt.h = w2.h >> 8;
  bt.l = (w2.h << 24) | w2.l;
d168 2
a169 2
  if (bt.l < secs0070) bt.h--;
  bt.l -= secs0070;
d171 5
a175 1
  result = bt.h ? -1 : bt.l;
d426 7
a432 5
    _kernel_swi_regs r;
    r.r[0] = 25;
    r.r[1] = (int) old;
    r.r[2] = (int) new;
    if (_kernel_swi(OS_FSControl, &r, &r)) return 1;
a444 1
static size_t _getenv_size;
d448 6
a453 46
    _kernel_swi_regs r, rout;
    _kernel_oserror *e;

    /* Make sure we have an initial buffer of 256 */
    if (_getenv_value == NULL) {
      _getenv_value = malloc(256);
      if (_getenv_value == NULL) return NULL;
      _getenv_size = 256;
    }

    /* Try to read into the current buffer */
    r.r[0] = (int) name;
    r.r[1] = (int) _getenv_value;
    r.r[2] = _getenv_size - 1;
    r.r[3] = 0;
    r.r[4] = 3;
    if ((e = _kernel_swi(OS_ReadVarVal, &r, &rout)) != NULL)
    {
        /* If there was a buffer overflow... */
        if (e->errnum != 0x1E4)
            return NULL;

        /* ...find out how much space is required */
        r.r[2] = -1;
        _kernel_swi(OS_ReadVarVal, &r, &rout);
        if (rout.r[2] >= 0)
            return NULL;

        /* Try to reallocate the buffer */
        free(_getenv_value);
        _getenv_value = malloc(-rout.r[2]);
        if (_getenv_value == NULL)
            return NULL;

        /* And read again */
        _getenv_size = -rout.r[2];
        r.r[1] = (int) _getenv_value;
        r.r[2] = _getenv_size - 1;
        if (_kernel_swi(OS_ReadVarVal, &r, &rout) != NULL)
            return NULL;
    }

    /* Terminate the value */
    _getenv_value[rout.r[2]] = '\0';

    return _getenv_value;
@


4.3
log
@Fixed an RMA leak.

If a module written in C uses function getenv, buffer space
is allocated in the RMA. This buffer was never freed, leading
to RMA leakage when the module was 'RMKill'ed or 'RMReInit'ed.

Changes

 c.armsys
   added function _terminate_getenv to free the buffer

 c.stdlib
   added flag getenv_finalised to the exit_s structure

   initialised getenv_finalised in function _exit_init

   atexit tests getenv_finalised, calls _terminate_getenv

 s.version
   version string changed to 4.86 (27 Jul 1998)
@
text
@d36 1
d183 8
d220 3
a222 3
  static const int modtab[6] = { /* r = */ 0x040, /* r+ = */ 0x0c0,
                                 /* w = */ 0x4c0, /* w+ = */ 0x4c0,
                                 /* a = */ 0x3c0, /* a+ = */ 0x3c0 };
d232 4
a235 3
    if ((openmode & 16) ||                    /* update timestamp requested */
        (openmode >= 4 && openmode <= 9))          /* or mode = w, w+, or a */
    {   if (_kernel_osfile(9, name, &fb) <0) /* (contents of fb irrelevant) */
d238 1
d245 2
a246 1
    if (osmode <= 0x0c0)                                         /* r or r+ */
d249 2
a250 2
    else if (fh > 0) {
      if ((osmode == 0x4c0) || (size == 0))
d253 1
d257 1
a257 1
    } else if (fh == 0) {
d263 1
a263 1
        if (size < 512) return NONHANDLE;             /* probably Disc Full */
d270 1
d275 70
a344 1
int _ttywrite(unsigned char *buf, unsigned int len, int flag)
@


4.2
log
@Version RO_3_70 taken
@
text
@d373 8
@


4.2.2.1
log
@* RISC_OSLib msgs module now closes its Messages files on exit.
* strerror/perror now call _kernel_last_oserror and use result
  if errno is unknown.
* _sys_open calls error-returning form of OS_Find so
  _kernel_last_oserror can return something meaningful after
  fopen fails
* All file handling calls set errno to -1 if a _kernel_osfind/
  _kernel_osgbpb etc call returns an error
* These three changes mean that the code sequence

         if ((fp = fopen(file, "rb")) == NULL) {
            perror(progname);
            return 1;
         }

  will now say something useful rather than "No error (errno=0)"
  This could now be used by socklib to get perror to work
  with errors generated by the Internet module.
* ANSILib now outputs proper messages, not just tokens.
@
text
@a35 1
#include <errno.h>
a181 8
/* Riscos has a second distinguished FILEHANDLE value, to indicate that  */
/* a file is a keyboard and/or vdu, which can't be read or written using */
/* Riscos file operations (or at any rate, couldn't when the library was */
/* originally implemented).                                              */
#define TTYHANDLE 0

#define istty(fh) ((fh) == TTYHANDLE)

d211 3
a213 3
  static const int modtab[6] = { /* r = */ 0x04c, /* r+ = */ 0x0cc,
                                 /* w = */ 0x4cc, /* w+ = */ 0x4cc,
                                 /* a = */ 0x3cc, /* a+ = */ 0x3cc };
d223 3
a225 4
    if ((openmode & OPEN_T) ||                /* update timestamp requested */
        (openmode & OPEN_W) ||
        (openmode & ~OPEN_B) == OPEN_A)           /* or mode = w, w+, or a */
    {   if (_kernel_osfile(9, name, &fb) == _kernel_ERROR)
a227 1
                errno = -1;
d234 1
a234 2
    if (osmode <= 0x0cc) {                                       /* r or r+ */
      if (fh == _kernel_ERROR) errno = -1;
d237 2
a238 2
    } else if (fh > 0) {
      if ((osmode == 0x4cc) || (size == 0))
a240 1
              errno = -1;
d244 1
a244 1
    } else if (fh <= 0) {
d250 1
a250 1
        if (size < 512) { errno = -1; return NONHANDLE; }
a256 1
    if (fh == _kernel_ERROR) errno = -1;
d261 1
a261 70
int _sys_istty(FILE *stream)
{
    return istty(stream->__file);
}

int _sys_seek(FILEHANDLE fh, long pos)
{
    if istty(fh) return 0;
    {   int rc = _kernel_osargs(1, fh, (int)pos);
        if (rc == _kernel_ERROR) errno = -1;
        return rc;
    }
}

long _sys_flen(FILEHANDLE fh)
{
    int rc = _kernel_osargs(2, fh, 0);
    if (rc == _kernel_ERROR) errno = -1;
    return rc;
}

int _sys_write(FILEHANDLE fh, const unsigned char *buf, unsigned len, int mode)
{   if (istty(fh))
        return _ttywrite(buf, len, mode);
    else {
        _kernel_osgbpb_block b;
        b.dataptr = (void *)buf;
        b.nbytes = (int)len;
        if (_kernel_osgbpb(2, fh, &b) == _kernel_ERROR) {
            errno = -1;
            return _kernel_ERROR;
        } else
            return b.nbytes;
    }
}

int _sys_read(FILEHANDLE fh, unsigned char *buf, unsigned len, int mode)
{
    if (istty(fh))
        return _ttyread(buf, (int)len, mode);
    else {
        _kernel_osgbpb_block b;
        b.dataptr = (void *)buf;
        b.nbytes = (int)len;
        if (_kernel_osgbpb(4, fh, &b) == _kernel_ERROR) {
            errno = -1;
            return _kernel_ERROR;
        } else
            return b.nbytes;
    }
}

int _sys_ensure(FILEHANDLE fh)
{
    if (istty(fh)) return 0;
    {   int rc = _kernel_osargs(0xFF, fh, 0);
        if (rc == _kernel_ERROR) errno = -1;
        return rc;
    }
}

int _sys_close(FILEHANDLE fh)
{   if (istty(fh)) return 0;
    {   int rc = _kernel_osfind(0, (char *)fh);
        if (rc == _kernel_ERROR) errno = -1;
        return rc;
    }
}

int _ttywrite(const unsigned char *buf, unsigned int len, int flag)
@


4.1
log
@Initial revision
@
text
@d660 1
d662 1
a662 1
            z = (int *)((fp[0] & 0x03fffffc) - 12);
d664 6
a669 1
/* instruction, not just 8!                                              */
a689 1
                _kernel_swi_regs r;
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a659 1
        _kernel_swi_regs r;
d661 1
a661 1
            z = (int *)(fp[0] & 0x03fffffc);
d663 1
a663 6
/* instruction, not just 8! Unless it's a StrongARM or similar.          */
            r.r[0] = 0;
            if (!_kernel_swi(OS_PlatformFeatures, &r, &r) && (r.r[0] & 8))
                z -= 2;
            else
                z -= 3;
d684 1
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.9;
access;
symbols
	RISC_OSLib-5_97:4.9
	RISC_OSLib-5_96:4.9
	RISC_OSLib-5_95:4.9
	RISC_OSLib-5_94:4.9
	RISC_OSLib-5_93:4.9
	RISC_OSLib-5_92:4.9
	RISC_OSLib-5_91:4.9
	RISC_OSLib-5_90:4.9
	RISC_OSLib-5_89:4.9
	RISC_OSLib-5_88:4.9
	RISC_OSLib-5_87:4.9
	RISC_OSLib-5_86-1:4.9
	RISC_OSLib-5_86:4.9
	RISC_OSLib-5_85:4.9
	RISC_OSLib-5_84:4.9
	RISC_OSLib-5_83-2:4.9
	RISC_OSLib-5_83-1:4.9
	RISC_OSLib-5_83:4.9
	RISC_OSLib-5_82:4.9
	RISC_OSLib-5_81:4.9
	RISC_OSLib-5_75-2:4.9
	RISC_OSLib-5_80:4.9
	RISC_OSLib-5_79:4.9
	RISC_OSLib-5_78:4.9
	RISC_OSLib-5_75-1:4.9
	RISC_OSLib-5_77:4.9
	RISC_OSLib-5_76:4.9
	RISC_OSLib-5_75:4.9
	RISC_OSLib-5_74:4.9
	RISC_OSLib-5_73:4.9
	RISC_OSLib-5_72:4.9
	RISC_OSLib-5_71:4.9
	RISC_OSLib-5_70:4.9
	RISC_OSLib-5_69:4.9
	RISC_OSLib-5_68:4.9
	RISC_OSLib-5_67:4.9
	RISC_OSLib-5_66:4.9
	RISC_OSLib-5_65:4.9
	RISC_OSLib-5_64:4.9
	RISC_OSLib-5_63:4.8
	RISC_OSLib-5_62:4.8
	RISC_OSLib-5_61:4.8
	RISC_OSLib-5_60:4.8
	RISC_OSLib-5_59:4.8
	RISC_OSLib-5_58:4.8
	RISC_OSLib-5_57:4.8
	RISC_OSLib-5_56:4.8
	RISC_OSLib-5_55:4.8
	RISC_OSLib-5_54:4.8
	RISC_OSLib-5_53:4.8
	RISC_OSLib-5_52:4.8
	RISC_OSLib-5_51:4.7
	RO_5_07:4.7
	RISC_OSLib-5_50:4.7
	RISC_OSLib-5_49:4.7
	RISC_OSLib-5_46-4_64_2_1:4.6
	NoInlineAsm:4.6.0.2
	RISC_OSLib-5_48:4.6
	RISC_OSLib-5_47:4.6
	RISC_OSLib-5_46:4.6
	RISC_OSLib-5_45:4.5
	RISC_OSLib-5_44:4.5
	RISC_OSLib-5_43:4.5
	RISC_OSLib-5_42:4.5
	RISC_OSLib-5_41:4.5
	RISC_OSLib-5_40:4.4
	RISC_OSLib-5_39:4.4
	RISC_OSLib-5_38:4.3
	RISC_OSLib-5_37:4.2
	RISC_OSLib-5_36:4.1
	RISC_OSLib-5_35:4.1
	RISC_OSLib-5_34:4.1
	RISC_OSLib-5_33-4_50_2_1:4.1
	sbrodie_dev:4.1.0.14
	sbrodie_dev_bp:4.1
	RISC_OSLib-5_33:4.1
	RISC_OSLib-5_32:4.1
	RISC_OSLib-5_31:4.1
	RISC_OSLib-5_30:4.1
	RISC_OSLib-5_29:4.1
	RISC_OSLib-5_28:4.1
	RISC_OSLib-5_27:4.1
	RISC_OSLib-5_26:4.1
	RISC_OSLib-5_25:4.1
	RISC_OSLib-5_24:4.1
	RISC_OSLib-5_01-4_16_2_5:4.1
	RISC_OSLib-5_23:4.1
	RISC_OSLib-5_22:4.1
	RISC_OSLib-5_21:4.1
	RISC_OSLib-5_20:4.1
	RISC_OSLib-5_19:4.1
	RISC_OSLib-5_18:4.1
	RISC_OSLib-5_17:4.1
	RISC_OSLib-5_16:4.1
	RISC_OSLib-5_15:4.1
	dellis_autobuild_BaseSW:4.1
	RISC_OSLib-5_14:4.1
	RISC_OSLib-5_13:4.1
	RISC_OSLib-5_12:4.1
	RISC_OSLib-5_01-4_16_2_4:4.1
	RISC_OSLib-5_11:4.1
	RISC_OSLib-5_01-4_16_2_3:4.1
	RISC_OSLib-5_01-4_16_2_2:4.1
	RISC_OSLib-5_10:4.1
	RISC_OSLib-5_01-4_16_2_1:4.1
	Bethany:4.1.0.12
	RISC_OSLib-5_09:4.1
	RISC_OSLib-5_08:4.1
	RISC_OSLib-5_07:4.1
	RISC_OSLib-5_06:4.1
	RISC_OSLib-4_97-4_12_2_8:4.1
	RISC_OSLib-5_05:4.1
	RISC_OSLib-5_04:4.1
	sbrodie_sedwards_16Mar2000:4.1
	RISC_OSLib-5_03:4.1
	RISC_OSLib-5_02:4.1
	RISC_OSLib-4_97-4_12_2_7:4.1
	RISC_OSLib-5_01:4.1
	RISC_OSLib-5_00:4.1
	RISC_OSLib-4_99:4.1
	RISC_OSLib-4_98:4.1
	RISC_OSLib-4_97-4_12_2_6:4.1
	RISC_OSLib-4_97-4_12_2_5:4.1
	RISC_OSLib-4_97-4_12_2_4:4.1
	RISC_OSLib-4_97-4_12_2_3:4.1
	RISC_OSLib-4_97-4_12_2_2:4.1
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.1
	kbracey_32bit:4.1.0.10
	kbracey_32bit_bp:4.1
	dcotton_autobuild_BaseSW:4.1
	RISC_OSLib-4_97:4.1
	RISC_OSLib-4_96:4.1
	RISC_OSLib-4_95:4.1
	RISC_OSLib-4_94:4.1
	RISC_OSLib-4_93:4.1
	RISC_OSLib-4_92:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.1
	RISC_OSLib-4_90:4.1
	RISC_OSLib-4_89:4.1
	Ursula_merge:4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2011.10.28.14.23.17;	author bavison;	state Exp;
branches;
next	4.8;
commitid	hIG6j26y6NoxM7Fv;

4.8
date	2005.03.07.15.19.17;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	2004.01.23.19.10.19;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2003.04.15.16.50.23;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2002.05.22.10.45.24;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2002.04.11.16.37.52;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2002.03.26.16.17.26;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2002.03.21.14.36.24;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.48;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.48;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.47;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.09;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.31;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* math.c: ANSI draft (X3J11 May 86) library code, section D.5 */
/* Copyright (C) Codemist Ltd, 1988 */

/* version 0.04b */
/* Nov 87: fix bug in ibm frexp(-ve arg).                                   */

/*
 * This version of the code takes the view that whenever there is an
 * error a NaN should be handed back (as well as errno getting set). The
 * value HUGE_VAL is used, which is not actually a NaN but which will
 * often lead to exponent overflow pretty soon if it is used.  ACN is
 * unclear if this is sensible, and has had a program fall over when
 * atan2(0.0, 0.0) handed back HUGE_VAL rather than some less vicious
 * value (e.g. 0.0).  He can imagine people who expect pow(0.0, 0.0) to
 * be 1.0 (or maybe 0.0, but certainly not HUGE_VAL), and who expect
 * sin(x) to be <= 1.0 in absolute value regardless of anything.  Thus
 * the current state is OK if we are being strict, but mey be unfriendly
 * in some cases?  Thoughts and comments, anybody?
 */

#include "hostsys.h"
#include <limits.h>
#include <float.h>
#include <errno.h>

/* This file contains code for most of the math routines from <math.h>      */

/* On the ARM some of these routines are implemented as floating point      */
/* opcodes and as such appear in startup.s                                  */

#ifndef NO_FLOATING_POINT

#ifndef HOST_HAS_TRIG
#error HOST_HAS_TRIG assumed - software sin et al removed
#endif

#include <math.h>                          /* for forward references */
#include <fenv.h>

#pragma STDC FENV_ACCESS ON

#ifdef __CC_NORCROFT
/* NAN definitions to match the FPA support code */
#define NAN_XRem0       0f_7fc0000a
#define NAN_SqrtNeg     0f_7fc0000b
#define NAN_SinCosRange 0f_7fc00010
#define NAN_TanRange    0f_7fc00012
#define NAN_AsnAcsRange 0f_7fc00015
#define NAN_LgnLogNeg   0f_7fc00018
#define NAN_NegPowX     0f_7fc00019
#define NAN_0PowNonpos  0f_7fc0001a
#else
#define NAN_XRem0       NAN
#define NAN_SqrtNeg     NAN
#define NAN_SinCosRange NAN
#define NAN_TanRange    NAN
#define NAN_AsnAcsRange NAN
#define NAN_LgnLogNeg   NAN
#define NAN_NegPowX     NAN
#define NAN_0PowNonpos  NAN
#endif

/* On the ARM, this has moved into the library's static data area */
/* so that it still works with the Shared C Library module.       */
/* const double __huge_val = 1.79769313486231571e+308; */

/* New versions with Annex F behaviour; exported for complex.c */
double _new_cosh(double x);
double _new_sinh(double x);
double _new_tanh(double x);

double frexp(double d, int *lvn)
{
/* This version works even if d starts off as an unnormalized number in  */
/* the IEEE sense. But in that special case it will be mighty slow!      */
/* By that we mean at most 52 iterations for the smallest number.        */
    fp_number d1;
    int n;
    if (d==0.0)
    {   *lvn = 0;
        return d;
    }
    d1.d = d;
    if ((n = d1.i.x - 0x3fe) == -0x3fe)
    {   int flag;
/* Here d1 has zero in its exponent field - this means that the mantissa */
/* is un-normalized. I have to shift it left (at least one bit) until a  */
/* suitable nonzero bit appears to go in the implicit-bit place in the   */
/* fractional result. For each bit shifted I need to adjust the final    */
/* exponent that will be returned.                                       */
/* I have already tested to see if d was zero so the following loop MUST */
/* terminate.                                                            */
        n++;
        do
        {   flag = d1.i.mhi & 0x00080000;
            d1.i.mhi = (d1.i.mhi << 1) | (d1.i.mlo >> 31);
            d1.i.mlo = d1.i.mlo << 1;
            n--;
        } while (flag==0);
    }
    else if (n == 0x401)
    {
/* Here d1 has 0x7ff in its exponent field - it's a NaN or infinity      */
        *lvn = (d1.i.mhi || d1.i.mlo) ? FP_ILOGBNAN : INT_MAX;
        return d1.d;
    }
    *lvn = n;
    d1.i.x = 0x3fe;
    return d1.d;
}

float frexpf(float s, int *lvn)
{
    fp_number_single s1;
    int n;
    if (s==0.0F)
    {   *lvn = 0;
        return s;
    }
    s1.s = s;
    if ((n = s1.i.x - 0x7e) == -0x7e)
    {   int flag;
        n++;
        do
        {   flag = s1.i.m & 0x00400000;
            s1.i.m = s1.i.m << 1;
            n--;
        } while (flag==0);
    }
    else if (n == 0x81)
    {
/* Here d1 has 0xff in its exponent field - it's a NaN or infinity       */
        *lvn = (s1.i.m) ? FP_ILOGBNAN : INT_MAX;
        return s1.s;
    }
    *lvn = n;
    s1.i.x = 0x7e;
    return s1.s;
}

double scalbln(double d, long int n)
{
    fp_number x;
    long int exponent;
    if (n == 0) return d;
    x.d = d;
    exponent = x.i.x;
    if (exponent == 0x7ff) return d; /* NaN or infinite */
    if (exponent == 0) /* starting subnormal or zero */
    {   int flag;
        if (x.i.mhi == 0 && x.i.mlo == 0) return d;
        exponent++;
        do
        {   flag = x.i.mhi & 0x00080000;
            x.i.mhi = (x.i.mhi << 1) | (x.i.mlo >> 31);
            x.i.mlo = x.i.mlo << 1;
            exponent--;
        } while (flag==0);
    }
    if (n > 0x1000 || exponent + n >= 0x7ff) /* overflow */
    {   feraiseexcept(FE_OVERFLOW|FE_INEXACT);
        return x.i.s ? -INFINITY : INFINITY;
    }
    if (n < -0x1000 || exponent + n <= -53) /* total underflow */
    {   feraiseexcept(FE_UNDERFLOW|FE_INEXACT);
        x.i.x = x.i.mhi = x.i.mlo = 0;
        return x.d;
    }
    if (exponent + n <= 0) /* subnormal result */
    {   unsigned round = 0, hi;
        n = 1 - (exponent + n);
        hi = 0x00100000 | x.i.mhi;

        if (n >= 32)
        {   round = x.i.mlo;
            x.i.mlo = hi;
            hi = 0;
            n -= 32;
        }
        if (n > 0)
        {   round = (x.i.mlo << (32-n)) | (round != 0);
            x.i.mlo = (hi << (32-n)) | (x.i.mlo >> n);
            hi = hi >> n;
        }
        x.i.mhi = hi;
        x.i.x = 0;
        /* perform round-to-nearest; to even in tie cases */
        if (round > 0x80000000 ||
            (round == 0x80000000 && (x.i.mlo & 1)))
            if (++x.i.mlo == 0)
                if (++x.i.mhi == 0)
                    x.i.x = 1;

        if (round != 0) feraiseexcept(FE_UNDERFLOW|FE_INEXACT);

        return x.d;
    }
    /* normal result */
    x.i.x = (int) (exponent + n);
    return x.d;
}

float scalblnf(float s, long int n)
{
    fp_number_single x;
    long int exponent;
    if (n == 0) return s;
    x.s = s;
    exponent = x.i.x;
    if (exponent == 0xff) return s; /* NaN or infinite */
    if (exponent == 0) /* starting subnormal or zero */
    {   int flag;
        if (x.i.m == 0) return s;
        exponent++;
        do
        {   flag = x.i.m & 0x00400000;
            x.i.m = x.i.m << 1;
            exponent--;
        } while (flag==0);
    }
    if (n > 0x1000 || exponent + n >= 0xff) /* overflow */
    {   feraiseexcept(FE_OVERFLOW|FE_INEXACT);
        return x.i.s ? -INFINITY : INFINITY;
    }
    if (n < -0x1000 || exponent + n <= -24) /* total underflow */
    {   feraiseexcept(FE_UNDERFLOW|FE_INEXACT);
        x.i.x = x.i.m = 0;
        return x.s;
    }
    if (exponent + n <= 0) /* subnormal result */
    {   unsigned round, m;
        n = 1 - (exponent + n);
        m = 0x00800000 | x.i.m;

        round = m << (32-n);
        x.i.m = m >> n;
        x.i.x = 0;
        /* perform round-to-nearest; to even in tie cases */
        if (round > 0x80000000 ||
            (round == 0x80000000 && (x.i.m & 1)))
            if (++x.i.m == 0)
                  x.i.x = 1;

        if (round != 0) feraiseexcept(FE_UNDERFLOW|FE_INEXACT);

        return x.s;
    }
    /* normal result */
    x.i.x = (int) (exponent + n);
    return x.s;
}

double scalbn(double x, int n)
{
    return scalbln(x, n);
}

float scalbnf(float x, int n)
{
    return scalblnf(x, n);
}

double ldexp(double x, int n)
{
    fenv_t env;
    int exc;
    feholdexcept(&env);
    x = scalbn(x, n);
    exc = fetestexcept(FE_OVERFLOW|FE_UNDERFLOW);
    if (exc)
    {   errno = ERANGE;
        if (exc & FE_OVERFLOW)
        {   feclearexcept(FE_OVERFLOW);
            x = copysign(HUGE_VAL, x);
        }
    }
    feupdateenv(&env);
    return x;
}

float ldexpf(float x, int n)
{
    return scalbnf(x, n);
}

int ilogb(double d)
{
    fp_number x;
    int exponent;

    x.d = d;
    exponent = x.i.x;
    if (exponent == 0)
    {   int flag;
        if (x.i.mhi == 0 && x.i.mlo == 0) return FP_ILOGB0;
        exponent = 1;
        do
        {   flag = x.i.mhi & 0x00080000;
            x.i.mhi = (x.i.mhi << 1) | (x.i.mlo >> 31);
            x.i.mlo = x.i.mlo << 1;
            exponent--;
        } while (flag==0);
    }
    else if (exponent == 0x7ff)
    {   if (x.i.mhi || x.i.mlo)
            return FP_ILOGBNAN;
        else
            return INT_MAX;
    }
    return exponent - 0x3ff;
}

int ilogbf(float s)
{
    fp_number_single x;
    int exponent;

    x.s = s;
    exponent = x.i.x;
    if (exponent == 0)
    {   int flag;
        if (x.i.m == 0) return FP_ILOGB0;
        exponent = 1;
        do
        {   flag = x.i.m & 0x00400000;
            x.i.m = x.i.m << 1;
            exponent--;
        } while (flag==0);
    }
    else if (exponent == 0xff)
    {   if (x.i.m)
            return FP_ILOGBNAN;
        else
            return INT_MAX;
    }
    return exponent - 0x7f;
}

double logb(double d)
{
    int x = ilogb(d);

    switch (x)
    {
        case FP_ILOGB0:   feraiseexcept(FE_DIVBYZERO); return -INFINITY;
        case FP_ILOGBNAN: return d;
        case INT_MAX:     return INFINITY;
        default:          return x;
    }
}

float logbf(float s)
{
    int x = ilogbf(s);

    switch (x)
    {
        case FP_ILOGB0:   feraiseexcept(FE_DIVBYZERO); return -INFINITY;
        case FP_ILOGBNAN: return s;
        case INT_MAX:     return INFINITY;
        default:          return x;
    }
}

#define _exp_arg_limit 709.78271289338397

#define _pi_       3.14159265358979323846
#define _pi_3      1.04719755119659774615
#define _pi_2      1.57079632679489661923
#define _pi_4      0.78539816339744830962
#define _pi_6      0.52359877559829887038
#define _sqrt_half 0.70710678118654752440
#define _ln2hi_    0x1.62E42FEEp-1
#define _ln2lo_    0x1.A39EF35793C76p-33

static double fetidyexcept(const fenv_t *envp, double x)
{
    int exc = fetestexcept(FE_ALL_EXCEPT);
    if (exc & (FE_DIVBYZERO|FE_INVALID))
    {   if (exc & (FE_UNDERFLOW|FE_OVERFLOW|FE_INEXACT))
            feclearexcept(FE_UNDERFLOW|FE_OVERFLOW|FE_INEXACT);
    }
    else if (exc & FE_UNDERFLOW)
    {   /* Got to check for spurious underflow. We are allowed to raise underflow */
        /* whenever result is tiny (even if exact), so this is sufficient. */
        if (!isless(fabs(x), DBL_MIN))
            feclearexcept(FE_UNDERFLOW);
    }
    feupdateenv(envp);
    return x;
}

static float fetidyexceptf(const fenv_t *envp, float x)
{
    int exc = fetestexcept(FE_ALL_EXCEPT);
    if (exc & (FE_DIVBYZERO|FE_INVALID))
    {   if (exc & (FE_UNDERFLOW|FE_OVERFLOW|FE_INEXACT))
            feclearexcept(FE_UNDERFLOW|FE_OVERFLOW|FE_INEXACT);
    }
    else if (exc & FE_UNDERFLOW)
    {   /* Got to check for spurious underflow. We are allowed to raise underflow */
        /* whenever result is tiny (even if exact), so this is sufficient. */
        if (!isless(fabsf(x), FLT_MIN))
            feclearexcept(FE_UNDERFLOW);
    }
    feupdateenv(envp);
    return x;
}

double atan2(double y, double x)
{
    if (isunordered(y, x)) return y+x;

    if (y==0.0 || (isinf(x) && isfinite(y)))
    {   if (x==y) /* ie x==y==0 */
        {   errno = EDOM;
            return -HUGE_VAL;   // for backwards compatibility.
        }
        return signbit(x) ? copysign(_pi_, y) : y;
    }

    if (isinf(x)) /* y must also be infinite, from above */
        return copysign(x > 0 ? _pi_4 : 3*_pi_4, y);

    if (fabs(x) < fabs(y)) /* handles infinite y, finite x */
    {   if (fabs(x / y)<1.0e-20)
        {   if (y<0.0) return - _pi_2;
            else return _pi_2;
        }
    }
    y = atan(y / x);
    if (x<0.0)
    {   if (y>0.0) y -= _pi_;
        else y += _pi_;
    }
    return y;
}

/* atan2f supplied in mathasm; follows Annex F */

/* Use the macros, which expand to inline ABS instructions */
double (fabs)(double x) { return fabs(x); }
float (fabsf)(float x) { return fabsf(x); }

double sinh(double x)
{
    int sign;
    double y;
    if (x==0) return x;
    if (isless(x,0.0)) y = -x, sign = 1; else y = x, sign = 0;
    if (isgreater(y,1.0))
    {
/* _sinh_lnv is REQUIRED to read in as a number with the lower part of   */
/* its floating point representation zero.                               */
#define    _sinh_lnv     0.69316101074218750000          /* ln(v)        */
#define    _sinh_vm2     0.24999308500451499336          /* 1/v^2        */
#define    _sinh_v2m1    0.13830277879601902638e-4       /* (v/2) - 1    */
        double w = y - _sinh_lnv, z, r;
        if (w>_exp_arg_limit)
        {   if (isinf(x)) return x;
            errno = ERANGE;
            if (sign) return -HUGE_VAL;
            else return HUGE_VAL;
        }
        z = exp(w);   /* should not overflow!                            */
        if (z < 1.0e10) z = z - _sinh_vm2/z;
        r = z + _sinh_v2m1 * z;
        if (sign) return -r;
        else return r;
    }
    else if (!isgreater(y,1.0e-10)) return x;
    else
    {
#define _sinh_p0    -0.35181283430177117881e6
#define _sinh_p1    -0.11563521196851768270e5
#define _sinh_p2    -0.16375798202630751372e3
#define _sinh_p3    -0.78966127417357099479e0
#define _sinh_q0    -0.21108770058106271242e7
#define _sinh_q1     0.36162723109421836460e5
#define _sinh_q2    -0.27773523119650701667e3
#define _sinh_q3     1.0
        double g = x*x;
        double r;
        /* Use a (minimax) rational approximation. See Cody & Waite.     */
        r = ((((_sinh_p3*g + _sinh_p2)*g + _sinh_p1)*g + _sinh_p0)*g) /
             (((g + _sinh_q2)*g + _sinh_q1)*g + _sinh_q0);
        return x + x*r;
    }
}

double _new_sinh(double x)
{
    int sign;
    double y;
    if (x==0) return x;
    if (isless(x,0.0)) y = -x, sign = 1; else y = x, sign = 0;
    if (isgreater(y,1.0))
    {   fenv_t env;
        feholdexcept(&env);
        double w = y - _sinh_lnv, z, r;
        z = __d_exp(w);  /* may overflow */
        if (z < 1.0e10) z = z - _sinh_vm2/z;
        r = z + _sinh_v2m1 * z;
        return fetidyexcept(&env, sign ? -r : +r);
    }
    else if (islessequal(y,1.0e-10))
    {   feraiseexcept(FE_INEXACT);
        return x;
    }
    else /* NaN case comes here */
    {
        double g = x*x;
        double r;
        /* I assume this will always raise inexact (except for NaN). */
        /* Use a (minimax) rational approximation. See Cody & Waite.     */
        r = ((((_sinh_p3*g + _sinh_p2)*g + _sinh_p1)*g + _sinh_p0)*g) /
             (((g + _sinh_q2)*g + _sinh_q1)*g + _sinh_q0);
        return x + x*r;
    }
}

double cosh(double x)
{
    x = fabs(x);
    if (isgreater(x,1.0))
    {   x = x - _sinh_lnv;
        if (x>_exp_arg_limit)
        {   if (isinf(x)) return x;
            errno = ERANGE;
            return HUGE_VAL;
        }
        x = exp(x);   /* the range check above ensures that this does    */
                      /* not overflow.                                   */
        if (x < 1.0e10) x = x + _sinh_vm2/x;
        /* This very final line might JUST overflow even though the call */
        /* to exp is safe and even though _exp_arg_limit is conservative */
        return x + _sinh_v2m1 * x;
    }
/* This second part is satisfactory, even though it is simple!           */
    x = exp(x);
    return 0.5*(x + 1/x);
}

double _new_cosh(double x)
{
    fenv_t env;
    feholdexcept(&env);
    x = fabs(x);
    if (isgreater(x,1.0))
    {   x = __d_exp(x - _sinh_lnv);
        if (x < 1.0e10) x = x + _sinh_vm2/x;
        x = x + _sinh_v2m1 * x;
    }
    else
    {
    /* This second part is satisfactory, even though it is simple!           */
        x = __d_exp(x);
        x = 0.5*(x + 1/x);
    }
    return fetidyexcept(&env, x);
}

double tanh(double x)
{
/* The first two exits avoid premature overflow as well as needless use  */
/* of the exp() function.                                                */
    int sign;
    if (isgreater(x,27.0)) return 1.0;  /* here exp(2x) dominates 1.0    */
    else if (isless(x,-27.0)) return -1.0;
    if (isless(x,0.0)) x = -x, sign = 1;
    else sign = 0;
    if (isgreater(x,0.549306144334054846)) /* ln(3)/2 is crossover point */
    {   x = exp(2.0*x);
        x = 1.0 - 2.0/(x + 1.0);
        if (sign) return -x;
        else return x;
    }
#define _tanh_p0    -0.16134119023996228053e4
#define _tanh_p1    -0.99225929672236083313e2
#define _tanh_p2    -0.96437492777225469787e0
#define _tanh_q0     0.48402357071988688686e4
#define _tanh_q1     0.22337720718962312926e4
#define _tanh_q2     0.11274474380534949335e3
#define _tanh_q3     1.0
    if (isgreater(x,1.0e-10))
    {   double y = x*x;
        /* minimax rational approximation                                */
        y = (((_tanh_p2*y + _tanh_p1)*y + _tanh_p0)*y) /
             (((y + _tanh_q2)*y + _tanh_q1)*y + _tanh_q0);
        x = x + x*y;
    }
    if (sign) return -x;
    else return x;
}

double _new_tanh(double x)
{
/* The first two exits avoid premature overflow as well as needless use  */
/* of the exp() function.                                                */
    int sign;
    if (isgreater(x,27.0))
    {   if (!isinf(x)) feraiseexcept(FE_INEXACT);
        return 1.0;  /* here exp(2x) dominates 1.0    */
    }
    else if (isless(x,-27.0))
    {   if (!isinf(x)) feraiseexcept(FE_INEXACT);
        return -1.0;
    }
    if (x == 0.0) return x;
    if (isless(x,0.0)) x = -x, sign = 1;
    else sign = 0;
    if (isgreater(x,0.549306144334054846)) /* ln(3)/2 is crossover point */
    {   x = exp(2.0*x);
        x = 1.0 - 2.0/(x + 1.0);
        if (sign) return -x;
        else return x;
    }
    if (!islessequal(x,1.0e-10))
    {   double y = x*x; /* NaN case comes here */
        /* I assume this will raise inexact (except for NaN) */
        /* minimax rational approximation                                */
        y = (((_tanh_p2*y + _tanh_p1)*y + _tanh_p0)*y) /
             (((y + _tanh_q2)*y + _tanh_q1)*y + _tanh_q0);
        x = x + x*y;
    }
    else
        feraiseexcept(FE_INEXACT);
    if (sign) return -x;
    else return x;
}

/* Simple forms for now */
float coshf(float x)
{
    fenv_t env;
    feholdexcept(&env);
    return fetidyexceptf(&env, (float)cosh(x));
}

float sinhf(float x)
{
    fenv_t env;
    feholdexcept(&env);
    return fetidyexceptf(&env, (float)sinh(x));
}

float tanhf(float x)
{
    fenv_t env;
    feholdexcept(&env);
    return fetidyexceptf(&env, (float)tanh(x));
}

double asinh(double x)
{
    if (x == 0) return x; // asinh(±0) returns ±0

    double y = fabs(x), s; // rounding mode UP/DOWN danger here

    if (isless(y, 0x1.0p-32))
    {   feraiseexcept(FE_INEXACT);
        return x; // what about rounding mode
    }
    if (isgreater(y, 0x1.0p64))
    {   s = log1p(y) + _ln2lo_;
        return copysign(s + _ln2hi_, x);
    }
    s = 1.0/y;
    return copysign(log1p(y + y/(s+hypot(s,1.0))), x);
}

double acosh(double x)
{
    double t;
    if (isless(x, 1.0))
    {   feraiseexcept(FE_INVALID);
        return NAN_LgnLogNeg;
    }
    if (isgreater(x, 0x1.0p64))
    {   t = log1p(x) + _ln2lo_;
        return t + _ln2hi_;
    }
    t = sqrt(x - 1.0);
    #ifdef FE_DOWNWARD
    t = fabs(t); // otherwise acosh(1)=-0 in FE_DOWNWARD
    #endif
    return log1p(t * (t + sqrt(x + 1.0)));
}

double atanh(double x)
{
    double z = copysign(0.5, x);
    x = fabs(x);
    if (isgreater(x, 1.0))
        x = -1.0; // so log1p traps, but avoiding INX in 1.0-x
    else
    #ifdef FE_DOWNWARD
        x = x / fabs(1.0 - x); // otherwise atanh(1)=NaN in FE_DOWNWARD
    #else
        x = x / (1.0 - x);
    #endif
    return z * log1p(x + x);
}

/* The cast back to float for these 3 can only raise inexact */
float asinhf(float x)
{
    return (float) asinh(x);
}

float acoshf(float x)
{
    return (float) acosh(x);
}

float atanhf(float x)
{
    return (float) atanh(x);
}

/* expm1 implementation from Tang's 1992 paper */
#define _expm1_te    0x1p-54
#define _expm1_tp    0x1.C4474E1726455p10  // 2610 log 2
#define _expm1_tm   -0x1.2B708872320E1p5   //  -54 log 2
#define _expm1_t1   -0x1.269621134DB93p-2  // log (1 - 1/4) rounded down
#define _expm1_t2    0x1.C8FF7C79A9A22p-3  // log (1 + 1/4) rounded up
#define _expm1_Inv_L 0x1.71547652B82FEp5   // 32 / log 2
#define _expm1_L1    0x1.62E42FEF00000p-6  // log 2 / 32 (ms bits)
#define _expm1_L2    0x1.473DE6AF278EDp-39 // log 2 / 32 (extra bits)

static const double _expm1_s[32][2] = // 2^(j/32) with extended precision
{
    0x1.0000000000000p0, 0,
    0x1.059B0D3158540p0, 0x1.A1D73E2A475B4p-47,
    0x1.0B5586CF98900p0, 0x1.EC5317256E308p-49,
    0x1.11301D0125B40p0, 0x1.0A4EBBF1AED93p-48,
    0x1.172B83C7D5140p0, 0x1.D6E6FBE462876p-47,
    0x1.1D4873168B980p0, 0x1.53C02DC0144C8p-47,
    0x1.2387A6E756200p0, 0x1.C3360FD6D8E0Bp-47,
    0x1.29E9DF51FDEC0p0, 0x1.09612E8AFAD12p-47,
    0x1.306FE0A31B700p0, 0x1.52DE8D5A46306p-48,
    0x1.371A7373AA9C0p0, 0x1.54E28AA05E8A9p-49,
    0x1.3DEA64C123400p0, 0x1.11ADA0911F09Fp-47,
    0x1.44E0860618900p0, 0x1.68189B7A04EF8p-47,
    0x1.4BFDAD5362A00p0, 0x1.38EA1CBD7F621p-47,
    0x1.5342B569D4F80p0, 0x1.DF0A83C49D86Ap-52,
    0x1.5AB07DD485400p0, 0x1.4AC64980A8C8Fp-47,
    0x1.6247EB03A5580p0, 0x1.2C7C3E81BF4B7p-50,
    0x1.6A09E667F3BC0p0, 0x1.921165F626CDDp-49,
    0x1.71F75E8EC5F40p0, 0x1.9EE91B8797785p-47,
    0x1.7A11473EB0180p0, 0x1.B5F54408FDB37p-50,
    0x1.82589994CCE00p0, 0x1.28ACF88AFAB35p-48,
    0x1.8ACE5422AA0C0p0, 0x1.B5BA7C55A192Dp-48,
    0x1.93737B0CDC5C0p0, 0x1.27A280E1F92A0p-47,
    0x1.9C49182A3F080p0, 0x1.01C7C46B071F3p-48,
    0x1.A5503B23E2540p0, 0x1.C8B424491CAF8p-48,
    0x1.AE89F995AD380p0, 0x1.6AF439A68BB99p-47,
    0x1.B7F76F2FB5E40p0, 0x1.BAA9EC206AD4Fp-50,
    0x1.C199BDD855280p0, 0x1.C2220CB12A092p-48,
    0x1.CB720DCEF9040p0, 0x1.48A81E5E8F4A5p-47,
    0x1.D5818DCFBA480p0, 0x1.C976816BAD9B8p-50,
    0x1.DFC97337B9B40p0, 0x1.EB968CAC39ED3p-48,
    0x1.EA4AFA2A490C0p0, 0x1.9858F73A18F5Ep-48,
    0x1.F50765B6E4540p0, 0x1.9D3E12DD8A18Bp-54
};

static double poly(double x, int n, const double A[static n])
{
    double r = A[n-1] * x;
    for (int i = n-2; i >= 0; i--)
        r = (r + A[i]) * x;
    return r;
}

double expm1(double x)
{
    if (isless(fabs(x), _expm1_te))
    {   if (x == 0.0) return x;
        return (x*0x1p128 + fabs(x)) * 0x1p-128;
    }
    if (!islessequal(x, _expm1_tp))
    {   /* NaN comes here */
        return __d_exp(x); /* let exp() do all the hard work */
    }
    if (x < _expm1_tm)
    {   if (isfinite(x)) return -1.0 + 0x1p-128;
        return -1.0;
    }
    if (x <= _expm1_t1 || x >= _expm1_t2)
    {   /* procedure 1 */
        int n = (int) lrint(x * _expm1_Inv_L);
        int n2 = n & 31;
        int n1 = n - n2;
        double r1 = x - (n * _expm1_L1);
        double r2 = - (n * _expm1_L2);
        int m = n1 / 32;
        int j = n2;
        double r = r1 + r2;
        static const double A[5] = { 0x1.0000000000000p-1,
                                     0x1.5555555548F7Cp-3,
                                     0x1.5555555545D4Ep-5,
                                     0x1.11115B7AA905Ep-7,
                                     0x1.6C1728D739765p-10 };
        double q = poly(r, 5, A) * r;
        double p = r1 + (r2 + q);
        double s = _expm1_s[j][0] + _expm1_s[j][1];
        if (m >= 53)
        {   x = _expm1_s[j][1];
            if (m < 2*53) x -= scalbn(1, -m);
            return scalbn(_expm1_s[j][0] + (s * p + x), m);
        }
        else if (m <= -8)
            return scalbn(_expm1_s[j][0] + (s * p + _expm1_s[j][1]), m) - 1;
        else
            return scalbn((_expm1_s[j][0] - scalbn(1, -m)) +
                          (_expm1_s[j][0] * p + _expm1_s[j][1] * (1 + p)), m);
    }
    else
    {   /* procedure 2 */
        double u = (float) x;
        double v = x - u;
        double y = u * u * 0.5;
        double z = v * (x + u) * 0.5;
        static const double A[9] = { 0x1.5555555555549p-3,
                                     0x1.55555555554B6p-5,
                                     0x1.111111111A9F3p-7,
                                     0x1.6C16C16CE14C6p-10,
                                     0x1.A01A01159DD2Dp-13,
                                     0x1.A019F635825C4p-16,
                                     0x1.71E14BFE3DB59p-19,
                                     0x1.28295484734EAp-22,
                                     0x1.A2836AA646B96p-26 };
        double q = poly(x, 9, A) * x * x;
        if (fabs(y) >= 0x1p-7)
            return (u + y) + (q + (v + z));
        else
            return x + (y + (q + z));
    }
}

float expm1f(float x)
{
    fenv_t env;
    feholdexcept(&env);
    return fetidyexceptf(&env, (float)expm1(x));
}

double fmod(double x, double y)
{
/* floating point remainder of (x/y) for integral quotient. Remainder    */
/* has same sign as x.                                                   */
    double r;
    if (isinf(x) || y == 0.0)
    { errno = EDOM;
      return -HUGE_VAL;
    }
    r = remainder(fabs(x), y = fabs(y));
    if (signbit(r)) r += y;
    return copysign(r, x);
}

float fmodf(float x, float y)
{
    float r;
    r = remainderf(fabsf(x), y = fabsf(y));
    if (signbit(r)) r += y;
    return copysignf(r, x);
}

double (ceil)(double x)                { return ceil(x); }
float (ceilf)(float x)                 { return ceilf(x); }
double (floor)(double x)               { return floor(x); }
float (floorf)(float x)                { return floorf(x); }
double (rint)(double x)                { return rint(x); }
float (rintf)(float x)                 { return rintf(x); }
long int (lrint)(double x)             { return lrint(x); }
long int (lrintf)(float x)             { return lrintf(x); }
double (trunc)(double x)               { return trunc(x); }
float (truncf)(float x)                { return truncf(x); }

float (acosf)(float x)                 { return acosf(x); }
float (asinf)(float x)                 { return asinf(x); }
double (atan)(double x)                { return atan(x); }
float (atanf)(float x)                 { return atanf(x); }
float (sinf)(float x)                  { return sinf(x); }
float (cosf)(float x)                  { return cosf(x); }
float (tanf)(float x)                  { return tanf(x); }
float (expf)(float x)                  { return expf(x); }
float (logf)(float x)                  { return logf(x); }
float (log10f)(float x)                { return log10f(x); }
float (sqrtf)(float x)                 { return sqrtf(x); }

double modf(double value, double *iptr)
{
/* splits value into integral part & fraction (both same sign)           */
    fp_number x;
    int exponent, mask;
    if (value == 0.0)
    {   *iptr = value;
        return value;
    }
    x.d = value;
    if ((exponent = x.i.x - 0x3ff) < 0)
    {   *iptr = copysign(0.0, value);
        return value;
    }
    else if (exponent >= 52)
    {   *iptr = value;
        return copysign(0.0, value);
    }
    if (exponent >= 20)
    {   mask = ((unsigned) 0xffffffff) >> (exponent - 20);
        x.i.mlo &= ~mask;
    }
    else
    {   mask = 0xfffff >> exponent;
        x.i.mhi &= ~mask;
        x.i.mlo = 0;
    }
    *iptr = x.d;
    return value - x.d;
}

float modff(float value, float *iptr)
{
/* splits value into integral part & fraction (both same sign)           */
    fp_number_single x;
    int exponent, mask;
    if (value == 0.0F)
    {   *iptr = value;
        return value;
    }
    x.s = value;
    if ((exponent = x.i.x - 0xff) < 0)
    {   *iptr = copysignf(0.0F, value);
        return value;
    }
    else if (exponent >= 23)
    {   *iptr = value;
        return copysignf(0.0F, value);
    }
    mask = 0x7fffff >> exponent;
    x.i.m &= ~mask;
    *iptr = x.s;
    return value - x.s;
}

double nan(const char *s)
{
    (void) s;
    return (double) NAN;
}

float nanf(const char *s)
{
    (void) s;
    return NAN;
}

double fdim(double x, double y)
{
    if (islessequal(x, y))
       return 0.0;
    else
       return x - y; /* Will return NaN for NaN input */
}

float fdimf(float x, float y)
{
    if (islessequal(x, y))
       return 0.0F;
    else
       return x - y; /* Will return NaN for NaN input */
}

#define _sqrt2pi   2.50662827463100050242

/*
 * Gamma functions computed using Lanczos' approximation.
 * Double version uses coefficients computed as per Spouge (1994)
 * to achieve (theoretically) < 1 ulp error.
 * Float version uses original Lanczos coefficients.
 *
 * Lanczos' approximation:
 *
 * G(x+1) = (x+a)^(x+.5)* e^-(x+a) * sqrt(2*pi) *
 *            [ c0 + c1/(x+1) + c2/(x+3).. + cn/(x+n) ]    (x > 0)
 *
 *
 * Spouge's coefficients:
 *  c0 = 1
 *  c[k] = (-1)^(k-1) * e^(a-k) * (a-k)^(k-0.5)        ( 1 <= k < ceil(a) )
 *        ------------------------------------
 *                  sqrt(2*pi) * (k-1)!
 *
 * giving relative error < sqrt(a) * (2*pi)^-(a+0.5) / (a+x)
 *
 * Useful relations: gamma(x+1) = x*gamma(x)
 *                   gamma(1-x) = pi / (gamma(x)*sin(pi*x))
 *                   gamma(n+1) = n!
 */

static const double _lgamma_c[18] =   // actually c[k]*sqrt(2*pi)
{
     166599025.853949811570,
    -981939810.195007931170,
     2548964102.46316408700,
    -3836248618.43839895348,
     3709080184.61731236844,
    -2412708472.49486138749,
     1075449464.75190680642,
    -328534715.011179056348,
     67752870.4715251633277,
    -9145761.20044444915581,
     768402.637723269577278,
    -37175.9448951564986832,
     917.944248521710658895,
    -9.51510944794615044564,
     0.0294177178100457006509,
    -1.37185031730621246722e-5,
     1.72316912091954830013e-10,
    -2.50065513100139951901e-20
};

static inline double _gamma_sum(double x)
{
    double r = _sqrt2pi;
    for (int i = 1; i <= 18; i++)
        r += _lgamma_c[i-1] / (x + i);
    return r;
}

static const double _lgammaf_c[7] =
{
     1.000000000190015,
     76.18009172947146,
    -86.50532032941677,
     24.01409824083091,
    -1.231739572450155,
     1.208650973866179e-3,
    -5.395239384953e-6
};

static inline double _gammaf_sum(double x)
{
    double r = _lgammaf_c[0];
    for (int i = 1; i <= 6; i++)
        r += _lgammaf_c[i] / (x + i);
    return r;
}

double lgamma(double x)
{
    if (isinf(x)) return INFINITY;
    if (isnan(x)) return x;

    if (x < 1)
    {
        if (floor(x) == x)
        {   feraiseexcept(FE_DIVBYZERO);
            return INFINITY;
        }

        return __d_log(fabs((1-x)*_pi_/__d_sin(_pi_*x)))-lgamma(2-x);
    }

    if (x == 1 || x == 2) return +0;

    return (x+0.5)*__d_log(x+18.5) - (x+18.5) + __d_log(_gamma_sum(x) / x);
}

float lgammaf(float x)
{
    if (isinf(x)) return INFINITY;
    if (isnan(x)) return x;

    if (x < 1)
    {
        if (floorf(x) == x)
        {   feraiseexcept(FE_DIVBYZERO);
            return INFINITY;
        }

        return (float) __d_log(fabs((1.0-x)*_pi_/__d_sin(_pi_*x)))-lgammaf(2-x);
    }

    if (x == 1 || x == 2) return +0;

    return (float) ((x+0.5)*__d_log(x+5.5) - (x+5.5) + __d_log(_sqrt2pi * _gammaf_sum(x) / x));
}

double tgamma(double x)
{
    if (isinf(x))
    {   if (x > 0)
            return x;
        else
        {   feraiseexcept(FE_INVALID);
            return NAN;
        }
    }
    if (isnan(x)) return x;

    if (x == 0)
        return 1 / x; // ±Inf, with Divide By Zero

    if (floor(x) == x)
    {
        if (x < 0)
        {   feraiseexcept(FE_INVALID);
            return NAN;
        }
        else if (x <= 171)
        {  double r = 1;
            for (int n = (int) x - 1; n > 1; n--)
                r *= n;
            return r;
        }
    }

    if (x < 1)
        return (1-x)*_pi_/(sin(_pi_*x)*tgamma(2-x));

    return __d_exp(lgamma(x));
}

float tgammaf(float x)
{
    if (isinf(x))
    {   if (x > 0)
            return x;
        else
        {   feraiseexcept(FE_INVALID);
            return NAN;
        }
    }
    if (isnan(x)) return x;

    if (x == 0)
        return 1 / x; // ±Inf, with Divide By Zero

    if (floorf(x) == x)
    {
        if (x < 0)
        {   feraiseexcept(FE_INVALID);
            return NAN;
        }
        else if (x <= 35)
        {
            float r = 1;
            for (int n = (int) x - 1; n > 1; n--)
                r *= n;
            return r;
        }
    }

    if (x < 1)
        return (float) ((1.0-x)*_pi_/(sin(_pi_*x)*tgammaf(2-x)));

    return expf(lgammaf(x));
}

/* Error function algorithms derived from "Numerical recipes in C" */

#define _log_sqrt_pi 0.5723649429247000870717137 // == lgamma(0.5)

/* Series calculation for incomplete gamma function P(0.5,x); good for */
/* x <= 1.5. */
static double gser05(double x, double epsilon)
{
    double sum,del,ap;

    ap = 0.5;
    del = sum = 2;
    for (;;)
    {   ++ap;
        del *= x/ap;
        sum += del;
        if (fabs(del) < fabs(sum)*epsilon)
            return sum*exp(-x+0.5*log(x)-_log_sqrt_pi);
    }
}

/* Continued fraction calculation for incomplete gamma function */
/* 1 - P(0.5,x); good for x >= 1.5. */
static double gcf05(double x, double epsilon)
{
    double an,b,c,d,del,h;
    #define FPMIN 1e-300

    b = x+0.5;
    c = 1/FPMIN;
    d = 1/b;
    h = d;
    for (int i=1; ; i++)
    {   an = i*(0.5-i);
        b += 2;
        d = an*d+b;
        if (fabs(d) < FPMIN) d = FPMIN;
        c = b + an/c;
        if (fabs(c) < FPMIN) c = FPMIN;
        d = 1/d;
        del = d*c;
        h *= del;
        if (fabs(del-1) < epsilon) break;
    }
    return exp(-x+0.5*log(x)-_log_sqrt_pi)*h;
}

static double gammp05(double x, double epsilon)
{
    if (isunordered(x, 1.5))
        return x;
    else if (isless(x, 1.5))
        return gser05(x,epsilon);
    else
        return 1 - gcf05(x,epsilon);
}

static double gammq05(double x, double epsilon)
{
    if (isunordered(x, 1.5))
        return x;
    else if (isless(x, 1.5))
        return 1 - gser05(x,epsilon);
    else
        return gcf05(x,epsilon);
}

double erf(double x)
{
    if (x == 0) return x;
    if (isless(x, 0.0)) return -erf(-x);
    if (isgreater(x, 1e100)) return 1.0;

    return gammp05(x*x, 3*DBL_EPSILON);
}

double erfc(double x)
{
    if (isgreater(fabs(x), 1e100)) return isless(x, 0.0) ? 2 : 0;

    return isless(x, 0.0) ? 1+gammp05(x*x, 3*DBL_EPSILON)
                          : gammq05(x*x, 3*DBL_EPSILON);
}

float erff(float x)
{
    if (x == 0) return x;
    if (isless(x, 0.0)) return -erff(-x);
    if (isgreater(x, 1e15F)) return 1.0F;

    return (float) gammp05((double) x*x, 3.0*FLT_EPSILON);
}

#define _erfcf_c0  -1.26551223
#define _erfcf_c1   1.00002368
#define _erfcf_c2   0.37409196
#define _erfcf_c3   0.09678418
#define _erfcf_c4  -0.18628806
#define _erfcf_c5   0.27886807
#define _erfcf_c6  -1.13520398
#define _erfcf_c7   1.48851586
#define _erfcf_c8  -0.82215223
#define _erfcf_c9   0.17087277

float erfcf(float x)
{
    double t,r;

    if (isgreater(fabsf(x), 1e15F)) return isless(x, 0.0F) ? 2 : 0;

    t = 1/(1+0.5*fabsf(x));

    r = (((((((((_erfcf_c9) * t + _erfcf_c8) * t + _erfcf_c7) * t +
                 _erfcf_c6) * t + _erfcf_c5) * t + _erfcf_c4) * t +
                 _erfcf_c3) * t + _erfcf_c2) * t + _erfcf_c1) * t +
                 _erfcf_c0;

    r = t*exp(r - (double)x*x);
    return (float) (isless(x, 0.0F) ? 2-r : r);
}

/* Output quo is 0 for error cases, else has magnitude congruent */
/* modulo 2^31 to the magnitude of the integral quotient of x/y */
double remquo(double x, double y, int *quo)
{
    double r;
    long long xm, ym, rm;
    int i, xx, yx, sx;
    int sign, qsign;
    unsigned q=0;
    if (!islessgreater(x, 0.0) || !islessgreater(y, 0.0) ||
        isinf(x) || isinf(y))
        return *quo = 0, remainder(x, y);
    xx = ilogb(x);
    yx = ilogb(y);
    i = xx-yx+1;
    if (i < 0) return x;
    xm = (long long) scalbn(fabs(x), DBL_MANT_DIG-1-xx);
    ym = (long long) scalbn(fabs(y), DBL_MANT_DIG-1-yx);
    sign = sx = x < 0;
    qsign = sign ^ (y < 0);
    rm = xm;
    do
    {   if (ym < rm)
        {   sign = !sign;
            q = ~q;
            rm = ym+ym-rm;
        }
        i--, rm<<=1, q<<=1;
    } while (i >= 0);
    if (sign != sx) q = -q;
    q >>= 1;
    *quo = qsign ? -(int) q : (int) q;
    if (rm == 0) sign = sx, r = 0;
    else r = scalbn((double) rm, yx-1-DBL_MANT_DIG);
    return sign ? -r : +r;
}

float remquof(float x, float y, int *quo)
{
    float r;
    int xm, ym, rm;
    int i, xx, yx, sx;
    int sign, qsign;
    unsigned q=0;
    if (!islessgreater(x, 0.0F) || !islessgreater(y, 0.0F) ||
        isinf(x) || isinf(y))
        return *quo = 0, remainderf(x, y);
    xx = ilogbf(x);
    yx = ilogbf(y);
    i = xx-yx+1;
    if (i < 0) return x;
    xm = (int) scalbnf(fabsf(x), FLT_MANT_DIG-1-xx);
    ym = (int) scalbnf(fabsf(y), FLT_MANT_DIG-1-yx);
    sign = sx = x < 0;
    qsign = sign ^ (y < 0);
    rm = xm;
    do
    {   if (ym < rm)
        {   sign = !sign;
            q = ~q;
            rm = ym+ym-rm;
        }
        i--, rm<<=1, q<<=1;
    } while (i >= 0);
    if (sign != sx) q = -q;
    q >>= 1;
    *quo = qsign ? -(int) q : (int) q;
    if (rm == 0) sign = sx, r = 0;
    else r = scalbnf((float) rm, yx-1-FLT_MANT_DIG);
    return sign ? -r : +r;
}

#endif /* NO_FLOATING_POINT */

/* end of math.c */
@


4.8
log
@Added run-time and ISO C library support for C99 complex numbers.

Version 5.52. Tagged as 'RISC_OSLib-5_52'
@
text
@d965 1
d971 1
@


4.7
log
@<ctype.h> * isblank() added.
          * isprint() now true for non-breaking spaces
<math.h>  * FP_INFINITY corrected to FP_INFINITE
          * fma(), fmal(), llrint(), llrintf(), llrintl(),
            llround(), llroundf(), llroundl(),
            remquo(), remquof(), remquol() added.
          * added inlining for remainder() and fmaf() and various
            float functions.
          * math_errhandling removed pending overhaul - it was misleading.
          * expm1() and log1p() now provide decent (< 1 ulp) accuracy,
            rather than only being marginally better than exp(x)-1 and
            log(1+x).
          * new version of copysign() with standard calling conventions.
          * some C99 functions changed to use infinity/NaNs and exceptions
            for error handling - see comments in header file about the
            changes in progress.
<stdio.h>  * output from %a now correctly rounded
<stdlib.h> * strtof() and strtold() added.
<string.h> * strerror() no longer clears _kernel_last_oserror().

Version 5.49. Tagged as 'RISC_OSLib-5_49'
@
text
@d82 4
d391 17
d506 31
d559 19
d611 36
@


4.6
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d48 4
d55 23
a82 2
#ifndef DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS

a151 31
#else   /* DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS */

double frexp(double d, int *lvn)
{
    fp_number d1;
    if (d==0.0)
    {   *lvn = 0;
        return d;
    }
    d1.d = d;
    *lvn = d1.i.x - 0x3fe;
    d1.i.x = 0x3fe;
    return d1.d;
}

float frexpf(float s, int *lvn)
{
    fp_number_single s1;
    int n;
    if (s==0.0F)
    {   *lvn = 0;
        return s;
    }
    s1.s = s;
    *lvn = s1.i.x - 0x7e;
    s1.i.x = 0x7e;
    return s1.s;
}

#endif   /* DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS */

d156 1
a156 1
    if (n == 0 || d == 0.0) return d;
d160 1
a160 2
#ifndef DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS
    if (exponent == 0) /* starting subnormal */
d162 1
a170 1
#endif
d172 2
a173 2
    {   errno = ERANGE;
        return x.i.s ? -HUGE_VAL : HUGE_VAL;
d176 2
a177 2
    {   x.i.x = x.i.mhi = x.i.mlo = 0;
        errno = ERANGE;
d205 1
a205 1
        if (round != 0) errno = ERANGE; /* only if inexact */
d218 1
a218 1
    if (n == 0 || s == 0.0F) return s;
d222 1
a222 2
#ifndef DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS
    if (exponent == 0) /* starting subnormal */
d224 1
a231 1
#endif
d233 2
a234 2
    {   errno = ERANGE;
        return x.i.s ? -HUGE_VALF : HUGE_VALF;
d237 2
a238 2
    {   x.i.x = x.i.m = 0;
        errno = ERANGE;
d255 1
a255 1
        if (round != 0) errno = ERANGE; /* only if inexact */
d276 14
a289 1
    return scalbn(x, n);
a301 5
    if (d == 0.0)
    {   errno = ERANGE;
        return FP_ILOGB0;
    }

a303 1
#ifndef DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS
d306 1
a320 1
#endif
a328 5
    if (s == 0.0F)
    {   errno = ERANGE;
        return FP_ILOGB0;
    }

a330 1
#ifndef DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS
d333 1
a346 1
#endif
d356 1
a356 1
        case FP_ILOGB0:   return -HUGE_VAL;
d369 1
a369 1
        case FP_ILOGB0:   return -HUGE_VALF;
a377 2
/* machine independent code - but beware the 1e-20's */

d384 2
d387 1
a387 139
#ifndef HOST_HAS_TRIG
/* The ARM has a load of trig functions etc available as opcodes, so     */
/* has no need for these software versions shown here.                   */

#undef sin
#undef cos
#undef atan

static double _sincos(double x, double y, int sign, int coscase)
{
    int n;
    double xn, f, g, r;
    if (y >= 1.0e9)     /* fail if argument is overlarge                 */
    {   errno = EDOM;
        return -HUGE_VAL;
    }
    n = (int) ((y + _pi_2) / _pi_);
    xn = (double) n;
    if ((n & 1) != 0) sign = -sign;
    if (coscase) xn = xn - 0.5;
/* Note that these days C is REQUIRED to observe the brackets used here. */
/* The compiler is NOT allowed to re-associate the additions.            */
#ifdef IBMFLOAT
    {   double x1 = (double)(int)x;
/* observe that the range check on y assures me that (int)x is OK.       */
        double x2 = x - x1;
        f = ((x1 - xn*3.1416015625) + x2) + xn*8.908910206761537356617e-6;
    }
#else
    f = (x - xn*3.1416015625) + xn*8.908910206761537356617e-6;
#endif
/* I expect that the absolute value of f is less than pi/2 here          */
    if (fabs(f) >= 1.e-10)
#define _sincos_r1  -0.16666666666666665052
#define _sincos_r2   0.83333333333331650315e-2
#define _sincos_r3  -0.19841269841201840457e-3
#define _sincos_r4   0.27557319210152756119e-5
#define _sincos_r5  -0.25052106798274584544e-7
#define _sincos_r6   0.16058936490371589114e-9
#define _sincos_r7  -0.76429178068910467734e-12
#define _sincos_r8   0.27204790957888846175e-14
    {   g = f*f;
        r = ((((((((_sincos_r8) * g + _sincos_r7) * g + _sincos_r6) * g +
                    _sincos_r5) * g + _sincos_r4) * g + _sincos_r3) * g +
                    _sincos_r2) * g + _sincos_r1) * g;
        f += f*r;
    };
    if (sign < 0) return -f;
    else return f;
}

double sin(double x)
{
    if (x < 0.0) return _sincos(-x, -x, -1, 0);
    else return _sincos(x, x, 1, 0);
}

double cos(double x)
{
    if (x < 0.0) return _sincos(-x, _pi_2 - x, 1, 1);
    else return _sincos(x, _pi_2 + x, 1, 1);
}

/* NB: the following value is a proper limit provided denormalised       */
/* values are not being supported. It would need to be changed if they   */
/* were to start existing.                                               */
#define _exp_negative_arg_limit -708.39641853226408

double exp(double x)
{
    int n;
    double xn, g, z, gp, q, r;
    if (x > _exp_arg_limit)
    {   errno = ERANGE;
        return HUGE_VAL;
    }
    if (x < _exp_negative_arg_limit) return 0.0;
    if (fabs(x) < 1.e-20) return 1.0;
/* In C the cast (int)x truncates towards zero. Here I want to round.    */
    n = (int)((x >= 0 ? 0.5 : -0.5) + 1.44266950408889634074 * x);
    xn = (double)n;
    g = (x - xn * 0.693359375) - xn * (-2.1219444005469058277e-4);
    z = g * g;
#define  _exp_p0  0.249999999999999993
#define  _exp_p1  0.694360001511792852e-2
#define  _exp_p2  0.165203300268279130e-4
#define  _exp_q0  0.500000000000000000
#define  _exp_q1  0.555538666969001188e-1
#define  _exp_q2  0.495862884905441294e-3
    gp = ((_exp_p2 * z + _exp_p1) * z + _exp_p0) * g;
    q = (_exp_q2 * z + _exp_q1) * z + _exp_q0;
    r = 0.5 + gp / (q - gp);
    return ldexp(r, n + 1);
}

double log(double x)
{
    double f, znum, zden, z, w, r, xn;
    int n;
    if (x <= 0.0)
    {   if (x==0.0)
        {   errno = ERANGE;
            return -HUGE_VAL;
        } else
        { errno = EDOM;
          return -HUGE_VAL;
        }
    }
    f = frexp(x, &n);
    if (f > _sqrt_half)
    {   znum = (f - 0.5) - 0.5;
        zden = f * 0.5 + 0.5;
    }
    else
    {   n -= 1;
        znum = f - 0.5;
        zden = znum * 0.5 + 0.5;
    }
    z = znum / zden;
    w = z * z;
#define _log_a0 -0.64124943423745581147e2
#define _log_a1  0.16383943563021534222e2
#define _log_a2 -0.78956112887491257267e0
#define _log_b0 -0.76949932108494879777e3
#define _log_b1  0.31203222091924532844e3
#define _log_b2 -0.35667977739034646171e2
    r = w * ( ((_log_a2 * w + _log_a1) * w + _log_a0) /
              (((w + _log_b2) * w + _log_b1) * w + _log_b0) );
    r = z + z * r;
    xn = (double)n;
    return (xn*(-2.121944400546905827679e-4) + r) + xn*(355.0/512.0);
}

double log10(double x)
{
    return log(x) * 0.43429448190325182765;  /* log10(e) */
}

double sqrt(double x)
d389 10
a398 15
    fp_number f;
    double y0;
    int n;
    if (x <= 0.0)
    {   if (x < 0.0) errno = EDOM;
        return -HUGE_VAL;
    }
    f.d = x;
    n = f.i.x - 0x3fe;
    f.i.x = 0x3fe;
    {   double fd = f.d;
        y0 = 0.41731 + 0.59016 * fd;
        y0 = 0.5 * (y0 + fd/y0);
        y0 = 0.5 * (y0 + fd/y0);
        y0 = 0.5 * (y0 + fd/y0);
d400 2
a401 9
    if (n & 1)
    {
        y0 *= _sqrt_half;
        n += 1;
    }
    n /= 2;
    f.d = y0;
    f.i.x += n;
    return f.d;
a403 289
double _tancot(double x, int iflag)
{
    int n;
    double f, g, xnum, xden, y, xn;
    y = fabs(x);
    if (y >= 1.0e9)     /* fail if argument is overlarge                 */
    {   errno = EDOM;
        return -HUGE_VAL;
    }
    n = (int) ((2.0 * y + _pi_2) / _pi_);
    if (x < 0) n = - n;
    xn = (double) n;
    f = (x - xn*1.57080078125) + xn*4.454455103380768678308e-6;
    if (fabs(f) > 1.e-10)
    {   g = f * f;
#define _tan_p1 -0.13338350006421960681
#define _tan_p2  0.34248878235890589960e-2
#define _tan_p3 -0.17861707342254426711e-4
#define _tan_q0  1.00000000000000000000
#define _tan_q1 -0.46671683339755294240
#define _tan_q2  0.25663832289440112864e-1
#define _tan_q3 -0.31181531907010027307e-3
#define _tan_q4  0.49819433993786512270e-6
        xnum = ((_tan_p3*g + _tan_p2)*g + _tan_p1)*g*f + f;
        xden = (((_tan_q4*g + _tan_q3)*g + _tan_q2)*g + _tan_q1)*g + _tan_q0;
    }
    else
    {   xnum = f;
        xden = 1.0;
    }
/* It is probable that overflow can never occur here, since floating     */
/* point values fall about or more 1.e-16 apart near singularities       */
/* of the tangent function.                                              */
    if (iflag==0)
    {   if ((n & 1) == 0) return xnum / xden;
        else return - xden / xnum;
    }
    else
    {   if ((n & 1) == 0) return xden / xnum;
        else return - xnum / xden;
    }
}

double tan(double x)
{
    return _tancot(x, 0);
}

double _cot(double x)      /* Not specified by ANSI hence the funny name */
{
    if (fabs(x) < 1.0/HUGE_VAL)
    {   errno = ERANGE;
        if (x < 0.0) return -HUGE_VAL;
        else return HUGE_VAL;
    }
    return _tancot(x, 1);
}

double atan(double x)
{
    int n;
    double f;
    const static double a[4] = { 0.0, _pi_6, _pi_2, _pi_3 };
    f = fabs(x);
    if (f > 1.0)
    {   f = 1.0 / f;
        n = 2;
    }
    else n = 0;
#define _two_minus_root_three 0.26794919243112270647
#define _sqrt_three           1.73205080756887729353
#define _sqrt_three_minus_one 0.73205080756887729353
    if (f > _two_minus_root_three)
    {   f = (((_sqrt_three_minus_one*f - 0.5) - 0.5) + f) / (_sqrt_three + f);
        n++;
    }
    if (fabs(f) > 1.e-10)
    {   double g = f * f;
        double r;
#define _atan_p0    -0.13688768894191926929e2
#define _atan_p1    -0.20505855195861651981e2
#define _atan_p2    -0.84946240351320683534e1
#define _atan_p3    -0.83758299368150059274
#define _atan_q0     0.41066306682575781263e2
#define _atan_q1     0.86157349597130242515e2
#define _atan_q2     0.59578436142597344465e2
#define _atan_q3     0.15024001160028576121e2
        r = ((((_atan_p3*g + _atan_p2)*g + _atan_p1)*g + _atan_p0)*g) /
             ((((g + _atan_q3)*g + _atan_q2)*g + _atan_q1)*g + _atan_q0);
        f = f + f * r;
    }
    if (n > 1) f = -f;
    f = f + a[n];
    if (x < 0) return -f;
    else return f;
}

double _asinacos(double x, int flag)
{
    int i;
    double y, g, r;
    const static double a[2] = {0.0, _pi_4 };
    const static double b[2] = {_pi_2, _pi_4 };
    y = fabs(x);
    if (y < 1.e-10) i = flag;
    else
    {   if (y > 0.5)
        {   i = 1 - flag;
            if (y > 1.0)
            {   errno = EDOM;
                return -HUGE_VAL;
            }
            g = ((0.5 - y) + 0.5) * 0.5;
            y = -2.0 * sqrt(g);
        }
        else
        {   i = flag;
            g = y * y;
        }
#define _asin_p1    -0.27368494524164255994e2
#define _asin_p2     0.57208227877891731407e2
#define _asin_p3    -0.39688862997504877339e2
#define _asin_p4     0.10152522233806463645e2
#define _asin_p5    -0.69674573447350646411e0
#define _asin_q0    -0.16421096714498560795e3
#define _asin_q1     0.41714430248260412556e3
#define _asin_q2    -0.38186303361750149284e3
#define _asin_q3     0.15095270841030604719e3
#define _asin_q4    -0.23823859153670238830e2
        r = (((((_asin_p5*g + _asin_p4)*g + _asin_p3)*g +
                              _asin_p2)*g + _asin_p1)*g)      /
             (((((g + _asin_q4)*g + _asin_q3)*g +
                      _asin_q2)*g + _asin_q1)*g + _asin_q0);
        y = y + y*r;
    }
    if (flag==0)
    {   y = (a[i] + y) + a[i];
        if (x<0) y = -y;
    }
    else if (x < 0) y = (b[i] + y) + b[i];
    else y = (a[i] - y) + a[i];
    return y;
}

double asin(double x)
{
    return _asinacos(x, 0);
}

double acos(double x)
{
    return _asinacos(x, 1);
}

double pow(double x, double y)
{
    int sign = 0, m, p, i, mdash, pdash;
    double g, r, z, v, u1, u2;
/* The table a1[] contains properly rounded values for 2**(i/16), and    */
/* a2[] contains differences between the true values of 2**(i/16) and    */
/* the a1[] values for odd i.                                            */
    const static double a1[17] = {
/* It is painfully important that the following 17 floating point        */
/* numbers are read in to yield the quantities shown on the right.       */
        1.0,                    /* 3ff00000:00000000 */
        0.9576032806985737,     /* 3feea4af:a2a490da */
        0.91700404320467121,    /* 3fed5818:dcfba487 */
        0.87812608018664973,    /* 3fec199b:dd85529c */
        0.8408964152537145,     /* 3feae89f:995ad3ad */
        0.80524516597462714,    /* 3fe9c491:82a3f090 */
        0.77110541270397037,    /* 3fe8ace5:422aa0db */
        0.73841307296974967,    /* 3fe7a114:73eb0187 */
        0.70710678118654757,    /* 3fe6a09e:667f3bcd */
        0.67712777346844632,    /* 3fe5ab07:dd485429 */
        0.64841977732550482,    /* 3fe4bfda:d5362a27 */
        0.620928906036742,      /* 3fe3dea6:4c123422 */
        0.59460355750136051,    /* 3fe306fe:0a31b715 */
        0.56939431737834578,    /* 3fe2387a:6e756238 */
        0.54525386633262884,    /* 3fe172b8:3c7d517b */
        0.52213689121370688,    /* 3fe0b558:6cf9890f */
        0.5                     /* 3fe00000:00000000 */
        };
    const static double a2[8] = {
        -5.3099730280915798e-17,
        1.4800703477186887e-17,
        1.2353596284702225e-17,
        -1.7419972784343138e-17,
        3.8504741898901863e-17,
        2.3290137959059465e-17,
        4.4563878092065126e-17,
        4.2759448527536718e-17
        };
    if (y == 1.0) return x;
    if (x <= 0.0)
    {   int ny;
        if (x==0.0)
        {   if (y <= 0.0)
            {   errno = EDOM;
                if (y==0.0) return 1.0;
                return -HUGE_VAL;
            }
            return 0.0;
        }
        if (y < (double)INT_MIN || y > (double)INT_MAX ||
            (double)(ny = (int)y) != y)
        {   errno = EDOM;
            return -HUGE_VAL;
        }
/* Here y is an integer and x is negative.                               */
        x = -x;
        sign = (ny & 1);
    }
    if (y == 2.0 && x < 1.e20) return x*x;  /* special case.             */
    g = frexp(x, &m);
    p = 0;
    if (g <= a1[8]) p = 8;
    if (g <= a1[p+4]) p += 4;
    if (g <= a1[p+2]) p += 2;
    z = ((g - a1[p+1]) - a2[p/2]) / (0.5*g + 0.5*a1[p+1]);
/* Expect abs(z) <= 0.044 here */
    v = z * z;
#define _pow_p1 0.83333333333333211405e-1
#define _pow_p2 0.12500000000503799174e-1
#define _pow_p3 0.22321421285924258967e-2
#define _pow_p4 0.43445775672163119635e-3
    r = (((_pow_p4*v + _pow_p3)*v + _pow_p2)*v + _pow_p1)*v*z;
#define _pow_k 0.44269504088896340736
    r = r + _pow_k * r;
    u2 = (r + z * _pow_k) + z;
#define _reduce(v) ((double)(int)(16.0*(v))*0.0625)
    u1 = (double)(16*m-p-1) * 0.0625;
    {   double y1 = _reduce(y);
        double y2 = y - y1;
        double w = u2*y + u1*y2;
        double w1 = _reduce(w);
        double w2 = w - w1;
        int iw1;
        w = w1 + u1*y1;
        w1 = _reduce(w);
        w2 = w2 + (w - w1);
        w = _reduce(w2);
        iw1 = (int)(16.0*(w1+w));
        w2 = w2 - w;
/* The following values have been determined experimentally, buth their  */
/* values are not very critical.                                         */
#  define _negative_pow_limit -16352
        if (iw1 < _negative_pow_limit)
        {   errno = ERANGE;         /* Underflow certain                 */
            return 0.0;
        }
        if (w2 > 0.0)
        {   iw1 += 1;
            w2 -= 0.0625;
        }
        if (iw1 < 0) i = 0;
        else i = 1;
        mdash = iw1/16 + i;
        pdash = 16*mdash - iw1;
#define _pow_q1 0.69314718055994529629
#define _pow_q2 0.24022650695909537056
#define _pow_q3 0.55504108664085595326e-1
#define _pow_q4 0.96181290595172416964e-2
#define _pow_q5 0.13333541313585784703e-2
#define _pow_q6 0.15400290440989764601e-3
#define _pow_q7 0.14928852680595608186e-4
        z = ((((((_pow_q7*w2 + _pow_q6)*w2 + _pow_q5)*w2 +
                  _pow_q4)*w2 + _pow_q3)*w2 + _pow_q2)*w2 + _pow_q1)*w2;
        z = a1[pdash] + a1[pdash]*z;
        z = frexp(z, &m);
        mdash += m;
        if (mdash >= 0x7ff-0x3fe)
        {   errno = ERANGE;
            if (sign) r = -HUGE_VAL;
            else r = HUGE_VAL;
        }
        else if (mdash <= -0x3fe)
        {   errno = ERANGE;
            r = 0.0;
        }
        else
        {   r = ldexp(z, mdash);
            if (sign) r = -r;
        }
    }
    return r;
}

#endif /* HOST_HAS_TRIG */

d409 4
d414 1
d433 1
a433 103
float atan2f(float y, float x)
{
    if (isunordered(y, x)) return y+x;

    if (y==0.0F || (isinf(x) && isfinite(y)))
        return signbit(x) ? copysignf((float)_pi_, y) : y;

    if (isinf(x)) /* y must also be infinite, from above */
        return copysignf(x > 0 ? (float)_pi_4 : (float)(3*_pi_4), y);

    if (fabsf(x) < fabsf(y)) /* handles infinite y, finite x */
    {   if (fabsf(x / y)<1.0e-12F)
        {   if (y<0.0F) return (float) - _pi_2;
            else return (float) _pi_2;
        }
    }
    y = atanf(y / x);
    if (x<0.0F)
    {   if (y>0.0F) y -= (float) _pi_;
        else y += (float) _pi_;
    }
    return y;
}

#ifndef HOST_HAS_TRIG
double hypot(double x, double y)
{
    #pragma STDC FENV_ACCESS ON
    int excepts;
    double p, q, r;
    fenv_t env;

    p = fabs(x);
    q = fabs(y);

    if (isunordered(p, q))
    {
        if (p == INFINITY || q == INFINITY)
            return INFINITY;
        else
            return p + q;
    }
    if (isless(p, q))
    {
        r = p; p = q; q = r;
    }

    if (p == 0 || q == INFINITY)
        return q;

    feholdexcept(&env);
    r = q / p;
    p = p * sqrt(1 + r * r);
    excepts = fetestexcept(FE_OVERFLOW);
    fesetenv(&env);
    if (excepts)
    {
        errno = ERANGE;
        return HUGE_VAL;
    }
    return p;
}

/* All over again, in floats */
float hypotf(float x, float y)
{
    #pragma STDC FENV_ACCESS ON
    int excepts;
    float p, q; double r;
    fenv_t env;
    float sqrtf(float);

    p = fabsf(x);
    q = fabsf(y);

    if (isunordered(p, q))
    {
        if (p == INFINITY || q == INFINITY)
            return INFINITY;
        else
            return p + q;
    }
    if (isless(p, q))
    {
        r = p; p = q; q = r;
    }

    if (p == 0 || q == INFINITY)
        return q;

    feholdexcept(&env);
    r = (double) q / p;
    p = (float) (p * sqrt(1 + r * r));
    excepts = fetestexcept(FE_OVERFLOW);
    fesetenv(&env);
    if (excepts)
    {
        errno = ERANGE;
        return HUGE_VAL;
    }
    return p;
}
#endif
d543 3
a545 1
    return (float)cosh(x);
d550 3
a552 1
    return (float)sinh(x);
d557 3
a559 1
    return (float)tanh(x);
d564 1
a564 2
    if (isless(x, 0.0))
        return -asinh(-x);
d566 1
a566 1
    if (x == 0) return x; // asinh(±0) returns ±0
d568 10
a577 1
    return log(x+hypot(x,1.0));
d582 1
d584 2
a585 2
    {   errno = EDOM;
        return NAN;
d587 9
a595 3

    // acosh(0) = 2.0*log(sqrt(1)+sqrt(0)) = 2.0*log(1) = +0
    return 2.0*log(sqrt((x+1)*0.5)+sqrt((x-1)*0.5));
d600 2
a601 4
    if (isless(x, 0.0))
        return -atanh(-x);

    if (x == 0) return x; // atanh(±0) returns ±0
d603 8
a610 9
    {   errno = EDOM;
        return NAN;
    }
    if (x == 1) // atanh(±1) returns ±inf
    {   errno = ERANGE;
        return HUGE_VAL;
    }

    return 0.5*log((1+x)/(1-x));
d613 1
d616 1
a616 6
    if (isless(x, 0.0F))
        return -asinhf(-x);

    if (x == 0) return x; // asinhf(±0) returns ±0

    return (float) log(x+hypot(x,1.0));
d621 1
a621 7
    if (isless(x, 1.0F))
    {   errno = EDOM;
        return NAN;
    }

    // acoshf(0) = 2.0*log(sqrt(1)+sqrt(0)) = 2.0*log(1) = +0
    return (float) (2.0*log(sqrt((x+1.0)*0.5)+sqrt((x-1.0)*0.5)));
d626 2
a627 2
    if (isless(x, 0.0F))
        return -atanhf(-x);
d629 52
a680 11
    if (x == 0) return x; // atanhf(±0) returns ±0
    if (isgreater(x, 1.0))
    {   errno = EDOM;
        return NAN;
    }
    if (x == 1) // atanhf(±1) returns ±inf
    {   errno = ERANGE;
        return HUGE_VALF;
    }

    return (float) (0.5*log((1.0+x)/(1.0-x)));
d683 1
a683 1
double fmod(double x, double y)
d685 40
a724 17
/* floating point remainder of (x/y) for integral quotient. Remainder    */
/* has same sign as x.                                                   */
    double q, r;
    if (y==0.0)
    {
      errno = EDOM;
      return -HUGE_VAL;
    }
    if (x==0.0) return 0.0;
    if (y < 0.0) y = -y;
    r = modf(x/y, &q);
    r = x - q * y;
/* The next few lines are an ultra-cautious scheme to ensure that the    */
/* result is less than fabs(y) in value and that it has the sign of x.   */
    if (x > 0.0)
    {   while (r >= y) r -= y;
        while (r < 0.0) r += y;
d727 19
a745 2
    {   while (r <= -y) r += y;
        while (r > 0.0) r -= y;
a746 1
    return r;
d749 1
a749 1
float fmodf(float x, float y)
d751 3
a753 23
/* floating point remainder of (x/y) for integral quotient. Remainder    */
/* has same sign as x.                                                   */
    float q, r;
    if (y==0.0F)
    {
      errno = EDOM;
      return -HUGE_VALF;
    }
    if (x==0.0F) return x;
    if (y < 0.0F) y = -y;
    r = modff(x/y, &q);
    r = x - q * y;
/* The next few lines are an ultra-cautious scheme to ensure that the    */
/* result is less than fabs(y) in value and that it has the sign of x.   */
    if (x > 0.0F)
    {   while (r >= y) r -= y;
        while (r < 0.0F) r += y;
    }
    else
    {   while (r <= -y) r += y;
        while (r > 0.0F) r -= y;
    }
    return r;
d756 1
a756 2
#if 0
double (floor)(double d)
d758 6
a763 14
/* round x down to an integer towards minus infinity.                    */
    fp_number x;
    int exponent, mask, exact;
    if (d == 0.0) return 0.0;
    x.d = d;                            /* pun on union type             */
    if ((exponent = x.i.x - 0x3ff) < 0)
    {   if (x.i.s) return -1.0;
        else return 0.0;
    }
    else if (exponent >= 52) return x.d;
    if (exponent >= 20)
    {   mask = ((unsigned) 0xffffffff) >> (exponent - 20);
        exact = x.i.mlo & mask;
        x.i.mlo &= ~mask;
d765 3
a767 8
    else
    {   mask = 0xfffff >> exponent;
        exact = (x.i.mhi & mask) | x.i.mlo;
        x.i.mhi &= ~mask;
        x.i.mlo = 0;
    }
    if (exact!=0 && x.i.s) return x.d - 1.0;
    else return x.d;
d770 1
a770 1
double (ceil)(double d)
d772 4
a775 23
/* round x up to an integer towards plus infinity.                       */
    fp_number x;
    int exponent, mask, exact;
    if (d == 0.0) return d;
    x.d = d;                            /* pun on union type             */
    if ((exponent = x.i.x - 0x3ff) < 0)
    {   if (x.i.s) return 0.0;
        else return 1.0;
    }
    else if (exponent >= 52) return x.d;
    if (exponent >= 20)
    {   mask = ((unsigned) 0xffffffff) >> (exponent - 20);
        exact = x.i.mlo & mask;
        x.i.mlo &= ~mask;
    }
    else
    {   mask = 0xfffff >> exponent;
        exact = (x.i.mhi & mask) | x.i.mlo;
        x.i.mhi &= ~mask;
        x.i.mlo = 0;
    }
    if (exact!=0 && x.i.s==0) return x.d + 1.0;
    else return x.d;
a776 1
#endif
d789 2
a792 1
double (sin)(double x)                 { return sin(x); }
a793 1
double (cos)(double x)                 { return cos(x); }
d795 5
d909 21
a929 18
#define _lgamma_c1   166599025.853949811570  // actually c[k]*sqrt(2*pi)
#define _lgamma_c2  -981939810.195007931170
#define _lgamma_c3   2548964102.46316408700
#define _lgamma_c4  -3836248618.43839895348
#define _lgamma_c5   3709080184.61731236844
#define _lgamma_c6  -2412708472.49486138749
#define _lgamma_c7   1075449464.75190680642
#define _lgamma_c8  -328534715.011179056348
#define _lgamma_c9   67752870.4715251633277
#define _lgamma_c10 -9145761.20044444915581
#define _lgamma_c11  768402.637723269577278
#define _lgamma_c12 -37175.9448951564986832
#define _lgamma_c13  917.944248521710658895
#define _lgamma_c14 -9.51510944794615044564
#define _lgamma_c15  0.0294177178100457006509
#define _lgamma_c16 -1.37185031730621246722e-5
#define _lgamma_c17  1.72316912091954830013e-10
#define _lgamma_c18 -2.50065513100139951901e-20
d933 16
a948 29
    /* Do it like this to avoid using client static data for an array */
    return _sqrt2pi
           + _lgamma_c1 / (x + 1)
           + _lgamma_c2 / (x + 2)
           + _lgamma_c3 / (x + 3)
           + _lgamma_c4 / (x + 4)
           + _lgamma_c5 / (x + 5)
           + _lgamma_c6 / (x + 6)
           + _lgamma_c7 / (x + 7)
           + _lgamma_c8 / (x + 8)
           + _lgamma_c9 / (x + 9)
           + _lgamma_c10 / (x + 10)
           + _lgamma_c11 / (x + 11)
           + _lgamma_c12 / (x + 12)
           + _lgamma_c13 / (x + 13)
           + _lgamma_c14 / (x + 14)
           + _lgamma_c15 / (x + 15)
           + _lgamma_c16 / (x + 16)
           + _lgamma_c17 / (x + 17)
           + _lgamma_c18 / (x + 18);
}

#define _lgammaf_c0  1.000000000190015
#define _lgammaf_c1  76.18009172947146
#define _lgammaf_c2 -86.50532032941677
#define _lgammaf_c3  24.01409824083091
#define _lgammaf_c4 -1.231739572450155
#define _lgammaf_c5  1.208650973866179e-3
#define _lgammaf_c6 -5.395239384953e-6
d952 4
a955 7
    return _lgammaf_c0
           + _lgammaf_c1 / (x + 1)
           + _lgammaf_c2 / (x + 2)
           + _lgammaf_c3 / (x + 3)
           + _lgammaf_c4 / (x + 4)
           + _lgammaf_c5 / (x + 5)
           + _lgammaf_c6 / (x + 6);
d966 2
a967 2
        {   errno = ERANGE;
            return HUGE_VAL;
d970 1
a970 1
        return log(fabs((1-x)*_pi_/sin(_pi_*x)))-lgamma(2-x);
d975 1
a975 1
    return (x+0.5)*log(x+18.5) - (x+18.5) + log(_gamma_sum(x) / x);
d986 2
a987 2
        {   errno = ERANGE;
            return HUGE_VALF;
d990 1
a990 1
        return (float) log(fabs((1.0-x)*_pi_/sin(_pi_*x)))-lgammaf(2-x);
d995 1
a995 1
    return (float) ((x+0.5)*log(x+5.5) - (x+5.5) + log(_sqrt2pi * _gammaf_sum(x) / x));
d1004 1
a1004 1
        {   errno = ERANGE;
d1011 1
a1011 3
    {   errno = ERANGE;
        return copysign(HUGE_VAL, x);
    }
d1016 1
a1016 1
        {   errno = EDOM;
d1030 1
a1030 1
    return exp(lgamma(x));
d1039 1
a1039 1
        {   errno = ERANGE;
d1046 1
a1046 3
    {   errno = ERANGE;
        return copysignf(HUGE_VALF, x);
    }
d1051 1
a1051 1
        {   errno = EDOM;
d1188 72
@


4.5
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@d38 1
d67 1
a67 1
        return 0.0;
d77 1
a77 1
/* I have already tested to see if d was zero so the fllowing loop MUST  */
d79 1
d87 6
d98 29
d134 1
a134 1
        return 0.0;
d142 14
d158 115
a272 1
double ldexp(double d, int n)
d274 94
a367 16
    fp_number d1;
    int nx;
    if (d==0.0) return 0.0;        /* special case                       */
    d1.d = d;
    nx = (int) d1.i.x + n;
    if (nx >= 0x7ff)
    { errno = ERANGE;
      return HUGE_VAL;              /* overflow yields 'infinity'        */
    }
/* Maybe I should be prepared to generate un-normalized numbers here, or */
/* even deal with input d un-normalized and n positive yielding a proper */
/* result. All that seems like a lot of work and so I will not even try  */
/* in this version of the code!                                          */
    else if (nx <= 0) return 0.0;  /* deal with underflow                */
    d1.i.x = nx;
    return (d1.d);
d370 3
d374 8
d852 9
a860 5
    if (x==0.0 && y==0.0)
    {   errno = EDOM;
        return -HUGE_VAL;
    }
    if (fabs(x) < fabs(y))
d874 24
d986 3
a988 2
    if (x<0.0) y = -x, sign = 1; else y = x, sign = 0;
    if (y>1.0)
d997 2
a998 1
        {   errno = ERANGE;
d1008 1
a1008 1
    else if (y<=1.0e-10) return x;
d1030 3
a1032 4
    if (x<0.0) x = -x;
    if (x>1.0)
    {
        x = x - _sinh_lnv;
d1034 2
a1035 1
        {   errno = ERANGE;
d1055 3
a1057 3
    if (x>27.0) return 1.0;         /* here exp(2x) dominates 1.0        */
    else if (x<-27.0) return -1.0;
    if (x<0.0) x = -x, sign = 1;
d1059 1
a1059 1
    if (x>0.549306144334054846)     /* ln(3)/2 is crossover point        */
d1072 1
a1072 1
    if (x>1.0e-10)
d1083 94
d1204 28
d1264 1
a1264 1
    if (d == 0.0) return 0.0;
d1285 1
d1287 1
a1287 1
/*double (ceil)(double x)                { return ceil(x); }*/
d1289 1
a1289 1
/*double (floor)(double x)               { return floor(x); }*/
d1299 1
a1299 1
/*float (atanf)(float x)                 { return atanf(x); }*/
d1301 1
a1301 1
/*float (sinf)(float x)                  { return sinf(x); }*/
d1303 1
a1303 1
/*float (cosf)(float x)                  { return cosf(x); }*/
d1311 2
a1312 2
    {   *iptr = 0.0;
        return 0.0;
d1316 1
a1316 1
    {   *iptr = 0.0;
d1321 1
a1321 1
        return 0.0;
d1336 24
d1384 325
@


4.4
log
@* Added C99 functions floorf, ceilf, [l]rint[f], trunc[f], [l]round[f],
  nearbyint[f] and remainder[f].
* Added macros (only) for sinf, cosf, atanf.
* Requires cc 5.43

Version 5.39. Tagged as 'RISC_OSLib-5_39'
@
text
@d57 1
a57 2
double frexp(d, lvn)
double d; int *lvn;
d92 1
a92 2
double frexp(d, lvn)
double d; int *lvn;
d107 1
a107 2
double ldexp(d, n)
double d; int n;
@


4.3
log
@* Added C99 extensions to strftime(). All basic specifiers supported, but "E"
  and "O" modifiers ignored.
* strftime specifiers %c, %X and %x for "C" locale changed to match C99.
* Optimised hypot[f].
* Missing hypotf() declaration added to <math.h>.
* Fixed Shared C Library - inadvertent change to static data size meant it was
  incompatible with the stubs.

Version 5.38. Tagged as 'RISC_OSLib-5_38'
@
text
@d48 1
d619 1
a619 1
/* Use the Moler-Morrison algorithm */
d622 4
a625 1
    double p, q, r, s;
d630 8
a637 18
    /* Ensure p <= q (putting NaNs in p and Infs in q). We avoid calling
     * functions like isnan() and isinf(), with their unwanted niceties
     * of not triggering signalling NaNs. If we can avoid calling any
     * functions, we save a lot of function call overhead.
     *
     * This ends up compiling neatly to:
     *
     *       CMF     p, q
     *       BGT     swap
     *       CMFVS   p, p
     *       BVC     cont
     * swap  MVFD    r, p
     *       MVFD    p, q
     *       MVFD    q, r
     * cont
     *
     */
    if (isgreater(p,q) || isunordered(p,q) && isunordered(p,p))
d642 12
a653 13
    /* More cunning ordering to only do two comparisons */
    if (q == INFINITY || p == 0.0) return q;
    if (isunordered(p, 0.0)) return p;

    for (;;)
    {
        r = q / p;
        r = r * r;
        s = r + 4.0;
        if (!islessgreater(s, 4.0)) return p;
        r = r / s;
        p = p + 2.0 * r * p;
        q = q * r;
d655 1
d661 5
a665 1
    float p, q, r, s;
d670 8
a677 1
    if (isgreater(p,q) || isunordered(p,q) && isunordered(p,p))
d682 2
a683 2
    if (q == INFINITY || p == 0.0F) return q;
    if (isunordered(p, 0.0F)) return p;
d685 6
a690 1
    for (;;)
d692 2
a693 7
        r = q / p;
        r = r * r;
        s = r + 4.0F;
        if (!islessgreater(s, 4.0F)) return p;
        r = r / s;
        p = p + 2.0F * r * p;
        q = q * r;
d695 1
d697 1
d829 1
a829 1
double floor(double d)
d856 1
a856 1
double ceil(double d)
d882 18
@


4.2
log
@Added the following C99 features:

  * snprintf(), vsnprintf(), vfscanf(), vscanf(), vsscanf()
  * hh, j, z and t printf length modifiers (indicating char, intmax_t, size_t
    and ptrdiff_t respectively)
  * Hexadecimal floating-point printing and scanning (%a/%A)
  * %F printf() specifier (upper-case form of %F)
  * Input/output of NaNs and Infinities
  * imaxdiv_t, imaxdiv(), strtoimax(), strtoumax() (simulated through macros)
  * <fenv.h>: feclearexcept(), fegetexceptflag(), feraiseexcept(),
              fesetexceptflag(), fetestexcept(), fegetround(), fesetround(),
              fegetenv(), feholdexcept(), fesetenv(), feupdateenv()
  * FLT_EVAL_METHOD, DECIMAL_DIG
  * hypot(), hypotf(), fabsf(), fdim(), fdimf(), fmax(), fmaxf(), fmin(),
    fminf()
  * INFINITY, NAN, fpclassify(), isfinite(), isinf(), isnan(), isnormal(),
    signbit(), copysign(), copysignf(), nan(), nanf(), nextafter(),
    nextafterf() isgreater(), isgreaterequal(), isless(), islessequal(),
    islessgreater(), isunordered()

This involves adding 36 new entries to the stubs. Current versions of the C
library will not fault client programs with such larger stubs, but will fill
in the extra entries with junk. Programs requiring the new functions will have
to RMEnsure this version of the Shared C Library.

This version of the C library has been fixed so that in future, any extra
unknown stubs entries will be filled in with a branch to zero, rather than
corrupted.

Requires cc 5.41 or later, both to build, and to make use of some of the extra
facilities.


Version 5.37. Tagged as 'RISC_OSLib-5_37'
@
text
@d618 1
a622 2
    /* Use the Moler-Morrison algorithm */

d626 16
a641 5
    /* Ensure p <= q (putting NaNs in p and Infs in q). p!=p is a
     * simple NaN check without the function call overhead of isnan()
     * [it has the nicety of not trapping signalling NaNs, which we don't
     * need]. If we can avoid calling any functions, we save a lot of
     * overhead.
d643 1
a643 1
    if (isgreater(p,q) || isunordered(p,q) && p!=p)
d648 3
a650 2
    if (p == 0.0 || q == INFINITY) return q;
    if (p != p) return p;
d657 1
a657 2
        /* The compiler is capable of optimising multiple comparisons */
        if (s == 4.0 || isunordered(s, 4.0)) return p;
d672 1
a672 1
    if (isgreater(p,q) || isunordered(p,q) && p!=p)
d677 2
a678 2
    if (p == 0.0F || q == INFINITY) return q;
    if (p != p) return p;
d685 1
a685 1
        if (s == 4.0F || isunordered(s, 4.0F)) return p;
@


4.1
log
@Initial revision
@
text
@a48 3
#ifdef IBMFLOAT
const double __huge_val = 7.2370055773322621e+75;
#else
a51 1
#endif
a52 80
#ifdef IBMFLOAT

double frexp(d, lvn)
double d; int *lvn;
{
    fp_number d1;
    int n;
    if (d==0.0)
/* I worry a little about signed zeros here. I hope that -0.0 == 0.0     */
    {   *lvn = 0;
        return 0.0;
    }
    d1.d = d;
    n = 4*(d1.i.x - 0x40);        /* excess 64 exponent */
    d1.i.x = 0x40;
    d = d1.d;
    /* Note that the following code works for unnormalised numbers, but  */
    /* can then take 55 cycles to converge instead of usual 3 max.       */
    while ((d>=0 ? d : -d) < 0.5) d = d+d, n--;
    /* Now d is most definitely normalised.                              */
    *lvn = n;
    return d;
}


double ldexp(d, n)
double d; int n;
{
    fp_number d1;
    int nx;
    if (d==0.0) return 0.0;         /* special case                      */
    d1.d = d;
    nx = d1.i.x + (n & ~3)/4;
    n &= 3;
#ifndef DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS
    /* The following code gets the msd/expt right for unnormalised nos.  */
    d1.i.x = 0x40;
    d1.d += 0.0;                    /* i.e. normalise                    */
    nx += d1.i.x - 0x40;
#endif
    {   int mhi = d1.i.mhi;
        int nx1 = (mhi & 0x00c00000)==0 ?
                   ((mhi & 0x00200000)==0 ? n - 3 : n - 2) :
                   ((mhi & 0x00800000)==0 ? n - 1 : n);
        if (nx1 > 0) nx++, n -= 4;
/* That just dealt with the fact that in IBM format the exponent is for  */
/* base 16 and so scaling by a power of two can involve a real multiply. */
/* I now know what the true exponent (nx) in the result will be.         */
    }
    if (nx > 0x7f)                  /* Overflow (maybe do a raise() ?)   */
    {   d1.i.x = 0x7f;
        d1.i.mhi = 0xffffff;
        d1.i.mlo = 0xffffffff;
        return d1.d;
    }
    if (nx < 0)                     /* Deal with underflow/unnormalised  */
    {   if (nx <= -14) return 0.0;
        d1.i.x = 0;
        while (nx < 0) d1.d /= 16, nx++;     /* de-normalise gracefully  */
    }
    d1.i.x = nx;
    {   double d2;
        switch (n)
        {
case -3:d2 = 0.125; break;
case -2:d2 = 0.25;  break;
case -1:d2 = 0.5;   break;
default:   /* avoid dataflow whinge */
case 0: d2 = 1.0;   break;
case 1: d2 = 2.0;   break;
case 2: d2 = 4.0;   break;
case 3: d2 = 8.0;   break;
        }
        d1.d *= d2;
    }
    return d1.d;
}


#else       /* Here is the IEEE format stuff */
a128 1
#endif
a130 3
#ifdef IBMFLOAT
#define _exp_arg_limit 174.673089501106208
#else
a131 1
#endif
a204 3
#ifdef IBMFLOAT
#define _exp_negative_arg_limit -180.218266945585778
#else
a208 1
#endif
a222 6
#ifdef IBMFLOAT
    {   double x1 = (double)(int)x;
        double x2 = x - x1;
        g = ((x1 - xn * 0.693359375) + x2) - xn * (-2.1219444005469058277e-4);
    }
#else
a223 1
#endif
a289 4
#ifdef IBMFLOAT
    n = f.i.x - 0x40;
    f.i.x = 0x40;
#else
a291 1
#endif
a292 3
#ifdef IBMFLOAT
        y0 = 0.223607 + 0.894427 * fd;
#else
a293 1
#endif
a296 4
#ifdef IBMFLOAT
#define __EPS 2.2204460492503131e-16
        y0 = y0 + (0.5 * (fd/y0 - y0) + __EPS/32.0);
#endif
a299 3
#ifdef IBMFLOAT
        y0 = (y0 + __EPS/8.0) * 0.25;
#else
a300 1
#endif
a320 6
#ifdef IBMFLOAT
    {   double x1 = (double)(int)x;
        double x2 = x - x1;
        f = ((x1 - xn*1.57080078125) + x2) + xn*4.454455103380768678308e-6;
    }
#else
a321 1
#endif
a469 33
#ifdef IBMFLOAT
    const static double a1[17] = {
/* It is painfully important that the following 17 floating point        */
/* numbers are read in to yield the quantities shown on the right.       */
        1.000000000000000000,    /* 41100000:00000000 */
        0.957603280698573644,    /* 40f5257d:152486cc */
        0.917004043204671229,    /* 40eac0c6:e7dd2439 */
        0.878126080186649740,    /* 40e0ccde:ec2a94e1 */
        0.840896415253714543,    /* 40d744fc:cad69d6b */
        0.805245165974627155,    /* 40ce248c:151f8481 */
        0.771105412703970413,    /* 40c5672a:115506db */
        0.738413072969749659,    /* 40bd08a3:9f580c37 */
        0.707106781186547531,    /* 40b504f3:33f9de65 */
        0.677127773468446367,    /* 40ad583e:ea42a14b */
        0.648419777325504834,    /* 40a5fed6:a9b15139 */
        0.620928906036742028,    /* 409ef532:6091a112 */
        0.594603557501360527,    /* 409837f0:518db8a9 */
        0.569394317378345823,    /* 4091c3d3:73ab11c3 */
        0.545253866332628830,    /* 408b95c1:e3ea8bd7 */
        0.522136891213706919,    /* 4085aac3:67cc487b */
        0.500000000000000000     /* 40800000:00000000 */
        };
    const static double a2[8] = {
        2.4114209503420287e-18,
        9.2291566937243078e-19,
        -1.5241915231122319e-18,
        -3.5421849765286817e-18,
        -3.1286215245415074e-18,
        -4.4654376565694489e-18,
        2.9305146686217562e-18,
        1.1260851040933474e-18
        };
#else /* IEEE format */
a500 1
#endif
a553 3
#ifdef IBMFLOAT
#  define _negative_pow_limit -4160
#else
a554 1
#endif
a578 11
#ifdef IBMFLOAT
        if (mdash > 0x3f*4)
        {   errno = ERANGE;
            if (sign) r = -HUGE_VAL;
            else r = HUGE_VAL;
        }
        else if (mdash <= -0x41*4)
        {   errno = ERANGE;
            r = 0.0;
        }
#else
a587 1
#endif
d618 35
a652 1
#undef fabs
d654 2
a655 1
double fabs(double x)
d657 23
a679 2
    if (x<0.0) return -x;
    else return x;
d682 4
a811 89
#ifdef IBMFLOAT

double floor(double d)
{
/* round x down to an integer towards minus infinity.                    */
    fp_number x;
    int exponent, mask, exact;
    if (d == 0.0) return 0.0;
    x.d = d;                            /* pun on union type             */
    if ((exponent = x.i.x - 0x40) < 0)
    {   if (x.i.s) return -1.0;
        else return 0.0;
    }
    else if (exponent >= 56/4) return x.d;
    if (exponent >= 24/4)
    {   mask = ((unsigned) 0xffffffff) >> (4*(exponent - 24));
        exact = x.i.mlo & mask;
        x.i.mlo &= ~mask;
    }
    else
    {   mask = 0xfffff >> (4*exponent);
        exact = (x.i.mhi & mask) | x.i.mlo;
        x.i.mhi &= ~mask;
        x.i.mlo = 0;
    }
    if (exact!=0 && x.i.s) return x.d - 1.0;
    else return x.d;
}

double ceil(double d)
{
/* round x up to an integer towards plus infinity.                       */
    fp_number x;
    int exponent, mask, exact;
    if (d == 0.0) return 0.0;
    x.d = d;                            /* pun on union type             */
    if ((exponent = x.i.x - 0x40) < 0)
    {   if (x.i.s) return 0.0;
        else return 1.0;
    }
    else if (exponent >= 56/4) return x.d;
    if (exponent >= 24/4)
    {   mask = ((unsigned) 0xffffffff) >> (4*(exponent - 24));
        exact = x.i.mlo & mask;
        x.i.mlo &= ~mask;
    }
    else
    {   mask = 0xfffff >> (4*exponent);
        exact = (x.i.mhi & mask) | x.i.mlo;
        x.i.mhi &= ~mask;
        x.i.mlo = 0;
    }
    if (exact!=0 && x.i.s==0) return x.d + 1.0;
    else return x.d;
}

double modf(double value, double *iptr)
{
/* splits value into integral part & fraction (both same sign)           */
    fp_number x;
    int exponent, mask;
    if (value == 0.0)
    {   *iptr = 0.0;
        return 0.0;
    }
    x.d = value;
    if ((exponent = x.i.x - 0x40) < 0)
    {   *iptr = 0.0;
        return value;
    }
    else if (exponent >= 56/4)
    {   *iptr = value;
        return 0.0;
    }
    if (exponent >= 24/4)
    {   mask = ((unsigned) 0xffffffff) >> (4*(exponent - 24));
        x.i.mlo &= ~mask;
    }
    else
    {   mask = 0xffffff >> (4*exponent);
        x.i.mhi &= ~mask;
        x.i.mlo = 0;
    }
    *iptr = x.d;
    return value - x.d;
}

#else /* IBMFLOAT */

d897 26
a922 1
#endif /* IBMFLOAT */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

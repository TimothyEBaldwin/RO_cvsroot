head	4.3;
access;
symbols
	RISC_OSLib-5_97:4.3
	RISC_OSLib-5_96:4.3
	RISC_OSLib-5_95:4.3
	RISC_OSLib-5_94:4.3
	RISC_OSLib-5_93:4.3
	RISC_OSLib-5_92:4.3
	RISC_OSLib-5_91:4.3
	RISC_OSLib-5_90:4.3
	RISC_OSLib-5_89:4.3
	RISC_OSLib-5_88:4.3
	RISC_OSLib-5_87:4.3
	RISC_OSLib-5_86-1:4.3
	RISC_OSLib-5_86:4.3
	RISC_OSLib-5_85:4.3
	RISC_OSLib-5_84:4.3
	RISC_OSLib-5_83-2:4.3
	RISC_OSLib-5_83-1:4.3
	RISC_OSLib-5_83:4.3
	RISC_OSLib-5_82:4.3
	RISC_OSLib-5_81:4.3
	RISC_OSLib-5_75-2:4.3
	RISC_OSLib-5_80:4.3
	RISC_OSLib-5_79:4.3
	RISC_OSLib-5_78:4.3
	RISC_OSLib-5_75-1:4.3
	RISC_OSLib-5_77:4.3
	RISC_OSLib-5_76:4.3
	RISC_OSLib-5_75:4.3
	RISC_OSLib-5_74:4.3
	RISC_OSLib-5_73:4.3
	RISC_OSLib-5_72:4.3
	RISC_OSLib-5_71:4.3
	RISC_OSLib-5_70:4.3
	RISC_OSLib-5_69:4.3
	RISC_OSLib-5_68:4.3
	RISC_OSLib-5_67:4.3
	RISC_OSLib-5_66:4.3
	RISC_OSLib-5_65:4.3
	RISC_OSLib-5_64:4.3
	RISC_OSLib-5_63:4.3
	RISC_OSLib-5_62:4.3
	RISC_OSLib-5_61:4.3
	RISC_OSLib-5_60:4.3
	RISC_OSLib-5_59:4.3
	RISC_OSLib-5_58:4.3
	RISC_OSLib-5_57:4.3
	RISC_OSLib-5_56:4.3
	RISC_OSLib-5_55:4.3
	RISC_OSLib-5_54:4.3
	RISC_OSLib-5_53:4.3
	RISC_OSLib-5_52:4.3
	RISC_OSLib-5_51:4.3
	RO_5_07:4.3
	RISC_OSLib-5_50:4.3
	RISC_OSLib-5_49:4.3
	RISC_OSLib-5_46-4_64_2_1:4.3
	NoInlineAsm:4.3.0.8
	RISC_OSLib-5_48:4.3
	RISC_OSLib-5_47:4.3
	RISC_OSLib-5_46:4.3
	RISC_OSLib-5_45:4.3
	RISC_OSLib-5_44:4.3
	RISC_OSLib-5_43:4.3
	RISC_OSLib-5_42:4.3
	RISC_OSLib-5_41:4.3
	RISC_OSLib-5_40:4.3
	RISC_OSLib-5_39:4.3
	RISC_OSLib-5_38:4.3
	RISC_OSLib-5_37:4.3
	RISC_OSLib-5_36:4.3
	RISC_OSLib-5_35:4.3
	RISC_OSLib-5_34:4.3
	RISC_OSLib-5_33-4_50_2_1:4.3
	sbrodie_dev:4.3.0.6
	sbrodie_dev_bp:4.3
	RISC_OSLib-5_33:4.3
	RISC_OSLib-5_32:4.3
	RISC_OSLib-5_31:4.3
	RISC_OSLib-5_30:4.3
	RISC_OSLib-5_29:4.3
	RISC_OSLib-5_28:4.3
	RISC_OSLib-5_27:4.3
	RISC_OSLib-5_26:4.3
	RISC_OSLib-5_25:4.3
	RISC_OSLib-5_24:4.3
	RISC_OSLib-5_01-4_16_2_5:4.3
	RISC_OSLib-5_23:4.3
	RISC_OSLib-5_22:4.3
	RISC_OSLib-5_21:4.3
	RISC_OSLib-5_20:4.3
	RISC_OSLib-5_19:4.3
	RISC_OSLib-5_18:4.3
	RISC_OSLib-5_17:4.3
	RISC_OSLib-5_16:4.3
	RISC_OSLib-5_15:4.3
	dellis_autobuild_BaseSW:4.3
	RISC_OSLib-5_14:4.3
	RISC_OSLib-5_13:4.3
	RISC_OSLib-5_12:4.3
	RISC_OSLib-5_01-4_16_2_4:4.3
	RISC_OSLib-5_11:4.3
	RISC_OSLib-5_01-4_16_2_3:4.3
	RISC_OSLib-5_01-4_16_2_2:4.3
	RISC_OSLib-5_10:4.3
	RISC_OSLib-5_01-4_16_2_1:4.3
	Bethany:4.3.0.4
	RISC_OSLib-5_09:4.3
	RISC_OSLib-5_08:4.3
	RISC_OSLib-5_07:4.3
	RISC_OSLib-5_06:4.3
	RISC_OSLib-4_97-4_12_2_8:4.3
	RISC_OSLib-5_05:4.3
	RISC_OSLib-5_04:4.3
	sbrodie_sedwards_16Mar2000:4.3
	RISC_OSLib-5_03:4.3
	RISC_OSLib-5_02:4.3
	RISC_OSLib-4_97-4_12_2_7:4.3
	RISC_OSLib-5_01:4.3
	RISC_OSLib-5_00:4.3
	RISC_OSLib-4_99:4.3
	RISC_OSLib-4_98:4.3
	RISC_OSLib-4_97-4_12_2_6:4.3
	RISC_OSLib-4_97-4_12_2_5:4.3
	RISC_OSLib-4_97-4_12_2_4:4.3
	RISC_OSLib-4_97-4_12_2_3:4.3
	RISC_OSLib-4_97-4_12_2_2:4.3
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.3
	kbracey_32bit:4.3.0.2
	kbracey_32bit_bp:4.3
	dcotton_autobuild_BaseSW:4.3
	RISC_OSLib-4_97:4.3
	RISC_OSLib-4_96:4.3
	RISC_OSLib-4_95:4.2
	RISC_OSLib-4_94:4.2
	RISC_OSLib-4_93:4.2
	RISC_OSLib-4_92:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.2
	RISC_OSLib-4_90:4.2
	RISC_OSLib-4_89:4.2
	Ursula_merge:4.1.4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.3
date	99.09.21.10.21.28;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	98.10.01.09.14.15;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.49;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.24.49;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.53;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.04.14.10.00.33;	author rthornb;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.27.18;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.36;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.3
log
@  Fix for qsort to stop aborts.
Detail:
  If qsort is passed an invalid base pointer and the number of entries
    is zero, then due to some pointer artihmetic going wrong, it aborts.
    The fix is to trap zero length arrays and exit quickly.
Admin:
  Required by cmhg prior to version 5.20 which had an explicit fix to
    prevent triggering this bug.
  Reportedly this fix is required by PhotoDesk prior to version 3.03.

Version 4.96. Tagged as 'RISC_OSLib-4_96'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* sort.c: ANSI draft (X3J11 Oct 86) library, section 4.10 */
/* Copyright (C) Codemist Ltd, 1988                        */
/* version 0.02 */

#include "hostsys.h"
#include <stddef.h>
#include <stdlib.h>
#include "kernel.h"

/* Sorting and searching procedures. Separate from the rest of stdlib
   since stdlib will often be loaded (for exit(), e.g.) but these things
   are often not needed (and are quite large)
*/

#define Compar_(a, b) (_call_client_2(compar, a, b))

void *bsearch(const void *key, const void *base,
              size_t nmemb, size_t size,
              int (*compar)(const void *, const void *))
{
/* Binary search for given key in a sorted array (starting at base).     */
/* Comparisons are performed using the given function, and the array has */
/* nmemb items in it, each of size bytes.                                */
    int midn, c;
    void *midp;
    for (;;)
    {   if (nmemb==0) return NULL;      /* not found at all.             */
        else if (nmemb==1)
/* If there is only one item left in the array it is the only one that   */
/* needs to be looked at.                                                */
        {   if (Compar_(key, base)==0) return (void *)base;
            else return NULL;
        }
        midn = nmemb>>1;                /* index of middle item          */
/* I have to cast bast to (char *) here so that the addition will be     */
/* performed using natural machine arithmetic.                           */
        midp = (char *)base + midn * size;
        c = Compar_(key, midp);
        if (c==0) return midp;          /* item found (by accident)      */
        else if (c<0) nmemb = midn;     /* key is to left of midpoint    */
        else                            /* key is to the right           */
        {   base = (char *)midp + size; /* exclude the midpoint          */
            nmemb = nmemb - midn - 1;
        }
        continue;
    }
}

/* must not use Shellsort - it is broken (subtracts potentially large
   offsets from pointers before comparing with base, can wrap) */
/* #ifndef UROM */
#if 1
/* Qsort is implemented using an explicit stack rather than C recursion  */
/* See Sedgewick (Algorithms, Addison Wesley, 1983) for discussion.      */


#define STACKSIZE 32
#define SUBDIVISION_LIMIT 10

#define exchange(p1, p2, size)                      \
{                                                   \
    int xsize = size;                               \
    if (((xsize | (int) p1) & 0x3)==0)              \
    {   do                                          \
        {   int temp = *(int *)p1;                  \
            *(int *)p1 = *(int *)p2;                \
            *(int *)p2 = temp;                      \
            p1 += 4;                                \
            p2 += 4;                                \
            xsize -= 4;;                            \
        } while (xsize != 0);                       \
    }                                               \
    else                                            \
    {   do                                          \
        {   char temp = *p1;                        \
            *p1++ = *p2;                            \
            *p2++ = temp;                           \
            xsize--;                                \
        } while (xsize != 0);                       \
    }                                               \
    p1 -= size;                                     \
    p2 -= size;                                     \
}

#define stack(p, n)                                 \
    (basestack[stackpointer] = (void *) (p),        \
     sizestack[stackpointer++] = (n))



static void partition_sort(void *base, size_t nmemb, size_t size,
                           int (*compar)(const void *, const void *))
{
    int stackpointer = 1;
    void *basestack[STACKSIZE];
    int sizestack[STACKSIZE];
/* The explicit stack that is used here is large enough for any array    */
/* that could exist on this computer - since I stack sub-intervals in a  */
/* careful order I can guarantee that the depth of stack needed is       */
/* bounded by log2(nmemb), so I can certainly handle arrays of up to     */
/* size 2**STACKSIZE, which is bigger than my address space.             */
/* I require that SUBDIVISION_LIMIT >= 2 so that all segments to be      */
/* partitioned have at least 3 items in them. This means that the first, */
/* middle and last items in a segment are distinct (although they may,   */
/* of course, have the same value).                                      */
    basestack[0] = base;
    sizestack[0] = nmemb;
    while (stackpointer!=0)
    {   char *b = (char *) basestack[--stackpointer];
        int n = sizestack[stackpointer];
/* The for loop here marks where we re-enter the code having refined an  */
/* interval.                                                             */
        for (;;)
        {   int halfn = (n >> 1) * size;  /* index of middle in the list */
            char *bmid = b + halfn;
            char *btop;
            if ((n & 1) == 0) halfn -= size;
            btop = bmid + halfn;
/* Sort first, middle and last items in the segment into order. Put the  */
/* smallest and largest at the start and end of the segment (where they  */
/* act as sentinel values in a conveniant way) and use the median of 3   */
/* as my pivot. This happens to ensure that sorted and inverse sorted    */
/* input gets pivoted neatly and costs n*log n operations, even though   */
/* there are STILL worst cases that take about n*n operations.           */
            if (Compar_(b, bmid) > 0) exchange(b, bmid, size);
            if (Compar_(bmid, btop) > 0)
            {   if (Compar_(b, btop) > 0) exchange(b, btop, size);
                exchange(bmid, btop, size);
            }
/* Now I have the first and last elements in place & a useful pivot.     */
            {   char *l;
                char *r = btop - size;
                char *pivot;
                int s1, s2;
                exchange(bmid, r, size);
                l = b;
                pivot = r;
/* Sweep inwards partitioning elements on the basis of the pivot         */
                for (;;)
                {   do l += size; while (Compar_(l, pivot) < 0);
                    do r -= size; while (Compar_(r, pivot) > 0);
                    if (r <= l) break;
                    exchange(l, r, size);
                }
/* Move the pivot value to the middle of the array where it wants to be. */
                exchange(l, pivot, size);
/* s1 and s2 get the sizes of the sublists that I have partitioned my    */
/* data into. Note that s1 + s2 = n - 1 since the pivot element is now   */
/* in its correct place.                                                 */
                s1 = ((l - b)/ size) - 1;
                s2 = n - s1 - 1;
/* I am not going to try partitioning things that are smaller than some  */
/* fairly arbitrary small size (SUBDIVISION_LIMIT), and (only) if I will */
/* have to subdivide BOTH remaining intervals I push the larger of them  */
/* onto a stack for later consideration.                                 */
                if (s1 > s2)
/* Here the segment (b, s1) is the larger....                            */
                {   if (s2 > SUBDIVISION_LIMIT)
/* If the smaller segment needs subdividing then a fortiori the larger   */
/* one does, and needs stacking.                                         */
                    {   stack(b, s1);
                        b = l;
                        n = s2;
                    }
/* If just the larger segment needs dividing more I can loop.            */
                    else if (s1 > SUBDIVISION_LIMIT) n = s1;
/* If both segments are now small I break out of the loop.               */
                    else break;
                }
                else
/* Similar considerations apply if (l, s2) is the larger segment.        */
                {   if (s1 > SUBDIVISION_LIMIT)
                    {   stack(l, s2);
                        n = s1;
                    }
                    else if (s2 > SUBDIVISION_LIMIT)
                    {   b = l;
                        n = s2;
                    }
                    else break;
                }
            }
        }
    }
}

void qsort(void *base, size_t nmemb, size_t size,
           int (*compar)(const void *, const void *))
{
/* Sort an array (base) with nmemb items each of size bytes.             */
/* This uses a quicksort method, but one that is arranged to complete in */
/* about n*log(n) steps for sorted and inverse sorted inputs.            */
    char *b, *endp;
/* SNB 990921: The nmemb == 0 fast exit test was added because if the    */
/* caller passed nmemb as 0 and base as a null pointer, the pointer      */
/* arithmetic goes bang.                                                 */
    if (size == 0 || nmemb == 0) return;
    if (nmemb > SUBDIVISION_LIMIT)
        partition_sort(base, nmemb, size, compar);
/* Now I do an insertion sort on the array that is left over. This makes */
/* sense because the quicksort activity above has arranged that the      */
/* array is nearly sorted - at most segments of size SUBDIVISION_LIMIT   */
/* contain locally unsorted segments. In this case insertion sort goes   */
/* as fast as anything else. Doing things this way avoids the need for   */
/* a certain amount of partitioning/recursing overhead in the main body  */
/* of the quicksort procedure.                                           */
/* Note: some sorts of bugs in the above quicksort could be compensated  */
/* for here, leaving this entire procedure as just an insertion sort.    */
/* This would yield correct results but would be somewhat slow.          */
    b = (char *) base;
    endp = b + (nmemb-1) * size;
    while (b < endp)
    {   char *b1 = b;
        b += size;
/* Find out where to insert this item.                                   */
        while (b1>=(char *)base && Compar_(b1, b)>0) b1 -= size;
        b1 += size;
/* The fact that I do not know how large the objects that are being      */
/* sorted are is horrible - I do an exchange here copying things one     */
/* word at a time or one byte at a time depending on the value of size.  */
        if (((size | (int) b) & 0x3)==0)
        {   int j;
            for (j=0; j<size; j+=4)
            {   char *bx = b + j;
/* Even when moving word by word I use (char *) pointers so as to avoid  */
/* muddles about pointer arithmetic. I cast to (int *) pointers when I   */
/* am about to dereference something.                                    */
                int save = *(int *)bx;
                char *by = bx - size;
                while (by>=b1)
                {   *(int *)(by + size) = *(int *)by;
                    by -= size;
                }
                *(int *)(by + size) = save;
            }
        }
        else
/* If size is not a multiple of 4 I behave with great caution and copy   */
/* byte by byte. I could, of course, copy by words up to the last 1, 2   */
/* or 3 bytes - I count that as too much effort for now.                 */
        {   int j;
            for (j=0; j<size; j++)
            {   char *bx = b + j;
                char save = *bx;
                char *by = bx - size;
                while (by>=b1)
                {   *(by + size) = *by;
                    by -= size;
                }
                *(by + size) = save;
            }
        }
    }
}
#else
/* this is broken - see comments at top of #if */

/* For ROM version we use Shellsort instead of Quicksort for a saving of 880
 * bytes. This Shellsort has proven worst case < N^1.5, empirically it is
 * much better. Typical average case is either N(LOG(N)^2) or N^1.25.
 * Thus N has to be quite large for Quickort to produce any significant win,
 * especially given the higher overheads of Quicksort.
 *
 * Testing this on a file containing 25145 words in random order gives
 * Quicksort: 192 csec, Shellsort 286 csec. QED.
 */
void qsort(void *base, size_t nmemb, size_t size,
           int (*compar)(const void *, const void *))
{
    char *p1, *p2, *pi, *pj, *pe;
    size_t h, hsize, xsize;
    int t;

    pe = (char *)base + nmemb * size;
    h = 1;
    do
        h = h * 3 + 1;
    while (h <= nmemb);
    do {
        h = h / 3;
        hsize = h * size;
        for (pi = (char *)base + hsize; pi < pe; pi += size) {
            pj = pi - hsize;
            if (Compar_(pj, pi) > 0) {
                do {
                    pj -= hsize;
                } while (pj >= (char *)base && Compar_(pj, pi) > 0);
                xsize = size;
                pj += hsize;
                if (((xsize | (int)pi) & 0x3) == 0) {
                    do {
                        p1 = pi; p2 = pi - hsize;
                        t = *(int *)pi;
                        pi += 4;
                        do {
                            *(int *)p1 = *(int *)p2;
                            p1 -= hsize; /* one of the broken bits */
                            p2 -= hsize;
                        } while (p2 >= pj);
                        *(int *)pj = t;
                        pj += 4;
                        xsize -= 4;
                    } while (xsize != 0);
                } else {
                    do {
                        p1 = pi; p2 = pi - hsize;
                        t = *pi++;
                        do {
                            *p1 = *p2;
                            p1 -= hsize;
                            p2 -= hsize;
                        } while (p2 >= pj);
                        *pj++ = t;
                        xsize--;
                    } while (xsize != 0);
                }
                pi -= size;
            }
        }
    } while (h > 1);
}
#endif

/* end of sort.c */
@


4.2
log
@Ursula branch merged.
StrongARMfudge flag removed.
StrongARM compatibility set according to AMBKernel flag in Hdr:RISCOS
strftime %U and %W specifiers fixed for week 0.

Version 4.89. Tagged as 'RISC_OSLib-4_89'
@
text
@d209 4
a212 1
    if (size == 0) return;
@


4.1
log
@Initial revision
@
text
@d64 4
a67 2

#ifndef UROM
d268 2
d309 1
a309 1
                            p1 -= hsize;
@


4.1.4.1
log
@ROM qsort () function is broken so it has been fixed to use the RAM qsort ()
in both cases.
@
text
@d64 2
a65 4
/* must not use Shellsort - it is broken (subtracts potentially large
   offsets from pointers before comparing with base, can wrap) */
/* #ifndef UROM */
#if 1
a265 2
/* this is broken - see comments at top of #if */

d305 1
a305 1
                            p1 -= hsize; /* one of the broken bits */
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

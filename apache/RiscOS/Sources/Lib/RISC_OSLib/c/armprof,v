head	4.4;
access;
symbols
	RISC_OSLib-5_97:4.4
	RISC_OSLib-5_96:4.4
	RISC_OSLib-5_95:4.4
	RISC_OSLib-5_94:4.4
	RISC_OSLib-5_93:4.4
	RISC_OSLib-5_92:4.4
	RISC_OSLib-5_91:4.4
	RISC_OSLib-5_90:4.4
	RISC_OSLib-5_89:4.4
	RISC_OSLib-5_88:4.4
	RISC_OSLib-5_87:4.4
	RISC_OSLib-5_86-1:4.4
	RISC_OSLib-5_86:4.4
	RISC_OSLib-5_85:4.4
	RISC_OSLib-5_84:4.4
	RISC_OSLib-5_83-2:4.4
	RISC_OSLib-5_83-1:4.4
	RISC_OSLib-5_83:4.4
	RISC_OSLib-5_82:4.4
	RISC_OSLib-5_81:4.4
	RISC_OSLib-5_75-2:4.4
	RISC_OSLib-5_80:4.4
	RISC_OSLib-5_79:4.4
	RISC_OSLib-5_78:4.4
	RISC_OSLib-5_75-1:4.4
	RISC_OSLib-5_77:4.4
	RISC_OSLib-5_76:4.4
	RISC_OSLib-5_75:4.4
	RISC_OSLib-5_74:4.4
	RISC_OSLib-5_73:4.4
	RISC_OSLib-5_72:4.4
	RISC_OSLib-5_71:4.4
	RISC_OSLib-5_70:4.4
	RISC_OSLib-5_69:4.4
	RISC_OSLib-5_68:4.4
	RISC_OSLib-5_67:4.4
	RISC_OSLib-5_66:4.4
	RISC_OSLib-5_65:4.4
	RISC_OSLib-5_64:4.4
	RISC_OSLib-5_63:4.4
	RISC_OSLib-5_62:4.4
	RISC_OSLib-5_61:4.4
	RISC_OSLib-5_60:4.4
	RISC_OSLib-5_59:4.4
	RISC_OSLib-5_58:4.4
	RISC_OSLib-5_57:4.4
	RISC_OSLib-5_56:4.4
	RISC_OSLib-5_55:4.4
	RISC_OSLib-5_54:4.4
	RISC_OSLib-5_53:4.4
	RISC_OSLib-5_52:4.4
	RISC_OSLib-5_51:4.4
	RO_5_07:4.4
	RISC_OSLib-5_50:4.4
	RISC_OSLib-5_49:4.4
	RISC_OSLib-5_46-4_64_2_1:4.4
	NoInlineAsm:4.4.0.4
	RISC_OSLib-5_48:4.4
	RISC_OSLib-5_47:4.4
	RISC_OSLib-5_46:4.4
	RISC_OSLib-5_45:4.4
	RISC_OSLib-5_44:4.4
	RISC_OSLib-5_43:4.4
	RISC_OSLib-5_42:4.4
	RISC_OSLib-5_41:4.4
	RISC_OSLib-5_40:4.4
	RISC_OSLib-5_39:4.4
	RISC_OSLib-5_38:4.4
	RISC_OSLib-5_37:4.4
	RISC_OSLib-5_36:4.4
	RISC_OSLib-5_35:4.4
	RISC_OSLib-5_34:4.4
	RISC_OSLib-5_33-4_50_2_1:4.4
	sbrodie_dev:4.4.0.2
	sbrodie_dev_bp:4.4
	RISC_OSLib-5_33:4.4
	RISC_OSLib-5_32:4.4
	RISC_OSLib-5_31:4.4
	RISC_OSLib-5_30:4.4
	RISC_OSLib-5_29:4.4
	RISC_OSLib-5_28:4.4
	RISC_OSLib-5_27:4.4
	RISC_OSLib-5_26:4.4
	RISC_OSLib-5_25:4.4
	RISC_OSLib-5_24:4.4
	RISC_OSLib-5_01-4_16_2_5:4.3
	RISC_OSLib-5_23:4.4
	RISC_OSLib-5_22:4.4
	RISC_OSLib-5_21:4.4
	RISC_OSLib-5_20:4.4
	RISC_OSLib-5_19:4.4
	RISC_OSLib-5_18:4.4
	RISC_OSLib-5_17:4.4
	RISC_OSLib-5_16:4.4
	RISC_OSLib-5_15:4.4
	dellis_autobuild_BaseSW:4.4
	RISC_OSLib-5_14:4.4
	RISC_OSLib-5_13:4.4
	RISC_OSLib-5_12:4.4
	RISC_OSLib-5_01-4_16_2_4:4.3
	RISC_OSLib-5_11:4.4
	RISC_OSLib-5_01-4_16_2_3:4.3
	RISC_OSLib-5_01-4_16_2_2:4.3
	RISC_OSLib-5_10:4.4
	RISC_OSLib-5_01-4_16_2_1:4.3
	Bethany:4.3.0.4
	RISC_OSLib-5_09:4.4
	RISC_OSLib-5_08:4.4
	RISC_OSLib-5_07:4.4
	RISC_OSLib-5_06:4.4
	RISC_OSLib-4_97-4_12_2_8:4.3.2.1
	RISC_OSLib-5_05:4.3
	RISC_OSLib-5_04:4.3
	sbrodie_sedwards_16Mar2000:4.3
	RISC_OSLib-5_03:4.3
	RISC_OSLib-5_02:4.3
	RISC_OSLib-4_97-4_12_2_7:4.3.2.1
	RISC_OSLib-5_01:4.3
	RISC_OSLib-5_00:4.3
	RISC_OSLib-4_99:4.3
	RISC_OSLib-4_98:4.3
	RISC_OSLib-4_97-4_12_2_6:4.3.2.1
	RISC_OSLib-4_97-4_12_2_5:4.3.2.1
	RISC_OSLib-4_97-4_12_2_4:4.3.2.1
	RISC_OSLib-4_97-4_12_2_3:4.3.2.1
	RISC_OSLib-4_97-4_12_2_2:4.3
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.3
	kbracey_32bit:4.3.0.2
	kbracey_32bit_bp:4.3
	dcotton_autobuild_BaseSW:4.4
	RISC_OSLib-4_97:4.3
	RISC_OSLib-4_96:4.3
	RISC_OSLib-4_95:4.3
	RISC_OSLib-4_94:4.3
	RISC_OSLib-4_93:4.3
	RISC_OSLib-4_92:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	sforrest_daytona_appflash-0_31:4.2
	RISC_OSLib-4_91:4.3
	RISC_OSLib-4_90:4.3
	RISC_OSLib-4_89:4.3
	Ursula_merge:4.2
	RISC_OSLib-4_88:4.3
	RISC_OSLib-4_87:4.3
	blaughto_daytona_appflash-0_30:4.2
	rmanby_clib-4_86:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.4
date	2000.05.09.14.09.21;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.08.27.10.01.11;	author smiddle;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.21.17.42.39;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.24.46;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	99.11.10.14.02.21;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.24.46;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.51.37;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.26.51;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.47.21;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.4
log
@32-bit work merged from kbracey_32bit branch.

Version 5.06. Tagged as 'RISC_OSLib-5_06'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* armprof.c:  Copyright (C) Codemist Ltd., 1988      */
/* Copyright (C) Acorn Computers Ltd., 1988, 1990     */
/* RISCOS-specific profiling support                  */

#include <stdio.h>

/* HIDDEN EXPORTS */
extern void _mapstore(void);
extern void _fmapstore(char *);
void _write_profile(char *);

#ifdef __STDC__
  #error armprof.c MUST be compiled in -pcc mode
#endif

extern unsigned Image$$RO$$Base, Image$$RO$$Limit, Image$$RW$$Limit;

static unsigned *RO_Base  = &Image$$RO$$Base;
static unsigned *RO_Limit = &Image$$RO$$Limit;
static unsigned *RW_Limit = &Image$$RO$$Limit;

extern void _count(void), _count1(void);

typedef union count_position
/* This defines the format of the word that follows on from a call         */
/* to _count1(). The related constant values are related to the way that   */
/* file-name decoding tables are packed away.                              */
{   int i;
    struct s
    {   unsigned int posn:12,
                     line:16,
                     file:4;
    } s;
} count_position;

#define file_name_map_start 0xfff12340  /* Magic number */
#define file_name_map_end   0x31415926  /* Magic number */

#define word_roundup(s) ((char *)(((int)s + 3) & (~3)))

static char *find_file_map(int p)
{
    int i, w;
    char *s;
    while (((w = *(int *)p) & 0xfffffff0) != file_name_map_start)
    {   if (p >= (int)RO_Limit) return "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
        p += 4;
    }
    s = (char *)(p + 4);
    for ( i = 0; i<=(w & 0xf); i++)
    {   s += 1 + strlen(s);
        s = word_roundup(s);
    }
    if (*(int *)s != file_name_map_end) return find_file_map((int)s);
    return (char *)(p + 4);
}

static void _map_store(FILE *map_file)
{
    unsigned count1 = (unsigned)_count1;    /* address of the fn as an int */
    unsigned p, onthisline = 4, w1 = 0, w2 = 0;
    unsigned ro_base  = (unsigned)RO_Base;
    unsigned ro_limit = (unsigned)RO_Limit;
    unsigned rw_limit = (unsigned)RW_Limit;

    fprintf(map_file,
"\nFunction/statement counts from code base = %.6x to code limit = %.6x\n",
        ro_base, ro_limit);

    for (p = ro_base; p < ro_limit; p += 4)
    {   int w = *(int *)p;
        if ((w & 0xff000000) == 0xeb000000) /* Unconditional BL instruction */
        {   unsigned dest = (p + 8 + ((w << 8) >> 6));
            if (dest != count1 && dest >= ro_base && dest < rw_limit)
            {   /* Try for call through (straight) veneer */
                int b = *(int *)dest;
                if ((b & 0xff000000) == 0xea000000) /* Unconditional B */
                    dest = (dest + 8 + ((b << 8) >> 6));
            }
            if (dest == count1)
            {   if (onthisline == 4) onthisline = 0, fputs("\n   ", map_file);
                ++onthisline;
                fprintf(map_file, " %.6u: %-9u",
                        (*(unsigned *)(p + 8) << 4) >> 16,
                        *(unsigned *)(p + 4));
            }
        }
        if (   ((w & 0xff000000) == 0xe9000000) &&
             ( ((w & 0x00ff0000) == 0x002c0000 && w1 == 0xe1a0b00c) ||
               ((w & 0x00ff0000) == 0x002d0000 && w1 == 0xe1a0c00d) ) &&
             /* STMFD sp!, ..., ; MOV ip, sp  @@@@@@@@@@, either calling sequence */
             (w2 & 0xffff0000) == 0xff000000)
        {   char *name = (char *)(p - 8 - (w2 & 0xffff));
            if (onthisline != 0) fputc('\n', map_file);
            onthisline = 4;
            fprintf(map_file, "%s", name);
        }
        w2 = w1;
        w1 = w;
    }
    if (onthisline != 0) fputc('\n', map_file);
}

void _mapstore()
{
    _map_store(stderr);
}

void _fmapstore(char *filename)
{
    FILE *map_file = fopen(filename, "w");
    if (map_file == NULL)
    {   fprintf(stderr, "\nUnable to open %s for execution profile log\n",
                        filename);
        return;
    }
    _map_store(map_file);
    fclose(map_file);
    fprintf(stderr, "\nProfile information written to %s\n", filename);
}

void _write_profile(char *filename)
{
/* Create a (binary) file containing execution profile information for     */
/* the current program. The format is eccentric, and must be kept in step  */
/* with (a) parts of armgen.c that generate code that collects statistics  */
/* and (b) code in misc.c that reads in the binary file created here and   */
/* displays the counts attached to a source listing of the original code.  */
    int count1 = (int)_count1;
    int p, w1 = 0, w2 = 0, pass, nfiles = 0, namebytes = 0, ncounts = 0;
    int global_name_offset[256];
    char *global_file_map[256]; /* Limits total number of files allowed */
    FILE *map_file = fopen(filename, "wb");
    char *file_map;
    if (map_file == NULL)
    {   fprintf(stderr, "\nUnable to open %s for execution profile log\n",
                        filename);
        return;
    }
    for (pass = 1; pass <=2; pass++)
    {
        if (pass == 2)
        /* Write file header indicating size of sub-parts */
        {   fwrite("\xff*COUNTFILE*", 4, 3, map_file);
            fwrite(&namebytes, 4, 1, map_file);
            fwrite(&nfiles,    4, 1, map_file);
            fwrite(&ncounts,   4, 1, map_file);
            for (p = 0; p < nfiles; p++)
            {   char *ss = global_file_map[p];
                int len = 1 + strlen(ss);
                len = ((len + 3) & (~3)) / 4;
                fwrite(ss, 4, len, map_file);
            }
            for (p = 0; p < nfiles; p++)
                fwrite(&global_name_offset[p], 4, 1, map_file);
        }
        file_map = NULL;
        for (p = (int)RO_Base; p < (int)RO_Limit; p += 4)
        {   int w = *(int *)p;
            if ((w & 0xff000000) == 0xeb000000) /* BL instruction */
            {   int dest = (p + 8 + ((w << 8) >> 6));
                if (dest != count1 &&
                    dest >= (int)RO_Base && dest < (int)RO_Limit)
                {   /* Try for call through (straight) veneer */
                    int b = *(int *)dest;
                    if ((b & 0xff000000) == 0xea000000) /* Unconditional B */
                        dest = (dest + 8 + ((b << 8) >> 6));
                }
                if (dest == count1)
                {   count_position k;
                    int i;
                    char *s;
                    if (file_map == NULL ||
                        (int)file_map <= p) file_map = find_file_map(p+12);
                    s = file_map;
                    k.i = *(int *)(p + 8);
                    for (i = 0; i<k.s.file; i++)
                    {   s += 1 + strlen(s);
                        s = word_roundup(s);
                    }
                    if (pass == 1)
                    {   int i;
                        for (i = 0;;i++)
                        {   if (i >= nfiles)
                            {   global_name_offset[nfiles] = namebytes;
                                global_file_map[nfiles++] = s;
                                namebytes += 1 + strlen(s);
                                namebytes = (namebytes + 3) & (~3);
                                break;
                            }
                            else if (strcmp(s,global_file_map[i]) ==0) break;
                        }
                        ncounts++;
                    }
                    else
                    {   int i;
                        for (i = 0; strcmp(s, global_file_map[i]) !=0; i++);
                        fwrite((int *)(p + 4), 4, 1, map_file);
                        i = (k.s.line & 0xffff) | (i << 16);
                        fwrite(&i, 4, 1, map_file);
                    }
                    p += 8;
                }
            }
            w2 = w1;
            w1 = w;
        }
    }
    fwrite("\xff*ENDCOUNT*\n", 4, 3, map_file); /* Trailer data */
    fclose(map_file);
    fprintf(stderr, "\nProfile information written to %s\n", filename);
}
@


4.3
log
@Merged Spinner branch changes onto trunk (new RCA messages files
and Makefile changes). Convert to srccommit while we're at it.
Removed a few $Revision's to prevent future spurious merge clashes.

Version 4.87. Tagged as 'RISC_OSLib-4_87'
@
text
@d126 1
a126 1
    FILE *map_file = map_file = fopen(filename, "w");
@


4.3.2.1
log
@_kernel_unwind now understands SFMFD instructions in function entry.
It also copes with STFE now - it was totally broken.
32-bit stubs and corresponding LibInit SWIs created.
All rather untested.

Version 4.97, 4.12.2.3. Tagged as 'RISC_OSLib-4_97-4_12_2_3'
@
text
@d126 1
a126 1
    FILE *map_file = fopen(filename, "w");
@


4.2
log
@Module merged
@
text
@a19 6
/*
 * RCS $Revision: 4.1.7.1 $
 * Checkin $Date: 1996/11/29 19:47:21 $
 * Revising $Author: nturton $
 */

@


4.1
log
@Initial revision
@
text
@d21 3
a23 3
 * RCS $Revision: 1.6 $
 * Checkin $Date: 90/07/19 10:31:31 $
 * Revising $Author: lee $
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.15;
access;
symbols
	RISC_OSLib-5_97:4.15
	RISC_OSLib-5_96:4.15
	RISC_OSLib-5_95:4.15
	RISC_OSLib-5_94:4.15
	RISC_OSLib-5_93:4.15
	RISC_OSLib-5_92:4.14
	RISC_OSLib-5_91:4.13
	RISC_OSLib-5_90:4.12
	RISC_OSLib-5_89:4.12
	RISC_OSLib-5_88:4.12
	RISC_OSLib-5_87:4.12
	RISC_OSLib-5_86-1:4.12
	RISC_OSLib-5_86:4.12
	RISC_OSLib-5_85:4.12
	RISC_OSLib-5_84:4.12
	RISC_OSLib-5_83-2:4.12
	RISC_OSLib-5_83-1:4.11
	RISC_OSLib-5_83:4.12
	RISC_OSLib-5_82:4.11
	RISC_OSLib-5_81:4.11
	RISC_OSLib-5_75-2:4.11
	RISC_OSLib-5_80:4.11
	RISC_OSLib-5_79:4.11
	RISC_OSLib-5_78:4.11
	RISC_OSLib-5_75-1:4.11
	RISC_OSLib-5_77:4.11
	RISC_OSLib-5_76:4.11
	RISC_OSLib-5_75:4.11
	RISC_OSLib-5_74:4.11
	RISC_OSLib-5_73:4.11
	RISC_OSLib-5_72:4.11
	RISC_OSLib-5_71:4.11
	RISC_OSLib-5_70:4.11
	RISC_OSLib-5_69:4.11
	RISC_OSLib-5_68:4.11
	RISC_OSLib-5_67:4.11
	RISC_OSLib-5_66:4.11
	RISC_OSLib-5_65:4.11
	RISC_OSLib-5_64:4.11
	RISC_OSLib-5_63:4.10
	RISC_OSLib-5_62:4.10
	RISC_OSLib-5_61:4.10
	RISC_OSLib-5_60:4.10
	RISC_OSLib-5_59:4.9
	RISC_OSLib-5_58:4.9
	RISC_OSLib-5_57:4.9
	RISC_OSLib-5_56:4.9
	RISC_OSLib-5_55:4.9
	RISC_OSLib-5_54:4.9
	RISC_OSLib-5_53:4.8
	RISC_OSLib-5_52:4.8
	RISC_OSLib-5_51:4.8
	RO_5_07:4.8
	RISC_OSLib-5_50:4.8
	RISC_OSLib-5_49:4.8
	RISC_OSLib-5_46-4_64_2_1:4.7
	NoInlineAsm:4.7.0.2
	RISC_OSLib-5_48:4.8
	RISC_OSLib-5_47:4.8
	RISC_OSLib-5_46:4.7
	RISC_OSLib-5_45:4.7
	RISC_OSLib-5_44:4.7
	RISC_OSLib-5_43:4.6
	RISC_OSLib-5_42:4.6
	RISC_OSLib-5_41:4.6
	RISC_OSLib-5_40:4.5
	RISC_OSLib-5_39:4.5
	RISC_OSLib-5_38:4.5
	RISC_OSLib-5_37:4.5
	RISC_OSLib-5_36:4.4
	RISC_OSLib-5_35:4.4
	RISC_OSLib-5_34:4.4
	RISC_OSLib-5_33-4_50_2_1:4.4
	sbrodie_dev:4.4.0.2
	sbrodie_dev_bp:4.4
	RISC_OSLib-5_33:4.4
	RISC_OSLib-5_32:4.4
	RISC_OSLib-5_31:4.4
	RISC_OSLib-5_30:4.4
	RISC_OSLib-5_29:4.4
	RISC_OSLib-5_28:4.4
	RISC_OSLib-5_27:4.4
	RISC_OSLib-5_26:4.4
	RISC_OSLib-5_25:4.4
	RISC_OSLib-5_24:4.4
	RISC_OSLib-5_01-4_16_2_5:4.2
	RISC_OSLib-5_23:4.4
	RISC_OSLib-5_22:4.4
	RISC_OSLib-5_21:4.4
	RISC_OSLib-5_20:4.4
	RISC_OSLib-5_19:4.4
	RISC_OSLib-5_18:4.4
	RISC_OSLib-5_17:4.4
	RISC_OSLib-5_16:4.4
	RISC_OSLib-5_15:4.4
	dellis_autobuild_BaseSW:4.4
	RISC_OSLib-5_14:4.4
	RISC_OSLib-5_13:4.4
	RISC_OSLib-5_12:4.4
	RISC_OSLib-5_01-4_16_2_4:4.2
	RISC_OSLib-5_11:4.4
	RISC_OSLib-5_01-4_16_2_3:4.2
	RISC_OSLib-5_01-4_16_2_2:4.2
	RISC_OSLib-5_10:4.4
	RISC_OSLib-5_01-4_16_2_1:4.2
	Bethany:4.2.0.12
	RISC_OSLib-5_09:4.3
	RISC_OSLib-5_08:4.3
	RISC_OSLib-5_07:4.3
	RISC_OSLib-5_06:4.3
	RISC_OSLib-4_97-4_12_2_8:4.2.10.4
	RISC_OSLib-5_05:4.2
	RISC_OSLib-5_04:4.2
	sbrodie_sedwards_16Mar2000:4.2
	RISC_OSLib-5_03:4.2
	RISC_OSLib-5_02:4.2
	RISC_OSLib-4_97-4_12_2_7:4.2.10.3
	RISC_OSLib-5_01:4.2
	RISC_OSLib-5_00:4.2
	RISC_OSLib-4_99:4.2
	RISC_OSLib-4_98:4.2
	RISC_OSLib-4_97-4_12_2_6:4.2.10.2
	RISC_OSLib-4_97-4_12_2_5:4.2.10.2
	RISC_OSLib-4_97-4_12_2_4:4.2.10.2
	RISC_OSLib-4_97-4_12_2_3:4.2.10.1
	RISC_OSLib-4_97-4_12_2_2:4.2
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.2
	kbracey_32bit:4.2.0.10
	kbracey_32bit_bp:4.2
	dcotton_autobuild_BaseSW:4.4
	RISC_OSLib-4_97:4.2
	RISC_OSLib-4_96:4.2
	RISC_OSLib-4_95:4.2
	RISC_OSLib-4_94:4.2
	RISC_OSLib-4_93:4.2
	RISC_OSLib-4_92:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	sforrest_daytona_appflash-0_31:4.2
	RISC_OSLib-4_91:4.2
	RISC_OSLib-4_90:4.2
	RISC_OSLib-4_89:4.2
	Ursula_merge:4.2
	RISC_OSLib-4_88:4.2
	RISC_OSLib-4_87:4.2
	blaughto_daytona_appflash-0_30:4.2
	rmanby_clib-4_86:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2017.09.03.22.22.23;	author jlee;	state Exp;
branches;
next	4.14;
commitid	o2klppFenR57KN5A;

4.14
date	2016.05.28.18.56.04;	author jlee;	state Exp;
branches;
next	4.13;
commitid	iLtWPZpTlif3uh8z;

4.13
date	2016.05.24.22.50.28;	author jlee;	state Exp;
branches;
next	4.12;
commitid	RYaH5CsBb1WpUM7z;

4.12
date	2015.01.16.00.44.46;	author jlee;	state Exp;
branches;
next	4.11;
commitid	AU0zG3zSgj29sb6y;

4.11
date	2011.10.28.14.23.46;	author bavison;	state Exp;
branches;
next	4.10;
commitid	hIG6j26y6NoxM7Fv;

4.10
date	2011.08.06.20.05.20;	author jlee;	state Exp;
branches;
next	4.9;
commitid	D9pXqV2mtIAhluuv;

4.9
date	2009.05.31.17.59.03;	author pnaulls;	state Exp;
branches;
next	4.8;

4.8
date	2003.10.09.17.39.50;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2002.11.15.15.00.33;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2002.05.22.10.45.28;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2002.03.21.14.36.26;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.07.03.12.30.41;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.09.14.09.42;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.13.06;	author nturton;	state Exp;
branches
	4.2.10.1;
next	4.1;

4.1
date	96.11.05.09.25.43;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.10.1
date	99.11.10.14.02.40;	author kbracey;	state Exp;
branches;
next	4.2.10.2;

4.2.10.2
date	99.11.10.16.59.11;	author kbracey;	state Exp;
branches;
next	4.2.10.3;

4.2.10.3
date	2000.01.14.11.02.22;	author kbracey;	state Exp;
branches;
next	4.2.10.4;

4.2.10.4
date	2000.05.09.13.58.57;	author kbracey;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.25.43;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.56.22;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.35.25;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.51.54;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.15
log
@Eliminate some global OS_SynchroniseCodeAreas calls
Detail:
  kernel/s/k_body - Eliminate a couple of global OS_SynchroniseCodeAreas calls in _kernel_init and _kernel_system
  s/initmodule - Eliminate a global OS_SynchroniseCodeAreas call in _Shared_Lib_Module_SWI_Code
Admin:
  Tested on iMx6
  Improves performance with SMP ROMs, where global D-cache clean isn't really possible


Version 5.93. Tagged as 'RISC_OSLib-5_93'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; -*- Mode: Assembler -*-
;* module initialisation for shared libraries
;* Lastedit: 03 Apr 90 10:51:05 by Harry Meekings *
; Copyright (C) Acorn Computers Ltd., 1988
;
; IDJ: 19-Jul-91: removed message C03

        GBLL    SharedLibrary
SharedLibrary   SETL    {TRUE}

        GBLL    NoStubEntries
NoStubEntries   SETL    {TRUE}  ; stop h_modmacro defining Entry

        AREA    |AA$$code|, CODE, READONLY

        GET     h_regs.s
        GET     h_brazil.s
        GET     h_stack.s
        GET     h_modmacro.s
        GET     h_workspc.s

        GET     Hdr:Proc
        GET     Hdr:OSMisc

        IMPORT  |Lib$$Init$$Base|
        IMPORT  |Lib$$Init$$Limit|
        IMPORT  |Image$$ZI$$Base|
 [ Code_Destination = "RAM"
        IMPORT  |__RelocCode|
 ]
        IMPORT  |_kernel_copyerror|
        IMPORT  |_kernel_getmessage|

        EXPORT  |_Lib$Reloc$Off|
        EXPORT  |_Mod$Reloc$Off|
        EXPORT  |_Shared_Lib_Module_SWI_Code|
        EXPORT  |_Shared_Lib_Module_Init_Code|
        EXPORT  |_Shared_Lib_Module_Die_Code|

|_Lib$Reloc$Off|        *       -SL_Lib_Offset
|_Mod$Reloc$Off|        *       -SL_Client_Offset

OverflowBit             *       &10000000

n_module_claim EQU 6

sharedclibrary_path
        DCB     "SharedCLibrary$$Path"
        DCB     0
risc_oslibrary_path
        DCB     "RISC_OSLibrary$$Path"
        DCB     0

sharedclibrary_resources
        DCB     "Resources:$.Resources.CLib."
        DCB     0
risc_oslibrary_resources
        DCB     "Resources:$.Resources.RISC_OSLib."
        DCB     0

        ALIGN

|_Shared_Lib_Module_Init_Code|
        STMFD   r13!, {r7-r11, lr}
 [ Code_Destination = "RAM"
        BL      |__RelocCode|
 ]
        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_RISCOSLibWord
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        LDREQ   r2, =Legacy_RISCOSLibWord
        STR     r1, [r2]
        MOV     r0, #6
        MOV     r2, #OSRSI6_CLibWord
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        CMP     r2, #0
        LDREQ   r2, =Legacy_CLibWord
        STR     r1, [r2]

        ADR     r0, sharedclibrary_path
        ADR     r1, sharedclibrary_resources
        MOV     r5, #?sharedclibrary_resources
        BL      setresourcevar

        ADR     r0, risc_oslibrary_path
        ADR     r1, risc_oslibrary_resources
        MOV     r5, #?risc_oslibrary_resources
        BL      setresourcevar

        CLRV
        LDMFD   r13!, {r7-r11, pc}

setresourcevar
        MOV     r11, lr
        MOV     r10, r0
        MOV     r2, #-1
        MOV     r3, #0
        MOV     r4, #0
        SWI     ReadVarVal
        MOV     r0, r10
        CMP     r2, #0
        MOVEQ   r2, r5
        MOVEQ   r3, #0
        MOVEQ   r4, #0
        SWIEQ   SetVarVal
        MOV     pc, r11

XMessageTrans_CloseFile EQU &61504 ; Put in hdr file someday

|_Shared_Lib_Module_Die_Code|
        STR     lr, [r13, #-4]!

        MOV     r0, #6
        MOV     r1, #0
        MOV     r2, #OSRSI6_CLibWord
        SWI     XOS_ReadSysInfo
        MOVVS   r2, #0
        MOVS    r3, r2
        LDREQ   r3, =Legacy_CLibWord
        LDR     r2, [r3]
        CMP     r2, #0
        BEQ     %F00
        MOV     r0, r2
        SWI     XMessageTrans_CloseFile
        MOV     r0, #Module_Free
        SWI     Module
        STR     r1, [r3]
00
        CLRV
        LDR     pc, [r13], #4

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; This is the SWI Lib_Init code
;
; Entered with r0 pointer to description of stubs present in image
;                 each having format
;                   library chunk id
;                   entry vector base
;                   entry vector limit
;                   static data base
;                   static data limit
;                 terminated by an entry with stub id -1
;                 For each of these, there must be an entry in the shared
;                 library description (in the Lib$$Init area) with the same
;                 id and the the same static data size.
;              r1 pointer to low end of workspace
;              r2 pointer to high end of workspace
;              r3 base of client's zero-initialise area (at end of statics)
;              r4 pointer to start of client's statics
;              r5 pointer to end of clients's statics
;              (old stubs)  r6 = 0
;              r6 [0] = 0 if client is running in a 26-bit mode (may still be APCS-32)
;                     = 1 if client is running in a 32-bit mode (=> must be APCS-32,
;                       and address constant table must follow vectors)
;              r6 [1:15] = 0
;              r6 [16:31] = requested root stack size (Kb)
; Returns with stub vector patched
;              if input r5>r4, user statics copied and [sl, #SL_Client_Offset]
;               initialised
;              library statics copied and [sl, #SL_Lib_Offset] initialised
;              r1 stack base
;              r2 stack top (sp value)
;              r6 = library version number
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ^ 0
        ; Format of Lib$$Init area entry
LI_Id           #       4
LI_EntryBase    #       4
LI_EntryEnd     #       4
LI_DataStart    #       4
LI_DataEnd      #       4
LI_ItemSize     #       0

        ; In: r4 -> entry table
        ; Out: r4 incremented
        ;      r6 = absolute address of entry
        MACRO
        GetRoutineAddress
        LDR     r6, [r4], #4
        TST     r6, #1
        BEQ     %FT10
        Push    "r14"
        BL      PickRoutineVariant
        Pull    "r14"
10
        MEND

|_Shared_Lib_Module_SWI_Code|
        ; Relative SWI number in r11.
        ;  0  old-style init.  Client uses APCS_A.  No longer supported.
        ;  1  new-style init.  Client uses APCS_U; so must this module.
        ;  2  (new-style) module init.  Stack is SWI stack, not in the heap.
        ;  3  APCS-32 init.  Client uses APCS-3/32bit.
        ;  4  APCS-32 module init.  Stack is SWI stack, not in the heap.

        EntryS  "r0-r6"

        ; Check SWI in valid range
        CMP     r11, #1
        ADRLO   r0, E_OldAPCS_A
        BLO     Failed
      [ {CONFIG}<>26
        CMP     r11, #3
        ADRLO   r0, E_OldAPCS_R
        BLO     Failed
      ]

        CMP     r11, #4
        ADRHI   r0, E_UnknownSWI
        BHI     Failed

        CLRPSR  F_bit:OR:I_bit, lr      ; ensure IRQs enabled

        ; Check memory constraints work:
        ; lr = end of required workspace (data + stack), ie stack top for non-modules
        ; r12 = stack base
        SUBS    lr, r5, r4              ; size of client's statics
        MOVMI   lr, #0                  ; no client statics really.
        CMP     r11, #2                 ; module?
        CMPNE   r11, #4
        MOVEQ   r12, sp, LSR #20
        MOVEQ   r12, r12, ASL #20
        ADDEQ   lr, lr, r1
        BEQ     CheckEnoughStore

        ADD     r12, r1, lr             ; heap base plus size of copied statics
        ; For things linked with old stubs r6 may be zero - if so,
        ; we use the old default root stack size
        MOVS    r6, r6, LSR #6
        MOVEQ   r6, #OldRootStackSize
        ADD     lr, r12, r6             ; plus size of root stack
CheckEnoughStore
        CMP     lr, r2                  ; must fit within available workspace
        ADRGT   r0, E_BadMemory
        BGT     Failed

      [ Proc_RegOffset = 0
        STMIA   r13, {r2, r12, lr}      ; return values of r0, r1 & r2 (Data end, stack base and stack top)
      |
        [ Proc_RegOffset = 4
        STMIB   r13, {r2, r12, lr}      ; return values of r0, r1 & r2 (Data end, stack base and stack top)
        |
        ! 1, "Proc_RegOffset = ?"
        ]
      ]
        CMP     r11, #2                 ; module?
        CMPNE   r11, #4
        STRNE   r6, [r12, #SC_size]     ; Start filling stack chunk header for non-modules

        ; Copy the non-zeroed client statics
        SUBS    lr, r5, r4              ; see again whether client statics to copy
        MOVMI   r4, r1
        SUBPLS  r6, r3, r4
        BLE     ZeroInitClientStatics
  [ StrongARM
        STR     r1, [sp, #-4]!
  ]
CopyClientStatics
        LDR     lr, [r4], #+4
        STR     lr, [r1], #+4
        SUBS    r6, r6, #4
        BNE     CopyClientStatics
  [ StrongARM
        ; Statics may contain code, synchronise it
        STMFD   sp!, {r0-r2}
        MOV     r0, #1
        MOV     r2, r1
        LDR     r1, [sp, #12]
        SWI     XOS_SynchroniseCodeAreas
        LDMFD   sp!, {r0-r2}
        ADD     sp, sp, #4
  ]

        ; Zero the client statics which need zeroing
ZeroInitClientStatics
        SUB     lr, r1, r4              ; the value for SL_Client_Offset
        SUBS    r5, r5, r3
        BLE     DoneClientStatics
        MOV     r6, #0
01      STR     r6, [r1], #4
        SUBS    r5, r5, #4
        BGT     %B01

        ; Client statics copied/zeroed, fill in SC_Client_Offset for -zm1 clients
DoneClientStatics
        STR     lr, [r12, #SC_SLOffset+SL_Client_Offset]

        ; r5 is used to hold SL_Lib_Offset - if a library chunk has an different value
        ; its time to barf! r5=0 is the initial value to indicate 'r5 isn't set yet'
        MOV     r5, #0

NextLibraryChunk
        ; Pick up:
        ; r14 = Start of our table of libraries
        ; r12 = End of our table of libraries
        ; r1 = next client library chunk number
        ; r2 = next client library chunk branch table start
        ; r3 = next client library chunk branch table end
        LDR     r14, =|Lib$$Init$$Base|
        LDR     r12, =|Lib$$Init$$Limit|
        LDMIA   r0!, {r1, r2, r3}

        ; If end of client's library table we've finished
        CMP     r1, #0
        BLT     EndStubInit

FindLibraryChunk
        ; If finished with our table of libraries then the client's chunk isn't recognised
        CMP     r14, r12
        ADRGE   r0, E_UnknownLib
        BGE     Failed

        ; Check if this chunk matches the client's, if yes, then drop through
        LDR     r4, [r14], #LI_ItemSize
        BIC     r4, r4, #library_segment_is_ROM_only
        CMP     r4, r1
        BNE     FindLibraryChunk

FoundLibraryChunk
        ; We've now matched a client library chunk to a library chunk we know about
        ; so, we should now patch the branches and copy and initialise the data

        ; Check not attempting to bind ROM chunk to RAM application
        LDR     r4, [r14, #LI_Id - LI_ItemSize]
        TST     r4, #library_segment_is_ROM_only
        TEQNE   r2, r3
        ADRNE   r0, E_UnknownLib
        BNE     Failed

        ; I suppose it would be friendly to check here that there are
        ; no fewer entries in the library than in the stub.
        ; So let's do it:
        LDR     r12, StubInitValue
        LDR     r1, [r14, #LI_EntryBase-LI_ItemSize]
        LDR     r4, [r14, #LI_EntryEnd-LI_ItemSize]
        SUB     r4, r4, r1              ; r4 = size of our table
        ADD     r4, r2, r4              ; r4 = end of client table we know
01      CMP     r4, r3
        STRLO   r12, [r3, #-4]!         ; fill in excess with MOV PC,#0
        BLO     %BT01

        ; Branch patchup for SWI Lib_Init1 to 4
        ; r2 = entry vector base
        ; r3 = entry vector limit
        ; r6 bit 0 set => 32-bit mode (so BL not valid), and address constant table
        ; of same size follows immediately after

        ; UNFORTUNATELY, r6 bit 0 is not set by early versions of the 32-bit
        ; module stubs. So we can't rely on it. Instead, if we're in {CONFIG}=32
        ; we know we only support the APCS-32 Init SWIs, so we know they must
        ; have supplied sufficient space for the table, and we were built for
        ; a 32-bit OS. We will thus always use B if {CONFIG}=26 and LDR PC if
        ; {CONFIG}=32.

 [ {CONFIG} <> 26
        ; Create a table of LDR PC,&xxx followed by the address constants

        LDR     r1, =&E59FF000          ; LDR PC,[PC,#+0]
        SUB     r4, r3, r2              ; r4 = size of table (remember for later)
        SUBS    r6, r4, #8              ; r6 = offset to use in LDR
        BICMI   r1, r1, #1:SHL:23       ; handle the negative case (just possible
        RSBMI   r6, r6, #0              ; for a single entry stub table)
        CMP     r6, #&1000              ; Offset must be <= &FFF
        ADRHS   r0, E_UnknownLib        ; Can't be bothered to make a new error
        BHS     Failed

        ORR     r6, r1, r6
FixLDRs
        CMP     r2, r3
        STRNE   r6, [r2], #4
        BNE     FixLDRs                 ; Write the LDR PC,[PC,#<xxx>] into each entry

        ADD     r3, r2, r4              ; r2, r3 now point to address constant table

        LDR     r4, [r14, #LI_EntryBase-LI_ItemSize]    ; Our entry table
FixAddresses
        CMP     r2, r3
        BEQ     ChunkEntriesDone
        GetRoutineAddress
        LDR     r1, [r2], #4           ; patch the stub entry only if it's
        CMP     r1, r6                 ; not already right.
        STRNE   r6, [r2, #-4]
        B       FixAddresses
 |
        ; Create a table of B &xxx

FixBranches
        LDR     r4, [r14, #LI_EntryBase-LI_ItemSize]    ; Our entry table
FixEntries
        CMP     r2, r3
        BEQ     ChunkEntriesDone
        GetRoutineAddress
        SUB     r6, r6, r2
        SUB     r6, r6, #8
        MOV     r6, r6, ASR #2
        BIC     r6, r6, #&FF000000
        ORR     r6, r6, #&EA000000     ; le branch!
        LDR     r1, [r2], #4           ; patch the stub entry only if it's
        CMP     r1, r6                 ; not already right.
        STRNE   r6, [r2, #-4]
        B       FixEntries
 ]

ChunkEntriesDone
  [ StrongARM
        ; patched branch code requires SynchroniseCodeAreas
        STMFD  sp!, {r0,r14}
        LDMDB  r0, {r1, r2}
        MOV    r0, #1
        SWI    XOS_SynchroniseCodeAreas
        LDMFD  sp!, {r0,r14}
  ]

        ; Having patched up the branch table, lets copy the library's static data

        ; The space reserved in the image for static data for this chunk
        ; must match the actual size in the shared library.
        LDMIA   r0!, {r2, r3}
        LDMDB   r14, {r4, r6}
        SUB     r1, r2, r3
        ADD     r1, r1, r6
        SUBS    r1, r1, r4
 [ 1 = 1
        ADRNE   r0, E_StaticSizeWrong
        BNE     Failed
 |
        BEQ     staticsizeok
        STMDB   sp!, {r0, r1, r2}
   [ :DEF:DEFAULT_TEXT
        ADR     r0, stubdatasize_text
        ADR     r1, stubdatasize_tag
   |
        ADR     r0, stubdatasize_tag
   ]
        BL      |_kernel_getmessage|
        BL      writectrl
        SUB     r0, r3, r2
        SUB     r1, sp, #12
        MOV     r2, #9
        SWI     &d4
        SWI     2
        SWI     3
   [ :DEF:DEFAULT_TEXT
        ADR     r0, libdatasize_text
        ADR     r1, libdatasize_tag
   |
        ADR     r0, libdatasize_tag
   ]
        BL      |_kernel_getmessage|
        BL      writectrl
        SUB     r0, r6, r4
        MOV     r1, sp
        MOV     r2, #9
        SWI     &d4
        SWI     2
        SWI     3
        ADD     sp, sp, #8
        LDMIA   sp!, {r0, r1, r2}
        ADR     r0, E_StaticSizeWrong
        B       Failed

writectrl
        STMDB   sp!, {r1,lr}
        MOV     r1, r0
01      LDRB    r0, [r1], #1
        CMP     r0, #" "
        LDMCCIA sp!, {r1,pc}
        SWI     0
        B       %BT01

stubdatasize_tag
        DCB     "C67",0
libdatasize_tag
        DCB     "C68",0

  [ :DEF:DEFAULT_TEXT
stubdatasize_text
        DCB     "Stub data size = ",0
libdatasize_text
        DCB     "Library data size = ",0
        ALIGN
  ]

staticsizeok
 ]
        SUBS    r3, r3, r2              ; size of library chunk statics
        BLE     NextLibraryChunk        ; no statics for this chunk

        ; and the offset must agree with that for all earlier chunks

        LDR     r1, [r13, #Proc_RegOffset + 4]
        LDR     r1, [r1, #SC_SLOffset+SL_Client_Offset]
        ADD     r2, r2, r1              ; relocate address to copy to!!
        SUB     r1, r2, r4
        CMP     r5, #0
        CMPNE   r5, r1
        ADRNE   r0, E_StaticOffsetInconsistent
        BNE     Failed
        MOV     r5, r1

  [ StrongARM
        STMFD   sp!, {r2,r14}
  ]

        ; Copy the data from our fixed static data area to the clients dynamic
        ; static data area. No zero initialised data at all.
CopyLibStatics
        LDR     r1, [r4], #+4
        STR     r1, [r2], #+4
        SUBS    r3, r3, #4
        BNE     CopyLibStatics

  [ StrongARM
        ; There may have been code in the data area, synchronise it
        LDR     r1, [sp]
        STR     r0, [sp]
        MOV     r0, #1
        SWI     XOS_SynchroniseCodeAreas
        LDMFD   sp!, {r0,r14}
  ]

        LDR     r1, [r14, #LI_Id-LI_ItemSize]
        CMP     r1, #1                  ; was this the library kernel?
        BNE     NextLibraryChunk
        CMP     r11, #3
        ORRGE   r3, r3, #ClientFlag_APCS_32
05      STRB    r3, [r2, #-32*4]        ; yuck! - set ClientFlags
        B       NextLibraryChunk

EndStubInit
        ; Set up SL_Lib_Offset
        LDR     r12, [r13, #Proc_RegOffset + 4]          ; r1 out
        STR     r5, [r12, #SC_SLOffset+SL_Lib_Offset]

        MOV     r6, #LibraryVersionNumber
Proc_RegList    SETS "r0-r5, r12"  ; don't restore r6 (hacky :))
        EXITS

Failed
        ; Here with r0=error block if failed for one reason or another
        BL      |_kernel_copyerror|
        STR     r0, [r13, #Proc_RegOffset]
        EXITVS

StubInitValue
        MOV     pc, #0

PickRoutineVariant ROUT
        ; In:
        ; r6 -> variant block + 1
        ;       word 0: 4x OS_PlatformFeatures 34 flags
        ;       word 1: Offset to routine to use if all features supported
        ;       word 2: Offset to routine to use if features not supported
        ; Out:
        ; r6 -> routine to use
        Entry   "r0-r3"
        SUB     r2, r6, #1
        ADD     r6, r6, #3 ; r6 -> word 1
10
        LDRB    r3, [r2], #1
        CMP     r3, #255
        BEQ     %FT20
        MOV     r0, #OSPlatformFeatures_ReadCodeFeatures
        SWI     XOS_PlatformFeatures
        BVS     %FT15
        TST     r0, #CPUFlag_ExtraReasonCodesFixed ; Is it safe to try calling non-zero reason codes?
        MOV     r0, #OSPlatformFeatures_ReadCPUFeatures
        ASSERT  OSPlatformFeatures_ReadCPUFeatures != 1
        MOVNE   r1, r3
        SWINE   XOS_PlatformFeatures
15
        CMP     r0, #1        ; If SWI returned an error, assume error pointer wasn't '1'
        BEQ     %BT10         ; Feature supported, check next flag
        ADD     r6, r6, #4    ; Feature(s) not supported, use fallback routine
20
        LDR     r0, [r6]      ; get address of matching routine
        ADD     r6, r6, r0    ; apply offset
        EXIT


        ErrorBlock UnknownSWI, "SWI value out of range for module %0", BadSWI
        ErrorBlock BadMemory, "Not enough memory for C library", C01
        ErrorBlock UnknownLib, "Unknown library chunk", C02
        ErrorBlock StaticSizeWrong, "Static data size in library and stub disagree", C04
        ErrorBlock StaticOffsetInconsistent, "Static data offset not the same for all library chunks", C05
        ErrorBlock OldAPCS_A, "Calling standard APCS-A no longer supported by C library", C71, withdefault
 [ {CONFIG}<>26
        ErrorBlock OldAPCS_R, "Application is not 32-bit compatible", C72
 ]
        ALIGN

        LTORG

        END
@


4.14
log
@Remove ARM2 NOPs
Detail:
  kernel/s/k_body, s/initmodule - Remove NOPs from after PSR manipulation macros; the macros now fully take care of ARM2 & StrongARM compatibility for us
Admin:
  Tested PlingSystem build on (ARM3) RISC OS 3.1
  Requires HdrSrc-2_63 for ARM2 compatibility


Version 5.92. Tagged as 'RISC_OSLib-5_92'
@
text
@d274 3
d282 10
d424 9
d520 4
d532 9
a553 6
  [ StrongARM
    ; patched branch code requires SynchroniseCodeAreas
    MOV    r0,#0                     ;fully synchronise (too lazy to narrow down address range)
    SWI    XOS_SynchroniseCodeAreas
  ]

@


4.13
log
@When multiple CPU architectures are supported, allow dynamically linked clients to be given optimal versions of routines where possible
Detail:
  This set of changes adds support for representing architecture-specific variants of routines within the export tables which the shared C library uses to fill in the client's stubs.
  This allows builds of the module which target multiple architectures (e.g. IOMD, Raspberry Pi, or softloads) to offer the most optimal versions of routines to clients wherever multiple variants exist.
  If only one architecture is supported, only one version of each routine will be built, and no variant tables will be generated.
  Currently routine selection for staticly linked clients isn't supported - staticly linked targets will only use the most backwards-compatible version of the routines, as before. Also not all routines are catered for yet (e.g. _ll_udiv)
  File changes:
  - s/h_common - New file containing macros used during variant table construction
  - Makefile - Set SHARED_C_LIBRARY to {TRUE} for SCL builds of assembler code, as per the SHARED_C_LIBRARY #define
  - kernel/s/k_body, s/longlong - For routines which have multiple variants available for the target architectures, build all variants, and generate variant table entries using the new RoutineVariant macro. This has required some reordering of the different variants to make sure that when both versions are built, the most backwards-compatible one will be first (and thus will be called by staticly linked clients)
  - s/h_modmacro - "Entry" macro (when building SCL export tables) changed to use DCD instead of B, to allow byte-aligned symbols to be represented (low bits of symbol address is now used as 'is a variant table' flag)
  - s/initmodule - Client stub initialisation rewritten to take into account the B -> DCD change, and to detect and evaluate variant entries
  - clib/s/cl_entries, kernel/s/k_entries, kernel/s/k_entries2 - Update library entry tables to reference the variant forms of routines where relevant
Admin:
  Tested on Raspberry Pi 1, 2, 3 (ROM), RISC OS 3.1 & StrongARM 3.7 (softload 26bit build)
  Requires Kernel-5_35-4_79_2_325


Version 5.91. Tagged as 'RISC_OSLib-5_91'
@
text
@a231 1
        NOP
@


4.12
log
@Escape some dollars
Detail:
  kernel/s/k_body, s/initmodule - Escape some dollars contained in strings to avoid warnings from objasm
Admin:
  Resulting binary unchanged


Version 5.83. Retagged as 'RISC_OSLib-5_83'
@
text
@d37 1
d193 13
d386 4
a389 7
        LDR     r1, [r4], #+4
        MOV     r1, r1, ASL #8         ; sign-extend branch offset
        ADD     r1, r4, r1, ASR #6     ; and convert to bytes
        ADD     r1, r1, #8-4           ; +8 for pc, -4 for ,#+4 above
        LDR     r6, [r2], #4           ; patch the stub entry only if it's
        CMP     r6, r1                 ; not already right.
        STRNE   r1, [r2, #-4]
d392 1
a392 1
        ; Create a table of BL &xxx
d399 9
a407 9
        LDR     r1, [r4]
        ADD     r1, r1, r4, LSR #2
        SUB     r1, r1, r2, LSR #2
        BIC     r1, r1, #&FF000000
        ORR     r1, r1, #&EA000000     ; le branch!
        ADD     r4, r4, #4
        LDR     r6, [r2], #4           ; patch the stub entry only if it's
        CMP     r6, r1                 ; not already right.
        STRNE   r1, [r2, #-4]
d539 33
@


4.11
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@d61 1
a61 1
        DCB     "SharedCLibrary$Path"
d64 1
a64 1
        DCB     "RISC_OSLibrary$Path"
@


4.10
log
@Update to work with zero page relocation
Detail:
  clib/s/cl_stub, kernel/s/k_body, s/initmodule - Use OS_ReadSysInfo 6 to look up CLibWord/RISCOSLibWord/CLibCounter location each time it's needed instead of using hardcoded addresses. SWI overhead shouldn't be too bad since the zero page areas are rarely used.
  rlib/c/menu - Fix null pointer access when attempting to clear a submenu pointer via menu_submenu(...,...,NULL)
  s/h_workspc - Remove old local definitions of CLibCounter, RISCOSLibWorkSpace and CLibWorkSpace. Use Hdr:PublicWS instead.
Admin:
  Tested on rev A2 BB-xM


Version 5.60. Tagged as 'RISC_OSLib-5_60'
@
text
@d128 1
a128 1
        STMDB   r13!, {lr}
d147 1
a147 1
        LDMIA   r13!, {pc}
d273 1
a273 1
01      STMIA   r1!, {r6}
@


4.9
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@d81 15
a95 3
        MOV     r14, #0
        STR     r14, [r14, #CLibWorkSpace]
        STR     r14, [r14, #RISCOSLibWorkSpace]
d130 8
a137 2
        MOV     r3, #0
        LDR     r2, [r3, #CLibWorkSpace]
d144 1
a144 1
        STR     r3, [r3, #CLibWorkSpace]
@


4.8
log
@  Changes required for Customer W.
Detail:
  * Implemented the thread-safety mutex macros for the user mode heap.
  * Created ansilibm, a version of ansilib suitable for building modules.
  * Fixed an overestimation of the size of the workspace passed to
    SharedCLibrary_LibInitModule[APCS_32] by the stubs.
  * Fixed bug in SharedCLibrary_LibInitModule[APCS_32] regarding handling of
    non-reentrant modules - if module code was at a higher address than the
    module data, then all the intervening data would be pointlessly copied
    back over itself with no allowance for volatility.
  * Removed the bsearch source file, since it was only required for APCS-A
    which the library has not supported since the year 2000, and which the
    compiler is now no longer able to build.
Admin:
  ansilibm builds working modules, but thread safety has not been
  extensively tested.

Version 5.47. Tagged as 'RISC_OSLib-5_47'
@
text
@d30 5
a34 5
        GET     s.h_Regs
        GET     s.h_Brazil
        GET     s.h_stack
        GET     s.h_modmacro
        GET     s.h_workspc
@


4.7
log
@ROM build fixed for 64-bit stuff.
PCI added to swis.h
alloc.c updated to handle bigger slots (new code merged from ARM libraries)
Various 32-bit fixes for backtracing, and general trap handling.
Polite "Application is not 32-bit compatible" message.
Headers <stdint.h> and <inttypes.h> fixed to work in non-C99 mode.
txt changed to do new-style Delete behaviour

Version 5.44. Tagged as 'RISC_OSLib-5_44'
@
text
@d241 1
a241 1
        SUBS    r6, r3, r4
@


4.6
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@d95 2
a96 1
        LDMFD   r13!, {r7-r11, pc}^
d111 1
a111 1
        MOVS    pc, r11
d128 2
a129 1
        LDMIA   r13!, {pc}^
a185 1
      [ {CONFIG}=26
d187 3
a189 1
      |
d191 2
a193 2
        ADRLO   r0, E_OldAPCS
        BLO     Failed
d323 6
a328 3
        LDR     r6, [r13, #Proc_RegOffset + 6*4]
        TST     r6, #1                  ; if in 26-bit mode, just use the BL form
        BEQ     FixBranches             ; as it works, and is faster
d330 1
d362 1
a362 1

d380 1
d515 4
a518 1
        ErrorBlock OldAPCS, "Calling standard no longer supported by C library", C71, withdefault
@


4.5
log
@Added the following C99 features:

  * snprintf(), vsnprintf(), vfscanf(), vscanf(), vsscanf()
  * hh, j, z and t printf length modifiers (indicating char, intmax_t, size_t
    and ptrdiff_t respectively)
  * Hexadecimal floating-point printing and scanning (%a/%A)
  * %F printf() specifier (upper-case form of %F)
  * Input/output of NaNs and Infinities
  * imaxdiv_t, imaxdiv(), strtoimax(), strtoumax() (simulated through macros)
  * <fenv.h>: feclearexcept(), fegetexceptflag(), feraiseexcept(),
              fesetexceptflag(), fetestexcept(), fegetround(), fesetround(),
              fegetenv(), feholdexcept(), fesetenv(), feupdateenv()
  * FLT_EVAL_METHOD, DECIMAL_DIG
  * hypot(), hypotf(), fabsf(), fdim(), fdimf(), fmax(), fmaxf(), fmin(),
    fminf()
  * INFINITY, NAN, fpclassify(), isfinite(), isinf(), isnan(), isnormal(),
    signbit(), copysign(), copysignf(), nan(), nanf(), nextafter(),
    nextafterf() isgreater(), isgreaterequal(), isless(), islessequal(),
    islessgreater(), isunordered()

This involves adding 36 new entries to the stubs. Current versions of the C
library will not fault client programs with such larger stubs, but will fill
in the extra entries with junk. Programs requiring the new functions will have
to RMEnsure this version of the Shared C Library.

This version of the C library has been fixed so that in future, any extra
unknown stubs entries will be filled in with a branch to zero, rather than
corrupted.

Requires cc 5.41 or later, both to build, and to make use of some of the extra
facilities.


Version 5.37. Tagged as 'RISC_OSLib-5_37'
@
text
@d447 3
a449 1
        SUB     r3, r3, r2              ; size of library chunk statics
d451 1
a460 3

        CMP     r3, #0
        BLE     NextLibraryChunk        ; no statics for this chunk
@


4.4
log
@C library now has a default message for C71 (Calling standard no longer
supported), so you get a meaningful message if soft-loading a new version.
No code changes.

Version 5.10. Tagged as 'RISC_OSLib-5_10'
@
text
@d304 1
d306 7
@


4.3
log
@32-bit work merged from kbracey_32bit branch.

Version 5.06. Tagged as 'RISC_OSLib-5_06'
@
text
@d499 1
a499 1
        ErrorBlock OldAPCS, "Calling standard no longer supported by C library", C71
@


4.2
log
@Version RO_3_70 taken
@
text
@a21 2
        GET     s.h_StrongA

d23 1
d25 2
a26 1
SharedLibrary   SETL    {TRUE}
d36 2
d149 4
a152 1
;              r6 [0:15] = 0
d175 1
a175 2
        ;  0  old-style init.  Client uses APCS_A.  If this is an APCS_U
        ;     module, entry is via compatibility veneer.
d178 2
d181 1
a181 1
        STMFD   r13!, {r0-r5, lr}
d184 9
a192 5
 [ Calling_Standard = "APCS_A"
        CMP     r11, #0
  |
        CMP     r11, #2
 ]
d196 2
a197 2
        TEQP    pc, #3                  ; ensure IRQs enabled
        MOV     r0, r0
d205 1
d212 1
a212 5
        ; if APCS_A, entry r6 is unknown (and certainly doesn't contain a
        ; requested stack size)
        CMP     r11, #0
        MOVEQ   r6, #0
        ; Otherwise, for things linked with old stubs r6 may be zero - if so,
d214 1
a214 1
        MOVNES  r6, r6, LSR #6
d222 1
d224 7
d232 1
d305 32
a336 9
 [ Calling_Standard <> "APCS_A"
        CMP     r11, #0
        BNE     DirectEntry

        ; Branch patchup for SWI Lib_Init0

        LDR     r4, [r14, #LI_EntryEnd-LI_ItemSize]
        ADD     r4, r4, #4              ; look at the second word in vector entries
CV_FixEntries
d339 10
a348 16
        LDR     r1, [r4], #+8
        CMP     r1, #0
        ; If first word is a branch we patch the stub to branch to the same place
        ; (r4 is one word ahead of where the pc would be executing the branch)
        LDREQ   r1, [r4, #-12]
        ADDEQ   r1, r1, r4, LSR #2
        SUBEQ   r1, r1, #1+2
        ; Otherwise, we patch the stub to branch to the vector entry.
        ; (r4 points three words ahead of it).
        MOVNE   r1, r4, LSR #2
        SUBNE   r1, r1, #3+2
        SUB     r1, r1, r2, LSR #2
        BIC     r1, r1, #&FF000000
        ORR     r1, r1, #&EA000000     ; le branch!
        STR     r1, [r2], #4
        B       CV_FixEntries
d350 1
a350 3
DirectEntry
        ; Branch patchup for SWI Lib_Init1 and Lib_Init2
 ]
d355 1
a355 1
        LDR     r1, [r4], #+4
a356 1
        SUB     r1, r1, #-1+2          ; -1 for ,#+4 above and +2 for pc being 2 ahead of 'here'
d360 1
d376 1
a376 1
 [ 0 = 1
d441 1
a441 1
        LDR     r1, [r13, #4]
d464 4
a467 7
 [ Calling_Standard = "APCS_A"
        MOVEQ   r3, #0
   |
        SUBEQ   r3, r11, #1
        MOVEQ   r3, r3, LSR #31         ; 1 if r11 was 0, 0 if r11 was >= 1
 ]
        STREQB  r3, [r2, #-32*4]        ; yuck! - set APCS_A_Client
d472 1
a472 1
        LDR     r12, [r13, #4]          ; r1 out
d482 2
a483 1
        LDMFD   r13!, {r0-r5, pc}^
d488 2
a489 3
        STR     r0, [r13]
        LDMFD   r13!, {r0-r5, lr}
        ORRS    pc, lr, #OverflowBit
d499 1
@


4.2.10.1
log
@_kernel_unwind now understands SFMFD instructions in function entry.
It also copes with STFE now - it was totally broken.
32-bit stubs and corresponding LibInit SWIs created.
All rather untested.

Version 4.97, 4.12.2.3. Tagged as 'RISC_OSLib-4_97-4_12_2_3'
@
text
@d22 2
d25 1
a27 3
        GBLL    NoStubEntries
NoStubEntries   SETL    {TRUE}  ; stop h_modmacro defining Entry

a35 2
        GET     Hdr:Proc

d147 1
a147 4
;              r6 [0] = 0 if client is running in a 26-bit mode (may still be APCS-32)
;                     = 1 if client is running in a 32-bit mode (=> must be APCS-32,
;                       and address constant table must follow vectors)
;              r6 [1:15] = 0
a173 2
        ;  3  APCS-32 init.  Client uses APCS-3/32bit.
        ;  4  APCS-32 module init.  Stack is SWI stack, not in the heap.
d175 1
a175 1
        EntryS  "r0-r6"
d181 1
a181 1
        CMP     r11, #4
d186 2
a187 2
        CLRPSR  F_bit:OR:I_bit, lr      ; ensure IRQs enabled
        NOP
a194 1
        CMPNE   r11, #4
a214 1
      [ Proc_RegOffset = 0
a215 7
      |
        [ Proc_RegOffset = 4
        STMIB   r13, {r2, r12, lr}      ; return values of r0, r1 & r2 (Data end, stack base and stack top)
        |
        ! 1, "Proc_RegOffset = ?"
        ]
      ]
a216 1
        CMPNE   r11, #4
d318 1
a318 1
        ; Branch patchup for SWI Lib_Init1 to 4
a319 28
        ; r2 = entry vector base
        ; r3 = entry vector limit
        ; r6 bit 0 set => 32-bit mode (so BL not valid), and address constant table
        ; of same size follows immediately after

        LDR     r6, [r13, #Proc_RegOffset + 6*4] ; not APCS-A, so entry R6 valid
        TST     r6, #1                  ; if in 26-bit mode, just use the BL form
        BEQ     FixBranches             ; as it works, and is faster

        ; Create a table of LDR PC,&xxx followed by the address constants

        LDR     r1, =&E59FF000          ; LDR PC,[PC,#+0]
        SUB     r4, r3, r2              ; r4 = size of table (remember for later)
        SUBS    r6, r4, #8              ; r6 = offset to use in LDR
        BICMI   r1, r1, #1:SHL:23       ; handle the negative case (just possible
        RSBMI   r6, r6, #0              ; for a single entry stub table)
        CMP     r6, #&1000              ; Offset must be <= &FFF
        ADRHS   r0, E_UnknownLib        ; Can't be bothered to make a new error
        BHS     Failed

        ORR     r6, r1, r6
FixLDRs
        CMP     r2, r3
        STRNE   r6, [r2], #4
        BNE     FixLDRs                 ; Write the LDR PC,[PC,#<xxx>] into each entry

        ADD     r3, r2, r4              ; r2, r3 now point to address constant table

d321 1
a321 1
FixAddresses
a324 16
        MOV     r1, r1, ASL #8         ; sign-extend branch offset
        ADD     r1, r4, r1, ASR #6     ; and convert to bytes
        ADD     r1, r1, #8-4           ; +8 for pc, -4 for ,#+4 above
        LDR     r6, [r2], #4           ; patch the stub entry only if it's
        CMP     r6, r1                 ; not already right.
        STRNE   r1, [r2, #-4]
        B       FixAddresses

        ; Create a table of BL &xxx

FixBranches
        LDR     r4, [r14, #LI_EntryBase-LI_ItemSize]    ; Our entry table
FixEntries
        CMP     r2, r3
        BEQ     ChunkEntriesDone
        LDR     r1, [r4]
d326 1
a329 1
        ADD     r4, r4, #4
d410 1
a410 1
        LDR     r1, [r13, #Proc_RegOffset + 4]
a434 1
        STREQB  r3, [r2, #-32*4]        ; yuck! - set ClientFlags
d436 2
a437 9
        BNE     NextLibraryChunk
        LDR     r1, [r13, #Proc_RegOffset + 6 * 4]
        SUB     r3, r11, #1
        MOV     r3, r3, LSR #31         ; 1 if r11 was 0, 0 if r11 was >= 1
        CMP     r11, #3
        ORRGE   r3, r3, #2              ; +2 if r11 was >= 3 (APCS_32)
        TST     r1, #1
        ORRNE   r3, r3, #4              ; +4 if r6 bit 1 was set (32-bit mode)
        STRB    r3, [r2, #-32*4]        ; yuck! - set ClientFlags
d439 1
d444 1
a444 1
        LDR     r12, [r13, #Proc_RegOffset + 4]          ; r1 out
d454 1
a454 2
Proc_RegList    SETS "r0-r5, r12"  ; don't restore r6 (hacky :))
        EXITS
d459 3
a461 2
        STR     r0, [r13, #Proc_RegOffset]
        EXITVS
@


4.2.10.2
log
@Most of the obvious problems in the last check-in fixed. It now builds, at
least.
Stubs now correctly, and internationalisably, report "C library too old".
Both BL and LDR PC forms of branch table successfully created.
Tested on various existing 26-bit programs, and one 32-bit program tested.

Version 4.97, 4.12.2.4. Tagged as 'RISC_OSLib-4_97-4_12_2_4'
@
text
@d499 3
a501 3
        TEQ     r11, #0
        MOVEQ   r3, #ClientFlag_APCS_A
        BEQ     %FT05
d503 1
a503 3
        ORRGE   r3, r3, #ClientFlag_APCS_32
        BLT     %FT05
        LDR     r1, [r13, #Proc_RegOffset + 6 * 4]
d505 2
a506 2
        ORRNE   r3, r3, #ClientFlag_32bit
05      STRB    r3, [r2, #-32*4]        ; yuck! - set ClientFlags
@


4.2.10.3
log
@More 32-bit work. Now functional, but still need to sort out various
build issues.

Version 4.97, 4.12.2.7. Tagged as 'RISC_OSLib-4_97-4_12_2_7'
@
text
@a405 1
        ; KJB - Nov 99; just check that we have enough, not an exact match
d504 4
@


4.2.10.4
log
@Features:

* APCS-32 support complete.
* APCS-A compatibility removed.
* Old ArthurLib code removed.
* _clib_version() now reports version from VersionNum.
* time() no longer does a run-time host check - I think we know we're not a BBC
  Master ARM second processor now.
* rename() now uses OS_FSControl 25 instead of *rename.
* getenv() can handle arbitrary length variables.
* Can now handle exceptions in 32-bit form of FPEmulator (on either 26 or 32
  bit systems).
* tmpnam() switches to SVC mode to access its zero page counter.
* Faster divide routines.

Admin:

  This will build all sorts of different things depending on the flags. See
  the Docs directory for details.

  As far as ROM builds are concerned, if using APCS-R, no changes are needed.
  If using APCS-32, the Shared C Library must be built as APCS-R to ensure
  compatibility with old binaries. To achieve this, pass in the option
  SCL_APCS="-APCS 3/26bit" in the Components file.

Version 4.97, 4.12.2.8. Tagged as 'RISC_OSLib-4_97-4_12_2_8'
@
text
@d175 2
a176 1
        ;  0  old-style init.  Client uses APCS_A.  No longer supported.
d185 3
a187 8
      [ {CONFIG}=26
        CMP     r11, #1
      |
        CMP     r11, #3
      ]
        ADRLO   r0, E_OldAPCS
        BLO     Failed

d189 1
d209 5
a213 1
        ; For things linked with old stubs r6 may be zero - if so,
d215 1
a215 1
        MOVS    r6, r6, LSR #6
d306 27
d334 1
d336 1
d342 1
a342 1
        LDR     r6, [r13, #Proc_RegOffset + 6*4]
d406 2
a407 1
 [ 1 = 1
d495 4
d500 3
d506 1
a537 1
        ErrorBlock OldAPCS, "Calling standard no longer supported by C library", C71
@


4.1
log
@Initial revision
@
text
@d22 2
d447 6
a452 1
        ; return
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a21 2
        GET     s.h_StrongA

d445 1
a445 6
  [ StrongARM
    ; patched branch code requires SynchroniseCodeAreas
    MOV    r0,#0                     ;fully synchronise (too lazy to narrow down address range)
    SWI    XOS_SynchroniseCodeAreas
  ]

@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

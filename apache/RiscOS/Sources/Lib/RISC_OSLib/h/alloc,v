head	4.6;
access;
symbols
	RISC_OSLib-5_97:4.6
	RISC_OSLib-5_96:4.6
	RISC_OSLib-5_95:4.6
	RISC_OSLib-5_94:4.6
	RISC_OSLib-5_93:4.6
	RISC_OSLib-5_92:4.6
	RISC_OSLib-5_91:4.6
	RISC_OSLib-5_90:4.6
	RISC_OSLib-5_89:4.6
	RISC_OSLib-5_88:4.6
	RISC_OSLib-5_87:4.6
	RISC_OSLib-5_86-1:4.6
	RISC_OSLib-5_86:4.6
	RISC_OSLib-5_85:4.6
	RISC_OSLib-5_84:4.6
	RISC_OSLib-5_83-2:4.6
	RISC_OSLib-5_83-1:4.6
	RISC_OSLib-5_83:4.6
	RISC_OSLib-5_82:4.6
	RISC_OSLib-5_81:4.6
	RISC_OSLib-5_75-2:4.6
	RISC_OSLib-5_80:4.6
	RISC_OSLib-5_79:4.6
	RISC_OSLib-5_78:4.6
	RISC_OSLib-5_75-1:4.6
	RISC_OSLib-5_77:4.6
	RISC_OSLib-5_76:4.6
	RISC_OSLib-5_75:4.6
	RISC_OSLib-5_74:4.6
	RISC_OSLib-5_73:4.6
	RISC_OSLib-5_72:4.6
	RISC_OSLib-5_71:4.6
	RISC_OSLib-5_70:4.6
	RISC_OSLib-5_69:4.6
	RISC_OSLib-5_68:4.6
	RISC_OSLib-5_67:4.6
	RISC_OSLib-5_66:4.6
	RISC_OSLib-5_65:4.6
	RISC_OSLib-5_64:4.6
	RISC_OSLib-5_63:4.6
	RISC_OSLib-5_62:4.6
	RISC_OSLib-5_61:4.6
	RISC_OSLib-5_60:4.6
	RISC_OSLib-5_59:4.6
	RISC_OSLib-5_58:4.6
	RISC_OSLib-5_57:4.6
	RISC_OSLib-5_56:4.6
	RISC_OSLib-5_55:4.6
	RISC_OSLib-5_54:4.6
	RISC_OSLib-5_53:4.6
	RISC_OSLib-5_52:4.6
	RISC_OSLib-5_51:4.6
	RO_5_07:4.6
	RISC_OSLib-5_50:4.6
	RISC_OSLib-5_49:4.6
	RISC_OSLib-5_46-4_64_2_1:4.5
	NoInlineAsm:4.5.0.2
	RISC_OSLib-5_48:4.6
	RISC_OSLib-5_47:4.5
	RISC_OSLib-5_46:4.5
	RISC_OSLib-5_45:4.5
	RISC_OSLib-5_44:4.5
	RISC_OSLib-5_43:4.4
	RISC_OSLib-5_42:4.4
	RISC_OSLib-5_41:4.4
	RISC_OSLib-5_40:4.3
	RISC_OSLib-5_39:4.3
	RISC_OSLib-5_38:4.3
	RISC_OSLib-5_37:4.3
	RISC_OSLib-5_36:4.3
	RISC_OSLib-5_35:4.3
	RISC_OSLib-5_34:4.3
	RISC_OSLib-5_33-4_50_2_1:4.3
	sbrodie_dev:4.3.0.6
	sbrodie_dev_bp:4.3
	RISC_OSLib-5_33:4.3
	RISC_OSLib-5_32:4.3
	RISC_OSLib-5_31:4.3
	RISC_OSLib-5_30:4.3
	RISC_OSLib-5_29:4.3
	RISC_OSLib-5_28:4.3
	RISC_OSLib-5_27:4.3
	RISC_OSLib-5_26:4.3
	RISC_OSLib-5_25:4.3
	RISC_OSLib-5_24:4.3
	RISC_OSLib-5_01-4_16_2_5:4.3
	RISC_OSLib-5_23:4.3
	RISC_OSLib-5_22:4.3
	RISC_OSLib-5_21:4.3
	RISC_OSLib-5_20:4.3
	RISC_OSLib-5_19:4.3
	RISC_OSLib-5_18:4.3
	RISC_OSLib-5_17:4.3
	RISC_OSLib-5_16:4.3
	RISC_OSLib-5_15:4.3
	dellis_autobuild_BaseSW:4.3
	RISC_OSLib-5_14:4.3
	RISC_OSLib-5_13:4.3
	RISC_OSLib-5_12:4.3
	RISC_OSLib-5_01-4_16_2_4:4.3
	RISC_OSLib-5_11:4.3
	RISC_OSLib-5_01-4_16_2_3:4.3
	RISC_OSLib-5_01-4_16_2_2:4.3
	RISC_OSLib-5_10:4.3
	RISC_OSLib-5_01-4_16_2_1:4.3
	Bethany:4.3.0.4
	RISC_OSLib-5_09:4.3
	RISC_OSLib-5_08:4.3
	RISC_OSLib-5_07:4.3
	RISC_OSLib-5_06:4.3
	RISC_OSLib-4_97-4_12_2_8:4.3
	RISC_OSLib-5_05:4.3
	RISC_OSLib-5_04:4.3
	sbrodie_sedwards_16Mar2000:4.3
	RISC_OSLib-5_03:4.3
	RISC_OSLib-5_02:4.3
	RISC_OSLib-4_97-4_12_2_7:4.3
	RISC_OSLib-5_01:4.3
	RISC_OSLib-5_00:4.3
	RISC_OSLib-4_99:4.3
	RISC_OSLib-4_98:4.3
	RISC_OSLib-4_97-4_12_2_6:4.3
	RISC_OSLib-4_97-4_12_2_5:4.3
	RISC_OSLib-4_97-4_12_2_4:4.3
	RISC_OSLib-4_97-4_12_2_3:4.3
	RISC_OSLib-4_97-4_12_2_2:4.3
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.3
	kbracey_32bit:4.3.0.2
	kbracey_32bit_bp:4.3
	dcotton_autobuild_BaseSW:4.3
	RISC_OSLib-4_97:4.3
	RISC_OSLib-4_96:4.3
	RISC_OSLib-4_95:4.3
	RISC_OSLib-4_94:4.3
	RISC_OSLib-4_93:4.3
	RISC_OSLib-4_92:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	sforrest_daytona_appflash-0_31:4.2
	RISC_OSLib-4_91:4.3
	RISC_OSLib-4_90:4.3
	RISC_OSLib-4_89:4.3
	Ursula_merge:4.2
	RISC_OSLib-4_88:4.3
	RISC_OSLib-4_87:4.3
	blaughto_daytona_appflash-0_30:4.2
	rmanby_clib-4_86:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2003.12.02.16.51.31;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.15.15.00.29;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2002.05.22.10.45.26;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.08.27.10.01.14;	author smiddle;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.42.41;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.01;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.25.01;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.52.56;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.29.03;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.48.39;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@  Changes for Customer W; also suitable for building on an Iyonix.
Detail:
  * No longer uses aasm to build h.swis.
  * (Only) compatible with new C compilers: assumes const static data is
    placed in separate read-only areas, and suitable command-line switch
    is used to ensure that library static data is never placed in a zero-
    init area.
  * Stack extension code now thread-safe.
  * Heap thread-safety code (in clib) now uses SWP instruction test results
    from stack extension code (in kernel) - as a side effect, the exported
    symbol _swp_available now exists, if you need to use it elsewhere.
  * Slightly closer to having top-bit-set heap addresses working.
Admin:
  Tested in a Tungsten build, and with Customer W's test suite.

Version 5.48. Tagged as 'RISC_OSLib-5_48'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
  Title:        alloc - Storage management (dynamic allocation/deallocation)
  Copyright:    (C) 1987, Acorn Computers Ltd., Cambridge, England.
  Revision: 4.2  LDS, LH 03-Nov-89
*/

#ifndef __alloc__h
#define __alloc__h

#ifndef __stddef__h
#include <stddef.h>
#endif

/* #define CAMEL */
#define BLOCKS_GUARDED */
#define MULTITHREADED */
/* #define GC */
/* #define STATS */
/* #define DEBUG */
/* #define STACKCHECK */
/* #define VERBOSE */
/* #define ANALYSIS prints +No on allocate and -No on deallocate */
/* #define MEMDUMP gives a memory dump to screen and $.memdump when corrupt */
/*
 * if the OSStorage can not be depended upon to allocate areas of the
 *   heap in consistently increasing address order then the following
 *   constant must be set to FALSE.
 */
#define HEAP_ALLOCATED_IN_ASCENDING_ADDRESS_ORDER 1

typedef struct BlockStruct {
#ifdef BLOCKS_GUARDED
  unsigned int guard; /* guard word should contain GuardConstant if all ok */
#endif
  size_t size; /* block size (not including header) in address units. */
               /* The bottom 2 bits of size hold the flags declared below */
  struct BlockStruct *next; /* next and previous are used internaly in */
  struct BlockStruct *previous; /* coalescing and managing free blocks. */
                                /* next is the first word of the user block */
} Block, *BlockP;

#define OK       0
#define FAILED  -1
#define CORRUPT -2
#define MINHEAPERROR -2 /* ensure you update this if you add any new errors */

#define SIZEMASK      0xfffffffc /* all except bottom two bits, when applied */
                                 /* to block.size yields no of address units */
                                 /* of user space in this block. */
#define FREEBIT       (1U<<0) /* if set, indicates that the block is free */
#define HEAPHOLEBIT   (1U<<1) /* block used for marking start of heap hole */
#define GUARDCONSTANT 0x3E694C3C /* not a legal word pointer */
#define BYTESPERWORD  sizeof(int)
/* Block.next offset from Block (in words) */
#define FIRSTUSERWORD ((sizeof(Block)-sizeof(BlockP)*2) / BYTESPERWORD)

extern void _init_alloc(void);
/*
 * Initialise allocate (not to be called by anyone outside the M2Core!)
 */

typedef void FreeProc (BlockP block);
/* block = pointer to start of header of block to be freed */


extern size_t _byte_size(void *p);
/*
 * Return an approximation to the allocated size of the object pointed
 * to by p. The only guarantee is that:-
 *   requested_size(p) <= _byte_size(p) <= allocated_size(p).
 */

extern void *_sys_alloc(size_t n);
/*
 * A paranoid variant of malloc used by the C compiler.
 */

extern int __coalesce(void);
/*
 * Perform a colesce step on the heap. Returns OK or Corrupt.
 */

/* ---------------------------- Debug aids --------------------------------- */

#ifdef BLOCKS_GUARDED
extern void __heap_checking_on_all_deallocates(int on);
/*
 * If on = TRUE, the structure of the heap is checked on every deallocate
 */

extern void __heap_checking_on_all_allocates(int on);
/*
 * If on = TRUE, the structure of the heap is checked on every allocate
 */
#endif

/* ------------------------- Statistics reporting --------------------------*/
typedef enum {
  COALESCE,
  EXTENSION,
  COALESCE_AND_EXTENSION
} Event;

typedef struct StorageInfoStruct {
  BlockP heapLow; /* heap base */
  BlockP heapHigh; /* heap top */
  unsigned int userHeap; /* user part of heap = heapHigh-heapLow-gcbitmaps */
  unsigned int maxHeapRequirement; /* max storage actually requested by user */
  unsigned int currentHeapRequirement;  /* current user requested storage */
  unsigned int coalesces; /* number of coalesces performed, includes number
                             of garbage collections cos a coalesce is done
                             after every garbage collection. */
  unsigned int heapExtensions;    /* number of times that heap is extended */
  unsigned int blocksAllocated;   /* total number of allocates requested */
  unsigned int blocksDeallocated; /* total number of deallocates requested */
  unsigned int bytesAllocated;    /* total number of bytes allocated */
  unsigned int bytesDeallocated;  /* total number of bytes deallocated */
} StorageInfo, *StorageInfoP;

typedef struct EventInfoStruct {
  Event event;
  size_t blockThatCausedEvent; /* size of allocate that caused event */
  unsigned int totalFree;  /* amount of heap that user can actually write to,
                              does not include bitmaps and block overheads */
  unsigned int userHeap;   /* user part of heap = heapHigh-heapLow-gcbitmaps */
  /* the following are changes from previous event */
  unsigned int allocates;        /* number of allocates requested */
  unsigned int bytesAllocated;   /* number of bytes allocated */
  unsigned int deallocates;      /* number of deallocates requested */
  unsigned int bytesDeallocated; /* number of bytes deallocated */
} EventInfo, *EventInfoP;

#ifdef STATS
extern void _GetStorageInfo(StorageInfoP info);
/*
 * Get statistics on the current state of the storage manager
 */

extern int _GetLastEvent(void);
/*
 * returns the number of the last event to happen in the storage manager.
 */

extern int _GetEventData(int event, EventInfoP info);
/*
 * get the record which describes the state of the storage manager for the
 * given event. Returns FALSE if no more records available. All records can
 * be read from GetLastEvent() downwards until FALSE is returned.
 */

extern void _NextHeapElement(
  BlockP *nextBase,         /* updated to point to start of next block */
  unsigned int *guard,      /* value of guard word */
  size_t *size,             /* size of user block in bytes */
  int *free,                /* if true, block is free */
  int *heapHole,            /* if true, block is a heap hole */
  int *bitmap,              /* if true, block is a gc bitmap */
  unsigned int *firstWord); /* first word of the user block */
/*
 * Get data describing the heap block pointed at by nextBase (first block is
 * accessed by nextBase = NIL) nextBase is set to NIL when the last block has
 * been read (not on the attempt to read the last block)
 */
#endif /* stats */


#define BITSIZE(bytes) ((bytes)<<3)
#define BITSPERWORD  BITSIZE(sizeof(int))
#define BITSPERBYTE  (BITSPERWORD/BYTESPERWORD)
/*
 * The following constants are all in address units
 */
/* MAXBYTES should be something outrageously big */
#define MAXBYTES     0x40000000
#define OVERHEAD     (FIRSTUSERWORD * BYTESPERWORD)
#define HOLEOVERHEAD OVERHEAD
#define MINBLOCKSIZE (OVERHEAD + BYTESPERWORD)

/* the following constants are tunable */
/* multiple of required block size needing to be free before coalesce done */
#define BINRANGE     (BYTESPERWORD * 1) /* see assumptions */
#define NBINS        16
#define MAXBINSIZE   (BINRANGE*(NBINS)-1)
#define LARGEBLOCK   512

/*
 * Code macros.
 */
#define SIZE(block) ((size_t)((block)->size & SIZEMASK))
#define BITSTOWORDS(bits) ((bits+(BITSPERWORD-1))/BITSPERWORD)
#define BYTESTOWORDS(bytes) ((bytes+(BYTESPERWORD-1))/BYTESPERWORD)
#define ADDBYTES(bp, bytes) (BlockP)((char *)bp + (bytes))
#define ADDBYTESTO(bp, bytes) bp = (BlockP)((char *)bp + (bytes))
#define PTRDIFF(hi, lo) ((char *)hi - (char *)lo)
#define FREE(block) (FREEBIT & ((BlockP)block)->size)
#define HEAPHOLE(block) (HEAPHOLEBIT & block->size)

#ifdef BLOCKS_GUARDED
#define INVALID(block) (((BlockP)block)->guard != GUARDCONSTANT)
#else
#define INVALID(block) (0)
#endif
#define BADUSERBLOCK(block) (INVALID(ADDBYTES(block,-OVERHEAD)) \
                            || FREE(ADDBYTES(block,-OVERHEAD)))

#endif
@


4.5
log
@ROM build fixed for 64-bit stuff.
PCI added to swis.h
alloc.c updated to handle bigger slots (new code merged from ARM libraries)
Various 32-bit fixes for backtracing, and general trap handling.
Polite "Application is not 32-bit compatible" message.
Headers <stdint.h> and <inttypes.h> fixed to work in non-C99 mode.
txt changed to do new-style Delete behaviour

Version 5.44. Tagged as 'RISC_OSLib-5_44'
@
text
@d59 1
@


4.4
log
@* Added two new library chunks, 4 and 5, which contain extensions to the kernel
  and C library respectively. These have no static data associated with them,
  just being extensions of the stub tables. The reason for this is to minimise
  wasted space in programs that don't use the C99 facilities; o.stubs is now
  a library split into 3 pieces - basic kernel and CLib, extra kernel and extra
  CLib; only the bits a program needs get included.

* Previous extensions to the C library stubs revoked - they now stop at _swix;
  all the new C99 functions now live in chunk 4. Anyone using those new
  functions should relink with new stubs and ensure this C library version.

* printf/scanf now support 64-bit types through "ll" and "j" length modifiers.

* Run-time support for VLAs (__rt_allocauto and __rt_freeauto) added. No
  attempt is currently made to clear up on longjmp or to cope with someone
  changing the kernel allocator while a VLA is active. These would be a
  future enhancement.

* Added complete 64-bit run-time support (48 functions) to kernel library;
  these functions are compatible with the ones used by the ARM ADS. Many of
  the simpler functions will not normally be used by the compiler, as it
  will generate inline code. There is scope for improvement by switching
  in MULL and CLZ-using forms of multiply and divide when possible.

* llabs and lldiv added to C library.

* Header files corrected in a few areas, and changed to match the C compiler.
  <stdint.h> and <stdbool.h> now require the compiler to be in C99 mode
  (as detected using __STDC_VERSION__).


Version 5.41. Tagged as 'RISC_OSLib-5_41'
@
text
@d50 1
a50 1
               /* The top 5 bits of size hold the flags declared above */
d60 1
a60 1
#define SIZEMASK      0x07ffffff /* all except top five bits, when applied */
d63 2
a64 5
#define PUREDATABIT   (1u<<31) /* indicates the block contains no pointers */
#define NOTGCABLEBIT  (1u<<30) /* the block is not to be garbage collected */
#define USEDBIT       (1u<<29) /* if set, indicates that the block is not free */
#define FREEBIT       (1u<<28) /* if set, indicates that the block is free */
#define HEAPHOLEBIT   (1u<<27) /* block used for marking start of heap hole */
a65 3
#define GCABLE        0
#define GCDATA        PUREDATABIT
#define DATA          (NOTGCABLEBIT|PUREDATABIT)
a77 49
/*
 * alloc maintains a bitmap to be used by the registered GCProc, this is
 * referred to a bitmapA. If the heap maintained by alloce has a hole in it
 * due to OSStorage not extending the heap contiguously then another bitmap
 * (bitmapB) is used to describe the second part of the heap. There may or may
 * not be a bitmapB, but if heapAEnd < topOfHeap there will be. This does not
 * mean that either of the bitmaps will never represent an area of the heap
 * which contains heap holes.
 */
typedef int (*GCProc) (
  BlockP base,
  BlockP limit, /* of the heap */
  char *mapA, /* one bit per word in [base..heapAEnd-1] */
  char *mapB, /* one bit per word in [heapBStart..limit-1] */
  BlockP heapAEnd, /* base == heapA < heapAEnd */
  BlockP heapBStart, /* if heapAEnd < limit --> heapBStart == heapB < limit */
  FreeProc *freeProc);
  /* returns values OK or Corrupt. */

#ifdef GC
extern void _gcallocate(void **a, size_t bitlen, int gcbits);
/*
 * Support for AEM-2 ALLOCATE.
 */

extern void _set_gcbits(void **a, int gcbits);
/*
 * Function to set the GCAble bit and PureData bit to the given values.
 */

extern int __register_gc_proc(GCProc proc);
/*
 * alloc will (at its discretion) call the registered GarbageCollect proc
 * to search for (and instruct alloc to free) any appropriate user block
 * (depends on the gcBits it was allocated with) which has no pointer it's
 * start. Failed or OK can be returned. Failed is returned if no procedure
 * was previously registered and the heap is almost full (alloc will not be
 * able to allocate an area of the heap to hold the bitmaps required for
 * garbage collection).
 */

extern void *_gc_malloc(int gcbits, size_t bytesize);
/*
 * A variant of malloc which allocates garbage-collectable store.
 * Note that the returned pointer must not be lost or chaos may ensue.
 * 'gcbits' allows blocks to be marked as pure data (which speeds up
 * garbage collection).
 */
#endif
a85 12
extern void *malloc(size_t size);
/*
 * Allocate an area of memory of size 'size' and return a pointer to it.
 */

extern void *realloc(void *p, size_t size);
/*
 * Reallocate the block pointed to by p with size 'size' (assumed >
 * _byte_size(p) or this is a no-op). In general, this leads to p
 * being reallocated at a different address.
 */

a90 17
extern void *calloc(size_t count, size_t size);
/*
 * A variant of malloc which allocates 'count' zeroed objects of size 'size'.
 */

extern void free(void *p);
/*
 * Deallocate the block pointed to by 'p'.
 */

extern void _deallocate(void **p, size_t bitlen);
/*
 * Deallocate the block pointed to by 'p' raising the AllocateFailed
 * exception on error.  The M2 DEALLOCATE function.  The bitlen value
 * is ignored.
 */

a95 5
extern int _alloc_reinit(void);
/*
 * re-initialise the heap returns 1 for success otherwise 0.
 */

d111 6
a126 1
  unsigned int garbageCollects;   /* number of garbage collections */
a130 2
  unsigned int totalGCBlocks;     /* total number of blocks gc'd */
  unsigned int totalGCBytes;      /* total number of bytes garbage collected */
d134 1
a134 1
  int event;
a143 2
  unsigned int bytesGCd;         /* number of bytes garbage collected */
  unsigned int blocksGCd;        /* number of blocks garbage collected */
a151 11
/* Events */
typedef int Events;

#define GARBAGE_COLLECT 0
#define COALESCE 1
#define EXTENSION 2
#define COALESCE_AND_EXTENSION 3
#define GC_AND_EXTENSION 4
#define COALESCE_AND_GC_AND_EXTENSION 5
#define COALESCE_AND_GC 6

d178 40
@


4.3
log
@Merged Spinner branch changes onto trunk (new RCA messages files
and Makefile changes). Convert to srccommit while we're at it.
Removed a few $Revision's to prevent future spurious merge clashes.

Version 4.87. Tagged as 'RISC_OSLib-4_87'
@
text
@d63 5
a67 5
#define PUREDATABIT   (1<<31) /* indicates the block contains no pointers */
#define NOTGCABLEBIT  (1<<30) /* the block is not to be garbage collected */
#define USEDBIT       (1<<29) /* if set, indicates that the block is not free */
#define FREEBIT       (1<<28) /* if set, indicates that the block is free */
#define HEAPHOLEBIT   (1<<27) /* block used for marking start of heap hole */
@


4.2
log
@Module merged
@
text
@d18 1
a18 1
  $Revision: 4.1.7.1 $  LDS, LH 03-Nov-89
@


4.1
log
@Initial revision
@
text
@d18 1
a18 1
  $Revision: 1.4 $  LDS, LH 03-Nov-89
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

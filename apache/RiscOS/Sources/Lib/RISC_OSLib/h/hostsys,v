head	4.8;
access;
symbols
	RISC_OSLib-5_97:4.8
	RISC_OSLib-5_96:4.8
	RISC_OSLib-5_95:4.8
	RISC_OSLib-5_94:4.8
	RISC_OSLib-5_93:4.8
	RISC_OSLib-5_92:4.8
	RISC_OSLib-5_91:4.8
	RISC_OSLib-5_90:4.8
	RISC_OSLib-5_89:4.8
	RISC_OSLib-5_88:4.8
	RISC_OSLib-5_87:4.8
	RISC_OSLib-5_86-1:4.8
	RISC_OSLib-5_86:4.8
	RISC_OSLib-5_85:4.8
	RISC_OSLib-5_84:4.8
	RISC_OSLib-5_83-2:4.8
	RISC_OSLib-5_83-1:4.8
	RISC_OSLib-5_83:4.8
	RISC_OSLib-5_82:4.8
	RISC_OSLib-5_81:4.8
	RISC_OSLib-5_75-2:4.8
	RISC_OSLib-5_80:4.8
	RISC_OSLib-5_79:4.8
	RISC_OSLib-5_78:4.8
	RISC_OSLib-5_75-1:4.8
	RISC_OSLib-5_77:4.8
	RISC_OSLib-5_76:4.8
	RISC_OSLib-5_75:4.8
	RISC_OSLib-5_74:4.8
	RISC_OSLib-5_73:4.8
	RISC_OSLib-5_72:4.8
	RISC_OSLib-5_71:4.8
	RISC_OSLib-5_70:4.8
	RISC_OSLib-5_69:4.8
	RISC_OSLib-5_68:4.8
	RISC_OSLib-5_67:4.8
	RISC_OSLib-5_66:4.8
	RISC_OSLib-5_65:4.8
	RISC_OSLib-5_64:4.8
	RISC_OSLib-5_63:4.7
	RISC_OSLib-5_62:4.7
	RISC_OSLib-5_61:4.7
	RISC_OSLib-5_60:4.7
	RISC_OSLib-5_59:4.7
	RISC_OSLib-5_58:4.7
	RISC_OSLib-5_57:4.7
	RISC_OSLib-5_56:4.7
	RISC_OSLib-5_55:4.7
	RISC_OSLib-5_54:4.7
	RISC_OSLib-5_53:4.7
	RISC_OSLib-5_52:4.7
	RISC_OSLib-5_51:4.7
	RO_5_07:4.7
	RISC_OSLib-5_50:4.7
	RISC_OSLib-5_49:4.7
	RISC_OSLib-5_46-4_64_2_1:4.7
	NoInlineAsm:4.7.0.2
	RISC_OSLib-5_48:4.7
	RISC_OSLib-5_47:4.7
	RISC_OSLib-5_46:4.7
	RISC_OSLib-5_45:4.6
	RISC_OSLib-5_44:4.6
	RISC_OSLib-5_43:4.6
	RISC_OSLib-5_42:4.6
	RISC_OSLib-5_41:4.6
	RISC_OSLib-5_40:4.6
	RISC_OSLib-5_39:4.6
	RISC_OSLib-5_38:4.6
	RISC_OSLib-5_37:4.6
	RISC_OSLib-5_36:4.5
	RISC_OSLib-5_35:4.5
	RISC_OSLib-5_34:4.4
	RISC_OSLib-5_33-4_50_2_1:4.4
	sbrodie_dev:4.4.0.2
	sbrodie_dev_bp:4.4
	RISC_OSLib-5_33:4.4
	RISC_OSLib-5_32:4.4
	RISC_OSLib-5_31:4.4
	RISC_OSLib-5_30:4.4
	RISC_OSLib-5_29:4.4
	RISC_OSLib-5_28:4.4
	RISC_OSLib-5_27:4.4
	RISC_OSLib-5_26:4.3
	RISC_OSLib-5_25:4.3
	RISC_OSLib-5_24:4.3
	RISC_OSLib-5_01-4_16_2_5:4.2
	RISC_OSLib-5_23:4.3
	RISC_OSLib-5_22:4.3
	RISC_OSLib-5_21:4.3
	RISC_OSLib-5_20:4.3
	RISC_OSLib-5_19:4.3
	RISC_OSLib-5_18:4.3
	RISC_OSLib-5_17:4.3
	RISC_OSLib-5_16:4.3
	RISC_OSLib-5_15:4.3
	dellis_autobuild_BaseSW:4.2
	RISC_OSLib-5_14:4.2
	RISC_OSLib-5_13:4.2
	RISC_OSLib-5_12:4.2
	RISC_OSLib-5_01-4_16_2_4:4.2
	RISC_OSLib-5_11:4.2
	RISC_OSLib-5_01-4_16_2_3:4.2
	RISC_OSLib-5_01-4_16_2_2:4.2
	RISC_OSLib-5_10:4.2
	RISC_OSLib-5_01-4_16_2_1:4.2
	Bethany:4.2.0.4
	RISC_OSLib-5_09:4.2
	RISC_OSLib-5_08:4.2
	RISC_OSLib-5_07:4.2
	RISC_OSLib-5_06:4.2
	RISC_OSLib-4_97-4_12_2_8:4.2
	RISC_OSLib-5_05:4.2
	RISC_OSLib-5_04:4.2
	sbrodie_sedwards_16Mar2000:4.2
	RISC_OSLib-5_03:4.2
	RISC_OSLib-5_02:4.2
	RISC_OSLib-4_97-4_12_2_7:4.2
	RISC_OSLib-5_01:4.2
	RISC_OSLib-5_00:4.2
	RISC_OSLib-4_99:4.2
	RISC_OSLib-4_98:4.2
	RISC_OSLib-4_97-4_12_2_6:4.2
	RISC_OSLib-4_97-4_12_2_5:4.2
	RISC_OSLib-4_97-4_12_2_4:4.2
	RISC_OSLib-4_97-4_12_2_3:4.2
	RISC_OSLib-4_97-4_12_2_2:4.2
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.2
	kbracey_32bit:4.2.0.2
	kbracey_32bit_bp:4.2
	dcotton_autobuild_BaseSW:4.4
	RISC_OSLib-4_97:4.2
	RISC_OSLib-4_96:4.2
	RISC_OSLib-4_95:4.2
	RISC_OSLib-4_94:4.2
	RISC_OSLib-4_93:4.2
	RISC_OSLib-4_92:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	sforrest_daytona_appflash-0_31:4.1
	RISC_OSLib-4_91:4.2
	RISC_OSLib-4_90:4.2
	RISC_OSLib-4_89:4.2
	Ursula_merge:4.1.4.1
	RISC_OSLib-4_88:4.1
	RISC_OSLib-4_87:4.1
	blaughto_daytona_appflash-0_30:4.1
	rmanby_clib-4_86:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2011.10.28.14.23.35;	author bavison;	state Exp;
branches;
next	4.7;
commitid	hIG6j26y6NoxM7Fv;

4.7
date	2003.04.15.16.50.28;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	2002.03.21.14.36.26;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	2002.01.29.16.03.35;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2001.02.22.13.10.50;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.10.02.10.46.57;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.10.01.09.14.24;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.01;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.25.01;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.52.57;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.03.26.12.14.42;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.29.06;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.48.40;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.8
log
@  File handling improvements
Detail:
  * Added 64-bit file pointer API support, following the LFS spec v1.5
    (see Docs directory). Internally, now uses 64-bit file pointers
    exclusively. For now, the backend still limits you to 4GB-1 files, but
    clients of the C library won't need recompiling again to support larger
    files than this once they use the new API.
  * Fixed a large number of warnings produced in compilation, assembly and
    linking, many of them new and resulting from the improved checks in the
    latest toolchain.
  * Increased the maximum stream buffer size from 16MB to 1GB.
  * Added Hdr:SDFS and Hdr:SDIO to the list of headers used to build swis.h
    if they are present.
Admin:
  Verified that the new 64-bit file pointer buffering code works using a
  ROM build (since the toolchain makes extensive use of reading, writing
  and seeking internally).

Version 5.64. Tagged as 'RISC_OSLib-5_64'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* hostsys.h: specify details of host system when compiling CLIB */
/* Copyright (C) A.C. Norman and A. Mycroft     */
/* version 0.01a, amalgamates norcrosys+sysdep: */
/* soon rationalise to armsys.h, s370sys.h etc  */
/* The tests of #ifdef ARM must go one day.     */

#ifndef __hostsys_h
#define __hostsys_h

#include <stdio.h>
#include <stdbool.h>

#undef MACHINE
#ifdef __arm
#  ifndef __ARM
#  define __ARM 1
#  endif
#endif

#ifdef __ARM
/* The following lines could be a #include "armsys.h" etc. */
#  ifndef PLUS_APRM
/* ordinary ARM */
#    define BYTESEX_EVEN 1
#  else
/* Apple ARM */
#    define BYTESEX_ODD 1
#  endif
#  define MACHINE "ARM"
#endif
#ifdef __ACW
#  define BYTESEX_EVEN 1
#  define MACHINE "ACW"
#endif
#ifdef __ibm370
#  define BYTESEX_ODD 1
#  define MACHINE "370"
#endif
#ifndef MACHINE
#  error -D__ibm370 assumed
#  define __ibm370 1
#  define BYTESEX_ODD 1
#  define MACHINE "370"
#endif

#define memclr(p,n) memset(p,0,n)

#ifdef __ibm370
#  define MAXSTORE 0x00ffffff       /* used only by alloc.c */
#else                               /* not right! */
#  define MAXSTORE 0x03ffffff       /* used only by alloc.c */
#  define HOST_LACKS_ALLOC 1
#endif

#ifdef __ARM                          /* fpe2 features stfp/ldfp ops */
#  define HOST_HAS_BCD_FLT 1
#  ifndef SOFTWARE_FLOATING_POINT
#    define HOST_HAS_TRIG 1         /* and ieee trig functions     */
#  endif
#endif

extern char *_strerror(int n, char *v);
 /* The same as strerror, except that if an error message must be constructed
 * this is done into the array v.
 */

extern int _interrupts_off;
extern void _raise_stacked_interrupts(void);
extern void _postmortem(char *msg, int mflag);
extern void _mapstore(void);
extern void _write_profile(char *filename);
extern void _sysdie(const char *s);
extern void _init_alloc(void), _initio(char *,char *,char *),
            _terminateio(void), _lib_shutdown(void), _signal_init(void),
            _exit_init(void);
extern void _armsys_lib_init(void);

extern int _signal_real_handler(int sig);

#ifndef __size_t
#define __size_t 1
typedef unsigned int size_t;  /* see <stddef.h> */
#endif
extern void *_sys_alloc(size_t n);
extern void _init_user_alloc(void);
extern void _terminate_user_alloc(void);
extern void _sys_msg(const char *);
extern bool _sys__assert(const char *fmt, const char *expr,
                         const char *func, const char *file, int line);
extern void _exit(int n);
extern void _terminate_getenv(void);

#ifdef __ARM
typedef int FILEHANDLE;
#define TTYFILENAME ":tt"
extern int _osgbpb(int op, int fh, void *base, int len, int extra);
extern int _ttywrite(const unsigned char *buf, unsigned int len, int flag);
extern int _ttyread(unsigned char *buff, int size, int flag);
extern double _ldfp(void *x);
extern void _stfp(double d, void *p);
#endif

#ifdef __ibm370
#  if ('A' == 193)
#    define atoe(x) (x)       /* ebcdic already.                */
#    define etoa(x) (x)
#  else
#    define atoe(x) _atoe[x]  /* else translate text files etc. */
#    define etoa(x) _etoa[x]
#  endif
extern char _etoa[], _atoe[];
extern void _abend(int);
extern void *_svc_getmain(int);
extern void _svc_freemain(void *, int);
struct _svcwto { short len, mcsflags;
                 char  msg[80];
                 short desccode, routcde; };
extern void _svc_wto(const struct _svcwto *);
struct _svctime { int csecs; int yday/* 0-365 */; int year; };
extern void _svc_time(struct _svctime *);
extern void  _svc_stimer(int);
extern unsigned  _svc_ttimer(void);             /* units of 1/38400 sec  */
/* the following lines use "struct NIOPBASE" instead of "NIOPBASE" to    */
/* to reduce syntactic confusion if "niopbase.h" not included            */
typedef struct NIOPBASE *FILEHANDLE;
extern int _io_call(int fn, struct NIOPBASE *p, int arg), _io_r0;
extern struct _svcwto _io_emsg;  /* beware only 64 bytes thereof */
#endif


#ifndef SOFTWARE_FLOATING_POINT
#  ifdef __ibm370
#     define IBMFLOAT 1
#  else
#     define IEEE 1
/* IEEE floating point format assumed.                                   */
#     ifdef __ARM
/* For the current ARM floating point system that Acorn use the first    */
/* word of a floating point value is the one containing the exponent.    */
#        undef OTHER_WORD_ORDER_FOR_FP_NUMBERS
/*#        define DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS 1*/
#     endif
#  endif
#endif

/* I/O stuff... */

extern FILEHANDLE _sys_open(const char *name, int openmode);

/* openmode is a bitmap, whose bits have the following significance ...  */
/* most correspond directly to the ANSI mode specification - the         */
/* exception is OPEN_T, an extension which requests timestamp update.    */
/* This is really a sop to implementation laziness: what is intended is  */
/* that the timestamp should be updated if the file is written to or     */
/* otherwise modified.  But that is known only when the file is closed   */
/* and RISC OS has no 'set timestamp given filehandle' operation and the */
/* name by which the file was opened may no longer be valid at the time  */
/* of its close.                                                         */
#define OPEN_R 0
#define OPEN_W 4
#define OPEN_A 8
#define OPEN_B 1
#define OPEN_PLUS 2
#define OPEN_T 16

extern int _sys_close(FILEHANDLE fh);
/* result is 0 or an error indication                                    */

extern int _sys_write(FILEHANDLE fh, const unsigned char *buf, unsigned len, int mode);
/* result is number of characters not written (ie non-0 denotes a        */
/* failure of some sort) or a negative error indicator.                  */

extern int _sys_read(FILEHANDLE fh, unsigned char *buf, unsigned len, int mode);
/* result is number of characters not read (ie len - result _were_ read),*/
/* or negative to indicate error or EOF.                                 */
/* _sys_iserror(result) distinguishes between the two possibilities.     */
/* (Redundantly, since on EOF it is required that (result & ~0x80000000) */
/* is the number of characters unread).                                  */

extern int _sys_istty(FILE *);
/* Return true if the argument file is connected to a terminal.          */
/* Used to:  provide default unbuffered behaviour (in the absence of a   */
/*           setbuf call).                                               */
/*           disallow seek                                               */

extern int _sys_seek(FILEHANDLE fh, _off64_t pos);
/* Position the file at offset pos from its beginning.                   */
/* Result is >= 0 if OK, negative for an error.                          */

extern int _sys_ensure(FILEHANDLE fh);
/* Flush any OS buffers associated with fh, ensuring that the file is    */
/* up to date on disc.  (Only required if HOSTOS_NEEDSENSURE; see above) */
/* Result is >= 0 if OK, negative for an error.                          */

extern _off64_t _sys_flen(FILEHANDLE fh);
/* Return the current length of the file fh (or a negative error         */
/* indicator).  Required to convert fseek(, SEEK_END) into (, SEEK_START)*/
/* as required by _sys_seek.                                             */

#ifdef __ARM

#define NONHANDLE (-1)

extern void _sys_tmpnam_(char *name, int sig);
/* Return the name for temporary file number  sig  in the buffer name.   */

extern char *_hostos_error_string(int no, char *buf);

#endif

#ifdef __ibm370

#define NONHANDLE ((FILEHANDLE)0)
#define _sys_istty_(fh) (((DCB *)(fh))->DCBDEVT==DCBDVTRM)
#define _sys_seek_(fh, pos) (_sysdie("Unimplemented fseek"), 0)
#define _sys_flen_(fh)      (_sysdie("Unimplemented filelen"), 0)

extern int _sys_write_(FILEHANDLE fh, unsigned char *buf, int len, int mode);
extern int _sys_read_(FILEHANDLE fh, unsigned char *buf, int len, int mode);
extern int _sys_close_(FILEHANDLE fh);
#define _sys_tmpnam_(name, sig) sprintf(name, "$.tmp.x%.8x", sig)

#endif

/* The following code is NOT PORTABLE but can stand as a prototype for   */
/* whatever makes sense on other machines.                               */

#ifdef IBMFLOAT
/* This version works with IBM 360 floating point.                       */
#define SignBit 0x80000000
#define ExpBits 0x7F000000
#define MHiBits 0x00FFFFFF

#ifdef BYTESEX_EVEN
typedef union {struct {int mhi:24, x:7, s:1; unsigned mlo; } i;
               struct {unsigned sxmhi, mlo; } w;
               double d; } fp_number;
#else
typedef union {struct {int s:1, x:7, mhi:24; unsigned mlo; } i;
               struct {unsigned sxmhi, mlo; } w;
               double d; } fp_number;
#endif

#else
#define SignBit 0x80000000
#define ExpBits 0x7FF00000
#define MHiBits 0x000FFFFF
#define ExpBits_S 0x7F800000
#define MBits_S   0x007FFFFF

#ifdef BYTESEX_EVEN
typedef union {struct {int m:23, x:8, s:1; } i;
               unsigned w;
               float s; } fp_number_single;
#else
typedef union {struct {int s:1, x:8, m:23; } i;
               unsigned w;
               float s; } fp_number_single;
#endif
#ifndef OTHER_WORD_ORDER_FOR_FP_NUMBERS
/* This version works with the ARM floating point emulator - it may have */
/* to be reworked when or if floating point hardware is installed        */

#  ifdef BYTESEX_EVEN
typedef union {struct {int mhi:20, x:11, s:1; unsigned mlo; } i;
               struct {unsigned sxmhi, mlo; } w;
               double d; } fp_number;
#  else
typedef union {struct {int s:1, x:11, mhi:20; unsigned mlo; } i;
               struct {unsigned sxmhi, mlo; } w;
               double d; } fp_number;
#  endif

#else   /* OTHER_WORD_ORDER_FOR_FP_NUMBERS */
#  ifdef BYTESEX_EVEN
typedef union {struct {unsigned mlo; int mhi:20, x:11, s:1; } i;
               struct {unsigned mlo, sxmhi; } w;
               double d; } fp_number;
#  else
typedef union {struct {unsigned mlo; int s:1, x:11, mhi:20; } i;
               struct {unsigned mlo, sxmhi; } w;
               double d; } fp_number;
#  endif
#endif  /* OTHER_WORD_ORDER_FOR_FP_NUMBERS */

#endif

/* the object of the following macro is to adjust the floating point     */
/* variables concerned so that the more significant one can be squared   */
/* with NO LOSS OF PRECISION. It is only used when there is no danger    */
/* of over- or under-flow.                                               */

/* This code is NOT PORTABLE but can be modified for use elsewhere       */
/* It should, however, serve for IEEE and IBM FP formats.                */

#define _fp_normalize(high, low)                                          \
    {   fp_number temp;        /* access to representation     */         \
        double temp1;                                                     \
        temp.d = high;         /* take original number         */         \
        temp.i.mlo = 0;        /* make low part of mantissa 0  */         \
        temp1 = high - temp.d; /* the bit that was thrown away */         \
        low += temp1;          /* add into low-order result    */         \
        high = temp.d;                                                    \
    }

#if 0
/* The next line is not very nice, but since I want to declare a      */
/* function of type (FILE *) is seems to be needed. If you do not     */
/* want <stdio.h> included, tough luck!                               */
/* Note also the use of __system_io to alter the amount of detail     */
/* revealed by <stdio.h>.                                             */
#include <stdio.h>
extern FILE *_fopen_string_file(const char *data, int length);
#endif


#if defined __ARM && defined SHARED_C_LIBRARY

#  define _call_client_0(f) \
     _kernel_call_client(0, 0, 0, (_kernel_ccproc *)(f))
#  define _call_client_1(f,a) \
     _kernel_call_client((int)(a), 0, 0, (_kernel_ccproc *)(f))
#  define _call_client_2(f,a,b) \
     _kernel_call_client((int)(a), (int)(b), 0, (_kernel_ccproc *)(f))
#  define _call_client_3(f,a,b,c) \
     _kernel_call_client((int)(a), (int)(b), (int)(c), (_kernel_ccproc *)(f))

#else

#  define _call_client_0(f)       (*(f))()
#  define _call_client_1(f,a)     (*(f))(a)
#  define _call_client_2(f,a,b)   (*(f))((a), (b))
#  define _call_client_3(f,a,b,c) (*(f))((a), (b), (c))

#endif

#ifdef DEFAULT_TEXT
extern char *_kernel_getmessage(char *msg, char *tag);
extern char *_kernel_getmessage2(char *msg, char *tag, char *dst, size_t len);
#define _kernel_getmessage_def(msg, tag) _kernel_getmessage(msg, tag)
#else
extern char *_kernel_getmessage(char *tag);
extern char *_kernel_getmessage2(char *tag, char *dst, size_t len);
extern char *_kernel_getmessage_def(char *msg, char *tag);
#define _kernel_getmessage(msg, tag) _kernel_getmessage(tag)
#define _kernel_getmessage2(msg, tag, dst, len) _kernel_getmessage2(tag, dst, len)
#endif
extern char *decimal_point;

extern int __counter( void );

#endif

/* end of hostsys.h */
@


4.7
log
@* __assert2() added to support for C99 assert(), which displays
  function name.
* _Exit() added.
* Lots of new <math.h> functions (acosh, asinh, atanh, exp2, expm1,
  ilogb, log1p, log2, logb, scalbn, scalbln, cbrt, erf, erfc,
  lgamma, tgamma, nexttoward, fmaf). Float and long double forms
  of every function added; long double forms are included as another
  library object in the stubs rather than the shared library, as they
  just branch to the double form.
* Subnormal/NaN/infinity cases in various <math.h> functions improved.
* Added <tgmath.h>.
* Headers brought into line with CC 5.54.
* RMEnsures added to C library initialisation to try to load minimum
  CallASWI, FPEmulator, CLib. No errors reported if load fails.
* A few pointless inter-file dependencies removed to reduce minimum
  size of included ANSILib.

Version 5.46. Tagged as 'RISC_OSLib-5_46'
@
text
@d201 1
a201 1
extern int _sys_seek(FILEHANDLE fh, long pos);
d210 1
a210 1
extern long _sys_flen(FILEHANDLE fh);
d321 1
d329 1
@


4.6
log
@Added the following C99 features:

  * snprintf(), vsnprintf(), vfscanf(), vscanf(), vsscanf()
  * hh, j, z and t printf length modifiers (indicating char, intmax_t, size_t
    and ptrdiff_t respectively)
  * Hexadecimal floating-point printing and scanning (%a/%A)
  * %F printf() specifier (upper-case form of %F)
  * Input/output of NaNs and Infinities
  * imaxdiv_t, imaxdiv(), strtoimax(), strtoumax() (simulated through macros)
  * <fenv.h>: feclearexcept(), fegetexceptflag(), feraiseexcept(),
              fesetexceptflag(), fetestexcept(), fegetround(), fesetround(),
              fegetenv(), feholdexcept(), fesetenv(), feupdateenv()
  * FLT_EVAL_METHOD, DECIMAL_DIG
  * hypot(), hypotf(), fabsf(), fdim(), fdimf(), fmax(), fmaxf(), fmin(),
    fminf()
  * INFINITY, NAN, fpclassify(), isfinite(), isinf(), isnan(), isnormal(),
    signbit(), copysign(), copysignf(), nan(), nanf(), nextafter(),
    nextafterf() isgreater(), isgreaterequal(), isless(), islessequal(),
    islessgreater(), isunordered()

This involves adding 36 new entries to the stubs. Current versions of the C
library will not fault client programs with such larger stubs, but will fill
in the extra entries with junk. Programs requiring the new functions will have
to RMEnsure this version of the Shared C Library.

This version of the C library has been fixed so that in future, any extra
unknown stubs entries will be filled in with a branch to zero, rather than
corrupted.

Requires cc 5.41 or later, both to build, and to make use of some of the extra
facilities.


Version 5.37. Tagged as 'RISC_OSLib-5_37'
@
text
@d103 2
a104 2
extern bool _sys__assert(const char *fmt,
                         const char *expr, const char *file, int line);
d156 1
a156 1
#        define DO_NOT_SUPPORT_UNNORMALIZED_NUMBERS 1
d353 1
d357 1
@


4.5
log
@Abort and error handling massively overhauled:
  Aborts now give standard error messages (Abort on Data Transfer at... etc)
  *ShowRegs now filled in after aborts
  assert(), abort(), "free failed" and standard signal handlers now use Wimp
    error boxes if in the desktop
  Postmortem button on error boxes to view the postmortem

Also, x$multiply, x$divide, __rt_sdiv, x$remainder, x$udivide, __rt_udiv and
x$uremainder optimised.

Version 5.35. Tagged as 'RISC_OSLib-5_35'
@
text
@d245 3
d251 1
d255 1
d260 15
d281 1
d285 1
d292 1
d296 1
@


4.4
log
@  fwrite performance improved significantly.
  Another getenv() bug fixed.
Detail:
  stdio.c contains a vastly improved implementation of fwrite.
  hostsys.h declares _terminate_getenv to remove build warnings.
  armsys.c contains fix to getenv() to stop Omni dying.
Admin:
  Tested on desktop machine for over a week without incident, including
    several heavy fwrite users (WebServe, C compiler)
  fwrite change is documented in Doc/fwrite
  getenv() bug is Bugzilla bug #28

Version 5.27. Tagged as 'RISC_OSLib-5_27'
@
text
@d26 1
d103 2
@


4.3
log
@* Trailing garbage no longer appears after some perror() calls.
* Correction to static base location in modulewrap - was affecting some
  DSL 4000 video software.

Version 5.15. Tagged as 'RISC_OSLib-5_15'
@
text
@d103 1
@


4.2
log
@Ursula branch merged.
StrongARMfudge flag removed.
StrongARM compatibility set according to AMBKernel flag in Hdr:RISCOS
strftime %U and %W specifiers fixed for week 0.

Version 4.89. Tagged as 'RISC_OSLib-4_89'
@
text
@d324 1
d327 1
d329 1
@


4.1
log
@Initial revision
@
text
@d25 2
d76 5
d108 1
a108 1
extern int _ttywrite(unsigned char *buf, unsigned int len, int flag);
d161 50
d213 1
a213 16
#define TTYHANDLE 0          /* maybe it is now time to switch these ... */
#define NONHANDLE (-1)       /* ... two values                           */
#define _sys_istty_(fh) \
   ((fh) == TTYHANDLE)
#define _sys_seek_(fh, pos) \
   ((fh) == TTYHANDLE ? 0 : _kernel_osargs(1, fh, pos))
#define _sys_flen_(fh) \
   _kernel_osargs(2, fh, 0)
#define _sys_write_(fh, buf, len, mode) \
   ((fh) == TTYHANDLE ? _ttywrite(buf,len,mode) : _osgbpb(2,fh,buf,len,0))
#define _sys_read_(fh, buf, len, mode)  \
   ((fh) == TTYHANDLE ? _ttyread(buf,len,mode) : _osgbpb(4,fh,buf,len,0))
#define _sys_ensure_(fh)        \
   ((fh) == TTYHANDLE ? 0 : _kernel_osargs(0xFF, fh, 0))
#define _sys_close_(fh) \
   ((fh) == TTYHANDLE ? 0 : _kernel_osfind(0, (char *)fh))
d216 3
@


4.1.4.1
log
@* RISC_OSLib msgs module now closes its Messages files on exit.
* strerror/perror now call _kernel_last_oserror and use result
  if errno is unknown.
* _sys_open calls error-returning form of OS_Find so
  _kernel_last_oserror can return something meaningful after
  fopen fails
* All file handling calls set errno to -1 if a _kernel_osfind/
  _kernel_osgbpb etc call returns an error
* These three changes mean that the code sequence

         if ((fp = fopen(file, "rb")) == NULL) {
            perror(progname);
            return 1;
         }

  will now say something useful rather than "No error (errno=0)"
  This could now be used by socklib to get perror to work
  with errors generated by the Internet module.
* ANSILib now outputs proper messages, not just tokens.
@
text
@a24 2
#include <stdio.h>

a73 5
extern char *_strerror(int n, char *v);
 /* The same as strerror, except that if an error message must be constructed
 * this is done into the array v.
 */

d101 1
a101 1
extern int _ttywrite(const unsigned char *buf, unsigned int len, int flag);
a153 50
/* openmode is a bitmap, whose bits have the following significance ...  */
/* most correspond directly to the ANSI mode specification - the         */
/* exception is OPEN_T, an extension which requests timestamp update.    */
/* This is really a sop to implementation laziness: what is intended is  */
/* that the timestamp should be updated if the file is written to or     */
/* otherwise modified.  But that is known only when the file is closed   */
/* and RISC OS has no 'set timestamp given filehandle' operation and the */
/* name by which the file was opened may no longer be valid at the time  */
/* of its close.                                                         */
#define OPEN_R 0
#define OPEN_W 4
#define OPEN_A 8
#define OPEN_B 1
#define OPEN_PLUS 2
#define OPEN_T 16

extern int _sys_close(FILEHANDLE fh);
/* result is 0 or an error indication                                    */

extern int _sys_write(FILEHANDLE fh, const unsigned char *buf, unsigned len, int mode);
/* result is number of characters not written (ie non-0 denotes a        */
/* failure of some sort) or a negative error indicator.                  */

extern int _sys_read(FILEHANDLE fh, unsigned char *buf, unsigned len, int mode);
/* result is number of characters not read (ie len - result _were_ read),*/
/* or negative to indicate error or EOF.                                 */
/* _sys_iserror(result) distinguishes between the two possibilities.     */
/* (Redundantly, since on EOF it is required that (result & ~0x80000000) */
/* is the number of characters unread).                                  */

extern int _sys_istty(FILE *);
/* Return true if the argument file is connected to a terminal.          */
/* Used to:  provide default unbuffered behaviour (in the absence of a   */
/*           setbuf call).                                               */
/*           disallow seek                                               */

extern int _sys_seek(FILEHANDLE fh, long pos);
/* Position the file at offset pos from its beginning.                   */
/* Result is >= 0 if OK, negative for an error.                          */

extern int _sys_ensure(FILEHANDLE fh);
/* Flush any OS buffers associated with fh, ensuring that the file is    */
/* up to date on disc.  (Only required if HOSTOS_NEEDSENSURE; see above) */
/* Result is >= 0 if OK, negative for an error.                          */

extern long _sys_flen(FILEHANDLE fh);
/* Return the current length of the file fh (or a negative error         */
/* indicator).  Required to convert fseek(, SEEK_END) into (, SEEK_START)*/
/* as required by _sys_seek.                                             */

d156 16
a171 1
#define NONHANDLE (-1)
a173 3
/* Return the name for temporary file number  sig  in the buffer name.   */

extern char *_hostos_error_string(int no, char *buf);
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

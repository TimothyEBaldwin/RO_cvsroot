head	4.7;
access;
symbols
	RISC_OSLib-5_97:4.7
	RISC_OSLib-5_96:4.7
	RISC_OSLib-5_95:4.7
	RISC_OSLib-5_94:4.7
	RISC_OSLib-5_93:4.7
	RISC_OSLib-5_92:4.7
	RISC_OSLib-5_91:4.7
	RISC_OSLib-5_90:4.7
	RISC_OSLib-5_89:4.7
	RISC_OSLib-5_88:4.7
	RISC_OSLib-5_87:4.7
	RISC_OSLib-5_86-1:4.7
	RISC_OSLib-5_86:4.7
	RISC_OSLib-5_85:4.7
	RISC_OSLib-5_84:4.7
	RISC_OSLib-5_83-2:4.7
	RISC_OSLib-5_83-1:4.7
	RISC_OSLib-5_83:4.7
	RISC_OSLib-5_82:4.7
	RISC_OSLib-5_81:4.7
	RISC_OSLib-5_75-2:4.7
	RISC_OSLib-5_80:4.7
	RISC_OSLib-5_79:4.7
	RISC_OSLib-5_78:4.7
	RISC_OSLib-5_75-1:4.7
	RISC_OSLib-5_77:4.7
	RISC_OSLib-5_76:4.7
	RISC_OSLib-5_75:4.7
	RISC_OSLib-5_74:4.7
	RISC_OSLib-5_73:4.7
	RISC_OSLib-5_72:4.7
	RISC_OSLib-5_71:4.7
	RISC_OSLib-5_70:4.7
	RISC_OSLib-5_69:4.7
	RISC_OSLib-5_68:4.7
	RISC_OSLib-5_67:4.7
	RISC_OSLib-5_66:4.7
	RISC_OSLib-5_65:4.7
	RISC_OSLib-5_64:4.7
	RISC_OSLib-5_63:4.7
	RISC_OSLib-5_62:4.7
	RISC_OSLib-5_61:4.7
	RISC_OSLib-5_60:4.7
	RISC_OSLib-5_59:4.7
	RISC_OSLib-5_58:4.7
	RISC_OSLib-5_57:4.7
	RISC_OSLib-5_56:4.7
	RISC_OSLib-5_55:4.7
	RISC_OSLib-5_54:4.7
	RISC_OSLib-5_53:4.6
	RISC_OSLib-5_52:4.6
	RISC_OSLib-5_51:4.6
	RO_5_07:4.6
	RISC_OSLib-5_50:4.6
	RISC_OSLib-5_49:4.6
	RISC_OSLib-5_46-4_64_2_1:4.6
	NoInlineAsm:4.6.0.4
	RISC_OSLib-5_48:4.6
	RISC_OSLib-5_47:4.6
	RISC_OSLib-5_46:4.6
	RISC_OSLib-5_45:4.6
	RISC_OSLib-5_44:4.6
	RISC_OSLib-5_43:4.6
	RISC_OSLib-5_42:4.6
	RISC_OSLib-5_41:4.6
	RISC_OSLib-5_40:4.6
	RISC_OSLib-5_39:4.6
	RISC_OSLib-5_38:4.6
	RISC_OSLib-5_37:4.6
	RISC_OSLib-5_36:4.6
	RISC_OSLib-5_35:4.6
	RISC_OSLib-5_34:4.6
	RISC_OSLib-5_33-4_50_2_1:4.6
	sbrodie_dev:4.6.0.2
	sbrodie_dev_bp:4.6
	RISC_OSLib-5_33:4.6
	RISC_OSLib-5_32:4.6
	RISC_OSLib-5_31:4.6
	RISC_OSLib-5_30:4.6
	RISC_OSLib-5_29:4.6
	RISC_OSLib-5_28:4.6
	RISC_OSLib-5_27:4.6
	RISC_OSLib-5_26:4.6
	RISC_OSLib-5_25:4.6
	RISC_OSLib-5_24:4.6
	RISC_OSLib-5_01-4_16_2_5:4.4
	RISC_OSLib-5_23:4.6
	RISC_OSLib-5_22:4.6
	RISC_OSLib-5_21:4.6
	RISC_OSLib-5_20:4.6
	RISC_OSLib-5_19:4.6
	RISC_OSLib-5_18:4.5
	RISC_OSLib-5_17:4.5
	RISC_OSLib-5_16:4.5
	RISC_OSLib-5_15:4.5
	dellis_autobuild_BaseSW:4.5
	RISC_OSLib-5_14:4.5
	RISC_OSLib-5_13:4.5
	RISC_OSLib-5_12:4.5
	RISC_OSLib-5_01-4_16_2_4:4.4
	RISC_OSLib-5_11:4.5
	RISC_OSLib-5_01-4_16_2_3:4.4
	RISC_OSLib-5_01-4_16_2_2:4.4
	RISC_OSLib-5_10:4.5
	RISC_OSLib-5_01-4_16_2_1:4.4
	Bethany:4.4.0.4
	RISC_OSLib-5_09:4.5
	RISC_OSLib-5_08:4.5
	RISC_OSLib-5_07:4.5
	RISC_OSLib-5_06:4.5
	RISC_OSLib-4_97-4_12_2_8:4.4.2.2
	RISC_OSLib-5_05:4.4
	RISC_OSLib-5_04:4.4
	sbrodie_sedwards_16Mar2000:4.4
	RISC_OSLib-5_03:4.4
	RISC_OSLib-5_02:4.4
	RISC_OSLib-4_97-4_12_2_7:4.4.2.2
	RISC_OSLib-5_01:4.4
	RISC_OSLib-5_00:4.4
	RISC_OSLib-4_99:4.4
	RISC_OSLib-4_98:4.4
	RISC_OSLib-4_97-4_12_2_6:4.4.2.2
	RISC_OSLib-4_97-4_12_2_5:4.4.2.2
	RISC_OSLib-4_97-4_12_2_4:4.4.2.1
	RISC_OSLib-4_97-4_12_2_3:4.4.2.1
	RISC_OSLib-4_97-4_12_2_2:4.4
	sbrodie_RISC_OSLib-4_97-4_12_2_1:4.4
	kbracey_32bit:4.4.0.2
	kbracey_32bit_bp:4.4
	dcotton_autobuild_BaseSW:4.6
	RISC_OSLib-4_97:4.4
	RISC_OSLib-4_96:4.4
	RISC_OSLib-4_95:4.4
	RISC_OSLib-4_94:4.3
	RISC_OSLib-4_93:4.3
	RISC_OSLib-4_92:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.8
	sforrest_daytona_appflash-0_31:4.2
	RISC_OSLib-4_91:4.3
	RISC_OSLib-4_90:4.3
	RISC_OSLib-4_89:4.3
	Ursula_merge:4.2
	RISC_OSLib-4_88:4.2
	RISC_OSLib-4_87:4.2
	blaughto_daytona_appflash-0_30:4.2
	rmanby_clib-4_86:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	afrost_NC2_Generic:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.6
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2009.05.31.17.58.57;	author pnaulls;	state Exp;
branches;
next	4.6;

4.6
date	2000.10.16.16.30.40;	author sbrodie;	state Exp;
branches;
next	4.5;

4.5
date	2000.05.09.14.09.39;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	99.07.09.12.27.16;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	98.10.01.09.14.31;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.21.17.13.02;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.25.04;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.4.2.1
date	99.11.10.14.02.30;	author kbracey;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	99.11.22.13.27.52;	author sbrodie;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.25.04;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.19.53.15;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.11.29.32;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.19.48.56;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Normalise C and assembler include paths
Detail:
 This changes all the C and assembler includes to be a canoncial Unix format.
 Also match include paths to previous commit for EditIntern/DrawIntern/VerIntern
 Finally, also include some minor type fixes (NULL vs 0)
Admin:
 May be some other paths elsewhere in the source I'm not immediately able to fix.  Will address any issues ASAP, since this is a huge change.

Version 5.54. Not tagged
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GBLL    Brazil_Compatible
        GBLS    Calling_Standard
        GBLL    ModeMayBeNonUser
        GBLL    DDE

Brazil_Compatible  SETL  {FALSE}
Calling_Standard   SETS  "APCS_U"
ModeMayBeNonUser   SETL  {TRUE}
DDE                SETL  {TRUE}

        GET     h_regs.s
        GET     h_brazil.s

        MACRO
$name   StoreSWIXFlags
  [ {CONFIG}=26
$name   STR     pc, [sp, #4*4]!
  |
$name   MRS     lr, CPSR
        STR     lr, [sp, #4*4]!
  ]
        MEND

        AREA    |C$$code|, CODE, READONLY

        EXPORT  |_swix|
        EXPORT  |_swi|

  [ StrongARM
    ; tedious static _swi(x) entry handling, to avoid generating dynamic code, and
    ; requiring an expensive XOS_SynchroniseCodeAreas

|_swix|
        ORR     r0, r0, #&20000
        TST     r1, #&FF0                 ; check for use of input regs. 4 to 9, or of block param
        BNE     swix_even_more_tedious    ; if so, do full stuff

        STMFD   sp!, {r2, r3}             ; put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}      ; save stuff

        SUB     sp, sp, #5*4              ; so we can use tail code common with dynamic version (and room for regs stash)

        ADD     r14, sp, #(5+8)*4         ; r14 -> input args
        MOV     r12, r0                   ; target SWI code
        STR     fp, [sp]                  ; stash fp

        MOV     r11, r1
        TST     r11, #&001
        LDRNE   r0, [r14], #4
        TST     r11, #&002
        LDRNE   r1, [r14], #4
        TST     r11, #&004
        LDRNE   r2, [r14], #4
        TST     r11, #&008
        LDRNE   r3, [r14], #4

        STR     r14, [sp, #4]             ; stash args ptr
        LDR     fp, [sp, #0]              ; get fp and lr saying something useful in case
        LDR     lr, [sp, #48]             ; SWI aborts or throws an error.
        SWI     XOS_CallASWIR12
        LDR     ip, [sp, #4]              ; restore (ip -> args)
        B       SWIXReturn

swix_even_more_tedious
|_swi|
        STMFD   sp!, {r2, r3}             ; put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}      ; save stuff

        SUB     sp, sp, #5*4              ; so we can use tail code common with dynamic version (and room for regs stash)

        ADD     r14, sp, #(5+8)*4         ; r14 -> input args
        MOV     r12, r0                   ; target SWI code
        STR     fp, [sp]                  ; stash fp


        MOV     r11, r1
        TST     r11, #&001
        LDRNE   r0, [r14], #4
        TST     r11, #&002
        LDRNE   r1, [r14], #4
        TST     r11, #&004
        LDRNE   r2, [r14], #4
        TST     r11, #&008
        LDRNE   r3, [r14], #4
        TST     r11, #&010
        LDRNE   r4, [r14], #4
        TST     r11, #&020
        LDRNE   r5, [r14], #4
        TST     r11, #&040
        LDRNE   r6, [r14], #4
        TST     r11, #&080
        LDRNE   r7, [r14], #4
        TST     r11, #&100
        LDRNE   r8, [r14], #4
        TST     r11, #&200
        LDRNE   r9, [r14], #4

        STR     r14, [sp, #4]             ; stash args ptr
        TST     r11, #&800                ; use of block parameter input?
        BLNE    swi_blockhead             ; if so, handle it and... (BL<cond> 32-bit OK)
        TST     r11, #&800                ; use of block parameter input? (r11 preserved by the call, flags not)
        LDRNE   r14, [sp, #4]             ; ...restore arg ptr

        TST     r12, #&20000              ; if non X SWI, could be a return value register
        BEQ     swi_beyond_a_joke

        LDR     fp, [sp, #0]              ; get fp and lr saying something useful in case
        LDR     lr, [sp, #48]             ; SWI aborts or throws an error.
        SWI     XOS_CallASWIR12
        LDR     ip, [sp, #4]              ; restore (ip -> args)
        B       SWIXReturn

swi_beyond_a_joke
;so we have to deal with a return value then
        LDR     fp, [sp, #0]              ; get fp and lr saying something useful in case
        LDR     lr, [sp, #48]             ; SWI aborts or throws an error.
        SWI     XOS_CallASWIR12
        LDR     ip, [sp, #4]              ; restore (ip -> args)
        StoreSWIXFlags
        LDR     lr, [sp, #1*4]
;right, if R0 is also required as an output param, we'd better sort that first
        TST     lr,#&80000000
        BEQ     swi_beyond_a_joke_R0safe
        LDRNE   lr, [r12], #4
        STRNE   r0, [lr]
        LDR     lr, [sp, #1*4]
        BIC     lr,lr,#&80000000       ;done it now
        STR     lr, [sp, #1*4]
swi_beyond_a_joke_R0safe
        ANDS    lr, lr, #&000F0000     ;select return value register
        BEQ     SWIReturn2
        CMP     lr, #&00010000
        MOVEQ   r0, r1
        CMP     lr, #&00020000
        MOVEQ   r0, r2
        CMP     lr, #&00030000
        MOVEQ   r0, r3
        CMP     lr, #&00040000
        MOVEQ   r0, r4
        CMP     lr, #&00050000
        MOVEQ   r0, r5
        CMP     lr, #&00060000
        MOVEQ   r0, r6
        CMP     lr, #&00070000
        MOVEQ   r0, r7
        CMP     lr, #&00080000
        MOVEQ   r0, r8
        CMP     lr, #&00090000
        MOVEQ   r0, r9
        CMP     lr, #&000F0000         ;for goodness sake!
        LDREQ   r0, [sp]
        B       SWIReturn2

swi_blockhead
        STMFD   sp!, {r10-r12, lr}
        LDR     r12, [sp, #(4+1)*4]    ;pick up args ptr from stack
;r12 currently -> first output arg, so crank it past them
        MOVS    r11, r11, ASL #1
        ADDCS   r12, r12, #4           ;tests R0 output bit
        ADDMI   r12, r12, #4           ;tests R1 output bit
        MOV     r10, #5                ;5 more reg bit pairs to go (includes PC and one dummy)
swi_blockhead1
        MOVS    r11, r11, ASL #2
        ADDCS   r12, r12, #4
        ADDMI   r12, r12, #4
        SUBS    r10, r10, #1
        BNE     swi_blockhead1
;now r12 -> parameter block args on stack
        LDR     r11, [sp,#4]
        ANDS    r11, r11, #&f000       ;select reg for parameter block pointer
        MOVEQ   r0, r12
        CMP     r11, #&1000
        MOVEQ   r1, r12
        CMP     r11, #&2000
        MOVEQ   r2, r12
        CMP     r11, #&3000
        MOVEQ   r3, r12
        CMP     r11, #&4000
        MOVEQ   r4, r12
        CMP     r11, #&5000
        MOVEQ   r5, r12
        CMP     r11, #&6000
        MOVEQ   r6, r12
        CMP     r11, #&7000
        MOVEQ   r7, r12
        CMP     r11, #&8000
        MOVEQ   r8, r12
        CMP     r11, #&9000
        MOVEQ   r9, r12

        LDMFD   sp!, {r10-r12, pc} ; no need to restore flags

  ] ; StrongARM


  [ :LNOT: StrongARM

|_swi|

; Construct a stack frame that looks something like this:
;       LDMIA   r12!, {r0..rn}      ; Or NOP if no input regs
;       ADD     Rb, R12, #Nout * 4  ; Or NOP if no parameter block
;       SWI     xxxxxx
;       MOV     R0, Rn              ; Use ADD because Rn is correct bitfield
;       B       SWIReturn
;       saved r4-r11,lr
;       saved r1
;       saved input values (r2...rn)

        STMFD   sp!, {r2-r3}            ; Save r1 and put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}
        ADR     r6, SWIReturn-4
        B       swix0
|_swix|
        ORR     r0, r0, #&20000
        STMDB   sp!, {r2-r3}
        STMDB   sp!, {r1, r4-r9, lr}
        ADR     r6, SWIXReturn-4
swix0
        ORR     r3, r0, #&ef000000      ; Construct SWI instruction
        MOV     r0, r1, LSL #22         ; Construct LDMIA R12!, {regs} instruction
        MOVS    r0, r0, LSR #22         ; {regs} = {} (IE no input regs) we must not
        ORRNE   r0, r0, #&e8000000      ; use an LDMIA R12!, {} instruction as this is an
        ORRNE   r0, r0, #&00bc0000      ; invalid instruction, we use a suitable NOP instead.
        MOV     r5, r1, LSR #16
        AND     r5, r5, #&f
        ORR     r5, r5, #&e1000000
        ORR     r5, r5, #&a00000
        ANDS    r2, r1, #&800
        BLNE    BuildBlockInst          ; BL<cond> 32-bit OK
        SUB     r6, r6, sp
        MOV     r6, r6, LSR #2
        BIC     r6, r6, #&ff000000
        ADD     r6, r6, #&ea000000
        STMDB   sp!, {r0,r2,r3,r5,r6}
        ADD     r12, sp, #(5+8)*4       ; Point R12 at input regs on stack.
        MOV     pc, sp                  ; Call routine on stack

SWIReturn
        StoreSWIXFlags
  ] ; not StrongARM
SWIReturn2
        LDR     lr, [sp, #1*4]
        MOVS    lr, lr, ASL #1          ; Shift out setting C if R0 to be written, N
        LDRCS   lr, [r12], #4           ; if R1 to be written.
        STRCS   r0, [lr]
        LDRMI   lr, [r12], #4
        STRMI   r1, [lr]
        LDR     lr, [sp, #1*4]
        B       ReturnTail
SWIXReturn
        StoreSWIXFlags                  ; increments sp by 16
        LDR     lr, [sp, #1*4]
        BVS     VSetReturn
        MOVS    lr, lr, ASL #1          ; Shift out setting C if R0 to be written, N
        LDRCS   lr, [r12], #4           ; if R1 to be written.
        STRCS   r0, [lr]
        LDRMI   lr, [r12], #4
        STRMI   r1, [lr]
        LDR     lr, [sp, #1*4]
        TST     lr, #&f0000
        MOVEQ   r0, #0
ReturnTail
        MOVS    lr, lr, ASL #3          ; Shift 2 bits each time for the next 2 regs
        LDRCS   r1, [r12], #4
        STRCS   r2, [r1]
        LDRMI   r1, [r12], #4
        STRMI   r3, [r1]
        AND     lr, lr, #&ff000000
        MOVS    lr, lr, ASL #2
        LDRCS   r1, [r12], #4
        STRCS   r4, [r1]
        BEQ     VSetReturn              ; Typically saves 16S - (3S + 1N)
        LDRMI   r1, [r12], #4
        STRMI   r5, [r1]
        MOVS    lr, lr, ASL #2
        LDRCS   r1, [r12], #4
        STRCS   r6, [r1]
        LDRMI   r1, [r12], #4
        STRMI   r7, [r1]
        MOVS    lr, lr, ASL #2
        LDRCS   r1, [r12], #4
        STRCS   r8, [r1]
        LDRMI   r1, [r12], #4
        STRMI   r9, [r1]
        MOVS    lr, lr, ASL #2
        LDRCS   r9, [sp]
        LDRCS   r1, [r12], #4
        STRCS   r9, [r1]
VSetReturn
        ADD     sp, sp, #2*4
        LDMIA   sp!, {r4-r9,lr}
        ADD     sp, sp, #2 * 4
        Return  ,LinkNotStacked

  [ :LNOT: StrongARM
BuildBlockInst
        MOV     r4, #6
        AND     r2, r1, #&f000
        ORR     r2, r2, #&e2000000
        ORR     r2, r2, #&008c0000
BuildBlockInst1
        MOVS    r1, r1, ASL #2
        ADDCS   r2, r2, #4
        ADDMI   r2, r2, #4
        SUBS    r4, r4, #1
        BNE     BuildBlockInst1
        Return  ,LinkNotStacked
  ]

        END
@


4.6
log
@  Fixed bug in _swi/_swix code.
Detail:
  This code would only work in 26-bit modes, since it stored the output
    flags using STR pc, [sp, #4*4]!.  When {CONFIG} is 32, it stores the
    CPSR instead.
Admin:
  Tested in 32-bit Lazarus build - this fixes the RCMMDriver stiffing
    (because it sits with interrupts off waiting for the C flag to be
    set on exit from an OS_Byte call it calls through _swix)

Version 5.19. Tagged as 'RISC_OSLib-5_19'
@
text
@d25 2
a26 2
        GET     s.h_Regs
        GET     s.h_Brazil
@


4.5
log
@32-bit work merged from kbracey_32bit branch.

Version 5.06. Tagged as 'RISC_OSLib-5_06'
@
text
@d28 10
d133 1
a133 1
        STR     pc, [sp, #4*4]!
d254 1
a254 1
        STR     pc, [sp, #4*4]!
d266 1
a266 1
        STR     pc, [sp, #4*4]!
@


4.4
log
@Incorporated _swi/_swix bug fix that was released in the RISC OS 3.70/3.71
ROM patches.
fp and lr are now set correctly before calling a SWI. This allows much better
recovery if the SWI aborts or generates an error.

Version 4.95. Tagged as 'RISC_OSLib-4_95'
@
text
@d15 9
a23 16
r0              RN      0
r1              RN      1
r2              RN      2
r3              RN      3
r4              RN      4
r5              RN      5
r6              RN      6
r7              RN      7
r8              RN      8
r9              RN      9
r10             RN      10
r11             RN      11
r12             RN      12
sp              RN      13
lr              RN      14
pc              RN      15
d25 2
d28 1
a28 3
                GET     s.h_StrongA

                AREA    |C$$code|, CODE, READONLY
d104 2
a105 1
        BLNE    swi_blockhead             ; if so, handle it and...
d195 1
a195 1
        LDMFD   sp!, {r10-r12, pc}^ ;must restore flags
d234 1
a234 1
        BLNE    BuildBlockInst
d298 1
a298 1
        MOVS    pc, lr
d312 1
a312 1
        MOVS    pc, lr
@


4.4.2.1
log
@_kernel_unwind now understands SFMFD instructions in function entry.
It also copes with STFE now - it was totally broken.
32-bit stubs and corresponding LibInit SWIs created.
All rather untested.

Version 4.97, 4.12.2.3. Tagged as 'RISC_OSLib-4_97-4_12_2_3'
@
text
@d15 16
a30 4
        GBLL    Brazil_Compatible
        GBLS    Calling_Standard
        GBLL    ModeMayBeNonUser
        GBLL    DDE
a31 4
Brazil_Compatible  SETL  {FALSE}
Calling_Standard   SETS  "APCS_U"
ModeMayBeNonUser   SETL  {TRUE}
DDE                SETL  {TRUE}
d33 1
a33 2
        GET     s.h_Regs
        GET     s.h_Brazil
d35 1
a35 1
        AREA    |C$$code|, CODE, READONLY
@


4.4.2.2
log
@  Work in progress.  Do not use.
Detail:
  Many changes to use the APCS macros for function entry and exit so
    that the code can build for 32-bit environments.  Changes are NOT
    yet complete.
  Makefile rebuilds swis.h header file but only exports it if it has
    changed to avoid unnecessary rebuilding of nearly all C sources
    in a build.
Admin:
  Work in progress.  Do not use.

Version 4.97, 4.12.2.5. Tagged as 'RISC_OSLib-4_97-4_12_2_5'
@
text
@d104 1
a104 2
        BLNE    swi_blockhead             ; if so, handle it and... (BL<cond> 32-bit OK)
        TST     r11, #&800                ; use of block parameter input? (r11 preserved by the call, flags not)
d194 1
a194 1
        LDMFD   sp!, {r10-r12, pc} ; no need to restore flags
d233 1
a233 1
        BLNE    BuildBlockInst          ; BL<cond> 32-bit OK
d297 1
a297 1
        Return  ,LinkNotStacked
d311 1
a311 1
        Return  ,LinkNotStacked
@


4.3
log
@Ursula branch merged.
StrongARMfudge flag removed.
StrongARM compatibility set according to AMBKernel flag in Hdr:RISCOS
strftime %U and %W specifiers fixed for week 0.

Version 4.89. Tagged as 'RISC_OSLib-4_89'
@
text
@d69 2
d72 1
a72 1
        LDMIA   sp, {fp, ip}              ; restore (ip -> args)
d117 2
d120 1
a120 1
        LDMIA   sp, {fp, ip}              ; restore (ip -> args)
d125 2
d128 1
a128 1
        LDMIA   sp, {fp, ip}           ;restore (ip -> args)
@


4.2
log
@Version RO_3_70 taken
@
text
@d128 1
a128 1
        LDRNE   lr, [r12], #4           
a240 4
  [ StrongARMfudge
    ; so that dynamic version would at least work
    SyncStackCode 5
  ]
@


4.1
log
@Initial revision
@
text
@d33 2
d39 163
d241 4
d246 1
d249 2
d304 1
d317 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a32 2
                GET     s.h_StrongA

a36 163

  [ StrongARM
    ; tedious static _swi(x) entry handling, to avoid generating dynamic code, and
    ; requiring an expensive XOS_SynchroniseCodeAreas

|_swix|
        ORR     r0, r0, #&20000
        TST     r1, #&FF0                 ; check for use of input regs. 4 to 9, or of block param
        BNE     swix_even_more_tedious    ; if so, do full stuff

        STMFD   sp!, {r2, r3}             ; put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}      ; save stuff

        SUB     sp, sp, #5*4              ; so we can use tail code common with dynamic version (and room for regs stash)

        ADD     r14, sp, #(5+8)*4         ; r14 -> input args
        MOV     r12, r0                   ; target SWI code
        STR     fp, [sp]                  ; stash fp

        MOV     r11, r1
        TST     r11, #&001
        LDRNE   r0, [r14], #4
        TST     r11, #&002
        LDRNE   r1, [r14], #4
        TST     r11, #&004
        LDRNE   r2, [r14], #4
        TST     r11, #&008
        LDRNE   r3, [r14], #4

        STR     r14, [sp, #4]             ; stash args ptr
        SWI     XOS_CallASWIR12
        LDMIA   sp, {fp, ip}              ; restore (ip -> args)
        B       SWIXReturn

swix_even_more_tedious
|_swi|
        STMFD   sp!, {r2, r3}             ; put 1st two variadic args on stack
        STMDB   sp!, {r1, r4-r9, lr}      ; save stuff

        SUB     sp, sp, #5*4              ; so we can use tail code common with dynamic version (and room for regs stash)

        ADD     r14, sp, #(5+8)*4         ; r14 -> input args
        MOV     r12, r0                   ; target SWI code
        STR     fp, [sp]                  ; stash fp


        MOV     r11, r1
        TST     r11, #&001
        LDRNE   r0, [r14], #4
        TST     r11, #&002
        LDRNE   r1, [r14], #4
        TST     r11, #&004
        LDRNE   r2, [r14], #4
        TST     r11, #&008
        LDRNE   r3, [r14], #4
        TST     r11, #&010
        LDRNE   r4, [r14], #4
        TST     r11, #&020
        LDRNE   r5, [r14], #4
        TST     r11, #&040
        LDRNE   r6, [r14], #4
        TST     r11, #&080
        LDRNE   r7, [r14], #4
        TST     r11, #&100
        LDRNE   r8, [r14], #4
        TST     r11, #&200
        LDRNE   r9, [r14], #4

        STR     r14, [sp, #4]             ; stash args ptr
        TST     r11, #&800                ; use of block parameter input?
        BLNE    swi_blockhead             ; if so, handle it and...
        LDRNE   r14, [sp, #4]             ; ...restore arg ptr

        TST     r12, #&20000              ; if non X SWI, could be a return value register
        BEQ     swi_beyond_a_joke

        SWI     XOS_CallASWIR12
        LDMIA   sp, {fp, ip}              ; restore (ip -> args)
        B       SWIXReturn

swi_beyond_a_joke
;so we have to deal with a return value then
        SWI     XOS_CallASWIR12
        LDMIA   sp, {fp, ip}           ;restore (ip -> args)
        STR     pc, [sp, #4*4]!
        LDR     lr, [sp, #1*4]
;right, if R0 is also required as an output param, we'd better sort that first
        TST     lr,#&80000000
        BEQ     swi_beyond_a_joke_R0safe
        LDRNE   lr, [r12], #4           
        STRNE   r0, [lr]
        LDR     lr, [sp, #1*4]
        BIC     lr,lr,#&80000000       ;done it now
        STR     lr, [sp, #1*4]
swi_beyond_a_joke_R0safe
        ANDS    lr, lr, #&000F0000     ;select return value register
        BEQ     SWIReturn2
        CMP     lr, #&00010000
        MOVEQ   r0, r1
        CMP     lr, #&00020000
        MOVEQ   r0, r2
        CMP     lr, #&00030000
        MOVEQ   r0, r3
        CMP     lr, #&00040000
        MOVEQ   r0, r4
        CMP     lr, #&00050000
        MOVEQ   r0, r5
        CMP     lr, #&00060000
        MOVEQ   r0, r6
        CMP     lr, #&00070000
        MOVEQ   r0, r7
        CMP     lr, #&00080000
        MOVEQ   r0, r8
        CMP     lr, #&00090000
        MOVEQ   r0, r9
        CMP     lr, #&000F0000         ;for goodness sake!
        LDREQ   r0, [sp]
        B       SWIReturn2

swi_blockhead
        STMFD   sp!, {r10-r12, lr}
        LDR     r12, [sp, #(4+1)*4]    ;pick up args ptr from stack
;r12 currently -> first output arg, so crank it past them
        MOVS    r11, r11, ASL #1
        ADDCS   r12, r12, #4           ;tests R0 output bit
        ADDMI   r12, r12, #4           ;tests R1 output bit
        MOV     r10, #5                ;5 more reg bit pairs to go (includes PC and one dummy)
swi_blockhead1
        MOVS    r11, r11, ASL #2
        ADDCS   r12, r12, #4
        ADDMI   r12, r12, #4
        SUBS    r10, r10, #1
        BNE     swi_blockhead1
;now r12 -> parameter block args on stack
        LDR     r11, [sp,#4]
        ANDS    r11, r11, #&f000       ;select reg for parameter block pointer
        MOVEQ   r0, r12
        CMP     r11, #&1000
        MOVEQ   r1, r12
        CMP     r11, #&2000
        MOVEQ   r2, r12
        CMP     r11, #&3000
        MOVEQ   r3, r12
        CMP     r11, #&4000
        MOVEQ   r4, r12
        CMP     r11, #&5000
        MOVEQ   r5, r12
        CMP     r11, #&6000
        MOVEQ   r6, r12
        CMP     r11, #&7000
        MOVEQ   r7, r12
        CMP     r11, #&8000
        MOVEQ   r8, r12
        CMP     r11, #&9000
        MOVEQ   r9, r12

        LDMFD   sp!, {r10-r12, pc}^ ;must restore flags

  ] ; StrongARM


  [ :LNOT: StrongARM

a75 4
  [ StrongARMfudge
    ; so that dynamic version would at least work
    SyncStackCode 5
  ]
a76 1

a78 2
  ] ; not StrongARM
SWIReturn2
a131 1
  [ :LNOT: StrongARM
a143 1
  ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

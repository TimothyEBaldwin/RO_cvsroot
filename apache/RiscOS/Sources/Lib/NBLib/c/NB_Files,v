head	1.9;
access;
symbols
	NBLib-0_28:1.9
	dellis_autobuild_BaseSW:1.9
	dcotton_autobuild_BaseSW:1.9
	nbingham_NBLib-0_27:1.9
	NBLib-0_27:1.9
	NBLib-0_26:1.9
	NBLib-0_25:1.8
	NBLib-0_24:1.7
	NBLib-0_23:1.7
	NBLib-0_22:1.7
	NBLib-0_21:1.7
	NBLib-0_20:1.7
	NBLib-0_19:1.7
	NBLib-0_18:1.7
	NBLib-0_17:1.6
	NBLib-0_16:1.6
	NBLib-0_15:1.6
	NBLib-0_14:1.6
	NBLib-0_13:1.6
	NBLib-0_12:1.5
	NBLib-0_11:1.4
	NBLib-0_10:1.3
	NBLib-0_09:1.3
	NBLib-0_08:1.3
	NBLib-0_07:1.3
	NBLib-0_06:1.3
	NBLib-0_05:1.3
	NBLib-0_04:1.3
	NBLib-0_03:1.2
	NBLib-0_02:1.1.1.1
	initial:1.1.1.1
	TRUNK:1.1.1;
locks; strict;
comment	@# @;


1.9
date	99.03.05.16.50.07;	author nbingham;	state Exp;
branches;
next	1.8;

1.8
date	99.03.03.15.00.37;	author nbingham;	state Exp;
branches;
next	1.7;

1.7
date	98.11.09.09.31.24;	author nbingham;	state Exp;
branches;
next	1.6;

1.6
date	98.11.06.12.05.17;	author nbingham;	state Exp;
branches;
next	1.5;

1.5
date	98.11.05.11.47.41;	author nbingham;	state Exp;
branches;
next	1.4;

1.4
date	98.10.22.17.37.14;	author nbingham;	state Exp;
branches;
next	1.3;

1.3
date	98.09.29.09.02.38;	author nbingham;	state Exp;
branches;
next	1.2;

1.2
date	98.09.28.13.02.13;	author nbingham;	state Exp;
branches;
next	1.1;

1.1
date	98.09.24.12.30.26;	author nbingham;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.24.12.30.26;	author nbingham;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Log:
!Mk        - increased Wimpslot.
!MkExport  -   "   "    "   "
NB_Files   - Fixed canonicalise code that was checked in broken in 0.25.
Added code to escape text to remove reserved HTML characters and replace
with escaped sequences.  This code was originally written by BAL for NCMail,
but is now used in more than one place hence it is incorporated here.

Version 0.26. Tagged as 'NBLib-0_26'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/* File:    NB_Files.c                                                  */
/* Purpose: File contains code to do with filer operations.             */
/*                                                                      */
/* Author:  Neil Bingham <mailto:neil@@binghams.demon.co.uk>             */
/* History: 0.01  Tue 14th October 1997                                 */
/*                Created.                                              */
/*          0.02  Fri 07th August 1998                                  */
/*                Removed directory code into separate file.            */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "main.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */


/* ============================================================================================== */
/* |======================================== CREATE CODE =======================================| */
/* ============================================================================================== */



/************************************************************************/
/* nb_file_copy                                                         */
/*                                                                      */
/* Function copies the file specified in source to the file specified   */
/* in destination.                                                      */
/*                                                                      */
/* Parameters: flags       - 0: Set   - Move files.                     */
/*                              Unset - Copy files.                     */
/*             source      - source file.                               */
/*             destination - destination file.                          */
/*                                                                      */
/* Returns:    _kernel_oserror: 0 - Source file doesn't exist.          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_copy(unsigned int flags, char *source, char *destination)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_swi_regs		 regs;

  nbinternal_clear_return_code();

  if (nb_file_exists(1, source, NULL, NULL) == NULL)
  {
    regs.r[0] = 26;
    regs.r[1] = (int) source;
    regs.r[2] = (int) destination;

    if (nb_bit_set(flags, 0) == TRUE)
    {
      regs.r[3] = 4738;
    }
    else
    {
      regs.r[3] = 4610;
    }
    return(_kernel_swi(OS_FSControl, &regs, &regs));
  }
  else
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_copy failed because the source file didn't exist");
    return_ptr = &return_code;
    return(return_ptr);
  }
}


/************************************************************************/
/* nb_file_delete                                                       */
/*                                                                      */
/* Function deletes the specified file.                                 */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to delete. */
/*              location  - directory location or full file path.       */
/*              file_name - file to del, or NULL.                       */
/*                                                                      */
/* Returns:     _kernel_oserror: 0 - file doesn't exist.                */
/*                               2 - SWI call failed.                   */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_delete(unsigned int flags, char *location, char *file_name)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_swi_regs		 regs;
  char				*buffer = NULL;

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, file_name, &buffer) == FALSE)
  {
    return_code.errnum = 1;
    strcpy(return_code.errmess, "nb_file_delete failed due to lack of memory.");
    return_ptr = &return_code;
  }
  else
  {
    /* Check for the existance of the file */
    if (nb_file_exists(1, buffer, NULL, NULL) != NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_delete failed because file specified does not exist");
      return_ptr = &return_code;
    }
    else
    {
      /* File Exists */
      regs.r[0] = 6;
      regs.r[1] = (int) buffer;

      if (_kernel_swi(OS_File, &regs, &regs) != NULL)
      {
        return_code.errnum = 2;
        strcpy(return_code.errmess,
               "nb_file_delete failed because OS_File swi returned non-null data.");
        return_ptr = &return_code;
      }
    }
  }
  free(buffer);
  return(return_ptr);
}


/************************************************************************/
/* nb_file_exists                                                       */
/*                                                                      */
/* Function checks to see if the specified file exists.                 */
/*                                                                      */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to check.  */
/*                          Bit 1 Set   - Check filetype                */
/*              location  - directory location or full file path.       */
/*              file_name - dir to check, or NULL.                      */
/*                                                                      */
/* Returns:    _kernel_oserror: 0 - File doesn't have correct filetype. */
/*                              2 - A non-file exists with this name.   */
/*                              Correct OS error returned otherwise.    */
/************************************************************************/
_kernel_oserror *nb_file_exists(unsigned int flags, char *location, char *file_name, int file_type)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_oserror		*er = NULL;
  _kernel_swi_regs		 regs;
  char				*buffer = NULL;

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, file_name, &buffer) == FALSE)
  {
    return_code.errnum = 1;
    strcpy(return_code.errmess, "nb_file_exists failed due to lack of memory.");
    return_ptr = &return_code;
  }
  else
  {
    regs.r[0] = 21;
    regs.r[1] = (int) buffer;

    er = _kernel_swi(OS_File, &regs, &regs);

    if (er != NULL)
    {
      /* Pass proper OS codes back to calling program */
      return_code.errnum = er->errnum;
      strcpy(return_code.errmess, er->errmess);
      return_ptr = &return_code;
    }
    else
    {
      /* OK, because the SWI didn't return an error something exists.  Now we need to check what */
      if((regs.r[0] != 0) && (regs.r[0] != 2))
      {
        /* The buffer does not point to a directory, so continue. */
        if (nb_bit_set(flags,1) == TRUE)
        {
          /* Check Filetype */
          if (regs.r[6] != file_type)
          {
            /* Filetype invalid */
            return_code.errnum = 0;
            strcpy(return_code.errmess,
                   "nb_file_exists failed because File Does Not Have The Specified FileType");
            return_ptr = &return_code;
          }
        }
      }
      else
      {
        /* Item exists but it isn't a file */
        return_code.errnum = 2;
        strcpy(return_code.errmess,
               "nb_file_exists failed the item isn't a file");
        return_ptr = &return_code;
      }
    }
  }
  free(buffer);
  return(return_ptr);
}


/************************************************************************/
/* nb_file_find_filetype                                                */
/*                                                                      */
/* Function returns the filename of the first file in the directory     */
/* with type absolute.                                                  */
/*                                                                      */
/*                                                                      */
/* Parameters:  flags                                                   */
/*              location  - directory location.                         */
/*              file_type - as hex integer.                             */
/*              file_name - pointer to string                           */
/*              nbytes    - size of string                              */
/*                                                                      */
/* Returns:    _kernel_oserror: 0 - no file of this type exists.        */
/*                              2 - specified dir doesn't exist.        */
/************************************************************************/
_kernel_oserror *nb_file_find_filetype(unsigned int flags, char *location, int file_type,
                                        char *file_name, int nbytes)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_oserror		*er = NULL;
  _kernel_swi_regs		 regs;
  OSGBPB_Full_Info		 buffer;      /* Buffer for file details. */
  int				 found_file = FALSE;

  NB_UNUSED(flags);

  nbinternal_clear_return_code();

  /* Setup SWI registers */
  regs.r[0] = 12;		/* OS_GBPB 12 */
  regs.r[1] = (int) location;	/* Directory to search */
  regs.r[2] = (int)&buffer;	/* Buffer for directory information */
  regs.r[3] = 1;		/* Read one item at a time */
  regs.r[4] = 0;		/* Offset of first item to read (0 for start) */
  regs.r[5] = sizeof(buffer);
  regs.r[6] = (int)"*";         /* Return Everything */

  if (nb_directory_exists(1, location, NULL) == NULL)
  {
    /* Directory Exists */
    do
    {
      if ((er = _kernel_swi(OS_GBPB, &regs, &regs)) != NULL)
      {
        /* Error returned by SWI */
        break;
      }

      if (regs.r[3] > 0)
      {
        /* A file has been returned */
        if (buffer.file_type == file_type)
        {
          /* We have found the first file in the directory to match the criteria */
          strncpy(file_name, buffer.name, (nbytes-1));
          found_file = TRUE;
        }
      }
    }
    while (regs.r[4] != -1);

    /* In case we didn't find anything, return an error block */
    if (found_file == FALSE)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess,
             "nb_file_find_filetype failed because a file of that type didn't exist");
      return_ptr = &return_code;
    }
  }
  else
  {
    return_code.errnum = 2;
    strcpy(return_code.errmess,"nb_file_find_filetype failed because host directory doesn't exist");
    return_ptr = &return_code;
  }

  return(return_ptr);
}


/************************************************************************/
/* nb_file_get_datestamp                                                */
/*                                                                      */
/* Function returns the datestamp information for the specified file as */
/* would be seen from the Filer File->Info dialogue.                    */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to check.  */
/*              location  - directory location or full file path.       */
/*              file_name - file to check, or NULL.                     */
/*              date      - string to put date into.                    */
/*              size      - size of date.                               */
/*                                                                      */
/* Returns:     _kernel_oserror: 0 - file doesn't exist.                */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_get_datestamp(unsigned int flags,char *location,char *filename,char *date,
                                       int size)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_swi_regs		 regs;
  unsigned char			 block[5];
  char				*buffer = NULL;
  char				 datetime[45];

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, filename, &buffer) == FALSE)
  {
    return_code.errnum = 1;
    strcpy(return_code.errmess, "nb_file_get_datestamp failed due to lack of memory.");
    return_ptr = &return_code;
  }
  else
  {
    if (nb_file_exists(1, buffer, NULL, NULL) == NULL)
    {
      /* File Exists */
      regs.r[0] = 5;
      regs.r[1] = (int) buffer;

      _kernel_swi(OS_File, &regs, &regs);

      /* Put 5 byte time into block */
      block[4] = (regs.r[2] & 0xFF);
      block[3] = (regs.r[3] & 0xFF000000)	>> 24;
      block[2] = (regs.r[3] & 0xFF0000)		>> 16;
      block[1] = (regs.r[3] & 0xFF00)		>> 8;
      block[0] = (regs.r[3] & 0xFF);

      regs.r[0] = (int)  block;
      regs.r[1] = (int) &datetime;
      regs.r[2] = sizeof(datetime);

      _kernel_swi(OS_ConvertStandardDateAndTime, &regs, &regs);

      strncpy(date, datetime, size);
    }
    else
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess,
             "nb_file_get_datestamp failed because file specified does not exist");
      return_ptr = &return_code;
    }
  }

  free(buffer);
  return(return_ptr);
}

/************************************************************************/
/* nb_file_get_leafname                                                 */
/*                                                                      */
/* Function returns <filename> from <path>.<filename>.                  */
/*                                                                      */
/* Parameters:  flags    - if Bit 0 is set don't check for file existing*/
/*              fullpath - full filename path                           */
/*              filename - pointer to char                              */
/*              size     - size of filename buffer.                     */
/*                                                                      */
/* Returns:     _kernel_oserror: 0 - file doesn't exist with bit 0 unset*/
/*                               2 - buffer too short.                  */
/*                               3 - fullpath contained invalid filename*/
/************************************************************************/
_kernel_oserror *nb_file_get_leafname(unsigned int flags, char *fullpath, char *filename, int size)
{
  _kernel_oserror		*return_ptr = NULL;
  int				 counter = 0;
  int				 start_pos = 0;
  int				 len = 0;

  nbinternal_clear_return_code();

  len = strlen(fullpath) - 1;
  start_pos = len;

  if (nb_bit_set(flags, 0) == FALSE)
  {
    if (nb_file_exists(1, fullpath, NULL, NULL) != NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_get_leafname failed because the file doesn't exist");
      return_ptr = &return_code;
      return(return_ptr);
    }
  }

  if (strstr(fullpath, ".") == NULL)
  {
    /* No parent path found */
    return_code.errnum = 3;
    strcpy(return_code.errmess, "nb_file_get_leafname failed invalid filename was passed");
    return_ptr = &return_code;
  }
  else
  {
    do
    {
      start_pos--;
    }
    while(fullpath[start_pos] != '.');
    start_pos++;

    /* Check that the buffer is big enough */
    if ( (len - start_pos) < size)
    {
      for (counter = 0; counter <= (len - start_pos); counter++)
      {
        filename[counter] = fullpath[start_pos + counter];
      }
      filename[counter] = '\0';
    }
    else
    {
      return_code.errnum = 2;
      strcpy(return_code.errmess, "nb_file_get_leafname failed because the buffer was too short.");
      return_ptr = &return_code;
    }
  }

  return(return_ptr);
}



/************************************************************************/
/* nb_file_get_lines                                                    */
/*                                                                      */
/* Function returns the number of lines of text in a file.              */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to count.  */
/*              location  - directory location or full file path.       */
/*              file_name - file to count, or NULL                      */
/*                                                                      */
/* Returns:    lines in file (-1 if no memory or file doesn't exist).   */
/*                                                                      */
/************************************************************************/
int nb_file_get_lines(unsigned int flags, char *location, char *filename)
{
  int			 lines_code = 0;
  char			 letter;
  char			*buffer = NULL;
  FILE			*file_handle;

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, filename, &buffer) == FALSE)
  {
    lines_code = -1;
  }
  else
  {
    if (nb_file_exists(1, buffer, NULL, NULL) != NULL)
    {
      lines_code = -1;
    }
    else
    {
      /* File Exists */
      file_handle = fopen(buffer, "r");

      if (file_handle != NULL)
      {
        while ((letter = getc(file_handle)) != 255) //EOF
        {
          if ( (letter == 10) || (letter == 13) ) //'\n')
          {
            lines_code++;
          }
        }
        fclose(file_handle);
      }
      else
      {
        /* Unable to open file */
        lines_code = -1;
      }
    }
  }
  free(buffer);
  return(lines_code);
}


/************************************************************************/
/* nb_file_get_size                                                     */
/*                                                                      */
/* Function returns the size of the specified file in bytes             */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to count.  */
/*              location  - directory location or full file path.       */
/*              file_name - file to count, or NULL.                     */
/*                                                                      */
/* Returns:    size (-1 if no memory or file doesn't exist).            */
/*                                                                      */
/************************************************************************/
int nb_file_get_size(unsigned int flags, char *location, char *filename)
{
  _kernel_oserror	*er = NULL;
  _kernel_swi_regs	 regs;
  char			*buffer = NULL;
  int			 size = -1;

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, filename, &buffer) == FALSE)
  {
    size = -1;
  }
  else
  {
    if (nb_file_exists(1, buffer, NULL, NULL) != NULL)
    {
      size = -1;
    }
    else
    {
      /* File Exists */
      regs.r[0] = 17;
      regs.r[1] = (int) buffer;

      er = _kernel_swi(OS_File, &regs, &regs);

      if (er != NULL)
        size = -1;
      else
        size = regs.r[4];
    }
  }
  free(buffer);
  return(size);
}


/************************************************************************/
/* nb_file_get_parent_dir                                               */
/*                                                                      */
/* Function returns <path> from <path>.<filename>.                      */
/*                                                                      */
/* Parameters:  flags      - flags field.                               */
/*              fullpath   - full path of filename.                     */
/*              parent_dir - pointer to buffer.                         */
/*              nbytes     - size of buffer.                            */
/*                                                                      */
/* Returns:     _kernel_oserror: 0 - file doesn't exist.                */
/*                               2 - buffer too short.                  */
/************************************************************************/
_kernel_oserror *nb_file_get_parent_dir(unsigned int flags, char *fullpath, char *parent_dir,
                                        int nbytes)
{
  _kernel_oserror		*return_ptr = NULL;
  int				 counter = 0;
  int				 stop_pos = 0;
  int				 len = 0;

  NB_UNUSED(flags);
  nbinternal_clear_return_code();

  if (nb_file_exists(1, fullpath, NULL, NULL) != NULL)
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_get_parent_dir failed because the file doesn't exist");
    return_ptr = &return_code;
  }
  else
  {
    len = strlen(fullpath) - 1;

    /* We need to start at the end of the string and work backwards to find the beginning of the
     * filename - this will be denoted by a "." character
     */
    stop_pos = len;

    do
    {
      stop_pos--;
    }
    while(fullpath[stop_pos] != '.');

    /* We now scan through from the beginning of the string to the stop_pos (which will be the "."
     * character, and extract the data
     */
    if (stop_pos < nbytes)
    {
      for (counter = 0; counter <= (stop_pos - 1); counter++)
      {
        parent_dir[counter] = fullpath[counter];
      }
      parent_dir[counter] = '\0';
    }
    else
    {
      return_code.errnum = 2;
      strcpy(return_code.errmess, "nb_file_get_parent_dir failed because the buffer is too short.");
      return_ptr = &return_code;
    }
  }
  return(return_ptr);
}


/************************************************************************/
/* nb_file_get_filetype                                                 */
/*                                                                      */
/* Function gets the filetype of the specified file.                    */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to get type*/
/*              location  - directory location or full file path.       */
/*              file_name - file to check, or NULL.                     */
/*              file_type - pointer to int.                             */
/*                                                                      */
/* Returns:    _kernel_oserror: 0 - file doesn't exist.                 */
/*                                  SWI return code returned if not NULL*/
/************************************************************************/
_kernel_oserror *nb_file_get_filetype(unsigned int flags, char *location, char *file_name,
                                        int *file_type)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_oserror		*er = NULL;
  _kernel_swi_regs		 regs;
  char				*buffer = NULL;

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, file_name, &buffer) == FALSE)
  {
    return_code.errnum = 1;
    strcpy(return_code.errmess, "nb_file_get_filetype failed due lack of memory");
    return_ptr = &return_code;
  }
  else
  {
    if (nb_file_exists(1, buffer, NULL, NULL) == NULL)
    {
      regs.r[0] = 20;
      regs.r[1] = (int ) buffer;

      er = _kernel_swi(OS_File, &regs, &regs);

      if (er == NULL)
      {
        *file_type = regs.r[6];
      }
      else
      {
        return_code.errnum = er->errnum;
        strcpy(return_code.errmess, er->errmess);
        return_ptr = &return_code;
      }
    }
    else
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_get_filetype failed because file doesn't exist.");
      return_ptr = &return_code;
    }
  }
  free(buffer);
  return(return_ptr);
}


/************************************************************************/
/* nb_file_set_filetype                                                 */
/*                                                                      */
/* Function sets the filetype of the specified file.                    */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to settype */
/*              location  - directory location or full file path.       */
/*              file_name - dir to check, or NULL.                      */
/*              file_type - Hex filetype.                               */
/*                                                                      */
/* Returns:    _kernel_oserror: 0 - file doesn't exist.                 */
/*                              SWI return code returned if not NULL.   */
/************************************************************************/
_kernel_oserror *nb_file_set_filetype(unsigned int flags, char *location, char *file_name,
                                        int file_type)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_oserror		*er = NULL;
  _kernel_swi_regs		 regs;
  char		  		*buffer = NULL;

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, file_name, &buffer) == FALSE)
  {
    return_code.errnum = 1;
    strcpy(return_code.errmess, "nb_file_set_filetype failed due lack of memory");
    return_ptr = &return_code;
  }
  else
  {
    if (nb_file_exists(1, buffer, NULL, NULL) == NULL)
    {
      regs.r[0] = 18;
      regs.r[1] = (int ) buffer;
      regs.r[2] = file_type;

      er = _kernel_swi(OS_File, &regs, &regs);

      if (er != NULL)
      {
        return_code.errnum = er->errnum;
        strcpy(return_code.errmess, er->errmess);
      }
    }
    else
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_set_filetype failed because file doesn't exist.");
      return_ptr = &return_code;
    }
  }
  free(buffer);
  return(return_ptr);
}


/************************************************************************/
/* nb_file_stamp                                                        */
/*                                                                      */
/* Function stamps the specified file.                                  */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to stamp.  */
/*              location  - directory location or full file path.       */
/*              file_name - file to run, or NULL.                       */
/*                                                                      */
/* Returns:     _kernel_oserror: NULL or SWI's error block.             */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_stamp(unsigned int flags, char *location, char *file_name)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_oserror		*er = NULL;
  _kernel_swi_regs		 regs;
  char				*buffer = NULL;

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, file_name, &buffer) == FALSE)
  {
    return_code.errnum = 1;
    strcpy(return_code.errmess, "nb_file_stamp failed due lack of memory");
    return_ptr = &return_code;
  }
  else
  {
    regs.r[0] = 9;
    regs.r[1] = (int) buffer;

    er = _kernel_swi(OS_File, &regs, &regs);

    if (er != NULL)
    {
      return_code.errnum = er->errnum;
      strcpy(return_code.errmess, er->errmess);
      return_ptr = &return_code;
    }
  }

  free(buffer);
  return(return_ptr);
}


/************************************************************************/
/* nb_file_lock                                                         */
/*                                                                      */
/* Function sets the Lock bit of the specified file.                    */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to lock.   */
/*              location  - directory location or full file path.       */
/*              file_name - file to lock, or NULL.                      */
/*                                                                      */
/* Returns:     _kernel_oserror: 0 - file attributes couldn't be read.  */
/*                               1 - file attributes couldn't be written*/
/************************************************************************/
_kernel_oserror *nb_file_lock(unsigned int flags, char *location, char *file_name)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_oserror		*er = NULL;
  _kernel_swi_regs		 regs;
  char				*buffer = NULL;

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, file_name, &buffer) == FALSE)
  {
    return_code.errnum = 1;
    strcpy(return_code.errmess, "nb_file_lock failed due lack of memory");
    return_ptr = &return_code;
  }
  else
  {
    if (nb_file_exists(1, buffer, NULL, NULL) != NULL)
    {
      return_code.errnum = 3;
      strcpy(return_code.errmess,"nb_file_lock failed because file doesn't exist.");
      return_ptr = &return_code;
    }
    else
    {
      regs.r[0] = 17;
      regs.r[1] = (int) buffer;

      /* OK now that paths have been setup, get the existing file flags */
      er = _kernel_swi(OS_File, &regs, &regs);

      if (er != NULL)
      {
        return_code.errnum = 0;
        strcpy(return_code.errmess,"nb_file_lock failed because file attributes couldn't be read.");
        return_ptr = &return_code;
      }
      else
      {
        /* Update the returned flags to lock the file */
        regs.r[5] |= (1 << 3);
        regs.r[0] = 4;

        er = _kernel_swi(OS_File, &regs, &regs);

        if (er != NULL)
        {
          return_code.errnum = 2;
          strcpy(return_code.errmess,
                 "nb_file_lock failed because file attributes couldn't be written.");
          return_ptr = &return_code;
        }
      }
    }
  }
  free(buffer);
  return(return_ptr);
}


/************************************************************************/
/* nb_file_unlock                                                       */
/*                                                                      */
/* Function sets the Lock bit of the specified file to unlocked.        */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to unlock. */
/*              location  - directory location or full file path.       */
/*              file_name - file to unlock, or NULL.                    */
/*                                                                      */
/* Returns:     _kernel_oserror block.                                  */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_unlock(unsigned int flags, char *location, char *file_name)
{
  _kernel_oserror		*return_ptr = NULL;
  _kernel_oserror		*er = NULL;
  _kernel_swi_regs		 regs;
  char				*buffer = NULL;

  nbinternal_clear_return_code();

  /* Setup the file paths accordingly based on the flags word */
  if (nbinternal_setup_file_paths(flags, location, file_name, &buffer) == FALSE)
  {
    return_code.errnum = 1;
    strcpy(return_code.errmess, "nb_file_unlock failed due lack of memory");
    return_ptr = &return_code;
  }
  else
  {
    if (nb_file_exists(1, buffer, NULL, NULL) != NULL)
    {
      return_code.errnum = 3;
      strcpy(return_code.errmess,"nb_file_unlock failed because file doesn't exist.");
      return_ptr = &return_code;
    }
    else
    {
      regs.r[0] = 17;
      regs.r[1] = (int) buffer;

      /* OK now that paths have been setup, get the existing file flags */
      er = _kernel_swi(OS_File, &regs, &regs);

      if (er != NULL)
      {
        return_code.errnum = 0;
        strcpy(return_code.errmess,"nb_file_unlock failed (file attributes couldn't be read).");
        return_ptr = &return_code;
      }
      else
      {
        /* Update the returned flags to lock the file */
        regs.r[5] &= ~(1 << 3);
        regs.r[0] = 4;

        er = _kernel_swi(OS_File, &regs, &regs);

        if (er != NULL)
        {
          return_code.errnum = 2;
          strcpy(return_code.errmess,
                 "nb_file_unlock failed because file attributes couldn't be written.");
          return_ptr = &return_code;
        }
      }
    }
  }
  free(buffer);
  return(return_ptr);
}



/************************************************************************/
/* nb_canonicalise_path                                                  */
/*                                                                      */
/* Function calls OS_FSControl 37 on the specified string.              */
/*                                                                      */
/* Parameters: pointer to store expanded path at.                       */
/*             path to expand                                           */
/*                                                                      */
/* Returns:    TRUE (success) or FALSE (malloc failed).                 */
/*                                                                      */
/************************************************************************/
int nb_canonicalise_path(char **path, char *dir)
{
  _kernel_swi_regs	 regs;
  int			 buff_size = 0;
  char			*buffer = NULL;

  regs.r[0] = 37;
  regs.r[1] = (int) dir;
  regs.r[2] = NULL;
  regs.r[4] = 0;
  regs.r[5] = NULL;

  _kernel_swi(OS_FSControl, &regs, &regs);
  buff_size = ~regs.r[5] + 10;

  if ((buffer = malloc(buff_size)) != NULL)
  {
    regs.r[0] = 37;
    regs.r[1] = (int) dir;
    regs.r[2] = (int) buffer;
    regs.r[4] = 0;
    regs.r[5] = buff_size;

    if (_kernel_swi(OS_FSControl, &regs, &regs) == NULL)
    {
      *path = buffer;
      return(TRUE);
    }
    else
    {
      *path = NULL;
      return(FALSE);
    }
  }
  else
  {
    return(FALSE);
  }
}


@


1.8
log
@Updates to File & MessageTrans code required for the Translator tool.
Makefile tweaked to provide more readable output, !MkClean has StripDepend
and command-line EraseCVS added.

Version 0.25. Tagged as 'NBLib-0_25'
@
text
@d1002 1
a1002 1
    if (_kernel_swi(OS_FSControl, &regs, &regs) != NULL)
@


1.7
log
@Major improvements.  Fixed error handling that got broken in 0.13.  Added
test harness which tests non-toolbox functions.  As a result of this several
bugs fixed.  Some code duplication removed.  Updated StrongHelp docs.

Version 0.18. Tagged as 'NBLib-0_18'
@
text
@d966 54
@


1.6
log
@Fixed a couple of memory leaks and tidied up a few functions.  Split up some
of the code into more logical files.  Version reporting function added.
Moved to BAL's two-stage Makefile system.

Version 0.13. Tagged as 'NBLib-0_13'
@
text
@d55 1
a55 1
/* Returns:    _kernel_oserror.                                         */
d60 1
d85 2
a86 1
    return(&return_code);
d102 2
a103 1
/* Returns:     _kernel_oserror block.                                  */
d108 1
d118 2
a119 1
    strcpy(return_code.errmess, "nb_delete_file failed due to lack of memory.");
d127 2
a128 1
      strcpy(return_code.errmess, "nb_delete_file failed because file specified does not exist");
d138 1
a138 1
        return_code.errnum = 0;
d140 2
a141 1
               "nb_delete_file failed because OS_File swi returned non-null data.");
d146 1
a146 1
  return(&return_code);
d163 3
a165 2
/* Returns:    NULL if it exists, otherwise a _kernel_oserror.          */
/*                                                                      */
d167 1
a167 1
_kernel_oserror *nb_file_exists(unsigned int flags, char *location, char*file_name, int file_type)
d169 1
d174 4
a177 1
  if (nb_bit_set(flags, 0) == TRUE)
d179 3
a181 5
    /* location includes file to check.
     * Use OS_File 21 to determine path and filetype
     */
    regs.r[0] = 21;
    regs.r[1] = (int) location;
a184 11
    /* location contains parent directory only */
    if ((buffer = malloc(strlen(location) + strlen(file_name) + 6)) == NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_exists failed due to lack of memory");
      return(&return_code);
    }
    else
    {
      sprintf(buffer, "%s.%s", location, file_name);
    }
a186 1
  }
d188 1
a188 2
  /* Filepath sorted out, so check for its validity. */
  er = _kernel_swi(OS_File, &regs, &regs);
d190 8
a197 10
  if (nb_bit_set(flags, 0) == FALSE)
    free(buffer);

  if (er != NULL)
  {
    return(er);
  }
  else
  {
    if((regs.r[0] != 0) && (regs.r[0] != 2))
d199 2
a200 2
      /* The file_path does not point to a directory, so continue. */
      if (nb_bit_set(flags,1) == TRUE)
d202 2
a203 2
        /* Check Filetype */
        if (regs.r[6] == file_type)
d205 9
a213 9
          /* Filetype valid, so return */
          return(NULL);
        }
        else
        {
          return_code.errnum = 0;
          strcpy(return_code.errmess,
                 "nb_file_exists failed because File Does Not Have The Specified FileType");
          return(&return_code);
d218 5
a222 2
        /* File Exists, and filetype was not to be checked */
        return(NULL);
a224 7
    else
    {
      /* File doesn't exist */
      return_code.errnum = 0;
      strcpy(return_code.errmess, "File Specified Does Not Exist.");
      return(&return_code);
    }
d226 2
d244 2
a245 2
/* Returns:    NULL if it exists, otherwise a _kernel_oserror.          */
/*                                                                      */
d250 1
d258 2
d296 4
a299 8
    return_code.errnum = 1;
    strcpy(return_code.errmess,
           "nb_file_find_filetype failed because a file of that type didn't exist");
    return(&return_code);
    }
    else
    {
      return(NULL);
d304 1
a304 1
    return_code.errnum = 1;
d306 1
a306 1
    return(&return_code);
d308 2
d327 1
a327 1
/* Returns:     _kernel_oserror if file does not exist.                 */
d333 1
a336 1
  int				 buffer_len = 0;
d339 1
a339 4
  if (nb_bit_set(flags, 0) == TRUE)
    buffer_len = strlen(location) + 5;
  else
    buffer_len = strlen(location) + strlen(filename) + 5;
d341 2
a342 2
  /* Allocate buffer */
  if ((buffer = malloc(buffer_len)) == NULL)
d344 3
a346 3
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_get_datestamp failed due to lack of memory");
    return(&return_code);
a349 9
    if (nb_bit_set(flags, 0) == TRUE)
    {
      strcpy(buffer, location);
    }
    else
    {
      sprintf(buffer, "%s.%s", location, filename);
    }

a371 2
      free(buffer);
      return(NULL);
a374 3
      /* file specified does not exist */
      free(buffer);

d378 1
a378 1
      return(&return_code);
d381 3
d396 3
a398 2
/* Returns:     _kernel_oserror                                         */
/*                                                                      */
d402 1
d407 2
d418 2
a419 1
      return(&return_code);
d422 2
a423 1
  do
d425 4
a428 1
    start_pos--;
d430 8
a437 2
  while(fullpath[start_pos] != '.');
  start_pos++;
d439 10
a448 4
  /* Check that the buffer is big enough */
  if ( (len - start_pos) < size)
  {
    for (counter = 0; counter <= (len - start_pos); counter++)
d450 3
a452 1
      filename[counter] = fullpath[start_pos + counter];
a453 8
    filename[counter] = '\0';
    return(NULL);
  }
  else
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_get_leafname failed because the buffer was too short.");
    return(&return_code);
d455 2
d472 1
a472 1
/* Returns:    lines in file.                                           */
d482 4
a485 1
  if (nb_bit_set(flags, 0) == TRUE)
d487 1
a487 10
    /* Bit 1 set: location contains full filepath */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
    {
      /* File Exists */
      file_handle = fopen(location, "r");
    }
    else
    {
      return(NULL);
    }
d491 1
a491 4
    /* Bit 1 unset: location is just directory
     * allocate memory for operation
     */
    if ((buffer = malloc(strlen(location) + strlen(filename) + 30)) == NULL)
d493 1
a493 1
      return(NULL);
d497 1
a497 1
      sprintf(buffer, "%s.%s", location, filename);
a498 2
    }
  }
d500 12
a511 5
  if (file_handle != NULL)
  {
    while ((letter = getc(file_handle)) != 255) //EOF
    {
      if ( (letter == 10) || (letter == 13) ) //'\n')
d513 2
a514 1
        lines_code++;
a516 13
    fclose(file_handle);

    if (nb_bit_set(flags, 0) == FALSE)
      free(buffer);

    return lines_code;
  }
  else
  {
    if (nb_bit_set(flags, 0) == FALSE)
      free(buffer);

    return(0);
d518 2
d534 1
a534 1
/* Returns:    size (-1 if file doesn't exist).                         */
d542 3
a544 1
  OSGBPB_Full_Info	 details;     /* Buffer for file details. */
d546 2
a547 1
  if (nb_bit_set(flags, 0) == FALSE)
d549 1
a549 10
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
    {
      /* File Exists */
      regs.r[1] = (int) location;
    }
    else
    {
      /* file specified does not exist */
      return(-1);
    }
d553 1
a553 1
    if (nb_file_exists(0, location, filename, NULL) == NULL)
d555 1
a555 9
      if ((buffer = malloc(strlen(location) + strlen(filename) + 5)) == NULL)
      {
        return(-1);
      }
      else
      {
        sprintf(buffer, "%s.%s", location, filename);
        regs.r[1] = (int) buffer;
      }
d559 3
a561 4
      /* File doesn't exist */
      return(-1);
    }
  }
d563 1
a563 7
  /* OK, Now call the swi */
  regs.r[0] = 12;			/* OS_GBPB 12 */
  regs.r[2] = (int)&details;		/* Buffer for directory information */
  regs.r[3] = 1;			/* Read one item at a time */
  regs.r[4] = 0;			/* Offset of first item to read (0 for start) */
  regs.r[5] = sizeof(details);
  regs.r[6] = (int) "*";
d565 4
a568 6
  do
  {
    if ((er = _kernel_swi(OS_GBPB, &regs, &regs)) != NULL)
    {
      /* Error returned by SWI */
      break;
d571 2
a572 9
  while ((nb_case_insensitive_strcmp(filename, details.name) != 0) && (regs.r[4] != -1));

  if (nb_bit_set(flags, 0) == FALSE)
    free(buffer);

  if (er != NULL)
    return(-1);
  else
    return(details.size);
d586 2
a587 2
/* Returns:     _kernel_oserror                                         */
/*                                                                      */
d592 1
d598 1
d600 7
a606 1
  if (nb_file_exists(1, fullpath, NULL, NULL) == NULL)
a630 1
      return(NULL);
d634 1
a634 1
      return_code.errnum = 0;
d636 1
a636 1
      return(&return_code);
d639 1
a639 6
  else
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_get_parent_dir failed because the file doesn't exist");
    return(&return_code);
  }
d655 2
a656 2
/* Returns:    _kernel_oserror if file doesn't exist                    */
/*                                                                      */
d661 2
d666 4
a669 1
  if (nb_bit_set(flags, 0) == TRUE)
d671 3
a673 11
    /* location includes file to check. */
    if ((buffer = malloc(strlen(location) +  20)) == NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_get_filetype failed due lack of memory");
      return(&return_code);
    }
    else
    {
      strcpy(buffer, location);
    }
d677 1
a677 2
    /* location contains parent directory only */
    if ((buffer = malloc(strlen(location) + strlen(file_name) + 20)) == NULL)
d679 15
a693 3
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_get_filetype failed due lack of memory");
      return(&return_code);
d697 3
a699 1
      sprintf(buffer, "%s.%s", location, file_name);
d702 2
a703 21

  /* Filepath sorted out, so get the filetype */
  if (nb_file_exists(1, buffer, NULL, NULL) == NULL)
  {
    regs.r[0] = 20;
    regs.r[1] = (int ) buffer;

    _kernel_swi(OS_File, &regs, &regs);

    *file_type = regs.r[6];

    free(buffer);
    return(NULL);
  }
  else
  {
    free(buffer);
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_get_filetype failed because file doesn't exist.");
    return(&return_code);
  }
d719 2
a720 2
/* Returns:    NULL if it exists, otherwise a _kernel_oserror.          */
/*                                                                      */
d725 1
d730 4
a733 1
  if (nb_bit_set(flags, 0) == TRUE)
d735 3
a737 11
    /* location includes file to check. */
    if ((buffer = malloc(strlen(location) +  20)) == NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_set_filetype failed due lack of memory");
      return(&return_code);
    }
    else
    {
      strcpy(buffer, location);
    }
d741 1
a741 2
    /* location contains parent directory only */
    if ((buffer = malloc(strlen(location) + strlen(file_name) + 20)) == NULL)
d743 11
a753 3
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_set_filetype failed due lack of memory");
      return(&return_code);
d757 3
a759 1
      sprintf(buffer, "%s.%s", location, file_name);
d762 2
a763 23

  /* Filepath sorted out, so get the filetype */
  if (nb_file_exists(1, buffer, NULL, NULL) == NULL)
  {
    regs.r[0] = 18;
    regs.r[1] = (int ) buffer;
    regs.r[2] = file_type;

    er = _kernel_swi(OS_File, &regs, &regs);
    free(buffer);

    if (er == NULL)
      return(NULL);
    else
      return(er);
  }
  else
  {
    free(buffer);
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_set_filetype failed because file doesn't exist.");
    return(&return_code);
  }
d778 1
a778 1
/* Returns:     _kernel_oserror block.                                  */
d783 1
d788 4
a791 1
  if (nb_bit_set(flags, 0) == TRUE)
d793 3
a795 17
    /* Bit 1 set: location contains full filepath */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
    {
      /* File Exists */
      regs.r[0] = 9;
      regs.r[1] = (int) location;

      er = _kernel_swi(OS_File, &regs, &regs);
      return(er);
    }
    else
    {
      /* file specified does not exist */
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_stamp_file failed because file specified does not exist");
      return(&return_code);
    }
d799 2
a800 15
    /* Location contains just directory file exists in - check to see if it is valid */
    if (nb_directory_exists(1, location, NULL) == NULL)
    {
      /* We must add file_name to the end of location
       * allocate memory for operation
       */
      if ((buffer = malloc(strlen(location) + strlen(file_name) + 5)) == NULL)
      {
        return_code.errnum = 0;
        strcpy(return_code.errmess, "nb_stamp_file failed due to lack of memory");
        return(&return_code);
      }
      else
      {
        sprintf(buffer, "%s.%s", location, file_name);
d802 1
a802 2
        regs.r[0] = 9;
        regs.r[1] = (int) buffer;
d804 1
a804 17
        er = _kernel_swi(OS_File, &regs, &regs);
        free(buffer);

        if (er != NULL)
        {
          return_code.errnum = 0;
          strcpy(return_code.errmess,
                 "nb_stamp_file failed because the file specified doesn't exist.");
          return(&return_code);
        }
        else
        {
          return(NULL);
        }
      }
    }
    else
d806 3
a808 5
      return_code.errnum = 0;
      strcpy(return_code.errmess,
             "nb_stamp_file failed because the directory specified doesn't exist.");
      return(&return_code);

d811 3
d828 2
a829 2
/* Returns:     _kernel_oserror block.                                  */
/*                                                                      */
d833 1
d838 4
a841 1
  if (nb_bit_set(flags, 0) == TRUE)
d843 7
a849 2
    /* location includes file to lock */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
d851 3
a853 2
      regs.r[0] = 17;
      regs.r[1] = (int) location;
d857 7
a863 13
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_lock failed because file doesn't exist");
      return(&return_code);
    }
  }
  else
  {
    /* Location contains parent directory */
    /* file_name contains details of the file to lock.  Check file actually exists. */
    if (nb_file_exists(0, location, file_name, NULL) == NULL)
    {
      /* allocate memory for operation */
      if ((buffer = malloc(strlen(location) + strlen(file_name) + 6)) == NULL)
d866 2
a867 2
        strcpy(return_code.errmess, "nb_file_lock failed due to lack of memory");
        return(&return_code);
d871 5
a875 1
        sprintf(buffer, "%s.%s", location, file_name);
d877 7
a883 2
        regs.r[0] = 17;
        regs.r[1] = (int) buffer;
a885 29
    else
    {
      /* Parent directory didn't exist - report error */
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_lock failed because the file doesn't exist");
      return(&return_code);
    }
  }

  /* OK now that paths have been setup, get the existing file flags */
  _kernel_swi(OS_File, &regs, &regs);

  /* Update the returned flags to lock the file */
  regs.r[5] |= (1 << 3);
  regs.r[0] = 4;

  er = _kernel_swi(OS_File, &regs, &regs);

  if (nb_bit_set(flags, 0) == FALSE)
    free(buffer);

  if (er != NULL)
  {
    return(er);
  }
  else
  {
    /* No problem encountered */
    return(NULL);
d887 2
d908 1
d913 4
a916 1
  if (nb_bit_set(flags, 0) == TRUE)
d918 7
a924 2
    /* location includes file to unlock */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
d926 3
a928 2
      regs.r[0] = 17;
      regs.r[1] = (int) location;
d932 7
a938 13
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_unlock failed because file doesn't exist");
      return(&return_code);
    }
  }
  else
  {
    /* Location contains parent directory */
    /* file_name contains details of the file to unlock.  Check file actually exists. */
    if (nb_file_exists(0, location, file_name, NULL) == NULL)
    {
      /* allocate memory for operation */
      if ((buffer = malloc(strlen(location) + strlen(file_name) + 6)) == NULL)
d941 2
a942 2
        strcpy(return_code.errmess, "nb_file_unlock failed due to lack of memory");
        return(&return_code);
d946 5
a950 1
        sprintf(buffer, "%s.%s", location, file_name);
d952 7
a958 2
        regs.r[0] = 17;
        regs.r[1] = (int) buffer;
a960 29
    else
    {
      /* Parent directory didn't exist - report error */
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_unlock failed because the file doesn't exist");
      return(&return_code);
    }
  }

  /* OK now that paths have been setup, get the existing file flags */
  _kernel_swi(OS_File, &regs, &regs);

  /* Update the returned flags to lock the file */
  regs.r[5] &= ~(1 << 3);
  regs.r[0] = 4;

  er = _kernel_swi(OS_File, &regs, &regs);

  if (nb_bit_set(flags, 0) == FALSE)
    free(buffer);

  if (er != NULL)
  {
    return(er);
  }
  else
  {
    /* No problem encountered */
    return(NULL);
d962 2
a964 1

@


1.5
log
@Made improvements to error handling.

Version 0.12. Tagged as 'NBLib-0_12'
@
text
@d62 2
a104 1
  _kernel_oserror		*er = NULL;
d108 9
a116 1
  if (nb_bit_set(flags, 0) == TRUE)
d118 2
a119 14
    /* Bit 1 set: location contains full filepath */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
    {
      /* File Exists */
      regs.r[0] = 6;
      regs.r[1] = (int) location;

      er = _kernel_swi(OS_File, &regs, &regs);
      if (er != NULL)
        return(er);
      else
        return(NULL);
    }
    else
a120 1
      /* file specified does not exist */
a122 1
      return(&return_code);
d124 1
a124 5
  }
  else
  {
    /* Location contains just directory file exists in - check to see if it is valid */
    if (nb_directory_exists(1, location, NULL) == NULL)
d126 5
a130 4
      /* We must add file_name to the end of location
       * allocate memory for operation
       */
      if ((buffer = malloc(strlen(location) + strlen(file_name) + 5)) == NULL)
d133 2
a134 2
        strcpy(return_code.errmess, "nb_delete_file failed due to lack of memory");
        return(&return_code);
a135 29
      else
      {
        sprintf(buffer, "%s.%s", location, file_name);

        regs.r[0] = 6;
        regs.r[1] = (int) buffer;

        er = _kernel_swi(OS_File, &regs, &regs);
        if (er != NULL)
        {
          return_code.errnum = 0;
          strcpy(return_code.errmess,
                 "nb_delete_file failed because the file specified doesn't exist.");

          free(buffer);
          return(&return_code);
        }
        else
        {
          return(NULL);
        }
      }
    }
    else
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess,
             "nb_delete_file failed because the directory specified doesn't exist.");
      return(&return_code);
d138 2
d193 3
a210 4
          if (nb_bit_set(flags, 0) == FALSE)
          {
            free(buffer);
          }
a217 4
          if (nb_bit_set(flags, 0) == FALSE)
          {
            free(buffer);
          }
a223 4
        if (nb_bit_set(flags, 0) == FALSE)
        {
          free(buffer);
        }
a231 4
      if (nb_bit_set(flags, 0) == FALSE)
      {
        free(buffer);
      }
d296 1
a345 1
  {
a346 1
  }
a347 1
  {
d349 1
a349 1
  }
d390 1
d396 2
d524 1
a525 1
    {
d527 1
a527 1
    }
a532 1
    {
d534 1
a534 1
    }
d558 2
a559 1
  OSGBPB_Full_Info	 buffer;      /* Buffer for file details. */
d563 14
a576 10
    /* Bit 1 unset: location contains just directory */
    regs.r[0] = 12;			/* OS_GBPB 12 */
    regs.r[1] = (int) location;		/* Directory to search */
    regs.r[2] = (int)&buffer;		/* Buffer for directory information */
    regs.r[3] = 1;			/* Read one item at a time */
    regs.r[4] = 0;			/* Offset of first item to read (0 for start) */
    regs.r[5] = sizeof(buffer);
    regs.r[6] = (int) "*";

    do
d578 5
a582 1
      if ((er = _kernel_swi(OS_GBPB, &regs, &regs)) != NULL)
d584 2
a585 2
        /* Error returned by SWI */
        break;
d588 6
a593 1
    while ((strcmp(filename, buffer.name) != 0) && (regs.r[4] != -1));
d595 15
a609 1
    return(buffer.size);
d611 9
a619 1
  return(-1);
d899 2
a905 2

          free(buffer);
d1000 3
d1088 3
@


1.4
log
@Removed dependencies on ErrorLib in all functions except Toolbox ones.

Version 0.11. Tagged as 'NBLib-0_11'
@
text
@d60 1
a60 2
  _kernel_swi_regs	regs;
  _kernel_oserror	return_code;
d103 3
a105 4
  _kernel_oserror	 return_code;
  _kernel_oserror	*er;
  _kernel_swi_regs	 regs;
  char			*buffer;
d196 3
a198 4
  _kernel_oserror	*er;
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  char			*buffer = NULL;
d305 4
a308 5
  _kernel_oserror	*er;
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  OSGBPB_Full_Info	 buffer;      /* Buffer for file details. */
  int			 found_file=FALSE;
d386 5
a390 6
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  unsigned char		 block[5];
  char			*buffer;
  int			 buffer_len;
  char			 datetime[45];
d468 3
a470 2
  _kernel_oserror	return_code;
  int  counter, start_pos, len=0;
d527 1
a527 1
  int			 lines_code=0;
d604 1
a604 1
  _kernel_oserror	*er;
d651 3
a653 2
  _kernel_oserror	return_code;
  int  counter, stop_pos=0, len=0;
d718 2
a719 3
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  char			*buffer;
d791 3
a793 4
  _kernel_oserror	 return_code;
  _kernel_oserror	*er;
  _kernel_swi_regs	 regs;
  char			*buffer;
d865 3
a867 4
  _kernel_oserror	 return_code;
  _kernel_oserror	*er;
  _kernel_swi_regs	 regs;
  char			*buffer;
d954 3
a956 4
  _kernel_oserror	*er;
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  char			*buffer;
d1040 3
a1042 4
  _kernel_oserror	*er;
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  char			*buffer;
@


1.3
log
@Bug fix to set type function.

Version 0.04. Tagged as 'NBLib-0_04'
@
text
@d119 4
a122 2
      error_check(er);
      return(NULL);
a229 1
  error_check(er);
d231 1
a231 1
  if((regs.r[0] != 0) && (regs.r[0] != 2))
d233 5
a237 2
    /* The file_path does not point to a directory, so continue. */
    if (nb_bit_set(flags,1) == TRUE)
d239 2
a240 2
      /* Check Filetype */
      if (regs.r[6] == file_type)
d242 11
a252 2
        /* Filetype valid, so return */
        if (nb_bit_set(flags, 0) == FALSE)
d254 8
a261 1
          free(buffer);
a262 1
        return(NULL);
d266 1
a266 3
        return_code.errnum = 0;
        strcpy(return_code.errmess,
               "nb_file_exists failed because File Does Not Have The Specified FileType");
d271 1
a271 1
        return(&return_code);
d276 3
a278 1
      /* File Exists, and filetype was not to be checked */
d283 1
a283 11
      return(NULL);
    }
  }
  else
  {
    /* File doesn't exist */
    return_code.errnum = 0;
    strcpy(return_code.errmess, "File Specified Does Not Exist.");
    if (nb_bit_set(flags, 0) == FALSE)
    {
      free(buffer);
a284 1
    return(&return_code);
d885 1
a885 2
      error_check(er);
      return(NULL);
@


1.2
log
@Added two new functions to NB_Files.c

Version 0.03. Tagged as 'NBLib-0_03'
@
text
@d788 2
d803 1
a803 1
      sprintf(buffer, "settype %s %x", location, file_type);
d817 1
a817 1
      sprintf(buffer, "settype %s.%s %x", location, file_name, file_type);
d821 22
a842 4
  /* Filepath sorted out, so set the filetype */
  _kernel_oscli(buffer);
  free(buffer);
  return(NULL);
@


1.1
log
@Initial revision
@
text
@d918 1
a918 1
/* nb_file_set_lock_permissions                                         */
d920 1
a920 1
/* Function sets the lock access attributes on the specified file       */
d922 5
a926 4
/* Parameters: flags     - Bit 0 set:   location contains full path     */
/*                         Bit 0 unset: location contains parent dir.   */
/*             location  - directory location or full file path.        */
/*             file_name - file to run, or NULL.                        */
d928 1
a928 1
/* Returns:    _kernel_oserror block.                                   */
d931 1
a931 1
_kernel_oserror *nb_file_set_lock_permissions(unsigned int flags, char *location, char *filename)
d933 1
a934 1
  _kernel_oserror	*er;
d940 1
a940 1
    /* Bit 1 set: location contains full filepath */
d943 1
a943 2
      /* File Exists */
      regs.r[0] = 13;
d945 24
d970 12
a981 4
      /* Get existing flags */
      er = _kernel_swi(OS_File, &regs, &regs);
      error_check(er);
      regs.r[5] = regs.r[5] + 8;
d983 2
a984 2
      /* Set flags */
      regs.r[0] = 1;
d986 16
a1001 2
      er = _kernel_swi(OS_File, &regs, &regs);
      error_check(er);
d1003 29
a1031 1
      return(NULL);
a1034 1
      /* file specified does not exist */
d1036 1
a1036 1
      strcpy(return_code.errmess, "nb_file_set_lock failed because file specified does not exist");
d1042 3
a1044 2
    /* Location contains just directory file exists in - check to see if it is valid */
    if (nb_directory_exists(1, location, NULL) == NULL)
d1046 2
a1047 4
      /* We must add file_name to the end of location
       * allocate memory for operation
       */
      if ((buffer = malloc(strlen(location) + strlen(filename) + 5)) == NULL)
d1050 1
a1050 1
        strcpy(return_code.errmess, "nb_file_set_lock failed due to lack of memory");
d1055 1
a1055 1
        sprintf(buffer, "%s.%s", location, filename);
d1057 1
a1057 1
        regs.r[0] = 13;
d1059 10
d1070 2
a1071 2
        er = _kernel_swi(OS_File, &regs, &regs);
        error_check(er);
d1073 3
a1075 1
        regs.r[5] = regs.r[5] + 8;
d1077 1
a1077 3
        regs.r[0] = 1;
        er = _kernel_swi(OS_File, &regs, &regs);
        error_check(er);
d1079 8
a1086 4
        free(buffer);
        return(NULL);
      }
    }
a1087 1
  return(NULL);
d1089 2
@


1.1.1.1
log
@Initial import of NBLib.

@
text
@@

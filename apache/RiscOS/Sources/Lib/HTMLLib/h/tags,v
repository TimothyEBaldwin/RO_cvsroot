head	1.3;
access;
symbols
	HTMLLib-0_04:1.3
	HTMLLib-0_03:1.3
	HTMLLib-0_02:1.3
	HTMLLib-0_01:1.3
	ahodgkin_207release:1.3
	ahodgkin_206release:1.3
	ahodgkin_205release:1.3
	ahodgkin_204release:1.3
	ahodgkin_133beta:1.2.2.17
	kbracey_126:1.2.2.15
	kbracey_AW97patch:1.2.2.15
	ahodgkin_AW97:1.2.2.15
	kbracey_PreGordon:1.2
	Web_bp:1.2
	Web:1.2.0.2
	ARTtmp_merge:1.1.2.2
	ARTtmp:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	98.02.17.10.42.35;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	97.04.29.15.51.02;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.08.10.27.12;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.2.2.1
date	97.06.26.11.02.53;	author kbracey;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	97.07.02.08.39.49;	author kbracey;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	97.07.02.09.06.02;	author gthorbur;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	97.07.02.16.02.05;	author kbracey;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	97.07.24.16.21.11;	author kbracey;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	97.07.28.15.20.02;	author kbracey;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	97.07.30.12.09.40;	author kbracey;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	97.08.01.09.00.10;	author kbracey;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	97.08.01.15.06.46;	author kbracey;	state Exp;
branches;
next	1.2.2.10;

1.2.2.10
date	97.08.18.16.13.42;	author kbracey;	state Exp;
branches;
next	1.2.2.11;

1.2.2.11
date	97.09.12.09.12.33;	author ahodgkin;	state Exp;
branches;
next	1.2.2.12;

1.2.2.12
date	97.09.30.14.14.21;	author kbracey;	state Exp;
branches;
next	1.2.2.13;

1.2.2.13
date	97.10.02.14.49.15;	author kbracey;	state Exp;
branches;
next	1.2.2.14;

1.2.2.14
date	97.10.06.13.50.53;	author kbracey;	state Exp;
branches;
next	1.2.2.15;

1.2.2.15
date	97.10.13.10.51.50;	author kbracey;	state Exp;
branches;
next	1.2.2.16;

1.2.2.16
date	97.11.14.15.43.22;	author kbracey;	state Exp;
branches;
next	1.2.2.17;

1.2.2.17
date	98.01.09.16.31.11;	author ahodgkin;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.08.10.27.12;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.04.28.14.20.31;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Web branch merged
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*************************************************************************/
/* HTML tags definitions file. (C)1995/1996 Acorn Computers Ltd.         */
/*************************************************************************/
/* This file contains the header definitions of the tags used in the     */
/* the HTML parser. It is currently divided into two sections; those in  */
/* the 'style' word (HTML tags) and those in the 'type' word (anchor     */
/* tags and derived information).   	     	 	     		 */
/*************************************************************************/

#ifndef __tags_h__
#define __tags_h__

/* NULL is used a lot so if we dont have one, define one. */
#ifndef NULL
#define NULL 0
#endif



//#define LOADSMEM

/*#define TABLE_SUPPORT*/

/*************************************************************************/
/* The first section deals with the STYLE word in the HStream structure. */
/* This contains the main HTML markup tags, which are defined as         */
/* follows. To find out if a tag is set on a HStream element passed back */
/* and it with the style word. If the resultant value is the tag then    */
/* the tag is set (note that non-zero is not sufficient since the header */
/* tags occupy only 3 bits for 7 tags.)	     		      	  	 */
/*************************************************************************/

/*************************************************************************/
/* These tags are found in the stlye word if bit 1 of the type word is   */
/* set and bit 0 is not, otherwise the meanings found in the relevant    */
/* section of this file should be applied. 	      	       	         */
/*************************************************************************/

/*#define TITLE       ((unsigned int)1<<31)*/ /* <TITLE>....</TITLE>         */
#define LINK        ((unsigned int)1<<30) /* <LINK ... > 	         */
#define ISINDEX	    ((unsigned int)1<<29) /* <ISINDEX> 		         */
/*#define BASE        ((unsigned int)12345)*/ /* <BASE ... >		 */ /* these numbers need sorting out! */
/*#define STYLE       ((unsigned int)12346)*/ /* <STYLE></STYLE>             */
/*#define SCRIPT      ((unsigned int)12347)*/ /* <SCRIPT></SCRIPT>           */
#define META	    ((unsigned int)1<<27) /* <META ... >		 */
/*#define NEXTID      ((unsigned int)1<<26)*/ /* <NEXTID ... >	         */

/*************************************************************************/
/* These tags / style flags apply only to tags found in the body         */
/* section (bit 0 set). Remember that some of the tags overlap those     */
/* in other sections.               	    	     	     		 */
/*************************************************************************/

/*************************************************************************/
/* Basic text styles: bold, italic and fixed width.                      */
/*************************************************************************/
#define BOLD        ((unsigned int)1<<2) /* <B>...</B>	 */
#define ITALIC	    ((unsigned int)1<<3) /* <I>...</I>	 */
#define TT	    ((unsigned int)1<<4) /* <TT>...</TT> */

/*************************************************************************/
/* Additional text styles. These are mapped back on to Bold, Italic and  */
/* fixed width.	   	   	     	   	      	    	   	 */
/*************************************************************************/
#define EM	    ITALIC /* <EM>...</EM>	   */
#define STRONG	    BOLD   /* <STRONG>...</STRONG> */
#define CODE	    TT     /* <CODE>...</CODE>	   */
#define SAMP	    TT     /* <SAMP>...</SAMP>	   */
#define KBD	    TT     /* <KBD>...</KBD>	   */
#define VAR	    TT     /* <VAR>...</VAR>	   */
#define CITE        ITALIC /* <CITE>...</CITE>	   */

/*************************************************************************/
/* We have two basic types of anchors; A tags and IMaGe tags.            */
/*************************************************************************/
#define A           ((unsigned int)1<<5) /* <A ...>...</A> */
#define IMG         ((unsigned int)1<<6) /* <IMG ...>      */

/*************************************************************************/
/* Paragraphs and line breaks.                                           */
/*************************************************************************/
#define P           ((unsigned int)1<<7) /* <P> ... </P> */
#define BR	    ((unsigned int)1<<8) /* <BR>         */

/*************************************************************************/
/* A horizontal rule.                                                    */
/*************************************************************************/
#define HR          ((unsigned int)1<<9) /* <HR> */

/*************************************************************************/
/* HTML has 6 layers of header, but since we have allocated 3 bits to    */
/* store them, here are 7 header types.	     	  	      	   	 */
/*************************************************************************/
#define H_SHIFT     10
#define H_MASK      ((unsigned int)7<<H_SHIFT)
#define H1          ((unsigned int)1<<H_SHIFT) /* <H1> ... </H1> */
#define H2          ((unsigned int)2<<H_SHIFT) /* <H2> ... </H2> */
#define H3          ((unsigned int)3<<H_SHIFT) /* <H3> ... </H3> */
#define H4          ((unsigned int)4<<H_SHIFT) /* <H4> ... </H4> */
#define H5          ((unsigned int)5<<H_SHIFT) /* <H5> ... </H5> */
#define H6          ((unsigned int)6<<H_SHIFT) /* <H6> ... </H6> */

/*************************************************************************/
/* Preformatted text. This is fixed width with Linefeeds and spaces      */
/* preserved. Escape sequences are expanded.   		     		 */
/*************************************************************************/
#define PRE	    ((unsigned int)1<<13) /* <PRE> ... </PRE> */

/*************************************************************************/
/* A number of different types of list are supported.                    */
/*************************************************************************/
/* A definitions list. This consists of a term to be defined and the a   */
/* piece of text defining it.	     	       	     	     	     	 */
/*************************************************************************/
#define DL          ((unsigned int)1<<14) /* <DL> ... </DL> */
#define DT          ((unsigned int)1<<15) /* <DT> ... </DT> */
#define DD          ((unsigned int)1<<16) /* <DD> ... </DD> */

/*************************************************************************/
/* NOBR - don't word break between two consecutive tokens thus marked    */
/*************************************************************************/
#define NOBR        ((unsigned int)1<<17) /* <NOBR> ... </NOBR> */

/*************************************************************************/
/* An unordered list. Elements are bulleted. A menu is also an UL        */
/*************************************************************************/
#define UL	    ((unsigned int)1<<18) /* <UL> ... </UL>     */

/*************************************************************************/
/* All lists have 'list items'.                                          */
/*************************************************************************/
#define LI	    ((unsigned int)1<<19) /* <LI> ... </LI>     */

/*************************************************************************/
/* There are a number of other forms of text blocks; BLOCKQUOTES and     */
/* ADDRESSes   	      	       	     	     	     		 	 */
/*************************************************************************/
#define BLOCKQUOTE  ((unsigned int)1<<20) /* <BLOCKQUOTE> .. </BLOCKQUOTE> */
#define ADDRESS	    ((unsigned int)1<<21) /* <ADDRESS> ... </ADDRESS>      */

/*************************************************************************/
/* For various reasons a number of tags introduced by another browser    */
/* are also supported and/or understood.	      	      		 */
/*************************************************************************/
#define CENTER	    ((unsigned int)1<<22) /* <CENTRE> ... </CENTRE> */
#define FONT	    ((unsigned int)1<<23) /* <FONT...> ... </FONT>  */

#define UNDERLINE   ((unsigned int)1<<24) /* <U> ... </U>           */
#define STRIKE      ((unsigned int)1<<25) /* <STRIKE> ... </STRIKE> */

/*************************************************************************/
/* The next set of body tags deals with basic forms handling.            */
/*************************************************************************/

/*************************************************************************/
/* The main FORM tag                                                     */
/*************************************************************************/
#define FORM        ((unsigned int)1<<26) /* <FORM> ... </FORM> */

/*************************************************************************/
/* More text styles.                                                     */
/*************************************************************************/
#define RIGHT       ((unsigned int)1<<27) /* <P align=right> ... </P> */
#define SUB         ((unsigned int)1<<28) /* <SUB> ... </SUB>         */
#define SUP         ((unsigned int)1<<29) /* <SUP> ... </SUP>         */

/*#define DUMMY       ((unsigned int)1<<29)*/ /* To mark a gap            */

#define ISSUB(t)    ((t)->style & SUB)
#define ISSUP(t)    ((t)->style & SUP)
#define ISUNDERLINE(t) ((t)->style & UNDERLINE)
#define ISSTRIKE(t)    ((t)->style & STRIKE)


/*************************************************************************/
/* This next bit depends upon whether we have table support enabled!     */
/*************************************************************************/
#ifndef TABLE_SUPPORT
/*************************************************************************/
/* PCDATA is used to define a text element. Its is more an internal flag */
/* in the parser but it may be of use externally.  	   	    	 */
/*************************************************************************/
#define PCDATA      ((unsigned int)1<<30) /* Normal text */
#else /* TABLE_SUPPORT enabled */
#define PCDATA 0
#endif /* TABLE_SUPPORT */

//*************************************************************************/
/* These tags / style flags apply only to tags found in the frameset     */
/* section, if present (ie. bit 0 & 1 unset and bit 2 set). Remember     */
/* that some of the  tags overlap those  in other sections.              */
/*************************************************************************/
#define FRAME      (1U<<31) /* Start at the other end - it's cleaner */

/*************************************************************************/
/* Now for stuff in the second style word                                */
/*************************************************************************/

/*#define UNDERLINE (1U<<0)
#define STRIKE    (1U<<1)*/

/*#define ISUNDERLINE(t) ((t)->style2 & UNDERLINE)
#define ISSTRIKE(t)    ((t)->style2 & STRIKE)*/

/*************************************************************************/
/* The rest of this file deals with the type word allocations.           */
/*************************************************************************/

/*************************************************************************/
/* The following definitions look a little out of place here, and not    */
/* without reason: they are. PW placed the important body/head           */
/* determination flag here when he could no longer fit it in the         */
/* original style word - TGR.                                            */
/*************************************************************************/
#define TYPE_BODY      (1U)
#define BODY           TYPE_BODY
#define TYPE_HEAD      (1U<<1)
#define HEAD 	       TYPE_HEAD
#define TYPE_FRAMESET  (1U<<2)
#define TYPE_NOFRAMES  (1U<<3)
#define TYPE_MASK      (TYPE_BODY|TYPE_HEAD|TYPE_FRAMESET|TYPE_NOFRAMES)

#define ISHEAD(p)   (((p)->type) & TYPE_HEAD)
#define ISBODY(p)   (((p)->type) & TYPE_BODY)
#define ISFRAMESET(p) (((p)->type) & TYPE_FRAMESET)
#define ISNOFRAMES(p) (((p)->type) & TYPE_NOFRAMES)
#define ISNULL(p)   ((((p)->type) & TYPE_MASK) == 0)


/*************************************************************************/
/* Is the tag currently being presented a start of end tag. This is used */
/* in conjunction with the 'tag' field in the HStream structure.    	 */
/*************************************************************************/
#define TYPE_START_SHIFT 8
#define TYPE_START       ((unsigned int)1<<TYPE_START_SHIFT)

/*************************************************************************/
/* If the element has an alignment set, it is stored here.               */
/*************************************************************************/
#define TYPE_ALIGN_SHIFT 9

#define TYPE_TOP         ((unsigned int)1<<TYPE_ALIGN_SHIFT)
#define TYPE_MIDDLE      ((unsigned int)2<<TYPE_ALIGN_SHIFT)
#define TYPE_BOTTOM      ((unsigned int)3<<TYPE_ALIGN_SHIFT)
#define TYPE_LEFT        ((unsigned int)4<<TYPE_ALIGN_SHIFT)
#define TYPE_RIGHT       ((unsigned int)5<<TYPE_ALIGN_SHIFT)
#define TYPE_CENTRE      ((unsigned int)6<<TYPE_ALIGN_SHIFT)
#define TYPE_FULLJUSTIFY ((unsigned int)7<<TYPE_ALIGN_SHIFT)

#define TYPE_ALIGN_MASK  ((unsigned int)7<<TYPE_ALIGN_SHIFT)

/*************************************************************************/
/* If an image is also an anchor, look here to see if it is also an      */
/* image map   	       	  	       	       	      	    	 	 */
/*************************************************************************/
#define TYPE_ISMAP_SHIFT 12
#define TYPE_ISCLIENTMAP_SHIFT 13

#define TYPE_ISMAP       ((unsigned int)1<<TYPE_ISMAP_SHIFT)
#define TYPE_ISCLIENTMAP ((unsigned int)1<<TYPE_ISCLIENTMAP_SHIFT)

/*************************************************************************/
/* For horizontal rules (could overload on TYPE_SELECTED ??? )           */
/*************************************************************************/
#define TYPE_NOSHADE_SHIFT 23

#define TYPE_NOSHADE   (1U<<TYPE_NOSHADE_SHIFT)

/*************************************************************************/
/* If this tag has a colour defined by <FONT>, this bit is set.          */
/*************************************************************************/
#define TYPE_COLOURED_SHIFT 24

#define TYPE_COLOURED  (1U<<TYPE_COLOURED_SHIFT)

#define UNITS_PIXELS 0
#define UNITS_PERCENT 1

#define ALIGN_LEFT   TYPE_LEFT
#define ALIGN_CENTER TYPE_CENTRE
#define ALIGN_RIGHT  TYPE_RIGHT
#define ALIGN_FULL   TYPE_FULLJUSTIFY

#define ALIGN_TOP    1
#define ALIGN_MIDDLE 2
#define ALIGN_BOTTOM 3

/*************************************************************************/
/* Type word for FRAMEs etc.                                             */
/*************************************************************************/
#define TYPE_SCROLLING_SHIFT 29
#define TYPE_NORESIZE_SHIFT  31

typedef enum _scroll_options {
  SCROLLING_AUTO, SCROLLING_YES, SCROLLING_NO
} ScrollOptions;

#define SCROLLING_MASK 3U

#define TYPE_SCROLLING_NO   ((unsigned int) SCROLLING_NO  <<TYPE_SCROLLING_SHIFT)
#define TYPE_SCROLLING_YES  ((unsigned int) SCROLLING_YES <<TYPE_SCROLLING_SHIFT)
#define TYPE_SCROLLING_AUTO ((unsigned int) SCROLLING_AUTO<<TYPE_SCROLLING_SHIFT)

#define TYPE_SCROLLING_MASK (SCROLLING_MASK<<TYPE_SCROLLING_SHIFT)

#define TYPE_NORESIZE  (1U<<TYPE_NORESIZE_SHIFT)

/*************************************************************************/
/* Macros for accessing the fields of an HR...                           */
/* Note that if you change these, you'll need to play with               */
/* html_get_anchor_info()                                                */
/*************************************************************************/
#define HR_HAS_WIDTH(t)   ((t)->cols & 0x01000000)
#define HR_WIDTH(t)       ((t)->cols & 0x00FFFFFF)
#define HR_WIDTH_UNITS(t) ((unsigned)((t)->cols) >> 28)
#define HR_ALIGN(t)       ((unsigned)((t)->type & TYPE_ALIGN_MASK))
#define HR_HAS_SIZE(t)    (HR_SIZE(t) != 0)
#define HR_SIZE(t)        ((t)->size & 0x00FFFFFF)
#define HR_SIZE_UNITS(t)  UNITS_PIXELS
#define HR_NOSHADE(t)     ((t)->type & TYPE_NOSHADE)

#define OBJECT_HAS_WIDTH(t)    ((t)->cols & 0x01000000)
#define OBJECT_WIDTH(t)        ((t)->cols & 0x00FFFFFF)
#define OBJECT_WIDTH_UNITS(t)  ((unsigned)((t)->cols) >> 28)
#define OBJECT_HAS_HEIGHT(t)   ((t)->rows & 0x01000000)
#define OBJECT_HEIGHT(t)       ((t)->rows & 0x00FFFFFF)
#define OBJECT_HEIGHT_UNITS(t) ((unsigned)((t)->rows) >> 28)

#endif /* __tags_h__ */
@


1.2
log
@Merged in ARTtmp_merge
@
text
@a31 1
#define FRAMESUPPORT
d53 1
a53 1
#define TITLE       ((unsigned int)1<<31) /* <TITLE>....</TITLE>         */
d56 3
a58 1
#define BASE        ((unsigned int)12345) /* <BASE ... >		 */ /* these numbers need sorting out! */
d60 1
a60 1
#define NEXTID      ((unsigned int)1<<26) /* <NEXTID ... >	         */
d76 1
a76 1
/* Additional text styles. These are maped back on to Bold, Italic and   */
a115 1
#define H7          ((unsigned int)7<<H_SHIFT) /* <H7> ... </H7> */
d134 1
a134 1
/* An ordered list. Elements should be numbered.                         */
d136 1
a136 1
#define OL	    ((unsigned int)1<<17) /* <OL> ... </OL> */
a141 6
#define MENU	    UL	                  /* <MENU> ... </MENU> */

/*************************************************************************/
/* A directory listing is a special type of list too.                    */
/*************************************************************************/
#define DIR         ((unsigned int)1<<19) /* <DIR> ... </DIR>   */
d146 1
a146 1
#define LI	    ((unsigned int)1<<20) /* <LI> ... </LI>     */
d152 2
a153 2
#define BLOCKQUOTE  ((unsigned int)1<<21) /* <BLOCKQUOTE> .. </BLOCKQUOTE> */
#define ADDRESS	    ((unsigned int)1<<22) /* <ADDRESS> ... </ADDRESS>      */
d159 5
a163 2
#define CENTER	    ((unsigned int)1<<23) /* <CENTRE> ... </CENTRE> */
#define FONT	    ((unsigned int)1<<24) /* <FONT...> ... </FONT>  */
d172 1
a172 1
#define FORM        ((unsigned int)1<<25) /* <FORM> ... </FORM> */
d175 1
a175 3
/* These are the tags that can exist within a form. Information derived  */
/* from them may be found in the type word or other fields in the        */
/* HStream structure as appropriate.  	      	    	      		 */
d177 10
a186 4
#define INPUT	    ((unsigned int)1<<26) /* <INPUT ...> */
#define SELECT	    ((unsigned int)1<<27) /* <SELECT> ... </SELECT> */
#define OPTION	    ((unsigned int)1<<28) /* <OPTION ...> */
#define TEXTAREA    ((unsigned int)1<<29) /* <TEXTAREA ...> */
a200 13
#define CDATA       PCDATA  /* _should_ work */
#define EMPTY	    0

/*************************************************************************/
/* Lots of table support stuff. Because of the way this works it appears */
/* in bits 0,1,30 and 31 of the style word :( This was due to an         */
/* oversight on day one :(                                               */
/*************************************************************************/
#define TR          ((unsigned int)3<<0)  /* <TR>...</TR> IRRELEVANT! (separate data structure) */
#define TD          ((unsigned int)3<<1)  /* <TD>...</TD> IRRELEVANT! */
/*?? what are the conflicts with HEAD BODY and TITLE? */
#define TH          ((unsigned int)1<<30) /* <TH>...</TH> IRRELEVANT! and free */
#define TABLE       ((unsigned int)1<<31) /* <TABLE>...</TABLE> */
d202 1
a202 1
/*************************************************************************/
a206 1
#ifdef FRAMESUPPORT
d208 10
a217 1
#endif
a228 1
#ifdef FRAMESUPPORT
d235 7
a241 13
#define ISBODY(p)   ((((p)->type) & TYPE_BODY) != 0)
#define ISHEAD(p)   ((((p)->type) & TYPE_HEAD) != 0)
#define ISFRAMESET(p) ((((p)->type) & TYPE_FRAMESET) != 0)
#define ISNOFRAMES(p) ((((p)->type) & TYPE_NOFRAMES) != 0)
#else
#define TYPE_HEAD (0U)
#define TYPE_BODY (1U)
#define HEAD (1U)
#define BODY (1U<<1)
#define TYPE_FRAMESET  (1U<<2)
#define ISBODY(p)   ((((p)->type) & HEAD) == 0)
#define ISHEAD(p)   (!ISBODY((p)))
#endif
d271 1
d274 1
a274 50

/*************************************************************************/
/* If the tag is an input field, the type of the field is defined here   */
/*************************************************************************/
#define TYPE_INPUT_SHIFT 13

#define TYPE_TEXT        (0) /* If no value is set it is a text field! */
#define TYPE_PASSWORD    ((unsigned int)1<<TYPE_INPUT_SHIFT)
#define TYPE_CHECKBOX    ((unsigned int)2<<TYPE_INPUT_SHIFT)
#define TYPE_RADIO       ((unsigned int)3<<TYPE_INPUT_SHIFT)
#define TYPE_IMAGE       ((unsigned int)4<<TYPE_INPUT_SHIFT)
#define TYPE_HIDDEN      ((unsigned int)5<<TYPE_INPUT_SHIFT)
#define TYPE_SUBMIT      ((unsigned int)6<<TYPE_INPUT_SHIFT)
#define TYPE_RESET       ((unsigned int)7<<TYPE_INPUT_SHIFT)

/*************************************************************************/
/* If the form element is a box of some sort, this bit is set if its     */
/* initial state is checked.	   	      	       	      	 	 */
/*************************************************************************/
#define TYPE_CHECKED_SHIFT 16

#define TYPE_CHECKED   ((unsigned int)1<<TYPE_CHECKED_SHIFT)

/*************************************************************************/
/* If this input type can have multiple selected items (INPUT and SELECT */
/* tags), then this bit is set.			       	      	  	 */
/*************************************************************************/
#define TYPE_MULTIPLE_SHIFT 17

#define TYPE_MULTIPLE  ((unsigned int)1<<TYPE_MULTIPLE_SHIFT)

/*************************************************************************/
/* If this element in the select list is the default option this is set  */
/*************************************************************************/
#define TYPE_SELECTED_SHIFT 18

#define TYPE_SELECTED  ((unsigned int)1<<TYPE_SELECTED_SHIFT)

/*************************************************************************/
/* If the tag is a FORM tag, the submission method is stored here in the */
/* same format as the URL module uses.	    	      	     	     	 */
/* NB: For some strange reason PW alotted 4 bits to the following: this  */
/* may have some import.                                                 */
/*************************************************************************/
#define TYPE_METHOD_SHIFT 19

#define TYPE_PUT       ((unsigned int)8<<TYPE_METHOD_SHIFT)
#define TYPE_POST      ((unsigned int)4<<TYPE_METHOD_SHIFT)
/* There is no definition for HEAD since it is pointless [??? - TGR]*/
#define TYPE_GET       ((unsigned int)1<<TYPE_METHOD_SHIFT)
d335 7
@


1.2.2.1
log
@Improved comment handling.
Started work on SUB, SUP, U and STRIKE support.
@
text
@a223 14
/* Now for stuff in the second style word                                */
/*************************************************************************/

#define UNDERLINE (1U<<0)
#define STRIKE    (1U<<1)
#define SUB       (1U<<2)
#define SUP       (1U<<3)

#define ISUNDERLINE(t) ((t)->style2 & UNDERLINE)
#define ISSTRIKE(t)    ((t)->style2 & STRIKE)
#define ISSUB(t)       ((t)->style2 & ISSUB)
#define ISSUP(t)       ((t)->style2 & ISSUP)

/*************************************************************************/
@


1.2.2.2
log
@Added previous pointers to table rows and cells.
Implemented skipping of <STYLE> and <SCRIPT>.
@
text
@a57 2
#define STYLE       ((unsigned int)12346) /* <STYLE></STYLE>             */
#define SCRIPT      ((unsigned int)12347) /* <SCRIPT></SCRIPT>           */
@


1.2.2.3
log
@updated to help enable head/body switching
@
text
@d256 4
a259 5
#define ISHEAD(p)   ((((p)->type) & TYPE_HEAD) == 2)
#define ISBODY(p)   ((((p)->type) & TYPE_BODY) == 3)
#define ISFRAMESET(p) ((((p)->type) & TYPE_FRAMESET) == 4)
#define ISNOFRAMES(p) ((((p)->type) & TYPE_NOFRAMES) == 5)

d266 1
a266 1
#define ISBODY(p)   ((((p)->type) & HEAD) == 3)
@


1.2.2.4
log
@Removed dependence on <HEAD> and <BODY>
@
text
@d256 4
a259 7
#define TYPE_MASK      (TYPE_BODY|TYPE_HEAD|TYPE_FRAMESET|TYPE_NOFRAMES)

#define ISHEAD(p)   (((p)->type) & TYPE_HEAD)
#define ISBODY(p)   (((p)->type) & TYPE_BODY)
#define ISFRAMESET(p) (((p)->type) & TYPE_FRAMESET)
#define ISNOFRAMES(p) (((p)->type) & TYPE_NOFRAMES)
#define ISNULL(p)   ((((p)->type) & TYPE_MASK) == 0)
@


1.2.2.5
log
@Totally redesigned attribute parsing code.
Started new API for accessing attributes - only implemented for BODY.
Added <BODY alink onload onunload> support.
@
text
@d61 1
a61 1
/*#define NEXTID      ((unsigned int)1<<26)*/ /* <NEXTID ... >	         */
d144 6
d202 2
a413 1

@


1.2.2.6
log
@SCRIPT and <A onclick> handling, hopefully
@
text
@d32 1
d213 1
d215 1
d241 1
d255 10
@


1.2.2.7
log
@Redid handling of FORM tags to use an elementinfo structure.
@
text
@d321 13
@


1.2.2.8
log
@Revised INPUT handling - made INPUT type=image work
@
text
@d283 13
d305 7
@


1.2.2.9
log
@Fixed &#160;, fixed option selection, changed GOT_MORE flag
@
text
@d283 17
@


1.2.2.10
log
@Did align on <P> and right align on tables.
Fixed problem with the final ">" of "</SCRIPT>" ending up in the title.
Fixed problem of HtmlGetStream returning a pointer to the wrong parent table.
Added SUB and SUP.
@
text
@d173 8
a180 5
/* More text styles.                                                     */
/*************************************************************************/
#define RIGHT       ((unsigned int)1<<26) /* <P align=right> ... </P> */
#define SUB         ((unsigned int)1<<27) /* <SUB> ... </SUB>         */
#define SUP         ((unsigned int)1<<28) /* <SUP> ... </SUP>         */
a181 2
#define ISSUB(t)    ((t)->style & SUB)
#define ISSUP(t)    ((t)->style & SUP)
d220 2
d225 2
@


1.2.2.11
log
@Stopped clash with TABLE, SCRIPT or STYLE looking like TITLE - should now
check for titles with (tagno=TAG_TITLE), rather than (style & TITLE).
@
text
@d53 1
a53 1
/*#define TITLE       ((unsigned int)1<<31)*/ /* <TITLE>....</TITLE>         */
@


1.2.2.12
log
@Turned off CUSTOMER_SPECIAL.
Changed encoding tables to use FFFF as a null value instead of FFFD.
Added OBJECT support (more testing required - PARAM not yet done).
Added AREA support (commented out - MAP not yet done). They come out
looking like <A></A> elements.
Souped up mapping to Latin-1 (added lossy tables for Latin Extended
Additional, CJK Punctuation and Fullwidth forms).
Added support for <H1 align=...>
Stripped some superfluous whitespace caused by linefeeds.
Fixed missing linebreak in "<DT>One<DT>Two" by turning the second DT into
a BR.
Removed now unnecessary free(malloc(16384)) bodge.
Put in CJK code even if UNIFONT not defined (hey - why not?).
Added code to take direct pointer to table rather than loading it if
it's in ResourceFS.
Added support for encoding "x-acorn-latin1".
Ensured correct handling of OPTIONs when UNIFONT not defined.
@
text
@d56 3
a58 3
/*#define BASE        ((unsigned int)12345)*/ /* <BASE ... >		 */ /* these numbers need sorting out! */
/*#define STYLE       ((unsigned int)12346)*/ /* <STYLE></STYLE>             */
/*#define SCRIPT      ((unsigned int)12347)*/ /* <SCRIPT></SCRIPT>           */
d76 1
a76 1
/* Additional text styles. These are mapped back on to Bold, Italic and  */
d116 1
a177 2

#define DUMMY       ((unsigned int)1<<29) /* To mark a gap            */
@


1.2.2.13
log
@Added STRIKE and U
@
text
@d146 1
a146 1
#define LI	    ((unsigned int)1<<19) /* <LI> ... </LI>     */
d152 2
a153 2
#define BLOCKQUOTE  ((unsigned int)1<<20) /* <BLOCKQUOTE> .. </BLOCKQUOTE> */
#define ADDRESS	    ((unsigned int)1<<21) /* <ADDRESS> ... </ADDRESS>      */
d159 2
a160 5
#define CENTER	    ((unsigned int)1<<22) /* <CENTRE> ... </CENTRE> */
#define FONT	    ((unsigned int)1<<23) /* <FONT...> ... </FONT>  */

#define UNDERLINE   ((unsigned int)1<<24) /* <U> ... </U>           */
#define STRIKE      ((unsigned int)1<<25) /* <STRIKE> ... </STRIKE> */
d169 1
a169 1
#define FORM        ((unsigned int)1<<26) /* <FORM> ... </FORM> */
d174 3
a176 3
#define RIGHT       ((unsigned int)1<<27) /* <P align=right> ... </P> */
#define SUB         ((unsigned int)1<<28) /* <SUB> ... </SUB>         */
#define SUP         ((unsigned int)1<<29) /* <SUP> ... </SUP>         */
d178 1
a178 1
/*#define DUMMY       ((unsigned int)1<<29)*/ /* To mark a gap            */
a181 3
#define ISUNDERLINE(t) ((t)->style & UNDERLINE)
#define ISSTRIKE(t)    ((t)->style & STRIKE)

d218 2
a219 2
/*#define UNDERLINE (1U<<0)
#define STRIKE    (1U<<1)*/
d221 2
a222 2
/*#define ISUNDERLINE(t) ((t)->style2 & UNDERLINE)
#define ISSTRIKE(t)    ((t)->style2 & STRIKE)*/
@


1.2.2.14
log
@Stopped style being attached to SCRIPT and STYLE tokens.
Stopping leading spaces being stripped from PRE elements.
Removed TABLE,TR,TD and TH from the style word.
@
text
@d202 12
a213 1
//*************************************************************************/
@


1.2.2.15
log
@Added % handling to OBJECT width and height
@
text
@a333 6
#define OBJECT_HAS_WIDTH(t)    ((t)->cols & 0x01000000)
#define OBJECT_WIDTH(t)        ((t)->cols & 0x00FFFFFF)
#define OBJECT_WIDTH_UNITS(t)  ((unsigned)((t)->cols) >> 28)
#define OBJECT_HAS_HEIGHT(t)   ((t)->rows & 0x01000000)
#define OBJECT_HEIGHT(t)       ((t)->rows & 0x00FFFFFF)
#define OBJECT_HEIGHT_UNITS(t) ((unsigned)((t)->rows) >> 28)
@


1.2.2.16
log
@MAP and AREA handling - first attempt
@
text
@a270 1
#define TYPE_ISCLIENTMAP_SHIFT 13
a272 1
#define TYPE_ISCLIENTMAP ((unsigned int)1<<TYPE_ISCLIENTMAP_SHIFT)
@


1.2.2.17
log
@*** empty log message ***
@
text
@d134 1
a134 1
/* NOBR - don't word break between two consecutive tokens thus marked    */
d136 1
a136 1
#define NOBR        ((unsigned int)1<<17) /* <NOBR> ... </NOBR> */
@


1.1
log
@file tags was initially added on branch ARTtmp.
@
text
@d1 395
@


1.1.2.1
log
@Initial revision
@
text
@a0 396
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*************************************************************************/
/* HTML tags definitions file. (C)1995/1996 Acorn Computers Ltd.         */
/*************************************************************************/
/* This file contains the header definitions of the tags used in the     */
/* the HTML parser. It is currently divided into two sections; those in  */
/* the 'style' word (HTML tags) and those in the 'type' word (anchor     */
/* tags and derived information).   	     	 	     		 */
/*************************************************************************/

#ifndef __tags_h__
#define __tags_h__

/* NULL is used a lot so if we dont have one, define one. */
#ifndef NULL
#define NULL 0
#endif

#define FRAMESUPPORT


//#define LOADSMEM

/*#define TABLE_SUPPORT*/

/*************************************************************************/
/* The first section deals with the STYLE word in the HStream structure. */
/* This contains the main HTML markup tags, which are defined as         */
/* follows. To find out if a tag is set on a HStream element passed back */
/* and it with the style word. If the resultant value is the tag then    */
/* the tag is set (note that non-zero is not sufficient since the header */
/* tags occupy only 3 bits for 7 tags.)	     		      	  	 */
/*************************************************************************/

/*************************************************************************/
/* These tags are found in the stlye word if bit 1 of the type word is   */
/* set and bit 0 is not, otherwise the meanings found in the relevant    */
/* section of this file should be applied. 	      	       	         */
/*************************************************************************/

#define TITLE       ((unsigned int)1<<31) /* <TITLE>....</TITLE>         */
#define LINK        ((unsigned int)1<<30) /* <LINK ... > 	         */
#define ISINDEX	    ((unsigned int)1<<29) /* <ISINDEX> 		         */
#define BASE        ((unsigned int)12345) /* <BASE ... >		 */ /* these numbers need sorting out! */
#define META	    ((unsigned int)1<<27) /* <META ... >		 */
#define NEXTID      ((unsigned int)1<<26) /* <NEXTID ... >	         */

/*************************************************************************/
/* These tags / style flags apply only to tags found in the body         */
/* section (bit 0 set). Remember that some of the tags overlap those     */
/* in other sections.               	    	     	     		 */
/*************************************************************************/

/*************************************************************************/
/* Basic text styles: bold, italic and fixed width.                      */
/*************************************************************************/
#define BOLD        ((unsigned int)1<<2) /* <B>...</B>	 */
#define ITALIC	    ((unsigned int)1<<3) /* <I>...</I>	 */
#define TT	    ((unsigned int)1<<4) /* <TT>...</TT> */

/*************************************************************************/
/* Additional text styles. These are maped back on to Bold, Italic and   */
/* fixed width.	   	   	     	   	      	    	   	 */
/*************************************************************************/
#define EM	    ITALIC /* <EM>...</EM>	   */
#define STRONG	    BOLD   /* <STRONG>...</STRONG> */
#define CODE	    TT     /* <CODE>...</CODE>	   */
#define SAMP	    TT     /* <SAMP>...</SAMP>	   */
#define KBD	    TT     /* <KBD>...</KBD>	   */
#define VAR	    TT     /* <VAR>...</VAR>	   */
#define CITE        ITALIC /* <CITE>...</CITE>	   */

/*************************************************************************/
/* We have two basic types of anchors; A tags and IMaGe tags.            */
/*************************************************************************/
#define A           ((unsigned int)1<<5) /* <A ...>...</A> */
#define IMG         ((unsigned int)1<<6) /* <IMG ...>      */

/*************************************************************************/
/* Paragraphs and line breaks.                                           */
/*************************************************************************/
#define P           ((unsigned int)1<<7) /* <P> ... </P> */
#define BR	    ((unsigned int)1<<8) /* <BR>         */

/*************************************************************************/
/* A horizontal rule.                                                    */
/*************************************************************************/
#define HR          ((unsigned int)1<<9) /* <HR> */

/*************************************************************************/
/* HTML has 6 layers of header, but since we have allocated 3 bits to    */
/* store them, here are 7 header types.	     	  	      	   	 */
/*************************************************************************/
#define H_SHIFT     10
#define H_MASK      ((unsigned int)7<<H_SHIFT)
#define H1          ((unsigned int)1<<H_SHIFT) /* <H1> ... </H1> */
#define H2          ((unsigned int)2<<H_SHIFT) /* <H2> ... </H2> */
#define H3          ((unsigned int)3<<H_SHIFT) /* <H3> ... </H3> */
#define H4          ((unsigned int)4<<H_SHIFT) /* <H4> ... </H4> */
#define H5          ((unsigned int)5<<H_SHIFT) /* <H5> ... </H5> */
#define H6          ((unsigned int)6<<H_SHIFT) /* <H6> ... </H6> */
#define H7          ((unsigned int)7<<H_SHIFT) /* <H7> ... </H7> */

/*************************************************************************/
/* Preformatted text. This is fixed width with Linefeeds and spaces      */
/* preserved. Escape sequences are expanded.   		     		 */
/*************************************************************************/
#define PRE	    ((unsigned int)1<<13) /* <PRE> ... </PRE> */

/*************************************************************************/
/* A number of different types of list are supported.                    */
/*************************************************************************/
/* A definitions list. This consists of a term to be defined and the a   */
/* piece of text defining it.	     	       	     	     	     	 */
/*************************************************************************/
#define DL          ((unsigned int)1<<14) /* <DL> ... </DL> */
#define DT          ((unsigned int)1<<15) /* <DT> ... </DT> */
#define DD          ((unsigned int)1<<16) /* <DD> ... </DD> */

/*************************************************************************/
/* An ordered list. Elements should be numbered.                         */
/*************************************************************************/
#define OL	    ((unsigned int)1<<17) /* <OL> ... </OL> */

/*************************************************************************/
/* An unordered list. Elements are bulleted. A menu is also an UL        */
/*************************************************************************/
#define UL	    ((unsigned int)1<<18) /* <UL> ... </UL>     */
#define MENU	    UL	                  /* <MENU> ... </MENU> */

/*************************************************************************/
/* A directory listing is a special type of list too.                    */
/*************************************************************************/
#define DIR         ((unsigned int)1<<19) /* <DIR> ... </DIR>   */

/*************************************************************************/
/* All lists have 'list items'.                                          */
/*************************************************************************/
#define LI	    ((unsigned int)1<<20) /* <LI> ... </LI>     */

/*************************************************************************/
/* There are a number of other forms of text blocks; BLOCKQUOTES and     */
/* ADDRESSes   	      	       	     	     	     		 	 */
/*************************************************************************/
#define BLOCKQUOTE  ((unsigned int)1<<21) /* <BLOCKQUOTE> .. </BLOCKQUOTE> */
#define ADDRESS	    ((unsigned int)1<<22) /* <ADDRESS> ... </ADDRESS>      */

/*************************************************************************/
/* For various reasons a number of tags introduced by another browser    */
/* are also supported and/or understood.	      	      		 */
/*************************************************************************/
#define CENTER	    ((unsigned int)1<<23) /* <CENTRE> ... </CENTRE> */
#define FONT	    ((unsigned int)1<<24) /* <FONT...> ... </FONT>  */

/*************************************************************************/
/* The next set of body tags deals with basic forms handling.            */
/*************************************************************************/

/*************************************************************************/
/* The main FORM tag                                                     */
/*************************************************************************/
#define FORM        ((unsigned int)1<<25) /* <FORM> ... </FORM> */

/*************************************************************************/
/* These are the tags that can exist within a form. Information derived  */
/* from them may be found in the type word or other fields in the        */
/* HStream structure as appropriate.  	      	    	      		 */
/*************************************************************************/
#define INPUT	    ((unsigned int)1<<26) /* <INPUT ...> */
#define SELECT	    ((unsigned int)1<<27) /* <SELECT> ... </SELECT> */
#define OPTION	    ((unsigned int)1<<28) /* <OPTION ...> */
#define TEXTAREA    ((unsigned int)1<<29) /* <TEXTAREA ...> */


/*************************************************************************/
/* This next bit depends upon whether we have table support enabled!     */
/*************************************************************************/
#ifndef TABLE_SUPPORT
/*************************************************************************/
/* PCDATA is used to define a text element. Its is more an internal flag */
/* in the parser but it may be of use externally.  	   	    	 */
/*************************************************************************/
#define PCDATA      ((unsigned int)1<<30) /* Normal text */
#else /* TABLE_SUPPORT enabled */
#define PCDATA 0
#endif /* TABLE_SUPPORT */
#define CDATA       PCDATA  /* _should_ work */
#define EMPTY	    0

/*************************************************************************/
/* Lots of table support stuff. Because of the way this works it appears */
/* in bits 0,1,30 and 31 of the style word :( This was due to an         */
/* oversight on day one :(                                               */
/*************************************************************************/
#ifdef TABLE_SUPPORT
#define TABLE       ((unsigned int)1<<0)  /* <TABLE>...</TABLE> */
#define TD          ((unsigned int)1<<1)  /* <TD>...</TD> */
#define TH          ((unsigned int)1<<30) /* <TH>...</TH> */
#define TR          ((unsigned int)1<<31) /* <TR>...</TR> */
#endif /* TABLE_SUPPORT */

/*************************************************************************/
/* These tags / style flags apply only to tags found in the frameset     */
/* section, if present (ie. bit 0 & 1 unset and bit 2 set). Remember     */
/* that some of the  tags overlap those  in other sections.              */
/*************************************************************************/
#ifdef FRAMESUPPORT
#define FRAME      (1U<<31) /* Start at the other end - it's cleaner */
#endif

/*************************************************************************/
/* The rest of this file deals with the type word allocations.           */
/*************************************************************************/

/*************************************************************************/
/* The following definitions look a little out of place here, and not    */
/* without reason: they are. PW placed the important body/head           */
/* determination flag here when he could no longer fit it in the         */
/* original style word - TGR.                                            */
/*************************************************************************/
#ifdef FRAMESUPPORT
#define TYPE_BODY      (1U)
#define BODY           TYPE_BODY
#define TYPE_HEAD      (1U<<1)
#define HEAD 	       TYPE_HEAD
#define TYPE_FRAMESET  (1U<<2)
#define TYPE_NOFRAMES  (1U<<3)
#define ISBODY(p)   ((((p)->type) & TYPE_BODY) != 0)
#define ISHEAD(p)   ((((p)->type) & TYPE_HEAD) != 0)
#define ISFRAMESET(p) ((((p)->type) & TYPE_FRAMESET) != 0)
#define ISNOFRAMES(p) ((((p)->type) & TYPE_NOFRAMES) != 0)
#else
#define TYPE_HEAD (0U)
#define TYPE_BODY (1U)
#define HEAD (1U)
#define BODY (1U<<1)
#define TYPE_FRAMESET  (1U<<2)
#define ISBODY(p)   ((((p)->type) & HEAD) == 0)
#define ISHEAD(p)   (!ISBODY((p)))
#endif


/*************************************************************************/
/* Is the tag currently being presented a start of end tag. This is used */
/* in conjunction with the 'tag' field in the HStream structure.    	 */
/*************************************************************************/
#define TYPE_START_SHIFT 8
#define TYPE_START       ((unsigned int)1<<TYPE_START_SHIFT)

/*************************************************************************/
/* If the element has an alignment set, it is stored here.               */
/*************************************************************************/
#define TYPE_ALIGN_SHIFT 9

#define TYPE_TOP         ((unsigned int)1<<TYPE_ALIGN_SHIFT)
#define TYPE_MIDDLE      ((unsigned int)2<<TYPE_ALIGN_SHIFT)
#define TYPE_BOTTOM      ((unsigned int)3<<TYPE_ALIGN_SHIFT)
#define TYPE_LEFT        ((unsigned int)4<<TYPE_ALIGN_SHIFT)
#define TYPE_RIGHT       ((unsigned int)5<<TYPE_ALIGN_SHIFT)
#define TYPE_CENTRE      ((unsigned int)6<<TYPE_ALIGN_SHIFT)
#define TYPE_FULLJUSTIFY ((unsigned int)7<<TYPE_ALIGN_SHIFT)

#define TYPE_ALIGN_MASK  ((unsigned int)7<<TYPE_ALIGN_SHIFT)

/*************************************************************************/
/* If an image is also an anchor, look here to see if it is also an      */
/* image map   	       	  	       	       	      	    	 	 */
/*************************************************************************/
#define TYPE_ISMAP_SHIFT 12

#define TYPE_ISMAP       ((unsigned int)1<<TYPE_ISMAP_SHIFT)

/*************************************************************************/
/* If the tag is an input field, the type of the field is defined here   */
/*************************************************************************/
#define TYPE_INPUT_SHIFT 13

#define TYPE_TEXT        (0) /* If no value is set it is a text field! */
#define TYPE_PASSWORD    ((unsigned int)1<<TYPE_INPUT_SHIFT)
#define TYPE_CHECKBOX    ((unsigned int)2<<TYPE_INPUT_SHIFT)
#define TYPE_RADIO       ((unsigned int)3<<TYPE_INPUT_SHIFT)
#define TYPE_IMAGE       ((unsigned int)4<<TYPE_INPUT_SHIFT)
#define TYPE_HIDDEN      ((unsigned int)5<<TYPE_INPUT_SHIFT)
#define TYPE_SUBMIT      ((unsigned int)6<<TYPE_INPUT_SHIFT)
#define TYPE_RESET       ((unsigned int)7<<TYPE_INPUT_SHIFT)

/*************************************************************************/
/* If the form element is a box of some sort, this bit is set if its     */
/* initial state is checked.	   	      	       	      	 	 */
/*************************************************************************/
#define TYPE_CHECKED_SHIFT 16

#define TYPE_CHECKED   ((unsigned int)1<<TYPE_CHECKED_SHIFT)

/*************************************************************************/
/* If this input type can have multiple selected items (INPUT and SELECT */
/* tags), then this bit is set.			       	      	  	 */
/*************************************************************************/
#define TYPE_MULTIPLE_SHIFT 17

#define TYPE_MULTIPLE  ((unsigned int)1<<TYPE_MULTIPLE_SHIFT)

/*************************************************************************/
/* If this element in the select list is the default option this is set  */
/*************************************************************************/
#define TYPE_SELECTED_SHIFT 18

#define TYPE_SELECTED  ((unsigned int)1<<TYPE_SELECTED_SHIFT)

/*************************************************************************/
/* If the tag is a FORM tag, the submission method is stored here in the */
/* same format as the URL module uses.	    	      	     	     	 */
/* NB: For some strange reason PW alotted 4 bits to the following: this  */
/* may have some import.                                                 */
/*************************************************************************/
#define TYPE_METHOD_SHIFT 19

#define TYPE_PUT       ((unsigned int)8<<TYPE_METHOD_SHIFT)
#define TYPE_POST      ((unsigned int)4<<TYPE_METHOD_SHIFT)
/* There is no definition for HEAD since it is pointless [??? - TGR]*/
#define TYPE_GET       ((unsigned int)1<<TYPE_METHOD_SHIFT)

/*************************************************************************/
/* For horizontal rules (could overload on TYPE_SELECTED ??? )           */
/*************************************************************************/
#define TYPE_NOSHADE_SHIFT 23

#define TYPE_NOSHADE   (1U<<TYPE_NOSHADE_SHIFT)

/*************************************************************************/
/* If this tag has a colour defined by <FONT>, this bit is set.          */
/*************************************************************************/
#define TYPE_COLOURED_SHIFT 24

#define TYPE_COLOURED  (1U<<TYPE_COLOURED_SHIFT)

#define UNITS_PIXELS 0
#define UNITS_PERCENT 1

#define ALIGN_LEFT   TYPE_LEFT
#define ALIGN_CENTER TYPE_CENTRE
#define ALIGN_RIGHT  TYPE_RIGHT
#define ALIGN_FULL   TYPE_FULLJUSTIFY

#define ALIGN_TOP    1
#define ALIGN_MIDDLE 2
#define ALIGN_BOTTOM 3

/*************************************************************************/
/* Type word for FRAMEs etc.                                             */
/*************************************************************************/
#define TYPE_SCROLLING_SHIFT 29
#define TYPE_NORESIZE_SHIFT  31

typedef enum _scroll_options {
  SCROLLING_AUTO, SCROLLING_YES, SCROLLING_NO
} ScrollOptions;

#define SCROLLING_MASK 3U

#define TYPE_SCROLLING_NO   ((unsigned int) SCROLLING_NO  <<TYPE_SCROLLING_SHIFT)
#define TYPE_SCROLLING_YES  ((unsigned int) SCROLLING_YES <<TYPE_SCROLLING_SHIFT)
#define TYPE_SCROLLING_AUTO ((unsigned int) SCROLLING_AUTO<<TYPE_SCROLLING_SHIFT)

#define TYPE_SCROLLING_MASK (SCROLLING_MASK<<TYPE_SCROLLING_SHIFT)

#define TYPE_NORESIZE  (1U<<TYPE_NORESIZE_SHIFT)

/*************************************************************************/
/* Macros for accessing the fields of an HR...                           */
/* Note that if you change these, you'll need to play with               */
/* html_get_anchor_info()                                                */
/*************************************************************************/
#define HR_HAS_WIDTH(t)   ((t)->cols & 0x01000000)
#define HR_WIDTH(t)       ((t)->cols & 0x00FFFFFF)
#define HR_WIDTH_UNITS(t) ((unsigned)((t)->cols) >> 28)
#define HR_ALIGN(t)       ((unsigned)((t)->type & TYPE_ALIGN_MASK))
#define HR_HAS_SIZE(t)    (HR_SIZE(t) != 0)
#define HR_SIZE(t)        ((t)->size & 0x00FFFFFF)
#define HR_SIZE_UNITS(t)  UNITS_PIXELS
#define HR_NOSHADE(t)     ((t)->type & TYPE_NOSHADE)

#endif /* __tags_h__ */
@


1.1.2.2
log
@Added in Tony Cheal's table code. Various other bug fixes.
@
text
@d208 6
a213 5
#define TR          ((unsigned int)3<<0)  /* <TR>...</TR> IRRELEVANT! (separate data structure) */
#define TD          ((unsigned int)3<<1)  /* <TD>...</TD> IRRELEVANT! */
/*?? what are the conflicts with HEAD BODY and TITLE? */
#define TH          ((unsigned int)1<<30) /* <TH>...</TH> IRRELEVANT! and free */
#define TABLE       ((unsigned int)1<<31) /* <TABLE>...</TABLE> */
d241 4
a244 4
#define ISBODY(p)   ((((p)->type) & TYPE_BODY) != 0)
#define ISHEAD(p)   ((((p)->type) & TYPE_HEAD) != 0)
#define ISFRAMESET(p) ((((p)->type) & TYPE_FRAMESET) != 0)
#define ISNOFRAMES(p) ((((p)->type) & TYPE_NOFRAMES) != 0)
d251 1
a251 1
#define ISBODY(p)   ((((p)->type) & HEAD) == 0)
@

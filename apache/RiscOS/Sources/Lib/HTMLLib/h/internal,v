head	1.15;
access;
symbols
	HTMLLib-0_04:1.15
	HTMLLib-0_03:1.15
	HTMLLib-0_02:1.15
	HTMLLib-0_01:1.14
	ahodgkin_207release:1.12
	ahodgkin_206release:1.6
	ahodgkin_205release:1.3
	ahodgkin_204release:1.3
	ahodgkin_133beta:1.2.2.42
	kbracey_126:1.2.2.35
	kbracey_AW97patch:1.2.2.34
	ahodgkin_AW97:1.2.2.33
	kbracey_PreGordon:1.2.2.1
	Web_bp:1.2
	Web:1.2.0.2
	ARTtmp_merge:1.1.2.4
	ARTtmp:1.1.0.2;
locks; strict;
comment	@# @;


1.15
date	2006.03.13.21.10.18;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.02.15.53.23;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	99.06.04.14.51.25;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	98.09.10.15.54.04;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	98.09.10.12.39.43;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	98.08.29.16.15.50;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	98.08.19.14.05.20;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	98.08.18.08.47.46;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	98.08.07.16.11.46;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	98.06.16.15.36.35;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	98.05.08.11.34.07;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	98.05.07.15.03.54;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	98.02.17.10.42.32;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	97.04.29.15.50.58;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.08.10.27.05;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.2.2.1
date	97.05.30.10.03.15;	author kbracey;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	97.06.23.17.09.19;	author kbracey;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	97.06.24.10.52.10;	author kbracey;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	97.06.24.11.19.32;	author kbracey;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	97.06.26.11.02.51;	author kbracey;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	97.07.02.08.39.44;	author kbracey;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	97.07.02.16.02.03;	author kbracey;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	97.07.02.17.14.52;	author kbracey;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	97.07.03.13.37.26;	author kbracey;	state Exp;
branches;
next	1.2.2.10;

1.2.2.10
date	97.07.03.13.57.53;	author kbracey;	state Exp;
branches;
next	1.2.2.11;

1.2.2.11
date	97.07.04.14.54.12;	author kbracey;	state Exp;
branches;
next	1.2.2.12;

1.2.2.12
date	97.07.04.16.14.36;	author kbracey;	state Exp;
branches;
next	1.2.2.13;

1.2.2.13
date	97.07.10.12.41.17;	author blaughto;	state Exp;
branches;
next	1.2.2.14;

1.2.2.14
date	97.07.24.16.21.06;	author kbracey;	state Exp;
branches;
next	1.2.2.15;

1.2.2.15
date	97.07.25.10.01.24;	author kbracey;	state Exp;
branches;
next	1.2.2.16;

1.2.2.16
date	97.07.28.15.20.00;	author kbracey;	state Exp;
branches;
next	1.2.2.17;

1.2.2.17
date	97.07.30.12.09.37;	author kbracey;	state Exp;
branches;
next	1.2.2.18;

1.2.2.18
date	97.07.31.13.30.06;	author ahodgkin;	state Exp;
branches;
next	1.2.2.19;

1.2.2.19
date	97.08.01.09.00.08;	author kbracey;	state Exp;
branches;
next	1.2.2.20;

1.2.2.20
date	97.08.01.15.06.43;	author kbracey;	state Exp;
branches;
next	1.2.2.21;

1.2.2.21
date	97.08.06.14.28.18;	author ahodgkin;	state Exp;
branches;
next	1.2.2.22;

1.2.2.22
date	97.08.18.16.13.38;	author kbracey;	state Exp;
branches;
next	1.2.2.23;

1.2.2.23
date	97.09.18.14.12.52;	author kbracey;	state Exp;
branches;
next	1.2.2.24;

1.2.2.24
date	97.09.18.15.30.11;	author ahodgkin;	state Exp;
branches;
next	1.2.2.25;

1.2.2.25
date	97.09.30.14.14.15;	author kbracey;	state Exp;
branches;
next	1.2.2.26;

1.2.2.26
date	97.10.03.14.17.11;	author kbracey;	state Exp;
branches;
next	1.2.2.27;

1.2.2.27
date	97.10.03.16.08.44;	author ahodgkin;	state Exp;
branches;
next	1.2.2.28;

1.2.2.28
date	97.10.06.13.50.50;	author kbracey;	state Exp;
branches;
next	1.2.2.29;

1.2.2.29
date	97.10.06.15.17.46;	author ahodgkin;	state Exp;
branches;
next	1.2.2.30;

1.2.2.30
date	97.10.08.12.34.08;	author kbracey;	state Exp;
branches;
next	1.2.2.31;

1.2.2.31
date	97.10.13.10.01.31;	author kbracey;	state Exp;
branches;
next	1.2.2.32;

1.2.2.32
date	97.10.14.13.41.17;	author kbracey;	state Exp;
branches;
next	1.2.2.33;

1.2.2.33
date	97.10.14.14.48.36;	author kbracey;	state Exp;
branches;
next	1.2.2.34;

1.2.2.34
date	97.10.22.14.23.59;	author kbracey;	state Exp;
branches;
next	1.2.2.35;

1.2.2.35
date	97.10.27.18.21.51;	author kbracey;	state Exp;
branches;
next	1.2.2.36;

1.2.2.36
date	97.11.14.15.43.21;	author kbracey;	state Exp;
branches;
next	1.2.2.37;

1.2.2.37
date	97.11.28.15.32.30;	author kbracey;	state Exp;
branches;
next	1.2.2.38;

1.2.2.38
date	98.01.05.12.23.42;	author ahodgkin;	state Exp;
branches;
next	1.2.2.39;

1.2.2.39
date	98.01.07.14.08.14;	author kbracey;	state Exp;
branches;
next	1.2.2.40;

1.2.2.40
date	98.01.07.15.31.19;	author ahodgkin;	state Exp;
branches;
next	1.2.2.41;

1.2.2.41
date	98.01.09.16.31.10;	author ahodgkin;	state Exp;
branches;
next	1.2.2.42;

1.2.2.42
date	98.02.16.11.45.04;	author ahodgkin;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.08.10.27.06;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.04.09.16.44.44;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	97.04.28.14.20.26;	author kbracey;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	97.04.28.17.29.53;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.15
log
@  New build variants; minor API tweaks; const/restrict additions.
Detail:
  Builds Unicode versions as well as non-Unicode versions now, and
  exports them. Required by March 2006 era Browse sources. API tweaks
  including filling in more info fields with border widths. Tightened
  up use of const/restrict in various interfaces.
Admin:
  Tested under Browse, new facilities work as expected. Builds all
  four variants (non-Unicode/Unicode, application/module) from clean
  and returns to clean state with !MkClean.

Version 0.02. Tagged as 'HTMLLib-0_02'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef __html_externs__
#define __html_externs__

#include "kernel.h"

#include "tags.h"
#include "struct.h"
#include "tablestruc.h"

#include "Unicode/encoding.h"

#ifdef USE_NSPRLIB_MALLOC_REGISTRATION

  #include "NSPRLib/ROSallocs.h"

  #define free    rosallocs_free
  #define malloc  rosallocs_malloc
  #define calloc  rosallocs_calloc
  #define realloc rosallocs_realloc

#endif

#ifndef BOOL
#define BOOL  int

// Sometimes people define Bool & TRUE & FALSE...

#ifndef TRUE
#define TRUE  1
#define FALSE 0
#endif
#endif

#ifndef NOT_USED
#define NOT_USED(x) { x=x; }
#endif

/* Maximum OL depth that we keep count */
#define MAX_OL 16

/********************************************************************/
/* A few preprocessor definitions to make life easier.              */
/********************************************************************/
#define START 1
#define END   0

typedef unsigned char byte;

typedef struct
{
    HStream *prev;         /* Previous hstream */
    HStream **prevnextptr; /* Previous hstream's next pointer or head of list ptr */
} table_prev_info;


typedef struct IntAttrInfo {
    unsigned int attr:16;
    unsigned int processed:1;
    unsigned int pleasefree:1; /* data is a pointer and should be freed */
    unsigned int present:1;
    unsigned int miscflag:1;
    union
    {
        char *text;
        unsigned int number;
        int *coords;
        void *raw;
    } data;
} IntAttrInfo;


/***********************************************************************/
/* Structures used internally                                          */
/***********************************************************************/
/* General purpose structure to hold anchor tag information            */
/* All element names are those used in the HTML 2.0 specification.     */
/***********************************************************************/
typedef struct ANCHOR {
    char		*name;
    char		*href;       /* URL of page */
    char		*src;        /* Location of image */
    char                *target;
    int                 *coords;
    #ifdef CUSTOMER_SPECIAL
    char                *onclick;
    #endif
    } AnchorInfo, *AnchorInfoRef;

/***********************************************************************/
/* This is the internal stream structure used by the HTML stream parser*/
/***********************************************************************/
typedef struct COLOUR_INFO ColourInfo, *ColourInfoRef;

typedef struct MAP_STREAM
{
    struct MAP_STREAM *next;
    char *name;
    HStream *stream;
} MapStream;

#ifdef TonyTables
typedef struct TABLE_STUFF {
    HStream *Stream;
    unsigned int memcontext;
} TableContext;
#endif

/*
 * States for the stream parser. Somewhat limited at present :)
 */
typedef enum stream_state
{
    Other,            /* Catch all that covers all the original code */
    Declaration,      /* Inside a <! > */
    Comment,          /* Inside a -- -- inside a <! > */
    Script,           /* Inside a <SCRIPT> </SCRIPT> */
    NoScript,         /* Inside a <NOSCRIPT> </NOSCRIPT> */
    Style             /* Inside a <STYLE> </STYLE> */
}
stream_state;

typedef struct styleinfo
{
  byte bold;    /* used as a counter */
  byte italic;  /* used as a counter */
  byte tt;      /* used as a counter */
  byte nobr;    /* used as a counter */
  byte u;
  byte sub;
  byte sup;
  byte strike;
  byte a;
  byte img;
  byte p;       /* bool */
  byte pre;
  byte dl;
  byte dt;
  byte dd;
  byte ol;
  byte ul;
  byte br;
  byte q;
  byte blockquote;
  byte address;
  byte centre;
  byte right;
  byte select;
  byte li;
  byte oldcentre, oldright;
  unsigned int palign:1;
  unsigned int halign:3;
  unsigned int divalign:3;
  unsigned int h;
  /* Keep track of anchors */
  AnchorInfo *anchor;
  /* Keep track of colour blocks */
  ColourInfo *colour;
  /* Ordered list handling */
  int olcount[MAX_OL];
  char olstyle[MAX_OL];
} styleinfo;

typedef struct STREAM_TOKENS {
  /* The HTML token counters (not all used -> see code! ) */

  /* head */
  byte _stream_title;   /* used as a counter */
  byte _stream_isindex; /* bool */

  /* body */

  /* Stuff that needs to be stacked away on a <TABLE> */
  styleinfo _stream_style;
  #define _stream_bold   _stream_style.bold
  #define _stream_italic _stream_style.italic
  #define _stream_u      _stream_style.u
  #define _stream_nobr   _stream_style.nobr
  #define _stream_sub    _stream_style.sub
  #define _stream_sup    _stream_style.sup
  #define _stream_strike _stream_style.strike
  #define _stream_tt     _stream_style.tt
  #define _stream_a      _stream_style.a
  #define _stream_img    _stream_style.img
  #define _stream_p      _stream_style.p
  #define _stream_pre    _stream_style.pre
  #define _stream_dl     _stream_style.dl
  #define _stream_dt     _stream_style.dt
  #define _stream_dd     _stream_style.dd
  #define _stream_ol     _stream_style.ol
  #define _stream_ul     _stream_style.ul
  #define _stream_br     _stream_style.br
  #define _stream_q      _stream_style.q
  #define _stream_blockquote _stream_style.blockquote
  #define _stream_address _stream_style.address
  #define _stream_centre _stream_style.centre
  #define _stream_right  _stream_style.right
  #define _stream_oldcentre _stream_style.oldcentre
  #define _stream_oldright  _stream_style.oldright
  #define _stream_palign _stream_style.palign
  #define _stream_select _stream_style.select
  #define _stream_textarea _stream_style.textarea
  #define _stream_li     _stream_style.li
  #define _stream_h      _stream_style.h
  #define _stream_halign _stream_style.halign
  #define _stream_divalign _stream_style.divalign
  #define _stream_colour _stream_style.colour
  #define _stream_olcount _stream_style.olcount
  #define _stream_olstyle _stream_style.olstyle
  #define _stream_anchor  _stream_style.anchor
  /* End stuff that need to be stacked */
  byte _stream_form;

  /* doc tags */
#ifdef NEWSPACING
  unsigned int stripleadingspace:1;
  unsigned int trailingspacestripped:1;
  unsigned int lastwaspcdata:1;
  unsigned int lastwaspcdataspace:1;
  unsigned int isendtag:1;
#endif
  unsigned int _stream_noframes:1;
  unsigned int usingframes:1;
  unsigned int usingobjects:1;
  unsigned int usingtables:1;
  unsigned int usingscripts:1;
  unsigned int _stream_map:1;
  byte _stream_frameset;
  byte type; /* 1 = HTML, 2=TEXT currently */
  /* Send a list token with next token? */
  unsigned int send_list;
  /* Hold off processing until we get a */
  /* Keep track of end tokens so we can just send back those we need */
  unsigned char needtosend[TAG_MAX];
  /* How far into the stream are we? */
  unsigned int done;
  unsigned int sizesofar; /* What we have been given in total */
  /* Size of chunk/document */
  unsigned int chunklength;
  unsigned int doclength;
  /* The URL of the document*/
  char *url;
  /* The base target of the document */
  char *target;
  /* Information about <OBJECT> nesting */
  HStream *object;
  /*FormInfo *_stream_forms;*/
  /* The head of the stream structure */
  HStream *Stream;
  /* The last tag generated. */
  HStream *current;
  #ifdef TonyTables
  TableContext   *Tables;                  /* Previous parsing contexts for tables */
  table_stream   *_stream_current_table;   /* this is also an HStream * */
  table_row      *_stream_current_row;
  table_headdata *_stream_current_headdata;
  #endif
  MapStream *maps;
  /* The memory context we are in */
  unsigned int memcontext;
  unsigned int following_start_tag:1;
  unsigned int need_to_send_name:1;
  unsigned int _stream_basefont:3;
  stream_state state;
  int          anglecount;                 /* Count < > pairs inside comments */

  /* Hack hack hack */
  HStream *pendingformfortable;
  int dopendingform;

  /* Stuff for the whole encoding shebang */
  int encoding_no;
  encoding_priority enc_priority;
  unsigned int chars_read;                 /* The number of UCS characters converted so far... */
  Encoding *encoding;
  char *utf_buffer;
  char *utf_ptr;
  int utf_size;
  char *utf_end;
  void (*encoding_callback)(int, void *);
  void *encoding_callback_handle;
  char *(*script_callback)(void *, HStream *, void *);
  void *script_callback_handle;
  void (*base_callback)(void *, const char *, const char *, void*);
  void *base_callback_handle;
  char *insertion;
  char dead;
  char had_frame;

  #ifdef TonyTables
  table_stream *current_table; /* this is also an HStream */
  table_row *current_row;
  table_cell *current_cell;
  #endif

  HStream *special_return;

  static AttrInfo    curattrs[MAX_ATTRS]; /* Attributes explicitly set in the current entity */
  static IntAttrInfo attrlist[MAX_ATTRS]; /* Info about stacked attributes */

} StreamTokens, *StreamTokensRef;

#define ATTR_SET(n) (st->curattrs[n].present)
#define ATTR_STR(n) (st->curattrs[n].pleasefree = 0, st->curattrs[n].data.text)
#define ATTR_STRPEEK(n) (st->curattrs[n].data.text)
#define ATTR_COORDS(n) (st->curattrs[n].pleasefree = 0, st->curattrs[n].data.coords)
#define ATTR_VAL(n) (st->curattrs[n].data.number)

struct COLOUR_INFO {
  struct COLOUR_INFO *next;
  unsigned int colour:24;
  unsigned int colour_valid:1;
  unsigned int stacked_for_link:1;
  signed int size:6;
};

/*************************************************************************/
/* These #defines are used in link parsing. They have been moved out of  */
/* the publicly defined interface. 	    	      	   	     	 */
/*************************************************************************/



/***********************************************************************/
/* From ^.c.attribute                                                  */
/***********************************************************************/
/* This file is a replacement for the dreadful anchor_inf.c.           */
/* It contains routines to parse attributes using the pseudo-DTD in    */
/* html2.h and fill in the curattr array.      	  	      	       */
/***********************************************************************/
extern void __html_process_attributes(StreamTokens *st, Tag *tag, char *html, char *url);
extern void __html_process_embed_attributes(StreamTokens *st, Tag *tag, char *html, HStream *obj);
extern void __html_reset_curattrlist(StreamTokens *st);
extern char *__html_relativise_url(const char *base, const char *link);
extern int __html_tag_length(const char *s);
extern unsigned int __html_convcol(const char *s, int invalid_returns_random);

/***********************************************************************/
/* From ^.c.rules                                                      */
/***********************************************************************/
/* ^.c.rules contains a number of small routines for extracting tags   */
/* and manipulating them where required. "Knows the HTML2 DTD".	       */
/***********************************************************************/
extern int __html_check_tag (const Tag *rules, int max_rules, const char *tag);
extern Tag *__html_find_start_tag_block(char *tag);
extern Tag *__html_find_end_tag_block(char *tag);
extern Tag *__html_find_tag(char **html, int end);

/***********************************************************************/
/* From ^.c.display                                                    */
/***********************************************************************/
/* ^.c.display contains the routines needed prior to displaying a page */
/* ATM this is just the code to strip the spaces, but the code to      */
/* convert the ISO-LATIN-1 entities will also be in here       	       */
/***********************************************************************/
#ifdef NEWSPACING
extern int __html_strip_spaces(char *input, int stripleadingspace, int striptrailingspace);
extern void __html_strip_trailing_spaces(char *input);
#else
extern char *__html_strip_spaces(char *input, int stripleadingcr);
#endif
extern char *__html_strip_lfs(char *input);
extern char *strdup(const char *s1);
extern char *strndup(const char *s1, int size);
extern char *__html_unescape_string(char *input, unsigned int strict);
extern int __html_unnumeric_escape(char ch);
extern void __html_strip_control_codes(char *input);
extern char __html_iso10646_to_latin1(unsigned ch);
extern int  strincmp(const char *string, const char *index, int size);
extern int  stricmp(const char *string, const char *index);
extern char *strnstr(const char *string, const char *index, int size);
char *strinstr(const char *string, const char *index, int size);

/* Need to think about TABs at some stage */
#define CTRL_CODE(c) (c<' ' && c!='\n' && c!='\r')

/***********************************************************************/
/* From ^.c.object                                                     */
/***********************************************************************/
/* ^.c.object contains the routines needed to process the <OBJECT>     */
/* element.                                                            */
/***********************************************************************/
extern HStream *__html_stream_object(StreamTokens *st, char **html, Tag *next_tag);
extern HStream *__html_stream_param(StreamTokens *st, char **html, Tag *next_tag);
extern HStream *__html_construct_param(StreamTokens *st, const char *name, const char *type,
                                       const char *value, paramtype valuetype);
extern void __html_stream_end_object(StreamTokens *st);
extern HStream *__html_stream_embed(StreamTokens *st, char **html, Tag *next_tag);
extern table_prev_info __html_find_current_object(StreamTokens *st, HStream *current);
extern HStream *__html_replace_object(HStream *t);
extern HStream *__html_find_map(MapStream *maps, const char *name);

/***********************************************************************/
/* From ^.c.ol                                                         */
/***********************************************************************/
/* ^.c.ol handles ordered lists                                        */
/***********************************************************************/
extern void __html_construct_ol_text(StreamTokens *st, HStream *);

/***********************************************************************/
/* From ^.c.font                                                       */
/***********************************************************************/
/* ^.c.font contains the routines needed to process the <FONT> tag     */
/***********************************************************************/
extern void add_colour_info(StreamTokens *st, unsigned int col, int *allocate_required);
extern void add_size_info(StreamTokens *st, const char *ptr, int *allocate_required);
extern void fill_in_colour_info(const StreamTokens *st, HStream *hs);
extern void font_tag_closed(StreamTokens *st);

#ifdef USING_OLD_FREE
/***********************************************************************/
/* From ^.c.free - no longer needed I belive                           */
/***********************************************************************/
/* ^.c.free was the initial code to free up memory that was allocated. */
/* These routines were used to free up the stream and tree structures  */
/* before __html_free() existed. There are I believe no longer needed. */
/***********************************************************************/
extern void __html_tree_entry_free(Html *document);
extern void __html_tree_free(Html *document, int depth);
extern void __html_stream_free(HStream *stream);
extern void __html_stream_entry_free(HStream *stream);
#endif

/***********************************************************************/
/* From ^.c.malloc                                                     */
/***********************************************************************/
/* ^.c.malloc is the general purpose front end to malloc which keeps   */
/* account of the context which a set of structures exists in. When    */
/* a call to __html_free() is made, all memory in the same context as  */
/* the pointer passed can be freeded if the second argument is TRUE.   */
/* NOTE: these functions put a wrapper around the memory allocated so  */
/* they cant be used in conjunction with normal free() and malloc().   */
/* The code uses calloc() internally to ensure memory is initialised.  */
/***********************************************************************/
extern char *__html_malloc(size_t bytes, size_t size);
extern void __html_free(void *ptr, int free_all);
extern unsigned int __html_return_context(void *block);
extern unsigned int __html_memory_init(void);
extern void __html_memory_list(void);
extern void __html_set_memory_context(unsigned int);
extern void __html_set_memory_context_from_block(const void * block);

#if 0
/***********************************************************************/
/* From ^.c.stream                                                     */
/***********************************************************************/
/* ^.c.stream contains a small streamer used to turn a HTML document   */
/* into a stream compatible with a particular 3rd party GUI.           */
/***********************************************************************/
extern unsigned int __html_interest_tags;
extern unsigned int __html_indent_tags;
extern HStream *__html_make_stream(Html *doc);
#endif

/***********************************************************************/
/* From ^.c.new_stream                                                 */
/***********************************************************************/
/* ^.c.new_stream contains a small streamer used to turn a HTML        */
/* document into a stream compatible with a particular 3rd party GUI.  */
/***********************************************************************/
extern byte __html_done_for_now;
extern HStream *__html_stream_parse(StreamTokens *st,char **html, char *url, int size, HStream *prevhs);
extern StreamTokens *__html_stream_init(void);
extern void __html_style_init(styleinfo *s);
extern HStream *__html_return_text_token(StreamTokens *st, char *doc, size_t size);
extern HStream *HStreamalloc(StreamTokens *st, tag_no);
extern unsigned int __html_stream_style(StreamTokens *st);
extern unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start);
extern unsigned int __html_stream_indent(StreamTokens *st);

/***********************************************************************/
/* From ^.c.HTTPSupport                                                */
/***********************************************************************/
/* HTTPSupport contains a number of functions to support the parsing   */
/* of HTTP headers, work out file content type, and strip the HTTP     */
/* headers ready to pass to an external application or the main parser */
/***********************************************************************/
extern int __http_strip_headers(char *stream, size_t stream_len);
extern unsigned int __html_identify(char *base_url, char *stream, size_t stream_len, char done,
                                    char **url, int *file_type, int *canparse, int *encoding);
extern char *__http_escape_string(char *string);

/***********************************************************************/
/* From ^.c.URLModule                                                  */
/***********************************************************************/
/* URLModule contains a number of veneer functions to support parsing  */
/* and canonicalisation of URLs.                                       */
/***********************************************************************/

struct URL_ptrs {
  char *full;
  char *scheme;
  char *host;
  char *port;
  char *user;
  char *password;
  char *account;
  char *path;
  char *query;
  char *fragment;
  char *minimal;
};

struct URL_lengths {
  size_t  full;
  size_t  scheme;
  size_t  host;
  size_t  port;
  size_t  user;
  size_t  password;
  size_t  account;
  size_t  path;
  size_t  query;
  size_t  fragment;
  size_t  minimal;
};

typedef union URL {
  struct URL_lengths lengths;
  size_t len[sizeof(struct URL_ptrs)/sizeof(size_t)];
  struct URL_ptrs data;
  char * field[sizeof(struct URL_ptrs)/sizeof(size_t)];
} URL;

enum {
  urlfield_FULL,
  urlfield_SCHEME,
  urlfield_HOST,
  urlfield_PORT,
  urlfield_USER,
  urlfield_PASSWORD,
  urlfield_ACCOUNT,
  urlfield_PATH,
  urlfield_QUERY,
  urlfield_FRAGMENT,
  urlfield_MINIMAL
};

enum {
  url_parseurl_buffer_lengths,
  url_parseurl_return_data,
  url_parseurl_compose_from_components,
  url_parseurl_quick_resolve
};

#define URL_fields   ((sizeof(URL)/sizeof(size_t)))
#define URL_ParseURL (0x83E07)

extern char *__html_url_canonicalise_url(int flags, const char*url, const char *rel);

extern _kernel_oserror *__html_url_find_lengths(int flags, const char *url, const char *rel, URL *u);
extern _kernel_oserror *__html_url_find_data(int flags, const char *url, const char *rel, URL *u);
extern _kernel_oserror *__html_url_compose_from_components(int flags, const char *url, const char *rel, URL *u);

/***********************************************************************/
/* This is just needed ok' :)                                          */
/***********************************************************************/
#include "ctype.h"

/***********************************************************************/
/* Useful macro's                                                      */
/***********************************************************************/
/* This turns a string into upper case. NOTE: it is destructive. That  */
/* has caught me out before. The best use is to strdup the string and  */
/* then upper_case() it. You will need to do this in two steps.	       */
/***********************************************************************/
#define UPPER_CASE(x) { char *y; y=x; while (*y != '\0') { \
		        *y=toupper(*y); y++; } }
#define LOWER_CASE(x) { char *y; y=x; while (*y != '\0') { \
		        *y=tolower(*y); y++; } }

#endif /* __html_externs__ */
@


1.14
log
@  Handle font colours inside anchors.
Detail:
  For code that changes font before the anchor, the link should be shown
  at link colour in a browser. For code that changes after, the link should
  be shown according to the colour specifier. It's the difference between
  <a href...><font color...>Link</font></a> and
  <font color...><a href...>Link</a></font>. Browse could never tell the
  difference previously so always used the link colour, but lots of sites
  these days seem to have a background colour that clashes with the link
  colour and use <font> tags to sort it out (ick). The solution is to stack
  the existing font settings on <a> and unstack on </a> (if there are any).
  Claimed a bit in COLOUR_INFO (internal.h) from the 'size' field to record
  if this was done - otherwise every anchor would have a stacked colour
  attached which is pretty inefficient.
Admin:
  Tested with a debug Browse and "production" Phoenix build, ensured the
  stack in/stack out behaviour is correct with TML debug in the library.
  Requires a Redraw.c in the browser from 02-Mar-2000 (15:30pm) or later.
@
text
@d454 1
a454 1
extern void __html_set_memory_context_from_block(void *block);
@


1.13
log
@Various fixes. Attribute parser would hang when faced with '...VALUE=>'.
Entites which were a substring match of other entities in name (possible
in HTML 4 but not previously) would get mismatched in HTML (the shorter
always being picked and extra letters left over getting spat out to the
page). Solved by having a seperate try-first table of substring matching
entities.

New feature (sort of). Entities in URLs were never escaped as the
existing relaxed entity parser would often mangle CGI-style URLs. There
is now a strict unescaping mode used for URLs which seems to sort out
various sites where this was a problem.

Makefile exports to 'Lib$Dir' rather than 'HTMLLib:' to fit in with
current build environments.
@
text
@d326 2
a327 1
  signed int size:7;
@


1.12
log
@Euro sign mapping added to display.c's ISO10646 -> Acorn Extended Latin-1
transformation table. HtmlParse can be told whether or not it supports
JavaScript (if so, script callback function is called and <NOSCRIPT> contents
are ignored; else script callback function is not called and <NOSCRIPT> is
parsed, with <SCRIPT> contents just passed through). In veneers.c, names of
parameters to HtmlParse changed to match those in api.h.
@
text
@d377 1
a377 1
extern char *__html_unescape_string(char *input);
@


1.11
log
@If USE_NSPRLIB_MALLOC_REGISTRATION is defined, will assume an NSPRLib built
with the same option is going to be present in the final client application.
Redefines free, malloc, calloc and realloc to use the NSPRLib reregisterable
equivalents.
@
text
@d239 1
@


1.10
log
@Shouldn't crash when it hits </option> in <select> lists now (oops).
Fixed buffer juggling done then <script> callback function returns data
to be written into the document; utf_end wasn't being correctly updated.
NOSCRIPT is now dealt with in the same way as STYLE - passed through as
raw text, but won't be parsed.
@
text
@d26 1
a26 1
#ifdef USE_MALLOC_REPLACEMENT
d28 1
a28 1
  /* MemLib stuff */
d30 4
a33 11
  #define os_error _kernel_oserror

  #define malloc(size)       MemHeap_malloc(size)
  #define free(ptr)          MemHeap_free(ptr)
  #define realloc(ptr, size) MemHeap_realloc(ptr, size)
  #define calloc(n, size)    MemHeap_calloc(n, size)

  extern void * MemHeap_malloc  (size_t size);
  extern void   MemHeap_free    (void * ptr);
  extern void * MemHeap_realloc (void * ptr, size_t size);
  extern void * MemHeap_calloc  (size_t n, size_t size);
@


1.9
log
@Anchor information should be stacked and popped going in/out of table cells,
as with font info; moved _stream_anchor field from StreamTokens to styleinfo
structure. _stream_table_anc field removed from StreamTokens (it was unused).
@
text
@d135 2
a136 2
    Declaration,      /* Inside a <! >*/
    Comment,          /* Inside a -- -- inside a <! >*/
d138 1
@


1.8
log
@Daft bug in <option> element handling fixed. <script> element is no
longer block level, to try and avoid white space problems with calls
to document.write(). MemLib stuff in internal.h can be switched on by
cleaning the build, defining USE_MALLOC_REPLACEMENT on the CC command
line and rebuilding.
@
text
@d174 2
d229 1
a264 2
  /* Keep track of anchors */
  AnchorInfo *_stream_anchor;
a265 1
  AnchorInfo *_stream_table_anc;
@


1.7
log
@Added externally visible function HtmlParseColour, which maps to
__html_convcol internally. Extended API to the latter so that it
either does the "return random colour if I don't understand the
string" trick, or returns a value telling the caller it didn't
know what was going on. Needed all of this for JavaScript support
in Browse.
@
text
@d26 17
a42 13
// /* MemLib stuff */
//
// #define os_error _kernel_oserror
//
// #define malloc(size)       MemHeap_malloc(size)
// #define free(ptr)          MemHeap_free(ptr)
// #define realloc(ptr, size) MemHeap_realloc(ptr, size)
// #define calloc(n, size)    MemHeap_calloc(n, size)
//
// extern void * MemHeap_malloc  (size_t size);
// extern void   MemHeap_free    (void * ptr);
// extern void * MemHeap_realloc (void * ptr, size_t size);
// extern void * MemHeap_calloc  (size_t n, size_t size);
@


1.6
log
@Multiple text tags inside one <OPTION> container are "glued together",
so HTML such as '<OPTION>Some <I>italicised</I> entries' will generate
meaningful menu entries.

<PRE> and <Hn> elements now cancel <P ALIN="...">, whereas they did
not before. This is special-cased for those elements, based on the
code already in place for <DIV>.
@
text
@d26 14
d349 1
@


1.5
log
@Can now cope with < or > characters in quoted attributes
@
text
@d284 2
@


1.4
log
@Removed unused function HTTPEscapeString.
Added SCRIPT element callback function with provision for source insertion.
@
text
@d332 1
@


1.3
log
@Web branch merged
@
text
@d282 3
@


1.2
log
@Merged in ARTtmp_merge
@
text
@a14 77
/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/h/Attic/internal,v $
 *
 * $Log: internal,v $
 * Revision 1.1.2.4  1997/04/28 17:29:53  kbracey
 * Made forms work across tables.
 *
 * Revision 1.1.2.3  1997/04/28 14:20:26  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
 * Revision 1.1.2.2  1997/04/09 16:44:44  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:27:06  kbracey
 * Initial revision
 *
 * Revision 1.4  95/10/31  13:16:09  pwain
 * Changed a few more definitions
 *
 * Revision 1.3  95/10/30  10:24:40  pwain
 * Reformatted, sorted and commented declarations.
 *
 * Revision 1.2  95/10/17  14:03:10  pwain
 * Added __html_memory_init() and changed number of
 * parameters to __html_free() to include free_all
 * for mass memory freeing if permitted.
 *
 * Revision 1.1  95/10/12  12:49:21  pwain
 * Initial revision
 *
 *
 * --- Original Log Info ---
 *
 * $Version: networking $
 *
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/h/Attic/internal,v $
 *
 * $Log: internal,v $
 * Revision 1.1.2.4  1997/04/28 17:29:53  kbracey
 * Made forms work across tables.
 *
 * Revision 1.1.2.3  1997/04/28 14:20:26  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
 * Revision 1.1.2.2  1997/04/09 16:44:44  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:27:06  kbracey
 * Initial revision
 *
 * Revision 1.4  95/10/31  13:16:09  pwain
 * Changed a few more definitions
 *
 * Revision 1.3  95/10/30  10:24:40  pwain
 * Reformatted, sorted and commented declarations.
 *
 * Revision 1.2  95/10/17  14:03:10  pwain
 * Added __html_memory_init() and changed number of
 * parameters to __html_free() to include free_all
 * for mass memory freeing if permitted.
 *
 * Revision 1.1  95/10/12  12:49:21  pwain
 * Initial revision
 *
 * Revision 1.2  95/09/26  11:44:10  pwain
 * Added __html_check_tag() definition.
 *
 * Revision 1.1  95/09/08  10:06:16  pwain
 * Initial revision
 *
 *
 */
d18 2
d24 2
d37 12
d52 22
a81 6
    /******/
/*  char		*rel;
    char		*rev;
    char		*urn;
    char		*title;
    char		*methods;  */
d86 3
a88 22
    char		*alt;	     /* Text for image */
    char 		*action;     /* Place to send form - same as HREF? */
    char 		*enctype;    /* Ignored */
    char 		*value;      /* Of input field */
    unsigned int	maxlength;   /* of input field */
    unsigned int	size;	     /* Of on-screen box */
    unsigned int	rows;	     /* Text area size */
    unsigned int	cols;	     /* text area size */
    unsigned int        spacing;     /* frame, frameset spacing */
    unsigned int        type;	     /* INPUT formats (0-7), frameset types etc. */
    byte	        method;	     /* Method to use - see HTTP module */
    byte		ismap;	     /* ISMAP on images */
    byte		alignment;   /* For images (0-7) */
    byte                valign;      /* For tables (0-7) */
    byte                checked;     /* For checkboxes */
    byte		multiple;    /* For Radio buttons */
    byte		selected;    /* For menus etc */
    byte		border;	     /* Hopefully borderwidth <= 255 */
    byte                colspan;     /* Tables support */
    byte                rowspan;     /* Tables support */
    #ifdef TonyTables
    int                 width;
a89 3
    unsigned int        noshade:1;   /* NOSHADE on <HR>s */
    unsigned int        noresize:1;  /* NORESIZE on <FRAME>s */
    unsigned int        scrolling:2; /* SCROLLING on <FRAME>s */
d97 7
d111 13
d129 5
a142 1
  byte dir;
d144 1
d148 1
a148 1
  byte comment;
a149 1
  byte textarea;
d151 4
d158 3
d176 5
a190 1
  #define _stream_dir    _stream_style.dir
d192 1
d195 5
a199 2
  #define _stream_center _stream_style.centre
  #define _stream_comment _stream_style.comment
d204 2
d207 2
a212 2
  unsigned int _stream_body:1;
  unsigned int _stream_head:1;
a219 1
#ifdef FRAMESUPPORT
d222 3
a225 1
#endif
a226 1
  byte  _stream_table;
d228 1
a228 5
  byte send_list;
  /* Cope with another Netscrape-ism */
#ifndef NEWSPACING
  byte stripleadingcr;
#endif
d231 1
a231 1
  unsigned int needtosend;
d242 2
d246 1
a246 1
  AnchorInfo *_stream_forms;
d250 2
d258 1
d262 1
d264 32
d298 6
d310 1
a314 5
/*
 * These are the attributes used by links etc. They are in a second
 * status word effectivly.
 */
#ifdef FRAMESUPPORT
a315 16
enum _anchor_tags {
  REL,		REV,		URN,		_TITLE,
  METHODS,	HREF,		NAME,		SRC,
  BACKGROUND = SRC,
  ALT,		ALIGN,		ISMAP,		ACTION,
  METHOD, 	ENCTYPE,	TYPE,		MAXLENGTH,
  SIZE,		VALUE,		CHECKED,	MULTIPLE,
  SELECTED,	COLS,		ROWS,		BORDER,
  VALIGN,	COLSPAN,	ROWSPAN,	BGCOL,
  FGCOL,	ALINK,		VLINK,		COLOR,
  FONTSIZE,	BASEFONTSIZE,	HRWIDTH,	NOSHADE,
  FRAMEBORDER,  BORDERCOLOR,    MARGINWIDTH,    MARGINHEIGHT,
  SCROLLING,    NORESIZE,       TARGET,         CELLSPACING,
  CELLPADDING,  NOWRAP,         CELLWIDTH,      CELLHEIGHT,
  TABLEWIDTH
};
a316 1
#else
a317 76
#define REL			((unsigned int)1<<0)
#define REV			((unsigned int)1<<1)
#define URN			((unsigned int)1<<2)
#define _TITLE			((unsigned int)1<<3)
#define METHODS			((unsigned int)1<<4)
#define HREF			((unsigned int)1<<5)
#define NAME			((unsigned int)1<<6)
#define SRC			((unsigned int)1<<7)
#define ALT			((unsigned int)1<<8)
#define ALIGN			((unsigned int)1<<9)
#define ISMAP			((unsigned int)1<<10)
#define BACKGROUND              SRC

/*
 * Form bits
 */
#define ACTION                  ((unsigned int)1<<11)
#define METHOD			((unsigned int)1<<12)
#define ENCTYPE			((unsigned int)1<<13)
#define TYPE			((unsigned int)1<<14)
#define MAXLENGTH		((unsigned int)1<<15)
#define SIZE			((unsigned int)1<<16)
#define VALUE			((unsigned int)1<<17)
#define CHECKED			((unsigned int)1<<18)
#define MULTIPLE		((unsigned int)1<<19)
#define SELECTED		((unsigned int)1<<20)
#define COLS			((unsigned int)1<<21)
#define ROWS			((unsigned int)1<<22)
#define BORDER			((unsigned int)1<<23)

/* Tables stuff */
#define VALIGN                  ((unsigned int)1<<24)
#define COLSPAN                 ((unsigned int)1<<25)
#define ROWSPAN                 ((unsigned int)1<<26)

/* Colours stuff */
#define BGCOL                   ((unsigned int)1<<27)
#define FGCOL                   ((unsigned int)1<<28)
#define ALINK                   ((unsigned int)1<<29)
#define VLINK                   ((unsigned int)1<<30)

/* Values for <FONT> tags, purely internal */
#define COLOR                   17
#define FONTSIZE                18
#define BASEFONTSIZE            19

/* And HR... */
#define HRWIDTH                 20
#define NOSHADE                 21


#endif

/* The values for align can just be normal unsigned ints not bits set... */
#define TOP			(1)
#define RIGHT			(2)
#define	BOTTOM			(3)
#define LEFT			(4)
#define MIDDLE			(5)

/* The values for INPUT TYPE=... */
#define TEXT  	  		(0)  /* Default case */
#define PASSWORD		(1)  /* Gets hidden */
#define CHECKBOX		(2)  /* Square thing */
#define RADIO			(3)  /* Round thing */
#define IMAGE			(4)  /* Uh-oh! */
#define HIDDEN			(5)  /* Not shown in UI */
#define SUBMIT			(6)  /* Press to send */
#define RESET			(7)  /* Got it wrong? */

/***********************************************************************/
/* From ^.c.parse                                                      */
/***********************************************************************/
/* This file is a hang over from the tree parser; it just contains the */
/* generic code to strip stuff out of anchors and store their value in */
/* and AnchorInfo struct.      	      	      	  	      	       */
d319 10
a328 1
extern AnchorInfo *__html_get_anchor_info(StreamTokens *st, char **anchor_info, Tag tag);
d337 3
a339 3
extern Tag __html_find_start_tag_block(char *tag);
extern Tag __html_find_end_tag_block(char *tag);
extern Tag __html_find_tag(char **html, int end);
d355 2
a356 2
extern char *strdup(char *s1);
extern char *strndup(char *s1, int size);
d360 1
d362 1
d370 23
d429 1
d433 1
d457 5
a461 1
extern HStream *__html_return_text_token(char *doc, size_t size);
d471 2
a472 1
extern unsigned int __html_identify(char *stream, size_t stream_len, char done, char **url, int *file_type, int *canparse);
d476 72
d561 2
a562 7
/***********************************************************************/
/* Small macro to do lots of tests in one line of code. This will tell */
/* You if the return value from withing any of the TAG finding fn's is */
/* the NULL_TAG as defined in h.tags	       	       	       	       */
/***********************************************************************/
#define NULL_TAG(x) ( (x.start_tag==NULL) && \
		      (x.tag==0) && (x.rule == 0 ) && (x.anchors == 0))
@


1.2.2.1
log
@Added HtmlMalloc and HtmlFree client calls
@
text
@d19 1
a19 1
 * $Source: /projects2/renaissa/cvsroot/Projects/Web/HTMLLib/h/internal,v $
a21 3
 * Revision 1.2  1997/04/29 15:50:58  kbracey
 * Merged in ARTtmp_merge
 *
d54 1
a54 1
 * $Source: /projects2/renaissa/cvsroot/Projects/Web/HTMLLib/h/internal,v $
a56 3
 * Revision 1.2  1997/04/29 15:50:58  kbracey
 * Merged in ARTtmp_merge
 *
a480 1
extern void __html_set_memory_context_from_block(void *block);
@


1.2.2.2
log
@Now handles tables with a <TR> missing in the middle, as well as at the start.
@
text
@a21 3
 * Revision 1.2.2.1  1997/05/30 10:03:15  kbracey
 * Added HtmlMalloc and HtmlFree client calls
 *
a59 3
 * Revision 1.2.2.1  1997/05/30 10:03:15  kbracey
 * Added HtmlMalloc and HtmlFree client calls
 *
a288 1
  unsigned int awaiting_tr:1;
@


1.2.2.3
log
@A couple more missing <TR> fixes - now copes with nested tables.
Added inheritance of ALIGN and BGCOLOR settings from <TR>s and <TABLE>s.
@
text
@d295 1
@


1.2.2.4
log
@Removed some compilation warnings. Fixed handling of vanilla <FRAME> tags
(ie ones with no attributes).
@
text
@a121 3
#ifndef NOT_USED
#define NOT_USED(x) { x=x; }
#endif
@


1.2.2.5
log
@Improved comment handling.
Started work on SUB, SUP, U and STRIKE support.
@
text
@d15 89
a185 11
/*
 * States for the stream parser. Somewhat limited at present :)
 */
typedef enum stream_state
{
    Other,            /* Catch all that covers all the original code */
    Declaration,      /* Inside a <! */
    Comment           /* Inside a -- inside a <! */
}
stream_state;

a190 4
  byte u;
  byte sub;
  byte sup;
  byte strike;
d205 1
a226 4
  #define _stream_u      _stream_style.u
  #define _stream_sub    _stream_style.sub
  #define _stream_sup    _stream_style.sup
  #define _stream_strike _stream_style.strike
d242 1
a302 1
  stream_state state;
@


1.2.2.6
log
@Added previous pointers to table rows and cells.
Implemented skipping of <STYLE> and <SCRIPT>.
@
text
@d103 2
a104 4
    Declaration,      /* Inside a <! >*/
    Comment,          /* Inside a -- -- inside a <! >*/
    Script,           /* Inside a <SCRIPT> </SCRIPT> */
    Style             /* Inside a <STYLE> </STYLE> */
@


1.2.2.7
log
@Removed dependence on <HEAD> and <BODY>
@
text
@d182 2
@


1.2.2.8
log
@Fixed some extra whitespace that had crept into the parser output
@
text
@d481 2
a482 1
#define NULL_TAG(x) ((x.start_tag==NULL))
@


1.2.2.9
log
@Improved <STYLE> and <SCRIPT> skipping
Stopped multiple <DT>s with no <DD>s being concatenated
Fixed a few null pointer dereferences
Corrected definition of st->send_list
@
text
@d197 5
a201 1
  unsigned int send_list;
@


1.2.2.10
log
@Stopped the library passing Tag structures around by value (bleuch!)
@
text
@d342 1
a342 1
extern AnchorInfo *__html_get_anchor_info(StreamTokens *st, char **anchor_info, Tag *tag);
d351 3
a353 3
extern Tag *__html_find_start_tag_block(char *tag);
extern Tag *__html_find_end_tag_block(char *tag);
extern Tag *__html_find_tag(char **html, int end);
d472 6
@


1.2.2.11
log
@Made to deal with an empty <A NAME="fred"></A>
@
text
@a225 1
  unsigned int need_to_send_name:1;
@


1.2.2.12
log
@Made ALIGN=MIDDLE mean ALIGN=CENTRE in horizontal only contexts
@
text
@d261 1
a261 1
  TABLEWIDTH,   HALIGN
@


1.2.2.13
log
@Added HtmlInit function to explicitly initialse some static data so that a variant suitable for use by modules can be made
@
text
@a354 1
extern void __html_rules_init (void);
@


1.2.2.14
log
@Totally redesigned attribute parsing code.
Started new API for accessing attributes - only implemented for BODY.
Added <BODY alink onload onunload> support.
@
text
@a39 48
enum _anchor_tags {
  REL,		REV,		URN,		_TITLE,
  METHODS,	HREF,		NAME,		SRC,
  BACKGROUND = SRC,             WIDTH,          HEIGHT,
  ALT,		ALIGN,		ISMAP,		ACTION,
  METHOD, 	ENCTYPE,	TYPE,		MAXLENGTH,
  SIZE,		VALUE,		CHECKED,	MULTIPLE,
  SELECTED,	COLS,		ROWS,		BORDER,
  VALIGN,	COLSPAN,	ROWSPAN,	BGCOL,
  FGCOL,        LINKCOL,	VLINK,		ALINK,
  COLOUR,       FONTSIZE,	BASEFONTSIZE,	NOSHADE,
  FRAMEBORDER,  BORDERCOLOUR,   MARGINWIDTH,    MARGINHEIGHT,
  SCROLLING,    NORESIZE,       TARGET,         CELLSPACING,
  CELLPADDING,  NOWRAP,
  HALIGN,

  /* Intrinsic events */
  ONLOAD,       ONUNLOAD,       ONCLICK,        ONDBLCLICK,
  ONMOUSEDOWN,  ONMOUSEUP,      ONMOUSEOVER,    ONMOUSEMOVE,
  ONMOUSEOUT,   ONFOCUS,        ONBLUR,         ONKEYPRESS,
  ONKEYDOWN,    ONKEYUP,        ONSUBMIT,       ONRESET,
  ONSELECT,     ONCHANGE,

  ACCESSKEY,    CHARSET,        COORDS,         SHAPE,
  TABINDEX,     HSPACE,         VSPACE,         USEMAP,
  MEDIA,        DIRECTION,      LANG,           CLASS,
  ID,           CONTENT,        HTTP_EQUIV,     SCHEME,
  ACCEPT_CHARSET, DISABLED,     READONLY,       FACE,
  TABLEFRAME,   TABLERULES,     CHAR,           CHAROFF,

  MAX_ATTRS
};

typedef struct IntAttrInfo {
    unsigned int attr:16;
    unsigned int processed:1;
    unsigned int pleasefree:1; /* data is a pointer and should be freed */
    unsigned int present:1;
    unsigned int miscflag:1;
    union
    {
        char *text;
        unsigned int number;
        void *raw;
    } data;
} IntAttrInfo;


d57 20
a76 20
    //char		*alt;	     /* Text for image */
    //char 		*action;     /* Place to send form - same as HREF? */
    //char 		*enctype;    /* Ignored */
    //char 		*value;      /* Of input field */
    //unsigned int	maxlength;   /* of input field */
    //unsigned int	size;	     /* Of on-screen box */
    //unsigned int	rows;	     /* Text area size */
    //unsigned int	cols;	     /* text area size */
    //unsigned int        spacing;     /* frame, frameset spacing */
    //unsigned int        type;	     /* INPUT formats (0-7), frameset types etc. */
    //byte	        method;	     /* Method to use - see HTTP module */
    //byte		ismap;	     /* ISMAP on images */
    //byte		alignment;   /* For images (0-7) */
    //byte                valign;      /* For tables (0-7) */
    //byte                checked;     /* For checkboxes */
    //byte		multiple;    /* For Radio buttons */
    //byte		selected;    /* For menus etc */
    //byte		border;	     /* Hopefully borderwidth <= 255 */
    //byte                colspan;     /* Tables support */
    //byte                rowspan;     /* Tables support */
d78 1
a78 1
    //int                 width;
d80 3
a82 3
    //unsigned int        noshade:1;   /* NOSHADE on <HR>s */
    //unsigned int        noresize:1;  /* NORESIZE on <FRAME>s */
    //unsigned int        scrolling:2; /* SCROLLING on <FRAME>s */
d128 1
d168 1
a180 5
  /* Form bits */
  unsigned int form_method:8;
  unsigned int form_disabled:1;
  unsigned int form_selected:1;

d213 1
a213 1
  /*FormInfo *_stream_forms;*/
a228 4

  static AttrInfo    curattrs[MAX_ATTRS]; /* Attributes explicitly set in the current entity */
  static IntAttrInfo attrlist[MAX_ATTRS]; /* Info about stacked attributes */

a230 5
#define ATTR_SET(n) (st->curattrs[n].present)
#define ATTR_STR(n) (st->curattrs[n].pleasefree = 0, st->curattrs[n].data.text)
#define ATTR_STRPEEK(n) (st->curattrs[n].data.text)
#define ATTR_VAL(n) (st->curattrs[n].data.number)

d241 37
d279 39
d337 1
a337 1
/* From ^.c.attribute                                                  */
d339 3
a341 3
/* This file is a replacement for the dreadful anchor_inf.c.           */
/* It contains routines to parse attributes using the pseudo-DTD in    */
/* html2.h and fill in the curattr array.      	  	      	       */
d343 1
a343 2
extern void __html_process_attributes(StreamTokens *st, Tag *tag, char *html, char *url);
extern void __html_reset_curattrlist(StreamTokens *st);
a473 2
#define LOWER_CASE(x) { char *y; y=x; while (*y != '\0') { \
		        *y=tolower(*y); y++; } }
@


1.2.2.15
log
@Added new external call HtmlRelativiseURL, and added support for hex entities.
@
text
@a328 1
extern char *__html_relativise_url(const char *base, const char *link);
d356 2
a357 2
extern char *strdup(const char *s1);
extern char *strndup(const char *s1, int size);
@


1.2.2.16
log
@SCRIPT and <A onclick> handling, hopefully
@
text
@d40 33
d95 6
d105 22
a126 2
    #ifdef CUSTOMER_SPECIAL
    char                *onclick;
d128 3
d240 1
d244 1
@


1.2.2.17
log
@Redid handling of FORM tags to use an elementinfo structure.
@
text
@d166 1
@


1.2.2.18
log
@Added HtmlReturnContext (__html_return_context) to get the context of a
block of memory (e.g. an HStream structure). This allows clients to check
if some particular block belongs to a stream that is about to be freed,
say, and take appropriate action before the freeing. Merged in a few
changes by Kevin Bracey to help with vertical white space problems,
mostly involving SCRIPT tags - there was also a bug in BASE which didn't
check for an HREF before trying to read the attributes value, so broken
HTML like <BASE FONT=1> would stop all subsequent HREFs from being
correctly relativised.
@
text
@a340 1
extern unsigned int __html_return_context(void *block);
@


1.2.2.19
log
@Revised INPUT handling - made INPUT type=image work
@
text
@d245 10
@


1.2.2.20
log
@Fixed &#160;, fixed option selection, changed GOT_MORE flag
@
text
@d165 4
@


1.2.2.21
log
@Removed the GetContext stuff (blimey, that was short lived) - a much better
approach to relativise broken redirections inside the header parsing
routines has been taken (see HtmlIdentify).
@
text
@d365 1
a365 1
extern unsigned int __html_identify(char *base_url, char *stream, size_t stream_len, char done, char **url, int *file_type, int *canparse);
@


1.2.2.22
log
@Did align on <P> and right align on tables.
Fixed problem with the final ">" of "</SCRIPT>" ending up in the title.
Fixed problem of HtmlGetStream returning a pointer to the wrong parent table.
Added SUB and SUP.
@
text
@a117 1
  byte right;
d119 1
a120 2
  byte oldcentre, oldright;
  unsigned int palign:1;
d156 1
a156 5
  #define _stream_centre _stream_style.centre
  #define _stream_right  _stream_style.right
  #define _stream_oldcentre _stream_style.oldcentre
  #define _stream_oldright  _stream_style.oldright
  #define _stream_palign _stream_style.palign
d182 1
a182 1
  unsigned char needtosend[TAG_MAX];
d234 6
@


1.2.2.23
log
@Encoding support added (yippee). #define UNIFONT to get UTF-8 output,
otherwise Latin-1 output is provided. Lots of encoding files...
@
text
@a21 2
#include "encoding.h"

a217 13
  /* Stuff for the whole encoding shebang */
  int encoding_no;
  encoding_priority enc_priority;
  unsigned int chars_read;                 /* The number of UCS characters converted so far... */
  Encoding *encoding;
  char *utf_buffer;
  char *utf_ptr;
  int utf_size;
  char *utf_end;
  void (*encoding_callback)(int, void *);
  void *encoding_callback_handle;
  char dead;

a282 1
extern char __html_iso10646_to_latin1(unsigned ch);
d365 1
a365 2
extern unsigned int __html_identify(char *base_url, char *stream, size_t stream_len, char done,
                                    char **url, int *file_type, int *canparse, int *encoding);
@


1.2.2.24
log
@Altered comment handling. It expects them to start with '<!', end with '>',
and there may be '<' '>' pairs inside but they must be correctly matched.
If there are too many '>'s, some of the commented out region will be visible
on the page. The other way round - you'll probably have a blank page ;-)
@
text
@a218 1
  int          anglecount;                 /* Count < > pairs inside comments */
@


1.2.2.25
log
@Turned off CUSTOMER_SPECIAL.
Changed encoding tables to use FFFF as a null value instead of FFFD.
Added OBJECT support (more testing required - PARAM not yet done).
Added AREA support (commented out - MAP not yet done). They come out
looking like <A></A> elements.
Souped up mapping to Latin-1 (added lossy tables for Latin Extended
Additional, CJK Punctuation and Fullwidth forms).
Added support for <H1 align=...>
Stripped some superfluous whitespace caused by linefeeds.
Fixed missing linebreak in "<DT>One<DT>Two" by turning the second DT into
a BR.
Removed now unnecessary free(malloc(16384)) bodge.
Put in CJK code even if UNIFONT not defined (hey - why not?).
Added code to take direct pointer to table rather than loading it if
it's in ResourceFS.
Added support for encoding "x-acorn-latin1".
Ensured correct handling of OPTIONs when UNIFONT not defined.
@
text
@a38 6
/********************************************************************/
/* A few preprocessor definitions to make life easier.              */
/********************************************************************/
#define START 1
#define END   0

a40 6
typedef struct
{
    HStream *prev;         /* Previous hstream */
    HStream **prevnextptr; /* Previous hstream's next pointer or head of list ptr */
} table_prev_info;

a51 1
        int *coords;
a67 1
    int                 *coords;
a124 1
  unsigned int halign:3;
a168 1
  #define _stream_halign _stream_style.halign
a200 2
  /* Information about <OBJECT> nesting */
  HStream *object;
a206 2
  /* The last tag generated. */
  HStream *current;
a241 1
#define ATTR_COORDS(n) (st->curattrs[n].pleasefree = 0, st->curattrs[n].data.coords)
a249 1

a307 10
/* From ^.c.object                                                     */
/***********************************************************************/
/* ^.c.object contains the routines needed to process the <OBJECT>     */
/* element.                                                            */
/***********************************************************************/
extern HStream *__html_stream_object(StreamTokens *st, char **html, Tag *next_tag);
extern void __html_stream_end_object(StreamTokens *st);
extern table_prev_info __html_find_current_object(StreamTokens *st, HStream *current);

/***********************************************************************/
a372 4
extern HStream *HStreamalloc(tag_no);
extern unsigned int __html_stream_style(StreamTokens *st);
extern unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start);
extern unsigned int __html_stream_indent(StreamTokens *st);
@


1.2.2.26
log
@Added simple support for <DIV align=...>
Forced linebreaks after </CENTRE> (and </DIV>).
@
text
@a139 1
  unsigned int divalign:3;
a184 1
  #define _stream_divalign _stream_style.divalign
@


1.2.2.27
log
@To solve problems with odd position of NOFRAMES, HTMLLib now uses the
Navigator-esque behaviour of ignoring everything after a /FRAMESET,
provided the frameset had at least one FRAME tag inside. This was
mostly for 'http://www.airuk.co.uk/'.
@
text
@a254 1
  char had_frame;
@


1.2.2.28
log
@Stopped style being attached to SCRIPT and STYLE tokens.
Stopping leading spaces being stripped from PRE elements.
Removed TABLE,TR,TD and TH from the style word.
@
text
@d203 1
@


1.2.2.29
log
@Some pages could be parsed in the context of a previous table - fixed.
Made the 'throw away very tall images' code only do it for images < 6
pixels wide.
@
text
@a255 6
  #ifdef TonyTables
  table_stream *current_table; /* this is also an HStream */
  table_row *current_row;
  table_cell *current_cell;
  #endif

d406 2
a407 2
extern HStream *__html_return_text_token(StreamTokens *st, char *doc, size_t size);
extern HStream *HStreamalloc(StreamTokens *st, tag_no);
@


1.2.2.30
log
@Implemented ordered lists.
Implemented <Q> ... </Q>.
Caused a linebreak after </DD>.
Finished implementing attributes for <OBJECT>.
Stopped HTML after a </FRAMESET> leaking through.
Ensured that FRAME and FRAMESET tokens aren't passed up if not using frames.

Removed lots of unnecessary #include "utf8.h" lines from encoding files.
Ensured unsigned constants used in UTF-8 code.
Added UTF8_next and UTF8_prev functions.
@
text
@a38 3
/* Maximum OL depth that we keep count */
#define MAX_OL 16

a130 1
  byte q;
a143 3
  /* Ordered list handling */
  int olcount[MAX_OL];
  char olstyle[MAX_OL];
a173 1
  #define _stream_q      _stream_style.q
a187 2
  #define _stream_olcount _stream_style.olcount
  #define _stream_olstyle _stream_style.olstyle
a345 7

/***********************************************************************/
/* From ^.c.ol                                                         */
/***********************************************************************/
/* ^.c.ol handles ordered lists                                        */
/***********************************************************************/
extern void __html_construct_ol_text(StreamTokens *st, HStream *);
@


1.2.2.31
log
@PARAM and APPLET, take 1.
@
text
@a352 1
extern HStream *__html_stream_applet(StreamTokens *st, char **html, Tag *next_tag);
a353 1
extern HStream *__html_stream_param(StreamTokens *st, char **html, Tag *next_tag);
@


1.2.2.32
log
@Fixed links to "./".
Ensured incomplete OBJECTs not returned (I hope).
Stopped newlines being stripped inside PRE.
Made </P> turn off any paragraph alignment.
Added HtmlReplaceOBJECT call.
@
text
@a271 2
  HStream *special_return;

a357 1
extern HStream *__html_replace_object(HStream *t);
@


1.2.2.33
log
@Previous check-in broke APPLET and OBJECTs inside tables.
Also, /APPLET didn't work (thought I'd fixed this?)
Default border for images now 0 if not a link.
@
text
@d355 1
@


1.2.2.34
log
@Added EMBED support (creating lookalike OBJECTs).
Removed startup table initialisation, because latest compiler can do it.
@
text
@a306 1
extern void __html_process_embed_attributes(StreamTokens *st, Tag *tag, char *html, HStream *obj);
d320 1
a356 2
extern HStream *__html_construct_param(StreamTokens *st, const char *name, const char *type,
                                       const char *value, paramtype valuetype);
a357 1
extern HStream *__html_stream_embed(StreamTokens *st, char **html, Tag *next_tag);
@


1.2.2.35
log
@Added objects flag to HtmlParse
@
text
@a210 1
  unsigned int usingobjects:1;
@


1.2.2.36
log
@MAP and AREA handling - first attempt
@
text
@a94 7
typedef struct MAP_STREAM
{
    struct MAP_STREAM *next;
    char *name;
    HStream *stream;
} MapStream;

a211 1
  unsigned int _stream_map:1;
a244 1
  MapStream *maps;
a343 1
extern int  stricmp(const char *string, const char *index);
a363 1
extern HStream *__html_find_map(MapStream *maps, const char *name);
@


1.2.2.37
log
@Modified to use external Unicode resources and UnicodeLib.
@
text
@d22 1
a22 1
#include "Unicode/encoding.h"
@


1.2.2.38
log
@NB, This HTMLLib version went out in Browse v1.30 beta, 19 December 1997.
It now uses the URL_Fetcher module for URL relativisation, rather than
its own internal routines. The deprecated definition of BLOCK has been
commented out in rules.h, too.
@
text
@a17 2
#include "kernel.h"

a464 71

/***********************************************************************/
/* From ^.c.URLModule                                                  */
/***********************************************************************/
/* URLModule contains a number of veneer functions to support parsing  */
/* and canonicalisation of URLs.                                       */
/***********************************************************************/

struct URL_ptrs {
  char *full;
  char *scheme;
  char *host;
  char *port;
  char *user;
  char *password;
  char *account;
  char *path;
  char *query;
  char *fragment;
  char *minimal;
};

struct URL_lengths {
  size_t  full;
  size_t  scheme;
  size_t  host;
  size_t  port;
  size_t  user;
  size_t  password;
  size_t  account;
  size_t  path;
  size_t  query;
  size_t  fragment;
  size_t  minimal;
};

typedef union URL {
  struct URL_lengths lengths;
  size_t len[sizeof(struct URL_ptrs)/sizeof(size_t)];
  struct URL_ptrs data;
  char * field[sizeof(struct URL_ptrs)/sizeof(size_t)];
} URL;

enum {
  urlfield_FULL,
  urlfield_SCHEME,
  urlfield_HOST,
  urlfield_PORT,
  urlfield_USER,
  urlfield_PASSWORD,
  urlfield_ACCOUNT,
  urlfield_PATH,
  urlfield_QUERY,
  urlfield_FRAGMENT,
  urlfield_MINIMAL
};

enum {
  url_parseurl_buffer_lengths,
  url_parseurl_return_data,
  url_parseurl_compose_from_components
};

#define URL_fields   ((sizeof(URL)/sizeof(size_t)))
#define URL_ParseURL (0x83E07)

extern char *__html_url_canonicalise_url(int flags, const char*url, const char *rel);

extern _kernel_oserror *__html_url_find_lengths(int flags, const char *url, const char *rel, URL *u);
extern _kernel_oserror *__html_url_find_data(int flags, const char *url, const char *rel, URL *u);
extern _kernel_oserror *__html_url_compose_from_components(int flags, const char *url, const char *rel, URL *u);
@


1.2.2.39
log
@Added hack to support <FORM> tags between <TABLE> and <TD>
@
text
@a263 4
  /* Hack hack hack */
  HStream *pendingformfortable;
  int dopendingform;

@


1.2.2.40
log
@*** empty log message ***
@
text
@d531 1
a531 2
  url_parseurl_compose_from_components,
  url_parseurl_quick_resolve
@


1.2.2.41
log
@*** empty log message ***
@
text
@a128 1
  byte nobr;    /* used as a counter */
a175 1
  #define _stream_nobr   _stream_style.nobr
@


1.2.2.42
log
@Added flag to HtmlParse to turn on or off tables support
@
text
@a222 1
  unsigned int usingtables:1;
@


1.1
log
@file internal was initially added on branch ARTtmp.
@
text
@d1 539
@


1.1.2.1
log
@Initial revision
@
text
@a0 448
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source: /ax/networking:Phileas/HTML/h/internal: $
 *
 * $Log:	internal,v $
 * Revision 1.4  95/10/31  13:16:09  pwain
 * Changed a few more definitions
 *
 * Revision 1.3  95/10/30  10:24:40  pwain
 * Reformatted, sorted and commented declarations.
 *
 * Revision 1.2  95/10/17  14:03:10  pwain
 * Added __html_memory_init() and changed number of
 * parameters to __html_free() to include free_all
 * for mass memory freeing if permitted.
 *
 * Revision 1.1  95/10/12  12:49:21  pwain
 * Initial revision
 *
 *
 * --- Original Log Info ---
 *
 * $Version: networking $
 *
 * $Source: /ax/networking:Phileas/HTML/h/internal: $
 *
 * $Log:	internal,v $
 * Revision 1.4  95/10/31  13:16:09  pwain
 * Changed a few more definitions
 *
 * Revision 1.3  95/10/30  10:24:40  pwain
 * Reformatted, sorted and commented declarations.
 *
 * Revision 1.2  95/10/17  14:03:10  pwain
 * Added __html_memory_init() and changed number of
 * parameters to __html_free() to include free_all
 * for mass memory freeing if permitted.
 *
 * Revision 1.1  95/10/12  12:49:21  pwain
 * Initial revision
 *
 * Revision 1.2  95/09/26  11:44:10  pwain
 * Added __html_check_tag() definition.
 *
 * Revision 1.1  95/09/08  10:06:16  pwain
 * Initial revision
 *
 *
 */
#ifndef __html_externs__
#define __html_externs__

#include "tags.h"
#include "struct.h"

#ifndef BOOL
#define BOOL  int

// Sometimes people define Bool & TRUE & FALSE...

#ifndef TRUE
#define TRUE  1
#define FALSE 0
#endif
#endif


typedef unsigned char byte;


/***********************************************************************/
/* Structures used internally                                          */
/***********************************************************************/
/* General purpose structure to hold anchor tag information            */
/* All element names are those used in the HTML 2.0 specification.     */
/***********************************************************************/
typedef struct ANCHOR {
    /******/
/*  char		*rel;
    char		*rev;
    char		*urn;
    char		*title;
    char		*methods;  */
    char		*name;
    char		*href;       /* URL of page */
    char		*src;        /* Location of image */
    char                *target;
    char		*alt;	     /* Text for image */
    char 		*action;     /* Place to send form - same as HREF? */
    char 		*enctype;    /* Ignored */
    char 		*value;      /* Of input field */
    unsigned int	maxlength;   /* of input field */
    unsigned int	size;	     /* Of on-screen box */
    unsigned int	rows;	     /* Text area size */
    unsigned int	cols;	     /* text area size */
    unsigned int        spacing;     /* frame, frameset spacing */
    unsigned int        type;	     /* INPUT formats (0-7), frameset types etc. */
    byte	        method;	     /* Method to use - see HTTP module */
    byte		ismap;	     /* ISMAP on images */
    byte		alignment;   /* For images (0-7) */
    byte                valign;      /* For tables (0-7) */
    byte                checked;     /* For checkboxes */
    byte		multiple;    /* For Radio buttons */
    byte		selected;    /* For menus etc */
    byte		border;	     /* Hopefully borderwidth <= 255 */
    byte                colspan;     /* Tables support */
    byte                rowspan;     /* Tables support */
    unsigned int        noshade:1;   /* NOSHADE on <HR>s */
    unsigned int        noresize:1;  /* NORESIZE on <FRAME>s */
    unsigned int        scrolling:2; /* SCROLLING on <FRAME>s */
    } AnchorInfo, *AnchorInfoRef;

/***********************************************************************/
/* This is the internal stream structure used by the HTML stream parser*/
/***********************************************************************/
typedef struct COLOUR_INFO ColourInfo, *ColourInfoRef;

typedef struct STREAM_TOKENS {
  /* The HTML token counters (not all used -> see code! ) */

  /* head */
  byte _stream_title;   /* used as a counter */
  byte _stream_isindex; /* bool */

  /* body */
  byte _stream_bold;    /* used as a counter */
  byte _stream_italic;  /* used as a counter */
  byte _stream_tt;      /* used as a counter */
  byte _stream_a;
  byte _stream_img;
  byte _stream_p;       /* bool */
  byte _stream_pre;
  byte _stream_dl;
  byte _stream_dt;
  byte _stream_dd;
  byte _stream_ol;
  byte _stream_ul;
  byte _stream_dir;
  byte _stream_br;
  byte _stream_blockquote;
  byte _stream_address;
  byte _stream_center;
  byte _stream_comment;
  byte _stream_form;
  byte _stream_select;
  byte _stream_textarea;

  /* doc tags */
  unsigned int _stream_body:1;
  unsigned int _stream_head:1;
#ifdef FRAMESUPPORT
  unsigned int _stream_noframes:1;
  unsigned int usingframes:1;
  byte _stream_frameset;
#endif
  byte type; /* 1 = HTML, 2=TEXT currently */
  byte  _stream_li;
  byte  _stream_table;
  /* Send a list token with next token? */
  byte send_list;
  /* Cope with another Netscrape-ism */
  byte stripleadingcr;
  /* Hold off processing until we get a */
  /* Keep track of end tokens so we can just send back those we need */
  unsigned int needtosend;
  /* How far into the stream are we? */
  unsigned int done;
  unsigned int sizesofar; /* What we have been given in total */
  /* Size of chunk/document */
  unsigned int chunklength;
  unsigned int doclength;
  /* The current H<n> state (headers aren't nestable - don't need counters) */
  unsigned int _stream_h;
  /* The URL of the document*/
  char *url;
  /* The base target of the document */
  char *target;
  /* Keep track of anchors */
  AnchorInfo *_stream_anchor;
  AnchorInfo *_stream_forms;
  AnchorInfo *_stream_table_anc;
  /* Keep track of colour blocks */
  ColourInfo *_stream_colour;
  /* The head of the stream structure */
  HStream *Stream;
  /* The memory context we are in */
  unsigned int memcontext;
  unsigned int following_start_tag:1;
  unsigned int _stream_basefont:3;
} StreamTokens, *StreamTokensRef;

struct COLOUR_INFO {
  struct COLOUR_INFO *next;
  unsigned int colour:24;
  unsigned int colour_valid:1;
  signed int size:7;
};
/*************************************************************************/
/* These #defines are used in link parsing. They have been moved out of  */
/* the publicly defined interface. 	    	      	   	     	 */
/*************************************************************************/
/*
 * These are the attributes used by links etc. They are in a second
 * status word effectivly.
 */
#ifdef FRAMESUPPORT

enum _anchor_tags {
  REL,		REV,		URN,		_TITLE,
  METHODS,	HREF,		NAME,		SRC,
  BACKGROUND = SRC,
  ALT,		ALIGN,		ISMAP,		ACTION,
  METHOD, 	ENCTYPE,	TYPE,		MAXLENGTH,
  SIZE,		VALUE,		CHECKED,	MULTIPLE,
  SELECTED,	COLS,		ROWS,		BORDER,
  VALIGN,	COLSPAN,	ROWSPAN,	BGCOL,
  FGCOL,	ALINK,		VLINK,		COLOR,
  FONTSIZE,	BASEFONTSIZE,	HRWIDTH,	NOSHADE,
  FRAMEBORDER,  BORDERCOLOR,    MARGINWIDTH,    MARGINHEIGHT,
  SCROLLING,    NORESIZE,       TARGET
};

#else

#define REL			((unsigned int)1<<0)
#define REV			((unsigned int)1<<1)
#define URN			((unsigned int)1<<2)
#define _TITLE			((unsigned int)1<<3)
#define METHODS			((unsigned int)1<<4)
#define HREF			((unsigned int)1<<5)
#define NAME			((unsigned int)1<<6)
#define SRC			((unsigned int)1<<7)
#define ALT			((unsigned int)1<<8)
#define ALIGN			((unsigned int)1<<9)
#define ISMAP			((unsigned int)1<<10)
#define BACKGROUND              SRC

/*
 * Form bits
 */
#define ACTION                  ((unsigned int)1<<11)
#define METHOD			((unsigned int)1<<12)
#define ENCTYPE			((unsigned int)1<<13)
#define TYPE			((unsigned int)1<<14)
#define MAXLENGTH		((unsigned int)1<<15)
#define SIZE			((unsigned int)1<<16)
#define VALUE			((unsigned int)1<<17)
#define CHECKED			((unsigned int)1<<18)
#define MULTIPLE		((unsigned int)1<<19)
#define SELECTED		((unsigned int)1<<20)
#define COLS			((unsigned int)1<<21)
#define ROWS			((unsigned int)1<<22)
#define BORDER			((unsigned int)1<<23)

/* Tables stuff */
#define VALIGN                  ((unsigned int)1<<24)
#define COLSPAN                 ((unsigned int)1<<25)
#define ROWSPAN                 ((unsigned int)1<<26)

/* Colours stuff */
#define BGCOL                   ((unsigned int)1<<27)
#define FGCOL                   ((unsigned int)1<<28)
#define ALINK                   ((unsigned int)1<<29)
#define VLINK                   ((unsigned int)1<<30)

/* Values for <FONT> tags, purely internal */
#define COLOR                   17
#define FONTSIZE                18
#define BASEFONTSIZE            19

/* And HR... */
#define HRWIDTH                 20
#define NOSHADE                 21

#endif

/* The values for align can just be normal unsigned ints not bits set... */
#define TOP			(1)
#define RIGHT			(2)
#define	BOTTOM			(3)
#define LEFT			(4)
#define MIDDLE			(5)

/* The values for INPUT TYPE=... */
#define TEXT  	  		(0)  /* Default case */
#define PASSWORD		(1)  /* Gets hidden */
#define CHECKBOX		(2)  /* Square thing */
#define RADIO			(3)  /* Round thing */
#define IMAGE			(4)  /* Uh-oh! */
#define HIDDEN			(5)  /* Not shown in UI */
#define SUBMIT			(6)  /* Press to send */
#define RESET     (7)  /* Got it wrong? */

/***********************************************************************/
/* From ^.c.parse                                                      */
/***********************************************************************/
/* This file is a hang over from the tree parser; it just contains the */
/* generic code to strip stuff out of anchors and store their value in */
/* and AnchorInfo struct.      	      	      	  	      	       */
/***********************************************************************/
extern AnchorInfo *__html_get_anchor_info(StreamTokens *st, char **anchor_info, Tag tag);

/***********************************************************************/
/* From ^.c.rules                                                      */
/***********************************************************************/
/* ^.c.rules contains a number of small routines for extracting tags   */
/* and manipulating them where required. "Knows the HTML2 DTD".	       */
/***********************************************************************/
extern int __html_check_tag (Tag *rules, int max_rules, const char *tag);
extern Tag __html_find_start_tag_block(char *tag);
extern Tag __html_find_end_tag_block(char *tag);
extern Tag __html_find_tag(char **html, int end);

/***********************************************************************/
/* From ^.c.display                                                    */
/***********************************************************************/
/* ^.c.display contains the routines needed prior to displaying a page */
/* ATM this is just the code to strip the spaces, but the code to      */
/* convert the ISO-LATIN-1 entities will also be in here       	       */
/***********************************************************************/
extern char *__html_strip_spaces(char *input, int stripleadingcr);
extern char *__html_strip_lfs(char *input);
extern char *strdup(char *s1);
extern char *strndup(char *s1, int size);
extern char *__html_unescape_string(char *input);
extern int __html_unnumeric_escape(char ch);
extern void __html_strip_control_codes(char *input);
extern int  strincmp(const char *string, const char *index, int size);
extern char *strnstr(const char *string, const char *index, int size);
char *strinstr(const char *string, const char *index, int size);

/* Need to think about TABs at some stage */
#define CTRL_CODE(c) (c<' ' && c!='\n' && c!='\r')

/***********************************************************************/
/* From ^.c.font                                                       */
/***********************************************************************/
/* ^.c.font contains the routines needed to process the <FONT> tag     */
/***********************************************************************/
extern void add_colour_info(StreamTokens *st, unsigned int col, int *allocate_required);
extern void add_size_info(StreamTokens *st, const char *ptr, int *allocate_required);
extern void fill_in_colour_info(const StreamTokens *st, HStream *hs);
extern void font_tag_closed(StreamTokens *st);

#ifdef USING_OLD_FREE
/***********************************************************************/
/* From ^.c.free - no longer needed I belive                           */
/***********************************************************************/
/* ^.c.free was the initial code to free up memory that was allocated. */
/* These routines were used to free up the stream and tree structures  */
/* before __html_free() existed. There are I believe no longer needed. */
/***********************************************************************/
extern void __html_tree_entry_free(Html *document);
extern void __html_tree_free(Html *document, int depth);
extern void __html_stream_free(HStream *stream);
extern void __html_stream_entry_free(HStream *stream);
#endif

/***********************************************************************/
/* From ^.c.malloc                                                     */
/***********************************************************************/
/* ^.c.malloc is the general purpose front end to malloc which keeps   */
/* account of the context which a set of structures exists in. When    */
/* a call to __html_free() is made, all memory in the same context as  */
/* the pointer passed can be freeded if the second argument is TRUE.   */
/* NOTE: these functions put a wrapper around the memory allocated so  */
/* they cant be used in conjunction with normal free() and malloc().   */
/* The code uses calloc() internally to ensure memory is initialised.  */
/***********************************************************************/
extern char *__html_malloc(size_t bytes, size_t size);
extern void __html_free(void *ptr, int free_all);
extern void __html_memory_init(void);
extern void __html_memory_list(void);
extern unsigned int __html_memory_context;

#if 0
/***********************************************************************/
/* From ^.c.stream                                                     */
/***********************************************************************/
/* ^.c.stream contains a small streamer used to turn a HTML document   */
/* into a stream compatible with a particular 3rd party GUI.           */
/***********************************************************************/
extern unsigned int __html_interest_tags;
extern unsigned int __html_indent_tags;
extern HStream *__html_make_stream(Html *doc);
#endif

/***********************************************************************/
/* From ^.c.new_stream                                                 */
/***********************************************************************/
/* ^.c.new_stream contains a small streamer used to turn a HTML        */
/* document into a stream compatible with a particular 3rd party GUI.  */
/***********************************************************************/
extern byte __html_done_for_now;
extern HStream *__html_stream_parse(StreamTokens *st,char **html, char *url, int size);
extern StreamTokens *__html_stream_init(void);
extern HStream *__html_return_text_token(char *doc, size_t size);

/***********************************************************************/
/* From ^.c.HTTPSupport                                                */
/***********************************************************************/
/* HTTPSupport contains a number of functions to support the parsing   */
/* of HTTP headers, work out file content type, and strip the HTTP     */
/* headers ready to pass to an external application or the main parser */
/***********************************************************************/
extern int __http_strip_headers(char *stream, size_t stream_len);
extern unsigned int __html_identify(char *stream, size_t stream_len, char done, char **url, int *file_type, int *canparse);
extern char *__http_escape_string(char *string);

/***********************************************************************/
/* This is just needed ok' :)                                          */
/***********************************************************************/
#include "ctype.h"

/***********************************************************************/
/* Useful macro's                                                      */
/***********************************************************************/
/* This turns a string into upper case. NOTE: it is destructive. That  */
/* has caught me out before. The best use is to strdup the string and  */
/* then upper_case() it. You will need to do this in two steps.	       */
/***********************************************************************/
#define UPPER_CASE(x) { char *y; y=x; while (*y != '\0') { \
		        *y=toupper(*y); y++; } }
/***********************************************************************/
/* Small macro to do lots of tests in one line of code. This will tell */
/* You if the return value from withing any of the TAG finding fn's is */
/* the NULL_TAG as defined in h.tags	       	       	       	       */
/***********************************************************************/
#define NULL_TAG(x) ( (x.start_tag==NULL) && \
		      (x.tag==0) && (x.rule == 0 ) && (x.anchors == 0))

#endif /* __html_externs__ */
@


1.1.2.2
log
@Spacing rules drastically improved. Major error in memory context handling
fixed. Bug in __html_strip_lf fixed.
@
text
@d19 1
a19 5
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/h/Attic/internal,v $
 *
 * $Log: internal,v $
 * Revision 1.1.2.1  1997/04/08 10:27:06  kbracey
 * Initial revision
d21 1
d41 1
a41 5
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/h/Attic/internal,v $
 *
 * $Log: internal,v $
 * Revision 1.1.2.1  1997/04/08 10:27:06  kbracey
 * Initial revision
d43 1
d140 1
a140 1

d167 1
a167 8
#ifdef NEWSPACING
  unsigned int stripleadingspace:1;
  unsigned int trailingspacestripped:1;
  unsigned int lastwaspcdata:1;
  unsigned int lastwaspcdataspace:1;
  unsigned int isendtag:1;
#endif
#ifdef FRAMESUPPORT
d171 1
a171 1
#endif
a177 1
#ifndef NEWSPACING
a178 1
#endif
d325 1
a325 1
extern int __html_check_tag (const Tag *rules, int max_rules, const char *tag);
a336 4
#ifdef NEWSPACING
extern int __html_strip_spaces(char *input, int stripleadingspace, int striptrailingspace);
extern void __html_strip_trailing_spaces(char *input);
#else
a337 1
#endif
d388 1
a388 1
extern unsigned int __html_memory_init(void);
d390 1
a390 1
extern void __html_set_memory_context(unsigned int);
d411 1
a411 1
extern HStream *__html_stream_parse(StreamTokens *st,char **html, char *url, int size, HStream *prevhs);
@


1.1.2.3
log
@Added in Tony Cheal's table code. Various other bug fixes.
@
text
@a21 4
 * Revision 1.1.2.2  1997/04/09 16:44:44  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
a46 4
 * Revision 1.1.2.2  1997/04/09 16:44:44  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
a76 1
#include "tablestruc.h"
a129 3
    #ifdef TonyTables
    int                 width;
    #endif
a139 36
#ifdef TonyTables
typedef struct TABLE_STUFF {
    HStream *Stream;
    unsigned int memcontext;
} TableContext;
#endif

typedef struct styleinfo
{
  byte bold;    /* used as a counter */
  byte italic;  /* used as a counter */
  byte tt;      /* used as a counter */
  byte a;
  byte img;
  byte p;       /* bool */
  byte pre;
  byte dl;
  byte dt;
  byte dd;
  byte ol;
  byte ul;
  byte dir;
  byte br;
  byte blockquote;
  byte address;
  byte centre;
  byte comment;
  byte form;
  byte select;
  byte textarea;
  byte li;
  unsigned int h;
  /* Keep track of colour blocks */
  ColourInfo *colour;
} styleinfo;

d148 21
a168 28

  /* Stuff that needs to be stacked away on a <TABLE> */
  styleinfo _stream_style;
  #define _stream_bold   _stream_style.bold
  #define _stream_italic _stream_style.italic
  #define _stream_tt     _stream_style.tt
  #define _stream_a      _stream_style.a
  #define _stream_img    _stream_style.img
  #define _stream_p      _stream_style.p
  #define _stream_pre    _stream_style.pre
  #define _stream_dl     _stream_style.dl
  #define _stream_dt     _stream_style.dt
  #define _stream_dd     _stream_style.dd
  #define _stream_ol     _stream_style.ol
  #define _stream_ul     _stream_style.ul
  #define _stream_dir    _stream_style.dir
  #define _stream_br     _stream_style.br
  #define _stream_blockquote _stream_style.blockquote
  #define _stream_address _stream_style.address
  #define _stream_center _stream_style.centre
  #define _stream_comment _stream_style.comment
  #define _stream_form   _stream_style.form
  #define _stream_select _stream_style.select
  #define _stream_textarea _stream_style.textarea
  #define _stream_li     _stream_style.li
  #define _stream_h      _stream_style.h
  #define _stream_colour _stream_style.colour
  /* End stuff that need to be stacked */
d186 1
d203 2
d213 2
a216 6
  #ifdef TonyTables
  TableContext   *Tables;                  /* Previous parsing contexts for tables */
  table_stream   *_stream_current_table;   /* this is also an HStream * */
  table_row      *_stream_current_row;
  table_headdata *_stream_current_headdata;
  #endif
d251 1
a251 3
  SCROLLING,    NORESIZE,       TARGET,         CELLSPACING,
  CELLPADDING,  NOWRAP,         CELLWIDTH,      CELLHEIGHT,
  TABLEWIDTH
a305 1

a432 1
extern void __html_style_init(styleinfo *s);
@


1.1.2.4
log
@Made forms work across tables.
@
text
@a21 3
 * Revision 1.1.2.3  1997/04/28 14:20:26  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
a50 3
 * Revision 1.1.2.3  1997/04/28 14:20:26  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
d179 1
d217 1
a223 1
  byte _stream_form;
@

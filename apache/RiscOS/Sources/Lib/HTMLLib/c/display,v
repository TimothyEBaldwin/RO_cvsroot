head	1.6;
access;
symbols
	HTMLLib-0_04:1.6
	HTMLLib-0_03:1.6
	HTMLLib-0_02:1.6
	HTMLLib-0_01:1.6
	ahodgkin_207release:1.4
	ahodgkin_206release:1.3
	ahodgkin_205release:1.3
	ahodgkin_204release:1.3
	ahodgkin_133beta:1.2.2.15
	kbracey_126:1.2.2.11
	kbracey_AW97patch:1.2.2.11
	ahodgkin_AW97:1.2.2.11
	kbracey_PreGordon:1.2
	Web_bp:1.2
	Web:1.2.0.2
	ARTtmp_merge:1.1.2.3
	ARTtmp:1.1.0.2;
locks; strict;
comment	@# @;


1.6
date	99.06.04.14.51.19;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	98.11.05.14.38.47;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	98.09.10.15.54.01;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	98.02.17.10.42.14;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	97.04.29.15.50.43;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.08.10.26.36;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.2.2.1
date	97.06.25.08.04.10;	author kbracey;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	97.06.26.11.02.46;	author kbracey;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	97.07.02.16.01.54;	author kbracey;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	97.07.04.11.55.10;	author kbracey;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	97.07.25.10.01.21;	author kbracey;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	97.07.25.16.07.25;	author kbracey;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	97.08.01.15.06.28;	author kbracey;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	97.08.12.11.22.43;	author kbracey;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	97.08.27.08.29.14;	author kbracey;	state Exp;
branches;
next	1.2.2.10;

1.2.2.10
date	97.09.18.14.11.25;	author kbracey;	state Exp;
branches;
next	1.2.2.11;

1.2.2.11
date	97.09.30.14.13.40;	author kbracey;	state Exp;
branches;
next	1.2.2.12;

1.2.2.12
date	97.11.14.09.51.02;	author kbracey;	state Exp;
branches;
next	1.2.2.13;

1.2.2.13
date	97.11.14.15.43.13;	author kbracey;	state Exp;
branches;
next	1.2.2.14;

1.2.2.14
date	97.11.28.15.32.05;	author kbracey;	state Exp;
branches;
next	1.2.2.15;

1.2.2.15
date	98.01.12.19.13.11;	author ahodgkin;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.08.10.26.38;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.04.09.16.44.35;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	97.04.28.14.20.18;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Various fixes. Attribute parser would hang when faced with '...VALUE=>'.
Entites which were a substring match of other entities in name (possible
in HTML 4 but not previously) would get mismatched in HTML (the shorter
always being picked and extra letters left over getting spat out to the
page). Solved by having a seperate try-first table of substring matching
entities.

New feature (sort of). Entities in URLs were never escaped as the
existing relaxed entity parser would often mangle CGI-style URLs. There
is now a strict unescaping mode used for URLs which seems to sort out
various sites where this was a problem.

Makefile exports to 'Lib$Dir' rather than 'HTMLLib:' to fit in with
current build environments.
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "html2_ext.h"
#include "tags.h"
#include "struct.h"
#include "string.h"
#include "internal.h"
#include "stdio.h"

#include "Unicode/iso10646.h"
#ifdef UNIFONT
#include "Unicode/utf8.h"
#endif

#ifdef NEWSPACING
int __html_strip_spaces(char *input, int stripleadingspace, int striptrailingspace);
#else
char * __html_strip_spaces(char *input, int stripleadingcr);
#endif
char * __html_strip_lfs(char *input);
char * __html_tidy_url(char *url);
int __html_unnumeric_escape(char ch);
static UCS4 __html_entity_name_to_char(char **sequencep, unsigned int strict);
static UCS4 __html_number_to_char(char **sequencep);


/********************************************************************/
/* char *__html_strip_spaces(char *input, int stripleadingcr)       */
/********************************************************************/
/* This function removes all instances of multiple whitespace and   */
/* replaces them with a single space. Thus CR, LF CTRL-... are      */
/* replaced by a space                                              */
/********************************************************************/
#ifdef NEWSPACING
int __html_strip_spaces(char *input, int stripleadingspace, int striptrailingspace)
#else
char *__html_strip_spaces(char *input, int stripleadingcr)
#endif
{
char *s,*ptr;
#ifdef NEWSPACING
int strippedtrailingspaces=0;
int lastisspace=0;
#endif

/*
 * Avoid muck situation we know about
 */
#ifdef NEWSPACING
  if ((input==NULL) || (*input=='\0')) return stripleadingspace;
#else
  if ((input==NULL) || (*input=='\0')) return input;
#endif

  ptr=s=input;
#ifdef DEBUG
  Printf("Stripping spaces:\n");
  Printf("Input : '%s'\n",input);
#endif

#ifdef NEWSPACING
  /*
   * Strip all leading whitespace if necessary (ie if after start tag)
   */
  if (stripleadingspace)
  {
    while (isspace(*input))
       input++;
  }
#else
/*
 * First off, if the input sequence starts with chars that are
 * under 32 (a space), e.g. new lines, jump over these straigt off
 * to make the output look a bit better!
 */
if (stripleadingcr)
{
  while ((*input > 0) && (*input < 32)) input++;
  if (*input==0) {
    *ptr='\0';
    return ptr;
  }
}
#endif


/* Turn all initial spaces into a single space */
  while (isspace(*input) && isspace(*(input+1))) input++;

/*
 * Now loop down the string stripping out any non-ascii chars
 * and turn them into spaces.
 */
  while (*input != '\0') {
    if (*input <= 32) {
      while ((*input <= 32) && (*input != '\0')) {
/* Step over all chars less than or a space */
	input++;
/* Replace them with a single space */
/*
        *s=' ';
        s++;
*/
      }
      *s=' ';
      s++;
    }

/* At this point we know that *input is not a space so we can snarf it */
    *s=*input;
    if (*s != '\0') {
      s++;
      input++;
    }
  }

  *s='\0';

#ifdef NEWSPACING
  if (striptrailingspace)
  {
    if (s > ptr && isspace(*(s-1)))
    {
      strippedtrailingspaces=1;
      *--s='\0';
    }
  }
  else
  {
    if (s > ptr && isspace(*(s-1)))
    {
      lastisspace=1;
    }
    else if (s == ptr)
      lastisspace=stripleadingspace;
  }
#endif

#ifdef DEBUG
  Printf("Output: '%s'\n", ptr);
#endif

/* And return */
#ifdef NEWSPACING
  return lastisspace;
#else
  return ptr;
#endif
}

void __html_strip_trailing_spaces(char *input)
{
    char *p=input+strlen(input)-1;

    while (p >= input && isspace(*p))
        *p--='\0';
}

/********************************************************************/
/* char *__html_strip_lfs(char *input)                              */
/********************************************************************/
/* This function removes all instances LF in the input stream to    */
/* enable the front end to only have to deal with CRs  	      	    */
/*                                                                  */
/* 18/03/1999 (ADH) Arf. Don't think so. Does the reverse - leaves  */
/*                  you with just LFs.                              */
/********************************************************************/
#define CR '\r'
#define LF '\n'
char *__html_strip_lfs(char *input)
{
char *s1=input, *s2=input, c;

  if(!input || !*input) return input;

  while ((c=*s1) != '\0') {
/* Are we pointing at a CR */
    switch (c)
    {
      case CR:
        if (*(s1+1)==LF)         /* Turn CRLF into LF */
        {
            *s2=LF;
            s1++;
        }
        else
        {
            *s2=LF;              /* Turn CR into LF */
        }
        break;
      /* Deal with tabs - this should pad to 8 chars */
      case '\t':
        *s2=' ';
        break;
      default:
        *s2=*s1;
        break;
    }
    s1++;
    s2++;
  }
/* Ensure we terminate s2 */
  *s2='\0';

/* Return the string */
  return input;
}

/********************************************************************/
/* char *strdup(char *s1)                                           */
/********************************************************************/
/* strdup stand for "STRing DUPlicate". Go figure :) This returns a */
/* copy of s1 on success or a NULL pointer on failure               */
/********************************************************************/

char * strdup(const char * s1)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = (char *) __html_malloc(strlen(s1) + 1, 1);

  if (s2 == NULL) return NULL;

  return strcpy(s2, s1);
}

/********************************************************************/
/* char *strndup(char *s1, int size)                                */
/********************************************************************/
/* Same as strdup except that the amount of bytes to copy is known  */
/********************************************************************/

char * strndup(const char * s1, int size)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = (char *) __html_malloc(size + 1, sizeof(char)); /* +1 to be safe? */

  if (s2 == NULL) return NULL;

  return (char *) memcpy(s2, s1, size);
}

/********************************************************************/
/* static void __html_unescape(char *sequence, unsigned int strict) */
/********************************************************************/
/* Given a string which either must be terminated in ';' (if the    */
/* parameter 'strict' is set to 1 on entry) or may be terminated by */
/* ';', ' ' or even more string (e.g. "nbsp;" or "nbspmore" match   */
/* the same thing), return the (hopefully!) correct ISO-LATIN-1     */
/* char for that string. The string passed in the first parameter   */
/* is returned in the modified form.                                */
/********************************************************************/

static void __html_unescape(char *sequence, unsigned int strict)
{
  char *ptr=sequence;
  char c;
  UCS4 result;
  char *end;

  /*
   * Force a terminating NUL after the entity name. Want to include
   * the ';' for strict unescaping; otherwise, can't later distinguish
   * between "&amp;" and "&amp".
   */

  while (isalnum(*sequence) || *sequence=='#' || *sequence=='&') {
    sequence++;
  }

  if (*sequence==';') sequence++;
  c=*sequence; *sequence='\0';

  if (*(ptr+1) == '#') { /* Decimal numeric escape */
    end = ptr + 2;
    result=__html_number_to_char(&end);

    #define MS_TO_UNICODE_HACK

    #ifdef MS_TO_UNICODE_HACK
    /* "Microsoft Unicode" -> Unicode translation table */
    if (result >= 0x80 && result <= 0x9F)
    {
        static const UCS2 ms_hack[] = {
            0x0080, 0x0081, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
            0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008D, 0x008E, 0x008F,
            0x0090, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
            0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x009D, 0x009E, 0x0178
        };
        result = ms_hack[result-0x80];
    }
    #endif
    /* Turn TABs into spaces (it'll do for now) */
    if (result == 9) result = 32;
    if (result < 32 || result == 127)
        result = 0;
  }
  else {
    end = ptr+1;
    result=__html_entity_name_to_char(&end, strict);
  }

  if (result == 0)
  {
    *sequence=c;
    return;             /* We don't recognise it as a valid thingy, so exit */
  }
  else
#ifdef UNIFONT
    /*
     * Assumption here is that no entity can produce a UTF sequence
     * longer than itself. True for numeric entities and should
     * remain true for named entities, as long as:
     * All entities &x;  ->  <= 0x7FF
     * All entities &xx; ->  <= 0xFFFF
     * All entities &xxx; ->   <= 0x1FFFFF
     * All entities &xxxx; ->   <= 0x3FFFFFF
     */
    ptr = UCS4_to_UTF8(ptr, result);
#else
    *ptr++ = __html_iso10646_to_latin1(result);
#endif

  *sequence=c;

  sequence = end;
  if (*sequence==';')
    sequence++;

  if (ptr == sequence)
    return;

  while (*sequence != '\0') {
    *ptr=*sequence;
    ptr++;
    sequence++;
  }
  *ptr='\0';
}

/********************************************************************/
/* static int __html_unhex(char ch)                                 */
/********************************************************************/
/* Given a single char return its integer value as if it were a hex */
/* digit.                                                           */
/********************************************************************/

int __html_unnumeric_escape(char ch)
{
    if ((ch >= '0') && (ch <= '9')) return ((int)ch-'0'); /* 0 to 9 */
    if ((ch >= 'A') && (ch <= 'F')) return ((int)ch-'A'+10); /* 10 to 15 */
    return 0;
}

static int iso10646cmp(const void *a, const void *b)
{
    unsigned int key = (unsigned int) a;
    wchar_t *wc = (wchar_t *) b;

    return key - *wc;
}

/********************************************************************/
/* char __html_iso10646_to_latin1(unsigned long ch)                 */
/********************************************************************/
/* Given an ISO 10646 code, spit out the Acorn Extended Latin-1     */
/* equivalent.                                                      */
/********************************************************************/
char __html_iso10646_to_latin1(UCS4 ch)
{
  typedef struct
  {
    wchar_t num;
    char acornlatin1;
  }
  CharEnt;

  /*
   * This table contains transformations from ISO10646 to Acorn
   * Extended Latin-1.
   */
  static const CharEnt char_table[] =
  {
     0x0192, 'f',  /* Latin small letter f with hook */
     0x02BC, 'ë',  /* Modifier letter apostrophe */
     0x02C6, '^',  /* Modifier letter circumflex accent */
     0x02DC, '~',  /* Small tilde */
     0x2013, 'ó',  /* En dash */
     0x2014, 'ò',  /* Em dash */
     0x2018, 'ê',  /* Left single quotation mark */
     0x2019, 'ë',  /* Right single quotation mark */
     0x201A, ',',  /* Single low-9 quotation mark */
     0x201C, 'î',  /* Left double quotation mark */
     0x201D, 'ï',  /* Right double quotation mark */
     0x201E, 'ñ',  /* Double low-9 quotation mark */
     0x2020, 'ú',  /* Dagger */
     0x2021, 'ù',  /* Double dagger */
     0x2022, 'è',  /* Bullet */
     0x2026, 'å',  /* Horizontal ellipsis */
     0x2030, 'é',  /* Per mille sign */
     0x2039, 'í',  /* Single left-pointing angle quotation mark */
     0x203A, 'ì',  /* Single right pointing angle quotation mark */
     0x20AC, 'Ä',  /* Euro sign */
     0x2122, 'ç',  /* Trade mark sign */
     0x2212, 'ô',  /* Minus sign */
     0xFB01, 'û',  /* Latin small ligature fi */
     0xFB02, 'ü',  /* Latin small ligature fl */
  };

  static char latinexta[0x80] =
  {
    'A','a','A','a','A','a','C','c','C','c','C','c','C','c','D','d','–','d','E','e','E','e','E','e','E','e','E','e','G','g','G','g',
    'G','g','G','g','H','h','H','h','I','i','I','i','I','i','I','i','I','i','I','i','J','j','K','k','k','L','l','L','l','L','l','L',
    'l','L','l','N','n','N','n','N','n','n','N','n','O','o','O','o','O','o','ö','õ','R','r','R','r','R','r','S','s','S','s','S','s',
    'S','s','T','t','T','t','T','t','U','u','U','u','U','u','U','u','U','u','U','u','Å','Ç','Ö','Ü','Y','Z','z','Z','z','Z','z','s'
  };

  static char latinextadd[0x100] =
  {
    'A','a','B','b','B','b','B','b','C','c','D','d','D','d','D','d','D','d','D','d','E','e','E','e','E','e','E','e','E','e','F','f',
    'G','g','H','h','H','h','H','h','H','h','H','h','I','i','I','i','K','k','K','k','K','k','L','l','L','l','L','l','L','l','M','m',
    'M','m','N','n','N','n','N','n','N','n','O','o','O','o','O','o','O','o','P','p','P','p','R','r','R','r','R','r','R','r','S','s',
    'S','s','S','s','S','s','S','s','S','s','T','t','T','t','T','t','T','t','U','u','U','u','U','u','U','u','U','u','V','v','V','v',
    'W','w','W','w','W','w','W','w','W','w','X','x','X','x','Y','y','Z','z','Z','z','Z','z','h','t','w','y','a','?','?','?','?','?',
    'A','a','A','a','A','a','A','a','A','a','A','a','A','a','A','a','A','a','A','a','A','a','A','a','E','e','E','e','E','e','E','e',
    'E','e','E','e','E','e','E','e','I','i','I','i','O','o','O','o','O','o','O','o','O','o','O','o','O','o','O','o','O','o','O','o',
    'O','o','O','o','U','u','U','u','U','u','U','u','U','u','U','u','U','u','Y','y','Y','y','Y','y','Y','y','?','?','?','?','?','?'
  };
  static char cjksymb[0x40] =
  {
    ' ',',','.','"','?','?','?','?','<','>','´','ª','ê','ë','ê','ë','[',']','?','?','(',')','[',']','{','}','[',']','~','î','ï','ñ',
    '?','1','2','3','4','5','6','7','8','9','?','?','?','?','?','?','~','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?'
  };

  static char fullwidth[0xF0] =
  {
    '?','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/','0','1','2','3','4','5','6','7','8','9',':',';', '<','=','>','?',
    '@@','A','B','C','D','E','F','G', 'H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_',
    '`','a','b','c','d','e','f','g', 'h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','{','|', '}','~','?',
    '?','?','?','?','?','?','?','?', '?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?', '?','?','?',
    '?','?','?','?','?','?','?','?', '?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?', '?','?','?',
    '?','?','?','?','?','?','?','?', '?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?', '?','?','?',
    '?','?','?','?','?','?','?','?', '?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?','?', '?','?','?',
    '¢','£','¨','Ø','¶','•','W','?', '?','?','?','?','?','?','?','?'
  };

  CharEnt *cent;

  if (ch < 128 || ch >= 160 && ch < 256)
      return (char) ch;

  if (ch >= 0x0100 && ch < 0x0180)
      return latinexta[ch - 0x100];

  if (ch >= 0x1E00 && ch < 0x1F00)
      return latinextadd[ch - 0x1E00];

  if (ch >= 0x3000 && ch < 0x3040)
      return cjksymb[ch - 0x3000];

  if (ch >= 0xFF00 && ch < 0xFFF0)
      return fullwidth[ch - 0xFF00];

  cent = bsearch((const void *) ch,
                 char_table,
                 (sizeof char_table) / (sizeof char_table[0]),
                 sizeof char_table[0],
                 iso10646cmp);

  return cent ? cent->acornlatin1 : '?';
}

/********************************************************************/
/* char __html_hex_to_char(char *sequence)                          */
/********************************************************************/
/* Given a char sequence that is known to be an ISO-LATIN-1 hex     */
/* escape code, convert this to a single Risc OS char               */
/********************************************************************/

static UCS4 __html_number_to_char(char **sequencep)
{
  UCS4 ch;

 /* We know that sequence is 0 terminated */
  if (**sequencep == 'x' || **sequencep == 'X')
      ch = (UCS4) strtoul(*sequencep + 1, NULL, 16);
  else
      ch = (UCS4) strtoul(*sequencep, NULL, 10);
  *sequencep += strlen(*sequencep);

  return ch;
}

/* The following is needed for the fuzzy matching routine for entities. */

typedef struct
{
  char name[9];
  unsigned short code;
}
CharEnt;

static CharEnt * entcmpfuzzy_found = NULL;
static int       entcmpfuzzy_len   = 0;

/*
 * This routine compares a given entity name from HTML source and finds,
 * via. being called from bsearch, the character code corresponding to
 * a matching entity name (if any) - where the length of the matching
 * entity name is as large as possible. This way, entities where one is
 * a substring of another - e.g. 'not' and 'notin' - do not get confused
 * in broken code such as '&notinmissing a semicolon'.
 *
 * Set entcmpfuzzy_found to NULL and entcmpfuzzy_len to 0 before calling
 * bsearch with this function given as the comparison code. Don't use
 * bsearch's return value; check if entcmpfuzzy_found is NULL on exit
 * instead (bsearch will always say "nothing found" directly).
 */

static int entcmpfuzzy(const void *a, const void *b)
{
  int len;
  int result;

  len = strlen((const char *) b);
  result = strncmp((const char *) a, (const char *) b, len);

  if (!result)
  {
    if (len > entcmpfuzzy_len)
    {
      entcmpfuzzy_len   = len;
      entcmpfuzzy_found = (CharEnt *) b;
    }

    return 1;
  }

  return result;
}

/*
 * Use this if you want to use bsearch on a strict 'must match exactly'
 * basis for entities. No need to do any special setting up for this
 * one, and bsearch's return value should be used as normal.
 */

static int entcmpstrict(const void *a, const void *b)
{
/*  return strncmp((const char *) a, (const char *) b, strlen((const char *) b)); *//* Fuzzy */
/*  return strncmp((const char *) a, (const char *) b, strlen((const char *) a)); *//* Strict or broken? */

  return strcmp((const char *) a, (const char *) b);
}

/********************************************************************/
/* char __html_entity_name_to_char(const char * sequence,           */
/*                                 unsigned int strict)             */
/********************************************************************/
/* Given a string which either must be terminated in ';' (if the    */
/* parameter 'strict' is set to 1 on entry) or may be terminated by */
/* ';', ' ' or even more string (e.g. "nbsp;" or "nbspmore" match   */
/* the same thing), return the (hopefully!) correct UCS4 character  */
/* for the entity named in the string, if recognised (returns zero  */
/* if no match is found). The first parameter is a pointer to a     */
/* string as this gets updated to point to the first character      */
/* after the entity if a match is found.                            */
/********************************************************************/

static UCS4 __html_entity_name_to_char(char ** sequencep, unsigned int strict)
{
  char *sequence = *sequencep;

  /*
   * This table comes from the W3C HTML 4.0 Specification Working
   * Draft (8-Jul-1997). CharEnt is defined just above entcmpfuzzy().
   */

  static const CharEnt char_table[] =
  {
    "AElig",   0x00C6,
    "Aacute",  0x00C1,
    "Acirc",   0x00C2,
    "Agrave",  0x00C0,
    "Alpha",   0x0391,
    "Aring",   0x00C5,
    "Atilde",  0x00C3,
    "Auml",    0x00C4,
    "Beta",    0x0392,
    "Ccedil",  0x00C7,
    "Chi",     0x03A7,
    "Dagger",  0x2021,
    "Delta",   0x0394,
    "ETH",     0x00D0,
    "Eacute",  0x00C9,
    "Ecirc",   0x00CA,
    "Egrave",  0x00C8,
    "Epsilon", 0x0395,
    "Eta",     0x0397,
    "Euml",    0x00CB,
    "Gamma",   0x0393,
    "Iacute",  0x00CD,
    "Icirc",   0x00CE,
    "Igrave",  0x00CC,
    "Iota",    0x0399,
    "Iuml",    0x00CF,
    "Kappa",   0x039A,
    "Lambda",  0x039B,
    "Mu",      0x039C,
    "Ntilde",  0x00D1,
    "Nu",      0x039D,
    "OElig",   0x0152,
    "Oacute",  0x00D3,
    "Ocirc",   0x00D4,
    "Ograve",  0x00D2,
    "Omega",   0x03A9,
    "Omicron", 0x039F,
    "Oslash",  0x00D8,
    "Otilde",  0x00D5,
    "Ouml",    0x00D6,
    "Phi",     0x03A6,
    "Pi",      0x03A0,
    "Prime",   0x2033,
    "Psi",     0x03A8,
    "Rho",     0x03A1,
    "Scaron",  0x0160,
    "Sigma",   0x03A3,
    "THORN",   0x00DE,
    "Tau",     0x03A4,
    "Theta",   0x0398,
    "Uacute",  0x00DA,
    "Ucirc",   0x00DB,
    "Ugrave",  0x00D9,
    "Upsilon", 0x03A5,
    "Uuml",    0x00DC,
    "Xi",      0x039E,
    "Yacute",  0x00DD,
    "Yuml",    0x0178,
    "Zeta",    0x0396,
    "aacute",  0x00E1,
    "acirc",   0x00E2,
    "acute",   0x00B4,
    "aelig",   0x00E6,
    "agrave",  0x00E0,
    "alefsym", 0x2135,
    "alpha",   0x03B1,
    "amp",     0x0026,
    "and",     0x2227,
    "ang",     0x2220,
    "aring",   0x00E5,
    "asymp",   0x2248,
    "atilde",  0x00E3,
    "auml",    0x00E4,
    "bdquo",   0x201E,
    "beta",    0x03B2,
    "brvbar",  0x00A6,
    "bull",    0x2022,
    "cap",     0x2229,
    "ccedil",  0x00E7,
    "cedil",   0x00B8,
    "cent",    0x00A2,
    "chi",     0x03C7,
    "circ",    0x02C6,
    "clubs",   0x2663,
    "cong",    0x2245,
    "copy",    0x00A9,
    "crarr",   0x21B5,
    "cup",     0x222A,
    "curren",  0x00A4,
    "dArr",    0x21D3,
    "dagger",  0x2020,
    "darr",    0x2193,
    "deg",     0x00B0,
    "delta",   0x03B4,
    "diams",   0x2666,
    "divide",  0x00F7,
    "eacute",  0x00E9,
    "ecirc",   0x00EA,
    "egrave",  0x00E8,
    "empty",   0x2205,
    "emsp",    0x2003,
    "ensp",    0x2002,
    "epsilon", 0x03B5,
    "equiv",   0x2261,
    "eta",     0x03B7,
    "eth",     0x00F0,
    "euml",    0x00EB,
    "euro",    0x20AC,
    "exist",   0x2203,
    "fnof",    0x0192,
    "forall",  0x2200,
    "frac12",  0x00BD,
    "frac14",  0x00BC,
    "frac34",  0x00BE,
    "frasl",   0x2044,
    "gamma",   0x03B3,
    "ge",      0x2265,
    "gt",      0x003E,
    "hArr",    0x21D4,
    "harr",    0x2194,
    "hearts",  0x2665,
    "hellip",  0x2026,
    "iacute",  0x00ED,
    "icirc",   0x00EE,
    "iexcl",   0x00A1,
    "igrave",  0x00EC,
    "image",   0x2111,
    "infin",   0x221E,
    "int",     0x222B,
    "iota",    0x03B9,
    "iquest",  0x00BF,
    "isin",    0x2208,
    "iuml",    0x00EF,
    "kappa",   0x03BA,
    "lArr",    0x21D0,
    "lambda",  0x03BB,
    "lang",    0x2329,
    "laquo",   0x00AB,
    "larr",    0x2190,
    "lceil",   0x2308,
    "ldquo",   0x201C,
    "le",      0x2264,
    "lfloor",  0x230A,
    "lowast",  0x2217,
    "loz",     0x25CA,
    "lrm",     0x200E,
    "lsaquo",  0x2039,
    "lsquo",   0x2018,
    "lt",      0x003C,
    "macr",    0x00AF,
    "mdash",   0x2014,
    "micro",   0x00B5,
    "middot",  0x00B7,
    "minus",   0x2212,
    "mu",      0x03BC,
    "nabla",   0x2207,
    "nbsp",    0x00A0,
    "ndash",   0x2013,
    "ne",      0x2260,
    "ni",      0x220B,
    "not",     0x00AC,
    "notin",   0x2209,
    "nsub",    0x2284,
    "ntilde",  0x00F1,
    "nu",      0x03BD,
    "oacute",  0x00F3,
    "ocirc",   0x00F4,
    "oelig",   0x0153,
    "ograve",  0x00F2,
    "oline",   0x203E,
    "omega",   0x03C9,
    "omicron", 0x03BF,
    "oplus",   0x2295,
    "or",      0x2228,
    "ordf",    0x00AA,
    "ordm",    0x00BA,
    "oslash",  0x00F8,
    "otilde",  0x00F5,
    "otimes",  0x2297,
    "ouml",    0x00F6,
    "para",    0x00B6,
    "part",    0x2202,
    "permil",  0x2030,
    "perp",    0x22A5,
    "phi",     0x03C6,
    "pi",      0x03C0,
    "piv",     0x03D6,
    "plusmn",  0x00B1,
    "pound",   0x00A3,
    "prime",   0x2032,
    "prod",    0x220F,
    "prop",    0x221D,
    "psi",     0x03C8,
    "quot",    0x0022,
    "rArr",    0x21D2,
    "radic",   0x221A,
    "rang",    0x232A,
    "raquo",   0x00BB,
    "rarr",    0x2192,
    "rceil",   0x2309,
    "rdquo",   0x201D,
    "real",    0x211C,
    "reg",     0x00AE,
    "rfloor",  0x230B,
    "rho",     0x03C1,
    "rlm",     0x200F,
    "rsaquo",  0x203A,
    "rsquo",   0x2019,
    "sbquo",   0x201A,
    "scaron",  0x0161,
    "sdot",    0x22C5,
    "sect",    0x00A7,
    "shy",     0x00AD,
    "sigma",   0x03C3,
    "sigmaf",  0x03C2,
    "sim",     0x223C,
    "spades",  0x2660,
    "sub",     0x2282,
    "sube",    0x2286,
    "sum",     0x2211,
    "sup",     0x2283,
    "sup1",    0x00B9,
    "sup2",    0x00B2,
    "sup3",    0x00B3,
    "supe",    0x2287,
    "szlig",   0x00DF,
    "tau",     0x03C4,
    "there4",  0x2234,
    "theta",   0x03B8,
    "thetasym",0x03D1,
    "thinsp",  0x2009,
    "thorn",   0x00FE,
    "tilde",   0x02DC,
    "times",   0x00D7,
    "trade",   0x2122,
    "uArr",    0x21D1,
    "uacute",  0x00FA,
    "uarr",    0x2191,
    "ucirc",   0x00FB,
    "ugrave",  0x00F9,
    "uml",     0x00A8,
    "upsih",   0x03D2,
    "upsilon", 0x03C5,
    "uuml",    0x00FC,
    "weierp",  0x2118,
    "xi",      0x03BE,
    "yacute",  0x00FD,
    "yen",     0x00A5,
    "yuml",    0x00FF,
    "zeta",    0x03B6,
    "zwj",     0x200D,
    "zwnj",    0x200C,
  };

  const CharEnt * found;
  char            temp[9];
  int             i;

  /* Must end with ';' if in strict mode */

  if (strict)
  {
    for (
          i = 0;

          sequence[i] != ';' &&
          i < 9;

          i++
        )
    {
      if (sequence[i] == '\0') return 0;
      temp[i] = sequence[i];
    }
  }
  else
  {
    for (
          i = 0;

          sequence[i] != '\0' &&
          sequence[i] != ' '  &&
          sequence[i] != ';'  &&

          i < 9;

          i++
        )
        temp[i] = sequence[i];
  }

  temp[i] = '\0';

  /* Having isolated the entity name, see if we recognise it */

  if (strict)
  {
    found = bsearch(temp,
                    char_table,
                    (sizeof char_table) / (sizeof char_table[0]),
                    sizeof char_table[0],
                    entcmpstrict);
  }
  else
  {
    entcmpfuzzy_len   = 0;
    entcmpfuzzy_found = NULL;

    bsearch(temp,
            char_table,
            (sizeof char_table) / (sizeof char_table[0]),
            sizeof char_table[0],
            entcmpfuzzy);

    found = entcmpfuzzy_found;
  }

  /* Did we get a match? */

  if (found)
  {
    *sequencep = sequence + strlen(found->name);
    return found->code;
  }
  else return 0;
}

/********************************************************************/
/* char *__html_unescape_string(char *input, unsigned int strict)   */
/********************************************************************/
/* This function searches for any entities '&name;' or '&#number;'  */
/* and converts them to the relevant characters.                    */
/********************************************************************/

char *__html_unescape_string(char * input, unsigned int strict)
{
  char * ret = input;

  while (*input != '\0')
  {
    if (*input == '&')
        __html_unescape(input, strict);
    input++;
  }
  return ret;
}

/********************************************************************/
/* char *__html_tidy_url(char *url)                                 */
/********************************************************************/
/* Given a URL, this routine will attempt to tidy up all occurances */
/* of ".." and remove the relevant parts of the directory tree      */
/********************************************************************/

#define UPDIR "/../"

char * __html_tidy_url(char * url)
{
  char * s1;
  char * s2;
  char * s3;

  if (!url || !*url) return NULL;

  /* Check for case of link ending in "/.." */

  if (
       strlen(url) >= 3                          &&
       strcmp(url + strlen(url) - 3, "/..") == 0
     )
     strcat(url, "/");

  /* While we still have "/.."s in the input stream */

  while ((s1=strstr(url,UPDIR)) != NULL)
  {
    /* Locate the start of the previous directory */

    *s1 = 0;
    s2  = strrchr(url, '/');
    s3  = strrchr(url, ':');

    s2  = s2 > s3 ? s2 : s3;
    *s1 = '/';

    if (s2 == NULL) return url;

    /* If s2[-1] = '/' we're at '//', as in 'http://'. So don't */
    /* want to strip out the site name, but do need to remove   */
    /* the '/../' from the end.                                 */
    /*                                                          */
    /* This is for the case where there are too many '/../'s in */
    /* a relative URL (which happens quite often, it seems!).   */

    if (s2[-1] == '/') s2 = s1;

    /* Skip over the UPDIR bit */

    s1 += sizeof(UPDIR) - 1;

    /* Blat the remainder of the string onto what we have */

    s2++;
    memmove(s2, s1, strlen(s1) + 1);

    /* Repeat as required! */
  }

  return url;
}

/********************************************************************/
/* char *__html_strip_control_codes(char *s)                        */
/********************************************************************/
/* Strip out all control codes (c>0 & c< 32 && c!=10 && c!=13)      */
/********************************************************************/
void __html_strip_control_codes(char *s)
{
    while (*s)
    {
        if (CTRL_CODE(*s) && *s!='\t')
            *s='?';

        s++;
    }
}

/*************************************************************/
/* char *strincmp(char *sting, char *index, int size)        */
/*************************************************************/
/* Given two strings, look case insensitivly to establish if */
/* the first "size" chars in "string" are "index"	     */
/*************************************************************/
int strincmp(const char *string, const char *index, int size)
{
int d=0;

  while (size-- > 0) {
    d = toupper(*string++) - toupper(*index++);
    if (d != 0) return d;
    if (*string == 0) return 0;     /* no need to check c2 */
    }
  return 0;
}

/*************************************************************/
/* char *stricmp(char *sting, char *index, int size)         */
/*************************************************************/
/* Given two strings, look case insensitivly to establish if */
/* the first "size" chars in "string" are "index"	     */
/*************************************************************/
int stricmp(const char *string, const char *index)
{
int d=0;

  while (1) {
    d = toupper(*string++) - toupper(*index++);
    if (d != 0) return d;
    if (*string == 0) return 0;     /* no need to check c2 */
    }
  return 0;
}

/*************************************************************/
/* char *strnstr(char *sting, char *index, int size          */
/*************************************************************/
/* Given a pointer to a string, and the size of the string,  */
/* look to see if we can find the index char requested.      */
/*************************************************************/
char *strnstr(const char *string, const char *index, int size)
{
int i;
int count=0;

  while(1) {
    for (i=0;; i++) {
      char ch = index[i];
      if (count+i > size) return 0;
      if (ch == 0) return (char *)string;
      if (string[i] != ch) break;
    }
    count++;
    if (count > size) return 0;
    if (*string++ == 0) return 0;
  }
}

/*************************************************************/
/* char *strinstr(char *sting, char *index, int size         */
/*************************************************************/
/* Given a pointer to a string, and the size of the string,  */
/* look to see if we can find the index char requested.      */
/*************************************************************/
char *strinstr(const char *string, const char *index, int size)
{
int i;
int count=0;

  while(1) {
    for (i=0;; i++) {
      char ch = index[i];
      if (ch == 0) return (char *)string;
      if (count+i >= size) return 0;
      if (toupper(string[i]) != toupper(ch)) break;
    }
    count++;
    if (count > size) return 0;
    if (*string++ == 0) return 0;
  }
}

@


1.5
log
@Cleaned up a bit - any remaining build-time warnings are intentional
reminders that something needs attention. Adjusted CC flags as part
of this.

Corrected misleading comments on a couple of functions (a case of
Cut And Paste by the looks of things).

Rewrote element attribute parsing. As far as I can tell this now
behaves just as in Navigator 4.07 - fixed a large number of
reported bugs as a result. On the whole these are usually down to
spurious trailing closing quotes with no matching opening quote,
though there are some rather more exotic cases that now work
as intended.

Now remove CR and LF from attribute values rather than replacing
them with spaces - yet more sites fixed - and strip trailing spaces
from URLs (Ofsted's PDFs are now much easier to download...).
@
text
@d35 1
a35 1
static UCS4 __html_entity_name_to_char(char * *sequencep);
d176 3
d261 1
a261 1
/* static void __html_unescape(char *sequence)                      */
d263 6
a268 4
/* Given a ';' or ' ' space terminated sequence of chars (including */
/* the '&', this routine will return the correct (hopefully)        */
/* ISO-LATIN-1 char for that sequence. The string passed in         */
/* sequence is returned in the modified form.                       */
d271 1
a271 1
static void __html_unescape(char *sequence)
d278 6
d288 1
d317 1
a317 1
    result=__html_entity_name_to_char(&end);
d511 3
a513 4
/* This relies on no known entity being a truncation of another one! */
/* XXXXXX  This is no longer true!!!!! (sup, sup1; theta, thetasym) XXXXXX */
/* /* Fix meeeeeee */
static int entcmp(const void *a, const void *b)
d515 56
a570 1
    return strncmp((const char *) a, (const char *) b, strlen((const char *) b));
d574 2
a575 1
/* char __html_entity_name_to_char(const char * sequence)           */
d577 8
a584 4
/* Given a ';' or ' ' space terminated sequence of chars (including */
/* the '&', this routine will return the correct (hopefully)        */
/* Acorn Extended Latin 1 char for that sequence. The string passed */
/* in sequence is returned in the modified form.                    */
d587 1
a587 1
static UCS4 __html_entity_name_to_char(char ** sequencep)
a588 7
  typedef struct
  {
    char name[9];
    unsigned short code;
  }
  CharEnt;

d593 1
a593 1
   * Draft (8-Jul-1997)
d856 1
a856 2
  for (
        i = 0;
d858 7
a864 4
        sequence[i] != '\0' &&
        sequence[i] != ' '  &&
        sequence[i] != ';'  &&
        i < 9;
d866 4
a869 2
        i++
      )
d871 17
d891 25
a915 5
  found = bsearch(temp,
                  char_table,
                  (sizeof char_table) / (sizeof char_table[0]),
                  sizeof char_table[0],
                  entcmp);
d919 2
a920 2
      *sequencep = sequence + strlen(found->name);
      return found->code;
d922 1
a922 1
  else       return 0;
d926 1
a926 1
/* char *__html_unescape_string(char *input)                        */
d932 1
a932 1
char *__html_unescape_string(char * input)
d939 1
a939 1
        __html_unescape(input);
@


1.4
log
@Euro sign mapping added to display.c's ISO10646 -> Acorn Extended Latin-1
transformation table. HtmlParse can be told whether or not it supports
JavaScript (if so, script callback function is called and <NOSCRIPT> contents
are ignored; else script callback function is not called and <NOSCRIPT> is
parsed, with <SCRIPT> contents just passed through). In veneers.c, names of
parameters to HtmlParse changed to match those in api.h.
@
text
@d417 4
a420 4
      "AaAaAaCcCcCcCcDd–dEeEeEeEeEeGgGg"
      "GgGgHhHhIiIiIiIiIiIiJjKkkLlLlLlL"
      "lLlNnNnNnnNnOoOoOoöõRrRrRrSsSsSs"
      "SsTtTtTtUuUuUuUuUuUuÅÇÖÜYZzZzZzs"
d425 8
a432 8
      "AaBbBbBbCcDdDdDdDdDdEeEeEeEeEeFf"
      "GgHhHhHhHhHhIiIiKkKkKkLlLlLlLlMm"
      "MmNnNnNnNnOoOoOoOoPpPpRrRrRrRrSs"
      "SsSsSsSsSsTtTtTtTtUuUuUuUuUuVvVv"
      "WwWwWwWwWwXxXxYyZzZzZzhtwya?????"
      "AaAaAaAaAaAaAaAaAaAaAaAaEeEeEeEe"
      "EeEeEeEeIiIiOoOoOoOoOoOoOoOoOoOo"
      "OoOoUuUuUuUuUuUuUuYyYyYyYy??????"
d436 2
a437 2
      " ,.\"????""<>´ªêëêë[]??""()[]{}[]~îïñ"
      "?123456789??????~???????????????"
d442 8
a449 8
      "?!\"#$%&'()*+,-./0123456789:;<=>?"
      "@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
      "`abcdefghijklmnopqrstuvwxyz{|}~?"
      "????????????????????????????????"
      "????????????????????????????????"
      "????????????????????????????????"
      "????????????????????????????????"
      "¢£¨Ø¶•W?????????"
d823 2
a824 3
/* This function removes all instances of multiple whitespace and   */
/* replaces them with a single space. Thus CR, LF CTRL-... are      */
/* replaced by a space                                              */
@


1.3
log
@Web branch merged
@
text
@d408 1
@


1.2
log
@Merged in ARTtmp_merge
@
text
@a14 62
/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/display,v $
 *
 * $Log: display,v $
 * Revision 1.1.2.3  1997/04/28 14:20:18  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
 * Revision 1.1.2.2  1997/04/09 16:44:35  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:26:38  kbracey
 * Initial revision
 *
 * Revision 1.3  95/10/31  13:11:18  pwain
 * Moved strdup into this file
 *
 * Revision 1.2  95/10/30  10:25:26  pwain
 * Removed quick and long display code.
 *
 * Revision 1.1  95/10/12  12:46:44  pwain
 * Initial revision
 *
 *
 * --- Original log information ---
 *
 * $Version: networking $
 *
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/display,v $
 *
 * $Log: display,v $
 * Revision 1.1.2.3  1997/04/28 14:20:18  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
 * Revision 1.1.2.2  1997/04/09 16:44:35  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:26:38  kbracey
 * Initial revision
 *
 * Revision 1.3  95/10/31  13:11:18  pwain
 * Moved strdup into this file
 *
 * Revision 1.2  95/10/30  10:25:26  pwain
 * Removed quick and long display code.
 *
 * Revision 1.1  95/10/12  12:46:44  pwain
 * Initial revision
 *
 * Revision 1.2  95/09/26  12:43:03  pwain
 * Added display of alignment to long display code.
 *
 * Revision 1.1  95/09/08  10:06:05  pwain
 * Initial revision
 *
 *
 */

d22 5
a32 1
char * strdup(char *s1);
d35 2
a36 2
static char __html_iso_lat_1_to_char(const char *sequence);
static char __html_number_to_char(char *sequence, int hex);
d62 1
a62 1
  if ((input==NULL) || (*input=='\0')) return 0;
d146 2
d225 1
a225 1
char * strdup(char * s1)
d244 1
a244 1
char * strndup(char * s1, int size)
d269 3
a271 1
  char c, result;
d280 20
a299 1
    result=__html_number_to_char((ptr+2), 0);
d304 2
a305 1
    result=__html_iso_lat_1_to_char(ptr+1);
d314 16
a329 1
    *ptr = result;
d331 2
a332 1
  if (c==';')
a333 2
  else
    *sequence=c;
d335 2
a336 1
  ptr++;
d360 117
d484 1
a484 1
static char __html_number_to_char(char *sequence, int hex)
d486 8
a493 1
  char ch=0;
a494 9
  if (!hex) {
    return (char)atoi(sequence); /* We know that sequence is 0 terminated */
  }
  else {
    while (*sequence != '\0') {
      ch=(char)( ((int)ch*16) + __html_unnumeric_escape(toupper(*sequence)) );
      sequence++;
    }
  }
d498 7
d507 1
a507 1
/* char __html_unescape(char *sequence)                             */
d511 2
a512 2
/* ISO-LATIN-1 char for that sequence. The string passed in         */
/* sequence is returned in the modified form.                       */
d515 1
a515 1
static char __html_iso_lat_1_to_char(const char * sequence)
d519 2
a520 1
    char name[7], code;
d524 6
a529 1
  /* This table comes from ISO 8879, except where commented */
d533 252
a784 116
    "AElig",  198,
    "Aacute", 193,
    "Acirc",  194,
    "Agrave", 192,
    "Aring",  197,
    "Atilde", 195,
    "Auml",   196,
    "Ccedil", 199,
    "Dagger", 157, /* Cougar */
    "ETH",    208,
    "Eacute", 201,
    "Ecirc",  202,
    "Egrave", 200,
    "Euml",   203,
    "Iacute", 205,
    "Icirc",  206,
    "Igrave", 204,
    "Iuml",   207,
    "Ntilde", 209,
    "OElig",  154, /* Cougar */
    "Oacute", 211,
    "Ocirc",  212,
    "Ograve", 210,
    "Oslash", 216,
    "Otilde", 213,
    "Ouml",   214,
    "THORN",  222,
    "Uacute", 218,
    "Ucirc",  219,
    "Ugrave", 217,
    "Uuml",   220,
    "Yacute", 221,
    "aacute", 225,
    "acirc",  226,
    "acute",  180,
    "aelig",  230,
    "agrave", 224,
    "amp",    38,  /* HTML */
    "aring",  229,
    "atilde", 227,
    "auml",   228,
    "bdquo",  150, /* Cougar */
    "bull",   143, /* Cougar */
    "brvbar", 166, /* HTML 3.2 */
    "ccedil", 231,
    "cedil",  184, /* HTML 3.2 */
    "cent",   162, /* HTML 3.2 */
    "copy",   169, /* HTML */
    "curren", 164, /* HTML 3.2 */
    "dagger", 156, /* Cougar */
    "deg",    176, /* HTML 3.2 */
    "divide", 247, /* Cougar */
    "eacute", 233,
    "ecirc",  234,
    "egrave", 232,
    "eth",    240,
    "euml",   235,
    "frac12", 189, /* HTML 3.2 */
    "frac14", 188, /* HTML 3.2 */
    "frac34", 190, /* HTML 3.2 */
    "gt",     62,  /* HTML */
    "iacute", 237,
    "icirc",  238,
    "iexcl",  161, /* HTML 3.2 */
    "igrave", 236,
    "iquest", 191, /* HTML 3.2 */
    "iuml",   239,
    "laquo",  171, /* HTML 3.2 */
    "ldquo",  148, /* Cougar */
    "lsaquo", 146, /* Cougar */
    "lsquo",  144, /* Cougar */
    "lt",     60,  /* HTML */
    "macr",   175, /* HTML 3.2 */
    "mdash",  152, /* Cougar */
    "micro",  181, /* HTML 3.2 */
    "middot", 183, /* HTML 3.2 */
    "minus",  153, /* Cougar */
    "nbsp",   160, /* HTML */
    "ndash",  151, /* Cougar */
    "not",    172, /* HTML 3.2 */
    "ntilde", 241,
    "oacute", 243,
    "ocirc",  244,
    "oelig",  155, /* Cougar */
    "ograve", 242,
    "ordf",   170, /* HTML 3.2 */
    "ordm",   186, /* HTML 3.2 */
    "oslash", 248,
    "otilde", 245,
    "ouml",   246,
    "para",   182, /* HTML 3.2 */
    "permil", 142, /* Cougar */
    "plusmn", 177, /* HTML 3.2 */
    "pound",  163, /* HTML 3.2 */
    "quot",   34,  /* HTML */
    "raquo",  187, /* HTML 3.2 */
    "rdquo",  149, /* Cougar */
    "rsaquo", 147, /* Cougar */
    "rsquo",  145, /* Cougar */
    "reg",    174, /* HTML */
    "sect",   167, /* HTML 3.2 */
    "shy",    173, /* HTML 3.2 */
    "sup2",   178, /* HTML 3.2 */
    "sup3",   179, /* HTML 3.2 */
    "supl",   185, /* HTML 3.2 */
    "szlig",  223,
    "thorn",  254,
    "times",  215, /* Cougar */
    "uacute", 250,
    "ucirc",  251,
    "ugrave", 249,
    "uml",    168, /* HTML 3.2 */
    "uuml",   252,
    "yacute", 253,
    "yen",    165, /* HTML 3.2 */
    "yuml",   255,
d788 1
a788 1
  char            temp[7];
d797 1
a797 1
        i < 7;
d809 1
a809 1
                  (int(*)(const void *, const void *)) strcmp);
d811 5
a815 1
  if (found) return found->code;
d827 1
a827 1
char * __html_unescape_string(char * input)
d833 2
a834 1
    if (*input == '&') __html_unescape(input);
d939 18
a993 1
      if (count+i > size) return 0;
d995 1
@


1.2.2.1
log
@Now handles entities with missing ";"s, eg "RISC&nbspOS".
Handles entities split across parser calls better.
@
text
@d15 62
d93 2
a94 2
static char __html_iso_lat_1_to_char(char * *sequencep);
static char __html_number_to_char(char **sequencep);
a325 1
  char *end;
d334 1
a334 4
    end = ptr + 2;
    result=__html_number_to_char(&end);
    /* Turn TABs into spaces (it'll do for now) */
    if (result == 9) result = 32;
d339 1
a339 2
    end = ptr+1;
    result=__html_iso_lat_1_to_char(&end);
d350 1
a350 4
  *sequence=c;

  sequence = end;
  if (*sequence==';')
d352 2
d386 1
a386 1
static char __html_number_to_char(char **sequencep)
d390 9
a398 4
  ch = atoi(*sequencep); /* We know that sequence is 0 terminated */

  *sequencep += strlen(*sequencep);

a401 5
/* This relies on no known entity being a truncation of another one! */
static int entcmp(const void *a, const void *b)
{
    return strncmp((const char *) a, (const char *) b, strlen((const char *) b));
}
d404 1
a404 1
/* char __html_iso_lat_1_to_char(const char * sequence)             */
d412 1
a412 1
static char __html_iso_lat_1_to_char(char ** sequencep)
a419 2
  char *sequence = *sequencep;

d564 1
a564 1
                  entcmp);
d566 1
a566 5
  if (found)
  {
      *sequencep = sequence + strlen(found->name);
      return found->code;
  }
@


1.2.2.2
log
@Improved comment handling.
Started work on SUB, SUP, U and STRIKE support.
@
text
@d58 1
a58 1
  if ((input==NULL) || (*input=='\0')) return stripleadingspace;
a141 2
    else if (s == ptr)
      lastisspace=stripleadingspace;
@


1.2.2.3
log
@Removed dependence on <HEAD> and <BODY>
@
text
@a468 1
    "reg",    174, /* HTML */
d471 1
@


1.2.2.4
log
@Stopped table code using HStream flags word.
Allowed parsing of <--- Hello ---> style comments.
@
text
@d678 1
a679 1
      if (count+i >= size) return 0;
@


1.2.2.5
log
@Added new external call HtmlRelativiseURL, and added support for hex entities.
@
text
@d28 1
d221 1
a221 1
char * strdup(const char * s1)
d240 1
a240 1
char * strndup(const char * s1, int size)
d334 3
a336 1
  unsigned long ch=0;
a337 5
 /* We know that sequence is 0 terminated */
  if (**sequencep == 'x' || **sequencep == 'X')
      ch = strtoul(*sequencep + 1, NULL, 16);
  else
      ch = strtoul(*sequencep, NULL, 10);
d340 1
a340 1
  return ch < 0x100 ? (char) ch : '?';
@


1.2.2.6
log
@Added translation of codes 128-159 found in string into Latin1, on the
assumption that they are Microsoft Windows CP1252 codes. Also added handling
of these codes in numeric entities, plus support for those codes when entered
correctly as Unicode codes. Also support numeric Unicode entities for our
extra characters (eg W-circumflex=&#x0174;).
@
text
@a323 108
static int iso10646cmp(const void *a, const void *b)
{
    unsigned int key = (unsigned int) a;
    wchar_t *wc = (wchar_t *) b;

    return key - *wc;
}

/********************************************************************/
/* char __html_iso10646_to_latin1(unsigned long ch)                 */
/********************************************************************/
/* Given an ISO 10646 code (or a Microsoft code if in the range     */
/* 128-159), spit out the Acorn Extended Latin-1 equivalent         */
/* escape code, convert this to a single Risc OS char               */
/********************************************************************/
static char __html_iso10646_to_latin1(unsigned long ch)
{
  typedef struct
  {
    wchar_t num;
    char acornlatin1;
  }
  CharEnt;

  /*
   * This table contains transformations from ISO10646 to Acorn
   * Extended Latin-1, and from Microsoft code page 1252.
   *
   * We don't have proper charset support yet, so we assume:
   *   1) The library output will be displayed using an
   *      Acorn Extended Latin-1 font.
   *   2) Hence codes 32-126 and 160-255 are the same as
   *      ISO10646 and CP1252.
   *   3) The input document is encoded using CP1252.
   *   4) Numbered entities that are (erroneously) in the range
   *      128-159 are supposed to be CP1252.
   *   5) De facto standards suck.
   */
  static const CharEnt char_table[] =
  {
        130, ',',  /* Single low-9 quotation mark (U+201A) */
        131, 'f',  /* Latin small letter f with hook (U+0192) */
        132, 'ñ',  /* Double low-9 quotation mark (U+201E) */
        133, 'å',  /* Horizontal ellipsis (U+2026) */
        134, 'ú',  /* Dagger (U+2020) */
        135, 'ù',  /* Double dagger (U+2021) */
        136, '^',  /* Modifier letter circumflex accent (U+02C6) */
        137, 'é',  /* Per mille sign (U+2030) */
        138, 'S',  /* Latin capital letter S with caron (U+0160) */
        139, 'í',  /* Single left-pointing angle quotation mark (U+2039) */
        140, 'ö',  /* Latin capital ligature OE (U+0152) */
        145, 'ê',  /* Left single quotation mark (U+2018) */
        146, 'ë',  /* Right single quotation mark (U+2019) */
        147, 'î',  /* Left double quotation mark (U+201C) */
        148, 'ï',  /* Right double quotation mark (U+201D) */
        149, 'è',  /* Bullet (U+2022) */
        150, 'ó',  /* En dash (U+2013) */
        151, 'ò',  /* Em dash (U+2014) */
        152, '~',  /* Small tilde (U+02DC) */
        153, 'ç',  /* Trade mark sign (U+2122) */
        154, 's',  /* Latin small letter s with caron (U+0161) */
        155, 'ì',  /* Single right pointing angle quotation mark (U+203A) */
        156, 'õ',  /* Latin small ligature oe (U+0153) */
        159, 'Y',  /* Latin capital letter Y with diaresis (U+0178) */
     0x0152, 'ö',  /* Latin capital ligature OE */
     0x0153, 'õ',  /* Latin small ligature oe */
     0x0160, 'S',  /* Latin capital letter S with caron */
     0x0161, 's',  /* Latin small letter s with caron */
     0x0174, 'Å',  /* Latin capital letter W with circumflex */
     0x0175, 'Ç',  /* Latin small letter w with circumflex */
     0x0176, 'Ö',  /* Latin capital letter Y with circumflex */
     0x0177, 'Ü',  /* Latin small letter y with circumflex */
     0x0178, 'Y',  /* Latin capital letter Y with diaresis */
     0x0192, 'f',  /* Latin small letter f with hook */
     0x02C6, '^',  /* Modifier letter circumflex accent */
     0x02DC, '~',  /* Small tilde */
     0x2013, 'ó',  /* En dash */
     0x2014, 'ò',  /* Em dash */
     0x2018, 'ê',  /* Left single quotation mark */
     0x2019, 'ë',  /* Right single quotation mark */
     0x201A, ',',  /* Single low-9 quotation mark */
     0x201C, 'î',  /* Left double quotation mark */
     0x201D, 'ï',  /* Right double quotation mark */
     0x201E, 'ñ',  /* Double low-9 quotation mark */
     0x2020, 'ú',  /* Dagger */
     0x2021, 'ù',  /* Double dagger */
     0x2022, 'è',  /* Bullet */
     0x2026, 'å',  /* Horizontal ellipsis */
     0x2030, 'é',  /* Per mille sign */
     0x2039, 'í',  /* Single left-pointing angle quotation mark */
     0x203A, 'ì',  /* Single right pointing angle quotation mark */
     0x2122, 'ç',  /* Trade mark sign */
     0x2212, 'ô',  /* Minus sign */
     0xFB01, 'û',  /* Latin small ligature fi */
     0xFB02, 'ü',  /* Latin small ligature fl */
  };

  CharEnt *cent = bsearch((const void *) ch,
                          char_table,
                          (sizeof char_table) / (sizeof char_table[0]),
                          sizeof char_table[0],
                          iso10646cmp);

  return cent                                ? cent->acornlatin1 :
         (ch < 127 || (ch > 160 && ch < 256) ? (char) ch :
         '?');
}

d342 1
a342 1
  return __html_iso10646_to_latin1(ch);
a404 1
    "Wcirc",  129, /* Invented */
a405 1
    "Ycirc",  133, /* Invented */
a486 1
    "wcirc",  130, /* Invented */
a487 1
    "ycirc",  134, /* Invented */
d532 1
a532 1
char *__html_unescape_string(char * input)
d538 1
a538 4
    if (*input == '&')
        __html_unescape(input);
    else if (*input >= 128 && *input < 160)
        *input = __html_iso10646_to_latin1(*input);
@


1.2.2.7
log
@Fixed &#160;, fixed option selection, changed GOT_MORE flag
@
text
@d427 2
a428 2
  return cent                                 ? cent->acornlatin1 :
         (ch < 127 || (ch >= 160 && ch < 256) ? (char) ch :
@


1.2.2.8
log
@Fixed FRAME and FRAMESET border attributes
@
text
@d30 1
a30 1
static char __html_entity_name_to_char(char * *sequencep);
d283 1
a283 1
    result=__html_entity_name_to_char(&end);
a453 2
/* XXXXXX  This is no longer true!!!!! (sup, sup1; theta, thetasym) XXXXXX */
/* /* Fix meeeeeee */
d460 1
a460 1
/* char __html_entity_name_to_char(const char * sequence)           */
d464 2
a465 2
/* Acorn Extended Latin 1 char for that sequence. The string passed */
/* in sequence is returned in the modified form.                    */
d468 1
a468 1
static char __html_entity_name_to_char(char ** sequencep)
d472 1
a472 2
    char name[9];
    unsigned short code;
d478 1
a478 4
  /*
   * This table comes from the W3C HTML 4.0 Specification Working
   * Draft (8-Jul-1997)
   */
d482 120
a601 251
    "AElig",   0x00C6,
    "Aacute",  0x00C1,
    "Acirc",   0x00C2,
    "Agrave",  0x00C0,
    "Alpha",   0x0391,
    "Aring",   0x00C5,
    "Atilde",  0x00C3,
    "Auml",    0x00C4,
    "Beta",    0x0392,
    "Ccedil",  0x00C7,
    "Chi",     0x03A7,
    "Dagger",  0x2021,
    "Delta",   0x0394,
    "ETH",     0x00D0,
    "Eacute",  0x00C9,
    "Ecirc",   0x00CA,
    "Egrave",  0x00C8,
    "Epsilon", 0x0395,
    "Eta",     0x0397,
    "Euml",    0x00CB,
    "Gamma",   0x0393,
    "Iacute",  0x00CD,
    "Icirc",   0x00CE,
    "Igrave",  0x00CC,
    "Iota",    0x0399,
    "Iuml",    0x00CF,
    "Kappa",   0x039A,
    "Lambda",  0x039B,
    "Mu",      0x039C,
    "Ntilde",  0x00D1,
    "Nu",      0x039D,
    "OElig",   0x0152,
    "Oacute",  0x00D3,
    "Ocirc",   0x00D4,
    "Ograve",  0x00D2,
    "Omega",   0x03A9,
    "Omicron", 0x039F,
    "Oslash",  0x00D8,
    "Otilde",  0x00D5,
    "Ouml",    0x00D6,
    "Phi",     0x03A6,
    "Pi",      0x03A0,
    "Prime",   0x2033,
    "Psi",     0x03A8,
    "Rho",     0x03A1,
    "Scaron",  0x0160,
    "Sigma",   0x03A3,
    "THORN",   0x00DE,
    "Tau",     0x03A4,
    "Theta",   0x0398,
    "Uacute",  0x00DA,
    "Ucirc",   0x00DB,
    "Ugrave",  0x00D9,
    "Upsilon", 0x03A5,
    "Uuml",    0x00DC,
    "Xi",      0x039E,
    "Yacute",  0x00DD,
    "Yuml",    0x0178,
    "Zeta",    0x0396,
    "aacute",  0x00E1,
    "acirc",   0x00E2,
    "acute",   0x00B4,
    "aelig",   0x00E6,
    "agrave",  0x00E0,
    "alefsym", 0x2135,
    "alpha",   0x03B1,
    "amp",     0x0026,
    "and",     0x2227,
    "ang",     0x2220,
    "aring",   0x00E5,
    "asymp",   0x2248,
    "atilde",  0x00E3,
    "auml",    0x00E4,
    "bdquo",   0x201E,
    "beta",    0x03B2,
    "brvbar",  0x00A6,
    "bull",    0x2022,
    "cap",     0x2229,
    "ccedil",  0x00E7,
    "cedil",   0x00B8,
    "cent",    0x00A2,
    "chi",     0x03C7,
    "circ",    0x02C6,
    "clubs",   0x2663,
    "cong",    0x2245,
    "copy",    0x00A9,
    "crarr",   0x21B5,
    "cup",     0x222A,
    "curren",  0x00A4,
    "dArr",    0x21D3,
    "dagger",  0x2020,
    "darr",    0x2193,
    "deg",     0x00B0,
    "delta",   0x03B4,
    "diams",   0x2666,
    "divide",  0x00F7,
    "eacute",  0x00E9,
    "ecirc",   0x00EA,
    "egrave",  0x00E8,
    "empty",   0x2205,
    "emsp",    0x2003,
    "ensp",    0x2002,
    "epsilon", 0x03B5,
    "equiv",   0x2261,
    "eta",     0x03B7,
    "eth",     0x00F0,
    "euml",    0x00EB,
    "exist",   0x2203,
    "fnof",    0x0192,
    "forall",  0x2200,
    "frac12",  0x00BD,
    "frac14",  0x00BC,
    "frac34",  0x00BE,
    "frasl",   0x2044,
    "gamma",   0x03B3,
    "ge",      0x2265,
    "gt",      0x003E,
    "hArr",    0x21D4,
    "harr",    0x2194,
    "hearts",  0x2665,
    "hellip",  0x2026,
    "iacute",  0x00ED,
    "icirc",   0x00EE,
    "iexcl",   0x00A1,
    "igrave",  0x00EC,
    "image",   0x2111,
    "infin",   0x221E,
    "int",     0x222B,
    "iota",    0x03B9,
    "iquest",  0x00BF,
    "isin",    0x2208,
    "iuml",    0x00EF,
    "kappa",   0x03BA,
    "lArr",    0x21D0,
    "lambda",  0x03BB,
    "lang",    0x2329,
    "laquo",   0x00AB,
    "larr",    0x2190,
    "lceil",   0x2308,
    "ldquo",   0x201C,
    "le",      0x2264,
    "lfloor",  0x230A,
    "lowast",  0x2217,
    "loz",     0x25CA,
    "lrm",     0x200E,
    "lsaquo",  0x2039,
    "lsquo",   0x2018,
    "lt",      0x003C,
    "macr",    0x00AF,
    "mdash",   0x2014,
    "micro",   0x00B5,
    "middot",  0x00B7,
    "minus",   0x2212,
    "mu",      0x03BC,
    "nabla",   0x2207,
    "nbsp",    0x00A0,
    "ndash",   0x2013,
    "ne",      0x2260,
    "ni",      0x220B,
    "not",     0x00AC,
    "notin",   0x2209,
    "nsub",    0x2284,
    "ntilde",  0x00F1,
    "nu",      0x03BD,
    "oacute",  0x00F3,
    "ocirc",   0x00F4,
    "oelig",   0x0153,
    "ograve",  0x00F2,
    "oline",   0x203E,
    "omega",   0x03C9,
    "omicron", 0x03BF,
    "oplus",   0x2295,
    "or",      0x2228,
    "ordf",    0x00AA,
    "ordm",    0x00BA,
    "oslash",  0x00F8,
    "otilde",  0x00F5,
    "otimes",  0x2297,
    "ouml",    0x00F6,
    "para",    0x00B6,
    "part",    0x2202,
    "permil",  0x2030,
    "perp",    0x22A5,
    "phi",     0x03C6,
    "pi",      0x03C0,
    "piv",     0x03D6,
    "plusmn",  0x00B1,
    "pound",   0x00A3,
    "prime",   0x2032,
    "prod",    0x220F,
    "prop",    0x221D,
    "psi",     0x03C8,
    "quot",    0x0022,
    "rArr",    0x21D2,
    "radic",   0x221A,
    "rang",    0x232A,
    "raquo",   0x00BB,
    "rarr",    0x2192,
    "rceil",   0x2309,
    "rdquo",   0x201D,
    "real",    0x211C,
    "reg",     0x00AE,
    "rfloor",  0x230B,
    "rho",     0x03C1,
    "rlm",     0x200F,
    "rsaquo",  0x203A,
    "rsquo",   0x2019,
    "sbquo",   0x201A,
    "scaron",  0x0161,
    "sdot",    0x22C5,
    "sect",    0x00A7,
    "shy",     0x00AD,
    "sigma",   0x03C3,
    "sigmaf",  0x03C2,
    "sim",     0x223C,
    "spades",  0x2660,
    "sub",     0x2282,
    "sube",    0x2286,
    "sum",     0x2211,
    "sup",     0x2283,
    "sup1",    0x00B9,
    "sup2",    0x00B2,
    "sup3",    0x00B3,
    "supe",    0x2287,
    "szlig",   0x00DF,
    "tau",     0x03C4,
    "there4",  0x2234,
    "theta",   0x03B8,
    "thetasym",0x03D1,
    "thinsp",  0x2009,
    "thorn",   0x00FE,
    "tilde",   0x02DC,
    "times",   0x00D7,
    "trade",   0x2122,
    "uArr",    0x21D1,
    "uacute",  0x00FA,
    "uarr",    0x2191,
    "ucirc",   0x00FB,
    "ugrave",  0x00F9,
    "uml",     0x00A8,
    "upsih",   0x03D2,
    "upsilon", 0x03C5,
    "uuml",    0x00FC,
    "weierp",  0x2118,
    "xi",      0x03BE,
    "yacute",  0x00FD,
    "yen",     0x00A5,
    "yuml",    0x00FF,
    "zeta",    0x03B6,
    "zwj",     0x200D,
    "zwnj",    0x200C,
d605 1
a605 1
  char            temp[9];
d614 1
a614 1
        i < 9;
d631 1
a631 1
      return __html_iso10646_to_latin1(found->code);
@


1.2.2.9
log
@Some Unicode support added (#ifdefed out). Table cells now have parent rows.
@
text
@a21 5
#ifdef UNIFONT
#include "iso10646.h"
#include "utf8.h"
#endif

a29 4
#ifdef UNIFONT
static UCS4 __html_entity_name_to_char(char * *sequencep);
static UCS4 __html_number_to_char(char **sequencep);
#else
a31 1
#endif
d264 1
a264 6
  char c;
  #ifdef UNIFONT
  UCS4 result;
  #else
  char result;
  #endif
d292 1
a292 14
#ifdef UNIFONT
    /*
     * Assumption here is that no entity can produce a UTF sequence
     * longer than itself. True for numeric entities and should
     * remain true for named entities, as long as:
     * All entities &x;  ->  <= 0x7FF
     * All entities &xx; ->  <= 0xFFFF
     * All entities &xxx; ->   <= 0x1FFFFF
     * All entities &xxxx; ->   <= 0x3FFFFFF
     */
    ptr = UCS4_to_UTF8(ptr, result);
#else
    *ptr++ = result;
#endif
d300 1
a300 2
  if (ptr == sequence)
    return;
a323 1
#ifndef UNIFONT
a430 1
#endif
a438 3
#ifdef UNIFONT
static UCS4 __html_number_to_char(char **sequencep)
#else
a439 1
#endif
a449 3
#ifdef UNIFONT
  return (UCS4) ch;
#else
a450 1
#endif
a469 3
#ifdef UNIFONT
static UCS4 __html_entity_name_to_char(char ** sequencep)
#else
a470 1
#endif
a767 3
      #ifdef UNIFONT
      return found->code;
      #else
a768 1
      #endif
a788 1
#ifndef UNIFONT
a790 1
#endif
@


1.2.2.10
log
@Encoding support added (yippee). #define UNIFONT to get UTF-8 output,
otherwise Latin-1 output is provided. Lots of encoding files...
@
text
@d22 1
a23 1
#ifdef UNIFONT
d35 1
d38 4
d275 1
d277 3
d319 1
a319 1
    *ptr++ = __html_iso10646_to_latin1(result);
d353 1
d365 3
a367 2
/* Given an ISO 10646 code, spit out the Acorn Extended Latin-1     */
/* equivalent.                                                      */
d369 1
a369 1
char __html_iso10646_to_latin1(UCS4 ch)
d380 11
a390 1
   * Extended Latin-1.
d394 33
d451 9
a459 23
  static char latinexta[0x80] =
  {
      "AaAaAaCcCcCcCcDd–dEeEeEeEeEeGgGg"
      "GgGgHhHhIiIiIiIiIiIiJjKkkLlLlLlL"
      "lLlNnNnNnnNnOoOoOoöõRrRrRrSsSsSs"
      "SsTtTtTtUuUuUuUuUuUuÅÇÖÜYZzZzZzs"
  };

  CharEnt *cent;

  if (ch < 128 || ch >= 160 && ch < 256)
      return (char) ch;

  if (ch >= 0x0100 && ch < 0x0180)
      return latinexta[ch - 0x100];

  cent = bsearch((const void *) ch,
                 char_table,
                 (sizeof char_table) / (sizeof char_table[0]),
                 sizeof char_table[0],
                 iso10646cmp);

  return cent ? cent->acornlatin1 : '?';
d461 1
d470 1
d472 3
d476 1
a476 1
  UCS4 ch;
d480 1
a480 1
      ch = (UCS4) strtoul(*sequencep + 1, NULL, 16);
d482 1
a482 1
      ch = (UCS4) strtoul(*sequencep, NULL, 10);
d485 5
a489 1
  return ch;
d509 1
d511 3
d811 1
d813 3
d836 4
@


1.2.2.11
log
@Turned off CUSTOMER_SPECIAL.
Changed encoding tables to use FFFF as a null value instead of FFFD.
Added OBJECT support (more testing required - PARAM not yet done).
Added AREA support (commented out - MAP not yet done). They come out
looking like <A></A> elements.
Souped up mapping to Latin-1 (added lossy tables for Latin Extended
Additional, CJK Punctuation and Fullwidth forms).
Added support for <H1 align=...>
Stripped some superfluous whitespace caused by linefeeds.
Fixed missing linebreak in "<DT>One<DT>Two" by turning the second DT into
a BR.
Removed now unnecessary free(malloc(16384)) bodge.
Put in CJK code even if UNIFONT not defined (hey - why not?).
Added code to take direct pointer to table rather than loading it if
it's in ResourceFS.
Added support for encoding "x-acorn-latin1".
Ensured correct handling of OPTIONs when UNIFONT not defined.
@
text
@a404 29
  static char latinextadd[0x100] =
  {
      "AaBbBbBbCcDdDdDdDdDdEeEeEeEeEeFf"
      "GgHhHhHhHhHhIiIiKkKkKkLlLlLlLlMm"
      "MmNnNnNnNnOoOoOoOoPpPpRrRrRrRrSs"
      "SsSsSsSsSsTtTtTtTtUuUuUuUuUuVvVv"
      "WwWwWwWwWwXxXxYyZzZzZzhtwya?????"
      "AaAaAaAaAaAaAaAaAaAaAaAaEeEeEeEe"
      "EeEeEeEeIiIiOoOoOoOoOoOoOoOoOoOo"
      "OoOoUuUuUuUuUuUuUuYyYyYyYy??????"
  };
  static char cjksymb[0x40] =
  {
      " ,.\"????""<>´ªêëêë[]??""()[]{}[]~îïñ"
      "?123456789??????~???????????????"
  };

  static char fullwidth[0xF0] =
  {
      "?!\"#$%&'()*+,-./0123456789:;<=>?"
      "@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
      "`abcdefghijklmnopqrstuvwxyz{|}~?"
      "????????????????????????????????"
      "????????????????????????????????"
      "????????????????????????????????"
      "????????????????????????????????"
      "¢£¨Ø¶•W?????????"
  };

a411 9

  if (ch >= 0x1E00 && ch < 0x1F00)
      return latinextadd[ch - 0x1E00];

  if (ch >= 0x3000 && ch < 0x3040)
      return cjksymb[ch - 0x3000];

  if (ch >= 0xFF00 && ch < 0xFFF0)
      return fullwidth[ch - 0xFF00];
@


1.2.2.12
log
@Added apostrophe (U+02BC) to Unicode->Latin1 list.
Added &euro; entity to name list.
Fixed UNIFONT compile version.
@
text
@a373 1
     0x02BC, 'ë',  /* Modifier letter apostrophe */
a622 1
    "euro",    0x20AC,
@


1.2.2.13
log
@MAP and AREA handling - first attempt
@
text
@a922 18
/* char *stricmp(char *sting, char *index, int size)         */
/*************************************************************/
/* Given two strings, look case insensitivly to establish if */
/* the first "size" chars in "string" are "index"	     */
/*************************************************************/
int stricmp(const char *string, const char *index)
{
int d=0;

  while (1) {
    d = toupper(*string++) - toupper(*index++);
    if (d != 0) return d;
    if (*string == 0) return 0;     /* no need to check c2 */
    }
  return 0;
}

/*************************************************************/
@


1.2.2.14
log
@Modified to use external Unicode resources and UnicodeLib.
@
text
@d22 1
a22 1
#include "Unicode/iso10646.h"
d24 1
a24 1
#include "Unicode/utf8.h"
@


1.2.2.15
log
@MS_TO_UNICODE_HACK definition in __html_unescape to handle chars 128-159
@
text
@a281 16

    #define MS_TO_UNICODE_HACK

    #ifdef MS_TO_UNICODE_HACK
    /* "Microsoft Unicode" -> Unicode translation table */
    if (result >= 0x80 && result <= 0x9F)
    {
        static const UCS2 ms_hack[] = {
            0x0080, 0x0081, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
            0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008D, 0x008E, 0x008F,
            0x0090, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
            0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x009D, 0x009E, 0x0178
        };
        result = ms_hack[result-0x80];
    }
    #endif
@


1.1
log
@file display was initially added on branch ARTtmp.
@
text
@d1 735
@


1.1.2.1
log
@Initial revision
@
text
@a0 640
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source: /ax/networking:Phileas/HTML/c/display: $
 *
 * $Log:	display,v $
 * Revision 1.3  95/10/31  13:11:18  pwain
 * Moved strdup into this file
 *
 * Revision 1.2  95/10/30  10:25:26  pwain
 * Removed quick and long display code.
 *
 * Revision 1.1  95/10/12  12:46:44  pwain
 * Initial revision
 *
 *
 * --- Original log information ---
 *
 * $Version: networking $
 *
 * $Source: /ax/networking:Phileas/HTML/c/display: $
 *
 * $Log:	display,v $
 * Revision 1.3  95/10/31  13:11:18  pwain
 * Moved strdup into this file
 *
 * Revision 1.2  95/10/30  10:25:26  pwain
 * Removed quick and long display code.
 *
 * Revision 1.1  95/10/12  12:46:44  pwain
 * Initial revision
 *
 * Revision 1.2  95/09/26  12:43:03  pwain
 * Added display of alignment to long display code.
 *
 * Revision 1.1  95/09/08  10:06:05  pwain
 * Initial revision
 *
 *
 */

#include "html2_ext.h"
#include "tags.h"
#include "struct.h"
#include "string.h"
#include "internal.h"
#include "stdio.h"

char * __html_strip_spaces(char *input, int stripleadingcr);
char * __html_strip_lfs(char *input);
char * strdup(char *s1);
char * __html_tidy_url(char *url);
int __html_unnumeric_escape(char ch);
static char __html_iso_lat_1_to_char(const char *sequence);
static char __html_number_to_char(char *sequence, int hex);


/********************************************************************/
/* char *__html_strip_spaces(char *input, int stripleadingcr)       */
/********************************************************************/
/* This function removes all instances of multiple whitespace and   */
/* replaces them with a single space. Thus CR, LF CTRL-... are      */
/* replaced by a space                                              */
/********************************************************************/
char *__html_strip_spaces(char *input, int stripleadingcr)
{
char *s,*ptr;

/*
 * Avoid muck situation we know about
 */
  if ((input==NULL) || (*input=='\0')) return input;

  ptr=s=input;
#ifdef DEBUG
  Printf("Striping spaces:\n");
  Printf("Input : '%s'\n",input);
#endif

/*
 * First off, if the input sequence starts with chars that are
 * under 32 (a space), e.g. new lines, jump over these straigt off
 * to make the output look a bit better!
 */
if (stripleadingcr)
{
  while ((*input > 0) && (*input < 32)) input++;
  if (*input==0) {
    *ptr='\0';
    return ptr;
  }
}


/* Turn all initial spaces into a single space */
  while (isspace(*input) && isspace(*(input+1))) input++;

/*
 * Now loop down the string stripping out any non-ascii chars
 * and turn them into spaces.
 */
  while (*input != '\0') {
    if (*input <= 32) {
      while ((*input <= 32) && (*input != '\0')) {
/* Step over all chars less than or a space */
	input++;
/* Replace them with a single space */
/*
        *s=' ';
        s++;
*/
      }
      *s=' ';
      s++;
    }

/* At this point we know that *input is not a space so we can snarf it */
    *s=*input;
    if (*s != '\0') {
      s++;
      input++;
    }
  }

  *s='\0';

#ifdef DEBUG
  Printf("Output: '%s'\n", ptr);
#endif

/* And return */
  return ptr;
}

/********************************************************************/
/* char *__html_strip_lfs(char *input)                              */
/********************************************************************/
/* This function removes all instances LF in the input stream to    */
/* enable the front end to only have to deal with CRs  	      	    */
/********************************************************************/
#define CR '\r'
#define LF '\n'
char *__html_strip_lfs(char *input)
{
char *s1=input, *s2=input;

  if(!input || !*input) return input;

  while (*s1 != '\0') {
/* Are we pointing at a CR */
    while (*s1==CR)
    {
        if (*(s1+1)==LF)         /* Turn CRLF into LF */
        {
            *s2=LF;
            s1+=2;
            s2+=1;
        }
        else
        {
            *s2=LF;              /* Turn CR into LF */
            s1++;
            s2++;
        }
    }
/* Now we know we arent */

    /* Deal with tabs - this should pad to 8 chars */
    if (*s1 == '\t')
        *s2=' ';
    else
        *s2=*s1;
    s1++; s2++;
  }
/* Ensure we terminate s2 */
  *s2=*s1;

/* Return the string */
  return input;
}

/********************************************************************/
/* char *strdup(char *s1)                                           */
/********************************************************************/
/* strdup stand for "STRing DUPlicate". Go figure :) This returns a */
/* copy of s1 on success or a NULL pointer on failure               */
/********************************************************************/

char * strdup(char * s1)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = (char *) __html_malloc(strlen(s1) + 1, 1);

  if (s2 == NULL) return NULL;

  return strcpy(s2, s1);
}

/********************************************************************/
/* char *strndup(char *s1, int size)                                */
/********************************************************************/
/* Same as strdup except that the amount of bytes to copy is known  */
/********************************************************************/

char * strndup(char * s1, int size)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = (char *) __html_malloc(size + 1, sizeof(char)); /* +1 to be safe? */

  if (s2 == NULL) return NULL;

  return (char *) memcpy(s2, s1, size);
}

/********************************************************************/
/* static void __html_unescape(char *sequence)                      */
/********************************************************************/
/* Given a ';' or ' ' space terminated sequence of chars (including */
/* the '&', this routine will return the correct (hopefully)        */
/* ISO-LATIN-1 char for that sequence. The string passed in         */
/* sequence is returned in the modified form.                       */
/********************************************************************/

static void __html_unescape(char *sequence)
{
  char *ptr=sequence;
  char c, result;

  while (isalnum(*sequence) || *sequence=='#' || *sequence=='&') {
    sequence++;
  }

  c=*sequence; *sequence='\0';

  if (*(ptr+1) == '#') { /* Decimal numeric escape */
    result=__html_number_to_char((ptr+2), 0);
    if (result < 32 || result == 127)
        result = 0;
  }
  else {
    result=__html_iso_lat_1_to_char(ptr+1);
  }

  if (result == 0)
  {
    *sequence=c;
    return;             /* We don't recognise it as a valid thingy, so exit */
  }
  else
    *ptr = result;

  if (c==';')
    sequence++;
  else
    *sequence=c;

  ptr++;

  while (*sequence != '\0') {
    *ptr=*sequence;
    ptr++;
    sequence++;
  }
  *ptr='\0';
}

/********************************************************************/
/* static int __html_unhex(char ch)                                 */
/********************************************************************/
/* Given a single char return its integer value as if it were a hex */
/* digit.                                                           */
/********************************************************************/

int __html_unnumeric_escape(char ch)
{
    if ((ch >= '0') && (ch <= '9')) return ((int)ch-'0'); /* 0 to 9 */
    if ((ch >= 'A') && (ch <= 'F')) return ((int)ch-'A'+10); /* 10 to 15 */
    return 0;
}

/********************************************************************/
/* char __html_hex_to_char(char *sequence)                          */
/********************************************************************/
/* Given a char sequence that is known to be an ISO-LATIN-1 hex     */
/* escape code, convert this to a single Risc OS char               */
/********************************************************************/

static char __html_number_to_char(char *sequence, int hex)
{
  char ch=0;

  if (!hex) {
    return (char)atoi(sequence); /* We know that sequence is 0 terminated */
  }
  else {
    while (*sequence != '\0') {
      ch=(char)( ((int)ch*16) + __html_unnumeric_escape(toupper(*sequence)) );
      sequence++;
    }
  }
  return ch;
}


/********************************************************************/
/* char __html_unescape(char *sequence)                             */
/********************************************************************/
/* Given a ';' or ' ' space terminated sequence of chars (including */
/* the '&', this routine will return the correct (hopefully)        */
/* ISO-LATIN-1 char for that sequence. The string passed in         */
/* sequence is returned in the modified form.                       */
/********************************************************************/

static char __html_iso_lat_1_to_char(const char * sequence)
{
  typedef struct
  {
    char name[7], code;
  }
  CharEnt;

  /* This table comes from ISO 8879, except where commented */

  static const CharEnt char_table[] =
  {
    "AElig",  198,
    "Aacute", 193,
    "Acirc",  194,
    "Agrave", 192,
    "Aring",  197,
    "Atilde", 195,
    "Auml",   196,
    "Ccedil", 199,
    "ETH",    208,
    "Eacute", 201,
    "Ecirc",  202,
    "Egrave", 200,
    "Euml",   203,
    "Iacute", 205,
    "Icirc",  206,
    "Igrave", 204,
    "Iuml",   207,
    "Ntilde", 209,
    "Oacute", 211,
    "Ocirc",  212,
    "Ograve", 210,
    "Oslash", 216,
    "Otilde", 213,
    "Ouml",   214,
    "THORN",  222,
    "Uacute", 218,
    "Ucirc",  219,
    "Ugrave", 217,
    "Uuml",   220,
    "Yacute", 221,
    "aacute", 225,
    "acirc",  226,
    "acute",  180,
    "aelig",  230,
    "agrave", 224,
    "amp",    38,  /* HTML */
    "aring",  229,
    "atilde", 227,
    "auml",   228,
    "brvbar", 166, /* HTML 3.2 */
    "ccedil", 231,
    "cedil",  184, /* HTML 3.2 */
    "cent",   162, /* HTML 3.2 */
    "copy",   169, /* HTML */
    "curren", 164, /* HTML 3.2 */
    "deg",    176, /* HTML 3.2 */
    "eacute", 233,
    "ecirc",  234,
    "egrave", 232,
    "eth",    240,
    "euml",   235,
    "frac12", 189, /* HTML 3.2 */
    "frac14", 188, /* HTML 3.2 */
    "frac34", 190, /* HTML 3.2 */
    "gt",     62,  /* HTML */
    "iacute", 237,
    "icirc",  238,
    "iexcl",  161, /* HTML 3.2 */
    "igrave", 236,
    "iquest", 191, /* HTML 3.2 */
    "iuml",   239,
    "laquo",  171, /* HTML 3.2 */
    "lt",     60,  /* HTML */
    "macr",   175, /* HTML 3.2 */
    "micro",  181, /* HTML 3.2 */
    "middot", 183, /* HTML 3.2 */
    "nbsp",   160, /* HTML */
    "not",    172, /* HTML 3.2 */
    "ntilde", 241,
    "oacute", 243,
    "ocirc",  244,
    "ograve", 242,
    "ordf",   170, /* HTML 3.2 */
    "ordm",   186, /* HTML 3.2 */
    "oslash", 248,
    "otilde", 245,
    "ouml",   246,
    "para",   182, /* HTML 3.2 */
    "plusmn", 177, /* HTML 3.2 */
    "pound",  163, /* HTML 3.2 */
    "quot",   34,  /* HTML */
    "raquo",  187, /* HTML 3.2 */
    "reg",    174, /* HTML */
    "sect",   167, /* HTML 3.2 */
    "shy",    173, /* HTML 3.2 */
    "sup2",   178, /* HTML 3.2 */
    "sup3",   179, /* HTML 3.2 */
    "supl",   185, /* HTML 3.2 */
    "szlig",  223,
    "thorn",  254,
    "uacute", 250,
    "ucirc",  251,
    "ugrave", 249,
    "uml",    168, /* HTML 3.2 */
    "uuml",   252,
    "yacute", 253,
    "yen",    165, /* HTML 3.2 */
    "yuml",   255,
  };

  const CharEnt * found;
  char            temp[7];
  int             i;

  for (
        i = 0;

        sequence[i] != '\0' &&
        sequence[i] != ' '  &&
        sequence[i] != ';'  &&
        i < 7;

        i++
      )
      temp[i] = sequence[i];

  temp[i] = '\0';

  found = bsearch(temp,
                  char_table,
                  (sizeof char_table) / (sizeof char_table[0]),
                  sizeof char_table[0],
                  (int(*)(const void *, const void *)) strcmp);

  if (found) return found->code;
  else       return 0;
}

/********************************************************************/
/* char *__html_unescape_string(char *input)                        */
/********************************************************************/
/* This function removes all instances of multiple whitespace and   */
/* replaces them with a single space. Thus CR, LF CTRL-... are      */
/* replaced by a space                                              */
/********************************************************************/

char * __html_unescape_string(char * input)
{
  char * ret = input;

  while (*input != '\0')
  {
    if (*input == '&') __html_unescape(input);
    input++;
  }
  return ret;
}

/********************************************************************/
/* char *__html_tidy_url(char *url)                                 */
/********************************************************************/
/* Given a URL, this routine will attempt to tidy up all occurances */
/* of ".." and remove the relevant parts of the directory tree      */
/********************************************************************/

#define UPDIR "/../"

char * __html_tidy_url(char * url)
{
  char * s1;
  char * s2;
  char * s3;

  if (!url || !*url) return NULL;

  /* Check for case of link ending in "/.." */

  if (
       strlen(url) >= 3                          &&
       strcmp(url + strlen(url) - 3, "/..") == 0
     )
     strcat(url, "/");

  /* While we still have "/.."s in the input stream */

  while ((s1=strstr(url,UPDIR)) != NULL)
  {
    /* Locate the start of the previous directory */

    *s1 = 0;
    s2  = strrchr(url, '/');
    s3  = strrchr(url, ':');

    s2  = s2 > s3 ? s2 : s3;
    *s1 = '/';

    if (s2 == NULL) return url;

    /* If s2[-1] = '/' we're at '//', as in 'http://'. So don't */
    /* want to strip out the site name, but do need to remove   */
    /* the '/../' from the end.                                 */
    /*                                                          */
    /* This is for the case where there are too many '/../'s in */
    /* a relative URL (which happens quite often, it seems!).   */

    if (s2[-1] == '/') s2 = s1;

    /* Skip over the UPDIR bit */

    s1 += sizeof(UPDIR) - 1;

    /* Blat the remainder of the string onto what we have */

    s2++;
    memmove(s2, s1, strlen(s1) + 1);

    /* Repeat as required! */
  }

  return url;
}

/********************************************************************/
/* char *__html_strip_control_codes(char *s)                        */
/********************************************************************/
/* Strip out all control codes (c>0 & c< 32 && c!=10 && c!=13)      */
/********************************************************************/
void __html_strip_control_codes(char *s)
{
    while (*s)
    {
        if (CTRL_CODE(*s) && *s!='\t')
            *s='?';

        s++;
    }
}

/*************************************************************/
/* char *strincmp(char *sting, char *index, int size)        */
/*************************************************************/
/* Given two strings, look case insensitivly to establish if */
/* the first "size" chars in "string" are "index"	     */
/*************************************************************/
int strincmp(const char *string, const char *index, int size)
{
int d=0;

  while (size-- > 0) {
    d = toupper(*string++) - toupper(*index++);
    if (d != 0) return d;
    if (*string == 0) return 0;     /* no need to check c2 */
    }
  return 0;
}

/*************************************************************/
/* char *strnstr(char *sting, char *index, int size          */
/*************************************************************/
/* Given a pointer to a string, and the size of the string,  */
/* look to see if we can find the index char requested.      */
/*************************************************************/
char *strnstr(const char *string, const char *index, int size)
{
int i;
int count=0;

  while(1) {
    for (i=0;; i++) {
      char ch = index[i];
      if (count+i > size) return 0;
      if (ch == 0) return (char *)string;
      if (string[i] != ch) break;
    }
    count++;
    if (count > size) return 0;
    if (*string++ == 0) return 0;
  }
}

/*************************************************************/
/* char *strinstr(char *sting, char *index, int size         */
/*************************************************************/
/* Given a pointer to a string, and the size of the string,  */
/* look to see if we can find the index char requested.      */
/*************************************************************/
char *strinstr(const char *string, const char *index, int size)
{
int i;
int count=0;

  while(1) {
    for (i=0;; i++) {
      char ch = index[i];
      if (count+i > size) return 0;
      if (ch == 0) return (char *)string;
      if (toupper(string[i]) != toupper(ch)) break;
    }
    count++;
    if (count > size) return 0;
    if (*string++ == 0) return 0;
  }
}

@


1.1.2.2
log
@Spacing rules drastically improved. Major error in memory context handling
fixed. Bug in __html_strip_lf fixed.
@
text
@d19 1
a19 5
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/display,v $
 *
 * $Log: display,v $
 * Revision 1.1.2.1  1997/04/08 10:26:38  kbracey
 * Initial revision
d21 1
d36 1
a36 5
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/display,v $
 *
 * $Log: display,v $
 * Revision 1.1.2.1  1997/04/08 10:26:38  kbracey
 * Initial revision
d38 1
a63 3
#ifdef NEWSPACING
int __html_strip_spaces(char *input, int stripleadingspace, int striptrailingspace);
#else
a64 1
#endif
a79 3
#ifdef NEWSPACING
int __html_strip_spaces(char *input, int stripleadingspace, int striptrailingspace)
#else
a80 1
#endif
a82 4
#ifdef NEWSPACING
int strippedtrailingspaces=0;
int lastisspace=0;
#endif
a86 3
#ifdef NEWSPACING
  if ((input==NULL) || (*input=='\0')) return 0;
#else
a87 1
#endif
d91 1
a91 1
  Printf("Stripping spaces:\n");
a94 10
#ifdef NEWSPACING
  /*
   * Strip all leading whitespace if necessary (ie if after start tag)
   */
  if (stripleadingspace)
  {
    while (isspace(*input))
       input++;
  }
#else
a107 1
#endif
a141 18
#ifdef NEWSPACING
  if (striptrailingspace)
  {
    if (s > ptr && isspace(*(s-1)))
    {
      strippedtrailingspaces=1;
      *--s='\0';
    }
  }
  else
  {
    if (s > ptr && isspace(*(s-1)))
    {
      lastisspace=1;
    }
  }
#endif

a146 3
#ifdef NEWSPACING
  return lastisspace;
#else
a147 9
#endif
}

void __html_strip_trailing_spaces(char *input)
{
    char *p=input+strlen(input)-1;

    while (p >= input && isspace(*p))
        *p--='\0';
d160 1
a160 1
char *s1=input, *s2=input, c;
d164 1
a164 1
  while ((c=*s1) != '\0') {
d166 1
a166 1
    switch (c)
a167 1
      case CR:
d171 2
a172 1
            s1++;
d177 2
d180 5
a184 3
        break;
      /* Deal with tabs - this should pad to 8 chars */
      case '\t':
d186 1
a186 2
        break;
      default:
d188 1
a188 4
        break;
    }
    s1++;
    s2++;
d191 1
a191 1
  *s2='\0';
@


1.1.2.3
log
@Added in Tony Cheal's table code. Various other bug fixes.
@
text
@a21 4
 * Revision 1.1.2.2  1997/04/09 16:44:35  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
a41 4
 * Revision 1.1.2.2  1997/04/09 16:44:35  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
a417 1
    "Dagger", 157, /* Cougar */
a427 1
    "OElig",  154, /* Cougar */
a448 2
    "bdquo",  150, /* Cougar */
    "bull",   143, /* Cougar */
a454 1
    "dagger", 156, /* Cougar */
a455 1
    "divide", 247, /* Cougar */
a471 3
    "ldquo",  148, /* Cougar */
    "lsaquo", 146, /* Cougar */
    "lsquo",  144, /* Cougar */
a473 1
    "mdash",  152, /* Cougar */
a475 1
    "minus",  153, /* Cougar */
a476 1
    "ndash",  151, /* Cougar */
a480 1
    "oelig",  155, /* Cougar */
a487 1
    "permil", 142, /* Cougar */
a491 3
    "rdquo",  149, /* Cougar */
    "rsaquo", 147, /* Cougar */
    "rsquo",  145, /* Cougar */
a499 1
    "times",  215, /* Cougar */
@

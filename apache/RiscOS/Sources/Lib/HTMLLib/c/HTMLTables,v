head	1.8;
access;
symbols
	HTMLLib-0_04:1.8
	HTMLLib-0_03:1.8
	HTMLLib-0_02:1.8
	HTMLLib-0_01:1.8
	ahodgkin_207release:1.7
	ahodgkin_206release:1.7
	ahodgkin_205release:1.5
	ahodgkin_204release:1.3
	ahodgkin_133beta:1.2.2.25
	kbracey_126:1.2.2.23
	kbracey_AW97patch:1.2.2.23
	ahodgkin_AW97:1.2.2.21
	kbracey_PreGordon:1.2.2.2
	Web_bp:1.2
	Web:1.2.0.2
	ARTtmp_merge:1.1.2.1
	ARTtmp:1.1.0.2;
locks; strict;
comment	@# @;


1.8
date	98.11.05.14.38.44;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	98.06.16.15.36.32;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	98.05.08.11.34.02;	author kbracey;	state Exp;
branches;
next	1.5;

1.5
date	98.04.19.16.25.03;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	98.04.19.15.51.36;	author ahodgkin;	state Exp;
branches;
next	1.3;

1.3
date	98.02.17.10.42.06;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	97.04.29.15.50.40;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.28.14.20.14;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.2.2.1
date	97.05.12.12.09.19;	author kbracey;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	97.05.12.12.29.24;	author kbracey;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	97.06.03.12.50.12;	author kbracey;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	97.06.23.16.45.06;	author kbracey;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	97.06.23.17.09.17;	author kbracey;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	97.06.24.10.52.03;	author kbracey;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	97.06.24.11.19.26;	author kbracey;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	97.07.02.08.39.37;	author kbracey;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	97.07.03.13.57.44;	author kbracey;	state Exp;
branches;
next	1.2.2.10;

1.2.2.10
date	97.07.04.11.55.08;	author kbracey;	state Exp;
branches;
next	1.2.2.11;

1.2.2.11
date	97.07.24.16.20.48;	author kbracey;	state Exp;
branches;
next	1.2.2.12;

1.2.2.12
date	97.07.25.10.01.19;	author kbracey;	state Exp;
branches;
next	1.2.2.13;

1.2.2.13
date	97.08.18.16.13.26;	author kbracey;	state Exp;
branches;
next	1.2.2.14;

1.2.2.14
date	97.08.27.08.29.13;	author kbracey;	state Exp;
branches;
next	1.2.2.15;

1.2.2.15
date	97.09.17.15.08.37;	author ahodgkin;	state Exp;
branches;
next	1.2.2.16;

1.2.2.16
date	97.09.17.15.51.37;	author ahodgkin;	state Exp;
branches;
next	1.2.2.17;

1.2.2.17
date	97.09.25.16.50.36;	author ahodgkin;	state Exp;
branches;
next	1.2.2.18;

1.2.2.18
date	97.09.30.14.13.37;	author kbracey;	state Exp;
branches;
next	1.2.2.19;

1.2.2.19
date	97.10.03.10.57.01;	author ahodgkin;	state Exp;
branches;
next	1.2.2.20;

1.2.2.20
date	97.10.06.13.50.32;	author kbracey;	state Exp;
branches;
next	1.2.2.21;

1.2.2.21
date	97.10.06.15.17.41;	author ahodgkin;	state Exp;
branches;
next	1.2.2.22;

1.2.2.22
date	97.10.18.15.49.56;	author ahodgkin;	state Exp;
branches;
next	1.2.2.23;

1.2.2.23
date	97.10.22.07.36.22;	author ahodgkin;	state Exp;
branches;
next	1.2.2.24;

1.2.2.24
date	98.01.07.14.08.10;	author kbracey;	state Exp;
branches;
next	1.2.2.25;

1.2.2.25
date	98.01.13.11.43.31;	author ahodgkin;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.28.14.20.15;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Cleaned up a bit - any remaining build-time warnings are intentional
reminders that something needs attention. Adjusted CC flags as part
of this.

Corrected misleading comments on a couple of functions (a case of
Cut And Paste by the looks of things).

Rewrote element attribute parsing. As far as I can tell this now
behaves just as in Navigator 4.07 - fixed a large number of
reported bugs as a result. On the whole these are usually down to
spurious trailing closing quotes with no matching opening quote,
though there are some rather more exotic cases that now work
as intended.

Now remove CR and LF from attribute values rather than replacing
them with spaces - yet more sites fixed - and strip trailing spaces
from URLs (Ofsted's PDFs are now much easier to download...).
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/***************************************************/
/* File   : HTMLTables.c                           */
/* Purpose: Parsing of Tables and other            */
/*          table related functions                */
/* Author : Tony Cheal                             */
/* History: 12-Feb-97: Created                     */
/***************************************************/
/*have to repeat this here because our header file depends on it!*/
#include "HTMLTables.h"
#include "tablestruc.h"

#ifdef TonyTables

#ifdef UPDATEINPUT
static void skipptr(char **html)
{
char *ptr;
/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
/*
 * why the f*** wasn't this a function, and done earlier???
 * under what circumstance do you want to get the pointer stuck?
 */

 if (html != NULL) {
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) {/*printf("!%c",*ptr);*/ptr++;}
  if (*ptr=='>') ptr++;
  *html=ptr;
  /*printf("\n");*/
 }
}
#endif

/* spurious externs... */

HStream * __html_stream_return_tag(StreamTokens *st, Tag *tag,char **html, int start, char *url);
void __html_stream_free_anchor(AnchorInfo **anchor);

HStream * __html_table_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 HStream * return_val;

 NOT_USED(size);
 NOT_USED(url);
 NOT_USED(next_tag);

 return_val=__html_stream_return_tag(st,next_tag,html,0,url);

 if (return_val != NULL) {
     table_stream * treturn_val=(table_stream *) return_val;

     treturn_val->finished=0;
     treturn_val->List=NULL;
     treturn_val->Next=NULL; /*just in case?*/
     treturn_val->Prev=NULL;

     treturn_val->indent = __html_stream_indent(st);

     /*
      * Some page did "border=-8" once. Good grief. MSIE 4 takes
      * a default value of 1, in this case.
      */

     treturn_val->border=((signed int) (ATTR_VAL(BORDER))) < 0 ? 1 : ATTR_VAL(BORDER);

     if (ATTR_SET(BGCOL))
         treturn_val->bgcol=ATTR_VAL(BGCOL);
     else
         treturn_val->bgcol=(unsigned int) -1;

     treturn_val->background=ATTR_STR(BACKGROUND);

     if (ATTR_SET(CELLPADDING))
     {
         treturn_val->cellpadding=ATTR_VAL(CELLPADDING);
         treturn_val->has_cellpadding = 1;
     }
     else
     {
         treturn_val->cellpadding=2; /* Default to 2 pixels padding */
         treturn_val->has_cellpadding = 1;
     }

     if (ATTR_SET(CELLSPACING))
     {
         treturn_val->cellspacing=ATTR_VAL(CELLSPACING);
         treturn_val->has_cellspacing = 1;
     }
     else
     {
         treturn_val->cellspacing=1; /* Default to 1 pixel spacing */
         treturn_val->has_cellspacing = 1;
     }

     if (ATTR_SET(COLS))
     {
         treturn_val->cols = ATTR_VAL(COLS);
         treturn_val->has_cols = 1;
     }

     switch (ATTR_VAL(ALIGN))
     {
         case 1: treturn_val->Align = _html_left; break;
         case 2: treturn_val->Align = _html_centre; break;
         case 3: treturn_val->Align = _html_right; break;
         default:treturn_val->Align = _html_none; break;
     }

     switch (ATTR_VAL(VALIGN))
     {
        case 1: treturn_val->VAlign = _html_top; break;
        default:
        case 2: treturn_val->VAlign = _html_middle; break;
        case 3: treturn_val->VAlign = _html_bottom; break;
     }

     if (ATTR_SET(WIDTH))
     {
         treturn_val->width     = ATTR_VAL(WIDTH);
         treturn_val->has_width = 1;
         treturn_val->width_units = st->curattrs[WIDTH].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
     }

     if (ATTR_SET(HEIGHT))
     {
         treturn_val->height     = ATTR_VAL(HEIGHT);
         treturn_val->has_height = 1;
         treturn_val->height_units = st->curattrs[HEIGHT].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
     }

     /* If <TABLE ALIGN="..."> is to be inherited down to the cells
        rather than specify whole-table alignment, comment out the
        below line of code and re-enable the relevant part of the
        row handler dealing with <TR ALIGN="...">. However, other
        browsers seem to use this attribute for aligning the table
        as a whole. */

     treturn_val->type |= (treturn_val->Align) << TYPE_ALIGN_SHIFT;

     /* Stack away style information */
     treturn_val->stackedstyle = (styleinfo *) __html_malloc(sizeof(styleinfo), 1);
     if (treturn_val->stackedstyle)
        *treturn_val->stackedstyle = st->_stream_style;

     treturn_val->awaiting_tr = 1;
 }

/*should set the style stuff?*/
 return return_val;
}

HStream * __html_table_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 NOT_USED(next_tag);
 NOT_USED(url);
#ifndef UPDATEINPUT
 NOT_USED(html);
#endif

/*printf("table_table_end_tag 0x%x",(int) st->current_table);*/
 if (st->current_table != NULL)
 {
     st->current_table->finished=-1;
     if (st->current_table->stackedstyle)
     {
         st->_stream_style = *st->current_table->stackedstyle;
         __html_free(st->current_table->stackedstyle, 0);
         st->current_table->stackedstyle = 0;
     }
 }
#ifdef UPDATEINPUT
 skipptr(html);
#endif
 return NULL;
}

HStream * __html_table_row_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 NOT_USED(size);
 NOT_USED(url);
 NOT_USED(next_tag);
#ifndef UPDATEINPUT
 NOT_USED(html);
#endif

 if (st->current_table != NULL) {
  table_row * trow=(table_row *)__html_malloc(sizeof(table_row)+1,1);
  if (trow != NULL)
  {
    st->current_table->awaiting_tr = 0;

    if (st->current_row != NULL)
    {
      trow->Prev=st->current_row;
      st->current_row->Next=trow;
    }
    else
      st->current_table->List=trow;

    trow->parent = st->current_table;

    switch (ATTR_VAL(ALIGN))
    {
        case 1: trow->align = _html_left; break;
        case 2: trow->align = _html_centre; break;
        case 3: trow->align = _html_right; break;
        /*case 4: trow->align = _html_justify; break;*/

        /* If you believe that <TABLE ALIGN="..."> should inherit
           down to the cells beneath it, uncomment the below line
           and the code elsewhere that sets the Align field
           according to ATTR_VAL(ALIGN). However, other browsers
           appear to use this attribute to specify alignment of the
           table as a whole. */

        /* default:trow->align=st->current_table->Align; break; */
    }

    switch (ATTR_VAL(VALIGN))
    {
        case 1: trow->valign = _html_top; break;
        case 2: trow->valign = _html_middle; break;
        case 3: trow->valign = _html_bottom; break;
        default:trow->valign=st->current_table->VAlign; break;
    }

    if (ATTR_SET(BGCOL))
        trow->bgcol = ATTR_VAL(BGCOL);
    else
        trow->bgcol=st->current_table->bgcol;

   }
 }
#ifdef UPDATEINPUT
 skipptr(html);
#endif
 return NULL;
}

HStream * __html_table_row_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 NOT_USED(next_tag);
 NOT_USED(url);
 NOT_USED(st);
#ifndef UPDATEINPUT
 NOT_USED(html);
#endif

 if (st->current_table)
     st->current_table->awaiting_tr = 1;
#ifdef UPDATEINPUT
 skipptr(html);
#endif
 return NULL;
/*junk up to the next <TR> will be added to the last <TR><TD>*/
}

static HStream * table_cell_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size,int tag)
{
 NOT_USED(url);
 NOT_USED(size);
 NOT_USED(next_tag);
#ifndef UPDATEINPUT
 NOT_USED(html);
#endif

 if (st->current_table != NULL) {
  table_cell * tcell=(table_cell *)__html_malloc(sizeof(table_cell)+1,1);
  /* Deal with tables missing a <TR> */
  if (st->current_table->awaiting_tr) {
   table_row *trow=(table_row *)__html_malloc(sizeof(table_row)+1,1);
   if (trow != NULL)
   {
     st->current_table->awaiting_tr = 0;
     if (st->current_row != NULL)
     {
       trow->Prev=st->current_row;
       st->current_row->Next=trow;
     }
     else
       st->current_table->List=trow;

     trow->parent=st->current_table;

     trow->bgcol=st->current_table->bgcol;
     trow->align=st->current_table->Align;

     st->current_row = trow;
     st->current_cell = NULL;
   }
  }
  if (st->current_row != NULL && tcell != NULL)
  {
    if (st->current_cell != NULL)
    {
      st->current_cell->Next=tcell;
      tcell->Prev=st->current_cell;
    }
    else
      st->current_row->List=tcell;
    tcell->Tag=tag;

    tcell->parent = st->current_row;

    tcell->ColSpan=ATTR_VAL(COLSPAN);
    tcell->RowSpan=ATTR_VAL(ROWSPAN);
    tcell->background=ATTR_STR(BACKGROUND);
    if (ATTR_SET(BGCOL))
        tcell->bgcol=ATTR_VAL(BGCOL);
    else
        tcell->bgcol=st->current_row->bgcol;
    if (ATTR_SET(WIDTH))
    {
        tcell->width       = ATTR_VAL(WIDTH);
        tcell->width_units = st->curattrs[WIDTH].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
        tcell->has_width   = 1;
    }
    if (ATTR_SET(HEIGHT))
    {
        tcell->height       = ATTR_VAL(HEIGHT);
        tcell->height_units = st->curattrs[HEIGHT].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
        tcell->has_height   = 1;
    }
    if (ATTR_SET(NOWRAP))
        tcell->nowrap = 1;

    switch (ATTR_VAL(VALIGN))
    {
        case 1: tcell->VAlign = _html_top; break;
        case 2: tcell->VAlign = _html_middle; break;
        case 3: tcell->VAlign = _html_bottom; break;
        default:tcell->VAlign = st->current_row->valign; break;
    }

    switch (ATTR_VAL(ALIGN))
    {
        case 1: tcell->Align = _html_left; break;
        case 2: tcell->Align = _html_centre; break;
        case 3: tcell->Align = _html_right; break;
        default:tcell->Align = st->current_row->align; break;
    }

    if (st->current_table->stackedstyle != NULL)
    {
        __html_style_init(&st->_stream_style);
        if (tag == TagTableHead)
        {
           st->_stream_style.bold = 1;
           if (tcell->Align==_html_none)
               st->_stream_centre = 1;
        }
        /* Override here */
        if (tcell->Align==_html_centre)
           st->_stream_centre = 1;
        else if (tcell->Align==_html_right)
           st->_stream_right = 1, st->_stream_centre = 0;
    }

    if (st->pendingformfortable)
    {
        st->special_return = st->pendingformfortable;
        st->pendingformfortable = NULL;
    }
  }
 }
#ifdef UPDATEINPUT
 skipptr(html);
#endif
 return NULL;
}

HStream * __html_table_data_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 return table_cell_start_tag(st,next_tag,html,url,size,TagTableData);
}

HStream * __html_table_data_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 NOT_USED(st);
 NOT_USED(next_tag);
 NOT_USED(url);
#ifndef UPDATEINPUT
 NOT_USED(html);
#else
 skipptr(html);
#endif
 return NULL;
/*junk up to next <TD> will be added to the last <TD>*/
}

HStream * __html_table_head_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 return table_cell_start_tag(st,next_tag,html,url,size,TagTableHead);
}

HStream * __html_table_head_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 return __html_table_data_end_tag(st,next_tag,html,url);
}

table_prev_info table_skip_current(StreamTokens *st, table_prev_info realcurrent)
{
 st->current_table=NULL; /*to stop inadvertant <TR><TD> causing trouble*/
 st->current_row=NULL;
 st->current_cell=NULL;
/*printf("calling table_skip_current\n");*/
 return table_skip_current_r(st, realcurrent);
}


table_prev_info table_skip_current_r(StreamTokens *st, table_prev_info realcurrent)
{
  HStream *current = realcurrent.prev;

/* printf("table is 0x%x\n",(int)st->current_table);
   printf("row is 0x%x\n",(int)st->current_row);
   printf("cell is 0x%x\n",(int)st->current_cell);*/
 if (current == NULL)
 {
   return realcurrent;
 }
 if (current->tagno != TAG_TABLE) return realcurrent;
 {
  table_stream * tcurrent;
  tcurrent = (table_stream *) current;
  if (tcurrent->finished) return realcurrent;
/*incomplete table, so go down to rows etc.*/
  st->current_table=tcurrent;
  st->current_row=tcurrent->List;
  if (st->current_row != NULL) {
   while(st->current_row->Next != NULL) st->current_row=st->current_row->Next;
  }
  st->current_cell=NULL;
  if (st->current_row != NULL) st->current_cell=st->current_row->List;
  if (st->current_cell != NULL) {
   while(st->current_cell->Next != NULL) st->current_cell=st->current_cell->Next;
  }
  if (st->current_cell != NULL)
  {
    realcurrent.prev=NULL;
    realcurrent.prevnextptr=(HStream * *)(&(st->current_cell->List));
  }
  else
  {
    realcurrent.prev=NULL;
    realcurrent.prevnextptr=NULL;
  }
  if (realcurrent.prevnextptr == NULL || *realcurrent.prevnextptr == NULL) return realcurrent;
  while((*realcurrent.prevnextptr)->next != NULL)
  {
    realcurrent.prev=*realcurrent.prevnextptr;
    realcurrent.prevnextptr=&realcurrent.prev->next;
  }
/*printf("recursing\n");*/
  realcurrent.prev = *realcurrent.prevnextptr;
  realcurrent.prevnextptr= &realcurrent.prev->next;
  return table_skip_current_r(st, realcurrent/**realcurrent.prevnextptr*/);
/* st->current_table will be NULL or relevant nested table
   st->current_row will be NULL if no rows yet
   st->current_cell will be NULL if no columns yet*/
 }
}
#endif
@


1.7
log
@Multiple text tags inside one <OPTION> container are "glued together",
so HTML such as '<OPTION>Some <I>italicised</I> entries' will generate
meaningful menu entries.

<PRE> and <Hn> elements now cancel <P ALIN="...">, whereas they did
not before. This is special-cased for those elements, based on the
code already in place for <DIV>.
@
text
@d172 5
a176 1
 NOT_USED(next_tag); NOT_USED(url);
d200 3
d263 3
d281 3
d397 6
a402 3
 NOT_USED(st); NOT_USED(next_tag); NOT_USED(url);

#ifdef UPDATEINPUT
@


1.6
log
@Can now cope with < or > characters in quoted attributes
@
text
@d149 9
d219 9
a227 1
        default:trow->align=st->current_table->Align; break;
@


1.5
log
@Completely failed to notice that the 'border without value -> border="1"'
attempt slightly missed the point, adding a border to every table whether
it wanted one or not... Taken that code out, rethinking approach!
@
text
@d28 1
d50 1
d176 1
d178 1
d228 1
d230 1
d242 1
d244 1
d354 1
d356 1
d369 1
d371 1
@


1.4
log
@Negative table border specifiers are now turned into a border width of 1,
and 'border' may be used without a width specifier to again imply a width
of 1.
@
text
@d76 2
a77 3
      * Some page did "border=-8" once. Good grief. MSIE takes
      * a default value of 1, in this case. BORDER is also
      * used as a flag (implying a value of 1) on some sites.
d80 1
a80 4
     if (ATTR_SET(BORDER))
     {
       treturn_val->border=((signed int) (ATTR_VAL(BORDER))) <= 0 ? 1 : ATTR_VAL(BORDER);
     }
@


1.3
log
@Web branch merged
@
text
@d75 10
a84 1
     treturn_val->border=ATTR_VAL(BORDER);
@


1.2
log
@Merged in ARTtmp_merge
@
text
@a26 3
table_stream   * __html_current_table=0; /* this is also an HStream */
table_row      * __html_current_row=0;
table_headdata * __html_current_headdata=0;
d42 2
a43 2
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) {/*printf("!%c",*ptr);*/ptr++;}
d52 1
a52 1
HStream * __html_stream_return_tag(StreamTokens *st, Tag tag,char **html, int start, char *url);
d55 1
a55 1
HStream * __html_table_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
a57 2
 AnchorInfo *anc;
 styleinfo *s;
d59 4
a62 1
 anc = __html_get_anchor_info(st, html, next_tag);
d64 1
a67 1
     return_val->tag=TABLE;
d71 63
d135 1
a135 1
     if (anc)
d137 3
a139 21
         treturn_val->border      = anc->border;
         if (anc->size & 0x80000000)
         {
           treturn_val->cellpadding = anc->size & 0x7fffffff;
           treturn_val->flags    |= TABLEFLAG_CELLPADDING;
         }
         if (anc->spacing & 0x80000000)
         {
           treturn_val->cellspacing = anc->spacing & 0x7fffffff;
           treturn_val->flags      |= TABLEFLAG_CELLSPACING;
         }
         treturn_val->cols        = anc->cols;
         if (anc->cols)
           treturn_val->flags    |= TABLEFLAG_COLS;
         /*treturn_val->align       = anc->alignment;*/
         if (anc->width & 0x01000000)
         {
             treturn_val->flags  |= TABLEFLAG_WIDTH;
             treturn_val->width   = anc->width & 0x00ffffff;
             treturn_val->flags  |= (anc->width >> 28) << TABLEFLAG_UNITS_SHIFT;
         }
d141 1
d147 1
a148 2
 if (anc)
    __html_stream_free_anchor(&anc);
d154 1
a154 1
HStream * __html_table_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url)
d156 4
a159 2
/*printf("table_table_end_tag 0x%x",(int) __html_current_table);*/
 if (__html_current_table != NULL)
d161 2
a162 2
     __html_current_table->finished=-1;
     if (__html_current_table->stackedstyle)
d164 3
a166 3
         st->_stream_style = *__html_current_table->stackedstyle;
         __html_free(__html_current_table->stackedstyle, 0);
         __html_current_table->stackedstyle == 0;
d173 1
a173 1
HStream * __html_table_row_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
d175 5
a179 1
 if (__html_current_table != NULL) {
d183 7
a189 3
    AnchorInfo *anc;
    if (__html_current_row != NULL)
      __html_current_row->Next=trow;
d191 11
a201 10
      __html_current_table->List=trow;
    trow->Next=NULL;
    trow->List=NULL;

    anc = __html_get_anchor_info(st, html, next_tag);
    if (anc)
    {
       trow->align = anc->alignment;
       trow->valign = anc->valign;
       __html_stream_free_anchor(&anc);
d203 15
a217 1
  }
d223 1
a223 1
HStream * __html_table_row_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url)
d225 6
d236 1
a236 1
static HStream * table_thing_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size,int tag)
d238 10
a247 5
 AnchorInfo * anc;
 if (__html_current_table != NULL) {
  if (__html_current_row != NULL) {
   table_headdata * theaddata=(table_headdata *)__html_malloc(sizeof(table_headdata)+1,1);
   if (theaddata != NULL)
d249 6
a254 2
     if (__html_current_headdata != NULL)
       __html_current_headdata->Next=theaddata;
d256 9
a264 25
       __html_current_row->List=theaddata;
     theaddata->Next=NULL;
     theaddata->List=NULL;
     theaddata->Tag=tag;
     theaddata->bgcol=(unsigned int) -1;
     anc=__html_get_anchor_info(st,html,next_tag);
     if (anc != NULL) {
       theaddata->ColSpan=anc->colspan;
       theaddata->RowSpan=anc->rowspan;
       theaddata->background=strdup(anc->src);
       theaddata->bgcol=anc->maxlength;
       theaddata->width=anc->cols;
       theaddata->height=anc->rows;
       theaddata->VAlign=anc->valign;
       theaddata->Align=anc->alignment;
       /*printf("ColSpan is: 0x%x\n",theaddata->ColSpan);
       printf("RowSpan is: 0x%x\n",theaddata->RowSpan);*/
       __html_stream_free_anchor(&anc);
     }
     if (__html_current_table->stackedstyle != NULL)
     {
         __html_style_init(&st->_stream_style);
         if (tag == TagTableHead)
            st->_stream_style.bold = 1;
     }
d267 73
d345 1
a345 1
HStream * __html_table_data_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
d347 1
a347 1
 return table_thing_start_tag(st,next_tag,html,url,size,TagTableData);
d350 1
a350 1
HStream * __html_table_data_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url)
d352 2
d359 1
a359 1
HStream * __html_table_head_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
d361 1
a361 1
 return table_thing_start_tag(st,next_tag,html,url,size,TagTableHead);
d364 1
a364 1
HStream * __html_table_head_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url)
d369 1
a369 1
HStream * * table_skip_current(HStream * current)
d371 3
a373 3
 __html_current_table=NULL; /*to stop inadvertant <TR><TD> causing trouble*/
 __html_current_row=NULL;
 __html_current_headdata=NULL;
d375 1
a375 1
 return table_skip_current_r(current);
d379 1
a379 1
HStream * * table_skip_current_r(HStream * current)
d381 10
a390 7
 HStream * * realcurrent;
/* printf("table is 0x%x\n",(int)__html_current_table);
   printf("row is 0x%x\n",(int)__html_current_row);
   printf("headdata is 0x%x\n",(int)__html_current_headdata);*/
 if (current == NULL) return NULL;
 realcurrent=&(current->next);
 if (!(current->tag == TABLE && ISBODY(current))) return realcurrent;
d396 26
a421 15
  __html_current_table=tcurrent;
  __html_current_row=tcurrent->List;
  if (__html_current_row != NULL) {
   while(__html_current_row->Next != NULL) __html_current_row=__html_current_row->Next;
  }
  __html_current_headdata=NULL;
  if (__html_current_row != NULL) __html_current_headdata=__html_current_row->List;
  if (__html_current_headdata != NULL) {
   while(__html_current_headdata->Next != NULL) __html_current_headdata=__html_current_headdata->Next;
  }
  if (__html_current_headdata != NULL) realcurrent=(HStream * *)(&(__html_current_headdata->List));
  else realcurrent=NULL;
  if (realcurrent == NULL) return realcurrent;
  if (*realcurrent == NULL) return realcurrent;
  while((*realcurrent)->next != NULL) realcurrent=&((*realcurrent)->next);
d423 6
a428 4
  return table_skip_current_r(*realcurrent);
/* __html_current_table will be NULL or relevant nested table
   __html_current_row will be NULL if no rows yet
   __html_current_headdata will be NULL if no columns yet*/
@


1.2.2.1
log
@Flags TDFLAG_WIDTH and _HEIGHT now set correctly in table_headdata structure.
@
text
@d184 2
a185 10
       if (anc->cols & 0x80000000)
       {
           theaddata->width = anc->cols & 0x7fffffff;
           theaddata->flags |= TDFLAG_WIDTH;
       }
       if (anc->rows & 0x80000000)
       {
           theaddata->height = anc->rows & 0x7fffffff;
           theaddata->flags |= TDFLAG_HEIGHT;
       }
@


1.2.2.2
log
@Dealt with percentages in table cell widths and heights
@
text
@d186 1
a186 1
           theaddata->width = anc->cols & 0x3fffffff;
a187 2
           if (anc->cols & 0x40000000)
               theaddata->flags |= UNITS_PERCENT << TDFLAG_WUNITS_SHIFT;
d191 1
a191 1
           theaddata->height = anc->rows & 0x3fffffff;
a192 2
           if (anc->rows & 0x40000000)
               theaddata->flags |= UNITS_PERCENT << TDFLAG_HUNITS_SHIFT;
@


1.2.2.3
log
@First attempt at "more HStreams have come in" flag and getting previous
pointers to work in tables. Various fiddles by GThorburn.
@
text
@a29 1
/*table_flag     * __html_table_stream_flag=0; */
a65 1

a72 1
    /* treturn_val->Prev=NULL; // */
d121 1
a121 1
         __html_current_table->stackedstyle = 0;
a135 1
    /*  __html_previous_row->Prev=trow; //  */
a141 2
   /* trow->Prev=NULL; //  */

a170 1
    /*   __html_previous_headdata->Prev=theaddata; //  */
a175 1
    /* theaddata->Prev=NULL; //  */
d239 1
a239 1
table_prev_info table_skip_current(HStream * current)
d249 1
a249 1
table_prev_info table_skip_current_r(HStream * current)
d251 1
a251 1
  table_prev_info realcurrent;
d255 2
a256 8
 if (current == NULL)
 {
   realcurrent.prev = NULL;
   realcurrent.prevnextptr = NULL;
   return realcurrent;
 }
 realcurrent.prev = current;
 realcurrent.prevnextptr = &current->next;
d273 5
a277 16
  if (__html_current_headdata != NULL)
  {
    realcurrent.prev=NULL;
    realcurrent.prevnextptr=(HStream * *)(&(__html_current_headdata->List));
  }
  else
  {
    realcurrent.prev=NULL;
    realcurrent.prevnextptr=NULL;
  }
  if (realcurrent.prevnextptr == NULL || *realcurrent.prevnextptr == NULL) return realcurrent;
  while((*realcurrent.prevnextptr)->next != NULL)
  {
    realcurrent.prev=*realcurrent.prevnextptr;
    realcurrent.prevnextptr=&((*realcurrent.prevnextptr)->next);
  }
d279 1
a279 1
  return table_skip_current_r(*realcurrent.prevnextptr);
@


1.2.2.4
log
@Tables with missing <TR>s now handled
@
text
@d172 3
a174 5
  table_headdata * theaddata=(table_headdata *)__html_malloc(sizeof(table_headdata)+1,1);
  /* Deal with tables missing a <TR> */
  if (__html_current_row == NULL) {
   __html_current_row=(table_row *)__html_malloc(sizeof(table_row)+1,1);
   if (__html_current_row != NULL)
d176 42
a217 3
     __html_current_table->List=__html_current_row;
     __html_current_row->Next=NULL;
     __html_current_row->List=NULL;
a218 45
  }
  if (__html_current_row != NULL && theaddata != NULL)
  {
    if (__html_current_headdata != NULL)
   /*   __html_previous_headdata->Prev=theaddata; //  */
      __html_current_headdata->Next=theaddata;
    else
      __html_current_row->List=theaddata;
    theaddata->Next=NULL;
    theaddata->List=NULL;
   /* theaddata->Prev=NULL; //  */
    theaddata->Tag=tag;
    theaddata->bgcol=(unsigned int) -1;
    anc=__html_get_anchor_info(st,html,next_tag);
    if (anc != NULL) {
      theaddata->ColSpan=anc->colspan;
      theaddata->RowSpan=anc->rowspan;
      theaddata->background=strdup(anc->src);
      theaddata->bgcol=anc->maxlength;
      if (anc->cols & 0x80000000)
      {
          theaddata->width = anc->cols & 0x3fffffff;
          theaddata->flags |= TDFLAG_WIDTH;
          if (anc->cols & 0x40000000)
              theaddata->flags |= UNITS_PERCENT << TDFLAG_WUNITS_SHIFT;
      }
      if (anc->rows & 0x80000000)
      {
          theaddata->height = anc->rows & 0x3fffffff;
          theaddata->flags |= TDFLAG_HEIGHT;
          if (anc->rows & 0x40000000)
              theaddata->flags |= UNITS_PERCENT << TDFLAG_HUNITS_SHIFT;
      }
      theaddata->VAlign=anc->valign;
      theaddata->Align=anc->alignment;
      /*printf("ColSpan is: 0x%x\n",theaddata->ColSpan);
      printf("RowSpan is: 0x%x\n",theaddata->RowSpan);*/
      __html_stream_free_anchor(&anc);
    }
    if (__html_current_table->stackedstyle != NULL)
    {
        __html_style_init(&st->_stream_style);
        if (tag == TagTableHead)
           st->_stream_style.bold = 1;
    }
@


1.2.2.5
log
@Now handles tables with a <TR> missing in the middle, as well as at the start.
@
text
@a105 1
     st->awaiting_tr = 1;
a137 3

    st->awaiting_tr = 0;

a162 1
 st->awaiting_tr = 1;
d174 3
a176 3
  if (st->awaiting_tr) {
   table_row *trow=(table_row *)__html_malloc(sizeof(table_row)+1,1);
   if (trow != NULL)
d178 3
a180 9
     st->awaiting_tr = 0;
     if (__html_current_row != NULL)
       __html_current_row->Next=trow;
     else
       __html_current_table->List=trow;
     trow->Next=NULL;
     trow->List=NULL;
     __html_current_row = trow;
     __html_current_headdata = NULL;
@


1.2.2.6
log
@A couple more missing <TR> fixes - now copes with nested tables.
Added inheritance of ALIGN and BGCOLOR settings from <TR>s and <TABLE>s.
@
text
@a75 2
     treturn_val->bgcol=(unsigned int) -1;
     treturn_val->Align=_html_none;
a79 1
         treturn_val->bgcol       = anc->maxlength;
d92 2
a93 3
             treturn_val->flags    |= TABLEFLAG_COLS;
         if (anc->alignment != _html_none)
             treturn_val->Align       = anc->alignment;
d106 1
a106 1
     treturn_val->awaiting_tr = 1;
d140 1
a140 1
    __html_current_table->awaiting_tr = 0;
a149 3
    trow->bgcol=__html_current_table->bgcol;
    trow->align=__html_current_table->Align;

d155 1
a155 2
       if (anc->alignment != _html_none)
           trow->align = anc->alignment;
a156 2
       if (anc->maxlength != (unsigned int) -1)
          trow->bgcol = anc->maxlength;
d167 1
a167 2
 if (__html_current_table)
     __html_current_table->awaiting_tr = 1;
d179 1
a179 1
  if (__html_current_table->awaiting_tr) {
d183 1
a183 1
     __html_current_table->awaiting_tr = 0;
a189 3
     trow->bgcol=__html_current_table->bgcol;
     trow->align=__html_current_table->Align;

d205 1
a205 2
    theaddata->bgcol=__html_current_row->bgcol;
    theaddata->Align=__html_current_row->align;
d211 1
a211 2
      if (anc->maxlength != (unsigned int) -1)
          theaddata->bgcol=anc->maxlength;
d227 1
a227 2
      if (anc->alignment != _html_none)
          theaddata->Align=anc->alignment;
a235 1
        {
a236 6
           if (theaddata->Align==_html_none)
               st->_stream_center = 1;
        }
        /* Override here */
        if (theaddata->Align==_html_centre)
           st->_stream_center = 1;
@


1.2.2.7
log
@Removed some compilation warnings. Fixed handling of vanilla <FRAME> tags
(ie ones with no attributes).
@
text
@d63 1
a63 4

 NOT_USED(size);
 NOT_USED(url);
 NOT_USED(next_tag);
a120 2
 NOT_USED(next_tag); NOT_USED(url);

a137 3
 NOT_USED(size);
 NOT_USED(url);

a176 4
 NOT_USED(next_tag);
 NOT_USED(url);
 NOT_USED(st);

a186 4

 NOT_USED(url);
 NOT_USED(size);

a274 2
 NOT_USED(st); NOT_USED(next_tag); NOT_USED(url);

@


1.2.2.8
log
@Added previous pointers to table rows and cells.
Implemented skipping of <STYLE> and <SCRIPT>.
@
text
@d78 1
a78 1
     treturn_val->Prev=NULL;
d155 1
a155 2
    {
      trow->Prev=__html_current_row;
a156 1
    }
d159 2
a160 2

    trow->parent = __html_current_table;
d165 2
a211 2
     {
       trow->Prev=__html_current_row;
a212 1
     }
d215 2
a216 3

     trow->parent=__html_current_table;

d227 1
a227 1
    {
a228 2
      theaddata->Prev=__html_current_headdata;
    }
d231 3
@


1.2.2.9
log
@Stopped the library passing Tag structures around by value (bleuch!)
@
text
@d56 1
a56 1
HStream * __html_stream_return_tag(StreamTokens *st, Tag *tag,char **html, int start, char *url);
d59 1
a59 1
HStream * __html_table_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
d122 1
a122 1
HStream * __html_table_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
d141 1
a141 1
HStream * __html_table_row_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
d183 1
a183 1
HStream * __html_table_row_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
d196 1
a196 1
static HStream * table_thing_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size,int tag)
d287 1
a287 1
HStream * __html_table_data_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
d292 1
a292 1
HStream * __html_table_data_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
d301 1
a301 1
HStream * __html_table_head_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
d306 1
a306 1
HStream * __html_table_head_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
@


1.2.2.10
log
@Stopped table code using HStream flags word.
Allowed parsing of <--- Hello ---> style comments.
@
text
@d89 1
a89 1
           treturn_val->has_cellpadding = 1;
d94 1
a94 1
           treturn_val->has_cellspacing = 1;
d98 1
a98 1
             treturn_val->has_cols = 1;
d103 1
a103 1
             treturn_val->has_width = 1;
d105 1
a105 1
             treturn_val->width_units = anc->width >> 28;
a243 4
      if (theaddata->RowSpan == 10)
      {
          theaddata->RowSpan = 10;
      }
d250 1
a250 1
          theaddata->has_width = 1;
d252 1
a252 1
              theaddata->width_units = UNITS_PERCENT;
d257 1
a257 1
          theaddata->has_height = 1;
d259 1
a259 1
              theaddata->height_units = UNITS_PERCENT;
a260 4

      if (anc->noresize)
          theaddata->nowrap = 1;

@


1.2.2.11
log
@Totally redesigned attribute parsing code.
Started new API for accessing attributes - only implemented for BODY.
Added <BODY alink onload onunload> support.
@
text
@d29 1
a29 1
table_cell * __html_current_cell=0;
d62 1
d68 1
d79 2
d82 1
a82 20
     treturn_val->border=ATTR_VAL(BORDER);

     if (ATTR_SET(BGCOL))
         treturn_val->bgcol=ATTR_VAL(BGCOL);
     else
         treturn_val->bgcol=(unsigned int) -1;

     if (ATTR_SET(CELLPADDING))
     {
         treturn_val->cellpadding=ATTR_VAL(CELLPADDING);
         treturn_val->has_cellpadding = 1;
     }

     if (ATTR_SET(COLS))
     {
         treturn_val->cols = ATTR_VAL(COLS);
         treturn_val->has_cols = 1;
     }

     switch (ATTR_VAL(ALIGN))
d84 23
a106 4
         case 1: treturn_val->Align = _html_left; break;
         case 2: treturn_val->Align = _html_centre; break;
         case 3: treturn_val->Align = _html_right; break;
         default:treturn_val->Align = _html_none; break;
a107 8

     if (ATTR_SET(WIDTH))
     {
         treturn_val->width     = ATTR_VAL(WIDTH);
         treturn_val->has_width = 1;
         treturn_val->width_units = st->curattrs[WIDTH].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
     }

d115 2
d150 2
d164 2
a165 8
    switch (ATTR_VAL(ALIGN))
    {
        case 1: trow->align = _html_left; break;
        case 2: trow->align = _html_centre; break;
        case 3: trow->align = _html_right; break;
        /*case 4: trow->align = _html_justify; break;*/
        default:trow->align=__html_current_table->Align; break;
    }
d167 2
a168 1
    switch (ATTR_VAL(VALIGN))
d170 6
a175 4
        case 1: trow->valign = _html_top; break;
        case 2: trow->valign = _html_middle; break;
        case 3: trow->valign = _html_bottom; break;
        default:trow->valign = _html_none; break;
d177 1
a177 7

    if (ATTR_SET(BGCOL))
        trow->bgcol = ATTR_VAL(BGCOL);
    else
        trow->bgcol=__html_current_table->bgcol;

   }
d196 1
a196 1
static HStream * table_cell_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size,int tag)
d198 2
d204 1
a204 1
  table_cell * tcell=(table_cell *)__html_malloc(sizeof(table_cell)+1,1);
d225 1
a225 1
     __html_current_cell = NULL;
d228 1
a228 1
  if (__html_current_row != NULL && tcell != NULL)
d230 1
a230 1
    if (__html_current_cell != NULL)
d232 2
a233 2
      __html_current_cell->Next=tcell;
      tcell->Prev=__html_current_cell;
d236 39
a274 15
      __html_current_row->List=tcell;
    tcell->Tag=tag;

    tcell->ColSpan=ATTR_VAL(COLSPAN);
    tcell->RowSpan=ATTR_VAL(ROWSPAN);
    tcell->background=ATTR_STR(BACKGROUND);
    if (ATTR_SET(BGCOL))
        tcell->bgcol=ATTR_VAL(BGCOL);
    else
        tcell->bgcol=__html_current_row->bgcol;
    if (ATTR_SET(WIDTH))
    {
        tcell->width = ATTR_VAL(WIDTH);
        tcell->width = st->curattrs[WIDTH].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
        tcell->has_width = 1;
a275 25
    if (ATTR_SET(HEIGHT))
    {
        tcell->height = ATTR_VAL(HEIGHT);
        tcell->height = st->curattrs[HEIGHT].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
        tcell->has_height = 1;
    }
    if (ATTR_SET(NOWRAP))
        tcell->nowrap = 1;

    switch (ATTR_VAL(VALIGN))
    {
        case 1: tcell->VAlign = _html_top; break;
        case 2: tcell->VAlign = _html_middle; break;
        case 3: tcell->VAlign = _html_bottom; break;
        default:tcell->VAlign = __html_current_row->valign; break;
    }

    switch (ATTR_VAL(ALIGN))
    {
        case 1: tcell->Align = _html_left; break;
        case 2: tcell->Align = _html_centre; break;
        case 3: tcell->Align = _html_right; break;
        default:tcell->Align = __html_current_row->align; break;
    }

d282 1
a282 1
           if (tcell->Align==_html_none)
d286 1
a286 1
        if (tcell->Align==_html_centre)
d297 1
a297 1
 return table_cell_start_tag(st,next_tag,html,url,size,TagTableData);
d311 1
a311 1
 return table_cell_start_tag(st,next_tag,html,url,size,TagTableHead);
d323 1
a323 1
 __html_current_cell=NULL;
d334 1
a334 1
   printf("cell is 0x%x\n",(int)__html_current_cell);*/
d354 4
a357 4
  __html_current_cell=NULL;
  if (__html_current_row != NULL) __html_current_cell=__html_current_row->List;
  if (__html_current_cell != NULL) {
   while(__html_current_cell->Next != NULL) __html_current_cell=__html_current_cell->Next;
d359 1
a359 1
  if (__html_current_cell != NULL)
d362 1
a362 1
    realcurrent.prevnextptr=(HStream * *)(&(__html_current_cell->List));
d379 1
a379 1
   __html_current_cell will be NULL if no columns yet*/
@


1.2.2.12
log
@Added new external call HtmlRelativiseURL, and added support for hex entities.
@
text
@a146 1
 NOT_USED(next_tag);
a208 1
 NOT_USED(next_tag);
@


1.2.2.13
log
@Did align on <P> and right align on tables.
Fixed problem with the final ">" of "</SCRIPT>" ending up in the title.
Fixed problem of HtmlGetStream returning a pointer to the wrong parent table.
Added SUB and SUP.
@
text
@d293 1
a293 1
               st->_stream_centre = 1;
d297 1
a297 3
           st->_stream_centre = 1;
        else if (tcell->Align==_html_right)
           st->_stream_right = 1, st->_stream_centre = 0;
@


1.2.2.14
log
@Some Unicode support added (#ifdefed out). Table cells now have parent rows.
@
text
@a247 2
    tcell->parent = __html_current_row;

@


1.2.2.15
log
@VALIGN on a TABLE tag is now inherited by TR. CENTER or CENTRE permitted,
as well as MIDDLE.
@
text
@a104 8
     switch (ATTR_VAL(VALIGN))
     {
        case 1: treturn_val->VAlign = _html_top; break;
        case 2: treturn_val->VAlign = _html_middle; break;
        case 3: treturn_val->VAlign = _html_bottom; break;
        default:treturn_val->VAlign = _html_none; break;
     }

d179 1
a179 1
        default:trow->valign=__html_current_table->VAlign; break;
@


1.2.2.16
log
@Fixed WIDTH and HEIGHT attributes on tables
@
text
@d267 3
a269 3
        tcell->width       = ATTR_VAL(WIDTH);
        tcell->width_units = st->curattrs[WIDTH].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
        tcell->has_width   = 1;
d273 3
a275 3
        tcell->height       = ATTR_VAL(HEIGHT);
        tcell->height_units = st->curattrs[HEIGHT].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
        tcell->has_height   = 1;
@


1.2.2.17
log
@Bras Direct now works. Woohoo. Doesn't die when loading extremely large
chunks - malloc failures due to a locked flex heap caused problems.
HttpEndParse call added to free up parse related blocks. To solve layout
problems on certain sizes, spacer images (align left or right) which are
less than 2 pixels wide, or are more than 15 times tall than wide, will
be ignored.
@
text
@d46 2
a47 2
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) {/*printf("!%c",*ptr);*/ptr++;}
@


1.2.2.18
log
@Turned off CUSTOMER_SPECIAL.
Changed encoding tables to use FFFF as a null value instead of FFFD.
Added OBJECT support (more testing required - PARAM not yet done).
Added AREA support (commented out - MAP not yet done). They come out
looking like <A></A> elements.
Souped up mapping to Latin-1 (added lossy tables for Latin Extended
Additional, CJK Punctuation and Fullwidth forms).
Added support for <H1 align=...>
Stripped some superfluous whitespace caused by linefeeds.
Fixed missing linebreak in "<DT>One<DT>Two" by turning the second DT into
a BR.
Removed now unnecessary free(malloc(16384)) bodge.
Put in CJK code even if UNIFONT not defined (hey - why not?).
Added code to take direct pointer to table rather than loading it if
it's in ResourceFS.
Added support for encoding "x-acorn-latin1".
Ensured correct handling of OPTIONs when UNIFONT not defined.
@
text
@a107 1
        default:
d110 1
d341 1
a341 1
table_prev_info table_skip_current(table_prev_info realcurrent)
d347 1
a347 1
 return table_skip_current_r(realcurrent);
d351 1
a351 1
table_prev_info table_skip_current_r(table_prev_info realcurrent)
d353 1
a353 2
  HStream *current = realcurrent.prev;

d359 2
d363 2
d395 1
a395 1
    realcurrent.prevnextptr=&realcurrent.prev->next;
d398 1
a398 3
  realcurrent.prev = *realcurrent.prevnextptr;
  realcurrent.prevnextptr= &realcurrent.prev->next;
  return table_skip_current_r(realcurrent/**realcurrent.prevnextptr*/);
@


1.2.2.19
log
@Now have an 'indent' field to TableStream structure to match that in
HStream, so that tables can be indented to the same horizontal position
as text; some page layouts rely on this (e.g. the current Acorn site!).
@
text
@a77 2
     treturn_val->indent = __html_stream_indent(st);

@


1.2.2.20
log
@Stopped style being attached to SCRIPT and STYLE tokens.
Stopping leading spaces being stripped from PRE elements.
Removed TABLE,TR,TD and TH from the style word.
@
text
@d72 1
d79 1
a79 1

d364 1
a364 1
 if (current->tagno != TAG_TABLE) return realcurrent;
@


1.2.2.21
log
@Some pages could be parsed in the context of a previous table - fixed.
Made the 'throw away very tall images' code only do it for images < 6
pixels wide.
@
text
@d27 4
d137 2
a138 2
/*printf("table_table_end_tag 0x%x",(int) st->current_table);*/
 if (st->current_table != NULL)
d140 2
a141 2
     st->current_table->finished=-1;
     if (st->current_table->stackedstyle)
d143 3
a145 3
         st->_stream_style = *st->current_table->stackedstyle;
         __html_free(st->current_table->stackedstyle, 0);
         st->current_table->stackedstyle = 0;
d158 1
a158 1
 if (st->current_table != NULL) {
d162 1
a162 1
    st->current_table->awaiting_tr = 0;
d164 1
a164 1
    if (st->current_row != NULL)
d166 2
a167 2
      trow->Prev=st->current_row;
      st->current_row->Next=trow;
d170 1
a170 1
      st->current_table->List=trow;
d172 1
a172 1
    trow->parent = st->current_table;
d180 1
a180 1
        default:trow->align=st->current_table->Align; break;
d188 1
a188 1
        default:trow->valign=st->current_table->VAlign; break;
d194 1
a194 1
        trow->bgcol=st->current_table->bgcol;
d208 2
a209 2
 if (st->current_table)
     st->current_table->awaiting_tr = 1;
d221 1
a221 1
 if (st->current_table != NULL) {
d224 1
a224 1
  if (st->current_table->awaiting_tr) {
d228 2
a229 2
     st->current_table->awaiting_tr = 0;
     if (st->current_row != NULL)
d231 2
a232 2
       trow->Prev=st->current_row;
       st->current_row->Next=trow;
d235 1
a235 1
       st->current_table->List=trow;
d237 1
a237 1
     trow->parent=st->current_table;
d239 2
a240 2
     trow->bgcol=st->current_table->bgcol;
     trow->align=st->current_table->Align;
d242 2
a243 2
     st->current_row = trow;
     st->current_cell = NULL;
d246 1
a246 1
  if (st->current_row != NULL && tcell != NULL)
d248 1
a248 1
    if (st->current_cell != NULL)
d250 2
a251 2
      st->current_cell->Next=tcell;
      tcell->Prev=st->current_cell;
d254 1
a254 1
      st->current_row->List=tcell;
d257 1
a257 1
    tcell->parent = st->current_row;
d265 1
a265 1
        tcell->bgcol=st->current_row->bgcol;
d286 1
a286 1
        default:tcell->VAlign = st->current_row->valign; break;
d294 1
a294 1
        default:tcell->Align = st->current_row->align; break;
d297 1
a297 1
    if (st->current_table->stackedstyle != NULL)
d342 1
a342 1
table_prev_info table_skip_current(StreamTokens *st, table_prev_info realcurrent)
d344 3
a346 3
 st->current_table=NULL; /*to stop inadvertant <TR><TD> causing trouble*/
 st->current_row=NULL;
 st->current_cell=NULL;
d348 1
a348 1
 return table_skip_current_r(st, realcurrent);
d352 1
a352 1
table_prev_info table_skip_current_r(StreamTokens *st, table_prev_info realcurrent)
d356 3
a358 3
/* printf("table is 0x%x\n",(int)st->current_table);
   printf("row is 0x%x\n",(int)st->current_row);
   printf("cell is 0x%x\n",(int)st->current_cell);*/
d369 4
a372 4
  st->current_table=tcurrent;
  st->current_row=tcurrent->List;
  if (st->current_row != NULL) {
   while(st->current_row->Next != NULL) st->current_row=st->current_row->Next;
d374 4
a377 4
  st->current_cell=NULL;
  if (st->current_row != NULL) st->current_cell=st->current_row->List;
  if (st->current_cell != NULL) {
   while(st->current_cell->Next != NULL) st->current_cell=st->current_cell->Next;
d379 1
a379 1
  if (st->current_cell != NULL)
d382 1
a382 1
    realcurrent.prevnextptr=(HStream * *)(&(st->current_cell->List));
d398 4
a401 4
  return table_skip_current_r(st, realcurrent/**realcurrent.prevnextptr*/);
/* st->current_table will be NULL or relevant nested table
   st->current_row will be NULL if no rows yet
   st->current_cell will be NULL if no columns yet*/
@


1.2.2.22
log
@CELLSPACING now filled in table_stream struct. CELLPADDING and CELLSPACING
both default to 2 pixels rather than zero.
@
text
@a86 16
     else
     {
         treturn_val->cellpadding=2; /* Default to 2 pixels padding */
         treturn_val->has_cellpadding = 1;
     }

     if (ATTR_SET(CELLSPACING))
     {
         treturn_val->cellspacing=ATTR_VAL(CELLSPACING);
         treturn_val->has_cellspacing = 1;
     }
     else
     {
         treturn_val->cellspacing=2; /* Default to 2 pixels spacing */
         treturn_val->has_cellspacing = 1;
     }
@


1.2.2.23
log
@Corrected default cellspacing to 1 pixel instead of 2
@
text
@d100 1
a100 1
         treturn_val->cellspacing=1; /* Default to 1 pixel spacing */
@


1.2.2.24
log
@Added hack to support <FORM> tags between <TABLE> and <TD>
@
text
@a323 6

    if (st->pendingformfortable)
    {
        st->special_return = st->pendingformfortable;
        st->pendingformfortable = NULL;
    }
@


1.2.2.25
log
@HEIGHT and BACKGROUND attributes on a TABLE tag now supported, with appropriate
macros for extracting the information from a table_stream struct. A table_stream
no longer needs to be the same length or shorter than an HStream, though several
of the fields do still need to be in the same position in each structure.
@
text
@a81 2
     treturn_val->background=ATTR_STR(BACKGROUND);

a130 7
     }

     if (ATTR_SET(HEIGHT))
     {
         treturn_val->height     = ATTR_VAL(HEIGHT);
         treturn_val->has_height = 1;
         treturn_val->height_units = st->curattrs[HEIGHT].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
@


1.1
log
@file HTMLTables was initially added on branch ARTtmp.
@
text
@d1 273
@


1.1.2.1
log
@Added in Tony Cheal's table code. Various other bug fixes.
@
text
@a0 273
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/***************************************************/
/* File   : HTMLTables.c                           */
/* Purpose: Parsing of Tables and other            */
/*          table related functions                */
/* Author : Tony Cheal                             */
/* History: 12-Feb-97: Created                     */
/***************************************************/
/*have to repeat this here because our header file depends on it!*/
#include "HTMLTables.h"
#include "tablestruc.h"

#ifdef TonyTables
table_stream   * __html_current_table=0; /* this is also an HStream */
table_row      * __html_current_row=0;
table_headdata * __html_current_headdata=0;

static void skipptr(char **html)
{
char *ptr;
/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
/*
 * why the f*** wasn't this a function, and done earlier???
 * under what circumstance do you want to get the pointer stuck?
 */

 if (html != NULL) {
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) {/*printf("!%c",*ptr);*/ptr++;}
  if (*ptr=='>') ptr++;
  *html=ptr;
  /*printf("\n");*/
 }
}

/* spurious externs... */

HStream * __html_stream_return_tag(StreamTokens *st, Tag tag,char **html, int start, char *url);
void __html_stream_free_anchor(AnchorInfo **anchor);

HStream * __html_table_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
 HStream * return_val;
 AnchorInfo *anc;
 styleinfo *s;

 anc = __html_get_anchor_info(st, html, next_tag);
 return_val=__html_stream_return_tag(st,next_tag,html,0,url);
 if (return_val != NULL) {
     table_stream * treturn_val=(table_stream *) return_val;

     return_val->tag=TABLE;
     treturn_val->finished=0;
     treturn_val->List=NULL;
     treturn_val->Next=NULL; /*just in case?*/

     if (anc)
     {
         treturn_val->border      = anc->border;
         if (anc->size & 0x80000000)
         {
           treturn_val->cellpadding = anc->size & 0x7fffffff;
           treturn_val->flags    |= TABLEFLAG_CELLPADDING;
         }
         if (anc->spacing & 0x80000000)
         {
           treturn_val->cellspacing = anc->spacing & 0x7fffffff;
           treturn_val->flags      |= TABLEFLAG_CELLSPACING;
         }
         treturn_val->cols        = anc->cols;
         if (anc->cols)
           treturn_val->flags    |= TABLEFLAG_COLS;
         /*treturn_val->align       = anc->alignment;*/
         if (anc->width & 0x01000000)
         {
             treturn_val->flags  |= TABLEFLAG_WIDTH;
             treturn_val->width   = anc->width & 0x00ffffff;
             treturn_val->flags  |= (anc->width >> 28) << TABLEFLAG_UNITS_SHIFT;
         }
     }
     /* Stack away style information */
     treturn_val->stackedstyle = (styleinfo *) __html_malloc(sizeof(styleinfo), 1);
     if (treturn_val->stackedstyle)
        *treturn_val->stackedstyle = st->_stream_style;

 }
 if (anc)
    __html_stream_free_anchor(&anc);

/*should set the style stuff?*/
 return return_val;
}

HStream * __html_table_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url)
{
/*printf("table_table_end_tag 0x%x",(int) __html_current_table);*/
 if (__html_current_table != NULL)
 {
     __html_current_table->finished=-1;
     if (__html_current_table->stackedstyle)
     {
         st->_stream_style = *__html_current_table->stackedstyle;
         __html_free(__html_current_table->stackedstyle, 0);
         __html_current_table->stackedstyle == 0;
     }
 }
 skipptr(html);
 return NULL;
}

HStream * __html_table_row_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
 if (__html_current_table != NULL) {
  table_row * trow=(table_row *)__html_malloc(sizeof(table_row)+1,1);
  if (trow != NULL)
  {
    AnchorInfo *anc;
    if (__html_current_row != NULL)
      __html_current_row->Next=trow;
    else
      __html_current_table->List=trow;
    trow->Next=NULL;
    trow->List=NULL;

    anc = __html_get_anchor_info(st, html, next_tag);
    if (anc)
    {
       trow->align = anc->alignment;
       trow->valign = anc->valign;
       __html_stream_free_anchor(&anc);
    }
  }
 }
 skipptr(html);
 return NULL;
}

HStream * __html_table_row_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url)
{
 skipptr(html);
 return NULL;
/*junk up to the next <TR> will be added to the last <TR><TD>*/
}

static HStream * table_thing_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size,int tag)
{
 AnchorInfo * anc;
 if (__html_current_table != NULL) {
  if (__html_current_row != NULL) {
   table_headdata * theaddata=(table_headdata *)__html_malloc(sizeof(table_headdata)+1,1);
   if (theaddata != NULL)
   {
     if (__html_current_headdata != NULL)
       __html_current_headdata->Next=theaddata;
     else
       __html_current_row->List=theaddata;
     theaddata->Next=NULL;
     theaddata->List=NULL;
     theaddata->Tag=tag;
     theaddata->bgcol=(unsigned int) -1;
     anc=__html_get_anchor_info(st,html,next_tag);
     if (anc != NULL) {
       theaddata->ColSpan=anc->colspan;
       theaddata->RowSpan=anc->rowspan;
       theaddata->background=strdup(anc->src);
       theaddata->bgcol=anc->maxlength;
       theaddata->width=anc->cols;
       theaddata->height=anc->rows;
       theaddata->VAlign=anc->valign;
       theaddata->Align=anc->alignment;
       /*printf("ColSpan is: 0x%x\n",theaddata->ColSpan);
       printf("RowSpan is: 0x%x\n",theaddata->RowSpan);*/
       __html_stream_free_anchor(&anc);
     }
     if (__html_current_table->stackedstyle != NULL)
     {
         __html_style_init(&st->_stream_style);
         if (tag == TagTableHead)
            st->_stream_style.bold = 1;
     }
   }
  }
 }
 skipptr(html);
 return NULL;
}

HStream * __html_table_data_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
 return table_thing_start_tag(st,next_tag,html,url,size,TagTableData);
}

HStream * __html_table_data_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url)
{
 skipptr(html);
 return NULL;
/*junk up to next <TD> will be added to the last <TD>*/
}

HStream * __html_table_head_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
 return table_thing_start_tag(st,next_tag,html,url,size,TagTableHead);
}

HStream * __html_table_head_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url)
{
 return __html_table_data_end_tag(st,next_tag,html,url);
}

HStream * * table_skip_current(HStream * current)
{
 __html_current_table=NULL; /*to stop inadvertant <TR><TD> causing trouble*/
 __html_current_row=NULL;
 __html_current_headdata=NULL;
/*printf("calling table_skip_current\n");*/
 return table_skip_current_r(current);
}


HStream * * table_skip_current_r(HStream * current)
{
 HStream * * realcurrent;
/* printf("table is 0x%x\n",(int)__html_current_table);
   printf("row is 0x%x\n",(int)__html_current_row);
   printf("headdata is 0x%x\n",(int)__html_current_headdata);*/
 if (current == NULL) return NULL;
 realcurrent=&(current->next);
 if (!(current->tag == TABLE && ISBODY(current))) return realcurrent;
 {
  table_stream * tcurrent;
  tcurrent = (table_stream *) current;
  if (tcurrent->finished) return realcurrent;
/*incomplete table, so go down to rows etc.*/
  __html_current_table=tcurrent;
  __html_current_row=tcurrent->List;
  if (__html_current_row != NULL) {
   while(__html_current_row->Next != NULL) __html_current_row=__html_current_row->Next;
  }
  __html_current_headdata=NULL;
  if (__html_current_row != NULL) __html_current_headdata=__html_current_row->List;
  if (__html_current_headdata != NULL) {
   while(__html_current_headdata->Next != NULL) __html_current_headdata=__html_current_headdata->Next;
  }
  if (__html_current_headdata != NULL) realcurrent=(HStream * *)(&(__html_current_headdata->List));
  else realcurrent=NULL;
  if (realcurrent == NULL) return realcurrent;
  if (*realcurrent == NULL) return realcurrent;
  while((*realcurrent)->next != NULL) realcurrent=&((*realcurrent)->next);
/*printf("recursing\n");*/
  return table_skip_current_r(*realcurrent);
/* __html_current_table will be NULL or relevant nested table
   __html_current_row will be NULL if no rows yet
   __html_current_headdata will be NULL if no columns yet*/
 }
}
#endif
@

head	1.13;
access;
symbols
	HTMLLib-0_04:1.13
	HTMLLib-0_03:1.13
	HTMLLib-0_02:1.13
	HTMLLib-0_01:1.13
	ahodgkin_207release:1.8
	ahodgkin_206release:1.6
	ahodgkin_205release:1.2
	ahodgkin_204release:1.2
	ahodgkin_133beta:1.1.2.15
	kbracey_126:1.1.2.12
	kbracey_AW97patch:1.1.2.12
	ahodgkin_AW97:1.1.2.11
	Web:1.1.0.2;
locks; strict;
comment	@# @;


1.13
date	99.09.02.12.47.59;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	99.08.10.14.00.31;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	99.06.04.14.51.18;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	98.11.05.15.14.22;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	98.11.05.14.38.46;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	98.08.19.14.03.28;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	98.08.07.16.11.44;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	98.07.06.14.07.33;	author ahodgkin;	state Exp;
branches;
next	1.5;

1.5
date	98.05.15.13.36.38;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	98.05.15.13.32.42;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	98.05.08.11.34.03;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	98.02.17.10.42.11;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	97.07.24.16.20.50;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	97.07.24.16.20.51;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.07.25.10.01.20;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	97.07.25.11.07.51;	author ahodgkin;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	97.09.15.13.08.02;	author ahodgkin;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	97.09.19.15.14.54;	author ahodgkin;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	97.09.25.16.50.36;	author ahodgkin;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	97.09.30.14.13.39;	author kbracey;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	97.10.08.12.33.34;	author kbracey;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	97.10.13.13.40.11;	author kbracey;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	97.10.14.13.40.53;	author kbracey;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	97.10.15.14.58.47;	author ahodgkin;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	97.10.22.14.21.55;	author kbracey;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	97.11.27.18.01.20;	author ahodgkin;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	98.01.05.12.23.41;	author ahodgkin;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	98.01.09.16.31.06;	author ahodgkin;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Handling of colour attributes changed. Used source code from Mozilla to
get colour handling pretty much identical to Navigator or MSIE.
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -*-C-*-
 *
 */

#include "stdio.h"        /* For NULL etc */
#include "stdlib.h"       /* For bsearch */
#include "limits.h"       /* For INT_MAX */
#include "html2_ext.h"    /* For the HTML bits */
#include "tags.h"         /* for PCDATA */
#include "struct.h"       /* For the structures */
#include "string.h"       /* For string handling */
#include "internal.h"     /* predefinitions of functions */
#include "rules.h"
#include "unixlib.h"
#include "elementinf.h"
#ifdef TonyTables
#include "HTMLTables.h"
#endif

static unsigned int __attribute_is_space(char c);
static void  __attribute_munge_spaces(char *s, unsigned int leave_crlf);
static int compare_attribute(const void *keyp, const void *membp);

/*
 * Returns 1 if the given char is a space, \n or \r.
 */

unsigned int __attribute_is_space(char c)
{
  if (c == ' ' || c == '\r' || c == '\n') return 1;
  else                                    return 0;
}

/*
 * This routine parses the attributes found in a start tag, and fills in
 * st->curattrs with the found values. Filling in of default values is not done
 * here.
 */
void __html_process_attributes(StreamTokens *st, Tag *tag, char *html, char *url)
{
    const Attribute *attrs = tag->attributes;
    Attribute       *found_attr;
    AttrInfo        *curattr;

    char      *info  = strndup(html, __html_tag_length(html));
    char      *start_ptr = info;
    char      *p = info, *ptr, *pointer = 0, c, replace;
    int        has_quotes, expecting_equals, parsing_value, just_started;

    int        max_attrs = tag->max_attributes;

    /* Reset the attribute table */
    __html_reset_curattrlist(st);

    /* Make parsing a little easier */
    __attribute_munge_spaces(start_ptr, 1);

    /* Skip the main part of the tag (e.g. '<a' for anchors) */

    while (
            !__attribute_is_space(*info) &&
            (*info != '\0') &&
            (*info != '>')
          )
          info++;

    /* Skip the next set of spaces */

    while (__attribute_is_space(*info)) info++;

    /* We have hit the end of the tag? */
    if ((*info == '\0') || (*info== '>'))
    {
        __html_free(start_ptr,0);
        return;
    }

    {
        /* Chop off the closing '>' */
        int len = strlen(info);
        if (info[len-1] == '>')
            info[len-1] = '\0';
    }

    p = info;

    /* We are just working inside the tag now: */

    while (*info != '\0')
    {
      /*
       * See __html_tag_length for a similar bit of
       * code with comments describing what it does
       */

      has_quotes       = 0;
      expecting_equals = 0;
      parsing_value    = 0;
      just_started     = 0;

      while (*p != '\0')
      {
        if (expecting_equals)
        {
          if (!(*p <= ' ' || *p == '='))
          {
            p--;
            break;
          }
          else if (*p == '=')
          {
            expecting_equals = 0;
            parsing_value    = 1;
            just_started     = 1;

            do {p++;} while (*p && *p <= ' ');
          }
          else p++;
        }
        else if (!parsing_value)
        {
          if (*p <= ' ') expecting_equals = 1;
          else if (*p == '>') break;
          else if (*p == '=')
          {
            expecting_equals = 0;
            parsing_value    = 1;
            just_started     = 1;

            do {p++;} while (*p && *p <= ' ');
          }
          else p++;
        }
        else
        {
          if (*p == '\'' || *p == '"' || *p == '`')
          {
            char skip = *p;

            if (just_started) has_quotes = skip;
            else if (has_quotes == skip)
            {
              while (*(++p) == skip);
              break;
            }
          }
          else if (*p <= ' ' || *p == '>')
          {
            if (!has_quotes) break;
          }

          p++;
          just_started = 0;
        }
      }

      /*
       * The summary here is that 'p' will be on the closing '>' or first
       * char of an unusual terminator; 'info' will point to the start of
       * the attribute name.
       */

      c  = *p;
      *p = '\0';

    /*
     * Look to see what we have. First off scan through to see if we have
     * an '=' sign. If we do, store for later use!
     */
        ptr=info;
        while (*ptr != '\0') {
          if (*ptr=='=') {
            *ptr='\0';
            ptr++;
            while (__attribute_is_space(*ptr)) ptr++;
            break;
          }
          if (__attribute_is_space(*ptr)) {
            *ptr='\0'; ptr++;
            while (__attribute_is_space(*ptr)) ptr++;
            if (*ptr=='=') {
              ptr++;
              while (__attribute_is_space(*ptr)) ptr++;
            }
            break;
          }
          ptr++;
        }

    /*
     * At this point then, 'info' points to the name, 'ptr' points
     * to the value, 'p' points to the NUL after the value. Now
     * try and find the attribute in the lists of known items.
     */

        UPPER_CASE(info);

        found_attr = bsearch(info, attrs, max_attrs, sizeof attrs[0], compare_attribute);

        if (!found_attr && tag->has_coreattrs)
            found_attr = bsearch(info, Core_Attributes, MAX_CORE_ATTRIBUTES, sizeof Core_Attributes[0], compare_attribute);

        if (!found_attr && tag->has_i18n)
            found_attr = bsearch(info, I18n_Attributes, MAX_I18N_ATTRIBUTES, sizeof I18n_Attributes[0], compare_attribute);

        if (!found_attr && tag->has_events)
            found_attr = bsearch(info, Event_Attributes, MAX_EVENT_ATTRIBUTES, sizeof Event_Attributes[0], compare_attribute);

        /*
         * If we have not found anything that is allowed, skip it
         */
        if (!found_attr)
        {
          if (c=='\0') break;
          *p=c;
          while (__attribute_is_space(*p)) p++;
          info=p;
          continue;
        }

        /*
         * If the value inside ptr is enclosed in quotes, we need to
         * strip them off!
         */

        if (*ptr=='"')
        {
            ptr++;
            pointer=strpbrk(ptr,"\"");
        }
        else if (*ptr=='\'')
        {
            ptr++;
            pointer=strpbrk(ptr,"\'");
        }
        else if (*ptr=='`')
        {
            ptr++;
            pointer=strpbrk(ptr,"`");
        }

        if (pointer != NULL)
        {
            replace=*pointer;
            *pointer='\0';
        }
        else replace='\0';

        /*
         * We are going to slot this attribute value into our array.
         * Remove any prior value first...
         */

        curattr = &st->curattrs[found_attr->tag];
        if (curattr->pleasefree)
        {
            __html_free(curattr->data.raw, 0);
            curattr->pleasefree=0;
        }
        curattr->present = 1;

        __attribute_munge_spaces(ptr, 0);

        switch (found_attr->rule)
        {
            /* A piece of text (character entities allowed). */
            case CDATA:
                __html_unescape_string(ptr, 0);
                curattr->data.text = strdup(ptr);
                curattr->pleasefree = 1;
                break;

            /* A SGML name */
            case NAME_RULE:
                curattr->data.text = strdup(ptr);
                curattr->pleasefree = 1;
                break;

            /* Either there or not */
            case EMPTY:
                break;

            case LENGTH_RULE:
                __html_unescape_string(ptr, 0);
                curattr->miscflag = strchr(ptr, '%') ? 1 : 0;
                /* Fall through */

            /* Goody! An integer! */
            case NUMBER:
                if (!isdigit(*ptr)) curattr->data.number = found_attr->set ? atoi(found_attr->set) : 0;
                else                curattr->data.number = atoi(ptr);
                break;

            /* Erk - a choice... */
            case SET:
            {
                const char *s = found_attr->set;
                const char *p;
                int n;
                LOWER_CASE(ptr);

                for (n = 1; *s;)
                {
                    p = ptr;
                    while (*s && *s != '|' && *s != ',')
                    {
                        if (*s++ != *p++)
                            goto next;
                    }
                    if (*p == '\0')
                    {
                        curattr->data.number = n;
                        break;
                    }

                  next:
                    while (*s && *s != '|' && *s != ',')
                        s++;

                    if (*s == '|')
                        s++, n++;
                    else if (*s == ',')
                        s++;

                }
                break;
            }

            /* A coordinate list (a list of integers) */
            case COORDS_RULE:
            {
                const char *p, *next, *percent;
                int n;

                /*
                 * Count the seperators. Start the count at two because
                 * the first two items are used for the type of item and
                 * number of coordinates.
                 */
                for (n = 2, p = ptr; *p; p = next, n++)
                {
                    next = p + strcspn(p, "0123456789%");
                    if (!strchr("0123456789%", *next)) break;
                    next += strspn(next, "0123456789%");
                }

                curattr->data.coords = (int *) __html_malloc(sizeof(int), n);
                if (!curattr->data.coords)
                    break;

                /*
                 * Item 0 left free to put shape in later;
                 * item 2 = number of coords, items 2 + = coords
                 */
                curattr->data.coords[1] = n - 2;

                for (n = 2, p = ptr; *p; p = next, n++)
                {
                    next = p + strcspn(p, "0123456789%");
                    if (!strchr("0123456789%", *next)) break;

                    curattr->data.coords[n] = atoi(next);
                    if (curattr->data.coords[n] < 0) curattr->data.coords[n] = 0;

                    percent = strchr(next, '%');
                    next   += strspn(next, "0123456789%");

                    if (percent && percent < next)
                        curattr->data.coords[n] = -curattr->data.coords[n];
                }

                break;
            }

            /* A colour (duh!) */
            case COLOUR_RULE:
                __html_unescape_string(ptr, 0);
                curattr->data.number = __html_convcol(ptr, 1);
                break;

            /* The style of an OL */
            case OLSTYLE_RULE:
                __html_unescape_string(ptr, 0);
                if (tag->tag_no == TAG_OL)
                {
                    if (strchr("1aAiI", ptr[0]))
                        curattr->data.number = ptr[0];
                }
                else
                {
                    if (strchr("1aAiIdcsDCS", ptr[0]))
                    {
                        curattr->data.number = ptr[0];
                        if (curattr->data.number == 'D' ||
                            curattr->data.number == 'C' ||
                            curattr->data.number == 'S')
                            curattr->data.number += 32;
                    }
                }
                break;

            /* A URL - lets relativise */
            case URL_RULE:
            {
                char *p;

                /*
                 * HREF tags *should* be able to have entities in them, so we should
                 * unescape the string. However, many sites put CGI-style form info
                 * in anchors, which we do not want to unescape. Therefore we must
                 * ensure that only entirely correctly specified entities are
                 * escaped (must have closing semicolon).
                 */

                 __html_unescape_string(ptr, 1);

                /*
                 * Strip any trailing spaces
                 */

                p = ptr + strlen(ptr) - 1;
                while (p >= ptr && *p == ' ') *p = '\0', p--;

                curattr->data.text  = __html_relativise_url(url, ptr);
                curattr->pleasefree = 1;
            }
            break;
        }

        if (pointer != NULL) *pointer = replace;

        /* Skip this bit (or if it was the last one exit) */

        if (c=='\0') break;

        *p=c;

        /* Skip over spaces */

        while (__attribute_is_space(*p)) p++;

        info=p;
    }

    __html_free(start_ptr,0);
}

static int compare_attribute(const void *keyp, const void *membp)
{
    const char       *key = (const char *)      keyp;
    const Attribute *memb = (const Attribute *) membp;

    return strcmp(key, memb->name);
}


/*
 * This routine parses the attributes found in an EMBED tag, and attaches
 * them as a list of PARAMs to obj.
 */
void __html_process_embed_attributes(StreamTokens *st, Tag *tag, char *html, HStream *obj)
{
    const Attribute *attrs = tag->attributes;
    Attribute       *found_attr;

    char      *info  = strndup(html, __html_tag_length(html));
    char      *start_ptr = info;
    char      *p = info, *ptr, *pointer = 0, c;
    int        has_quotes, expecting_equals, parsing_value, just_started;
    HStream   *param, *h = NULL, **hprev = &obj->info->object.hstream;
    char      *name;

    int        max_attrs = tag->max_attributes;

    /* Make parsing a little easier */
    __attribute_munge_spaces(start_ptr, 0);

    /* Skip the main part of the tag (e.g. '<a' for anchors) */
    while (
          (*info != ' ')  &&
          (*info != '\0') &&
          (*info != '>')
          )
        info++;

    /* Skip the next set of spaces */
    while (*info == ' ') info++;

    /* We have hit the end of the tag? */
    if ((*info == '\0') || (*info== '>'))
    {
        __html_free(start_ptr,0);
        return;
    }

    /* Grab just the bit inside the tag: convert \n, \t and \r to ' ' */

    p = info;

    while ((*p != '>') && (*p != '<') && (*p != '\0'))
    {
      p++;
    }

    /* Snip off the '>' at the end now, then move back to the begining */

    *p = '\0';
    p  = info;

    /* We are just working inside the tag now: */

    while (*info != '\0')
    {
      /* See __html_tag_length for a similar bit of
       * code with comments describing what it does
       */

      has_quotes       = 0;
      expecting_equals = 0;
      parsing_value    = 0;
      just_started     = 0;

      while (*p != '\0')
      {
        if (expecting_equals)
        {
          if (!(*p <= ' ' || *p == '='))
          {
            p--;
            break;
          }
          else if (*p == '=')
          {
            expecting_equals = 0;
            parsing_value    = 1;
            just_started     = 1;

            do {p++;} while (*p && *p <= ' ');
          }
          else p++;
        }
        else if (!parsing_value)
        {
          if (*p <= ' ') expecting_equals = 1;
          else if (*p == '>') break;
          else if (*p == '=')
          {
            expecting_equals = 0;
            parsing_value    = 1;
            just_started     = 1;

            do {p++;} while (*p && *p <= ' ');
          }
          else p++;
        }
        else
        {
          if (*p == '\'' || *p == '"' || *p == '`')
          {
            char skip = *p;

            if (just_started) has_quotes = skip;
            else if (has_quotes == skip)
            {
              while (*(++p) == skip);
              break;
            }
          }
          else if (*p <= ' ' || *p == '>')
          {
            if (!has_quotes) break;
          }

          p++;
          just_started = 0;
        }
      }

      c  = *p;
      *p = '\0';

    /*
     * Look to see what we have. First off scan through to see if we have
     * an '=' sign. If we do, store for later use!
     */
        ptr=info;
        while (*ptr != '\0') {
          if (*ptr=='=') {
            *ptr='\0';
            ptr++;
            while (*ptr == ' ') ptr++;
            break;
          }
          if (*ptr==' ') {
            *ptr='\0'; ptr++;
            while (*ptr==' ') ptr++;
            if (*ptr=='=') {
              ptr++;
              while (*ptr==' ') ptr++;
            }
            break;
          }
          ptr++;
        }
        name = strdup(info);
        if (!name) break;

    /*
     * Next look to see if we can find the suposed anchor element
     * in the list provided
     */
        UPPER_CASE(info);

    //    Printf ("anchor element '%s', data '%s'\n", info, ptr, info, max_anc, anc);

        found_attr = bsearch(info, attrs, max_attrs, sizeof attrs[0], compare_attribute);

        /*
         * If _have_ found something that is allowed, skip it! We only want
         * unknown attributes here...
         */
        if (found_attr) {
            __html_free(name, 0);
            if (c=='\0') break;
            *p=c; p++;
            info=p;
            continue;
        }

        /*
         * If the value inside ptr is enclosed in quotes, we need to
         * strip them off!
         */
        if (*ptr=='"')
        {
            ptr++;
            pointer=strpbrk(ptr,"\"");
        }
        else if (*ptr=='\'')
        {
            ptr++;
            pointer=strpbrk(ptr,"\'");
        }
        if (pointer != NULL) *pointer='\0';

        /*
         * Allocate a PARAM.
         */
        param = __html_construct_param(st, name, NULL, parsing_value ? strdup(ptr) : NULL, paramtype_DATA);
        if (param)
        {
            *hprev = param;
            param->prev = h;
            hprev = &param->next;
            h = param;
        }

        if (pointer != NULL) *pointer='"';

    /* Skip this bit, or if it was the last one exit */
        if (c=='\0') break;
          *p=c; /*p++;*/

    /* Skip over spaces */
        while (*p == ' ')
            p++;

        info=p;
    }

    __html_free(start_ptr,0);
}

typedef struct colour_name { char *name; unsigned int colour; } colour_name;

#include "colourlist.h"

static int compare_colname(const void *keyp, const void *membp)
{
    const char        * key  = (const char        *) keyp;
    const colour_name * memb = (const colour_name *) membp;
    const char *a = key;
    const char *b = memb->name;

    for (;;)
    {   char c1 = *a++, c2 = *b++;
        int d = toupper(c1) - toupper(c2);
        if (isspace(c1))
        {
            b--;
            continue;
        }
        if (isspace(c2))
        {
            a--;
            continue;
        }
        if (d != 0) return d;
        if (c1 == 0) return 0;     /* no need to check c2 */
    }
}

/*
 * If 'invalid_returns_random' is non-zero, an invalid colour string leads
 * to a random RGB result. Otherwise, 1 is returned - this flags an error
 * as it is not of the form '0xBBGGRR00'.
 */
unsigned int __html_convcol(const char *s, int invalid_returns_random)
{
  /* 02-Sep-1999 (ADH): Original algorithm - doesn't work as MSIE etc. */

//    char r, g, b;
//    unsigned int c = 0;
//    unsigned int d = 0;
//
//    while (*s==' ' || *s=='"' || *s=='\'')
//        s++;
//
//    if (*s == '#')
//    {
//        s++;
//
//  retry_colour:
//
//        while (*s)
//        {
//            c=c*16+__html_unnumeric_escape(toupper(*s));
//            s++;
//        }
//
//        r=c>>16;
//        g=c>>8;
//        b=c;
//
//        return (b<<24) | (g<<16) | (r<<8);
//    }
//    else
//    {
//        const colour_name *entry;
//
//        if ((entry = bsearch(s, colour_list, SizeOfArray(colour_list), sizeof colour_list[0], compare_colname)) != NULL)
//            return entry->colour;
//        else
//        {
//            if (isxdigit(s[0]) && isxdigit(s[1]) && isxdigit(s[2]))
//                goto retry_colour; /* May be a colour missing initial '#' */
//        }
//
//        if (invalid_returns_random) return rand() << 8;
//        else                        return 1;
//    }

  /* 02-Sep-1999 (ADH): Adapted from Mozilla source -     */
  /*                    lib/layout/layimage.c 16-Oct-1998 */

  int i, j, len;
  int val, bval;
  int red_val, green_val, blue_val;
  int bytes_per_val;

  while (*s==' ' || *s=='"' || *s=='\'') s++;

  len = strlen(s);

  if (!len)
  {
    if (invalid_returns_random) return rand() << 8;
    else                        return 1;
  }

  /* Strings not starting with a '#' are probably named colours; */
  /* look them up in the table                                   */

  if (*s == '#')
  {
    s++;
    len--;

    if (!len)
    {
      if (invalid_returns_random) return rand() << 8;
      else                        return 1;
    }
  }
  else
  {
    const colour_name *entry;

    if (
         (entry = bsearch(s,
                          colour_list,
                          SizeOfArray(colour_list),
                          sizeof colour_list[0],
                          compare_colname)
         ) != NULL
       )
       return entry->colour;
  }

  /* This is not a (recognised) colour name, or starts with */
  /* a '#' (so probably a component specifier)              */

  red_val = 0;
  green_val = 0;
  blue_val = 0;

  bytes_per_val = (int)((len + 2) / 3);
  if (bytes_per_val > 4)
  {
    bytes_per_val = 4;
  }

  for (j=0; j<3; j++)
  {
    val = 0;
    for (i=0; i<bytes_per_val; i++)
    {
      if (*s == '\0')
      {
        bval = 0;
      }
      else
      {
        bval = __html_unnumeric_escape(toupper(*s));
        s++;
      }
      val = (val << 4) + bval;
    }
    if (j == 0)
    {
      red_val = val;
    }
    else if (j == 1)
    {
      green_val = val;
    }
    else
    {
      blue_val = val;
    }
  }

//  if(double_three_byte_codes && bytes_per_val == 1)
//  {
//    red_val = (red_val << 4) + red_val;
//    green_val = (green_val << 4) + green_val;
//    blue_val = (blue_val << 4) + blue_val;
//  }

  while ((red_val > 255)||(green_val > 255)||(blue_val > 255))
  {
    red_val = (red_val >> 4);
    green_val = (green_val >> 4);
    blue_val = (blue_val >> 4);
  }

  return (blue_val<<24) | (green_val<<16) | (red_val<<8);
}

/*************************************************************************/
/* static void __anchor_munge_spaces(char *s)                            */
/*************************************************************************/
/* Given a string convert most control chars into spaces. LF and CR are  */
/* removed, so the string may not be as long on exit as it was on entry. */
/* This all makes parsing the string easier :)                           */
/*                                                                       */
/* 10/08/1999 (ADH): Second parameter is 0 for behaviour as described    */
/*                   above, or 1 to turn all control codes into spaces   */
/*                   *except* for CR and LF, which are left in place.    */
/*************************************************************************/
static void  __attribute_munge_spaces(char *s, unsigned int leave_crlf)
{
  while (*s != '\0')
  {
    if (*s == '\n' || *s == '\r')
    {
      if (!leave_crlf)
      {
        *s=' ';
        strcpy(s, s + 1);
        continue;
      }
    }
    else if (*s < ' ' && *s > 0) *s = ' ';

    s++;
  }
}

/*
 * Given a pointer to the start of a tag (ie pointing at the '<')
 * return the length of the tag, including the delimiting angle brackets.
 * If unusually terminated, it does not include the unusual terminator.
 * If it runs out of input (ie hits '\0') it returns -1.
 *
 * For example:  __html_tag_length("<B>Hello") == 3
 *               __html_tag_length("<B<I>Hello") == 2
 *               __html_tag_length("<B") == -1
 */
int __html_tag_length(const char *s1)
{
  const char *p=s1 + 1;
  int has_quotes, expecting_equals, parsing_value, just_started;

  /* Skip leading spaces */
  while (*p <= 32 && *p != '\0')
        p++;

  /* Skip the main part */

  while (
          (*p != ' ')  &&
          (*p != '\0') &&
          (*p != '>')  &&
          (*p != '<')
        )
        p++;

  /* Skip the next set of spaces */
  while (*p <= 32 && *p != '\0')
        p++;

  /* Loop over attributes */

  while (*p != '\0' && *p != '>')
  {
    has_quotes       = 0;
    expecting_equals = 0;
    parsing_value    = 0;
    just_started     = 0;

    /* Split attributes into name/value pairs. Ignore quotes not in values.
     * This allows rapid resyncing if someone misses a quote off.
     */

    while (*p != '\0')
    {
      if (expecting_equals)
      {
        /* If we've finished looking at an attribute name and we're
         * waiting for the value or to see if there is a value, then
         * hitting anything other than '=' or white space means we
         * aren't getting one.
         */

        if (!(*p <= ' ' || *p == '='))
        {
          /* Must back the pointer up or we end up chopping off
           * the first char of the next attribute name (this is
           * not so important here as we're not actually trying
           * to read the names, but is important where similar
           * code is used to extract the actual details and so
           * is included here for consistency).
           */

          p--;
          break;
        }
        else if (*p == '=')
        {
          expecting_equals = 0;
          parsing_value    = 1;
          just_started     = 1;

          do {p++;} while (*p && *p <= ' ');
        }
        else p++;
      }
      else if (!parsing_value)
      {
        /* If we hit white space whilst parsing the name,
         * we should look for an equals sign for the value
         */

        if (*p <= ' ') expecting_equals = 1;

        /* Hitting a '>' during name parsing always means
         * we've finished with the element
         */

        else if (*p == '>') break;

        /* Hitting an '=' sign directly jumps us straight
         * to parsing the value
         */

        else if (*p == '=')
        {
          expecting_equals = 0;
          parsing_value    = 1;
          just_started     = 1;

          do {p++;} while (*p && *p <= ' ');
        }
        else p++;
      }
      else
      {
        /* We're parsing the attribute value here */

        if (*p == '\'' || *p == '"' || *p == '`')
        {
          char skip = *p;

          /* If the value starts with a quote mark,
           * white space and '>' won't close it; else
           * they will. We don't skip multiple opening
           * quotes as you can't distinguish them from
           * legal things like 'alt=""'.
           */

          if (just_started) has_quotes = skip;

          /* Otherwise, if we've got another quote mark of the
           * same type as the opening one, this attribute value
           * is finished with.
           */

          else if (has_quotes == skip)
          {
            /* Skip multiple closing quotes - a common error... */

            while (*(++p) == skip);
            break;
          }
        }
        else if (*p <= ' ' || *p == '>')
        {
          /* White space and '>' can only appear in a value if
           * it is a quoted one
           */

          if (!has_quotes) break;
        }

        p++;
        just_started = 0;
      }
    }

    /* Skip over spaces */

    while (*p <= ' ' && *p != '\0') p++;
  }

  if (*p=='\0') return -1;

  if (*p=='>') p++;

  return (int)(p-s1);
}

void __html_reset_curattrlist(StreamTokens *st)
{
    int i;

    for (i=0; i<MAX_ATTRS; i++)
        if (st->curattrs[i].pleasefree)
            __html_free(st->curattrs[i].data.raw, 0);

    memset(st->curattrs, 0, sizeof st->curattrs);
}

/********************************************************************/
/* static char *__html_relativise_url(char *base, char *link)       */
/********************************************************************/
/* Given a base URL and another URL (e.g. a link or an image), this */
/* routine constructs the resultant URL from the pair               */
/********************************************************************/

char * __html_relativise_url(const char * base, const char * link)
{
  char        * ret = NULL;

//  char        * copy;
//  char        * buffer;
//  char        * uri;
//  extern char * __html_tidy_url(char * url);

  if (link == NULL) return NULL;

  if (base == NULL) // || (strstr(base,"ADFS:") != NULL)
  {
    ret = strdup(link);
    return ret;
  }

  /* Strip preceeding spaces */

  while (*link == ' ') link++;

  /* Cope with empty link URLs */

  if (link[0] == '\0') return strdup(base);

  /* Otherwise, just go for it... */

  return __html_url_canonicalise_url(0, base, link);

// OLD CODE: Want to have used the above call for quite a
// while longer before the below gets cut out for good in
// case we find a good reason to use the below instead
// of the URL module's routines.
//
//  /* Check for an in-document link */
//
//  if (link[0] == '#')
//  {
//    ret = __html_malloc(strlen(link) + strlen(base) + 1, 1);
//    if (ret) sprintf(ret,"%s%s",base,link);
//
//    return ret;
//  }
//
//  /* Should have a Fetcher_Relativise call                               */
//  /*                                                                     */
//  /* Simple test for a fully qualified URL. Look for '://' in the string */
//  /* Also catch "mailto:" and "x500:" URLs at this point. We expect the  */
//  /* method to be at the start of the string. (This is to allow for      */
//  /* funny proxies :)                                                    */
//  /*                                                                     */
//  /* The test on ret - link <= 9 ensures URLs that are indeed relative,  */
//  /* but contain URLs themselves (e.g. as part of some CGI info in the   */
//  /* link) aren't treated as absolute (see below for more of this kind   */
//  /* of consideration). We want the :// to be within about the first 9   */
//  /* characters, more or less...                                         */
//
//  ret = strstr(link, "://");
//
//  if (
//       (ret && ret - link <= 9)     ||
//       !strincmp(link,"MAILTO:",7)  ||
//       !strincmp(link,"NEWS:",  5)  ||
//       !strincmp(link,"X500:",  5)  ||
//       !strincmp(link,"FILE:/", 6)
//     )
//  {
//    ret = strdup(link);
//    return ret;
//  }
//
//  /* Now look for broken URLs of the form 'method:/path/to/file' or           */
//  /* 'method:relative/path'. These are a tad more difficult to deal with      */
//  /* so a separate routine is needed to do this :) This relies on mailto and  */
//  /* x500 being caught above.                                                 */
//  /*                                                                          */
//  /* Also the test for being more than 7 chars in is needed for places like   */
//  /* www.pathfinder.com who have URLs of the form:                            */
//  /*                                                                          */
//  /* /adgw/nph-adgw.cgi?url=http:%2f%2fchess.ibm.park.org&advertiser=...      */
//  /* IBM%20OS2&description=IBM%20Chess%20Button&source=%2fpathfinder%2f...    */
//  /* welcome.html                                                             */
//  /*                                                                          */
//  /* which contain the sequence "http:" (Technically the ':' should be        */
//  /* encoded too I believe!). Anyway since mailto is the longest method, 7    */
//  /* should be okay, I hope!. Alternatively if this is found to be unreliable */
//  /* change the buffer=strchr() bit and the *link=='/' bits around.           */
//
//  buffer = strchr(link, ':');
//
//  if (buffer && (buffer - link < 7))
//  {
//    buffer++;
//
//    uri = strdup(buffer); /* Buffer should now contain URI. Just need new base */
//    if (!uri) return NULL;
//
//    /* Now get the method bit - ughh! */
//
//    buffer = strdup(link);
//
//    if (!buffer) return buffer;
//
//    ret  = strchr(buffer,':'); /* Can't fail because of above */
//    *ret = '\0';
//
//    /* Now need to construct new base bit. */
//    copy=__html_malloc(strlen(base)+strlen(buffer)+1,1);
//    if (!copy) return copy;
//    /* We have up to the : so skip that in base */
//    base=strchr(base,':');
//    if (base==NULL) return NULL;
//    sprintf(copy,"%s%s",buffer,base);
//    base=copy;
//    link=uri;
//  }
//
//  /* The 1st case. The link starts with a '/' so it is an absolute URL
//   * around the same host/method base.
//   */
//  if (*link=='/') {
//    link++;
//    ret=__html_malloc(strlen(base)+strlen(link)+1,sizeof(char));
//    if (ret==NULL) return NULL;
//
//    strcpy(ret,base);
//    copy=ret;
//    copy=strstr(copy,"://");
//    if (copy==NULL) {
//      __html_free(ret, 0);
//      return NULL;
//    }
//    copy++; copy++; copy++;
//    copy=strchr(copy,'/');
//    if (copy==NULL) {
//      __html_free(ret, 0);
//      return NULL;
//    }
//    copy++; *copy='\0';
//    strcat(ret,link);
//    return ret;
//  }
//
//  /* The 2nd case. The link starts with a './' so it is an relative URL
//   * around this page
//   */
//  if ((*link=='.') && (*(link+1)=='/')) {
//    link++; link++;
//
//default_return:
//
//    /*
//     * Basically we need to look back through base to find the last '/'
//     * and append link at that point. So we need a string the length
//     * of base and link, and then blat the two strings into it.
//     *
//     * So grab a copy of base, and strip it back to the required point
//     */
//    ret=copy=strdup(base);
//
//    if (ret==NULL) return ret;
//
//    /* If 'link' is a null string, return the base URL - so for example, */
//    /* http://www.site.com/name.html wouldn't get turned into            */
//    /* http://www.site.com/                                              */
//    /* No, don't do this... We want HREF="./" to work */
//    /*if (!*link) return ret;*/
//
//    ret=strrchr(copy,'/');
//
//    if (ret==NULL) {
//      __html_free(copy, 0);
//      return NULL;
//    }
//    ret++;
//    *ret='\0';
//
//    /* Create a big enough string */
//    ret=__html_malloc(strlen(copy)+strlen(link)+1,sizeof(char));
//    if (ret==NULL) return ret;
//    /* Add the two strings into the return buffer */
//    sprintf(ret,"%s%s",copy,link);
//    return __html_tidy_url(ret);
//  }
//
//  /* 3rd case. The link has a ':' in it. Assume its a link such as a
//   * mailto request. (i.e. host independant URL)
//   */
//
//  if (strchr(link, ':') != NULL) {
//    ret=strdup(link);
//    return ret;
//  }
//
//  /* Otherwise this is sort of the same as case 2 sans the './' */
//  goto default_return;
}
@


1.12
log
@
  Fixed attribute parser bug relating to markup split by CR or LF.

Detail:

  __attribute_strip_spaces removes CR and LF completely, shuffling
  the rest of the string up over the character. This screws up in
  some cases where attribute names, say, get abutted against values.
  Fixed by having two modes to strip spaces, one which leaves CR and
  LF in, and one which strips them; the first part to split the
  string up leaves CR and LF, the second part to read the value
  strips them out.

Admin:

  Tested against various real-life sites and a dedicated test page
  that tripped the previous version of the code up.
@
text
@d724 1
a724 2
    char r, g, b;
    unsigned int c = 0;
d726 66
a791 2
    while (*s==' ' || *s=='"' || *s=='\'')
        s++;
d793 38
a830 1
    if (*s == '#')
d832 7
d840 10
a849 14

  retry_colour:

        while (*s)
        {
            c=c*16+__html_unnumeric_escape(toupper(*s));
            s++;
        }

        r=c>>16;
        g=c>>8;
        b=c;

        return (b<<24) | (g<<16) | (r<<8);
d853 3
a855 1
        const colour_name *entry;
d857 13
a869 7
        if ((entry = bsearch(s, colour_list, SizeOfArray(colour_list), sizeof colour_list[0], compare_colname)) != NULL)
            return entry->colour;
        else
        {
            if (isxdigit(s[0]) && isxdigit(s[1]) && isxdigit(s[2]))
                goto retry_colour; /* May be a colour missing initial '#' */
        }
d871 1
a871 3
        if (invalid_returns_random) return rand() << 8;
        else                        return 1;
    }
@


1.11
log
@Various fixes. Attribute parser would hang when faced with '...VALUE=>'.
Entites which were a substring match of other entities in name (possible
in HTML 4 but not previously) would get mismatched in HTML (the shorter
always being picked and extra letters left over getting spat out to the
page). Solved by having a seperate try-first table of substring matching
entities.

New feature (sort of). Entities in URLs were never escaped as the
existing relaxed entity parser would often mangle CGI-style URLs. There
is now a strict unescaping mode used for URLs which seems to sort out
various sites where this was a problem.

Makefile exports to 'Lib$Dir' rather than 'HTMLLib:' to fit in with
current build environments.
@
text
@d34 2
a35 1
static void  __attribute_munge_spaces(char *s);
d39 10
d70 1
a70 1
    __attribute_munge_spaces(start_ptr);
d73 1
d75 3
a77 3
          (*info != ' ')  &&
          (*info != '\0') &&
          (*info != '>')
d79 1
a79 1
        info++;
d82 2
a83 1
    while (*info == ' ') info++;
d189 1
a189 1
            while (*ptr == ' ') ptr++;
d192 1
a192 1
          if (*ptr==' ') {
d194 1
a194 1
            while (*ptr==' ') ptr++;
d197 1
a197 1
              while (*ptr==' ') ptr++;
d230 1
a230 1
          while (*p == ' ') p++;
d276 2
a441 1

d454 1
a454 1
        while (*p == ' ') p++;
d490 1
a490 1
    __attribute_munge_spaces(start_ptr);
d771 4
d776 1
a776 1
static void  __attribute_munge_spaces(char *s)
d782 6
a787 2
      strcpy(s, s + 1);
      continue;
@


1.10
log
@For URL quick resolving, add one more to the buffer size than should be
required and use this to force in a terminator.

Removed second attempt to strip trailing spaces in incoming URLs (which
has been broken since the URL module started escaping characters anyway).
@
text
@d50 1
a50 1
    char      *p = info, *ptr, *pointer = 0, c;
d86 1
a86 1
    p  = info;
d92 2
a93 1
      /* See __html_tag_length for a similar bit of
d117 1
a117 1
            while (*(++p) <= ' ');
d131 1
a131 1
            while (*(++p) <= ' ');
d158 6
d192 3
a194 2
     * Next look to see if we can find the suposed anchor element
     * in the list provided
d196 1
a198 2
    //    Printf ("anchor element '%s', data '%s'\n", info, ptr, info, max_anc, anc);

d213 7
a219 5
        if (!found_attr) {
            if (c=='\0') break;
            *p=c; p++;
            info=p;
            continue;
d226 1
d237 12
a248 1
        if (pointer != NULL) *pointer='\0';
d250 2
a251 1
        /* We are going to slot this attribute value into our array.
d254 1
d267 1
a267 1
                __html_unescape_string(ptr);
d283 1
a283 1
                __html_unescape_string(ptr);
d376 1
a376 1
                __html_unescape_string(ptr);
d382 1
a382 1
                __html_unescape_string(ptr);
d409 3
a411 1
                 * in anchors, which we do not want to unescape.
d414 1
a414 1
                /*  __html_unescape_string(ptr);*/
d429 5
a433 2
        if (pointer != NULL) *pointer='"';
    /* Skip this bit (or if it was the last one exit */
a434 1
          *p=c; /*p++;*/
d436 5
a440 3
    /* Skip over spaces */
        while (*p == ' ')
            p++;
d538 1
a538 1
            while (*(++p) <= ' ');
d552 1
a552 1
            while (*(++p) <= ' ');
d793 1
d795 4
a798 4
        (*p != ' ')  &&
        (*p != '\0') &&
        (*p != '>') &&
        (*p != '<')
d800 1
a800 1
      p++;
d848 1
a848 1
          while (*(++p) <= ' ');
d876 1
a876 1
          while (*(++p) <= ' ');
@


1.9
log
@Cleaned up a bit - any remaining build-time warnings are intentional
reminders that something needs attention. Adjusted CC flags as part
of this.

Corrected misleading comments on a couple of functions (a case of
Cut And Paste by the looks of things).

Rewrote element attribute parsing. As far as I can tell this now
behaves just as in Navigator 4.07 - fixed a large number of
reported bugs as a result. On the whole these are usually down to
spurious trailing closing quotes with no matching opening quote,
though there are some rather more exotic cases that now work
as intended.

Now remove CR and LF from attribute values rather than replacing
them with spaces - yet more sites fixed - and strip trailing spaces
from URLs (Ofsted's PDFs are now much easier to download...).
@
text
@d398 1
a398 13
                curattr->data.text = __html_relativise_url(url, ptr);

                /*
                 * Strip trailing spaces (important for named anchors)
                 */

                if (curattr->data.text)
                {
                  p = curattr->data.text + strlen(curattr->data.text) - 1;
                  while (*p == ' ') p--;
                  *(++p) = '\0';
                }

@


1.8
log
@Tolerates multiple closing quotes on attribute values (seen at
http://news.bbc.co.uk/). Only one opening quote allowed though,
and missing a closing quote will still result in chunks of the
document disappearing.
@
text
@d51 1
a51 1
    int        has_quotes, has_equals, in_second_part, had_space;
d92 8
a99 1
        /* Note that we havent seen a quote mark yet! */
d101 3
a103 8
        has_quotes     = 0;
        has_equals     = 0;
        in_second_part = 0;
        had_space      = 0;

        /* isolate the next bit of the tag */

        while (*p != '\0')
d105 1
a105 1
          if (*p=='"' || *p=='\'')
d107 10
a116 9
            if (has_quotes)
            {
              if ((*p == '"' && has_quotes == 1) || (*p == '\'' && has_quotes == 2))
              {
                while (*p == '"' || *p == '\'') p++;
                break;
              }
            }
            else has_quotes = ((*p == '"') ? 1 : 2);
d118 7
a124 2
          else if (*p=='=') has_equals = 1;
          else if (isspace(*p))
d126 3
a128 1
            if (in_second_part && !has_quotes) break;
d130 1
a130 1
            had_space = 1;
d132 5
a136 1
          else
d138 1
a138 1
            if (has_equals) in_second_part = 1;
d140 2
a141 1
            else if (had_space)
d143 1
a143 3
              /* Hit the next element after an atomic one - back up */

              p--;
d147 5
d153 1
d155 1
d157 2
a158 2
        c  = *p;
        *p = '\0';
d391 8
a398 1
                curattr->data.text  = __html_relativise_url(url, ptr);
d452 1
a452 1
    int        has_quotes, has_equals, in_second_part, had_space;
d497 8
a504 1
        /* Note that we havent seen a quote mark yet! */
d506 3
a508 8
        has_quotes     = 0;
        has_equals     = 0;
        in_second_part = 0;
        had_space      = 0;

        /* isolate the next bit of the tag */

        while (*p != '\0')
d510 1
a510 1
          if (*p=='"' || *p=='\'')
d512 10
a521 9
            if (has_quotes)
            {
              if ((*p == '"' && has_quotes == 1) || (*p == '\'' && has_quotes == 2))
              {
                p++;
                break;
              }
            }
            else has_quotes = ((*p == '"') ? 1 : 2);
d523 7
a529 2
          else if (*p=='=') has_equals = 1;
          else if (isspace(*p))
d531 3
a533 1
            if (in_second_part && !has_quotes) break;
d535 1
a535 1
            had_space = 1;
d537 5
a541 1
          else
d543 1
a543 1
            if (has_equals) in_second_part = 1;
d545 2
a546 1
            else if (had_space)
d548 1
a548 3
              /* Hit the next element after an atomic one - back up */

              p--;
d552 5
d558 1
d560 1
d562 2
a563 2
        c  = *p;
        *p = '\0';
d590 1
d632 1
a632 1
        param = __html_construct_param(st, name, NULL, has_equals ? strdup(ptr) : NULL, paramtype_DATA);
d643 1
a643 1
    /* Skip this bit (or if it was the last one exit */
d737 3
a739 2
/* Given a string convert all control chars into spaces (e.g. newlines   */
/* tabs and linefeeds). This makes parsing the string easier :)		 */
d743 9
a751 2
  while (*s != '\0') {
    if ((*s < 32) && (*s > 0)) *s=32;
d769 1
a769 1
  int has_quotes, has_equals, in_second_part, had_space;
d789 2
a790 1
  while (*p != '\0' && *p != '>' && *p != '<')
d792 4
a795 1
    has_quotes = has_equals = in_second_part = had_space = 0;
d801 1
a801 1
    while (!(has_quotes == 0 && (*p == '>' || *p == '<')) && (*p != '\0'))
d803 1
a803 1
      if (*p == '\'' && has_equals)
d805 7
a811 3
        in_second_part = 1;
        if (has_quotes == 0) has_quotes = '\'';
        else if (has_quotes == '\'')
d813 10
a822 2
          while (*(p + 1) == '\'') p++; /* Deal with double closing quotes - a fairly common error! */
          has_quotes = 0;
d824 1
a824 6
      }
      else if (*p == '"' && has_equals)
      {
        in_second_part = 1;
        if (has_quotes == 0) has_quotes = '"';
        else if (has_quotes == '"')
d826 5
a830 2
          while (*(p + 1) == '"') p++;
          has_quotes = 0;
d832 1
d834 1
a834 3
      else if (*p == '=')
        has_equals = 1;
      else if (*p <= ' ')
d836 17
a852 1
        if (in_second_part && !has_quotes)
d854 5
a858 1
          break;
d860 1
a860 1
        had_space = 1;
d864 3
a866 2
        if (has_equals) in_second_part = 1;
        else if (had_space)
d868 21
a888 2
            /* hit the next attribute name after an abbreviated attribute */
            p--;
d890 9
d900 3
a903 1
      p++;
a906 2
    while (*p <= ' ' && *p != '\0')
         p++;
d908 1
@


1.7
log
@Added externally visible function HtmlParseColour, which maps to
__html_convcol internally. Extended API to the latter so that it
either does the "return random colour if I don't understand the
string" trick, or returns a value telling the caller it didn't
know what was going on. Needed all of this for JavaScript support
in Browse.
@
text
@d109 1
a109 1
                p++;
d746 6
a751 1
        if (has_quotes == 0) has_quotes = '\''; else if (has_quotes == '\'') has_quotes = 0;
d756 6
a761 1
        if (has_quotes == 0) has_quotes = '"'; else if (has_quotes == '"') has_quotes = 0;
@


1.6
log
@Images (from IMG elements only at present) have an info field in their
internal structure, with 'hspace' and 'vspace' filled in - so you can
now use HtmlOBJECTvspace / HtmlOBJECThspace to get at this information
for both IMG and OBJECT elements (as with macros OBJECT_HAS_WIDTH etc.)
@
text
@a35 1
static unsigned int __html_convcol(const char *s);
d334 1
a334 1
                curattr->data.number = __html_convcol(ptr);
d638 6
a643 1
static unsigned int __html_convcol(const char *s)
d681 2
a682 1
        return rand() << 8;        /* Whyever not? */
@


1.5
log
@Fixed slight cockup - trailing > of tag would sometimes be added to an
attribute value.
@
text
@d247 2
a248 1
                curattr->data.number = atoi(ptr);
@


1.4
log
@Added some tolerance of mismatched quotes in tags
@
text
@d84 1
a84 1
            info[len-1] = '>';
@


1.3
log
@Can now cope with < or > characters in quoted attributes
@
text
@a79 6
    /* Grab just the bit inside the tag: convert \n, \t and \r to ' ' */

    p = info;
    has_quotes = 0;

    while (!(has_quotes==0 && (*p == '>' || *p == '<')) && *p != '\0')
d81 4
a84 9
      if (*p == '\'')
      {
        if (has_quotes == 0) has_quotes = '\''; else if (has_quotes == '\'') has_quotes = 0;
      }
      else if (*p == '"')
      {
        if (has_quotes == 0) has_quotes = '"'; else if (has_quotes == '"') has_quotes = 0;
      }
      p++;
a86 3
    /* Snip off the '>' at the end now, then move back to the begining */

    *p = '\0';
d694 10
d707 1
a707 1
  int has_quotes = 0;
d709 19
a727 1
  while (!(has_quotes == 0 && (*p == '>' || *p == '<')) && (*p != '\0'))
d729 7
a735 1
    if (*p == '\'')
d737 31
a767 1
      if (has_quotes == 0) has_quotes = '\''; else if (has_quotes == '\'') has_quotes = 0;
d769 5
a773 5
    else if (*p == '"')
    {
      if (has_quotes == 0) has_quotes = '"'; else if (has_quotes == '"') has_quotes = 0;
    }
    p++; /* skip to the end of the tag name */
d775 2
@


1.2
log
@Web branch merged
@
text
@a33 1
static int __html_tag_length(char *s1);
d83 1
d85 1
a85 1
    while ((*p != '>') && (*p != '<') && (*p != '\0'))
d87 8
d708 1
a708 1
static int __html_tag_length (char *s1)
d710 2
a711 1
  char *p=s1 + 1;
d713 12
a724 3
  while ((*p != '>') && (*p != '<') && (*p != '\0')) {
        p++; /* skip to the end of the tag name */
	}
@


1.1
log
@file attributes was initially added on branch Web.
@
text
@d1 927
@


1.1.2.1
log
@Totally redesigned attribute parsing code.
Started new API for accessing attributes - only implemented for BODY.
Added <BODY alink onload onunload> support.
@
text
@a0 624
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -*-C-*-
 *
 */

#include "stdio.h"        /* For NULL etc */
#include "stdlib.h"       /* For bsearch */
#include "limits.h"       /* For INT_MAX */
#include "html2_ext.h"  /* For the HTML bits */
#include "tags.h"         /* for PCDATA */
#include "struct.h"        /* For the structures */
#include "string.h"        /* For string handling */
#include "internal.h"         /* predefinitions of functions */
#include "rules.h"
#include "unixlib.h"
#ifdef TonyTables
#include "HTMLTables.h"
#endif

static int __html_tag_length(char *s1);
static void  __attribute_munge_spaces(char *s);
static int compare_attribute(const void *keyp, const void *membp);
static unsigned int __html_convcol(const char *s);
static char * __html_relativise_url(char * base, char * link);

/*
 * This routine parses the attributes found in a start tag, and fills in
 * st->curattrs with the found values. Filling in of default values is not done
 * here.
 */
void __html_process_attributes(StreamTokens *st, Tag *tag, char *html, char *url)
{
    const Attribute *attrs = tag->attributes;
    Attribute       *found_attr;
    AttrInfo        *curattr;

    char      *info  = strndup(html, __html_tag_length(html));
    char      *start_ptr = info;
    char      *p = info, *ptr, *pointer = 0, c;
    int        has_quotes, has_equals, in_second_part, had_space;

    int        max_attrs = tag->max_attributes;

    /* Reset the attribute table */
    __html_reset_curattrlist(st);

    /* Make parsing a little easier */
    __attribute_munge_spaces(start_ptr);

    /* Skip the main part of the tag (e.g. '<a' for anchors) */
    while (
          (*info != ' ')  &&
          (*info != '\0') &&
          (*info != '>')
          )
        info++;

    /* Skip the next set of spaces */
    while (*info == ' ') info++;

    /* We have hit the end of the tag? */
    if ((*info == '\0') || (*info== '>'))
    {
        __html_free(start_ptr,0);
        return;
    }

    /* Grab just the bit inside the tag: convert \n, \t and \r to ' ' */

    p = info;

    while ((*p != '>') && (*p != '<'))
    {
      if (*p=='\0')
      {
        __html_free(start_ptr,0);
        return; /* error case really */
      }

      p++;
    }

    /* Snip off the '>' at the end now, then move back to the begining */

    *p = '\0';
    p  = info;

    /* We are just working inside the tag now: */

    while (*info != '\0')
    {
        /* Note that we havent seen a quote mark yet! */

        has_quotes     = 0;
        has_equals     = 0;
        in_second_part = 0;
        had_space      = 0;

        /* isolate the next bit of the tag */

        while (*p != '\0')
        {
          if (*p=='"' || *p=='\'')
          {
            if (has_quotes)
            {
              if ((*p == '"' && has_quotes == 1) || (*p == '\'' && has_quotes == 2))
              {
                p++;
                break;
              }
            }
            else has_quotes = ((*p == '"') ? 1 : 2);
          }
          else if (*p=='=') has_equals = 1;
          else if (isspace(*p))
          {
            if (in_second_part && !has_quotes) break;

            had_space = 1;
          }
          else
          {
            if (has_equals) in_second_part = 1;

            else if (had_space)
            {
              /* Hit the next element after an atomic one - back up */

              p--;
              break;
            }
          }
          p++;
        }

        c  = *p;
        *p = '\0';

    /*
     * Look to see what we have. First off scan through to see if we have
     * an '=' sign. If we do, store for later use!
     */
        ptr=info;
        while (*ptr != '\0') {
          if (*ptr=='=') {
            *ptr='\0';
            ptr++;
            while (*ptr == ' ') ptr++;
            break;
          }
          if (*ptr==' ') {
            *ptr='\0'; ptr++;
            while (*ptr==' ') ptr++;
            if (*ptr=='=') {
              ptr++;
              while (*ptr==' ') ptr++;
            }
            break;
          }
          ptr++;
        }

    /*
     * Next look to see if we can find the suposed anchor element
     * in the list provided
     */
        UPPER_CASE(info);

    //    Printf ("anchor element '%s', data '%s'\n", info, ptr, info, max_anc, anc);

        found_attr = bsearch(info, attrs, max_attrs, sizeof attrs[0], compare_attribute);

        if (!found_attr && tag->has_coreattrs)
            found_attr = bsearch(info, Core_Attributes, MAX_CORE_ATTRIBUTES, sizeof Core_Attributes[0], compare_attribute);

        if (!found_attr && tag->has_i18n)
            found_attr = bsearch(info, I18n_Attributes, MAX_I18N_ATTRIBUTES, sizeof I18n_Attributes[0], compare_attribute);

        if (!found_attr && tag->has_events)
            found_attr = bsearch(info, Event_Attributes, MAX_EVENT_ATTRIBUTES, sizeof Event_Attributes[0], compare_attribute);

        /*
         * If we have not found anything that is allowed, skip it
         */
        if (!found_attr) {
            if (c=='\0') break;
            *p=c; p++;
            info=p;
            continue;
        }

        /*
         * If the value inside ptr is enclosed in quotes, we need to
         * strip them off!
         */
        if (*ptr=='"')
        {
            ptr++;
            pointer=strpbrk(ptr,"\"");
        }
        else if (*ptr=='\'')
        {
            ptr++;
            pointer=strpbrk(ptr,"\'");
        }
        if (pointer != NULL) *pointer='\0';

        /* We are going to slot this attribute value into our array.
         * Remove any prior value first...
         */
        curattr = &st->curattrs[found_attr->tag];
        if (curattr->pleasefree)
        {
            __html_free(curattr->data.raw, 0);
            curattr->pleasefree=0;
        }
        curattr->present = 1;

        switch (found_attr->rule)
        {
            /* A piece of text (character entities allowed). */
            case CDATA:
                __html_unescape_string(ptr);
                curattr->data.text = strdup(ptr);
                curattr->pleasefree = 1;
                break;

            /* A SGML name */
            case NAME_RULE:
                curattr->data.text = strdup(ptr);
                curattr->pleasefree = 1;
                break;

            /* Either there or not */
            case EMPTY:
                break;

            case LENGTH_RULE:
                __html_unescape_string(ptr);
                curattr->miscflag = strchr(ptr, '%') ? 1 : 0;
                /* Fall through */

            /* Goody! An integer! */
            case NUMBER:
                curattr->data.number = atoi(ptr);
                break;

            /* Erk - a choice... */
            case SET:
            {
                const char *s = found_attr->set;
                const char *p;
                int n;
                LOWER_CASE(ptr);

                for (n = 1; *s;)
                {
                    p = ptr;
                    while (*s && *s != '|' && *s != ',')
                    {
                        if (*s++ != *p++)
                            goto next;
                    }
                    if (*p == '\0')
                    {
                        curattr->data.number = n;
                        break;
                    }

                  next:
                    while (*s && *s != '|' && *s != ',')
                        s++;

                    if (*s == '|')
                        s++, n++;
                    else if (*s == ',')
                        s++;

                }
                break;
            }

            /* A colour (duh!) */
            case COLOUR_RULE:
                __html_unescape_string(ptr);
                curattr->data.number = __html_convcol(ptr);
                break;

            /* A URL - lets relativise */
            case URL_RULE:
                __html_unescape_string(ptr);
                curattr->data.text = __html_relativise_url(url, ptr);
                curattr->pleasefree = 1;
                break;

        }
        if (pointer != NULL) *pointer='"';
    /* Skip this bit (or if it was the last one exit */
        if (c=='\0') break;
          *p=c; /*p++;*/

    /* Skip over spaces */
        while (*p == ' ')
            p++;

        info=p;
    }

    __html_free(start_ptr,0);
}

static int compare_attribute(const void *keyp, const void *membp)
{
    const char       *key = (const char *)      keyp;
    const Attribute *memb = (const Attribute *) membp;

    return strcmp(key, memb->name);
}


typedef struct colour_name { char *name; unsigned int colour; } colour_name;

#include "colourlist.h"

static int compare_colname(const void *keyp, const void *membp)
{
    const char        * key  = (const char        *) keyp;
    const colour_name * memb = (const colour_name *) membp;
    const char *a = key;
    const char *b = memb->name;

    for (;;)
    {   char c1 = *a++, c2 = *b++;
        int d = toupper(c1) - toupper(c2);
        if (isspace(c1))
        {
            b--;
            continue;
        }
        if (isspace(c2))
        {
            a--;
            continue;
        }
        if (d != 0) return d;
        if (c1 == 0) return 0;     /* no need to check c2 */
    }
}

static unsigned int __html_convcol(const char *s)
{
    char r, g, b;
    unsigned int c = 0;

    while (*s==' ' || *s=='"' || *s=='\'')
        s++;

    if (*s == '#')
    {
        s++;

  retry_colour:

        while (*s)
        {
            c=c*16+__html_unnumeric_escape(toupper(*s));
            s++;
        }

        r=c>>16;
        g=c>>8;
        b=c;

        return (b<<24) | (g<<16) | (r<<8);
    }
    else
    {
        const colour_name *entry;

        if ((entry = bsearch(s, colour_list, SizeOfArray(colour_list), sizeof colour_list[0], compare_colname)) != NULL)
            return entry->colour;
        else
        {
            if (isxdigit(s[0]) && isxdigit(s[1]) && isxdigit(s[2]))
                goto retry_colour; /* May be a colour missing initial '#' */
        }

        return rand() << 8;        /* Whyever not? */
    }
}

/*************************************************************************/
/* static void __anchor_munge_spaces(char *s)                            */
/*************************************************************************/
/* Given a string convert all control chars into spaces (e.g. newlines   */
/* tabs and linefeeds). This makes parsing the string easier :)		 */
/*************************************************************************/
static void  __attribute_munge_spaces(char *s)
{
  while (*s != '\0') {
    if ((*s < 32) && (*s > 0)) *s=32;
    s++;
  }
}

static int __html_tag_length (char *s1)
{
  char *p=s1;

  while ((*p != '>') && (*p != '\0')) {
        p++; /* skip to the end of the tag name */
	}

  if (*p=='>') p++;

  return (int)(p-s1);
}

void __html_reset_curattrlist(StreamTokens *st)
{
    int i;

    for (i=0; i<MAX_ATTRS; i++)
        if (st->curattrs[i].pleasefree)
            __html_free(st->curattrs[i].data.raw, 0);

    memset(st->curattrs, 0, sizeof st->curattrs);
}

/********************************************************************/
/* static char *__html_relativise_url(char *base, char *link)       */
/********************************************************************/
/* Given a base URL and another URL (e.g. a link or an image), this */
/* routine constructs the resultant URL from the pair               */
/********************************************************************/

static char * __html_relativise_url(char * base, char * link)
{
  char        * ret = NULL;
  char        * copy;
  char        * buffer;
  char        * uri;
  extern char * __html_tidy_url(char * url);

  if (link == NULL) return NULL;

  if (base == NULL) // || (strstr(base,"ADFS:") != NULL)
  {
    ret = strdup(link);
    return ret;
  }

  if (link[0] == '#')
  {
    /* It's a within document link */

    ret = __html_malloc(strlen(link) + strlen(base) + 1, 1);
    if (ret) sprintf(ret,"%s%s",base,link);

    return ret;
  }

  /* Should have a Fetcher_Relativise call                               */
  /*                                                                     */
  /* Simple test for a fully qualified URL. Look for '://' in the string */
  /* Also catch "mailto:" and "x500:" URLs at this point. We expect the  */
  /* method to be at the start of the string. (This is to allow for      */
  /* funny proxies :)                                                    */
  /*                                                                     */
  /* The test on ret - link <= 9 ensures URLs that are indeed relative,  */
  /* but contain URLs themselves (e.g. as part of some CGI info in the   */
  /* link) aren't treated as absolute (see below for more of this kind   */
  /* of consideration). We want the :// to be within about the first 9   */
  /* characters, more or less...                                         */

  ret = strstr(link, "://");

  if (
       (ret && ret - link <= 9)     ||
       !strincmp(link,"MAILTO:",7)  ||
       !strincmp(link,"NEWS:",  5)  ||
       !strincmp(link,"X500:",  5)
     )
  {

    ret = strdup(link);
    return ret;
  }

  /* Now look for broken URLs of the form 'method:/path/to/file' or           */
  /* 'method:relative/path'. These are a tad more difficult to deal with      */
  /* so a separate routine is needed to do this :) This relies on mailto and  */
  /* x500 being caught above.                                                 */
  /*                                                                          */
  /* Also the test for being more than 7 chars in is needed for places like   */
  /* www.pathfinder.com who have URLs of the form:                            */
  /*                                                                          */
  /* /adgw/nph-adgw.cgi?url=http:%2f%2fchess.ibm.park.org&advertiser=...      */
  /* IBM%20OS2&description=IBM%20Chess%20Button&source=%2fpathfinder%2f...    */
  /* welcome.html                                                             */
  /*                                                                          */
  /* which contain the sequence "http:" (Technically the ':' should be        */
  /* encoded too I believe!). Anyway since mailto is the longest method, 7    */
  /* should be okay, I hope!. Alternatively if this is found to be unreliable */
  /* change the buffer=strchr() bit and the *link=='/' bits around.           */

  buffer = strchr(link, ':');

  if (buffer && (buffer - link < 7))
  {
    buffer++;

    uri = strdup(buffer); /* Buffer should now contain URI. Just need new base */
    if (!uri) return NULL;

    /* Now get the method bit - ughh! */

    buffer = strdup(link);

    if (!buffer) return buffer;

    ret  = strchr(buffer,':'); /* Can't fail because of above */
    *ret = '\0';

    /* Now need to construct new base bit. */
    copy=__html_malloc(strlen(base)+strlen(buffer)+1,1);
    if (!copy) return copy;
    /* We have up to the : so skip that in base */
    base=strchr(base,':');
    if (base==NULL) return base;
    sprintf(copy,"%s%s",buffer,base);
    base=copy;
    link=uri;
  }

/* The 1st case. The link starts with a '/' so it is an absolute URL
 * around the same host/method base.
 */
  if (*link=='/') {
    link++;
    ret=__html_malloc(strlen(base)+strlen(link)+1,sizeof(char));
    if (ret==NULL) return NULL;

    strcpy(ret,base);
    copy=ret;
    copy=strstr(copy,"://");
    if (copy==NULL) {
      __html_free(ret, 0);
      return NULL;
    }
    copy++; copy++; copy++;
    copy=strchr(copy,'/');
    if (copy==NULL) {
      __html_free(ret, 0);
      return NULL;
    }
    copy++; *copy='\0';
    strcat(ret,link);
    return ret;
  }

/* The 2nd case. The link starts with a './' so it is an relative URL
 * around this page
 */
  if ((*link=='.') && (*(link+1)=='/')) {
    link++; link++;

default_return:

/*
 * Basically we need to look back through base to find the last '/'
 * and append link at that point. So we need a string the length
 * of base and link, and then blat the two strings into it.
 *
 * So grab a copy of base, and strip it back to the required point
 */
    ret=copy=strdup(base);

    if (ret==NULL) return ret;

    ret=strrchr(copy,'/');

    if (ret==NULL) {
      __html_free(copy, 0);
      return NULL;
    }
    ret++;
    *ret='\0';

/* Create a big enough string */
    ret=__html_malloc(strlen(copy)+strlen(link)+1,sizeof(char));
    if (ret==NULL) return ret;
/* Add the two strings into the return buffer */
    sprintf(ret,"%s%s",copy,link);
    return __html_tidy_url(ret);
  }

/* 3rd case. The link has a ':' in it. Assume its a link such as a
 * mailto request. (i.e. host independant URL)
 */

 if (strchr(link, ':') != NULL) {
   ret=strdup(link);
   return ret;
 }

/* Otherwise this is sort of the same as case 2 sans the './' */
 goto default_return;
}

@


1.1.2.2
log
@Added new external call HtmlRelativiseURL, and added support for hex entities.
@
text
@d37 1
d451 1
a451 1
char * __html_relativise_url(const char * base, const char * link)
d544 1
a544 1
    if (base==NULL) return NULL;
@


1.1.2.3
log
@Made __html_relativise_url return the full base URL if the link URL was a
null string, rather than effectively stripping the leaf off the base.
@
text
@d498 1
a592 6

    /* If 'link' is a null string, return the base URL - so for example, */
    /* http://www.site.com/name.html wouldn't get turned into            */
    /* http://www.site.com/                                              */

    if (!*link) return ret;
@


1.1.2.4
log
@Don't unescape HREF attribute contents
@
text
@d304 1
a304 7
                /*
                 * HREF tags *should* be able to have entities in them, so we should
                 * unescape the string. However, many sites put CGI-style form info
                 * in anchors, which we do not want to unescape.
                 */

                /*  __html_unescape_string(ptr);*/
@


1.1.2.5
log
@Fixed a data abort in __html_find_content_type (would happily run off
the end of the header).
@
text
@a303 3
            {
                char *p;

d311 1
a311 11

                curattr->data.text  = __html_relativise_url(url, ptr);

                /*
                 * Strip trailing spaces (important for named anchors)
                 */

                p = curattr->data.text + strlen(curattr->data.text) - 1;
                while (*p == ' ') p--;
                *(++p) = '\0';

d313 1
a313 2
            }
            break;
a470 4

  /* Strip preceeding spaces */

  while (*link == ' ') link++;
@


1.1.2.6
log
@Bras Direct now works. Woohoo. Doesn't die when loading extremely large
chunks - malloc failures due to a locked flex heap caused problems.
HttpEndParse call added to free up parse related blocks. To solve layout
problems on certain sizes, spacer images (align left or right) which are
less than 2 pixels wide, or are more than 15 times tall than wide, will
be ignored.
@
text
@d84 1
a84 1
    while ((*p != '>') && (*p != '<') && (*p != '\0'))
d86 6
d321 3
a323 6
                if (curattr->data.text)
                {
                  p = curattr->data.text + strlen(curattr->data.text) - 1;
                  while (*p == ' ') p--;
                  *(++p) = '\0';
                }
d441 1
a441 1
  char *p=s1 + 1;
d443 1
a443 1
  while ((*p != '>') && (*p != '<') && (*p != '\0')) {
@


1.1.2.7
log
@Turned off CUSTOMER_SPECIAL.
Changed encoding tables to use FFFF as a null value instead of FFFD.
Added OBJECT support (more testing required - PARAM not yet done).
Added AREA support (commented out - MAP not yet done). They come out
looking like <A></A> elements.
Souped up mapping to Latin-1 (added lossy tables for Latin Extended
Additional, CJK Punctuation and Fullwidth forms).
Added support for <H1 align=...>
Stripped some superfluous whitespace caused by linefeeds.
Fixed missing linebreak in "<DT>One<DT>Two" by turning the second DT into
a BR.
Removed now unnecessary free(malloc(16384)) bodge.
Put in CJK code even if UNIFONT not defined (hey - why not?).
Added code to take direct pointer to table rather than loading it if
it's in ResourceFS.
Added support for encoding "x-acorn-latin1".
Ensured correct handling of OPTIONs when UNIFONT not defined.
@
text
@a289 32
            /* A coordinate list (a comma separated list of integers) */
            case COORDS_RULE:
            {
                const char *p, *next, *percent;
                int n;

                /* Count the commas */
                for (n = 0, p = ptr-1; p; n++)
                    p = strchr(p+1, ',');

                curattr->data.coords = (int *) __html_malloc(sizeof(int), 2 + n);
                if (!curattr->data.coords)
                    break;

                /* Item 0 left free to put shape in later */

                /* Item 1 = number of coords, items 2 + = coords */
                curattr->data.coords[1] = n;

                for (n = 2, p = ptr-1; p; p = next, n++)
                {
                    curattr->data.coords[n] = atoi(p+1);
                    if (curattr->data.coords[n] < 0) curattr->data.coords[n] = 0;
                    next = strchr(p+1, ',');
                    percent = strchr(p+1, '%');
                    if (percent && percent < next)
                        curattr->data.coords[n] = -curattr->data.coords[n];
                }

                break;
            }

@


1.1.2.8
log
@Implemented ordered lists.
Implemented <Q> ... </Q>.
Caused a linebreak after </DD>.
Finished implementing attributes for <OBJECT>.
Stopped HTML after a </FRAMESET> leaking through.
Ensured that FRAME and FRAMESET tokens aren't passed up if not using frames.

Removed lots of unnecessary #include "utf8.h" lines from encoding files.
Ensured unsigned constants used in UTF-8 code.
Added UTF8_next and UTF8_prev functions.
@
text
@a327 21
            /* The style of a OL */
            case OLSTYLE_RULE:
                __html_unescape_string(ptr);
                if (tag->tag_no == TAG_OL)
                {
                    if (strchr("1aAiI", ptr[0]))
                        curattr->data.number = ptr[0];
                }
                else
                {
                    if (strchr("1aAiIdcsDCS", ptr[0]))
                    {
                        curattr->data.number = ptr[0];
                        if (curattr->data.number == 'D' ||
                            curattr->data.number == 'C' ||
                            curattr->data.number == 'S')
                            curattr->data.number += 32;
                    }
                }
                break;

@


1.1.2.9
log
@Fixed problem with file:/ URLs
@
text
@d569 1
a569 2
       !strincmp(link,"X500:",  5)  ||
       !strincmp(link,"FILE:/", 6)
@


1.1.2.10
log
@Fixed links to "./".
Ensured incomplete OBJECTs not returned (I hope).
Stopped newlines being stripped inside PRE.
Made </P> turn off any paragraph alignment.
Added HtmlReplaceOBJECT call.
@
text
@d671 2
a672 2
    /* No, don't do this... We want HREF="./" to work */
    /*if (!*link) return ret;*/
@


1.1.2.11
log
@Special case for null link URLs in __html_relativise_url
@
text
@a539 6
  /* Cope with empty link URLs */

  if (link[0] == '\0') return strdup(base);

  /* Check for an in-document link */

d542 2
@


1.1.2.12
log
@Added EMBED support (creating lookalike OBJECTs).
Removed startup table initialisation, because latest compiler can do it.
@
text
@a28 1
#include "elementinf.h"
a402 196

/*
 * This routine parses the attributes found in an EMBED tag, and attaches
 * them as a list of PARAMs to obj.
 */
void __html_process_embed_attributes(StreamTokens *st, Tag *tag, char *html, HStream *obj)
{
    const Attribute *attrs = tag->attributes;
    Attribute       *found_attr;

    char      *info  = strndup(html, __html_tag_length(html));
    char      *start_ptr = info;
    char      *p = info, *ptr, *pointer = 0, c;
    int        has_quotes, has_equals, in_second_part, had_space;
    HStream   *param, *h = NULL, **hprev = &obj->info->object.hstream;
    char      *name;

    int        max_attrs = tag->max_attributes;

    /* Make parsing a little easier */
    __attribute_munge_spaces(start_ptr);

    /* Skip the main part of the tag (e.g. '<a' for anchors) */
    while (
          (*info != ' ')  &&
          (*info != '\0') &&
          (*info != '>')
          )
        info++;

    /* Skip the next set of spaces */
    while (*info == ' ') info++;

    /* We have hit the end of the tag? */
    if ((*info == '\0') || (*info== '>'))
    {
        __html_free(start_ptr,0);
        return;
    }

    /* Grab just the bit inside the tag: convert \n, \t and \r to ' ' */

    p = info;

    while ((*p != '>') && (*p != '<') && (*p != '\0'))
    {
      p++;
    }

    /* Snip off the '>' at the end now, then move back to the begining */

    *p = '\0';
    p  = info;

    /* We are just working inside the tag now: */

    while (*info != '\0')
    {
        /* Note that we havent seen a quote mark yet! */

        has_quotes     = 0;
        has_equals     = 0;
        in_second_part = 0;
        had_space      = 0;

        /* isolate the next bit of the tag */

        while (*p != '\0')
        {
          if (*p=='"' || *p=='\'')
          {
            if (has_quotes)
            {
              if ((*p == '"' && has_quotes == 1) || (*p == '\'' && has_quotes == 2))
              {
                p++;
                break;
              }
            }
            else has_quotes = ((*p == '"') ? 1 : 2);
          }
          else if (*p=='=') has_equals = 1;
          else if (isspace(*p))
          {
            if (in_second_part && !has_quotes) break;

            had_space = 1;
          }
          else
          {
            if (has_equals) in_second_part = 1;

            else if (had_space)
            {
              /* Hit the next element after an atomic one - back up */

              p--;
              break;
            }
          }
          p++;
        }

        c  = *p;
        *p = '\0';

    /*
     * Look to see what we have. First off scan through to see if we have
     * an '=' sign. If we do, store for later use!
     */
        ptr=info;
        while (*ptr != '\0') {
          if (*ptr=='=') {
            *ptr='\0';
            ptr++;
            while (*ptr == ' ') ptr++;
            break;
          }
          if (*ptr==' ') {
            *ptr='\0'; ptr++;
            while (*ptr==' ') ptr++;
            if (*ptr=='=') {
              ptr++;
              while (*ptr==' ') ptr++;
            }
            break;
          }
          ptr++;
        }
        name = strdup(info);
        if (!name) break;
    /*
     * Next look to see if we can find the suposed anchor element
     * in the list provided
     */
        UPPER_CASE(info);

    //    Printf ("anchor element '%s', data '%s'\n", info, ptr, info, max_anc, anc);

        found_attr = bsearch(info, attrs, max_attrs, sizeof attrs[0], compare_attribute);

        /*
         * If _have_ found something that is allowed, skip it! We only want
         * unknown attributes here...
         */
        if (found_attr) {
            __html_free(name, 0);
            if (c=='\0') break;
            *p=c; p++;
            info=p;
            continue;
        }

        /*
         * If the value inside ptr is enclosed in quotes, we need to
         * strip them off!
         */
        if (*ptr=='"')
        {
            ptr++;
            pointer=strpbrk(ptr,"\"");
        }
        else if (*ptr=='\'')
        {
            ptr++;
            pointer=strpbrk(ptr,"\'");
        }
        if (pointer != NULL) *pointer='\0';

        /*
         * Allocate a PARAM.
         */
        param = __html_construct_param(st, name, NULL, has_equals ? strdup(ptr) : NULL, paramtype_DATA);
        if (param)
        {
            *hprev = param;
            param->prev = h;
            hprev = &param->next;
            h = param;
        }

        if (pointer != NULL) *pointer='"';

    /* Skip this bit (or if it was the last one exit */
        if (c=='\0') break;
          *p=c; /*p++;*/

    /* Skip over spaces */
        while (*p == ' ')
            p++;

        info=p;
    }

    __html_free(start_ptr,0);
}
@


1.1.2.13
log
@Extra field 'ncells' added to table_stream structure
@
text
@d291 1
a291 1
            /* A coordinate list (a list of integers) */
d297 3
a299 11
                /*
                 * Count the seperators. Start the count at two because
                 * the first two items are used for the type of item and
                 * number of coordinates.
                 */
                for (n = 2, p = ptr; *p; p = next, n++)
                {
                    next = p + strcspn(p, "0123456789%");
                    if (!strchr("0123456789%", *next)) break;
                    next += strspn(next, "0123456789%");
                }
d301 1
a301 1
                curattr->data.coords = (int *) __html_malloc(sizeof(int), n);
d305 4
a308 5
                /*
                 * Item 0 left free to put shape in later;
                 * item 2 = number of coords, items 2 + = coords
                 */
                curattr->data.coords[1] = n - 2;
d310 1
a310 1
                for (n = 2, p = ptr; *p; p = next, n++)
d312 1
a312 4
                    next = p + strcspn(p, "0123456789%");
                    if (!strchr("0123456789%", *next)) break;

                    curattr->data.coords[n] = atoi(next);
d314 2
a315 4

                    percent = strchr(next, '%');
                    next   += strspn(next, "0123456789%");

@


1.1.2.14
log
@NB, This HTMLLib version went out in Browse v1.30 beta, 19 December 1997.
It now uses the URL_Fetcher module for URL relativisation, rather than
its own internal routines. The deprecated definition of BLOCK has been
commented out in rules.h, too.
@
text
@d22 1
a22 1
#include "html2_ext.h"    /* For the HTML bits */
d24 3
a26 3
#include "struct.h"       /* For the structures */
#include "string.h"       /* For string handling */
#include "internal.h"     /* predefinitions of functions */
d734 4
a737 5

//  char        * copy;
//  char        * buffer;
//  char        * uri;
//  extern char * __html_tidy_url(char * url);
d755 133
a887 1
  /* Otherwise, just go for it... */
d889 1
a889 1
  return __html_url_canonicalise_url(0, base, link);
d891 26
a916 167
// OLD CODE: Want to have used the above call for quite a
// while longer before the below gets cut out for good in
// case we find a good reason to use the below instead
// of the URL module's routines.
//
//  /* Check for an in-document link */
//
//  if (link[0] == '#')
//  {
//    ret = __html_malloc(strlen(link) + strlen(base) + 1, 1);
//    if (ret) sprintf(ret,"%s%s",base,link);
//
//    return ret;
//  }
//
//  /* Should have a Fetcher_Relativise call                               */
//  /*                                                                     */
//  /* Simple test for a fully qualified URL. Look for '://' in the string */
//  /* Also catch "mailto:" and "x500:" URLs at this point. We expect the  */
//  /* method to be at the start of the string. (This is to allow for      */
//  /* funny proxies :)                                                    */
//  /*                                                                     */
//  /* The test on ret - link <= 9 ensures URLs that are indeed relative,  */
//  /* but contain URLs themselves (e.g. as part of some CGI info in the   */
//  /* link) aren't treated as absolute (see below for more of this kind   */
//  /* of consideration). We want the :// to be within about the first 9   */
//  /* characters, more or less...                                         */
//
//  ret = strstr(link, "://");
//
//  if (
//       (ret && ret - link <= 9)     ||
//       !strincmp(link,"MAILTO:",7)  ||
//       !strincmp(link,"NEWS:",  5)  ||
//       !strincmp(link,"X500:",  5)  ||
//       !strincmp(link,"FILE:/", 6)
//     )
//  {
//    ret = strdup(link);
//    return ret;
//  }
//
//  /* Now look for broken URLs of the form 'method:/path/to/file' or           */
//  /* 'method:relative/path'. These are a tad more difficult to deal with      */
//  /* so a separate routine is needed to do this :) This relies on mailto and  */
//  /* x500 being caught above.                                                 */
//  /*                                                                          */
//  /* Also the test for being more than 7 chars in is needed for places like   */
//  /* www.pathfinder.com who have URLs of the form:                            */
//  /*                                                                          */
//  /* /adgw/nph-adgw.cgi?url=http:%2f%2fchess.ibm.park.org&advertiser=...      */
//  /* IBM%20OS2&description=IBM%20Chess%20Button&source=%2fpathfinder%2f...    */
//  /* welcome.html                                                             */
//  /*                                                                          */
//  /* which contain the sequence "http:" (Technically the ':' should be        */
//  /* encoded too I believe!). Anyway since mailto is the longest method, 7    */
//  /* should be okay, I hope!. Alternatively if this is found to be unreliable */
//  /* change the buffer=strchr() bit and the *link=='/' bits around.           */
//
//  buffer = strchr(link, ':');
//
//  if (buffer && (buffer - link < 7))
//  {
//    buffer++;
//
//    uri = strdup(buffer); /* Buffer should now contain URI. Just need new base */
//    if (!uri) return NULL;
//
//    /* Now get the method bit - ughh! */
//
//    buffer = strdup(link);
//
//    if (!buffer) return buffer;
//
//    ret  = strchr(buffer,':'); /* Can't fail because of above */
//    *ret = '\0';
//
//    /* Now need to construct new base bit. */
//    copy=__html_malloc(strlen(base)+strlen(buffer)+1,1);
//    if (!copy) return copy;
//    /* We have up to the : so skip that in base */
//    base=strchr(base,':');
//    if (base==NULL) return NULL;
//    sprintf(copy,"%s%s",buffer,base);
//    base=copy;
//    link=uri;
//  }
//
//  /* The 1st case. The link starts with a '/' so it is an absolute URL
//   * around the same host/method base.
//   */
//  if (*link=='/') {
//    link++;
//    ret=__html_malloc(strlen(base)+strlen(link)+1,sizeof(char));
//    if (ret==NULL) return NULL;
//
//    strcpy(ret,base);
//    copy=ret;
//    copy=strstr(copy,"://");
//    if (copy==NULL) {
//      __html_free(ret, 0);
//      return NULL;
//    }
//    copy++; copy++; copy++;
//    copy=strchr(copy,'/');
//    if (copy==NULL) {
//      __html_free(ret, 0);
//      return NULL;
//    }
//    copy++; *copy='\0';
//    strcat(ret,link);
//    return ret;
//  }
//
//  /* The 2nd case. The link starts with a './' so it is an relative URL
//   * around this page
//   */
//  if ((*link=='.') && (*(link+1)=='/')) {
//    link++; link++;
//
//default_return:
//
//    /*
//     * Basically we need to look back through base to find the last '/'
//     * and append link at that point. So we need a string the length
//     * of base and link, and then blat the two strings into it.
//     *
//     * So grab a copy of base, and strip it back to the required point
//     */
//    ret=copy=strdup(base);
//
//    if (ret==NULL) return ret;
//
//    /* If 'link' is a null string, return the base URL - so for example, */
//    /* http://www.site.com/name.html wouldn't get turned into            */
//    /* http://www.site.com/                                              */
//    /* No, don't do this... We want HREF="./" to work */
//    /*if (!*link) return ret;*/
//
//    ret=strrchr(copy,'/');
//
//    if (ret==NULL) {
//      __html_free(copy, 0);
//      return NULL;
//    }
//    ret++;
//    *ret='\0';
//
//    /* Create a big enough string */
//    ret=__html_malloc(strlen(copy)+strlen(link)+1,sizeof(char));
//    if (ret==NULL) return ret;
//    /* Add the two strings into the return buffer */
//    sprintf(ret,"%s%s",copy,link);
//    return __html_tidy_url(ret);
//  }
//
//  /* 3rd case. The link has a ':' in it. Assume its a link such as a
//   * mailto request. (i.e. host independant URL)
//   */
//
//  if (strchr(link, ':') != NULL) {
//    ret=strdup(link);
//    return ret;
//  }
//
//  /* Otherwise this is sort of the same as case 2 sans the './' */
//  goto default_return;
d918 1
@


1.1.2.15
log
@*** empty log message ***
@
text
@d343 1
a343 1
            /* The style of an OL */
@

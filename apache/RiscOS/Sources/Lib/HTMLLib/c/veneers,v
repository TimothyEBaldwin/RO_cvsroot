head	1.13;
access;
symbols
	HTMLLib-0_04:1.13
	HTMLLib-0_03:1.13
	HTMLLib-0_02:1.13
	HTMLLib-0_01:1.12
	ahodgkin_207release:1.10
	ahodgkin_206release:1.7
	ahodgkin_205release:1.3
	ahodgkin_204release:1.3
	ahodgkin_133beta:1.2.2.27
	kbracey_126:1.2.2.23
	kbracey_AW97patch:1.2.2.22
	ahodgkin_AW97:1.2.2.21
	kbracey_PreGordon:1.2.2.1
	Web_bp:1.2
	Web:1.2.0.2
	ARTtmp_merge:1.1.2.3
	ARTtmp:1.1.0.2;
locks; strict;
comment	@# @;


1.13
date	2006.03.13.21.10.18;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.13.13.10.38;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	99.06.04.14.51.23;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	98.09.10.15.54.03;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	98.08.29.16.15.48;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	98.08.07.16.11.45;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	98.06.16.15.36.34;	author ahodgkin;	state Exp;
branches;
next	1.6;

1.6
date	98.05.27.15.30.46;	author kbracey;	state Exp;
branches;
next	1.5;

1.5
date	98.05.11.11.13.21;	author ahodgkin;	state Exp;
branches;
next	1.4;

1.4
date	98.05.07.15.03.45;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	98.02.17.10.42.22;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	97.04.29.15.50.50;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.08.10.26.50;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.2.2.1
date	97.05.30.10.03.13;	author kbracey;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	97.06.03.12.50.14;	author kbracey;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	97.07.07.12.42.23;	author kbracey;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	97.07.10.12.41.06;	author blaughto;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	97.07.25.10.01.22;	author kbracey;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	97.07.28.15.19.56;	author kbracey;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	97.07.31.13.30.03;	author ahodgkin;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	97.08.01.15.06.34;	author kbracey;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	97.08.05.16.10.27;	author ahodgkin;	state Exp;
branches;
next	1.2.2.10;

1.2.2.10
date	97.08.06.14.28.17;	author ahodgkin;	state Exp;
branches;
next	1.2.2.11;

1.2.2.11
date	97.08.18.16.13.30;	author kbracey;	state Exp;
branches;
next	1.2.2.12;

1.2.2.12
date	97.09.18.14.11.29;	author kbracey;	state Exp;
branches;
next	1.2.2.13;

1.2.2.13
date	97.09.25.16.50.38;	author ahodgkin;	state Exp;
branches;
next	1.2.2.14;

1.2.2.14
date	97.09.30.14.13.47;	author kbracey;	state Exp;
branches;
next	1.2.2.15;

1.2.2.15
date	97.10.03.16.08.43;	author ahodgkin;	state Exp;
branches;
next	1.2.2.16;

1.2.2.16
date	97.10.06.15.17.44;	author ahodgkin;	state Exp;
branches;
next	1.2.2.17;

1.2.2.17
date	97.10.07.09.56.24;	author ahodgkin;	state Exp;
branches;
next	1.2.2.18;

1.2.2.18
date	97.10.08.12.33.44;	author kbracey;	state Exp;
branches;
next	1.2.2.19;

1.2.2.19
date	97.10.14.13.41.05;	author kbracey;	state Exp;
branches;
next	1.2.2.20;

1.2.2.20
date	97.10.14.14.48.31;	author kbracey;	state Exp;
branches;
next	1.2.2.21;

1.2.2.21
date	97.10.15.17.21.31;	author kbracey;	state Exp;
branches;
next	1.2.2.22;

1.2.2.22
date	97.10.22.14.22.03;	author kbracey;	state Exp;
branches;
next	1.2.2.23;

1.2.2.23
date	97.10.27.18.21.45;	author kbracey;	state Exp;
branches;
next	1.2.2.24;

1.2.2.24
date	97.11.14.15.43.17;	author kbracey;	state Exp;
branches;
next	1.2.2.25;

1.2.2.25
date	97.11.28.15.32.07;	author kbracey;	state Exp;
branches;
next	1.2.2.26;

1.2.2.26
date	98.01.07.14.08.12;	author kbracey;	state Exp;
branches;
next	1.2.2.27;

1.2.2.27
date	98.02.16.11.45.02;	author ahodgkin;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.08.10.26.50;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.04.09.16.44.39;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	97.04.28.14.20.20;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.13
log
@  New build variants; minor API tweaks; const/restrict additions.
Detail:
  Builds Unicode versions as well as non-Unicode versions now, and
  exports them. Required by March 2006 era Browse sources. API tweaks
  including filling in more info fields with border widths. Tightened
  up use of const/restrict in various interfaces.
Admin:
  Tested under Browse, new facilities work as expected. Builds all
  four variants (non-Unicode/Unicode, application/module) from clean
  and returns to clean state with !MkClean.

Version 0.02. Tagged as 'HTMLLib-0_02'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * These functions are basically remappings to the actual functions used.
 */

#include "VersionNum"
#include "api.h"
#include "internal.h"
#include "flex.h"
#include "stdio.h"
#include <string.h>
#include <stddef.h>
#include "swis.h"
#ifdef TonyTables
#include "HTMLTables.h"
#endif
#include "Unicode/encoding.h"
#ifdef UNIFONT
#include "Unicode/utf8.h"
#endif

static void do_the_funky_on_the_fly_buffer_shuffle_thing(StreamTokens *,
            int, int, char *, char *, char **, char **, char **, int *);

/***********************************************************************/
/* (void) __html_set_hourglass_percent(int done, int size)             */
/***********************************************************************/
/* A small macro to set the hour glass status                          */
/***********************************************************************/
#define __html_set_hourglass_percent(done,size) {\
  _swix(Hourglass_Percent, _IN(0), (done*100)/size); }

/***********************************************************************/
/* void HtmlInit(void)                                                 */
/***********************************************************************/
/* User frontend to initialisation routines                            */
/***********************************************************************/
void HtmlInit(void)
{
}

/***********************************************************************/
/* const char *HtmlVersion()                                           */
/***********************************************************************/
/* Return version details.                                             */
/***********************************************************************/
const char *HtmlVersion(void)
{
  return Module_HelpVersion;
}

/***********************************************************************/
/* void *HtmlParse(char *url, int length)                              */
/***********************************************************************/
/* This is the call to set up a new context within which a document is */
/* parsed. The length is the total size of the document and is an      */
/* optional parameter (it is used in place of size in HtmlGetStream to */
/* set the hourglass percentage if it is non-zero), and URL is a       */
/* pointer to the document being parsed.                               */
/***********************************************************************/
void *HtmlParse(char *url, int length, int type, int frames, int objects, int tables,
                int scripts, int encoding, encoding_priority priority)
{
   StreamTokens *st;
/* Create the stream context structure */
    st=__html_stream_init();
    if (st == NULL)
        return (void *)st;
/* Fill in the bits known, such as length, memory context and url */
    st->doclength=length; /* If known */
/* Create a memory context for this URL */
    st->memcontext=__html_memory_init();
    st->encoding = encoding_new(st->encoding_no = encoding, 0);
    st->maps = (MapStream *) __html_malloc(sizeof(MapStream), 1);
    if (!st->encoding || !st->maps)
    {
        __html_free(st->maps, 0);
        free(st);
        return NULL;
    }
    st->enc_priority = priority;
    st->utf_buffer = malloc(1024);
    if (!st->utf_buffer)
    {
        encoding_delete(st->encoding);
        free(st);
        return NULL;
    }
    st->utf_ptr = st->utf_buffer;
    st->utf_size = 1024;
    st->utf_end = st->utf_buffer + 1024 - 7; /* 6 for a UTF char + 1 for a terminator */
    st->url=strdup(url);
    st->type=type;
    st->usingframes=frames;
    st->usingobjects=objects;
    st->usingtables=tables;
    st->usingscripts=scripts;
/* Return the pointer to the struct as a void * */
    return (void *)st;
}

static void StripNoframes(HStream *p)
{
  HStream *next;

  if (!p)
    return;

  /*
   * Skip one - this is OK because p will either be the very first token (which
   * is infinitely unlikely to be NOFRAMES, or it will be the last tag
   * of a previous parse chunk, hence already checked
   */
  p = p->next;

  for ( ; p; p=next)
  {
    next = p->next;
    if (p->type & TYPE_NOFRAMES) {
      p->prev->next = next;
      if (next)
        next->prev = p->prev;
      /*
       * This doesn't free associated data in the token, but it will get
       * freed eventually when HtmlFreeStream is called. Should be sorted.
       */
      __html_free(p, 0);

    }
  }
}

static UCS4 pending_code;

static int ucs_out(void *streamtok, UCS4 ucs)
{
    StreamTokens *st = (StreamTokens *)streamtok;

    /* Quick and dirty way of stripping out UCS-2 signature... */
    if (ucs == 0xFEFF)
        return 0;

    if (ucs < 0x20)
    {
        /* HT, LF and CR are only C0 controls valid in HTML */
        if (ucs != 0x0009 && ucs != 0x000A && ucs != 0x000D)
            ucs = 0xFFFD;
    }
    else if (ucs >= 0x007F && ucs < 0x00A0)
    {
        /* No C1 controls valid */
        ucs = 0xFFFD;
    }

    if (st->utf_ptr > st->utf_end)
    {
        int ptr_pos = st->utf_ptr - st->utf_buffer;
        int end_pos = st->utf_end - st->utf_buffer;
        char *newbuf;

        newbuf = realloc(st->utf_buffer, st->utf_size * 2);
        if (!newbuf)
        {
            pending_code = ucs;
            return 1;
        }
        st->utf_buffer = newbuf;

        st->utf_end = newbuf + end_pos + st->utf_size;
        st->utf_ptr = newbuf + ptr_pos;
        st->utf_size *= 2;
    }

    st->chars_read++;
    #ifdef UNIFONT
    st->utf_ptr = UCS4_to_UTF8(st->utf_ptr, ucs);
    #else
    *st->utf_ptr++ = __html_iso10646_to_latin1(ucs);
    #endif

    return 0;
}

/***********************************************************************/
/* HStream *HtmlGetStream(void *streamtok, char **document, int size)  */
/***********************************************************************/
/* Attempt to parse an additional "size" bytes of the "document" using */
/* the context pointed too in "streamtok". This allows documents to be */
/* parsed as they come in off the wire.                                */
/***********************************************************************/

HStream *HtmlGetStream(void *streamtok, char **document, int size, unsigned int *flagsptr)
{
  HStream *return_val, *current, *last_token;
  StreamTokens *st = (StreamTokens *)streamtok;
  char *doc,  *start, *end;
  int utf_chunk_start;
  int old_chars_read;
  int chunksize=st->doclength;
  int oldflexstate;
  unsigned int flags = 0;
  int firsttoken = 1;
  int n, ntotal=0;

#ifdef TRACE
{
    FILE *fp=fopen("ADFS::4.$.Trace.ParseIn", "a");
    if (fp)
    {
        int t;
        fprintf(fp, "HtmlGetStream(%p, %d)\n", streamtok, size);
        t=size;
        if (st->done < st->sizesofar)
            t+=st->sizesofar - st->done;
        fwrite(doc+st->done, t, 1, fp);
        fclose(fp);
    }
}
#endif

  if (!size || st->dead) return NULL;

  utf_chunk_start = st->utf_ptr - st->utf_buffer;
  old_chars_read = st->chars_read;

  /* Turn flex budging off to prevent grief as we read the source document */
  oldflexstate = flex_set_budge(0);

retry_with_more_memory:

  n = encoding_read(st->encoding, ucs_out, *document + st->sizesofar, size - ntotal, st);
  ntotal += n;
  if (ntotal != size && n > 0)
  {
      int r;

      /* We've run out of memory - probably because flex budge had to be off in
       * the encoding routine. Get some more memory and go round again.
       */
      st->sizesofar += n;
      flex_set_budge(1);
      r = ucs_out(st, pending_code);
      flex_set_budge(0);
      if (r == 0) goto retry_with_more_memory;
  }
  /* For everyone's convenience... */
  *st->utf_ptr = '\0';

  /* Can put flex budgie back on now because we're not going to look */
  /* at the document source again.                                   */
  flex_set_budge(oldflexstate);

/* Set up our environment first */
  __html_set_memory_context(st->memcontext);

  doc = start = st->utf_buffer;
  st->sizesofar += n;
  end = st->utf_ptr;
  if (chunksize == 0) chunksize = end - doc;

/* Now parse the document */
  if (st->type == TYPE_HTMLFILE) {
/* HTML Parser */

    return_val=current=st->current;

    while (st->special_return || (doc < end && *doc != '\0' && !st->dead)) {
      char *olddoc = doc;
      size=chunksize-(doc-start);
      /* Fail safe for badly terminated strings */
      if ((size<1) || __html_done_for_now) break;
      if (return_val == NULL && !st->object) {
        current=return_val=last_token=__html_stream_parse(st, &doc, st->url, size, NULL);
        if (st->_stream_map)
            current=return_val=last_token=NULL;
        /*if (current) flags |= HTML_GOT_MORE;*/
        if (current == NULL && doc == olddoc)
            __html_done_for_now = 1;
      }
      else {
        #ifdef TonyTables //
        /*
         * if there are incomplete tables, then you link somewhere different
         * also table-stuff needs a bit of context in order to operate properly
         */
        table_prev_info realcurrent;

        realcurrent = __html_find_current_object(st, current);

        realcurrent=table_skip_current(st, realcurrent);

        st->isendtag=0;
        if (realcurrent.prevnextptr != NULL)
        {
            *realcurrent.prevnextptr=
            last_token=__html_stream_parse(st, &doc, st->url, size, realcurrent.prev);
            if (st->_stream_map) last_token = NULL;
            /*if (*realcurrent.prevnextptr) flags |= HTML_GOT_MORE;*/
            if (firsttoken && *realcurrent.prevnextptr && realcurrent.prev != current)
                flags |= HTML_GOT_MORE_IN_A_TABLE;
        }
        else
        {
            HStream *t;
            t = __html_stream_parse(st, &doc, st->url, size, current);
            if (t->tagno == TAG_FORM)
                st->pendingformfortable = t;
            last_token = NULL;
        }
        /* effect is to skip anything before valid <tr><td> e.g. junk<tr>junk<td> */
        #else
        st->isendtag=0;
        current->next=__html_stream_parse(st, &doc, st->url, size, current);
        if (st->_stream_map) current->next = NULL;
        if (current->next) flags |= HTML_GOT_MORE;
        #endif
        if (realcurrent.prevnextptr != NULL && *realcurrent.prevnextptr != NULL)
        {
            firsttoken = 0;
#ifdef NEWSPACING
            if ((st->isendtag) && realcurrent.prev && realcurrent.prev->text &&
                !(realcurrent.prev->style & PRE) &&
                realcurrent.prev->tagno != TAG_TEXTAREA)
            {
                int s=strlen(realcurrent.prev->text);
                if (s > 0)
                {
                    if (realcurrent.prev->text[s-1]==' ')
                        realcurrent.prev->text[s-1]='\0';
                }
            }
#endif
            (*realcurrent.prevnextptr)->prev = realcurrent.prev;
            if (current->next != NULL)
                current=current->next;
        }
        else if (doc == olddoc)
            __html_done_for_now = 1;
      }
      /*
       * Code to deal with "on-the-fly" encoding changes via the
       *    <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
       * construct.
       */
      if (last_token && last_token->tagno == TAG_META &&
          st->enc_priority < priority_meta &&
          HtmlMETAhttp_equiv(last_token) &&
          HtmlMETAcontent(last_token))
      {
          if (strincmp(HtmlMETAhttp_equiv(last_token), "Content-Type", 12) == 0)
          {
              char *p = strinstr(HtmlMETAcontent(last_token), "charset=", 256);
              if (p)
              {
                  int enc;

                  p += 8;
                  while (*p == ' ') p++;

                  enc = encoding_number_from_name(p);
                  if (enc && enc != st->encoding_no)
                  {
                      do_the_funky_on_the_fly_buffer_shuffle_thing
                        (st, enc, old_chars_read, *document,
                         st->utf_buffer + utf_chunk_start,
                         &doc, &start, &end, &chunksize);
                      if (st->encoding_callback)
                          st->encoding_callback(enc, st->encoding_callback_handle);
                  }
              }
          }
      }
      if (st->insertion)
      {
          size_t inslen = strlen(st->insertion);
          int proceed = 0;
          int bufsize = st->utf_end - st->utf_ptr;

          /* Do we have enough space in the buffer already? */

          if (inslen > bufsize)
          {
              ptrdiff_t ptr_pos = st->utf_ptr - st->utf_buffer;
              ptrdiff_t end_pos = st->utf_end - st->utf_buffer;
              ptrdiff_t doc_pos = doc - st->utf_buffer;
              int extraspace = inslen - bufsize;
              char *newbuf = realloc(st->utf_buffer, st->utf_size + extraspace);

              if (newbuf)
              {
                  st->utf_buffer = start = newbuf;

                  st->utf_end = newbuf + end_pos + extraspace;
                  st->utf_ptr = end = newbuf + ptr_pos;
                  st->utf_size += extraspace;
                  doc = newbuf + doc_pos;

                  proceed = 1;
              }
          }
          else proceed = 1;

          /* Continue only if we had enough space or the reallocation succeeded */

          if (proceed)
          {
            memmove(doc + inslen, doc, end - doc + 1); /* +1 for the terminating '/0' */
            memcpy(doc, st->insertion, inslen);

            end += inslen;
            chunksize += inslen;
            st->utf_ptr += inslen;
          }

          /* Either way, free the insertion buffer */

          __html_free(st->insertion, 0);
          st->insertion = NULL;
      }
      /*if (chunksize >= 1)
        __html_set_hourglass_percent((int)(doc-start),
            chunksize);*/
      /*if (doc == olddoc && current == NULL)
        break;*/
    }
    __html_done_for_now=0;

    if (st->usingframes)
      StripNoframes(return_val);

    if (return_val)
    {
        current = return_val;
        while (current->next)
            current = current->next;

        st->current = current;
    }

    /*if (st->special_return)
    {
        st->current->next = st->special_return;
        st->current = st->special_return;
        st->special_return = NULL;
    }*/
  }
  else { /* plain text */
    table_prev_info dummy = { NULL, NULL };
    table_skip_current(st, dummy);
    return_val=__html_return_text_token(st, doc, end - doc);
    doc=end;
    if (st->current)
      st->current->next = return_val;
    st->current = return_val;
    /*if (return_val) flags |= HTML_GOT_MORE;*/
  }

/* Preserve the start of the stream for us */
  if (st->Stream==NULL)
      st->Stream=return_val;
  else if (return_val != NULL && return_val->next != NULL && !(flags & HTML_GOT_MORE_IN_A_TABLE))
      return_val=return_val->next;

  /* Copy unused stuff back to bottom of UTF buffer */
  memmove(st->utf_buffer, doc, st->utf_ptr - doc);
  st->utf_ptr = st->utf_buffer + (st->utf_ptr - doc);


  if (flagsptr)
    *flagsptr = flags;

/*
 * Return the pointer to the complete stream or the element which
 * we added if the stream already existed.
 */
  return return_val;
}

/***********************************************************************/
/* void HtmlEndParse(void *stream)                                     */
/***********************************************************************/
/* Free all the structures involved in the parsing of a document,      */
/* but not the actual generated token stream, which is freed later     */
/* with HtmlStreamFree.                                                */
/***********************************************************************/
void HtmlEndParse(void *stream)
{
  free(((StreamTokens *) stream)->utf_buffer);
  encoding_delete(((StreamTokens *) stream)->encoding);

  free(stream);
}

/***********************************************************************/
/* void HtmlStreamFree(void *stream)                                   */
/***********************************************************************/
/* Small entry point to free up all the memory associated with a       */
/* stream (even if the stream was created with multiple parses.        */
/***********************************************************************/
void HtmlStreamFree(void *stream)
{
    if (stream==NULL) return;
    __html_free(stream, 1);
    /*delete_encoding(st->encoding);
    free(st->utf_buffer);*/
#ifdef MEMORY_DEBUG
    __html_memory_list();
#endif
}

int HttpStripHeaders(char *stream, size_t stream_len)
{
  return __http_strip_headers(stream, stream_len);
}

unsigned int HtmlIdentify(char * base_url, char *stream, size_t stream_len,
                                      char done, char **url,
                                      int *file_type, int *canparse,
                                      int *encoding)
{
  return __html_identify(base_url, stream, stream_len, done,
                         url, file_type, canparse, encoding);
}

#if 0
char *HTTPEscapeString(char *string)
{
  return __http_escape_string(string);
}
#endif

int HTTPEncodingNumberFromName(const char *name)
{
  return encoding_number_from_name(name);
}

/***********************************************************************/
/* void *HtmlMalloc(size_t size, void *parent)                         */
/***********************************************************************/
/* User frontend to __html_malloc                                      */
/***********************************************************************/
void *HtmlMalloc(size_t size, void *parent)
{
    __html_set_memory_context_from_block(parent);
    return __html_malloc(size, 1);
}

/***********************************************************************/
/* void *HtmlFree(void *block)                                         */
/***********************************************************************/
/* User frontend to __html_free for a specific block                   */
/***********************************************************************/
void HtmlFree(void *block)
{
    __html_free(block, 0);
}

/***********************************************************************/
/* void *HtmlReturnContext(void *block)                                */
/***********************************************************************/
/* User frontend to __html_return_context                              */
/***********************************************************************/
unsigned int HtmlReturnContext(void *block)
{
    return __html_return_context(block);
}

/***********************************************************************/
/* void HtmlRelativiseURL(const char *base, const char *link, void *p..*/
/***********************************************************************/
/* User frontend to __html_relativise_url                              */
/***********************************************************************/
char *HtmlRelativiseURL(const char * restrict base, const char * restrict link, const void * restrict parent)
{
    __html_set_memory_context_from_block(parent);
    return __html_relativise_url(base, link);
}

static int count_chars(void *h, UCS4 c);
static int count_utf(void *h, UCS4 c);

/*
 * We have just parsed a <META> tag with a encoding selection.
 * Goody. But we have already converted a load of guff with the original
 * encoding, and that is sitting in utf_buffer, and the document pointer
 * has been advanced. We need to rewind the decoder and try again.
 *
 * Here it is in pictures:
 *
 *  document source:
 *
 *  ------------------------------<META xxx>-----------------------------
 *  ^                          ^                                        ^
 *  |                          start of this chunk                      |
 *  *document                                                  *document + st->sizesofar
 *                                                            (end of this chunk)
 *  utf_buffer:
 *
 *  oooz-----<META xxx>------------------.........        (o = left over data from last chunk
 *  ^  ^               ^                 ^       ^         z = a character split between chunks
 *  |  utf_chunk_start doc               |    st->utf_end  . = free space in utf_buffer)
 *  st->utf_buffer                  st->utf_ptr
 *
 * Because of the statefulness of some encodings we really need to rewind
 * all the way back to the start. We have stored in old_chars_read the number
 * of characters (ie converted UCS codes) read up to but not including this
 * chunk. We get the encoder to decode this many characters (discarding contents).
 *
 * We then run the decoder again, until it has generated (doc - utf_chunk_start)'s
 * worth of UTF-8. We can then clear out the UTF-8 buffer, and run the
 * decoder one last time using the standard ucs_out routine.
 *
 * BEWARE!!!! This routine will only work ONCE!!!! You can't have multiple META charset
 * selections!!!
 */
static void do_the_funky_on_the_fly_buffer_shuffle_thing
            (StreamTokens *st,
             int encoding_no,
             int old_chars_read,
             char *document,
             char *utf_chunk_start,
             char **pdoc,
             char **pstart,
             char **pend,
             int *pchunksize
             )
{
    int n;
    unsigned int docpos = 0;

    encoding_reset(st->encoding);
    st->chars_read = 0;

    /* Wind up to "utf_chunk_start" */
    if (old_chars_read)
        docpos += encoding_read(st->encoding, count_chars, document, st->sizesofar,
                                &old_chars_read);

    n = *pdoc - utf_chunk_start;

    /* Wind up to "doc" */
    if (n)
        docpos += encoding_read(st->encoding, count_utf, document + docpos,
                                st->sizesofar - docpos, &n);

    /* Now we clear the utf_buffer */
    st->utf_ptr = st->utf_buffer;

    /* Sort out the encoding */
    encoding_delete(st->encoding);
    st->encoding = encoding_new(st->encoding_no = encoding_no, 0);
    st->enc_priority = priority_meta;

    /* And run the decoder for real */
    encoding_read(st->encoding, ucs_out, document + docpos,
                  st->sizesofar - docpos, st);

    /* Sort out document pointers for the parser */
    *pstart = *pdoc = st->utf_buffer;
    *pend = st->utf_ptr;
    *pchunksize = *pend - *pdoc;

    /* Put back a terminator */
    *st->utf_ptr = '\0';
}

static int count_chars(void *h, UCS4 c)
{
    int *ip = (int *) h;

    NOT_USED(c);

    return --(*ip) ? 0 : 1;
}

static int count_utf(void *h, UCS4 c)
{
    int *ip = (int *) h;

    #ifdef UNIFONT
    *ip -= UTF8_codelen(c);
    #else
    NOT_USED(c);
    *ip -= 1;
    #endif

    return *ip > 0 ? 0 : 1;
}


extern void HtmlSetEncodingCallback(void *str, void (*cb)(int, void *), void *handle)
{
    StreamTokens *st = (StreamTokens *) str;

    st->encoding_callback = cb;
    st->encoding_callback_handle = handle;
}

extern void HtmlSetScriptCallback(void *str, HtmlScriptHandler *cb, void *handle)
{
    StreamTokens *st = (StreamTokens *) str;

    st->script_callback = cb;
    st->script_callback_handle = handle;
}

extern void HtmlSetBaseCallback(void *str, HtmlBaseHandler *cb, void *handle)
{
    StreamTokens *st = (StreamTokens *) str;

    st->base_callback = cb;
    st->base_callback_handle = handle;
}

extern HStream *HtmlReplaceOBJECT(HStream *t)
{
    return __html_replace_object(t);
}

/***********************************************************************/
/* unsigned int HtmlParseColour(const char *colour)                    */
/***********************************************************************/
/* Return a RISC OS colour number (0xBBGGRR00) based on the given      */
/* string which should contain a valid way of specifying colours in    */
/* HTML *after* being unescaped.                                       */
/***********************************************************************/

extern unsigned int HtmlParseColour(const char *colour)
{
  /* This uses a routine in attributes.c, exported by internal.h */

  return __html_convcol(colour, 0);
}
@


1.12
log
@  Brought under srccommit control. Dependencies stripped on cleaning.
Detail:
  !MkClean now runs StripDepnd on the Makefile. VersionNum file is
  used to implement a new "HtmlVersion" call (which just returns the
  Module_HelpVersion string).
Admin:
  !MkClean tested. HtmlVersion call not tested.

Version 0.01. Tagged as 'HTMLLib-0_01'
@
text
@d586 1
a586 1
char *HtmlRelativiseURL(const char *base, const char *link, void *parent)
@


1.11
log
@Various fixes. Attribute parser would hang when faced with '...VALUE=>'.
Entites which were a substring match of other entities in name (possible
in HTML 4 but not previously) would get mismatched in HTML (the shorter
always being picked and extra letters left over getting spat out to the
page). Solved by having a seperate try-first table of substring matching
entities.

New feature (sort of). Entities in URLs were never escaped as the
existing relaxed entity parser would often mangle CGI-style URLs. There
is now a strict unescaping mode used for URLs which seems to sort out
various sites where this was a problem.

Makefile exports to 'Lib$Dir' rather than 'HTMLLib:' to fit in with
current build environments.
@
text
@d19 1
d53 10
@


1.10
log
@Euro sign mapping added to display.c's ISO10646 -> Acorn Extended Latin-1
transformation table. HtmlParse can be told whether or not it supports
JavaScript (if so, script callback function is called and <NOSCRIPT> contents
are ignored; else script callback function is not called and <NOSCRIPT> is
parsed, with <SCRIPT> contents just passed through). In veneers.c, names of
parameters to HtmlParse changed to match those in api.h.
@
text
@d310 1
a310 1
             last_token = NULL;
@


1.9
log
@Shouldn't crash when it hits </option> in <select> lists now (oops).
Fixed buffer juggling done then <script> callback function returns data
to be written into the document; utf_end wasn't being correctly updated.
NOSCRIPT is now dealt with in the same way as STYLE - passed through as
raw text, but won't be parsed.
@
text
@d63 2
a64 2
void *HtmlParse(char *url, int length, int type, int usingframes, int usingobjects, int usingtables,
                int encoding, encoding_priority priority)
d96 4
a99 3
    st->usingframes=usingframes;
    st->usingobjects=usingobjects;
    st->usingtables=usingtables;
@


1.8
log
@Added externally visible function HtmlParseColour, which maps to
__html_convcol internally. Extended API to the latter so that it
either does the "return random colour if I don't understand the
string" trick, or returns a value telling the caller it didn't
know what was going on. Needed all of this for JavaScript support
in Browse.
@
text
@d377 6
a382 1
          if (inslen > st->utf_end - st->utf_ptr)
d387 1
a387 1
              int extraspace = inslen - (st->utf_end - st->utf_ptr);
d389 1
d393 3
a396 2
                  st->utf_ptr = end = newbuf + ptr_pos;
                  st->utf_end = newbuf + end_pos;
d398 2
d402 16
a417 5
          memmove(doc + inslen, doc, end - doc + 1); /* +1 for the terminiating '/0' */
          memcpy(doc, st->insertion, inslen);
          end += inslen;
          chunksize += inslen;
          st->utf_ptr += inslen;
@


1.7
log
@Multiple text tags inside one <OPTION> container are "glued together",
so HTML such as '<OPTION>Some <I>italicised</I> entries' will generate
meaningful menu entries.

<PRE> and <Hn> elements now cancel <P ALIN="...">, whereas they did
not before. This is special-cased for those elements, based on the
code already in place for <DIV>.
@
text
@a539 10
/* void *HtmlFreeAll(void *block)                                      */
/***********************************************************************/
/* User frontend to __html_free for all blocks in a given context      */
/***********************************************************************/
void HtmlFreeAll(void *block)
{
    __html_free(block, 1);
}

/***********************************************************************/
d699 15
@


1.6
log
@Added calls to examine BASE element easily
@
text
@d698 1
a698 6
extern HStream *HtmlReplaceOBJECT(HStream *t)
{
    return __html_replace_object(t);
}

extern const char *HtmlDocumentBASEhref(void *str)
d702 2
a703 1
    return st->url;
d706 1
a706 1
extern const char *HtmlDocumentBASEtarget(void *str)
d708 1
a708 3
    StreamTokens *st = (StreamTokens *) str;

    return st->target;
a709 1

@


1.5
log
@Fixed premature termination when script inserts text
@
text
@d702 15
@


1.4
log
@Removed unused function HTTPEscapeString.
Added SCRIPT element callback function with provision for source insertion.
@
text
@a390 1
                  chunksize += inslen;
d396 1
@


1.3
log
@Web branch merged
@
text
@d24 1
d374 27
d506 1
d511 1
d688 8
@


1.2
log
@Merged in ARTtmp_merge
@
text
@a14 77
/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/veneers,v $
 *
 * $Log: veneers,v $
 * Revision 1.1.2.3  1997/04/28 14:20:20  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
 * Revision 1.1.2.2  1997/04/09 16:44:39  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:26:50  kbracey
 * Initial revision
 *
 * Revision 1.4  95/10/30  10:40:08  pwain
 * Removed (#ifdef'ed out) the calls to the quick
 * and long display code.
 *
 * Revision 1.3  95/10/18  10:41:36  pwain
 * Changed calls to __html_*_free() to
 * __html_free(x,1) to ensure that all allocated
 * memory gets zapped.
 *
 * Revision 1.2  95/10/16  08:12:50  pwain
 * Added code to list memory in usage after a call to
 * either __html_stream_free or __html_tree_free
 *
 * Revision 1.1  95/10/12  12:46:53  pwain
 * Initial revision
 *
 *
 * --- Original Log Information ---
 *
 * $Version: networking $
 *
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/veneers,v $
 *
 * $Log: veneers,v $
 * Revision 1.1.2.3  1997/04/28 14:20:20  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
 * Revision 1.1.2.2  1997/04/09 16:44:39  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:26:50  kbracey
 * Initial revision
 *
 * Revision 1.4  95/10/30  10:40:08  pwain
 * Removed (#ifdef'ed out) the calls to the quick
 * and long display code.
 *
 * Revision 1.3  95/10/18  10:41:36  pwain
 * Changed calls to __html_*_free() to
 * __html_free(x,1) to ensure that all allocated
 * memory gets zapped.
 *
 * Revision 1.2  95/10/16  08:12:50  pwain
 * Added code to list memory in usage after a call to
 * either __html_stream_free or __html_tree_free
 *
 * Revision 1.1  95/10/12  12:46:53  pwain
 * Initial revision
 *
 * Revision 1.2  95/09/11  13:13:05  pwain
 * Fixes. The calls into __html_stream_free were typcasting a HStream to
 * type HTML, causing memory to be corrupted.
 *
 * Revision 1.1  95/09/08  10:06:12  pwain
 * Initial revision
 *
 *
 */

d24 1
a24 1
#include "kernel.h"
d28 7
a40 1
#define Hourglass_Percent 0x406c4
d42 10
a51 2
  r.r[0]=(int)((done*100)/size); \
  _kernel_swi(Hourglass_Percent, &r, &r);}
d60 1
a60 1
/* pointer to the document being parsed. 	    	       	       */
d62 2
a63 1
void *HtmlParse(char *url, int length, int type, int usingframes)
d74 19
a94 1
#ifdef FRAMESUPPORT
d96 2
a97 1
#endif
a101 1
#ifdef FRAMESUPPORT
d132 51
a182 1
#endif
d189 1
a189 1
/* parsed as they come in off the wire.	   	       		       */
d192 1
a192 1
HStream *HtmlGetStream(void *streamtok, char **document, int size, unsigned int *flags)
d194 1
a194 1
  HStream *return_val, *current;
d196 3
a198 1
  char *doc,  *start, *docstart, *end;
d201 3
a204 4
#ifdef OLDCODE
  int todo=size;
#endif
  _kernel_swi_regs r;
d221 1
a221 1
  if (!size) return (HStream *)size;
d223 2
a224 5
  /* Yuckery! Give us 16K of free space by shifting flex stuff, then lock the
     flex stuff */
  oldflexstate = flex_set_budge(1);
  free(malloc(16384));
  flex_set_budge(0);
d226 2
a227 1
  doc=start=docstart=*document;
d229 1
a229 2
/* Set up our environment first */
  __html_set_memory_context(st->memcontext);
d231 5
a235 1
  current=st->Stream;
d237 8
a244 10
  if (st->done != 0) {
/* We have already done some parsing so update doc and size appropriatly */
    int  newsize = size;
    doc += st->done;
    start=doc;
    if (st->done < st->sizesofar) {
      newsize += st->sizesofar - st->done;
    }
    st->sizesofar += size;
    size = newsize;
d246 9
a254 4
  else {
    st->sizesofar += size;
  }
  end=*document+st->sizesofar;
d256 4
a259 1
  if (chunksize==0) chunksize=size;
d265 1
a265 7
    if (current == NULL) {
      current=return_val=__html_stream_parse(st, &doc, st->url, size, NULL);
    }
    else {
      while (current->next != NULL) current=current->next;
      return_val=current;
    }
d267 1
a267 1
    while (doc < end && *doc != '\0') {
d272 5
a276 2
      if (return_val == NULL) {
        current=return_val=__html_stream_parse(st, &doc, st->url, size, NULL);
d281 1
a281 1
        #ifdef TonyTables
d286 5
a290 2
        HStream **realcurrent;
        realcurrent=table_skip_current(current);
d293 9
a301 2
        if (realcurrent != NULL)
            *realcurrent=__html_stream_parse(st, &doc, st->url, size, current);
d303 7
a309 1
             __html_stream_parse(st, &doc, st->url, size, current);
d314 2
d317 3
a319 1
        if (current->next != NULL) {
d321 3
a323 2
            if ((st->isendtag) && current && current->text && current &&
                !(current->style & (PRE|TEXTAREA)))
d325 1
a325 1
                int s=strlen(current->text);
d328 2
a329 2
                    if (current->text[s-1]==' ')
                        current->text[s-1]='\0';
d333 3
a335 2
            current->next->prev = current;
            current=current->next;
d340 34
a373 1
      if (chunksize >= 1)
d375 1
a375 1
            chunksize);
a380 1
    #ifdef FRAMESUPPORT
a382 1
    #endif
d384 5
d390 9
d401 8
a408 8
    if (current == NULL) {
      current=return_val=__html_return_text_token(doc,size);
    }
    else {
      while (current->next != NULL) current=current->next;
      return_val=current->next=__html_return_text_token(doc,size);
    }
    doc+=size;
d414 1
a414 1
  else if (return_val != NULL && return_val->next != NULL)
d417 4
a420 3
/* and make a note of how much we have done */
  st->done=(doc-docstart);
  if (st->done > st->sizesofar) st->done=st->sizesofar;
d422 2
a423 1
  flex_set_budge(oldflexstate);
d433 15
d451 1
a451 1
/* stream (even if the stream was created with multiple parses.	       */
d453 2
a454 1
void HtmlStreamFree(void *stream) {
d457 2
d469 4
a472 3
unsigned int HtmlIdentify(char *stream, size_t stream_len, char done,
       		    		      char **url, int *file_type,
       		    		      int *canparse)
d474 2
a475 1
  return __html_identify(stream, stream_len, done, url, file_type, canparse);
d481 182
@


1.2.2.1
log
@Added HtmlMalloc and HtmlFree client calls
@
text
@d15 77
a380 21
}

/***********************************************************************/
/* void *HtmlMalloc(size_t size, void *parent)                         */
/***********************************************************************/
/* User frontend to __html_malloc                        	       */
/***********************************************************************/
void *HtmlMalloc(size_t size, void *parent)
{
    __html_set_memory_context_from_block(parent);
    return __html_malloc(size, 1);
}

/***********************************************************************/
/* void *HtmlFree(void *block)                                         */
/***********************************************************************/
/* User frontend to __html_free                             	       */
/***********************************************************************/
void HtmlFree(void *block)
{
    __html_free(block, 0);
@


1.2.2.2
log
@First attempt at "more HStreams have come in" flag and getting previous
pointers to work in tables. Various fiddles by GThorburn.
@
text
@d109 1
a109 1
HStream *HtmlGetStream(void *streamtok, char **document, int size, unsigned int *flagsptr)
a115 1
  unsigned int flags = 0;
a175 1
      if (current) flags |= HTML_GOT_MORE;
a188 1
        if (current) flags |= HTML_GOT_MORE;
d193 1
a193 1
        #ifdef TonyTables //
d198 1
a198 1
        table_prev_info realcurrent;
d202 2
a203 5
        if (realcurrent.prevnextptr != NULL)
        {
            *realcurrent.prevnextptr=__html_stream_parse(st, &doc, st->url, size, current);
            if (*realcurrent.prevnextptr) flags |= HTML_GOT_MORE;
        }
a209 1
        if (current->next) flags |= HTML_GOT_MORE;
d211 1
a211 2
        if (realcurrent.prevnextptr != NULL && *realcurrent.prevnextptr != NULL)
        {
d213 2
a214 2
            if ((st->isendtag) && realcurrent.prev && realcurrent.prev->text &&
                !(realcurrent.prev->style & (PRE|TEXTAREA)))
d216 1
a216 1
                int s=strlen(realcurrent.prev->text);
d219 2
a220 2
                    if (realcurrent.prev->text[s-1]==' ')
                        realcurrent.prev->text[s-1]='\0';
d224 2
a225 3
            (*realcurrent.prevnextptr)->prev = realcurrent.prev;
            if (current->next != NULL)
                current=current->next;
a252 1
    if (return_val) flags |= HTML_GOT_MORE;
a266 3

  if (flagsptr)
    *flagsptr = flags;
@


1.2.2.3
log
@Fixed stripping of spaces before end tags inside tables
@
text
@d207 1
a207 1
            *realcurrent.prevnextptr=__html_stream_parse(st, &doc, st->url, size, realcurrent.prev);
@


1.2.2.4
log
@Added HtmlInit function to explicitly initialse some static data so that a variant suitable for use by modules can be made
@
text
@a338 10

/***********************************************************************/
/* void HtmlInit(void)                                                 */
/***********************************************************************/
/* User frontend to initialisation routines                            */
/***********************************************************************/
void HtmlInit(void)
{
    __html_rules_init();
}
@


1.2.2.5
log
@Added new external call HtmlRelativiseURL, and added support for hex entities.
@
text
@a348 12

/***********************************************************************/
/* void HtmlRelativiseURL(const char *base, const char *link, void *p..*/
/***********************************************************************/
/* User frontend to __html_relativise_url                              */
/***********************************************************************/
char *HtmlRelativiseURL(const char *base, const char *link, void *parent)
{
    __html_set_memory_context_from_block(parent);
    return __html_relativise_url(base, link);
}

@


1.2.2.6
log
@SCRIPT and <A onclick> handling, hopefully
@
text
@d61 1
d63 1
d68 1
d99 1
d247 1
d250 1
@


1.2.2.7
log
@Added HtmlReturnContext (__html_return_context) to get the context of a
block of memory (e.g. an HStream structure). This allows clients to check
if some particular block belongs to a stream that is about to be freed,
say, and take appropriate action before the freeing. Merged in a few
changes by Kevin Bracey to help with vertical white space problems,
mostly involving SCRIPT tags - there was also a bug in BASE which didn't
check for an HREF before trying to read the attributes value, so broken
HTML like <BASE FONT=1> would stop all subsequent HREFs from being
correctly relativised.
@
text
@d46 1
a46 1
/* pointer to the document being parsed.                               */
d102 1
a102 1
/* parsed as they come in off the wire.                                */
d286 1
a286 1
/* stream (even if the stream was created with multiple parses.        */
d302 2
a303 2
                                      char **url, int *file_type,
                                      int *canparse)
d316 1
a316 1
/* User frontend to __html_malloc                                      */
d327 1
a327 1
/* User frontend to __html_free                                        */
a341 10
}

/***********************************************************************/
/* void *HtmlReturnContext(void *block)                                */
/***********************************************************************/
/* User frontend to __html_return_context                              */
/***********************************************************************/
unsigned int HtmlReturnContext(void * block)
{
    return __html_return_context(block);
@


1.2.2.8
log
@Fixed &#160;, fixed option selection, changed GOT_MORE flag
@
text
@a112 1
  int firsttoken = 1;
d173 1
a173 3
      if (current)
          firsttoken=0;
      /*if (current) flags |= HTML_GOT_MORE;*/
d187 1
a187 1
        /*if (current) flags |= HTML_GOT_MORE;*/
d204 1
a204 3
            /*if (*realcurrent.prevnextptr) flags |= HTML_GOT_MORE;*/
            if (firsttoken && *realcurrent.prevnextptr && realcurrent.prev != current)
                flags |= HTML_GOT_MORE_IN_A_TABLE;
a215 1
            firsttoken = 0;
d256 1
a256 1
    /*if (return_val) flags |= HTML_GOT_MORE;*/
@


1.2.2.9
log
@Made __html_stream_init() externally visible, as HtmlGetContext. The reasons
why are fully documented in the comments by the relevant part of either
api.h or veneers.c.
@
text
@a39 20
/* void *HtmlGetContext(void)                                          */
/***********************************************************************/
/* This is a call to get a context pointer from HTMLLib - perhaps      */
/* because you want to use some of the HTMLLib memory services but     */
/* have no actual token stream to refer them to. For example, a client */
/* wishing to use the URL relativisation functions for a broken server */
/* redirection may not have a document to refer to, as the redirection */
/* occurs in the HTTP response headers.                                */
/*                                                                     */
/* The caller must, of course, be very careful to free the structures  */
/* this will set up using HtmlStreamFree when the context is no longer */
/* required.                                                           */
/***********************************************************************/

void *HtmlGetContext(void)
{
  return __html_stream_init();
}

/***********************************************************************/
@


1.2.2.10
log
@Removed the GetContext stuff (blimey, that was short lived) - a much better
approach to relativise broken redirections inside the header parsing
routines has been taken (see HtmlIdentify).
@
text
@d40 20
d327 3
a329 3
unsigned int HtmlIdentify(char * base_url, char *stream, size_t stream_len,
                                      char done, char **url,
                                      int *file_type, int *canparse)
d331 1
a331 2
  return __html_identify(base_url, stream, stream_len, done,
                         url, file_type, canparse);
d353 1
a353 1
/* User frontend to __html_free for a specific block                   */
a357 10
}

/***********************************************************************/
/* void *HtmlFreeAll(void *block)                                      */
/***********************************************************************/
/* User frontend to __html_free for all blocks in a given context      */
/***********************************************************************/
void HtmlFreeAll(void *block)
{
    __html_free(block, 1);
@


1.2.2.11
log
@Did align on <P> and right align on tables.
Fixed problem with the final ">" of "</SCRIPT>" ending up in the title.
Fixed problem of HtmlGetStream returning a pointer to the wrong parent table.
Added SUB and SUP.
@
text
@d224 1
a224 2
                !(realcurrent.prev->style & PRE) &&
                realcurrent.prev->tagno != TAG_TEXTAREA)
a254 1
    table_skip_current(NULL);
d269 1
a269 1
  else if (return_val != NULL && return_val->next != NULL && !(flags & HTML_GOT_MORE_IN_A_TABLE))
@


1.2.2.12
log
@Encoding support added (yippee). #define UNIFONT to get UTF-8 output,
otherwise Latin-1 output is provided. Lots of encoding files...
@
text
@d24 1
a24 1
#include "swis.h"
a27 7
#include "encoding.h"
#ifdef UNIFONT
#include "utf8.h"
#endif

static void do_the_funky_on_the_fly_buffer_shuffle_thing(StreamTokens *,
            int, int, char *, char *, char **, char **, char **, int *);
d34 1
d36 2
a37 1
  _swix(Hourglass_Percent, _IN(0), (done*100)/size); }
d48 1
a48 2
void *HtmlParse(char *url, int length, int type, int usingframes,
                int encoding, encoding_priority priority)
a58 17
    st->encoding = new_encoding(st->encoding_no = encoding);
    if (!st->encoding)
    {
        free(st);
        return NULL;
    }
    st->enc_priority = priority;
    st->utf_buffer = malloc(1024);
    if (!st->utf_buffer)
    {
        delete_encoding(st->encoding);
        free(st);
        return NULL;
    }
    st->utf_ptr = st->utf_buffer;
    st->utf_size = 1024;
    st->utf_end = st->utf_buffer + 1024 - 7; /* 6 for a UTF char + 1 for a terminator */
a96 43
static int ucs_out(void *streamtok, UCS4 ucs)
{
    StreamTokens *st = (StreamTokens *)streamtok;

    /* Quick and dirty way of stripping out UCS-2 signature... */
    if (ucs == 0xFEFF)
        return 0;

    if (ucs < 0x20)
    {
        /* HT, LF and CR are only C0 controls valid in HTML */
        if (ucs != 0x0009 && ucs != 0x000A && ucs != 0x000D)
            ucs = 0xFFFD;
    }
    else if (ucs >= 0x007F && ucs < 0x00A0)
    {
        /* No C1 controls valid */
        ucs = 0xFFFD;
    }

    if (st->utf_ptr > st->utf_end)
    {
        int ptr_pos = st->utf_ptr - st->utf_buffer;
        int end_pos = st->utf_end - st->utf_buffer;

        st->utf_buffer = realloc(st->utf_buffer, st->utf_size + 1024);
        if (!st->utf_buffer) return 1;

        st->utf_size += 1024;
        st->utf_end = st->utf_buffer + end_pos + 1024;
        st->utf_ptr = st->utf_buffer + ptr_pos;
    }

    st->chars_read++;
    #ifdef UNIFONT
    st->utf_ptr = UCS4_to_UTF8(st->utf_ptr, ucs);
    #else
    *st->utf_ptr++ = __html_iso10646_to_latin1(ucs);
    #endif

    return 0;
}

d107 1
a107 1
  HStream *return_val, *current, *last_token;
d109 1
a109 3
  char *doc,  *start, *end;
  int utf_chunk_start;
  int old_chars_read;
a113 1
  int n;
d115 4
d135 1
a135 1
  if (!size) return NULL;
d143 1
a143 10
  utf_chunk_start = st->utf_ptr - st->utf_buffer;
  old_chars_read = st->chars_read;
  n = st->encoding->read(st->encoding, ucs_out, *document + st->sizesofar, size, st);
  if (n != size)
  {
      st->dead = 1;
      size = n;
  }
  /* For everyone's convenience... */
  *st->utf_ptr = '\0';
d150 17
a166 4
  doc = start = st->utf_buffer;
  st->sizesofar += size;
  end = st->utf_ptr;
  if (chunksize == 0) chunksize = end - doc;
d189 1
a189 1
        current=return_val=last_token=__html_stream_parse(st, &doc, st->url, size, NULL);
d206 1
a206 2
            *realcurrent.prevnextptr=
            last_token=__html_stream_parse(st, &doc, st->url, size, realcurrent.prev);
a211 1
        {
a212 2
             last_token = NULL;
        }
d242 1
a242 34
      /*
       * Code to deal with "on-the-fly" encoding changes via the
       *    <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
       * construct.
       */
      if (last_token && last_token->tagno == TAG_META &&
          st->enc_priority < priority_meta &&
          HtmlMETAhttp_equiv(last_token) &&
          HtmlMETAcontent(last_token))
      {
          if (strincmp(HtmlMETAhttp_equiv(last_token), "Content-Type", 12) == 0)
          {
              char *p = strinstr(HtmlMETAcontent(last_token), "charset=", 256);
              if (p)
              {
                  int enc;

                  p += 8;
                  while (*p == ' ') p++;

                  enc = encoding_number_from_name(p);
                  if (enc && enc != st->encoding_no)
                  {
                      do_the_funky_on_the_fly_buffer_shuffle_thing
                        (st, enc, old_chars_read, *document,
                         st->utf_buffer + utf_chunk_start,
                         &doc, &start, &end, &chunksize);
                      if (st->encoding_callback)
                          st->encoding_callback(enc, st->encoding_callback_handle);
                  }
              }
          }
      }
      /*if (chunksize >= 1)
d244 1
a244 1
            chunksize);*/
d274 3
a276 3
  /* Copy unused stuff back to bottom of UTF buffer */
  memmove(st->utf_buffer, doc, st->utf_ptr - doc);
  st->utf_ptr = st->utf_buffer + (st->utf_ptr - doc);
d296 1
a296 2
void HtmlStreamFree(void *stream)
{
a298 2
    /*delete_encoding(st->encoding);
    free(st->utf_buffer);*/
d311 1
a311 2
                                      int *file_type, int *canparse,
                                      int *encoding)
d314 1
a314 1
                         url, file_type, canparse, encoding);
a321 5
int HTTPEncodingNumberFromName(const char *name)
{
  return encoding_number_from_name(name);
}

a383 118
static int count_chars(void *h, UCS4 c);
static int count_utf(void *h, UCS4 c);

/*
 * We have just parsed a <META> tag with a encoding selection.
 * Goody. But we have already converted a load of guff with the original
 * encoding, and that is sitting in utf_buffer, and the document pointer
 * has been advanced. We need to rewind the decoder and try again.
 *
 * Here it is in pictures:
 *
 *  document source:
 *
 *  ------------------------------<META xxx>-----------------------------
 *  ^                          ^                                        ^
 *  |                          start of this chunk                      |
 *  *document                                                  *document + st->sizesofar
 *                                                            (end of this chunk)
 *  utf_buffer:
 *
 *  oooz-----<META xxx>------------------.........        (o = left over data from last chunk
 *  ^  ^               ^                 ^       ^         z = a character split between chunks
 *  |  utf_chunk_start doc               |    st->utf_end  . = free space in utf_buffer)
 *  st->utf_buffer                  st->utf_ptr
 *
 * Because of the statefulness of some encodings we really need to rewind
 * all the way back to the start. We have stored in old_chars_read the number
 * of characters (ie converted UCS codes) read up to but not including this
 * chunk. We get the encoder to decode this many characters (discarding contents).
 *
 * We then run the decoder again, until it has generated (doc - utf_chunk_start)'s
 * worth of UTF-8. We can then clear out the UTF-8 buffer, and run the
 * decoder one last time using the standard ucs_out routine.
 *
 * BEWARE!!!! This routine will only work ONCE!!!! You can't have multiple META charset
 * selections!!!
 */
static void do_the_funky_on_the_fly_buffer_shuffle_thing
            (StreamTokens *st,
             int encoding_no,
             int old_chars_read,
             char *document,
             char *utf_chunk_start,
             char **pdoc,
             char **pstart,
             char **pend,
             int *pchunksize
             )
{
    int n;
    unsigned int docpos = 0;

    st->encoding->reset_decoder(st->encoding);
    st->chars_read = 0;

    /* Wind up to "utf_chunk_start" */
    if (old_chars_read)
        docpos += st->encoding->read(st->encoding, count_chars, document, st->sizesofar,
                                     &old_chars_read);

    n = *pdoc - utf_chunk_start;

    /* Wind up to "doc" */
    if (n)
        docpos += st->encoding->read(st->encoding, count_utf, document + docpos,
                                     st->sizesofar - docpos, &n);

    /* Now we clear the utf_buffer */
    st->utf_ptr = st->utf_buffer;

    /* Sort out the encoding */
    st->encoding->delete(st->encoding);
    st->encoding = new_encoding(st->encoding_no = encoding_no);
    st->enc_priority = priority_meta;

    /* And run the decoder for real */
    st->encoding->read(st->encoding, ucs_out, document + docpos,
                       st->sizesofar - docpos, st);

    /* Sort out document pointers for the parser */
    *pstart = *pdoc = st->utf_buffer;
    *pend = st->utf_ptr;
    *pchunksize = *pend - *pdoc;

    /* Put back a terminator */
    *st->utf_ptr = '\0';
}

static int count_chars(void *h, UCS4 c)
{
    int *ip = (int *) h;

    NOT_USED(c);

    return --(*ip) ? 0 : 1;
}

static int count_utf(void *h, UCS4 c)
{
    int *ip = (int *) h;

    #ifdef UNIFONT
    *ip -= UTF8_codelen(c);
    #else
    *ip -= 1;
    #endif

    return *ip > 0 ? 0 : 1;
}


extern void HtmlSetEncodingCallback(void *str, void (*cb)(int, void *), void *handle)
{
    StreamTokens *st = (StreamTokens *) str;

    st->encoding_callback = cb;
    st->encoding_callback_handle = handle;
}
@


1.2.2.13
log
@Bras Direct now works. Woohoo. Doesn't die when loading extremely large
chunks - malloc failures due to a locked flex heap caused problems.
HttpEndParse call added to free up parse related blocks. To solve layout
problems on certain sizes, spacer images (align left or right) which are
less than 2 pixels wide, or are more than 15 times tall than wide, will
be ignored.
@
text
@a119 2
static UCS4 pending_code;

a143 1
        char *newbuf;
d145 2
a146 7
        newbuf = realloc(st->utf_buffer, st->utf_size * 2);
        if (!newbuf)
        {
            pending_code = ucs;
            return 1;
        }
        st->utf_buffer = newbuf;
d148 3
a150 3
        st->utf_end = newbuf + end_pos + st->utf_size;
        st->utf_ptr = newbuf + ptr_pos;
        st->utf_size *= 2;
d182 1
a182 1
  int n, ntotal=0;
a201 3
  utf_chunk_start = st->utf_ptr - st->utf_buffer;
  old_chars_read = st->chars_read;

a206 2
  
retry_with_more_memory:
d208 4
a211 3
  n = st->encoding->read(st->encoding, ucs_out, *document + st->sizesofar, size - ntotal, st);
  ntotal += n;
  if (ntotal != size && n > 0)
d213 2
a214 10
      int r;

      /* We've run out of memory - probably because flex budge had to be off in
       * the encoding routine. Get some more memory and go round again.
       */
      st->sizesofar += n;
      flex_set_budge(1);
      r = ucs_out(st, pending_code);
      flex_set_budge(0);
      if (r == 0) goto retry_with_more_memory;
a218 4
  /* Can put flex budgie back on now because we're not going to look */
  /* at the document source again.                                   */
  flex_set_budge(oldflexstate);

d225 1
a225 1
  st->sizesofar += n;
d376 1
a385 15
}

/***********************************************************************/
/* void HtmlEndParse(void *stream)                                     */
/***********************************************************************/
/* Free all the structures involved in the parsing of a document,      */
/* but not the actual generated token stream, which is freed later     */
/* with HtmlStreamFree.                                                */
/***********************************************************************/
void HtmlEndParse(void *stream)
{
  free(((StreamTokens *) stream)->utf_buffer);
  delete_encoding(((StreamTokens *) stream)->encoding);

  free(stream);
@


1.2.2.14
log
@Turned off CUSTOMER_SPECIAL.
Changed encoding tables to use FFFF as a null value instead of FFFD.
Added OBJECT support (more testing required - PARAM not yet done).
Added AREA support (commented out - MAP not yet done). They come out
looking like <A></A> elements.
Souped up mapping to Latin-1 (added lossy tables for Latin Extended
Additional, CJK Punctuation and Fullwidth forms).
Added support for <H1 align=...>
Stripped some superfluous whitespace caused by linefeeds.
Fixed missing linebreak in "<DT>One<DT>Two" by turning the second DT into
a BR.
Removed now unnecessary free(malloc(16384)) bodge.
Put in CJK code even if UNIFONT not defined (hey - why not?).
Added code to take direct pointer to table rather than loading it if
it's in ResourceFS.
Added support for encoding "x-acorn-latin1".
Ensured correct handling of OPTIONs when UNIFONT not defined.
@
text
@d213 6
a218 3
  /* Turn flex budging off to prevent grief as we read the source document */
  oldflexstate = flex_set_budge(0);

d246 2
d257 10
a266 1
    return_val=current=st->current;
d286 1
a286 4

        realcurrent = __html_find_current_object(st, current);

        realcurrent=table_skip_current(realcurrent);
a374 5
    if (return_val)
    {
        current = return_val;
        while (current->next)
            current = current->next;
a375 2
        st->current = current;
    }
d378 8
a385 6
    table_prev_info dummy = { NULL, NULL };
    table_skip_current(dummy);
    return_val=__html_return_text_token(doc,size);
    if (st->current)
      st->current->next = return_val;
    st->current = return_val;
a632 1
    NOT_USED(c);
@


1.2.2.15
log
@To solve problems with odd position of NOFRAMES, HTMLLib now uses the
Navigator-esque behaviour of ignoring everything after a /FRAMESET,
provided the frameset had at least one FRAME tag inside. This was
mostly for 'http://www.airuk.co.uk/'.
@
text
@d208 1
a208 1
  if (!size || st->dead) return NULL;
@


1.2.2.16
log
@Some pages could be parsed in the context of a previous table - fixed.
Made the 'throw away very tall images' code only do it for images < 6
pixels wide.
@
text
@d275 1
a275 1
        realcurrent=table_skip_current(st, realcurrent);
d375 2
a376 2
    table_skip_current(st, dummy);
    return_val=__html_return_text_token(st, doc, size);
@


1.2.2.17
log
@Added veneers for OBJECT tags in attrvenrs.c, and updated api.h as
appropriate - tidied this so comments appear before the functions they
apply to rather than after (!), and moved HtmlInit to the top, since
it's the first thing you're supposed to call (hence change to veneers.c).

Stripped dependencies out of Makefile prior to checkin.
@
text
@a44 10
/* void HtmlInit(void)                                                 */
/***********************************************************************/
/* User frontend to initialisation routines                            */
/***********************************************************************/
void HtmlInit(void)
{
    __html_rules_init();
}

/***********************************************************************/
d490 10
@


1.2.2.18
log
@Implemented ordered lists.
Implemented <Q> ... </Q>.
Caused a linebreak after </DD>.
Finished implementing attributes for <OBJECT>.
Stopped HTML after a </FRAMESET> leaking through.
Ensured that FRAME and FRAMESET tokens aren't passed up if not using frames.

Removed lots of unnecessary #include "utf8.h" lines from encoding files.
Ensured unsigned constants used in UTF-8 code.
Added UTF8_next and UTF8_prev functions.
@
text
@d264 1
a264 1
    while (doc < end && *doc != '\0' && !st->dead) {
d507 1
a507 1
unsigned int HtmlReturnContext(void *block)
@


1.2.2.19
log
@Fixed links to "./".
Ensured incomplete OBJECTs not returned (I hope).
Stopped newlines being stripped inside PRE.
Made </P> turn off any paragraph alignment.
Added HtmlReplaceOBJECT call.
@
text
@a381 7

    if (st->special_return)
    {
        st->current->next = st->special_return;
        st->current = st->special_return;
        st->special_return = NULL;
    }
a640 5
}

extern HStream *HtmlReplaceOBJECT(HStream *t)
{
    return __html_replace_object(t);
@


1.2.2.20
log
@Previous check-in broke APPLET and OBJECTs inside tables.
Also, /APPLET didn't work (thought I'd fixed this?)
Default border for images now 0 if not a link.
@
text
@d264 1
a264 1
    while (st->special_return || (doc < end && *doc != '\0' && !st->dead)) {
d269 1
a269 1
      if (return_val == NULL && !st->object) {
d383 1
a383 1
    /*if (st->special_return)
d388 1
a388 1
    }*/
@


1.2.2.21
log
@Would often blow up when processing text files.
@
text
@d393 1
a393 2
    return_val=__html_return_text_token(st, doc, end - doc);
    doc=end;
d398 1
@


1.2.2.22
log
@Added EMBED support (creating lookalike OBJECTs).
Removed startup table initialisation, because latest compiler can do it.
@
text
@d51 1
@


1.2.2.23
log
@Added objects flag to HtmlParse
@
text
@d62 1
a62 1
void *HtmlParse(char *url, int length, int type, int usingframes, int usingobjects,
a93 1
    st->usingobjects=usingobjects;
@


1.2.2.24
log
@MAP and AREA handling - first attempt
@
text
@d75 1
a75 2
    st->maps = (MapStream *) __html_malloc(sizeof(MapStream), 1);
    if (!st->encoding || !st->maps)
a76 1
        __html_free(st->maps, 0);
a270 2
        if (st->_stream_map)
            current=return_val=last_token=NULL;
a291 1
            if (st->_stream_map) last_token = NULL;
a304 1
        if (st->_stream_map) current->next = NULL;
@


1.2.2.25
log
@Modified to use external Unicode resources and UnicodeLib.
@
text
@d28 1
a28 1
#include "Unicode/encoding.h"
d30 1
a30 1
#include "Unicode/utf8.h"
d74 1
a74 1
    st->encoding = encoding_new(st->encoding_no = encoding, 0);
d86 1
a86 1
        encoding_delete(st->encoding);
d230 1
a230 1
  n = encoding_read(st->encoding, ucs_out, *document + st->sizesofar, size - ntotal, st);
d438 1
a438 1
  encoding_delete(((StreamTokens *) stream)->encoding);
d588 1
a588 1
    encoding_reset(st->encoding);
d593 2
a594 2
        docpos += encoding_read(st->encoding, count_chars, document, st->sizesofar,
                                &old_chars_read);
d600 2
a601 2
        docpos += encoding_read(st->encoding, count_utf, document + docpos,
                                st->sizesofar - docpos, &n);
d607 2
a608 2
    encoding_delete(st->encoding);
    st->encoding = encoding_new(st->encoding_no = encoding_no, 0);
d612 2
a613 2
    encoding_read(st->encoding, ucs_out, document + docpos,
                  st->sizesofar - docpos, st);
@


1.2.2.26
log
@Added hack to support <FORM> tags between <TABLE> and <TD>
@
text
@d303 1
a303 4
            HStream *t;
            t = __html_stream_parse(st, &doc, st->url, size, current);
            if (t->tagno == TAG_FORM)
                st->pendingformfortable = t;
@


1.2.2.27
log
@Added flag to HtmlParse to turn on or off tables support
@
text
@d62 1
a62 1
void *HtmlParse(char *url, int length, int type, int usingframes, int usingobjects, int usingtables,
a96 1
    st->usingtables=usingtables;
@


1.1
log
@file veneers was initially added on branch ARTtmp.
@
text
@d1 381
@


1.1.2.1
log
@Initial revision
@
text
@a0 325
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source: /ax/networking:Phileas/HTML/c/veneers: $
 *
 * $Log:	veneers,v $
 * Revision 1.4  95/10/30  10:40:08  pwain
 * Removed (#ifdef'ed out) the calls to the quick
 * and long display code.
 *
 * Revision 1.3  95/10/18  10:41:36  pwain
 * Changed calls to __html_*_free() to
 * __html_free(x,1) to ensure that all allocated
 * memory gets zapped.
 *
 * Revision 1.2  95/10/16  08:12:50  pwain
 * Added code to list memory in usage after a call to
 * either __html_stream_free or __html_tree_free
 *
 * Revision 1.1  95/10/12  12:46:53  pwain
 * Initial revision
 *
 *
 * --- Original Log Information ---
 *
 * $Version: networking $
 *
 * $Source: /ax/networking:Phileas/HTML/c/veneers: $
 *
 * $Log:	veneers,v $
 * Revision 1.4  95/10/30  10:40:08  pwain
 * Removed (#ifdef'ed out) the calls to the quick
 * and long display code.
 *
 * Revision 1.3  95/10/18  10:41:36  pwain
 * Changed calls to __html_*_free() to
 * __html_free(x,1) to ensure that all allocated
 * memory gets zapped.
 *
 * Revision 1.2  95/10/16  08:12:50  pwain
 * Added code to list memory in usage after a call to
 * either __html_stream_free or __html_tree_free
 *
 * Revision 1.1  95/10/12  12:46:53  pwain
 * Initial revision
 *
 * Revision 1.2  95/09/11  13:13:05  pwain
 * Fixes. The calls into __html_stream_free were typcasting a HStream to
 * type HTML, causing memory to be corrupted.
 *
 * Revision 1.1  95/09/08  10:06:12  pwain
 * Initial revision
 *
 *
 */

/*
 * These functions are basically remappings to the actual functions used.
 */

#include "api.h"
#include "internal.h"
#include "flex.h"
#include "stdio.h"
#include "kernel.h"


/***********************************************************************/
/* (void) __html_set_hourglass_percent(int done, int size)             */
/***********************************************************************/
/* A small macro to set the hour glass status                          */
/***********************************************************************/
#define Hourglass_Percent 0x406c4
#define __html_set_hourglass_percent(done,size) {\
  r.r[0]=(int)((done*100)/size); \
  _kernel_swi(Hourglass_Percent, &r, &r);}

/***********************************************************************/
/* void *HtmlParse(char *url, int length)                              */
/***********************************************************************/
/* This is the call to set up a new context within which a document is */
/* parsed. The length is the total size of the document and is an      */
/* optional parameter (it is used in place of size in HtmlGetStream to */
/* set the hourglass percentage if it is non-zero), and URL is a       */
/* pointer to the document being parsed. 	    	       	       */
/***********************************************************************/
void *HtmlParse(char *url, int length, int type, int usingframes)
{
   StreamTokens *st;
/* Create a memory context for this URL */
    __html_memory_init();
/* Create the stream context structure */
    st=__html_stream_init();
    if (st == NULL)
        return (void *)st;
/* Fill in the bits known, such as length, memory context and url */
    st->doclength=length; /* If known */
    st->memcontext=__html_memory_context;
    st->url=strdup(url);
    st->type=type;
#ifdef FRAMESUPPORT
    st->usingframes=usingframes;
#endif
/* Return the pointer to the struct as a void * */
    return (void *)st;
}

#ifdef FRAMESUPPORT
static void StripNoframes(HStream *p)
{
  HStream *next;
  
  if (!p)
    return;
    
  /* 
   * Skip one - this is OK because p will either be the very first token (which
   * is infinitely unlikely to be NOFRAMES, or it will be the last tag
   * of a previous parse chunk, hence already checked
   */
  p = p->next;
  
  for ( ; p; p=next)
  {
    next = p->next;
    if (p->type & TYPE_NOFRAMES) {
      p->prev->next = next;
      if (next)
        next->prev = p->prev;
      /*
       * This doesn't free associated data in the token, but it will get
       * freed eventually when HtmlFreeStream is called. Should be sorted.
       */
      __html_free(p, 0);
      
    }
  }
}
#endif

/***********************************************************************/
/* HStream *HtmlGetStream(void *streamtok, char **document, int size)  */
/***********************************************************************/
/* Attempt to parse an additional "size" bytes of the "document" using */
/* the context pointed too in "streamtok". This allows documents to be */
/* parsed as they come in off the wire.	   	       		       */
/***********************************************************************/

HStream *HtmlGetStream(void *streamtok, char **document, int size) {
  HStream *return_val, *current;
  StreamTokens *st = (StreamTokens *)streamtok;
  char *doc,  *start, *docstart, *end;
  int chunksize=st->doclength;
  int oldflexstate;

#ifdef OLDCODE
  int todo=size;
#endif
  _kernel_swi_regs r;
#ifdef TRACE
{
    FILE *fp=fopen("ADFS::4.$.Trace.ParseIn", "a");
    if (fp)
    {
        int t;
        fprintf(fp, "HtmlGetStream(%p, %d)\n", streamtok, size);
        t=size;
        if (st->done < st->sizesofar)
            t+=st->sizesofar - st->done;
        fwrite(doc+st->done, t, 1, fp);
        fclose(fp);
    }
}
#endif

  if (!size) return (HStream *)size;

  /* Yuckery! Give us 16K of free space by shifting flex stuff, then lock the
     flex stuff */
  oldflexstate = flex_set_budge(1);
  free(malloc(16384));
  flex_set_budge(0);

  doc=start=docstart=*document;

/* Set up our environment first */
  __html_memory_context=st->memcontext;

  current=st->Stream;

  if (st->done != 0) {
/* We have already done some parsing so update doc and size appropriatly */
    int  newsize = size;
    doc += st->done;
    start=doc;
    if (st->done < st->sizesofar) {
      newsize += st->sizesofar - st->done;
    }
    st->sizesofar += size;
    size = newsize;
  }
  else {
    st->sizesofar += size;
  }
  end=*document+st->sizesofar;

  if (chunksize==0) chunksize=size;

/* Now parse the document */
  if (st->type == TYPE_HTMLFILE) {
/* HTML Parser */
    
    if (current == NULL) {
      current=return_val=__html_stream_parse(st, &doc, st->url, size);
    }
    else {
      while (current->next != NULL) current=current->next;
      return_val=current;
    }
    
    while (doc < end && *doc != '\0') {
      char *olddoc = doc;
      size=chunksize-(doc-start);
      /* Fail safe for badly terminated strings */
      if ((size<1) || __html_done_for_now) break;
      if (return_val == NULL) {
        current=return_val=__html_stream_parse(st, &doc, st->url, size);
        if (current == NULL && doc == olddoc)
            __html_done_for_now = 1;
      }
      else {
        current->next=__html_stream_parse(st, &doc, st->url, size);
        if (current->next != NULL) {
            current->next->prev = current;
            current=current->next;
        }
        else if (doc == olddoc)
            __html_done_for_now = 1;
      }
      if (chunksize >= 1)
        __html_set_hourglass_percent((int)(doc-start),
            chunksize);
      /*if (doc == olddoc && current == NULL)
        break;*/
    }
    __html_done_for_now=0;
    
    #ifdef FRAMESUPPORT
    if (st->usingframes)
      StripNoframes(return_val);
    #endif


  }
  else { /* plain text */
    if (current == NULL) {
      current=return_val=__html_return_text_token(doc,size);
    }
    else {
      while (current->next != NULL) current=current->next;
      return_val=current->next=__html_return_text_token(doc,size);
    }
    doc+=size;
  }

/* Preserve the start of the stream for us */
  if (st->Stream==NULL) st->Stream=return_val;
  else if (return_val != NULL) return_val=return_val->next;

/* and make a note of how much we have done */
  st->done=(doc-docstart);
  if (st->done > st->sizesofar) st->done=st->sizesofar;

  flex_set_budge(oldflexstate);

/*
 * Return the pointer to the complete stream or the element which
 * we added if the stream already existed.
 */
  return return_val;
}

/***********************************************************************/
/* void HtmlStreamFree(void *stream)                                   */
/***********************************************************************/
/* Small entry point to free up all the memory associated with a       */
/* stream (even if the stream was created with multiple parses.	       */
/***********************************************************************/
void HtmlStreamFree(void *stream) {
    if (stream==NULL) return;
    __html_free(stream, 1);
    __html_memory_list();
}

int HttpStripHeaders(char *stream, size_t stream_len)
{
  return __http_strip_headers(stream, stream_len);
}

unsigned int HtmlIdentify(char *stream, size_t stream_len, char done,
       		    		      char **url, int *file_type,
       		    		      int *canparse)
{
  return __html_identify(stream, stream_len, done, url, file_type, canparse);
}

char *HTTPEscapeString(char *string)
{
  return __http_escape_string(string);
}
@


1.1.2.2
log
@Spacing rules drastically improved. Major error in memory context handling
fixed. Bug in __html_strip_lf fixed.
@
text
@d19 1
a19 5
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/veneers,v $
 *
 * $Log: veneers,v $
 * Revision 1.1.2.1  1997/04/08 10:26:50  kbracey
 * Initial revision
d21 1
d43 1
a43 5
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/veneers,v $
 *
 * $Log: veneers,v $
 * Revision 1.1.2.1  1997/04/08 10:26:50  kbracey
 * Initial revision
d45 1
a79 1
#include <string.h>
d105 2
d113 1
a113 2
/* Create a memory context for this URL */
    st->memcontext=__html_memory_init();
d127 1
a127 1

d130 2
a131 2

  /*
d137 1
a137 1

d150 1
a150 1

d202 1
a202 1
  __html_set_memory_context(st->memcontext);
d227 1
a227 1

d229 1
a229 1
      current=return_val=__html_stream_parse(st, &doc, st->url, size, NULL);
d235 1
a235 1

d242 1
a242 1
        current=return_val=__html_stream_parse(st, &doc, st->url, size, NULL);
d247 1
a247 2
        st->isendtag=0;
        current->next=__html_stream_parse(st, &doc, st->url, size, current);
a248 12
#ifdef NEWSPACING
            if ((st->isendtag) && current && current->text && current &&
                !(current->style & (PRE|TEXTAREA)))
            {
                int s=strlen(current->text);
                if (s > 0)
                {
                    if (current->text[s-1]==' ')
                        current->text[s-1]='\0';
                }
            }
#endif
d262 1
a262 1

a306 1
#ifdef MEMORY_DEBUG
a307 1
#endif
@


1.1.2.3
log
@Added in Tony Cheal's table code. Various other bug fixes.
@
text
@a21 4
 * Revision 1.1.2.2  1997/04/09 16:44:39  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
a48 4
 * Revision 1.1.2.2  1997/04/09 16:44:39  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
d88 1
a88 3
#ifdef TonyTables
#include "HTMLTables.h"
#endif
d170 1
a170 2
HStream *HtmlGetStream(void *streamtok, char **document, int size, unsigned int *flags)
{
a252 15
        #ifdef TonyTables
        /*
         * if there are incomplete tables, then you link somewhere different
         * also table-stuff needs a bit of context in order to operate properly
         */
        HStream **realcurrent;
        realcurrent=table_skip_current(current);

        st->isendtag=0;
        if (realcurrent != NULL)
            *realcurrent=__html_stream_parse(st, &doc, st->url, size, current);
        else
             __html_stream_parse(st, &doc, st->url, size, current);
        /* effect is to skip anything before valid <tr><td> e.g. junk<tr>junk<td> */
        #else
a254 1
        #endif
d301 2
a302 4
  if (st->Stream==NULL)
      st->Stream=return_val;
  else if (return_val != NULL && return_val->next != NULL)
      return_val=return_val->next;
@

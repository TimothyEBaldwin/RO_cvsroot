head	1.23;
access;
symbols
	HTMLLib-0_04:1.23
	HTMLLib-0_03:1.23
	HTMLLib-0_02:1.23
	HTMLLib-0_01:1.22
	ahodgkin_207release:1.19
	ahodgkin_206release:1.10
	ahodgkin_205release:1.3
	ahodgkin_204release:1.3
	ahodgkin_133beta:1.2.2.57
	kbracey_126:1.2.2.42
	kbracey_AW97patch:1.2.2.41
	ahodgkin_AW97:1.2.2.40
	kbracey_PreGordon:1.2
	Web_bp:1.2
	Web:1.2.0.2
	ARTtmp_merge:1.1.2.3
	ARTtmp:1.1.0.2;
locks; strict;
comment	@# @;


1.23
date	2006.03.13.21.10.18;	author ahodgkin;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.02.15.53.17;	author ahodgkin;	state Exp;
branches;
next	1.21;

1.21
date	99.06.04.14.51.22;	author ahodgkin;	state Exp;
branches;
next	1.20;

1.20
date	98.11.05.14.38.50;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	98.10.08.17.29.35;	author ahodgkin;	state Exp;
branches;
next	1.18;

1.18
date	98.10.07.11.06.13;	author ahodgkin;	state Exp;
branches;
next	1.17;

1.17
date	98.09.22.12.40.53;	author ahodgkin;	state Exp;
branches;
next	1.16;

1.16
date	98.09.10.15.54.02;	author ahodgkin;	state Exp;
branches;
next	1.15;

1.15
date	98.09.10.11.55.15;	author ahodgkin;	state Exp;
branches;
next	1.14;

1.14
date	98.08.29.16.15.47;	author ahodgkin;	state Exp;
branches;
next	1.13;

1.13
date	98.08.24.11.48.40;	author ahodgkin;	state Exp;
branches;
next	1.12;

1.12
date	98.08.18.08.47.44;	author ahodgkin;	state Exp;
branches;
next	1.11;

1.11
date	98.08.07.11.30.02;	author ahodgkin;	state Exp;
branches;
next	1.10;

1.10
date	98.07.06.14.07.36;	author ahodgkin;	state Exp;
branches;
next	1.9;

1.9
date	98.07.01.08.40.38;	author ahodgkin;	state Exp;
branches;
next	1.8;

1.8
date	98.06.16.15.36.33;	author ahodgkin;	state Exp;
branches;
next	1.7;

1.7
date	98.05.15.13.32.44;	author kbracey;	state Exp;
branches;
next	1.6;

1.6
date	98.05.08.13.52.37;	author kbracey;	state Exp;
branches;
next	1.5;

1.5
date	98.05.08.11.34.05;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	98.05.07.15.03.44;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	98.02.17.10.42.17;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	97.04.29.15.50.47;	author kbracey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.08.10.26.45;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

1.2.2.1
date	97.06.24.11.19.29;	author kbracey;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	97.06.25.08.04.11;	author kbracey;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	97.06.26.11.02.47;	author kbracey;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	97.06.30.09.10.34;	author kbracey;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	97.07.02.08.39.39;	author kbracey;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	97.07.02.09.05.55;	author gthorbur;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	97.07.02.16.01.56;	author kbracey;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	97.07.02.17.14.47;	author kbracey;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	97.07.03.13.37.23;	author kbracey;	state Exp;
branches;
next	1.2.2.10;

1.2.2.10
date	97.07.03.13.57.46;	author kbracey;	state Exp;
branches;
next	1.2.2.11;

1.2.2.11
date	97.07.04.11.55.11;	author kbracey;	state Exp;
branches;
next	1.2.2.12;

1.2.2.12
date	97.07.04.14.54.05;	author kbracey;	state Exp;
branches;
next	1.2.2.13;

1.2.2.13
date	97.07.24.16.20.54;	author kbracey;	state Exp;
branches;
next	1.2.2.14;

1.2.2.14
date	97.07.24.16.56.25;	author kbracey;	state Exp;
branches;
next	1.2.2.15;

1.2.2.15
date	97.07.28.15.19.54;	author kbracey;	state Exp;
branches;
next	1.2.2.16;

1.2.2.16
date	97.07.30.12.09.30;	author kbracey;	state Exp;
branches;
next	1.2.2.17;

1.2.2.17
date	97.07.31.13.30.02;	author ahodgkin;	state Exp;
branches;
next	1.2.2.18;

1.2.2.18
date	97.08.01.09.00.02;	author kbracey;	state Exp;
branches;
next	1.2.2.19;

1.2.2.19
date	97.08.01.15.06.31;	author kbracey;	state Exp;
branches;
next	1.2.2.20;

1.2.2.20
date	97.08.12.11.22.44;	author kbracey;	state Exp;
branches;
next	1.2.2.21;

1.2.2.21
date	97.08.12.12.24.15;	author ahodgkin;	state Exp;
branches;
next	1.2.2.22;

1.2.2.22
date	97.08.18.16.13.28;	author kbracey;	state Exp;
branches;
next	1.2.2.23;

1.2.2.23
date	97.08.18.16.25.51;	author kbracey;	state Exp;
branches;
next	1.2.2.24;

1.2.2.24
date	97.09.12.09.12.30;	author ahodgkin;	state Exp;
branches;
next	1.2.2.25;

1.2.2.25
date	97.09.18.14.11.27;	author kbracey;	state Exp;
branches;
next	1.2.2.26;

1.2.2.26
date	97.09.18.15.30.09;	author ahodgkin;	state Exp;
branches;
next	1.2.2.27;

1.2.2.27
date	97.09.25.16.50.37;	author ahodgkin;	state Exp;
branches;
next	1.2.2.28;

1.2.2.28
date	97.09.30.14.13.42;	author kbracey;	state Exp;
branches;
next	1.2.2.29;

1.2.2.29
date	97.10.02.14.48.12;	author kbracey;	state Exp;
branches;
next	1.2.2.30;

1.2.2.30
date	97.10.03.09.29.13;	author kbracey;	state Exp;
branches;
next	1.2.2.31;

1.2.2.31
date	97.10.03.14.16.59;	author kbracey;	state Exp;
branches;
next	1.2.2.32;

1.2.2.32
date	97.10.03.16.08.42;	author ahodgkin;	state Exp;
branches;
next	1.2.2.33;

1.2.2.33
date	97.10.06.13.50.37;	author kbracey;	state Exp;
branches;
next	1.2.2.34;

1.2.2.34
date	97.10.06.15.17.42;	author ahodgkin;	state Exp;
branches;
next	1.2.2.35;

1.2.2.35
date	97.10.08.12.33.39;	author kbracey;	state Exp;
branches;
next	1.2.2.36;

1.2.2.36
date	97.10.09.10.49.49;	author ahodgkin;	state Exp;
branches;
next	1.2.2.37;

1.2.2.37
date	97.10.13.10.01.25;	author kbracey;	state Exp;
branches;
next	1.2.2.38;

1.2.2.38
date	97.10.14.13.40.59;	author kbracey;	state Exp;
branches;
next	1.2.2.39;

1.2.2.39
date	97.10.14.14.48.28;	author kbracey;	state Exp;
branches;
next	1.2.2.40;

1.2.2.40
date	97.10.15.21.00.51;	author ahodgkin;	state Exp;
branches;
next	1.2.2.41;

1.2.2.41
date	97.10.22.14.21.57;	author kbracey;	state Exp;
branches;
next	1.2.2.42;

1.2.2.42
date	97.10.27.18.21.41;	author kbracey;	state Exp;
branches;
next	1.2.2.43;

1.2.2.43
date	97.11.11.14.32.44;	author ahodgkin;	state Exp;
branches;
next	1.2.2.44;

1.2.2.44
date	97.11.13.14.32.47;	author ahodgkin;	state Exp;
branches;
next	1.2.2.45;

1.2.2.45
date	97.11.13.17.50.54;	author ahodgkin;	state Exp;
branches;
next	1.2.2.46;

1.2.2.46
date	97.11.14.09.51.04;	author kbracey;	state Exp;
branches;
next	1.2.2.47;

1.2.2.47
date	97.11.14.15.43.15;	author kbracey;	state Exp;
branches;
next	1.2.2.48;

1.2.2.48
date	97.11.25.11.20.45;	author ahodgkin;	state Exp;
branches;
next	1.2.2.49;

1.2.2.49
date	97.12.17.21.38.10;	author ahodgkin;	state Exp;
branches;
next	1.2.2.50;

1.2.2.50
date	98.01.07.15.31.15;	author ahodgkin;	state Exp;
branches;
next	1.2.2.51;

1.2.2.51
date	98.01.09.16.31.07;	author ahodgkin;	state Exp;
branches;
next	1.2.2.52;

1.2.2.52
date	98.01.13.11.43.32;	author ahodgkin;	state Exp;
branches;
next	1.2.2.53;

1.2.2.53
date	98.01.13.12.16.09;	author kbracey;	state Exp;
branches;
next	1.2.2.54;

1.2.2.54
date	98.01.15.13.26.51;	author ahodgkin;	state Exp;
branches;
next	1.2.2.55;

1.2.2.55
date	98.02.02.16.15.06;	author ahodgkin;	state Exp;
branches;
next	1.2.2.56;

1.2.2.56
date	98.02.05.11.25.45;	author ahodgkin;	state Exp;
branches;
next	1.2.2.57;

1.2.2.57
date	98.02.16.11.45.01;	author ahodgkin;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.08.10.26.46;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.04.09.16.44.37;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	97.04.28.14.20.19;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.23
log
@  New build variants; minor API tweaks; const/restrict additions.
Detail:
  Builds Unicode versions as well as non-Unicode versions now, and
  exports them. Required by March 2006 era Browse sources. API tweaks
  including filling in more info fields with border widths. Tightened
  up use of const/restrict in various interfaces.
Admin:
  Tested under Browse, new facilities work as expected. Builds all
  four variants (non-Unicode/Unicode, application/module) from clean
  and returns to clean state with !MkClean.

Version 0.02. Tagged as 'HTMLLib-0_02'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <assert.h>
#include <stdio.h>     /* For NULL etc */
#include <ctype.h>
#include "html2_ext.h" /* For the HTML bits */
#include "tags.h"      /* for PCDATA */
#include "struct.h"    /* For the structures */
#include "string.h"    /* For string handling */
#include "internal.h"  /* predefinitions of functions */
#include "elementinf.h"
#ifdef TonyTables
#include "HTMLTables.h"
#endif

/******************************************************************************/
/* This comment is 80 chars wide. It was used to format this file.            */
/******************************************************************************/

/********************************************************************/
/* Predefinition of static functions contained in this file, along  */
/* along with the main parse function predifinition.   	     	    */
/********************************************************************/
static    HStream * __html_stream_start_tag(StreamTokens *st, Tag *next_tag,
                              char **html,char *url, int size);
static       void   __html_stream_cancel_align(StreamTokens *st);
static    HStream * __html_stream_end_tag(StreamTokens *st, Tag *next_tag,
                              char **html, char *url, int size);
static    HStream * __html_stream_end_form(StreamTokens *st, char **html);
static    HStream * __html_stream_image(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_q(StreamTokens *st, char **html,
                              int start);
static    HStream * __html_map_handler(StreamTokens *st);
static    HStream * __html_stream_area(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_hr(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_anchor(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_add_anchor_to_map(StreamTokens *st,
                              char **html, Tag *next_tag);
static    HStream * __html_stream_frame(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_frameset(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_base(StreamTokens *st);
static        void  __html_stream_end_anchor(StreamTokens *st);
#if 0
static    HStream * __html_stream_end_header(char **html);
#endif
static    HStream * __html_form_handler(StreamTokens *st, Tag *next_tag,
                              char **html, int size);
/*static*/HStream * __html_stream_return_tag(StreamTokens *st, Tag *tag,
                              char **html, int start);
static 	     char * __html_stream_grab_pcdata(char **input,
                              int contig, int after_tag);
/*static*/   char * __html_make_anchor(char *base, char *link);
/*static*/         void __html_stream_free_anchor(AnchorInfo **anchor);
static    HStream * __html_form_parse_select(StreamTokens *, char **html,
                              int size, HStream *ret);
static    HStream * __html_stream_declaration(StreamTokens *st, char **html,
                                              int size);
//static    HStream * __html_stream_comment(StreamTokens *st, char **html,
//                                          int size);
static    HStream * __html_stream_script(StreamTokens *st, char **html,
                                             int size, const char *term, tag_no tagno);
static void parse_rowcols (char *ptr, unsigned int *values, unsigned int *number);
static char *__html_skip_record_end(const char *s, int strip_leading);

/********************************************************************/
/* A global variable declared in this file. A byte is an unsigned   */
/* char.    	     	      	      	      	      	 	    */
/********************************************************************/
byte __html_done_for_now=0;

/********************************************************************/
/* A small macro. Set a parser internal flag for some exit states.  */
/* This permits on the fly HTML parsing to work correctly. 	    */
/********************************************************************/
#define RETURN(x) {__html_done_for_now=1; return x;}

/********************************************************************/
/* HStream *__html_stream_parse(StreamTokens *st, char **html, .... */
/********************************************************************/
/* The main parse routine. This does one of three things:           */
/*     + Grabs the next bit of text on the input stream		    */
/*     + interprets the top HTML tag on the input stream	    */
/*     + nothing because there is insufficient input (on the fly    */
/*          parsing needs this).  	       	     	     	    */
/*	    	    	  					    */
/* In the first two cases the input pointer is updated to where we  */
/* got to, in the last case, __html_done_for_now is set and the     */
/* input pointer is not moved. 			    	    	    */
/********************************************************************/
HStream *__html_stream_parse(StreamTokens *st, char **html, char *url,
                             int size, HStream *prevhs)
{
  HStream *return_val=NULL;
  Tag     *next_tag;
  char    *ptr;
  char 	  *tag_start;
  char 	  *start;
  int     lastwaspcdata=st->lastwaspcdata;
  int     len;

/* Reset the bail out pointer */
  __html_done_for_now=0;

  if (st->special_return)
  {
      return_val = st->special_return;
      st->special_return = NULL;
      return return_val;
  }

/* Look to make sure we have a valid input pointer. Order is important here */
  if (!html || !*html || !**html) RETURN(NULL);

  switch (st->state)
  {
    case Declaration:
    {
      return __html_stream_declaration(st, html, size);
    }
//    case Comment:
//      return __html_stream_comment(st, html, size);

    /* Don't handle SCRIPT or STYLE at the moment, but lets parse over it */
    /* - don't do NOSCRIPT either, let the browser write that if it wants */

    case Script:
    {
      return __html_stream_script(st, html, size, "</SCRIPT>", TAG_SCRIPT);
    }
    case NoScript:
    {
      return __html_stream_script(st, html, size, "</NOSCRIPT>", TAG_NOSCRIPT);
    }

    case Style:
    {
      return __html_stream_script(st, html, size, "</STYLE>", TAG_STYLE);
    }
    /* Fall through if other */
  }

/* In some cases a '>' is left at the beginning of the input stream. Ignore it */
  if (**html == '>') {
/* If we ignore it, update the input pointer and the size */
    *html = *html+1;
    size--;
/* If we now have nothing left, return */
    if ((size==0) || (!**html)) RETURN((HStream *)NULL);
/* Always keep ptr in sync with HTML */
  }

  ptr=*html;
  tag_start=*html+1;
  start=*html;

/*
 * The first case. We dont have a '<' as the top of the input stream
 * and we are not inside a comment, so grab up to the next tag or the
 * end of the input stream, whichever is the sooner, and return it as
 * a text segment (PCDATA).
 */
  if (*ptr != '<') {

/* This avoids a few funnies. Cant remember why but it is needed */
    if (**html == '>') {
      *html += 1;
      size --;
    }

/* Create the structure to return. If non-NULL fill it in */
    return_val=HStreamalloc(st, (tag_no)0);
    if (return_val != NULL) {
/* Grab the text, and set the style word in the structure */
      return_val->text=__html_stream_grab_pcdata(html, 0, 0);
      if (st->_stream_title)
          return_val->tagno = TAG_TITLE;
      else
          return_val->style=__html_stream_style(st) | PCDATA ;
/*
 * If the text is PREformatted or in a textarea in a form we dont want
 * to strip out the LFs, but we do need to unescape it
 */
      if ((return_val->style & PRE) == PRE ||
      	   return_val->tagno == TAG_TEXTAREA) {
        __html_strip_lfs(return_val->text); /* Strip CRs, preserve LFs */
        __html_unescape_string(return_val->text, 0);
      } else {
/*
 * Otherwise it is true PCDATA so we need to munge spaces, CRs, LFs, and
 * unescape escape sequences in the data
 */
#ifdef NEWSPACING
        st->stripleadingspace = __html_strip_spaces(return_val->text, st->stripleadingspace, 0);
        st->lastwaspcdata = 1;
#else
        __html_strip_spaces(return_val->text, st->stripleadingcr);
#endif
        __html_unescape_string(return_val->text, 0);
      }

/*
 * Now evaluate the type word. We need this to decide what to do if there
 * is a NULL input string left at this point.
 */
      return_val->type=__html_stream_type(st, TYPE_BODY, START);

      /*if (return_val->style & DL)
         Printf("HTMLLib: Got a DL\n");*/
/* Look to see if we have a zero length return string */
      if (*(return_val->text) == '\0') {
/*
 * If the tag is not a special once-only tag,
 * dump the tag to save memory in the
 * final stream returned.
 */
      if (!(return_val->style & (P|BR|DL|UL))) {
/*
 * We only need to free the text and the structure since we havent filled
 * in any other bits, so this is faster than calling the free routine. And
 * return a NULL pointer because we dont need to do anything. 'html' has
 * already been moved at this point, so this is safe.
 */
          __html_free(return_val->text,0);
          __html_free(return_val,0);
          /*if (return_val->style & DL)
            Printf("HTMLLib: Junked a DL :-(\n");*/
          return NULL;
        }
        else {
/* Otherwise just free up the text and set the text pointer to a NULL */
          __html_free(return_val->text,0);
          return_val->text=NULL;
          /*if (return_val->style & DL)
            Printf("HTMLLib: Cleared a DL\n");*/
        }
      }

/* Calculate the list indent count */
      return_val->indent=__html_stream_indent(st);

/* If this tag has anchor information associated with it, extract it */
      if (st->_stream_anchor != NULL) {
        return_val->anchor=st->_stream_anchor->href;
        #ifdef CUSTOMER_SPECIAL
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
        return_val->name=st->_stream_anchor->name;
        return_val->coords=st->_stream_anchor->coords;
        st->need_to_send_name=0;
        return_val->target = st->_stream_anchor->target;
      }

/* Fill in colour information */
      fill_in_colour_info(st, return_val);

/* Set the rest of the values up as a TEXT token */
      return_val->tag=PCDATA;
      memset(st->needtosend, 0, sizeof st->needtosend);
      #ifdef NEWSPACING
      /*st->stripleadingspace=0;*/
      #else
      st->stripleadingcr=0;
      #endif
    }

  #ifdef TRACE
  {
      FILE *fp=fopen("ADFS::4.$.Trace.ParseTrc", "a");
      if (fp)
      {
          fputs(return_val->text, fp);
          fclose(fp);
      }
  }
  #endif
/*
 * Return the structure. Note that if there was insufficient memory to
 * allocate a tag, this will return a NULL pointer, so this is safe.
 */
    //if (return_val->style & DL) Printf("HTMLLib: returned a DL\n");

    return return_val;
  }

  if (size < 2)
      RETURN(NULL);

  /* Stop doing any titleness */
  st->_stream_title=0;

  if (*(ptr+1) == '!')
  {
      st->state = Declaration;
      *html = ptr+2;
      return NULL;
  }

  #ifdef NEWSPACING
  st->lastwaspcdata=0;
  #endif

/*
 * We now think we have a tag. We extract the tag information by skipping
 * the initial '<', finding the end of the tag, and inspecting the bit
 * between the start and end pointers (*html and ptr).
 */

 len = __html_tag_length(ptr);
 if (len == -1)
     RETURN(NULL);

 ptr += len;

#if 0
  ptr++; /* Skip the '<' */
 {
  int quoted = 0;

  while (ptr-start < size && *ptr != '\0' && !(quoted == 0 && (*ptr == '>' || *ptr == '<')))
  {
    if (*ptr == '\'')
    {
      if (quoted == '\'') quoted = 0; else if (quoted == 0) quoted = '\'';
    }
    else if (*ptr == '"')
    {
      if (quoted == '"') quoted = 0; else if (quoted == 0) quoted = '"';
    }
    ptr++;
  }
 }

  if (*ptr == '>')
    ptr++;
#endif

/* This code breaks if there happens to be a '>' in the first byte
 * after the meaningful data
 */
#if 0
/*
 * If we hit 'size' but the first element in the stream is a '<'
 * I think we have an incomplete tag, otherwise if we have moved
 * more than 'size' bytes we have run off the end of a meaningful
 * input stream.
 */
  if (ptr-start >= size) {
    if ( ((**html == '<') && (*ptr != '>')) || (ptr-start > size) ) {
      RETURN(NULL);
    }
  }
#else
  if (ptr-start >= size)
  {
      RETURN(NULL);
  }
#endif

/*
 * We are now in a safe position to believe we have a tag and that we
 * have all of the tag. Thus we can look to see what we have.
 */

  if (tag_start[0]=='/')
  {
    if (lastwaspcdata && prevhs && prevhs->text && prevhs->tag == PCDATA)
    {
      __html_strip_trailing_spaces(prevhs->text);
      if (prevhs->text[0]=='\0')
      {
        __html_free(prevhs->text, 0);
        prevhs->text=0;
        prevhs->type &=~ TYPE_MASK;
        /*prevhs->type=(prevhs->type &~ (TYPE_BODY|TYPE_FRAMESET|TYPE_NOFRAMES)) | TYPE_HEAD;*/
      }
    }
  }
  else
    st->stripleadingspace=1;

  if (tag_start[0] != '/')
  {
      next_tag=__html_find_tag(&tag_start,0);

    /* The start tag case */
      if (next_tag) {
    /*
     * If the tag we have is a tag that we need to notify the termination
     * of, then send back a NULL tag that terminates all the tags we need
     * to before returning this tag. We can do this by not moving the html
     * data pointer before returning.
     */
        if (st->needtosend[next_tag->tag_no] && next_tag->tag_no
    #ifdef TonyTables
            && !st->current_table
    #endif
           )
        {
            /* Put in a null tag (ish) */
            return_val=__html_stream_return_tag(st, &Null_Tag, NULL, END);
            return_val->type|=TYPE_BODY;
            return_val->tagno = TAG_DUMMY;
            /*return_val->style |= DUMMY;*/
        }
        else
        {
            char *p=*html;
    /*
     * Otherwise do what we need to with this pointer before returning
     * any token that it generates.
     */
          if (lastwaspcdata && next_tag->block_tag && prevhs && prevhs->text)
          {
            __html_strip_trailing_spaces(prevhs->text);
            if (prevhs->text[0]=='\0')
            {
              __html_free(prevhs->text, 0);
              prevhs->text=0;
            }
          }

          return_val = __html_stream_start_tag(st, next_tag, &p, url, size);
          /* More hackery - some tags swallow PCDATA - if the routine returns
             NULL, that indicates a tag that needs more PCDATA */
          if (p>ptr)
            *html=p;
          else if (p!=NULL)
            *html=ptr;

          /* Take off any RE (line feed) following a start tag */
          if (!st->_stream_pre || next_tag->tag_no == TAG_PRE || next_tag->tag_no == TAG_XMP || next_tag->tag_no == TAG_TEXTAREA)
              *html = __html_skip_record_end(*html, next_tag->tag_no != TAG_PRE && next_tag->tag_no != TAG_XMP && next_tag->tag_no != TAG_TEXTAREA);
        }
        return return_val;
      }
  }
  else
  {
      st->isendtag=1;
    /* Otherwise it was an end tag? */
      next_tag=__html_find_tag(&tag_start,1);

      if (next_tag) {
    /* Register that we have an end tag */
        st->stripleadingspace=next_tag->block_tag;
        return_val = __html_stream_end_tag(st, next_tag, html, url, size);
        *html=ptr;
        if (next_tag->block_tag && !st->_stream_pre)
            *html = __html_skip_record_end(*html, 1);

       return return_val;
      }
      else
        st->stripleadingspace=1;
  }

/* Update the pointer and return. This skips unwanted tags etc. */

  *html=ptr;

  return return_val;
}

/********************************************************************/
/* __html_stream_declaration                                        */
/********************************************************************/
/* Called instead of __html_stream_parse when inside a <!  > pair   */
/********************************************************************/
static HStream *__html_stream_declaration(StreamTokens *st, char **html,
                                          int size)
{
    /*
     * Currently we don't do anything with declarations. Just need
     * to skip comments
     */

    char *ptr = *html;

    while (size)
    {
//        if (*ptr == '>')
//        {
//            *html = ptr + 1;
//            st->state = Other;
//            return NULL;
//        }

        if      (*ptr == '<') st->anglecount++;
        else if (*ptr == '>') st->anglecount--;

        /* Count < and > pairs, but allow the comment close '-->' */
        /* to forcibly end the comment section.                   */

        if (
             st->anglecount < 0 ||
             (
               size >= 3         &&
               *ptr == '-'       &&
               *(ptr + 1) == '-' &&
               *(ptr + 2) == '>'
             )
           )
        {
            int inc = (*ptr == '-') ? 3 : 1;

            st->anglecount = 0;
            st->state      = Other;

            if (!st->_stream_pre)
                *html = __html_skip_record_end(ptr + inc, 1);
            else
                *html = ptr + inc;
            return NULL;
        }

//        if (*ptr == '-')
//        {
//            if (size < 2)
//            {
//                *html = ptr;
//                RETURN(NULL);
//            }
//            if (*(ptr+1) == '-')
//            {
//                int i;
//
//                /* Check for a run of -s */
//                for (i=2; i<size; i++)
//                {
//                    if (ptr[i] != '-')
//                    {
//                        *html = ptr+i;
//                        st->state = Comment;
//                        return NULL;
//                    }
//                }
//                /* Have not reached the end of this run yet */
//                *html = ptr;
//                RETURN(NULL);
//            }
//        }

        ptr++;
        size--;
    }

    *html=ptr;
    RETURN(NULL);
}

// /********************************************************************/
// /* __html_stream_comment                                            */
// /********************************************************************/
// /* Called instead of __html_stream_parse when inside a -- -- pair   */
// /********************************************************************/
// static HStream *__html_stream_comment(StreamTokens *st, char **html,
//                                       int size)
// {
//     char *ptr = *html;
//     while (size)
//     {
//         if (*ptr == '-')
//         {
//             if (size < 2)
//             {
//                 *html = ptr;
//                 RETURN(NULL);
//             }
//             if (*(ptr+1) == '-')
//             {
//                 int i;
//
//                 /* Check for a run of -s */
//                 for (i=2; i<size; i++)
//                 {
//                     if (ptr[i] != '-')
//                     {
//                         *html = ptr+i;
//                         st->state = Declaration;
//                         return NULL;
//                     }
//                 }
//                 /* Have not reached the end of this run yet */
//                 *html = ptr;
//                 RETURN(NULL);
//             }
//         }
//         ptr++;
//         size--;
//     }
//
//     *html = ptr;
//     RETURN(NULL);
// }

/********************************************************************/
/* static unsigned int __html_stream_style(void)                    */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

unsigned int __html_stream_style(StreamTokens *st)
{
  unsigned int return_val=0;

  /*
  if (st->_stream_title) {
    return_val |= TITLE;
  }
  else {
  */
    if (st->_stream_bold)           return_val |= BOLD;
    if (st->_stream_italic)         return_val |= ITALIC;
    if (st->_stream_tt)             return_val |= TT;
    if (st->_stream_a)              return_val |= A;
    if (st->_stream_img)            return_val |= IMG;
    if (st->_stream_nobr)           return_val |= NOBR;
    if (st->_stream_p)            { return_val |= P; st->_stream_p=0; }
                                    return_val |= st->_stream_h;
    if (st->_stream_pre)	        return_val |= PRE;

    if (st->send_list > 0) {
      if (st->send_list & DL) {
        if (st->_stream_dl)	        return_val |= DL;
      }
      if (st->send_list & UL) {
        if (st->_stream_ul)	        return_val |= UL;
      }
      st->send_list = 0;
    }
    /*if (st->_stream_li)	            return_val |= LI;*/
    if (st->_stream_dt)	    	    return_val |= DT;
    if (st->_stream_dd)	    	    return_val |= DD;
    if (st->_stream_br)           { return_val |= BR ; st->_stream_br=0; }
    if (st->_stream_blockquote)     return_val |= BLOCKQUOTE;
    if (st->_stream_address)        return_val |= ADDRESS;
    if (st->_stream_h && st->_stream_halign)
    {
        switch (st->_stream_halign)
        {
            case 2: return_val |= CENTER; break;
            case 3: return_val |= RIGHT; break;
        }
    }
    else
    {
        if (st->_stream_centre)	    return_val |= CENTER;
        if (st->_stream_right)	    return_val |= RIGHT;
    }
    if (st->_stream_sub)	    return_val |= SUB;
    if (st->_stream_sup)	    return_val |= SUP;
    if (st->_stream_u)              return_val |= UNDERLINE;
    if (st->_stream_strike)         return_val |= STRIKE;
    if (st->_stream_anchor != NULL) return_val |= A;
  /*}*/

  return return_val;
}

/********************************************************************/
/* static unsigned int __html_stream_type(void)                     */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start)
{
  unsigned int temp=tag_type;

  if (st->_stream_title) {
    temp = TYPE_HEAD;

  } else if (st->_stream_frameset) {
    temp = TYPE_FRAMESET;
  }

  if (st->_stream_noframes) {
    temp |= TYPE_NOFRAMES;
  }

  temp |= (((unsigned int) start) << TYPE_START_SHIFT);

  if (st->_stream_colour != NULL) {
    if (st->_stream_colour->colour_valid)
      temp |= TYPE_COLOURED;
  }

  return temp;
}

/********************************************************************/
/* static unsigned int __html_stream_indent(void)                   */
/********************************************************************/
/* Given all the status variable attempt to work out the indent     */
/* level at this point in time	 	    	     	 	    */
/********************************************************************/
unsigned int __html_stream_indent(StreamTokens *st)
{
  return ((unsigned int) st->_stream_dl -
                         st->_stream_dt +
  	 	         st->_stream_ol +
  	 	         st->_stream_ul);
}

#if 0
static char *strnchrs(char *start, const char *c, const char *end)
{
    const char *p;

    while (start < end)
    {
        for (p = c; *p; p++)
            if (*start == *p)
                return start;
        start++;
    }
    return 0;
}
#endif

/********************************************************************/
/* static char * __html_stream_grab_pcdata(char **input, int size)  */
/********************************************************************/
/* This routine returns a local copy of any PCDATA encountered at   */
/* this point, including feeding it through the relevant stripping  */
/* code etc. This routine only reads up to the next '<' sign  	    */
/********************************************************************/
static char *__html_stream_grab_pcdata(char **input, int contig, int after_tag)
{
  char *end;
  char *ret;

  if (after_tag)
      end = __html_skip_record_end(*input, 1);
  else
      end = *input;

carryon:
/*
 * Find the start of the next tag, end of the input stream, or the
 * end of the chunk by size, which ever is the sooner.
 */
  while ((*end != '\0') && (*end != '<') && (*end != '&'))
  {
      end++;
  }

/* If we have gone over the end of the size limit, shuffle back a bit */
  if (*end == '\0') {
    if (contig)
        RETURN(NULL);  /* Can't be sure we have all PCDATA yet - we'll come back later */
  }
  else if (*end == '&')
  {
      /* Check we don't have half an escape code */
      char *stop;

      for (stop = end + 1; *stop != '\0' && (isalnum(*stop) || *stop=='#' || *stop=='&'); stop++)
        continue;

      if (*stop == ';')
      {
          end = stop + 1;
          goto carryon;
      }
      else if (*stop)
      {
          end = stop;
          goto carryon;
      }
      else if (contig) RETURN(NULL);
  }

/*
 * grab a copy of what we have and return it, moving the input
 * pointer accordingly.
 */
  ret=strndup(*input,(end-*input));
  __html_strip_control_codes(ret);

  *input=end;
  return ret;

}

/********************************************************************/
/* static HStream __html_stream_start_tag(Tag next_tag, char **html)*/
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words          */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading                                             */
/********************************************************************/
static HStream *__html_stream_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
#ifndef NEWSPACING
    st->stripleadingcr=1;
#endif

    __html_process_attributes(st, next_tag, *html, url);

    switch(next_tag->tag_no)
    {
      #ifdef TABLE_SUPPORT
      case TAG_TR:
      case TAG_TD:
      case TAG_TH:
      case TAG_TABLE:      return __html_stream_return_tag(st,next_tag,html,END,url);
      #endif
      case TAG_INPUT:
      case TAG_SELECT:
      case TAG_OPTION:
      case TAG_TEXTAREA:
      case TAG_FORM:       return __html_form_handler(st, next_tag, html, size);
      case TAG_MAP:        return __html_map_handler(st);
      case TAG_AREA:       return __html_stream_area(st, html, next_tag);
      case TAG_APPLET:
      case TAG_OBJECT:     return __html_stream_object(st, html, next_tag);
      case TAG_PARAM:      return __html_stream_param(st, html, next_tag);
      case TAG_EMBED:      return __html_stream_embed(st, html, next_tag);
      case TAG_BASEFONT:   if (ATTR_VAL(FONTSIZE) >= 1 && ATTR_VAL(FONTSIZE) <= 7)
                               st->_stream_basefont = ATTR_VAL(FONTSIZE);
                           break;
      case TAG_FONT:  {     int first=1;

                            if (ATTR_SET(COLOUR))
                                add_colour_info(st, ATTR_VAL(COLOUR), &first);

                            if (ATTR_SET(FONTSIZE))
                                add_size_info(st, ATTR_STR(FONTSIZE), &first);

                            break;
                      }
      case TAG_BIG:   {     int first=1;

                            add_size_info(st, "+1", &first);
                            break;
                      }

      case TAG_ACRONYM:
      case TAG_SMALL: {     int first=1;

                            add_size_info(st, "-1", &first);
                            break;
                      }
      case TAG_CENTER:     st->_stream_centre++; break;
      case TAG_ADDRESS:    st->_stream_address++; break;
      case TAG_BLOCKQUOTE: st->_stream_blockquote++; break;
      case TAG_XMP:
      case TAG_PRE: __html_stream_cancel_align(st);

                    st->_stream_pre++; break;
      case TAG_H1:
      case TAG_H2:
      case TAG_H3:
      case TAG_H4:
      case TAG_H5:
      case TAG_H6: __html_stream_cancel_align(st);

                   st->_stream_h=next_tag->tag;
                   st->_stream_halign=ATTR_VAL(ALIGN);

                   break;

      case TAG_MENU:
      case TAG_DIR:
      case TAG_UL:  __html_stream_cancel_align(st);

                   st->_stream_ul++;  /* Needed for indent level */
      	   	       st->send_list|=UL;
      	   	       if (st->_stream_ol + st->_stream_ul <= MAX_OL)
      	   	       {
      	   	           st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = 'u';
      	   	       }
                       break;

      case TAG_OL: __html_stream_cancel_align(st);

                   st->_stream_ol++;  /* Needed for indent level */
                   if (st->_stream_ol + st->_stream_ul <= MAX_OL)
                   {
                       int start = ATTR_VAL(STARTattr);
                       int style = ATTR_VAL(TYPE);
                       if (ATTR_SET(STARTattr))
                           start--;
                       if (!style)
                           style = '1';
                       st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] = start;
                       st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = style;
                   }
      	   	       break;

      case TAG_DL: __html_stream_cancel_align(st);

                   st->_stream_dl++;  /* Needed for indent level */
      	   	       st->_stream_dt=0;
      	   	       st->_stream_dd=0;
      	   	       st->send_list|=DL;
      	   	       //Printf("HTMLLib: Should send a DL now\n");
      	   	       break;

      case TAG_LI: {
                       HStream *ret;

                       __html_stream_cancel_align(st);

                       st->_stream_li++; /* Needed for indent level? */
                       if (st->_stream_ol + st->_stream_ul > 0 && st->_stream_ol + st->_stream_ul <= MAX_OL)
                       {
                           if (ATTR_SET(VALUE))
                               st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] = ATTR_VAL(VALUE);
                           else
                               st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] ++;

                           if (ATTR_SET(TYPE))
                               st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = ATTR_VAL(TYPE);
                       }

                       ret = __html_stream_return_tag(st,next_tag,html,START);
                       if (ret)
                           __html_construct_ol_text(st, ret);
                       return ret;
                   }
      case TAG_DT:     __html_stream_cancel_align(st);
                       if (st->_stream_dt || !st->_stream_dl)
                       {
                           char *br = "BR>";
                           /* Send back a BR tag - easiest way to get a linebreak */
                           return __html_stream_return_tag(st, __html_find_tag(&br, 0), html, START);
                       }
                       if (st->_stream_dd) st->_stream_br=1;
                       st->_stream_dt=1; /* Needed for indent level? */
                       st->_stream_dd=0;
                       break;
      	   	       /*return __html_stream_return_tag(st,next_tag,html,START);*/

      case TAG_DD:     __html_stream_cancel_align(st);
                       if (st->_stream_dd || !st->_stream_dl)
                       {
                           char *br = "BR>";
                           /* Send back a BR tag - easiest way to get a linebreak */
                           return __html_stream_return_tag(st, __html_find_tag(&br, 0), html, START);
                       }
                       if (st->_stream_dt) st->_stream_br=1;
                       st->_stream_dd=1; /* Needed for indent level? */
                       st->_stream_dt=0;
                       break;
      	   	       /*return __html_stream_return_tag(st,next_tag,html,START);*/

      case TAG_HR:     return __html_stream_hr(st, html, next_tag);
      case TAG_BR:     return __html_stream_return_tag(st,next_tag,html,START);
/*
 * We didnt find the tag in that lot, so look in the last 10. This is
 * sort of complicated by the fact that some of these are in the
 * head and some are in the body list, and there are <HEAD> and <BODY>
 * too.
 */
      case TAG_P:   {  int align = ATTR_VAL(ALIGN);
                       st->_stream_p=1;
                       if (align != 0 && !st->_stream_palign)
                       {
                           st->_stream_palign = 1;
                           st->_stream_oldcentre = st->_stream_centre;
                           st->_stream_oldright = st->_stream_right;
                       }
                       if (align == 1)
                           st->_stream_centre = st->_stream_right = 0;
                       else if (align == 2)
                           st->_stream_centre = 1, st->_stream_right = 0;
                       else if (align == 3)
                           st->_stream_centre = 0, st->_stream_right = 1;
                       else if (st->_stream_palign)
                       {
                           st->_stream_palign = 0;
                           st->_stream_centre = st->_stream_oldcentre;
                           st->_stream_right = st->_stream_oldright;
                       }
                       break;
                     }
      case TAG_DIV:    __html_stream_cancel_align(st);
                       st->_stream_h = 0;
                       switch (ATTR_VAL(ALIGN))
                       {
                           default:
                           case 1: st->_stream_centre = st->_stream_right = 0; break;
                           case 2: st->_stream_centre = 1; st->_stream_right = 0; break;
                           case 3: st->_stream_centre = 0; st->_stream_right = 1; break;
                       }
                       break;
      case TAG_IMG:    return __html_stream_image(st,html, next_tag);
      case TAG_A:      {
                         int first = 1;

                         /* To get around "<font color><a>default</a></font>" vs.
                          * "<a><font color>coloured</font></a>", stack the current
                          * font settings replacing them with defaults.
                          */

                         if (
                              st->_stream_colour != NULL &&
                              st->_stream_colour->colour_valid != 0
                            )
                         {
                           add_colour_info(st, 0, &first);
                           st->_stream_colour->colour_valid     = 0;
                           st->_stream_colour->stacked_for_link = 1;
                         }

                         __html_stream_anchor(st, html, next_tag); break;
                       }
      case TAG_SAMP:
      case TAG_CODE:
      case TAG_KBD:
      case TAG_VAR:
      case TAG_TT:     st->_stream_tt++; break;
      case TAG_EM:
      case TAG_CITE:
      case TAG_DFN:
      case TAG_ITALIC: st->_stream_italic++; break;
      case TAG_STRONG:
      case TAG_BOLD:   st->_stream_bold++; break;
      case TAG_NOBR:   st->_stream_nobr++; break;
      case TAG_SUB:    st->_stream_sub++; break;
      case TAG_SUP:    st->_stream_sup++; break;
      case TAG_INS:
      case TAG_U:      st->_stream_u++; break;
      case TAG_Q:      return __html_stream_q(st, html, START);

      case TAG_S:
      case TAG_DEL:
      case TAG_STRIKE: st->_stream_strike++; break;
      #ifdef TonyTables
      case TAG_TR:     if (st->usingtables) return __html_table_row_start_tag(st, next_tag, html, url, size);
                       else break;
      case TAG_TD:     if (st->usingtables) return __html_table_data_start_tag(st, next_tag, html, url, size);
                       else break;
      case TAG_TH:     if (st->usingtables) return __html_table_head_start_tag(st, next_tag, html, url, size);
                       else break;
      case TAG_TABLE:  if (st->usingtables) return __html_table_start_tag(st, next_tag, html, url, size);
                       else break;
      #endif
      case TAG_META: {
              HStream *ret=__html_stream_return_tag(st,next_tag,html,START);
              if (ret)
              {
                  ret->info = (elementinfo *)__html_malloc(sizeof (elementinfo_meta), 1);
                  if (!ret->info) { __html_free(ret, 0); return NULL; }
                  ret->info->meta.http_equiv = ATTR_STR(HTTP_EQUIV);
                  ret->info->meta.name       = ATTR_STR(NAME);
                  ret->info->meta.content    = ATTR_STR(CONTENT);
                  ret->info->meta.scheme     = ATTR_STR(SCHEME);
              }
              return ret;
      }
      case TAG_TITLE:    st->_stream_title++; break;
      case TAG_BASE:     __html_stream_base(st); break;
      case TAG_ISINDEX:  st->_stream_isindex=1; break;
      case TAG_SCRIPT:   st->state = Script; return NULL;
      case TAG_NOSCRIPT:
      {
        if (st->usingscripts)
        {
          st->state = NoScript;
          return NULL;
        }
        else break;
      }
      case TAG_STYLE:    st->state = Style; return NULL;
      case TAG_FRAME:    return __html_stream_frame(st, html, next_tag);
      case TAG_BODY: {
              HStream *ret=__html_stream_return_tag(st,next_tag,html,START);
              if (ret)
              {
                  ret->info = (elementinfo *)__html_malloc(sizeof (elementinfo_body), 1);
                  if (!ret->info) { __html_free(ret, 0); return NULL; }
                  ret->info->body.onload = ATTR_STR(ONLOAD);
                  ret->info->body.onunload = ATTR_STR(ONUNLOAD);
                  ret->info->body.background = ATTR_STR(BACKGROUND);
                  ret->info->body.text = ATTR_SET(FGCOL) ? ATTR_VAL(FGCOL) : NULL_COLOUR;
                  ret->info->body.bgcolour = ATTR_SET(BGCOL) ? ATTR_VAL(BGCOL) : NULL_COLOUR;
                  ret->info->body.link = ATTR_SET(LINKCOL) ? ATTR_VAL(LINKCOL) : NULL_COLOUR;
                  ret->info->body.vlink = ATTR_SET(VLINK) ? ATTR_VAL(VLINK) : NULL_COLOUR;
                  ret->info->body.alink = ATTR_SET(ALINK) ? ATTR_VAL(ALINK) : NULL_COLOUR;
              }
              return ret;
          }
      case TAG_FRAMESET:return __html_stream_frameset(st, html, next_tag);
      case TAG_NOFRAMES:
              st->_stream_noframes = 1;
              break;
    }
/* In theory we dont need to do any more so we can return here */
    return NULL;
}

/********************************************************************/
/* static void __html_stream_cancel_align(StreamTokens *st)         */
/********************************************************************/
/* Code handling block-level elements like <Hn> or <UL> should call */
/* this to cancel any previous <P ALIGN="...">.                     */
/********************************************************************/
static void __html_stream_cancel_align(StreamTokens *st)
{
  if (st->_stream_palign)
  {
      st->_stream_palign = 0;
      st->_stream_centre = st->_stream_oldcentre;
      st->_stream_right = st->_stream_oldright;
  }

  return;
}

#define DEC(a) if ((a) > 0) { (a)--; }

/********************************************************************/
/* static Hstream *__html_stream_end_tag(Tag next_tag, char **html) */
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words	    */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading		     	      	    	       	    */
/********************************************************************/
static HStream *__html_stream_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
/* Make a note of this token for later use */
  st->needtosend[next_tag->tag_no] = 1;
/*
 * we have a start tag. Big case statement alert - work from the bottom
 * of the list upwards for safty :) */

  switch(next_tag->tag_no) {
    #ifdef TABLE_SUPPORT
    case TAG_TR:
    case TAG_TD:
    case TAG_TH:
    case TAG_TABLE: return __html_stream_return_tag(st,next_tag,html,END,url);
    #endif

    case TAG_FORM:
      return __html_stream_end_form(st, html);

    case TAG_MAP:
      st->_stream_map=0;
      break;

    case TAG_SELECT:
      st->_stream_select=0;
      break;

    case TAG_BIG:
    case TAG_SMALL:
    case TAG_ACRONYM:
    case TAG_FONT:
      font_tag_closed(st);
      #ifndef NEWSPACING
      st->stripleadingcr = 0;
      #endif
      break;

    case TAG_P:
      __html_stream_cancel_align(st);
      /* '</P>' implies a following '<P>' with no attributes, so there's
         no closing tag, in effect */
      st->needtosend[next_tag->tag_no] = 0;
      st->_stream_p=1;
      break;

    case TAG_CENTER:
      st->_stream_br = 1;
      DEC(st->_stream_centre);
      break;

    case TAG_DIV:
      st->_stream_br = 1;
      st->_stream_palign = 0;
      st->_stream_centre = 0;
      st->_stream_right = 0;
      break;

    case TAG_ADDRESS:
      DEC(st->_stream_address);
      break;

    case TAG_BLOCKQUOTE:
      DEC(st->_stream_blockquote);
      break;

    case TAG_MENU:
    case TAG_DIR:
    case TAG_UL:
      DEC(st->_stream_ul);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case TAG_OL:
      DEC(st->_stream_ol);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case TAG_DL:
      DEC(st->_stream_dl);
      /* Cope with nested <DL>s: if we're still in a DL, for valid HTML
         we must be in a DD! */
      st->_stream_dt=0;
      if (st->_stream_dl)
      {
        st->_stream_dd = 1;
      }
      else
      {
        st->_stream_dd = 0;
        /* A little dubious. Ensures that there's always a break after '</DL>'
           and works as the client is assumed to render a paragraph break
           style between DT and DD - this way, if you nest a <DL>...</DL>,
           the gap caused by the paragraph break force under the </DL> won't
           look odd. */
        st->_stream_p = 1;
      }
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url)*/;

    case TAG_DD:
      st->_stream_dd = 0;
      st->_stream_br = 1; /* Yuck. */
      break;

    case TAG_DT:
      st->_stream_dt = 0;
      st->_stream_br = 1; /* Yuck again! */
      break;

    case TAG_LI:
      DEC(st->_stream_li);
      break;

    case TAG_XMP:
    case TAG_PRE:
      DEC(st->_stream_pre);
      break;

    case TAG_H1:
    case TAG_H2:
    case TAG_H3:
    case TAG_H4:
    case TAG_H5:
    case TAG_H6:
      st->_stream_h = 0;
      break;

    case TAG_A:
    {
      /* Unstack colour info. See TAG_A in __html_stream_start_tag for
       * more information.
       */

      if (
           st->_stream_colour != NULL &&
           st->_stream_colour->stacked_for_link != 0
         )
         font_tag_closed(st);

      /* Cope with <A NAME="fred"></A> */
      if (st->need_to_send_name)
      {
          HStream *return_val;
          st->need_to_send_name=0;

          /* To stop it stripping spaces before the <A NAME="x"> */
          st->isendtag=0;

          return_val=HStreamalloc(st, TAG_A);
          if (return_val)
          {
              return_val->style=__html_stream_style(st)|PCDATA;
              return_val->type=__html_stream_type(st, TYPE_BODY, END);
              return_val->indent=__html_stream_indent(st);
              if (st->_stream_anchor != NULL) {
                #ifdef CUSTOMER_SPECIAL
                return_val->onclick=st->_stream_anchor->onclick;
                #endif
                return_val->anchor=st->_stream_anchor->href;
                return_val->name=st->_stream_anchor->name;
                return_val->target = st->_stream_anchor->target;
              }
              fill_in_colour_info(st, return_val);
              return_val->tag=next_tag->tag;
          }
          __html_stream_end_anchor(st);
          return return_val;
      }
      __html_stream_end_anchor(st);
      break;
    }
    case TAG_SAMP:
    case TAG_CODE:
    case TAG_KBD:
    case TAG_VAR:
    case TAG_TT:
      DEC(st->_stream_tt);
      break;

    case TAG_EM:
    case TAG_CITE:
    case TAG_DFN:
    case TAG_ITALIC:
      DEC(st->_stream_italic);
      break;

    case TAG_STRONG:
    case TAG_BOLD:
      DEC(st->_stream_bold);
      break;

    case TAG_NOBR:
      DEC(st->_stream_nobr);
      break;

    case TAG_SUB:
      DEC(st->_stream_sub);
      break;

    case TAG_SUP:
      DEC(st->_stream_sup);
      break;

    case TAG_INS:
    case TAG_U:
      DEC(st->_stream_u);
      break;

    case TAG_Q:
      return __html_stream_q(st, html, END);

    case TAG_S:
    case TAG_DEL:
    case TAG_STRIKE:
      DEC(st->_stream_strike);
      break;

  #ifdef TonyTables
    case TAG_TR:    if (st->usingtables) return __html_table_row_end_tag(st, next_tag, html, url);
                    else break;
    case TAG_TD:    if (st->usingtables) return __html_table_data_end_tag(st, next_tag, html, url);
                    else break;
    case TAG_TH:    if (st->usingtables) return __html_table_head_end_tag(st, next_tag, html, url);
                    else break;
    case TAG_TABLE: if (st->usingtables) return __html_table_end_tag(st, next_tag, html, url);
                    else break;
  #endif
  #if 0
    /* Not required because ANY tag will terminate a TITLE */
    case TAG_TITLE:
      DEC(st->_stream_title);
      break;
  #endif
    case TAG_APPLET:
    case TAG_OBJECT:
      __html_stream_end_object(st);
      break;
    case TAG_FRAMESET:
      if (st->_stream_frameset == 1 && st->had_frame) st->dead = 1;
      DEC(st->_stream_frameset);
      NOT_USED(size);
      break;
    case TAG_NOFRAMES:
      st->_stream_noframes = 0;
      break;
  }
  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_imagechar **html)                  */
/********************************************************************/
/* Knowing that we are in a image tag, grab the anchor information  */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_image(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream            *return_val;
  elementinfo_object *info;

#ifdef UPDATEINPUT
  char               *ptr;
#else
  NOT_USED(html);
#endif

  /* Throw out certain nasty image thingies which probably don't */
  /* contribute much to the page alignment...                    */

  if (ATTR_VAL(ALIGN) == 4 || ATTR_VAL(ALIGN) == 5)
  {
    if (
         (
           ATTR_SET(WIDTH) &&
           ATTR_VAL(WIDTH) <= 2
         )
         ||
         (
           ATTR_SET(WIDTH)      &&
           ATTR_SET(HEIGHT)     &&
           ATTR_VAL(WIDTH) <= 6 &&
           ATTR_VAL(HEIGHT) > ATTR_VAL(WIDTH) * 15
         )
       )
       return NULL;
  }

  return_val=HStreamalloc(st, TAG_IMG);

  if (return_val != NULL) {

    info = (elementinfo_object *)__html_malloc(sizeof(elementinfo_object), 1);
    if (!info) {__html_free(return_val, 0); return NULL; }

    return_val->info = (elementinfo *) info;

    info->hspace = ATTR_VAL(HSPACE);
    info->vspace = ATTR_VAL(VSPACE);

    return_val->style=__html_stream_style(st) | IMG;
    return_val->type=__html_stream_type(st, next_tag->type, START);
    if (ATTR_SET(ISMAP))
        return_val->type|=TYPE_ISMAP;

    if (ATTR_SET(USEMAP))
    {
        elementinfo_object *info;
        info = (elementinfo_object *)__html_malloc(sizeof(elementinfo_object), 1);
        if (info)
        {
            return_val->info = (elementinfo *) info;
            info->usemap = ATTR_STR(USEMAP);
            info->maps = st->maps;
            return_val->type |= TYPE_ISCLIENTMAP;
        }
    }


    switch (ATTR_VAL(ALIGN))
    {
        case 1: return_val->type|=_html_top<<TYPE_ALIGN_SHIFT; break;
        case 2: return_val->type|=_html_middle<<TYPE_ALIGN_SHIFT; break;
        case 3: return_val->type|=_html_bottom<<TYPE_ALIGN_SHIFT; break;
        case 4: return_val->type|=_html_left<<TYPE_ALIGN_SHIFT; break;
        case 5: return_val->type|=_html_right<<TYPE_ALIGN_SHIFT; break;
        case 6: return_val->type|=_html_centre<<TYPE_ALIGN_SHIFT; break;
        default:return_val->type|=_html_none<<TYPE_ALIGN_SHIFT; break;
    }

    if (st->_stream_anchor!=NULL) {
        return_val->anchor=st->_stream_anchor->href;
        return_val->name=st->_stream_anchor->name;
        return_val->target=st->_stream_anchor->target;
        #ifdef CUSTOMER_SPECIAL
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
    }

    st->need_to_send_name=0;

    return_val->text=ATTR_STR(ALT);

    return_val->src=ATTR_STR(SRC);

    if (ATTR_SET(WIDTH))
    {
        return_val->cols = ATTR_VAL(WIDTH) | (1<<24);
        if (st->curattrs[WIDTH].miscflag)
            return_val->cols |= UNITS_PERCENT << 28;
        else
            return_val->cols |= UNITS_PIXELS << 28;
    }
    if (ATTR_SET(HEIGHT))
    {
        return_val->rows = ATTR_VAL(HEIGHT) | (1<<24);
        if (st->curattrs[HEIGHT].miscflag)
            return_val->rows |= UNITS_PERCENT << 28;
        else
            return_val->rows |= UNITS_PIXELS << 28;
    }

    return_val->maxlen=ATTR_SET(BORDER) ? ATTR_VAL(BORDER) :
                                            return_val->anchor ? 2 : 0;

    info->border = return_val->maxlen;

//    /* If one of HEIGHT or WIDTH are missing, remove the other one as
//       well to prevent confusion */
//    if (return_val->rows==0 || return_val->cols==0)
//        return_val->cols=return_val->rows=0;

    memset(st->needtosend, 0, sizeof st->needtosend);

    return_val->tag=IMG;
    return_val->indent=__html_stream_indent(st);
    fill_in_colour_info(st, return_val);
  }

#ifdef UPDATEINPUT
/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;
#endif

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_hr()                               */
/********************************************************************/
/* Knowing that we are in a HR tag, grab the anchor information     */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_hr(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream     *return_val;
  int         noshade=0;
  int         alignment=_html_centre;

#ifdef UPDATEINPUT
  char        *ptr;
#else
  NOT_USED(html);
#endif

  return_val=HStreamalloc(st, TAG_HR);
  if (return_val != NULL) {
    if (ATTR_SET(NOSHADE))
        noshade=TYPE_NOSHADE;
    switch (ATTR_VAL(ALIGN))
    {
        case 1: alignment = _html_left; break;
        case 2: alignment = _html_right; break;
        default:alignment = _html_centre; break;
    }
    if (ATTR_SET(WIDTH))
    {
        return_val->cols = ATTR_VAL(WIDTH) | (1<<24);
        if (st->curattrs[WIDTH].miscflag)
            return_val->cols |= UNITS_PERCENT << 28;
        else
            return_val->cols |= UNITS_PIXELS << 28;
    }
    return_val->size=ATTR_VAL(SIZE);

    memset(st->needtosend, 0, sizeof st->needtosend);
    if (st->_stream_anchor!=NULL) {
        return_val->anchor=st->_stream_anchor->href;
        return_val->name=st->_stream_anchor->name;
        #ifdef CUSTOMER_SPECIAL
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
        st->need_to_send_name=0;
    }
    return_val->style=__html_stream_style(st) | HR;
    return_val->type=__html_stream_type(st, next_tag->type, START) | noshade;
    return_val->type &= ~TYPE_ALIGN_MASK;
    return_val->type |= alignment << TYPE_ALIGN_SHIFT;
    return_val->indent=__html_stream_indent(st);
    return_val->tag=HR;
    /* Get rid of the anchor info block */

    fill_in_colour_info(st, return_val);
  }


#ifdef UPDATEINPUT
/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;
#endif

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_anchor(char **html)                */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_anchor(StreamTokens *st, char **html, Tag *next_tag)
{
  AnchorInfo *anc;
  int gotsomething=0;

  NOT_USED(html); NOT_USED(next_tag);

  if (st->_stream_map) __html_stream_add_anchor_to_map(st, html, next_tag);

  if (st->_stream_anchor != NULL) __html_stream_end_anchor(st);

  anc = (AnchorInfo *) __html_malloc(sizeof(AnchorInfo), 1);
  if (!anc) return NULL;

  if (ATTR_SET(NAME))
      anc->name = ATTR_STR(NAME), gotsomething=1, st->need_to_send_name = 1;

  if (ATTR_SET(HREF))
      anc->href = ATTR_STR(HREF), gotsomething=1;

  if (ATTR_SET(TARGET))
      anc->target = ATTR_STR(TARGET), gotsomething=1;

  #ifdef CUSTOMER_SPECIAL
  if (ATTR_SET(ONCLICK))
      anc->onclick = ATTR_STR(ONCLICK), gotsomething=1;
  #endif

  /* Get the coordinates */
  if (ATTR_SET(COORDS))
      anc->coords = ATTR_COORDS(COORDS);
  else if (ATTR_VAL(SHAPE) == areashape_DEFAULT)
      /* If no coordinates, and shape = DEFAULT, that's okay - put in a dummy coords block. */
      anc->coords = (int *) __html_malloc(sizeof(int), 2);

  if (anc->coords)
      anc->coords[0] = ATTR_VAL(SHAPE);

  if (gotsomething)
  {
      if (!anc->target)
          anc->target = strdup(st->target);

      st->_stream_anchor = anc;
  }

  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_add_anchor_to_map ()               */
/********************************************************************/
/* Deal with <a> inside <map> as well as <area> (HTML 4)            */
/********************************************************************/
static HStream *__html_stream_add_anchor_to_map(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream *ret, **prev;

  NOT_USED(next_tag);

  if (!st->_stream_map) return NULL;

  /* Fill in an HStream */
  ret = __html_stream_return_tag(st, next_tag, html, 1);
  if (!ret)
      return NULL;

  ret->style |= A;

  /* Get the coordinates */
  if (ATTR_SET(COORDS))
      ret->coords = ATTR_COORDS(COORDS);
  else if (ATTR_VAL(SHAPE) == areashape_DEFAULT)
      /* If no coordinates, and shape = DEFAULT, that's okay - put in a dummy coords block. */
      ret->coords = (int *) __html_malloc(sizeof(int), 2);

  if (!ret->coords)
  {
      __html_free(ret, 0);
      return NULL;
  }

  ret->coords[0] = ATTR_VAL(SHAPE);

  ret->anchor = ATTR_STR(HREF);

  if (ATTR_SET(TARGET))
      ret->target = ATTR_STR(TARGET);
  else
      ret->target = strdup(st->target);

  if (ATTR_SET(ALT))
      ret->text = ATTR_STR(ALT);
  else
      ret->text = strdup(ret->anchor);

  for (prev = &st->maps->next->stream; *prev; prev = &(*prev)->next)
      continue;

  *prev = ret;

  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_frame (char **html)                */
/********************************************************************/
/* Given a frame start tag, extract the relevant information        */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_frame (StreamTokens *st, char **html, Tag *next_tag)
{
  HStream *return_val;

  if (!st->usingframes)
      return NULL;

  return_val=HStreamalloc(st, TAG_FRAME);

  if (return_val != NULL)
  {
    st->had_frame = 1;

    return_val->style  = __html_stream_style(st) | FRAME;
    return_val->tag    = FRAME;
    return_val->type = __html_stream_type(st, next_tag->type, START);
    return_val->size   = st->_stream_frameset;
    return_val->type |= ATTR_VAL(SCROLLING) << TYPE_SCROLLING_SHIFT;
    if (ATTR_SET(NORESIZE))
        return_val->type |= TYPE_NORESIZE;
    if (ATTR_SET(FRAMEBORDER))
    {
        char *p = ATTR_STRPEEK(FRAMEBORDER);
        UPPER_CASE(p);

        if (strstr(p, "YES")) return_val->indent = 8;
        else if (strstr(p, "NO")) return_val->indent = 0;
        else
        {
            return_val->indent = atoi(p);
            if (return_val->indent == 1)
                return_val->indent = 8;
        }
    }
    else
        return_val->indent = 8;
    if (ATTR_SET(BORDER))
    {
        int val = ATTR_VAL(BORDER);

        if (val < 0) return_val->indent = 8;
        else         return_val->indent = val;
    }
    if (ATTR_SET(BORDERCOLOUR))
        return_val->maxlen = ATTR_VAL(BORDERCOLOUR) | 1;
    return_val->rows   = ATTR_VAL(MARGINHEIGHT);
    return_val->cols   = ATTR_VAL(MARGINWIDTH);
    return_val->name   = ATTR_STR(NAME);
    return_val->src    = ATTR_STR(SRC);
  }

  *html += __html_tag_length(*html);
  __html_stream_grab_pcdata(html, 1, 1);
  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_frameset (char **html)             */
/********************************************************************/
/* Given a frame start tag, extract the relevant information        */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_frameset(StreamTokens *st, char **html, Tag *tag)
{
  HStream *return_val;

  if (!st->usingframes)
      return NULL;

  if (!ATTR_SET(ROWS) && !ATTR_SET(COLS)) return NULL;

  st->_stream_frameset++;
  st->_stream_noframes = 0;
  return_val=HStreamalloc(st, TAG_FRAMESET);
  if (return_val != NULL) {
    return_val->style  = __html_stream_style(st) | tag->tag;
    return_val->tag    = tag->tag;
    return_val->type   = __html_stream_type(st, tag->type, START);
    return_val->size   = st->_stream_frameset;
    if (ATTR_SET(ROWS))
    {
        parse_rowcols(ATTR_STRPEEK(ROWS), NULL, &return_val->rows);
        return_val->name = __html_malloc(sizeof(unsigned int), return_val->rows);
        if (return_val->name)
            parse_rowcols(ATTR_STRPEEK(ROWS), (unsigned int *) (return_val->name), NULL);
    }
    if (ATTR_SET(COLS))
    {
        parse_rowcols(ATTR_STRPEEK(COLS), NULL, &return_val->cols);
        return_val->value = __html_malloc(sizeof(unsigned int), return_val->cols);
        if (return_val->value)
            parse_rowcols(ATTR_STRPEEK(COLS), (unsigned int *) (return_val->value), NULL);
    }
    if (ATTR_SET(FRAMEBORDER))
    {
        char *p = ATTR_STRPEEK(FRAMEBORDER);
        UPPER_CASE(p);

        if (strstr(p, "YES")) return_val->indent = 8;
        else if (strstr(p, "NO")) return_val->indent = 0;
        else
        {
            return_val->indent = atoi(p);
            if (return_val->indent == 1)
                return_val->indent = 8;
        }
    }
    else
        return_val->indent = 8;
    if (ATTR_SET(BORDER))
    {
        int val = ATTR_VAL(BORDER);

        if (val < 0) return_val->indent = 8;
        else         return_val->indent = val;
    }
    if (ATTR_SET(BORDERCOLOUR))
        return_val->maxlen = ATTR_VAL(BORDERCOLOUR) | 1;
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  *html += __html_tag_length(*html );
  __html_stream_grab_pcdata(html, 1, 1);
  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_base(char **html)                  */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   	                    */
/********************************************************************/
static HStream *__html_stream_base(StreamTokens *st)
{
  if (ATTR_SET(HREF))
  {
      if (st->url) __html_free(st->url, 0);
      st->url = ATTR_STR(HREF);
  }

  if (ATTR_SET(TARGET))
  {
      if (st->target) __html_free(st->target, 0);
      st->target = ATTR_STR(TARGET);
  }

  if (st->base_callback)
      st->base_callback(st, st->url, st->target, st->base_callback_handle);

  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_end_anchor(void)                   */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static void __html_stream_end_anchor(StreamTokens *st)
{
  /* Need to rewrite this ! */
  __html_stream_free_anchor(&(st->_stream_anchor));
}

#if 0
/********************************************************************/
/* static HStream *__html_stream_end_header(char **html)            */
/********************************************************************/
/* Given the end of the header block, return a token indicating     */
/* things like if ISINDEX is set for example.  	     		    */
/********************************************************************/
static HStream *__html_stream_end_header(char **html)
{
  NOT_USED(html);

  return NULL;
}
#endif

/********************************************************************/
/* static void __html_style_init(styleinfo *s)                      */
/********************************************************************/
/* This small routine resets all the styles to their initial        */
/* value      	      	     	     	       	  		    */
/********************************************************************/
void __html_style_init(styleinfo *s)
{
  memset(s, 0, sizeof *s);
}

/********************************************************************/
/* static void __html_stream_init(void)                             */
/********************************************************************/
/* This small routine resets all the variables to their initial     */
/* value      	      	     	     	       	  		    */
/********************************************************************/
StreamTokens *__html_stream_init(void)
{
  StreamTokens *st;

  st=(StreamTokens *)calloc(1, sizeof(StreamTokens)); /* zeroes everything */
  if (st==NULL) return NULL;

  __html_style_init(&st->_stream_style);

  st->_stream_basefont   =3;
  st->stripleadingspace  =1;

  return st;
}

/********************************************************************/
/* static HStream *__html_stream_return_tag (Tag tag, char **html)  */
/********************************************************************/
/* Given any old tag block that isnt a PCDATA, create and return a  */
/* stream element for that tag.	       	       	      	  	    */
/********************************************************************/
/*static*/ HStream *__html_stream_return_tag(StreamTokens *st, Tag *tag, char **html, int start)
{
  HStream *ret;

#ifdef UPDATEINPUT
  char *ptr;
#else
  NOT_USED(html);
#endif

  ret=HStreamalloc(st, tag->tag_no);
  if (ret != NULL) {

      ret->style=__html_stream_style(st) | tag->tag; // This appears to put dodgy stuff in the style word
      ret->type=__html_stream_type(st, tag->type, start);

      ret->indent=__html_stream_indent(st);

      fill_in_colour_info(st, ret);

      if (st->_stream_anchor!=NULL) {
        #ifdef CUSTOMER_SPECIAL
        ret->onclick=st->_stream_anchor->onclick;
        #endif
        ret->anchor=st->_stream_anchor->href;
        ret->name=st->_stream_anchor->name;
        st->need_to_send_name=0;
        ret->target=st->_stream_anchor->target;
      }

      ret->tag=tag->tag;

      memset(st->needtosend, 0, sizeof st->needtosend);
  }

#ifdef UPDATEINPUT
/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  if (html != NULL) {
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
  }
#endif

  return ret;
}

/********************************************************************/
/* static void __html_stream_free_anchor(AnchorInfo **anchor)       */
/********************************************************************/
/* Given an anchor info block free up all the memory associated     */
/* with it, and set it back to NULL   	      	     		    */
/********************************************************************/
/*static*/ void __html_stream_free_anchor(AnchorInfo **anchor)
{
AnchorInfo *anc=*anchor;

  if (!anchor || !anc) return;

  /* Don't free href or target - HStreams point directly to them.
   * They will get freed normally when the stream is discarded.
   */
  __html_free(anc,0);

  *anchor=NULL;
}

/********************************************************************/
/* static HStream * __html_form_handler(StreamTokens *st, Tag ne... */
/********************************************************************/
/* General purpose forms handling but. Since all form elements are  */
/* basically derived from the same generic idea, it makes sense to  */
/* keep them in one bit.                                            */
/********************************************************************/
static HStream * __html_form_handler(StreamTokens *st, Tag *next_tag, char **html, int size)
{
HStream *ret;
char *ptr; /* Hackery - used to get text after tag */
char *p;

/* Since a form shouldnt be within an anchor, we can clear the anchor state */
  /*if (st->_stream_forms) __html_stream_free_anchor(&(st->_stream_forms));*/


/* Fill in a return slip :) */
  ret=HStreamalloc(st, next_tag->tag_no);
  if (!ret) return ret;

   ret->flags = 0;
   fill_in_colour_info(st, ret);

  if (next_tag->tag_no == TAG_OPTION ||
      next_tag->tag_no == TAG_TEXTAREA ||
      next_tag->tag_no == TAG_SELECT)
  {
    ptr = *html += __html_tag_length(*html);
  }

/* This is the nasty bit :) Decide what to do based on the tag */
  switch(next_tag->tag_no) {
    case TAG_FORM: /* Fill in method bit etc */
    	       ret->tag=FORM;
    	       ret->info=(elementinfo *)__html_malloc(sizeof(elementinfo_form), 1);
    	       if (!ret->info) { __html_free(ret, 0); return NULL; }
	       ret->style=__html_stream_style(st) | FORM;
	       ret->type=__html_stream_type(st, next_tag->type, START);
               ret->indent=__html_stream_indent(st);
               if (ATTR_SET(ACTION))
    	           ret->info->form.action     = ATTR_STR(ACTION);
    	       else
    	           ret->info->form.action     = strdup(st->url);
    	       ret->info->form.method         = (formmethod) ATTR_VAL(METHOD);
               ret->info->form.accept_charset = ATTR_STR(ACCEPT_CHARSET);
               ret->info->form.enctype        = ATTR_STR(ENCTYPE);
               ret->info->form.onsubmit       = ATTR_STR(ONSUBMIT);
               ret->info->form.onreset        = ATTR_STR(ONRESET);
               if (ATTR_SET(TARGET))
                   ret->info->form.target     = ATTR_STR(TARGET);
               else
                   ret->info->form.target     = strdup(st->target);
               st->needtosend[TAG_FORM] = 1;
	       break;

    case TAG_INPUT: /* Do lots of bits */
    {
               elementinfo_input *info;

    	       info=(elementinfo_input *)__html_malloc(sizeof(elementinfo_input), 1);
    	       ret->info=(elementinfo *)info;
    	       if (!info) { __html_free(ret, 0); return NULL; }
	       ret->style=__html_stream_style(st) | FORM;
	       ret->type=__html_stream_type(st, next_tag->type, START);
               ret->indent=__html_stream_indent(st);
	       /* INPUTy bits */
               info->type      = (inputtype) ATTR_VAL(TYPE);
	       info->name      = ATTR_STR(NAME);
	       info->value     = ATTR_STR(VALUE);
               info->checked   = ATTR_SET(CHECKED);
               info->disabled  = ATTR_SET(DISABLED);
               info->readonly  = ATTR_SET(READONLY);
	       info->size      = ATTR_VAL(SIZE);
	       info->maxlength = ATTR_VAL(MAXLENGTH);
	       info->src       = ATTR_STR(SRC);
	       info->alt       = ATTR_STR(ALT);
	       info->usemap    = ATTR_STR(USEMAP);
	       info->align     = (imgalign) ATTR_VAL(ALIGN);
               info->tabindex  = ATTR_VAL(TABINDEX);
               info->onfocus   = ATTR_STR(ONFOCUS);
               info->onblur    = ATTR_STR(ONBLUR);
               info->onselect  = ATTR_STR(ONSELECT);
               info->onclick   = ATTR_STR(ONCLICK);
               info->onchange  = ATTR_STR(ONCHANGE);
               info->accept    = ATTR_STR(ACCEPT);
	       if (info->type == inputtype_TEXT || info->type == inputtype_PASSWORD) {
  	         if (info->maxlength > 0) {
  	           ret->text=strndup(info->value, info->maxlength); /* Ensure big buffer */
  	         }
  	         else {
  	           ret->text=strndup(info->value, 1024);
  	         }
  	       } else if (info->type == inputtype_IMAGE)
  	           ret->text=strdup(info->alt);
	       break;
    }

    case TAG_SELECT: /* Check multiple bits */
                /* Right, here we go. We need to grab data until the next
                   </SELECT> */
                if ((p = strinstr(*html, "</SELECT>", size)) == NULL)
                {
                    *html=0;       /* Signal back-up */
                    RETURN(NULL);
                }
                return __html_form_parse_select(st, html, p-*html+1, ret);

    case TAG_OPTION: /* OPTION tag */
    	       ret->info=(elementinfo *)__html_malloc(sizeof(elementinfo_option), 1);
    	       if (!ret->info) { __html_free(ret, 0); return NULL; }
	       ret->style=__html_stream_style(st) | FORM;
	       ret->type=__html_stream_type(st, next_tag->tag, START);
	       /* OPTIONy bits */
	       ret->value=ATTR_STR(VALUE);
	       ret->info->option.selected = ATTR_SET(SELECTED);
	       ret->info->option.disabled = ATTR_SET(DISABLED);
	       ret->text=__html_stream_grab_pcdata(html, 1, !st->_stream_pre);
	       if (ret->text==NULL)
	       {
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
	       }
               #ifdef NEWSPACING
               __html_strip_spaces(ret->text, st->stripleadingspace, 1);
               #else
               __html_strip_spaces(ret->text, st->stripleadingcr);
               #endif
               __html_unescape_string(ret->text, 0);
               ret->indent=__html_stream_indent(st);
	       break;

    default: /* TEXTAREA */
	       ret->style=__html_stream_style(st) | FORM;
	       ret->type=__html_stream_type(st, next_tag->type, START);
	       ret->text=__html_stream_grab_pcdata(html, 1, 1);
	       if (ret->text==NULL)
	       {
	         __html_free(ret,0);
	         *html=NULL;
	         RETURN(NULL);
	       }
	       /* TextArea Bits */
	       ret->cols=ATTR_VAL(COLS);
	       ret->rows=ATTR_VAL(ROWS);
	       ret->name=ATTR_STR(NAME);
	       /*st->form_disabled = ATTR_SET(DISABLED);*/
	       __html_strip_lfs(ret->text); /* Strip CRs, preserve LFs */
	       __html_unescape_string(ret->text, 0);
	       ret->indent=__html_stream_indent(st);
	       break;
  }

  if (ret)
      fill_in_colour_info(st, ret);

  return ret;
}

HStream *__html_return_text_token(StreamTokens *st, char *doc, size_t size)
{
HStream *return_val=NULL;

  return_val=HStreamalloc(st, (tag_no)0);

  if (return_val != NULL) {

    return_val->text=strndup(doc, size);
    return_val->style=PRE | PCDATA ;
    return_val->flags = 0;


    __html_strip_lfs(return_val->text);
    __html_strip_control_codes(return_val->text);
    return_val->type=TYPE_BODY;
    return_val->tag=PCDATA;
    return_val->fontsize = 3;
  }
  return return_val;
}

#include "api.h"

/*
 * This routine is called from __html_form_handler
 * We have an HStream ready to be filled in, html points to the start
 * of the block, and size is the size of the block.
 */
static HStream *__html_form_parse_select(StreamTokens *st, char **html, int size, HStream *ret)
{
    char *ptr=*html, *p;
    HStream *h, *hp;
    StreamTokens *s;
    int count,items;
    elementinfo_select *info;

    /* Re-enter the parser - get a stream for our block, and pull out the
       OPTION tags(!) */

    #ifdef UNIFONT
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, st->usingscripts, 0, 106 /* UTF-8 */, priority_user);
    #else
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, st->usingscripts, 0, 5001 /* Acorn Latin-1 */, priority_user);
    #endif
    /* Hack hack hack! */
    s->_stream_select=1;
    h=HtmlGetStream(s, &ptr, size, NULL);
    __html_set_memory_context(st->memcontext);

    /* The format of the "value" is:
               1st word: number of options
               2nd word: flags (0)
       then per option:
               Flags byte: bit 0 = selected
                           bit 1 = disabled
               Displayed text, terminated by zero byte
               Symbolic name, terminated by a zero byte (just a zero byte if not
                                                         present)
       then to terminate
               &FF
     */
    count=8;
    items=0;
    hp=h;
    while (hp)
    {
        if (hp->tagno == TAG_OPTION)
        {
            /* If someone does <option>text<option>more text<option>text...
               everything is fine */
            count += 1 +
                     (hp->text ? strlen(hp->text) : 0) +
                     1 +
                     (hp->value ? strlen(hp->value) : (hp->text ? strlen(hp->text) : 0)) +
                     1;

            items += 1;

            /* If someone however does <option><i>text</i><option><b>more text</b>...
               then we need to include the text of the extra tags after the OPTION
               tag. Thanks, www.epson.co.uk... */
            if (hp->next && hp->next->tagno != TAG_OPTION)
            {
              HStream * op = hp->next;

              while (op && op->tagno != TAG_OPTION)
              {
                if (op->text) count += strlen(op->text);

                op = op->next;
              }
            }
        }
        hp=hp->next;
    }

    count+=1; /* (Room for 0xff to terminate, see above) */

    info=(elementinfo_select *)__html_malloc(sizeof(elementinfo_select), 1);
    ret->info=(elementinfo *)info;
    if (!info) { HtmlStreamFree(h); free(s); __html_free(ret, 0); return NULL; }

    info->options=(int *)__html_malloc(count, 1);
    info->options[0] = items;
    info->options[1] = 0;
    p = (char *) &info->options[2];
    hp=h;
    while (hp)
    {
        if (hp->tagno == TAG_OPTION)
        {
            int len;

            /* Flags byte */
            *p++=hp->info->option.selected;

            p += sprintf(p, "%s", hp->text ? hp->text : "");

            /* Strip trailing spaces */
            while (*(p-1)==' ')
                *--p='\0';

            /* As above, deal with things like <option><i>text</i>... */
            if (hp->next)
            {
              HStream * op = hp->next;

              while (op && op->tagno != TAG_OPTION)
              {
                if (op->text)
                {
                  p += sprintf(p, "%s", op->text);

                  /* Strip trailing spaces */
                  while (*(p-1)==' ')
                      *--p='\0';
                }

                op = op->next;
              }
            }

            p++;

            sprintf(p, "%s%n", hp->value ? hp->value : (hp->text ? hp->text : ""), &len); p+=len+1;
        }
        hp=hp->next;
    }

    *p=0xFF;

    assert((p+1)-(char *)info->options == count);

    HtmlStreamFree(h);
    HtmlEndParse(s);

    ret->style=__html_stream_style(st) | FORM;
    ret->type=__html_stream_type(st, TYPE_BODY, START);
    ret->indent=__html_stream_indent(st);

    info->name     = ATTR_STR(NAME);
    info->disabled = ATTR_SET(DISABLED);
    info->multiple = ATTR_SET(MULTIPLE);
    info->size     = ATTR_VAL(SIZE);
    info->tabindex = ATTR_VAL(TABINDEX);
    info->onfocus  = ATTR_STR(ONFOCUS);
    info->onblur   = ATTR_STR(ONBLUR);
    info->onselect = ATTR_STR(ONSELECT);
    info->onchange = ATTR_STR(ONCHANGE);
    info->onclick  = ATTR_STR(ONCLICK);

    fill_in_colour_info(st, ret);
    st->needtosend[TAG_SELECT] = 1;

    ptr=*html+size;

    while (*ptr!='>')
        ptr++;

    *html=ptr+1;

    return ret;
}

static HStream *__html_stream_end_form(StreamTokens *st, char **html)
{
    HStream *ret;

#ifdef UPDATEINPUT
    char *ptr;
#else
    NOT_USED(html);
#endif

    ret = HStreamalloc(st, TAG_FORM_END);
    if (ret)
    {
        ret->style=__html_stream_style(st) | FORM;
        ret->type=__html_stream_type(st, TYPE_BODY, END);
        ret->indent=__html_stream_indent(st);
        ret->tag=FORM;
        fill_in_colour_info(st, ret);
    }

#ifdef UPDATEINPUT
  /*
   * This routine is called with the understanding that it will update
   * the HTML pointer. Move it to past the next > or the end of the input
   * whichever is sooner. In theory it should be the former.
   */
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
#endif

    return ret;

}

HStream *HStreamalloc(StreamTokens *st, tag_no tagno)
{
    HStream *ret;

    if (tagno == TAG_TABLE) ret = (HStream *)__html_malloc(sizeof(table_stream), 1);
    else                    ret = (HStream *)__html_malloc(sizeof(HStream),      1);

    if (ret)
    {
        ret->parent = st->current_cell;
        ret->tagno = tagno;
    }

    return ret;
}

static int my_strncasecmp(const char *a, const char *b, unsigned int n)
{
    while( *a && *b && n-- )
	if( tolower(*a++) != tolower(*b++) )
	    return 1;

    return 0;
}


static HStream *__html_stream_script(StreamTokens *st, char **html, int size, const char *term, tag_no tagno)
{
    char *ptr = *html;
    int termlen = strlen(term);
    char term0 = term[0];

    while (size)
    {
        if (*ptr == term0)
        {
            if (size < termlen)
                RETURN(NULL);

            if (my_strncasecmp(ptr, term, termlen)==0)
            {
                HStream *ret;

                st->state = Other;
                /* Produce a return token with the data in the text field */
                ret = HStreamalloc(st, tagno);
                if (ret)
                {
                    /*ret->style = __html_stream_style(st);*/
                    ret->type = __html_stream_type(st, TYPE_HEAD, START);
                    ret->text = strndup(*html, ptr - *html);

                    /*
                     * According to HTML 4, the script contents are CDATA and should
                     * be unescaped. So if we wanted to output a single ampersand into
                     * the stream with document.write, you must do:
                     *
                     *   document.write("&amp;amp;");
                     *
                     * The first '&amp;' gets unescaped here, then the second when the
                     * script callback function has gone off and the document.write code
                     * in the client - if any - has returned our '&' followed by the
                     * second occurrence of 'amp;' to give '&amp;'.
                     *
                     * However, Navigator and Explorer *do not* unescape the string, and
                     * whilst they're broken, so is every script on the planet that uses
                     * entites. So guess what? We have to break our script handling too.
                     */

                    /* __html_unescape_string(ret->text, 0); */

                    ret->name = ATTR_STR(LANGUAGE);
                    ret->src = ATTR_STR(SRC);
                    if (tagno == TAG_SCRIPT && st->script_callback && st->usingscripts)
                    {
                        char *toinsert = st->script_callback(st, ret, st->script_callback_handle);
                        if (toinsert)
                        {
                           st->insertion = toinsert;
                        }
                    }
                }
                ptr += termlen;
                if (!st->_stream_pre)
                    *html = __html_skip_record_end(ptr, 1);
                else
                    *html = ptr;
                st->stripleadingspace = 1;
                return ret;
            }
        }
        ptr++;
        size--;
    }

    RETURN(NULL);
}

/* parse_rowcols (local)
 *
 *   ptr -> FRAMESET ROWS=""/COLS="" data to parse
 *   values = NULL:
 *      put number of data into number
 *   value != NULL:
 *      put data into values array
 *
 * counts number of data items, or puts data items in an array
 */

static void parse_rowcols (char *ptr, unsigned int *values, unsigned int *number) {

  unsigned int value;

  if (!values) *number = 0;

  do {
    while (isspace(*ptr) || isalpha(*ptr)) ptr++;
    value = 0;
    if (isdigit(*ptr)) {
      value = (unsigned int) strtol (ptr, &ptr, /*base=*/10);
    }
    while (isspace(*ptr) || isalpha(*ptr)) ptr++;
    if (*ptr == '*') {

      if (!value) value = 1;
      value |= ROWCOL_STAR;
      ptr++;

    } else if (*ptr == '%') {

      /* Navigator handles a single '%' as '100%', it seems */

      if (!value) value = 100;
      value |= ROWCOL_PERCENT;
      ptr++;
    }
    while (isspace(*ptr) || isalpha(*ptr)) ptr++;
    if (*ptr == ',') {
      ptr++;
    }
    while (isspace(*ptr) || isalpha(*ptr)) ptr++;

    if (values) {
      *values++ = value;
    } else {
      *number += 1;
    }

  } while (isdigit (*ptr) || *ptr == '*' || *ptr == '%');
}

/********************************************************************/
/* static HStream *__html_map_handler(char **html)                  */
/********************************************************************/
/* Given an map tag, prepare a new MapStream.              	    */
/********************************************************************/
static HStream *__html_map_handler(StreamTokens *st)
{
    MapStream *map;

    /* Need a name */
    if (!ATTR_STRPEEK(NAME)) return NULL;

    map = (MapStream *) __html_malloc(sizeof(MapStream), 1);
    if (!map) return NULL;

    map->name = ATTR_STR(NAME);
    map->next = st->maps->next;
    st->maps->next = map;
    st->_stream_map = 1;

    return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_area(char **html)                  */
/********************************************************************/
/* Given an area tag, extract the relevant information              */
/* associated with this tag and present it as an <A> element,       */
/* attached to the current map.                         	    */
/********************************************************************/
static HStream *__html_stream_area(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream *ret, **prev;

  NOT_USED(next_tag);

  if (!st->_stream_map) return NULL;

  /* Fill in an HStream */
  ret = __html_stream_return_tag(st, next_tag, html, 1);
  if (!ret)
      return NULL;

  ret->style |= A;

  /* Get the coordinates */
  if (ATTR_SET(COORDS))
      ret->coords = ATTR_COORDS(COORDS);
  else if (ATTR_VAL(SHAPE) == areashape_DEFAULT)
      /* If no coordinates, and shape = DEFAULT, that's okay - put in a dummy coords block. */
      ret->coords = (int *) __html_malloc(sizeof(int), 2);

  if (!ret->coords)
  {
      __html_free(ret, 0);
      return NULL;
  }

  ret->coords[0] = ATTR_VAL(SHAPE);

  ret->anchor = ATTR_STR(HREF);

  if (ATTR_SET(TARGET))
      ret->target = ATTR_STR(TARGET);
  else
      ret->target = strdup(st->target);

  if (ATTR_SET(ALT))
      ret->text = ATTR_STR(ALT);
  else
      ret->text = strdup(ret->anchor);

  for (prev = &st->maps->next->stream; *prev; prev = &(*prev)->next)
      continue;

  *prev = ret;

  return NULL;
}

/********************************************************************/
/* static HStream *__html_skip_record_end(char *s)                  */
/********************************************************************/
/* Skip over record ends (RE) (line feed). Need to cope with there  */
/* being spaces at the end of lines or start of the last line.      */
/********************************************************************/
static char *__html_skip_record_end(const char *s, int skip_leading)
{
    const char *p = s;
    bool found_re = false;

    while ((*p == ' ' || *p == 10 || *p == 13) && !(found_re && !skip_leading && *p == ' '))
    {
        if (*p != ' ')
            found_re = true;

        p++;
    }

    return (char *) (found_re ? p : s);
}

static HStream *__html_stream_q(StreamTokens *st, char **html, int start)
{
    HStream *ret;
    static const char quote[2][2][4] =
    {
        #ifdef UNIFONT
        "", "", "", ""
        #else
        "",   "",   "",   ""
        #endif
    };

#ifdef UPDATEINPUT
    char *ptr;
#else
    NOT_USED(html);
#endif

    ret = HStreamalloc(st, (tag_no)0);
    if (ret)
    {
        ret->text = strdup(quote[st->_stream_q & 1][start]);
        ret->style=__html_stream_style(st) | PCDATA;
        ret->type=__html_stream_type(st, TYPE_BODY, START);
        ret->indent=__html_stream_indent(st);
        ret->tag=PCDATA;
        st->lastwaspcdata = 1;
        fill_in_colour_info(st, ret);
        memset(st->needtosend, 0, sizeof st->needtosend);
        if (st->_stream_anchor != NULL)
        {
            ret->anchor=st->_stream_anchor->href;
            #ifdef CUSTOMER_SPECIAL
            ret->onclick=st->_stream_anchor->onclick;
            #endif
            ret->name=st->_stream_anchor->name;
            st->need_to_send_name=0;
            ret->target = st->_stream_anchor->target;
        }
    }

    st->_stream_q += start ? +1 : -1;

#ifdef UPDATEINPUT
  /*
   * This routine is called with the understanding that it will update
   * the HTML pointer. Move it to past the next > or the end of the input
   * whichever is sooner. In theory it should be the former.
   */
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
#endif

    return ret;

}

@


1.22
log
@  Handle font colours inside anchors.
Detail:
  For code that changes font before the anchor, the link should be shown
  at link colour in a browser. For code that changes after, the link should
  be shown according to the colour specifier. It's the difference between
  <a href...><font color...>Link</font></a> and
  <font color...><a href...>Link</a></font>. Browse could never tell the
  difference previously so always used the link colour, but lots of sites
  these days seem to have a background colour that clashes with the link
  colour and use <font> tags to sort it out (ick). The solution is to stack
  the existing font settings on <a> and unstack on </a> (if there are any).
  Claimed a bit in COLOUR_INFO (internal.h) from the 'size' field to record
  if this was done - otherwise every anchor would have a stacked colour
  attached which is pretty inefficient.
Admin:
  Tested with a debug Browse and "production" Phoenix build, ensured the
  stack in/stack out behaviour is correct with TML debug in the library.
  Requires a Redraw.c in the browser from 02-Mar-2000 (15:30pm) or later.
@
text
@d1509 2
@


1.21
log
@Various fixes. Attribute parser would hang when faced with '...VALUE=>'.
Entites which were a substring match of other entities in name (possible
in HTML 4 but not previously) would get mismatched in HTML (the shorter
always being picked and extra letters left over getting spat out to the
page). Solved by having a seperate try-first table of substring matching
entities.

New feature (sort of). Entities in URLs were never escaped as the
existing relaxed entity parser would often mangle CGI-style URLs. There
is now a strict unescaping mode used for URLs which seems to sort out
various sites where this was a problem.

Makefile exports to 'Lib$Dir' rather than 'HTMLLib:' to fit in with
current build environments.
@
text
@d1015 20
a1034 1
      case TAG_A:      __html_stream_anchor(st, html, next_tag); break;
d1274 10
@


1.20
log
@Cleaned up a bit - any remaining build-time warnings are intentional
reminders that something needs attention. Adjusted CC flags as part
of this.

Corrected misleading comments on a couple of functions (a case of
Cut And Paste by the looks of things).

Rewrote element attribute parsing. As far as I can tell this now
behaves just as in Navigator 4.07 - fixed a large number of
reported bugs as a result. On the whole these are usually down to
spurious trailing closing quotes with no matching opening quote,
though there are some rather more exotic cases that now work
as intended.

Now remove CR and LF from attribute values rather than replacing
them with spaces - yet more sites fixed - and strip trailing spaces
from URLs (Ofsted's PDFs are now much easier to download...).
@
text
@d204 1
a204 1
        __html_unescape_string(return_val->text);
d216 1
a216 1
        __html_unescape_string(return_val->text);
d639 1
a639 1
    if (st->_stream_p)           { return_val |= P; st->_stream_p=0; }
d641 1
a641 1
    if (st->_stream_pre)	    return_val |= PRE;
d645 1
a645 1
        if (st->_stream_dl)	    return_val |= DL;
d648 1
a648 1
        if (st->_stream_ul)	    return_val |= UL;
d776 2
a777 1
  } else if (*end == '&')
d795 1
d955 1
d968 1
d1168 4
d1209 14
a1222 1
      st->_stream_dd=st->_stream_dl ? 1 : 0;
d1230 5
a1238 4
    case TAG_DT:
      st->_stream_dt = 0;
      break;

d1995 1
a1995 2
/* keep them in one bit. NOTE: LINKS WITHIN FORMS ARE DUFF AT THE   */
/* moment due to an earlier oversight. Fix soon	      	      	    */
d2119 1
a2119 1
               __html_unescape_string(ret->text);
d2129 3
a2131 3
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
d2138 3
a2140 3
                __html_strip_lfs(ret->text); /* Strip CRs, preserve LFs */
               __html_unescape_string(ret->text);
               ret->indent=__html_stream_indent(st);
d2439 2
a2440 1
                    /* __html_unescape_string(ret->text); */
@


1.19
log
@Didn't correctly deal with <noscript> vs. <script> when JS support was
flagged as 'on' or 'off' in the relevant parameter to HtmlParse.
@
text
@d1352 3
d1356 3
a1358 1
  elementinfo_object *info;
a1493 1
  char        *ptr;
d1497 6
d1677 1
a1677 2
  HStream     *return_val;
  char        *ptr;
d1739 1
a1739 2
  HStream     *return_val;
  char        *ptr;
d1899 2
d1902 3
d2317 2
d2320 4
a2604 1
    char *ptr;
d2613 6
@


1.18
log
@MAP containers may hold A elements as well as AREA, in accordance with
the release HTML 4 spec. The description of client side image maps is
significantly different from the November '97 draft which HTMLLib was
coded towards. The previous behaviour (use of a 'shapes' attribute on
OBJECT etc.) has been retained for backwards compatibility with the
few web sites that use this earlier notation.
@
text
@d135 1
d137 1
d140 4
a143 2
      /* Don't handle SCRIPT or STYLE at the moment, but lets parse over it */
      /* - don't do NOSCRIPT either, let the browser write that if it wants */
d149 4
a152 1
      if (st->usingscripts) return __html_stream_script(st, html, size, "</NOSCRIPT>", TAG_NOSCRIPT);
d154 1
d156 1
d1056 15
a1070 7
      case TAG_TITLE:  st->_stream_title++; break;
      case TAG_BASE:   __html_stream_base(st); break;
      case TAG_ISINDEX: st->_stream_isindex=1; break;
      case TAG_SCRIPT:  st->state = Script; return NULL;
      case TAG_NOSCRIPT:st->state = NoScript; return NULL;
      case TAG_STYLE:   st->state = Style; return NULL;
      case TAG_FRAME:   return __html_stream_frame(st, html, next_tag);
@


1.17
log
@Passes value of LANGUAGE attribute on SCRIPT element through the 'name' field
@
text
@d53 2
d1545 2
d1583 55
@


1.16
log
@Euro sign mapping added to display.c's ISO10646 -> Acorn Extended Latin-1
transformation table. HtmlParse can be told whether or not it supports
JavaScript (if so, script callback function is called and <NOSCRIPT> contents
are ignored; else script callback function is not called and <NOSCRIPT> is
parsed, with <SCRIPT> contents just passed through). In veneers.c, names of
parameters to HtmlParse changed to match those in api.h.
@
text
@d1626 7
d1700 7
d2325 1
@


1.15
log
@The contents of <script> is CDATA according to HTML 4, so HTMLLib unescaped
entities in it before passing the script to the client through the callback
function (if one was registered). However, Navigator fails to do this and
HTMLLib's script handling has been broken to match. This is acknowledged as
a bug by the Mozilla team but it can't be fixed as it would stop existing
scripts working properly. (MSIE mimics the bug too).
@
text
@d139 1
d141 1
d143 1
a143 1
      return __html_stream_script(st, html, size, "</NOSCRIPT>", TAG_NOSCRIPT);
d2067 1
a2067 1
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, 0, 106 /* UTF-8 */, priority_user);
d2069 1
a2069 1
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, 0, 5001 /* Acorn Latin-1 */, priority_user);
d2312 1
a2312 1
                    if (tagno == TAG_SCRIPT && st->script_callback)
@


1.14
log
@Shouldn't crash when it hits </option> in <select> lists now (oops).
Fixed buffer juggling done then <script> callback function returns data
to be written into the document; utf_end wasn't being correctly updated.
NOSCRIPT is now dealt with in the same way as STYLE - passed through as
raw text, but won't be parsed.
@
text
@d2290 19
a2308 1
                    __html_unescape_string(ret->text);
@


1.13
log
@As well as skipping over isspace() characters in parse_rowcols, which parses
the row / column information in a relevant <frameset> attribute string, the
function now skips over isalpha() characters at the same time. Deals with
strings like "<frameset rows='30 pixels , * , 50 pixels'>", seen at some
sites.
@
text
@d137 1
d140 2
d1047 1
d2112 1
a2112 1
                count += op->text ? strlen(op->text) : 0;
d2141 1
a2141 1
            p += sprintf(p, "%s", hp->text ? hp->text : '\0');
d2154 3
a2156 1
                p += sprintf(p, "%s", op->text ? op->text : '\0');
d2158 4
a2161 3
                /* Strip trailing spaces */
                while (*(p-1)==' ')
                    *--p='\0';
d2169 1
a2169 1
            sprintf(p, "%s%n", hp->value ? hp->value : (hp->text ? hp->text : '\0'), &len); p+=len+1;
d2297 1
a2297 1
                            st->insertion = toinsert;
@


1.12
log
@Daft bug in <option> element handling fixed. <script> element is no
longer block level, to try and avoid white space problems with calls
to document.write(). MemLib stuff in internal.h can be switched on by
cleaning the build, defining USE_MALLOC_REPLACEMENT on the CC command
line and rebuilding.
@
text
@d2328 1
a2328 1
    while (isspace(*ptr)) ptr++;
d2333 1
a2333 1
    while (isspace(*ptr)) ptr++;
d2348 1
a2348 1
    while (isspace(*ptr)) ptr++;
d2352 1
a2352 1
    while (isspace(*ptr)) ptr++;
@


1.11
log
@New function, __html_stream_cancel_align, used in various places to cancel
the stored <P ALIGN...> value. HTMLLib now cancels alignment after OL, UL,
DL, LI, DD and DT (I noticed these omissions when viewing TechWriter 4.10's
HTML output in Browse).
@
text
@a2090 1

a2101 1

d2106 1
a2106 1
              while (op->tagno != TAG_OPTION)
d2116 2
a2117 1
    count+=1;
d2137 1
a2137 3
            if (hp->text)
            {
              p += sprintf(p, "%s", hp->text);
d2139 3
a2141 4
              /* Strip trailing spaces */
              while (*(p-1)==' ')
                  *--p='\0';
            }
d2148 1
a2148 1
              while (op->tagno != TAG_OPTION)
d2150 5
a2154 8
                if (op->text)
                {
                  p += sprintf(p, "%s", op->text);

                  /* Strip trailing spaces */
                  while (*(p-1)==' ')
                      *--p='\0';
                }
d2166 1
d2168 1
@


1.10
log
@Images (from IMG elements only at present) have an info field in their
internal structure, with 'hspace' and 'vspace' filled in - so you can
now use HtmlOBJECTvspace / HtmlOBJECThspace to get at this information
for both IMG and OBJECT elements (as with macros OBJECT_HAS_WIDTH etc.)
@
text
@d38 1
d796 1
a796 1
/* it setting the correct bits in the various status words	    */
d798 1
a798 1
/* ease of code reading		     	      	    	       	    */
d856 1
a856 8
      case TAG_PRE: /* Block level element - cancels previous alignment settings */

                    if (st->_stream_palign)
                    {
                        st->_stream_palign = 0;
                        st->_stream_centre = st->_stream_oldcentre;
                        st->_stream_right = st->_stream_oldright;
                    }
d864 1
a864 8
      case TAG_H6: /* Block level element - cancels previous alignment settings */

                   if (st->_stream_palign)
                   {
                       st->_stream_palign = 0;
                       st->_stream_centre = st->_stream_oldcentre;
                       st->_stream_right = st->_stream_oldright;
                   }
d873 3
a875 1
      case TAG_UL:     st->_stream_ul++;  /* Needed for indent level */
d882 15
a896 12
      case TAG_OL:     st->_stream_ol++;  /* Needed for indent level */
                       if (st->_stream_ol + st->_stream_ul <= MAX_OL)
                       {
                           int start = ATTR_VAL(STARTattr);
                           int style = ATTR_VAL(TYPE);
                           if (ATTR_SET(STARTattr))
                               start--;
                           if (!style)
                               style = '1';
                           st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] = start;
                           st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = style;
                       }
d898 4
a901 1
      case TAG_DL:     st->_stream_dl++;  /* Needed for indent level */
d911 2
d930 2
a931 1
      case TAG_DT:     if (st->_stream_dt || !st->_stream_dl)
d941 3
a943 1
      case TAG_DD:     if (st->_stream_dd || !st->_stream_dl)
d984 1
a984 6
      case TAG_DIV:    if (st->_stream_palign)
                       {
                           st->_stream_palign = 0;
                           st->_stream_centre = st->_stream_oldcentre;
                           st->_stream_right = st->_stream_oldright;
                       }
d1072 18
d1138 1
a1138 6
      if (st->_stream_palign)
      {
          st->_stream_palign = 0;
          st->_stream_centre = st->_stream_oldcentre;
          st->_stream_right = st->_stream_oldright;
      }
@


1.9
log
@The sequence <option value=""> followed by a comment would lead to some
characters from zero page being spat out as menu entries; the browser
then failed with "Illegal character in font string" when it tried to do
things with those entries. NULL values in [HStream]->text are now
correctly checked for and dealt with in __html_form_parse_select().
@
text
@d1318 3
a1320 2
  HStream     *return_val;
  char        *ptr;
d1344 1
d1346 9
d1418 1
a1418 1
                                          return_val->anchor ? 2 : 0;
d1427 3
a1430 4

  return_val->tag=IMG;
  return_val->indent=__html_stream_indent(st);
  fill_in_colour_info(st, return_val);
@


1.8
log
@Multiple text tags inside one <OPTION> container are "glued together",
so HTML such as '<OPTION>Some <I>italicised</I> entries' will generate
meaningful menu entries.

<PRE> and <Hn> elements now cancel <P ALIN="...">, whereas they did
not before. This is special-cased for those elements, based on the
code already in place for <DIV>.
@
text
@d1925 1
d2075 1
a2075 1
                     strlen(hp->text) +
d2077 1
a2077 1
                     (hp->value ? strlen(hp->value) : strlen(hp->text)) +
d2120 3
a2122 1
            p += sprintf(p, "%s", hp->text);
d2124 4
a2127 3
            /* Strip trailing spaces */
            while (*(p-1)==' ')
                *--p='\0';
d2151 1
a2151 1
            sprintf(p, "%s%n", hp->value ? hp->value : hp->text, &len); p+=len+1;
d2174 1
@


1.7
log
@Added some tolerance of mismatched quotes in tags
@
text
@d855 10
a864 1
      case TAG_PRE:        st->_stream_pre++; break;
d870 14
a883 3
      case TAG_H6:     st->_stream_h=next_tag->tag;
                       st->_stream_halign=ATTR_VAL(ALIGN);
                       break;
d1687 1
a1687 1
/* associated with this tag.  	      	  	   		    */
d1703 3
d2070 3
d2080 16
d2119 2
a2120 1
            sprintf(p, "%s%n", hp->text, &len); p+=len;
d2124 21
d2146 1
@


1.6
log
@Now correctly stores contents of SCRIPT elements
@
text
@d114 1
d308 8
d336 1
d1590 1
a1590 1
  *html += __html_tag_length(*html + 1) + 1;
d1658 1
a1658 1
  *html += __html_tag_length(*html + 1) + 1;
d1847 1
a1847 1
    ptr = *html += __html_tag_length(*html + 1) + 1;
@


1.5
log
@Can now cope with < or > characters in quoted attributes
@
text
@a2182 6
                ptr += termlen;
                if (!st->_stream_pre)
                    *html = __html_skip_record_end(ptr, 1);
                else
                    *html = ptr;
                st->stripleadingspace = 1;
d2189 1
a2189 1
                    ret->text = strndup(*html, ptr - *html - 1);
d2201 6
@


1.4
log
@Removed unused function HTTPEscapeString.
Added SCRIPT element callback function with provision for source insertion.
@
text
@d308 13
a320 2
  while ((ptr-start < size) && (*ptr != '\0') && (*ptr != '>') &&
                             (*ptr != '<')) {
d323 1
d1392 1
d1402 1
d1461 1
d1471 1
d1580 1
a1580 10
/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

d1648 1
a1648 5
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

d1771 1
d1783 1
d1837 1
a1837 4
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
d2123 1
d2133 1
d2410 1
d2420 1
@


1.3
log
@Web branch merged
@
text
@d106 1
a106 1
                              int size, HStream *prevhs)
d2179 6
d2193 9
a2202 5
                if (!st->_stream_pre)
                    *html = __html_skip_record_end(ptr, 1);
                else
                    *html = ptr;
                st->stripleadingspace = 1;
@


1.2
log
@Merged in ARTtmp_merge
@
text
@a14 22
/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/new_stream,v $
 *
 * $Log: new_stream,v $
 * Revision 1.1.2.3  1997/04/28 14:20:19  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
 * Revision 1.1.2.2  1997/04/09 16:44:37  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:26:46  kbracey
 * Initial revision
 *
 * Revision 1.1  95/10/31  13:12:14  pwain
 * Initial revision
 *
 */

d17 1
d23 1
d36 1
a36 5
static unsigned int __html_stream_style(StreamTokens *st);
static unsigned int __html_stream_type(StreamTokens *st,
                              unsigned int style, int start);
static unsigned int __html_stream_indent(StreamTokens *st);
static    HStream * __html_stream_start_tag(StreamTokens *st, Tag next_tag,
d38 1
a38 1
static    HStream * __html_stream_end_tag(StreamTokens *st, Tag next_tag,
d40 1
d42 6
a47 1
                              Tag next_tag, char *url);
d49 1
a49 1
                              Tag next_tag, char *url);
d51 1
a51 1
                              Tag next_tag, char *url);
d53 4
a56 3
                              Tag next_tag, char *url, int size);
static    HStream * __html_stream_base(StreamTokens *st, char **html,
                              Tag next_tag, char *url);
d58 1
d60 7
a66 6
static    HStream * __html_form_handler(StreamTokens *st, Tag next_tag,
                              char **html, char *url, int size);
/*static*/HStream * __html_stream_return_tag(StreamTokens *st, Tag tag,
                              char **html, int start, char *url);
static 	     char * __html_stream_grab_pcdata(char **input, int size,
                              int contig);
a68 1
static         void strdoublecpy(char *buffer, char *s1, char *s2);
d71 8
a86 6
/* A few preprocessor definitions to make life easier.              */
/********************************************************************/
#define START 1
#define END   0

/********************************************************************/
d109 1
a109 1
  Tag     next_tag;
d118 7
d128 14
d162 1
a162 1
  if ((*ptr != '<') && (st->_stream_comment==0)) {
d166 1
a166 1
      *html=(*html)+sizeof(char);
d171 1
a171 1
    return_val=HStreamalloc();
d174 5
a178 3
      return_val->flags = 0;
      return_val->text=__html_stream_grab_pcdata(html, size, 0);
      return_val->style=__html_stream_style(st) | PCDATA ;
d183 2
a184 2
      if (((return_val->style & PRE) == PRE ) ||
      	   ((return_val->style & TEXTAREA) == TEXTAREA)) {
d205 1
a205 1
      return_val->type=__html_stream_type(st,return_val->style,START);
d212 1
a212 1
 * If the tag is in the head, or it is not a special once-only tag,
d216 1
a216 3
      if (((return_val->type & HEAD) == HEAD) ||
           (return_val->type & BODY) &&
              !(return_val->style & (P|BR|DL|OL|UL|DIR))) {
d243 4
a246 1
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
d248 2
a251 5
/* Otherwise set it to a NULL */
      else {
        return_val->anchor=NULL;
        return_val->name=NULL;
      }
d258 1
a258 4
      return_val->src=NULL;
      return_val->next=NULL;
      return_val->prev=NULL;
      st->needtosend=0;
d260 1
a260 1
      st->stripleadingspace=0;
d285 13
a302 27
 * The next case we have to deal with is that of a comment. This can
 * be done on the fly too. Basically if we have a '<!--' or were in
 * a comment already, see if we have a '-->' on the input stream.
 * If we do, skip to the end of the '-->' otherwise wait until more
 * information is avaliable.
 */
  if ((!strncmp(ptr,"<!--",4)) || st->_stream_comment) {
/* Look to see if  we have a '-->' pending on the input */
    ptr=strnstr(ptr,"-->",size /*- (ptr-start) */);
    if (ptr != NULL) {
/* We do, so skip over it. Turn off the comment flag. */
      st->_stream_comment=0;
      *html=ptr+3;
/* A comment is a NULL token. */
      return NULL;
    }
    else {
/*
 * We didnt find the end of the comment. Set the comment flag, and return
 * setting __html_done_for_now on the way out.
 */
      st->_stream_comment=1;
      RETURN(NULL);
    }
  }

/*
d313 3
d345 1
a345 1
    if (lastwaspcdata && prevhs && prevhs->text)
d352 2
d360 3
a362 1
  next_tag=__html_find_tag(&tag_start,0);
d364 21
a384 27
/* The start tag case */
  if (!NULL_TAG(next_tag)) {
/*
 * If the tag we have is a tag that we need to notify the termination
 * of, then send back a NULL tag that terminates all the tags we need
 * to before returning this tag. We can do this by not moving the html
 * data pointer before returning.
 */
    if ((st->needtosend & next_tag.tag) == next_tag.tag && next_tag.tag
#ifdef TonyTables
        && !__html_current_table
#endif
       )
    {
        return_val=__html_stream_return_tag(st, Null_Tag, NULL, END, st->url);
    }
    else
    {
        char *p=*html;
/*
 * Otherwise do what we need to with this pointer before returning
 * any token that it generates.
 */
      if (lastwaspcdata && next_tag.implicit_lf_before && prevhs && prevhs->text)
      {
        __html_strip_trailing_spaces(prevhs->text);
        if (prevhs->text[0]=='\0')
d386 26
a411 2
          __html_free(prevhs->text, 0);
          prevhs->text=0;
d413 1
d415 14
d430 4
a433 9
      return_val =  __html_stream_start_tag(st,next_tag, &p, url, size);
      /* More hackery - some tags swallow PCDATA - if the routine returns
         NULL, that indicates a tag that needs more PCDATA */
      if (p>ptr)
        *html=p;
      else if (p!=NULL)
        *html=ptr;
    }
    return return_val;
d436 21
d458 26
a483 2
/* Otherwise it was an end tag? */
  next_tag=__html_find_tag(&tag_start,1);
d485 2
a486 4
  if (!NULL_TAG(next_tag)) {
/* Register that we have an end tag */
    return_val = __html_stream_end_tag(st, next_tag, html, url, size);
    *html=ptr;
d488 6
a493 2
   return return_val;
  }
d495 26
a520 1
/* Update the pointer and return. This skips unwanted tags etc. */
d522 3
a524 1
  *html=ptr;
d526 2
a527 1
  return return_val;
d530 45
d584 1
a584 1
static unsigned int __html_stream_style(StreamTokens *st)
d588 1
d593 2
a594 1
    if (st->_stream_bold)	    return_val |= BOLD;
d596 5
a600 4
    if (st->_stream_tt)	    	    return_val |= TT;
    if (st->_stream_a)	    	    return_val |= A;
    if (st->_stream_img)	    return_val |= IMG;
    if (st->_stream_p)	          { return_val |= P; st->_stream_p=0; }
a607 3
      if (st->send_list & OL) {
        if (st->_stream_ol)	    return_val |= OL;
      }
a610 3
      if (st->send_list & DIR) {
        if (st->_stream_dir)	    return_val |= DIR;
      }
d619 17
a635 1
    if (st->_stream_center)	    return_val |= CENTER;
d637 1
a637 7
    if (st->_stream_form)     	    return_val |= FORM;
    if (st->_stream_select)	    return_val |= SELECT;
    if (st->_stream_textarea)	    return_val |= TEXTAREA;
    #ifdef TonyTables
    if (st->_stream_table)          return_val |= TABLE;
    #endif
  }
d651 1
a651 1
static unsigned int __html_stream_type(StreamTokens *st, unsigned int style, int start)
d653 1
a653 1
  unsigned int temp=0;
d655 2
a656 3
/* if ((st->_stream_head) || (st->_stream_title)) temp=((unsigned int)1<<0); */
  if (st->_stream_title || st->_stream_head) {
    temp=((unsigned int)HEAD);
a657 3
#ifdef FRAMESUPPORT
  } else if (st->_stream_body) {
    temp = TYPE_BODY;
d661 1
a663 1
#endif
a667 12
/* Draw together the anchor and form bits just in case :) */
  if (st->_stream_anchor != NULL) {
    temp |= ((unsigned int)(st->_stream_anchor->alignment) <<TYPE_ALIGN_SHIFT);
    temp |= ((unsigned int)(st->_stream_anchor->ismap)     <<TYPE_ISMAP_SHIFT);
  }
  if (st->_stream_forms != NULL) {
    temp |= ((unsigned int)(st->_stream_forms->type)       <<TYPE_INPUT_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->method)     <<TYPE_METHOD_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->checked)    <<TYPE_CHECKED_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->multiple)   <<TYPE_MULTIPLE_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->selected)   <<TYPE_SELECTED_SHIFT);
  }
d682 1
a682 1
static unsigned int __html_stream_indent(StreamTokens *st)
d687 1
a687 2
  	 	         st->_stream_ul +
  	 	         st->_stream_dir);
d713 1
a713 1
static char *__html_stream_grab_pcdata(char **input, int size, int contig)
d715 1
a715 1
  char *end=*input;
d718 5
d728 1
a728 1
  while ((end - *input < size) && (*end != '\0') && (*end != '<') && (*end != '&'))
d734 1
a734 2
  if ((end-*input) >= size) {
    end=(*input)+size;
d742 1
a742 1
      for (stop = end + 1; isalnum(*stop) || *stop=='#' || *stop=='&'; stop++)
d747 2
a748 2
        end = stop + 1;
        goto carryon;
d752 2
a753 2
        end = stop;
        goto carryon;
d777 1
a777 1
static HStream *__html_stream_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
a781 12
/*
 * we have a start tag. Big case statement alert - work from the bottom
 * of the list upwards for safty :)
 */
#ifndef TABLE_SUPPORT
    if (next_tag.tag >= BR) {
/*
 * We have a body only element so if we were in the head stage
 * we should toggle to the body stage
 */
    }
#endif
d783 1
d785 2
a786 1
    switch(next_tag.tag) {
d788 4
a791 4
      case TR:
      case TD:
      case TH:
      case TABLE:      return __html_stream_return_tag(st,next_tag,html,END,url);
d793 52
a844 31
      case INPUT:
      case SELECT:
      case OPTION:
      case TEXTAREA:   if (st->_stream_form==0) break;
      case FORM:       return __html_form_handler(st, next_tag, html, url, size);
      case FONT:       {
                         AnchorInfo *anc;
                         /*
                          * __html_get_anchor_info will examine the size/colour information in
                          * the tag, and will update st. We don't actually want the AnchorInfo
                          * structure generated...
                          */
                         anc = __html_get_anchor_info(st, html, next_tag);
                         __html_stream_free_anchor(&anc);
                         break;
                       }
      case CENTER:     st->_stream_center++; break;
      case ADDRESS:    st->_stream_address++; break;
      case BLOCKQUOTE: st->_stream_blockquote++; break;
      case PRE:	       st->_stream_pre++; break;
      case H1:
      case H2:
      case H3:
      case H4:
      case H5:
      case H6:
      case H7:         st->_stream_h=next_tag.tag; break;
      case DIR:	       st->_stream_dir++; /* Needed for indent level */
      	   	       st->send_list|=DIR;
      	   	       break;
      case UL:	       st->_stream_ul++;  /* Needed for indent level */
d846 4
d851 12
a862 2
      case OL:	       st->_stream_ol++;  /* Needed for indent level */
      	   	       st->send_list|=OL;
d864 1
a864 1
      case DL:	       st->_stream_dl++;  /* Needed for indent level */
d871 27
a897 3
      case LI:	       st->_stream_li++; /* Needed for indent level? */
                       return __html_stream_return_tag(st,next_tag,html,START,url);
      case DT:	       st->_stream_dt=1; /* Needed for indent level? */
d899 9
a907 2
      	   	       return __html_stream_return_tag(st,next_tag,html,START,url);
      case DD:	       st->_stream_dd=1; /* Needed for indent level? */
d909 2
a910 1
      	   	       return __html_stream_return_tag(st,next_tag,html,START,url);
d912 2
a913 3
      case HR:	       return __html_stream_hr(st, html, next_tag, url);
      case BR:	       return __html_stream_return_tag(st,next_tag,html,START,url);
      default: {
d920 80
a999 48
        if (__html_check_tag(Body_Tags,MAX_BODY_TAGS,
               	       	              next_tag.start_tag))
        {
          switch(next_tag.tag) {
            case P:      st->_stream_p=1; break;
            case IMG:    return __html_stream_image(st,html, next_tag, url);
            case A:      __html_stream_anchor(st, html, next_tag, url); break;
            case TT:     st->_stream_tt++; break;
            case ITALIC: st->_stream_italic++; break;
            case BOLD:	 st->_stream_bold++; break;
            #ifdef TonyTables
            case TR:     return __html_table_row_start_tag(st, next_tag, html, url, size);
            case TD:     return __html_table_data_start_tag(st, next_tag, html, url, size);
            case TH:     return __html_table_head_start_tag(st, next_tag, html, url, size);
            case TABLE:  st->_stream_table++;
                         return __html_table_start_tag(st, next_tag, html, url, size);
            #endif
          }
       } else if ((__html_check_tag(Head_Tags, MAX_HEAD_TAGS,
             		           next_tag.start_tag)) != NULL) {
          switch(next_tag.tag) {
            case NEXTID:
            case META:
            case LINK:   //st->_stream_head=1;
            	         break; /* We are ignoring these for now */
            case TITLE:  st->_stream_title++; break;
            case BASE:   __html_stream_base(st, html, next_tag, url); break;
            case ISINDEX: st->_stream_isindex=1; st->_stream_head=1; break;
          }
        } else
#ifdef FRAMESUPPORT
        /* Slightly contrived code follows: this only has an else clause, largely to
         * keep the structure of the 'else if' chain, thus allowing for easy future
         * expansion - TGR */

        if (__html_check_tag(Frameset_Tags, MAX_FRAMESET_TAGS, next_tag.start_tag)
           && next_tag.tag == FRAME) {
             return __html_stream_frame (st, html, next_tag, url, size);
        } else
#endif
        {
          switch(next_tag.tag) {
            case HEAD: st->_stream_head=1; break;
            case BODY: {
              if (st->_stream_head != 0) { // use to be (.. >= 1)
                st->_stream_head=0;
                st->_stream_body=1;
                /* return __html_stream_end_header(html); */
d1001 22
a1022 15
              st->_stream_body=1;
              __html_stream_anchor(st, html, next_tag, url);
              return __html_stream_return_tag(st,next_tag,html,START,url);
            }
#ifdef FRAMESUPPORT
            case TYPE_FRAMESET: {
              HStream *ret_val;
              st->_stream_frameset++;
              st->_stream_head = 0;
              st->_stream_body = 0;
              st->_stream_noframes = 0;
              __html_stream_anchor(st, html, next_tag, url);
              if (st->_stream_anchor) {
                st->_stream_anchor->size = st->_stream_frameset;
//                st->_stream_frame = 0;
d1024 4
a1027 8
              ret_val =  __html_stream_return_tag(st,next_tag,html,START,url);

              __html_stream_grab_pcdata(html, size, 1);

              return ret_val;
              break;
            }
            case TYPE_NOFRAMES:
a1028 2
              st->_stream_body = 1;
              st->_stream_head = 0;
a1029 4
#endif
          }
        }
      }
d1045 1
a1045 1
static HStream *__html_stream_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
a1046 6
#ifdef NEWSPACING
    st->isendtag=1;
    st->stripleadingspace=next_tag.implicit_lf_after;
#else
    st->stripleadingcr=1;
#endif
d1048 1
a1048 1
  st->needtosend |= next_tag.tag;
d1052 2
a1053 1
  switch(next_tag.tag) {
d1055 4
a1058 4
    case TR:
    case TD:
    case TH:
    case TABLE: return __html_stream_return_tag(st,next_tag,html,END,url);
d1061 5
a1065 2
    case FORM:
      st->_stream_form=0;
d1068 1
a1068 1
    case SELECT:
d1072 4
a1075 5
    case TEXTAREA:
      st->_stream_textarea=0;
      break;

    case FONT:
d1082 19
a1100 2
    case CENTER:
      DEC(st->_stream_center);
d1103 1
a1103 1
    case ADDRESS:
d1107 1
a1107 1
    case BLOCKQUOTE:
d1111 3
a1113 5
    case DIR:
      DEC(st->_stream_dir);
      return __html_stream_return_tag(st,next_tag,html,END,url);

    case UL:
d1117 1
a1117 1
    case OL:
d1121 1
a1121 1
    case DL:
d1129 1
a1129 1
    case DD:
d1131 1
d1134 1
a1134 1
    case LI:
d1138 1
a1138 1
    case DT:
d1142 2
a1143 1
    case PRE:
d1147 6
a1152 7
    case H1:
    case H2:
    case H3:
    case H4:
    case H5:
    case H6:
    case H7:
d1156 4
a1159 63
    case HR: break; /* Should never see! */
    case BR: break; /* Should never see! */
    default: {
/*
 * We didnt find the tag in that lot, so look in the last 10. This is
 * sort of complicated by the fact that some of these are in the
 * head and some are in the body list, and there are <HEAD> and <BODY>
 * too.
 */
      st->_stream_body=__html_check_tag(Body_Tags,MAX_BODY_TAGS,
             	       	              next_tag.start_tag);
      if (st->_stream_body==1) {
        #ifndef NEWSPACING
        st->stripleadingcr = 0;
        #endif
        switch(next_tag.tag) {
          case P:
            DEC(st->_stream_p);
            #ifndef NEWSPACING
            st->stripleadingcr = 1;
            #endif
            break;

          case IMG:    break; /* No such tag! */
          case A:      __html_stream_end_anchor(st); break;
          case TT:
            DEC(st->_stream_tt);
            break;

          case ITALIC:
            DEC(st->_stream_italic);
            break;

          case BOLD:
            DEC(st->_stream_bold);
            break;
        #ifdef TonyTables
          case TR:    return __html_table_row_end_tag(st, next_tag, html, url);
          case TD:    return __html_table_data_end_tag(st, next_tag, html, url);
          case TH:    return __html_table_head_end_tag(st, next_tag, html, url);
          case TABLE: return __html_table_end_tag(st, next_tag, html, url);
        #endif
        }
      } else if(__html_check_tag(Head_Tags, MAX_HEAD_TAGS,
               		           next_tag.start_tag))
        {
       switch(next_tag.tag) {
          case NEXTID:
          case META:
          case LINK:
          case ISINDEX: break; /* No such tags */
          case TITLE:  {
            DEC(st->_stream_title);
            break;
          }
        }
      } else
#if FALSE
        if (__html_check_tag(Frameset_Tags, MAX_FRAMESET_TAGS, next_tag.start_tag)
        && next_tag.tag == FRAME) {
          st->_stream_frame = 0;
        } else
#endif
d1161 2
a1162 12
        switch(next_tag.tag) {
          case HEAD: {
            st->_stream_head=0;
            return __html_stream_end_header(html);
          }
          case BODY: {
            DEC(st->_stream_body);
            break;
          }
#ifdef FRAMESUPPORT
          case TYPE_FRAMESET: {
            char *ptr;
d1164 2
a1165 2
            DEC(st->_stream_frameset);
#if 0
d1167 16
a1182 9
            if (html != NULL) {
              ptr=*html;
              while((*ptr != '\0') && (*ptr != '>')) ptr++;
              if (*ptr=='>') ptr++;
              *html=ptr;
            }
            __html_stream_grab_pcdata(html, size, 1);
#endif
            break;
d1184 2
a1185 5
          case TYPE_NOFRAMES:
            st->_stream_noframes = 0;
            break;
#endif
         }
d1187 2
d1190 74
d1274 1
a1274 1
static HStream *__html_stream_image(StreamTokens *st, char **html, Tag next_tag, char *url)
a1275 1
  AnchorInfo  *anc;
d1279 22
a1300 1
  return_val=HStreamalloc();
d1302 3
a1304 6
    return_val->flags = 0;
    anc=__html_get_anchor_info(st, html, next_tag);
    if (anc != NULL) {
      return_val->style=__html_stream_style(st) | IMG;
      return_val->type=__html_stream_type(st,return_val->style,START);
      if (anc->ismap) {
d1306 48
a1353 23
      }
      return_val->type|=anc->alignment<<TYPE_ALIGN_SHIFT;
      if (st->_stream_anchor!=NULL) {
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
        return_val->target = (st->_stream_anchor->target);
       }
      else {
        return_val->anchor=NULL;
      }
      return_val->text=strdup(anc->alt);
      return_val->src=__html_make_anchor(url,anc->src);
      return_val->name=st->_stream_anchor->name;
//      return_val->target = strdup(st->_stream_anchor->target);
     return_val->rows=anc->rows;
      return_val->cols=anc->cols;
      return_val->maxlen=anc->border;
      return_val->next=NULL;
      return_val->prev=NULL;

      /* If one of HEIGHT or WIDTH are missing, remove the other one as
         well to prevent confusion */
      if (return_val->rows==0 || return_val->cols==0)
        return_val->cols=return_val->rows=0;
d1355 16
a1370 1
    st->needtosend=0;
d1372 1
a1372 2
    /* Get rid of the anchor info block */
    __html_stream_free_anchor(&anc);
d1385 2
a1386 2
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
d1399 1
a1399 1
static HStream *__html_stream_hr(StreamTokens *st, char **html, Tag next_tag, char *url)
a1400 1
  AnchorInfo  *anc;
d1406 1
a1406 1
  return_val=HStreamalloc();
d1408 21
a1428 9
    return_val->flags = 0;
    anc=__html_get_anchor_info(st, html, next_tag);
    if (anc != NULL) {
      if (anc->noshade)
        noshade = TYPE_NOSHADE;
      if (anc->alignment != _html_none)
          alignment = anc->alignment;
      if (st->_stream_anchor!=NULL) {
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
d1430 4
a1433 5
      }
      return_val->cols=anc->cols;
      return_val->size=anc->size;
      __html_stream_free_anchor(&anc);

a1434 2
    st->needtosend=0;
    return_val->name=st->_stream_anchor->name;
d1436 1
a1436 1
    return_val->type=__html_stream_type(st,return_val->style,START) | noshade;
d1452 2
a1453 2
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
d1466 1
a1466 1
static HStream *__html_stream_anchor(StreamTokens *st, char **html, Tag next_tag, char *url)
d1468 5
d1474 36
a1509 3
  st->_stream_anchor=__html_get_anchor_info(st, html, next_tag);
  if (st->_stream_anchor && !st->_stream_anchor->target)
    st->_stream_anchor->target = strdup(st->target);
d1519 1
a1519 1
static HStream *__html_stream_frame (StreamTokens *st, char **html, Tag next_tag, char *url, int size)
a1520 1
  AnchorInfo  *anc;
d1524 9
a1532 3
  return_val=HStreamalloc();
  anc = __html_get_anchor_info(st, html, next_tag);
  if (return_val != NULL) {
d1535 4
a1538 6
    return_val->type = __html_stream_type(st,return_val->style,START);
    if (anc != NULL) {
      if (anc->scrolling) {
        return_val->type |= anc->scrolling << TYPE_SCROLLING_SHIFT;
      }
      if (anc->noresize) {
d1540 4
a1543 8
      }
      return_val->size   = st->_stream_frameset;
      return_val->indent = anc->spacing;
      return_val->maxlen = anc->maxlength;
      return_val->rows   = anc->rows;
      return_val->cols   = anc->cols;
      return_val->name   = anc->name;
      return_val->src=__html_make_anchor(url,anc->src);
d1545 8
a1552 1
//      __html_stream_free_anchor(&anc);
d1554 8
d1570 1
a1570 1
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
d1574 73
a1646 1
  __html_stream_grab_pcdata(html, size, 1);
d1656 1
a1656 1
static HStream *__html_stream_base(StreamTokens *st, char **html, Tag next_tag, char *url)
d1658 10
a1667 18
char *newurl, *newtarget;
  if (st->_stream_anchor != NULL) __html_stream_end_anchor(st);
  st->_stream_anchor=__html_get_anchor_info(st, html, next_tag);
  if (st->_stream_anchor != NULL) {
    if (st->_stream_anchor->href != NULL) {
      newurl=strdup(st->_stream_anchor->href);
      if (newurl) {
        __html_free(st->url,0);
        st->url=newurl;
      }
    }
    if (st->_stream_anchor->target != NULL) {
      newtarget=strdup(st->_stream_anchor->target);
      if (newtarget) {
        __html_free(st->target,0);
        st->target=newtarget;
      }
    }
d1669 1
d1685 1
d1694 2
d1698 1
a1725 1
  st->_stream_body       =1;
d1727 1
d1738 1
a1738 1
/*static*/ HStream *__html_stream_return_tag(StreamTokens *st, Tag tag, char **html, int start, char *url)
a1741 3
  #ifdef TRACE
  FILE *fp;
  #endif
d1743 1
a1743 1
  ret=HStreamalloc();
d1746 2
a1747 24
      if (tag.tag!=BODY) {
        ret->flags = 0;
        ret->style=__html_stream_style(st) | tag.tag; // This appears to put dodgy stuff in the style word
        ret->type=__html_stream_type(st,ret->style, start);
      }
      else {
          ret->style=__html_stream_style(st) | IMG;
          ret->type=(__html_stream_type(st,ret->style, start) | TYPE_HEAD) & ~TYPE_BODY;

//          Printf ("In stream_return_tag %08x %08x\n", ret->style, ret->type);
//          ********************ret->type |= 1;
      }
      #ifdef TABLE_SUPPORT
      if (tag.tag==TABLE) {
        ret->style|=HR;
        #ifdef TRACE
        fp=fopen("adfs::4.$.op","a");
        if (fp) {
          fprintf(fp,"TABLE found...\n");
          fclose(fp);
        }
        #endif
      }
      #endif
d1754 4
a1757 1
        ret->anchor=__html_make_anchor(url, st->_stream_anchor->href);
d1759 1
a1761 20
      else {
        ret->anchor=NULL;
        ret->name=NULL;
        ret->target=NULL;
      }

      ret->text=NULL;
      if (tag.tag==BODY)
        ret->tag=0;
      else
        ret->tag=tag.tag;

      #ifdef TABLE_SUPPORT
      if (tag.tag == TABLE) {
        ret->style|=HR;
      }
      #endif


//      Printf ("%s has tag field %08x\n", tag.start_tag, tag.tag);
d1763 1
a1763 21
      if (tag.tag == BODY) {
        if (st->_stream_anchor != NULL) {
          ret->src=__html_make_anchor(url,st->_stream_anchor->src);
          /* These four store colour info for the page (special case) */
          ret->size=st->_stream_anchor->size;
          ret->rows=st->_stream_anchor->rows;
          ret->cols=st->_stream_anchor->cols;
          ret->maxlen=st->_stream_anchor->maxlength;
          __html_stream_free_anchor(&(st->_stream_anchor));
          ret->style |= IMG;
        }
        else {
          ret->src=NULL;
          /* Not valid RiscOS colours. Should be trapped by the UI */
          ret->size=(unsigned int)-1;
          ret->rows=(unsigned int)-1;
          ret->cols=(unsigned int)-1;
          ret->maxlen=(unsigned int)-1;
        }
      } else if (tag.tag == TYPE_FRAMESET) {
//          ret->src=st->_stream_anchor->src;
d1765 1
a1765 22
          if (st->_stream_anchor != NULL) {

              ret->value=st->_stream_anchor->value;
              st->_stream_anchor->value = 0;

              ret->size=st->_stream_anchor->size;
              ret->rows=st->_stream_anchor->rows;
              ret->cols=st->_stream_anchor->cols;
              ret->indent=st->_stream_anchor->spacing;
              ret->maxlen=st->_stream_anchor->maxlength;
          } else {
              ret->value = 0;
              ret->size = st->_stream_frameset;
              ret->rows = 0;
              ret->cols = 0;
              ret->indent = 1;
              ret->maxlen = 0x00000000;
          }

      } else ret->src=NULL;
      ret->prev=NULL;
      st->needtosend=0;
d1774 2
a1775 2
    ptr=*html;
    while((*ptr != '\0') && (*ptr != '>')) ptr++;
a1783 181
/* static char *__html_make_anchor(char *base, char *link)          */
/********************************************************************/
/* Given a base URL and another URL (e.g. a link or an image), this */
/* routine constructs the resultant URL from the pair               */
/********************************************************************/

char * __html_make_anchor(char * base, char * link)
{
  char        * ret = NULL;
  char        * copy;
  char        * buffer;
  char        * uri;
  extern char * __html_tidy_url(char * url);

  if (link == NULL) return NULL;

  if (base == NULL) // || (strstr(base,"ADFS:") != NULL)
  {
    ret = strdup(link);
    return ret;
  }

  if (link[0] == '#')
  {
    /* It's a within document link */

    ret = __html_malloc(strlen(link) + strlen(base) + 1, 1);
    if (ret) strdoublecpy(ret, base, link);

    return ret;
  }

  /* Should have a Fetcher_Relativise call                               */
  /*                                                                     */
  /* Simple test for a fully qualified URL. Look for '://' in the string */
  /* Also catch "mailto:" and "x500:" URLs at this point. We expect the  */
  /* method to be at the start of the string. (This is to allow for      */
  /* funny proxies :)                                                    */
  /*                                                                     */
  /* The test on ret - link <= 9 ensures URLs that are indeed relative,  */
  /* but contain URLs themselves (e.g. as part of some CGI info in the   */
  /* link) aren't treated as absolute (see below for more of this kind   */
  /* of consideration). We want the :// to be within about the first 9   */
  /* characters, more or less...                                         */

  ret = strstr(link, "://");

  if (
       (ret && ret - link <= 9)     ||
       !strincmp(link,"MAILTO:",7)  ||
       !strincmp(link,"NEWS:",  5)  ||
       !strincmp(link,"X500:",  5)
     )
  {

    ret = strdup(link);
    return ret;
  }

  /* Now look for broken URLs of the form 'method:/path/to/file' or           */
  /* 'method:relative/path'. These are a tad more difficult to deal with      */
  /* so a separate routine is needed to do this :) This relies on mailto and  */
  /* x500 being caught above.                                                 */
  /*                                                                          */
  /* Also the test for being more than 7 chars in is needed for places like   */
  /* www.pathfinder.com who have URLs of the form:                            */
  /*                                                                          */
  /* /adgw/nph-adgw.cgi?url=http:%2f%2fchess.ibm.park.org&advertiser=...      */
  /* IBM%20OS2&description=IBM%20Chess%20Button&source=%2fpathfinder%2f...    */
  /* welcome.html                                                             */
  /*                                                                          */
  /* which contain the sequence "http:" (Technically the ':' should be        */
  /* encoded too I believe!). Anyway since mailto is the longest method, 7    */
  /* should be okay, I hope!. Alternatively if this is found to be unreliable */
  /* change the buffer=strchr() bit and the *link=='/' bits around.           */

  buffer = strchr(link, ':');

  if (buffer && (buffer - link < 7))
  {
    buffer++;

    uri = strdup(buffer); /* Buffer should now contain URI. Just need new base */
    if (!uri) return NULL;

    /* Now get the method bit - ughh! */

    buffer = strdup(link);

    if (!buffer) return buffer;

    ret  = strchr(buffer,':'); /* Can't fail because of above */
    *ret = '\0';

    /* Now need to construct new base bit. */
    copy=__html_malloc(strlen(base)+strlen(buffer)+1,1);
    if (!copy) return copy;
    /* We have up to the : so skip that in base */
    base=strchr(base,':');
    if (base==NULL) return base;
    sprintf(copy,"%s%s",buffer,base);
    base=copy;
    link=uri;
  }

/* The 1st case. The link starts with a '/' so it is an absolute URL
 * around the same host/method base.
 */
  if (*link=='/') {
    link++;
    ret=__html_malloc(strlen(base)+strlen(link)+1,sizeof(char));
    if (ret==NULL) return NULL;

    strcpy(ret,base);
    copy=ret;
    copy=strstr(copy,"://");
    if (copy==NULL) {
      __html_free(ret, 0);
      return NULL;
    }
    copy++; copy++; copy++;
    copy=strchr(copy,'/');
    if (copy==NULL) {
      __html_free(ret, 0);
      return NULL;
    }
    copy++; *copy='\0';
    strcat(ret,link);
    return ret;
  }

/* The 2nd case. The link starts with a './' so it is an relative URL
 * around this page
 */
  if ((*link=='.') && (*(link+1)=='/')) {
    link++; link++;

default_return:

/*
 * Basically we need to look back through base to find the last '/'
 * and append link at that point. So we need a string the length
 * of base and link, and then blat the two strings into it.
 *
 * So grab a copy of base, and strip it back to the required point
 */
    ret=copy=strdup(base);

    if (ret==NULL) return ret;

    ret=strrchr(copy,'/');

    if (ret==NULL) {
      __html_free(copy, 0);
      return NULL;
    }
    ret++;
    *ret='\0';

/* Create a big enough string */
    ret=__html_malloc(strlen(copy)+strlen(link)+1,sizeof(char));
    if (ret==NULL) return ret;
/* Add the two strings into the return buffer */
    strdoublecpy(ret, copy, link);
    return __html_tidy_url(ret);
  }

/* 3rd case. The link has a ':' in it. Assume its a link such as a
 * mailto request. (i.e. host independant URL)
 */

 if (strchr(link, ':') != NULL) {
   ret=strdup(link);
   return ret;
 }

/* Otherwise this is sort of the same as case 2 sans the './' */
 goto default_return;
}

/********************************************************************/
d1795 3
a1797 7
  if (anc->href != NULL)    __html_free(anc->href,0);
  if (anc->src != NULL)     __html_free(anc->src,0);
  if (anc->alt != NULL)     __html_free(anc->alt,0);
  if (anc->action != NULL)  __html_free(anc->action,0);
  if (anc->enctype != NULL) __html_free(anc->enctype,0);
  if (anc->value != NULL)   __html_free(anc->value,0);
//  if (anc->target != NULL)  __html_free(anc->target,0);
a1803 12
/* static void strdoublecpy(char *buffer, char *s1, char *s2)       */
/********************************************************************/
/* Copy s1 and s2 into buffer, with no space between them           */
/********************************************************************/

static void strdoublecpy(char *buffer, char *s1, char *s2)
{
  if (buffer==NULL) return;
  sprintf(buffer,"%s%s",s1,s2);
}

/********************************************************************/
d1811 1
a1811 1
static HStream * __html_form_handler(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
a1812 1
AnchorInfo *anc;
d1818 1
a1818 4
  if (st->_stream_forms) __html_stream_free_anchor(&(st->_stream_forms));

/* Now get the form information out of the anchor */
  anc=__html_get_anchor_info(st, html, next_tag);
a1819 5
/* Always check for those NULLs. */
  if (anc == NULL && next_tag.tag != OPTION)
      return (HStream *)anc; /* 2 instructions saved :) */

  st->_stream_forms = anc;
d1822 1
a1822 1
  ret=HStreamalloc();
d1828 3
a1830 1
  if (next_tag.tag == OPTION || next_tag.tag == TEXTAREA || next_tag.tag == SELECT)
d1832 2
a1833 2
    ptr=*html;
    while((*ptr != '\0') && (*ptr != '>')) ptr++;
d1839 2
a1840 3
  switch(next_tag.tag) {
    case FORM: /* Fill in method bit etc */
    	       st->_stream_form=1;
d1842 4
a1845 9
    	       if (!anc->method)
    	            anc->method=1; /* Default to GET form (there are morons out there) */
	       ret->style=__html_stream_style(st);
	       ret->type=__html_stream_type(st, ret->style, START);
	       ret->anchor=__html_make_anchor(url, st->_stream_forms->action);
	       if (st->_stream_anchor) {
                 ret->target = st->_stream_anchor->target;
               }
               ret->enctype=strdup(st->_stream_forms->enctype);
d1847 14
a1860 1
               st->needtosend |= FORM;
d1863 10
a1872 4
    case INPUT: /* Do lots of bits */
    	       ret->tag=INPUT;
	       ret->style=__html_stream_style(st) | INPUT;
	       ret->type=__html_stream_type(st, ret->style, START);
d1874 21
a1894 6
	       ret->maxlen=st->_stream_forms->maxlength;
	       ret->size=st->_stream_forms->size;
	       ret->value=strdup(st->_stream_forms->value);
	       if (st->_stream_forms->type <= 1) {
  	         if (ret->maxlen > 0) {
  	           ret->text=strndup(ret->value,ret->maxlen); /* Ensure big buffer */
d1897 1
a1897 1
  	           ret->text=strndup(ret->value, 1024);
d1899 2
a1900 4
  	       }
	       ret->name=strdup(st->_stream_forms->name);
	       ret->src=strdup(st->_stream_forms->src);
               ret->indent=__html_stream_indent(st);
d1902 1
d1904 1
a1904 12
    case SELECT: /* Check multiple bits */
#ifdef OLDCODE
    	       st->_stream_select=1;
    	       ret->tag=SELECT;
	       ret->style=__html_stream_style(st) | SELECT;
	       ret->type=__html_stream_type(st, ret->style, START);
	       /* SELECTy bits */
	       ret->name=strdup(st->_stream_forms->name);
               ret->indent=__html_stream_indent(st);
	       st->needtosend |= SELECT;
	       break;
#else
d1912 1
a1912 2
                return __html_form_parse_select(st, html, p-*html, ret);
#endif
d1914 5
a1918 4
    case OPTION: /* OPTION tag */
    	       ret->tag=OPTION;
	       ret->style=__html_stream_style(st) | OPTION;
	       ret->type=__html_stream_type(st, ret->style, START);
d1920 4
a1923 3
	       if (st->_stream_forms)
	           ret->value=strdup(st->_stream_forms->value);
	       ret->text=__html_stream_grab_pcdata(html, size, 1);
d1940 3
a1942 5
    	       st->_stream_textarea=1;
    	       ret->tag=TEXTAREA;
	       ret->style=__html_stream_style(st) | TEXTAREA;
	       ret->type=__html_stream_type(st, ret->style, START);
	       ret->text=__html_stream_grab_pcdata(html, size, 1);
d1950 4
a1953 3
	       ret->cols=st->_stream_forms->cols;
	       ret->rows=st->_stream_forms->rows;
	       ret->name=strdup(st->_stream_forms->name);
d1960 3
d1966 1
a1966 1
HStream *__html_return_text_token(char *doc, size_t size)
d1970 1
a1970 1
  return_val=HStreamalloc();
a1982 2
    return_val->src=NULL;
    return_val->prev=NULL;
d2001 1
d2006 6
a2011 3
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, 0);
    /* Hack hack hack hack! */
    s->_stream_form=1;
d2020 2
a2021 1
               Flags byte (0 atm)
d2033 1
a2033 1
        if (hp->tag == OPTION)
d2035 7
a2041 2
            count+=1+strlen(hp->text)+1+(hp->value?strlen(hp->value):0)+1;
            items+=1;
d2046 9
a2054 4
    /* Hack! */
    ret->value=p=__html_malloc(count, 1);
    *((int *)p)=items; p+=4;
    *((int *)p)=0; p+=4;
d2058 1
a2058 1
        if (hp->tag == OPTION)
d2063 1
a2063 1
            *p++=(hp->type & TYPE_SELECTED) ? 1 : 0;
d2070 1
a2070 6
            if (hp->value)
            {
                sprintf(p, "%s%n", hp->value, &len); p+=len+1;
            }
            else
                *p++='\0';
d2075 1
a2075 1
    assert((p+1)-ret->value == count);
d2078 1
a2078 1
    free(s);
d2080 2
a2081 5
    ret->tag=SELECT;
    ret->style=__html_stream_style(st) | SELECT;
    ret->type=__html_stream_type(st, ret->style, START);
    ret->name=strdup(st->_stream_forms->name);
    ret->size=st->_stream_forms->size;
d2083 11
d2095 1
a2095 1
    st->needtosend |= SELECT;
d2106 304
@


1.2.2.1
log
@Removed some compilation warnings. Fixed handling of vanilla <FRAME> tags
(ie ones with no attributes).
@
text
@d19 1
a19 1
 * $Source: /projects2/renaissa/cvsroot/Projects/Web/HTMLLib/c/new_stream,v $
a21 3
 * Revision 1.2  1997/04/29 15:50:47  kbracey
 * Merged in ARTtmp_merge
 *
d57 2
a58 1
static unsigned int __html_stream_type(StreamTokens *st, int start);
d196 1
a196 1
      return_val->type=__html_stream_type(st, START);
d499 1
a499 1
static unsigned int __html_stream_type(StreamTokens *st, int start)
d994 2
d1000 1
a1000 1
              char *ptr=*html;
a1005 2
#else
            NOT_USED(size);
d1038 1
a1038 1
      return_val->type=__html_stream_type(st, START);
d1124 1
a1124 1
    return_val->type=__html_stream_type(st, START) | noshade;
a1155 1
  NOT_USED(url);
d1180 1
a1180 2
    return_val->type = __html_stream_type(st, START);
    return_val->size   = st->_stream_frameset;
d1188 1
a1222 2
  NOT_USED(url);

a1263 2
  NOT_USED(html);

d1319 1
a1319 1
        ret->type=__html_stream_type(st, start);
d1323 1
a1323 1
          ret->type=(__html_stream_type(st, start) | TYPE_HEAD) & ~TYPE_BODY;
d1699 1
a1699 1
	       ret->type=__html_stream_type(st, START);
d1712 1
a1712 1
	       ret->type=__html_stream_type(st, START);
d1735 1
a1735 1
	       ret->type=__html_stream_type(st, START);
d1755 1
a1755 1
	       ret->type=__html_stream_type(st, START);
d1779 1
a1779 1
	       ret->type=__html_stream_type(st, START);
d1908 1
a1908 1
    ret->type=__html_stream_type(st, START);
@


1.2.2.2
log
@Now handles entities with missing ";"s, eg "RISC&nbspOS".
Handles entities split across parser calls better.
@
text
@d605 1
a605 1
      for (stop = end + 1; (stop - *input < size) && (isalnum(*stop) || *stop=='#' || *stop=='&'); stop++)
d608 1
a608 1
      if (stop - *input < size)
d610 7
a616 10
        if (*stop == ';')
        {
            end = stop + 1;
            goto carryon;
        }
        else if (*stop)
        {
            end = stop;
            goto carryon;
        }
@


1.2.2.3
log
@Improved comment handling.
Started work on SUB, SUP, U and STRIKE support.
@
text
@a88 4
static    HStream * __html_stream_declaration(StreamTokens *st, char **html,
                                              int size);
static    HStream * __html_stream_comment(StreamTokens *st, char **html,
                                          int size);
a136 9
  switch (st->state)
  {
    case Declaration:
      return __html_stream_declaration(st, html, size);
    case Comment:
      return __html_stream_comment(st, html, size);
    /* Fall through if other */
  }

d157 1
a157 1
  if (*ptr != '<') {
d258 1
a258 1
      /*st->stripleadingspace=0;*/
d283 3
a285 2
  if (size < 2)
      RETURN(NULL);
d287 15
a301 4
  if (*(ptr+1) == '!')
  {
      st->state = Declaration;
      *html = ptr+2;
d303 9
a313 4
  #ifdef NEWSPACING
  st->lastwaspcdata=0;
  #endif

a429 74
}

/********************************************************************/
/* __html_stream_declaration                                        */
/********************************************************************/
/* Called instead of __html_stream_parse when inside a <!  > pair   */
/********************************************************************/
static HStream *__html_stream_declaration(StreamTokens *st, char **html,
                                          int size)
{
    /*
     * Currently we don't do anything with declarations. Just need
     * to skip comments
     */
    char *ptr = *html;
    while (size)
    {
        if (*ptr == '>')
        {
            *html = ptr + 1;
            st->state = Other;
            return NULL;
        }
        if (*ptr == '-')
        {
            if (size < 2)
            {
                *html = ptr;
                RETURN(NULL);
            }
            if (*(ptr+1) == '-')
            {
                *html = ptr+2;
                st->state = Comment;
                return NULL;
            }
        }
        ptr++;
        size--;
    }

    RETURN(NULL);
}

/********************************************************************/
/* __html_stream_comment                                            */
/********************************************************************/
/* Called instead of __html_stream_parse when inside a -- -- pair   */
/********************************************************************/
static HStream *__html_stream_comment(StreamTokens *st, char **html,
                                      int size)
{
    char *ptr = *html;
    while (size)
    {
        if (*ptr == '-')
        {
            if (size < 2)
            {
                *html = ptr;
                RETURN(NULL);
            }
            if (*(ptr+1) == '-')
            {
                *html = ptr+2;
                st->state = Declaration;
                return NULL;
            }
        }
        ptr++;
        size--;
    }

    RETURN(NULL);
@


1.2.2.4
log
@Tweaked colour names Pink and DarkTurqoise.
Strips leading space from start of HTML.
@
text
@a1374 1
  st->stripleadingspace  =1;
@


1.2.2.5
log
@Added previous pointers to table rows and cells.
Implemented skipping of <STYLE> and <SCRIPT>.
@
text
@a92 3
static    HStream * HStreamalloc(void);
static    HStream * __html_stream_skip_cdata(StreamTokens *st, char **html,
                                             int size);
a146 4
      /* Don't handle SCRIPT or STYLE at the moment, but lets parse over it */
    case Script:
    case Style:
      return __html_stream_skip_cdata(st, html, size);
a466 1
    *html=ptr;
a498 1
    *html = ptr;
a827 2
            case SCRIPT:  st->state = Script; return NULL;
            case STYLE:   st->state = Style; return NULL;
d1898 2
a2003 44
}

HStream *HStreamalloc(void)
{
    HStream *ret = (HStream *)__html_malloc(sizeof(HStream), 1);

    if (ret)
        ret->parent = __html_current_headdata;

    return ret;
}

static HStream * __html_stream_skip_cdata(StreamTokens *st, char **html, int size)
{
    char *ptr = *html;
    while (size)
    {
        if (*ptr == '<')
        {
            if (size < 3)
            {
                *html = ptr;
                RETURN(NULL);
            }
            if (*(ptr+1) == '/' && (*(ptr+2) >= 'A' && *(ptr+2) <= 'Z' ||
                                    *(ptr+2) >= 'a' && *(ptr+2) <= 'z'))
            {
                /*
                 * It's an end tag - assume its the end of the SCRIPT/STYLE section and
                 * let the parser process the </Whatever>. HTML 3.2 spec says that we
                 * should ignore anything other than "</" followed immediately by
                 * [a-zA-Z], so we've satisfied that condition at least
                 */
                st->state = Other;
                *html = ptr;
                return NULL;
            }
        }
        ptr++;
        size--;
    }

    *html = ptr;
    RETURN(NULL);
@


1.2.2.6
log
@updated to help enable head/body switching
@
text
@a21 4
 * Revision 1.2.2.5  1997/07/02 08:39:39  kbracey
 * Added previous pointers to table rows and cells.
 * Implemented skipping of <STYLE> and <SCRIPT>.
 *
d732 1
a732 2
    if (next_tag.tag >= BR)
    {
d740 2
a741 2
    switch(next_tag.tag)
    {
d743 4
a746 4
      case TAG_TR:
      case TAG_TD:
      case TAG_TH:
      case TAG_TABLE:      return __html_stream_return_tag(st,next_tag,html,END,url);
d748 28
a775 28
      case TAG_INPUT:
      case TAG_SELECT:
      case TAG_OPTION:
      case TAG_TEXTAREA:   if (st->_stream_form==0) break;
      case TAG_FORM:       return __html_form_handler(st, next_tag, html, url, size);
      case TAG_FONT:       {
                           AnchorInfo *anc;
                           /*
                            * __html_get_anchor_info will examine the size/colour information in
                            * the tag, and will update st. We don't actually want the AnchorInfo
                            * structure generated...
                            */
                           anc = __html_get_anchor_info(st, html, next_tag);
                           __html_stream_free_anchor(&anc);
                           break;
                           }
      case TAG_CENTER:     st->_stream_center++; break;
      case TAG_ADDRESS:    st->_stream_address++; break;
      case TAG_BLOCKQUOTE: st->_stream_blockquote++; break;
      case TAG_PRE:	   st->_stream_pre++; break;
      case TAG_H1:
      case TAG_H2:
      case TAG_H3:
      case TAG_H4:
      case TAG_H5:
      case TAG_H6:
      case TAG_H7:         st->_stream_h=next_tag.tag; break;
      case TAG_DIR:	       st->_stream_dir++; /* Needed for indent level */
d778 1
a778 1
      case TAG_UL:	       st->_stream_ul++;  /* Needed for indent level */
d781 1
a781 1
      case TAG_OL:	       st->_stream_ol++;  /* Needed for indent level */
d784 1
a784 1
      case TAG_DL:	       st->_stream_dl++;  /* Needed for indent level */
d791 1
a791 1
      case TAG_LI:	       st->_stream_li++; /* Needed for indent level? */
d793 1
a793 1
      case TAG_DT:	       st->_stream_dt=1; /* Needed for indent level? */
d796 1
a796 1
      case TAG_DD:	       st->_stream_dd=1; /* Needed for indent level? */
d800 3
a802 2
      case TAG_HR:     return __html_stream_hr(st, html, next_tag, url);
      case TAG_BR:     return __html_stream_return_tag(st,next_tag,html,START,url);
d809 32
a840 23
      case TAG_P:      st->_stream_p=1; break;
      case TAG_IMG:    return __html_stream_image(st,html, next_tag, url);
      case TAG_A:      __html_stream_anchor(st, html, next_tag, url); break;
      case TAG_TT:     st->_stream_tt++; break;
      case TAG_ITALIC: st->_stream_italic++; break;
      case TAG_BOLD:   st->_stream_bold++; break;
      #ifdef TonyTables
      case TAG_TR:     return __html_table_row_start_tag(st, next_tag, html, url, size);
      case TAG_TD:     return __html_table_data_start_tag(st, next_tag, html, url, size);
      case TAG_TH:     return __html_table_head_start_tag(st, next_tag, html, url, size);
      case TAG_TABLE:  st->_stream_table++;
                       return __html_table_start_tag(st, next_tag, html, url, size);
      #endif
      case TAG_NEXTID:
      case TAG_META:
      case TAG_LINK:   //st->_stream_head=1;
         	 break; /* We are ignoring these for now */
      case TAG_TITLE:  st->_stream_title++; break;
      case TAG_BASE:   __html_stream_base(st, html, next_tag, url); break;
      case TAG_ISINDEX: st->_stream_isindex=1; st->_stream_head=1; break;
      case SCRIPT:  st->state = Script; return NULL;
      case STYLE:   st->state = Style; return NULL;

d847 1
a847 2
           && next_tag.tag == FRAME)
           {
d849 1
a849 1
           } else
d852 1
a852 2
          switch(next_tag.tag)
          {
d854 2
a855 4
            case BODY:
            {
              if (st->_stream_head != 0) // use to be (.. >= 1)
              {
d865 1
a865 2
            case TYPE_FRAMESET:
            {
d872 1
a872 2
              if (st->_stream_anchor)
              {
d891 1
a919 4

  st->_stream_body=__html_check_tag(Head_Body_Tags,MAX_HEAD_BODY_TAGS,
       	       	                    next_tag.start_tag);

d922 4
a925 4
    case TAG_TR:
    case TAG_TD:
    case TAG_TH:
    case TAG_TABLE: return __html_stream_return_tag(st,next_tag,html,END,url);
d928 1
a928 1
    case TAG_FORM:
d932 1
a932 1
    case TAG_SELECT:
d936 1
a936 1
    case TAG_TEXTAREA:
d940 1
a940 1
    case TAG_FONT:
d947 1
a947 1
    case TAG_CENTER:
d951 1
a951 1
    case TAG_ADDRESS:
d955 1
a955 1
    case TAG_BLOCKQUOTE:
d959 1
a959 1
    case TAG_DIR:
d963 1
a963 1
    case TAG_UL:
d967 1
a967 1
    case TAG_OL:
d971 1
a971 1
    case TAG_DL:
d979 1
a979 1
    case TAG_DD:
d983 1
a983 1
    case TAG_LI:
d987 1
a987 1
    case TAG_DT:
d991 1
a991 1
    case TAG_PRE:
d995 7
a1001 7
    case TAG_H1:
    case TAG_H2:
    case TAG_H3:
    case TAG_H4:
    case TAG_H5:
    case TAG_H6:
    case TAG_H7:
d1005 3
a1007 2
    case TAG_HR: break; /* Should never see! */
    case TAG_BR: break; /* Should never see! */
d1014 19
a1032 5
    case TAG_IMG:    break; /* No such tag! */
    case TAG_A:      __html_stream_end_anchor(st); break;
    case TAG_TT:
      DEC(st->_stream_tt);
      break;
d1034 3
a1036 3
    case TAG_ITALIC:
      DEC(st->_stream_italic);
      break;
d1038 24
a1061 19
    case TAG_BOLD:
      DEC(st->_stream_bold);
      break;
  #ifdef TonyTables
    case TAG_TR:    return __html_table_row_end_tag(st, next_tag, html, url);
    case TAG_TD:    return __html_table_data_end_tag(st, next_tag, html, url);
    case TAG_TH:    return __html_table_head_end_tag(st, next_tag, html, url);
    case TAG_TABLE: return __html_table_end_tag(st, next_tag, html, url);
  #endif
    case TAG_NEXTID:
    case TAG_META:
    case TAG_LINK:
    case TAG_ISINDEX: break; /* No such tags */
    case TAG_TITLE:
    {
      DEC(st->_stream_title);
      break;
    }

d1064 1
a1064 2
        && next_tag.tag == FRAME)
        {
d1069 2
a1070 4
        switch(next_tag.tag)
        {
          case HEAD:
          {
d1074 1
a1074 2
          case BODY:
          {
d1079 1
a1079 3
          case TYPE_FRAMESET:
          {

d1083 1
a1083 2
            if (html != NULL)
            {
d1099 1
a1099 1
        }
d1101 1
d1785 1
a1785 1
    case TAG_FORM: /* Fill in method bit etc */
d1801 1
a1801 1
    case TAG_INPUT: /* Do lots of bits */
d1822 1
a1822 1
    case TAG_SELECT: /* Check multiple bits */
d1844 1
a1844 1
    case TAG_OPTION: /* OPTION tag */
@


1.2.2.7
log
@Removed dependence on <HEAD> and <BODY>
@
text
@a21 3
 * Revision 1.2.2.6  1997/07/02 09:05:55  gthorbur
 * updated to help enable head/body switching
 *
d64 1
a64 1
static unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start);
a80 1
#if 0
a81 1
#endif
d222 1
a222 1
      return_val->type=__html_stream_type(st, TYPE_BODY, START);
d229 1
a229 1
 * If the tag is not a special once-only tag,
d233 3
a235 1
      if (!(return_val->style & (P|BR|DL|OL|UL|DIR))) {
a309 3
  /* Stop doing any titleness */
  st->_stream_title=0;

a367 2
        prevhs->type &=~ TYPE_MASK;
        /*prevhs->type=(prevhs->type &~ (TYPE_BODY|TYPE_FRAMESET|TYPE_NOFRAMES)) | TYPE_HEAD;*/
a389 1
        /* Put in a null tag (ish) */
a390 1
        return_val->type|=TYPE_BODY;
d584 1
a584 1
static unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start)
d586 1
a586 1
  unsigned int temp=tag_type;
d588 3
a590 2
  if (st->_stream_title) {
    temp = TYPE_HEAD;
d592 3
a597 1

d600 1
d736 1
a736 1
    if (next_tag.tag >= BR)
d745 1
a745 1
    switch(next_tag.tag_no)
a757 1
      case TAG_BASEFONT:
d779 2
a780 2
      case TAG_H7:     st->_stream_h=next_tag.tag; break;
      case TAG_DIR:    st->_stream_dir++; /* Needed for indent level */
d783 1
a783 2
      case TAG_MENU:
      case TAG_UL:     st->_stream_ul++;  /* Needed for indent level */
d786 1
a786 1
      case TAG_OL:     st->_stream_ol++;  /* Needed for indent level */
a815 4
      case TAG_SAMP:
      case TAG_CODE:
      case TAG_KBD:
      case TAG_VAR:
a816 2
      case TAG_EM:
      case TAG_CITE:
a817 1
      case TAG_STRONG:
d832 28
a859 5
      case TAG_ISINDEX: st->_stream_isindex=1; break;
      case TAG_SCRIPT:  st->state = Script; return NULL;
      case TAG_STYLE:   st->state = Style; return NULL;
      case TAG_FRAME:   return __html_stream_frame(st, html, next_tag, url, size);
      case TAG_BODY:
d862 3
a864 1
      case TAG_FRAMESET:
d868 2
d872 1
a872 1
              if (st->_stream_anchor)
d884 1
a884 1
      case TAG_NOFRAMES:
d886 2
d889 3
d920 5
a924 2

  switch(next_tag.tag_no) {
a966 1
    case TAG_MENU:
a1018 4
    case TAG_SAMP:
    case TAG_CODE:
    case TAG_KBD:
    case TAG_VAR:
a1022 2
    case TAG_EM:
    case TAG_CITE:
a1026 1
    case TAG_STRONG:
d1040 2
a1041 3
#if 0
    /* Not required because ANY tag will terminate a TITLE */
    case TAG_TITLE:
d1044 45
d1090 2
a1091 6
    case TAG_FRAMESET:
      DEC(st->_stream_frameset);
      NOT_USED(size);
      break;
    case TAG_NOFRAMES:
      st->_stream_noframes = 0;
d1114 1
a1114 1
      return_val->type=__html_stream_type(st, next_tag.type, START);
d1200 1
a1200 1
    return_val->type=__html_stream_type(st, next_tag.type, START) | noshade;
d1257 1
a1257 1
    return_val->type = __html_stream_type(st, next_tag.type, START);
a1334 1
#if 0
a1346 1
#endif
d1374 1
d1398 12
a1409 3
      ret->flags = 0;
      ret->style=__html_stream_style(st) | tag.tag; // This appears to put dodgy stuff in the style word
      ret->type=__html_stream_type(st, tag.type, start);
d1439 1
a1439 1
      if (tag.tag_no==TAG_BODY)
d1453 1
a1453 1
      if (tag.tag_no == TAG_BODY) {
d1774 1
a1774 1
  switch(next_tag.tag_no) {
d1781 1
a1781 1
	       ret->type=__html_stream_type(st, next_tag.type, START);
d1794 1
a1794 1
	       ret->type=__html_stream_type(st, next_tag.type, START);
d1837 1
a1837 1
	       ret->type=__html_stream_type(st, next_tag.tag, START);
d1861 1
a1861 1
	       ret->type=__html_stream_type(st, next_tag.type, START);
d1988 1
a1988 1
    ret->type=__html_stream_type(st, TYPE_BODY, START);
@


1.2.2.8
log
@Fixed some extra whitespace that had crept into the parser output
@
text
@d382 1
a382 3
  if (tag_start[0] != '/')
  {
      next_tag=__html_find_tag(&tag_start,0);
d384 29
a412 13
    /* The start tag case */
      if (!NULL_TAG(next_tag)) {
    /*
     * If the tag we have is a tag that we need to notify the termination
     * of, then send back a NULL tag that terminates all the tags we need
     * to before returning this tag. We can do this by not moving the html
     * data pointer before returning.
     */
        if ((st->needtosend & next_tag.tag) == next_tag.tag && next_tag.tag
    #ifdef TonyTables
            && !__html_current_table
    #endif
           )
d414 2
a415 3
            /* Put in a null tag (ish) */
            return_val=__html_stream_return_tag(st, Null_Tag, NULL, END, st->url);
            return_val->type|=TYPE_BODY;
d417 1
a417 16
        else
        {
            char *p=*html;
    /*
     * Otherwise do what we need to with this pointer before returning
     * any token that it generates.
     */
          if (lastwaspcdata && next_tag.block_tag && prevhs && prevhs->text)
          {
            __html_strip_trailing_spaces(prevhs->text);
            if (prevhs->text[0]=='\0')
            {
              __html_free(prevhs->text, 0);
              prevhs->text=0;
            }
          }
d419 9
a427 10
          return_val =  __html_stream_start_tag(st,next_tag, &p, url, size);
          /* More hackery - some tags swallow PCDATA - if the routine returns
             NULL, that indicates a tag that needs more PCDATA */
          if (p>ptr)
            *html=p;
          else if (p!=NULL)
            *html=ptr;
        }
        return return_val;
      }
a428 11
  else
  {
      st->isendtag=1;
    /* Otherwise it was an end tag? */
      next_tag=__html_find_tag(&tag_start,1);

      if (!NULL_TAG(next_tag)) {
    /* Register that we have an end tag */
        st->stripleadingspace=next_tag.block_tag;
        return_val = __html_stream_end_tag(st, next_tag, html, url, size);
        *html=ptr;
d430 10
a439 4
       return return_val;
      }
      else
        st->stripleadingspace=0;
d892 6
@


1.2.2.9
log
@Improved <STYLE> and <SCRIPT> skipping
Stopped multiple <DT>s with no <DD>s being concatenated
Fixed a few null pointer dereferences
Corrected definition of st->send_list
@
text
@a21 3
 * Revision 1.2.2.8  1997/07/02 17:14:47  kbracey
 * Fixed some extra whitespace that had crept into the parser output
 *
a48 1
#include <ctype.h>
d104 1
a104 1
                                             int size, const char *term);
a160 1
      return __html_stream_skip_cdata(st, html, size, "</SCRIPT");
d162 1
a162 1
      return __html_stream_skip_cdata(st, html, size, "</STYLE");
d367 1
a367 1
    if (lastwaspcdata && prevhs && prevhs->text && prevhs->tag != TABLE)
d421 1
a421 1
          return_val = __html_stream_start_tag(st,next_tag, &p, url, size);
d749 9
d805 1
a805 1
      case TAG_DL:     st->_stream_dl++;  /* Needed for indent level */
d812 1
a812 1
      case TAG_LI:     st->_stream_li++; /* Needed for indent level? */
d814 1
a814 12
      case TAG_DT:     if (st->_stream_dt)
                       {
                           /* Force a non DT tag so we get a newline */
                           HStream *r;

                           *html = NULL;
                           st->_stream_dt=0;
                           r=__html_stream_return_tag(st, Null_Tag, NULL, END, url);
                           r->type |= TYPE_BODY;
                           return r;
                       }
                       st->_stream_dt=1; /* Needed for indent level? */
d817 1
a817 1
      case TAG_DD:     st->_stream_dd=1; /* Needed for indent level? */
d992 2
d1000 1
d1026 5
a1030 1
  #if 0
d1035 1
a1035 1
  #endif
a1041 1
      break;
d1078 1
a1078 2
      if (st->_stream_anchor)
          return_val->name=st->_stream_anchor->name;
d1138 4
d1148 1
a1148 4
    if (st->_stream_anchor!=NULL) {
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
        return_val->name=st->_stream_anchor->name;
    }
d1374 5
d1380 1
d1957 1
a1957 11
static int my_strncasecmp(const char *a, const char *b, unsigned int n)
{
    while( *a && *b && n-- )
	if( tolower(*a++) != tolower(*b++) )
	    return 1;

    return 0;
}


static HStream * __html_stream_skip_cdata(StreamTokens *st, char **html, int size, const char *term)
a1959 3
    int termlen = strlen(term);
    char term0 = term[0];

d1962 1
a1962 1
        if (*ptr == term0)
d1964 1
a1964 1
            if (size < termlen)
d1969 2
a1970 1
            if (my_strncasecmp(ptr, term, termlen)==0)
d1972 6
@


1.2.2.10
log
@Stopped the library passing Tag structures around by value (bleuch!)
@
text
@d15 35
d73 1
a73 1
static    HStream * __html_stream_start_tag(StreamTokens *st, Tag *next_tag,
d75 1
a75 1
static    HStream * __html_stream_end_tag(StreamTokens *st, Tag *next_tag,
d78 1
a78 1
                              Tag *next_tag, char *url);
d80 1
a80 1
                              Tag *next_tag, char *url);
d82 1
a82 1
                              Tag *next_tag, char *url);
d84 1
a84 1
                              Tag *next_tag, char *url, int size);
d86 1
a86 1
                              Tag *next_tag, char *url);
d91 1
a91 1
static    HStream * __html_form_handler(StreamTokens *st, Tag *next_tag,
d93 1
a93 1
/*static*/HStream * __html_stream_return_tag(StreamTokens *st, Tag *tag,
d145 1
a145 1
  Tag     *next_tag;
d392 1
a392 1
      if (next_tag) {
d399 1
a399 1
        if ((st->needtosend & next_tag->tag) == next_tag->tag && next_tag->tag
d406 1
a406 1
            return_val=__html_stream_return_tag(st, &Null_Tag, NULL, END, st->url);
d416 1
a416 1
          if (lastwaspcdata && next_tag->block_tag && prevhs && prevhs->text)
d426 1
a426 1
          return_val = __html_stream_start_tag(st, next_tag, &p, url, size);
d443 1
a443 1
      if (next_tag) {
d445 1
a445 1
        st->stripleadingspace=next_tag->block_tag;
d745 1
a745 1
static HStream *__html_stream_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
d755 1
a755 1
    switch(next_tag->tag_no)
d790 1
a790 1
      case TAG_H7:     st->_stream_h=next_tag->tag; break;
d817 1
a817 1
                           r=__html_stream_return_tag(st, &Null_Tag, NULL, END, url);
d905 1
a905 1
static HStream *__html_stream_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
d908 1
a908 1
  st->needtosend |= next_tag->tag;
d913 1
a913 1
  switch(next_tag->tag_no) {
d1053 1
a1053 1
static HStream *__html_stream_image(StreamTokens *st, char **html, Tag *next_tag, char *url)
d1065 1
a1065 1
      return_val->type=__html_stream_type(st, next_tag->type, START);
d1123 1
a1123 1
static HStream *__html_stream_hr(StreamTokens *st, char **html, Tag *next_tag, char *url)
d1151 1
a1151 1
    return_val->type=__html_stream_type(st, next_tag->type, START) | noshade;
d1181 1
a1181 1
static HStream *__html_stream_anchor(StreamTokens *st, char **html, Tag *next_tag, char *url)
d1197 1
a1197 1
static HStream *__html_stream_frame (StreamTokens *st, char **html, Tag *next_tag, char *url, int size)
d1208 1
a1208 1
    return_val->type = __html_stream_type(st, next_tag->type, START);
d1248 1
a1248 1
static HStream *__html_stream_base(StreamTokens *st, char **html, Tag *next_tag, char *url)
d1339 1
a1339 1
/*static*/ HStream *__html_stream_return_tag(StreamTokens *st, Tag *tag, char **html, int start, char *url)
d1351 2
a1352 2
      ret->style=__html_stream_style(st) | tag->tag; // This appears to put dodgy stuff in the style word
      ret->type=__html_stream_type(st, tag->type, start);
d1354 1
a1354 1
      if (tag->tag==TABLE) {
d1376 1
a1376 1
      if (tag->tag_no==TAG_BODY)
d1379 1
a1379 1
        ret->tag=tag->tag;
d1382 1
a1382 1
      if (tag->tag == TABLE) {
d1388 1
a1388 1
//      Printf ("%s has tag field %08x\n", tag->start_tag, tag->tag);
d1390 1
a1390 1
      if (tag->tag_no == TAG_BODY) {
d1409 1
a1409 1
      } else if (tag->tag == TYPE_FRAMESET) {
d1676 1
a1676 1
static HStream * __html_form_handler(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
d1690 1
a1690 1
  if (anc == NULL && next_tag->tag != OPTION)
d1702 1
a1702 1
  if (next_tag->tag == OPTION || next_tag->tag == TEXTAREA || next_tag->tag == SELECT)
d1711 1
a1711 1
  switch(next_tag->tag_no) {
d1718 1
a1718 1
	       ret->type=__html_stream_type(st, next_tag->type, START);
d1731 1
a1731 1
	       ret->type=__html_stream_type(st, next_tag->type, START);
d1774 1
a1774 1
	       ret->type=__html_stream_type(st, next_tag->tag, START);
d1798 1
a1798 1
	       ret->type=__html_stream_type(st, next_tag->type, START);
@


1.2.2.11
log
@Stopped table code using HStream flags word.
Allowed parsing of <--- Hello ---> style comments.
@
text
@d457 3
a459 15
                int i;

                /* Check for a run of -s */
                for (i=2; i<size; i++)
                {
                    if (ptr[i] != '-')
                    {
                        *html = ptr+i;
                        st->state = Comment;
                        return NULL;
                    }
                }
                /* Have not reached the end of this run yet */
                *html = ptr;
                RETURN(NULL);
d490 3
a492 15
                int i;

                /* Check for a run of -s */
                for (i=2; i<size; i++)
                {
                    if (ptr[i] != '-')
                    {
                        *html = ptr+i;
                        st->state = Declaration;
                        return NULL;
                    }
                }
                /* Have not reached the end of this run yet */
                *html = ptr;
                RETURN(NULL);
@


1.2.2.12
log
@Made to deal with an empty <A NAME="fred"></A>
@
text
@d168 1
a236 1
        st->need_to_send_name=0;
d239 5
d250 3
d988 7
a994 31
    case TAG_A:
    {
      /* Cope with <A NAME="fred"></A> */
      if (st->need_to_send_name)
      {
          HStream *return_val;
          st->need_to_send_name=0;

          /* To stop it stripping spaces before the <A NAME="x"> */
          st->isendtag=0;

          return_val=HStreamalloc();
          if (return_val)
          {
              return_val->style=__html_stream_style(st)|PCDATA;
              return_val->type=__html_stream_type(st, TYPE_BODY, END);
              return_val->indent=__html_stream_indent(st);
              if (st->_stream_anchor != NULL) {
                return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
                return_val->name=st->_stream_anchor->name;
                return_val->target = st->_stream_anchor->target;
              }
              fill_in_colour_info(st, return_val);
              return_val->tag=next_tag->tag;
          }
          __html_stream_end_anchor(st);
          return return_val;
      }
      __html_stream_end_anchor(st);
      break;
    }
a1069 1
          st->need_to_send_name=0;
a1137 1
        st->need_to_send_name=0;
d1175 2
a1176 8
  if (st->_stream_anchor)
  {
      if (!st->_stream_anchor->target)
          st->_stream_anchor->target = strdup(st->target);

      if (st->_stream_anchor->name)
          st->need_to_send_name = 1;
  }
a1361 1
        st->need_to_send_name=0;
@


1.2.2.13
log
@Totally redesigned attribute parsing code.
Started new API for accessing attributes - only implemented for BODY.
Added <BODY alink onload onunload> support.
@
text
@a22 1
#include "elementinf.h"
d43 1
a43 1
                              Tag *next_tag);
d45 1
a45 1
                              Tag *next_tag);
d47 1
a47 1
                              Tag *next_tag);
d49 3
a51 4
                              Tag *next_tag, int size);
static    HStream * __html_stream_frameset(StreamTokens *st, char **html,
                              Tag *next_tag, int size);
static    HStream * __html_stream_base(StreamTokens *st);
d57 1
a57 1
                              char **html, int size);
d59 1
a59 1
                              char **html, int start);
d64 1
a73 1
static void parse_rowcols (char *ptr, unsigned int *values, unsigned int *number);
d207 1
a207 1
      if (!(return_val->style & (P|BR|DL|OL|UL))) {
d234 1
a234 1
        return_val->anchor=st->_stream_anchor->href;
d363 1
a363 1
            return_val=__html_stream_return_tag(st, &Null_Tag, NULL, END);
d555 3
d606 10
a615 3
  if (st->_stream_form) {
    temp |= ((unsigned int)(st->form_method)     <<TYPE_METHOD_SHIFT);
    temp |= ((unsigned int)(st->form_selected)   <<TYPE_SELECTED_SHIFT);
d636 2
a637 1
  	 	         st->_stream_ul);
d731 4
a734 2

    __html_process_attributes(st, next_tag, *html, url);
d748 11
a758 3
      case TAG_FORM:       return __html_form_handler(st, next_tag, html, size);
      case TAG_BASEFONT:   if (ATTR_VAL(FONTSIZE) >= 1 && ATTR_VAL(FONTSIZE) <= 7)
                               st->_stream_basefont = ATTR_VAL(FONTSIZE);
d760 1
a760 10
      case TAG_FONT: {     int first=1;

                           if (ATTR_SET(COLOUR))
                               add_colour_info(st, ATTR_VAL(COLOUR), &first);

                           if (ATTR_SET(FONTSIZE))
                               add_size_info(st, ATTR_STR(FONTSIZE), &first);

                           break;
                     }
d770 5
a774 1
      case TAG_H6:     st->_stream_h=next_tag->tag; break;
a775 1
      case TAG_DIR:
d790 1
a790 1
                       return __html_stream_return_tag(st,next_tag,html,START);
d798 1
a798 1
                           r=__html_stream_return_tag(st, &Null_Tag, NULL, END);
d804 1
a804 1
      	   	       return __html_stream_return_tag(st,next_tag,html,START);
d807 1
a807 1
      	   	       return __html_stream_return_tag(st,next_tag,html,START);
d809 2
a810 2
      case TAG_HR:     return __html_stream_hr(st, html, next_tag);
      case TAG_BR:     return __html_stream_return_tag(st,next_tag,html,START);
d818 2
a819 2
      case TAG_IMG:    return __html_stream_image(st,html, next_tag);
      case TAG_A:      __html_stream_anchor(st, html, next_tag); break;
d837 1
d842 1
a842 1
      case TAG_BASE:   __html_stream_base(st); break;
d846 11
a856 4
      case TAG_FRAME:   return __html_stream_frame(st, html, next_tag, size);
      case TAG_BODY: {
              HStream *ret=__html_stream_return_tag(st,next_tag,html,START);
              if (ret)
d858 2
a859 12
                  //ret->tag = 0;
                  //ret->style |= IMG;
                  ret->info = (elementinfo *)__html_malloc(sizeof (elementinfo_body), 1);
                  if (!ret->info) { __html_free(ret, 0); return NULL; }
                  ret->info->body.onload = ATTR_STR(ONLOAD);
                  ret->info->body.onunload = ATTR_STR(ONUNLOAD);
                  ret->info->body.background = ATTR_STR(BACKGROUND);
                  ret->info->body.text = ATTR_SET(FGCOL) ? ATTR_VAL(FGCOL) : NULL_COLOUR;
                  ret->info->body.bgcolour = ATTR_SET(BGCOL) ? ATTR_VAL(BGCOL) : NULL_COLOUR;
                  ret->info->body.link = ATTR_SET(LINKCOL) ? ATTR_VAL(LINKCOL) : NULL_COLOUR;
                  ret->info->body.vlink = ATTR_SET(VLINK) ? ATTR_VAL(VLINK) : NULL_COLOUR;
                  ret->info->body.alink = ATTR_SET(ALINK) ? ATTR_VAL(ALINK) : NULL_COLOUR;
d861 7
a867 3
              return ret;
          }
      case TAG_FRAMESET:return __html_stream_frameset(st, html, next_tag, size);
d933 4
a937 1
    case TAG_DIR:
d976 1
d998 1
a998 1
                return_val->anchor=st->_stream_anchor->href;
d1058 1
a1058 1
static HStream *__html_stream_image(StreamTokens *st, char **html, Tag *next_tag)
d1060 1
d1066 6
a1071 3
    return_val->style=__html_stream_style(st) | IMG;
    return_val->type=__html_stream_type(st, next_tag->type, START);
    if (ATTR_SET(ISMAP))
d1073 25
a1097 10

    switch (ATTR_VAL(ALIGN))
    {
        case 1: return_val->type|=_html_top<<TYPE_ALIGN_SHIFT; break;
        case 2: return_val->type|=_html_middle<<TYPE_ALIGN_SHIFT; break;
        case 3: return_val->type|=_html_bottom<<TYPE_ALIGN_SHIFT; break;
        case 4: return_val->type|=_html_left<<TYPE_ALIGN_SHIFT; break;
        case 5: return_val->type|=_html_right<<TYPE_ALIGN_SHIFT; break;
        case 6: return_val->type|=_html_centre<<TYPE_ALIGN_SHIFT; break;
        default:return_val->type|=_html_none<<TYPE_ALIGN_SHIFT; break;
d1099 1
d1101 2
a1102 22
    if (st->_stream_anchor!=NULL) {
        return_val->anchor=st->_stream_anchor->href;
        return_val->name=st->_stream_anchor->name;
        return_val->target=st->_stream_anchor->target;
    }

    st->need_to_send_name=0;

    return_val->text=ATTR_STR(ALT);

    return_val->src=ATTR_STR(SRC);

    return_val->rows=ATTR_VAL(HEIGHT);
    return_val->cols=ATTR_VAL(WIDTH);
    return_val->maxlen=ATTR_SET(BORDER) ? ATTR_VAL(BORDER) : 2;

    /* If one of HEIGHT or WIDTH are missing, remove the other one as
       well to prevent confusion */
    if (return_val->rows==0 || return_val->cols==0)
        return_val->cols=return_val->rows=0;

    st->needtosend=0;
d1129 1
a1129 1
static HStream *__html_stream_hr(StreamTokens *st, char **html, Tag *next_tag)
d1131 1
d1139 11
a1149 8
    if (ATTR_SET(NOSHADE))
        noshade=1;
    switch (ATTR_VAL(ALIGN))
    {
        case 1: alignment = _html_left; break;
        case 2: alignment = _html_right; break;
        case 3: alignment = _html_centre; break;
        default:alignment = _html_none; break;
a1150 10
    if (ATTR_SET(WIDTH))
    {
        return_val->cols = ATTR_VAL(WIDTH) | (1<<24);
        if (st->curattrs[WIDTH].miscflag)
            return_val->cols |= UNITS_PERCENT << 28;
        else
            return_val->cols |= UNITS_PIXELS << 28;
    }
    return_val->size=ATTR_VAL(SIZE);

d1153 1
a1153 1
        return_val->anchor=st->_stream_anchor->href;
d1188 1
a1188 1
static HStream *__html_stream_anchor(StreamTokens *st, char **html, Tag *next_tag)
d1190 1
a1190 5
  AnchorInfo *anc;
  int gotsomething=0;

  NOT_USED(html); NOT_USED(next_tag);

d1192 2
a1193 14

  anc = (AnchorInfo *) __html_malloc(sizeof(AnchorInfo), 1);
  if (!anc) return NULL;

  if (ATTR_SET(NAME))
      anc->name = ATTR_STR(NAME), gotsomething=1, st->need_to_send_name = 1;

  if (ATTR_SET(HREF))
      anc->href = ATTR_STR(HREF), gotsomething=1;

  if (ATTR_SET(TARGET))
      anc->target = ATTR_STR(TARGET), gotsomething=1;

  if (gotsomething)
d1195 2
a1196 2
      if (!anc->target)
          anc->target = strdup(st->target);
d1198 2
a1199 1
      st->_stream_anchor = anc;
a1200 1

d1210 1
a1210 1
static HStream *__html_stream_frame (StreamTokens *st, char **html, Tag *next_tag, int size)
d1212 1
d1217 1
d1223 5
a1227 2
    return_val->type |= ATTR_VAL(SCROLLING) << TYPE_SCROLLING_SHIFT;
    if (ATTR_SET(NORESIZE))
d1229 7
a1235 21
    if (ATTR_SET(FRAMEBORDER))
        return_val->indent = ATTR_VAL(FRAMEBORDER);
    else
        return_val->indent = 8;
    if (ATTR_SET(BORDERCOLOUR))
        return_val->maxlen = ATTR_VAL(BORDERCOLOUR) | 1;
    return_val->rows   = ATTR_VAL(MARGINHEIGHT);
    return_val->cols   = ATTR_VAL(MARGINWIDTH);
    return_val->name   = ATTR_STR(NAME);
    return_val->src    = ATTR_STR(SRC);
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;
d1237 1
a1237 36
  __html_stream_grab_pcdata(html, size, 1);
  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_frameset (char **html)             */
/********************************************************************/
/* Given a frame start tag, extract the relevant information        */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_frameset(StreamTokens *st, char **html, Tag *tag, int size)
{
  HStream     *return_val;
  char        *ptr;

  st->_stream_frameset++;
  st->_stream_noframes = 0;
  return_val=HStreamalloc();
  if (return_val != NULL) {
    return_val->style  = __html_stream_style(st) | tag->tag;
    return_val->tag    = tag->tag;
    return_val->type   = __html_stream_type(st, tag->type, START);
    return_val->size   = st->_stream_frameset;
    if (ATTR_SET(ROWS))
    {
        parse_rowcols(ATTR_STRPEEK(ROWS), NULL, &return_val->rows);
        return_val->name = __html_malloc(sizeof(unsigned int), return_val->rows);
        if (return_val->name)
            parse_rowcols(ATTR_STRPEEK(ROWS), (unsigned int *) (return_val->name), NULL);
    }
    if (ATTR_SET(COLS))
    {
        parse_rowcols(ATTR_STRPEEK(COLS), NULL, &return_val->cols);
        return_val->value = __html_malloc(sizeof(unsigned int), return_val->cols);
        if (return_val->value)
            parse_rowcols(ATTR_STRPEEK(COLS), (unsigned int *) (return_val->value), NULL);
d1261 1
a1261 1
static HStream *__html_stream_base(StreamTokens *st)
d1263 2
a1264 5
  if (st->url) __html_free(st->url, 0);
  if (st->target) __html_free(st->target, 0);

  st->url = ATTR_STR(HREF);
  st->target = ATTR_STR(TARGET);
d1266 18
d1352 1
a1352 1
/*static*/ HStream *__html_stream_return_tag(StreamTokens *st, Tag *tag, char **html, int start)
d1356 3
d1363 1
d1366 12
d1384 1
a1384 1
        ret->anchor=st->_stream_anchor->href;
d1390 54
a1443 1
      ret->tag=tag->tag;
d1445 2
d1466 181
d1658 7
a1664 3
  /* Don't free href or target - HStreams point directly to them.
   * They will get freed normally when the stream is discarded.
   */
d1671 12
d1690 1
a1690 1
static HStream * __html_form_handler(StreamTokens *st, Tag *next_tag, char **html, int size)
d1692 1
d1698 1
a1698 1
  /*if (st->_stream_forms) __html_stream_free_anchor(&(st->_stream_forms));*/
d1700 8
d1729 2
a1730 4
    	       if (ATTR_SET(METHOD))
    	            st->form_method=ATTR_VAL(METHOD);
    	       else
    	            st->form_method=1; /* Default to GET form (there are morons out there) */
d1733 5
a1737 3
	       ret->anchor = ATTR_STR(ACTION);
               ret->target = ATTR_STR(TARGET);
               ret->enctype = ATTR_STR(ENCTYPE);
d1747 4
a1750 9
	       ret->maxlen=ATTR_VAL(MAXLENGTH);
	       ret->size=ATTR_VAL(SIZE);
	       ret->value=ATTR_STR(VALUE);
	       ret->name=ATTR_STR(NAME);
	       ret->src=ATTR_STR(SRC);
               ret->type|=ATTR_VAL(TYPE) << TYPE_INPUT_SHIFT;
               if (ATTR_SET(CHECKED)) ret->type |= TYPE_CHECKED;
               st->form_disabled=ATTR_SET(DISABLED);
	       if (ATTR_VAL(TYPE) == TEXT || ATTR_VAL(TYPE) == PASSWORD) {
d1758 2
d1764 11
d1783 1
d1790 2
a1791 3
	       ret->value=ATTR_STR(VALUE);
	       st->form_selected = ATTR_SET(SELECTED);
	       st->form_disabled = ATTR_SET(DISABLED);
d1821 3
a1823 4
	       ret->cols=ATTR_VAL(COLS);
	       ret->rows=ATTR_VAL(ROWS);
	       ret->name=ATTR_STR(NAME);
	       st->form_disabled = ATTR_SET(DISABLED);
d1883 1
a1883 2
               Flags byte: bit 0 = selected
                           bit 1 = disabled
d1940 2
a1941 4
    ret->name=ATTR_STR(NAME);
    st->form_disabled = ATTR_SET(DISABLED);
    if (ATTR_SET(MULTIPLE)) ret->type |= TYPE_MULTIPLE;
    ret->size=ATTR_VAL(SIZE);
d1961 1
a1961 1
        ret->parent = __html_current_cell;
a2003 47
}

/* parse_rowcols (local)
 *
 *   ptr -> FRAMESET ROWS=""/COLS="" data to parse
 *   values = NULL:
 *      put number of data into number
 *   value != NULL:
 *      put data into values array
 *
 * counts number of data items, or puts data items in an array
 */

static void parse_rowcols (char *ptr, unsigned int *values, unsigned int *number) {

  unsigned int value;

  if (!values) *number = 0;

  do {
    while (isspace(*ptr)) ptr++;
    value = 0;
    if (isdigit(*ptr)) {
      value = (unsigned int) strtol (ptr, &ptr, /*base=*/10);
    }
    while (isspace(*ptr)) ptr++;
    if (*ptr == '*') {
      if (!value) value = 1;
      value |= ROWCOL_STAR;
      ptr++;
    } else if (*ptr == '%') {
      value |= ROWCOL_PERCENT;
      ptr++;
    }
    while (isspace(*ptr)) ptr++;
    if (*ptr == ',') {
      ptr++;
    }
    while (isspace(*ptr)) ptr++;

    if (values) {
      *values++ = value;
    } else {
      *number += 1;
    }

  } while (isdigit (*ptr) || *ptr == '*');
@


1.2.2.14
log
@Added META support
@
text
@d824 3
a826 13
      case TAG_META: {
              HStream *ret=__html_stream_return_tag(st,next_tag,html,START);
              if (ret)
              {
                  ret->info = (elementinfo *)__html_malloc(sizeof (elementinfo_meta), 1);
                  if (!ret->info) { __html_free(ret, 0); return NULL; }
                  ret->info->meta.http_equiv = ATTR_STR(HTTP_EQUIV);
                  ret->info->meta.name       = ATTR_STR(NAME);
                  ret->info->meta.content    = ATTR_STR(CONTENT);
                  ret->info->meta.scheme     = ATTR_STR(SCHEME);
              }
              return ret;
      }
d837 2
@


1.2.2.15
log
@SCRIPT and <A onclick> handling, hopefully
@
text
@d73 2
a74 2
static    HStream * __html_stream_script(StreamTokens *st, char **html,
                                             int size, const char *term, int tag);
d132 1
a132 1
      return __html_stream_script(st, html, size, "</SCRIPT", SCRIPT);
d134 1
a134 1
      return __html_stream_script(st, html, size, "</STYLE", STYLE);
a236 3
        #ifdef CUSTOMER_SPECIAL
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
a986 3
                #ifdef CUSTOMER_SPECIAL
                return_val->onclick=st->_stream_anchor->onclick;
                #endif
a1073 3
        #ifdef CUSTOMER_SPECIAL
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
a1149 3
        #ifdef CUSTOMER_SPECIAL
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
a1203 5
  #ifdef CUSTOMER_SPECIAL
  if (ATTR_SET(ONCLICK))
      anc->onclick = ATTR_STR(ONCLICK), gotsomething=1;
  #endif

a1407 3
        #ifdef CUSTOMER_SPECIAL
        ret->onclick=st->_stream_anchor->onclick;
        #endif
d1735 1
a1735 1
static HStream *__html_stream_script(StreamTokens *st, char **html, int size, const char *term, int tag)
d1746 2
d1749 1
a1749 1

a1751 2
                HStream *ret;

a1752 10
                /* Produce a return token with the data in the text field */
                ret = HStreamalloc();
                if (ret)
                {
                    ret->tag = tag;
                    ret->style = __html_stream_style(st);
                    ret->type = __html_stream_type(st, TYPE_HEAD, START);
                    ret->text = strndup(*html, ptr - *html - 1);
                    __html_unescape_string(ret->text);
                }
d1754 1
a1754 1
                return ret;
d1761 1
@


1.2.2.16
log
@Redid handling of FORM tags to use an elementinfo structure.
@
text
@d609 1
d1510 1
d1512 4
a1515 3
    	       ret->info=(elementinfo *)__html_malloc(sizeof(elementinfo_form), 1);
    	       if (!ret->info) { __html_free(ret, 0); return NULL; }
    	       st->_stream_form=1;
d1518 3
a1521 7
    	       ret->info->form.action         = ATTR_STR(ACTION);
    	       ret->info->form.method         = (formmethod) ATTR_VAL(METHOD);
               ret->info->form.accept_charset = ATTR_STR(ACCEPT_CHARSET);
               ret->info->form.enctype        = ATTR_STR(ENCTYPE);
               ret->info->form.onsubmit       = ATTR_STR(ONSUBMIT);
               ret->info->form.onreset        = ATTR_STR(ONRESET);
               ret->info->form.target         = ATTR_STR(TARGET);
@


1.2.2.17
log
@Added HtmlReturnContext (__html_return_context) to get the context of a
block of memory (e.g. an HStream structure). This allows clients to check
if some particular block belongs to a stream that is about to be freed,
say, and take appropriate action before the freeing. Merged in a few
changes by Kevin Bracey to help with vertical white space problems,
mostly involving SCRIPT tags - there was also a bug in BASE which didn't
check for an HREF before trying to read the attributes value, so broken
HTML like <BASE FONT=1> would stop all subsequent HREFs from being
correctly relativised.
@
text
@d414 1
a414 1
        st->stripleadingspace=1;
d1334 2
a1335 5
  if (ATTR_SET(HREF))
  {
      if (st->url) __html_free(st->url, 0);
      st->url = ATTR_STR(HREF);
  }
d1337 2
a1338 5
  if (ATTR_SET(TARGET))
  {
      if (st->target) __html_free(st->target, 0);
      st->target = ATTR_STR(TARGET);
  }
a1784 1
                st->stripleadingspace = 1;
@


1.2.2.18
log
@Revised INPUT handling - made INPUT type=image work
@
text
@a1532 3
    {
               elementinfo_input *info;

a1533 3
    	       info=(elementinfo_input *)__html_malloc(sizeof(elementinfo_input), 1);
    	       ret->info=(elementinfo *)info;
    	       if (!info) { __html_free(ret, 0); return NULL; }
a1535 1
               ret->indent=__html_stream_indent(st);
d1537 11
a1547 21
               info->type      = (inputtype) ATTR_VAL(TYPE);
	       info->name      = ATTR_STR(NAME);
	       info->value     = ATTR_STR(VALUE);
               info->checked   = ATTR_SET(CHECKED);
               info->disabled  = ATTR_SET(DISABLED);
               info->readonly  = ATTR_SET(READONLY);
	       info->size      = ATTR_VAL(SIZE);
	       info->maxlength = ATTR_VAL(MAXLENGTH);
	       info->src       = ATTR_STR(SRC);
	       info->alt       = ATTR_STR(ALT);
	       info->usemap    = ATTR_STR(USEMAP);
	       info->align     = (imgalign) ATTR_VAL(ALIGN);
               info->tabindex  = ATTR_VAL(TABINDEX);
               info->onfocus   = ATTR_STR(ONFOCUS);
               info->onblur    = ATTR_STR(ONBLUR);
               info->onselect  = ATTR_STR(ONSELECT);
               info->onchange  = ATTR_STR(ONCHANGE);
               info->accept    = ATTR_STR(ACCEPT);
	       if (info->type == inputtype_TEXT || info->type == inputtype_PASSWORD) {
  	         if (info->maxlength > 0) {
  	           ret->text=strndup(info->value, info->maxlength); /* Ensure big buffer */
d1550 1
a1550 1
  	           ret->text=strndup(info->value, 1024);
d1552 2
a1553 2
  	       } else if (info->type == inputtype_IMAGE)
  	           ret->text=strdup(info->alt);
a1554 1
    }
a1612 3
  if (ret)
      fill_in_colour_info(st, ret);

a1650 1
    elementinfo_select *info;
d1687 4
a1690 9

    info=(elementinfo_select *)__html_malloc(sizeof(elementinfo_select), 1);
    ret->info=(elementinfo *)info;
    if (!info) { HtmlStreamFree(h); free(s); __html_free(ret, 0); return NULL; }

    info->options=(int *)__html_malloc(count, 1);
    info->options[0] = items;
    info->options[1] = 0;
    p = (char *) &info->options[2];
d1716 1
a1716 1
    assert((p+1)-(char *)info->options == count);
a1721 1

d1724 4
a1728 11

    info->name     = ATTR_STR(NAME);
    info->disabled = ATTR_SET(DISABLED);
    info->multiple = ATTR_SET(MULTIPLE);
    info->size     = ATTR_VAL(SIZE);
    info->tabindex = ATTR_VAL(TABINDEX);
    info->onfocus  = ATTR_STR(ONFOCUS);
    info->onblur   = ATTR_STR(ONBLUR);
    info->onselect = ATTR_STR(ONSELECT);
    info->onchange = ATTR_STR(ONCHANGE);

@


1.2.2.19
log
@Fixed &#160;, fixed option selection, changed GOT_MORE flag
@
text
@d607 4
a1585 2
    	       ret->info=(elementinfo *)__html_malloc(sizeof(elementinfo_option), 1);
    	       if (!ret->info) { __html_free(ret, 0); return NULL; }
d1590 2
a1591 2
	       ret->info->option.selected = ATTR_SET(SELECTED);
	       ret->info->option.disabled = ATTR_SET(DISABLED);
d1624 1
a1624 1
	       /*st->form_disabled = ATTR_SET(DISABLED);*/
d1726 1
a1726 1
            *p++=hp->info->option.selected;
@


1.2.2.20
log
@Fixed FRAME and FRAMESET border attributes
@
text
@d1248 1
a1248 13
    {
        char *p = ATTR_STRPEEK(FRAMEBORDER);
        UPPER_CASE(p);

        if (strstr(p, "YES")) return_val->indent = 8;
        else if (strstr(p, "NO")) return_val->indent = 0;
        else
        {
            return_val->indent = atoi(p);
            if (return_val->indent == 1)
                return_val->indent = 8;
        }
    }
a1305 16
    if (ATTR_SET(FRAMEBORDER))
    {
        char *p = ATTR_STRPEEK(FRAMEBORDER);
        UPPER_CASE(p);

        if (strstr(p, "YES")) return_val->indent = 8;
        else if (strstr(p, "NO")) return_val->indent = 0;
        else
        {
            return_val->indent = atoi(p);
            if (return_val->indent == 1)
                return_val->indent = 8;
        }
    }
    else
        return_val->indent = 8;
@


1.2.2.21
log
@Bug with frame border colours fixed (by Kevin)
@
text
@a1333 3

    if (ATTR_SET(BORDERCOLOUR))
        return_val->maxlen = ATTR_VAL(BORDERCOLOUR) | 1;
@


1.2.2.22
log
@Did align on <P> and right align on tables.
Fixed problem with the final ">" of "</SCRIPT>" ending up in the title.
Fixed problem of HtmlGetStream returning a pointer to the wrong parent table.
Added SUB and SUP.
@
text
@d72 1
a72 1
static    HStream * HStreamalloc(tag_no);
d74 1
a74 1
                                             int size, const char *term, int tag, tag_no tagno);
d132 1
a132 1
      return __html_stream_script(st, html, size, "</SCRIPT>", SCRIPT, TAG_SCRIPT);
d134 1
a134 1
      return __html_stream_script(st, html, size, "</STYLE>", STYLE, TAG_STYLE);
d167 1
a167 1
    return_val=HStreamalloc((tag_no)0);
d176 2
a177 2
      if ((return_val->style & PRE) == PRE ||
      	   return_val->tagno == TAG_TEXTAREA) {
d250 1
a250 1
      memset(st->needtosend, 0, sizeof st->needtosend);
d361 1
a361 1
        if (st->needtosend[next_tag->tag_no] && next_tag->tag_no
d568 1
a568 4
    if (st->_stream_centre)	    return_val |= CENTER;
    if (st->_stream_right)	    return_val |= RIGHT;
    if (st->_stream_sub)	    return_val |= SUB;
    if (st->_stream_sup)	    return_val |= SUP;
d571 2
d749 1
a749 1
      case TAG_CENTER:     st->_stream_centre++; break;
d802 1
a802 22
      case TAG_P:   {  int align = ATTR_VAL(ALIGN);
                       st->_stream_p=1;
                       if (align != 0 && !st->_stream_palign)
                       {
                           st->_stream_palign = 1;
                           st->_stream_oldcentre = st->_stream_centre;
                           st->_stream_oldright = st->_stream_right;
                       }
                       if (align == 1)
                           st->_stream_centre = st->_stream_right = 0;
                       else if (align == 2)
                           st->_stream_centre = 1, st->_stream_right = 0;
                       else if (align == 3)
                           st->_stream_centre = 0, st->_stream_right = 1;
                       else if (st->_stream_palign)
                       {
                           st->_stream_palign = 0;
                           st->_stream_centre = st->_stream_oldcentre;
                           st->_stream_right = st->_stream_oldright;
                       }
                       break;
                     }
a814 2
      case TAG_SUB:    st->_stream_sub++; break;
      case TAG_SUP:    st->_stream_sup++; break;
d880 1
a880 1
  st->needtosend[next_tag->tag_no] = 1;
d901 4
d913 1
a913 1
      DEC(st->_stream_centre);
d978 1
a978 1
          return_val=HStreamalloc(TAG_A);
a1018 9

    case TAG_SUB:
      DEC(st->_stream_sub);
      break;

    case TAG_SUP:
      DEC(st->_stream_sup);
      break;

d1053 1
a1053 1
  return_val=HStreamalloc(TAG_IMG);
d1095 1
a1095 1
    memset(st->needtosend, 0, sizeof st->needtosend);
d1129 1
a1129 1
  return_val=HStreamalloc(TAG_HR);
d1150 1
a1150 1
    memset(st->needtosend, 0, sizeof st->needtosend);
d1238 1
a1238 1
  return_val=HStreamalloc(TAG_FRAME);
d1298 1
a1298 1
  return_val=HStreamalloc(TAG_FRAMESET);
d1334 3
d1446 1
a1446 1
  ret=HStreamalloc(tag->tag_no);
d1468 1
a1468 1
      memset(st->needtosend, 0, sizeof st->needtosend);
d1525 1
a1525 1
  ret=HStreamalloc(next_tag->tag_no);
d1531 1
a1531 3
  if (next_tag->tag_no == TAG_OPTION ||
      next_tag->tag_no == TAG_TEXTAREA ||
      next_tag->tag_no == TAG_SELECT)
d1556 1
a1556 1
               st->needtosend[TAG_FORM] = 1;
d1563 1
d1567 1
a1567 1
	       ret->style=__html_stream_style(st);
d1612 1
d1615 1
a1615 1
	       ret->style=__html_stream_style(st);
d1638 3
a1640 1
	       ret->style=__html_stream_style(st);
d1670 1
a1670 1
  return_val=HStreamalloc((tag_no)0);
d1730 1
a1730 1
        if (hp->tagno == TAG_OPTION)
d1750 1
a1750 1
        if (hp->tagno == TAG_OPTION)
d1777 3
a1779 1
    ret->style=__html_stream_style(st);
d1794 1
a1794 1
    st->needtosend[TAG_SELECT] = 1;
d1806 1
a1806 1
HStream *HStreamalloc(tag_no tagno)
a1810 1
    {
a1811 2
        ret->tagno = tagno;
    }
d1826 1
a1826 1
static HStream *__html_stream_script(StreamTokens *st, char **html, int size, const char *term, int tag, tag_no tagno)
d1845 1
a1845 1
                ret = HStreamalloc(tagno);
@


1.2.2.23
log
@Fixed prebsem with <INPUT value="">
@
text
@d334 1
a334 1
    if (lastwaspcdata && prevhs && prevhs->text && prevhs->tag == PCDATA)
@


1.2.2.24
log
@Stopped clash with TABLE, SCRIPT or STYLE looking like TITLE - should now
check for titles with (tagno=TAG_TITLE), rather than (style & TITLE).
@
text
@d171 1
a171 5

      if (st->_stream_title)
        return_val->tagno=TAG_TITLE;
      else
        return_val->style=__html_stream_style(st) | PCDATA;
a536 1
  /*
a540 1
  */
d577 1
a577 1
  /*}*/
@


1.2.2.25
log
@Encoding support added (yippee). #define UNIFONT to get UTF-8 output,
otherwise Latin-1 output is provided. Lots of encoding files...
@
text
@d162 1
a162 1
      *html += 1;
d171 1
d173 1
a173 1
          return_val->tagno = TAG_TITLE;
d175 1
a175 1
          return_val->style=__html_stream_style(st) | PCDATA ;
d1736 1
a1736 1
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, 106 /* UTF-8 */, priority_user);
@


1.2.2.26
log
@Altered comment handling. It expects them to start with '<!', end with '>',
and there may be '<' '>' pairs inside but they must be correctly matched.
If there are too many '>'s, some of the commented out region will be visible
on the page. The other way round - you'll probably have a blank page ;-)
@
text
@d70 2
a71 2
//static    HStream * __html_stream_comment(StreamTokens *st, char **html,
//                                          int size);
d128 2
a129 2
//    case Comment:
//      return __html_stream_comment(st, html, size);
a438 1

a439 1

d442 1
a442 11
//        if (*ptr == '>')
//        {
//            *html = ptr + 1;
//            st->state = Other;
//            return NULL;
//        }

        if      (*ptr == '<') st->anglecount++;
        else if (*ptr == '>') st->anglecount--;

        if (st->anglecount < 0)
a443 3
            st->anglecount = 0;
            st->state      = Other;

d445 1
d448 10
d459 15
a473 27
//        if (*ptr == '-')
//        {
//            if (size < 2)
//            {
//                *html = ptr;
//                RETURN(NULL);
//            }
//            if (*(ptr+1) == '-')
//            {
//                int i;
//
//                /* Check for a run of -s */
//                for (i=2; i<size; i++)
//                {
//                    if (ptr[i] != '-')
//                    {
//                        *html = ptr+i;
//                        st->state = Comment;
//                        return NULL;
//                    }
//                }
//                /* Have not reached the end of this run yet */
//                *html = ptr;
//                RETURN(NULL);
//            }
//        }

d482 44
a525 44
// /********************************************************************/
// /* __html_stream_comment                                            */
// /********************************************************************/
// /* Called instead of __html_stream_parse when inside a -- -- pair   */
// /********************************************************************/
// static HStream *__html_stream_comment(StreamTokens *st, char **html,
//                                       int size)
// {
//     char *ptr = *html;
//     while (size)
//     {
//         if (*ptr == '-')
//         {
//             if (size < 2)
//             {
//                 *html = ptr;
//                 RETURN(NULL);
//             }
//             if (*(ptr+1) == '-')
//             {
//                 int i;
//
//                 /* Check for a run of -s */
//                 for (i=2; i<size; i++)
//                 {
//                     if (ptr[i] != '-')
//                     {
//                         *html = ptr+i;
//                         st->state = Declaration;
//                         return NULL;
//                     }
//                 }
//                 /* Have not reached the end of this run yet */
//                 *html = ptr;
//                 RETURN(NULL);
//             }
//         }
//         ptr++;
//         size--;
//     }
//
//     *html = ptr;
//     RETURN(NULL);
// }
@


1.2.2.27
log
@Bras Direct now works. Woohoo. Doesn't die when loading extremely large
chunks - malloc failures due to a locked flex heap caused problems.
HttpEndParse call added to free up parse related blocks. To solve layout
problems on certain sizes, spacer images (align left or right) which are
less than 2 pixels wide, or are more than 15 times tall than wide, will
be ignored.
@
text
@a1102 20
  /* Throw out certain nasty image thingies which probably don't */
  /* contribute much to the page alignment...                    */

  if (ATTR_VAL(ALIGN) == 4 || ATTR_VAL(ALIGN) == 5)
  {
    if (
         (
           ATTR_SET(WIDTH) &&
           ATTR_VAL(WIDTH) <= 2
         )
         ||
         (
           ATTR_SET(WIDTH)  &&
           ATTR_SET(HEIGHT) &&
           ATTR_VAL(HEIGHT) > ATTR_VAL(WIDTH) * 15
         )
       )
       return NULL;
  }

d1158 2
a1159 2
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
d1226 2
a1227 2
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
d1327 1
a1327 1
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
a1345 2
  if (!ATTR_SET(ROWS) && !ATTR_SET(COLS)) return NULL;

d1391 2
a1392 2
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
d1524 2
a1525 2
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
d1582 2
a1583 2
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
@


1.2.2.28
log
@Turned off CUSTOMER_SPECIAL.
Changed encoding tables to use FFFF as a null value instead of FFFD.
Added OBJECT support (more testing required - PARAM not yet done).
Added AREA support (commented out - MAP not yet done). They come out
looking like <A></A> elements.
Souped up mapping to Latin-1 (added lossy tables for Latin Extended
Additional, CJK Punctuation and Fullwidth forms).
Added support for <H1 align=...>
Stripped some superfluous whitespace caused by linefeeds.
Fixed missing linebreak in "<DT>One<DT>Two" by turning the second DT into
a BR.
Removed now unnecessary free(malloc(16384)) bodge.
Put in CJK code even if UNIFONT not defined (hey - why not?).
Added code to take direct pointer to table rather than loading it if
it's in ResourceFS.
Added support for encoding "x-acorn-latin1".
Ensured correct handling of OPTIONs when UNIFONT not defined.
@
text
@d36 3
a44 2
static    HStream *__html_stream_area(StreamTokens *st, char **html,
                              Tag *next_tag);
d63 1
a63 1
                              int contig, int after_tag);
d72 1
d74 1
a74 1
                                             int size, const char *term, tag_no tagno);
a75 1
static char *__html_skip_record_end(const char *s);
d84 6
d132 1
a132 1
      return __html_stream_script(st, html, size, "</SCRIPT>", TAG_SCRIPT);
d134 1
a134 1
      return __html_stream_script(st, html, size, "</STYLE>", TAG_STYLE);
d170 1
a170 1
      return_val->text=__html_stream_grab_pcdata(html, size, 0, 0);
a307 3
  if (*ptr == '>')
    ptr++;

a372 2
            return_val->tag = DUMMY;
            return_val->style |= DUMMY;
a397 3

          /* Take off any RE (line feed) following a start tag */
          *html = __html_skip_record_end(*html);
a412 2
        if (next_tag->block_tag)
            *html = __html_skip_record_end(*html);
d459 1
a459 1
            *html = __html_skip_record_end(ptr + 1);
d552 1
a552 1
unsigned int __html_stream_style(StreamTokens *st)
d589 2
a590 13
    if (st->_stream_h && st->_stream_halign)
    {
        switch (st->_stream_halign)
        {
            case 2: return_val |= CENTER; break;
            case 3: return_val |= RIGHT; break;
        }
    }
    else
    {
        if (st->_stream_centre)	    return_val |= CENTER;
        if (st->_stream_right)	    return_val |= RIGHT;
    }
d612 1
a612 1
unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start)
d643 1
a643 1
unsigned int __html_stream_indent(StreamTokens *st)
d674 1
a674 1
static char *__html_stream_grab_pcdata(char **input, int size, int contig, int after_tag)
d676 1
a676 1
  char *end;
a678 5
  if (after_tag)
      end = __html_skip_record_end(*input);
  else
      end = *input;

a757 4
      /*case TAG_MAP:        return __html_map_handler(st, next_tag, html, size);*/
      /*case TAG_AREA:       return __html_stream_area(st, html, next_tag);*/
      case TAG_OBJECT:     return __html_stream_object(st, html, next_tag);
      /*case TAG_PARAM:      return __html_stream_param(st, html);*/
d780 1
a780 3
      case TAG_H6:     st->_stream_h=next_tag->tag;
                       st->_stream_halign=ATTR_VAL(ALIGN);
                       break;
d800 8
a807 3
                           char *br = "BR>";
                           /* Send back a BR tag - easiest way to get a linebreak */
                           return __html_stream_return_tag(st, __html_find_tag(&br, 0), html, START);
d811 1
a811 2
                       break;
      	   	       /*return __html_stream_return_tag(st,next_tag,html,START);*/
d814 1
a814 2
                       break;
      	   	       /*return __html_stream_return_tag(st,next_tag,html,START);*/
a1080 3
    case TAG_OBJECT:
      __html_stream_end_object(st);
      break;
d1351 1
a1351 1
  __html_stream_grab_pcdata(html, size, 1, 1);
d1418 1
a1418 1
  __html_stream_grab_pcdata(html, size, 1, 1);
d1690 1
a1690 1
	       ret->text=__html_stream_grab_pcdata(html, size, 1, 1);
d1709 1
a1709 1
	       ret->text=__html_stream_grab_pcdata(html, size, 1, 1);
a1772 1
    #ifdef UNIFONT
a1773 3
    #else
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, 5001 /* Acorn Latin-1 */, priority_user);
    #endif
d1842 1
a1842 1
    HtmlEndParse(s);
d1894 1
a1894 1
static HStream *__html_stream_script(StreamTokens *st, char **html, int size, const char *term, tag_no tagno)
d1916 1
d1922 1
a1922 1
                *html = __html_skip_record_end(ptr);
a1978 66
}

/********************************************************************/
/* static HStream *__html_stream_area(char **html)                  */
/********************************************************************/
/* Given an area tag, extract the relevant information              */
/* associated with this tag and present it as an <A> element. 	    */
/********************************************************************/
static HStream *__html_stream_area(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream *ret;

  NOT_USED(next_tag);

  /* Fill in an HStream */
  ret = __html_stream_return_tag(st, next_tag, html, 1);
  if (!ret)
      return NULL;

  ret->style |= A;

  /* Get the coordinates */
  if (ATTR_SET(COORDS))
      ret->coords = ATTR_COORDS(COORDS);
  else if (ATTR_VAL(SHAPE) == areashape_DEFAULT)
      /* If no coordinates, and shape = DEFAULT, that's okay - put in a dummy coords block. */
      ret->coords = (int *) __html_malloc(sizeof(int), 2);

  if (!ret->coords)
  {
      __html_free(ret, 0);
      return NULL;
  }

  ret->coords[0] = ATTR_VAL(SHAPE);

  ret->anchor = ATTR_STR(HREF);
  ret->target = ATTR_STR(TARGET);

  if (ATTR_SET(ALT))
      ret->text = ATTR_STR(ALT);
  else
      ret->text = strdup(ret->anchor);

  return ret;
}

/********************************************************************/
/* static HStream *__html_skip_record_end(char *s)                  */
/********************************************************************/
/* Skip over record ends (RE) (line feed). Need to cope with there  */
/* being spaces at the end of lines or start of the last line.      */
/********************************************************************/
static char *__html_skip_record_end(const char *s)
{
    const char *p = s;
    bool found_re = false;

    while (*p == ' ' || *p == 10 || *p == 13)
    {
        if (*p != ' ')
            found_re = true;
        p++;
    }

    return (char *) (found_re ? p : s);
@


1.2.2.29
log
@Added STRIKE and U support.
@
text
@d369 2
a370 2
            return_val->tagno = TAG_DUMMY;
            /*return_val->style |= DUMMY;*/
a606 2
    if (st->_stream_u)              return_val |= UNDERLINE;
    if (st->_stream_strike)         return_val |= STRIKE;
a881 2
      case TAG_U:      st->_stream_u++; break;
      case TAG_STRIKE: st->_stream_strike++; break;
a1088 8
      break;

    case TAG_U:
      DEC(st->_stream_u);
      break;

    case TAG_STRIKE:
      DEC(st->_stream_strike);
@


1.2.2.30
log
@Deal more elegantly with <DT> and <DD> outside of a DL element.
Strip spaces after </MAP>.
@
text
@d825 1
a825 1
      case TAG_DT:     if (st->_stream_dt || !st->_stream_dl)
d835 1
a835 7
      case TAG_DD:     if (st->_stream_dd || !st->_stream_dl)
                       {
                           char *br = "BR>";
                           /* Send back a BR tag - easiest way to get a linebreak */
                           return __html_stream_return_tag(st, __html_find_tag(&br, 0), html, START);
                       }
                       st->_stream_dd=1; /* Needed for indent level? */
@


1.2.2.31
log
@Added simple support for <DIV align=...>
Forced linebreaks after </CENTRE> (and </DIV>).
@
text
@a875 15
      case TAG_DIV:    if (st->_stream_palign)
                       {
                           st->_stream_palign = 0;
                           st->_stream_centre = st->_stream_oldcentre;
                           st->_stream_right = st->_stream_oldright;
                       }
                       st->_stream_h = 0;
                       switch (ATTR_VAL(ALIGN))
                       {
                           default:
                           case 1: st->_stream_centre = st->_stream_right = 0; break;
                           case 2: st->_stream_centre = 1; st->_stream_right = 0; break;
                           case 3: st->_stream_centre = 0; st->_stream_right = 1; break;
                       }
                       break;
a985 1
      st->_stream_br = 1;
a986 7
      break;

    case TAG_DIV:
      st->_stream_br = 1;
      st->_stream_palign = 0;
      st->_stream_centre = 0;
      st->_stream_right = 0;
@


1.2.2.32
log
@To solve problems with odd position of NOFRAMES, HTMLLib now uses the
Navigator-esque behaviour of ignoring everything after a /FRAMESET,
provided the frameset had at least one FRAME tag inside. This was
mostly for 'http://www.airuk.co.uk/'.
@
text
@a1147 1
      if (st->_stream_frameset == 1 && st->had_frame) st->dead = 1;
d1375 1
a1375 5

  if (return_val != NULL)
  {
    st->had_frame = 1;

@


1.2.2.33
log
@Stopped style being attached to SCRIPT and STYLE tokens.
Stopping leading spaces being stripped from PRE elements.
Removed TABLE,TR,TD and TH from the style word.
@
text
@d74 1
a74 1
static char *__html_skip_record_end(const char *s, int strip_leading);
d398 1
a398 1
          *html = __html_skip_record_end(*html, next_tag->tag_no != TAG_PRE && next_tag->tag_no != TAG_TEXTAREA);
d415 1
a415 1
            *html = __html_skip_record_end(*html, 1);
d462 1
a462 1
            *html = __html_skip_record_end(ptr + 1, 1);
d611 3
d696 1
a696 1
      end = __html_skip_record_end(*input, 1);
d911 2
a912 1
      case TAG_TABLE:  return __html_table_start_tag(st, next_tag, html, url, size);
d1991 1
a1991 1
                    /*ret->style = __html_stream_style(st);*/
d1996 1
a1996 1
                *html = __html_skip_record_end(ptr, 1);
d2106 1
a2106 1
static char *__html_skip_record_end(const char *s, int skip_leading)
d2111 1
a2111 1
    while ((*p == ' ' || *p == 10 || *p == 13) && !(found_re && !skip_leading && *p == ' '))
a2114 1

@


1.2.2.34
log
@Some pages could be parsed in the context of a previous table - fixed.
Made the 'throw away very tall images' code only do it for images < 6
pixels wide.
@
text
@d160 1
a160 1
    return_val=HStreamalloc(st, (tag_no)0);
d362 1
a362 1
            && !st->current_table
d1070 1
a1070 1
          return_val=HStreamalloc(st, TAG_A);
d1178 2
a1179 3
           ATTR_SET(WIDTH)      &&
           ATTR_SET(HEIGHT)     &&
           ATTR_VAL(WIDTH) <= 6 &&
d1186 1
a1186 1
  return_val=HStreamalloc(st, TAG_IMG);
d1262 1
a1262 1
  return_val=HStreamalloc(st, TAG_HR);
d1371 1
a1371 1
  return_val=HStreamalloc(st, TAG_FRAME);
d1437 1
a1437 1
  return_val=HStreamalloc(st, TAG_FRAMESET);
d1582 1
a1582 1
  ret=HStreamalloc(st, tag->tag_no);
d1661 1
a1661 1
  ret=HStreamalloc(st, next_tag->tag_no);
d1800 1
a1800 1
HStream *__html_return_text_token(StreamTokens *st, char *doc, size_t size)
d1804 1
a1804 1
  return_val=HStreamalloc(st, (tag_no)0);
d1942 1
a1942 1
HStream *HStreamalloc(StreamTokens *st, tag_no tagno)
d1948 1
a1948 1
        ret->parent = st->current_cell;
d1984 1
a1984 1
                ret = HStreamalloc(st, tagno);
@


1.2.2.35
log
@Implemented ordered lists.
Implemented <Q> ... </Q>.
Caused a linebreak after </DD>.
Finished implementing attributes for <OBJECT>.
Stopped HTML after a </FRAMESET> leaking through.
Ensured that FRAME and FRAMESET tokens aren't passed up if not using frames.

Removed lots of unnecessary #include "utf8.h" lines from encoding files.
Ensured unsigned constants used in UTF-8 code.
Added UTF8_next and UTF8_prev functions.
@
text
@a41 2
static    HStream * __html_stream_q(StreamTokens *st, char **html,
                              int start);
a808 4
      	   	       if (st->_stream_ol + st->_stream_ul <= MAX_OL)
      	   	       {
      	   	           st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = 'u';
      	   	       }
a810 11
                       if (st->_stream_ol + st->_stream_ul <= MAX_OL)
                       {
                           int start = ATTR_VAL(STARTattr);
                           int style = ATTR_VAL(TYPE);
                           if (ATTR_SET(STARTattr))
                               start--;
                           if (!style)
                               style = '1';
                           st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] = start;
                           st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = style;
                       }
d820 2
a821 20
      case TAG_LI: {
                       HStream *ret;

                       st->_stream_li++; /* Needed for indent level? */
                       if (st->_stream_ol + st->_stream_ul > 0 && st->_stream_ol + st->_stream_ul <= MAX_OL)
                       {
                           if (ATTR_SET(VALUE))
                               st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] = ATTR_VAL(VALUE);
                           else
                               st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] ++;

                           if (ATTR_SET(TYPE))
                               st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = ATTR_VAL(TYPE);
                       }

                       ret = __html_stream_return_tag(st,next_tag,html,START);
                       if (ret)
                           __html_construct_ol_text(st, ret);
                       return ret;
                   }
a902 2
      case TAG_Q:      return __html_stream_q(st, html, START);

a1035 1
      st->_stream_br = 1; /* Yuck. */
a1123 3
    case TAG_Q:
      return __html_stream_q(st, html, END);

a1371 3
  if (!st->usingframes)
      return NULL;

a1433 3
  if (!st->usingframes)
      return NULL;

a2116 52
}

static HStream *__html_stream_q(StreamTokens *st, char **html, int start)
{
    HStream *ret;
    char *ptr;
    static const char quote[2][2][4] =
    {
        #ifdef UNIFONT
        "", "", "", ""
        #else
        "",   "",   "",   ""
        #endif
    };

    ret = HStreamalloc(st, (tag_no)0);
    if (ret)
    {
        ret->text = strdup(quote[st->_stream_q & 1][start]);
        ret->style=__html_stream_style(st) | PCDATA;
        ret->type=__html_stream_type(st, TYPE_BODY, START);
        ret->indent=__html_stream_indent(st);
        ret->tag=PCDATA;
        st->lastwaspcdata = 1;
        fill_in_colour_info(st, ret);
        memset(st->needtosend, 0, sizeof st->needtosend);
        if (st->_stream_anchor != NULL)
        {
            ret->anchor=st->_stream_anchor->href;
            #ifdef CUSTOMER_SPECIAL
            ret->onclick=st->_stream_anchor->onclick;
            #endif
            ret->name=st->_stream_anchor->name;
            st->need_to_send_name=0;
            ret->target = st->_stream_anchor->target;
        }
    }

    st->_stream_q += start ? +1 : -1;

  /*
   * This routine is called with the understanding that it will update
   * the HTML pointer. Move it to past the next > or the end of the input
   * whichever is sooner. In theory it should be the former.
   */
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;

    return ret;

@


1.2.2.36
log
@Added basic support - in terms of changing text styles as appropriate
but nothing more - for ACRONYM, BIG, BLINK, DEL, DFN, S, and SMALL.
XMP maps to PRE correctly now (so it isn't a correct implementation,
but again, the text style is OK) and ADDRESS has been flagged as a
block level element.
@
text
@d400 1
a400 1
          *html = __html_skip_record_end(*html, next_tag->tag_no != TAG_PRE && next_tag->tag_no != TAG_XMP && next_tag->tag_no != TAG_TEXTAREA);
d785 1
a785 1
      case TAG_FONT:  {     int first=1;
d787 2
a788 2
                            if (ATTR_SET(COLOUR))
                                add_colour_info(st, ATTR_VAL(COLOUR), &first);
d790 2
a791 2
                            if (ATTR_SET(FONTSIZE))
                                add_size_info(st, ATTR_STR(FONTSIZE), &first);
d793 2
a794 14
                            break;
                      }
      case TAG_BIG:   {     int first=1;

                            add_size_info(st, "+1", &first);
                            break;
                      }

      case TAG_ACRONYM:
      case TAG_SMALL: {     int first=1;

                            add_size_info(st, "-1", &first);
                            break;
                      }
d798 1
a798 2
      case TAG_XMP:
      case TAG_PRE:        st->_stream_pre++; break;
a931 1
      case TAG_DFN:
a936 1
      case TAG_INS:
a939 2
      case TAG_S:
      case TAG_DEL:
a1025 3
    case TAG_BIG:
    case TAG_SMALL:
    case TAG_ACRONYM:
a1083 1
    case TAG_XMP:
a1140 1
    case TAG_DFN:
a1157 1
    case TAG_INS:
a1164 2
    case TAG_S:
    case TAG_DEL:
d2173 1
a2173 1
        "", "", "", ""
d2175 1
a2175 1
        "",   "",   "",   ""
@


1.2.2.37
log
@PARAM and APPLET, take 1.
@
text
@d781 1
a781 2
      case TAG_PARAM:      return __html_stream_param(st, html, next_tag);
      case TAG_APPLET:     return __html_stream_applet(st, html, next_tag);
@


1.2.2.38
log
@Fixed links to "./".
Ensured incomplete OBJECTs not returned (I hope).
Stopped newlines being stripped inside PRE.
Made </P> turn off any paragraph alignment.
Added HtmlReplaceOBJECT call.
@
text
@a115 7
  if (st->special_return)
  {
      return_val = st->special_return;
      st->special_return = NULL;
      return return_val;
  }

d400 1
a400 2
          if (!st->_stream_pre || next_tag->tag_no == TAG_PRE || next_tag->tag_no == TAG_XMP || next_tag->tag_no == TAG_TEXTAREA)
              *html = __html_skip_record_end(*html, next_tag->tag_no != TAG_PRE && next_tag->tag_no != TAG_XMP && next_tag->tag_no != TAG_TEXTAREA);
d416 1
a416 1
        if (next_tag->block_tag && !st->_stream_pre)
d464 1
a464 4
            if (!st->_stream_pre)
                *html = __html_skip_record_end(ptr + 1, 1);
            else
                *html = ptr+1;
a1053 9
    case TAG_P:
      if (st->_stream_palign)
      {
          st->_stream_palign = 0;
          st->_stream_centre = st->_stream_oldcentre;
          st->_stream_right = st->_stream_oldright;
      }
      break;

d1831 1
a1831 1
	       ret->text=__html_stream_grab_pcdata(html, size, 1, !st->_stream_pre);
d2066 1
a2066 4
                if (!st->_stream_pre)
                    *html = __html_skip_record_end(ptr, 1);
                else
                    *html = ptr;
@


1.2.2.39
log
@Previous check-in broke APPLET and OBJECTs inside tables.
Also, /APPLET didn't work (thought I'd fixed this?)
Default border for images now 0 if not a link.
@
text
@a790 1
      case TAG_APPLET:
d793 1
a1226 1
    case TAG_APPLET:
d1309 1
a1309 2
    return_val->maxlen=ATTR_SET(BORDER) ? ATTR_VAL(BORDER) :
                                          return_val->anchor ? 2 : 0;
@


1.2.2.40
log
@Implemented % sizing of images.
@
text
@d1308 2
a1309 17
    if (ATTR_SET(WIDTH))
    {
        return_val->cols = ATTR_VAL(WIDTH) | (1<<24);
        if (st->curattrs[WIDTH].miscflag)
            return_val->cols |= UNITS_PERCENT << 28;
        else
            return_val->cols |= UNITS_PIXELS << 28;
    }
    if (ATTR_SET(HEIGHT))
    {
        return_val->rows = ATTR_VAL(HEIGHT) | (1<<24);
        if (st->curattrs[HEIGHT].miscflag)
            return_val->rows |= UNITS_PERCENT << 28;
        else
            return_val->rows |= UNITS_PIXELS << 28;
    }

@


1.2.2.41
log
@Added EMBED support (creating lookalike OBJECTs).
Removed startup table initialisation, because latest compiler can do it.
@
text
@a793 1
      case TAG_EMBED:      return __html_stream_embed(st, html, next_tag);
@


1.2.2.42
log
@Added objects flag to HtmlParse
@
text
@d1955 1
a1955 1
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, 5001 /* Acorn Latin-1 */, priority_user);
@


1.2.2.43
log
@HR attribute NOSHADE fixed
@
text
@d1371 1
a1371 1
        noshade=TYPE_NOSHADE;
@


1.2.2.44
log
@Modified comment handling to close comment forcibly on '-->'
@
text
@d467 1
a467 12
        /* Count < and > pairs, but allow the comment close '-->' */
        /* to forcibly end the comment section.                   */

        if (
             st->anglecount < 0 ||
             (
               size >= 3         &&
               *ptr == '-'       &&
               *(ptr + 1) == '-' &&
               *(ptr + 2) == '>'
             )
           )
a468 2
            int inc = (*ptr == '-') ? 3 : 1;

d473 1
a473 1
                *html = __html_skip_record_end(ptr + inc, 1);
d475 1
a475 1
                *html = ptr + inc;
@


1.2.2.45
log
@OBJECT-based image maps now supported (done by KBracey)
@
text
@a245 1
        return_val->coords=st->_stream_anchor->coords;
a1466 10

  /* Get the coordinates */
  if (ATTR_SET(COORDS))
      anc->coords = ATTR_COORDS(COORDS);
  else if (ATTR_VAL(SHAPE) == areashape_DEFAULT)
      /* If no coordinates, and shape = DEFAULT, that's okay - put in a dummy coords block. */
      anc->coords = (int *) __html_malloc(sizeof(int), 2);

  if (anc->coords)
      anc->coords[0] = ATTR_VAL(SHAPE);
@


1.2.2.46
log
@Added apostrophe (U+02BC) to Unicode->Latin1 list.
Added &euro; entity to name list.
Fixed UNIFONT compile version.
@
text
@d1977 1
a1977 1
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, 106 /* UTF-8 */, priority_user);
@


1.2.2.47
log
@MAP and AREA handling - first attempt
@
text
@d44 1
a44 2
static    HStream * __html_map_handler(StreamTokens *st);
static    HStream * __html_stream_area(StreamTokens *st, char **html,
d803 2
a804 2
      case TAG_MAP:        return __html_map_handler(st);
      case TAG_AREA:       return __html_stream_area(st, html, next_tag);
a1065 4
    case TAG_MAP:
      st->_stream_map=0;
      break;

a1296 14
    if (ATTR_SET(USEMAP))
    {
        elementinfo_object *info;
        info = (elementinfo_object *)__html_malloc(sizeof(elementinfo_object), 1);
        if (info)
        {
            return_val->info = (elementinfo *) info;
            info->usemap = ATTR_STR(USEMAP);
            info->maps = st->maps;
            return_val->type |= TYPE_ISCLIENTMAP;
        }
    }


a2190 23
/* static HStream *__html_map_handler(char **html)                  */
/********************************************************************/
/* Given an map tag, prepare a new MapStream.              	    */
/********************************************************************/
static HStream *__html_map_handler(StreamTokens *st)
{
    MapStream *map;

    /* Need a name */
    if (!ATTR_STRPEEK(NAME)) return NULL;

    map = (MapStream *) __html_malloc(sizeof(MapStream), 1);
    if (!map) return NULL;

    map->name = ATTR_STR(NAME);
    map->next = st->maps->next;
    st->maps->next = map;
    st->_stream_map = 1;

    return NULL;
}

/********************************************************************/
d2194 1
a2194 2
/* associated with this tag and present it as an <A> element,       */
/* attached to the current map.                         	    */
d2198 1
a2198 1
  HStream *ret, **prev;
a2201 2
  if (!st->_stream_map) return NULL;

d2232 1
a2232 6
  for (prev = &st->maps->next->stream; *prev; prev = &(*prev)->next)
      continue;

  *prev = ret;

  return NULL;
@


1.2.2.48
log
@Made BASE TARGET work for FORMs and AREAs.
@
text
@d1848 1
a1848 4
               if (ATTR_SET(TARGET))
                   ret->info->form.target     = ATTR_STR(TARGET);
               else
                   ret->info->form.target     = strdup(st->target);
d2270 1
a2270 5

  if (ATTR_SET(TARGET))
      ret->target = ATTR_STR(TARGET);
  else
      ret->target = strdup(st->target);
@


1.2.2.49
log
@Now allows just WIDTH or HEIGHT on an IMG tag, rather than requiring both.
@
text
@d1362 4
a1365 4
//    /* If one of HEIGHT or WIDTH are missing, remove the other one as
//       well to prevent confusion */
//    if (return_val->rows==0 || return_val->cols==0)
//        return_val->cols=return_val->rows=0;
@


1.2.2.50
log
@*** empty log message ***
@
text
@a39 1
static    HStream * __html_stream_end_form(StreamTokens *st, char **html);
d638 1
d802 1
a802 1
      case TAG_TEXTAREA:
d1064 2
a1065 1
      return __html_stream_end_form(st, html);
d1838 2
a1839 1
	       ret->style=__html_stream_style(st) | FORM;
d1842 1
a1842 4
               if (ATTR_SET(ACTION))
    	           ret->info->form.action     = ATTR_STR(ACTION);
    	       else
    	           ret->info->form.action     = strdup(st->url);
d1862 1
a1862 1
	       ret->style=__html_stream_style(st) | FORM;
d1909 1
a1909 1
	       ret->style=__html_stream_style(st) | FORM;
d1932 1
a1932 1
	       ret->style=__html_stream_style(st) | FORM;
d2003 2
a2004 1
    /* Hack hack hack! */
d2028 2
a2029 7
            count += 1 +
                     strlen(hp->text) +
                     1 +
                     (hp->value ? strlen(hp->value) : strlen(hp->text)) +
                     1;

            items += 1;
d2058 6
a2063 1
            sprintf(p, "%s%n", hp->value ? hp->value : hp->text, &len); p+=len+1;
d2073 1
a2073 1
    ret->style=__html_stream_style(st) | FORM;
a2099 28
static HStream *__html_stream_end_form(StreamTokens *st, char **html)
{
    HStream *ret;
    char *ptr;
    ret = HStreamalloc(st, TAG_FORM_END);
    if (ret)
    {
        ret->style=__html_stream_style(st) | FORM;
        ret->type=__html_stream_type(st, TYPE_BODY, END);
        ret->indent=__html_stream_indent(st);
        ret->tag=FORM;
        fill_in_colour_info(st, ret);
    }

  /*
   * This routine is called with the understanding that it will update
   * the HTML pointer. Move it to past the next > or the end of the input
   * whichever is sooner. In theory it should be the former.
   */
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;

    return ret;

}

a2364 1

@


1.2.2.51
log
@*** empty log message ***
@
text
@d216 1
a216 1
      if (!(return_val->style & (P|BR|DL|UL))) {
d594 1
a594 1
    if (st->_stream_bold)           return_val |= BOLD;
d596 4
a599 5
    if (st->_stream_tt)             return_val |= TT;
    if (st->_stream_a)              return_val |= A;
    if (st->_stream_img)            return_val |= IMG;
    if (st->_stream_nobr)           return_val |= NOBR;
    if (st->_stream_p)           { return_val |= P; st->_stream_p=0; }
d607 3
d869 1
a976 1
      case TAG_NOBR:   st->_stream_nobr++; break;
a1209 4
      break;

    case TAG_NOBR:
      DEC(st->_stream_nobr);
@


1.2.2.52
log
@HEIGHT and BACKGROUND attributes on a TABLE tag now supported, with appropriate
macros for extracting the information from a table_stream struct. A table_stream
no longer needs to be the same length or shorter than an HStream, though several
of the fields do still need to be in the same position in each structure.
@
text
@d2035 1
a2035 1

d2132 1
a2132 4
    HStream *ret;

    if (tagno == TAG_TABLE) ret = (HStream *)__html_malloc(sizeof(table_stream), 1);
    else                    ret = (HStream *)__html_malloc(sizeof(HStream),      1);
@


1.2.2.53
log
@Stopped contents of TEXTAREAs falling out.
@
text
@d53 1
a53 1
                              Tag *next_tag);
d55 1
a55 1
                              Tag *next_tag);
d65 1
a65 1
static 	     char * __html_stream_grab_pcdata(char **input,
d174 1
a174 1
      return_val->text=__html_stream_grab_pcdata(html, 0, 0);
d713 1
a713 1
static char *__html_stream_grab_pcdata(char **input, int contig, int after_tag)
d728 1
a728 1
  while ((*end != '\0') && (*end != '<') && (*end != '&'))
d734 2
a735 1
  if (*end == '\0') {
d743 1
a743 1
      for (stop = end + 1; *stop != '\0' && (isalnum(*stop) || *stop=='#' || *stop=='&'); stop++)
d746 1
a746 1
      if (*stop == ';')
d748 10
a757 7
          end = stop + 1;
          goto carryon;
      }
      else if (*stop)
      {
          end = stop;
          goto carryon;
d1008 1
a1008 1
      case TAG_FRAME:   return __html_stream_frame(st, html, next_tag);
d1026 1
a1026 1
      case TAG_FRAMESET:return __html_stream_frameset(st, html, next_tag);
d1516 1
a1516 1
static HStream *__html_stream_frame (StreamTokens *st, char **html, Tag *next_tag)
d1571 1
a1571 1
  __html_stream_grab_pcdata(html, 1, 1);
d1581 1
a1581 1
static HStream *__html_stream_frameset(StreamTokens *st, char **html, Tag *tag)
d1641 1
a1641 1
  __html_stream_grab_pcdata(html, 1, 1);
d1907 1
a1907 1
                return __html_form_parse_select(st, html, p-*html+1, ret);
d1918 1
a1918 1
	       ret->text=__html_stream_grab_pcdata(html, 1, !st->_stream_pre);
d1937 1
a1937 1
	       ret->text=__html_stream_grab_pcdata(html, 1, 1);
@


1.2.2.54
log
@Handles broken framesets with '%' instead of 'n%' (treats as 100%)
@
text
@a2218 1

a2221 1

a2222 4

      /* Navigator handles a single '%' as '100%', it seems */

      if (!value) value = 100;
d2238 1
a2238 1
  } while (isdigit (*ptr) || *ptr == '*' || *ptr == '%');
@


1.2.2.55
log
@HRs default to centre, rather than left alignment
@
text
@d1406 2
a1407 1
        default:alignment = _html_centre; break;
@


1.2.2.56
log
@BORDERCOLOR supported on FRAMESET now, as well as on FRAME
@
text
@a1623 2
    if (ATTR_SET(BORDERCOLOUR))
        return_val->maxlen = ATTR_VAL(BORDERCOLOUR) | 1;
@


1.2.2.57
log
@Added flag to HtmlParse to turn on or off tables support
@
text
@d981 4
a984 8
      case TAG_TR:     if (st->usingtables) return __html_table_row_start_tag(st, next_tag, html, url, size);
                       else break;
      case TAG_TD:     if (st->usingtables) return __html_table_data_start_tag(st, next_tag, html, url, size);
                       else break;
      case TAG_TH:     if (st->usingtables) return __html_table_head_start_tag(st, next_tag, html, url, size);
                       else break;
      case TAG_TABLE:  if (st->usingtables) return __html_table_start_tag(st, next_tag, html, url, size);
                       else break;
d1233 4
a1236 8
    case TAG_TR:    if (st->usingtables) return __html_table_row_end_tag(st, next_tag, html, url);
                    else break;
    case TAG_TD:    if (st->usingtables) return __html_table_data_end_tag(st, next_tag, html, url);
                    else break;
    case TAG_TH:    if (st->usingtables) return __html_table_head_end_tag(st, next_tag, html, url);
                    else break;
    case TAG_TABLE: if (st->usingtables) return __html_table_end_tag(st, next_tag, html, url);
                    else break;
d1999 1
a1999 1
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, 0, 106 /* UTF-8 */, priority_user);
d2001 1
a2001 1
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, 0, 5001 /* Acorn Latin-1 */, priority_user);
@


1.1
log
@file new_stream was initially added on branch ARTtmp.
@
text
@d1 1923
@


1.1.2.1
log
@Initial revision
@
text
@a0 1817
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source: /ax/networking:Phileas/HTML/c/new_stream: $
 *
 * $Log:	new_stream,v $
 * Revision 1.1  95/10/31  13:12:14  pwain
 * Initial revision
 *
 */

#include <assert.h>
#include <stdio.h>     /* For NULL etc */
#include "html2_ext.h" /* For the HTML bits */
#include "tags.h"      /* for PCDATA */
#include "struct.h"    /* For the structures */
#include "string.h"    /* For string handling */
#include "internal.h"  /* predefinitions of functions */

/******************************************************************************/
/* This comment is 80 chars wide. It was used to format this file.            */
/******************************************************************************/

/********************************************************************/
/* Predefinition of static functions contained in this file, along  */
/* along with the main parse function predifinition.   	     	    */
/********************************************************************/
          HStream *__html_stream_parse(StreamTokens *st, char **html,
                              char *url, int size);
static unsigned int __html_stream_style(StreamTokens *st);
static unsigned int __html_stream_type(StreamTokens *st,
                              unsigned int style, int start);
static unsigned int __html_stream_indent(StreamTokens *st);
static    HStream * __html_stream_start_tag(StreamTokens *st, Tag next_tag,
                              char **html,char *url, int size);
static    HStream * __html_stream_end_tag(StreamTokens *st, Tag next_tag,
                              char **html, char *url, int size);
static    HStream * __html_stream_image(StreamTokens *st, char **html,
                              Tag next_tag, char *url);
static    HStream * __html_stream_hr(StreamTokens *st, char **html,
                              Tag next_tag, char *url);
static    HStream * __html_stream_anchor(StreamTokens *st, char **html,
                              Tag next_tag, char *url);
static    HStream * __html_stream_frame(StreamTokens *st, char **html,
                              Tag next_tag, char *url, int size);
static    HStream * __html_stream_base(StreamTokens *st, char **html,
                              Tag next_tag, char *url);
static        void  __html_stream_end_anchor(StreamTokens *st);
static    HStream * __html_stream_end_header(char **html);
static    HStream * __html_form_handler(StreamTokens *st, Tag next_tag,
                              char **html, char *url, int size);
static    HStream * __html_stream_return_tag(StreamTokens *st, Tag tag,
                              char **html, int start, char *url);
static 	     char * __html_stream_grab_pcdata(char **input, int size,
                              int contig);
static       char * __html_make_anchor(char *base, char *link);
static         void __html_stream_free_anchor(AnchorInfo **anchor);
static         void strdoublecpy(char *buffer, char *s1, char *s2);
static    HStream * __html_form_parse_select(StreamTokens *, char **html,
                              int size, HStream *ret);

/********************************************************************/
/* A global variable declared in this file. A byte is an unsigned   */
/* char.    	     	      	      	      	      	 	    */
/********************************************************************/
byte __html_done_for_now=0;

/********************************************************************/
/* A few preprocessor definitions to make life easier.              */
/********************************************************************/
#define START 1
#define END   0

/********************************************************************/
/* A small macro. Set a parser internal flag for some exit states.  */
/* This permits on the fly HTML parsing to work correctly. 	    */
/********************************************************************/
#define RETURN(x) {__html_done_for_now=1; return x;}

/********************************************************************/
/* HStream *__html_stream_parse(StreamTokens *st, char **html, .... */
/********************************************************************/
/* The main parse routine. This does one of three things:           */
/*     + Grabs the next bit of text on the input stream		    */
/*     + interprets the top HTML tag on the input stream	    */
/*     + nothing because there is insufficient input (on the fly    */
/*          parsing needs this).  	       	     	     	    */
/*	    	    	  					    */
/* In the first two cases the input pointer is updated to where we  */
/* got to, in the last case, __html_done_for_now is set and the     */
/* input pointer is not moved. 			    	    	    */
/********************************************************************/
HStream *__html_stream_parse(StreamTokens *st, char **html, char *url,
                              int size)
{
  HStream *return_val=NULL;
  Tag     next_tag;
  char    *ptr;
  char 	  *tag_start;
  char 	  *start;

/* Reset the bail out pointer */
  __html_done_for_now=0;

/* Look to make sure we have a valid input pointer. Order is important here */
  if (!html || !*html || !**html) RETURN(NULL);

/* In some cases a '>' is left at the beginning of the input stream. Ignore it */
  if (**html == '>') {
/* If we ignore it, update the input pointer and the size */
    *html = *html+1;
    size--;
/* If we now have nothing left, return */
    if ((size==0) || (!**html)) RETURN((HStream *)NULL);
/* Always keep ptr in sync with HTML */
  }

  ptr=*html;
  tag_start=*html+1;
  start=*html;

/*
 * The first case. We dont have a '<' as the top of the input stream
 * and we are not inside a comment, so grab up to the next tag or the
 * end of the input stream, whichever is the sooner, and return it as
 * a text segment (PCDATA).
 */
  if ((*ptr != '<') && (st->_stream_comment==0)) {

/* This avoids a few funnies. Cant remember why but it is needed */
    if (**html == '>') {
      *html=(*html)+sizeof(char);
      size --;
    }

/* Create the structure to return. If non-NULL fill it in */
    return_val=HStreamalloc();
    if (return_val != NULL) {
/* Grab the text, and set the style word in the structure */
      return_val->flags = 0;
      return_val->text=__html_stream_grab_pcdata(html, size, 0);
      return_val->style=__html_stream_style(st) | PCDATA ;
/*
 * If the text is PREformatted or in a textarea in a form we dont want
 * to strip out the LFs, but we do need to unescape it
 */
      if (((return_val->style & PRE) == PRE ) ||
      	   ((return_val->style & TEXTAREA) == TEXTAREA)) {
        __html_strip_lfs(return_val->text); /* Strip CRs, preserve LFs */
        __html_unescape_string(return_val->text);
      } else {
/*
 * Otherwise it is true PCDATA so we need to munge spaces, CRs, LFs, and
 * unescape escape sequences in the data
 */
        __html_strip_spaces(return_val->text, st->stripleadingcr);
        __html_unescape_string(return_val->text);
      }

/*
 * Now evaluate the type word. We need this to decide what to do if there
 * is a NULL input string left at this point.
 */
      return_val->type=__html_stream_type(st,return_val->style,START);

      /*if (return_val->style & DL)
         Printf("HTMLLib: Got a DL\n");*/
/* Look to see if we have a zero length return string */
      if (*(return_val->text) == '\0') {
/*
 * If the tag is in the head, or it is not a special once-only tag,
 * dump the tag to save memory in the
 * final stream returned.
 */
      if (((return_val->type & HEAD) == HEAD) ||
           (return_val->type & BODY) &&
              !(return_val->style & (P|BR|DL|OL|UL|DIR))) {
/*
 * We only need to free the text and the structure since we havent filled
 * in any other bits, so this is faster than calling the free routine. And
 * return a NULL pointer because we dont need to do anything. 'html' has
 * already been moved at this point, so this is safe.
 */
          __html_free(return_val->text,0);
          __html_free(return_val,0);
          /*if (return_val->style & DL)
            Printf("HTMLLib: Junked a DL :-(\n");*/
          return NULL;
        }
        else {
/* Otherwise just free up the text and set the text pointer to a NULL */
          __html_free(return_val->text,0);
          return_val->text=NULL;
          /*if (return_val->style & DL)
            Printf("HTMLLib: Cleared a DL\n");*/
        }
      }

/* Calculate the list indent count */
      return_val->indent=__html_stream_indent(st);

/* If this tag has anchor information associated with it, extract it */
      if (st->_stream_anchor != NULL) {
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
        return_val->name=st->_stream_anchor->name;
        return_val->target = st->_stream_anchor->target;
      }
/* Otherwise set it to a NULL */
      else {
        return_val->anchor=NULL;
        return_val->name=NULL;
      }

/* Fill in colour information */
      fill_in_colour_info(st, return_val);

/* Set the rest of the values up as a TEXT token */
      return_val->tag=PCDATA;
      return_val->src=NULL;
      return_val->next=NULL;
      return_val->prev=NULL;
      st->needtosend=0;
      st->stripleadingcr=0;
    }

  #ifdef TRACE
  {
      FILE *fp=fopen("ADFS::4.$.Trace.ParseTrc", "a");
      if (fp)
      {
          fputs(return_val->text, fp);
          fclose(fp);
      }
  }
  #endif
/*
 * Return the structure. Note that if there was insufficient memory to
 * allocate a tag, this will return a NULL pointer, so this is safe.
 */
    //if (return_val->style & DL) Printf("HTMLLib: returned a DL\n");

    return return_val;
  }

/*
 * The next case we have to deal with is that of a comment. This can
 * be done on the fly too. Basically if we have a '<!--' or were in
 * a comment already, see if we have a '-->' on the input stream.
 * If we do, skip to the end of the '-->' otherwise wait until more
 * information is avaliable.
 */
  if ((!strncmp(ptr,"<!--",4)) || st->_stream_comment) {
/* Look to see if  we have a '-->' pending on the input */
    ptr=strnstr(ptr,"-->",size /*- (ptr-start) */);
    if (ptr != NULL) {
/* We do, so skip over it. Turn off the comment flag. */
      st->_stream_comment=0;
      *html=ptr+3;
/* A comment is a NULL token. */
      return NULL;
    }
    else {
/*
 * We didnt find the end of the comment. Set the comment flag, and return
 * setting __html_done_for_now on the way out.
 */
      st->_stream_comment=1;
      RETURN(NULL);
    }
  }

/*
 * We now think we have a tag. We extract the tag information by skipping
 * the initial '<', finding the end of the tag, and inspecting the bit
 * between the start and end pointers (*html and ptr).
 */
  ptr++; /* Skip the '<' */
  while ((ptr-start < size) && (*ptr != '\0') && (*ptr != '>') &&
                             (*ptr != '<')) {
    ptr++;
  }

/* This code breaks if there happens to be a '>' in the first byte
 * after the meaningful data
 */
#if 0
/*
 * If we hit 'size' but the first element in the stream is a '<'
 * I think we have an incomplete tag, otherwise if we have moved
 * more than 'size' bytes we have run off the end of a meaningful
 * input stream.
 */
  if (ptr-start >= size) {
    if ( ((**html == '<') && (*ptr != '>')) || (ptr-start > size) ) {
      RETURN(NULL);
    }
  }
#else
  if (ptr-start >= size)
  {
      RETURN(NULL);
  }
#endif

/*
 * We are now in a safe position to believe we have a tag and that we
 * have all of the tag. Thus we can look to see what we have.
 */

  next_tag=__html_find_tag(&tag_start,0);

/* The start tag case */
  if (!NULL_TAG(next_tag)) {
/*
 * If the tag we have is a tag that we need to notify the termination
 * of, then send back a NULL tag that terminates all the tags we need
 * to before returning this tag. We can do this by not moving the html
 * data pointer before returning.
 */
    if ((st->needtosend & next_tag.tag) == next_tag.tag && (next_tag.tag)) {
      return_val=__html_stream_return_tag(st, Null_Tag, NULL, END, st->url);
    }
    else {
        char *p=*html;
/*
 * Otherwise do what we need to with this pointer before returning
 * any token that it generates.
 */
      return_val =  __html_stream_start_tag(st,next_tag, &p, url, size);
      /* More hackery - some tags swallow PCDATA - if the routine returns
         NULL, that indicates a tag that needs more PCDATA */
      if (p>ptr)
        *html=p;
      else if (p!=NULL)
        *html=ptr;
    }
    return return_val;
  }

/* Otherwise it was an end tag? */
  next_tag=__html_find_tag(&tag_start,1);

  if (!NULL_TAG(next_tag)) {
/* Register that we have an end tag */
    return_val = __html_stream_end_tag(st, next_tag, html, url, size);
    *html=ptr;

   return return_val;
  }

/* Update the pointer and return. This skips unwanted tags etc. */

  *html=ptr;

  return return_val;
}

/********************************************************************/
/* static unsigned int __html_stream_style(void)                    */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

static unsigned int __html_stream_style(StreamTokens *st)
{
  unsigned int return_val=0;

  if (st->_stream_title) {
    return_val |= TITLE;
  }
  else {
    if (st->_stream_bold)	    return_val |= BOLD;
    if (st->_stream_italic)         return_val |= ITALIC;
    if (st->_stream_tt)	    	    return_val |= TT;
    if (st->_stream_a)	    	    return_val |= A;
    if (st->_stream_img)	    return_val |= IMG;
    if (st->_stream_p)	          { return_val |= P; st->_stream_p=0; }
                                    return_val |= st->_stream_h;
    if (st->_stream_pre)	    return_val |= PRE;

    if (st->send_list > 0) {
      if (st->send_list & DL) {
        if (st->_stream_dl)	    return_val |= DL;
      }
      if (st->send_list & OL) {
        if (st->_stream_ol)	    return_val |= OL;
      }
      if (st->send_list & UL) {
        if (st->_stream_ul)	    return_val |= UL;
      }
      if (st->send_list & DIR) {
        if (st->_stream_dir)	    return_val |= DIR;
      }
      st->send_list = 0;
    }
    /*if (st->_stream_li)	            return_val |= LI;*/
    if (st->_stream_dt)	    	    return_val |= DT;
    if (st->_stream_dd)	    	    return_val |= DD;
    if (st->_stream_br)           { return_val |= BR ; st->_stream_br=0; }
    if (st->_stream_blockquote)     return_val |= BLOCKQUOTE;
    if (st->_stream_address)        return_val |= ADDRESS;
    if (st->_stream_center)	    return_val |= CENTER;
    if (st->_stream_anchor != NULL) return_val |= A;
    if (st->_stream_form)     	    return_val |= FORM;
    if (st->_stream_select)	    return_val |= SELECT;
    if (st->_stream_textarea)	    return_val |= TEXTAREA;
/*  if (st->_stream_table)          return_val |= TABLE; */
  }

  return return_val;
}

/********************************************************************/
/* static unsigned int __html_stream_type(void)                     */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

static unsigned int __html_stream_type(StreamTokens *st, unsigned int style, int start)
{
  unsigned int temp=0;

/* if ((st->_stream_head) || (st->_stream_title)) temp=((unsigned int)1<<0); */
  if (st->_stream_title || st->_stream_head) {
    temp=((unsigned int)HEAD);

#ifdef FRAMESUPPORT
  } else if (st->_stream_body) {
    temp = TYPE_BODY;
  } else if (st->_stream_frameset) {
    temp = TYPE_FRAMESET;
  }
  if (st->_stream_noframes) {
    temp |= TYPE_NOFRAMES;
#endif
  }

  temp |= (((unsigned int) start) << TYPE_START_SHIFT);

/* Draw together the anchor and form bits just in case :) */
  if (st->_stream_anchor != NULL) {
    temp |= ((unsigned int)(st->_stream_anchor->alignment) <<TYPE_ALIGN_SHIFT);
    temp |= ((unsigned int)(st->_stream_anchor->ismap)     <<TYPE_ISMAP_SHIFT);
  }
  if (st->_stream_forms != NULL) {
    temp |= ((unsigned int)(st->_stream_forms->type)       <<TYPE_INPUT_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->method)     <<TYPE_METHOD_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->checked)    <<TYPE_CHECKED_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->multiple)   <<TYPE_MULTIPLE_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->selected)   <<TYPE_SELECTED_SHIFT);
  }
  if (st->_stream_colour != NULL) {
    if (st->_stream_colour->colour_valid)
      temp |= TYPE_COLOURED;
  }

  return temp;
}

/********************************************************************/
/* static unsigned int __html_stream_indent(void)                   */
/********************************************************************/
/* Given all the status variable attempt to work out the indent     */
/* level at this point in time	 	    	     	 	    */
/********************************************************************/
static unsigned int __html_stream_indent(StreamTokens *st)
{
  return ((unsigned int) st->_stream_dl -
                         st->_stream_dt +
  	 	         st->_stream_ol +
  	 	         st->_stream_ul +
  	 	         st->_stream_dir);
}

static char *strnchrs(char *start, const char *c, const char *end)
{
    const char *p;

    while (start < end)
    {
        for (p = c; *p; p++)
            if (*start == *p)
                return start;
        start++;
    }
    return 0;
}

/********************************************************************/
/* static char * __html_stream_grab_pcdata(char **input, int size)  */
/********************************************************************/
/* This routine returns a local copy of any PCDATA encountered at   */
/* this point, including feeding it through the relevant stripping  */
/* code etc. This routine only reads up to the next '<' sign  	    */
/********************************************************************/
static char *__html_stream_grab_pcdata(char **input, int size, int contig)
{
  char *end=*input;
  char *ret;

carryon:
/*
 * Find the start of the next tag, end of the input stream, or the
 * end of the chunk by size, which ever is the sooner.
 */
  while ((end - *input < size) && (*end != '\0') && (*end != '<') && (*end != '&'))
  {
      end++;
  }

/* If we have gone over the end of the size limit, shuffle back a bit */
  if ((end-*input) >= size) {
    end=(*input)+size;
    if (contig)
        RETURN(NULL);  /* Can't be sure we have all PCDATA yet - we'll come back later */
  } else if (*end == '&')
  {
      /* Check we don't have half an escape code */
      char *stop;

      for (stop = end + 1; isalnum(*stop) || *stop=='#' || *stop=='&'; stop++)
        continue;

      if (*stop == ';')
      {
        end = stop + 1;
        goto carryon;
      }
      else if (*stop)
      {
        end = stop;
        goto carryon;
      }
  }

/*
 * grab a copy of what we have and return it, moving the input
 * pointer accordingly.
 */
  ret=strndup(*input,(end-*input));
  __html_strip_control_codes(ret);

  *input=end;
  return ret;

}

/********************************************************************/
/* static HStream __html_stream_start_tag(Tag next_tag, char **html)*/
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words	    */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading		     	      	    	       	    */
/********************************************************************/
static HStream *__html_stream_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
    st->stripleadingcr=1;
/*
 * we have a start tag. Big case statement alert - work from the bottom
 * of the list upwards for safty :)
 */
#ifndef TABLE_SUPPORT
    if (next_tag.tag >= BR) {
/*
 * We have a body only element so if we were in the head stage
 * we should toggle to the body stage
 */
    }
#endif


    switch(next_tag.tag) {
      #ifdef TABLE_SUPPORT
      case TR:
      case TD:
      case TH:
      case TABLE:      return __html_stream_return_tag(st,next_tag,html,END,url);
      #endif
      case INPUT:
      case SELECT:
      case OPTION:
      case TEXTAREA:   if (st->_stream_form==0) break;
      case FORM:       return __html_form_handler(st, next_tag, html, url, size);
      case FONT:       {
                         AnchorInfo *anc;
                         /*
                          * __html_get_anchor_info will examine the size/colour information in
                          * the tag, and will update st. We don't actually want the AnchorInfo
                          * structure generated...
                          */
                         anc = __html_get_anchor_info(st, html, next_tag);
                         __html_stream_free_anchor(&anc);
                         break;
                       }
      case CENTER:     st->_stream_center++; break;
      case ADDRESS:    st->_stream_address++; break;
      case BLOCKQUOTE: st->_stream_blockquote++; break;
      case PRE:	       st->_stream_pre++; break;
      case H1:
      case H2:
      case H3:
      case H4:
      case H5:
      case H6:
      case H7:         st->_stream_h=next_tag.tag; break;
      case DIR:	       st->_stream_dir++; /* Needed for indent level */
      	   	       st->send_list|=DIR;
      	   	       break;
      case UL:	       st->_stream_ul++;  /* Needed for indent level */
      	   	       st->send_list|=UL;
                       break;
      case OL:	       st->_stream_ol++;  /* Needed for indent level */
      	   	       st->send_list|=OL;
      	   	       break;
      case DL:	       st->_stream_dl++;  /* Needed for indent level */
      	   	       st->_stream_dt=0;
      	   	       st->_stream_dd=0;
      	   	       st->send_list|=DL;
      	   	       //Printf("HTMLLib: Should send a DL now\n");
      	   	       break;

      case LI:	       st->_stream_li++; /* Needed for indent level? */
                       return __html_stream_return_tag(st,next_tag,html,START,url);
      case DT:	       st->_stream_dt=1; /* Needed for indent level? */
                       st->_stream_dd=0;
      	   	       return __html_stream_return_tag(st,next_tag,html,START,url);
      case DD:	       st->_stream_dd=1; /* Needed for indent level? */
                       st->_stream_dt=0;
      	   	       return __html_stream_return_tag(st,next_tag,html,START,url);

      case HR:	       return __html_stream_hr(st, html, next_tag, url);
      case BR:	       return __html_stream_return_tag(st,next_tag,html,START,url);
      default: {
/*
 * We didnt find the tag in that lot, so look in the last 10. This is
 * sort of complicated by the fact that some of these are in the
 * head and some are in the body list, and there are <HEAD> and <BODY>
 * too.
 */
        if (__html_check_tag(Body_Tags,MAX_BODY_TAGS,
               	       	              next_tag.start_tag))
        {
          switch(next_tag.tag) {
            case P:      st->_stream_p=1; break;
            case IMG:    return __html_stream_image(st,html, next_tag, url);
            case A:      __html_stream_anchor(st, html, next_tag, url); break;
            case TT:     st->_stream_tt++; break;
            case ITALIC: st->_stream_italic++; break;
            case BOLD:	 st->_stream_bold++; break;
          }
       } else if ((__html_check_tag(Head_Tags, MAX_HEAD_TAGS,
             		           next_tag.start_tag)) != NULL) {
          switch(next_tag.tag) {
            case NEXTID:
            case META:
            case LINK:   //st->_stream_head=1;
            	         break; /* We are ignoring these for now */
            case TITLE:  st->_stream_title++; break;
            case BASE:   __html_stream_base(st, html, next_tag, url); break;
            case ISINDEX: st->_stream_isindex=1; st->_stream_head=1; break;
          }
        } else
#ifdef FRAMESUPPORT
        /* Slightly contrived code follows: this only has an else clause, largely to
         * keep the structure of the 'else if' chain, thus allowing for easy future
         * expansion - TGR */

        if (__html_check_tag(Frameset_Tags, MAX_FRAMESET_TAGS, next_tag.start_tag)
           && next_tag.tag == FRAME) {
             return __html_stream_frame (st, html, next_tag, url, size);
        } else
#endif
        {
          switch(next_tag.tag) {
            case HEAD: st->_stream_head=1; break;
            case BODY: {
              if (st->_stream_head != 0) { // use to be (.. >= 1)
                st->_stream_head=0;
                st->_stream_body=1;
                /* return __html_stream_end_header(html); */
              }
              st->_stream_body=1;
              __html_stream_anchor(st, html, next_tag, url);
              return __html_stream_return_tag(st,next_tag,html,START,url);
            }
#ifdef FRAMESUPPORT
            case TYPE_FRAMESET: {
              HStream *ret_val;
              st->_stream_frameset++;
              st->_stream_head = 0;
              st->_stream_body = 0;
              st->_stream_noframes = 0;
              __html_stream_anchor(st, html, next_tag, url);
              if (st->_stream_anchor) {
                st->_stream_anchor->size = st->_stream_frameset;
//                st->_stream_frame = 0;
              }
              ret_val =  __html_stream_return_tag(st,next_tag,html,START,url);

              __html_stream_grab_pcdata(html, size, 1);

              return ret_val;
              break;
            }
            case TYPE_NOFRAMES:
              st->_stream_noframes = 1;
              st->_stream_body = 1;
              st->_stream_head = 0;
              break;
#endif
          }
        }
      }
    }
/* In theory we dont need to do any more so we can return here */
    return NULL;
}

#define DEC(a) if ((a) > 0) { (a)--; }

/********************************************************************/
/* static Hstream *__html_stream_end_tag(Tag next_tag, char **html) */
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words	    */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading		     	      	    	       	    */
/********************************************************************/
static HStream *__html_stream_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
    st->stripleadingcr=1;
/* Make a note of this token for later use */
  st->needtosend |= next_tag.tag;
/*
 * we have a start tag. Big case statement alert - work from the bottom
 * of the list upwards for safty :) */
  switch(next_tag.tag) {
    #ifdef TABLE_SUPPORT
    case TR:
    case TD:
    case TH:
    case TABLE: return __html_stream_return_tag(st,next_tag,html,END,url);
    #endif

    case FORM:
      st->_stream_form=0;
      break;

    case SELECT:
      st->_stream_select=0;
      break;

    case TEXTAREA:
      st->_stream_textarea=0;
      break;

    case FONT:
      font_tag_closed(st);
      st->stripleadingcr = 0;
      break;

    case CENTER:
      DEC(st->_stream_center);
      break;

    case ADDRESS:
      DEC(st->_stream_address);
      break;

    case BLOCKQUOTE:
      DEC(st->_stream_blockquote);
      break;

    case DIR:
      DEC(st->_stream_dir);
      return __html_stream_return_tag(st,next_tag,html,END,url);

    case UL:
      DEC(st->_stream_ul);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case OL:
      DEC(st->_stream_ol);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case DL:
      DEC(st->_stream_dl);
      /* Cope with nested <DL>s: if we're still in a DL, for valid HTML
         we must be in a DD! */
      st->_stream_dt=0;
      st->_stream_dd=st->_stream_dl ? 1 : 0;
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url)*/;

    case DD:
      st->_stream_dd = 0;
      break;

    case LI:
      DEC(st->_stream_li);
      break;

    case DT:
      st->_stream_dt = 0;
      break;

    case PRE:
      DEC(st->_stream_pre);
      break;

    case H1:
    case H2:
    case H3:
    case H4:
    case H5:
    case H6:
    case H7:
      st->_stream_h = 0;
      break;

    case HR: break; /* Should never see! */
    case BR: break; /* Should never see! */
    default: {
/*
 * We didnt find the tag in that lot, so look in the last 10. This is
 * sort of complicated by the fact that some of these are in the
 * head and some are in the body list, and there are <HEAD> and <BODY>
 * too.
 */
      st->_stream_body=__html_check_tag(Body_Tags,MAX_BODY_TAGS,
             	       	              next_tag.start_tag);
      if (st->_stream_body==1) {
        st->stripleadingcr = 0;
        switch(next_tag.tag) {
          case P:
            DEC(st->_stream_p);
            st->stripleadingcr = 1;
            break;

          case IMG:    break; /* No such tag! */
          case A:      __html_stream_end_anchor(st); break;
          case TT:
            DEC(st->_stream_tt);
            break;

          case ITALIC:
            DEC(st->_stream_italic);
            break;

          case BOLD:
            DEC(st->_stream_bold);
            break;
        }
      } else if(__html_check_tag(Head_Tags, MAX_HEAD_TAGS,
               		           next_tag.start_tag))
        {
       switch(next_tag.tag) {
          case NEXTID:
          case META:
          case LINK:
          case ISINDEX: break; /* No such tags */
          case TITLE:  {
            DEC(st->_stream_title);
            break;
          }
        }
      } else
#if FALSE
        if (__html_check_tag(Frameset_Tags, MAX_FRAMESET_TAGS, next_tag.start_tag)
        && next_tag.tag == FRAME) {
          st->_stream_frame = 0;
        } else
#endif
      {
        switch(next_tag.tag) {
          case HEAD: {
            st->_stream_head=0;
            return __html_stream_end_header(html);
          }
          case BODY: {
            DEC(st->_stream_body);
            break;
          }
#ifdef FRAMESUPPORT
          case TYPE_FRAMESET: {
            char *ptr;

            DEC(st->_stream_frameset);
#if 0

            if (html != NULL) {
              ptr=*html;
              while((*ptr != '\0') && (*ptr != '>')) ptr++;
              if (*ptr=='>') ptr++;
              *html=ptr;
            }
            __html_stream_grab_pcdata(html, size, 1);
#endif
            break;
          }
          case TYPE_NOFRAMES:
            st->_stream_noframes = 0;
            break;
#endif
         }
      }
    }
  }
  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_imagechar **html)                  */
/********************************************************************/
/* Knowing that we are in a image tag, grab the anchor information  */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_image(StreamTokens *st, char **html, Tag next_tag, char *url)
{
  AnchorInfo  *anc;
  HStream     *return_val;
  char        *ptr;

  return_val=HStreamalloc();
  if (return_val != NULL) {
    return_val->flags = 0;
    anc=__html_get_anchor_info(st, html, next_tag);
    if (anc != NULL) {
      return_val->style=__html_stream_style(st) | IMG;
      return_val->type=__html_stream_type(st,return_val->style,START);
      if (anc->ismap) {
        return_val->type|=TYPE_ISMAP;
      }
      return_val->type|=anc->alignment<<TYPE_ALIGN_SHIFT;
      if (st->_stream_anchor!=NULL) {
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
        return_val->target = (st->_stream_anchor->target);
       }
      else {
        return_val->anchor=NULL;
      }
      return_val->text=strdup(anc->alt);
      return_val->src=__html_make_anchor(url,anc->src);
//      return_val->target = strdup(st->_stream_anchor->target);
     return_val->rows=anc->rows;
      return_val->cols=anc->cols;
      return_val->maxlen=anc->border;
      return_val->next=NULL;
      return_val->prev=NULL;

      /* If one of HEIGHT or WIDTH are missing, remove the other one as
         well to prevent confusion */
      if (return_val->rows==0 || return_val->cols==0)
        return_val->cols=return_val->rows=0;
    }
    st->needtosend=0;

    /* Get rid of the anchor info block */
    __html_stream_free_anchor(&anc);

  }

  return_val->tag=IMG;
  return_val->indent=__html_stream_indent(st);
  fill_in_colour_info(st, return_val);

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_hr()                               */
/********************************************************************/
/* Knowing that we are in a HR tag, grab the anchor information     */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_hr(StreamTokens *st, char **html, Tag next_tag, char *url)
{
  AnchorInfo  *anc;
  HStream     *return_val;
  char        *ptr;
  int         noshade=0;
  int         alignment=_html_centre;

  return_val=HStreamalloc();
  if (return_val != NULL) {
    return_val->flags = 0;
    anc=__html_get_anchor_info(st, html, next_tag);
    if (anc != NULL) {
      if (anc->noshade)
        noshade = TYPE_NOSHADE;
      if (anc->alignment != _html_none)
          alignment = anc->alignment;
      if (st->_stream_anchor!=NULL) {
        return_val->anchor=st->_stream_anchor->href;
        return_val->name=st->_stream_anchor->name;
      }
      return_val->cols=anc->cols;
      return_val->size=anc->size;
      __html_stream_free_anchor(&anc);

    }
    st->needtosend=0;
    return_val->style=__html_stream_style(st) | HR;
    return_val->type=__html_stream_type(st,return_val->style,START) | noshade;
    return_val->type &= ~TYPE_ALIGN_MASK;
    return_val->type |= alignment << TYPE_ALIGN_SHIFT;
    return_val->indent=__html_stream_indent(st);
    return_val->tag=HR;
    /* Get rid of the anchor info block */

    fill_in_colour_info(st, return_val);
  }


/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_anchor(char **html)                */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_anchor(StreamTokens *st, char **html, Tag next_tag, char *url)
{
  if (st->_stream_anchor != NULL) __html_stream_end_anchor(st);
  st->_stream_anchor=__html_get_anchor_info(st, html, next_tag);
  if (st->_stream_anchor && !st->_stream_anchor->target)
    st->_stream_anchor->target = strdup(st->target);
  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_frame (char **html)                */
/********************************************************************/
/* Given a frame start tag, extract the relevant information        */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_frame (StreamTokens *st, char **html, Tag next_tag, char *url, int size)
{
  AnchorInfo  *anc;
  HStream     *return_val;
  char        *ptr;

  return_val=HStreamalloc();
  anc = __html_get_anchor_info(st, html, next_tag);
  if (return_val != NULL) {
    return_val->style  = __html_stream_style(st) | FRAME;
    return_val->tag    = FRAME;
    return_val->type = __html_stream_type(st,return_val->style,START);
    if (anc != NULL) {
      if (anc->scrolling) {
        return_val->type |= anc->scrolling << TYPE_SCROLLING_SHIFT;
      }
      if (anc->noresize) {
        return_val->type |= TYPE_NORESIZE;
      }
      return_val->size   = st->_stream_frameset;
      return_val->indent = anc->spacing;
      return_val->maxlen = anc->maxlength;
      return_val->rows   = anc->rows;
      return_val->cols   = anc->cols;
      return_val->name   = anc->name;
      return_val->src=__html_make_anchor(url,anc->src);

//      __html_stream_free_anchor(&anc);
    }
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  __html_stream_grab_pcdata(html, size, 1);
  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_base(char **html)                  */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_base(StreamTokens *st, char **html, Tag next_tag, char *url)
{
char *newurl, *newtarget;
  if (st->_stream_anchor != NULL) __html_stream_end_anchor(st);
  st->_stream_anchor=__html_get_anchor_info(st, html, next_tag);
  if (st->_stream_anchor != NULL) {
    if (st->_stream_anchor->href != NULL) {
      newurl=strdup(st->_stream_anchor->href);
      if (newurl) {
        __html_free(st->url,0);
        st->url=newurl;
      }
    }
    if (st->_stream_anchor->target != NULL) {
      newtarget=strdup(st->_stream_anchor->target);
      if (newtarget) {
        __html_free(st->target,0);
        st->target=newtarget;
      }
    }
  }
  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_end_anchor(void)                   */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static void __html_stream_end_anchor(StreamTokens *st)
{
  /* Need to rewrite this ! */
  __html_stream_free_anchor(&(st->_stream_anchor));
}

/********************************************************************/
/* static HStream *__html_stream_end_header(char **html)            */
/********************************************************************/
/* Given the end of the header block, return a token indicating     */
/* things like if ISINDEX is set for example.  	     		    */
/********************************************************************/
static HStream *__html_stream_end_header(char **html)
{
  return NULL;
}

/********************************************************************/
/* static void __html_stream_init(void)                             */
/********************************************************************/
/* This small routine resets all the variables to their initial     */
/* value      	      	     	     	       	  		    */
/********************************************************************/
StreamTokens *__html_stream_init(void)
{
  StreamTokens *st;

  st=(StreamTokens *)calloc(1, sizeof(StreamTokens)); /* zeroes everything */
  if (st==NULL) return NULL;

  st->_stream_body       =1;
  st->_stream_basefont   =3;

  return st;
}

/********************************************************************/
/* static HStream *__html_stream_return_tag (Tag tag, char **html)  */
/********************************************************************/
/* Given any old tag block that isnt a PCDATA, create and return a  */
/* stream element for that tag.	       	       	      	  	    */
/********************************************************************/
static HStream *__html_stream_return_tag(StreamTokens *st, Tag tag, char **html, int start, char *url)
{
  HStream *ret;
  char *ptr;
  #ifdef TRACE
  FILE *fp;
  #endif

  ret=HStreamalloc();
  if (ret != NULL) {

      if (tag.tag!=BODY) {
        ret->flags = 0;
        ret->style=__html_stream_style(st) | tag.tag; // This appears to put dodgy stuff in the style word
        ret->type=__html_stream_type(st,ret->style, start);
      }
      else {
          ret->style=__html_stream_style(st) | IMG;
          ret->type=(__html_stream_type(st,ret->style, start) | TYPE_HEAD) & ~TYPE_BODY;

//          Printf ("In stream_return_tag %08x %08x\n", ret->style, ret->type);
//          ********************ret->type |= 1;
      }
      #ifdef TABLE_SUPPORT
      if (tag.tag==TABLE) {
        ret->style|=HR;
        #ifdef TRACE
        fp=fopen("adfs::4.$.op","a");
        if (fp) {
          fprintf(fp,"TABLE found...\n");
          fclose(fp);
        }
        #endif
      }
      #endif

      ret->indent=__html_stream_indent(st);

      fill_in_colour_info(st, ret);

      if (st->_stream_anchor!=NULL) {
        ret->anchor=st->_stream_anchor->href;
        ret->name=st->_stream_anchor->name;
        ret->target=st->_stream_anchor->target;
      }
      else {
        ret->anchor=NULL;
        ret->name=NULL;
        ret->target=NULL;
      }

      ret->text=NULL;
      if (tag.tag==BODY)
        ret->tag=0;
      else
        ret->tag=tag.tag;

      #ifdef TABLE_SUPPORT
      if (tag.tag == TABLE) {
        ret->style|=HR;
      }
      #endif


//      Printf ("%s has tag field %08x\n", tag.start_tag, tag.tag);

      if (tag.tag == BODY) {
        if (st->_stream_anchor != NULL) {
          ret->src=__html_make_anchor(url,st->_stream_anchor->src);
          /* These four store colour info for the page (special case) */
          ret->size=st->_stream_anchor->size;
          ret->rows=st->_stream_anchor->rows;
          ret->cols=st->_stream_anchor->cols;
          ret->maxlen=st->_stream_anchor->maxlength;
          __html_stream_free_anchor(&(st->_stream_anchor));
          ret->style |= IMG;
        }
        else {
          ret->src=NULL;
          /* Not valid RiscOS colours. Should be trapped by the UI */
          ret->size=(unsigned int)-1;
          ret->rows=(unsigned int)-1;
          ret->cols=(unsigned int)-1;
          ret->maxlen=(unsigned int)-1;
        }
      } else if (tag.tag == TYPE_FRAMESET) {
//          ret->src=st->_stream_anchor->src;

          if (st->_stream_anchor != NULL) {

              ret->value=st->_stream_anchor->value;
              st->_stream_anchor->value = 0;

              ret->size=st->_stream_anchor->size;
              ret->rows=st->_stream_anchor->rows;
              ret->cols=st->_stream_anchor->cols;
              ret->indent=st->_stream_anchor->spacing;
              ret->maxlen=st->_stream_anchor->maxlength;
          } else {
              ret->value = 0;
              ret->size = st->_stream_frameset;
              ret->rows = 0;
              ret->cols = 0;
              ret->indent = 1;
              ret->maxlen = 0x00000000;
          }

      } else ret->src=NULL;
      ret->prev=NULL;
      st->needtosend=0;
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  if (html != NULL) {
    ptr=*html;
    while((*ptr != '\0') && (*ptr != '>')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
  }

  return ret;
}

/********************************************************************/
/* static char *__html_make_anchor(char *base, char *link)          */
/********************************************************************/
/* Given a base URL and another URL (e.g. a link or an image), this */
/* routine constructs the resultant URL from the pair               */
/********************************************************************/

char * __html_make_anchor(char * base, char * link)
{
  char        * ret = NULL;
  char        * copy;
  char        * buffer;
  char        * uri;
  extern char * __html_tidy_url(char * url);

  if (link == NULL) return NULL;

  if (base == NULL) // || (strstr(base,"ADFS:") != NULL)
  {
    ret = strdup(link);
    return ret;
  }

  if (link[0] == '#')
  {
    /* It's a within document link */

    ret = __html_malloc(strlen(link) + strlen(base) + 1, 1);
    if (ret) strdoublecpy(ret, base, link);

    return ret;
  }

  /* Should have a Fetcher_Relativise call                               */
  /*                                                                     */
  /* Simple test for a fully qualified URL. Look for '://' in the string */
  /* Also catch "mailto:" and "x500:" URLs at this point. We expect the  */
  /* method to be at the start of the string. (This is to allow for      */
  /* funny proxies :)                                                    */
  /*                                                                     */
  /* The test on ret - link <= 9 ensures URLs that are indeed relative,  */
  /* but contain URLs themselves (e.g. as part of some CGI info in the   */
  /* link) aren't treated as absolute (see below for more of this kind   */
  /* of consideration). We want the :// to be within about the first 9   */
  /* characters, more or less...                                         */

  ret = strstr(link, "://");

  if (
       (ret && ret - link <= 9)     ||
       !strincmp(link,"MAILTO:",7)  ||
       !strincmp(link,"NEWS:",  5)  ||
       !strincmp(link,"X500:",  5)
     )
  {

    ret = strdup(link);
    return ret;
  }

  /* Now look for broken URLs of the form 'method:/path/to/file' or           */
  /* 'method:relative/path'. These are a tad more difficult to deal with      */
  /* so a separate routine is needed to do this :) This relies on mailto and  */
  /* x500 being caught above.                                                 */
  /*                                                                          */
  /* Also the test for being more than 7 chars in is needed for places like   */
  /* www.pathfinder.com who have URLs of the form:                            */
  /*                                                                          */
  /* /adgw/nph-adgw.cgi?url=http:%2f%2fchess.ibm.park.org&advertiser=...      */
  /* IBM%20OS2&description=IBM%20Chess%20Button&source=%2fpathfinder%2f...    */
  /* welcome.html                                                             */
  /*                                                                          */
  /* which contain the sequence "http:" (Technically the ':' should be        */
  /* encoded too I believe!). Anyway since mailto is the longest method, 7    */
  /* should be okay, I hope!. Alternatively if this is found to be unreliable */
  /* change the buffer=strchr() bit and the *link=='/' bits around.           */

  buffer = strchr(link, ':');

  if (buffer && (buffer - link < 7))
  {
    buffer++;

    uri = strdup(buffer); /* Buffer should now contain URI. Just need new base */
    if (!uri) return NULL;

    /* Now get the method bit - ughh! */

    buffer = strdup(link);

    if (!buffer) return buffer;

    ret  = strchr(buffer,':'); /* Can't fail because of above */
    *ret = '\0';

    /* Now need to construct new base bit. */
    copy=__html_malloc(strlen(base)+strlen(buffer)+1,1);
    if (!copy) return copy;
    /* We have up to the : so skip that in base */
    base=strchr(base,':');
    if (base==NULL) return base;
    sprintf(copy,"%s%s",buffer,base);
    base=copy;
    link=uri;
  }

/* The 1st case. The link starts with a '/' so it is an absolute URL
 * around the same host/method base.
 */
  if (*link=='/') {
    link++;
    ret=__html_malloc(strlen(base)+strlen(link)+1,sizeof(char));
    if (ret==NULL) return NULL;

    strcpy(ret,base);
    copy=ret;
    copy=strstr(copy,"://");
    if (copy==NULL) {
      __html_free(ret, 0);
      return NULL;
    }
    copy++; copy++; copy++;
    copy=strchr(copy,'/');
    if (copy==NULL) {
      __html_free(ret, 0);
      return NULL;
    }
    copy++; *copy='\0';
    strcat(ret,link);
    return ret;
  }

/* The 2nd case. The link starts with a './' so it is an relative URL
 * around this page
 */
  if ((*link=='.') && (*(link+1)=='/')) {
    link++; link++;

default_return:

/*
 * Basically we need to look back through base to find the last '/'
 * and append link at that point. So we need a string the length
 * of base and link, and then blat the two strings into it.
 *
 * So grab a copy of base, and strip it back to the required point
 */
    ret=copy=strdup(base);

    if (ret==NULL) return ret;

    ret=strrchr(copy,'/');

    if (ret==NULL) {
      __html_free(copy, 0);
      return NULL;
    }
    ret++;
    *ret='\0';

/* Create a big enough string */
    ret=__html_malloc(strlen(copy)+strlen(link)+1,sizeof(char));
    if (ret==NULL) return ret;
/* Add the two strings into the return buffer */
    strdoublecpy(ret, copy, link);
    return __html_tidy_url(ret);
  }

/* 3rd case. The link has a ':' in it. Assume its a link such as a
 * mailto request. (i.e. host independant URL)
 */

 if (strchr(link, ':') != NULL) {
   ret=strdup(link);
   return ret;
 }

/* Otherwise this is sort of the same as case 2 sans the './' */
 goto default_return;
}

/********************************************************************/
/* static void __html_stream_free_anchor(AnchorInfo **anchor)       */
/********************************************************************/
/* Given an anchor info block free up all the memory associated     */
/* with it, and set it back to NULL   	      	     		    */
/********************************************************************/
static void __html_stream_free_anchor(AnchorInfo **anchor)
{
AnchorInfo *anc=*anchor;

  if (!anchor || !anc) return;

  if (anc->href != NULL)    __html_free(anc->href,0);
  if (anc->src != NULL)     __html_free(anc->src,0);
  if (anc->alt != NULL)     __html_free(anc->alt,0);
  if (anc->action != NULL)  __html_free(anc->action,0);
  if (anc->enctype != NULL) __html_free(anc->enctype,0);
  if (anc->value != NULL)   __html_free(anc->value,0);
//  if (anc->target != NULL)  __html_free(anc->target,0);
  __html_free(anc,0);

  *anchor=NULL;
}

/********************************************************************/
/* static void strdoublecpy(char *buffer, char *s1, char *s2)       */
/********************************************************************/
/* Copy s1 and s2 into buffer, with no space between them           */
/********************************************************************/

static void strdoublecpy(char *buffer, char *s1, char *s2)
{
  if (buffer==NULL) return;
  sprintf(buffer,"%s%s",s1,s2);
}

/********************************************************************/
/* static HStream * __html_form_handler(StreamTokens *st, Tag ne... */
/********************************************************************/
/* General purpose forms handling but. Since all form elements are  */
/* basically derived from the same generic idea, it makes sense to  */
/* keep them in one bit. NOTE: LINKS WITHIN FORMS ARE DUFF AT THE   */
/* moment due to an earlier oversight. Fix soon	      	      	    */
/********************************************************************/
static HStream * __html_form_handler(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
AnchorInfo *anc;
HStream *ret;
char *ptr; /* Hackery - used to get text after tag */
char *p;

/* Since a form shouldnt be within an anchor, we can clear the anchor state */
  if (st->_stream_forms) __html_stream_free_anchor(&(st->_stream_forms));

/* Now get the form information out of the anchor */
  anc=__html_get_anchor_info(st, html, next_tag);

/* Always check for those NULLs. */
  if (anc == NULL && next_tag.tag != OPTION)
      return (HStream *)anc; /* 2 instructions saved :) */

  st->_stream_forms = anc;

/* Fill in a return slip :) */
  ret=HStreamalloc();
  if (!ret) return ret;

   ret->flags = 0;
   fill_in_colour_info(st, ret);

  if (next_tag.tag == OPTION || next_tag.tag == TEXTAREA || next_tag.tag == SELECT)
  {
    ptr=*html;
    while((*ptr != '\0') && (*ptr != '>')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
  }

/* This is the nasty bit :) Decide what to do based on the tag */
  switch(next_tag.tag) {
    case FORM: /* Fill in method bit etc */
    	       st->_stream_form=1;
    	       ret->tag=FORM;
    	       if (!anc->method)
    	            anc->method=1; /* Default to GET form (there are morons out there) */
	       ret->style=__html_stream_style(st);
	       ret->type=__html_stream_type(st, ret->style, START);
	       ret->anchor=__html_make_anchor(url, st->_stream_forms->action);
	       if (st->_stream_anchor) {
                 ret->target = st->_stream_anchor->target;
               }
               ret->enctype=strdup(st->_stream_forms->enctype);
               ret->indent=__html_stream_indent(st);
               st->needtosend |= FORM;
	       break;

    case INPUT: /* Do lots of bits */
    	       ret->tag=INPUT;
	       ret->style=__html_stream_style(st) | INPUT;
	       ret->type=__html_stream_type(st, ret->style, START);
	       /* INPUTy bits */
	       ret->maxlen=st->_stream_forms->maxlength;
	       ret->size=st->_stream_forms->size;
	       ret->value=strdup(st->_stream_forms->value);
	       if (st->_stream_forms->type <= 1) {
  	         if (ret->maxlen > 0) {
  	           ret->text=strndup(ret->value,ret->maxlen); /* Ensure big buffer */
  	         }
  	         else {
  	           ret->text=strndup(ret->value, 1024);
  	         }
  	       }
	       ret->name=strdup(st->_stream_forms->name);
	       ret->src=strdup(st->_stream_forms->src);
               ret->indent=__html_stream_indent(st);
	       break;

    case SELECT: /* Check multiple bits */
#ifdef OLDCODE
    	       st->_stream_select=1;
    	       ret->tag=SELECT;
	       ret->style=__html_stream_style(st) | SELECT;
	       ret->type=__html_stream_type(st, ret->style, START);
	       /* SELECTy bits */
	       ret->name=strdup(st->_stream_forms->name);
               ret->indent=__html_stream_indent(st);
	       st->needtosend |= SELECT;
	       break;
#else
                /* Right, here we go. We need to grab data until the next
                   </SELECT> */
                if ((p = strinstr(*html, "</SELECT>", size)) == NULL)
                {
                    *html=0;       /* Signal back-up */
                    RETURN(NULL);
                }
                return __html_form_parse_select(st, html, p-*html, ret);
#endif

    case OPTION: /* OPTION tag */
    	       ret->tag=OPTION;
	       ret->style=__html_stream_style(st) | OPTION;
	       ret->type=__html_stream_type(st, ret->style, START);
	       /* OPTIONy bits */
	       if (st->_stream_forms)
	           ret->value=strdup(st->_stream_forms->value);
	       ret->text=__html_stream_grab_pcdata(html, size, 1);
	       if (ret->text==NULL)
	       {
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
	       }
               __html_strip_spaces(ret->text, st->stripleadingcr);
               __html_unescape_string(ret->text);
               ret->indent=__html_stream_indent(st);
	       break;

    default: /* TEXTAREA */
    	       st->_stream_textarea=1;
    	       ret->tag=TEXTAREA;
	       ret->style=__html_stream_style(st) | TEXTAREA;
	       ret->type=__html_stream_type(st, ret->style, START);
	       ret->text=__html_stream_grab_pcdata(html, size, 1);
	       if (ret->text==NULL)
	       {
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
	       }
	       /* TextArea Bits */
	       ret->cols=st->_stream_forms->cols;
	       ret->rows=st->_stream_forms->rows;
	       ret->name=strdup(st->_stream_forms->name);
                __html_strip_lfs(ret->text); /* Strip CRs, preserve LFs */
               __html_unescape_string(ret->text);
               ret->indent=__html_stream_indent(st);
	       break;
  }

  return ret;
}

HStream *__html_return_text_token(char *doc, size_t size)
{
HStream *return_val=NULL;

  return_val=HStreamalloc();

  if (return_val != NULL) {

    return_val->text=strndup(doc, size);
    return_val->style=PRE | PCDATA ;
    return_val->flags = 0;


    __html_strip_lfs(return_val->text);
    __html_strip_control_codes(return_val->text);
    return_val->type=TYPE_BODY;
    return_val->tag=PCDATA;
    return_val->src=NULL;
    return_val->prev=NULL;
    return_val->fontsize = 3;
  }
  return return_val;
}

#include "api.h"

/*
 * This routine is called from __html_form_handler
 * We have an HStream ready to be filled in, html points to the start
 * of the block, and size is the size of the block.
 */
static HStream *__html_form_parse_select(StreamTokens *st, char **html, int size, HStream *ret)
{
    char *ptr=*html, *p;
    HStream *h, *hp;
    StreamTokens *s;
    int count,items;

    /* Re-enter the parser - get a stream for our block, and pull out the
       OPTION tags(!) */

    s=HtmlParse(st->url, size, TYPE_HTMLFILE, 0);
    /* Hack hack hack hack! */
    s->_stream_form=1;
    s->_stream_select=1;
    h=HtmlGetStream(s, &ptr, size);
    __html_memory_context=st->memcontext;

    /* The format of the "value" is:
               1st word: number of options
               2nd word: flags (0)
       then per option:
               Flags byte (0 atm)
               Displayed text, terminated by zero byte
               Symbolic name, terminated by a zero byte (just a zero byte if not
                                                         present)
       then to terminate
               &FF
     */
    count=8;
    items=0;
    hp=h;
    while (hp)
    {
        if (hp->tag == OPTION)
        {
            count+=1+strlen(hp->text)+1+(hp->value?strlen(hp->value):0)+1;
            items+=1;
        }
        hp=hp->next;
    }
    count+=1;
    /* Hack! */
    ret->value=p=__html_malloc(count, 1);
    *((int *)p)=items; p+=4;
    *((int *)p)=0; p+=4;
    hp=h;
    while (hp)
    {
        if (hp->tag == OPTION)
        {
            int len;

            /* Flags byte */
            *p++=(hp->type & TYPE_SELECTED) ? 1 : 0;

            sprintf(p, "%s%n", hp->text, &len); p+=len;
            /* Strip trailing spaces */
            while (*(p-1)==' ')
                *--p='\0';
            p++;
            if (hp->value)
            {
                sprintf(p, "%s%n", hp->value, &len); p+=len+1;
            }
            else
                *p++='\0';
        }
        hp=hp->next;
    }
    *p=0xFF;
    assert((p+1)-ret->value == count);

    HtmlStreamFree(h);
    free(s);

    ret->tag=SELECT;
    ret->style=__html_stream_style(st) | SELECT;
    ret->type=__html_stream_type(st, ret->style, START);
    ret->name=strdup(st->_stream_forms->name);
    ret->size=st->_stream_forms->size;
    ret->indent=__html_stream_indent(st);
    fill_in_colour_info(st, ret);
    st->needtosend |= SELECT;

    ptr=*html+size;

    while (*ptr!='>')
        ptr++;

    *html=ptr+1;

    return ret;
}
@


1.1.2.2
log
@Spacing rules drastically improved. Major error in memory context handling
fixed. Bug in __html_strip_lf fixed.
@
text
@d19 1
a19 5
 * $Source: /projects2/renaissa/cvsroot/ART/Web/HTMLLib/c/Attic/new_stream,v $
 *
 * $Log: new_stream,v $
 * Revision 1.1.2.1  1997/04/08 10:26:46  kbracey
 * Initial revision
d21 1
d43 2
d109 1
a109 1
                              int size, HStream *prevhs)
a115 1
  int     lastwaspcdata=st->lastwaspcdata;
a170 4
#ifdef NEWSPACING
        st->stripleadingspace = __html_strip_spaces(return_val->text, st->stripleadingspace, 0);
        st->lastwaspcdata = 1;
#else
a171 1
#endif
a237 3
      #ifdef NEWSPACING
      st->stripleadingspace=0;
      #else
a238 1
      #endif
a259 4
  #ifdef NEWSPACING
  st->lastwaspcdata=0;
  #endif

a324 15
  if (tag_start[0]=='/')
  {
    if (lastwaspcdata && prevhs && prevhs->text)
    {
      __html_strip_trailing_spaces(prevhs->text);
      if (prevhs->text[0]=='\0')
      {
        __html_free(prevhs->text, 0);
        prevhs->text=0;
      }
    }
  }
  else
    st->stripleadingspace=1;

a343 10
      if (lastwaspcdata && next_tag.implicit_lf_before && prevhs && prevhs->text)
      {
        __html_strip_trailing_spaces(prevhs->text);
        if (prevhs->text[0]=='\0')
        {
          __html_free(prevhs->text, 0);
          prevhs->text=0;
        }
      }

a354 1

a495 1
#if 0
a508 1
#endif
a578 1
#ifndef NEWSPACING
a579 1
#endif
a752 4
#ifdef NEWSPACING
    st->isendtag=1;
    st->stripleadingspace=next_tag.implicit_lf_after;
#else
a753 1
#endif
a780 1
      #ifndef NEWSPACING
a781 1
      #endif
a853 1
        #ifndef NEWSPACING
a854 1
        #endif
a857 1
            #ifndef NEWSPACING
a858 1
            #endif
d1025 1
a1025 1
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
d1244 1
a1244 1
        ret->anchor=__html_make_anchor(url, st->_stream_anchor->href);
d1601 1
a1601 1
               }
a1663 3
               #ifdef NEWSPACING
               __html_strip_spaces(ret->text, st->stripleadingspace, 1);
               #else
a1664 1
               #endif
d1740 1
a1740 1
    __html_set_memory_context(st->memcontext);
@


1.1.2.3
log
@Added in Tony Cheal's table code. Various other bug fixes.
@
text
@a21 4
 * Revision 1.1.2.2  1997/04/09 16:44:37  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
a36 3
#ifdef TonyTables
#include "HTMLTables.h"
#endif
d68 1
a68 1
/*static*/HStream * __html_stream_return_tag(StreamTokens *st, Tag tag,
d72 2
a73 2
/*static*/   char * __html_make_anchor(char *base, char *link);
/*static*/         void __html_stream_free_anchor(AnchorInfo **anchor);
d365 2
a366 7
    if ((st->needtosend & next_tag.tag) == next_tag.tag && next_tag.tag
#ifdef TonyTables
        && !__html_current_table
#endif
       )
    {
        return_val=__html_stream_return_tag(st, Null_Tag, NULL, END, st->url);
d368 1
a368 2
    else
    {
d466 1
a466 3
    #ifdef TonyTables
    if (st->_stream_table)          return_val |= TABLE;
    #endif
a716 7
            #ifdef TonyTables
            case TR:     return __html_table_row_start_tag(st, next_tag, html, url, size);
            case TD:     return __html_table_data_start_tag(st, next_tag, html, url, size);
            case TH:     return __html_table_head_start_tag(st, next_tag, html, url, size);
            case TABLE:  st->_stream_table++;
                         return __html_table_start_tag(st, next_tag, html, url, size);
            #endif
a929 6
        #ifdef TonyTables
          case TR:    return __html_table_row_end_tag(st, next_tag, html, url);
          case TD:    return __html_table_data_end_tag(st, next_tag, html, url);
          case TH:    return __html_table_head_end_tag(st, next_tag, html, url);
          case TABLE: return __html_table_end_tag(st, next_tag, html, url);
        #endif
a1020 1
      return_val->name=st->_stream_anchor->name;
a1089 1
    return_val->name=st->_stream_anchor->name;
a1234 11
/* static void __html_style_init(styleinfo *s)                      */
/********************************************************************/
/* This small routine resets all the styles to their initial        */
/* value      	      	     	     	       	  		    */
/********************************************************************/
void __html_style_init(styleinfo *s)
{
  memset(s, 0, sizeof *s);
}

/********************************************************************/
a1246 2
  __html_style_init(&st->_stream_style);

d1259 1
a1259 1
/*static*/ HStream *__html_stream_return_tag(StreamTokens *st, Tag tag, char **html, int start, char *url)
d1573 1
a1573 1
/*static*/ void __html_stream_free_anchor(AnchorInfo **anchor)
d1799 1
a1799 1
    h=HtmlGetStream(s, &ptr, size, NULL);
@

head	1.7;
access;
symbols
	remotedb-0_12:1.7
	remotedb-0_11:1.7
	RO_5_07:1.7
	remotedb-0_10:1.7
	remotedb-0_09:1.7
	dellis_autobuild_BaseSW:1.7
	sbrodie_sedwards_16Mar2000:1.7
	remotedb-0_08:1.7
	dcotton_autobuild_BaseSW:1.7
	remotedb-0_07:1.7
	remotedb-0_06:1.6
	remotedb-0_05:1.5
	remotedb-0_04:1.4
	remotedb-0_03:1.3
	remotedb-0_02:1.2
	Spin_Merge:1.1.2.10
	remotedb-0_01-1_1_2_5:1.1.2.10
	remotedb-0_01-1_1_2_4:1.1.2.9
	afrost_NC2_Generic:1.1.2.8
	remotedb-0_01-1_1_2_3:1.1.2.8
	remotedb-0_01-1_1_2_2:1.1.2.7
	Spinner_B20_2:1.1.2.6
	Spinner_19_3:1.1.2.6
	Spinner_B18:1.1.2.6
	Spinner_B17:1.1.2.6
	Spinner_B15:1.1.2.6
	Spinner_B14:1.1.2.6
	Spinner_B13:1.1.2.6
	Spinner_B12:1.1.2.6
	Spinner_B10:1.1.2.4
	Spinner_B7:1.1.2.4
	Spinner:1.1.0.2;
locks; strict;
comment	@# @;


1.7
date	99.09.21.08.50.49;	author jberanek;	state Exp;
branches;
next	1.6;

1.6
date	99.05.26.12.28.59;	author jberanek;	state Exp;
branches;
next	1.5;

1.5
date	99.05.24.11.43.03;	author sbrodie;	state Exp;
branches;
next	1.4;

1.4
date	99.02.24.16.57.36;	author smiddle;	state Exp;
branches;
next	1.3;

1.3
date	98.11.05.14.43.58;	author Spin;	state Exp;
branches;
next	1.2;

1.2
date	98.11.05.13.13.25;	author Spin;	state Exp;
branches;
next	1.1;

1.1
date	97.04.25.13.36.17;	author rbuckley;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	97.04.25.13.36.18;	author rbuckley;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.04.25.13.46.15;	author rbuckley;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	97.04.25.14.17.17;	author rbuckley;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	97.04.28.14.21.54;	author rbuckley;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	97.05.29.20.47.45;	author smiddle;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	97.05.30.17.33.47;	author smiddle;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	98.01.19.10.41.19;	author smiddle;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	98.04.20.12.51.22;	author smiddle;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	98.06.22.13.56.46;	author jberanek;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	98.11.05.13.09.53;	author jberanek;	state Exp;
branches;
next	;


desc
@@


1.7
log
@ * remotedb is now properly namespaced, all calls and visible variables are
   prefixed "remote_". Previously only some of the calls were namespaced,
   now they all are.  This may break some apps that used remotedb directly
   instead of using DebugLib, but the changes needed will be small. This
   change was done because I was getting a nameclash with some other
   source that defined debug_vprintf.

 * Updated DebugLib will be checked-in that uses new naming scheme.


Version 0.07. Tagged as 'remotedb-0_07'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/*                  Copyright 1997-1999 Pace Micro Technology plc       */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Pace Micro Tecnology.  It may not be reproduced,     */
/*  used sold, or transferred to any third party without the prior      */
/*  written consent of Pace Micro Technology.  All rights reserved.     */
/*                                                                      */
/************************************************************************/

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#include "sys/types.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "netdb.h"
#include "netinet/in.h"
#include "socklib.h"
#define REMOTE_DEBUG
#include "remote.h"

#include "VersionNum"

static const char REMOTE_DEBUG_VERSION[] = Module_FullVersion;

#define REMOTE_DEBUG_MAX_LINE (10*1024)

static bool remote_debug_poll_flag = true;
static char *remote_debug_line = NULL;

/*
 * compare two strings caselessly
 */
static int
remote_debug_caseless_strcmp(char *a, char *b)
{
  int d;

  while (*a || *b)
  {
    d = tolower( *(a++) ) - tolower( *(b++) );
    if (d) return d;
  }
  return 0;
}

/*
 * check the input port for any data, if there is, check it for a newline
 * and if terminated correctly, extract the line.
 */
int
remote_debug_poll(remote_debug_session *sess)
{
  static char sbuff[REMOTE_DEBUG_MAX_LINE];
  fd_set read_set;
  struct timeval tv;
  char	 *argv[20];
  int    argc = 0;
  char   *cp;
  int    more;

  if (!sess)
    return (0);

  remote_debug_poll_flag = false; /* don't poll during debug_printf */

  do
  {
    more = 0;
    FD_ZERO(&read_set);
    FD_SET(sess->sock,&read_set);
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    if (select(FD_SETSIZE,&read_set,NULL,NULL,&tv)>0)
    {
      if (FD_ISSET(sess->sock,&read_set))
      {
        int recv_len = recv(sess->sock, sbuff, REMOTE_DEBUG_MAX_LINE-1,MSG_PEEK);
        if (recv_len>0)
        {
          if ((cp=memchr(sbuff,'\n', recv_len))!=NULL)
          {
            if (recv(sess->sock, sbuff, (cp-sbuff+1),0)>0)
            {
              sbuff[cp-sbuff]='\0'; /* remove the new line char */
              /*
               * break down string
               */
              cp = sbuff;
              while (*cp != '\0')
              {
                while (*cp == ' ')
                  cp++;
                if (*cp == '\0')
                  break;
                argv[argc++] = cp;
                if (argc>=20)
                  break;
                while (*cp != '\0' && *cp != ' ')
                  cp++;
                if (*cp == 0)
                  break;
                *cp++ = '\0';
              }
              *cp++ = '\0';
              /*
               * what do we want to do
               */
              if (argc == 0 || argv[0][0]=='#' || argv[0][0] == 0)  /* ignore comments */
                ;
              else if (remote_debug_caseless_strcmp(argv[0],"PRIORITY")==0)
              {
                if (argc>1)
                {
                  sess->priority = atoi(argv[1]);
                  if (sess->priority>7)
                    sess->priority = 7;
                  remote_debug_printf(sess,"(6) debug priority changed to %d\n",
                  			     sess->priority);
                }
              }
              else if (sess->cmd_handler) /* callback cmd handler if registered */
              {
		  char name[32];
		  int rc;
		  strncpy(name, argv[0], sizeof(name));
		  name[sizeof(name)-1] = 0;
		  rc = sess->cmd_handler(argc, argv, sess->cmd_handle);
		  remote_debug_printf(sess,"(6) cmd '%s' returns %d\n", name, rc);
              }
              else if (remote_debug_caseless_strcmp(argv[0], ":ack")==0)
              {
                  /* Discard these silently */
              }
              else
              {
                  remote_debug_printf(sess,"(6) unknown command '%s'\n",argv[0]);
              }

              more = 1; /* try for more input */
            }
          }
        }
      }
    }
  } while (more);

  remote_debug_poll_flag = true; /* return to polling during debug_printf */
  return (0);
}

/*
 * send stuff to the debug session
 */
void
remote_debug_printf(remote_debug_session *sess, char *format, ...)
{
  va_list list;

  va_start (list, format);
  vsprintf (remote_debug_line,format, list);
  va_end (list);

  remote_debug_print_line_simple (sess, remote_debug_line);
}

void
remote_debug_vprintf(remote_debug_session *sess, const char *format, va_list list)
{
  vsprintf (remote_debug_line,format, list);

  remote_debug_print_line_simple (sess, remote_debug_line);
}

void
remote_debug_dvprintf(remote_debug_session *sess, int priority, const char *file, int line, const char *format, va_list list)
{
  int n = 0;

  if (priority != 0)
      n += sprintf(remote_debug_line, "(%d)", priority);

  if (file)
      n += sprintf(remote_debug_line+n, " %s:%d: ", file, line);

  vsprintf(remote_debug_line+n, format, list);

  remote_debug_print_line_simple(sess, remote_debug_line);
}


void
remote_debug_print_line_simple(remote_debug_session *sess, const char *line)
{
  remote_debug_print_line (0u, sess, line, strlen (line));
}


void
remote_debug_print_line (unsigned int flags, remote_debug_session *sess, const char *line, size_t len)
{
  unsigned char priority = 7;

  if (!sess)
    return;

  if (remote_debug_poll_flag)
    remote_debug_poll(sess);

  /* Not raw */
  if ((flags & 1) == 0)
  {
    /* Get opening bracket */
    if (line[0]=='(')
    {
      /* Find closing bracket */
      if (strchr (line,')') != NULL)
        priority = atoi (line+1);
    }
    /* If we're masking this line out, just return */
    if (priority > sess->priority)
      return;
    /* Send the info string to the socket */
    send (sess->sock, sess->info, strlen (sess->info), 0);
  }

  /* Send the actual debug data */
  send (sess->sock, line, len, 0);

  /* Not raw */
  if ((flags & 1) == 0)
  {
    /* And if we're not in raw mode, output a \n if the debug data doesn't end with one */
    if (line[len-1] != '\n')
      send (sess->sock, "\n", strlen ("\n"), 0);
  }
}


void
remote_debug_register_cmd_handler(remote_debug_session *sess, remote_debug_cmd_handler fn, void *handle)
{
  if (sess)
  {
    sess->cmd_handler = fn;
    sess->cmd_handle = handle;
  }
}

/*
 * Reads environment variable Inet$DebugHost in the form valhalla:1448 to
 * obtain IP address and port number. Opens a socket to this host and returns
 * a structure to be used for subsequent debug calls. Debug session should be
 * closed using the remote_debug_session_close() function
 */
void
remote_debug_open(char *info, remote_debug_session **db_sess)
{
  int rc;
  int debug_socket=-1;
  struct sockaddr_in sockaddr;
  struct hostent *hostent;
  remote_debug_session *sess=NULL;
  char host[40];
  char varname[100];
  char *port;

  /* malloc to avoid problems in SVC mode */
  if (remote_debug_line == NULL)
      remote_debug_line = malloc(REMOTE_DEBUG_MAX_LINE);

  memset(&sockaddr, 0, sizeof(sockaddr));

  /*
   * where do we want to connect to
   */

  sprintf (varname, "Inet$DebugHost_%s", info);

  if (getenv (varname) == NULL)
  {
    if (getenv("Inet$DebugHost")==NULL)
      goto exit_gracefully;
    strncpy(host,getenv("Inet$DebugHost"),sizeof(host));
  }
  else
    strncpy(host,getenv(varname),sizeof(host));

  host[sizeof(host)-1] = '\0';

  /*
   * find port
   */
  if ((port=strchr(host,':'))==NULL)
    goto exit_gracefully;

  *(port++) = 0; /* terminate host name and leave pointer to port */
  sockaddr.sin_port = htons(atoi(port));
  if (sockaddr.sin_port==0)
    goto exit_gracefully;

  /*
   * allocate a socket
   */
  do
  {
    debug_socket = socket(AF_INET, SOCK_STREAM, 0);
  } while (debug_socket == -1);

  hostent = gethostbyname(host);
  if (hostent == NULL)
    goto exit_gracefully;

  sockaddr.sin_family = AF_INET;
#ifndef COMPAT_INET4
  sockaddr.sin_len = sizeof(sockaddr);
#endif
  sockaddr.sin_addr.s_addr = *(u_long*)hostent->h_addr;

  rc = connect(debug_socket, (struct sockaddr *)&sockaddr, sizeof(sockaddr) );
  if (rc<0)
    goto exit_gracefully;

  /*
   * allocate a debug session
   */
  if ((sess=malloc(sizeof(remote_debug_session)))==NULL)
    goto exit_gracefully;

  sess->sock = debug_socket;
  sess->cmd_handler = NULL;
  sess->cmd_handle = NULL;

  if ((sess->info=malloc(strlen(info)+sizeof(": ")))==NULL)
    goto exit_gracefully;

  strcpy(sess->info, info);
  strcat(sess->info, ": ");

  sess->priority = 7;

  /*
   * send initial opening message
   */
  remote_debug_printf(sess,"(6) Open Version %s", REMOTE_DEBUG_VERSION);

  *db_sess = sess;

  return;

exit_gracefully:
  if (debug_socket >= 0)
    socketclose(debug_socket);
  debug_socket = -1;

  if (sess)
  {
    if (sess->info)
      free(sess->info);
    free(sess);
  }
  *db_sess = NULL;
}

/*
 * close previously opened debug session
 */
void
remote_debug_close(remote_debug_session *sess)
{
  if (sess)
  {
    remote_debug_printf(sess,"(6) Close");
    if (sess->sock >= 0)
      socketclose(sess->sock);

    if (sess->info)
      free(sess->info);
    free(sess);
  }

  if (remote_debug_line)
  {
     free(remote_debug_line);
     remote_debug_line = NULL;
  }

  return;
}


const char *remote_debug_version (void)
{
  return REMOTE_DEBUG_VERSION;
}
@


1.6
log
@ * Improved namespacing of functions throughout remotedb.  External
   functions weren't able to be renamed, so as not to break compatability
   with programs that use remotedb

 * Added a new API call "remote_debug_print_line".  It is similar to
   "debug_print_line", except that it takes flags, and you can pass the
   length of the line you want to output (so you can pass non-NULL
   terminated strings).  The one used bit in the flag is bit 1, which if
   set means that the debug output should be "raw", i.e. bypass the
   priority code, and not force a \n at the end of the line.  The next
   DebugLib version (0.38) will use this raw mode.

 * Renamed the remotedb_version function to remote_debug_version to better
   fit the namespacing of the rest of the (correctly namespaced) API calls.
   Compatability shouldn't be too much of a concern, because it's a new
   API call, which very few people will be using.

 * Added -throwback into !Mk and !MkExport

 * Changed C flags to -ffah, to stop function name embedding...this was
   causing problems with using DebugLib Trace output with remotedb.


Version 0.06. Tagged as 'remotedb-0_06'
@
text
@d16 1
a16 1
/*                  Copyright 1997-1999 Element 14 Ltd                  */
d19 3
a21 3
/*  information of Element 14 Ltd.  It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Element 14 Ltd.  All rights reserved.                    */
d30 1
d47 2
a48 2
static int remote_debug_poll=1;
static char *debug_line = NULL;
d71 1
a71 1
debug_poll(debug_session *sess)
d84 1
a84 1
  remote_debug_poll=0; /* don't poll during debug_printf */
d137 1
a137 1
                  debug_printf(sess,"(6) debug priority changed to %d\n",
d148 1
a148 1
		  debug_printf(sess,"(6) cmd '%s' returns %d\n", name, rc);
d156 1
a156 1
                  debug_printf(sess,"(6) unknown command '%s'\n",argv[0]);
d167 1
a167 1
  remote_debug_poll=1; /* return to polling during debug_printf */
d175 1
a175 1
debug_printf(debug_session *sess, char *format, ...)
d180 2
a181 2
  vsprintf(debug_line,format, list);
  va_end(list);
d183 1
a183 1
  debug_print_line(sess, debug_line);
d187 1
a187 1
debug_vprintf(debug_session *sess, const char *format, va_list list)
d189 1
a189 1
  vsprintf(debug_line,format, list);
d191 1
a191 1
  debug_print_line(sess, debug_line);
d195 1
a195 1
debug_dvprintf(debug_session *sess, int priority, const char *file, int line, const char *format, va_list list)
d200 1
a200 1
      n += sprintf(debug_line, "(%d)", priority);
d203 1
a203 1
      n += sprintf(debug_line+n, " %s:%d: ", file, line);
d205 1
a205 1
  vsprintf(debug_line+n, format, list);
d207 1
a207 1
  debug_print_line(sess, debug_line);
d212 1
a212 1
debug_print_line(debug_session *sess, const char *line)
d219 1
a219 1
remote_debug_print_line (unsigned int flags, debug_session *sess, const char *line, size_t len)
d226 2
a227 2
  if (remote_debug_poll)
    debug_poll(sess);
d260 1
a260 1
remote_debug_register_cmd_handler(debug_session *sess, remote_debug_cmd_handler fn, void *handle)
d276 1
a276 1
remote_debug_open(char *info, debug_session **db_sess)
d282 1
a282 1
  debug_session *sess=NULL;
d288 2
a289 2
  if (debug_line == NULL)
      debug_line = malloc(REMOTE_DEBUG_MAX_LINE);
d346 1
a346 1
  if ((sess=malloc(sizeof(debug_session)))==NULL)
d364 1
a364 1
  debug_printf(sess,"(6) Open Version %s", REMOTE_DEBUG_VERSION);
d388 1
a388 1
remote_debug_close(debug_session *sess)
d392 1
a392 1
    debug_printf(sess,"(6) Close");
d401 1
a401 1
  if (debug_line)
d403 2
a404 2
     free(debug_line);
     debug_line = NULL;
@


1.5
log
@  Fixed a couple of serious bugs.
Detail:
  Session command handler function pointer was being left uninitialised.
    If you were lucky, it data aborted ...
  When preformatting output with vsprintf, it's not a great idea to pass
    the destination buffer as one of the substitution strings, otherwise
    it disappears up itself and generates a puff of smoke.
Admin:
  Tested with CLI_App.

Version 0.05. Tagged as 'remotedb-0_05'
@
text
@d42 1
a42 8
/* If macro value is empty, expression rewrites to "0 * + 1" which is zero. */
#if 0 * Module_MinorVersion_CMHG + 1 == 0
#  define VSN  Module_MajorVersion
#else
#  define VSN  Module_MajorVersion " " Module_MinorVersion
#endif

static const char REMOTE_DEBUG_VERSION[] = VSN;
d46 1
a46 1
static int poll=1;
d53 1
a53 1
caseless_strcmp(char *a, char *b)
d83 1
a83 1
  poll=0; /* don't poll during debug_printf */
d129 1
a129 1
              else if (caseless_strcmp(argv[0],"PRIORITY")==0)
d149 1
a149 1
              else if (caseless_strcmp(argv[0], ":ack")==0)
d166 1
a166 1
  poll=1; /* return to polling during debug_printf */
d209 8
d218 1
a218 1
debug_print_line(debug_session *sess, const char *debug_line)
d220 1
a220 1
  unsigned char priority=7;
d225 1
a225 1
  if (poll)
d228 16
a243 3
  if (debug_line[0]=='(')             /* get opening bracket */
    if (strchr(debug_line,')')!=NULL) /* find closing bracket */
      priority=atoi(debug_line+1);
d245 5
a249 1
  if (priority<=sess->priority)
d251 3
a253 5
    send(sess->sock, sess->info, strlen(sess->info), 0);
    send(sess->sock, debug_line, strlen(debug_line), 0);

    if (debug_line[strlen(debug_line)-1]!='\n')
      send(sess->sock, "\n", 1, 0);
d257 1
d410 1
a410 1
const char *remotedb_version (void)
a413 1

@


1.4
log
@Changed copyright messages.
Stopped  version string from including the space at the end
unnecessarily. This fix means that this code now works!
Previously the version string with the space wasn't matched
correctly by the daemon and so it failed with no errors.
This code will still fail if branmch development goes on.
Suggest that someone fix the daemon by then.

Version 0.04. Tagged as 'remotedb-0_04'
@
text
@d79 1
d103 6
a108 3
        if (recv(sess->sock, debug_line, REMOTE_DEBUG_MAX_LINE,MSG_PEEK)>0)
          if ((cp=strchr(debug_line,'\n'))!=NULL)
            if (recv(sess->sock, debug_line, (cp-debug_line+1),0)>0)
d110 1
a110 1
              debug_line[cp-debug_line]='\0'; /* remove the new line char */
d114 1
a114 1
              cp = debug_line;
d156 4
d161 3
a163 1
                debug_printf(sess,"(6) unknown command '%s'\n",argv[0]);
d167 2
d309 1
a309 1
  } while (debug_socket == 0);
d316 3
d332 2
d335 1
a335 1
  if ((sess->info=malloc(strlen(info)+/*2 - No, you need + 3 JBeranek */ 3))==NULL)
d355 1
@


1.3
log
@ * Added version number string (created from SrcCommit info) and version
   number method (remotedb_version).

 * VersionNum file also gets copied to Export directory, so it's easy to
   see what version you've got compiled.


Version 0.03. Tagged as 'remotedb-0_03'
@
text
@d16 1
a16 1
/*                  Copyright 1996 Acorn Computers Ltd                  */
d19 1
a19 1
/*  information of Acorn Computers. It may not be reproduced, used      */
d21 1
a21 1
/*  consent of Acorn Computers. All rights reserved.                    */
d42 8
a49 3
/* Gives the version number an extra space if there's no minor version number
   but I can't figure how to get the preprocessor to fix this */
static const char REMOTE_DEBUG_VERSION[] = Module_MajorVersion " " Module_MinorVersion;
d329 1
a329 1
  debug_printf(sess,"(6) Open Version %s",REMOTE_DEBUG_VERSION);
@


1.2
log
@ * remotedb library moved onto trunk.


Version 0.02. Tagged as 'remotedb-0_02'
@
text
@d40 6
d370 4
@


1.1
log
@file remote was initially added on branch Spinner.
@
text
@d1 364
@


1.1.2.1
log
@Put the wacky remote debug library into cvs for safe keeping.
@
text
@a0 276
/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>

#include "sys/types.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "netdb.h"
#include "netinet/in.h"
#include "socklib.h"
#define REMOTE_DEBUG
#include "remote.h"

#define REMOTE_DEBUG_MAX_LINE 256

/*
 * compare two strings caselessly
 */
static int
caseless_strcmp(char *a, char *b)
{
  int d;

  while (*a || *b)
  {
    d = tolower( *(a++) ) - tolower( *(b++) );
    if (d) return d;
  }
  return 0;
}

/*
 * check the input port for any data, if there is, check it for a newline
 * and if terminated correctly, extract the line.
 */
static int
debug_poll(debug_session *sess)
{
  char debug_line[REMOTE_DEBUG_MAX_LINE];
  fd_set read_set;
  struct timeval tv;
  char	 *argv[20];
  int    argc = 0;
  char   *cp;

  if (!sess)
    return (0);

  FD_ZERO(&read_set);
  FD_SET(sess->sock,&read_set);
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  if (select(FD_SETSIZE,&read_set,NULL,NULL,&tv)<=0)
    return (0);

  if (FD_ISSET(sess->sock,&read_set))
  {
    if (recv(sess->sock, debug_line, sizeof(debug_line),MSG_PEEK)>0)
      if ((cp=strchr(debug_line,'\n'))!=NULL)
        if (recv(sess->sock, debug_line, (cp-debug_line+1),0)>0)
        {
          debug_line[cp-debug_line]='\0'; /* remove the new line char */
          /*
           * break down string
           */
          cp = debug_line;
          while (*cp != '\0')
          {
            while (*cp == ' ')
              cp++;
            if (*cp == '\0')
              break;
            argv[argc++] = cp;
            if (argc>=20)
              break;
            while (*cp != '\0' && *cp != ' ')
              cp++;
            if (*cp == 0)
              break;
            *cp++ = '\0';
          }
          *cp++ = '\0';
          /*
           * what do we want to do
           */
          if (caseless_strcmp(argv[0],"PRIORITY")==0)
          {
            if (argc>1)
            {
              debug_printf(sess,"(6) debug priority changed to %d\n",
              			     sess->priority);
              sess->priority = atoi(argv[1]);
            }
          }
          else
            debug_printf(sess,"(6) unknown command %s\n",argv[0]);
        }

  }
  return (0);
}

/*
 * send stuff to the debug session
 */
void
debug_printf(debug_session *sess, char *format, ...)
{
  char debug_line[REMOTE_DEBUG_MAX_LINE];
  va_list list;
  unsigned char priority=7;

  if (!sess)
    return;

  debug_poll(sess);

  va_start (list, format);
  vsprintf(debug_line,format, list);
  va_end(list);

  if (debug_line[strlen(debug_line)-1]!='\n')
    strcat(debug_line,"\n");

  if (debug_line[0]=='(')             /* get opening bracket */
    if (strchr(debug_line,')')!=NULL) /* find closing bracket */
      priority=atoi(debug_line+1);

  if (priority<=sess->priority)
  {
    send(sess->sock, sess->info, strlen(sess->info), 0);
    send(sess->sock, debug_line, strlen(debug_line), 0);
  }
}


/*
 * Reads environment variable Inet$DebugHost in the form valhalla:1448 to
 * obtain IP address and port number. Opens a socket to this host and returns
 * a structure to be used for subsequent debug calls. Debug session should be
 * closed using the remote_debug_session_close() function
 */
void
remote_debug_open(char *info, debug_session **db_sess)
{
  int rc;
  int debug_socket=-1;
  struct sockaddr_in sockaddr;
  struct hostent *hostent;
  debug_session *sess=NULL;
  char host[40];
  char *port;

  memset(&sockaddr, 0, sizeof(sockaddr));

  /*
   * where do we want to connect to
   */
  if (getenv("Inet$DebugHost")==NULL)
    goto exit_gracefully;
  strncpy(host,getenv("Inet$DebugHost"),sizeof(host));

  /*
   * find port
   */
  if ((port=strchr(host,':'))==NULL)
    goto exit_gracefully;

  *(port++) = 0; /* terminate host name and leave pointer to port */
  sockaddr.sin_port = htons(atoi(port));
  if (sockaddr.sin_port==0)
    goto exit_gracefully;

  /*
   * allocate a socket
   */
  do
  {
    debug_socket = socket(AF_INET, SOCK_STREAM, 0);
  } while (debug_socket == 0);

  hostent = gethostbyname(host);
  if (hostent == NULL)
    goto exit_gracefully;

  sockaddr.sin_family = AF_INET;
  sockaddr.sin_addr.s_addr = *(u_long*)hostent->h_addr;

  rc = connect(debug_socket, (struct sockaddr *)&sockaddr, sizeof(sockaddr) );
  if (rc<0)
    goto exit_gracefully;

  /*
   * allocate a debug session
   */
  if ((sess=malloc(sizeof(debug_session)))==NULL)
    goto exit_gracefully;

  sess->sock = debug_socket;

  if ((sess->info=malloc(strlen(info)+2))==NULL)
    goto exit_gracefully;

  strcpy(sess->info, info);
  strcat(sess->info, ": ");

  sess->priority = 7;

  /*
   * send initial opening message
   */
  debug_printf(sess,"(6) Open Version %s",REMOTE_DEBUG_VERSION);

  *db_sess = sess;

  return;

exit_gracefully:
  if (debug_socket >= 0)
    socketclose(debug_socket);

  if (sess)
  {
    if (sess->info)
      free(sess->info);
    free(sess);
  }
  *db_sess = NULL;
}

/*
 * close previously opened debug session
 */
void
remote_debug_close(debug_session *sess)
{
  if (sess)
  {
    debug_printf(sess,"(6) Close");
    if (sess->sock >= 0)
      socketclose(sess->sock);

    if (sess->info)
      free(sess->info);
    free(sess);
  }
  return;
}



@


1.1.2.2
log
@Forgot the comment '#' handling - tis done now.
@
text
@a110 2
          if (argv[0][0]=='#') /* ignore comments */
            ;
@


1.1.2.3
log
@Range check priority to stop Neil trying to break things.
Flush all input during one poll.
@
text
@a40 2
static int poll=1;

a69 1
  int    more;
d74 6
a79 1
  poll=0; /* don't poll during debug_printf */
d81 1
a81 1
  do
d83 33
a115 12
    more = 0;
    FD_ZERO(&read_set);
    FD_SET(sess->sock,&read_set);
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    if (select(FD_SETSIZE,&read_set,NULL,NULL,&tv)>0)
    {
      if (FD_ISSET(sess->sock,&read_set))
      {
        if (recv(sess->sock, debug_line, sizeof(debug_line),MSG_PEEK)>0)
          if ((cp=strchr(debug_line,'\n'))!=NULL)
            if (recv(sess->sock, debug_line, (cp-debug_line+1),0)>0)
d117 3
a119 41
              debug_line[cp-debug_line]='\0'; /* remove the new line char */
              /*
               * break down string
               */
              cp = debug_line;
              while (*cp != '\0')
              {
                while (*cp == ' ')
                  cp++;
                if (*cp == '\0')
                  break;
                argv[argc++] = cp;
                if (argc>=20)
                  break;
                while (*cp != '\0' && *cp != ' ')
                  cp++;
                if (*cp == 0)
                  break;
                *cp++ = '\0';
              }
              *cp++ = '\0';
              /*
               * what do we want to do
               */
              if (argv[0][0]=='#')  /* ignore comments */
                ;
              else if (caseless_strcmp(argv[0],"PRIORITY")==0)
              {
                if (argc>1)
                {
                  sess->priority = atoi(argv[1]);
                  if (sess->priority>7)
                    sess->priority = 7;
                  debug_printf(sess,"(6) debug priority changed to %d\n",
                  			     sess->priority);
                }
              }
              else
                debug_printf(sess,"(6) unknown command '%s'\n",argv[0]);

              more = 1; /* try for more input */
d121 4
a124 3
      }
    }
  } while (more);
d126 1
a126 1
  poll=1; /* return to polling during debug_printf */
d143 1
a143 2
  if (poll)
    debug_poll(sess);
@


1.1.2.4
log
@Deal with null input lines correctly. Range check priority of debug line.
@
text
@d25 13
a37 2
#ifndef __debug_remote_h
#define __debug_remote_h
d39 1
a39 1
#include <stdarg.h>
d41 1
a41 1
#define REMOTE_DEBUG_VERSION "0.02"
d43 15
a57 1
#ifdef REMOTE_DEBUG
d60 2
a61 1
 * structure to fold session data
d63 2
a64 1
typedef struct
d66 77
a142 4
  int  sock;
  char *info;
  unsigned char priority;
} debug_session;
d145 1
a145 4
 * Open a connection to host specified by Inet$DebugHost and send an initial
 * connection message. All future sends via this interface will be prefixed by
 * info. A copy of info is made internally. This call will return a pointer to
 * a session structure to be used in subsequent calls.
d147 31
a177 1
void remote_debug_open(char *info, debug_session **sess);
d180 4
a183 3
 * Send an printf formatted string upto a max of 256 characters to the debug
 * host. If string is prefixed by (n), this is treated as the debug priority
 * level.
d185 87
a271 1
void debug_printf(debug_session *sess, char *format, ...);
d274 1
a274 1
 * Close a previously open debug channel.
d276 15
a290 3
void remote_debug_close(debug_session *sess);

#else
a291 3
#define remote_debug_open(x,y)
#define debug_printf 1?0:printf
#define remote_debug_close(x)
a292 1
#endif /* REMOTE_DEBUG */
a293 1
#endif
@


1.1.2.5
log
@Extended to allow va_list's to be passed in directly to debug_printf
and to allow a command handling function to be registered to handle
commands coming down the wire from the server end.
@
text
@d25 2
a26 14
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>

#include "sys/types.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "netdb.h"
#include "netinet/in.h"
#include "socklib.h"
#define REMOTE_DEBUG
#include "remote.h"
d28 1
a28 1
#define REMOTE_DEBUG_MAX_LINE 1024
d30 3
a32 1
static int poll=1;
d35 1
a35 1
 * compare two strings caselessly
d37 1
a37 2
static int
caseless_strcmp(char *a, char *b)
d39 4
a42 9
  int d;

  while (*a || *b)
  {
    d = tolower( *(a++) ) - tolower( *(b++) );
    if (d) return d;
  }
  return 0;
}
d45 4
a48 2
 * check the input port for any data, if there is, check it for a newline
 * and if terminated correctly, extract the line.
d50 1
a50 85
static int
debug_poll(debug_session *sess)
{
  char debug_line[REMOTE_DEBUG_MAX_LINE];
  fd_set read_set;
  struct timeval tv;
  char	 *argv[20];
  int    argc = 0;
  char   *cp;
  int    more;

  if (!sess)
    return (0);

  poll=0; /* don't poll during debug_printf */

  do
  {
    more = 0;
    FD_ZERO(&read_set);
    FD_SET(sess->sock,&read_set);
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    if (select(FD_SETSIZE,&read_set,NULL,NULL,&tv)>0)
    {
      if (FD_ISSET(sess->sock,&read_set))
      {
        if (recv(sess->sock, debug_line, sizeof(debug_line),MSG_PEEK)>0)
          if ((cp=strchr(debug_line,'\n'))!=NULL)
            if (recv(sess->sock, debug_line, (cp-debug_line+1),0)>0)
            {
              debug_line[cp-debug_line]='\0'; /* remove the new line char */
              /*
               * break down string
               */
              cp = debug_line;
              while (*cp != '\0')
              {
                while (*cp == ' ')
                  cp++;
                if (*cp == '\0')
                  break;
                argv[argc++] = cp;
                if (argc>=20)
                  break;
                while (*cp != '\0' && *cp != ' ')
                  cp++;
                if (*cp == 0)
                  break;
                *cp++ = '\0';
              }
              *cp++ = '\0';
              /*
               * what do we want to do
               */
              if (argv[0][0]=='#')  /* ignore comments */
                ;
              else if (caseless_strcmp(argv[0],"PRIORITY")==0)
              {
                if (argc>1)
                {
                  sess->priority = atoi(argv[1]);
                  if (sess->priority>7)
                    sess->priority = 7;
                  debug_printf(sess,"(6) debug priority changed to %d\n",
                  			     sess->priority);
                }
              }
              else if (sess->cmd_handler) /* callback cmd handler if registered */
              {
                int rc = sess->cmd_handler(argc, argv, sess->cmd_handle);
                debug_printf(sess,"(6) cmd '%s' returns %d\n",argv[0], rc);
              }
              else
                debug_printf(sess,"(6) unknown command '%s'\n",argv[0]);

              more = 1; /* try for more input */
            }
      }
    }
  } while (more);

  poll=1; /* return to polling during debug_printf */
  return (0);
}
d53 3
a55 1
 * send stuff to the debug session
d57 1
a57 54
void
debug_printf(debug_session *sess, char *format, ...)
{
  char debug_line[REMOTE_DEBUG_MAX_LINE];
  va_list list;

  va_start (list, format);
  vsprintf(debug_line,format, list);
  va_end(list);

  debug_print_line(sess, debug_line);
}

void
debug_vprintf(debug_session *sess, const char *format, va_list list)
{
  char debug_line[REMOTE_DEBUG_MAX_LINE];

  vsprintf(debug_line,format, list);

  debug_print_line(sess, debug_line);
}

void
debug_print_line(debug_session *sess, const char *debug_line)
{
  unsigned char priority=7;

  if (!sess)
    return;

  if (poll)
    debug_poll(sess);

  if (debug_line[0]=='(')             /* get opening bracket */
    if (strchr(debug_line,')')!=NULL) /* find closing bracket */
      priority=atoi(debug_line+1);

  if (priority<=sess->priority)
  {
    send(sess->sock, sess->info, strlen(sess->info), 0);
    send(sess->sock, debug_line, strlen(debug_line), 0);

    if (debug_line[strlen(debug_line)-1]!='\n')
      send(sess->sock, "\n", 1, 0);
  }
}

void
remote_debug_register_cmd_handler(debug_session *sess, remote_debug_cmd_handler fn, void *handle)
{
  sess->cmd_handler = fn;
  sess->cmd_handle = handle;
}
d60 1
a60 4
 * Reads environment variable Inet$DebugHost in the form valhalla:1448 to
 * obtain IP address and port number. Opens a socket to this host and returns
 * a structure to be used for subsequent debug calls. Debug session should be
 * closed using the remote_debug_session_close() function
d62 1
a62 87
void
remote_debug_open(char *info, debug_session **db_sess)
{
  int rc;
  int debug_socket=-1;
  struct sockaddr_in sockaddr;
  struct hostent *hostent;
  debug_session *sess=NULL;
  char host[40];
  char *port;

  memset(&sockaddr, 0, sizeof(sockaddr));

  /*
   * where do we want to connect to
   */
  if (getenv("Inet$DebugHost")==NULL)
    goto exit_gracefully;
  strncpy(host,getenv("Inet$DebugHost"),sizeof(host));

  /*
   * find port
   */
  if ((port=strchr(host,':'))==NULL)
    goto exit_gracefully;

  *(port++) = 0; /* terminate host name and leave pointer to port */
  sockaddr.sin_port = htons(atoi(port));
  if (sockaddr.sin_port==0)
    goto exit_gracefully;

  /*
   * allocate a socket
   */
  do
  {
    debug_socket = socket(AF_INET, SOCK_STREAM, 0);
  } while (debug_socket == 0);

  hostent = gethostbyname(host);
  if (hostent == NULL)
    goto exit_gracefully;

  sockaddr.sin_family = AF_INET;
  sockaddr.sin_addr.s_addr = *(u_long*)hostent->h_addr;

  rc = connect(debug_socket, (struct sockaddr *)&sockaddr, sizeof(sockaddr) );
  if (rc<0)
    goto exit_gracefully;

  /*
   * allocate a debug session
   */
  if ((sess=malloc(sizeof(debug_session)))==NULL)
    goto exit_gracefully;

  sess->sock = debug_socket;

  if ((sess->info=malloc(strlen(info)+2))==NULL)
    goto exit_gracefully;

  strcpy(sess->info, info);
  strcat(sess->info, ": ");

  sess->priority = 7;

  /*
   * send initial opening message
   */
  debug_printf(sess,"(6) Open Version %s",REMOTE_DEBUG_VERSION);

  *db_sess = sess;

  return;

exit_gracefully:
  if (debug_socket >= 0)
    socketclose(debug_socket);

  if (sess)
  {
    if (sess->info)
      free(sess->info);
    free(sess);
  }
  *db_sess = NULL;
}
d64 1
a64 18
/*
 * close previously opened debug session
 */
void
remote_debug_close(debug_session *sess)
{
  if (sess)
  {
    debug_printf(sess,"(6) Close");
    if (sess->sock >= 0)
      socketclose(sess->sock);

    if (sess->info)
      free(sess->info);
    free(sess);
  }
  return;
}
d66 3
d70 1
d72 1
@


1.1.2.6
log
@Upped version number, exported debug_poll and checked for null sess in
cmd_handler.
@
text
@d64 1
a64 1
int
d204 2
a205 5
  if (sess)
  {
    sess->cmd_handler = fn;
    sess->cmd_handle = handle;
  }
@


1.1.2.7
log
@Used srccommit.
Updated Makefile to create library versions.
 Upped max line length and allocated it via malloc.
Added new debug type with args for file and line.

Version 0.01, 1.1.2.2. Tagged as 'remotedb-0_01-1_1_2_2'
@
text
@d40 1
a40 1
#define REMOTE_DEBUG_MAX_LINE (10*1024)
a42 1
static char *debug_line = NULL;
d67 1
d91 1
a91 1
        if (recv(sess->sock, debug_line, REMOTE_DEBUG_MAX_LINE,MSG_PEEK)>0)
d156 1
d169 2
a176 16
debug_dvprintf(debug_session *sess, int priority, const char *file, int line, const char *format, va_list list)
{
  int n = 0;

  if (priority != 0)
      n += sprintf(debug_line, "(%d)", priority);

  if (file)
      n += sprintf(debug_line+n, " %s:%d: ", file, line);

  vsprintf(debug_line+n, format, list);

  debug_print_line(sess, debug_line);
}

void
a227 4
  /* malloc to avoid problems in SVC mode */
  if (debug_line == NULL)
      debug_line = malloc(REMOTE_DEBUG_MAX_LINE);

a320 7

  if (debug_line)
  {
     free(debug_line);
     debug_line = NULL;
  }

@


1.1.2.8
log
@Fixed the problem with 'debug_line' in 'debug_poll' being used for input
and output at the same time and this corrupting the argv[0] and causing crashes (apparently).

Version 0.01, 1.1.2.3. Tagged as 'remotedb-0_01-1_1_2_3'
@
text
@d119 1
a119 1
              if (argc == 0 || argv[0][0]=='#' || argv[0][0] == 0)  /* ignore comments */
d134 2
a135 6
		  char name[32];
		  int rc;
		  strncpy(name, argv[0], sizeof(name));
		  name[sizeof(name)-1] = 0;
		  rc = sess->cmd_handler(argc, argv, sess->cmd_handle);
		  debug_printf(sess,"(6) cmd '%s' returns %d\n", name, rc);
@


1.1.2.9
log
@Fixed memory trampling bug in remote_debug_open.  Was causing unexplained
exits in code compiled with remotedb.
.
Removed dynamic depenencies from Makefile

Version 0.01, 1.1.2.4. Tagged as 'remotedb-0_01-1_1_2_4'
@
text
@a256 1
  host[sizeof(host)-1] = '\0';
d296 1
a296 1
  if ((sess->info=malloc(strlen(info)+/*2 - No, you need + 3 JBeranek */ 3))==NULL)
@


1.1.2.10
log
@ * Debug host and port number may now be different for seperate tasks.
   The debug host can now be specified by Inet$DebugHost_<taskname>.  If
   this variable is not set, remotedb will fall back to a global variable,
   Inet$DebugHost.


Version 0.01, 1.1.2.5. Tagged as 'remotedb-0_01-1_1_2_5'
@
text
@a242 1
  char varname[100];
d254 3
a256 12

  sprintf (varname, "Inet$DebugHost_%s", info);

  if (getenv (varname) == NULL)
  {
    if (getenv("Inet$DebugHost")==NULL)
      goto exit_gracefully;
    strncpy(host,getenv("Inet$DebugHost"),sizeof(host));
  }
  else
    strncpy(host,getenv(varname),sizeof(host));

@

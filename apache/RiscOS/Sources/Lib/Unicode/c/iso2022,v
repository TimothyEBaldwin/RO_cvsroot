head	1.21;
access;
symbols
	Unicode-0_63:1.21
	Unicode-0_62:1.21
	Unicode-0_61:1.21
	Unicode-0_60:1.21
	Unicode-0_59:1.20
	Unicode-0_58:1.20
	Unicode-0_57:1.20
	Unicode-0_56:1.20
	Unicode-0_55:1.19
	Unicode-0_54:1.19
	RO_5_07:1.18
	Unicode-0_53:1.18
	Unicode-0_52:1.18
	Unicode-0_51:1.17
	Unicode-0_50:1.17
	Unicode-0_49:1.17
	Unicode-0_48:1.17
	Unicode-0_47:1.17
	Unicode-0_46:1.16
	Unicode-0_45:1.14
	dellis_autobuild_BaseSW:1.13
	sbrodie_sedwards_16Mar2000:1.13
	Unicode-0_44:1.13
	dcotton_autobuild_BaseSW:1.16
	Unicode-0_43:1.13
	Unicode-0_42:1.13
	Unicode-0_41:1.13
	Unicode-0_40:1.12
	Unicode-0_39:1.12
	Unicode-0_38:1.12
	Unicode-0_37:1.12
	Unicode-0_36:1.12
	Unicode-0_35:1.11
	Unicode-0_34:1.10
	Unicode-0_33:1.10
	Unicode-0_32:1.8
	Unicode-0_31:1.8
	Unicode-0_30:1.8
	Unicode-0_29:1.8
	Unicode-0_28:1.8
	Unicode-0_27:1.7
	Unicode-0_26:1.7
	Unicode-0_25:1.7
	Unicode-0_24:1.7
	Unicode-0_23:1.7
	ahodgkin_207release:1.6
	Unicode-0_22:1.7
	Unicode-0_21:1.7
	Unicode-0_20:1.7
	Unicode-0_19:1.6
	Unicode-0_18:1.6
	Unicode-0_16:1.6
	Unicode-0_15:1.6
	ahodgkin_205release:1.6
	ahodgkin_204release:1.6
	Unicode-0_14:1.6
	ahodgkin_133beta:1.6
	Unicode-0_13:1.6
	Unicode-0_12:1.6
	Unicode-0_10:1.5
	Unicode-0_09:1.4
	Unicode-0_08:1.4
	Unicode-0_07:1.3
	Unicode-0_06:1.3
	Unicode-0_05:1.3
	Unicode-0_04:1.3
	Unicode-0_03:1.2
	Unicode-0_02:1.1;
locks; strict;
comment	@# @;


1.21
date	2013.01.06.22.32.09;	author jbell;	state Exp;
branches;
next	1.20;
commitid	mXR1bDbpHeiotczw;

1.20
date	2008.12.05.00.29.44;	author ahodgkin;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.25.11.57.08;	author kbracey;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.05.18.16.24;	author srevill;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.10.15.08.35;	author sbrodie;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.17.09.04.10;	author jberanek;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.13.10.38.05;	author jberanek;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.05.14.46.35;	author jberanek;	state Exp;
branches;
next	1.13;

1.13
date	99.09.13.09.55.47;	author kbracey;	state Exp;
branches;
next	1.12;

1.12
date	99.03.12.17.09.59;	author smiddle;	state Exp;
branches;
next	1.11;

1.11
date	99.03.12.15.53.14;	author kbracey;	state Exp;
branches;
next	1.10;

1.10
date	99.02.24.13.33.47;	author smiddle;	state Exp;
branches;
next	1.9;

1.9
date	99.02.24.12.04.21;	author smiddle;	state Exp;
branches;
next	1.8;

1.8
date	98.11.16.12.47.55;	author smiddle;	state Exp;
branches;
next	1.7;

1.7
date	98.09.15.18.11.17;	author smiddle;	state Exp;
branches;
next	1.6;

1.6
date	98.01.05.10.24.32;	author smiddle;	state Exp;
branches;
next	1.5;

1.5
date	97.12.18.14.56.54;	author smiddle;	state Exp;
branches;
next	1.4;

1.4
date	97.12.08.17.00.28;	author smiddle;	state Exp;
branches;
next	1.3;

1.3
date	97.11.21.18.21.50;	author smiddle;	state Exp;
branches;
next	1.2;

1.2
date	97.11.12.18.11.50;	author smiddle;	state Exp;
branches;
next	1.1;

1.1
date	97.11.11.16.24.47;	author smiddle;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Add encoding_read_in_multibyte_sequence API.
Detail:
  The new API allows the client to determine if a read codec has run
  out of input in the middle of a multibyte sequence. This permits a
  client to distinguish between the two cases in which no output
  character is generated:

    a) insufficient input has been provided to complete an output character
    b) the input consisted of a complete multibyte sequence which generates
       no output (e.g. an ISO-2022 shift sequence)
Admin:
  Tested using Iconv.


Version 0.60. Tagged as 'Unicode-0_60'
@
text
@/* Copyright 1997 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* > iso2022.c */

/**************************************************************************/
/*                                                                        */
/* Copyright [1997-2000] Pace Micro Technology PLC.  All rights reserved. */
/*                                                                        */
/* The copyright in this material is owned by Pace Micro Technology PLC   */
/* ("Pace").  This material is regarded as a highly confidential trade    */
/* secret of Pace.  It may not be reproduced, used, sold or in any        */
/* other way exploited or transferred to any third party without the      */
/* prior written permission of Pace.                                      */
/**************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "charsets.h"
#include "encpriv.h"
#include "iso2022.h"

/* ---------------------------------------------------------------------------------------------------- */

#define MAX_TABLES	10

typedef struct ISO2022_Set ISO2022_Set;
typedef struct ISO2022_EncoderSet ISO2022_EncoderSet;
typedef struct ISO2022_Encoding ISO2022_Encoding;

struct ISO2022_EncoderSet
{
    encoding_table table;

    const unsigned char *esc_seq;
    int esc_seq_len;
};

struct ISO2022_Encoding
{
    EncodingPriv e;
    ISO2022_Set *Set[4+2];

    ISO2022_Set *CL, *GL, *CR, *GR;
    unsigned char CL_s, GL_s, CR_s, GR_s;

    unsigned char ssarea;

    unsigned char sync[2];

    unsigned char tempset;
    ISO2022_Set *oldset;

    /* Whether escape sequences are disabled
     *
     * Value: Meaning:
     *   0    All escape sequences enabled
     *   1    Only SS2/3 escape sequences enabled
     *   2    All escape sequences disabled
     */
    unsigned char esc_disabled;

    /* Whether C1 control characters are permitted
     *
     * Value: Meaning:
     *   0    No C1 control characters permitted
     *   1    Only 0x8E/0x8F permitted
     *   2    All C1 control characters permitted
     */
    unsigned char c1_permitted;

    /* Pending escape commands */
    unsigned char esc_pending;
    unsigned char esc_multi;
    unsigned char esc_inter1;
    unsigned char esc_inter2;
    unsigned char esc_inter3;
    unsigned char esc_revision;

    /* encoding tables - 10 pointers should do for now */
    ISO2022_EncoderSet table[MAX_TABLES];
    int current[4];
    unsigned char first;
    unsigned char oneoffdesignator;
};

#define iso2022_ws_size (sizeof(ISO2022_Encoding) - sizeof(EncodingPriv))

/* ---------------------------------------------------------------------------------------------------- */

struct ISO2022_Set
{
    UCS4 (*next_code)(struct ISO2022_Set *s, int c, int invoker, unsigned char *sync);
};

#define G0 0
#define G1 1
#define G2 2
#define G3 3
#define C0 4
#define C1 5

#define G94_ISO646_IRV 0x42
#define C0_ISO646 0x40
#define C1_ISO6429 0x43

#define _GL 0
#define _GR 1
#define _CL 2
#define _CR 3

#define SS2 0x8E
#define SS3 0x8F

typedef struct simple_set
{
    ISO2022_Set s;
    encoding_table table;
} simple_set;

/* ---------------------------------------------------------------------------------------------------- */

/* static UCS2 *table94[0x3F], *table96[0x3F], *table128[0x3F], *table94x94[0x3F]; */
/* static UCS2 *tableC0[0x3F], *tableC1[0x3F]; */

/* ---------------------------------------------------------------------------------------------------- */

static UCS4 iso2022_esc_cont(ISO2022_Encoding *i, unsigned char c);
static void iso2022_esc(ISO2022_Encoding *i);

/* ---------------------------------------------------------------------------------------------------- */

static UCS4 simple_double_next_code_94(ISO2022_Set *s, int c, int invoker, unsigned char *sync)
{
    simple_set *ss = (simple_set *) s;

    if (c == 0x00 || c == 0x5F)
    {
        *sync = 0;
        return invoker == _GL ? c + 0x20 : 0xFFFD;
    }

    if (!*sync)
    {
        *sync = c;
        return NULL_UCS4;
    }
    else
    {
        UCS4 u = encoding_table_ptr(ss->table)[94*(*sync-1) + c-1];
        *sync = 0;
        return u;
    }
}

static UCS4 null_double_next_code(ISO2022_Set *s, int c, int invoker, unsigned char *sync)
{
    return 0xFFFD;

    NOT_USED(s);
    NOT_USED(c);
    NOT_USED(invoker);
    NOT_USED(sync);
}

static UCS4 simple_next_code_94(ISO2022_Set *s, int c, int invoker, unsigned char *sync)
{
    if (c > 0 && c < 0x5F)
        return encoding_table_ptr(((simple_set *)s)->table)[c-1]; /* -1 for 94 byte tables */

    if (invoker != _GL)
        return 0xFFFD;

    return c == 0 ? 0x20 : 0x7F;

    NOT_USED(sync);
}

static UCS4 simple_next_code_96(ISO2022_Set *s, int c, int invoker, unsigned char *sync)
{
    return encoding_table_ptr(((simple_set *)s)->table)[c];

    NOT_USED(invoker);
    NOT_USED(sync);
}

static UCS4 null_next_code_94(ISO2022_Set *s, int c, int invoker, unsigned char *sync)
{
    if (invoker == _GL)
    {
        if (c == 0) return 0x20;
        if (c == 0x5F) return 0x7F;
    }

    return 0xFFFD;

    NOT_USED(s);
    NOT_USED(sync);
}

static UCS4 null_next_code_96(ISO2022_Set *s, int c, int invoker, unsigned char *sync)
{
    return 0xFFFD;

    NOT_USED(s);
    NOT_USED(c);
    NOT_USED(invoker);
    NOT_USED(sync);
}

static void iso2022_ls(ISO2022_Encoding *i, int n)
{
    i->GL = i->Set[n];
    i->GL_s = n;
}

static void iso2022_lsr(ISO2022_Encoding *i, int n)
{
    i->GR = i->Set[n];
    i->GR_s = n;
}

static void iso2022_ss(ISO2022_Encoding *i, int n)
{
    if (i->ssarea)
    {
        i->tempset = 2;
        i->oldset = i->GR;
        i->GR = i->Set[n];
    }
    else
    {
        i->tempset = 1;
        i->oldset = i->GL;
        i->GL = i->Set[n];
    }
}

encoding_table iso2022_find_table(int type, int id)
{
    const char *dir;
    char fname[256];

    /* 07/14 is the empty set (section 14.1) */
    if (id == 0x7E)
        return NULL;

    switch (type)
    {
        case 32:
/*           table = tableC0 + id - 0x40; */
          dir = "C0";
          break;
        case 32+1:
/*           table = tableC1 + id - 0x40; */
          dir = "C1";
          break;
        case 94:
/*           table = table94 + id - 0x40; */
          dir = "G94";
          break;
        case 96:
/*           table = table96 + id - 0x40; */
          dir = "G96";
          break;
        case 94*94:
/*           table = table94x94 + id - 0x40; */
          dir = "G94x94";
          break;
        default:
          return NULL;
    }

    sprintf(fname, "ISO2022" DIR_SEP "%s" DIR_SEP "%02X" DIR_WILD, dir, id);
    return encoding_load_map_file(fname);
}

static void set_free(ISO2022_Set *Set)
{
    simple_set *set = (simple_set *)Set;
    if (set)
    {
	encoding_discard_map_file(set->table);
	encoding__free(set);
    }
}

static int iso2022_select_set(ISO2022_Encoding *i, int setno, int type, int id)
{
    encoding_table t;
    ISO2022_Set *set;

    UNIDBG(("iso2022_select_set: enc %p setno %d type %d\n", i, setno, type));

    /* This can return NULL if the table is not present in which case
       we fall back on default mapping functions below */
    t = iso2022_find_table(type, id);

    set = encoding__alloc(sizeof(simple_set));
    if (!set) return 0;
    memset(set, 0, sizeof(simple_set));

    if (type == 94*94)
    {
        if (t)
            set->next_code = simple_double_next_code_94;
        else
            set->next_code = null_double_next_code;
    }
    else if (type == 94)
    {
        if (t)
            set->next_code = simple_next_code_94;
        else
            set->next_code = null_next_code_94;
    }
    else
    {
        if (t)
            set->next_code = simple_next_code_96;
        else
            set->next_code = null_next_code_96;
    }

    ((simple_set *)set)->table = t;

    UNIDBG(("iso2022_select_set: free %p new %p tempset %d oldset %p\n", i->Set[setno], set, i->tempset, i->oldset));

    set_free(i->Set[setno]);
    i->Set[setno] = set;

    if (i->CL_s == setno) i->CL = i->Set[setno];
    if (i->GL_s == setno) i->GL = i->Set[setno];
    if (i->CR_s == setno) i->CR = i->Set[setno];
    if (i->GR_s == setno) i->GR = i->Set[setno];

    return t != NULL;
}

/* Free the tables that have been saved away to search when re
encoding. */

static void iso2022_free_write_tables(ISO2022_Encoding *i)
{
    int tab;
    for (tab = 0; tab < MAX_TABLES; tab++)
    {
	encoding_table *pt = &i->table[tab].table;
	if ( *pt )
	{
	    encoding_discard_map_file( *pt );
	    *pt = NULL;
	}
    }
}

static void iso2022_delete(EncodingPriv *e)
{
    ISO2022_Encoding *i = (ISO2022_Encoding *) e;
    set_free(i->Set[G0]);
    set_free(i->Set[G1]);
    set_free(i->Set[G2]);
    set_free(i->Set[G3]);
    set_free(i->Set[C0]);
    set_free(i->Set[C1]);

    iso2022_free_write_tables(i);
}

static int iso2022_reset(Encoding *e, int for_encoding)
{
    ISO2022_Encoding *i = (ISO2022_Encoding *) e;

/*  memset(i->Set, 0, sizeof i->Set); */

    i->CL_s = C0;
    i->GL_s = G0;
    i->CR_s = C1;
    i->GR_s = G1;

    i->c1_permitted = 2;
    i->esc_disabled = 0;
    i->esc_pending = i->esc_revision = 0;
    i->tempset = 0;
    i->oldset = NULL;
    i->ssarea = 0;
    i->first = 1;
    i->sync[_GL] = i->sync[_GR] = 0;

    iso2022_select_set(i, G0, 94, G94_ISO646_IRV);
    iso2022_select_set(i, G1, 96, 0x7E);
    iso2022_select_set(i, G2, 96, 0x7E);
    iso2022_select_set(i, G3, 96, 0x7E);
    iso2022_select_set(i, C0, 32, C0_ISO646);
    iso2022_select_set(i, C1, 32+1, C1_ISO6429);

    /* ISO8859 and EUC variants of ISO2022 require preloading with
       escape sequences to get the appropriate tables */
    if (e->list_entry->preload)
    {
        char euc = 0;
	unsigned int n = strlen(e->list_entry->preload);
	if (n != e->read(e, NULL, (unsigned char *)e->list_entry->preload, n, NULL))
	    return 0;

        if (e->list_entry->identifier == csEUCPkdFmtJapanese ||
                /* e->list_entry->identifier == csKSC56011987 || */
                e->list_entry->identifier == csEUCKR ||
                e->list_entry->identifier == csGB2312)
        {
            euc = 1;
        }

        /* If we've preloaded and we're not handling an EUC variant
         * then we need to disable further escape sequences otherwise
         * stray control sequences (eg 8E, 8F) will try and switch tables.
         *
         * If we're handling an EUC variant which has loaded tables into
         * G2 and G3, then SS2/SS3 are permitted. */
        if (euc && ((simple_set *)i->Set[G2])->table &&
                ((simple_set *)i->Set[G3])->table)
        {
            i->esc_disabled = 1;
            i->c1_permitted = 1;
        }
        else
        {
            i->esc_disabled = 2;
            if (euc)
                i->c1_permitted = 0;
        }
    }

    if (for_encoding != encoding_READ)
    {
	const unsigned char *s = (const unsigned char *)e->list_entry->encoder_data;
	if (s)
	{
	    int tab = 0;
	    const unsigned char *last_s = NULL;

	    /* free up the old ones before allocating new ones */
	    iso2022_free_write_tables(i);

	    /* process the table specifying string, they will all place into G1 */
	    while (tab < MAX_TABLES)
	    {
		unsigned char c = *s;

		if (c == 0 || c == 0x1B)
		{
		    if (last_s)
		    {
			simple_set *ss = (simple_set *)i->Set[G1];

			i->table[tab].table = ss->table;	/* copy over table ptr */
			ss->table = NULL;			/* null entry so it doesn't get discarded */

			i->table[tab].esc_seq = last_s;
			i->table[tab].esc_seq_len = s - last_s;

			UNIDBG(("iso2022_reset: loaded write table %d table %p esc_seq_len %d\n", tab,
			        i->table[tab].table, i->table[tab].esc_seq_len));

			tab++;
		    }

		    last_s = s;
		}

		if (c == 0)
		    break;
		else if (c == 0x1B)
		    iso2022_esc(i);
		else
		{
		    /* Jiggery pokery - run all through G1 just for this scan */
		    iso2022_esc_cont(i,(unsigned char )(c >= 0x28 && c <= 0x2F ?
                                                        (c&~3)+1 : c));

		    /* Aaargh! Above won't work for crummy 1B 24 42 Japanese broken sequences */
		    if (c == 0x24 && s[1] >= 0x40) iso2022_esc_cont(i, 0x29);
		}

		s++;
	    }

	    set_free(i->Set[G1]);

	    i->Set[G1] = 0;
    	    /*
    	     * Special - this may need improving. If only two tables (ASCII variant + 1 other)
             * we assume that only one designator sequence is required, at the top of the
             * output. This handles ISO-2022-KR. Although that doesn't actually require
             * it at the top, it requires it at the start of a line; at the top is the
             * easiest way to do that.
             */
    	    i->oneoffdesignator = tab <= 2;
	}

	i->current[G0] = 0;	/* assume the first table is set initially */
    }

    return 1;
}

#if 0
/* Not used at the moment */
static void iso2022_disable_escapes(EncodingPriv *i)
{
    ((ISO2022_Encoding *)i)->esc_disabled = 1;
}
#endif

static void iso2022_esc(ISO2022_Encoding *i)
{
    i->esc_pending = 1;
    i->esc_multi = 0;
    i->esc_inter1 = 0;
    i->esc_inter2 = 0;
    i->esc_inter3 = 0;
}

static UCS4 iso2022_esc_cont(ISO2022_Encoding *i, unsigned char c)
{
    if (c >= 0x7F || c < 0x20)
    {
        /* Illegal. Yuck */
        i->esc_pending = 0;
        return 0xFFFD;
    }

    if (c >= 0x20 && c <= 0x2F)
    {
        /* A continuation byte */
        switch (c)
        {
            case 0x24:
              if (!i->esc_inter1)
              {
                  i->esc_multi = 0x24;
                  break;
              }
              /* else fall through */
            default:
              if (!i->esc_inter1)
                 i->esc_inter1 = c;
              else if (!i->esc_inter2)
                 i->esc_inter2 = c;
              break;
        }
        return NULL_UCS4;
    }

    /* The final byte (yippee) */
    i->esc_pending = 0;

    /* Special: ESC $ <c> == ESC $ ( <c> */
    if (i->esc_multi && !i->esc_inter1)
        i->esc_inter1 = 0x28;

    if (!i->esc_multi && !i->esc_inter1)
    {
        /* A single character escape sequence */
        if (c >= 0x40 && c <= 0x5F)
            return i->Set[C1]->next_code(i->Set[C1], c - 0x40, _GL, NULL);
        else if (c == 0x6E)
            iso2022_ls(i, G2);
        else if (c == 0x6F)
            iso2022_ls(i, G3);
        else if (c == 0x7E)
            iso2022_lsr(i, G1);
        else if (c == 0x7D)
            iso2022_lsr(i, G2);
        else if (c == 0x7C)
            iso2022_lsr(i, G3);

        return NULL_UCS4;
    }

    switch (i->esc_inter1)
    {
        case 0x20:
          switch (c)
          {
            case 0x5C:
              i->ssarea = 1;
              break;
          }
          break;
        case 0x21: iso2022_select_set(i, C0, 32, c); break;
        case 0x22: iso2022_select_set(i, C1, 32+1, c); break;
        case 0x25: /* Non-ISO2022 set */ break;
        case 0x26: i->esc_revision = c; break;
        case 0x28: iso2022_select_set(i, G0, i->esc_multi ? 94*94 : 94, c); break;
        case 0x29: iso2022_select_set(i, G1, i->esc_multi ? 94*94 : 94, c); break;
        case 0x2A: iso2022_select_set(i, G2, i->esc_multi ? 94*94 : 94, c); break;
        case 0x2B: iso2022_select_set(i, G3, i->esc_multi ? 94*94 : 94, c); break;
        case 0x2D: iso2022_select_set(i, G1, i->esc_multi ? 96*96 : 96, c); break;
        case 0x2E: iso2022_select_set(i, G2, i->esc_multi ? 96*96 : 96, c); break;
        case 0x2F: iso2022_select_set(i, G3, i->esc_multi ? 96*96 : 96, c); break;
    }

    return NULL_UCS4;
}

/* ---------------------------------------------------------------------------------------------------- */

static unsigned int iso2022_read(EncodingPriv *e,
			  encoding_read_callback_fn ucs_out,
                          const unsigned char *s,
                          unsigned int n,
                          void *handle)
{
    ISO2022_Encoding *i = (ISO2022_Encoding *) e;
    unsigned int count;

    for (count = n; count; count--)
    {
        unsigned char c = *s++;
        UCS4 u;

	UNIDBG(("iso2022: %02x\n", c));

	/* check for illegal single shifts */
	if ((i->tempset == 1 && (c < 0x20 || c > 0x7F)) ||
	    (i->tempset == 2 && (c < 0xA0)))
	{
	    u = 0xFFFD;
	}
        /* or illegal continuation bytes */
        else if ((i->sync[_GL] && (c < 0x20 || c > 0x7F)) ||
                 (i->sync[_GR] && (c < 0xA0)))
        {
            u = 0xFFFD;
        }
	else if (i->esc_pending)
	{
            u = iso2022_esc_cont(i, c);
	}
        else if (c < 0x20)
        {
            i->sync[_GL] = i->sync[_GR] = 0;
            u = i->CL->next_code(i->CL, c       , _CL, NULL);
        }
        else if (c < 0x80)
        {
            i->sync[_GR] = 0;
            u = i->GL->next_code(i->GL, c - 0x20, _GL, i->sync + _GL);
        }
        else if (c < 0xA0)
        {
            i->sync[_GL] = i->sync[_GR] = 0;
            if (i->c1_permitted == 2 ||
                    (i->c1_permitted == 1 && (c == 0x8E || c == 0x8F)))
            {
                u = i->CR->next_code(i->CR, c - 0x80, _CR, NULL);
            }
            else
            {
                u = 0xFFFD;
            }
        }
        else
        {
            i->sync[_GL] = 0;
	    u = i->GR->next_code(i->GR, c - 0xA0, _GR, i->sync + _GR);
        }

        switch (u)
        {
            case 0x1B: if (!i->esc_disabled) { iso2022_esc(i); continue; }
                       break;
            case 0x0F: if (!i->esc_disabled) { iso2022_ls(i, G0); continue; }
                       break;
            case 0x0E: if (!i->esc_disabled) { iso2022_ls(i, G1); continue; }
                       break;
            case 0x8E: if (i->esc_disabled < 2) { iso2022_ss(i, G2); continue; }
                       break;
            case 0x8F: if (i->esc_disabled < 2) { iso2022_ss(i, G3); continue; }
                       break;
        }

        if (u != NULL_UCS4)
        {
            if (i->tempset)
            {
                if (i->tempset == 1)
                    i->GL = i->oldset;
                else
                    i->GR = i->oldset;
                i->tempset = 0;
            }

            if (u == NULL_UCS2)
                u = 0xFFFD;

            if (ucs_out)
                if (ucs_out(handle, u))
                {
                    /* Character has been used, so ensure it's counted */
                    count--;
                    break;
                }
        }
    }

    return n - count;
}

static int iso2022_read_in_multibyte_sequence(EncodingPriv *e)
{
    ISO2022_Encoding *i = (ISO2022_Encoding *) e;

    return i->sync[_GL] != 0 || i->sync[_GR] != 0 || i->esc_pending != 0;
}

/* ---------------------------------------------------------------------------------------------------- */

static int write_index(int index, unsigned char *out, int table_size, int sevenbit)
{
    int base = sevenbit ? 0x20 : 0xA0;
    switch (table_size)
    {
    case 32:
    case 32+1:
	*out++ = index;
	return 1;

    case 94:
	*out++ = base + 1 + index;
	return 1;

    case 96:
	*out++ = base + index;
	return 1;

    case 94*94:
    {
	int c1 = index / 94;
	int c2 = index % 94;

	out[0] = base + 1 + c1;
	out[1] = base + 1 + c2;

	return 2;
    }
    }
    return 0;
}

/* ---------------------------------------------------------------------------------------------------- */

static int iso2022_scan_tables(ISO2022_Encoding *enc, UCS4 u, int *index, int *table_no, int *size)
{
    int i, tab;
    for (tab = 0; tab < MAX_TABLES; tab++)
    {
	encoding_table table = enc->table[tab].table;

	if (table && (i = encoding_lookup_in_table(u, table)) != -1)
	{
	    *index = i;
	    *table_no = tab;
	    *size = encoding_n_table_entries(table);
	    return 1;
	}
    }

    return 0;
}

/* 7bit scheme. Two or more character sets are set up and SO,SI,SS2,SS3 are used
 * to switch between them.
 */

static int iso2022_write_shifts(EncodingPriv *e, UCS4 u, unsigned char **ps, int *bufsize)
{
    ISO2022_Encoding *enc = (ISO2022_Encoding *)e;
    int index, tab, n_entries;
    unsigned char buf[16];		/* assume that 16 characters will be enough space */
    int out = 0;
    int GL_s = enc->GL_s;
    int current[4];

    memcpy(current, enc->current, sizeof current);

    if (enc->first && enc->oneoffdesignator && u != NULL_UCS4)
    {
        memcpy(buf + out, enc->table[1].esc_seq, enc->table[1].esc_seq_len);
        out += enc->table[1].esc_seq_len;
        current[G1] = 1;
    }

    /* control chars */
    if (u < 0x0021 || u == NULL_UCS4)
    {
        if (GL_s != G0)
	{
	    buf[out++] = 0x0F;
	    GL_s = G0;
	}

	if (current[G0] != 0)
	{
            memcpy(buf + out, enc->table[0].esc_seq, enc->table[0].esc_seq_len);
            out += enc->table[0].esc_seq_len;
            current[G0] = 0;
        }

	if (!enc->oneoffdesignator && (u == NULL_UCS4 || u == 0x0D || u == 0x0A))
	{
  	    /* Forget all our other designators */
	    current[G1] = current[G2] = current[G3] = 0;
	}

	if (u != NULL_UCS4)
	    buf[out++] = u;
    }

    /* main chars */

    else if ((index = encoding_lookup_in_table(u, enc->table[current[GL_s]].table)) != -1)
    {
        out += write_index(index, buf + out, encoding_n_table_entries(enc->table[current[GL_s]].table), 1);
    }

    else if (iso2022_scan_tables(enc, u, &index, &tab, &n_entries))
    {
 	 UNIDBG(("iso2022_write_escapes: u %04x index %d table %d n_entries %d\n",
 	         u, index, tab, n_entries));
	if (enc->current[GL_s] != tab)
	{
	    ISO2022_EncoderSet *eset = &enc->table[tab];
	    int setno;

	    UNIDBG(("iso2022_write_escapes: switch set\n"));

	    /* Which Gn set does this table belong in? */
	    if (eset->esc_seq[1] >= 0x28 && eset->esc_seq[1] <= 0x2F)
	        setno = (eset->esc_seq[1] & 3) + G0;
	    else if (eset->esc_seq[2] >= 0x28 && eset->esc_seq[2] <= 0x2F)
	        setno = (eset->esc_seq[2] & 3) + G0;
	    else /* Yuck - one of the broken ISO-2022-JP specifiers */
	        setno = 0;

	    if (current[setno] != tab)
	    {
	        memcpy(buf + out, eset->esc_seq, eset->esc_seq_len);
	        out += eset->esc_seq_len;
	        current[setno] = tab;
	    }

	    if (GL_s != setno)
	    {
                switch (setno)
                {
                    case G0: buf[out++] = 0x0F; GL_s = G0; break;
                    case G1: buf[out++] = 0x0E; GL_s = G1; break;
                    case G2: buf[out++] = 0x1B; buf[out++] = 0x4E; break;
                    case G3: buf[out++] = 0x1B; buf[out++] = 0x4F; break;
                }
            }
	}

	out += write_index(index, buf + out, n_entries, 1);
    }

    else if (e->for_encoding == encoding_WRITE_STRICT)
	return -1;

    /* special chars */
    else /* if (u == 0xFFFD) */	/* bad character */
    {
        if (GL_s != G0)
	{
	    buf[out++] = 0x0F;
	    GL_s = G0;
	}

	buf[out++] = '?';
    }

    /* check space */
    if ((*bufsize -= out) < 0 || !ps)
	return 0;

    enc->first = 0;
    enc->GL_s = GL_s;
    memcpy(enc->current, current, sizeof current);

    /* copy out and update ptr */
    memcpy(*ps, buf, out);
    (*ps) += out;

    return 1;
}


EncodingPriv enc_iso2022 =
{
    iso2022_read,
    iso2022_read_in_multibyte_sequence,
    iso2022_reset,
    sizeof (ISO2022_Encoding) - sizeof(EncodingPriv),
    iso2022_delete,
    0,
    iso2022_write_shifts,
    0,
    0,
    0
};

/* ---------------------------------------------------------------------------------------------------- */

static int iso2022_scan_sets(ISO2022_Encoding *enc, UCS4 u, int *index, int *table_no, int *size)
{
    int i, set;
    for (set = 0; set < 4; set++)
    {
	simple_set *setptr = (simple_set *) enc->Set[set];

        /* UNIDBG(("scan_table: set %d table %p\n", set, setptr->table)); */

        if (setptr->table == NULL) continue;

	if ((i = encoding_lookup_in_table(u, setptr->table)) != -1)
	{
	    *index = i;
	    *table_no = set;
	    *size = encoding_n_table_entries(setptr->table);
	    return 1;
	}
    }

    return 0;
}

/* EUC:    sets 0 and 1 are fixed, SS2,SS3 used to select sets 2 and 3
 * 8859-X: sets 0 and 1 are fixed, sets 2 and 3 aren't used.
 */

static int iso2022_write_euc(EncodingPriv *e, UCS4 u, unsigned char **euc, int *bufsize)
{
    ISO2022_Encoding *enc = (ISO2022_Encoding *)e;
    unsigned char buf[4];

    int index, set, n_entries;
    int out = 0;

    if (u == NULL_UCS4)
	return 0;

retry:

    /* control chars */
    if (u < 0x0021 || u == 0x007F)
        buf[out++] = u;
    else if ((enc->c1_permitted == 2 && 0x0080 <= u && u <= 0x009F))
        buf[out++] = u;

    /* main chars */
    else if (iso2022_scan_sets(enc, u, &index, &set, &n_entries))
    {
        UNIDBG(("iso2022_write_euc: u %04x index %d set %d size %d\n",
                u, index, set, n_entries));
	switch (set)
	{
	case G0:
	    buf[out++] = index + 0x21;
	    break;

	case G1:
	    out += write_index(index, buf+out, n_entries, 0);
	    break;

	case G2:
	    buf[out++] = SS2;
	    out += write_index(index, buf+out, n_entries, 0);
	    break;

	case G3:
	    buf[out++] = SS3;
	    out += write_index(index, buf+out, n_entries, 0);
	    break;
	}
    }

    else if (e->for_encoding == encoding_WRITE_STRICT)
	return -1;

    else if (u == 0x0110) /* D-stroke - try Eth */
    {
        u = 0x00D0;
        goto retry;
    }

    /* special chars */
    else /* if (u == 0xFFFD) */	/* bad character */
	buf[out++] = '?';

    /* check space */
    if ((*bufsize -= out) < 0 || !euc)
	return 0;

    /* copy out and update ptr */
    memcpy(*euc, buf, out);
    (*euc) += out;

    return 1;
}

EncodingPriv enc_iso2022_euc =
{
    iso2022_read,
    iso2022_read_in_multibyte_sequence,
    iso2022_reset,
    sizeof (ISO2022_Encoding) - sizeof(EncodingPriv),
    iso2022_delete,
    0,
    iso2022_write_euc,
    0,
    0,
    0
};

/* ---------------------------------------------------------------------------------------------------- */

/* eof iso2022.c */
@


1.20
log
@  Fix bugs and inconsistencies in encoding handlers.
  Fix inconsistency in handling illegal byte sequences.
  Convert surrogate codepoints and U+FFFE, U+FFFF to U+FFFD.
  Also, a few extra mappings.
Detail:
  enc_utf8.c: 0x80 is a continuation byte. Map stray ones to U+FFFD.
              Reset the count of expected continuation bytes to 0 when
              encountering illegal byte sequences. Previously, if the character
              callback returned non-zero, this count would not be reset, thus
              leaving the codec in an inconsistent state. Additionally, we no
              longer consume the illegal continuation byte: instead, we process
              it as a start byte next time round.
  encoding.c: Do not load extension tables for ISO-8859-{1,2,9,10,15,16}
              If these are needed, it's probably best that different charset
              names are used rather than overloading 8859-n.
  iso2022.c:  Permit SS2/3 escape sequences for EUC encode/decode.
              Disable C1 characters for EUC encode/decode.
              Fix G94x94 read function to handle GR 0xA0/0xFF correctly.
              Fix writing of C1 controls for 8859-n.
              Prevent dereference of NULL pointer when scanning tables.
  iso6937.c:  Replace C99 loop iterators with C89 friendly versions.
  johab.c:    Fix final_only lookup table to have entries in the right place.
              Map 0x5C to the Won sign.
              Actually pay attention to encoding_WRITE_STRICT.
  shiftjis.c: Map 0x7E to overbar rather than tilde.
  textconv.c: Fix static assignment of stdin/stdout.
  unix.c:     Perform wildcard lookup of mapping tables.
  ccsolaris/Makefile: Modify for use with GCCSDK
Admin:
  Tested with the Iconv module testsuite.
Author:
  John-Mark Bell


Version 0.56. Tagged as 'Unicode-0_56'
@
text
@d724 7
d916 1
d1029 1
@


1.19
log
@* Added support for ISO 6937:2001, and the variant with Euro used by DVB.
  (This isn't integrated with ISO 2022 processing though - it's standalone).
* Added a Dstroke -> Eth second-attempt conversion in various write routines,
  primarily for ISO 6937 -> Latin1 conversion (ISO 6937 unifies them).

Version 0.54. Tagged as 'Unicode-0_54'
@
text
@d32 1
d67 7
d76 9
d153 1
a153 1
        return c + 0x20;
a166 2

    NOT_USED(invoker);
d394 1
d410 1
a410 1
    /* ISO8859 and EUC variants of IOS2022 require preloading with
d414 1
d418 27
a444 5
        
        /* if we've preloaded then we need to disable further escape
         * sequences otherwise stray control sequences (eg 8E, 8F)
         * will try and switch tables */
        i->esc_disabled = 1;
d644 6
d667 9
a675 1
            u = i->CR->next_code(i->CR, c - 0x80, _CR, NULL);
d691 1
a691 1
            case 0x8E: if (!i->esc_disabled) { iso2022_ss(i, G2); continue; }
d693 1
a693 1
            case 0x8F: if (!i->esc_disabled) { iso2022_ss(i, G3); continue; }
d930 2
d962 4
a965 2
    if (u < 0x0021)
	buf[out++] = u;
@


1.18
log
@Change merged from Pace repository:
> Summary:
>   Merged changes from branch tree
>   Reversed previous change
> Detail:
>
> * Merged a few changes/fixes from the Unicode library in
>  branch's tree.
>
> * Reversed Steve's change from version 0.50. The change wasn't
>  necessary, and with the changed definition of NOT_USED in this
>  version, it compiles fine with cc 5.45.
>
> * Small comment change in unix.c. It now states that the file
>  isn't equivalent to any in the branch tree.
>
> Admin:
>   Built and briefly tested using TextConv utility on Risc PC.

Version 0.52. Tagged as 'Unicode-0_52'
@
text
@d661 1
a661 1
                    /* Character has been used, so ensure its counted */
d904 2
d940 6
@


1.17
log
@  Merge of bug fixes from NCBrowser tree.
Detail:
  Buffer overrun fixed; some buffer counting problems fixed too.  There is
    now helpful initialisation and tidyup routines you can call too (called
    encoding_initialise and encoding_tidyup)
Admin:
  I've built this with cc 5.45 in basic build environment - it built OK.
  This source code now matches that in NCBrowser 5.28.


Version 0.47. Tagged as 'Unicode-0_47'
@
text
@d401 5
@


1.16
log
@  Argh, timestamps.
Detail:
  Timestamps defeated my latest checkin of the library, iso2022.c
   failed to be copied from my RPC to the NFS mount, which makes
   the library fail to build...argh.  Copied over correct version
   of this file.
Admin:
  Will retag file as Unicode-0_46.
@
text
@d655 3
d659 1
@


1.15
log
@  More syncronisation with Unicode lib in branched tree
Detail:
  Added some changes from Unicode lib in branched tree.  All basically
   type changes.  This appears to be because other compilers are
   more picky about types than armcc.

Admin:
  Will add 0.46 VersionNum file into branched tree, and all will be
   syncronised fully.


Version 0.46. Tagged as 'Unicode-0_46'
@
text
@d47 1
a47 1
    const char *esc_seq;
d57 1
a57 1
    char CL_s, GL_s, CR_s, GR_s;
d59 1
a59 1
    char ssarea;
d61 1
a61 1
    char sync[2];
d63 1
a63 1
    char tempset;
d66 1
a66 1
    char esc_disabled;
d69 6
a74 6
    char esc_pending;
    char esc_multi;
    char esc_inter1;
    char esc_inter2;
    char esc_inter3;
    char esc_revision;
d79 2
a80 2
    char first;
    char oneoffdesignator;
d89 1
a89 1
    UCS4 (*next_code)(struct ISO2022_Set *s, int c, int invoker, char *sync);
d124 1
a124 1
static UCS4 iso2022_esc_cont(ISO2022_Encoding *i, char c);
d129 1
a129 1
static UCS4 simple_double_next_code_94(ISO2022_Set *s, int c, int invoker, char *sync)
d154 1
a154 1
static UCS4 null_double_next_code(ISO2022_Set *s, int c, int invoker, char *sync)
d164 1
a164 1
static UCS4 simple_next_code_94(ISO2022_Set *s, int c, int invoker, char *sync)
d177 1
a177 1
static UCS4 simple_next_code_96(ISO2022_Set *s, int c, int invoker, char *sync)
d185 1
a185 1
static UCS4 null_next_code_94(ISO2022_Set *s, int c, int invoker, char *sync)
d199 1
a199 1
static UCS4 null_next_code_96(ISO2022_Set *s, int c, int invoker, char *sync)
d399 1
a399 1
	if (n != e->read(e, NULL, e->list_entry->preload, n, NULL))
d405 1
a405 1
	const char *s = e->list_entry->encoder_data;
d409 1
a409 1
	    const char *last_s = NULL;
d417 1
a417 1
		int c = *s;
d447 2
a448 1
		    iso2022_esc_cont(i, c >= 0x28 && c <= 0x2F ? (c&~3)+1 : c);
d493 1
a493 1
static UCS4 iso2022_esc_cont(ISO2022_Encoding *i, char c)
d580 1
a580 1
                          const char *s,
d589 1
a589 1
        char c = *s++;
d664 1
a664 1
static int write_index(int index, char *out, int table_size, int sevenbit)
d721 1
a721 1
static int iso2022_write_shifts(EncodingPriv *e, UCS4 u, char **ps, int *bufsize)
d725 1
a725 1
    char buf[16];		/* assume that 16 characters will be enough space */
d884 1
a884 1
static int iso2022_write_euc(EncodingPriv *e, UCS4 u, char **euc, int *bufsize)
d887 1
a887 1
    char buf[4];
@


1.14
log
@  Copyright message changes + changes from branch + Unified
   branched/non-branched builds
Detail:
  Copyright messages changed from E-14 to Pace throughout, filename
   placed at top of file throughout, instead of in just some files.

  Merged branch's fixes into our code base, plus made it possible to
   get nice debug output in branched tree, and vfprintf() to stderr in
   RISC OS tree.  Exactly same source used in branched tree now (apart
   from OS specific files riscos.c and unix.c moving into layers
   directory structure).

Admin:
  Built for branched, both Unix and RISC OS.
  Built in RISC OS tree, and compiled into TextConv.


Version 0.45. Tagged as 'Unicode-0_45'
@
text
@d865 1
a865 1
/* 	fprintf(stderr, "scan_table: set %d table %p n %d\n", set, setptr->table, n_entries); */
d901 2
a902 1
/* 	fprintf(stderr, "iso2022_write_euc: u %04x index %d set %d size %d\n", u, index, set, n_entries); */
@


1.13
log
@SCSU encoder made aware of SIP (Supplementary Plane for Unified CJK Ideographs).
UTF-8 encoder handles out-of-space conditions correctly.
ISO 2022 encoder/decoder doesn't try to load table 7E (the null table).
encoding_new() does identify a null MIME string with auto-detect Japanese.
UnicodeData 3.0.0 imported.

Version 0.41. Tagged as 'Unicode-0_41'
@
text
@d15 12
a26 9
/************************************************************************/
/*                  Copyright 1997-1999 Element 14 Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Element 14 Ltd.  It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Element 14 Ltd.  All rights reserved.                    */
/*                                                                      */
/************************************************************************/
d150 2
d157 5
d173 2
d180 3
d194 3
d202 5
d291 1
a291 1
    /* fdebugf(stderr, "iso2022_select_set: enc %p setno %d type %d\n", i, setno, type); */
d325 1
a325 1
    /* fdebugf(stderr, "iso2022_select_set: free %p new %p tempset %d oldset %p\n", i->Set[setno], set, i->tempset, i->oldset); */
d398 1
a398 1
	int n = strlen(e->list_entry->preload);
d431 2
a432 1
			fdebugf(stderr, "iso2022_reset: loaded write table %d table %p esc_seq_len %d\n", tab, i->table[tab].table, i->table[tab].esc_seq_len);
d475 2
a476 1

d481 1
d591 1
a591 1
	/* fdebugf(stderr, "iso2022: %02x\n", c); */
d773 2
a774 1
 	/* fdebugf(stderr, "iso2022_write_escapes: u %04x index %d table %d n_entries %d\n", u, index, tab, n_entries); */
d780 1
a780 1
	    /* fdebugf(stderr, "iso2022_write_escapes: switch set\n"); */
d850 4
a853 1
    iso2022_write_shifts
d949 4
a952 1
    iso2022_write_euc
@


1.12
log
@Changed encoding_table_remove_unused() so that it takes a
parameter giving the depth from which to start purging.
Fixed ISO2022 write code to free search tables.
Added unix.c for unix-targeted builds.
Updated cross-compile build.
Added unix-targeted build of library and textconv tool
in ccsolaris directory.

Version 0.36. Tagged as 'Unicode-0_36'
@
text
@d219 4
@


1.11
log
@Updated ISO 2022 handling to write ISO 2022-KR and ISO 2022-CN. Fixed various
bugs.
x-Current encoding didn't work if International 1.50 wasn't loaded.
Adjusted various ISO 2022 escape sequence tables to change prioritisation.
ISO 2022 writer won't shift character set until required.

Version 0.35. Tagged as 'Unicode-0_35'
@
text
@a27 1
#include "swis.h"
d311 17
d337 2
d384 3
d674 1
a674 1
	if ((i = encoding_lookup_in_table(u, table)) != -1)
@


1.10
log
@Added copyright messages to all source files and unified the
header #define's.

Version 0.33. Not tagged
@
text
@d76 3
a78 1
    int current_table;
d266 1
a266 1
    
d328 1
a328 1
    
d339 1
d366 1
a366 1
	    /* process the table specifying string, they will all place into G0 */
d375 1
a375 1
			simple_set *ss = (simple_set *)i->Set[G0];
d382 1
a382 1
			
d387 1
a387 1
		    
d396 7
a402 1
		    iso2022_esc_cont(i, c);
d407 11
a417 2
	    set_free(i->Set[G0]);
	    i->Set[G0] = 0;
d420 1
a420 1
	i->current_table = 0;	/* assume the first table is set initially */
d661 1
a661 1
    
d665 5
a669 1
static int iso2022_write_escapes(EncodingPriv *e, UCS4 u, char **ps, int *bufsize)
d675 11
d690 1
a690 1
	if (enc->current_table != 0)
d692 3
a694 1
	    ISO2022_EncoderSet *eset = &enc->table[0];
d696 6
a701 2
	    memcpy(buf + out, eset->esc_seq, eset->esc_seq_len);
	    out += eset->esc_seq_len;
d703 4
a706 1
	    enc->current_table = 0;
d712 1
a712 1
    
d714 6
d723 1
a723 2

	if (enc->current_table != tab)
d726 1
d730 14
a743 2
	    memcpy(buf + out, eset->esc_seq, eset->esc_seq_len);
	    out += eset->esc_seq_len;
d745 10
a754 1
	    enc->current_table = tab;
d762 1
a762 1
    
d765 7
d773 1
d779 4
a790 19
/* 7bit scheme. Escape sequences are used to switch different 1 or 2
 * byte character sets into 0x21-0x7E.
 */

EncodingPriv enc_iso2022_escapes =
{
    iso2022_read,
    iso2022_reset,
    sizeof (ISO2022_Encoding) - sizeof(EncodingPriv),
    iso2022_delete,
    0,
    iso2022_write_escapes
};


/* 7bit scheme. Two character sets are set up and SO and SI are used
 * to switch between them.
 */

d798 1
a798 1
    0
d811 1
a811 1
		
d820 1
a820 1
    
d871 1
a871 1
    
d883 1
a883 1
    
@


1.9
log
@Created new file riscos.c for RISC OS specific functions. Rest of
library should remain portable. Moved function to load a map file
into that new file. Added #defines for directory separator and
wild card characters and updated the various file names.

Version 0.33. Tagged as 'Unicode-0_33'
@
text
@d15 10
@


1.8
log
@Updated all the writers to ignore the NULL_UCS4 character (as had
been previously added to the iso2022_escapes case). Any new writers
should flush any pending characters they may have at this point.
Also udpated enc_UCS4.c and utf8.c to turn all illegal characeters
(top bit set) into FFFD.

Version 0.28. Tagged as 'Unicode-0_28'
@
text
@d234 1
a234 1
    sprintf(fname, "ISO2022.%s.%02X*", dir, id);
@


1.7
log
@Corrected iso2022_write_escapes() to reset table at end of line
and on a NULL_UCS4.

Version 0.20. Tagged as 'Unicode-0_20'
@
text
@d764 3
@


1.6
log
@ Fixed autojp state machine. It wasn't resetting 'state' to HAD_NONE after
changing whatcode. So basically it was lucky it ever worked. Also rewrote
the various range tests to only use one compare per case.
Changed the 'for_encoding' parameter to encoding_write() to an enumeration.
Added a new type of writing where if the character cannot be encoded then
the function returns -1 rather than writing a default character
Added the pseudo-charsets csAutodetectJP and csEUCorShiftJIS to the encoding
table so that they return the correct default language (ja).
Added function to remove unused encoding tables (must be called explicitly).
Fixed usage counting in iso2022 (I think).
When looking up encoding name try stripping 'x-' and 'X-' off the front i
can't find on first pass.

Version 0.12. Tagged as 'Unicode-0_12'
@
text
@d645 1
a645 1
    if (u < 0x0021)
d647 12
a658 1
	buf[out++] = u;
a687 8
    /* if this is a successful write then we can update any state */
    if (*bufsize >= out || !*ps)
    {
	/* clear table marker at a line break */
	if (u == 10 || u == 13)
	    enc->current_table = -1;
    }
	
@


1.5
log
@Fixed iso2202_write_escapes() (as used by JIS encoding) so that it actually works.
It also now assumes that the first write encoding is already set up.

Version 0.10. Tagged as 'Unicode-0_10'
@
text
@d238 10
d289 1
a289 1
    encoding__free(i->Set[setno]);
d303 6
a308 6
    encoding__free(i->Set[G0]);
    encoding__free(i->Set[G1]);
    encoding__free(i->Set[G2]);
    encoding__free(i->Set[G3]);
    encoding__free(i->Set[C0]);
    encoding__free(i->Set[C1]);
d345 1
a345 1
    if (for_encoding)
d362 5
a366 1
			i->table[tab].table = ((simple_set *)i->Set[G0])->table;
d388 1
a388 2
	    /* free the set used in G0 */
	    encoding__free(i->Set[G0]);
d670 3
d791 3
@


1.4
log
@Fixed when SS1 or SS2 followed by a set change by disallowing controlcharacters
after single shifts.
Made encoding_table_ptr and encoding_n_table_entries check for null tables.
moved 'Lm' type characters from marks to letters in mkunictype.

Version 0.08. Tagged as 'Unicode-0_08'
@
text
@d341 1
a341 1
	    const char *last_s = s;
d346 1
a346 1
		int c = *s++;
d350 11
a360 5
		    i->table[tab].table = ((simple_set *)i->Set[G0])->table;
		    i->table[tab].esc_seq = last_s;
		    i->table[tab].esc_seq_len = s - last_s;
		    tab++;

d370 2
d379 1
a379 1
	i->current_table = -1;
d571 1
a571 1
static int write_index(int index, char *out, int table_size)
d573 1
d582 1
a582 1
	*out++ = 0xA1 + index;
d586 1
a586 1
	*out++ = 0xA0 + index;
d594 2
a595 2
	out[0] = 0xA1 + c1;
	out[1] = 0xA1 + c2;
d640 1
a640 3
#if 0
 	fprintf(stderr, "iso2022_write_escapes: u %04x index %d table %d n_entries %d\n", u, index, tab, n_entries);
#endif
d646 2
d654 1
a654 1
	out += write_index(index, buf + out, n_entries);
d760 1
a760 1
	    out += write_index(index, buf+out, n_entries);
d765 1
a765 1
	    out += write_index(index, buf+out, n_entries);
d770 1
a770 1
	    out += write_index(index, buf+out, n_entries);
@


1.3
log
@Added new file 'languages.h' with some ISO639 language codes.
Added a default language field to each encoding (using above codes).
Added a max char size field to each encoding.
Tidied up some of the reencoders behaviour when output ptr NULL.
Fixed a load of charset numbers which were wrong.
New UTF8 function to skiop multiple characters in a string.
Fixed RISC OS build which was out of date.

Version 0.04. Tagged as 'Unicode-0_04'
@
text
@d243 2
d277 2
d491 10
a500 1
        if (i->esc_pending)
d502 1
a520 3
#ifdef DEBUG
/* 	    fprintf(stderr, "c: %02x GR %p next_code %p\n", c, i->GR, i->GR->next_code); */
#endif
a521 3
#ifdef DEBUG
/* 	    fprintf(stderr, "u: %04x\n", u); */
#endif
@


1.2
log
@Fixed encoding table so that modules builds will work.
Made all tables be on linked list to avoid static copies of pointers.
Removed redundant 8bit files.

Version 0.03. Tagged as 'Unicode-0_03'
@
text
@d653 1
a653 1
    if ((*bufsize -= out) < 0 || !*ps)
@


1.1
log
@Initial version checked in

Version 0.01. Not tagged
@
text
@d33 1
a33 1
    UCS2 *table;
d100 1
a100 1
    UCS2 *table;
d105 2
a106 2
static UCS2 *table94[0x3F], *table96[0x3F], *table128[0x3F], *table94x94[0x3F];
static UCS2 *tableC0[0x3F], *tableC1[0x3F];
d132 1
a132 1
        UCS4 u = ss->table[94*(*sync-1) + c-1];
d146 1
a146 1
        return ((simple_set *)s)->table[c-1]; /* -1 for 94 byte tables */
d156 1
a156 1
    return ((simple_set *)s)->table[c];
d203 1
a203 1
UCS2 *iso2022_find_table(int type, int id)
a204 1
    UCS2 **table;
d211 1
a211 1
          table = tableC0 + id - 0x40;
d215 1
a215 1
          table = tableC1 + id - 0x40;
d219 1
a219 1
          table = table94 + id - 0x40;
d223 1
a223 1
          table = table96 + id - 0x40;
d227 1
a227 1
          table = table94x94 + id - 0x40;
d234 2
a235 7
    if (!*table)
    {
        sprintf(fname, "ISO2022.%s.%02X*", dir, id);
        *table = encoding_load_map_file(fname);
    }

    return *table;
d240 1
a240 1
    UCS2 *t;
d593 1
a593 2
	UCS2 *table = enc->table[tab].table;
	int n_entries = encoding_n_table_entries(table);
d595 1
a595 1
	if ((i = encoding_lookup_in_table(u, table, n_entries)) != -1)
d599 1
a599 1
	    *size = n_entries;
a700 1
	int n_entries = encoding_n_table_entries(setptr->table);
d704 1
a704 1
	if ((i = encoding_lookup_in_table(u, setptr->table, n_entries)) != -1)
d708 1
a708 1
	    *size = n_entries;
@

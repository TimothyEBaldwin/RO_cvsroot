head	1.9;
access;
symbols
	Unicode-0_63:1.9
	Unicode-0_62:1.9
	Unicode-0_61:1.9
	Unicode-0_60:1.9
	Unicode-0_59:1.8
	Unicode-0_58:1.8
	Unicode-0_57:1.8
	Unicode-0_56:1.8
	Unicode-0_55:1.8
	Unicode-0_54:1.8
	RO_5_07:1.8
	Unicode-0_53:1.8
	Unicode-0_52:1.8
	Unicode-0_51:1.8
	Unicode-0_50:1.8
	Unicode-0_49:1.8
	Unicode-0_48:1.8
	Unicode-0_47:1.8
	Unicode-0_46:1.7
	Unicode-0_45:1.6
	dellis_autobuild_BaseSW:1.5
	sbrodie_sedwards_16Mar2000:1.5
	Unicode-0_44:1.5
	dcotton_autobuild_BaseSW:1.7
	Unicode-0_43:1.4
	Unicode-0_42:1.3
	Unicode-0_41:1.2
	Unicode-0_40:1.1
	Unicode-0_39:1.1
	Unicode-0_38:1.1
	Unicode-0_37:1.1
	Unicode-0_36:1.1
	Unicode-0_35:1.1
	Unicode-0_34:1.1;
locks; strict;
comment	@# @;


1.9
date	2013.01.06.22.32.08;	author jbell;	state Exp;
branches;
next	1.8;
commitid	mXR1bDbpHeiotczw;

1.8
date	2002.06.10.15.08.35;	author sbrodie;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.13.10.38.05;	author jberanek;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.05.14.46.35;	author jberanek;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.13.17.03.08;	author kbracey;	state Exp;
branches;
next	1.4;

1.4
date	99.09.16.14.24.24;	author kbracey;	state Exp;
branches;
next	1.3;

1.3
date	99.09.14.16.39.43;	author kbracey;	state Exp;
branches;
next	1.2;

1.2
date	99.09.13.09.55.44;	author kbracey;	state Exp;
branches;
next	1.1;

1.1
date	99.03.11.17.01.16;	author kbracey;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Add encoding_read_in_multibyte_sequence API.
Detail:
  The new API allows the client to determine if a read codec has run
  out of input in the middle of a multibyte sequence. This permits a
  client to distinguish between the two cases in which no output
  character is generated:

    a) insufficient input has been provided to complete an output character
    b) the input consisted of a complete multibyte sequence which generates
       no output (e.g. an ISO-2022 shift sequence)
Admin:
  Tested using Iconv.


Version 0.60. Tagged as 'Unicode-0_60'
@
text
@/* Copyright 1999 Element 14 Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* > enc_scsu.c */

/**************************************************************************/
/*                                                                        */
/* Copyright [1997-2000] Pace Micro Technology PLC.  All rights reserved. */
/*                                                                        */
/* The copyright in this material is owned by Pace Micro Technology PLC   */
/* ("Pace").  This material is regarded as a highly confidential trade    */
/* secret of Pace.  It may not be reproduced, used, sold or in any        */
/* other way exploited or transferred to any third party without the      */
/* prior written permission of Pace.                                      */
/**************************************************************************/

#include <stdlib.h>
#include <limits.h>

#include "iso10646.h"

#include "encpriv.h"

#include "enc_scsu.h"

/* #define DEBUG_SCSU_COMPRESSION
#define DEBUG_LEARNING */

#ifdef DEBUG_SCSU_COMPRESSION
#include <stdio.h>
#endif

/*
 * Routines for encoding SCSU (Standard Compression Scheme for Unicode)
 * Number: ???
 * Names: x-SCSU
 */

/* Single Mode Tag Values */
#define SQ0 0x01
#define SQ1 0x02
#define SQ2 0x03
#define SQ3 0x04
#define SQ4 0x05
#define SQ5 0x06
#define SQ6 0x07
#define SQ7 0x08
#define SDX 0x0B
#define SQU 0x0E
#define SCU 0x0F
#define SC0 0x10
#define SC1 0x11
#define SC2 0x12
#define SC3 0x13
#define SC4 0x14
#define SC5 0x15
#define SC6 0x16
#define SC7 0x17
#define SD0 0x18
#define SD1 0x19
#define SD2 0x1A
#define SD3 0x1B
#define SD4 0x1C
#define SD5 0x1D
#define SD6 0x1E
#define SD7 0x1F
#define IS_SINGLE_LITERAL(c) ((c)==0 || (c)==0x09 || (c)==0x0A || \
                              (c)==0x0D || ((c)>=0x20 && (c)<=0x7F))

/* Unicode Mode Tag Values */
#define UC0 0xE0
#define UC1 0xE1
#define UC2 0xE2
#define UC3 0xE3
#define UC4 0xE4
#define UC5 0xE5
#define UC6 0xE6
#define UC7 0xE7
#define UD0 0xE8
#define UD1 0xE9
#define UD2 0xEA
#define UD3 0xEB
#define UD4 0xEC
#define UD5 0xED
#define UD6 0xEE
#define UD7 0xEF
#define UQU 0xF0
#define UDX 0xF1
#define IS_UNICODE_LITERAL(c) ((c)<0xE0 || (c)>=0xF3)

static const UCS2 static_window[8] =
{
    0x0000,     /* C0 controls */
    0x0080,     /* Latin-1 Supplement */
    0x0100,     /* Latin Extended-A */
    0x0300,     /* Combining Diacritical Marks */
    0x2000,     /* General Punctuation */
    0x2080,     /* Currency Symbols */
    0x2100,     /* Letterlike Symbols and Number Forms */
    0x3000      /* CJK Symbols & Punctuation */
};

static const unsigned char default_dynamic_window[8] =
{
    0x01,       /* 0080: Latin-1 */
    0xF9,       /* 00C0: Latin-1 letters + half of Extended-A */
    0x08,       /* 0400: Cyrillic */
    0x0C,       /* 0600: Arabic */
    0x12,       /* 0900: Devanagari */
    0xFD,       /* 3040: Hiragana */
    0xFE,       /* 30A0: Katakana */
    0xA6        /* FF00: Fullwidth ASCII */
};

/*
 * A guess at which default windows we're most likely to use.
 * From the most likely first: Latin-1 Supplement, Latin-1/Latin Ext-A, Cyrillic, Hiragana,
 * Katakana, Fullwidth ASCII, Arabic, Devanagari.
 */
static const char default_window_usage[8] =
{
    7, 6, 5, 1, 0, 4, 3, 2
};

/*
 * The special window offsets.
 */
static const UCS2 special_offset[7] =
{
    0x00C0,     /* Latin-1 letters + half of Extended-A */
    0x0250,     /* IPA Extensions */
    0x0370,     /* Greek */
    0x0530,     /* Armenian */
    0x3040,     /* Hiragana */
    0x30A0,     /* Katakana */
    0xFF60      /* Halfwidth Katakana */
};

#define SPECIAL_OFFSET_BASE 0xF9

static UCS4 window_offset(unsigned char x)
{
    if (x >= 0x01 && x <= 0x67)
        return x * 0x80;
    else if (x >= 0x68 && x <= 0xA7)
        return x * 0x80 + 0xAC00;
    else if (x >= SPECIAL_OFFSET_BASE)
        return special_offset[x - SPECIAL_OFFSET_BASE];
    else
        return 0xF0000; /* For lack of anything better to do */
}

static int default_lock_to(unsigned char x)
{
    /*
     * 256 bits, giving the default state for the lock_to flag for each possible
     * window position. This is set to 1 for the following windows:
     * 0080-0200, 0380-1100, 1200-1D80, 2800-2880, 3080-3180, E000-F880,
     * 00C0, 0250, 0370, 0530, 3040, 30A0, FF60, plus the
     * "reserved for future use" windows.
     */
    static const unsigned long bits[8] =
    {
        0xFFFFFF9E, /* 01111001111111111111111111111111   0080-0200, 0380-0F80        */
        0x0FFFFFF7, /* 11101111111111111111111111110000   1000-1100, 1200-1D80        */
        0x00030000, /* 00000000000000001100000000000000   2800-2880                   */
        0xFFFFFF0E, /* 01110000111111111111111111111111   3080-3180, E000-EB80        */
        0x03FFFFFF, /* 11111111111111111111111111000000   EC00-F880                   */
        0xFFFFFF00, /* 00000000111111111111111111111111   reserved (A8-BF)            */
        0xFFFFFFFF, /* 11111111111111111111111111111111   reserved (C0-DF)            */
        0xFFFFFFFF  /* 11111111111111111111111111111111   reserved (E0-F8) + specials */
    };

    return (int)(bits[x >> 5] >> (x & 0x1F)) & 1;
}

typedef enum SCSU_State
{
    SingleByte,
    DefiningWindow,
    DefiningExtendedWindow,
    DefiningExtendedWindowLSB,
    QuotingWindow,
    QuotingUnicode,
    QuotingUnicodeLSB,
    Unicode,
    UnicodeLSB,
    UnicodeQuoting
} SCSU_State;

typedef struct SCSU_Encoding
{
    EncodingPriv e;
    UCS4 dynamic_window[8];
    SCSU_State state;
    UCS4 window_base;
    unsigned char msb;
    char window_no;
    UCS2 surrogate;
    /* For writing only */
    unsigned int count;
    unsigned int window_last_used[8];
    UCS4 next;
    char lock_to[8];
    char learning_from, learning_to, is_first;
} SCSU_Encoding;

static int scsu_reset(Encoding *e, int for_encoding)
{
    SCSU_Encoding *se = (SCSU_Encoding *) e;
    int i;

    for (i=0; i<8; i++)
        se->dynamic_window[i] = window_offset(default_dynamic_window[i]);

    se->window_base = se->dynamic_window[0];
    se->surrogate = 0;
    se->state = SingleByte;
    se->window_no = 0;

    if (for_encoding != encoding_READ)
    {
        se->count = 8;

        se->next = NULL_UCS4;

        se->learning_from = 8;

        se->is_first = 1;

        for (i=0; i<8; i++)
        {
            se->window_last_used[i] = default_window_usage[i];
            /* Of the default dynamic windows, I reckon all are good to lock to
             * when there is no clear other reason, except window 7 (Fullwidth ASCII).
             */
            se->lock_to[i] = default_lock_to(default_dynamic_window[i]);
        }
    }

    return 1;
}

static unsigned int scsu_read(Encoding *e,
			      encoding_read_callback_fn ucs_out,
                              const unsigned char *s,
                              unsigned int n,
                              void *handle)
{
    SCSU_Encoding *se = (SCSU_Encoding *) e;
    unsigned int count;

    for (count = n; count; count--)
    {
        unsigned char c = *s++;
        UCS4 u;

        switch (se->state)
        {
        case SingleByte:
            switch (c)
            {
            case SQU:
                se->state = QuotingUnicode;
                continue;
            case SCU:
                se->state = Unicode;
                continue;
            case SQ0: case SQ1: case SQ2: case SQ3:
            case SQ4: case SQ5: case SQ6: case SQ7:
                se->state = QuotingWindow;
                se->window_no = c - SQ0;
                continue;
            case SC0: case SC1: case SC2: case SC3:
            case SC4: case SC5: case SC6: case SC7:
                se->window_base = se->dynamic_window[c - SC0];
                continue;
            case SD0: case SD1: case SD2: case SD3:
            case SD4: case SD5: case SD6: case SD7:
                se->state = DefiningWindow;
                se->window_no = c - SD0;
                continue;
            case SDX:
                se->state = DefiningExtendedWindow;
                continue;
            case 0x0C: /* reserved */
                u = 0xFFFD;
                break;
            default:
                if (c < 0x80)
                    u = c;
                else
                    u = se->window_base + c - 0x80;
                break;
            }
            break;

        case Unicode:
            switch (c)
            {
            case UQU:
                se->state = UnicodeQuoting;
                continue;
            case UC0: case UC1: case UC2: case UC3:
            case UC4: case UC5: case UC6: case UC7:
                se->state = SingleByte;
                se->window_base = se->dynamic_window[c - UC0];
                continue;
            case UD0: case UD1: case UD2: case UD3:
            case UD4: case UD5: case UD6: case UD7:
                se->state = DefiningWindow;
                se->window_no = c - UD0;
                continue;
            case UDX:
                se->state = DefiningExtendedWindow;
                continue;
            case 0xF2: /* reserved */
                u = 0xFFFD;
                break;
            default:
                se->state = UnicodeLSB;
                se->msb = c;
                continue;
            }
            break;

        case UnicodeLSB:
            se->state = Unicode;
            u = (se->msb << 8) | c;
            break;

        case UnicodeQuoting:
            se->state = UnicodeLSB;
            se->msb = c;
            continue;

        case QuotingUnicode:
            se->state = QuotingUnicodeLSB;
            se->msb = c;
            continue;

        case QuotingUnicodeLSB:
            se->state = SingleByte;
            u = (se->msb << 8) | c;
            break;

        case DefiningWindow:
            se->state = SingleByte;
            se->window_base = se->dynamic_window[(unsigned int)se->window_no]
                            = window_offset(c);
            continue;

        case DefiningExtendedWindow:
            se->state = DefiningExtendedWindowLSB;
            se->msb = c;
            continue;

        case DefiningExtendedWindowLSB:
            se->state = SingleByte;
            se->window_base = se->dynamic_window[se->msb >> 5]
                            = 0x10000 + (((se->msb & 0x1F) << 8) | c) * 0x80;
            continue;

        case QuotingWindow:
            se->state = SingleByte;
            if (c < 0x80)
                u = static_window[(unsigned int)se->window_no] + c;
            else
                u = se->dynamic_window[(unsigned int)se->window_no] + c - 0x80;
            break;

        default: /* Should never happen */
            se->state = SingleByte;
            u = 0xFFFD;
            break;
        }

        if (se->surrogate)
        {
            if (u < 0xDC00 || u >= 0xE000)
                u = 0xFFFD;
            else
                u = 0x10000 + ((se->surrogate - 0xD800) << 10)
                            + u - 0xDC00;
            se->surrogate = 0;
        }
        else if (u >= 0xD800 && u < 0xDC00)
        {
            se->surrogate = u;
            continue;
        }
        else if (u >= 0xDC00 && u < 0xE000)
            u = 0xFFFD;

        if (ucs_out)
            if (ucs_out(handle, u))
            {
                /* Character has been used, so ensure its counted */
                count--;
                break;
            }
    }

    return n - count;
}

static int scsu_read_in_multibyte_sequence(EncodingPriv *e)
{
    SCSU_Encoding *se = (SCSU_Encoding *) e;

    return (se->state != SingleByte && se->state != Unicode) || se->surrogate;
}

/*
 * What window offset should I use for this character?
 * Returns 0 if not accessible via a standard window.
 */
static int window_offset_for_character(UCS4 u)
{
    /*
     * We'll try the special offsets first - if they exist, it's
     * probably because they're better than the standard offsets
     */

    unsigned int i;

    for (i=SPECIAL_OFFSET_BASE; i<0x100u; i++)
        if (u - special_offset[i - SPECIAL_OFFSET_BASE] < 0x80u)
            return i;

    if (u >= 0x0080u && u < 0x3400u)
        return u / 0x80u;
    else if (u >= 0xE000u && u < 0x10000u)
        return (u - 0xAC00u) / 0x80u;
    else
        return 0;
}

/*
 * Find a dynamic window containing character (-1 if none)
 */
static int find_dynamic_window(SCSU_Encoding *se, UCS4 u)
{
    int i, n = -1;
    unsigned int l = 0;

    /* Use the most recently used window, if there is more than one
     * possibility.
     */

    for (i=0; i<8; i++)
        if (u - se->dynamic_window[i] < 0x80u && se->window_last_used[i] >= l)
            l = se->window_last_used[n = i];

    return n;
}

/*
 * Find a dynamic window containing characters "u" and "next". If not
 * possible, one containing the "u" (-1 if none)
 */
static int find_dynamic_window_with_next(SCSU_Encoding *se, UCS4 u, UCS4 next)
{
    int i, l = 0, n = -1;

    /* Use the most recently used window, if there is more than one
     * possibility.
     */

    for (i=0; i<8; i++)
        if (u - se->dynamic_window[i] < 0x80u)
        {
            int priority = se->window_last_used[i];
            if (next - se->dynamic_window[i] < 0x80u) priority += 0x100000;

            if (priority >= l)
                l = priority, n = i;
        }

    return n;
}

/* Find a static window containing "u" */
static int find_static_window(UCS4 u)
{
    int i;

    for (i=0; i<8; i++)
        if (u - static_window[i] < 0x80u)
            return i;

    return -1;
}

/* Find least recently used window */
static int lru_window(SCSU_Encoding *se)
{
    int i, n = 0;
    unsigned int *w = se->window_last_used, l = INT_MAX;

    for (i=0; i<8; i++)
        if (w[i] < l)
            l = w[n = i];

    return n;
}

/*
 * Is character "u" one of the window-independent ASCII/control
 * characters?
 */
static int is_valid_ascii(UCS4 u)
{
    return u < 0x0080 &&
            (u >= 0x0020 || u == 0x0000 || u == 0x0009 || u == 0x000A || u == 0x000D);
}

/*
 * Is character "u" expressible as a single byte if the current
 * window is "window"?
 */
static int is_single_byte(SCSU_Encoding *se, UCS4 u, int window)
{
    return is_valid_ascii(u) || u - se->dynamic_window[window] < 0x80u;
}

static int output(int c, unsigned char **out, int *outsize)
{
    if ((*outsize)-- > 0)
    {
        *(*out)++ = c;
        return 1;
    }
    else
        return 0;
}

/*
 * This compressor is an attempt to be optimal, given one character
 * look-ahead. We use a LRU-replacement strategy for windows.
 *
 * Uses the same members of SCSU_Encoding as reading, but we only use
 * states SingleByte and Unicode.
 */
static int scsu_write(EncodingPriv *e, UCS4 u, unsigned char **buf, int *bufsize)
{
    SCSU_Encoding *se = (SCSU_Encoding *) e;
    SCSU_State state = se->state;
    int window_no = se->window_no;
    int ok = 0;
    int w;
    UCS4 next;

    #define OUTPUT(c) output(c, buf, bufsize)

    if (u == NULL_UCS4) /* Flush */
    {
        #ifdef DEBUG_SCSU_COMPRESSION
        fprintf(stderr, "Flush\n");
        #endif
    }
    else
    {
        /* Knock out illegal characters immediately */
        if (u >= 0x110000 || (u >= 0xD800 && u < 0xE000))
        {
            if (se->e.for_encoding == encoding_WRITE_STRICT)
                return -1;
            else
                u = 0xFFFD;
        }
    }

    /* Put this character into "next", then process the existing "next" */
    next = u;
    u = se->next;

    /*
     * At this point, "next" is the next character (which the caller passed in)
     * and se->next = u is the character we're processing. If we can't output
     * the character, we will leave se->next unchanged so that when the caller
     * calls us again with "next", we will end up in the same place.
     *
     * BE AWARE THAT "next" COULD BE NULL_UCS4, INDICATING END OF STREAM
     */

    if (u == NULL_UCS4)
    {
        se->next = next;
        return 0;
    }

    #ifdef DEBUG_SCSU_COMPRESSION
    fprintf(stderr, "%08X: ", u);
    #endif

    /* Special rule for byte-order mark (introduced in revision 3.1) - always
     * output using SQU.
     */
    if (u == 0xFEFF && se->is_first)
        goto output_squ;

    /* Is it ASCII or a permitted control code? */
    if (is_valid_ascii(u))
    {
        if (state == Unicode)
        {
            /* Only switch to single byte if the next character is
             * expressible as a single byte. If that next character is
             * ASCII, switch to the previous window, otherwise to the
             * window the next character requires.
             */

            w = window_no;
            if (is_valid_ascii(next) || (w = find_dynamic_window(se, next)) >= 0)
            {
                state = SingleByte;
                window_no = w;
                OUTPUT(UC0 + w);
                #ifdef DEBUG_SCSU_COMPRESSION
                fprintf(stderr, "UC%d ", window_no);
                #endif
            }
            else
                goto output_unicode;
        }
        ok = OUTPUT(u);
        #ifdef DEBUG_SCSU_COMPRESSION
        fprintf(stderr, "%02X\n", u);
        #endif
    }
    /* Is it in our current window? */
    else if (state == SingleByte && u - se->dynamic_window[window_no] < 0x80u)
    {
        if (se->learning_from < 8)
        {
            #ifdef DEBUG_LEARNING
            {
                int old = se->lock_to[(unsigned int)se->learning_to];
                int new = (se->learning_to == window_no);
                fprintf(stderr, "{locking to %d is %s%s} ", se->learning_to, new != old ? "now " : "", new ? "good" : "bad");
            }
            #endif
            se->lock_to[(unsigned int)se->learning_to] = (se->learning_to == window_no);

            se->learning_from = 8;
        }

        ok = OUTPUT(0x80u + u - se->dynamic_window[window_no]);
        if (ok)
            se->window_last_used[window_no] = se->count++;

        #ifdef DEBUG_SCSU_COMPRESSION
        fprintf(stderr, "%02X\n", 0x80u + u - se->dynamic_window[window_no]);
        #endif
    }
    /* Is it in one of our dynamic windows? */
    else if ((w = find_dynamic_window_with_next(se, u, next)) >= 0)
    {
        if (state == Unicode)
        {
            /* When's it worthwhile to switch? When the following character
             * is a single byte, I reckon. */
            if (is_single_byte(se, next, w))
            {
                window_no = w;
                state = SingleByte;
                OUTPUT(UC0 + w);
                #ifdef DEBUG_SCSU_COMPRESSION
                fprintf(stderr, "UC%d ", w);
                #endif
            }
            else
                goto output_unicode;
        }
        else
        {
            int lock;

            if (se->learning_from < 8)
            {
                if (se->learning_from == w)
                {
                    #ifdef DEBUG_LEARNING
                    fprintf(stderr, "{locking to %d is %sbad} ", se->learning_to, se->lock_to[se->learning_to] != 0 ? "now ": "");
                    #endif
                    se->lock_to[(unsigned int)se->learning_to] = 0;  /* Shouldn't have switched */
                }
                else if (se->learning_to == w)
                {
                    #ifdef DEBUG_LEARNING
                    fprintf(stderr, "{locking to %d is %sgood} ", se->learning_to, se->lock_to[se->learning_to] != 1 ? "now ": "");
                    #endif
                    se->lock_to[(unsigned int)se->learning_to] = 1;  /* Should have switched */
                }

                se->learning_from = 8;
            }

            /*
             * We'll do a locking shift if the next character is in the
             * new window. We'll do a single shift if the next character
             * is in the current window, but not the new one.
             * In the remaining cases (ie next character not in either new
             * or current window, including ASCII), we have a learning
             * function.
             */

            if (next - se->dynamic_window[w] < 0x80)
                lock = 1;
            else if (next - se->dynamic_window[window_no] < 0x80)
                lock = 0;
            else
            {
                lock = se->lock_to[w];
                se->learning_from = window_no;
                se->learning_to = w;
                #ifdef DEBUG_LEARNING
                fprintf(stderr, "{%s to %d} ", lock ? "locking" : "not locking", w);
                #endif
            }

            if (lock)
            {
                window_no = w;
                OUTPUT(SC0 + w);
                #ifdef DEBUG_SCSU_COMPRESSION
                fprintf(stderr, "SC%d ", w);
                #endif
            }
            else
            {
                /* We're doing a single shift. I reckon that if we're only
                 * using a dynamic window for single shifts, and there's a
                 * static window that could do the same job, we might as well
                 * use that, leaving the dynamic window free to be replaced.
                 */
                int temp;
                if ((temp = find_static_window(u)) >= 0)
                {
                    w = temp;
                    goto output_static_quote;
                }
                OUTPUT(SQ0 + w);
                #ifdef DEBUG_SCSU_COMPRESSION
                fprintf(stderr, "SQ%d ", w);
                #endif
            }
        }

        #ifdef DEBUG_SCSU_COMPRESSION
        fprintf(stderr, "%02X\n", 0x80u + u - se->dynamic_window[w]);
        #endif
        ok = OUTPUT(0x80u + u - se->dynamic_window[w]);
        if (ok)
            se->window_last_used[w] = se->count++;
    }
    /* If in single-byte mode, is it in one of the static windows? */
    else if (state == SingleByte && (w = find_static_window(u)) >= 0)
    {
        int temp;

        if (!is_single_byte(se, next, window_no) &&
            (temp = window_offset_for_character(u)) != 0 &&
            window_offset_for_character(next) == temp)
        {
            /* The next character becomes 1 byte if we instead define
             * a dynamic window for this character. Probably a good
             * cue to do so.
             */
            w = temp;
            goto define_window;
        }

      output_static_quote:

        #ifdef DEBUG_SCSU_COMPRESSION
        fprintf(stderr, "SQ%d %02X\n", w, u - static_window[w]);
        #endif
        OUTPUT(SQ0 + w);
        ok = OUTPUT(u - static_window[w]);
    }
    /* Can we define a window to cover this character? (Don't bother
       if it's in a static window, which may be the case if in
       Unicode mode) */
    else if ((w = window_offset_for_character(u)) != 0
              && find_static_window(u) == -1)
    {
        UCS4 base;
        int temp;

        if (state == Unicode)
        {
            /* Don't bother if the next character can't be expressed
             * as a single byte after the define (ie the UDn + char + next
             * = 4 bytes, the same as staying in Unicode).
             */
            if (!is_valid_ascii(next)                           /* Not valid ASCII / ctrl */
                && next - window_offset((unsigned char)w) >= 0x80u)            /* Not in new window */
            {
                goto output_unicode;
            }
        }

      define_window:

        se->learning_from = 8;

        /* Make sure we don't splat the window we're going to need
         * for the next character
         */
        if ((temp = find_dynamic_window(se, next)) >= 0)
            se->window_last_used[temp] = se->count+1;

        window_no = lru_window(se);

        if (state == Unicode)
        {
            state = SingleByte;
            OUTPUT(UD0 + window_no);
            #ifdef DEBUG_SCSU_COMPRESSION
            fprintf(stderr, "UD%d ", window_no);
            #endif
        }
        else
        {
            OUTPUT(SD0 + window_no);
            #ifdef DEBUG_SCSU_COMPRESSION
            fprintf(stderr, "SD%d ", window_no);
            #endif
        }

        OUTPUT(w);

        base = window_offset((unsigned char)w);

        #ifdef DEBUG_SCSU_COMPRESSION
        fprintf(stderr, "%02X %02X     [Window %d = %04X]\n",
                       w, 0x80u + u - base, window_no, base);
        #endif

        ok = OUTPUT(0x80u + u - base);
        if (ok)
        {
            /*
             * If next character is neither in this window, nor the
             * previous one, set up the learning variables.
             */
            if (se->state == SingleByte &&
                !(next - base < 0x80) &&
                !(next - se->dynamic_window[(unsigned int)se->window_no] < 0x80))
            {
                se->learning_from = se->window_no;
                se->learning_to = window_no;
            }
            se->lock_to[window_no] = default_lock_to((unsigned char)w);
            se->dynamic_window[window_no] = base;
            se->window_last_used[window_no] = se->count++;
        }
    }
    /* Is it in the BMP? */
    else if (u < 0x10000)
    {
      output_unicode:

        if (u >= 0xE000 && u < 0xF300)
        {
            if (state == Unicode)
            {
                #ifdef DEBUG_SCSU_COMPRESSION
                fprintf(stderr, "UQU ");
                #endif
                OUTPUT(UQU);
            }
            else
            {
                /* Logically, can't happen, as we would have defined
                   a window to cover it. But you never know... */
              output_squ:
                #ifdef DEBUG_SCSU_COMPRESSION
                fprintf(stderr, "SQU ");
                #endif
                OUTPUT(SQU);
            }
        }
        else
        {
            if (state == SingleByte)
            {
                if (is_single_byte(se, next, window_no))
                {
                    if (se->learning_from < 8 && next >= 0x80u) /* Single byte because our guessed window is correct... */
                    {
                        #ifdef DEBUG_LEARNING
                        {
                            int old = se->lock_to[(unsigned int)se->learning_to];
                            int new = (se->learning_to == window_no);
                            fprintf(stderr, "{locking to %d is %s%s} ", se->learning_to, new != old ? "now " : "", new ? "good" : "bad");
                        }
                        #endif
                        se->lock_to[(unsigned int)se->learning_to] = (se->learning_to == window_no);
                    }
                    #ifdef DEBUG_SCSU_COMPRESSION
                    fprintf(stderr, "SQU ");
                    #endif
                    OUTPUT(SQU);
                }
                else
                {
                    if (se->learning_from < 8)
                    {
                        if (next - se->dynamic_window[(unsigned int)se->learning_from] < 0x80)
                        {
                            #ifdef DEBUG_LEARNING
                            fprintf(stderr, "{locking to %d is %sbad} ", se->learning_to, se->lock_to[se->learning_to] != 0 ? "now " : "");
                            #endif
                            se->lock_to[(unsigned int)se->learning_to] = 0; /* Shouldn't have locked */
                        }
                        else if (next - se->dynamic_window[(unsigned int)se->learning_to] < 0x80)
                        {
                            #ifdef DEBUG_LEARNING
                            fprintf(stderr, "{locking to %d is %sgood} ", se->learning_to, se->lock_to[se->learning_to] != 1 ? "now " : "");
                            #endif
                            se->lock_to[(unsigned int)se->learning_to] = 1; /* Should have locked */
                        }
                    }
                    state = Unicode;
                    #ifdef DEBUG_SCSU_COMPRESSION
                    fprintf(stderr, "SCU ");
                    #endif
                    OUTPUT(SCU);
                }
            }
        }
        se->learning_from = 8;
        #ifdef DEBUG_SCSU_COMPRESSION
        fprintf(stderr, "%02X %02X\n", u >> 8, u & 0xFF);
        #endif
        OUTPUT(u >> 8);
        ok = OUTPUT(u & 0xFF);
    }
    /* Is it in the SIP? */
    else if (u >= 0x20000 && u < 0x30000)
    {
        /* It's in the Supplementary Plane for CJK Unified Ideographs. We'll
         * assume it's a bad thing to create a window, as these will tend to
         * be sparse. However, if we're in single-byte mode, getting in and
         * out of Unicode mode is so expensive that we might as well define
         * a window - even if it ends up never being reused, redefining it
         * again ends up at less cost as not defining it in the first
         * place. ("SDX nn nn cc SDn cc" vs "SCU hh hh ll ll UCn cc")
         *
         * So, we'll define a window unless either we are in Unicode mode,
         * or we have to switch into Unicode for the next character anyway.
         *
         * If we do come across one of these isolated in single-byte mode,
         * it's probably as part of some sort of code chart, in which case
         * window defining might be the right thing to do anyway.
         *
         * Exception: if the next character is in the same window as this
         * one, we will define the window, even if in Unicode mode.
         */
        UCS4 h, l;

        /* Is the next character in the same window? Or alternatively, are
         * we in single-byte mode, and we don't have to switch to Unicode
         * for the next character?
         */
        if ((u &~ 0x7F) == (next &~ 0x7F) ||
            (state == SingleByte && (next < 0x80 || window_offset_for_character(next))))
            goto define_extended_window;

        if (state == SingleByte)
        {
            /* Always do it as "SCU hh hh ll ll" rather than "SQU hh hh SQU ll ll" -
             * we can stay in Unicode, or get a choice of any window for the same
             * price as the pair of SQUs.
             */
            state = Unicode;
            #ifdef DEBUG_SCSU_COMPRESSION
            fprintf(stderr, "SCU ");
            #endif
            OUTPUT(SCU);
        }

        h = 0xD800 + ((u - 0x10000) >> 10);
        l = 0xDC00 + (u & 0x3FF);

        se->learning_from = 8;
        #ifdef DEBUG_SCSU_COMPRESSION
        fprintf(stderr, "%02X %02X %02X %02X\n", h >> 8, h & 0xFF, l >> 8, l & 0xFF);
        #endif
        OUTPUT(h >> 8);
        OUTPUT(h & 0xFF);
        OUTPUT(l >> 8);
        ok = OUTPUT(l & 0xFF);
    }
    else /* u >= 0x10000 && u < 0x110000 && not in any window && not in SIP */
    {
        /* We'll always do it by defining a window. This takes
         * 4 bytes, regardless of current mode. With 1 look-ahead,
         * we're assuming that putting it into a window is a
         * Good Thing.
         */

        UCS4 base;

      define_extended_window:

        se->learning_from = 8;

        if (state == Unicode)
        {
            state = SingleByte;
            #ifdef DEBUG_SCSU_COMPRESSION
            fprintf(stderr, "UDX ");
            #endif
            OUTPUT(UDX);
        }
        else
        {
            #ifdef DEBUG_SCSU_COMPRESSION
            fprintf(stderr, "SDX ");
            #endif
            OUTPUT(SDX);
        }

        window_no = lru_window(se);

        base = u &~ 0x7F;

        #ifdef DEBUG_SCSU_COMPRESSION
        fprintf(stderr, "%02X %02X %02X  [Window %d = %08X]\n",
                        (window_no << 5) | ((base - 0x10000) >> 15),
                        ((base - 0x10000) >> 7) & 0xFF,
                        0x80u + u - base,
                        window_no,
                        base);
        #endif
        OUTPUT((window_no << 5) | ((base - 0x10000) >> 15));
        OUTPUT(((base - 0x10000) >> 7) & 0xFF);

        ok = OUTPUT(0x80u + u - base);
        if (ok)
        {
            if (se->state == SingleByte &&
                !(next - base < 0x80) &&
                !(next - se->dynamic_window[(unsigned int)se->window_no]))
            {
                se->learning_from = se->window_no;
                se->learning_to = window_no;
            }
            se->lock_to[window_no] = 0; /* Assume we don't lock to extended windows */
            se->dynamic_window[window_no] = base;
            se->window_last_used[window_no] = se->count++;
        }
    }

    if (ok)
    {
        se->window_no = window_no;
        se->state = state;
        se->next = next;
        se->is_first = 0;
    }

    return ok;
}

EncodingPriv enc_scsu =
{
    scsu_read,
    scsu_read_in_multibyte_sequence,
    scsu_reset,
    sizeof(SCSU_Encoding) - sizeof(EncodingPriv),
    0, /* scsu_delete */
    0,
    scsu_write,
    0,
    0,
    0
};
@


1.8
log
@  Merge of bug fixes from NCBrowser tree.
Detail:
  Buffer overrun fixed; some buffer counting problems fixed too.  There is
    now helpful initialisation and tidyup routines you can call too (called
    encoding_initialise and encoding_tidyup)
Admin:
  I've built this with cc 5.45 in basic build environment - it built OK.
  This source code now matches that in NCBrowser 5.28.


Version 0.47. Tagged as 'Unicode-0_47'
@
text
@d418 7
d1084 1
@


1.7
log
@  More syncronisation with Unicode lib in branched tree
Detail:
  Added some changes from Unicode lib in branched tree.  All basically
   type changes.  This appears to be because other compilers are
   more picky about types than armcc.

Admin:
  Will add 0.46 VersionNum file into branched tree, and all will be
   syncronised fully.


Version 0.46. Tagged as 'Unicode-0_46'
@
text
@d408 3
d412 1
@


1.6
log
@  Copyright message changes + changes from branch + Unified
   branched/non-branched builds
Detail:
  Copyright messages changed from E-14 to Pace throughout, filename
   placed at top of file throughout, instead of in just some files.

  Merged branch's fixes into our code base, plus made it possible to
   get nice debug output in branched tree, and vfprintf() to stderr in
   RISC OS tree.  Exactly same source used in branched tree now (apart
   from OS specific files riscos.c and unix.c moving into layers
   directory structure).

Admin:
  Built for branched, both Unix and RISC OS.
  Built in RISC OS tree, and compiled into TextConv.


Version 0.45. Tagged as 'Unicode-0_45'
@
text
@d257 1
a257 1
                              const char *s,
d527 1
a527 1
static int output(int c, char **out, int *outsize)
d545 1
a545 1
static int scsu_write(EncodingPriv *e, UCS4 u, char **buf, int *bufsize)
d799 1
a799 1
                && next - window_offset(w) >= 0x80u)            /* Not in new window */
d835 1
a835 1
        base = window_offset(w);
d856 1
a856 1
            se->lock_to[window_no] = default_lock_to(w);
@


1.5
log
@Minor change to SCSU encoder. If someone feeds us a byte-order mark (U+FEFF)
as the first character of a stream, we encode it as SQU FE FF. This is
recommended by revision 3.1 of Unicode Technical Report #6.

Version 0.44. Tagged as 'Unicode-0_44'
@
text
@d15 12
a26 9
/************************************************************************/
/*                  Copyright 1997-1999 Element 14 Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Element 14 Ltd.  It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Element 14 Ltd.  All rights reserved.                    */
/*                                                                      */
/************************************************************************/
d360 1
a360 1
            se->window_base = se->dynamic_window[se->window_no]
d378 1
a378 1
                u = static_window[se->window_no] + c;
d380 1
a380 1
                u = se->dynamic_window[se->window_no] + c - 0x80;
d433 1
a433 1
    else if (u >= 0xE000u & u < 0x10000u)
d444 2
a445 1
    int i, l = 0, n = -1;
d498 2
a499 2
    int i, l = INT_MAX, n = 0;
    unsigned int *w = se->window_last_used;
d565 1
a565 1
        if (u >= 0x110000 || u >= 0xD800 && u < 0xE000)
d639 1
a639 1
                int old = se->lock_to[se->learning_to];
d644 1
a644 1
            se->lock_to[se->learning_to] = (se->learning_to == window_no);
d687 1
a687 1
                    se->lock_to[se->learning_to] = 0;  /* Shouldn't have switched */
d694 1
a694 1
                    se->lock_to[se->learning_to] = 1;  /* Should have switched */
d851 1
a851 1
                !(next - se->dynamic_window[se->window_no] < 0x80))
d896 1
a896 1
                            int old = se->lock_to[se->learning_to];
d901 1
a901 1
                        se->lock_to[se->learning_to] = (se->learning_to == window_no);
d912 1
a912 1
                        if (next - se->dynamic_window[se->learning_from] < 0x80)
d917 1
a917 1
                            se->lock_to[se->learning_to] = 0; /* Shouldn't have locked */
d919 1
a919 1
                        else if (next - se->dynamic_window[se->learning_to] < 0x80)
d924 1
a924 1
                            se->lock_to[se->learning_to] = 1; /* Should have locked */
d1048 1
a1048 1
                !(next - se->dynamic_window[se->window_no]))
d1077 4
a1080 1
    scsu_write
@


1.4
log
@Typo in enc_scsu.c corrected.
ISO 8859-8 is now ISO-IR 198 (05/14).

Version 0.43. Tagged as 'Unicode-0_43'
@
text
@d213 1
a213 1
    char learning_from, learning_to;
d237 2
a556 2
	next = NULL_UCS4;
	u = se->next;
d568 1
d570 3
a572 5
        /* Put this character into "next", then process the existing "next" */

        next = u;
        u = se->next;
    }
d593 6
d875 1
d1060 1
@


1.3
log
@Improved SCSU "to lock or not to lock" learning.
Improved handling of SIP ideographs.
Added ISO-8859-11 (csISOLatinThai).
Renamed Latin13 to Latin7.

Version 0.42. Tagged as 'Unicode-0_42'
@
text
@d1038 1
a1038 2
                !(next - se->dynamic_window[se->window_no]) &&
                )
@


1.2
log
@SCSU encoder made aware of SIP (Supplementary Plane for Unified CJK Ideographs).
UTF-8 encoder handles out-of-space conditions correctly.
ISO 2022 encoder/decoder doesn't try to load table 7E (the null table).
encoding_new() does identify a null MIME string with auto-detect Japanese.
UnicodeData 3.0.0 imported.

Version 0.41. Tagged as 'Unicode-0_41'
@
text
@d166 1
a166 1
     * 0080-0200, 0380-1100, 1200-1D80, 3080-3180, E000-F880,
d174 1
a174 1
        0x00000000, /* 00000000000000000000000000000000                               */
d697 1
a697 1
             * function
a817 7
            /*
             * Set up the learning variables. This will allow a
             * free learn to see if we should lock in future
             */
            se->learning_from = se->window_no;
            se->learning_to = window_no;

d836 11
d937 5
a941 4
         * be sparse. We'll get it by shifting into Unicode mode. Might
         * as well do it with SCU hh hh ll ll, as that gives us the option
         * to stay in Unicode for free, or to drop out to the window of our
         * choice for the same price as SQU hh hh SQU ll ll.
d943 9
a951 2
         * Exception - if the next character is in the same window, someone's
         * probably compressing a code table, so we'll define a window.
d955 6
a960 1
        if ((u &~ 0x7F) == (next &~ 0x7F))
d965 4
d1036 8
a1043 2
            se->learning_from = se->window_no;
            se->learning_to = window_no;
@


1.1
log
@Implemented SCSU and UTF-7.
Added encoding_set_flags().
Proper handling of byte order marks in UTF-16 and UCS-4.
Fixed UTF-16 surrogate writing.
Adjusted various MIME charset identifiers.
Incorporated latest Unicode Character Database (2.1.8).
Added "current system alphabet" encoding.
Created "TextConv" command line character set conversion utility.

Version 0.34. Tagged as 'Unicode-0_34'
@
text
@d15 10
d34 2
a35 2
/*#define DEBUG_SCSU_COMPRESSION
#define DEBUG_LEARNING*/
d166 3
a168 2
     * 0080-0200, 0380-1D80, 3080-3180, E000-F880, 00C0, 0250, 0370, 0530,
     * 3040, 30A0, FF60, plus the "reserved for future use".
d173 1
a173 1
        0x0FFFFFFF, /* 11111111111111111111111111110000   1000-1D80                   */
d420 1
a420 1
    int i;
d422 1
a422 1
    for (i=SPECIAL_OFFSET_BASE; i<0x100; i++)
d426 1
a426 1
    if (u >= 0x0080 && u < 0x3400)
d428 1
a428 1
    else if (u >= 0xE000 & u < 0x10000)
d453 2
a454 2
 * Find a dynamic window containing both characters. If not
 * possible, one containing the next character character (-1 if none)
d477 1
d503 2
a504 2
 * Is character "u" expressible as a single byte if the current
 * window is "window"?
d606 1
a606 1
            if (is_valid_ascii(next) || (w = find_dynamic_window(se, next)) >= 0) /* Might as well switch if EOS */
d818 2
a819 1
            /* Set up the learning variables. This will allow a
d928 40
a967 1
    else /* u >= 0x10000 && u < 0x110000 && not in any window */
d976 2
@

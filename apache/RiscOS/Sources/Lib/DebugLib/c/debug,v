head	1.44;
access;
symbols
	DebugLib-0_72:1.44
	DebugLib-0_71:1.43
	DebugLib-0_70:1.43
	DebugLib-0_69:1.43
	DebugLib-0_68:1.43
	DebugLib-0_67:1.42
	DebugLib-0_66:1.41
	DebugLib-0_65:1.41
	DebugLib-0_64:1.40
	RO_5_07:1.39
	DebugLib-0_63:1.39
	DebugLib-0_62:1.39
	DebugLib-0_61:1.39
	DebugLib-0_60:1.38
	DebugLib-0_59:1.37
	DebugLib-0_58:1.37
	DebugLib-0_57:1.36
	dellis_autobuild_BaseSW:1.35
	DebugLib-0_56:1.35
	DebugLib-0_55:1.34
	DebugLib-0_54:1.33
	DebugLib-0_53:1.32
	DebugLib-0_52:1.32
	DebugLib-0_51:1.31
	DebugLib-0_50:1.31
	DebugLib-0_49:1.31
	sbrodie_sedwards_16Mar2000:1.30
	DebugLib-0_48:1.30
	DebugLib-0_47:1.30
	DebugLib-0_46:1.29
	dcotton_autobuild_BaseSW:1.39
	DebugLib-0_45:1.29
	DebugLib-0_44:1.29
	DebugLib-0_43:1.29
	DebugLib-0_42:1.29
	DebugLib-0_41:1.28
	DebugLib-0_40:1.27
	DebugLib-0_39:1.26
	DebugLib-0_38:1.25
	DebugLib-0_33-1_28_2_1:1.21.2.1
	DebugLib-0_37:1.24
	DebugLib-0_36:1.23
	DebugLib-0_35:1.23
	DebugLib-0_34:1.22
	nturton_DebugLib-0_24:1.13
	DebugLib-0_33:1.21
	DebugLib-0_32:1.20
	DebugLib-0_31:1.18
	DebugLib-0_30:1.17
	DebugLib-0_29:1.15
	DebugLib-0_28:1.14
	DebugLib-0_27:1.14
	DebugLib-0_26:1.14
	DebugLib-0_25:1.14
	DebugLib-0_24:1.12
	DebugLib-0_23:1.11
	DebugLib-0_22:1.11
	DebugLib-0_21:1.10
	DebugLib-0_20:1.9
	DebugLib-0_19:1.8
	DebugLib-0_18:1.7
	sforrest_daytona_appflash-0_31:1.1.2.1
	DebugLib-0_17:1.7
	DebugLib-0_16:1.6
	DebugLib-0_15:1.6
	DebugLib-0_14:1.5
	DebugLib-0_13:1.4
	DebugLib-0_12:1.4
	DebugLib-0_11:1.3
	DebugLib-0_10:1.3
	blaughto_daytona_appflash-0_30:1.1.2.1
	blaughto_daytona_appflash-0_29:1.1.2.1
	blaughto_daytona_appflash-0_28:1.1.2.1
	jberanek_debuglib-0_09:1.1.2.1
	blaughto_daytona_appflash-0_27:1.1.2.1
	blaughto_daytona_appflash-0_26:1.1.2.1
	blaughto_daytona_appflash-0_25:1.1.2.1
	blaughto_daytona_appflash-0_24:1.1.2.1
	blaughto_daytona_appflash-0_23:1.1.2.1
	jberanek_debuglib-0_08:1.1.2.1
	blaughto_daytona_appflash-0_21:1.1.2.1
	blaughto_daytona_appflash-0_20:1.1.2.1
	rwarren_debuglib-0_07:1.1.2.1
	blaughto_daytona_appflash-0_19:1.1
	jberanek_debuglib-0_06:1.1.2.1
	blaughto_daytona_appflash-0_18:1.1
	jberanek_debuglib-0_05:1.1
	Daytona_bp:1.1
	Daytona:1.1.0.2;
locks; strict;
comment	@# @;


1.44
date	2018.07.14.14.50.34;	author rsprowson;	state Exp;
branches;
next	1.43;
commitid	V19ZLEiOPZCm97KA;

1.43
date	2014.10.01.07.56.24;	author rsprowson;	state Exp;
branches;
next	1.42;
commitid	I4DkrDPuu5YshtSx;

1.42
date	2014.05.27.19.10.03;	author jlee;	state Exp;
branches;
next	1.41;
commitid	q3CKSpFBAsDE5dCx;

1.41
date	2010.03.23.00.36.49;	author jlee;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.10.15.39.58;	author srevill;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.17.10.53.31;	author jberanek;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.02.17.08.20;	author mjenning;	state Exp;
branches;
next	1.37;

1.37
date	2001.02.01.16.55.16;	author bavison;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.16.11.52.50;	author jberanek;	state Exp;
branches;
next	1.35;

1.35
date	2000.07.13.12.00.11;	author jberanek;	state Exp;
branches;
next	1.34;

1.34
date	2000.05.18.15.33.05;	author jberanek;	state Exp;
branches;
next	1.33;

1.33
date	2000.05.17.09.56.21;	author jberanek;	state Exp;
branches;
next	1.32;

1.32
date	2000.04.20.17.50.06;	author jberanek;	state Exp;
branches;
next	1.31;

1.31
date	2000.04.05.09.14.59;	author jberanek;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.21.10.56.38;	author jberanek;	state Exp;
branches;
next	1.29;

1.29
date	99.09.10.16.19.06;	author jberanek;	state Exp;
branches;
next	1.28;

1.28
date	99.09.08.13.40.14;	author jberanek;	state Exp;
branches;
next	1.27;

1.27
date	99.05.28.15.21.52;	author jberanek;	state Exp;
branches;
next	1.26;

1.26
date	99.05.27.15.51.50;	author nbingham;	state Exp;
branches;
next	1.25;

1.25
date	99.05.26.13.19.32;	author jberanek;	state Exp;
branches;
next	1.24;

1.24
date	99.05.20.10.00.52;	author jberanek;	state Exp;
branches;
next	1.23;

1.23
date	99.05.19.19.10.55;	author jberanek;	state Exp;
branches;
next	1.22;

1.22
date	99.05.19.15.20.14;	author sbrodie;	state Exp;
branches;
next	1.21;

1.21
date	99.05.10.15.48.46;	author jberanek;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	99.04.29.15.51.07;	author jberanek;	state Exp;
branches;
next	1.19;

1.19
date	99.04.26.08.46.24;	author jberanek;	state Exp;
branches;
next	1.18;

1.18
date	99.04.26.08.39.01;	author jberanek;	state Exp;
branches;
next	1.17;

1.17
date	99.03.19.18.48.17;	author jberanek;	state Exp;
branches;
next	1.16;

1.16
date	99.03.19.15.42.40;	author jberanek;	state Exp;
branches;
next	1.15;

1.15
date	99.03.19.11.54.12;	author blaughto;	state Exp;
branches;
next	1.14;

1.14
date	99.01.11.16.03.49;	author nbingham;	state Exp;
branches;
next	1.13;

1.13
date	98.11.24.17.05.23;	author kbracey;	state Exp;
branches;
next	1.12;

1.12
date	98.11.17.12.35.09;	author jberanek;	state Exp;
branches;
next	1.11;

1.11
date	98.11.11.17.18.27;	author jberanek;	state Exp;
branches;
next	1.10;

1.10
date	98.11.11.15.20.09;	author jberanek;	state Exp;
branches;
next	1.9;

1.9
date	98.11.05.15.14.53;	author Spin;	state Exp;
branches;
next	1.8;

1.8
date	98.11.05.14.52.50;	author Spin;	state Exp;
branches;
next	1.7;

1.7
date	98.10.22.16.32.26;	author jberanek;	state Exp;
branches;
next	1.6;

1.6
date	98.09.21.11.22.47;	author jberanek;	state Exp;
branches;
next	1.5;

1.5
date	98.09.17.12.48.15;	author jberanek;	state Exp;
branches;
next	1.4;

1.4
date	98.09.16.11.28.46;	author jberanek;	state Exp;
branches;
next	1.3;

1.3
date	98.09.04.17.18.56;	author jberanek;	state Exp;
branches;
next	1.2;

1.2
date	98.09.04.15.33.31;	author jberanek;	state Exp;
branches;
next	1.1;

1.1
date	98.02.16.14.18.20;	author jberanek;	state Exp;
branches
	1.1.2.1;
next	;

1.21.2.1
date	99.05.20.12.57.14;	author nbingham;	state Exp;
branches;
next	;

1.1.2.1
date	98.03.23.11.15.03;	author jberanek;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Fix for pointer compare confusion
Don't compare a pointer (that can never be NULL) when a nul terminator was intended.
Avoid strcmp() of potentially NULL area_level_in in the DEBUG case.
Found by cppcheck static analysis.

Version 0.72. Tagged as 'DebugLib-0_72'
@
text
@/* Copyright 1998 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**************************************************************************/
/* File:    debug.c                                                       */
/* Purpose: The file contains the generic routines, exported to callers   */
/*          of DebugLib.  Different output methods are implemented in     */
/*          seperate files.  Buffering and layers specifier parsing are   */
/*          done in seperate files also.                                  */
/*                                                                        */
/* Copyright [1999-2001] Pace Micro Technology PLC.  All rights reserved. */
/*                                                                        */
/* The copyright in this material is owned by Pace Micro Technology PLC   */
/* ("Pace").  This material is regarded as a highly confidential trade    */
/* secret of Pace.  It may not be reproduced, used, sold or in any        */
/* other way exploited or transferred to any third party without the      */
/* prior written permission of Pace.                                      */
/**************************************************************************/

/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include <stdarg.h>
#include <time.h>
#include <ctype.h>

#include "include.h"

#include "Trace/Trace.h"                /* Trace by JSmith */
#include "remotedb/remote.h"            /* Remote DB code by Rich Buckley */
#include "PDebug/PDebug.h"              /* PDebug by JSmith */

#include "misc.h"
#include "options.h"
#include "debugit.h"
#include "file.h"
#include "pdebug.h"
#include "printf.h"
#include "serial.h"
#include "socket.h"
#include "tml.h"
#include "tracker.h"
#include "buffering.h"
#include "parse.h"
#include "globals.h"
#include "debug.h"
#include "dadebug.h"
#include "brainlink.h"
#include "reporter.h"
#include "syslog.h"
#include "hal.h"

#include "VersionNum"

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

debug_options debug_current_options;

/* -------------------------------------- LOCAL VARIABLES --------------------------------------- */

static const char debug_version_string[] = Module_FullVersion;

static debug_device sysvar_provided_device = UNSET_OUTPUT;    /* The variable to hold output device specified by
                                                                 system variable */

static debug_device sysvar_provided_raw_device = UNSET_OUTPUT; /* The variable to hold the raw output device
                                                                   specified by system variable */

static debug_device sysvar_provided_tracedevice = UNSET_OUTPUT;  /* The variable to hold the trace output device
                                                                    specified by system variable */

static char *debug_level_specifier = NULL;            /* Contents of area-level specifying sys var */

static char debug_buffer[Debug_Buffer_Size];     /* Buffer for debug data */

static int debug_global_indent = 0;

static const char *debug_always_ignore = " PDebug_* Trace_* remote_debug_* debug_* _dprintf _dvprintf"
                                         " _dfprintf ddumpbuf send sendto select socket socketclose"
                                         " recv recvfrom connect gethostbyname";

typedef struct debug_output_method
{
  /* Functions */
  bool (*initialise)(void);
  void (*output)(const char *, size_t);
  void (*quit)(void);

  /* Variables */
  bool open;
  bool start_of_line;
}debug_output_method;

static debug_output_method methods[16] =
{
  {NULL,                 NULL,                   NULL,                 false,  true},   /* NULL_OUTPUT */
  {debug_tracker_init,   debug_tracker_output,   debug_tracker_quit,   false,  true},   /* TRACKER_OUTPUT */
  {NULL,                 debug_printf_output,    NULL,                 false,  true},   /* PRINTF_OUTPUT */
  {NULL,                 NULL,                   NULL,                 false,  true},   /* NOTUSED_OUTPUT */
  {debug_pdebug_init,    debug_pdebug_output,    debug_pdebug_quit,    false,  true},   /* PDEBUG_OUTPUT */
  {debug_socket_init,    debug_socket_output,    debug_socket_quit,    false,  true},   /* SOCKET_OUTPUT */
  {debug_debugit_init,   debug_debugit_output,   NULL,                 false,  true},   /* DEBUGIT_OUTPUT */
  {debug_tml_init,       debug_tml_output,       NULL,                 false,  true},   /* TML_OUTPUT */
  {debug_file_init,      debug_file_output,      debug_file_quit,      false,  true},   /* FILE_OUTPUT */
  {debug_serial_init,    debug_serial_output,    debug_serial_quit,    false,  true},   /* SERIAL_OUTPUT */
  {debug_dadebug_init,   debug_dadebug_output,   NULL,                 false,  true},   /* DADEBUG_OUTPUT */
  {debug_brainlink_init, debug_brainlink_output, debug_brainlink_quit, false,  true},   /* BRAINLINK_OUTPUT */
  {debug_reporter_init,  debug_reporter_output,  debug_reporter_quit,  false,  true},   /* REPORTER_OUTPUT */
  {debug_syslog_init,    debug_syslog_output,    debug_syslog_quit,    false,  true},   /* SYSLOG_OUTPUT */
  {debug_hal_init,       debug_hal_output,       NULL,                 false,  true},   /* HAL_OUTPUT */
  {NULL,                 NULL,                   NULL,                 false,  true}    /* UNSET_OUTPUT */

};

typedef struct debug_area_level_pair
{
  const char *area;
  char level;
}debug_area_level_pair;

typedef struct debug_sysvar_area_allowed_pair
{
  const char *area;
  unsigned int allowed;
}debug_sysvar_area_allowed_pair;

typedef enum
{
  positive_match,
  negative_match,
  no_match
}debug_tristate;

static debug_sysvar_area_allowed_pair debug_sysvar_pairs[32];
static int debug_sysvar_num_pairs = 0;

/* ------------------------------------ LOCAL FUNCTIONS ----------------------------------------- */


/************************************************************************/
/* debug_check_level                                                    */
/*                                                                      */
/* Checks the area-level pair passed in a dprintf with the system       */
/* variable specifying what areas and levels are wanted, and returns    */
/* true if the line should be output, and false if it shouldn't         */
/*                                                                      */
/* Parameters: area_level_in - The area-level pair                      */
/*                                                                      */
/* Returns:    true or false.                                           */
/*                                                                      */
/************************************************************************/
static bool debug_check_level (const char *area_level_in)
{
  debug_tristate matched = no_match;
  debug_area_level_pair pairs[16];
  char *step, *match;
  int i = 0, j, num_pairs;
  char *specifier;

  /* If we've got no sysyvar area/level pairs, we output */
  if (debug_sysvar_num_pairs == 0)
    return true;

  /* If the area_level is NULL, or an empty string we output */
  if ((area_level_in == NULL) || strlen (area_level_in) == 0)
    return true;

#ifdef DEBUG
  if (strcmp (area_level_in, "__DebugLib") == 0)
    return true;
#endif

  /*** We're through to here, we're gonna have to do some real matching ***/

  /* Take a copy so we can locally modify it */

  specifier = debug_misc_strdup (area_level_in);

  /* Parse the specifier string into a list of tokens of all the area specifiers */
  step = strtok (specifier, ",");
  pairs[i++].area = step;
  while ((i < 16) && (step = strtok (NULL, ",")) != NULL)
  {
    pairs[i++].area = step;
  };
  num_pairs = i;

  internal_dprintf(("__DebugLib", "num_pairs = %d\n", num_pairs));

  /* Step through the area specifiers */
  for (i=0; i < num_pairs; i++)
  {
    /* First, extract the level from the current specifier */

    /* If there's an _ in the current specifier ... */
    if ((match = strrchr (pairs[i].area, '_')) != NULL)
    {
      *match = '\0';

      /* If there's a number after the _ ... */
      if (match[1] != '\0')
      {
        /* Extract it */
        pairs[i].level = atoi (match+1);
      }
      else
      {
        /* Else, we default to least verbose */
        pairs[i].level = 0;
      }
    }
    else
    {
      /* Else, we default to least verbose */
      pairs[i].level = 0;
    }

    /* Next, step through the system variable areas, checking for matches with the current specifier */

    for (j=0; j < debug_sysvar_num_pairs; j++)
    {
      /* internal_dprintf (("__DebugLib", "sysvar[%d] = %s (%x)\n", j, sysvar_pairs[j].area,
                            sysvar_pairs[j].allowed)); */
      /* If the current sysvar area matches the current debug specifier area ... */
      if (strcmp (pairs[i].area, debug_sysvar_pairs[j].area) == 0)
      {
        /* Check if the specifier level lies in the included level mask of the sysvar area */
        if ( (debug_sysvar_pairs[j].allowed & _LEVEL_INCLUDED(pairs[i].level)) &&
            !(debug_sysvar_pairs[j].allowed & _LEVEL_EXCLUDED(pairs[i].level)))
        {
          /* Positive match overrides any kind of match */
          matched = positive_match;
        }
        else if ( (debug_sysvar_pairs[j].allowed & _LEVEL_EXCLUDED(pairs[i].level)) &&
                 !(debug_sysvar_pairs[j].allowed & _LEVEL_INCLUDED(pairs[i].level)))
        {
          /* Negative match only overrides a non-match */
          if (matched == no_match)
            matched = negative_match;
        }
      }
      /* Else, if the sysvar specifier is the catchall, and we've not yet decided on match/not match ... */
      else if ((strcmp (debug_sysvar_pairs[j].area, "*") == 0) && (matched == no_match))
      {
        /* Check if the specifier level lies in the allowed levels of the sysvar area */
        if (debug_sysvar_pairs[j].allowed & _LEVEL_INCLUDED(pairs[i].level))
          matched = positive_match;
        else if (debug_sysvar_pairs[j].allowed & _LEVEL_EXCLUDED(pairs[i].level))
          matched = negative_match;
      }
    }
  }

  /* Free up some memory */
  free (specifier);

  if (matched == positive_match)
    return true;
  else
    return false;
}


/************************************************************************/
/* debug_level_specifier_print                                          */
/*                                                                      */
/* Ikkle helper function to print out a level specifying "allowed"      */
/* word in a human readable form.                                       */
/*                                                                      */
/* e.g. 01236789                                                        */
/*                                                                      */
/* Parameters: allowed - The level specifying word from a               */
/*                       debug_sysvar_area_allowed_pair.allowed         */
/*                                                                      */
/* Returns:    Pointer to local static string containing human          */
/*             readable representatiom of "allowed".                    */
/*                                                                      */
/************************************************************************/
static const char *debug_level_specifier_print(int allowed)
{
  static char str[11];
  int i;
  char *p = str;

  for (i=0 ; i < 10; i++)
  {
    if ((allowed & _LEVEL_INCLUDED(i)) && !(allowed & _LEVEL_EXCLUDED(i)))
    {
      *p = '0' + i;
      p++;
    }
  }

  *p = '\0';

  return str;
}


/************************************************************************/
/* debug_setup_filename                                                 */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the filename for   */
/* the file output method using either sysvar or param passed into      */
/* debug_initialise                                                     */
/*                                                                      */
/* Parameters: fname  - filename passed in debug_initialise             */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_filename (const char *fname)
{
  char *tmp_sysvar_name;

  tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$Filename_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$Filename_%s", debug_current_options.taskname);

  if (debug_current_options.filename)
    free (debug_current_options.filename);
  debug_current_options.filename = debug_misc_getenv_malloc (tmp_sysvar_name);
  if (debug_current_options.filename == NULL)
  {
    if (fname && strlen (fname))
    {
      debug_current_options.filename = debug_misc_strdup (fname);
    }
  }

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_setup_unbuffered                                               */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the whether files  */
/* should be unbuffered for the file outpit method.                     */
/* debug_initialise                                                     */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_unbuffered (void)
{
  char *tmp_sysvar_name;
  char *tmp_string;

  tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$UnbufferedFiles_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$UnbufferedFiles_%s", debug_current_options.taskname);

  tmp_string = debug_misc_getenv_malloc (tmp_sysvar_name);
  if (tmp_string != NULL)
  {
    free (tmp_string);
    debug_current_options.unbuffered_files = true;
  }
  else
    debug_current_options.unbuffered_files = false;

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_set_level                                                      */
/*                                                                      */
/* A callback used by the level parsing code to fill the structure      */
/* holding the pairs of values that set what debug levels are output.   */
/*                                                                      */
/* Parameters: area - The area name to set                              */
/*             allowed - The allowed mask                               */
/*                                                                      */
/* Returns:    nothing                                                  */
/*                                                                      */
/************************************************************************/
static void debug_set_level (const char *area, unsigned int allowed)
{
  debug_sysvar_pairs[debug_sysvar_num_pairs].area = area;
  debug_sysvar_pairs[debug_sysvar_num_pairs++].allowed = allowed;
}


/************************************************************************/
/* debug_setup_level                                                    */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the level          */
/* specifier, which is read from a system variable                      */
/*                                                                      */
/*                                                                      */
/* Parameters: sysvar - system variable specifier from debug_initialise */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_level (const char *sysvar)
{
  char *tmp_sysvar_name;

  /* Check for level sysvar specifier */
  if (sysvar && strlen (sysvar))
  {
    tmp_sysvar_name = debug_misc_strdup (sysvar);
  }
  else
  {
    /* .. Setup a string with the name of the default system variable that will
       specify the debug area/level(s) */
    tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$Level_") + 1);
    sprintf (tmp_sysvar_name, "DebugLib$Level_%s", debug_current_options.taskname);
  }

  if (debug_level_specifier != NULL)
    free (debug_level_specifier);
  debug_level_specifier = debug_misc_getenv_malloc (tmp_sysvar_name);

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);

  if (debug_level_specifier && strlen (debug_level_specifier))
  {
    debug_sysvar_num_pairs = 0;
    debug_parse_levels (debug_set_level, debug_level_specifier);
  }
}


/************************************************************************/
/* debug_setup_device                                                   */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the device used    */
/* for normal debug output. Read from a system variable                 */
/*                                                                      */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_device (void)
{
  char *tmp_sysvar_name;
  char *tmp_string;

  /* Setup a string with the name of the system variable that will
     specify the output device */
  tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$Device_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$Device_%s", debug_current_options.taskname);

  /* Read the system variable */
  tmp_string = debug_misc_getenv_malloc (tmp_sysvar_name);

  if (tmp_string)
  {
    sysvar_provided_device = (debug_device) atoi (tmp_string);
    debug_set_device (sysvar_provided_device);
    free (tmp_string);
  }

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_setup_raw_device                                               */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the device used    */
/* for raw debug output. Read from a system variable                    */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_raw_device (void)
{
  char *tmp_sysvar_name;
  char *tmp_string;

  /* Setup a string with the name of the system variable that will
     specify the output device */
  tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$RawDevice_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$RawDevice_%s", debug_current_options.taskname);

  /* Read the system variable */
  tmp_string = debug_misc_getenv_malloc (tmp_sysvar_name);

  if (tmp_string)
  {
    sysvar_provided_raw_device = (debug_device) atoi (tmp_string);

    if (sysvar_provided_raw_device != UNSET_OUTPUT)
      debug_current_options.raw_device = sysvar_provided_raw_device;

    free (tmp_string);
  }

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_setup_tracedevice                                              */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the device used    */
/* for trace output. Read from a system variable.                       */
/*                                                                      */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_tracedevice (void)
{
  char *tmp_sysvar_name;
  char *tmp_string;

  /* Setup a string with the name of the system variable that will
     specify the trace output device */
  tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$TraceDevice_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$TraceDevice_%s", debug_current_options.taskname);

  tmp_string = debug_misc_getenv_malloc (tmp_sysvar_name);

  /* If we got something out of the system variable ... */
  if (tmp_string)
  {
    /* ... convert it to a output device type */
    sysvar_provided_tracedevice = (debug_device) atoi (tmp_string);
    free (tmp_string);
  }

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_close_device                                                   */
/*                                                                      */
/* Function closes the currently active device.                         */
/*                                                                      */
/* Parameters: device - integer constant for devices.                   */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_close_device (debug_device device)
{
  time_t timer;

  /* Only close the device if it's open */
  if (methods[device].open == true)
  {
    /* And only send the close text if it's not the raw device */
    if (device != debug_current_options.raw_device)
    {
      time (&timer);
      _dfprintf("",device,"\n***** Debug Session Terminated *************************************\n");
      _dfprintf("", device, "Task: %s\n", debug_current_options.taskname);
      _dfprintf("", device, "Time: %s", ctime(&timer));
      _dfprintf("", device, "%s\n", COPYRIGHT_MESSAGE);
      _dfprintf("", device, "********************************************************************\n");
    }

    if (methods[device].quit)
      methods[device].quit();
    methods[device].open = false;

    if (device == debug_current_options.device)
      debug_current_options.device = NULL_OUTPUT;
  }
}


/************************************************************************/
/* debug_output_prefix                                                  */
/*                                                                      */
/* Function outputs the debug output prefix that is needed based on     */
/* the current configuration, and the device identifer that is passed   */
/* in.                                                                  */
/*                                                                      */
/* Parameters: area_level - Levels specified in the _dprintf().         */
/*             device - the debug device to send the buffer to          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_output_prefix (const char *area_level, debug_device device)
{
  if (debug_current_options.taskname_prefix == true  && device != TRACKER_OUTPUT)
  {
    methods[device].output (debug_current_options.taskname, strlen (debug_current_options.taskname));
  }
  if (debug_current_options.stamp_debug == true)
  {
    char buf[20];
    time_t timer;
    struct tm *t;

    time (&timer);

    t = localtime (&timer);

    strftime (buf, sizeof (buf), " %H:%M:%S", t);
    methods[device].output (buf, strlen (buf));
  }
  if (debug_current_options.area_level_prefix == true)
  {
    const char *str;
    char *out;

    if ((area_level == NULL) || (*area_level == '\0'))
      str = "ALERT";
    else
      str = area_level;

    if (debug_current_options.area_pad_limit > 0)
    {
      out = malloc (debug_current_options.area_pad_limit + 1);
      if (out)
      {
        strncpy (out, str, debug_current_options.area_pad_limit);
        if (strlen(str) < debug_current_options.area_pad_limit)
        {
          /* Pad */
          int i;

          for (i=strlen(str) ; i<debug_current_options.area_pad_limit ; i++)
            out[i] = ' ';
          out[i] = '\0';
        }
        else
        {
          /* Truncate */
          out[debug_current_options.area_pad_limit] = '\0';
        }
      }
    }
    else
      out = (char*)str;

    methods[device].output (" [", strlen (" ["));
    methods[device].output (out, strlen (out));
    methods[device].output ("]", strlen ("]"));

    if (debug_current_options.area_pad_limit > 0)
      free (out);
  }
  if ((debug_current_options.taskname_prefix == true  && device != TRACKER_OUTPUT) ||
      (debug_current_options.stamp_debug == true) ||
      (debug_current_options.area_level_prefix == true))
  {
    methods[device].output (": ", strlen (": "));
  }
}


/************************************************************************/
/* debug_output_data                                                    */
/*                                                                      */
/* Function outputs the conventional debuglib output with prefixing,    */
/* timestamping etc.                                                    */
/*                                                                      */
/* Parameters: area_level - Levels specified in the _dprintf().         */
/*             device - the debug device to send the buffer to          */
/*             buffer - data to be streamed.                            */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_output_data (const char *area_level, debug_device device, const char *buffer)
{
  if (debug_buff_status.enabled != false)
  {
    debug_buffer_stream (buffer);
  }
  else
  {
    bool rc = true;

    /* If we've been passed an invalid device, don't bother */
    if (device <= NULL_OUTPUT || device >= UNSET_OUTPUT || device == NOTUSED_OUTPUT)
      return;

    /* If the device has no output method, don't bother */
    if (methods[device].output == NULL)
      return;

    /* If we've got an empty string, return too */
    if ((buffer == NULL) || (*buffer == '\0'))
      return;

    /* Check that the output device is open */
    if (methods[device].open == false)
    {
      /* If it's not, initialise it */
      if (methods[device].initialise)
      {
        rc = methods[device].initialise ();
      }
      if (rc == true)
        methods[device].open = true;
    }

    /* And if everything is OK, go ahead and output the buffer */
    if (rc == true)
    {
      const char *stepper = buffer, *match;

      if (methods[device].start_of_line == true)
      {
        debug_output_prefix (area_level, device);
        methods[device].start_of_line = false;
      }
      do
      {
        match = strchr (stepper, '\n');
        if (match)
        {
          /* Output up to and including the \n */
          methods[device].output (stepper, match - stepper + 1);
          stepper = match + 1;
          if (*stepper == NULL)
          {
            /* \n is at the end of "buffer" */
            methods[device].start_of_line = true;
          }
          else
          {
            /* \n in middle of "buffer" */
            debug_output_prefix (area_level, device);
          }
        }
        else
        {
          /* No more \ns */
          methods[device].output (stepper, strlen (stepper));
        }
      }
      while ((match != NULL) && (*stepper != NULL));
    }
  }
}


/************************************************************************/
/* debug_trace_enter                                                    */
/*                                                                      */
/* Function is called when a function is entered provided trace is      */
/* running.                                                             */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_trace_enter (const char *fname)
{
  int i = 0;
  char *buffer;
  char buffer2[256];

  buffer = malloc (strlen ("Trace: 999:")+(strlen(" |")*debug_global_indent)+strlen(" \n")+strlen (fname)+1);

  if (buffer)
  {
    sprintf (buffer, "Trace: %3d:", debug_global_indent);

    for (i = 0; i < debug_global_indent; i++)
    {
      strcat (buffer, " |");
    }
    sprintf (buffer2, " %s\n", fname);
    strcat (buffer, buffer2);

    _dfprintf ("Trace", debug_current_options.trace_device, buffer);

    free (buffer);
  }

  debug_global_indent++;
}


/************************************************************************/
/* debug_trace_exit                                                     */
/*                                                                      */
/* Function is called when a function is exited provided trace is       */
/* running.                                                             */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_trace_exit (const char* fname)
{
  int i = 0;
  char *buffer;
  char buffer2[256];

  buffer = malloc (strlen ("Trace: 999:")+(strlen(" |")*debug_global_indent)+strlen("~\n")+strlen (fname)+1);

  if (buffer)
  {
    sprintf (buffer, "Trace: %3d:", debug_global_indent-1);

    for (i=0; i < debug_global_indent-1; i++)
    {
      strcat (buffer, " |");
    }

    sprintf (buffer2, "~%s\n", fname);
    strcat (buffer, buffer2);

    _dfprintf ("Trace", debug_current_options.trace_device, buffer);

    free (buffer);
  }

  debug_global_indent--;
}


/************************************************************************/
/* debug_terminate                                                      */
/*                                                                      */
/* Function terminates the current debug session.                       */
/*                                                                      */
/* Parameters: none                                                     */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_terminate (void)
{
  int i;

  for (i = (NULL_OUTPUT+1); i < UNSET_OUTPUT; i++)
    debug_close_device ((debug_device)i);
}


/* --------------------------------- EXPORTED FUNCTIONS -------------------------------------- */


/************************************************************************/
/* debug_initialise                                                     */
/*                                                                      */
/* Function initialises the library                                     */
/*                                                                      */
/* Parameters: name - name of app that is calling the library.          */
/*             fame - file for debug output to FILE                     */
/*             sysvar - System Variable to override default area/level  */
/*                      specifiying system variable. Uses default if    */
/*                      NULL or "" is passed.                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_initialise (const char *name, const char *fname, const char *sysvar)
{
  /* Set up our atexit handler */
  atexit(debug_terminate);

  /* Set default DebugLib options */
  debug_options_initialise ();

  /* Setup taskname */
  if (debug_current_options.taskname)
    free (debug_current_options.taskname);
  if (name && *name)
    debug_current_options.taskname = debug_misc_strdup (name);
  else
    debug_current_options.taskname = debug_misc_strdup ("DefaultName");

  /* Setup filename */
  debug_setup_filename (fname);

  /* Setup whether we should be doing unbuffered file writes */
  debug_setup_unbuffered ();

  /* Setup the level specifier */
  debug_setup_level (sysvar);

  /* Setup the device */
  debug_setup_device ();

  /* Setup the raw device */
  debug_setup_raw_device ();

  /* Setup the trace device */
  debug_setup_tracedevice ();

  /* Setup the buffering code */
  debug_buffer_startup();
}


/************************************************************************/
/* debug_read_device                                                    */
/*                                                                      */
/* Function returns the identifier of the currently active debug output */
/* device.                                                              */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    debug device identifier.                                 */
/*                                                                      */
/************************************************************************/
debug_device debug_read_device (void)
{
  debug_device device = UNSET_OUTPUT;

  if (sysvar_provided_device != UNSET_OUTPUT)
    device = sysvar_provided_device;
  else
    device = debug_current_options.device;

  return device;
}


/************************************************************************/
/* debug_set_device                                                     */
/*                                                                      */
/* Function selects the debug output device                             */
/*                                                                      */
/* Parameters: device - device specifer.                                */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_set_device (debug_device device)
{
  time_t timer;
  bool rc = false;

  /* Fault invalid devices */
  if (device < NULL_OUTPUT || device > UNSET_OUTPUT)
    return;

  if (debug_buff_status.enabled == false)
  {
    /* Buffering is off, so proceed */

    /* If we've been provided with an output device by a sysvar, we want to
       override the the requested output device with the one in the sysvar */
    if (sysvar_provided_device != UNSET_OUTPUT)
      device = sysvar_provided_device;

    if ((device == debug_current_options.device) &&
        (methods[device].open == true))
    {
      /* No need to do anything, escape */
      return;
    }

    /* Close down previous debug output */
    debug_close_device (debug_current_options.device);

    if (methods[device].initialise)
      rc = methods[device].initialise();
    else
      rc = true;

    /* If we've initialised correctly, set the debug device and output DebugLib header */
    if (rc == true)
    {
      methods[device].open = true;
      debug_current_options.device = device;

      time (&timer);
      _dprintf ("", "\n***** Debug Session Started **************************************\n");
      _dprintf ("", "%s\n", COPYRIGHT_MESSAGE);
      _dprintf ("", "System: DebugLib %s\n", debug_version());
      _dprintf ("", "        remotedb %s\n", remote_debug_version());
      _dprintf ("", "        PDebug %s\n", PDebug_Version());
      _dprintf ("", "Task:   %s\n", debug_current_options.taskname);
      _dprintf ("", "Time:   %s", ctime(&timer));
      {
        if (debug_sysvar_num_pairs < 1)
        {
          _dprintf ("", "Levels: Not specified.\n");
        }
        else
        {
          int i;

          _dprintf ("", "Levels:\n");

          for (i=0 ; i < debug_sysvar_num_pairs; i++)
          {
            _dprintf ("", "       Area: %s - %s\n", debug_sysvar_pairs[i].area,
                      debug_level_specifier_print(debug_sysvar_pairs[i].allowed));
          }
        }
      }
      _dprintf ("", "******************************************************************\n");
    }
  }
  else
  {
    if (sysvar_provided_device != UNSET_OUTPUT)
      device = sysvar_provided_device;

    debug_current_options.device = device;
  }
}


/************************************************************************/
/* debug_set_raw_device                                                 */
/*                                                                      */
/* Function sets up the raw device.                                     */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_set_raw_device (debug_device device)
{
  if (sysvar_provided_raw_device == UNSET_OUTPUT)
    debug_current_options.raw_device = device;
}


/************************************************************************/
/* debug_output                                                         */
/*                                                                      */
/* Function sends the debugging data to a valid location.               */
/*                                                                      */
/* Parameters: flags      - Bit 0 set:   Output raw                     */
/*                          Bit 0 unset: Output full info.              */
/*             area_level - Levels specified in the _dprintf().         */
/*             device - the debug device to send the buffer to          */
/*             buffer - data to be streamed.                            */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_output (unsigned int flags, const char *area_level, debug_device device,
                   const char *buffer)
{
  debug_options		local_opts;

  if (flags & 1u)
  {
    /* Bit 0 set, output raw with no timestamping, levelling, prefixing etc. */
    debug_get_internal_options(&local_opts);
    debug_set_internal_options_raw();
    debug_output_data (area_level, device, buffer);
    debug_set_internal_options(local_opts);
  }
  else
  {
    /* Bit 0 unset, output info based on options */
    debug_output_data (area_level, device, buffer);
  }
}


/************************************************************************/
/* _dvprintf                                                            */
/*                                                                      */
/* Function is equilivant to vprintf for debugging.                     */
/*                                                                      */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void _dvprintf(const char *area_level, const char *format, const va_list arg)
{
  if (debug_check_level (area_level) == true)
  {
    vsprintf (debug_buffer, format, arg);
    debug_output (0, area_level, debug_current_options.device, debug_buffer);
  }
}


/************************************************************************/
/* _dprintf                                                             */
/*                                                                      */
/* Function sends the data to the current output device                 */
/*                                                                      */
/* Parameters: format - printf configuration.                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void _dprintf (const char *area_level, const char *format, ...)
{
  va_list p;

  va_start (p, format);
  _dvprintf(area_level, format, p);
  va_end (p);
}


/************************************************************************/
/* _dprintf_raw                                                         */
/*                                                                      */
/* Function sends the data to the current output device                 */
/*                                                                      */
/* Parameters: void *  - Use by Dr. Smith's.                            */
/*             format  - printf args.                                   */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void _dprintf_raw (void *ref, const char *format, ...)
{
  va_list p;

  IGNORE(ref);

  va_start (p, format);

  /* We don't want level checking in here, so we won't be calling _dvprintf() */
  vsprintf(debug_buffer, format, p);
  debug_output(1, "", debug_current_options.raw_device, debug_buffer);

  va_end (p);
}


/************************************************************************/
/* _dfprintf                                                            */
/*                                                                      */
/* Function sends the data to the specified stream.                     */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void _dfprintf (const char *area_level, debug_device device, const char *format, ...)
{
  va_list p;

  if (debug_check_level (area_level) == true)
  {
    va_start (p, format);
    vsprintf (debug_buffer, format, p);
    va_end (p);

    debug_output (0, area_level, device, debug_buffer);
  }
}


/************************************************************************/
/* ddumpbuf                                                             */
/*                                                                      */
/* Function to dump a buffer to the current output device               */
/*                                                                      */
/* Parameters: buffer - data to dump                                    */
/*             size   - amount of data to dump                          */
/*             offset - offset to add to addresses                      */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void ddumpbuf (const char *area_level, const void *buffer, size_t size, size_t offset)
{
  if (debug_check_level (area_level) == true)
  {
    const size_t width = debug_current_options.dump_width;
    const size_t end = ((size + width - 1) / width) * width;
    const char *membuf = buffer;

    size_t i = 0, j;
    char *db;

    db = debug_buffer;
    *db = 0;

    while (i < end)
    {
      if ((i % width) == 0)
      {
        if (i)
        {
          db += sprintf (db, ": ");
          for (j = i - width; j != i; ++j)
          {
            db += sprintf (db, "%c", (membuf[j]>=32 && membuf[j] != 0x7f) ? membuf[j] : '.');
          }
          sprintf (db, "\n");
          debug_output (0, area_level, debug_current_options.device, debug_buffer);
          db = debug_buffer;
        }
        db += sprintf (db, "%04x: ", i + offset);
      }

      if (i>=size)
      {
        db += sprintf (db, "   ");
      }
      else
      {
        db += sprintf (db, "%02x ", membuf[i]);
      }
      ++i;
    }

    if (i)
    {
      for (db += sprintf (db, ": "), j = i - width; j != i; ++j)
      {
        db += sprintf (db, "%c", j>=size ? ' ' : (membuf[j]>=32 && membuf[j] != 0x7f) ? membuf[j] : '.');
      }
      sprintf (db, "\n");
      debug_output (0, area_level, debug_current_options.device, debug_buffer);
    }
  }
}


/************************************************************************/
/* debug_beep                                                           */
/*                                                                      */
/* Function makes a beep when called                                    */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_beep (void)
{
  _swix (OS_WriteI + 7, 0);
}


/************************************************************************/
/* debug_version                                                        */
/*                                                                      */
/* Function returns the library's version number.                       */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    Pointer to const string containg version number.         */
/*                                                                      */
/************************************************************************/
const char *debug_version (void)
{
  return debug_version_string;
}


/************************************************************************/
/* debug_initialise_trace                                               */
/*                                                                      */
/* Function initialises the trace library.                              */
/*                                                                      */
/* Parameters: stream - Debug output stream to use.                     */
/*             fns    - Functions to ignore                             */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_initialise_trace (debug_device device, const char *fns)
{
  char *ignore_fns;
  int len, len2;

  if (sysvar_provided_tracedevice == UNSET_OUTPUT)
    debug_current_options.trace_device = device;
  else
    debug_current_options.trace_device = sysvar_provided_tracedevice;

  debug_global_indent++;

  if (fns == NULL)
    len2 = 0;
  else
    len2 = strlen (fns);

  len = len2 + strlen (debug_always_ignore) + 1;

  if ((ignore_fns = malloc (len)) == NULL)
  {
    return;
  }

  /* Buffer allocated, so add the PDebug, Trace and remotedb functions onto the end of the list */

  if (len2 > 0)
    strcpy (ignore_fns, fns);
  else
    ignore_fns[0] = '\0';

  strcat (ignore_fns, debug_always_ignore);

  Trace_IgnoreFunctions (ignore_fns);
  Trace_SetHandlers (
                     (Trace_fnstarthandler)debug_trace_enter,
                     (Trace_fnstophandler)debug_trace_exit
                    );
  Trace_InterceptAllFunctions ();

  free (ignore_fns);
}
@


1.43
log
@Relocate remotedb
Requires remotedb-0_12.

Version 0.68. Tagged as 'DebugLib-0_68'
@
text
@a168 5
#ifdef DEBUG
  if (strcmp (area_level_in, "__DebugLib") == 0)
    return true;
#endif

d177 5
d210 1
a210 1
      if ((match+1) != NULL)
@


1.42
log
@Fix null pointer dereference
Detail:
  c/debug - Fixed a null pointer dereference in debug_setup_filename()
Admin:
  Tested on BB-xM with high processor vectors


Version 0.67. Tagged as 'DebugLib-0_67'
@
text
@d39 1
a39 1
#include "debug/remote.h"               /* Remote DB code by Rich Buckley */
@


1.41
log
@Add HAL_DebugTX support to DebugLib
Detail:
  Makefile, c/hal, h/hal, c/debug, h/DebugLib - Added new HAL_OUTPUT debug device that calls HAL_DebugTX
  Docs/DebugLib,3d6 - updated StrongHelp docs
Admin:
  Tested in OMAP ROM on rev C2 beagleboard


Version 0.65. Tagged as 'DebugLib-0_65'
@
text
@d333 1
a333 1
    if (fname || strlen (fname))
@


1.40
log
@  Adding SysLog and Reporter logging backends to the DebugLib library.
Detail:
  I've added simple backends for the standard SysLog SWI interface and
  the Reporter module. Both of these provide line based APIs so the output
  is line buffered (to a width of 80 characters). I also removed two
  unnecessary forward declarations for static functions in debug.c which
  were producing warnings from Norcroft CC.
Admin:
   Compiled with Norcroft 5.65. Tested on RISC OS 5.13, using DoggySoft
   SysLog 0.20, Reporter 2.64d via a debug build of the USBDriver module.

Version 0.64. Tagged as 'DebugLib-0_64'
@
text
@d60 1
d103 1
a103 1
static debug_output_method methods[15] =
d119 1
@


1.39
log
@  Updated Copyrights, tidied comment header blocks
Detail:
  Updated Copyright messages to show range of years, up to 2001...a bit
 late in the year for that...

  Tidied a few file header comment blocks.

Admin:
  Built on RiscPC.


Version 0.61. Tagged as 'DebugLib-0_61'
@
text
@d58 2
d102 1
a102 1
static debug_output_method methods[13] =
d116 2
a143 5
/* ---------------------------------- LOCAL FUNCTION PROTOTYPES --------------------------------- */

static void debug_output_data (const char *, debug_device, const char *);
static void debug_close_device (debug_device);

@


1.38
log
@  A new DebugLib device added to allow debugging via the BrainLink module.
  The GUI_test program has been modified to support the new DebugLib device.
  DebugLib stronghelp documentaion has been updated.
Detail:

Admin:
  Tested on my RiscPC, seems to work fine.


Version 0.60. Tagged as 'DebugLib-0_60'
@
text
@d15 15
a29 16
/************************************************************************/
/* File:    debug.c                                                     */
/* Purpose: The file contains various debugging routines.  I have       */
/*          provided several methods of debug output; TML Podules,      */
/*          !Tracker, printf statements, serial parallel and sockets    */
/* Author:  Neil Bingham (mailto:NBingham@@acorn.co.uk)                  */
/* History: Tue 18th February 1997  ver 0.01 - Created.                 */
/*                                                                      */
/* Copyright [1999] Pace Micro Technology PLC.  All rights reserved.    */
/*                                                                      */
/* The copyright in this material is owned by Pace Micro Technology PLC */
/* ("Pace").  This material is regarded as a highly confidential trade  */
/* secret of Pace.  It may not be reproduced, used, sold or in any      */
/* other way exploited or transferred to any third party without the    */
/* prior written permission of Pace.                                    */
/************************************************************************/
a1277 1

@


1.37
log
@Added DADebug support (see RiscOS/Sources/Programmer/DADebug). Original work
was done against version 0.45 of DebugLib, but I don't think anything's
changed that cvs update can't deal with. Not tested.

Version 0.58. Tagged as 'DebugLib-0_58'
@
text
@d58 1
d101 1
a101 1
static debug_output_method methods[12] =
d103 14
a116 12
  {NULL,               NULL,                 NULL,               false,  true},   /* NULL_OUTPUT */
  {debug_tracker_init, debug_tracker_output, debug_tracker_quit, false,  true},   /* TRACKER_OUTPUT */
  {NULL,               debug_printf_output,  NULL,               false,  true},   /* PRINTF_OUTPUT */
  {NULL,               NULL,                 NULL,               false,  true},   /* NOTUSED_OUTPUT */
  {debug_pdebug_init,  debug_pdebug_output,  debug_pdebug_quit,  false,  true},   /* PDEBUG_OUTPUT */
  {debug_socket_init,  debug_socket_output,  debug_socket_quit,  false,  true},   /* SOCKET_OUTPUT */
  {debug_debugit_init, debug_debugit_output, NULL,               false,  true},   /* DEBUGIT_OUTPUT */
  {debug_tml_init,     debug_tml_output,     NULL,               false,  true},   /* TML_OUTPUT */
  {debug_file_init,    debug_file_output,    debug_file_quit,    false,  true},   /* FILE_OUTPUT */
  {debug_serial_init,  debug_serial_output,  debug_serial_quit,  false,  true},   /* SERIAL_OUTPUT */
  {debug_dadebug_init, debug_dadebug_output, NULL,               false,  true},   /* DADEBUG_OUTPUT */
  {NULL,               NULL,                 NULL,               false,  true}    /* UNSET_OUTPUT */
@


1.36
log
@  A number of changes, made over the months, but which I'd failed to
   checkin.  Tsk.
Detail:
  Some additions to CLI test harness.

  Bits of code in CLI and GUI test harness to check at compile time if
   OSLib and "Toolbox" style boolean definitions work with DebugLib.h

  Changed GUI test harness Makefile to use LocalRes:

  Removed calls to debug_atexit() in test harnesses, they're no longer
   necessary.

  Behaviour change: if you set a device in DebugLib$Device_<taskname>,
   debug_set_device() is called for that device on debug_initialise().

  Added check into debug_set_device(), if it's called with the current
   device, and the current device is initialised, it now does nothing,
   because it doesn't need to.

  Added extra checks into file and socket output methods that ensure
   initialising and/or terminating these devices repeatedly won't
   cause problems.

  Added some extra preprocessor malarky into DebugLib.h so that it should
   handle more boolean definitions.  It should handle (at least) "Toolbox"
   style ones and OSLib ones.

  Changed some used of debug_output_device() to debug_set_device() in Module
   test harness. debug_output_device() is deprecated.

  Fixed a bug in the core termination code...all open devices should now
   be closed correctly on exit.
Admin:
  Built library.
  Built and ran through some tests in the 3 test harnesses.


Version 0.57. Tagged as 'DebugLib-0_57'
@
text
@d57 1
d100 1
a100 1
static debug_output_method methods[11] =
d112 1
@


1.35
log
@  Few little fixes
Detail:
  Levels specifier in DebugLib header now outputs correctly.  It now
   prints out a human readable form of what it's parsed from the
   DebugLib$Level_<taskname> system variable, showing the areas and
   levels specified.

  Added a few variable resets into "quit" functions of some of the
   output devices.  Done after a report from Ben that calling
   debug_terminate twice could cause a crash.  Not sure what
   device was used to cause the crash, also not sure if any of my
   changes will have changed the behaviour.  Added an extra test
   into the CLI_App test harness, it calls debug_terminate twice
   at the end. (Didn't manage to make it crash before or after
   changes).
Admin:
  StrongHelp document now gets copied to Export dir, along with
   headers, library and LibVersion.


Version 0.56. Tagged as 'DebugLib-0_56'
@
text
@d467 1
d583 2
a584 2
    if (methods[debug_current_options.device].quit)
      methods[debug_current_options.device].quit();
d971 6
a976 3
    /* Set to NULL by default, until proved otherwise.  Removes the need for an ELSE statements
     * when checking for modules
     */
@


1.34
log
@  Efficiency improvement and obscure overflow fix in area checking code
Detail:
  Every dprintf() call calls debug_check_level() to check whether the
   statement should be printed or not.  This function did take 2
   parameters, the 2nd of which was no longer being used.  The function
   now only takes 1 parameter.

  You are limited to having 16 comma-seperated area/level
   pairs in each dprintf(), but the routine to tokenise this string
   would've written into and beyond position 16 of a 16 element
   array if you passed a string with more than 16 pairs.  Routine now
   bails out after 16 pairs.
Admin:
  MemCheck rule of CLI test harness now uses correct MemCheck library,
   so actually does check memory. Only violations appear to be deep
   inside trace library.

  Added debug statement into CLI test harness with 18 levels, and
   verified DebugLib only uses 16. [Unfortunately couldn't verify
   array bounds were(n't) being violated, cos of MemCheck's limited
   stack protection].

  Fiddled with DebugLib's internal debugging so that DebugLib internal
   debug gets labelled with the level "__DebugLib".


Version 0.55. Tagged as 'DebugLib-0_55'
@
text
@d269 36
d997 4
a1000 3
        char *levels;
        if (debug_level_specifier == NULL)
          levels = "";
d1002 11
a1012 2
          levels = debug_level_specifier;
        _dprintf ("", "Levels: %s\n", levels);
@


1.33
log
@  More boolean type changes.
Detail:
  More drastic changes to try and fix all the wonderful variants of
   the boolean type.

  DebugLib now uses <stdbool.h>, "bool", "false" and "true"
   internally.

  DebugLib.h now prototypes its functions with the type DebugLib_BOOL,
   and does preprocessor jiggery-pokery to try and ensure that
   it, plus TRUE, FALSE and BOOL get defined as something appropriate.
Admin:
  Tested by changing some of the test harnesses to include OSLib,
   stdbool and tboxlib headers.
  Fixed test harness module Makefile to include zm versions of
   libraries in all cases.


Version 0.54. Tagged as 'DebugLib-0_54'
@
text
@d149 1
a149 1
/* 1 if the line should be output, and 0 if it shouldn't                */
a151 1
/*             variable - The contents of the system variable           */
d153 1
a153 1
/* Returns:    1 or 0.                                                  */
d156 1
a156 1
static bool debug_check_level (const char *area_level_in, const char *variable)
d164 2
a165 3
#if 0
  /* If variable unset, it's a match */
  if (variable == NULL)
a166 6

  /* If the variable is set and empty, no match */
  if (strlen (variable) == 0)
    return false;
#else
  IGNORE (variable);
d169 1
d173 1
a173 1
  /* If the area_level is NULL, or an empty string it's a match */
d186 1
a186 1
  while ((step = strtok (NULL, ",")) != NULL)
d192 2
a221 2
    /* internal_dprintf (("", "Area = \"%s\", level = %d\n", pairs[i].area, pairs[i].level)); */

d226 2
a227 1
      /* internal_dprintf (("", "sysvar[%d] = %s (%x)\n", j, sysvar_pairs[j].area, sysvar_pairs[j].allowed)); */
d1046 1
a1046 1
  if (debug_check_level (area_level, debug_level_specifier) == true)
d1115 1
a1115 1
  if (debug_check_level (area_level, debug_level_specifier) == true)
d1140 1
a1140 1
  if (debug_check_level (area_level, debug_level_specifier) == true)
@


1.32
log
@  Build changes + doc update
Detail:
  DebugLib now gets the Trace header file from the build system, now
   that it lives there.  Deleted local copy.

  Checked in updated StrongHelp manual that shows deprecation of
   debug_atexit() function, and that no longer tells you to use
   it in the "Setting up the library" section.
Admin:
  Built.


Version 0.52. Tagged as 'DebugLib-0_52'
@
text
@d90 1
a90 1
  BOOL (*initialise)(void);
d95 2
a96 2
  BOOL open;
  BOOL start_of_line;
d101 11
a111 11
  {NULL,               NULL,                 NULL,               FALSE,  TRUE},   /* NULL_OUTPUT */
  {debug_tracker_init, debug_tracker_output, debug_tracker_quit, FALSE,  TRUE},   /* TRACKER_OUTPUT */
  {NULL,               debug_printf_output,  NULL,               FALSE,  TRUE},   /* PRINTF_OUTPUT */
  {NULL,               NULL,                 NULL,               FALSE,  TRUE},   /* NOTUSED_OUTPUT */
  {debug_pdebug_init,  debug_pdebug_output,  debug_pdebug_quit,  FALSE,  TRUE},   /* PDEBUG_OUTPUT */
  {debug_socket_init,  debug_socket_output,  debug_socket_quit,  FALSE,  TRUE},   /* SOCKET_OUTPUT */
  {debug_debugit_init, debug_debugit_output, NULL,               FALSE,  TRUE},   /* DEBUGIT_OUTPUT */
  {debug_tml_init,     debug_tml_output,     NULL,               FALSE,  TRUE},   /* TML_OUTPUT */
  {debug_file_init,    debug_file_output,    debug_file_quit,    FALSE,  TRUE},   /* FILE_OUTPUT */
  {debug_serial_init,  debug_serial_output,  debug_serial_quit,  FALSE,  TRUE},   /* SERIAL_OUTPUT */
  {NULL,               NULL,                 NULL,               FALSE,  TRUE}    /* UNSET_OUTPUT */
d157 1
a157 1
static BOOL debug_check_level (const char *area_level_in, const char *variable)
d168 1
a168 1
    return TRUE;
d172 1
a172 1
    return FALSE;
d178 1
a178 1
    return TRUE;
d182 1
a182 1
    return TRUE;
d268 1
a268 1
    return TRUE;
d270 1
a270 1
    return FALSE;
d334 1
a334 1
    debug_current_options.unbuffered_files = TRUE;
d337 1
a337 1
    debug_current_options.unbuffered_files = FALSE;
d539 1
a539 1
  if (methods[device].open == TRUE)
d554 1
a554 1
    methods[device].open = FALSE;
d577 1
a577 1
  if (debug_current_options.taskname_prefix == TRUE  && device != TRACKER_OUTPUT)
d581 1
a581 1
  if (debug_current_options.stamp_debug == TRUE)
d594 1
a594 1
  if (debug_current_options.area_level_prefix == TRUE)
d636 3
a638 3
  if ((debug_current_options.taskname_prefix == TRUE  && device != TRACKER_OUTPUT) ||
      (debug_current_options.stamp_debug == TRUE) ||
      (debug_current_options.area_level_prefix == TRUE))
d661 1
a661 1
  if (debug_buff_status.enabled != FALSE)
d667 1
a667 1
    BOOL rc = TRUE;
d682 1
a682 1
    if (methods[device].open == FALSE)
d689 2
a690 2
      if (rc == TRUE)
        methods[device].open = TRUE;
d694 1
a694 1
    if (rc == TRUE)
d698 1
a698 1
      if (methods[device].start_of_line == TRUE)
d701 1
a701 1
        methods[device].start_of_line = FALSE;
d714 1
a714 1
            methods[device].start_of_line = TRUE;
d925 1
a925 1
  BOOL rc = FALSE;
d931 1
a931 1
  if (debug_buff_status.enabled == FALSE)
d950 1
a950 1
      rc = TRUE;
d953 1
a953 1
    if (rc == TRUE)
d955 1
a955 1
      methods[device].open = TRUE;
d1052 1
a1052 1
  if (debug_check_level (area_level, debug_level_specifier) == TRUE)
d1121 1
a1121 1
  if (debug_check_level (area_level, debug_level_specifier) == TRUE)
d1146 1
a1146 1
  if (debug_check_level (area_level, debug_level_specifier) == TRUE)
@


1.31
log
@  Changed atexit handling + code tidying
Detail:
  debug_atexit() is now deprecated and DebugLib adds its own atexit
  handler to close down debug devices.  debug_atexit() calls in code
  are now removed by the preprocessor even when DEBUGLIB is defined.
  The atexit handler is added in the debug_initialise() call.

  Tidied debug.c.  Made more functions static, and moved all the static
  functions to before the exported functions.
Admin:
  Built and tested.
  StrongHelp manual updated to reflect atexit change.


Version 0.49. Tagged as 'DebugLib-0_49'
@
text
@d39 1
a39 1
#include "Trace.h"                      /* Trace by JSmith */
@


1.30
log
@  Tidy-up
Detail:
  Stewart's checkin about LibVersion reminded me I'd done some tidying
  (including the LibVersion thing) and not checked it in.  So here it is.

  Tidied Makefile, added standard headers to all the c and h files,
  including the regulation copyright message.

  Changed options.c so that it fits the coding style of the rest of
  DebugLib (naughty Stewart).

  Improved "strdup" routine.

  Moved stripdepend call into Makefile.

Admin:
  Built and tested.


Version 0.47. Tagged as 'DebugLib-0_47'
@
text
@d83 3
a85 1
static const char *debug_always_ignore = " PDebug_* Trace_* remote_debug_* debug_* _dprintf _dvprintf _dfprintf ddumpbuf send sendto select socket socketclose recv recvfrom connect gethostbyname";
d136 1
a136 1
/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */
d139 1
d141 1
a141 1
/* ----------------------------------------- FUNCTIONS ------------------------------------------ */
d525 39
a563 1
/* debug_initialise                                                     */
d565 3
a567 1
/* Function initialises the library                                     */
d569 2
a570 5
/* Parameters: name - name of app that is calling the library.          */
/*             fame - file for debug output to FILE                     */
/*             sysvar - System Variable to override default area/level  */
/*                      specifiying system variable. Uses default if    */
/*                      NULL or "" is passed.                           */
d575 1
a575 1
void debug_initialise (const char *name, const char *fname, const char *sysvar)
d577 67
a643 2
  /* Set default DebugLib options */
  debug_options_initialise ();
d645 20
a664 5
  /* Setup taskname */
  if (debug_current_options.taskname)
    free (debug_current_options.taskname);
  if (name && *name)
    debug_current_options.taskname = debug_misc_strdup (name);
d666 123
a788 1
    debug_current_options.taskname = debug_misc_strdup ("DefaultName");
d790 1
a790 2
  /* Setup filename */
  debug_setup_filename (fname);
d792 3
a794 2
  /* Setup whether we should be doing unbuffered file writes */
  debug_setup_unbuffered ();
d796 4
a799 2
  /* Setup the level specifier */
  debug_setup_level (sysvar);
d801 2
a802 2
  /* Setup the device */
  debug_setup_device ();
d804 1
a804 2
  /* Setup the raw device */
  debug_setup_raw_device ();
d806 2
a807 2
  /* Setup the trace device */
  debug_setup_tracedevice ();
d809 1
a809 2
  /* Setup the buffering code */
  debug_buffer_startup();
d832 3
d836 1
a836 1
/* debug_close_device                                                   */
d838 1
a838 1
/* Function closes the currently active device.                         */
d840 5
a844 1
/* Parameters: device - integer constant for devices.                   */
d849 1
a849 1
void debug_close_device (debug_device device)
d851 25
a875 1
  time_t timer;
d877 2
a878 13
  /* Only close the device if it's open */
  if (methods[device].open == TRUE)
  {
    /* And only send the close text if it's not the raw device */
    if (device != debug_current_options.raw_device)
    {
      time (&timer);
      _dfprintf("",device,"\n***** Debug Session Terminated *************************************\n");
      _dfprintf("", device, "Task: %s\n", debug_current_options.taskname);
      _dfprintf("", device, "Time: %s", ctime(&timer));
      _dfprintf("", device, "%s\n", COPYRIGHT_MESSAGE);
      _dfprintf("", device, "********************************************************************\n");
    }
d880 2
a881 3
    if (methods[debug_current_options.device].quit)
      methods[debug_current_options.device].quit();
    methods[device].open = FALSE;
d883 2
a884 3
    if (device == debug_current_options.device)
      debug_current_options.device = NULL_OUTPUT;
  }
d889 1
a889 1
/* debug_set_device                                                     */
a1004 83
/* debug_output_prefix                                                  */
/*                                                                      */
/* Function outputs the debug output prefix that is needed based on     */
/* the current configuration, and the device identifer that is passed   */
/* in.                                                                  */
/*                                                                      */
/* Parameters: area_level - Levels specified in the _dprintf().         */
/*             device - the debug device to send the buffer to          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_output_prefix (const char *area_level, debug_device device)
{
  if (debug_current_options.taskname_prefix == TRUE  && device != TRACKER_OUTPUT)
  {
    methods[device].output (debug_current_options.taskname, strlen (debug_current_options.taskname));
  }
  if (debug_current_options.stamp_debug == TRUE)
  {
    char buf[20];
    time_t timer;
    struct tm *t;

    time (&timer);

    t = localtime (&timer);

    strftime (buf, sizeof (buf), " %H:%M:%S", t);
    methods[device].output (buf, strlen (buf));
  }
  if (debug_current_options.area_level_prefix == TRUE)
  {
    const char *str;
    char *out;

    if ((area_level == NULL) || (*area_level == '\0'))
      str = "ALERT";
    else
      str = area_level;

    if (debug_current_options.area_pad_limit > 0)
    {
      out = malloc (debug_current_options.area_pad_limit + 1);
      if (out)
      {
        strncpy (out, str, debug_current_options.area_pad_limit);
        if (strlen(str) < debug_current_options.area_pad_limit)
        {
          /* Pad */
          int i;

          for (i=strlen(str) ; i<debug_current_options.area_pad_limit ; i++)
            out[i] = ' ';
          out[i] = '\0';
        }
        else
        {
          /* Truncate */
          out[debug_current_options.area_pad_limit] = '\0';
        }
      }
    }
    else
      out = (char*)str;

    methods[device].output (" [", strlen (" ["));
    methods[device].output (out, strlen (out));
    methods[device].output ("]", strlen ("]"));

    if (debug_current_options.area_pad_limit > 0)
      free (out);
  }
  if ((debug_current_options.taskname_prefix == TRUE  && device != TRACKER_OUTPUT) ||
      (debug_current_options.stamp_debug == TRUE) ||
      (debug_current_options.area_level_prefix == TRUE))
  {
    methods[device].output (": ", strlen (": "));
  }
}


/************************************************************************/
a1039 89
/* debug_output_data                                                    */
/*                                                                      */
/* Function outputs the conventional debuglib output with prefixing,    */
/* timestamping etc.                                                    */
/*                                                                      */
/* Parameters: area_level - Levels specified in the _dprintf().         */
/*             device - the debug device to send the buffer to          */
/*             buffer - data to be streamed.                            */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_output_data (const char *area_level, debug_device device, const char *buffer)
{
  if (debug_buff_status.enabled != FALSE)
  {
    debug_buffer_stream (buffer);
  }
  else
  {
    BOOL rc = TRUE;

    /* If we've been passed an invalid device, don't bother */
    if (device <= NULL_OUTPUT || device >= UNSET_OUTPUT || device == NOTUSED_OUTPUT)
      return;

    /* If the device has no output method, don't bother */
    if (methods[device].output == NULL)
      return;

    /* If we've got an empty string, return too */
    if ((buffer == NULL) || (*buffer == '\0'))
      return;

    /* Check that the output device is open */
    if (methods[device].open == FALSE)
    {
      /* If it's not, initialise it */
      if (methods[device].initialise)
      {
        rc = methods[device].initialise ();
      }
      if (rc == TRUE)
        methods[device].open = TRUE;
    }

    /* And if everything is OK, go ahead and output the buffer */
    if (rc == TRUE)
    {
      const char *stepper = buffer, *match;

      if (methods[device].start_of_line == TRUE)
      {
        debug_output_prefix (area_level, device);
        methods[device].start_of_line = FALSE;
      }
      do
      {
        match = strchr (stepper, '\n');
        if (match)
        {
          /* Output up to and including the \n */
          methods[device].output (stepper, match - stepper + 1);
          stepper = match + 1;
          if (*stepper == NULL)
          {
            /* \n is at the end of "buffer" */
            methods[device].start_of_line = TRUE;
          }
          else
          {
            /* \n in middle of "buffer" */
            debug_output_prefix (area_level, device);
          }
        }
        else
        {
          /* No more \ns */
          methods[device].output (stepper, strlen (stepper));
        }
      }
      while ((match != NULL) && (*stepper != NULL));
    }
  }
}


/************************************************************************/
a1230 78

/************************************************************************/
/* debug_trace_enter                                                    */
/*                                                                      */
/* Function is called when a function is entered provided trace is      */
/* running.                                                             */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_trace_enter (const char *fname)
{
  int i = 0;
  char *buffer;
  char buffer2[256];

  buffer = malloc (strlen ("Trace: 999:")+(strlen(" |")*debug_global_indent)+strlen(" \n")+strlen (fname)+1);

  if (buffer)
  {
    sprintf (buffer, "Trace: %3d:", debug_global_indent);

    for (i = 0; i < debug_global_indent; i++)
    {
      strcat (buffer, " |");
    }
    sprintf (buffer2, " %s\n", fname);
    strcat (buffer, buffer2);

    _dfprintf ("Trace", debug_current_options.trace_device, buffer);

    free (buffer);
  }

  debug_global_indent++;
}


/************************************************************************/
/* debug_trace_exit                                                     */
/*                                                                      */
/* Function is called when a function is exited provided trace is       */
/* running.                                                             */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_trace_exit (const char* fname)
{
  int i = 0;
  char *buffer;
  char buffer2[256];

  buffer = malloc (strlen ("Trace: 999:")+(strlen(" |")*debug_global_indent)+strlen("~\n")+strlen (fname)+1);

  if (buffer)
  {
    sprintf (buffer, "Trace: %3d:", debug_global_indent-1);

    for (i=0; i < debug_global_indent-1; i++)
    {
      strcat (buffer, " |");
    }

    sprintf (buffer2, "~%s\n", fname);
    strcat (buffer, buffer2);

    _dfprintf ("Trace", debug_current_options.trace_device, buffer);

    free (buffer);
  }

  debug_global_indent--;
}
@


1.29
log
@ * Updated DebugLib StrongHelp manual to add information on the use of
   the debug level specifier.

 * DebugLib.h now exports the remotedb session handle, this should mean
   that apps can use the 2-way capabilites of remotedb to control their
   applications via remotedb-sent commands.  Note that the new function
   call debug_read_device should be used to check the current DebugLib
   device is SOCKET_OUTPUT and that the remotedb session handle is valid
   before registering a remotedb command handler.  Added for use by
   NCFresco.


Version 0.42. Tagged as 'DebugLib-0_42'
@
text
@d22 8
a31 1

d342 12
d543 1
a543 1
  if (name && strlen (name))
d628 11
d744 13
a756 1
/* */
@


1.28
log
@ * Improved DebugLib's area handling system.  Lines of debug may now belong
   to multiple "areas" of code, each at a specific level.  The filtering of
   debug at runtime is now done with a much more flexible system,
   areas/levels are masked in/out based on a new format for the
   DebugLib$Level_<taskname> system variable.  The description of this
   format has not made it into the StrongHelp document, it will go into
   this, and into the DebugLib web docs ASAP.

 * Added a new option to allow the area/level prefix in debug output to
   be padded to a particular width.  This makes the prefix much more
   useable.  The prefixing is turned on with the option
   "debug_set_area_level_prefix", and the padding controlled with
   "debug_set_area_pad_limit".

 * Added test cases for new levelling scheme into CLI test harness.

 * Updated StrongHelp manual somewhat.


Version 0.41. Tagged as 'DebugLib-0_41'
@
text
@d609 13
@


1.27
log
@ * Fixed the logic in debug_close_device.  The changes made for raw mode
   meant that the raw device wouldn't be closed.

 * Changed the copyright messages a little.


Version 0.40. Tagged as 'DebugLib-0_40'
@
text
@d47 1
d70 1
a70 1
static char *level_specifier = NULL;            /* Contents of area-level specifying sys var */
d74 1
a74 1
static int global_indent = 0;
d76 1
a76 1
static const char *always_ignore = " PDebug_* Trace_* remote_debug_* debug_* _dprintf _dvprintf _dfprintf ddumpbuf send sendto select socket socketclose recv recvfrom connect gethostbyname";
d105 21
d147 1
a147 1
static int debug_check_level (const char *area_level_in, const char *variable)
d149 5
a153 5
  char *match;
  int matched = 0;
  int area_level_len, area_len, var_len, offset;
  char *area, *area_level = NULL;
  int level = 0, var_level = 0;
d155 1
d158 1
a158 1
    return 1;
d162 7
a168 1
    return 0;
d170 3
a172 3
  /* If the area_level is NULL, it's a match */
  if (area_level_in == NULL)
    return 1;
d174 1
a174 1
  area_level_len = strlen (area_level_in);
d176 1
a176 3
  /* If the area_level is empty, it's a match */
  if (area_level_len == 0)
    return 1;
d178 1
a178 3
  area_level = malloc (strlen (area_level_in) + 1);
  strcpy (area_level, area_level_in);
  area = area_level;
d180 4
a183 1
  if ((area_level_len - 2) > 0)
d185 3
a187 8
    /* It's possible to have "A_5" */
    if (isdigit (area_level[area_level_len - 1]) != 0)     /* area_level = "Area_4" */
    {
      /* area_level has an explicit level embedded */
      area_level[area_level_len - 2] = '\0';
      level = atoi (&area_level[area_level_len - 1]);
    }
  }
d189 2
a190 1
  if ((area_level_len - 1) > 0)
d192 4
a195 2
    /* It's possible to have "A_" */
    if (area_level[area_level_len - 1] == '_')   /* area_level = "Area_" */
d197 1
a197 10
      /* area_level has an '_', but no explicit level */
      area_level[area_level_len - 1] = '\0';
      level = 0;
    }
  }
  else
  {
    /* area_level has no explicit level embedded */
    level = 0;
  }
d199 7
a205 9
  var_len = strlen (variable);
  area_len = strlen (area);

  if ((match = strstr (variable, area)) != NULL)
  {
    internal_dprintf (("", "match = \"%s\"\n", match));
    if (match != variable)
    {
      if (*(match-1) != ' ' && *(match-1) != ',')
d207 2
a208 2
        /* No match */
        return 0;
d211 5
d217 1
a217 1
    offset = (int) match - (int) variable;
d219 1
a219 1
    internal_dprintf (("", "offset = %d,  var_len = %d,  area_len = %d\n", offset, var_len, area_len));
d221 1
a221 1
    if (area_len + offset > var_len)
d223 3
a225 19
      /* No match, we've fallen off the end of the system variable */
      internal_dprintf (("", "Fallen off end\n"));
      return 0;
    }
    else if (area_len + offset == var_len)  /* match = "Area" */
    {
      /* No level in variable, we want everything */
      var_level = 9;
      matched = 1;
    }
    else if (match[area_len] == ',')  /* match = "Area," */
    {
      /* No level in variable, we want everything */
      var_level = 9;
      matched = 1;
    }
    else if (area_len + offset + 1 < var_len)
    {
       if ((match[area_len] == '_') && (!isdigit (match[area_len+1]))) /* match = "Area_" */
d227 14
a240 3
        /* No level in variable, we want everything */
        var_level = 9;
        matched = 1;
d242 2
a243 1
      else if (match[area_len] == '_' && isdigit (match[area_len+1]))  /* match = "Area_4" */
d245 5
a249 3
        /* level supplied in variable */
        var_level = atoi (&match[area_len+1]);
        matched = 1;
a250 2
      else
        matched = 0;
a251 2
    else
      matched = 0;
a252 2
  else
    matched = 0;
d254 2
a255 2
  if (area_level)
    free (area_level);
d257 2
a258 7
  if (matched == 1)
  {
    if (var_level >= level)
      return 1;
    else
      return 0;
  }
d260 1
a260 1
    return 0;
d263 1
d335 7
d371 3
a373 3
  if (level_specifier != NULL)
    free (level_specifier);
  level_specifier = debug_misc_getenv_malloc (tmp_sysvar_name);
d378 6
d665 1
a665 1
        if (level_specifier == NULL)
d668 1
a668 1
          levels = level_specifier;
a706 1
    methods[device].output (": ", strlen (": "));
d718 1
a718 1
    strftime (buf, sizeof (buf), "%H:%M:%S - ", t);
d723 2
a724 1
    const char *out;
d727 1
a727 1
      out = "ALERT";
d729 1
a729 1
      out = area_level;
d731 26
a756 1
    methods[device].output ("[", strlen ("["));
d758 10
a767 1
    methods[device].output ("] ", strlen ("] "));
d909 1
a909 1
  if (debug_check_level (area_level, level_specifier) == 1)
d978 1
a978 1
  if (debug_check_level (area_level, level_specifier) == 1)
d1003 1
a1003 1
  if (debug_check_level (area_level, level_specifier) == 1)
d1106 1
a1106 1
  buffer = malloc (strlen ("Trace: 999:")+(strlen(" |")*global_indent)+strlen(" \n")+strlen (fname)+1);
d1110 1
a1110 1
    sprintf (buffer, "Trace: %3d:", global_indent);
d1112 1
a1112 1
    for (i = 0; i < global_indent; i++)
d1124 1
a1124 1
  global_indent++;
d1145 1
a1145 1
  buffer = malloc (strlen ("Trace: 999:")+(strlen(" |")*global_indent)+strlen("~\n")+strlen (fname)+1);
d1149 1
a1149 1
    sprintf (buffer, "Trace: %3d:", global_indent-1);
d1151 1
a1151 1
    for (i=0; i < global_indent-1; i++)
d1164 1
a1164 1
  global_indent--;
d1189 1
a1189 1
  global_indent++;
d1196 1
a1196 1
  len = len2 + strlen (always_ignore) + 1;
d1210 1
a1210 1
  strcat (ignore_fns, always_ignore);
@


1.26
log
@Summary
-------
  * Initial checkin of code to allow data to be output in a raw form.
  * Added copyright messages to DebugLib.h (the exported header) as
    DebugLib has now been shipped to one customer.
Detail
------
  * Two new functions debug_set_raw_device() and dprintf_raw() have been
    added to debug.c.  This allows debug data to be output unprocessed;
    i.e. without taskname prefixing, timestamping etc.  This was done for
    HierProf, MemCheck and McCabe.  This is especially important for McCabe
    as no formatting must be done to the output generated by the program.
    Subject to testing against McCabe, it will be possible to send output
    for analysis via any debug stream (except RemoteDB due to the nature
    of the daemon).  DebugLib$RawDevice_<taskname> can be used to override
    debug_set_raw_device().
Admin
-----
  * Tested that the data is output in a raw form.  Testing with McCabe
    not yet accomplished.

Version 0.39. Tagged as 'DebugLib-0_39'
@
text
@d564 2
a565 2
  /* Only send the close text if (a) the device is open, and (b) if it isn't the raw device */
  if ( (methods[device].open == TRUE) && (device != debug_current_options.raw_device) )
d567 10
a576 6
    time (&timer);
    _dfprintf("",device,"\n***** Debug Session Terminated *************************************\n");
    _dfprintf("", device, "Task: %s\n", debug_current_options.taskname);
    _dfprintf("", device, "Time: %s", ctime(&timer));
    _dfprintf("", device, "%s\n", COPYRIGHT_MESSAGE);
    _dfprintf("", device, "********************************************************************\n");
a679 1

a786 13

#if 0
    /* If we're doing a dfprintf ... */
    if (device != debug_current_options.device)
    {
      /* And we're doing it to a file ... */
      if (device == FILE_OUTPUT)
      {
        /* ... we don't know how to handle this situation yet */
        return;
      }
    }
#endif
@


1.25
log
@ * Continued tidy-up of DebugLib:

 * All DebugLib functions now namespaced, they all start debug_<filename>_
  (except the functions in debug.c which are debug_).

 * Device specific #defines etc moved into device specific header files,
   e.g. debugit.h

 * Moved taskname prefixing to a central location, moved timestamping here
   also, added area/level prefixing, and tidied up this prefixing to make
   sure it looks good on all the possible debug devices.

 * Can now do any debuglib function to any debug device, including trace
   output, this hasn't been the case for a while.

 * Added new option, to set whether you want to prefix all debug lines
   with the area/level pair specified in dprintf, dfprintf etc.  Added
   new function to set this option.  debug_set_area_level_prefix ()

 * remotedb output now uses new "raw" output mode added to remotedb in
   version 0.06.  _DebugLib now requires remotedb version >= 0.06_

 * Added new test cases into CLI_App test harness, and changed a few things
   in TestMod.

 * Added Memcheck misc block registration into buffering code, which allows
   buffering to be used on the DebugLib Memcheck build.

 * Added lots of new function names into the always_ignore field which is
   used to tell trace which functions to ignore.  It seems that some the
   internet libraries have function names emebedded, which causes horrible
   loops when using DebugLib to output trace info to remotedb.  Also added
   debug_* and remote_debug_*

 * Added StrongHelp topics for ddumpbuf, debug_output_buffer_* and
   debug_set_area_level_prefix.  Updated the "Setting up the library"
   section.

 * Checked with all the debug devices except TML and serial.


Version 0.38. Tagged as 'DebugLib-0_38'
@
text
@d63 3
d105 4
d404 40
d520 3
d564 2
a565 1
  if (methods[device].open == TRUE)
d568 5
a572 4
    _dfprintf ("", device, "\n***** Debug Session Terminated ***********************************\n");
    _dfprintf ("", device, "Task: %s\n", debug_current_options.taskname);
    _dfprintf ("", device, "Time: %s", ctime(&timer));
    _dfprintf ("", device, "******************************************************************\n");
d632 1
d659 18
d719 38
a756 1
/* Parameters: device - the debug device to send the buffer to          */
d758 1
d763 1
a763 1
void debug_output (const char *area_level, debug_device device, const char *buffer)
d867 1
a867 1
    debug_output (area_level, debug_current_options.device, debug_buffer);
d893 27
d939 1
a939 1
    debug_output (area_level, device, debug_buffer);
d982 1
a982 1
          debug_output (area_level, debug_current_options.device, debug_buffer);
d1006 1
a1006 1
      debug_output (area_level, debug_current_options.device, debug_buffer);
a1133 1

@


1.24
log
@ * Continued tidy of DebugLib structure/implementation...added an "Open"
   variable to the debug_output_method structure, to replace the
   sessions_available struct that was used previously.  Now check for
   whether a device is open at the top level (debug.c) instead of once
   for each device.  Removed the "quit" function for a few devices, because
   it was doing nothing.
 * Reduced global variable count to 1. :)

 * Split option setting functions to options.[ch], left debug_set_device
   in c.debug, as it does a bit more that just set an option.


Version 0.37. Tagged as 'DebugLib-0_37'
@
text
@d31 5
d72 1
a72 1
static const char *always_ignore = " PDebug_* Trace_* remote_debug_open debug_printf";
d78 1
a78 1
  void (*output)(const char *);
d83 1
d88 11
a98 11
  {NULL,               NULL,                 NULL,               FALSE},   /* NULL_OUTPUT */
  {debug_tracker_init, debug_tracker_output, debug_tracker_quit, FALSE},   /* TRACKER_OUTPUT */
  {NULL,               debug_printf_output,  NULL,               FALSE},   /* PRINTF_OUTPUT */
  {NULL,               NULL,                 NULL,               FALSE},   /* NOTUSED_OUTPUT */
  {debug_pdebug_init,  debug_pdebug_output,  debug_pdebug_quit,  FALSE},   /* PDEBUG_OUTPUT */
  {debug_socket_init,  debug_socket_output,  debug_socket_quit,  FALSE},   /* SOCKET_OUTPUT */
  {debug_debugit_init, debug_debugit_output, NULL,               FALSE},   /* DEBUGIT_OUTPUT */
  {debug_tml_init,     debug_tml_output,     NULL,               FALSE},   /* TML_OUTPUT */
  {debug_file_init,    debug_file_output,    debug_file_quit,    FALSE},   /* FILE_OUTPUT */
  {debug_serial_init,  debug_serial_output,  debug_serial_quit,  FALSE},   /* SERIAL_OUTPUT */
  {NULL,               NULL,                 NULL,               FALSE}    /* UNSET_OUTPUT */
d270 1
a270 1
  debug_current_options.filename = misc_getenv_malloc (tmp_sysvar_name);
d275 1
a275 1
      debug_current_options.filename = debug_strdup (fname);
d305 1
a305 1
  tmp_string = misc_getenv_malloc (tmp_sysvar_name);
d339 1
a339 1
    tmp_sysvar_name = debug_strdup (sysvar);
d351 1
a351 1
  level_specifier = misc_getenv_malloc (tmp_sysvar_name);
d382 1
a382 1
  tmp_string = misc_getenv_malloc (tmp_sysvar_name);
d418 1
a418 1
  tmp_string = misc_getenv_malloc (tmp_sysvar_name);
d457 1
a457 1
    debug_current_options.taskname = debug_strdup (name);
d459 1
a459 1
    debug_current_options.taskname = debug_strdup ("DefaultName");
d477 1
a477 1
  buffer_startup();
d495 1
a495 1
  for (i = TRACKER_OUTPUT; i < UNSET_OUTPUT; i++)
d551 1
a551 1
  if (buff_status.enabled == FALSE)
d581 1
a581 1
      _dprintf ("", "        remotedb %s\n", remotedb_version());
d596 44
d654 1
a654 1
void debug_output (debug_device device, const char *buffer)
d656 1
a656 1
  if (buff_status.enabled != FALSE)
d658 1
a658 1
    buffer_stream (buffer);
d664 2
a665 1
    if (device < NULL_OUTPUT || device > UNSET_OUTPUT)
d668 10
d680 1
d683 1
a683 1
        /* Don't know how to handle this situation yet */
d686 8
a693 1
      if (methods[device].open == FALSE)
d695 1
a695 6
        if (methods[device].initialise)
        {
          rc = methods[device].initialise ();
        }
        if (rc == TRUE)
          methods[device].open = TRUE;
d697 2
d701 1
d704 33
a736 2
      if (methods[device].output)
        methods[device].output (buffer);
d755 1
a755 1
  if (debug_check_level(area_level, level_specifier) == 1)
d757 2
a758 16
    vsprintf(debug_buffer, format, arg);

    if (debug_current_options.stamp_debug == TRUE)
    {
      char buf[20];
      time_t timer;
      struct tm *t;

      time (&timer);

      t = localtime (&timer);

      strftime (buf, sizeof (buf), "%H:%M:%S - ", t);
      debug_output (debug_current_options.device, buf);
    }
    debug_output(debug_current_options.device, debug_buffer);
d803 1
a803 1
    debug_output (device, debug_buffer);
d846 1
a846 1
          debug_output (debug_current_options.device, debug_buffer);
d870 1
a870 1
      debug_output (debug_current_options.device, debug_buffer);
d922 1
a922 1
  char buffer[1024];
d925 1
a925 1
  sprintf (buffer, "Trace: %3d:", global_indent);
d927 1
a927 2
  /* _dfprintf ("", debug_current_options.trace_device, "Trace: %3d:", global_indent); */
  for (i = 0; i < global_indent; i++)
d929 12
a940 2
    strcat (buffer, " |");
    /*stream_debug_output (debug_current_options.trace_device, " |");*/
a941 4
  sprintf (buffer2, " %s\n", fname);
  strcat (buffer, buffer2);

  _dfprintf ("Trace", debug_current_options.trace_device, buffer);
d961 1
a961 1
  char buffer[1024];
d964 1
a964 1
  sprintf (buffer, "Trace: %3d:", global_indent-1);
d966 1
a966 2
  /*_dfprintf ("", debug_current_options.trace_device, "Trace: %3d:", global_indent-1);*/
  for (i=0; i < global_indent-1; i++)
d968 9
a976 3
    strcat (buffer, " |");
    /*stream_debug_output (debug_current_options.trace_device, " |");*/
  }
d978 1
a978 2
  sprintf (buffer2, "~%s\n", fname);
  strcat (buffer, buffer2);
d980 2
a981 1
  _dfprintf ("Trace", debug_current_options.trace_device, buffer);
a983 1
  /*_dfprintf ("", debug_current_options.trace_device, "~%s\n", fname); */
d999 1
a999 1
void debug_initialise_trace (debug_device stream, const char *fns)
d1005 1
a1005 1
    debug_current_options.trace_device = stream;
@


1.23
log
@ * Initial work on tidying design of DebugLib.  Each output method is now
   more or less independant, and in its own file.  The common functions
   of each debug output method are accessed using an array of function
   pointers.  In the fullness of time this should make it easy to add new
   devices (and perhaps some cunning stuff with the linker).

 * Code re-org has been tested, and seen to work for at least one debug
   method.


Version 0.35. Tagged as 'DebugLib-0_35'
@
text
@a30 1
#include "debug.h"
d32 1
a32 1
#include "globals.h"
d42 2
a46 2

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */
a50 15
int serial_handle = 0;

FILE *debug_file_pointer = NULL;          /* File pointer */

debug_session *remotedb_info;           /* RemoteDB handler */

SessionsAvailable sessions_available;

int tracker_window_handle = -1;

BOOL pdebug_error = FALSE;

debug_device sysvar_provided_device = UNSET_OUTPUT;    /* The variable to hold output device specified by
                                                          system variable */

d55 3
d59 1
a59 1
                                                          specified by system variable */
d75 3
d82 11
a92 11
  {NULL,               NULL,                 NULL},                 /* NULL_OUTPUT */
  {debug_tracker_init, debug_tracker_output, debug_tracker_quit},   /* TRACKER_OUTPUT */
  {NULL,               debug_printf_output,  NULL},                 /* PRINTF_OUTPUT */
  {NULL,               NULL,                 NULL},                 /* NOTUSED_OUTPUT */
  {debug_pdebug_init,  debug_pdebug_output,  debug_pdebug_quit},    /* PDEBUG_OUTPUT */
  {debug_socket_init,  debug_socket_output,  debug_socket_quit},    /* SOCKET_OUTPUT */
  {debug_debugit_init, debug_debugit_output, debug_debugit_quit},   /* DEBUGIT_OUTPUT */
  {debug_tml_init,     debug_tml_output,     debug_tml_quit},       /* TML_OUTPUT */
  {debug_file_init,    debug_file_output,    debug_file_quit},      /* FILE_OUTPUT */
  {debug_serial_init,  debug_serial_output,  debug_serial_quit},    /* SERIAL_OUTPUT */
  {NULL,               NULL,                 NULL}                  /* UNSET_OUTPUT */
a94 4
/* ------------------------------------ FUNCTION PROTOTYPES ------------------------------------- */

void debug_trace_enter (const char *);
void debug_trace_exit (const char *);
a428 27
/* debug_initialise_options                                             */
/*                                                                      */
/* Function initialises the library's options to default values         */
/*                                                                      */
/* Parameters: none                                                     */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_initialise_options (void)
{
  debug_current_options.taskname = NULL;
  debug_current_options.filename = NULL;
  debug_current_options.device = NULL_OUTPUT;
  debug_current_options.trace_device = NULL_OUTPUT;
  debug_current_options.taskname_prefix = TRUE;
  debug_current_options.stamp_debug = FALSE;
  debug_current_options.screen_cornering = TRUE;
  debug_current_options.unbuffered_files = FALSE;
  debug_current_options.serial_lf = TRUE;
  debug_current_options.serial_port_speed = SerialPort_DefaultSpeed;
  debug_current_options.serial_port_number = SerialPort_DefaultPort;
  debug_current_options.dump_width = DumpWidth_DefaultWidth;
}


/************************************************************************/
d444 2
a445 10
  /* No open debug devices */
  sessions_available.debugit = FALSE;
  sessions_available.tml = FALSE;
  sessions_available.remotedb = FALSE;
  sessions_available.tracker = FALSE;
  sessions_available.pdebug = FALSE;
  sessions_available.serial = FALSE;

  /* Set default debuglib options */
  debug_initialise_options ();
a474 101
void debug_set_trace_device (debug_device device)
{
  debug_current_options.trace_device = device;
}

void debug_set_taskname_prefix (BOOL on)
{
  debug_current_options.taskname_prefix = on;
}

void debug_set_stamp_debug (BOOL on)
{
  debug_current_options.stamp_debug = on;
}

void debug_set_screen_cornering (BOOL on)
{
  debug_current_options.screen_cornering = on;
}

void debug_set_unbuffered_files (BOOL on)
{
  debug_current_options.unbuffered_files = on;
}

void debug_set_serial_lf (BOOL on)
{
  debug_current_options.serial_lf = on;
}

void debug_set_serial_port_speed (int speed)
{
  debug_current_options.serial_port_speed = speed;
}

void debug_set_serial_port_number (int num)
{
  debug_current_options.serial_port_number = num;
}

void debug_set_dump_width (size_t width)
{
  debug_current_options.dump_width = width;
}


/************************************************************************/
/* debug_set_options                                                    */
/*                                                                      */
/* Function sets up debuglib options.                                   */
/*                                                                      */
/* Parameters: options - Bit 0 Set,    Enable taskname prefixing (def). */
/*                             Unset,  Disable taskname prefixing.      */
/*                     - Bit 1 Set,    Add \r to serial output (def).   */
/*                             Unset,  No \r.                           */
/*                     - Bit 2 Set,    Enable printf "screen cornering" */
/*                                     i.e. each successive "printf"    */
/*                                     output is sent to the top-left   */
/*                                     corner of the screen (default)   */
/*                             Unset,  Disable "screen cornering"       */
/*             sport   - Serial port to use (1|2) - def = 1.            */
/*             sspeed  - Serial port speed (300 - 115200) - def = 9600. */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_set_options (unsigned int options, int sport, int sspeed)
{
  /* Task prefixing */
  if (options & DebugLib_Options_TasknamePrefix_On)
    debug_current_options.taskname_prefix = TRUE;
  else
    debug_current_options.taskname_prefix = FALSE;

  /* Serial port \r */
  if (options & DebugLib_Options_SerialPortLF_On)
    debug_current_options.serial_lf = TRUE;
  else
    debug_current_options.serial_lf = FALSE;

  /* Serial port number */
  if ((sport > 0) && (sport < 3))
    debug_current_options.serial_port_number = sport;

  /* Serial port speed */
  if ((sspeed >= 300) && (sspeed <= 115200))
    debug_current_options.serial_port_speed = sspeed;

  /* Printf "screen cornering (TM)" */
  if (options & DebugLib_Options_ScreenCornering_On)
    debug_current_options.screen_cornering = TRUE;
  else
    debug_current_options.screen_cornering = FALSE;

  if (options & DebugLib_Options_StampDebug_On)
    debug_current_options.stamp_debug = TRUE;
  else
    debug_current_options.stamp_debug = FALSE;
}


d487 1
a487 1
  debug_close_device ();
d489 2
a490 7
  debug_debugit_quit ();
  debug_file_quit ();
  debug_pdebug_quit ();
  debug_socket_quit ();
  debug_tml_quit ();
  debug_tracker_quit ();
  debug_serial_quit ();
d504 1
a504 1
void debug_close_device (void)
d508 15
a522 9
  time (&timer);
  _dprintf ("", "\n***** Debug Session Terminated ***********************************\n");
  _dprintf ("", "Task: %s\n", debug_current_options.taskname);
  _dprintf ("", "Time: %s", ctime(&timer));
  _dprintf ("", "******************************************************************\n");

  if (methods[debug_current_options.device].quit)
    methods[debug_current_options.device].quit();
  debug_current_options.device = NULL_OUTPUT;
d559 1
a559 1
    debug_close_device ();
d566 1
a566 2
    /* If we've initialised correctly, set the debug
       device */
d568 2
d572 16
a587 14
    time (&timer);
    _dprintf ("", "\n***** Debug Session Started **************************************\n");
    _dprintf ("", "System: DebugLib %s\n", debug_version());
    _dprintf ("", "        remotedb %s\n", remotedb_version());
    _dprintf ("", "        PDebug %s\n", PDebug_Version());
    _dprintf ("", "Task:   %s\n", debug_current_options.taskname);
    _dprintf ("", "Time:   %s", ctime(&timer));
    {
      char *levels;
      if (level_specifier == NULL)
        levels = "";
      else
        levels = level_specifier;
      _dprintf ("", "Levels: %s\n", levels);
a588 1
    _dprintf ("", "******************************************************************\n");
d598 2
a599 1
/* Parameters: buffer - data to be streamed.                            */
d604 1
a604 1
void debug_output (const char *buffer)
d612 3
a614 1
    if (debug_current_options.device < NULL_OUTPUT || debug_current_options.device > UNSET_OUTPUT)
d617 23
a639 2
    if (methods[debug_current_options.device].output)
      methods[debug_current_options.device].output (buffer);
d672 1
a672 1
      debug_output (buf);
d674 1
a674 1
    debug_output(debug_buffer);
a699 50
/* debug_beep                                                           */
/*                                                                      */
/* Function makes a beep when called                                    */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_beep (void)
{
  _swix (OS_WriteI + 7, 0);
}


/************************************************************************/
/* stream_debug_output                                                  */
/*                                                                      */
/* Function sends the debugging data to the specified stream.           */
/*                                                                      */
/* Parameters: buffer - data to be streamed.                            */
/*             stream - place to send it.                               */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void stream_debug_output (debug_device device, const char *buffer)
{
  BOOL rc;

  if (device < NULL_OUTPUT || device > UNSET_OUTPUT)
    return;

  if (methods[device].initialise)
    rc = methods[device].initialise();
  else
    rc = TRUE;

  if (rc == TRUE)
  {
    if (device != FILE_OUTPUT)
    {
      if (methods[device].output)
        methods[device].output (buffer);
    }
  }
}


/************************************************************************/
d709 1
a709 1
void _dfprintf (const char *area_level, debug_device stream, const char *format, ...)
d719 1
a719 4
    if (stream == debug_current_options.device)
      debug_output (debug_buffer);
    else
      stream_debug_output (stream, debug_buffer);
d723 1
d736 1
a736 1
void ddumpbuf(const char *area_level, const void *buffer, size_t size, size_t offset)
d750 10
a759 6
    while (i < end) {
      if ((i % width) == 0) {
        if (i) {
          db += sprintf(db, ": ");
          for (j = i - width; j != i; ++j) {
            db += sprintf(db, "%c", (membuf[j]>=32 && membuf[j] != 0x7f) ? membuf[j] : '.');
d761 2
a762 2
          sprintf(db, "\n");
          debug_output (debug_buffer);
d765 1
a765 1
        db += sprintf(db, "%04x: ", i + offset);
d768 3
a770 2
      if (i>=size) {
        db += sprintf(db, "   ");
d772 3
a774 2
      else {
        db += sprintf(db, "%02x ", membuf[i]);
d779 5
a783 3
    if (i) {
      for (db += sprintf(db, ": "), j = i - width; j != i; ++j) {
        db += sprintf(db, "%c", j>=size ? ' ' : (membuf[j]>=32 && membuf[j] != 0x7f) ? membuf[j] : '.');
d785 2
a786 2
      sprintf(db, "\n");
      debug_output (debug_buffer);
a787 1

d793 1
a793 1
/* debug_initialise_trace                                               */
d795 1
a795 1
/* Function initialises the trace library.                              */
d797 1
a797 2
/* Parameters: stream - Debug output stream to use.                     */
/*             fns    - Functions to ignore                             */
d802 1
a802 2

void debug_initialise_trace (debug_device stream, const char *fns)
d804 2
a805 7
  char *ignore_fns;
  int len, len2;

  if (sysvar_provided_tracedevice == UNSET_OUTPUT)
    debug_current_options.trace_device = stream;
  else
    debug_current_options.trace_device = sysvar_provided_tracedevice;
a806 1
  global_indent++;
d808 13
a820 29
  if (fns == NULL)
    len2 = 0;
  else
    len2 = strlen (fns);

  len = len2 + strlen (always_ignore) + 1;

  if ((ignore_fns = malloc (len)) == NULL)
  {
    return;
  }

  /* Buffer allocated, so add the PDebug, Trace and remotedb functions onto the end of the list */

  if (len2 > 0)
    strcpy (ignore_fns, fns);
  else
    ignore_fns[0] = '\0';

  strcat (ignore_fns, always_ignore);

  Trace_IgnoreFunctions (ignore_fns);
  Trace_SetHandlers (
                     (Trace_fnstarthandler)debug_trace_enter,
                     (Trace_fnstophandler)debug_trace_exit
                    );
  Trace_InterceptAllFunctions ();

  free (ignore_fns);
d835 1
a835 1
void debug_trace_enter (const char *fname)
d869 1
a869 1
void debug_trace_exit (const char* fname)
d895 1
a895 1
/* debug_version                                                        */
d897 1
a897 1
/* Function returns the library's version number.                       */
d899 2
a900 1
/* Parameters: none.                                                    */
d902 1
a902 1
/* Returns:    Pointer to const string containg version number.         */
d905 2
a906 1
const char *debug_version (void)
d908 39
a946 1
  return debug_version_string;
@


1.22
log
@  Buffer dumper added.
  A handful of miscellaneous header file fixes.
Detail:
  ddumpbuf(area, buffer pointer, size of buffer, offset) added to enable
    binary data to be dumped out to debug.
  debug_set_dump_width(width) sets the number of bytes of data per line
    of debug output.  This must be a positive integer greater than zero
    and less than 64.
  Macro out of serial port function fixed.
  Pragma declarations fixed.
Admin:
  Modified CLI test program to dump buffers out and verified the widthing
    and offset work.

Version 0.34. Tagged as 'DebugLib-0_34'
@
text
@a31 3
#include "inits.h"
#include "output.h"
#include "quits.h"
d34 8
d82 23
d639 7
a645 7
  quit_debugit ();
  quit_file ();
  quit_pdebug ();
  quit_socket ();
  quit_tml ();
  quit_tracker ();
  quit_serial();
d669 2
a670 18
  switch (debug_current_options.device)
  {
    case FILE_OUTPUT:
      quit_file ();
      break;

    case PDEBUG_OUTPUT:
      quit_pdebug ();
      break;

    case SOCKET_OUTPUT:
      quit_socket ();
      break;

    case TRACKER_OUTPUT:
      quit_tracker ();
      break;
  }
d690 4
d710 4
a713 55
    switch (device)
    {
      /* !List Debug output device */
      case DEBUGIT_OUTPUT:
        rc = init_debugit ();
        break;

      /* FILE Output */
      case FILE_OUTPUT:
        rc = init_file ();
        break;

      /* PDebug Output */
      case PDEBUG_OUTPUT:
        /* Check that module is present */
        rc = init_pdebug ();
        break;

      case SERIAL_OUTPUT:
        rc = init_serial();
        break;

      /* Sockets */
      case SOCKET_OUTPUT:
        rc = init_socket ();
        break;

      /* TML Output */
      case TML_OUTPUT:
        /* Check that module is present */
        rc = init_tml ();
        break;

      /* Tracker Output */
      case TRACKER_OUTPUT:
        /* Check that module is present */
        rc = init_tracker ();
        break;

      /* Printf Output */
      case PRINTF_OUTPUT:
        /* No initialisation to do */
        rc = TRUE;
        break;

      /* No output */
      case NULL_OUTPUT:
        rc = TRUE;
        break;

      /* Undefined device, treat as no output */
      default:
        device = NULL_OUTPUT;
        rc = TRUE;
    }
d750 1
a750 1
void debug_output (const char *stream)
d754 1
a754 1
    buffer_stream(stream);
d758 5
a762 47
    switch (debug_current_options.device)
    {
      /* !Listdebug Output */
      case DEBUGIT_OUTPUT:
        output_debugit (stream);
        break;

      /* FILE Output */
      case FILE_OUTPUT:
        output_file (stream);
        break;

      /* PDebug Output */
      case PDEBUG_OUTPUT:
        output_pdebug (stream);
        break;

      /* Printf Output */
      case PRINTF_OUTPUT:
        output_printf (stream);
        break;

      /* RemoteDB Output */
      case SOCKET_OUTPUT:
        output_socket (stream);
        break;

      /* Serial Output */
      case SERIAL_OUTPUT:
        output_serial (stream);
        break;

      /* !Tracker Output */
      case TRACKER_OUTPUT:
        output_tracker (stream);
        break;

      /* TML Podule Output */
      case TML_OUTPUT:
        output_tml (stream);
        break;

      case NULL_OUTPUT:
      default:
        // do nothing
        break;
    }
d851 11
a861 1
  switch (device)
d863 5
a867 51
    /* !Listdebug Output */
    case DEBUGIT_OUTPUT:
      if (init_debugit () == TRUE)
        output_debugit (buffer);
      break;

    /* PDebug Output */
    case PDEBUG_OUTPUT:
      if (init_pdebug () == TRUE)
        output_pdebug (buffer);
      break;

    /* RemoteDB Output */
    case SOCKET_OUTPUT:
      if (init_socket () == TRUE)
        output_socket (buffer);
      break;

    /* !Tracker Output */
    case TRACKER_OUTPUT:
      if (init_tracker () == TRUE)
        output_tracker (buffer);
      break;

    /* TML Podule Output */
    case TML_OUTPUT:
      if (init_tml () == TRUE)
        output_tml (buffer);
      break;

    /* Serial Output */
    case SERIAL_OUTPUT:
      if (init_serial () == TRUE)
        output_serial (buffer);
      break;

    /* printf output */
    case PRINTF_OUTPUT:
      if (init_printf () == TRUE)
        output_printf (buffer);
      break;

    case FILE_OUTPUT:
      /* Do nothing.  I guess it should open a file,
         write to it, then close it */
      break;

    case NULL_OUTPUT:
    default:
      /* do nothing */
      break;
@


1.21
log
@ * Overhauled how DebugLib options are handled.  Options are now held in
   an options structure internal to DebugLib.  Options are set one at a
   time by function calls, this makes it much easier to add new options
   over time.  debug_set_options and debug_output_device now deprecated,
   but still provided.  Updated StrongHelp manual to document this
   new behaviour.

 * Fixed trace output somewhat...should now look better on remotedb
   output (no extraneous CRs), and you can now set the trace device to
   be the same as the main debug device.  Setting trace device to "printf"
   now also works (file still to do, as you still can't "dfprintf" to file)

 * Added one of the new options function calls to the CLI_App test harness,
   to test functionality.

 * Improved the !MkCleans for the test harnesses.


Version 0.33. Tagged as 'DebugLib-0_33'
@
text
@d437 1
d536 5
d1009 60
@


1.21.2.1
log
@Produced a version for Alastair Roger to use which has copyright
messages in place on debug output and the header files.
Branch work.

Version 0.33, 1.28.2.1. Tagged as 'DebugLib-0_33-1_28_2_1'
@
text
@a632 1
  _dprintf ("", "DebugLib is (c) Acorn Computers Ltd 1997, 98, 99.\n");
a763 1
    _dprintf ("", "DebugLib is (c) Acorn Computers Ltd 1997, 98, 99.\n");
@


1.20
log
@ * Added debug and MemCheck targets to DebugLib.  They don't get exported,
   as they are only for DebugLib development.  They were used to spot...

 * Found and fixed malloc block overwrite in the level checking code.  I
   was mallocing too small of a block by doing strlen on the wrong
   string.  This bug was causing problems when level filtering was used
   with apps compiled with DebugLib.

 * Tidied OS_ReadVarVal veneer.

 * Added MemCheck code and build target to CLI_App test program, which uses
   the new MemCheck target of DebugLib.


Version 0.32. Tagged as 'DebugLib-0_32'
@
text
@a40 1
static const char debuglib_version_string[] = Module_FullVersion;
d45 1
a45 1
int use_taskname_prefix = TRUE;
a46 2
int serial_port_speed = SerialPort_DefaultSpeed;
int serial_port_number = SerialPort_DefaultPort;
a47 5
int serial_lf = TRUE;

int printf_screen_cornering = 1;

int DEBUG_OUTPUT_TYPE = NULL_OUTPUT;    /* Output device - see DebugLib.h */
a50 2
int trace_stream = NULL;

a52 4
char *TASK_NAME = NULL;                 /* Task name for use with Sockets Library */

char *FILE_FILENAME = NULL;             /* Filename for FILE debug output */

a57 1
BOOL file_output_nonbuffered = FALSE;
d59 2
a60 2
int sysvar_provided_device = -1;              /* The variable to hold output device specified by
                                                 system variable */
d64 4
a67 2
static int sysvar_provided_tracedevice = -1;  /* The variable to hold the trace output device
                                                 specified by system variable */
a72 2
static int stamp_debug = FALSE;                  /* Add timestamp to lines if set to TRUE */

d241 1
a241 1
static void debug_setup_filename (char *fname)
d245 2
a246 2
  tmp_sysvar_name = malloc (strlen (TASK_NAME) + strlen ("DebugLib$Filename_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$Filename_%s", TASK_NAME);
d248 4
a251 4
  if (FILE_FILENAME)
    free (FILE_FILENAME);
  FILE_FILENAME = misc_getenv_malloc (tmp_sysvar_name);
  if (FILE_FILENAME == NULL)
d255 1
a255 1
      FILE_FILENAME = debuglib_strdup (fname);
d266 1
a266 1
/* debug_setup_unbufferf                                                */
d282 2
a283 2
  tmp_sysvar_name = malloc (strlen (TASK_NAME) + strlen ("DebugLib$UnbufferedFiles_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$UnbufferedFiles_%s", TASK_NAME);
d289 1
a289 1
    file_output_nonbuffered = TRUE;
d292 1
a292 1
    file_output_nonbuffered = FALSE;
d312 1
a312 1
static void debug_setup_level (char *sysvar)
d319 1
a319 1
    tmp_sysvar_name = debuglib_strdup (sysvar);
d325 2
a326 2
    tmp_sysvar_name = malloc (strlen (TASK_NAME) + strlen ("DebugLib$Level_") + 1);
    sprintf (tmp_sysvar_name, "DebugLib$Level_%s", TASK_NAME);
d358 2
a359 2
  tmp_sysvar_name = malloc (strlen (TASK_NAME) + strlen ("DebugLib$Device_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$Device_%s", TASK_NAME);
d366 1
a366 1
    sysvar_provided_device = atoi (tmp_string);
d395 2
a396 2
  tmp_sysvar_name = malloc (strlen (TASK_NAME) + strlen ("DebugLib$TraceDevice_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$TraceDevice_%s", TASK_NAME);
d404 1
a404 1
    sysvar_provided_tracedevice = atoi (tmp_string);
d415 26
d454 1
a454 1
void debug_initialise (char *name, char *fname, char *sysvar)
d464 3
d468 2
a469 2
  if (TASK_NAME)
    free (TASK_NAME);
d471 1
a471 1
    TASK_NAME = debuglib_strdup (name);
d473 1
a473 1
    TASK_NAME = debuglib_strdup ("DefaultName");
d495 41
d556 1
a556 1
void debug_set_options (const unsigned int options, const int sport, const int sspeed)
d560 1
a560 1
    use_taskname_prefix = TRUE;
d562 1
a562 1
    use_taskname_prefix = FALSE;
d566 1
a566 3
  {
    serial_lf = TRUE;
  }
d568 1
a568 1
    serial_lf = FALSE;
d571 2
a572 4
  if ( (sport > 0) && (sport < 3) )
  {
    serial_port_number = sport;
  }
d575 2
a576 4
  if ( (sspeed >= 300) && (sspeed <= 115200) )
  {
    serial_port_speed = sspeed;
  }
d580 1
a580 1
    printf_screen_cornering = 1;
d582 1
a582 1
    printf_screen_cornering = 0;
d585 3
a587 1
    stamp_debug = TRUE;
d631 1
a631 1
  _dprintf ("", "Task: %s\n", TASK_NAME);
d635 1
a635 1
  switch(DEBUG_OUTPUT_TYPE)
d653 1
a653 1
  DEBUG_OUTPUT_TYPE = NULL_OUTPUT;
d658 1
a658 1
/* debug_output_device                                                  */
d660 1
a660 1
/* Function selects the Debug Output Device                             */
d662 1
a662 1
/* Parameters: device - integer constant for devices.                   */
d667 1
a667 1
void debug_output_device (int device)
d678 1
a678 1
    if (sysvar_provided_device != -1)
d681 8
a688 1
    if ((device <= no_devices) && (device >= 0))
d690 24
a713 3
      /* Set to NULL by default, until proved otherwise.  Removes the need for an ELSE statements
       * when checking for modules
       */
d715 5
a719 2
      /* Close down previous debug output */
      debug_close_device ();
d721 11
a731 55
      switch (device)
      {
        /* !List Debug output device */
        case DEBUGIT_OUTPUT:
          rc = init_debugit ();
          break;

        /* FILE Output */
        case FILE_OUTPUT:
          rc = init_file ();
          break;

        /* PDebug Output */
        case PDEBUG_OUTPUT:
          /* Check that module is present */
          rc = init_pdebug ();
          break;

        case SERIAL_OUTPUT:
          rc = init_serial();
          break;

        /* Sockets */
        case SOCKET_OUTPUT:
          rc = init_socket ();
          break;

        /* TML Output */
        case TML_OUTPUT:
          /* Check that module is present */
          rc = init_tml ();
          break;

        /* Tracker Output */
        case TRACKER_OUTPUT:
          /* Check that module is present */
          rc = init_tracker ();
          break;

        /* Printf Output */
        case PRINTF_OUTPUT:
          /* No initialisation to do */
          rc = TRUE;
          break;

        /* No output */
        case NULL_OUTPUT:
          rc = TRUE;
          break;

        /* Undefined device, treat as no output */
        default:
          device = NULL_OUTPUT;
          rc = TRUE;
      }
d733 4
a736 4
      /* If we've initialised correctly, set the debug
         device */
      if (rc == TRUE)
        DEBUG_OUTPUT_TYPE = device;
d738 25
a762 16
      time (&timer);
      _dprintf ("", "\n***** Debug Session Started **************************************\n");
      _dprintf ("", "System: DebugLib %s\n", debuglib_version());
      _dprintf ("", "        remotedb %s\n", remotedb_version());
      _dprintf ("", "        PDebug %s\n", PDebug_Version());
      _dprintf ("", "Task:   %s\n", TASK_NAME);
      _dprintf ("", "Time:   %s", ctime(&timer));
      {
        char *levels;
        if (level_specifier == NULL)
          levels = "";
        else
          levels = level_specifier;
        _dprintf ("", "Levels: %s\n", levels);
      }
      _dprintf ("", "******************************************************************\n");
d764 1
d787 1
a787 1
    switch (DEBUG_OUTPUT_TYPE)
d849 1
a849 1
void _dvprintf(const char *area_level, const char *format, va_list arg)
d855 1
a855 1
    if (stamp_debug == TRUE)
d920 1
a920 1
void stream_debug_output (int stream, const char *buffer)
d922 1
a922 1
  switch (stream)
a923 4
    case NULL_OUTPUT:
      // do nothing
      break;

a927 1

a933 1

a939 1

a945 1

a951 1

d958 1
d960 4
d967 1
a967 1
      /* Do Nothing.  I guess it should open a file,
d970 5
d989 1
a989 1
void _dfprintf (const char *area_level, const int stream, const char *format, ...)
d999 4
a1002 1
    stream_debug_output (stream, debug_buffer);
d1019 1
a1019 1
void debug_initialise_trace (int stream, char *fns)
d1024 2
a1025 2
  if (sysvar_provided_tracedevice == -1)
    trace_stream = stream;
d1027 1
a1027 1
    trace_stream = sysvar_provided_tracedevice;
d1074 1
a1074 1
void debug_trace_enter (const char* fname)
d1077 4
d1082 2
a1083 2
  _dfprintf ("", trace_stream, "Trace: %3d:", global_indent);
  for (i=0; i< global_indent; i++)
d1085 2
a1086 1
    stream_debug_output (trace_stream, " |");
d1088 5
a1092 1
  _dfprintf ("", trace_stream, " %s\n", fname);
d1111 4
d1116 1
a1116 1
  _dfprintf ("", trace_stream, "Trace: %3d:", global_indent-1);
d1119 2
a1120 1
    stream_debug_output (trace_stream, " |");
d1122 6
d1129 1
a1129 1
  _dfprintf ("", trace_stream, "~%s\n", fname);
d1134 1
a1134 1
/* debuglib_version                                                     */
d1143 1
a1143 1
const char *debuglib_version (void)
d1145 1
a1145 1
  return debuglib_version_string;
@


1.19
log
@ * Changed version num code to use new srccommit definition
   Module_FullVersion.  It can wait until next change to get tagged
   unless someone wants the version num upped...


Version 0.31. Not tagged
@
text
@d139 1
a139 1
  area_level = malloc (strlen (area_level) + 1);
@


1.18
log
@ * Renamed function "strdup" in c.misc to avoid conflicts when building
   with other code that define strdup

 * Added extra option to debug_set_options to allow timestamping of debug
   output...doesn't handle \n chars in debug output very elegantly, but
   it'll do for now.  Option is DebugLib_Options_StampDebug_(On/Off)


Version 0.31. Tagged as 'DebugLib-0_31'
@
text
@d41 1
a41 1
static const char debuglib_version_string[] = Module_MajorVersion " " Module_MinorVersion;
@


1.17
log
@ * Tidied debug_initialise function greatly.  It now uses a number of
   auxiliary functions to reduce the size and complexity of the function.
   The auxiliary functions use functions in the new file misc.c, most
   importantly a veneer to use OS_ReadVarVal nicely.

 * Storage of taskname, and filename for file output method is now done
   with dynamic memory allocation, used to be statically sized buffers.


Version 0.30. Tagged as 'DebugLib-0_30'
@
text
@d270 1
a270 1
      FILE_FILENAME = strdup (fname);
d334 1
a334 1
    tmp_sysvar_name = strdup (sysvar);
d457 1
a457 1
    TASK_NAME = strdup (name);
d459 1
a459 1
    TASK_NAME = strdup ("DefaultName");
d534 3
d809 1
d811 2
d815 4
a818 1
      debug_output (ctime (&timer));
@


1.16
log
@ * Noted an oddity in the "always_ignore" functions for trace.
   "debug_printf" was declared twice for some reason.  Fixed this.
 * A variable in debug.c was being used as a global.  Moved it into the
   global area of the file, and put a prototype in globals.h
 * These changes not enough for a version increment IMO.


Version 0.29. Not tagged
@
text
@d35 1
d57 1
a57 1
FILE *debug_file_pointer=NULL;          /* File pointer */
d63 1
a63 1
char TASK_NAME[40];                     /* Task name for use with Sockets Library */
d65 1
a65 1
char FILE_FILENAME[300];                /* Filename for FILE debug output */
d82 1
a82 1
static char *sys_var_contents = NULL;            /* Contents of area-level specifying sys var */
a243 1

d245 4
d251 1
a251 7
/* Function initialises the library                                     */
/*                                                                      */
/* Parameters: name - name of app that is calling the library.          */
/*             fame - file for debug output to FILE                     */
/*             sysvar - System Variable to override default area/level  */
/*                      specifiying system variable. Uses default if    */
/*                      NULL or "" is passed.                           */
d253 1
a253 1
/* Returns:    void.                                                    */
d256 1
a256 1
void debug_initialise (char *name, char *fname, char *sysvar)
d258 1
a258 3
  char *sys_variable;
  _kernel_oserror *er;
  char tmp_string[20];
d260 2
a261 16
  /* No open debug devices */
  sessions_available.debugit = FALSE;
  sessions_available.tml = FALSE;
  sessions_available.remotedb = FALSE;
  sessions_available.tracker = FALSE;
  sessions_available.pdebug = FALSE;
  sessions_available.serial = FALSE;

  /* Setup TASK_NAME  */
  if (name != NULL)
  {
    strncpy (TASK_NAME, name, sizeof (TASK_NAME));
    TASK_NAME[sizeof (TASK_NAME) - 1] = '\0';
  }
  else
    strcpy (TASK_NAME, "DefaultName");
d263 4
a266 5
  /* Setup filename */
  sys_variable = malloc (strlen (TASK_NAME) + 18 /* strlen ("DebugLib$Filename_") */ + 1);
  sprintf (sys_variable, "DebugLib$Filename_%s", TASK_NAME);
  er = _kernel_getenv (sys_variable, FILE_FILENAME, sizeof (FILE_FILENAME));
  if (er != NULL)
d268 1
a268 1
    if (fname != NULL)
d270 1
a270 2
      strncpy (FILE_FILENAME, fname, sizeof (FILE_FILENAME));
      FILE_FILENAME[sizeof (FILE_FILENAME) - 1] = '\0';
a271 2
    else
      FILE_FILENAME[0] = '\0';
a272 2
  if (sys_variable)
    free (sys_variable);
d274 4
a277 8
  /* Check whether we should be doing unbuffered file writes */
  sys_variable = malloc (strlen (TASK_NAME) + 25 /* strlen ("DebugLib$UnbufferedFiles_") */ + 1);
  sprintf (sys_variable, "DebugLib$UnbufferedFiles_%s", TASK_NAME);
  er = _kernel_getenv (sys_variable, tmp_string, sizeof (tmp_string));
  if (er == NULL)
    file_output_nonbuffered = TRUE;
  if (sys_variable)
    free (sys_variable);
a278 3
  if (sys_var_contents != NULL)
    free (sys_var_contents);
  sys_var_contents = malloc (300);
d280 16
a295 7
  /* If we've not been provided a system variable name in the intialise call ... */
  if (sysvar == NULL || strlen (sysvar) == 0)
  {
    /* .. Setup a string with the name of the default system variable that will
       specify the debug area/level(s) */
    sys_variable = malloc (strlen (TASK_NAME) + 15 /* strlen ("DebugLib$Level_") */ + 1);
    sprintf (sys_variable, "DebugLib$Level_%s", TASK_NAME);
d297 2
a298 2
    /* Read the system variable */
    er = _kernel_getenv (sys_variable, sys_var_contents, 300);
d300 5
a304 3
    /* Free up the string */
    if (sys_variable)
      free (sys_variable);
d307 23
a329 4
  {
    /* ... else if we've been provided with a sysvar, read from it instead */
    er = _kernel_getenv (sysvar, sys_var_contents, 300);
  }
d331 2
a332 1
  if (er != NULL)
d334 1
a334 4
    /* Probably means the sysvar is unset */
    if (sys_var_contents)
      free (sys_var_contents);
    sys_var_contents = NULL;
d338 4
a341 2
    /* Make sure it's NUL terminated */
    sys_var_contents[300 - 1] = '\0';
d344 26
d373 2
a374 2
  sys_variable = malloc (strlen (TASK_NAME) + 16 /* strlen ("DebugLib$Device_") */ + 1);
  sprintf (sys_variable, "DebugLib$Device_%s", TASK_NAME);
d377 1
a377 1
  er = _kernel_getenv (sys_variable, tmp_string, sizeof (tmp_string));
d379 1
a379 6
  /* Free up the string */
  if (sys_variable)
    free (sys_variable);

  /* If there was no error reading the sysvar, use the contents */
  if (er == NULL)
a380 4
    /* Make sure it's the device specifier is NUL terminated */
    tmp_string[sizeof(tmp_string) - 1] = '\0';

    /* And convert it to an output device type */
d382 1
d385 22
d410 2
a411 2
  sys_variable = malloc (strlen (TASK_NAME) + 21 /* strlen ("DebugLib$TraceDevice_") */ + 1);
  sprintf (sys_variable, "DebugLib$TraceDevice_%s", TASK_NAME);
d413 1
a413 2
  /* Read the system variable */
  er = _kernel_getenv (sys_variable, tmp_string, sizeof (tmp_string));
d415 2
a416 6
  /* Free up the string */
  if (sys_variable)
    free (sys_variable);

  /* If there was no error reading the sysvar, use the contents */
  if (er == NULL)
d418 1
a418 4
    /* Make sure the device specifier is NUL terminated */
    tmp_string[sizeof(tmp_string) - 1] = '\0';

    /* And convert it to a output device type */
d420 1
d423 53
d706 1
a706 1
        if (sys_var_contents == NULL)
d709 1
a709 1
          levels = sys_var_contents;
d800 1
a800 1
  if (debug_check_level(area_level, sys_var_contents) == 1)
d935 1
a935 1
  if (debug_check_level (area_level, sys_var_contents) == 1)
@


1.15
log
@Summary
    * Added dvprintf courtesy of Neil Bingham.
    * Fixed module tracing.
Detail
    * dvprintf speaks for iteslf.
    * Fixed module trace builds - they were not linking against the module
      version of the trace library.  It was mostly working, but one of the
      things that wasn't was the ability to ignore certain functions.
    * Tidied up debug_trace_initialise a bit to find the length of the string
      of functions it always ignores by using strlen, instead of having a
      hard-coded integer.  Also fixed a memory leak - wasn't freeing the
      string of ignored functions.
Admin
    * dvprintf tested with the test harnesses and with the ATM driver.
    * Module trace fixes tested with the ATM driver.

Version 0.29. Tagged as 'DebugLib-0_29'
@
text
@a72 2
/* -------------------------------------- LOCAL VARIABLES --------------------------------------- */

d76 2
d89 1
a89 1
static const char *always_ignore = " PDebug_* debug_printf Trace_* debug_printf remote_debug_open";
@


1.14
log
@--------
  * Added buffering support.
Detail:
-------
  * DebugLib output can now be buffered and then output.  This is primarily
    for debugging ROM modules that would be active before the parallel
    port is alive during boot up.  Two new functions have been added to
    support this; debug_output_buffer_on() and debug_output_buffer_off().
    Updated documentation to follow.
Admin:
------
  * Tested on RiscPC/NC with Parallel, DebugIt and System variable
    override of output settings.

Version 0.25. Tagged as 'DebugLib-0_25'
@
text
@d89 2
d703 3
a705 1
/* _dprintf                                                             */
a706 1
/* Function sends the data to the current output device                 */
d708 1
a708 1
/* Parameters: format - printf configuration.                           */
d713 1
a713 1
void _dprintf (const char *area_level, const char *format, ...)
d715 1
a715 3
  va_list p;

  if (debug_check_level (area_level, sys_var_contents) == 1)
d717 1
a717 3
    va_start (p, format);
    vsprintf (debug_buffer, format, p);
    va_end (p);
d726 1
a726 1
    debug_output (debug_buffer);
d732 20
d872 1
d890 1
a890 1
  len = len2 + 61  /* strlen (" PDebug_* debug_printf Trace_* debug_printf remote_debug_open") */ + 1;
d904 1
a904 1
  strcat (ignore_fns, " PDebug_* debug_printf Trace_* debug_printf remote_debug_open");
d912 2
@


1.13
log
@Fixed a couple of _swix calls that cc 5.10 complained about.

Version 0.24. Not tagged
@
text
@d36 1
d75 2
a76 2
static int sysvar_provided_device = -1;   /* The variable to hold output device specified by
                                             system variable */
d388 3
d531 1
a531 6
  /* If we've been provided with an output device by a sysvar, we want to
     override the the requested output device with the one in the sysvar */
  if (sysvar_provided_device != -1)
    device = sysvar_provided_device;

  if ((device <= no_devices) && (device >= 0))
d533 1
a533 3
    /* Set to NULL by default, until proved otherwise.  Removes the need for an ELSE statements
     * when checking for modules
     */
d535 4
a538 2
    /* Close down previous debug output */
    debug_close_device ();
d540 1
a540 1
    switch (device)
d542 3
a544 4
      /* !List Debug output device */
      case DEBUGIT_OUTPUT:
        rc = init_debugit ();
        break;
d546 2
a547 4
      /* FILE Output */
      case FILE_OUTPUT:
        rc = init_file ();
        break;
d549 55
a603 5
      /* PDebug Output */
      case PDEBUG_OUTPUT:
        /* Check that module is present */
        rc = init_pdebug ();
        break;
d605 21
a625 36
      case SERIAL_OUTPUT:
        rc = init_serial();
        break;

      /* Sockets */
      case SOCKET_OUTPUT:
        rc = init_socket ();
        break;

      /* TML Output */
      case TML_OUTPUT:
        /* Check that module is present */
        rc = init_tml ();
        break;

      /* Tracker Output */
      case TRACKER_OUTPUT:
        /* Check that module is present */
        rc = init_tracker ();
        break;

      /* Printf Output */
      case PRINTF_OUTPUT:
        /* No initialisation to do */
        rc = TRUE;
        break;

      /* No output */
      case NULL_OUTPUT:
        rc = TRUE;
        break;

      /* Undefined device, treat as no output */
      default:
        device = NULL_OUTPUT;
        rc = TRUE;
a626 22

    /* If we've initialised correctly, set the debug
       device */
    if (rc == TRUE)
      DEBUG_OUTPUT_TYPE = device;

    time (&timer);
    _dprintf ("", "\n***** Debug Session Started **************************************\n");
    _dprintf ("", "System: DebugLib %s\n", debuglib_version());
    _dprintf ("", "        remotedb %s\n", remotedb_version());
    _dprintf ("", "        PDebug %s\n", PDebug_Version());
    _dprintf ("", "Task:   %s\n", TASK_NAME);
    _dprintf ("", "Time:   %s", ctime(&timer));
    {
      char *levels;
      if (sys_var_contents == NULL)
        levels = "";
      else
        levels = sys_var_contents;
      _dprintf ("", "Levels: %s\n", levels);
    }
    _dprintf ("", "******************************************************************\n");
d643 5
a647 1
  switch (DEBUG_OUTPUT_TYPE)
d649 6
a654 4
    /* !Listdebug Output */
    case DEBUGIT_OUTPUT:
      output_debugit (stream);
      break;
d656 4
a659 4
    /* FILE Output */
    case FILE_OUTPUT:
      output_file (stream);
      break;
d661 4
a664 4
    /* PDebug Output */
    case PDEBUG_OUTPUT:
      output_pdebug (stream);
      break;
d666 4
a669 4
    /* Printf Output */
    case PRINTF_OUTPUT:
      output_printf (stream);
      break;
d671 4
a674 4
    /* RemoteDB Output */
    case SOCKET_OUTPUT:
      output_socket (stream);
      break;
d676 4
a679 4
    /* Serial Output */
    case SERIAL_OUTPUT:
      output_serial (stream);
      break;
d681 4
a684 4
    /* !Tracker Output */
    case TRACKER_OUTPUT:
      output_tracker (stream);
      break;
d686 4
a689 4
    /* TML Podule Output */
    case TML_OUTPUT:
      output_tml (stream);
      break;
d691 5
a695 4
    case NULL_OUTPUT:
    default:
      // do nothing
      break;
@


1.12
log
@ * Fixed Makefile so that it doesn't use "newer" when copying files.  This
   meant that an export wouldn't overwrite newer libraries, when you'd
   expect it to.

 * Tidied test app Makefiles and build obey files.

 * Fixed GUI test app, wasn't declaring it's windows as autocreate and/or
   shared, which meant it missed events.  Removed all warnings also.

 * Now outputs the PDebug version information when a device is activiated.


Version 0.24. Tagged as 'DebugLib-0_24'
@
text
@d728 1
a728 1
  _swix (0x107, _IN(0));
@


1.11
log
@ * Fixed bug in area debugging.  This bug meant that if you specified the
   levels to output as e.g. "Main,Error", dprintfs with "Error" as the level
   would not be output.  Tracked it down to a misbracketed expression.

 * Made it possible to debug debuglib by adding another macro
   "internal_dprintf".  To turn on internal debugging you must define
   "DEBUG" in the make system.


Version 0.22. Tagged as 'DebugLib-0_22'
@
text
@d606 1
@


1.10
log
@ * Added new feature.  Can now override the filename which the file output
   method uses at runtime by setting a system variable
   "DebugLib$Filename_<Taskname>"

 * Can now tell debuglib to turn off file buffering for the file output
   method, with a system variable. "DebugLib$UnbufferedFiles<Taskname>" set
   to any value

 * Tidied make system, so throwback is only turned on by the build obey
   files

 * Tidied a few switch statements

 * Updated StrongHelp manual to reflect new system variables and features.


Version 0.21. Tagged as 'DebugLib-0_21'
@
text
@d171 1
d174 1
a174 1
      if (*(match-1) != ' ' && (*match-1) != ',')
d183 2
d188 1
@


1.9
log
@ * Added version number method (debuglib_version).


Version 0.20. Tagged as 'DebugLib-0_20'
@
text
@d70 1
d275 4
a278 1
  if (fname != NULL)
d280 7
a286 2
    strncpy (FILE_FILENAME, fname, sizeof (FILE_FILENAME));
    FILE_FILENAME[sizeof (FILE_FILENAME) - 1] = '\0';
d288 11
a298 2
  else
    FILE_FILENAME[0] = '\0';
a303 1

d521 1
d524 1
a524 1
     override the the rquested output device with the one in the sysvar */
d541 1
a541 5
        if (init_debugit () == TRUE)
        {
          /* Module initialised properly */
          DEBUG_OUTPUT_TYPE = device;
        }
d546 1
a546 5
        if (init_file () == TRUE)
        {
          /* File opened OK */
          DEBUG_OUTPUT_TYPE = device;
        }
d552 1
a552 5
        if (init_pdebug () == TRUE)
        {
          /* Module initialised properly */
          DEBUG_OUTPUT_TYPE = device;
        }
d556 1
a556 4
        if (init_serial() == TRUE)
        {
          DEBUG_OUTPUT_TYPE = device;
        }
d561 1
a561 5
        if (init_socket () == TRUE)
        {
          /* Initialised OK */
          DEBUG_OUTPUT_TYPE = device;
        }
d567 1
a567 4
        if (init_tml () == TRUE)
        {
          DEBUG_OUTPUT_TYPE = device;
        }
d573 1
a573 4
        if (init_tracker () == TRUE)
        {
          DEBUG_OUTPUT_TYPE = device;
        }
d579 1
a579 1
        DEBUG_OUTPUT_TYPE = device;
d581 10
d592 6
a630 4
    case NULL_OUTPUT:
      // do nothing
      break;

d670 5
d924 10
a937 1

@


1.8
log
@ * Now uses remotedb's version method (requires v0.03 or later) so it can
   report the version of remotedb that is compiled into the DebugLib
   library file.


Version 0.19. Tagged as 'DebugLib-0_19'
@
text
@d39 1
d591 1
a591 2
    _dprintf ("", "System: DebugLib %s  (Neil Bingham & John Beranek)\n",
                      Module_MajorVersion);
d912 7
@


1.7
log
@ * You can now specify the debug device that DebugLib uses for trace
   output with a system variable (DebugLib$TraceDevice_<taskname>).
   The corresponding behaviour for normal debug statements is now
   more appropriate. (i.e. The debug device specified in the variable is
   only initialised at the first call of debug_out_device())

 * Increased vsprintf buffer size to 1Kbyte (Previous buffer was overrun
   by some applications).  Could put in a hack to fprintf to Null: to
   discover the size, then create a big enough buffer to do the vsprintf...


Version 0.17. Tagged as 'DebugLib-0_17'
@
text
@d592 1
@


1.6
log
@Added NULL checking to debug_initialise_trace to fix any potential
  problems from cropping up.

Version 0.15. Tagged as 'DebugLib-0_15'
@
text
@d72 5
a76 2
static int sysvar_provided_type = NULL_OUTPUT;   /* The variable to hold output device specified by
                                                    system variable */
a251 1
  int tmp_type;
d285 2
a286 1
  /* Setup area-level specifying system variable */
d289 2
d294 1
d297 1
d302 2
d305 1
d320 3
a322 1
  /* Setup output device specifying system variable */
d326 1
d329 1
d333 2
a334 1
  if (er != NULL)
d336 5
a340 2
    /* Probably means the sysvar is unset */
    sysvar_provided_type = NULL_OUTPUT;
d342 16
a357 1
  else
d359 1
a359 1
    /* Make sure it's the device specifier is NUL terminated */
d363 1
a363 7
    tmp_type = atoi (tmp_string);

    /* Set the output device to the one specified */
    debug_output_device (tmp_type);

    /* And set a variable which is checked later */
    sysvar_provided_type = tmp_type;
d505 3
a507 3
     disallow the output device being changed */
  if (sysvar_provided_type != NULL_OUTPUT)
    return;
d826 5
a830 1
  trace_stream = stream;
@


1.5
log
@  Updated Documentation for debug_initialise, to clarify some of the
parameters.
  Fixed a few cases where NULLs could be passed to strcpy etc. in
debug_initialise.
  VersionNum file now gets exported to the DebugLib's Export directory, so
you always know what version you've got compiled.
  Tidied some header files a bit.

Version 0.14. Tagged as 'DebugLib-0_14'
@
text
@d797 1
a797 1
  int len;
d802 6
a807 1
  len = strlen (fns) + 61  /* strlen (" PDebug_* debug_printf Trace_* debug_printf remote_debug_open") */ + 1;
d815 6
a820 1
  strcpy (ignore_fns, fns);
@


1.4
log
@ * New features:
   - You can now set a system variable to override the output method
     compiled into the program. (DebugLib$Device_<Taskname>)
   - Printf output now has an option bit associated with it.  This option
     being whether or not the cursor is sent to the top-left of the screen
     before outputting text.  Default is on.

 * Bug fix - printf output wasn't working due to an oversight in the device
   selection function.
 * Updated manual for new features

Version 0.12. Tagged as 'DebugLib-0_12'
@
text
@d52 1
a52 1
int DEBUG_OUTPUT_TYPE = NULL_OUTPUT;		/* Output device - see DebugLib.h */
d54 1
a54 2
static int sysvar_provided_type = NULL_OUTPUT;         /* The variable to hold output device specified by
                                                          system variable */
d56 1
a56 1
FILE		*debug_file_pointer=NULL;	/* File pointer */
d58 1
a58 1
int		trace_stream = NULL;
d60 1
a60 1
debug_session	*remotedb_info;			/* RemoteDB handler */
d62 1
a62 5
char	TASK_NAME[20];			/* Task name for use with Sockets Library */

char	FILE_FILENAME[300];		/* Filename for FILE debug output */

static char *sys_var_contents = NULL;        /* Contents of area-level specifying sys var */
d72 6
a77 1
static char    debug_buffer[Debug_Buffer_Size];	/* Buffer for debug data */
d79 3
a81 1
static int	stamp_debug = FALSE;		/* Add timestamp to lines if set to TRUE */
a83 1
static int global_indent = 0;
d85 2
a86 2
void debug_trace_enter(const char *);
void debug_trace_exit(const char *);
d120 4
d126 2
a127 2
  /* If the area_level is empty, or NULL, it's a match */
  if (area_level_in == NULL || area_level_len == 0)
d238 4
a241 1
/*             filename - file for debug output to FILE                 */
d246 1
a246 1
void debug_initialise (char *name, char *fname, char* sysvar)
a252 2
  IGNORE (sysvar);

d261 8
a268 3
  /* Setup TASK_NAME for use with Sockets debugging. */
  strncpy (TASK_NAME, name, sizeof (TASK_NAME));
  TASK_NAME[sizeof (TASK_NAME) - 1] = '\0';
d271 7
a277 2
  strncpy (FILE_FILENAME, fname, sizeof (FILE_FILENAME));
  FILE_FILENAME[sizeof (FILE_FILENAME) - 1] = '\0';
d350 5
d436 4
a439 4
  _dprintf("", "\n***** Debug Session Terminated ***********************************\n");
  _dprintf("", "Task: %s\n", TASK_NAME);
  _dprintf("", "Time: %s", ctime(&timer));
  _dprintf("", "******************************************************************\n");
d562 2
a563 2
    _dprintf("", "\n***** Debug Session Started **************************************\n");
    _dprintf("", "System: DebugLib %s  (Neil Bingham & John Beranek)\n",
d565 2
a566 2
    _dprintf("", "Task:   %s\n", TASK_NAME);
    _dprintf("", "Time:   %s", ctime(&timer));
d573 1
a573 1
      _dprintf("", "Levels: %s\n", levels);
d575 1
a575 1
    _dprintf("", "******************************************************************\n");
@


1.3
log
@Added Serial Output device.
Added CLI, Module and Toolbox test applications
Tidied various sections
Tidied StrongHelp manual
Removed remotedb from Libs folder, now fetched from build structure
Removed svcprint from Libs folder, wasn't being used
Added srccommit support

Version 0.10. Tagged as 'DebugLib-0_10'
@
text
@d50 2
d54 3
a89 1

a128 2
/*  printf ("\narea_level = \"%s\"_______variable = \"%s\"\n", area_level, variable); */

a155 5
#if 0 /* Debug */
  _dprintf ("", ">>>>DB>>>> area = \"%s\" level = %d\n", area, level);
#endif

/*  printf ("Area = \"%s\"---Level = %d\n", area, level); */
d241 1
d243 1
d293 29
d356 1
d361 2
d367 6
d456 5
d533 6
d594 1
a594 4
/*      _swi (OS_WriteC, _IN(0),4);
      _swi (OS_WriteC, _IN(0),26);
      printf ("%s", stream); */
      _swix (OS_Write0, _IN(0), stream);
a813 1

@


1.2
log
@Merged DebugLib from Daytona branch onto trunk

Version 0.09. Not tagged
@
text
@d17 1
a17 1
/* Purpose: The file contains various debugging routsines.  I have       */
d19 1
a19 1
/*          !Tracker, printf statements, and WIMP message boxes.        */
d28 1
d37 2
d43 7
d62 2
d66 4
d79 2
a80 2
void debug_trace_enter(const char*);
void debug_trace_exit(const char*);
d84 146
d243 3
d254 1
d258 1
d261 75
a335 1
  strcpy (FILE_FILENAME, fname);
d359 1
d378 4
a381 1
  _dprintf ("", "***** Debug Session Terminated at: %s", ctime(&timer));
d385 1
a385 2
    case (FILE_OUTPUT):
    {
d388 2
a389 3
    }
    case (PDEBUG_OUTPUT):
    {
d392 2
a393 3
    }
    case (SOCKET_OUTPUT):
    {
d396 4
a399 1
    }
d406 1
a406 1
/* debug_output_device                                                 */
d417 1
a417 1
  time_t 		timer;
d458 7
d493 14
a506 1
    _dprintf ("", "***** Debug Session Started at: %s", ctime(&timer));
d521 1
a521 1
void debug_output (const char *level, const char *stream)
d525 4
d531 1
a531 1
      output_debugit (level, stream);
d536 1
a536 1
      output_file (level, stream);
d546 1
a546 1
      _swi (OS_WriteC, _IN(0),4);
d548 2
a549 1
      printf ("%s", stream);
d557 5
d585 1
a585 1
void _dprintf (const char *level, const char *format, ...)
d589 5
a593 3
  va_start (p, format);
  vsprintf (debug_buffer, format, p);
  va_end (p);
d595 4
a598 4
  if (stamp_debug == TRUE)
  {
    time_t timer;
    time (&timer);
d600 3
a602 1
    debug_output (level, ctime (&timer));
a603 1
  debug_output (level, debug_buffer);
d608 1
a608 1
/* debug_beep                                                          */
d634 1
a634 1
void stream_debug_output (int stream, const char *level, const char *buffer)
d638 4
d645 1
a645 1
        output_debugit (level, buffer);
d677 7
d685 2
a686 1
      // Do Nothing - BUG :-(
d702 1
a702 1
void _dfprintf (const char *level, const int stream, const char *format, ...)
d706 5
a710 3
  va_start (p, format);
  vsprintf (debug_buffer, format, p);
  va_end (p);
d712 2
a713 1
  stream_debug_output (stream, level, debug_buffer);
d730 2
a731 2
  char	*ignore_fns;
  int	 len;
d736 2
a737 8
  if (trace_stream == TML_OUTPUT)
  {
    len = strlen (fns) + 20;
  }
  else
  {
    len = strlen (fns);
  }
d743 1
a743 1
  /* Buffer allocated, so add the TML functions on to the end of the stream */
d745 1
a745 4
  if (trace_stream == TML_OUTPUT)
  {
    strcat (ignore_fns, " owrch Printf prf");
  }
d775 1
a775 1
    stream_debug_output (trace_stream, "", " |");
d800 1
a800 1
    stream_debug_output (trace_stream, "", " |");
@


1.1
log
@Debug Library used in Daytona project.  First CVS checkin
@
text
@d267 1
a267 2
      fputs (stream, debug_file_pointer);
      fflush (debug_file_pointer);
@


1.1.2.1
log
@  File debug now conforms more closely to all the other debug devices, with
a separate function to handle output to a file, output_file
@
text
@d267 2
a268 1
      output_file (level, stream);
@

head	4.6;
access;
symbols
	Filer-2_43:4.6
	Filer-2_42:4.6
	Filer-2_41:4.6
	Filer-2_40:4.6
	Filer-2_39:4.6
	Filer-2_38:4.6
	Filer-2_37:4.6
	Filer-2_36:4.6
	Filer-2_35:4.6
	Filer-2_34:4.6
	Filer-2_33:4.6
	Filer-2_32:4.6
	Filer-2_31:4.6
	Filer-2_30:4.6
	Filer-2_29:4.6
	Filer-2_28:4.6
	Filer-2_27:4.6
	Filer-2_26:4.6
	Filer-2_25:4.6
	Filer-2_24:4.6
	Filer-2_23:4.5
	Filer-2_22:4.5
	Filer-2_21:4.5
	Filer-2_20:4.5
	Filer-2_19:4.5
	Filer-2_18:4.5
	Filer-2_17:4.5
	Filer-2_16:4.5
	Filer-2_15:4.5
	Filer-2_14:4.5
	Filer-2_13:4.5
	Filer-2_12:4.5
	Filer-2_11:4.5
	Filer-2_10:4.5
	Filer-2_09:4.4
	RO_5_07:4.4
	Filer-2_08:4.4
	Filer-2_07:4.4
	Filer-2_06:4.4
	Filer-2_05:4.4
	Filer-2_04:4.4
	Filer-2_03:4.4
	Filer-2_02:4.4
	Filer-2_01:4.4
	Filer-2_00:4.3
	Filer-1_99:4.3
	Filer-1_98:4.3
	Filer-1_97:4.3
	Ursula_merge:4.1.4.1
	Filer-1_96:4.2
	Filer-1_95:4.1.4.1
	nturton_Filer-1_85:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rleggett_Filer-1_94:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rleggett_Filer-1_93:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2010.03.07.08.26.14;	author rsprowson;	state Exp;
branches;
next	4.5;

4.5
date	2004.12.03.00.58.52;	author jballance;	state Exp;
branches;
next	4.4;

4.4
date	2001.03.16.17.09.24;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.04.20.16.21.14;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.08.17.11.56.46;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.32;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.32;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.27.46;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.08.27.09.09.08;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.17.27;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.16.28;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Correct sprite name clamping while looking for sm!app
A previous fix in Filer-2_10 had changed the concatenation to be clamped at 10 letters so it doesn't overflow the buffer for long app names. However, having failed to find 'sm!app' it then just tried adding 2 to the string pointer therefore looking for a 10 letter sprite '!app'.
This is different behaviour to before Filer-2_10, which would have overrun thebuffer but at least looked for a full 12 letter name.
Optimised strncat a bit.
Put unused source file in the attic.
Trimmed some bug fix switches dating back to 1989.

Version 2.24. Tagged as 'Filer-2_24'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strlen
; ======
;
; Find the length of a string (exclusive of terminator, so can't HeapGet (0))
;
; In    r1 -> CtrlChar terminated string
;
; Out   r3 = number of chars (can be used as size for Heap)

strlen EntryS "r0"

        MOV     r3, #0
10      LDRB    r0, [r1, r3]
        CMP     r0, #delete             ; Order, you git! EQ -> ~HI
        CMPNE   r0, #space-1            ; CtrlChar, delete
        ADDHI   r3, r3, #1
        BHI     %BT10
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strlen_excludingspaces
; ======================
;
; Find the length of a string (exclusive of terminator, so can't HeapGet (0))
;
; In    r1 -> space or CtrlChar terminated string
;
; Out   r3 = number of chars (can be used as size for Heap)

strlen_excludingspaces EntryS "r0"

        MOV     r3, #0

10      LDRB    r0, [r1, r3]
        CMP     r0, #delete             ; Order, you git! EQ -> ~HI
        CMPNE   r0, #space              ; space, CtrlChar, delete
        ADDHI   r3, r3, #1
        BHI     %BT10
        EXITS


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strncat
; =======
; strncat10
; =========
;
; Copy n or 10 characters from string pointed to by r2
;    onto string pointed to by r1.
;
; In    r1 -> NULL terminated string
;       r2 -> CtrlChar terminated string
;       r4 = n
;
; Out   new string in r1 = "r1" :CC: "r2" :CC: 0

strncat10
        Entry   "r1-r5"
        MOV     r4, #10
        B       %FT05

strncat
        Entry   "r1-r5"
05      LDRB    r14, [r1], #1           ; Find where to stick the appendage
        CMP     r14, #0
        BNE     %BT05
        SUB     r1, r1, #1              ; Point back to the term char

10      LDRB    r14, [r2], #1           ; Copy from *r2++
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, #space-1           ; Any control character terminates copy
        MOVLS   r14, #0                 ; Terminate dst with 0
        STRB    r14, [r1], #1           ; Copy to *r1++
        EXIT    LS

        SUBS    r4, r4, #1
        BNE     %BT10
        STRB    r4, [r1], #1            ; Always null terminate

        EXIT



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strcat
; ======
;
; Concatenate two strings (r1 string assumed to be already 0 term'd for strcat)
;
; In    r1 -> NULL terminated string
;       r2 -> CtrlChar/r3 terminated string
;
; Out   new string in r1 = "r1" :CC: "r2" :CC: 0

strcat EntryS "r1-r3"

        MOV     r3, #space-1

05      LDRB    r14, [r1], #1           ; Find where to stick the appendage
        CMP     r14, #0
        BNE     %BT05
        SUB     r1, r1, #1              ; Point back to the term char

10      LDRB    r14, [r2], #1           ; Copy from *r2++
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, r3                 ; Any char <= r3 terminates copy
        MOVLS   r14, #0                 ; Terminate dst with 0
        STRB    r14, [r1], #1           ; Copy to *r1++
        BHI     %BT10

        EXITS

; ............................................................................

strcat_excludingspaces ALTENTRY

        MOV     r3, #space
        B       %BT05


; .............................................................................
;
; strcpy
; ======
;
; Copy a string and terminate with 0
;
; In    r1 -> dest area
;       r2 -> CtrlChar/r3 terminated src string

strcpy ALTENTRY

        MOV     r3, #space-1
        B       %BT10

; .............................................................................

strcpy_excludingspaces ALTENTRY

        MOV     r3, #space
        B       %BT10

; .............................................................................

strcpyTS ALTENTRY

        B       %BT10

; .............................................................................
;
; AppendLeafnameToDirname
; =======================
;
; In    r1 -> dest string (non-null), may already contain spaces
;       r2 -> leafname, CtrlChar terminater

AppendLeafnameToDirname ALTENTRY

20      LDRB    r14, [r1], #1           ; Find where to stick the appendage
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, #space-1
        BHI     %BT20

        SUB     r1, r1, #1              ; Point back to the term char
        LDRB    r14, [r1, #-1]          ; If last char was not ':' then do '.'
        CMP     r14, #":"
        MOVNE   r14, #"."
        STRNEB  r14, [r1], #1

        MOV     r3, #space-1            ; Stick on the leafname
        B       %BT10

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; nul_terminate
; =============
;
; In    r1 -> string
;
; Out string nul terminated at 1st char le space or eq delete
;

nul_terminate Entry "r1"
10
        LDRB    r14, [r1], #1
        CMP     r14, #delete
        CMPNE   r14, #space
        MOVLS   r14, #0
        STRLSB  r14, [r1, #-1]
        BHI     %BT10
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strncpy
; =======
;
; In    r1 -> dest
;       r2 -> source
;       r3 = max size of string to copy ( <= r3+1 bytes filled )
; Out   Regs preserved and string copied.

strncpy Entry   "r1-r3"
        ; Initialise for the main loop
        CMP     r3, #0
        B       %FT20

        ; Main loop starts here
10      LDRB    r14, [r2], #1
        STRB    r14, [r1], #1
        CMP     r14, #delete
        CMPNE   r14, #space-1
        SUBNES  r3, r3, #1
20      BHI     %BT10           ; Loop entered here
        EXIT    NE              ; Exit if terminator is non-delete or < space-1
        TEQ     r3, #0
        EXIT    NE              ; Exit if didn't run out of space
        MOV     r14, #0
        STRB    r14, [r1]       ; Did run out of space, so terminate it now
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strcpy_advance
; ==============
;
; In    r1 -> dest area
;       r2 -> source string
;
; Out   r1 -> terminating null

strcpy_advance EntryS "r2"

10      LDRB    r14, [r2], #1           ; Copy from *r2++
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, #space-1           ; Any char < space is a terminator
        MOVLS   r14, #0                 ; Terminate dst with 0
        STRB    r14, [r1], #1           ; Copy to *r1++
        BHI     %BT10

        SUB     r1, r1, #1              ; -> null
        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strcmp
; ======
;
; Compares two strings (case insensitive)
;
; In    r1 -> string, CtrlChar/r6 terminated
;       r2 -> string, CtrlChar/r6 terminated
;
; Out   EQ/NE as appropriate

strcmp Entry "r1, r2, r4-r7"

        MOV     r6, #space-1

00      LDR     r7, lower_case_table

10      LDRB    r4, [r1], #1
        CMP     r4, #space-1
        MOVLS   r4, #0
        CMP     r4, r6
        CMPNE   r4, #delete
        MOVEQ   r4, #0
        LDRB    r4, [r7, r4]

        LDRB    r5, [r2], #1
        CMP     r5, #space-1
        MOVLS   r5, #0
        CMP     r5, r6
        CMPNE   r5, #delete
        MOVEQ   r5, #0
        LDRB    r5, [r7, r5]

        CMP     r4, r5
        EXIT    NE                      ; [differ]

        CMP     r4, #0
        BNE     %BT10                   ; [more to come]

        EXIT                            ; [EQ: both finished together]

; .............................................................................

strcmp_excludingspaces ALTENTRY

        MOV     r6, #space
        B       %BT00

 [ disallow_recursive_copies
strcmpTS ALTENTRY
        B       %BT00
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strncmp
; =======
;
; Compares two strings (case insensitive)

; In    r1 -> string, CtrlChar/r6 terminated
;       r2 -> string, CtrlChar/r6 terminated
;       r3 = source span

; Out   EQ/NE as appropriate: if EQ,CC -> span matched, but dest not finished

strncmp Entry "r1-r7"

        MOV     r6, #space-1

00      LDR     r7, lower_case_table

10      CMP     r3, #0                  ; Finished source span ?
        BEQ     %FT90

        SUB     r3, r3, #1

        LDRB    r4, [r1], #1
        CMP     r4, #space-1
        MOVLS   r4, #0
        CMP     r4, r6
        CMPNE   r4, #delete
        MOVEQ   r4, #0
        LDRB    r4, [r7, r4]

        LDRB    r5, [r2], #1
        CMP     r5, #space-1
        MOVLS   r5, #0
        CMP     r5, r6
        CMPNE   r5, #delete
        MOVEQ   r5, #0
        LDRB    r5, [r7, r5]

        CMP     r4, r5
        EXIT    NE                      ; [differ]

        CMP     r4, #0
        BNE     %BT10                   ; [more to come]

        EXIT                            ; [EQ,CS: both finished together]


90      LDRB    r5, [r2]                ; Has comparison string now finished ?
        CMP     r5, #delete             ; Order, you git !
        CMPNE   r5, r6
        MOVLS   r5, #1                  ; CS -> span matched, dest finished
        MOVHI   r5, #0                  ; CC -> span matched, dest not finished
        MOVS    r5, r5, LSR #1          ; EQ always
        EXIT

; .............................................................................

strncmp_excludingspaces ALTENTRY

        MOV     r6, #space
        B       %BT00

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strcmp_sensitive
; ================
;
; Compares two strings (case sensitive)
;
; In    r1 -> string, CtrlChar/r6 terminated
;       r2 -> string, CtrlChar/r6 terminated
;
; Out   EQ/NE as appropriate

strcmp_sensitive Entry "r1, r2, r4-r7"

10      LDRB    r4, [r1], #1
        CMP     r4, #space-1
        MOVLS   r4, #0
        CMP     r4, r6
        CMPNE   r4, #delete
        MOVEQ   r4, #0

        LDRB    r5, [r2], #1
        CMP     r5, #space-1
        MOVLS   r5, #0
        CMP     r5, r6
        CMPNE   r5, #delete
        MOVEQ   r5, #0

        CMP     r4, r5
        EXIT    NE

        CMP     r4, #0
        BNE     %BT10

        EXIT


        END

@


4.5
log
@        ensure neither large icon or small icon app name exceeds 12 chars
        even when app name is much longer. Re-enabled Alt-Select for icons
        whilst leaving Alt-Select renaming active.
Detail:
Admin:
     castle added ip.
     tested in iyonix rom


Version 2.10. Tagged as 'Filer-2_10'
@
text
@d15 1
a15 2
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;                      C o m m o n   r o u t i n e s
d22 1
a22 1

d24 1
a24 1

d43 1
a43 1

d45 1
a45 1

d65 1
a65 3
; =======
; strncat12
; =======
d67 1
a67 1
; Copy n, 10, or 12 characters from string pointed to by r2
d71 1
a71 1
;       r2 -> CtrlChar/r3 terminated string
d76 2
a77 3

strncat10 Entry "r1-r5"

d79 1
a79 10
        B       strncat02

strncat12 Entry "r1-r5"

        MOV     r4, #12
        B       strncat02

strncat Entry "r1-r5"
strncat02
        MOV     r3, #space-1
d81 2
d90 1
a90 1
        CMPNE   r14, r3                 ; Any char <= r3 terminates copy
d95 3
a97 5
        SUB     r4, r4, #1
        CMP     r4, #0
        BGT     %BT10
        MOV     r14, #0
        STRB    r14, [r1], #1
d109 1
a109 1

d112 1
a112 1

d147 1
a147 1

d173 1
a173 1

d177 1
a177 3
AppendLeafnameToDirname ; NOROUT

        ALTENTRY
d193 2
a194 1
; .............................................................................
d196 1
d202 1
d214 1
d216 1
d246 1
a246 1

d249 1
a249 1

d270 1
a270 1

d273 1
a273 1

d388 1
a388 1

d391 1
a391 1

@


4.4
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 2.01. Tagged as 'Filer-2_01'
@
text
@d65 4
d70 2
a71 2
; Copy n characters from string pointed to by r2 onto string pointed to
; by r1.
d79 11
d91 1
a91 1

a92 1
        MOV     r4, #10
@


4.3
log
@Made 32-bit compatible. Quite a complex job, and only limited testing so far.

Version 1.97. Tagged as 'Filer-1_97'
@
text
@d75 1
a75 1
strncat ENTRY "r1-r5"
d201 1
a201 1
nul_terminate ENTRY "r1"
d219 1
a219 1
strncpy ENTRY   "r1-r3"
d272 1
a272 1
strcmp ENTRY "r1, r2, r4-r7"
d327 1
a327 1
strncmp ENTRY "r1-r7"
d390 1
a390 1
strcmp_sensitive ENTRY "r1, r2, r4-r7"
@


4.2
log
@Merged Ursula branch.
Moved to srccommit.

Version 1.96. Tagged as 'Filer-1_96'
@
text
@d28 1
a28 1
strlen ENTRY "r0"
d49 1
a49 1
strlen_excludingspaces ENTRY "r0"
d90 1
a90 1
        EXITS   LS
d98 1
a98 1
        EXITS
d114 1
a114 1
strcat ENTRY "r1-r3"
d231 1
a231 1
        EXITS   NE              ; Exit if terminator is non-delete or < space-1
d233 1
a233 1
        EXITS   NE              ; Exit if didn't run out of space
d236 1
a236 1
        EXITS
d248 1
a248 1
strcpy_advance ENTRY "r2"
d391 1
a391 1
                      
d405 1
a405 1
        
d408 1
a408 1
        
d411 1
a411 1
        
@


4.1
log
@Initial revision
@
text
@d60 42
d139 1
d378 36
d416 1
@


4.1.4.1
log
@Long filename support and SaveAs style new directory creation
@
text
@a59 42

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strncat
; =======
;
; Copy n characters from string pointed to by r2 onto string pointed to
; by r1.
;
; In    r1 -> NULL terminated string
;       r2 -> CtrlChar/r3 terminated string
;       r4 = n
;
; Out   new string in r1 = "r1" :CC: "r2" :CC: 0

strncat ENTRY "r1-r5"

        MOV     r3, #space-1
        MOV     r4, #10

05      LDRB    r14, [r1], #1           ; Find where to stick the appendage
        CMP     r14, #0
        BNE     %BT05
        SUB     r1, r1, #1              ; Point back to the term char

10      LDRB    r14, [r2], #1           ; Copy from *r2++
        CMP     r14, #delete            ; Order, you git!
        CMPNE   r14, r3                 ; Any char <= r3 terminates copy
        MOVLS   r14, #0                 ; Terminate dst with 0
        STRB    r14, [r1], #1           ; Copy to *r1++
        EXITS   LS

        SUB     r4, r4, #1
        CMP     r4, #0
        BGT     %BT10
        MOV     r14, #0
        STRB    r14, [r1], #1

        EXITS



a96 1

a334 36
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; strcmp_sensitive
; ================
;
; Compares two strings (case sensitive)

; In    r1 -> string, CtrlChar/r6 terminated
;       r2 -> string, CtrlChar/r6 terminated

; Out   EQ/NE as appropriate

strcmp_sensitive ENTRY "r1, r2, r4-r7"
                      
10      LDRB    r4, [r1], #1
        CMP     r4, #space-1
        MOVLS   r4, #0
        CMP     r4, r6
        CMPNE   r4, #delete
        MOVEQ   r4, #0

        LDRB    r5, [r2], #1
        CMP     r5, #space-1
        MOVLS   r5, #0
        CMP     r5, r6
        CMPNE   r5, #delete
        MOVEQ   r5, #0
        
        CMP     r4, r5
        EXIT    NE
        
        CMP     r4, #0
        BNE     %BT10
        
        EXIT

a336 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

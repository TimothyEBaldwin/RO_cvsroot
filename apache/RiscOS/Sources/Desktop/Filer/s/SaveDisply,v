head	4.5;
access;
symbols
	Filer-2_43:4.5
	Filer-2_42:4.5
	Filer-2_41:4.5
	Filer-2_40:4.5
	Filer-2_39:4.5
	Filer-2_38:4.5
	Filer-2_37:4.5
	Filer-2_36:4.5
	Filer-2_35:4.5
	Filer-2_34:4.5
	Filer-2_33:4.5
	Filer-2_32:4.5
	Filer-2_31:4.5
	Filer-2_30:4.5
	Filer-2_29:4.5
	Filer-2_28:4.5
	Filer-2_27:4.5
	Filer-2_26:4.5
	Filer-2_25:4.4
	Filer-2_24:4.4
	Filer-2_23:4.4
	Filer-2_22:4.4
	Filer-2_21:4.4
	Filer-2_20:4.4
	Filer-2_19:4.3
	Filer-2_18:4.3
	Filer-2_17:4.3
	Filer-2_16:4.3
	Filer-2_15:4.3
	Filer-2_14:4.3
	Filer-2_13:4.3
	Filer-2_12:4.3
	Filer-2_11:4.3
	Filer-2_10:4.3
	Filer-2_09:4.3
	RO_5_07:4.3
	Filer-2_08:4.3
	Filer-2_07:4.3
	Filer-2_06:4.3
	Filer-2_05:4.3
	Filer-2_04:4.3
	Filer-2_03:4.3
	Filer-2_02:4.3
	Filer-2_01:4.3
	Filer-2_00:4.2
	Filer-1_99:4.2
	Filer-1_98:4.2
	Filer-1_97:4.2
	Ursula_merge:4.1.4.1
	Filer-1_96:4.2
	Filer-1_95:4.1.4.1
	nturton_Filer-1_85:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rleggett_Filer-1_94:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rleggett_Filer-1_93:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.5
date	2010.10.23.18.02.28;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2009.12.05.20.21.42;	author jlee;	state Exp;
branches;
next	4.3;

4.3
date	2001.03.16.17.09.23;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.08.17.11.56.42;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.31;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.31;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.27.38;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.10.21.09.38.39;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.17.11;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.16.20;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Fix for 'set type' writeable icon being out of step with the disc.
Adjust clicking would recreate the menu immediately after the operation but before the next wimp poll when the directory gets recached, so the first entry in the cache is manually fixed up so the recreated menu is right (the files all get refreshed later anyway).
Collapsed switch 'Fix003', after 21 years of testing it's safe to assume it's good.
Reinstated ExtractCMOSOptions conditional on not OptionsAreInRAM so that combination still assembles.
Optimise MUL/ADD into MLA where possible, and set 'S' flag on ALU operations when followed by TEQ#0.
Tested with & without filer action running, fixes ticket 254.

Version 2.26. Tagged as 'Filer-2_26'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; transfer_bytes
; In    r1 -> source of bytes
;       r3 =  Size of source
;       r7 =  Number of bytes passed over so far
;       r8 =  Number of bytes to not transfer at start
;       r9 -> destination buffer
;       r10 = offset into destination buffer to put bytes
;       r11 = destination buffer size
;
; Out   r7 incremented by number of bytes passed over
;       r8 decremented by number of bytes transfered
;       r10 = offset of byte past last byte transfered
;       HS indicates destination buffer full
;       LO indicates not full
;       bytes transfered to estination buffer

transfer_bytes Entry "r1,r3"
10      ; Exit if destination full
        CMP     r10, r11
        EXIT    HS

        ; Exit if source is empty
        TEQ     r3, #0
        BEQ     %FT90

        ; Transfer if no nullcount, else decrement nullcount
        CMP     r8, #0
        LDREQB  r0, [r1]
        STREQB  r0, [r9, r10]
        ADDEQ   r10, r10, #1
        SUBNE   r8, r8, #1
        ADD     r1, r1, #1
        ADD     r7, r7, #1
        SUB     r3, r3, #1

        ; loop
        B       %BT10

        ; exit for source empty
90      CMP     r10, r11
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; transfer_number
; In    r0 = number to transfer
;       r7 =  Number of bytes passed over so far
;       r8 =  Number of bytes to not transfer at start
;       r9 -> destination buffer
;       r10 = offset into destination buffer to put bytes
;       r11 = destination buffer size
;
; Out   r0 -> error if VS, else
;       exit as per transfer_bytes
;
 [ version >= 155
transfer_number Entry "r1,r2,r3,r4", 20
 |
transfer_number Entry "r1,r2,r3,r4", 16
 ]
        MOV     r1, sp
        MOV     r2, #16

 [ version >= 155
        CMP     r0, #0                  ; negative number?
        MOVLT   r4, #quote              ; then put a quote in
        STRLTB  r4, [r1], #1            ; moving r1 along
 ]

        SWI     XOS_BinaryToDecimal     ; preserves r0, r1
        EXIT    VS

 [ version >= 155
        CMP     r0, #0                  ; negative number?
        STRLTB  r4, [r1, r2]            ; r4 should still hold quote mark
        MOVLT   r1, sp                  ; real start of string
        ADDLT   r2, r2, #2              ; room for two quote marks
 ]

        MOV     r3, r2
        BL      transfer_bytes
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; transfer_a_space
; In    r7 =  Number of bytes passed over so far
;       r8 =  Number of bytes not to transfer at start
;       r9 -> destination buffer
;       r10 = offset into destination buffer to put bytes
;       r11 = destination buffer size
;
; Out   exit as per transfer_bytes
;
a_space DCB     " "
transfer_a_space Entry "r1,r3"
        ADR     r1, a_space
        MOV     r3, #1
        BL      transfer_bytes
        EXIT

a_newline DCB   LF
sortmodes DCB "-sn-st-ss-sd"
displaymodes DCB "-li-si-fi"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; savedisplay_fillbuffer
;
; In    r9 -> destination buffer
;       r10 = destination buffer offset
;       r11 = destination buffer size
;
; Out   r10 = offset past last byte transfered. If r10 < r11 then operation
;             has finished.
;       r0 will be corrupted, and if VS then r0 -> error.

savedisplay_fillbuffer Entry "r1-r9,r11", 36
     ; Initialise
        ; Go down the viewer list, stopping on viewer first_viewerno.
        ; Viewers are numbered 0 upwards.
        LDR     r6, first_viewerno
        CMP     r6, #Nowt
        EXIT    EQ
        MOV     r0, #0
        LDR     r4, ViewerList
05      CMP     r4, #Nowt
        BEQ     %FT90
        CMP     r0, r6
        BHS     %FT06
        LDR     r4, [r4, #d_link]
        ADD     r0, r0, #1
        B       %BT05

06      ; First viewer found:zero bytes read from it, and read in
        ; number of bytes to not transfer
        MOV     r7, #0
        LDR     r8, next_nullcount

10      ; Main loop. One execution of this loop corresponds to transfering
        ; the details of one viewer. The registers are allocated as
        ; follows:
        ; r4 -> Viewer being transfered
        ; r6 =  Number (starting at 0) of viewer being transfered
        ; r7 =  Number of bytes passed over for this viewer
        ; r8 =  Number of bytes left to ignore for this viewer
        ; r9 -> destination buffer
        ; r10 = offset into destination buffer
        ; r11 = destination buffer size

        ; Filer_OpenDir
        addr    r1, Filer_CommandTable
        BL      strlen
        BL      transfer_bytes
        BHS     %FT90
        BL      transfer_a_space
        BHS     %FT90

        ; <full dirname>
        LDR     r1, [r4, #d_dirnamestore]
        BL      strlen_excludingspaces
        BL      transfer_bytes
        BHS     %FT90
        BL      transfer_a_space
        BHS     %FT90

        ; r0 = x0
        ; r1 = y1
        ; r2 = w
        ; r3 = h
        MOV     r1, sp
        LDR     r0, [r4, #d_handle]
        STR     r0, [r1]
        SWI     XWimp_GetWindowState
        EXIT    VS
        LDR     r0, [r1, #u_wax0]
        LDR     r2, [r1, #u_wax1]
        SUB     r2, r2, r0
        LDR     r3, [r1, #u_way0]
        LDR     r1, [r1, #u_way1]
        SUB     r3, r1, r3

        ; x0
        BL      transfer_number
        EXIT    VS
        BHS     %FT90
        BL      transfer_a_space
        BHS     %FT90

        ; y1
        MOV     r0, r1
        BL      transfer_number
        EXIT    VS
        BHS     %FT90
        BL      transfer_a_space
        BHS     %FT90

        ; w
        MOV     r0, r2
        BL      transfer_number
        EXIT    VS
        BHS     %FT90
        BL      transfer_a_space
        BHS     %FT90

        ; h
        MOV     r0, r3
        BL      transfer_number
        EXIT    VS
        BHS     %FT90
        BL      transfer_a_space
        BHS     %FT90

        ; sortmode
        LDRB    r0, [r4, #d_viewmode]
        AND     r3, r0, #db_sortmode
        MOV     r3, r3, LSR #dbb_sortmode
        ADD     r3, r3, r3, LSL #1              ; r3 = r3*3
        addr    r1, sortmodes
        ADD     r1, r1, r3
        MOV     r3, #3
        BL      transfer_bytes
        BHS     %FT90
        BL      transfer_a_space
        BHS     %FT90

        ; display mode
        LDRB    r0, [r4, #d_viewmode]
        AND     r3, r0, #db_displaymode
        ; The next line should read
        ; MOV     r3, r3, LSR #dbb_displaymode
        ; but the assembler can't cope with zero shifts, so
        ; the line is taken out
        ADD     r3, r3, r3, LSL #1              ; r3 = r3*3
        addr    r1, displaymodes
        ADD     r1, r1, r3
        MOV     r3, #3
        BL      transfer_bytes
        BHS     %FT90
        addr    r1, a_newline
        MOV     r3, #1
        BL      transfer_bytes
        BHS     %FT90

        ; Get pointer to next viewer in the list
        ADD     r6, r6, #1
        LDR     r4, [r4, #d_link]
        CMP     r4, #Nowt
        BEQ     %FT90
        MOV     r7, #0
        B       %BT10

90      ; Finished. May be destination full or source empty.
        STR     r7, next_nullcount
        STR     r6, first_viewerno
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; sortviewers_bystacking
;
; In    Nothing
; Out   r0 corrupted
;       Dir viewers sorted by stacking order, bottom first
;
sortviewers_bystacking Entry "r1-r4", u_windowstate
        ; Zero out the sort links
        LDR     r2, ViewerList
        MOV     r1, #0
10      CMP     r2, #Nowt
        BEQ     %FT20
        STR     r1, [r2, #d_sortlink]
        LDR     r2, [r2, #d_link]
        B       %BT10

20      ; Find a viewer with a 'zero' sortlink
        LDR     r2, ViewerList
30      CMP     r2, #Nowt
        BEQ     %FT60
        LDR     r1, [r2, #d_sortlink]
        BICS    r1, r1, #2
        BEQ     %FT40
        LDR     r2, [r2, #d_link]
        B       %BT30

40      ; Store the viewer's window handle in the open block
        LDR     r1, [r2, #d_handle]
        STR     r1, [sp, #u_handle]

        ; Find the next window up the stack
        MOV     r1, sp
50      SWI     XWimp_GetWindowState
        EXIT    VS
        LDR     r0, [sp, #u_bhandle]
        CMP     r0, #-1
        LDREQ   r0, [r2, #d_sortlink]
        ORREQ   r0, r0, #Nowt
        STREQ   r0, [r2, #d_sortlink]
        BEQ     %BT20

        BL      FindDir

        STRNE   r0, [sp, #u_handle]
        BNE     %BT50

        ; Found the dir. Link r2 to r4 (the found dir). Flag r4 that it
        ; is being pointed at.
        LDR     r3, [r2, #d_sortlink]
        ORR     r3, r3, r4
        STR     r3, [r2, #d_sortlink]
        LDR     r3, [r4, #d_sortlink]
        ORR     r3, r3, #2
        STR     r3, [r4, #d_sortlink]
        B       %BT20

60      ; Finished. Find the start and redo the chain.
        LDR     r1, ViewerList
70      CMP     r1, #Nowt
        EXIT    EQ              ; Disaster!! - best leave well alone.
        LDR     r2, [r1, #d_sortlink]
        TST     r2, #2
        BEQ     %FT80
        LDR     r1, [r1, #d_link]
        B       %BT70

80      STR     r1, ViewerList

90      LDR     r2, [r1, #d_sortlink]
        BIC     r2, r2, #2
        STR     r2, [r1, #d_link]
        MOV     r1, r2
        CMP     r1, #Nowt
        BNE     %BT90

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; savedisplay_init
;
; In    Nothing
; Out   Status all set up for a displaysave from the start

savedisplay_init Entry "r0,r3"
        MOV     r0, #0
        STR     r0, next_nullcount
        STR     r0, first_viewerno

        ; Simulate last transfer used all of a full buffer
        MOV     r0, #displaysave_buffers
        STR     r0, displaysave_buffer_rover
        STR     r0, displaysave_buffer_bytes_in_it

        ; Sort the viewers
        BL      sortviewers_bystacking

        ; Get a buffer
        MOV     r3, #displaysave_buffers
        ADR     r0, displaysave_bufferp
        BL      SNewArea

        ; If failed, invalidate the viewerno
        MOVVS   r3, #Nowt
        STRVS   r3, first_viewerno

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; In    r1 -> file name

savedisplay_intofile Entry "r1,r2,r10,r11"

        ; Open the file for output
        MOV     r0, #2_10000111 ; OPENOUT
        SWI     XOS_Find
        BVS     %FT90

        ; Hold name and handle in r10, r11
        MOV     r11, r0
        MOV     r10, r1

        ; Set the type of the file to obey
        MOV     r0, #OSFile_SetType
        LDR     r2, =FileType_Obey
        SWI     XOS_File
        BVS     %FT70

        MOV     r1, r11
        BL      savedisplay_intofilehandle
        BVS     %FT70

        ; Close the file
        MOV     r0, #0
        MOV     r1, r11
        SWI     XOS_Find
        BVS     %FT80
        EXIT

70      ; Error: close and delete the file
        BLVS    LocalReportError

        MOV     r0, #0
        MOV     r1, r11                 ; file handle
        SWI     XOS_Find

80      ; Error: delete the file
        BLVS    LocalReportError
        MOV     r0, #OSFile_Delete
        MOV     r1, r10                 ; file name
        SWI     XOS_File

90      ; Error: no tidying up to do
        BLVS    LocalReportError
        ADR     r0, ErrorBlock_Filer_FailedSave
        BL      LookupError
        EXIT

        LTORG

        MakeErrorBlock  Filer_FailedSave

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; savedisplay_intofilehandle
;
; In    r1 = file handle
savedisplay_intofilehandle Entry "r1-r4,r9-r11"
        ; Init for transfering bytes of filer_opendir commands
        BL      savedisplay_init
        EXIT    VS

        ; Get the details of the buffer
        LDR     r9, displaysave_bufferp
        MOV     r11, #displaysave_buffers

10      ; Extract a next bufferfull  starting at offset 0 into the buffer
        MOV     r10, #0
        BL      savedisplay_fillbuffer
        BVS     %FT95

        ; Save the buffer into the file
        MOV     r0, #2          ; OS_GBPB 2 = put buffer to file
                                ; r1 = handle already
        MOV     r2, r9          ; Buffer location
        MOVS    r3, r10         ; Buffer size = bytes transfered into buffer
        SWINE   XOS_GBPB
        BVS     %FT95
        CMP     r10, r11        ; If buffer was filled, go round again.
        BHS     %BT10

90      ; Junk the buffer
        BL      discard_savedisplaybuffer
        EXIT

95      ; Junk the save buffer (after an error)
        BL      discard_savedisplaybuffer
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Saves the applications in the applications list as a sequence of filer_boots
;
; In r1 = file handle
; Out r0 corrupted and file written
;
saveapps_intofilehandle Entry "r1-r6"
        LDR     r5, ApplicList
        MOV     r6, r1
        MOV     r0, #OSGBPB_WriteAtPTR
        B       %FT50
10
        ; Only save boot sequence for booted applications
        LDRB    r1, [r5, #a_wasbooted]
        TEQ     r1, #0
        BEQ     %FT30
        ADR     r1, filer_boot_command
        BL      strlen
        MOV     r2, r1
        MOV     r1, r6
        SWI     XOS_GBPB
        EXIT    VS
        LDR     r2, [r5, #a_dir]
        ADD     r2, r2, #ad_name
        ;ADR     r1, dirnamebuffer
        LDR     r1, dirnamebuffer
        BL      strcpy
        ADD     r2, r5, #a_leafname
        BL      AppendLeafnameToDirname
        BL      strlen
        MOV     r2, r1
        MOV     r1, r6
        SWI     XOS_GBPB
        EXIT    VS
        addr    r2, a_newline
        MOV     r3, #1
        SWI     XOS_GBPB
        EXIT    VS
30

        LDR     r5, [r5, #a_link]
50
        CMP     r5, #Nowt
        BNE     %BT10
        EXIT

filer_boot_command
        DCB     "Filer_Boot ",0

        END
@


4.4
log
@Fix alignment exception in Filer desktop save code
Detail:
  transfer_number was allocating 18 bytes of space on the stack, leaving SP unaligned. To avoid alignment exceptions on ARMv6+, 20 bytes are now allocated instead.
Admin:
  Tested on rev C2 beagleboard


Version 2.20. Tagged as 'Filer-2_20'
@
text
@d80 1
a80 1
        MOVLT   r4, #""""               ; then put a quote in
d292 1
a292 2
        BIC     r1, r1, #2
        TEQ     r1, #0
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 2.01. Tagged as 'Filer-2_01'
@
text
@d71 1
a71 1
transfer_number Entry "r1,r2,r3,r4", 18
@


4.2
log
@Merged Ursula branch.
Moved to srccommit.

Version 1.96. Tagged as 'Filer-1_96'
@
text
@d32 1
a32 1
transfer_bytes ENTRY "r1,r3"
d71 1
a71 1
transfer_number ENTRY "r1,r2,r3,r4", 18
d73 1
a73 1
transfer_number ENTRY "r1,r2,r3,r4", 16
d109 1
a109 1
transfer_a_space ENTRY "r1,r3"
d130 1
a130 1
savedisplay_fillbuffer ENTRY "r1-r9,r11", 36
d277 1
a277 1
sortviewers_bystacking ENTRY "r1-r4", u_windowstate
d355 1
a355 1
savedisplay_init ENTRY "r0,r3"
d383 1
a383 1
savedisplay_intofile ENTRY "r1,r2,r10,r11"
d438 1
a438 1
savedisplay_intofilehandle ENTRY "r1-r4,r9-r11"
d476 1
a476 1
saveapps_intofilehandle ENTRY "r1-r6"
@


4.1
log
@Initial revision
@
text
@d494 2
a495 1
        ADR     r1, dirnamebuffer
@


4.1.4.1
log
@Fixed bug with system font in Filer windows, plus redraw of highlighted icons.
@
text
@d494 1
a494 2
        ;ADR     r1, dirnamebuffer
        LDR     r1, dirnamebuffer
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

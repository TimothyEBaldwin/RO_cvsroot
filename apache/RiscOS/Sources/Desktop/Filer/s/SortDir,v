head	4.13;
access;
symbols
	Filer-2_43:4.13
	Filer-2_42:4.13
	Filer-2_41:4.13
	Filer-2_40:4.13
	Filer-2_39:4.12
	Filer-2_38:4.12
	Filer-2_37:4.12
	Filer-2_36:4.12
	Filer-2_35:4.11
	Filer-2_34:4.11
	Filer-2_33:4.10
	Filer-2_32:4.10
	Filer-2_31:4.10
	Filer-2_30:4.10
	Filer-2_29:4.10
	Filer-2_28:4.10
	Filer-2_27:4.9
	Filer-2_26:4.8
	Filer-2_25:4.8
	Filer-2_24:4.8
	Filer-2_23:4.8
	Filer-2_22:4.8
	Filer-2_21:4.7
	Filer-2_20:4.7
	Filer-2_19:4.7
	Filer-2_18:4.7
	Filer-2_17:4.7
	Filer-2_16:4.7
	Filer-2_15:4.7
	Filer-2_14:4.7
	Filer-2_13:4.7
	Filer-2_12:4.7
	Filer-2_11:4.7
	Filer-2_10:4.7
	Filer-2_09:4.7
	RO_5_07:4.7
	Filer-2_08:4.7
	Filer-2_07:4.6
	Filer-2_06:4.6
	Filer-2_05:4.5
	Filer-2_04:4.5
	Filer-2_03:4.5
	Filer-2_02:4.4
	Filer-2_01:4.4
	Filer-2_00:4.3
	Filer-1_99:4.3
	Filer-1_98:4.3
	Filer-1_97:4.3
	Ursula_merge:4.1.4.1
	Filer-1_96:4.2
	Filer-1_95:4.1.4.1
	nturton_Filer-1_85:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	rleggett_Filer-1_94:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rleggett_Filer-1_93:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2015.07.29.19.19.49;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	IGbCCybMxb91odvy;

4.12
date	2014.03.01.22.54.00;	author jlee;	state Exp;
branches;
next	4.11;
commitid	c84NTBTZAa5S73rx;

4.11
date	2013.11.24.12.33.03;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	qgjIfJ3IKLI7Owex;

4.10
date	2011.10.26.07.31.15;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	c97VPz82jzpbzPEv;

4.9
date	2011.10.14.20.30.47;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	H69jZPpdLOazgmDv;

4.8
date	2010.01.07.21.52.58;	author rool;	state Exp;
branches;
next	4.7;

4.7
date	2003.02.04.14.30.59;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2003.01.09.15.58.11;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2001.05.18.10.49.31;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2001.03.16.17.09.24;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.04.20.16.21.14;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.08.17.11.56.45;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.32;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.32;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.27.44;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.01.07.10.27.57;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.17.24;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.16.27;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Minor filer fixes
When a viewer is in 'sort by size' mode the size of image files was not being considered. So, a dir full of ZIP files (SparkFS not run) would be in size order amongst the other files, but if SparkFS was running the image files would be sorted as dirs of 0 size.
Fix for ticket #400, the *Filer_Run command now defaults to '-noshift' and inspecting the shift key state must be requested (opt in instead of opt out). This solves two key annoyances, running the !Boot sequence and holding shift causes you to enter the desktop with the obey files from the Tasks directory unhelpfully loaded in a text editor, and when setting a task alarm in !Alarm if the alarm happens to go off when you're typing with the shift key the task's !Run file opens in a text editor.

SortDir.s: count image files as files so they're sorted like they were in Filer 2.26
Commands.s: parse new option switch, and consider -noshift the default
Messages/HelpSrc: add the switch to the command syntax

Tested with a task alarm in !Alarm with and without shift held down, and running a !Boot sequence similarly.

Version 2.40. Tagged as 'Filer-2_40'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sort directory

; In    r1 -> dirviewer block (strange)
;       [r1, #d_viewmode] :SHR: dbb_sortmode =
;         0 (name), 1 (type), 2 (size), 3 (date)

; Out   items re-ordered (blocks only - names are ref by ptrs)

SortDir Entry   "r1-r11"

 [ debug
 DREG r1, "Sorting dirviewer "
 ]
        InvSmiWidth  r1
        LDR     r0, [r1, #d_nfiles]
        CMP     r0, #2
        EXIT    LT                      ; [nothing to do]

        ; Check if there's room in sortingbuffer
        ADR     r10, sortingbuffer      ; r10 -> buffer
        CMP     r0, #sortingbuffer_entries
        BLT     %FT01

        ; If not, try and claim enough memory in RMA
        MOV     r3, r0, LSL #2          ; we want entries * 4 bytes
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS                      ; Couldn't claim it
        MOV     r10, r2                 ; r10 -> buffer

; work out correct sorting procedure for HeapSort, and do it!
01
        LDRB    r0, [r1, #d_viewmode]
        TST     r0, #db_sortorder
        ADREQ   r14, sortproctable
        ADRNE   r14, reversesortproctable

        AND     r0, r0, #db_sortmode
        MOV     r0, r0, LSR #dbb_sortmode ; 0..3
 [ debug
 DREG r0, "sort mode (0..3) "
 ]
        LDR     r2, [r14, r0, LSL #2]   ; offset to routine
        ADD     r2, r14, r2             ; r2 -> routine for OS_HeapSort

        LDR     r0, [r1, #d_nfiles]     ; r0 = number of items
        MOV     r3, r1                  ; r3 -> dirviewer^ passed in r12 to sort procs
        ADD     r4, r1, #d_headersize   ; r4 -> base of data
        MOV     r5, #df_size            ; r5 = element size
        MOV     r1, r10                 ; r1 -> array of pointers
 [ debug
 DREG r0,"OS_HeapSort: n ",cc,Integer
 DREG r1,", array ",cc
 DREG r2,", proc ",cc
 DREG r3,", baseaddr ",cc
 DREG r4,", block ",cc
 DREG r5,", size "
 ]
        TST     r1, #2_111 :SHL: 29     ; use old or new SWI depending on
        BNE     %FT20                   ; address
        ORR     r1, r1, #2_11 :SHL: 30  ; Ask HeapSort to build pointer array
                                        ; itself and shuffle data after sorting
        SWI     XOS_HeapSort
        B       %FT25
20      MOV     r7, #2_11 :SHL: 30
        SWI     XOS_HeapSort32
25
        ; if we claimed any RMA for the sort, free it now
        ADR     r0, sortingbuffer
        CMP     r0, r10
        EXIT    EQ                      ; We used sortingbuffer, not RMA

        MOV     r0, #ModHandReason_Free
        MOV     r2, r10
        SWI     XOS_Module
        EXIT

sortproctable

        DCD     sort_name - sortproctable ; directory viewer
        DCD     sort_type - sortproctable
        DCD     sort_size - sortproctable
        DCD     sort_date - sortproctable

reversesortproctable

        DCD     reverse_sort_name - reversesortproctable ; directory viewer
        DCD     reverse_sort_type - reversesortproctable
        DCD     reverse_sort_size - reversesortproctable
        DCD     reverse_sort_date - reversesortproctable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sort procedures called in SVC mode, with r13 FD stack

; In    r0 -> first object
;       r1 -> second object
;       r12 -> value from r3 on calling OS_HeapSort

; Out   LT,GE from CMP between first and second objects
;       r0-r3 may be corrupted
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; sort by name:
; -------------
;   names (A..Z)

reverse_sort_name

sort_name Entry
        LDR     r3, [r12, #d_filenames] ; base of filenames
        
        LDR     r2, [r1, #df_fileptr]
 [ not_16bit_offsets
        ADD     r2, r3, r2              ; r2 -> name(r1)
 |
        ADD     r2, r3, r2, LSR #16     ; r2 -> name(r1)
 ]

        LDR     r1, [r0, #df_fileptr]
 [ not_16bit_offsets
        ADD     r1, r3, r1              ; r1 -> name(r0)
 |
        ADD     r1, r3, r1, LSR #16     ; r1 -> name(r0)
 ]

        LDRB    r0, [r12, #d_viewmode]  ; sorting mode

        TST     r0, #db_sortorder
        MOVNE   r3, r1                  ; swap r1 & r2 if reverse sort
        MOVNE   r1, r2
        MOVNE   r2, r3

        TST     r0, #db_sortnumeric
        MOVEQ   r3, #Collate_IgnoreCase
        MOVNE   r3, #Collate_IgnoreCase :OR: Collate_InterpretCardinals

        MOV     r0, #-1                 ; use configured territory
        SWI     XTerritory_Collate
        EXIT    VS
        CMP     r0, #0                  ; set LT, GE depending on which is smaller
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; sort by type:
; -------------
;   untyped files
;   typed files (000..FFF)
;   applications
;   directories

        MACRO
$label  LType   $rd, $rs, $rtemp
$label  LDRB    $rtemp, [$rs, #df_type]
        CMP     $rtemp, #dft_applic
        MOVEQ   $rd, #&1000             ; applications next to last in list
        MOVNE   $rd, #&2000             ; dirs last in list

        CMP     $rtemp, #dft_file
      [ version >= 143
        CMPNE   $rtemp, #dft_partition
      ]
        BNE     %FT01

 ASSERT df_load = 0
 ASSERT df_exec = 4
 ASSERT $rd < $rtemp ; For LDMIA !!!
        LDMIA   $rs, {$rd, $rtemp}

        TEQ     $rd, $rtemp
        MOVEQ   $rd, #-1
        BEQ     %FT01

        CMN     $rd, #&00100000
        MOVCC   $rd, #-1                ; [undated; first in list]
        MOVCS   $rd, $rd, LSL #12
        MOVCS   $rd, $rd, LSR #20
01
        MEND

reverse_sort_type Entry

        LType   r3, r0, r14
        LType   r2, r1, r14
        B       %FT10

sort_type ALTENTRY

        LType   r2, r0, r14
        LType   r3, r1, r14
10
        CMP     r2, r3
        BLEQ    sort_name               ; sort by name if types equal
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; sort by size:
; -------------
;   files (large..0)
;   applications        full size not known, so can't really order by it
;   directories         ditto

        MACRO
$label  LSize   $rdlo, $rdhi, $rs
$label  LDRB    $rdlo, [$rs, #df_type]
 ASSERT dft_dir < dft_applic
 ASSERT dft_file < dft_dir
      [ version >= 143
        TEQ     $rdlo, #dft_partition
        MOVEQ   $rdlo, #dft_file        ; equate partitions to files
      ]
        SUBS    $rdhi, $rdlo, #dft_dir  ; = 0 => 0 = dirs lowest
        MOVGT   $rdhi, #1               ; > 0 => 1 = applications next
        MOVMI   $rdhi, #2               ; < 0 => 2 = files highest
        MOVGE   $rdlo, #0               ; >=0 => apps & dirs have zero size
        LDRMI   $rdlo, [$rs, #df_length]
        MEND

reverse_sort_size Entry "r4, r5"

        LSize   r3, r5, r0
        LSize   r2, r4, r1
        B       %FT10

sort_size ALTENTRY

        LSize   r2, r4, r0
        LSize   r3, r5, r1
10
        SUBS    r14, r3, r2             ; descending order - CMP64
        MOVNE   r14, #Z_bit
        SBCS    r2, r5, r4
      [ No32bitCode
        TEQEQP  r14, pc
      |
        MRSEQ   r4, CPSR
        EOREQ   r4, r4, r14
        MSREQ   CPSR_f, r4
      ]
        BLEQ    sort_name               ; NB. don't corrupt r0,r1 if going
        EXIT                            ; to do sort_name !
        
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; sort by date:
; -------------
;   objects (new..1900)
;
; NB. Getting signed CMP results was difficult

        MACRO
$label  LDate   $rdlo, $rdhi, $rs
$label  LDRB    $rdhi, [$rs, #df_load]  ; High byte of date
        LDR     $rdlo, [$rs, #df_exec]  ; Low word of date
        MEND

reverse_sort_date Entry "r4, r5"

        LDate   r3, r5, r0              ; Get date
        LDate   r2, r4, r1
        B       %FT10

sort_date ALTENTRY

        LDate   r2, r4, r0              ; Get date
        LDate   r3, r5, r1
10
        SUBS    r14, r3, r2             ; descending order - CMP64
        MOVNE   r14, #Z_bit
        SBCS    r2, r5, r4
      [ No32bitCode
        TEQEQP  r14, pc
      |
        MRSEQ   r4, CPSR
        EOREQ   r4, r4, r14
        MSREQ   CPSR_f, r4
      ]
        BLEQ    sort_name               ; NB. don't corrupt r0,r1 if going
        EXIT                            ; to do sort_name !


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; sort for optimal redraw order
; -----------------------------
;
; This is similar to sort_type, except we don't care about the name, but we do
; care about dfs_selected & dfs_opened
;
; Note that R0 & R1 are (reverse) fileinfo numbers, not fileinfo pointers!

sort_redraw ALTENTRY
        ; Get fileinfo pointers. r12 points to end of fileinfo list, so:
        ASSERT  df_size = 7*4
        SUB     r2, r12, r0, LSL #3+2
        SUB     r3, r12, r1, LSL #3+2
        ADD     r0, r2, r0, LSL #2
        ADD     r1, r3, r1, LSL #2

        LType   r2, r0, r14
        LType   r3, r1, r14
        CMP     r2, r3
        BNE     %FT10
        LDRB    r2, [r0, #df_state]
        LDRB    r3, [r1, #df_state]
        AND     r2, r2, #dfs_selected + dfs_opened
        AND     r3, r3, #dfs_selected + dfs_opened
        CMP     r2, r3
10
        EXIT        

        END
@


4.12
log
@Redraw items in a more optimal order
Detail:
  This change moves some identical code out of event_redraw_window and UpdateFile, to create the RedrawDirectory routine.
  This new routine improves on the original code by using the spare part of the userdata block to build a list of all files which need redrawing, and then sorting the list by filetype & state in order to try and make sure all files which have the same sprites are drawn in one go. This helps avoid thrashing the translation table generation code in the Wimp/ColourTrans, and helps improve CPU cache performance.
  File changes:
  s/Redraw - Cut up event_redraw_window and  UpdateFile to create the new RedrawDirectory routine and SortAndDraw subroutine.
  s/SortDir - Add sort_redraw function which is used to sort the files into their redraw order. However it takes different arguments to the other sort routines and so is only of use to SortAndDraw.
Admin:
  Tested on Iyonix, BB-xM, StrongARM RiscPC


Version 2.36. Tagged as 'Filer-2_36'
@
text
@d225 1
a225 1
        MOVEQ   $rdlo, #dft_dir         ; equate partitions to dirs
@


4.11
log
@Add support for sorting dir contents numerically as well as alphabetically
New option to the display menu "Numerical sort" modifies the existing 4 sort methods (name, size, type, date) to sort by interpreting any numbers as cardinals. This modifier only really has effect on "Sort by name" since the other three already sort numerically.
This means for example a dir containing "File9,File10,File11" will appear in that order, whereas sorting by name alone would show "File10,File11,File9".

SelStuff0.s/SelStuff.s/Gets.s: Removed. Single function placed into SelStuff.
ModHdr.s/OpenDir.s/Commands.s/DebugFlags.s: Decoding of -NumericalSort switch, switched out undocumented 'Query' flags.
DecodeMenu.s/MenuCreate.s: Handle menu entry, simplify rename code a little.
HelpSrc.s/Messages: Extra help text.
SortDir.s: Pass option flag to Territory_Collate.
WkspEtc.s: Corrected definition of db_sm_type and db_sm_size.

Version 2.34. Tagged as 'Filer-2_34'
@
text
@d295 30
@


4.10
log
@Respect the sort direction in the event of a tie break.
Behaviour now matches 2.26 again.
Also, sort by name no longer preserves r0-r3 because the PRM says we can trash them.

Version 2.28. Tagged as 'Filer-2_28'
@
text
@d62 1
a62 4

        MOVEQ   r3, r1                  ; r3 -> dirviewer^ passed in r12 to sort procs
        ORRNE   r3, r1, #1              ; remember reverse sorts

d126 1
a126 3
        TST     r12, #1                 ; NE = reverse sorting
        BIC     r3, r12, #3             ; zap flags, get back dirviewer^
        LDR     r3, [r3, #d_filenames]  ; base of filenames
d142 3
d149 4
a153 1
        MOV     r3, #1
@


4.9
log
@Fix bug in sort-by-size mode for files > 2G.
A signed comparison meant the larger files appeared last and in reverse order. Fixed by using an effective 40 bit compare by ripping off the date sorting code.
Also made all the reverse sort versions use common sorting by using ALTENTRY macros for the forware sort versions.

Version 2.27. Tagged as 'Filer-2_27'
@
text
@d63 2
a64 2
        LDR     r3, [r1, #d_dirname]    ; r3 -> base address of filenames
                                        ; passed in as r12 to sort procs
d115 1
d118 1
d126 1
a126 1
reverse_sort_name Entry "r0-r3"
d128 6
a133 1
        LDR     r2, [r0, #df_fileptr]
d135 1
a135 1
        ADD     r2, r12, r2             ; r2 -> name(r0)
d137 1
a137 1
        ADD     r2, r12, r2, LSR #16    ; r2 -> name(r0)
d139 2
a140 1
        LDR     r1, [r1, #df_fileptr]
d142 1
a142 1
        ADD     r1, r12, r1             ; r1 -> name(r1)
d144 1
a144 1
        ADD     r1, r12, r1, LSR #16    ; r1 -> name(r1)
a145 1
        B       %FT10
d147 3
a149 1
sort_name ALTENTRY
a150 13
        LDR     r2, [r1, #df_fileptr]
 [ not_16bit_offsets
        ADD     r2, r12, r2             ; r2 -> name(r1)
 |
        ADD     r2, r12, r2, LSR #16    ; r2 -> name(r1)
 ]
        LDR     r1, [r0, #df_fileptr]
 [ not_16bit_offsets
        ADD     r1, r12, r1             ; r1 -> name(r0)
 |
        ADD     r1, r12, r1, LSR #16    ; r1 -> name(r0)
 ]
10
a153 1
        STRVS   r0, [sp]
@


4.8
log
@  Add the ability to sort Filer objects in reverse order
Detail:
  It's been possible to sort Filer objects using various criteria for a long
  time but sorting objects in reverse order was not possible. This change aims
  to remedy that omission.
  The option 'Reverse sort' has been added to the 'Display' submenu of the
  Filer menu, allowing the sort order of individual directory viewers to be
  changed dynamically.
  The switch -ReverseSort has been added to the command Filer_OpenDir to allow
  it to open directories with the sort order reversed.
  The switch -ReverseSort has been added to the Filer_Layout command so that
  reverse sort order can be set as default for new directory viewers. The
  Filer_Layout command is also written to the FlrSetup file in Choices:Boot.
  Tasks by the Filer configure plug-in (which has been also updated to allow
  -ReverseSort).
Admin:
  Tested on Iyonix RO5.14


Version 2.22. Tagged as 'Filer-2_22'
@
text
@d119 22
a140 1
sort_name Entry "r0-r3"
d154 1
a154 1

a162 2
; <<< if names identical, order by number (fs)

d166 2
a167 2
;   undated files
;   dated files (000..FFF)
a170 1

d200 5
d206 1
a206 1
sort_type Entry
d210 1
a210 1

d223 4
a226 6
$label  LSize   $rd, $rs, $rtemp
$label  LDRB    $rtemp, [$rs, #df_type]
        CMP     $rtemp, #dft_applic
        MOVEQ   $rd, #-1                ; Fudge files bigger> apps bigger> dirs
        MOVNE   $rd, #-2
        CMP     $rtemp, #dft_file
d228 2
a229 1
        CMPNE   $rtemp, #dft_partition
d231 5
a235 1
        LDREQ   $rd, [$rs, #df_length]
d238 1
d240 3
a242 1
sort_size Entry
d244 1
a244 33
        LSize   r2, r0, r14
        LSize   r3, r1, r14

        CMP     r3, r2                  ; descending order (largest at top)
        BLEQ    sort_name               ; sort by name if sizes equal
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; sort by date:
; -------------
;   objects (new..1900)

; NB. Getting signed CMP results was difficult

        MACRO
$label  LDate   $rd, $rs, $rtemp
$label  LDRB    $rd, [$rs, #df_load]    ; High byte of date
 [ False
        LDRB    $rtemp, [$rs, #df_type]
        CMP     $rtemp, #dft_applic
        ORREQ   $rd, $rd, #&100         ; Fudge files newer> apps newer> dirs
        CMP     $rtemp, #dft_file
        ORREQ   $rd, $rd, #&200
 ]
        MEND


sort_date Entry "r4, r5"

        LDate   r4, r0, r14             ; Get high bytes
        LDate   r5, r1, r14
        LDR     r2, [r0, #df_exec]      ; Get low words
        LDR     r3, [r1, #df_exec]
d246 3
d261 1
a261 70

;-------------------------------------------------------------------------------

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Sort procedures called in SVC mode, with r13 FD stack

; In    r0 -> first object
;       r1 -> second object

; Out   LT,GE from CMP between first and second objects
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

reverse_sort_name Entry "r0-r3"

        LDR     r2, [r0, #df_fileptr]
 [ not_16bit_offsets
        ADD     r2, r12, r2             ; r2 -> name(r0)
 |
        ADD     r2, r12, r2, LSR #16    ; r2 -> name(r0)
 ]
        LDR     r1, [r1, #df_fileptr]
 [ not_16bit_offsets
        ADD     r1, r12, r1             ; r1 -> name(r1)
 |
        ADD     r1, r12, r1, LSR #16    ; r1 -> name(r1)
 ]

        MOV     r0, #-1                 ; use configured territory
        MOV     r3, #1
        SWI     XTerritory_Collate
        STRVS   r0, [sp]
        EXIT    VS
        CMP     r0, #0                  ; set LT, GE depending on which is smaller
        EXIT

; <<< if names identical, order by number (fs)

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; sort by type:
; -------------
;   undated files
;   dated files (000..FFF)
;   applications
;   directories

reverse_sort_type Entry

        LType   r2, r0, r14
        LType   r3, r1, r14

        CMP     r3, r2
        BLEQ    reverse_sort_name       ; sort by name if types equal
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; sort by size:
; -------------
;   files (large..0)
;   applications        full size not known, so can't really order by it
;   directories         ditto

reverse_sort_size Entry

        LSize   r2, r0, r14
        LSize   r3, r1, r14

        CMP     r2, r3                  ; descending order (largest at top)
        BLEQ    reverse_sort_name       ; sort by name if sizes equal
        EXIT

d266 2
d269 5
a273 1
; NB. Getting signed CMP results was difficult
d277 10
a286 6
        LDate   r4, r0, r14             ; Get high bytes
        LDate   r5, r1, r14
        LDR     r2, [r0, #df_exec]      ; Get low words
        LDR     r3, [r1, #df_exec]

        SUBS    r14, r2, r3             ; descending order - CMP64
d288 1
a288 1
        SBCS    r2, r4, r5
d296 1
a296 1
        BLEQ    reverse_sort_name       ; NB. don't corrupt r0,r1 if going
d298 1
@


4.7
log
@  Misc bugfixes.
Detail:
  * Mered in RISCOS Ltd's fix for directory displays with more than 65536
    bytes of leafnames.
  * Tries to use Wimp_TextOp 4 to do ellipsis truncation. As a result, it
    can now cope properly with:
    + multibyte UTF-8 characters in leafnames (previously this caused
      problems even if not truncated)
    + WimpSymbol character substitution in leafnames
    + alphabets without an ellipsis character
    + fonts without an ellipsis character
  * Sprite icons in 'Copy as' and 'New directory' dialogue boxes are no
    longer filled.
Admin:
  Tested on Tungsten.

Version 2.08. Tagged as 'Filer-2_08'
@
text
@d49 5
a57 1
        ADR     r14, sortproctable
a95 1

d98 11
a108 4
        DCD     sort_name  -sortproctable ; directory viewer
        DCD     sort_type  -sortproctable
        DCD     sort_size  -sortproctable
        DCD     sort_date  -sortproctable
d133 1
d261 96
@


4.6
log
@  The following were present in RISC OS 5.00/5.01:
  * "Directory" string removed from "New directory" dialogue box template.
    Unlike the version shipped in 5.00 and 5.01, this template file doesn't
    have its "Recurse" option button in the "Access details" dialogue box
    deselected.
  * When "New directory" dialogue box is opened, contents of the writable
    icon is now set to a null string, rather than the uninternationalised
    "Directory" that was used previously.
  * Uses OS_HeapSort32 instead of OS_HeapSort when the RMA is high.
  The following are new since then:
  * Fixed rubber dragboxes to use exclusive maximum coordinates, stops you
    dragging the box off the left hand side of the window.
  * Enabled SetDirectory option. Merged in 4.02's SetDirectoryComesFirst
    option, changed token in Messages file to read "Set work directory"
    instead of "Set directory" to match 4.02, and added the missing token
    MH?7? for interactive help.

Version 2.06. Tagged as 'Filer-2_06'
@
text
@d112 3
d116 1
d118 3
d122 1
@


4.5
log
@Fixed some mrs and msr macros for ObjAsm.

Version 2.03. Tagged as 'Filer-2_03'
@
text
@a64 2
        ORR     r1, r1, #2_11 :SHL: 30  ; Ask HeapSort to build pointer array
                                        ; itself and shuffle data after sorting
d73 4
d78 4
a81 1

@


4.4
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 2.01. Tagged as 'Filer-2_01'
@
text
@d231 1
a231 1
        mrs EQ, r4, CPSR
d233 1
a233 1
        msr EQ, CPSR_f, r4
@


4.3
log
@Made 32-bit compatible. Quite a complex job, and only limited testing so far.

Version 1.97. Tagged as 'Filer-1_97'
@
text
@d24 1
a24 1
SortDir ENTRY   "r1-r11"
d104 1
a104 1
sort_name ENTRY "r0-r3"
d159 1
a159 1
sort_type ENTRY
d189 1
a189 1
sort_size ENTRY
d218 1
a218 1
sort_date ENTRY "r4, r5"
@


4.2
log
@Merged Ursula branch.
Moved to srccommit.

Version 1.96. Tagged as 'Filer-1_96'
@
text
@d81 1
a81 1
        
d136 1
a136 1
        CMP     $rtemp, #dft_file 
d228 1
d230 5
@


4.1
log
@Initial revision
@
text
@d34 11
a44 2
        CMP     r0, #256
        EXIT    GE                      ; [too many to sort! array limited]
d47 1
a47 1

d64 1
a64 1
        ADR     r1, sortingbuffer       ; r1 -> array of pointers
d76 9
@


4.1.4.1
log
@A *Filer_Layout command now replaces CMOS setting of the display options.
Fixed bug which meant dirviews weren't sorted if they had >256 entries.
Increased dirnamebuffer to 2K to cope with long pathname renames.
@
text
@d34 2
a35 4
        ; Check if there's room in sortingbuffer
        ADR     r10, sortingbuffer      ; r10 -> buffer
        CMP     r0, #sortingbuffer_entries
        BLT     %FT01
d37 1
a37 6
        ; If not, try and claim enough memory in RMA
        MOV     r3, r0, LSL #2          ; we want entries * 4 bytes
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        EXIT    VS                      ; Couldn't claim it
        MOV     r10, r2                 ; r10 -> buffer
a38 2
; work out correct sorting procedure for HeapSort, and do it!
01
d55 1
a55 1
        MOV     r1, r10                 ; r1 -> array of pointers
a66 9

        ; if we claimed any RMA for the sort, free it now
        ADR     r0, sortingbuffer
        CMP     r0, r10
        EXIT    EQ                      ; We used sortingbuffer, not RMA
        
        MOV     r0, #ModHandReason_Free
        MOV     r2, r10
        SWI     XOS_Module
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

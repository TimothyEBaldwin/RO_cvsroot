head	4.14;
access;
symbols
	Filer-2_43:4.14
	Filer-2_42:4.14
	Filer-2_41:4.14
	Filer-2_40:4.13
	Filer-2_39:4.13
	Filer-2_38:4.13
	Filer-2_37:4.13
	Filer-2_36:4.12
	Filer-2_35:4.11
	Filer-2_34:4.11
	Filer-2_33:4.11
	Filer-2_32:4.11
	Filer-2_31:4.11
	Filer-2_30:4.11
	Filer-2_29:4.11
	Filer-2_28:4.11
	Filer-2_27:4.11
	Filer-2_26:4.11
	Filer-2_25:4.10
	Filer-2_24:4.10
	Filer-2_23:4.9
	Filer-2_22:4.9
	Filer-2_21:4.9
	Filer-2_20:4.9
	Filer-2_19:4.9
	Filer-2_18:4.9
	Filer-2_17:4.8
	Filer-2_16:4.8
	Filer-2_15:4.8
	Filer-2_14:4.8
	Filer-2_13:4.8
	Filer-2_12:4.7
	Filer-2_11:4.7
	Filer-2_10:4.7
	Filer-2_09:4.6
	RO_5_07:4.5
	Filer-2_08:4.5
	Filer-2_07:4.4
	Filer-2_06:4.4
	Filer-2_05:4.4
	Filer-2_04:4.4
	Filer-2_03:4.4
	Filer-2_02:4.4
	Filer-2_01:4.4
	Filer-2_00:4.3
	Filer-1_99:4.3
	Filer-1_98:4.3
	Filer-1_97:4.3
	Ursula_merge:4.1.4.8
	Filer-1_96:4.2
	Filer-1_95:4.1.4.8
	nturton_Filer-1_85:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.8
	Ursula_RiscPC:4.1.4.8.0.2
	rthornb_UrsulaBuild-19Aug1998:4.1.4.8
	UrsulaBuild_FinalSoftload:4.1.4.8
	rthornb_UrsulaBuild-12Aug1998:4.1.4.8
	aglover_UrsulaBuild-05Aug1998:4.1.4.8
	rthornb_UrsulaBuild-29Jul1998:4.1.4.8
	rthornb_UrsulaBuild-22Jul1998:4.1.4.8
	rleggett_Filer-1_94:4.1.4.8
	rthornb_UrsulaBuild-15Jul1998:4.1.4.7
	rthornb_UrsulaBuild-07Jul1998:4.1.4.7
	rthornb_UrsulaBuild-17Jun1998:4.1.4.7
	rthornb_UrsulaBuild-03Jun1998:4.1.4.6
	rthornb_UrsulaBuild-27May1998:4.1.4.6
	rleggett_Filer-1_93:4.1.4.6
	rthornb_UrsulaBuild-21May1998:4.1.4.6
	rthornb_UrsulaBuild_01May1998:4.1.4.6
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.14
date	2015.08.01.19.30.12;	author jlee;	state Exp;
branches;
next	4.13;
commitid	wlEeHupJlGcClBvy;

4.13
date	2014.06.29.10.37.14;	author jlee;	state Exp;
branches;
next	4.12;
commitid	4jLNa6WihVxYbpGx;

4.12
date	2014.03.01.22.53.59;	author jlee;	state Exp;
branches;
next	4.11;
commitid	c84NTBTZAa5S73rx;

4.11
date	2010.10.23.18.02.28;	author rsprowson;	state Exp;
branches;
next	4.10;

4.10
date	2010.03.07.08.26.14;	author rsprowson;	state Exp;
branches;
next	4.9;

4.9
date	2009.06.15.23.38.17;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2007.09.18.16.12.45;	author srevill;	state Exp;
branches;
next	4.7;

4.7
date	2004.12.03.00.58.52;	author jballance;	state Exp;
branches;
next	4.6;

4.6
date	2004.12.02.00.40.23;	author jballance;	state Exp;
branches;
next	4.5;

4.5
date	2003.02.04.14.30.59;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2001.03.16.17.09.23;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.04.20.16.21.13;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.08.17.11.56.40;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.29;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.29;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.27.33;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.05.27.11.13.30;	author rleggett;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.05.28.08.44.07;	author rleggett;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.08.27.09.09.07;	author rleggett;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	97.09.24.13.26.42;	author rleggett;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	97.10.21.09.38.36;	author rleggett;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.04.15.11.27.47;	author rleggett;	state Exp;
branches;
next	4.1.4.7;

4.1.4.7
date	98.06.10.09.45.19;	author rleggett;	state Exp;
branches;
next	4.1.4.8;

4.1.4.8
date	98.07.22.09.51.20;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.17.01;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.16.16;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Fix null pointer dereferences in keyboard shortcut handling. Fix Ctrl-R renaming not always working.
Detail:
  s/Redraw - Introduce always_create_rename_writeable, as a variation of create_rename_writeable. This new version ignores the mouse position and positions the caret at the end of the filename.
  s/KeyPress - Fix delete shortcut handling to do nothing if nothing selected (avoids null pointer dereference in Filer_Action). Fix null pointer dereference in 'open parent' shortcut handling if parent already open. Change rename handling to use always_create_rename_writeable instead of trying to generate a fake mouse position (old code only worked for some filer view modes). Fix comments for next/prev dir shortcuts to match reality, and wrap rename code in AltRenaming switch to match the implementation in s/Redraw.
Admin:
  Tested on Pandaboard
  Fixes null pointer dereferences reported on forums:
  https://www.riscosopen.org/forum/forums/4/topics/3447


Version 2.41. Tagged as 'Filer-2_41'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
 [ AltRenaming

wr_filename_validation    DCB  "s;pptr_write;A~ .:*#$&@@^%\\|",34,0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; create_rename_writeable
; =======================
;
; Create the writeable icon (if mouse click is within text bounding box)
;
; In:  r4 -> directory block
;      r5 -> file block
;
; Out: EQ - click was claimed
;      NE - click not claimed

create_rename_writeable
        Entry   "r0-r12"

        MOV     r8, #0                          ; Zero -> use mouse pos

01
        ; Check if filesystem is read-only (eg. ROM), in which case rename not allowed.
        LDR     r2, [r4, #d_filesystem]
        TST     r2, #fod_readonly
        BNE     %FT08

        ; store dirviewer block and fileinfo block (so we know what to rename later)
        LDR     r1, renaming_chunkaddr
        ADD     r1, r1, #re_dirblock
        STR     r4, [r1]
        STR     r5, [r1, #4]

        ; Copy the filename into our indirected area
        LDR     r1, [r4, #d_filenames]
        LDR     r6, [r5, #df_fileptr]
 [ not_16bit_offsets
        ADD     r2, r1, r6                      ; r2 -> filename (null-terminated)
 |
        ADD     r2, r1, r6, LSR #16             ; r2 -> filename (null-terminated)
 ]
        LDR     r1, renaming_chunkaddr
        ADD     r1, r1, #re_textstring          ; r1 -> destination
        BL      strcpy                          ; to the string copy

        LDR     r10, renaming_chunkaddr         ; Where is the icon data for our writeable icon?
        ADD     r10, r10, #re_createiconblock

        LDR     r0, windowhandle                ; Store the window handle in the first word of the
        STR     r0, [r10]                       ; block which will be passed to Wimp_CreateIcon
        ADD     r9, r10, #4                     ; make R9 the location of the icon data

        LDRB    r5, [r4, #d_viewmode]           ; load r5 with the display mode bit
        AND     r5, r5, #db_displaymode         ; (use it later)

        ADR     r0, filebox1                    ; load the bounding box for the icon clicked on
        LDMIA   r0, {r1, r2, r3, r4}

        CMP     r5, #db_dm_largeicon            ; is this a large icon
        ADDNE   r1, r1, #40                     ; no, then decrease bounding box x
        SUB     r2, r2, #2
        MOV     r4, r2                          ; Decrease the vertical bound to take the
        ADD     r4, r4, #32                     ;     writeable icon

        Push    "r0-r3"                         ; Keep r0 - r3
        MOV     r0, #-1
        MOV     r1, #5
        SWI     XOS_ReadModeVariable             ; Read the y eigen factor
        MOVCS   r2, #1

        MOV     r0, #1
        MOV     r1, r0, LSL r2

        MOV     r0, #4
;        MUL     r7, r0, r1                      ; Adjust the size of the writeable icon according
;        ADD     r4, r4, r7                      ;     to the y eigenvalue
        MLA     r4, r0, r1, r4
        Pull    "r0-r3"                         ; Restore r0 - r3

        TEQ     r8, #0
        STRNE   r3, relmousex                   ; Pretend click was on right edge of writable
        STRNE   r4, relmousey

        LDR     r6, relmousex                   ; load mouse x relative to window origin in r6
        LDR     r7, relmousey                   ; load mouse y relative to window origin in r6
        CMP     r6, r1                          ; compare x with left hand extreme of bouding box
        BLT     %FT08                           ; if less, then ignore click
        CMP     r6, r3                          ; compare x with right hand extreme of bounding box
        BGT     %FT08
        CMP     r7, r2                          ; compare y with bottom extreme of bounding box
        BLT     %FT08
        CMP     r7, r4                          ; compare y with top extreme
        BGT     %FT08

        STMIA   r9, {r1, r2, r3, r4}            ; store bounding box in icon data

        LDR     r0, windowhandle                ; put window handle in r0, plus use bounding box in r1-r4
        SWI     XWimp_ForceRedraw                ; to do wimp redraw.

        ADD     r9,r9,#16                       ; Move on r9 to next four words

        ; Now make icon flags
        MOV     r1,#7
        MOV     r4, r1,      LSL #24            ; Foreground colour   (bits 24-27)
        MOV     r1,#0
        ADD     r4, r4, r1,  LSL #28            ; Background colour   (bits 28-31)
        MOV     r1,#15
        ADD     r4, r4, r1,  LSL #12            ; Type                (bits 12-15)

        ADD     r4, r4, #if_indirected          ; Indirected          (bit 8)
        ADD     r4, r4, #if_filled              ; Filled background   (bit 5)
        ADD     r4, r4, #if_border              ; Border              (bit 2)
        ADD     r4, r4, #if_text                ; Has text            (bit 0)

        CMP     r5, #db_dm_largeicon            ; is this a large icon?
        ADDEQ   r4, r4, #if_hcentred            ; if a large sprite, centre horizontally
        ADDEQ   r4, r4, #if_sprite              ; if a large sprite, then add an invisible sprite
        ADDNE   r4, r4, #if_vcentred            ; if NOT a large sprite, then centre vertically

        ; Now make the text buffer etc. point to our memory chunk
        LDR     r5, renaming_chunkaddr
        ADD     r5, r5, #re_textstring          ; location of text buffer
        ADR     r6, wr_filename_validation      ; location of validation string
        MOV     r7,#252                         ; length of buffer
        STMIA   r9, {r4, r5, r6, r7}            ; store flags etc.

        ; Create the writeable icon
        MOV     r0,#0
        MOV     r1,r10
        SWI     XWimp_CreateIcon

        LDR     r2, renaming_chunkaddr
        ADD     r2, r2, #re_windowhandle
        STR     r0, [r2, #4]                    ; store the handle of the writeable icon

        ; Send a claim entity message
        LDR     r1, renaming_chunkaddr
        ADD     r1, r1, #re_tempdata            ; Address of a block to put the message data
        MOV     r0, #24                         ; message size
        STR     r0, [r1]
        LDR     r0, mytaskhandle                ; my task handle
        STR     r0, [r1, #4]
        MOV     r0, #0                          ; my ref
        STR     r0, [r1, #8]
        MOV     r0, #0                          ; your ref
        STR     r0, [r1, #12]
        MOV     r0, #Message_ClaimEntity        ; message action
        STR     r0, [r1, #16]
        MOV     r0, #3                          ; bits 0 and 1 set indicating caret claim
        STR     r0, [r1, #20]

        MOV     r0, #17                         ; event code
        MOV     r2, #0                          ; 0 = broadcast message
        SWI     XWimp_SendMessage

        ; Set the caret position
        LDR     r2, renaming_chunkaddr
        LDR     r1, [r2, #re_iconhandle]        ; put icon handle in r1 for SetCaret call

        LDR     r0, windowhandle                ; put window handle in r0.
        STR     r0, [r2, #re_windowhandle]      ; store window handle

        LDR     r2, relmousex                   ; Set caret position according to mouse x and y
        LDR     r3, relmousey
        MVN     r4, #1
        MVN     r5, #1

        SWI     XWimp_SetCaretPosition

06                                              ; exit claimed click
        CMP     r0, r0
        EXIT

08                                              ; exit unclaimed click
        CMP     pc, #0
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; always_create_rename_writeable
; ==============================
;
; Like create_rename_writable, but ignores mouse pos
;
always_create_rename_writeable
        ALTENTRY
        MOV     r8, #1                          ; Non-zero -> ignore mouse pos
        B       %BT01
 ]


 [ AltRenaming
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; remove_rename_writeable
; =======================
;
; If it exists, delete the writeable icon used for renaming files
;
; In:
;
; Out: no corruption

remove_rename_writeable Entry

00
        Push    "r0-r5"
        LDR     r1, renaming_chunkaddr
        ADD     r1, r1, #re_windowhandle
        LDR     r0, [r1]
        CMP     r0, #0
        BEQ     %FT10
        SWI     XWimp_DeleteIcon
        MOV     r0,#0                       ; Update details of writeable icon to show nonexistance
        STR     r0, [r1]
        STR     r0, [r1, #4]

        ; Force a redraw
        ADD     r5, r1, #re_createwhandle   ; point to window handle
        LDMIA   r5, {r0, r1, r2, r3, r4}    ; load window handle, followed by icon bounding box
        SWI     XWimp_ForceRedraw            ; Force a redraw of that area

10
        Pull    "r0-r5"
        EXIT
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; event_redraw_window
; ===================

; In    r1 -> wimp_eventstr
;             [r1, #0]  window handle

; Out   all regs may be corrupted - going back to PollWimp

; NB. Errors generated at this level or below result in an error box with just
;  the 'Ok' button in it, which means give up redrawing window. Set a flag in
;  dirviewer to say it's dead.

event_redraw_window Entry

 [ debugredraw
 LDR r14,[r1, #r_handle]
 DREG r14,"redraw_window: window ",,Integer
 ]
        BL      read_font_widths

        SWI     XWimp_RedrawWindow      ; get wimp to redraw as much as poss.
        BVS     %FT99

        Push    "r0"                    ; save more_rectangles flag
        LDR     r0, [r1, #r_handle]
        BL      FindDir                 ; r4 -> dirviewer block
        Pull    "r0"
        BEQ     %FT02                   ; [redrawing a dirviewer]


01      CMP     r0, #0                  ; Loop doing rectangles anyway
        EXIT    EQ                      ; VClear

        ADR     r1, userdata
 [ debugredraw
 LDR r14, [r1, #u_handle]
 DREG r14, "silly call of XWimp_GetRectangle, window handle ",,Integer
 ]
        SWI     XWimp_GetRectangle
        BVC     %BT01
        B       %FT99

02
        LDRB    r14, [r4, #d_filesperrow]
 [ centralwrap
        TEQ     r14, #db_fpr_stuffed
 |
        TEQ     r14, #&ff
 ]
        BEQ     %BT01                   ; [dirviewer is stuffed, can no cope]


 ASSERT r_wax0 = 4
        LDMIB   r1, {x0, y0, x1, y1, scx, scy}
        SUB     r10, x0, #0             ; scx MUST be 0
        SUB     r11, y1, scy

        STR     r10, windowx            ; abs coords of top left of work area
        STR     r11, windowy
        BL      RedrawDirectory
        EXIT    VC

99      BL      LocalReportError

 [ centralwrap
        MOV     r14, #db_fpr_stuffed    ; dirviewer is stuffed, matey-peeps
 |
        MOV     r14, #&FF               ; dirviewer is stuffed, matey-peeps
 ]
        STRB    r14, [r4, #d_filesperrow]

        CLRV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Redraw directory viewer
;
; In     r4 -> dirviewer block
;        r0 = more_rectangles flag
;        first redraw block stored in userdata
;        [windowx], [windowy] set up
; Out    r0 -> error
;        r1-r3, r5 corrupt

RedrawDirectory ROUT
        Entry   "r6"

05      CMP     r0, #0                  ; while (more_rectangles) do ...
 [ debugredraw
 BNE %FT00
 DLINE "No more rectangles for redraw"
00
 ]
        EXIT    EQ                      ; VClear

; loop over file icons (format depends on viewmode)

 [ debugredraw
 Push "cx0-cy1"
 wsaddr r14, userdata + r_gwx0  ; current graphics window (abs)
 LDMIA  r14, {cx0, cy0, cx1, cy1}
 DREG cx0, "redraw file icons in graphics window: x0=",cc,Integer
 DREG cy0, ", y0=",cc,Integer
 DREG cx1, ", x1=",cc,Integer
 DREG cy1, ", y1=",,Integer
 Pull "cx0-cy1"
 ]
        LDR     r3, [r4, #d_nfiles]     ; r3 = no of files to do
        CMP     r3, #0
        BEQ     %FT95                   ; [nothing in this viewer]

        ADD     r5, r4, #d_headersize
        ADRL    r2, userdata + r_size
        ADR     r6, userdata + userdata_size

90
        ; Draw applications immediately, as they're likely to have unique
        ; sprites. Everything else gets queued and then sorted to avoid
        ; thrashing ColourTrans and to improve CPU cache performance.
        LDRB    r14, [r5, #df_type]
        TEQ     r14, #dft_applic
        BEQ     %FT93
        STR     r3, [r2], #4
        TEQ     r2, r6
        BNE     %FT94
        BL      SortAndDraw
        ADRL    r2, userdata + r_size
        B       %FT94
93
        BL      GetFileBox              ; get relative to work area origin
        BL      RedrawFile
        BVS     %FT99
94
        SUBS    r3, r3, #1
        ADDNE   r5, r5, #df_size
        BNE     %BT90
        ADRL    r6, userdata + r_size
        TEQ     r2, r6
        BLNE    SortAndDraw

95      ADR     r1, userdata
 [ debugredraw
 LDR r14, [r1, #u_handle]
 DREG r14, "calling XWimp_GetRectangle, window handle ",,Integer
 ]
        SWI     XWimp_GetRectangle      ; r0,r1 := more_rectangle state
        BVC     %BT05

99
        EXIT

astring DCB "r2 %d r3 %d",10,0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In     r4 -> dirviewer block
;        r2 -> end of redraw list in userdata block (nonempty!)

SortAndDraw ROUT
        Entry   "r0-r7"
        ; Heap sort the redraw block
        ADRL    r1, userdata + r_size
        SUB     r0, r2, r1
        MOV     r0, r0, LSR #2
        ADD     r3, r4, #d_headersize
        LDR     r5, [r4, #d_nfiles]
        CMP     r0, #2
        ASSERT  df_size = 7*4
        ADD     r3, r3, r5, LSL #2+3    ; *8
        SUB     r3, r3, r5, LSL #2      ; -1
        BLS     %FT25                   ; No point sorting if <=2 entries
        ADRL    r2, sort_redraw
        TST     r1, #2_111 :SHL: 29     ; use old or new SWI depending on
        BNE     %FT20                   ; address
        SWI     XOS_HeapSort
        B       %FT25
20      MOV     r7, #0
        SWI     XOS_HeapSort32
25
        ; Now draw the icons
        FRAMLDR r2
        ADRL    r1, userdata + r_size
        MOV     r6, r3
26
        LDR     r3, [r1], #4
        ASSERT  df_size = 7*4
        SUB     r5, r6, r3, LSL #2+3
        ADD     r5, r5, r3, LSL #2
        BL      GetFileBox
        BL      RedrawFile
        CMP     r1, r2
        BNE     %BT26
        EXIT         
        

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In     r4 -> dirviewer block
;        r5 -> fileinfo block
;        filebox()() set up

RedrawFile ROUT
        Entry "r1-r5, x0, y0, x1, y1"

 [ debugredraw
 DREG r4, "RedrawFile: dir ",cc
 DREG r5, ", file "
 ]

; Try drawing object icon part (sprite + text)

        ADR     r0, filebox1
        BL      checkboxcoords          ; x0, y0, x1, y1 := abs. coords of box
        BLE     RedrawInfoPart          ; [no intersection with sprite part]

; Setup name for copy into indirect buffer

        LDR     r1, [r4, #d_filenames]
        LDR     r14, [r5, #df_fileptr]
 [ not_16bit_offsets
        ADD     r0, r1, r14             ; r0 -> filename (null-terminated)
 |
        ADD     r0, r1, r14, LSR #16    ; r0 -> filename (null-terminated)
 ]
 [ debugredraw
 DSTRING r0, "leafname to copy: "
 ]
        ;wsaddr  r1, i_textbuffer
        LDR     r1, i_textbuffer_ptr

        LDRB    r14, [r4, #d_viewmode]
        AND     r14, r14, #db_displaymode
        CMP     r14, #db_dm_largeicon
        BNE     %FT50

; Large icon display

        MOV     r6, r0                   ; filename
        MOV     r7, r1                   ; icon
        LDR     r8, largeicon_truncation_mp
        BL      truncate_filename

;10      Push    "R2"
;        MOV     R2,#max_text_size
;15      LDRB    r14, [r0], #1           ; Copy name, will be centred
;        TEQ     r14, #0
;        SUBNES  r2,r2,#1
;        MOVEQ   r14, #CR
;        STRB    r14, [r1], #1
;        BNE     %BT15
;        Pull    "r2"

 [ debugredraw
 ;wsaddr r1, i_textbuffer
 LDR     r1, i_textbuffer_ptr
 DSTRING r1, "copied leafname into icon buffer "
 ]

        BL      GetBigIconName
        wsaddr  r3, dirwindow + lgi_icon_offset
        MOV     r6, #0                  ; All large icons drawn full size
        B       GoDrawIcon


; Full info or small icon display

50      MOV     r6, r0                       ; filename
        MOV     r7, r1                       ; icon
        LDR     r8, smallicon_truncation_mp  ; truncation width in millipoints
        CMP     r14, #db_dm_smallicon
        LDRNE   r8, fullinfo_truncation_mp   ; If Full Info, different width

        BL      truncate_filename

;50      MOV     r2, #0                  ; Pad to right of name with spaces
;60
;                                        ; don't pad with fancy font
;
;        LDRB    r14, [r0]
;        TEQ     r14, #0
;;        MOVEQ   r14, #space
;        ADDNE   r0, r0, #1
;;        ADD     r0, r0, #1
;        ADD     r2, r2, #1
;        CMP     r2, #max_text_size
;        MOVEQ   r14, #CR
;        STRB    r14, [r1], #1
;        BNE     %BT60

 [ debugredraw
 ;wsaddr r1, i_textbuffer
 LDR     r1, i_textbuffer_ptr
 DSTRING r1, "copied leafname into icon buffer "
 ]

        BL      GetSmallIconName
        wsaddr  r3, dirwindow + smi_icon_offset
        B       GoDrawIcon

GetSmallIconName
;In:    r4 -> dirviewer block
;       r5 -> file info block
;Out:   r2 -> icon name
;       r6 = 0 (full size) or #if_halfsize

        Push    "r3,lr"

        LDRB    r3, [r5, #df_type]      ; type
        LDMIA   r5, {r6, r7}            ; load & exec

        CMP     r3, #dft_dir            ; directories easy
 [ ShowOpenDirs
        BNE     %FT79

; Check to see if this directory is open

        LDRB    R14,[R5,#df_state]      ; get icon state
        TST     R14,#dfs_opened         ; is directory open?
        ADREQ   R2, small_dir           ; use 'small_dir'
        BEQ     %FA90
        ADR     R2, small_diro          ; use 'small_diro'
        BL      ExistsSprite
        ADRVS   R2, small_dir           ; use 'small_dir'
        B       %FA90
79
 |
        ADREQ   r2, small_dir           ; use 'small_dir'
        BEQ     %FA90
 ]
        CMP     r3, #dft_applic
        BNE     %FT80

; If 'sm!Applic' exists, use it in preference to a scaled '!Applic' sprite

        wsaddr  r1, i_spritebuffer + 4  ; temp place
        ADR     r2, sm_prefix
        MOV     r3, #' '
        BL      strcpy
        LDR     r2, [r4, #d_filenames]
        LDR     r14, [r5, #df_fileptr]
 [ not_16bit_offsets
        ADD     r2, r2, r14             ; r2 -> full !Applic
 |
        ADD     r2, r2, r14, LSR #16    ; r2 -> full !Applic
 ]
        BL      strncat10               ; clamp to sprite name limit
        MOV     r6, r2                  ; keep -> full !Applic
        MOV     r2, r1                  ; r2 -> clamped sm!Applic
        BL      ExistsSprite
        BVC     %FA90                   ; ['sm!Applic' found]

; Otherwise try a scaled '!Applic'

        wsaddr  r1, i_spritebuffer + 4  ; temp place
        MOV     r2, r6                  ; recover -> full !Applic
        MOV     r3, #12
        BL      strncpy                 ; clamp to sprite name limit
        MOV     r2, r1                  ; r2 -> clamped !Applic
        BL      ExistsSprite
        ADRVS   r2, small_app           ; ['!Applic' not found]
        BVS     %FA90

        MOV     r6, #if_halfsize        ; Half-size '!Applic'
        Pull    "r3,pc"


sm_prefix       DCB     "sm", 0
small_dir       DCB     "small_dir", 0
small_diro      DCB     "small_diro", 0
small_app       DCB     "small_app", 0
                ALIGN

; At this point, r6 = load address, r7 = exec address.

80      LDR     r2, dead_file
        CMP     r6, r2          ; Is load address = &DEADDEAD
        BNE     %FT82           ; No?
        CMP     r6, r7          ; Is exec address = &DEADDEAD
        ADREQ   r2, small_unf   ; If so, then use 'small_unf'
        BEQ     %FA90
        ;Pull    "r3,pc",EQ

82      TEQ     r6, r7
        ADREQ   r2, small_lxa           ; [load=exec; use 'small_xxx' icon]
        BEQ     %FA90

        CMN     r6, #&00100000
        ADRCC   r2, small_lxa           ; [undated; use 'small_xxx' icon]
        BCC     %FA90

; If 'small_xyz' exists, use it

                                        ; Test existence of 'small_xyz'
        MOV     r0, r6, LSL #12         ; r0 := file type, only using 16 bits
        MOV     r0, r0, LSR #20
        wsaddr  r1, i_spritebuffer + 4  ; temp place
        ADR     r2, small_prefix
        BL      strcpy_advance
        MOV     r2, #5                  ; 5 byte buffer
        SWI     XOS_ConvertHex4
        wsaddr  r2, i_spritebuffer + 4
        MOV     r14, #"_"               ; replace leading '0' with '_'
        STRB    r14, [r2, #(?small_prefix)-1]

        BL      ExistsSprite
        BVC     %FA90                   ; ['small_xyz' found]

; Otherwise try a scaled 'file_xyz'

                                        ; Test existence of 'file_xyz'
        MOV     r0, r6, LSL #12         ; r0 := file type, only using 16 bits
        MOV     r0, r0, LSR #20
        wsaddr  r1, i_spritebuffer + 4  ; temp place
        ADR     r2, file_prefix
        BL      strcpy_advance
        MOV     r2, #5                  ; 5 byte buffer
        SWI     XOS_ConvertHex4
        wsaddr  r2, i_spritebuffer + 4
        MOV     r14, #"_"               ; replace leading '0' with '_'
        STRB    r14, [r2, #(?file_prefix)-1]

        BL      ExistsSprite
        MOVVC   r6, #if_halfsize        ; Half-size 'file_xyz'
        Pull    "r3,pc",VC

        ADR     r2, small_xxx           ; ['file_xyz' not found]

90      MOV     r6, #0                  ; Full-size
        Pull    "r3,pc"


small_prefix    DCB     "small", 0
small_xxx       DCB     "small_xxx", 0
small_lxa       DCB     "small_lxa",0
small_unf       DCB     "small_unf",0
                ALIGN


GetBigIconName ROUT
;In:    r4 -> dirviewer block
;       r5 -> file info block
;Out:   r2 -> icon name

        Push    "r3,lr"

        LDRB    r3, [r5, #df_type]      ; type
        LDMIA   r5, {r6, r7}            ; load & exec

        CMP     r3, #dft_dir            ; directories easy
 [ ShowOpenDirs
        BNE     %FT09

; Check to see if this directory is open
        LDRB    R14,[R5,#df_state]      ; get icon state
        TST     R14,#dfs_opened         ; is directory open?
        ADREQ   R2, directory           ; use 'directory'
        Pull    "r3,pc",EQ
        ADR     R2, directoryo          ; use 'directoryo'
        BL      ExistsSprite
        ADRVS   R2, directory           ; use 'directory'
        Pull    "r3,pc"
09
 |
        ADREQ   r2, directory           ; use 'directory'
        Pull    "r3,pc",EQ
 ]

        CMP     r3, #dft_applic
        BNE     %FT10

        LDR     r2, [r4, #d_filenames]
        LDR     r14, [r5, #df_fileptr]
 [ not_16bit_offsets
        ADD     r2, r2, r14             ; r2 -> !Applic
 |
        ADD     r2, r2, r14, LSR #16    ; r2 -> !Applic
 ]
        Push    "r1"
        wsaddr  r1, i_spritebuffer + 4  ; temp place
        MOV     r3, #12
        BL      strncpy                 ; clamp to sprite name limit
        MOV     r2, r1                  ; r2 -> clamped !Applic
        BL      ExistsSprite
        Pull    "r1"
        ADRVS   r2, application         ; ['!Applic' not found]
        Pull    "r3,pc"

directory       DCB     "directory", 0
directoryo      DCB     "directoryo", 0
application     DCB     "application", 0
                ALIGN


10      LDR     r2, dead_file
        CMP     r6, r2
        BNE     %FT12
        TEQ     r6, r7
        ADREQ   r2, file_unf
        Pull    "r3,pc",EQ

12      TEQ     r6, r7
        ADREQ   r2, file_lxa            ; [load=exec; use 'file_xxx' icon]
        Pull    "r3,pc",EQ

        CMN     r6, #&00100000
        ADRCC   r2, file_lxa            ; [undated; use 'file_xxx' icon]
        Pull    "r3,pc",CC

                                        ; Test existence of 'file_xyz'
        MOV     r0, r6, LSL #12         ; r0 := file type, only using 16 bits
        MOV     r0, r0, LSR #20
        wsaddr  r1, i_spritebuffer + 4  ; temp place
        ADR     r2, file_prefix
        BL      strcpy_advance
        MOV     r2, #5                  ; 5 byte buffer
        SWI     XOS_ConvertHex4
        wsaddr  r2, i_spritebuffer + 4
        MOV     r14, #"_"               ; replace leading '0' with '_'
        STRB    r14, [r2, #(?file_prefix)-1]

        BL      ExistsSprite
        ADRVS   r2, file_xxx            ; ['file_xyz' not found]
        Pull    "r3,pc"


file_prefix     DCB     "file", 0
file_xxx        DCB     "file_xxx", 0
file_lxa        DCB     "file_lxa", 0
file_unf        DCB     "file_unf", 0
dead_file       DCD     &DEADDEAD
                ALIGN



; .............................................................................
; In    r2 -> sprite name
;       r3 -> icon to use
;       r6 = if_halfsize or 0

GoDrawIcon ROUT

        LDRB    r14, [r5, #df_state]
        TST     r14, #dfs_selected
        ORRNE   r6, r6, #is_inverted    ; Draw as selected

        wsaddr  r1, i_spritebuffer + 1  ; Don't overwrite 's'
        BL      strcpy

        MOV     r1, r3                  ; r1 -> icon
        ADR     r0, filebox1            ; Load relative coords
        LDMIA   r0, {r8, r9, r10, r11}
 ASSERT i_bbx0 = 0
        STMIA   r1, {r8, r9, r10, r11}  ; Stuff the icon
 [ debugredraw :LAND: True
 DREG  r8, "stuffing icon bbox: rel. x0 := ",cc,Integer
 DREG  r9, ", y0 := ",cc,Integer
 DREG r10, ", x1 := ",cc,Integer
 DREG r11, ", y1 := ",cc,Integer
 ;wsaddr r2, i_textbuffer
 LDR     r2, i_textbuffer_ptr
 DSTRING r2, ", text part is ",cc
 wsaddr r2, i_spritebuffer
 DSTRING r2, ", sprite part is "
 ]
        LDR     r2, [r1, #i_flags]
        BIC     r2, r2, #is_inverted
        BIC     r2, r2, #if_halfsize
        ORR     r2, r2, r6              ; Draw half-size or full-size

; fix template for fancy system font
        AND     r6,r2,#&218
        CMP     r6,#&218

        BICEQ   r2,r2, #&218            ; HVR bits
        ORREQ   r2,r2, #&10

        STR     r2, [r1, #i_flags]

        SWI     XWimp_PlotIcon
        BVC     RedrawInfoPart

        LDREQ   r14, =ErrorNumber_Sprite_DoesntExist ; Don't winge if no sprite
        TEQ     r14, r0
        EXIT    NE                      ; VSet still

; .............................................................................
; Try printing out full info part of object

RedrawInfoPart ROUT

; if 'full info', display extra data

        LDRB    r14, [r4, #d_viewmode]
        AND     r14, r14, #db_displaymode
        CMP     r14, #db_dm_fullinfo
        EXIT    NE                      ; [no extra info, we're done]

        ADR     r0, filebox3
        BL      checkboxcoords          ; x0, y0, x1, y1 := abs. coords of box
 [ debugbox
 BGT %FT00
 DLINE "no intersection with full info"
00
 ]
        EXIT    LE                      ; [no intersection with full info part]

 [ version >= 117
        ; Choose the colours depending on whether the item is selected or not
 [ version >= 118
        LDRB    r1, text_fgcolour
        LDRB    r2, text_bgcolour
 |
        LDRB    r0, [r5, #df_state]
        TST     r0, #dfs_selected
        LDRNEB  r1, text_bgcolour
        LDRNEB  r2, text_fgcolour
        LDREQB  r1, text_fgcolour
        LDREQB  r2, text_bgcolour
 ]

        [ {TRUE}
        ; Set foreground and background colour from r1 and r2
        MOV     r0, r1
        SWI     XWimp_SetColour
        ORRVC   r0, r2, #&80
        SWIVC   XWimp_SetColour
        ]

        [ {FALSE}
        ; Fill in the background rectangle and move the cursor
        SUBVC   r1, x1, #1
        MOVVC   r2, y0
        MOVVC   r0, #4
        SWIVC   XOS_Plot
        MOVVC   r1, x0
        ADDVC   r2, y0, #chary-1
        MOVVC   r0, #96+7
        SWIVC   XOS_Plot
        |
        MOV     r1,x0
        ADD     r2,y0,#chary-1          ; this can be zonked with below
        ]

;        LDR     r14,windowx
;        SUB     r1,r1,r14
        STR     r1,current_x0
;        LDR     r14,windowy
;        SUB     r2,r2,r14
        SUB     r2,r2,#32
        STR     r2,current_y0
 |
        LDRB    r0, text_fgcolour       ; Is this paranoia or what, we ask ???
        SWI     XWimp_SetColour
        LDRVCB  r0, text_bgcolour
        ORRVC   r0, r0, #&80
        SWIVC   XWimp_SetColour
        MOVVC   r1, x0
        ADDVC   r2, y0, #chary-1        ; -1 (chars painted on rasters 0..-n)
        MOVVC   r0, #4
 [ debugredraw
 DREG r1,"Moving to ",cc,Integer
 DREG r2,",",,Integer
 ]
        SWIVC   XOS_Plot
 ]

        EXIT    VS


        SUB     sp, sp, #256            ; Let's have a temp frame

accesslength * :LEN:"LWR/wr "

        LDR     r0, =&20202020
        MOV     r1, r0
        STMIA   sp, {r0, r1}            ; eight spaces in a buffer
 ASSERT accesslength <= 2*4

        LDRB    r0, [r5, #df_attr]      ; Access is lsb of attributes
        MOV     r1, sp
        LDRB    r14, [r5, #df_type]     ; Directories only have locked meaning
        TEQ     r14, #dft_file
      [ version < 143
        ANDNE   r0, r0, #locked_attribute      ; Show all attributes on all objects (RM)
      ]

        MOV     r2, #"L"
        TST     r0, #locked_attribute
        STRNEB  r2, [r1], #1
        TST     r0, #write_attribute
        MOV     r2, #"W"
        STRNEB  r2, [r1], #1
        MOV     r2, #"R"
        TST     r0, #read_attribute
        STRNEB  r2, [r1], #1

        TEQ     r0, #0                  ; Any attributes set at all ?
        BNE     %FT40                   ; [yes]

      [ version < 143
        LDRB    r2, [r5, #df_type]      ; If it's not a file then skip to end
        TEQ     r2, #dft_file
        BNE     %FT50
      ]

40      MOV     r2, #"/"
        STRB    r2, [r1], #1
        MOV     r2, #"w"
        TST     r0, #public_write_attribute
        STRNEB  r2, [r1], #1
        MOV     r2, #"r"
        TST     r0, #public_read_attribute
        STRNEB  r2, [r1], #1

50      MOV     r0, sp
        LDR     r1, access_length
        STR     r1, string_length
        MOV     r1, #accesslength
        ORR     r1,r1,#&10000           ; use [string_length]
        BL      myOS_WriteN
        BVS     p256exit

; Now need to diverge on object type

        LDRB    r14, [r5, #df_type]
        CMP     r14, #dft_applic        ; EQ,CS if so
        ADREQL  r1, applicstring
        TEQNE   r14, #dft_dir*4,2       ; EQ,CC if so
        ADRCC   r1, dirstring
        BEQ     printdirappinfo


sizelength * :LEN: "8192K "

        LDR     r0, [r5, #df_length]    ; Print size of file
        LDR     r1, size_length
        STR     r1, string_length
        MOV     r1, sp
        MOV     r2, #256
        SWI     XOS_ConvertFixedFileSize
        MOVVC   r1, #sizelength-2       ; Don't print ' Kbytes' part of it
        ORRVC   r1,r1, #&10000
        BLVC    myOS_WriteNjus
        LDRVCB  r0, [sp, #sizelength-1] ; Print 'K' or 'M' or ' '
        BLVC    myOS_WriteC
;        SWIVC   XOS_WriteI+space        ; And a trailing space too
        BVS     p256exit

; Print type of file

 ASSERT df_load = 0
 ASSERT df_exec = 4
        LDMIA   r5, {r1, r2}

        TEQ     r1, r2
        BEQ     undatedfile             ; [load=exec; no file type]

        CMN     r1, #&00100000
        BCC     undatedfile             ; [undated; no file type]

        MOV     r2, r1, LSR #8          ; r2 = filetype (uses bottom 12 bits)
        [ {TRUE}
        BL      getfile_type
        |
        MOV     r0, #18
        SWI     XOS_FSControl           ; read file type string
                                        ; (default &abc is given if unknown)
        ]

        LDRVC   r14, =&20202020         ; Three trailing spaces. Yuk!
 ASSERT typelength = 12
        STMVCIA sp, {r2, r3, r14}
        MOVVC   r0, sp
        LDR     R1,applic_length         ; this assumes "Application" is widest type
        STR     R1,string_length
        MOVVC   r1, #typelength
        ORR     R1,R1,#&10000
        BLVC    myOS_WriteN

rejoindirapp
        BVS     p256exit

 ASSERT df_load = 0
 ASSERT df_exec = 4
        LDMIA   r5, {r1, r2}            ; get load/exec addresses
        CMP     r1, r2                  ; unlikely to be the same. VClear
        BEQ     printloadexec           ; (trap for BBC utilities)

printdatestamp
        STR     r2, [sp, #0]            ; store low-word first
        STRB    r1, [sp, #4]
        MOV     r0, sp
        ADD     r1, sp, #8              ; r1 -> output buffer
        MOV     r2, #256 - 8            ; r2 = output buffer length
        wsaddr  r3, mydateformat
        SWI     XOS_ConvertDateAndTime

w0p256exit
        BLVC    myOS_Write0

p256exit
        ADD     sp, sp, #256
        EXIT


undatedfile                             ; Has no type
        ADR     r0, nulltypestring
        LDR     R1,applic_length         ; this assumes "Application" is widest type
        STR     R1,string_length
        BL      myOS_Write0

printloadexec
        LDRVC   r0, [r5, #df_load]
        MOVVC   r1, sp
        MOVVC   r2, #256-1              ; We'll be putting in a space ourselves
        SWIVC   XOS_ConvertHex8         ; Updates r1, r2
        MOVVC   r0, #space
        STRVCB  r0, [r1], #1
        LDRVC   r0, [r5, #df_exec]
        SWIVC   XOS_ConvertHex8
        MOVVC   r0, sp
        B       w0p256exit              ; Nothing follows exec addr


 [ version >= 118
dirstring       DCB     "Display_Directory", 0
applicstring    DCB     "Display_Application", 0
nulltypestring  DCB     "            ", 0
typelength      *       ?nulltypestring - 1
 |
dirstring       DCB     "Directory   ", 0
typelength      *       ?dirstring - 1
applicstring    DCB     "Application ", 0
nulltypestring  DCB     "            ", 0
 ]
nullsizestring  *       .-1-(typelength-sizelength)
loadexeclength  *       :LEN: "12345678 12345678"
                ALIGN

        LTORG

printdirappinfo
        LDR     r0, length_length
        STR     r0, string_length
        ADR     r0, nullsizestring
        BL      myOS_Write0
 [ version >= 118
        ADRVC   r0, messagetrans_struct
        MOVVC   r2, #0
        SWIVC   XMessageTrans_Lookup
        MOVVC   r1, r2
        BLVC    strlen
        MOVVC   r0, r1
        LDR     r1,applic_length
        STR     r1,string_length
        MOVVC   r1, r3
        ORR     r1,r1,#&10000
        BLVC    myOS_WriteN
 |
        MOVVC   r0, r1                  ; 'Directory   ' or 'Application '
        SWIVC   XOS_Write0
 ]

        B       rejoindirapp

;;=============================================================================
;; myOS_Write? routines, use the wimp icon system to print
;; Entry as standard routines and [current_x0] updated
;; originated: Neil Kelleher, Feb 25 1993
;;=============================================================================

myOS_WriteC
        CMP     R0,#256
        MOVGE   PC,lr
        Push    "lr,R0"
        Push    "R0"            ; SP is now character+'\0'
        MOV     R0,#0
        STR     R0,current_justified
        MOV     R0,SP
        BL      myOS_Write0_int
        ADD     SP,SP,#4        ; get the stack back
        LDR     R0,current_x0
        Push    "R1"
        LDR     R1,char_length
        ADD     R0,R0,R1
        Pull    "R1"
        STR     R0,current_x0  ; move along width of ("M ")
        Pull    "PC,R0"

myOS_Write0

        Push    "lr,r0-r1,r3"
        MOV     R1,#0
        STR     R1,current_justified
        BL      myOS_Write0_int
        LDR     R1,string_length
        LDR     R0,current_x0
        ADD     R1,R0,r1
        STR     R1,current_x0
        Pull    "PC,r0-r1,r3"


myOS_Write0_int

        Push    "R0-R5,lr"

        LDR     R4,current_x0
        LDR     R2,string_length

        LDR     R1,current_justified
        TEQ     R1,#0

        ADDEQ   R3,R4,R2                ; for non justified R4 to R4+len is x bbox
        MOVEQ   R2,R4

        MOVNE   R3,R4
        SUBNE   R2,R4,R2                ; for rjust R4-len to R4 is x bbox

        TEQ     R1,#0
        MOVEQ   R0,#&10000002           ; 'vertical justification'
        MOVNE   R0,#&90000002           ; right justified
        BNE     %FT01                   ; as we're right justifying, may be outside
                                        ; x0-x1, but still need to print.

        CMP     R2,x1
        Pull    "R0-R5,PC",GT

        CMP     R3,x0
        Pull    "R0-R5,PC",LT
01
        LDR     R5,current_y0

        ADDNE   R4,R4,R1
        LDR     R14,smi_height
        ADD     R5,R5,R14,LSR #1                ; so that text is aligned with small icon
        ADD     R5,R5,#smi_botgap
        LDR     R1,[sp]
        SWI     XWimp_TextOp
        Pull    "R0-R5,PC"



myOS_WriteNjus             ; right justified WriteN

        Push    "lr,R0-R2,R6-R8"
        TST     R1,#&10000
        MOVEQ   R7,R1, ASL #4
        LDRNE   R7,string_length
        EORNE   R1,R1,#&10000
        ADD     R6,R1,#4        ; yes 4, beacuse we may need space for '\0'
        STR     R7,current_justified
        BIC     R6,R6,#3
        SUB     SP,SP,R6        ; make space on stack for string
        MOV     R8,SP
oswrite_loop_j2
        LDRB    R2,[R0] ,#1
        STRB    R2,[R8], #1
        SUBS    R1,R1,#1
        BNE     oswrite_loop_j2
        MOV     R2,#0
        STRB    R2,[R8]         ; terminate string
        MOV     R0,SP
        BL      myOS_Write0_int
        LDR     R0,current_x0
        ADD     R0,R0,R7
        STR     R0,current_x0   ; update x position
        ADD     SP,SP,R6        ; get the stack back
        Pull    "PC,R0-R2,R6-R8"


myOS_WriteN
        Push    "lr,R0-R2,R6-R8"
        MOV     R7,#0
        STR     R7,current_justified
        TST     R1,#&10000
        MOVEQ   R7,R1, ASL #4
        LDRNE   R7,string_length
        EORNE   R1,R1,#&10000    ; mask off control bits
        ADD     R6,R1,#4        ; yes 4, beacuse we may need space for '\0'
        BIC     R6,R6,#3
        SUB     SP,SP,R6        ; make space on stack for string
        MOV     R8,SP
oswrite_loop
        LDRB    R2,[R0] ,#1
        STRB    R2,[R8], #1
        SUBS    R1,R1,#1
        BNE     oswrite_loop
        MOV     R2,#0
        STRB    R2,[R8]         ; terminate string
        MOV     R0,SP
        BL      myOS_Write0_int
        LDR     R0,current_x0
        ADD     R0,R0,R7
        STR     R0,current_x0   ; update x position
        ADD     SP,SP,R6        ; get the stack back
        Pull    "PC,R0-R2,R6-R8"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r0 -> block containing coords
;       windowx,y = offsets to make these absolute
;       [userdata+r_gwx0] contains absolute coords of graphics window

; Out   x0, y0, x1, y1 = coords from block having been made absolute
;       GT: block intersects graphics window
;       LE: no intersection

checkboxcoords Entry "cx0, cy0, cx1, cy1"

        LDMIA   r0, {x0, y0, x1, y1}    ; our box
 [ debugbox
 DREG x0,"rel. box coords ",cc,Integer
 DREG y0,", ",cc,Integer
 DREG x1,", ",cc,Integer
 DREG y1,", ",,Integer
 ]

        LDR     r14, windowx            ; make absolute
        ADD     x0, x0, r14
        ADD     x1, x1, r14
        LDR     r14, windowy
        ADD     y0, y0, r14
        ADD     y1, y1, r14
 [ debugbox
 DREG x0, "checkboxcoords: absolute x0 := ",cc,Integer
 DREG y0, ", y0 := ",cc,Integer
 DREG x1, ", x1 := ",cc,Integer
 DREG y1, ", y1 := ",,Integer
 ]

        wsaddr  r14, userdata + r_gwx0  ; current graphics window (abs)
        LDMIA   r14, {cx0, cy0, cx1, cy1}
 [ debugbox
 DREG cx0, "checkboxcoords: graphics window x0 = ",cc,Integer
 DREG cy0, ", y0 = ",cc,Integer
 DREG cx1, ", x1 = ",cc,Integer
 DREG cy1, ", y1 = ",,Integer
 ]

        CMP     cx1, x0
        CMPGT   x1, cx0
        CMPGT   cy1, y0
        CMPGT   y1, cy0
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; A file has had its info changed, so ask for it to be redrawm

; In    r4 -> dirviewer block
;       r5 -> fileinfo block

; Out   filebox()() corrupt

UpdateFile ROUT
        Entry "r1-r5"


        BL      GetFileBox

        LDR     r0, [r4, #d_handle]
 [ version >= 117
        LDRB    r14, [r4, #d_viewmode]
        AND     r14, r14, #db_displaymode
        TEQ     r14, #db_dm_fullinfo
 ]
        ADR     r14, filebox1
        LDMIA   r14, {r2-r5}
 [ version >= 117
        BNE     %FT01
        Push    "r0"
        MOV     r0,#4
        SWI     XWimp_ReadSysInfo
        MOVVSS  r0,#0
        TEQ     r0,#0
        Pull    "r0"
        LDREQ   r4, filebox3 + fb_x1
01
 ]
        ADR     r1, userdata
        STMIA   r1, {r0, r2-r5}
 [ debugredraw
 DREG r0, "UpdateWindow: window ",cc,Integer
 DREG r2, ", x0 = ",cc,Integer
 DREG r3, ", y0 = ",cc,Integer
 DREG r4, ", x1 = ",cc,Integer
 DREG r5, ", y1 = ",,Integer
 ]

        [ {TRUE}
; redraw whole window if doing a lot of selections
        MOV     R14,R1
        LDR     R2,redraw_all
        TEQ     R2,#0
        BEQ     dont_redraw_all
        TEQ     R2,#1
        MOVEQ   R0,#0
        BEQ     done_redrawing
        MOV     R1,#0
        MOV     R4,#0
        MOV     R3,#&FFFFFF
        MVN     R2,#&FFFFFF
         [ {FALSE}
          SWI     XWimp_ForceRedraw
          MOVVC   R0,#0                   ; no rectangles yet
          B       done_redrawing
         |
          STMIA   R14,{R0-R4}
          MOV     R1,R14
         ]
dont_redraw_all
        SWI     XWimp_UpdateWindow
done_redrawing
        |
        SWI     XWimp_UpdateWindow      ; r0 := more_rectangles flag
        ]
        EXIT    VS

        LDR     r4, [sp, #4*3]          ; r4in

        LDRB    r14, [r4, #d_filesperrow]
 [ centralwrap
        TEQ     r14, #db_fpr_stuffed
 |
        TEQ     r14, #&FF
 ]
        BEQ     %FT80                   ; [dirviewer is stuffed, can no cope]


        LDR     r2, [r1, #u_wax0]       ; set up window x,y coords
 [ False ; scx MUST be 0
        LDR     r3, [r1, #u_scx]
        SUB     r2, r2, r3
 ]
        STR     r2, windowx

        LDR     r2, [r1, #u_way1]
        LDR     r3, [r1, #u_scy]
        SUB     r2, r2, r3
        STR     r2, windowy

        BL      RedrawDirectory
        EXIT    VC

99      BL      LocalReportError

 [ centralwrap
        MOV     r14, #db_fpr_stuffed    ; dirviewer is stuffed, matey-peeps
 |
        MOV     r14, #&FF               ; dirviewer is stuffed, matey-peeps
 ]
        STRB    r14, [r4, #d_filesperrow]



80      CMP     r0, #0                  ; Loop doing rectangles anyway
        EXIT    EQ                      ; VClear

        ADR     r1, userdata
        SWI     XWimp_GetRectangle
        BVC     %BT80

        BL      LocalReportError
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Compute the parent box size for items in the current viewing mode of a given
; dirviewer; this is used to divide up the window into a rectangular mesh.
; Hopefully this will be bigger than the combined bbox of all individual items.

; In    r4 -> dirviewer block

; Out   r11 = x size of item (same for all items in the same viewing mode)
;       r14 = y size

iconbar_height  *       140
title_height    *       40
vscroll_width   *       40

dvr_topgap      * 8
dvr_botgap      * 8
dvr_rhsgap      * 16
dvr_rhsslack    * 32

bbox_x_enlarge  * 4
bbox_y_enlarge  * 4

lgi_lhsgap      * 8
lgi_rhsgap      * 8
lgi_botgap      * 8
lgi_topgap      * 8

smi_lhsgap      * 8
smi_rhsgap      * 8
smi_botgap      * 4
smi_topgap      * 4

fui_lhsgap      * 8
fui_midgap1     * charx
fui_moreinfo    * charx*(accesslength + sizelength + typelength)
fui_midgap2     * charx
fui_rhsgap      * 8
fui_botgap      * 4
fui_topgap      * 4


GetItemBoxSize Entry

        LDRB    r14, [r4, #d_viewmode]  ; what view mode are we in?
        AND     r14, r14, #db_displaymode
        CMP     r14, #db_dm_largeicon
        BEQ     %FT10
        CMP     r14, #db_dm_smallicon
        BEQ     %FT20

; 'Full info' display

        BL      GetSmiWidth_r11
        LDR     r14, date_length        ; maximum length of date string
        ADD     r11, r11, r14           ; Only dynamic bit in pbox calc'n
        LDR     r14, size_length
        ADD     r11,r11,r14
        LDR     r14, applic_length
        ADD     r11,r11,r14
        LDR     r14,access_length
        ADD     r11,r11,r14
        LDR     r14,char_length
        ADD     r11,r11,r14             ; for good measure!!!

        ADD     r11, r11, #fui_lhsgap + fui_midgap1  + fui_midgap2 + fui_rhsgap

        LDR     r14, smi_height
        ADD     r14, r14, #fui_botgap + fui_topgap
        B       %FT30


; 'Large icon' display

10      BL      GetLgiWidth_r11
        ADD     r11, r11, #lgi_lhsgap + lgi_rhsgap
        LDR     r14, lgi_height
        ADD     r14, r14, #lgi_botgap + lgi_topgap
        B       %FT30


; 'Small icon' display

20
        BL      GetSmiWidth_r11
        ADD     r11, r11, #smi_lhsgap + smi_rhsgap
        LDR     r14, smi_height
        ADD     r14, r14, #smi_botgap + smi_topgap

30
 [ debugbox
 DREG r11, "Box size: x ",cc,Integer
 DREG r14, ", y ",,Integer
 ]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r4 -> dirviewer block
;       r5 -> fileinfo block
;       r3 = file number (descending)

; Out   filebox1() = relative coords (x0,y0, x1,y1) of icon part of object
;       filebox3() = relative coords (x0,y0, x1,y1) of info part of object

; NB. Do NOT call this with an empty dirviewer!

GetFileBox Entry "r1-r11"

        LDR     r10, [r4, #d_nfiles]
        SUB     r10, r10, r3            ; r10 := index of file (0..n-1)
 [ debugbox :LAND: False
 DREG r10, "GetFileBox: index ",cc
 ]

        LDRB    r1, [r4, #d_filesperrow]
 [ True
  [ centralwrap
  CMP r1, #db_fpr_invalid ; Neil can sometimes call us in silly states
  CMPNE r1, #db_fpr_stuffed
  |
  CMP r1, #0 ; Neil can sometimes call us in silly states
  CMPNE r1, #&FF
  ]
 MOVEQ r1, #1
 ]
        DivRem  y0, r10, r1, r14        ; y0 := row number, r10 := column no.
 [ debugbox :LAND: False
 DREG y0, ", row ",cc
 DREG r10, ", col "
 ]

        Push    "r0"
        MOV     r0,#4
        SWI     XWimp_ReadSysInfo
        MOVVS   r0,#0
        TEQ     r0,#0
        BEQ     %FT01
        LDR     r0, [r4, #d_nfiles]
        CMP     r0,r1
        SUBGE   r10,r1,r10
        SUBGE   r10,r10,#1
        SUBLT   r10,r0,r10
        SUBLT   r10,r10,#1
01
        Pull    "r0"

        BL      GetItemBoxSize          ; r11,r14 := (x, y) size of pbox
        MUL     x0, r10, r11            ; x := col * x_per_col
        ADD     x1, x0, r11             ; x0, x1 := left/right of pbox

        MUL     y1, y0, r14             ; y := row * y_per_row
        RSB     y1, y1, #0              ; y0, y1 := bottom/top of pbox
        SUB     y1, y1, #dvr_topgap     ; Small gap at top of dirviewer
        SUB     y0, y1, r14             ; coords now relative to top left of
                                        ; the dir viewer (x +ve, y -ve)
 [ debugbox
 DREG x0,"pbox: x0 = ",cc,Integer
 DREG y0,", y0 = ",cc,Integer
 DREG x1,", x1 = ",cc,Integer
 DREG y1,", y1 = ",,Integer
 ]

                                        ; Keep pbox (parent box) relative

; Calculate icon/name boxes (depends on viewmode)

; In    x0, y0, x1, y1 = pbox (relative coords)
; Out   filebox()() set up

        LDRB    r14, [r4, #d_viewmode]
        AND     r14, r14, #db_displaymode
        CMP     r14, #db_dm_largeicon
        BEQ     %FT10
        CMP     r14, #db_dm_smallicon
        BEQ     %FT20

; 'full info' display

        ADD     cy0,  y0, #fui_botgap
        LDR     r14, smi_height
        ADD     cy1, cy0, r14

; icon bbox, same cy0,cy1

        ADD     cx0,  x0, #fui_lhsgap
        BL      GetSmiWidth
        ADD     cx1, cx0, r14

        Push    "r0"
        MOV     r0,#4
        SWI     XWimp_ReadSysInfo
        MOVVS   r0,#0
        TEQ     r0,#0
        SUBNE   cx1,x1, #fui_rhsgap   ; Variable bit, come in from rhs
        SUBNE   cx0,cx1,r14
        Pull    "r0"

        ADR     r14, filebox1           ; Must stuff here as next bit needs cx1
        STMIA   r14, {cx0, cy0, cx1, cy1}

; info bbox, same cy0,cy1

        SUBNE   cx1, cx0, #fui_midgap1
        ADDNE   cx0,  x0, #fui_lhsgap

        ADDEQ   cx0, cx1, #fui_midgap1
        SUBEQ   cx1,  x1, #fui_rhsgap   ; Variable bit, come in from rhs

        ADR     r14, filebox3
        B       %FT95


10 ; 'large icon' display - icon bbox only

        ADD     cy0,  y0, #lgi_botgap
        LDR     r14, lgi_height
        ADD     cy1, cy0, r14

        ADD     cx0,  x0, #lgi_lhsgap
        BL      GetLgiWidth
        B       %FT90


20 ; 'small icon' display - icon bbox only

        ADD     cy0,  y0, #smi_botgap
        LDR     r14, smi_height
        ADD     cy1, cy0, r14

        ADD     cx0,  x0, #smi_lhsgap
        BL      GetSmiWidth


90      ADD     cx1, cx0, r14
        ADR     r14, filebox1


95      STMIA   r14, {cx0, cy0, cx1, cy1}
        CLRV
        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In    r2 = file type
;       r0 -> leafname
;       r3 -> fileblock
; Out   r2 -> sprite name

FiletypeToSpritename Entry "r0,r1"

        ; Is it a dir
        TEQ     r2, #filetype_directory
        ADREQL  r2, directory
        EXIT    EQ

        ; Is it undated
        TEQ     r2, #filetype_undated

    [ {TRUE}
        BNE     %FT04
        LDR     r1, dead_file
        LDR     r0, [r3, #df_exec]
        CMP     r0, r1
        LDREQ   r0, [r3, #df_load]
        CMP     r0, r1
        ADRL    r2, file_lxa
        ADREQL  r2, file_unf
        ADRNEL  r2, file_lxa
        EXIT
04
    |
        ADREQL  r2, file_xxx
        EXIT    EQ
    ]

        ; Is it not application
        TEQ     r2, #filetype_application
        BNE     %FT05

        ; Is application
        MOV     r2, r0
        BL      ExistsSprite
        ADRVSL  r2, application
        CLRV
        EXIT

05
        ; Object is a dated file
        ; Construct file_nnn and check it exists.
        MOV     r0, r2
        wsaddr  r1, i_spritebuffer + 4
        ADRL    r2, file_prefix
        BL      strcpy_advance
        MOV     r2, #5
        SWI     XOS_ConvertHex4
        wsaddr  r2, i_spritebuffer + 4
        MOV     r14, #"_"
        STRB    r14, [r2, #(?file_prefix) - 1]
        BL      ExistsSprite
        ADRVSL  r2, file_xxx
        CLRV
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Out   regs preserved, all unsure dirs recached/deleted as necessary.

RedrawIfModified

; This shouldn't happen unless it needs to

        Entry   "r0, r1, r4"
 [ debugrecache
 DLINE  "RedrawBecauseModified"
 ]

00      ADR     r1, ViewerList - d_link ; Always start at beginning of list
                                        ; each time

01      LDR     r4, [r1, #d_link]
        CMP     r4, #Nowt               ; VClear
        BEQ     %FT90

        LDRB    r14, [r4, #d_unsure]    ; Dirty ?
        TEQ     r14, #0
        MOVEQ   r1, r4
        BEQ     %BT01

 [ debugrecache
 DREG r4, "Found dirty dir "
 ]
                                        ; r1 -> dirty dirviewer block^
        BL      RecacheDir              ; r4 -> dirty dirviewer block
        BVC     %BT00                   ; back to start, list will have changed

; Maybe it's gone away. Whatever the situation, kill the window

        STR     r0, [sp]
        LDR     r0, [r4, #d_handle]     ; Must destroy failed dirviewers
        BL      DeleteDir               ; Ignore any errors caused by this

        LDR     r0, [sp]                ; Check error number
        LDR     r0, [r0]
        BICS    r14, r0, #&FF           ; Is it 'not found' from FileSwitch ?
        MOVNE   r14, r0, LSR #16
        TEQNE   r14, #&0001             ; Is it 'not found' from filesystem ?
        BNE     %FA89
        AND     r14, r0, #&FF
        TEQ     r14, #ErrorNumber_FileNotFound
        BEQ     %BT00                   ; Its a 'File not found' - check the other viewers

89      SETV                            ; Raise unexpected error to caller
        EXIT


90      ; Everything is recached (hopefully)
 [ debugrecache
 DLINE "All dirty windows cleaned"
 ]
        EXIT


;; FindSmiWidth         finds column size for a dirviewer
;; Entry R0 is dirviewer block
;; Exit R0 is column size

FindSmiWidth
        Push    "R1-R5,lr"
        Push    "r0"
        LDR     R1,smi_width
        [ debug
        DREG    R1,"default smi width: ",,Integer
        ]
        Push    "R1"
        LDR     R3,[R0,#d_nfiles]
        ; must be non-zero
        CMP     R3,#0
        BEQ     %FT15
        ADD     R2,R0,#d_headersize
        LDR     R5,[R0,#d_filenames]
10
        MOV     R0,#1                  ; get text width/max size reason
        LDR     R4,[R2,#df_fileptr]
        Push    "R2"
 [ not_16bit_offsets
        ADD     R1,R5,R4
 |
        ADD     R1,R5,R4, LSR #16
 ]
        MOV     R2,#max_text_size-1
        SWI     XWimp_TextOp
        Pull    "R2"
        ADD     R0,R0,#6+34+8           ; gap between sprite and text
                                        ; plus sprite width+margin for error!
        LDR     R4,[sp]                 ; smi width
        CMP     R0,R4
        STRGT   R0,[sp]
        SUBS    R3,R3,#1
        ADDNE   R2,R2,#df_size
        BNE     %bt10
15
        Pull    "R0"                    ; max width of icon

        Pull    "r2"
        LDRB    r1, [r2, #d_viewmode]
        AND     r1, r1,#db_displaymode
        CMP     r1, #db_dm_smallicon      ; if small icon display, truncate.
        LDRNE   r1, fullinfo_truncation   ; full info
        LDREQ   r1, smallicon_truncation  ; small icon
        ADD     r1, r1, #34+12
        CMP     r1, r0
        MOVLT   r0, r1

16

        Pull    "R1-R5,PC"


GetSmiWidth
        Push    "lr"
        LDR     r14,[r4,#d_smiwidth]
        CMP     r14,#0
        BNE     %FT33
        Push    "R0"
        MOV     R0,r4
        BL      FindSmiWidth
        STR     R0,[r4,#d_smiwidth]
        [ debug
        DREG    R0,"invalid smi width, new width= ",,Integer
        ]
        MOV     r14,R0
        Pull    "R0"
33
        Pull    "PC"

GetSmiWidth_r11
        Push    "lr"
        LDR     r11,[r4,#d_smiwidth]
        CMP     r11,#0
        BNE     %FT33
        Push    "R0"
        MOV     R0,r4
        BL      FindSmiWidth
        STR     R0,[r4,#d_smiwidth]
        [ debug
        DREG    R0,"invalid smi width, new width= ",,Integer
        ]
        MOV     r11,R0
        Pull    "R0"
33
        Pull    "PC"



;; FindLgiWidth         finds column size for a dirviewer
;; Entry R0 is dirviewer block
;; Exit R0 is column size

FindLgiWidth
        Push    "R1-R5,lr"
        LDR     R1,lgi_width
        [ debug
        DREG    R1,"default lgi width: ",,Integer
        ]
        Push    "R1"
        LDR     R3,[R0,#d_nfiles]
        ; must be non-zero
        CMP     R3,#0
        BEQ     %FT15
        ADD     R2,R0,#d_headersize
        LDR     R5,[R0,#d_filenames]
10
        MOV     R0,#1                   ; get text width reason
        LDR     R4,[R2,#df_fileptr]
 [ not_16bit_offsets
        ADD     R1,R5,R4
 |
        ADD     R1,R5,R4, LSR #16
 ]
        Push    "R2"
        MOV     R2,#0
        SWI     XWimp_TextOp
        Pull    "R2"
        
        ADD     R0,R0,#8                ; add error margin for oblique text - Colin Granville 18-Sep-2007
        LDR     R4,[sp]                 ; lgi width
        CMP     R0,R4
        STRGT   R0,[sp]
        SUBS    R3,R3,#1
        ADDNE   R2,R2,#df_size
        BNE     %bt10
15
        Pull    "R0"                    ; max width of icon
        LDR     r1, largeicon_truncation
        CMP     r1, r0
        MOVLT   r0, r1

        Pull    "R1-R5,PC"

GetLgiWidth
        Push    "lr"
        LDR     r14,[r4,#d_lgiwidth]
        CMP     r14,#0
        BNE     %FT33
        Push    "R0"
        MOV     R0,r4
        BL      FindLgiWidth
        STR     R0,[r4,#d_lgiwidth]
        [ debug
        DREG    R0,"invalid lgi width, new width= ",,Integer
        ]
        MOV     r14,R0
        Pull    "R0"
33
        Pull    "PC"

GetLgiWidth_r11
        Push    "lr"
        LDR     r11,[r4,#d_lgiwidth]
        CMP     r11,#0
        BNE     %FT33
        Push    "R0"
        MOV     R0,r4
        BL      FindLgiWidth
        STR     R0,[r4,#d_lgiwidth]
        [ debug
        DREG    R0,"invalid lgi width, new width= ",,Integer
        ]
        MOV     r11,R0
        Pull    "R0"
33
        Pull    "PC"

        [ {TRUE}
; uses a cache to maintain filetypes
; In R2 is filetype (bits 0-11), out R2,R3 is type string, R0 corrupted

getfile_type
        Push    "R8,lr"
        MOV     R8,R2
        LDR     R14,filetype_cache
        TEQ     R14,#0
        BNE     %FT05
        MOV     R0,#ModHandReason_Claim
        MOV     R3,#64                          ; first level look up is 16 words
        SWI     XOS_Module
        STRVC   R2,filetype_cache
        MOVVC   R14,R2
        BVS     getfile_type_error
        ADD     R0,R2,R3
        MOV     R3,#0
03
        STR     R3,[R0,#-4]!                    ; clear the area
        TEQ     R0,R2
        BNE     %BT03
05
        MOV     R2,R8, LSL #20                  ; make sure top bits clear
        ADD     R14,R14,R2, LSR #26
        BIC     R14,R14,#3
        LDR     R3,[R14]                        ; first level lookup
        TEQ     R3,#0
        BNE     %FT10
        Push    "R2,R14"
        MOV     R0,#ModHandReason_Claim
        MOV     R3,#64
        SWI     XOS_Module
        Pull    "R2,R14",VS
        BVS     getfile_type_error

        ADD     R0,R2,R3
        MOV     R3,#0
08
        STR     R3,[R0,#-4]!                    ; clear the area
        TEQ     R0,R2
        BNE     %BT08

        MOV     R3,R2
        Pull    "R2,R14"

        STR     R3,[R14]
10
        AND     R2,R2,#&0ff00000                ; don't need those bits anymore
        ADD     R14,R3,R2, LSR #22
        BIC     R14,R14,#3
        LDR     R3,[R14]
        TEQ     R3,#0
        BNE     %FT15

        Push    "R2,R14"
        MOV     R0,#ModHandReason_Claim
        MOV     R3,#128                         ; 16 filetypes 8 bytes each
        SWI     XOS_Module
        Pull    "R2,R14",VS
        BVS     getfile_type_error

        ADD     R0,R2,R3
        MOV     R3,#0
13
        STR     R3,[R0,#-4]!                    ; clear the area
        TEQ     R0,R2
        BNE     %BT13

        MOV     R3,R2
        Pull    "R2,R14"

        STR     R3,[R14]
15
        AND     R2,R2,#&00f00000
        LDR     R2,[R3,R2, LSR #17]!
        TEQ     R2,#0                           ; already there
        LDRNE   R3,[R3,#4]
        Pull    "R8,PC",NE
        MOV     R2,R8
        MOV     R8,R3
        MOV     R0,#18
        SWI     XOS_FSControl
        STMVCIA R8,{R2,R3}
        Pull    "R8,PC"

getfile_type_error
        CLRV
        MOV     R0,#18
        MOV     R2,R8
        SWI     XOS_FSControl

        Pull    "R8,PC"

invalidate_filetypes
        Push    "lr"
        LDR     R14,filetype_cache
        TEQ     R14,#0
        Pull    "PC",EQ
        Push    "R0-R5"
        ADD     R0,R14 ,#64
outer_loop
        LDR     R1,[R0,#-4]!
        TEQ     R1,#0
        TEQEQ   R0,R14
        Pull    "R0-R5,PC",EQ
        TEQ     R1,#0
        BEQ     outer_loop
        ADD     R2,R1,#64
inner_loop
        LDR     R3,[R2,#-4]!
        TEQ     R3,#0
        TEQEQ   R1,R2
        TEQEQ   R0,R14
        Pull    "R0-R5,PC",EQ
        TEQ     R1,R2
        TEQEQ   R3,#0
        BEQ     outer_loop
        TEQ     R3,#0
        BEQ     inner_loop
        ADD     R4,R3,#128
        MOV     R5,#0
splat_loop
        STR     R5,[R4,#-8]!
        TEQ     R4,R3
        BNE     splat_loop
        TEQ     R1,R2
        TEQEQ   R0,R14
        Pull    "R0-R5,PC",EQ
        TEQ     R1,R2
        BNE     inner_loop
        B       outer_loop

        ]


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; truncate_filename
;
; Take a filename in and output the truncated version (including ellipsis).
;
; In:   r6 -> filename
;       r7 -> icon buffer
;       r8 =  maximum width, in millipoints
;
; Out:  r10, r11 corrupted
;       All other regs preserved.

truncate_filename Entry "r0-r5"

        MOV     r1, r8
        MOV     r2, #0
        SWI     XFont_ConverttoOS
        MOV     r4, r1
        MOV     r3, #i_textbuffer_size
        MOV     r2, r7
        MOV     r1, r6
        MOV     r0, #4
        SWI     XWimp_TextOp
        EXIT    VC

        ; Drop back to our own (broken) code if this fails...

        ; Set font to desktop font
        MOV     r0, #8
        SWI     XWimp_ReadSysInfo
        CMP     r0, #0            ; If system font, skip to different routine
        BEQ     %FT30
        SWI     XFont_SetFont

        ; Where would we need to split the string to fit the maximum width?
        MOV     r1, r6
        MOV     r2, r8
        MOV     r3, r8
        MOV     r4, #-1
        MOV     r5, #256
        SWI     XFont_StringWidth
        MOV     r10, r4

        ; Now find the length of the filename string
        MOV     r1, r6
        BL      strlen
        MOV     r11, r3

        ; If the string is split before end of length, then find the new split size, taking
        ; into account the ellipsis character which we will add.
        CMP     r11, r10
        BLE     %FT20
        MOV     r1, r6
        LDR     r3, ellipsis_width
        SUB     r2, r8, r3
        MOV     r3, r8
        MOV     r4, #-1
        MOV     r5, #256
        SWI     XFont_StringWidth
        MOV     r10, r4

20      ; Copy string (upto split character) to icon buffer
        MOV     r0, r7
        MOV     r1, r6
        MOV     r2, r10
24
        LDRB    r14, [r1], #1
        STRB    r14, [r0], #1
        SUBS    r2, r2, #1
        BNE     %BT24

        ; If necessary, add ellipsis character
        CMP     r11, r10
        MOVGT   r14, #140
        STRGTB  r14, [r0], #1
        MOV     r14, #CR
        STRB    r14, [r0], #1

        EXIT

30 ; Deal with system font

        ; Covert millipoints back to OS units
        ; Shift right 5 to divide by 32 and find number of characters
        ; If less than string width, subtract 1 and add ellipsis.
        MOV     r1, r8
        MOV     r2, #0
        SWI     XFont_ConverttoOS    ; this returns max width in OS units
        MOV     r0, r1, LSR #4       ; divide max width by 16 to get number of chars

        MOV     r1, r6
        BL      strlen
        MOV     r11, r3              ; r11 = length of string
        MOV     r10, r3              ; r10 = how many characters we'll display (try for whole length)
        CMP     r10, r0              ; see if whole length will fit
        SUBGT   r10, r0, #1          ; if not, put max characters-1 (we'll ad an ellipsis)

        ; Copy string (upto split character) to icon buffer
        MOV     r0, r7
        MOV     r1, r6
        MOV     r2, r10
34
        LDRB    r14, [r1], #1
        STRB    r14, [r0], #1
        SUB     r2, r2, #1
        CMP     r2, #0
        BGT     %BT34

        ; If necessary, add ellipsis character
        CMP     r11, r10
        MOVGT   r14, #140
        STRGTB  r14, [r0], #1
        MOV     r14, #CR
        STRB    r14, [r0], #1

        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; read_font_widths
;
; Read some widths needed by the truncation code

ellipsis_str DCB "",0

read_font_widths Entry "r0-r6"

        ; Set font to desktop font
        MOV     r0, #8
        SWI     XWimp_ReadSysInfo
        CMP     r0, #0
        SWINE   XFont_SetFont

        ; What's the width of an ellipsis in the current font?
        ADR     r1, ellipsis_str
        MOV     r2, #71680
        ADD     r2, r2, #320
        MOV     r3, r2
        MOV     r4, #-1
        MOV     r5, #1
        SWI     XFont_StringWidth
        STR     r2, ellipsis_width

        ; What's the large icon maximum width allowed, in millipoints?
        LDR     r1, largeicon_truncation
        MOV     r2, #0
        SWI     XFont_Converttopoints
        STR     r1, largeicon_truncation_mp

        ; What's the small icon maximum width allowed, in millipoints?
        LDR     r1, smallicon_truncation
        MOV     r2, #0
        SWI     XFont_Converttopoints
        STR     r1, smallicon_truncation_mp

        ; What's the full info maximum width allowed, in millipoints?
        LDR     r1, fullinfo_truncation
        MOV     r2, #0
        SWI     XFont_Converttopoints
        STR     r1, fullinfo_truncation_mp

        EXIT

        END
@


4.13
log
@Fix incorrect d_filesperrow calculation when directory path name is wider than the screen
Detail:
  s/Open - When widening the viewer width so that the full directory name is visible, clamp the value to the screen width before calculating d_filesperrow. Without this fix the window width will get clamped to the screen width (by the Wimp?), but d_filesperrow will reflect the pre-clamp value, potentially causing one or more columns of files to be placed outside the window bounds until the window is next resized.
  s/Errors, s/GoFiler, s/Redraw - Swap some ADRs for ADRL and fix a typo that prevented the module from building when debugging was enabled
Admin:
  Tested on BB-xM with some long path names and 640x480 screen


Version 2.37. Tagged as 'Filer-2_37'
@
text
@d18 1
d30 2
a31 1
; Out: r0 - set if click was claimed, else 0
d33 2
a34 1
create_rename_writeable Entry
d36 1
a36 1
        Push "r0-r12"
d38 1
d96 4
a186 1
        Pull    "r0-r12"
d190 1
a190 2
08
        Pull    "r0-r12"                        ; exit unclaimed click
d193 12
@


4.12
log
@Redraw items in a more optimal order
Detail:
  This change moves some identical code out of event_redraw_window and UpdateFile, to create the RedrawDirectory routine.
  This new routine improves on the original code by using the spare part of the userdata block to build a list of all files which need redrawing, and then sorting the list by filetype & state in order to try and make sure all files which have the same sprites are drawn in one go. This helps avoid thrashing the translation table generation code in the Wimp/ColourTrans, and helps improve CPU cache performance.
  File changes:
  s/Redraw - Cut up event_redraw_window and  UpdateFile to create the new RedrawDirectory routine and SortAndDraw subroutine.
  s/SortDir - Add sort_redraw function which is used to sort the files into their redraw order. However it takes different arguments to the other sort routines and so is only of use to SortAndDraw.
Admin:
  Tested on Iyonix, BB-xM, StrongARM RiscPC


Version 2.36. Tagged as 'Filer-2_36'
@
text
@d789 1
a789 1
 wsaddr r2, i_spritebufer
@


4.11
log
@Fix for 'set type' writeable icon being out of step with the disc.
Adjust clicking would recreate the menu immediately after the operation but before the next wimp poll when the directory gets recached, so the first entry in the cache is manually fixed up so the recreated menu is right (the files all get refreshed later anyway).
Collapsed switch 'Fix003', after 21 years of testing it's safe to assume it's good.
Reinstated ExtractCMOSOptions conditional on not OptionsAreInRAM so that combination still assembles.
Optimise MUL/ADD into MLA where possible, and set 'S' flag on ALU operations when followed by TEQ#0.
Tested with & without filer action running, fixes ticket 254.

Version 2.26. Tagged as 'Filer-2_26'
@
text
@a269 6

; Redraw directory viewer

; In     r4 -> dirviewer block
;        r0 = more_rectangles flag

d287 2
d290 25
d341 2
d344 15
a358 1
90      BL      GetFileBox              ; get relative to work area origin
d361 1
d365 3
d377 2
d380 2
a381 1
99      BL      LocalReportError
d383 3
a385 6
 [ centralwrap
        MOV     r14, #db_fpr_stuffed    ; dirviewer is stuffed, matey-peeps
 |
        MOV     r14, #&FF               ; dirviewer is stuffed, matey-peeps
 ]
        STRB    r14, [r4, #d_filesperrow]
d387 36
a422 4
        CLRV
        EXIT

astring DCB "r2 %d r3 %d",10,0
d429 2
a430 1
RedrawFile Entry "r1-r5, x0, y0, x1, y1"
d666 1
a666 1
GetBigIconName
d1281 2
a1282 1
UpdateFile Entry "r1-r5"
d1368 2
a1369 42

05      CMP     r0, #0                  ; Loop doing rectangles
 [ debugredraw
 BNE %FT00
 DLINE "No more rectangles for update"
00
 ]
        EXIT    EQ

; loop over file icons (format depends on viewmode)

 [ debugredraw
 Push "cx0-cy1"
 wsaddr r14, userdata + r_gwx0  ; current graphics window (abs)
 LDMIA  r14, {cx0, cy0, cx1, cy1}
 DREG cx0, "update file icons in graphics window: gwx0 := ",cc,Integer
 DREG cy0, ", gwy0 := ",cc,Integer
 DREG cx1, ", gwx1 := ",cc,Integer
 DREG cy1, ", gwy1 := ",,Integer
 Pull "cx0-cy1"
 ]
        LDR     r3, [r4, #d_nfiles]     ; r3 = no of files to do
        CMP     r3, #0
        BEQ     %FT95                   ; [nothing in this viewer]

        ADD     r5, r4, #d_headersize

90      BL      GetFileBox              ; get relative to work area origin
        BL      RedrawFile
        BVS     %FT99
        SUBS    r3, r3, #1
        ADDNE   r5, r5, #df_size
        BNE     %BT90

95      ADR     r1, userdata
 [ debugredraw
 LDR r14, [r1, #u_handle]
 DREG r14, "calling XWimp_GetRectangle, window handle ",,Integer
 ]
        SWI     XWimp_GetRectangle      ; r0,r1 := more_rectangle state
        BVC     %BT05

@


4.10
log
@Correct sprite name clamping while looking for sm!app
A previous fix in Filer-2_10 had changed the concatenation to be clamped at 10 letters so it doesn't overflow the buffer for long app names. However, having failed to find 'sm!app' it then just tried adding 2 to the string pointer therefore looking for a 10 letter sprite '!app'.
This is different behaviour to before Filer-2_10, which would have overrun thebuffer but at least looked for a full 12 letter name.
Optimised strncat a bit.
Put unused source file in the attic.
Trimmed some bug fix switches dating back to 1989.

Version 2.24. Tagged as 'Filer-2_24'
@
text
@d87 3
a89 2
        MUL     r7, r0, r1                      ; Adjust the size of the writeable icon according
        ADD     r4, r4, r7                      ;     to the y eigenvalue
d2093 2
a2094 3
        SUB     r2, r2, #1
        CMP     r2, #0
        BGT     %BT24
@


4.9
log
@  Bugfixes related to misuse of unaligned loads
Detail:
  s.Commands: Filer_Truncation code to parse OS_ReadArgs output block was
    written on the assumption that LDR allows unaligned accesses - this is
    only true as of ARMv6! We got away with it as long as all the truncation
    widths were <= 65535 OS units - which in practice is easily as wide as
    any screen anyone might use. Nevertheless, this is now fixed to use the
    LDW macro.
  s.DragEnd - d_filesperrow is a 1-byte variable, yet it was loaded using
    LDR. This is clearly wrong and may in part be responsible for offsets
    48-63 of Message_FilerSelection being nonsense (though they are still
    incorrect after this fix).
  s.Redraw - loaded colour values to pass to Wimp_SetColour from 1-byte
    variables using LDR, and hence was setting undefined bits. Harmless with
    current Wimps, but probably not a good idea.
Admin:
  Builds but untested.

Version 2.18. Tagged as 'Filer-2_18'
@
text
@a224 2
lgi_trunc_variable DCB "Filer$LargeIconTruncation",0

d485 1
a485 1
; If 'sm!Applic' exists, use it
d494 1
a494 1
        ADD     r2, r2, r14             ; r2 -> !Applic
d496 1
a496 1
        ADD     r2, r2, r14, LSR #16    ; r2 -> !Applic
d498 3
a500 3
        BL      strncat10               ; 12 char sprite name - 2 char sm
        MOV     r2, r1                  ; r2 -> sm!Applic

d506 5
a510 2
        ADD     r2, r2, #2              ; skip 'sm'

d632 4
a635 4
        MOV     r14, #0
        STRB    r14, [r1]               ; init to empty
        BL      strncat12
        MOV     r2, r1
a636 1
        BL      ExistsSprite
a737 2
dfilename DCB "$.debfile",0

@


4.8
log
@  Fixed widest name in filer window in large icon mode having the text clipped.
Detail:
  Changed redraw.s so that the largest name in filer window in large icon mode
  doesn't have the text clipped. Added 8 OS unit error margin (line 1844) that
  had already been added in other modes.
Admin:
   Tested on Iyonix RO5.10
   Programmer tested only.
Notes:
  Changes by Colin Granville.

Version 2.13. Tagged as 'Filer-2_13'
@
text
@d764 2
a765 2
        LDR     r1, text_fgcolour
        LDR     r2, text_bgcolour
d806 1
a806 1
        LDR     r0, text_fgcolour       ; Is this paranoia or what, we ask ???
d808 1
a808 1
        LDRVC   r0, text_bgcolour
@


4.7
log
@        ensure neither large icon or small icon app name exceeds 12 chars
        even when app name is much longer. Re-enabled Alt-Select for icons
        whilst leaving Alt-Select renaming active.
Detail:
Admin:
     castle added ip.
     tested in iyonix rom


Version 2.10. Tagged as 'Filer-2_10'
@
text
@d1840 2
a1841 1

@


4.6
log
@         fix small bug to do with missing sm!app icons
Detail:
         s.Redraw used strncat in 1 place, but didnt initialise the count(n)
         resulted in potential lockup looking for a small app sprite when
         the full app sprite name was the max sprite name length (12)
         .. (i.e. with an app whose name was longer than 12 chars.
Admin:
         castle added IP


Version 2.09. Tagged as 'Filer-2_09'
@
text
@d94 1
a94 1
        BLT     %FT06                           ; if less, then ignore click
d96 1
a96 1
        BGT     %FT06
d98 1
a98 1
        BLT     %FT06
d100 1
a100 1
        BGT     %FT06
d491 1
d500 1
a500 4
        MOV     r6, r4                  ; remember r4
        MOV     r4, #12-2               ; 12 char sprite name - 2 char sm
        BL      strncat
        MOV     r4, r6                  ; restore
d629 7
a635 1

@


4.5
log
@  Misc bugfixes.
Detail:
  * Mered in RISCOS Ltd's fix for directory displays with more than 65536
    bytes of leafnames.
  * Tries to use Wimp_TextOp 4 to do ellipsis truncation. As a result, it
    can now cope properly with:
    + multibyte UTF-8 characters in leafnames (previously this caused
      problems even if not truncated)
    + WimpSymbol character substitution in leafnames
    + alphabets without an ellipsis character
    + fonts without an ellipsis character
  * Sprite icons in 'Copy as' and 'New directory' dialogue boxes are no
    longer filled.
Admin:
  Tested on Tungsten.

Version 2.08. Tagged as 'Filer-2_08'
@
text
@d499 2
d502 1
@


4.4
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 2.01. Tagged as 'Filer-2_01'
@
text
@d49 3
d53 1
d374 3
d378 1
d494 3
d498 1
d623 3
d627 1
d1734 3
d1738 1
d1824 3
d1828 1
d2031 13
@


4.3
log
@Made 32-bit compatible. Quite a complex job, and only limited testing so far.

Version 1.97. Tagged as 'Filer-1_97'
@
text
@d17 1
a17 1
wr_filename_validation    DCB  "s;pptr_write;A~ .:*#$&@@^%\|",34,0
d31 1
a31 1
create_rename_writeable ENTRY
d197 1
a197 1
remove_rename_writeable ENTRY
d237 1
a237 1
event_redraw_window ENTRY
d353 1
a353 1
RedrawFile ENTRY "r1-r5, x0, y0, x1, y1"
d1139 1
a1139 1
checkboxcoords ENTRY "cx0, cy0, cx1, cy1"
d1185 1
a1185 1
UpdateFile ENTRY "r1-r5"
d1376 1
a1376 1
GetItemBoxSize ENTRY
d1440 1
a1440 1
GetFileBox ENTRY "r1-r11"
d1582 1
a1582 1
FiletypeToSpritename ENTRY "r0,r1"
d1645 1
a1645 1
        ENTRY   "r0, r1, r4"
d2006 1
a2006 1
truncate_filename ENTRY "r0-r5"
d2107 1
a2107 1
read_font_widths ENTRY "r0-r6"
@


4.2
log
@Merged Ursula branch.
Moved to srccommit.

Version 1.96. Tagged as 'Filer-1_96'
@
text
@d50 1
a50 1
        LDR     r1, renaming_chunkaddr  
d60 1
a60 1
     
d77 2
a78 2
        MOVCS   r2, #1                          
        
d80 1
a80 1
        MOV     r1, r0, LSL r2 
d122 1
a122 1
        
d129 2
a130 2
        
        ; Create the writeable icon        
d133 1
a133 1
        SWI     XWimp_CreateIcon     
d154 1
a154 1
        
d165 1
a165 1
 
d177 2
a178 2
        
08  
d182 1
a182 1
 ]       
d193 1
a193 1
; In: 
d213 1
a213 1
        LDMIA   r5, {r0, r1, r2, r3, r4}    ; load window handle, followed by icon bounding box        
d343 2
a344 1
        EXITS                           ; Assumes VClear in caller lr
d387 2
a388 2
        BL      truncate_filename        
  
d418 3
a420 3
        
        BL      truncate_filename        
 
d424 1
a424 1
;                                
d435 1
a435 1
        
d629 1
a629 1
        
d631 1
a631 1
        ADREQ   r2, file_lxa            ; [load=exec; use 'file_xxx' icon]        
d660 1
a660 1
                ALIGN                
d907 1
a907 1
        MOVVC   r1, #typelength 
a933 1
        EXITS   VC                      ; Preserve caller's flags; CMN canset V
d987 1
a987 1
        MOVVC   r1, r3          
d999 1
a999 1
;; Entry as standard routines and [current_x0] updated                         
d1003 1
a1003 1
myOS_WriteC                                               
d1021 2
a1022 2
myOS_Write0  
 
d1032 1
a1032 1
        
d1046 1
a1046 1
        
d1071 1
a1071 1
        
d1085 1
a1085 1
        MOV     R8,SP               
d1100 1
a1100 1
        
d1113 1
a1113 1
        MOV     R8,SP               
d1186 1
a1186 1
        
d1198 1
a1198 1
 [ version >= 117            
d1463 1
a1463 1
 ]                           
d1469 1
a1469 1
        TEQ     r0,#0   
d1519 1
a1519 1
        BL      GetSmiWidth 
d1572 2
a1574 2
        EXITS
        
d1617 2
a1618 1
        EXITS
d1634 2
a1635 1
        EXITS
d1695 1
a1695 1
            
d1744 1
a1744 1
        
d1748 1
a1748 1
GetSmiWidth   
d1760 1
a1760 1
        MOV     r14,R0   
d1762 1
a1762 1
33      
d1765 1
a1765 1
GetSmiWidth_r11 
d1777 1
a1777 1
        MOV     r11,R0   
d1779 1
a1779 1
33      
d1783 1
a1783 1
            
d1824 1
a1824 1
GetLgiWidth   
d1826 1
a1826 1
        LDR     r14,[r4,#d_lgiwidth]     
d1836 1
a1836 1
        MOV     r14,R0   
d1838 1
a1838 1
33      
d1841 1
a1841 1
GetLgiWidth_r11 
d1853 1
a1853 1
        MOV     r11,R0   
d1855 1
a1855 1
33      
d1944 1
a1944 1
getfile_type_error     
d1949 1
a1949 1
        
d2022 1
a2022 1
        MOV     r10, r4        
d2024 1
a2024 1
        ; Now find the length of the filename string 
d2028 1
a2028 1
        
d2042 1
a2042 1
20      ; Copy string (upto split character) to icon buffer        
d2052 1
a2052 1
        
d2061 1
a2061 1
        
d2066 1
a2066 1
        ; If less than string width, subtract 1 and add ellipsis.        
d2071 1
a2071 1
                
d2073 1
a2073 1
        BL      strlen               
d2078 2
a2079 2
        
        ; Copy string (upto split character) to icon buffer        
d2089 1
a2089 1
        
d2124 1
a2124 1
        
d2126 1
a2126 1
        LDR     r1, largeicon_truncation        
d2132 1
a2132 1
        LDR     r1, smallicon_truncation        
@


4.1
log
@Initial revision
@
text
@d15 208
d243 2
d345 2
d373 2
a374 1
        wsaddr  r1, i_textbuffer
d381 1
d383 14
a396 1
; Large icon display
a397 9
10      Push    "R2"
        MOV     R2,#max_text_size
15      LDRB    r14, [r0], #1           ; Copy name, will be centred
        TEQ     r14, #0
        SUBNES  r2,r2,#1
        MOVEQ   r14, #CR
        STRB    r14, [r1], #1
        BNE     %BT15
        Pull    "r2"
d399 2
a400 1
 wsaddr r1, i_textbuffer
d412 22
a433 14
50      MOV     r2, #0                  ; Pad to right of name with spaces
60
                                        ; don't pad with fancy font
                                
        LDRB    r14, [r0]
        TEQ     r14, #0
;        MOVEQ   r14, #space
        ADDNE   r0, r0, #1
;        ADD     r0, r0, #1
        ADD     r2, r2, #1
        CMP     r2, #max_text_size
        MOVEQ   r14, #CR
        STRB    r14, [r1], #1
        BNE     %BT60
d436 2
a437 1
 wsaddr r1, i_textbuffer
a444 1

d486 1
a486 1
        BL      strcat
d510 9
d520 2
a521 2
80      TEQ     r6, r7
        ADREQ   r2, small_xxx           ; [load=exec; use 'small_xxx' icon]
d525 1
a525 1
        ADRCC   r2, small_xxx           ; [undated; use 'small_xxx' icon]
d571 2
d622 9
a630 2
10      TEQ     r6, r7
        ADREQ   r2, file_xxx            ; [load=exec; use 'file_xxx' icon]
d634 1
a634 1
        ADRCC   r2, file_xxx            ; [undated; use 'file_xxx' icon]
d656 3
d687 2
a688 1
 wsaddr r2, i_textbuffer
d690 1
a690 1
 wsaddr r2, i_spritebuffer
d714 2
d1230 2
a1231 2
        MOV     R3,#&8000
        MVN     R2,#&8000
d1572 1
d1574 1
a1575 1
 [ version >= 114
d1579 1
d1591 14
d1607 1
d1634 1
a1634 1
 ]
d1700 1
d1720 1
a1720 1
        ADD     R0,R0,#6+34+4           ; gap between sprite and text
d1730 13
d1816 4
a1821 1

d1990 152
@


4.1.4.1
log
@Alt + Select renaming added
@
text
@a16 34
; remove_rename_writeable
; =======================
;
; If it exists, delete the writeable icon used for renaming files
;
; In: Nowt
; Out: Nowt (no corruption)

remove_rename_writeable ENTRY

00
        Push    "r0-r5"
        LDR     r1, renaming_chunkaddr
        ADD     r1, r1, #re_windowhandle
        LDR     r0, [r1]
        CMP     r0, #0
        BEQ     %FT10
        SWI     Wimp_DeleteIcon
        MOV     r0,#0                       ; Update details of writeable icon to show nonexistance
        STR     r0, [r1]
        STR     r0, [r1, #4]

        ; Force a redraw
        ADD     r5, r1, #re_createwhandle   ; point to window handle
        LDMIA   r5, {r0, r1, r2, r3, r4}    ; load window handle, followed by icon bounding box        
        SWI     Wimp_ForceRedraw            ; Force a redraw of that area

10
        Pull    "r0-r5"
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
@


4.1.4.2
log
@A few changes to Alt+Select renaming
@
text
@a0 170
; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
 [ version>=186
wr_filename_validation    DCB  "s;pptr_write;A~ .:*#$&@@^%\|",34,0
 ]

 [ version >=186
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; create_rename_writeable
; =======================
;
; Create the writeable icon (if mouse click is within text bounding box)
;
; In:  r4 -> directory block
;      r5 -> file block
;
; Out: r0 - set if click was claimed, else 0

create_rename_writeable ENTRY

        Push "r0-r12"

        ; Check if filesystem is read-only (eg. ROM), in which case rename not allowed.
        LDR     r2, [r4, #d_filesystem]
        TST     r2, #fod_readonly
        BNE     %FT08

        ; store dirviewer block and fileinfo block (so we know what to rename later)
        LDR     r1, renaming_chunkaddr
        ADD     r1, r1, #re_dirblock
        STR     r4, [r1]
        STR     r5, [r1, #4]

        ; Copy the filename into our indirected area
        LDR     r1, [r4, #d_filenames]
        LDR     r6, [r5, #df_fileptr]
        ADD     r2, r1, r6, LSR #16             ; r2 -> filename (null-terminated)
        LDR     r1, renaming_chunkaddr  
        ADD     r1, r1, #re_textstring          ; r1 -> destination
        BL      strcpy                          ; to the string copy

        LDR     r10, renaming_chunkaddr         ; Where is the icon data for our writeable icon?
        ADD     r10, r10, #re_createiconblock

        LDR     r0, windowhandle                ; Store the window handle in the first word of the
        STR     r0, [r10]                       ; block which will be passed to Wimp_CreateIcon
        ADD     r9, r10, #4                     ; make R9 the location of the icon data
     
        LDRB    r5, [r4, #d_viewmode]           ; load r5 with the display mode bit
        AND     r5, r5, #db_displaymode         ; (use it later)

        ADR     r0, filebox1                    ; load the bounding box for the icon clicked on
        LDMIA   r0, {r1, r2, r3, r4}

        CMP     r5, #db_dm_largeicon            ; is this a large icon
        ADDNE   r1, r1, #40                     ; no, then decrease bounding box x
        SUB     r2, r2, #2
        MOV     r4, r2                          ; Decrease the vertical bound to take the
        ADD     r4, r4, #40                     ; writeable icon

        LDR     r6, relmousex                   ; load mouse x relative to window origin in r6
        LDR     r7, relmousey                   ; load mouse y relative to window origin in r6
        CMP     r6, r1                          ; compare x with left hand extreme of bouding box
        BLT     %FT06                           ; if less, then ignore click
        CMP     r6, r3                          ; compare x with right hand extreme of bounding box
        BGT     %FT06
        CMP     r7, r2                          ; compare y with bottom extreme of bounding box
        BLT     %FT06
        CMP     r7, r4                          ; compare y with top extreme
        BGT     %FT06

        STMIA   r9, {r1, r2, r3, r4}            ; store bounding box in icon data

        LDR     r0, windowhandle                ; put window handle in r0, plus use bounding box in r1-r4
        SWI     Wimp_ForceRedraw                ; to do wimp redraw.

        ADD     r9,r9,#16                       ; Move on r9 to next four words

        ; Now make icon flags
        MOV     r1,#7
        MOV     r4, r1,      LSL #24            ; Foreground colour   (bits 24-27)
        MOV     r1,#0
        ADD     r4, r4, r1,  LSL #28            ; Background colour   (bits 28-31)
        MOV     r1,#15
        ADD     r4, r4, r1,  LSL #12            ; Type                (bits 12-15)

        ADD     r4, r4, #if_indirected          ; Indirected          (bit 8)
        ADD     r4, r4, #if_filled              ; Filled background   (bit 5)
        ADD     r4, r4, #if_border              ; Border              (bit 2)
        ADD     r4, r4, #if_text                ; Has text            (bit 0)

        CMP     r5, #db_dm_largeicon            ; is this a large icon?
        ADDEQ   r4, r4, #if_hcentred            ; if a large sprite, centre horizontally
        ADDEQ   r4, r4, #if_sprite              ; if a large sprite, then add an invisible sprite
        ADDNE   r4, r4, #if_vcentred            ; if NOT a large sprite, then centre vertically
        
        ; Now make the text buffer etc. point to our memory chunk
        LDR     r5, renaming_chunkaddr
        ADD     r5, r5, #re_textstring          ; location of text buffer
        ADR     r6, wr_filename_validation      ; location of validation string
        MOV     r7,#252                         ; length of buffer
        STMIA   r9, {r4, r5, r6, r7}            ; store flags etc.
        
        ; Create the writeable icon        
        MOV     r0,#0
        MOV     r1,r10
        SWI     Wimp_CreateIcon     

        LDR     r2, renaming_chunkaddr
        ADD     r2, r2, #re_windowhandle
        STR     r0, [r2, #4]                    ; store the handle of the writeable icon

        ; Send a claim entity message
        LDR     r1, renaming_chunkaddr
        ADD     r1, r1, #re_tempdata            ; Address of a block to put the message data
        MOV     r0, #24                         ; message size
        STR     r0, [r1]
        LDR     r0, mytaskhandle                ; my task handle
        STR     r0, [r1, #4]
        MOV     r0, #0                          ; my ref
        STR     r0, [r1, #8]
        MOV     r0, #0                          ; your ref
        STR     r0, [r1, #12]
        MOV     r0, #Message_ClaimEntity        ; message action
        STR     r0, [r1, #16]
        MOV     r0, #3                          ; bits 0 and 1 set indicating caret claim
        STR     r0, [r1, #20]
        
        MOV     r0, #17                         ; event code
        MOV     r2, #0                          ; 0 = broadcast message
        SWI     Wimp_SendMessage

        ; Set the caret position
        LDR     r2, renaming_chunkaddr
        LDR     r1, [r2, #re_iconhandle]        ; put icon handle in r1 for SetCaret call

        LDR     r0, windowhandle                ; put window handle in r0.
        STR     r0, [r2, #re_windowhandle]      ; store window handle
 
        LDR     r2, absmousex                   ; Set caret position according to mouse x and y
        LDR     r3, absmousey
        MVN     r4, #1
        MVN     r5, #1

        SWI     Wimp_SetCaretPosition

06                                              ; exit claimed click
        Pull    "r0-r12"
        MOV     r0, #1
        EXIT
        
08  
        Pull    "r0-r12"                        ; exit unclaimed click
        MOV     r0, #0
        EXIT
        

d22 1
a22 2
; In:  Nowt
;
a46 2

 ]
@


4.1.4.3
log
@Long filename support and SaveAs style new directory creation
@
text
@d15 1
d17 1
d19 1
d72 1
a72 15
        ADD     r4, r4, #32                     ;     writeable icon

        Push    "r0-r3"                         ; Keep r0 - r3
        MOV     r0, #-1
        MOV     r1, #5
        SWI     OS_ReadModeVariable             ; Read the y eigen factor
        MOVCS   r2, #1                          
        
        MOV     r0, #1
        MOV     r1, r0, LSL r2 

        MOV     r0, #4
        MUL     r7, r0, r1                      ; Adjust the size of the writeable icon according
        ADD     r4, r4, r7                      ;     to the y eigenvalue
        Pull    "r0-r3"                         ; Restore r0 - r3
d153 2
a154 2
        LDR     r2, relmousex                   ; Set caret position according to mouse x and y
        LDR     r3, relmousey
d162 1
a162 1
        CMP     r0, r0
d167 1
a167 1
        CMP     pc, #0
d178 1
a178 1
; In: 
d180 1
a180 1
; Out: no corruption
d205 1
a206 1
lgi_trunc_variable DCB "Filer$LargeIconTruncation",0
a227 46

        [ version >= 187
        Push    "r1"
        SUB     sp, sp, #4

        ; Set font to desktop font
        MOV     r0, #8
        SWI     Wimp_ReadSysInfo
        SWI     Font_SetFont

        ; What's the width of an ellipsis in the current font?
        MOV     r0, #140
        STRB    r0, [sp]
        MOV     r0, #0
        STRB    r0, [sp, #1]        
        MOV     r1, sp
        MOV     r2, #71680
        ADD     r2, r2, #320
        MOV     r3, r2
        MOV     r4, #-1
        MOV     r5, #1
        SWI     XFont_StringWidth
        STR     r2, ellipsis_width
        
        ; What's the large icon maximum width allowed, in millipoints?
        LDR     r1, largeicon_truncation        
        MOV     r2, #0
        SWI     XFont_Converttopoints
        STR     r1, largeicon_truncation_mp

        ; What's the small icon maximum width allowed, in millipoints?
        LDR     r1, smallicon_truncation        
        MOV     r2, #0
        SWI     XFont_Converttopoints
        STR     r1, smallicon_truncation_mp

        ; What's the full info maximum width allowed, in millipoints?
        LDR     r1, fullinfo_truncation        
        MOV     r2, #0
        SWI     XFont_Converttopoints
        STR     r1, fullinfo_truncation_mp

        ADD     sp, sp, #4
        Pull    "r1"
        ]

a327 2
astring DCB "r2 %d r3 %d",10,0

d354 1
a354 2
        ;wsaddr  r1, i_textbuffer
        LDR     r1, i_textbuffer_ptr
d361 1
d364 9
a372 15
        MOV     r6, r0                   ; filename
        MOV     r7, r1                   ; icon
        LDR     r8, largeicon_truncation_mp
        BL      truncate_filename        
  
;10      Push    "R2"
;        MOV     R2,#max_text_size
;15      LDRB    r14, [r0], #1           ; Copy name, will be centred
;        TEQ     r14, #0
;        SUBNES  r2,r2,#1
;        MOVEQ   r14, #CR
;        STRB    r14, [r1], #1
;        BNE     %BT15
;        Pull    "r2"

d374 1
a374 2
 ;wsaddr r1, i_textbuffer
 LDR     r1, i_textbuffer_ptr
d386 14
a399 21
50      MOV     r6, r0                       ; filename
        MOV     r7, r1                       ; icon
        LDR     r8, smallicon_truncation_mp  ; truncation width in millipoints
        CMP     r14, #db_dm_smallicon
        LDRNE   r8, fullinfo_truncation_mp   ; If Full Info, different width
        BL      truncate_filename        
 
;50      MOV     r2, #0                  ; Pad to right of name with spaces
;60
;                                        ; don't pad with fancy font
;                                
;        LDRB    r14, [r0]
;        TEQ     r14, #0
;;        MOVEQ   r14, #space
;        ADDNE   r0, r0, #1
;;        ADD     r0, r0, #1
;        ADD     r2, r2, #1
;        CMP     r2, #max_text_size
;        MOVEQ   r14, #CR
;        STRB    r14, [r1], #1
;        BNE     %BT60
d402 1
a402 2
 ;wsaddr r1, i_textbuffer
 LDR     r1, i_textbuffer_ptr
d410 1
d452 1
a452 1
        BL      strncat
a475 6
80      LDR     r2, dead_file
        CMP     r6, r2
        BNE     %FT82
        TEQ     r6, r7
        ADREQ   r2, small_unf
        Pull    "r3,pc",EQ
d477 2
a478 2
82      TEQ     r6, r7
        ADREQ   r2, small_lae           ; [load=exec; use 'small_xxx' icon]
d482 1
a482 1
        ADRCC   r2, small_lae           ; [undated; use 'small_xxx' icon]
a527 2
small_lae       DCB     "small_lae",0
small_unf       DCB     "small_unf",0
d577 2
a578 9
10      LDR     r2, dead_file
        CMP     r6, r2
        BNE     %FT12
        TEQ     r6, r7
        ADREQ   r2, file_unf
        Pull    "r3,pc",EQ
        
12      TEQ     r6, r7
        ADREQ   r2, file_lae            ; [load=exec; use 'file_xxx' icon]        
d582 1
a582 1
        ADRCC   r2, file_lae            ; [undated; use 'file_xxx' icon]
a603 3
file_lae        DCB     "file_lae", 0
file_unf        DCB     "file_unf", 0
dead_file       DCD     &DEADDEAD
d632 1
a632 2
 ;wsaddr r2, i_textbuffer
 LDR     r2, i_textbuffer_ptr
d634 1
a634 1
 wsaddr r2, i_spritebufer
a657 1

a1513 1

a1514 1
        
d1531 1
a1531 1
        ADREQL  r2, file_lae
a1624 1
        Push    "r0"
a1653 12

        Pull    "r2"
        LDRB    r1, [r2, #d_viewmode]
        AND     r1, r1,#db_displaymode
        CMP     r1, #db_dm_smallicon      ; if small icon display, truncate.
        LDRNE   r1, fullinfo_truncation   ; full info
        LDREQ   r1, smallicon_truncation  ; small icon
        ADD     r1, r1, #34
        CMP     r1, r0
        MOVLT   r0, r1
16
        
d1727 1
a1727 3
        LDR     r1, largeicon_truncation
        CMP     r1, r0
        MOVLT   r0, r1
a1728 1
        Pull    "R1-R5,PC"
a1897 70

 [ version >= 187

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; truncate_filename
;
; Take a filename in and output the truncated version (including ellipsis).
;
; In:   r6 -> filename
;       r7 -> icon buffer
;       r8 =  maximum width, in millipoints
;
; Out:  r10, r11 corrupted
;       All other regs preserved.

truncate_filename ENTRY "r0-r5"

        ; Set font to desktop font
        MOV     r0, #8
        SWI     Wimp_ReadSysInfo
        SWI     Font_SetFont

        ; Where would we need to split the string to fit the maximum width?
        MOV     r1, r0
        MOV     r2, r8
        MOV     r3, r8
        MOV     r4, #-1
        MOV     r5, #256
        SWI     XFont_StringWidth
        MOV     r10, r4

        ; Now find the length of the filename string 
        MOV     r1, r6
        BL      strlen
        MOV     r11, r3
         
        ; If the string is split before end of length, then find the new split size, taking
        ; into account the ellipsis character which we will add.
        CMP     r11, r10
        BLE     %FT20
        MOV     r1, r6
        LDR     r3, ellipsis_width
        SUB     r2, r8, r3
        MOV     r3, r8
        MOV     r4, #-1
        MOV     r5, #256
        SWI     XFont_StringWidth
        MOV     r10, r4

20      ; Copy string (upto split character) to icon buffer        
        MOV     r0, r7
        MOV     r1, r6
        MOV     r2, r10
24
        LDRB    r14, [r1], #1
        STRB    r14, [r0], #1
        SUB     r2, r2, #1
        CMP     r2, #0
        BGT     %BT24
        
        ; If necessary, add ellipsis character
        MOV     r14, #140
        CMP     r11, r10
        STRGTB  r14, [r0], #1
        MOV     r14, #CR
        STRB    r14, [r0], #1

        EXIT

 ]
@


4.1.4.4
log
@Add new options to Options menu, plus fixed bugs
@
text
@a456 1
        
a548 2
; At this point, r6 = load address, r7 = exec address.

d550 5
a554 6
        CMP     r6, r2          ; Is load address = &DEADDEAD
        BNE     %FT82           ; No?
        CMP     r6, r7          ; Is exec address = &DEADDEAD
        ADREQ   r2, small_unf   ; If so, then use 'small_unf'
        BEQ     %FA90
        ;Pull    "r3,pc",EQ
d557 1
a557 1
        ADREQ   r2, small_lxa           ; [load=exec; use 'small_xxx' icon]
d561 1
a561 1
        ADRCC   r2, small_lxa           ; [undated; use 'small_xxx' icon]
d607 1
a607 1
small_lxa       DCB     "small_lxa",0
d666 1
a666 1
        ADREQ   r2, file_lxa            ; [load=exec; use 'file_xxx' icon]        
d670 1
a670 1
        ADRCC   r2, file_lxa            ; [undated; use 'file_xxx' icon]
d692 1
a692 1
file_lxa        DCB     "file_lxa", 0
d1626 1
a1626 1
        ADREQL  r2, file_lxa
d2032 1
a2032 1
        MOV     r1, r6
d2038 1
a2038 1
        MOV     r10, r4        
d2044 1
a2044 1
        
d2070 1
a2071 1
        MOVGT   r14, #140
@


4.1.4.5
log
@Fixed bug with system font in Filer windows, plus redraw of highlighted icons.
@
text
@d247 1
a247 2
        CMP     r0, #0
        SWINE   Font_SetFont
d276 1
a276 1
        LDR     r1, fullinfo_truncation
a753 1
dfilename DCB "$.debfile",0
d1744 1
a1744 1
        ADD     R0,R0,#6+34+8           ; gap between sprite and text
d1761 1
a1761 1
        ADD     r1, r1, #34+12
a1763 1

a2032 2
        CMP     r0, #0            ; If system font, skip to different routine
        BEQ     %FT30
a2071 37
        
        ; If necessary, add ellipsis character
        CMP     r11, r10
        MOVGT   r14, #140
        STRGTB  r14, [r0], #1
        MOV     r14, #CR
        STRB    r14, [r0], #1

        EXIT
        
30 ; Deal with system font

        ; Covert millipoints back to OS units
        ; Shift right 5 to divide by 32 and find number of characters
        ; If less than string width, subtract 1 and add ellipsis.        
        MOV     r1, r8
        MOV     r2, #0
        SWI     XFont_ConverttoOS    ; this returns max width in OS units
        MOV     r0, r1, LSR #4       ; divide max width by 16 to get number of chars
                
        MOV     r1, r6
        BL      strlen               
        MOV     r11, r3              ; r11 = length of string
        MOV     r10, r3              ; r10 = how many characters we'll display (try for whole length)
        CMP     r10, r0              ; see if whole length will fit
        SUBGT   r10, r0, #1          ; if not, put max characters-1 (we'll ad an ellipsis)
        
        ; Copy string (upto split character) to icon buffer        
        MOV     r0, r7
        MOV     r1, r6
        MOV     r2, r10
34
        LDRB    r14, [r1], #1
        STRB    r14, [r0], #1
        SUB     r2, r2, #1
        CMP     r2, #0
        BGT     %BT34
@


4.1.4.6
log
@Changed font width calculation code.
@
text
@a0 16
; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
 [ AltRenaming

d74 1
a74 1
        SWI     XOS_ReadModeVariable             ; Read the y eigen factor
d99 1
a99 1
        SWI     XWimp_ForceRedraw                ; to do wimp redraw.
d131 1
a131 1
        SWI     XWimp_CreateIcon     
d155 1
a155 1
        SWI     XWimp_SendMessage
d169 1
a169 1
        SWI     XWimp_SetCaretPosition
d180 1
a180 2
 ]       

a181 1
 [ AltRenaming
d202 1
a202 1
        SWI     XWimp_DeleteIcon
d210 1
a210 1
        SWI     XWimp_ForceRedraw            ; Force a redraw of that area
d215 1
a215 1
 ]
d239 46
a284 1
        BL      read_font_widths
d2017 1
d2035 1
a2035 1
        SWI     XWimp_ReadSysInfo
d2038 1
a2038 1
        SWI     XFont_SetFont
d2124 1
a2124 45

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; read_font_widths
;
; Read some widths needed by the truncation code

ellipsis_str DCB "",0

read_font_widths ENTRY "r0-r6"

        ; Set font to desktop font
        MOV     r0, #8
        SWI     XWimp_ReadSysInfo
        CMP     r0, #0
        SWINE   XFont_SetFont

        ; What's the width of an ellipsis in the current font?
        ADR     r1, ellipsis_str
        MOV     r2, #71680
        ADD     r2, r2, #320
        MOV     r3, r2
        MOV     r4, #-1
        MOV     r5, #1
        SWI     XFont_StringWidth
        STR     r2, ellipsis_width
        
        ; What's the large icon maximum width allowed, in millipoints?
        LDR     r1, largeicon_truncation        
        MOV     r2, #0
        SWI     XFont_Converttopoints
        STR     r1, largeicon_truncation_mp

        ; What's the small icon maximum width allowed, in millipoints?
        LDR     r1, smallicon_truncation        
        MOV     r2, #0
        SWI     XFont_Converttopoints
        STR     r1, smallicon_truncation_mp

        ; What's the full info maximum width allowed, in millipoints?
        LDR     r1, fullinfo_truncation
        MOV     r2, #0
        SWI     XFont_Converttopoints
        STR     r1, fullinfo_truncation_mp

        EXIT
@


4.1.4.7
log
@Fixed bug which displayed wrong icon in file info window for DEADDEAD files.
@
text
@d1576 1
a1579 1
;       r3 -> fileblock
d1591 1
a1591 15

    [ {TRUE}
        BNE     %FT04
        LDR     r1, dead_file
        LDR     r0, [r3, #df_exec]
        CMP     r0, r1
        LDREQ   r0, [r3, #df_load]
        CMP     r0, r1
        ADRL    r2, file_lxa
        ADREQL  r2, file_unf
        ADRNEL  r2, file_lxa
        EXIT
04
    |
        ADREQL  r2, file_xxx
a1592 1
    ]
d1619 1
a1619 1

@


4.1.4.8
log
@Message_FilerSelection enhanced to provide x and y co-ordinates of pointer.
Fixed redraw bug associated with very tall dirviewers.
@
text
@d1230 2
a1231 2
        MOV     R3,#&FFFFFF
        MVN     R2,#&FFFFFF
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

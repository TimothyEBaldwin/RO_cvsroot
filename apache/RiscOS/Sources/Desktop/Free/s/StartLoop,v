head	4.8;
access;
symbols
	Free-0_42:4.8
	Free-0_41:4.8
	Free-0_40:4.7
	RO_5_07:4.6
	Free-0_39:4.6
	Free-0_38:4.5
	Free-0_37:4.4
	Free-0_36:4.4
	dellis_autobuild_BaseSW:4.3
	Free-0_35:4.3
	Free-0_34:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.4
	Free-0_33:4.2
	ROL_merge:4.1.10.1
	ROL_Free-0_33:4.1.10.1
	ROL_bp:4.1
	ROL:4.1.0.10
	Free-0_32:4.1
	Ursula_merge:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_Free_0_30:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.8
date	2012.04.13.22.55.30;	author bavison;	state Exp;
branches;
next	4.7;
commitid	l03GGMel26OudL0w;

4.7
date	2011.11.28.12.18.36;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	iKirgixLQEf066Jv;

4.6
date	2002.11.26.17.25.03;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.11.22.21.35.43;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2001.03.16.17.07.29;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.05.25.16.05.16;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.08.25.12.45.53;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.53;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1
	4.1.10.1;
next	;

4.1.1.1
date	96.11.05.09.29.53;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.29.17;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.20.15;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.18.10;	author nturton;	state Exp;
branches;
next	;

4.1.10.1
date	99.08.25.12.25.22;	author sbrodie;	state Exp;
branches;
next	;


desc
@@


4.8
log
@  Changes to header file handling
Detail:
  Filing system handler reason codes moved into Hdr:Free so they can be used
  from other modules. Also created a C version of the header, Interface/Free.h
Admin:
  Shouldn't be any functional change to the Free module itself.
  Worth noting that the PRM and the updated docs herein are wrong: the handler
  can be entered in either USR mode or SVC mode, depending upon the reason
  code (1 and 3 SVC mode, 2 and 4 USR mode). This makes implementing the
  handler in C "interesting"...

Version 0.41. Tagged as 'Free-0_41'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > s.StartLoop

; -----------------------------------------------------------------------------
;      Application title and 'TASK' word store
taskidentifier  DCB     "TASK"
                ALIGN

; -----------------------------------------------------------------------------
;       Set up error blocks

        MakeInternatErrorBlock WimpNotPresent,,NoWimp     ; "Window Manager not present"

ErrorOldWimp
        SWI     XWimp_CloseDown
        SWI     XOS_WriteI+4            ; just in case (old Wimp!)
        ADR     r0, ErrorBlock_WimpNotPresent
        MOV     r1, #0
        BL      LookupError

ErrorNoWimp
        SWI     OS_GenerateError        ; can't use Wimp to report error!

CloseWimp

        EntryS  "r0"
        LDR     r0, mytaskhandle        ; Get task handle
        LDR     r1, taskidentifier
        SWI     XWimp_CloseDown
        EXITS

; -----------------------------------------------------------------------------
template_file   DCB     "Free:Templates",0
                ALIGN
window_name     DCB     "Free",0
                ALIGN
task_token      DCB     "Title",0
                ALIGN
title_prefix    DCB     "FSP",0
                ALIGN
units_token     DCB     "bytes",0
                ALIGN
MessagesList    DCD     Message_Quit
                DCD     0

; -----------------------------------------------------------------------------
;       Start up the wimp task for Free
Start
        LDR     r12, [r12]              ; get workspace pointer

        ADRL    r0, ErrorBlock_CantStartFree
        MOV     r1, #0
        MOV     r2, #0
        ADRL    r4, Title
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0

        LDR     r14, mytaskhandle       ; abort if not responding to desktop starting stuff
        CMP     r14, #-1
        SWINE   XMessageTrans_ErrorLookup
        SWIVS   OS_GenerateError

        ADRL    sp, stacktop            ; STACK IS NOW VALID!

        ADR     r0, units_token
        BL      Lookup_InPlace
        MOVVC   r4, r0
        ADRVS   r4, units_token         ; the token happens to be the english default too
        ADR     r0, message_bytes
        MOV     r3, #?message_bytes-1
        BL      copy_r0r4r3_space       ; cache the 'bytes' suffix

        ADR     r0,task_token
        BL      Lookup_InPlace
        SWIVS   OS_GenerateError
        MOV     r2,r0

        LDR     r0, =310                ; We know about wimp 3.10 and have a messages list
        LDR     r1, taskidentifier
        ADR     r3, MessagesList
        SWI     XWimp_Initialise
        LDR     r3, =310                ; Wimp version number that we want.
        CMP     r0,r3                   ; needs Wimp with Wimp_PollWord, draggable iconbar icons
                                        ; and Iconize and close window messages.
        BCC     ErrorOldWimp

        STR     r1, mytaskhandle        ; Store task handle

        ADR     r1, template_file       ; Load in the templates
        SWI     XWimp_OpenTemplate
        BLVS    CloseWimp
        SWIVS   OS_GenerateError

        ADR     r1, windowarea                ; Get template for window into memory.
        LDR     r2, =indirected_data_offset
        ADD     r2,r2,r12
        ADD     r3, r2, #?indirected_data
        MOV     r4, #-1                     ; No font array
        ADR     r5, window_name             ; Name of window.
        MOV     r6, #0                      ; Search from first template.
        SWI     XWimp_LoadTemplate
        BLVS    CloseWimp
        SWIVS   OS_GenerateError

        SWIVC   XWimp_CloseTemplate


        ADR     r1,windowarea+88
        LDR     r0,[r1,#-4]
        Debug   xx,"number of icons is: ",r0

        ADD     r1,r1,#icon_SizeBar :SHL: icon_shift
        LDR     r0,[r1,#8]
        LDR     r1,[r1,#0]
        SUB     r0,r0,r1
        STR     r0,full_bar                 ; Size of 100% Bar.

        Debug   xx,"Full bar size is ",r0

        MOV     r0,#0
        STR     r0,poll_word

; -----------------------------------------------------------------------------
;       Wimp polling routine
repollwimp
        BVC     %FT01
        Push    "r0"
        ADRL    R0,task_token
        MOV     r2,r0                   ; Just in case !
        BL      Lookup_InPlace
        ADDVS   sp,sp,#4
        MOVVC   r2,r0
        Pull    "r0",VC
        MOV     R1,#6                   ; Cancel box
        SWI     XWimp_ReportError

01

; Call Wimp_Poll.
        MOV     R0, #&31
        ORR     R0, R0, #&400000        ; Poll word (low priority)
        ADR     r3, poll_word
        ADR     R1,dataarea
        SWI     XWimp_Poll              ; can't call non-X form
        BVS     repollwimp

; Call the appropriate routine using a fast jump table
        ADR     LR,repollwimp
        CMP     R0,#(endjptable-jptable)/4
        ADDCC   PC,PC,R0,ASL #2
        MOV     PC,LR
jptable
        MOV     PC,LR                   ;  0  null reason
        MOV     PC,LR                   ;  1  redraw window
        B       open_window             ;  2  open window
        B       close_window            ;  3  close window
        MOV     PC,LR                   ;  4  pointer leaving window
        MOV     PC,LR                   ;  5  pointer entering window
        MOV     PC,LR                   ;  6  mouse click.
        MOV     PC,LR                   ;  7  drag box complete
        MOV     PC,LR                   ;  8
        MOV     PC,LR                   ;  9  menu_select
        MOV     PC,LR                   ; 10
        MOV     PC,LR                   ; 11
        MOV     PC,LR                   ; 12
        B       update_windows          ; 13  poll word non-zero
        MOV     PC,LR                   ; 14
        MOV     PC,LR                   ; 15
        MOV     PC,LR                   ; 16
        B       message_received        ; 17
        B       message_received_ack    ; 18
        MOV     PC,LR                   ; 19
endjptable

; -----------------------------------------------------------------------------
open_window
        SWI     Wimp_OpenWindow
        MOV     PC,LR

; -----------------------------------------------------------------------------
close_window_from_block
        EntryS  "r1-r5"

        ADR     r1,dataarea
        LDR     r2,[r5,#window_handle]
        STR     r2,[r1]

        B       int_close_window
close_window
        ALTENTRY
int_close_window
        SWI     Wimp_DeleteWindow       ; 14 Jul 92 OSS Used to be Close

        ADR     r0,windows_ptr
01
        LDR     r0,[r0,#next_ptr]
        CMP     r0,#0
        EXIT    EQ

        LDR     r2,[r0,#window_handle]
        LDR     r14,[r1]
        CMP     r14,r2
        BNE     %BT01

        LDR     r1,[r0,#next_ptr]
        LDR     r2,[r0,#prev_ptr]
        CMP     r1,#0
        STRNE   r2,[r1,#prev_ptr]
        CMP     r2,#0
        STRNE   r1,[r2,#next_ptr]
        STREQ   r1,windows_ptr            ; Unlinked from list.

        MOV     r5,r0

        LDR     r2,[r0,#window_discname]
        MOV     r0,#ModHandReason_Free
        SWI     XOS_Module
        EXIT    VS

        Debug   xx,"Freed space"

        MOV     r0,#ModHandReason_Free
        MOV     r2,r5
        SWI     XOS_Module
        EXIT    VS

        Debug   xx,"Freed block."

        EXITS

; -----------------------------------------------------------------------------
; This is called when the poll word is non-zero, it scans the window list
; to find out which windows are to be updated, and updates them.
;

icon_shift           *  5

update_windows

        Push    "LR"

        Debug   xx,"Poll word non zero"

        MOV     r3,#0
        STR     r3, poll_word           ; Clear poll word.

        ADR     r5,windows_ptr
updatelp
        LDR     r5,[r5,#next_ptr]
updatelp1
        CMP     r5,#0
        Pull    "PC",EQ            ; Updated all windows.

        LDR     r0,[r5,#window_update]
        CMP     r0,#0
        BEQ     updatelp           ; Unchanged.

        Debug   xx,"Window updated."

        LDR     r0,[r5,#window_handle]
        CMP     r0,#-1
        BNE     just_update        ; Window already exists.

        Debug   xx,"New window"

        LDR     r0,[r5,#window_namelength]

        ADD     r3,r0,#60          ; Get length
        ADD     r3,r3,#&100
        MOV     r0,#ModHandReason_Claim
        SWI     XOS_Module         ; Claim space to hold name. + 3 sizes.
        Pull    "PC",VS

        ADRL    r0,title_prefix
        LDR     r4,[r5,#window_device]
        BL      Lookup
        Pull    "PC",VS
        ADD     r3,r3,#1
        STR     r3,[r5,#window_namelength]
        Debug   xx,"Length returned from lookup is ",r3

        ADR     r1,windowarea+72   ; Point at title data
        STR     r2,[r1]            ; Set it to point at name.
        STR     r2,[r5,#window_discname]
        LDR     r0,[r5,#window_namelength]
        STR     r0,[r1,#8]         ; Length of name.
        Debug   xx,"title length is ",r0
        ADR     r1,windowarea+88
        ADD     r2,r2,r0           ; Start of first data area.
        STR     r2,[r1,#20+icon_Size :SHL: icon_shift]
        ADD     r2,r2,#20          ; Start of second data area.
        STR     r2,[r1,#20+icon_Free :SHL: icon_shift]
        ADD     r2,r2,#20          ; Start of third data area.
        STR     r2,[r1,#20+icon_Used :SHL: icon_shift]


        MOV     r0,#-1             ;init the cached values so they'll always change the first time
        STR     r0,[r5,#window_size_lo]
        STR     r0,[r5,#window_free_lo]
        STR     r0,[r5,#window_used_lo]
        STR     r0,[r5,#window_size_hi]
        STR     r0,[r5,#window_free_hi]
        STR     r0,[r5,#window_used_hi]
  [ fix_silly_sizes
        MOV     r0,#'?' :SHL: 24
        STR     r0,[r5,#used_ascii]
        STR     r0,[r5,#free_ascii]
        STR     r0,[r5,#size_ascii]
  ]

        ; Centre window on mouse pointer
        ADR     r1,dataarea
        ADR     r2,windowarea
        SWI     XWimp_GetPointerInfo
        ADR     r2,windowarea
        LDR     r3,[r2,#w_wax0]
        LDR     r4,[r2,#w_wax1]
        SUB     r4,r4,r3
        LDR     r0,[r1]
        SUB     r3,r0,r4,LSR #1    ; Mouse pos - 1/2 window size
        ADD     r4,r4,r3
        STR     r3,[r2,#w_wax0]
        STR     r4,[r2,#w_wax1]

        LDR     r3,[r2,#w_way0]
        LDR     r4,[r2,#w_way1]
        SUB     r4,r4,r3
        LDR     r0,[r1,#4]
        SUB     r3,r0,r4,LSR #1    ; Mouse pos - 1/2 window size
      [ {TRUE}
        MOV     r0,#-2
        STR     r0,[r1]
        SWI     XWimp_GetWindowState
        LDR     r0,[r1,#16]        ; top of icon bar
        ADD     r0,r0,#4
        CMP     r3,r0
        MOVLT   r3,r0              ; ensure we're clear of the icon bar
      ]
        ADD     r4,r4,r3
        STR     r3,[r2,#w_way0]
        STR     r4,[r2,#w_way1]

        ADR     r1,windowarea
        SWI     XWimp_CreateWindow ; Create the window
        Pull    "PC",VS
        STR     r0,[r5,#window_handle]

        Debug   xx,"Window created."


just_update                        ; Window has changed, update it.

        Debug   xx,"Update window"

        LDR     r0,[r5,#window_update]
        TST     r0,#1 :SHL: 30
        BEQ     %FT01

        ADR     r1,dataarea
        LDR     r0,[r5,#window_handle]
        STR     r0,[r1]
        LDR     r5,[r5,#next_ptr]
        BL      close_window
        B       updatelp1

01      TST     r0,#1 :SHL: 31
        MOV     r0,#0
        STR     r0,[r5,#window_update]
        BEQ     %FT01

        Debug   xx,"Open at front"

        LDR     r0,[r5,#window_handle]
        ADR     r1,dataarea
        STR     r0,[r1]
        SWI     XWimp_GetWindowState
        Pull    "PC",VS
        ADR     r1,dataarea
        MOV     r0,#-1
        STR     r0,[r1,#28]        ; Open at front.
        SWI     XWimp_OpenWindow
        Pull    "PC",VS

        Debug   xx,"Window re-opened"

01
        ;amg: first, we try to treat this as a 64 bit aware filing system. If this fails,
        ;we then use the 32 bit getspace reason code, but still need to mangle it into the
        ;internal 64 bit layout.

        ;data layout
        ;old 00 size    new 00 size low
        ;    04 free        04 size high
        ;    08 used        08 free low
        ;                   0c free high
        ;                   10 used low
        ;                   14 used high

        MOV     r0,#0
        STR     r0,[r5,#no_change]

        MOV     r0,#FreeReason_GetSpace64
        LDR     r1,[r5,#window_fs]
        ADR     r2,dataarea
        LDR     r3,[r5,#window_device]
        BL      CallEntry

        ; if there was an error, R0 will NOT be zero.

        CMP     r0,#0                    ; if successful R0 zeroed as well as filling in the block
        BEQ     %FT09

        MOV     r0,#FreeReason_GetSpace
        BL      CallEntry                ; [r2] = Size, Free , Used
        Push    "r0",VS
        BLVS    close_window_from_block
        Pull    "r0,PC",VS

        ;move the data returned into the new layout

        LDMIB   r2,{r1,r6}
        STR     r1,[r2,#8]               ; move free to free_low
        STR     r6,[r2,#16]              ; move used to used_low
        MOV     r0,#0
        STR     r0,[r2,#4]
        STR     r0,[r2,#12]
        STR     r0,[r2,#20]              ; zero the high words

09
   [ fix_silly_sizes
        ; R0, R1, R6, R7 Corruptable
        LDMIA   r2, {r0,r1,r6,r7}        ; r0=size.l, r1=size.h, r6=free.l, r7=free.h
        ; check free size
        CMP     r7,r1
        CMPEQ   r6,r0                    ; Free > Size ::= fault
        MOVHI   r7,#-1
        STRHI   r7,[r2,#12]
        STRHI   r7,[r2,#8]

        ; check used size
        ADD     r6,r2,#16
        LDMIA   r6, {r6,r7}              ; r6=used.l, r6=used.h
        CMP     r7,r1
        CMPEQ   r6,r0                    ; Used > Size ::= fault
        MOVHI   r7,#-1
        STRHI   r7,[r2,#20]
        STRHI   r7,[r2,#16]
   |
        LDMIA   r2, {r0,r1}              ; r0=size.l, r1=size.h
   ]
        ADD     lr,r5,#window_size_lo
        LDMIA   lr,{r6,r7}
        CMP     r7,r1
        CMPEQ   r6,r0
        BEQ     %FT01                    ; Size unchanged

        STR     r13,[r5,#no_change]      ; set the flag to indicate that the textual fields need rewriting

        LDR     r0,[r2,#4]               ; Size high
        LDR     r1,[r5,#window_size_hi]
        ;r0 =new_size_high, r1=old_size_high

        STR     r0,[r5,#window_size_hi]  ; store size high in window block

        ;r7 =new_size_low, r6=old_size_low

        LDR     r6,[r5,#window_size_lo]
        LDR     r7,[r2,#0]
        STR     r7,[r5,#window_size_lo]  ; and size low

        ;r8 = size_low, r2 = size_high

        LDR     r8,[r2,#0]

        LDR     r2,[r2,#4]

        ;r0 new size high
        ;r1 old size high
        ;r2 size high
        ;r6 old size low
        ;r7 new size low
        ;r8 size low

        MOV     r3,#icon_SizeBar
        BL      set_bar
        Pull    "PC",VS

        LDR     r0,[r5,#window_size_lo]
        LDR     r1,[r5,#window_size_hi]
        BL      create_size_word
        STR     r0,[r5,#size_ascii]

        ; the actual call to set_text is saved until later now

01
        ADR     r2,dataarea
        LDR     r0,[r2,#8]               ; Free
        LDR     r1,[r5,#window_free_lo]
        CMP     r0,r1
        BNE     %FT02
        LDR     r0,[r2,#12]
        LDR     r1,[r5,#window_free_hi]
        CMP     r0,r1
        BEQ     %FT01                    ; Size Unchanged.
02
        STR     r13,[r5,#no_change]     ; set flag to indicate the ascii fields need reconsidering

        LDR     r0,[r2,#12]
        LDR     r1,[r5,#window_free_hi]
        ;r0=new_free_hi, r1=old_free_hi

        STR     r0,[r5,#window_free_hi]

        ;r7=new_free_lo, r6=old_free_lo

        LDR     r6,[r5,#window_free_lo]
        LDR     r7,[r2,#8]
        STR     r7,[r5,#window_free_lo]

        ;r8=size_lo, r2=size_hi

        LDR     r8,[r2,#0]
        LDR     r2,[r2,#4]

        ;r0 new free high
        ;r1 old free high
        ;r2 size high
        ;r6 old free low
        ;r7 new free low
        ;r8 size low

        MOV     r3,#icon_FreeBar
        BL      set_bar                  ; r0 - New size  r1 - Old size r2 - Total size , r3 - icon number.
        Pull    "PC",VS

        LDR     r0,[r5,#window_free_lo]
        LDR     r1,[r5,#window_free_hi]
        BL      create_size_word
        STR     r0,[r5,#free_ascii]

01
        ADR     r2,dataarea
        LDR     r0,[r2,#16]               ; Used
        LDR     r1,[r5,#window_used_lo]
        CMP     r0,r1
        BNE     %FT02
        LDR     r0,[r2,#20]
        LDR     r1,[r5,#window_used_hi]
        CMP     r0,r1
        BEQ     %FT01                    ; Size Unchanged.
02
        STR     r13,[r5,#no_change]      ; set flag to indicate that ascii values need fixing

        LDR     r0,[r2,#20]
        LDR     r1,[r5,#window_used_hi]

        ;r0=new_used_hi, r1=old_used_hi

        STR     r0,[r5,#window_used_hi]

        ;r7=new_used_lo, r6=old_free_lo

        LDR     r6,[r5,#window_used_lo]
        LDR     r7,[r2,#16]
        STR     r7,[r5,#window_used_lo]

        ;r8=size_lo, r2=size_hi

        LDR     r8,[r2,#0]
        LDR     r2,[r2,#4]

        ;r0 new used high
        ;r1 old used high
        ;r2 size high
        ;r6 old used low
        ;r7 new used low
        ;r8 size low

        MOV     r3,#icon_UsedBar
        BL      set_bar                  ; r0 - New size  r1 - Old size r2 - Total size , r3 - icon number.
        Pull    "PC",VS

        LDR     r0,[r5,#window_used_lo]
        LDR     r1,[r5,#window_used_hi]
        BL      create_size_word
        STR     r0,[r5,#used_ascii]

01
        LDR     r0,[r5,#no_change]
        TEQ     r0,#0
        BEQ     %FT02

        ; we do need to check, round, and then update the ascii fields

        ; (check the three values are all of the same magnitude, if so, apply rounding)
        ; then call modified set_text for each one...


        ; check whether all three are the same units
        LDR     r0,[r5,#used_ascii]
        LDR     r1,[r5,#free_ascii]
        LDR     r2,[r5,#size_ascii]

        MOV     lr,r0,LSR #24
        CMP     lr,r1,LSR #24
        CMPEQ   lr,r2,LSR #24
        BNE     %FT02

        ; When all the same units, include a safety check in case it doesn't
        ; add up due to rounding errors, most notably when used+free=size-1
        ; Errors of >1 of the unit are assumed to be deliberate (eg user free space
        ; being less than available free space on whole disc etc)
        SUB     r1,r2,r0
        ORR     r1,r1,lr,LSL #24
        LDR     r0,[r5,#free_ascii]
        SUB     r0,r1,r0                 ; r0 := size-used-free
        CMP     r0,#2
        STRLT   r1,[r5,#free_ascii]      ; out by one so override
02
        LDR     r0,[r5,#used_ascii]
        MOV     r3,#icon_Used
        BL      set_text

        LDR     r0,[r5,#free_ascii]
        MOV     r3,#icon_Free
        BL      set_text

        LDR     r0,[r5,#size_ascii]
        MOV     r3,#icon_Size
        BL      set_text
02
        B       updatelp

;------------------------------------------------------------------------------
; Entry r0 = value (low)
;       r1 = value (high)
;
; Exit  r0 = coded value - top byte is the ASCII character for that size, remaining bytes are
;            the size in those units.
;       r1 = corrupted

create_size_word ROUT
  [ fix_silly_sizes
        CMP     r0,#-1
        CMPEQ   r1,#-1
        MOVEQ   r0,#"?":SHL:24
        MOVEQ   pc, lr                  ; it's a silly size, mark as such
  ]
        Push    "r10,lr"

        MOV     r10, #0                 ; SI unit index
20
        CMP     r1, #1
        CMPCC   r0, #4096               ; Keep dividing until < 4096
        BCC     %FT30
        MOV     r14, r1, LSL #22
        MOV     r1, r1, LSR #10
        MOVS    r0, r0, LSR #10
        ORR     r0, r14, r0
        ADCS    r0, r0, #0              ; Round up lost bit
        ADC     r1, r1, #0
        ADD     r10, r10, #1            ; Next 10^3 up
        B       %BT20
30
        ADR     r14,create_prefixes
        LDRB    r14,[r14,r10]
        ORR     r0,r0,r14,LSL #24       ; Compact representation

        Pull    "r10,pc"

create_prefixes
        DCB     " kMGTPE"               ; units/kilo/mega/giga/tera/peta/exa
        ALIGN

;------------------------------------------------------------------------------
; set_bar
; set bar size.
; Entry:
;       r0 - New   wotsit high
;       r1 - Old   wotsit high
;       r2 - Total size high
;       r3 - Icon number
;       [r5] - window block.
;       r6 - Old   wotsit low
;       r7 - New   wotsit low
;       r8 - Total size low
set_bar ROUT

        ;r9,r10,r11 are working registers for the sums
        Push   "r0-r11,LR"

        ;amg: On closer inspection this actually does not use the old size at all!

        ;calc is new_wotsit * bar_length, then divide by total_size
        ;        r0:r7                                   r2:r8
        ;result in r4
        ;save r3,r5, can trash r9-r11 and r1/r6

        ;first a check for divide by zero
        MOV     r4, r2
        ORRS    r4, r4, r8
        BEQ     %FT50                   ; so take zero as the result

        MOV     r9,#0
        LDR     r10,full_bar

        mextralong_multiply r11,r1,r10,r9,r7,r0
        mextralong_divide r4,r9,r11,r1,r8,r2,r10,r6,r0

        ;ok r4 is the result, and r9 has the top bits (must be zero!)

        LDR    r10,full_bar             ; now a safety check to determine whether the bar is too long
        CMP    r4,r10                   ; (eg for nfs where the used space can exceed the total space
        MOVGT  r4,r10                   ; because of soft and hard limits to partition size)
50
        ADR    r1,dataarea+40
        LDR    r0,[r5,#window_handle]
        STR    r0,[r1]
        STR    r3,[r1,#4]
        SWI    XWimp_GetIconState
        ADDVS  sp,sp,#4
        Pull   "r1-r11,PC",VS

        ADR    r1,dataarea+40
        LDR    r6,[r1,#8+8]      ; Old x1.
        LDR    r14,[r1,#8]       ; x0
        ADD    r14,r14,r4        ; New x1
        STR    r14,[r1,#8+8]     ; Store it.

        Debug  xx,"delete icon"


        SWI    XWimp_DeleteIcon  ; Delete icon.
        ADDVS  sp,sp,#4
        Pull   "r1-r11,PC",VS

        Debug  xx,"create icon"

        ADR    r1,dataarea+44
        LDR    r0,[r5,#window_handle]
        STR    r0,[r1]
        SWI    XWimp_CreateIcon
        ADDVS  sp,sp,#4
        Pull   "r1-r11,PC",VS

        Debug  xx,"force redraw"

        LDR    r0,[r5,#window_handle]
        LDR    r2,[r1,#8]        ; Min y.
        LDR    r4,[r1,#16]       ; Max y.
        CMP    r6,r14
        MOVLE  r1,r6
        MOVLE  r3,r14
        MOVGT  r1,r14
        MOVGT  r3,r6
        SUB    r1,r1,#4
        SWI    XWimp_ForceRedraw
        ADDVS  sp,sp,#4
        Pull   "r1-r11,PC",VS

        Debug  xx,"Set bar returns"

        Pull   "r0-r11,PC"

;------------------------------------------------------------------------------
; set_text
;
; r0 - Size in coded form (top byte = ascii character for power, rest is value at that exponent)
; r3 - Icon number
; [r5] - window block.
set_text
        Push    "r0-r4,r6,LR"

        ADR     r1,dataarea+20
        LDR     r14,[r5,#window_handle]
        STR     r14,[r1,#gi_handle]
        STR     r3,[r1,#gi_iconhandle]
        SWI     XWimp_GetIconState
        ADDVS   sp,sp,#4
        Pull    "r1-r4,r6,PC",VS
                                     
        LDR     r1,[r1,#gi_iconblock+i_data+ii_buffer]  ; Get pointer to buffer
        Debug   xx,"Got state"       

        LDR     r0, [sp]               ; recover r0 after Wimp corrupted it
        MOV     r4,r0,LSR #24

   [ fix_silly_sizes
        TEQ     r4,#"?"
        STREQB  r4,[r1],#1
        MOVEQ   r4,#" "
        STREQB  r4,[r1],#1
        BEQ     %FT33
   ]

        MOV     r2,#20
        SWI     XOS_ConvertCardinal2
        ADDVS   sp,sp,#4
        Pull    "r1-r4,r6,PC",VS

        Debug   xx,"Converted number"

        MOV     r2,#' '
        STRB    r2,[r1],#1             ; Space
        TEQ     r4,#' '
        STRNEB  r4,[r1],#1             ; Power of 10
33
        ADR     r4,message_bytes       ; 'bytes' and a null
        MOV     r0,r1
        BL      copy_r0r4_null

        ADR     r1,dataarea+20
        ASSERT  (si_handle=gi_handle):LAND:(si_iconhandle=gi_iconhandle)
        MOV     r0,#0
        STR     r0,[r1,#si_eorword]
        STR     r0,[r1,#si_clearword]
        SWI     XWimp_SetIconState

        Debug   xx,"Set state, returning."

        Pull    "r0-r4,r6,PC"

;------------------------------------------------------------------------------
; CallEntry - Call the FS entry by the FS number in r1.
;
CallEntry
        Push    "r5,LR"

        Debug   xx,"Call entry"

        ADR     r5,fs_list
01
        LDR     r5,[r5,#fs_next]
        CMP     r5,#0
        ADREQL  r0,ErrorBlock_UnknownFileSystem
        MOVEQ   r1,#0
        BLEQ    LookupError
        Pull    "r5,PC",VS

        Debug   xx,"Known FS"

        LDR     r14,[r5,#fs_number]
        CMP     r14,r1
        BNE     %BT01

        MOV     r14,r5
        Pull    "r5"
        Push    "r12"
        LDR     R12,[r14,#fs_r12]
        Push    "PC"
        LDR     PC,[r14,#fs_entry]        ; Get entry point
        NOP
        Pull    "r12"
        Pull    "PC"
;------------------------------------------------------------------------------
; AddEntry - Add the FS entry in r0 for the FS number in r1 to the list.
;
AddEntry
        Push    "r0-r6,LR"

        MOV     r4,r1
        MOV     r5,r0
        MOV     r6,r2

        MOV     r3,#fs_block_size
        MOV     r0,#ModHandReason_Claim
        SWI     XOS_Module          ; Claim block.
        ADDVS   sp,sp,#4
        Pull    "r1-r5,PC",VS

        LDR     r0,fs_list
        STR     r0,[r2,#fs_next]
        CMP     r0,#0
        STRNE   r2,[r0,#fs_prev]
        MOV     r0,#0
        STR     r0,[r2,#fs_prev]
        STR     r2,fs_list          ; Linked to list

        STR     r4,[r2,#fs_number]
        STR     r5,[r2,#fs_entry]
        STR     r6,[r2,#fs_r12]

        Debug   xx,"Added entry for FS #",r4

        Pull    "r0-r6,PC"

RemoveEntry     ROUT
        Push    "r0-r6,LR"

        LDR     r4,fs_list
01
        CMP     r4,#0
        Pull    "r0-r6,PC",EQ       ; Not found.

        LDR     r14,[r4,#fs_number]
        TEQ     r14,r0
        LDREQ   r14,[r4,#fs_entry]
        TEQEQ   r14,r1
        LDREQ   r14,[r4,#fs_r12]
        TEQEQ   r14,r2
        LDRNE   r4,[r4,#fs_next]
        BNE     %BT01

        LDR     r5,[r4,#fs_prev]
        LDR     r6,[r4,#fs_next]
        CMP     r5,#0
        STRNE   r6,[r5,#fs_next]
        STREQ   r6,fs_list
        CMP     r6,#0
        STRNE   r5,[r6,#fs_prev]

        MOV     r0,#ModHandReason_Free
        MOV     r2,r4
        SWI     XOS_Module
        STRVS   r0,[sp]
        Pull    "r0-r6,PC"

        LNK     Messages.s
@


4.7
log
@Change text formatting to be a single right justified (internationalised) icon.
Delete Doc.doc duplication.
Delete Template2D.
Excess headers removed.
Out of range SWIs returned error 0.
Some symbolic names from ModHand, HighFSI, WimpSpace used.
Fix corrupt error message in set_text due to misplaced Pull.
Uses k for thousands not Kelvins.

Version 0.40. Tagged as 'Free-0_40'
@
text
@a248 5
FreeReason_Noop        *  0
FreeReason_GetName     *  1
FreeReason_GetSpace    *  2
FreeReason_ComparePath *  3
FreeReason_GetSpace64  *  4
@


4.6
log
@No longer opens its windows overlapping with the icon bar.

Version 0.39. Tagged as 'Free-0_39'
@
text
@d17 1
a17 1
; ----------------------------------------------------------------------------------------------------------------------
a19 1
tasktitle       DCB     "Title",0
d21 2
a22 1
; ----------------------------------------------------------------------------------------------------------------------
d45 7
a51 7
; ----------------------------------------------------------------------------------------------------------------------
template_filename
        DCB     "Free:Templates",0
        ALIGN
window_name
        DCB     "Free",0
        ALIGN
d53 2
a54 5
        ALIGN
ADFSFree        DCB     "Alias$ADFS_Free"
                DCB     0
FreeString      DCB     "ShowFree -FS ADFS %*0"
                DCB     0
d59 1
a59 1
; ----------------------------------------------------------------------------------------------------------------------
d79 9
a87 1
        ADRL    r0,tasktitle
d103 1
a103 1
        ADR     r1, template_filename   ; Load in the templates
d111 1
a111 1
        ADD     r3, r2, #indirected_space
d137 1
a137 1
; ----------------------------------------------------------------------------------------------------------------------
d142 1
a142 1
        ADRL    R0,tasktitle
d180 1
a180 1
        B       update_windows          ; 13 poll word non-zero
d189 1
a189 1
; ----------------------------------------------------------------------------------------------------------------------
d191 2
a192 2
       SWI      Wimp_OpenWindow
       MOV      PC,LR
d194 1
a194 1
; ----------------------------------------------------------------------------------------------------------------------
d230 1
a230 1
        MOV     r0,#7
d236 1
a236 1
        MOV     r0,#7
d239 1
a239 1
        EXIT
d245 3
a247 3
; ----------------------------------------------------------------------------------------------------------------------
; This is called when the poll word is non-zero, it scans the window list to find out which windows
; are to be updated, and updates them.
d249 1
d289 1
a289 1
        MOV     r0,#6
d324 1
a324 1
        MOV     r0,#"?" << 24
d450 1
a450 1
     ; R0, R1, R6, R7 Corruptable
d452 1
a452 1
     ; check free size
d459 1
a459 1
     ; check used size
d612 1
a612 1
        ;we do need to check, round, and then update the ascii fields
d614 2
a615 2
        ;(check the three values are all of the same magnitude, if so, apply rounding)
        ;then call modified set_text for each one...
d618 1
a618 1
        ;check whether all three are the same units
d628 4
a631 1
        ;ok, same units, replace free with size-used
a633 3
        ;and include a safety check in case it doesn't add up for a reason
        ;errors of >1 of the unit are assumed to be deliberate (eg user free space
        ;being less than available free space on whole disc etc)
d635 1
a635 1
        SUB     r0,r1,r0                  ; classic error is that used+free = size - 1 due to rounding error
d637 1
a637 1
        STRLT   r1,[r5,#free_ascii]
d653 1
a653 1
;--------------------------------------------------------------------------------------------------------------
d661 1
a661 2
create_size_word
        STMFD   r13!,{lr}
d666 1
a666 1
        BEQ     %FT04         ; it's a silly size, mark as such
d668 1
a668 2
        TEQ     r1,#0
        BNE     %FT01         ;value is M, G or TBytes
d670 17
a686 10
        MOV     lr,#" "
        CMP     r0,#&1000
        MOVCS   lr,#"K"
        MOVCSS  r0,r0,LSR #10
        ADC     r0,r0,#0
        CMP     r0,#&1000
        MOVCS   lr,#"M"
        MOVCSS  r0,r0,LSR #10
        ADC     r0,r0,#0
        B       %FT02
d688 5
a692 31
01
        ;gigabytes are messy cos they're split across the two words...
        CMP     r1,#&100
        BCS     %FT03

        MOV     lr,#"G"
        MOVS    r0,r0,LSR #30
        ORR     r0,r0,r1,LSL #2
        ADC     r0,r0,#0

        B       %FT02

03      ;it is a T/Q byte value
        MOV     lr,#"T"
        MOVS    r0,r1,LSR #8
        ADC     r0,r0,#0

        CMP     r0,#&1000
        MOVCS   lr,#"P"
        MOVCSS  r0,r0,LSR #10
        ADC     r0,r0,#0

        CMP     r0,#&1000
        MOVCS   lr,#"E"
        MOVCSS  r0,r0,LSR #10
        ADC     r0,r0,#0

02      BIC     r0,r0,#255:SHL:24
        ORR     r0,r0,lr,LSL #24
04
        LDMFD   r13!,{pc}
d694 1
a694 1
;--------------------------------------------------------------------------------------------------------------
d741 1
a741 1
        Pull   "r1-r8,PC",VS
d784 1
a784 1
;--------------------------------------------------------------------------------------------------------
d791 1
a791 1
        Push  "r0-r5,LR"
d793 12
a805 18
        BIC     r0,r0,#&FF000000

        Push  "r0"

        ADR   r1,dataarea+20
        LDR   r14,[r5,#window_handle]
        STR   r14,[r1]
        STR   r3,[r1,#4]
        SWI   XWimp_GetIconState
        Pull  "r0"
        ADDVS sp,sp,#4
        Pull  "r1-r5,PC",VS

        Debug xx,"Got state"

        Debug xx,"New size ",r0

        LDR   r1,[r1,#28]            ; Get pointer to buffer
d808 5
a812 5
        TEQ   r4,#"?"
        STREQB r4,[r1],#1
        MOVEQ r4,#" "
        STREQB r4,[r1],#1
        BEQ   %33
d815 4
a818 4
        MOV   r2,#20
        SWI   XOS_ConvertCardinal4
        ADDVS sp,sp,#4
        Pull  "r1-r5,PC",VS
d820 1
a820 1
        Debug xx,"Converted number"
d822 4
a825 1
        STRB  r4,[r1],#1
d827 3
a829 2
        MOV   r0,#0
        STRB  r0,[r1]
d831 6
d838 1
a838 6
        ADR   r1,dataarea+20
        STR   r0,[r1,#8]
        STR   r0,[r1,#12]
        SWI   XWimp_SetIconState

        Debug xx,"Set state, returning."
d840 1
a840 1
        Pull  "r0-r5,PC"
d842 2
a843 2
;--------------------------------------------------------------------------------------------------------
; CallEntry - Call th FS entry by the FS number in r1.
d874 1
a874 1
;--------------------------------------------------------------------------------------------------------
d885 1
a885 1
        MOV     r0,#6
@


4.5
log
@Free tweaked to round to nearest.
Fix for desktop free blowing up on 32 bit systems when the filing
system vanishes (eg.a RAM disc going to 0 size).

Version 0.38. Tagged as 'Free-0_38'
@
text
@d343 9
@


4.4
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.36. Tagged as 'Free-0_36'
@
text
@d361 1
d363 6
a368 6
        ADRNE   r1,dataarea
        LDRNE   r0,[r5,#window_handle]
        STRNE   r0,[r1]
        LDRNE   r5,[r5,#next_ptr]
        BLNE    close_window
        BNE     updatelp1
d370 1
a370 1
        TST     r0,#1 :SHL: 31
d425 3
a427 4
        LDR     r0,[r2,#8]
        STR     r0,[r2,#16]              ; move used to used_low
        LDR     r0,[r2,#4]
        STR     r0,[r2,#8]               ; move free to free_low
d436 1
a436 2
        LDR     r0,[r2,#4]               ; Size high
        LDR     r1,[r2,#0]               ; Size low
a437 5
        LDR     r6,[r2,#12]              ; Free high
        LDR     r7,[r2,#8]               ; Free low
        CMP     r6,r0
        BLO     %FT03                    ; Free < Size ::= ok
        BHI     %FT04                    ; Free > Size ::= fault
d439 4
a442 6
        BLS     %FT03                    ; Free >= Size ::= ok
04 ; free fault
        MOV     r7,#-1
        STR     r7,[r2,#12]
        STR     r7,[r2,#8]
03 ; free ok
d445 2
a446 8
        LDR     r6,[r2,#20]              ; Used high
        LDR     r7,[r2,#16]              ; Used low
        TEQ     r7,#0
        TEQEQ   r6,#0
        BEQ     %FT04
        CMP     r6,r0
        BLO     %FT03                    ; Used < Size ::= ok
        BHI     %FT04                    ; Used > Size ::= fault
d448 6
a453 6
        BLS     %FT03                    ; Used >= Size ::= ok
04 ; used fault
        MOV     r7,#-1
        STR     r7,[r2,#20]
        STR     r7,[r2,#16]
03 ; used ok
d455 6
a460 9
        LDR     r0,[r2,#0]               ; Size low
        LDR     r1,[r5,#window_size_lo]
        CMP     r0,r1
        BNE     %FT02
        LDR     r0,[r2,#4]               ; Size high
        LDR     r1,[r5,#window_size_hi]
        CMP     r0,r1
        BEQ     %FT01                    ; Size Unchanged.
02
d610 1
a610 2
        BNE     %FT02
        CMP     lr,r2,LSR #24
d651 2
a652 3
        MOVEQ   r0,#0
        MOVEQ   lr,#"?"
        BEQ     %FT02         ; it's a silly size, mark as such
d659 3
a661 2
        MOVHI   r0,r0,LSR #10
        MOVHI   lr,#"K"
d663 3
a665 2
        MOVHI   r0,r0,LSR #10
        MOVHI   lr,#"M"
a668 2
        MOV     lr,#"G"

d671 1
a671 1
        BHI     %FT03
d673 2
a674 1
        MOV     r0,r0,LSR #30
d676 1
d682 2
a683 1
        MOV     r0,r1,LSR #8
d686 3
a688 2
        MOVGT   r0,r0,LSR #10
        MOVGT   lr,#"P"
d691 7
a697 6
        MOVGT   r0,r0,LSR #10
        MOVGT   lr,#"E"

02      BIC     r0,r0,#255<<24
        ORR     r0,r0,r14,LSL #24

@


4.3
log
@  32-bit compatibility.
Detail:
  Module is 32-bit compatible
  Documentation updated to note that entry point is now called in SVC32.
Admin:
  Tested briefly on Ursula build.

Version 0.34. Tagged as 'Free-0_34'
@
text
@d324 1
a324 1
     [ Version >= 2                ; Centre window on mouse pointer
a346 1
     ]
d958 1
a958 1
        LNK     s.Messages
@


4.2
log
@Merged stack screwup bug fix from ROL branch.
Merged Ursula service call table from ROL branch + added assertions.
Merged 4096B -> 4T bug fix from ROL branch.

Version 0.33. Tagged as 'Free-0_33'
@
text
@d39 1
a39 1
        Push    "r0,lr"
d43 1
a43 1
        Pull    "r0,pc",,^
a58 1
      [ Version >= 5
a60 1
      ]
d78 1
a78 1
        SWINE   OS_GenerateError
d87 1
a87 6
      [ Version >= 5
        MOV     r0,#300                 ; We know about wimp 3.00 and have a messages list
      |
        LDR     r3, =278                ; latest known Wimp version number
        MOV     r0, r3                  ; latest known Wimp version number
      ]
a88 1
      [ Version >= 5
a89 1
      ]
d91 1
a91 3
      [ Version >= 5
        LDR     r3, =278                ; Wimp version number that we want.
      ]
a131 13
      [ Version < 9

; Set ASFS alias.

        ADR     R0, ADFSFree
        ADR     R1, FreeString
        MOV     R2, #?FreeString
        MOV     R3, #0
        MOV     R4, #VarType_String
        SWI     XOS_SetVarVal

      ]

d191 1
a191 1
        Push    "r1-r5,LR"
d199 1
a199 1
        Push    "r1-r5,LR"
d207 1
a207 1
        Pull    "r1-r5,PC",EQ
d227 1
a227 1
        Pull    "r1-r5,PC",VS
d234 1
a234 1
        Pull    "r1-r5,PC",VS
d238 1
a238 1
        Pull    "r1-r5,PC",,^
a411 11
        ; fix bug MED-04392. Instead of treating an error from this as fatal, we ignore
        ; it and try the 32-bit version of the call instead. That way those clients who
        ; return an error from unknown reason codes will still work, and real errors will
        ; just have to be returned twice to be believed


        ; Push    "r0",VS
        ; BLVS    close_window_from_block
        ; Pull    "r0",VS
        ; Pull    "PC",VS

d421 1
a421 2
        Pull    "r0",VS
        Pull    "PC",VS
@


4.1
log
@Initial revision
@
text
@d37 1
a37 1
CloseWimp     
d66 1
a66 1
Start                    
d88 1
a88 1
      
d112 1
a112 1
        SWIVS   OS_GenerateError  
d126 1
a126 1
                                  
d158 1
a158 1
repollwimp         
d161 1
a161 1
        ADRL    R0,tasktitle    
d164 1
a164 1
        ADDVS   sp,sp,#4   
d168 1
a168 1
        SWI     XWimp_ReportError               
d172 2
a173 2
; Call Wimp_Poll. 
        MOV     R0, #&31    
d209 1
a209 1
open_window     
d223 1
a223 1
        Push    "r1-r5,LR"      
d226 1
a226 1
        
d228 1
a228 1
01      
d290 1
a290 1
        
d301 1
a301 1
        Debug   xx,"New window"  
d309 7
a315 9
        STRVS   r0,[sp]
        Pull    "r0,PC",VS            
                             
        ADRL    r0,title_prefix         
        LDR     r4,[r5,#window_device] 
        BL      Lookup 
        ADDVS   SP,SP,#4
        Pull    "PC",VS  
        ADD     r3,r3,#1       
d319 1
a319 1
        ADR     r1,windowarea+72   ; Point at title data 
d327 1
a327 1
        STR     r2,[r1,#20+icon_Size :SHL: icon_shift] 
d329 1
a329 1
        STR     r2,[r1,#20+icon_Free :SHL: icon_shift] 
d331 2
a332 2
        STR     r2,[r1,#20+icon_Used :SHL: icon_shift] 
 
d341 6
d361 1
a361 1
        
d386 1
a386 1
        
d402 1
a402 1
        ADR     r1,dataarea 
d406 1
a406 1
        ADR     r1,dataarea 
d411 1
a411 1
                                     
d414 1
a414 1
01               
d418 1
a418 1
        
d429 1
a429 1
        
d435 1
a435 1
        
d440 1
a440 1
        
d445 2
a446 2
        ; Pull    "PC",VS                 
        
d448 1
a448 1
        
d457 2
a458 2
        Pull    "PC",VS                 
        
d460 1
a460 1
        
d470 37
a506 2
09                  
        LDR     r0,[r2,#0]               ; Size low        
d508 1
a508 1
        CMP     r0,r1                    
d516 1
a516 1
                                                                           
d520 1
a520 1
        
d522 1
a522 1
        
d528 1
a528 1
                          
d530 3
a532 3
        
        LDR     r8,[r2,#0]            
        
d534 1
a534 1
        
d540 3
a542 3
        ;r8 size low           
        
        MOV     r3,#icon_SizeBar         
d550 1
a550 1
        
d556 1
a556 1
        LDR     r1,[r5,#window_free_lo]             
d570 2
a571 2
        STR     r0,[r5,#window_free_hi]   
        
d573 2
a574 2
        
        LDR     r6,[r5,#window_free_lo] 
d576 2
a577 2
        STR     r7,[r5,#window_free_lo]  
        
d579 1
a579 1
        
d589 2
a590 2
        
        MOV     r3,#icon_FreeBar         
d610 1
a610 1
        STR     r13,[r5,#no_change]      ; set flag to indicate that ascii values need fixing  
d614 1
a614 1
        
d618 3
a620 3
        
        ;r7=new_used_lo, r6=old_free_lo  
        
d624 1
a624 1
        
d626 1
a626 1
        
d637 1
a637 1
        MOV     r3,#icon_UsedBar         
d639 2
a640 2
        Pull    "PC",VS      
        
d645 1
a645 1
        
d652 1
a652 1
        
d661 1
a661 1
        
d667 1
a667 1
        
d675 1
a675 1
        SUB     r0,r1,r0                  ; classic error is that used+free = size - 1 due to rounding error 
d691 2
a692 2
        B       updatelp   
        
d696 1
a696 1
;   
d703 7
a709 1
                                                     
d712 1
a712 1
        
d724 1
a724 1
        
d727 2
a728 2
        BCS     %FT03          
        
d730 2
a731 2
        ORR     r0,r0,r1,LSL #2    
        
d733 2
a734 2
        
03      ;it is a T/Q byte value  
d736 2
a737 2
        MOV     r0,r1,LSR #8    
        
d741 2
a742 2
        
        CMP     r0,#&1000 
d746 2
a747 1
02      ORR     r0,r0,r14,LSL #24
d763 1
a763 1
set_bar ROUT          
d766 2
a767 2
        Push   "r0-r11,LR"          
        
d769 1
a769 1
        
d772 1
a772 1
        ;result in r4 
d774 1
a774 1
        
d779 1
a779 1
        
d782 1
a782 1
        
d785 3
a787 3
        
        ;ok r4 is the result, and r9 has the top bits (must be zero!)  
        
d831 1
a831 1
        MOVGT  r3,r6  
d848 2
a849 2
        Push  "r0-r5,LR" 
        
d852 2
a853 2
            
        Push  "r0" 
d859 1
a859 1
        SWI   XWimp_GetIconState   
d864 1
a864 1
        Debug xx,"Got state"        
d866 1
a866 1
        Debug   xx,"New size ",r0
d869 9
d883 1
a883 1
        Debug xx,"Converted number"        
d886 1
d890 1
d896 1
a896 1
        Debug xx,"Set state, returning."        
d907 1
a907 1
       
d922 1
a922 1
                   
d936 1
a936 1
        Push    "r0-r6,LR"  
d939 1
a939 1
        MOV     r5,r0 
d943 1
a943 1
        MOV     r0,#6     
d957 1
a957 1
        STR     r5,[r2,#fs_entry]   
d971 1
a971 1
        
d977 1
a977 1
        TEQEQ   r14,r2    
d988 1
a988 1
        
@


4.1.10.1
log
@Commit of third party version of Desktop Free.

Contains bug fix to stop R15 being loaded with a random value in some
  circumstances.
Contains traps for silly space sizes that are obviously incorrect.
Displays 4096G instead of 4T.
Ursula service call handler added.
@
text
@d37 1
a37 1
CloseWimp
d66 1
a66 1
Start
d88 1
a88 1

d112 1
a112 1
        SWIVS   OS_GenerateError
d126 1
a126 1

d158 1
a158 1
repollwimp
d161 1
a161 1
        ADRL    R0,tasktitle
d164 1
a164 1
        ADDVS   sp,sp,#4
d168 1
a168 1
        SWI     XWimp_ReportError
d172 2
a173 2
; Call Wimp_Poll.
        MOV     R0, #&31
d209 1
a209 1
open_window
d223 1
a223 1
        Push    "r1-r5,LR"
d226 1
a226 1

d228 1
a228 1
01
d290 1
a290 1

d301 1
a301 1
        Debug   xx,"New window"
d309 9
a317 7
        Pull    "PC",VS

        ADRL    r0,title_prefix
        LDR     r4,[r5,#window_device]
        BL      Lookup
        Pull    "PC",VS
        ADD     r3,r3,#1
d321 1
a321 1
        ADR     r1,windowarea+72   ; Point at title data
d329 1
a329 1
        STR     r2,[r1,#20+icon_Size :SHL: icon_shift]
d331 1
a331 1
        STR     r2,[r1,#20+icon_Free :SHL: icon_shift]
d333 2
a334 2
        STR     r2,[r1,#20+icon_Used :SHL: icon_shift]

a342 6
  [ fix_silly_sizes
        MOV     r0,#"?" << 24
        STR     r0,[r5,#used_ascii]
        STR     r0,[r5,#free_ascii]
        STR     r0,[r5,#size_ascii]
  ]
d357 1
a357 1

d382 1
a382 1

d398 1
a398 1
        ADR     r1,dataarea
d402 1
a402 1
        ADR     r1,dataarea
d407 1
a407 1

d410 1
a410 1
01
d414 1
a414 1

d425 1
a425 1

d431 1
a431 1

d436 1
a436 1

d441 2
a442 2
        ; Pull    "PC",VS

d444 1
a444 1

d453 2
a454 2
        Pull    "PC",VS

d456 1
a456 1

d466 2
a467 37
09
   [ fix_silly_sizes
     ; R0, R1, R6, R7 Corruptable
        LDR     r0,[r2,#4]               ; Size high
        LDR     r1,[r2,#0]               ; Size low
     ; check free size
        LDR     r6,[r2,#12]              ; Free high
        LDR     r7,[r2,#8]               ; Free low
        CMP     r6,r0
        BLO     %FT03                    ; Free < Size ::= ok
        BHI     %FT04                    ; Free > Size ::= fault
        CMP     r7,r1
        BLS     %FT03                    ; Free >= Size ::= ok
04 ; free fault
        MOV     r7,#-1
        STR     r7,[r2,#12]
        STR     r7,[r2,#8]
03 ; free ok

     ; check used size
        LDR     r6,[r2,#20]              ; Used high
        LDR     r7,[r2,#16]              ; Used low
        TEQ     r7,#0
        TEQEQ   r6,#0
        BEQ     %FT04
        CMP     r6,r0
        BLO     %FT03                    ; Used < Size ::= ok
        BHI     %FT04                    ; Used > Size ::= fault
        CMP     r7,r1
        BLS     %FT03                    ; Used >= Size ::= ok
04 ; used fault
        MOV     r7,#-1
        STR     r7,[r2,#20]
        STR     r7,[r2,#16]
03 ; used ok
   ]
        LDR     r0,[r2,#0]               ; Size low
d469 1
a469 1
        CMP     r0,r1
d477 1
a477 1

d481 1
a481 1

d483 1
a483 1

d489 1
a489 1

d491 3
a493 3

        LDR     r8,[r2,#0]

d495 1
a495 1

d501 3
a503 3
        ;r8 size low

        MOV     r3,#icon_SizeBar
d511 1
a511 1

d517 1
a517 1
        LDR     r1,[r5,#window_free_lo]
d531 2
a532 2
        STR     r0,[r5,#window_free_hi]

d534 2
a535 2

        LDR     r6,[r5,#window_free_lo]
d537 2
a538 2
        STR     r7,[r5,#window_free_lo]

d540 1
a540 1

d550 2
a551 2

        MOV     r3,#icon_FreeBar
d571 1
a571 1
        STR     r13,[r5,#no_change]      ; set flag to indicate that ascii values need fixing
d575 1
a575 1

d579 3
a581 3

        ;r7=new_used_lo, r6=old_free_lo

d585 1
a585 1

d587 1
a587 1

d598 1
a598 1
        MOV     r3,#icon_UsedBar
d600 2
a601 2
        Pull    "PC",VS

d606 1
a606 1

d613 1
a613 1

d622 1
a622 1

d628 1
a628 1

d636 1
a636 1
        SUB     r0,r1,r0                  ; classic error is that used+free = size - 1 due to rounding error
d652 2
a653 2
        B       updatelp

d657 1
a657 1
;
d664 1
a664 7
  [ fix_silly_sizes
        CMP     r0,#-1
        CMPEQ   r1,#-1
        MOVEQ   r0,#0
        MOVEQ   lr,#"?"
        BEQ     %FT02         ; it's a silly size, mark as such
  ]
d667 1
a667 1

d679 1
a679 1

d682 2
a683 2
        BHI     %FT03

d685 2
a686 2
        ORR     r0,r0,r1,LSL #2

d688 2
a689 2

03      ;it is a T/Q byte value
d691 2
a692 2
        MOV     r0,r1,LSR #8

d696 2
a697 2

        CMP     r0,#&1000
d701 1
a701 2
02      BIC     r0,r0,#255<<24
        ORR     r0,r0,r14,LSL #24
d717 1
a717 1
set_bar ROUT
d720 2
a721 2
        Push   "r0-r11,LR"

d723 1
a723 1

d726 1
a726 1
        ;result in r4
d728 1
a728 1

d733 1
a733 1

d736 1
a736 1

d739 3
a741 3

        ;ok r4 is the result, and r9 has the top bits (must be zero!)

d785 1
a785 1
        MOVGT  r3,r6
d802 2
a803 2
        Push  "r0-r5,LR"

d806 2
a807 2

        Push  "r0"
d813 1
a813 1
        SWI   XWimp_GetIconState
d818 1
a818 1
        Debug xx,"Got state"
d820 1
a820 1
        Debug xx,"New size ",r0
a822 9

   [ fix_silly_sizes
        TEQ   r4,#"?"
        STREQB r4,[r1],#1
        MOVEQ r4,#" "
        STREQB r4,[r1],#1
        BEQ   %33
   ]

d828 1
a828 1
        Debug xx,"Converted number"
a830 1
33
a833 1

d839 1
a839 1
        Debug xx,"Set state, returning."
d850 1
a850 1

d865 1
a865 1

d879 1
a879 1
        Push    "r0-r6,LR"
d882 1
a882 1
        MOV     r5,r0
d886 1
a886 1
        MOV     r0,#6
d900 1
a900 1
        STR     r5,[r2,#fs_entry]
d914 1
a914 1

d920 1
a920 1
        TEQEQ   r14,r2
d931 1
a931 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

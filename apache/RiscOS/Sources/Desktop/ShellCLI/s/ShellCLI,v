head	4.12;
access;
symbols
	ShellCLI-0_37:4.12
	ShellCLI-0_36:4.10
	ShellCLI-0_35:4.9
	ShellCLI-0_34:4.8
	RO_5_07:4.6
	ShellCLI-0_33:4.6
	ShellCLI-0_32:4.4
	dellis_autobuild_BaseSW:4.3
	ShellCLI-0_31:4.3
	sbrodie_sedwards_16Mar2000:4.2
	dcotton_autobuild_BaseSW:4.4
	ShellCLI-0_30:4.2
	Ursula_merge:4.1.4.1
	nturton_ShellCLI-0_28:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	Ursula_RiscPC:4.1.4.1.0.2
	nicke_ShellCLI_0_28:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.12
date	2015.01.16.00.20.58;	author jlee;	state Exp;
branches;
next	4.11;
commitid	lFwpRsR3Yig0kb6y;

4.11
date	2014.01.11.20.44.52;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	yEcfYX6ry7ieZJkx;

4.10
date	2013.01.12.12.58.49;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	x4jsvIlJ6mcK6Vzw;

4.9
date	2012.09.25.09.52.58;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	iknSZLp0vGjcATlw;

4.8
date	2012.09.12.16.10.33;	author srevill;	state Exp;
branches;
next	4.7;
commitid	t3l8XonilLny5gkw;

4.7
date	2012.09.11.23.03.33;	author srevill;	state Exp;
branches;
next	4.6;
commitid	UlRI9yyoDfPjpakw;

4.6
date	2002.10.23.20.08.33;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.10.21.17.10.44;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2001.03.16.17.06.35;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.04.20.17.04.50;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	99.08.16.10.42.58;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.07;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.30.07;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.30.11;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.03.27.13.49.04;	author mstphens;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.21.22;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.19.12;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Escape some dollars
Detail:
  s/ShellCLI - Escape some dollars contained in strings to avoid warnings from objasm
Admin:
  Resulting binary unchanged


Version 0.37. Retagged as 'ShellCLI-0_37'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.ShellCLI

;;----------------------------------------------------------------------------
;; *********************
;; ***  CHANGE LIST  ***
;; *********************
;;
;; 20-May-88    0.13    Change list added
;; 20-May-88            OS_ReadDefaultHandler used for boring handlers
;; 20-May-88            Keyboard setup left up to Wimp
;; 20-May-88    0.14    Wimp_CommandWindow used so *cat :foo works properly
;; 23-May-88    0.15    VDU 4 before printing error messages / prompt
;;              0.15    ==== Risc OS 2.00 Release version ====
;;
;; 26-May-88    0.16    Use Service_WimpCloseDown to object to wimp tasks
;; 20-Oct-88            'Make' procedures reorganised, Version file included
;; 20-Oct-88            Conditional assembly for versions 0.15 and 0.16
;;  5-May-89    0.17    Improve error recovery on startup
;;  4-Sep-89    0.18    Improve error handling in readline routine
;; 11-Sep-89    0.19    Only claim application memory while in startup sequence
;;  9-Dec-89    0.20    Check for R0 = -64*&100000 in Service_Memory
;;  3-Sep-90    0.21    Changed New Line printing to VDU 31 sequence to
;;                      move the cursor to bottom of screen.
;;  3-Apr-91    0.22    Internationalised
;; 10-Dec-91    0.25    Shortened message tokens.
;; 20-Apr-00    0.31    Made 32-bit compatible.
;;----------------------------------------------------------------------------

        AREA      |ShellCLI$Code|, CODE, READONLY, PIC

Module_BaseAddr

        GET       Hdr:ListOpts
        GET       Hdr:Macros
        GET       Hdr:System
        GET       Hdr:ModHand
        GET       Hdr:Services
        GET       Hdr:Wimp
        GET       Hdr:EnvNumbers
        GET       Hdr:FSNumbers
        GET       Hdr:NewErrors
        GET       Hdr:MsgTrans
        GET       Hdr:OsBytes
        GET       Hdr:Proc
        GET       Hdr:Variables
        GET       hdr.Shell
        GET       VersionASM

 [ :LNOT: :DEF: international_help
        GBLL      international_help
international_help SETL {TRUE}          ; Default to RISC OS 3.60+ internationalisation
 ]

MessageBlockSize  *  16
IsAnybodyThere    *  -64*&100000        ; magic number used by the Wimp
                                        ; for checking whether an application wants its memory

;=========================================================================
;
; Provides a module to support Shelling a CLI interface from a application.
;
; The module responds to the command Wimp_StartTask(ShellCLI).
;
; Shell will only work under the Wimp, and relies on the appropriate values
; for eg. function and cursor keys being set up by the Wimp beforehand.
;
; It issues the "*" prompt and processes commands, setting up the default
; environment for each of them, with a new quit handler.  It continues to do
; this until a null line is input. This terminates the Shell session.
;
; On exit the Shell will close the command window quietly, and call the
; original exit handler.
;
; The keyboard and screen are reset by the Wimp on exit.
;
;=========================================================================

;=========================================================================
;
; The RM header
;
; As laid down by the founding fathers
;
;=========================================================================

ModuleHeader
        DCD     StartCode                       - Module_BaseAddr
        DCD     InitialisationCode              - Module_BaseAddr
        DCD     FinalisationCode                - Module_BaseAddr
        DCD     ServiceCall                     - Module_BaseAddr
        DCD     TitleString                     - Module_BaseAddr
        DCD     HelpString                      - Module_BaseAddr
        DCD     HelpAndCommandKeywordTable      - Module_BaseAddr
        DCD     ShellSWI_Base
        DCD     SWIHandlerCode                  - Module_BaseAddr
        DCD     SWIDecodingTable                - Module_BaseAddr
        DCD     0                 ; SWIDecodingCode
 [ international_help
        DCD     message_filename                - Module_BaseAddr
 |
        DCD     0
 ]
 [ :LNOT: No32bitCode
        DCD     ModuleFlags                     - Module_BaseAddr
 ]


;=========================================================================


HelpString
;=========
        DCB     "ShellCLI", 9, "$Module_HelpVersion", 0
        ALIGN
 [ :LNOT: No32bitCode
ModuleFlags
        DCD     ModuleFlag_32bit
 ]

InitialisationCode ROUT
;=================
; Must preserve r7-r11 and r13
        MOV     r6, lr
        ; Try to open the messages file
        SUB     sp, sp, #MessageBlockSize + 256
        MOV     r0, sp
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        BVS     %FT10
        ; Look-up the greeting string
        MOV     r0, sp
        ADR     r1, greeting_tok
        ADD     r2, sp, #MessageBlockSize
        MOV     r3, #256
        SWI     XMessageTrans_Lookup
        ; Keep it in a variable
        ADRVC   r0, greeting_var
        MOVVC   r1, r2
        MOVVC   r2, r3
        MOVVC   r3, #0
        MOVVC   r4, #VarType_String
        SWIVC   XOS_SetVarVal
        MOV     r0, sp
        SWI     XMessageTrans_CloseFile
10
        ; Free the buffer and return
        ADD     sp, sp, #MessageBlockSize + 256
        CLRV                            ; don't fail to start if no greeting
        MOV     pc, r6

greeting_tok
        DCB     "Greeting", 0
        ALIGN
greeting_var
        DCB     "CLI$$Greeting", 0
        ALIGN


FinalisationCode ROUT
;===============
; Must preserve r7-r11 and r13
; Only die if we have no instances of Shell's to support
        MOV     r6, lr
        LDR     r12, [r12]
        CMP     r12, #0                 ; V clear
        ADRNE   r12, ErrorBlock_ShellRemoval
        BNE     CopyError
        MOV     pc, r6

        LTORG

        MakeInternatErrorBlock ShellRemoval,,"SActive"

;
ServiceTable
;===========
; Ursula format service table
        ASSERT Service_Memory  <  Service_Reset
        ASSERT Service_Reset   <  Service_WimpCloseDown
        DCD    0                                ; flags
        DCD    UrsServiceCall - Module_BaseAddr
        DCD    Service_Memory
        DCD    Service_Reset
        DCD    Service_WimpCloseDown
        DCD    0                                ; terminator
        DCD    ServiceTable - Module_BaseAddr   ; table anchor
;
ServiceCall ROUT
        MOV     r0, r0                          ; magic instruction for Ursula format
        TEQ     r1, #Service_Memory
        TEQNE   r1, #Service_Reset
        TEQNE   r1, #Service_WimpCloseDown
        MOVNE   PC, LR
;
UrsServiceCall
        CMP     r1, #Service_Reset
        BEQ     svc_reset
        CMP     r1, #Service_WimpCloseDown
        BEQ     svc_wimpclos
;else fall through to svc_memory (must be Service_Memory)
svc_memory
        Push    "lr"
        addr    r14, ModuleHeader
        CMP     r14, r2
        Pull    "pc", NE
        TEQ     pc,pc
        MOVNE   r14, #IsAnybodyThere
        MOVEQ   r14,#1:SHL:31
        CMP     r0, r14               ; only claim if this is the Wimp!
        MOVEQ   r1, #0
        Pull    "pc"

svc_reset
; on reset, free all memory
        STMDB   sp!, {r0-r2, r9, lr}
        LDR     r9, [r12]      ; get workspace
        CMP     r9, #0         ; if zero, then no shell
        LDMEQIA sp!, {r0-r2, r9, pc}
        MOV     r0, #0
        STR     r0, [r12]
        MOV     r0, #ModHandReason_Free
        LDR     r2, [r9, #:INDEX:MyStack]
        SWI     XOS_Module
        MOV     r0, #ModHandReason_Free
        MOV     r2, r9
        SWI     XOS_Module
        LDMIA   sp!, {r0-r2, r9, pc}

svc_wimpclos
        CMP     R0,#0           ; not allowed to object if this was Wimp_Close
        LDRNE   r12, [r12]
        CMPNE   r12, #0         ; not active unless we have a block,
        MOVEQ   pc, lr          ; and this is our task handle
        LDR     r12, mytaskhandle
        CMP     r2, r12                      ; if we are currently active,
        ADREQ   r0, ErrorBlock_WimpCantKill  ; tell him to get stuffed!
        BEQ     CopyError
        MOV     pc, lr

        MakeInternatErrorBlock WimpCantKill,,WActive


TitleString
HelpAndCommandKeywordTable
;=========================
; We do all the real work in the *command *ShellCLI.
; The expected client is a Wimp application doing a Wimp_StartTask("ShellCLI")
;

 [ international_help
        Command "ShellCLI", 0, 0, International_Help
        DCB     0              ; terminate my *cmd list

ShellCLI_Syntax
        DCB     "SSCLSCL", 0
ShellCLI_Help
        DCB     "HSCLSCL", 0
 |
        Command "ShellCLI", 0, 0, 0
        DCB     0              ; terminate my *cmd list

ShellCLI_Syntax
        DCB     "Syntax: *ShellCLI", 0
ShellCLI_Help
        DCB     "ShellCLI - used by a Wimp Program to create a CLI shell", 0
 ]
        ALIGN

ShellCLI_Code ROUT
        LDR     r12, [r12]
        CMP     r12, #0
        ADRNE   r0, ErrorBlock_ShellCreation
        BNE     CopyError

        MOV     r0, #ModHandReason_Enter
        ADR     r1, TitleString
        MOV     r2, #0
        SWI     OS_Module
        SWI     OS_Exit

taskid  DCB     "TASK"

        MakeInternatErrorBlock ShellCreation,,NoSpawn

;========================================================================
;
StartCode ROUT
;
; The real work goes on here. The Wimp application will have done a
; Wimp_StartTask(*ShellCLI) to get here. Our aim is to create a CLI shell
; which allows the user to execute CLI commands, then exit back to
; the Wimp.
;
; The Wimp will restore the state it requires when we OS_Exit to it, so
; we don't need to maintain the state, and indeed we can't as applications
; may change for you.
;
; On entry we reset the pallette, turn off the mouse etc.
; We also reset the keyboard to do function key expansion, cursor editing,
; and enable Escape.
;
;========================================================================

        SWI     Shell_Create         ; try and create a Shell instance

        LDR     r12, [r12]           ; get workspace pointer of new instance
        LDR     sp, MyStack
        ADD     sp, sp, #MyStackSize

        MOV     R0,#200
        LDR     R1,taskid
        ADR     R2,TitleString
        SWI     Wimp_Initialise      ; goes to our error handler
        STR     R1,mytaskhandle

        BL      ScreenSetup
        MOVVC   r0, #1               ; tell the Wimp that we're using VDU 4
        SWIVC   XWimp_CommandWindow
        BVS     SetupError

        MOV     R0,#CAOPointer       ; pretend we're not the current application
        ADR     R1,Do_ExitHandler
        MOV     R2,#0
        MOV     R3,#0
        SWI     XOS_ChangeEnvironment
        BVS     SetupError

        ADR     R0, greeting_var
        ADR     R1, ErrorBufferMsg
        MOV     R2, #?ErrorBufferMsg - 1
        MOV     R3, #0
        MOV     R4, #VarType_Expanded
        SWI     XOS_ReadVarVal
        SWIVC   XOS_WriteI+4         ; just in case
        ADRVC   R0, ErrorBufferMsg
        MOVVC   R1, #0
        STRVCB  R1, [R0, R2]         ; terminator for pretty print
        SWIVC   XOS_PrettyPrint
        SWIVC   XOS_NewLine

CmdPrompt
;========
;
; The inner loop of the Cli.
;
; LOOP
;   WriteF("Shell*")
;   command := READLINE();
;   IF command = " " THEN EXIT; END;
;   OSCLI(command);
; END;
;
        BL      DisplayPrompt
        ADRVC   r0, CommandBuffer    ; Read a command line
        MOVVC   r1, #?CommandBuffer
        MOVVC   r2, #" "
        MOVVC   r3, #255
        SWIVC   XOS_ReadLine
        BVS     internalerror        ; give it a chance to recover
        BCS     EscapeAck            ; CS indicated an Escape key was pressed
        CMP     r1, #0               ; zero length string terminates CLI
        BEQ     CmdPromptExit

        ADR     r0, CommandBuffer
        SWI     XOS_CLI
        BVC     CmdPrompt            ; no error, repeat

internalerror
        ADD     r0, r0, #4           ; error - skip number
        SWI     XOS_Write0           ; and print the error message
        SWIVC   XOS_NewLine
        BVC     CmdPrompt            ; drop through if error

SetupError
        Push    "R0"
        MOV     r0, #-1              ; ensure error is reported in a box
        SWI     XWimp_CommandWindow  ; ignore errors from this
        Pull    "R0"
        MOV     R1, #6               ; cancel box highlighted
        ADRL    R2, TitleString
        SWI     Wimp_ReportError

CmdPromptExit ROUT
        SWI     Shell_Destroy        ; lose block (we are now inactive)
        SWI     Wimp_CloseDown
        MOV     r0, #-1              ; close down quietly
        SWI     Wimp_CommandWindow   ; (screen will be redrawn because of this)
        SWI     OS_Exit              ; calls Wimp_CloseDown automatically

esc_msg DCB     "Escape", 0
        ALIGN

EscapeAck ROUT
;========
;
; Also called if Readline terminates with carry set, indication escape.
;
        MOV     r0, #OsByte_AcknowledgeEscape
        SWI     XOS_Byte               ; Acknowledge the Escape
        SWI     XOS_NewLine
        MOVVC   r0, #0
        ADRVC   r1, esc_msg
        MOVVC   r2, #0
        MOVVC   r4, #0
        MOVVC   r5, #0
        MOVVC   r6, #0
        MOVVC   r7, #0
        SWIVC   XMessageTrans_Lookup
        MOVVC   r0, r2
        MOVVC   r1, r3
        SWIVC   XOS_WriteN
        SWIVC   XOS_NewLine
        B       CmdPrompt


Do_ExitHandler ROUT
;=============
;
; The application has died, so return to the Cli prompt
; but I'm paranoid - reset all my handlers first
;
        LDR     sp, MyStack
        ADD     sp, sp, #MyStackSize

        BL      SetHandlers

        B       CmdPrompt


ScreenSetup ROUT
;==========
        Push    r14
        MOV     r0, #OsByte_RW_VDUQueue
        MOV     r1, #0
        MOV     r2, #0
        SWI     XOS_Byte               ; flush VDU Q.
        ADR     r0, %f1
        ADR     r1, %f2
        SUB     r1, r1, r0
        SWI     XOS_WriteN             ; Write out a VDU String to reset things
        B       %f3
1
        =       6                      ; Enable VDU
        =       4                      ; VDU 4 mode
        =       23,1,1,0,0,0,0,0,0,0   ; enable text cursor
        =       26                     ; text and graphics windows to default
        =       30                     ; text cursor homed
        =       29, 0, 0, 0, 0         ; graphics origin to (0,0)
        =       25, 4, 0, 0, 0, 0      ; graphics cursor to (0,0)
        =       15                     ; Paged mode off
;        =       17, 7                  ; text foreground to colour 7
        =       18, 0, 7               ; graphics foreground to colour 7
;        =       17, 128                ; text background to colour 0
        =       18, 0, 128             ; graphics background to colour 0
2
        ALIGN
3
        MOV     r0, #7
        SWI     XWimp_TextColour       ; set text foreground
        MOV     r0, #&80
        SWI     XWimp_TextColour       ; set text background
        MOV     r0, #OsByte_VDUVariable
        MOV     r1, #9                 ; read bottom row
        SWI     XOS_Byte
        MOV     r0,#31                 ;goto
        SWI     XOS_WriteC
        MOV     r0,#0                  ;Left column
        SWI     XOS_WriteC
        MOV     r0,r1                  ;Bottom row.
        SWI     XOS_WriteC
        MOV     r0,#10                 ;One extra line.
        SWI     XOS_WriteC

        MOV     r0, #OsByte_SelectPointer
        MOV     r1, #0                 ; turn it off
        SWI     XOS_Byte

        Pull    pc


DisplayPrompt ROUT
;============
        Push    "lr"
        SWI     XOS_WriteI+4            ; just in case
        Pull    "pc",VS
        ADR     r0, CliDPrompt
        ADR     r1, CommandBuffer
        MOV     r2, #?CommandBuffer
        MOV     r3, #0
        MOV     r4, #VarType_Expanded
        SWI     XOS_ReadVarVal
        ADRVS   r0, DefaultPrompt
        MOVVS   r2, #1
        MOVVC   r0, r1
        ADDS    r1, r2, #0              ; R1 := R2, clear V, set Z if no chars to write
        SWIGT   XOS_WriteN              ; >0, not negative
        Pull    "pc"

CliDPrompt
        DCB     "CLI$$Prompt", 0
DefaultPrompt
        DCB     "*"
message_filename
        DCB     "Resources:$.Resources.ShellCLI.Messages", 0
        ALIGN

Do_ErrorHandler ROUT
;==============
;
; An error has occurred, print error msg and exit
;
        MOV     r12, r0                ; get Workspace pointer in correct reg
        LDR     r13, MyStack
        ADD     r13, r13, #MyStackSize

        SWI     XOS_WriteI+4           ; just in case
        ADR     r0, ErrorBufferMsg
        SWI     XOS_Write0             ; print the error message
        SWI     XOS_NewLine
        SWI     XOS_Exit               ; exit to ShellCLI's exit handler


;===================================================================
;
; The SWI handlers.
; We have Create and Destroy, used to create and destroy instances
; of the Shell.
;
;===================================================================
SWIDecodingTable
;===============
        DCB     "Shell", 0
        DCB     "Create", 0
        DCB     "Destroy", 0
        DCB     0
        ALIGN


SWIHandlerCode ROUT
;==================
        CMP     r11, #1
        BEQ     SWI_Destroy
        BCC     SWI_Create

        ADR     r0, ErrorNumber_ModuleBadSWI
        B       CopyError

        MakeInternatErrorBlock ModuleBadSWI,,BadSWI

;===================================================================
;
SWI_Create ROUT
;
; We create an instance of a shell. We allocate some workspace in the
; RMA and link it in at the head of the instance chain. We reset the
; handlers, saving the old values for restoration by destroy.
;
;===================================================================
; Can corrupt r10-r12

        Push    "r0-r9, lr"

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =(LastWord - FirstWord)
        SWI     XOS_Module
        BVS     SWI_CreateExit

        MOV     r9, r2
        MOV     r3, #MyStackSize
        SWI     XOS_Module
        BVS     SWI_CreateError

        STR     r9, [r12]
        MOV     r12, r9                 ; point to our workspace
        STR     r2, MyStack

        BL      SetHandlers             ; on exit r1-r3 = old Exit handler pars
                                        ; assume no errors from this
        ADRVC   r0, OldExitHandler
        STMVCIA r0,{r1-r3}

SWI_CreateExit
        STRVS   r0, [sp]
        Pull    "r0-r9, pc"

SWI_CreateError
        STR     r0, [sp]

        MOV     r0, #ModHandReason_Free
        MOV     r2, r9
        SWI     XOS_Module

        SETV                            ; return with error
        Pull    "r0-r9, pc"

;
; set up default environment handlers (ensure none left in yukky state)
;  0 in table ==> leave alone (MemoryLimit,ApplicationSpaceSize)
;  1 in table ==> use default handler
; >1 in table ==> use values in table
;

maxenv  *       MaxEnvNumber   ; this keeps changing!

SetHandlers ROUT
        Push    "R1-R6,LR"              ; R1-R3 pushed later
;
        ADR     R4,defaulthandlers      ; R4 --> data
        MOV     R6,#maxenv
01
        LDR     R1,[R4],#4              ; if zero, it's not an address offset
        TEQ     R1,#0
        RSBEQ   R0,R6,#maxenv           ; R1=0 ==> use default handler
        SWIEQ   XOS_ReadDefaultHandler
        Pull    "R1-R6,PC",VS
        ADDNE   R1,R1,R4                ; R1 --> code address
        MOVNE   R2,R12
        ADRNEL  R3,ErrorBuffer
02
        RSB     R0,R6,#maxenv
        SWI     XOS_ChangeEnvironment
        TEQ     R6,#maxenv-ExitHandler
        STMEQIA sp,{R1-R3}              ; stash old exit handler
        SUBS    R6,R6,#1
        BNE     %BT01
;
        Pull    "R1-R6,PC"

;
; Default settings to pass to SWI XOS_ChangeEnvironment
;       R1 --> code address / buffer pointer
;       R2  =  returned in R12 (if R1 is an address) - maybe
;       R3 --> block           (if R1 is an address)
;

defaulthandlers
        DCD     0                       ; MemoryLimit

        DCD     0                       ; UndefinedHandler
        DCD     0                       ; PrefetchAbortHandler
        DCD     0                       ; DataAbortHandler
        DCD     0                       ; AddressExceptionHandler
        DCD     0                       ; OtherExceptionHandler

        DCD     Do_ErrorHandler-.-4
        DCD     0                       ; CallBackHandler
        DCD     0                       ; BreakPointHandler

        DCD     0                       ; EscapeHandler
        DCD     0                       ; EventHandler
        DCD     Do_ExitHandler-.-4
        DCD     0                       ; UnusedSWIHandler

        DCD     0                       ; ExceptionDumpArea
        DCD     0                       ; ApplicationSpaceSize
        DCD     0                       ; CAO pointer

        DCD     0                       ; UpCall handler

        ASSERT  (.-defaulthandlers)/4 = maxenv


;===================================================================
;
SWI_Destroy ROUT
;
; We dismantle this instance of shell, restoring all the old handlers
; and freeing the workspace in the RMA, delinking us from the
; instance chain.
;
;===================================================================
; can corrupt only r10-r12

        Push    "r0-r9, lr"

        MOV     r10, r12             ; save private word
        LDR     r12, [r12]           ; get workspace
        CMP     r12, #0              ; if zero, then no shell
        BEQ     SWI_Destroy_Exit     ; note: Z is set, V is clear

        MOV     r0, #0
        STR     r0, [r10]            ; unchain ourselves - no going back now !

        MOV     r0, #ExitHandler
        ADR     r1, OldExitHandler   ; restore old Exit handler
        LDMIA   r1, {r1-r3}
        SWI     XOS_ChangeEnvironment

        MOV     r0, #ModHandReason_Free
        LDR     r2, MyStack
        SWI     XOS_Module           ; ignore errors

        MOV     r0, #ModHandReason_Free
        MOV     r2, r12
        SWI     XOS_Module           ; ignore errors
        SUBS    R0, R0, R0           ; clears V, sets Z for next instruction

SWI_Destroy_Exit
        TEQ     pc, pc               ; in 32-bit mode?
        Pull    "r0-r9, pc",NE,^     ; no - 26-bit exit
        Pull    "r0-r9, pc"          ; yes - 32-bit exit (PSR trashed)

;===================================================================


CopyError
        STMDB   sp!, {r0-r7, lr}
        SUB     sp, sp, #MessageBlockSize
        MOV     r0, sp
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        BVS     CopyError1
        LDR     r0, [sp, #MessageBlockSize]
        MOV     r1, sp
        ADRL    r4, TitleString
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        STR     r0, [sp, #MessageBlockSize]
        MOV     r0, sp
        SWI     XMessageTrans_CloseFile
        SETV
CopyError1
        ADD     sp, sp, #MessageBlockSize

        LDMIA   sp!, {r0-r7, lr}
        TEQ     pc, pc               ; in 32-bit mode?  (set Z if so)
        ORRNES  pc, lr, #V_bit       ; 26-bit exit - NZC preserved
        MOV     pc, lr               ; 32-bit exit - NZC trashed


;===================================================================
;
; Instance Data - kept in RMA Heap blocks
;
;===================================================================
        ^ 0, r12
FirstWord              Word 0  ; unused - a placeholder for allocating space

OldExitHandler         Word 3
mytaskhandle           Word
ErrorBuffer            Word 0
ErrorBufferPC          Word
ErrorBufferNumber      Word
ErrorBufferMsg         Word 64
CommandBuffer          Word 256  ;mjs changed for Ursula (was 64)
CallbackBuffer         Word 16
MyStack                Word

MyStackSize            * &400

LastWord               Word 0  ; unused - a placeholder for allocating space

        END
@


4.11
log
@Build fix
Move Hdr:Services up above Hdr:Wimp
Built, but not tested.

Version 0.37. Tagged as 'ShellCLI-0_37'
@
text
@d170 1
a170 1
        DCB     "CLI$Greeting", 0
d515 1
a515 1
        DCB     "CLI$Prompt", 0
@


4.10
log
@Add support for an adaptive CLI greeting
ShellCLI already supports setting CLI$Prompt to replace the '*' with something else.
Now, the initial greeting ("Press return to get back to the desktop") can also be replaced by setting CLI$Greeting, for example "Session started <Sys$Time>".
* Read the default greeting from the messages at init
* Expand the variable and prettyprint it on starting a new ShellCLI instance
* Remove use of International_Help bitfield as an assembly time switch
* Made the "can't kill ShellCLI" and "can't start ShellCLI" have two different error messages
* Use Command macro, and own header file

Version 0.36. Tagged as 'ShellCLI-0_36'
@
text
@d51 1
a53 1
        GET       Hdr:Services
@


4.9
log
@Untangle messages
* Command help moved to CmdHelp
* Unused message tokens (and unused file 'Help') removed
* Phrasing of greeting heartily stolen from switcher
* Provide MessageTrans_Lookup with a buffer to avoid needing to know about the kernel dictionary
* OS_Byte magic numbers replaced from Hdr:OsBytes
Tested in IOMD ROM, still worked.

Version 0.35. Tagged as 'ShellCLI-0_35'
@
text
@d59 2
d63 8
d102 1
a102 1
        DCD     0
d108 1
a108 1
        DCD     SWIChunkBaseNumber
d112 1
a112 1
 [ International_Help <> 0
d127 44
a170 1
        =       "ShellCLI", 9, "$Module_HelpVersion", 0
d181 1
a181 1
        ADRNE   r12, ShellCLIFailure
d187 1
a187 10
ShellCLIFailure
        DCD     &900
        =       "SActive", 0
        ALIGN

 [ :LNOT: No32bitCode
ModuleFlags
        DCD     ModuleFlag_32bit
 ]

a188 4
IsAnybodyThere    *  -64*&100000        ; magic number used by the Wimp
                                        ; for checking whether an application wants its memory

;mjs: Ursula format service table
d190 3
a194 2
;
ServiceTable
a263 8
        =       "ShellCLI", 0
        ALIGN
        DCD     StartShellCLI           - Module_BaseAddr
        DCD     International_Help
        DCD     ShellCLIInvalid         - Module_BaseAddr
        DCD     ShellCLIHelpText        - Module_BaseAddr

        DCD     0              ; terminate my *cmd list
d265 11
d277 4
a280 10
 [ International_Help = 0
ShellCLIInvalid
        =      "Syntax: *ShellCLI", 0
ShellCLIHelpText
        =      "ShellCLI - used by a Wimp Program to create a CLI shell", 0
 |
ShellCLIInvalid
        =      "SSCLSCL", 0
ShellCLIHelpText
        =      "HSCLSCL", 0
d284 1
a284 1
StartShellCLI ROUT
d287 1
a287 1
        ADRNE   r0, ShellCLIFailure
d290 1
a290 1
        MOV     r0, #2
d298 1
d343 12
a354 1
        BL      OutputGreeting
d370 1
a370 1
        MOVVC   r1, #(CommandBufferEnd - CommandBuffer)
a495 1

d503 1
a503 1
        MOV     r2, #(CommandBufferEnd - CommandBuffer)
d505 1
a505 1
        MOV     r4, #3
d515 1
a515 1
        =       "CLI$Prompt", 0
d517 3
a519 1
        =       "*"
a521 1

a544 8

SWIChunkBaseNumber            * &40000 + (&40 * ShellSWI)
;=================

Shell_Create                  * SWIChunkBaseNumber
Shell_Destroy                 * SWIChunkBaseNumber + 1


d547 4
a550 4
        =       "Shell", 0
        =       "Create", 0
        =       "Destroy", 0
        =       0
d560 1
a560 1
        ADR     r0, UnknownSWIErrorMsg
d563 1
a563 5
UnknownSWIErrorMsg
        DCD     &901
        DCB     "BadSWI", 0
        ALIGN

d628 1
a628 1
        RSBEQ   R0,R6,#maxenv     ; R1=0 ==> use default handler
a719 1
MessageBlockSize EQU 16
a747 40
OutputGreeting
        Push    "r0-r7, lr"
        ; Do a VDU4, just in case
        SWI     XOS_WriteI+4
        ; Set aside a buffer
        SUB     sp, sp, #MessageBlockSize
        ; Open the messages block
        MOV     r0, sp
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        BVS     SkipGreeting
        ; Look-up the greeting string
        MOV     r0, sp
        ADR     r1, greeting_tok
        ADR     r2, ErrorBufferMsg   ; to detokenise into
        MOV     r3, #?ErrorBufferMsg
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        ; Output the greeting string
        MOVVC   r0, r2
        SWIVC   XOS_PrettyPrint
        SWIVC   XOS_NewLine
        MOV     r0, sp
        SWI     XMessageTrans_CloseFile
SkipGreeting
        ; Free the buffer and return
        ADD     sp, sp, #MessageBlockSize
        Pull    "r0-r7, pc"

greeting_tok
        DCB     "Greeting", 0
        ALIGN

message_filename
        DCB     "Resources:$.Resources.ShellCLI.Messages", 0
        ALIGN
a763 1
CommandBufferEnd       Word 0
@


4.8
log
@Forgot about ROM build messages file tokenisation in previous change.
@
text
@d47 12
a58 11
        GET       hdr:ListOpts
        GET       hdr:Macros
        GET       hdr:System
        GET       hdr:ModHand
        GET       hdr:Wimp
        GET       hdr:EnvNumbers
        GET       hdr:Services
        GET       hdr:FSNumbers
        GET       hdr:NewErrors
        GET       hdr:MsgTrans
        GET       hdr:Proc
d107 1
d109 1
d139 1
a140 3
 [ No32bitCode
        DCD     0
 |
d363 1
a363 1
        MOV     r0, #&7E
d398 1
a398 1
        MOV     r0, #218
d427 3
a429 3
        MOV     r0, #160               ; Read VDU variable
        MOV     r1, #9                 ; of bottom row
        SWI     XOS_Byte               ; into r1
d439 1
a439 1
        MOV     r0, #106               ; mouse pointer
d726 2
a727 2
        MOV     r2, #0
        MOV     r3, #0
a733 2
        SWIVC   XMessageTrans_Dictionary
        MOVVC   r1, r0
d745 2
a746 2
	DCB     "Greeting", 0
	ALIGN
@


4.7
log
@Tweaked to output a message when it is started.

One line of (internationalised) text is output when the ShellCLI is started.
This is assumed to be a hint to the inexperienced user as to how to get out
of the ShellCLI.

Version 0.34. Tagged as 'ShellCLI-0_34'
@
text
@d733 2
a734 1
        MOVVC   r1, r3
d736 1
a736 1
        SWIVC   XOS_WriteN
@


4.6
log
@Oops, got condition code wrong way round in last commit.
Retagged as 'ShellCLI-0_33'.

Version 0.33. Not tagged
@
text
@d259 1
d303 2
d710 38
@


4.5
log
@If in 32-bit mode, now required to expect and requires the application
space size change in Service_Memory issued by the Wimp to be -2 GB, not
-64 MB.

Version 0.33. Tagged as 'ShellCLI-0_33'
@
text
@d178 1
a178 1
        Pull    "pc", EQ
@


4.4
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.32. Tagged as 'ShellCLI-0_32'
@
text
@d178 5
a182 1
        CMPEQ   r0, #IsAnybodyThere   ; only claim if this is the Wimp!
@


4.3
log
@Made 32-bit compatible.

Version 0.31. Tagged as 'ShellCLI-0_31'
@
text
@d43 2
a50 1
;        GET       hdr:vduext
a110 5
TitleString
;==========
        =       "ShellCLI", 0
        ALIGN

d114 1
a114 5
        =       "ShellCLI", 9, "$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
 ]
        =       0
d212 1
a252 1
      [ Module_Version >= 16
a253 1
      ]
a273 4
      [ Module_Version < 16
        MOV     r0, #1
        SWI     Wimp_CommandWindow
      ]
a279 1
     [ Module_Version >= 16
a285 1
      [ Module_Version >= 17
a289 9
      |
        MOV     r0, #1               ; tell the Wimp that we're using VDU 4
        SWI     Wimp_CommandWindow   ; without actually using the normal window

        BL      ScreenSetup          ; then the screen
      ]
     |
        BL      ScreenSetup          ; version 0.15 and earlier
     ]
a290 1
      [ Module_Version >= 19
a296 1
      ]
a310 1
     [ Module_Version >= 17
a315 1
      [ Module_Version >= 18
a316 10
      |
        BVS     SetupError
      ]
        BCS     EscapeAck            ; CS indicated an Escape key was pressed
     |
        ADR     r0, CommandBuffer    ; Read a command line
        MOV     r1, #(CommandBufferEnd - CommandBuffer)
        MOV     r2, #" "
        MOV     r3, #255
        SWI     OS_ReadLine
a317 1
     ]
a327 4
      [ Module_Version < 17
        SWI     XOS_NewLine
        B       CmdPrompt
      |
a338 1
      ]
a341 1
      [ Module_Version >= 16
a342 1
      ]
d348 1
a421 1
      [ Module_Version >= 21
a429 7
      |
        MOV     r0, #10
4
        SWI     XOS_WriteC             ; do linefeeds
        SUBS    r1, r1, #1             ; to bottom of screen
        BGE     %b4
      ]
a442 1
      [ Module_Version >= 18
a443 1
      ]
d450 1
a450 1
        ADRVS   r1, DefaultPrompt
d452 3
a454 10
        MOV     r3, #0
1
        LDR     r0, [r1, r3]
        CMP     r3, r2
        SWINE   XOS_WriteC
      [ Module_Version >= 18
        Pull    "pc",VS
      ]
        ADDNE   r3, r3, #1
        BNE     %b1
a571 3
      [ Module_Version <= 17
maxenv  *       &10
      |
a572 1
      ]
a626 1
      [ Module_Version >= 18
a627 1
      ]
d648 1
a648 1
        BEQ     SWI_Destroy_Exit
d665 1
d668 2
a669 5
        MOVS    R0, #0               ; clear V
        mrs    ,R0, CPSR
        TST     R0, #2_11100         ; in 32-bit mode?

        Pull    "r0-r9, pc",EQ,^     ; no - 26-bit exit
d694 1
a697 4
        MOV     R0, #0
        mrs    ,R0, CPSR
        TST     R0, #2_11100         ; in 32-bit mode?

d699 2
a700 2
        ORREQS  pc, lr, #V_bit       ; 26-bit exit - NZC preserved
        SETV
a715 1
  [ Module_Version >= 16
a716 1
  ]
@


4.2
log
@Ursula branch merged.
Changed to use srccommit.

Version 0.30. Tagged as 'ShellCLI-0_30'
@
text
@d40 1
d105 1
d132 1
a132 1
        CMP     r12, #0
d135 1
a135 1
        MOVS    pc, r6
d144 7
d174 1
a174 1
        MOVNES  PC, LR
d188 1
a188 1
        Pull    "pc",,^
d195 1
a195 1
        LDMEQIA sp!, {r0-r2, r9, pc}^
d204 1
a204 1
        LDMIA   sp!, {r0-r2, r9, pc}^
a423 2
        TEQP    pc, #0                 ; make really sure we are user mode
        MOVNV   r0, r0
a531 2
        TEQP    pc, #0                 ; make really sure we are user mode
        MOVNV   r0, r0
d624 2
a625 2
        Pull    "r0-r9, lr"
        ORRS    pc, lr, #V_bit          ; return with error
d716 1
a716 1
        Pull    "r0-r9, pc",EQ,^
d734 7
a740 1
        Pull    "r0-r9, pc",,^
a746 1
        ORR     lr, lr, #V_bit
d766 9
a774 1
        LDMIA   sp!, {r0-r7, pc}^
@


4.1
log
@Initial revision
@
text
@d56 1
a56 1
        GET       Version
d116 5
a120 1
        =       "ShellCLI", 9, "$VString ($Date)", 0
d146 14
d161 7
a167 1
;==========
d172 1
a172 3
        CMP     r1, #Service_Memory
        MOVNES  pc, r14

d251 1
a251 1
      [ Version >= 16
d274 1
a274 1
      [ Version < 16
d284 1
a284 1
     [ Version >= 16
d291 1
a291 1
      [ Version >= 17
d306 1
a306 1
      [ Version >= 19
d328 1
a328 1
     [ Version >= 17
d334 1
a334 1
      [ Version >= 18
d358 1
a358 1
      [ Version < 17
d377 1
a377 1
      [ Version >= 16
d460 1
a460 1
      [ Version >= 21
d489 1
a489 1
      [ Version >= 18
d505 1
a505 1
      [ Version >= 18
d590 1
a590 1
        MOV     r3, #(LastWord - FirstWord)
d629 1
a629 1
      [ Version <= 17
d688 1
a688 1
      [ Version >= 18
d771 1
a771 1
  [ Version >= 16
d778 1
a778 1
CommandBuffer          Word 64
@


4.1.4.1
log
@- increase command line buffer to 1k
- update to Ursula format (service table)
@
text
@a141 14
;mjs: Ursula format service table
;
        ASSERT Service_Memory  <  Service_Reset
        ASSERT Service_Reset   <  Service_WimpCloseDown
;
ServiceTable
        DCD    0                                ; flags
        DCD    UrsServiceCall - Module_BaseAddr
        DCD    Service_Memory
        DCD    Service_Reset
        DCD    Service_WimpCloseDown
        DCD    0                                ; terminator
        DCD    ServiceTable - Module_BaseAddr   ; table anchor
;
d143 1
a143 7
        MOV     r0, r0                          ; magic instruction for Ursula format
        TEQ     r1, #Service_Memory
        TEQNE   r1, #Service_Reset
        TEQNE   r1, #Service_WimpCloseDown
        MOVNES  PC, LR
;
UrsServiceCall
d148 3
a150 1
;else fall through to svc_memory (must be Service_Memory)
d568 1
a568 1
        LDR     r3, =(LastWord - FirstWord)
d756 1
a756 1
CommandBuffer          Word 256  ;mjs changed for Ursula (was 64)
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

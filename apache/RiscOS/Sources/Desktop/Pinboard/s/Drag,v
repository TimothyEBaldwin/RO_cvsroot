head	4.9;
access;
symbols
	Pinboard-1_04:4.9
	Pinboard-1_03:4.9
	Pinboard-1_02:4.9
	Pinboard-1_01:4.9
	Pinboard-1_00:4.9
	Pinboard-0_99:4.8
	Pinboard-0_98:4.8
	Pinboard-0_97:4.8
	Pinboard-0_96:4.8
	Pinboard-0_95:4.8
	Pinboard-0_94:4.8
	Pinboard-0_93:4.8
	Pinboard-0_92:4.6
	Pinboard-0_91:4.5
	Pinboard-0_90:4.5
	Pinboard-0_89:4.5
	Pinboard-0_88:4.5
	Pinboard-0_87:4.5
	Pinboard-0_86:4.5
	Pinboard-0_85:4.5
	Pinboard-0_84:4.5
	Pinboard-0_83:4.5
	Pinboard-0_82:4.4
	RO_5_07:4.4
	Pinboard-0_81:4.4
	Pinboard-0_80:4.4
	Pinboard-0_79:4.4
	Pinboard-0_78:4.4
	Pinboard-0_77:4.3
	Pinboard-0_76:4.3
	Ursula_merge:4.1.4.4
	Pinboard-0_75:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.3
	Ursula_RiscPC:4.1.4.3.0.2
	rleggett_Pinboard-0_75d:4.1.4.4
	rthornb_UrsulaBuild-19Aug1998:4.1.4.3
	UrsulaBuild_FinalSoftload:4.1.4.3
	rthornb_UrsulaBuild-12Aug1998:4.1.4.3
	aglover_UrsulaBuild-05Aug1998:4.1.4.3
	rthornb_UrsulaBuild-29Jul1998:4.1.4.3
	rthornb_UrsulaBuild-22Jul1998:4.1.4.3
	rleggett_Pinboard-0_75c:4.1.4.3
	rleggett_Pinboard-0_75b:4.1.4.3
	rleggett_Pinboard-0_75:4.1.4.3
	rthornb_UrsulaBuild-15Jul1998:4.1.4.3
	rthornb_UrsulaBuild-07Jul1998:4.1.4.3
	rthornb_UrsulaBuild-17Jun1998:4.1.4.3
	rthornb_UrsulaBuild-03Jun1998:4.1.4.3
	rthornb_UrsulaBuild-27May1998:4.1.4.3
	rthornb_UrsulaBuild-21May1998:4.1.4.3
	rleggett_Pinboard-0_74:4.1.4.3
	rthornb_UrsulaBuild_01May1998:4.1.4.3
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2016.05.08.16.45.03;	author jlee;	state Exp;
branches;
next	4.8;
commitid	6qtTwO9XstbZoH5z;

4.8
date	2011.09.24.07.31.19;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	nRjnbtmOSxK1BIAv;

4.7
date	2011.09.24.07.23.44;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	U6nT8u4TlrjayIAv;

4.6
date	2011.09.19.07.41.57;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	90jvproiNPICO4Av;

4.5
date	2006.03.14.18.45.07;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.11.12.34.51;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2001.03.16.17.07.02;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.08.17.19.05.16;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.59;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.59;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.29.44;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.10.21.09.56.55;	author rleggett;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.10.22.09.33.21;	author rleggett;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.03.27.09.36.28;	author rleggett;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.09.18.10.18.09;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.20.48;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.18.42;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Avoid unnecessary remainder calculations. Fix wonky "snap to grid" logic.
Detail:
  s/Drag, s/Messages, s/StartLoop - Avoid unnecessary remainder calculation in DivRem macro
  s/Icons - Fix grid coordinate rounding when tidying to the left
Admin:
  Tested on Cortex-A15


Version 1.00. Tagged as 'Pinboard-1_00'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;


; s.Drag
;
; Comes here when a drag ends.



; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; drag_end
;
; Called upon receipt of User_Drag_Box event meaning a drag has ended.
;
; In: r1 -> Wimp_Poll block
;
; Out: registers may be corrupted. Returning to wimp_poll.

drag_end
        Push    "LR"

        Debug   sa,"Drag end"

        BL	Restore_Focus

        SWI     XDragASprite_Stop       ; Clear any DragASprite operations

        LDR     r0,DragType
        TEQ     r0,#DragType_SelectDrag
        BEQ     SelectDrag_end
        TEQ     r0,#DragType_AdjustDrag
        BEQ     AdjustDrag_end

        TEQ     r0,#DragType_SelectDragIcon
        BEQ     SelectDragIcon_end
        TEQ     r0,#DragType_AdjustDragIcon
        BEQ     SelectDragIcon_end

        TEQ     r0,#DragType_Iconized
        BEQ     SelectDragIcon_end
        ;BEQ     Iconized_DragEnd

        TEQ     r0,#DragType_Save
        BEQ     Save_DragEnd

        Pull    "PC"


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; AdjustDrag_end
;
; Called when user has finished dragging a selection with the right mouse button.

AdjustDrag_end                          ; Invert state of icons
        MOV     r3,#is_selected
        MOV     r4,#0
        B       %FT11


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectDrag_end
;
; Called when the user has finished dragging out a selection, this function will attempt
; to select any icons within the bounding box.

SelectDrag_end

        MOV     r3,#is_selected         ; Select icons.
        MOV     r4,#is_selected

11
        MOV     r0,#DragType_NoDrag
        STR     r0,DragType
        ADR     r1,dataarea             ; make sure that x0<x1 and y0<y1
        LDMIA   r1,{r6,r7,r8,r9}        ; x0,y0,x1,y1
        CMP     r6,r8
        MOVGT   r14,r6
        MOVGT   r6,r8
        MOVGT   r8,r14
        CMP     r7,r9
        MOVGT   r14,r7
        MOVGT   r7,r9
        MOVGT   r9,r14                  ; We now know x0<x1 and y0<y1

        LDR     r0,backdrop_handle
        STR     r0,[r1]
        LDR     r5,Icon_list            ; Load first icon in list
01
        CMP     r5,#0                   ; Have we reached end of list?
        ;Pull    "PC",EQ                 ; If so, then exit
        BEQ     %FT20

        LDR     r0,[r5,#ic_icon]
        STR     r0,[r1,#4]
        SWI     XWimp_GetIconState      ; Get the state of this icon
        Pull    "PC",VS

        ; Check Icon's bounds
        LDR     r14,[r1,#8]             ; Icon's x0
        CMP     r14,r8
        BGT     %FT10                   ; > x1 !
        LDR     r14,[r1,#16]            ; Icon's x1
        CMP     r14,r6
        BLT     %FT10                   ; < x0 !
        LDR     r14,[r1,#12]            ; Icon's y0
        CMP     r14,r9
        BGT     %FT10                   ; > y1 !
        LDR     r14,[r1,#20]            ; Icon's y1
        CMP     r14,r7
        BLT     %FT10                   ; < y0 !

        LDR     r0,Pinboard_Selected
        LDR     r14,[r1,#24]            ; Get icon flags
        TST     r14,#is_selected
        ADDEQ   r0,r0,#1                ; If it wasn't selected it will be
        CMPNE   r4,#is_selected         ; If it was is this adjust ?
        SUBNE   r0,r0,#1                ; If it is, it won't be.
        STR     r0,Pinboard_Selected
        Debug   pi,"Selected icons = ",r0

        STR     r3,[r1,#8]              ; Now set new state
        STR     r4,[r1,#12]
        SWI     XWimp_SetIconState
        Pull    "PC",VS

10
        LDR     r5,[r5,#ic_next]        ; Load next icon in list
        B       %BT01

20
        BL      Iconized_SelectDrag_end
        Pull    "pc"


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Iconized_SelectDrag_end
;
; Called by SelectDrag_end, which is called after a selection has been dragged out on the
; pinboard, it attempts to select any iconized window icons within the bounding box.
;
; In: r6, r7, r8, r9 = Bounding box
;     r3, r4 = Clear and EOR states for SetIconState
;     r1 -> dataarea, of which r1+4 = window handle
;
; Out:

Iconized_SelectDrag_end Entry
        MOV     r0,#DragType_NoDrag
        STR     r0,DragType

        LDR     r5, iconized_ptr
01
        CMP     r5, #0
        EXIT    EQ

        LDR     r0, [r5, #w_icon_handle]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState
        EXIT    VS

        ; Check Icon's bounds
        LDR     r14, [r1, #8]           ; Icon's x0
        CMP     r14, r8
        BGT     %FT10                   ; > x1 !
        LDR     r14, [r1, #16]          ; Icon's x1
        CMP     r14, r6
        BLT     %FT10                   ; < x0 !
        LDR     r14, [r1, #12]          ; Icon's y0
        CMP     r14, r9
        BGT     %FT10                   ; > y1 !
        LDR     r14, [r1, #20]          ; Icon's y1
        CMP     r14, r7
        BLT     %FT10                   ; < y0 !

        LDR     r0, Windows_Selected
        LDR     r14, [r1,#24]           ; Get icon flags
        TST     r14, #is_selected
        ADDEQ   r0, r0, #1              ; If it wasn't selected it will be
        CMPNE   r4, #is_selected        ; If it was is this adjust ?
        SUBNE   r0, r0, #1              ; If it is, it won't be.
        STR     r0, Windows_Selected

        STR     r3,[r1,#8]              ; Now set new state
        STR     r4,[r1,#12]
        SWI     XWimp_SetIconState
        EXIT    VS

10
        LDR     r5,[r5,#w_next_ptr]     ; Load next icon in list
        B       %BT01


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectDragIcon_end
;
; Called after the user has finished dragging a selection of icons.
;
; In: r1 -> Wimp_Poll block
;
; Out: registers may be corrupted - returning to Poll loop.

SelectDragIcon_end
        MOV     r0,#DragType_NoDrag
        STR     r0,DragType

        ; Find out where it ended
        ADR     r1, PointerInfo
        SWI     XWimp_GetPointerInfo
        LDR     r2, [r1, #12]          ; Window
        LDR     r3, [r1, #16]          ; Icon

        CMP     r2, #-2
        CMPLE   r3, #-1
        BEQ     Run_Selection         ; Dragged to empty part of icon bar, run it !

        LDR     r0, backdrop_handle
        CMP     r2, r0                 ; If destination wasn't the backdrop, call
        BNE     DragIconsToApp         ; appropriate function

        LDR     r5, drag_window
        CMP     r5, r2                 ; If source wasn't the backdrop
        BNE     DragIconsToApp

        ; Work out relative movement
        LDMIA   r1, {r5, r6}           ; get x and y of destination
        ADR     r0, drag_start
        LDMIA   r0, {r8, r9}           ; load x and y co-ordinate of start of drag
        SUB     r8,r5,r8
        SUB     r9,r6,r9               ; Get relative movement

        ; If grid lock is on, make the relative movement a multiple of the spacing
        LDR     r0, Pinboard_options
        TST     r0, #PinboardOption_Grid
        BLNE    lock_movement_to_grid

; Now we have to loop through all icons and windows, test if they are selected
; and if so, move them.
; At this point, r8 = relative x movement
;                r9 = relative y movement
01
        ADR     r6, dataarea
        LDR     r0, backdrop_handle
        STR     r0, [r6]
        LDR     r7, Icon_list
        MOV     r11, #0                ; Says we're on Icon_list
02
        CMP     r7, #0                 ; Is this the last icon?
        BEQ     %FT10

        ; Check icon is on backdrop
        LDR     r0, backdrop_handle
        LDR     r1, [r7, #ic_window]
        CMP     r1, r0
        BNE     %FT04

        ; Get icon's state
        LDR     r0, backdrop_handle
        STR     r0, [r6]
        LDR     r0, [r7, #ic_icon]
        STR     r0, [r6, #4]
        MOV     r1, r6
        SWI     XWimp_GetIconState
        Pull    "pc", VS

        ; Check if icon is selected
        LDR     r0, [r6, #24]
        TST     r0, #is_selected
        BEQ     %FT04

        ; Force redraw of old icon position
        Push    "r0-r4"
        ADD     r0, r1, #8
        LDMIA   r0, {r1-r4}
        LDR     r0, backdrop_handle
        SWI     XWimp_ForceRedraw
        Pull    "r0-r4"

        ; Work out new position
        ADD     r0, r6, #8
        LDMIA   r0, {r2-r5}
        ADD     r2, r2, r8
        ADD     r3, r3, r9
        ADD     r4, r4, r8
        ADD     r5, r5, r9

        ; Move (resize) icon
        LDR     r0, backdrop_handle
        LDR     r1, [r7, #ic_icon]
        SWI     XWimp_ResizeIcon
        Pull    "pc", VS

        ; Update x and y in linked list
        CMP     r11, #0
        STREQ   r2, [r7, #ic_x]
        STREQ   r3, [r7, #ic_y]

        ; Change it's state so it is no longer selected
        ; (this will also redraw icon at new position)
        MOV     r0, #is_selected
        STR     r0, [r6, #8]
        MOV     r0, #0
        STR     r0, [r6, #12]
        MOV     r1, r6
        SWI     XWimp_SetIconState
        Pull    "pc", VS

        ; Update number of icons selected
        CMP     r11, #0
        LDREQ   r0, Pinboard_Selected
        LDRNE   r0, Windows_Selected
        SUB     r0, r0, #1
        CMP     r11, #0
        STREQ   r0, Pinboard_Selected
        STRNE   r0, Windows_Selected
04
        LDR     r7, [r7, #ic_next]
        B       %BT02

10 ; finishedfiles
        CMP     r11, #1
        BEQ     %FT20
        LDR     r7, iconized_ptr
        MOV     r11, #1
        B       %BT02

20 ; finishedall
        Pull    "pc"


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; lock_movement_to_grid
;
; In: r0 - pinboard_options
;     r5, r6 - x co-ordinate of destination
;     drag_icon - icon where drag started
;
; Out: r8, r9 - relative movement x and y
;      All other regs preserved.

lock_movement_to_grid Entry "r0-r7, r10-r11"

        MOV     r4, r0

   ; Work out the x co-ord of the nearest grid position
        TST     r4, #PinboardOption_TidyToCornerLR
        BNE     %FT02
        ; If tidy to left
        MOV     r10, #grid_x_spacing
        DivRem  r1, r5, r10, r2, norem
        MUL     r8, r1, r10                  ; x = (mouse_x DIV x_spacing) * x_spacing
        B       %FT04
02      ; If tidy to right
        MOV     r10, #grid_x_spacing
        LDR     r11, Screen_x1
        ADD     r1, r11, #grid_x_spacing
        SUB     r2, r1, r5
        DivRem  r1, r2, r10, r0, norem
        MUL     r2, r1, r10
        SUB     r8, r11, r2

04 ; Work out the y co-ord of the nearest grid position
        TST     r4, #PinboardOption_TidyToCornerTB
        BNE     %FT06
        ; If tidy to top
        MOV     r10, #grid_y_spacing
        LDR     r11, Screen_y1
        ADD     r1, r11, #grid_y_spacing
        SUB     r2, r1, r6
        DivRem  r1, r2, r10, r0, norem
        MUL     r2, r1, r10
        SUB     r9, r11, r2
        B       %FT08
06      ; If tidy to bottom
        LDR     r0, icon_bar_height
        SUB     r6, r6, r0                   ; grid starts above icon bar, so subtract
        CMP     r6, #0                       ; it's height.
        MOVLT   r6, #0
        MOV     r10, #grid_y_spacing
        DivRem  r1, r6, r10, r2, norem
        MLA     r9, r1, r10, r0              ; y = (mouse_y DIV y_spacing) * y_spacing) + icon_bar_height

08 ; Get the state of the icon where the drag was started
        ADR     r1, dataarea
        LDR     r0, drag_window
        STR     r0, [r1]
        LDR     r0, drag_icon
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState
        EXIT    VS

        LDR     r5, [r1, #8]                 ; min x
        LDR     r6, [r1, #16]                ; max x
        MOV     r7, #grid_x_spacing
        SUB     r0, r6, r5                   ; icon width
        SUBS    r0, r7, r0
        MOVMI   r0, #0
        ADD     r8, r8, r0, LSR #1           ; x = x + 0.5(grid_x_spacing - icon_width)
        SUB     r8, r8, r5

        LDR     r5, [r1, #12]                ; min y
        LDR     r6, [r1, #20]                ; max y
        MOV     r7, #grid_y_spacing
        SUB     r0, r6, r5                   ; icon height
        SUBS    r0, r7, r0
        MOVMI   r0, #0
        ADD     r9, r9, r0, LSR #1           ; y = y + 0.5(grid_y_spacing - icon_height)
        SUB     r9, r9, r5

        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DragIconsToApp
;
; Result of drag end was that icons ended up on another application. Send FilerSelection
; and then DataLoad messages.
;
; In: r2 = window handle of destination
;     r3 = icon handle of destination
;
; Out: Registers may be corrupted

DragIconsToApp

        Push    "r2-r3"                  ; Push window and icon handle

         ; Adjust bbox returned by Wimp_Poll to same size as original (for DragASprite).
        ADR     r1,DragBBOX
        LDMIA   r1,{r6,r7,r8,r9}
        SUB     r2,r8,r6
        SUB     r3,r9,r7
        ADR     r1,dataarea
        LDMIA   r1,{r6,r7,r8,r9}
        ADD     r8,r6,r2
        SUB     r7,r9,r3

        ; Setup message block
        ADR     r1,dataarea
        ADD     r14,r1,#ms_data
        STMIA   r14!,{r6,r7,r8,r9}      ; Drag BBOX
        ADR     r0,DragBBOX
        LDMIA   r0,{r6,r7,r8,r9}        ; Get original box.

        MOV     r4,#grid_x_spacing
        STR     r4,[r14],#4             ; width of each selected item
        MOV     r5,#grid_y_spacing
        ADD     r7,r7,r5
        SUB     r7,r7,#1
        STR     r5,[r14],#4             ; height of each selected item

        MOV     r0,#0
        STR     r0,[r14],#4             ; Display mode is always 0 (large icons sort by name)

        ; Left column = bbox_left / grid_x_spacing
        DivRem  r10,r6,r4,r0,norem
        STR     r10,[r14],#4

        ; Top row = (screen_y - bbox_top) / grid_y_spacing
        LDR     r10,Screen_y1
        SUB     r9,r10,r9
        DivRem  r10,r9,r5,r0,norem
        STR     r10,[r14],#4

        ; Right column = bbox_right / grid_x_spacing
        DivRem  r10,r8,r4,r0,norem
        STR     r10,[r14],#4

        ; Bottom row = (screen_y - bbox_bottom) / grid_y_spacing
        LDR     r10,Screen_y1
        SUB     r7,r10,r7
        DivRem  r10,r7,r5,r0,norem
        STR     r10,[r14],#4

        MOV     r0,#0
        STR     r0,[r1,#ms_myref]       ; my ref
        STR     r0,[r1,#ms_yourref]     ; your ref
        MOV     r0,#ms_data+11*4
        STR     r0,[r1,#ms_size]        ; message size
        LDR     r0,=Message_FilerSelection
        STR     r0,[r1,#ms_action]      ; message action
        MOV     r0,#17
        Pull    "r2-r3"                 ; Pull window and icon handle
        SWI     XWimp_SendMessage
        Pull    "pc", VS

        ; Check if it was the filer
        LDR     r14,Filer_taskid
        TEQ     r2,r14
        BEQ     SendToFiler

        ; This isn't the filer, simply send data load messages for each icon.
        ; And deselect it.
        LDR     r10, Icon_list
01
        CMP     r10, #0                  ; last icon?
        Pull    "pc", EQ

        LDR     r3, DragWindow
        ADR     r1, dataarea
        LDR     r0, [r10, #ic_window]
        CMP     r0, r3                   ; Check if icon is in window drag originated from
        BNE     %FT10

        STR     r0, [r1]
        LDR     r0, [r10, #ic_icon]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState       ; Get icon state
        Pull    "pc", VS

        LDR     r0, [r1, #24]
        TST     r0, #selected
        BEQ     %FT10                    ; Not selected

        MOV     r0, #0
        STR     r0, [r1, #8]
        CMP     r3,#0
        MOVGT   r0,#is_selected
        MOVLT   r0,#selected
        STR     r0, [r1, #12]
        SWI     XWimp_SetIconState       ; Deselect icon

        CMP     r3, #0
        LDRGT   r0, Pinboard_Selected
        LDRLT   r0, TinyDirs_Selected
        SUB     r0, r0, #1
        STRGT   r0, Pinboard_Selected
        STRLT   r0, TinyDirs_Selected   ; Update number of icons selected.

        ADR     r0, PointerInfo
        LDMIA   r0, {r4, r5, r6, r7, r8} ; x,y,b,w,i
        ADD     r0, r1, #ms_data
        STMIA   r0!, {r7, r8}            ; w,i
        STMIA   r0!, {r4, r5}
        MOV     r4, #1
        STR     r4, [r0], #4            ; estimated size.
        LDR     r4, [r10, #ic_filetype]
        STR     r4, [r0], #4
        MOV     r1, r0
        ADD     r0, r10, #ic_path
        BL      Copy_r0r1
        ADD     r1, r1, #3+1            ; Include null.
        BIC     r1, r1, #3
        MOV     r0, #-1
        STR     r0, [r1], #4
        STR     r0, [r1], #4            ; Column, Row

        MOV     r0, r1
        ADR     r1, dataarea
        SUB     r0, r0, r1
        STR     r0, [r1, #ms_size]
        MOV     r0, #Message_DataLoad
        STR     r0, [r1, #ms_action]
        MOV     r0, #0
        STR     r0, [r1, #ms_myref]
        STR     r0, [r1, #ms_yourref]
        MOV     r0, #18
        LDR     r2, [r1, #ms_data]
        LDR     r3, [r1, #ms_data+4]
        SWI     XWimp_SendMessage
        Pull    "pc", VS
10
        LDR     r10, [r10, #ic_next]
        B       %BT01


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SendToFiler
;
; The destination of a drag was a Filer window.
; We want to save files to the filer, send
; DataSave to find out the directory.

SendToFiler     ROUT

        Debug   pi,"Send to filer"

        ADR     r1,dataarea
        ADR     r14,PointerInfo
        MOV     r0,#0
        STR     r0,[r1,#ms_myref]
        STR     r0,[r1,#ms_yourref]
        MOV     r0,#Message_DataSave
        STR     r0,[r1,#ms_action]
        LDR     r0,[r14,#12]             ; Window
        STR     r0,[r1,#ms_data]
        LDR     r0,[r14,#16]             ; Icon
        STR     r0,[r1,#ms_data+4]
        LDR     r0,[r14]                 ; X
        STR     r0,[r1,#ms_data+8]
        LDR     r0,[r14,#4]              ; Y
        STR     r0,[r1,#ms_data+12]
        MOV     r0,#1                    ; Estimated size.
        STR     r0,[r1,#ms_data+16]
        MOV     r0,#0                    ; File type
        STR     r0,[r1,#ms_data+20]
        MOV     r0,#65
        STR     r0,[r1,#ms_data+44]      ; Proposed leaf name ("A").

        MOV     r0,#18
        SWI     XWimp_SendMessage

        Pull    "PC"


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Run_Selection
;
; The destination of a drag of icons was a bare piece of icon bar. So, we Filer_Run
; any selected files.

Run_Selection   ROUT

        LDR     r10,Icon_list
01
        CMP     r10,#0
        Pull    "PC",EQ

        LDR     r14,[r10,#ic_window]
        LDR     r3,DragWindow
        TEQ     r14,r3
        BNE     %FT10

        ADR     r1,dataarea
        LDR     r0,[r10,#ic_icon]
        STR     r3,[r1]
        STR     r0,[r1,#4]
        SWI     XWimp_GetIconState
        Pull    "PC",VS

        LDR     r0,[r1,#24]
        TST     r0,#selected
        BEQ     %FT10                   ; Not selected

        MOV     r0,#0
        STR     r0,[r1,#8]
        CMP     r3,#0
        MOVGT   r0,#is_selected
        MOVLT   r0,#selected
        STR     r0,[r1,#12]
        SWI     XWimp_SetIconState      ; Deselect

        CMP     r3,#0
        LDRGE   r0,Pinboard_Selected
        LDRLE   r0,TinyDirs_Selected
        SUB     r0,r0,#1
        STRGE   r0,Pinboard_Selected
        STRLE   r0,TinyDirs_Selected
        Debug   pi,"Selected icons = ",r0

        ADR     r1,dataarea
        ADRL    r0,FilerRunCom
        BL      Copy_r0r1
        ADD     r0,r10,#ic_path
        BL      Copy_r0r1
        ADR     r0,dataarea
        SWI     XWimp_StartTask
        Pull    "PC",VS

10
        LDR     r10,[r10,#ic_next]
        B       %BT01

        LTORG

        LNK     Menu.s
@


4.8
log
@Shade "Configure..." when boot was unsuccessful.
When BootResources$Path is unset the option to run the configure plugin is no longer available.
Shared a "Filer_Run " string in 3x places.
Replaced most occurrences of calling XOS_ReadModeVariable of the current mode's XEig and YEig factors to use the cached copy sitting unloved in the workspace. Should thrash less during redraw.

Version 0.93. Tagged as 'Pinboard-0_93'
@
text
@d362 1
a362 1
        DivRem  r1, r5, r10, r2
d370 1
a370 1
        DivRem  r1, r2, r10, r0
d382 1
a382 1
        DivRem  r1, r2, r10, r0
d392 1
a392 1
        DivRem  r1, r6, r10, r2
d468 1
a468 1
        DivRem  r10,r6,r4,r0
d474 1
a474 1
        DivRem  r10,r9,r5,r0
d478 1
a478 1
        DivRem  r10,r8,r4,r0
d484 1
a484 1
        DivRem  r10,r7,r5,r0
@


4.7
log
@Collapse dead switches.
Same binary as 0.92, not tagged.
@
text
@d664 1
a664 1
        ADR     r0,Run_command
a675 3
Run_command     DCB     "Filer_Run ",0
        ALIGN

@


4.6
log
@Restore *AddTinyDir <nothing> functionality.
See ticket #283.
Moved 'Status' document into Docs.
Merged 'Changes' into 'BlackLog' and delete.
Expanded 2x POPs of lr/pc cos ARM deprecated it.
Combined 2x MUL/ADD into MLA so the module is the same size.

Version 0.92. Tagged as 'Pinboard-0_92'
@
text
@a205 174

 [ Version < 69
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectDragIcon_end
; old version

SelectDragIcon_end      ROUT
        MOV     r0,#DragType_NoDrag
        STR     r0,DragType

        ; Adjust bbox to same size as original (for DragASprite).
        ADR     r1,DragBBOX
        LDMIA   r1,{r6,r7,r8,r9}
        SUB     r2,r8,r6
        SUB     r3,r9,r7
        ADR     r1,dataarea
        LDMIA   r1,{r6,r7,r8,r9}
        ADD     r8,r6,r2
        SUB     r7,r9,r3

        ADR     r1,PointerInfo
        SWI     XWimp_GetPointerInfo    ; Find out where it ended.
        LDR     r2,[r1,#12]             ; Window
        LDR     r3,[r1,#16]             ; Icon
        ADR     r1,dataarea

        CMP     r2,#-2
        CMPLE   r3,#-1
        BEQ     Run_Selection           ; Dragged to empty part of icon bar, run it !

; Send a Message_FilerSelection

        ADD     r14,r1,#ms_data
        STMIA   r14!,{r6,r7,r8,r9}      ; Drag BBOX
        ADR     r0,DragBBOX
        LDMIA   r0,{r6,r7,r8,r9}        ; Get original box.

        MOV     r4,#grid_x_spacing
        STR     r4,[r14],#4
        MOV     r5,#grid_y_spacing
        ADD     r7,r7,r5
        SUB     r7,r7,#1
        STR     r5,[r14],#4             ; Width & height of icons.

        MOV     r0,#0
        STR     r0,[r14],#4             ; Display mode is always 0 (large icons sort by name)

        DivRem  r10,r6,r4,r0
        STR     r10,[r14],#4            ; Leftmost column
        Debug    pi,"Left: ",r10

        LDR     r10,Screen_y1
        SUB     r9,r10,r9
        DivRem  r10,r9,r5,r0            ; Top row
        STR     r10,[r14],#4
        Debug    pi,"Top: ",r10

        DivRem  r10,r8,r4,r0            ; Rightmost column
        STR     r10,[r14],#4
        Debug    pi,"Right: ",r10

        LDR     r10,Screen_y1
        SUB     r7,r10,r7
        DivRem  r10,r7,r5,r0            ; Bottom row
        STR     r10,[r14],#4
        Debug    pi,"Bottom: ",r10

        MOV     r0,#0
        STR     r0,[r1,#ms_myref]
        STR     r0,[r1,#ms_yourref]
        MOV     r0,#ms_data+11*4
        STR     r0,[r1,#ms_size]
        LDR     r0,=Message_FilerSelection
        STR     r0,[r1,#ms_action]
        MOV     r0,#17
        SWI     XWimp_SendMessage
        Pull    "PC",VS

        LDR     r14,Filer_taskid
        TEQ     r2,r14
        BEQ     SendToFiler

        Debug   pi,"Not filer"

        ; This isn't the filer, simply send data load messages for each icon.
        ; And deselect it.


        LDR     r10,Icon_list
01
        CMP     r10,#0
        Pull    "PC",EQ

        LDR     r3,DragWindow
        ADR     r1,dataarea
        LDR     r0,[r10,#ic_window]      ; Not in drag window.
        TEQ     r0,r3
        BNE     %FT10

        LDR     r0,[r10,#ic_icon]
        STR     r3,[r1]
        STR     r0,[r1,#4]
        SWI     XWimp_GetIconState
        Pull    "PC",VS

        LDR     r0,[r1,#24]
      [ Version >= 31
        TST     r0,#selected
      |
        TST     r0,#is_selected
      ]
        BEQ     %FT10                   ; Not selected

        MOV     r0,#0
        STR     r0,[r1,#8]
      [ Version >= 31
        CMP     r3,#0
        MOVGT   r0,#is_selected
        MOVLT   r0,#selected
      |
        MOV     r0,#is_selected
      ]
        STR     r0,[r1,#12]
        SWI     XWimp_SetIconState      ; Deselect

        CMP     r3,#0
        LDRGE   r0,Pinboard_Selected
        LDRLE   r0,TinyDirs_Selected
        SUB     r0,r0,#1
        STRGE   r0,Pinboard_Selected
        STRLE   r0,TinyDirs_Selected
        Debug   pi,"Selected icons = ",r0

        ADR     r0,PointerInfo
        LDMIA   r0,{r4,r5,r6,r7,r8}     ; x,y,b,w,i
        ADD     r0,r1,#ms_data
        STMIA   r0!,{r7,r8}       ; w,i
        STMIA   r0!,{r4,r5}
        MOV     r4,#1
        STR     r4,[r0],#4              ; estimated size.
        LDR     r4,[r10,#ic_filetype]
        STR     r4,[r0],#4
        MOV     r1,r0
        ADD     r0,r10,#ic_path
        BL      Copy_r0r1
        ADD     r1,r1,#3+1              ; Include null.
        BIC     r1,r1,#3
        MOV     r0,#-1
        STR     r0,[r1],#4
        STR     r0,[r1],#4              ; Column, Row !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        MOV     r0,r1
        ADR     r1,dataarea
        SUB     r0,r0,r1
        STR     r0,[r1,#ms_size]
        MOV     r0,#Message_DataLoad
        STR     r0,[r1,#ms_action]
        MOV     r0,#0
        STR     r0,[r1,#ms_myref]
        STR     r0,[r1,#ms_yourref]
        MOV     r0,#18
        LDR     r2,[r1,#ms_data]
        LDR     r3,[r1,#ms_data+4]
        SWI     XWimp_SendMessage
        Pull    "PC",VS

10
        LDR     r10,[r10,#ic_next]
        B       %BT01

        Pull    "PC"
 ]


@


4.5
log
@  Different way of doing escape-aborts-drag implementation
Detail:
  Although the previous check-in works, it uses EventV to trap escape key
  press events. This mechanism doesn't stop them from being passed on to
  whoever has input focus (e.g. a task window).

  The new way to do things is to grab input focus when a drag starts and
  to restore it (if possible) when the drag f we abort the drag (and restore focus). All other keys
  are passed on to the Wimp.

  The side-effect is that any window which has focus will temporarily lose
  focus for the duration of a Pinboard drag op I think we can
  live with that.
Admin:
  Tested on Iyonix and works fine. Now, if only the Filer did this, too...

Version 0.83. Tagged as 'Pinboard-0_83'
@
text
@d567 1
a567 2
        MUL     r9, r1, r10                  ; y = (mouse_y DIV y_spacing) * y_spacing
        ADD     r9, r9, r0
@


4.4
log
@Commented out "proginfo" string,no longer used.
Prefixed the pin and addtinydir commands that get saved in the
pinboard file with "X " so your pinboard setup continues even if a file
is no longer available.ROL did this with a new XPin command,not taken.
Merged changes from ROL to allow the icon text to be an arbitary colour
though this can be switched out with "technicolour_text" for the
purists.
Help entry added to the pinboard selection submenu,this will be greyed
out except when
 it's an app
 and it has a !help file
 and it is the only object selected
like the filer does.
Updated messages file accordingly.
Menu clicking on the "save pinboard settings" OK button no longer saves
the file,and adjust clicking keeps the menu tree open
 -> fixes bug report from 1998,now removed from "Status" file
Saveas template resized to match !Edit.
Fixed problem of select dragging a file to an app leaving the icon
selected (due to two conditional MOV R0's being followed by an
unconditional one for some reason).
 -> fixes bug report from 1998,now removed from "Status" file
Tweaked a few CMP#0 BLT's to test specifically for the iconbar handle.
The bug report in "Status" about bits of filenames being left on the
pinboard can be bodged by popping an ADD r0,r0,#16 after the XWimp_TextOp
in s.buffered but I've not done this yet.

Version 0.78. Tagged as 'Pinboard-0_78'
@
text
@d37 2
d85 2
d161 2
d213 3
d390 2
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.76. Tagged as 'Pinboard-0_76'
@
text
@d693 3
a695 4
        CMP     r3, #0
        MOVGT   r0, #is_selected
        MOVLE   r0, #selected
        MOV     r0, #0
@


4.2
log
@Ursula branch merged.
Added inclusion of Machine header for new CMOS header
Moved to srccommit.
Templates contain hardwired version/date information which is a long
  way out of date.  This has not been fixed in this checkin.

Version 0.75. Tagged as 'Pinboard-0_75'
@
text
@d44 1
a44 1
        
d56 1
a56 1
                
d87 1
a87 1
        MOVGT   r6,r8                   
d156 1
a156 1
Iconized_SelectDrag_end ENTRY
d162 1
a162 1
        
d189 1
a189 1
 
d198 3
a200 3
        
        
        
d403 1
a403 1
        LDMIA   r0, {r8, r9}           ; load x and y co-ordinate of start of drag        
d445 1
a445 1
        
d461 1
a461 1
        
d466 1
a466 1
        Pull    "pc", VS        
d482 1
a482 1
        
d494 1
a494 1
        
d515 2
a516 2
 
lock_movement_to_grid ENTRY "r0-r7, r10-r11"
d536 1
a536 1
        
d553 1
a553 1
        MOVLT   r6, #0 
d558 1
a558 1
        
d576 1
a576 1
        
d585 1
a585 1
         
d620 1
a620 1
        
d644 1
a644 1
        
d650 1
a650 1
 
d665 1
a665 1
        TEQ     r2,r14        
d697 1
a697 1
        STR     r0, [r1, #12]        
d742 1
a742 1
        
d747 1
a747 1
; The destination of a drag was a Filer window. 
d846 1
a846 1
        LNK     s.Menu
@


4.1
log
@Initial revision
@
text
@d15 2
d20 5
d26 1
d28 4
d44 1
d51 2
a52 1
        BEQ     Iconized_DragEnd
d56 1
d59 6
d70 7
d83 1
a83 1
        ADR     r1,dataarea
d87 1
a87 1
        MOVGT   r6,r8
d92 1
a92 1
        MOVGT   r9,r14
d96 1
a96 1
        LDR     r5,Icon_list
d98 3
a100 2
        CMP     r5,#0
        Pull    "PC",EQ                 ; End of list.
d104 1
a104 1
        SWI     XWimp_GetIconState
d107 1
a110 1

a113 1

a116 1

d130 1
a130 1
        STR     r3,[r1,#8]
d136 61
a196 1
        LDR     r5,[r5,#ic_next]
d198 7
d368 294
d663 80
a742 1
SendToFiler     ROUT
d744 4
d751 2
d782 7
a808 1
      [ Version >= 31
a809 3
      |
        TST     r0,#is_selected
      ]
a813 1
      [ Version >= 31
a816 3
      |
        MOV     r0,#is_selected
      ]
@


4.1.4.1
log
@Windows, as well as files, can be selected, plus new menu structure and options
@
text
@a17 5



; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; drag_end
a18 1
; Called upon receipt of User_Drag_Box event meaning a drag has ended.
a19 4
; In: r1 -> Wimp_Poll block
;
; Out: registers may be corrupted. Returning to wimp_poll.

a31 1
        
d38 1
a38 2
        BEQ     SelectDragIcon_end
        ;BEQ     Iconized_DragEnd
a43 6

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; AdjustDrag_end
;
; Called when user has finished dragging a selection with the right mouse button.

a48 7

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectDrag_end
;
; Called when the user has finished dragging out a selection, this function will attempt
; to select any icons within the bounding box.

d55 1
a55 1
        ADR     r1,dataarea             ; make sure that x0<x1 and y0<y1
d59 1
a59 1
        MOVGT   r6,r8                   
d64 1
a64 1
        MOVGT   r9,r14                  ; We now know x0<x1 and y0<y1
d68 1
a68 1
        LDR     r5,Icon_list            ; Load first icon in list
d70 2
a71 3
        CMP     r5,#0                   ; Have we reached end of list?
        ;Pull    "PC",EQ                 ; If so, then exit
        BEQ     %FT20
d75 1
a75 1
        SWI     XWimp_GetIconState      ; Get the state of this icon
a77 1
        ; Check Icon's bounds
d81 1
d85 1
d89 1
d103 1
a103 1
        STR     r3,[r1,#8]              ; Now set new state
d109 1
a109 61
        LDR     r5,[r5,#ic_next]        ; Load next icon in list
        B       %BT01

20
        BL      Iconized_SelectDrag_end
        Pull    "pc"


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Iconized_SelectDrag_end
;
; Called by SelectDrag_end, which is called after a selection has been dragged out on the
; pinboard, it attempts to select any iconized window icons within the bounding box.
;
; In: r6, r7, r8, r9 = Bounding box
;     r3, r4 = Clear and EOR states for SetIconState
;     r1 -> dataarea, of which r1+4 = window handle
;
; Out:

Iconized_SelectDrag_end ENTRY

        LDR     r5, iconized_ptr
01
        CMP     r5, #0
        EXIT    EQ
        
        LDR     r0, [r5, #w_icon_handle]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState
        EXIT    VS

        ; Check Icon's bounds
        LDR     r14, [r1, #8]           ; Icon's x0
        CMP     r14, r8
        BGT     %FT10                   ; > x1 !
        LDR     r14, [r1, #16]          ; Icon's x1
        CMP     r14, r6
        BLT     %FT10                   ; < x0 !
        LDR     r14, [r1, #12]          ; Icon's y0
        CMP     r14, r9
        BGT     %FT10                   ; > y1 !
        LDR     r14, [r1, #20]          ; Icon's y1
        CMP     r14, r7
        BLT     %FT10                   ; < y0 !

        LDR     r0, Windows_Selected
        LDR     r14, [r1,#24]           ; Get icon flags
        TST     r14, #is_selected
        ADDEQ   r0, r0, #1              ; If it wasn't selected it will be
        CMPNE   r4, #is_selected        ; If it was is this adjust ?
        SUBNE   r0, r0, #1              ; If it is, it won't be.
        STR     r0, Windows_Selected
 
        STR     r3,[r1,#8]              ; Now set new state
        STR     r4,[r1,#12]
        SWI     XWimp_SetIconState
        EXIT    VS

10
        LDR     r5,[r5,#w_next_ptr]     ; Load next icon in list
a110 7
        
        
        
 [ Version < 69
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectDragIcon_end
; old version
a273 1
 ]
d275 1
a276 385
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectDragIcon_end
;
; Called after the user has finished dragging a selection of icons.
;
; In: r1 -> Wimp_Poll block
;
; Out: registers may be corrupted - returning to Poll loop.

SelectDragIcon_end

        ; Find out where it ended
        ADR     r1, PointerInfo
        SWI     XWimp_GetPointerInfo
        LDR     r2, [r1, #12]          ; Window
        LDR     r3, [r1, #16]          ; Icon

        CMP     r2, #-2
        CMPLE   r3, #-1
        BEQ     Run_Selection         ; Dragged to empty part of icon bar, run it !

        LDR     r0, backdrop_handle
        CMP     r2, r0                 ; If destination wasn't the backdrop, call
        BNE     DragIconsToApp         ; appropriate function

        LDR     r5, drag_window
        CMP     r5, r2                 ; If source wasn't the backdrop
        BNE     DragIconsToApp

        ; Work out relative movement
        LDMIA   r1, {r5, r6}           ; get x and y of destination
        ADR     r0, drag_start
        LDMIA   r0, {r8, r9}           ; load x and y co-ordinate of start of drag        
        SUB     r8,r5,r8
        SUB     r9,r6,r9               ; Get relative movement

        ; If grid lock is on, make the relative movement a multiple of the spacing
        LDR     r0, Pinboard_options
        TST     r0, #PinboardOption_Grid
        BLNE    lock_movement_to_grid

; Now we have to loop through all icons and windows, test if they are selected
; and if so, move them.
; At this point, r8 = relative x movement
;                r9 = relative y movement
01
        ADR     r6, dataarea
        LDR     r0, backdrop_handle
        STR     r0, [r6]
        LDR     r7, Icon_list
        MOV     r11, #0                ; Says we're on Icon_list
02
        CMP     r7, #0                 ; Is this the last icon?
        BEQ     %FT10

        ; Check icon is on backdrop
        LDR     r0, backdrop_handle
        LDR     r1, [r7, #ic_window]
        CMP     r1, r0
        BNE     %FT04

        ; Get icon's state
        LDR     r0, backdrop_handle
        STR     r0, [r6]
        LDR     r0, [r7, #ic_icon]
        STR     r0, [r6, #4]
        MOV     r1, r6
        SWI     XWimp_GetIconState
        EXIT    VS

        ; Check if icon is selected
        LDR     r0, [r6, #24]
        TST     r0, #is_selected
        BEQ     %FT04
        
        ; Force redraw of old icon position
        Push    "r0-r4"
        ADD     r0, r1, #8
        LDMIA   r0, {r1-r4}
        LDR     r0, backdrop_handle
        SWI     XWimp_ForceRedraw
        Pull    "r0-r4"

        ; Work out new position
        ADD     r0, r6, #8
        LDMIA   r0, {r2-r5}
        ADD     r2, r2, r8
        ADD     r3, r3, r9
        ADD     r4, r4, r8
        ADD     r5, r5, r9
        
        ; Move (resize) icon
        LDR     r0, backdrop_handle
        LDR     r1, [r7, #ic_icon]
        SWI     XWimp_ResizeIcon
        EXIT    VS        

        ; Update x and y in linked list
        CMP     r11, #0
        STREQ   r2, [r7, #ic_x]
        STREQ   r3, [r7, #ic_y]

        ; Change it's state so it is no longer selected
        ; (this will also redraw icon at new position)
        MOV     r0, #is_selected
        STR     r0, [r6, #8]
        MOV     r0, #0
        STR     r0, [r6, #12]
        MOV     r1, r6
        SWI     XWimp_SetIconState
        EXIT    VS
        
        ; Update number of icons selected
        CMP     r11, #0
        LDREQ   r0, Pinboard_Selected
        LDRNE   r0, Windows_Selected
        SUB     r0, r0, #1
        CMP     r11, #0
        STREQ   r0, Pinboard_Selected
        STRNE   r0, Windows_Selected
04
        LDR     r7, [r7, #ic_next]
        B       %BT02
        
10 ; finishedfiles
        CMP     r11, #1
        BEQ     %FT20
        LDR     r7, iconized_ptr
        MOV     r11, #1
        B       %BT02

20 ; finishedall
        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; lock_movement_to_grid
;
; In: r0 - pinboard_options
;     r5, r6 - x co-ordinate of destination
;     drag_icon - icon where drag started
;
; Out: r8, r9 - relative movement x and y
;      All other regs preserved.
 
lock_movement_to_grid ENTRY "r0-r7, r10-r11"

        MOV     r4, r0

   ; Work out the x co-ord of the nearest grid position
        TST     r4, #PinboardOption_TidyToCornerLR
        BNE     %FT02
        ; If tidy to left
        MOV     r10, #grid_x_spacing
        DivRem  r1, r5, r10, r2
        MUL     r8, r1, r10                  ; x = (mouse_x DIV x_spacing) * x_spacing
        B       %FT04
02      ; If tidy to right
        MOV     r10, #grid_x_spacing
        LDR     r11, Screen_x1
        ADD     r1, r11, #grid_x_spacing
        SUB     r2, r1, r5
        DivRem  r1, r2, r10, r0
        MUL     r2, r1, r10
        SUB     r8, r11, r2
        
04 ; Work out the y co-ord of the nearest grid position
        TST     r4, #PinboardOption_TidyToCornerTB
        BNE     %FT06
        ; If tidy to top
        MOV     r10, #grid_y_spacing
        LDR     r11, Screen_y1
        ADD     r1, r11, #grid_y_spacing
        SUB     r2, r1, r6
        DivRem  r1, r2, r10, r0
        MUL     r2, r1, r10
        SUB     r9, r11, r2
        B       %FT08
06      ; If tidy to bottom
        LDR     r0, icon_bar_height
        SUB     r6, r6, r0                   ; grid starts above icon bar, so subtract
        CMP     r6, #0                       ; it's height.
        MOVLT   r6, #0 
        MOV     r10, #grid_y_spacing
        DivRem  r1, r6, r10, r2
        MUL     r9, r1, r10                  ; y = (mouse_y DIV y_spacing) * y_spacing
        ADD     r9, r9, r0
        
08 ; Get the state of the icon where the drag was started
        ADR     r1, dataarea
        LDR     r0, drag_window
        STR     r0, [r1]
        LDR     r0, drag_icon
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState
        EXIT    VS

        LDR     r5, [r1, #8]                 ; min x
        LDR     r6, [r1, #16]                ; max x
        MOV     r7, #grid_x_spacing
        SUB     r0, r6, r5                   ; icon width
        SUB     r0, r7, r0
        ADD     r8, r8, r0, LSR #1           ; x = x + 0.5(grid_x_spacing - icon_width)
        SUB     r8, r8, r5
        
        LDR     r5, [r1, #12]                ; min y
        LDR     r6, [r1, #20]                ; max y
        MOV     r7, #grid_y_spacing
        SUB     r0, r6, r5                   ; icon height
        SUB     r0, r7, r0
        ADD     r9, r9, r0, LSR #1           ; y = y + 0.5(grid_y_spacing - icon_height)
        SUB     r9, r9, r5
         
        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DragIconsToApp
;
; Result of drag end was that icons ended up on another application. Send FilerSelection
; and then DataLoad messages.
;
; In: r2 = window handle of destination
;     r3 = icon handle of destination
;
; Out: Registers may be corrupted

DragIconsToApp

        ;SWI     OS_WriteI+4
        ;SWI     OS_WriteI+26
        ;SWI     OS_WriteI+7
     
        Push    "r2-r3"                  ; Push window and icon handle

         ; Adjust bbox returned by Wimp_Poll to same size as original (for DragASprite).
        ADR     r1,DragBBOX
        LDMIA   r1,{r6,r7,r8,r9}
        SUB     r2,r8,r6
        SUB     r3,r9,r7
        ADR     r1,dataarea
        LDMIA   r1,{r6,r7,r8,r9}
        ADD     r8,r6,r2
        SUB     r7,r9,r3

        ; Setup message block
        ADR     r1,dataarea
        ADD     r14,r1,#ms_data
        STMIA   r14!,{r6,r7,r8,r9}      ; Drag BBOX
        ADR     r0,DragBBOX
        LDMIA   r0,{r6,r7,r8,r9}        ; Get original box.
        
        MOV     r4,#grid_x_spacing
        STR     r4,[r14],#4             ; width of each selected item
        MOV     r5,#grid_y_spacing
        ADD     r7,r7,r5
        SUB     r7,r7,#1
        STR     r5,[r14],#4             ; height of each selected item

        MOV     r0,#0
        STR     r0,[r14],#4             ; Display mode is always 0 (large icons sort by name)

        ; Left column = bbox_left / grid_x_spacing
        DivRem  r10,r6,r4,r0
        STR     r10,[r14],#4

        ; Top row = (screen_y - bbox_top) / grid_y_spacing
        LDR     r10,Screen_y1
        SUB     r9,r10,r9
        DivRem  r10,r9,r5,r0
        STR     r10,[r14],#4

        ; Right column = bbox_right / grid_x_spacing
        DivRem  r10,r8,r4,r0
        STR     r10,[r14],#4
        
        ; Bottom row = (screen_y - bbox_bottom) / grid_y_spacing
        LDR     r10,Screen_y1
        SUB     r7,r10,r7
        DivRem  r10,r7,r5,r0
        STR     r10,[r14],#4
 
        MOV     r0,#0
        STR     r0,[r1,#ms_myref]       ; my ref
        STR     r0,[r1,#ms_yourref]     ; your ref
        MOV     r0,#ms_data+11*4
        STR     r0,[r1,#ms_size]        ; message size
        LDR     r0,=Message_FilerSelection
        STR     r0,[r1,#ms_action]      ; message action
        MOV     r0,#17
        Pull    "r2-r3"                 ; Pull window and icon handle
        SWI     XWimp_SendMessage
        EXIT    VS

        ; Check if it was the filer
        LDR     r14,Filer_taskid
        TEQ     r2,r14        
        BEQ     SendToFiler

        ; This isn't the filer, simply send data load messages for each icon.
        ; And deselect it.
        LDR     r10, Icon_list
01
        CMP     r10, #0                  ; last icon?
        EXIT    EQ

        LDR     r3, DragWindow
        ADR     r1, dataarea
        LDR     r0, [r10, #ic_window]
        CMP     r0, r3                   ; Check if icon is in window drag originated from
        BNE     %FT10

        STR     r0, [r1]
        LDR     r0, [r10, #ic_icon]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState       ; Get icon state
        EXIT    VS

        LDR     r0, [r1, #24]
        TST     r0, #selected
        BEQ     %FT10                    ; Not selected

        ;SWI     OS_WriteI+73

        MOV     r0, #0
        STR     r0, [r1, #8]
        CMP     r3, #0
        MOVGT   r0, #is_selected
        MOVLT   r0, #selected
        STR     r0, [r1, #12]
        SWI     XWimp_SetIconState       ; Deselect icon

        ;SWI     OS_WriteI+74

        CMP     r3, #0
        LDRGT   r0, Pinboard_Selected
        LDRLT   r0, TinyDirs_Selected
        SUB     r0, r0, #1
        STRGT   r0, Pinboard_Selected
        STRLT   r0, TinyDirs_Selected   ; Update number of icons selected.

        ADR     r0, PointerInfo
        LDMIA   r0, {r4, r5, r6, r7, r8} ; x,y,b,w,i
        ADD     r0, r1, #ms_data
        STMIA   r0!, {r7, r8}            ; w,i
        STMIA   r0!, {r4, r5}
        MOV     r4, #1
        STR     r4, [r0], #4            ; estimated size.
        LDR     r4, [r10, #ic_filetype]
        STR     r4, [r0], #4
        MOV     r1, r0
        ADD     r0, r10, #ic_path
        BL      Copy_r0r1
        ADD     r1, r1, #3+1            ; Include null.
        BIC     r1, r1, #3
        MOV     r0, #-1
        STR     r0, [r1], #4
        STR     r0, [r1], #4            ; Column, Row

        MOV     r0, r1
        ADR     r1, dataarea
        SUB     r0, r0, r1
        STR     r0, [r1, #ms_size]
        MOV     r0, #Message_DataLoad
        STR     r0, [r1, #ms_action]
        MOV     r0, #0
        STR     r0, [r1, #ms_myref]
        STR     r0, [r1, #ms_yourref]
        MOV     r0, #18
        LDR     r2, [r1, #ms_data]
        LDR     r3, [r1, #ms_data+4]
        SWI     XWimp_SendMessage
        EXIT    VS

10
        LDR     r10, [r10, #ic_next]
        B       %BT01

        EXIT
        

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SendToFiler
;
; The destination of a drag was a Filer window. 
a279 2
SendToFiler     ROUT

a308 7

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Run_Selection
;
; The destination of a drag of icons was a bare piece of icon bar. So, we Filer_Run
; any selected files.

d329 1
d331 3
d338 1
d342 3
@


4.1.4.2
log
@Fixed bug which can cause Pinboard to die when dragging icons to other apps
@
text
@a53 1
                
d436 1
a436 1
        Pull    "pc", VS
d463 1
a463 1
        Pull    "pc", VS        
d478 1
a478 1
        Pull    "pc", VS
d500 1
a500 1
        Pull    "pc"
d597 4
d660 1
a660 1
        Pull    "pc", VS
d672 1
a672 1
        Pull    "pc", EQ
d684 1
a684 1
        Pull    "pc", VS
d690 2
d696 2
a697 3
        MOVLE   r0, #selected
        MOV     r0, #0
        STR     r0, [r1, #12]        
d700 2
d740 2
a741 1
        Pull    "pc", VS
d745 2
@


4.1.4.3
log
@Bug fixes.
Turned off defaultbackdrop and UseECFforLCD. Only needed on A4.
Updated service call handling to use new Ursula tables.
@
text
@d570 1
a570 2
        SUBS    r0, r7, r0
        MOVMI   r0, #0
d578 1
a578 2
        SUBS    r0, r7, r0
        MOVMI   r0, #0
@


4.1.4.4
log
@When the only window icons are on the iconbar, grey out the 'Select all'
menu item.
File 'Status' added giving Pinboard status after RPC2 cancellation.
@
text
@a0 16
; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;


@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

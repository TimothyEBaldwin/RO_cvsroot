head	4.13;
access;
symbols
	Pinboard-1_04:4.13
	Pinboard-1_03:4.12
	Pinboard-1_02:4.11
	Pinboard-1_01:4.11
	Pinboard-1_00:4.11
	Pinboard-0_99:4.11
	Pinboard-0_98:4.11
	Pinboard-0_97:4.11
	Pinboard-0_96:4.11
	Pinboard-0_95:4.10
	Pinboard-0_94:4.9
	Pinboard-0_93:4.8
	Pinboard-0_92:4.5
	Pinboard-0_91:4.5
	Pinboard-0_90:4.5
	Pinboard-0_89:4.5
	Pinboard-0_88:4.5
	Pinboard-0_87:4.5
	Pinboard-0_86:4.5
	Pinboard-0_85:4.5
	Pinboard-0_84:4.5
	Pinboard-0_83:4.5
	Pinboard-0_82:4.5
	RO_5_07:4.5
	Pinboard-0_81:4.5
	Pinboard-0_80:4.4
	Pinboard-0_79:4.4
	Pinboard-0_78:4.4
	Pinboard-0_77:4.3
	Pinboard-0_76:4.3
	Ursula_merge:4.1.4.6
	Pinboard-0_75:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.6
	Ursula_RiscPC:4.1.4.6.0.2
	rleggett_Pinboard-0_75d:4.1.4.6
	rthornb_UrsulaBuild-19Aug1998:4.1.4.6
	UrsulaBuild_FinalSoftload:4.1.4.6
	rthornb_UrsulaBuild-12Aug1998:4.1.4.6
	aglover_UrsulaBuild-05Aug1998:4.1.4.6
	rthornb_UrsulaBuild-29Jul1998:4.1.4.6
	rthornb_UrsulaBuild-22Jul1998:4.1.4.6
	rleggett_Pinboard-0_75c:4.1.4.6
	rleggett_Pinboard-0_75b:4.1.4.6
	rleggett_Pinboard-0_75:4.1.4.6
	rthornb_UrsulaBuild-15Jul1998:4.1.4.6
	rthornb_UrsulaBuild-07Jul1998:4.1.4.6
	rthornb_UrsulaBuild-17Jun1998:4.1.4.6
	rthornb_UrsulaBuild-03Jun1998:4.1.4.6
	rthornb_UrsulaBuild-27May1998:4.1.4.6
	rthornb_UrsulaBuild-21May1998:4.1.4.5
	rleggett_Pinboard-0_74:4.1.4.5
	rthornb_UrsulaBuild_01May1998:4.1.4.5
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.13
date	2018.07.01.12.00.14;	author jlee;	state Exp;
branches;
next	4.12;
commitid	t2MoBfZGMUbPCqIA;

4.12
date	2017.05.06.09.46.26;	author rool;	state Exp;
branches;
next	4.11;
commitid	0B1LpIyDG92VpjQz;

4.11
date	2012.09.11.19.31.13;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	wgigNNHV7grve9kw;

4.10
date	2012.08.23.19.59.06;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	rztFpV1VBvCVZHhw;

4.9
date	2011.09.28.20.30.38;	author jlee;	state Exp;
branches;
next	4.8;
commitid	yL3Exo8v4LfpMiBv;

4.8
date	2011.09.24.07.31.19;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	nRjnbtmOSxK1BIAv;

4.7
date	2011.09.24.07.25.50;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	NapphrXjtkIXyIAv;

4.6
date	2011.09.24.07.23.44;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	U6nT8u4TlrjayIAv;

4.5
date	2003.07.31.12.55.12;	author rsprowson;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.11.12.34.50;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2001.03.16.17.07.02;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.08.17.19.05.15;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.58;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.58;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.29.41;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.08.04.11.50.05;	author rleggett;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.09.24.15.29.13;	author rleggett;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.10.21.09.56.51;	author rleggett;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.01.07.10.28.32;	author rleggett;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.04.15.11.24.36;	author rleggett;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.05.26.11.14.24;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.20.44;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.18.38;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.13
log
@Fix pinboard sprite caching to take into account changes in mode RGB order & alpha blending
Detail:
  s/Backdrop - Change the construction of the "compact mode word" representing the screen mode to include the RGB & alpha mode flags, so that the sprite will be re-cached when switching between screen modes with different RGB & alpha settings
Admin:
  Tested on Raspberry Pi 3


Version 1.04. Tagged as 'Pinboard-1_04'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; s.Backdrop
;
; Handles backdrop window and sprite.




      [ defaultbackdrop
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; CheckLCD
;
; If supporting an LCD use a patterned default backdrop which shimmers less
;
CheckLCD
        Push    "r0-r3,lr"

        LDR     r0,backdrop_options
        TST     r0,#bd_OptionActive    ; do nothing if there is already a backdrop
        Pull    "r0-r3,pc",NE

        MOV     r0,#1
        SWI     XOS_ReadSysInfo
        CMP     r1,#5                   ; check for LCD
        Pull    "r0-r3,pc",NE

        ADR     r2,LCDbackdroptile      ; allocate memory for file name (so *Backdrop works)
        BL      strlen
        MOV     r0,#ModHandReason_Claim
        SWI     XOS_Module
        Pull    "r0-r3,pc",VS

        STR     r2,backdrop_path        ; copy path name
        MOV     r1,r2
        ADR     r0,LCDbackdroptile
        BL      Copy_r0r1

        MOV     r0,#bd_OptionTiled :OR: bd_OptionRecache
        STR     r0,backdrop_options

        LDR     r0,poll_word
        ORR     r0,r0,#PollWordReason_Recache
        STR     r0,poll_word

        Pull    "r0-r3,pc"

LCDbackdroptile
        DCB     "Pinboard:LCDTile",0
        ALIGN
      ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; MakeCompactModeWord
;
; Formulate a word that expresses bpp, eigen, palette, RGB+alpha all in one
;
; Out : r0 = compact word
;       r2 = sprite mode descriptor

MakeCompactModeWord
        Push    "r1, lr"
        MOV     r0, #OsByte_CursorCharacterAndMode
        SWI     XOS_Byte
        Pull    "r1, pc",VS

        CMP     r2, #256                ; Old style mode number limit
        MOVCC   r0, r2                  ; Numbered modes are unique
        Pull    "r1, pc",CC

        SUB     sp, sp, #20*4

        MOV     r1, sp
        SWI     XWimp_ReadPalette
        MOV     r0, #0                  ; Checksum
        MOV     r14, #20                ; Index
10
        SUBS    r14, r14, #1
        LDRB    r1, [sp, r14, LSL #2]
        ADD     r0, r0, r1
        BNE     %BT10

        ADD     sp, sp, #20*4

        ; Mix into &Fxybcccc
        LDRB    r14, [r2, #12]          ; Pixel depth
        ORR     r0, r0, r14, LSL #16
        LDRB    r14, YEig
        ORR     r0, r0, r14, LSL #20
        LDRB    r14, XEig
        ORR     r0, r0, r14, LSL #24
        ORR     r0, r0, #&C0000000      ; Make sure a 1bpp EX0 EY0 mode can't be mistaken
                                        ; for old style mode 0
        ; Store RGB+alpha flags too
        BIC     r0, r0, #&30000000
        Push    "r0,r2"
        MOV     r0, #-1
        MOV     r1, #VduExt_ModeFlags
        SWI     XOS_ReadModeVariable
        ASSERT  &30000000 = (ModeFlag_DataFormatSub_RGB+ModeFlag_DataFormatSub_Alpha) :SHL: 14
        AND     lr, r2, #ModeFlag_DataFormatSub_RGB+ModeFlag_DataFormatSub_Alpha
        Pull    "r0,r2"
        ORR     r0, r0, lr, LSL #14

        CLRV
        Pull    "r1, pc"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; [Int_]ModeChange
;
; The mode has changed, recalculate bounds and tiles
;

Int_ModeChange
        Push    "lr"
ModeChange

        Debug   bd,"Mode Change"

        [ truncate_filenames
        BL      read_font_widths
        ]

        BL      read_mode_variables
        LDR     r0,backdrop_handle
        STR     r0,[r1],#4
        ADR     r2,bounding_box
        LDMIA   r2,{r2,r3,r4,r5}
        ADD     r4,r4,#100
        ADD     r5,r5,#100
        STMIA   r1,{r2,r3,r4,r5}
        SWI     XWimp_SetExtent
        Pull    "PC",VS

        Debug   bd,"Extent set."

        BL      set_icon_bar_height
      [ useECFforLCD
        BL      setupECF
      ]

; new extent set, now open the window.

        ADR     r1,dataarea
        LDR     r0,icon_bar_height
        STR     r0 ,[r1,#8]             ; Don't cover icon bar
        MOV     r6,#-2
        ADD     r0,r1,#20
        STMIA   r0,{r4,r5,r6}
        SWI     XWimp_OpenWindow
        Pull    "PC",VS
        Debug   bd,"Opened window"

        MOV     r0,#-1                  ; Current mode

        MOV     r1,#VduExt_XWindLimit
        SWI     XOS_ReadModeVariable
        MOVVC   r3,r2
        MOVVC   r1,#VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   r3,r3,ASL r2
        STRVC   r3,Screen_x1
        STRVC   r2,XEig

        MOVVC   r1,#VduExt_YWindLimit
        SWIVC   XOS_ReadModeVariable
        MOVVC   r3,r2
        MOVVC   r1,#VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   r3,r3,ASL r2
        STRVC   r3,Screen_y1
        STRVC   r2,YEig

        Pull    "PC",VS

        LDR     r0,backdrop_options
        TST     r0,#bd_OptionActive
      [ defaultbackdrop
        BNE     %FT01
        BL      CheckLCD                ; if no backdrop then check for LCD
        Pull    "PC"
01
      ]

        TSTNE   r0,#bd_OptionRecache
        Pull    "PC",EQ

        TST     r0, #bd_OptionJPEG
        BNE     %FT03
02
        BL      MakeCompactModeWord
        LDR     r14, CachedBackdropMode
        TEQ     r0, r14

        DebugIf NE, bd,"BackdropMode changed",r0,r14

        LDREQ   r0, CachedBackdrop_x1
        LDREQ   r14, Screen_x1
        TEQEQ   r0, r14
        LDREQ   r0, CachedBackdrop_y1
        LDREQ   r14, Screen_y1
        TEQEQ   r0, r14

        DebugIf NE, bd,"Backdrop mode changed, recacheing sprite"
03
        BLNE    CacheBackdropSprite
        Pull    "PC"

FontChanged
        [ truncate_filenames
        BL      read_font_widths
        ]
        LDR     R0,backdrop_handle
        [ {FALSE}
        SUB     R0,R0,#1
        LDR     R0,[R0,#168]                    ; num icons, NUM_ICONS
        |
        SUB     SP,SP,#128
        Push    "R0"
        MOV     R1,SP
        ORR     R1,R1,#1                       ; don't want icons
        SWI     XWimp_GetWindowInfo
        LDR     R0,[SP,#88]
        ADD     SP,SP,#132
        ]
        MOV     R1,#0
        STR     R0,All_PB_Icons
        TEQ     R0,R1
        Pull    "PC",EQ
fontchanged_loop
        LDR     R0,backdrop_handle
        SUB     SP,SP,#32
        Push    "R0,R1"
        MOV     R1,SP
        SWI     XWimp_GetIconState
        BVS     fontchanged_end
        LDR     R0,[sp,#24]             ; flags
        ADD     R1,sp,#28               ; text
        TST     R0,#if_text
        BEQ     fontchanged_next
        TST     R0,#if_indirected
        LDRNE   R1,[R1]
        MOV     R0,#1
        MOVNE   R2,#0
        MOVEQ   R2,#12
        SWI     XWimp_TextOp
        ADD     R14,sp,#8
        LDMIA   R14,{R2-R5}
        SUB     R14,R4,R2
        CMP     R14,R0
        ADDLT   R4,R2,R0                ; x1 = x0+width
        LDMIA   sp,{R0-R1}              ; not ! (!)
        SWI     XWimp_ResizeIcon
        BVS     fontchanged_end
fontchanged_next
        ADD     SP,SP,#40
        ADD     R1,R1,#1
        LDR     R0,All_PB_Icons
        TEQ     R0,R1
        Pull    "PC",EQ
        B       fontchanged_loop
fontchanged_end
        ADD     SP,SP,#40
        CLRV
        Pull    "PC"

      [ :LNOT: ursulawimp               ; No palette utility
PaletteChange

        Debug   bd,"Palette change"

        LDR     r0,backdrop_options
        TST     r0,#bd_OptionActive
        TSTNE   r0,#bd_OptionRecache
        Pull    "PC",EQ

        BL      CacheBackdropSprite

        Pull    "PC"
      ]


;---------------------------------------------------------------
; CacheBackdropSprite
;
; Cache backdrop sprite for current mode
;
; In :
;       [backdrop_path]  name of sprite file.
;
; Out:
;       Sprite cached for current mode.
;
; This must always be entered when we are the current task !

CacheBackdropSprite     ROUT
        Push    "LR"

        LDR     r0,backdrop_path
        CMP     r0,#0

 [ technicolour_text
        BGT     %FT01
        LDR     r0,backdrop_handle
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#&8000
        MOV     r4,#&8000
        SWI     XWimp_ForceRedraw
        Pull    "PC"
01
 |
        Pull    "PC",LE
 ]

        SWI     XHourglass_On
        BL      Int_CacheBackdropSprite
        BVS     %FT01

      [ debugspr
        MOV     r0,#&20C
        MOV     r1,#&8000
        ADR     r2,savedspritepath
        SWI     XOS_SpriteOp
        B       %FT20
savedspritepath DCB     "scsi::4.$.tmp.sprites.pbsaved"
        ALIGN
20
      ]

        SWI     XHourglass_Off
        LDR     r0,backdrop_handle
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#&8000
        MOV     r4,#&8000
        SWI     XWimp_ForceRedraw

        LDRVC   r0,backdrop_options
        ORRVC   r0,r0,#bd_OptionActive
        STRVC   r0,backdrop_options
        Pull    "PC",VC

01
        Push    "r0"                    ; If failed, free any used memory,
        SWI     XHourglass_Off
        MOV     r0,#0                   ; and mark as inactive.
        MOV     r1,#-1
        SWI     XWimp_SlotSize
        LDR     r0,backdrop_options
        BIC     r0,r0,#bd_OptionActive
        STR     r0,backdrop_options
        Pull    "r0"
        SETV
        Pull    "PC"


Int_CacheBackdropSprite ROUT

        Push    "LR"

; First check that the file still exists and is still a sprite file.


        MOV     r0,#OSFile_ReadWithTypeNoPath
        LDR     r1,backdrop_path
        SWI     XOS_File
        Pull    "PC",VS

        CMP     r0,#1
        MOVNE   r2,r0
        MOVNE   r0,#OSFile_MakeError
        SWINE   XOS_File
        Pull    "PC",VS

        ADD     r4,r4,#4
        STR     r4,file_size

        ; JPEG backdrop support
        LDR     r14,=&C85
        CMP     r6,r14
        BNE     %FT01
        BL      Int_CacheJPEG
        Pull    "PC"
01

        LDR     r14,=&FF9
        CMP     r6,r14
        ADRNEL  r0,ErrorBlock_Pinboard_NotASprite
        LDRNE   r4,backdrop_path
        BLNE    msgtrans_errorlookup
        Pull    "PC",VS

; It still exists !

; See how much memory we need to store it ...

        LDR     r0,backdrop_options
        BIC     r0, r0, #bd_OptionJPEG
        STR     r0, backdrop_options

        TST     r0,#bd_OptionScaled             ; Scaled ?
        BEQ     %FT01

; Sprite is scaled, get screen size (r4 = width, r5 = height)

        MOV     r0,#-1                          ; Use current mode

        MOV     r1,#VduExt_XWindLimit           ; Screen width in pixels
        SWI     XOS_ReadModeVariable
        ADDVC   r4,r2,#1
        STRVC   r4,scale_x1
        MOVVC   r1,#VduExt_YWindLimit           ; Screen height in pixels
        SWIVC   XOS_ReadModeVariable
        ADDVC   r5,r2,#1
        STRVC   r5,scale_y1
        Pull    "PC",VS

        B       %FT10                           ; Go allocate memory etc.

01

; We are not going to scale it so find out how big it will be in the current mode.

        MOV     r0,#open_read :OR: open_nopath :OR: open_mustopen :OR: open_nodir
        LDR     r1,backdrop_path
        SWI     XOS_Find                        ; Open for reading.
        Pull    "PC",VS

        MOV     r1,r0
        MOV     r0,#OSGBPB_ReadFromGiven        ; Read bytes from file
        ADR     r2,dataarea
        MOV     r3,#?saFirst
        MOV     r4,#saFirst - 4                 ; Sprite files are sprite areas with saEnd missing
        SWI     XOS_GBPB
        BVS     %FT05

        LDR     r0,dataarea
        SUB     r4,r0,#4
        Debug   bd,"Offset to sprite is ",r4
        MOV     r0,#OSGBPB_ReadFromGiven
        ADR     r2,dataarea
        MOV     r3,#SpriteCBsize
        SWI     XOS_GBPB                        ; Read sprite header
        BVC     %FT06
05
        Push    "r0"                            ; Preserve original error
        MOV     r0,#0
        SWI     XOS_Find
        ADDVS   sp,sp,#4
        Pull    "r0",VC
        SETV
        Pull    "PC"
        
        LTORG

06
        MOV     r0,#0
        SWI     XOS_Find

        ADR     r2,dataarea
        LDR     r0,[r2,#spMode]
        Debug   bd,"Sprite mode is ",r0

        LDR     r5,[r2,#spHeight]               ; Get height of sprite
        ADD     r5,r5,#1
        Debug   bd,"Sprite height is ",r5

        LDR     r4,[r2,#spWidth]                ; Get width in words
        MOV     r4,r4,LSL #5                    ; Max width in bits
        LDR     r3,[r2,#spRBit]                 ; Get last bit used
        Debug   bd,"Last bit = ",r3
        ADD     r4,r4,r3                        ; Adjust width
        LDR     r3,[r2,#spLBit]                 ; Get first bit used
        Debug   bd,"First bit = ",r3
        SUB     r4,r4,r3                        ; Adjust width
        ADD     r4,r4,#1                        ; Real width in bits
        MOV     r1,#VduExt_Log2BPP              ; get log2bpp for sprites mode
        SWI     XOS_ReadModeVariable
        Pull    "PC",VS
        MOV     r4,r4,LSR r2                    ; width in pixels
        Debug   bd,"Sprite width is ",r4

        MOV     r1,#VduExt_YEigFactor           ; Get YEig for sprite's mode
        SWI     XOS_ReadModeVariable
        Pull    "PC",VS
        MOV     r5,r5, ASL r2           ; Height in OS units in sprites mode
                                        
        MOV     r1,#VduExt_XEigFactor   ; Get XEig for sprite's mode
        SWI     XOS_ReadModeVariable    
        Pull    "PC",VS                 
        MOV     r4,r4, ASL r2           ; Width in OS units in sprites mode

        ; Now convert back to pixels for current mode
        LDR     r2, YEig
        MOVS    r5,r5, LSR r2           ; Height in pixels
        MOVEQ   r5,#1                   ; Must be minimum of 1 pixel
        MOV     r2,r5, LSL r2           ; Height in OS units in current mode
        STR     r2,scale_y1
        Debug   bd,"Height in OS units is ",r2

        LDR     r2, XEig
        MOVS    r4,r4, LSR r2           ; Width in pixels
        MOVEQ   r4,#1                   ; Must be minimum of 1 pixel
        MOV     r2,r4, LSL r2           ; Width in OS units in current mode
        STR     r2,scale_x1
        Debug   bd,"Width in OS units is ",r4

10
        MOV     r0,#-1
        MOV     r1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ; Get Log2BPP for current mode

        MOV     r3,r4,ASL r2            ; Width in bits
        ADD     r3,r3,#7
        MOV     r3,r3,LSR #3            ; Width in bytes
        ADD     r3,r3,#3
        BIC     r3,r3,#3                ; rounded up to nearest word

        MUL     r2,r3,r5                ; r2 = size in bytes

        Debug   bd,"Destination sprite width = ",r4
        Debug   bd,"Destination sprite height = ",r5
        Debug   bd,"Sprite size would be ",r2

        ADD     r2,r2,#&100
        STR     r2,slot_size            ; Amount for actual sprite.

; Now get size of sprite in file

        LDR     r0,file_size
        ADD     r2,r2,r0
        STR     r2,tmp_slot_size

; Now get the memory we need.

        MOV     r3,r2
        MOV     r0,r2
        MOV     r1,#-1
        Debug   bd,"Slot size required is ",r0
        SWI     XWimp_SlotSize
        MOVVS   r0,#0
        Debug   bd,"actual Slot size is ",r0

        CMP     r3,r0
        BLS     got_memory

        LDR     r0,backdrop_handle
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#&8000
        MOV     r4,#&8000
        SWI     XWimp_ForceRedraw

        ADRL    r0,ErrorBlock_Pinboard_NoRoom
        BL      msgtrans_errorlookup    ; V set on exit

        Pull    "PC"

got_memory

        Debug   bd,"Got memory, loading file"

        LDR     r14,backdrop_options
        ORR     r14,r14,#bd_OptionActive
        STR     r14,backdrop_options

        ; mark as active to stop memory from being stolen!

        MOV     r0,#OSFile_LoadNoPath
        LDR     r1,backdrop_path
        MOV     r2,#&8000
        LDR     r3,slot_size
        ADD     r2,r2,r3        ; Address to load file.
        LDR     r14,file_size
        STR     r14,[r2],#4
        Push    "r2,r4,r5"
        MOV     r3,#0           ; Load at given address
        SWI     XOS_File
        Pull    "r2,r4,r5"

        [ {FALSE}
        LDRVS   r14,backdrop_options
        BICVS   r14,r14,#bd_OptionActive
        STRVS   r14,backdrop_options
        ]

        BVC     LoadedOK

        Push    R0
        LDR     r0,backdrop_handle
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#&8000
        MOV     r4,#&8000
        SWI     XWimp_ForceRedraw

        Pull    R0
        SETV

        Pull    "PC"

LoadedOK

        Debug   bd,"File loaded."

        SUB     r1,r2,#4        ; Pointer to sprite area
        LDR     r2,[r1,#8]
        ADD     r2,r2,r1        ; Pointer to sprite
        Push    "r1,r2"

        MOV     r1,#&8000
        LDR     r2,slot_size
        STR     r2,[r1]
        MOV     r2,#&10
        STR     r2,[r1,#8]
        LDR     r0,=&100 + SpriteReason_ClearSprites
        SWI     XOS_SpriteOp

        Debug   bd,"Sprite area initialised"

        BLVC    MakeCompactModeWord
        ADDVS   sp,sp,#8
        Pull    "PC",VS

        MOV     r6, r2                  ; For SpriteReason_CreateSprite
        STR     r0,CachedBackdropMode

        Debug   bd,"BackdropMode is brought to you by the number ",r0

        LDR     r0,Screen_x1
        LDR     r1,Screen_y1
        STR     r0,CachedBackdrop_x1
        STR     r1,CachedBackdrop_y1

        LDR     r0,=&100 + SpriteReason_CreateSprite
        MOV     r1,#&8000
        ADRL    r2,BackdropSpriteName   ; Create new sprite in current mode
        MOV     r3,#0                   ; No palette

        Debug   bd,"Xsize Ysize",r4,r5
        SWI     XOS_SpriteOp
        ADDVS   sp,sp,#8
        Pull    "PC",VS
        Debug   bd,"Created new sprite X x Y",r4,r5

; Now plot old sprite into new one:

        Pull    "r1,r2"                 ; Get old sprite pointer and area
        MOV     r9,r1
        MOV     r10,r2

        LDR     R0,[R2,#spImage]
        LDR     LR,[R2,#spTrans]
        CMP     R0,R2
        MOVGT   R0,LR                   ; min(spImage,spMask) = offset to sprite data
        CMP     R0,#spPalette           ; does the sprite have a palette?
        BGT     %FT01                   ; Yup - so decode it properly

        Push    "R2"
        LDR     R0,[R2,#spMode]
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ; attempt to read the Log2BPP
        CMP     R2,#3                   ; 8BPP or greater?
        Pull    "R2",GE
        BGE     %FT01
        ADR     R1,default_palette
        LDR     R2,=&45555254           ; "TRUE"
        SWI     XWimp_ReadPalette
        Pull    "R2"                    ; restore R2 after reading the Wimp's palette
        Pull    "PC",VS                 ; and then restore PC if it errors
        B       %FT10

; assuming that the sprite does have a palette or is 256 colours
; we now call ColourTrans to perform the conversion into our nicely
; specified buffer.

01      MOV     R0,R9                   ; R0 -> sprite area to be used
        MOV     R1,R10                  ; R1 -> sprite within the sprite area
        MOV     R5,#1:SHL:0             ; R5 = control flag for ColourTrans (bit 0 =1 => R1 -> sprite)

; assuming that R0,R1 contain meaningful values, if R0 >256 then R5 should
; be setup to contain flags for the sprite conversion.

        ASSERT  (colourtrans_end -colourtrans) >=1024

10      MOV     R2,#-1
        MOV     R3,#-1                  ; R2,R3 =-1 converting to current mode / palette
        ADR     R4,colourtrans          ; R4 -> buffer to fill with PixTrans information

        ORR     R5,R5,#16               ; and ask for a wide table

        SWI     XColourTrans_SelectTable
        Pull    "PC",VS                 ; return if it errored (V set => R0 -> error block)

        ADR     r6,ScaleFactors
        MOV     r0,#0
        STR     r0,[r6,#0]              ; x0 (y1 x1 y1 x1)
        STR     r0,[r6,#20]             ; y0
        STR     r0,[r6,#24]             ; x0
        STR     r0,[r6,#28]             ; y0

        LDR     r0,backdrop_options
        TST     r0,#bd_OptionScaled
        BEQ     %FT01

        ; Scaled sprite, x1,y1 are screen x1,y1
        LDR     r2, XEig                ; Get XEig
        LDR     r0,scale_x1
        MOV     r0,r0,ASL r2
        MOV     r0,r0,ASL #8
        STR     r0,[r6,#8]
        STR     r0,[r6,#16]
        Debug   bd,"x1 = ",r0

        LDR     r2, YEig                ; Get YEig
        LDR     r0,scale_y1
        MOV     r0,r0,ASL r2
        MOV     r0,r0,ASL #8
        STR     r0,[r6,#4]
        STR     r0,[r6,#12]
        Debug   bd,"y1 = ",r0

        LDR     r0,icon_bar_height
        MOV     r0,r0,LSL #8
        STR     r0,[r6,#20]
        STR     r0,[r6,#28]
        B       %FT10

01      ; Not a scaled sprite:

        LDR     r0,scale_x1
        MOV     r0,r0,ASL #8            ; passed in 1/256th of an OS unit
        STR     r0,[r6,#8]
        STR     r0,[r6,#16]
        LDR     r0,scale_y1
        MOV     r0,r0,ASL #8            ; passed in 1/256th of an OS unit
        STR     r0,[r6,#4]
        STR     r0,[r6,#12]

10
        Debug   bd,"Scale factors set."

        LDR     r0,=&200 + SpriteReason_SwitchOutputToSprite
        MOV     r1,#&8000               ; -> Sprite area
        ADD     r2,r1,#16               ; -> Sprite
        MOV     r3,#0                   ; No save area.
        SWI     XOS_SpriteOp
        BVS     %FT99                   ; If error, switch output to screen.

        Debug   bd,"Output switched to sprite"

        LDR     r0, background_colour
        MOV     r3, #128
        MOV     r4, #0
        SWI     ColourTrans_SetGCOL
        SWI     XOS_WriteI+16

        MOV     r0,#&200 + SpriteReason_PutSpriteTransformed
        MOV     r1,r9
        MOV     r2,r10
        MOV     r3,#1                   ; Dest = coords.
        MOV     r5,#8                   ; GCOL action
        ADD     r5,r5,#32               ; wide table
        ADR     r6,ScaleFactors         ; Dest. coords.
        ADR     r7,dataarea             ; Pixel translation table.
        SWI     XOS_SpriteOp

      [ debugbd
        BVS     %FT99
      ]
        Debug   bd,"Sprite scaled."

99
        LDR     r0,=&200 + SpriteReason_SwitchOutputToSprite
        MOV     r2,#0
        MOV     r3,#1
        SWI     XOS_SpriteOp            ; Switch output back to screen.
        Pull    "PC",VS
        Debug   bd,"Output directed back to screen"

; Release any unwanted memory

        LDR     r0,slot_size
        MOV     r1,#-1
        SWI     XWimp_SlotSize
        Pull    "PC",VS

; Now calculate where it would be plotted.

        LDR     r0,backdrop_options
        TST     r0,#bd_OptionScaled
        MOVNE   r0,#0
        STRNE   r0,Sprite_x
        STRNE   r0,Sprite_y             ; For scaled sprites plot at 0,0
        Pull    "PC",NE

        TST     r0,#bd_OptionTiled
        Pull    "PC",NE                 ; For tiled sprites, compute at redraw time.

        MOV     r0,#-1                  ; Current mode
        
        MOV     r1,#VduExt_XWindLimit   ; Screen width in pixels
        SWI     XOS_ReadModeVariable
        ADDVC   r4,r2,#1
        LDRVC   r2,XEig                 ; XEig
        MOVVC   r4,r4,ASL r2            ; Screen width in OS Units

        MOVVC   r1,#VduExt_YWindLimit   ; Screen height in pixels
        SWIVC   XOS_ReadModeVariable
        ADDVC   r5,r2,#1
        LDRVC   r2,YEig                 ; YEig
        MOVVC   r5,r5,ASL r2            ; Screen height in OS Units

        Pull    "PC",VS

        LDR     r1,icon_bar_height
        SUB     r5,r5,r1

        LDR     r0,scale_x1
        SUBS    r0,r4,r0
        MOV     r0,r0,ASR #1
        STR     r0,Sprite_x

        LDR     r0,scale_y1
        SUBS    r0,r5,r0
        MOV     r0,r0,ASR #1
        ADD     r0,r0,r1
        STR     r0,Sprite_y

        Pull    "PC"

ClearBackdrop
        Push    "r0-r4,lr"
        Debug   pi,"ClearBackdrop"

        LDR     r14,backdrop_options
        BIC     r14,r14,#bd_OptionActive
        STR     r14,backdrop_options

        LDR     r0,backdrop_handle
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#&80000
        MOV     r4,#&80000
        SWI     XWimp_ForceRedraw

        LDR     r2,backdrop_path
        TEQ     r2,#0
        MOVNE   r0,#ModHandReason_Free
        SWINE   XOS_Module
        MOV     r1,#0
        STR     r1,backdrop_path

        MOVVC   r0,#0
        MOVVC   r1,#-1
        SWIVC   XWimp_SlotSize

        Pull    "r0-r4,pc"

BackdropSpriteName
        DCB     "Backdrop",0
        ALIGN
        MakeErrorBlock  Pinboard_NoRoom



; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Int_CacheJPEG
;
; Caches a JPEG image used for backdrop
;
; In : r4 = file length (from OS_File call)

Int_CacheJPEG Entry

        LDR     r0, backdrop_options
        ORR     r0, r0, #bd_OptionJPEG
        ORR     r0, r0, #bd_OptionRecache
        STR     r0, backdrop_options

        ; Get memory
        STR     r4, slot_size
        MOV     r3, r4
        ADD     r0, r4, #32             ; Add 32 to file size for luck (or SpriteExtend bug!)
        CMP     r0, #&6000              ; if less than 24k,
        MOVLT   r0, #&6000              ; make it 24k (SpriteExtend bug)
        MOV     r1, #-1
        SWI     XWimp_SlotSize
        MOVVS   r0, #0
        CMP     r0, r3
        BCS     %FT20

        ; Couldn't get the memory
        LDR     r0,backdrop_handle
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#&8000
        MOV     r4,#&8000
        SWI     XWimp_ForceRedraw

        ADRL    r0,ErrorBlock_Pinboard_NoRoom
        BL      msgtrans_errorlookup    ; V set on exit

        Pull    "PC"

20      ; Load JPEG
        MOV     r0, #16
        LDR     r1, backdrop_path
        MOV     r2, #&8000
        MOV     r3, #0
        SWI     OS_File
        ; Get width and height
        MOV     r0, #1
        MOV     r1, #&8000
        LDR     r2, slot_size
        SWI     XJPEG_Info
        MOV     r4, r2
        MOV     r5, r3
        ; Read YEig and calculate height in OS units
        LDR     r2, YEig
        MOV     r2,r5, LSL r2
        STR     r2,scale_y1
        ; Read XEig and calculate width in OS units
        LDR     r2, XEig
        MOV     r2,r4, LSL r2
        STR     r2,scale_x1
        ; Are we scaling?
        ADR     r6, ScaleFactors
        LDR     r0, backdrop_options
        TST     r0, #bd_OptionScaled
        BEQ     %FT50

        ; Image is being scaled to fit screen
        ; Set up scale factors
        LDR     r2, Screen_x1
        ADD     r2, r2, #4
        STR     r2, [r6]
        LDR     r2, Screen_y1
        LDR     r0, icon_bar_height
        SUB     r2, r2, r0
        ADD     r2, r2, #4
        STR     r2, [r6, #4]
        LDR     r0, scale_x1
        STR     r0, [r6, #8]
        LDR     r0, scale_y1
        STR     r0, [r6, #12]

        ; Set up position
        MOV     r0, #0
        STR     r0, Sprite_x
        LDR     r0, icon_bar_height
        STR     r0, Sprite_y
        B       %FT60

50      ; Image centred, so scale 1:1
        MOV     r0, #1
        STR     r0, [r6]
        STR     r0, [r6, #4]
        STR     r0, [r6, #8]
        STR     r0, [r6, #12]
        ; Setup x position
        LDR     r0, Screen_x1
        LDR     r1, scale_x1
        SUBS    r2, r0, r1
        MOVS    r3, r2, ASR #1
        STR     r3, Sprite_x
        ; Setup y position
        LDR     r0, Screen_y1
        LDR     r1, scale_y1
        LDR     r4, icon_bar_height
        SUB     r0, r0, r4
        SUBS    r2, r0, r1
        MOVS    r3, r2, ASR #1
        ADD     r3, r3, r4
        STR     r3, Sprite_y
60
        EXIT

        LNK     Icons.s
@


4.12
log
@Fixes for pinboard backdrop sprite changing
Detail:
  Fix out-by-1 error in MakeCompactModeWord, the palette checksum read from array index -1 due to the loop construction.
  Consider the x/y size as well as the compact mode word when deciding whether to recache the backdrop sprite.
  Don't assume the screen byte size is equivalent to working out the sprite byte size, due to word rounding at the end of each line. Calculate it properly.
  Allow the Wimp_SlotSize to exactly equal the required memory (previously, had to be larger).
Admin:
  Submission from Timothy Baldwin, with minor refactoring.

Version 1.03. Tagged as 'Pinboard-1_03'
@
text
@d68 1
a68 1
; Formulate a word that expresses bpp, eigen, palette all in one
d104 1
a104 1
        ORR     r0, r0, #&F0000000      ; Make sure a 1bpp EX0 EY0 mode can't be mistaken
d106 11
@


4.11
log
@Fix for not recalculating pixel translation on backdrop tile going from G256 to C256 (or G16 to C16) mode specifier
The change in Pinboard-0_95 to get eigen factor rescaling right included a quick exit when neither the bpp nor eigen factors had changed.
However, changing from a greyscale to colour 8bpp or 4bpp mode falls fouls of this (since bpp and eigen are the same), so the backdrop sprite was not recached.
There was code to collect Message_PaletteChanged, however the Wimp hasn't sent this round since pre RISC OS 3.60, additionally the mode change code was manually disabling it (not required since Message_ModeChange was never accompanied by Message_PaletteChange according to PRM3-230). This has been switched out.
Now, the 'have I already done this sprite' flag includes the bpp and eigen factors plus a 13 bit hash of the desktop palette.

Version 0.96. Tagged as 'Pinboard-0_96'
@
text
@d93 1
a93 1
        BPL     %BT10
d196 1
a196 1
        DebugIf NE, bd,"BackdropMode changed, recacheing sprite",r0,r14
d198 8
d406 1
a406 1
; Sprite is scaled, get screen size (r4 = width, r5 = height, r2 = memory req.)
a417 2
        MOVVC   r1,#VduExt_ScreenSize
        SWIVC   XOS_ReadModeVariable            ; R2= screen size in bytes
d510 1
a522 1
10
d547 1
a547 1
        BLT     got_memory
d632 5
@


4.10
log
@Fix for patchy tiled backdrops on changing to non EX1/EY1 mode
Pinboard keeps a note of the mode (from OS_Byte 135) that the backdrop sprite tile was last cached in, to avoid having to recache it all the time. However, the comparison fails when the mode specifier block (ie. when OS_Byte 135 is not reporting a numeric screen mode) is static since although the mode might have changed Pinboard would not think it had and hence not recache the sprite.
The result is a patchy desktop, for example changing from EX1/EY1 to EX0/EY0 would leave a quadrant arrangement of 1 redrawn patch and 3 not redrawn.
Backdrop.s:
Line 151 onwards, when a mode specifier is used, build a magic mode word combining EX EY and BPP (the 3 parameters the cache sprite function cares about), as a stronger check.
Tail.s:
Line 130 onwards, calculate the iconbar height properly (previously used 134 pixels for EY0 modes, 1 too high, leading to a thin strip of background colour above the iconbar.
Other changes
 - Use sprite area offset names from Hdr:Sprites rather than magic numbers
 - Use OS_Byte reasons from Hdr:OsBytes
 - Use "file.s" style names in LNK commands
 - Move BadOptions/NotASprite error blocks to avoid range error when assembling debug versions
 - true and false for objasm {TRUE} and {FALSE}

Version 0.95. Tagged as 'Pinboard-0_95'
@
text
@d23 5
a27 5
LCDbackdroptile
        DCB     "Pinboard:LCDTile",0
        ALIGN
LCDbackdroptileEnd

d40 2
a41 3
        ADR     r0,LCDbackdroptile      ; allocate memory for file name (so *Backdrop works)
        ADR     r1,LCDbackdroptileEnd
        SUB     r3,r1,r0
d59 4
d65 50
a124 4
        LDR     r0,backdrop_options
        ORR     r0,r0,#bd_OptionIgnorePaletteChange
        STR     r0,backdrop_options

d190 1
a190 3
        BEQ     %FT02
        BL      CacheBackdropSprite
        Pull    "PC"
d192 3
a194 13
        MOV     r0,#OsByte_CursorCharacterAndMode
        SWI     XOS_Byte
        Pull    "PC",VS
        CMP     r2, #256                ; Old style mode number limit
        LDRCSB  r2, [r2, #12]           ; Pixel depth
        LDRCSB  r0, YEig
        ORRCS   r2, r2, r0, LSL #8
        LDRCSB  r0, XEig
        ORRCS   r2, r2, r0, LSL #16
        ORRCS   r2, r2, #&FF000000      ; Make sure a 1bpp EX0 EY0 mode isn't mistaken
                                        ; for old style mode 0
        LDR     r0, CachedBackdropMode
        TEQ     r0, r2
d196 1
a196 1
        DebugIf NE, bd,"BackdropMode changed, recacheing sprite",r0,r2
d198 1
a199 1

d260 1
a262 6
        LDR     r0,backdrop_options
        TST     r0,#bd_OptionIgnorePaletteChange
        BIC     r0,r0,#bd_OptionIgnorePaletteChange
        STR     r0,backdrop_options
        Pull    "PC",NE

d273 1
a273 1

d279 1
a279 1
; Cache backdrop sprite fo current mode
a613 2
        ADDVS   sp,sp,#8
        Pull    "PC",VS
d617 1
a617 2
        MOV     r0,#OsByte_CursorCharacterAndMode
        SWI     XOS_Byte
a619 1
        MOV     r6, r2                  ; For SpriteReason_CreateSprite 
d621 2
a622 9
        CMP     r2, #256                ; Old style mode number limit
        LDRCSB  r2, [r2, #12]           ; Pixel depth
        LDRCSB  r0, YEig
        ORRCS   r2, r2, r0, LSL #8
        LDRCSB  r0, XEig
        ORRCS   r2, r2, r0, LSL #16
        ORRCS   r2, r2, #&FF000000      ; Make sure a 1bpp EX0 EY0 mode isn't mistaken
                                        ; for old style mode 0
        STR     r2,CachedBackdropMode
d624 1
a624 1
        Debug   bd,"BackdropMode is brought to you by the number ",r2
@


4.9
log
@Fix caching of backdrop sprites
Detail:
  s/Backdrop - The tidying up in revision 4.8 caused a vital "MOV r0,#-1" to be lost, causing the wrong mode to be used when fetching the screen BPP. As a result, caching the sprite would fail if the sprite was in a lower BPP than the current screen mode, as the calculated sprite area size would have been too small. This fixes that.
Admin:
  Tested on rev A2 BB-xM.
  Sprite backdrops now seem to work again.


Version 0.94. Tagged as 'Pinboard-0_94'
@
text
@d145 1
a145 1
        MOV     r0,#135
d148 10
a157 6
        LDR     r0,CachedBackdropMode
        TEQ     r0,r2
        Pull    "PC",EQ

        Debug   bd,"Cached mode ",r0
        Debug   bd,"Current mode ",r2
d159 1
d161 1
a161 1
        BL      CacheBackdropSprite
d396 2
a397 2
        MOV     r3,#4
        MOV     r4,#4                           ; Read offsets to first sprite and end of area
d400 2
a401 2
        ADR     r2,dataarea
        LDR     r0,[r2]
a403 1

d405 2
a406 1
        MOV     r3,#48
d417 2
d425 1
a425 1
        LDR     r0,[r2,#40]
d428 1
a428 1
        LDR     r5,[r2,#20]                     ; Get height of sprite
d432 1
a432 1
        LDR     r4,[r2,#16]                     ; Get width in words
d434 1
a434 1
        LDR     r3,[r2,#28]                     ; Get last bit used
d437 1
a437 1
        LDR     r3,[r2,#24]                     ; Get first bit used
d490 1
a490 1
        STR     r2,slot_size                    ; Amount for actual sprite.
d519 1
a519 1
        BL      msgtrans_errorlookup
a520 1
        SETV
d587 1
a587 1
        MOV     r0,#135
d591 1
d593 8
d603 1
a603 1
        Debug   bd,"Screen mode is ",r2
a604 1
        MOV     r6,r2
d872 1
a872 1
        BL      msgtrans_errorlookup
a873 1
        SETV
@


4.8
log
@Shade "Configure..." when boot was unsuccessful.
When BootResources$Path is unset the option to run the configure plugin is no longer available.
Shared a "Filer_Run " string in 3x places.
Replaced most occurrences of calling XOS_ReadModeVariable of the current mode's XEig and YEig factors to use the cached copy sitting unloved in the workspace. Should thrash less during redraw.

Version 0.93. Tagged as 'Pinboard-0_93'
@
text
@d465 1
@


4.7
log
@Replace magic numbers with sumbols from header files for OS_ calls.
Same binary as 0.92, not tagged.
@
text
@d98 1
a98 1
        STR     r0 ,[r1,#8]     ; Don't cover icon bar
d106 2
a107 1
        MOV     r0,#-1
a115 1
        Pull    "PC",VS
d117 2
a118 3
        MOV     r0,#-1
        MOV     r1,#VduExt_YWindLimit
        SWI     XOS_ReadModeVariable
d125 1
d363 1
a363 6
        MOV     r0,#-1                  ; Use current mode
        MOV     r1,#VduExt_XWindLimit   ; Screen width in pixels
        SWI     XOS_ReadModeVariable
        Pull    "PC",VS
        ADD     r4,r2,#1
        STR     r4,scale_x1
d365 1
a365 1
        MOV     r1,#VduExt_YWindLimit   ; Screen height in pixels
d367 8
a374 7
        Pull    "PC",VS
        ADD     r5,r2,#1
        STR     r5,scale_y1

        MOV     r0,#-1                          ; Current mode.
        MOV     r1,#VduExt_ScreenSize
        SWI     XOS_ReadModeVariable            ; R2= screen size in bytes
d444 1
a444 1

d446 2
a447 2
        SWI     XOS_ReadModeVariable
        Pull    "PC",VS
d451 1
a451 5

        MOV     r0,#-1                  ; Use current mode
        MOV     r1,#VduExt_YEigFactor   ; YEig
        SWI     XOS_ReadModeVariable
        Pull    "PC",VS
d458 1
a458 3
        MOV     r1,#VduExt_XEigFactor   ; XEig
        SWI     XOS_ReadModeVariable
        Pull    "PC",VS
a464 1
        MOV     r0,#-1
d662 1
a662 5

        MOV     r0,#-1
        MOV     r1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable    ; Get XEig
        Pull    "PC",VS
d664 1
a664 1
        MOV     r0,r0,ASL R2
d670 1
a670 4
        MOV     r0,#-1
        MOV     r1,#VduExt_YEigFactor
        SWI     XOS_ReadModeVariable    ; Get YEig
        Pull    "PC",VS
d672 1
a672 1
        MOV     r0,r0,ASL R2
d755 2
a756 1
        MOV     r0,#-1
d759 10
a769 5
        ADD     r4,r2,#1
        MOV     r1,#VduExt_XEigFactor   ; XEig
        SWI     XOS_ReadModeVariable
        Pull    "PC",VS
        MOV     r4,r4,ASL r2            ; Screen width in OS Units
a770 8
        MOV     r1,#VduExt_YWindLimit   ; Screen height in pixels
        SWI     XOS_ReadModeVariable
        Pull    "PC",VS
        ADD     r5,r2,#1
        MOV     r1,#VduExt_YEigFactor   ; YEig
        SWI     XOS_ReadModeVariable
        Pull    "PC",VS
        MOV     r5,r5,ASL r2            ; Screen height in OS Units
d876 1
a876 4
        MOV     r0,#-1
        MOV     r1,#VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        EXIT    VS
d880 1
a880 3
        MOV     r1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        EXIT    VS
@


4.6
log
@Collapse dead switches.
Same binary as 0.92, not tagged.
@
text
@d107 1
a107 1
        MOV     r1,#11
d110 1
a110 1
        MOVVC   r1,#4
d118 1
a118 1
        MOV     r1,#12
d121 1
a121 1
        MOVVC   r1,#5
d321 1
a321 1
        MOV     r0,#23          ; Read catalogue info with type / no path
d328 1
a328 1
        MOVNE   r0,#19          ; Generate error.
d364 1
a364 1
        MOV     r1,#11                  ; Screen width in pixels
d370 1
a370 1
        MOV     r1,#12                  ; Screen height in pixels
d377 1
a377 1
        MOV     r1,#7
d387 1
a387 1
        MOV     r0,#&4f
d393 1
a393 1
        MOV     r0,#3                           ; Read bytes from file
d404 1
a404 1
        MOV     r0,#3
d438 1
a438 1
        MOV     r1,#9                           ; get log2bpp for sprites mode
d444 1
a444 1
        MOV     r1,#5                   ; Get YEig for sprite's mode
d449 1
a449 1
        MOV     r1,#4                   ; Get XEig for sprite's mode
d457 1
a457 1
        MOV     r1,#5                   ; YEig
d466 1
a466 1
        MOV     r1,#4                   ; XEig
d476 1
a476 1
        MOV     r1,#9
d537 1
a537 1
        MOV     r0,#16          ; Load file, no path.
d584 1
a584 1
        LDR     r0,=9+&100      ; SNew
d601 1
a601 1
        LDR     r0,=15+&100
d675 1
a675 1
        MOV     r1,#4
d686 1
a686 1
        MOV     r1,#5
d716 1
a716 1
        LDR     r0,=60+&200             ; Switch output to sprite.
d731 1
a731 1
        MOV     r0,#56+&200             ; Put sprite transformed.
d747 1
a747 1
        LDR     r0,=60+&200
d774 1
a774 1
        MOV     r1,#11                  ; Screen width in pixels
d778 1
a778 1
        MOV     r1,#4                   ; XEig
d783 1
a783 1
        MOV     r1,#12                  ; Screen height in pixels
d787 1
a787 1
        MOV     r1,#5                   ; YEig
d897 1
a897 1
        MOV     r1,#5
d903 1
a903 1
        MOV     r1,#4
@


4.5
log
@A few assumptions about SWIs preserving flags remained: nuked.
A few TEQ Rn,#0 changed to use 'S' and save an instruction.
Fix for misscaled tiled backdrop sprite in EX/EY0 mode - an 'out by 1'
error meant that some of the background colour shone through when the
tile sprite got resized to be too short.In any other EX/EY mode you never
noticed it due to rounding errors in the scaling.
The "Iconise to..." options submenu is now shaded if the Wimp has the
iconise buttons turned off: this minimises confusion for anyone who
hasn't realised that shift-close and iconise are subtley different in that
only the iconise button obeys the "Iconise to..." options,whereas
shift-close iconises at the point of application.

Version 0.81. Tagged as 'Pinboard-0_81'
@
text
@a617 2
      [ Version >= 037

a660 47
      |

; ooohy poohey code that does not cope with new sprite files!

        LDR     r0,[r2,#32]             ; Get offset to data
        CMP     r0,#44                  ; Does it have a palette ?
        BNE     %FT01

; It does not have a palette, get wimp's default for that mode

        Push    "r2"
        LDR     r0,[r2,#40]
        MOV     r1,#9
        SWI     XOS_ReadModeVariable
        CMP     r2,#3
        MOVGES  r1,#0
        ADRLT   r1,default_palette
        LDRLT   r2,=&45555254           ; "TRUE"
        SWILT   XWimp_ReadPalette       ; Get wimps default palette.
        Pull    "r2"
        Pull    "PC",VS
        B       %FT10

01      ; It does have a palette, convert it to a form we can use.
        ADD     r0,r0,r2                ; r0 -> Word after palette data
        ADD     r3,r2,#44               ; r3 -> First entry of palette
        MOV     r4,r3
02
        LDR     r14,[r3],#8             ; Get every second entry.
        STR     r14,[r4],#4
        CMP     r3,r0
        BNE     %BT02
        ADD     r1,r2,#44

        Debug   bd,"Palette modified"

10      ; Now r1-> palette
        LDR     r0,[r2,#40]
        MOV     r2,#-1
        MOV     r3,#-1
        ADR     r4,dataarea
        SWI     XColourTrans_SelectTable
        Pull    "PC",VS
        Debug   bd,"Got translation table."

      ]

@


4.4
log
@Commented out "proginfo" string,no longer used.
Prefixed the pin and addtinydir commands that get saved in the
pinboard file with "X " so your pinboard setup continues even if a file
is no longer available.ROL did this with a new XPin command,not taken.
Merged changes from ROL to allow the icon text to be an arbitary colour
though this can be switched out with "technicolour_text" for the
purists.
Help entry added to the pinboard selection submenu,this will be greyed
out except when
 it's an app
 and it has a !help file
 and it is the only object selected
like the filer does.
Updated messages file accordingly.
Menu clicking on the "save pinboard settings" OK button no longer saves
the file,and adjust clicking keeps the menu tree open
 -> fixes bug report from 1998,now removed from "Status" file
Saveas template resized to match !Edit.
Fixed problem of select dragging a file to an app leaving the icon
selected (due to two conditional MOV R0's being followed by an
unconditional one for some reason).
 -> fixes bug report from 1998,now removed from "Status" file
Tweaked a few CMP#0 BLT's to test specifically for the iconbar handle.
The bug report in "Status" about bits of filenames being left on the
pinboard can be bodged by popping an ADD r0,r0,#16 after the XWimp_TextOp
in s.buffered but I've not done this yet.

Version 0.78. Tagged as 'Pinboard-0_78'
@
text
@d460 1
a460 2
        MOV     r5,r5, LSR r2           ; Height in pixels
        TEQ     r5,#0
d469 1
a469 2
        MOV     r4,r4, LSR r2           ; Width in pixels
        TEQ     r4,#0
d632 6
a637 4
        ADRLT   R1,default_palette
        LDRLT   R2,=&45555254           ; "TRUE"
        SWILT   XWimp_ReadPalette
        Pull    "R2"                    ; restore R2 after reading the Wimps palette
d639 1
a639 1
        BLT     %FT10
d754 1
a754 3
        TEQ     r0,#1
        SUBNE   r0,r0,#1
        MOV     r0,r0,ASL #8
d758 1
a758 3
        TEQ     r0,#1
        SUBNE   r0,r0,#1
        MOV     r0,r0,ASL #8
a773 2
        ;MOV     r0,#128+4
        ;SWI     XWimp_SetColour
d915 1
a915 1
        BGE     %FT20
d941 1
a941 1
        SWI     &69980                  ; XJPEG_Info
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.76. Tagged as 'Pinboard-0_76'
@
text
@d62 2
a63 1

d242 1
a242 1
; Cahce backdrop sprite fo current mode
d257 12
d270 1
@


4.2
log
@Ursula branch merged.
Added inclusion of Machine header for new CMOS header
Moved to srccommit.
Templates contain hardwired version/date information which is a long
  way out of date.  This has not been fixed in this checkin.

Version 0.75. Tagged as 'Pinboard-0_75'
@
text
@d16 1
a16 1
; 
d155 1
a155 1
        BL      CacheBackdropSprite        
d170 1
a170 1
        MOV     R1,SP 
d226 1
a226 1
        
d241 1
a241 1
; Cahce backdrop sprite fo current mode 
d243 1
a243 1
; In : 
d251 1
a251 1
CacheBackdropSprite     ROUT            
d286 1
a286 1
01            
d306 1
a306 1
        
d343 1
a343 1
                
d394 1
a394 1
05           
d493 1
a493 1
        MOV     r1,#-1 
d501 1
a501 1
        
d511 1
a511 1
            
d524 1
a524 1
                        
d536 1
a536 1
             
d557 1
a557 1
                    
d598 1
a598 1
        Debug   bd,"Created new sprite X x Y",r4,r5    
d617 1
a617 1
        MOV     R1,#VduExt_Log2BPP      
d621 1
a621 1
        LDRLT   R2,=&45555254           ; "TRUE"         
d650 1
a650 1
                          
d681 1
a681 1
        ADD     r1,r2,#44 
d684 1
a684 1
        
d699 1
a699 1
        STR     r0,[r6,#20]             ; y0                  
d710 1
a710 1
        MOV     r1,#4   
d718 1
a718 1
        Debug   bd,"x1 = ",r0                         
d721 1
a721 1
        MOV     r1,#5   
d729 1
a729 1
        Debug   bd,"y1 = ",r0                         
d769 1
a769 1
        SWI     ColourTrans_SetGCOL        
d785 1
a785 1
        Debug   bd,"Sprite scaled."     
d793 1
a793 1
        Debug   bd,"Output directed back to screen" 
d813 1
a813 1
        
d836 1
a836 1
        SUBS    r0,r4,r0 
d890 1
a890 1
Int_CacheJPEG ENTRY
d896 1
a896 1
        
d898 1
a898 1
        STR     r4, slot_size        
d900 1
a900 1
        ADD     r0, r4, #32             ; Add 32 to file size for luck (or SpriteExtend bug!)       
d905 1
a905 1
        MOVVS   r0, #0        
d908 1
a908 1
        
d919 1
a919 1
            
d922 1
a922 1
        
d969 1
a969 1
                
d1001 1
a1001 1
        LNK     s.Icons
@


4.1
log
@Initial revision
@
text
@d18 4
a21 2
;
;
d62 1
d67 4
d135 1
d139 5
d154 2
a155 1
        BL      CacheBackdropSprite
d160 3
d321 8
d341 3
d559 1
d764 6
a769 2
        MOV     r0,#128+4
        SWI     XWimp_SetColour
d880 120
@


4.1.4.1
log
@Improved consistency of files/windows, plus JPEG backdrops
@
text
@a59 1

a127 1

a130 8
        [ Version >= 67
        TST     r0, #bd_OptionJPEG
        BEQ     %FT02
        BL      CacheBackdropSprite
        Pull    "PC"
02
        ]

d141 1
a141 2

        BL      CacheBackdropSprite        
a303 10
 [ Version >= 67
        ; JPEG backdrop support
        LDR     r14,=&C85
        CMP     r6,r14
        BNE     %FT01
        BL      Int_CacheJPEG
        Pull    "PC"
01
 ]

a315 6
        
        [ Version >= 67
        BIC     r0, r0, #bd_OptionJPEG
        STR     r0, backdrop_options
        ]
                
a846 138


 [ Version >= 67

tmpfile DCB "$.Tempfile",0

;---------------------------------------------------------------
; Int_CacheJPEG
;
; Caches a JPEG image used for backdrop
;
; In : r4 = file length (from OS_File call)

Int_CacheJPEG ENTRY


        LDR     r0, backdrop_options
        ORR     r0, r0, #bd_OptionJPEG
        ORR     r0, r0, #bd_OptionRecache
        STR     r0, backdrop_options
        
        ; Get memory
        STR     r4, slot_size        
        MOV     r3, r4
        ADD     r0, r4, #32             ; Add 32 to file size for luck (or SpriteExtend bug!)       
        ;CMP     r0, #&6000              ; if less than 24k, make it 24k (SpriteExtend bug)
        ;MOVLT   r0, #&6000
        MOV     r1, #-1
        SWI     XWimp_SlotSize
        MOVVS   r0, #0        
        CMP     r0, r3
        BGE     %FT20
        
        ; Couldn't get the memory
        LDR     r0,backdrop_handle
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#&8000
        MOV     r4,#&8000
        SWI     XWimp_ForceRedraw

        ADRL    r0,ErrorBlock_Pinboard_NoRoom
        BL      msgtrans_errorlookup
            
        SETV
        Pull    "PC"
        
20      ; Load JPEG
        MOV     r0, #16
        LDR     r1, backdrop_path
        MOV     r2, #&8000
        MOV     r3, #0
        SWI     OS_File
        ; Get width and height
        MOV     r0, #1
        MOV     r1, #&8000
        LDR     r2, slot_size
        SWI     &69980                  ; XJPEG_Info
        MOV     r4, r2
        MOV     r5, r3
        ; Read YEig and calculate height in OS units
        MOV     r0,#-1
        MOV     r1,#5
        SWI     XOS_ReadModeVariable
        EXIT    VS
        MOV     r2,r5, LSL r2
        STR     r2,scale_y1
        ; Read XEig and calculate width in OS units
        MOV     r1,#4
        SWI     XOS_ReadModeVariable
        EXIT    VS
        MOV     r2,r4, LSL r2
        STR     r2,scale_x1
        ; Are we scaling?
        ADR     r6, ScaleFactors
        LDR     r0, backdrop_options
        TST     r0, #bd_OptionScaled
        BEQ     %FT50

        ; Image is being scaled to fit screen
        ; Set up scale factors
        LDR     r2, Screen_x1
        ADD     r2, r2, #4
        STR     r2, [r6]
        LDR     r2, Screen_y1
        LDR     r0, icon_bar_height
        SUB     r2, r2, r0
        ADD     r2, r2, #4
        STR     r2, [r6, #4]
        LDR     r0, scale_x1
        STR     r0, [r6, #8]
        LDR     r0, scale_y1
        STR     r0, [r6, #12]
                
        ; Set up position
        MOV     r0, #0
        STR     r0, Sprite_x
        LDR     r0, icon_bar_height
        STR     r0, Sprite_y
        B       %FT60

50      ; Image centred, so scale 1:1
        MOV     r0, #1
        STR     r0, [r6]
        STR     r0, [r6, #4]
        STR     r0, [r6, #8]
        STR     r0, [r6, #12]
        ; Setup x position
        LDR     r0, Screen_x1
        LDR     r1, scale_x1
        SUBS    r2, r0, r1
        MOVS    r3, r2, ASR #1
        STR     r3, Sprite_x
        ; Setup y position
        LDR     r0, Screen_y1
        LDR     r1, scale_y1
        LDR     r4, icon_bar_height
        SUB     r0, r0, r4
        SUBS    r2, r0, r1
        MOVS    r3, r2, ASR #1
        ADD     r3, r3, r4
        STR     r3, Sprite_y
        
60
        ;Push    "r0-r10"
        ;MOV     r0, #0
        ;ADR     r1, formatstring
        ;LDR     r2, Screen_x1
        ;LDR     r3, Screen_y1
        ;LDR     r4, scale_x1
        ;LDR     r5, scale_y1
        ;SWI     &4f902
        ;Pull    "r0-r10"

        EXIT

formatstring DCB "Screen_x1 %d   Screen_y1 %d   scale_x1 %d   scale_y1 %d",10,0
 ]
@


4.1.4.2
log
@Fixed bug which can corrupt IconiseTo submenu.
@
text
@d1010 1
a1010 1
;formatstring DCB "Screen_x1 %d   Screen_y1 %d   scale_x1 %d   scale_y1 %d",10,0
@


4.1.4.3
log
@Windows, as well as files, can be selected, plus new menu structure and options
@
text
@d18 2
a19 4




d133 1
d139 2
d315 1
d323 1
a557 1

d876 1
d878 3
a880 1
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d889 1
d899 2
a900 2
        CMP     r0, #&6000              ; if less than 24k,
        MOVLT   r0, #&6000              ; make it 24k (SpriteExtend bug)
d996 1
d998 10
d1009 3
@


4.1.4.4
log
@Removed Info option on TinyDirs menu.
Updated interactive help messages.
Shift+Click on close icon now ALWAYS iconises the window underneath the icon
(old behaviour), while a click on iconise button iconises according to the
IconiseTo corner.
@
text
@d334 2
d338 1
@


4.1.4.5
log
@Fixed a couple of bugs.
Improved tidying code.
Filenames are now truncated.
@
text
@a66 4
        [ truncate_filenames
        BL      read_font_widths
        ]

a155 3
        [ truncate_filenames
        BL      read_font_widths
        ]
@


4.1.4.6
log
@Backdrop images that have a mask now have the chosen background colour
showing through (rather than just grey as before).
Added noiconbar compile-time flag (for DiTV demo).
@
text
@d764 2
a765 6
        ;MOV     r0,#128+4
        ;SWI     XWimp_SetColour
        LDR     r0, background_colour
        MOV     r3, #128
        MOV     r4, #0
        SWI     ColourTrans_SetGCOL        
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

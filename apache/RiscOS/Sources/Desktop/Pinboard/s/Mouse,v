head	4.7;
access;
symbols
	Pinboard-1_04:4.7
	Pinboard-1_03:4.7
	Pinboard-1_02:4.7
	Pinboard-1_01:4.7
	Pinboard-1_00:4.7
	Pinboard-0_99:4.7
	Pinboard-0_98:4.7
	Pinboard-0_97:4.7
	Pinboard-0_96:4.7
	Pinboard-0_95:4.7
	Pinboard-0_94:4.6
	Pinboard-0_93:4.6
	Pinboard-0_92:4.4
	Pinboard-0_91:4.4
	Pinboard-0_90:4.4
	Pinboard-0_89:4.4
	Pinboard-0_88:4.4
	Pinboard-0_87:4.4
	Pinboard-0_86:4.4
	Pinboard-0_85:4.4
	Pinboard-0_84:4.4
	Pinboard-0_83:4.4
	Pinboard-0_82:4.3
	RO_5_07:4.3
	Pinboard-0_81:4.3
	Pinboard-0_80:4.3
	Pinboard-0_79:4.3
	Pinboard-0_78:4.2
	Pinboard-0_77:4.2
	Pinboard-0_76:4.2
	Ursula_merge:4.1.4.5
	Pinboard-0_75:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.5
	Ursula_RiscPC:4.1.4.5.0.2
	rleggett_Pinboard-0_75d:4.1.4.5
	rthornb_UrsulaBuild-19Aug1998:4.1.4.5
	UrsulaBuild_FinalSoftload:4.1.4.5
	rthornb_UrsulaBuild-12Aug1998:4.1.4.5
	aglover_UrsulaBuild-05Aug1998:4.1.4.5
	rthornb_UrsulaBuild-29Jul1998:4.1.4.5
	rthornb_UrsulaBuild-22Jul1998:4.1.4.5
	rleggett_Pinboard-0_75c:4.1.4.5
	rleggett_Pinboard-0_75b:4.1.4.5
	rleggett_Pinboard-0_75:4.1.4.5
	rthornb_UrsulaBuild-15Jul1998:4.1.4.5
	rthornb_UrsulaBuild-07Jul1998:4.1.4.5
	rthornb_UrsulaBuild-17Jun1998:4.1.4.5
	rthornb_UrsulaBuild-03Jun1998:4.1.4.5
	rthornb_UrsulaBuild-27May1998:4.1.4.5
	rthornb_UrsulaBuild-21May1998:4.1.4.5
	rleggett_Pinboard-0_74:4.1.4.5
	rthornb_UrsulaBuild_01May1998:4.1.4.5
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.7
date	2012.08.23.19.59.12;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	rztFpV1VBvCVZHhw;

4.6
date	2011.09.24.07.31.20;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	nRjnbtmOSxK1BIAv;

4.5
date	2011.09.24.07.25.50;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	NapphrXjtkIXyIAv;

4.4
date	2006.03.14.18.45.07;	author srevill;	state Exp;
branches;
next	4.3;

4.3
date	2003.01.09.16.01.04;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	99.08.17.19.05.22;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.03;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.30.03;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.29.55;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.06.13.08.40.33;	author rleggett;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.08.04.11.50.33;	author rleggett;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.10.21.09.57.05;	author rleggett;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	97.10.22.09.33.28;	author rleggett;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.04.27.17.41.18;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.21.02;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.18.55;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.7
log
@Fix for patchy tiled backdrops on changing to non EX1/EY1 mode
Pinboard keeps a note of the mode (from OS_Byte 135) that the backdrop sprite tile was last cached in, to avoid having to recache it all the time. However, the comparison fails when the mode specifier block (ie. when OS_Byte 135 is not reporting a numeric screen mode) is static since although the mode might have changed Pinboard would not think it had and hence not recache the sprite.
The result is a patchy desktop, for example changing from EX1/EY1 to EX0/EY0 would leave a quadrant arrangement of 1 redrawn patch and 3 not redrawn.
Backdrop.s:
Line 151 onwards, when a mode specifier is used, build a magic mode word combining EX EY and BPP (the 3 parameters the cache sprite function cares about), as a stronger check.
Tail.s:
Line 130 onwards, calculate the iconbar height properly (previously used 134 pixels for EY0 modes, 1 too high, leading to a thin strip of background colour above the iconbar.
Other changes
 - Use sprite area offset names from Hdr:Sprites rather than magic numbers
 - Use OS_Byte reasons from Hdr:OsBytes
 - Use "file.s" style names in LNK commands
 - Move BadOptions/NotASprite error blocks to avoid range error when assembling debug versions
 - true and false for objasm {TRUE} and {FALSE}

Version 0.95. Tagged as 'Pinboard-0_95'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; s.Mouse
;
; Handle mouse clicks


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; mouse_click
;
; Handle mouse click events
;
; In: r1 -> wimp_event structure
;
; Out: Registers may be corrupted - returning to Wimp_Poll

mouse_click     ROUT

        Push    "LR"

        LDMIA   r1!,{r10,r11}    ; x,y
        LDMIA   r1,{r0-r2}
        ADR     r14, drag_start  ; store x and y in case of drag start
        STMIA   r14, {r10,r11}
        STR     r1, drag_window
        STR     r2, drag_icon

        ; At this point:
        ;   r0 = Buttons
        ;   r1 = Window
        ;   r2 = Icon.

        Debug   pi,"Mouse click ",r0,r1,r2
        LDR     r14,saveas_handle
        CMP     r1,r14
        BEQ     save_click
        Debug   pi,"Not saveas"
        CMP     r1,#-2
        LDRNE   r14,backdrop_handle
        CMPNE   r1,r14
        Pull    "PC",NE

        Debug   pi,"Backdrop click ",r0

        TST     r0,#2                   ; Is it a menu request?
        BNE     create_menu

        CMP     r1,#-2
        LDREQ   r14,TinyDirs_Handle
        TEQ     r2,r14
        Pull    "PC",EQ

        CMP     r0,#&400
        BEQ     Select_Click
        CMP     r0,#&100
        BEQ     Adjust_Click
        CMP     r0,#&40
        BEQ     Select_Drag
        CMP     r0,#&10
        BEQ     Adjust_Drag
        CMP     r0,#&4
        BEQ     SelectDoubleClick
        CMP     r0,#&1
        BEQ     AdjustDoubleClick

        Pull    "PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Select_Click

Select_Click    ROUT

        Debug   pi,"Select click",r1,r2

        CMP     r2,#-1
        BNE     %FT01

        MOV     r0,r1
        BL      DeselectAllIcons
        Pull    "PC"
01
        Push    "r1,r2"
        BL      FindIcon
        ;Pull    "r1,r2,pc",NE
        Pull    "r1, r2", NE
        BNE     Iconized_SelectClick

        LDMIA   sp,{r1,r2}

        MOV     r0,r1
        MOV     r3,r0

        ADR     r1,dataarea
        STR     r0,[r1]
        STR     r2,[r1,#4]
        SWI     XWimp_GetIconState
        Pull    "r1,r2,PC",VS

        Debug   pi,"Got icon state"

        ADR     r1,dataarea
        LDR     r14,[r1,#24]            ; Get icon flags
        TST     r14,#selected
        Pull    "r1,r2,PC",NE           ; Ignore if already selected.

        Debug   pi,"Not already selected"

        MOV     r0,r3
        BL      DeselectAllIcons

        Debug   pi,"Icons deselected ",r3

        ADR     r1,dataarea
        STR     r3,[r1]
        STR     r2,[r1,#4]
        MOV     r0,#is_selected
        STR     r0,[r1,#8]
        STR     r0,[r1,#12]
        SWI     XWimp_SetIconState
        Pull    "r1,r2,PC",VS

        MOV     r1,#1
        CMP     r3,#0
        STRGE   r1,Pinboard_Selected
        STRLT   r1,TinyDirs_Selected
        Debug   pi,"selected icons = ",r1

        Pull    "r1,r2,PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Iconized_SelectClick
;
; Handle a select click on an iconized window icon.
;
; In: r1 = Window handle
;     r2 = Icon handle
;
; Out:

Iconized_SelectClick

        LDR     r0, backdrop_handle
        CMP     r0, r1                  ; check if click was on backdrop
        Pull    "pc", NE                ; exit if not

        MOV     r6, r2                  ; r6 = icon
        BL      find_iconized           ; find the structure relating to the icon in r6
        CMP     r7, #0                  ; found one?
        Pull    "pc", EQ                ; no, then exit

        ADR     r1, dataarea
        LDR     r0, [r7, #w_icon_id]
        STR     r0, [r1]
        LDR     r0, [r7, #w_icon_handle]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState      ; Find current state of icon
        Pull    "pc", VS

        LDR     r0, [r1, #24]
        TST     r0, #selected           ; Is icon currently selected?
        Pull    "pc", NE                ; Yes? Then ignore click

        LDR     r0, backdrop_handle
        BL      DeselectAllIcons        ; Deselect all currently selected icons

        LDR     r0, [r7, #w_icon_id]
        STR     r0, [r1]
        LDR     r0, [r7, #w_icon_handle]
        STR     r0, [r1, #4]
        MOV     r0, #is_selected
        STR     r0, [r1, #8]
        MOV     r0, #0
        STR     r0, [r1, #12]
        SWI     XWimp_SetIconState      ; Change the state
        Pull    "pc", VS

        MOV     r0, #1
        STR     r0, Windows_Selected    ; Update number of selected window icons
        Pull    "pc"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Adjust_Click

Adjust_Click    ROUT

        CMP     r2,#-1
        Pull    "PC",EQ

        Push    "r1,r2"
        BL      FindIcon
        Pull    "r1,r2"
        BNE     Iconized_AdjustClick
        ;Pull    "PC",NE                 ; An iconized icon.

        MOV     r3,r1
        ADR     r1,dataarea
        STR     r3,[r1]
        STR     r2,[r1,#4]
        SWI     XWimp_GetIconState
        Pull    "PC",VS

        LDR     r14,[r1,#24]            ; Get icon flags
        TST     r14,#selected
        MOVEQ   r2,#1
        MOVNE   r2,#-1

        CMP     r3,#0
        LDRGE   r0,Pinboard_Selected
        LDRLT   r0,TinyDirs_Selected
        ADD     r0,r0,r2
        STRGE   r0,Pinboard_Selected
        STRLT   r0,TinyDirs_Selected
        Debug   pi,"selected icons = ",r0

        MOVGE   r0,#is_selected         ; Toggle icon's state.
        MOVLT   r0,#selected
        STR     r0,[r1,#8]
        MOV     r0,#0
        STR     r0,[r1,#12]
        SWI     XWimp_SetIconState

        Pull    "PC"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Iconized_AdjustClick
;
; Handle an adjust click on an iconized window icon.
;
; In: r1 = Window handle
;     r2 = Icon handle
;
; Out:

Iconized_AdjustClick

        LDR     r5, Windows_Selected
        LDR     r0, backdrop_handle
        CMP     r0, r1                  ; check if click was on backdrop
        Pull    "pc", NE                ; exit if not

        MOV     r6, r2                  ; r6 = icon
        BL      find_iconized           ; find the structure relating to the icon in r6
        CMP     r7, #0                  ; found one?
        Pull    "pc", EQ                ; no, then exit

        ADR     r1, dataarea
        LDR     r0, [r7, #w_icon_id]
        STR     r0, [r1]
        LDR     r0, [r7, #w_icon_handle]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState      ; Find current state of icon
        Pull    "pc", VS

        LDR     r0, [r1, #24]
        TST     r0, #selected           ; Is icon currently selected?
        SUBNE   r5, r5, #1              ; Yes, then it will be deselected
        ADDEQ   r5, r5, #1              ; No, then it will be selected

        LDR     r0, [r7, #w_icon_id]
        STR     r0, [r1]
        LDR     r0, [r7, #w_icon_handle]
        STR     r0, [r1, #4]
        MOV     r0, #is_selected
        STR     r0, [r1, #8]
        MOV     r0, #0
        STR     r0, [r1, #12]
        SWI     XWimp_SetIconState      ; Change the state
        Pull    "pc", VS

        STR     r5, Windows_Selected    ; Update number of selected window icons
        Pull    "pc"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Adjust_DoubleClick

AdjustDoubleClick       ROUT

        CMP     r2,#-1
        Pull    "PC",EQ

        Push    "r1,r2"

        BL      FindIcon                ; r2 -> icon block
        Pull    "r1,r2,PC",NE           ; Not found (Iconized window).

        MOV     r0,#BufferReason_Remove
        ADD     r2,r2,#ic_path
        BL      strlen
        DebugS  pi,"Path = ",r2
        Debug   pi,"Action = ",r0
        Debug   pi,"Window = ",r1
        Debug   pi,"length = ",r3
        BL      BufferIcon
        SUB     r2,r2,#ic_path
        B       %FT01


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectDoubleClick

SelectDoubleClick

        CMP     r2,#-1
        Pull    "PC",EQ

        Push    "r1,r2"

        BL      FindIcon                ; r2 -> icon block
        Pull    "r1,r2",NE              ; Not found (Iconized window).
        BNE     IconizedReopen

01
        ADRL    r0,FilerRunCom
        ADR     r1,dataarea
        BL      Copy_r0r1
        ADD     r0,r2,#ic_path
        BL      Copy_r0r1
        ADR     r0,dataarea
        DebugS  pi,"Command: ",r0
        SWI     XOS_CLI
        Pull    "r2,r3"
        Pull    "PC",VS

        ADR     r1,dataarea
        STR     r2,[r1]
        STR     r3,[r1,#4]
        MOV     r0,#0
        STR     r0,[r1,#8]
        CMP     r2,#0
        MOVLT   r0,#selected
        MOVGT   r0,#is_selected
        STR     r0,[r1,#12]
        SWI     XWimp_SetIconState
        Pull    "PC",VS

        CMP     r2,#0
        LDRGE   r0,Pinboard_Selected
        LDRLT   r0,TinyDirs_Selected
        SUB     r0,r0,#1
        STRGE   r0,Pinboard_Selected
        STRLT   r0,TinyDirs_Selected
        Debug   pi,"selected icons = ",r0

        Pull    "PC"

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Claim input focus (make a note of who had it before us).
; Fail silently.
Claim_Focus
        Push    "R0-R5, LR"
        ADR     R1, CaretPos
        SWI     XWimp_GetCaretPosition
        LDR     R0, backdrop_handle
        MOV     R1, #-1         ; icon handle
        MOV     R2, #0          ; x co-ord
        MOV     R3, #0          ; y co-ord
        MOV     R4, #-1         ; height + flags
        MOV     R5, #-1         ; string index
        SWI     XWimp_SetCaretPosition
        CLRV
        Pull    "R0-R5, PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Put the input focus back to where ever it was when we claimed
; it. Note: if that window has been closed, we fail silently.
Restore_Focus
        Push    "R0-R5, LR"
        ADR     LR, CaretPos
        LDMIA   LR, {R0-R5}
        TEQ     R0, #0
        SWINE   XWimp_SetCaretPosition
        MOV     R0, #0
        STR     R0, CaretPos
        CLRV
        Pull    "R0-R5, PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Adjust_Drag

Adjust_Drag     ROUT
        BL      Claim_Focus

        CMP     r2,#-1
        BNE     Select_DragIcon

        MOV     r0,#DragType_AdjustDrag
        STR     r0,DragType

        B       %FT01


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Select_Drag

Select_Drag
        BL      Claim_Focus

        CMP     r2,#-1
        BNE     Select_DragIcon

        MOV     r0,#DragType_SelectDrag
        STR     r0,DragType

01
      [ {TRUE}
        MOV     r0,#1
        LDR     r2,XEig
        LDR     r3,YEig
        MOV     r2,r0,LSL r2            ; pixel width
        MOV     r3,r0,LSL r3            ; pixel height
        ADR     r1,dataarea
        LDMIA   r1!,{r0,r14}
        STMIA   r1!,{r0,r14}
        ADD     r0,r0,r2                ; make exclusive!
        ADD     r14,r14,r3
        STMIA   r1!,{r0,r14}
        SUB     r1,r1,#8*3
      |
        ADR     r1,dataarea
        LDR     r14,[r1]
        STR     r14,[r1,#8]             ; Initial x0
        STR     r14,[r1,#16]            ; Initial x1
        LDR     r14,[r1,#4]
        STR     r14,[r1,#12]            ; Initial y0
        STR     r14,[r1,#20]            ; Initial y1
      ]
        LDR     r14,icon_bar_height     ; Parent y0
        STR     r14,[r1,#28]
        MOV     r14,#6                  ; Drag type
02
        STR     r14,[r1,#4]
        MOV     r14,#0
        STR     r14,[r1,#24]            ; Parent x0
        LDR     r14,Screen_x1           ; Parent x1
      [ {TRUE}
        ADD     r14,r14,r2              ; make exclusive!
      ]
        STR     r14,[r1,#32]
        LDR     r14,Screen_y1           ; Parent y1
      [ {TRUE}
        ADD     r14,r14,r3              ; make exclusive!
      ]
        STR     r14,[r1,#36]

 [ ursulawimp
        LDR     r2, backdrop_handle
        STR     r2, [r1]
        LDR     r2, taskword
        MOV     r3, #3
 ]

        SWI     XWimp_DragBox

        Pull    "PC"

 [ ursulawimp
taskword DCB "TASK"
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Adjust_DragIcon

Adjust_DragIcon
        Push    "r0-r2"
        BL      FindIcon
        STREQ    r2,[sp,#8]

        Pull    "r0-r2"
        Pull    "PC",NE                 ; Iconized window !


        MOV     r0,#DragType_AdjustDragIcon
        STR     r0,DragType

        MOV     r3,r1
        ADR     r1,dataarea
        STR     r3,[r1]
        STR     r2,[r1,#4]
        SWI     XWimp_GetIconState
        Pull    "PC",VS

        LDR     r14,[r1,#24]            ; Get icon flags
        TST     r14,#selected
        MOVNE   r1,r3
        BNE     %FT10                   ; Ignore if already selected.

        STR     r3,[r1]
        STR     r2,[r1,#4]
        MOV     r0,#is_selected
        STR     r0,[r1,#8]
        STR     r0,[r1,#12]
        SWI     XWimp_SetIconState
        Pull    "PC",VS

        CMP     r3,#0
        LDRGE   r1,Pinboard_Selected
        LDRLT   r1,TinyDirs_Selected
        ADD     r1,r1,#1
        STRGE   r1,Pinboard_Selected
        STRLT   r1,TinyDirs_Selected
        Debug   pi,"selected icons = ",r1
        MOV     r1,r3
        B       %FT10


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Select_DragIcon
;
; Deals with drags of icons

Select_DragIcon

        LDR     r14,saveas_handle
        TEQ     r1,r14
        BEQ     save_drag
        Push    "r0-r2"
        BL      FindIconBoth                ; r2 -> icon block if found
        STREQ   r2,[sp,#8]
        Pull    "r0-r2"
        Pull    "pc", NE
        ;BNE     Iconized_Drag
        MOV     r0,#DragType_SelectDragIcon
        STR     r0,DragType

10
        MOV     r0,r1
        STR     r0,DragWindow

        ; Check for DragASprite
        Push    "r0-r2"
        MOV     r0,#OsByte_ReadCMOS
        MOV     r1,#FileSwitchCMOS
        SWI     XOS_Byte
        MOVVS   r3,#0
        ANDVC   r3,r2,#DragASpriteCMOSBit
        Pull    "r0-r2"

        ; If using DragASprite then FindBBOX will set up the drag for us.
        Debug   tmp,"r2 (icon blk ptr) = ",r2
        Debug   tmp,"r3 (DAS) = ",r3
        BL      FindBBOX

        CMP     r0,#0
        ADDLT   r7,r7,#24
        ADDLT   r9,r9,#24
        Debug   tmp,"BBOX is ",r6,r7,r8,r9

        ; Ensure bounding box is at least grid_x_spacing by grid_y_spacing
        SUB     r0,r8,r6
        CMP     r0,#grid_x_spacing
        RSBLT   r0,r0,#grid_x_spacing
        SUBLT   r6,r6,r0,LSR #1
        ADDLT   r8,r8,r0,LSR #1
        SUB     r0,r9,r7
        CMP     r0,#grid_y_spacing
        RSBLT   r0,r0,#grid_y_spacing
        SUBLT   r7,r7,r0,LSR #1
        ADDLT   r9,r9,r0,LSR #1

        Debug   tmp,"adjusted BBOX is ",r6,r7,r8,r9

        ADR     r14,DragBBOX
        STMIA   r14,{r6,r7,r8,r9}

        CMP     r3,#0
        Pull    "pc",NE         ; Don't do Wimp_DragBox if using DragASprite

        ADRL    r1,dataarea+8
        STMIA   r1,{r6,r7,r8,r9}
        SUB     r1,r1,#8

        ; Why on earth is the parent box defined like this:
        SUB     r6,r6,r10
        STR     r6,[r1,#24]             ; Parent x0

        SUB     r7,r7,r11
        STR     r7,[r1,#28]             ; Parent y0

        LDR     r14,Screen_x1
        SUB     r8,r8,r10
        ADD     r14,r14,r8
        STR     r14,[r1,#32]            ; Parent x1

        LDR     r14,Screen_y1
        SUB     r9,r9,r11
        ADD     r14,r14,r9
        STR     r14,[r1,#36]

        MOV     r14,#5
        STR     r14,[r1,#4]

        SWI     XWimp_DragBox

        Pull    "PC"

        LNK     Drag.s
@


4.6
log
@Shade "Configure..." when boot was unsuccessful.
When BootResources$Path is unset the option to run the configure plugin is no longer available.
Shared a "Filer_Run " string in 3x places.
Replaced most occurrences of calling XOS_ReadModeVariable of the current mode's XEig and YEig factors to use the cached copy sitting unloved in the workspace. Should thrash less during redraw.

Version 0.93. Tagged as 'Pinboard-0_93'
@
text
@d549 1
a549 1
        MOV     r0,#ReadCMOS
d614 1
a614 1
        LNK     s.Drag
@


4.5
log
@Replace magic numbers with sumbols from header files for OS_ calls.
Same binary as 0.92, not tagged.
@
text
@d329 1
a329 1
        ADR     r0,FilerRun_command
a361 4
FilerRun_command        DCB     "Filer_Run ",0
        ALIGN


a423 10
        MOV     r0,#VduExt_XEigFactor
        MOV     r1,#VduExt_YEigFactor
        MOV     r2,#-1
        Push    "r0-r2"
        SUB     sp,sp,#8
        ADD     r0,sp,#8
        MOV     r1,sp
        SWI     XOS_ReadVduVariables
        Pull    "r2-r3"
        ADD     sp,sp,#12
d425 2
a436 1
;        MOV     r0,r1
@


4.4
log
@  Different way of doing escape-aborts-drag implementation
Detail:
  Although the previous check-in works, it uses EventV to trap escape key
  press events. This mechanism doesn't stop them from being passed on to
  whoever has input focus (e.g. a task window).

  The new way to do things is to grab input focus when a drag starts and
  to restore it (if possible) when the drag f we abort the drag (and restore focus). All other keys
  are passed on to the Wimp.

  The side-effect is that any window which has focus will temporarily lose
  focus for the duration of a Pinboard drag op I think we can
  live with that.
Admin:
  Tested on Iyonix and works fine. Now, if only the Filer did this, too...

Version 0.83. Tagged as 'Pinboard-0_83'
@
text
@d428 2
a429 2
        MOV     r0,#4
        MOV     r1,#5
@


4.3
log
@  The following was present in RISC OS 5.00/5.01:
  * Grammatical correction to interactive help for "Save as" dialogue box.
  The following is new since then:
  * Fixed rubber dragboxes to use exclusive maximum coordinates, stops you
    dragging the box off the left hand side of the window.

Version 0.79. Tagged as 'Pinboard-0_79'
@
text
@d367 33
d403 1
d418 1
@


4.2
log
@Ursula branch merged.
Added inclusion of Machine header for new CMOS header
Moved to srccommit.
Templates contain hardwired version/date information which is a long
  way out of date.  This has not been fixed in this checkin.

Version 0.75. Tagged as 'Pinboard-0_75'
@
text
@d44 1
a44 1
        
d159 1
a159 1
        
d164 1
a164 1
        
d172 2
a173 2
        
        LDR     r0, [r1, #24]           
d176 1
a176 1
        
d179 1
a179 1
                
d255 1
a255 1
        
d260 1
a260 1
        
d268 2
a269 2
        
        LDR     r0, [r1, #24]           
d273 1
a273 1
                
d287 1
a287 1
        
d392 23
a414 1
        MOV     r0,r1
d422 1
d431 3
d436 3
d557 1
a557 1
        
@


4.1
log
@Initial revision
@
text
@d18 8
d27 1
d35 10
a44 4

; r0 = Buttons
; r1 = Window
; r2 = Icon.
d80 4
d92 1
a92 1
        BL      DeselectIcons
d97 4
a100 11
 [ iconise_to_iconbar
        BEQ     %FT02
        Pull    "r1,r2"
        LDR     lr, Pinboard_options
        TST     lr, #PinboardOption_IconiseToIconBar
        BNE     IconizedReopen
        Pull    "pc"
02
 |
        Pull    "r1,r2,pc",NE
 ]
d122 1
a122 1
        BL      DeselectIcons
d143 56
d207 2
a208 1
        Pull    "PC",NE                 ; An iconized icon.
d239 53
d313 4
d365 4
d372 1
a372 1
        BNE     Adjust_DragIcon
d379 4
d411 8
d423 6
d473 5
a482 1

d484 2
a485 3
        BL      FindIcon                ; r2 -> icon block if found
        Debug   tmp,"r2 (icon blk ptr) = ",r2
        STREQ    r2,[sp,#8]
d487 2
a488 10
 [ iconise_to_iconbar
        BEQ     %FT09
        LDR     lr, Pinboard_options
        TST     lr, #PinboardOption_IconiseToIconBar
        BEQ     Iconized_Drag
        Pull    "pc"
09
 |
        BNE     Iconized_Drag
 ]
d496 1
a496 1
; Check for DragASprite
d505 1
a505 1
; If using DragASprite then FindBBOX will set up the drag for us.
a509 1
      [ Version >= 31
a512 1
      ]
d515 1
d528 1
d539 1
d558 1
@


4.1.4.1
log
@Added option to iconise windows to a corner
@
text
@d78 9
a86 9
; [ iconise_to_iconbar
;        BEQ     %FT02
;        Pull    "r1,r2"
;        LDR     lr, Pinboard_options
;        TST     lr, #PinboardOption_IconiseToIconBar
;        BNE     IconizedReopen
;        Pull    "pc"
;02
; |
d88 1
a88 1
; ]
@


4.1.4.2
log
@Improved consistency of files/windows, plus JPEG backdrops
@
text
@d336 8
a343 8
; [ iconise_to_iconbar
        ;BEQ     %FT09
        ;LDR     lr, Pinboard_options
        ;TST     lr, #PinboardOption_IconiseToIconBar
        ;BEQ     Iconized_Drag
        ;Pull    "pc"
;09
; |
d345 1
a345 1
; ]
@


4.1.4.3
log
@Windows, as well as files, can be selected, plus new menu structure and options
@
text
@a17 6


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; mouse_click
;
; Handle mouse click events
a18 3
; In: r1 -> wimp_event structure
;
; Out: Registers may be corrupted - returning to Wimp_Poll
d26 4
a29 10
        ADR     r14, drag_start  ; store x and y in case of drag start
        STMIA   r14, {r10,r11}
        STR     r1, drag_window
        STR     r2, drag_icon

        ; At this point:
        ;   r0 = Buttons
        ;   r1 = Window
        ;   r2 = Icon.
        
a64 4

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Select_Click

d73 1
a73 1
        BL      DeselectAllIcons
d78 11
a88 4
        ;Pull    "r1,r2,pc",NE
        Pull    "r1, r2", NE
        BNE     Iconized_SelectClick

d110 1
a110 1
        BL      DeselectAllIcons
a130 56

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Iconized_SelectClick
;
; Handle a select click on an iconized window icon.
;
; In: r1 = Window handle
;     r2 = Icon handle
;
; Out:

Iconized_SelectClick

        LDR     r0, backdrop_handle
        CMP     r0, r1                  ; check if click was on backdrop
        Pull    "pc", NE                ; exit if not
        
        MOV     r6, r2                  ; r6 = icon
        BL      find_iconized           ; find the structure relating to the icon in r6
        CMP     r7, #0                  ; found one?
        Pull    "pc", EQ                ; no, then exit
        
        ADR     r1, dataarea
        LDR     r0, [r7, #w_icon_id]
        STR     r0, [r1]
        LDR     r0, [r7, #w_icon_handle]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState      ; Find current state of icon
        Pull    "pc", VS
        
        LDR     r0, [r1, #24]           
        TST     r0, #selected           ; Is icon currently selected?
        Pull    "pc", NE                ; Yes? Then ignore click
        
        LDR     r0, backdrop_handle
        BL      DeselectAllIcons        ; Deselect all currently selected icons
                
        LDR     r0, [r7, #w_icon_id]
        STR     r0, [r1]
        LDR     r0, [r7, #w_icon_handle]
        STR     r0, [r1, #4]
        MOV     r0, #is_selected
        STR     r0, [r1, #8]
        MOV     r0, #0
        STR     r0, [r1, #12]
        SWI     XWimp_SetIconState      ; Change the state
        Pull    "pc", VS

        MOV     r0, #1
        STR     r0, Windows_Selected    ; Update number of selected window icons
        Pull    "pc"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Adjust_Click

d139 1
a139 2
        BNE     Iconized_AdjustClick
        ;Pull    "PC",NE                 ; An iconized icon.
a169 53
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Iconized_AdjustClick
;
; Handle an adjust click on an iconized window icon.
;
; In: r1 = Window handle
;     r2 = Icon handle
;
; Out:

Iconized_AdjustClick

        LDR     r5, Windows_Selected
        LDR     r0, backdrop_handle
        CMP     r0, r1                  ; check if click was on backdrop
        Pull    "pc", NE                ; exit if not
        
        MOV     r6, r2                  ; r6 = icon
        BL      find_iconized           ; find the structure relating to the icon in r6
        CMP     r7, #0                  ; found one?
        Pull    "pc", EQ                ; no, then exit
        
        ADR     r1, dataarea
        LDR     r0, [r7, #w_icon_id]
        STR     r0, [r1]
        LDR     r0, [r7, #w_icon_handle]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState      ; Find current state of icon
        Pull    "pc", VS
        
        LDR     r0, [r1, #24]           
        TST     r0, #selected           ; Is icon currently selected?
        SUBNE   r5, r5, #1              ; Yes, then it will be deselected
        ADDEQ   r5, r5, #1              ; No, then it will be selected
                
        LDR     r0, [r7, #w_icon_id]
        STR     r0, [r1]
        LDR     r0, [r7, #w_icon_handle]
        STR     r0, [r1, #4]
        MOV     r0, #is_selected
        STR     r0, [r1, #8]
        MOV     r0, #0
        STR     r0, [r1, #12]
        SWI     XWimp_SetIconState      ; Change the state
        Pull    "pc", VS

        STR     r5, Windows_Selected    ; Update number of selected window icons
        Pull    "pc"
        

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Adjust_DoubleClick

a190 4

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectDoubleClick

a238 4

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Adjust_Drag

d242 1
a242 1
        BNE     Select_DragIcon
a248 4

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Select_Drag

a281 3
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Adjust_DragIcon

a324 5
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Select_DragIcon
;
; Deals with drags of icons

d330 1
d332 3
a334 2
        BL      FindIconBoth                ; r2 -> icon block if found
        STREQ   r2,[sp,#8]
d336 10
a345 2
        EXIT    NE
        ;BNE     Iconized_Drag
d353 1
a353 1
        ; Check for DragASprite
d362 1
a362 1
        ; If using DragASprite then FindBBOX will set up the drag for us.
d367 1
d371 1
a373 1
        ; Ensure bounding box is at least grid_x_spacing by grid_y_spacing
a385 1
        
a395 1
        ; Why on earth is the parent box defined like this:
a413 1

@


4.1.4.4
log
@Fixed bug which can cause Pinboard to die when dragging icons to other apps
@
text
@d476 1
a476 1
        Pull    "pc", NE
@


4.1.4.5
log
@Wimp_DragBox for selections of icons now clipped to pinboard window.
@
text
@a410 8

 [ ursulawimp
        LDR     r2, backdrop_handle
        STR     r2, [r1]
        LDR     r2, taskword
        MOV     r3, #3
 ]

a414 3
 [ ursulawimp
taskword DCB "TASK"
 ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

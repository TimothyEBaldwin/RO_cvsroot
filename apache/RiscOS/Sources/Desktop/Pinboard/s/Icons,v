head	4.9;
access;
symbols
	Pinboard-1_04:4.9
	Pinboard-1_03:4.9
	Pinboard-1_02:4.9
	Pinboard-1_01:4.9
	Pinboard-1_00:4.9
	Pinboard-0_99:4.8
	Pinboard-0_98:4.8
	Pinboard-0_97:4.8
	Pinboard-0_96:4.8
	Pinboard-0_95:4.8
	Pinboard-0_94:4.7
	Pinboard-0_93:4.7
	Pinboard-0_92:4.6
	Pinboard-0_91:4.5
	Pinboard-0_90:4.5
	Pinboard-0_89:4.5
	Pinboard-0_88:4.5
	Pinboard-0_87:4.5
	Pinboard-0_86:4.5
	Pinboard-0_85:4.5
	Pinboard-0_84:4.5
	Pinboard-0_83:4.4
	Pinboard-0_82:4.4
	RO_5_07:4.4
	Pinboard-0_81:4.4
	Pinboard-0_80:4.4
	Pinboard-0_79:4.3
	Pinboard-0_78:4.3
	Pinboard-0_77:4.3
	Pinboard-0_76:4.3
	Ursula_merge:4.1.4.5
	Pinboard-0_75:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.4
	Ursula_RiscPC:4.1.4.4.0.2
	rleggett_Pinboard-0_75d:4.1.4.5
	rthornb_UrsulaBuild-19Aug1998:4.1.4.4
	UrsulaBuild_FinalSoftload:4.1.4.4
	rthornb_UrsulaBuild-12Aug1998:4.1.4.4
	aglover_UrsulaBuild-05Aug1998:4.1.4.4
	rthornb_UrsulaBuild-29Jul1998:4.1.4.4
	rthornb_UrsulaBuild-22Jul1998:4.1.4.4
	rleggett_Pinboard-0_75c:4.1.4.4
	rleggett_Pinboard-0_75b:4.1.4.4
	rleggett_Pinboard-0_75:4.1.4.4
	rthornb_UrsulaBuild-15Jul1998:4.1.4.4
	rthornb_UrsulaBuild-07Jul1998:4.1.4.4
	rthornb_UrsulaBuild-17Jun1998:4.1.4.4
	rthornb_UrsulaBuild-03Jun1998:4.1.4.3
	rthornb_UrsulaBuild-27May1998:4.1.4.3
	rthornb_UrsulaBuild-21May1998:4.1.4.3
	rleggett_Pinboard-0_74:4.1.4.3
	rthornb_UrsulaBuild_01May1998:4.1.4.2
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.9
date	2016.05.08.16.45.03;	author jlee;	state Exp;
branches;
next	4.8;
commitid	6qtTwO9XstbZoH5z;

4.8
date	2012.08.23.19.59.08;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	rztFpV1VBvCVZHhw;

4.7
date	2011.09.24.07.25.50;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	NapphrXjtkIXyIAv;

4.6
date	2011.09.19.07.41.57;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	90jvproiNPICO4Av;

4.5
date	2007.09.18.13.28.37;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2003.02.04.14.33.09;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	2001.03.16.17.07.03;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.08.17.19.05.18;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.59;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.59;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.29.48;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.10.21.09.56.58;	author rleggett;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.04.15.11.24.40;	author rleggett;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	98.05.06.08.54.14;	author rleggett;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	98.06.17.09.43.23;	author rleggett;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.09.18.10.18.11;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.20.53;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.18.47;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.9
log
@Avoid unnecessary remainder calculations. Fix wonky "snap to grid" logic.
Detail:
  s/Drag, s/Messages, s/StartLoop - Avoid unnecessary remainder calculation in DivRem macro
  s/Icons - Fix grid coordinate rounding when tidying to the left
Admin:
  Tested on Cortex-A15


Version 1.00. Tagged as 'Pinboard-1_00'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; s.Icons
;
; Handle pinned files.

is_selected     *       (1:SHL:21) :OR: (2_0111 :SHL: 24)
selected        *       (1:SHL:21)

BufferReason_AddAtXY            *       0       ; Put new icon at x,y given path.
BufferReason_Remove             *       1       ; Remove given path.
BufferReason_AddTinyDirsIcon    *       2       ; Add the TinyDirsIcon.
BufferReason_AddNewTinyDir      *       3       ; Add new TinyDir to icon bar.
BufferReason_RemoveAllTinyDirs  *       4       ; Remove all TinyDirs from icon bar.
BufferReason_RemoveAllPinboard  *       5       ; Remove all Pinboard icons.
BufferReason_AddAtXYWithoutLock *       6       ; Put new icon at x,y, but don't lock to grid (if grid on)

;---------------------------------------------------------------------
;BufferIcon
;
;Entry:
;       r0 - Action
;       r1 - Window handle
;       r2 - Path
;       r3 - Length of path
;       r4 - Monotonic ID.
;       r6 - X position
;       r7 - Y position
;Exit:
;       Icon added to *END* of buffered list.
;
BufferIcon

        Push    "r0-r7,LR"

        Debug   pi,"Buffer icon"

        ADR     r1,ActionTable
        LDRB    r1,[r1,r0]
        TST     r1,#1:SHL:2             ; Are we expecting a path ?
        MOVEQ   r3,#0                   ; No, length is 0.
        STREQ   r3,[sp,#3*4]
        BEQ     %FT01

        TST     r1,#1:SHL:0             ; Do we need to check path ?
        BEQ     %FT01                   ; No, skip.

        MOV     r0,#OSFile_ReadWithTypeNoPath
        ADR     r1,dataarea
        SWI     XOS_File
        STRVS   r0,[sp]
        Pull    "r0-r7,PC",VS

        TEQ     R0,#3                   ; image file
        BNE     %FT00

        MOV     R0,#OSFile_ReadNoPath
        ADR     r1,dataarea
        SWI     XOS_File

        MOV     R14,#&ff
        ORR     R14,R14,#&f00

        TEQ     R14,R2, LSR #20         ; load address or type/date ?
        MOVEQ   R6,R2, LSR #8           ; image file type stored in load address
        ANDEQ   R6,R6,R14
00
        CMP     r0,#0
        MOVEQ   r2,r0
        MOVEQ   r0,#OSFile_MakeError
        SWIEQ   XOS_File
        STRVS   r0,[sp]
        Pull    "r0-r7,PC",VS

; r6 = File type of icon.

01

        MOV     r0,#ModHandReason_Claim ; Claim RMA block.
        LDR     r3,[sp,#3*4]
        ADD     r3,r3,#ic_block_size

        [ truncate_filenames
        ; find out how much extra space is required to store the icon text
        ; ie. the truncated leafname.
        Push    "r2-r3"
        LDR     r2, [sp, #(2+2)*4]      ; pointer to path
        MOV     r3, #0
        BL      do_truncation           ; return truncated length in r3
        ADD     r8, r3, #4              ; add extra for ellipsis and terminator
        Pull    "r2-r3"
        ADD     r3, r3, r8
        ]

        SWI     XOS_Module
        STRVS   r0,[sp]
        Pull    "r0-r7,PC",VS

; Block claimed, now fill in the details.
        ASSERT  ic_next=0

        ADR     r14,Buffered_list       ; First link to list.
        Debug   sa,"buffered list is at ",r14
01
        LDR     r0,[r14,#ic_next]
        CMP     r0,#0
        MOVNE   r14,r0
        BNE     %BT01

        Debug   sa,"Linking to block at ",r14
        LDR     r0,[sp,#0*4]
        Debug   sa,"ACtion is ",r0

        STR     r2,[r14,#ic_next]
        STR     r14,[r2,#ic_prev]
        MOV     r0,#0
        STR     r0,[r2,#ic_next]

        LDR     r0,[sp,#0*4]
        STR     r0,[r2,#ic_action]

        ADR     r1,ActionTable          ; Are we expecting a path ?
        LDRB    r1,[r1,r0]
        TST     r1,#1:SHL:2
        BEQ     %FT10

        LDR     r14,[sp,#2*4]           ; Pointer to path
        LDR     r3 ,[sp,#3*4]           ; Length of path
        ADD     r4,r2,#ic_path
01
        LDRB    r5,[r14],#1             ; Copy into block.
        STRB    r5,[r4], #1
        SUBS    r3,r3,#1
        BNE     %BT01

        [ truncate_filenames
        Push    "r0-r3"
        LDR     r1, [sp, #(4+3)*4]      ; length of path
        ADD     r3, r2, #ic_path
        ADD     r3, r3, r1              ; offset to icon text
        STR     r3, [r2, #ic_icontext]  ; store this offset
        ADD     r2, r2, #ic_path        ; address of path
        BL      do_truncation
        Pull    "r0-r3"
        ]


10
        TST     r1,#1:SHL:1             ; Window handle ?
        LDRNE   r5,[sp,#1*4]
        STRNE   r5,[r2,#ic_window]

        TST     r1,#1:SHL:4             ; ID ?
        LDRNE   r5,[sp,#4*4]
        STRNE   r5,[r2,#ic_id]

        TST     r1,#1:SHL:5             ; File type ?
        STRNE   r6,[r2,#ic_filetype]

        TST     r1,#1:SHL:6             ; X ?
        LDRNE   r5,[sp,#6*4]
        STRNE   r5,[r2,#ic_x]

        TST     r1,#1:SHL:7             ; Y ?
        LDRNE   r5,[sp,#7*4]
        STRNE   r5,[r2,#ic_y]

        LDR     r0,poll_word
        ORR     r0,r0,#PollWordReason_Buffered
        STR     r0,poll_word

        Pull    "r0-r7,PC"

; ActionTable
; Each bit in this table tells which values are passed in for each possible action
; Bit 0 = Verify that path exists.
; Bit 1 = r1 (Window handle)
; Bit 2 = r2 (Path)
; And so on.
;
; Bit 5 is the file type, and is derived from the path.
;
ActionTable
        DCB     2_11111111              ; Action 0 = Add icon at x,y.
        DCB     2_00001100              ; Action 1 = Remove icon given path.
        DCB     2_00000000              ; Action 2 = Add TinyDirs icon
        DCB     2_11111111              ; Action 3 = Add new TinyDir
        DCB     0
        DCB     0
        DCB     2_11111111              ; Action 6 = Add icon at x,y, ignoring grid
        ALIGN


;--------------------------------------------------------------------
; DeselectFileIcons
;
;Entry:
;       r0 = Window handle
;Exit:
;       All active icons on window deselected.
;
;
DeselectFileIcons   ROUT

        Push    "r0-r4,LR"
        MOV     r4,r0

        ADR     r1,dataarea
        STR     r0,[r1]

        MOV     r0,#0
        CMP     r4,#0
        STRGE   r0,Pinboard_Selected
        STRLT   r0,TinyDirs_Selected



        ADR     r2,Icon_list-ic_next
01
        LDR     r2,[r2,#ic_next]
        CMP     r2,#0
        Pull    "r0-r4,PC",EQ           ; End of list

        LDR     r14,[r2,#ic_window]
        TEQ     r14,r4
        BNE     %BT01                   ; Not in this window

        LDR     r14,[r2,#ic_icon]
        STR     r14,[r1,#4]
        SWI     XWimp_GetIconState
        STRVS   r0,[sp]
        Pull    "r0-r4,PC",VS

        LDR     r14,[r1,#24]
        TST     r14,#selected
        BEQ     %BT01

        MOV     r14,#0
        STR     r14,[r1,#8]
        CMP     r4,#-2
        MOVNE   r14,#is_selected
        MOVEQ   r14,#selected
        STR     r14,[r1,#12]
        SWI     XWimp_SetIconState
        STRVS   r0,[sp]
        Pull    "r0-r4,PC",VS

        B       %BT01

        Pull    "r0-r4,PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DeselectWindowIcons
;
; Deselect all currently selected iconised window icons (within the window
; specified).
;
; In: r0 = Window handle (only backdrop_handle) currently
;
; Out: All registers preserved.

DeselectWindowIcons Entry "r0-r5"

        MOV     r4, r0
        LDR     r5, Windows_Selected     ; Number of backdrop icons selected
        ADR     r1, dataarea             ; temporary store for Wimp_Get and Wimp_SetIconState
        STR     r0, [r1]                 ; store window handle in first word
        LDR     r3, iconized_ptr         ; location of first iconised data block
02
        CMP     r3, #0                   ; have we reached end of list?
        BEQ     %FT06
        LDR     r2, [r3, #w_icon_id]     ; load window handle of icon
        CMP     r2, r4                   ; is it the same as the window specified?
        BNE     %FT04
        LDR     r2, [r3, #w_icon_handle] ; load the icon handle
        STR     r2, [r1, #4]             ; store in the second word of the dataarea
        SWI     XWimp_GetIconState       ; Get the icon state
        EXIT    VS

        LDR     r2, [r1, #24]            ; R1+24 stores the flags word returned by GetIconState
        TST     r2, #selected            ; Is this icon selected?
        BEQ     %FT04
        MOV     r2, #0                   ; Icon selected, so unselect it.
        STR     r2, [r1, #8]
        MOV     r2, #is_selected
        STR     r2, [r1, #12]
        SWI     XWimp_SetIconState
        EXIT    VS
        SUB     r5, r5, #1
04
        LDR     r3, [r3, #w_next_ptr]    ; find the next icon block
        B       %BT02
06
        STR     r5, Windows_Selected
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DeselectWindowIcons
;
; Deselect all currently selected file and window icons, within the window with
; specified handle.
;
; In: r0 = Window handle
;
; Out: All registers preserved.

DeselectAllIcons Entry

        Push    "r0"
        BL      DeselectWindowIcons
        Pull    "r0"
        BL      DeselectFileIcons
        MOV     r0, #0
        STR     r0, Pinboard_Selected
        STR     r0, Windows_Selected
        EXIT


;--------------------------------------------------------------------
; SelectFileIcons
;
;Entry:
;       r0 = Window handle
;Exit:
;       All active icons on window selected.
;
;
SelectFileIcons     ROUT
        Push    "r0-r6,LR"
        MOV     r4,r0
        MOV     r5,#0
        CMP     r0,#0
        ADRGE   r6,Pinboard_Selected
        ADRLT   r6,TinyDirs_Selected

        ADR     r1,dataarea
        STR     r0,[r1]
        MOV     r14,#is_selected
        STR     r14,[r1,#8]
        STR     r14,[r1,#12]

        LDR     r2,Icon_list
01
        CMP     r2,#0
        Pull    "r0-r6,PC",EQ           ; End of list
        LDR     r14,[r2,#ic_window]
        TEQ     r14,r4
        ADDEQ   r5,r5,#1
        STREQ   r5,[r6]

        LDREQ   r14,[r2,#ic_icon]
        STREQ   r14,[r1,#4]
        SWIEQ   XWimp_SetIconState
        STRVS   r0,[sp]
        Pull    "r0-r6,PC",VS

        LDR     r2,[r2,#ic_next]
        B       %BT01

        Pull    "r0-r6,PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectWindowIcons
;
; Make all iconised window icons in specified window selected.
;
; In: r0 = window handle (currently only backdrop_handle)
;
; Out: All registers preserved

SelectWindowIcons Entry "r0-r5"

        MOV     r4, r0
        LDR     r5, Windows_Selected     ; Number of icons selected on the backdrop
        ADR     r1, dataarea             ; temporary store for Wimp_SetIconState
        STR     r0, [r1]
        MOV     r2, #is_selected
        STR     r2, [r1, #8]
        STR     r2, [r1, #12]
        LDR     r3, iconized_ptr
02
        CMP     r3, #0
        BEQ     %FT06
        LDR     r2, [r3, #w_icon_id]     ; load window handle of icon
        CMP     r2, r4                   ; is it the same as the window specified?
        BNE     %FT04
        LDR     r2, [r3, #w_icon_handle] ; load the icon handle
        STR     r2, [r1, #4]             ; store in the second word of the dataarea
        SWI     XWimp_SetIconState
        ADD     r5, r5, #1               ; Increment the number of selected icons count
04
        LDR     r3, [r3, #w_next_ptr]    ; find the next icon block
        B       %BT02
06
        STR     r5, Windows_Selected
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectAllIcons
;
; Make all icons in specified window selected.
;
; In: r0 = window handle
;
; Out: All registers preserved

SelectAllIcons Entry

        BL      SelectWindowIcons
        BL      SelectFileIcons
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; FindIcon
;
; Tries to find an icon in the file linked list
;
; In: r1 = Window handle
;     r2 = Icon handle
;
; Out: r2 -> icon block , Z set if found
;      Z clear if not found.

FindIcon        ROUT

        Entry   "r0-r4"

        LDR     r0,Icon_list
01
        CMP     r0,#1
        EXIT    LT                      ; Not found Z clear

        LDR     r3,[r0,#ic_window]
        TEQ     r3,r1
        LDREQ   r3,[r0,#ic_icon]
        TEQEQ   r3,r2
        LDRNE   r0,[r0,#ic_next]
        BNE     %BT01

        STR     r0,[sp,#2*4]
        EXIT                            ; Z set


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; FindIconBoth
;
; Does a FindIcon on both file and window linked lists
;
; In: r1 = Window handle
;     r2 = Icon handle
;
; Out: r0 = 0 => icon not found
;           1 => icon is an iconized window
;           2 => icon is a filer-icon
;      r2 -> icon block , Z set if found
;      Z clear if not found.

FindIconBoth    ROUT

        Entry   "r0-r4"

        MOV     r4, #2
        LDR     r0,Icon_list
01
        CMP     r0,#1
        BLT     %FT02

        LDR     r3,[r0,#ic_window]
        TEQ     r3,r1
        LDREQ   r3,[r0,#ic_icon]
        TEQEQ   r3,r2
        LDRNE   r0,[r0,#ic_next]
        BNE     %BT01

        STR     r0,[sp,#2*4]
        STR     r4,[sp,#0*4]            ; (FG) return icon type
        EXIT                            ; Z set
02
        SUB     r4, r4, #1
        CMP     r4, #1
        EXIT    LT                      ; Not found Z clear
        LDR     r0, iconized_ptr
        B       %BT01


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Find BBOX
;
; In: r0 = Window handle
;     r2 -> icon block of icon clicked on
;     r3 = use DragASprite if non-0
;
; Out: r6-r9 BBOX of selected items in window. (x0,y0,x1,y1)

FindBBOX        ROUT

        Entry   "r0-r5, r11"

        ADR     r1,dataarea
        STR     r0,[r1]

        ; Set up BBOX with silly values
        MOV     r6,#&80000
        MOV     r7,#&80000
        MOV     r8,#-1
        MOV     r9,#-1

        MOV     r11, #0                 ; =0 means we're on files, =1 means windows
        MOV     r5,#0
        LDR     r4,Icon_list
01
        CMP     r4,#0                   ; Is this the end of the list?
        BEQ     %FT20

        ; Check icon is in window we're interested in.
        LDR     r14,[r4,#ic_window]
        LDR     r0,DragWindow
        TEQ     r14,r0
        BNE     %FT10

        ; Get current state of icon
        LDR     r14,[r4,#ic_icon]
        STR     r14,[r1,#4]
        SWI     XWimp_GetIconState
        STRVS   r0,[sp]
        EXIT    VS

        ; Check if selected
        LDR     r14,[r1,#24]
        TST     r14,#selected
        BEQ     %FT10

        ; Count icons for DragASprite
        ADD     r5,r5,#1

        ; Adjust bounding box to include this icon
        LDR     r14,[r1,#8]             ; x0
        CMP     r14,r6
        MOVLT   r6,r14
        LDR     r14,[r1,#12]            ; y0
        CMP     r14,r7
        MOVLT   r7,r14
        LDR     r14,[r1,#16]            ; x1
        CMP     r14,r8
        MOVGT   r8,r14
        LDR     r14,[r1,#20]            ; y1
        CMP     r14,r9
        MOVGT   r9,r14
10
        LDR     r4,[r4,#ic_next]
        B       %BT01

20 ; Deal with end of list
        ADD     r11, r11, #1
        CMP     r11, #1
        LDREQ   r4, iconized_ptr
        BEQ     %BT01

        SWI     XWimp_GetWindowState
        EXIT    VS

        LDR     r4,[r1,#20]              ; scroll x offset
        SUB     r6,r6,r4
        SUB     r8,r8,r4

        CMP     r3,#0
        EXIT    EQ

; Do DragASprite on clicked on icon
        LDR     r14,[r2,#ic_icon]
        STR     r14,[r1,#4]
        SWI     XWimp_GetIconState
        STRVS   r0,[sp]
        EXIT    VS

        ; Set up sprite name depending on number of icons selected
        CMP     r5,#1
        EXIT    LT
        ADDEQ   r2,r2,#ic_spritename+1
        ADRGT   r2,package

        Push    "r6-r9"                 ; save real bounding box

        LDR     r6,[r1,#8]              ; x0
        SUB     r6,r6,r4                ; take account of shifted window
        LDR     r8,[r1,#16]             ; x1
        SUB     r8,r8,r4                ; take account of shifted window
        LDR     r7,[r1,#12]             ; y0
        LDR     r9,[r1,#20]             ; y1

        SUB     r0,r8,r6
        CMP     r0,#grid_x_spacing
        RSBLT   r0,r0,#grid_x_spacing
        SUBLT   r6,r6,r0,LSR #1
        ADDLT   r8,r8,r0,LSR #1
        SUB     r0,r9,r7
        CMP     r0,#grid_y_spacing
        RSBLT   r0,r0,#grid_y_spacing
        SUBLT   r7,r7,r0,LSR #1
        ADDLT   r9,r9,r0,LSR #1

        LDR     r0,DragWindow
        CMP     r0,#0
        ADDLT   r7,r7,#24
        ADDLT   r9,r9,#24

        Push    "r6-r9"
        MOV     R0,#DS_HJustify_Centre :OR: DS_VJustify_Top :OR: DS_BoundTo_Screen :OR: DS_Bound_Pointer :OR: DS_DropShadow_Present
        MOV     r1,#1
        MOV     r3,sp
        Debug   tmp,"doing DragASprite"
        SWI     XDragASprite_Start
        ADD     sp,sp,#4*4
        Pull    "r6-r9"                 ; restore real bounding box

        EXIT

package
        DCB     "package",0
        ALIGN


;--------------------------------------------------------------------
; RemoveIcons
;
;Entry:
;       r0 = Window handle
;Exit:
;       All selected icons on window removed.
;

RemoveIcons   ROUT
        Push    "r0-r5,LR"
        MOV     r4,r0
        CMP     r4,#0
        ADRGT   r3,Pinboard_Selected
        ADRLT   r3,TinyDirs_Selected

        ADR     r1,dataarea

        LDR     r5,Icon_list
01
        MOVS    r2,r5
        STREQ   r2,[r3]
        Pull    "r0-r5,PC",EQ                   ; End of list
        LDR     r5,[r2,#ic_next]

        LDR     r14,[r2,#ic_window]
        TEQ     r14,r4
        BNE     %BT01                           ; Not in wanted window.

        STR     r14,[r1]
        LDR     r14,[r2,#ic_icon]
        STR     r14,[r1,#4]
        SWIEQ   XWimp_GetIconState
        STRVS   r0,[sp]
        Pull    "r0-r5,PC",VS

        LDR     r14,[r1,#8+16]
        TST     r14,#selected
        BEQ     %BT01                           ; Not selected.

        LDR     r14,[r1]
        CMP     r14,#0
        LDRGE   r14,Pinboard_Icons
        LDRLT   r14,TinyDirs_Icons
        SUB     r14,r14,#1
        STRGE   r14,Pinboard_Icons
        STRLT   r14,TinyDirs_Icons

        ORR     r14,r14,#if_funnyicon
        ORR     r14,r14,#is_deleted
        STR     r14,[r1,#8]
        STR     r14,[r1,#12]
        SWI     XWimp_SetIconState
        SWIVC   XWimp_DeleteIcon
        STRVS   r0,[sp]
        Pull    "r0-r5,PC",VS

        LDR     r0,[r2,#ic_prev]
        CMP     r0,#0
        STRGT   r5,[r0,#ic_next]
        STRLE   r5,Icon_list
        CMP     r5,#0
        STRNE   r0,[r5,#ic_prev]

        MOV     r0,#ModHandReason_Free
        SWI     XOS_Module
        STRVS   r0,[sp]
        Pull    "r0-r5,PC",VS

        B       %BT01


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 [ debug_commands
deb_winsel Entry "r0-r5"

        SUB     sp, sp, #4

        WRLN    " "
        STRIM   "   Pinboard_Icons:"
        LDR     r0, Pinboard_Icons
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine

        STRIM   "     Window_Icons:"
        LDR     r0, Window_Icons
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine

        STRIM   "Pinboard_Selected:"
        LDR     r0, Pinboard_Selected
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine

        STRIM   "  Window_Selected:"
        LDR     r0, Windows_Selected
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine

        STRIM   "    Iconbar_Icons:"
        LDR     r0, Iconbar_Icons
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine

        ADD     sp, sp, #4
        EXIT
 ]


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; FindNearestGridXY
;
; Given an x, y co-ord, return the nearest x,y of a grid point.
; Grid's origin is the corner which is currently selected for tidying
; icons to.
;
; In: r5, r6 - x and y
;
; Out: r5, r6 - new x and y

FindNearestGridXY Entry "r0-r4, r7-r11"

   ; Work out the x co-ord of the nearest grid position
        LDR     r4, Pinboard_options
        TST     r4, #PinboardOption_TidyToCornerLR
        BNE     %FT03
        ; If tidy to left
        MOV     r10, #grid_x_spacing
        DivRem  r1, r5, r10, r2
        CMP     r5, r10, LSR #1
        ADDGT   r1, r1, #1
        MUL     r5, r1, r10                  ; x = (mouse_x DIV x_spacing) * x_spacing
        B       %FT04
03      ; If tidy to right
        MOV     r10, #grid_x_spacing
        LDR     r11, Screen_x1
        SUB     r2, r11, r5
        DivRem  r1, r2, r10, r0
        CMP     r2, r10, LSR #1
        ADDGT   r1, r1, #1
        MUL     r2, r1, r10
        SUB     r5, r11, r2

04 ; Work out the y co-ord of the nearest grid position
        TST     r4, #PinboardOption_TidyToCornerTB
        BNE     %FT06
        ; If tidy to top
        MOV     r10, #grid_y_spacing
        LDR     r11, Screen_y1
        SUB     r2, r11, r6
        DivRem  r1, r2, r10, r0
        CMP     r2, r10, LSR #1
        ADDGT   r1, r1, #1
        MUL     r2, r1, r10
        SUB     r6, r11, r2
        EXIT
06      ; If tidy to bottom
        LDR     r0, icon_bar_height
        SUB     r6, r6, r0                   ; grid starts above icon bar, so subtract it's height
        CMP     r6, #0
        MOVLT   r6, #0
        MOV     r10, #grid_y_spacing
        DivRem  r1, r6, r10, r2
        CMP     r6, r10, LSR #1
        ADDGT   r1, r1, #1
        MLA     r6, r1, r10, r0              ; y = ((mouse_y DIV y_spacing) * y_spacing) + icon_bar_height
        EXIT


 [ truncate_filenames
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In: r2 -> path string
;     r3 -> destination, or =0 to return number of displayable characters.
;
; Out: r3 = number of characters displayed, if r3 = 0 on entry, else preserved.

do_truncation Entry "r0-r2, r4-r9"

        ; find leafname and put into r6
        MOV     r6, r2                       ; first guess for leafname is start of string
        MOV     r1, #0                       ; r1 is byte counter
04      LDRB    r0, [r2, r1]                 ; load next byte of string
        CMP     r0, #"."
        ADDEQ   r6, r2, r1                   ; if it's a dot, then it's our best guess so far
        ADDEQ   r6, r6, #1
        CMP     r0, #32                      ; if it's <32, then it's the string end
        BLT     %FT08
        ADD     r1, r1, #1                   ; next character
        CMP     r1, #256                     ; gone too far?
        BLT     %BT04

        ; truncate it
08      MOV     r7, r3
        BL      truncate_filename
        MOV     r3, r7
        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; truncate_filename
;
; Take a filename in and output the truncated version (including ellipsis).
;
; In:   r6 -> filename
;       r7 -> output buffer (or 0 to return size)
;
; Out: r7 = truncation length (no.chars) if r7 = 0 on entry, else preserved.
;      All other regs preserved.

truncate_filename Entry "r0-r6, r10-r11"

        MOV     r0, #4
        MOV     r1, r6
        MOVS    r2, r7
        MOVEQ   r3, #0            ; just find size if no buffer specified
        MOVNE   r3, #1:SHL:24     ; if buffer specified, it will have room
        MOV     r4, #grid_x_spacing - 4
        SWI     XWimp_TextOp
        BVS     %FT01
        TEQ     r7, #0
        MOVEQ   r7, r0
        EXIT

01      ; Fall back to our own (vroken) code if Wimp isn't new enough.

        ; What's the maximum width we allow?
        MOV     r1, #grid_x_spacing
        SUB     r1, r1, #4
        MOV     r2, r1
        SWI     XFont_Converttopoints
        MOV     r8, r2

        ; Set font to desktop font
        MOV     r0, #8
        SWI     XWimp_ReadSysInfo
        CMP     r0, #0            ; If system font, skip to different routine
        BEQ     %FT30
        SWI     XFont_SetFont

        ; Where would we need to split the string to fit the maximum width?
        MOV     r1, r6
        MOV     r2, r8
        MOV     r3, r8
        MOV     r4, #-1
        MOV     r5, #256
        SWI     XFont_StringWidth
        MOV     r10, r4

        ; Now find the length of the filename string
        MOV     r2, r6
        BL      strlen
        SUB     r11, r3, #1

        ; If the string is split before end of length, then find the new split size, taking
        ; into account the ellipsis character which we will add.
        CMP     r11, r10
        BLE     %FT20
        MOV     r1, r6
        LDR     r3, ellipsis_width
        SUB     r2, r8, r3
        MOV     r3, r8
        MOV     r4, #-1
        MOV     r5, #256
        SWI     XFont_StringWidth
        MOV     r10, r4

        ; Copy string (upto split character) to icon buffer
20      B       %FT40

        ; Deal with system font
        ; Covert millipoints back to OS units
        ; Shift right 5 to divide by 32 and find number of characters
        ; If less than string width, subtract 1 and add ellipsis.
30      MOV     r1, r8
        MOV     r2, #0
        SWI     XFont_ConverttoOS    ; this returns max width in OS units
        MOV     r0, r1, LSR #4       ; divide max width by 16 to get number of chars

        MOV     r2, r6
        BL      strlen
        SUB     r11, r3, #1          ; r11 = length of string
        MOV     r10, r11             ; r10 = how many characters we'll display (try for whole length)
        CMP     r10, r0              ; see if whole length will fit
        SUBGT   r10, r0, #1          ; if not, put max characters-1 (we'll ad an ellipsis)

        ; Copy string (upto split character) to icon buffer
40      CMP     r7, #0
        MOVEQ   r7, r10
        EXIT    EQ

        MOV     r0, r7
        MOV     r1, r6
        MOV     r2, r10

44      LDRB    r14, [r1], #1
        STRB    r14, [r0], #1
        SUB     r2, r2, #1
        CMP     r2, #0
        BGT     %BT44

        ; If necessary, add ellipsis character
        CMP     r11, r10
        MOVGT   r14, #140
        STRGTB  r14, [r0], #1
        MOV     r14, #0
        STRB    r14, [r0], #1
        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; read_font_widths
;
; Read some widths needed by the truncation code

read_font_widths Entry "r0-r6"

        ; Set font to desktop font
        MOV     r0, #8
        SWI     XWimp_ReadSysInfo
        CMP     r0, #0
        SWINE   XFont_SetFont

        ; What's the width of an ellipsis in the current font?
        ADR     r1, ellipsis_str
        MOV     r2, #71680
        ADD     r2, r2, #320
        MOV     r3, r2
        MOV     r4, #-1
        MOV     r5, #1
        SWI     XFont_StringWidth
        STR     r2, ellipsis_width

        EXIT

ellipsis_str DCB "Œ",0
 ]

        LNK     Buffered.s
@


4.8
log
@Fix for patchy tiled backdrops on changing to non EX1/EY1 mode
Pinboard keeps a note of the mode (from OS_Byte 135) that the backdrop sprite tile was last cached in, to avoid having to recache it all the time. However, the comparison fails when the mode specifier block (ie. when OS_Byte 135 is not reporting a numeric screen mode) is static since although the mode might have changed Pinboard would not think it had and hence not recache the sprite.
The result is a patchy desktop, for example changing from EX1/EY1 to EX0/EY0 would leave a quadrant arrangement of 1 redrawn patch and 3 not redrawn.
Backdrop.s:
Line 151 onwards, when a mode specifier is used, build a magic mode word combining EX EY and BPP (the 3 parameters the cache sprite function cares about), as a stronger check.
Tail.s:
Line 130 onwards, calculate the iconbar height properly (previously used 134 pixels for EY0 modes, 1 too high, leading to a thin strip of background colour above the iconbar.
Other changes
 - Use sprite area offset names from Hdr:Sprites rather than magic numbers
 - Use OS_Byte reasons from Hdr:OsBytes
 - Use "file.s" style names in LNK commands
 - Move BadOptions/NotASprite error blocks to avoid range error when assembling debug versions
 - true and false for objasm {TRUE} and {FALSE}

Version 0.95. Tagged as 'Pinboard-0_95'
@
text
@d784 1
a784 1
        CMP     r5, r10, LSR #2
@


4.7
log
@Replace magic numbers with sumbols from header files for OS_ calls.
Same binary as 0.92, not tagged.
@
text
@d992 1
a992 1
        LNK     s.Buffered
@


4.6
log
@Restore *AddTinyDir <nothing> functionality.
See ticket #283.
Moved 'Status' document into Docs.
Merged 'Changes' into 'BlackLog' and delete.
Expanded 2x POPs of lr/pc cos ARM deprecated it.
Combined 2x MUL/ADD into MLA so the module is the same size.

Version 0.92. Tagged as 'Pinboard-0_92'
@
text
@d60 1
a60 1
        MOV     r0,#23                  ; Read catalogue info with type / no path
d69 1
a69 1
        MOV     R0,#17
d82 1
a82 1
        MOVEQ   r0,#19                  ; Generate error.
@


4.5
log
@  Enable soft-selection of iconized window icons.
Detail:
  Clicking Menu over a filer-icon will cause it to be soft-selected if
  no icons have been selected. For iconized window icons this doesn't
  work.
  This changeset removes this limitation. The Selection -> Remove menu
  item will be corectly shaded (for iconized-icons) or unshaded (for
  filer-icons).
Admin:
  Tested on Iyonix RO5.11
Notes:
  Changes by Fred Graute.

Version 0.84. Tagged as 'Pinboard-0_84'
@
text
@d820 1
a820 2
        MUL     r9, r1, r10                  ; y = (mouse_y DIV y_spacing) * y_spacing
        ADD     r6, r9, r0
@


4.4
log
@  Leafname truncation fix.
Detail:
  Tries to use Wimp_TextOp 4 to do ellipsis truncation. Fixes same bugs as
  Filer 2.08.
Admin:
  Tested on Tungsten.

Version 0.80. Tagged as 'Pinboard-0_80'
@
text
@d469 4
a472 1
; Out: r2 -> icon block , Z set if found
d493 1
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.76. Tagged as 'Pinboard-0_76'
@
text
@d863 14
@


4.2
log
@Ursula branch merged.
Added inclusion of Machine header for new CMOS header
Moved to srccommit.
Templates contain hardwired version/date information which is a long
  way out of date.  This has not been fixed in this checkin.

Version 0.75. Tagged as 'Pinboard-0_75'
@
text
@d17 1
a17 1
; Handle pinned files.     
d20 1
a20 1
selected        *       (1:SHL:21) 
d75 1
a75 1
                                                                                
d110 1
a110 1
        
d121 1
a121 1
                                    
d130 1
a130 1
        
d136 1
a136 1
        TST     r1,#1:SHL:2             
d159 1
a159 1
       
d171 1
a171 1
        
d195 1
a195 1
ActionTable        
d200 1
a200 1
        DCB     0  
d204 1
a204 1
             
d234 1
a234 1
        Pull    "r0-r4,PC",EQ           ; End of list        
d255 1
a255 1
        STR     r14,[r1,#12]      
d260 1
a260 1
        B       %BT01        
d275 1
a275 1
DeselectWindowIcons ENTRY "r0-r5"
d280 3
a282 3
        STR     r0, [r1]                 ; store window handle in first word        
        LDR     r3, iconized_ptr         ; location of first iconised data block        
02      
d292 1
a292 1
        
d309 1
a309 1
        
d321 1
a321 1
DeselectAllIcons ENTRY
d359 1
a359 1
        Pull    "r0-r6,PC",EQ           ; End of list        
d361 1
a361 1
        TEQ     r14,r4  
d372 1
a372 1
        B       %BT01        
d386 1
a386 1
SelectWindowIcons ENTRY "r0-r5"
d423 1
a423 1
SelectAllIcons ENTRY
d437 1
a437 1
; 
d439 1
a439 1
;      Z clear if not found.                   
d443 1
a443 1
        ENTRY   "r0-r4"
d468 1
a468 1
; 
d470 1
a470 1
;      Z clear if not found.                   
d474 1
a474 1
        ENTRY   "r0-r4"
d497 1
a497 1
        
d510 1
a510 1
        ENTRY   "r0-r5, r11"
d532 1
a532 1
        BNE     %FT10     
d534 1
a534 1
        ; Get current state of icon           
d547 1
a547 1
        ADD     r5,r5,#1 
d628 1
a628 1
 
d630 1
a630 1
       
d658 1
a658 1
        Pull    "r0-r5,PC",EQ                   ; End of list        
d663 1
a663 1
        BNE     %BT01                           ; Not in wanted window.                            
d710 1
a710 1
deb_winsel ENTRY "r0-r5"
d713 1
a713 1
        
d754 1
a754 1
        
d758 1
a758 1
 
d771 1
a771 1
FindNearestGridXY ENTRY "r0-r4, r7-r11"
d793 1
a793 1
        
d811 1
a811 1
        MOVLT   r6, #0 
d828 1
a828 1
do_truncation ENTRY "r0-r2, r4-r9"
d842 1
a842 1
        
d861 1
a861 1
truncate_filename ENTRY "r0-r6, r10-r11"
d884 1
a884 1
        MOV     r10, r4        
d886 1
a886 1
        ; Now find the length of the filename string 
d890 1
a890 1
        
d906 1
a906 1
          
d910 1
a910 1
        ; If less than string width, subtract 1 and add ellipsis.        
d915 1
a915 1
                
d917 1
a917 1
        BL      strlen               
d922 2
a923 2
        
        ; Copy string (upto split character) to icon buffer        
d937 1
a937 1
        
d952 1
a952 1
read_font_widths ENTRY "r0-r6"
@


4.1
log
@Initial revision
@
text
@a21 16
                ^       0
ic_next         #       4       ; Pointer to next icon
ic_prev         #       4       ; Pounter to prev icon
ic_id           #       4       ; Monotonic icon ID
ic_action       #       4       ; What to do with this icon (For buffered icons)
ic_filetype     #       4       ; File type of icon's file (For any other icon).
ic_window       #       4       ; Window handle for this icon.
ic_icon         #       4       ; Icon handle for this icon.
ic_x            #       4       ; X and Y positions in window.
ic_y            #       4       ;
ic_spritename   #       16      ; Sprite name to use.
ic_path         #       0       ; Full path for this icon.

        ASSERT  ic_next = 0
ic_block_size   *       @@-ic_next

d28 1
d94 13
d110 1
a110 1

d130 1
a130 1

d147 12
d202 1
d207 1
a207 1
; DeselectIcons
d215 2
a216 1
DeselectIcons   ROUT
d265 68
d334 1
a334 1
; SelectIcons
d342 1
a342 1
SelectIcons     ROUT
d376 44
a419 2
;---------------------------------------------------------------------
;FindIcon
d421 11
a431 6
;Entry:
;       r1 = Window handle
;       r2 = Icon handle
;Exit:
;       r2 -> icon block , Z set if found
;       Z clear if not found.                   
d433 1
d435 6
a441 1
        Push    "r0-r4,LR"
d443 34
d480 1
a480 1
        Pull    "r0-r4,PC",LT           ; Not found Z clear
d490 8
a497 1
        Pull    "r0-r4,PC"              ; Z set.
d499 2
a500 2
;--------------------------------------------------------------------------
;Find BBOX
d502 3
a504 6
; Entry:
;       r0 = Window handle
;       r2 -> icon block of icon clicked on
;       r3 = use DragASprite if non-0
; Exit:
;       r6-r9 BBOX of selected items in window. (x0,y0,x1,y1)
d506 2
d510 1
a510 1
        Push    "r0-r5,LR" 
a511 1
        Debug   tmp,"r0 (window handle) = ",r0
d515 1
d521 1
d525 2
a526 2
        CMP     r4,#0
        BEQ     %FT20                   ; Deal with end of list
d528 1
a530 1
        Debug   tmp,"r0 (window handle) = ",r0
d533 2
a534 1
                   
d539 1
a539 1
        Pull    "r0-r5,PC",VS
d541 2
a542 1
        LDR     r14,[r1,#24]            ; Get icon flags
d544 1
a544 1
        BEQ     %FT10                   ; Not selected.
d546 2
a547 1
        ADD     r5,r5,#1                ; Count icons for DragASprite
d549 1
a552 1

a555 1

a558 1

d566 5
a570 4
; Deal with end of list
20
        Debug   pi,"end of list"
        Debug   pi,"bounding box = ",r6,r7,r8,r9
d573 2
a574 1
        Pull    "r0-r5,PC",VS
a575 1
        Debug   pi,"Scroll x offset = ",r4
d580 2
a581 1
        Pull    "r0-r5,PC",EQ           ; No DragASprite so return
d587 1
a587 1
        Pull    "r0-r5,PC",VS
d591 1
a591 1
        Pull    "r0-r5,PC",LT
a593 1
        DebugS  tmp,"sprite = ",r2
a626 1

d628 2
a629 2

        Pull    "r0-r5,PC"              ; End of list
d635 1
d644 1
a644 1
;
a651 1

d707 268
a975 1

@


4.1.4.1
log
@Windows, as well as files, can be selected, plus new menu structure and options
@
text
@d22 16
a43 1
BufferReason_AddAtXYWithoutLock *       6       ; Put new icon at x,y, but don't lock to grid (if grid on)
a191 1
        DCB     2_11111111              ; Action 6 = Add icon at x,y, ignoring grid
d196 1
a196 1
; DeselectFileIcons
d204 1
a204 2
DeselectFileIcons   ROUT

a252 63
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DeselectWindowIcons
;
; Deselect all currently selected iconised window icons (within the window
; specified).
;
; In: r0 = Window handle (only backdrop_handle) currently
;
; Out: All registers preserved.

DeselectWindowIcons ENTRY "r0-r5"

        MOV     r4, r0
        LDR     r5, Windows_Selected     ; Number of backdrop icons selected
        ADR     r1, dataarea             ; temporary store for Wimp_Get and Wimp_SetIconState
        STR     r0, [r1]                 ; store window handle in first word        
        LDR     r3, iconized_ptr         ; location of first iconised data block        
02      
        CMP     r3, #0                   ; have we reached end of list?
        BEQ     %FT06
        LDR     r2, [r3, #w_icon_id]     ; load window handle of icon
        CMP     r2, r4                   ; is it the same as the window specified?
        BNE     %FT04
        LDR     r2, [r3, #w_icon_handle] ; load the icon handle
        STR     r2, [r1, #4]             ; store in the second word of the dataarea
        SWI     XWimp_GetIconState       ; Get the icon state
        EXIT    VS
        
        LDR     r2, [r1, #24]            ; R1+24 stores the flags word returned by GetIconState
        TST     r2, #selected            ; Is this icon selected?
        BEQ     %FT04
        MOV     r2, #0                   ; Icon selected, so unselect it.
        STR     r2, [r1, #8]
        MOV     r2, #is_selected
        STR     r2, [r1, #12]
        SWI     XWimp_SetIconState
        EXIT    VS
        SUB     r5, r5, #1
04
        LDR     r3, [r3, #w_next_ptr]    ; find the next icon block
        B       %BT02
06
        STR     r5, Windows_Selected
        EXIT
        

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; DeselectWindowIcons
;
; Deselect all currently selected file and window icons, within the window with
; specified handle.
;
; In: r0 = Window handle
;
; Out: All registers preserved.

DeselectAllIcons ENTRY

        BL      DeselectWindowIcons
        BL      DeselectFileIcons
        EXIT


d254 1
a254 1
; SelectFileIcons
d262 1
a262 1
SelectFileIcons     ROUT
d296 2
a297 3

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectWindowIcons
d299 6
a304 1
; Make all iconised window icons in specified window selected.
a305 1
; In: r0 = window handle (currently only backdrop_handle)
a306 57
; Out: All registers preserved

SelectWindowIcons ENTRY "r0-r5"

        MOV     r4, r0
        LDR     r5, Windows_Selected     ; Number of icons selected on the backdrop
        ADR     r1, dataarea             ; temporary store for Wimp_SetIconState
        STR     r0, [r1]
        MOV     r2, #is_selected
        STR     r2, [r1, #8]
        STR     r2, [r1, #12]
        LDR     r3, iconized_ptr
02
        CMP     r3, #0
        BEQ     %FT06
        LDR     r2, [r3, #w_icon_id]     ; load window handle of icon
        CMP     r2, r4                   ; is it the same as the window specified?
        BNE     %FT04
        LDR     r2, [r3, #w_icon_handle] ; load the icon handle
        STR     r2, [r1, #4]             ; store in the second word of the dataarea
        SWI     XWimp_SetIconState
        ADD     r5, r5, #1               ; Increment the number of selected icons count
04
        LDR     r3, [r3, #w_next_ptr]    ; find the next icon block
        B       %BT02
06
        STR     r5, Windows_Selected
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; SelectAllIcons
;
; Make all icons in specified window selected.
;
; In: r0 = window handle
;
; Out: All registers preserved

SelectAllIcons ENTRY

        BL      SelectWindowIcons
        BL      SelectFileIcons
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; FindIcon
;
; Tries to find an icon in the file linked list
;
; In: r1 = Window handle
;     r2 = Icon handle
; 
; Out: r2 -> icon block , Z set if found
;      Z clear if not found.                   

d308 1
a308 2

        ENTRY   "r0-r4"
d313 1
a313 1
        EXIT    LT                      ; Not found Z clear
d323 1
a323 1
        EXIT                            ; Z set
d325 2
a326 3

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; FindIconBoth
d328 6
a333 1
; Does a FindIcon on both file and window linked lists
a334 42
; In: r1 = Window handle
;     r2 = Icon handle
; 
; Out: r2 -> icon block , Z set if found
;      Z clear if not found.                   

FindIconBoth    ROUT

        ENTRY   "r0-r4"

        MOV     r4, #2
        LDR     r0,Icon_list
01
        CMP     r0,#1
        BLT     %FT02

        LDR     r3,[r0,#ic_window]
        TEQ     r3,r1
        LDREQ   r3,[r0,#ic_icon]
        TEQEQ   r3,r2
        LDRNE   r0,[r0,#ic_next]
        BNE     %BT01

        STR     r0,[sp,#2*4]
        EXIT                            ; Z set
02
        SUB     r4, r4, #1
        CMP     r4, #1
        EXIT    LT                      ; Not found Z clear
        LDR     r0, iconized_ptr
        B       %BT01
        

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Find BBOX
;
; In: r0 = Window handle
;     r2 -> icon block of icon clicked on
;     r3 = use DragASprite if non-0
;
; Out: r6-r9 BBOX of selected items in window. (x0,y0,x1,y1)

d337 1
a337 1
        ENTRY   "r0-r5, r11"
d339 1
a342 1
        ; Set up BBOX with silly values
a347 1
        MOV     r11, #0                 ; =0 means we're on files, =1 means windows
d351 2
a352 2
        CMP     r4,#0                   ; Is this the end of the list?
        BEQ     %FT20
a353 1
        ; Check icon is in window we're interested in.
d356 1
d359 1
a359 2

        ; Get current state of icon           
d364 1
a364 1
        EXIT    VS
d366 1
a366 2
        ; Check if selected
        LDR     r14,[r1,#24]
d368 1
a368 1
        BEQ     %FT10
d370 1
a370 2
        ; Count icons for DragASprite
        ADD     r5,r5,#1 
a371 1
        ; Adjust bounding box to include this icon
d375 1
d379 1
d383 1
d391 4
a394 5
20 ; Deal with end of list
        ADD     r11, r11, #1
        CMP     r11, #1
        LDREQ   r4, iconized_ptr
        BEQ     %BT01
d397 1
a397 2
        EXIT    VS

d399 1
d404 1
a404 2
        EXIT    EQ

d410 1
a410 1
        EXIT    VS
d414 1
a414 1
        EXIT    LT
d417 1
d451 1
d453 2
a454 2
 
        EXIT
a459 1

d468 1
a468 1

d476 1
a531 100

deb_winsel ENTRY "r0-r5"

        SUB     sp, sp, #4
        
        WRLN    " "
        STRIM   "   Pinboard_Icons:"
        LDR     r0, Pinboard_Icons
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine
        STRIM   "     Window_Icons:"
        LDR     r0, Window_Icons
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine
        STRIM   "Pinboard_Selected:"
        LDR     r0, Pinboard_Selected
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine
        STRIM   "  Window_Selected:"
        LDR     r0, Windows_Selected
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine
        
        ADD     sp, sp, #4
        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; FindNearestGridXY
;
; Given an x, y co-ord, return the nearest x,y of a grid point.
; Grid's origin is the corner which is currently selected for tidying
; icons to.
;
; In: r5, r6 - x and y
;
; Out: r5, r6 - new x and y

FindNearestGridXY ENTRY "r0-r4, r7-r11"

   ; Work out the x co-ord of the nearest grid position
        LDR     r4, Pinboard_options
        TST     r4, #PinboardOption_TidyToCornerLR
        BNE     %FT03
        ; If tidy to left
        MOV     r10, #grid_x_spacing
        DivRem  r1, r5, r10, r2
        CMP     r5, r10, LSR #2
        ADDGT   r1, r1, #1
        MUL     r5, r1, r10                  ; x = (mouse_x DIV x_spacing) * x_spacing
        B       %FT04
03      ; If tidy to right
        MOV     r10, #grid_x_spacing
        LDR     r11, Screen_x1
        SUB     r2, r11, r5
        DivRem  r1, r2, r10, r0
        CMP     r2, r10, LSR #1
        ADDGT   r1, r1, #1
        MUL     r2, r1, r10
        SUB     r5, r11, r2
        
04 ; Work out the y co-ord of the nearest grid position
        TST     r4, #PinboardOption_TidyToCornerTB
        BNE     %FT06
        ; If tidy to top
        MOV     r10, #grid_y_spacing
        LDR     r11, Screen_y1
        SUB     r2, r11, r6
        DivRem  r1, r2, r10, r0
        CMP     r2, r10, LSR #1
        ADDGT   r1, r1, #1
        MUL     r2, r1, r10
        SUB     r6, r11, r2
        EXIT
06      ; If tidy to bottom
        LDR     r0, icon_bar_height
        SUB     r6, r6, r0                   ; grid starts above icon bar, so subtract it's height
        CMP     r6, #0
        MOVLT   r6, #0 
        MOV     r10, #grid_y_spacing
        DivRem  r1, r6, r10, r2
        CMP     r6, r10, LSR #1
        ADDGT   r1, r1, #1
        MUL     r9, r1, r10                  ; y = (mouse_y DIV y_spacing) * y_spacing
        ADD     r6, r9, r0
        EXIT

        
@


4.1.4.2
log
@Fixed a couple of bugs.
Improved tidying code.
Filenames are now truncated.
@
text
@a93 13

        [ truncate_filenames
        ; find out how much extra space is required to store the icon text
        ; ie. the truncated leafname.
        Push    "r2-r3"
        LDR     r2, [sp, #(2+2)*4]      ; pointer to path
        MOV     r3, #0
        BL      do_truncation           ; return truncated length in r3
        ADD     r8, r3, #4              ; add extra for ellipsis and terminator
        Pull    "r2-r3"
        ADD     r3, r3, r8
        ]

d97 1
a97 1
        
d117 1
a117 1
        
a133 12

        [ truncate_filenames
        Push    "r0-r3"
        LDR     r1, [sp, #(4+3)*4]      ; length of path
        ADD     r3, r2, #ic_path
        ADD     r3, r3, r1              ; offset to icon text
        STR     r3, [r2, #ic_icontext]  ; store this offset
        ADD     r2, r2, #ic_path        ; address of path
        BL      do_truncation
        Pull    "r0-r3"
        ]

a775 22

 [ truncate_filenames
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; In: r2 -> path string
;     r3 -> destination, or =0 to return number of displayable characters.
;
; Out: r3 = number of characters displayed, if r3 = 0 on entry, else preserved.

do_truncation ENTRY "r0-r2, r4-r9"

        ; find leafname and put into r6
        MOV     r6, r2                       ; first guess for leafname is start of string
        MOV     r1, #0                       ; r1 is byte counter
04      LDRB    r0, [r2, r1]                 ; load next byte of string
        CMP     r0, #"."
        ADDEQ   r6, r2, r1                   ; if it's a dot, then it's our best guess so far
        ADDEQ   r6, r6, #1
        CMP     r0, #32                      ; if it's <32, then it's the string end
        BLT     %FT08
        ADD     r1, r1, #1                   ; next character
        CMP     r1, #256                     ; gone too far?
        BLT     %BT04
d777 1
a777 6
        ; truncate it
08      MOV     r7, r3
        BL      truncate_filename
        MOV     r3, r7
        EXIT

a778 126
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; truncate_filename
;
; Take a filename in and output the truncated version (including ellipsis).
;
; In:   r6 -> filename
;       r7 -> output buffer (or 0 to return size)
;
; Out: r7 = truncation length (no.chars) if r7 = 0 on entry, else preserved.
;      All other regs preserved.

truncate_filename ENTRY "r0-r6, r10-r11"

        ; What's the maximum width we allow?
        MOV     r1, #grid_x_spacing
        SUB     r1, r1, #4
        MOV     r2, r1
        SWI     XFont_Converttopoints
        MOV     r8, r2

        ; Set font to desktop font
        MOV     r0, #8
        SWI     XWimp_ReadSysInfo
        CMP     r0, #0            ; If system font, skip to different routine
        BEQ     %FT30
        SWI     XFont_SetFont

        ; Where would we need to split the string to fit the maximum width?
        MOV     r1, r6
        MOV     r2, r8
        MOV     r3, r8
        MOV     r4, #-1
        MOV     r5, #256
        SWI     XFont_StringWidth
        MOV     r10, r4        

        ; Now find the length of the filename string 
        MOV     r2, r6
        BL      strlen
        SUB     r11, r3, #1
        
        ; If the string is split before end of length, then find the new split size, taking
        ; into account the ellipsis character which we will add.
        CMP     r11, r10
        BLE     %FT20
        MOV     r1, r6
        LDR     r3, ellipsis_width
        SUB     r2, r8, r3
        MOV     r3, r8
        MOV     r4, #-1
        MOV     r5, #256
        SWI     XFont_StringWidth
        MOV     r10, r4

        ; Copy string (upto split character) to icon buffer
20      B       %FT40
          
        ; Deal with system font
        ; Covert millipoints back to OS units
        ; Shift right 5 to divide by 32 and find number of characters
        ; If less than string width, subtract 1 and add ellipsis.        
30      MOV     r1, r8
        MOV     r2, #0
        SWI     XFont_ConverttoOS    ; this returns max width in OS units
        MOV     r0, r1, LSR #4       ; divide max width by 16 to get number of chars
                
        MOV     r2, r6
        BL      strlen               
        SUB     r11, r3, #1          ; r11 = length of string
        MOV     r10, r11             ; r10 = how many characters we'll display (try for whole length)
        CMP     r10, r0              ; see if whole length will fit
        SUBGT   r10, r0, #1          ; if not, put max characters-1 (we'll ad an ellipsis)
        
        ; Copy string (upto split character) to icon buffer        
40      CMP     r7, #0
        MOVEQ   r7, r10
        EXIT    EQ

        MOV     r0, r7
        MOV     r1, r6
        MOV     r2, r10

44      LDRB    r14, [r1], #1
        STRB    r14, [r0], #1
        SUB     r2, r2, #1
        CMP     r2, #0
        BGT     %BT44
        
        ; If necessary, add ellipsis character
        CMP     r11, r10
        MOVGT   r14, #140
        STRGTB  r14, [r0], #1
        MOV     r14, #0
        STRB    r14, [r0], #1
        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; read_font_widths
;
; Read some widths needed by the truncation code

read_font_widths ENTRY "r0-r6"

        ; Set font to desktop font
        MOV     r0, #8
        SWI     XWimp_ReadSysInfo
        CMP     r0, #0
        SWINE   XFont_SetFont

        ; What's the width of an ellipsis in the current font?
        ADR     r1, ellipsis_str
        MOV     r2, #71680
        ADD     r2, r2, #320
        MOV     r3, r2
        MOV     r4, #-1
        MOV     r5, #1
        SWI     XFont_StringWidth
        STR     r2, ellipsis_width

        EXIT

ellipsis_str DCB "Œ",0
 ]

        LNK     s.Buffered
@


4.1.4.3
log
@Bug fix: sometimes thought there was a selection when no icons were selected.
@
text
@a324 3
        MOV     r0, #0
        STR     r0, Pinboard_Selected
        STR     r0, Windows_Selected
a702 2
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 [ debug_commands
d739 1
a739 2
 ]
 
@


4.1.4.4
log
@Bug fix:Select all windows and select all files now work correctly.
@
text
@a322 1
        Push    "r0"
a323 1
        Pull    "r0"
@


4.1.4.5
log
@When the only window icons are on the iconbar, grey out the 'Select all'
menu item.
File 'Status' added giving Pinboard status after RPC2 cancellation.
@
text
@a721 1

a728 1

a735 1

a737 8
        MOV     r1, sp
        MOV     r2, #4
        SWI     OS_ConvertInteger4
        SWI     OS_Write0
        SWI     OS_NewLine

        STRIM   "    Iconbar_Icons:"
        LDR     r0, Iconbar_Icons
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

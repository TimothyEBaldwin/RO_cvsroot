head	4.5;
access;
symbols
	Pinboard-1_04:4.5
	Pinboard-1_03:4.5
	Pinboard-1_02:4.5
	Pinboard-1_01:4.5
	Pinboard-1_00:4.5
	Pinboard-0_99:4.5
	Pinboard-0_98:4.5
	Pinboard-0_97:4.5
	Pinboard-0_96:4.5
	Pinboard-0_95:4.5
	Pinboard-0_94:4.4
	Pinboard-0_93:4.4
	Pinboard-0_92:4.4
	Pinboard-0_91:4.4
	Pinboard-0_90:4.4
	Pinboard-0_89:4.4
	Pinboard-0_88:4.4
	Pinboard-0_87:4.4
	Pinboard-0_86:4.3
	Pinboard-0_85:4.3
	Pinboard-0_84:4.3
	Pinboard-0_83:4.3
	Pinboard-0_82:4.3
	RO_5_07:4.3
	Pinboard-0_81:4.3
	Pinboard-0_80:4.3
	Pinboard-0_79:4.3
	Pinboard-0_78:4.3
	Pinboard-0_77:4.2
	Pinboard-0_76:4.2
	Ursula_merge:1.1.2.2
	Pinboard-0_75:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.2.2
	Ursula_RiscPC:1.1.2.2.0.2
	rleggett_Pinboard-0_75d:1.1.2.2
	rthornb_UrsulaBuild-19Aug1998:1.1.2.2
	UrsulaBuild_FinalSoftload:1.1.2.2
	rthornb_UrsulaBuild-12Aug1998:1.1.2.2
	aglover_UrsulaBuild-05Aug1998:1.1.2.2
	rthornb_UrsulaBuild-29Jul1998:1.1.2.2
	rthornb_UrsulaBuild-22Jul1998:1.1.2.2
	rleggett_Pinboard-0_75c:1.1.2.2
	rleggett_Pinboard-0_75b:1.1.2.2
	rleggett_Pinboard-0_75:1.1.2.2
	rthornb_UrsulaBuild-15Jul1998:1.1.2.2
	rthornb_UrsulaBuild-07Jul1998:1.1.2.2
	rthornb_UrsulaBuild-17Jun1998:1.1.2.2
	rthornb_UrsulaBuild-03Jun1998:1.1.2.2
	rthornb_UrsulaBuild-27May1998:1.1.2.2
	rthornb_UrsulaBuild-21May1998:1.1.2.2
	rleggett_Pinboard-0_74:1.1.2.2
	rthornb_UrsulaBuild_01May1998:1.1.2.2
	Ursula:1.1.0.2;
locks; strict;
comment	@# @;


4.5
date	2012.08.23.19.59.15;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	rztFpV1VBvCVZHhw;

4.4
date	2007.11.05.17.25.53;	author srevill;	state Exp;
branches;
next	4.3;

4.3
date	2002.11.11.12.34.51;	author rsprowson;	state Exp;
branches;
next	4.2;

4.2
date	2001.03.16.17.07.05;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	99.08.17.19.05.25;	author sbrodie;	state Exp;
branches;
next	1.1;

1.1
date	98.04.15.11.24.58;	author rleggett;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	98.04.15.11.25.02;	author rleggett;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	98.04.23.11.52.22;	author rleggett;	state Exp;
branches;
next	;


desc
@@


4.5
log
@Fix for patchy tiled backdrops on changing to non EX1/EY1 mode
Pinboard keeps a note of the mode (from OS_Byte 135) that the backdrop sprite tile was last cached in, to avoid having to recache it all the time. However, the comparison fails when the mode specifier block (ie. when OS_Byte 135 is not reporting a numeric screen mode) is static since although the mode might have changed Pinboard would not think it had and hence not recache the sprite.
The result is a patchy desktop, for example changing from EX1/EY1 to EX0/EY0 would leave a quadrant arrangement of 1 redrawn patch and 3 not redrawn.
Backdrop.s:
Line 151 onwards, when a mode specifier is used, build a magic mode word combining EX EY and BPP (the 3 parameters the cache sprite function cares about), as a stronger check.
Tail.s:
Line 130 onwards, calculate the iconbar height properly (previously used 134 pixels for EY0 modes, 1 too high, leading to a thin strip of background colour above the iconbar.
Other changes
 - Use sprite area offset names from Hdr:Sprites rather than magic numbers
 - Use OS_Byte reasons from Hdr:OsBytes
 - Use "file.s" style names in LNK commands
 - Move BadOptions/NotASprite error blocks to avoid range error when assembling debug versions
 - true and false for objasm {TRUE} and {FALSE}

Version 0.95. Tagged as 'Pinboard-0_95'
@
text
@; Copyright 1998 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; s.Tidy
; Tidying and placing of icons

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_icons
;
; Tidies either the file icons or the window icons. Which is done depends
; on the value PinboardFlag_UseWindowList (set tidy window icons, clear
; tidy file icons).
;
; In:  Nothing.
;
; Out: All regs preserved.

tidy_icons Entry "r0-r11"

        MOV     r9, sp                              ; r9 is now data pointer

        LDR     r8, Pinboard_options
        TST     r8, #PinboardFlag_PinboardFull
        BICNE   r8, r8, #PinboardFlag_PinboardFull  ; Assume pinboard isn't yet full
        ORR     r8, r8, #PinboardFlag_SkipSelected
        STR     r8, Pinboard_options

        ; Decide starting position
        BL      decide_list_origin                  ;
        BL      tidy_find_next_free                 ;

        ; Where's the icon data?
        TST     r8, #PinboardFlag_UseWindowList     ;
        LDRNE   r11, iconized_ptr                   ; First window icon in list
        LDREQ   r11, Icon_list                      ; First file icon in list

        ; Now, go through all the icons and move them, if selected.
50      CMP     r11, #0                             ; have we reached the end of list?
        EXIT    EQ

        LDR     r0, backdrop_handle
        LDR     r1, [r11, #ic_window]
        CMP     r0, r1                              ; is the next icon on the backdrop?
        BNE     %FT70

        BL      tidy_move_icon_if_selected          ; move icon, if selected.
        BLEQ    tidy_find_next_icon_space           ; if we've moved an icon, find where to put next

70      LDR     r11, [r11, #ic_next]                ; find next icon data block
        B       %BT50

        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_find_next_icon_space
;
; Where will the next icon we tidy go?
;
; In: r3, r4 = x and y co-ordinates of current grid position.
;
; Out: r3, r4 = x and y co-ordinates of next free grid position.

tidy_find_next_icon_space Entry "r0-r2"

        ; Find the next grid position
        TST     r8, #PinboardFlag_UseWindowList
        MOVEQ   r2, r8, LSR #3                  ; shift the flags if files, so they look like
        MOVNE   r2, r8                          ; window flags.
        BL      find_next_x_and_y
        BNE     %FT10                           ; NE if the screen was filled up with this call

        ; If the screen is already full, then we don't bother to check for clashes anymore
        TST     r8, #PinboardFlag_PinboardFull
        EXIT    NE

        ; Screen not full - try and find the next free space
        BL      tidy_find_next_free
        EXIT    EQ

        ; The screen is now full - reset to origin
10      ORR     r8, r8, #PinboardFlag_PinboardFull
        STR     r8, Pinboard_options
        BL      decide_list_origin
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; decide_list_origin
;
; Decide where the origin of a list is. By that we mean the x and y
; co-ordinates of the grid position of the corner where the list starts.
;
; In: Nothing.
;
; Out: r3, r4 = x and y co-ordinates of start grid position.

decide_list_origin Entry "r0-r2, r5-r6"

        LDR     r5, Pinboard_options                 ; Pinboard options
        ADR     r0, bounding_box                     ; Screen bouding box

        TST     r5, #PinboardFlag_UseWindowList      ; check which we're working on
        MOVNE   r14, #PinboardOption_WinToCornerLR   ; if windows, then we'll test WinToCornerLR bit
        MOVEQ   r14, #PinboardOption_TidyToCornerLR  ; if files, then we'll test TidyToCornerLR bit
        TST     r5, r14                              ; test the bit, 0 = Left (EQ), 1 = Right (NE)
        LDR     r1, [r0, #8]                         ; Decide on initial left/right positioning
        MOVEQ   r3, #0                               ;
        MOVNE   r14, #grid_x_spacing                 ;
        SUBNE   r3, r1, r14                          ;

        TST     r5, #PinboardFlag_UseWindowList      ; check which we're working on
        MOVNE   r14, #PinboardOption_WinToCornerTB   ; if windows, then we'll test WinToCornerTB bit
        MOVEQ   r14, #PinboardOption_TidyToCornerTB  ; if files, then we'll test TidyToCornerTB bit
        TST     r5, r14                              ; test the bit, 0 = Top (EQ), 1 = Bottom (NE)
        LDR     r1, [r0, #12]                        ; Decide on initial up/down positioning
        MOVEQ   r14, #grid_y_spacing                 ;
        SUBEQ   r4, r1, r14                          ;
        LDRNE   r4, icon_bar_height                  ;

        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_move_icon_if_selected
;
; Check if icon whose details are in the structure in r11 is selected and
; if so, move it to the grid co-ordinates pointed to by r2, r3.
;
; In: r3, r4 = x, y grid co-ordinate to move to
;     r11 -> icon data structure
;
; Out: NE = didn't move icon
;      EQ = did move icon.

tidy_move_icon_if_selected Entry "r0-r10"

        SUB     sp, sp, #48                     ; Use stack for temporary storage.
        MOV     r1, sp                          ; -> temporary workspace

        MOV     r2, r3                          ;
        MOV     r3, r4                          ;

        LDR     r9, backdrop_handle             ;
        LDR     r8, Pinboard_options            ;

        ; If pinboard full, we offset the icons a little
        TST     r8, #PinboardFlag_PinboardFull
        MOVNE   r10, #(grid_x_spacing/2)
        MOVEQ   r10, #0

        ; Get the current wimp state of the icon
        STR     r9, [r1]                        ; Backdrop handle
        LDR     r0, [r11, #ic_icon]             ; Icon handle
        STR     r0, [r1, #4]                    ;
        SWI     XWimp_GetIconState              ;
        BVS     %FT10                           ;

        ; We'll only move it if it's selected
        LDR     r0, [r1, #24]                   ; icon flags
        TST     r0, #is_selected                ;
        BEQ     %FT10                           ;

        ; Resize it...
        LDR     r4, [r1, #8]                    ; How wide is the icon?
        LDR     r5, [r1, #16]                   ;
        SUB     r6, r5, r4                      ;
        LDR     r4, [r1, #12]                   ; How tall is the icon?
        LDR     r5, [r1, #20]                   ;
        SUB     r7, r5, r4                      ;

        MOV     r0, #grid_x_spacing             ; Adjust for centre alignment
        SUBS    r1, r0, r6                      ; x1
        ADDPL   r2, r2, r1, LSR #1              ; x2
        SUBMI   r1, r6, r0                      ;
        SUBMI   r2, r2, r1, LSR #1              ;

        ADD     r4, r2, r6                      ; x2

        MOV     r0, #grid_y_spacing             ; Adjust for centre alignment
        SUBS    r1, r0, r7                      ; y1
        ADDPL   r3, r3, r1, LSR #1              ; y2
        SUBMI   r1, r7, r0                      ;
        SUBMI   r3, r3, r1, LSR #1              ;

        ADD     r5, r3, r7                      ; y2

        ADD     r2, r2, r10                     ; icon offset if pinboard full
        ADD     r4, r4, r10                     ; icon offset if pinboard full

        TST     r8, #PinboardFlag_UseWindowList ; are we tidying window icons?
        STREQ   r2, [r11, #ic_x]                ; if not, store x and store y
        STREQ   r3, [r11, #ic_y]                ;

        MOV     r0, r9                          ; r0 = backdrop handle
        LDR     r1, [r11, #ic_icon]             ; r1 = icon handle
        SWI     XWimp_ResizeIcon                ; Move icon to new x and y
        BVS     %FT10

        ; Change its state so it is no longer selected
        ; (this will also redraw icon at new position)
        MOV     r1, sp                          ;
        MOV     r0, #is_selected                ;
        STR     r0, [r1, #8]                    ;
        MOV     r0, #0                          ;
        STR     r0, [r1, #12]                   ;
        SWI     XWimp_SetIconState              ;
        BVS     %FT10                           ;

        TST     r8, #PinboardFlag_UseWindowList ;
        LDREQ   r0, Pinboard_Selected           ;
        LDRNE   r0, Windows_Selected            ;
        SUB     r0, r0, #1                      ;
        STREQ   r0, Pinboard_Selected           ;
        STRNE   r0, Windows_Selected            ;

        ADD     sp, sp, #48                     ; exit EQ
        CMP     r8, r8
        EXIT

10      ADD     sp, sp, #48
        CMP     pc, r8                          ; exit NE
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_find_next_free
;
; Given an initial grid position, check if it's space is occupied. If it
; is, then move to the next position and try again.
;
; In: r3, r4 = x and y co-ordinates
;
; Out: r3, r4  = next free slot
;      r0 - r2 = corrupted.

tidy_find_next_free Entry

10
        LDR     r2, Pinboard_options            ;
        BL      is_something_there
        BNE     %FT20

        TST     r2, #PinboardFlag_UseWindowList ;
        MOVEQ   r2, r2, LSR #3                  ; shift the flags if files, so they look like window flags.

        BL      find_next_x_and_y
        EXIT    NE
        B       %BT10

20
        CMP     r0, r0
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; is_something_there
;
; Test if a grid position is occupied. We'll test against both lists and
; return NE if there's no icons overlapping the proposed grid position.
; Checking of selected icons is controlled by PinboardFlag_SkipSelected,
; if set selected icons will be skipped (tidying), if clear they'll be
; checked as well (iconizing).
;
; In: r3, r4 = x and y co-ordinate of grid position
;
; Out: EQ if something there, NE if not.
;      All regs. preserved.

is_something_there Entry "r2, r5-r11"

        SUB     sp, sp, #40                     ; grab some stack space to put data block
        MOV     r9, sp                          ;

        MOV     r8,#1                           ; 1 => use window icon list, 0 => use file icon list

10      ; next list
        CMP     r8,#1                           ; are we checking the window list
        LDREQ   r11, iconized_ptr               ; if so, -> first icon in window list
        LDRNE   r11, Icon_list                  ; if not, -> first icon in file icon list

20      ; next icon
        CMP     r11, #0                         ; is this the end of the linked list?
        BEQ     %FT90                           ; if so, see if we've done both lists

        BL      get_next_icon_bbox              ; get the icon's bounding box
        CMP     r10, #0                         ; icon not on backdrop if r10 is zero
        BEQ     %FT80                           ;

        TST     r2,#PinboardFlag_SkipSelected   ; should we skip selected icons?
        LDRNE   r14,[r10,#16]                   ; if not, get icon flags
        TSTNE   r14,#selected                   ; .. is the icon selected?
        BNE     %FT80                           ; .. if so, don't check this icon

        ; make r3, r4, r5, r6 the proposed bounding box.
        MOV     r14, #grid_x_spacing            ;
        ADD     r5, r3, r14                     ;
        MOV     r14, #grid_y_spacing            ;
        ADD     r6, r4, r14                     ;

        ; Check the proposed icon's left and right bounds against the current stored icon
        LDR     r7, [r10]
        CMP     r5, r7                          ; Check proposed x2 <= icon x1
        BLE     %FT80                           ; If it is, then this icon presents no problems - try next
        LDR     r7, [r10, #8]
        CMP     r3, r7                          ; Check proposed x1 >= icon x2
        BGE     %FT80                           ; If it is, then this icon presents no problems - try next

        ; Check the proposed icon's top and bottom bounds against the current stored icon
        LDR     r7, [r10, #4]
        CMP     r6, r7                          ; Check proposed y2 <= icon y1
        BLE     %FT80                           ; If it is, then this icon present no problems.
        LDR     r7, [r10, #12]
        CMP     r4, r7                          ; Check proposed y1 >= store y2
        BGE     %FT80                           ; If it is, then this icon presents no problems

70      ; Exit EQ
        ADD     sp, sp, #40                     ;
        CMP     sp, sp                          ;
        EXIT

80      ; this icon doesn't occupy the space - try next
        LDR     r11, [r11, #ic_next]            ;
        B       %BT20                           ;

90      SUBS    r8,r8,#1                        ;
        BPL     %BT10                           ;

        ; something ISN'T there - Exit NE
        ADD     sp, sp, #40                     ;
        CMP     sp, #0                          ;
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; next_grid_row_or_column
;
; Depending on PinboardOption_WinToCornerXX, return the X and Y
; co-ordinate of the start of the next row or column.
;
; In: r2     = options
;     r3, r4 = x and y co-ordinate of grid position

;
; Out: r3, r4 = x and y co-ordinate of next row or column

next_grid_row_or_column Entry "r5-r7"

        ADR     r5, bounding_box
        MOV     r6,#grid_x_spacing
        MOV     r7,#grid_y_spacing

        TST     r2, #PinboardOption_WinToCornerHV ; Are we dealing with rows or columns?
        BNE     %FT20

10      ; rows - reset x to left/right and move up/down a row
        LDR     r0, [r5, #8] ; x2
        TST     r2, #PinboardOption_WinToCornerLR
        SUBNE   r3, r0, r6
        MOVEQ   r3, #0

        TST     r2, #PinboardOption_WinToCornerTB
        ADDNE   r4, r4, r7
        SUBEQ   r4, r4, r7

        ; Check we haven't moved up/down too far
        LDR     r0, [r5, #12] ; y2
        SUB     r0, r0, r7
        CMP     r4, r0
        SUBGT   r4, r4, r7

        LDR     r0, icon_bar_height
        CMP     r4, r0
        ADDLT   r4, r4, r7
        EXIT

20      ; columns - reset y to top/bottom and move left/right a column
        LDR     r0, [r5, #12] ; y2
        TST     r2, #PinboardOption_WinToCornerTB
        LDRNE   r4, icon_bar_height
        SUBEQ   r4, r0, r7

        TST     r2, #PinboardOption_WinToCornerLR
        SUBNE   r3, r3, r6
        ADDEQ   r3, r3, r6

        ; Check we haven't moved left/right too far
        LDR     r0, [r5, #8] ; x2
        SUB     r0, r0, r6
        CMP     r3, r0
        SUBGT   r3, r3, r6

        CMP     r3, #0
        ADDLT   r3, r3, r6
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_iconise_position
;
; Decide where to put the icon for a window that's just been iconized.
; The process involves choosing a location, then searching first the window list, then the
; file list, to see if the space is occupied. If it is, then we move to the next space
; (dependent on PinboardOption_WinToCorner...) and check through each list again.
;
; In: Nothing.
;
; Out: The memory locations iconise_x and iconise_y are set to the position for the icon.
;      All regs preserved.

get_iconise_position

        Entry   "r0-r12"

        LDR     r2, Pinboard_options                ; Pinboard options
        ORR     r2, r2, #PinboardFlag_UseWindowList ; we need the origin of the window list
        BIC     r2, r2, #PinboardFlag_SkipSelected  ; ensure selected icons are checked too
        STR     r2, Pinboard_options                ; write back Pinboard options

        BL      decide_list_origin                  ; get origin of window list

        ; Now loop through linked list of icons and see if they present a problem
        ; (occupy the space that our 'proposed' icon is going to use). If so, try
        ; another space. If not, then we can use the coords.

10      BL      is_something_there                  ; is proposed space occupied?
        STRNE   r3, iconize_x                       ; if not, set x,y for iconised icon
        STRNE   r4, iconize_y                       ; .. and exit
        BLEQ    find_next_x_and_y                   ; if so, find next space (NB alters Z!)
        BEQ     %BT10                               ; .. and see if that's free

        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_next_icon_box
;
; Given a pointer to a data block, find the icon's bounding box.
; PinboardFlag_UseWindowList sets if the block is in the window or file list
;
; In: r2 = Pinboard_options
;     r11 -> icon data block
;     r9  -> 40 byte block of temporary memory (typically stack)
;
; Out: r10 -> bounding box (which will be 16 bytes within the 40 bytes)
;             if r10 is zero, icon is not on backdrop.
;      r0, r1 corrupted

get_next_icon_bbox Entry

        MOV     r10, #0
        TST     r2, #PinboardFlag_UseWindowList ; Is the data -> by r9 in the window or file list?
        BNE     %FT20

10      ; find the icon handle from the file icon list
        LDR     r0, [r11, #ic_icon]
        B       %FT30

20      ; find the icon handle from the window icon list
        LDR     r0, backdrop_handle
        LDR     r1, [r11, #w_icon_id]
        CMP     r0, r1
        EXIT    NE                              ; icon not on backdrop - exit
        LDR     r0, [r11, #w_icon_handle]

30      ; found an icon handle - get it's bounding box
        STR     r0, [r9, #4]
        LDR     r0, backdrop_handle
        STR     r0, [r9]
        MOV     r1, r9
        SWI     Wimp_GetIconState
        ADD     r10, r1, #8

        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; find_next_x_and_y
;
; What are x and y co-ordinates of the next spot on the grid?
; This depends on the start corner and the direction of stacking.
;
; In: r2 = pinboard options
;     r3 = x co-ord.
;     r4 = y co-ord.
;
; Out: r3, r4 = x and y co-ordinates
;      NE     = Screen full
;      EQ     = Found new position (in r3, r4)
;      r0, r1 = corrupted.

find_next_x_and_y Entry

        ; Which way are we stacking?
        TST     r2, #PinboardOption_WinToCornerHV ; 0 = horizontally (EQ), 1 = vertically (NE)
        BEQ     find_next_horizontal
        BNE     find_next_vertical


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

find_next_vertical

        ADR     r0, bounding_box
        LDR     r1, [r0, #12]
        MOV     r14, #grid_y_spacing
        SUB     r1, r1, r14
        LDR     r0, icon_bar_height

        TST     r2, #PinboardOption_WinToCornerTB ; 0 = top (EQ) 1 = bottom (NE)
        BNE     %FT12

        ; move down
        SUBS    r4, r4, r14
        MOVMI   r4, r1
        BMI     %FT16
        CMP     r4, r0
        MOVLT   r4, r1
        BLT     %FT16
        B       find_next_found

12      ; move up
        ADD     r4, r4, r14
        CMP     r4, r1
        MOVGE   r4, r0
        BGE     %FT16
        B       find_next_found

16      ; we've hit the edge - move left/right
        ADR     r0, bounding_box
        TST     r2, #PinboardOption_WinToCornerLR
        BEQ     %FT18

        ; move left
        MOV     r14, #grid_x_spacing
        SUBS    r3, r3, r14
        BMI     find_next_screen_full
        B       find_next_found

18      ; move right
        MOV     r14, #grid_x_spacing
        ADD     r3, r3, r14
        LDR     r1, [r0, #8]
        SUB     r1, r1, r14
        CMP     r3, r1
        BGT     find_next_screen_full
        B       find_next_found

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

find_next_horizontal

        ADR     r0, bounding_box
        MOV     r14, #grid_x_spacing
        LDR     r1, [r0, #8]
        SUB     r1, r1, r14

        ; which direction do we move?
        TST     r2, #PinboardOption_WinToCornerLR ; 0 = left (EQ), 1 = right (NE)
        BEQ     %FT22

        ; move left
        SUBS    r3, r3, r14
        MOVMI   r3, r1
        BMI     %FT26
        B       find_next_found

22      ; move right
        ADD     r3, r3, r14
        CMP     r3, r1
        MOVGE   r3, #0
        BGE     %FT26
        B       find_next_found

26      ; we've hit the edge - move up/down
        TST     r2, #PinboardOption_WinToCornerTB
        BNE     %FT28

        ; move down
        MOV     r14, #grid_y_spacing
        SUBS    r4, r4, r14
        BMI     find_next_screen_full
        LDR     r1, icon_bar_height
        CMP     r4, r1
        BLT     find_next_screen_full
        B       find_next_found

28      ; move up
        MOV     r14, #grid_y_spacing
        ADD     r4, r4, r14
        LDR     r1, [r0, #12]
        SUB     r1, r1, r14
        CMP     r4, r1
        BGT     find_next_screen_full
        B       find_next_found


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

find_next_found

        ; We've found the next slot - exit EQ
        MOV     r0, #24
        CMP     r0, #24
        EXIT


find_next_screen_full

        ; The screen was full - exit NE
        MOV     r0, #24
        CMP     r0, #23
        EXIT


        LNK     Tail.s
@


4.4
log
@  Prevent icons from overlapping when tidying a selection of icons.
Details:
  Tidying a selection of icons could result in icons being placed at locations
  already occupied by other icons. The reason for this is that tidying iconised
  window icons didn't check at all whether a position was occupied or not, and
  tidying file icons only checked against the list of iconised window icons.
  Essentially the code was designed for tidying all icons on the Pinboard, not
  selections.
Admin:
  Tested on Iyonix RO5.11
Changes by:
  Fred Graute

Version 0.87. Tagged as 'Pinboard-0_87'
@
text
@d627 1
a627 1
        LNK     s.Tail
@


4.3
log
@Commented out "proginfo" string,no longer used.
Prefixed the pin and addtinydir commands that get saved in the
pinboard file with "X " so your pinboard setup continues even if a file
is no longer available.ROL did this with a new XPin command,not taken.
Merged changes from ROL to allow the icon text to be an arbitary colour
though this can be switched out with "technicolour_text" for the
purists.
Help entry added to the pinboard selection submenu,this will be greyed
out except when
 it's an app
 and it has a !help file
 and it is the only object selected
like the filer does.
Updated messages file accordingly.
Menu clicking on the "save pinboard settings" OK button no longer saves
the file,and adjust clicking keeps the menu tree open
 -> fixes bug report from 1998,now removed from "Status" file
Saveas template resized to match !Edit.
Fixed problem of select dragging a file to an app leaving the icon
selected (due to two conditional MOV R0's being followed by an
unconditional one for some reason).
 -> fixes bug report from 1998,now removed from "Status" file
Tweaked a few CMP#0 BLT's to test specifically for the iconbar handle.
The bug report in "Status" about bits of filenames being left on the
pinboard can be bodged by popping an ADD r0,r0,#16 after the XWimp_TextOp
in s.buffered but I've not done this yet.

Version 0.78. Tagged as 'Pinboard-0_78'
@
text
@d22 2
a23 2
; on the value PinboardFlag_TidyWindows (set tidy window icons, clear
; tidy files).
d31 2
d36 1
a36 3
        TST     r8, #PinboardFlag_TidyWindows
        BICNE   r8, r8, #PinboardFlag_UseWindowList ; Set UseWindowList flag for later functions
        ORREQ   r8, r8, #PinboardFlag_UseWindowList
d40 2
a41 2
        BL      tidy_decide_origin
        MOV     r9, sp                              ; r9 is now data pointer
d44 1
a44 1
        TST     r8, #PinboardFlag_TidyWindows
d70 4
d75 1
a75 4
tidy_find_next_icon_space Entry "r0, r4"

        MOV     r4, r3
        MOV     r3, r2
d78 1
a78 1
        TST     r8, #PinboardFlag_TidyWindows
a85 2
        MOVNE   r2, r3
        MOVNE   r3, r4
a89 2
        MOVEQ   r2, r3
        MOVEQ   r3, r4
d95 1
a95 1
        BL      tidy_decide_origin
d100 1
a100 1
; tidy_decide_origin
d102 2
a103 2
; Decide where the origin of a tidy is. By that we mean the x and y
; co-ordinate of the grid position of the corner we're tidying from.
d107 1
a107 1
; Out: r2, r3 = x and y co-ordinates of start grid position.
d109 1
a109 1
tidy_decide_origin Entry "r0-r1, r4-r6"
d111 2
a112 2
        LDR     r5, Pinboard_options                ; Pinboard options
        ADR     r6, bounding_box                    ; Screen bouding box
d114 17
a130 27
        ; Decide on initial left/right positioning
        LDR     r1, [r6, #8]                        ; load screen max_x
        TST     r5, #PinboardFlag_TidyWindows       ; see if we're dealing with windows or files
        MOVNE   r0, #PinboardOption_WinToCornerLR   ; if windows, then we'll test WinToCornerLR bit
        MOVEQ   r0, #PinboardOption_TidyToCornerLR  ; if files, then we'll test TidyToCornerLR bit
        TST     r5, r0                              ; test the bit
        MOVEQ   r3, #0                              ; if not set, then use left of screen
        SUBNE   r3, r1, #grid_x_spacing             ; if set, then use right of screen

        ; Decide on initial up/down positiong
        LDR    r1, [r6, #12]                        ; load screen max_y
        TST    r5, #PinboardFlag_TidyWindows        ; see if we're dealing with windows or files
        MOVNE  r0, #PinboardOption_WinToCornerTB    ; if windows, then we'll test WinToCornerTB
        MOVEQ  r0, #PinboardOption_TidyToCornerTB   ; if files, then we'll test TidyToCornerTB
        TST    r5, r0                               ; test the bit
        SUBEQ  r4, r1, #grid_y_spacing              ; if not set, then use top of screen
        LDRNE  r4, icon_bar_height                  ; if set, then use bottom of screen

        ; If we're doing files, then check initial position for clash
        ; ie. windows are higher priority.
        TST     r5, #PinboardFlag_PinboardFull
        BNE     %FT10
        TST     r5, #PinboardFlag_TidyWindows
        BLEQ    tidy_find_next_free

10      MOV     r2, r3
        MOV     r3, r4
d141 1
a141 1
; In: r2, r3 = x, y grid co-ordinate to move to
d147 4
a150 1
tidy_move_icon_if_selected Entry "r0-r1, r4-r10"
d152 2
a153 2
        SUB     sp, sp, #48                           ; Use stack for temporary storage.
        MOV     r1, sp
d155 2
a156 2
        LDR     r9, backdrop_handle
        LDR     r8, Pinboard_options
d164 5
a168 5
        STR     r9, [r1]                              ; Backdrop handle
        LDR     r0, [r11, #ic_icon]                   ; Icon handle
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState
        BVS     %FT10
d171 3
a173 3
        LDR     r0, [r1, #24]                       ; icon flags
        TST     r0, #is_selected
        BEQ     %FT10
d176 33
a208 28
        LDR     r4, [r1, #8]                        ; How wide is the icon?
        LDR     r5, [r1, #16]
        SUB     r6, r5, r4
        LDR     r4, [r1, #12]                       ; How tall is the icon?
        LDR     r5, [r1, #20]
        SUB     r7, r5, r4

        Push    "r2"
        MOV     r0, #grid_x_spacing                 ; Adjust for centre alignment
        SUBS    r1, r0, r6                          ; x1
        ADDPL   r2, r2, r1, LSR #1                  ; x2
        SUBMI   r1, r6, r0
        SUBMI   r2, r2, r1, LSR #1

        ADD     r4, r2, r6                          ; x2
        ADD     r5, r3, r7                          ; y2

        ADD     r2, r2, r10                         ; icon offset if pinboard full
        ADD     r4, r4, r10                         ; icon offset if pinboard full

        TST     r8, #PinboardFlag_TidyWindows
        STREQ   r2, [r11, #ic_x]                    ; store x
        STREQ   r3, [r11, #ic_y]                    ; store y

        MOV     r0, r9
        LDR     r1, [r11, #ic_icon]
        SWI     XWimp_ResizeIcon                    ; Move icon to new x and y
        Pull    "r2"
d211 18
a228 1
        ADD     sp, sp, #48                         ; exit EQ
d233 1
a233 1
        CMP     pc, r8                              ; exit NE
a249 4
        LDR     r2, Pinboard_options
        TST     r2, #PinboardFlag_TidyWindows
        BNE     %FT20

d251 1
a251 1
        LDR     r2, Pinboard_options
d254 4
a257 1
        MOV     r2, r2, LSR #3
d270 5
a274 3
; Test if a grid position is occupied. As to which list of icons is
; checked depends on the value of PinboardFlag_TidyWindows. If set,
; then the file icon list is searched, else the iconised window list.
d283 9
a291 6
        LDR     r2, Pinboard_options
        TST     r2, #PinboardFlag_TidyWindows
        LDREQ   r11, iconized_ptr                 ; first window in list?
        LDRNE   r11, Icon_list                    ; or first icon in list?
        SUB     sp, sp, #40                       ; grab some stack space to put data block
        MOV     r9, sp
d294 2
a295 5
        CMP     r11, #0                           ; is this the end of the linked list?
        BEQ     %FT90
        BL      get_next_icon_bbox                ; get the icon's bounding box
        CMP     r10, #0                           ; icon not on backdrop if r10 is zero
        BEQ     %FT80
d297 14
a310 2
        ADD     r5, r3, #grid_x_spacing           ; make r3, r4, r5, r6 the proposed bounding box.
        ADD     r6, r4, #grid_y_spacing
d314 2
a315 2
        CMP     r5, r7                            ; Check proposed x2 <= icon x1
        BLE     %FT80                             ; If it is, then this icon presents no problems - try next
d317 2
a318 2
        CMP     r3, r7                            ; Check proposed x1 >= icon x2
        BGE     %FT80                             ; If it is, then this icon presents no problems - try next
d322 2
a323 2
        CMP     r6, r7                            ; Check proposed y2 <= icon y1
        BLE     %FT80                             ; If it is, then this icon present no problems.
d325 2
a326 2
        CMP     r4, r7                            ; Check proposed y1 >= store y2
        BGE     %FT80                             ; If it is, then this icon presents no problems
d329 2
a330 2
        ADD     sp, sp, #40
        CMP     sp, sp
d334 5
a338 2
        LDR     r11, [r11, #ic_next]
        B       %BT20
d340 3
a342 3
90      ; something ISN'T there - Exit NE
        ADD     sp, sp, #40
        CMP     sp, #0
d358 1
a358 1
next_grid_row_or_column Entry "r5"
d361 3
d370 1
a370 1
        SUBNE   r3, r0, #grid_x_spacing
d374 2
a375 2
        ADDNE   r4, r4, #grid_y_spacing
        SUBEQ   r4, r4, #grid_y_spacing
d379 1
a379 1
        SUB     r0, r0, #grid_y_spacing
d381 1
a381 1
        SUBGT   r4, r4, #grid_y_spacing
d385 1
a385 1
        ADDLT   r4, r4, #grid_y_spacing
d392 1
a392 1
        SUBEQ   r4, r0, #grid_y_spacing
d395 2
a396 2
        SUBNE   r3, r3, #grid_x_spacing
        ADDEQ   r3, r3, #grid_x_spacing
d400 1
a400 1
        SUB     r0, r0, #grid_x_spacing
d402 1
a402 1
        SUBGT   r3, r3, #grid_x_spacing
d405 1
a405 1
        ADDLT   r3, r3, #grid_x_spacing
d422 1
a422 1
get_iconise_position Entry
d424 1
a424 1
        Push    "r0-r12"
d427 15
a441 15
        ORR     r2, r2, #PinboardFlag_UseWindowList ; Start with the window list
        STR     r2, Pinboard_options
        ADR     r0, bounding_box                    ; Screen bouding box

        LDR     r1, [r0, #8]                        ; Decide on initial left/right positioning
        TST     r2, #PinboardOption_WinToCornerLR   ; 0 = Left (EQ), 1 = Right (NE)
        MOVEQ   r3, #0
        SUBNE   r3, r1, #grid_x_spacing

        LDR     r1, [r0, #12]                       ; Decide on initial up/down positioning
        TST     r2, #PinboardOption_WinToCornerTB   ; 0 = Top (EQ), 1 = Bottom (NE)
        SUBEQ   r4, r1, #grid_y_spacing
        LDRNE   r4, icon_bar_height

        SUB     sp, sp, #48                         ; Increase stack - we'll use it for getting icon data
a442 68
        ; Now loop through linked list of icons and see if they present a problem (occupy the space that
        ; our 'proposed' icon is going to use). If so, try another space. If not, then we can use the coords.
        ; (Surely there's an easier way?)
        ; r2 = options
        ; r3 = iconize_x
        ; r4 = iconize_y
        ; r3-r6 = attempted bounding box
        ; r11 -> current iconized icon we're checking
        ; r10 -> bounding box of the icon we're checking

10 ; tryagain
        ORR     r2, r2, #PinboardFlag_UseWindowList ; reset the list we're using to the window_list
        STR     r2, Pinboard_options
        LDR     r11, iconized_ptr                   ; location of first icon data
        CMP     r11, #0                             ; check there's actuallly icons in this list
        BNE     %FT20

        BIC     r2, r2, #PinboardFlag_UseWindowList ; There weren't any icons in the window_list
        STR     r2, Pinboard_options                ; so move to the file list.
        LDR     r11, Icon_list

20 ; nexticon
        CMP     r11, #0                             ; check for the end of the list
        BEQ     %FT86
        MOV     r9, sp
        BL      get_next_icon_bbox                  ; Get the next bounding box
        CMP     r10, #0
        BEQ     %FT80                               ; if bbox -> 0, icon was not on backdrop - go to next

        ADD     r5, r3, #grid_x_spacing             ; make r3, r4, r5, r6 the proposed bounding box.
        ADD     r6, r4, #grid_y_spacing

        ; Check the proposed icon's left and right bounds against the current stored icon
        LDR     r7, [r10]
        CMP     r5, r7                              ; Check proposed x2 <= icon x1
        BLE     %FT80                               ; If it is, then this icon presents no problems - try next
        LDR     r7, [r10, #8]
        CMP     r3, r7                              ; Check proposed x1 >= icon x2
        BGE     %FT80                               ; If it is, then this icon presents no problems - try next

        ; Check the proposed icon's top and bottom bounds against the current stored icon
        LDR     r7, [r10, #4]
        CMP     r6, r7                              ; Check proposed y2 <= icon y1
        BLE     %FT80                               ; If it is, then this icon present no problems.
        LDR     r7, [r10, #12]
        CMP     r4, r7                              ; Check proposed y1 >= store y2
        BGE     %FT80                               ; If it is, then this icon presents no problems

        ; The bounds checks have failed - the stored icon overlaps with our proposed one.
        ; So, we've got to move onto the next possible slot on the pinboard.
        BL  find_next_x_and_y
        BNE %FT84
        B   %BT10

80 ; try_next
        BL      get_next_icon_block
        B       %BT20                               ; Next icon - go back and check it

84 ; screen_full
        B       %FT88

86 ; got_one
        STR     r3, iconize_x
        STR     r4, iconize_y

88 ; exit
        ADD     sp, sp, #48
        Pull    "r0-r12"
a488 33
; get_next_icon_block
;
; Given an icon data block, find the next icon in the linked list. Includes
; both file icon list and window icon list. PinboardFlag_UseWindowList
; indicates if we are currently on the window list (set) or file list
; (clear). If we've reached the end of the window list, we'll move to
; the file list, but not vice-versa.
;
; In:  r2 = Pinboard_options
;      r11 -> icon data block
;
; Out: r10 -> bounding box (which will be 16 bytes within the 40 bytes)
;      r0, r1 corrupted

get_next_icon_block Entry

        TST     r2, #PinboardFlag_UseWindowList
        LDRNE   r11, [r11, #w_next_ptr]    ; if iconised window
        LDREQ   r11, [r11, #ic_next]       ; if file icon
        CMP     r11, #0
        EXIT    NE

        TST     r2, #PinboardFlag_UseWindowList
        EXIT    EQ                         ; if this is the file list, we can go no further

        BIC     r2, r2, #PinboardFlag_UseWindowList
        STR     r2, Pinboard_options
        LDR     r11, Icon_list

        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
d517 2
a518 1
        SUB     r1, r1, #grid_y_spacing
d525 1
a525 1
        SUBS    r4, r4, #grid_y_spacing
d534 1
a534 1
        ADD     r4, r4, #grid_y_spacing
d546 2
a547 1
        SUBS    r3, r3, #grid_x_spacing
d552 2
a553 1
        ADD     r3, r3, #grid_x_spacing
d555 1
a555 1
        SUB     r1, r1, #grid_x_spacing
d565 1
d567 1
a567 1
        SUB     r1, r1, #grid_x_spacing
d574 1
a574 1
        SUBS    r3, r3, #grid_x_spacing
d580 1
a580 1
        ADD     r3, r3, #grid_x_spacing
d591 2
a592 1
        SUBS    r4, r4, #grid_y_spacing
d600 2
a601 1
        ADD     r4, r4, #grid_y_spacing
d603 1
a603 1
        SUB     r1, r1, #grid_y_spacing
@


4.2
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.76. Tagged as 'Pinboard-0_76'
@
text
@d39 1
a39 1
        ; Deecide starting position
d76 1
a76 1
         ; Find the next grid position
@


4.1
log
@Ursula branch merged.
Added inclusion of Machine header for new CMOS header
Moved to srccommit.
Templates contain hardwired version/date information which is a long
  way out of date.  This has not been fixed in this checkin.

Version 0.75. Tagged as 'Pinboard-0_75'
@
text
@d29 1
a29 1
tidy_icons ENTRY "r0-r11"
d38 1
a38 1
 
d47 2
a48 2
        
        ; Now, go through all the icons and move them, if selected.                
d51 1
a51 1
        
d56 1
a56 1
        
d71 1
a71 1
tidy_find_next_icon_space ENTRY "r0, r4"
d75 1
a75 1
        
d82 1
a82 1
        
d87 1
a87 1
        EXIT    NE        
d94 1
a94 1
  
d112 1
a112 1
tidy_decide_origin ENTRY "r0-r1, r4-r6"
d119 1
a119 1
        TST     r5, #PinboardFlag_TidyWindows       ; see if we're dealing with windows or files        
d128 1
a128 1
        TST    r5, #PinboardFlag_TidyWindows        ; see if we're dealing with windows or files 
d146 1
a146 1
        
d153 1
a153 1
; 
d160 1
a160 1
tidy_move_icon_if_selected ENTRY "r0-r1, r4-r10"
d164 1
a164 1
        
d167 1
a167 1
        
d174 1
a174 1
        STR     r9, [r1]                              ; Backdrop handle               
d176 1
a176 1
        STR     r0, [r1, #4]                        
d215 1
a215 1
        
d219 1
a219 1
        
d222 1
a222 1
        EXIT        
d236 1
a236 1
tidy_find_next_free ENTRY
d252 1
a252 1
        CMP     r0, r0        
d268 1
a268 1
is_something_there ENTRY "r2, r5-r11"
d283 1
a283 1
        
d288 1
a288 1
        LDR     r7, [r10] 
d294 1
a294 1
        
d302 1
a302 1
        
d315 1
a315 1
        EXIT        
d330 1
a330 1
next_grid_row_or_column ENTRY "r5"
d335 1
a335 1
        
d362 1
a362 1
        
d372 1
a372 1
        
d391 1
a391 1
get_iconise_position ENTRY
d409 1
a409 1
                 
d413 1
a413 1
        ; our 'proposed' icon is going to use). If so, try another space. If not, then we can use the coords. 
d421 1
a421 1
        
d428 1
a428 1
        
d440 1
a440 1
        
d445 1
a445 1
        LDR     r7, [r10] 
d451 1
a451 1
        
d465 1
a465 1
        
d472 1
a472 1
 
d476 1
a476 1
                
d497 1
a497 1
get_next_icon_bbox ENTRY
d499 1
a499 1
        MOV     r10, #0        
d506 1
a506 1
        
d521 2
a522 2
        
        EXIT        
d540 1
a540 1
get_next_icon_block ENTRY
d547 1
a547 1
        
d550 1
a550 1
        
d554 1
a554 1
        
d573 1
a573 1
find_next_x_and_y ENTRY
d585 1
a585 1
        ADR     r0, bounding_box  
d592 1
a592 1
      
d601 1
a601 1
        
d610 1
a610 1
        ADR     r0, bounding_box  
d613 1
a613 1
        
d617 2
a618 2
        B       find_next_found        
        
d631 1
a631 1
        ADR     r0, bounding_box  
d689 1
a689 1
        
@


1.1
log
@file Tidy was initially added on branch Ursula.
@
text
@d1 691
@


1.1.2.1
log
@Fixed a couple of bugs.
Improved tidying code.
Filenames are now truncated.
@
text
@a0 691
; Copyright 1998 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; s.Tidy
; Tidying and placing of icons

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_icons
;
; Tidies either the file icons or the window icons. Which is done depends
; on the value PinboardFlag_TidyWindows (set tidy window icons, clear
; tidy files).
;
; In:  Nothing.
;
; Out: All regs preserved.

tidy_icons ENTRY "r0-r11"

        LDR     r8, Pinboard_options
        TST     r8, #PinboardFlag_PinboardFull
        BICNE   r8, r8, #PinboardFlag_PinboardFull  ; Assume pinboard isn't yet full
        TST     r8, #PinboardFlag_TidyWindows
        BICNE   r8, r8, #PinboardFlag_UseWindowList ; Set UseWindowList flag for later functions
        ORREQ   r8, r8, #PinboardFlag_UseWindowList
        STR     r8, Pinboard_options
 
        ; Deecide starting position
        BL      tidy_decide_origin
        MOV     r9, sp                              ; r9 is now data pointer

        ; Where's the icon data?
        TST     r8, #PinboardFlag_TidyWindows
        LDRNE   r11, iconized_ptr                   ; First window icon in list
        LDREQ   r11, Icon_list                      ; First file icon in list
        
        ; Now, go through all the icons and move them, if selected.                
50      CMP     r11, #0                             ; have we reached the end of list?
        EXIT    EQ
        
        LDR     r0, backdrop_handle
        LDR     r1, [r11, #ic_window]
        CMP     r0, r1                              ; is the next icon on the backdrop?
        BNE     %FT70
        
        BL      tidy_move_icon_if_selected          ; move icon, if selected.
        BLEQ    tidy_find_next_icon_space           ; if we've moved an icon, find where to put next

70      LDR     r11, [r11, #ic_next]                ; find next icon data block
        B       %BT50

        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_find_next_icon_space
;
; Where will the next icon we tidy go?

tidy_find_next_icon_space ENTRY "r0, r4"

        MOV     r4, r3
        MOV     r3, r2
        
         ; Find the next grid position
        TST     r8, #PinboardFlag_TidyWindows
        MOVEQ   r2, r8, LSR #3                  ; shift the flags if files, so they look like
        MOVNE   r2, r8                          ; window flags.
        BL      find_next_x_and_y
        BNE     %FT10                           ; NE if the screen was filled up with this call
        
        ; If the screen is already full, then we don't bother to check for clashes anymore
        TST     r8, #PinboardFlag_PinboardFull
        MOVNE   r2, r3
        MOVNE   r3, r4
        EXIT    NE        

        ; Screen not full - try and find the next free space
        BL      tidy_find_next_free
        MOVEQ   r2, r3
        MOVEQ   r3, r4
        EXIT    EQ
  
        ; The screen is now full - reset to origin
10      ORR     r8, r8, #PinboardFlag_PinboardFull
        STR     r8, Pinboard_options
        BL      tidy_decide_origin
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_decide_origin
;
; Decide where the origin of a tidy is. By that we mean the x and y
; co-ordinate of the grid position of the corner we're tidying from.
;
; In: Nothing.
;
; Out: r2, r3 = x and y co-ordinates of start grid position.

tidy_decide_origin ENTRY "r0-r1, r4-r6"

        LDR     r5, Pinboard_options                ; Pinboard options
        ADR     r6, bounding_box                    ; Screen bouding box

        ; Decide on initial left/right positioning
        LDR     r1, [r6, #8]                        ; load screen max_x
        TST     r5, #PinboardFlag_TidyWindows       ; see if we're dealing with windows or files        
        MOVNE   r0, #PinboardOption_WinToCornerLR   ; if windows, then we'll test WinToCornerLR bit
        MOVEQ   r0, #PinboardOption_TidyToCornerLR  ; if files, then we'll test TidyToCornerLR bit
        TST     r5, r0                              ; test the bit
        MOVEQ   r3, #0                              ; if not set, then use left of screen
        SUBNE   r3, r1, #grid_x_spacing             ; if set, then use right of screen

        ; Decide on initial up/down positiong
        LDR    r1, [r6, #12]                        ; load screen max_y
        TST    r5, #PinboardFlag_TidyWindows        ; see if we're dealing with windows or files 
        MOVNE  r0, #PinboardOption_WinToCornerTB    ; if windows, then we'll test WinToCornerTB
        MOVEQ  r0, #PinboardOption_TidyToCornerTB   ; if files, then we'll test TidyToCornerTB
        TST    r5, r0                               ; test the bit
        SUBEQ  r4, r1, #grid_y_spacing              ; if not set, then use top of screen
        LDRNE  r4, icon_bar_height                  ; if set, then use bottom of screen

        ; If we're doing files, then check initial position for clash
        ; ie. windows are higher priority.
        TST     r5, #PinboardFlag_PinboardFull
        BNE     %FT10
        TST     r5, #PinboardFlag_TidyWindows
        BLEQ    tidy_find_next_free

10      MOV     r2, r3
        MOV     r3, r4

        EXIT
        

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_move_icon_if_selected
;
; Check if icon whose details are in the structure in r11 is selected and
; if so, move it to the grid co-ordinates pointed to by r2, r3.
; 
; In: r2, r3 = x, y grid co-ordinate to move to
;     r11 -> icon data structure
;
; Out: NE = didn't move icon
;      EQ = did move icon.

tidy_move_icon_if_selected ENTRY "r0-r1, r4-r10"

        SUB     sp, sp, #48                           ; Use stack for temporary storage.
        MOV     r1, sp
        
        LDR     r9, backdrop_handle
        LDR     r8, Pinboard_options
        
        ; If pinboard full, we offset the icons a little
        TST     r8, #PinboardFlag_PinboardFull
        MOVNE   r10, #(grid_x_spacing/2)
        MOVEQ   r10, #0

        ; Get the current wimp state of the icon
        STR     r9, [r1]                              ; Backdrop handle               
        LDR     r0, [r11, #ic_icon]                   ; Icon handle
        STR     r0, [r1, #4]                        
        SWI     XWimp_GetIconState
        BVS     %FT10

        ; We'll only move it if it's selected
        LDR     r0, [r1, #24]                       ; icon flags
        TST     r0, #is_selected
        BEQ     %FT10

        ; Resize it...
        LDR     r4, [r1, #8]                        ; How wide is the icon?
        LDR     r5, [r1, #16]
        SUB     r6, r5, r4
        LDR     r4, [r1, #12]                       ; How tall is the icon?
        LDR     r5, [r1, #20]
        SUB     r7, r5, r4

        Push    "r2"
        MOV     r0, #grid_x_spacing                 ; Adjust for centre alignment
        SUBS    r1, r0, r6                          ; x1
        ADDPL   r2, r2, r1, LSR #1                  ; x2
        SUBMI   r1, r6, r0
        SUBMI   r2, r2, r1, LSR #1

        ADD     r4, r2, r6                          ; x2
        ADD     r5, r3, r7                          ; y2

        ADD     r2, r2, r10                         ; icon offset if pinboard full
        ADD     r4, r4, r10                         ; icon offset if pinboard full

        TST     r8, #PinboardFlag_TidyWindows
        STREQ   r2, [r11, #ic_x]                    ; store x
        STREQ   r3, [r11, #ic_y]                    ; store y

        MOV     r0, r9
        LDR     r1, [r11, #ic_icon]
        SWI     XWimp_ResizeIcon                    ; Move icon to new x and y
        Pull    "r2"
        BVS     %FT10
        
        ADD     sp, sp, #48                         ; exit EQ
        CMP     r8, r8
        EXIT
        
10      ADD     sp, sp, #48
        CMP     pc, r8                              ; exit NE
        EXIT        


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_find_next_free
;
; Given an initial grid position, check if it's space is occupied. If it
; is, then move to the next position and try again.
;
; In: r3, r4 = x and y co-ordinates
;
; Out: r3, r4  = next free slot
;      r0 - r2 = corrupted.

tidy_find_next_free ENTRY

        LDR     r2, Pinboard_options
        TST     r2, #PinboardFlag_TidyWindows
        BNE     %FT20

10
        LDR     r2, Pinboard_options
        BL      is_something_there
        BNE     %FT20
        MOV     r2, r2, LSR #3
        BL      find_next_x_and_y
        EXIT    NE
        B       %BT10

20
        CMP     r0, r0        
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; is_something_there
;
; Test if a grid position is occupied. As to which list of icons is
; checked depends on the value of PinboardFlag_TidyWindows. If set,
; then the file icon list is searched, else the iconised window list.
;
; In: r3, r4 = x and y co-ordinate of grid position
;
; Out: EQ if something there, NE if not.
;      All regs. preserved.

is_something_there ENTRY "r2, r5-r11"

        LDR     r2, Pinboard_options
        TST     r2, #PinboardFlag_TidyWindows
        LDREQ   r11, iconized_ptr                 ; first window in list?
        LDRNE   r11, Icon_list                    ; or first icon in list?
        SUB     sp, sp, #40                       ; grab some stack space to put data block
        MOV     r9, sp

20      ; next icon
        CMP     r11, #0                           ; is this the end of the linked list?
        BEQ     %FT90
        BL      get_next_icon_bbox                ; get the icon's bounding box
        CMP     r10, #0                           ; icon not on backdrop if r10 is zero
        BEQ     %FT80
        
        ADD     r5, r3, #grid_x_spacing           ; make r3, r4, r5, r6 the proposed bounding box.
        ADD     r6, r4, #grid_y_spacing

        ; Check the proposed icon's left and right bounds against the current stored icon
        LDR     r7, [r10] 
        CMP     r5, r7                            ; Check proposed x2 <= icon x1
        BLE     %FT80                             ; If it is, then this icon presents no problems - try next
        LDR     r7, [r10, #8]
        CMP     r3, r7                            ; Check proposed x1 >= icon x2
        BGE     %FT80                             ; If it is, then this icon presents no problems - try next
        
        ; Check the proposed icon's top and bottom bounds against the current stored icon
        LDR     r7, [r10, #4]
        CMP     r6, r7                            ; Check proposed y2 <= icon y1
        BLE     %FT80                             ; If it is, then this icon present no problems.
        LDR     r7, [r10, #12]
        CMP     r4, r7                            ; Check proposed y1 >= store y2
        BGE     %FT80                             ; If it is, then this icon presents no problems
        
70      ; Exit EQ
        ADD     sp, sp, #40
        CMP     sp, sp
        EXIT

80      ; this icon doesn't occupy the space - try next
        LDR     r11, [r11, #ic_next]
        B       %BT20

90      ; something ISN'T there - Exit NE
        ADD     sp, sp, #40
        CMP     sp, #0
        EXIT        


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; next_grid_row_or_column
;
; Depending on PinboardOption_WinToCornerXX, return the X and Y
; co-ordinate of the start of the next row or column.
;
; In: r2     = options
;     r3, r4 = x and y co-ordinate of grid position

;
; Out: r3, r4 = x and y co-ordinate of next row or column

next_grid_row_or_column ENTRY "r5"

        ADR     r5, bounding_box
        TST     r2, #PinboardOption_WinToCornerHV ; Are we dealing with rows or columns?
        BNE     %FT20
        
10      ; rows - reset x to left/right and move up/down a row
        LDR     r0, [r5, #8] ; x2
        TST     r2, #PinboardOption_WinToCornerLR
        SUBNE   r3, r0, #grid_x_spacing
        MOVEQ   r3, #0

        TST     r2, #PinboardOption_WinToCornerTB
        ADDNE   r4, r4, #grid_y_spacing
        SUBEQ   r4, r4, #grid_y_spacing

        ; Check we haven't moved up/down too far
        LDR     r0, [r5, #12] ; y2
        SUB     r0, r0, #grid_y_spacing
        CMP     r4, r0
        SUBGT   r4, r4, #grid_y_spacing

        LDR     r0, icon_bar_height
        CMP     r4, r0
        ADDLT   r4, r4, #grid_y_spacing
        EXIT

20      ; columns - reset y to top/bottom and move left/right a column
        LDR     r0, [r5, #12] ; y2
        TST     r2, #PinboardOption_WinToCornerTB
        LDRNE   r4, icon_bar_height
        SUBEQ   r4, r0, #grid_y_spacing
        
        TST     r2, #PinboardOption_WinToCornerLR
        SUBNE   r3, r3, #grid_x_spacing
        ADDEQ   r3, r3, #grid_x_spacing

        ; Check we haven't moved left/right too far
        LDR     r0, [r5, #8] ; x2
        SUB     r0, r0, #grid_x_spacing
        CMP     r3, r0
        SUBGT   r3, r3, #grid_x_spacing
        
        CMP     r3, #0
        ADDLT   r3, r3, #grid_x_spacing
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_iconise_position
;
; Decide where to put the icon for a window that's just been iconized.
; The process involves choosing a location, then searching first the window list, then the
; file list, to see if the space is occupied. If it is, then we move to the next space
; (dependent on PinboardOption_WinToCorner...) and check through each list again.
;
; In: Nothing.
;
; Out: The memory locations iconise_x and iconise_y are set to the position for the icon.
;      All regs preserved.

get_iconise_position ENTRY

        Push    "r0-r12"

        LDR     r2, Pinboard_options                ; Pinboard options
        ORR     r2, r2, #PinboardFlag_UseWindowList ; Start with the window list
        STR     r2, Pinboard_options
        ADR     r0, bounding_box                    ; Screen bouding box

        LDR     r1, [r0, #8]                        ; Decide on initial left/right positioning
        TST     r2, #PinboardOption_WinToCornerLR   ; 0 = Left (EQ), 1 = Right (NE)
        MOVEQ   r3, #0
        SUBNE   r3, r1, #grid_x_spacing

        LDR     r1, [r0, #12]                       ; Decide on initial up/down positioning
        TST     r2, #PinboardOption_WinToCornerTB   ; 0 = Top (EQ), 1 = Bottom (NE)
        SUBEQ   r4, r1, #grid_y_spacing
        LDRNE   r4, icon_bar_height
                 
        SUB     sp, sp, #48                         ; Increase stack - we'll use it for getting icon data

        ; Now loop through linked list of icons and see if they present a problem (occupy the space that
        ; our 'proposed' icon is going to use). If so, try another space. If not, then we can use the coords. 
        ; (Surely there's an easier way?)
        ; r2 = options
        ; r3 = iconize_x
        ; r4 = iconize_y
        ; r3-r6 = attempted bounding box
        ; r11 -> current iconized icon we're checking
        ; r10 -> bounding box of the icon we're checking
        
10 ; tryagain
        ORR     r2, r2, #PinboardFlag_UseWindowList ; reset the list we're using to the window_list
        STR     r2, Pinboard_options
        LDR     r11, iconized_ptr                   ; location of first icon data
        CMP     r11, #0                             ; check there's actuallly icons in this list
        BNE     %FT20
        
        BIC     r2, r2, #PinboardFlag_UseWindowList ; There weren't any icons in the window_list
        STR     r2, Pinboard_options                ; so move to the file list.
        LDR     r11, Icon_list

20 ; nexticon
        CMP     r11, #0                             ; check for the end of the list
        BEQ     %FT86
        MOV     r9, sp
        BL      get_next_icon_bbox                  ; Get the next bounding box
        CMP     r10, #0
        BEQ     %FT80                               ; if bbox -> 0, icon was not on backdrop - go to next
        
        ADD     r5, r3, #grid_x_spacing             ; make r3, r4, r5, r6 the proposed bounding box.
        ADD     r6, r4, #grid_y_spacing

        ; Check the proposed icon's left and right bounds against the current stored icon
        LDR     r7, [r10] 
        CMP     r5, r7                              ; Check proposed x2 <= icon x1
        BLE     %FT80                               ; If it is, then this icon presents no problems - try next
        LDR     r7, [r10, #8]
        CMP     r3, r7                              ; Check proposed x1 >= icon x2
        BGE     %FT80                               ; If it is, then this icon presents no problems - try next
        
        ; Check the proposed icon's top and bottom bounds against the current stored icon
        LDR     r7, [r10, #4]
        CMP     r6, r7                              ; Check proposed y2 <= icon y1
        BLE     %FT80                               ; If it is, then this icon present no problems.
        LDR     r7, [r10, #12]
        CMP     r4, r7                              ; Check proposed y1 >= store y2
        BGE     %FT80                               ; If it is, then this icon presents no problems

        ; The bounds checks have failed - the stored icon overlaps with our proposed one.
        ; So, we've got to move onto the next possible slot on the pinboard.
        BL  find_next_x_and_y
        BNE %FT84
        B   %BT10
        
80 ; try_next
        BL      get_next_icon_block
        B       %BT20                               ; Next icon - go back and check it

84 ; screen_full
        B       %FT88
 
86 ; got_one
        STR     r3, iconize_x
        STR     r4, iconize_y
                
88 ; exit
        ADD     sp, sp, #48
        Pull    "r0-r12"
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_next_icon_box
;
; Given a pointer to a data block, find the icon's bounding box.
; PinboardFlag_UseWindowList sets if the block is in the window or file list
;
; In: r2 = Pinboard_options
;     r11 -> icon data block
;     r9  -> 40 byte block of temporary memory (typically stack)
;
; Out: r10 -> bounding box (which will be 16 bytes within the 40 bytes)
;             if r10 is zero, icon is not on backdrop.
;      r0, r1 corrupted

get_next_icon_bbox ENTRY

        MOV     r10, #0        
        TST     r2, #PinboardFlag_UseWindowList ; Is the data -> by r9 in the window or file list?
        BNE     %FT20

10      ; find the icon handle from the file icon list
        LDR     r0, [r11, #ic_icon]
        B       %FT30
        
20      ; find the icon handle from the window icon list
        LDR     r0, backdrop_handle
        LDR     r1, [r11, #w_icon_id]
        CMP     r0, r1
        EXIT    NE                              ; icon not on backdrop - exit
        LDR     r0, [r11, #w_icon_handle]

30      ; found an icon handle - get it's bounding box
        STR     r0, [r9, #4]
        LDR     r0, backdrop_handle
        STR     r0, [r9]
        MOV     r1, r9
        SWI     Wimp_GetIconState
        ADD     r10, r1, #8
        
        EXIT        


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_next_icon_block
;
; Given an icon data block, find the next icon in the linked list. Includes
; both file icon list and window icon list. PinboardFlag_UseWindowList
; indicates if we are currently on the window list (set) or file list
; (clear). If we've reached the end of the window list, we'll move to
; the file list, but not vice-versa.
;
; In:  r2 = Pinboard_options
;      r11 -> icon data block
;
; Out: r10 -> bounding box (which will be 16 bytes within the 40 bytes)
;      r0, r1 corrupted

get_next_icon_block ENTRY

        TST     r2, #PinboardFlag_UseWindowList
        LDRNE   r11, [r11, #w_next_ptr]    ; if iconised window
        LDREQ   r11, [r11, #ic_next]       ; if file icon
        CMP     r11, #0
        EXIT    NE
        
        TST     r2, #PinboardFlag_UseWindowList
        EXIT    EQ                         ; if this is the file list, we can go no further
        
        BIC     r2, r2, #PinboardFlag_UseWindowList
        STR     r2, Pinboard_options
        LDR     r11, Icon_list
        
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; find_next_x_and_y
;
; What are x and y co-ordinates of the next spot on the grid?
; This depends on the start corner and the direction of stacking.
;
; In: r2 = pinboard options
;     r3 = x co-ord.
;     r4 = y co-ord.
;
; Out: r3, r4 = x and y co-ordinates
;      NE     = Screen full
;      EQ     = Found new position (in r3, r4)
;      r0, r1 = corrupted.

find_next_x_and_y ENTRY

        ; Which way are we stacking?
        TST     r2, #PinboardOption_WinToCornerHV ; 0 = horizontally (EQ), 1 = vertically (NE)
        BEQ     find_next_horizontal
        BNE     find_next_vertical


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

find_next_vertical

        TST     r2, #PinboardOption_WinToCornerTB ; 0 = top (EQ) 1 = bottom (NE)
        BNE     %FT12

        ADR     r0, bounding_box  
        LDR     r1, [r0, #12]
        SUB     r1, r1, #grid_y_spacing
        LDR     r0, icon_bar_height
       
        ; move down
        SUBS    r4, r4, #grid_y_spacing
        MOVMI   r4, r1
        BMI     %FT16
        CMP     r4, r0
        MOVLT   r4, r1
        BLT     %FT16
        B       find_next_found
        
12      ; move up
        ADD     r4, r4, #grid_y_spacing
        CMP     r4, r1
        MOVGE   r4, r0
        BGE     %FT16
        B       find_next_found

16      ; we've hit the edge - move left/right
        ADR     r0, bounding_box  
        TST     r2, #PinboardOption_WinToCornerLR
        BEQ     %FT18
        
        ; move left
        SUBS    r3, r3, #grid_x_spacing
        BMI     find_next_screen_full
        B       find_next_found        
        
18      ; move right
        ADD     r3, r3, #grid_x_spacing
        LDR     r1, [r0, #8]
        SUB     r1, r1, #grid_x_spacing
        CMP     r3, r1
        BGT     find_next_screen_full
        B       find_next_found

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

find_next_horizontal

        ADR     r0, bounding_box  
        LDR     r1, [r0, #8]
        SUB     r1, r1, #grid_x_spacing

        ; which direction do we move?
        TST     r2, #PinboardOption_WinToCornerLR ; 0 = left (EQ), 1 = right (NE)
        BEQ     %FT22

        ; move left
        SUBS    r3, r3, #grid_x_spacing
        MOVMI   r3, r1
        BMI     %FT26
        B       find_next_found

22      ; move right
        ADD     r3, r3, #grid_x_spacing
        CMP     r3, r1
        MOVGE   r3, #0
        BGE     %FT26
        B       find_next_found

26      ; we've hit the edge - move up/down
        TST     r2, #PinboardOption_WinToCornerTB
        BNE     %FT28

        ; move down
        SUBS    r4, r4, #grid_y_spacing
        BMI     find_next_screen_full
        LDR     r1, icon_bar_height
        CMP     r4, r1
        BLT     find_next_screen_full
        B       find_next_found

28      ; move up
        ADD     r4, r4, #grid_y_spacing
        LDR     r1, [r0, #12]
        SUB     r1, r1, #grid_y_spacing
        CMP     r4, r1
        BGT     find_next_screen_full
        B       find_next_found


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

find_next_found

        ; We've found the next slot - exit EQ
        MOV     r0, #24
        CMP     r0, #24
        EXIT


find_next_screen_full

        ; The screen was full - exit NE
        MOV     r0, #24
        CMP     r0, #23
        EXIT
        

        LNK     s.Tail
@


1.1.2.2
log
@- If Shift+Click on close icon, then don't iconise to iconbar.
- Fixed bug in stacking of icons vertically from bottom of screen.
@
text
@d585 3
d592 1
a592 4

        TST     r2, #PinboardOption_WinToCornerTB ; 0 = top (EQ) 1 = bottom (NE)
        BNE     %FT12
      
@

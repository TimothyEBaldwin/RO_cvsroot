head	4.15;
access;
symbols
	Pinboard-1_04:4.15
	Pinboard-1_03:4.15
	Pinboard-1_02:4.15
	Pinboard-1_01:4.15
	Pinboard-1_00:4.14
	Pinboard-0_99:4.13
	Pinboard-0_98:4.13
	Pinboard-0_97:4.13
	Pinboard-0_96:4.13
	Pinboard-0_95:4.12
	Pinboard-0_94:4.11
	Pinboard-0_93:4.11
	Pinboard-0_92:4.9
	Pinboard-0_91:4.9
	Pinboard-0_90:4.8
	Pinboard-0_89:4.7
	Pinboard-0_88:4.7
	Pinboard-0_87:4.6
	Pinboard-0_86:4.6
	Pinboard-0_85:4.6
	Pinboard-0_84:4.6
	Pinboard-0_83:4.5
	Pinboard-0_82:4.4
	RO_5_07:4.4
	Pinboard-0_81:4.4
	Pinboard-0_80:4.4
	Pinboard-0_79:4.4
	Pinboard-0_78:4.4
	Pinboard-0_77:4.3
	Pinboard-0_76:4.3
	Ursula_merge:4.1.4.11
	Pinboard-0_75:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.10
	Ursula_RiscPC:4.1.4.10.0.2
	rleggett_Pinboard-0_75d:4.1.4.11
	rthornb_UrsulaBuild-19Aug1998:4.1.4.10
	UrsulaBuild_FinalSoftload:4.1.4.10
	rthornb_UrsulaBuild-12Aug1998:4.1.4.10
	aglover_UrsulaBuild-05Aug1998:4.1.4.10
	rthornb_UrsulaBuild-29Jul1998:4.1.4.10
	rthornb_UrsulaBuild-22Jul1998:4.1.4.10
	rleggett_Pinboard-0_75c:4.1.4.10
	rleggett_Pinboard-0_75b:4.1.4.9
	rleggett_Pinboard-0_75:4.1.4.9
	rthornb_UrsulaBuild-15Jul1998:4.1.4.8
	rthornb_UrsulaBuild-07Jul1998:4.1.4.8
	rthornb_UrsulaBuild-17Jun1998:4.1.4.8
	rthornb_UrsulaBuild-03Jun1998:4.1.4.8
	rthornb_UrsulaBuild-27May1998:4.1.4.8
	rthornb_UrsulaBuild-21May1998:4.1.4.8
	rleggett_Pinboard-0_74:4.1.4.8
	rthornb_UrsulaBuild_01May1998:4.1.4.8
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.15
date	2016.05.10.21.05.00;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	O1qMSkbGF6eaMY5z;

4.14
date	2016.05.08.16.45.04;	author jlee;	state Exp;
branches;
next	4.13;
commitid	6qtTwO9XstbZoH5z;

4.13
date	2012.09.11.19.31.14;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	wgigNNHV7grve9kw;

4.12
date	2012.08.23.19.59.09;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	rztFpV1VBvCVZHhw;

4.11
date	2011.09.24.07.31.20;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	nRjnbtmOSxK1BIAv;

4.10
date	2011.09.24.07.25.50;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	NapphrXjtkIXyIAv;

4.9
date	2011.04.15.14.12.23;	author srevill;	state Exp;
branches;
next	4.8;
commitid	jh4OsQ8SVVas1Wfv;

4.8
date	2011.04.14.13.23.50;	author bavison;	state Exp;
branches;
next	4.7;
commitid	OKU4kYQkZdJNMNfv;

4.7
date	2008.10.04.19.14.57;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2007.09.18.13.28.38;	author srevill;	state Exp;
branches;
next	4.5;

4.5
date	2006.03.14.18.45.07;	author srevill;	state Exp;
branches;
next	4.4;

4.4
date	2002.11.11.12.34.51;	author rsprowson;	state Exp;
branches;
next	4.3;

4.3
date	2001.03.16.17.07.04;	author sbrodie;	state Exp;
branches;
next	4.2;

4.2
date	99.08.17.19.05.20;	author sbrodie;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.02;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.30.02;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.29.53;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	97.06.13.08.40.30;	author rleggett;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	97.08.04.11.50.22;	author rleggett;	state Exp;
branches;
next	4.1.4.3;

4.1.4.3
date	97.10.21.09.57.02;	author rleggett;	state Exp;
branches;
next	4.1.4.4;

4.1.4.4
date	97.10.22.09.33.26;	author rleggett;	state Exp;
branches;
next	4.1.4.5;

4.1.4.5
date	98.01.07.10.28.39;	author rleggett;	state Exp;
branches;
next	4.1.4.6;

4.1.4.6
date	98.03.27.09.36.32;	author rleggett;	state Exp;
branches;
next	4.1.4.7;

4.1.4.7
date	98.04.15.11.24.48;	author rleggett;	state Exp;
branches;
next	4.1.4.8;

4.1.4.8
date	98.04.23.11.52.18;	author rleggett;	state Exp;
branches;
next	4.1.4.9;

4.1.4.9
date	98.07.22.09.30.04;	author rleggett;	state Exp;
branches;
next	4.1.4.10;

4.1.4.10
date	98.07.22.11.48.18;	author rleggett;	state Exp;
branches;
next	4.1.4.11;

4.1.4.11
date	98.09.18.10.18.15;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.20.59;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.18.52;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.15
log
@Emit boot relative Pin/AddTinyDir commands where possible
When saving the desktop settings, use the same substring matching logic that !Configure's boot addapps/lookat/run uses, and replace the base of the name with Boot: or Boot:^.
This means that if the boot drive is renamed the pinboard still starts up with the same items on it.
Ditch support for Message_SaveDesktop - the code's been a NOP since Ursula (circa 1998).
Tested on a Raspberry Pi, renaming the SD card.

Version 1.01. Tagged as 'Pinboard-1_01'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; s.Messages
;
; Handle incoming Wimp messages.

message_bounced
        Push    "LR"

        LDR     r0, [r1,#ms_action]
        LDR     r14, =Message_WindowInfo
        TEQ     r0,r14
        BEQ     bounced_WindowInfo

        Pull    "PC"

message_received

        Push    "LR"

        LDR     r0, [r1,#ms_action]             ; Get message action.

        LDR     r14,=Message_ModeChange
        TEQ     r0, r14
        BEQ     ModeChange

        LDR     r14,=Message_FontChanged
        TEQ     r0, r14
        BEQ     FontChanged

      [ :LNOT: ursulawimp
        LDR     r14,=Message_PaletteChange
        TEQ     r0, r14
        BEQ     PaletteChange
      ]
        LDR     r14,=Message_FilerSelection
        TEQ     r0, r14
        BEQ     FilerSelection

        TEQ     r0,#Message_DataLoad
        BEQ     DataLoad

        TEQ     r0,#Message_DataSaveAck
        BEQ     DataSaveAck

        LDR     r14,=Message_FilerDevicePath
        TEQ     r0,r14
        BEQ     FilerDevicePath

        LDR     r14,=Message_MenusDeleted
        TEQ     r0,r14
        BEQ     MenuDeleted

        LDR     r14, =Message_IconizeAt
        TEQ     r0, r14
        BEQ     IconizeAt

        LDR     r14, =Message_Iconize
        TEQ     r0, r14
        BEQ     Iconize

        LDR     r14, =Message_WindowInfo
        TEQ     r0, r14
        BEQ     WindowInfo

        LDR     r14, =Message_TaskNameIs
        TEQ     r0, r14
        BEQ     got_task_name

        LDR     r14, =Message_WindowClosed
        TEQ     r0, r14
        BEQ     close_window

        LDR     r14, =Message_TaskCloseDown
        TEQ     r0, r14
        BEQ     close_task

        LDR     r14, =Message_HelpRequest
        TEQ     r0, r14
        BEQ     HelpRequest

        LDR     r14, =Message_ToggleBackdrop
        TEQ     r0, r14
        BEQ     ToggleBackdrop

        TEQ     r0,#Message_Quit
        Pull    "PC",NE

        BL      FreeIconList
        BL      FreeBufferedList
        LDR     r0,mytaskhandle
        LDR     r1,taskidentifier
        SWI     XWimp_CloseDown
        MOV     r0,#0
        STR     r0,mytaskhandle
        SWI     XOS_Exit

        Pull    "PC"

DataLoad ROUT

        Debug   pi,"Data load "

      [ debugpi
        LDR     r14,[r1,#ms_size]
        ADD     r14,r1,r14
        SUB     r14,r14,#8
        LDMIA   r14,{r0,r14}
        Debug   pi,"x,y = ",r0,r14
      ]

        LDR     r0,[r1,#20]                     ; Window handle
        CMP     r0,#0
        BLT     IconbarDataLoad                 ; Iconbar !

        MOV     r0,#FSControl_CanonicalisePath
        ADD     r1,r1,#44               ; -> path
        ADR     r2,dataarea
        MOV     r3,#0
        MOV     r4,#0
        MOV     r5,#256
        SWI     XOS_FSControl
        Pull    "PC",VS
        DebugS  pi,"Full Path is : ",r2
        RSB     r3,r5,#&100
        ADD     r3,r3,#1

        LDR     r6,NextPosition
        LDR     r7,NextPosition+4

        LDR     r1,backdrop_handle
        Debug   pi,"backdrop handle is ",r1
        BL      GetMonotonicID
        MOV     r0,#BufferReason_Remove
        BL      BufferIcon
        MOV     r0,#BufferReason_AddAtXY
        BL      BufferIcon

        ADD     r6,r6,#grid_x_spacing
        LDR     r14,DragBBox+8
        CMP     r6,r14
        LDRGE   r6,DragBBox
        SUBGE   r7,r7,#grid_y_spacing
        STR     r6,NextPosition
        STR     r7,NextPosition+4

        Pull    "PC"

IconbarDataLoad

        MOV     r0,#FSControl_CanonicalisePath
        ADD     r1,r1,#44               ; -> path
        ADR     r2,dataarea
        MOV     r3,#0
        MOV     r4,#0
        MOV     r5,#256
        SWI     XOS_FSControl
        Pull    "PC",VS
        DebugS  pi,"Full Path is : ",r2
        RSB     r3,r5,#&100
        ADD     r3,r3,#1

        MOV     r1,#-2
        BL      GetMonotonicID
        MOV     r0,#BufferReason_Remove
        BL      BufferIcon
        MOV     r0,#BufferReason_AddNewTinyDir
        BL      BufferIcon

        Pull    "PC"


ToggleBackdrop  ROUT

        MOV     R0,#User_Message_Acknowledge ; =19
        LDR     R3,[R1,#ms_myref]       ;
        LDR     R2,[R1,#ms_taskhandle]  ;
        STR     R3,[R1,#ms_yourref]     ;
        SWI     XWimp_SendMessage       ; acknowledge message

        STR     R2,[R1,#ms_taskhandle]  ; restore as ack screwed it
        LDR     R0,[R1,#ms_size]        ; get message size
        LDR     R2,[R1,#ms_data]        ; get flags
        CMP     R0,#&18                 ; is msg >= 24 bytes, ie flags present?
        MOVLT   R2,#0                   ; if not, assume 0

        ADD     R1,R1,#128              ; use upper half of wimp data block
        LDR     R0,backdrop_handle      ; get window handle of backdrop
        STR     R0,[R1,#u_handle]       ; pop window handle in block
        SWI     XWimp_GetWindowState    ; get state of backdrop
        LDR     R14,[R1,#u_bhandle]     ; get handle to open behind
        CMP     R14,#-1                 ; is it -1, ie backdrop at front?
        MOVNE   R14,#-2                 ; if not, pretend it's at back

        AND     R2,R2,#3                ; isolate bottom two bits of flags
        ADD     R2,R2,#1                ; convert flags to something that's
        AND     R2,R2,#3                ; easier to use (0,1,2,3 -> 1,2,3,0)
        CMP     R2,#1                   ;
        EOREQ   R14,R14,#1              ; toggle -2 <-> -1
        RSBHI   R14,R2,#1               ; convert %10 to -1, %11 to -2
        BLO     %FT01                   ; just notify, skip code to move backdrop

        CMP     R14,#-1                 ; is backdrop to be moved to front?
        LDR     R0,[R1,#u_wflags]       ; get flags for backdrop window
        BICEQ   R0,R0,#wf_backwindow    ; if to front, clear background stack bit
        ORRNE   R0,R0,#wf_backwindow    ; if to back, set background stack bit
        STR     R0,[R1,#u_wflags]       ; write flags for backdrop window back
        STR     R14,[R1,#u_bhandle]     ; write handle to open behind back

        LDR     R2,taskidentifier       ; magic word "TASK"
        MOV     R3,#-1                  ; -1 =>
        MOV     R4,#1                   ; bit 0 set =>
        SWI     XWimp_OpenWindow        ; open backdrop window in new position

01      SUB     R1,R1,#128              ; reset to start of wimp data block
        MOV     R2,#&18                 ; message size
        RSB     R3,R14,#0               ;
        LDR     R4,[R1,#ms_myref]       ;
        STR     R2,[R1,#ms_size]        ;
        STR     R3,[R1,#ms_data]        ;
        STR     R4,[R1,#ms_yourref]     ;

        MOV     R0,#User_Message        ; =17
        LDR     R2,[R1,#ms_taskhandle]  ;
        SWI     XWimp_SendMessage       ;

        Pull    "PC"


FilerSelection  ROUT

        ADD     r14,r1,#ms_data
        LDMIA   r14,{r0-r10}
        Debug   pi,"Filer selection BBOX: ",r0,r1,r2,r3
        Debug   pi,"Item width, height: ",r4,r5
        Debug   pi,"Display mode: ",r6
        Debug   pi,"Selection BBOX: ",r7,r8,r9,r10

  [ truncate_filenames
        ; Shrink dragbox to size it will be on pinboard (ie. column width in
        ; dir viewers is likely to be greater than column width in pinboard)
        Push    "r6-r10"
        SUB     r8, r2, r0              ; What is width of drag box?
        DivRem  r9, r8, r4, r10         ; Divide this by column width (from FilerSelection message)...
        CMP     r8, #0                  ; (check for remainder)
        ADDGT   r9, r9, #1              ; ...to get number of columns.
        MOV     r10, #grid_x_spacing
        MUL     r6, r10, r9             ; Multiply this by Pinboard's column width to get new box width

        ; Now we move the box, so that the icon where the drag started (the initiating
        ; icon) appears underneath the pointer on the pinboard.
        LDR     r7, [r14, #44]          ; r7 = mouse x
        SUB     r8, r7, r0              ; r8 = mouse x - x1
        DivRem  r9, r8, r4, r10, norem  ; r9 = column number of initiating icon
        MOV     r4, #grid_x_spacing     ; new item width
        MUL     r8, r9, r4
        SUB     r0, r7, r8              ; new x1 (nearly!)
        SUB     r0, r0, r4, LSR #1      ; minus half column width to centre gives new x1
        ADD     r2, r0, r6              ; new x2
        Pull    "r6-r10"
  ]

; for small icon /full into, drag box will be wildly out.
        TST     r6,#3
        SUBNE   r14,r2,r0
        MOVNE   r14,r14, ASR #1
        SUBNE   r14,r14,#68+12

        ADDNE   r2,r2,r14
        ADDNE   r0,r0,r14
        ADDNE   R1,r1,#16
        ADDNE   r3,r3,#16

        ; Subtract grid_y_spacing from each y co-ord.
        SUB     r1, r1, #grid_y_spacing
        SUB     r3, r3, #grid_y_spacing

        ; Ensure box isn't off screen
        Push    "r4, r5"
        LDR     r5, Screen_x1
        SUB     r4, r2, r0
        CMP     r0, #0                 ; if x1<0
        MOVLT   r2, r4                 ;   then x2 = bbox_width
        MOVLT   r0, #0                 ;    and x1 = 0
        CMP     r2, r5                 ; if x2>screen_width
        SUBGT   r0, r5, r4             ;   then x1 = screen_width - bbox_width
        MOVGT   r2, r5                 ;    and x2 = screen_width

        LDR     r5, icon_bar_height
        SUB     r5, r5, #grid_y_spacing
        SUB     r4, r3, r1
        CMP     r1, r5                 ; if y1<icon_bar_height
        ADDLT   r3, r5, r4             ;   then y2 = icon_bar_height + bbox_height
        MOVLT   r1, r5                 ;    and y1 = icon_bar_height
        LDR     r5, Screen_y1
        SUB     r5, r5, #grid_y_spacing
        CMP     r3, r5                 ; if y2>screen_height
        SUBGT   r1, r5, r4             ;   then y1 = screen_height - bbox_height
        MOVGT   r3, r5                 ;    and y2 = screen_height
        Pull    "r4, r5"

        ADR     r14,DragBBox
        STMIA   r14,{r0-r3}

        ADR     r14,NextPosition
        STMIA   r14,{r0,r3}                     ; x0,y1 of next position

        Pull    "pc"

FilerDevicePath
        ADD     r0,r1,#20
        B       Int_DataSaveAck

DataSaveAck     ROUT
        Debug   pi,"DataSaveAck received."

        MOV     r0,#DragType_NoDrag
        LDR     r14,DragType
        STR     r0,DragType
        TEQ     r14,#DragType_Save
        BEQ     Save_DataSaveAck

; Now that we have the directory to send to, start sending the files.

        ADD     r0,r1,#44
        ADR     r1,dest_directory
        BL      Copy_r0r1

00
        LDRB    r14,[r1],#-1
        CMP     r14,#"."
        BNE     %BT00
        MOV     r14,#0
        STRB    r14,[r1,#1]

Int_DataSaveAck

        LDR     r10,Icon_list
01
        CMP     r10,#0
        Pull    "PC",EQ

        LDR     r3,DragWindow
        ADR     r1,dataarea
        LDR     r0,[r10,#ic_window]      ; Not in drag window.
        TEQ     r0,r3
        BNE     %FT10

        LDR     r0,[r10,#ic_icon]
        STR     r3,[r1]
        STR     r0,[r1,#4]
        SWI     XWimp_GetIconState
        Pull    "PC",VS

        LDR     r0,[r1,#24]
        TST     r0,#selected
        BEQ     %FT10                   ; Not selected

        MOV     r0,#0
        STR     r0,[r1,#8]
        CMP     r3,#0
        MOVGT   r0,#is_selected
        MOVLT   r0,#selected
        STR     r0,[r1,#12]
        SWI     XWimp_SetIconState      ; Deselect

        CMP     r3,#0
        LDRGE   r0,Pinboard_Selected
        LDRLE   r0,TinyDirs_Selected
        SUB     r0,r0,#1
        STRGE   r0,Pinboard_Selected
        STRLE   r0,TinyDirs_Selected
        Debug   pi,"Selected icons = ",r0

; Check for recursive copy

        MOV     r0,#-1
        SWI     XTerritory_UpperCaseTable
        Pull    "PC",VS
        MOV     r14,r0

        ADD     r0,r10,#ic_path
        ADR     r1,dest_directory
        DebugS  pi,"Source: ",r0
        DebugS  pi,"Dest: ",r1
02
        LDRB    r3, [r0], #1    ;       Source char
        LDRB    r3, [r14, r3]
        LDRB    r4, [r1], #1    ;       Dest char
        LDRB    r4, [r14, r4]
        CMP     r3,#32
        BLE     %FT03
        CMP     r3,r4
        BEQ     %BT02
        B       %FT04
03
        Debug   pi,"Check terminating char ",r4
        CMP     r4,#"."
        CMPNE   r4,#32
        ADRLE   r0,ErrorBlock_Pinboard_CopyRecursive
        BLLE    msgtrans_errorlookup
        Pull    "PC",VS

04
        Debug   pi,"Copy not recursive"
        BL      read_copy_options
        Debug   pi,"Copy options read"

; Check free RAM. If less than 64k then there is not enough for a FilerAction task to do the copying
        MOV     r0, #-1
        MOV     r1, #-1
        SWI     XWimp_SlotSize
        Pull    "PC",VS

        Debug   pi,"Next slot is ",r1

; If not enough for FilerAction then *COPY
        CMP     r1, #Filer_Action_Memory_CopyRename
        BLT     do_copy

        Debug   pi,"Enough memory"

; Check configuration bit, do * copy if no interactive filer copy.
        MOV     r0,#OsByte_ReadCMOS
        MOV     r1,#FileSwitchCMOS
        SWI     XOS_Byte
        TST     R2,#4
        BNE     do_copy

        Debug   pi,"Configuration OK"

; Start FilerAction
        ADR     r0, FilerAction_command
        SWI     XWimp_StartTask
        Pull    "PC",VS
        CMP     r0, #0
        BEQ     do_copy

        Debug   pi,"Filer action started"

; Select source directory
        MOV     r8, r0
        ADD     r0, r10, #ic_path
        ADR     r1, dataarea
        BL      Copy_r0r1

        ADR     r14,dataarea
        MOV     r3,r14
05
        LDRB    r2,[r14],#1
        CMP     r2,#"."
        SUBEQ   r3,r14,#1
        CMP     r2,#32
        BGT     %BT05

        MOV     r0,#0
        STRB    r0,[r3],#1              ; Get just the directory name.

        MOV     r0, r8
        ADR     r1, dataarea
        DebugS  pi,"Source directory: ",r1
        SWI     XFilerAction_SendSelectedDirectory

; Select source file
        MOV     r1, r3
        DebugS  pi,"source file: ",r1
        SWI     XFilerAction_SendSelectedFile

; Perform the copy
; r1 = reason code, r2 = options, r3 -> destination directory, r4 = length of destination directory name

        MOV     r1, #Action_Copying
        LDR     r2, filer_action_copy_options
        ADR     r3, dest_directory
        MOV     r4, r3
06
        LDRB    r5, [r4], #1
        CMP     r5, #32
        BGT     %BT06
        SUB     r4, r4, r3
        MOV     r0,r8
        SWI     XFilerAction_SendStartOperation

10
        LDR     r10,[r10,#ic_next]
        B       %BT01

do_copy                                 ; There isn't enough memory to invoke FIlerAct or FilerAct is disabled
                                        ; by configuration.

        ADR     r0, Copy_command
        SWI     XWimp_CommandWindow
        Pull    "PC",VS

        ADR     r0, dataarea            ; Copy *copy command to dataarea
        ADR     r1, Copy_command
        BL      Copy_r1r0

        ADD     r1, r10, #ic_path       ; Append filename
        BL      Copy_r1r0

        MOV     r2, #" "                ; Change null terminator to space
        STRB    r2, [r0],#1
        ADR     r1, dest_directory
        BL      Copy_r1r0

; Append leafname
        MOV     r2, #"."
        STRB    r2, [r0],#1


        ADD     r3, r10, #ic_path
        MOV     r4,r3
11
        LDRB    r14,[r3],#1
        CMP     r14,#"."
        MOVEQ   r4,r3
        CMP     r14,#32
        BGT     %BT11

        MOV     r1, r4
        BL      Copy_r1r0


        MOV     r2, #" "                ; Append options
        STRB    r2, [r0],#1
        ADR     r1, copy_options
        BL      Copy_r1r0


        ADR     r0, dataarea            ; Do the copy
        SWI     XOS_CLI
        BVS     %FT20

        MOV     r0, #0
        SWI     XWimp_CommandWindow
        Pull    "PC",VS

        B       %BT10

20
        BL      ReportError
        MOV     r0,#-1
        SWI     XWimp_CommandWindow
        Pull    "PC"

FilerAction_command
        DCB     "Filer_action",0
Copy_command
        DCB     "Copy "
        ALIGN

        MakeErrorBlock  Pinboard_CopyRecursive
        ALIGN

IntMenuDeleted
        Push    "LR"
MenuDeleted
        ; Abort any pending drag operation
        LDR     R0, DragType
        TEQ     R0, #DragType_NoDrag
        BEQ     MenuNoDrag
        ; Abort the drag and restore input focus
        MOV     R0, #DragType_NoDrag
        STR     R0, DragType
        BL      Restore_Focus
        SWI     XDragASprite_Stop
MenuNoDrag

        LDR     r8,soft_selection_window
        CMP     r8,#0
        Debug   me,"Soft selection window is ",r8
        Pull    "PC",EQ

        ADRGT   r0,Pinboard_Selected
        ADRLT   r0,TinyDirs_Selected
        LDR     r1,[r0]
        SUBS    r1,r1,#1
        MOVMIS  r1,#0
        STREQ   r1,[r0]

        ADR     r1,dataarea
        STR     r8,[r1]
        LDR     r14,soft_selection_icon
        Debug   me,"icon is ",r14
        STR     r14,[r1,#4]
        MOV     r14,#0
        STR     r14,[r1,#8]
        CMP     r8,#0
        MOVLT   r14,#selected
        MOVGT   r14,#is_selected
        STR     r14,[r1,#12]
        SWI     XWimp_SetIconState
        Pull    "PC",VS

        ;------ We've de-selected the soft-selected icon, now reset all
        ; (FG)  related variables. No need to check _what_ was selected.

        MOV     r14,#0
        STR     r14,soft_selection_window
        STR     r14,soft_selection_icon         ; (FG)
        STR     r14,Pinboard_Selected           ; (FG)
        STR     r14,TinyDirs_Selected           ; (FG)
        STR     r14,Windows_Selected            ; (FG)

        Pull    "PC"


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle Message_IconizeAt

IconizeAt
        LDR     r0, [r1, #28]
        STR     r0, IconizeAtX

        LDR     r0, [r1, #32]
        STR     r0, IconizeAtY

        LDR     r0, [r1, #36]
        STR     r0, IconizeAtFlags

        Pull    "PC"


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle Message_Iconize

Iconize

        LDR     r0,Pinboard_options
        TST     r0,#PinboardOption_NoIconize
        Pull    "PC",NE

        LDR      R0, [r1,#ms_myref]
        STR      R0, [r1,#ms_yourref]
        MOV      R0, #19                ; Ack the message.
        LDR      R2, [r1,#ms_taskhandle]
        SWI      XWimp_SendMessage
        Pull     "PC",VS

        LDR      r3,[r1,#ms_data]
        STR      r3,iconized_window     ; Save window handle.

        LDR      r2,[r1,#ms_data+4]
        STR      r2,iconized_task       ; Save task id.

        MOV      r0,#0
        STRB     r0,[r1,#ms_data+8+10]  ; Truncate title string to 10 chars.

        ADD      r0,r1,#ms_data+8       ; Save the title string
        ADR      r1,window_title
        BL       Copy_r0r1

        ADR      r1,dataarea
        MOV      r0,#ms_data+4          ; Send WindowInfo message.
        STR      r0,[r1]                ; one word of data.
        MOV      r0,#0
        STR      r0,[r1,#ms_myref]
        STR      r0,[r1,#ms_yourref]
        LDR      r0,=Message_WindowInfo
        STR      r0,[r1,#ms_action]
        STR      r3,[r1,#ms_data]

        MOV      r0,#18                 ; Recorded message.
        SWI      XWimp_SendMessage

        Pull     "PC"

WindowInfo     ROUT

        Debug   ic,"Got WindowInfo"

        LDR     r0,[r1,#ms_size]
        CMP     r0,#24
        BGT     %FT01                ; Size > 24 this is a reply to my request.

        LDR     r0,[r1,#ms_taskhandle]
        LDR     r2,mytaskhandle

        CMP     r0,r2                ;  Did I send it ?
        LDRNE   r0,Pinboard_options
        ORRNE   r0,r0,#PinboardOption_NoIconize
        STRNE   r0,Pinboard_options
        BLNE    ReopenWindows        ; Someone else sent it , reopen all windows

        Pull    "PC"

01
        MOV      r0,#0
        STRB     r0,[r1,#ms_data+16+10]       ; Force terminator after 10 chars.
        ADD      r0,r1,#ms_data+16            ; Save the title string
        ADR      r1,window_title
        BL       Copy_r0r1

        ADR      r1,dataarea
        B        got_task_name                ; pretend it's a TaskNameIs message.

bounced_WindowInfo

        Debug    ic,"Bounced windowinfo"

        MOV       R0,#ms_data+4               ; Get task name (for sprite_name)
        STR       R0,[R1]
        MOV       R0,#0
        STR       r0,[r1,#ms_myref]
        STR       r0,[r1,#ms_yourref]
        LDR       r0,=Message_TaskNameRq
        STR       r0,[r1,#ms_action]
        LDR       R0,iconized_task
        STR       r0,[r1,#ms_data]
        MOV       r0,#17
        MOV       r2,#0                       ; Broadcast.
        SWI       XWimp_SendMessage

        Pull     "PC"

 [ iconise_to_iconbar
w_iconbar_flags DCD &1700310b
 ]
w_icon_flags    DCD &4000a50b
;w_icon_flags    DCD &4700A50B

icon_sprite   DCB  "ic_",0
default_icon  DCB  "ic_?",0

       ASSERT (?default_icon)<15

       ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; write_colour_valid
;
; Poke a colour validation string in

 [ technicolour_text
write_colour_valid
        ; r1 -> block
        ; r2 = foreground colour
        ; r3 = background colour
        Push    "r0,r2,lr"

        MOV     r0,#'C'
        STRB    r0,[r1],#1

        MOV     r0,r2,LSR #8
        MOV     r2,#10
        SWI     XOS_ConvertHex6

        MOV     r0,#'/'
        STRB    r0,[r1],#1

        MOV     r0,r3,LSR #8
        MOV     r2,#10
        SWI     XOS_ConvertHex6               ; creates part of a validation string Cbbggrr/bbggrr
                                              ; which requires Window Manager 3.98 or later
        Pull    "r0,r2,pc"

write_icon_valid_string
        ; r0 -> spritename
        ; r1 -> block to contain valid string
        Push    "r0-r3,lr"

        LDR     r2,foreground_colour
        LDR     r3,background_colour
        BL      write_colour_valid
        MOV     r2, r0
        ADR     r0, write_icon_selected
        BL      Copy_r0r1                     ; append some more validation
        MOV     r0, r2
        BL      Copy_r0r1                     ; now append the spritename

        Pull    "r0-r3,pc"

write_icon_selected
        DCB     "/////AAAAAA/000000;S",0
        ALIGN
 ]

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; got_task_name
;
; We've got a name for the window we're iconising.

got_task_name
       ; Allocate buffer space
       MOV      r3, #w_block_size
       MOV      r0, #ModHandReason_Claim
       SWI      XOS_Module
       Pull     "PC",VS

       ; Delete duplicate icons.
       Push     "r0-r11"
       LDR      r5, iconized_window
       BL       Int_close_window
       Pull     "r0-r11"

       ; Fill info
       MOV      r0,#-1
       STR      r0,[r2,#w_icon_handle]

 [ technicolour_text
       ADR      r0,icon_sprite
       ADD      r1,r2,#w_valid_string
       BL       write_icon_valid_string
 |
       MOV      r0,#"S"
       STR      r0,[r2,#w_sprite_prefix]

       ADR      r0,icon_sprite            ; copy sprite prefix
       ADD      r1,r2,#w_sprite_name
       BL       Copy_r0r1
 ]

       ADR      r1,dataarea
       ADD      r3,r1,#ms_data+8
       ADD      r0,r2,#w_sprite_name      ;  and task name.
       MOV      r4,#?icon_sprite-1

01
       LDRB     r5,[r3],#1
       CMP      r5,#&20                   ; Up to space or terminator.
       BLE      %FT02
       STRB     r5,[r0,r4]
       ADD      r4,r4,#1
       CMP      r4,#14                    ; or 13 characters.
       BLT      %BT01

02     MOV      r5,#0                     ; Store zero terminator.
       STRB     r5,[r0,r4]

       MOV     r11, r2

       ADD     r2,  r2,#w_sprite_name
       MOV     r0,  #SpriteReason_ReadSpriteSize
       SWI     XWimp_SpriteOp
       ADDVS   r1, r11, #w_sprite_name
       ADRVS   r0, default_icon
       BLVS    Copy_r0r1

       ; Read window info.
       ADR      r1,dataarea
       LDR      r0,iconized_window
       STR      r0,[r1]
       STR      r0,[r11,#w_window_handle]
       SWI      XWimp_GetWindowState

       ADD      r1,r1,#4
       LDMIA    r1,{r3-r8}
       Debug    ic,"window pos ",r3,r4,r5,r6,r7,r8
       ADD      r1,r11,#w_window_pos
       STMIA    r1,{r3-r8}

       Debug    ic,"window pos ",r3,r4,r5,r6,r7,r8

       LDR      r0,iconized_task
       STR      r0,[r11,#w_task]

       ADR      r0,window_title           ; Copy window title.
       ADD      r1,r11,#w_window_title
       BL       Copy_r0r1

       ; Open window with -3
       ADR      r1,dataarea
       MOV      r0,#-3
       STR      r0,[r1,#28]

       MOV      r0,#2     ; Open window
       LDR      r2,iconized_task
       SWI      XWimp_SendMessage

       Debug    ic,"Sent open request"


; Get position
 [ iconise_to_iconbar
       LDR      lr, IconizeAtFlags
       TST      lr, #IconizeAtFlag_ShiftCloseIcon
       BNE      %FT08
       LDR      lr, Pinboard_options
       TST      lr, #PinboardOption_IconiseToIconBar
       BNE      %FT00
08
 ]
       ; x co-ord
       LDR      r0,[r11,#w_window_pos]
       ADD      r0,r0,#grid_x_spacing :SHR: 1
       SUB      r0, r0, #34
       STR      r0,iconize_x

       ; y co-ord
       LDR      r1,[r11,#w_window_pos+12]
       SUB      r1,r1,#grid_y_spacing :SHR: 1
       STR      r1,iconize_y

       ; First see if shift+close was used to do the iconising. If so, ignore corner settings.
       LDR      r0, IconizeAtFlags
       TST      r0, #IconizeAtFlag_ShiftCloseIcon
       BNE      %FT09

       ; Are we using the corner settings? If so, get the position the icon will go in.
       TST      lr, #PinboardOption_UseWinToCorner
       Push     "lr"
       BLNE     get_iconise_position
       Pull     "lr"

       ; If using a corner, or the iconbar, then skip ahead.
       TST      lr, #PinboardOption_UseWinToCorner
       BNE      %FT00
       TST      lr, #PinboardOption_IconiseToIconBar
       BNE      %FT00

09     ; We're iconising to the pointer, either because this was set or because the iconising
       ; was done by Shift clicking on the close icon of a window.
       LDR      r0, IconizeAtX     ; If there's a value waiting from a Message_IconizeAt
       CMP      r0, #-1            ; then use that,
       BEQ      %FT00              ; otherwise use the default position (so skip ahead)
       STR      r0, iconize_x
       LDR      r0, IconizeAtY
       STR      r0, iconize_y

00
       ; Peform bounds check on iconize_x and iconize_y
       LDR      r0, iconize_x
       CMP      r0, #0
       MOVLT    r0, #0
       LDR      r1, Screen_x1
       SUB      r1, r1, #grid_x_spacing - 8
       CMP      r0, r1
       MOVGT    r0, r1
       STR      r0, iconize_x

       LDR      r0, iconize_y
       CMP      r0, #0
       MOVLT    r0, #0
       LDR      r1, Screen_y1
       SUB      r1, r1, #grid_y_spacing - 8
       CMP      r0, r1
       MOVGT    r0, r1
       STR      r0, iconize_y

       ; Reset the IconizeAt copy
       MOV     r0, #-1
       STR     r0, IconizeAtX
       STR     r0, IconizeAtY

       ADD     r2, r11, #w_sprite_name

       MOV     r0, #SpriteReason_ReadSpriteSize
       SWI     XWimp_SpriteOp

       ADD     r9,r11,#w_window_title
       ADD     r10,r11,#w_sprite_prefix

; Valid registers r6 = sprite mode, r3,r4 = sprite width,height, r9->icon name,r10->sprite name,r11->icon
; Adjust to get OS units
       MOVVC   r0, r6                          ; creation mode of sprite
       MOVVC   r1, #VduExt_XEigFactor
       SWIVC   XOS_ReadModeVariable
       MOVVC   r5, r3, LSL r2
       MOVVC   r3, #0
       MOVVC   r1, #VduExt_YEigFactor
       SWIVC   XOS_ReadModeVariable
       Pull    "PC",VS
       MOV     r6, r4, LSL r2
       ADD     r6, r6, #36
       MOV     r4, #0
       MOV     r3, #0

       ; Check length of name
       MOV     R0,#1
       MOV     R1,R9
       Push    "R2"
       MOV     R2,#0
       SWI     XWimp_TextOp
       Pull    "R2"
       CMP     R5,R0
       MOVLT   R5,R0

       ; Get flags and name
       ADR     r1, dataarea
       LDR     r0, backdrop_handle

 [ iconise_to_iconbar
       LDR     lr, Pinboard_options
       TST     lr, #PinboardOption_IconiseToIconBar
       SUBNE   r6, r6, #16
       MOVNE   r4, #-16
 ]

        STMIA   r1!, {r0,r3,r4,r5,r6}
 [ iconise_to_iconbar
        LDRNE   r6, w_iconbar_flags
        LDREQ   r6, w_icon_flags
 |
        LDR     r6, w_icon_flags
 ]
 [ technicolour_text
        ADD     r10, r11, #w_valid_string
 |
        ADD     r10, r11, #w_sprite_prefix
 ]
        MOV     r14, #32
        STMIA   r1!, {r6,r9,r10,r14}

        ; Create the icon
        ADR     r1,dataarea             ; create iconbar entry

 [ iconise_to_iconbar
        ; Deal with Iconise to Iconbar
        ; Ignore if Shift + Close clicked
        LDR     lr, IconizeAtFlags
        TST     lr, #IconizeAtFlag_ShiftCloseIcon
        BNE     %FT01

        ; Ignore if  not Iconise to Iconbar
        LDR     lr, Pinboard_options
        TST     lr, #PinboardOption_IconiseToIconBar
        BEQ     %FT01

        ; Okay, it's Iconise to Iconbar
        LDR     r0, Iconbar_Icons
        ADD     r0, r0, #1
        STR     r0, Iconbar_Icons
        MOV     r0, #-2
        STR     r0, [r1]
 [ technicolour_text
        ADD     r0,r11,#w_sprite_prefix
        STR     r0, [r1,#28]            ; change the validation string to skip the C command
 ]
        B       %FT10
01
 ]

        LDR     r0,backdrop_handle
        STR     r0,[r1],#4
        LDMIA   r1,{r3-r6}
        LDR     r9,iconize_y
        LDR     r8,icon_bar_height
        CMP     r8,r9
        MOVGT   r9,r8
        LDR     r8,iconize_x

        ; Check if we're iconising to the close icon
        LDR     r3, IconizeAtFlags
        TST     r3, #IconizeAtFlag_ShiftCloseIcon
        BNE     %FT02
        TSTEQ   lr, #PinboardOption_UseWinToCorner
        BEQ     %FT02

        ; We're iconising to a corner - centre icon.
        Push    "r0-r1"
        MOV     r3, r8
        MOV     r4, r9
        MOV     r0, #grid_x_spacing
        SUBS    r1, r0, r5
        ADDS    r3, r3, r1, ASR #1
        Pull    "r0-r1"
        B       %FT04

02      ; Tweak x positioning of the icon if we're iconising to the close icon
        Debug   ic,"r3 x y",r3,r8,r9
        ADD     r3,r3,r8
        SUBS    r3,r3,r5, LSR #1
        MOVCC   r3,#0
        ADD     r4,r4,r9

04
        ADD     r5,r3,r5
        ADD     r6,r6,r9
        LDR     r8,w_icon_flags
        Debug   ic,"Lock to grid ",r3
        ;BL      lock_to_grid
        Debug   ic,"Lock to grid returned"

        STMIA   r1,{r3-r6,r8}
        Debug   ic,"Bounding box is ",r3,r4,r5,r6
        SUB     r1,r1,#4
10
        LDR     r8, [r1]
        Push    "r8"          ; stick the window handle (backdrop or iconbar) on stack

        SWI     XWimp_CreateIcon
        ADRVC   r1,dataarea
        STRVC   r0,[r1,#4]
        MOVVC   r8,#0
        STRVC   r8,[r1,#8]
        STRVC   r8,[r1,#12]
        MOVVC   r8,r0
        SWIVC   XWimp_SetIconState

        Pull    "r0"                     ; get window handle back off stack.
        STR     r0, [r11, #w_icon_id]    ; store window handle
        STRVC   r8, [r11,#w_icon_handle] ; store icon handle

        ; Reset IconizeAtFlags
        MOV     r0, #Default_IconizeAtFlags
        STR     r0, IconizeAtFlags

        ; (r11=Pointer) Link to list.
        LDR     r0,iconized_ptr
        STR     r0,[r11,#w_next_ptr]
        CMP     r0,#0                    ; If next exsists link to it.
        STRNE   r11,[r0,#w_prev_ptr]
        STR     r11,iconized_ptr         ;  First on the list.
        MOV     r0,#0
        STR     r0,[r11,#w_prev_ptr]     ; No previous.

       ; Install icon (Zoom ?)
 [ drag_on_iconise
        ADR     r1, dataarea
        LDR     r2, [r1, #4]            ; Get back icon handle.
        SWI     XWimp_GetPointerInfo
        LDMVCIA r1, {r10,r11}           ; Get current pointer position.
        BVC     Iconized_Drag           ; Start drag.
 ]
        LDR     r0, Window_Icons
        ADD     r0, r0, #1
        STR     r0, Window_Icons
        Pull    "PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Int_close_window

Int_close_window                  ; fake close window ( r5=handle )
        Push    "LR"
        B       close_window_entry


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; close_window

close_window
        LDR     R0, [r1,#ms_myref]
        STR     R0, [r1,#ms_yourref]
        MOV     R0, #19                ; Ack the message.
        LDR     R2, [r1,#ms_taskhandle]
        SWI     XWimp_SendMessage
        Pull    "PC",VS

        LDR     r5,[r1,#ms_data]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; close_window_entry

close_window_entry
        Push    "R7"

        Debug   ic,"window closed ",r5

01      BL      find_window

        CMP     r7,#0
        Pull    "R7,PC",EQ
        BL      delete_window      ; Preserves r5.
        B       %BT01


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; close_task

close_task

        LDR     r5,[r1,#ms_taskhandle]

        Debug   ic,"Task close ",r5

01      BL      find_task
        CMP     r7,#0
        Pull    "PC",EQ
        BL      delete_window      ; Preserves r5.
        B       %BT01


        LNK     Help.s
@


4.14
log
@Avoid unnecessary remainder calculations. Fix wonky "snap to grid" logic.
Detail:
  s/Drag, s/Messages, s/StartLoop - Avoid unnecessary remainder calculation in DivRem macro
  s/Icons - Fix grid coordinate rounding when tidying to the left
Admin:
  Tested on Cortex-A15


Version 1.00. Tagged as 'Pinboard-1_00'
@
text
@a89 3
        TEQ     r0, #Message_SaveDesktop
        BEQ     DesktopSave

@


4.13
log
@Fix for not recalculating pixel translation on backdrop tile going from G256 to C256 (or G16 to C16) mode specifier
The change in Pinboard-0_95 to get eigen factor rescaling right included a quick exit when neither the bpp nor eigen factors had changed.
However, changing from a greyscale to colour 8bpp or 4bpp mode falls fouls of this (since bpp and eigen are the same), so the backdrop sprite was not recached.
There was code to collect Message_PaletteChanged, however the Wimp hasn't sent this round since pre RISC OS 3.60, additionally the mode change code was manually disabling it (not required since Message_ModeChange was never accompanied by Message_PaletteChange according to PRM3-230). This has been switched out.
Now, the 'have I already done this sprite' flag includes the bpp and eigen factors plus a 13 bit hash of the desktop palette.

Version 0.96. Tagged as 'Pinboard-0_96'
@
text
@d269 1
a269 1
        DivRem  r9, r8, r4, r10         ; r9 = column number of initiating icon
@


4.12
log
@Fix for patchy tiled backdrops on changing to non EX1/EY1 mode
Pinboard keeps a note of the mode (from OS_Byte 135) that the backdrop sprite tile was last cached in, to avoid having to recache it all the time. However, the comparison fails when the mode specifier block (ie. when OS_Byte 135 is not reporting a numeric screen mode) is static since although the mode might have changed Pinboard would not think it had and hence not recache the sprite.
The result is a patchy desktop, for example changing from EX1/EY1 to EX0/EY0 would leave a quadrant arrangement of 1 redrawn patch and 3 not redrawn.
Backdrop.s:
Line 151 onwards, when a mode specifier is used, build a magic mode word combining EX EY and BPP (the 3 parameters the cache sprite function cares about), as a stronger check.
Tail.s:
Line 130 onwards, calculate the iconbar height properly (previously used 134 pixels for EY0 modes, 1 too high, leading to a thin strip of background colour above the iconbar.
Other changes
 - Use sprite area offset names from Hdr:Sprites rather than magic numbers
 - Use OS_Byte reasons from Hdr:OsBytes
 - Use "file.s" style names in LNK commands
 - Move BadOptions/NotASprite error blocks to avoid range error when assembling debug versions
 - true and false for objasm {TRUE} and {FALSE}

Version 0.95. Tagged as 'Pinboard-0_95'
@
text
@d43 1
d47 1
a47 1

@


4.11
log
@Shade "Configure..." when boot was unsuccessful.
When BootResources$Path is unset the option to run the configure plugin is no longer available.
Shared a "Filer_Run " string in 3x places.
Replaced most occurrences of calling XOS_ReadModeVariable of the current mode's XEig and YEig factors to use the cached copy sitting unloved in the workspace. Should thrash less during redraw.

Version 0.93. Tagged as 'Pinboard-0_93'
@
text
@d438 1
a438 1
        MOV     r0,#ReadCMOS
@


4.10
log
@Replace magic numbers with sumbols from header files for OS_ calls.
Same binary as 0.92, not tagged.
@
text
@d998 4
a1001 4
        LDR     lr, Pinboard_options
        TST     lr, #PinboardOption_IconiseToIconBar
        SUBNE   r6, r6, #16
        MOVNE   r4, #-16
d1109 12
a1120 12
       ; Reset IconizeAtFlags
       MOV     r0, #Default_IconizeAtFlags
       STR     r0, IconizeAtFlags

       ; (r11=Pointer) Link to list.
       LDR      r0,iconized_ptr
       STR      r0,[r11,#w_next_ptr]
       CMP      r0,#0                    ; If next exsists link to it.
       STRNE    r11,[r0,#w_prev_ptr]
       STR      r11,iconized_ptr         ;  First on the list.
       MOV      r0,#0
       STR      r0,[r11,#w_prev_ptr]     ; No previous.
d1130 4
a1133 4
       LDR      r0, Window_Icons
       ADD      r0, r0, #1
       STR      r0, Window_Icons
       Pull     "PC"
d1148 6
a1153 6
        LDR      R0, [r1,#ms_myref]
        STR      R0, [r1,#ms_yourref]
        MOV      R0, #19                ; Ack the message.
        LDR      R2, [r1,#ms_taskhandle]
        SWI      XWimp_SendMessage
        Pull     "PC",VS
@


4.9
log
@Fixed so that it builds. There was a PC-relative LDR out-of-range error.

Version 0.91. Tagged as 'Pinboard-0_91'
@
text
@d130 1
a130 1
        MOV     r0,#37                  ; Canonicalise path
d165 1
a165 1
        MOV     r0,#37                  ; Canonicalise path
@


4.8
log
@  Add Message_ToggleBackdrop to allow the backdrop to be moved to front or back.
Detail:
  The Message_ToggleBackdrop has been introduced by ROL in one of their Select
  releases. In order to bring the RISC OS 5 API closer the ROL branch this
  changeset aims to add this message to RO5.

  Applications can broadcast Message_ToggleBackdrop to request that the backdrop
  application moves the backdrop. The message can be used to move the backdrop
  to the front, the back, toggle it or to get notified of the backdrop's
  current position.

  After the backdrop has been moved, this message is sent back to the
  application to notify it of the backdrop's new position.

  Message_ToggleBackdrop &400D1:
     +0  = 24 (Message size)
     +4  = Backdrop controlling application
     +8  = My reference number
     +12 = Your reference number
     +16 = &400D1 (Message_ToggleBackdrop)
     +20 = Flags (if not present, assumed 0)
             b0-1  = type of toggle
                      0 = toggle
                      1 = front
                      2 = back
                      3 = notify of status
             other = reserved
Admin:
  Tested on RO 5.16
Author:
  Fred Graute

Version 0.90. Tagged as 'Pinboard-0_90'
@
text
@d187 57
a1189 57
ToggleBackdrop  ROUT

        MOV     R0,#User_Message_Acknowledge ; =19
        LDR     R3,[R1,#ms_myref]       ;
        LDR     R2,[R1,#ms_taskhandle]  ;
        STR     R3,[R1,#ms_yourref]     ;
        SWI     XWimp_SendMessage       ; acknowledge message

        STR     R2,[R1,#ms_taskhandle]  ; restore as ack screwed it
        LDR     R0,[R1,#ms_size]        ; get message size
        LDR     R2,[R1,#ms_data]        ; get flags
        CMP     R0,#&18                 ; is msg >= 24 bytes, ie flags present?
        MOVLT   R2,#0                   ; if not, assume 0

        ADD     R1,R1,#128              ; use upper half of wimp data block
        LDR     R0,backdrop_handle      ; get window handle of backdrop
        STR     R0,[R1,#u_handle]       ; pop window handle in block
        SWI     XWimp_GetWindowState    ; get state of backdrop
        LDR     R14,[R1,#u_bhandle]     ; get handle to open behind
        CMP     R14,#-1                 ; is it -1, ie backdrop at front?
        MOVNE   R14,#-2                 ; if not, pretend it's at back

        AND     R2,R2,#3                ; isolate bottom two bits of flags
        ADD     R2,R2,#1                ; convert flags to something that's
        AND     R2,R2,#3                ; easier to use (0,1,2,3 -> 1,2,3,0)
        CMP     R2,#1                   ;
        EOREQ   R14,R14,#1              ; toggle -2 <-> -1
        RSBHI   R14,R2,#1               ; convert %10 to -1, %11 to -2
        BLO     %FT01                   ; just notify, skip code to move backdrop

        CMP     R14,#-1                 ; is backdrop to be moved to front?
        LDR     R0,[R1,#u_wflags]       ; get flags for backdrop window
        BICEQ   R0,R0,#wf_backwindow    ; if to front, clear background stack bit
        ORRNE   R0,R0,#wf_backwindow    ; if to back, set background stack bit
        STR     R0,[R1,#u_wflags]       ; write flags for backdrop window back
        STR     R14,[R1,#u_bhandle]     ; write handle to open behind back

        LDR     R2,taskidentifier       ; magic word "TASK"
        MOV     R3,#-1                  ; -1 =>
        MOV     R4,#1                   ; bit 0 set =>
        SWI     XWimp_OpenWindow        ; open backdrop window in new position

01      SUB     R1,R1,#128              ; reset to start of wimp data block
        MOV     R2,#&18                 ; message size
        RSB     R3,R14,#0               ;
        LDR     R4,[R1,#ms_myref]       ;
        STR     R2,[R1,#ms_size]        ;
        STR     R3,[R1,#ms_data]        ;
        STR     R4,[R1,#ms_yourref]     ;

        MOV     R0,#User_Message        ; =17
        LDR     R2,[R1,#ms_taskhandle]  ;
        SWI     XWimp_SendMessage       ;

        Pull    "PC"


@


4.7
log
@  Merged in changes from Castle
Detail:
  iconise of window with longer name could cause disappearing window
  if window (file) name longer than 10 chars or so the icon 'vanishes' when
  iconised. s.messages line 989 kad a LSR of a negative(possibly) number. This
  left a top bit set value in the bounding box.. oversize!
  changing to ASR kept the maths at this point valid
Admin:
  Not tested

Version 0.88. Tagged as 'Pinboard-0_88'
@
text
@d96 4
d1133 57
@


4.6
log
@  Enable soft-selection of iconized window icons.
Detail:
  Clicking Menu over a filer-icon will cause it to be soft-selected if
  no icons have been selected. For iconized window icons this doesn't
  work.
  This changeset removes this limitation. The Selection -> Remove menu
  item will be corectly shaded (for iconized-icons) or unshaded (for
  filer-icons).
Admin:
  Tested on Iyonix RO5.11
Notes:
  Changes by Fred Graute.

Version 0.84. Tagged as 'Pinboard-0_84'
@
text
@d1009 1
a1009 1
        ADDS    r3, r3, r1, LSR #1
@


4.5
log
@  Different way of doing escape-aborts-drag implementation
Detail:
  Although the previous check-in works, it uses EventV to trap escape key
  press events. This mechanism doesn't stop them from being passed on to
  whoever has input focus (e.g. a task window).

  The new way to do things is to grab input focus when a drag starts and
  to restore it (if possible) when the drag f we abort the drag (and restore focus). All other keys
  are passed on to the Wimp.

  The side-effect is that any window which has focus will temporarily lose
  focus for the duration of a Pinboard drag op I think we can
  live with that.
Admin:
  Tested on Iyonix and works fine. Now, if only the Filer did this, too...

Version 0.83. Tagged as 'Pinboard-0_83'
@
text
@d549 3
d554 4
@


4.4
log
@Commented out "proginfo" string,no longer used.
Prefixed the pin and addtinydir commands that get saved in the
pinboard file with "X " so your pinboard setup continues even if a file
is no longer available.ROL did this with a new XPin command,not taken.
Merged changes from ROL to allow the icon text to be an arbitary colour
though this can be switched out with "technicolour_text" for the
purists.
Help entry added to the pinboard selection submenu,this will be greyed
out except when
 it's an app
 and it has a !help file
 and it is the only object selected
like the filer does.
Updated messages file accordingly.
Menu clicking on the "save pinboard settings" OK button no longer saves
the file,and adjust clicking keeps the menu tree open
 -> fixes bug report from 1998,now removed from "Status" file
Saveas template resized to match !Edit.
Fixed problem of select dragging a file to an app leaving the icon
selected (due to two conditional MOV R0's being followed by an
unconditional one for some reason).
 -> fixes bug report from 1998,now removed from "Status" file
Tweaked a few CMP#0 BLT's to test specifically for the iconbar handle.
The bug report in "Status" about bits of filenames being left on the
pinboard can be bodged by popping an ADD r0,r0,#16 after the XWimp_TextOp
in s.buffered but I've not done this yet.

Version 0.78. Tagged as 'Pinboard-0_78'
@
text
@d270 1
d272 1
a275 1

d512 10
d647 1
a647 1
                                              
d649 9
a657 9
        STR       R0,[R1]                     
        MOV       R0,#0                       
        STR       r0,[r1,#ms_myref]           
        STR       r0,[r1,#ms_yourref]         
        LDR       r0,=Message_TaskNameRq      
        STR       r0,[r1,#ms_action]          
        LDR       R0,iconized_task            
        STR       r0,[r1,#ms_data]            
        MOV       r0,#17                      
d659 3
a661 3
        SWI       XWimp_SendMessage           
                                              
        Pull     "PC"                         
@


4.3
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.76. Tagged as 'Pinboard-0_76'
@
text
@d57 4
a91 1

d263 3
d288 1
d631 1
a631 1
        B        got_task_name        ; pretend it's a TaskNameIs message.
d636 15
a650 15

        MOV       R0,#ms_data+4           ; Get task name (for sprite_name)
        STR       R0,[R1]
        MOV       R0,#0
        STR       r0,[r1,#ms_myref]
        STR       r0,[r1,#ms_yourref]
        LDR       r0,=Message_TaskNameRq
        STR       r0,[r1,#ms_action]
        LDR       R0,iconized_task
        STR       r0,[r1,#ms_data]
        MOV       r0,#17
        MOV       r2,#0                   ; Broadcast.
        SWI       XWimp_SendMessage

        Pull     "PC"
d665 48
d729 1
a729 1
       BL       int_close_window
d736 5
d747 1
d751 1
a751 1
       ADD      r0,r2,#w_sprite_name       ;  and task name.
d932 3
d936 1
d961 4
d1058 1
a1058 1
; int_close_window
d1060 1
a1060 1
int_close_window                  ; fake close window ( r5=handle )
@


4.2
log
@Ursula branch merged.
Added inclusion of Machine header for new CMOS header
Moved to srccommit.
Templates contain hardwired version/date information which is a long
  way out of date.  This has not been fixed in this checkin.

Version 0.75. Tagged as 'Pinboard-0_75'
@
text
@d189 1
a189 1
  [ truncate_filenames        
d209 1
a209 1
        ADD     r2, r0, r6              ; new x2        
d244 1
a244 1
        MOVLT   r1, r5                 ;    and y1 = icon_bar_height       
d254 1
a254 1
                        
d548 2
a549 2
        STR     r0, IconizeAtFlags        
        
d773 1
a773 1
       
d805 1
a805 1
       
d889 1
a889 1
        
d908 1
a908 1
        
d933 1
a933 1
04        
d940 1
a940 1
        
d947 1
a947 1
                
d1017 1
a1017 1
        
d1042 1
a1042 1
        LNK     s.Help
@


4.1
log
@Initial revision
@
text
@d61 4
d179 1
d188 25
d224 28
d254 1
d258 2
a259 1
        Pull    "PC"
d536 20
d649 1
d658 6
d665 1
a665 2

;      Allocate buffer space
d671 1
a671 2
;      Delete duplicate icons.

d677 1
a677 2
;      Fill info

d714 1
a714 1
;      Read window info.
d736 1
a736 2
;      Open window with -3

d745 1
a746 1
       Debug    ic,"Sent open request"
a748 1

d750 3
d756 1
d758 1
a758 1

a759 1

d761 1
d764 1
a764 4
       Debug    ic,"X ",r0


       LDR      r0,[r11,#w_window_pos+4]
d768 27
a794 1
       Debug    ic,"Y", r1
d796 23
a829 1

d842 14
a855 25
; Check length of name
       MOV     r0, #0
01
        [ {FALSE}
        LDRB    r1,[r9,r0]
        ADD     r0, r0, #1
        CMP     r1,#0
        BGT     %BT01
        STRB    r3,[r9,r0]
        SUB     r8, r0, #1
        CMP     r5, r8, LSL#4
        MOVLT   r5, r8, LSL#4
        |
        MOV     R0,#1
        MOV     R1,R9
        Push    "R2"
        MOV     R2,#0
        SWI     XWimp_TextOp
        Pull    "R2"
        CMP     R5,R0
        MOVLT   R5,R0
        ]
; Get flags and name
        ADR     r1, dataarea
        LDR     r0, backdrop_handle
d875 1
a875 1
; Create the icon
d879 7
d888 10
a897 3
        MOVNE   r0, #-2
        STRNE   r0, [r1]
        BNE     %FT02
d908 19
d932 2
d938 1
a938 1
;        BL      lock_to_grid
d940 1
d944 4
a947 1
02
a955 1
        STRVC   r8, [r11,#w_icon_handle]
d957 7
d965 1
a965 2
;      (r11=Pointer) Link to list.

d970 1
a970 1
       STR      r11,iconized_ptr          ;  First on the list.
d972 1
a972 3
       STR      r0,[r11,#w_prev_ptr]      ; No previous.

;      Install icon (Zoom ?)
d974 1
d982 3
d987 4
d995 4
a999 1

d1009 4
d1017 1
d1019 1
d1025 4
d1040 1
@


4.1.4.1
log
@Added option to iconise windows to a corner
@
text
@a60 6
        [ Version >= 67
        LDR     r14, =Message_IconizeAt
        TEQ     r0, r14
        BEQ     IconizeAt
        ]

a475 13
IconizeAt

        ;MOV     r0, #7
        ;SWI     OS_WriteC
        LDR     r0, [r1, #28]
        STR     r0, IconizeAtX
        LDR     r0, [r1, #32]
        STR     r0, IconizeAtY        
        
        Pull    "PC"

filenamestring DCB "$.MB",0

a684 19

 [ Version >= 67
       TST      lr, #PinboardOption_UseWinToCorner
       BLNE     get_iconise_position

       TST      lr, #PinboardOption_UseWinToCorner
       BNE      %FT10
       TST      lr, #PinboardOption_IconiseToIconBar
       BNE      %FT10

       LDR      r0, IconizeAtX     ; If there's a value waiting from a Message_IconizeAt
       CMP      r0, #-1            ; then use that,
       BEQ      %FT10              ; otherwise use the default position (so skip ahead)
       STR      r0, iconize_x
       LDR      r0, IconizeAtY
       STR      r0, iconize_y
10       
 ]

a687 6
       [ Version >= 67
       MOV     r0, #-1
       STR     r0, IconizeAtX
       STR     r0, IconizeAtY
       ]

d763 1
a763 1
        BNE     %FT10
a773 14
        
 [ Version >=67
        TST     lr, #PinboardOption_UseWinToCorner
        BEQ     %FT02
        Push    "r0-r1"
        MOV     r3, r8
        MOV     r4, r9
        MOV     r0, #grid_x_spacing
        SUBS    r1, r0, r5
        ADDS    r3, r3, r1, LSR #1
        Pull    "r0-r1"
        B       %FT04
02
 ]
a778 2

04        
d783 1
a783 1
        ;BL      lock_to_grid
a784 1
        
d788 1
a788 6
10
        [ Version >= 67
        LDR     r8, [r1]
        Push    "r8"          ; stick the window handle (backdrop or iconbar) on stack
        ]
                
a796 6

        [ Version >= 67
        Pull    "r0"
        STR     r0, [r11, #w_icon_id]
        ]

a820 176

 [ Version >=67
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_iconise_position
;
; Decide where to put the icon for a window that's just been iconized.
;
; In: Nothing.
;
; Out: The memory locations iconise_x and iconise_y are set.
;      All regs preserved.

get_iconise_position ENTRY

        Push    "r0-r12"
        
        LDR     r2, Pinboard_options              ; Pinboard options
        ADR     r0, bounding_box                  ; Screen bouding box

        LDR     r1, [r0, #8]                      ; Decide of Left/Right positioning
        TST     r2, #PinboardOption_WinToCornerLR ; 0 = Left (EQ), 1 = Right (NE)
        MOVEQ   r3, #0
        SUBNE   r3, r1, #grid_x_spacing

        LDR     r1, [r0, #12]                     ; Decide on up/down positioning
        TST     r2, #PinboardOption_WinToCornerTB ; 0 = Top (EQ), 1 = Bottom (NE)
        SUBEQ   r4, r1, #grid_y_spacing
        LDRNE   r4, icon_bar_height
                 
        SUB     sp, sp, #48                       ; Increase stack - we'll use it for getting icon data

        ; Now loop through linked list of icons and see if they present a problem (occupy the space that
        ; our 'proposed' icon is going to use). If so, try another space. If not, then we can use the coords. 
        ; (Surely there's an easier way?)
        ; r2 = options
        ; r3 = iconize_x
        ; r4 = iconize_y
        ; r3-r6 = attempted bounding box
        ; r11 -> current iconized icon we're checking
        ; r10 -> bounding box of the icon we're checking
        
10 ; tryagain
        LDR     r11, iconized_ptr                 ; location of first icon data

20 ; nexticon
        CMP     r11, #0                           ; if pointer to icon data is <=0, then there's no more
        BLE     %FT86                             ; so the last values of r3, r4 are the right coords.
        LDR     r0, backdrop_handle
                                                  ; Get the bounding box of this icon
        STR     r0, [sp]
        LDR     r0, [r11, #w_icon_handle]
        STR     r0, [sp, #4]
        MOV     r1, sp
        SWI     Wimp_GetIconState
        ADD     r10, r1, #8                       ; r10 -> Bounding box

        ADD     r5, r3, #grid_x_spacing           ; make r3, r4, r5, r6 the proposed bounding box.
        ADD     r6, r4, #grid_y_spacing

        ; Check the proposed icon's left and right bounds against the current stored icon
        LDR     r7, [r10] 
        CMP     r5, r7                            ; Check proposed x2 <= icon x1
        BLE     %FT80                             ; If it is, then this icon presents no problems - try next
        LDR     r7, [r10, #8]
        CMP     r3, r7                            ; Check proposed x1 >= icon x2
        BGE     %FT80                             ; If it is, then this icon presents no problems - try next
        
        ; Check the proposed icon's top and bottom bounds against the current stored icon
        LDR     r7, [r10, #4]
        CMP     r6, r7                            ; Check proposed y2 <= icon y1
        BLE     %FT80                             ; If it is, then this icon present no problems.
        LDR     r7, [r10, #12]
        CMP     r4, r7                            ; Check proposed y1 >= store y2
        BGE     %FT80                             ; If it is, then this icon presents no problems

        ; The bounds checks have failed - the stored icon overlaps with our proposed one.
        ; So, we've got to move onto the next possible slot on the pinboard.
        TST     r2, #PinboardOption_WinToCornerHV ; 0 = Stack horizontally (EQ), 1 = Stack vertically (NE)
        BEQ     %FT70                             ; if we're stacking horizontally, skip to different code.
        
        ; Right, we're stacking vertically - move y up/down by one icon
        TST     r2, #PinboardOption_WinToCornerTB ; 0 = move down (EQ), 1 = move up (NE)
        ADDNE   r4, r4, #grid_y_spacing           
        SUBEQ   r4, r4, #grid_y_spacing

        ; Check we're still on the screen
        LDR     r0, icon_bar_height
        CMP     r4, r0                            
        BLT     %FT66                             ; We're off the bottom - move x and reset y.
        ADR     r0, bounding_box
        LDR     r1, [r0, #12]
        SUB     r1, r1, #grid_y_spacing
        CMP     r4, r1
        BGT     %FT66                             ; We're off the top - moce x and reset y.
        
        ; We are still on the screen, so now go back and check and see if this new position is okay.
        B       %BT10

66 ; move_x
        ; we've reached the top/bottom of a vertical stack, so move x left/right by one icon
        TST     r2, #PinboardOption_WinToCornerLR ; 0 = move right (EQ), 1 = move left (NE)
        SUBNES  r3, r3, #grid_x_spacing
        ADDEQ   r3, r3, #grid_x_spacing

        ; reset y to the top/bottom
        ADR     r0, bounding_box
        LDR     r1, [r0, #12]
        TST     r2, #PinboardOption_WinToCornerTB ; 0 = top (EQ), 1 = bottom (NE)
        LDRNE   r4, icon_bar_height
        SUBEQ   r4, r1, #grid_y_spacing

        ; has x reached the screen edge (ie. screen full) ?
        CMP     r3, #0
        BLT     %FT84                            ; The screen is full
        LDR     r1, [r0, #8]
        CMP     r3, r1
        BLT     %BT10
        B       %FT84                             ; The screen is full

70 ; not_here_horiz
        ; we're stacking horizontally, so move x left/right by one icon
        TST     r2, #PinboardOption_WinToCornerLR ; 0 = left (EQ), 1 = right (NE)
        ADDEQ   r3, r3, #grid_x_spacing
        SUBNES  r3, r3, #grid_x_spacing
        
        ; Check we're still on the screen
        CMP     r3, #0
        BLT     %FT76                             ; We're off the left - move y and reset x.
        ADR     r0, bounding_box
        LDR     r1, [r0, #8]
        SUB     r1, r1, #grid_x_spacing
        CMP     r3, r1
        BGT     %FT76                             ; We're off the right - move y and reset x.
        
        ; We are still on the screen, so now go back and check and see if this new position is okay.
        B       %BT10
        
76 ; move_y
        ; we've reached the edge of a horizontal stack, so move y up/down by one icon
        TST     r2, #PinboardOption_WinToCornerTB ; 0 = move down (EQ), 1 = move up (NE)
        ADDNE   r4, r4, #grid_y_spacing
        SUBEQS  r4, r4, #grid_y_spacing
        
        ; reset x to the left/right
        ADR     r0, bounding_box
        LDR     r1, [r0, #8]
        TST     r2, #PinboardOption_WinToCornerLR ; 0 = left (EQ), 1 = right (NE)
        MOVEQ   r3, #0
        SUBNE   r3, r1, #grid_x_spacing
        
        ; has y reached the screen edge (ie. screen full) ?
        CMP     r4, #0
        BLT     %FT84                             ; The screen is full
        LDR     r1, [r0, #12]
        CMP     r4, r1
        BLT     %BT10
        B       %FT84                             ; The screen is full

80 ; try_next
        LDR     r11, [r11, #w_next_ptr]
        B       %BT20                             ; Next icon - go back and check it

84 ; screen_full
        B       %FT88
 
86 ; got_one
        STR     r3, iconize_x
        STR     r4, iconize_y
                
88 ; exit
        ADD     sp, sp, #48
        Pull    "r0-r12"
        EXIT
 ]


a839 1
        
a840 1

@


4.1.4.2
log
@Improved consistency of files/windows, plus JPEG backdrops
@
text
@d483 1
a706 1
       Push     "lr"
a707 1
       Pull     "lr"
a710 1
       
a892 3
int_close_window                  ; fake close window ( r5=handle )
        Push    "LR"
        B       close_window_entry
d894 2
a895 39
close_window

        LDR      R0, [r1,#ms_myref]
        STR      R0, [r1,#ms_yourref]
        MOV      R0, #19                ; Ack the message.
        LDR      R2, [r1,#ms_taskhandle]
        SWI      XWimp_SendMessage
        Pull     "PC",VS

        LDR     r5,[r1,#ms_data]

close_window_entry
        Push    "R7"

        Debug   ic,"window closed ",r5
        
01      BL      find_window

        CMP     r7,#0
        Pull    "R7,PC",EQ
        BL      delete_window      ; Preserves r5.
        B       %BT01

close_task

        LDR     r5,[r1,#ms_taskhandle]

        Debug   ic,"Task close ",r5

01      BL      find_task
        CMP     r7,#0
        Pull    "PC",EQ
        BL      delete_window      ; Preserves r5.
        B       %BT01



 [ Version >= 67
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
a898 3
; The process involves choosing a location, then searching first the window list, then the
; file list, to see if the space is occupied. If it is, then we move to the next space
; (dependent on PinboardOption_WinToCorner...) and check through each list again.
d902 1
a902 1
; Out: The memory locations iconise_x and iconise_y are set to the position for the icon.
d908 3
d912 2
a913 7
        LDR     r2, Pinboard_options                ; Pinboard options
        ORR     r2, r2, #PinboardFlag_UseWindowList ; Start with the window list
        STR     r2, Pinboard_options
        ADR     r0, bounding_box                    ; Screen bouding box

        LDR     r1, [r0, #8]                        ; Decide on initial left/right positioning
        TST     r2, #PinboardOption_WinToCornerLR   ; 0 = Left (EQ), 1 = Right (NE)
d917 2
a918 2
        LDR     r1, [r0, #12]                       ; Decide on initial up/down positioning
        TST     r2, #PinboardOption_WinToCornerTB   ; 0 = Top (EQ), 1 = Bottom (NE)
d922 1
a922 1
        SUB     sp, sp, #48                         ; Increase stack - we'll use it for getting icon data
d935 1
a935 9
        ORR     r2, r2, #PinboardFlag_UseWindowList ; reset the list we're using to the window_list
        STR     r2, Pinboard_options
        LDR     r11, iconized_ptr                   ; location of first icon data
        CMP     r11, #0                             ; check there's actuallly icons in this list
        BNE     %FT20
        
        BIC     r2, r2, #PinboardFlag_UseWindowList ; There weren't any icons in the window_list
        STR     r2, Pinboard_options                ; so move to the file list.
        LDR     r11, Icon_list
d938 12
a949 8
        CMP     r11, #0                             ; check for the end of the list
        BEQ     %FT86
        MOV     r9, sp
        BL      get_next_icon_bbox                  ; Get the next bounding box
        CMP     r10, #0
        BEQ     %FT80                               ; if bbox -> 0, icon was not on backdrop - go to next
        
        ADD     r5, r3, #grid_x_spacing             ; make r3, r4, r5, r6 the proposed bounding box.
d954 2
a955 2
        CMP     r5, r7                              ; Check proposed x2 <= icon x1
        BLE     %FT80                               ; If it is, then this icon presents no problems - try next
d957 2
a958 2
        CMP     r3, r7                              ; Check proposed x1 >= icon x2
        BGE     %FT80                               ; If it is, then this icon presents no problems - try next
d962 2
a963 2
        CMP     r6, r7                              ; Check proposed y2 <= icon y1
        BLE     %FT80                               ; If it is, then this icon present no problems.
d965 2
a966 2
        CMP     r4, r7                              ; Check proposed y1 >= store y2
        BGE     %FT80                               ; If it is, then this icon presents no problems
a969 112
        BL  find_next_x_and_y
        BNE %FT84
        B   %BT10
        
80 ; try_next
        BL      get_next_icon_block
        B       %BT20                               ; Next icon - go back and check it

84 ; screen_full
        B       %FT88
 
86 ; got_one
        STR     r3, iconize_x
        STR     r4, iconize_y
                
88 ; exit
        ADD     sp, sp, #48
        Pull    "r0-r12"
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_next_icon_box
;
; Given a pointer to a data block, find the icon's bounding box.
; PinboardFlag_UseWindowList sets if the block is in the window or file list
;
; In: r2 = Pinboard_options
;     r11 -> icon data block
;     r9  -> 40 byte block of temporary memory (typically stack)
;
; Out: r10 -> bounding box (which will be 16 bytes within the 40 bytes)
;             if r10 is zero, icon is not on backdrop.
;      r0, r1 corrupted

get_next_icon_bbox ENTRY

        MOV     r10, #0        
        TST     r2, #PinboardFlag_UseWindowList ; Is the data -> by r9 in the window or file list?
        BNE     %FT20

10      ; find the icon handle from the file icon list
        LDR     r0, [r11, #ic_icon]
        B       %FT30
        
20      ; find the icon handle from the window icon list
        LDR     r0, backdrop_handle
        LDR     r1, [r11, #w_icon_id]
        CMP     r0, r1
        EXIT    NE                              ; icon not on backdrop - exit
        LDR     r0, [r11, #w_icon_handle]

30      ; found an icon handle - get it's bounding box
        STR     r0, [r9, #4]
        LDR     r0, backdrop_handle
        STR     r0, [r9]
        MOV     r1, r9
        SWI     Wimp_GetIconState
        ADD     r10, r1, #8
        
        EXIT        


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_next_icon_block
;
; Given an icon data block, find the next icon in the linked list. Includes
; both file icon list and window icon list. PinboardFlag_UseWindowList
; indicates if we are currently on the window list (set) or file list
; (clear). If we've reached the end of the window list, we'll move to
; the file list, but not vice-versa.
;
; In:  r2 = Pinboard_options
;      r11 -> icon data block
;
; Out: r10 -> bounding box (which will be 16 bytes within the 40 bytes)
;      r0, r1 corrupted

get_next_icon_block ENTRY

        TST     r2, #PinboardFlag_UseWindowList
        LDRNE   r11, [r11, #w_next_ptr]    ; if iconised window
        LDREQ   r11, [r11, #ic_next]       ; if file icon
        CMP     r11, #0
        EXIT    NE
        
        TST     r2, #PinboardFlag_UseWindowList
        EXIT    EQ                         ; if this is the file list, we can go no further
        
        BIC     r2, r2, #PinboardFlag_UseWindowList
        STR     r2, Pinboard_options
        LDR     r11, Icon_list
        
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; find_next_x_and_y
;
; What are x and y co-ordinates of the next spot on the grid?
;
; In: r2 = pinboard options
;     r3 = x co-ord.
;     r4 = y co-ord.
;
; Out: r3, r4 = x and y co-ordinates
;      NE     = Screen full
;      EQ     = Found new position (in r3, r4)
;      r0, r1 = corrupted.

find_next_x_and_y ENTRY

        ; Which way are we stacking?
d971 1
a971 1
        BEQ     %FT20                             ; if we're stacking horizontally, skip to different code.
d981 1
a981 1
        BLT     %FT16                             ; We're off the bottom - move x and reset y.
d986 1
a986 1
        BGT     %FT16                             ; We're off the top - moce x and reset y.
d989 1
a989 1
        B       %FT30
d991 1
a991 1
16 ; move_x
d1006 1
a1006 2
        BLT     %F40
        
d1009 2
a1010 2
        BLT     %FT30
        B       %FT40
d1012 1
a1012 1
20 ; not_here_horiz
d1020 1
a1020 1
        BLT     %FT26                             ; We're off the left - move y and reset x.
d1025 1
a1025 1
        BGT     %FT26                             ; We're off the right - move y and reset x.
d1028 1
a1028 1
        B       %FT30
d1030 1
a1030 1
26 ; move_y
d1045 1
a1045 1
        BLT     %FT40
d1048 2
a1049 2
        BLT     %FT30
        B       %FT40
d1051 3
a1053 1
30 ; exit_check_okay
d1055 10
a1064 2
        MOV     r0, #24
        CMP     r0, #24
d1066 1
a1067 1
40 ; exit_screen_full
d1069 38
a1106 4
        MOV     r0, #24
        CMP     r0, #23
        EXIT
 ]
@


4.1.4.3
log
@Windows, as well as files, can be selected, plus new menu structure and options
@
text
@d61 1
d65 1
a199 28
        ; Subtract grid_y_spacing from each y co-ord.
        SUB     r1, r1, #grid_y_spacing
        SUB     r3, r3, #grid_y_spacing

        ; Ensure box isn't off screen
        Push    "r4, r5"
        LDR     r5, Screen_x1
        SUB     r4, r2, r0
        CMP     r0, #0                 ; if x1<0
        MOVLT   r2, r4                 ;   then x2 = bbox_width
        MOVLT   r0, #0                 ;    and x1 = 0
        CMP     r2, r5                 ; if x2>screen_width
        SUBGT   r0, r5, r4             ;   then x1 = screen_width - bbox_width
        MOVGT   r2, r5                 ;    and x2 = screen-width

        LDR     r5, icon_bar_height
        SUB     r5, r5, #grid_y_spacing
        SUB     r4, r3, r1
        CMP     r1, r5                 ; if y1<icon_bar_height
        ADDLT   r3, r5, r4             ;   then y2 = icon_bar_height + bbox_height
        MOVLT   r1, r5                 ;    and y1 = icon_bar_height       
        LDR     r5, Screen_y1
        SUB     r5, r5, #grid_y_spacing
        CMP     r3, r5                 ; if y2>screen_height
        SUBGT   r1, r5, r4             ;   then y1 = screen_height - bbox_height
        MOVGT   r3, r5                 ;    and y2 = screen_height
        Pull    "r4, r5"

a201 1
                        
d205 1
a205 2
        EXIT

a586 1
;w_icon_flags    DCD &4700A50B
a892 4

       LDR      r0, Window_Icons
       ADD      r0, r0, #1
       STR      r0, Window_Icons
@


4.1.4.4
log
@Fixed bug which can cause Pinboard to die when dragging icons to other apps
@
text
@d232 1
a232 1
        Pull    "pc"
@


4.1.4.5
log
@Removed Info option on TinyDirs menu.
Updated interactive help messages.
Shift+Click on close icon now ALWAYS iconises the window underneath the icon
(old behaviour), while a click on iconise button iconises according to the
IconiseTo corner.
@
text
@d511 2
d516 1
a516 3
        STR     r0, IconizeAtY
        LDR     r0, [r1, #36]
        STR     r0, IconizeAtFlags        
d624 1
d626 1
a626 7
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; got_task_name
;
; We've got a name for the window we're iconising.

got_task_name
       ; Allocate buffer space
d632 2
a633 1
       ; Delete duplicate icons.
d639 2
a640 1
       ; Fill info
d677 1
a677 1
       ; Read window info.
d699 2
a700 1
       ; Open window with -3
d709 1
d712 1
a713 1
; Get position
d727 1
d733 1
a733 6
       ; First see if shift+close was used to do the iconising. If so, ignore corner settings.
       LDR      r0, IconizeAtFlags
       TST      r0, #IconizeAtFlag_ShiftCloseIcon
       BNE      %FT09
       
       ; Are we using the corner settings? If so, get the position the icon will go in.
a738 1
       ; If using a corner, or the iconbar, then skip ahead.
d740 2
a741 1
       BNE      %FT00
d743 1
a743 1
       BNE      %FT00
a744 2
09     ; We're iconising to the pointer, either because this was set or because the iconising
       ; was done by Shift clicking on the close icon of a window.
d747 1
a747 1
       BEQ      %FT00              ; otherwise use the default position (so skip ahead)
d751 2
d754 1
d756 2
a757 1
       ; Reset the IconizeAt copy
d761 1
d773 1
d786 25
a810 14

       ; Check length of name
       MOV     R0,#1
       MOV     R1,R9
       Push    "R2"
       MOV     R2,#0
       SWI     XWimp_TextOp
       Pull    "R2"
       CMP     R5,R0
       MOVLT   R5,R0

       ; Get flags and name
       ADR     r1, dataarea
       LDR     r0, backdrop_handle
d830 1
a830 1
        ; Create the icon
d850 2
a851 5
        ; Check if we're iconising to the close icon
        LDR     r3, IconizeAtFlags
        TST     r3, #IconizeAtFlag_ShiftCloseIcon
        BNE     %FT02
        TSTEQ   lr, #PinboardOption_UseWinToCorner
a852 2

        ; We're iconising to a corner - centre icon.
d861 2
a862 2

02      ; Tweak x positioning of the icon if we're iconising to the close icon
d881 1
d884 1
d895 4
a898 3
        Pull    "r0"                     ; get window handle back off stack.
        STR     r0, [r11, #w_icon_id]    ; store window handle
        STRVC   r8, [r11,#w_icon_handle] ; store icon handle
d900 4
a903 3
       ; Reset IconizeAtFlags
       MOV     r0, #0
       STR     r0, IconizeAtFlags
a904 1
       ; (r11=Pointer) Link to list.
d909 1
a909 1
       STR      r11,iconized_ptr         ;  First on the list.
d911 3
a913 1
       STR      r0,[r11,#w_prev_ptr]     ; No previous.
a914 1
       ; Install icon (Zoom ?)
d922 1
a927 4

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; int_close_window

d932 1
a933 4
; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; close_window

close_window
a942 4

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; close_window_entry

a954 4

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; close_task

d968 2
a1073 1

d1259 1
@


4.1.4.6
log
@Bug fixes.
Turned off defaultbackdrop and UseECFforLCD. Only needed on A4.
Updated service call handling to use new Ursula tables.
@
text
@d211 1
a211 1
        MOVGT   r2, r5                 ;    and x2 = screen_width
@


4.1.4.7
log
@Fixed a couple of bugs.
Improved tidying code.
Filenames are now truncated.
@
text
@d973 291
@


4.1.4.8
log
@- If Shift+Click on close icon, then don't iconise to iconbar.
- Fixed bug in stacking of icons vertically from bottom of screen.
@
text
@a715 3
       LDR      lr, IconizeAtFlags
       TST      lr, #IconizeAtFlag_ShiftCloseIcon
       BNE      %FT08
a718 1
08
a823 4
        LDR     lr, IconizeAtFlags
        TST     lr, #IconizeAtFlag_ShiftCloseIcon
        BNE     %FT01

a828 1
01
@


4.1.4.9
log
@* If Ursula window manager not present, always iconises to close icon.
* Sorted problem with spacing of icons dragged from long filename dir viewers.
* If the co-ordinates for Message_IconizeAt put an icon off screen, it is
  pushed back on screen by Pinboard.
@
text
@a178 1

a186 25

  [ truncate_filenames        
        ; Shrink dragbox to size it will be on pinboard (ie. column width in
        ; dir viewers is likely to be greater than column width in pinboard)
        Push    "r6-r10"
        SUB     r8, r2, r0              ; What is width of drag box?
        DivRem  r9, r8, r4, r10         ; Divide this by column width (from FilerSelection message)...
        CMP     r8, #0                  ; (check for remainder)
        ADDGT   r9, r9, #1              ; ...to get number of columns.
        MOV     r10, #grid_x_spacing
        MUL     r6, r10, r9             ; Multiply this by Pinboard's column width to get new box width

        ; Now we move the box, so that the icon where the drag started (the initiating
        ; icon) appears underneath the pointer on the pinboard.
        LDR     r7, [r14, #44]          ; r7 = mouse x
        SUB     r8, r7, r0              ; r8 = mouse x - x1
        DivRem  r9, r8, r4, r10         ; r9 = column number of initiating icon
        MOV     r4, #grid_x_spacing     ; new item width
        MUL     r8, r9, r4
        SUB     r0, r7, r8              ; new x1 (nearly!)
        SUB     r0, r0, r4, LSR #1      ; minus half column width to centre gives new x1
        ADD     r2, r0, r6              ; new x2        
        Pull    "r6-r10"
  ]

a509 4

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle Message_IconizeAt

a512 1

a514 1

d520 1
a520 3

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Handle Message_Iconize
d724 1
a724 1
       ; x co-ord
d726 1
a727 1
       SUB      r0, r0, #34
d730 3
a732 1
       ; y co-ord
a763 19
       ; Peform bounds check on iconize_x and iconize_y
       LDR      r0, iconize_x
       CMP      r0, #0
       MOVLT    r0, #0
       LDR      r1, Screen_x1
       SUB      r1, r1, #grid_x_spacing
       CMP      r0, r1
       MOVGT    r0, r1
       STR      r0, iconize_x
       
       LDR      r0, iconize_y
       CMP      r0, #0
       MOVLT    r0, #0
       LDR      r1, Screen_y1
       SUB      r1, r1, #grid_y_spacing
       CMP      r0, r1
       MOVGT    r0, r1
       STR      r0, iconize_y

d902 1
a902 1
       MOV     r0, #Default_IconizeAtFlags
@


4.1.4.10
log
@Fixed bug introduced by last change.
@
text
@d801 1
a801 1
       SUB      r1, r1, #grid_x_spacing - 8
d810 1
a810 1
       SUB      r1, r1, #grid_y_spacing - 8
@


4.1.4.11
log
@When the only window icons are on the iconbar, grey out the 'Select all'
menu item.
File 'Status' added giving Pinboard status after RPC2 cancellation.
@
text
@a878 2
        ; Deal with Iconise to Iconbar
        ; Ignore if Shift + Close clicked
a882 1
        ; Ignore if  not Iconise to Iconbar
d885 3
a887 9
        BEQ     %FT01
        
        ; Okay, it's Iconise to Iconbar
        LDR     r0, Iconbar_Icons
        ADD     r0, r0, #1
        STR     r0, Iconbar_Icons
        MOV     r0, #-2
        STR     r0, [r1]
        B       %FT10
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

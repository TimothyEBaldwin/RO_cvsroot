head	4.79;
access;
symbols
	Wimp-5_62:4.79
	Wimp-5_61:4.79
	Wimp-5_60:4.79
	Wimp-5_59:4.79
	Wimp-5_58:4.78
	Wimp-5_57:4.77
	Wimp-5_56:4.76
	Wimp-5_55:4.75
	Wimp-5_54:4.74
	Wimp-5_53:4.74
	Wimp-5_52:4.74
	Wimp-5_51:4.73
	Wimp-5_50:4.72
	Wimp-5_49:4.71
	Wimp-5_48:4.71
	Wimp-5_47-file1ad:4.71
	Wimp-5_47:4.71
	Wimp-5_46:4.71
	Wimp-5_45:4.71
	Wimp-5_44:4.71
	Wimp-5_43:4.71
	Wimp-5_42:4.70
	Wimp-5_41:4.70
	Wimp-5_40:4.70
	Wimp-5_39:4.69
	Wimp-5_38:4.69
	Wimp-5_37:4.68
	Wimp-5_36:4.67
	Wimp-5_35:4.66
	Wimp-5_34:4.65
	Wimp-5_33:4.63
	Wimp-5_32:4.62
	Wimp-5_31:4.61
	Wimp-5_30:4.60
	Wimp-530-pre4:4.59
	Wimp-5_30-pre3:4.58
	Wimp-5_30-pre2:4.58
	Wimp-5_30-pre1:4.57
	Wimp-5_29:4.57
	Wimp-5_28:4.56
	Wimp-5_27:4.55
	Wimp-5_26:4.54
	Wimp-5_25:4.53
	Wimp-5_24:4.52
	Wimp-5_23:4.50
	Wimp-5_22:4.50
	Wimp-5_21:4.49
	Wimp-5_20:4.49
	Wimp-5_19:4.48
	Wimp-5_18:4.48
	Wimp-5_17:4.48
	Wimp-5_16:4.47
	Wimp-5_15:4.46
	Wimp-5_14:4.45
	Wimp-5_13:4.43
	Wimp-5_12:4.42
	Wimp-5_11:4.42
	Wimp-5_10:4.42
	Wimp-5_09:4.42
	Wimp-5_08:4.41
	Wimp-5_07:4.41
	Wimp-5_06:4.41
	Wimp-5_05:4.40
	Wimp-5_04:4.39
	Wimp-5_03:4.38
	Wimp-5_02:4.37
	Wimp-5_01:4.36
	Wimp-4_66-4_77_2_1:4.22.2.1
	bavison_Threads_dev:4.22.0.2
	bavison_Threads_dev_bp:4.22
	Wimp-5_00:4.36
	Wimp-4_100:4.36
	Wimp-4_99:4.36
	Wimp-4_98:4.36
	Wimp-4_97:4.36
	Wimp-4_96:4.36
	Wimp-4_95:4.36
	Wimp-4_94:4.36
	RO_5_07:4.35
	Wimp-4_93:4.35
	Wimp-4_92:4.35
	Wimp-4_91:4.35
	Wimp-4_90:4.35
	Wimp-4_89:4.35
	Wimp-4_88:4.34
	Wimp-4_87:4.33
	Wimp-4_86:4.33
	Wimp-4_85:4.33
	Wimp-4_84:4.31
	Wimp-4_83:4.30
	Wimp-4_82:4.30
	Wimp-4_81:4.29
	Wimp-4_80:4.29
	Wimp-4_79:4.28
	Wimp-4_78:4.28
	Wimp-4_77:4.27
	Wimp-4_76:4.26
	Wimp-4_75:4.25
	Wimp-4_74:4.25
	Wimp-4_73:4.25
	Wimp-4_72:4.25
	Wimp-4_71:4.25
	Wimp-4_70:4.25
	Wimp-4_69:4.25
	Wimp-4_68:4.24
	Wimp-4_67:4.23
	Wimp-4_66:4.22
	Wimp-4_65:4.22
	Wimp-4_64:4.22
	Wimp-4_63:4.21
	Wimp-4_62:4.20
	Wimp-4_61:4.20
	Wimp-4_60:4.20
	Wimp-4_59:4.20
	Wimp-4_58:4.20
	Wimp-4_36-4_46_2_6:4.17
	Wimp-4_57:4.20
	Alpnet_approved:4.17
	Wimp-4_36-4_46_2_5:4.17
	Wimp-4_56:4.19
	dellis_autobuild_BaseSW:4.19
	Wimp-4_36-4_46_2_4:4.17
	Wimp-4_36-4_46_2_3:4.17
	Wimp-4_55:4.19
	Wimp-4_54:4.19
	Wimp-4_36-4_46_2_2:4.17
	Wimp-4_53:4.19
	Wimp-4_36-4_46_2_1:4.17
	Bethany:4.17.0.2
	Wimp-4_52:4.19
	Wimp-4_51:4.19
	Wimp-4_50:4.19
	Wimp-4_49:4.19
	Wimp-4_48:4.19
	Wimp-4_47:4.19
	Wimp-4_46:4.18
	Wimp-4_45:4.18
	Wimp-4_44:4.18
	Wimp-4_43:4.18
	Wimp-4_42:4.17
	sbrodie_sedwards_16Mar2000:4.17
	Wimp-4_41:4.17
	Wimp-4_40:4.17
	Wimp-4_39:4.17
	Wimp-4_38:4.17
	Wimp-4_37:4.17
	Wimp-4_36:4.17
	Wimp-4_35:4.17
	Wimp-4_34:4.17
	Wimp-4_33:4.17
	Wimp-4_32:4.17
	Wimp-4_31:4.17
	dcotton_autobuild_BaseSW:4.25
	Wimp-4_30:4.17
	Wimp-4_29:4.17
	Wimp-4_28:4.17
	Wimp-4_27:4.17
	Wimp-4_26:4.17
	Wimp-4_25:4.17
	Wimp-4_24:4.17
	Wimp-4_23:4.16
	Wimp-4_22:4.15
	Wimp-4_21:4.15
	Wimp-4_20:4.15
	Wimp-4_19:4.15
	Wimp-4_18:4.14
	Wimp-4_17:4.14
	Wimp-4_16:4.14
	Wimp-4_15:4.14
	Wimp-4_14:4.14
	Wimp-4_13:4.14
	Wimp-4_12:4.13
	mstphens_UrsulaRiscPCBuild_20Nov98:4.5.2.19
	bavison_Wimp-4_11:4.13
	Ursula_RiscPC:4.5.2.19.0.2
	Wimp-4_11:4.13
	Wimp-4_10:4.12
	Wimp-4_09:4.11
	Wimp-4_08:4.10
	Wimp-4_07:4.10
	Wimp-4_06:4.9
	Wimp-4_05:4.8
	Wimp-4_04:4.8
	bavison_Wimp-4_03_noshrinkables:4.8
	Wimp-4_03:4.8
	Wimp-4_02:4.8
	Ursula_merge:4.5.2.19
	bavison_Wimp-4_01:4.8
	Wimp-4_01:4.8
	nicke_Wimp_3_96M:4.1.7.8
	bavison_Wimp-4_00_TRUNK:4.6
	bavison_Wimp-4_00:4.5.2.19
	nicke_Wimp_3_96:4.1.7.8
	mjrobert_Wimp_3_98:4.5.2.5
	rthornb_UrsulaBuild-19Aug1998:4.5.2.19
	UrsulaBuild_FinalSoftload:4.5.2.19
	bavison_Wimp-3_99t:4.5.2.19
	rthornb_UrsulaBuild-12Aug1998:4.5.2.19
	bavison_Wimp-3_99s:4.5.2.19
	aglover_UrsulaBuild-05Aug1998:4.5.2.19
	bavison_Wimp-3_99r:4.5.2.19
	rthornb_UrsulaBuild-29Jul1998:4.5.2.18
	bavison_Wimp-3_99q:4.5.2.18
	jfarrell_NCWimp_3_96:4.1.7.8
	rthornb_UrsulaBuild-22Jul1998:4.5.2.17
	bavison_Wimp-3_99p:4.5.2.17
	rthornb_UrsulaBuild-15Jul1998:4.5.2.16
	bavison_Wimp-3_99o:4.5.2.16
	bavison_Wimp-3_99n:4.5.2.15
	rthornb_UrsulaBuild-07Jul1998:4.5.2.14
	bavison_Wimp-3_99m:4.5.2.14
	rthornb_UrsulaBuild-17Jun1998:4.5.2.13
	rthornb_UrsulaBuild-03Jun1998:4.5.2.13
	bavison_Wimp-3_99l:4.5.2.13
	rthornb_UrsulaBuild-27May1998:4.5.2.13
	rthornb_UrsulaBuild-21May1998:4.5.2.13
	bavison_Wimp-3_99k:4.5.2.13
	bavison_Wimp-3_99j:4.5.2.13
	bavison_Wimp-3_99i:4.5.2.13
	bavison_Wimp-3_99h:4.5.2.13
	rthornb_UrsulaBuild_01May1998:4.5.2.12
	bavison_Wimp_399g:4.5.2.12
	bavison_Wimp_399f:4.5.2.11
	afrost_NC2_Generic:4.1.7.7
	bavison_Wimp_399e:4.5.2.10
	bavison_Wimp_399d:4.5.2.9
	bavison_Wimp_399c:4.5.2.8
	Wimp_3_98:4.5.2.5
	kbracey_AW97:4.5.2.3
	Spinner_B20_2:4.1.7.7
	Spinner_19_3:4.1.7.6
	Spinner_B18:4.1.7.5
	Spinner_B17:4.1.7.5
	Spinner_B15:4.1.7.5
	Spinner_B14:4.1.7.4
	Spinner_B13:4.1.7.4
	Spinner_B12:4.1.7.3
	Spinner_B10:4.1.7.3
	Spin_merge_16May97:4.1.7.2
	Daytona:4.4.0.4
	Daytona_bp:4.4
	Ursula:4.5.0.2
	Ursula_bp:4.5
	Wimp_3_91:4.4
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.2
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2.2.7
	Spin_3Apr97:4.1.7.2
	ARTtmp:4.1.7.2.0.2
	Spin_merge:4.1.7.8
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.79
date	2017.07.24.20.32.59;	author jlee;	state Exp;
branches;
next	4.78;
commitid	JCLe8rNfSgjisw0A;

4.78
date	2017.04.11.21.55.23;	author rsprowson;	state Exp;
branches;
next	4.77;
commitid	0CryT2wkOiYOfaNz;

4.77
date	2017.04.08.19.44.08;	author rool;	state Exp;
branches;
next	4.76;
commitid	UUrozP4arUCMCLMz;

4.76
date	2017.03.25.20.07.27;	author jlee;	state Exp;
branches;
next	4.75;
commitid	9fJyMcIucZtGcYKz;

4.75
date	2016.09.16.08.27.02;	author rsprowson;	state Exp;
branches;
next	4.74;
commitid	DIegooz0OeJwpumz;

4.74
date	2016.05.08.16.48.42;	author jlee;	state Exp;
branches;
next	4.73;
commitid	xXPn2osqjffdqH5z;

4.73
date	2015.11.29.19.57.16;	author jlee;	state Exp;
branches;
next	4.72;
commitid	bEIfj6rhNgsJD1Ly;

4.72
date	2015.10.10.12.15.03;	author jlee;	state Exp;
branches;
next	4.71;
commitid	hTZlaaPZyibzGyEy;

4.71
date	2014.07.20.08.02.11;	author rsprowson;	state Exp;
branches;
next	4.70;
commitid	dYAocC6tl2fSE5Jx;

4.70
date	2014.04.18.14.20.34;	author jlee;	state Exp;
branches;
next	4.69;
commitid	pByMhPD26mc4Kaxx;

4.69
date	2014.03.27.23.23.05;	author jlee;	state Exp;
branches;
next	4.68;
commitid	peEWW3P1EQW1soux;

4.68
date	2014.03.09.17.39.42;	author jlee;	state Exp;
branches;
next	4.67;
commitid	jtr40bk3ymV683sx;

4.67
date	2014.03.01.22.42.58;	author jlee;	state Exp;
branches;
next	4.66;
commitid	KQ4bwdJetbz443rx;

4.66
date	2014.01.01.19.47.57;	author jlee;	state Exp;
branches;
next	4.65;
commitid	LFYgvVGTUEWBZrjx;

4.65
date	2013.11.30.13.41.35;	author jlee;	state Exp;
branches;
next	4.64;
commitid	IX1UPIonBUsJZifx;

4.64
date	2013.11.30.01.22.06;	author jlee;	state Exp;
branches;
next	4.63;
commitid	NHBF77CIMgF0Uefx;

4.63
date	2013.10.07.22.18.33;	author jlee;	state Exp;
branches;
next	4.62;
commitid	ATrKhtPyAxgGAp8x;

4.62
date	2013.09.08.18.53.29;	author rsprowson;	state Exp;
branches;
next	4.61;
commitid	46q23XZLtAc5oF4x;

4.61
date	2013.08.06.23.31.42;	author jlee;	state Exp;
branches;
next	4.60;
commitid	UbPZokvIlfdkZr0x;

4.60
date	2013.06.01.17.06.27;	author rsprowson;	state Exp;
branches;
next	4.59;
commitid	cfrGRVe6q9kCYVRw;

4.59
date	2013.06.01.16.46.08;	author rsprowson;	state Exp;
branches;
next	4.58;
commitid	JN66OJ2rTo2LQVRw;

4.58
date	2013.06.01.16.17.19;	author rsprowson;	state Exp;
branches;
next	4.57;
commitid	RcX32nE0liZuHVRw;

4.57
date	2013.05.21.20.36.47;	author rsprowson;	state Exp;
branches;
next	4.56;
commitid	qpZh6Cn3wGUpuxQw;

4.56
date	2013.05.18.21.30.38;	author rsprowson;	state Exp;
branches;
next	4.55;
commitid	iTES0NkvFxbcT9Qw;

4.55
date	2013.05.11.15.12.05;	author rsprowson;	state Exp;
branches;
next	4.54;
commitid	t0VXhGy6ECMh1ePw;

4.54
date	2013.05.09.20.53.30;	author rsprowson;	state Exp;
branches;
next	4.53;
commitid	AOn93h8uizkqYZOw;

4.53
date	2013.05.06.11.54.48;	author rsprowson;	state Exp;
branches;
next	4.52;
commitid	dyQdYmrTRpty5zOw;

4.52
date	2013.05.03.21.08.16;	author rsprowson;	state Exp;
branches;
next	4.51;
commitid	QS59VqQdUOQmfeOw;

4.51
date	2013.04.27.10.17.33;	author rsprowson;	state Exp;
branches;
next	4.50;
commitid	qlaYPAdsRZtaQoNw;

4.50
date	2013.04.10.20.48.44;	author rsprowson;	state Exp;
branches;
next	4.49;
commitid	oyotsfYRPfGzSgLw;

4.49
date	2013.03.28.08.07.32;	author rsprowson;	state Exp;
branches;
next	4.48;
commitid	6IoKYZf9tBXk5xJw;

4.48
date	2012.07.16.21.02.39;	author rsprowson;	state Exp;
branches;
next	4.47;
commitid	LDMZUNbd2Uj2zPcw;

4.47
date	2012.06.24.17.54.05;	author rsprowson;	state Exp;
branches;
next	4.46;
commitid	DcNZ4Jj5yRyneZ9w;

4.46
date	2012.06.23.09.22.25;	author rsprowson;	state Exp;
branches;
next	4.45;
commitid	EU9dc3pmPjF0rO9w;

4.45
date	2012.03.10.08.57.27;	author rsprowson;	state Exp;
branches;
next	4.44;
commitid	Nd0Kg1yDdhpdFjWv;

4.44
date	2012.01.23.08.03.50;	author rsprowson;	state Exp;
branches;
next	4.43;
commitid	6P5Pgy6PliwZSgQv;

4.43
date	2011.08.04.20.33.30;	author jlee;	state Exp;
branches;
next	4.42;
commitid	gzFhtZcn753Zyeuv;

4.42
date	2010.11.26.18.47.52;	author jlee;	state Exp;
branches;
next	4.41;

4.41
date	2009.06.11.20.57.38;	author bavison;	state Exp;
branches;
next	4.40;

4.40
date	2009.04.20.09.30.07;	author jballance;	state Exp;
branches;
next	4.39;

4.39
date	2008.09.10.15.49.10;	author srevill;	state Exp;
branches;
next	4.38;

4.38
date	2008.09.10.15.47.58;	author srevill;	state Exp;
branches;
next	4.37;

4.37
date	2008.09.10.15.47.14;	author srevill;	state Exp;
branches;
next	4.36;

4.36
date	2005.01.17.13.38.30;	author bavison;	state Exp;
branches;
next	4.35;

4.35
date	2003.02.28.16.09.32;	author bavison;	state Exp;
branches;
next	4.34;

4.34
date	2003.02.04.14.22.21;	author bavison;	state Exp;
branches;
next	4.33;

4.33
date	2003.01.20.14.16.27;	author bavison;	state Exp;
branches;
next	4.32;

4.32
date	2003.01.17.19.35.23;	author bavison;	state Exp;
branches;
next	4.31;

4.31
date	2002.12.20.19.48.20;	author bavison;	state Exp;
branches;
next	4.30;

4.30
date	2002.12.05.19.28.11;	author bavison;	state Exp;
branches;
next	4.29;

4.29
date	2002.11.28.10.52.53;	author kbracey;	state Exp;
branches;
next	4.28;

4.28
date	2002.10.30.17.43.54;	author bavison;	state Exp;
branches;
next	4.27;

4.27
date	2002.10.25.15.34.25;	author bavison;	state Exp;
branches;
next	4.26;

4.26
date	2002.10.23.17.12.35;	author bavison;	state Exp;
branches;
next	4.25;

4.25
date	2001.09.14.21.27.15;	author bavison;	state Exp;
branches;
next	4.24;

4.24
date	2001.06.26.13.31.53;	author ahodgkin;	state Exp;
branches;
next	4.23;

4.23
date	2001.05.29.11.44.06;	author bavison;	state Exp;
branches;
next	4.22;

4.22
date	2001.03.16.17.04.39;	author sbrodie;	state Exp;
branches
	4.22.2.1;
next	4.21;

4.21
date	2001.03.15.15.17.48;	author bavison;	state Exp;
branches;
next	4.20;

4.20
date	2000.10.20.12.44.26;	author bavison;	state Exp;
branches;
next	4.19;

4.19
date	2000.04.25.12.24.04;	author kbracey;	state Exp;
branches;
next	4.18;

4.18
date	2000.03.30.14.38.36;	author bavison;	state Exp;
branches;
next	4.17;

4.17
date	99.08.04.14.15.16;	author bavison;	state Exp;
branches;
next	4.16;

4.16
date	99.08.03.18.45.50;	author bavison;	state Exp;
branches;
next	4.15;

4.15
date	99.04.29.11.02.04;	author kbracey;	state Exp;
branches;
next	4.14;

4.14
date	98.11.27.20.56.10;	author bavison;	state Exp;
branches;
next	4.13;

4.13
date	98.11.09.12.49.12;	author bavison;	state Exp;
branches;
next	4.12;

4.12
date	98.10.29.13.18.55;	author bavison;	state Exp;
branches;
next	4.11;

4.11
date	98.10.23.15.48.24;	author bavison;	state Exp;
branches;
next	4.10;

4.10
date	98.10.21.14.50.40;	author bavison;	state Exp;
branches;
next	4.9;

4.9
date	98.10.20.16.21.20;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	98.09.30.12.52.24;	author kbracey;	state Exp;
branches;
next	4.7;

4.7
date	98.09.30.09.06.29;	author kbracey;	state Exp;
branches;
next	4.6;

4.6
date	98.09.18.16.14.10;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	97.05.16.13.40.54;	author kbracey;	state Exp;
branches
	4.5.2.1;
next	4.4;

4.4
date	97.05.07.17.01.33;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.14.15.32;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.13.13.24.59;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.48;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.22.2.1
date	2007.10.07.02.17.29;	author bavison;	state Exp;
branches;
next	;
commitid	NSavcPvbNd36pBAs;

4.5.2.1
date	97.05.21.16.37.43;	author kbracey;	state Exp;
branches;
next	4.5.2.2;

4.5.2.2
date	97.07.07.11.25.05;	author bavison;	state Exp;
branches;
next	4.5.2.3;

4.5.2.3
date	97.07.09.12.28.43;	author kbracey;	state Exp;
branches;
next	4.5.2.4;

4.5.2.4
date	97.10.21.14.01.30;	author mstphens;	state Exp;
branches;
next	4.5.2.5;

4.5.2.5
date	98.02.02.16.27.52;	author kbracey;	state Exp;
branches;
next	4.5.2.6;

4.5.2.6
date	98.03.10.16.11.34;	author bavison;	state Exp;
branches;
next	4.5.2.7;

4.5.2.7
date	98.03.26.19.31.36;	author bavison;	state Exp;
branches;
next	4.5.2.8;

4.5.2.8
date	98.04.03.19.38.34;	author bavison;	state Exp;
branches;
next	4.5.2.9;

4.5.2.9
date	98.04.07.17.53.44;	author bavison;	state Exp;
branches;
next	4.5.2.10;

4.5.2.10
date	98.04.17.16.54.08;	author bavison;	state Exp;
branches;
next	4.5.2.11;

4.5.2.11
date	98.04.21.16.57.55;	author bavison;	state Exp;
branches;
next	4.5.2.12;

4.5.2.12
date	98.04.27.15.18.35;	author bavison;	state Exp;
branches;
next	4.5.2.13;

4.5.2.13
date	98.05.08.11.43.35;	author bavison;	state Exp;
branches;
next	4.5.2.14;

4.5.2.14
date	98.07.03.17.59.46;	author bavison;	state Exp;
branches;
next	4.5.2.15;

4.5.2.15
date	98.07.13.14.10.47;	author bavison;	state Exp;
branches;
next	4.5.2.16;

4.5.2.16
date	98.07.14.16.34.12;	author bavison;	state Exp;
branches;
next	4.5.2.17;

4.5.2.17
date	98.07.21.16.14.47;	author bavison;	state Exp;
branches;
next	4.5.2.18;

4.5.2.18
date	98.07.28.17.11.07;	author bavison;	state Exp;
branches;
next	4.5.2.19;

4.5.2.19
date	98.08.05.09.09.31;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.30.48;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.33.01;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.24.40;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.22.12;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.14.10.23.50;	author kbracey;	state Exp;
branches
	4.1.7.2.2.1;
next	4.1.7.3;

4.1.7.3
date	97.04.30.16.50.37;	author scormie;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.06.11.10.04.45;	author scormie;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.07.02.11.02.08;	author arodger;	state Exp;
branches;
next	4.1.7.6;

4.1.7.6
date	97.07.25.13.27.30;	author jcoxhead;	state Exp;
branches;
next	4.1.7.7;

4.1.7.7
date	97.07.28.14.31.15;	author jcoxhead;	state Exp;
branches;
next	4.1.7.8;

4.1.7.8
date	98.06.25.08.58.43;	author scormie;	state Exp;
branches;
next	;

4.1.7.2.2.1
date	97.04.10.13.51.16;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.2;

4.1.7.2.2.2
date	97.04.14.12.21.58;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.3;

4.1.7.2.2.3
date	97.04.14.13.35.07;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.4;

4.1.7.2.2.4
date	97.04.14.21.56.00;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.5;

4.1.7.2.2.5
date	97.04.14.22.04.44;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.6;

4.1.7.2.2.6
date	97.04.16.10.35.36;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.7;

4.1.7.2.2.7
date	97.04.28.16.49.55;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.79
log
@Remove startup delay from power saving code
Detail:
  s/Wimp02 - Get rid of the magic ~30 second delay before the Portable_Speed/Portable_Idle power saving kicks in. The fast/slow thresholds are self-adjusting, and any non-null poll event will kick the system into high speed, so removing the startup delay isn't likely to have any adverse affect on desktop startup time.
  s/Wimp01 - MaxIdleEvents is now redundant, remove it
Admin:
  Tested on Raspberry Pi 3
  Should resolve issue reported on the forums where RPCEmu thrashes the hosts's CPU for 30 seconds after entering the desktop:
  https://www.riscosopen.org/forum/forums/10/topics/8990


Version 5.59. Tagged as 'Wimp-5_59'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

;;-----------------------------------------------------------------------------
;; Register names
;;-----------------------------------------------------------------------------

wsptr           RN      R12
userblk         RN      R11             ; rectlinks
handle          RN      R10             ; rectcoords
rectlinks       RN      R11             ; userblk
rectcoords      RN      R10             ; handle

y1              RN      R9
x1              RN      R8
y0              RN      R7
x0              RN      R6

cy1             RN      R5
cx1             RN      R4
cy0             RN      R3
cx0             RN      R2

ur_pollmask     RN      R0
ur_reasoncode   RN      R0
ur_userblk      RN      R1

                ^       0
u_cw0           #       0               ; start of create data
u_handle        #       4
u_ow0           #       0               ; start of open data
u_wax0          #       4
u_way0          #       4
u_wax1          #       4
u_way1          #       4
u_scx           #       4
u_scy           #       4
u_bhandle       #       4
u_ow1           #       0
              [ ChildWindows
u_flags         #       4               ; for supplying new window flags (new form of Wimp_OpenWindow)

                ^       u_ow1
              ]
u_scroll        #       8               ; x,y scroll-offsets (for user scroll)



;;-----------------------------------------------------------------------------
;; Macro definitions
;;-----------------------------------------------------------------------------

        MACRO
$lab    CheckAllWindows $message
$lab
      [ debugcheck :LAND: debug
        Push    "LR,PC"
        BL      checkallwindows
        BNE     %FT01
        Debug   check,"**** Bad window data found [ $message ] ****"
01
        LDR     R14,[SP,#4]
        TEQP    R14,#0
        LDR     LR,[SP],#8
      ]
        MEND

        MACRO
$lab    AddIcon $name,$pressable,$sprite,$width,$height
        int_AddIcon $name, $sprite, $width, $height
      [ "$pressable"=""
        [ "$sprite"=""
          int_AddIcon "p$name", $sprite, $width, $height
        |
          int_AddIcon "p$name", "p$sprite", $width, $height
        ]
      ]
        MEND

        MACRO
$lab    int_AddIcon $n,$s,$w,$h
      [ "$s"=""
        = "$n",0
      |
        = "$s",0
      ]
        ALIGN
      [ "$w"=""
        & &0
      |
        & :INDEX:$w
      ]
      [ "$h"=""
        & &0
      |
        & :INDEX:$h
      ]

tool_$n                         # 4

        MEND


        MACRO
$l      CallFilter $name,$nohandle
        Push    "R2,R11,wsptr"
 [ "$nohandle" = ""
        LDR     R2,taskhandle           ; handle of calling task
 ]
        ADRL    R11,$name.WP            ; address the vector table
        MOV     LR,PC                   ; setup suitable return address
        LDMIA   R11,{wsptr,PC}          ; call the filter
        Pull    "R2,R11,wsptr"          ; restore pushed registers
        MEND


        MACRO
$l      Hex     $rd,$rs
$l      SUB     $rd,$rs,#"0"
        CMP     $rd,#10
        SUBCS   $rd,$rd,#"A"-"9"-1
        MEND

        MACRO
$label  CLI     $command
$label
        Push    "R0,R14"
        ADR     R0,%FT01
        SWI     XOS_CLI
        B       %FT02
01
        DCB     "$command",13
        ALIGN
02
        Pull    "R0,R14"
        MEND

        MACRO
        pullx   $list
        LDMFD   R13,{$list}
        MEND

        MACRO
$lab    MyEntry $string
$lab
      [ debugtask2
        Push    "R0"
        TEQ     pc,pc
        LDRNE   R0, [sp, #(1 + 11 + 2 + 4) * 4]
        LDREQ   R0, [sp, #(1 + 11 + 2 + 3) * 4]   ; get return address from stack - skip:
                                                  ; 1 word:   for storing R0 here
                                                  ; 11 words: registers stored by generic Wimp SWI code
                                                  ; 2 words:  for Wimp re-entrancy
                                                  ; 1 word:   return address (in kernel SWI despatcher)
                                                  ; 1 word:   used by kernel - caller R9 (only for 26-bit OSes)
                                                  ; 1 word:   used by kernel - caller flags
                                                  ; 1 word:   used by kernel - SWI number
        SUB     R0, R0, #4 ; we actually want the previous instruction
        Debug   task2,"$string called by, from:",#taskhandle,R0
        Pull    "R0"
      ]
        MEND

        MACRO
$label  Plot    $pcode,$x,$y
$label
      [ "$x" <> "R1"
       [ "$y" = "R1"
        MOV     R2,R1
       ]
        MOV     R1,$x
      ]
      [ "$y" <> "R2" :LAND: "$y" <> "cx0" :LAND: :LNOT: ( "$x" <> "R1" :LAND: "$y" = "R1" )
        MOV     R2,$y
      ]
        MOV     R0,#$pcode
        SWI     XOS_Plot
        MEND

        MACRO
        Coords  $x,$y
        Coord   $x
        Coord   $y
        MEND

        GBLS    coordstemp

        MACRO
        Coord   $x
      [ "$x":LEFT:1 = "#"
coordstemp SETS "$x":RIGHT:(:LEN:"$x"-1)
        SWI     XOS_WriteI+($coordstemp:AND:&FF)
        SWI     XOS_WriteI+(($coordstemp:SHR:8):AND:&FF)
      |
        MOV     R0,$x
        SWI     XOS_WriteC
        MOV     R0,$x,LSR #8
        SWI     XOS_WriteC
      ]
        MEND

        MACRO
        Abs     $to,$from,$cc
        SUB$cc  $to,$from,#1
        MEND

        MACRO
$lab    Rel     $to,$from,$cc
$lab    ADD$cc  $to,$from,#1
        MEND

        MACRO
        SetRectPtrs
        ADRL    rectlinks,rlinks
        ADRL    rectcoords,rectarea
        MEND

        MACRO
        max     $a,$b
        CMP     $a,$b
        MOVLT   $a,$b
        MEND

        MACRO
        min     $a,$b
        CMP     $a,$b
        MOVGT   $a,$b
        MEND

        MACRO
        getxy   $r,$x,$y
        ADD     R14,rectcoords,$r,ASL #2
        LDMIA   R14,{$x.0,$y.0,$x.1,$y.1}
        MEND

        MACRO
        putxy   $r,$x,$y
        ADD     R14,rectcoords,$r,ASL #2
        STMIA   R14,{$x.0,$y.0,$x.1,$y.1}
        MEND

        MACRO
$label  ALIGNHASH  $m
      [ ((:INDEX:@@):AND:($m-1))<>0
$label  #          $m-((:INDEX:@@):AND:($m-1))
      |
$label  #          0
      ]
        MEND

        MACRO
        strw    $r1,$r2,$off
        STRB    $r1,[$r2,#$off]
        MOV     R14,$r1,LSR #8
        STRB    R14,[$r2,#$off+1]
        MEND

swf_alive       *       2_0001  ; bit set => check that task is alive
swf_checklimit  *       2_1000  ; if < checklimit, check R1 on entry

        MACRO
$lab    MySWI   $swiname
        ASSERT  MySWIBase+(.-jptable)/4 = $swiname
        GBLA    xflg_$swicnt
      [ (("$lab":CC:" "):LEFT:1)="x"
xflg_$swicnt    SETA    0         ; task doesn't have to be initialised
      |
xflg_$swicnt    SETA    swf_alive ; swi not allowed unless task is initialised
      ]
      [ ((" ":CC:"$lab"):RIGHT:1)<>"p"     ; check pointer if "p" present
xflg_$swicnt    SETA    xflg_$swicnt + swf_checklimit
      ]
swicnt  SETA    swicnt+1
        B       SWI$swiname
        MEND

        MACRO
$lab    BreakPt
$lab    MOV     PC,#0
        MEND

;
; Entry: $reg = handle of task to page in
; Exit:  [taskhandle] = $reg
;        $reg, [flagword] = flags for task
;        userblk = R1 on entry to Wimp_Poll of this task
;

        MACRO
$lab    Task    $reg,$cc,$dbg
$lab
      [ debugsw
        B$cc    %FT01
        B       %FT02
01
        Debuga  sw,"$dbg: "
02
      ]
        STR$cc  $reg,newtaskhandle      ; copied to [taskhandle] by subroutine
        BL$cc   pageintask              ; may do memory paging
        MEND

;-----------------------------------------------------

        MACRO
$lab    Dump    $file,$reg,$size
        Push    "R0-R5,LR"
        MOV     R0,#OSFile_Save
        ADR     R1,%FT01
      [ $reg=sp
        ADD     R4,$reg,#7*4            ; skip stacked registers
      |
        MOV     R4,$reg
      ]
        ADD     R5,R4,#$size
        SWI     XOS_File
        CLRV                            ; just in case
        Pull    "R0-R5,LR"
        B       %FT02
01
        DCB     "$file",0
        ALIGN
02
        MEND

        MACRO
$label  MyXError   $errsym, $c1, $c2
$label  ADR$c1$c2  R0,ErrorBlock_$errsym
        BL$c1      ErrorLookup
        MEND

;;-----------------------------------------------------------------------------
;; Workspace allocation
;;-----------------------------------------------------------------------------

cr      *       13
lf      *       10

FALSE   *       0
TRUE    *       1

 [ RO4
;;-----------------------------------------------------------------------------
;; 3D Patch definitions
;;-----------------------------------------------------------------------------

					^	0
TileInfo_SpritePtr			#	4
TileInfo_SpriteAreaPtr			#	4
TileInfo_TranslationTablePtr		#	4
TileInfo_ScaleFactors			#	4*4
TileInfo_Width				#	4
TileInfo_Height				#	4
TileInfo				*	@@

 [ false
					; default to everything on
ThreeDFlags_Default			*	&FFFFFFFF :AND::NOT: (ThreeDFlags_NoFontBlending :OR: ThreeDFlags_FullIconClipping)
 |
                                        ; you have to be kidding - use sane defaults
ThreeDFlags_Default                     *       ThreeDFlags_RemoveIconBackgrounds :OR: \
                                                ThreeDFlags_NoFontBlending
ThreeDFlags_All                         *       :NOT: ThreeDFlags_NoFontBlending
 ]
ThreeDFlags_Use3DBorders		*	1<<0	; note, flag bit positions are exposed via Wimp_ReadSysInfo
ThreeDFlags_UseAlternateMenuTexture	*	1<<1
ThreeDFlags_Fully3DIconBar		*	1<<2
ThreeDFlags_RemoveIconBackgrounds	*	1<<3
ThreeDFlags_TexturedMenus		*	1<<4
ThreeDFlags_NoIconBgInTransWindows	*	1<<5
ThreeDFlags_NoFontBlending		*	1<<6
ThreeDFlags_FullIconClipping		*	1<<7    ; we're just ignoring this flag
ThreeDFlags_WindowOutlineOver           *       1<<8

arrowIconWidth_No3D     *       24
arrowIconWidth_3D       *       32
 ]

No_Reason                       *       0
Redraw_Window_Request           *       1
Open_Window_Request             *       2
Close_Window_Request            *       3
Pointer_Leaving_Window          *       4
Pointer_Entering_Window         *       5
Mouse_Click                     *       6
User_Dragbox                    *       7
Key_Pressed                     *       8
Menu_Select                     *       9
Scroll_Request                  *       10
max_oldreason                   *       11      ; old apps don't know better

Lose_Caret                      *       11
Gain_Caret                      *       12
PollWord_NonZero                *       13      ; Wimp 2.23 onwards

User_Message                    *       17
User_Message_Recorded           *       18
User_Message_Acknowledge        *       19
max_reason                      *       20

 [ :LNOT: UTF8  ; we've done away with this kludge!
Key_PressedOldData              *       &FF     ; This is never seen outside the wimp.
 ]


border_normal                   *       0
border_slabout                  *       1
border_slabin                   *       2
border_ridge                    *       3
border_channel                  *       4
border_action                   *       5
border_defaultaction            *       6
border_editable                 *       7
border_max                      *       8


masknewcodes  *  ((1:SHL:max_reason)-1):EOR:((1:SHL:max_oldreason)-1)


null_bit          *     1 :SHL: No_Reason
redraw_bit        *     1 :SHL: Redraw_Window_Request
open_bit          *     1 :SHL: Open_Window_Request             ; can't be suppressed
close_bit         *     1 :SHL: Close_Window_Request            ; can't be suppressed
ptrleaving_bit    *     1 :SHL: Pointer_Leaving_Window
ptrentering_bit   *     1 :SHL: Pointer_Entering_Window
buttonchange_bit  *     1 :SHL: Mouse_Click
userdrag_bit      *     1 :SHL: User_Dragbox                    ; can't be suppressed
keypress_bit      *     1 :SHL: Key_Pressed
menuselect_bit    *     1 :SHL: Menu_Select                     ; can't be suppressed
scroll_bit        *     1 :SHL: Scroll_Request                  ; can't be suppressed
losecaret_bit     *     1 :SHL: Lose_Caret
gaincaret_bit     *     1 :SHL: Gain_Caret
pollword_bit      *     1 :SHL: PollWord_NonZero
message_bit       *     1 :SHL: User_Message
messagerec_bit    *     1 :SHL: User_Message_Recorded
messagebounce_bit *     1 :SHL: User_Message_Acknowledge

button_left     *       4
button_middle   *       2
button_right    *       1

mf_oldcoords    *       2_000000000001

mf_waitrepeat   *       2_000000001000
mf_waitclick    *       2_000000010000
mf_waitdrag     *       2_000000100000
mf_waitrelease  *       2_000001000000
mf_wait2clicks  *       2_000010000000
mf_waitremove   *       2_000100000000                  ; unhighlight if gone
mf_pending      *       2_000111111000
mf_pendingexceptdrag *  mf_pending:AND:(:NOT:mf_waitdrag)
mfb_setflags    *       3                       ; bit no. of pending bits


default_doubleclick_movelimit   *       32              ; chicago dist. (OS coords)
default_drag_movelimit          *       32
default_doubleclick_timelimit   *       10              ; centiseconds/10
default_drag_timelimit          *       default_doubleclick_timelimit / 2
default_automenudelay           *       10
default_menudragdelay           *       10
default_iconbarspeed            *       4   ; 200 OS units / sec
default_iconbaraccel            *       3   ; 100 OS units / sec^2
default_autofrontdelay          *       5
default_autoscrolldelay         *       5

drag_posn       *       1               ; system dragging routines
drag_size       *       2               ; all terminate when buttons released
drag_hscroll    *       3               ; ditto
drag_vscroll    *       4               ; ditto
drag_user       *       5               ; drag user box (fixed size)
drag_user2      *       6               ; drag user box (variable size)
drag_user3      *       7               ; drag point (nothing displayed)
drag_subr_posn  *       8               ; user subr, fixed size box
drag_subr_size  *       9               ; user subr, variable size box
drag_subr_posn2 *       10              ; doesn't stop when buttons released
drag_subr_size2 *       11              ; doesn't stop when buttons released
drag_scrollboth *       12              ; drag both scroll bars

 [ Autoscr
dragf_anchor    *       2_00000001      ; anchor rubber boxes to work area
dragf_clip      *       2_00000010      ; clip dragbox by window visible rectangles
 ]

getrect_firstrect       * 2_000001
getrect_updating        * 2_000010
getrect_redrawing       * 2_000100
getrect_noicons         * 2_001000
 [ Twitter
getrect_twitter         * 2_010000
 ]
 [ Autoscr
getrect_keepdragbox     * 2_100000
 ]

                        ^ -1
windowicon_workarea     # -1            ; -1
windowicon_back         # -1            ; -2
windowicon_close        # -1            ; -3
windowicon_title        # -1            ; -4
windowicon_toggle       # -1            ; -5
windowicon_up           # -1            ; -6
windowicon_verticalbar  # -1            ; -7    includes well area
windowicon_down         # -1            ; -8
windowicon_resize       # -1            ; -9
windowicon_left         # -1            ; -10
windowicon_horizbar     # -1            ; -11   includes well area
windowicon_right        # -1            ; -12
windowicon_outerframe   # -1            ; -13
windowicon_iconise	# -1		; -14
 [ PushBothBars
windowicon_bothbars     # -1            ; -15   for when both scrollbars are pushed in
 ]

iconposn_back           * 1
iconposn_close          * 2
iconposn_title          * 3
iconposn_toggle         * 4
iconposn_vscroll        * 5
iconposn_resize         * 6
iconposn_hscroll        * 7
iconposn_iconise	* 8

maxrects        *       512

bignum          *       &0FFFFFFF
nullptr         *       -1
nullptr2        *       -2

sz_scrleft      *       0
sz_scrright     *       1280
sz_scrbot2      *       0
sz_scrbot       *       0               ; was 96 (to allow for icon bar)
sz_scrtop       *       1024


; contents of task word if task is dead

task_unused       *     1:SHL:31


;------------------------;
; Task data block format ;
;------------------------;

                  ^     0
task_flagword     #     4                       ; flag word on entry to Poll
task_slotptr      #     4                       ; if switched, block of pages
task_wimpver      #     4                       ; R0 on entry to Wimp_Initialise
task_pollword     #     4                       ; R3 on entry to Wimp_Poll(Idle)
task_fpblock      #     4                       ; FP register save block
              [ Swapping
task_file         #     4                       ; File handle for swap file.
task_filename     #     4                       ; File name for swap file.
task_extent       #     4                       ; File extent / Slot size.
task_swapped      *     1:SHL:31                ; bit 31 set if swapped out.
              ]
task_windows      #     4                       ; Number of open windows.
task_priority     #     4                       ; Priority for swap out.
	      [ debugtask4
task_eventtime    #     4
              ]

task_messages     #     4                       ; messages list / =-1 for all
task_messagessize #     4                       ; size of the list

priority_iconbar  *     1:SHL:0   ;1
priority_old      *     1:SHL:1   ;2
priority_pollword *     1:SHL:2   ;4
priority_idle     *     1:SHL:3   ;8
priority_windows  *     1:SHL:4   ;16
priority_null     *     1:SHL:5   ;32
priority_top      *     1:SHL:20

task_environment  #     4*3*MaxEnvNumber        ; environment pointers
task_registers    #     4*17                    ; USR register set
task_vfpcontext   #     4                       ; VFPSupport context ID
task_datasize     #     0

; extra bits for Wimp_Poll - not stored in task_flagword

flag_fpsavebit    *     24                      ; save/restore FP registers
flag_pollfastbit  *     23                      ; look at poll word before messages
flag_pollwordbit  *     22                      ; there is a poll word in R3

; top bits of flag word are version number of task
; then the 'poll idle' bit, and then bits 0..19 (the event mask)

flag_versionbit   *     21                      ; one above flag_pollidle
flag_pollidlebit  *     20                      ; not part of version number

             ASSERT     max_reason <= flag_versionbit

flag_fpsave       *     1 :SHL: flag_fpsavebit
flag_pollfast     *     1 :SHL: flag_pollfastbit
flag_pollword     *     1 :SHL: flag_pollwordbit
flag_version      *     1 :SHL: flag_versionbit
flag_pollidle     *     1 :SHL: flag_pollidlebit

flag_allowed      *     flag_pollword :OR: flag_pollfast :OR: flag_fpsave

; structures for storing the messsge list

                ^       0               ; Linked list of messages.
ml_next         #       4               ; Next message
ml_prev         #       4               ; Previous message
ml_message      #       4               ; Message number.
ml_task         #       4               ; Pointer to first task on list.
ml_size         #       0

        ASSERT  ml_next=0

                ^       0               ; Linked list of tasks for each message.
mlt_next        #       4               ; Next task.
mlt_prev        #       4               ; Previous task on list.
mlt_task        #       4               ; Task handle.
mlt_size        #       0

        ASSERT  mlt_next=0

;------------------------;
; FP register save block ;
;------------------------;

                ^       0
fp_status       #       4
fp_reg0         #       12              ; stored in extended precision
fp_reg1         #       12
fp_reg2         #       12
fp_reg3         #       12
fp_reg4         #       12
fp_reg5         #       12
fp_reg6         #       12
fp_reg7         #       12
fp_size         #       0

F0      FN      0       ; register name symbols for FP register saving
F1      FN      1
F2      FN      2
F3      FN      3
F4      FN      4
F5      FN      5
F6      FN      6
F7      FN      7

C_runtime_status   *    &70000  ; suitable value for C run-time environment

;------------------------------;
; Rectangle list head pointers ;
;------------------------------;

                ^       0
freerects       #       4               ; rectangle data
invalidrects    #       4
              [ ChildWindows
oldinvalidrects #       4
              ]
oldwindowrects  #       4
windowrects     #       4
borderrects     #       4
torects         #       4
firstfreerect   #       0


                ^       0
icd_list        #       4               ; iconbar data
icd_middle      #       4
icd_extent      #       4
icd_width       #       4
icd_widthoffset #       4
icd_size        #       0

iconbargap      *       16
iconbarsepgap   *       64

                ^       0
icb_link        #       4               ; format of iconbar blocks in heap
icb_iconhandle  #       4
icb_taskhandle  #       4
icb_priority    #       4
icb_defwidth    #       4               ; default width
icb_size        #       0

sysflags_dragbits   *   2_00001111      ; enable instant dragging
sysflags_nobeep     *   2_00010000      ; disable beep on error
sysflags_offscreen  *   2_00100000      ; allow windows to go off-screen
sysflags_nobounds   *   2_01000000      ; allow windows to go off-screen in all directions.
sysflags_automenu   *   2_10000000      ; auto open submenus

; Two-way linked list definitions

        ; List header
                ^       0
lh_forwards     #       4
lh_indicator    #       4
lh_backwards    #       4
lh_size         #       0

        ; List link
                ^       0
ll_forwards     #       4
ll_backwards    #       4
ll_size         #       0


                ^       0,R12

wsorigin        #       0

tempworkspace   #       8*4             ; can be used easily

vduoutput       #       0
log2px          #       4
log2py          #       4
log2bpp         #       4
scrx0           #       4               ; converted to OS units
scry0           #       4
scrx1           #       4
scry1           #       4
textxsize       #       4               ; converted to OS units
textysize       #       4
modeflags       #       4
ncolour         #       4

rotatecounter   #       4               ; modified rotdotdash routine

romspr_suffix   #       4               ; <x><y> or "23"

dx              #       4
dy              #       4
dx_1            #       4
dy_1            #       4
xypixelsize     #       4

xborder         #       1
yborder         #       1
xborder1        #       1
yborder1        #       1
scroll_minlength    #   1
scroll_sidemargin   #   1
scroll_endmargin    #   1
scroll_mxborder     #   1
scroll_myborder     #   1
scroll_minxbar      #   1
scroll_minybar      #   1
fontforeground      #   1
fontbackground      #   1
continueflag    #       1               ; for changing extent while dragging
;fpemulator_flag #      1
iconbar_needs_rs    #   1
reentrancyflag  #       1
old_escape      #       1

       ALIGNHASH 4

 [ ThreeDPatch
truemenuborderfacecolour        # 4
truemenuborderoppcolour         # 4	; colours to use for menu borders
truewindowborderfacecolour      # 4
truewindowborderoppcolour	# 4	; colours to use for window borders
truewindowoutlinecolour         # 4     ; colour to use for window outline
 ]
 [ TrueIcon1
truefgcolour    #       4               ; for 24-bit colour icons
truebgcolour    #       4
 ]
 [ TrueIcon2
truebgcolour2   #       4               ; background colour for selected R5/R6 icons
truewellcolour  #       4               ; well colour for R6 icons
truefacecolour  #       4               ; 3D plinth colour facing light source
trueoppcolour   #       4               ; 3D plinth colour opposite light source
 [ TrueSelectionColours
trueselfgcolour	#	4		; selected foreground colour
trueselbgcolour	#	4		; selected background colour
 |
                #       4               ; reserved, in case 7 icon colours are specified!
 ]
 ]
redrawhandle    #       4
iconhandle      #       4
getrectflags    #       4
mouseflags      #       4
dragtype        #       4
draghandle      #       4
dragtask        #       4
dragoldx        #       4
dragoldy        #       4
dragx0          #       4
dragy0          #       4
dragx1          #       4
dragy1          #       4
dragoffx0       #       4
dragoffy0       #       4
dragoffx1       #       4
dragoffy1       #       4
dragwsptr       #       4               ; for user-supplied subroutines
dragsubr_on     #       4               ; for user-supplied subroutines
dragsubr_off    #       4               ; for user-supplied subroutines
dragsubr_move   #       4               ; for user-supplied subroutines
 [ Autoscr
dragflags       #       4               ; as passed to Wimp_DragBox in R3
 ]

drg_on          *       dragsubr_on   - dragwsptr
drg_off         *       dragsubr_off  - dragwsptr
drg_move        *       dragsubr_move - dragwsptr

wimpswiintercept        #       4       ; Wimp_Extend SWI intercepter
plotsprCB               #       4       ; backdrop tiling CB

        ALIGNHASH  16
; these have moved!
RAM_SWIEntry            #       12      ; 3 instructions for getting R12 back
OScopy_ChangeDynamic    #       4       ; this must follow immediately
longjumpSP              #       4       ; for cutting out the middle-man
ROMstart                #       4       ; ROM base address
ROMend                  #       4       ; ROM end address (inclusive)

        ALIGNHASH  16			; missing HASH! JRC 25 Jul 1997
clipx0          #       4
clipy0          #       4
clipx1          #       4
clipy1          #       4
spaceinicon     #       4               ; for displaying scrollable icons
text_width      #       4
text_y0         #       4
text_y1         #       4

temp_text_height #      4               ; 320nk textwidth now gets height
                                        ; as well as width (Wimp_04)
        [ slabinout
two_sprite_save #       4               ; save flags for two sprite icons
        ]
spritecachevalid #      0               ; uses same adr as below
auto_menu_flag  #       1               ; flag to keep track of auto width
autorepeating   #       1
        [ TrueIcon3
tinted_enable   #       1               ; 1:SHL:2 => tinting enabled for current set of toolsprites
tinted_window   #       1               ; 1:SHL:2 => tinting enabled for this window (ie nonstandard colours)
tinted_tool     #       1               ; 1:SHL:2 => tinting enabled for this tool
        |
work_back_colour #      1               ; background colour of current window
        ]
errorbox_open   #       1
        ALIGNHASH 4
        [ windowsprite
	 [ ThreeDPatch
ThreeDFlags	#	4
MenuIsColourMenu #	4
arrowIconWidth  #       1
        ALIGNHASH 4
	 |
tiling_sprite   #       4
tile_pixtable   #       4
tile_temptab    #       4
	 ]
        ]

oldclipx0       #       16              ; really x0,y0,x1,y1
hascaret        #       4               ; 0 ==> this icon has the caret
careticonaddr   #       4               ; address of icon with caret
caretx          #       4               ; caret posn relative to text itself
caretscrollx    #       4               ; text offset due to caret
areaCBptr       #       4
thisCBptr       #       4
spritename      #       4               ; ptr to sprite name (or header)
spritenamebuf   #       12              ; buffer for sprite name itself
validationstring  #     4
lengthflags     #       4
linespacing     #       4               ; for formattable text icons

xoffset         #       4               ; used by block-copy code
yoffset         #       4
oldlink         #       4
errorhandle     #       4               ; handle of error window
backwindow      #       4               ; handle of background window (if any)
backwindowhandle  #     4               ; handle of 'new' bg window
commandhandle   #       4               ; handle of 'command' window
commandflag     #       4               ; is a command window pending?

              [ :LNOT: NewErrorSystem
highlighted_colour      #       4       ; colour of OK box initially
unhighlighted_colour    #       4       ; colour of Cancel box initially
              ]

iconbarhandle   #       4
iconbarheight   #       4
iconbarleft     #       icd_size
iconbarright    #       icd_size

dotdashrate     *       5
initdotdash1    *       &FC
tempdotdash     *       ((initdotdash1:SHL:1):AND:&FF):OR:(initdotdash1:SHR:7)
initdotdash2    *       initdotdash1:EOR:tempdotdash
dragflag        #       1
dragaction      #       1
addtoolstolist  #       1               ; if non-zero then rotate and reset
dotdash1        #       1
dotdash2        #       1
dotdash         #       1
              [ :LNOT: TrueIcon3
titlecolour     #       1
              ]
repeatdelay     #       1               ; for auto-repeating icons
repeatrate      #       1
repeatlimit     #       1
gcolaction      #       1               ; used by Wimp_SetColour
sysflags        #       1               ; actions on moving windows (drag?)
memoryOK        #       1               ; flag for ChangeDynamicArea
modechanged     #       1               ; flag set on mode change
sprite_needsfactors  #  1               ; otherwise 1:1 scaling for this mode
sprite_needsfactors2 #  1               ; initial needsfactors guess
tsprite_needsfactors #  1               ; otherwise 1:1 scaling for this mode
tsprite_needsregen   #  1               ; need to recalculate the tool sprite pixtrans
selecttable_crit     #  1               ; ignore invalidate cache service calls if we're the cause
              [ ChildWindows
openspending    #       1               ; whether we're in the middle of a set of opens
              ]

        ALIGNHASH   4

oldfxstatus     #       13              ; *FX 4
                                        ; *FX 219
                                        ; *FX 221..228
                                        ; *FX 9..10
                                        ; *FX 229

              [ mousecache
recacheposn     #       1               ; non-zero then re-cache mouse information (x,y,b and time changed!)
              ]


        ALIGNHASH   4

                #       14*4            ; FD stack for Wimp_ReportError
errorstack      #       0

mousexpos       #       4
mouseypos       #       4
mousebuttons    #       4
              [ mousecache
mousetime       #       4
              ]
mouseblk        #       12
oldbuttons      #       4
mousexrel       #       4
mouseyrel       #       4
leftborder      #       4

pending_time    #       8
pending_x       #       4
pending_y       #       4
pending_buttons #       4
pending_window  #       4
pending_icon    #       4
timeblk         #       4               ; NB overlaid with next word!
temp            #       4

writeabledir    #       4               ; Direction of writeable icons.
reversedmenu    #       4               ; Flag for reversed menus.
externalcreate  #       4               ; True if menu is a result of a SWI call.
                [       outlinefont
systemfont      #       4               ; WIMP font handle, if claimed
symbolfont      #       4               ; WIMP symbol font handle, if claimed
currentfont     #       4               ; the font in force on entry to the WIMP, if needed
currentbg       #       4               ; its background colour
currentfg       #       4               ; its foreground colour
currentoffset   #       4               ; its colour offset
                ]

                [ SpritePriority
preferredpool   #       4               ; 1 => ROM, 0 => RAM
baseoflosprites #       4               ; base of low priority common sprite pool
baseofhisprites #       4               ; base of high priority common sprite pool
                ]
baseofsprites   #       4               ; base of common sprite pool (in RAM)
baseofromsprites  #     4               ; base of ROM sprite pool (in Resources:)

oldCAOpointer   #       4               ; used in OS_ChangeDynamicArea
handlerword     #       4               ; flag word ==> has handler changed?
parentquithandler   #   4               ; quit handler when application starts
freepool        #       4               ; stack of free pages (words)
freepoolbase    #       4               ; base address of free memory
freepoolpages   #       4               ; no of pages in free pool
pendingtask     #       4               ; task block pending deletion
                                        ; (in Wimp_Poll)
orig_memorylimit           #  4
orig_applicationspacesize  #  4
oldapplimit     #       4               ; used in ChangeDynamicArea code
pagesize        #       4
npages          #       4
slotsize        #       4               ; default slot size
currentmode     #       4

taskhandle      #       4               ; task currently paged-in
newtaskhandle   #       4               ; temporary location for pageintask
polltaskhandle  #       4               ; task handle on entry to Wimp_Poll
menutaskhandle  #       4               ; task handle of menu owner
nulltaskhandle  #       4               ; for cycling null events
singletaskhandle   #    4               ; single = taskhandle if 1-tasking
createwindowtaskhandle # 4              ; if <= 0, this is used to fill in w_taskhandle (else current taskhandle is used)
inithandle      #       4               ; "owner" slot if [freepool] = -1
taskcount       #       4               ; number of active tasks
tasknumber      #       4               ; global task number (monotonic)
taskSP          #       4               ; pointer into parent task stack
wimpquithandler #       12              ; how to get out of the Wimp!!
oldcallback     #       12              ; previous callback handler

flagword        #       4               ; flag word for current task
;latestwimp     #       4

ptrwindow       #       4               ; where the mouse was last seen
ptrtask         #       4               ; original owner of ptrwindow
borderlinked    #       4
isborderok      #       4
;ishscroll      #       4
;isvscroll      #       4
;heapfreeptr    #       4

headpointer     #       4               ; for message passing

sender          #       4
myref           #       4

maxmenus        *       8
whichmenu       #       4
menus_temporary #       4               ; if set, Wimp_Poll kills the menus
menuhandle      #       4
menuiconwidth   #       4
menuiconheight  #       4
menuiconspacing #       4
menuSP          #       4
menuhandles     #       4*maxmenus      ; handle of relevant window
menudata        #       4*maxmenus      ; ptrs to menu definitions (-1 if dial)
menuselections  #       4*maxmenus      ; selection index in each menu

crf_vdu5caret   *       &01000000
crf_invisible   *       &02000000
crf_usercolour  *       &04000000
crf_realcolour  *       &08000000

crb_colourshift *       16              ; use bits 16-23 for caret colour

caretdata       #       28              ; window,icon,x,y coords,height,index
                                        ; [caretdata+24]=caretscrollx (the definitive copy)
oldcaretwindow  #       4
menucaretwindow #       4
menucareticon   #       4
oldcaretdata    #       24              ; preserves caret data over menus
hotkeyptr       #       4               ; pointer into window stack
menuscrolly     #       4

 [ UseAMBControl
appspacesize    #       4               ; size of current application slot
 ]

 [ CnP
ghostcaretdata  #       28              ; window,icon,x,y coords,height,index
                                        ; [ghostcaretdata+24]=ghostcaretscrollx
selectionwindow #       4               ; external handle of the window that has the unshaded selection (or -1 if none)
font_cs_list    #       4               ; for pointing to font control sequence list during pushfontstring
 ]

 [ UTF8
keystring_buflen #      1               ; number of bytes in keystring_buffer (see below)
keyprocess_buflen #     1               ; number of bytes in keyprocess_buffer (see below)
keyin_buffer    #       6               ; filled from kernel buffer, for the sake of identifying incoming UTF-8 sequences
keyin_buflen    #       1               ; number of bytes in keyin_buffer
keyout_buffer   #       5               ; for outputting multi-byte UTF-8 characters as hotkey sequences
keyout_buflen   #       1               ; number of bytes in keyout_buffer

alphabet        #       1               ; for storing the current alphabet
        ALIGNHASH 4
systemfont_wimpsymbol_map #     4       ; for use in pushfontstring
 ]

 [ Autoscr
; main autoscrolling variables
autoscr_state           #       4       ; flags word
autoscr_handle          #       4       ; window being scrolled
autoscr_pz_x0           #       4       ; pause zone sizes
autoscr_pz_y0           #       4
autoscr_pz_x1           #       4
autoscr_pz_y1           #       4
autoscr_user_pause      #       4       ; minimum pause time (cs), or -1 to use default
autoscr_user_rout       #       4       ; user routine, or < &8000 to use Wimp-supplied
autoscr_user_wsptr      #       4       ; user routine workspace (if above >= &8000)

autoscr_pause           #       4       ; minimum pause time (cs) (explicit if default)
autoscr_rout            #       4       ; routine (user or Wimp)
autoscr_wsptr           #       4       ; workspace (user or Wimp)
autoscr_next_t          #       4       ; time when to start autoscrolling, or when next to update
autoscr_last_t          #       4       ; time of last update
autoscr_last_x          #       4       ; position of mouse at last examination
autoscr_last_y          #       4
autoscr_old_ptr_colours #     3*4       ; used when restoring pointer after autoscroll pointer use
autoscr_old_ptr_number  #       1
autoscr_default_pause   #       1       ; derived from CMOS (ds)
autoscr_scrolling       #       1       ; used to determine next setting of flag bit 8
autoscr_pausing         #       1       ; used to determine whether timer is dirty, also a "don't re-enter" flag

autoscr_speed_factor    *       5       ; -log2 of number of pointer offsets to scroll per centisecond
autoscr_update_delay    *       8       ; hardwired minimum interval between updates (cs)
                                        ; is necessary to ensure null events have a chance to be seen
        ALIGNHASH   4
autoscr_END             #       0
 ]

 [ ClickSubmenus
clicksubmenuenable      #       1       ; nonzero => functionality enabled
submenuopenedbyclick    #       1       ; nonzero => submenu should be held open
 ]

 [ IconiseButton
iconisebutton           #       1       ; nonzero => add iconise button
 ]

 [ StickyEdges
stickyedges             #       1       ; nonzero => interpret "force on screen" as sticky
 ]

 [ BounceClose
buttontype              #       1       ; nonzero => buttons are release-type
 ]

 [ SpritesA
alphaspriteflag         #       1       ; nonzero => *iconsprites looks for alpha sprites
 ]
checkedcolourmapping    #       1       ; nonzero => we've checked for colour mapping support in SpriteExtend (and generated the tables)

 [ PoppingIconBar
popiconbar              #       1       ; nonzero => enable autofronting
        ALIGNHASH   4
popiconbar_pause        #       4       ; configured pause time (cs)
 ]

        ALIGNHASH   4

inversecolourmap        #       4       ; pointer to colour mapping descriptors and LUTs used for true colour sprite shading & inversion

 [ MultiClose
nextwindowtoiconise     #       4       ; pointer through window stack so far
 ]

 [ TrueIcon3
truetitlefg     #       4               ; title foreground and window frame colour
truetitlebg     #       4               ; title background colour
trueworkfg      #       4               ; work area foreground colour
trueworkbg      #       4               ; work area background colour
truescoutcolour #       4               ; scroll bar outer colour
truescincolour  #       4               ; scroll bar inner colour
truetitlebg2    #       4               ; title background colour when highlighted for input focus
truetitlecolour #       4               ; independent of input focus status
   [ TrueSelectionColours
		#	4		; spare word because of selected icon bg
   ]
 ]

 [ SwitchingToSprite
switchtospr_current     #       4       ; -> sprite (or 0 for screen) that VDU output is switched to
switchtospr_correctfor  #       4       ; -> sprite (or 0 for screen) that Wimp is set up for
 ]

iconbar_scroll_speed    #       4
iconbar_scroll_accel    #       4

systemfontwidth #       4
systemfonty0    #       4
systemfonty1    #       4

ellipsiswidth   #       4
ellipsis        #       4

tempiconblk     #       48              ; for creating icons for menus
                                        ; also used for int_open_window
                                        ; and system drag boxes
tf_hdr          *       16
tf_indexsize    *       24
tf_log2fontsize *       4               ; actually font size = 3*2^4
tf_fontsize     *       3*(1:SHL:tf_log2fontsize)


templatehdr     #       tf_hdr
fontbindings    #       256

filehandle      #       4
fileaddress     #       4
filelength      #       4

templateindex   #       4
userfreeptr     #       4
userfreeend     #       4
userfontcounts  #       4

PollTaskPtr     #       4               ; -> last entry in PollTaskList

              [ NKmessages1
lastpointer     #       4               ; end of message queue (NK's optimise)
              ]

lastmode_x1     #       4               ; (xwindlimit+1) * px for previous mode
lastmode_y1     #       4               ; (ywindlimit+1) * py for previous mode
forceflags      #       4               ; for putting windows back

ditheringflag   #       4               ; flag to control dithering

sprite_lastmode #       4
sprite_log2bpp  #       4               ; for mode-independent sprite plotting
sprite_log2px   #       4
sprite_log2py   #       4
sprite_modeflags #      4
sprite_ncolour   #      4
tsprite_lastmode #      4
tsprite_log2bpp  #      4               ; for mode-independent toolsprite plotting
tsprite_log2px   #      4
tsprite_log2py   #      4
tsprite_modeflags #     4
tsprite_ncolour   #     4
           ALIGNHASH    16
sprite_factors  #       16
tsprite_factors #       16

physpaltable    #       4*16            ; secondary palette table (disconnected from Wimp jobbie)
temppaltable    #       4*16            ; temporary store for a palette
usephyspaltable #       4               ; use the physical palette table

transtable1     #       2               ; 1bpp mapping from wimp -> sprite pixels
transtable2     #       4               ; 2bpp     ---------- "" ------------
transtable4     #       16              ; 4bpp     ---------- "" ------------
        ALIGNHASH       16

selecttable_args #      4*8             ; parameters used for the last sprite select table call
selecttable_lastmode #  4
selecttable_lastpalptr # 4

pixtable_at     #       4
pixtable_size   #       4               ; size and position of pixtrans table currently setup

list_at         #       4               ; head of sprite cache list
list_size       #       4               ; size of buffer claimed
list_end        #       4               ; end of list used for chop

tpixtable_at    #       4
tpixtable_size  #       4               ; size and position of tool pixtrans table currently setup

        [ windowsprite :LAND: :LNOT: ThreeDPatch
tile_sc_block   #       16
tile_log2px     #       4
tile_log2py     #       4
tile_width      #       4
tile_height     #       4
        ]

; bits for internationalised Wimp

message_block   #       4*4             ; 16 bytes for message trans
messages        #       4               ; =0 then no messages / -> messages block

; bits for portable speed control

; see 321nk later
IdlePerSec      #       4               ; amount of time spent in idle mode
 [ Stork
WimpPortableFlags #     4               ;
PowerSave * &01000000
 |
WimpPortableFlag #      4               ; non-zero then portable module present
 ]

last_fg_gcol    #       4
last_bg_gcol    #       4

; filters registered using Wimp_RegisterFilter

prefilterWP     #       4               ; pre-poll filter
prefilter       #       4
postfilterWP    #       4               ; post-poll filter
postfilter      #       4
copyfilterWP    #       4               ; block copy filter
copyfilter      #       4
rectanglefilterWP #     4               ; get-rectangle filter
rectanglefilter   #     4
postrectfilterWP #     4               ; post-get-rectangle filter
postrectfilter   #     4
posticonfilterWP #     4               ; post-icon-draw filter
posticonfilter   #     4

; bits for icon borders

border_type     #       4               ; border slab type => 0 => normal
border_highlight #      4               ; highlight colour to be applied

border_iconselected #   4               ; icon that is currently selected
border_windowselected # 4               ; window selected

tool_area       #       4               ; -> sprite area owned by tool managing routines (may be in resources:)
tool_areaCB     #       SpriteAreaCBsize

tool_list       #       4               ; -> list of sprites in area / =0 if not valid yet
tool_list_backup #      4               ; backup copy of tool_list

; tool plotting information

tool_plotparams #       0
tool_plotop     #       4               ; sprite op to plot sprites with
tool_maskop     #       4
tool_scaling    #       4               ; -> scaling block (may not be used)
tool_transtable #       4               ; -> translation table (may not be used)
 [ ToolTables
ttt_masterset   #       16*4            ; -> user supplied tool translation tables (one per wimp colour)
ttt_activeset   #       16*4            ; -> reprocessed for this mode
ttt_activeset_at #      4
ttt_activeset_size #    4
ttt_lastlookup  #       4               ; most recent colour match
ttt_table2      *       2*4
 ]
tool_scrollclip #       4*4             ; clip region used for plotting scroll bars
tool_scalingblk #       4*4             ; scaling block used for painting glyphs

; tool size information

title_height    #       4               ; title height = close, toggle, back
title_height1   #       4
vscroll_width   #       4               ; vscroll height = left, right, resize
vscroll_width1  #       4
hscroll_height  #       4               ; hscroll width = toggle, up, down, resize
hscroll_height1 #       4

back_width      #       4               ; width of the back box
close_width     #       4               ; width of the close box
 [ IconiseButton
iconise_width	#	4		; width of the iconise button
 ]

left_width      #       4               ; width of the left arrow
right_width     #       4               ; width of the right arrow

up_height       #       4               ; up arrow height
down_height     #       4               ; down arrow height

; bits for iny-outy type scroll blobs - yucky!

vscroll_top             # 4             ; height in OS units
vscroll_topfill         # 4
vscroll_blobtop         # 4
vscroll_blobfill        # 4
vscroll_blobbottom      # 4
vscroll_bottomfill      # 4
vscroll_bottom          # 4

hscroll_left            # 4             ; width in OS units
hscroll_leftfill        # 4
hscroll_blobleft        # 4
hscroll_blob            # 4
hscroll_blobright       # 4
hscroll_rightfill       # 4
hscroll_right           # 4

title_left              # 4             ; width in OS units
title_right             # 4

title_sectionwidth      # 4             ; width of sections in OS units
title_topheight         # 4             ; height of units in OS units
title_bottomheight      # 4

                      [ hvblip
vscroll_blipheight      # 4             ; width an height of scroll bar blobs
hscroll_blipwidth       # 4
                      ]

; some other bits of misc data for configuration and caret saving

drag_movelimit             #       1
doubleclick_movelimit      #       1
              ALIGNHASH    4
drag_timelimit             #       4
doubleclick_timelimit      #       4
automenu_timelimit         #       4
menudragdelay              #       4
automenu_timeouttime       #       4
automenu_inactivetimeout   #       4

savedcaretdata             #      24    ; holds caretdata from start of key handling process
savedvalidation            #       4
savedcharcode              #       4

; bits to do with pointer tracking

old_icon        #       4
old_window      #       4
special_pointer #       4
pointer_sprite  #       12

 [ KeyboardMenus
lastxpos        #       4               ; stop mouse highlighting menus unless it moves
lastypos        #       4
 ]

 [ AutoHourglass
hourglass_delay	*	100		; delay before showing hourglass for "dodgy apps", in 1/100 secs
hourglass_status #      4               ; autohourglass status (0 => no hourglass or WrchV routine, 1 => just routine,
 ]                                      ;                       2 => routine is on vector & hourglass is pending or active)

        ALIGNHASH       64

 [ UTF8
keystring_buffer #      256             ; for queuing Key$n bytes
keyprocess_buffer #     256             ; for queuing multiple key-originating Wimp_ProcessKey calls
                                        ; byte format is the same as bytes read from kernel keyboard buffer
 ]

        ALIGNHASH       64

        [ NewErrorSystem
errorbuttonsize * 256
errorbuttons    #       errorbuttonsize ; this is used to copy button labels
buttontextsize  * 24
oktext          #       0               ; SMC: now lookup text for buttons (OK same as Continue)
conttext        #       buttontextsize
quittext        #       buttontextsize
progerrsaveblk  #       4 * 4           ; caller R0-R3, stored while the "may have gone wrong" window is displayed
errbut_y0_def   #       4               ; bottom of default action button, read from "Continue"
errbut_y1_def   #       4               ; top of default action button, read from "Continue"
errbut_fl_def   #       4               ; icon flags of default action button, read from "Continue"
errbut_va_def   #       4               ; validation string of default action button, read from "Continue"
errbut_w_def    #       4               ; width of default action button, read from "Continue"
errbut_y0       #       4               ; bottom of action button, read from "Cancel"
errbut_y1       #       4               ; top of action button, read from "Cancel"
errbut_fl       #       4               ; icon flags of action button, read from "Cancel"
errbut_va       #       4               ; validation string of action button, read from "Cancel"
errbut_w        #       4               ; width of action button, read from "Cancel"
errapp_x0       #       4               ; LHS of application sprite
errtype_x0      #       4               ; LHS of error type sprite
errmess_x0      #       4               ; LHS of error message icon
        [ StretchErrorText
linecount       #       4               ; flags counting and returns number of lines required for error message
errmess_maxlines    *   7               ; maximum number of lines to allow for error message
errmess_increment   *   48              ; step size (in OS units) to increase error box size by when enlarging
        ]
maxno_error_buttons *   8               ; maximum number of action buttons (needs this many Additional buttons in template)
        ]

paltable        #       4 * 16          ; one word per colour
othercolours    #       4 * 4           ; border & mouse colours

        [ NewErrorSystem
watchdogarea    #       4
watchdogerror   #       4
watchdogerrtxt  #       244
watchdogtaskno  #       4
watchdogtask    #       4
watchdogcodew   #       4
        ]

iconbar_scroll_start_time #	4	; time icon bar started scrolling
iconbar_scroll_start_scx  #	4	; and where it started from
MaxSlowIdleEvents       #       4       ; 321nk added for PowerUtils incorporation
MaxFastIdleEvents       #       4
Threshold       *       &600

	[ PoppingIconBar
iconbar_pop_time	#	4
iconbar_pop_state	#	4
pop_Back	* 0
pop_Delaying	* 1
pop_Front	* 2
pop_HeldByMenu	* 3
        [ :LNOT: OldStyleIconBar
pop_Front2      * 4 ; held by virtue of Shift-F12
        ]
	]

        [ ChildWindows
newparent       #       4               ; parameter for Wimp_OpenWindow
newalignflags   #       4               ; parameter for Wimp_OpenWindow
oldactivewinds  #       lh_size         ; used for deferred opening
openingwinds    #       lh_size         ; ditto
heldoverwinds   #       4               ; singly-linked list for windows that are optimized out
        ]

activewinds     #       lh_size         ; Forwards is top to bottom of stack
allwinds        #       lh_size

        ; Braindead Panic Redraw handling
BPR_indication  #       4
BPR_gotfullarea *       0               ; Rect area has become full from a no problem situation
BPR_panicnow    *       1               ; Rect area become full again - enter brain dead mode
BPR_nullrectops *       1               ; This or below means rectangle ops do nothing
BPR_notatall    *       2               ; No problems with full rectangle areas
BPR_1sttry      *       3               ; After a rect area full try redrawing whole screen
BPR_continuelevel *     4               ; HS this means continuing BPR
; Other values indicate BPR_panicnow and are the next window to redraw braindeadwise

ptr_IRQsema     #       4               ; Pointer to kernel's IRQsema
ptr_DomainId    #       4               ; Pointer to kernel's DomainId
        [ DynamicAreaWCF
wcfda           #       4
        ]

rlinks          #       4*maxrects
                #       -4*firstfreerect        ; this data not used
rectarea        #       16*maxrects
rectend         #       0

registerbuffer  #       4*17

           ALIGNHASH    64

maxtasks        *       128

taskstack       #       maxtasks * 4    ; each task can only be in it once!
taskpointers    #       maxtasks * 4    ; pointers to task data blocks
maxtaskhandle   *       :INDEX:@@

PollTasks       #       maxtasks * 4    ; Packed list of tasks with pollwords

errorbuffer     #       256             ; used by error handler

errordynamic    *       errorbuffer+4   ; put these after stashed PC
errordynamicsize *      ?errorbuffer-4
stackspace      #       0               ; temporary stack for debugging!

copyerror       #       240             ; copy of error block
greys_mode       #      1               ; last grey mode.
last_greys      #       1               ; previous greys mode
freepoolinuse	#	1
misc		#	1
save_context    #       4
fontnamebuffer  #       60              ; used to store last ROM font.

        [ PoppingIconBar :LAND: OldStyleIconBar
iconbar_pop_previous	#	4	; where to go back to
        ]

        [ DebugMemory
memory_claims   #       8               ; build a list of mem claims for debugging
        ]

 ALIGNHASH 4

inverselookup   #       1024            ; what colour numbers to use when EOR'ing an area

       [ LongCommandLines
path_buffer     #       1024            ; for building Sprites<x><y> pathnames
taskbuffer      #       1024            ; command which starts a task
       |
path_buffer     #       256             ; for building Sprites<x><y> pathnames
taskbuffer      #       256             ; command which starts a task
       ]

errortitle      #       1024            ; for building up 'Error from ...'
errortitend     #       0

 ALIGNHASH 4

	[ ThreeDPatch
tile_sprites	 #	TileInfo * 16
menu_tile_sprite #	TileInfo
temp_tile_sprite #	TileInfo
	]

              [ Swapping
swapping        #       4               ; Is there a swap path ? if so, the length of the path.
swapsize        #       4               ; Must be together (returned from ReadSysInfo )
swapused        #       4
                ASSERT  swapsize=swapping+4
                ASSERT  swapused=swapsize+4
swap_filename   #       4               ; File name for next swap file.
swap_path       #       256             ; Path name for swap files.
              ]

              [ NCErrorBox
ptrshlflag	#	4		; Pointer shape and linkage flag (saved here during
					; ReportError) JRC 25 Jul 1997
ptrsuspenddata  #       12              ; To store x,y,b last generated by IconHigh
ptrsuspendflag  #       4               ; 0 => normal
                                        ; 1 => waiting for mouse move generated by IconHigh
                                        ; 2 => waiting for next mouse move *not* generated by IconHigh
ptrpreserveflag #       4               ; 0 => position pointer over default error button on box start
                                        ; 1 => don't move pointer on box start
              ]

              [ ErrorServiceCall
errorbuttonoldhandlers # 3*3*4          ; old environment handlers to restore afterwards
              ]

selecttable_lastpal # 1024              ; Last sprite palette used with selecttable

maxwork         *       :INDEX:@@

                ! 0,    "Free pool              = R12+&" :CC: :STR: :INDEX: freepool
                ! 0,    "#pixtable_at           = R12+&" :CC: :STR: :INDEX: pixtable_at
                ! 0,    "#pixtable_size         = R12+&" :CC: :STR: :INDEX: pixtable_size
                ! 0,    "#tpixtable_at          = R12+&" :CC: :STR: :INDEX: tpixtable_at
                ! 0,    "#tpixtable_size        = R12+&" :CC: :STR: :INDEX: tpixtable_size
                ! 0,    "#list_at               = R12+&" :CC: :STR: :INDEX: list_at
                ! 0,    "#list_size             = R12+&" :CC: :STR: :INDEX: list_size
                ! 0,    "#list_end              = R12+&" :CC: :STR: :INDEX: list_end
                ! 0,    "#allwinds              = R12+&" :CC: :STR: :INDEX: allwinds
                ! 0,    "Task Pointers          = R12+&" :CC: :STR: :INDEX: taskpointers
                ! 0,    "Filter bits            = R12+&" :CC: :STR: :INDEX: prefilterWP
 [ PoppingIconBar
                ! 0,    "#iconbar_pop_state     = R12+&" :CC: :STR: :INDEX: iconbar_pop_state
 ]
 [ CnP
                ! 0,    "#ghostcaretdata        = R12+&" :CC: :STR: :INDEX: ghostcaretdata
                ! 0,    "#selectionwindow       = R12+&" :CC: :STR: :INDEX: selectionwindow
 ]
 [ Autoscr
                ! 0,    "#dragtype              = R12+&" :CC: :STR: :INDEX: dragtype
                ! 0,    "#dragflags             = R12+&" :CC: :STR: :INDEX: dragflags
                ! 0,    "#autoscr_state         = R12+&" :CC: :STR: :INDEX: autoscr_state
 ]


                ! 0,    "Workspace used               &":CC::STR:maxwork:CC:" bytes."


;;-----------------------------------------------------------------------------
;; Format of data in a window definition
;;-----------------------------------------------------------------------------

;; For Aquarius, keep the data from the guard to w_cw0 constant !!!

                ^       0
w_guardword     #       4               ; guard word when policing window handles
w_guardword_valid       *       &646e6957       ; "Wind"
w_taskhandle    #       4               ; handle of task which created window

              [ :LNOT: ChildWindows
w_active_link   #       ll_size         ; this has moved!
              ]
w_all_link      #       ll_size
w_icons         #       4               ; Points to window's block of icons

              [ togglebits
w_togglewidth   #       4               ; width of previous work area if toggled2 is set
w_toggleheight  #       4               ; height of previous work area if toggled2 is set
              ]
              [ Mode22
w_origflags     #       4
              ]

              [ CnP
w_seldata       #       32              ; selection icon, x offset, width, y offset, height+flags, low,high indexes
              ]                         ; [w_seldata+28] = w_selscrollx

              [ ChildWindows
w_bwax0         #       4               ; previous position/size (for toggling)
w_bway0         #       4
w_bwax1         #       4
w_bway1         #       4
w_bscx          #       4               ; previous x,y scroll positions
w_bscy          #       4
w_bbhandle      #       4               ; previous window it was behind

w_alignflags    #       4               ; auto-alignment with parent window

w_opening_link  #       ll_size         ; for the list of windows being opened, and the block-copy rectangles
w_xoffset       #       4
w_yoffset       #       4
w_oldwindowrects  #     4               ; list of rectangles to be block-copied for this window

w_old_data      #       0               ; start of old version of current position

w_old_children  #       lh_size         ; children of this window (chained by w_active_link)
w_old_link      #       ll_size

w_old_parent    #       4               ; parent of this window (if any)

w_old_x0        #       4
w_old_y0        #       4               ; 'current' position, ie. the most-recently-displayed
w_old_x1        #       4               ; these are used for collecting up Wimp_OpenWindows
w_old_y1        #       4

w_old_wax0      #       4               ; x,y coordinates of work area
w_old_way0      #       4               ; (ie. corners)
w_old_wax1      #       4               ;
w_old_way1      #       4
w_old_scx       #       4               ; x,y scroll positions
w_old_scy       #       4               ; (between wex0/y0 and wex1/y1)

w_old_bhandle   #       4               ; not used, but keeps the structures in line

w_old_flags     #       4               ; status of window (open/closed etc.)

w_old_end       #       0

w_new_data      #       0               ; start of new version of current position

w_children      #       lh_size         ; children of this window (chained by w_active_link)
w_active_link   #       ll_size         ; this has moved!

w_parent        #       4               ; parent of this window (if any)
              ]
w_x0            #       4               ; bounding box of window
w_y0            #       4               ; (including outline)
w_x1            #       4               ;
w_y1            #       4               ;

              [ :LNOT: ChildWindows     ; this has moved!
w_bwax0         #       4               ; previous position/size
w_bway0         #       4
w_bwax1         #       4
w_bway1         #       4
w_bscx          #       4               ; previous x,y scroll positions
w_bscy          #       4
w_bbhandle      #       4               ; previous window it was behind
              ]

w_st0           #       0       ; start of 'status' section
w_cw0           #       0       ; start of Create_Window section
w_ow0           #       0       ; start of Open_Window section

w_wax0          #       4               ; x,y coordinates of work area
w_way0          #       4               ; (ie. corners)
w_wax1          #       4               ;
w_way1          #       4
w_scx           #       4               ; x,y scroll positions
w_scy           #       4               ; (between wex0/y0 and wex1/y1)
w_bhandle       #       4               ; handle of window above this one

w_ow1           #       0       ; end of Open_Window section

w_flags         #       4               ; status of window (open/closed etc.)

w_new_end       #       0

w_st1           #       0       ; end of 'status' section

w_tfcol         #       1               ; title foreground colour
w_tbcol         #       1               ; title background colour
w_wfcol         #       1               ; work area foreground colour
w_wbcol         #       1               ; work area background colour
w_scouter       #       1               ; scroll bar outer portion
w_scinner       #       1               ; scroll bar inner portion
w_tbcol2        #       1               ; colour if window has input focus
 [ TrueIcon3
w_flags2        #       1               ; secondary flags
 |
                #       1               ; reserved
 ]
w_wex0          #       4               ; work area extent
w_wey0          #       4               ; (x0,y0,x1,y1)
w_wex1          #       4
w_wey1          #       4
w_titleflags    #       4
w_workflags     #       4               ; icon flags for 'work area'
w_areaCBptr     #       4               ; sprite area CB ptr (<=0 ==> system)
w_minx          #       2               ; minimum x size (0 ==> use title)
w_miny          #       2               ; minimum y size
w_title         #       12              ; title (max 11 chars, then <cr>)
w_nicons        #       4               ; no. of icons following


w_cw1           #       0       ; end of Create_Window section

w_size          #       0       ; end of window data

      [ ChildWindows
        ASSERT  (w_old_end - w_old_data) = (w_new_end - w_new_data)
      ]
      [ CnP
                ! 0,    "Selection data      = handle+&" :CC: :STR: :INDEX: w_seldata
      ]

; standard colour numbers

sc_white              * &0
sc_verylightgrey      * &1
sc_lightgrey          * &2
sc_midlightgrey       * &3
sc_middarkgrey        * &4
sc_darkgrey           * &5
sc_verydarkgrey       * &6
sc_black              * &7
sc_darkblue           * &8
sc_yellow             * &9
sc_lightgreen         * &A
sc_red                * &B
sc_cream              * &C
sc_darkgreen          * &D
sc_orange             * &E
sc_lightblue          * &F

rgb_white             * &FFFFFF00
rgb_verylightgrey     * &DDDDDD00 ; Unused
rgb_lightgrey         * &BBBBBB00
rgb_midlightgrey      * &99999900
rgb_middarkgrey       * &77777700
rgb_darkgrey          * &55555500 ; Unused
rgb_verydarkgrey      * &33333300 ; Unused
rgb_black             * &00000000
rgb_darkblue          * &99440000 ; Unused
rgb_yellow            * &00EEEE00 ; Unused
rgb_lightgreen        * &00CC0000 ; Unused
rgb_red               * &0000DD00 ; Unused
rgb_cream             * &BBEEEE00 ; Unused
rgb_darkgreen         * &00885500 ; Unused
rgb_orange            * &00BBFF00 ; Unused
rgb_lightblue         * &FFBB0000 ; Unused

; bit masks for flags/status

wf_title        *       2_00000000000000000000000000000001
wf_moveable     *       2_00000000000000000000000000000010
wf_vscroll      *       2_00000000000000000000000000000100
wf_hscroll      *       2_00000000000000000000000000001000
wf_autoredraw   *       2_00000000000000000000000000010000
wf_isapane      *       2_00000000000000000000000000100000
wf_nochecks     *       2_00000000000000000000000001000000
wf_nobackquit   *       2_00000000000000000000000010000000
wf_userscroll1  *       2_00000000000000000000000100000000      ; auto-repeat
wf_userscroll2  *       2_00000000000000000000001000000000      ; debounced
wf_userscroll   *       2_00000000000000000000001100000000
wf_realcolours  *       2_00000000000000000000010000000000
wf_backwindow   *       2_00000000000000000000100000000000
wf_grabkeys     *       2_00000000000000000001000000000000
wf_onscreen     *       2_00000000000000000010000000000000      ; override sysflags_offscreen
wf_rubbery_wex1 *       2_00000000000000000100000000000000      ; extent can stretch to the right
wf_rubbery_wey0 *       2_00000000000000001000000000000000      ; extent can stretch downwards

ws_open         *       2_00000000000000010000000000000000
ws_top          *       2_00000000000000100000000000000000
ws_toggled      *       2_00000000000001000000000000000000
ws_toggling     *       2_00000000000010000000000000000000
ws_hasfocus     *       2_00000000000100000000000000000000
              [ :LNOT: ChildWindows
ws_system       *       2_00000000000111110000000000000000
ws_status       *       2_00000000000000110000000000000000      ; calc_w_status
              ]

ws_onscreenonce *       2_00000000001000000000000000000000      ; cancelled after open_window
ws_toggled2     *       2_00000000010000000000000000000000      ; used for storing important toggle

              [ ChildWindows
ws_system       *       2_00000000011111110000000000000000

wf_inborder     *       2_00000000100000000000000000000000      ; child window can overlap parent's border
              ]

wf_icon1        *       2_00000001000000000000000000000000
wf_icon2        *       2_00000010000000000000000000000000
wf_icon3        *       2_00000100000000000000000000000000
wf_icon4        *       2_00001000000000000000000000000000
wf_icon5        *       2_00010000000000000000000000000000
wf_icon6        *       2_00100000000000000000000000000000
wf_icon7        *       2_01000000000000000000000000000000
wf_iconbits     *       2_01111111000000000000000000000000
wf_newformat    *       2_10000000000000000000000000000000

              [ TrueIcon3
wf2_truecolour          *       2_00000001      ; use title validation string colours
                                                ; (implies w_title+4 is always used as validation string pointer, unless
                                                ; already in use as spriteareaCB ptr, or part of non-indirected string)
              ]
wf2_extscrollreq        *       2_00000010      ; used by RISC OS 4.32
wf2_reserved            *       2_00001100      ; these bits are (erroneously) set in ResEd's window-object prototype
                                                ; so we can't use them
	      [ ThreeDPatch
wf2_no3Dborder		*	2_00000100	; this window must never be given a 3D border
wf2_force3Dborder	*	2_00001000	; this window must always be given a 3D border
              ]
wf2_shadedhelp          *       2_00010000      ; return shaded icons in GetPointerInfo, so they can have interactive help

              [ ChildWindows

; alignment options for each item

al_s            *       0               ; align with scrolling element
al_0            *       1               ; align with left/bottom
al_1            *       2               ; align with right/top
al_reserved     *       3               ; not used (yet)

al_mask         *       3

alf_setflags    *       1 :SHL: 0       ; set this bit to alter the window's flags

als_x0          *       16              ; bit numbers (shift the above by these)
als_y0          *       18
als_x1          *       20
als_y1          *       22
als_scx         *       24
als_scy         *       26

alm_x0          *       ( al_mask :SHL: als_x0 )
alm_y0          *       ( al_mask :SHL: als_y0 )
alm_x1          *       ( al_mask :SHL: als_x1 )
alm_y1          *       ( al_mask :SHL: als_y1 )
alm_scx         *       ( al_mask :SHL: als_scx )
alm_scy         *       ( al_mask :SHL: als_scy )

al0_x0          *       ( al_0 :SHL: als_x0 )
al0_y0          *       ( al_0 :SHL: als_y0 )
al0_x1          *       ( al_0 :SHL: als_x1 )
al0_y1          *       ( al_0 :SHL: als_y1 )
al0_scx         *       ( al_0 :SHL: als_scx )
al0_scy         *       ( al_0 :SHL: als_scy )

              ]

;;-----------------------------------------------------------------------------
;; Format of data in an icon definition
;;-----------------------------------------------------------------------------

                ^       0
i_bbx0          #       4               ; bounding box (x0,y0,x1,y1)
i_bby0          #       4
i_bbx1          #       4               ; if sprite, get size instead
i_bby1          #       4
i_flags         #       4
i_data          #       12      ; up to 12 bytes of text/sprite name etc.

i_size          #       0       ; size of icon data

i_shift         *       5
             ASSERT     (i_size = 1:SHL:i_shift)

; bit masks for flags

if_text         *       2_00000000000000000000000000000001
if_sprite       *       2_00000000000000000000000000000010
if_border       *       2_00000000000000000000000000000100
if_hcentred     *       2_00000000000000000000000000001000
if_vcentred     *       2_00000000000000000000000000010000
if_filled       *       2_00000000000000000000000000100000
if_fancyfont    *       2_00000000000000000000000001000000
if_funnyicon    *       2_00000000000000000000000010000000
if_indirected   *       2_00000000000000000000000100000000
if_rjustify     *       2_00000000000000000000001000000000
if_canadjust    *       2_00000000000000000000010000000000
if_halfsize     *       2_00000000000000000000100000000000

if_buttontype   *       2_00000000000000001111000000000000
if_esg          *       2_00000000000111110000000000000000
if_esg2         *       2_00000000000011110000000000000000   ; all but top bit
if_numeric      *       2_00000000000100000000000000000000   ; Just top bit

; bit masks for status

is_inverted     *       2_00000000001000000000000000000000
is_shaded       *       2_00000000010000000000000000000000
is_deleted      *       2_00000000100000000000000000000000

; foreground and background colours

if_fcol         *       2_00001111000000000000000000000000
if_bcol         *       2_11110000000000000000000000000000
if_shadecols    *       2_00100010111111111111111111111111

; bit positions of various fields

ib_buttontype   *       12
ib_esg          *       16
ib_fcol         *       24
ib_bcol         *       28
ib_fontno       *       24              ; overlaid

; button types

ibt_never           *   0               ; never report
ibt_always          *   1               ; always report
ibt_autorepeat      *   2               ; button clicked (auto-repeat)
ibt_click           *   3               ; button clicked (debounced)
ibt_clickrelease    *   4               ; select if clicked, report if released
ibt_click2          *   5               ; select if clicked, report if 2 clicks
ibt_dclick          *   6               ; as for (3), but can also drag
ibt_dclickrelease   *   7               ; as for (4), but can also drag
ibt_dclick2         *   8               ; as for (5), but can also drag
ibt_menuicon        *   9               ; select when hover over, notify on click
ibt_rdclick2        *   10              ; as for (8), but reports for 1 click also
ibt_clicksel        *   11              ; select and notify on click, but can also drag
ibt_dwritable       *   14              ; writable gains caret, but can also drag
ibt_writeable       *   15              ; writable gains caret

erf_okbox       *       1 :SHL: 0
erf_cancelbox   *       1 :SHL: 1
erf_htcancel    *       1 :SHL: 2
erf_dontwait    *       1 :SHL: 3
erf_omiterror   *       1 :SHL: 4
erf_poll        *       1 :SHL: 5       ; leave error window open
erf_pollexit    *       1 :SHL: 6       ; close error window
erf_nobeep      *       1 :SHL: 7       ; don't beep (Wimp 2.28 onwards)
erf_newtype	*	1 :SHL: 8	; new style error report (Wimp 3.21 onwards)
erf_errortype	*	7 :SHL: 9	; error type (new style only)
 [ true
erf_describe	*	1 :SHL: 23	; used internally
erf_ocontcode_shift           * 24
erf_ocontcode   *      15 :SHL: erf_ocontcode_shift   ; return code to use for Continue in "omen" window (0 => return 1)
erf_ocancelcode_shift         * 28
erf_ocancelcode *      15 :SHL: erf_ocancelcode_shift ; return code to use for Cancel in "omen" window (0 => exit handler)
 |
erf_describe	*	1 :SHL: 31	; used internally
 ]

erb_errortype	*	9

;;------------------------------------------------------------------------------
;; Things to do with swapping of tasks to disc
;;------------------------------------------------------------------------------

               [ Swapping

swapping_version   *  286         ; First version in which swapping is implemented.
                                  ; So that it can be changed.
               ]


;;-----------------------------------------------------------------------------
;; RM header information
;;-----------------------------------------------------------------------------

        ASSERT  (.=Module_BaseAddr)

        ENTRY

MySWIBase       *       Module_SWISystemBase + WimpSWI * Module_SWIChunkSize

        DCD     Start          - Module_BaseAddr
        DCD     Init           - Module_BaseAddr
        DCD     Die            - Module_BaseAddr
        DCD     Service        - Module_BaseAddr
        DCD     Title          - Module_BaseAddr
        DCD     Helpstr        - Module_BaseAddr
        DCD     Helptable      - Module_BaseAddr
        DCD     MySWIBase
        DCD     Wimp_SWIdecode - Module_BaseAddr
        DCD     Wimp_SWInames  - Module_BaseAddr
        DCD     0
 [ international_help
        DCD     messfsp        - Module_BaseAddr
 |
        DCD     0
 ]
        DCD     Flags          - Module_BaseAddr

Title   =       "WindowManager",0
Helpstr =       "Window Manager",9,"$Module_HelpVersion"
        [ DebugMemory
        = " Memory debugging enabled"
        ]
      [ debug
        =       " Development version"
      ]
      [ standalone
        =       "  (Stand alone)"
      ]
	=	module_postfix
        =       0

 [ :LNOT: international_help

IconSprites_Help        DCB     "*IconSprites loads a sprite file into the "
                        DCB     "Wimp's common sprite pool",cr
IconSprites_Syntax      DCB     "Syntax: *IconSprites <filename>",0

Pointer_Help            DCB     "*Pointer turns the mouse pointer on/off",cr
Pointer_Syntax          DCB     "Syntax: *Pointer [0|1]",0

ToolSprites_Help        DCB     "*ToolSprites loads a sprite file to use as window borders",cr
ToolSprites_Syntax      DCB     "Syntax: *ToolSprites <filename>",0

WimpFlagsC_Help
        DCB     "*Configure WimpFlags sets the default actions "
        DCB     "when dragging windows, as follows:",cr
        DCB     "bit 0 set: continuous window movement",cr
        DCB     "bit 1 set: continuous window resizing",cr
        DCB     "bit 2 set: continuous horizontal scroll",cr
        DCB     "bit 3 set: continuous vertical scroll",cr
        DCB     "bit 4 set: don't beep when error box appears",cr
        DCB     "bit 5 set: allow windows to go partly off screen",cr
        DCB     "bit 6 set: allow windows to go partly off screen in all directions",cr
        DCB     "bit 7 set: open submenus automatically",cr

WimpFlagsC_Syntax
        DCB     "Syntax: *Configure WimpFlags <number>",0

WimpDragDelayC_Help
        DCB     "*Configure WimpDragDelay sets the delay in 1/10 second units after a single click "
        DCB     "after which a drag is started.",cr

WimpDragDelayC_Syntax
        DCB     "Syntax: *Configure WimpDragDelay <delay>",0

WimpFontC_Help
        DCB     "*Configure WimpFont sets the font to be used within the desktop for icons and menus. "
        DCB     "0 means use Wimp$* and 1 means use system font. 2-15 refer to a ROM font.",cr

WimpFontC_Syntax
        DCB     "Syntax: *Configure WimpFont <font number>",0

WimpDragMoveC_Help
        DCB     "*Configure WimpDragMove sets the distance in OS units that the "
        DCB     "pointer has to move after a single click for a drag to be started.",cr

WimpDragMoveC_Syntax
        DCB     "Syntax: *Configure WimpDragMove <distance>",0

WimpDoubleClickDelayC_Help
        DCB     "*Configure WimpDoubleClickDelay sets the time in 1/10 second units after a single click "
        DCB     "during which a double click is accepted.",cr

WimpDoubleClickDelayC_Syntax
        DCB     "Syntax: *Configure WimpDoubleClickDelay <delay>",0

WimpDoubleClickMoveC_Help
        DCB     "*Configure WimpDoubleClickMove sets the distance in OS units that the "
        DCB     "pointer has to move after a single click for a double click to be cancelled.",cr

WimpDoubleClickMoveC_Syntax
        DCB     "Syntax: *Configure WimpDoubleClickMove <distance>",0

WimpAutoMenuDelayC_Help
        DCB     "*Configure WimpAutoMenuDelay sets the time in 1/10 second units that the pointer "
        DCB     "has to stay over a non leaf menu entry before the submenu is automatically opened "
        DCB     "if WimpFlags bit 7 is set.",cr

WimpAutoMenuDelayC_Syntax
        DCB     "Syntax: *Configure WimpAutoMenuDelay <delay>",0

WimpMenuDragDelayC_Help
        DCB     "*Configure WimpMenuDragDelay sets the time in 1/10 second units for which menu "
        DCB     "activity is disabled after a menu has been automatically opened. This enables the "
        DCB     " pointer to move over other menu entries without cancelling the submenu.",cr

WimpMenuDragDelayC_Syntax
        DCB     "Syntax: *Configure WimpMenuDragDelay <delay>",0

WimpPalette_Help        DCB     "Used to activate a Wimp palette file.",cr
WimpPalette_Syntax      DCB     "Syntax: *WimpPalette <filename>",0

WimpSlot_Help   DCB     "Change the size of application space"
                DCB     ", or the amount of application space allocated to the next task to run."
                DCB     cr

WimpSlot_Syntax DCB     "Syntax: *WimpSlot [[-min] <size>[K]] [[-max] <size>[K]] [[-next] <size>[K]]"
                DCB     0

WimpTask_Help   DCB     "Start up a new task (from within a task)",cr
WimpTask_Syntax DCB     "Syntax: *WimpTask <*command>",0

Wimp_SetMode_Help   DCB "Change the current Wimp screen mode"
                    DCB " without affecting the configured value.",cr
Wimp_SetMode_Syntax DCB "Syntax: *WimpMode <number>"
        [ Medusa
                DCB     " | <specifier string>"
        ]
        DCB     0

WimpWriteDir_Help       DCB "Change the direction for writeable icons.",cr
                        DCB " 0 - Same direction as the configured territory.",cr
                        DCB " 1 - Opposite direction to the configured territory.",cr
WimpWriteDir_Syntax     DCB "Syntax: *WimpWriteDir 0|1",0

WimpKillSprite_Help     DCB "Remove a sprite from the wimp sprite pool.",cr
WimpKillSprite_Syntax   DCB "Syntax: *WimpKillSprite <spritename>",0

        [ Autoscr
WimpAutoScrollDelayC_Help       DCB "*Configure WimpAutoScrollDelay sets the time in 1/10 second units "
                                DCB "that the pointer has to stay over the edge of a window before it starts scrolling. "
                                DCB "This only applies in certain circumstances.",cr
WimpAutoScrollDelayC_Syntax     DCB "Syntax: *Configure WimpAutoScrollDelay <delay>",0
        ]
        [ PoppingIconBar
WimpAutoFrontDelayC_Help        DCB "*Configure WimpAutoFrontDelay sets the time in 1/10 second units "
                                DCB "that the pointer has to stay at the bottom of the screen before "
                                DCB "the icon bar is brought to the front.",cr
WimpAutoFrontDelayC_Syntax      DCB "Syntax: *Configure WimpAutoFrontDelay <delay>",0
        ]

WimpIconBarSpeedC_Help          DCB "*Configure WimpIconBarSpeed sets the initial scrolling speed of the icon bar "
                                DCB "in OS units per second.",cr
WimpIconBarSpeedC_Syntax        DCB "Syntax: *Configure WimpIconBarSpeed <speed>",0

WimpIconBarAccelerationC_Help   DCB "*Configure WimpIconBarAcceleration sets the acceleration rate of an icon bar scroll "
                                DCB "in OS units per second per second.",cr
WimpIconBarAccelerationC_Syntax DCB "Syntax: *Configure WimpIconBarAcceleration <rate>",0

        [ IconiseButton
WimpIconiseButtonC_Help         DCB "*Configure WimpIconiseButton sets whether an iconise button is added to "
                                DCB "top-level windows.",cr
WimpIconiseButtonC_Syntax       DCB "Syntax: *Configure WimpIconiseButton On|Off",0
        ]
        [ PoppingIconBar
WimpAutoFrontIconBarC_Help      DCB "*Configure WimpAutoFrontIconBar sets whether the icon bar is brought to the front "
                                DCB "when the pointer is held at the bottom of the screen.",cr
WimpAutoFrontIconBarC_Syntax    DCB "Syntax: *Configure WimpAutoFrontIconBar On|Off",0
        ]
        [ SpritePriority
WimpSpritePrecedenceC_Help      DCB "*Configure WimpSpritePrecedence sets whether ROM sprites have priority over "
                                DCB "RAM sprites or vice versa.",cr
WimpSpritePrecedenceC_Syntax    DCB "Syntax: *Configure WimpSpritePrecedence RAM|ROM",0
        ]
        [ StickyEdges
WimpStickyEdgesC_Help           DCB "*Configure WimpStickyEdges sets whether 'force on screen' directions can be "
                                DCB "overridden by pushing a window 'hard' enough.",cr
WimpStickyEdgesC_Syntax         DCB "Syntax: *Configure WimpStickyEdges On|Off",0
        ]
        [ BounceClose
WimpButtonTypeC_Help            DCB "*Configure WimpButtonType sets whether the back, close, iconise and toggle-size icons "
                                DCB "act when you click on them or when you release the mouse button afterwards.",cr
WimpButtonTypeC_Syntax          DCB "Syntax: *Configure WimpButtonType Click|Release",0
        ]
        [ ClickSubmenus
WimpClickSubmenuC_Help          DCB "*Configure WimpClickSubmenu sets whether clicking on a menu item that has an attached "
                                DCB "submenu will cause the attached submenu to be opened.",cr
WimpClickSubmenuC_Syntax        DCB "Syntax: *Configure WimpClickSubmenu On|Off",0
        ]
	[ ThreeDPatch
WimpVisualFlags_Help		DCB "*WimpVisualFlags changes some aspects of the visual appearance of the desktop.",cr
				DCB "-3DWindowBorders",cr
				DCB "   Give all menus and dialogue boxes a 3D border.",cr
				DCB "-TexturedMenus",cr
				DCB "   Give all menus a textured background.",cr
				DCB "-UseAlternateMenuBg",cr
				DCB "   Use a different background tile for menus.",cr
				DCB "-RemoveIconBoxes",cr
				DCB "   Remove the filled box from behind the text in text+sprite icons.",cr
				DCB "-NoIconBoxesInTransWindows",cr
				DCB "   Remove the filled box from icons on windows similar to the pinboard.",cr
				DCB "-Fully3DIconBar",cr
				DCB "   Make the iconbar have a full 3D border.",cr
				DCB "-FontBlending",cr
				DCB "   Use font blending in icons.",cr
				DCB "-WindowOutlineOver",cr
				DCB "   Plot the window outline over the tool icons.",cr
				DCB "-All",cr
				DCB "   Turn all flags on.",cr
				DCB "-WindowBorderFaceColour <&RRGGBB>",cr
				DCB "   Set the colour of the top left portion of the window border.",cr
				DCB "-WindowBorderOppColour <&RRGGBB>",cr
				DCB "   Set the colour of the bottom right portion of the window border.",cr
				DCB "-MenuBorderFaceColour <&RRGGBB>",cr
				DCB "   Set the colour of the top left portion of the menu border.",cr
				DCB "-MenuBorderOppColour <&RRGGBB>",cr
				DCB "   Set the colour of the bottom right portion of the menu border.",cr
                                DCB "-WindowOutlineColour <&RRGGBB>",cr
                                DCB "   Set the colour of the window outline.",cr
WimpVisualFlags_Syntax		DCB "Syntax: *WimpVisualFlags <options>",0
	]
                        ALIGN

 |
IconSprites_Help        DCB     "HWNMICS",0
IconSprites_Syntax      DCB     "SWNMICS",0

Pointer_Help            DCB     "HWNMPTR",0
Pointer_Syntax          DCB     "SWNMPTR",0

ToolSprites_Help        DCB     "HWNMTSP",0
ToolSprites_Syntax      DCB     "SWNMTSP",0

WimpFlagsC_Help
        DCB     "HWNMCWF",0
WimpFlagsC_Syntax
        DCB     "SWNMCWF",0

WimpDragDelayC_Help
        DCB     "HWNMWDD",0
WimpDragDelayC_Syntax
        DCB     "SWNMWDD",0

WimpFontC_Help
        DCB     "HWNMFON",0
WimpFontC_Syntax
        DCB     "SWNMFON",0

WimpDragMoveC_Help
        DCB     "HWNMWDM",0
WimpDragMoveC_Syntax
        DCB     "SWNMWDM",0

WimpDoubleClickDelayC_Help
        DCB     "HWNMDCD",0
WimpDoubleClickDelayC_Syntax
        DCB     "SWNMDCD",0

WimpDoubleClickMoveC_Help
        DCB     "HWNMDCM",0
WimpDoubleClickMoveC_Syntax
        DCB     "SWNMDCM",0

WimpAutoMenuDelayC_Help
        DCB     "HWNMAMD",0
WimpAutoMenuDelayC_Syntax
        DCB     "SWNMAMD",0

WimpMenuDragDelayC_Help
        DCB     "HWNMMDD",0
WimpMenuDragDelayC_Syntax
        DCB     "SWNMMDD",0

WimpPalette_Help        DCB     "HWNMWP",0
WimpPalette_Syntax      DCB     "SWNMWP",0

WimpSlot_Help   DCB     "HWNMWS",0
WimpSlot_Syntax DCB     "SWNMWS",0

WimpTask_Help   DCB     "HWNMWT",0
WimpTask_Syntax DCB     "SWNMWT",0

Wimp_SetMode_Help   DCB "HWNMWM",0
Wimp_SetMode_Syntax DCB "SWNMWM",0

WimpWriteDir_Help       DCB "HWNMWWD",0
WimpWriteDir_Syntax     DCB "SWNMWWD",0

WimpKillSprite_Help     DCB "HWNMKS",0
WimpKillSprite_Syntax   DCB "SWNMKS",0

        [ Autoscr
WimpAutoScrollDelayC_Help       DCB "HWNMASD",0
WimpAutoScrollDelayC_Syntax     DCB "SWNMASD",0
        ]
        [ PoppingIconBar
WimpAutoFrontDelayC_Help        DCB "HWNMAFD",0
WimpAutoFrontDelayC_Syntax      DCB "SWNMAFD",0
        ]

WimpIconBarSpeedC_Help          DCB "HWNMIBS",0
WimpIconBarSpeedC_Syntax        DCB "SWNMIBS",0

WimpIconBarAccelerationC_Help   DCB "HWNMIBA",0
WimpIconBarAccelerationC_Syntax DCB "SWNMIBA",0

        [ IconiseButton
WimpIconiseButtonC_Help         DCB "HWNMICB",0
WimpIconiseButtonC_Syntax       DCB "SWNMICB",0
        ]
        [ PoppingIconBar
WimpAutoFrontIconBarC_Help      DCB "HWNMAF",0
WimpAutoFrontIconBarC_Syntax    DCB "SWNMAF",0
        ]
        [ SpritePriority
WimpSpritePrecedenceC_Help      DCB "HWNMSPP",0
WimpSpritePrecedenceC_Syntax    DCB "SWNMSPP",0
        ]
        [ StickyEdges
WimpStickyEdgesC_Help           DCB "HWNMSE",0
WimpStickyEdgesC_Syntax         DCB "SWNMSE",0
        ]
        [ BounceClose
WimpButtonTypeC_Help            DCB "HWNMBT",0
WimpButtonTypeC_Syntax          DCB "SWNMBT",0
        ]
        [ ClickSubmenus
WimpClickSubmenuC_Help          DCB "HWNMCSM",0
WimpClickSubmenuC_Syntax        DCB "SWNMCSM",0
        ]
	[ ThreeDPatch
WimpVisualFlags_Help		DCB "HWNMVF",0
WimpVisualFlags_Syntax		DCB "SWNMVF",0
	]
                        ALIGN

 ]

Flags
        [ No32bitCode
        DCD     0
        |
        DCD     ModuleFlag_32bit
        ]
        [ international_help
i_h_flag      * International_Help
        |
i_h_flag      * 0
        ]
        
Helptable
        Command IconSprites,            1,1,                       i_h_flag
        Command Pointer,                1,0,                       i_h_flag
        Command ToolSprites,            1,0,                       i_h_flag
        [ Medusa
        Command WimpMode,               255,1,                     i_h_flag,Wimp_SetMode
        |
        Command WimpMode,               1,1,                       i_h_flag,Wimp_SetMode
        ]
        Command WimpPalette,            1,1,                       i_h_flag
        Command WimpSlot,               6,1,                       i_h_flag
        Command WimpTask,               255,1,                     i_h_flag
        Command WimpWriteDir,           1,1,                       i_h_flag
        Command WimpKillSprite,         1,1,                       i_h_flag
        Command WimpFlags,              1,1,Status_Keyword_Flag:OR:i_h_flag,WimpFlagsC
        Command WimpFont,               1,1,Status_Keyword_Flag:OR:i_h_flag,WimpFontC
        Command WimpDragDelay,          1,1,Status_Keyword_Flag:OR:i_h_flag,WimpDragDelayC
        Command WimpDragMove,           1,1,Status_Keyword_Flag:OR:i_h_flag,WimpDragMoveC
        Command WimpDoubleClickDelay,   1,1,Status_Keyword_Flag:OR:i_h_flag,WimpDoubleClickDelayC
        Command WimpDoubleClickMove,    1,1,Status_Keyword_Flag:OR:i_h_flag,WimpDoubleClickMoveC
        Command WimpAutoMenuDelay,      1,1,Status_Keyword_Flag:OR:i_h_flag,WimpAutoMenuDelayC
        Command WimpMenuDragDelay,      1,1,Status_Keyword_Flag:OR:i_h_flag,WimpMenuDragDelayC
        Command WimpIconBarSpeed,       1,1,Status_Keyword_Flag:OR:i_h_flag,WimpIconBarSpeedC
        Command WimpIconBarAcceleration,1,1,Status_Keyword_Flag:OR:i_h_flag,WimpIconBarAccelerationC
        [ SpritePriority
        Command WimpSpritePrecedence,   1,1,Status_Keyword_Flag:OR:i_h_flag,WimpSpritePrecedenceC
        ]
        [ BounceClose
        Command WimpButtonType,         1,1,Status_Keyword_Flag:OR:i_h_flag,WimpButtonTypeC
        ]
        [ IconiseButton
        Command WimpIconiseButton,      1,1,Status_Keyword_Flag:OR:i_h_flag,WimpIconiseButtonC
        ]
        [ StickyEdges
        Command WimpStickyEdges,        1,1,Status_Keyword_Flag:OR:i_h_flag,WimpStickyEdgesC
        ]
        [ PoppingIconBar
        Command WimpAutoFrontIconBar,   1,1,Status_Keyword_Flag:OR:i_h_flag,WimpAutoFrontIconBarC
        Command WimpAutoFrontDelay,     1,1,Status_Keyword_Flag:OR:i_h_flag,WimpAutoFrontDelayC
        ]
        [ Autoscr
        Command WimpAutoScrollDelay,    1,1,Status_Keyword_Flag:OR:i_h_flag,WimpAutoScrollDelayC
        ]
        [ ClickSubmenus
        Command WimpClickSubmenu,       1,1,Status_Keyword_Flag:OR:i_h_flag,WimpClickSubmenuC
        ]
        [ ThreeDPatch
        Command WimpVisualFlags,        255,0,                     i_h_flag
        ]
        DCB     0
        ALIGN

;............................................................................


WimpWriteDir_Code
        Push    "LR"

        MOV     R1,R0                   ; R1 -> string form of number
        MOV     R0,#10                  ; R0 = default base
        SWI     XOS_ReadUnsigned
        Pull    "PC",VS
        CMP     R2,#1
        Pull    "PC",HI
        MOV     r0,#-1
        SWI     XTerritory_WriteDirection
        MOVVS   R0,#WriteDirection_LeftToRight
        TST     R0,#WriteDirection_RightToLeft
        SUBNE   R2,R2,#1
        LDR     R12,[R12]               ; get workspace pointer!
        STR     R2,writeabledir

        Pull    "PC"

;............................................................................


WimpTask_Code
        Push    "LR"

        LDR     wsptr,[R12]             ; wsptr -> workspace
        LDR     R14,taskhandle
        LDR     R14,[wsptr,R14]
        TST     R14,#task_unused        ; if already a Wimp task,
        BEQ     %FT01                   ; no need to initialise temporarily

        MOV     R2,R0                   ; R2 -> parameters
        MOV     R0,#ModHandReason_Enter
        ADRL    R1,Title
        BL     XROS_Module

        Pull    "PC"                    ; in case it returned!
01
        SWI     XWimp_StartTask         ; R0 --> parameters
        Pull    "PC"

; must actually enter the module in order to start a task!
; NB: there is no workspace (or stack) here!

Start
        MOV     R3,R0                   ; R3 -> parameters

        MOV     R0,#200                 ; initialise temporarily
        LDR     R1,taskid3
        ADR     R2,str_tmp
        SWI     Wimp_Initialise

        MOV     R0,R3
        SWI     Wimp_StartTask          ; use normal error handler

        SWI     OS_Exit                 ; also does a closedown

taskid3 DCB     "TASK"
str_tmp DCB     "<temporary>", 0
        ALIGN

;............................................................................

Wimp_SetMode_Code
        Push    "LR"

        [ true
        Push    "R12"
        LDR     R12,[R12]
        ADRL    R14,greys_mode
        LDRB    R1,[R14]
        STRB    R1,[R14,#1]             ; last time
        MOV     R1,#0
        STRB    R1,[R14]                ; assume not a grey mode at first
        Pull    "R12"
        ]

        MOV     R1,R0                   ; R1 -> string form of number
        MOV     R0,#10                  ; R0 = default base
        SWI     XOS_ReadUnsigned
        [ Medusa
        BVS     setmode_from_specifier
        |
        Pull    "PC",VS
        ]

        LDR     R12,[R12]               ; get workspace pointer!
        CMP     R2,#255
        BHI     bad_param_exit2
        LDR     R14,currentmode         ; only set the mode if different
        Debug   xx,"*WimpMode: old,new =",R14,R2
        CMP     R2,R14
        MOVNE   R0,R2
        SWINE   XWimp_SetMode

        Pull    "PC"

        [ Medusa
setmode_from_specifier
; R1 -> string
     [ {TRUE}
        ; See if the OS can handle the conversion for us
        MOV     R0,#ScreenModeReason_ModeStringToSpecifier
        SUB     SP,SP,#ModeSelector_MaxSize
        MOV     R2,SP
        MOV     R3,#ModeSelector_MaxSize
        SWI     XOS_ScreenMode
        ADDVS   SP,SP,#ModeSelector_MaxSize
        BVS     setmode_from_specifier_manual
        MOV     R0,SP
        SWI     XWimp_SetMode
        ; TODO anything extra here?
        ADD     SP,SP,#ModeSelector_MaxSize
        Pull    "PC"
setmode_from_specifier_manual
     ]
        MOV     R0,#-1
        LDR     R12,[R12]
        Push    "R12"
        MOV     R12,SP                  ; R12 not required yet
        Push    "R0"                    ; end of params
        [ DoubleHeightVDU4
	MOV	R3, #VduExt_ModeFlags
	MOV	R4, #1			; get back to this  (it's [R12, #-16])
	MOV	R5, #VduExt_ScrBRow
	MOV	R6, #-1			; get back to this too... ([R12, #-8])
	Push	"R3-R6"
        ]
; use R4-R6 for xres,yres,bpp, R3 frame rate
        MOV     R4,#-1
        MOV     R5,#-1
        MOV     R6,#-1                  ; must specify these
        MOV     R3,#-1
scan_for_param
        LDRB    R0,[R1],#1
        CMP     R0,#32
        BLO     scan_ended
        BEQ     scan_for_param
        CMP     R0,#","
        BEQ     scan_for_param
        ASCII_UpperCase R0,R14          ; this is safe
        CMP     R0,#"E"
        BEQ     get_eig_factors
        CMP     R0,#"X"
        BEQ     get_xres
        CMP     R0,#"Y"
        BEQ     get_yres
        CMP     R0,#"C"
        BEQ     get_colours
        CMP     R0,#"G"
        BEQ     get_greys
        CMP     R0,#"F"
        BEQ     get_frame
; oh dear, user error
bad_param_exit
        MOV     SP,R12
        Pull    "R12"
        ]

bad_param_exit2
;R12 needed by error lookup
        MyXError        BadParameters
        Pull    "PC"
        ; SMC: use international error block as "BadParameters" token did not exist
        MakeInternatErrorBlock  BadParameters,,BadParm

        [ Medusa
get_eig_factors
        LDRB    R0,[R1],#1
        ASCII_UpperCase R0,R14
        CMP     R0,#"X"                  ; only EX EY allowed
        MOVEQ   R0,#VduExt_XEigFactor
        CMP     R0,#"Y"
        MOVEQ   R0,#VduExt_YEigFactor
        CMPNE   R0,#VduExt_XEigFactor
        BNE     bad_param_exit
        Push    "R0"
        MOV     R0,#&2000000a           ; base 10
        MOV     R2,#3                   ; only allow 0-3 (note OS can cope with 4)
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        Pull    "R0"
        Push    "R0,R2"
	[ DoubleHeightVDU4
	TEQ	R0,#VduExt_XEigFactor	; squirrel this away...
	STREQ	R2,[R12,#-16]
	STRNE	R2,[R12,#-8]
	]
        B       scan_for_param

get_xres
        CMP     R4,#-1
        BNE     bad_param_exit                  ; only one x allowed
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R4,R2
        B       scan_for_param

get_yres
        CMP     R5,#-1
        BNE     bad_param_exit                  ; only one y allowed
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R5,R2
        B       scan_for_param

get_frame
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R3,R2
        B       scan_for_param

get_colours
        CMP     R6,#-1
        BNE     bad_param_exit                  ; only one C or G allowed
; only 2,4,16,64,256,32T,32K,16M are valid
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R0,#-1
        CMP     R2,#2
        MOVEQ   R0,#0                           ; 1bpp
        CMP     R2,#4
        MOVEQ   R0,#1                           ; 2bpp
        CMP     R2,#256
;        MOVEQ   R0,#3                           ; NCol
;        MOVEQ   R2,#255
;        Push    "R0,R2",EQ
        CMPNE   R2,#64
        MOVEQ   R0,#3                           ; 8bpp
        CMP     R0,#-1
        MOVNE   R6,R0
        BNE     scan_for_param
        LDRB    R0,[R1]
        ASCII_UpperCase R0,R14
        CMP     R2,#16
        BNE     %FT05
        CMP     R0,#"M"
        ADDEQ   R1,R1,#1
        MOVEQ   R6,#5                           ; 32bpp (16M)
        MOVNE   R6,#2                           ; 4bpp  (16)
        B       scan_for_param
5
        CMP     R2,#32
        BNE     bad_param_exit
        ; must be either T or K
        CMP     R0,#"T"
        CMPNE   R0,#"K"
        BNE     bad_param_exit
        ADD     R1,R1,#1                        ; move it along
        MOV     R6,#4                           ; 16bpp
        B       scan_for_param

get_greys
        CMP     R6,#-1
        BNE     bad_param_exit                  ; only one C or G allowed
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        CMP     R2,#16
        MOV     R6,#3+128                         ; 8bpp (+128 makes the palette get hit later)
        MOVEQ   R6,#2+128                         ; 4bpp
        CMPNE   R2,#256
        CMPNE   R2,#4
        CMPNE   R2,#2
        BNE     bad_param_exit
        CMP     R2,#4
        MOVEQ   R6,#1
        CMP     R2,#2
        MOVEQ   R6,#0                             ; no palette munging so not +128
        CMP     R2,#256
        MOVEQ   R0,#3                           ; NCol
        MOVEQ   R2,#255
        Push    "R0,R2",EQ                      ; must be set for 256 greys
        MOVEQ   R0,#0                           ; ModeFlags
        MOVEQ   R2,#128
        Push    "R0,R2",EQ                      ; must be set for 256 greys

        B       scan_for_param

scan_ended
        CMP     R4,#-1
        CMPNE   R5,#-1
        CMPNE   R6,#-1
        BEQ     bad_param_exit          ; all must be supplied
        Push    "R3"                    ; frame rate
        TST     R6,#128
        BICNE   R6,R6,#128              ; greys required
        Push    "R4-R6"                 ; xres, yres bpp
        ORRNE   R6,R6,#128
        MOVEQ   R6,#0
        MOV     R0,#1                   ; mode selector flags
        Push    "R0"

	[ DoubleHeightVDU4
	; Need to establish what XEigFactor and YEigFactor are
	LDR	R0,[R12,#-8]
	CMP	R0,#-1
	BNE	%FT01
	CMP	R5, R4, LSR #1		; is yres >= xres/2?
	MOVHS	R0,#1
	MOVLO	R0,#2
01	LDR	R14,[R12,#-16]
	; is yeig(R0) > xeig(R14), don't double height
	CMP	R0,R14
	MOVHI	R0,#0
	MOVHI	R14,R5,LSR #3
	MOVLS	R0,#ModeFlag_DoubleVertical
	MOVLS	R14,R5,LSR #4
	SUB	R14,R14,#1
	STR	R0,[R12,#-16]		; store the mode flags
	STR	R14,[R12,#-8]		; store the text height
	]
        MOV     R0,SP
        Push    R12
        LDR     R12,[R12]               ; the R12 that was saved on the stack
        ADRL    R14,greys_mode
        STRB    R6,[R14]
        SWI     XWimp_SetMode           ; may update greys_mode
        Pull    R12,VS                  ; SMC: only pull R12 if VS, need R12=wsptr to load greys_mode below
        BVS     exit_setmode

        ADRL    R14,greys_mode          ; SMC: get possibly updated greys_mode
        LDRB    R6,[R14]
        TST     R6,#128
        Pull    R12                     ; SMC: get back R12->old top of stack
        BEQ     exit_setmode

        MOV     SP,R12
        NOP
        Pull    "R12"

        BL      recalc_greys_palette
; palette changed so send message
        SWI       XColourTrans_InvalidateCache
        [ false
; as we haven't done the wimp palette, no need
        MOV     R14,#ms_data            ; size of block
        STR     R14,[sp,#-ms_data]!
        MOV     R0,#User_Message
        MOV     R1,sp
        MOV     R2,#0
        STR     R2,[R1,#ms_yourref]
        MOV     R14,#Message_PaletteChange
        STR     R14,[R1,#ms_action]
        SWI     XWimp_SendMessage
        ADD     sp,sp,#ms_data          ; correct stack
        ]
        Pull    "PC"

recalc_greys_palette
        Push    "R0-R9,lr"
        ADRL    R14,greys_mode
        LDRB    R6,[R14]
        TEQ     R6,#128+3
        BEQ     set_greys256
        [ false
set_grey_palette
        ; must splat the palette for the grey scales
        SUB     SP,SP,#80
        MOV     R1,SP
        SWI     XWimp_ReadPalette
        ; preserves border and pointer colours
        MOV     R0,#8
        ADD     R1,R1,#32               ; jump first 8 colours
        ADR     R2,greys_16
5
        LDR     R14,[R2],#4
        STR     R14,[R1],#4
        SUBS    R0,R0,#1
        BNE     %BT5
        MOV     R1,SP
        SWI     XWimp_SetPalette
        |
        ; must set palette directly
set_grey_palette

        Push    "R9"
        MOV     R9,#&23                 ; PaletteV
        MOV     R0,#8                   ; start at colour 8
        MOV     R1,#16
        MOV     R4,#2                   ; set palette, R4 becomes zero on return
5
        Push    "R0-R5,R9"
        ADR     R2,greys_16
        SUB     R2,R2,#32
        LDR     R2,[R2,R0, LSL #2]
        MOV     R3,R2
        SWI     XOS_CallAVector
        Pull    "R0-R5,R9"
        Pull    "R9",VS
        BVS     exit_setmodegreys
        ADD     R0,R0,#1

        CMP     R0,#16
        BNE     %BT5
        Pull    "R9"
        ]

exit_setmodegreys
        Pull    "R0-R9,PC"



exit_setmode
        MOV     SP,R12
        Pull    "R12,PC"

set_greys256
        ; must set palette directly
        Push    "R9"
        MOV     R9,#&23                 ; PaletteV
        MOV     R0,#0
        MOV     R1,#16
        MOV     R2,#0
        MOV     R3,R2
        LDR     R5,=&01010100
        MOV     R4,#2                   ; set palette, R4 becomes zero on return
5
        Push    "R0-R5,R9"
        SWI     XOS_CallAVector
        Pull    "R0-R5,R9"
        Pull    "R9",VS
        BVS     exit_setmode
        ADD     R0,R0,#1
        ADD     R2,R2,R5
        MOV     R3,R2
        CLRV                            ; clear overflow for R0>127
        CMP     R0,#256
        BNE     %BT5
        Pull    "R9"

        [ false
        B       set_grey_palette         ; update wimp palette
        ]

        [ false
; now set wimp palette with first 16 colours (! is this logical captain?)
        SUB     SP,SP,#80
        MOV     R1,SP
        SWI     XWimp_ReadPalette
        ; preserves border and pointer colours
        MOV     R0,#16
        LDR     R2,=&01010100
        MOV     R3,#0
5
        STR     R3,[R1],#4
        ADD     R3,R3,R2
        SUBS    R0,R0,#1
        BNE     %BT5
        MOV     R1,SP
        SWI     XWimp_SetPalette

        ]

        B       exit_setmodegreys


greys_16
        DCD     &10101000,&c0c0c000,&60606000,&20202000
        DCD     &e0e0e000,&40404000,&a0a0a000,&80808000
        ]

;----------------------------------------------------------------------------

; *IconSprites <filename>
; In:   R0 -> parameters
;       R1 = number of parameters (1)
; Out:  R0-R6 may be corrupted
; call Wimp_SpriteOp (11 = merge) to add sprites to the common sprite area
; tries "<filename>23" if hi-res mono, and/or "<filename>22" if 2x2 OS units

IconSprites_Code
        Push    "R7-R9,LR"
        LDR     wsptr,[R12]
;
      [ :LNOT: Medusa
        Push    "R0"
        MOV     R0,#ModHandReason_RMADesc
        SWI     XOS_Module
        MOV     R9,R3                   ; how much free RMA there was before merging
        Pull    "R0"
      ]
        MOV     R8,R0                   ; R8 -> original filename
        MOV     R5,R0                   ; R5 = position at which to insert system variable
01      LDRB    LR,[R0],#1              ; skip leading space
        TEQ     LR,#' '
        BEQ     %BT01
02      TEQ     LR,#'.'                 ; remember last '.' or ':'
        TEQNE   LR,#':'
        MOVEQ   R5,R0
        CMP     LR,#' '
        LDRHIB  LR,[R0],#1
        BHI     %BT02
        SUB     R7,R0,R8                ; length of original string incl terminator
        ADD     R7,R7,#IconThemeSysVarLen + 3
        BIC     R7,R7,#3                ; R7 = length to allocate for string with inserted system variable
        SUB     SP,SP,R7

        MOV     R0,R8
        MOV     R3,SP
03      LDRB    LR,[R0]                 ; skip leading spaces
        TEQ     LR,#' '
        ADDEQ   R0,R0,#1
        BEQ     %BT03
04      TEQ     R0,R5                   ; if at appropriate position
        BNE     %FT06
        ADR     R2,IconThemeSysVar
        MOV     R4,#IconThemeSysVarLen
05      LDRB    LR,[R2],#1              ; then insert system variable
        STRB    LR,[R3],#1
        SUBS    R4,R4,#1
        BNE     %BT05
06      LDRB    LR,[R0],#1              ; copy rest of string as is, including terminator
        STRB    LR,[R3],#1
        CMP     LR,#' '
        BHI     %BT04

        MOV     R3,SP                   ; R3 -> pathname with system variable inserted
01      LDRB    R5,romspr_suffix
        LDRB    R6,romspr_suffix+1
        SUB     R5,R5,#'0'
        SUB     R6,R6,#'0'
        SUB     sp,sp,#4
02
      [ SpritesA
        CMP     R5,R6
        LDREQB  R0,alphaspriteflag
        CMPEQ   R0,#255
        MOVEQ   R5,#'A'-'0'             ; Try alpha before square pixels
      ]
025
        ADD     R14,R5,R6,LSL #8
        ADD     R14,R14,#'0'
        ADD     R14,R14,#'0':SHL:8
        STR     R14,[sp]
        MOV     R0,sp
        MOV     R1,R3
        BL      getspritefname          ; R1 -> <filename><x><y><bpp>
        MOV     R2,R1                   ; R2 -> filename
;
        MOV     R0,#SpriteReason_MergeSpriteFile
        SWI     XWimp_SpriteOp
        BVC     %FT03

      [ SpritesA
        CMP     R5,#'A'-'0'
        MOVEQ   R5,R6
        BEQ     %BT025                  ; Try square pixels if alpha failed
      ]

        TEQ     R6,#3
        MOVEQ   R6,#2
        BEQ     %BT02                   ; after Sprites23, try Sprites22

        CMP     R5,R6
        MOVLO   R5,R5,LSL#1
        MOVHI   R6,R6,LSL#1
        BNE     %BT02                   ; after rectangular pixels, try next squarer version

      [ Sprites11
        TEQ     R5,#1
        MOVEQ   R5,#2
        MOVEQ   R6,#2
        BEQ     %BT02                   ; after Sprites11, try Sprites22
      ]

      [ SpritesA
        LDRB    R0,alphaspriteflag
        CMP     R0,#0
        BEQ     %FT029
        MOV     R14,#'A'
        STR     R14,[sp]
        MOV     R0,sp
        MOV     R1,R3
        BL      getspritefname
        MOV     R2,R1
        MOV     R0,#SpriteReason_MergeSpriteFile
        SWI     XWimp_SpriteOp          ; try just <filename>A before falling back to the original
        BVC     %FT03
029
      ]

        MOV     R2,R3                   ; R2 -> original filename
        MOV     R0,#SpriteReason_MergeSpriteFile
        SWI     XWimp_SpriteOp
03      ADD     sp,sp,#4

        TEQ     R3,R8                   ; were we trying with the system variable inserted?
        ADDNE   SP,SP,R7                ; yes, so junk stack frame
        BVC     %FT04
        BEQ     %FT95                   ; no, and an error, so give up
        MOV     R3,R8                   ; yes, and an error, so try again without the system variable
        B       %BT01
04

 [ windowsprite
  [ ThreeDPatch
	MOV	R0,#0
	BL	reset_all_tiling_sprites
  |
        MOV     R0,#-1
        STR     R0,tiling_sprite
  ]
 ]

      [ :LNOT: Medusa                   ; Medusa uses DA
        MOV     R0,#1                   ; The merge might have bumped up the RMA while both sets of sprites
        MOV     R1,#-&10000000          ; were loaded. Try and shrink RMA.
        SWI     XOS_ChangeDynamicArea   ; -256M will give "Unable to move memory"
        MOV     R0,#1
        MOV     R1,R9                   ; Put back the same amount of free space as on entry
        SWI     XOS_ChangeDynamicArea   ; May fail if APPSPACE is in use, that's ok.
        CLRV                            
      ]
95
        Pull    "R7-R9,PC"

IconThemeSysVar = "<Wimp$IconTheme>"
IconThemeSysVarLen * . - IconThemeSysVar
        ALIGN

;............................................................................

; In    R0 -> suffix to add to filename
;       R1 -> sprite filename
; Out   R1 -> <filename><suffix>
;       R2 -> start of suffix as added to filename

getspritefname
        Push    "R0,LR"

        ADRL    R2, path_buffer         ; watchdogerrtxt isn't big enough for long pathnames, and was getting
                                        ; overwritten by the new Service_SwitchingOutputToSprite handler

01      LDRB    R14,[R1],#1             ; skip leading spaces
        CMP     R14,#" "
        BEQ     %BT01
02      CMP     R14,#32                 ; stop on space or ctrl-char
        STRHIB  R14,[R2],#1
        LDRHIB  R14,[R1],#1
        BHI     %BT02

        MOV     R1,R2
        BL      copy0                   ; copy from R0 to R1

        ADRL    R1, path_buffer
        DebugS  xx,"getspritefname: ",R1

        Pull    "R0,PC"

;............................................................................

; Entry:  R0 = sprite reason code
;         all other regs except R1 set up as normal for OS_SpriteOp
; Exit:   operation performed on RAM / ROM sprite areas
; Error:  "Bad parameter passed to Wimp in R0" if attempt to write to sprites
;

SWIWimp_SpriteOp
;        MyEntry "SpriteOp"

        AND     R0,R0,#&FF              ; just in case!
        TEQ     R0,#SpriteReason_MergeSpriteFile
        BEQ     %FT01
        TEQ     R0,#SpriteReason_SetPointerShape
        BEQ     %FT02
        TEQ     R0,#99                  ; fast find
        BEQ     dospriteop
        CMP     R0,#SpriteReason_BadReasonCode
        BHS     err_badR0
;
        ADR     R1,spritebits           ; disallow all other write operations
        MOV     R14,R0,LSR #5
        LDR     R1,[R1,R14,LSL #2]
        AND     R14,R0,#31
        MOVS    R1,R1,LSL R14           ; top bit is now set/unset accordingly
        BMI     err_badR0

dospriteop
        MOV     R1,#1
        STR     R1,thisCBptr
        STR     R1,lengthflags
        STR     R2,spritename
        LDR     R1,list_at
        TEQ     R1,#0
        BEQ     dospriteopnext          ; no list yet.
        TEQ     R0,#36                  ; set pointer shape
        BEQ     dospriteopnext
        Push    "R2"                    ; needs preserving
        BL      getspriteaddr
        STRVC   R2,spritename
        Pull    "R2"
        MOVVC   R1,#0
        STRVC   R1,lengthflags          ; use pointer
        BVS     sprite_not_found
        TEQ     R0,#99                  ; fast sprite existence
        BEQ     ExitWimp
dospriteopnext
        TEQ     R0,#99
        MOVEQ   R0,#SpriteReason_ReadSpriteSize
        MOV     R1,#1                   ; incase daft routines expect it
        BL      wimp_SpriteOp
        STMIA   sp, {R1-R10}            ; return correct results to caller
        B       ExitWimp

01      BL      int_merge_sprites
        B       ExitWimp

02      TST     R3,#1:SHL:5             ; is it trying to set up the palette?
        MOVEQ   R3,#1                   ; don't program the border colour
        BLEQ    setmousepalette         ; palette defaults to central version
        MOV     R0,#SpriteReason_SetPointerShape
        LDMIA   sp,{R1-R7}
        B       dospriteop

spritebits   ;    0       8      16      24     31
        DCD     2_11100000011000111000000001110111
        DCD     2_11010010001011110000001001101101
        DCD     2_10111111111111111111111111111111
        ASSERT  SpriteReason_BadReasonCode < 96

sprite_not_found
        ADR     R0,SpriteDoesntExist
        BL      ErrorLookup
        B       ExitWimp

SpriteDoesntExist
        DCD     134
        DCB     "BadSprite",0
        ALIGN


;............................................................................

; Entry:  R2 --> sprite file name
;         [baseofsprites] = current RAM sprite area pointer
; Exit:   [baseofsprites] = new RAM sprite area pointer (area extended)

int_merge_sprites
        Push    "R1-R5,LR"              ; R2 on stack = filename ptr
;
        DebugS  spr,"File name is ",r2

        MOV     R1,R2
        MOV     R0,#OSFile_ReadInfo
        SWI     XOS_File                ; R4 = file length
        Debug   spr,"File size is ",r4
        Debug   spr,"Object type is ",r0
        TEQ     R0,#object_file         ; must be a file (NB doesn't affect V)
        MOVNE   R2,#object_nothing
        MOVNE   R0,#OSFile_MakeError    ; state which file is missing
        SWINE   XOS_File
        BVS     %FT98
;
        MOV     R2,R2,LSL # 12
        MOV     R2,R2,LSR # 20
        LDR     R14,=FileType_Squash
        TEQ     R2,R14
        BEQ     %FT99
;
        LDR     R2,baseofsprites

        MOVVC   R0,#ModHandReason_ExtendBlock
        MOVVC   R3,R4                   ; extend by enough to cover new file
        BLVC    allocatespritememory
        STRVC   R2,baseofsprites        ; do this now just in case !!!
      [ SpritePriority
        BVS     %FT06
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseofhisprites
        STRNE   R2, baseoflosprites
06
      ]

        DebugE  spr,"Extending sprite block"
      [ debugspr
        BVS     %FT55
        Debug   spr,"baseofsprites (1)  ",r2
55
      ]
;
        LDRVC   R14,[R2,#saEnd]
        ADDVC   R14,R14,R3
        STRVC   R14,[R2,#saEnd]

        [ debugnk
        ADD     R1,R14,R2
        SUB     R1,R1,#4
        Debug   nk,"End of sprite area",R1
        LDR     R0,[R1]
        STR     R0,[R1]
        MOV     R0,R1
        SWI     XOS_ValidateAddress
        BCC     %FT01
        Debug   nk,"Oh dear ",R1
        ]
01
        MOVVC   R1,R2
        LDRVC   R2,[sp,#1*4]            ; R2 --> file name
        MOVVC   R0,#SpriteReason_MergeSpriteFile
        ADDVC   R0,R0,#&100
      [ debugspr
        BVS     %FT55
        Debug   spr,"(1) r0 r1 r2  ",r0,r1,r2
55
      ]
        SWIVC   XOS_SpriteOp

        Debug   nk,"Returned from merge ",R0
;
        LDRVC   R14,[R1,#saFree]        ; compact area down now
        LDRVC   R0,[R1,#saEnd]
        STRVC   R14,[R1,#saEnd]
        SUBVC   R3,R14,R0               ; R3 = amount to change size by
        LDRVC   R2,baseofsprites
      [ debugspr
        BVS     %FT55
        Debug   spr,"(2) r0 r1 r14 r2  ",r0,r1,r14,r2
55
      ]
        MOVVC   R0,#ModHandReason_ExtendBlock
        BLVC    allocatespritememory
        STRVC   R2,baseofsprites
      [ SpritePriority
        BVS     %FT06
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseofhisprites
        STRNE   R2, baseoflosprites
06
      ]
      [ debugspr
        BVS     %FT55
        Debug   spr,"baseofsprites (2)  ",r2
55
      ]
;
        MOVVC   R1,#Service_WimpSpritesMoved
        LDRVC   R2,baseofromsprites     ; R2 -> ROM area
        LDRVC   R3,baseofsprites        ; R3 -> RAM area
        SWIVC   XOS_ServiceCall
;
        BLVC    freelist                ; mark sprite cache list as invalid
;
98
        Pull    "R1-R5,PC"

99
        MyXError        WimpBadSprites
        Pull    "R1-R5,PC"

        MakeErrorBlock  WimpBadSprites

;............................................................................

; Exit:  R0 --> common sprite area (ROM)
;        R1 --> common sprite area (RAM)

SWIWimp_BaseOfSprites
;        MyEntry "BaseOfSprites"

        LDR     R0,baseofromsprites
        LDR     R1,baseofsprites
        STR     R1,[sp,#0*4]            ; overwrite stacked value
        B       ExitWimp


;-----------------------------------------------------------------------------
; Initialisation - claim work area
;-----------------------------------------------------------------------------

WimpVarPath     DCB     "WindowManager$Path", 0
WimpDefPath     DCB     "Resources:$.Resources.Wimp."
                DCB     0
WimpVarTheme    DCB     "Wimp$IconTheme", 0
WimpDefTheme    DCB     UserIF :CC: "."
                DCB     0
                ALIGN

Init
        Push    "R0-R12,LR"

; open debugging file

      [ debug :LAND: :LNOT: hostvdu :LAND: :LNOT: pdebug_module
        Debug_Open "<Wimp$Debug>1"
      ]

; initialise WindowManager$Path if not already done

        ADR     R0, WimpVarPath
        MOV     R2, #-1
        MOV     R3, #0
        MOV     R4, #VarType_String     ; Do not expand, to bypass a bug in OS_ReadVarVal
        SWI     XOS_ReadVarVal          ; returns R2=0 if doesn't exist
        CMP     R2, #0                  ; clears V as well!

        ADREQ   R0, WimpVarPath
        ADREQ   R1, WimpDefPath
        MOVEQ   R2, #?WimpDefPath
        MOVEQ   R3, #0
        MOVEQ   R4, #VarType_String
        SWIEQ   XOS_SetVarVal
        BVS     exitinit1

; initialise Wimp$IconTheme to the build UserIF if not set by the user

        ADR     R0, WimpVarTheme
        MOV     R2, #-1
        MOV     R3, #0
        MOV     R4, #VarType_String     ; Do not expand, to bypass a bug in OS_ReadVarVal
        SWI     XOS_ReadVarVal          ; returns R2=0 if doesn't exist
        CMP     R2, #0                  ; clears V as well!

        ADREQ   R0, WimpVarTheme
        ADREQ   R1, WimpDefTheme
        MOVEQ   R2, #?WimpDefTheme
        MOVEQ   R3, #0
        MOVEQ   R4, #VarType_String
        SWIEQ   XOS_SetVarVal           ; Ignore error

; claim workspace

        LDR     R2,[R12]                ; load from private word
        CMP     R2,#0
        BNE     gotwork                 ; no need to reclaim block
;
        LDR     R3,=maxwork
        MOV     R0,#ModHandReason_Claim
        SWI     XOS_Module
        BVS     errcantclaim
        STR     R2,[R12]

; need to claim save area for when something else (eg. font manager) switches
; output.
        Push    "R0-R3"
        MOV     wsptr,R2

        [ DebugMemory
        ADRL    R0,memory_claims
        MOV     R2,#-1
        STR     R2,[R0,#4]
        STR     R2,[R0]
        MOV     R2,#0
        STRB    R2,reentrancyflag

        ]

        MOV     R0,#SpriteReason_ReadSaveAreaSize
        MOV     R2,#0
        SWI     XOS_SpriteOp                    ; get size of area
        MOVVC   R0,#ModHandReason_Claim
        BLVC    XROS_Module
        MOVVC   R0,#0
        STRVC   R0,[R2]
        MOVVS   R2,#0
        ADRL    R14,save_context
        STR     R2,[R14]
        Pull    "R0-R3"

gotwork
        MOV     wsptr,R2

        MOV     R0,#6
        MOV     R1,#0
        MOV     R2,#OSRSI6_IRQsema
        SWI     XOS_ReadSysInfo
        MOVVS   R2,#0
        CMP     R2,#0
        LDREQ   R2,=Legacy_IRQsema
        STR     R2,ptr_IRQsema
        MOV     R0,#6
        MOV     R2,#OSRSI6_DomainId
        SWI     XOS_ReadSysInfo
        MOVVS   R2,#0
        CMP     R2,#0
        LDREQ   R2,=Legacy_DomainId
        STR     R2,ptr_DomainId

        MOV     R1, #0
        STR     R1, messages            ; no messsages open, in case of error lookups
      [ DynamicAreaWCF
        BL      initwcfda
      ]
;
        BL      initptrs                ; also claims ChangeEnvironmentV
;
        SWI     XOS_ReadMemMapInfo      ; R0 = page size, R1 = number of pages
        MOV     R1,#DefaultNextSlot
        DivRem  R2,R1,R0,R14,norem      ; R2 = number of pages for 640k (or whatever)
        STR     R2,slotsize
;
 [ DontCheckModeOnInit
        MOV     r0, #-1
        STR     r0, currentmode
 |
        BL      read_current_configd_mode
 ]
;
        ; Read WimpFlags
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpFlagsCMOS
        SWI     XOS_Byte
        MOVVS   R2,#0
        STRB    R2,sysflags
;
        ; Read WimpDragDelay
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpDragTimeCMOS
        SWI     XOS_Byte
        [ false
        EORVC   R0,R2,#default_drag_timelimit
        |
        ANDVC   R3, R2, #&0F
        EORVC   R3, R3, #default_drag_timelimit
        MOVVC   R1, #WimpDragMoveLimitCMOS
        SWIVC   XOS_Byte
        ANDVC   R4, R2, #1 :SHL: 0
        MOVVC   R0, R3, LSL R4
        TEQ     R4, #0 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        ]
        MOVVS   R0,#default_drag_timelimit
        ADD     R0,R0,R0,ASL #2        ; R0*5
        MOV     R0,R0,ASL #1           ; R0*10
        STR     R0,drag_timelimit
;
        ; Read WimpDoubleClickDelay
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpDoubleClickTimeCMOS
        SWI     XOS_Byte
        [ false
        EORVC   R0,R2,#default_doubleclick_timelimit
        |
        ANDVC   R3, R2, #&0F
        EORVC   R3, R3, #default_doubleclick_timelimit
        MOVVC   R1, #WimpDoubleClickMoveLimitCMOS
        SWIVC   XOS_Byte
        ANDVC   R4, R2, #1 :SHL: 0
        MOVVC   R0, R3, LSL R4
        TEQ     R4, #0 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        ]
        MOVVS   R0,#default_doubleclick_timelimit
        ADD     R0,R0,R0,ASL #2        ; R0*5
        MOV     R0,R0,ASL #1           ; R0*10
        STR     R0,doubleclick_timelimit
;
        ; Read WimpDragMove
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpDragMoveLimitCMOS
        SWI     XOS_Byte
        [ true
        ANDVC   R2, R2, #&7C
        ]
        EORVC   R0,R2,#default_drag_movelimit
        MOVVS   R0,#default_drag_movelimit
        STRB    R0,drag_movelimit
;
        ; Read WimpDoubleClickMove
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpDoubleClickMoveLimitCMOS
        SWI     XOS_Byte
        [ true
        ANDVC   R2, R2, #&7C
        ]
        EORVC   R0,R2,#default_doubleclick_movelimit
        MOVVS   R0,#default_doubleclick_movelimit
        STRB    R0,doubleclick_movelimit
;
        ; Read WimpAutoMenuDelay
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpAutoSubMenuTimeCMOS
        SWI     XOS_Byte
        [ false
        MOVVS   R0,#0
        ADDVC   R0,R2,R2,ASL #2        ; R0*5
        MOVVC   R0,R0,ASL #1           ; R0*10
        |
        ANDVC   R0, R2, #&0F
        EORVC   R0, R0, #default_automenudelay
        TST     R2, #1 :SHL: 4 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        MOVNE   R0, R0, LSL #1
        MOVVS   R0, #default_automenudelay
        ADD     R0, R0, R0, LSL #2
        MOV     R0, R0, LSL #1
        ]
        STR     R0,automenu_timelimit
;
        ; Read WimpMenuDragDelay
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpMenuDragDelayCMOS
        SWI     XOS_Byte
        [ false
        MOVVS   R0,#0
        ADDVC   R0,R2,R2,ASL #2        ; R0*5
        MOVVC   R0,R0,ASL #1           ; R0*10
        |
        ANDVC   R0, R2, #&0F
        EORVC   R0, R0, #default_menudragdelay
        TST     R2, #1 :SHL: 4 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        MOVNE   R0, R0, LSL #1
        MOVVS   R0, #default_menudragdelay
        ADD     R0, R0, R0, LSL #2
        MOV     R0, R0, LSL #1
        ]
        STR     R0,menudragdelay
;
        ; Read WimpIconBarSpeed
        ADR     R3, iconbarlogtable
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpAutoSubMenuTimeCMOS
        SWI     XOS_Byte
        MOVVC   R2, R2, LSR #5
        EORVC   R2, r2, #default_iconbarspeed
        MOVVS   R2, #default_iconbarspeed
        LDR     R0, [R3, R2, LSL#2]
        STR     R0, iconbar_scroll_speed
;
        ; Read WimpIconBarAcceleration
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpMenuDragDelayCMOS
        SWI     XOS_Byte
        MOVVC   R2, R2, LSR #5
        EORVC   R2, r2, #default_iconbaraccel
        MOVVS   R2, #default_iconbaraccel
        LDR     R0, [R3, R2, LSL#2]
        STR     R0, iconbar_scroll_accel
;
        ; Read WimpSpritePrecedence
      [ SpritePriority
        MOV     R0, #ReadCMOS
        MOV     R1, #DesktopFeaturesCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 5 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STR     R0, preferredpool
      ]
;
        ; ReadWimpButtonType
      [ BounceClose
        MOV     R0, #ReadCMOS
        MOV     R1, #DesktopFeaturesCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 6 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, buttontype
      ]
;
        ; Read WimpIconiseButton
      [ IconiseButton
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDragMoveLimitCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 7 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, iconisebutton
      ]
;
        ; ReadWimpStickyEdges
      [ StickyEdges
        MOV     R0, #ReadCMOS
        MOV     R1, #DesktopFeaturesCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 6 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, stickyedges
      ]
;
        ; Read WimpAutoFrontIconBar
      [ PoppingIconBar
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDoubleClickMoveLimitCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 7 ;preserves V
        MOVEQ   R0, #1
        MOVNE   R0, #0
        MOVVS   R0, #1
        STRB    R0, popiconbar
;
        ; Read WimpAutoFrontDelay
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDoubleClickTimeCMOS
        SWI     XOS_Byte
        MOVVC   R3, R2, LSR #4
        EORVC   R3, R3, #default_autofrontdelay
        MOVVC   R1, #WimpDoubleClickMoveLimitCMOS
        SWIVC   XOS_Byte
        TST     R2, #1 :SHL: 1 ;preserves V
        MOVEQ   R0, R3
        MOVNE   R0, R3, LSL #1
        ADDNE   R0, R0, R0, LSL #2
        MOVVS   R0, #default_autofrontdelay
        ADD     R0, R0, R0, LSL #2
        MOV     R0, R0, LSL #1
        STR     R0, popiconbar_pause
      ]
;
        ; Read WimpAutoScrollDelay
      [ Autoscr
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDragTimeCMOS
        SWI     XOS_Byte
        MOVVC   R3, R2, LSR #4
        EORVC   R3, R3, #default_autoscrolldelay
        MOVVC   R1, #WimpDragMoveLimitCMOS
        SWIVC   XOS_Byte
        TST     R2, #1 :SHL: 1 ;preserves V
        MOVEQ   R0, R3
        MOVNE   R0, R3, LSL #1
        ADDNE   R0, R0, R0, LSL #2
        MOVVS   R0, #default_autofrontdelay
        STRB    R0, autoscr_default_pause ; not *10
      ]
;
        ; Read WimpClickSubmenu
      [ ClickSubmenus
        MOV     R0, #ReadCMOS
        MOV     R1, #Misc1CMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 0 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, clicksubmenuenable
      ]
;
      [ ThreeDPatch
	; set up the 3dpatch configuration
	MOV	R0,#ThreeDFlags_Default
	STR	R0,ThreeDFlags
	LDR	R0,=rgb_white
	STR	R0,truemenuborderfacecolour
	STR	R0,truewindowborderfacecolour
	LDR	R0,=rgb_midlightgrey
	STR	r0,truemenuborderoppcolour
	LDR	R0,=rgb_middarkgrey
	STR	r0,truewindowborderoppcolour
	LDR	R0,=rgb_black
	STR	r0,truewindowoutlinecolour
      [ true
        MOV     R0,#arrowIconWidth_No3D
      |
        MOV     R0,#arrowIconWidth_3D
      ]
        STRB    R0,arrowIconWidth
      ]
;
        ADRL    R14,paltable            ; initialise palette
        ADR     R11,emergencypalette
        LDMIA   R11!,{R1-R10}
        STMIA   R14!,{R1-R10}
        LDMIA   R11,{R1-R10}
        STMIA   R14,{R1-R10}
;
        BL      initphyspalmap          ; initialise bits for colour mappings
;
        MOV     R0,#ModHandReason_Claim
        MOV     R3,#SpriteAreaCBsize    ; 16, I believe!
        BL      allocatespritememory
        MOVVS   R2,#nullptr
        STR     R2,baseofsprites        ; NB this is null if error occurs
      [ SpritePriority
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseofhisprites
        STRNE   R2, baseoflosprites
      ]
        STRVC   R3,[R2,#saEnd]
        STRVC   R3,[R2,#saFirst]
        STRVC   R3,[R2,#saFree]
        MOVVC   R14,#0                  ; no sprites defined
        STRVC   R14,[R2,#saNumber]
;
        ADRVC   R0,str_wimpcom
        ADRVC   R1,CommandWindow_var
        MOVVC   R2,#CommandWindow_varsize
        MOVVC   R3,#0
        MOVVC   R4,#VarType_Code
        SWIVC   XOS_SetVarVal
;
        BL      defaultfilters          ; reset the filter handlers + broadcast service
;
        MOV     R0,#0
        STR     R0,automenu_inactivetimeout
;
        STRB    R0,selecttable_crit     ; don't mind losing it on an invalidate cache service call
        STRB    R0,tsprite_needsregen   ; doesn't because there isn't one

        STR     R0,pixtable_at          ; no pixel translation table
        STR     R0,pixtable_size

        STR     R0,tpixtable_at         ; no tool pixel translation table
        STR     R0,tpixtable_size
        [ ToolTables
        STR     R0,ttt_activeset_at     ; no custom translation tables
        STR     R0,ttt_activeset_size
        ]
        STR     R0,list_at
        STR     R0,list_size            ; mark to indicate now list present
        STR     R0,filehandle
        STR     R0,fileaddress          ; reset the file address / handle (faults on template load!)
        STR     R0,tool_list
        STR     R0,tool_area
        STR     R0,tool_transtable      ; no tool sprites / tool sprites list
        STRB    R0,errorbox_open        ; the error box is not displayed
        STRB    R0,iconbar_needs_rs     ; check iconbar icon sizes
        [ NewErrorSystem
        STR     R0,watchdogcodew
        ]
        ADRL    R14,tool_list_backup
        STR     R0,[R14]
;        ADRL    R14,wimpmodebefore
;        STR     R0,[R14]
        ADRL    R14,greys_mode
        STR     R0,[R14]                ; splats misc
        [ NewErrorSystem
        STR     R0,watchdogarea         ; 'watchdog' isn't active
        ]
        [ StretchErrorText
        STR     R0,linecount
        ]
        STR     R0,wimpswiintercept
        STR     R0,plotsprCB
	[ PoppingIconBar
	STR	R0,iconbar_pop_state
	]
        [ TrueIcon3
        MOV     R0, #1:SHL:2
        STRB    R0, tinted_enable
        MOV     R0, #0
        STRB    R0, tinted_window
        STRB    R0, tinted_tool
        ]
        [ windowsprite
	 [ ThreeDPatch						
	MOV	R0,#0                   ; initialise all the tile sprite info blocks
	BL      reset_all_tiling_sprites
         |
        MOV     R0,#-1
        STR     R0,tiling_sprite        ; no tile sprite
        MOV     R0,#0
        STR     R0,tile_pixtable
         ]
        ]
        STRB    R0,checkedcolourmapping
        STR     R0,inversecolourmap
;
        BL      freetoolarea            ; tidy the tool area
;
        BL      declareresourcefsfiles  ; trap service call to pick them up
        BL      recalcmodevars
;
exitinit1
        STRVS   R0,[sp]                 ; bodge stack if error
        Pull    "R0-R12,PC"
        LTORG

errcantclaim
        MyXError WimpNoClaim

        STR     R0,[sp]                ; bodge stack on error
        Pull    "R0-R12,PC"
        MakeErrorBlock  WimpNoClaim

iconbarlogtable
        DCD     0, 20, 50, 100, 200, 500, 1000, 2000, -1

 [ SpritesA
checkalphasprites
        Entry   "R0-R2"
        ; Check if the kernel + SpriteExtend understand alpha masked sprites
        ; If they do, assume everything else is OK and that we can render them
        LDR     R0, testalphaspritemode
        MOV     R1, #VduExt_NColour
        SWI     XOS_ReadModeVariable
        CMP     R2, #1
        MOVNE   R0, #0
        BNE     %FT50
        LDR     R0, =SpriteReason_CheckSpriteArea+512
        ADR     R1, testalphaspritearea
        ADR     R2, testalphasprite
        SWI     XOS_SpriteOp
        MOVVS   R0, #0
        MOVVC   R0, #255
50
        STRB    R0, alphaspriteflag
        EXIT

testalphaspritearea
        DCD     &44
        DCD     1
        DCD     &10
        DCD     &44
testalphasprite
        DCD     &34
        DCD     &61 ; 'a'
        DCD     0
        DCD     0
        DCD     0   ; width
        DCD     0   ; height
        DCD     0   ; left bit
        DCD     0   ; right bit
        DCD     &2C ; image offset
        DCD     &30 ; mask offset
testalphaspritemode
        DCD     &80000001+(90<<1)+(90<<14)+(1<<27) ; 1bpp + alpha mask
        ; Image & mask data can just be any old garbage
 ]

;.................................................................................

; Declare resource files to ResourceFS
; This causes a Service_ResourceFSStarted, which is then trapped

fontinstall = "%FontInstall", 0
        ALIGN

declareresourcefsfiles
        Push    "R0,LR"

        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_RegisterFiles   ; ignore errors
        ADR     R0, fontinstall
        SWI     XOS_CLI                     ; ensure WIMPSymbol has been seen
        BL      getromsprites

        CLRV
        Pull    "R0,PC"


;.................................................................................
;
; Entry:  R3 = amount of memory to claim
; Exit:   R2 --> new block
;         bodgeblk is thrown away if present.

claimblock
        Push    "LR"
        MOV     R0,#ModHandReason_Claim
        BL     XROS_Module
        DebugE  rma,"Claim failed:"
        Pull    "PC"

claim
        Push    "LR"
        BL      release                 ; also sets R2 = wsptr
        SWI     XOS_Claim
        Pull    "PC"

release
        EntryS  "R0-R1"
01
        MOV     R2,wsptr
        SWI     XOS_Release             ; release until bored
        BVC     %BT01
        EXITS

;.................................................................................

str_wimpcom     DCB     "Wimp$State", 0
                ALIGN

emergencypalette
        GET     !Palette.s

;.................................................................................

Die
        Push    "R0-R3,R12,LR"
        LDR     wsptr,[R12]
;
        LDR     R14,taskcount

        Debug   die,"WimpDie: taskcount",R14

        TEQ     R14,#0                  ; Any tasks?
        MyXError WimpCantKill,NE        ; Yes then error
        ADDVS   SP,SP,#4                ; And drop R0
        Pull    "R1-R3,R12,PC",VS
;
        Debug   die,"Deregister resources"

        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles ; ignore errors
;
        BL      deallocateptrs          ; doesn't deallocate sprites
                                        ; does deallocate ALL windows

    [ :LNOT: KernelLocksFreePool
        BL      resetdynamic
    ]
    [ DynamicAreaWCF
        BL      destroywcfda
    ]

;
        MOV     R0,#ModHandReason_Free
        LDR     R2,baseofsprites
        BL      allocatespritememory         ; release the RAM sprite pool
;
        BL      freetoolarea
;
; Don't try freeing the command and error windows, its already happened.
;
        MOV     R0,#ChangeEnvironmentV
        ADRL    R1,ChangeEnvCode
        BL      release
;
        ADR     R0,str_wimpcom
        ADR     R1,CommandWindow_var
        MOV     R2,#-1
        MOV     R3,#0
        MOV     R4,#VarType_Code        ; must use this to destroy code vars
        SWI     XOS_SetVarVal
;
        BL      LoseMessages            ; just incase messages still open (unlikely)
;
        ADRL    R0,svc_callback
        MOV     R1,WsPtr
        SWI     XOS_RemoveCallBack      ; remove possible callback routine (may have been granted!)
;

        Debug   opn,"---- Debug closing down ----"

        Debug_Close

        CLRV                            ; no errors allowed here!
        Pull    "R0-R3,R12,PC"

        MakeErrorBlock WimpCantKill

;;-----------------------------------------------------------------------------
;; Command Window code variable
;;-----------------------------------------------------------------------------

CommandWindow_var
        MOV     PC,LR                   ; entry point for write op
        Push    "LR"                    ; entry point for read op

        MOV     R0,#WimpSysInfo_DesktopState
        SWI     XWimp_ReadSysInfo
        Pull    "PC",VS

        CMP     R0,#0                   ; R0=0 => "command" state

        ADREQ   R0,str_commands
        ADRNE   R0,str_desktop

        LDRB    R2,[R0],#1
        Pull    "PC"

str_commands    DCB     ?str_commands2
str_commands2   DCB     "commands"
str_desktop     DCB     ?str_desktop2
str_desktop2    DCB     "desktop"
                ALIGN

CommandWindow_varsize   *       . - CommandWindow_var

;;----------------------------------------------------------------------------
;; Neil's debugging routines
;;----------------------------------------------------------------------------

      [ debug
        InsertNDRDebugRoutines
      ]

        LTORG


;;-----------------------------------------------------------------------------
;; Service call handling
;;-----------------------------------------------------------------------------

ServiceTable
        DCD     0                               ; flags word
        DCD     Service2 - Module_BaseAddr
        [ :LNOT: UseAMBControl
        DCD     Service_Memory                  ; &11   ;
        ]                                               ;
        DCD     Service_Reset                   ; &27   ;
        DCD     Service_NewApplication          ; &2A   ;
        DCD     Service_ModeChange              ; &46   ;
        DCD     Service_MemoryMoved             ; &4E   ; must be in ascending order
        DCD     Service_ResourceFSStarted       ; &59   ;
        DCD     Service_ResourceFSDying         ; &5A   ;
        DCD     Service_ResourceFSStarting      ; &60   ;
        [ :LNOT: Medusa
        DCD     Service_ValidateAddress         ; &6D   ;
        ]
        [ SwitchingToSprite
        DCD     Service_SwitchingOutputToSprite ; &72   ;
        ]
        DCD     Service_InvalidateCache         ; &82   ;
        DCD     Service_ModeChanging            ; &89   ;
        [ Medusa :LAND: :LNOT: UseAMBControl            ;
        DCD     Service_PagesSafe               ; &8F   ;
        ]
        DCD     Service_ModeFileChanged         ; &94   ;
        DCD     0                               ; terminator

        DCD     ServiceTable - Module_BaseAddr
Service
        MOV     R0, R0                          ; flag service table to aware kernels

        ; Quick reject code for old kernels
        [ :LNOT: UseAMBControl
        TEQ     R1, #Service_Memory
        TEQNE   R1, #Service_Reset
        |
        TEQ     R1, #Service_Reset
        ]
        TEQNE   R1, #Service_NewApplication
        TEQNE   R1, #Service_ModeChange
        TEQNE   R1, #Service_MemoryMoved
        TEQNE   R1, #Service_ResourceFSStarted
        TEQNE   R1, #Service_ResourceFSDying
        TEQNE   R1, #Service_ResourceFSStarting
        [ :LNOT: Medusa
        TEQNE   R1, #Service_ValidateAddress
        ]
        [ SwitchingToSprite
        TEQNE   R1, #Service_SwitchingOutputToSprite
        ]
        TEQNE   R1, #Service_InvalidateCache
        TEQNE   R1, #Service_ModeChanging
        [ Medusa :LAND: :LNOT: UseAMBControl
        TEQNE   R1, #Service_PagesSafe
        ]
        TEQNE   R1, #Service_ModeFileChanged
        MOVNE   PC, LR

Service2
        LDR     wsptr,[R12]
        Debug   sv,"Wimp has received service call",R1
;

        [ debugnk
        TEQ     R1,#&68
        BNE     %FT01
        Push    "R0,lr"
        TraceS  nk,R2
        MOV     R0,#10
        BL      trace_char
        Pull    "R0,lr"
01
        TEQ     R1,#6
        BNE     %FT01
        Push    "R0,lr"
        LDR     lr,[R0]
        Debug   nk,"Error Number ",lr
        ADD     lr,R0,#4
        TraceS  nk,lr
        MOV     R0,#10
        BL      trace_char
        Pull    "R0,lr"
01
        ]
      [ debugvalid
        TEQ     R1,#Service_ValidateAddress
        BNE     %FT01
        Debug   valid,"Service validate address: r2,r3",r2,r3
01
      ]


      [ :LNOT: Medusa
        TEQ     R1,#Service_ValidateAddress
        BEQ     ValidateAddress
      ]
        TEQ     R1,#Service_NewApplication
        BEQ     newapplication

    [ :LNOT: UseAMBControl                      ; not our responsibility any more!
        TEQ     R1,#Service_Memory
        BEQ     servicememory
    ]
        TEQ     R1,#Service_MemoryMoved
        BEQ     servicememorymoved
      [ Medusa :LAND: :LNOT: UseAMBControl
        TEQ     R1,#Service_PagesSafe
        BEQ     servicepagessafe                ; in wimp08, screen resize etc.
      ]

      [ SwitchingToSprite
        TEQ     R1, #Service_SwitchingOutputToSprite
        BEQ     switchingtosprite
      ]
        TEQ     R1,#Service_ModeChange
        BEQ     recalcmodevars
        TEQ     R1,#Service_ResourceFSStarting  ; redeclare resource files
        BEQ     serviceresourcefsstarting
        TEQ     R1,#Service_ResourceFSStarted   ; re-link to sprite file
        BEQ     getromsprites
        TEQ     R1,#Service_ResourceFSDying
        BEQ     loseromsprites
        TEQ     R1,#Service_InvalidateCache     ; ColourTrans changed palette
        BEQ     invalidatecache
        TEQ     R1,#Service_ModeChanging
        BEQ     releasewrchvpremodechange
        TEQ     R1, #Service_ModeFileChanged
        BEQ     servicemodefilechanged
        TEQ     R1,#Service_Reset
        MOVNE   PC,LR

        Push    "LR"                    ; called on Service_Reset
      [ Medusa :LAND: :LNOT: DontCheckModeOnInit
        ; Reset currentmode on Service_Reset
        ; This allows us to get the correct mode in the case of a GraphicsV
        ; driver overriding the result of OS_ReadSysInfo 1 (as the driver
        ; probably wasn't initialised at the time we first read the mode)
        BL      read_current_configd_mode
      ]
        BL      deallocateptrs
        BL      initptrs                ; re-initialise window stack etc.
        BL      defaultfilters          ; re-register the filter routines
        Pull    "PC"

        [ :LNOT: Medusa
ValidateAddress
        Debug   valid,"Validate address ",r2,r3
        Push    "LR"
        LDRB    r14,memoryOK                            ; BUGFIX: NRaine 6-Aug-96 (should be unconditional)
        TST     r14,#mem_claimed
        Pull    "PC",EQ
        LDR     r14,freepoolbase
        Debug   valid,"First address is",r14
        CMP     r2,r14
        Pull    "PC",LO
        LDR     r14,orig_applicationspacesize
        Debug   valid,"Last address is ",r14
        CMP     r3,r14
        Pull    "PC",HS
        MOV     r1,#0
        Pull    "PC"
        ]

; ResourceFS has been reloaded - redeclare resource files
; In    R2 -> address to call
;       R3 -> workspace for ResourceFS module

serviceresourcefsstarting
        Push    "R0,LR"
        ADRL    R0,resourcefsfiles
        MOV     LR,PC                   ; LR -> return address
        MOV     PC,R2                   ; R2 -> address to call
        Pull    "R0,PC"

; A new MDF was loaded, this might have improved the kernel's idea
; of what the configured 'auto' mode achievable is, recache currentmode

servicemodefilechanged
        Push    "LR"
        LDR     LR,taskcount
        TEQ     LR,#0                   ; but only if we're outside the desktop
        BLEQ    read_current_configd_mode
        Pull    "PC"

; try to locate ROM sprite area - if not found, refuse to start up!
; this MUST be in Resources:, as we need to use it directly

getromsprites
        Push    "R0-R6,LR"
;
        LDR     R0,currentmode
        SWI     XOS_CheckModeValid              ; get the REAL mode number!
        CMP     R0,#-1                  ; if mode does not exist,
        MOVEQ   R0,R1                   ; try to use substitute mode
        CMP     R0,#-2                  ; if R1 = -2, we're stuck!
        LDREQ   R0,currentmode          ; (just give up and use the original)
;
        MOV     R4,#1

        MOV     R1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        MOV     R5,R4,LSL R2                    ; R5 = char 0 - '0'

        MOV     R1,#VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        MOV     R6,R4,LSL R2                    ; R6 = char 1 - '0'

	MOV	R1,#VduExt_Log2BPP
	SWI	XOS_ReadModeVariable

        TEQ     R5,#2  				; 2x2 OS unit, 1bpp
        TEQEQ   R6,#2
        TEQEQ   R2,#0
        MOVEQ   R6,#3

      [ :LNOT: Sprites11
        TEQ     R5,#1
        TEQNE   R6,#1
        MOVEQ   R5,#2
        MOVEQ   R6,#2                           ; '1y' or 'x1' -> '22'
      ]

      [ SpritesA
        BL      checkalphasprites
        TEQ     R5,#2
        TEQEQ   R6,#3                           
        MOVEQ   R0,#0
        STREQB  R0,alphaspriteflag              ; Completely ignore alpha sprites in mode 23
      ]

        ADD     R14,R5,R6,LSL #8
        ADD     R14,R14,#'0'
        ADD     R14,R14,#'0':SHL:8

        ASSERT  ((:INDEX:romspr_suffix) :AND: 3) = 0
        STR     R14,romspr_suffix
;
        SUB     sp,sp,#4
01
      [ SpritesA
        CMP     R5,R6
        LDREQB  R0,alphaspriteflag
        CMPEQ   R0,#255
        MOVEQ   R5,#'A'-'0'             ; Try alpha before square pixels
      ]
02      ADD     R14,R5,R6,LSL #8
        ADD     R14,R14,#'0'
        ADD     R14,R14,#'0':SHL:8
        STR     R14,[sp]
        MOV     R0,sp

        ADR     R1,spritesfname
        BL      getspritefname          ; R1 -> <filename><x><y><bpp>
                                        ; R2 -> terminator
        MOV     R0,#OSFind_ReadFile
        SWI     XOS_Find
;
        BVC     %FT04

      [ SpritesA
        CMP     R5,#'A'-'0'
        MOVEQ   R5,R6
        BEQ     %BT02                   ; Try square pixels if alpha failed
      ]

        TEQ     R6,#3
        MOVEQ   R6,#2
        BEQ     %BT01                   ; after Sprites23, try Sprites22

        CMP     R5,R6
        MOVLO   R5,R5,LSL#1
        MOVHI   R6,R6,LSL#1
        BNE     %BT01                   ; after rectangular pixels, try next squarer version

      [ Sprites11
        TEQ     R5,#1
        MOVEQ   R5,#2
        MOVEQ   R6,#2
        BEQ     %BT01                   ; after Sprites11, try Sprites22
      ]

      [ SpritesA
        LDRB    R0,alphaspriteflag
        CMP     R0,#0
        BEQ     %FT03
        MOV     R14,#'A'
        STR     R14,[sp]
        MOV     R0,sp
        ADR     R1,spritesfname
        BL      getspritefname
        MOV     R0,#OSFind_ReadFile
        SWI     XOS_Find                ; try just <filename>A before falling back to the original
        BVC     %FT04
03
      ]

        ADR     R1,spritesfname         ; R1 -> original filename
        MOV     R0,#OSFind_ReadFile     ; try again!
        SWI     XOS_Find
04      ADD     sp,sp,#4
        BVS     %FT99                   ; error!
;
        MOV     R3,R0                   ; save external file handle
;
        MOV     R0,#FSControl_ReadFSHandle
        MOV     R1,R3
        SWI     XOS_FSControl
;
        AND     R2,R2,#&FF
        TEQ     R2,#fsnumber_resourcefs
      [ SpritePriority
        BNE     %FT06
        SUB     R2,R1,#4                ; R2 -> sprite area (including size)
        STR     R2,baseofromsprites
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseoflosprites
        STRNE   R2, baseofhisprites
06
      |
        SUBEQ   R2,R1,#4                ; R2 -> sprite area (including size)
        STREQ   R2,baseofromsprites
      ]
;
        MOV     R0,#0
        MOV     R1,R3
        SWI     XOS_Find                ; close file
99
        BLVS    loseromsprites          ; don't return error - just lose sprites
        CLRV
        Pull    "R0-R6,PC"

spritesfname    DCB     "WindowManager:Sprites", 0
                ALIGN

loseromsprites
        Push    "R1,LR"
        Debug   ub,"lose ROM sprites"
        ADRL    R14,romsprites
        STR     R14,baseofromsprites
      [ SpritePriority
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R14, baseoflosprites
        STRNE   R14, baseofhisprites
      ]
        Pull    "R1,PC"

  [ SwitchingToSprite
; Service_SwitchingOutputToSprite: cache limited graphics parameters

switchingtosprite
        Entry
        STR     R4, switchtospr_current     ; remember where output is switched to now
        TEQ     R4, #0                      ; if switching to screen
        BLEQ    switchingtosprite_recache   ; then make sure parameters are correct
        EXIT

switchingtosprite_recache
; recaches graphics parameters iff switchtospr_correctfor <> switchtospr_current
        Entry   "R0,R5-R6"
        LDR     R0, switchtospr_current
        LDR     R14, switchtospr_correctfor
        TEQ     R0, R14
        EXIT    EQ
        STR     R0, switchtospr_correctfor
        BL      readvduvars2            ; including new screen/sprite size etc.
        BLVC    calcborders             ; to set up dx, dy
        EXIT
  ]

; Service_ModeChange: cache new graphics parameters

recalcmodevars
        Push    "LR"
        BL      readvduvars2            ; including new screen size etc.
        BLVC    calcborders

        Push    R0
        ADRL    R0,inverselookup
        MOV     LR,#-1
        STR     LR,[R0]                 ; force recache
        [ windowsprite
	 [ ThreeDPatch
	MOV	R0,#0
	BL	reset_all_tiling_sprites
	 |
        STR     lr,tiling_sprite        ; force re cache
         ]
        ]
        Pull    R0

        [ false
        ADRL    R14,greys_mode
        LDR     R14,[R14]
        TEQ     R14,#0
        BLNE    recalc_greys_palette
        ]
        Pull    "PC"

; Service_ModeChanging: get off wrchv if necessary

releasewrchvpremodechange
        Push    "LR"
; medusa may require the write character vector to be reset.

        LDR     R14,commandflag
        TST     R14,#cf_suspended
        Pull    "PC",NE

        TEQ     R14,#cf_pending
        Pull    "PC",NE

        Push    "R0-R2"
        MOV     R0,#WrchV               ; get off the vector now!
        ADRL    R1,mywrch
        MOV     R2,wsptr
        SWI     XOS_Release

        MOV     R14,#cf_active
        STR     R14,commandflag

        Pull    "R0-R2,PC"


; Service_InvalidateCache: Mark all cached palette data as invalid

invalidatecache
        Push    "R0,R2,LR"
        LDRB    R2,selecttable_crit     ; avoid discarding the table when we know
        CMP     R2,#0                   ; that it is still valid
        Pull    "R0,R2,PC", NE

        LDR     R2,pixtable_at
        CMP     R2,#0                   ; has a pixtable been setup?
        MOVNE   R0,#ModHandReason_Free
        BLNE    XROS_Module             ; attempt to release - ignore errors

        MOV     R2,#0
        STR     R2,pixtable_at          ; mark the pixtable as being zapped!

        MOV     R2,#-1                  ; and the PixTrans mode
        STR     R2,sprite_lastmode

      [ ThreeDPatch
; MB - must add invalidating of new tile pixel tables here
      |
        LDR     R2,tile_temptab
        ORR     R2,R2,#1
        STR     R2,tile_temptab
      ]

        LDR     R2,tpixtable_at
        CMP     R2,#0                   ; has a tool pixtable been setup?
        MOVNE   R0,#ModHandReason_Free
        BLNE    XROS_Module             ; attempt to release - ignore errors

        MOV     R2,#0
        STR     R2,tpixtable_at         ; mark the tool pixtable as being zapped!
        STR     R2,tool_transtable

        MOV     R2,#-1                  ; and the tool PixTrans mode
        STR     R2,tsprite_lastmode

        STRB    R2,tsprite_needsregen   ; re-calcuate border based information

        Pull    "R0,R2,PC"

;
; Entry:  R2 = new CAO pointer
; Exit:   set flag to indicate whether application uses absolute w/s
;         NB: BASIC looks like a module, but uses application workspace
;

newapplication
        Push    "R0-R3,LR"
;
        Debuga  task1,"New CAO pointer =",R2
;
        MOV     R14,#0                  ; reset when application is run
        STR     R14,handlerword
;
        MOV     R0,#ExitHandler
        MOV     R1,#0
        MOV     R2,#0
        MOV     R3,#0
        SWI     XOS_ChangeEnvironment
        STR     R1,parentquithandler    ; for checking later
        Debug   task1,", Parent quit handler =",R1
;
        Pull    "R0-R3,PC"

;
; ChangeEnvironment monitoring
; Set bits in [handlerword] whenever a handler is modified
;

ChangeEnvCode
        Push    "R1,LR"
;
        TEQ     R1,#0           ; if the handler is being modified,
        MOVNE   R14,#1          ; set the corresponding bit in [handlerword]
        LDRNE   R1,handlerword
        ORRNE   R1,R1,R14,LSL R0   ; assume < 32 handlers
        STRNE   R1,handlerword
;
        Pull    "R1,PC"         ; pass it on!


UpCallCode	ROUT
        TEQ     R0,#UpCall_MediaSearchEnd
        BEQ     finishupcall                        ; this comes round if it works!
	TEQ	R0,#UpCall_MediaSearchEndMessage
        BEQ     finishupcall_withmessage            ; this comes round if it works!

        TEQ     R0,#UpCall_MediaNotPresent
        TEQNE   R0,#UpCall_MediaNotKnown
        MOVNE   PC,LR                   ; Pass it on


; In    r1 = fs number
;       r2 -> media name, or = -1 => r6 -> message
;       r3 = device number (-1 for irrelevant)
;       r4 = iteration number (so we can 'reverse poll' if required)
;       r5 = timeout between reverse polls (large if not wanted)
;       r6 -> media type (eg. 'disc' for FileCore) (if r2 <> -1)
;          = -1 for disc (if r2 <> -1)
;          -> complete message to display (if r2 = -1)

; Note  PRM p1-179 says that r2 may be -1 if irrelevant, the comment above
;       said it may be 0. Both were wrong. We take advantage of the
;       documentation to provide slightly modified behaviour, since no-one
;       can have been relying on r2 = -1 working before.

        Push    "R1-R6"         ; no need to stash LR (we'll claim vector)

      [ :LNOT: Medusa
        CMP     R6,#0                   ; bodge for old FileCores
        ADRMIL	R6,disc
        MOVMI   R5,#bignum              ; long timeout if R6 invalid
      ]

        SUB     sp,sp,#32
;
        MOV     r0, #FSControl_ReadFSName
        ADRL    r2, errorbuffer         ; r2 = buffer
        MOV     r3, #256                ; r3 = length
        LDR     r1, [sp,#32+0*4]        ; r1 = fs number
        SWI     XOS_FSControl
        SUBS    r2, sp, #0              ; CLRV, r2 -> buffer.
;
        Push    "r4"
        MOVVS   r4, #0
        ADRVCL  r4, errorbuffer         ; -> string of messages
        ADR     r0, messagefrom
        MOV     r3, #32
        BL      LookupToken
        Pull    "r4"
;
        SUBS    r2, sp, #0              ; CLRV, r2 -> buffer.
;
        Push    "R2-R5"
	LDR	r5, [sp, #32+1*4+4*4]	; media name or -1
	CMP	r5, #-1
	BEQ	%04

        ADRL    R2,errorbuffer
        MOV     R3,#252
        MOV     R14,#0                  ; error number
        STR     R14,[R2],#4
;
        ADRL    R0,ensuredisc           ; "Please insert %0 '%1'"
        MOV     R4,R6			; media type
;
        BL      LookupToken             ; resolve into suitable string

	B	%05
04
	;Just use the message provided (copied into the same buffer)
      [ false
	ADRL    r2, errorbuffer
	ADD	r2, r2, #4		;don't care about error number
06	LDRB	lr, [r6], #1		;read from given message
	STRB	lr, [r2], #1		;write to error buffer
	TEQ	lr, #0			;NUL-terminated
	BNE	%06
      |
	ADRL    r2, errorbuffer
	ADD	r3, r2, #251		;r3 holds the end address of the error buffer
	ADD	r2, r2, #4		;don't care about error number
06	LDRB	lr, [r6], #1		;read from given message
	TEQ	lr, #0			;NUL-terminated
	TEQNE	lr, #10			;test for end of line searching too far
	TEQNE	lr, #13			;test for cr
	TEQNE 	r2, r3			;test end of buffer
	STRNEB	lr, [r2], #1		;write to error buffer
	BNE	%06

	MOV	lr, #0			;ensure always NUL-terminated
	STRB	lr, [r2]
      ]
05
        Pull    "R2-R5"
;
        SWI     XOS_ReadMonotonicTime
        MOV     R4,R0

01      ADRL    R0,errorbuffer
        MOV     R1,#erf_okbox:OR:erf_cancelbox:OR:erf_omiterror:OR:erf_poll
        CMP     R5,#bignum
        BICCS   R1,R1,#erf_poll         ; don't poll if timeout too long
	Debug	upcall, "+Wimp_ReportError: flags", R1
        SWI     XWimp_ReportError
	Debug	upcall, "-Wimp_ReportError: button", R1
        TEQ     R1,#0                   ; if no decision made, loop & timeout
        BNE     %FT02

        SWI     XOS_ReadMonotonicTime
        SUB     R0,R0,R4
        CMP     R0,R5
        BCC     %BT01                   ; unsigned comparison

        MOV     R0,#UpCall_Claimed      ; get ADFS to try again
        B       %FT03

02      TEQ     R1,#erf_okbox
        MOVEQ   R0,#UpCall_Claimed      ; UpCall processed
        MOVNE   R0,#UpCall_Invalid
03
        ADD     sp,sp,#32               ; correct stack
        Pull    "R1-R6,PC"              ; Claim vector

finishupcall
        Push    "R0-R1"
;
        MOV     R1,#erf_okbox:OR:erf_pollexit   ; select 'OK'
        SWI     XWimp_ReportError
;
        [ No32bitCode
        MOV     R14,#0
        ]
        MRS     R14,CPSR
        TST     R14,#2_11100
        Pull    "R0-R1,PC",EQ,^         ; claim vector
        CLRV
        Pull    "R0-R1,PC"

finishupcall_withmessage
        Push    "R0-R3"
;
	;Just use the message provided (copied into the same buffer)
	ADRL    r2, errorbuffer
	ADD	r3, r2, #251		;r3 holds the end address of the error buffer
	ADD	r2, r2, #4		;don't care about error number
01	LDRB	lr, [r1], #1		;read from given message
	TEQ	lr, #0			;NUL-terminated
	TEQNE	lr, #10			;test for end of line searching too far
	TEQNE	lr, #13			;test for cr
	TEQNE 	r2, r3			;test end of buffer
	STRNEB	lr, [r2], #1		;write to error buffer
	BNE	%01

	MOV	lr, #0			;ensure always NUL-terminated
	STRB	lr, [r2]

	ADRL	R0, errorbuffer
	SUB	R0, r2, r0
	Debug	upcall,"string size",R0
	ADRL	R0, errorbuffer
        MOV     R1,#erf_okbox:OR:erf_poll   		; Draw the Box
        SWI     XWimp_ReportError
        MOV     R1,#erf_okbox:OR:erf_pollexit   	; Request the Box Removed
        SWI     XWimp_ReportError
;
        [ No32bitCode
        MOV     R14,#0
        ]
        MRS     R14,CPSR
        TST     R14,#2_11100
        Pull    "R0-R3,PC",EQ,^         ; claim vector
        CLRV
        Pull    "R0-R3,PC"

messagefrom DCB "MF", 0
ensuredisc  DCB "ID", 0                  ; followed by media type (eg. 'disc')
disc        DCB "disc", 0               ; cheat

        ALIGN

;
; Free resources currently used by Wimp
; NB:  task blocks etc. are not valid, so are simply discarded
;      don't bother to rewrite pointers - done later in 'initptrs'
; Doesn't reset the common sprite pool (only done in Die)
;

deallocateptrs	ROUT
        Push    "R0-R5,LR"
;
; release block used for holding pixtrans tables
;
        MOV     R0,#ModHandReason_Free
        MOV     R1,#0                   ; reset pointers to zero
;
        LDR     R2,pixtable_at
        CMP     R2,#0
        BLNE    XROS_Module              ; release the pixtrans table (ignore errors)
;
        LDR     R2,fileaddress
        CMP     R2,#0
        BLNE    XROS_Module              ; release the template loading buffer (ignore errors)
;
        LDR     R2,inversecolourmap
        CMP     R2,#0
        BLNE    XROS_Module             ; release colour mapping tables
;
        STR     R1,pixtable_at
        STR     R1,pixtable_size
        STR     R1,filehandle
        STR     R1,fileaddress          ; tag as free'd
        STR     R1,inversecolourmap
        STRB    R1,checkedcolourmapping ; ensure we check again before we try using the duff pointer
;
        BL      freelist                ; de-allocate list buffer (for sprite cache)
        BL      freetoolarea
;
        [ mousecache
        MOV     R0,#TickerV             ; tidy the mouse handler
        ADRL    R1,MouseCallEveryHandler
        BL      release
        ]
      [ NewErrorSystem
        [ WatchdogTimer
        ADRL    R0,BreakWatchdogHandler
        MOV     R1,WsPtr
        SWI     XOS_RemoveTickerEvent
        |
        MOV     R0,#EventV
        ADRL    R1,BreakWatchdogHandler
        MOV     R2,WsPtr
        SWI     XOS_Release                     ; stop calls to watchdog on events
         [ false
        MOV     R0,#13
        MOV     R1,#Event_Keyboard              ; disable keyboard events
        SWI     XOS_Byte
05
         ]
        ]
      ]
;
      [ outlinefont
        BL      LoseFont
      ]
;
; delete window blocks
;
        B       %FT02

01      LDR     R5,[R2,#ll_backwards]

        ; Delink window
        STR     R4,[R5,#ll_forwards]
        STR     R5,[R4,#ll_backwards]

        ; Discard it after translating link address to window address
        SUB     R2,R2,#w_all_link

        Debug   opn,"**** Discarding window on wimp dying ****",R2

        BL      discard_window
02
        ; Get first window in list, is it the header?
      [ ChildWindows                            ; make this unconditional when merging sources back in
        LDR     R2,allwinds+lh_forwards         ; BUGFIX: NRaine 2-Aug-96: discard ALL windows, not just the open ones!
      |                                         ;         It actually breaks otherwise, since w_all_link is used (see above)
        LDR     R2,activewinds+lh_forwards
      ]
        LDR     R4,[R2,#ll_forwards]
        CMP     R4,#nullptr
        BNE     %BT01
;
; delete the message queue
;
        BL      deletemessagequeue              ; also done when last task dies
;
; delete task blocks and associated slots
;
        ADRL    R4,taskpointers
        MOV     R5,#maxtasks
01
        LDR     R2,[R4],#4
        TST     R2,#task_unused
        BNE     %FT11
        LDR     R2,[R2,#task_slotptr]
        Debug   mjs2," wimp01 (1) slotptr to free",R2
        CMP     R2,#nullptr
      [ UseAMBControl
        MOVNE   R0,#1   ;deallocate reason code
        SWINE   XOS_AMBControl
      |
        MOVNE   R0,#ModHandReason_Free
        BLNE   XROS_Module                      ; free block (ignoring errors)
      ]
        LDR     R2,[R4,#-4]
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module              ; free block (ignoring errors)
11
        SUBS    R5,R5,#1
        BNE     %BT01
;
      [ :LNOT: Medusa
        LDR     R2,freepool
        CMP     R2,#nullptr2
        MOVLO   R0,#ModHandReason_Free
        BLLO   XROS_Module
      ]
;
        BL      deletependingtask
;
; delete both sets of iconbar entries
;
        ADRL    R1,iconbarleft
        BL      killiconbar
        ADRL    R1,iconbarright
        BL      killiconbar

;
        Pull    "R0-R5,PC"


deletependingtask
        Push    "R0-R2,LR"
;
        LDR     R2,pendingtask
        CMP     R2,#0
        BMI     %FT01
        LDR     R2,[R2,#task_slotptr]   ; delete slot block
        Debug   mjs2," wimp01 (2) slotptr to free",R2
        CMP     R2,#nullptr
      [ UseAMBControl
        MOVNE   R0,#1   ;deallocate reason code
        SWINE   XOS_AMBControl
      |
        MOVNE   R0,#ModHandReason_Free
        BLNE   XROS_Module
      ]
        LDR     R2,pendingtask          ; and task block (in that order)
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module
        MOV     R14,#nullptr
        STR     R14,pendingtask
01
        CLRV
        Pull    "R0-R2,PC"


killiconbar
        Push    "LR"
        LDR     R2,[R1,#icd_list]
01
        CMP     R2,#nullptr
        BEQ     %FT02
        LDR     R4,[R2,#icb_link]
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module              ; free block (ignoring errors)
        MOV     R2,R4
        B       %BT01
02
        MOV     R14,#nullptr
        STR     R14,[R1,#icd_list]
;
        Pull    "PC"


deletemessagequeue
        Push    "R0-R3,LR"
;
        LDR     R1,headpointer
01
        CMP     R1,#nullptr
        BEQ     %FT02
        MOV     R0,#ModHandReason_Free  ; free block (ignoring errors)
        MOV     R2,R1
        LDR     R1,[R1,#msb_link]       ; do this first!!!
        BL     XROS_Module
        B       %BT01
02
        MOV     R14,#nullptr
        STR     R14,headpointer
      [ NKmessages1
        STR     R14,lastpointer
      ]
;
        CLRV
        Pull    "R0-R3,PC"              ; ignore errors


vduinput
        DCD     VduExt_XEigFactor
        DCD     VduExt_YEigFactor
        DCD     VduExt_Log2BPP
        DCD     -1

        ASSERT  (scrx0-vduoutput)=12
vduinput2
        DCD     VduExt_XEigFactor
        DCD     VduExt_YEigFactor
        DCD     VduExt_Log2BPP
      [ SwitchingToSprite
        DCD     0                     ; dummies - these are zeroed later
        DCD     0                     ;
        DCD     VduExt_XWindLimit
        DCD     VduExt_YWindLimit
      |
        DCD     VduExt_GWLCol
        DCD     VduExt_GWBRow
        DCD     VduExt_GWRCol
        DCD     VduExt_GWTRow
      ]
        DCD     VduExt_TCharSpaceX
        DCD     VduExt_TCharSpaceY
        DCD     VduExt_ModeFlags      ; for checking for hi-res mono modes
        DCD     VduExt_NColour
        DCD     -1


readvduvars2
        Push    "R0-R4,LR"

        ADR     R0,vduinput2
        ADR     R1,vduoutput
        SWI     XOS_ReadVduVariables
        ADRVC   R0,scrx0
        LDMVCIA R0,{R1-R6}              ; plus text x,y size
        LDR     R14,log2px
      [ SwitchingToSprite
        MOV     R1, #0
      |
        MOV     R1,R1,ASL R14
      ]
        ADD     R3,R3,#1                ; make exclusive
        MOV     R3,R3,ASL R14
        MOV     R5,R5,ASL R14
        LDR     R14,log2py
      [ SwitchingToSprite
        MOV     R2, #0
      |
        MOV     R2,R2,ASL R14
      ]
        ADD     R4,R4,#1                ; make exclusive
        MOV     R4,R4,ASL R14
        MOV     R6,R6,ASL R14
        STMVCIA R0,{R1-R6}
        BVS     leavereadvduvars2       ; return if errors

        MOV     R0,#ReadCMOS
        MOV     R1,#FileSwitchCMOS
        SWI     XOS_Byte
        MOVVS   R2,#0                   ; if errored then must read location as 0!
        CLRV    VS                      ; ignore any errors

        TST     R2,#WimpDitherDesktopCMOSBit
        MOV     R2,#0
        ORRNE   R2,R2,#1:SHL:8          ; dithering enabled - thats rather dangerous isn't it!
        STR     R2,ditheringflag

leavereadvduvars2
        STRVS   R0,[sp]
        Pull    "R0-R4,PC"

readvduvars
        Push    "R0,R1,LR"
        ADR     R0,vduinput
        ADR     R1,vduoutput
        SWI     XOS_ReadVduVariables
        STRVS   R0,[sp]
        Pull    "R0,R1,PC"

calcborders
        Push    "R1-R10,LR"
;
; relocate the ROM sprites for this mode!
;
        BL      getromsprites           ; re-address the ROM sprites
;
        LDR     R14,log2px
        MOV     R1,#1
        MOV     R1,R1,ASL R14
        STR     R1,dx
        SUB     R14,R1,#1
        STR     R14,dx_1
;
        LDR     R14,log2py
        MOV     R1,#1
        MOV     R1,R1,ASL R14
        STR     R1,dy
        SUB     R14,R1,#1
        STR     R14,dy_1
;
; calculate basic characteristics used for the scroll bars
;
        LDR     R14,dx
        LDR     R1,dy
        CMP     R1,R14
        MOVLT   R1,R14                  ; R1 = maximum pixel size
        STR     R1,xypixelsize
;
        MOV     R14,#40                 ; always 40 OS units!
;
        STRB    R14,xborder
        STRB    R14,yborder
;
        LDR     R1,dx
        ADD     R1,R14,R1
        STRB    R1,xborder1             ; xborder1 = xborder + dx
        LDR     R1,dy
        ADD     R1,R14,R1
        STRB    R1,yborder1             ; yborder1 = yborder + dy
;
        Pull    "R1-R10,PC"

;;-----------------------------------------------------------------------------
;; The Wimp SWI - all calls to the Wimp come through here
;;
;; Entry:  R11 = SWI number within chunk
;;         R12 --> private word
;;         R1 --> user buffer (parameter block)
;; Exit :  R0 = reason code
;;         R1 --> parameter block (modified)
;;-----------------------------------------------------------------------------

;;-----------------------------------------------------------------------------
;; Handle the SWI decoding for the Window Manager
;;-----------------------------------------------------------------------------

Wimp_SWIdecode
        Push    "LR"
;
      [ debugints
       [ No32bitCode
        MOV     R14,#I_bit
        TST     R14,PC
       |
        MOV     R14,CPSR
        TST     R14,#I32_bit
       ]
        BEQ     %FT00
        Debug   ints,"Ints enabled: SWI number =",R11
00
      ]
        CLRPSR  I_bit, R14                      ; re-enable interrupts
;
        LDR     wsptr,[R12]                     ; wsptr --> workspace
        LDR     R14,longjumpSP
        STR     R14,[sp,#-4]!                   ; stash these for re-entrancy!
        LDR     R14,polltaskhandle
        STR     R14,[sp,#-4]!
;
        Push    "R1-R11"
        STR     sp,longjumpSP
        LDR     R14,taskhandle                  ; in case of incorrect swaps ..
        STR     R14,polltaskhandle              ; .. the caller is put back!
;
        LDR     R14,[wsptr,R14]                 ; check whether this SWI can
        TST     R14,#task_unused                ; be called without Wimp_Init
        ADR     R14,flagtable
        LDRB    R14,[R14,R11]
        TSTNE   R14,#swf_alive
        BNE     jporg                           ; error if not initialised
        CMP     R14,#swf_checklimit
        CMPLO   R1,#ApplicationStart
        BLO     err_badpointer

        [       outlinefont
        MOV     R14, #0
        STR     R14, currentfont
        ]
        LDR     R14,wimpswiintercept
        TEQ     R14,#0
        MOVNE   PC,R14
callaswi
        CMP     R11,#maxnewswi
        ADDCC   R14,R11,#(jptable-jporg-4)/4    ; bodge factor
        MOVCC   userblk,R1                      ; get userblk (--> parameters)
        ADDCC   PC,PC,R14,ASL #2                ; go!
jporg
        MyXError  WimpBadOp
        B       ExitWimp_noswitch
        MakeErrorBlock WimpBadOp
err_badpointer
        MyXError  WimpBadPtrInR1
        B       ExitWimp_noswitch
        MakeErrorBlock WimpBadPtrInR1

ExitWimp
        LDR     R14,polltaskhandle      ; ensure no illegal task swaps occur!
        Task    R14,,"ExitWimp"

ExitWimp_noswitch
   ;    MOVVS   R14,#nullptr            ; CAN'T CLEAR THIS JUST BECAUSE V SET!
   ;    STRVS   R14,redrawhandle
;
        Pull    "R1-R11"
return
        LDR     R14,[sp],#4
        STR     R14,polltaskhandle
        LDR     R14,[sp],#4
        STR     R14,longjumpSP

        [       outlinefont
        ;Restore the current font and font colours that were in force on
        ;       entry, if they've been changed. Preserve flags while doing
        ;       this.
        Debug   exit, "ExitWimp: restoring font and font colours"
        [ No32bitCode
        Push    "R0-R3,PC"
        |
        MRS     R14,CPSR
        Push    "R0-R3,R14"
        ]
        LDR     R0, currentfont
        TEQ     R0, #0
        BEQ     ExitWimp_restored_font_colours
        LDR     R1,systemfont
        TEQ     R1,R0
        BEQ     %FT05                           ; its ours ! No need to call the SWI
        LDR     R1, currentbg
        LDR     R2, currentfg
        LDR     R3, currentoffset
        Debug   exit, "ExitWimp: calling Font_SetFontColours"
        SWI     XFont_SetFontColours
05
        MOV     R0, #0
        STR     R0, currentfont
ExitWimp_restored_font_colours
        Pull    "R0-R3,LR"
        [ No32bitCode
        TEQP    PC, LR
        |
        MSR     CPSR_f, LR
        ]
        |
        [ :LNOT:No32bitCode
        MRS     LR, CPSR
        ]
        ]

        [ :LNOT:No32bitCode
        ; LR contains CPSR
        TST     LR, #2_11100
        Pull    "PC",NE          ; 32-bit exit (just pass V back)
        ]

        Pull    "PC",VC,^        ; exit immediately

        DebugE  err,"Wimp SWI error"
        Debug   err,"SWI #, task",R11,#taskhandle

        Pull    "PC",VS

ExitWimp2
        LDR     R14,polltaskhandle      ; ensure no illegal task swaps occur!
        Task    R14,,"ExitWimp2"
;
        ADD     sp,sp,#6*4              ; leave R1-R6 as on exit
        Pull    "R7-R11"
        B       return

;
; jump table - contains branches to entry points
;

        GBLA    swicnt                  ; for dealing with flagtable
swicnt  SETA    0

jptable
x       MySWI   Wimp_Initialise         ; 0       ; Wimp_Init not necessary
p       MySWI   Wimp_CreateWindow       ; 1       ; check for owner window
p       MySWI   Wimp_CreateIcon         ; 2       ; check for owner window
p       MySWI   Wimp_DeleteWindow       ; 3       ; check for owner window
p       MySWI   Wimp_DeleteIcon         ; 4       ; check for owner window
p       MySWI   Wimp_OpenWindow         ; 5       ; check for owner window
p       MySWI   Wimp_CloseWindow        ; 6       ; check for owner window
xp      MySWI   Wimp_Poll               ; 7       ; Wimp_Init not necessary; check for owner window
p       MySWI   Wimp_RedrawWindow       ; 8       ; check for owner window
p       MySWI   Wimp_UpdateWindow       ; 9       ; check for owner window
p       MySWI   Wimp_GetRectangle       ; 10      ; check for owner window
xp	MySWI   Wimp_GetWindowState     ; 11      ; Wimp_Init not necessary; check for owner window
xp	MySWI   Wimp_GetWindowInfo      ; 12      ; Wimp_Init not necessary; check for owner window
p       MySWI   Wimp_SetIconState       ; 13      ; check for owner window
p       MySWI   Wimp_GetIconState       ; 14      ; check for owner window
xp	MySWI   Wimp_GetPointerInfo     ; 15      ; Wimp_Init not necessary; check for owner window
        MySWI   Wimp_DragBox            ; 16
        MySWI   Wimp_ForceRedraw        ; 17
        MySWI   Wimp_SetCaretPosition   ; 18
p       MySWI   Wimp_GetCaretPosition   ; 19      ; check for owner window
        MySWI   Wimp_CreateMenu         ; 20
        MySWI   Wimp_DecodeMenu         ; 21
p       MySWI   Wimp_WhichIcon          ; 22      ; check for owner window
p       MySWI   Wimp_SetExtent          ; 23      ; check for owner window
x       MySWI   Wimp_SetPointerShape    ; 24      ; Wimp_Init not necessary
xp      MySWI   Wimp_OpenTemplate       ; 25      ; Wimp_Init not necessary; check for owner window
x       MySWI   Wimp_CloseTemplate      ; 26      ; Wimp_Init not necessary
x       MySWI   Wimp_LoadTemplate       ; 27      ; Wimp_Init not necessary
        MySWI   Wimp_ProcessKey         ; 28
x       MySWI   Wimp_CloseDown          ; 29      ; Wimp_Init not necessary
        MySWI   Wimp_StartTask          ; 30
x       MySWI   Wimp_ReportError        ; 31      ; Wimp_Init not necessary
p       MySWI   Wimp_GetWindowOutline   ; 32
xp      MySWI   Wimp_PollIdle           ; 33      ; Wimp_Init not necessary; check for owner window
p       MySWI   Wimp_PlotIcon           ; 34
x       MySWI   Wimp_SetMode            ; 35      ; Wimp_Init not necessary
x       MySWI   Wimp_SetPalette         ; 36      ; Wimp_Init not necessary
xp      MySWI   Wimp_ReadPalette        ; 37      ; Wimp_Init not necessary; check for owner window
x       MySWI   Wimp_SetColour          ; 38      ; Wimp_Init not necessary
p       MySWI   Wimp_SendMessage        ; 39      ; check for owner window
        MySWI   Wimp_CreateSubMenu      ; 40
x       MySWI   Wimp_SpriteOp           ; 41      ; Wimp_Init not necessary
x       MySWI   Wimp_BaseOfSprites      ; 42      ; Wimp_Init not necessary
        MySWI   Wimp_BlockCopy          ; 43      ; check for owner window
x       MySWI   Wimp_SlotSize           ; 44      ; Wimp_Init not necessary
x       MySWI   Wimp_ReadPixTrans       ; 45      ; Wimp_Init not necessary
x       MySWI   Wimp_ClaimFreeMemory    ; 46      ; Wimp_Init not necessary
x       MySWI   Wimp_CommandWindow      ; 47      ; Wimp_Init not necessary
x       MySWI   Wimp_TextColour         ; 48      ; Wimp_Init not necessary
x       MySWI   Wimp_TransferBlock      ; 49      ; Wimp_Init not necessary
x       MySWI   Wimp_ReadSysInfo        ; 50      ; Wimp_Init not necessary
        MySWI   Wimp_SetFontColours     ; 51
p       MySWI   Wimp_GetMenuState       ; 52      ; check for owner window
x       MySWI   Wimp_RegisterFilter     ; 53      ; Wimp_Init not necessary
        MySWI   Wimp_AddMessages        ; 54
        MySWI   Wimp_RemoveMessages     ; 55
x       MySWI   Wimp_SetColourMapping   ; 56      ; Wimp_Init not necessary
        MySWI   Wimp_TextOp             ; 57      ; 320nk
x       MySWI   Wimp_SetWatchdogState   ; 58      ; Wimp_Init not necessary      ; 322
x       MySWI   Wimp_Extend             ; 59      ; Wimp_Init not necessary
        MySWI   Wimp_ResizeIcon         ; 60
 [ Autoscr
x       MySWI   Wimp_AutoScroll         ; 61      ; checks done later
 ]

endjptable
maxnewswi   *   (endjptable-jptable)/4

flagtable
swicnt  SETA    0
        WHILE   swicnt < maxnewswi
        DCB     xflg_$swicnt            ; flags for a given SWI
swicnt  SETA    swicnt+1
        WEND
        [ false
        WHILE   swicnt < 64
        DCB     0
swicnt  SETA    swicnt+1
        WEND
        ]
        ; all 'new' SWI's may be used without wimp_initalise
        DCB     16,16,16,16

        ALIGN

Wimp_SWInames
        DCB     "Wimp",0                ; prefix
        DCB     "Initialise",0
        DCB     "CreateWindow",0
        DCB     "CreateIcon",0
        DCB     "DeleteWindow",0
        DCB     "DeleteIcon",0
        DCB     "OpenWindow",0
        DCB     "CloseWindow",0
        DCB     "Poll",0
        DCB     "RedrawWindow",0
        DCB     "UpdateWindow",0
        DCB     "GetRectangle",0
        DCB     "GetWindowState",0
        DCB     "GetWindowInfo",0
        DCB     "SetIconState",0
        DCB     "GetIconState",0
        DCB     "GetPointerInfo",0
        DCB     "DragBox",0
        DCB     "ForceRedraw",0
        DCB     "SetCaretPosition",0
        DCB     "GetCaretPosition",0
        DCB     "CreateMenu",0
        DCB     "DecodeMenu",0
        DCB     "WhichIcon",0
        DCB     "SetExtent",0
        DCB     "SetPointerShape",0
        DCB     "OpenTemplate",0
        DCB     "CloseTemplate",0
        DCB     "LoadTemplate",0
        DCB     "ProcessKey",0
        DCB     "CloseDown",0

        DCB     "StartTask",0
        DCB     "ReportError",0
        DCB     "GetWindowOutline",0
        DCB     "PollIdle",0
        DCB     "PlotIcon",0
        DCB     "SetMode",0
        DCB     "SetPalette",0
        DCB     "ReadPalette",0
        DCB     "SetColour",0
        DCB     "SendMessage",0
        DCB     "CreateSubMenu",0
        DCB     "SpriteOp",0
        DCB     "BaseOfSprites",0
        DCB     "BlockCopy",0
        DCB     "SlotSize",0
        DCB     "ReadPixTrans",0
        DCB     "ClaimFreeMemory",0
        DCB     "CommandWindow",0
        DCB     "TextColour",0
        DCB     "TransferBlock",0
        DCB     "ReadSysInfo",0
        DCB     "SetFontColours",0

        DCB     "GetMenuState",0
        DCB     "RegisterFilter",0
        DCB     "AddMessages",0

        DCB     "RemoveMessages",0
        DCB     "SetColourMapping",0

        DCB     "TextOp",0
        DCB     "SetWatchdogState",0
        DCB     "Extend",0
        DCB     "ResizeIcon",0

        DCB     "AutoScroll",0

        DCB     0
        ALIGN


;;-----------------------------------------------------------------------------
;; Wimp_ReadSysInfo - return information given specfic index
;;
;; in   R0 = index
;; out  R0 = value (depends on R0 on entry)
;;      R1 = value (depends on R0 on entry)
;;-----------------------------------------------------------------------------

SWIWimp_ReadSysInfo
        MyEntry "ReadSysInfo"
;
        CMP     R0,#(err_badR0-%00)/4
        ADDCC   PC,PC,R0,LSL #2         ; yeehaa its valid so despatch
        B       err_badR0               ; otherwise return
00
        B       sysinfo_TaskCount       ; 0 = task count
        B       sysinfo_WimpMode        ; 1 = current wimp mode
        B       sysinfo_SpriteSuffix    ; 2 = suffix for icon sprites
        B       sysinfo_DesktopState    ; 3 = state of the desktop
        B       sysinfo_WriteDir        ; 4 = write direction
        B       sysinfo_CurrentTask     ; 5 = return current task
        B       sysinfo_Swapping        ; 6 = swapping information / error if not swapping version
        B       sysinfo_Version         ; 7 = Get wimp version
        B       sysinfo_SystemFont      ; 8 = Get system font handle
        B       sysinfo_ToolSprites     ; 9 = ToolSpriteCB
        B       sysinfo_IconBarInt      ; 10= Iconbar info             (Internal)
        B       sysinfo_appspace        ; 11= App space size           
        B       sysinfo_messages        ; 12= message queue            (Internal)
        B       sysinfo_memclaim        ; 13= list of memory claims    (Internal)
        B       sysinfo_transtables     ; 14= tool plotting info       (Internal)
	B	err_badR0               ; 15= iconise button           (Internal)
	B       sysinfo_baseofsprites   ; 16= low/high priority sprite areas
	B       sysinfo_pausedelay      ; 17= drag-and-drop scroll startup delay
        B       err_badR0               ; 18= ?                        (ROL)
        B       err_badR0               ; 19= priority sprite area     (ROL)
        B       err_badR0               ; 20= special highlight colour (ROL)
        B       err_badR0               ; 21= text selection behaviour (ROL)
        B       err_badR0               ; 22= caret colour             (ROL)
        B       sysinfo_dragging        ; 23= mouse drag delay
        B       sysinfo_doubleclicks    ; 24= double click delay
        B       sysinfo_automenus       ; 25= auto menu open settings
        B       sysinfo_iconbar         ; 26= iconbar speed and acceleration
        B       err_badR0               ; 27= screen edge notification (ROL)
        B       sysinfo_3Dpatch         ; 28= visual flags
        B       sysinfo_alphasprites    ; 29= alpha sprites

err_badR0
        MyXError  WimpBadSysInfo
        B       ExitWimp
        MakeErrorBlock WimpBadSysInfo

;..............................................................................

sysinfo_TaskCount
        LDR     R0,taskcount            ; R0 = number of active tasks
        B       ExitWimp

sysinfo_WimpMode
        LDR     R0,currentmode          ; R0 = current desktop mode
        B       ExitWimp

sysinfo_SpriteSuffix
        ADR     R0,romspr_suffix
        B       ExitWimp

sysinfo_DesktopState
        LDR     R0,taskcount
        CMP     R0,#0                   ; R0=0 => Wimp inactive
        LDRNE   R0,commandflag
        EORNES  R0,R0,#cf_active        ; R0=0 => command window active
        MOVNE   R0,#1                   ; R0=1 => desktop vdu state set
        B       ExitWimp

sysinfo_WriteDir
        LDR     R0,writeabledir         ; R0 = write direction
        B       ExitWimp

sysinfo_CurrentTask
        LDR     R0,taskhandle           ; R0 = task handle
        LDR     R1,[wsptr,R0]           ; R1 -> task record
        TEQ     R1,#task_unused
;
        LDRNE   R1,[R1,#task_wimpver]   ; if used slot then return handle + wimp ver known
        STRNE   R1,[SP,#4*0]
        BLNE    fulltaskhandle
        MOVNE   R0,R14
        MOVEQ   R0,#0                   ; setup meaningful task handle =0 if none, else current
;
        B       ExitWimp

sysinfo_Swapping
      [ Swapping
        ADR     R0,swapping
        B       ExitWimp
      |
        B       err_badR0
      ]

sysinfo_Version
        LDR     R0,=Module_Version
        B       ExitWimp
        LTORG
        
sysinfo_SystemFont
      [ outlinefont
        LDR     R0,systemfont           ; zero if no font, cf spec
        LDR     R1,symbolfont
        B       sysinfo_exitR0R1
      |
        B       err_badR0
      ]

sysinfo_ToolSprites
        ADRL    R0,tool_areaCB
        B       ExitWimp

sysinfo_IconBarInt
        ADRL    R0,iconbarhandle
        MOV     R1,#w_icons
        MOV     R2,#w_nicons
        ADRL    R3,iconbarleft
        ADRL    R4,iconbarright
        STMIA   sp,{R1-R4}
        B       ExitWimp

sysinfo_dragging
        LDRB    R0,drag_movelimit
        LDR     R1,drag_timelimit
sysinfo_exitR0R1
        STR     R1,[sp]
        B       ExitWimp

sysinfo_doubleclicks
        LDRB    R0,doubleclick_movelimit
        LDR     R1,doubleclick_timelimit
        B       sysinfo_exitR0R1

sysinfo_3Dpatch
      [ ThreeDPatch
        LDR     R0,ThreeDFlags
        B       ExitWimp
      |
        B       err_badR0
      ]

sysinfo_iconbar
        LDR     R0,iconbar_scroll_speed
        LDR     R1,iconbar_scroll_accel
        B       sysinfo_exitR0R1

sysinfo_automenus
        LDR     R0,automenu_timelimit
        LDR     R1,menudragdelay
        B       sysinfo_exitR0R1
                
sysinfo_appspace
        LDR     R0,orig_applicationspacesize
        B       ExitWimp

sysinfo_messages
        ADR     R0,headpointer
      [ NKmessages1
        ADRL    R1,lastpointer
        B       sysinfo_exitR0R1
      |
        B       ExitWimp
      ]

sysinfo_memclaim
      [ DebugMemory
        ADRL    R0,memory_claims
        LDR     R0,[R0]
      ]
        B       ExitWimp

sysinfo_transtables
        LDR     R0,tpixtable_at
        ADRL    R2,tool_plotparams
        LDR     R1,[R2]
        STMIA   sp,{R1-R2}
        B       ExitWimp

sysinfo_baseofsprites
      [ SpritePriority
        LDR     R0, baseoflosprites
        LDR     R1, baseofhisprites
	B	sysinfo_exitR0R1
      |
        B       err_badR0
      ]

sysinfo_pausedelay
      [ Autoscr
        LDRB    R0, autoscr_default_pause
        ADD     R0, R0, R0, LSL #2  ; * 5
        MOV     R0, R0, LSL #1      ; * 10
	B	ExitWimp
      |
        B       err_badR0
      ]

sysinfo_alphasprites
        ; Bit 0: Alpha-masked sprites supported by OS/Wimp and will be looked
        ;        for by IconSprites, Wimp_Extend 13, etc.
        ; Bits 1-31: reserved
      [ SpritesA
        LDRB    R0, alphaspriteflag
        ANDS    R0, R0, #255
        MOVNE   R0, #1
      |
        MOV     R0, #0
      ]
        B       ExitWimp

;;-----------------------------------------------------------------------------
;; Command Window handling
;;-----------------------------------------------------------------------------
;
; Entry:  R0 --> title string for window
;                (open command window if anything is sent via WrchV)
;         R0 = 1 ==> treat command window as open without displaying it
;         R0 = 0 ==> close command window, and get off WrchV, prompting
;         R0 < 0 ==> close command window, and get off WrchV, quietly
;

                ^       0
cf_dormant      #       1
cf_pending      #       1
cf_active       #       1
cf_wimpdoingvdu	*	1 :SHL: 6	; set by various wimp routines
cf_suspended    *       1 :SHL: 7       ; set by ADFS UpCall handler

SWIWimp_CommandWindow
        MyEntry "CommandWindow"
;
        BL      int_commandwindow
        B       ExitWimp

int_commandwindow
        Push    "R7,LR"                 ; save R7 to help Poll code
;
        Debuga  co,"Wimp_CommandWindow: R0=",R0
;
        LDR     handle,commandhandle    ; if this doesn't exist,
        BL      checkhandle             ; give up now!
        Pull    "R7,PC",VS
;
        AcceptLoosePointer_Neg R0,-1
        CMP     R0, R0, ASR #31
        BEQ     releasewrch             ; R0 = 0 or -1 ==> remove window
        CMP     R0,#1
        BEQ     treatasactive           ; R0 = 1 ==> treat as open
;
        LDR     R14,[handle,#w_titleflags]
        ORR     R14,R14,#if_indirected          ; force indirection
        STR     R14,[handle,#w_titleflags]
;
        STR     R0,[handle,#w_title+0]
        MOV     R14,#-1
        STR     R14,[handle,#w_title+4]         ; no validation string
        MOV     R14,#1
        STR     R14,[handle,#w_title+8]         ; length 1 will do
;
 [ true
        BL      resizecommandwindow
 ]
;
        BL      commandtextwindow       ; do this now so text width correct
;                                       ; NB must be done BEFORE OS_Claim!
        MOV     R0,#WrchV
        ADR     R1,mywrch
        MOV     R2,wsptr
        SWI     XOS_Claim
        Debug   co," - Claimed wrchV"
;
        BL      restorekeys_withescape  ; bodge about with singletaskhandle
;
        MOV     R14,#cf_pending
        STR     R14,commandflag         ; command window pending
;
        Debug   co," - Command window pending"
;
        Pull    "R7,PC"


treatasactive
        Debug   co," - Treat command window as active"
;
        MOV     R0,#WrchV
        ADR     R1,mywrch
        MOV     R2,wsptr
        SWI     XOS_Release
        CLRV                            ; ignore errors
;
        BL      restorekeys_withescape  ; set up key codes, as for normal case
;
        MOV     R14,#cf_active
        STR     R14,commandflag
        Pull    "R7,PC"


restorekeys_withescape
        Push    "LR"
;
        LDR     R14,singletaskhandle    ; FORCE escape to be re-enabled
        Push    "R14"
        MOV     R14,#nullptr
        STR     R14,singletaskhandle
        BL      restorekeycodes         ; restore escape etc. temporarily
        Pull    "R14"
        STR     R14,singletaskhandle
;
        Pull    "PC"

resetkeys_withescape
        Push    "LR"
;
        LDR     R14,singletaskhandle    ; FORCE escape to be re-disabled
        Push    "R14"
        MOV     R14,#nullptr
        STR     R14,singletaskhandle
        BL      resetkeycodes           ; also re-disable escape after temporary restoration
        Pull    "R14"
        STR     R14,singletaskhandle
;
        Pull    "PC"

execcom2 DCB	"Exec",0
	ALIGN

releasewrch
        Debug   co," - Turn off command window"
;
        LDR     R14,commandflag
        TEQ     R14,#cf_dormant
        Pull    "R7,PC",EQ                 ; nothing to do!
;
        Push    "R0,R14"
;
        MOV     R14,#cf_dormant         ; not in a command window any more!
        STR     R14,commandflag
        ADR     R0,execcom2             ; cancel exec file (just in case)
        SWI     XOS_CLI                 ; cf. Wimp_ReportError
        ADRL    R3,tempiconblk
        BL      resetkeys_withescape    ; back to normal
        MOV     R0,#WrchV                       ; doesn't matter if released
        ADR     R1,mywrch                       ;                    already!
        MOV     R2,wsptr
        SWI     XOS_Release
;
        Pull    "R0,R14"
        CMP     R14,#cf_active          ; clears V
        BNE     closit                  ; just in case!!!
;
 [ :LNOT: NoCommandPrompt		; always do this quietly
;
        CMP     R0,#-1                  ; R0 = -1 ==> do this quietly
;
        BEQ     %FT01

        Push    "r2,r3"
        SWI     XOS_NewLine
;
        ADR     r0,pressspace
        ADRL    r2,errorbuffer
        MOV     r3,#256
        BL      LookupToken1            ; get command line to be used
;
        ADRL    r0,errorbuffer
        SWI     XOS_Write0
        SWI     XOS_NewLine
        Pull    "r2,r3"
;
        BL      waitforkey
01
;
 ] ;	:LNOT: NoCommandPrompt
;
        SWI     XOS_WriteI+5            ; get rid of cursor!
closit
        BL      int_close_window        ; handle --> window
        Pull    "R7,PC"

pressspace      DCB     "Space",0
                ALIGN

; Exit:  R1 = &1B ==> escape pressed, 0 ==> mouse click, else key code

waitforkey
        Push    "LR"
;
        BL      flushkbdmouse
11
        BL      powersave_tick
        BL      pollforkey
        BEQ     %BT11
;
        Pull    "PC"

; Out   Z=0 ==> result in R1, else carry on polling

pollforkey
        Push    "R2,R3,LR"

        Debug   err,"PollForKey"

        LDR     R3,mousebuttons         ; 'old' button state
        BL      getmouseposn
        BICS    R14,R2,R3
        MOVNE   R1,#0                   ; 0 ==> mouse click did it
        Debug   err,"Mouse?"
        Pull    "R2,R3,PC",NE
;
        Debug   err,"No mouse press"
        MOV     R0,#&81                 ; read key with 0 time limit
        MOV     R1,#0
        MOV     R2,#0
        SWI     XOS_Byte
;
        TEQ     R1,#&FF
        Debug   err,"Key ?"
        Pull    "R2,R3,PC",LS           ; EQ or CC
        Debug   err,"No key !"
;
        MOV     R0,#124                 ; clear escape condition
        SWI     XOS_Byte
        MOVS    R1,#&1B                 ; Z=0
;
        Pull    "R2,R3,PC"


flushkbdmouse
        Push    "R1-R3,LR"
;
        MOV     R0,#15                  ; flush keyboard buffer
        MOV     R1,#1
        SWI     XOS_Byte
;
        MOV     R0,#21                  ; flush mouseahead buffer
        MOV     R1,#9
        SWI     XOS_Byte
;
        BL      getmouseposn            ; read initial button state
;
        Pull    "R1-R3,PC"

; if a character is printed, activate the command window

mywrch
        Push    "R0-R11,LR"
;
; ignore chars if suspended (Upcall handler does this), or if its
; us doing the VDU!
;
        LDR     R14,commandflag
        TST     R14,#cf_suspended:OR:cf_wimpdoingvdu
        Pull    "R0-R11,PC",NE
;
        Debug   co,"Activate command window"
;
        MOV     R0,#WrchV               ; get off the vector now!
        ADR     R1,mywrch
        MOV     R2,wsptr
        SWI     XOS_Release
;
        MOV     R14,#cf_active
        STR     R14,commandflag

; optimisation - if first char is 22 (mode change),
; don't bother about window cos it'll be overwritten anyway

        LDR     R0,[sp]
        TEQ     R0,#22
        TEQNE   R0,#16                  ; clear G area, oh ma god, FM reentrancy!!!
        Pull    "R0-R11,PC",EQ

; open command window and explicitly redraw it (no Wimp_Polls)

        LDR     R0,commandhandle
        Abs     handle,R0
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{R1-R6}
        MOV     R7,#-1                  ; open at top
;
        Push    "R0-R7"
        MOV     userblk,sp
        BL      int_open_window

        Debug   opn, "Calling int_flush_opens to open command window"
      [ ChildWindows
        BLVC    int_flush_opens         ; flush this before calling visibleouterportion
      ]

        ADRL    userblk,tempiconblk
        BLVC    visibleouterportion     ; handle --> window definition already
        BLVC    int_redraw_window
        BVS     %FT02
01
        TEQ     R0,#0                   ; redraw window now, cos there
        BEQ     %FT02                   ; won't be any Wimp_Poll calls!
        BL      int_get_rectangle
        BVC     %BT01
02
        ADD     sp,sp,#8*4              ; correct stack

; set up corresponding text window and colours

        BL      commandtextwindow       ; VDU 28,x0,y0,x1,y1 etc.
        SWI     XOS_WriteI+4
;
        LDRB    R0,[handle,#w_wfcol]
        BIC     R0,R0,#&80
        SWI     XWimp_TextColour
;
        LDRB    R0,[handle,#w_wbcol]
        ORR     R0,R0,#&80
        SWI     XWimp_TextColour
;
        SWI     XOS_WriteI+12
        SWI     XOS_WriteI+15           ; scroll mode off!
;
        Pull    "R0-R11,PC"             ; pass on the character

 [ true
resizecommandwindow
        Push    "R1,cx0-cy1,handle,LR"
        LDR     cy1,scry1
        LDR     R0,textysize
        ADD     cy1,cy1,R0
        BIC     cy1,cy1,R0              ; ensure top aligned if odd number of rows
        MOV     R1,cy1,LSR #1
        SUB     R1,R1,cy1,LSR #4
        ADD     R1,R1,cy1,LSR #6
        SUB     R1,R1,cy1,LSR #8        ; 0.45 * screen height (or pretty close to)
        DivRem  cy0,R1,R0,R14,norem
        BIC     cy0,cy0,#1              ; round down to even number of rows
        MUL     cy0,R0,cy0              ; scale back to OS units
        CMP     cy0,#1024
        MOVHI   cy0,#1024               ; cap at 1024 OS units

        LDR     cx1,scrx1
        BIC     cx1,cx1,R0              ; ensure left aligned if odd number of columns
        LDR     R0,textxsize
        SUB     R1,cx1,cx1,LSR #2       ; 0.75 * screen width
        DivRem  cx0,R1,R0,R14,norem
        BIC     cx0,cx0,#1              ; round down to even number of columns
        MUL     cx0,R0,cx0              ; scale back to OS units
        CMP     cx0,#1280
        MOVHI   cx0,#1280               ; cap at 1280 OS units

        LDR     R0,commandhandle
        Abs     handle,R0
        MOV     R14,#-12                ; 12 pixels above first line
        SUB     R14,R14,cy0             ; min extent
        STR     cx0,[handle,#w_wex1]
        STR     R14,[handle,#w_wey0]

        MOV     cy1,cy1,LSR #1          ; centre
        MOV     cx1,cx1,LSR #1
        MOV     R1,cy0,LSR #1
        MOV     R0,cx0,LSR #1
        SUB     cy0,cy1,R1
        ADD     cy1,cy1,R1
        SUB     cx0,cx1,R0
        ADD     cx1,cx1,R0
        ADD     cy1,cy1,#12             ; 12 pixels above first line
        ADD     R0,handle,#w_wax0
        STMIA   R0,{cx0-cy1}
        Pull    "R1,cx0-cy1,handle,PC"
 ]

commandtextwindow
        Push    "R1-R11,LR"
;
        LDR     R0,commandhandle
        Abs     handle,R0
        ADD     handle,handle,#w_wax0
;
        SWI     XOS_WriteI+28           ; define text window
        LDR     cy1,scry1
        SUB     cy1,cy1,#1
        MOV     R1,#4                   ; number of coords to do
01
        TST     R1,#1
        LDREQ   cx0,textxsize           ; depends on mode (chars not scaled)
        LDRNE   cx0,textysize
        LDR     x0,[handle],#4          ; get window coords in turn
        RSBNE   x0,x0,cy1
        SUB     cx1,cx0,#1
        TST     R1,#2                   ; ensure text window entirely contained
        ADDEQ   x0,x0,cx1               ; within Wimp window
        SUBNE   x0,x0,cx1               ; (NB y-coords are upside-down)
        DivRem  R0,x0,cx0,R14,norem
        SWI     XOS_WriteC
        SUBS    R1,R1,#1
        BNE     %BT01
;
        ADR     R0,scrollprot           ; turn on the 'scroll protect' bit
        MOV     R1,#endscrollprot-scrollprot
        SWI     XOS_WriteN
;
        Pull    "R1-R11,PC"

scrollprot      DCB     4                       ; VDU 4
                DCB     23, 1,0,  0,0,0,0,0,0,0 ; turn cursor off
                DCB     23,16,1,&FE,0,0,0,0,0,0 ; enable scroll protect
endscrollprot
                ALIGN

;;-----------------------------------------------------------------------------
;; *POINTER  -  calls internal SWI
;;-----------------------------------------------------------------------------

;
; Turn mouse pointer on/off
; If turning it on, also set up the mouse pointer data
;

Pointer_Code
        Push    "R0-R12,LR"
        LDR     R12,[R12]
;
        CMP     R1,#0
        BEQ     Pointer1_Code
        LDRB    R1,[R0]
        CMP     R1,#"0"
        BEQ     Pointer0_Code
        CMP     R1,#"1"
        BEQ     Pointer1_Code
        CMP     R1,#"2"
        BEQ     Pointer2_Code
;
        MyXError  WimpBadPointer
;
exitswi
        STRVS   R0,[sp]
        Pull    "R0-R12,PC"

        MakeErrorBlock WimpBadPointer

; Internal routines to set up the pointer shape
; These use the palette inside the sprite, rather than the WimpPalette

doubleptr_on
        EntryS  "R0,R2,R3"

        ADR     R2,ptr_double
        B       %FT01

doubleptr_off
        ALTENTRY

        ADR     R2,ptr_default
01
        BL      testptrshape
        MOVEQ   R3,#1                   ; program pointer shape, number and palette
        MOVNE   R3,#&61
        BL      setptr_shape

        EXITS                           ; ignore errors

testptrshape
        Push    "R0-R2,LR"

        MOV     R0,#&6A                 ; set/read pointer shape no
        MOV     R1,#127                 ; this is invalid, so won't be set
        SWI     XOS_Byte                ; R1 := actual shape number
        CMP     R1,#1

        Pull    "R0-R2,PC"              ; Z set => current shape = 1

; In    R2 -> pointer shape name
;       R3 = shape number to set, plus flags

setptr_shape
        Push    "R0-R7,LR"

        MOV     R0,#SpriteReason_SetPointerShape
      [ Autoscr
        LDR     R14, autoscr_state      ; don't reprogram pointer if autoscrolling is enabled
        TST     R14, #af_enable
        ORRNE   R3, R3, #&10
      ]
        MOV     R4,#0                   ; active point at top-left
        MOV     R5,#0
        MOV     R6,#0
        MOV     R7,#0
        SWI     XWimp_SpriteOp          ; take from Wimp's sprite area(s)

        STRVS   R0,[sp]
        Pull    "R0-R7,PC"

ptr_double      DCB     "ptr_double",0          ; now moved so that starterrorbox_draw can access ptr_default
ptr_default     DCB     "ptr_default",0
                ALIGN


; set up mouse pointer shape

Pointer1_Code
        BL      readvduvars2            ; including screen size

        ADRVC   R2,ptr_default
        MOVVC   R3,#1                   ; program shape 1, set ptr and palette
        BLVC    setptr_shape            ; active point at top-left
        BLVC    clearpointerwindow
        B       exitswi

Pointer0_Code
        MOV     R0,#0
        BL      int_set_pointer_shape

Pointer2_Code
        B       exitswi


;
; Set_Pointer_Shape
; Entry:  R0 = shape number (1-4), or 0 ==> turn pointer off
;         R1 --> shape data
;         R2,R3 = width, height (pixels)
;         R4,R5 = active point (pixels from top-left)
;

SWIWimp_SetPointerShape
        MyEntry "SetPointerShape"

        BL      int_set_pointer_shape
        B       ExitWimp

int_set_pointer_shape
        Push    "LR"
;
        CMP     R0,#0
        AcceptLoosePointer_Neg R1,nullptr,NE,R14
        CMPNE   R1,#nullptr             ; null pointer if = -1
        BEQ     justsetshape
;
        Push    "R0-R5"
        SUB     sp,sp,#12
        MOV     R14,#0
        STRB    R14,[sp,#2+0]           ; reason code 0 ==> set shape
        STRB    R0,[sp,#2+1]            ; shape number
        MOV     R14,R2,ASR #2           ; 4 pixels per byte
        STRB    R14,[sp,#2+2]           ; width (bytes)
        STRB    R3,[sp,#2+3]            ; height (pixels)
        STRB    R4,[sp,#2+4]            ; active point X
        STRB    R5,[sp,#2+5]            ; active point Y
        STR     R1,[sp,#2+6]            ; word-aligned (I hope!)
        MOV     R0,#&15
        ADD     R1,sp,#2                ; to allow word-alignment of ptr
        SWI     XOS_Word
        ADD     sp,sp,#12
        STRVS   R0,[sp]
        Pull    "R0-R5"
        Pull    "PC",VS
;
justsetshape
        MOV     R1,R0                   ; pointer shape
        MOV     R2,#0                   ; pointer linked to mouse
        MOV     R0,#&6A
        SWI     XOS_Byte
        Pull    "PC"


;;-----------------------------------------------------------------------------
;; Rectangle handling routines: intrect, subrect, addrect, addtolist
;;-----------------------------------------------------------------------------

;;------------------------------------
;; Intrect - take a list and a rectangle and produce the intersection
;;
;; Entry :  cx0,cy0,cx1,cy1 = rectangle to clip to
;;          R0 = index of source link pointer
;;          R1 = index of dest. link pointer
;;-------------------------------------

intrect
        Push    "R0,R1,userblk,handle,LR"
        SetRectPtrs
;
        LDR     R14,dx_1                ; ensure coords are aligned to pixels
        BIC     cx0,cx0,R14
        BIC     cx1,cx1,R14
        LDR     R14,dy_1
        BIC     cy0,cy0,R14
        BIC     cy1,cy1,R14
;
        Push    R1                      ; destination list
;
        MOV     R1,R0
        B       endintrect
intrectlp
        getxy   R1,x,y
        max     x0,cx0
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1
        BL      addtolist                       ; add x0,y0,x1,y1 to list
endintrect
        LDR     R1,[rectlinks,R1]
        CMP     R1,#nullptr
        BNE     intrectlp
;
        Pull    R0
        BL      assign                  ; switch to destination list
;
        Pull    "R0,R1,userblk,handle,PC"

;;-----------------------------------------------
;; subrect - take a list and a rectangle and produce the non-intersection
;;
;; Entry :  cx0,cy0,cx1,cy1 = rectangle to clip to
;;          R0 = index of source head link pointer
;;          R1 = index of destination head link pointer
;;------------------------------------------------

subwindowrect
        MOV     R0,#windowrects
        MOV     R1,R0

subrect
;        Debug   opn, "subrect: called with R0,R1,cx0-cy1 =", R0, R1, cx0, cy0, cx1, cy1
        Push    "R0,R1,userblk,handle,LR"
        SetRectPtrs
;
        Push    R1                      ; R1 --> destination list
        BL      addsub                  ; used also by addrect
        Pull    R0
        BL      assign
;
        Pull    "R0,R1,userblk,handle,PC"


;;-----------------------------------------------
;; addrect - take a list and a rectangle and add them together
;;
;; Entry :  cx0,cy0,cx1,cy1 = rectangle to add in
;;          R0 = index of source head link pointer
;;          R1 = index of destination head link pointer
;;------------------------------------------------

addrect
        Push    "R0,R1,userblk,handle,LR"
        SetRectPtrs
;
        Push    R1                      ; R1 --> destination list
        BL      addsub                  ; get non-intersecting part
        Push    "cx0,cy0,cx1,cy1"
        Pull    "x0,y0,x1,y1"
        BL      addtolist               ; then add the rectangle itself
        Pull    R0
        BL      assign
;
        Pull    "R0,R1,userblk,handle,PC"

;;---------------------------
;; addsub - used by both of the above routines
;; Entry :  R0 --> item under consideration
;;          cx0,cy0,cx1,cy1 = rectangle to (not) clip to
;; Exit :   'torects' list updated
;;---------------------------

addsub
        Push    LR
;
        LDR     R14,dx_1                ; ensure coords are aligned to pixels
        BIC     cx0,cx0,R14
        BIC     cx1,cx1,R14
        LDR     R14,dy_1
        BIC     cy0,cy0,R14
        BIC     cy1,cy1,R14
;
        MOV     R1,R0
        B       endaddsublp
addsublp
        ADD     R0,rectcoords,R1,ASL #2
;
        LDMIA   R0,{x0,y0,x1,y1}
        min     y0,cy0                  ; x0,min(y0,cy0),x1,min(y1,cy0)
        min     y1,cy0
        BL      addtolist
;
        LDMIA   R0,{x0,y0,x1,y1}        ; x0,max(y0,cy1),x1,max(y1,cy1)
        max     y0,cy1
        max     y1,cy1
        BL      addtolist
;
        LDMIA   R0,{x0,y0,x1,y1}
        max     y0,cy0                  ; y0 <- max(y0,cy0)
        min     y1,cy1                  ; y1 <- min(y1,cy1)
;
        min     x0,cx0                  ; min(x0,cx0),y0,min(x1,cx0),y1
        min     x1,cx0
        BL      addtolist
;
        LDR     x0,[R0,#0]
        LDR     x1,[R0,#8]
        max     x0,cx1                  ; max(x0,cx1),y0,max(x1,cx1),y1
        max     x1,cx1
        BL      addtolist
;
endaddsublp
        LDR     R1,[rectlinks,R1]
        CMP     R1,#nullptr
        BNE     addsublp
;
        Pull    PC


;;---------------------------------------------------------
;; addtolist - megaroutine that optimises the rectangle combinations
;;
;; Entry :  x0,y0,x1,y1 = rectangle to be added in
;;          rectlinks, rectcoords already set up
;; Exit :   'torects' list updated (and optimised)
;;          all registers preserved
;;---------------------------------------------------------

addtolist
        Push    "cx0,cy0,cx1,cy1,LR"
;
        LDR     R14,BPR_indication
        CMP     R14,#BPR_nullrectops
      [ debugbpr
        BHI     %FT00
        Debug   bpr,"addtolist skipping rectangles reason:",R14
00
      ]
        Pull    "cx0,cy0,cx1,cy1,PC",LS ; In a no rectangle ops situation
;
        ADR     R14,scrx0
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        max     x0,cx0                  ; watch out for screen boundary!
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1
;
        CMP     x0,x1
        CMPLT   y0,y1
        Pull    "cx0,cy0,cx1,cy1,PC",GE ; null rectangle
;
        Push    "R0,R1,x0,y0,x1,y1"
;
addtotop
        MOV     R0,#torects             ; 'previous' link
        LDR     R1,[rectlinks,R0]
        CMP     R1,#nullptr
        BEQ     addtoend                ; done with all rectangles
;
addtolp
        getxy   R1,cx,cy
;
        CMP     x0,cx0
        CMPEQ   x1,cx1
        BNE     tryaddtoy
;
        CMP     y0,cy1
        MOVEQ   y0,cy0
        BEQ     addtogotcha
        CMP     y1,cy0
        MOVEQ   y1,cy1
        BEQ     addtogotcha
tryaddtoy
        CMP     y0,cy0
        CMPEQ   y1,cy1
        BNE     trynextaddto
;
        CMP     x0,cx1
        MOVEQ   x0,cx0
        BEQ     addtogotcha
        CMP     x1,cx0
        MOVEQ   x1,cx1
        BNE     trynextaddto
;
; delete old rectangle from list, and feed new one in at top
;
addtogotcha
        LDR     R14,[rectlinks,R1]
        STR     R14,[rectlinks,R0]              ; link(R0)=link(R1)
        LDR     R14,[rectlinks,#freerects]
        STR     R14,[rectlinks,R1]              ; link(R1)=link(free)
        STR     R1,[rectlinks,#freerects]       ; link(free)=R1
        B       addtotop                        ; add new x0,y0,x1,y1
                                                ; (N.B. cannot be null)
;
trynextaddto
        MOV     R0,R1                           ; remember previous link
        LDR     R1,[rectlinks,R1]
        CMP     R1,#nullptr
        BNE     addtolp
;
; now all we can do is to stuff the new rectangle on the end
;
addtoend
        BL      newrect                         ; coords are x0,y0,x1,y1
        CMP     R1, #nullptr
        STRNE   R1,[rectlinks,R0]               ; link(R0)=R1
;
        Pull    "R0,R1,x0,y0,x1,y1"
        Pull    "cx0,cy0,cx1,cy1,PC"

;;------------------------------------
;; loserects - add list of rectangles to the free list
;; Entry :  R0 = index of head pointer
;;          rectlinks, rectcoords already set up
;;------------------------------------

losewindowrects
        MOV     R0,#windowrects

loserects
        EntryS  "R0,R1,userblk,handle"
        SetRectPtrs
;
        LDR     R1,[rectlinks,R0]               ; R1=link(R0)
        MOV     R14,#nullptr
        STR     R14,[rectlinks,R0]              ; link(R0)=#nullptr
        CMP     R1,#nullptr
        BEQ     endloserects
;
loserectslp
        LDR     R0,[rectlinks,R1]               ; R0=link(R1)
        LDR     R14,[rectlinks,#freerects]
        STR     R14,[rectlinks,R1]              ; link(R1)=link(free)
        STR     R1,[rectlinks,#freerects]       ; link(free)=R1
        MOV     R1,R0                           ; R1 = R0
        CMP     R1,#nullptr
        BNE     loserectslp
endloserects
;
        EXITS                                   ; must preserve flags

;;-------------------------------------
;; assign - move 'torects' list to one pointed to by R0
;;-------------------------------------

      [ ChildWindows
assign_set      ROUT
        Push    "userblk,handle,LR"
        SetRectPtrs
        BL      assign
        Pull    "userblk,handle,PC"
      ]

; NB: This version assumes that SetRectPtrs has already been called

assign
        TEQ     R0,#torects                     ; same list!
        MOVEQ   PC,LR
;
        Push    LR
;
        BL      loserects                       ; preserves R0
        LDR     R14,[rectlinks,#torects]
        STR     R14,[rectlinks,R0]              ; link(R0)=link(torects)
        MOV     R14,#nullptr
        STR     R14,[rectlinks,#torects]        ; link(torects)=#nullptr
;
        Pull    PC

;;------------------------------------------
;; copyrects - copy a set of rectangles
;; Entry :  R0 = source index
;;          R1 = destination index
;; Exit  :  rectangles copied
;;------------------------------------------

      [ ChildWindows

copyrects  Entry  "R0-R2,x0,y0,x1,y1,handle,userblk"

        Debug   opn,"copyrects from/to",R0,R1

        SetRectPtrs

        MOV     R0,R1
        BL      loserects

        LDR     R0,[SP]
        MOV     R2,R1

01      LDR     R0,[rectlinks,R0]
        CMP     R0,#nullptr
        BEQ     %FT90

        getxy   R0,x,y

        Debug   opn,"copying rectangle",x0,y0,x1,y1

        BL      newrect
        CMP     R1,#nullptr
        STRNE   R1,[rectlinks,R2]
        MOVNE   R2,R1
        BNE     %BT01
90
        EXIT
      ]

;;------------------------------------------
;; newrect - get a space from the free list
;; Entry :  x0,y0,x1,y1 = coords to put into entry
;; Exit :   R1 --> new entry
;;                 or nullptr if no rectangle to be had
;;          coords and link are set up
;;          all other registers preserved
;;------------------------------------------

newrect
        Push    LR
;
        LDR     R1,[rectlinks,#freerects]       ; R1=link(free)
        CMP     R1,#nullptr
        BEQ     errnorects
        LDR     R14,[rectlinks,R1]
        STR     R14,[rectlinks,#freerects]      ; link(free)=link(R1)
        MOV     R14,#nullptr
        STR     R14,[rectlinks,R1]              ; link(R1)=#nullptr
;
        putxy   R1,x,y
;
        Pull    PC

errnorects
        BL      initrectptrs                    ; help!
        ; BPR_indication:
        ; 1sttry   -> panicnow
        ; notatall -> gotfullarea
        ; Others shouldn't arrive here, but leave alone anyway
        LDR     R14,BPR_indication
        TEQ     R14,#BPR_1sttry
        MOVEQ   R14,#BPR_panicnow
        TEQ     R14,#BPR_notatall
        MOVEQ   R14,#BPR_gotfullarea
        Debug   bpr,"BPR indication after norect:",R14
        STR     R14,BPR_indication
        MOV     R1,#nullptr
        Pull    PC

;;-----------------------------------------------------------------------
;; listrects - print rectangle list to debug output
;; Entry: R0 = index of header of list to print
;;-----------------------------------------------------------------------

      [ debugopn
listrects
        Entry   "x0-y1, handle, userblk"
        SetRectPtrs
        Debug   opn, "Rectangle list", R0
        B       %FT02
01
        getxy   R0, x, y
        Debug   opn, "Link / x0-y1 =", R0, x0, y0, x1, y1

02      LDR     R0, [rectlinks, R0]
        CMP     R0, #nullptr
        BNE     %BT01
        EXITS
      ]

;;-----------------------------------------------------------------------
;; Zap all rectangle lists and invalidate whole screen
;;-----------------------------------------------------------------------

BPR_startintelligentredraw
        Push    LR
        Debug   bpr,"Starting intelligent redraw"
        MOV     R14,#BPR_1sttry
        STR     R14,BPR_indication
        BL      BPR_invalidatewholescreen
        Pull    PC

BPR_invalidatewholescreen
        Push    LR
        BL      initrectptrs
        ADR     R14,scrx0
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        BL      markinvalid_cx0cy0cx1cy1
        Pull    PC

;;-----------------------------------------------------------------------
;; visibleportion - find rectangle list (visible) for a given window
;;-----------------------------------------------------------------------

      [ Twitter
visibleoutertwitter

        Push    "lr"
        BL      checktwitter
        Pull    "lr"
        ADDNE   r0, handle, #w_x0
        LDMNEIA r0, {x0,y0,x1,y1}
        SUBNE   y0, y0, #2
        ADDNE   y1, y1, #2
        BNE     visibleportion_x0y0x1y1
        ; if twitter not required then drop through to visibleouterportion
      ]

visibleouterportion
        ADD     R0,handle,#w_x0
        B       visibleportion

 [ ThreeDPatch
visibleinnerportion_3D
        ADD     R0,handle,#w_wax0
      [ ChildWindows
        Push    "R1,LR"
        BL      visibleportion_3D
        MOV     R1,#0
        BL      subtract_children       ; don't include children of this window
        Pull    "R1,PC"
      ]

visibleportion_3D
        LDMIA   R0,{x0,y0,x1,y1}        ; get relevant coordinates
	ADD	x0,x0,#4
	ADD	y0,y0,#4
	SUB	x1,x1,#4
	SUB	y1,y1,#4
	B	visibleportion_x0y0x1y1
 ]

visibleinnerportion
        ADD     R0,handle,#w_wax0
      [ ChildWindows
        Push    "R1,LR"
        BL      visibleportion
        MOV     R1,#0
        BL      subtract_children       ; don't include children of this window
        Pull    "R1,PC"
      ]

visibleportion
        LDMIA   R0,{x0,y0,x1,y1}        ; get relevant coordinates

visibleportion_x0y0x1y1
      [ ChildWindows
        Push    "cx0,cy0,cx1,cy1,handle,userblk,LR"
      |
        Push    "cx0,cy0,cx1,cy1,LR"
      ]

        Debug   child,"visibleportion_x0y0x1y1",handle,x0,y0,x1,y1
;
        ADR     R14,scrx0
        LDMIA   R14,{cx0,cy0,cx1,cy1}
;
        LDR     R1,[handle,#w_flags]
;
; create a one-rectangle list in windowrects
;
      [ :LNOT: ChildWindows
        Push    "userblk,handle"
      ]
        SetRectPtrs
;
        max     x0,cx0                  ; off-screen bits are invisible
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1                  ; need this cos not using 'addtolist'
;
        CMP     x0,x1
        CMPLT   y0,y1
        MOVGE   R1,#nullptr
        BGE     vispor1                 ; null list if rectangle is null
;
        TST     R1,#ws_open             ; R1 still = status
        MOVEQ   R1,#nullptr
        BLNE    newrect                 ; coords are x0,y0,x1,y1
;
vispor1
        BL      losewindowrects
        STR     R1,[rectlinks,R0]

      [ :LNOT: ChildWindows
        Pull    "userblk,handle"
        CMP     R1,#nullptr
        Pull    "cx0,cy0,cx1,cy1,PC",EQ ; done if not in stack
      |
        CMP     R1,#nullptr
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,PC",EQ ; done if not in stack
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,LR"
        ; drop through

; go through windows above this one, knocking them out
; In    handle -> window definition
;       [rectlinks,#windowrects] = rectangle(s) so far
; Out   [rectlinks,#windowrects] = visible parts of original set

visible_knockout        ROUT

        Push    "cx0,cy0,cx1,cy1,handle,userblk,LR"

40      LDR     R0,[handle,#w_flags]
        TST     R0,#wf_inborder
        MOVEQ   R0,#nullptr
        LDRNE   R0,[handle,#w_parent]
        CMPNE   R0,#nullptr
        ADDNE   R0,R0,#w_wax0                   ; we'll need to clip non-border siblings to this

        LDR     R2,[handle,#w_active_link + ll_backwards]

41      LDR     R3,[R2,#ll_backwards]
        CMP     R3,#nullptr
        BEQ     %FT45

        Push    "R0,R2,R3"

        CMP     R0,#nullptr
        LDRNE   userblk,[R2,#w_flags-w_active_link]

        ADD     R14,R2,#w_x0-w_active_link
        LDMIA   R14,{cx0,cy0,cx1,cy1}

        BEQ     %FT42

        TST     userblk,#wf_inborder
        BNE     %FT42

        LDMIA   R0,{x0,y0,x1,y1}
        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1
42
        Debug   child,"subtract sibling",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,R0
        BL      subrect
        Pull    "R0,R2,R3"

        MOV     R2,R3
        B       %BT41

45      LDR     userblk,[handle,#w_flags]       ; keep window flags

        LDR     handle,[handle,#w_parent]
        CMP     handle,#nullptr
        BEQ     %FT50

        ; check whether the parent window is closed

        LDR     R14,[handle,#w_flags]
        TST     R14,#ws_open
        BEQ     %FT70

        ; clip window list to the parent's work area or outline

        TST     userblk,#wf_inborder
        ADDNE   R14,handle,#w_x0                ; clip to outer box if allowed to overlap border
        ADDEQ   R14,handle,#w_wax0              ; clip to work area otherwise
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        Debug   child,"clip to parent work area",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,R0
        BL      intrect

        ; now continue by knocking out the siblings of the parent

        B       %BT40

70      BL      losewindowrects                 ; parent closed => so is child

50
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,PC"
      |
        ADRL    R3,activewinds+lh_forwards-ll_forwards
        ADD     R2,handle,#w_active_link        ; Translate to link's address for end check
visporlp
        LDR     R3,[R3,#ll_forwards]
        CMP     R3,R2                           ; Has end been reached (address of active_link is same)
        Pull    "cx0,cy0,cx1,cy1,PC",EQ
;
        Push    "R2,R3"
        ADD     R14,R3,#w_x0-w_active_link
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        MOV     R1,R0
        BL      subrect
        Pull    "R2,R3"
        B       visporlp
      ]

;;-----------------------------------------------------------------------
;; oldvisibleportion - find old visible rectangle list for a given window
;;-----------------------------------------------------------------------

      [ ChildWindows

      [ Twitter
oldvisibleoutertwitter

        Push    "lr"
        BL      checktwitter
        Pull    "lr"
        ADDNE   r0, handle, #w_old_x0
        LDMNEIA r0, {x0,y0,x1,y1}
        SUBNE   y0, y0, #2
        ADDNE   y1, y1, #2
        BNE     oldvisibleportion_x0y0x1y1
        ; if twitter not required then drop through to oldvisibleouterportion
      ]

oldvisibleouterportion
        ADD     R0,handle,#w_old_x0
        B       oldvisibleportion

oldvisibleinnerportion
        ADD     R0,handle,#w_old_wax0

        Push    "R1,LR"
        BL      oldvisibleportion
        MOV     R1,#0                   ; subtract all children
        BL      oldsubtract_children    ; don't include children of this window
        Pull    "R1,PC"

oldvisibleportion
        LDMIA   R0,{x0,y0,x1,y1}        ; get relevant coordinates

oldvisibleportion_x0y0x1y1
        Push    "cx0,cy0,cx1,cy1,handle,userblk,LR"

        Debug   child,"oldvisibleportion_x0y0x1y1",handle,x0,y0,x1,y1

        ADR     R14,scrx0
        LDMIA   R14,{cx0,cy0,cx1,cy1}

        LDR     R1,[handle,#w_old_flags]

; create a one-rectangle list in windowrects

        SetRectPtrs

        max     x0,cx0                  ; off-screen bits are invisible
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1                  ; need this cos not using 'addtolist'

        CMP     x0,x1
        CMPLT   y0,y1
        MOVGE   R1,#nullptr
        BGE     %FT01                   ; null list if rectangle is null

        TST     R1,#ws_open             ; R1 still = status
        MOVEQ   R1,#nullptr
        BLNE    newrect                 ; coords are x0,y0,x1,y1

01      BL      losewindowrects
        STR     R1,[rectlinks,R0]

        CMP     R1,#nullptr
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,PC",EQ ; done if not in stack
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,LR"
        ; drop through

; go through windows above this one, knocking them out
; In    handle -> window definition
;       [rectlinks,#windowrects] = rectangle(s) so far
; Out   [rectlinks,#windowrects] = visible parts of original set

oldvisible_knockout     ROUT

        Push    "cx0,cy0,cx1,cy1,handle,userblk,LR"

40      LDR     R0,[handle,#w_old_flags]
        TST     R0,#wf_inborder
        MOVEQ   R0,#nullptr
        LDRNE   R0,[handle,#w_old_parent]
        CMPNE   R0,#nullptr
        ADDNE   R0,R0,#w_old_wax0                ; we'll need to clip non-border siblings to this

        LDR     R2,[handle,#w_old_link + ll_backwards]

41      LDR     R3,[R2,#ll_backwards]
        CMP     R3,#nullptr
        BEQ     %FT45

        Push    "R0,R2,R3"

        CMP     R0,#nullptr
        LDRNE   userblk,[R2,#w_old_flags-w_old_link]

        ADD     R14,R2,#w_old_x0-w_old_link
        LDMIA   R14,{cx0,cy0,cx1,cy1}

        BEQ     %FT42

        TST     userblk,#wf_inborder
        BNE     %FT42

        LDMIA   R0,{x0,y0,x1,y1}
        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1
42
        Debug   child,"subtract sibling",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,R0
        BL      subrect
        Pull    "R0,R2,R3"

        MOV     R2,R3
        B       %BT41

45      LDR     userblk,[handle,#w_old_flags]

        LDR     handle,[handle,#w_old_parent]
        CMP     handle,#nullptr
        BEQ     %FT50

        ; check whether the parent window was closed

        LDR     R14,[handle,#w_old_flags]
        TST     R14,#ws_open
        BEQ     %FT70

        ; clip window list to the parent's work area or outline

        TST     userblk,#wf_inborder
        ADDNE   R14,handle,#w_old_x0            ; clip to parent's outline if child can go in border
        ADDEQ   R14,handle,#w_old_wax0          ; clip to parent's work area otherwise
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        Debug   child,"clip to parent work area",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,R0
        BL      intrect

        ; now continue by knocking out the siblings of the parent

        B       %BT40

70      BL      losewindowrects                 ; parent closed => so is child

50
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,PC"
      ]

;;--------------------------------------------------------------------------
;; subtract_children - remove child windows' outer rectangles from windowrects
;; In:  R1 = 0 => subtract all child windows
;;      R1 = wf_inborder => subtract border children only
;;      handle -> parent window
;;      [windowrects] set up (already within work area of parent)
;; Out: [windowrects] updated
;;--------------------------------------------------------------------------

      [ ChildWindows

subtract_children ROUT

        Push    "cx0,cy0,cx1,cy1,handle,LR"

        Debug   child,"Subtract children",handle

        LDR     handle,[handle,#w_children+lh_forwards]

10      LDR     R14,[handle,#ll_forwards]
        CMP     R14,#nullptr                                    ; Has end been reached?
        BEQ     %FT20

        LDR     cx0,[handle,#w_flags - w_active_link]
        AND     cx0,cx0,R1                                      ; don't do it if R1<>0 and bit not set
        TEQ     cx0,R1
        ADDEQ   R14,handle,#w_x0 - w_active_link
        LDMEQIA R14,{cx0,cy0,cx1,cy1}
        Debug   child,"Subtracting child window rectangle",handle,cx0,cy0,cx1,cy1
        Push    "R1"
        BLEQ    subwindowrect
        Pull    "R1"

        LDR     handle,[handle,#ll_forwards]
        B       %BT10
20
        Pull    "cx0,cy0,cx1,cy1,handle,PC"

;...........................................................................

; In    R1 = 0 => subtract all child windows
;       R1 = wf_inborder => subtract border children only
;       handle -> parent window
;       windowrects = rectangle list to subtract children from (already less than work area)
; Out   unclipped old outer rectangles of relevant children subtracted from rectangle list
;       we assume there's no need to clip the child rectangles, as the rectangle list is already clipped to it

oldsubtract_children ROUT

        Push    "cx0,cy0,cx1,cy1,handle,LR"

        Debug   child,"Old Subtract children",handle

        LDR     handle,[handle,#w_old_children+lh_forwards]

10      LDR     R14,[handle,#ll_forwards]
        CMP     R14,#nullptr                             ; Has end been reached?
        BEQ     %FT20

        LDR     cx0,[handle,#w_old_flags - w_old_link]
        AND     cx0,cx0,R1                                      ; don't do it if R1<>0 and bit not set
        TEQ     cx0,R1
        ADDEQ   R14,handle,#w_old_x0 - w_old_link
        LDMEQIA R14,{cx0,cy0,cx1,cy1}
        Debug   child,"Subtracting OLD child window rectangle",handle,cx0,cy0,cx1,cy1
        Push    "R1"
        BLEQ    subwindowrect
        Pull    "R1"

        LDR     handle,[handle,#ll_forwards]
        B       %BT10
20
        Pull    "cx0,cy0,cx1,cy1,handle,PC"

;...........................................................................

; In    handle -> parent window
;       R0 = rectangle list to subtract children from
; Out   clipped new outer rectangles of OPENING children subtracted from rectangle list
;       R1 corrupted
; Note: We must also deal with opening grandchildren, where the windows in between aren't in the opening list
;       This causes problems, as we could otherwise end up with overlapping rectangles to be copied
; Note: If a parent is opening/closing, all descendents are removed from the opening list in remove_children

subtract_openingchildren ROUT

        Push    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk,LR"

        Debug   child,"Subtract opening children",handle

        MOV     R1,R0                                   ; modify same rectangle list
        MOV     userblk,handle                          ; userblk -> original window

        LDR     handle, openingwinds + lh_forwards
10
        ASSERT  ll_forwards = 0
        LDR     R14,[handle],#-w_opening_link
        CMP     R14,#nullptr                            ; Has end been reached?
        BEQ     %FT20

        LDR     R2,[handle,#w_parent]
        B       %FT14

12      LDR     R14,[R2,#w_opening_link + ll_forwards]
        TEQ     R14,#0
        BNE     %FT15                                   ; if intervening window is opening anyway, we can ignore this one

        LDR     R2,[R2,#w_parent]

14      CMP     R2,userblk
        BEQ     %FT25

        CMP     R2,#nullptr
        BNE     %BT12

15      LDR     handle,[handle,#w_opening_link + ll_forwards]
        B       %BT10
20
        Pull    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk,PC"

; we've found a child window in the opening list that's a descendent of the window in question

25
        Push    "handle"

        ADD     R14,handle,#w_x0
        LDMIA   R14,{cx0,cy0,cx1,cy1}                   ; cx0,cy0,cx1,cy1 = outline of child

27      LDR     R14,[handle,#w_flags]
        TST     R14,#wf_inborder                        ; if child can live in parent's border,
        LDR     handle,[handle,#w_parent]
        ADDNE   R14,handle,#w_x0
        ADDEQ   R14,handle,#w_wax0
        LDMIA   R14,{x0,y0,x1,y1}                       ; x0,y0,x1,y1 = work area or outline of parent

        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1

        CMP     handle,userblk                          ; keep clipping to intervening windows
        BNE     %BT27

        Pull    "handle"

        Debug   child,"Subtracting opening child window rectangle",handle,cx0,cy0,cx1,cy1
     [ true                                             ; BJGA bugfix
        CMP     cx0, cx1                                ; optimise out these cases -
        CMPLT   cy0, cy1                                ; they are unnecessary, and can cause intermittent bugs
        BLLT    subrect
     |
        BL      subrect
     ]

        LDR     handle,[handle,#w_opening_link + ll_forwards]
        B       %BT10

;...........................................................................

; In    handle -> parent window
;       R0 = rectangle list to subtract children from
; Out   clipped old outer rectangles of OPENING children subtracted from rectangle list
;       R1 corrupted

oldsubtract_openingchildren ROUT

        Push    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk,LR"

        Debug   child,"Old Subtract opening children",handle

        MOV     R1,R0                                   ; modify same rectangle list
        MOV     userblk,handle                          ; userblk -> original window

        LDR     handle, openingwinds + lh_forwards
10
;      [ debugopn
;        Push    "R0, R1, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        LDR     R1, [sp, #2*4] ; get handle from stack
;        Debug   opn, "oldsubtract_openingchildren: next handle, borderrects =", R1, R0
;        Pull    "R0, R1, rectcoords, rectlinks"
;      ]
        ASSERT  ll_forwards = 0
        LDR     R14,[handle],#-w_opening_link
        CMP     R14,#nullptr                            ; Has end been reached?
        BEQ     %FT20

        LDR     R2,[handle,#w_old_parent]
        B       %FT14

12      LDR     R14,[R2,#w_opening_link + ll_forwards]
        TEQ     R14,#0                                  ; shouldn't that be CMP R14, #nullptr?  BJGA Apr98
        BNE     %FT15                                   ; if intervening window is opening anyway, we can ignore this one

        LDR     R2,[R2,#w_old_parent]

14      ; handle = valid handle from openingwinds
        ; R2     = handle's old parent / old ancestor
;      [ debugopn
;        Push    "R0, R1, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        LDR     R1, [sp, #2*4] ; get handle from stack
;        Debug   opn, "oldsubtract_openingchildren: borderrects, handle, ancestor =", R0, R1, R2
;        Pull    "R0, R1, rectcoords, rectlinks"
;      ]
        CMP     R2,userblk
        BEQ     %FT25

        CMP     R2,#nullptr
        BNE     %BT12

15      LDR     handle,[handle,#w_opening_link + ll_forwards]
        B       %BT10
20
;      [ debugopn
;        Push    "R0, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        Debug   opn, "oldsubtract_openingchildren: opening list scan complete, borderrects =", R0
;        Pull    "R0, rectcoords, rectlinks"
;      ]
        Pull    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk,PC"

; we've found a child window in the opening list that's a descendent of the window in question

25
;      [ debugopn
;        Push    "R0, R1, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        LDR     R1, [sp, #2*4] ; get handle from stack
;        Debug   opn, "oldsubtract_openingchildren: found a descendent, borderrects, handle =", R0, R1
;        Pull    "R0, R1, rectcoords, rectlinks"
;      ]
        Push    "handle"

        ADD     R14,handle,#w_old_x0
        LDMIA   R14,{cx0,cy0,cx1,cy1}                   ; cx0,cy0,cx1,cy1 = outline of child

27      LDR     R14,[handle,#w_old_flags]
        TST     R14,#wf_inborder                        ; if child can live in parent's border,
        LDR     handle,[handle,#w_old_parent]
        ADDNE   R14,handle,#w_old_x0
        ADDEQ   R14,handle,#w_old_wax0
        LDMIA   R14,{x0,y0,x1,y1}                       ; x0,y0,x1,y1 = work area or outline of parent

        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1

        CMP     handle,userblk                          ; keep clipping to intervening windows
        BNE     %BT27

        Pull    "handle"

        Debug   child,"Old Subtracting opening child window rectangle",handle,cx0,cy0,cx1,cy1
;      [ debugopn
;        Push    "R0, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        Debug   opn, "oldsubtract_openingchildren: before subrect, borderrects =", R0
;        Pull    "R0, rectcoords, rectlinks"
;      ]
     [ true                                             ; BJGA bugfix
        CMP     cx0, cx1                                ; optimise out these cases -
        CMPLT   cy0, cy1                                ; they are unnecessary, and can cause intermittent bugs
        BLLT    subrect
     |
        BL      subrect
     ]
;      [ debugopn
;        Push    "R0, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        Debug   opn, "oldsubtract_openingchildren: after subrect,  borderrects =", R0
;        Pull    "R0, rectcoords, rectlinks"
;      ]

        LDR     handle,[handle,#w_opening_link + ll_forwards]
        B       %BT10
      ]

;;--------------------------------------------------------------------------
;; invalidportion - get rectangle(s) within window that need updating
;; assume that any windows above this one have already been processed
;;--------------------------------------------------------------------------

invalidouterportion ROUT
        ADD     R0,handle,#w_x0
        B       invalidportion

invalidinnerportion
        ADD     R0,handle,#w_wax0

invalidportion
        LDMIA   R0,{cx0,cy0,cx1,cy1}
        MOV     R0,#invalidrects
        MOV     R1,#windowrects         ; R0,R1 = source/dest. lists
        B       intrect

;
; markvalid - having processed this window, mark its area as valid
;

markvalid
        ADD     R0,handle,#w_x0
        LDMIA   R0,{cx0,cy0,cx1,cy1}
        MOV     R0,#invalidrects
        MOV     R1,R0
        B       subrect

;
; markinvalid - add window rectangle to the invalid list
;

markinvalid
        ADD     R0,handle,#w_x0
        LDMIA   R0,{cx0,cy0,cx1,cy1}
markinvalid_cx0cy0cx1cy1
        MOV     R0,#invalidrects
        MOV     R1,R0
        B       addrect


;;----------------------------------------------------------------------------
;; markinvalidrects - add 'windowrects' list to the invalid list
;;----------------------------------------------------------------------------

markinvalidrects  ROUT
        EntryS  "R0,R1,userblk,handle"
    [ ChildWindows
        MOV     R0,#invalidrects
      [ false   ; I don't think we actually need this one after all
        B       %FT01

markoldinvalidrects
        ALTENTRY
        MOV     R0,#oldinvalidrects
01
      ]
    ]
        SetRectPtrs

        MOV     R1,#windowrects
        B       endaddrectslp
addrectslp
        Push    R1
        getxy   R1,cx,cy
      [ :LNOT: ChildWindows
        MOV     R0,#invalidrects
      ]
        MOV     R1,R0                           ; dest. = source
        BL      addrect
        Pull    R1
endaddrectslp
        LDR     R1,[rectlinks,R1]               ; get first rectangle
        CMP     R1,#nullptr
        BNE     addrectslp

        EXITS                                   ; must preserve flags

;;------------------------------------------
;; subtract one rectangle list from another
;; Entry :  R0 --> first list
;;          R1 --> second list
;; Exit :   R0 --> (R0)-(R1)
;;------------------------------------------

subrects
        Push    "R0,R1,userblk,handle,LR"
        SetRectPtrs
;
        B       endsubrectslp
subrectslp
        Push    "R0,R1"
        getxy   R1,cx,cy
        MOV     R1,R0                           ; dest. = source
        BL      subrect
        Pull    "R0,R1"
endsubrectslp
        LDR     R1,[rectlinks,R1]               ; get first rectangle
        CMP     R1,#nullptr
        BNE     subrectslp
;
        Pull    "R0,R1,userblk,handle,PC"

;;------------------------------------------
;; intersect one rectangle list with another
;; Entry :  R0 --> first list
;;          R1 --> second list
;; Exit :   R0 --> (R0) int (R1)
;;------------------------------------------

intrects
        Push    "R0,R1,userblk,handle,LR"
        SetRectPtrs
;
        B       endintrectslp
intrectslp
        Push    "R0,R1"
        getxy   R1,cx,cy
        MOV     R1,#torects                     ; add list to 'torects'
        BL      intrect
        Pull    "R0,R1"
endintrectslp
        LDR     R1,[rectlinks,R1]               ; get first rectangle
        CMP     R1,#nullptr
        BNE     intrectslp
;
        BL      assign                          ; move list to right place
;
        Pull    "R0,R1,userblk,handle,PC"

;------------------------------------------------------------------------------
; in    R0 -> source string (null terminated)
;       R1 -> destination buffer
; out   R0,R1 -> after strings
;------------------------------------------------------------------------------

copy0
        Push    "LR"
01
        LDRB    R14,[R0],#1
        STRB    R14,[R1],#1
        CMP     R14,#32
        BHS     %BT01

        SUB     R1,R1,#1
;
        Pull    "PC"

;------------------------------------------------------------------------------
; in    R0 -> string
; out   R0 -> terminator
;       R1 = length of string including terminator
;------------------------------------------------------------------------------

count0
        Push    "LR"
        MOV     R1,R0
01
        LDRB    R14,[R1],#1
        CMP     R14,#32
        BHS     %BT01

        SUB     R1,R1,R0
;
        Pull    "PC"

WimpKillSprite_Code
        Push    "r12,LR"
        LDR     r12,[r12]
        STR     R0,spritename
        MOV     R0,#1
        STR     R0,thisCBptr
        STR     R0,lengthflags
        MOV     R0,#SpriteReason_DeleteSprite
        BL      wimp_SpriteOp

        [ windowsprite
	 [ ThreeDPatch
        MOVVC   R0,#0
	BLVC	reset_all_tiling_sprites
	 |
        MOVVC   R0,#-1
        STRVC   R0,tiling_sprite
         ]
        ]
        BLVC    freelist                ; mark list invalid

        [ false
        BVS     %FT02
        MOV     R14,#ms_data            ; message block size
        STR     R14,[sp,#-ms_data]!
        MOV     R14,#0                  ; your_ref
        STR     R14,[sp,#ms_yourref]
        LDR     R14,=Message_IconsChanged
        STR     R14,[sp,#ms_action]
        MOV     R0,#User_Message
        MOV     R1,sp
        MOV     R2,#0                   ; broadcast message
        BL      int_sendmessage_fromwimp
        ADD     sp,sp,#ms_data
        CLRV                            ; ignore errors
02
        ]
        Pull    "r12,PC"

 [ ThreeDPatch

	ROUT
00
	DCB	"3DWindowBorders=3DWB/S,TexturedMenus=TM/S,UseAlternateMenuBg=UAMB/S,RemoveIconBoxes=RIB/S,"
	DCB	"NoIconBoxesInTransWindows=NIBITW/S,Fully3DIconBar=F3DIB/S,All=A/S,"
	DCB	"WindowBorderFaceColour=WBFC/E,WindowBorderOppColour=WBOC/E,"
	DCB	"MenuBorderFaceColour=MBFC/E,MenuBorderOppColour=MBOC/E,"
	DCB	"NoFontBlending=NFB/S,FontBlending=FB/S,"
	DCB     "WindowOutlineColour=WOC/E,WindowOutlineOver=WOO/S",0
	ALIGN

WimpVisualFlags_Code
	Push	"r12,lr"
	LDR	r12,[r12]

	TEQ	r1,#0
	MOVEQ   r1,# :NOT: ThreeDFlags_All
	STREQ	r1,ThreeDFlags		; if no options are supplied then turn everything off
	MOVEQ   lr,#arrowIconWidth_No3D
	STREQB  lr,arrowIconWidth
	Pull	"r12,pc",EQ

	SUB	sp,sp,#256
	MOV	r1,r0
	ADR	r0,%BT00
	MOV	r2,sp
	MOV	r3,#256
	SWI	XOS_ReadArgs
	ADDVS	sp,sp,#256
	Pull	"r12,pc",VS

	MOV	r2,# :NOT: ThreeDFlags_All
	LDR	r1,[sp,#0]
	TEQ	r1,#0
	ORRNE	r2,r2,#ThreeDFlags_Use3DBorders
	MOVEQ   lr,#arrowIconWidth_No3D
	MOVNE   lr,#arrowIconWidth_3D
	STRB    lr,arrowIconWidth
	LDR	r1,[sp,#4]
	TEQ	r1,#0
	ORRNE	r2,r2,#ThreeDFlags_TexturedMenus
	LDR	r1,[sp,#8]
	TEQ	r1,#0
	ORRNE	r2,r2,#ThreeDFlags_UseAlternateMenuTexture
	LDR	r1,[sp,#12]
	TEQ	r1,#0
	ORRNE	r2,r2,#ThreeDFlags_RemoveIconBackgrounds
	LDR	r1,[sp,#16]
	TEQ	r1,#0
	ORRNE	r2,r2,#ThreeDFlags_NoIconBgInTransWindows
	LDR	r1,[sp,#20]
	TEQ	r1,#0
	ORRNE	r2,r2,#ThreeDFlags_Fully3DIconBar
;	LDR	r1,[sp,#44]
;	TEQ	r1,#0
;	ORRNE	r2,r2,#ThreeDFlags_NoFontBlending ; bit is already set!
	LDR	r1,[sp,#48]
	TEQ	r1,#0
	BICNE	r2,r2,#ThreeDFlags_NoFontBlending

	LDR	r1,[sp,#56]
	TEQ	r1,#0
	ORRNE	r2,r2,#ThreeDFlags_WindowOutlineOver

	LDR	r1,[sp,#28]		; window border face colour
	BL	%FT02
	LDRNE	r0,=rgb_white
	STR	r0,truewindowborderfacecolour

	LDR	r1,[sp,#32]		; window border opposite colour
	BL	%FT02
	LDRNE	r0,=rgb_middarkgrey
	STR	r0,truewindowborderoppcolour

	LDR	r1,[sp,#36]		; menu border face colour
	BL	%FT02
	LDRNE	r0,=rgb_white
	STR	r0,truemenuborderfacecolour

	LDR	r1,[sp,#40]		; menu border opposite colour
	BL	%FT02
	LDRNE	r0,=rgb_midlightgrey
	STR	r0,truemenuborderoppcolour

	LDR	r1,[sp,#52]		; window outline colour
	BL	%FT02
	LDRNE	r0,=rgb_black
	STR	r0,truewindowoutlinecolour

	LDR	r1,[sp,#24]		; all
	TEQ	r1,#0
	MOVNE	r2,#ThreeDFlags_All
	MOVNE   lr,#arrowIconWidth_3D
	STRNEB  lr,arrowIconWidth

01	ADD	sp,sp,#256
	STR	r2,ThreeDFlags

	Pull	"r12,pc"

02	; subroutine
	; r1 = ptr to int returned from OS_ReadArgs
	; returns, r0 = 24 bit RGB value
	; EQ if it is valid
	Push	"lr"
	TEQ	r1,#0
	BNE	%FT03
	TEQ	pc,#0
	Pull	"pc"

03	LDRB	r0,[r1],#1
	TEQ	r0,#0                   ; type = integer
	Pull	"pc",NE

	LDRB	lr,[r1,#2]
	MOV	r0,lr,LSL #8
	LDRB	lr,[r1,#1]
	ORR	r0,r0,lr,LSL #16
	LDRB	lr,[r1,#0]
	ORR	r0,r0,lr,LSL #24

	TEQ	r0,r0
	Pull	"pc"
 ]

        END
@


4.78
log
@Gate the recache of currentmode
The operations at module init and at Service_PreReset are both implicitly pre desktop, however it is valid to have Service_ModeFileChanged while in the desktop (for example, if selecting a different MDF from !ScrnSetup).
Gate the one hanging off Service_ModeFileChanged to only act when there are no tasks active (ie. outside the Wimp).
Fixes problem reported https://www.riscosopen.org/forum/forums/4/topics/9206 with NetSurf redraw.

Version 5.58. Tagged as 'Wimp-5_58'
@
text
@a1271 1
MaxIdleEvents   #       4               ; maximum number of idle events received
@


4.77
log
@Recache currentmode at the right time
Detail:
  Modification to make the Wimp reread 'currentmode' by calling OS_ReadSysInfo 1 in the following circumstances
  1. On module init (accounts for being softloaded off disc)
  2. At Service_Reset (accounts for any graphics driver starting after it in ROM module order)
  3. When Service_ModeFileChange (new, this catches the new mode selected by an MDF or EDID during !Boot)
  Commoned up these 3 cases into 1 function.
  This restores the design intent that to get the monitor's native resolution it is *not* required to configure the MonitorType=EDID, indeed doing so wouldn't have helped loading EDID off disc if the monitor's data is found to be incorrect and needing overriding.
Admin:
  Tested on a Pandaboard with MonitorType=Auto and resolution chosen as "Native", resulting in a desktop at the panel resolution.

Version 5.57. Tagged as 'Wimp-5_57'
@
text
@d4149 1
a4149 1
        BEQ     read_current_configd_mode
d4196 9
@


4.76
log
@Fix use of uninitialised pointer
Detail:
  s/Wimp01 - initwcfda tries to look up the dynamic area name using MsgTrans, so make sure the 'messages' pointer is initialised before we call it
Admin:
  Tested on iMx6


Version 5.56. Tagged as 'Wimp-5_56'
@
text
@d3433 1
a3433 11
        MOV     R0,#1                   ; Read configured mode
        SWI     XOS_ReadSysInfo
        Debug   mode,"gotwork trying mode",R0
        BLVC    validatemode            ; error if non-graphics mode
        MOVVS   R0,#27
        [ Medusa
        BL      copy_mode_specifier     ; just in case configured mode
                                        ; is new style.
        ]
        Debug   mode,"setting currentmode",R0
        STR     R0,currentmode          ; altered by Wimp_SetMode
d4046 1
d4077 1
d4148 2
d4153 1
d4159 1
a4159 14
        Push    "R0-R2,LR"
        MOV     R0,#1                   ; Read configured mode
        SWI     XOS_ReadSysInfo
        Debug   mode,"Service_Reset trying mode",R0
        BLVC    validatemode            ; error if non-graphics mode
        MOVVS   R0,#27
        [ Medusa
        BL      copy_mode_specifier     ; just in case configured mode
                                        ; is new style.
        ]
        Debug   mode,"setting currentmode",R0
        STR     R0,currentmode          ; altered by Wimp_SetMode
        Pull    "R0-R2,LR"
        ; Fall through...
a4160 3

initptrs_deallocating                   ; called on Service_Reset
        Push    "LR"
@


4.75
log
@Fix for crashes loading sprites on RISC OS 3.10
A register fumble (revision 4.43 of this file) meant the pointer to the error block from OS_ReadSysInfo not existing was being cached as IRQsema, so later any attempts to resize the RMA would be skipped believing it to be unsafe (because the error pointer would point to an error block whose first word is mostly non zero).
Tested on a real A5000 and emulated via ArcEm.
@
text
@d3416 2
a3420 2
        MOV     R1, #0
        STR     R1, messages            ; no messsages open, in case of error lookups
@


4.74
log
@Avoid unnecessary remainder calculations
Detail:
  s/Wimp01, s/Wimp02, s/Wimp05, s/Wimp08s, s/Wimp10 - Avoid unnecessary remainder calculations in DivRem macro. Also make more use of DivRem's ability to accept a constant (not a register) as the divisor.
Admin:
  Tested on Cortex-A15


Version 5.52. Tagged as 'Wimp-5_52'
@
text
@d3407 1
a3407 1
        STR     R0,ptr_IRQsema
@


4.73
log
@Make use of power saving features when sat waiting for user input
Detail:
  s/Wimp03 - Move two key bits of power-saving logic out of repollwimp and into a new subroutine (powersave_tick)
  s/Wimp01, s/Wimp07 - Call powersave_tick when displaying an error box or "Press SPACE or click mouse to continue", so that CPU will drop speed and enter WFI state instead of running at full tilt.
Admin:
  Tested on Pandaboard
  Fixes issue reported on forums with CPUs getting hot for no good reason:
  https://www.riscosopen.org/forum/forums/4/topics/3749


Version 5.51. Tagged as 'Wimp-5_51'
@
text
@d3426 1
a3426 1
        DivRem  R2,R1,R0,R14            ; R2 = number of pages for 640k (or whatever)
d5903 1
a5903 1
        DivRem  cy0,R1,R0,R14
d5913 1
a5913 1
        DivRem  cx0,R1,R0,R14
d5961 1
a5961 1
        DivRem  R0,x0,cx0, R14
@


4.72
log
@Reinstate Wimp_ClaimFreeMemory
Detail:
  This restores support for Wimp_ClaimFreeMemory, via having the Wimp manage a small-ish (4MB) DA that is used to satisfy Wimp_ClaimFreeMemory requests. The Wimp will only ever grow the DA, but the DA is shrinkable, so the system should shrink it as necessary should the free pool run too low.
  Options/s/!Default, Options/s/32, Options/s/Ursula - Add DynamicAreaWCF option to control support for the Wimp_ClaimFreeMemory DA. Enable the option for any builds of the module destined for RISC OS 5.
  Options/s/!Debug - New debug option for Wimp_ClaimFreeMemory debugging (mainly DynamicAreaWCF code path)
  Wimp/s/Wimp01 - Add calls to create/destroy DA on startup/shutdown
  Wimp/s/Wimp08s - DA create/destroy implementation. DA is only used if the free pool is a PMP or the Wimp expects kernel free pool locking but the kernel doesn't support it. Modify Wimp_ClaimFreeMemory to use the DA if it's present.
Admin:
  Tested on Raspberry Pi
  Restores compatibility with software which relies on Wimp_ClaimFreeMemory, e.g. GDraw module (cause of "No free memory" errors reported by many)
  Note that Wimp_ClaimFreeMemory is still considered deprecated and support may be removed in future OS versions.


Version 5.50. Tagged as 'Wimp-5_50'
@
text
@d5762 1
@


4.71
log
@Add definitions of button types 11/14/15
Button type 11 was added in 1988 so is about time it had a symbol to refer to it in the sources. Added & used said symbols.
Removed 'DoubleIcon' switch, prototype button type 12.
Built binary identical module, not tested.

Version 5.43. Not tagged
@
text
@d1508 3
d3416 3
d3949 3
@


4.70
log
@Fix *WimpMode/Wimp_SetMode to return an error when given a bad mode selector block. Re-read configured mode on Sevice_Reset.
Detail:
  s/Wimp01 - Reinitialise currentmode on Service_Reset in order to get the correct mode in the case of a GraphicsV driver overriding it (driver may not have been initialised at the time of the first call in module init). Add a bit more mode debugging and ensure ValidateAddress code completely removed under Medusa.
  s/Wimp02 - Issue OS_CheckModeValid in validatemode so we can detect cases where a valid looking mode selector block doesn't actually map to a mode definition. Add more mode debugging code.
Admin:
  Tested on Raspberry Pi
  Fixes issue where "F12 -> *BASIC -> MODE 0 -> QUIT -> return" wouldn't restore screen mode correctly if currentmode had been set to a bad mode selector (e.g. after a CMOS reset nukes the LoadModeFile command), due to WimpMode's lack of error checking
  Note that this merely prevents currentmode being set to a bad mode at the time of *WimpMode/Wimp_SetMode - if a mode which is valid suddenly becomes invalid (e.g. due to loading a new MDF but not reselecting a valid wimp mode) then the Wimp will still fail to set a sensible mode on return to the desktop.


Version 5.40. Tagged as 'Wimp-5_40'
@
text
@d1979 5
a1983 2
ibt_menuicon        *   9               ; select when over, report on click
ibt_rdclick2        *   10              ; as for (8), but reports for 1 click
@


4.69
log
@Disallow Wimp_SpriteOp 38 (create/remove alpha)
Detail:
  - s/Wimp01 - Add OS_SpriteOp 38 (create/remove alpha) to the list of banned SpriteOp's for Wimp_SpriteOp. OS_SpriteOp 38 is almost always guaranteed to modify the target sprite, and so in keeping with other sprite modification ops it shouldn't be allowed via Wimp_SpriteOp.
Admin:
  Tested on BB-xM


Version 5.38. Tagged as 'Wimp-5_38'
@
text
@d3426 1
d3433 1
d4147 20
a4166 1

d4175 1
a4176 12
        [ Medusa
;         [ true
;        Push    "R0-R2,lr"
;        MOV     R0,#6
;        SWI     XOS_ReadDynamicArea             ; is there a kernel free pool
;        Pull    "R0-R2,lr"
;        MOVVC   PC,lr
;        CLRV
;        |
;        MOV     PC,lr
;         ]
        |
@


4.68
log
@Fix to build with HdrSrc-2_42. Use OS_SpriteOp 65 where possible.
Detail:
  s/Wimp01 - Update Wimp_SpriteOp handler to cope with the new SpriteReason_BadReasonCode value. Initialise unused bits of spritebits to 1 so that it acts as a whitelist, only allowing through operations that we know are safe.
  s/Tiling3D - Use OS_SpriteOp 65 for drawing tiled window backgrounds. Softload versions will fall back to using the old manual tiling code if OS_SpriteOp 65 is unavailable.
  s/Wimp10 - Use OS_SpriteOp 65 for drawing the tiled sprites that make up scrollbar wells and bars. Falls back to manual tiling in softload versions.
Admin:
  Tested on Iyonix, BB-xM
  Requires HdrSrc-2_42


Version 5.37. Tagged as 'Wimp-5_37'
@
text
@d3147 1
a3147 1
        DCD     2_11010000001011110000001001101101
@


4.67
log
@Implement sprite translation table caching
Detail:
  This set of changes allows the Wimp to cache the last-used translation table, and cleans up some instances where translation tables were being generated and then not used
  s/Wimp01 - Expand selecttable_args to store all 8 registers needed by ColourTrans_GenerateTable. Add 1K of space for caching the palette that the cached translation table was generated from. Remove unused spriteX, spriteY variables.
  s/Wimp04 - Split cachespritedata in two. cachespritedata now only caches the basic information, while the new cachespritepixtable rotuine will generate a translation table (shaded/inverted if required). This allows table generation to be deferred until we're just about to render the sprite, ensuring that the table isn't generated only to not be used. Also updated icon sprite rendering to check the sprite is within the graphics window before attempting to render it, allowing removal of one more case where tables can be needlessly generated.
  s/NewSWIs, s/Wimp09 - Change ADR to ADRL
  s/Tiling, s/Tiling3D - Use cachespritepixtable when needed
Admin:
  Tested on Iyonix, BB-xM, StrongARM RiscPC


Version 5.36. Tagged as 'Wimp-5_36'
@
text
@d3147 3
a3149 2
        DCD     2_11010000001011110000001001101100
        ASSERT  SpriteReason_BadReasonCode < 64
@


4.66
log
@Change Wimp_ReadSysInfo 2 to not return alpha sprite names. Add Wimp_ReadSysInfo 29 and Wimp_Extend 257.
Detail:
  s/Wimp01 - Change romspr_suffix initialisation so that it won't store alpha sprite suffixes. This has the knock-on effect of making Wimp_ReadSysInfo 2 no longer return alpha sprite suffixes, without affecting any of the sprite search code
  hdr/Wimp, s/Wimp01 - Add Wimp_ReadSysInfo 29 to read the alphaspriteflag value - i.e. whether alpha sprites are supported by the OS/Wimp and *IconSprites, Wimp_Extend 13, etc. will look for them
  hdr/Wimp - Document the private Wimp_Extend reason codes and add a couple of ROL's reason codes
  s/NewSWIs - Tidy up Wimp_Extend implementation to use a jump table instead of a load of tests and branches. Add an implementation of ROL's Wimp_Extend 257, which just acts as a wrapper around Wimp_Extend 13
Admin:
  Tested on Raspberry Pi
  Wimp_ReadSysInfo 2 change should fix issue reported on forums with software unexpectedly using low-res sprites or failing altogether:
  http://www.riscosopen.org/forum/forums/4/topics/2274


Version 5.35. Tagged as 'Wimp-5_35'
@
text
@a834 2
spriteX         #       4               ; for sprite plotting in icons
spriteY         #       4
d923 1
d1243 3
a1245 1
selecttable_args #      4*6             ; parameters used for the last sprite select table call
d1596 2
@


4.65
log
@Fix alpha sprite support
Detail:
  s/Wimp01 - An ill-advised last minute edit would leave the Wimp in an infinite loop looking for ROM sprites if it tried to enable alpha sprite support
Admin:
  Tested on BB-xM


Version 5.34. Retagged as 'Wimp-5_34'
@
text
@a4235 4
        LDRNEB  R0,alphaspriteflag
        CMP     R0,#255                         ; If alpha sprites supported
        CMPEQ   R5,R6                           ; And square pixel mode
        MOVEQ   R5,#'A'-'0'                     ; Look for alpha version
d5387 1
d5544 13
@


4.64
log
@Add support for *iconspriting of alpha-masked sprites. Fix icon shading/inverting to work with true colour sprites.
Detail:
  Options/s/!Default, s/NewSWIs, s/Wimp01:

  Updated ROM sprite find code, *IconSprites and Wimp_Extend 13 to understand a new spritefile suffix.
  If the Wimp detects that RISC OS Select style alpha masked sprites are supported, and we're not using the mode 23 sprites, then the code will enable support for alpha masked sprites of the form !SpritesA1, !SpritesA2, !SpritesA, etc. Alpha-masked sprites are only looked for when looking for square pixel sprites or just before looking for the default sprites. This means the full search pattern for (e.g.) a !Sprites21 mode would be as follows:

  !Sprites21  (original mode)
  !SpritesA2  (next squarer mode, alpha sprites)
  !Sprites22  (next squarer mode)
  !SpritesA   (default alpha sprites)
  !Sprites    (default sprites)

  Like with !Sprites11 support, this feature can be toggled off via the SpritesA option if necessary.

  s/Wimp01, s/Wimp04:

  Updated icon plotting code (wimp_SpriteOp_putsprite and calculateinverse) to allow true colour sprites/icons to be rendered shaded/inverted.
  For this to work the Wimp needs a version of SpriteExtend which supports colour mapping (specifically it checks for the relevant ROOL version number).
  The colour mapping function which is used to build the translation tables used for shading/inverting palettised sprites is too slow to be sensibly used on a per-pixel basis, so the first time a shaded/inverted true colour sprite is requested the Wimp will generate a set of lookup tables which can be used by a much simpler colour mapping routine.
  To keep memory usage down these lookup tables only use 4K colours each; however the quality isn't always that great and so this may need revising in future.

Admin:
  Tested on BB-xM


Version 5.34. Tagged as 'Wimp-5_34'
@
text
@d4239 1
a4239 1
        MOVEQ   R5,#'A'                         ; Look for alpha version
@


4.63
log
@Fix logic which decides whether to plot sprites using the Kernel or SpriteExtend to take into account the new sprite modes
Detail:
  s/Wimp01 - Add NColour mode variable to the list of variables cached for the current screen mode. Add modeflags & ncolour to the sprite & tool sprite variables.
  s/Wimp04, s/Wimp10 - Update cachespritedata and cachetoolspritedata to look at the modeflags, ncolour and alpha mask flag when deciding if sprite_needsfactors should be set or not (i.e. whether the code ultimately uses OS_SpriteOp 52 or 34). This should allow the Wimp to correctly detect if a sprite can safely be rendered by the Kernel or not (except for double pixel vs. non-double pixel - but presumably nobody's using double pixel mode sprites for icons/tool sprites, otherwise it would be fixed by now?)
  s/Wimp04 - Add an extra safety check to icon text rendering after a crash was seen when calling Wimp_PlotIcon outside of a redraw loop
Admin:
  Tested on BB-xM
  Fixes problem reported on forums with 32bpp, alpha-masked sm!Netsurf icon vanishing from filer when viewed in 32bpp modes
  https://www.riscosopen.org/forum/forums/3/topics/309?page=4#posts-25995


Version 5.33. Tagged as 'Wimp-5_33'
@
text
@d1138 5
d1151 2
d2950 9
a2958 1
02      ADD     R14,R5,R6,LSL #8
d2971 6
d2992 17
d3787 2
d3810 42
d4229 13
d4250 8
a4257 1
01      ADD     R14,R5,R6,LSL #8
d4271 6
d4292 16
d4724 4
d4732 2
@


4.62
log
@3 minor fixes, 2 minor enhancements
Makefile:
* Conditionally copy the disc resources, saving a little build time.
Wimp10.s; hdr/Wimp:
* Issue Service_WimpToolSpritesChanged when the tool sprite area is changed.
Wimp05:
* Fix bug in softloaded versions of the Wimp where menus would randomly lose the keyboard shortcut text. This was caused by use of an LDR to retrieve a byte wide variable. This specifically affected some softloads because the Wimp gets squeezed, and during unsqueezing the Wimp's workspace ends up being allocated from the same bit of RMA that used to contain the squeezed copy of the module (=lots of random numbers).
Wimp09:
* Fix bug where configuring WimpSpritePrecedence to ROM when a theme is loaded would cause redrawing of window textures to fail. This is because the Wimp intersects the ROM and RAM sprite areas and deletes any duplicates from the RAM area when remaking the fast lookup sprite list. So if the RAM sprites include the "tile_1" (etc) sprite on redrawing the desktop the Wimp points to this, then intersects the lists and deletes the sprite, leaving the pointers pointing at junk. Now, on deleting something, the window tile pointers are invalidated. Fixes ticket #346.
Wimp02:
* Fix bug where the title bar text, when the desktop font is the system font, is incorrectly rendered in the colour selected by WimpVisualFlag -WindowOutlineColour. The Wimp now restores the text colour if -WOC has set the graphics colour to something other than black.

Administrative -
In Wimp01, swap a couple of SpriteReasons from magic numbers. In the init of variables use the common reset_all_tiling_sprite function.
In Tiling3D, more SpriteReasons, and rationalise the registers used in reset_all_tiling_sprites.

Version 5.32. Tagged as 'Wimp-5_32'
@
text
@d734 1
d1216 2
d1222 2
d4804 1
@


4.61
log
@Replace OS_SpriteOp reason code magic numbers with definitions. Add support for new screen modes.
Detail:
  s/Tiling, s/Tiling3D, s/Watchdog, s/Wimp05, s/Wimp07, s/Wimp09 - Replaced OS_SpriteOp reason code magic numbers with symbolic definitions.
  s/Wimp01 - Update *WimpMode / Wimp_SetMode to use OS_ScreenMode 13 (mode string to specifer) in place of its own code if a mode specifier string has been given. Note - mode number handling is unchanged, so a mode specifier string which begins with a mode number will currently have the specifier part ignored.
  s/Wimp01, s/Wimp02 - Flag_* -> ModeFlag_* renaming
  s/Wimp02 - Fix mode specifier copying to only stop copying when we hit a mode variable of -1. Previous code would also stop if the variable value was -1. Update mode set code to apply the Wimp's special greyscale palettes if the greyscale mode flag is set (i.e. greyscale mode was set via specifier generated by OS_ScreenMode 13)
Admin:
  Tested on BB-xM


Version 5.31. Tagged as 'Wimp-5_31'
@
text
@d3083 1
a3083 1
        MOVEQ   R0,#40                  ; read info
d3734 3
a3736 11
	 [ ThreeDPatch						; initialise all the tile sprite info blocks
	MOV	R0,#0
	ADRL	R2,tile_sprites
	ADD	R3,R2,#TileInfo * 18

00	STR	R0,[R2,#TileInfo_SpritePtr]			; set all sprite pointer to -1
	STR	R0,[R2,#TileInfo_TranslationTablePtr]		; and all translation table pointers to 0
	ADD	R2,R2,#TileInfo
	CMP	R2,R3
	BLT	%BT00

d7198 1
a7198 1
        MOV     R0,#25               ; delete sprite
@


4.60
log
@Add flexible scheme to allow non-grey/opaque toolsprites
The Wimp can now accept toolsprite sets which have precalculated (non default) colour translation tables supplied by the designer.
This allows the link between window template colour and displayed tool colour to be reestablished when the tools aren't grey (previously, the Ursula Wimp would only tint greys).
For full design details see Doc/ToolTables.
An example test set, TestO/TTTTest is provided. This is the 'Newlook' set but with a splotch in the corner of each sprite which is then replaced by the hex of the Wimp colour being requested.
Detail:
 Wimp01.s: New workspace requirements
 Wimp04.s: Pull out the RGB to greyscale function so it can be used elsewhere
 Wimp10.s: New tool table support code

Fixes ticket #323.
Also introduces a disc variant (with the extra EX0 EY0 resolution) of the 'Steel' theme, thus making it generally available.

Version 5.30. Tagged as 'Wimp-5_30'
@
text
@d2516 16
d2721 1
a2721 1
	MOVLS	R0,#Flag_DoubleVertical
d3332 1
a3332 1
        MOV     R0,#62
@


4.59
log
@Change to method of window highlighting
The change made in Wimp-5_02 to Wimp-5_03 (to permit 'f' prefixed toolsprites) introduced a set of interesting boundary cases not covered by that scheme.
This commit restores the former behaviour, while retaining its simplification of H/V scrollbar plotting (beefed up with a few ASSERTs).
Part of fix for ticket #323.

Tagged as Wimp-5_30-pre4.
@
text
@d1308 8
d3677 4
a3680 1

@


4.58
log
@Don't try freeing the tool pixel trans table twice
In deallocptrs a call to freetoolarea is made, then much the same code repeated inline.
Excess code deleted.

Tagged as Wimp-5_30-pre2
@
text
@d81 5
a85 9
$lab    AddIcon $index,$name,$pressable,$sprite,$width,$height

        LCLS focus
        LCLS pushed
        LCLS iname
        LCLS isprite

        [ ($index :AND: 2_01) > 0
pushed  SETS "p"
d87 1
a87 1
pushed  SETS ""
d89 1
a89 25

        [ ($index :AND: 2_10) > 0
focus   SETS "f"
        |
focus   SETS ""
        ]

iname   SETS "$pushed" :CC: "$focus" :CC: "$name"

        [ "$sprite" = ""
          [ "$pressable" = ""
isprite SETS "$sprite"
          |
isprite SETS "$focus" :CC: "$name"
          ]
        |
          [ "$pressable" = ""
isprite SETS "$pushed" :CC: "$focus" :CC: "$sprite"
          |
isprite SETS "$focus" :CC: "$sprite"
          ]
        ]

        int_AddIcon "$iname", "$isprite", $width, $height

@


4.57
log
@Change titlecolour variable to truetitlecolour
The word wide variable actually contains the RGB value, rename this to be distinct from the 4 bit Wimp colour, to make searching easier.
No change to binary, not tagged.
@
text
@a4599 4
        LDR     R2,tpixtable_at
        CMP     R2,#0
        BLNE    XROS_Module              ; release the tools pixtrans table (ignore errors)
;
a4605 2
        STR     R1,tpixtable_at
        STR     R1,tpixtable_size
@


4.56
log
@Stranded comment reunited with its owner
@
text
@d1185 1
a1185 1
titlecolour     #       4               ; independent of input focus status
@


4.55
log
@Introduce definitions of the 16 standard Wimp colours
Substitute magic numbers through the code.
Squash some UAL warnings from missing #'s in Wimp10.s

Version 5.27. Tagged as 'Wimp-5_27'
@
text
@a4788 10
;;-----------------------------------------------------------------------------
;; The Wimp SWI - all calls to the Wimp come through here
;;
;; Entry:  R11 = SWI number within chunk
;;         R12 --> private word
;;         R1 --> user buffer (parameter block)
;; Exit :  R0 = reason code
;;         R1 --> parameter block (modified)
;;-----------------------------------------------------------------------------

d4912 9
@


4.54
log
@Change to RMA shrinkage in *ICONSPRITES pre Medusa
On completing the sprite area merge the Wimp would try to minimise the RMA by -256MB (to account for the fact that during the merge the RMA is enlarged to hold both the existing sprites and the new ones to be merged, in the case of duplicates).
However, this meant that the common construct

  IconSprites MySprites
  Run MyApp

where MyApp wanted to use more than a teaspoon of RMA would fail due to the lack of free pool and that the RMA can't be resized when an application is running as a result.

Now, the Wimp notes the free space in the RMA, does the -256MB shrink, then ensures there's still the same free space after the event (ie. overall it may have grown by the size of any extra sprites added during the command).
Tested on RISC OS 3.10.

Version 5.26. Tagged as 'Wimp-5_26'
@
text
@d1016 1
a1226 2
baseofromsprites  #     4               ; base of ROM sprite pool (in Resources:)

d1327 1
a1538 1
tool_list_backup #      4               ; backup copy of tool_list
d1781 36
d3634 1
a3634 1
	LDR	R0,=&FFFFFF00
d3637 1
a3637 1
	LDR	R0,=&99999900
d3639 1
a3639 1
	LDR	R0,=&77777700
d3641 1
a3641 1
	MOV	R0,#&00000000
d7313 1
a7313 1
	LDRNE	r0,=&FFFFFF00
d7318 1
a7318 1
	LDRNE	r0,=&77777700
d7323 1
a7323 1
	LDRNE	r0,=&FFFFFF00
d7328 1
a7328 1
	LDRNE	r0,=&99999900
d7333 1
a7333 1
	LDRNE	r0,=&00000000
d7358 1
a7358 1
	TEQ	r0,#0
@


4.53
log
@Refinements to disc based targets especially
Previous attempt to disable Sprites11 support for 3.10 and 3.50 hadn't spotted it was reenabled in the common options, also the Sprites11 switch was also tied up in Wimp$IconTheme support.
Title bars would flicker when picked up when using a tool sprite set with no 'p' pushed equivalents on RISC OS 4.0x due to screen cache.
Makefile now installs a default set of tools & sprites when target is ThemeDefs.
CLI limit reduced to 256 pre Ursula to save RAM.

Options/!Common:
  Promote Sprites11 switch into !Default
  Remove fixrmatools
Options/!Default:
  Sprites11 true by default
  LongCommandLines true by default, false on targets pre Ursula
  Remove ServiceCallTable (harmless to have it in all cases)
NewSWIs.s:
  Enable Wimp_Extend 13 all the time
Wimp01.s:
  Reduce RMA use by vital 1.5k for non long command line case
  Change sense of Sprites11 switch to adopt all its previous functionality, but not look for '11' suffix when the switch is false
  Adopt ServiceCallTable switch permanently
Wimp02.s:
  Comments ammended
Wimp07.s:
  Range of ADR
Wimp10.s:
  Change sense of Sprites11 switch to adopt all its previous functionality, but not look for '11' suffix when the switch is false
  Adopt :LNOT: fixrmatools switch permanently
  Supress title bar sprite plotting when none of the sprites exist

Version 5.25. Tagged as 'Wimp-5_25'
@
text
@d2856 1
a2856 1
        Push    "R7-R8,LR"
d2859 7
d2943 1
a2943 1
        BEQ     %FT05                   ; no, and an error, so give up
d2959 3
a2961 1
; this merge bumps the RMA up, compress it again just in case.
d2963 3
a2965 3
        MOV     R1,#-&10000000           ; try and shrink RMA
        SWI     XOS_ChangeDynamicArea
        CLRV                            ; may cause an error, but ok.
d2967 2
a2968 2
05
        Pull    "R7-R8,PC"
@


4.52
log
@Slacken pointer checks
The pointer comparison checking required when running in a system with > 64M memory was tightened up from Wimp-4_75 to Wimp-4_76, but to allow the module to target pre RISC OS 5 systems an option to relax those checks is required.
Each check has been revisited and where appropriate demarked with a "AcceptLoosePointer" macro, which just remaps the pointer into the stricter form and carries on. In the strict checking case, the macro reduces to nothing.

Detail:
Add AcceptLoosePointers switch.
Retire singular use of StrongARM switch (calling XOS_SynchroniseCodeAreas is harmless pre StrongARM anyway).
Rename Ursula_RPC options to RO400.
Put duplicate documentation in the attic.
Allow -2 or -1 as the iconbar handle in Wimp_ResizeIcon (ticket #203).
Tighten up the list terminator check in the DebugMemory switch of Memory.s

Tested on RISC OS 3.10 (emulated), 3.50, 3.60, 3.70, 4.02.

Version 5.24. Tagged as 'Wimp-5_24'
@
text
@a873 1
        [ :LNOT: fixrmatools
a874 1
        ]
a1533 1
taskbuffer      #       1024            ; command which starts a task
d1560 1
d1562 5
a2855 1
      [ Sprites11
a2905 7
      |
        Push    "LR"
        LDR     wsptr,[R12]
;
        MOV     R1,R0
        MOV     R3,R0                   ; R3 -> original filename
      ]
a2910 1
      [ Sprites11
d2922 1
d2927 1
a2927 1

a2939 6
      |
        MOVVS   R2,R3                   ; R2 -> original filename
        MOVVS   R0,#SpriteReason_MergeSpriteFile
        SWIVS   XWimp_SpriteOp
        BVS     %FT05
      ]
a2958 1
      [ Sprites11
a2959 3
      |
        Pull    "PC"
      ]
a2960 1
 [ Sprites11
a2963 1
 ]
d2967 1
a2967 5
; In  [ Sprites11
;       R0 -> suffix to add to filename
;     |
;       [romspr_suffix..] = suffix to add to filename
;     ]
a2985 3
      [ :LNOT: Sprites11
        ADR     R0,romspr_suffix
      ]
a3217 1
      [ Sprites11
a3220 1
      ]
a3248 1
      [ Sprites11
a3263 1
      ]
d3891 1
a3891 1
      [ ServiceCallTable
d3921 1
a3921 3
      |
Service
      ]
a4082 3
      [ :LNOT: Sprites11
        MOV     R3,#"0"
      ]
a4086 1
      [ Sprites11
a4087 3
      |
        ADD     R5,R3,R4,LSL R2                 ; R5 = char 0
      ]
a4090 1
      [ Sprites11
a4091 3
      |
        ADD     R6,R3,R4,LSL R2                 ; R6 = char 1
      ]
a4095 1
      [ Sprites11
d4101 6
a4109 10
      |
        TEQ     R5,R6
        TEQEQ   R5,#"1"                         ; 1 os unit to a pixel mode
        MOVEQ   R5,#"2"
        MOVEQ   R6,#"2"

	TEQ	R5,#"2"				; 2x2 OS unit, 1bpp
	TEQEQ	R6,#"2"
	TEQEQ	R2,#0
	MOVEQ	R6,#"3"
a4110 2
        ADD     R14,R5,R6,LSL #8
      ]
a4113 1
      [ Sprites11
d4120 1
a4120 1
      ]
a4126 1
      [ Sprites11
d4138 1
d4143 1
a4143 1

a4147 5
      |
        ADRVS   R1,spritesfname         ; R1 -> original filename
        MOVVS   R0,#OSFind_ReadFile     ; try again!
        SWIVS   XOS_Find
      ]
d7305 1
a7305 1
	; returns, r0 = the
@


4.51
log
@Reverse sense of international help switch
In Wimp-5_22 change (to not use the bitfield definition as a build switch) the sense got inverted, so would have hardwired text for international versions.

Version 5.23. Not tagged
@
text
@d5470 1
d5956 1
@


4.50
log
@Build fixes for variants pre RISC OS 5
Minor fixups as part of univeral !Boot work.
Options no longer ASSERT on International_Help (which is a definition exported by the kernel, rather than a build switch), and instead define a switch which is true for > 3.50.
Non UTF8 supporting case has simple substitutes for Wimp_TextOp.
Legacy_DomainId and LegacyIRQsema no longer cause NULL pointer dereference.
MOVeQ => MOVEQ to placate ObjAsm.

Ursula_RPC version built and used briefly on RISC OS 4.02 host. No other run time testing.

Version 5.22. Tagged as 'Wimp-5_22'
@
text
@d2024 1
a2024 1
 [ international_help
d2337 6
a2342 1

d2344 3
a2346 4
        Command IconSprites,1,1,International_Help                 ; max/min pars (!)
        Command Pointer,1,0,International_Help
        Command ToolSprites,1,0,International_Help
        Command WimpFlags,1,1,Status_Keyword_Flag:OR:International_Help,WimpFlagsC
d2348 1
a2348 1
        Command WimpMode,255,1,International_Help,Wimp_SetMode      ; change name to "*WimpMode"
d2350 1
a2350 1
        Command WimpMode,1,1,International_Help,Wimp_SetMode
d2352 15
a2366 14
        Command WimpPalette,1,1,International_Help
        Command WimpSlot,6,1,International_Help
        Command WimpTask,255,1,International_Help
        Command WimpWriteDir,1,1 ,International_Help
        Command WimpFont,1,1,Status_Keyword_Flag:OR:International_Help,WimpFontC
        Command WimpDragDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpDragDelayC
        Command WimpDragMove,1,1,Status_Keyword_Flag:OR:International_Help,WimpDragMoveC
        Command WimpDoubleClickDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpDoubleClickDelayC
        Command WimpDoubleClickMove,1,1,Status_Keyword_Flag:OR:International_Help,WimpDoubleClickMoveC
        Command WimpAutoMenuDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoMenuDelayC
        Command WimpMenuDragDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpMenuDragDelayC
        Command WimpKillSprite,1,1,International_Help
        Command WimpIconBarSpeed,1,1,Status_Keyword_Flag:OR:International_Help,WimpIconBarSpeedC
        Command WimpIconBarAcceleration,1,1,Status_Keyword_Flag:OR:International_Help,WimpIconBarAccelerationC
d2368 1
a2368 1
        Command WimpSpritePrecedence,1,1,Status_Keyword_Flag:OR:International_Help,WimpSpritePrecedenceC
d2371 1
a2371 1
        Command WimpButtonType,1,1,Status_Keyword_Flag:OR:International_Help,WimpButtonTypeC
d2374 1
a2374 1
        Command WimpIconiseButton,1,1,Status_Keyword_Flag:OR:International_Help,WimpIconiseButtonC
d2377 1
a2377 1
        Command WimpStickyEdges,1,1,Status_Keyword_Flag:OR:International_Help,WimpStickyEdgesC
d2380 2
a2381 2
        Command WimpAutoFrontIconBar,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoFrontIconBarC
        Command WimpAutoFrontDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoFrontDelayC
d2384 1
a2384 1
        Command WimpAutoScrollDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoScrollDelayC
d2387 1
a2387 1
        Command WimpClickSubmenu,1,1,Status_Keyword_Flag:OR:International_Help,WimpClickSubmenuC
d2390 1
a2390 1
        Command WimpVisualFlags,255,0,International_Help
@


4.49
log
@Add support for wide translation tables for window tool furniture
With the introduction of 16bpp/32bpp modes it became possible to request tables from ColourTrans which used > 1 byte per colour, but the Wimp wasn't using this extension. Therefore tool sprites designed in 8bpp or less would be quantised horribly when plotted in a 16bpp or 32bpp mode.
The Wimp now requests and plots with a wide table, and to avoid thrashing ColourTrans so much with the prevalence of individually paletted icon sprites, keeps the table seperately to the icon sprites ones. At worst (in 32bpp) this uses an extra 256x4 bytes of RAM.
Trace.s: Split out the tracing routines from Wimp10 as it was getting a bit big.
Tiling.s: Namespace change for the icons versus tools distinction. Removed some unnecessary PC+8/PC+12 confused NOPs.
Tiling3D.s: Namespace change for the icons versus tools distinction.
Wimp01.s: New set of variables to track the tool translation tables separately. Various jiggling to keep ADRs in range.
Wimp02.s: Namespace change. Remove some double handling in Wimp_SetColourMapping.
Wimp04.s: Namespace change. Made factor rationalisation common to both the icon and tool grinding code. Removed dual use of cachespritedata for both icons and tools. The tintfunc moves to Wimp10. Service_InvalidateCache confusion resolved by adding a new flag to remember that the tools need regenerating rather than just marking the tool list as missing (which subsequently got restored in Tool_SpriteOp without actually doing any palette work.
Wimp10.s: Label tools_area renamed as it was immensely confusing to have that (which was actually holding the RMA allocation of the tool_list) and tool_area (which contains the sprite area) hanging around. Changed references to use tools-only cachetolspritedata routine. Added 'wide' flags to sprite op and colour trans calls. Tool_SpriteOp changed to actually regenerate the colour tables when they're known invalid (previously the tools list pointer was merely restored and no colour tables used). Trace functions extracted. Resolved confusion as to what recache_tools_trans and recache_tools_trans2 should be doing.

Tested with 4bpp "NewLook" sprites in 4bpp/8bpp/16bpp/32bpp and 8bpp smooth greyscaled "Steel" tool sprites in same modes.
Also ran a task window doing repeated Service_InvalidateCache calls while monitoring the RMA for leaks.
Generally navigated around some directories to ensure that inverse icons (during double click) and filer windows (with individually paletted sprites) were being rendered.

Version 5.20. Tagged as 'Wimp-5_20'
@
text
@d2003 1
a2003 1
 [ International_Help <> 0
d2024 1
a2024 1
        [ International_Help=0
d2216 1
a2216 1
       |
d2329 1
a2329 1
       ]
d2384 3
a2386 3
	[ ThreeDPatch
	Command WimpVisualFlags,255,0,International_Help
	]
d3336 1
a3336 1
        LDRVS   R2,=Legacy_IRQsema
d3343 1
a3343 1
        LDRVS   R2,=Legacy_DomainId
@


4.48
log
@Postfix default assignment of Wimp$IconTheme with a dot
Avoids restriction of 10 letter filenames on short name media. Idea supplied by Ben-cunning-fox-Avison.
@
text
@d853 1
d953 4
a956 1
preservett      #       1               ; used to hang onto translation tables
a1065 1
longjumpSP      #       4               ; for cutting out the middle-man
d1240 3
a1242 1
lastmode        #       4
d1246 4
a1249 1
needsfactors    #       4
d1251 2
a1252 3
factors         #       16

ditheringflag   #       4               ; flag to control dithering
d1254 2
a1256 1
physpaltable    #       4*16            ; secondary palette table (disconnected from Wimp jobbie)
d1261 3
a1263 1
        ALIGNHASH       4
a1264 1
pixtable_params #       4*6             ; parameters used for the select table call
a1267 2
temppaltable    #       4*16            ; temporary store for a palette

d1272 3
d1542 1
a1542 2
tools_area      #       4               ; area for tools list
tools_trans_size #      4               ; size of last tools_trans
d1606 2
d3668 3
d3673 4
a3676 1
        STRB    R0,preservett           ; don't mind losing it on an invalidate cache service call
d3689 1
a3689 1
        ADRL    R14,tools_area
d4326 1
a4326 1
        LDRB    R2,preservett           ; avoid discarding the table when we know
d4328 1
a4328 1
        BNE     %FT10
d4333 2
a4334 2
        BLNE    XROS_Module              ; attempt to release - ignore errors
;
d4337 1
a4337 1
;
d4339 1
a4339 1
        STR     R2,lastmode
d4349 4
a4352 10
        [ false
        BL      freetoollist            ; Lose cached tool data
        |
; tool translation table is invalid,  try to recache
        LDR     R2,tool_area
        CMP     R2,#0
        BEQ     %FT99
        LDR     R2,tool_list
        CMP     R2,#0
        BEQ     %FT99
d4355 7
a4361 1
        STR     R2,tool_list      ; force recache next time we need it
a4362 3
99
        ]
10
d4605 4
d4615 2
d5407 1
a5407 1
        LDR     R0,pixtable_at
@


4.47
log
@Be more specific when after all tries the sprites aren't found
Messages updated to be more specific/helpful.
Magic numbers for OS_File swapped to use names from Hdr:HighFSI.

Version 5.15. Not tagged
@
text
@d3228 1
a3228 1
WimpDefTheme    DCB     UserIF
@


4.46
log
@Preset Wimp$IconTheme on initialisation to UserIF if not already set
Therefore, when in ROM, the ROM theme can be inferred. When a different theme is selected by the user in the boot sequence, that is respected.
Restore a lost error message for *ICONSPRITES when the file doesn't exist even after trying all the 11/22/23 suffix and prefixes. This seems to have been lost post RISC OS 3.10 when Sprites22 support was added, but it is an error for the file given to not exist at all (cf. *TOOLSPRITES).
Typos in docs ammended.

Version 5.15. Tagged as 'Wimp-5_15'
@
text
@d348 1
a348 1
        MOV     R0,#0                   ; save file
d3099 6
a3104 2
        TEQ     R0,#1                   ; must be a file (NB doesn't affect V)
        BNE     %FT99                   ; bound not to work!
d3196 1
d3203 1
a3203 1
  MakeErrorBlock  WimpBadSprites
d3226 1
d3230 1
@


4.45
log
@Two magic numbers swapped to defines.
Retagged as Wimp-5_14.
@
text
@a2945 15
        [ false
        MOV     R14,#ms_data            ; message block size
        STR     R14,[sp,#-ms_data]!
        MOV     R14,#0                  ; your_ref
        STR     R14,[sp,#ms_yourref]
        LDR     R14,=Message_IconsChanged
        STR     R14,[sp,#ms_action]
        MOV     R0,#User_Message
        MOV     R1,sp
        MOV     R2,#0                   ; broadcast message
        BL      int_sendmessage_fromwimp
        ADD     sp,sp,#ms_data
        CLRV                            ; ignore errors
        ]

d2953 1
a2958 13
05
        Push    "R0"
        [ true                          ; don't send error back
        LDR     R0,[R0]
        LDR     R14,=ErrorNumber_WimpBadSprites
        TEQ     R0,R14                   ; not really an error!
        CLRV    EQ
        ]
      [ Sprites11
        Pull    "R0,R7-R8,PC"
      |
        Pull    "R0,PC"
      ]
d2974 1
a2974 1
; Out   R1 -> <filename><suffix> (in watchdog errorbuffer)
a2979 5
      [ false
        ADRL    R2,watchdogerrtxt       ; changed from errorbuffer to fix nager:sprites occurring cos
                                        ; this was writing over the errorblock before it was presented
                                        ; to the user
      |
a2981 1
      ]
d2996 1
a2996 3
      [ false
        ADRL    R1,watchdogerrtxt
      |
a2997 1
      ]
d3103 1
a3103 1
        LDR     R14,=&fca                ; squashed!
d3218 5
a3222 2
WimpPath        DCB     "WindowManager$Path", 0
ResourcesColon  DCB     "Resources:$.Resources.Wimp."
d3235 1
a3235 1
; initialise Wimp$Path if not already done
d3237 1
a3237 1
        ADR     R0, WimpPath
d3240 1
a3240 1
        MOV     R4,#0      ; Do not expand, to bypass a bug in OS_ReadVarVal
d3244 3
a3246 3
        ADREQ   R0, WimpPath
        ADREQ   R1, ResourcesColon         ; set variable to "Resources:Resources."
        MOVEQ   R2, #?ResourcesColon
d3251 18
a3268 1
;
@


4.44
log
@Add extra Wimp_ReadSysInfo reasons 23/24/25/26/28.
RISC OS Select has added reasons 18-27 and this change implements those that map directly to features that already exist (unimplemented ones return an error as before).
One additional reason, 28, permits the reading of the flags collected from the *WimpVisualFlags command so that applications can discover if the cheesy 3D borders are on or not.

Version 5.14. Tagged as 'Wimp-5_14'
@
text
@d2393 2
a2394 2
        MOVVS   R0,#0
        TST     R0,#1
@


4.43
log
@Make compatible with zero page relocation
Detail:
  s/Wimp, s/Wimp01, s/Wimp02, s/Wimp07, s/Wimp08 - Try using OS_ReadSysInfo 6 to get IRQsema & DomainId locations before falling back on legacy values. Store the pointers in module workspace for speedy access.
Admin:
  Tested on rev A2 BB-xM


Version 5.13. Tagged as 'Wimp-5_13'
@
text
@d405 1
a405 1
ThreeDFlags_Use3DBorders		*	1<<0	; set to indicate the user wants 3D borders if they are configured
d1280 1
a1280 1
MaxIdleEvents   #       4               ; maximum number of idle events recieved
a5224 19
;;             0 ==> read number of active tasks
;;             1 ==> read current Wimp mode (version 2.34 onwards)
;;             2 ==> read address of romspr_suffix
;;             3 ==> read status of commandwindow (pending => in Wimp)
;;             4 ==> current write direction
;;             5 ==> current task
;;             6 ==> Swap space Used / Free
;;             7 ==> Wimp version number (V3.10 on)
;;             8 ==> Outline font being used as system font
;;             9 ==> Tool sprite CB area
;;            10 ==> Icon bar information, internal use
;;            11 ==> Application space size
;;            12 ==> Message queue pointers, internal use
;;            13 ==> Memory debugging, internal use
;;            14 ==> Translation tables, internal use
;;            15 ==> disabled
;;            16 ==> R0 = low priority Wimp sprite pool, R1 = high priority sprite pool
;;            17 ==> Default autoscroll pause delay
;;
d5226 1
a5241 1
      [ Swapping
a5242 3
      |
        B       err_badR0               ; otherwise return
      ]
a5243 1
      [ outlinefont
a5244 3
      |
        B       err_badR0
      ]
d5246 19
a5264 16
        B       sysinfo_IconBar         ; 10= Iconbar info     (Internal)
        B       sysinfo_appspace        ; 11= App space size
        B       sysinfo_messages        ; 12= message queue
        B       sysinfo_memclaim        ; 13= list of memory claims
        B       sysinfo_transtables
	B	err_badR0
      [ SpritePriority
	B       sysinfo_baseofsprites   ; 16 = low/high priority sprite areas
      |
        B       err_badR0
      ]
      [ Autoscr
	B       sysinfo_pausedelay      ; 17 = drag-and-drop scroll startup delay (cs)
      |
        B       err_badR0
      ]
d5310 1
a5311 1
sysinfo_Swapping
d5314 2
a5317 3

VersionPtr      DCD     Module_Version

d5319 1
a5319 1
        LDR     R0,VersionPtr
d5321 4
a5324 4


        [ outlinefont
sysinfo_SystemFont                      ; added nk for 3.20
d5327 4
a5330 3
        STR     R1,[sp]
        B       ExitWimp
        ]
d5336 1
a5336 1
sysinfo_IconBar
d5345 30
d5383 3
a5385 1
        STMIA   sp,{R1}
a5386 1
        B       ExitWimp
d5389 1
a5389 1
        [ DebugMemory
d5392 1
a5392 1
        ]
d5402 1
a5403 1
sysinfo_baseofsprites
d5406 3
a5408 2
        STR     R1, [sp]
	B	ExitWimp
d5411 1
a5412 1
sysinfo_pausedelay
d5417 2
@


4.42
log
@Make the Wimp automatically switch VFP contexts
Detail:
  s/Wimp, s/Wimp01, s/Wimp02, s/Wimp03, s/Wimp07 - The Wimp now uses the VFPSupport module to switch VFP contexts when performing task switches.
  Each task begins with the null context active (i.e. no VFP/NEON access). When paging out a task the ID of the active context is saved in the Wimp's per-task workspace. This context is then restored when the task is about to be resumed.
  Context save/restore is performed while the right task's memory is paged in, so it's safe to use with contexts located in application space.
Admin:
  Tested with Iyonix & Beagle ROM builds.


Version 5.09. Tagged as 'Wimp-5_09'
@
text
@d1505 3
d3328 16
@


4.41
log
@  GET file pathnames changed
Detail:
  Uses suffixed file extensions for compatiblity with both objasm and asasm.
Admin:
  Supplied by Peter Naulls, tested at ROOL

Version 5.05. Not tagged
@
text
@d616 1
@


4.40
log
@  3D window outline colour default initialiesed to black
Detail:
  Wimp found to have ininitialised WindowOutlineColour until the
  WimpVisualFlags had been run. Now initialised at module startup.
Admin:
  Tested in ROM build. J Ballance, Castle


Version 5.05. Tagged as 'Wimp-5_05'
@
text
@d3779 1
a3779 1
        GET     s.!Palette
@


4.39
log
@  Make colour used for the window outline configurable.
  Allow the outline to be plotted over the window tools.
Detail:
  The options available through WimpVisualFlags have been extended with two
  new options that control how the window outline is plotted.

  WimpVisualFlags -WindowOutlineColour <&RRGGBB> -WindowOutlineOver

  WindowOutlineColour defines the colour to be used for the window outline.
  It allows theme designers to choose a window outline colour that fits
  in with a theme's general colour scheme. Default value is black.

  WindowOutlineOver controls if the window outline is plotted over the
  toolicons. It can be used to ensure that there is a window outline
  visible even when the toolicons are borderless. Default value is off.
Admin:
  Tested on RO 5.11
Author:
  Fred Graute

Version 5.04. Tagged as 'Wimp-5_04'
@
text
@d3598 2
@


4.38
log
@  Allow a different set of window toolicons for the window with the input focus.
Detail:
  Previous versions of the Window Manager required toolicons to have pixels
  that were transparent so that the background colour could be used to indicate
  whether a window had input focus or not. This means that new sets of toolicons
  either have to have transparent pixels or lose indication of input focus.
  To remove this limitation the support for toolicons has been extended so
  that a different set of toolicons can be used for the window with the input
  focus.

  The new icons have the prefix 'f' added to their names as follows:
    <toolname>    standard version of toolicon
    p<toolname>   pressed version of toolicon
    f<toolname>   focus version of toolicon
    pf<toolname>  pressed+focus version of toolicon

  Code has been added to ensure that all toolicons are represented.
  This is done in two stages; first the pressed icons are checked and for any
  missing its non-pressed equivalent will be filled in. Next the focus icons
  are checked and for missing ones its non-focus equivalent will be used.
Admin:
  Tested on Iyonix RO5.11
Author:
  Fred Graute

Version 5.03. Tagged as 'Wimp-5_03'
@
text
@d413 1
d798 1
d2183 2
d2194 3
a2196 1
				DCB "   Set the colour of the bottom right portion of the menu border.",0
d7213 2
a7214 1
	DCB	"NoFontBlending=NFB/S,FontBlending=FB/S",0
d7266 4
d7290 5
@


4.37
log
@  Fixed misalignment of WimpWriteDir code.
  Fixed corruption of table with characters to be mapped to WimpSymbol.
Detail:
  There was an ALIGN statement missing just above the code for WimpWriteDir

  The table used to map characters to the WimpSymbol font had become corrupted
  which prevented the mapping from working correctly. This resulted in keyboard
  shortcuts disappearing in menus when using fonts that don't have definitions
  for the required characters, in particular the up-arrow representing shift.
Admin:
  Tested on RO 5.11
Author:
  Fred Graute

Version 5.02. Tagged as 'Wimp-5_02'
@
text
@d81 27
a107 5
$lab    AddIcon $name,$pressable,$sprite,$width,$height
        int_AddIcon $name, $sprite, $width, $height
      [ "$pressable"=""
        [ "$sprite"=""
          int_AddIcon "p$name", $sprite, $width, $height
d109 5
a113 1
          int_AddIcon "p$name", "p$sprite", $width, $height
d115 3
a117 1
      ]
@


4.36
log
@32-bitted some debugging code.
Moved the Hdr:NdrDebug routines so that debug versions build.

No change to production binaries, so not tagged.
@
text
@d2339 1
@


4.35
log
@Added a new window flag (extra flags byte bit 4) to indicate that
Wimp_GetPointerInfo should include shaded icons, in particular so that they
can now have interactive help. Included some information on RISC OS Select
APIs so that we can avoid clashes.

Version 4.89. Tagged as 'Wimp-4_89'
@
text
@a3806 2


d3835 11
@


4.34
log
@Added a couple of new Wimp_TextOp reason codes. Current clients are Filer
2.08 and Pinboard 0.80.

Version 4.88. Tagged as 'Wimp-4_88'
@
text
@d1784 3
a1786 5
wf2_truecolour  *       2_00000001      ; use title validation string colours
                                        ; (implies w_title+4 is always used as validation string pointer, unless
                                        ; already in use as spriteareaCB ptr, or part of non-indirected string)
wf2_reserved    *       2_00001100      ; these bits are (erroneously) set in ResEd's window-object prototype
                                        ; so we can't use them
d1788 3
d1795 1
@


4.33
log
@Resource tweaks: changed floppydisc label; corrected *WimpVisualFlags help
to use present tense like all other help strings do.

Retagged as 'Wimp-4_85'
@
text
@d1170 3
@


4.32
log
@  Menu bugfixes and sprite variation support.
Detail:
  * Adjust clicking on menu items was leading to Message_MenusDeleted being
    broadcast, resulting in incorrect behaviour in many applications.
  * Sprite-only menu items (eg !Draw's line pattern submenu) now highlight
    correctly when tiled menus are configured.
  * Added Wimp_Extend 13, which works out the appropriate resolution suffix
    for a given sprite pathname - required since Sprites11 support needs
    an iterative approach. This supercedes Wimp_ReadSysInfo 2.
  * *IconSprites now tries prefixing the last element of its path argument
    with "<Wimp$IconTheme>".
Admin:
  Tested on Tungsten.

Version 4.85. Tagged as 'Wimp-4_85'
@
text
@d2133 1
a2133 1
WimpVisualFlags_Help		DCB "*WimpVisualFlags will change some aspects of the visual appearance of the desktop.",cr
@


4.31
log
@  Bugfixing, Sprites11 support and stretchy command windows.
Detail:
  * Bugfix: the contents of the pollword returned in the poll block by
    a PollWordNonZero event, where the pollword was flagged as high
    priority, was rotated by 8 bits due to a internal top-bit-set
    workaround. This no longer happens. (This was causing OmniClient never
    to complete initialisation on my machine.)
  * Extended the alternate resolution icon scheme for RAM/ROM sprites and
    toolsprites to be multi-pass, enabling the use of extra sprite sets for
    weird modes (most notably EX0 EY0 ones). After '23' or '0' suffixes
    (the latter still only applies to toolsprites), the suffix for the
    equivalent polychromatic resolution is tried. After rectangular
    suffixes, the next larger squarer suffix is tried. After '11', '22' is
    tried. Failing all of these, a match is attempted with no suffix.
  * The command window is now scaled and centred to match the current screen
    mode - up to a maximum size of 1280 x 1024 OS units.
  * Fixed the *WimpVisualFlags help strings (again).
  * Fixed 'task2' debugging to know about the structure of the SVC stack on
    32-bit machines.
  * Added support for generation of GPA files.
Admin:
  Tested on Tungsten.

Version 4.84. Tagged as 'Wimp-4_84'
@
text
@d2793 2
a2794 1
        Push    "R12,LR"
d2797 37
a2833 3
      [ Sprites11
        MOV     R3,R0                   ; R3 -> original filename
        LDRB    R5,romspr_suffix
d2838 1
a2838 1
01      ADD     R14,R5,R6,LSL #8
d2845 3
d2857 1
a2857 1
        BVC     %FT04
d2861 1
a2861 1
        BEQ     %BT01                   ; after Sprites23, try Sprites22
d2866 1
a2866 1
        BNE     %BT01                   ; after rectangular pixels, try next squarer version
d2871 1
a2871 1
        BEQ     %BT01                   ; after Sprites11, try Sprites22
d2876 9
a2884 1
04      ADD     sp,sp,#4
d2889 1
a2890 1
        BVS     %FT05
d2917 1
a2917 3
      [ Medusa
        Pull    "R12,PC"                ; Medusa uses DA
      |
d2923 5
a2927 1
        Pull    "R12,PC"
d2937 11
a2947 1
        Pull    "R0,R12,PC"
@


4.30
log
@  A few bugfixes, and some muching around with WimpVisualFlags that I did
  ages ago but hasn't made it into a build yet.
Detail:
  * Deleting icon 0 in a window that had no windows would rotate the
    contents of word &00000010 by 16 bits. This had the effect of causing
    lazy task swapping to blow up with an "undefined instruction" error.
  * Setting the caret to a byte position beyond the end of an icon's text
    would (a) loop indefinitely if the alphabet is UTF-8, or (b) data abort
    for any other alphabet. This was due to the code trying to determine the
    number of characters in the string, and ignoring the terminator;
    skipcharR would never advance far enough to satisfy the loop in UTF-8,
    in other alphabets it would advance as far as necessary, leading to the
    later code to try to step a huge number of characters through the
    pushfontstring copy of the text, running off the top of the SVC stack
    (which is mapped out on Tungsten, previously it abutted the system heap,
    so no ill effects were observed).
  * Keyboard shortcuts are now correctly positoned when 3D menus are selected.
  * Corrected spelling of "dialogue" in *WimpVisualFlags help.
  * Changed *WimpVisualFlags so that no parameters gives RISC OS 3
    behaviour, and -All gives default RISC OS 4 behaviour. (Previously, font
    blending was enabled in both cases, unless explicitly disabled by an
    additional -NoFontBlending switch.) This required a sense change in the
    font blending switch: -FontBlending now enables font blending.
    -NoFontBlending is still accepted without error, but is ineffectual
    (since the no-options state upon which it acts already has font blending
    disabled).
  * Default setting is now as though *WimpVisualFlags -RemoveIconBoxes had
    been executed. (In practice, this will not be noticeably different from
    previous Tematic versions, see below.)
  * The state -RemoveIconBoxes switch was previously assumed always set -
    now, if it is not specified, you get the old RISC OS 3 behaviour back.
Admin:
  Tested on Tungsten.

Version 4.82. Tagged as 'Wimp-4_82'
@
text
@d160 3
a162 1
        LDR     R0, [sp, #1*4 + 11*4 + 2*4 + 2*4] ; get return address from stack - skip:
d166 4
a169 2
                                                  ; 1 word:   return address in kernel
                                                  ; 1 word:   used by kernel
d842 1
d844 1
d1938 2
d2133 1
a2133 1
WimpVisualFlags_Help		DCB "Change the visual appearance of the desktop.",cr
d2788 1
a2788 1
; Out:  R0-R3 corrupted (OS_CLI restores them)
d2796 14
d2812 1
d2818 22
d2843 1
d2893 3
a2895 1
; In    R1 -> sprite filename
d2897 2
d2922 1
d2924 1
d3744 2
d3971 1
d3973 1
d3978 3
d3982 1
d3986 3
d3990 1
d3995 10
d4015 2
a4017 1
        ADD     R14,R5,R6,LSL #8
d4020 8
d4034 22
d4059 1
d5314 1
a5314 2
        CMP     R0, #0
        CMPNE   R0, #-1
d5329 4
d5587 48
@


4.29
log
@Fix to Wimp_DeleteIcon stiffing the machine when trying to delete an
icon which doesn't yet exist.Now fails gracefully.
Import of another set of awful icons in the Iyonix resources.
Tweak to the number of CLI parameters accepted by * commands.

Version 4.80. Tagged as 'Wimp-4_80'
@
text
@d369 3
a371 1
ThreeDFlags_Default                     *       ThreeDFlags_NoFontBlending
d380 1
a380 1
ThreeDFlags_FullIconClipping		*	1<<7
d2127 1
a2127 1
				DCB "	Give all menus and dialog boxes a 3D border.",cr
d2129 1
a2129 1
				DCB "	Give all menus a textured background.",cr
d2131 1
a2131 1
				DCB "	Use a different background tile for menus.",cr
d2133 1
a2133 1
				DCB "	Remove the filled box from behind the text in text+sprite icons.",cr
d2135 1
a2135 1
				DCB "	Remove the filled box from icons on windows similar to the pinboard.",cr
d2137 3
a2139 3
				DCB "	Make the iconbar have a full 3D border.",cr
				DCB "-NoFontBlending",cr
				DCB "   Don't use font blending in icons.
d2141 1
a2141 1
				DCB "	Turn all flags on.",cr
d2143 1
a2143 1
				DCB "	Set the colour of the top left portion of the window border.",cr
d2147 1
a2147 1
				DCB "	Set the colour of the top left portion of the menu border.",cr
d2149 1
a2149 1
				DCB "	Set the colour of the bottom right portion of the menu border.",0
d6949 1
a6949 1
	DCB	"NoFontBlending=NFB/S",0
d6957 1
a6957 1
	MOVEQ   r1,#ThreeDFlags_NoFontBlending
d6972 1
a6972 1
	MOV	r2,#0
d6994 3
a6996 3
	LDR	r1,[sp,#44]
	TEQ	r1,#0
	ORRNE	r2,r2,#ThreeDFlags_NoFontBlending
d6999 1
a6999 1
	ORRNE	r2,r2,#ThreeDFlags_FullIconClipping
d7023 1
a7023 1
	MOVNE	r2,#&FFFFFFFF :EOR: ThreeDFlags_NoFontBlending
@


4.28
log
@  Merged in RISC OS 4.02 changes (including ROM patches). Also som bugfixes.
Detail:
  RISC OS 4 changes:
  * Font blending for desktop font (based on NC code, but now configurable)
  * 3-D window/menu/iconbar borders
  * Textured menu backgrounds
  * Loss of rubout box in unfilled text+sprite icons
  * *WimpVisualFlags controls various aspects of cosmetic changes above
  * Iconise button "slot" glyph slightly shorter (but only adopted in the RO400
    Resource directory)
  * Command window has front-window flag set
  * Byte at +39 of the window block has gained two new flag bits:
      bit 2 set => this window must never be given a 3D border
      bit 3 set => this window must always be given a 3D border
      (note that ResEd erroneously created windows with both bits set,
      this case is treated as though both bits were clear)
  * Another two colour specifiers on the end of C validation string command
    for icons controls the foreground and background colours to be used when
    the icon is selected
  * Pointer shape is correctly reprogrammed by the creation of icon
    underneath it
  * Full stops in writable icons are treated the same as spaces from the
    point of view of cursor navigation
  * spritesize routine returns a size of 0 if the sprite didn't exist
    (probably fixes some rendering problems)
  * Adjust-click on back icon brings window to front
  My changes:
  * DeleteRight turned on
  * Icon bar title background is set to default in all resource sets (avoids
    translation table recalc)
  * Error box title now cream across all resource sets
  * RISC OS 4 changes made 32-bit compatible / high addresses safe
  * Undocumented FullIconClipping option disabled
  * Command help made consistent for internationalised and non-
    internationalised builds
  * WimpVisualFlags defaults made sensible
  * Menu side width affected by ThreeD option at *run* time not assemble time
  * Right-clicking on menus with writable items no longer data aborts
  * Auto-opened menus are now at RHS of current icon (matches RISC OS 3.1)
  * Colour menus were knackered unless menu tiling was enabled
  * Fixed a bug whereby adding messages to a task that wanted all messages
    actually caused it to lose all other messages. The RISC OS 4 fix for
    this didn't work
  * Fixed bug introduced in version 4.76: tasks that wanted no messages got
    all of them
  * Autoscrolling is updated every 8 cs rather than every 12 cs
  * Added menu texture to pre-RISC OS 4 sprites files
Admin:
  Tested on Tungsten.

Version 4.78. Tagged as 'Wimp-4_78'
@
text
@d2134 1
a2134 1
				DCB "-Fully3DIconbar",cr
d2321 1
a2321 1
	Command WimpVisualFlags,15,0,International_Help
@


4.27
log
@  Memory-related stuff.
Detail:
  * Default UpCall handler is installed when an application is paged out,
    so there is no danger of it being called by naughty people issuing
    UpCalls in the background.
  * AMBControl builds now sit on Service_MemoryMoved so that they can issue
    Message_SlotSize when the kernel has resized the application slot
    independently (eg because the memory was needed to grow a dynamic area,
    and nobody objected via Service_Memory or UpCall_MovingMemory).
  * Medusa-onwards builds no longer request Service_ValidateAddress, because
    we're not managing the free pool any more, and the code that was here
    only called an ineffectual SWI!
  * SafeChangeDynamic wasn't setting the CAO high enough to be free of big
    application slots; now it points it at itself.
  * The free pool wasn't being shrunk/grown enough on initfirsttask /
    closelast. It still can't do by more than 1GB without stiffing - bug in
    kernel?
  * Bugs in top-bit-safe changes fixed: dragbox resizing was broken, Escape
    state wasn't being restored for new tasks.
Admin:
  Tested on high-ROM/stack, 48M-appslot Tungsten.

Version 4.77. Tagged as 'Wimp-4_77'
@
text
@d350 34
d758 6
d773 4
d779 1
d849 6
d858 1
d1022 13
a1050 13
maxmenus        *       8
longjumpSP      #       4               ; for cutting out the middle-man
whichmenu       #       4
menus_temporary #       4               ; if set, Wimp_Poll kills the menus
menuhandle      #       4
menuiconwidth   #       4
menuiconheight  #       4
menuiconspacing #       4
menuSP          #       4
menuhandles     #       4*maxmenus      ; handle of relevant window
menudata        #       4*maxmenus      ; ptrs to menu definitions (-1 if dial)
menuselections  #       4*maxmenus      ; selection index in each menu

d1101 1
a1101 1
autoscr_update_delay    *      12       ; hardwired minimum interval between updates (cs)
d1145 3
d1223 1
a1223 1
        [ windowsprite
d1516 5
d1779 4
d2122 28
d2259 4
d2320 3
d2798 5
a2802 1
        [ windowsprite
d2805 2
a2806 1
        ]
d3435 19
d3532 12
d3548 1
a4033 1
        Pull    R0
d4035 4
d4040 1
d4042 1
d4096 3
d4102 1
d6107 20
d6911 4
d6917 1
d6938 116
@


4.26
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@d999 4
d3595 1
a3595 3
        [ :LNOT: UseAMBControl                          ;
        DCD     Service_MemoryMoved             ; &4E   ;
        ]                                               ; must be in ascending order
d3599 1
d3601 1
a3626 1
        [ :LNOT: UseAMBControl
a3627 1
        ]
d3631 1
d3633 1
d3678 1
d3681 1
d3688 1
d3691 1
a3691 1
      [ Medusa
a3694 1
    ]
d3726 10
a3735 10
         [ true
        Push    "R0-R2,lr"
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea             ; is there a kernel free pool
        Pull    "R0-R2,lr"
        MOVVC   PC,lr
        CLRV
        |
        MOV     PC,lr
         ]
@


4.25
log
@  Commit of my Wimp changes that have trickled in over the last four months.
Detail:
  * The pointer passed to Wimp_CommandWindow can now be top-bit-set.
  * Bugfix to Wimp_CommandWindow: if the current task was uninitialised,
    or initialised as a non-multitasking task, then although entering the
    CommandWindow would restore escape condition generation to the way it
    was before entering the desktop, exiting the CommandWindow did not
    reset escape condition generation to the default desktop state (which is
    for escape condition generation to be disabled).
  * Escape condition generation is disabled for the duration of SWI
    Wimp_ReportError (instead of setting the default escape key for the
    duration). The previous state is restored on exit.
  * Added a minimal environment for the service call
    Service_ErrorButtonPressed, so that claimants can call OS_Exit without
    leaving the global Wimp error box in an undefined state.
  * In the Wimp_Poll loop, if there are no events to deliver to any tasks
    (not even null events), then rather than sitting in a SVC mode loop,
    the Wimp now triggers transient callbacks. This is particularly
    important in order not to halt all activity in the Internet stack.
    The option LeaveOS can be set to make the Wimp use the as-yet
    unimplemented SWI OS_LeaveOS for this purpose; this is currently unset
    for all builds.
  * By (persistent) request, reinstated the old iconbar popping code,
    though it is currently a build switch that is turned off for all builds.
Admin:
  Tested on a Risc PC.

Version 4.69. Tagged as 'Wimp-4_69'
@
text
@a499 2
ROMstart        *       &3800000

d771 2
d2233 1
a2233 1
        Pull    "PC",GT
d2313 1
a2313 1
        BGT     bad_param_exit2
d2345 1
a2345 1
        BLT     scan_ended
d2400 2
a2401 2
        CMP     R4,#0
        BGE     bad_param_exit                  ; only one x allowed
d2408 2
a2409 2
        CMP     R5,#0
        BGE     bad_param_exit                  ; only one y allowed
d2422 2
a2423 2
        CMP     R6,#0
        BGE     bad_param_exit                  ; only one C or G allowed
d2438 3
a2440 3
        CMP     R0,#0
        MOVGE   R6,R0
        BGE     scan_for_param
d2462 2
a2463 2
        CMP     R6,#0
        BGE     bad_param_exit                  ; only one C or G allowed
d2793 1
a2793 1
        BGE     err_badR0
d3070 2
a3071 2
        MOV     R1,#640*1024
        DivRem  R2,R1,R0,R14            ; R2 = number of pages for 640k
d3730 1
a3730 1
        ]
d3739 1
a3739 1
        Pull    "PC",LT
d3743 1
a3743 1
        Pull    "PC",GT
d3746 1
d3770 2
a3771 2
        CMP     R0,#0                   ; if R1 = -2, we're stuck!
        LDRLT   R0,currentmode          ; (just give up and use the original)
d3950 1
a3950 1
        ORR     R2,R2,#&80000000
d3958 2
a3959 2
        CMP     R2,#1
        BLT     %FT99
d3961 2
a3962 2
        CMP     R2,#1
        BLT     %FT99
d4040 1
d4042 3
a4044 2
        ADRLTL	R6,disc
        MOVLT   R5,#bignum              ; long timeout if R6 invalid
d4214 1
a4214 1
        BLGT    XROS_Module              ; release the template loading buffer (ignore errors)
d4293 1
a4293 1
        CMP     R2,#0
d4295 2
a4296 2
        MOVGT   R0,#1   ;deallocate reason code
        SWIGT   XOS_AMBControl
d4298 2
a4299 2
        MOVGT   R0,#ModHandReason_Free
        BLGT   XROS_Module                      ; free block (ignoring errors)
d4308 1
d4310 4
a4313 3
        CMP     R2,#0
        MOVGT   R0,#ModHandReason_Free
        BLGT   XROS_Module
d4333 1
a4333 1
        BLE     %FT01
d4336 1
a4336 1
        CMP     R2,#0
d4338 2
a4339 2
        MOVGT   R0,#1   ;deallocate reason code
        SWIGT   XOS_AMBControl
d4341 2
a4342 2
        MOVGT   R0,#ModHandReason_Free
        BLGT   XROS_Module
d4358 2
a4359 2
        CMP     R2,#0
        BLE     %FT02
d4377 2
a4378 2
        CMP     R1,#0
        BLE     %FT02
d4568 2
a4569 2
        CMPLT   R1,#ApplicationStart
        BLT     err_badpointer
d5489 2
a5490 2
        CMPGT   R1,#0                   ; null pointer if <= 0
        BLE     justsetshape
d6705 1
a6705 1
        BGE     %BT01
d6723 1
a6723 1
        BGE     %BT01
@


4.24
log
@  Stack imbalance corrected.
Detail:
  When building a copy for RISC OS 3.1, this bug would be hit. Now fixed.
Admin:
  Checked on RISC OS 3.1; seems to work fine now.

Version 4.68. Tagged as 'Wimp-4_68'
@
text
@d1378 1
d1380 1
d1438 3
d1479 4
d5050 3
a5053 1
        BLT     releasewrch             ; R0 <= 0 ==> remove window
d5113 13
d5143 1
a5143 1
        BL      resetkeycodes           ; back to normal
d5155 1
a5155 1
        CMP     R0,#0                   ; R0 < 0 ==> do this quietly
d5157 1
a5157 1
        BLT     %FT01
d5172 1
a5173 1
        BLGE    waitforkey
@


4.23
log
@  Minor fixes, some of which have been waiting to be committed for a while.
Detail:
  * Command line buffer for Wimp_StartTask (and anything that uses it,
    eg *WimpTask) increased from 256 bytes to 1024 bytes.
  * Top-bit-set message list pointers passed to Wimp_Initialise and
    Wimp_RemoveMessages now work (there was never a problem with
    Wimp_AddMessages!)
  * The fix for top-bit-set application name pointers in Wimp 4.65 actually
    only fixed lookup for "<application> may have gone wrong" lookups. They
    now work correctly in error window title construction, and when
    constructing an application sprite name if flag bit 8 is clear.
  * A pointer value of 0 is now accepted in addition to -1 for an
    "<application> may have gone wrong" lookup - this brings it into line
    with the other two places where the application name pointer is
    referenced.
  * When constructing an error window title, the Wimp would skip any leading
    backslash character. Now it does so when constructing "<application> may
    have gone wrong" too - this is a simple way to disable the application
    sprite in the error window.
Admin:
  Error box behaviour actually tested this time!

Version 4.67. Tagged as 'Wimp-4_67'
@
text
@d3836 1
a3836 1
        Push    "LR"
@


4.22
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 4.64. Tagged as 'Wimp-4_64'
@
text
@d1420 1
a1420 1
taskbuffer      #       256             ; command which starts a task
@


4.22.2.1
log
@  Added Dan Ellis's multithreading support, on a development branch for now.
Detail:
  This breaks the equivalence between tasks and AMB slots, allowing many
  threads of execution to share the same AMB slot, where an application's
  heap is usually located. In API terms, it is presented as an extension to
  Wimp_StartTask, see Docs/Multithreading for more information. It is the
  caller's responsibility to create a new stack chunk for the new thread if
  required. Note that BASIC's variable storage model is fundamentally
  unsuited for multithreading.
Admin:
  This was developed in 2001 and was not committed at the time due to lack
  of testing and peer review. It is now being added as a branch from a
  contemporary trunk Wimp. Hopefully somebody will be interested enough to
  merge the branch into a recent version!

Version 4.66, 4.77.2.1. Tagged as 'Wimp-4_66-4_77_2_1'
@
text
@a512 10
 [ Threads
;-------------------------------;
; Application data block format ;
;-------------------------------;

                  ^     0
app_slotptr       #     4                       ; AMB control block
app_refcnt        #     4                       ; reference count for this application
app_datasize      #     0
 ]
a1850 2
        ENTRY

a3915 1
        Debug   thread, "command window made active premode change"
d4281 1
a4281 1

d4283 2
a4284 1
        BL      deallocate
a4285 1
        CMP     R2,#0
a4288 1

d4315 1
a4315 1
        Push    "R0-R3,LR"
d4319 2
a4320 3
        BLE     %FT10
        LDR     R2,[R2,#task_slotptr]

d4322 1
d4324 2
a4325 1
        BL      deallocate
a4326 1
        CMP     R2,#0
d4335 1
a4335 1
10
d4337 1
a4337 1
        Pull    "R0-R3,PC"
a5298 7

	MOV	r0, #0			; don't do this if in a taskwindow
 	SWI	XTaskWindow_TaskInfo
	MOVVS	r0, #0
	TEQ	r0, #0
	Pull	"R1-R11,PC",NE

@


4.21
log
@  A couple of fixes for bugs that were crippling 32-bit Lazarus builds.
Detail:
  1) The pointer to the module flags word wasn't made relative to the start
     of the module; because the linker bases an image at &8000 by default,
     this meant that the module flags pointer pointed at a word 32K too far
     into the image, and there were even chances whether a given build of
     the Wimp would appear to be 32-bit compatible.
  2) Due to a missing alignment directive in the Wimp's workspace layout, if
     you did a build of the Wimp where one or more of the ClickSubmenus,
     IconiseButton, StickyEdges or BounceClose switches were on but the
     PoppingIconBar one was off, you would end up with several word-sized
     locations being non-word-aligned. This affected embedded builds, where
     only the ClickSubmenus switch (new in Wimp 4.57) is typically set, but
     not desktop builds, where PoppingIconBar is typically set.
Admin:
  Only tested on a desktop machine so far, but this wouldn't have shown up
  either of the problems in the first place...

Version 4.63. Tagged as 'Wimp-4_63'
@
text
@d1874 1
a1874 4
Helpstr =       "Window Manager",9,"$Module_MajorVersion ($Module_Date)"
        [ Module_MinorVersion <> ""
        = " $Module_MinorVersion"
        ]
@


4.20
log
@  Shock horror - a new feature for the Wimp! And some housekeeping too.
Detail:
  * Added new functionality for menu trees: submenus can now be opened by
    clicking on their parent menu item. This is particularly aimed at
    touchscreen devices, and is configurable via the new *Configure keyword
    WimpClickSubmenu.
  * Change to the menu inactivity timeout behaviour after auto-opening of
    submenus (either by hovering over the parent menu item or by the new
    click-to-open functionality): although all hover operations are still
    ignored for this period, any click operations *will* now be obeyed.
  * Corrected numerous misleading comments in the menu handling code.
  * Added some suspiciously absent ALIGNs in the *Configure keyword handlers.
  * Uses new ASCII case-forcing macros so there are now fewer warnings
    printed during assembly (and it should run faster now too).
  * Added an AREA directive so that objasm's -ABS switch is no longer needed.
  * Standardised ErrMem token across all Messages files that use English.
Admin:
  Tested on a desktop machine.
  Requires HdrSrc 1.06.

Version 4.57. Tagged as 'Wimp-4_57'
@
text
@d1074 2
d1871 1
a1871 1
        DCD     Flags
@


4.19
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d1051 5
d2041 5
d2151 4
d2209 3
d2341 1
a2341 1
        UpperCase       R0,R14          ; this is safe
d2370 1
a2370 1
        UpperCase       R0,R14
d2434 1
a2434 1
        UpperCase       R0,R14
d3305 12
@


4.18
log
@  System windows (eg STB command window) can now have window furniture but
  no 1-pixel borders.
Detail:
  The code that checked for a Wimp_Initialise version number of >= 380 before
  applying the new interpretation of title foreground colour &FF was broken:
  it was checking the current task handle instead of the task handle of the
  window's creator. A few other things needed tampering with in order to ensure
  that the window's task handle word is correctly set up at the time that the
  colour check is performed.
Admin:
  Tested in a desktop build, using STB resources.

Version 4.43. Tagged as 'Wimp-4_43'
@
text
@a124 1
        NOP
d548 1
a548 1
task_registers    #     4*16                    ; USR register set
d868 1
a868 1
oldfxstatus     #       11              ; *FX 4
d871 1
d1400 2
a1408 1
registerbuffer  #       4*16
d1416 1
d1864 1
d2145 7
d2747 1
a2747 1
        Pull    "R0,PC",,^
d3411 2
a3412 1
        Pull    "R0,PC",,^
d3435 1
a3435 1
        Push    "R0-R1,LR"
d3440 1
a3440 1
        Pull    "R0-R1,PC",,^
d3508 2
a3509 1
        Pull    "R0-R3,R12,PC",,^       ; no errors allowed here!
d3601 1
a3601 1
        MOVNES  PC, LR
d3688 1
a3688 1
        MOVVCS  PC,lr
d3691 1
a3691 1
        MOVS    PC,lr
a3695 1
      [ ChildWindows
a3696 3
      |
        LDR     r14,memoryOK
      ]
d3719 1
a3719 1
        Pull    "R0,PC",,^
d3801 2
a3802 2
        STRVS   R0,[sp]
        Pull    "R0-R6,PC",,^
d3828 1
a3828 1
        EXITS
d3836 1
a3836 1
        EXITS   EQ
d3840 1
a3840 1
        EXITS
d3932 1
a3932 1
        Pull    "R0,R2,PC",,^
d3956 1
a3956 1
        Pull    "R0-R3,PC",,^
d4102 8
a4109 1
        Pull    "R0-R1,PC",,^           ; claim vector
d4138 8
a4145 1
        Pull    "R0-R3,PC",,^           ; claim vector
d4283 1
a4283 1
        Pull    "R0-R5,PC",,^
d4308 2
a4309 1
        Pull    "R0-R2,PC",,^
d4349 2
a4350 1
        Pull    "R0-R3,PC",,^           ; ignore errors
d4495 1
d4498 4
d4506 1
a4506 2
        MVN     R14,#I_bit
        TSTP    R14,PC                          ; re-enable interrupts
d4570 1
d4572 4
d4592 1
d4594 13
d5334 1
a5334 2
        Pull    "R0-R12,PC",VC,^
        Pull    "R0-R12,PC",VS
d5342 1
a5342 1
        Push    "R0,R2,R3,LR"
d5348 1
a5348 1
        Push    "R0,R2,R3,LR"
d5357 1
a5357 1
        Pull    "R0,R2,R3,PC",,^        ; ignore errors
d5709 1
a5709 1
        Push    "R0,R1,userblk,handle,LR"
d5728 1
a5728 2
        Pull    "R0,R1,userblk,handle,LR"
        MOVS    PC,LR                           ; must preserve flags
d5793 1
a5793 1
        EXITS
d6552 1
a6552 1
        Push    "R0,R1,userblk,handle,LR"
d6559 1
a6559 1
        Push    "R0,R1,userblk,handle,LR"
d6582 1
a6582 2
        Pull    "R0,R1,userblk,handle,LR"
        MOVS    PC,LR                           ; must preserve flags
@


4.17
log
@Doing all of recalcmodevars on Service_ModeChanging turns out to be a Bad Idea
because some of the Wimp's copies of VDU variables end up out-of-date. Now
only the parts pertaining to command windows are done on Service_ModeChanging
(for that was the bit we were having trouble with), and the rest is back on
Service_ModeChange.

Version 4.24. Tagged as 'Wimp-4_24'
@
text
@d946 1
@


4.16
log
@Now calls recalcmodevars on Service_ModeChanging instead of Service_ModeChange
(this was clashing with the Interlace module at one point during STB
development, and had the potential to trip us up again in the future).

No longer produces build errors if some resources are absent.

Corrected token in Japan messages file to use valid UTF-8 character.

Service call table now included by default.

Version 4.23. Tagged as 'Wimp-4_23'
@
text
@d3540 1
d3572 1
d3644 2
d3655 1
a3655 1
        BEQ     recalcmodevars
d3834 1
a3834 1
; Service_ModeChanging: cache new graphics parameters
d3856 1
d3858 4
@


4.15
log
@Increased size of indirected data buffer for error template from 256 to 1024.

Version 4.19. Tagged as 'Wimp-4_19'
@
text
@d1693 2
a3539 1
        DCD     Service_ModeChange              ; &46   ;
d3551 1
a3570 1
        TEQNE   R1, #Service_ModeChange
d3582 1
a3641 2
        TEQ     R1,#Service_ModeChange
        BEQ     recalcmodevars
d3650 2
d3830 1
a3830 1
; Service_ModeChange: cache new graphics parameters
@


4.14
log
@Another bugfix to and a new feature of NC error box code:
* If pointer was hidden-until-next-mouse-move, the act of confining the mouse
  to the error box window no longer causes it to be redisplayed.
* In error boxes, the pointer and the IconHigh highlight are now initially
  positioned over the rightmost (default) button. There is one exception to
  this rule: when "Next task" is clicked in a Watchdog window, the pointer
  stays over the "Next task" button.

Version 4.13. Tagged as 'Wimp-4_13'
@
text
@a1316 2
errortitle      #       256              ; for building up 'Error from ...'
errortitend     #       0
a1342 3
        |
errortitle      #       128             ; old versions have smaller template file
errortitend     #       0
d1436 3
@


4.13
log
@Optimisation to new WimpSymbol substitution code: in icons containing fonts
  other than the desktop font, the substitution table is only calculated
  when a symbol character is encountered.
Embryonic cut-n-paste support introduced (currently in desktop builds only):
  * workspace is allocated and initialised;
  * extended Wimp_GetCaretPosition implemented;
  * pushfontstring adapted to allow insertion of arbitrary control sequences in
    font strings (to allow selected text to be plotted in inverted colours).
Inverted, unfilled text icons now work properly again in <256-colour modes.
Reworked NC error box code: see Doc.IconHigh.

Version 4.11. Tagged as 'Wimp-4_11'
@
text
@d1462 2
@


4.12
log
@
my_StringBBox rewritten - effects are:
* Deprecated Font SWIs no longer used
* Height of UTF-8 strings now calculated correctly
* Fancy fonts in icons are now aligned the same as outline desktop-font icons
* Text rubout boxes for icons with text above the sprite are correctly sized

Lazy WimpSymbol subsitution implemented: characters are only substituted if
they are not already present in the font. For the first time, substitution
now works in UTF-8 text - but for the proper Unicode positions of the
relevant symbols, instead of usurping undefined positions (as in other
alphabets).

Version 4.10. Tagged as 'Wimp-4_10'
@
text
@d998 7
d1455 1
a1455 1
		[	PreservePointerOnError
d1458 5
a1462 1
		]
d1478 4
a1485 1
                ! 0,    " autoscr data size     =      " :CC: :STR: (:INDEX: autoscr_END - :INDEX: autoscr_state)
d1517 4
d1635 3
@


4.11
log
@Adapted assembly process so that the choice of Options file (previously based
purely on the "System" variable) can be overridden by passing "OPTIONS=foo" as
an argument to either MkRom, or to amu/amu_machine directly, or indirectly,
by specifying it in the components file for a build. To accomplish this, it
was necessary to switch from using aasm to objasm - hence the large number of
source files affected in this commit.

Version 4.09. Tagged as 'Wimp-4_09'
@
text
@d1008 1
@


4.10
log
@Service_SwitchingOutputToSprite code optimised: graphics parameters are now
only cached when making the first Wimp_PlotIcon call while output is switched
to a sprite, and upon return to screen output after such an occurrence.

All error box templates featuring "border" icons updated to have button type
0 (never). This prevents IconHigh from mistakenly allowing them to be selected.

Version 4.07. Tagged as 'Wimp-4_07'
@
text
@d342 1
a342 1
;; RM header information
d345 2
a346 1
        ASSERT  (.=Module_BaseAddr)
d348 2
a349 1
MySWIBase       *       Module_SWISystemBase + WimpSWI * Module_SWIChunkSize
d351 12
a362 16
        DCD     Start          - Module_BaseAddr
        DCD     Init           - Module_BaseAddr
        DCD     Die            - Module_BaseAddr
        DCD     Service        - Module_BaseAddr
        DCD     Title          - Module_BaseAddr
        DCD     Helpstr        - Module_BaseAddr
        DCD     Helptable      - Module_BaseAddr
        DCD     MySWIBase
        DCD     Wimp_SWIdecode - Module_BaseAddr
        DCD     Wimp_SWInames  - Module_BaseAddr
        DCD     0
 [ International_Help <> 0
        DCD     messfsp        - Module_BaseAddr
 |
        DCD     0
 ]
d364 3
a366 16
Title   =       "WindowManager",0
Helpstr =       "Window Manager",9,"$Module_MajorVersion ($Module_Date)"
        [ Module_MinorVersion <> ""
        = " $Module_MinorVersion"
        ]
        [ DebugMemory
        = " Memory debugging enabled"
        ]
      [ debug
        =       " Development version"
      ]
      [ standalone
        =       "  (Stand alone)"
      ]
	=	module_postfix
        =       0
d368 4
a371 1
        [ International_Help=0
d373 3
a375 3
IconSprites_Help        DCB     "*IconSprites loads a sprite file into the "
                        DCB     "Wimp's common sprite pool",cr
IconSprites_Syntax      DCB     "Syntax: *IconSprites <filename>",0
a376 2
Pointer_Help            DCB     "*Pointer turns the mouse pointer on/off",cr
Pointer_Syntax          DCB     "Syntax: *Pointer [0|1]",0
d378 9
a386 2
ToolSprites_Help        DCB     "*ToolSprites loads a sprite file to use as window borders",cr
ToolSprites_Syntax      DCB     "Syntax: *ToolSprites <filename>",0
a387 11
WimpFlagsC_Help
        DCB     "*Configure WimpFlags sets the default actions "
        DCB     "when dragging windows, as follows:",cr
        DCB     "bit 0 set: continuous window movement",cr
        DCB     "bit 1 set: continuous window resizing",cr
        DCB     "bit 2 set: continuous horizontal scroll",cr
        DCB     "bit 3 set: continuous vertical scroll",cr
        DCB     "bit 4 set: don't beep when error box appears",cr
        DCB     "bit 5 set: allow windows to go partly off screen",cr
        DCB     "bit 6 set: allow windows to go partly off screen in all directions",cr
        DCB     "bit 7 set: open submenus automatically",cr
d389 1
a389 2
WimpFlagsC_Syntax
        DCB     "Syntax: *Configure WimpFlags <number>",0
a390 3
WimpDragDelayC_Help
        DCB     "*Configure WimpDragDelay sets the delay in 1/10 second units after a single click "
        DCB     "after which a drag is started.",cr
d392 17
a408 2
WimpDragDelayC_Syntax
        DCB     "Syntax: *Configure WimpDragDelay <delay>",0
d410 3
a412 3
WimpFontC_Help
        DCB     "*Configure WimpFont sets the font to be used within the desktop for icons and menus. "
        DCB     "0 means use Wimp$* and 1 means use system font. 2-15 refer to a ROM font.",cr
d414 1
a414 2
WimpFontC_Syntax
        DCB     "Syntax: *Configure WimpFont <font number>",0
d416 9
a424 3
WimpDragMoveC_Help
        DCB     "*Configure WimpDragMove sets the distance in OS units that the "
        DCB     "pointer has to move after a single click for a drag to be started.",cr
a425 2
WimpDragMoveC_Syntax
        DCB     "Syntax: *Configure WimpDragMove <distance>",0
d427 10
a436 3
WimpDoubleClickDelayC_Help
        DCB     "*Configure WimpDoubleClickDelay sets the time in 1/10 second units after a single click "
        DCB     "during which a double click is accepted.",cr
d438 12
a449 2
WimpDoubleClickDelayC_Syntax
        DCB     "Syntax: *Configure WimpDoubleClickDelay <delay>",0
d451 4
a454 3
WimpDoubleClickMoveC_Help
        DCB     "*Configure WimpDoubleClickMove sets the distance in OS units that the "
        DCB     "pointer has to move after a single click for a double click to be cancelled.",cr
d456 10
a465 2
WimpDoubleClickMoveC_Syntax
        DCB     "Syntax: *Configure WimpDoubleClickMove <distance>",0
d467 18
a484 4
WimpAutoMenuDelayC_Help
        DCB     "*Configure WimpAutoMenuDelay sets the time in 1/10 second units that the pointer "
        DCB     "has to stay over a non leaf menu entry before the submenu is automatically opened "
        DCB     "if WimpFlags bit 7 is set.",cr
d486 8
a493 2
WimpAutoMenuDelayC_Syntax
        DCB     "Syntax: *Configure WimpAutoMenuDelay <delay>",0
d495 1
a495 4
WimpMenuDragDelayC_Help
        DCB     "*Configure WimpMenuDragDelay sets the time in 1/10 second units for which menu "
        DCB     "activity is disabled after a menu has been automatically opened. This enables the "
        DCB     " pointer to move over other menu entries without cancelling the submenu.",cr
d497 3
a499 2
WimpMenuDragDelayC_Syntax
        DCB     "Syntax: *Configure WimpMenuDragDelay <delay>",0
d501 1
a501 2
WimpPalette_Help        DCB     "Used to activate a Wimp palette file.",cr
WimpPalette_Syntax      DCB     "Syntax: *WimpPalette <filename>",0
d503 5
a507 3
WimpSlot_Help   DCB     "Change the size of application space"
                DCB     ", or the amount of application space allocated to the next task to run."
                DCB     cr
a508 2
WimpSlot_Syntax DCB     "Syntax: *WimpSlot [[-min] <size>[K]] [[-max] <size>[K]] [[-next] <size>[K]]"
                DCB     0
d510 1
a510 2
WimpTask_Help   DCB     "Start up a new task (from within a task)",cr
WimpTask_Syntax DCB     "Syntax: *WimpTask <*command>",0
d512 1
a512 7
Wimp_SetMode_Help   DCB "Change the current Wimp screen mode"
                    DCB " without affecting the configured value.",cr
Wimp_SetMode_Syntax DCB "Syntax: *WimpMode <number>"
        [ Medusa
                DCB     " | <specifier string>"
        ]
        DCB     0
a513 4
WimpWriteDir_Help       DCB "Change the direction for writeable icons.",cr
                        DCB " 0 - Same direction as the configured territory.",cr
                        DCB " 1 - Opposite direction to the configured territory.",cr
WimpWriteDir_Syntax     DCB "Syntax: *WimpWriteDir 0|1",0
d515 24
a538 2
WimpKillSprite_Help     DCB "Remove a sprite from the wimp sprite pool.",cr
WimpKillSprite_Syntax   DCB "Syntax: *WimpKillSprite <spritename>",0
d540 7
a546 12
        [ Autoscr
WimpAutoScrollDelayC_Help       DCB "*Configure WimpAutoScrollDelay sets the time in 1/10 second units "
                                DCB "that the pointer has to stay over the edge of a window before it starts scrolling. "
                                DCB "This only applies in certain circumstances.",cr
WimpAutoScrollDelayC_Syntax     DCB "Syntax: *Configure WimpAutoScrollDelay <delay>",0
        ]
        [ PoppingIconBar
WimpAutoFrontDelayC_Help        DCB "*Configure WimpAutoFrontDelay sets the time in 1/10 second units "
                                DCB "that the pointer has to stay at the bottom of the screen before "
                                DCB "the icon bar is brought to the front.",cr
WimpAutoFrontDelayC_Syntax      DCB "Syntax: *Configure WimpAutoFrontDelay <delay>",0
        ]
d548 3
a550 3
WimpIconBarSpeedC_Help          DCB "*Configure WimpIconBarSpeed sets the initial scrolling speed of the icon bar "
                                DCB "in OS units per second.",cr
WimpIconBarSpeedC_Syntax        DCB "Syntax: *Configure WimpIconBarSpeed <speed>",0
d552 1
a552 3
WimpIconBarAccelerationC_Help   DCB "*Configure WimpIconBarAcceleration sets the acceleration rate of an icon bar scroll "
                                DCB "in OS units per second per second.",cr
WimpIconBarAccelerationC_Syntax DCB "Syntax: *Configure WimpIconBarAcceleration <rate>",0
d554 3
a556 26
        [ IconiseButton
WimpIconiseButtonC_Help         DCB "*Configure WimpIconiseButton sets whether an iconise button is added to "
                                DCB "top-level windows.",cr
WimpIconiseButtonC_Syntax       DCB "Syntax: *Configure WimpIconiseButton On|Off",0
        ]
        [ PoppingIconBar
WimpAutoFrontIconBarC_Help      DCB "*Configure WimpAutoFrontIconBar sets whether the icon bar is brought to the front "
                                DCB "when the pointer is held at the bottom of the screen.",cr
WimpAutoFrontIconBarC_Syntax    DCB "Syntax: *Configure WimpAutoFrontIconBar On|Off",0
        ]
        [ SpritePriority
WimpSpritePrecedenceC_Help      DCB "*Configure WimpSpritePrecedence sets whether ROM sprites have priority over "
                                DCB "RAM sprites or vice versa.",cr
WimpSpritePrecedenceC_Syntax    DCB "Syntax: *Configure WimpSpritePrecedence RAM|ROM",0
        ]
        [ StickyEdges
WimpStickyEdgesC_Help           DCB "*Configure WimpStickyEdges sets whether 'force on screen' directions can be "
                                DCB "overridden by pushing a window 'hard' enough.",cr
WimpStickyEdgesC_Syntax         DCB "Syntax: *Configure WimpStickyEdges On|Off",0
        ]
        [ BounceClose
WimpButtonTypeC_Help            DCB "*Configure WimpButtonType sets whether the back, close, iconise and toggle-size icons "
                                DCB "act when you click on them or when you release the mouse button afterwards.",cr
WimpButtonTypeC_Syntax          DCB "Syntax: *Configure WimpButtonType Click|Release",0
        ]
                        ALIGN
d558 2
a559 3
       |
IconSprites_Help        DCB     "HWNMICS",0
IconSprites_Syntax      DCB     "SWNMICS",0
d561 2
a562 2
Pointer_Help            DCB     "HWNMPTR",0
Pointer_Syntax          DCB     "SWNMPTR",0
d564 1
a564 2
ToolSprites_Help        DCB     "HWNMTSP",0
ToolSprites_Syntax      DCB     "SWNMTSP",0
d566 5
a570 4
WimpFlagsC_Help
        DCB     "HWNMCWF",0
WimpFlagsC_Syntax
        DCB     "SWNMCWF",0
d572 1
a572 4
WimpDragDelayC_Help
        DCB     "HWNMWDD",0
WimpDragDelayC_Syntax
        DCB     "SWNMWDD",0
d574 1
a574 4
WimpFontC_Help
        DCB     "HWNMFON",0
WimpFontC_Syntax
        DCB     "SWNMFON",0
d576 6
a581 4
WimpDragMoveC_Help
        DCB     "HWNMWDM",0
WimpDragMoveC_Syntax
        DCB     "SWNMWDM",0
d583 1
a583 4
WimpDoubleClickDelayC_Help
        DCB     "HWNMDCD",0
WimpDoubleClickDelayC_Syntax
        DCB     "SWNMDCD",0
d585 5
a589 4
WimpDoubleClickMoveC_Help
        DCB     "HWNMDCM",0
WimpDoubleClickMoveC_Syntax
        DCB     "SWNMDCM",0
d591 1
a591 4
WimpAutoMenuDelayC_Help
        DCB     "HWNMAMD",0
WimpAutoMenuDelayC_Syntax
        DCB     "SWNMAMD",0
d593 3
a595 4
WimpMenuDragDelayC_Help
        DCB     "HWNMMDD",0
WimpMenuDragDelayC_Syntax
        DCB     "SWNMMDD",0
d597 11
a607 2
WimpPalette_Help        DCB     "HWNMWP",0
WimpPalette_Syntax      DCB     "SWNMWP",0
d609 8
a616 2
WimpSlot_Help   DCB     "HWNMWS",0
WimpSlot_Syntax DCB     "SWNMWS",0
d618 1
a618 2
WimpTask_Help   DCB     "HWNMWT",0
WimpTask_Syntax DCB     "SWNMWT",0
d620 3
a622 2
Wimp_SetMode_Help   DCB "HWNMWM",0
Wimp_SetMode_Syntax DCB "SWNMWM",0
d624 11
a634 2
WimpWriteDir_Help       DCB "HWNMWWD",0
WimpWriteDir_Syntax     DCB "SWNMWWD",0
a635 2
WimpKillSprite_Help     DCB "HWNMKS",0
WimpKillSprite_Syntax   DCB "SWNMKS",0
d637 7
a643 8
        [ Autoscr
WimpAutoScrollDelayC_Help       DCB "HWNMASD",0
WimpAutoScrollDelayC_Syntax     DCB "SWNMASD",0
        ]
        [ PoppingIconBar
WimpAutoFrontDelayC_Help        DCB "HWNMAFD",0
WimpAutoFrontDelayC_Syntax      DCB "SWNMAFD",0
        ]
d645 2
a646 2
WimpIconBarSpeedC_Help          DCB "HWNMIBS",0
WimpIconBarSpeedC_Syntax        DCB "SWNMIBS",0
d648 7
a654 2
WimpIconBarAccelerationC_Help   DCB "HWNMIBA",0
WimpIconBarAccelerationC_Syntax DCB "SWNMIBA",0
d656 5
a660 21
        [ IconiseButton
WimpIconiseButtonC_Help         DCB "HWNMICB",0
WimpIconiseButtonC_Syntax       DCB "SWNMICB",0
        ]
        [ PoppingIconBar
WimpAutoFrontIconBarC_Help      DCB "HWNMAF",0
WimpAutoFrontIconBarC_Syntax    DCB "SWNMAF",0
        ]
        [ SpritePriority
WimpSpritePrecedenceC_Help      DCB "HWNMSPP",0
WimpSpritePrecedenceC_Syntax    DCB "SWNMSPP",0
        ]
        [ StickyEdges
WimpStickyEdgesC_Help           DCB "HWNMSE",0
WimpStickyEdgesC_Syntax         DCB "SWNMSE",0
        ]
        [ BounceClose
WimpButtonTypeC_Help            DCB "HWNMBT",0
WimpButtonTypeC_Syntax          DCB "SWNMBT",0
        ]
                        ALIGN
d662 1
a662 1
       ]
d664 6
a669 44
Helptable
        Command IconSprites,1,1,International_Help                 ; max/min pars (!)
        Command Pointer,1,0,International_Help
        Command ToolSprites,1,0,International_Help
        Command WimpFlags,1,1,Status_Keyword_Flag:OR:International_Help,WimpFlagsC
        [ Medusa
        Command WimpMode,255,1,International_Help,Wimp_SetMode      ; change name to "*WimpMode"
        |
        Command WimpMode,1,1,International_Help,Wimp_SetMode
        ]
        Command WimpPalette,1,1,International_Help
        Command WimpSlot,6,1,International_Help
        Command WimpTask,255,1,International_Help
        Command WimpWriteDir,1,1 ,International_Help
        Command WimpFont,1,1,Status_Keyword_Flag:OR:International_Help,WimpFontC
        Command WimpDragDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpDragDelayC
        Command WimpDragMove,1,1,Status_Keyword_Flag:OR:International_Help,WimpDragMoveC
        Command WimpDoubleClickDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpDoubleClickDelayC
        Command WimpDoubleClickMove,1,1,Status_Keyword_Flag:OR:International_Help,WimpDoubleClickMoveC
        Command WimpAutoMenuDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoMenuDelayC
        Command WimpMenuDragDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpMenuDragDelayC
        Command WimpKillSprite,1,1,International_Help
        Command WimpIconBarSpeed,1,1,Status_Keyword_Flag:OR:International_Help,WimpIconBarSpeedC
        Command WimpIconBarAcceleration,1,1,Status_Keyword_Flag:OR:International_Help,WimpIconBarAccelerationC
        [ SpritePriority
        Command WimpSpritePrecedence,1,1,Status_Keyword_Flag:OR:International_Help,WimpSpritePrecedenceC
        ]
        [ BounceClose
        Command WimpButtonType,1,1,Status_Keyword_Flag:OR:International_Help,WimpButtonTypeC
        ]
        [ IconiseButton
        Command WimpIconiseButton,1,1,Status_Keyword_Flag:OR:International_Help,WimpIconiseButtonC
        ]
        [ StickyEdges
        Command WimpStickyEdges,1,1,Status_Keyword_Flag:OR:International_Help,WimpStickyEdgesC
        ]
        [ PoppingIconBar
        Command WimpAutoFrontIconBar,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoFrontIconBarC
        Command WimpAutoFrontDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoFrontDelayC
        ]
        [ Autoscr
        Command WimpAutoScrollDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoScrollDelayC
        ]
        DCB     0
d671 5
a675 1
;............................................................................
d678 1
a678 2
WimpWriteDir_Code
        Push    "LR"
d680 1
a680 13
        MOV     R1,R0                   ; R1 -> string form of number
        MOV     R0,#10                  ; R0 = default base
        SWI     XOS_ReadUnsigned
        Pull    "PC",VS
        CMP     R2,#1
        Pull    "PC",GT
        MOV     r0,#-1
        SWI     XTerritory_WriteDirection
        MOVVS   R0,#0
        TST     R0,#1
        SUBNE   R2,R2,#1
        LDR     R12,[R12]               ; get workspace pointer!
        STR     R2,writeabledir
d682 1
a682 1
        Pull    "PC"
d684 11
a694 1
;............................................................................
d696 1
d698 1
a698 2
WimpTask_Code
        Push    "LR"
d700 5
a704 5
        LDR     wsptr,[R12]             ; wsptr -> workspace
        LDR     R14,taskhandle
        LDR     R14,[wsptr,R14]
        TST     R14,#task_unused        ; if already a Wimp task,
        BEQ     %FT01                   ; no need to initialise temporarily
d706 18
a723 4
        MOV     R2,R0                   ; R2 -> parameters
        MOV     R0,#ModHandReason_Enter
        ADRL    R1,Title
        BL     XROS_Module
d725 1
a725 4
        Pull    "PC"                    ; in case it returned!
01
        SWI     XWimp_StartTask         ; R0 --> parameters
        Pull    "PC"
d727 35
a761 2
; must actually enter the module in order to start a task!
; NB: there is no workspace (or stack) here!
d763 3
a765 2
Start
        MOV     R3,R0                   ; R3 -> parameters
d767 2
a768 4
        MOV     R0,#200                 ; initialise temporarily
        LDR     R1,taskid3
        ADR     R2,str_tmp
        SWI     Wimp_Initialise
d770 4
a773 2
        MOV     R0,R3
        SWI     Wimp_StartTask          ; use normal error handler
d775 11
a785 1
        SWI     OS_Exit                 ; also does a closedown
d787 4
a790 18
taskid3 DCB     "TASK"
str_tmp DCB     "<temporary>", 0
        ALIGN

;............................................................................

Wimp_SetMode_Code
        Push    "LR"

        [ true
        Push    "R12"
        LDR     R12,[R12]
        ADRL    R14,greys_mode
        LDRB    R1,[R14]
        STRB    R1,[R14,#1]             ; last time
        MOV     R1,#0
        STRB    R1,[R14]                ; assume not a grey mode at first
        Pull    "R12"
d792 7
a798 6

        MOV     R1,R0                   ; R1 -> string form of number
        MOV     R0,#10                  ; R0 = default base
        SWI     XOS_ReadUnsigned
        [ Medusa
        BVS     setmode_from_specifier
d800 8
a807 1
        Pull    "PC",VS
d810 12
a821 8
        LDR     R12,[R12]               ; get workspace pointer!
        CMP     R2,#255
        BGT     bad_param_exit2
        LDR     R14,currentmode         ; only set the mode if different
        Debug   xx,"*WimpMode: old,new =",R14,R2
        CMP     R2,R14
        MOVNE   R0,R2
        SWINE   XWimp_SetMode
d823 18
a840 1
        Pull    "PC"
d842 24
a865 45
        [ Medusa
setmode_from_specifier
; R1 -> string
        MOV     R0,#-1
        LDR     R12,[R12]
        Push    "R12"
        MOV     R12,SP                  ; R12 not required yet
        Push    "R0"                    ; end of params
        [ DoubleHeightVDU4
	MOV	R3, #VduExt_ModeFlags
	MOV	R4, #1			; get back to this  (it's [R12, #-16])
	MOV	R5, #VduExt_ScrBRow
	MOV	R6, #-1			; get back to this too... ([R12, #-8])
	Push	"R3-R6"
        ]
; use R4-R6 for xres,yres,bpp, R3 frame rate
        MOV     R4,#-1
        MOV     R5,#-1
        MOV     R6,#-1                  ; must specify these
        MOV     R3,#-1
scan_for_param
        LDRB    R0,[R1],#1
        CMP     R0,#32
        BLT     scan_ended
        BEQ     scan_for_param
        CMP     R0,#","
        BEQ     scan_for_param
        UpperCase       R0,R14          ; this is safe
        CMP     R0,#"E"
        BEQ     get_eig_factors
        CMP     R0,#"X"
        BEQ     get_xres
        CMP     R0,#"Y"
        BEQ     get_yres
        CMP     R0,#"C"
        BEQ     get_colours
        CMP     R0,#"G"
        BEQ     get_greys
        CMP     R0,#"F"
        BEQ     get_frame
; oh dear, user error
bad_param_exit
        MOV     SP,R12
        Pull    "R12"
        ]
d867 1
a867 6
bad_param_exit2
;R12 needed by error lookup
        MyXError        BadParameters
        Pull    "PC"
        ; SMC: use international error block as "BadParameters" token did not exist
        MakeInternatErrorBlock  BadParameters,,BadParm
d869 4
a872 23
        [ Medusa
get_eig_factors
        LDRB    R0,[R1],#1
        UpperCase       R0,R14
        CMP     R0,#"X"                  ; only EX EY allowed
        MOVEQ   R0,#VduExt_XEigFactor
        CMP     R0,#"Y"
        MOVEQ   R0,#VduExt_YEigFactor
        CMPNE   R0,#VduExt_XEigFactor
        BNE     bad_param_exit
        Push    "R0"
        MOV     R0,#&2000000a           ; base 10
        MOV     R2,#3                   ; only allow 0-3 (note OS can cope with 4)
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        Pull    "R0"
        Push    "R0,R2"
	[ DoubleHeightVDU4
	TEQ	R0,#VduExt_XEigFactor	; squirrel this away...
	STREQ	R2,[R12,#-16]
	STRNE	R2,[R12,#-8]
	]
        B       scan_for_param
d874 3
a876 7
get_xres
        CMP     R4,#0
        BGE     bad_param_exit                  ; only one x allowed
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R4,R2
        B       scan_for_param
a877 7
get_yres
        CMP     R5,#0
        BGE     bad_param_exit                  ; only one y allowed
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R5,R2
        B       scan_for_param
d879 1
a879 5
get_frame
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R3,R2
        B       scan_for_param
d881 2
a882 39
get_colours
        CMP     R6,#0
        BGE     bad_param_exit                  ; only one C or G allowed
; only 2,4,16,64,256,32T,32K,16M are valid
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        MOV     R0,#-1
        CMP     R2,#2
        MOVEQ   R0,#0                           ; 1bpp
        CMP     R2,#4
        MOVEQ   R0,#1                           ; 2bpp
        CMP     R2,#256
;        MOVEQ   R0,#3                           ; NCol
;        MOVEQ   R2,#255
;        Push    "R0,R2",EQ
        CMPNE   R2,#64
        MOVEQ   R0,#3                           ; 8bpp
        CMP     R0,#0
        MOVGE   R6,R0
        BGE     scan_for_param
        LDRB    R0,[R1]
        UpperCase       R0,R14
        CMP     R2,#16
        BNE     %FT05
        CMP     R0,#"M"
        ADDEQ   R1,R1,#1
        MOVEQ   R6,#5                           ; 32bpp (16M)
        MOVNE   R6,#2                           ; 4bpp  (16)
        B       scan_for_param
5
        CMP     R2,#32
        BNE     bad_param_exit
        ; must be either T or K
        CMP     R0,#"T"
        CMPNE   R0,#"K"
        BNE     bad_param_exit
        ADD     R1,R1,#1                        ; move it along
        MOV     R6,#4                           ; 16bpp
        B       scan_for_param
d884 11
a894 23
get_greys
        CMP     R6,#0
        BGE     bad_param_exit                  ; only one C or G allowed
        SWI     XOS_ReadUnsigned
        BVS     bad_param_exit
        CMP     R2,#16
        MOV     R6,#3+128                         ; 8bpp (+128 makes the palette get hit later)
        MOVEQ   R6,#2+128                         ; 4bpp
        CMPNE   R2,#256
        CMPNE   R2,#4
        CMPNE   R2,#2
        BNE     bad_param_exit
        CMP     R2,#4
        MOVEQ   R6,#1
        CMP     R2,#2
        MOVEQ   R6,#0                             ; no palette munging so not +128
        CMP     R2,#256
        MOVEQ   R0,#3                           ; NCol
        MOVEQ   R2,#255
        Push    "R0,R2",EQ                      ; must be set for 256 greys
        MOVEQ   R0,#0                           ; ModeFlags
        MOVEQ   R2,#128
        Push    "R0,R2",EQ                      ; must be set for 256 greys
d896 8
a903 1
        B       scan_for_param
d905 11
a915 13
scan_ended
        CMP     R4,#-1
        CMPNE   R5,#-1
        CMPNE   R6,#-1
        BEQ     bad_param_exit          ; all must be supplied
        Push    "R3"                    ; frame rate
        TST     R6,#128
        BICNE   R6,R6,#128              ; greys required
        Push    "R4-R6"                 ; xres, yres bpp
        ORRNE   R6,R6,#128
        MOVEQ   R6,#0
        MOV     R0,#1                   ; mode selector flags
        Push    "R0"
d917 6
a922 27
	[ DoubleHeightVDU4
	; Need to establish what XEigFactor and YEigFactor are
	LDR	R0,[R12,#-8]
	CMP	R0,#-1
	BNE	%FT01
	CMP	R5, R4, LSR #1		; is yres >= xres/2?
	MOVHS	R0,#1
	MOVLO	R0,#2
01	LDR	R14,[R12,#-16]
	; is yeig(R0) > xeig(R14), don't double height
	CMP	R0,R14
	MOVHI	R0,#0
	MOVHI	R14,R5,LSR #3
	MOVLS	R0,#Flag_DoubleVertical
	MOVLS	R14,R5,LSR #4
	SUB	R14,R14,#1
	STR	R0,[R12,#-16]		; store the mode flags
	STR	R14,[R12,#-8]		; store the text height
	]
        MOV     R0,SP
        Push    R12
        LDR     R12,[R12]               ; the R12 that was saved on the stack
        ADRL    R14,greys_mode
        STRB    R6,[R14]
        SWI     XWimp_SetMode           ; may update greys_mode
        Pull    R12,VS                  ; SMC: only pull R12 if VS, need R12=wsptr to load greys_mode below
        BVS     exit_setmode
d924 15
a938 5
        ADRL    R14,greys_mode          ; SMC: get possibly updated greys_mode
        LDRB    R6,[R14]
        TST     R6,#128
        Pull    R12                     ; SMC: get back R12->old top of stack
        BEQ     exit_setmode
d940 12
a951 3
        MOV     SP,R12
        NOP
        Pull    "R12"
d953 2
a954 17
        BL      recalc_greys_palette
; palette changed so send message
        SWI       XColourTrans_InvalidateCache
        [ false
; as we haven't done the wimp palette, no need
        MOV     R14,#ms_data            ; size of block
        STR     R14,[sp,#-ms_data]!
        MOV     R0,#User_Message
        MOV     R1,sp
        MOV     R2,#0
        STR     R2,[R1,#ms_yourref]
        MOV     R14,#Message_PaletteChange
        STR     R14,[R1,#ms_action]
        SWI     XWimp_SendMessage
        ADD     sp,sp,#ms_data          ; correct stack
        ]
        Pull    "PC"
d956 7
a962 26
recalc_greys_palette
        Push    "R0-R9,lr"
        ADRL    R14,greys_mode
        LDRB    R6,[R14]
        TEQ     R6,#128+3
        BEQ     set_greys256
        [ false
set_grey_palette
        ; must splat the palette for the grey scales
        SUB     SP,SP,#80
        MOV     R1,SP
        SWI     XWimp_ReadPalette
        ; preserves border and pointer colours
        MOV     R0,#8
        ADD     R1,R1,#32               ; jump first 8 colours
        ADR     R2,greys_16
5
        LDR     R14,[R2],#4
        STR     R14,[R1],#4
        SUBS    R0,R0,#1
        BNE     %BT5
        MOV     R1,SP
        SWI     XWimp_SetPalette
        |
        ; must set palette directly
set_grey_palette
d964 1
a964 16
        Push    "R9"
        MOV     R9,#&23                 ; PaletteV
        MOV     R0,#8                   ; start at colour 8
        MOV     R1,#16
        MOV     R4,#2                   ; set palette, R4 becomes zero on return
5
        Push    "R0-R5,R9"
        ADR     R2,greys_16
        SUB     R2,R2,#32
        LDR     R2,[R2,R0, LSL #2]
        MOV     R3,R2
        SWI     XOS_CallAVector
        Pull    "R0-R5,R9"
        Pull    "R9",VS
        BVS     exit_setmodegreys
        ADD     R0,R0,#1
d966 2
a967 4
        CMP     R0,#16
        BNE     %BT5
        Pull    "R9"
        ]
d969 4
a972 2
exit_setmodegreys
        Pull    "R0-R9,PC"
d974 1
d976 8
d985 12
a996 3
exit_setmode
        MOV     SP,R12
        Pull    "R12,PC"
d998 7
a1004 23
set_greys256
        ; must set palette directly
        Push    "R9"
        MOV     R9,#&23                 ; PaletteV
        MOV     R0,#0
        MOV     R1,#16
        MOV     R2,#0
        MOV     R3,R2
        LDR     R5,=&01010100
        MOV     R4,#2                   ; set palette, R4 becomes zero on return
5
        Push    "R0-R5,R9"
        SWI     XOS_CallAVector
        Pull    "R0-R5,R9"
        Pull    "R9",VS
        BVS     exit_setmode
        ADD     R0,R0,#1
        ADD     R2,R2,R5
        MOV     R3,R2
        CLRV                            ; clear overflow for R0>127
        CMP     R0,#256
        BNE     %BT5
        Pull    "R9"
d1006 3
a1008 3
        [ false
        B       set_grey_palette         ; update wimp palette
        ]
d1010 11
a1020 16
        [ false
; now set wimp palette with first 16 colours (! is this logical captain?)
        SUB     SP,SP,#80
        MOV     R1,SP
        SWI     XWimp_ReadPalette
        ; preserves border and pointer colours
        MOV     R0,#16
        LDR     R2,=&01010100
        MOV     R3,#0
5
        STR     R3,[R1],#4
        ADD     R3,R3,R2
        SUBS    R0,R0,#1
        BNE     %BT5
        MOV     R1,SP
        SWI     XWimp_SetPalette
d1022 12
a1033 1
        ]
d1035 6
a1040 1
        B       exit_setmodegreys
d1042 3
d1046 7
a1052 4
greys_16
        DCD     &10101000,&c0c0c000,&60606000,&20202000
        DCD     &e0e0e000,&40404000,&a0a0a000,&80808000
        ]
d1054 5
a1058 1
;----------------------------------------------------------------------------
d1060 3
a1062 6
; *IconSprites <filename>
; In:   R0 -> parameters
;       R1 = number of parameters (1)
; Out:  R0-R3 corrupted (OS_CLI restores them)
; call Wimp_SpriteOp (11 = merge) to add sprites to the common sprite area
; tries "<filename>23" if hi-res mono, and/or "<filename>22" if 2x2 OS units
d1064 10
a1073 15
IconSprites_Code
        Push    "R12,LR"
        LDR     wsptr,[R12]
;
        MOV     R1,R0
        MOV     R3,R0                   ; R3 -> original filename
        BL      getspritefname          ; R1 -> <filename><x><y><bpp>
        MOV     R2,R1                   ; R2 -> filename
;
        MOV     R0,#SpriteReason_MergeSpriteFile
        SWI     XWimp_SpriteOp
        MOVVS   R2,R3                   ; R2 -> original filename
        MOVVS   R0,#SpriteReason_MergeSpriteFile
        SWIVS   XWimp_SpriteOp
        BVS     %FT05
d1075 4
a1078 4
        [ windowsprite
        MOV     R0,#-1
        STR     R0,tiling_sprite
        ]
d1080 2
a1081 14
        [ false
        MOV     R14,#ms_data            ; message block size
        STR     R14,[sp,#-ms_data]!
        MOV     R14,#0                  ; your_ref
        STR     R14,[sp,#ms_yourref]
        LDR     R14,=Message_IconsChanged
        STR     R14,[sp,#ms_action]
        MOV     R0,#User_Message
        MOV     R1,sp
        MOV     R2,#0                   ; broadcast message
        BL      int_sendmessage_fromwimp
        ADD     sp,sp,#ms_data
        CLRV                            ; ignore errors
        ]
d1083 3
a1085 19
      [ Medusa
        Pull    "R12,PC"                ; Medusa uses DA
      |
; this merge bumps the RMA up, compress it again just in case.
        MOV     R0,#1
        MOV     R1,#-&10000000           ; try and shrink RMA
        SWI     XOS_ChangeDynamicArea
        CLRV                            ; may cause an error, but ok.
        Pull    "R12,PC"
      ]
05
        Push    "R0"
        [ true                          ; don't send error back
        LDR     R0,[R0]
        LDR     R14,=ErrorNumber_WimpBadSprites
        TEQ     R0,R14                   ; not really an error!
        CLRV    EQ
        ]
        Pull    "R0,R12,PC"
d1087 7
a1093 1
;............................................................................
a1094 4
; In    R1 -> sprite filename
;       [romspr_suffix..] = suffix to add to filename
; Out   R1 -> <filename><suffix> (in watchdog errorbuffer)
;       R2 -> start of suffix as added to filename
d1096 2
a1097 2
getspritefname
        Push    "R0,LR"
d1099 3
a1101 8
      [ false
        ADRL    R2,watchdogerrtxt       ; changed from errorbuffer to fix nager:sprites occurring cos
                                        ; this was writing over the errorblock before it was presented
                                        ; to the user
      |
        ADRL    R2, path_buffer         ; watchdogerrtxt isn't big enough for long pathnames, and was getting
                                        ; overwritten by the new Service_SwitchingOutputToSprite handler
      ]
d1103 4
a1106 7
01      LDRB    R14,[R1],#1             ; skip leading spaces
        CMP     R14,#" "
        BEQ     %BT01
02      CMP     R14,#32                 ; stop on space or ctrl-char
        STRHIB  R14,[R2],#1
        LDRHIB  R14,[R1],#1
        BHI     %BT02
d1108 1
a1108 9
        ADR     R0,romspr_suffix
        MOV     R1,R2
        BL      copy0                   ; copy from R0 to R1
      [ false
        ADRL    R1,watchdogerrtxt
      |
        ADRL    R1, path_buffer
      ]
        DebugS  xx,"getspritefname: ",R1
d1110 1
a1110 1
        Pull    "R0,PC",,^
d1112 3
a1114 1
;............................................................................
d1116 3
a1118 5
; Entry:  R0 = sprite reason code
;         all other regs except R1 set up as normal for OS_SpriteOp
; Exit:   operation performed on RAM / ROM sprite areas
; Error:  "Bad parameter passed to Wimp in R0" if attempt to write to sprites
;
d1120 7
a1126 2
SWIWimp_SpriteOp
;        MyEntry "SpriteOp"
d1128 1
a1128 16
        AND     R0,R0,#&FF              ; just in case!
        TEQ     R0,#SpriteReason_MergeSpriteFile
        BEQ     %FT01
        TEQ     R0,#SpriteReason_SetPointerShape
        BEQ     %FT02
        TEQ     R0,#99                  ; fast find
        BEQ     dospriteop
        CMP     R0,#SpriteReason_BadReasonCode
        BGE     err_badR0
;
        ADR     R1,spritebits           ; disallow all other write operations
        MOV     R14,R0,LSR #5
        LDR     R1,[R1,R14,LSL #2]
        AND     R14,R0,#31
        MOVS    R1,R1,LSL R14           ; top bit is now set/unset accordingly
        BMI     err_badR0
d1130 2
a1131 26
dospriteop
        MOV     R1,#1
        STR     R1,thisCBptr
        STR     R1,lengthflags
        STR     R2,spritename
        LDR     R1,list_at
        TEQ     R1,#0
        BEQ     dospriteopnext          ; no list yet.
        TEQ     R0,#36                  ; set pointer shape
        BEQ     dospriteopnext
        Push    "R2"                    ; needs preserving
        BL      getspriteaddr
        STRVC   R2,spritename
        Pull    "R2"
        MOVVC   R1,#0
        STRVC   R1,lengthflags          ; use pointer
        BVS     sprite_not_found
        TEQ     R0,#99                  ; fast sprite existence
        BEQ     ExitWimp
dospriteopnext
        TEQ     R0,#99
        MOVEQ   R0,#40                  ; read info
        MOV     R1,#1                   ; incase daft routines expect it
        BL      wimp_SpriteOp
        STMIA   sp, {R1-R10}            ; return correct results to caller
        B       ExitWimp
d1133 4
a1136 2
01      BL      int_merge_sprites
        B       ExitWimp
d1138 3
a1140 6
02      TST     R3,#1:SHL:5             ; is it trying to set up the palette?
        MOVEQ   R3,#1                   ; don't program the border colour
        BLEQ    setmousepalette         ; palette defaults to central version
        MOV     R0,#SpriteReason_SetPointerShape
        LDMIA   sp,{R1-R7}
        B       dospriteop
d1142 1
a1142 4
spritebits   ;    0       8      16      24     31
        DCD     2_11100000011000111000000001110111
        DCD     2_11010000001011110000001001101100
        ASSERT  SpriteReason_BadReasonCode < 64
d1144 3
a1146 4
sprite_not_found
        ADR     R0,SpriteDoesntExist
        BL      ErrorLookup
        B       ExitWimp
d1148 7
a1154 4
SpriteDoesntExist
        DCD     134
        DCB     "BadSprite",0
        ALIGN
d1156 1
d1158 2
a1159 1
;............................................................................
d1161 1
a1161 3
; Entry:  R2 --> sprite file name
;         [baseofsprites] = current RAM sprite area pointer
; Exit:   [baseofsprites] = new RAM sprite area pointer (area extended)
d1163 9
a1171 4
int_merge_sprites
        Push    "R1-R5,LR"              ; R2 on stack = filename ptr
;
        DebugS  spr,"File name is ",r2
d1173 2
a1174 14
        MOV     R1,R2
        MOV     R0,#OSFile_ReadInfo
        SWI     XOS_File                ; R4 = file length
        Debug   spr,"File size is ",r4
        Debug   spr,"Object type is ",r0
        TEQ     R0,#1                   ; must be a file (NB doesn't affect V)
        BNE     %FT99                   ; bound not to work!
        MOV     R2,R2,LSL # 12
        MOV     R2,R2,LSR # 20
        LDR     R14,=&fca                ; squashed!
        TEQ     R2,R14
        BEQ     %FT99
;
        LDR     R2,baseofsprites
d1176 1
a1176 12
        MOVVC   R0,#ModHandReason_ExtendBlock
        MOVVC   R3,R4                   ; extend by enough to cover new file
        BLVC    allocatespritememory
        STRVC   R2,baseofsprites        ; do this now just in case !!!
      [ SpritePriority
        BVS     %FT06
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseofhisprites
        STRNE   R2, baseoflosprites
06
      ]
d1178 12
a1189 10
        DebugE  spr,"Extending sprite block"
      [ debugspr
        BVS     %FT55
        Debug   spr,"baseofsprites (1)  ",r2
55
      ]
;
        LDRVC   R14,[R2,#saEnd]
        ADDVC   R14,R14,R3
        STRVC   R14,[R2,#saEnd]
d1191 1
a1191 22
        [ debugnk
        ADD     R1,R14,R2
        SUB     R1,R1,#4
        Debug   nk,"End of sprite area",R1
        LDR     R0,[R1]
        STR     R0,[R1]
        MOV     R0,R1
        SWI     XOS_ValidateAddress
        BCC     %FT01
        Debug   nk,"Oh dear ",R1
        ]
01
        MOVVC   R1,R2
        LDRVC   R2,[sp,#1*4]            ; R2 --> file name
        MOVVC   R0,#SpriteReason_MergeSpriteFile
        ADDVC   R0,R0,#&100
      [ debugspr
        BVS     %FT55
        Debug   spr,"(1) r0 r1 r2  ",r0,r1,r2
55
      ]
        SWIVC   XOS_SpriteOp
d1193 2
a1194 37
        Debug   nk,"Returned from merge ",R0
;
        LDRVC   R14,[R1,#saFree]        ; compact area down now
        LDRVC   R0,[R1,#saEnd]
        STRVC   R14,[R1,#saEnd]
        SUBVC   R3,R14,R0               ; R3 = amount to change size by
        LDRVC   R2,baseofsprites
      [ debugspr
        BVS     %FT55
        Debug   spr,"(2) r0 r1 r14 r2  ",r0,r1,r14,r2
55
      ]
        MOVVC   R0,#ModHandReason_ExtendBlock
        BLVC    allocatespritememory
        STRVC   R2,baseofsprites
      [ SpritePriority
        BVS     %FT06
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseofhisprites
        STRNE   R2, baseoflosprites
06
      ]
      [ debugspr
        BVS     %FT55
        Debug   spr,"baseofsprites (2)  ",r2
55
      ]
;
        MOVVC   R1,#Service_WimpSpritesMoved
        LDRVC   R2,baseofromsprites     ; R2 -> ROM area
        LDRVC   R3,baseofsprites        ; R3 -> RAM area
        SWIVC   XOS_ServiceCall
;
        BLVC    freelist                ; mark sprite cache list as invalid
;
        Pull    "R1-R5,PC"
d1196 2
a1197 3
99
        MyXError        WimpBadSprites
        Pull    "R1-R5,PC"
d1199 2
a1200 1
  MakeErrorBlock  WimpBadSprites
d1202 1
a1202 1
;............................................................................
d1204 1
a1204 2
; Exit:  R0 --> common sprite area (ROM)
;        R1 --> common sprite area (RAM)
d1206 7
a1212 2
SWIWimp_BaseOfSprites
;        MyEntry "BaseOfSprites"
d1214 1
a1214 4
        LDR     R0,baseofromsprites
        LDR     R1,baseofsprites
        STR     R1,[sp,#0*4]            ; overwrite stacked value
        B       ExitWimp
d1216 6
d1223 5
a1227 3
;-----------------------------------------------------------------------------
; Initialisation - claim work area
;-----------------------------------------------------------------------------
d1229 2
a1230 4
WimpPath        DCB     "WindowManager$Path", 0
ResourcesColon  DCB     "Resources:$.Resources.Wimp."
                DCB     0
                ALIGN
d1232 2
a1233 2
Init
        Push    "R0-R12,LR"
d1235 1
a1235 1
; open debugging file
d1237 7
a1243 3
      [ debug :LAND: :LNOT: hostvdu :LAND: :LNOT: pdebug_module
        Debug_Open "<Wimp$Debug>1"
      ]
d1245 7
a1251 1
; initialise Wimp$Path if not already done
d1253 2
a1254 6
        ADR     R0, WimpPath
        MOV     R2, #-1
        MOV     R3, #0
        MOV     R4,#0      ; Do not expand, to bypass a bug in OS_ReadVarVal
        SWI     XOS_ReadVarVal          ; returns R2=0 if doesn't exist
        CMP     R2, #0                  ; clears V as well!
d1256 3
a1258 8
        ADREQ   R0, WimpPath
        ADREQ   R1, ResourcesColon         ; set variable to "Resources:Resources."
        MOVEQ   R2, #?ResourcesColon
        MOVEQ   R3, #0
        MOVEQ   R4, #VarType_String
        SWIEQ   XOS_SetVarVal
        BVS     exitinit1
;
d1260 4
a1263 1
; claim workspace
d1265 1
a1265 9
        LDR     R2,[R12]                ; load from private word
        CMP     R2,#0
        BNE     gotwork                 ; no need to reclaim block
;
        LDR     R3,=maxwork
        MOV     R0,#ModHandReason_Claim
        SWI     XOS_Module
        BVS     errcantclaim
        STR     R2,[R12]
d1267 9
a1275 4
; need to claim save area for when something else (eg. font manager) switches
; output.
        Push    "R0-R3"
        MOV     wsptr,R2
d1277 3
a1279 7
        [ DebugMemory
        ADRL    R0,memory_claims
        MOV     R2,#-1
        STR     R2,[R0,#4]
        STR     R2,[R0]
        MOV     R2,#0
        STRB    R2,reentrancyflag
d1281 1
a1281 1
        ]
d1283 14
a1296 11
        MOV     R0,#62
        MOV     R2,#0
        SWI     XOS_SpriteOp                    ; get size of area
        MOVVC   R0,#ModHandReason_Claim
        BLVC    XROS_Module
        MOVVC   R0,#0
        STRVC   R0,[R2]
        MOVVS   R2,#0
        ADRL    R14,save_context
        STR     R2,[R14]
        Pull    "R0-R3"
d1298 1
a1298 2
gotwork
        MOV     wsptr,R2
d1300 4
a1303 23
        MOV     R1, #0
        STR     R1, messages            ; no messsages open, in case of error lookups
;
        BL      initptrs                ; also claims ChangeEnvironmentV
;
        SWI     XOS_ReadMemMapInfo      ; R0 = page size, R1 = number of pages
        MOV     R1,#640*1024
        DivRem  R2,R1,R0,R14            ; R2 = number of pages for 640k
        STR     R2,slotsize
;
 [ DontCheckModeOnInit
        MOV     r0, #-1
        STR     r0, currentmode
 |
        MOV     R0,#1                   ; Read configured mode
        SWI     XOS_ReadSysInfo
        BLVC    validatemode            ; error if non-graphics mode
        MOVVS   R0,#27
        [ Medusa
        BL      copy_mode_specifier     ; just in case configured mode
                                        ; is new style.
        ]
        STR     R0,currentmode          ; altered by Wimp_SetMode
d1305 30
a1334 23
;
        ; Read WimpFlags
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpFlagsCMOS
        SWI     XOS_Byte
        MOVVS   R2,#0
        STRB    R2,sysflags
;
        ; Read WimpDragDelay
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpDragTimeCMOS
        SWI     XOS_Byte
        [ false
        EORVC   R0,R2,#default_drag_timelimit
        |
        ANDVC   R3, R2, #&0F
        EORVC   R3, R3, #default_drag_timelimit
        MOVVC   R1, #WimpDragMoveLimitCMOS
        SWIVC   XOS_Byte
        ANDVC   R4, R2, #1 :SHL: 0
        MOVVC   R0, R3, LSL R4
        TEQ     R4, #0 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
d1336 1
a1336 11
        MOVVS   R0,#default_drag_timelimit
        ADD     R0,R0,R0,ASL #2        ; R0*5
        MOV     R0,R0,ASL #1           ; R0*10
        STR     R0,drag_timelimit
;
        ; Read WimpDoubleClickDelay
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpDoubleClickTimeCMOS
        SWI     XOS_Byte
        [ false
        EORVC   R0,R2,#default_doubleclick_timelimit
d1338 2
a1339 8
        ANDVC   R3, R2, #&0F
        EORVC   R3, R3, #default_doubleclick_timelimit
        MOVVC   R1, #WimpDoubleClickMoveLimitCMOS
        SWIVC   XOS_Byte
        ANDVC   R4, R2, #1 :SHL: 0
        MOVVC   R0, R3, LSL R4
        TEQ     R4, #0 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
d1341 11
a1351 11
        MOVVS   R0,#default_doubleclick_timelimit
        ADD     R0,R0,R0,ASL #2        ; R0*5
        MOV     R0,R0,ASL #1           ; R0*10
        STR     R0,doubleclick_timelimit
;
        ; Read WimpDragMove
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpDragMoveLimitCMOS
        SWI     XOS_Byte
        [ true
        ANDVC   R2, R2, #&7C
d1353 23
a1375 10
        EORVC   R0,R2,#default_drag_movelimit
        MOVVS   R0,#default_drag_movelimit
        STRB    R0,drag_movelimit
;
        ; Read WimpDoubleClickMove
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpDoubleClickMoveLimitCMOS
        SWI     XOS_Byte
        [ true
        ANDVC   R2, R2, #&7C
d1377 49
a1425 21
        EORVC   R0,R2,#default_doubleclick_movelimit
        MOVVS   R0,#default_doubleclick_movelimit
        STRB    R0,doubleclick_movelimit
;
        ; Read WimpAutoMenuDelay
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpAutoSubMenuTimeCMOS
        SWI     XOS_Byte
        [ false
        MOVVS   R0,#0
        ADDVC   R0,R2,R2,ASL #2        ; R0*5
        MOVVC   R0,R0,ASL #1           ; R0*10
        |
        ANDVC   R0, R2, #&0F
        EORVC   R0, R0, #default_automenudelay
        TST     R2, #1 :SHL: 4 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        MOVNE   R0, R0, LSL #1
        MOVVS   R0, #default_automenudelay
        ADD     R0, R0, R0, LSL #2
        MOV     R0, R0, LSL #1
a1426 230
        STR     R0,automenu_timelimit
;
        ; Read WimpMenuDragDelay
        MOV     R0,#ReadCMOS
        MOV     R1,#WimpMenuDragDelayCMOS
        SWI     XOS_Byte
        [ false
        MOVVS   R0,#0
        ADDVC   R0,R2,R2,ASL #2        ; R0*5
        MOVVC   R0,R0,ASL #1           ; R0*10
        |
        ANDVC   R0, R2, #&0F
        EORVC   R0, R0, #default_menudragdelay
        TST     R2, #1 :SHL: 4 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        MOVNE   R0, R0, LSL #1
        MOVVS   R0, #default_menudragdelay
        ADD     R0, R0, R0, LSL #2
        MOV     R0, R0, LSL #1
        ]
        STR     R0,menudragdelay
;
        ; Read WimpIconBarSpeed
        ADR     R3, iconbarlogtable
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpAutoSubMenuTimeCMOS
        SWI     XOS_Byte
        MOVVC   R2, R2, LSR #5
        EORVC   R2, r2, #default_iconbarspeed
        MOVVS   R2, #default_iconbarspeed
        LDR     R0, [R3, R2, LSL#2]
        STR     R0, iconbar_scroll_speed
;
        ; Read WimpIconBarAcceleration
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpMenuDragDelayCMOS
        SWI     XOS_Byte
        MOVVC   R2, R2, LSR #5
        EORVC   R2, r2, #default_iconbaraccel
        MOVVS   R2, #default_iconbaraccel
        LDR     R0, [R3, R2, LSL#2]
        STR     R0, iconbar_scroll_accel
;
        ; Read WimpSpritePrecedence
      [ SpritePriority
        MOV     R0, #ReadCMOS
        MOV     R1, #DesktopFeaturesCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 5 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STR     R0, preferredpool
      ]
;
        ; ReadWimpButtonType
      [ BounceClose
        MOV     R0, #ReadCMOS
        MOV     R1, #DesktopFeaturesCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 6 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, buttontype
      ]
;
        ; Read WimpIconiseButton
      [ IconiseButton
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDragMoveLimitCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 7 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, iconisebutton
      ]
;
        ; ReadWimpStickyEdges
      [ StickyEdges
        MOV     R0, #ReadCMOS
        MOV     R1, #DesktopFeaturesCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 6 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, stickyedges
      ]
;
        ; Read WimpAutoFrontIconBar
      [ PoppingIconBar
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDoubleClickMoveLimitCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 7 ;preserves V
        MOVEQ   R0, #1
        MOVNE   R0, #0
        MOVVS   R0, #1
        STRB    R0, popiconbar
;
        ; Read WimpAutoFrontDelay
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDoubleClickTimeCMOS
        SWI     XOS_Byte
        MOVVC   R3, R2, LSR #4
        EORVC   R3, R3, #default_autofrontdelay
        MOVVC   R1, #WimpDoubleClickMoveLimitCMOS
        SWIVC   XOS_Byte
        TST     R2, #1 :SHL: 1 ;preserves V
        MOVEQ   R0, R3
        MOVNE   R0, R3, LSL #1
        ADDNE   R0, R0, R0, LSL #2
        MOVVS   R0, #default_autofrontdelay
        ADD     R0, R0, R0, LSL #2
        MOV     R0, R0, LSL #1
        STR     R0, popiconbar_pause
      ]
;
        ; Read WimpAutoScrollDelay
      [ Autoscr
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDragTimeCMOS
        SWI     XOS_Byte
        MOVVC   R3, R2, LSR #4
        EORVC   R3, R3, #default_autoscrolldelay
        MOVVC   R1, #WimpDragMoveLimitCMOS
        SWIVC   XOS_Byte
        TST     R2, #1 :SHL: 1 ;preserves V
        MOVEQ   R0, R3
        MOVNE   R0, R3, LSL #1
        ADDNE   R0, R0, R0, LSL #2
        MOVVS   R0, #default_autofrontdelay
        STRB    R0, autoscr_default_pause ; not *10
      ]
;
        ADRL    R14,paltable            ; initialise palette
        ADR     R11,emergencypalette
        LDMIA   R11!,{R1-R10}
        STMIA   R14!,{R1-R10}
        LDMIA   R11,{R1-R10}
        STMIA   R14,{R1-R10}
;
        BL      initphyspalmap          ; initialise bits for colour mappings
;
        MOV     R0,#ModHandReason_Claim
        MOV     R3,#SpriteAreaCBsize    ; 16, I believe!
        BL      allocatespritememory
        MOVVS   R2,#nullptr
        STR     R2,baseofsprites        ; NB this is null if error occurs
      [ SpritePriority
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseofhisprites
        STRNE   R2, baseoflosprites
      ]
        STRVC   R3,[R2,#saEnd]
        STRVC   R3,[R2,#saFirst]
        STRVC   R3,[R2,#saFree]
        MOVVC   R14,#0                  ; no sprites defined
        STRVC   R14,[R2,#saNumber]
;
        ADRVC   R0,str_wimpcom
        ADRVC   R1,CommandWindow_var
        MOVVC   R2,#CommandWindow_varsize
        MOVVC   R3,#0
        MOVVC   R4,#VarType_Code
        SWIVC   XOS_SetVarVal
;
        BL      defaultfilters          ; reset the filter handlers + broadcast service
;
        MOV     R0,#0
        STR     R0,automenu_inactivetimeout
;
        STR     R0,pixtable_at          ; no pixel translation table
        STR     R0,pixtable_size
        STRB    R0,preservett           ; don't mind losing it on an invalidate cache service call
        STR     R0,list_at
        STR     R0,list_size            ; mark to indicate now list present
        STR     R0,filehandle
        STR     R0,fileaddress          ; reset the file address / handle (faults on template load!)
        STR     R0,tool_list
        STR     R0,tool_area
        STR     R0,tool_transtable      ; no tool sprites / tool sprites list
        STRB    R0,errorbox_open        ; the error box is not displayed
        STRB    R0,iconbar_needs_rs     ; check iconbar icon sizes
        [ NewErrorSystem
        STR     R0,watchdogcodew
        ]
        ADRL    R14,tools_area
        STR     R0,[R14]
;        ADRL    R14,wimpmodebefore
;        STR     R0,[R14]
        ADRL    R14,greys_mode
        STR     R0,[R14]                ; splats misc
        [ NewErrorSystem
        STR     R0,watchdogarea         ; 'watchdog' isn't active
        ]
        [ StretchErrorText
        STR     R0,linecount
        ]
        STR     R0,wimpswiintercept
        STR     R0,plotsprCB
	[ PoppingIconBar
	STR	R0,iconbar_pop_state
	]
        [ TrueIcon3
        MOV     R0, #1:SHL:2
        STRB    R0, tinted_enable
        MOV     R0, #0
        STRB    R0, tinted_window
        STRB    R0, tinted_tool
        ]
        [ windowsprite
        MOV     R0,#-1
        STR     R0,tiling_sprite        ; no tile sprite
        MOV     R0,#0
        STR     R0,tile_pixtable
        ]
;
        BL      freetoolarea            ; tidy the tool area
;
        BL      declareresourcefsfiles  ; trap service call to pick them up
        BL      recalcmodevars
;
exitinit1
        STRVS   R0,[sp]                 ; bodge stack if error
        Pull    "R0-R12,PC"
        LTORG
d1428 3
a1430 2
errcantclaim
        MyXError WimpNoClaim
d1432 1
a1432 3
        STR     R0,[sp]                ; bodge stack on error
        Pull    "R0-R12,PC"
        MakeErrorBlock  WimpNoClaim
d1434 1
a1434 2
iconbarlogtable
        DCD     0, 20, 50, 100, 200, 500, 1000, 2000, -1
a1435 1
;.................................................................................
d1437 9
a1445 2
; Declare resource files to ResourceFS
; This causes a Service_ResourceFSStarted, which is then trapped
d1447 4
a1450 1
fontinstall = "%FontInstall", 0
d1452 1
a1452 2
declareresourcefsfiles
        Push    "R0,LR"
d1454 18
a1471 5
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_RegisterFiles   ; ignore errors
        ADR     R0, fontinstall
        SWI     XOS_CLI                     ; ensure WIMPSymbol has been seen
        BL      getromsprites
a1472 1
        Pull    "R0,PC",,^
d1474 1
a1475 5
;.................................................................................
;
; Entry:  R3 = amount of memory to claim
; Exit:   R2 --> new block
;         bodgeblk is thrown away if present.
d1477 3
a1479 6
claimblock
        Push    "LR"
        MOV     R0,#ModHandReason_Claim
        BL     XROS_Module
        DebugE  rma,"Claim failed:"
        Pull    "PC"
d1481 1
a1481 5
claim
        Push    "LR"
        BL      release                 ; also sets R2 = wsptr
        SWI     XOS_Claim
        Pull    "PC"
d1483 4
a1486 7
release
        Push    "R0-R1,LR"
01
        MOV     R2,wsptr
        SWI     XOS_Release             ; release until bored
        BVC     %BT01
        Pull    "R0-R1,PC",,^
d1488 5
a1492 1
;.................................................................................
d1494 7
a1500 2
str_wimpcom     DCB     "Wimp$State", 0
                ALIGN
d1502 8
a1509 2
emergencypalette
        GET     s.!Palette
d1511 1
a1511 1
;.................................................................................
d1513 4
a1516 5
Die
        Push    "R0-R3,R12,LR"
        LDR     wsptr,[R12]
;
        LDR     R14,taskcount
d1518 1
a1518 1
        Debug   die,"WimpDie: taskcount",R14
d1520 2
a1521 6
        TEQ     R14,#0                  ; Any tasks?
        MyXError WimpCantKill,NE        ; Yes then error
        ADDVS   SP,SP,#4                ; And drop R0
        Pull    "R1-R3,R12,PC",VS
;
        Debug   die,"Deregister resources"
d1523 1
a1523 5
        ADRL    R0,resourcefsfiles
        SWI     XResourceFS_DeregisterFiles ; ignore errors
;
        BL      deallocateptrs          ; doesn't deallocate sprites
                                        ; does deallocate ALL windows
d1525 4
a1528 3
    [ :LNOT: KernelLocksFreePool
        BL      resetdynamic
    ]
d1530 6
a1535 26
;
        MOV     R0,#ModHandReason_Free
        LDR     R2,baseofsprites
        BL      allocatespritememory         ; release the RAM sprite pool
;
        BL      freetoolarea
;
; Don't try freeing the command and error windows, its already happened.
;
        MOV     R0,#ChangeEnvironmentV
        ADRL    R1,ChangeEnvCode
        BL      release
;
        ADR     R0,str_wimpcom
        ADR     R1,CommandWindow_var
        MOV     R2,#-1
        MOV     R3,#0
        MOV     R4,#VarType_Code        ; must use this to destroy code vars
        SWI     XOS_SetVarVal
;
        BL      LoseMessages            ; just incase messages still open (unlikely)
;
        ADRL    R0,svc_callback
        MOV     R1,WsPtr
        SWI     XOS_RemoveCallBack      ; remove possible callback routine (may have been granted!)
;
d1537 1
a1537 1
        Debug   opn,"---- Debug closing down ----"
d1539 1
a1539 1
        Debug_Close
d1541 1
a1541 1
        Pull    "R0-R3,R12,PC",,^       ; no errors allowed here!
d1543 1
a1543 1
        MakeErrorBlock WimpCantKill
d1545 2
a1546 3
;;-----------------------------------------------------------------------------
;; Command Window code variable
;;-----------------------------------------------------------------------------
d1548 6
a1553 3
CommandWindow_var
        MOV     PC,LR                   ; entry point for write op
        Push    "LR"                    ; entry point for read op
d1555 9
a1563 3
        MOV     R0,#WimpSysInfo_DesktopState
        SWI     XWimp_ReadSysInfo
        Pull    "PC",VS
d1565 3
a1567 1
        CMP     R0,#0                   ; R0=0 => "command" state
d1569 7
a1575 2
        ADREQ   R0,str_commands
        ADRNE   R0,str_desktop
d1577 1
a1577 2
        LDRB    R2,[R0],#1
        Pull    "PC"
d1579 1
a1579 5
str_commands    DCB     ?str_commands2
str_commands2   DCB     "commands"
str_desktop     DCB     ?str_desktop2
str_desktop2    DCB     "desktop"
                ALIGN
d1581 1
a1581 1
CommandWindow_varsize   *       . - CommandWindow_var
d1583 1
a1583 28
;;-----------------------------------------------------------------------------
;; Service call handling
;;-----------------------------------------------------------------------------
      [ ServiceCallTable
ServiceTable
        DCD     0                               ; flags word
        DCD     Service2 - Module_BaseAddr
        [ :LNOT: UseAMBControl
        DCD     Service_Memory                  ; &11   ;
        ]                                               ;
        DCD     Service_Reset                   ; &27   ;
        DCD     Service_NewApplication          ; &2A   ;
        DCD     Service_ModeChange              ; &46   ;
        [ :LNOT: UseAMBControl                          ;
        DCD     Service_MemoryMoved             ; &4E   ;
        ]                                               ; must be in ascending order
        DCD     Service_ResourceFSStarted       ; &59   ;
        DCD     Service_ResourceFSDying         ; &5A   ;
        DCD     Service_ResourceFSStarting      ; &60   ;
        DCD     Service_ValidateAddress         ; &6D   ;
        [ SwitchingToSprite
        DCD     Service_SwitchingOutputToSprite ; &72   ;
        ]
        DCD     Service_InvalidateCache         ; &82   ;
        [ Medusa :LAND: :LNOT: UseAMBControl            ;
        DCD     Service_PagesSafe               ; &8F   ;
        ]
        DCD     0                               ; terminator
d1585 26
a1610 30
        DCD     ServiceTable - Module_BaseAddr
Service
        MOV     R0, R0                          ; flag service table to aware kernels
      |
Service
      ]
        ; Quick reject code for old kernels
        [ :LNOT: UseAMBControl
        TEQ     R1, #Service_Memory
        TEQNE   R1, #Service_Reset
        |
        TEQ     R1, #Service_Reset
        ]
        TEQNE   R1, #Service_NewApplication
        TEQNE   R1, #Service_ModeChange
        [ :LNOT: UseAMBControl
        TEQNE   R1, #Service_MemoryMoved
        ]
        TEQNE   R1, #Service_ResourceFSStarted
        TEQNE   R1, #Service_ResourceFSDying
        TEQNE   R1, #Service_ResourceFSStarting
        TEQNE   R1, #Service_ValidateAddress
        [ SwitchingToSprite
        TEQNE   R1, #Service_SwitchingOutputToSprite
        ]
        TEQNE   R1, #Service_InvalidateCache
        [ Medusa :LAND: :LNOT: UseAMBControl
        TEQNE   R1, #Service_PagesSafe
        ]
        MOVNES  PC, LR
d1612 1
a1612 4
Service2
        LDR     wsptr,[R12]
        Debug   sv,"Wimp has received service call",R1
;
d1614 2
a1615 26
        [ debugnk
        TEQ     R1,#&68
        BNE     %FT01
        Push    "R0,lr"
        TraceS  nk,R2
        MOV     R0,#10
        BL      trace_char
        Pull    "R0,lr"
01
        TEQ     R1,#6
        BNE     %FT01
        Push    "R0,lr"
        LDR     lr,[R0]
        Debug   nk,"Error Number ",lr
        ADD     lr,R0,#4
        TraceS  nk,lr
        MOV     R0,#10
        BL      trace_char
        Pull    "R0,lr"
01
        ]
      [ debugvalid
        TEQ     R1,#Service_ValidateAddress
        BNE     %FT01
        Debug   valid,"Service validate address: r2,r3",r2,r3
01
d1618 1
d1620 17
a1636 4
        TEQ     R1,#Service_ValidateAddress
        BEQ     ValidateAddress
        TEQ     R1,#Service_NewApplication
        BEQ     newapplication
d1638 9
a1646 10
    [ :LNOT: UseAMBControl                      ; not our responsibility any more!
        TEQ     R1,#Service_Memory
        BEQ     servicememory
        TEQ     R1,#Service_MemoryMoved
        BEQ     servicememorymoved
      [ Medusa
        TEQ     R1,#Service_PagesSafe
        BEQ     servicepagessafe                ; in wimp08, screen resize etc.
      ]
    ]
d1648 2
a1649 16
      [ SwitchingToSprite
        TEQ     R1, #Service_SwitchingOutputToSprite
        BEQ     switchingtosprite
      ]
        TEQ     R1,#Service_ModeChange
        BEQ     recalcmodevars
        TEQ     R1,#Service_ResourceFSStarting  ; redeclare resource files
        BEQ     serviceresourcefsstarting
        TEQ     R1,#Service_ResourceFSStarted   ; re-link to sprite file
        BEQ     getromsprites
        TEQ     R1,#Service_ResourceFSDying
        BEQ     loseromsprites
        TEQ     R1,#Service_InvalidateCache     ; ColourTrans changed palette
        BEQ     invalidatecache
        TEQ     R1,#Service_Reset
        MOVNE   PC,LR
d1651 2
d1654 2
d1657 9
a1665 6
initptrs_deallocating                   ; called on Service_Reset
        Push    "LR"
        BL      deallocateptrs
        BL      initptrs                ; re-initialise window stack etc.
        BL      defaultfilters          ; re-register the filter routines
        Pull    "PC"
d1667 5
a1671 32
ValidateAddress
        [ Medusa
         [ true
        Push    "R0-R2,lr"
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea             ; is there a kernel free pool
        Pull    "R0-R2,lr"
        MOVVCS  PC,lr
        CLRV
        |
        MOVS    PC,lr
         ]
        ]
        Debug   valid,"Validate address ",r2,r3
        Push    "LR"
      [ ChildWindows
        LDRB    r14,memoryOK                            ; BUGFIX: NRaine 6-Aug-96 (should be unconditional)
      |
        LDR     r14,memoryOK
      ]
        TST     r14,#mem_claimed
        Pull    "PC",EQ
        LDR     r14,freepoolbase
        Debug   valid,"First address is",r14
        CMP     r2,r14
        Pull    "PC",LT
        LDR     r14,orig_applicationspacesize
        Debug   valid,"Last address is ",r14
        CMP     r3,r14
        Pull    "PC",GT
        MOV     r1,#0
        Pull    "PC"
d1673 1
a1673 3
; ResourceFS has been reloaded - redeclare resource files
; In    R2 -> address to call
;       R3 -> workspace for ResourceFS module
d1675 1
a1675 6
serviceresourcefsstarting
        Push    "R0,LR"
        ADRL    R0,resourcefsfiles
        MOV     LR,PC                   ; LR -> return address
        MOV     PC,R2                   ; R2 -> address to call
        Pull    "R0,PC",,^
d1677 4
d1682 1
a1682 2
; try to locate ROM sprite area - if not found, refuse to start up!
; this MUST be in Resources:, as we need to use it directly
d1684 1
a1684 12
getromsprites
        Push    "R0-R6,LR"
;
        LDR     R0,currentmode
        SWI     XOS_CheckModeValid              ; get the REAL mode number!
        CMP     R0,#-1                  ; if mode does not exist,
        MOVEQ   R0,R1                   ; try to use substitute mode
        CMP     R0,#0                   ; if R1 = -2, we're stuck!
        LDRLT   R0,currentmode          ; (just give up and use the original)
;
        MOV     R3,#"0"
        MOV     R4,#1
d1686 6
a1691 3
        MOV     R1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        ADD     R5,R3,R4,LSL R2                 ; R5 = char 0
d1693 6
a1698 3
        MOV     R1,#VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        ADD     R6,R3,R4,LSL R2                 ; R6 = char 1
d1700 6
a1705 2
	MOV	R1,#VduExt_Log2BPP
	SWI	XOS_ReadModeVariable
d1707 1
a1707 4
        TEQ     R5,R6
        TEQEQ   R5,#"1"                         ; 1 os unit to a pixel mode
        MOVEQ   R5,#"2"
        MOVEQ   R6,#"2"
d1709 3
a1711 4
	TEQ	R5,#"2"				; 2x2 OS unit, 1bpp
	TEQEQ	R6,#"2"
	TEQEQ	R2,#0
	MOVEQ	R6,#"3"
d1713 9
a1721 44
        ASSERT  ((:INDEX:romspr_suffix) :AND: 3) = 0
        ADD     R14,R5,R6,LSL #8
        STR     R14,romspr_suffix
;
        ADR     R1,spritesfname
        BL      getspritefname          ; R1 -> <filename><x><y><bpp>
                                        ; R2 -> terminator
        MOV     R0,#OSFind_ReadFile
        SWI     XOS_Find
;
        ADRVS   R1,spritesfname         ; R1 -> original filename
        MOVVS   R0,#OSFind_ReadFile     ; try again!
        SWIVS   XOS_Find
        BVS     %FT99                   ; error!
;
        MOV     R3,R0                   ; save external file handle
;
        MOV     R0,#FSControl_ReadFSHandle
        MOV     R1,R3
        SWI     XOS_FSControl
;
        AND     R2,R2,#&FF
        TEQ     R2,#fsnumber_resourcefs
      [ SpritePriority
        BNE     %FT06
        SUB     R2,R1,#4                ; R2 -> sprite area (including size)
        STR     R2,baseofromsprites
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseoflosprites
        STRNE   R2, baseofhisprites
06
      |
        SUBEQ   R2,R1,#4                ; R2 -> sprite area (including size)
        STREQ   R2,baseofromsprites
      ]
;
        MOV     R0,#0
        MOV     R1,R3
        SWI     XOS_Find                ; close file
99
        BLVS    loseromsprites          ; don't return error - just lose sprites
        STRVS   R0,[sp]
        Pull    "R0-R6,PC",,^
d1723 2
a1724 2
spritesfname    DCB     "WindowManager:Sprites", 0
                ALIGN
d1726 1
a1726 12
loseromsprites
        Push    "LR"
        Debug   ub,"lose ROM sprites"
        ADRL    R14,romsprites
        STR     R14,baseofromsprites
      [ SpritePriority
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R14, baseoflosprites
        STRNE   R14, baseofhisprites
      ]
        Pull    "R1,PC"
d1728 12
a1739 2
  [ SwitchingToSprite
; Service_SwitchingOutputToSprite: cache limited graphics parameters
d1741 4
a1744 6
switchingtosprite
        ENTRY
        STR     R4, switchtospr_current     ; remember where output is switched to now
        TEQ     R4, #0                      ; if switching to screen
        BLEQ    switchingtosprite_recache   ; then make sure parameters are correct
        EXITS
d1746 1
a1746 12
switchingtosprite_recache
; recaches graphics parameters iff switchtospr_correctfor <> switchtospr_current
        ENTRY   "R0,R5-R6"
        LDR     R0, switchtospr_current
        LDR     R14, switchtospr_correctfor
        TEQ     R0, R14
        EXITS   EQ
        STR     R0, switchtospr_correctfor
        BL      readvduvars2            ; including new screen/sprite size etc.
        BLVC    calcborders             ; to set up dx, dy
        EXITS
  ]
d1748 3
a1750 1
; Service_ModeChange: cache new graphics parameters
d1752 1
a1752 4
recalcmodevars
        Push    "LR"
        BL      readvduvars2            ; including new screen size etc.
        BLVC    calcborders
d1754 3
a1756 8
        Push    R0
        ADRL    R0,inverselookup
        MOV     LR,#-1
        STR     LR,[R0]                 ; force recache
        Pull    R0
        [ windowsprite
        STR     lr,tiling_sprite        ; force re cache
        ]
d1758 1
a1758 6
        [ false
        ADRL    R14,greys_mode
        LDR     R14,[R14]
        TEQ     R14,#0
        BLNE    recalc_greys_palette
        ]
d1760 5
a1764 1
; medusa may require the write character vector to be reset.
d1766 1
a1766 3
        LDR     R14,commandflag
        TST     R14,#cf_suspended
        Pull    "PC",NE
d1768 11
a1778 2
        TEQ     R14,#cf_pending
        Pull    "PC",NE
d1780 19
a1798 5
        Push    "R0-R2"
        MOV     R0,#WrchV               ; get off the vector now!
        ADRL    R1,mywrch
        MOV     R2,wsptr
        SWI     XOS_Release
d1800 1
a1800 2
        MOV     R14,#cf_active
        STR     R14,commandflag
d1802 3
a1804 1
        Pull    "R0-R2,PC"
d1806 1
d1808 3
a1810 1
; Service_InvalidateCache: Mark all cached palette data as invalid
a1811 5
invalidatecache
        Push    "R0,R2,LR"
        LDRB    R2,preservett           ; avoid discarding the table when we know
        CMP     R2,#0                   ; that it is still valid
        BNE     %FT10
d1813 3
a1815 10
        LDR     R2,pixtable_at
        CMP     R2,#0                   ; has a pixtable been setup?
        MOVNE   R0,#ModHandReason_Free
        BLNE    XROS_Module              ; attempt to release - ignore errors
;
        MOV     R2,#0
        STR     R2,pixtable_at          ; mark the pixtable as being zapped!
;
        MOV     R2,#-1                  ; and the PixTrans mode
        STR     R2,lastmode
d1817 1
a1817 3
        LDR     R2,tile_temptab
        ORR     R2,R2,#&80000000
        STR     R2,tile_temptab
d1819 1
a1819 10
        [ false
        BL      freetoollist            ; Lose cached tool data
        |
; tool translation table is invalid,  try to recache
        LDR     R2,tool_area
        CMP     R2,#1
        BLT     %FT99
        LDR     R2,tool_list
        CMP     R2,#1
        BLT     %FT99
d1821 16
a1836 2
        MOV     R2,#0
        STR     R2,tool_list      ; force recache next time we need it
d1838 7
a1844 1
99
d1846 8
a1853 2
10
        Pull    "R0,R2,PC",,^
d1855 1
a1855 5
;
; Entry:  R2 = new CAO pointer
; Exit:   set flag to indicate whether application uses absolute w/s
;         NB: BASIC looks like a module, but uses application workspace
;
d1857 3
a1859 17
newapplication
        Push    "R0-R3,LR"
;
        Debuga  task1,"New CAO pointer =",R2
;
        MOV     R14,#0                  ; reset when application is run
        STR     R14,handlerword
;
        MOV     R0,#ExitHandler
        MOV     R1,#0
        MOV     R2,#0
        MOV     R3,#0
        SWI     XOS_ChangeEnvironment
        STR     R1,parentquithandler    ; for checking later
        Debug   task1,", Parent quit handler =",R1
;
        Pull    "R0-R3,PC",,^
d1861 2
a1862 4
;
; ChangeEnvironment monitoring
; Set bits in [handlerword] whenever a handler is modified
;
d1864 2
a1865 10
ChangeEnvCode
        Push    "R1,LR"
;
        TEQ     R1,#0           ; if the handler is being modified,
        MOVNE   R14,#1          ; set the corresponding bit in [handlerword]
        LDRNE   R1,handlerword
        ORRNE   R1,R1,R14,LSL R0   ; assume < 32 handlers
        STRNE   R1,handlerword
;
        Pull    "R1,PC"         ; pass it on!
d1867 11
d1879 2
a1880 5
UpCallCode	ROUT
        TEQ     R0,#UpCall_MediaSearchEnd
        BEQ     finishupcall                        ; this comes round if it works!
	TEQ	R0,#UpCall_MediaSearchEndMessage
        BEQ     finishupcall_withmessage            ; this comes round if it works!
d1882 3
a1884 3
        TEQ     R0,#UpCall_MediaNotPresent
        TEQNE   R0,#UpCall_MediaNotKnown
        MOVNE   PC,LR                   ; Pass it on
d1886 2
d1889 3
a1891 8
; In    r1 = fs number
;       r2 -> media name, or = -1 => r6 -> message
;       r3 = device number (-1 for irrelevant)
;       r4 = iteration number (so we can 'reverse poll' if required)
;       r5 = timeout between reverse polls (large if not wanted)
;       r6 -> media type (eg. 'disc' for FileCore) (if r2 <> -1)
;          = -1 for disc (if r2 <> -1)
;          -> complete message to display (if r2 = -1)
d1893 2
a1894 4
; Note  PRM p1-179 says that r2 may be -1 if irrelevant, the comment above
;       said it may be 0. Both were wrong. We take advantage of the
;       documentation to provide slightly modified behaviour, since no-one
;       can have been relying on r2 = -1 working before.
d1896 3
a1898 1
        Push    "R1-R6"         ; no need to stash LR (we'll claim vector)
d1900 2
a1901 3
        CMP     R6,#0                   ; bodge for old FileCores
        ADRLTL	R6,disc
        MOVLT   R5,#bignum              ; long timeout if R6 invalid
d1903 3
a1905 23
        SUB     sp,sp,#32
;
        MOV     r0, #FSControl_ReadFSName
        ADRL    r2, errorbuffer         ; r2 = buffer
        MOV     r3, #256                ; r3 = length
        LDR     r1, [sp,#32+0*4]        ; r1 = fs number
        SWI     XOS_FSControl
        SUBS    r2, sp, #0              ; CLRV, r2 -> buffer.
;
        Push    "r4"
        MOVVS   r4, #0
        ADRVCL  r4, errorbuffer         ; -> string of messages
        ADR     r0, messagefrom
        MOV     r3, #32
        BL      LookupToken
        Pull    "r4"
;
        SUBS    r2, sp, #0              ; CLRV, r2 -> buffer.
;
        Push    "R2-R5"
	LDR	r5, [sp, #32+1*4+4*4]	; media name or -1
	CMP	r5, #-1
	BEQ	%04
d1907 2
a1908 9
        ADRL    R2,errorbuffer
        MOV     R3,#252
        MOV     R14,#0                  ; error number
        STR     R14,[R2],#4
;
        ADRL    R0,ensuredisc           ; "Please insert %0 '%1'"
        MOV     R4,R6			; media type
;
        BL      LookupToken             ; resolve into suitable string
d1910 3
a1912 21
	B	%05
04
	;Just use the message provided (copied into the same buffer)
      [ false
	ADRL    r2, errorbuffer
	ADD	r2, r2, #4		;don't care about error number
06	LDRB	lr, [r6], #1		;read from given message
	STRB	lr, [r2], #1		;write to error buffer
	TEQ	lr, #0			;NUL-terminated
	BNE	%06
      |
	ADRL    r2, errorbuffer
	ADD	r3, r2, #251		;r3 holds the end address of the error buffer
	ADD	r2, r2, #4		;don't care about error number
06	LDRB	lr, [r6], #1		;read from given message
	TEQ	lr, #0			;NUL-terminated
	TEQNE	lr, #10			;test for end of line searching too far
	TEQNE	lr, #13			;test for cr
	TEQNE 	r2, r3			;test end of buffer
	STRNEB	lr, [r2], #1		;write to error buffer
	BNE	%06
d1914 2
a1915 8
	MOV	lr, #0			;ensure always NUL-terminated
	STRB	lr, [r2]
      ]
05
        Pull    "R2-R5"
;
        SWI     XOS_ReadMonotonicTime
        MOV     R4,R0
d1917 4
a1920 9
01      ADRL    R0,errorbuffer
        MOV     R1,#erf_okbox:OR:erf_cancelbox:OR:erf_omiterror:OR:erf_poll
        CMP     R5,#bignum
        BICCS   R1,R1,#erf_poll         ; don't poll if timeout too long
	Debug	upcall, "+Wimp_ReportError: flags", R1
        SWI     XWimp_ReportError
	Debug	upcall, "-Wimp_ReportError: button", R1
        TEQ     R1,#0                   ; if no decision made, loop & timeout
        BNE     %FT02
d1922 2
a1923 4
        SWI     XOS_ReadMonotonicTime
        SUB     R0,R0,R4
        CMP     R0,R5
        BCC     %BT01                   ; unsigned comparison
d1925 4
a1928 2
        MOV     R0,#UpCall_Claimed      ; get ADFS to try again
        B       %FT03
d1930 2
a1931 6
02      TEQ     R1,#erf_okbox
        MOVEQ   R0,#UpCall_Claimed      ; UpCall processed
        MOVNE   R0,#UpCall_Invalid
03
        ADD     sp,sp,#32               ; correct stack
        Pull    "R1-R6,PC"              ; Claim vector
d1933 2
a1934 7
finishupcall
        Push    "R0-R1"
;
        MOV     R1,#erf_okbox:OR:erf_pollexit   ; select 'OK'
        SWI     XWimp_ReportError
;
        Pull    "R0-R1,PC",,^           ; claim vector
d1936 3
a1938 14
finishupcall_withmessage
        Push    "R0-R3"
;
	;Just use the message provided (copied into the same buffer)
	ADRL    r2, errorbuffer
	ADD	r3, r2, #251		;r3 holds the end address of the error buffer
	ADD	r2, r2, #4		;don't care about error number
01	LDRB	lr, [r1], #1		;read from given message
	TEQ	lr, #0			;NUL-terminated
	TEQNE	lr, #10			;test for end of line searching too far
	TEQNE	lr, #13			;test for cr
	TEQNE 	r2, r3			;test end of buffer
	STRNEB	lr, [r2], #1		;write to error buffer
	BNE	%01
d1940 2
a1941 2
	MOV	lr, #0			;ensure always NUL-terminated
	STRB	lr, [r2]
d1943 2
a1944 10
	ADRL	R0, errorbuffer
	SUB	R0, r2, r0
	Debug	upcall,"string size",R0
	ADRL	R0, errorbuffer
        MOV     R1,#erf_okbox:OR:erf_poll   		; Draw the Box
        SWI     XWimp_ReportError
        MOV     R1,#erf_okbox:OR:erf_pollexit   	; Request the Box Removed
        SWI     XWimp_ReportError
;
        Pull    "R0-R3,PC",,^           ; claim vector
d1946 7
a1952 3
messagefrom DCB "MF", 0
ensuredisc  DCB "ID", 0                  ; followed by media type (eg. 'disc')
disc        DCB "disc", 0               ; cheat
d1954 24
a1977 1
        ALIGN
d1979 3
a1981 6
;
; Free resources currently used by Wimp
; NB:  task blocks etc. are not valid, so are simply discarded
;      don't bother to rewrite pointers - done later in 'initptrs'
; Doesn't reset the common sprite pool (only done in Die)
;
d1983 19
a2001 28
deallocateptrs	ROUT
        Push    "R0-R5,LR"
;
; release block used for holding pixtrans tables
;
        MOV     R0,#ModHandReason_Free
        MOV     R1,#0                   ; reset pointers to zero
;
        LDR     R2,pixtable_at
        CMP     R2,#0
        BLNE    XROS_Module              ; release the pixtrans table (ignore errors)
;
        LDR     R2,fileaddress
        CMP     R2,#0
        BLGT    XROS_Module              ; release the template loading buffer (ignore errors)
;
        STR     R1,pixtable_at
        STR     R1,pixtable_size
        STR     R1,filehandle
        STR     R1,fileaddress          ; tag as free'd
;
        BL      freelist                ; de-allocate list buffer (for sprite cache)
        BL      freetoolarea
;
        [ mousecache
        MOV     R0,#TickerV             ; tidy the mouse handler
        ADRL    R1,MouseCallEveryHandler
        BL      release
d2003 4
a2006 16
      [ NewErrorSystem
        [ WatchdogTimer
        ADRL    R0,BreakWatchdogHandler
        MOV     R1,WsPtr
        SWI     XOS_RemoveTickerEvent
        |
        MOV     R0,#EventV
        ADRL    R1,BreakWatchdogHandler
        MOV     R2,WsPtr
        SWI     XOS_Release                     ; stop calls to watchdog on events
         [ false
        MOV     R0,#13
        MOV     R1,#Event_Keyboard              ; disable keyboard events
        SWI     XOS_Byte
05
         ]
d2008 5
a2012 9
      ]
;
      [ outlinefont
        BL      LoseFont
      ]
;
; delete window blocks
;
        B       %FT02
d2014 2
a2015 1
01      LDR     R5,[R2,#ll_backwards]
d2017 2
a2018 3
        ; Delink window
        STR     R4,[R5,#ll_forwards]
        STR     R5,[R4,#ll_backwards]
d2020 4
a2023 2
        ; Discard it after translating link address to window address
        SUB     R2,R2,#w_all_link
d2025 4
a2028 1
        Debug   opn,"**** Discarding window on wimp dying ****",R2
d2030 4
a2033 54
        BL      discard_window
02
        ; Get first window in list, is it the header?
      [ ChildWindows                            ; make this unconditional when merging sources back in
        LDR     R2,allwinds+lh_forwards         ; BUGFIX: NRaine 2-Aug-96: discard ALL windows, not just the open ones!
      |                                         ;         It actually breaks otherwise, since w_all_link is used (see above)
        LDR     R2,activewinds+lh_forwards
      ]
        LDR     R4,[R2,#ll_forwards]
        CMP     R4,#nullptr
        BNE     %BT01
;
; delete the message queue
;
        BL      deletemessagequeue              ; also done when last task dies
;
; delete task blocks and associated slots
;
        ADRL    R4,taskpointers
        MOV     R5,#maxtasks
01
        LDR     R2,[R4],#4
        TST     R2,#task_unused
        BNE     %FT11
        LDR     R2,[R2,#task_slotptr]
        Debug   mjs2," wimp01 (1) slotptr to free",R2
        CMP     R2,#0
      [ UseAMBControl
        MOVGT   R0,#1   ;deallocate reason code
        SWIGT   XOS_AMBControl
      |
        MOVGT   R0,#ModHandReason_Free
        BLGT   XROS_Module                      ; free block (ignoring errors)
      ]
        LDR     R2,[R4,#-4]
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module              ; free block (ignoring errors)
11
        SUBS    R5,R5,#1
        BNE     %BT01
;
        LDR     R2,freepool
        CMP     R2,#0
        MOVGT   R0,#ModHandReason_Free
        BLGT   XROS_Module
;
        BL      deletependingtask
;
; delete both sets of iconbar entries
;
        ADRL    R1,iconbarleft
        BL      killiconbar
        ADRL    R1,iconbarright
        BL      killiconbar
d2035 4
a2038 2
;
        Pull    "R0-R5,PC",,^
d2040 4
d2045 4
a2048 23
deletependingtask
        Push    "R0-R2,LR"
;
        LDR     R2,pendingtask
        CMP     R2,#0
        BLE     %FT01
        LDR     R2,[R2,#task_slotptr]   ; delete slot block
        Debug   mjs2," wimp01 (2) slotptr to free",R2
        CMP     R2,#0
      [ UseAMBControl
        MOVGT   R0,#1   ;deallocate reason code
        SWIGT   XOS_AMBControl
      |
        MOVGT   R0,#ModHandReason_Free
        BLGT   XROS_Module
      ]
        LDR     R2,pendingtask          ; and task block (in that order)
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module
        MOV     R14,#nullptr
        STR     R14,pendingtask
01
        Pull    "R0-R2,PC",,^
d2050 4
d2055 4
a2058 16
killiconbar
        Push    "LR"
        LDR     R2,[R1,#icd_list]
01
        CMP     R2,#0
        BLE     %FT02
        LDR     R4,[R2,#icb_link]
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module              ; free block (ignoring errors)
        MOV     R2,R4
        B       %BT01
02
        MOV     R14,#nullptr
        STR     R14,[R1,#icd_list]
;
        Pull    "PC"
d2060 2
d2063 8
a2070 20
deletemessagequeue
        Push    "R0-R3,LR"
;
        LDR     R1,headpointer
01
        CMP     R1,#0
        BLE     %FT02
        MOV     R0,#ModHandReason_Free  ; free block (ignoring errors)
        MOV     R2,R1
        LDR     R1,[R1,#msb_link]       ; do this first!!!
        BL     XROS_Module
        B       %BT01
02
        MOV     R14,#nullptr
        STR     R14,headpointer
      [ NKmessages1
        STR     R14,lastpointer
      ]
;
        Pull    "R0-R3,PC",,^           ; ignore errors
d2072 2
d2075 2
a2076 3
;;-----------------------------------------------------------------------------
;; Workspace allocation
;;-----------------------------------------------------------------------------
d2078 8
a2085 2
cr      *       13
lf      *       10
d2087 2
a2088 2
FALSE   *       0
TRUE    *       1
d2090 2
a2091 12
No_Reason                       *       0
Redraw_Window_Request           *       1
Open_Window_Request             *       2
Close_Window_Request            *       3
Pointer_Leaving_Window          *       4
Pointer_Entering_Window         *       5
Mouse_Click                     *       6
User_Dragbox                    *       7
Key_Pressed                     *       8
Menu_Select                     *       9
Scroll_Request                  *       10
max_oldreason                   *       11      ; old apps don't know better
d2093 21
a2113 3
Lose_Caret                      *       11
Gain_Caret                      *       12
PollWord_NonZero                *       13      ; Wimp 2.23 onwards
d2115 1
a2115 4
User_Message                    *       17
User_Message_Recorded           *       18
User_Message_Acknowledge        *       19
max_reason                      *       20
d2117 44
a2160 3
 [ :LNOT: UTF8  ; we've done away with this kludge!
Key_PressedOldData              *       &FF     ; This is never seen outside the wimp.
 ]
d2162 1
a2163 9
border_normal                   *       0
border_slabout                  *       1
border_slabin                   *       2
border_ridge                    *       3
border_channel                  *       4
border_action                   *       5
border_defaultaction            *       6
border_editable                 *       7
border_max                      *       8
d2165 2
d2168 13
a2180 1
masknewcodes  *  ((1:SHL:max_reason)-1):EOR:((1:SHL:max_oldreason)-1)
d2182 1
d2184 1
a2184 17
null_bit          *     1 :SHL: No_Reason
redraw_bit        *     1 :SHL: Redraw_Window_Request
open_bit          *     1 :SHL: Open_Window_Request             ; can't be suppressed
close_bit         *     1 :SHL: Close_Window_Request            ; can't be suppressed
ptrleaving_bit    *     1 :SHL: Pointer_Leaving_Window
ptrentering_bit   *     1 :SHL: Pointer_Entering_Window
buttonchange_bit  *     1 :SHL: Mouse_Click
userdrag_bit      *     1 :SHL: User_Dragbox                    ; can't be suppressed
keypress_bit      *     1 :SHL: Key_Pressed
menuselect_bit    *     1 :SHL: Menu_Select                     ; can't be suppressed
scroll_bit        *     1 :SHL: Scroll_Request                  ; can't be suppressed
losecaret_bit     *     1 :SHL: Lose_Caret
gaincaret_bit     *     1 :SHL: Gain_Caret
pollword_bit      *     1 :SHL: PollWord_NonZero
message_bit       *     1 :SHL: User_Message
messagerec_bit    *     1 :SHL: User_Message_Recorded
messagebounce_bit *     1 :SHL: User_Message_Acknowledge
a2185 3
button_left     *       4
button_middle   *       2
button_right    *       1
d2187 2
a2188 1
mf_oldcoords    *       2_000000000001
d2190 5
a2194 9
mf_waitrepeat   *       2_000000001000
mf_waitclick    *       2_000000010000
mf_waitdrag     *       2_000000100000
mf_waitrelease  *       2_000001000000
mf_wait2clicks  *       2_000010000000
mf_waitremove   *       2_000100000000                  ; unhighlight if gone
mf_pending      *       2_000111111000
mf_pendingexceptdrag *  mf_pending:AND:(:NOT:mf_waitdrag)
mfb_setflags    *       3                       ; bit no. of pending bits
d2196 4
d2201 4
a2204 10
default_doubleclick_movelimit   *       32              ; chicago dist. (OS coords)
default_drag_movelimit          *       32
default_doubleclick_timelimit   *       10              ; centiseconds/10
default_drag_timelimit          *       default_doubleclick_timelimit / 2
default_automenudelay           *       10
default_menudragdelay           *       10
default_iconbarspeed            *       4   ; 200 OS units / sec
default_iconbaraccel            *       3   ; 100 OS units / sec^2
default_autofrontdelay          *       5
default_autoscrolldelay         *       5
d2206 2
a2207 12
drag_posn       *       1               ; system dragging routines
drag_size       *       2               ; all terminate when buttons released
drag_hscroll    *       3               ; ditto
drag_vscroll    *       4               ; ditto
drag_user       *       5               ; drag user box (fixed size)
drag_user2      *       6               ; drag user box (variable size)
drag_user3      *       7               ; drag point (nothing displayed)
drag_subr_posn  *       8               ; user subr, fixed size box
drag_subr_size  *       9               ; user subr, variable size box
drag_subr_posn2 *       10              ; doesn't stop when buttons released
drag_subr_size2 *       11              ; doesn't stop when buttons released
drag_scrollboth *       12              ; drag both scroll bars
d2209 2
a2210 4
 [ Autoscr
dragf_anchor    *       2_00000001      ; anchor rubber boxes to work area
dragf_clip      *       2_00000010      ; clip dragbox by window visible rectangles
 ]
d2212 4
a2215 10
getrect_firstrect       * 2_000001
getrect_updating        * 2_000010
getrect_redrawing       * 2_000100
getrect_noicons         * 2_001000
 [ Twitter
getrect_twitter         * 2_010000
 ]
 [ Autoscr
getrect_keepdragbox     * 2_100000
 ]
d2217 2
a2218 18
                        ^ -1
windowicon_workarea     # -1            ; -1
windowicon_back         # -1            ; -2
windowicon_close        # -1            ; -3
windowicon_title        # -1            ; -4
windowicon_toggle       # -1            ; -5
windowicon_up           # -1            ; -6
windowicon_verticalbar  # -1            ; -7    includes well area
windowicon_down         # -1            ; -8
windowicon_resize       # -1            ; -9
windowicon_left         # -1            ; -10
windowicon_horizbar     # -1            ; -11   includes well area
windowicon_right        # -1            ; -12
windowicon_outerframe   # -1            ; -13
windowicon_iconise	# -1		; -14
 [ PushBothBars
windowicon_bothbars     # -1            ; -15   for when both scrollbars are pushed in
 ]
d2220 1
a2220 8
iconposn_back           * 1
iconposn_close          * 2
iconposn_title          * 3
iconposn_toggle         * 4
iconposn_vscroll        * 5
iconposn_resize         * 6
iconposn_hscroll        * 7
iconposn_iconise	* 8
d2222 3
a2224 1
maxrects        *       512
d2226 1
a2226 3
bignum          *       &0FFFFFFF
nullptr         *       -1
nullptr2        *       -2
d2228 2
a2229 1
ROMstart        *       &3800000
d2231 10
a2240 5
sz_scrleft      *       0
sz_scrright     *       1280
sz_scrbot2      *       0
sz_scrbot       *       0               ; was 96 (to allow for icon bar)
sz_scrtop       *       1024
d2242 8
d2251 8
a2258 1
; contents of task word if task is dead
d2260 1
a2260 1
task_unused       *     1:SHL:31
d2262 45
d2308 6
a2313 3
;------------------------;
; Task data block format ;
;------------------------;
d2315 23
a2337 17
                  ^     0
task_flagword     #     4                       ; flag word on entry to Poll
task_slotptr      #     4                       ; if switched, block of pages
task_wimpver      #     4                       ; R0 on entry to Wimp_Initialise
task_pollword     #     4                       ; R3 on entry to Wimp_Poll(Idle)
task_fpblock      #     4                       ; FP register save block
              [ Swapping
task_file         #     4                       ; File handle for swap file.
task_filename     #     4                       ; File name for swap file.
task_extent       #     4                       ; File extent / Slot size.
task_swapped      *     1:SHL:31                ; bit 31 set if swapped out.
              ]
task_windows      #     4                       ; Number of open windows.
task_priority     #     4                       ; Priority for swap out.
	      [ debugtask4
task_eventtime    #     4
              ]
d2339 7
a2345 2
task_messages     #     4                       ; messages list / =-1 for all
task_messagessize #     4                       ; size of the list
d2347 7
a2353 7
priority_iconbar  *     1:SHL:0   ;1
priority_old      *     1:SHL:1   ;2
priority_pollword *     1:SHL:2   ;4
priority_idle     *     1:SHL:3   ;8
priority_windows  *     1:SHL:4   ;16
priority_null     *     1:SHL:5   ;32
priority_top      *     1:SHL:20
d2355 5
a2359 3
task_environment  #     4*3*MaxEnvNumber        ; environment pointers
task_registers    #     4*16                    ; USR register set
task_datasize     #     0
d2361 39
a2399 1
; extra bits for Wimp_Poll - not stored in task_flagword
d2401 25
a2425 3
flag_fpsavebit    *     24                      ; save/restore FP registers
flag_pollfastbit  *     23                      ; look at poll word before messages
flag_pollwordbit  *     22                      ; there is a poll word in R3
d2427 13
a2439 2
; top bits of flag word are version number of task
; then the 'poll idle' bit, and then bits 0..19 (the event mask)
d2441 27
a2467 2
flag_versionbit   *     21                      ; one above flag_pollidle
flag_pollidlebit  *     20                      ; not part of version number
d2469 5
a2473 1
             ASSERT     max_reason <= flag_versionbit
d2475 3
a2477 5
flag_fpsave       *     1 :SHL: flag_fpsavebit
flag_pollfast     *     1 :SHL: flag_pollfastbit
flag_pollword     *     1 :SHL: flag_pollwordbit
flag_version      *     1 :SHL: flag_versionbit
flag_pollidle     *     1 :SHL: flag_pollidlebit
d2479 17
a2495 1
flag_allowed      *     flag_pollword :OR: flag_pollfast :OR: flag_fpsave
d2497 26
a2522 1
; structures for storing the messsge list
d2524 16
a2539 6
                ^       0               ; Linked list of messages.
ml_next         #       4               ; Next message
ml_prev         #       4               ; Previous message
ml_message      #       4               ; Message number.
ml_task         #       4               ; Pointer to first task on list.
ml_size         #       0
d2541 4
a2544 1
        ASSERT  ml_next=0
d2546 2
a2547 5
                ^       0               ; Linked list of tasks for each message.
mlt_next        #       4               ; Next task.
mlt_prev        #       4               ; Previous task on list.
mlt_task        #       4               ; Task handle.
mlt_size        #       0
a2548 1
        ASSERT  mlt_next=0
a2549 3
;------------------------;
; FP register save block ;
;------------------------;
d2551 3
a2553 11
                ^       0
fp_status       #       4
fp_reg0         #       12              ; stored in extended precision
fp_reg1         #       12
fp_reg2         #       12
fp_reg3         #       12
fp_reg4         #       12
fp_reg5         #       12
fp_reg6         #       12
fp_reg7         #       12
fp_size         #       0
d2555 23
a2577 8
F0      FN      0       ; register name symbols for FP register saving
F1      FN      1
F2      FN      2
F3      FN      3
F4      FN      4
F5      FN      5
F6      FN      6
F7      FN      7
d2579 3
a2581 1
C_runtime_status   *    &70000  ; suitable value for C run-time environment
d2583 16
a2598 3
;------------------------------;
; Rectangle list head pointers ;
;------------------------------;
d2600 1
a2600 11
                ^       0
freerects       #       4               ; rectangle data
invalidrects    #       4
              [ ChildWindows
oldinvalidrects #       4
              ]
oldwindowrects  #       4
windowrects     #       4
borderrects     #       4
torects         #       4
firstfreerect   #       0
d2602 1
a2603 7
                ^       0
icd_list        #       4               ; iconbar data
icd_middle      #       4
icd_extent      #       4
icd_width       #       4
icd_widthoffset #       4
icd_size        #       0
d2605 4
a2608 2
iconbargap      *       16
iconbarsepgap   *       64
d2610 1
a2610 7
                ^       0
icb_link        #       4               ; format of iconbar blocks in heap
icb_iconhandle  #       4
icb_taskhandle  #       4
icb_priority    #       4
icb_defwidth    #       4               ; default width
icb_size        #       0
d2612 27
a2638 5
sysflags_dragbits   *   2_00001111      ; enable instant dragging
sysflags_nobeep     *   2_00010000      ; disable beep on error
sysflags_offscreen  *   2_00100000      ; allow windows to go off-screen
sysflags_nobounds   *   2_01000000      ; allow windows to go off-screen in all directions.
sysflags_automenu   *   2_10000000      ; auto open submenus
d2640 14
a2653 1
; Two-way linked list definitions
d2655 19
a2673 6
        ; List header
                ^       0
lh_forwards     #       4
lh_indicator    #       4
lh_backwards    #       4
lh_size         #       0
d2675 1
a2675 5
        ; List link
                ^       0
ll_forwards     #       4
ll_backwards    #       4
ll_size         #       0
d2677 4
d2682 2
a2683 1
                ^       0,R12
d2685 8
a2692 1
wsorigin        #       0
d2694 7
a2700 1
tempworkspace   #       8*4             ; can be used easily
d2702 9
a2710 11
vduoutput       #       0
log2px          #       4
log2py          #       4
log2bpp         #       4
scrx0           #       4               ; converted to OS units
scry0           #       4
scrx1           #       4
scry1           #       4
textxsize       #       4               ; converted to OS units
textysize       #       4
modeflags       #       4
d2712 1
a2712 1
rotatecounter   #       4               ; modified rotdotdash routine
d2714 1
a2714 1
romspr_suffix   #       4               ; <x><y> or "23"
d2716 5
a2720 5
dx              #       4
dy              #       4
dx_1            #       4
dy_1            #       4
xypixelsize     #       4
d2722 2
a2723 18
xborder         #       1
yborder         #       1
xborder1        #       1
yborder1        #       1
scroll_minlength    #   1
scroll_sidemargin   #   1
scroll_endmargin    #   1
scroll_mxborder     #   1
scroll_myborder     #   1
scroll_minxbar      #   1
scroll_minybar      #   1
fontforeground      #   1
fontbackground      #   1
continueflag    #       1               ; for changing extent while dragging
;fpemulator_flag #      1
iconbar_needs_rs    #   1
reentrancyflag  #       1
old_escape      #       1
d2725 16
a2740 1
       ALIGNHASH 4
d2742 26
a2767 35
 [ TrueIcon1
truefgcolour    #       4               ; for 24-bit colour icons
truebgcolour    #       4
 ]
 [ TrueIcon2
truebgcolour2   #       4               ; background colour for selected R5/R6 icons
truewellcolour  #       4               ; well colour for R6 icons
truefacecolour  #       4               ; 3D plinth colour facing light source
trueoppcolour   #       4               ; 3D plinth colour opposite light source
                #       4               ; reserved, in case 7 icon colours are specified!
 ]
redrawhandle    #       4
iconhandle      #       4
getrectflags    #       4
mouseflags      #       4
dragtype        #       4
draghandle      #       4
dragtask        #       4
dragoldx        #       4
dragoldy        #       4
dragx0          #       4
dragy0          #       4
dragx1          #       4
dragy1          #       4
dragoffx0       #       4
dragoffy0       #       4
dragoffx1       #       4
dragoffy1       #       4
dragwsptr       #       4               ; for user-supplied subroutines
dragsubr_on     #       4               ; for user-supplied subroutines
dragsubr_off    #       4               ; for user-supplied subroutines
dragsubr_move   #       4               ; for user-supplied subroutines
 [ Autoscr
dragflags       #       4               ; as passed to Wimp_DragBox in R3
 ]
d2769 2
a2770 3
drg_on          *       dragsubr_on   - dragwsptr
drg_off         *       dragsubr_off  - dragwsptr
drg_move        *       dragsubr_move - dragwsptr
d2772 6
a2777 2
wimpswiintercept        #       4       ; Wimp_Extend SWI intercepter
plotsprCB               #       4       ; backdrop tiling CB
d2779 4
a2782 4
        ALIGNHASH  16
; these have moved!
RAM_SWIEntry            #       12      ; 3 instructions for getting R12 back
OScopy_ChangeDynamic    #       4       ; this must follow immediately
d2784 9
a2792 11
        ALIGNHASH  16			; missing HASH! JRC 25 Jul 1997
clipx0          #       4
clipy0          #       4
clipx1          #       4
clipy1          #       4
spriteX         #       4               ; for sprite plotting in icons
spriteY         #       4
spaceinicon     #       4               ; for displaying scrollable icons
text_width      #       4
text_y0         #       4
text_y1         #       4
a2793 22
temp_text_height #      4               ; 320nk textwidth now gets height
                                        ; as well as width (Wimp_04)
        [ slabinout
two_sprite_save #       4               ; save flags for two sprite icons
        ]
spritecachevalid #      0               ; uses same adr as below
auto_menu_flag  #       1               ; flag to keep track of auto width
autorepeating   #       1
        [ TrueIcon3
tinted_enable   #       1               ; 1:SHL:2 => tinting enabled for current set of toolsprites
tinted_window   #       1               ; 1:SHL:2 => tinting enabled for this window (ie nonstandard colours)
tinted_tool     #       1               ; 1:SHL:2 => tinting enabled for this tool
        |
work_back_colour #      1               ; background colour of current window
        ]
errorbox_open   #       1
        ALIGNHASH 4
        [ windowsprite
tiling_sprite   #       4
tile_pixtable   #       4
tile_temptab    #       4
        ]
d2795 1
a2795 12
oldclipx0       #       16              ; really x0,y0,x1,y1
hascaret        #       4               ; 0 ==> this icon has the caret
careticonaddr   #       4               ; address of icon with caret
caretx          #       4               ; caret posn relative to text itself
caretscrollx    #       4               ; text offset due to caret
areaCBptr       #       4
thisCBptr       #       4
spritename      #       4               ; ptr to sprite name (or header)
spritenamebuf   #       12              ; buffer for sprite name itself
validationstring  #     4
lengthflags     #       4
linespacing     #       4               ; for formattable text icons
d2797 3
a2799 8
xoffset         #       4               ; used by block-copy code
yoffset         #       4
oldlink         #       4
errorhandle     #       4               ; handle of error window
backwindow      #       4               ; handle of background window (if any)
backwindowhandle  #     4               ; handle of 'new' bg window
commandhandle   #       4               ; handle of 'command' window
commandflag     #       4               ; is a command window pending?
d2801 4
a2804 4
              [ :LNOT: NewErrorSystem
highlighted_colour      #       4       ; colour of OK box initially
unhighlighted_colour    #       4       ; colour of Cancel box initially
              ]
d2806 14
a2819 4
iconbarhandle   #       4
iconbarheight   #       4
iconbarleft     #       icd_size
iconbarright    #       icd_size
d2821 12
a2832 24
dotdashrate     *       5
initdotdash1    *       &FC
tempdotdash     *       ((initdotdash1:SHL:1):AND:&FF):OR:(initdotdash1:SHR:7)
initdotdash2    *       initdotdash1:EOR:tempdotdash
dragflag        #       1
dragaction      #       1
addtoolstolist  #       1               ; if non-zero then rotate and reset
dotdash1        #       1
dotdash2        #       1
dotdash         #       1
              [ :LNOT: TrueIcon3
titlecolour     #       1
              ]
repeatdelay     #       1               ; for auto-repeating icons
repeatrate      #       1
repeatlimit     #       1
gcolaction      #       1               ; used by Wimp_SetColour
sysflags        #       1               ; actions on moving windows (drag?)
memoryOK        #       1               ; flag for ChangeDynamicArea
modechanged     #       1               ; flag set on mode change
preservett      #       1               ; used to hang onto translation tables
              [ ChildWindows
openspending    #       1               ; whether we're in the middle of a set of opens
              ]
d2834 10
a2843 1
        ALIGNHASH   4
d2845 22
a2866 4
oldfxstatus     #       11              ; *FX 4
                                        ; *FX 219
                                        ; *FX 221..228
                                        ; *FX 229
d2868 37
a2904 3
              [ mousecache
recacheposn     #       1               ; non-zero then re-cache mouse information (x,y,b and time changed!)
              ]
d2906 3
d2910 1
a2910 1
        ALIGNHASH   4
d2912 1
a2912 2
                #       14*4            ; FD stack for Wimp_ReportError
errorstack      #       0
d2914 2
a2915 11
mousexpos       #       4
mouseypos       #       4
mousebuttons    #       4
              [ mousecache
mousetime       #       4
              ]
mouseblk        #       12
oldbuttons      #       4
mousexrel       #       4
mouseyrel       #       4
leftborder      #       4
d2917 2
a2918 8
pending_time    #       8
pending_x       #       4
pending_y       #       4
pending_buttons #       4
pending_window  #       4
pending_icon    #       4
timeblk         #       4               ; NB overlaid with next word!
temp            #       4
d2920 4
a2923 11
writeabledir    #       4               ; Direction of writeable icons.
reversedmenu    #       4               ; Flag for reversed menus.
externalcreate  #       4               ; True if menu is a result of a SWI call.
                [       outlinefont
systemfont      #       4               ; WIMP font handle, if claimed
symbolfont      #       4               ; WIMP symbol font handle, if claimed
currentfont     #       4               ; the font in force on entry to the WIMP, if needed
currentbg       #       4               ; its background colour
currentfg       #       4               ; its foreground colour
currentoffset   #       4               ; its colour offset
                ]
a2924 6
                [ SpritePriority
preferredpool   #       4               ; 1 => ROM, 0 => RAM
baseoflosprites #       4               ; base of low priority common sprite pool
baseofhisprites #       4               ; base of high priority common sprite pool
                ]
baseofsprites   #       4               ; base of common sprite pool (in RAM)
d2926 52
a2977 15
oldCAOpointer   #       4               ; used in OS_ChangeDynamicArea
handlerword     #       4               ; flag word ==> has handler changed?
parentquithandler   #   4               ; quit handler when application starts
freepool        #       4               ; stack of free pages (words)
freepoolbase    #       4               ; base address of free memory
freepoolpages   #       4               ; no of pages in free pool
pendingtask     #       4               ; task block pending deletion
                                        ; (in Wimp_Poll)
orig_memorylimit           #  4
orig_applicationspacesize  #  4
oldapplimit     #       4               ; used in ChangeDynamicArea code
pagesize        #       4
npages          #       4
slotsize        #       4               ; default slot size
currentmode     #       4
d2979 7
a2985 12
taskhandle      #       4               ; task currently paged-in
newtaskhandle   #       4               ; temporary location for pageintask
polltaskhandle  #       4               ; task handle on entry to Wimp_Poll
menutaskhandle  #       4               ; task handle of menu owner
nulltaskhandle  #       4               ; for cycling null events
singletaskhandle   #    4               ; single = taskhandle if 1-tasking
inithandle      #       4               ; "owner" slot if [freepool] = -1
taskcount       #       4               ; number of active tasks
tasknumber      #       4               ; global task number (monotonic)
taskSP          #       4               ; pointer into parent task stack
wimpquithandler #       12              ; how to get out of the Wimp!!
oldcallback     #       12              ; previous callback handler
d2987 1
a2987 2
flagword        #       4               ; flag word for current task
;latestwimp     #       4
d2989 11
a2999 7
ptrwindow       #       4               ; where the mouse was last seen
ptrtask         #       4               ; original owner of ptrwindow
borderlinked    #       4
isborderok      #       4
;ishscroll      #       4
;isvscroll      #       4
;heapfreeptr    #       4
d3001 2
a3002 1
headpointer     #       4               ; for message passing
d3004 344
a3347 2
sender          #       4
myref           #       4
d3349 2
a3350 4
crf_vdu5caret   *       &01000000
crf_invisible   *       &02000000
crf_usercolour  *       &04000000
crf_realcolour  *       &08000000
d3352 3
a3354 1
crb_colourshift *       16              ; use bits 16-23 for caret colour
d3356 2
a3357 8
caretdata       #       28              ; window,icon,x,y coords,height,index
                                        ; [caretdata+24]=caretscrollx (the definitive copy)
oldcaretwindow  #       4
menucaretwindow #       4
menucareticon   #       4
oldcaretdata    #       24              ; preserves caret data over menus
hotkeyptr       #       4               ; pointer into window stack
menuscrolly     #       4
d3359 1
a3359 12
maxmenus        *       8
longjumpSP      #       4               ; for cutting out the middle-man
whichmenu       #       4
menus_temporary #       4               ; if set, Wimp_Poll kills the menus
menuhandle      #       4
menuiconwidth   #       4
menuiconheight  #       4
menuiconspacing #       4
menuSP          #       4
menuhandles     #       4*maxmenus      ; handle of relevant window
menudata        #       4*maxmenus      ; ptrs to menu definitions (-1 if dial)
menuselections  #       4*maxmenus      ; selection index in each menu
d3361 2
a3362 7
 [ UTF8
keystring_buflen #      1               ; number of bytes in keystring_buffer (see below)
keyprocess_buflen #     1               ; number of bytes in keyprocess_buffer (see below)
keyin_buffer    #       6               ; filled from kernel buffer, for the sake of identifying incoming UTF-8 sequences
keyin_buflen    #       1               ; number of bytes in keyin_buffer
keyout_buffer   #       5               ; for outputting multi-byte UTF-8 characters as hotkey sequences
keyout_buflen   #       1               ; number of bytes in keyout_buffer
d3364 2
a3365 3
alphabet        #       1               ; for storing the current alphabet
        ALIGNHASH 4
 ]
d3367 2
a3368 11
 [ Autoscr
; main autoscrolling variables
autoscr_state           #       4       ; flags word
autoscr_handle          #       4       ; window being scrolled
autoscr_pz_x0           #       4       ; pause zone sizes
autoscr_pz_y0           #       4
autoscr_pz_x1           #       4
autoscr_pz_y1           #       4
autoscr_user_pause      #       4       ; minimum pause time (cs), or -1 to use default
autoscr_user_rout       #       4       ; user routine, or < &8000 to use Wimp-supplied
autoscr_user_wsptr      #       4       ; user routine workspace (if above >= &8000)
d3370 5
a3374 12
autoscr_pause           #       4       ; minimum pause time (cs) (explicit if default)
autoscr_rout            #       4       ; routine (user or Wimp)
autoscr_wsptr           #       4       ; workspace (user or Wimp)
autoscr_next_t          #       4       ; time when to start autoscrolling, or when next to update
autoscr_last_t          #       4       ; time of last update
autoscr_last_x          #       4       ; position of mouse at last examination
autoscr_last_y          #       4
autoscr_old_ptr_colours #     3*4       ; used when restoring pointer after autoscroll pointer use
autoscr_old_ptr_number  #       1
autoscr_default_pause   #       1       ; derived from CMOS (ds)
autoscr_scrolling       #       1       ; used to determine next setting of flag bit 8
autoscr_pausing         #       1       ; used to determine whether timer is dirty, also a "don't re-enter" flag
d3376 1
a3376 6
autoscr_speed_factor    *       5       ; -log2 of number of pointer offsets to scroll per centisecond
autoscr_update_delay    *      12       ; hardwired minimum interval between updates (cs)
                                        ; is necessary to ensure null events have a chance to be seen
        ALIGNHASH   4
autoscr_END             #       0
 ]
a3377 3
 [ IconiseButton
iconisebutton           #       1       ; nonzero => add iconise button
 ]
d3379 5
a3383 3
 [ StickyEdges
stickyedges             #       1       ; nonzero => interpret "force on screen" as sticky
 ]
d3385 6
a3390 3
 [ BounceClose
buttontype              #       1       ; nonzero => buttons are release-type
 ]
d3392 5
a3396 147
 [ PoppingIconBar
popiconbar              #       1       ; nonzero => enable autofronting
        ALIGNHASH   4
popiconbar_pause        #       4       ; configured pause time (cs)
 ]

 [ MultiClose
nextwindowtoiconise     #       4       ; pointer through window stack so far
 ]

 [ TrueIcon3
truetitlefg     #       4               ; title foreground and window frame colour
truetitlebg     #       4               ; title background colour
trueworkfg      #       4               ; work area foreground colour
trueworkbg      #       4               ; work area background colour
truescoutcolour #       4               ; scroll bar outer colour
truescincolour  #       4               ; scroll bar inner colour
truetitlebg2    #       4               ; title background colour when highlighted for input focus
titlecolour     #       4               ; independent of input focus status
 ]

 [ SwitchingToSprite
switchtospr_current     #       4       ; -> sprite (or 0 for screen) that VDU output is switched to
switchtospr_correctfor  #       4       ; -> sprite (or 0 for screen) that Wimp is set up for
 ]

iconbar_scroll_speed    #       4
iconbar_scroll_accel    #       4

systemfontwidth #       4
systemfonty0    #       4
systemfonty1    #       4

tempiconblk     #       48              ; for creating icons for menus
                                        ; also used for int_open_window
                                        ; and system drag boxes
tf_hdr          *       16
tf_indexsize    *       24
tf_log2fontsize *       4               ; actually font size = 3*2^4
tf_fontsize     *       3*(1:SHL:tf_log2fontsize)


templatehdr     #       tf_hdr
fontbindings    #       256

filehandle      #       4
fileaddress     #       4
filelength      #       4

templateindex   #       4
userfreeptr     #       4
userfreeend     #       4
userfontcounts  #       4

baseofromsprites  #     4               ; base of ROM sprite pool (in Resources:)

PollTaskPtr     #       4               ; -> last entry in PollTaskList

              [ NKmessages1
lastpointer     #       4               ; end of message queue (NK's optimise)
              ]

lastmode_x1     #       4               ; (xwindlimit+1) * px for previous mode
lastmode_y1     #       4               ; (ywindlimit+1) * py for previous mode
forceflags      #       4               ; for putting windows back

lastmode        #       4
sprite_log2bpp  #       4               ; for mode-independent sprite plotting
sprite_log2px   #       4
sprite_log2py   #       4
needsfactors    #       4
           ALIGNHASH    16
factors         #       16

ditheringflag   #       4               ; flag to control dithering

usephyspaltable #       4               ; use the physical palette table
physpaltable    #       4*16            ; secondary palette table (disconnected from Wimp jobbie)

transtable1     #       2               ; 1bpp mapping from wimp -> sprite pixels
transtable2     #       4               ; 2bpp     ---------- "" ------------
transtable4     #       16              ; 4bpp     ---------- "" ------------
        ALIGNHASH       4

pixtable_params #       4*6             ; parameters used for the select table call
pixtable_at     #       4
pixtable_size   #       4               ; size and position of pixtrans table currently setup

temppaltable    #       4*16            ; temporary store for a palette

list_at         #       4               ; head of sprite cache list
list_size       #       4               ; size of buffer claimed
list_end        #       4               ; end of list used for chop

        [ windowsprite
tile_sc_block   #       16
tile_log2px     #       4
tile_log2py     #       4
tile_width      #       4
tile_height     #       4
        ]

; bits for internationalised Wimp

message_block   #       4*4             ; 16 bytes for message trans
messages        #       4               ; =0 then no messages / -> messages block

; bits for portable speed control

MaxIdleEvents   #       4               ; maximum number of idle events recieved
; see 321nk later
IdlePerSec      #       4               ; amount of time spent in idle mode
 [ Stork
WimpPortableFlags #     4               ;
PowerSave * &01000000
 |
WimpPortableFlag #      4               ; non-zero then portable module present
 ]

last_fg_gcol    #       4
last_bg_gcol    #       4

; filters registered using Wimp_RegisterFilter

prefilterWP     #       4               ; pre-poll filter
prefilter       #       4
postfilterWP    #       4               ; post-poll filter
postfilter      #       4
copyfilterWP    #       4               ; block copy filter
copyfilter      #       4
rectanglefilterWP #     4               ; get-rectangle filter
rectanglefilter   #     4
postrectfilterWP #     4               ; post-get-rectangle filter
postrectfilter   #     4
posticonfilterWP #     4               ; post-icon-draw filter
posticonfilter   #     4

; bits for icon borders

border_type     #       4               ; border slab type => 0 => normal
border_highlight #      4               ; highlight colour to be applied

border_iconselected #   4               ; icon that is currently selected
border_windowselected # 4               ; window selected

tool_area       #       4               ; -> sprite area owned by tool managing routines (may be in resources:)
tool_areaCB     #       SpriteAreaCBsize
d3398 7
a3404 1
tool_list       #       4               ; -> list of sprites in area / =0 if not valid yet
d3406 1
a3406 1
; tool plotting information
d3408 2
a3409 7
tool_plotparams #       0
tool_plotop     #       4               ; sprite op to plot sprites with
tool_maskop     #       4
tool_scaling    #       4               ; -> scaling block (may not be used)
tool_transtable #       4               ; -> translation table (may not be used)
tool_scrollclip #       4*4             ; clip region used for plotting scroll bars
tool_scalingblk #       4*4             ; scaling block used for painting glyphs
d3411 2
a3412 1
; tool size information
d3414 1
a3414 6
title_height    #       4               ; title height = close, toggle, back
title_height1   #       4
vscroll_width   #       4               ; vscroll height = left, right, resize
vscroll_width1  #       4
hscroll_height  #       4               ; hscroll width = toggle, up, down, resize
hscroll_height1 #       4
d3416 5
a3420 5
back_width      #       4               ; width of the back box
close_width     #       4               ; width of the close box
 [ IconiseButton
iconise_width	#	4		; width of the iconise button
 ]
d3422 1
a3422 2
left_width      #       4               ; width of the left arrow
right_width     #       4               ; width of the right arrow
d3424 6
a3429 2
up_height       #       4               ; up arrow height
down_height     #       4               ; down arrow height
d3431 5
a3435 1
; bits for iny-outy type scroll blobs - yucky!
d3437 3
a3439 7
vscroll_top             # 4             ; height in OS units
vscroll_topfill         # 4
vscroll_blobtop         # 4
vscroll_blobfill        # 4
vscroll_blobbottom      # 4
vscroll_bottomfill      # 4
vscroll_bottom          # 4
d3441 26
a3466 7
hscroll_left            # 4             ; width in OS units
hscroll_leftfill        # 4
hscroll_blobleft        # 4
hscroll_blob            # 4
hscroll_blobright       # 4
hscroll_rightfill       # 4
hscroll_right           # 4
d3468 1
a3468 2
title_left              # 4             ; width in OS units
title_right             # 4
d3470 1
a3470 3
title_sectionwidth      # 4             ; width of sections in OS units
title_topheight         # 4             ; height of units in OS units
title_bottomheight      # 4
d3472 1
a3472 4
                      [ hvblip
vscroll_blipheight      # 4             ; width an height of scroll bar blobs
hscroll_blipwidth       # 4
                      ]
d3474 1
a3474 1
; some other bits of misc data for configuration and caret saving
d3476 3
a3478 9
drag_movelimit             #       1
doubleclick_movelimit      #       1
              ALIGNHASH    4
drag_timelimit             #       4
doubleclick_timelimit      #       4
automenu_timelimit         #       4
menudragdelay              #       4
automenu_timeouttime       #       4
automenu_inactivetimeout   #       4
d3480 3
a3482 3
savedcaretdata             #      24    ; holds caretdata from start of key handling process
savedvalidation            #       4
savedcharcode              #       4
d3484 3
a3486 1
; bits to do with pointer tracking
d3488 1
a3488 4
old_icon        #       4
old_window      #       4
special_pointer #       4
pointer_sprite  #       12
d3490 2
a3491 4
 [ KeyboardMenus
lastxpos        #       4               ; stop mouse highlighting menus unless it moves
lastypos        #       4
 ]
d3493 2
a3494 4
 [ AutoHourglass
hourglass_delay	*	100		; delay before showing hourglass for "dodgy apps", in 1/100 secs
hourglass_status #      4               ; autohourglass status (0 => no hourglass or WrchV routine, 1 => just routine,
 ]                                      ;                       2 => routine is on vector & hourglass is pending or active)
d3496 5
a3500 1
        ALIGNHASH       64
d3502 1
a3502 5
 [ UTF8
keystring_buffer #      256             ; for queuing Key$n bytes
keyprocess_buffer #     256             ; for queuing multiple key-originating Wimp_ProcessKey calls
                                        ; byte format is the same as bytes read from kernel keyboard buffer
 ]
d3504 28
a3531 1
        ALIGNHASH       64
d3533 17
a3549 27
        [ NewErrorSystem
errortitle      #       256              ; for building up 'Error from ...'
errortitend     #       0
errorbuttonsize * 256
errorbuttons    #       errorbuttonsize ; this is used to copy button labels
buttontextsize  * 24
oktext          #       0               ; SMC: now lookup text for buttons (OK same as Continue)
conttext        #       buttontextsize
quittext        #       buttontextsize
progerrsaveblk  #       4 * 4           ; caller R0-R3, stored while the "may have gone wrong" window is displayed
errbut_y0_def   #       4               ; bottom of default action button, read from "Continue"
errbut_y1_def   #       4               ; top of default action button, read from "Continue"
errbut_fl_def   #       4               ; icon flags of default action button, read from "Continue"
errbut_va_def   #       4               ; validation string of default action button, read from "Continue"
errbut_w_def    #       4               ; width of default action button, read from "Continue"
errbut_y0       #       4               ; bottom of action button, read from "Cancel"
errbut_y1       #       4               ; top of action button, read from "Cancel"
errbut_fl       #       4               ; icon flags of action button, read from "Cancel"
errbut_va       #       4               ; validation string of action button, read from "Cancel"
errbut_w        #       4               ; width of action button, read from "Cancel"
errapp_x0       #       4               ; LHS of application sprite
errtype_x0      #       4               ; LHS of error type sprite
errmess_x0      #       4               ; LHS of error message icon
        [ StretchErrorText
linecount       #       4               ; flags counting and returns number of lines required for error message
errmess_maxlines    *   7               ; maximum number of lines to allow for error message
errmess_increment   *   48              ; step size (in OS units) to increase error box size by when enlarging
d3551 6
a3556 4
maxno_error_buttons *   8               ; maximum number of action buttons (needs this many Additional buttons in template)
        |
errortitle      #       128             ; old versions have smaller template file
errortitend     #       0
d3558 3
a3560 11

paltable        #       4 * 16          ; one word per colour
othercolours    #       4 * 4           ; border & mouse colours

        [ NewErrorSystem
watchdogarea    #       4
watchdogerror   #       4
watchdogerrtxt  #       244
watchdogtaskno  #       4
watchdogtask    #       4
watchdogcodew   #       4
d3562 1
d3564 4
a3567 5
iconbar_scroll_start_time #	4	; time icon bar started scrolling
iconbar_scroll_start_scx  #	4	; and where it started from
MaxSlowIdleEvents       #       4       ; 321nk added for PowerUtils incorporation
MaxFastIdleEvents       #       4
Threshold       *       &600
d3569 27
a3595 9
	[ PoppingIconBar
iconbar_pop_time	#	4
iconbar_pop_state	#	4
pop_Back	* 0
pop_Delaying	* 1
pop_Front	* 2
pop_HeldByMenu	* 3
pop_Front2      * 4 ; held by virtue of Shift-F12
	]
a3596 7
        [ ChildWindows
newparent       #       4               ; parameter for Wimp_OpenWindow
newalignflags   #       4               ; parameter for Wimp_OpenWindow
oldactivewinds  #       lh_size         ; used for deferred opening
openingwinds    #       lh_size         ; ditto
heldoverwinds   #       4               ; singly-linked list for windows that are optimized out
        ]
d3598 4
a3601 2
activewinds     #       lh_size         ; Forwards is top to bottom of stack
allwinds        #       lh_size
d3603 10
a3612 9
        ; Braindead Panic Redraw handling
BPR_indication  #       4
BPR_gotfullarea *       0               ; Rect area has become full from a no problem situation
BPR_panicnow    *       1               ; Rect area become full again - enter brain dead mode
BPR_nullrectops *       1               ; This or below means rectangle ops do nothing
BPR_notatall    *       2               ; No problems with full rectangle areas
BPR_1sttry      *       3               ; After a rect area full try redrawing whole screen
BPR_continuelevel *     4               ; HS this means continuing BPR
; Other values indicate BPR_panicnow and are the next window to redraw braindeadwise
d3614 16
a3629 4
rlinks          #       4*maxrects
                #       -4*firstfreerect        ; this data not used
rectarea        #       16*maxrects
rectend         #       0
a3630 1
           ALIGNHASH    64
a3631 1
maxtasks        *       128
d3633 6
a3638 4
taskstack       #       maxtasks * 4    ; each task can only be in it once!
taskpointers    #       maxtasks * 4    ; pointers to task data blocks
maxtaskhandle   *       :INDEX:@@
registerbuffer  #       4*16
d3640 32
a3671 1
PollTasks       #       maxtasks * 4    ; Packed list of tasks with pollwords
d3673 3
a3675 2
errorbuffer     #       256             ; used by error handler
taskbuffer      #       256             ; command which starts a task
d3677 6
a3682 2
errordynamic    *       errorbuffer+4   ; put these after stashed PC
stackspace      #       0               ; temporary stack for debugging!
a3683 9
tools_area      #       4               ; area for tools list
tools_trans_size #      4               ; size of last tools_trans
copyerror       #       240             ; copy of error block
greys_mode       #      1               ; last grey mode.
last_greys      #       1               ; previous greys mode
freepoolinuse	#	1
misc		#	1
save_context    #       4
fontnamebuffer  #       60              ; used to store last ROM font.
d3685 2
d3688 12
a3699 3
        [ DebugMemory
memory_claims   #       8               ; build a list of mem claims for debugging
        ]
d3701 3
a3703 1
 ALIGNHASH 4
d3705 3
a3707 1
inverselookup   #       1024            ; what colour numbers to use when EOR'ing an area
d3709 2
a3710 1
path_buffer     #       1024            ; for building Sprites<x><y> pathnames
d3712 4
a3715 1
 ALIGNHASH 4
d3717 4
d3722 44
a3765 9
              [ Swapping
swapping        #       4               ; Is there a swap path ? if so, the length of the path.
swapsize        #       4               ; Must be together (returned from ReadSysInfo )
swapused        #       4
                ASSERT  swapsize=swapping+4
                ASSERT  swapused=swapsize+4
swap_filename   #       4               ; File name for next swap file.
swap_path       #       256             ; Path name for swap files.
              ]
d3767 2
a3768 4
		[	PreservePointerOnError
ptrshlflag	#	4		; Pointer shape and linkage flag (saved here during
					; ReportError) JRC 25 Jul 1997
		]
d3770 12
a3781 1
maxwork         *       :INDEX:@@
d3783 2
a3784 18
                ! 0,    "Free pool              = R12+&" :CC: :STR: :INDEX: freepool
                ! 0,    "#pixtable_at           = R12+&" :CC: :STR: :INDEX: pixtable_at
                ! 0,    "#pixtable_size         = R12+&" :CC: :STR: :INDEX: pixtable_size
                ! 0,    "#list_at               = R12+&" :CC: :STR: :INDEX: list_at
                ! 0,    "#list_size             = R12+&" :CC: :STR: :INDEX: list_size
                ! 0,    "#list_end              = R12+&" :CC: :STR: :INDEX: list_end
                ! 0,    "#allwinds              = R12+&" :CC: :STR: :INDEX: allwinds
                ! 0,    "Task Pointers          = R12+&" :CC: :STR: :INDEX: taskpointers
                ! 0,    "Filter bits            = R12+&" :CC: :STR: :INDEX: prefilterWP
 [ PoppingIconBar
                ! 0,    "#iconbar_pop_state     = R12+&" :CC: :STR: :INDEX: iconbar_pop_state
 ]
 [ Autoscr
                ! 0,    "#dragtype              = R12+&" :CC: :STR: :INDEX: dragtype
                ! 0,    "#dragflags             = R12+&" :CC: :STR: :INDEX: dragflags
                ! 0,    "#autoscr_state         = R12+&" :CC: :STR: :INDEX: autoscr_state
                ! 0,    " autoscr data size     =      " :CC: :STR: (:INDEX: autoscr_END - :INDEX: autoscr_state)
 ]
d3786 6
d3793 12
a3804 1
                ! 0,    "Workspace used               &":CC::STR:maxwork:CC:" bytes."
d3806 1
d3808 4
a3811 3
;;-----------------------------------------------------------------------------
;; Format of data in a window definition
;;-----------------------------------------------------------------------------
d3813 8
a3820 1
;; For Aquarius, keep the data from the guard to w_cw0 constant !!!
d3822 6
a3827 4
                ^       0
w_guardword     #       4               ; guard word when policing window handles
w_guardword_valid       *       &646e6957       ; "Wind"
w_taskhandle    #       4               ; handle of task which created window
d3829 1
a3829 5
              [ :LNOT: ChildWindows
w_active_link   #       ll_size         ; this has moved!
              ]
w_all_link      #       ll_size
w_icons         #       4               ; Points to window's block of icons
d3831 3
a3833 7
              [ togglebits
w_togglewidth   #       4               ; width of previous work area if toggled2 is set
w_toggleheight  #       4               ; height of previous work area if toggled2 is set
              ]
              [ Mode22
w_origflags     #       4
              ]
d3835 2
a3836 8
              [ ChildWindows
w_bwax0         #       4               ; previous position/size (for toggling)
w_bway0         #       4
w_bwax1         #       4
w_bway1         #       4
w_bscx          #       4               ; previous x,y scroll positions
w_bscy          #       4
w_bbhandle      #       4               ; previous window it was behind
d3838 5
a3842 1
w_alignflags    #       4               ; auto-alignment with parent window
d3844 2
a3845 4
w_opening_link  #       ll_size         ; for the list of windows being opened, and the block-copy rectangles
w_xoffset       #       4
w_yoffset       #       4
w_oldwindowrects  #     4               ; list of rectangles to be block-copied for this window
d3847 1
a3847 4
w_old_data      #       0               ; start of old version of current position

w_old_children  #       lh_size         ; children of this window (chained by w_active_link)
w_old_link      #       ll_size
a3848 1
w_old_parent    #       4               ; parent of this window (if any)
d3850 1
a3850 4
w_old_x0        #       4
w_old_y0        #       4               ; 'current' position, ie. the most-recently-displayed
w_old_x1        #       4               ; these are used for collecting up Wimp_OpenWindows
w_old_y1        #       4
d3852 5
a3856 6
w_old_wax0      #       4               ; x,y coordinates of work area
w_old_way0      #       4               ; (ie. corners)
w_old_wax1      #       4               ;
w_old_way1      #       4
w_old_scx       #       4               ; x,y scroll positions
w_old_scy       #       4               ; (between wex0/y0 and wex1/y1)
d3858 10
a3867 1
w_old_bhandle   #       4               ; not used, but keeps the structures in line
d3869 3
a3871 1
w_old_flags     #       4               ; status of window (open/closed etc.)
d3873 10
a3882 1
w_old_end       #       0
d3884 2
a3885 1
w_new_data      #       0               ; start of new version of current position
d3887 4
a3890 2
w_children      #       lh_size         ; children of this window (chained by w_active_link)
w_active_link   #       ll_size         ; this has moved!
d3892 5
a3896 6
w_parent        #       4               ; parent of this window (if any)
              ]
w_x0            #       4               ; bounding box of window
w_y0            #       4               ; (including outline)
w_x1            #       4               ;
w_y1            #       4               ;
d3898 17
a3914 53
              [ :LNOT: ChildWindows     ; this has moved!
w_bwax0         #       4               ; previous position/size
w_bway0         #       4
w_bwax1         #       4
w_bway1         #       4
w_bscx          #       4               ; previous x,y scroll positions
w_bscy          #       4
w_bbhandle      #       4               ; previous window it was behind
              ]

w_st0           #       0       ; start of 'status' section
w_cw0           #       0       ; start of Create_Window section
w_ow0           #       0       ; start of Open_Window section

w_wax0          #       4               ; x,y coordinates of work area
w_way0          #       4               ; (ie. corners)
w_wax1          #       4               ;
w_way1          #       4
w_scx           #       4               ; x,y scroll positions
w_scy           #       4               ; (between wex0/y0 and wex1/y1)
w_bhandle       #       4               ; handle of window above this one

w_ow1           #       0       ; end of Open_Window section

w_flags         #       4               ; status of window (open/closed etc.)

w_new_end       #       0

w_st1           #       0       ; end of 'status' section

w_tfcol         #       1               ; title foreground colour
w_tbcol         #       1               ; title background colour
w_wfcol         #       1               ; work area foreground colour
w_wbcol         #       1               ; work area background colour
w_scouter       #       1               ; scroll bar outer portion
w_scinner       #       1               ; scroll bar inner portion
w_tbcol2        #       1               ; colour if window has input focus
 [ TrueIcon3
w_flags2        #       1               ; secondary flags
 |
                #       1               ; reserved
 ]
w_wex0          #       4               ; work area extent
w_wey0          #       4               ; (x0,y0,x1,y1)
w_wex1          #       4
w_wey1          #       4
w_titleflags    #       4
w_workflags     #       4               ; icon flags for 'work area'
w_areaCBptr     #       4               ; sprite area CB ptr (<=0 ==> system)
w_minx          #       2               ; minimum x size (0 ==> use title)
w_miny          #       2               ; minimum y size
w_title         #       12              ; title (max 11 chars, then <cr>)
w_nicons        #       4               ; no. of icons following
d3916 4
d3921 10
a3930 1
w_cw1           #       0       ; end of Create_Window section
a3931 1
w_size          #       0       ; end of window data
d3933 5
a3937 3
      [ ChildWindows
        ASSERT  (w_old_end - w_old_data) = (w_new_end - w_new_data)
      ]
d3939 3
a3941 1
; bit masks for flags/status
a3942 17
wf_title        *       2_00000000000000000000000000000001
wf_moveable     *       2_00000000000000000000000000000010
wf_vscroll      *       2_00000000000000000000000000000100
wf_hscroll      *       2_00000000000000000000000000001000
wf_autoredraw   *       2_00000000000000000000000000010000
wf_isapane      *       2_00000000000000000000000000100000
wf_nochecks     *       2_00000000000000000000000001000000
wf_nobackquit   *       2_00000000000000000000000010000000
wf_userscroll1  *       2_00000000000000000000000100000000      ; auto-repeat
wf_userscroll2  *       2_00000000000000000000001000000000      ; debounced
wf_userscroll   *       2_00000000000000000000001100000000
wf_realcolours  *       2_00000000000000000000010000000000
wf_backwindow   *       2_00000000000000000000100000000000
wf_grabkeys     *       2_00000000000000000001000000000000
wf_onscreen     *       2_00000000000000000010000000000000      ; override sysflags_offscreen
wf_rubbery_wex1 *       2_00000000000000000100000000000000      ; extent can stretch to the right
wf_rubbery_wey0 *       2_00000000000000001000000000000000      ; extent can stretch downwards
d3944 8
a3951 9
ws_open         *       2_00000000000000010000000000000000
ws_top          *       2_00000000000000100000000000000000
ws_toggled      *       2_00000000000001000000000000000000
ws_toggling     *       2_00000000000010000000000000000000
ws_hasfocus     *       2_00000000000100000000000000000000
              [ :LNOT: ChildWindows
ws_system       *       2_00000000000111110000000000000000
ws_status       *       2_00000000000000110000000000000000      ; calc_w_status
              ]
d3953 4
a3956 2
ws_onscreenonce *       2_00000000001000000000000000000000      ; cancelled after open_window
ws_toggled2     *       2_00000000010000000000000000000000      ; used for storing important toggle
d3958 1
a3958 2
              [ ChildWindows
ws_system       *       2_00000000011111110000000000000000
d3960 3
a3962 2
wf_inborder     *       2_00000000100000000000000000000000      ; child window can overlap parent's border
              ]
d3964 23
a3986 9
wf_icon1        *       2_00000001000000000000000000000000
wf_icon2        *       2_00000010000000000000000000000000
wf_icon3        *       2_00000100000000000000000000000000
wf_icon4        *       2_00001000000000000000000000000000
wf_icon5        *       2_00010000000000000000000000000000
wf_icon6        *       2_00100000000000000000000000000000
wf_icon7        *       2_01000000000000000000000000000000
wf_iconbits     *       2_01111111000000000000000000000000
wf_newformat    *       2_10000000000000000000000000000000
d3988 9
a3996 5
              [ TrueIcon3
wf2_truecolour  *       2_00000001      ; use title validation string colours
                                        ; (implies w_title+4 is always used as validation string pointer, unless
                                        ; already in use as spriteareaCB ptr, or part of non-indirected string)
              ]
d3998 21
a4018 1
              [ ChildWindows
d4020 8
a4027 1
; alignment options for each item
d4029 9
a4037 4
al_s            *       0               ; align with scrolling element
al_0            *       1               ; align with left/bottom
al_1            *       2               ; align with right/top
al_reserved     *       3               ; not used (yet)
d4039 4
a4042 1
al_mask         *       3
d4044 2
a4045 1
alf_setflags    *       1 :SHL: 0       ; set this bit to alter the window's flags
d4047 6
a4052 6
als_x0          *       16              ; bit numbers (shift the above by these)
als_y0          *       18
als_x1          *       20
als_y1          *       22
als_scx         *       24
als_scy         *       26
d4054 7
a4060 6
alm_x0          *       ( al_mask :SHL: als_x0 )
alm_y0          *       ( al_mask :SHL: als_y0 )
alm_x1          *       ( al_mask :SHL: als_x1 )
alm_y1          *       ( al_mask :SHL: als_y1 )
alm_scx         *       ( al_mask :SHL: als_scx )
alm_scy         *       ( al_mask :SHL: als_scy )
d4062 14
a4075 6
al0_x0          *       ( al_0 :SHL: als_x0 )
al0_y0          *       ( al_0 :SHL: als_y0 )
al0_x1          *       ( al_0 :SHL: als_x1 )
al0_y1          *       ( al_0 :SHL: als_y1 )
al0_scx         *       ( al_0 :SHL: als_scx )
al0_scy         *       ( al_0 :SHL: als_scy )
d4077 2
a4078 1
              ]
d4080 10
a4089 3
;;-----------------------------------------------------------------------------
;; Format of data in an icon definition
;;-----------------------------------------------------------------------------
d4091 3
a4093 12
                ^       0
i_bbx0          #       4               ; bounding box (x0,y0,x1,y1)
i_bby0          #       4
i_bbx1          #       4               ; if sprite, get size instead
i_bby1          #       4
i_flags         #       4
i_data          #       12      ; up to 12 bytes of text/sprite name etc.

i_size          #       0       ; size of icon data

i_shift         *       5
             ASSERT     (i_size = 1:SHL:i_shift)
d4095 1
a4095 1
; bit masks for flags
d4097 6
a4102 12
if_text         *       2_00000000000000000000000000000001
if_sprite       *       2_00000000000000000000000000000010
if_border       *       2_00000000000000000000000000000100
if_hcentred     *       2_00000000000000000000000000001000
if_vcentred     *       2_00000000000000000000000000010000
if_filled       *       2_00000000000000000000000000100000
if_fancyfont    *       2_00000000000000000000000001000000
if_funnyicon    *       2_00000000000000000000000010000000
if_indirected   *       2_00000000000000000000000100000000
if_rjustify     *       2_00000000000000000000001000000000
if_canadjust    *       2_00000000000000000000010000000000
if_halfsize     *       2_00000000000000000000100000000000
d4104 55
a4158 4
if_buttontype   *       2_00000000000000001111000000000000
if_esg          *       2_00000000000111110000000000000000
if_esg2         *       2_00000000000011110000000000000000   ; all but top bit
if_numeric      *       2_00000000000100000000000000000000   ; Just top bit
d4160 1
a4160 1
; bit masks for status
d4162 3
a4164 3
is_inverted     *       2_00000000001000000000000000000000
is_shaded       *       2_00000000010000000000000000000000
is_deleted      *       2_00000000100000000000000000000000
d4166 2
a4167 1
; foreground and background colours
d4169 1
a4169 3
if_fcol         *       2_00001111000000000000000000000000
if_bcol         *       2_11110000000000000000000000000000
if_shadecols    *       2_00100010111111111111111111111111
d4171 54
a4224 1
; bit positions of various fields
d4226 2
a4227 5
ib_buttontype   *       12
ib_esg          *       16
ib_fcol         *       24
ib_bcol         *       28
ib_fontno       *       24              ; overlaid
a4228 1
; button types
d4230 23
a4252 11
ibt_never           *   0               ; never report
ibt_always          *   1               ; always report
ibt_autorepeat      *   2               ; button clicked (auto-repeat)
ibt_click           *   3               ; button clicked (debounced)
ibt_clickrelease    *   4               ; select if clicked, report if released
ibt_click2          *   5               ; select if clicked, report if 2 clicks
ibt_dclick          *   6               ; as for (3), but can also drag
ibt_dclickrelease   *   7               ; as for (4), but can also drag
ibt_dclick2         *   8               ; as for (5), but can also drag
ibt_menuicon        *   9               ; select when over, report on click
ibt_rdclick2        *   10              ; as for (8), but reports for 1 click
a4253 19
erf_okbox       *       1 :SHL: 0
erf_cancelbox   *       1 :SHL: 1
erf_htcancel    *       1 :SHL: 2
erf_dontwait    *       1 :SHL: 3
erf_omiterror   *       1 :SHL: 4
erf_poll        *       1 :SHL: 5       ; leave error window open
erf_pollexit    *       1 :SHL: 6       ; close error window
erf_nobeep      *       1 :SHL: 7       ; don't beep (Wimp 2.28 onwards)
erf_newtype	*	1 :SHL: 8	; new style error report (Wimp 3.21 onwards)
erf_errortype	*	7 :SHL: 9	; error type (new style only)
 [ true
erf_describe	*	1 :SHL: 23	; used internally
erf_ocontcode_shift           * 24
erf_ocontcode   *      15 :SHL: erf_ocontcode_shift   ; return code to use for Continue in "omen" window (0 => return 1)
erf_ocancelcode_shift         * 28
erf_ocancelcode *      15 :SHL: erf_ocancelcode_shift ; return code to use for Cancel in "omen" window (0 => exit handler)
 |
erf_describe	*	1 :SHL: 31	; used internally
 ]
d4255 16
a4270 1
erb_errortype	*	9
a4271 3
;;------------------------------------------------------------------------------
;; Things to do with swapping of tasks to disc
;;------------------------------------------------------------------------------
d4273 20
a4292 5
               [ Swapping

swapping_version   *  286         ; First version in which swapping is implemented.
                                  ; So that it can be changed.
               ]
d5688 1
a5688 1
copyrects  ENTRY  "R0-R2,x0,y0,x1,y1,handle,userblk"
d5764 1
a5764 1
        ENTRY   "x0-y1, handle, userblk"
@


4.9
log
@UTF-8 support from previous version switched in; additional alphabet-
conditional support added as follows:
* Correctly converts character index returned from Font_FindCaret into byte
  index into raw string.
* Left-arrow, right-arrow, delete-left and delete-right now act as far as
  the next character boundary, instead of to the next byte.
* Menu item text justification works again (it relies on overwriting spaces
  with hard space characters, which are two-byte characters in UTF-8).
* General key handling code has been rewritten. The Wimp now has three
  internal key input buffers - one each for taking keyboard-generated,
  task-generated, and function-key-generated strings. Each input buffer is
  processed in chunks of one character, rather than one byte; malformed
  UTF-8 characters are rejected, so tasks don't have to worry about them
  (simplifying their character-handling code). There is also a key output
  buffer, to ensure that (UTF-8) sequences of Key_Pressed events are not
  broken up.
* As a result of the above, multiple calls to Wimp_ProcessKey are now
  possible between calls to Wimp_Poll. Previously, this resulted in bytes
  getting jumbled up - making it useless for input of UTF-8 characters.
* Multi-byte characters are inserted into writeable icons in one go, so you
  don't see a brief flicker of the "malformed character" symbol while the
  initial bytes are being inserted.
* Multi-byte characters that don't entirely fit in a writeable icon buffer
  are not inserted at all.
* A new validation string command ("U") can limit the contents of a
  writeable by number of characters, instead of bytes. This will hide the
  character sizes from the user interface.
* Allowable characters (validation string command "A") now works on Unicode
  characters and character ranges.
* Various other minor bugs are fixed (Wimp_ProcessKey 13 can activate a
  writeable menu item, Shift-arrow keys are always consistent in firing off
  Key_Pressed events, etc.)
* Password icons supported: one symbol is displayed for each character
  (instead of for each byte); the display character (validation string
  command "D") can be any UTF-8 character; correctly displays the caret
  after set-caret-by-index calls, even though characters in the processed
  string are different width to those in the raw string, in password icons.

Other changes:
* The border around NC-style error boxes is resized when the error window
  is grown or shrunk.
* Messages, CmdHelp and Template files made consistent across resource
  directories, including support for all Ursula features.
* ShrinkableAreas turned back on in System=RCA builds.
* User interface features of desktop OS builds standardised.

Version 4.06. Tagged as 'Wimp-4_06'
@
text
@d2314 14
a2327 1
        Push    "R0,R5-R6,LR"
d2330 1
a2330 1
        Pull    "R0,R5-R6,PC"
d3554 5
@


4.8
log
@Fixed date in module help string
@
text
@d2547 1
a2547 1
	Debug	temp, "+Wimp_ReportError: flags", R1
d2549 1
a2549 1
	Debug	temp, "-Wimp_ReportError: button", R1
d2596 1
a2596 1
	Debug	temp,"string size",R0
d2841 1
d2843 1
d3466 12
d3740 1
a3740 1
savedcaretdata             #      24
d3760 8
@


4.7
log
@Spinner branch merged.
Changed to use srccommit.
All conditionals on "Version" removed.

Version 4.01. Tagged as 'Wimp-4_01'
@
text
@d367 1
a367 1
Helpstr =       "Window Manager",9,"$Module_MajorVersion ($ModuleDate)"
@


4.6
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d367 4
a370 1
Helpstr =       "Window Manager",9,"$VString ($Date)"
d1162 1
a1162 1
        
d1167 1
a1167 1
        
d1182 1
a1182 1
        
d1748 1
a1748 1
        ; Read WimpAutoFrontDelay        
d2059 1
a2059 1
        
d2457 1
d2533 1
a2533 1
	
a2537 1

d2547 1
d2549 1
d2590 1
a2590 1
	
d2593 1
a2593 1
	
d2596 1
d2606 1
a2606 1
ensuredisc  DCB "ID",0      ; followed by media type (eg. 'disc')
a2640 1
    [ Version >= 317
a2668 1
    ]
d3340 1
a3340 1
              [ Version >= 317 :LAND: mousecache
d3353 1
a3353 1
              [ Version >= 317 :LAND: mousecache
a3558 1
              [ Version >= 311
a3559 3
              |
pollwordtaskhandle #    4               ; for cycling pollword events
              ]
d3709 1
a3709 1
                      [ Version >= 317 :LAND: hvblip
a3845 1
 [ Version >= 311
a3846 1
 ]
d3888 5
d3935 1
a3935 1
              [ Version >= 317 :LAND: togglebits
d4510 2
a4511 2
x       MySWI   Wimp_Initialise         ; 0       ; Wimp_Init not nec.
p       MySWI   Wimp_CreateWindow       ; 1
d4517 1
a4517 1
xp      MySWI   Wimp_Poll               ; 7       ; Wimp_Init not nec.
d4521 5
a4525 5
p       MySWI   Wimp_GetWindowState     ; 11
p       MySWI   Wimp_GetWindowInfo      ; 12
p       MySWI   Wimp_SetIconState       ; 13
p       MySWI   Wimp_GetIconState       ; 14
p       MySWI   Wimp_GetPointerInfo     ; 15
d4529 1
a4529 1
p       MySWI   Wimp_GetCaretPosition   ; 19
d4532 1
a4532 1
p       MySWI   Wimp_WhichIcon          ; 22
d4534 4
a4537 4
x       MySWI   Wimp_SetPointerShape    ; 24      ; Wimp_Init not nec.
xp      MySWI   Wimp_OpenTemplate       ; 25      ; Wimp_Init not nec.
x       MySWI   Wimp_CloseTemplate      ; 26      ; Wimp_Init not nec.
x       MySWI   Wimp_LoadTemplate       ; 27      ; Wimp_Init not nec.
d4539 1
a4539 2
x       MySWI   Wimp_CloseDown          ; 29      ; Wimp_Init not nec.

d4541 1
a4541 1
x       MySWI   Wimp_ReportError        ; 31      ; Wimp_Init not nec.
d4543 1
a4543 1
xp      MySWI   Wimp_PollIdle           ; 33      ; Wimp_Init not nec.
d4545 5
a4549 5
x       MySWI   Wimp_SetMode            ; 35      ; Wimp_Init not nec.
x       MySWI   Wimp_SetPalette         ; 36      ; Wimp_Init not nec.
xp      MySWI   Wimp_ReadPalette        ; 37      ; Wimp_Init not nec.
x       MySWI   Wimp_SetColour          ; 38      ; Wimp_Init not nec.
p       MySWI   Wimp_SendMessage        ; 39
d4551 2
a4552 2
x       MySWI   Wimp_SpriteOp           ; 41      ; Wimp_Init not nec.
x       MySWI   Wimp_BaseOfSprites      ; 42      ; Wimp_Init not nec.
d4554 7
a4560 7
x       MySWI   Wimp_SlotSize           ; 44      ; Wimp_Init not nec.
x       MySWI   Wimp_ReadPixTrans       ; 45      ; Wimp_Init not nec.
x       MySWI   Wimp_ClaimFreeMemory    ; 46      ; Wimp_Init not nec.
x       MySWI   Wimp_CommandWindow      ; 47      ; Wimp_Init not nec.
x       MySWI   Wimp_TextColour         ; 48      ; Wimp_Init not nec.
x       MySWI   Wimp_TransferBlock      ; 49      ; Wimp_Init not nec.
x       MySWI   Wimp_ReadSysInfo        ; 50      ; Wimp_Init not nec.
d4562 2
a4563 3

p       MySWI   Wimp_GetMenuState       ; 52
x       MySWI   Wimp_RegisterFilter     ; 53      ; Wimp_Init not nec.
a4564 1

d4566 1
a4566 1
x       MySWI   Wimp_SetColourMapping   ; 56      ; Wimp_Init not nec.
d4568 2
a4569 2
x       MySWI   Wimp_SetWatchdogState   ; 58      ; 322
x       MySWI   Wimp_Extend             ; 59
d4662 1
a4662 1
        
d4788 1
a4788 1
VersionPtr      DCD     Version
d6562 1
a6562 1
        
@


4.5
log
@Printer upcall changes from Spiner merged
@
text
@d158 13
a170 1
$lab    Debug   task2,"$string called by:",#taskhandle
d486 47
d602 36
d656 1
a657 1
        Command WimpFont,1,1,Status_Keyword_Flag:OR:International_Help,WimpFontC
d664 21
d700 1
a700 1
        SWI     Territory_WriteDirection
d795 7
d845 1
a845 1
        MOVEQ   R0,#4
d847 2
a848 2
        MOVEQ   R0,#5
        CMPNE   R0,#4
d857 5
d965 20
d1158 2
d1161 2
a1162 2
        MOVVC   R0,#-1
        STRVC   R0,tiling_sprite
d1164 14
a1177 7
        BVC     %FT05
        Push    R0
        [ true                          ; don't send error back
        LDR     R0,[R0]
        LDR     R14,=ErrorNumber_WimpBadSprites
        TEQ     R0,R14                   ; not really an error!
        CLRV    EQ
d1179 1
a1179 3
        Pull    "R0,R12,PC"
05
; this merge bumps the RMA up, compress it again just in case.
d1182 2
a1183 1
      ]
a1187 2
end_iconspr
;
d1189 10
d1210 1
d1214 4
d1230 1
d1232 3
d1248 2
d1306 2
a1307 2
        DCD     2_11010000001011110000000000001100
        ASSERT  SpriteReason_BadReasonCode < 66
d1350 8
d1408 8
d1443 2
d1465 1
a1465 1
      [ debug :LAND: :LNOT: hostvdu
d1554 1
d1559 1
a1559 1
        STRB    R2,sysflags             ; read the WimpFlags CMOS
d1561 1
d1565 1
d1567 10
d1582 1
d1586 1
d1588 10
d1603 1
d1607 3
d1614 1
d1618 3
d1625 1
d1629 1
d1633 10
d1645 1
d1649 1
d1653 10
d1665 115
d1794 6
d1842 3
d1850 7
d1881 3
d1961 1
d1963 1
d2031 56
d2088 1
a2088 1
Service
d2138 4
d2269 10
d2281 1
d2299 10
a2308 1
        Pull    "PC"
d2310 6
d2446 3
a2448 1
        BEQ     finishupcall            ; this comes round if it works!
d2503 1
a2503 1
        ADR     R0,ensuredisc           ; "Please insert %0 '%1'"
d2511 1
d2518 15
d2571 28
d2893 6
d2913 9
a2921 4
getrect_firstrect       * 2_00001
getrect_updating        * 2_00010
getrect_redrawing       * 2_00100
getrect_noicons         * 2_01000
d2923 4
a2926 1
getrect_twitter         * 2_10000
d2944 3
d2957 1
a2957 1
maxrects        *       256
d3185 1
d3189 11
d3221 7
d3232 4
d3237 1
a3237 5
drg_on          *       dragsubr_on   - dragwsptr
drg_off         *       dragsubr_off  - dragwsptr
drg_move        *       dragsubr_move - dragwsptr

        ALIGN  16
d3257 5
d3263 1
d3265 1
d3294 1
d3297 1
d3314 1
d3316 1
d3379 6
a3384 1
baseofsprites   #       4               ; base of common sprite pool (in RMA)
a3458 1
        ALIGNHASH  16
d3460 68
a3527 2
RAM_SWIEntry            #       12      ; 3 instructions for getting R12 back
OScopy_ChangeDynamic    #       4       ; this must follow immediately
d3742 5
d3750 1
a3750 1
errortitle      #       200              ; for building up 'Error from ...'
d3752 1
a3752 1
errorbuttonsize * 64
d3758 20
a3796 2
iconbar_scroll_speed	  *	2	; in 100 OS units per second
iconbar_scroll_accel	  *	1	; in 100 OS units per second^2
d3808 1
a3808 1
pop_DelayTime	* 50	; centiseconds
a3865 3
	[ PoppingIconBar
iconbar_pop_previous	#	4	; where to go back to
	]
d3871 1
a3871 1
 ALIGN
d3875 3
a3877 1
 ALIGN
d3901 9
d4030 3
d4034 1
d4052 1
d4054 1
d4105 6
d4228 7
d4236 1
d4272 6
d4282 1
d4298 3
d4302 1
d4307 3
d4311 1
d4463 1
a4463 2
        TraceK  exit, "ExitWimp: restoring font and font colours"
        TraceNL exit
d4474 1
a4474 2
        TraceK  exit, "ExitWimp: calling Font_SetFontColours"
        TraceNL exit
d4571 3
d4662 2
d4685 6
d4725 11
d4842 16
d4952 2
d4966 1
a4966 1
        ADRL    R0,execcom              ; cancel exec file (just in case)
d5112 1
d5255 5
d5302 2
d5342 1
a5342 1
;; Rectangle handling routines: intrect, subrect, addrects, addtolist
d5398 1
d5434 1
a5434 1
;; Entry :  R1 --> item under consideration
d5717 21
d6240 5
d6246 1
d6269 9
d6287 1
a6287 1
        TEQ     R14,#0
d6292 12
a6303 1
14      CMP     R2,userblk
d6312 8
d6325 9
d6357 13
d6371 9
d6562 1
d6568 17
@


4.5.2.1
log
@Wimp_ReadSysInfo extended to report width of iconise button (if any)
@
text
@a3980 4
;;            12 ==> Message queue pointers, internal use
;;            13 ==> Memory debugging, internal use
;;            14 ==> Translation tables, internal use
;;            15 ==> Iconise button present
a4014 1
	B	sysinfo_IconiseButton
a4119 8

sysinfo_IconiseButton
      [ IconiseButton
	LDR	R0,iconise_width
      |
        MOV	R0,#0
      ]
	B	ExitWimp
@


4.5.2.2
log
@Hourglass depth now incremented by 1 between calls to Wimp_Poll; effect is
to automatically display hourglass whenever applications hog the CPU,
irrespective of whether they already display the hourglass themselves or not.
Hourglass is automatically smashed before any Command Windows are displayed
so that output-generating single-tasking programs are not forced to show the
hourglass due to the behaviour described above.
@
text
@a2435 4
 [ AutoHourglass
hourglass_delay	*	33		; delay before showing hourglass for "dodgy apps" in 1/100 secs
 ]

a4364 6

      [ Version >= 394 :LAND: AutoHourglass
        SWI	XHourglass_Smash	; the easy option for consistent behaviour
        CLRV
        Debug	autohg,"Hourglass_Smash at CommandWindow start"
      ]
@


4.5.2.3
log
@Added 24-bit colour selections for icons
@
text
@a2656 2
truefgcolour    #       4               ; for 24-bit colour icons
truebgcolour    #       4
@


4.5.2.4
log
@ - corrected comments re Wimp08 versus Wimp08s
 - tidied up Wimp08s
 - Added optional use of kernel lock for Wimp_ClaimFreeMemory, controlled
   by KernelLocksFreePool in Options (currently true for Ursula only)
 - restricted max size of Wimp Sprite Pool dynamic area to 16M (controlled
   by WimpSpritePoolMaxSize in s.Memory) to avoid wasted address space on
   large memory machines
@
text
@a1576 1
    [ :LNOT: KernelLocksFreePool
a1577 1
    ]
@


4.5.2.5
log
@Fixed occasional lock-ups when error boxes displayed.
Added ALIGN directive before watchdog callback label.
Added option to select double-height VDU 4 modes.
Added German resources.
Added necessary options for parallel-port debugging via the PDebugM module.
@
text
@a678 7
        [ DoubleHeightVDU4
	MOV	R3, #VduExt_ModeFlags
	MOV	R4, #1			; get back to this  (it's [R12, #-16])
	MOV	R5, #VduExt_ScrBRow
	MOV	R6, #-1			; get back to this too... ([R12, #-8])
	Push	"R3-R6"
        ]
d722 1
a722 1
        MOVEQ   R0,#VduExt_XEigFactor
d724 2
a725 2
        MOVEQ   R0,#VduExt_YEigFactor
        CMPNE   R0,#VduExt_XEigFactor
a733 5
	[ DoubleHeightVDU4
	TEQ	R0,#VduExt_XEigFactor	; squirrel this away...
	STREQ	R2,[R12,#-16]
	STRNE	R2,[R12,#-8]
	]
a836 20

	[ DoubleHeightVDU4
	; Need to establish what XEigFactor and YEigFactor are
	LDR	R0,[R12,#-8]
	CMP	R0,#-1
	BNE	%FT01
	CMP	R5, R4, LSR #1		; is yres >= xres/2?
	MOVHS	R0,#1
	MOVLO	R0,#2
01	LDR	R14,[R12,#-16]
	; is yeig(R0) > xeig(R14), don't double height
	CMP	R0,R14
	MOVHI	R0,#0
	MOVHI	R14,R5,LSR #3
	MOVLS	R0,#Flag_DoubleVertical
	MOVLS	R14,R5,LSR #4
	SUB	R14,R14,#1
	STR	R0,[R12,#-16]		; store the mode flags
	STR	R14,[R12,#-8]		; store the text height
	]
d1272 1
a1272 1
      [ debug :LAND: :LNOT: hostvdu :LAND: :LNOT: pdebug_module
a4235 2
execcom2 DCB	"Exec",0
	ALIGN
d4248 1
a4248 1
        ADR     R0,execcom2             ; cancel exec file (just in case)
@


4.5.2.6
log
@Main new features in Ursula build so far
(some are also available in other builds):

* New icon highlighting scheme - hue rotated 180 degrees, photographic negative,
  darkened 25% - suits Ursula icons better.
* Release-button window tools compile-time switch turned on.
* Any "TASK" word cleared on exit from Wimp_OpenWindow, Wimp_GetWindowState,
  Wimp_ForceRedraw and Wimp_CloseDown.
* Child windows are no longer allowed to be opened inside the icon bar.
* Message_IconizeAt generation optimised, and no longer calls non-X SWIs.
* Message_IconsChanged implemented, and switched out on speed grounds.
* Wimp_ReadSysInfo 15 removed, replaced with (new) Wimp_Extend 11.
* Backwindows are now segregated from normal windows. A new category,
  foreground windows, are added, and stay above all other windows. (The error
  box template is updated to make it a foreground window.)
* ROM sprites override RAM sprites (and duplicate RAM sprites are deleted
  during the building of the sprite lookup list, preceding the first sprite
  plot after a sprite pool update).
* Wimp_ReadSysInfo 16 added, to return sprite area pointers in order of
  priority (Wimp_BaseOfSprites retains the ROM/RAM distinction).
* Error box code altered:
  + symbolic names used for offsets into tempworkspace
  + error button text buffer enlarged
  + stretched error buttons now shrink back for next use
  + int_flush_opens called at appropriate points to ensure buttons are seen to
    slab in, and to reduce flicker when redisplaying error box at a different
    width (also fixes some redraw bugs)
  + Cancel button given the R6 type border when it will be activated by Return
    (and is therefore moved to the extreme right in such cases)
  + Escape now always selects the second-right button (unless there's only one
    button!) - this also fixes a bug when there's a single user-defined button
  + keypresses in "xxx may have gone wrong" error boxes are now correctly
    interpreted - previously the buttons available in the underlying box were
    being used to determine the effect of keys
  + maximum number of buttons increased from 4 to 8, and the machine no longer
    crashes when the maximum is exceeded
  + window stretches horizontally to keep error message to 7 lines or less
* Bugfix: opening or creating a window with a minimum x visible area coordinate
  of -1 was leading to any of smearing/flickering/recursive drawing. (This was
  actually due to a failure to recognise which windows' positions had been
  updated.)
* Features merged in from spinner branch Wimp:
  + support for UpCall_MediaSearchEndMessage added
  + control-termination allowed in upcalls (used to require null-termination)
  + escape character switched to default during error box display, then
    switched back again afterwards
* GetRectangle filters are now called with (internal) window handle in R10.
* Autohourglass is deactivated whenever WrchV is invoked. (Also optimised.)
* Action button bugfixes:
  + action buttons now deselect if the pointer is dragged off and a window tool
    is the pressed before all the buttons have been released
  + action buttons now slab in following a long (autorepeating) press on a
    scroll arrow window tool
@
text
@d584 1
a584 1
        SWI     XTerritory_WriteDirection
a1041 2
        BVS     %FT05
        
d1043 2
a1044 2
        MOV     R0,#-1
        STR     R0,tiling_sprite
d1046 7
a1052 14
        
        [ false
        MOV     R14,#ms_data            ; message block size
        STR     R14,[sp,#-ms_data]!
        MOV     R14,#0                  ; your_ref
        STR     R14,[sp,#ms_yourref]
        LDR     R14,=Message_IconsChanged
        STR     R14,[sp,#ms_action]
        MOV     R0,#User_Message
        MOV     R1,sp
        MOV     R2,#0                   ; broadcast message
        BL      int_sendmessage_fromwimp
        ADD     sp,sp,#ms_data
        CLRV                            ; ignore errors
d1054 3
a1056 1
        
d1059 1
a1059 2
      |
; this merge bumps the RMA up, compress it again just in case.
d1064 2
a1066 10
      ]
05
        Push    "R0"
        [ true                          ; don't send error back
        LDR     R0,[R0]
        LDR     R14,=ErrorNumber_WimpBadSprites
        TEQ     R0,R14                   ; not really an error!
        CLRV    EQ
        ]
        Pull    "R0,R12,PC"
a1206 8
      [ SpritePriority
        BVS     %FT06
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseofhisprites
        STRNE   R2, baseoflosprites
06
      ]
a1256 8
      [ SpritePriority
        BVS     %FT06
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseofhisprites
        STRNE   R2, baseoflosprites
06
      ]
a1446 6
      [ SpritePriority
        MOV     R0,#ReadCMOS
        MOV     R0,#1 ; ie ROM has priority - will need to add CMOS read stuff when allocated
        STR     R0,preferredpool
      ]
;
a1460 6
      [ SpritePriority
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseofhisprites
        STRNE   R2, baseoflosprites
      ]
a1502 3
        [ StretchErrorText
        STR     R0,linecount
        ]
a1856 10
      [ SpritePriority
        BNE     %FT06
        SUB     R2,R1,#4                ; R2 -> sprite area (including size)
        STR     R2,baseofromsprites
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R2, baseoflosprites
        STRNE   R2, baseofhisprites
06
      |
a1858 1
      ]
d1876 1
a1876 7
      [ SpritePriority
        LDR     R1, preferredpool
        TEQ     R1, #0 ; preserves V
        STREQ   R14, baseoflosprites
        STRNE   R14, baseofhisprites
      ]
        Pull    "R1,PC"
d2008 1
a2008 3
        BEQ     finishupcall                        ; this comes round if it works!
	TEQ	R0,#UpCall_MediaSearchEndMessage
        BEQ     finishupcall_withmessage            ; this comes round if it works!
d2063 1
a2063 1
        ADRL    R0,ensuredisc           ; "Please insert %0 '%1'"
a2070 1
      [ false
a2076 15
      |
	ADRL    r2, errorbuffer
	ADD	r3, r2, #251		;r3 holds the end address of the error buffer
	ADD	r2, r2, #4		;don't care about error number
06	LDRB	lr, [r6], #1		;read from given message
	TEQ	lr, #0			;NUL-terminated
	TEQNE	lr, #10			;test for end of line searching too far
	TEQNE	lr, #13			;test for cr
	TEQNE 	r2, r3			;test end of buffer
	STRNEB	lr, [r2], #1		;write to error buffer
	BNE	%06
	
	MOV	lr, #0			;ensure always NUL-terminated
	STRB	lr, [r2]
      ]
a2114 29
finishupcall_withmessage
        Push    "R0-R3"
;
	;Just use the message provided (copied into the same buffer)
	ADRL    r2, errorbuffer
	ADD	r3, r2, #251		;r3 holds the end address of the error buffer
	ADD	r2, r2, #4		;don't care about error number
01	LDRB	lr, [r1], #1		;read from given message
	TEQ	lr, #0			;NUL-terminated
	TEQNE	lr, #10			;test for end of line searching too far
	TEQNE	lr, #13			;test for cr
	TEQNE 	r2, r3			;test end of buffer
	STRNEB	lr, [r2], #1		;write to error buffer
	BNE	%01
	
	MOV	lr, #0			;ensure always NUL-terminated
	STRB	lr, [r2]
	
	ADRL	R0, errorbuffer
	SUB	R0, r2, r0
	Debug	temp,"string size",R0
	ADRL	R0, errorbuffer
        MOV     R1,#erf_okbox:OR:erf_poll   		; Draw the Box
        SWI     XWimp_ReportError
        MOV     R1,#erf_okbox:OR:erf_pollexit   	; Request the Box Removed
        SWI     XWimp_ReportError
;
        Pull    "R0-R3,PC",,^           ; claim vector

d2470 4
a2687 1
old_escape      #       1
d2723 1
a2723 1
        ALIGNHASH  16			; missing HASH! JRC 25 Jul 1997
a2772 1
              [ :LNOT: NewErrorSystem
a2774 1
              ]
d2854 1
a2854 6
                [ SpritePriority
preferredpool   #       4               ; 1 => ROM, 0 => RAM
baseoflosprites #       4               ; base of low priority common sprite pool
baseofhisprites #       4               ; base of high priority common sprite pool
                ]
baseofsprites   #       4               ; base of common sprite pool (in RAM)
a3146 5
 [ AutoHourglass
hourglass_delay	*	100		; delay before showing hourglass for "dodgy apps", in 1/100 secs
hourglass_status #      4               ; autohourglass status (0 => no hourglass or WrchV routine, 1 => just routine,
 ]                                      ;                       2 => routine is on vector & hourglass is pending or active)

d3150 1
a3150 1
errortitle      #       256              ; for building up 'Error from ...'
d3152 1
a3152 1
errorbuttonsize * 256
a3157 20
progerrsaveblk  #       4 * 4           ; caller R0-R3, stored while the "may have gone wrong" window is displayed
errbut_y0_def   #       4               ; bottom of default action button, read from "Continue"
errbut_y1_def   #       4               ; top of default action button, read from "Continue"
errbut_fl_def   #       4               ; icon flags of default action button, read from "Continue"
errbut_va_def   #       4               ; validation string of default action button, read from "Continue"
errbut_w_def    #       4               ; width of default action button, read from "Continue"
errbut_y0       #       4               ; bottom of action button, read from "Cancel"
errbut_y1       #       4               ; top of action button, read from "Cancel"
errbut_fl       #       4               ; icon flags of action button, read from "Cancel"
errbut_va       #       4               ; validation string of action button, read from "Cancel"
errbut_w        #       4               ; width of action button, read from "Cancel"
errapp_x0       #       4               ; LHS of application sprite
errtype_x0      #       4               ; LHS of error type sprite
errmess_x0      #       4               ; LHS of error message icon
        [ StretchErrorText
linecount       #       4               ; flags counting and returns number of lines required for error message
errmess_maxlines    *   7               ; maximum number of lines to allow for error message
errmess_increment   *   48              ; step size (in OS units) to increase error box size by when enlarging
        ]
maxno_error_buttons *   8               ; maximum number of action buttons (needs this many Additional buttons in template)
a3251 1

a3421 1
      [ ChildWindows
a3422 1
      ]
d4059 1
a4059 6
	B	err_badR0
      [ SpritePriority
	B       sysinfo_baseofsprites   ; 16 = low/high priority sprite areas
      |
        B       err_badR0
      ]
d4166 6
a4171 5
      [ SpritePriority
sysinfo_baseofsprites
        LDR     R0, baseoflosprites
        LDR     R1, baseofhisprites
        STR     R1, [sp]
a4172 1
      ]
d4408 6
a5788 1
        
a5793 17

        [ false
        BVS     %FT02
        MOV     R14,#ms_data            ; message block size
        STR     R14,[sp,#-ms_data]!
        MOV     R14,#0                  ; your_ref
        STR     R14,[sp,#ms_yourref]
        LDR     R14,=Message_IconsChanged
        STR     R14,[sp,#ms_action]
        MOV     R0,#User_Message
        MOV     R1,sp
        MOV     R2,#0                   ; broadcast message
        BL      int_sendmessage_fromwimp
        ADD     sp,sp,#ms_data
        CLRV                            ; ignore errors
02
        ]
@


4.5.2.7
log
@New features:
Dragboxes can now be clipped by and/or fixed to a given window's work area
SWI Wimp_AutoScroll implemented
Ursula icon highlighting scheme redesigned

Bugfixes:
Wimp_Extend 11 now performs the same check on R1 as the main SWI handling code
Message blocks now updated if in a dynamic area
Screenblanker now turned off when error box is displayed
ptr_double now turned off when a drag starts
@
text
@d1480 3
a1482 9
        MOV     R0, #ReadCMOS
        MOV     R0, #1 ; ie ROM has priority - will need to add CMOS read stuff when allocated
        STR     R0, preferredpool
      ]
;
      [ Autoscr
        MOV     R0, #ReadCMOS
        MOV     R0, #5 ; ie 0.5 seconds - will need to add CMOS read stuff when allocated
        STRB    R0, autoscr_default_pause
a2533 5
 [ Autoscr
dragf_anchor    *       2_00000001      ; anchor rubber boxes to work area
dragf_clip      *       2_00000010      ; clip dragbox by window visible rectangles
 ]

d2822 4
a2825 3
 [ Autoscr
dragflags       #       4               ; as passed to Wimp_DragBox in R0
 ]
a2830 8
wimpswiintercept        #       4       ; Wimp_Extend SWI intercepter
plotsprCB               #       4       ; backdrop tiling CB

        ALIGNHASH  16
; these have moved!
RAM_SWIEntry            #       12      ; 3 instructions for getting R12 back
OScopy_ChangeDynamic    #       4       ; this must follow immediately

d3044 1
d3046 2
a3047 32
 [ Autoscr
; main autoscrolling variables
autoscr_state           #       4       ; flags word
autoscr_handle          #       4       ; window being scrolled
autoscr_pz_x0           #       4       ; pause zone sizes
autoscr_pz_y0           #       4
autoscr_pz_x1           #       4
autoscr_pz_y1           #       4
autoscr_user_pause      #       4       ; minimum pause time (cs), or -1 to use default
autoscr_user_rout       #       4       ; user routine, or < &8000 to use Wimp-supplied
autoscr_user_wsptr      #       4       ; user routine workspace (if above >= &8000)

autoscr_pause           #       4       ; minimum pause time (cs) (explicit if default)
autoscr_rout            #       4       ; routine (user or Wimp)
autoscr_wsptr           #       4       ; workspace (user or Wimp)
autoscr_next_t          #       4       ; time when to start autoscrolling, or when next to update
autoscr_last_t          #       4       ; time of last update
autoscr_last_x          #       4       ; position of mouse at last examination
autoscr_last_y          #       4
autoscr_old_ptr_colours #     3*4       ; used when restoring pointer after autoscroll pointer use
autoscr_old_ptr_number  #       1
autoscr_default_pause   #       1       ; derived from CMOS (ds)
autoscr_scrolling       #       1       ; used to determine next setting of flag bit 8
autoscr_pausing         #       1       ; used to determine whether timer is dirty, also a "don't re-enter" flag

autoscr_speed_factor    *       5       ; -log2 of number of pointer offsets to scroll per centisecond
autoscr_update_delay    *       8       ; hardwired minimum interval between updates (cs)
                                        ; is necessary to ensure null events have a chance to be seen
        ALIGNHASH   4
autoscr_END             #       0
 ]

a3424 6
 [ Autoscr
                ! 0,    "#dragtype              = R12+&" :CC: :STR: :INDEX: dragtype
                ! 0,    "#dragflags             = R12+&" :CC: :STR: :INDEX: dragflags
                ! 0,    "#autoscr_state         = R12+&" :CC: :STR: :INDEX: autoscr_state
                ! 0,    " autoscr data size     =      " :CC: :STR: (:INDEX: autoscr_END - :INDEX: autoscr_state)
 ]
a4054 1
x       MySWI   Wimp_AutoScroll         ; 61      ; checks done later
a4142 2
        
        DCB     "AutoScroll",0
a4575 1
        Debug   opn, "Calling int_flush_opens to open command window"
a4717 5
      [ Autoscr
        LDR     R14, autoscr_state      ; don't reprogram pointer if autoscrolling is enabled
        TST     R14, #af_enable
        ORRNE   R3, R3, #&10
      ]
@


4.5.2.8
log
@Iconise button removed from child windows
Icon bar now jumps to the back of the stack as soon as a window is opened above
it (excluding menus, dialogue boxes and foregroud windows). This is to avoid
the ambiguous situation when the icon bar can be part-way down the window stack.
Improved co-odination between auto-fronting and Shift-F12 behaviour.
Stopped scroll offset overflow during icon bar scroll.
Numerous features made configurable:
  WimpIconBarSpeed
  WimpIconBarAcceleration
  WimpSpritePrecedence
  WimpIconiseButton
  WimpStickyEdges (although not actually implemented yet)
  WimpAutoFrontIconBar
  WimpAutoFrontDelay
  WimpAutoScrollDelay
To make room for these in CMOS, Wimp<Drag|DoubleClick><Delay|Move> and
Wimp<AutoMenu|MenuDrag>Delay options are now stored in a more compressed form
in CMOS - but the *Configure interface is unaltered.
@
text
@a473 42

        [ Autoscr
WimpAutoScrollDelayC_Help       DCB "*Configure WimpAutoScrollDelay sets the time in 1/10 second units "
                                DCB "that the pointer has to stay over the edge of a window before it starts scrolling. "
                                DCB "This only applies in certain circumstances.",cr
WimpAutoScrollDelayC_Syntax     DCB "Syntax: *Configure WimpAutoScrollDelay <delay>",0
        ]
        [ PoppingIconBar
WimpAutoFrontDelayC_Help        DCB "*Configure WimpAutoFrontDelay sets the time in 1/10 second units "
                                DCB "that the pointer has to stay at the bottom of the screen before "
                                DCB "the icon bar is brought to the front.",cr
WimpAutoFrontDelayC_Syntax      DCB "Syntax: *Configure WimpAutoFrontDelay <delay>",0
        ]

WimpIconBarSpeedC_Help          DCB "*Configure WimpIconBarSpeed sets the initial scrolling speed of the icon bar "
                                DCB "in OS units per second.",cr
WimpIconBarSpeedC_Syntax        DCB "Syntax: *Configure WimpIconBarSpeed <speed>",0

WimpIconBarAccelerationC_Help   DCB "*Configure WimpIconBarAcceleration sets the acceleration rate of an icon bar scroll "
                                DCB "in OS units per second per second.",cr
WimpIconBarAccelerationC_Syntax DCB "Syntax: *Configure WimpIconBarAcceleration <rate>",0

        [ IconiseButton
WimpIconiseButtonC_Help         DCB "*Configure WimpIconiseButton sets whether an iconise button is added to "
                                DCB "top-level windows.",cr
WimpIconiseButtonC_Syntax       DCB "Syntax: *Configure WimpIconiseButton 0|1",0
        ]
        [ PoppingIconBar
WimpAutoFrontIconBarC_Help      DCB "*Configure WimpAutoFrontIconBar sets whether the icon bar is brought to the front "
                                DCB "when the pointer is held at the bottom of the screen.",cr
WimpAutoFrontIconBarC_Syntax    DCB "Syntax: *Configure WimpAutoFrontIconBar 0|1",0
        ]
        [ SpritePriority
WimpSpritePrecedenceC_Help      DCB "*Configure WimpSpritePrecedence sets whether ROM sprites have priority over "
                                DCB "RAM sprites or vice versa.",cr
WimpSpritePrecedenceC_Syntax    DCB "Syntax: *Configure WimpSpritePrecedence RAM|ROM",0
        ]
        [ StickyEdges
WimpStickyEdgesC_Help           DCB "*Configure WimpStickyEdges sets whether 'force on screen' directions can be "
                                DCB "overridden by pushing a window 'hard' enough.",cr
WimpStickyEdgesC_Syntax         DCB "Syntax: *Configure WimpStickyEdges 0|1",0
        ]
a542 32

        [ Autoscr
WimpAutoScrollDelayC_Help       DCB "HWNMASD",0
WimpAutoScrollDelayC_Syntax     DCB "SWNMASD",0
        ]
        [ PoppingIconBar
WimpAutoFrontDelayC_Help        DCB "HWNMAFD",0
WimpAutoFrontDelayC_Syntax      DCB "SWNMAFD",0
        ]

WimpIconBarSpeedC_Help          DCB "HWNMIBS",0
WimpIconBarSpeedC_Syntax        DCB "SWNMIBS",0

WimpIconBarAccelerationC_Help   DCB "HWNMIBA",0
WimpIconBarAccelerationC_Syntax DCB "SWNMIBA",0

        [ IconiseButton
WimpIconiseButtonC_Help         DCB "HWNMICB",0
WimpIconiseButtonC_Syntax       DCB "SWNMICB",0
        ]
        [ PoppingIconBar
WimpAutoFrontIconBarC_Help      DCB "HWNMAF",0
WimpAutoFrontIconBarC_Syntax    DCB "SWNMAF",0
        ]
        [ SpritePriority
WimpSpritePrecedenceC_Help      DCB "HWNMSPP",0
WimpSpritePrecedenceC_Syntax    DCB "SWNMSPP",0
        ]
        [ StickyEdges
WimpStickyEdgesC_Help           DCB "HWNMSE",0
WimpStickyEdgesC_Syntax         DCB "SWNMSE",0
        ]
d561 1
a562 1
        Command WimpDragDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpDragDelayC
a568 18
        Command WimpIconBarSpeed,1,1,Status_Keyword_Flag:OR:International_Help,WimpIconBarSpeedC
        Command WimpIconBarAcceleration,1,1,Status_Keyword_Flag:OR:International_Help,WimpIconBarAccelerationC
        [ SpritePriority
        Command WimpSpritePrecedence,1,1,Status_Keyword_Flag:OR:International_Help,WimpSpritePrecedenceC
        ]
        [ IconiseButton
        Command WimpIconiseButton,1,1,Status_Keyword_Flag:OR:International_Help,WimpIconiseButtonC
        ]
        [ StickyEdges
        Command WimpStickyEdges,1,1,Status_Keyword_Flag:OR:International_Help,WimpStickyEdgesC
        ]
        [ PoppingIconBar
        Command WimpAutoFrontIconBar,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoFrontIconBarC
        Command WimpAutoFrontDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoFrontDelayC
        ]
        [ Autoscr
        Command WimpAutoScrollDelay,1,1,Status_Keyword_Flag:OR:International_Help,WimpAutoScrollDelayC
        ]
a1424 1
        ; Read WimpFlags
d1429 1
a1429 1
        STRB    R2,sysflags
a1430 1
        ; Read WimpDragDelay
a1433 1
        [ false
a1434 10
        |
        ANDVC   R3, R2, #&0F
        EORVC   R3, R3, #default_drag_timelimit
        MOVVC   R1, #WimpDragMoveLimitCMOS
        SWIVC   XOS_Byte
        ANDVC   R4, R2, #1 :SHL: 0
        MOVVC   R0, R3, LSL R4
        TEQ     R4, #0 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        ]
a1439 1
        ; Read WimpDoubleClickDelay
a1442 1
        [ false
a1443 10
        |
        ANDVC   R3, R2, #&0F
        EORVC   R3, R3, #default_doubleclick_timelimit
        MOVVC   R1, #WimpDoubleClickMoveLimitCMOS
        SWIVC   XOS_Byte
        ANDVC   R4, R2, #1 :SHL: 0
        MOVVC   R0, R3, LSL R4
        TEQ     R4, #0 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        ]
a1448 1
        ; Read WimpDragMove
a1451 3
        [ true
        ANDVC   R2, R2, #&7C
        ]
a1455 1
        ; Read WimpDoubleClickMove
a1458 3
        [ true
        ANDVC   R2, R2, #&7C
        ]
a1462 1
        ; Read WimpAutoMenuDelay
a1465 1
        [ false
a1468 10
        |
        ANDVC   R0, R2, #&0F
        EORVC   R0, R0, #default_automenudelay
        TST     R2, #1 :SHL: 4 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        MOVNE   R0, R0, LSL #1
        MOVVS   R0, #default_automenudelay
        ADD     R0, R0, R0, LSL #2
        MOV     R0, R0, LSL #1
        ]
a1470 1
        ; Read WimpMenuDragDelay
a1473 1
        [ false
a1476 10
        |
        ANDVC   R0, R2, #&0F
        EORVC   R0, R0, #default_menudragdelay
        TST     R2, #1 :SHL: 4 ; preserves V
        ADDNE   R0, R0, R0, LSL #2
        MOVNE   R0, R0, LSL #1
        MOVVS   R0, #default_menudragdelay
        ADD     R0, R0, R0, LSL #2
        MOV     R0, R0, LSL #1
        ]
a1478 22
        ; Read WimpIconBarSpeed
        ADR     R3, iconbarlogtable
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpAutoSubMenuTimeCMOS
        SWI     XOS_Byte
        MOVVC   R2, R2, LSR #5
        EORVC   R2, r2, #default_iconbarspeed
        MOVVS   R2, #default_iconbarspeed
        LDR     R0, [R3, R2, LSL#2]
        STR     R0, iconbar_scroll_speed
;
        ; Read WimpIconBarAcceleration
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpMenuDragDelayCMOS
        SWI     XOS_Byte
        MOVVC   R2, R2, LSR #5
        EORVC   R2, r2, #default_iconbaraccel
        MOVVS   R2, #default_iconbaraccel
        LDR     R0, [R3, R2, LSL#2]
        STR     R0, iconbar_scroll_accel
;
        ; Read WimpSpritePrecedence
d1481 1
a1481 6
        MOV     R1, #DesktopFeaturesCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 5 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
a1484 54
        ; Read WimpIconiseButton
      [ IconiseButton
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDragMoveLimitCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 7 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, iconisebutton
      ]
;
        ; ReadWimpStickyEdges
      [ StickyEdges
        MOV     R0, #ReadCMOS
        MOV     R1, #DesktopFeaturesCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 6 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, stickyedges
      ]
;
        ; Read WimpAutoFrontIconBar
      [ PoppingIconBar
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDoubleClickMoveLimitCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 7 ;preserves V
        MOVEQ   R0, #1
        MOVNE   R0, #0
        MOVVS   R0, #1
        STRB    R0, popiconbar
;
        ; Read WimpAutoFrontDelay        
        MOV     R0, #ReadCMOS
        MOV     R1, #WimpDoubleClickTimeCMOS
        SWI     XOS_Byte
        MOVVC   R3, R2, LSR #4
        EORVC   R3, R3, #default_autofrontdelay
        MOVVC   R1, #WimpDoubleClickMoveLimitCMOS
        SWIVC   XOS_Byte
        TST     R2, #1 :SHL: 1 ;preserves V
        MOVEQ   R0, R3
        MOVNE   R0, R3, LSL #1
        ADDNE   R0, R0, R0, LSL #2
        MOVVS   R0, #default_autofrontdelay
        ADD     R0, R0, R0, LSL #2
        MOV     R0, R0, LSL #1
        STR     R0, popiconbar_pause
      ]
;
        ; Read WimpAutoScrollDelay
d1487 2
a1488 12
        MOV     R1, #WimpDragTimeCMOS
        SWI     XOS_Byte
        MOVVC   R3, R2, LSR #4
        EORVC   R3, R3, #default_autoscrolldelay
        MOVVC   R1, #WimpDragMoveLimitCMOS
        SWIVC   XOS_Byte
        TST     R2, #1 :SHL: 1 ;preserves V
        MOVEQ   R0, R3
        MOVNE   R0, R3, LSL #1
        ADDNE   R0, R0, R0, LSL #2
        MOVVS   R0, #default_autofrontdelay
        STRB    R0, autoscr_default_pause ; not *10
a1584 3
iconbarlogtable
        DCD     0, 20, 50, 100, 200, 500, 1000, 2000, -1

a2525 6
default_automenudelay           *       10
default_menudragdelay           *       10
default_iconbarspeed            *       4   ; 200 OS units / sec
default_iconbaraccel            *       3   ; 100 OS units / sec^2
default_autofrontdelay          *       5
default_autoscrolldelay         *       5
a3094 17
 [ IconiseButton
iconisebutton           #       1       ; nonzero => add iconise button
 ]

 [ StickyEdges
stickyedges             #       1       ; nonzero => interpret "force on screen" as sticky
 ]

 [ PoppingIconBar
popiconbar              #       1       ; nonzero => enable autofronting
        ALIGNHASH   4
popiconbar_pause        #       4       ; configured pause time (cs)
 ]

iconbar_scroll_speed    #       4
iconbar_scroll_accel    #       4

d3364 2
d3377 1
a3377 1
pop_Front2      * 4 ; held by virtue of Shift-F12
d3434 4
@


4.5.2.9
log
@Added Ursula Service Call table
Flushes cached screen after dragbox updates
Fixed window stack behaviour so background windows interact conventionally again
  (fixes a number of window positioning bugs)
Disabled Shift-Select-close for child windows
@
text
@d1975 1
a1975 27
      [ ServiceCallTable
ServiceTable
        DCD     0                               ; flags word
        DCD     Service2 - Module_BaseAddr
        [ :LNOT: UseAMBControl
        DCD     Service_Memory                  ; &11   ;
        ]                                               ;
        DCD     Service_Reset                   ; &27   ;
        DCD     Service_NewApplication          ; &2A   ;
        DCD     Service_ModeChange              ; &46   ;
        [ :LNOT: UseAMBControl                          ;
        DCD     Service_MemoryMoved             ; &4E   ;
        ]                                               ; must be in ascending order
        DCD     Service_ResourceFSStarted       ; &59   ;
        DCD     Service_ResourceFSDying         ; &5A   ;
        DCD     Service_ResourceFSStarting      ; &60   ;
        DCD     Service_ValidateAddress         ; &6D   ;
        DCD     Service_InvalidateCache         ; &82   ;
        [ Medusa :LAND: :LNOT: UseAMBControl            ;
        DCD     Service_PagesSafe               ; &8F   ;
        ]
        DCD     0                               ; terminator
        
        DCD     ServiceTable - Module_BaseAddr
Service
        MOV     R0, R0                          ; flag service table to aware kernels
      |
a1976 24
      ]
        ; Quick reject code for old kernels
        [ :LNOT: UseAMBControl
        TEQ     R1, #Service_Memory
        TEQNE   R1, #Service_Reset
        |
        TEQ     R1, #Service_Reset
        ]
        TEQNE   R1, #Service_NewApplication
        TEQNE   R1, #Service_ModeChange
        [ :LNOT: UseAMBControl
        TEQNE   R1, #Service_MemoryMoved
        ]
        TEQNE   R1, #Service_ResourceFSStarted
        TEQNE   R1, #Service_ResourceFSDying
        TEQNE   R1, #Service_ResourceFSStarting
        TEQNE   R1, #Service_ValidateAddress
        TEQNE   R1, #Service_InvalidateCache
        [ Medusa :LAND: :LNOT: UseAMBControl
        TEQNE   R1, #Service_PagesSafe
        ]
        MOVNES  PC, LR

Service2
a3731 3
 [ PoppingIconBar
                ! 0,    "#iconbar_pop_state     = R12+&" :CC: :STR: :INDEX: iconbar_pop_state
 ]
@


4.5.2.10
log
@Redraw of dragboxes when being resized/translated optimised to reduce flicker.

Autoscroll update period extended to 12cs to reduce flicker.

Added Wimp_ReadSysInfo 17 to return configured drag-and-drop scroll startup
delay (in cs) because the CMOS storage isn't easy to read.

Identified and bracketed changes from 3.9x responsible for 24-bit icon colours.

defaultfontcolours now works correctly again.

Introduced new icon colour code. This holds icon colours in 24 bits internally
throughout, rather than treating 24-bit colour specifiers as a special case.
This results in the following bugfixes/improvements:
 * 3D faces and moat colours, and slabbed-in action button backgrounds, can
   all be specified in 24-bits
 * fading of icons is now consistent across icon types, and utilises the
   colour range of >16 colour modes
 * 3D borders now get faded along with the rest of the icon
 * action buttons can now contain sprites (background is correct, and sprite
   is not inverted)
 * various cases where anti-aliasing didn't blend in to the background
   correctly are now fixed
 * conventional and 24-bit specifiers now behave equivalently to each other -
   the same colour specified either way behaves the same when faded, used as
   an EOR colour etc. (greys are now always dithered in 1-bpp modes, even if
   specified in 24-bit)
 * behaviour is now the same whether the Wimp font is the system font or a
   fancy font (amazingly, this wasn't always the case)
 * except for 3D icons, if the icon background matches the work area
   background, it is unaffected by fading - so for example, group boxes can now
   be faded correctly

Switched out AutoHourglass (Mike was concerned about the speed hit).

Corrected *Help syntax strings for On/Off configuration options.
@
text
@d499 1
a499 1
WimpIconiseButtonC_Syntax       DCB "Syntax: *Configure WimpIconiseButton On|Off",0
d504 1
a504 1
WimpAutoFrontIconBarC_Syntax    DCB "Syntax: *Configure WimpAutoFrontIconBar On|Off",0
d514 1
a514 1
WimpStickyEdgesC_Syntax         DCB "Syntax: *Configure WimpStickyEdges On|Off",0
a3108 1
 [ TrueIcon1
a3110 7
 ]
 [ TrueIcon2
truebgcolour2   #       4               ; background colour for selected R5/R6 icons
truewellcolour  #       4               ; well colour for R6 icons
truefacecolour  #       4               ; 3D plinth colour facing light source
trueoppcolour   #       4               ; 3D plinth colour opposite light source
 ]
d3388 1
a3388 1
autoscr_update_delay    *      12       ; hardwired minimum interval between updates (cs)
a4576 5
      [ Autoscr
	B       sysinfo_pausedelay      ; 17 = drag-and-drop scroll startup delay (cs)
      |
        B       err_badR0
      ]
a4687 8
	B	ExitWimp
      ]

      [ Autoscr
sysinfo_pausedelay
        LDRB    R0, autoscr_default_pause
        ADD     R0, R0, R0, LSL #2  ; * 5
        MOV     R0, R0, LSL #1      ; * 10
@


4.5.2.11
log
@Bugfixes:

Re-opening a menu structure containing a dialogue box (especially one
containing the caret) was causing data aborts under some OSes/builds.

The minimum title bar length is now the same for windows without line borders,
even if the vertical scroll bar is also absent. This prevents cases when the
title bar shrunk so far that a graphics clipping error occurred.

Wimp_DragBox was looking in R0 for its flags, rather than R3, as specified!

If the pointer was to the right of the central zone, vertical autoscrolling
was working too slowly.

On Service_SwitchingOutputToSprite, the Wimp now re-assesses its idea of the
screen limits. This prevents Wimp_PlotIcon plots outside the current screen
bounds from being optimised out.
@
text
@a1991 3
        [ SwitchingToSprite
        DCD     Service_SwitchingOutputToSprite ; &72   ;
        ]
a2019 3
        [ SwitchingToSprite
        TEQNE   R1, #Service_SwitchingOutputToSprite
        ]
a2075 4
      [ SwitchingToSprite
        TEQ     R1, #Service_SwitchingOutputToSprite
        BEQ     switchingtosprite
      ]
a2240 9
  [ SwitchingToSprite
; Service_SwitchingOutputToSprite: cache limited graphics parameters

switchingtosprite
        Push    "R5-R6,LR"
        BL      readvduvars2            ; including new screen/sprite size etc.
        BLVC    calcborders             ; to set up dx, dy
        Pull    "R5-R6,PC"
  ]
d2516 1
a2516 1
;	Debug	temp,"string size",R0
a4142 6
      [ SwitchingToSprite
        DCD     0                     ; dummies - these are zeroed later
        DCD     0                     ;
        DCD     VduExt_XWindLimit
        DCD     VduExt_YWindLimit
      |
a4146 1
      ]
a4161 3
      [ SwitchingToSprite
        MOV     R1, #0
      |
a4162 1
      ]
a4166 3
      [ SwitchingToSprite
        MOV     R2, #0
      |
a4167 1
      ]
a4428 1
 [ Autoscr
a4429 1
 ]
d4544 1
a4544 3
;;            15 ==> disabled
;;            16 ==> R0 = low priority Wimp sprite pool, R1 = high priority sprite pool
;;            17 ==> Default autoscroll pause delay
@


4.5.2.12
log
@* When a window was reopened such that the iconise button replaces the
  toggle-size icon (or vice versa), the Wimp now spots that the relevant
  rectangle needs redrawing.
* When a window stays put, but scrolls in one direction, the unaffected
  scrollbar is no longer redrawn, in order to reduce flicker. This was
  coded, but broken, on Risc PC Wimps, but doubly broken in the Nested Wimps
  - and the flicker was particularly noticeable with Ursula's cached screen
  enabled...
* Fixed nasty bug in nested window open flushing: this seems to have been
  caused by faulty behaviour of addsub when passed a rectangle where cx0>cx1
  and/or cy0>cy1. Filtering out such cases from subrect calls in
  (old)subtract_openingchildren prevents this from being the case. The old
  behaviour was trashing the borderrects list, which resulted in the loss of
  the invalidrects list, causing full-screen redraw when a window containing
  seven (or more) child windows was scrolled or resized.
* Fixed a bug introduced in last version, whereby program error and watchdog
  error box text was overwritten with "WindowManager:Sprites22".
* Supported long pathnames for *IconSprites.
@
text
@a1185 1
      [ false
a1188 4
      |
        ADRL    R2, path_buffer         ; watchdogerrtxt isn't big enough for long pathnames, and was getting
                                        ; overwritten by the new Service_SwitchingOutputToSprite handler
      ]
a1200 1
      [ false
a1201 3
      |
        ADRL    R1, path_buffer
      ]
d2255 1
a2255 1
        Push    "R0,R5-R6,LR"
d2258 1
a2258 1
        Pull    "R0,R5-R6,PC"
d3160 1
a3160 1
dragflags       #       4               ; as passed to Wimp_DragBox in R3
a3784 2
path_buffer     #       1024            ; for building Sprites<x><y> pathnames

d5232 1
a5232 1
;; Rectangle handling routines: intrect, subrect, addrect, addtolist
a5287 1
;        Debug   opn, "subrect: called with R0,R1,cx0-cy1 =", R0, R1, cx0, cy0, cx1, cy1
d5323 1
a5323 1
;; Entry :  R0 --> item under consideration
a5605 21
;; listrects - print rectangle list to debug output
;; Entry: R0 = index of header of list to print
;;-----------------------------------------------------------------------

      [ debugopn
listrects
        ENTRY   "x0-y1, handle, userblk"
        SetRectPtrs
        Debug   opn, "Rectangle list", R0
        B       %FT02
01
        getxy   R0, x, y
        Debug   opn, "Link / x0-y1 =", R0, x0, y0, x1, y1

02      LDR     R0, [rectlinks, R0]
        CMP     R0, #nullptr
        BNE     %BT01
        EXITS
      ]

;;-----------------------------------------------------------------------
a6107 5
     [ true                                             ; BJGA bugfix
        CMP     cx0, cx1                                ; optimise out these cases -
        CMPLT   cy0, cy1                                ; they are unnecessary, and can cause intermittent bugs
        BLLT    subrect
     |
a6108 1
     ]
a6130 9
;      [ debugopn
;        Push    "R0, R1, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        LDR     R1, [sp, #2*4] ; get handle from stack
;        Debug   opn, "oldsubtract_openingchildren: next handle, borderrects =", R1, R0
;        Pull    "R0, R1, rectcoords, rectlinks"
;      ]
d6140 1
a6140 1
        TEQ     R14,#0                                  ; shouldn't that be CMP R14, #nullptr?  BJGA Apr98
d6145 1
a6145 12
14      ; handle = valid handle from openingwinds
        ; R2     = handle's old parent / old ancestor
;      [ debugopn
;        Push    "R0, R1, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        LDR     R1, [sp, #2*4] ; get handle from stack
;        Debug   opn, "oldsubtract_openingchildren: borderrects, handle, ancestor =", R0, R1, R2
;        Pull    "R0, R1, rectcoords, rectlinks"
;      ]
        CMP     R2,userblk
a6153 8
;      [ debugopn
;        Push    "R0, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        Debug   opn, "oldsubtract_openingchildren: opening list scan complete, borderrects =", R0
;        Pull    "R0, rectcoords, rectlinks"
;      ]
a6158 9
;      [ debugopn
;        Push    "R0, R1, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        LDR     R1, [sp, #2*4] ; get handle from stack
;        Debug   opn, "oldsubtract_openingchildren: found a descendent, borderrects, handle =", R0, R1
;        Pull    "R0, R1, rectcoords, rectlinks"
;      ]
a6181 13
;      [ debugopn
;        Push    "R0, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        Debug   opn, "oldsubtract_openingchildren: before subrect, borderrects =", R0
;        Pull    "R0, rectcoords, rectlinks"
;      ]
     [ true                                             ; BJGA bugfix
        CMP     cx0, cx1                                ; optimise out these cases -
        CMPLT   cy0, cy1                                ; they are unnecessary, and can cause intermittent bugs
        BLLT    subrect
     |
a6182 9
     ]
;      [ debugopn
;        Push    "R0, rectcoords, rectlinks"
;        SetRectPtrs
;        MOV     R0, #borderrects
;        LDR     R0, [rectlinks, R0]
;        Debug   opn, "oldsubtract_openingchildren: after subrect,  borderrects =", R0
;        Pull    "R0, rectcoords, rectlinks"
;      ]
@


4.5.2.13
log
@The title bar, and the back, close and iconise buttons, are no longer redrawn
when a window is resized in just the vertical direction.

All window colours can now be specified in 24-bit colour.

Where a sprite is used to plot the back, close, title, iconise, toggle-size,
adjust-size or scroll arrow icons, the sprite is now plotted using a distorted
translation table, to give the sprites the appearance of being coloured
according to the window colours.

The 3D toolsprite set now has solid titlebar sprites.

The icon bar template now uses the standard title bar colours (this optimises
redraw because of the new border tinting code).

When the toggle-size icon or title bar are to be plotted using solid sprites,
the background is no longer filled in just prior to the event (although this
will still be performed if the relevant sprite is masked). This is to reduce
flicker. Similarly, the erroneous rectangle outlines plotted behind scrollbars
have been removed.

New "TASK"-form Wimp_ForceRedraw reason codes:
  R2 = 0 => redraw whole window border (includes line borders).
  R2 = 8 => redraw iconise button.
@
text
@a1809 7
        [ TrueIcon3
        MOV     R0, #1:SHL:2
        STRB    R0, tinted_enable
        MOV     R0, #0
        STRB    R0, tinted_window
        STRB    R0, tinted_tool
        ]
d2544 1
a3145 1
                #       4               ; reserved, in case 7 icon colours are specified!
a3203 5
        [ TrueIcon3
tinted_enable   #       1               ; 1:SHL:2 => tinting enabled for current set of toolsprites
tinted_window   #       1               ; 1:SHL:2 => tinting enabled for this window (ie nonstandard colours)
tinted_tool     #       1               ; 1:SHL:2 => tinting enabled for this tool
        |
a3204 1
        ]
a3205 1
        ALIGNHASH 4
a3253 1
              [ :LNOT: TrueIcon3
a3254 1
              ]
a3443 11
 [ TrueIcon3
truetitlefg     #       4               ; title foreground and window frame colour
truetitlebg     #       4               ; title background colour
trueworkfg      #       4               ; work area foreground colour
trueworkbg      #       4               ; work area background colour
truescoutcolour #       4               ; scroll bar outer colour
truescincolour  #       4               ; scroll bar inner colour
truetitlebg2    #       4               ; title background colour when highlighted for input focus
titlecolour     #       4               ; independent of input focus status
 ]

d3790 1
a3790 1
 ALIGNHASH 4
d3796 1
a3796 1
 ALIGNHASH 4
a3948 3
 [ TrueIcon3
w_flags2        #       1               ; secondary flags
 |
a3949 1
 ]
a4018 6

              [ TrueIcon3
wf2_truecolour  *       2_00000001      ; use title validation string colours
                                        ; (implies w_title+4 is always used as validation string pointer, unless
                                        ; already in use as spriteareaCB ptr, or part of non-indirected string)
              ]
@


4.5.2.14
log
@Window tool button type is now configurable.
Windows now keep the same depth when toggle-size tool is clicked with Adjust.
Fixed bug where drags in Eureka caused branch-through-zeros and other
miscellaneous errors.
Fixed a few stray non-X form SWI calls.
Extended applicability/functionality of "MyEntry" debug macro.
@
text
@d158 1
a158 13
$lab
      [ debugtask2
        Push    "R0"
        LDR     R0, [sp, #1*4 + 11*4 + 2*4 + 2*4] ; get return address from stack - skip:
                                                  ; 1 word:   for storing R0 here
                                                  ; 11 words: registers stored by generic Wimp SWI code
                                                  ; 2 words:  for Wimp re-entrancy
                                                  ; 1 word:   return address in kernel
                                                  ; 1 word:   used by kernel
        SUB     R0, R0, #4 ; we actually want the previous instruction
        Debug   task2,"$string called by, from:",#taskhandle,R0
        Pull    "R0"
      ]
a515 5
        [ BounceClose
WimpButtonTypeC_Help            DCB "*Configure WimpButtonType sets whether the back, close, iconise and toggle-size icons "
                                DCB "act when you click on them or when you release the mouse button afterwards.",cr
WimpButtonTypeC_Syntax          DCB "Syntax: *Configure WimpButtonType Click|Release",0
        ]
a616 4
        [ BounceClose
WimpButtonTypeC_Help            DCB "HWNMBT",0
WimpButtonTypeC_Syntax          DCB "SWNMBT",0
        ]
a647 3
        [ BounceClose
        Command WimpButtonType,1,1,Status_Keyword_Flag:OR:International_Help,WimpButtonTypeC
        ]
a1223 2
;        MyEntry "SpriteOp"

a1416 2
;        MyEntry "BaseOfSprites"

a1669 12
        ; ReadWimpButtonType
      [ BounceClose
        MOV     R0, #ReadCMOS
        MOV     R1, #DesktopFeaturesCMOS
        SWI     XOS_Byte
        TST     R2, #1 :SHL: 6 ; preserves V
        MOVEQ   R0, #0
        MOVNE   R0, #1
        MOVVS   R0, #0
        STRB    R0, buttontype
      ]
;
a3453 4
 [ BounceClose
buttontype              #       1       ; nonzero => buttons are release-type
 ]

d4401 2
a4402 1
        Debug   exit, "ExitWimp: restoring font and font colours"
d4413 2
a4414 1
        Debug   exit, "ExitWimp: calling Font_SetFontColours"
a5241 2
        MyEntry "SetPointerShape"

@


4.5.2.15
log
@Window status flag bit 17 "window is fully visible" is now correctly set for
nested windows.
If the lowest window (eg most recently iconised window) is a hotkey window,
the Wimp used to hang if a keypress was not claimed by any task. Now fixed.
Hotkey events can now be delivered to nested windows.
Ctrl-Alt-Close now closes all windows, at the same nesting level, provided
that they have close buttons.
Ctr-Alt-Iconise now iconises all top-level windows that have close buttons.
Low-res versions of autoscroll pointers fixed: they had been in 256 greys!
@
text
@a3503 4
 [ MultiClose
nextwindowtoiconise     #       4       ; pointer through window stack so far
 ]

@


4.5.2.16
log
@Redraw of unfilled, font-specified icons now fixed; this caused antialising
errors, for example in CC applications' banner windows.

No longer maps anti-aliased system font character 128 to WimpSymbol tick;
this leaves character 128 free for use by Euro currency glyph.

Fixed Data Aborts in Wimp_SpriteOps 54, 57 and 58, and in *WimpKillSprite for
a sprite name found only in the ROM sprite pool.

Eureka window titles should now be redrawn correctly, without impacting the
redraw of Wimp-drawn titlebars, provided the ROM toolsprites are used. Note
that the toolsprite spritefile has regained sprite masks, but the colours
"behind" the mask are different to those in the last masked toolsprite file.
@
text
@d1306 2
a1307 2
        DCD     2_11010000001011110000001001101100
        ASSERT  SpriteReason_BadReasonCode < 64
@


4.5.2.17
log
@Faded text-plus-sprite icons in Impression and ArtWorks were being plotted
incorrectly, due to what appears to have been a workaround for a RISC OS 2
Wimp bug.

A redraw problem turned out to be due to the rectangle limit, so this has been
doubled again.

A number of window-toggling bugs are fixed:
* if a window had no title bar, shift-toggle left a gap before the top of the
  screen
* window status flag bit 19 was always cleared during a call to Wimp_SetExtent
* tasks which called Wimp_SetExtent after an Open_Window_Request (eg the Filer)
  weren't always being considered "full-size" after a shift-toggle operation
* when a non-toggled window and its shift-toggled version were the same size,
  various problems arose (window status flags being wrongly set, toggle button
  being non-responsive for next click, toggle button not being redrawn
  correctly)
@
text
@d2951 1
a2951 1
maxrects        *       512
@


4.5.2.18
log
@Corrected active point for autoscrolling pointers (was wrong in low-res modes).

Certain user-drawn dragbox routines (eg via DragASprite) don't pass the object
bounding box as the box; this was conflicting with one of the redraw
optimisations, and causing smearing when the underlying object was redrawn.
Relevant optimisation optioned out.

If a window stack-change causes the iconise button to appear or disappear,
this is now caught, and the window border is redrawn immediately.

Toggling of child windows now works - the return coordinates are linked to
the parent in the same way as the current ones. Note that this is unlikely to
be useful for anything other than alignment 0/0/0/0/0/0 children.

Return codes for the "Quit" and "Continue" buttons in "xxx may have gone wrong"
error boxes can now be specified.

Both scrollbars push in for adjust-drags.
@
text
@a2940 3
 [ PushBothBars
windowicon_bothbars     # -1            ; -15   for when both scrollbars are pushed in
 ]
a4221 7
 [ true
erf_describe	*	1 :SHL: 23	; used internally
erf_ocontcode_shift           * 24
erf_ocontcode   *      15 :SHL: erf_ocontcode_shift   ; return code to use for Continue in "omen" window (0 => return 1)
erf_ocancelcode_shift         * 28
erf_ocancelcode *      15 :SHL: erf_ocancelcode_shift ; return code to use for Cancel in "omen" window (0 => exit handler)
 |
a4222 1
 ]
@


4.5.2.19
log
@Text is now correctly justified when in an icon with validation string
commands R8, R9, R10, ...

R5/R6 type icons now behave more usefully with button types other than click,
release and auto-repeat.

Prevented coordinate overflow in dragboxes.

Stopped clipped dragboxes from flickering more than non-clipped ones.

Fixed a bug whereby data aborts occurred when generating the translation table
for inverted and/or shaded 256-colour sprites, if the first 256-colour sprite
plotted since the Wimp's cached translation table was invalidated (either by
Service_InvalidateCache or by plotting a 256-colour sprite after a non-256-
colour sprite one) was at an address that had since been invalidated or paged
out. This fixes a long-standing problem with 256-colour sprites in the desktop,
but which only happened sporadically.

Prevented palette corruption in paletted ( <256-colour) modes when the pointer
reverts from an autoscroll pointer to its original setting.

Fixed bug introduced in last build, where clicking on the bottom pixel row of a
horixontal scrollbar, or the left pixel column of a back icon, caused a crash.

All Wimp-drawn solid rectangles are now be plotted much faster - typically
around twice as fast - translating to a typical 30% increase in speed of
plotting filled icons. Improvements will be better still in cases where icons
are drawn in a non-contiguous order: this commonly affects Toolbox applications.

When a dialogue box is opened from a menu, the Wimp will no longer attempt to
place the caret in a shaded or deleted icon, but it will do so for a type-14
(writable/click/drag) icon, as well as the standard type-15 (writable) icons.
This brings it in line with KA-validation up/down arrow actions.
@
text
@d2918 4
a2921 4
getrect_firstrect       * 2_000001
getrect_updating        * 2_000010
getrect_redrawing       * 2_000100
getrect_noicons         * 2_001000
d2923 1
a2923 4
getrect_twitter         * 2_010000
 ]
 [ Autoscr
getrect_keepdragbox     * 2_100000
@


4.4
log
@Corrected setting of WatchdogTimer option to false.
Made options files specify any text wanted after the module version number.
Auto-fronting iconbar now returns to previous position rather than back, so
it interacts with Shift+F12 better.
@
text
@d1972 1
a1972 1
UpCallCode
d1980 4
a1983 4
; In    R1 = fs number
;       R2 -> media title, 0
;       r3 = device number (-1 for ADFS)
;       r4 = iteration number (so we can 'reverse poll' ADFS)
d1985 8
a1992 3
;       r6 = name of media (eg. 'disc' for FileCore)

XADFS_FloppyFlags * Auto_Error_SWI_bit + &40246
a1995 8
;        SWI     XADFS_FloppyFlags       ; 4 bytes, bits 6,7 set => can poll
;        AND     R0,R0,R0,LSL #16
;        AND     R0,R0,R0,LSL #8
;        MOVS    R0,R0,LSR #30           ; can poll if C=1,Z=0 (HI)
;        MOVHI   R5,#10                  ; poll every 1/10 sec
;        MOVLS   R5,#&10000000           ; don't poll at all!
;        ADR     R6,disc                 ; cheat

d1997 1
a1997 1
        ADRLT   R6,disc
d2020 4
d2030 1
a2030 2
        MOV     R4,R6
        LDR     R5,[sp,#32+1*4+4*4]     ; Disc name
d2033 12
d2094 1
a2094 1
deallocateptrs
@


4.3
log
@ARTtmp branch folded in
@
text
@d365 1
a365 11
      [ :LNOT:Medusa
        =       " RISC OS 3.1"
      |
      [ International_Help=0
        =       " RISC OS 3.5"
      |
      [ :LNOT:UseAMBControl
        =       " RISC OS 3.6"
      ]
      ]
      ]
d3123 8
a3139 7
iconbar_scroll_start_time #	4	; time icon bar started scrolling
iconbar_scroll_start_scx  #	4	; and where it started from
iconbar_scroll_speed	  *	2	; in 100 OS units per second
iconbar_scroll_accel	  *	1	; in 100 OS units per second^2
MaxSlowIdleEvents       #       4       ; 321nk added for PowerUtils incorporation
MaxFastIdleEvents       #       4
Threshold       *       &600
d3195 4
@


4.2
log
@Merged WIMP imported
@
text
@d54 1
a54 1
              
d76 1
a76 1
        LDR     LR,[SP],#8        
d164 4
a167 2
        Push    "R1,R2"
      [ "$x"<>"R1"
d170 1
a170 4
      [ "$y"<>"R2"
       [ "$y"="R1"
        LDR     R2,[R13,#0*4]
       |
a171 1
       ]
a174 1
        Pull    "R1,R2"
d365 11
d1004 1
a1004 1
; tries "<filename>23" if hi-res mono, and/or "<filename>20" if 2x2 OS units
d1035 3
a1037 2
        MedusaOS
        Pull    "R12,PC",EQ             ; Medusa uses DA
a1329 10
        [ Medusa
        Push    "r1"
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea             ; is there a kernel free pool
        MOVVC   R0,#1
        MOVVS   R0,#0
1
        STRB    R0,medusakernel
        Pull    "r1"
        ]
d1474 2
a1475 4
        ADRL    R14,freepoolinuse
        STRB    R0,[R14]
        ADRL    R14,wimpmodebefore
        STR     R0,[R14]
d1477 1
a1477 1
        STR     R0,[R14]                ; splats more_misc
d1483 3
a1614 5
        [ Medusa
        MedusaOS
        MOVEQ   R4,#-&10000000            ; shrink freepool as much as we can
        BLEQ    SafeChangeDynamic
        ]
d1695 1
a1695 1
    [ :LNOT UseAMBControl                       ; not our responsibility any more!
d1738 1
a1738 2
        MedusaOS
        MOVEQS  PC,lr
a1788 9
        MOV     R1,#VduExt_ModeFlags
        SWI     XOS_ReadModeVariable
        TST     R2,#Flag_HiResMono
        BEQ     %FT01

        MOV     R5,#"2"
        MOV     R6,#"3"
        B       %FT02
01
d1796 4
a1799 1
02
d1805 5
d2190 1
a2190 1
        SWIGT   AMBControl_SWI
d2231 1
a2231 1
        SWIGT   AMBControl_SWI
d2409 1
d2418 1
d2420 1
a2420 1
maxrects        *       128
d2458 1
d2460 1
d2554 1
a2554 1
              ]  
a2628 3
dx3             #       4
dy3             #       4
dy10            #       4
d2645 1
a2645 1
fpemulator_flag #       1
a2771 3
        [ Medusa
medusakernel    #       1
        ]
d2844 1
a2844 1
latestwimp      #       4
d2850 3
a2852 3
ishscroll       #       4
isvscroll       #       4
heapfreeptr     #       4
d2859 5
a2863 4
crf_vdu5caret   *       &1000000
crf_invisible   *       &2000000
crf_usercolour  *       &4000000
crf_realcolour  *       &8000000
d2924 1
a2924 1
              [ NKmessages1  
d2927 1
a2927 1
                
d2998 4
d3037 3
d3133 13
d3200 2
a3201 1
more_misc       #       2
a3203 4
wimpmodebefore   #      1               ; wimpmode before first task starts

freepoolinuse   #       1
misc            #       2
d3253 1
a3253 1
              [ :LNOT: ChildWindows  
d3328 1
a3328 1
              ]  
d3402 1
a3402 1
              [ :LNOT: ChildWindows  
d3414 1
a3414 1
              ]  
d3460 1
a3460 1
              ]  
d3541 5
a3545 4
newerrorbits    *       256             ; new error system, added 3.21
erf_describe    *       &80000000       ; used internally
errortypemask   *       &00000E00
errortypeshift  *       9
a3645 6
      [ chwidth
        MOV     R14,#6
      |
        ADD     R14,R1,R1,ASL #1
      ]
        STR     R14,dx3
a3652 5
        ADD     R14,R1,R1,ASL #1
        STR     R14,dy3
        ADD     R14,R1,R1,ASL #2
        MOV     R14,R14,ASL #1
        STR     R14,dy10
a3661 1
      [ chwidth
a3662 6
      |
        ADD     R14,R1,R1,LSL #2        ; R14 <- R1 * 5
        MOV     R14,R14,LSL #1          ; R14 <- 10 * pixel size
        CMP     R14,#16
        MOVLT   R14,#16                 ; minimum size = 16 OS units!
      ]
d4129 1
d4329 5
a4333 2
        LDR     R14,commandflag         ; ignore chars if suspended
        TST     R14,#cf_suspended       ; (UpCall handler does this)
d4365 1
a4365 1
        
d4866 1
a4866 1
      
d4882 1
a4882 1
        
d4895 1
a4895 1
        
d4897 1
a4897 1
        
d4900 1
a4900 1
        
d4903 1
a4903 1
        
d4907 1
a4907 1
        
d4909 1
a4909 1
        
d4911 1
a4911 1
        
d5022 1
a5022 1
        
d5086 1
a5086 1
        
d5094 1
a5094 1
        
d5096 1
a5096 1
        
d5111 1
a5111 1
        
d5120 1
a5120 1
        
d5122 1
a5122 1
        
d5126 1
a5126 1
        
d5167 1
a5167 1
      [ ChildWindows  
d5182 1
a5182 1
 
d5201 1
a5201 1
        
d5242 1
a5242 1
        Push    "cx0,cy0,cx1,cy1,handle,LR"
d5256 1
a5256 1
        
d5266 1
a5266 1
        
d5281 1
a5281 1
        
d5290 1
a5290 1
        
d5292 1
a5292 1
        
d5296 1
a5296 1
        
d5298 1
a5298 1
        
d5315 1
a5315 1
        Pull    "cx0,cy0,cx1,cy1,handle,PC"
d5332 1
a5332 1
        
d5340 1
a5340 1
        
d5350 1
a5350 1
        
d5376 1
a5376 1
        
d5405 1
a5405 1
        
d5410 1
a5410 1
        
d5417 1
a5417 1
        
d5432 1
a5432 1
        
d5439 1
a5439 1
       
d5457 1
a5457 1
        
d5460 1
a5460 1
        
d5465 1
a5465 1
        
d5479 1
a5479 1
        
d5484 1
a5484 1
        
d5491 1
a5491 1
        
d5506 1
a5506 1
        
d5513 1
a5513 1
       
d5531 1
a5531 1
        
d5534 1
a5534 1
        
d5539 1
a5539 1
        
d5594 1
a5594 1
      [ false   ; I don't think we actually need this one after all  
@


4.1
log
@Initial revision
@
text
@d52 5
d66 15
d1274 1
a1274 1
        Debug_Open "<Wimp$Debug>"
d1357 4
d1370 1
d1621 2
d1699 2
d1705 1
a1705 1
        [ Medusa
d1707 4
a1710 2
        BEQ     servicepagessafe              ; in wimp08, screen resize etc.
        ]
d1713 1
a1713 1
        TEQ     R1,#Service_ResourceFSStarting      ; redeclare resource files
d1715 1
a1715 1
        TEQ     R1,#Service_ResourceFSStarted       ; re-link to sprite file
d1749 3
d1753 1
d2138 1
a2138 1
        SWI     XOS_Release                       ; stop calls to watchdog on events
d2165 3
d2171 3
d2175 1
d2193 1
d2195 4
d2200 2
a2201 1
        BLGT   XROS_Module              ; free block (ignoring errors)
a2208 2


d2234 1
d2236 4
d2242 1
d2285 3
d2394 7
a2400 4
getrect_firstrect       * 2_0001
getrect_updating        * 2_0010
getrect_redrawing       * 2_0100
getrect_noicons         * 2_1000
d2555 3
d2764 3
a2894 1

d2932 4
d3101 5
d3138 7
d3244 3
a3246 1
w_active_link   #       ll_size
d3258 48
d3311 1
d3319 1
d3337 2
d3366 1
d3393 1
d3396 1
d3401 6
d3417 36
d3789 1
a3789 1
        Debug   err,"SWI #",R11
d4102 4
d4240 2
d4245 1
d4258 1
d4262 2
d4369 5
a4373 1
;
d4521 1
a4521 1
ptr_double      DCB     "ptr_double",0
d4525 1
d4863 10
d4886 38
d4968 1
d4989 14
d5009 7
d5021 3
d5025 3
d5036 1
d5038 1
d5058 2
a5059 1
;
a5060 1
;
d5063 6
a5068 1
;
d5070 81
a5150 1
;
d5165 382
d5553 1
a5553 1
invalidouterportion
d5594 1
a5594 1
markinvalidrects
d5596 11
d5608 1
a5608 1
;
d5614 1
d5616 1
d5624 1
a5624 1
;
a5652 1

d5674 1
a5674 1
         BNE     intrectslp
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a1336 4
 [ DontCheckModeOnInit
        MOV     r0, #-1
        STR     r0, currentmode
 |
a1345 1
 ]
d2339 4
a2342 7
getrect_firstrect       * 2_00001
getrect_updating        * 2_00010
getrect_redrawing       * 2_00100
getrect_noicons         * 2_01000
 [ Twitter
getrect_twitter         * 2_10000
 ]
d2831 1
a3033 5
 [ KeyboardMenus
lastxpos        #       4               ; stop mouse highlighting menus unless it moves
lastypos        #       4
 ]

a4057 2
 [ :LNOT: NoCommandPrompt		; always do this quietly
;
a4060 1

a4072 1
;
a4075 2
 ] ;	:LNOT: NoCommandPrompt
;
a4746 13
 [ Twitter
visibleoutertwitter
        Push    "lr"
        BL      checktwitter
        Pull    "lr"
        ADDNE   r0, handle, #w_x0
        LDMNEIA r0, {x0,y0,x1,y1}
        SUBNE   y0, y0, #2
        ADDNE   y1, y1, #2
        BNE     visibleportion_x0y0x1y1
        ; if twitter not required then drop through to visibleouterportion
 ]
 
@


4.1.7.2
log
@Rectangle filters not called when caret moves.
Post-rectangle and post-icon filters added.
@
text
@a2945 4
postrectfilterWP #     4               ; post-get-rectangle filter
postrectfilter   #     4
posticonfilterWP #     4               ; post-icon-draw filter
posticonfilter   #     4
d4777 1
a4777 1

@


4.1.7.3
log
@Modify UpCall handler; restore font colours before calling Service_WimpReportError at end of SWI Wimp_ReportError.
@
text
@d1959 1
a1959 1
UpCallCode	ROUT
d1967 4
a1970 4
; In    r1 = fs number
;       r2 -> media name, or = -1 => r6 -> message
;       r3 = device number (-1 for irrelevant)
;       r4 = iteration number (so we can 'reverse poll' if required)
d1972 3
a1974 8
;       r6 -> media type (eg. 'disc' for FileCore) (if r2 <> -1)
;          = -1 for disc (if r2 <> -1)
;          -> complete message to display (if r2 = -1)

; Note  P R M p1-179 says that r2 may be -1 if irrelevant, the comment above
;       said it may be 0. Both were wrong. We take advantage of the
;       documentation to provide slightly modified behaviour, since no-one
;       can have been relying on r2 = -1 working before.
d1978 8
d1987 1
a1987 1
        ADRLTL	R6,disc
a2009 4
	LDR	r5, [sp, #32+1*4+4*4]	; media name or -1
	CMP	r5, #-1
	BEQ	%04

d2016 2
a2017 1
        MOV     R4,R6			; media type
a2019 12

	B	%05
04
	;Just use the message provided (copied into the same buffer)
	ADRL    r2, errorbuffer
	ADD	r2, r2, #4		;don't care about error number
06	LDRB	lr, [r6], #1		;read from given message
	STRB	lr, [r2], #1		;write to error buffer
	TEQ	lr, #0			;NUL-terminated
	BNE	%06
05

d2069 1
a2069 1
deallocateptrs	ROUT
@


4.1.7.4
log
@When building for NCs, use IconHigh in error boxes, use different button
border colours, use replacement Templates file.
@
text
@a2612 1
old_escape      #       1
@


4.1.7.5
log
@Added code to the upcall proceedure to test for end of line and end of buffer
in error messages.
@
text
@d1961 2
a1962 4
        BEQ     finishupcall		            ; this comes round if it works!
	TEQ	R0,#UpCall_MediaSearchEndMessage
        BEQ     finishupcall_withmessage            ; this comes round if it works!
	
a1965 1
        
d2016 1
a2016 1
        ADRL    R0,ensuredisc           ; "Please insert %0 '%1'"
a2024 1
	ADD	r3, r2, #251		;r3 holds the end address of the error buffer
d2027 1
a2028 4
	TEQNE	lr, #10			;test for end of line searching too far
	TEQNE	lr, #13			;test for cr
	TEQNE 	r2, r3			;test end of buffer
	STRNEB	lr, [r2], #1		;write to error buffer
a2029 4
	
	MOV	lr, #0			;ensure always NUL-terminated
	STRB	lr, [r2]
	
d2031 1
d2059 1
a2059 1
        
a2066 29
        
finishupcall_withmessage
        Push    "R0-R3"
;
	;Just use the message provided (copied into the same buffer)
	ADRL    r2, errorbuffer
	ADD	r3, r2, #251		;r3 holds the end address of the error buffer
	ADD	r2, r2, #4		;don't care about error number
01	LDRB	lr, [r1], #1		;read from given message
	TEQ	lr, #0			;NUL-terminated
	TEQNE	lr, #10			;test for end of line searching too far
	TEQNE	lr, #13			;test for cr
	TEQNE 	r2, r3			;test end of buffer
	STRNEB	lr, [r2], #1		;write to error buffer
	BNE	%01
	
	MOV	lr, #0			;ensure always NUL-terminated
	STRB	lr, [r2]
	
	ADRL	R0, errorbuffer
	SUB	R0, r2, r0
	Debug	temp,"string size",R0
	ADRL	R0, errorbuffer
        MOV     R1,#erf_okbox:OR:erf_poll   		; Draw the Box
        SWI     XWimp_ReportError
        MOV     R1,#erf_okbox:OR:erf_pollexit   	; Request the Box Removed
        SWI     XWimp_ReportError
;
        Pull    "R0-R3,PC",,^           ; claim vector
d2069 1
a2069 1
ensuredisc  DCB "ID", 0                  ; followed by media type (eg. 'disc')
@


4.1.7.6
log
@   When turning the pointer off before Wimp_Report, save the state and
set it back to that state afterwards.
   Allow Wimp_GetPointerInfo, Wimp_GetWindowInfo, Wimp_GetWindowState outside
a task: needed to make IconHigh work in a ReportError box which has itself been
invoked from outside a task.
@
text
@d2686 1
a2686 1
        ALIGNHASH  16			; missing HASH! JRC 25 Jul 1997
a3204 5
              
		[	BuildForNC
ptrshlflag	#	4		; Pointer shape and linkage flag (saved here during
					; ReportError) JRC 25 Jul 1997
		]
d3699 2
a3700 2
x       MySWI   Wimp_Initialise         ; 0       ; Wimp_Init not necessary
p       MySWI   Wimp_CreateWindow       ; 1       ; check for owner window
d3706 1
a3706 1
xp      MySWI   Wimp_Poll               ; 7       ; Wimp_Init not necessary; check for owner window
d3710 5
a3714 5
xp	MySWI   Wimp_GetWindowState     ; 11      ; Wimp_Init not necessary; check for owner window
xp	MySWI   Wimp_GetWindowInfo      ; 12      ; Wimp_Init not necessary; check for owner window
p       MySWI   Wimp_SetIconState       ; 13      ; check for owner window
p       MySWI   Wimp_GetIconState       ; 14      ; check for owner window
xp	MySWI   Wimp_GetPointerInfo     ; 15      ; Wimp_Init not necessary; check for owner window
d3718 1
a3718 1
p       MySWI   Wimp_GetCaretPosition   ; 19      ; check for owner window
d3721 1
a3721 1
p       MySWI   Wimp_WhichIcon          ; 22      ; check for owner window
d3723 4
a3726 4
x       MySWI   Wimp_SetPointerShape    ; 24      ; Wimp_Init not necessary
xp      MySWI   Wimp_OpenTemplate       ; 25      ; Wimp_Init not necessary; check for owner window
x       MySWI   Wimp_CloseTemplate      ; 26      ; Wimp_Init not necessary
x       MySWI   Wimp_LoadTemplate       ; 27      ; Wimp_Init not necessary
d3728 2
a3729 1
x       MySWI   Wimp_CloseDown          ; 29      ; Wimp_Init not necessary
d3731 1
a3731 1
x       MySWI   Wimp_ReportError        ; 31      ; Wimp_Init not necessary
d3733 1
a3733 1
xp      MySWI   Wimp_PollIdle           ; 33      ; Wimp_Init not necessary; check for owner window
d3735 5
a3739 5
x       MySWI   Wimp_SetMode            ; 35      ; Wimp_Init not necessary
x       MySWI   Wimp_SetPalette         ; 36      ; Wimp_Init not necessary
xp      MySWI   Wimp_ReadPalette        ; 37      ; Wimp_Init not necessary; check for owner window
x       MySWI   Wimp_SetColour          ; 38      ; Wimp_Init not necessary
p       MySWI   Wimp_SendMessage        ; 39      ; check for owner window
d3741 2
a3742 2
x       MySWI   Wimp_SpriteOp           ; 41      ; Wimp_Init not necessary
x       MySWI   Wimp_BaseOfSprites      ; 42      ; Wimp_Init not necessary
d3744 7
a3750 7
x       MySWI   Wimp_SlotSize           ; 44      ; Wimp_Init not necessary
x       MySWI   Wimp_ReadPixTrans       ; 45      ; Wimp_Init not necessary
x       MySWI   Wimp_ClaimFreeMemory    ; 46      ; Wimp_Init not necessary
x       MySWI   Wimp_CommandWindow      ; 47      ; Wimp_Init not necessary
x       MySWI   Wimp_TextColour         ; 48      ; Wimp_Init not necessary
x       MySWI   Wimp_TransferBlock      ; 49      ; Wimp_Init not necessary
x       MySWI   Wimp_ReadSysInfo        ; 50      ; Wimp_Init not necessary
d3752 3
a3754 2
p       MySWI   Wimp_GetMenuState       ; 52      ; check for owner window
x       MySWI   Wimp_RegisterFilter     ; 53      ; Wimp_Init not necessary
d3756 1
d3758 1
a3758 1
x       MySWI   Wimp_SetColourMapping   ; 56      ; Wimp_Init not necessary
d3760 2
a3761 2
x       MySWI   Wimp_SetWatchdogState   ; 58      ; Wimp_Init not necessary      ; 322
x       MySWI   Wimp_Extend             ; 59      ; Wimp_Init not necessary
@


4.1.7.7
log
@   Return result from Wimp_Report *before* corrupting it.
@
text
@a2050 1
	Debug	temp, "+Wimp_ReportError: flags", R1
a2051 1
	Debug	temp, "-Wimp_ReportError: button", R1
@


4.1.7.8
log
@Added new flag, PreservePointerOnError, to control whether the mouse pointer
state is preserved over errors. This is also dependent on BuildForNC being true.
@
text
@d3208 1
a3208 1
		[	PreservePointerOnError
@


4.1.7.2.2.1
log
@AMBControl task switching merged from RO_3_70 branch.
PlotSpritesFromPalette and TwitterOnlyMenus options added.
ChildWindows merged in.
@
text
@a51 5
              [ ChildWindows
u_flags         #       4               ; for supplying new window flags (new form of Wimp_OpenWindow)

                ^       u_ow1
              ]
a60 15
$lab    CheckAllWindows $message
$lab
      [ debugcheck :LAND: debug
        Push    "LR,PC"
        BL      checkallwindows
        BNE     %FT01
        Debug   check,"**** Bad window data found [ $message ] ****"
01
        LDR     R14,[SP,#4]
        TEQP    R14,#0
        LDR     LR,[SP],#8
      ]
        MEND

        MACRO
a347 11
      [ false ; Some check here?
        =       " RISC OS 3.1"
      |
      [ International_Help=0
        =       " RISC OS 3.5"
      |
      [ :LNOT:UseAMBControl
        =       " RISC OS 3.6"
      ]
      ]
      ]
d1254 1
a1254 1
        Debug_Open "<Wimp$Debug>1"
a1600 2
        Debug   opn,"---- Debug closing down ----"

a1676 2

    [ :LNOT UseAMBControl                       ; not our responsibility any more!
d1681 1
a1681 1
      [ Medusa
d1683 2
a1684 4
        BEQ     servicepagessafe                ; in wimp08, screen resize etc.
      ]
    ]

d1687 1
a1687 1
        TEQ     R1,#Service_ResourceFSStarting  ; redeclare resource files
d1689 1
a1689 1
        TEQ     R1,#Service_ResourceFSStarted   ; re-link to sprite file
a1722 3
      [ ChildWindows
        LDRB    r14,memoryOK                            ; BUGFIX: NRaine 6-Aug-96 (should be unconditional)
      |
a1723 1
      ]
d2108 1
a2108 1
        SWI     XOS_Release                     ; stop calls to watchdog on events
a2134 3

        Debug   opn,"**** Discarding window on wimp dying ****",R2

a2137 3
      [ ChildWindows                            ; make this unconditional when merging sources back in
        LDR     R2,allwinds+lh_forwards         ; BUGFIX: NRaine 2-Aug-96: discard ALL windows, not just the open ones!
      |                                         ;         It actually breaks otherwise, since w_all_link is used (see above)
a2138 1
      ]
a2155 1
        Debug   mjs2," wimp01 (1) slotptr to free",R2
a2156 4
      [ UseAMBControl
        MOVGT   R0,#1   ;deallocate reason code
        SWIGT   XOS_AMBControl
      |
d2158 1
a2158 2
        BLGT   XROS_Module                      ; free block (ignoring errors)
      ]
d2166 2
a2192 1
        Debug   mjs2," wimp01 (2) slotptr to free",R2
a2193 4
      [ UseAMBControl
        MOVGT   R0,#1   ;deallocate reason code
        SWIGT   XOS_AMBControl
      |
a2195 1
      ]
a2237 3
      [ NKmessages1
        STR     R14,lastpointer
      ]
a2504 3
              [ ChildWindows
oldinvalidrects #       4
              ]
a2710 3
              [ ChildWindows
openspending    #       1               ; whether we're in the middle of a set of opens
              ]
a2875 4
              [ NKmessages1
lastpointer     #       4               ; end of message queue (NK's optimise)
              ]

a3081 7
        [ ChildWindows
newparent       #       4               ; parameter for Wimp_OpenWindow
newalignflags   #       4               ; parameter for Wimp_OpenWindow
oldactivewinds  #       lh_size         ; used for deferred opening
openingwinds    #       lh_size         ; ditto
heldoverwinds   #       4               ; singly-linked list for windows that are optimized out
        ]
d3181 1
a3181 3
              [ :LNOT: ChildWindows
w_active_link   #       ll_size         ; this has moved!
              ]
a3192 48
              [ ChildWindows
w_bwax0         #       4               ; previous position/size (for toggling)
w_bway0         #       4
w_bwax1         #       4
w_bway1         #       4
w_bscx          #       4               ; previous x,y scroll positions
w_bscy          #       4
w_bbhandle      #       4               ; previous window it was behind

w_alignflags    #       4               ; auto-alignment with parent window

w_opening_link  #       ll_size         ; for the list of windows being opened, and the block-copy rectangles
w_xoffset       #       4
w_yoffset       #       4
w_oldwindowrects  #     4               ; list of rectangles to be block-copied for this window

w_old_data      #       0               ; start of old version of current position

w_old_children  #       lh_size         ; children of this window (chained by w_active_link)
w_old_link      #       ll_size

w_old_parent    #       4               ; parent of this window (if any)

w_old_x0        #       4
w_old_y0        #       4               ; 'current' position, ie. the most-recently-displayed
w_old_x1        #       4               ; these are used for collecting up Wimp_OpenWindows
w_old_y1        #       4

w_old_wax0      #       4               ; x,y coordinates of work area
w_old_way0      #       4               ; (ie. corners)
w_old_wax1      #       4               ;
w_old_way1      #       4
w_old_scx       #       4               ; x,y scroll positions
w_old_scy       #       4               ; (between wex0/y0 and wex1/y1)

w_old_bhandle   #       4               ; not used, but keeps the structures in line

w_old_flags     #       4               ; status of window (open/closed etc.)

w_old_end       #       0

w_new_data      #       0               ; start of new version of current position

w_children      #       lh_size         ; children of this window (chained by w_active_link)
w_active_link   #       ll_size         ; this has moved!

w_parent        #       4               ; parent of this window (if any)
              ]
a3197 1
              [ :LNOT: ChildWindows     ; this has moved!
a3204 1
              ]
a3221 2
w_new_end       #       0

a3248 1
        ASSERT  (w_old_end - w_old_data) = (w_new_end - w_new_data)
a3274 1
              [ :LNOT: ChildWindows
a3276 1
              ]
a3280 6
              [ ChildWindows
ws_system       *       2_00000000011111110000000000000000

wf_inborder     *       2_00000000100000000000000000000000      ; child window can overlap parent's border
              ]

a3290 36
              [ ChildWindows

; alignment options for each item

al_s            *       0               ; align with scrolling element
al_0            *       1               ; align with left/bottom
al_1            *       2               ; align with right/top
al_reserved     *       3               ; not used (yet)

al_mask         *       3

alf_setflags    *       1 :SHL: 0       ; set this bit to alter the window's flags

als_x0          *       16              ; bit numbers (shift the above by these)
als_y0          *       18
als_x1          *       20
als_y1          *       22
als_scx         *       24
als_scy         *       26

alm_x0          *       ( al_mask :SHL: als_x0 )
alm_y0          *       ( al_mask :SHL: als_y0 )
alm_x1          *       ( al_mask :SHL: als_x1 )
alm_y1          *       ( al_mask :SHL: als_y1 )
alm_scx         *       ( al_mask :SHL: als_scx )
alm_scy         *       ( al_mask :SHL: als_scy )

al0_x0          *       ( al_0 :SHL: als_x0 )
al0_y0          *       ( al_0 :SHL: als_y0 )
al0_x1          *       ( al_0 :SHL: als_x1 )
al0_y1          *       ( al_0 :SHL: als_y1 )
al0_scx         *       ( al_0 :SHL: als_scx )
al0_scy         *       ( al_0 :SHL: als_scy )

              ]

d3627 1
a3627 1
        Debug   err,"SWI #, task",R11,#taskhandle
a3939 4
      [ NKmessages1
        ADRL    R1,lastpointer
        STMIA   sp,{R1}
      ]
d4203 1
a4203 5

      [ ChildWindows
        BLVC    int_flush_opens         ; flush this before calling visibleouterportion
      ]

d4351 1
a4351 1
ptr_double      DCB     "ptr_double",0          ; now moved so that starterrorbox_draw can access ptr_default
a4354 1

a4691 10
      [ ChildWindows
assign_set      ROUT
        Push    "userblk,handle,LR"
        SetRectPtrs
        BL      assign
        Pull    "userblk,handle,PC"
      ]

; NB: This version assumes that SetRectPtrs has already been called

a4706 38
;; copyrects - copy a set of rectangles
;; Entry :  R0 = source index
;;          R1 = destination index
;; Exit  :  rectangles copied
;;------------------------------------------

      [ ChildWindows

copyrects  ENTRY  "R0-R2,x0,y0,x1,y1,handle,userblk"

        Debug   opn,"copyrects from/to",R0,R1

        SetRectPtrs

        MOV     R0,R1
        BL      loserects

        LDR     R0,[SP]
        MOV     R2,R1

01      LDR     R0,[rectlinks,R0]
        CMP     R0,#nullptr
        BEQ     %FT90

        getxy   R0,x,y

        Debug   opn,"copying rectangle",x0,y0,x1,y1

        BL      newrect
        CMP     R1,#nullptr
        STRNE   R1,[rectlinks,R2]
        MOVNE   R2,R1
        BNE     %BT01
90
        EXITS
      ]

;;------------------------------------------
a4748 1

d4769 1
a4769 1
      [ Twitter
a4770 1

d4780 1
a4780 1
      ]
a4787 7
      [ ChildWindows
        Push    "R1,LR"
        BL      visibleportion
        MOV     R1,#0
        BL      subtract_children       ; don't include children of this window
        Pull    "R1,PC"
      ]
a4792 3
      [ ChildWindows
        Push    "cx0,cy0,cx1,cy1,handle,userblk,LR"
      |
a4793 3
      ]

        Debug   child,"visibleportion_x0y0x1y1",handle,x0,y0,x1,y1
a4801 1
      [ :LNOT: ChildWindows
a4802 1
      ]
d4822 1
a4822 2

      [ :LNOT: ChildWindows
d4824 1
d4827 1
a4827 6
      |
        CMP     R1,#nullptr
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,PC",EQ ; done if not in stack
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,LR"
        ; drop through

d4829 1
a4829 81
; In    handle -> window definition
;       [rectlinks,#windowrects] = rectangle(s) so far
; Out   [rectlinks,#windowrects] = visible parts of original set

visible_knockout        ROUT

        Push    "cx0,cy0,cx1,cy1,handle,userblk,LR"

40      LDR     R0,[handle,#w_flags]
        TST     R0,#wf_inborder
        MOVEQ   R0,#nullptr
        LDRNE   R0,[handle,#w_parent]
        CMPNE   R0,#nullptr
        ADDNE   R0,R0,#w_wax0                   ; we'll need to clip non-border siblings to this

        LDR     R2,[handle,#w_active_link + ll_backwards]

41      LDR     R3,[R2,#ll_backwards]
        CMP     R3,#nullptr
        BEQ     %FT45

        Push    "R0,R2,R3"

        CMP     R0,#nullptr
        LDRNE   userblk,[R2,#w_flags-w_active_link]

        ADD     R14,R2,#w_x0-w_active_link
        LDMIA   R14,{cx0,cy0,cx1,cy1}

        BEQ     %FT42

        TST     userblk,#wf_inborder
        BNE     %FT42

        LDMIA   R0,{x0,y0,x1,y1}
        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1
42
        Debug   child,"subtract sibling",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,R0
        BL      subrect
        Pull    "R0,R2,R3"

        MOV     R2,R3
        B       %BT41

45      LDR     userblk,[handle,#w_flags]       ; keep window flags

        LDR     handle,[handle,#w_parent]
        CMP     handle,#nullptr
        BEQ     %FT50

        ; check whether the parent window is closed

        LDR     R14,[handle,#w_flags]
        TST     R14,#ws_open
        BEQ     %FT70

        ; clip window list to the parent's work area or outline

        TST     userblk,#wf_inborder
        ADDNE   R14,handle,#w_x0                ; clip to outer box if allowed to overlap border
        ADDEQ   R14,handle,#w_wax0              ; clip to work area otherwise
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        Debug   child,"clip to parent work area",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,R0
        BL      intrect

        ; now continue by knocking out the siblings of the parent

        B       %BT40

70      BL      losewindowrects                 ; parent closed => so is child

50
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,PC"
      |
a4843 382
      ]

;;-----------------------------------------------------------------------
;; oldvisibleportion - find old visible rectangle list for a given window
;;-----------------------------------------------------------------------

      [ ChildWindows

      [ Twitter
oldvisibleoutertwitter

        Push    "lr"
        BL      checktwitter
        Pull    "lr"
        ADDNE   r0, handle, #w_old_x0
        LDMNEIA r0, {x0,y0,x1,y1}
        SUBNE   y0, y0, #2
        ADDNE   y1, y1, #2
        BNE     oldvisibleportion_x0y0x1y1
        ; if twitter not required then drop through to oldvisibleouterportion
      ]

oldvisibleouterportion
        ADD     R0,handle,#w_old_x0
        B       oldvisibleportion

oldvisibleinnerportion
        ADD     R0,handle,#w_old_wax0

        Push    "R1,LR"
        BL      oldvisibleportion
        MOV     R1,#0                   ; subtract all children
        BL      oldsubtract_children    ; don't include children of this window
        Pull    "R1,PC"

oldvisibleportion
        LDMIA   R0,{x0,y0,x1,y1}        ; get relevant coordinates

oldvisibleportion_x0y0x1y1
        Push    "cx0,cy0,cx1,cy1,handle,userblk,LR"

        Debug   child,"oldvisibleportion_x0y0x1y1",handle,x0,y0,x1,y1

        ADR     R14,scrx0
        LDMIA   R14,{cx0,cy0,cx1,cy1}

        LDR     R1,[handle,#w_old_flags]

; create a one-rectangle list in windowrects

        SetRectPtrs

        max     x0,cx0                  ; off-screen bits are invisible
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1                  ; need this cos not using 'addtolist'

        CMP     x0,x1
        CMPLT   y0,y1
        MOVGE   R1,#nullptr
        BGE     %FT01                   ; null list if rectangle is null

        TST     R1,#ws_open             ; R1 still = status
        MOVEQ   R1,#nullptr
        BLNE    newrect                 ; coords are x0,y0,x1,y1

01      BL      losewindowrects
        STR     R1,[rectlinks,R0]

        CMP     R1,#nullptr
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,PC",EQ ; done if not in stack
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,LR"
        ; drop through

; go through windows above this one, knocking them out
; In    handle -> window definition
;       [rectlinks,#windowrects] = rectangle(s) so far
; Out   [rectlinks,#windowrects] = visible parts of original set

oldvisible_knockout     ROUT

        Push    "cx0,cy0,cx1,cy1,handle,LR"

40      LDR     R0,[handle,#w_old_flags]
        TST     R0,#wf_inborder
        MOVEQ   R0,#nullptr
        LDRNE   R0,[handle,#w_old_parent]
        CMPNE   R0,#nullptr
        ADDNE   R0,R0,#w_old_wax0                ; we'll need to clip non-border siblings to this

        LDR     R2,[handle,#w_old_link + ll_backwards]

41      LDR     R3,[R2,#ll_backwards]
        CMP     R3,#nullptr
        BEQ     %FT45

        Push    "R0,R2,R3"

        CMP     R0,#nullptr
        LDRNE   userblk,[R2,#w_old_flags-w_old_link]

        ADD     R14,R2,#w_old_x0-w_old_link
        LDMIA   R14,{cx0,cy0,cx1,cy1}

        BEQ     %FT42

        TST     userblk,#wf_inborder
        BNE     %FT42

        LDMIA   R0,{x0,y0,x1,y1}
        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1
42
        Debug   child,"subtract sibling",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,R0
        BL      subrect
        Pull    "R0,R2,R3"

        MOV     R2,R3
        B       %BT41

45      LDR     userblk,[handle,#w_old_flags]

        LDR     handle,[handle,#w_old_parent]
        CMP     handle,#nullptr
        BEQ     %FT50

        ; check whether the parent window was closed

        LDR     R14,[handle,#w_old_flags]
        TST     R14,#ws_open
        BEQ     %FT70

        ; clip window list to the parent's work area or outline

        TST     userblk,#wf_inborder
        ADDNE   R14,handle,#w_old_x0            ; clip to parent's outline if child can go in border
        ADDEQ   R14,handle,#w_old_wax0          ; clip to parent's work area otherwise
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        Debug   child,"clip to parent work area",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,R0
        BL      intrect

        ; now continue by knocking out the siblings of the parent

        B       %BT40

70      BL      losewindowrects                 ; parent closed => so is child

50
        Pull    "cx0,cy0,cx1,cy1,handle,PC"
      ]

;;--------------------------------------------------------------------------
;; subtract_children - remove child windows' outer rectangles from windowrects
;; In:  R1 = 0 => subtract all child windows
;;      R1 = wf_inborder => subtract border children only
;;      handle -> parent window
;;      [windowrects] set up (already within work area of parent)
;; Out: [windowrects] updated
;;--------------------------------------------------------------------------

      [ ChildWindows

subtract_children ROUT

        Push    "cx0,cy0,cx1,cy1,handle,LR"

        Debug   child,"Subtract children",handle

        LDR     handle,[handle,#w_children+lh_forwards]

10      LDR     R14,[handle,#ll_forwards]
        CMP     R14,#nullptr                                    ; Has end been reached?
        BEQ     %FT20

        LDR     cx0,[handle,#w_flags - w_active_link]
        AND     cx0,cx0,R1                                      ; don't do it if R1<>0 and bit not set
        TEQ     cx0,R1
        ADDEQ   R14,handle,#w_x0 - w_active_link
        LDMEQIA R14,{cx0,cy0,cx1,cy1}
        Debug   child,"Subtracting child window rectangle",handle,cx0,cy0,cx1,cy1
        Push    "R1"
        BLEQ    subwindowrect
        Pull    "R1"

        LDR     handle,[handle,#ll_forwards]
        B       %BT10
20
        Pull    "cx0,cy0,cx1,cy1,handle,PC"

;...........................................................................

; In    R1 = 0 => subtract all child windows
;       R1 = wf_inborder => subtract border children only
;       handle -> parent window
;       windowrects = rectangle list to subtract children from (already less than work area)
; Out   unclipped old outer rectangles of relevant children subtracted from rectangle list
;       we assume there's no need to clip the child rectangles, as the rectangle list is already clipped to it

oldsubtract_children ROUT

        Push    "cx0,cy0,cx1,cy1,handle,LR"

        Debug   child,"Old Subtract children",handle

        LDR     handle,[handle,#w_old_children+lh_forwards]

10      LDR     R14,[handle,#ll_forwards]
        CMP     R14,#nullptr                             ; Has end been reached?
        BEQ     %FT20

        LDR     cx0,[handle,#w_old_flags - w_old_link]
        AND     cx0,cx0,R1                                      ; don't do it if R1<>0 and bit not set
        TEQ     cx0,R1
        ADDEQ   R14,handle,#w_old_x0 - w_old_link
        LDMEQIA R14,{cx0,cy0,cx1,cy1}
        Debug   child,"Subtracting OLD child window rectangle",handle,cx0,cy0,cx1,cy1
        Push    "R1"
        BLEQ    subwindowrect
        Pull    "R1"

        LDR     handle,[handle,#ll_forwards]
        B       %BT10
20
        Pull    "cx0,cy0,cx1,cy1,handle,PC"

;...........................................................................

; In    handle -> parent window
;       R0 = rectangle list to subtract children from
; Out   clipped new outer rectangles of OPENING children subtracted from rectangle list
;       R1 corrupted
; Note: We must also deal with opening grandchildren, where the windows in between aren't in the opening list
;       This causes problems, as we could otherwise end up with overlapping rectangles to be copied
; Note: If a parent is opening/closing, all descendents are removed from the opening list in remove_children

subtract_openingchildren ROUT

        Push    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk,LR"

        Debug   child,"Subtract opening children",handle

        MOV     R1,R0                                   ; modify same rectangle list
        MOV     userblk,handle                          ; userblk -> original window

        LDR     handle, openingwinds + lh_forwards
10
        ASSERT  ll_forwards = 0
        LDR     R14,[handle],#-w_opening_link
        CMP     R14,#nullptr                            ; Has end been reached?
        BEQ     %FT20

        LDR     R2,[handle,#w_parent]
        B       %FT14

12      LDR     R14,[R2,#w_opening_link + ll_forwards]
        TEQ     R14,#0
        BNE     %FT15                                   ; if intervening window is opening anyway, we can ignore this one

        LDR     R2,[R2,#w_parent]

14      CMP     R2,userblk
        BEQ     %FT25

        CMP     R2,#nullptr
        BNE     %BT12

15      LDR     handle,[handle,#w_opening_link + ll_forwards]
        B       %BT10
20
        Pull    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk,PC"

; we've found a child window in the opening list that's a descendent of the window in question

25
        Push    "handle"

        ADD     R14,handle,#w_x0
        LDMIA   R14,{cx0,cy0,cx1,cy1}                   ; cx0,cy0,cx1,cy1 = outline of child

27      LDR     R14,[handle,#w_flags]
        TST     R14,#wf_inborder                        ; if child can live in parent's border,
        LDR     handle,[handle,#w_parent]
        ADDNE   R14,handle,#w_x0
        ADDEQ   R14,handle,#w_wax0
        LDMIA   R14,{x0,y0,x1,y1}                       ; x0,y0,x1,y1 = work area or outline of parent

        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1

        CMP     handle,userblk                          ; keep clipping to intervening windows
        BNE     %BT27

        Pull    "handle"

        Debug   child,"Subtracting opening child window rectangle",handle,cx0,cy0,cx1,cy1
        BL      subrect

        LDR     handle,[handle,#w_opening_link + ll_forwards]
        B       %BT10

;...........................................................................

; In    handle -> parent window
;       R0 = rectangle list to subtract children from
; Out   clipped old outer rectangles of OPENING children subtracted from rectangle list
;       R1 corrupted

oldsubtract_openingchildren ROUT

        Push    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk,LR"

        Debug   child,"Old Subtract opening children",handle

        MOV     R1,R0                                   ; modify same rectangle list
        MOV     userblk,handle                          ; userblk -> original window

        LDR     handle, openingwinds + lh_forwards
10
        ASSERT  ll_forwards = 0
        LDR     R14,[handle],#-w_opening_link
        CMP     R14,#nullptr                            ; Has end been reached?
        BEQ     %FT20

        LDR     R2,[handle,#w_old_parent]
        B       %FT14

12      LDR     R14,[R2,#w_opening_link + ll_forwards]
        TEQ     R14,#0
        BNE     %FT15                                   ; if intervening window is opening anyway, we can ignore this one

        LDR     R2,[R2,#w_old_parent]

14      CMP     R2,userblk
        BEQ     %FT25

        CMP     R2,#nullptr
        BNE     %BT12

15      LDR     handle,[handle,#w_opening_link + ll_forwards]
        B       %BT10
20
        Pull    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk,PC"

; we've found a child window in the opening list that's a descendent of the window in question

25
        Push    "handle"

        ADD     R14,handle,#w_old_x0
        LDMIA   R14,{cx0,cy0,cx1,cy1}                   ; cx0,cy0,cx1,cy1 = outline of child

27      LDR     R14,[handle,#w_old_flags]
        TST     R14,#wf_inborder                        ; if child can live in parent's border,
        LDR     handle,[handle,#w_old_parent]
        ADDNE   R14,handle,#w_old_x0
        ADDEQ   R14,handle,#w_old_wax0
        LDMIA   R14,{x0,y0,x1,y1}                       ; x0,y0,x1,y1 = work area or outline of parent

        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1

        CMP     handle,userblk                          ; keep clipping to intervening windows
        BNE     %BT27

        Pull    "handle"

        Debug   child,"Old Subtracting opening child window rectangle",handle,cx0,cy0,cx1,cy1
        BL      subrect

        LDR     handle,[handle,#w_opening_link + ll_forwards]
        B       %BT10
      ]
d4850 1
a4850 1
invalidouterportion ROUT
d4891 1
a4891 8
markinvalidrects  ROUT
        Push    "R0,R1,userblk,handle,LR"
    [ ChildWindows
        MOV     R0,#invalidrects
      [ false   ; I don't think we actually need this one after all
        B       %FT01

markoldinvalidrects
a4892 4
        MOV     R0,#oldinvalidrects
01
      ]
    ]
d4894 1
a4894 1

a4899 1
      [ :LNOT: ChildWindows
a4900 1
      ]
d4908 1
a4908 1

d4937 1
d4959 1
a4959 1
        BNE     intrectslp
@


4.1.7.2.2.2
log
@Some obsolete assembly switches removed (chwidth in particular).
Behaviour of scrollbars with large extents improved.
Window tools now press in correctly after a Service_InvalidateCache.
Plotting of solid window tools optimised - background isn't drawn in.
Auto-fronting iconbar added.
Various optimisations, such as multiple OS_WriteI -> OS_WriteN.
HiResMono flag no longer relied on.
"22" tool sprites now chosen for 1x2,2x1 or 1x1 screen modes.
Buttons restored correctly after "application may have gone wrong" error box.
Positioning of outline font text shifted right 2 OS units to match system font.
Parameter of L validation string implemented.
Positioning of outline font "L" (multiple line) icons fixed.
Shift-toggle size behaviour fixed.
Wimp_TransferBlock above 2Gb should be fixed.
Post-rectangle filters implemented.
FPE4 flag added (to use LFM/SFM instead of LDFE/STFE).
Plotting of non-pixel aligned 3d icons fixed.
3d borders now solid in EX0/EY0 modes.
@
text
@d164 2
a165 4
      [ "$x" <> "R1"
       [ "$y" = "R1"
        MOV     R2,R1
       ]
d168 4
a171 1
      [ "$y" <> "R2" :LAND: "$y" <> "cx0" :LAND: :LNOT: ( "$x" <> "R1" :LAND: "$y" = "R1" )
d173 1
d177 1
d1007 1
a1007 1
; tries "<filename>23" if hi-res mono, and/or "<filename>22" if 2x2 OS units
d1488 2
a1489 2
;        ADRL    R14,wimpmodebefore
;        STR     R0,[R14]
d1491 1
a1491 1
        STR     R0,[R14]                ; splats misc
a1496 3
	[ PoppingIconBar
	STR	R0,iconbar_pop_state
	]
d1711 1
a1711 1
    [ :LNOT: UseAMBControl                      ; not our responsibility any more!
d1806 9
d1822 1
a1822 4

	MOV	R1,#VduExt_Log2BPP
	SWI	XOS_ReadModeVariable

a1827 5
	TEQ	R5,#"2"				; 2x2 OS unit, 1bpp
	TEQEQ	R6,#"2"
	TEQEQ	R2,#0
	MOVEQ	R6,#"3"

a2473 1
	      [ debugtask4
a2474 1
              ]
d2643 3
d2662 1
a2662 1
;fpemulator_flag #      1
d2864 1
a2864 1
;latestwimp     #       4
d2870 3
a2872 3
;ishscroll      #       4
;isvscroll      #       4
;heapfreeptr    #       4
d2879 4
a2882 5
crf_vdu5caret   *       &01000000
crf_invisible   *       &02000000
crf_usercolour  *       &04000000
crf_realcolour  *       &08000000

a3148 13
	[ PoppingIconBar
iconbar_pop_time	#	4
iconbar_pop_state	#	4
pop_Back	* 0
pop_Delaying	* 1
pop_Front	* 2
pop_HeldByMenu	* 3
pop_DelayTime	* 50	; centiseconds
	]
iconbar_scroll_start_time #	4	; time icon bar started scrolling
iconbar_scroll_start_scx  #	4	; and where it started from
iconbar_scroll_speed	  *	2	; in 100 OS units per second
iconbar_scroll_accel	  *	1	; in 100 OS units per second^2
d3203 1
a3203 2
freepoolinuse	#	1
misc		#	1
d3206 4
d3547 4
a3550 5
erf_newtype	*	1 :SHL: 8	; new style error report (Wimp 3.21 onwards)
erf_errortype	*	7 :SHL: 9	; error type (new style only)
erf_describe	*	1 :SHL: 31	; used internally

erb_errortype	*	9
d3651 6
d3664 5
d3678 1
d3680 6
@


4.1.7.2.2.3
log
@Iconise button added.
@
text
@a2425 1
windowicon_iconise	# -1		; -14
a2433 1
iconposn_iconise	* 8
a3054 3
 [ IconiseButton
iconise_width	#	4		; width of the iconise button
 ]
@


4.1.7.2.2.4
log
@Corruption of userblk in oldvisible_knockout (causing data aborts when
input focus changes) fixed.
Care taken to ensure that characters (eg VDU 26) issued by the Wimp don't
trigger a command window.
@
text
@a4148 1
cf_wimpdoingvdu	*	1 :SHL: 6	; set by various wimp routines
d4348 2
a4349 5
; ignore chars if suspended (Upcall handler does this), or if its
; us doing the VDU!
;
        LDR     R14,commandflag
        TST     R14,#cf_suspended:OR:cf_wimpdoingvdu
a4352 2
	LDR	R0,[SP,#0]
	Debug	co,"Char printed",R0
d5258 1
a5258 1
        Push    "cx0,cy0,cx1,cy1,handle,userblk,LR"
d5331 1
a5331 1
        Pull    "cx0,cy0,cx1,cy1,handle,userblk,PC"
@


4.1.7.2.2.5
log
@Erroneously included debug removed.
@
text
@d4357 2
@


4.1.7.2.2.6
log
@Stopped the Wimp shrinking the free pool on module finalisation. This
behaviour is rather unhelpful as it causes problems if a new Wimp is
softloaded during a boot sequence. The free pool is still shrunk when the
last task quits.
@
text
@d1626 5
@


4.1.7.2.2.7
log
@Added support for multiple options files (RO310, RO350, RO360, RO370, RCA,
Ursula).
Removed run-time MedusaOS checks.
Enabled correct build for RISC OS 3.1 machines.
Ensured that "freepoolinuse" is cleared before OS_ChangeDynamicArea
is intercepted.
Increased maxrects to 256.
Gave copy filter window handle in R10 (if ChildWindows).
Corrected a few border problems when no toolsprites.
Made toolsprites press in immediately - in particular close and toggle can
now be highlighted.
BounceClose flag no affects all of back,close,iconise and toggle.
Made "L" validation string parsing check manually for presence of a number,
to prevent error from OS_ReadUnsigned trashing MessageTrans' error buffers.
Allow error box buttons to stretch to fit text.
Fixed bug: floating point registers were not being saved unless on a portable.
Integrated some of the Wimp_TransferBlock fixes into Wimp08 from Wimp08s.
@
text
@d365 1
a365 1
      [ :LNOT:Medusa
d1035 2
a1036 3
      [ Medusa
        Pull    "R12,PC"                ; Medusa uses DA
      ]
d1329 10
d1483 2
d1749 2
a1750 1
        MOVS    PC,lr
d2432 1
a2432 1
maxrects        *       256
d2784 3
@


4.1.5.1
log
@Import from SrcFiler
@
text
@a1336 4
 [ DontCheckModeOnInit
        MOV     r0, #-1
        STR     r0, currentmode
 |
a1345 1
 ]
d2339 4
a2342 7
getrect_firstrect       * 2_00001
getrect_updating        * 2_00010
getrect_redrawing       * 2_00100
getrect_noicons         * 2_01000
 [ Twitter
getrect_twitter         * 2_10000
 ]
d2831 1
a3033 5
 [ KeyboardMenus
lastxpos        #       4               ; stop mouse highlighting menus unless it moves
lastypos        #       4
 ]

a4057 2
 [ :LNOT: NoCommandPrompt		; always do this quietly
;
a4060 1

a4072 1
;
a4075 2
 ] ;	:LNOT: NoCommandPrompt
;
a4746 13
 [ Twitter
visibleoutertwitter
        Push    "lr"
        BL      checktwitter
        Pull    "lr"
        ADDNE   r0, handle, #w_x0
        LDMNEIA r0, {x0,y0,x1,y1}
        SUBNE   y0, y0, #2
        ADDNE   y1, y1, #2
        BNE     visibleportion_x0y0x1y1
        ; if twitter not required then drop through to visibleouterportion
 ]
 
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a1671 1
  [ :LNOT UseAMBControl
a1679 1
  ]
a2150 1
    Debug mjs2," wimp01 (1) slotptr to free",R2
a2151 4
  [ UseAMBControl
     MOVGT   R0,#1   ;deallocate reason code
     SWIGT   AMBControl_SWI
  |
a2153 1
  ]
a2187 1
    Debug mjs2," wimp01 (2) slotptr to free",R2
a2188 4
  [ UseAMBControl
        MOVGT   R0,#1   ;deallocate reason code
        SWIGT   AMBControl_SWI
  |
a2190 1
  ]
a2232 1
        STR     R14,lastpointer
a2868 2
lastpointer     #       4               ; end of message queue (NK's optimise)

a3923 2
        ADRL    R1,lastpointer
        STMIA   sp,{R1}
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

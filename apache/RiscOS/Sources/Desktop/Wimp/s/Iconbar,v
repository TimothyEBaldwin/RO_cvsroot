head	4.10;
access;
symbols
	Wimp-5_62:4.10
	Wimp-5_61:4.10
	Wimp-5_60:4.10
	Wimp-5_59:4.10
	Wimp-5_58:4.10
	Wimp-5_57:4.10
	Wimp-5_56:4.10
	Wimp-5_55:4.10
	Wimp-5_54:4.10
	Wimp-5_53:4.10
	Wimp-5_52:4.9
	Wimp-5_51:4.9
	Wimp-5_50:4.9
	Wimp-5_49:4.9
	Wimp-5_48:4.9
	Wimp-5_47-file1ad:4.9
	Wimp-5_47:4.9
	Wimp-5_46:4.9
	Wimp-5_45:4.9
	Wimp-5_44:4.9
	Wimp-5_43:4.9
	Wimp-5_42:4.8
	Wimp-5_41:4.8
	Wimp-5_40:4.8
	Wimp-5_39:4.8
	Wimp-5_38:4.8
	Wimp-5_37:4.8
	Wimp-5_36:4.8
	Wimp-5_35:4.8
	Wimp-5_34:4.8
	Wimp-5_33:4.8
	Wimp-5_32:4.8
	Wimp-5_31:4.8
	Wimp-5_30:4.8
	Wimp-530-pre4:4.8
	Wimp-5_30-pre3:4.8
	Wimp-5_30-pre2:4.8
	Wimp-5_30-pre1:4.8
	Wimp-5_29:4.8
	Wimp-5_28:4.8
	Wimp-5_27:4.8
	Wimp-5_26:4.8
	Wimp-5_25:4.8
	Wimp-5_24:4.8
	Wimp-5_23:4.8
	Wimp-5_22:4.7
	Wimp-5_21:4.7
	Wimp-5_20:4.7
	Wimp-5_19:4.7
	Wimp-5_18:4.7
	Wimp-5_17:4.7
	Wimp-5_16:4.7
	Wimp-5_15:4.7
	Wimp-5_14:4.7
	Wimp-5_13:4.7
	Wimp-5_12:4.7
	Wimp-5_11:4.7
	Wimp-5_10:4.7
	Wimp-5_09:4.7
	Wimp-5_08:4.7
	Wimp-5_07:4.7
	Wimp-5_06:4.7
	Wimp-5_05:4.7
	Wimp-5_04:4.7
	Wimp-5_03:4.7
	Wimp-5_02:4.7
	Wimp-5_01:4.7
	Wimp-4_66-4_77_2_1:4.6.2.1
	bavison_Threads_dev:4.6.0.2
	bavison_Threads_dev_bp:4.6
	Wimp-5_00:4.7
	Wimp-4_100:4.7
	Wimp-4_99:4.7
	Wimp-4_98:4.7
	Wimp-4_97:4.7
	Wimp-4_96:4.7
	Wimp-4_95:4.7
	Wimp-4_94:4.7
	RO_5_07:4.7
	Wimp-4_93:4.7
	Wimp-4_92:4.7
	Wimp-4_91:4.7
	Wimp-4_90:4.7
	Wimp-4_89:4.7
	Wimp-4_88:4.7
	Wimp-4_87:4.7
	Wimp-4_86:4.7
	Wimp-4_85:4.7
	Wimp-4_84:4.7
	Wimp-4_83:4.7
	Wimp-4_82:4.7
	Wimp-4_81:4.7
	Wimp-4_80:4.7
	Wimp-4_79:4.7
	Wimp-4_78:4.7
	Wimp-4_77:4.7
	Wimp-4_76:4.7
	Wimp-4_75:4.6
	Wimp-4_74:4.6
	Wimp-4_73:4.6
	Wimp-4_72:4.6
	Wimp-4_71:4.6
	Wimp-4_70:4.6
	Wimp-4_69:4.6
	Wimp-4_68:4.6
	Wimp-4_67:4.6
	Wimp-4_66:4.6
	Wimp-4_65:4.6
	Wimp-4_64:4.6
	Wimp-4_63:4.6
	Wimp-4_62:4.6
	Wimp-4_61:4.6
	Wimp-4_60:4.6
	Wimp-4_59:4.6
	Wimp-4_58:4.6
	Wimp-4_36-4_46_2_6:4.4
	Wimp-4_57:4.6
	Alpnet_approved:4.4
	Wimp-4_36-4_46_2_5:4.4
	Wimp-4_56:4.6
	dellis_autobuild_BaseSW:4.6
	Wimp-4_36-4_46_2_4:4.4
	Wimp-4_36-4_46_2_3:4.4
	Wimp-4_55:4.6
	Wimp-4_54:4.6
	Wimp-4_36-4_46_2_2:4.4
	Wimp-4_53:4.6
	Wimp-4_36-4_46_2_1:4.4
	Bethany:4.4.0.2
	Wimp-4_52:4.6
	Wimp-4_51:4.6
	Wimp-4_50:4.6
	Wimp-4_49:4.6
	Wimp-4_48:4.6
	Wimp-4_47:4.6
	Wimp-4_46:4.5
	Wimp-4_45:4.5
	Wimp-4_44:4.5
	Wimp-4_43:4.5
	Wimp-4_42:4.4
	sbrodie_sedwards_16Mar2000:4.4
	Wimp-4_41:4.4
	Wimp-4_40:4.4
	Wimp-4_39:4.4
	Wimp-4_38:4.4
	Wimp-4_37:4.4
	Wimp-4_36:4.4
	Wimp-4_35:4.4
	Wimp-4_34:4.4
	Wimp-4_33:4.4
	Wimp-4_32:4.4
	Wimp-4_31:4.4
	dcotton_autobuild_BaseSW:4.6
	Wimp-4_30:4.4
	Wimp-4_29:4.4
	Wimp-4_28:4.4
	Wimp-4_27:4.4
	Wimp-4_26:4.4
	Wimp-4_25:4.4
	Wimp-4_24:4.4
	Wimp-4_23:4.4
	Wimp-4_22:4.4
	Wimp-4_21:4.4
	Wimp-4_20:4.4
	Wimp-4_19:4.4
	Wimp-4_18:4.4
	Wimp-4_17:4.4
	Wimp-4_16:4.4
	Wimp-4_15:4.4
	Wimp-4_14:4.4
	Wimp-4_13:4.4
	Wimp-4_12:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	bavison_Wimp-4_11:4.4
	Ursula_RiscPC:4.2.2.1.0.2
	Wimp-4_11:4.4
	Wimp-4_10:4.4
	Wimp-4_09:4.4
	Wimp-4_08:4.3
	Wimp-4_07:4.3
	Wimp-4_06:4.3
	Wimp-4_05:4.3
	Wimp-4_04:4.3
	bavison_Wimp-4_03_noshrinkables:4.3
	Wimp-4_03:4.3
	Wimp-4_02:4.3
	Ursula_merge:4.2.2.1
	bavison_Wimp-4_01:4.3
	Wimp-4_01:4.3
	nicke_Wimp_3_96M:4.1.7.1
	bavison_Wimp-4_00_TRUNK:4.3
	bavison_Wimp-4_00:4.2.2.1
	nicke_Wimp_3_96:4.1.7.1
	mjrobert_Wimp_3_98:4.2
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	bavison_Wimp-3_99t:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	bavison_Wimp-3_99s:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	bavison_Wimp-3_99r:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	bavison_Wimp-3_99q:4.2.2.1
	jfarrell_NCWimp_3_96:4.1.7.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	bavison_Wimp-3_99p:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	bavison_Wimp-3_99o:4.2.2.1
	bavison_Wimp-3_99n:4.2.2.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	bavison_Wimp-3_99m:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	bavison_Wimp-3_99l:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	bavison_Wimp-3_99k:4.2.2.1
	bavison_Wimp-3_99j:4.2.2.1
	bavison_Wimp-3_99i:4.2
	bavison_Wimp-3_99h:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	bavison_Wimp_399g:4.2
	bavison_Wimp_399f:4.2
	afrost_NC2_Generic:4.1.7.1
	bavison_Wimp_399e:4.2
	bavison_Wimp_399d:4.2
	bavison_Wimp_399c:4.2
	Wimp_3_98:4.2
	kbracey_AW97:4.2
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Wimp_3_91:4.2
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1.2.3
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2016.05.23.21.53.13;	author jlee;	state Exp;
branches;
next	4.9;
commitid	JVRG5UWTKsMNCE7z;

4.9
date	2014.07.20.08.02.11;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	dYAocC6tl2fSE5Jx;

4.8
date	2013.04.13.08.16.47;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	DLq3yhcS0mdCCALw;

4.7
date	2002.10.23.17.12.35;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2000.04.25.12.24.04;	author kbracey;	state Exp;
branches
	4.6.2.1;
next	4.5;

4.5
date	2000.03.30.14.38.36;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	98.10.23.15.48.16;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	98.09.18.16.14.01;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	97.05.07.14.15.22;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.30.46;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.6.2.1
date	2007.10.07.02.17.29;	author bavison;	state Exp;
branches;
next	;
commitid	NSavcPvbNd36pBAs;

4.2.2.1
date	98.05.18.15.51.12;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.30.46;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.32.49;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.24.26;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.22.01;	author nturton;	state Exp;
branches
	4.1.7.1.2.1;
next	;

4.1.7.1.2.1
date	97.04.17.16.43.44;	author kbracey;	state Exp;
branches;
next	4.1.7.1.2.2;

4.1.7.1.2.2
date	97.04.18.01.18.48;	author kbracey;	state Exp;
branches;
next	4.1.7.1.2.3;

4.1.7.1.2.3
date	97.04.28.16.49.50;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Fix invalid AMB node handle being used when low on memory
Detail:
  s/Wimp08s - If OS_AMBControl allocate is asked for a AMB node with a size > 0, but no pages can be claimed, it frees the node and returns an invalid handle (0). Make sure that the Wimp's allocateslot routine is aware of this, so that we don't try passing that bad handle back to AMBControl later on
  s/Iconbar - Use nullptr constant instead of -1 when checking task_slotsize (aka AMB node handle on modern machines)
Admin:
  Tested on BB-xM
  Fixes abort seen when attempting to start a task with no pages in the free pool


Version 5.53. Tagged as 'Wimp-5_53'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;;----------------------------------------------------------------------------
;; Create/Delete icon on icon bar
;; userblk --> user's original block
;; handle = -1 ==> right side from left edge with priority 0
;;          -2 ==> left side from right edge with priority 0
;;          -3 ==> to left of existing icon in R0            Wimp 2.21 onwards
;;                 - or extreme left if R0 < 0
;;          -4 ==> to right of existing icon in R0           Wimp 2.21 onwards
;;                 - or extreme right if R0 < 0
;;          -5 ==> left side from left edge with R0 = priority    2.73 onwards
;;          -6 ==> left side from right edge with R0 = priority   2.73 onwards
;;          -7 ==> right side from left edge with R0 = priority   2.73 onwards
;;          -8 ==> right side from right edge with R0 = priority  2.73 onwards
;; R0 = handle of icon to open next to (if used)
;;      if icon not found, move to extreme left/right of iconbar
;;----------------------------------------------------------------------------

icbf_rightside  *       1 :SHL: 0       ; 1 => start from right, else left
icbf_r0handle   *       1 :SHL: 1       ; 1 => R0 = icon handle
icbf_r0priority *       1 :SHL: 2       ; 1 => R0 = priority level
icbf_fromedge   *       1 :SHL: 7       ; 1 => scan from edge, else middle
                                        ; MUST be highest-order bit
iconbartab
        DCB     icbf_rightside                                          ; right, from left , priority 0
        DCB     0                                                       ; left , from right, priority 0
        DCB     icbf_fromedge :OR: icbf_r0handle                        ; left , from left , r0 handle
        DCB     icbf_rightside :OR: icbf_fromedge :OR: icbf_r0handle    ; right, from right, r0 handle
        DCB     icbf_fromedge :OR: icbf_r0priority                      ; left , from left , r0 priority
        DCB     icbf_r0priority                                         ; left , from right, r0 priority
        DCB     icbf_rightside :OR: icbf_r0priority                     ; right, from left,  r0 priority
        DCB     icbf_rightside :OR: icbf_fromedge :OR: icbf_r0priority  ; right, from right, r0 priority
iconbartabsize  * .-iconbartab
        ALIGN

addtoiconbar

; work out whereabouts in the list to put the new icon

        CMN     handle, #iconbartabsize
        MyXError  WimpBadHandle, MI, L
        BVS     ExitWimp

        ADRL    R14,iconbartab-1
        LDRB    R14,[R14,-handle]       ; R14 = flag byte

        TST     R14,#icbf_rightside
        ADREQ   R7,iconbarleft
        ADRNE   R7,iconbarright

        TST     R14,#icbf_r0handle
        BNE     gofindit

        TST     R14,#icbf_r0priority
        MOVEQ   R0,#0                   ; default is priority 0

addwithpriority                         ; R0 = priority of icon to add
        ADD     R1,R7,#icd_list-icb_link
01
        LDR     R4,[R1,#icb_link]       ; R4 -> next icon block
        CMP     R4,#nullptr
        BEQ     %FT02
        LDR     R3,[R4,#icb_priority]
        Debug   icb,"Iconblk, priority, newpriority:",R4,R3,R0
        CMP     R0,R3
        CMPEQ   R14,#icbf_fromedge      ; icbf_fromedge is highest order bit
        MOVLT   R1,R4
        BLT     %BT01
02                                      ; now r1 -> block before one to insert
        B       addtoR1
        MakeErrorBlock WimpBadIconHandle

gofindit
        MOVS    R4,R0                   ; R4 = icon handle to open next to
        MOVMI   R0,#WimpPriority_Maximum
        BMI     addwithpriority

        MOV     R3,R7                   ; R3 -> default end to add to
        BL      findicon                ; R1 -> previous, R2 -> current, R7 -> left/right head pointer
        MyXError  WimpBadIconHandle,NE
        BVS     ExitWimp

        LDR     R0,[R2,#icb_priority]   ; inherit matched icon's priority
        TEQ     R7,R3                   ; if not same as default end,
        LDRNE   R1,[R1,#icb_link]       ; move in to next icon

        ; now drop through to addtoR1

; in    R0 = priority to give to the new icon
;       R1 -> block prior to where the new one is going
;       R7 -> iconbar left/right chain head

addtoR1
        Push    "R0"                    ; save priority level

; create iconbar window if necessary

        LDR     handle,iconbarhandle
        BL      checkhandle             ; V set ==> not created yet
        BVC     %FT01                   ; skip this if already present
;
        Push    "R2,R3,R7,userblk"      ; iconbar ptr, original R1 from user
;
        ADR     R0,wn_iconbar
        MOV     R2,#0                   ; no indirected icons allowed!
        MOV     R3,#0
        BL      createsystemp           ; R0,handle = window rel/abs handles
        STRVC   R0,iconbarhandle
        LDRVC   R14,[handle,#w_way1]
        LDRVC   R2,[handle,#w_way0]
        SUBVC   R14,R14,R2
        STRVC   R14,iconbarheight       ; used later
 [ HideIconBar
        MOV     R2, #-3
 |
        LDRVC   R2,iconbarhandle        ; open at same height
 ]
        BLVC    openiconbar
;
        Pull    "R2,R3,R7,userblk"
        BVS     %FT99
01

; create icon and associated block (R0 is still stacked!)

        Push    "R1,cx0,cy0,cx1,cy1,x0,y0,x1,y1"
;
        LDMIA   userblk,{R0,cx0,cy0,cx1,cy1,x0,y0,x1,y1}
        Push    "R0,cx0,cy0,cx1,cy1,x0,y0,x1,y1"
        MOV     userblk,sp              ; copy icon onto the stack
; 322nk store default width
        SUB     R14,cx1,cx0
        STR     R14,tempworkspace+16
;
; 320nk, adjust size of icon if text too big in current font
        TST     x0,#if_text             ; x0 is flags
        BEQ     %FT10
        Push    "R0-R2"
        ADD     R1,sp,#36               ; 12 (Push) +4 (icon block) +20 (icon data)
        TST     x0,#if_indirected
        BEQ     %FT05
; if indirected can be turned off with validation X
        Push    R3
        LDR     R3,[R1,#4]
        MOV     R2,#WimpValidation_NoAuto
        BL      findcommand
        Pull    R3
        BEQ     %FT9                    ; found X
        LDR     R1,[R1]
05
        MOV     R0,#1
        MOV     R2,#0                   ; don't stop!
        SWI     XWimp_TextOp            ; R0 now has width
        LDR     R14,dx
        ADD     R0,R0,R14, LSL #1       ; add on 2 dx for luck
        SUB     R1,cx1,cx0
        SUBS    R0,R0,R1
        Pull    "R0-R2",MI
        BMI     %FT10
        ADD     cx1,cx1, R0
        STR     cx1,[sp,#24]
09
        Pull    "R0-R2"
10
        BL      int_create_icon         ; on exit R0 = icon handle
        ADD     sp,sp,#4+i_size         ; correct stack
        Pull    "R1,cx0,cy0,cx1,cy1,x0,y0,x1,y1"
;
        Pull    "R4"                    ; R4 = priority to set
;
        Push    "R0"                    ; used later
        MOVVC   R3,#icb_size
        BLVC    claimblock
        BVS     %FT99                           ; couldn't create block

; link new block into chain, and initialise various fields
; in    [sp] = icon handle
;       R1 -> block after which R2 is to be linked
;       R2 -> new icon block
;       R4 = priority to set
;       R7 -> head of appropriate chain (left or right)

        STR     R4,[R2,#icb_priority]
;
        LDR     R14,[R1,#icb_link]              ; don't assume link is null
        STR     R14,[R2,#icb_link]
        STR     R2,[R1,#icb_link]
;
        LDR     R14,[sp,#0*4]                   ; R14 = icon handle
        STR     R14,[R2,#icb_iconhandle]
;
        LDR     R14,tempworkspace+16
        STR     R14,[R2,#icb_defwidth]

        LDR     R14,taskhandle                  ; R14 = task handle
        STR     R14,[R2,#icb_taskhandle]        ; NB no version bits internally
;
        BL      recalcposns
99
        STRVS   R0,[sp,#0*4]

        LDR     R14,taskhandle
        Debug   swp,"iconbar task handle is ",R14
        LDR     R14,[wsptr,R14]
        LDR     R0,[R14,#task_priority]
        ORR     R0,R0,#priority_iconbar
        STR     R0,[R14,#task_priority]
        Debug   swp,"Priority (ICONBAR ICON) ",R0

        Pull    "R0"
        B       ExitWimp

wn_iconbar      DCB     "iconbar",0     ; must be word-aligned
                ALIGN

;
; Entry:  R0 --> window identifier
;         R2,R3 --> indirected icon data start/end
; Exit:   R0,handle = handle of window (read from WindowManager:Templates)
;

createsystemp
        Push    "R1-R6,userblk,LR"
;
        LDMIA   R0,{R4-R6}
        Push    "R4-R6"                 ; Save window ident on stack
;
        ADR     R1,wimptempfname
        BL      int_open_template
        BVS     %FT99
;
        LDR     R2,[sp,#12+1*4]         ; 12 byte name, then R1-R6
        LDR     R3,[sp,#12+2*4]
        MOV     R4,#0                   ; no fancy fonts!
        MOV     R5,sp                   ; R5 --> identifier
        MOV     R6,#0                   ; 1st entry
        MOV     userblk,#-1             ; Check space reqd
        BL      int_load_template       ; Read template

        Debug   systmpl,"Template buffer size, data size, count",R1,R2,R6

        TEQ     R6,#0                   ; Any entries?
        MyXError  WimpNoTemplate,EQ     ; No then error
        MOVVC   R3,R1                   ; Size of scratch buffer reqd
        BLVC    claimblock              ; Claim from RMA
        MOVVS   userblk,#0              ; No memory claimed if error
        MOVVC   userblk,R2              ; Get-> claimed block
        LDRVC   R2,[sp,#12+1*4]         ; 12 byte name, then R1-R6
        LDRVC   R3,[sp,#12+2*4]
        MOVVC   R4,#0                   ; no fancy fonts!
        MOVVC   R6,#0                   ; search whole of index

        Debug   systmpl,"Loading template to",userblk

        BLVC    int_load_template
        MOVVC   R14, #0                 ; created window will be 'owned' by Wimp
        STRVC   R14, createwindowtaskhandle
        BLVC    int_create_window       ; R0,handle = window handles (if V clr)
        MOV     R14, #1                 ; subsequent windows are 'owned' by their creators
        STR     R14, createwindowtaskhandle

        MOVVC   R14,#1
        STRVC   R14,[handle,#w_areaCBptr]       ; use common sprite pool
98
        SavePSR R14
        Push    "R0,R14"                 ; Save flags
        TEQ     userblk,#0
        MOVNE   R2,userblk              ; userblk --> window block
        MOVNE   R0,#ModHandReason_Free

        Debug   systmpl,"Freeing block",userblk

        BLNE   XROS_Module
        BL      int_close_template
        Pull    "R0,R14"
        RestPSR R14,,f                  ; Restore V flag
99
        ADD     sp,sp,#12               ; lose copy of name
        Pull    "R1-R6,userblk,PC"
        MakeErrorBlock WimpNoTemplate

        [ NewErrorSystem
wimptempfname   DCB     "WindowManager:Templates",0     ; AMcC 18-Oct-94 was Template3D
        |
wimptempfname   DCB     "WindowManager:Templates",0
        ]
                ALIGN


; (Re)open iconbar in appropriate position for the current mode
; In    R2 = handle of window to open iconbar behind
; Out   handle -> window data of iconbar (ie. absolute handle)

            ASSERT  handle = R10        ; we want to return this
openiconbar Entry   "R1-R9,R11"

        LDR     R0,iconbarhandle
        CMP     R0,#nullptr
        EXIT    EQ
        MOV     handle,R0
        BL      checkhandle
        EXIT    VS

; try to keep things the same as before
; however, we must ensure that the extent is big enough for the OpenWindow

        ADR     R14,scrx0
        LDMIA   R14,{cx0,cy0,cx1,cy1}           ; always open iconbar at bottom
        LDR     R14,iconbarheight
        ADD     cy1,cy0,R14
        LDR     R14,dx
        ADD     cx0,cx0,R14
        SUB     cx1,cx1,R14
        LDR     R14,dy
        ADD     cy0,cy0,R14                     ; cx0,cy0,cx1,cy1 = screen posn
        LDR     x0,[handle,#w_wex0]             ; try to keep extent the same
        SUB     x1,cx1,cx0
        ADD     x1,x0,x1                        ; x0,x1 = extent
        LDR     R14,[handle,#w_wex1]
        CMP     x1,R14                          ; we need extent >= screen width
        MOVLT   x1,R14                          ; so the OpenWindow works

; ensure that the other variables are consistent with this new size

        STR     x0,iconbarleft+icd_extent       ; window version is the same
        STR     x1,iconbarright+icd_extent
        STR     x1,[handle,#w_wex1]             ; NB: pixel aligned

        SUB     R14,cx1,cx0
        STR     R14,iconbarleft+icd_widthoffset     ; +width from left to right
        RSB     R14,R14,#0
        STR     R14,iconbarright+icd_widthoffset    ; -width from right to left
        LDR     R14,iconbarleft+icd_width
        ADD     R14,x0,R14                      ; relative to extent

        STR     R14,iconbarleft+icd_middle
        LDR     R14,iconbarright+icd_width          ; widths initialised before
        SUB     R14,x1,R14                      ; relative to extent
        STR     R14,iconbarright+icd_middle

        LDR     x0,[handle,#w_scx]                  ; keep same scroll offsets
        LDR     y0,[handle,#w_scy]

      [ debugicb
        Push    "cy0,cy1"
        LDR     cy0,[handle,#w_wex0]
        LDR     cy1,[handle,#w_wex1]
        Debug   icb,"openic: iconbar =",cx0,cx1,x0, cy0,cy1
        Pull    "cy0,cy1"
      ]

        LDR     R14,[sp, #1*4]          ; R2 on entry = bhandle
        Push    "R0,cx0,cy0,cx1,cy1,x0,y0,R14"
        MOV     userblk,sp
        BL      int_open_window
        ADD     sp,sp,#u_ow1

        EXIT

;
; Entry:  R2 = icon handle
;         it tries the filing system and utilities sections in turn
;

removefromiconbar
        BL      int_removefromiconbar
        B       ExitWimp


int_removefromiconbar
        Push    "R1-R7,LR"
;
        Debug   ic,"Remove from icon bar: R2 =",R2
;
        ORR     R0,R2,#msh_iconbar      ; R0 = icon handle (+marker bit)
        BL      byemessages             ; delete relevant messages
;
        LDR     handle,iconbarhandle
        BL      checkhandle
        BLVC    int_deleteicon          ; no error if not found
;
        MOV     R4,R2                   ; R4 = icon handle
        BL      findicon                ; exit: R2 --> block (if found)
;
        LDREQ   R14,[R2,#icb_link]      ; remove from chain
        STREQ   R14,[R1,#icb_link]
        MOVEQ   R0,#ModHandReason_Free
        BLEQ   XROS_Module
;
        BL      recalcposns             ; ignore errors from ROS_Module here
;
        LDR     R5,iconbarleft+icd_list
        LDR     R6,iconbarright+icd_list
        TST     R5,R6                   ; both negative?
        Pull    "R1-R7,PC",PL
;
        LDR     R0,iconbarhandle
        CMP     R0,#nullptr
        MOVNE   R14,#nullptr            ; kill off iconbar if empty
        STRNE   R14,iconbarhandle
        BLNE    int_delete_window
;
        Pull    "R1-R7,PC"

;
; Entry:  R4 = icon handle
; Exit:   found: Z set
;                R1-->previous link
;                R2-->icon block
;                R7-->iconbarleft/right
;     not found: Z unset
;

findicon
        Push    "LR"
;
        ADR     R7,iconbarleft
        BL      tryfindicon
        ADRNE   R7,iconbarright
        BLNE    tryfindicon
;
        Pull    "PC"

tryfindicon
        Push    "LR"
        ADD     R1,R7,#icd_list-icb_link
01
        LDR     R2,[R1,#icb_link]
        CMP     R2,#nullptr
        BEQ     %FT02
        LDR     R14,[R2,#icb_iconhandle]
        TEQ     R14,R4
        MOVNE   R1,R2
        BNE     %BT01
;
        Pull    "PC"                    ; found (Z set)
02
        TEQ     R2,#0
        Pull    "PC"                    ; not found (Z unset)


;
; Recompute positions of icons (called from CreateIcon and DeleteIcon)
; In    R7 -> icon data for appropriate side of icon bar
;       handle -> window defn of iconbar (ie. absolute handle)
;

recalcposns
        Push    "R1-R9,userblk,LR"
;
        ADR     R8,iconbarleft          ; R8 --> other section
        TEQ     R8,R7
        ADREQ   R8,iconbarright
;
        Push    handle
        LDR     handle,[handle,#w_icons]
;
        MOV     x0,#0
        LDR     R1,[R7,#icd_list]
01
        CMP     R1,#nullptr
        LDRNE   R2,[R1,#icb_iconhandle]
        ADDNE   R14,handle,R2,LSL #i_shift
        LDRNE   cx0,[R14,#i_bbx0]
        LDRNE   cx1,[R14,#i_bbx1]
        SUBNE   cx1,cx1,cx0
        ADDNE   x0,x0,#iconbargap       ; allow for gap between icons
        ADDNE   x0,x0,cx1               ; plus width of icon itself
        LDRNE   R1,[R1,#icb_link]
        BNE     %BT01
;
        STR     x0,[R7,#icd_width]
;
        Debug   ic,"This/other side, width =",R7,R8,x0
;
; decide if this will fit inside one screen-width
;
        LDR     R0,iconbarleft + icd_width
        LDR     R1,iconbarright+ icd_width
        ADD     R1,R0,R1                ; total width of icons
        LDR     cx1,iconbarleft + icd_widthoffset
        SUB     cx1,cx1,#iconbarsepgap  ; gap between left and right
;
; if it fits:  start at the outside and go in
;  otherwise:  start at the inside and go out
;
        LDR     R0,[R8,#icd_widthoffset]        ; +- screenwidth
        CMP     R1,cx1
        BGT     startinmiddle
;
        LDR     R9,[R8,#icd_extent]             ; other end
        ADD     R9,R9,R0                        ; must still be pixel-aligned
        STR     R9,[R7,#icd_extent]
        CMP     R0,#0                           ; was that plus or minus?
        SUBPL   R14,R9,x0
        ADDMI   R14,R9,x0
        STR     R14,[R7,#icd_middle]            ; work back to middle
        Debug   ic,"Unlimited: extent,middle =",R9,R14
        B       allocateicons

startinmiddle
        CMP     R0,#0
        LDR     R14,[R8,#icd_middle]
        ADDPL   R14,R14,#iconbarsepgap
        SUBMI   R14,R14,#iconbarsepgap
        STR     R14,[R7,#icd_middle]
        ADDPL   R9,R14,x0
        SUBMI   R9,R14,x0
        STR     R9,[R7,#icd_extent]
        Debug   ic,"Limited: extent,middle =",R9,R14

;
; R0 (bit 31) ==> direction to move in
; R7 --> data for this set of icons
; R8 --> data for the other set of icons
; R9 = start x-coord for icons
;

allocateicons
        LDR     R2,[R7,#icd_list]
01
        CMP     R2,#nullptr
        BEQ     doneicons
;
        LDR     R3,[R2,#icb_iconhandle]
        ADD     R14,handle,R3,LSL #i_shift
        LDMIA   R14,{R3,R4,R5,R6}
        SUB     R5,R5,R3                        ; width of icon
;
        CMP     R0,#0                           ; direction
        ADDMI   R3,R9,#iconbargap
        ADDMI   R5,R3,R5
        MOVMI   R9,R5
        SUBPL   R9,R9,#iconbargap
        SUBPL   R3,R9,R5
        MOVPL   R5,R9
        MOVPL   R9,R3
        STMIA   R14,{R3,R4,R5,R6}
;
        LDR     R2,[R2,#icb_link]
        B       %BT01

;
; reset window extent, and check whether we must scroll
;
doneicons
        Pull    handle
;
        LDR     R14,iconbarleft + icd_extent
        LDR     R0,dx_1                         ; must be pixel-aligned
        BIC     R14,R14,R0
        STR     R14,[handle,#w_wex0]            ; poke direct!
        LDR     R0,[handle,#w_scx]
        CMP     R0,R14
        MOVLT   R0,R14
;
        LDR     R14,iconbarright+ icd_extent
        LDR     R1,dx_1                         ; must be pixel-aligned
        BIC     R14,R14,R1
        STR     R14,[handle,#w_wex1]            ; poke direct!
        LDR     R1,iconbarright + icd_widthoffset
        ADD     R14,R14,R1
        CMP     R0,R14
        MOVGT   R0,R14
;
; Poke these directly to stop the Wimp attempting to do a block copy
;
        STR     R0,[handle,#w_scx]              ; poke direct! (pixel aligned)
      [ ChildWindows
        STR     R0,[handle,#w_old_scx]          ; also old position
      ]
;
      [ debugicb
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{cx0,cy0,cx1,cy1,x0,y0}
        LDR     cy0,[handle,#w_wex0]
        LDR     cy1,[handle,#w_wex1]
        Debug   icb,"recalc: iconbar =",cx0,cx1,x0, cy0,cy1
      ]
;
        MOV     x0,#-bignum
        MOV     y0,#-bignum
        MOV     x1,#bignum
        MOV     y1,#bignum
        BL      int_force_redraw                ; mark invalid
;
        Pull    "R1-R9,userblk,PC"

        [ true

resizeiconbaricons
; make sure widths of iconbar icons are ok in new font
        Push    "R0-R5,R7,handle,userblk,lr"
        MOV     R0,#0
        STRB    R0,iconbar_needs_rs
        LDR     handle,iconbarhandle
        CMP     handle,#nullptr
        Pull    "R0-R5,R7,handle,userblk,PC",EQ
        Abs     handle,handle
        LDR     R5,[handle,#w_icons]
        LDR     R3,[handle,#w_nicons]
        TEQ     R3,#0
        Pull    "R0-R5,R7,handle,userblk,PC",EQ            ; return if no icons
        LDR     R4,taskhandle
        Push    "R4"
        MOV     R4,#0
resizeicons_loop
        BL      findicon
        BNE     resizeicons_next
; R2 -> icon block
        LDR     R14,[R5,#i_flags]
        TST     R14,#if_text
        BEQ     resizeicons_next
        TST     R14,#if_indirected
        ADD     R1,R5,#i_data
        BEQ     %FT05
        LDR     R1,[R1]
        LDR     R0,[R2,#icb_taskhandle]
        CMP     R0,#0
        BMI     %FT05
        LDR     R14,orig_applicationspacesize
        CMP     R14,R1
        BLHI    mapslotinout
; so that indirected data is ok. Now R1-> text
        Push    "R2,R3"
        MOV     R2,#WimpValidation_NoAuto
        LDR     R3,[R5,#i_data+4]                 ; validation string
        BL      findcommand
        Pull    "R2,R3"
        BEQ     resizeicons_next
05
        MOV     R0,#1
        Push    "R2"
        MOV     R2,#0
        SWI     XWimp_TextOp
        LDR     R14,dx
        ADD     R0,R0,R14, LSL #1       ; add on 2 dx for luck

        Pull    "R2"
        LDR     R1,[R2,#icb_defwidth]
        CMP     R0,R1
        MOVHI   R1,R0
        LDR     R0,[R5,#i_bbx0]
        ADD     R1,R0,R1
        STR     R1,[R5,#i_bbx1]                 ; update width if needed

resizeicons_next
        SUBS    R3,R3,#1
        ADDNE   R5,R5,#i_size
        ADDNE   R4,R4,#1
        BNE     resizeicons_loop
        ADR     R7,iconbarleft
        BL      recalcposns
        ADR     R7,iconbarright
        BL      recalcposns
        ADR     R7,iconbarleft
        BL      recalcposns

        Pull    "R0"
        CMP     R0,#0
        BLPL    mapslotinout

        Pull    "R0-R5,R7,handle,userblk,PC"

mapslotinout
        Push    "R0-R2,R14"
        LDR     R1,taskhandle
        TEQ     R0,R1
        Pull    "R0-R2,PC",EQ
        LDR     R0,[R12,R1]                     ; task block
        TST     R0,#&80000000
        BNE     %FT01
        LDR     R0,[R0,#task_slotptr]
        CMP     R0,#nullptr
        BLNE    mapout
01
        Pull    "R0"
        LDR     R14,=&ffff
        AND     R0,R0,R14                    ; make sure internal t/h
        STR     R0,taskhandle
        LDR     R0,[R12,R0]
        TST     R0,#&80000000
        Pull    "R1-R2,PC",NE
        LDR     R0,[R0,#task_slotptr]
        CMP     R0,#nullptr
        BLNE    mapin
        Pull    "R1-R2,PC"
        ]

        END
@


4.9
log
@Add definitions of button types 11/14/15
Button type 11 was added in 1988 so is about time it had a symbol to refer to it in the sources. Added & used said symbols.
Removed 'DoubleIcon' switch, prototype button type 12.
Built binary identical module, not tested.

Version 5.43. Not tagged
@
text
@d687 1
a687 1
        CMP     R0,#-1
d698 1
a698 1
        CMP     R0,#-1
@


4.8
log
@Fix bug in Wimp_WhichIcon
When matching an icon on the iconbar the window is initially matched correctly, but the "is this the right task" filter step was trying to compare the handle with -1. The result was that you would get the first match for any iconbar icon rather than a match for *your* iconbar icon.
Unrelated: Tiling.s/Iconbar.s add a couple of comments and use symbols instead of magic numbers.
Tested with a quality 3 line BASIC program, no longer returns icon #0 all the time.

Version 5.23. Tagged as 'Wimp-5_23'
@
text
@a177 8
        [ DoubleIcon
        ; double click on iconbar icons
        LDR     R14,[SP,#20]            ; flags
        BIC     R14,R14,#if_buttontype
        ORR     R14,R14,#12 :SHL: ib_buttontype
        STR     R14,[sp,#20]
        ]

@


4.7
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@d158 1
a158 1
        MOV     R2,#"X"
d647 1
a647 1
        MOV     R2,#"X"
@


4.6
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d53 2
a54 2
        CMP     handle, #-1-iconbartabsize
        MyXError  WimpBadHandle, LE, L
d74 2
a75 2
        CMP     R4,#0
        BLE     %FT02
d88 2
a89 2
        MOVLT   R0,#WimpPriority_Maximum
        BLT     addwithpriority
d319 3
a321 2
        SUBS    handle,R0,#0
        EXIT    LE
d419 4
a422 4
        CMP     R0,#0
        MOVGT   R14,#nullptr            ; kill off iconbar if empty
        STRGT   R14,iconbarhandle
        BLGT    int_delete_window
d450 2
a451 2
        CMP     R2,#0
        Pull    "PC",LT                 ; not found (Z unset)
d458 3
d482 10
a491 10
        CMP     R1,#0
        LDRGT   R2,[R1,#icb_iconhandle]
        ADDGT   R14,handle,R2,LSL #i_shift
        LDRGT   cx0,[R14,#i_bbx0]
        LDRGT   cx1,[R14,#i_bbx1]
        SUBGT   cx1,cx1,cx0
        ADDGT   x0,x0,#iconbargap       ; allow for gap between icons
        ADDGT   x0,x0,cx1               ; plus width of icon itself
        LDRGT   R1,[R1,#icb_link]
        BGT     %BT01
d543 2
a544 2
        CMP     R2,#0
        BLT     doneicons
d618 2
a619 2
        CMP     handle,#1
        Pull    "R0-R5,R7,handle,userblk,PC",LT
d641 1
a641 1
        BLT     %FT05
d644 1
a644 1
        BLGT    mapslotinout
d663 1
a663 1
        MOVGT   R1,R0
d682 1
a682 1
        BLGT    mapslotinout
d696 1
a696 1
        BLGT    mapout
d707 1
a707 1
        BLGT    mapin
@


4.6.2.1
log
@  Added Dan Ellis's multithreading support, on a development branch for now.
Detail:
  This breaks the equivalence between tasks and AMB slots, allowing many
  threads of execution to share the same AMB slot, where an application's
  heap is usually located. In API terms, it is presented as an extension to
  Wimp_StartTask, see Docs/Multithreading for more information. It is the
  caller's responsibility to create a new stack chunk for the new thread if
  required. Note that BASIC's variable storage model is fundamentally
  unsuited for multithreading.
Admin:
  This was developed in 2001 and was not committed at the time due to lack
  of testing and peer review. It is now being added as a branch from a
  contemporary trunk Wimp. Hopefully somebody will be interested enough to
  merge the branch into a recent version!

Version 4.66, 4.77.2.1. Tagged as 'Wimp-4_66-4_77_2_1'
@
text
@d691 1
a691 1
        CMP     R0,#nullptr
d702 1
a702 1
        CMP     R0,#nullptr
@


4.5
log
@  System windows (eg STB command window) can now have window furniture but
  no 1-pixel borders.
Detail:
  The code that checked for a Wimp_Initialise version number of >= 380 before
  applying the new interpretation of title foreground colour &FF was broken:
  it was checking the current task handle instead of the task handle of the
  window's creator. A few other things needed tampering with in order to ensure
  that the window's task handle word is correctly set up at the time that the
  colour check is performed.
Admin:
  Tested in a desktop build, using STB resources.

Version 4.43. Tagged as 'Wimp-4_43'
@
text
@d286 2
a287 1
        Push    "R0,PC"                 ; Save flags
d297 1
a297 1
        TEQP    R14,#0                  ; Restore V flag
d615 1
a615 1
        Pull    "R0-R5,R7,handle,userblk,PC",LT,^
@


4.4
log
@Adapted assembly process so that the choice of Options file (previously based
purely on the "System" variable) can be overridden by passing "OPTIONS=foo" as
an argument to either MkRom, or to amu/amu_machine directly, or indirectly,
by specifying it in the components file for a build. To accomplish this, it
was necessary to switch from using aasm to objasm - hence the large number of
source files affected in this commit.

Version 4.09. Tagged as 'Wimp-4_09'
@
text
@d277 2
d280 2
a282 2
        MOVVC   R14,#0
        STRVC   R14,[handle,#w_taskhandle]      ; 'owned' by Wimp
@


4.3
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d313 1
a313 1
openiconbar ENTRY   "R1-R9,R11"
@


4.2
log
@ARTtmp branch folded in
@
text
@d126 3
d130 1
@


4.2.2.1
log
@Added a couple of extra compile-time options for use in specialied
applications; both are switched out in all standard builds.

ForceTwitter: used in combination with Twitter flag, this causes
   antitwittering to be employed irrespective of ModeFlags bit 8,
   and also irrespective of whether a window is auto-redraw or not.

HideIconBar: ensures that the icon bar is behind the backwindow, unless
   it has been brought to the front (by either method). In conjunction with
   a modified Pinboard, this can produce a quick-and-dirty iconbar-less
   machine.
@
text
@a125 3
 [ HideIconBar
        MOV     R2, #-3
 |
a126 1
 ]
@


4.1
log
@Initial revision
@
text
@d49 1
a49 1
addtoiconbar           
d149 1
a149 1
        TST     x0,#if_indirected  
d173 1
a173 1
10                                
d459 1
a459 1
        Push    "R1-R8,LR"
d476 1
a476 1
        SUBGT   cx1,cx1,cx0     
d576 2
d579 3
d597 1
a597 1
        Pull    "R1-R8,PC"
d629 1
a629 1
        CMP     R0,#0 
a630 5
        [ false
        MedusaOS
        MOVNE   R14,#16*1024*1024                ; in module space? APPSPACE
        LDREQ   R14,orig_applicationspacesize
        |
a631 1
        ]
d663 1
a663 1
        BL      recalcposns            
d665 1
a665 1
        BL      recalcposns   
d667 1
a667 1
        BL      recalcposns                     
d672 1
a672 1
        
d690 1
a690 1
        STR     R0,taskhandle  
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.1.2.1
log
@Fixed problem of iconbar corruption when icons added/removed.
Ensured that a window is redrawn if closed then opened immediately.
Merged in changes from 4.1.7.1 to 4.1.7.2 (post-icon filter stuff).
@
text
@d49 1
a49 1
addtoiconbar
d149 1
a149 1
        TST     x0,#if_indirected
d173 1
a173 1
10
d459 1
a459 1
        Push    "R1-R9,userblk,LR"
d476 1
a476 1
        SUBGT   cx1,cx1,cx0
a557 2
  [ true
	BL	int_flush_opens
a576 3
      [ ChildWindows
        STR     R0,[handle,#w_old_scx]          ; bit of a hack, but stops odd effects
      ]
a590 9

  |
;
        LDR     R14,iconbarleft + icd_extent
        LDR     R0,dx_1                         ; must be pixel-aligned
        BIC     R14,R14,R0
        STR     R14,[handle,#w_wex0]            ; poke direct!
        CMP     x0,R14
        MOVLT   x0,R14
d592 1
a592 43
        LDR     R14,iconbarright+ icd_extent
        BIC     R14,R14,R0                      ; must be pixel-aligned
        STR     R14,[handle,#w_wex1]            ; poke direct!
        LDR     R1,iconbarright + icd_widthoffset
        ADD     R14,R14,R1
        CMP     x0,R14
        MOVGT   x0,R14
	Push	x0
;
;        MOV     x0,#-bignum
;        MOV     y0,#-bignum
;        MOV     x1,#bignum
;        MOV     y1,#bignum
;        BL      int_force_redraw                ; mark invalid
;
;	Rel	R0,handle
;	MOV	R1,#-bignum
;	MOV	R2,#-bignum
;	MOV	R3,#bignum
;	MOV	R4,#bignum
;	SWI	XWimp_ForceRedraw
;
	ADD	R14,handle,#w_wax0
	LDMIA	R14,{cx0,cy0,cx1,cy1,x0,y0,x1}
	Pull	x0
;
	Rel	R0,handle
	Push	"R0,cx0,cy0,cx1,cy1,x0,y0,x1"
	Debug	icb,"openwindow:",R0,cx0,cy0,cx1,cy1,x0,y0,x1
	MOV	userblk,sp
	BL	int_open_window
	ADD	sp,sp,#u_ow1
;
      [ debugicb
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{cx0,cy0,cx1,cy1,x0,y0}
        LDR     cy0,[handle,#w_wex0]
        LDR     cy1,[handle,#w_wex1]
        Debug   icb,"recalc: iconbar =",cx0,cx1,x0, cy0,cy1
      ]
;
  ]
        Pull    "R1-R9,userblk,PC"
d624 1
a624 1
        CMP     R0,#0
d664 1
a664 1
        BL      recalcposns
d666 1
a666 1
        BL      recalcposns
d668 1
a668 1
        BL      recalcposns
d673 1
a673 1

d691 1
a691 1
        STR     R0,taskhandle
@


4.1.7.1.2.2
log
@Removed some redundant code from previous fix.
@
text
@d558 2
a577 2
; Poke these directly to stop the Wimp attempting to do a block copy
;
d580 1
a580 1
        STR     R0,[handle,#w_old_scx]          ; also old position
d596 50
d647 1
@


4.1.7.1.2.3
log
@Added support for multiple options files (RO310, RO350, RO360, RO370, RCA,
Ursula).
Removed run-time MedusaOS checks.
Enabled correct build for RISC OS 3.1 machines.
Ensured that "freepoolinuse" is cleared before OS_ChangeDynamicArea
is intercepted.
Increased maxrects to 256.
Gave copy filter window handle in R10 (if ChildWindows).
Corrected a few border problems when no toolsprites.
Made toolsprites press in immediately - in particular close and toggle can
now be highlighted.
BounceClose flag no affects all of back,close,iconise and toggle.
Made "L" validation string parsing check manually for presence of a number,
to prevent error from OS_ReadUnsigned trashing MessageTrans' error buffers.
Allow error box buttons to stretch to fit text.
Fixed bug: floating point registers were not being saved unless on a portable.
Integrated some of the Wimp_TransferBlock fixes into Wimp08 from Wimp08s.
@
text
@d631 5
d637 1
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

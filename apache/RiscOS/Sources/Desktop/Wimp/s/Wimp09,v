head	4.17;
access;
symbols
	Wimp-5_62:4.17
	Wimp-5_61:4.17
	Wimp-5_60:4.17
	Wimp-5_59:4.17
	Wimp-5_58:4.17
	Wimp-5_57:4.17
	Wimp-5_56:4.17
	Wimp-5_55:4.17
	Wimp-5_54:4.17
	Wimp-5_53:4.17
	Wimp-5_52:4.17
	Wimp-5_51:4.17
	Wimp-5_50:4.17
	Wimp-5_49:4.17
	Wimp-5_48:4.17
	Wimp-5_47-file1ad:4.17
	Wimp-5_47:4.17
	Wimp-5_46:4.17
	Wimp-5_45:4.17
	Wimp-5_44:4.17
	Wimp-5_43:4.17
	Wimp-5_42:4.17
	Wimp-5_41:4.17
	Wimp-5_40:4.17
	Wimp-5_39:4.17
	Wimp-5_38:4.17
	Wimp-5_37:4.17
	Wimp-5_36:4.17
	Wimp-5_35:4.16
	Wimp-5_34:4.16
	Wimp-5_33:4.16
	Wimp-5_32:4.16
	Wimp-5_31:4.15
	Wimp-5_30:4.14
	Wimp-530-pre4:4.14
	Wimp-5_30-pre3:4.14
	Wimp-5_30-pre2:4.14
	Wimp-5_30-pre1:4.14
	Wimp-5_29:4.14
	Wimp-5_28:4.14
	Wimp-5_27:4.14
	Wimp-5_26:4.14
	Wimp-5_25:4.14
	Wimp-5_24:4.14
	Wimp-5_23:4.14
	Wimp-5_22:4.14
	Wimp-5_21:4.14
	Wimp-5_20:4.14
	Wimp-5_19:4.14
	Wimp-5_18:4.14
	Wimp-5_17:4.14
	Wimp-5_16:4.14
	Wimp-5_15:4.14
	Wimp-5_14:4.14
	Wimp-5_13:4.14
	Wimp-5_12:4.14
	Wimp-5_11:4.14
	Wimp-5_10:4.14
	Wimp-5_09:4.14
	Wimp-5_08:4.14
	Wimp-5_07:4.14
	Wimp-5_06:4.14
	Wimp-5_05:4.14
	Wimp-5_04:4.14
	Wimp-5_03:4.14
	Wimp-5_02:4.14
	Wimp-5_01:4.14
	Wimp-4_66-4_77_2_1:4.5
	bavison_Threads_dev:4.5.0.2
	bavison_Threads_dev_bp:4.5
	Wimp-5_00:4.14
	Wimp-4_100:4.14
	Wimp-4_99:4.13
	Wimp-4_98:4.12
	Wimp-4_97:4.11
	Wimp-4_96:4.10
	Wimp-4_95:4.9
	Wimp-4_94:4.9
	RO_5_07:4.9
	Wimp-4_93:4.9
	Wimp-4_92:4.9
	Wimp-4_91:4.9
	Wimp-4_90:4.9
	Wimp-4_89:4.9
	Wimp-4_88:4.9
	Wimp-4_87:4.9
	Wimp-4_86:4.9
	Wimp-4_85:4.9
	Wimp-4_84:4.9
	Wimp-4_83:4.9
	Wimp-4_82:4.9
	Wimp-4_81:4.9
	Wimp-4_80:4.9
	Wimp-4_79:4.8
	Wimp-4_78:4.8
	Wimp-4_77:4.7
	Wimp-4_76:4.7
	Wimp-4_75:4.6
	Wimp-4_74:4.6
	Wimp-4_73:4.6
	Wimp-4_72:4.6
	Wimp-4_71:4.6
	Wimp-4_70:4.6
	Wimp-4_69:4.6
	Wimp-4_68:4.6
	Wimp-4_67:4.6
	Wimp-4_66:4.5
	Wimp-4_65:4.5
	Wimp-4_64:4.5
	Wimp-4_63:4.5
	Wimp-4_62:4.5
	Wimp-4_61:4.5
	Wimp-4_60:4.5
	Wimp-4_59:4.5
	Wimp-4_58:4.5
	Wimp-4_36-4_46_2_6:4.3
	Wimp-4_57:4.5
	Alpnet_approved:4.3
	Wimp-4_36-4_46_2_5:4.3
	Wimp-4_56:4.4
	dellis_autobuild_BaseSW:4.4
	Wimp-4_36-4_46_2_4:4.3
	Wimp-4_36-4_46_2_3:4.3
	Wimp-4_55:4.4
	Wimp-4_54:4.4
	Wimp-4_36-4_46_2_2:4.3
	Wimp-4_53:4.4
	Wimp-4_36-4_46_2_1:4.3
	Bethany:4.3.0.2
	Wimp-4_52:4.4
	Wimp-4_51:4.4
	Wimp-4_50:4.4
	Wimp-4_49:4.4
	Wimp-4_48:4.4
	Wimp-4_47:4.4
	Wimp-4_46:4.3
	Wimp-4_45:4.3
	Wimp-4_44:4.3
	Wimp-4_43:4.3
	Wimp-4_42:4.3
	sbrodie_sedwards_16Mar2000:4.3
	Wimp-4_41:4.3
	Wimp-4_40:4.3
	Wimp-4_39:4.3
	Wimp-4_38:4.3
	Wimp-4_37:4.3
	Wimp-4_36:4.3
	Wimp-4_35:4.3
	Wimp-4_34:4.3
	Wimp-4_33:4.3
	Wimp-4_32:4.3
	Wimp-4_31:4.3
	dcotton_autobuild_BaseSW:4.6
	Wimp-4_30:4.3
	Wimp-4_29:4.3
	Wimp-4_28:4.3
	Wimp-4_27:4.3
	Wimp-4_26:4.3
	Wimp-4_25:4.3
	Wimp-4_24:4.3
	Wimp-4_23:4.3
	Wimp-4_22:4.3
	Wimp-4_21:4.3
	Wimp-4_20:4.3
	Wimp-4_19:4.3
	Wimp-4_18:4.3
	Wimp-4_17:4.3
	Wimp-4_16:4.3
	Wimp-4_15:4.3
	Wimp-4_14:4.3
	Wimp-4_13:4.3
	Wimp-4_12:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	bavison_Wimp-4_11:4.3
	Ursula_RiscPC:4.1.4.1.0.2
	Wimp-4_11:4.3
	Wimp-4_10:4.3
	Wimp-4_09:4.3
	Wimp-4_08:4.2
	Wimp-4_07:4.2
	Wimp-4_06:4.2
	Wimp-4_05:4.2
	Wimp-4_04:4.2
	bavison_Wimp-4_03_noshrinkables:4.2
	Wimp-4_03:4.2
	Wimp-4_02:4.2
	Ursula_merge:4.1.4.1
	bavison_Wimp-4_01:4.2
	Wimp-4_01:4.2
	nicke_Wimp_3_96M:4.1.7.1
	bavison_Wimp-4_00_TRUNK:4.2
	bavison_Wimp-4_00:4.1.4.1
	nicke_Wimp_3_96:4.1.7.1
	mjrobert_Wimp_3_98:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	bavison_Wimp-3_99t:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	bavison_Wimp-3_99s:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	bavison_Wimp-3_99r:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	bavison_Wimp-3_99q:4.1.4.1
	jfarrell_NCWimp_3_96:4.1.7.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	bavison_Wimp-3_99p:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	bavison_Wimp-3_99o:4.1.4.1
	bavison_Wimp-3_99n:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	bavison_Wimp-3_99m:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	bavison_Wimp-3_99l:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	bavison_Wimp-3_99k:4.1.4.1
	bavison_Wimp-3_99j:4.1.4.1
	bavison_Wimp-3_99i:4.1.4.1
	bavison_Wimp-3_99h:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	bavison_Wimp_399g:4.1.4.1
	bavison_Wimp_399f:4.1.4.1
	afrost_NC2_Generic:4.1.7.1
	bavison_Wimp_399e:4.1.4.1
	bavison_Wimp_399d:4.1.4.1
	bavison_Wimp_399c:4.1.4.1
	Wimp_3_98:4.1
	kbracey_AW97:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Wimp_3_91:4.1
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.17
date	2014.03.01.22.42.58;	author jlee;	state Exp;
branches;
next	4.16;
commitid	KQ4bwdJetbz443rx;

4.16
date	2013.09.08.18.53.30;	author rsprowson;	state Exp;
branches;
next	4.15;
commitid	46q23XZLtAc5oF4x;

4.15
date	2013.08.06.23.31.43;	author jlee;	state Exp;
branches;
next	4.14;
commitid	UbPZokvIlfdkZr0x;

4.14
date	2006.02.22.09.17.53;	author jballance;	state Exp;
branches;
next	4.13;

4.13
date	2006.01.17.10.30.23;	author jballance;	state Exp;
branches;
next	4.12;

4.12
date	2006.01.11.14.17.18;	author srevill;	state Exp;
branches;
next	4.11;

4.11
date	2006.01.05.22.25.03;	author jballance;	state Exp;
branches;
next	4.10;

4.10
date	2006.01.05.13.00.16;	author jballance;	state Exp;
branches;
next	4.9;

4.9
date	2002.11.28.10.52.53;	author kbracey;	state Exp;
branches;
next	4.8;

4.8
date	2002.10.30.17.43.56;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2002.10.23.17.12.38;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2001.05.29.11.44.06;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2000.10.20.12.44.26;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2000.04.25.12.24.11;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.10.23.15.48.53;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	98.09.18.16.14.34;	author bavison;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.52;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.30.52;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.33.18;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.03.10.16.11.56;	author bavison;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.25.03;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.22.29;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.17
log
@Implement sprite translation table caching
Detail:
  This set of changes allows the Wimp to cache the last-used translation table, and cleans up some instances where translation tables were being generated and then not used
  s/Wimp01 - Expand selecttable_args to store all 8 registers needed by ColourTrans_GenerateTable. Add 1K of space for caching the palette that the cached translation table was generated from. Remove unused spriteX, spriteY variables.
  s/Wimp04 - Split cachespritedata in two. cachespritedata now only caches the basic information, while the new cachespritepixtable rotuine will generate a translation table (shaded/inverted if required). This allows table generation to be deferred until we're just about to render the sprite, ensuring that the table isn't generated only to not be used. Also updated icon sprite rendering to check the sprite is within the graphics window before attempting to render it, allowing removal of one more case where tables can be needlessly generated.
  s/NewSWIs, s/Wimp09 - Change ADR to ADRL
  s/Tiling, s/Tiling3D - Use cachespritepixtable when needed
Admin:
  Tested on Iyonix, BB-xM, StrongARM RiscPC


Version 5.36. Tagged as 'Wimp-5_36'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Wimp09

;;-----------------------------------------------------------------------------
;; Claim a block big enough for the RMA sprite pool area, then attempt to
;; map the RMA against the ROM working out the difference.
;;
;; Then claim the block so that it is big enough fill in both areas, build
;; the list and then sort it.  Using the OS_HeapSort SWI.
;;
;; in   [baseofsprites] = current RAM sprite area
;;      [baseofromsprites] = current ROM sprite area
;;      [list_at] = address of sorted list / =0 if none
;;      [listsize] = size of sorted list / =0 if none
;;      [addtoolstolist] = 0 if not to / >0 then add tool sprites pool (if present)
;;      [tool_areaCB] = valid control block for adding tool sprites (if required)
;; out  [list_at] = base of sorted list / =0 if none
;;      [list_size] = size of sorted list (aligned to boundary)
;;      [list_end] = real end of list used when scanning for sprite
;;-----------------------------------------------------------------------------

alignvalue      * 64                    ; *MUST* be a Log2 value

        ASSERT  list_size=list_at+4

makespritelist Entry   "R0-R4,R8-R9"

        LDRB    R3,addtoolstolist
        TEQ     R3,#0                   ; should I add the tool sprites?
        LDRNE   R0,=SpriteReason_ReadAreaCB +&100
        ADRNEL  R1,tool_areaCB
        SWINE   XOS_SpriteOp            ; Yes then decode the RAM based control block
;
        MOV     R8,R3
        Debuga  sprite,"Sprite count for Tools =",R8
;
        LDR     R0,=SpriteReason_ReadAreaCB +&100
        LDR     R1,baseofromsprites
        SWI     XOS_SpriteOp            ; attempt to get number of ROM sprites
;
        ADD     R8,R8,R3                ; add to growing total
        Debuga  sprite,", ROM =",R3
;
        LDRB    R3,addtoolstolist
        TEQ     R3,#0                   ; Adding tool sprites?
        LDREQ   R0,=SpriteReason_ReadAreaCB +&100
        LDREQ   R1,baseofsprites        ; base of RAM area
        SWIEQ   XOS_SpriteOp            ; No then include iconsprites
;
        Debug   sprite,", RAM =",R3
;
        ADD     R3,R8,R3                ; total number of sprites to be obtained
        ADD     R3,R3,#alignvalue -1
        BICS    R3,R3,#alignvalue -1    ; align to nice boundary
        BLEQ    freelist                ; un allocate the list (if null)
        BEQ     %FT60                   ; exit - if null (flag as so)
;
        LDR     R2,list_size
        CMP     R2,R3,LSL #2            ; is the current buffer big enough?
        BHS     %FT10                   ; if not then skip the new cliam
;
        BL      freelist                ; release the current list
;
        MOV     R0,#ModHandReason_Claim
        MOV     R3,R3,ASL #2
        BL     XROS_Module              ; attempt to claim

        DebugE  sprite,"Cant allocate list buffer "

        BVS     %FT60                   ; and fall back if failed to get required memory
;
        Debug   sprite,"list buffer allocated at, size:",R2,R3
;
        ADRL    R0,list_at
        STMIA   R0,{R2,R3}              ; store bounds of the list away
10
        LDR     R3,list_at              ; R3 -> buffers to store names pointers at

        Debug   sprite,"Start of sprite list: ",R3

        LDRB    R0,addtoolstolist
        TEQ     R0,#0                   ; Adding tool sprites?
        BNE     %FT25                   ; Yes then jump, don't include RAM icon sprites

        LDR     R0,baseofsprites
        LDR     R1,[R0,#saFirst]
        ADD     R1,R1,R0                ; R1 -> first sprite in area
        LDR     R2,[R0,#saNumber]       ; R2 = count for number of sprites
;
        Debug   sprite,"RAM sprites; first, count =",R1,R2
;
20      SUBS    R2,R2,#1
        STRPL   R1,[R3],#4              ; store a pointer away
        LDRPL   R0,[R1,#spNext]
        ADDPL   R1,R1,R0                ; advance to the next sprite
        BPL     %BT20                   ; looping until finished
;
        Debug   sprite,"End of RAM sprite list =",R3
;
25      LDR     R0,baseofromsprites
        LDR     R1,[R0,#saFirst]
        ADD     R1,R1,R0                ; R1 -> start of ROM pool
        LDR     R2,[R0,#saNumber]       ; R2 = counter for number of sprites in area
;
        Debug   sprite,"ROM sprites; first, count =",R1,R2
30
        SUBS    R2,R2,#1                ; decrease counter
        STRPL   R1,[R3],#4              ; store another pointer away
        LDRPL   R0,[R1,#spNext]
        ADDPL   R1,R1,R0                ; advance to next
        BPL     %BT30                   ; looping until finished (bla de bla)
;
        LDRB    R2,addtoolstolist
        TEQ     R2,#0                   ; add the tools area to the list of sprites
        BEQ     %FT35
;
        ADRL    R0,tool_areaCB
        LDR     R1,[R0,#saFirst]
        ADD     R1,R1,R0
        LDR     R2,[R0,#saNumber]
;
        Debug   sprite,"Tool sprites; first, count =",R1,R2
31
        SUBS    R2,R2,#1                ; have we finished copying the pointers yet?
        STRPL   R1,[R3],#4
        LDRPL   R0,[R1,#spNext]
        ADDPL   R1,R1,R0                ; advance to next sprite
        BPL     %BT31                   ; until finished
35
        Debug   sprite,"End of entire list =",R3
;
; Now perform a Heap Sort of the list.
;
        Push    "R3"                    ; storing the top limit away
        LDR     R1,list_at              ; start of list
        SUB     R0,R3,R1
        MOV     R0,R0,ASR #2            ; number of items in list
      [ debugsprprior
        ADRL    R2,checkspritenames     ; comparison routine
      |
        ADR     R2,checkspritenames     ; comparison routine
      ]
        MOV     R3,WsPtr

        Debug   sprite,"HeapSort: Items, At, Checker =",R0,R1,R2

        TST     R1,#2_111:SHL:29        ; high address?
        BNE     %FA37
        SWI     XOS_HeapSort            ; attempt to sort the list
        B       %FA39
37      Push    "R7"
        MOV     R7,#0
        SWI     XOS_HeapSort32          ; use new SWI with 32-bit address
        Pull    "R7"

39      Pull    "R3"                    ; restore original boundary for the list

; Now attempt to remove duplicates by simply scanning down the list from start to
; end.  This we do by checking first to see if we have reached the end, if we
; have then we can exit.  Otherwise we get two pointers if they are the
; same then we block the entire list back down assuming that the first name
; compared is the

      [ SpritePriority
        LDR     R8,baseofhisprites
      |
        LDR     R8,baseofsprites
      ]
        LDR     R9,[R8,#saEnd]
        LDR     R2,list_at              ; start of the list to be scanned

        Debug   sprite,"HeapSort done, scan the list for duplicates"

40      SUB     R4,R3,R2
        CMP     R4,#8                   ; have we finished yet?
        STRLO   R3,list_end             ; setup the chopping end
        EXIT    LO

        LDMIA   R2,{R0,R1}
        BL      checkspritenames        ; are the two sprite names the same?
        ADDNE   R2,R2,#4
        BNE     %BT40                   ; loop back until all finished

 [ debugsprite
        ADD     R14,R0,#spName
        DebugS  sprite,"Duplicate:",R14,12
 ]
        SUB     R14,R0,R8               ; is first sprite in the RAM low area? (or high-priority if SpritePriority true)
        CMP     R14,R9
        ADDCC   R2,R2,#4                ; advance past entry if inside the RAM area, otherwise copy next name over current

      [ SpritePriority
        LDR     R4,[R2]                 ; note address of sprite being removed from list
      ]
        MOV     R0,R2                   ; start to copy from
50      CMP     R0,R3                   ; have we finished yet?
        SUBEQ   R3,R3,#4
        BEQ     %FT55                   ; looping until all copied (modify the end pointer as required)

        LDR     R1,[R0,#4]
        STR     R1,[R0],#4              ; copy it down
        B       %BT50                   ; loop until the list has been moved

55
      [ SpritePriority
        LDR     R0, preferredpool
        TEQ     R0, #0
        DebugIf EQ, sprprior, "RAM sprites preferred"
        BEQ     %BT40                   ; don't do anything if RAM sprites have priority

        Push    "R8,R9"
        LDR     R8, baseofsprites       ; see if the removed sprite was in the RAM sprite area
        LDR     R9, [R8, #saEnd]
        SUB     R0, R4, R8
        CMP     R0, R9
        Pull    "R8,R9", HS
      [ debugsprprior
        ADDHS   R4, R4, #spName
        DebugSIf HS, sprprior, "This removed sprite was not in RAM area: ", R4, 12
      ]
        BHS     %BT40                   ; don't do anything if removed sprite wasn't in the RAM sprite area

        Push    "R2,R5"
        LDR     R5, [R4, #spNext]       ; size of sprite (== amount to shift later pointers down by)
      [ debugsprprior
        Debug   sprprior, "Deleting sprite from RAM area: addr, size =", R4, R5
        ADD     R4, R4, #spName
        DebugS  sprprior, "- name = ", R4, 12
        SUB     R4, R4, #spName
      ]
        MOV     R0, #512
        ORR     R0, R0, #SpriteReason_DeleteSprite
        MOV     R1, R8
        MOV     R2, R4
        SWI     XOS_SpriteOp            ; delete the unnecessary sprite
    [ windowsprite
      [ ThreeDPatch
        MOV     R0,#0                   ; RAM pointers are now stale
        BL      reset_all_tiling_sprites
      |
        MOV     R0,#-1                  ; RAM pointers are now stale
        STR     R0,tiling_sprite
      ]
    ]
        LDR     R2, list_at             ; go back to beginning of list
56      CMP     R2, R3                  ; have we finished yet?
        Pull    "R2,R5,R8,R9", EQ
        BEQ     %BT40                   ; go back to check next pair of sprites

        LDR     R0, [R2]
        SUB     R1, R0, R8
        CMP     R1, R9
        ADDHS   R2, R2, #4
        BHS     %BT56                   ; this sprite wasn't in the RAM area, so won't have been affected by the deletion
        CMP     R0, R4
        ADDLO   R2, R2, #4
        BLO     %BT56                   ; this sprite was below the deleted sprite, so again no action is required
        SUB     R0, R0, R5
      [ debugsprprior
        ADD     R0, R0, #spName
        DebugS  sprprior, "Realigned sprite:", R0, 12
        SUB     R0, R0, #spName
      ]
        STR     R0, [R2]                ; move pointer down
        ADD     R2, R2, #4
        B       %BT56                   ; check next pointer
      |
        B       %BT40                   ; go back to check next pair of sprites
      ]

60      MOV     R0,#-1
        STR     R0,list_at              ; flag as no valid list setup
        STR     R0,list_size
        EXIT

;..............................................................................

; Compare the two sprite names, ensuring case insensitive and truncating
; at the twelth character

; in    R0 -> sprite to compare
;       R1 -> sprite to compare against
; out   NE/EQ GT/LT CS/CC

checknames Entry "R0-R4"
        B       %FT05

checkspritenames ALTENTRY

        ADD     R0,R0,#spName           ; ensure pointing at the sprite names
        ADD     R1,R1,#spName
05      MOV     R2,#12                  ; maximum string length = 12 characters

10      LDRB    R3,[R0],#1
        LDRB    R4,[R1],#1              ; get characters
        CMP     R3,#32
        MOVLE   R3,#0
        CMP     R4,#32
        MOVLE   R4,#0                   ; convert to terminators if required
        ASCII_LowerCase R3,LR
        ASCII_LowerCase R4,LR           ; ensure that the characters are lower case
        CMP     R3,R4                   ; and that they match
        EXIT    NE                      ; returning if not the same
;
        TEQ     R3,#0                   ; is it the end of the strings?
        SUBNES  R2,R2,#1
        BNE     %BT10                   ; loop back if still characters pending
;
        CMP     R3,R4                   ; compare the final characters
        EXIT


;;-----------------------------------------------------------------------------
;; Free list - attempt to release the list memory if currently allocated.
;;
;; in   [list_at] >0 then release block
;; out  [list_at] [list_size] = 0
;;-----------------------------------------------------------------------------

freelist EntryS  "R0-R2"

        Debug   sprite,"Calling to free sprite list",#list_at
;
        LDR     R2,list_at
        CMP     R2,R2,ASR #31           ; is the list memory allocated?
        MOVNE   R0,#ModHandReason_Free
        BLNE    XROS_Module              ; yes, so release it (ignore errors)
;
        MOV     R2,#0
        STR     R2,list_at
        STR     R2,list_size            ; mark as released
;
        EXITS


;;-----------------------------------------------------------------------------
;; Locate a sprite name setting its pointers to meaningful values.  This routine
;; attempts to binary chop the sprite list created by calling "makespritelist".
;;
;; Based on the algorithm in Knuth; Sorting/Searching, pp 407
;;
;; in   [spritename] --> sprite name
;; out  R2 -> sprite, VS/VC if not found/found
;;-----------------------------------------------------------------------------

getspriteaddr Entry "R0-R1,R3-R5"

        LDR     R0,spritename           ; get pointer to name to compare against
;
        LDR     R2,list_at              ; base of sprite pointerrs
        CMP     R2,R2,ASR #31           ; this may be 0 (not initialised) or -1 (no room)
        BEQ     %FT20
        LDR     R3,list_end
        SUB     R3,R3,R2
        SUB     R3,R3,#4
        MOV     R3,R3,ASR #2            ; u = size of list
        MOV     R4,#0                   ; l = 0

10      CMP     R4,R3                   ; if l>u then not found
        BGT     %FT20
;
        ADD     R5,R4,R3
        MOV     R5,R5,ASR #1            ; i = (l+u) /2
;
        LDR     R1,[R2,R5,ASL #2]
        ADD     R1,R1,#spName
;
        BL      checknames
        ADDGT   R4,R5,#1                ; if [R0]>[R1] l = i + 1
        SUBLT   R3,R5,#1                ; if [R0]<[R1] l = i - 1
        BNE     %BT10
;
        LDR     R2,[R2,R5,ASL #2]       ; R2 -> sprite found !!!
        CLRV
        EXIT
20
        MOV     R2,#0                   ;
        SETV                            ; else return 'cos not found V set!
        EXIT


;;-----------------------------------------------------------------------------
;; Handle the opening of the messages file - check first to see if it has
;; already been opened.
;;
;; in   -
;; out  R0 -> 16 byte block for messages (may already be open)
;;-----------------------------------------------------------------------------

GetMessages ROUT

        Push    "R1-R2,LR"
;
        LDR     R0,messages
        CMP     R0,#0                   ; is it open yet?
        BNE     %FT10
;
        ADRL    R0,message_block
        ADR     R1,messfsp
        MOV     R2,#0                   ; let MessageTrans do caching
        SWI     XMessageTrans_OpenFile
        ADRVCL  R0,message_block
        STRVC   R0,messages             ; pointer to messages block

        Debug   err,"Message block @@",R0
10
        Pull    "R1-R2,PC"

messfsp = "WindowManager:Messages",0
        ALIGN


;;-----------------------------------------------------------------------------
;; Handle losing the messages file if its already opened.
;;-----------------------------------------------------------------------------

LoseMessages ROUT

        Push    "R0,LR"
;
        LDR     R0,messages
        CMP     R0,#0                   ; is it already open? (clears V)
        SWINE   XMessageTrans_CloseFile
        STRVS   R0,[SP]
;
        MOV     R14,#0
        STR     R14,messages            ; flag as lost (always!)
;
        Pull    "R0,PC"


;;-----------------------------------------------------------------------------
;; QuickLookup - look up token (no buffer), parameters in R4-R7 are optional
;;
;; in   R0 -> token to lookup
;; out  R0 -> text found
;;      R1 = length of text found
;;-----------------------------------------------------------------------------
QuickLookup
        Entry   "R2,R3"
        MOV     R1,R0
        MOV     R2,#0
        MOV     R3,#0
        BL      GetMessages             ; open messages if required
        SWI     XMessageTrans_Lookup
        MOVVC   R0,R2
        MOVVC   R1,R3
        EXIT

;;-----------------------------------------------------------------------------
;; LookupToken - resolve token into user specified buffer (with parameters)
;;
;; in   R0 -> token to lookup
;;      R2 -> buffer
;;      R3 = length of buffer
;;      R4 -> %0 substitution
;;      R5-R7 assumed to be zero
;;-----------------------------------------------------------------------------

LookupToken Entry "R1-R7"

        MOV     R1,R0                   ; -> token to be used
        B       %FA10

;;------------------------------------------------------------------------------
;; LookupToken1 - lookup token into user specified buffer
;;
;; in   R0 -> token to lookup
;;      R2 -> buffer
;;      R3 = length of buffer
;;------------------------------------------------------------------------------

LookupToken1 ALTENTRY

        MOV     R1,R0
        MOV     R4,#0                   ; justincase!
        MOV     R5,#0
10      MOV     R6,#0
        MOV     R7,#0
        BL      GetMessages             ; open messages if required
        SWI     XMessageTrans_Lookup
        EXIT


;;-----------------------------------------------------------------------------
;; Lookup an error block expanding and then return.
;;
;; in   R0 -> error block
;; out  R0 -> error block and overflow set
;;-----------------------------------------------------------------------------

ErrorLookup ROUT

        Push    "R0-R7,LR"
;
        BL      GetMessages             ; attempt to open the file
        ADDVS   sp,sp,#4
        BVS     %FT10                   ; reporting any errors in the process
;
        MOV     R1,R0                   ; R1 -> control block
        Pull    "R0"                    ; R0 -> error block
        MOV     R2,#0
        MOV     R4,#0                   ; no parameters
        MOV     R5,#0
        MOV     R6,#0
        MOV     R7,#0

 [ debugerr
        Debuga  err,"WimpErrorLookup,r0,r1",R0,R1
        ADD     R14, R0, #4
        DebugS  err," Token:",R14
 ]
        SWI     XMessageTrans_ErrorLookup
10
        Pull    "R1-R7,PC"              ; look it up and then return


;------------------------------------------------------------------------------
; Constants required for message checking routines
;------------------------------------------------------------------------------

messcheck_version       * 284


;;-----------------------------------------------------------------------------
;; Wimp_AddMessages
;;
;; This SWI will add a null terminated list of messages to the list of
;; accepted messages on the current task.  This is really only any use for
;; tasks which know about Wimp >= 284.
;;
;; in   R0 -> list of messages / =0 for none
;; out  -
;;-----------------------------------------------------------------------------

SWIWimp_AddMessages

        MyEntry "AddMessages"

        Debug   msgsel,"Wimp_AddMessages: list ->",R0

        MOVS    R3,R0
        BEQ     ExitWimp                ; if no messages to add then exit

        LDR     R4,taskhandle           ; currently active task

        LDR     R0,[WsPtr,R4]           ; -> task record
        LDR     R0,[R0,#task_wimpver]
        LDR     R1,=messcheck_version
        CMP     R0,R1                   ; is it worth adding to the list?
        BLHS    addmessages

        B       ExitWimp

;..............................................................................

; Add a list of messages to the messages to the internal task handle specified,
; in doing so we may actually have to allocate a block.
;
; The routine attempts to add the messages at the end and then perform
; a heap sort.  Having first checked for duplicates, this is not a speed
; critical operation (ie. not called on null-event).

; in    R3 -> list of messages / null terminated
;       R4 = internal task handle to add messages to / assumed to be valid
; out   -

addmessages Entry "R0-R7"

        Debug   msgsel,"add messages: list, task =",R3,R4

        MOV     R5,#0
10      LDR     R6,[R3,R5]
        TEQ     R6,#0                   ; end of the list encountered?
        ADDNE   R5,R5,#4
        BNE     %BT10                   ; loop back until finished scanning

        CMP     R5,#0                   ; is there any messages to add?
        EXIT    EQ                      ; if not then return without doing anything

        Debug   msgsel,"size of messages list =",R5

; R5 = size of messages list to add / create

        LDR     R4,[WsPtr,R4]           ; get pointer to the task block

        LDR     R2,[R4,#task_messages]
        CMP     R2,#nullptr
        EXIT    EQ                      ; the real fix for the AddMessages-to-task-that-already-wants-them bug
        CMP     R2,#0
        BNE     addmoremessages         ; add to the list if non-zero, create new block

        Push    "R3"
        MOV     R3,R5                   ; size of list to create
        MOV     R0,#ModHandReason_Claim
        BL     XROS_Module              ; attempt to allocate
        Pull    "R3"
        EXIT    VS

        Debug   msgsel,"new message buffer: size, at =",R5,R2

        STR     R2,[R4,#task_messages]
        STR     R5,[R4,#task_messagessize]
        Push    "R2,R5"

20      LDR     R6,[R3],#4
        TEQ     R6,#0
        STRNE   R6,[R2],#4              ; copy a message number
        BNE     %BT20                   ; loop back until all checked

        Pull    "R2,R6"
        B       sortmessages            ; ensure they are sorted

;..............................................................................

; add more to the current list - extend the current block by R5 and then
; attempt to add the messages at the end removing duplicates, once
; done shrink the block down to a real size.

; in    R3 -> list of messages to be added
;       R4 -> task record
;       R5 = number of words to append

addmoremessages
        LDR     R1,[R4,#task_messagessize]
        LDR     R2,[R4,#task_messages]  ; current list information

 [ RO4 :LAND: false ; This is too late to do this fix; if the app wants all messages, the the Wimp hasn't allocated a
                    ; messages list, and so addmoremessages doesn't get called. Interestingly, this fix is undone in
                    ; the patches to 4.02...
; MB FIX
; If the current message list has only the 0 terminator in it then the application wants all messages.
; So, don't bother adding these new messages as that will stop all other messages getting through.
	LDR	R14,[R2,#0]
	TEQ	R14,#0
	EXIT	EQ
; end MB FIX
 ]

        Push    "R3"
        MOV     R0,#ModHandReason_ExtendBlock
        MOV     r3, r5                  ;  jb/ma 4/1/06 r5 is already the extra space required
        BL     XROS_Module              ; attempt to extend it
        Pull    "R3"                    ; preserve the list pointer
        EXIT    VS

        Debug   msgsel,"extended message block at, size =",R2,R1

        MOV     R6,R1                   ; extending boundary  (old message size)

30      LDR     R7,[R3],#4              ; get a value from the list
        TEQ     R7,#0
        BEQ     %FT50

        Debug   msgsel,"adding message (check for duplicate) =",R7

        MOV     R0,R1                   ; index to check entries by

40      SUBS    R0,R0,#4
        STRMI   R7,[R2,R6]
        ADDMI   R6,R6,#4                ; add in at the end if end reached
        BMI     %BT30

        LDR     R14,[R2,R0]             ; get a message number
        CMP     R14,R7                  ; does it already exist
        BNE     %BT40                   ; loop back until found
        B       %BT30                   ; if it doesn't then try another entry

50      ADD     r3,r1,r5                ; jb/ma 18/1/06 total needed + claimed
        SUBS    r3,r6,r3                ; jb/ma 18/1/06 actual less above
                                        ; so give back any not needed
        MOVNE   R0,#ModHandReason_ExtendBlock
        BLNE   XROS_Module              ; reduce back to a meaningful size
        EXIT    VS

        Debug   msgsel,"after block truncate: at, change =,size =",R2,R3,R6

        STR     R2,[R4,#task_messages]  ; update to contain new size
        STR     R6,[R4,#task_messagessize] ; jb/ma 4/1/06 this is the actual size
                                           ; r3 is only the change in size

sortmessages
        Debug   msgsel,"sort list at, size =",R2,R6

        MOV     R0,R6,LSR #2            ; size of the list to be sorted
        MOV     R1,R2                   ; -> list to be sorted
        MOV     R2,#0                   ; sorting unsigned integers
        TST     R1,#2_111:SHL:29
        BNE     %FT55
        SWI     XOS_HeapSort
        B       %FT57
55      MOV     R7,#0
        SWI     XOS_HeapSort32
57
        Debug   msgsel,"list sorted and ready to rock and roll"

        EXIT


;;-----------------------------------------------------------------------------
;; Wimp_RemoveMessages
;;
;; Attempt to remove a set of messages being accepted by a task, no errors
;; are generated for unknown messages.  This call only applies to tasks
;; with a version >= 284.
;;
;; in   R0 -> list of messages / =0 for none
;; out  -
;;-----------------------------------------------------------------------------

SWIWimp_RemoveMessages

        MyEntry "RemoveMessages"

        Debug   msgsel,"Wimp_RemoveMessages: list at =",R0

        MOVS    R3,R0                   ; is there a messages list?
        CMPNE   R3,#nullptr
        BEQ     ExitWimp                ; exit if there is no list supplied

        LDR     R4,taskhandle

        LDR     R0,[WsPtr,R4]           ; -> task that is currently active
        LDR     R0,[R0,#task_wimpver]   ; = version number known by this task
        LDR     R1,=messcheck_version
        CMP     R0,R1                   ; is the tasks version number valid for this call?
        BLHS    removemessages

        B       ExitWimp

;..............................................................................

; remove the list of messages at R3 using internal handle of R4.

; in    R3 -> list of messages (will be non-zero)
;       R4 = internal task handle
; out   -

removemessages Entry "R1-R2,R4-R8"

        Debug   msgsel,"Selective remove task, list at =",R3,R4

        LDR     R4,[WsPtr,R4]           ; -> task block

        LDR     R2,[R4,#task_messages]
        CMP     R2,R2,ASR #31           ; are there any messages listed?
                                        ; (or does the task need to continue to receive all messages anyway?)
        LDRNE   R6,[R4,#task_messagessize]
        CMPNE   R6,#0
        EXIT    EQ                      ; if no messages then return

        Debug   msgsel,"selective remove list, size =",R2,R6

; R2 -> messages list
; R6 = size of the list to be scanned

10      MOV     R7,#0                   ; index into the list

        LDR     R8,[R3],#4              ; get message to be removed
        CMP     R8,#0
        BEQ     %FT40                   ; when end of list reached then reduce block size

        Debug   msgsel,"scan to remove message =",R8

; R7 = index into list of messages being scanned
; R8 = message to be removed

20      CMP     R7,R6                   ; have we reached the end of the list yet?
        BGE     %BT10                   ; loop back as finished scanning

        LDR     R0,[R2,R7]              ; get message we are looking at
        CMP     R0,R8                   ; remove this one?
        ADDNE   R7,R7,#4
        BNE     %BT20                   ; loop back until all checked

        Debug   msgsel,"message found at offset =",R7

30      CMP     R7,R6                   ; have we finished yet?
        ADDLT   R14,R7,#4
        LDRLT   R0,[R2,R14]
        STRLT   R0,[R2,R7]              ; copy the next message into the current slot
        ADDLT   R7,R7,#4                ; advance the pointer
        BLT     %BT30                   ; loop back until all checked

        Debug   msgsel,"message removed: new list size =",R6

        SUB     R6,R6,#4
        B       %BT10                   ; and try again until whole list scanned
40
        LDR     R3,[R4,#task_messagessize]  ; old size
        STR     R6,[R4,#task_messagessize]  ; new size
        SUBS    r3,r6,r3                ; jb/ma 4/1/06 check what we did not use
                                        ; and give back any unused

        MOVNE   R0,#ModHandReason_ExtendBlock
        BLNE    XROS_Module              ; attempt to reduce the block size
        STRVC   R2,[R4,#task_messages]  ; and then store updated block pointer

        Debug   msgsel,"after extend block: size of list =",R2,R6

        EXIT


;;-----------------------------------------------------------------------------
;; Remove all messages allocated to this task - flagging as removed.
;;
;; in   R5 = internal task handle
;; out  -
;;-----------------------------------------------------------------------------

removeallmessages Entry "R0,R2,R4-R5"

        Debug   msgsel,"remove all messages for task =",R5

        LDR     R5,[WsPtr,R5]           ; -> task record to be modified

        LDR     R2,[R5,#task_messages]
        CMP     R2,R2,ASR #31           ; is there a list attached
        MOVNE   R0,#ModHandReason_Free
        BLNE   XROS_Module              ; attempt to release it

        MOV     R2,#-1                  ; flag as no list of messages
        STR     R2,[R5,#task_messages]
        MOV     R2,#0
        STR     R2,[R5,#task_messagessize]

        CLRV
        EXIT


;;------------------------------------------------------------------------------
;; Scan to see if a message is active for the specified task.  This routine
;; must scan using the internal task handle specified and see if we can
;; broadcast to it.
;;
;; The routine takes the destination task handle and looks to see if it
;; has a messages list attached, if the pointer to this list is -1 (default)
;; then it is assumed that all messages are passed through (old style task)
;; otherwise it attempts to binary chop the list to find the required
;; message.
;;
;; in   R2 -> message block
;;      R3 -> task block (known to be alive)
;;      R5 = external task handle
;; out  R5 = R5 AND msf_broadcast
;;              IF R5 =0 on entry or message is not supported
;;------------------------------------------------------------------------------

checkformessage

        Entry   "R0-R4"

        LDR     R0,[R3,#task_messages]
        LDR     R1,[R3,#task_messagessize]
        CMP     R0,#nullptr             ; are all messages enabled?
        EXIT    EQ                      ; yes, so send all of them

        Debug   msgsel,"into check for message; block at, task, external =",R2,R3,R5

        LDR     R2,[R2,#ms_action +msb_size]
        TEQ     R2,#Message_Quit        ; message quit is always allowed
        EXIT    EQ                      ; so always return ....

        TEQ     R0,#0                   ; duff list characteristics?
        TEQNE   R1,#0
        ANDEQ   R5,R5,#msf_broadcast
        EXIT    EQ                      ; if so then return flaging as don't broadcast - quit already trapped!

        Debug   msgsel,"list at, size, msg =",R0,R1,R2

        SUB     R1,R1,#4
        MOV     R1,R1,LSR #2            ; R1 = size of list
        MOV     R3,#0                   ; R3 = l = 0

10      CMP     R1,R3                   ; end of list reached?
        ANDLT   R5,R5,#msf_broadcast
        EXIT    LT                      ; yes, so mark as not to be sent and then return

        ADD     R4,R1,R3
        MOV     R4,R4,LSR #1            ; get the mid point

        LDR     R14,[R0,R4,LSL #2]      ; get the message at this location
        CMP     R14,R2
        SUBGT   R1,R4,#1
        ADDLT   R3,R4,#1                ; adjust based on result, if equal then don't bother
        BNE     %BT10                   ; looping whilst not found

        Debug   msgsel,"message found =",R14,R2

        EXIT


        END
@


4.16
log
@3 minor fixes, 2 minor enhancements
Makefile:
* Conditionally copy the disc resources, saving a little build time.
Wimp10.s; hdr/Wimp:
* Issue Service_WimpToolSpritesChanged when the tool sprite area is changed.
Wimp05:
* Fix bug in softloaded versions of the Wimp where menus would randomly lose the keyboard shortcut text. This was caused by use of an LDR to retrieve a byte wide variable. This specifically affected some softloads because the Wimp gets squeezed, and during unsqueezing the Wimp's workspace ends up being allocated from the same bit of RMA that used to contain the squeezed copy of the module (=lots of random numbers).
Wimp09:
* Fix bug where configuring WimpSpritePrecedence to ROM when a theme is loaded would cause redrawing of window textures to fail. This is because the Wimp intersects the ROM and RAM sprite areas and deletes any duplicates from the RAM area when remaking the fast lookup sprite list. So if the RAM sprites include the "tile_1" (etc) sprite on redrawing the desktop the Wimp points to this, then intersects the lists and deletes the sprite, leaving the pointers pointing at junk. Now, on deleting something, the window tile pointers are invalidated. Fixes ticket #346.
Wimp02:
* Fix bug where the title bar text, when the desktop font is the system font, is incorrectly rendered in the colour selected by WimpVisualFlag -WindowOutlineColour. The Wimp now restores the text colour if -WOC has set the graphics colour to something other than black.

Administrative -
In Wimp01, swap a couple of SpriteReasons from magic numbers. In the init of variables use the common reset_all_tiling_sprite function.
In Tiling3D, more SpriteReasons, and rationalise the registers used in reset_all_tiling_sprites.

Version 5.32. Tagged as 'Wimp-5_32'
@
text
@d87 1
a87 1
        ADR     R0,list_at
@


4.15
log
@Replace OS_SpriteOp reason code magic numbers with definitions. Add support for new screen modes.
Detail:
  s/Tiling, s/Tiling3D, s/Watchdog, s/Wimp05, s/Wimp07, s/Wimp09 - Replaced OS_SpriteOp reason code magic numbers with symbolic definitions.
  s/Wimp01 - Update *WimpMode / Wimp_SetMode to use OS_ScreenMode 13 (mode string to specifer) in place of its own code if a mode specifier string has been given. Note - mode number handling is unchanged, so a mode specifier string which begins with a mode number will currently have the specifier part ignored.
  s/Wimp01, s/Wimp02 - Flag_* -> ModeFlag_* renaming
  s/Wimp02 - Fix mode specifier copying to only stop copying when we hit a mode variable of -1. Previous code would also stop if the variable value was -1. Update mode set code to apply the Wimp's special greyscale palettes if the greyscale mode flag is set (i.e. greyscale mode was set via specifier generated by OS_ScreenMode 13)
Admin:
  Tested on BB-xM


Version 5.31. Tagged as 'Wimp-5_31'
@
text
@d249 9
a257 1

d356 1
a356 1
;; out  R2 -> sprite, VS/VC if found/not found
@


4.14
log
@	Removemessages entry failed to put rma base in R2..
Detail:
	caused occasional aborts on task quit.
Admin:	castle added IP


Version 4.100. Tagged as 'Wimp-4_100'
@
text
@d245 1
a245 1
        ORR     R0, R0, #25
@


4.13
log
@	tidy fixes in Wimp09 .
Detail:
	tidied up logic of wimp_addmessages memory salvage
Admin:
	(this is a file that built!)

Version 4.99. Tagged as 'Wimp-4_99'
@
text
@d750 2
a751 2
        LDR     R5,[R4,#task_messages]
        CMP     R5,R5,ASR #31           ; are there any messages listed?
d757 1
a757 1
        Debug   msgsel,"selective remove list, size =",R5,R6
d759 1
a759 1
; R5 -> messages list
d776 1
a776 1
        LDR     R0,[R5,R7]              ; get message we are looking at
d785 2
a786 2
        LDRLT   R0,[R5,R14]
        STRLT   R0,[R5,R7]              ; copy the next message into the current slot
@


4.12
log
@  Fixed so it builds.
Detail:
  s.Wimp09 contained a stray line saying "block count" which surprisingly
  didn't assemble. Removed.
Admin:
  Builds. Haven't tested whether it performs to spec yet.

Version 4.98. Tagged as 'Wimp-4_98'
@
text
@a647 1
;        ADD     R3,R1,R5
d674 3
a676 5
50      LDR     r3,[r2,#-4]             ; jb/ma 4/1/06 check size block actually is
        SUB     r3,r3,#4                ; jb/ma 4/1/06 compensate for this block count
        SUBS    r3,r6,r3                ; jb/ma 4/1/06 check what we did not use
                                        ; and give back any unused
;        MOV     R3,R6
a685 1
;        STR     R3,[R4,#task_messagessize]
@


4.11
log
@	tuned memory recovery in addmessage in Wimp09 to take account of the
	granularity of RMA allocation. now does not consume/not return rma
Detail:
Admin: castle added ip


Version 4.97. Tagged as 'Wimp-4_97'
@
text
@a800 1
block count
@


4.10
log
@	Fixed small memory leak in Wimp09 when adding and removing
	messages
Detail:
	use of R3 value in OS_Module extend block entry was incorrect..
	it was used as absolute size required, should be changed size required.
	resulted in wrong block re-sizing.

Admin:
	castle added IP.


Version 4.96. Tagged as 'Wimp-4_96'
@
text
@d616 1
a616 1
        Pull    "R2,R3"
d675 3
a677 1
50      SUBS    r3, r6, r5              ; jb/ma 4/1/06 check what we did not use
d692 1
a692 1
        Debug   msgsel,"sort list at, size =",R2,R3
d694 1
a694 1
        MOV     R0,R3,LSR #2            ; size of the list to be sorted
d801 3
d805 2
a806 4
        SUBS    R3,R6,R3                ; compute changed size needed
        LDR     R2,[R4,#task_messages]
        MOV     R0,#ModHandReason_ExtendBlock
        BL     XROS_Module              ; attempt to reduce the block size
@


4.9
log
@Fix to Wimp_DeleteIcon stiffing the machine when trying to delete an
icon which doesn't yet exist.Now fails gracefully.
Import of another set of awful icons in the Iyonix resources.
Tweak to the number of CLI parameters accepted by * commands.

Version 4.80. Tagged as 'Wimp-4_80'
@
text
@d647 2
a648 1
        ADD     R3,R1,R5
d655 1
a655 1
        MOV     R6,R1                   ; extending boundary
d675 5
a679 3
50      MOV     R3,R6
        MOV     R0,#ModHandReason_ExtendBlock
        BL     XROS_Module              ; reduce back to a meaningful size
d682 1
a682 1
        Debug   msgsel,"after block truncate: at, size =",R2,R3
d684 4
a687 2
        STR     R2,[R4,#task_messages]  ; update to contian new size
        STR     R3,[R4,#task_messagessize]
d797 2
a798 1
        STR     R6,[R4,#task_messagessize]
d800 1
a800 1
        MOV     R3,R6
d806 1
a806 1
        Debug   msgsel,"after extend block: size of list =",R2,R3
@


4.8
log
@  Merged in RISC OS 4.02 changes (including ROM patches). Also som bugfixes.
Detail:
  RISC OS 4 changes:
  * Font blending for desktop font (based on NC code, but now configurable)
  * 3-D window/menu/iconbar borders
  * Textured menu backgrounds
  * Loss of rubout box in unfilled text+sprite icons
  * *WimpVisualFlags controls various aspects of cosmetic changes above
  * Iconise button "slot" glyph slightly shorter (but only adopted in the RO400
    Resource directory)
  * Command window has front-window flag set
  * Byte at +39 of the window block has gained two new flag bits:
      bit 2 set => this window must never be given a 3D border
      bit 3 set => this window must always be given a 3D border
      (note that ResEd erroneously created windows with both bits set,
      this case is treated as though both bits were clear)
  * Another two colour specifiers on the end of C validation string command
    for icons controls the foreground and background colours to be used when
    the icon is selected
  * Pointer shape is correctly reprogrammed by the creation of icon
    underneath it
  * Full stops in writable icons are treated the same as spaces from the
    point of view of cursor navigation
  * spritesize routine returns a size of 0 if the sprite didn't exist
    (probably fixes some rendering problems)
  * Adjust-click on back icon brings window to front
  My changes:
  * DeleteRight turned on
  * Icon bar title background is set to default in all resource sets (avoids
    translation table recalc)
  * Error box title now cream across all resource sets
  * RISC OS 4 changes made 32-bit compatible / high addresses safe
  * Undocumented FullIconClipping option disabled
  * Command help made consistent for internationalised and non-
    internationalised builds
  * WimpVisualFlags defaults made sensible
  * Menu side width affected by ThreeD option at *run* time not assemble time
  * Right-clicking on menus with writable items no longer data aborts
  * Auto-opened menus are now at RHS of current icon (matches RISC OS 3.1)
  * Colour menus were knackered unless menu tiling was enabled
  * Fixed a bug whereby adding messages to a task that wanted all messages
    actually caused it to lose all other messages. The RISC OS 4 fix for
    this didn't work
  * Fixed bug introduced in version 4.76: tasks that wanted no messages got
    all of them
  * Autoscrolling is updated every 8 cs rather than every 12 cs
  * Added menu texture to pre-RISC OS 4 sprites files
Admin:
  Tested on Tungsten.

Version 4.78. Tagged as 'Wimp-4_78'
@
text
@d160 2
d163 7
a169 1
        Pull    "R3"                    ; restore original boundary for the list
d690 2
d693 4
a696 1

@


4.7
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@d585 3
a587 1
        CMP     R2,R2,ASR #31
d625 12
d708 1
a708 1
        BEQ     ExitWimp                ; exit if there is no list currently defined
d736 1
d842 3
a844 4
        CMP     R0,R0,ASR #31           ; are the messages enabled?
        LDRNE   R1,[R3,#task_messagessize]
        CMPNE   R1,#0                   ; if there is is the list big enough?
        EXIT    EQ                      ; no, so send them all of them
@


4.6
log
@  Minor fixes, some of which have been waiting to be committed for a while.
Detail:
  * Command line buffer for Wimp_StartTask (and anything that uses it,
    eg *WimpTask) increased from 256 bytes to 1024 bytes.
  * Top-bit-set message list pointers passed to Wimp_Initialise and
    Wimp_RemoveMessages now work (there was never a problem with
    Wimp_AddMessages!)
  * The fix for top-bit-set application name pointers in Wimp 4.65 actually
    only fixed lookup for "<application> may have gone wrong" lookups. They
    now work correctly in error window title construction, and when
    constructing an application sprite name if flag bit 8 is clear.
  * A pointer value of 0 is now accepted in addition to -1 for an
    "<application> may have gone wrong" lookup - this brings it into line
    with the other two places where the application name pointer is
    referenced.
  * When constructing an error window title, the Wimp would skip any leading
    backslash character. Now it does so when constructing "<application> may
    have gone wrong" too - this is a simple way to disable the application
    sprite in the error window.
Admin:
  Error box behaviour actually tested this time!

Version 4.67. Tagged as 'Wimp-4_67'
@
text
@d73 1
a73 1
        BGE     %FT10                   ; if not then skip the new cliam
d181 2
a182 2
        STRLT   R3,list_end             ; setup the chopping end
        EXIT    LT
d322 3
a324 3
        CMP     R2,#0                   ; is the list memory allocated?
        MOVGT   R0,#ModHandReason_Free
        BLGT    XROS_Module              ; yes, so release it (ignore errors)
d348 2
a349 2
        CMP     R2,#1                   ; this may be 0 (not initialised) or -1 (no room)
        BLT     %FT20
d548 1
a548 1
        BLGE    addmessages
d585 2
a586 2
        CMP     R2,#0
        BGT     addmoremessages         ; add to the list if non-zero, create new block
d702 1
a702 1
        BLGE    removemessages
d721 4
a724 4
        CMP     R5,#0                   ; are there any messages listed?
        LDRGT   R6,[R4,#task_messagessize]
        CMPGT   R6,#0
        EXIT    LE                      ; if no messages then return
d791 3
a793 3
        CMP     R2,#0                   ; is there a list attached
        MOVGT   R0,#ModHandReason_Free
        BLGT   XROS_Module              ; attempt to release it
d827 4
a830 4
        CMP     R0,#0                   ; are the messages enabled?
        LDRGT   R1,[R3,#task_messagessize]
        CMPGT   R1,#0                   ; if there is is the list big enough?
        EXIT    LT                      ; no, so send them all of them
@


4.5
log
@  Shock horror - a new feature for the Wimp! And some housekeeping too.
Detail:
  * Added new functionality for menu trees: submenus can now be opened by
    clicking on their parent menu item. This is particularly aimed at
    touchscreen devices, and is configurable via the new *Configure keyword
    WimpClickSubmenu.
  * Change to the menu inactivity timeout behaviour after auto-opening of
    submenus (either by hovering over the parent menu item or by the new
    click-to-open functionality): although all hover operations are still
    ignored for this period, any click operations *will* now be obeyed.
  * Corrected numerous misleading comments in the menu handling code.
  * Added some suspiciously absent ALIGNs in the *Configure keyword handlers.
  * Uses new ASCII case-forcing macros so there are now fewer warnings
    printed during assembly (and it should run faster now too).
  * Added an AREA directive so that objasm's -ABS switch is no longer needed.
  * Standardised ErrMem token across all Messages files that use English.
Admin:
  Tested on a desktop machine.
  Requires HdrSrc 1.06.

Version 4.57. Tagged as 'Wimp-4_57'
@
text
@d693 2
a694 1
        BLE     ExitWimp                ; exit if there is no list currently defined
@


4.4
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d297 2
a298 2
        LowerCase R3,LR
        LowerCase R4,LR                 ; ensure that the characters are lower case
@


4.3
log
@Adapted assembly process so that the choice of Options file (previously based
purely on the "System" variable) can be overridden by passing "OPTIONS=foo" as
an argument to either MkRom, or to amu/amu_machine directly, or indirectly,
by specifying it in the components file for a build. To accomplish this, it
was necessary to switch from using aasm to objasm - hence the large number of
source files affected in this commit.

Version 4.09. Tagged as 'Wimp-4_09'
@
text
@d182 1
a182 1
        EXITS   LT
d209 1
a209 1
55      
d215 1
a215 1
        
d227 1
a227 1
        
d241 1
a241 1
        
d246 1
a246 1
        
d271 1
a271 1
        EXITS
d317 1
a317 1
freelist Entry  "R0-R2"
d576 1
a576 1
        EXITS   EQ                      ; if not then return without doing anything
d799 2
a800 1
        EXITS
d829 1
a829 1
        EXITS   LT                      ; no, so send them all of them
d835 1
a835 1
        EXITS   EQ                      ; so always return ....
d840 1
a840 1
        EXITS   EQ                      ; if so then return flaging as don't broadcast - quit already trapped!
d850 1
a850 1
        EXITS   LT                      ; yes, so mark as not to be sent and then return
d863 1
a863 1
        EXITS
@


4.2
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d39 1
a39 1
makespritelist ENTRY   "R0-R4,R8-R9"
d282 1
a282 1
checknames ENTRY "R0-R4"
d317 1
a317 1
freelist ENTRY  "R0-R2"
d343 1
a343 1
getspriteaddr ENTRY "R0-R1,R3-R5"
d437 1
a437 1
        ENTRY   "R2,R3"
d457 1
a457 1
LookupToken ENTRY "R1-R7"
d565 1
a565 1
addmessages ENTRY "R0-R7"
d713 1
a713 1
removemessages ENTRY "R1-R2,R4-R8"
d783 1
a783 1
removeallmessages ENTRY "R0,R2,R4-R5"
d822 1
a822 1
        ENTRY   "R0-R4"
@


4.1
log
@Initial revision
@
text
@d115 1
a115 1
        ADD     R1,R1,R0                ; R1 -> start of RAM pool
d151 3
d155 1
d169 3
d173 1
d193 1
a193 1
        SUB     R14,R0,R8               ; is first sprite in the RAM area?
d197 3
d203 1
a203 1
        BEQ     %BT40                   ; looping until all copied (modify the end pointer as required)
d208 59
@


4.1.4.1
log
@Main new features in Ursula build so far
(some are also available in other builds):

* New icon highlighting scheme - hue rotated 180 degrees, photographic negative,
  darkened 25% - suits Ursula icons better.
* Release-button window tools compile-time switch turned on.
* Any "TASK" word cleared on exit from Wimp_OpenWindow, Wimp_GetWindowState,
  Wimp_ForceRedraw and Wimp_CloseDown.
* Child windows are no longer allowed to be opened inside the icon bar.
* Message_IconizeAt generation optimised, and no longer calls non-X SWIs.
* Message_IconsChanged implemented, and switched out on speed grounds.
* Wimp_ReadSysInfo 15 removed, replaced with (new) Wimp_Extend 11.
* Backwindows are now segregated from normal windows. A new category,
  foreground windows, are added, and stay above all other windows. (The error
  box template is updated to make it a foreground window.)
* ROM sprites override RAM sprites (and duplicate RAM sprites are deleted
  during the building of the sprite lookup list, preceding the first sprite
  plot after a sprite pool update).
* Wimp_ReadSysInfo 16 added, to return sprite area pointers in order of
  priority (Wimp_BaseOfSprites retains the ROM/RAM distinction).
* Error box code altered:
  + symbolic names used for offsets into tempworkspace
  + error button text buffer enlarged
  + stretched error buttons now shrink back for next use
  + int_flush_opens called at appropriate points to ensure buttons are seen to
    slab in, and to reduce flicker when redisplaying error box at a different
    width (also fixes some redraw bugs)
  + Cancel button given the R6 type border when it will be activated by Return
    (and is therefore moved to the extreme right in such cases)
  + Escape now always selects the second-right button (unless there's only one
    button!) - this also fixes a bug when there's a single user-defined button
  + keypresses in "xxx may have gone wrong" error boxes are now correctly
    interpreted - previously the buttons available in the underlying box were
    being used to determine the effect of keys
  + maximum number of buttons increased from 4 to 8, and the machine no longer
    crashes when the maximum is exceeded
  + window stretches horizontally to keep error message to 7 lines or less
* Bugfix: opening or creating a window with a minimum x visible area coordinate
  of -1 was leading to any of smearing/flickering/recursive drawing. (This was
  actually due to a failure to recognise which windows' positions had been
  updated.)
* Features merged in from spinner branch Wimp:
  + support for UpCall_MediaSearchEndMessage added
  + control-termination allowed in upcalls (used to require null-termination)
  + escape character switched to default during error box display, then
    switched back again afterwards
* GetRectangle filters are now called with (internal) window handle in R10.
* Autohourglass is deactivated whenever WrchV is invoked. (Also optimised.)
* Action button bugfixes:
  + action buttons now deselect if the pointer is dragged off and a window tool
    is the pressed before all the buttons have been released
  + action buttons now slab in following a long (autorepeating) press on a
    scroll arrow window tool
@
text
@d115 1
a115 1
        ADD     R1,R1,R0                ; R1 -> start of ROM pool
a150 3
      [ debugsprprior
        ADRL    R2,checkspritenames     ; comparison routine
      |
a151 1
      ]
a164 3
      [ SpritePriority
        LDR     R8,baseofhisprites
      |
a165 1
      ]
d185 1
a185 1
        SUB     R14,R0,R8               ; is first sprite in the RAM low area? (or high-priority if SpritePriority true)
a188 3
      [ SpritePriority
        LDR     R4,[R2]                 ; note address of sprite being removed from list
      ]
d192 1
a192 1
        BEQ     %FT55                   ; looping until all copied (modify the end pointer as required)
a196 59

55      
      [ SpritePriority
        LDR     R0, preferredpool
        TEQ     R0, #0
        DebugIf EQ, sprprior, "RAM sprites preferred"
        BEQ     %BT40                   ; don't do anything if RAM sprites have priority
        
        Push    "R8,R9"
        LDR     R8, baseofsprites       ; see if the removed sprite was in the RAM sprite area
        LDR     R9, [R8, #saEnd]
        SUB     R0, R4, R8
        CMP     R0, R9
        Pull    "R8,R9", HS
      [ debugsprprior
        ADDHS   R4, R4, #spName
        DebugSIf HS, sprprior, "This removed sprite was not in RAM area: ", R4, 12
      ]
        BHS     %BT40                   ; don't do anything if removed sprite wasn't in the RAM sprite area
        
        Push    "R2,R5"
        LDR     R5, [R4, #spNext]       ; size of sprite (== amount to shift later pointers down by)
      [ debugsprprior
        Debug   sprprior, "Deleting sprite from RAM area: addr, size =", R4, R5
        ADD     R4, R4, #spName
        DebugS  sprprior, "- name = ", R4, 12
        SUB     R4, R4, #spName
      ]
        MOV     R0, #512
        ORR     R0, R0, #25
        MOV     R1, R8
        MOV     R2, R4
        SWI     XOS_SpriteOp            ; delete the unnecessary sprite
        
        LDR     R2, list_at             ; go back to beginning of list
56      CMP     R2, R3                  ; have we finished yet?
        Pull    "R2,R5,R8,R9", EQ
        BEQ     %BT40                   ; go back to check next pair of sprites
        
        LDR     R0, [R2]
        SUB     R1, R0, R8
        CMP     R1, R9
        ADDHS   R2, R2, #4
        BHS     %BT56                   ; this sprite wasn't in the RAM area, so won't have been affected by the deletion
        CMP     R0, R4
        ADDLO   R2, R2, #4
        BLO     %BT56                   ; this sprite was below the deleted sprite, so again no action is required
        SUB     R0, R0, R5
      [ debugsprprior
        ADD     R0, R0, #spName
        DebugS  sprprior, "Realigned sprite:", R0, 12
        SUB     R0, R0, #spName
      ]
        STR     R0, [R2]                ; move pointer down
        ADD     R2, R2, #4
        B       %BT56                   ; check next pointer
      |
        B       %BT40                   ; go back to check next pair of sprites
      ]
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

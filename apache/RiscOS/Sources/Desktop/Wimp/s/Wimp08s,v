head	4.14;
access;
symbols
	Wimp-5_62:4.14
	Wimp-5_61:4.14
	Wimp-5_60:4.14
	Wimp-5_59:4.14
	Wimp-5_58:4.14
	Wimp-5_57:4.14
	Wimp-5_56:4.14
	Wimp-5_55:4.14
	Wimp-5_54:4.14
	Wimp-5_53:4.14
	Wimp-5_52:4.13
	Wimp-5_51:4.12
	Wimp-5_50:4.12
	Wimp-5_49:4.11
	Wimp-5_48:4.10
	Wimp-5_47-file1ad:4.10
	Wimp-5_47:4.10
	Wimp-5_46:4.10
	Wimp-5_45:4.10
	Wimp-5_44:4.10
	Wimp-5_43:4.10
	Wimp-5_42:4.10
	Wimp-5_41:4.10
	Wimp-5_40:4.10
	Wimp-5_39:4.10
	Wimp-5_38:4.9
	Wimp-5_37:4.9
	Wimp-5_36:4.9
	Wimp-5_35:4.9
	Wimp-5_34:4.9
	Wimp-5_33:4.9
	Wimp-5_32:4.9
	Wimp-5_31:4.9
	Wimp-5_30:4.9
	Wimp-530-pre4:4.9
	Wimp-5_30-pre3:4.9
	Wimp-5_30-pre2:4.9
	Wimp-5_30-pre1:4.9
	Wimp-5_29:4.9
	Wimp-5_28:4.9
	Wimp-5_27:4.9
	Wimp-5_26:4.9
	Wimp-5_25:4.9
	Wimp-5_24:4.9
	Wimp-5_23:4.9
	Wimp-5_22:4.9
	Wimp-5_21:4.9
	Wimp-5_20:4.9
	Wimp-5_19:4.9
	Wimp-5_18:4.9
	Wimp-5_17:4.9
	Wimp-5_16:4.9
	Wimp-5_15:4.9
	Wimp-5_14:4.9
	Wimp-5_13:4.9
	Wimp-5_12:4.9
	Wimp-5_11:4.9
	Wimp-5_10:4.9
	Wimp-5_09:4.9
	Wimp-5_08:4.9
	Wimp-5_07:4.9
	Wimp-5_06:4.9
	Wimp-5_05:4.9
	Wimp-5_04:4.9
	Wimp-5_03:4.9
	Wimp-5_02:4.9
	Wimp-5_01:4.9
	Wimp-4_66-4_77_2_1:4.4.2.1
	bavison_Threads_dev:4.4.0.2
	bavison_Threads_dev_bp:4.4
	Wimp-5_00:4.9
	Wimp-4_100:4.9
	Wimp-4_99:4.9
	Wimp-4_98:4.9
	Wimp-4_97:4.9
	Wimp-4_96:4.9
	Wimp-4_95:4.9
	Wimp-4_94:4.9
	RO_5_07:4.9
	Wimp-4_93:4.9
	Wimp-4_92:4.9
	Wimp-4_91:4.9
	Wimp-4_90:4.9
	Wimp-4_89:4.9
	Wimp-4_88:4.9
	Wimp-4_87:4.9
	Wimp-4_86:4.9
	Wimp-4_85:4.9
	Wimp-4_84:4.9
	Wimp-4_83:4.9
	Wimp-4_82:4.9
	Wimp-4_81:4.9
	Wimp-4_80:4.9
	Wimp-4_79:4.8
	Wimp-4_78:4.8
	Wimp-4_77:4.8
	Wimp-4_76:4.7
	Wimp-4_75:4.5
	Wimp-4_74:4.4
	Wimp-4_73:4.4
	Wimp-4_72:4.4
	Wimp-4_71:4.4
	Wimp-4_70:4.4
	Wimp-4_69:4.4
	Wimp-4_68:4.4
	Wimp-4_67:4.4
	Wimp-4_66:4.4
	Wimp-4_65:4.4
	Wimp-4_64:4.4
	Wimp-4_63:4.4
	Wimp-4_62:4.4
	Wimp-4_61:4.4
	Wimp-4_60:4.4
	Wimp-4_59:4.4
	Wimp-4_58:4.4
	Wimp-4_36-4_46_2_6:4.2
	Wimp-4_57:4.4
	Alpnet_approved:4.2
	Wimp-4_36-4_46_2_5:4.2
	Wimp-4_56:4.3
	dellis_autobuild_BaseSW:4.3
	Wimp-4_36-4_46_2_4:4.2
	Wimp-4_36-4_46_2_3:4.2
	Wimp-4_55:4.3
	Wimp-4_54:4.3
	Wimp-4_36-4_46_2_2:4.2
	Wimp-4_53:4.3
	Wimp-4_36-4_46_2_1:4.2
	Bethany:4.2.0.2
	Wimp-4_52:4.3
	Wimp-4_51:4.3
	Wimp-4_50:4.3
	Wimp-4_49:4.3
	Wimp-4_48:4.3
	Wimp-4_47:4.3
	Wimp-4_46:4.2
	Wimp-4_45:4.2
	Wimp-4_44:4.2
	Wimp-4_43:4.2
	Wimp-4_42:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Wimp-4_41:4.2
	Wimp-4_40:4.2
	Wimp-4_39:4.2
	Wimp-4_38:4.2
	Wimp-4_37:4.2
	Wimp-4_36:4.2
	Wimp-4_35:4.2
	Wimp-4_34:4.2
	Wimp-4_33:4.2
	Wimp-4_32:4.2
	Wimp-4_31:4.2
	dcotton_autobuild_BaseSW:4.4
	Wimp-4_30:4.2
	Wimp-4_29:4.2
	Wimp-4_28:4.2
	Wimp-4_27:4.2
	Wimp-4_26:4.2
	Wimp-4_25:4.2
	Wimp-4_24:4.2
	Wimp-4_23:4.2
	Wimp-4_22:4.2
	Wimp-4_21:4.2
	Wimp-4_20:4.2
	Wimp-4_19:4.2
	Wimp-4_18:4.2
	Wimp-4_17:4.2
	Wimp-4_16:4.2
	Wimp-4_15:4.2
	Wimp-4_14:4.2
	Wimp-4_13:4.2
	Wimp-4_12:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.2.1
	bavison_Wimp-4_11:4.2
	Ursula_RiscPC:4.1.2.1.0.2
	Wimp-4_11:4.2
	Wimp-4_10:4.2
	Wimp-4_09:4.2
	Wimp-4_08:4.2
	Wimp-4_07:4.2
	Wimp-4_06:4.2
	Wimp-4_05:4.2
	Wimp-4_04:4.2
	bavison_Wimp-4_03_noshrinkables:4.2
	Wimp-4_03:4.2
	Wimp-4_02:4.2
	Ursula_merge:4.1.2.1
	bavison_Wimp-4_01:4.2
	Wimp-4_01:4.2
	bavison_Wimp-4_00_TRUNK:4.2
	bavison_Wimp-4_00:4.1.2.1
	mjrobert_Wimp_3_98:4.1.2.1
	rthornb_UrsulaBuild-19Aug1998:4.1.2.1
	UrsulaBuild_FinalSoftload:4.1.2.1
	bavison_Wimp-3_99t:4.1.2.1
	rthornb_UrsulaBuild-12Aug1998:4.1.2.1
	bavison_Wimp-3_99s:4.1.2.1
	aglover_UrsulaBuild-05Aug1998:4.1.2.1
	bavison_Wimp-3_99r:4.1.2.1
	rthornb_UrsulaBuild-29Jul1998:4.1.2.1
	bavison_Wimp-3_99q:4.1.2.1
	rthornb_UrsulaBuild-22Jul1998:4.1.2.1
	bavison_Wimp-3_99p:4.1.2.1
	rthornb_UrsulaBuild-15Jul1998:4.1.2.1
	bavison_Wimp-3_99o:4.1.2.1
	bavison_Wimp-3_99n:4.1.2.1
	rthornb_UrsulaBuild-07Jul1998:4.1.2.1
	bavison_Wimp-3_99m:4.1.2.1
	rthornb_UrsulaBuild-17Jun1998:4.1.2.1
	rthornb_UrsulaBuild-03Jun1998:4.1.2.1
	bavison_Wimp-3_99l:4.1.2.1
	rthornb_UrsulaBuild-27May1998:4.1.2.1
	rthornb_UrsulaBuild-21May1998:4.1.2.1
	bavison_Wimp-3_99k:4.1.2.1
	bavison_Wimp-3_99j:4.1.2.1
	bavison_Wimp-3_99i:4.1.2.1
	bavison_Wimp-3_99h:4.1.2.1
	rthornb_UrsulaBuild_01May1998:4.1.2.1
	bavison_Wimp_399g:4.1.2.1
	bavison_Wimp_399f:4.1.2.1
	bavison_Wimp_399e:4.1.2.1
	bavison_Wimp_399d:4.1.2.1
	bavison_Wimp_399c:4.1.2.1
	Wimp_3_98:4.1.2.1
	kbracey_AW97:4.1
	Daytona:4.1.0.4
	Daytona_bp:4.1
	Ursula:4.1.0.2
	Ursula_bp:4.1
	Wimp_3_91:4.1
	ARTtmp_bp:1.1.2.4
	ARTtmp_merge:1.1.2.4
	ARTtmp:1.1.0.2;
locks; strict;
comment	@# @;


4.14
date	2016.05.23.21.53.13;	author jlee;	state Exp;
branches;
next	4.13;
commitid	JVRG5UWTKsMNCE7z;

4.13
date	2016.05.08.16.48.43;	author jlee;	state Exp;
branches;
next	4.12;
commitid	xXPn2osqjffdqH5z;

4.12
date	2015.10.10.12.15.03;	author jlee;	state Exp;
branches;
next	4.11;
commitid	hTZlaaPZyibzGyEy;

4.11
date	2015.09.01.21.04.12;	author jlee;	state Exp;
branches;
next	4.10;
commitid	QMv9svFdvVc4SAzy;

4.10
date	2014.04.13.13.53.19;	author jlee;	state Exp;
branches;
next	4.9;
commitid	1vwXUmZfh2aHKwwx;

4.9
date	2002.10.31.18.53.06;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2002.10.25.15.34.26;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2002.10.23.17.16.38;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2002.10.23.17.12.37;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	2002.08.22.21.40.06;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2000.10.20.12.44.26;	author bavison;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	2000.04.25.12.24.10;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.09.18.16.14.33;	author bavison;	state Exp;
branches;
next	4.1;

4.1
date	97.05.07.14.15.50;	author kbracey;	state Exp;
branches
	4.1.2.1;
next	1.1;

1.1
date	97.04.10.13.51.36;	author kbracey;	state dead;
branches
	1.1.2.1;
next	;

4.4.2.1
date	2007.10.07.02.17.29;	author bavison;	state Exp;
branches;
next	;
commitid	NSavcPvbNd36pBAs;

4.1.2.1
date	97.10.21.14.01.39;	author mstphens;	state Exp;
branches;
next	;

1.1.2.1
date	97.04.10.13.51.37;	author kbracey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	97.04.14.12.22.17;	author kbracey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	97.04.14.15.29.08;	author kbracey;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	97.04.28.16.50.17;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Fix invalid AMB node handle being used when low on memory
Detail:
  s/Wimp08s - If OS_AMBControl allocate is asked for a AMB node with a size > 0, but no pages can be claimed, it frees the node and returns an invalid handle (0). Make sure that the Wimp's allocateslot routine is aware of this, so that we don't try passing that bad handle back to AMBControl later on
  s/Iconbar - Use nullptr constant instead of -1 when checking task_slotsize (aka AMB node handle on modern machines)
Admin:
  Tested on BB-xM
  Fixes abort seen when attempting to start a task with no pages in the free pool


Version 5.53. Tagged as 'Wimp-5_53'
@
text
@; Copyright 1997 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > s.Wimp08s


; This is the current source code - s.Wimp08 is old source code - see
; comments at top of s.Wimp08
;
; mjs
;
;;----------------------------------------------------------------------------
;; Switcher routines
;;----------------------------------------------------------------------------

; Wimp delegates task memory management to kernel, via OS_AMBControl

; Wimp_SlotSize
; Wimp_ClaimFreeMemory
; Wimp_TransferBlock
;
; findpages             look for application memory & set up free pool
; testapplication       see if the application space is in use
; restorepages          put the rest of the pages back after the current slot
; allocateslot          transfer pages from free pool to a slot array
; deallocateslot        transfer pages from a slot array to free pool
; mapslotin             map pages in a slot into application space
; mapslotout            map pages in a slot out of the way
;
; initdynamic           intercept SWI table entry
; resetdynamic          unintercept SWI table entry
; My_ChangeDynamic      stack the applications to fill up application space
;-----------------------------------------------------------------------------

; Data structures:
; task table -> task block (or task_unused if task dead)
; task block -> slot block for task
; freepool -> slot block for free pool (with room for all pages)
; slot block = { page, addr, protection }* -1 -1
;              (suitable for OS_ReadMemMapEntries and OS_FindMemMapEntries)
; freepoolbase, orig_applicationspacesize delimit the free pool

;-----------------------------------------------------------------------------


; Set/Read current Wimp slot size
; Entry:  R0 = new 'current' slot size in bytes (<0 ==> no change)
;         R1 = new 'next' slot size in bytes (<0 ==> no change)
; Exit:   R0 = actual 'current' slot size
;         R1 = actual 'next' slot size
;         R2 = total amount of free memory 'owned' by the Wimp
;              if R2 < R1, the next slot will not be allocated in full
;              when no tasks are running, R2 will be 0
;         if R0>=0 on entry, pages may be remapped and MemoryLimit changed


SWIWimp_SlotSize  ROUT
        MyEntry "SlotSize"

   Debug mjs2,"Wimp_SlotSize",R0,R1
;
        MOV     R4,R0                   ; R4 = new current slot size
;
        MOV     R2,R1                   ; R2 = proposed slot size
        SWI     XOS_ReadMemMapInfo
        CMP     R2,#-1                  ; if -ve, just read current value
        LDREQ   R3,slotsize
        BEQ     %FT01
        ADD     R2,R2,R0                ; R2 = (R2+size-1) DIV size * size
        SUB     R2,R2,#1
        DivRem  R3,R2,R0,R14,norem
        STR     R3,slotsize             ; [slotsize] = no of pages
01
        Push    "R0-R1"
    [ ShrinkableAreas
        MOV     R0, #5
        MOV     R1, #-1
        SWI     XOS_DynamicArea         ; memory in free pool + shrinkable
    |
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea
        MOV     R2,R1                   ; memory in free pool
    ]
        Pull    "R0-R1"

        MUL     R1,R3,R0                ; R1 = next slot size
        STMIA   SP,{R1,R2}              ; ensure calling task gets new values

;
; transfer pages between current slot and free pool
; on exit R0 = actual current slot size (whether or not memory could be moved)
;
        CMP     R4,#-1                  ; R4 = proposed new current slot size
        BEQ     returnmemsize           ; done if just reading

        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        MOV     R3,R1                   ; R3 --> end of current slot
        MOV     R0,#MemoryLimit
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        TEQ     R1,R3
        BNE     returnmemsize           ; cannot change slot size
;
        LDR     R0,pagesize             ; R0 = page size
        SUB     R14,R0,#1
        ADD     R4,R4,R14
        BIC     R4,R4,R14               ; round up to nearest page boundary
;
        LDR     R5,taskhandle           ; obtain R5 --> task block
        LDR     R5,[wsptr,R5]
        TST     R5,#task_unused
        LDRNE   R5,pendingtask
        TST     R5,#task_unused
        BNE     returnmemsize           ; no current task (?)
;
        LDR     R2,[R5,#task_slotptr]   ; R2 --> slot (if any)
        CMP     R2,#nullptr
        BLEQ    getnullslot
        STRVC   R2,[R5,#task_slotptr]   ; R2 --> slot
        BVS     ExitWimp                ; exit if unable to claim block

        MOV     R1,R4,LSR #12           ;no. of (4k) pages
        MOV     R0,#2                   ;grow/shrink reason code
        SWI     XOS_AMBControl
        BVS     ExitWimp
        CMP     R2,#0
        MOVEQ   R2,#nullptr
        STR     R2,[R5,#task_slotptr]
        MOV     R1,R1,LSL #12           ;no. of bytes
        CMP     R1,R3,LSL #12           ;did no. of pages change?
        BEQ     returnmemsize
        MOV     R5,R1                   ;for message
        ADR     lr, returnmemsize
        B       sendmemmessage

; SafeChangeDynamic
; if running under Medusa then the CAO needs to be moved high, otherwise
; the CDA call will fail.
; Entry : R4 number of bytes to move (signed), R0-R3 possibly corrupt
; Exit  : R1 number of bytes actually moved (unsigned)
SafeChangeDynamic
        Push    "lr"
        MOV     R0,#15
        ADR     R1,SafeChangeDynamic
        SWI     XOS_ChangeEnvironment
        BVS     %FT03                   ; can't change cao, try and shift memory anyway.
        MOV     R2,R1
        MOV     R0,#6                   ; freepool
        MOV     R1,R4                   ; number of bytes to alter free pool by
        SWI     XOS_ChangeDynamicArea
        Push    "R1"
        MOV     R1,R2
        MOV     R0,#15
        SWI     XOS_ChangeEnvironment   ; put cao back where it was.
        Pull    "R1,PC"
03
        MOV     R0,#6                   ; freepool
        MOV     R1,R4                   ; number of bytes to alter free pool by
        SWI     OS_ChangeDynamicArea
04
        Pull    "PC"

;
; send round a broadcast, to be picked up by the Switcher
; NB this can only be done if the task is alive (otherwise it has no handle)
;
sendmemmessage
        Push    "lr"
        STR     R1,appspacesize
        LDR     R14,taskhandle
        LDR     R14,[wsptr,R14]
        TST     R14,#task_unused

    Debug mjs2,"sendmemmessage R1,R5",R1,R5
;
        ASSERT  ms_data=20
        MOVEQ   R0,#28                  ; 28 byte block
        MOVEQ   R3,#0                   ; your ref
        LDREQ   R4,=Message_SlotSize
        LDREQ   R6,[sp,#1*4]            ; next slot size (already on stack)
        Push    "R0-R6"
        MOVEQ   R0,#User_Message        ; don't bother getting reply
        MOVEQ   R1,sp
        MOVEQ   R2,#0                   ; broadcast
        BLEQ    int_sendmessage         ; fills in sender, myref
        ADD     sp,sp,#28
        Pull    "pc"

returnmemsize
    Debug mjs2,"returnmemsize R1",R1
        MOV     R0,#MemoryLimit         ; may not actually be full slot size
        MOV     R1,#0                   ; (eg. if Twin is running above)
        SWI     XOS_ChangeEnvironment
    Debug mjs2,"  returnmemsize R1",R1
        SUBVC   R0,R1,#ApplicationStart ; R0 = actual slot size
    Debug mjs2,"  returnmemsize R0,R1",R0,R1
        B       ExitWimp
        LTORG

getnullslot
   Push  "R0-R1,LR"
   MOV   R0,#0  ;reason code 0 (allocate)
   MOV   R1,#0  ;0 pages
   SWI   XOS_AMBControl
   Debug mjs2,"getnullslot, slot handle =",R2
   STRVS R0,[SP]
   Pull  "R0-R1,PC"

servicememorymoved
  ; If OS_ChangeDynamicArea claims some or all of the application slot (ie if Service_Memory
  ; isn't claimed or UpCall_MovingMemory was claimed) then we need to issue Message_SlotSize
  ; to keep the Switcher up-to-date.
        Push    "R0-R6,LR"
        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        LDR     R0,appspacesize
        SUB     R1,R1,#ApplicationStart
        TEQ     R1,R0
        Pull    "R0-R6,PC", EQ
        LDR     R0,slotsize
        MOV     R5,R1
        MOV     R0,R0,LSL #12
        Push    "R0"
        BL      sendmemmessage
        ADD     SP,SP,#4
        Pull    "R0-R6,PC"

;
; Claim free memory pages
; Entry:  R0 = 0 for release, 1 for claim
;         R1 = length required
; Exit:   R1 = length available
;         R2 = start address
;         R2 = 0 means memory could not be claimed (no need to release)
; Can't:  if not enough free memory
;         if claimed already
;         if in the middle of a remapping operation
;

mem_remapped    *       2_0001
mem_claimed     *       2_0010

wimparea
        DCB     "Wimp"
        ALIGN

SWIWimp_ClaimFreeMemory  ROUT
        MyEntry "ClaimFreeMemory"
        Debug wcf, "Wimp_ClaimFreeMemory -> R0,R1", R0, R1
;
        CMP     R0,#0
        BNE     %FT01
; free
        MOV     R0,#0
        ADRL    R14,freepoolinuse
        STRB    R0,[R14]
  [ KernelLocksFreePool
        MOV     R0,#10
        ORR     R0,R0,#&100
        MOV     R1,#0
        SWI     XOS_Memory                              ; release wimp lock
        CLRV                                            ; Assume errors can be ignored (SWI not implemented in recent kernels)
  ]
        B       ExitWimp
01
; claim
        ADRL    R10,freepoolinuse
        LDRB    R0,[R10]
        TEQ     R0,#0
        MOVNE   R0,#0
        STRNE   R0,[SP]
        STRNE   R0,[SP,#4]
        BNE     ExitWimp                                ; already 'claimed'
  [ DynamicAreaWCF
        LDR     R14,wcfda
        TEQ     R14,#0
        BNE     %FT50
  ]
        MOV     R9,R1                                   ; preserve the amount asked for
        MOV     R0,#2
        MOV     R1,#6
        SWI     XOS_DynamicArea
        MOVVC   R0,R3
        MOVVC   R1,R2
        MOVVS   R0,#0                                   ; Shouldn't happen
        MOVVS   R1,#0
        TST     R4,#1:SHL:20                            ; Physical memory pool?
        MOVNE   R0,#0                                   ; Assume no logical mapping
        MOVNE   R1,#0

        CMP     R9,R1                                   ; set HI if R9 <0 or R9>R1
        MOVHI   R0,#0
        BHI     %FT10
  [ KernelLocksFreePool
        Push    "r0-r1"
        MOV     R0,#10
        ORR     R0,R0,#&100
        MOV     R1,#1
        SWI     XOS_Memory                              ; set wimp lock
        Pull    "r0-r1"
        MOVVS   R0,#0                                   ; just claim no memory available on error
        MOVVS   R1,#0
        BVS     %FT10
  ]
08
        MOV     R2,#1
        STRB    R2,[R10]                                ; mark free pool in use

10
        CLRV
        STR     R0,[SP,#4]                              ; return values
        STR     R1,[SP]
        Debug wcf, "<- R1,R2", R1, R0
        B       ExitWimp

 [ DynamicAreaWCF
wcfda_maxsize * 4 :SHL: 20 ; Considering the call has been deprecated since RISC OS 3.5, 4MB seems a reasonable limit

50
        ; Wimp_ClaimFreeMemory 'claim' operation, called from above
        MOV     R9,R1                                   ; preserve the amount asked for
        MOV     R0,#5
        MOV     R1,#-1
        SWI     XOS_DynamicArea                         ; get total free memory
55
        MOVVS   R0,#0
        MOVVS   R1,#0
        BVS     %BT10
        Debug wcf, "total free mem: ", R2
        CMP     R2,#wcfda_maxsize
        MOVHI   R2,#wcfda_maxsize
        CMP     R9,R2
        MOVHI   R0,#0
        MOVHI   R1,R2
        BHI     %BT10
        ; Grow the DA so it's at least R9 size
        LDR     R0,wcfda
        SWI     XOS_ReadDynamicArea
        BVS     %BT55
        Debug wcf, "current DA size: ", R1
        CMP     R1,R9
        BHS     %BT08
        MOV     R2,R0
        LDR     R0,wcfda
        SUB     R1,R9,R1
        Debug wcf, "growing by: ", R1
        SWI     XOS_ChangeDynamicArea
        Debug wcf, "actual grow: ", R1
        DebugIf VS, wcf, "error!"
        BVS     %BT55
        MOV     R0,R2
        MOV     R1,R9
        B       %BT08

initwcfda ROUT
        Entry   "R0-R8"
        MOV     R0,#0
        STR     R0,wcfda
        ; Check if WCF DA is needed
        ; Is free pool a PMP?
        MOV     R0,#2
        MOV     R1,#6
        SWI     XOS_DynamicArea
        EXIT    VS
        TST     R4,#1:SHL:20
        BNE     %FT50
      [ KernelLocksFreePool
        ; Can free pool be locked?
        LDR     R0,=10+&100
        MOV     R1,#1
        SWI     XOS_Memory
        LDRVC   R0,=10+&100
        MOVVC   R1,#0
        SWIVC   XOS_Memory
        BVS     %FT50
      ]
        EXIT
50
        ; DA required
        ADRL    R0,wimpareastring       ; Look up name for Wimp dynamic area.
        ADR     R2,errorbuffer          ; Use safe place for temporary string (copied by OS_DynamicArea).
        MOV     R3,#256
        BL      LookupToken1
        MOVVC   R8,R2
        ADRVSL  R8,wimpareastring       ; If look up fails then create something anyway.

        MOV     R0,#0
        MOV     R1,#-1
        MOV     R2,#0
        MOV     R3,#-1
        LDR     R4,=2 + (1:SHL:9)       ; SVC only, shrinkable (note that we don't shrink automatically, so just let the OS deal with it), user-draggable (should be fine, shouldn't be locked at any time when a drag is possible)
        MOV     R5,#wcfda_maxsize
        ADR     R6,wcfda_handler
        ADRL    R7,freepoolinuse
        SWI     XOS_DynamicArea
        STRVC   R1,wcfda
        EXIT

destroywcfda ROUT
        Entry  "R0-R1"
        LDR    R1,wcfda
        MOV    R0,#0
        CMP    R1,#0
        STR    R0,wcfda
        MOV    R0,#1
        SWI    XOS_DynamicArea
        EXIT

wcfda_handler ROUT
        CMP    R0,#4
        BNE    %FT90
        ; TestShrink entry
        ; Allow shrinking if not locked
        LDRB   R3,[R12]
        CMP    R3,#0
        MOVEQ  R3,R4
        MOVNE  R3,#0
        MOV    PC,LR
90
        MOV    R0,#0
        SETV   GT
        MOV    PC,LR

wimpareastring
        DCB     "WCF",0
        ALIGN

 ]

;
wimp_area_handler
        CLRV
        TST     R0,#1
        MOVNE   PC,lr                   ; not insterested in postshrink/grow
        SETV
; must be a pre shrink/grow, allow this if it was caused by the claim above
        Push    R0
        LDRB    R0,memoryOK
        TEQ     R0,#0
        Pull    R0
        CLRV    NE
        MOVVC   PC,lr
        CMP     R0,#2
        MOVEQ   R3,#0
        MOV     R0,#0
        SETV
        MOV     PC,lr

;
; Transfer memory from one application to another
; Entry:  R0 = task handle of source
;         R1 --> source buffer
;         R2 = task handle of destination
;         R3 --> destination buffer
;         R4 = buffer length
;         buffer addresses and length are byte-aligned (not nec. word-aligned)
;         the buffer addresses are validated to ensure they are in range
; Errors: "Invalid task handle"
;         "Wimp transfer out of range"
;
; note that we use tempworkspace here

SWIWimp_TransferBlock  ROUT
        MyEntry "TransferBlock"
;
  Debug mjs4,"&&&Wimp_TransferBlock",R0,R1,R2,R3,R4
        Push    "R0-R4"
        MOV     R0,#MemoryLimit         ; force this field to be up-to-date
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        LDR     R14,taskhandle
  Debug mjs4,"&&& taskhandle,MemoryLimit",R14,R1
        TEQ     R14,#0
        LDRNE   R14,[wsptr,R14]
        CMPNE   R14,#0
        STRGT   R1,[R14,#task_environment+12*MemoryLimit]
        LDMIA   SP,{R0-R4}                      ; leave them on the stack
;
  Debug mjs4,"&&& validtask_alive",R2
        BL      validtask_alive
        MOVVC   R7,R6                   ; R7 --> dest task block
        MOVVC   R2,R0
        Push    "R5"
  Debug mjs4,"&&& validtask_alive",R2
        BLVC    validtask_alive         ; R6 --> source task block
        BVC     %FT05
medusa_exit_trb
        ADD     SP,SP,#4                ; the push above was non-conditional
medusa_exit_trb2
        ADD     SP,SP,#20
        SETV                            ; want an error
        B       ExitWimp
;
05
        SUBS    R10,R4,#0               ; length must != 0
        BNE     %FT07                   ; ignore zero length now!
        ADD     SP,SP,#24
        ; no error so don't set V
        B       ExitWimp

07
        BLT     err_badtransfer
        CMP     R1,#ApplicationStart    ; buffer start >= &8000
        CMPHS   R3,#ApplicationStart
        BLO     err_badtransfer
        SUB     R8,R1,#ApplicationStart ; assuming app space...
        SUB     R9,R3,#ApplicationStart ; ... R8,R9 = offsets into domain
  Debug mjs4,"&&& offsets R8,R9",R8,R9
;
        LDR     R11,orig_applicationspacesize
;
        CMP     R1,R11                  ; not in application space?
        ADDHS   R8,R8,#ApplicationStart ; make absolute again
        BHS     %FT11
        LDR     R14,[R6,#task_environment+12*MemoryLimit]
  Debug mjs4,"&&& source memlimit",R14
        ADD     R0,R1,R4
        CMP     R0,R14
        BHI     err_badtransfer
11
        CMP     R3,R11                  ; not in application space?
        ADDHS   R9,R9,#ApplicationStart ; make absolute again
        BHS     %FT01
        LDR     R14,[R7,#task_environment+12*MemoryLimit]
  Debug mjs4,"&&& dest memlimit",R14
        ADD     R2,R3,R4
        CMP     R2,R14
        BHI     err_badtransfer
01
;
; map all slots into memory space, copy the data, then unmap them
; NOTE: make sure the slots are mapped out before exitting!!!
;
        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment   ; R1 --> end of current slot
;

; orignal calling values are still on the stack
        TEQ     R6,R7                   ; are the tasks the same?
        BEQ     %FT02
        CMP     R10,#7*1024*1024
        BLT     %FT02
; ok we're doing a BIG transfer, so split it up
        MOV     R10,#7*1024*1024        ; 7 meg, leave a bit of breathing space
        Push    "R1"                    ; save end-of-current-slot
        ADD     R0,SP,#8
        LDMIA   R0,{R0-R4}              ; original parameters for Wimp_TransferBlock
        ADD     R1,R1,#7*1024*1024      ; we'll carry on but only do 7 megs worth
        ADD     R3,R3,#7*1024*1024      ; then recall the routine, but starting 7 meg
        SUB     R4,R4,#7*1024*1024      ; further on.
        SWI     XWimp_TransferBlock
        Pull    "R1"                    ; restore end-of-current-slot
; this will cycle through as many times as required
02
; now if the ammount to copy+ R1 > app space, or 2* copy if neither task is the current task
; then part or all of current task must be paged out.
  Debug mjs4,"&&& alleged end of current slot (R1)",R1
        MOV     R0,R1
        LDR     R1,taskhandle
        LDR     R2,pagesize
        LDR     R4,[SP]                 ; task handle
        TEQ     R1,R4
        BEQ     onetask_currentr4       ; one of the tasks is the current task
        TEQ     R1,R5
        BEQ     onetask_currentr5
        CMP     R8,R11
        ADDLO   R0,R0,R10
        ADDLO   R0,R0,R2                ; just in case copy is over a page
        CMP     R9,R11
        ADDLO   R0,R0,R10
        ADDLO   R0,R0,R2
        LDR     R14,orig_applicationspacesize
        CMP     R0,R14
        BLO     %FT03

; since the copy must take place in application space (on ARM 3 its the only place! and on
; ARM 600 a level 2 page table would be required- 24K) we have to make some room by paging
; out part of the current task. For simplicity, we page the whole of the task out on the
; assumption that it is only rare circumstances that will bring us here. It's also
; potentially dangerous paging out bits of the current task, eg. if an exception occurs
; the Environment may point to somewhere that we've paged a different bit of memory to.
; Another complication with selective paging of the current task is that the bit we choose
; to page out may be required in the copy, obviously we need to do more work to make sure
; we don't fall over in these situations.
makespacefromct
  Debug mjs4,"&&& makespacefromct"
        Push    "R1"                    ; save task handle
        BL      mapslotout              ; map out CT
        MOV     R0,#0
        STR     R0,taskhandle
        ADD     R0,SP,#8                ; skipping just-pushed R1 and pushed R5 for Medusa...
        LDMIA   R0,{R0-R4}              ; ...restore R0-R4 from stack for recursive call
        SWI     XWimp_TransferBlock     ; do it again, only this time there is no current task
        Pull    "R1"
        STR     R1,taskhandle           ; return to how it all was
        BL      mapslotin
        ADD     SP,SP,#24
        B       ExitWimp

; this is potentially dodgy as the bit we want to map out of the way may actually be in
; the transfer range

onetask_currentr5
  Debug mjs4,"&&& onetask_currentr5 R4,R5,R8,R11",R4,R5,R8,R11
        TEQ     R5,R4
        BEQ     %FT03
        CMP     R8,R11                  ; we only need to woryy about space if the copy
                                        ; is actually in the tasks app space
        BLO     onetaskcurrent
        B       %FT03

onetask_currentr4
  Debug mjs4,"&&& onetask_currentr4 R4,R5,R9,R11",R4,R5,R9,R11
        TEQ     R5,R4
        BEQ     %FT03
        CMP     R9,R11

onetaskcurrent
        ADDLO   R0,R0,R10
        ADDLO   R0,R0,R2                ; just in case copy is over a page
  Debug mjs4,"&&& onetask_current R0,R2,R10",R0,R2,R10
        LDR     R14,orig_applicationspacesize
        CMP     R0,R14

        BLO     %FT03
        B       makespacefromct


03
        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment   ; R1 --> end of current slot
  Debug mjs4,"&&& end of current slot",R1
        Pull    "R4"
        ADD     SP,SP,#20               ; will always be original values on stack
        MOV     R2,#0
        STR     R2,tempworkspace+4      ; indicate mapenoughslot
        STR     R2,tempworkspace+12     ;  not used yet
        MOV     R2,R1
        LDR     R3,taskhandle
        CMP     R8,R11                  ; do we need it paged in ?
        BHS     %FT04
        TEQ     R3,R5
        ADDEQ   R8,R8,#ApplicationStart
        BEQ     %FT04
        LDR     R0,[R6,#task_slotptr]
        MOV     R1,R8
        MOV     R8,R2
        STR     R1,tempworkspace        ; save domain offset for later mapping-out use of mapenoughslot
        STR     R10,tempworkspace+4     ; save length for later mapping-out use of mapenoughslot
        BL      mapenoughslot
        ADD     R8,R8,R0
04
        CMP     R9,R11
        BHS     %FT06
        TEQ     R3,R4
        ADDEQ   R9,R9,#ApplicationStart
        BEQ     %FT06
        LDR     R0,[R7,#task_slotptr]
        MOV     R1,R9
        MOV     R9,R2
        STR     R1,tempworkspace+8      ; save domain offset for later mapping out use of mapenoughslot
        STR     R10,tempworkspace+12    ; save length for later mapping out ue of mapenoughslot
        BL      mapenoughslot           ; page in only whats required for the copy
        ADD     R9,R9,R0
06
;
; copy data in the correct order, in case source task = destination
;
        TST     R8,#3
        TSTEQ   R9,#3
        TSTEQ   R10,#3
        BEQ     wordcopy                ; word aligned, yipee!!!

        CMP     R8,R9
        BHS     %FT02
        ADD     R8,R8,R10
        ADD     R9,R9,R10
01
        LDRB    R14,[R8,#-1]!           ; descending copy if source < dest
        STRB    R14,[R9,#-1]!
        SUBS    R10,R10,#1
        BNE     %BT01
        B       %FT03
02
        LDRB    R14,[R8],#1             ; ascending copy if source >= dest
        STRB    R14,[R9],#1
        SUBS    R10,R10,#1
        BNE     %BT02
03
        LDR     R2,taskhandle           ; page out the bits we paged in, unless CT
        TEQ     R2,R5
        BEQ     %FT05
        LDR     R0,[R6,#task_slotptr]
        CMP     R0,#-1
        LDRNE   R10,tempworkspace+4     ; saved length (0 if no mapping done)
        TEQNE   R10,#0
        LDRNE   R1,tempworkspace        ; saved domain offset
        MOVNE   R2,#-1                  ; map out
   Debug mjs4,"putative page out R0,R1,R2,R10",R0,R1,R2,R10
        BLNE    mapenoughslot
05
        LDR     R2,taskhandle           ; page out the bits we paged in, unless CT
        TEQ     R2,R4
        BEQ     %FT10
        LDR     R0,[R7,#task_slotptr]
        CMP     R0,#-1
        LDRNE   R10,tempworkspace+12    ; saved length (0 if no mapping done)
        TEQNE   R10,#0
        LDRNE   R1,tempworkspace+8      ; saved domain offset
        MOVNE   R2,#-1                  ; map out
   Debug mjs4,"putative page out R0,R1,R2,R10",R0,R1,R2,R10
        BLNE    mapenoughslot
10
        B       ExitWimp

wordcopy
        CMP     R8,R9
        BHS     %FT02
        ADD     R8,R8,R10
        ADD     R9,R9,R10
01
        LDR     R14,[R8,#-4]!           ; descending copy if source < dest
        STR     R14,[R9,#-4]!
        SUBS    R10,R10,#4
        BNE     %BT01
        B       %BT03
02
        LDR     R14,[R8],#4             ; ascending copy if source >= dest
        STR     R14,[R9],#4
        SUBS    R10,R10,#4
        BNE     %BT02
        B       %BT03

; maps only the pages that are required for the copy to address R2, slot R0, length R10
; domain offset R1, note that R2 = -1 means map out
;
; exit: R0 is offset from page boundary, R2 (if not -1) updated to next mappable address

mapenoughslot
        Push    "R0-R1,R3-R5,LR"

   Debug mjs4,">mapenoughslot",R0,R1,R2,R10

        LDR     R4,pagesize
        SUB     R4,R4,#1

        AND     R5,R1,R4         ;offset from page
        STR     R5,[SP]          ;R0 on return
        ADD     R5,R5,R10
        ADD     R5,R5,R4
        BIC     R5,R5,R4         ;no. of pages required x pagesize
        MOV     R5,R5,LSR #12    ;no. of (4k) pages

        BIC     R1,R1,R4         ;start of map (page boundary)

        MOV     R3,R1,LSR #12    ;offset in (4k) pages to start of map
        MOV     R1,R2            ;start address
        MOV     R2,R0            ;handle
        MOV     R0,#3
        ORR     R0,R0,#&100      ;reason code 3, plus bit 8 set (mapsome)
        MOV     R4,R5            ;no. of pages to map
        SWI     XOS_AMBControl
        BVS     err_badtransfer2

        CMP     R1,#-1
        MOVEQ   R2,R1
        ADDNE   R2,R1,R4,LSL #12 ;R2 return
   Debug mjs4," <mapenoughslot",R2

        Pull    "R0-R1,R3-R5,PC"

err_badtransfer2
        MyXError        WimpBadSlot
        B               medusa_exit_trb2         ; task handle no longer on stack
        MakeErrorBlock  WimpBadSlot

err_badtransfer
        MyXError  WimpBadTransfer
        B         medusa_exit_trb
        MakeErrorBlock WimpBadTransfer


;
; free pool set up on entry (unless application memory is already in use)
;   order of pages in the free pool is unimportant
;
; Read in table of all OS pages
; work out which ones are in application space
; put them into free pool list
;
; Data structures:
; slot table:  list of 3-word entries (as passed to OS_ReadMemMapEntries)
; free pool:   list of 3-word entries (enough room for all pages in machine)
;              pages are used as in a LIFO stack, with lower addresses last
;
; Exit:  if application space used, [freepool] = -1
;                              else [freepool] --> free pool block
;

findpages       ROUT
        Push    "R1-R11,LR"
;
        MOV     R14,#nullptr
        STR     R14,freepool            ; lock application memory
        LDR     R14,taskhandle
        STR     R14,inithandle          ; this task slot "owns" the memory
;
        SWI     XOS_ReadMemMapInfo      ; R0 = page size, R1 = no of pages
        Pull    "R1-R11,PC",VS
        STR     R0,pagesize
        STR     R1,npages               ; used later
;
; under the Medusa kernel, try and shrink app space by as much as possible

        MOV     R0,#6                   ; free pool
        MOV     R1,#&3FFFFFFF           ; try and shrink app space
        SWI     XOS_ChangeDynamicArea
; this sets up memory limit/ app space size as well
        MOV     R0,#-1
        SWI     XOS_ReadDynamicArea
        ADDVC   R5,R0,R2
        STRVC   R5,orig_applicationspacesize
        STRVC   R5,appspacesize

        CLRV

        Pull    "R1-R11,PC"
;01
;
;;
;; if application space in use, we can't construct a free pool
;; but we must still read orig_memorylimit and orig_applicationspacesize
;;
;
;        MOV     R0,#ApplicationSpaceSize
;        MOV     R1,#0
;        SWI     XOS_ChangeEnvironment
;        MOVVC   R3,R1                           ; R3 --> real end of memory
;        STRVC   R3,orig_applicationspacesize
;;
;        MOVVC   R0,#MemoryLimit
;        MOVVC   R1,#0
;        SWIVC   XOS_ChangeEnvironment
;        STRVC   R1,orig_memorylimit
;;
;;
;        TEQ     R1,R3                   ; preserves V
;        Pull    "R1-R11,PC",NE          ; these must be equal on entry
;;
;        BLVC    testapplication         ; CC ==> space is in use
;        Pull    "R1-R11,PC",VS
;        Pull    "R1-R11,PC",CC          ; we'll get back to this later if used
;
;;
;; allocate a "free pool" block, with 12 bytes per page
;;
;        LDR     R3,npages
;        MOV     R3,R3,LSL #2            ; multiply by 12
;        ADD     R3,R3,R3,LSL #1
;        ADD     R3,R3,#4                ; leave room for terminator
;        BL      claimblock
;        STRVC   R2,freepool
;;
;; construct free pool array by calling OS_FindMemMapEntries
;;
;        MOVVC   R1,#ApplicationStart
;        STRVC   R1,freepoolbase         ; base address of free pages
;
;        LDRVC   R1,orig_applicationspacesize
;        BLVC    findfreepool
;        MOVVC   R1,#2                   ; protect against USR mode access
;        BLVC    setslotaccess
;;
;; I don't know what this is doing here!
;;
;        MOVVC   R14,#0
;        STRVCB  R14,memoryOK            ; it's had it by now anyway!
;;
;; now protect all these pages, keeping them just below orig_memlimit
;; and set MemoryLimit small
;;
;        MOVVC   R1,#ApplicationStart
;        BLVC    setmemsize              ; sets ACTUAL handlers (current task)
;;
;        LDRVC   R0,freepool
;        SWIVC   XOS_SetMemMapEntries
;
;        Pull    "R1-R11,PC"


; In    R1 = application space size (one after end of free pool)
;       R2 -> free pool page table
;       [freepoolbase] = start of free pool
; Out   free pool table filled in (lowest address last in list)
;       [freepoolbase] updated if less than application space size
;       [freepoolpages] set up


findfreepool    ROUT
        Push    "R1-R5,LR"


        LDR     R3,freepoolbase
        CMP     R3,R1
        MOVHI   R3,R1
        STRHI   R3,freepoolbase

        MOV     R4,#0                   ; R4 = no of pages so far
        MOV     R0,#0                   ; R0 = probable page no (don't know)
        LDR     R5,pagesize
01      SUB     R1,R1,R5                ; R1 = address of next page
        CMP     R1,R3
        STMHSIA R2!,{R0,R1,R14}         ; page no, address, access (undefined)
        ADDHS   R4,R4,#1
        BHS     %BT01
        STR     R4,freepoolpages
        MOV     R14,#-1
        STR     R14,[R2]                ; terminator

        LDR     R0,[sp,#1*4]
        SWI     XOS_FindMemMapEntries   ; find relevent pages

        Pull    "R1-R5,PC"

; In    R1 = page protection level required
;       R2 -> slot block
; Out   page protection level set, array updated
;       R0 corrupted

setslotaccess   ROUT
        Push    "R2,LR"

01      LDR     R14,[R2],#12            ; unless terminator,
        CMP     R14,#0
        STRGE   R1,[R2,#-4]             ; fill in access field
        BGE     %BT01

        LDR     R0,[sp]
        SWI     XOS_SetMemMapEntries

        Pull    "R2,PC"

;
; testapplication
; works out whether application space is in use
; Entry: [orig_memorylimit] = upper bound of memory used by application
;                             if &8000, then application space is not in use
; Exit:  CC ==> memory in use
;
; Method:
;    1. If CAO pointer < MemoryLimit, then application memory is in use.
;    2. If MemoryLimit < ApplicationSpaceSize, then memory (probably) in use.
;       (catches situations where CAO isn't set, e.g. when *WimpTask creates a
;        temp task and so CAO == our module)
;    3. Issue Service_Memory: R0 = large - if anyone objects, memory is in use
;

ApplicationStart  *  &8000
IsAnybodyThere    *  -64*&100000        ; large negative number
                                        ; NB: this number is checked for by ShellCLI
testapplication ROUT
        Push    "R1-R4,LR"
;
        LDR     R1,orig_applicationspacesize    ; watch out for Twin etc!
        BL      readCAOpointer                  ; use OS_ChangeEnvironment
        CMP     R2,R1                           ; below memorylimit?
        Pull    "R1-R4,PC",CC
;
        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        MOV     R4,R1
        MOV     R0,#MemoryLimit
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        CMP     R1,R4
        Pull    "R1-R4,PC",CC           ; MemoryLimit < ApplicationSpaceSize
;
  Debug mjs3,"testapplication routine issueing Service_Memory"
        MOV     R1,#Service_Memory
      [ false
        MOV     R0,#IsAnybodyThere      ; 64 megabytes should be enough!
      |
        ; Oh no it isn't!
        TEQ     PC,PC                   ; don't want yet another build option if we can avoid it
        MOVNE   R0,#IsAnybodyThere      ; on 26-bit machines, use 64 megs for compatibility
        MOVEQ   R0,#1:SHL:31            ; on 32-bit machines, use most negative possible number
      ]
        SWI     XOS_ServiceCall
        CMPVC   R1,#1                   ; CC ==> service was claimed
;
        Pull    "R1-R4,PC"


; Out   R2 = CAO pointer (read using OS_ChangeEnvironment)

readCAOpointer  ROUT
        Push    "R0-R3,LR"

        MOV     R0,#CAOPointer
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        STR     R1,[sp,#2*4]

        Pull    "R0-R3,PC"              ; assume no errors

;
; restorepages
; put back the free pool when the last task dies - do not disturb current stuff
; Entry:  all tasks dead
;         use OS_ChangeEnvironment to set/read end of application memory
;         free pool block indicates remaining spare pages
; Exit:   all pages replaced in application space
;         memorylimit increased if appropriate
;         free pool block released
;

restorepages    ROUT
        Push    "R1-R7,LR"
;
        BL      deletependingtask       ; not interested in this task

        MOV     R4,#&C0000000           ; shrink freepool as much as we can
        BL      SafeChangeDynamic
        Pull    "R1-R7,PC"
;                                       ; just add to the pages present
        LDR     R6,freepool
        CMP     R6,#nullptr2
        BHS     go_restorememlimit      ; NB: orig_ values MUST BE CORRECT!
;
        MOV     R0,#MemoryLimit
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment   ; R1 = current memory limit
;
; free pool is already in the right place - just set access bits to 0
;
        LDR     R2,freepool
        MOV     R1,#0                   ; 0 => USR mode read/write access
        BL      setslotaccess           ; R2 -> free pool still

        MOV     R14,#nullptr2           ; application space NOT in use by Wimp
        STR     R14,freepool            ; NB only applies if not used on entry
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module              ; ignore errors from here

go_restorememlimit
        BL      restorememlimit
;
        Pull    "R1-R7,PC"

restorememlimit ROUT
        EntryS
        MOV     R0,#MemoryLimit
        LDR     R1,orig_memorylimit
        SWI     XOS_ChangeEnvironment
        MOV     R0,#ApplicationSpaceSize
        LDR     R1,orig_applicationspacesize
        SWI     XOS_ChangeEnvironment
        EXITS                           ; must preserve flags

;
; allocateslot
; take pages from the free pool, and construct a page array block
; Entry:  [taskhandle] = current task
;         [slotsize] = max no of pages to use in new slot
; Exit:   taskhandle->task_slotptr --> block (suitable for OS_SetMemMapEntries)
;         pages transferred from the free pool to the slot
;         [freepoolbase] updated
;         slot size = 0 if no free pool (ie. all used up)
;         MemoryLimit updated to reflect the amount of memory available
;
allocateslot    ROUT
       Push    "R0-R4,LR"
       LDR     R1,slotsize ;no. of pages
    Debug mjs2,"allocateslot",R1
       MOV     R0,#0       ;reason code 0 (allocate)
       SWI     XOS_AMBControl
       BVC     %FT01
       BL      setdefaulthandlers
       Pull    "R0-R4,PC"
01
       CMP     R2,#0
       MOVEQ   R2,#nullptr
    Debug mjs2,"  allocateslot pages,slotptr",R1,R2
       LDR     R1,taskhandle
       LDR     R1,[wsptr,R1]
       STR     R2,[R1,#task_slotptr]
       Pull    "R0-R4,PC"


;
; Entry:  R2 --> slot block
;         R5 = number of pages required
; Exit:   R1 = amount of memory transferred
;         slot block, [freepoolbase], free pool sp updated
;         pages are not actually mapped in yet, and addresses are un-initialised
;

mapfromfreepool ROUT
        Push    "R2-R7,LR"
;
        LDR     R7,freepoolpages        ; R7 = number of pages in free pool
        SUB     R14,R7,R5
        STR     R14,freepoolpages       ; update [freepoolpages]

        ADD     R7,R7,R7,LSL #1
        LDR     R14,freepool
        ADD     R7,R14,R7,LSL #2        ; R7 -> terminator of free pool

        MOV     R4,#0                   ; R4 = page protection level (always 0)
01      SUBS    R5,R5,#1
        LDRPL   R0,[R7,#-12]!           ; R0 = page no
        STMPLIA R2!,{R0,R3,R4}          ; page no, address (uninit), access
        BPL     %BT01

        MOV     R14,#-1
        STR     R14,[R2]                ; slot block terminator
        STR     R14,[R7]                ; free pool terminator
;
; update [freepoolbase] and R1
;
        LDR     R0,pagesize             ; R0 = page size
        LDR     R5,[sp,#3*4]
        MUL     R1,R0,R5                ; R1 = amount of memory transferred
        LDR     R14,freepoolbase
        ADD     R14,R14,R1              ; update [freepoolbase]
        STR     R14,freepoolbase
;
        Pull    "R2-R7,PC"

;
; setmemsize
; sets up MemoryLimit and ApplicationSpaceSize for (polltaskhandle) task
; NB: these values apply to the CALLING task (so OS_ChangeEnvironment is used)
; Entry:  R1 = new memorylimit / applicationspacesize
; Exit:   OS_ChangeEnvironment used to change OS versions of these variables
;         if task is alive, its copies are also updated
;         R1 = old memorylimit
;

setmemsize      ROUT
        Push    "LR"
        MOV     R0,#ApplicationSpaceSize
        Push    "R1"
        SWI     XOS_ChangeEnvironment
        MOVVC   R0,#MemoryLimit
        Pull    "R1"
        SWIVC   XOS_ChangeEnvironment
        Pull    "PC"

;
; deallocateslot
; returns pages from a used slot to the free pool
; Entry:  [taskhandle] = current task
; Exit:   slot block deallocated (if any)
;         taskhandle->task_slotptr = null
;         pages put back into free pool (NB block never needs extension)
;
deallocateslot  ROUT
        Push    "R1-R2,LR"

   Debug mjs2,"deallocateslot"
        LDR     R14,taskhandle
        LDR     R1,[wsptr,R14]          ; R1 --> task block
        LDR     R2,[R1,#task_slotptr]

        CMP     R2,#nullptr
        MOVNE   R14,#nullptr
        STRNE   R14,[R1,#task_slotptr]
        BEQ     %FT03

        MOV     R0,#1       ;deallocpages reason code
        SWI     XOS_AMBControl
03
        CLRV
        Pull    "R1-R2,PC"

;
; Entry:  R2 --> slot block
; Exit:   pages mapped into free pool etc. (maptofreepool called)
;         slot block deallocated
;
deallocate      ROUT
        Push    "R0,LR"
        CMP     R2,#nullptr
        Pull    "R0,PC",EQ              ;return if invalid slot pointer

   Debug mjs2,"deallocate"

        MOV     R0,#1      ;deallocate reason code (not from App space)
        SWI     XOS_AMBControl
        STRVS   R0,[SP]
        Pull    "R0,PC"

;;
;; Entry:  R2 --> slot block
;; Exit:   pages mapped to base of free pool
;;         page numbers put into free pool (lowest page last)
;;         [freepoolbase] updated
;;
;
;maptofreepool   ROUT
;        Push    "R1-R7,LR"
;;
;        CMP     R2,#nullptr
;        Pull    "R1-R7,PC",EQ           ; no block!
;;
;
;        LDR     R6,freepool
;        LDR     R7,freepoolpages        ; R7 = number of pages in free pool
;        ADD     R6,R6,R7,LSL #2
;        ADD     R6,R6,R7,LSL #3         ; R6 -> terminators of free pool
;        MOV     R0,R6                   ; R0 -> block for OS_SetMemMapEntries
;
;        LDR     R1,pagesize
;        LDR     R4,freepoolbase         ; R4 -> next address
;        MOV     R5,#2                   ; R5 = protection level
;01      LDR     R3,[R2],#12             ; R3 = page number
;        CMP     R3,#nullptr
;        SUBNE   R4,R4,R1
;        STMNEIA R6!,{R3,R4,R5}          ; page number, address, protection level
;        ADDNE   R7,R7,#1
;        BNE     %BT01
;
;
;        STR     R4,freepoolbase
;        STR     R7,freepoolpages
;        MOV     R14,#-1
;        STR     R14,[R6]                ; terminator
;
;
;        SWI     XOS_SetMemMapEntries
;
;        Pull    "R1-R7,PC"              ; don't alter memorylimit

;
; mapslotin
; all pages in a slot are put into the application space (&8000)
; Entry:  [taskhandle] = current task
; Exit:   pages mapped in
;         handlers (eg. MemoryLimit) are also set up from task data
;

mapslotin       ROUT
        Push    "R1-R4,LR"
;
        LDR     R14,taskhandle
        LDR     R1,[wsptr,R14]          ; R1 --> task block
        CMP     R1,#0
        Pull    "R1-R4,PC",LE           ; task is dead (shouldn't happen)
;
        LDR     R0,[R1,#task_slotptr]
        CMP     R0,#nullptr             ; no slot allocated
        BLNE    mapin                   ; (corrupts R2)
;

        LDR     R14,taskhandle
        LDR     R4,[wsptr,R14]          ; NB task cannot be dead
        ADD     R4,R4,#task_environment
;
        LDR     R14,[R4,#12*ApplicationSpaceSize]
        SUB     R14,R14,#ApplicationStart
        STR     R14,appspacesize
;
        MOV     R0,#0                   ; handler number
01
        LDMIA   R4!,{R1-R3}             ; restore task handler data
        SWI     XOS_ChangeEnvironment
        ADD     R0,R0,#1
        CMP     R0,#MaxEnvNumber
        BCC     %BT01
;
        Pull    "R1-R4,PC"

;
; Entry:  R0 --> block suitable for passing to OS_SetMemMapEntries
; Exit:   the pages in the block are mapped into the application area
;
mapin   ROUT
        Push    "R0-R2,LR"
        MOV     R2,R0                ;handle
        MOV     R0,#3                ;reason code 3 (mapslot)
        MOV     R1,#ApplicationStart
        SWI     XOS_AMBControl
        STRVS   R0,[SP]
        Pull    "R0-R2,PC"

; Entry:  R0 --> page map block
;         R2 --> start address of place to map pages to
; Exit:   R2 --> after the memory

mapslot         ROUT
        Push    "R1,R3,LR"
;
        LDR     R3,pagesize
        MOV     R1,R0
01
        LDR     R14,[R1],#4
        CMP     R14,#0
        STRGE   R2,[R1],#8              ; next page
        ADDGE   R2,R2,R3
        BGE     %BT01
;
        SWI     XOS_SetMemMapEntries
;
        Pull    "R1,R3,PC"

;
; mapslotout
; all pages in a slot are put out of the way
; Entry:  [taskhandle] = current task
; Exit:   pages mapped out
;

mapslotout      ROUT
        Push    "R1-R6,LR"
;
        LDR     R14,taskhandle
        LDR     R6,[wsptr,R14]          ; R6 --> task block
        CMP     R6,#0
        Pull    "R1-R6,PC",LE           ; task is dead already
;
;
        ADD     R5,R6,#task_environment
        MOV     R0,#0
01
        TEQ     R0,#EscapeHandler       ; we must replace these now,
        TEQNE   R0,#EventHandler        ; since they are dangerous!
        TEQNE   R0,#UpCallHandler
        MOVNE   R1,#0
        MOVNE   R2,#0
        MOVNE   R3,#0
        SWIEQ   XOS_ReadDefaultHandler  ; replace with 'kosher' handlers
        SWI     XOS_ChangeEnvironment   ; set, and read original settings
        STMIA   R5!,{R1-R3}             ; old data
        ADD     R0,R0,#1
        CMP     R0,#MaxEnvNumber
        BCC     %BT01
;
        LDR     R0,[R6,#task_slotptr]
        CMP     R0,#nullptr             ; R0 --> slot block
        BLNE    mapout                  ; NB do this afterwards!
;
        Pull    "R1-R6,PC"

;
; Entry:  R0 --> block suitable for passing to OS_SetMemMapEntries
; Exit:   all pages referenced in the block are mapped out of the way
;
mapout  ROUT
        Push    "R0-R2,LR"
        MOV     R2,R0                ;handle
        MOV     R0,#3                ;reason code 3 (mapslot)
        MOV     R1,#-1               ;map out
        SWI     XOS_AMBControl
        STRVS   R0,[SP]
        Pull    "R0-R2,PC"


;;----------------------------------------------------------------------------
;; *WimpSlot command (for changing amount of application space)
;;----------------------------------------------------------------------------

                ^       0
vec_min         #       4               ; fields in output vector
vec_max         #       4
vec_next        #       4

ss_outputvec    *       &100


Keydef  DCB     "min,max,next", 0       ; -min no longer compulsory
        ALIGN

WimpSlot_Code   ROUT
        Push    "R11,R12,LR"
        LDR     wsptr,[R12]
        MOV     R11,sp                  ; remember stack for later
;
        SUB     sp,sp,#ss_outputvec     ; local workspace
;
; scan the comand line by calling OS_ReadArgs
;
        MOV     R1,R0                   ; R1 = input string
        ADR     R0,Keydef               ; R0 = key definition string
        MOV     R2,sp                   ; R2 = output vector
        MOV     R3,#ss_outputvec        ; R3 = max output vector length
        SWI     XOS_ReadArgs
        BVS     %FT99
;
; scan the resulting vector for known fields
;
        MOV     R0,#MemoryLimit
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        SUB     R3,R1,#ApplicationStart ; R3 = current amount of memory
;
        LDR     R1,[sp,#vec_min]
        CMP     R1,#0
        BEQ     %FT01
        BL      getminmax               ; R0 = min memory
        BVS     %FT99
        CMP     R0,R3
        BLS     %FT01
;
        Push    "R0"                    ; R0 = new current slot size
        MOV     R1,#-1                  ; leave next slot alone
        SWI     XWimp_SlotSize
        Pull    "R1"
        BVS     %FT99
        CMP     R0,R1                   ; R0=actual size, R1=required size
        BLO     err_notenoughmemory
        MOV     R3,R0                   ; R3 = new amount of memory
01
        LDR     R1,[sp,#vec_max]
        CMP     R1,#0
        BEQ     %FT02
        BL      getminmax               ; R0 = max memory
        BVS     %FT99
        CMP     R0,R3
        MOVLO   R1,#-1                  ; leave next slot alone
        SWILO   XWimp_SlotSize
02
        LDR     R1,[sp,#vec_next]
        CMP     R1,#0
        BEQ     %FT99
        BL      getminmax               ; R0 = new next slot size
        MOVVC   R1,R0
        MOVVC   R0,#-1                  ; leave current slot alone
        SWIVC   XWimp_SlotSize
99
        MOV     sp,R11
        Pull    "R11,R12,PC"

err_notenoughmemory
        MOV     R0,R1,ASR #10           ; R0 = size in K
;
        SUB     SP,SP,#32               ; allocate buffer big enough
;
        MOV     R1,SP
        MOV     R2,#20
        SWI     XOS_BinaryToDecimal     ; convert to a string
        ADDVS   SP,SP,#32
        BVS     %BT99                   ; (exit if it errored)
;
        MOV     R0,#0
        STRB    R0,[R1,R2]              ; terminate the string
;
        Push    "R4,R5"
;
        MOV     R4,R1                   ; -> string to use
        MOV     R5,#0

        MOV     R3,#errordynamicsize-4
        ADRL    R2,errordynamic+4       ; -> buffer to fill in
        ADR     R0,errmem
        BL      LookupToken
;
        Pull    "R4,R5"
        ADD     SP,SP,#32               ; balance the stack
;
        ADRL    R0,errordynamic
        LDR     R1,=ErrorNumber_ChDynamNotAllMoved
        STR     R1,[R0]
;
        SETV
        B       %BT99                   ; exit having setup the error block

  [ STB
errmem  DCB     "ErrMemS",0             ; simple message
  |
errmem  DCB     "ErrMem",0              ; original one
  ]
        ALIGN

;
; Entry:  R1 --> string
; Exit:   R0 = parameter value (number)
; Errors: "Bad number"
;

getminmax       ROUT
        Push    "R1-R3,LR"
;
        MOV     R0,#10
        SWI     XOS_ReadUnsigned
        Pull    "R1-R3,PC",VS
;
        LDRB    R3,[R1]
        ASCII_UpperCase R3, R14
        TEQ     R3,#"K"                 ; if terminator is "K" or "k",
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #10           ; multiply by 1024
        TEQ     R3,#"M"                 ; if terminator is "M" or "m",
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #20           ; multiply by 1048576
        TEQ     R3,#"G"                 ; if terminator is "G" or "g",
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #30           ; multiply by 1073741824
;
        LDRB    R14,[R1]                ; check terminator
        RSBS    R14,R14,#" "+1          ; ensure GT set if OK
        MyXError BadNumb,LE
;
        MOVVC   R0,R2                   ; R0 = answer
        Pull    "R1-R3,PC"
        MakeInternatErrorBlock BadNumb,,BadParm

  [ :LNOT: KernelLocksFreePool

;;----------------------------------------------------------------------------
;; Stuff to deal with OS_ChangeDynamicArea
;;----------------------------------------------------------------------------

;
; intercept OS_ChangeDynamicArea
;

initdynamic     ROUT
        Push    "R1-R4,LR"
;
        ADR     R0,RAM_SWIEntry
        LDR     R1,copyofRAMcode+0
        LDR     R2,copyofRAMcode+4
        ADR     R3,My_ChangeDynamic
        LDR     R14,=SvcTable + 4 * OS_ChangeDynamicArea
        LDR     R4,[R14]                        ; R4 = old SWI entry
        TEQ     R4,R0
        Pull    "R1-R4,PC",EQ             ; if already in, forget it!

        STMIA R0,{R1-R4}
        STR   R0,[R14]                        ; R0 = RAM_SWIEntry
;
    ;StrongARM
    ;synchronise with respect to modified code at RAM_SWIEntry
        MOV     R1,R0                           ; start address
        ADD     R2,R1,#4                        ; end address (inclusive) for 2 words (other 2 are addresses)
        MOV     R0,#1                           ; means R1,R2 specify range
        SWI     XOS_SynchroniseCodeAreas        ; do the necessary

        Pull    "R1-R4,PC"

copyofRAMcode
        SUB     R12,PC,#:INDEX:RAM_SWIEntry+8
        LDR     PC,[PC,#-4]
        ASSERT  (.-copyofRAMcode = 8)
        ASSERT  (OScopy_ChangeDynamic-RAM_SWIEntry = 12)

resetdynamic    ROUT

        Push    "R1,LR"
;
        LDR     R1,=SvcTable + 4 * OS_ChangeDynamicArea
        LDR     R14,OScopy_ChangeDynamic
        STR     R14,[R1]
;
        Pull    "R1,PC"
        LTORG


;----------------------------------------------------------------------------
; OS_ChangeDynamicArea
; Entry:  R0 = area to move (0=system heap, 1=RMA, 2=screen)
;         R1 = amount to move (+ve ==> take away from application space)
; Exit:   R1 = amount actually moved
; Errors: not all bytes moved (0 moved if R1 was +ve)
;
;  if freepool < 0 or CAO pointer <> Wimp,
;  then just pass it on
;  else if not enough free pool memory, grab some from current slot
;       map all pages into the application space
;       reset ApplicationSpaceSize/MemoryLimit to their original values
;       branch to the OS code
;-----------------------------------------------------------------------------

        LTORG

My_ChangeDynamic  ROUT
        Push    "R0-R5,LR"
        ADRL    R14,freepoolinuse
        LDRB    R2,[R14]
        TEQ     R2,#0
        BEQ     goto_osentry
; free pool is in use by WCF, must trap with 'memory cannot be moved'
        MOV     R1,#0
        ADD     SP,SP,#8
        MyXError ChDynamNotAllMoved

        Pull    "R2-R5,lr"
        ORR     lr,lr,#V_bit
        LDR     PC,=BranchToSWIExit

goto_osentry
        Pull    "R0-R5,LR"
        LDR     PC,OScopy_ChangeDynamic

  ] ; :LNOT: KernelLocksFreePool

        MakeInternatErrorBlock ChDynamNotAllMoved,,ErrNoMv
        LTORG

        END
@


4.13
log
@Avoid unnecessary remainder calculations
Detail:
  s/Wimp01, s/Wimp02, s/Wimp05, s/Wimp08s, s/Wimp10 - Avoid unnecessary remainder calculations in DivRem macro. Also make more use of DivRem's ability to accept a constant (not a register) as the divisor.
Admin:
  Tested on Cortex-A15


Version 5.52. Tagged as 'Wimp-5_52'
@
text
@d1098 2
@


4.12
log
@Reinstate Wimp_ClaimFreeMemory
Detail:
  This restores support for Wimp_ClaimFreeMemory, via having the Wimp manage a small-ish (4MB) DA that is used to satisfy Wimp_ClaimFreeMemory requests. The Wimp will only ever grow the DA, but the DA is shrinkable, so the system should shrink it as necessary should the free pool run too low.
  Options/s/!Default, Options/s/32, Options/s/Ursula - Add DynamicAreaWCF option to control support for the Wimp_ClaimFreeMemory DA. Enable the option for any builds of the module destined for RISC OS 5.
  Options/s/!Debug - New debug option for Wimp_ClaimFreeMemory debugging (mainly DynamicAreaWCF code path)
  Wimp/s/Wimp01 - Add calls to create/destroy DA on startup/shutdown
  Wimp/s/Wimp08s - DA create/destroy implementation. DA is only used if the free pool is a PMP or the Wimp expects kernel free pool locking but the kernel doesn't support it. Modify Wimp_ClaimFreeMemory to use the DA if it's present.
Admin:
  Tested on Raspberry Pi
  Restores compatibility with software which relies on Wimp_ClaimFreeMemory, e.g. GDraw module (cause of "No free memory" errors reported by many)
  Note that Wimp_ClaimFreeMemory is still considered deprecated and support may be removed in future OS versions.


Version 5.50. Tagged as 'Wimp-5_50'
@
text
@d82 1
a82 1
        DivRem  R3,R2,R0, R14
@


4.11
log
@Disable Wimp_ClaimFreeMemory if the free pool is a PMP
Detail:
  s/Wimp08s - If the free pool is a PMP, it's fairly safe to say there'll be no logical mapping, so don't allow Wimp_ClaimFreeMemory to succeed. Also cope with OS_Memory 10 potentially being unimplemented - swallow any error it generates, and refuse to claim the free pool.
Admin:
  Tested on Pandaboard
  Fixes crashes and subsequent OS_ChangeDynamicArea failures caused by software trying to claim the free pool (e.g. FileCore temp buffers).


Version 5.49. Tagged as 'Wimp-5_49'
@
text
@d263 1
d288 5
d319 1
d327 1
d330 114
@


4.10
log
@Protect memory above MemoryLimit being nuked when starting a task
Detail:
  s/Wimp08s - Improve testapplication to detect situations where data is being stored above MemoryLimit, e.g. if a C app uses system() to issue *WimpTask
  Usually the CAO check will detect this kind of situation, except for the case where a single-tasking app issues *WimpTask - in which case the CAO will get reset to the Wimp module due to ModHandReason_Enter being used to get into USR mode so a temp parent task can be created
  Wimp_SlotSize checks MemoryLimit against ApplicationSpaceSize before allowing the wimpslot to be resized, so it seems to be a bit of an oversight that the task startup code wasn't doing the same
Admin:
  Tested on BB-xM
  Fixes ticket #279:
  https://www.riscosopen.org/tracker/tickets/279


Version 5.39. Tagged as 'Wimp-5_39'
@
text
@d275 1
d280 2
a281 2
        ADRL    R4,freepoolinuse
        LDRB    R0,[R4]
d287 6
a292 3
        MOV     R5,R1                                   ; preserve the amount asked for
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea
d295 3
d299 1
a299 1
        CMP     R5,R1                                   ; set HI if R5 <0 or R5>R1
d301 14
a314 2
        MOVLS   R2,#1
        STRLSB  R2,[R4]                                 ; mark free pool in use
d316 2
a319 6
  [ KernelLocksFreePool
        MOVLS   R0,#10
        ORRLS   R0,R0,#&100
        MOVLS   R1,#1
        SWILS   XOS_Memory                              ; set wimp lock
  ]
@


4.9
log
@The application space size returned from OS_ChangeEnvironment includes the
&8000 below the application slot, and our Message_MemoryMoved handler wasn't
taking account of this, hence the way module tasks randomly acquired 32K
wimpslots in the Task Manager! Also updates appslotsize variable on task
switches, to remove some false positives.

Version 4.79. Not tagged
@
text
@d831 4
a834 1
;    2. Issue Service_Memory: R0 = large - if anyone objects, memory is in use
d841 1
a841 1
        Push    "R1-R3,LR"
d846 11
a856 1
        Pull    "R1-R3,PC",CC
d871 1
a871 1
        Pull    "R1-R3,PC"
@


4.8
log
@  Memory-related stuff.
Detail:
  * Default UpCall handler is installed when an application is paged out,
    so there is no danger of it being called by naughty people issuing
    UpCalls in the background.
  * AMBControl builds now sit on Service_MemoryMoved so that they can issue
    Message_SlotSize when the kernel has resized the application slot
    independently (eg because the memory was needed to grow a dynamic area,
    and nobody objected via Service_Memory or UpCall_MovingMemory).
  * Medusa-onwards builds no longer request Service_ValidateAddress, because
    we're not managing the free pool any more, and the code that was here
    only called an ineffectual SWI!
  * SafeChangeDynamic wasn't setting the CAO high enough to be free of big
    application slots; now it points it at itself.
  * The free pool wasn't being shrunk/grown enough on initfirsttask /
    closelast. It still can't do by more than 1GB without stiffing - bug in
    kernel?
  * Bugs in top-bit-safe changes fixed: dragbox resizing was broken, Escape
    state wasn't being restored for new tasks.
Admin:
  Tested on high-ROM/stack, 48M-appslot Tungsten.

Version 4.77. Tagged as 'Wimp-4_77'
@
text
@d231 1
d1124 4
@


4.7
log
@Put back in a change to Service_Memory that I regressed while tracking down
a bug. Retagged as 'Wimp-4_76'.
@
text
@d83 1
a84 1
        STR     R3,slotsize             ; [slotsize] = no of pages
d146 1
d157 1
a157 1
        MOV     R1,#&08000000
d181 2
d193 1
a193 1
        LDREQ   R6,[sp,#0*4]            ; next slot size (already on stack)
d200 1
d222 19
d694 1
a694 1
        MOV     R1,#&10000000           ; try and shrink app space
d701 1
d888 1
a888 1
        MOV     R4,#-&10000000            ; shrink freepool as much as we can
d1188 1
@


4.6
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@d822 1
a822 1
      [ true
@


4.5
log
@Commented out a lump of dead code to avoid anyone else getting confused by
it in future.

Version 4.75. Tagged as 'Wimp-4_75'
@
text
@d77 3
a79 3
        CMP     R2,#0                   ; if -ve, just read current value
        LDRLT   R3,slotsize
        BLT     %FT01
d105 1
a105 1
        BLE     returnmemsize           ; done if just reading
d130 2
a131 2
        CMP     R2,#0
        BLLE    getnullslot
d769 1
a769 1
        BGE     %BT01
d822 1
d824 6
d869 2
a870 2
        CMP     R6,#0
        BLE     go_restorememlimit      ; NB: orig_ values MUST BE CORRECT!
d1006 4
a1009 4
        CMP     R2,#0
        MOVGT   R14,#nullptr
        STRGT   R14,[R1,#task_slotptr]
        BLE     %FT03
d1024 2
a1025 2
        CMP     R2,#0
        Pull    "R0,PC",LE              ;return if invalid slot pointer
d1034 6
d1041 28
a1068 4
; Entry:  R2 --> slot block
; Exit:   pages mapped to base of free pool
;         page numbers put into free pool (lowest page last)
;         [freepoolbase] updated
a1069 3

maptofreepool   ROUT
        Push    "R1-R7,LR"
d1071 1
a1071 2
        CMP     R2,#0
        Pull    "R1-R7,PC",LE           ; no block!
d1073 1
a1073 27

        LDR     R6,freepool
        LDR     R7,freepoolpages        ; R7 = number of pages in free pool
        ADD     R6,R6,R7,LSL #2
        ADD     R6,R6,R7,LSL #3         ; R6 -> terminators of free pool
        MOV     R0,R6                   ; R0 -> block for OS_SetMemMapEntries

        LDR     R1,pagesize
        LDR     R4,freepoolbase         ; R4 -> next address
        MOV     R5,#2                   ; R5 = protection level
01      LDR     R3,[R2],#12             ; R3 = page number
        CMP     R3,#0
        SUBGE   R4,R4,R1
        STMGEIA R6!,{R3,R4,R5}          ; page number, address, protection level
        ADDGE   R7,R7,#1
        BGE     %BT01


        STR     R4,freepoolbase
        STR     R7,freepoolpages
        MOV     R14,#-1
        STR     R14,[R6]                ; terminator


        SWI     XOS_SetMemMapEntries

        Pull    "R1-R7,PC"              ; don't alter memorylimit
d1092 2
a1093 2
        CMP     R0,#0                   ; no slot allocated
        BLGT    mapin                   ; (corrupts R2)
d1175 2
a1176 2
        CMP     R0,#0                   ; R0 --> slot block
        BLGT    mapout                  ; NB do this afterwards!
d1234 1
a1234 1
        BLE     %FT01
d1238 1
a1238 1
        BLE     %FT01
d1246 1
a1246 1
        BLT     err_notenoughmemory
d1251 1
a1251 1
        BLE     %FT02
d1255 2
a1256 2
        MOVLT   R1,#-1                  ; leave next slot alone
        SWILT   XWimp_SlotSize
d1260 1
a1260 1
        BLE     %FT99
d1323 1
a1323 1
        LDRB    R3,[R1]                 ; if terminator is "K" or "k",
d1325 1
a1325 1
        TEQ     R3,#"K"
d1328 6
@


4.4
log
@  Shock horror - a new feature for the Wimp! And some housekeeping too.
Detail:
  * Added new functionality for menu trees: submenus can now be opened by
    clicking on their parent menu item. This is particularly aimed at
    touchscreen devices, and is configurable via the new *Configure keyword
    WimpClickSubmenu.
  * Change to the menu inactivity timeout behaviour after auto-opening of
    submenus (either by hovering over the parent menu item or by the new
    click-to-open functionality): although all hover operations are still
    ignored for this period, any click operations *will* now be obeyed.
  * Corrected numerous misleading comments in the menu handling code.
  * Added some suspiciously absent ALIGNs in the *Configure keyword handlers.
  * Uses new ASCII case-forcing macros so there are now fewer warnings
    printed during assembly (and it should run faster now too).
  * Added an AREA directive so that objasm's -ABS switch is no longer needed.
  * Standardised ErrMem token across all Messages files that use English.
Admin:
  Tested on a desktop machine.
  Requires HdrSrc 1.06.

Version 4.57. Tagged as 'Wimp-4_57'
@
text
@d682 1
a682 2
01

d684 57
a740 2
; if application space in use, we can't construct a free pool
; but we must still read orig_memorylimit and orig_applicationspacesize
d742 1
a742 55

        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        MOVVC   R3,R1                           ; R3 --> real end of memory
        STRVC   R3,orig_applicationspacesize
;
        MOVVC   R0,#MemoryLimit
        MOVVC   R1,#0
        SWIVC   XOS_ChangeEnvironment
        STRVC   R1,orig_memorylimit
;
;
        TEQ     R1,R3                   ; preserves V
        Pull    "R1-R11,PC",NE          ; these must be equal on entry
;
        BLVC    testapplication         ; CC ==> space is in use
        Pull    "R1-R11,PC",VS
        Pull    "R1-R11,PC",CC          ; we'll get back to this later if used

;
; allocate a "free pool" block, with 12 bytes per page
;
        LDR     R3,npages
        MOV     R3,R3,LSL #2            ; multiply by 12
        ADD     R3,R3,R3,LSL #1
        ADD     R3,R3,#4                ; leave room for terminator
        BL      claimblock
        STRVC   R2,freepool
;
; construct free pool array by calling OS_FindMemMapEntries
;
        MOVVC   R1,#ApplicationStart
        STRVC   R1,freepoolbase         ; base address of free pages

        LDRVC   R1,orig_applicationspacesize
        BLVC    findfreepool
        MOVVC   R1,#2                   ; protect against USR mode access
        BLVC    setslotaccess
;
; I don't know what this is doing here!
;
        MOVVC   R14,#0
        STRVCB  R14,memoryOK            ; it's had it by now anyway!
;
; now protect all these pages, keeping them just below orig_memlimit
; and set MemoryLimit small
;
        MOVVC   R1,#ApplicationStart
        BLVC    setmemsize              ; sets ACTUAL handlers (current task)
;
        LDRVC   R0,freepool
        SWIVC   XOS_SetMemMapEntries

        Pull    "R1-R11,PC"
@


4.4.2.1
log
@  Added Dan Ellis's multithreading support, on a development branch for now.
Detail:
  This breaks the equivalence between tasks and AMB slots, allowing many
  threads of execution to share the same AMB slot, where an application's
  heap is usually located. In API terms, it is presented as an extension to
  Wimp_StartTask, see Docs/Multithreading for more information. It is the
  caller's responsibility to create a new stack chunk for the new thread if
  required. Note that BASIC's variable storage model is fundamentally
  unsuited for multithreading.
Admin:
  This was developed in 2001 and was not committed at the time due to lack
  of testing and peer review. It is now being added as a branch from a
  contemporary trunk Wimp. Hopefully somebody will be interested enough to
  merge the branch into a recent version!

Version 4.66, 4.77.2.1. Tagged as 'Wimp-4_66-4_77_2_1'
@
text
@d130 2
a131 22
        CMP     R2,#nullptr
 [ Threads
        LDRNE   R2,[R2,#app_slotptr]
        BNE     %FT03
        BL      getnullslot
        BVS     ExitWimp
        Push    "R4"
        MOV     R4,R2
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #app_datasize
        BL     XROS_Module              ; get an app slot
        STRVC   R2,[R5,#task_slotptr]

        STRVC   R4,[R2,#app_slotptr]    ; init the app slot
        MOVVC   R0, #1
        STRVC   R0,[R2,#app_refcnt]
        MOV     R2, R4
        Pull    "R4"
        BVS     ExitWimp
03
 |
        BLEQ    getnullslot
a133 1
 ]
a139 12
 [ Threads
        LDR     R4,[R5,#task_slotptr]
        STRNE   R2,[R4,#app_slotptr]
        BNE     %FT05

        MOV     R2,R4                  ; release the app slot
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module
        MOV     R0,#nullptr
        STR     R0,[R5,#task_slotptr]
05
 |
a141 1
 ]
d210 7
a216 7
        Push    "R0-R1,LR"
        MOV     R0,#0  ;reason code 0 (allocate)
        MOV     R1,#0  ;0 pages
        SWI     XOS_AMBControl
        Debug   mjs2,"getnullslot, slot handle =",R2
        STRVS   R0,[SP]
        Pull    "R0-R1,PC"
a499 5
 [ Threads
        LDR     R0,[R6,#task_slotptr]
        CMP     R0,#nullptr
        LDRNE   R0,[R0,#app_slotptr]
 |
a500 1
 ]
a512 5
 [ Threads
        LDR     R0,[R7,#task_slotptr]
        CMP     R0,#nullptr
        LDRNE   R0,[R0,#app_slotptr]
 |
a513 1
 ]
d549 1
a549 4
        CMP     R0,#nullptr
 [ Threads
        LDRNE   R0,[R0,#app_slotptr]
 ]
d561 1
a561 4
        CMP     R0,#nullptr
 [ Threads
        LDRNE   R0,[R0,#app_slotptr]
 ]
d907 8
a914 8
        Push    "R0-R4,LR"
        LDR     R1,slotsize ;no. of pages
        Debug mjs2,"allocateslot",R1
        MOV     R0,#0       ;reason code 0 (allocate)
        SWI     XOS_AMBControl
        BVC     %FT01
        BL      setdefaulthandlers
        Pull    "R0-R4,PC"
d916 5
a920 28
        Debug mjs2,"  allocateslot pages,slotptr",R1,R2
        LDR     R1,taskhandle
        LDR     R1,[wsptr,R1]
 [ Threads
        LDR     R4,[R1,#task_slotptr]
        CMP     R4,#nullptr
        BNE     %FT10

        Push    "R2"
        MOV     R0, #ModHandReason_Claim
        MOV     R3, #app_datasize
        BL     XROS_Module              ; get an app slot
        MOV     R4, R2
        Pull    "R2"
        BVC     %FT05

        BL      setdefaulthandlers      ; it's all gone horribly wrong
        Pull    "R0-R4,PC"
05
        STR     R4,[R1,#task_slotptr]
        MOV     R0, #1
        STR     R0,[R4,#app_refcnt]
10
        STR     R2,[R4,#app_slotptr]
 |
        STR     R2,[R1,#task_slotptr]
 ]
        Pull    "R0-R4,PC"
d992 1
a992 1
        Push    "R1-R3,LR"
a996 1
 [ Threads
a997 10
        CMP     R2,#nullptr
        BEQ     %FT03

        LDR     R14,[R2,#app_refcnt]
        SUBS    R14,R14,#1
        STR     R14,[R2,#app_refcnt]
        Debug   thread,"reduced refcount, appslot: ",R14,R2
        MOV     R14,#nullptr		; always null the task slotptr
        STR     R14,[R1,#task_slotptr]
        BLS     %FT02
a998 15
        MOV     R0,#3                ;reason code 3 (mapslot)
        MOV     R1,#-1               ;map out
        LDR     R2,[R2,#app_slotptr]
        Debug   mjs2, "Mapping out AMB slot ", R2
        SWI     XOS_AMBControl
        BVS     %FT04
        B       %FT03
02
        LDR     R3,[R2,#app_slotptr]
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module
        BVS     %FT04
        MOV     R2,R3
 |
        LDR     R2,[R1,#task_slotptr]
a1002 1
 ]
d1008 1
a1008 2
04
        Pull    "R1-R3,PC"
d1016 1
a1016 4
 [ :DEF:TestNullPtr
        CMP     R2,#nullptr
        MOVEQ   PC,LR              ;return if invalid slot pointer
 |
d1018 1
a1018 3
        MOVLE   PC,LR              ;return if invalid slot pointer
 ]
        Push    "R0,R1,LR"
a1021 24
 [ Threads
        LDR     R0,[R2,#app_refcnt]
        SUBS    R0,R0,#1
        STRHI   R0,[R2,#app_refcnt]
        Debug   thread,"reduced refcount, appslot: ",R0,R2
        BLS     %FT01

        MOV     R0,#3                ;reason code 3 (mapslot)
        MOV     R1,#-1               ;map out
        LDR     R2,[R2,#app_slotptr]
        Debug   mjs2, "Mapping out AMB slot ", R2
        SWI     XOS_AMBControl
        STRVS   R0,[SP]
        Pull    "R0,R1,PC"              ;return if refcnt +ve
01
        LDR     R1,[R2,#app_slotptr]
        MOV     R0,#ModHandReason_Free  ; free the app slot
        BL     XROS_Module
        STRVS   R0,[SP]
        Pull    "R0,R1,PC",VS
        Debug   thread,"removed appslot"
        MOV     R2,R1
 ]
        Debug   mjs2,"Deallocating AMB slot ", R2
d1025 1
a1025 1
        Pull    "R0,R1,PC"
a1084 4
 [ :DEF:TestNullPtr
        CMP     R0,#nullptr             ; no slot allocated
        BLNE    mapin                   ; (corrupts R2)
 |
d1087 1
a1087 2
 ]

a1108 3
 [ Threads
        LDR     R2,[R0,#app_slotptr]
 |
a1109 1
 ]
a1111 1
        Debug   mjs2, "Mapping in  AMB slot ", R2
d1116 19
a1167 4
 [ :DEF:TestNullPtr
        CMP     R0,#nullptr                   ; R0 --> slot block
        BLNE    mapout                  ; NB do this afterwards!
 |
a1169 1
 ]
a1178 3
 [ Threads
        LDR     R2,[R0,#app_slotptr]
 |
a1179 1
 ]
a1181 1
        Debug   mjs2, "Mapping out AMB slot ", R2
@


4.3
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d1317 1
a1317 1
        UpperCase R3, R14
@


4.2
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d285 1
d287 1
a287 1
        MOVNES  PC,lr                   ; not insterested in postshrink/grow
d839 1
a839 1
        Pull    "R0-R3,PC",,^           ; assume no errors
d886 1
a886 1
        Push    "LR"
d893 1
a893 1
        Pull    "PC",,^                 ; must preserve flags
d1007 2
a1008 1
        Pull    "R1-R2,PC",,^           ; preserve flags
d1281 1
a1281 1
        MOV     R3,#(?errordynamic)-4
d1411 1
a1411 1
        ORR     lr,lr,#V_bit                    ; note 26 bit mode only!!!!
@


4.1
log
@ARTtmp branch folded in
@
text
@d17 3
a19 1
;new way of doing things (Wimp delegates task memory management)
d21 1
a21 1
;only used if UseAMBControl is true
d27 1
a27 1
; THIS FILE APPLIES TO WIMP 2.65 ONWARDS
d71 1
a71 1
   Debug mjs2,"mjs version of Wimp_SlotSize",R0,R1
d86 5
d92 3
a94 2
        SWI     XOS_ReadDynamicArea     ; memory in free pool
        MOV     R2,R1
a234 4
 [ :LNOT: FreePoolWCF
wimpareastring
        DCB     "WDA",0                 ; SMC: add WDA:Wimp Dynamic Area to Wimp.Messages file.
 ]
a239 4
        [ :LNOT: FreePoolWCF
        MOV     R5,R1
        LDR     R1,wimparea
        ]
a242 1
        [ FreePoolWCF
d246 6
a252 11
        |
        MOV     R0,#1
        STRB    R0,memoryOK
        MOV     R0,R1
        MOV     R1,#-&8000000                   ; shrink area
        SWI     XOS_ChangeDynamicArea
        MOV     R0,#0
        STRB    R0,memoryOK
        CLRV
        B       ExitWimp
        ]
a254 1
        [ FreePoolWCF
a257 5
        |
        MOV     R0,R1
        SWI     XOS_ReadDynamicArea
        TEQ     R1,#0
        ]
d261 1
a261 2
        BNE     ExitWimp                              ; already 'claimed'
        [ FreePoolWCF
d275 6
a282 58
        [ false

        CMP     R5,#0                                   ; asked for -ve amount
        CMPGE   R1,R5                                   ; not enough ?
        MOVLT   R3,R1
        MOVLT   R4,#0                                   ; no address as claim 'failed'
        BLT     %FT01
05
        CLRV
        MOV     R1,#1
        STRB    R1,[R4]                                ; mark free pool as in use
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea
        MOVVS   R4,#0                                   ; shouldn't happen
        MOVVC   R3,R1
        MOVVC   R4,R0                                   ; start address of free pool
        B       %FT01
        ]

        |
        MOV     R1,#1
        STRB    R1,memoryOK
        MOV     R1,R5
        CMP     R1,#0
        SETV    LT
        LDRVC   R0,wimparea
        SWIVC   XOS_ChangeDynamicArea
        MOV     R4,#0
        STRB    R4,memoryOK
        MOVVS   R0,#6                           ; freepool, just size!!!
        LDRVC   R0,wimparea                     ; our area
        MOV     R2,#0
        CLRV
        SWI     XOS_ReadDynamicArea
        TEQ     R2,#0
        MOV     R3,R1
        MOVNE   R4,R0                           ; no start if claim failed
        CLRV

        B       %FT01
        ]
02

        TEQ     R0,#0
        LDRB    R5,memoryOK             ; always load R5
        BICEQ   R5,R5,#mem_claimed
        STREQB  R5,memoryOK
        BEQ     ExitWimp
;
        MOV     R3,#0                   ; R3=0  no memory available
        MOV     R4,#0                   ; R4=0  can't claim
;
        TEQ     R5,#0
        BNE     %FT01                   ; can't claim (nasty business going on)
;
        LDR     R14,freepool
        CMP     R14,#0
        BLE     %FT01                   ; can't claim (no free pool)
a283 13
        LDR     R3,orig_applicationspacesize
        LDR     R4,freepoolbase
        SUB     R3,R3,R4                ; R3 = length available
;
        ADD     R14,R3,#1
        CMP     R1,R14                  ; C=1 ==> too long!
        MOVCS   R4,#0                   ; address = 0 if carry set
        ORRCC   R5,R5,#mem_claimed
        STRCCB  R5,memoryOK
01
        STMIA   sp,{R3,R4}              ; R1,R2 on return = length,addr
        B       ExitWimp

d300 1
d325 1
a325 1
	TEQ	R14,#0
d354 6
a359 6
	BLT	err_badtransfer
	CMP	R1,#ApplicationStart	; buffer start >= &8000
	CMPHS	R3,#ApplicationStart
	BLO	err_badtransfer
	SUB	R8,R1,#ApplicationStart ; assuming app space...
	SUB	R9,R3,#ApplicationStart ; ... R8,R9 = offsets into domain
a361 3
        [ sixteenmeg
        MOV     R11,#16*1024*1024
        |
a362 1
        ]
d398 1
a398 1
	Push	"R1"			; save end-of-current-slot
d400 1
a400 1
        LDMIA   R0,{R0-R4}		; original parameters for Wimp_TransferBlock
d405 1
a405 1
	Pull	"R1"			; restore end-of-current-slot
d424 1
a424 4
	ADDLO	R0,R0,R2
        [ sixteenmeg
        CMP     R0,#16*1024*1024
        |
a426 1
        ]
d444 2
a445 2
        ADD     R0,SP,#8		; skipping just-pushed R1 and pushed R5 for Medusa...
        LDMIA   R0,{R0-R4}		; ...restore R0-R4 from stack for recursive call
a474 3
        [ sixteenmeg
        CMP     R0,#16*1024*1024
        |
a476 1
        ]
d489 3
a491 3
	MOV	R2,#0
	STR	R2,tempworkspace+4	; indicate mapenoughslot
	STR	R2,tempworkspace+12	;  not used yet
d502 2
a503 2
	STR	R1,tempworkspace	; save domain offset for later mapping-out use of mapenoughslot
	STR	R10,tempworkspace+4	; save length for later mapping-out use of mapenoughslot
d515 2
a516 2
	STR	R1,tempworkspace+8	; save domain offset for later mapping out use of mapenoughslot
	STR	R10,tempworkspace+12	; save length for later mapping out ue of mapenoughslot
d549 4
a552 4
	LDRNE	R10,tempworkspace+4	; saved length (0 if no mapping done)
	TEQNE	R10,#0
	LDRNE	R1,tempworkspace	; saved domain offset
	MOVNE	R2,#-1			; map out
d554 1
a554 1
	BLNE	mapenoughslot
d556 1
a556 1
	LDR	R2,taskhandle           ; page out the bits we paged in, unless CT
d561 4
a564 4
	LDRNE	R10,tempworkspace+12	; saved length (0 if no mapping done)
	TEQNE	R10,#0
	LDRNE	R1,tempworkspace+8	; saved domain offset
	MOVNE	R2,#-1			; map out
d566 1
a566 1
	BLNE	mapenoughslot
a587 1
;mjs version of mapenoughslot
d619 2
a620 2
	CMP	R1,#-1
	MOVEQ	R2,R1
a672 1
        [ :LNOT: sixteenmeg
a676 21
         [ :LNOT: FreePoolWCF
; create dynamic area for Wimp_ClaimFreeMemory
        ADRL    R0,wimpareastring       ; Look up name for Wimp dynamic area.
        ADR     R2,errorbuffer          ; Use safe place for temporary string (copied by OS_DynamicArea).
        MOV     R3,#256
        BL      LookupToken1
        MOVVC   R8,R2
        ADRVSL  R8,wimpareastring       ; If look up fails then create something anyway.

        MOV     R0,#0
        LDR     R1,wimparea
        MOV     R2,#0
        MOV     R3,#-1
        MOV     R4,#128                 ; not dragable
        MOV     R5,#-1
        ADRL    R6,wimp_area_handler
        MOV     R7,R12
        SWI     XOS_DynamicArea
; ignore errors
         ]
        ]
a813 3
        [ sixteenmeg
        MOV     R1,#16*1024*1024                ; boo hiss
        |
a814 1
        ]
a904 2

;mjs version
d908 1
a908 1
    Debug mjs2,"mjs version of allocateslot",R1
a989 2

;mjs version
d993 1
a993 1
   Debug mjs2,"mjs version of deallocateslot"
a1012 2

;mjs version
d1018 1
a1018 1
   Debug mjs2,"mjs version of deallocate"
a1104 2

;mjs version
a1174 3

;mjs version

d1295 1
a1295 1
errmem  DCB     "ErrMemS",0		; simple message
d1297 1
a1297 1
errmem  DCB     "ErrMem",0		; original one
d1328 1
a1338 12
        [ :LNOT: FreePoolWCF
         [ true
        Push    "R0-R2,lr"
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea             ; is there a kernel free pool
        Pull    "R0-R2,lr"
        MOVVCS  PC,lr
        CLRV
        |
        MOVS   PC,lr
         ]
        ]
a1368 3
       [ :LNOT: FreePoolWCF
        MOVS   PC,lr
       ]
a1398 1
        [ FreePoolWCF
a1411 94
        MakeInternatErrorBlock ChDynamNotAllMoved,,ErrNoMv
        LTORG
05
        ]
;
; if freepool>0, the Wimp MUST be in control
;
        LDR     R14,freepool
        CMP     R14,#0
        BLE     goto_osentry
;
        MOV     R14,#IRQsema            ; if in IRQ, forget it!
        LDR     R14,[R14]
        TEQ     R14,#0
        BNE     goto_osentry
;
        LDRB    R14,memoryOK            ; check for re-entrancy
        TST     R14, #mem_remapped
        BNE     goto_osentry            ; shouldn't ever happen

        TST     R14, #mem_claimed       ; if free memory claimed
        BNE     noslot                  ; then continue, but trap it in Service_Memory
;
; work out if the current free pool is sufficient to meet the demand
; if not, see whether the current application would like to give some up
;
        LDR     R14,freepoolpages       ; R14 = number of free pages
        LDR     R0,pagesize
        MUL     R14,R0,R14              ; R14 = free memory
        LDR     R1,[sp,#4]
        SUBS    R14,R14,R1              ; R14 = extra needed (if -ve)
        BGE     noslot
        SUB     R0,R0,#1                ; round to next lower page boundary
        BIC     R0,R14,R0               ; assume pagesize = 2^n
;
        BL      readCAOpointer          ; OS_ChangeEnvironment -> R2
        LDR     R14,orig_applicationspacesize
        CMP     R2,R14
        BCC     noslot                  ; can't do it
        ADRL    R14,Module_BaseAddr
        TEQ     R2,R14
        BEQ     %FT02                   ; OK if Wimp active - don't even ask!
;
  Debug mjs3,"My_ChangeDynamic issuing Service_Memory"
        MOV     R1,#Service_Memory      ; R0 = amount to change area by
        SWI     XOS_ServiceCall
        CMP     R1,#0                   ; clear V!
        BEQ     noslot                  ; can't do it
02
        Push    "R0"                    ; amount to move (-ve)
        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment   ; R1 = size of current slot
        Pull    "R0"
        SUB     R1,R1,#ApplicationStart ; convert from end address to SIZE
        ADDS    R0,R1,R0                ; R0 = new slot size (if -ve, ignore)
        MOVGE   R1,#-1
        SWIGE   XWimp_SlotSize          ; I hope this works!
noslot
;
; map all slots into application space
;
        MOV     R0,#CAOPointer          ; Wimp active during OS_ChangeDynamic
        ADRL    R1,Module_BaseAddr
        SWI     XOS_ChangeEnvironment
        STR     R1,oldCAOpointer        ;; MUST RESTORE CAOPOINTER !!!
;
; swap total memory limits with local ones
;
;
        MOV     R0,#MemoryLimit
        LDR     R1,orig_memorylimit
        SWI     XOS_ChangeEnvironment
        STR     R1,orig_memorylimit             ; swap these over
;
        MOV     R0,#ApplicationSpaceSize
        LDR     R1,orig_applicationspacesize
        STR     R1,oldapplimit                  ; used later
        SWI     XOS_ChangeEnvironment
        STR     R1,orig_applicationspacesize    ; swap these over
;
; map all slots into the area above the current one
;
        BL      rackupslots             ; R1 --> address to start from
                                        ; current task is left alone
;
; free pool is already present at the top end of the memory
; check that we now have a contiguous block of memory
;

        LDRB    R14,memoryOK
        ORR     R14,R14,#mem_remapped   ; set flag for Service_Memory
        STRB    R14,memoryOK

d1416 1
a1416 26
;
; Entry:  R1 --> address to start putting slots at
; Exit:   all slots mapped into application space, not overlapping
;         R2 --> end address of slots
;         R0,R1,R3,R4 trashed
;
rackupslots     ROUT
        Push    "LR"
;
        MOV     R2,R1                           ; start mapping from here
        ADRL    R1,taskpointers
        LDR     R3,taskhandle           ; this one's been done already
        ADD     R3,wsptr,R3
        MOV     R4,#maxtasks
01
        TEQ     R1,R3                   ; is this the current task?
        LDR     R14,[R1],#4             ; NB always increment R1
        TEQNE   R14,#task_unused
        LDRNE   R0,[R14,#task_slotptr]
        MOVEQ   R0,#nullptr
        CMP     R0,#0
        BLGT    mapslot                 ; updates [R0..], R2
        SUBS    R4,R4,#1
        BNE     %BT01
;
        Pull    "PC"
d1418 2
a1419 25
;
; Entry:  all slots mapped into application space, consecutively
; Exit:   all slots except the current one are mapped out
;         R0-R4 trashed
;

unrackslots     ROUT
        Push    "LR"
;
        ADRL    R1,taskpointers
        LDR     R3,taskhandle           ; leave this one alone
        ADD     R3,wsptr,R3
        MOV     R4,#maxtasks
01
        TEQ     R1,R3                   ; is this the current task?
        LDR     R14,[R1],#4             ; NB always increment R1
        TEQNE   R14,#task_unused
        LDRNE   R0,[R14,#task_slotptr]
        MOVEQ   R0,#nullptr
        CMP     R0,#0
        BLGT    mapout
        SUBS    R4,R4,#1
        BNE     %BT01
;
        Pull    "PC"
@


4.1.2.1
log
@ - corrected comments re Wimp08 versus Wimp08s
 - tidied up Wimp08s
 - Added optional use of kernel lock for Wimp_ClaimFreeMemory, controlled
   by KernelLocksFreePool in Options (currently true for Ursula only)
 - restricted max size of Wimp Sprite Pool dynamic area to 16M (controlled
   by WimpSpritePoolMaxSize in s.Memory) to avoid wasted address space on
   large memory machines
@
text
@d17 1
a17 3

; This is the current source code - s.Wimp08 is old source code - see
; comments at top of s.Wimp08
d19 1
a19 1
; mjs
d25 1
a25 1
; Wimp delegates task memory management to kernel, via OS_AMBControl
d69 1
a69 1
   Debug mjs2,"Wimp_SlotSize",R0,R1
a83 5
    [ ShrinkableAreas
        MOV     R0, #5
        MOV     R1, #-1
        SWI     XOS_DynamicArea         ; memory in free pool + shrinkable
    |
d85 2
a86 3
        SWI     XOS_ReadDynamicArea
        MOV     R2,R1                   ; memory in free pool
    ]
d227 4
d236 4
d243 1
a246 6
  [ KernelLocksFreePool
        MOV     R0,#10
        ORR     R0,R0,#&100
        MOV     R1,#0
        SWI     XOS_Memory                              ; release wimp lock
  ]
d248 11
d261 1
d265 5
d273 2
a274 1
        BNE     ExitWimp                                ; already 'claimed'
a287 6
  [ KernelLocksFreePool
        MOVLS   R0,#10
        ORRLS   R0,R0,#&100
        MOVLS   R1,#1
        SWILS   XOS_Memory                              ; set wimp lock
  ]
d290 58
d349 13
a377 1

d402 1
a402 1
        TEQ     R14,#0
d431 6
a436 6
        BLT     err_badtransfer
        CMP     R1,#ApplicationStart    ; buffer start >= &8000
        CMPHS   R3,#ApplicationStart
        BLO     err_badtransfer
        SUB     R8,R1,#ApplicationStart ; assuming app space...
        SUB     R9,R3,#ApplicationStart ; ... R8,R9 = offsets into domain
d439 3
d443 1
d479 1
a479 1
        Push    "R1"                    ; save end-of-current-slot
d481 1
a481 1
        LDMIA   R0,{R0-R4}              ; original parameters for Wimp_TransferBlock
d486 1
a486 1
        Pull    "R1"                    ; restore end-of-current-slot
d505 4
a508 1
        ADDLO   R0,R0,R2
d511 1
d529 2
a530 2
        ADD     R0,SP,#8                ; skipping just-pushed R1 and pushed R5 for Medusa...
        LDMIA   R0,{R0-R4}              ; ...restore R0-R4 from stack for recursive call
d560 3
d565 1
d578 3
a580 3
        MOV     R2,#0
        STR     R2,tempworkspace+4      ; indicate mapenoughslot
        STR     R2,tempworkspace+12     ;  not used yet
d591 2
a592 2
        STR     R1,tempworkspace        ; save domain offset for later mapping-out use of mapenoughslot
        STR     R10,tempworkspace+4     ; save length for later mapping-out use of mapenoughslot
d604 2
a605 2
        STR     R1,tempworkspace+8      ; save domain offset for later mapping out use of mapenoughslot
        STR     R10,tempworkspace+12    ; save length for later mapping out ue of mapenoughslot
d638 4
a641 4
        LDRNE   R10,tempworkspace+4     ; saved length (0 if no mapping done)
        TEQNE   R10,#0
        LDRNE   R1,tempworkspace        ; saved domain offset
        MOVNE   R2,#-1                  ; map out
d643 1
a643 1
        BLNE    mapenoughslot
d645 1
a645 1
        LDR     R2,taskhandle           ; page out the bits we paged in, unless CT
d650 4
a653 4
        LDRNE   R10,tempworkspace+12    ; saved length (0 if no mapping done)
        TEQNE   R10,#0
        LDRNE   R1,tempworkspace+8      ; saved domain offset
        MOVNE   R2,#-1                  ; map out
d655 1
a655 1
        BLNE    mapenoughslot
d677 1
d709 2
a710 2
        CMP     R1,#-1
        MOVEQ   R2,R1
d763 1
d768 21
d926 3
d930 1
d1021 2
d1026 1
a1026 1
    Debug mjs2,"allocateslot",R1
d1108 2
d1113 1
a1113 1
   Debug mjs2,"deallocateslot"
d1133 2
d1140 1
a1140 1
   Debug mjs2,"deallocate"
d1227 2
d1299 3
d1422 1
a1422 1
errmem  DCB     "ErrMemS",0             ; simple message
d1424 1
a1424 1
errmem  DCB     "ErrMem",0              ; original one
a1454 1
  [ :LNOT: KernelLocksFreePool
d1465 12
d1507 3
d1540 1
d1554 94
d1652 32
a1683 1
  ] ; :LNOT: KernelLocksFreePool
d1685 19
a1703 2
        MakeInternatErrorBlock ChDynamNotAllMoved,,ErrNoMv
        LTORG
@


1.1
log
@file Wimp08s was initially added on branch ARTtmp.
@
text
@d1 1705
@


1.1.2.1
log
@AMBControl task switching merged from RO_3_70 branch.
PlotSpritesFromPalette and TwitterOnlyMenus options added.
ChildWindows merged in.
@
text
@a0 1734
; Copyright 1997 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > s.Wimp08s

;new way of doing things (Wimp delegates task memory management)
;
;only used if UseAMBControl is true
;
;;----------------------------------------------------------------------------
;; Switcher routines
;;----------------------------------------------------------------------------

; THIS FILE APPLIES TO WIMP 2.65 ONWARDS

; Wimp_SlotSize
; Wimp_ClaimFreeMemory
; Wimp_TransferBlock
;
; findpages             look for application memory & set up free pool
; testapplication       see if the application space is in use
; restorepages          put the rest of the pages back after the current slot
; allocateslot          transfer pages from free pool to a slot array
; deallocateslot        transfer pages from a slot array to free pool
; mapslotin             map pages in a slot into application space
; mapslotout            map pages in a slot out of the way
;
; initdynamic           intercept SWI table entry
; resetdynamic          unintercept SWI table entry
; My_ChangeDynamic      stack the applications to fill up application space
;-----------------------------------------------------------------------------

; Data structures:
; task table -> task block (or task_unused if task dead)
; task block -> slot block for task
; freepool -> slot block for free pool (with room for all pages)
; slot block = { page, addr, protection }* -1 -1
;              (suitable for OS_ReadMemMapEntries and OS_FindMemMapEntries)
; freepoolbase, orig_applicationspacesize delimit the free pool

;-----------------------------------------------------------------------------


; Set/Read current Wimp slot size
; Entry:  R0 = new 'current' slot size in bytes (<0 ==> no change)
;         R1 = new 'next' slot size in bytes (<0 ==> no change)
; Exit:   R0 = actual 'current' slot size
;         R1 = actual 'next' slot size
;         R2 = total amount of free memory 'owned' by the Wimp
;              if R2 < R1, the next slot will not be allocated in full
;              when no tasks are running, R2 will be 0
;         if R0>=0 on entry, pages may be remapped and MemoryLimit changed


SWIWimp_SlotSize  ROUT
        MyEntry "SlotSize"

   Debug mjs2,"mjs version of Wimp_SlotSize",R0,R1
;
        MOV     R4,R0                   ; R4 = new current slot size
;
        MOV     R2,R1                   ; R2 = proposed slot size
        SWI     XOS_ReadMemMapInfo
        CMP     R2,#0                   ; if -ve, just read current value
        LDRLT   R3,slotsize
        BLT     %FT01
        ADD     R2,R2,R0                ; R2 = (R2+size-1) DIV size * size
        SUB     R2,R2,#1
        DivRem  R3,R2,R0, R14
01
        STR     R3,slotsize             ; [slotsize] = no of pages
        Push    "R0-R1"
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea     ; memory in free pool
        MOV     R2,R1
        Pull    "R0-R1"

        MUL     R1,R3,R0                ; R1 = next slot size
        STMIA   SP,{R1,R2}              ; ensure calling task gets new values

;
; transfer pages between current slot and free pool
; on exit R0 = actual current slot size (whether or not memory could be moved)
;
        CMP     R4,#-1                  ; R4 = proposed new current slot size
        BLE     returnmemsize           ; done if just reading

        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        MOV     R3,R1                   ; R3 --> end of current slot
        MOV     R0,#MemoryLimit
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        TEQ     R1,R3
        BNE     returnmemsize           ; cannot change slot size
;
        LDR     R0,pagesize             ; R0 = page size
        SUB     R14,R0,#1
        ADD     R4,R4,R14
        BIC     R4,R4,R14               ; round up to nearest page boundary
;
        LDR     R5,taskhandle           ; obtain R5 --> task block
        LDR     R5,[wsptr,R5]
        TST     R5,#task_unused
        LDRNE   R5,pendingtask
        TST     R5,#task_unused
        BNE     returnmemsize           ; no current task (?)
;
        LDR     R2,[R5,#task_slotptr]   ; R2 --> slot (if any)
        CMP     R2,#0
        BLLE    getnullslot
        STRVC   R2,[R5,#task_slotptr]   ; R2 --> slot
        BVS     ExitWimp                ; exit if unable to claim block

        MOV     R1,R4,LSR #12           ;no. of (4k) pages
        MOV     R0,#2                   ;grow/shrink reason code
        SWI     XOS_AMBControl
        BVS     ExitWimp
        CMP     R2,#0
        MOVEQ   R2,#nullptr
        STR     R2,[R5,#task_slotptr]
        MOV     R1,R1,LSL #12           ;no. of bytes
        CMP     R1,R3,LSL #12           ;did no. of pages change?
        BEQ     returnmemsize
        MOV     R5,R1                   ;for message
        B       sendmemmessage

; SafeChangeDynamic
; if running under Medusa then the CAO needs to be moved high, otherwise
; the CDA call will fail.
; Entry : R4 number of bytes to move (signed), R0-R3 possibly corrupt
; Exit  : R1 number of bytes actually moved (unsigned)
SafeChangeDynamic
        Push    "lr"
        MOV     R0,#15
        MOV     R1,#&08000000
        SWI     XOS_ChangeEnvironment
        BVS     %FT03                   ; can't change cao, try and shift memory anyway.
        MOV     R2,R1
        MOV     R0,#6                   ; freepool
        MOV     R1,R4                   ; number of bytes to alter free pool by
        SWI     XOS_ChangeDynamicArea
        Push    "R1"
        MOV     R1,R2
        MOV     R0,#15
        SWI     XOS_ChangeEnvironment   ; put cao back where it was.
        Pull    "R1,PC"
03
        MOV     R0,#6                   ; freepool
        MOV     R1,R4                   ; number of bytes to alter free pool by
        SWI     OS_ChangeDynamicArea
04
        Pull    "PC"

;
; send round a broadcast, to be picked up by the Switcher
; NB this can only be done if the task is alive (otherwise it has no handle)
;
sendmemmessage
        LDR     R14,taskhandle
        LDR     R14,[wsptr,R14]
        TST     R14,#task_unused

    Debug mjs2,"sendmemmessage R1,R5",R1,R5
;
        ASSERT  ms_data=20
        MOVEQ   R0,#28                  ; 28 byte block
        MOVEQ   R3,#0                   ; your ref
        LDREQ   R4,=Message_SlotSize
        LDREQ   R6,[sp,#0*4]            ; next slot size (already on stack)
        Push    "R0-R6"
        MOVEQ   R0,#User_Message        ; don't bother getting reply
        MOVEQ   R1,sp
        MOVEQ   R2,#0                   ; broadcast
        BLEQ    int_sendmessage         ; fills in sender, myref
        ADD     sp,sp,#28

returnmemsize
    Debug mjs2,"returnmemsize R1",R1
        MOV     R0,#MemoryLimit         ; may not actually be full slot size
        MOV     R1,#0                   ; (eg. if Twin is running above)
        SWI     XOS_ChangeEnvironment
    Debug mjs2,"  returnmemsize R1",R1
        SUBVC   R0,R1,#ApplicationStart ; R0 = actual slot size
    Debug mjs2,"  returnmemsize R0,R1",R0,R1
        B       ExitWimp
        LTORG

getnullslot
   Push  "R0-R1,LR"
   MOV   R0,#0  ;reason code 0 (allocate)
   MOV   R1,#0  ;0 pages
   SWI   XOS_AMBControl
   Debug mjs2,"getnullslot, slot handle =",R2
   STRVS R0,[SP]
   Pull  "R0-R1,PC"

;
; Claim free memory pages
; Entry:  R0 = 0 for release, 1 for claim
;         R1 = length required
; Exit:   R1 = length available
;         R2 = start address
;         R2 = 0 means memory could not be claimed (no need to release)
; Can't:  if not enough free memory
;         if claimed already
;         if in the middle of a remapping operation
;

mem_remapped    *       2_0001
mem_claimed     *       2_0010

wimparea
        DCB     "Wimp"
 [ :LNOT: FreePoolWCF
wimpareastring
        DCB     "WDA",0                 ; SMC: add WDA:Wimp Dynamic Area to Wimp.Messages file.
 ]
        ALIGN

SWIWimp_ClaimFreeMemory  ROUT
        MyEntry "ClaimFreeMemory"
;
        [ Medusa
        MedusaOS
        BNE     %FT02
        [ :LNOT: FreePoolWCF
        MOV     R5,R1
        LDR     R1,wimparea
        ]
        CMP     R0,#0
        BNE     %FT01
; free
        [ FreePoolWCF
        MOV     R0,#0
        ADRL    R14,freepoolinuse
        STRB    R0,[R14]
        B       ExitWimp
        |
        MOV     R0,#1
        STRB    R0,memoryOK
        MOV     R0,R1
        MOV     R1,#-&8000000                   ; shrink area
        SWI     XOS_ChangeDynamicArea
        MOV     R0,#0
        STRB    R0,memoryOK
        CLRV
        B       ExitWimp
        ]
01
; claim
        [ FreePoolWCF
        ADRL    R4,freepoolinuse
        LDRB    R0,[R4]
        TEQ     R0,#0
        |
        MOV     R0,R1
        SWI     XOS_ReadDynamicArea
        TEQ     R1,#0
        ]
        MOVNE   R0,#0
        STRNE   R0,[SP]
        STRNE   R0,[SP,#4]
        BNE     ExitWimp                              ; already 'claimed'
        [ FreePoolWCF
        MOV     R5,R1                                   ; preserve the amount asked for
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea
        MOVVS   R0,#0                                   ; Shouldn't happen
        MOVVS   R1,#0

        CMP     R5,R1                                   ; set HI if R5 <0 or R5>R1
        MOVHI   R0,#0
        MOVLS   R2,#1
        STRLSB  R2,[R4]                                 ; mark free pool in use

        STR     R0,[SP,#4]                              ; return values
        STR     R1,[SP]
        B       ExitWimp

        [ false

        CMP     R5,#0                                   ; asked for -ve amount
        CMPGE   R1,R5                                   ; not enough ?
        MOVLT   R3,R1
        MOVLT   R4,#0                                   ; no address as claim 'failed'
        BLT     %FT01
05
        CLRV
        MOV     R1,#1
        STRB    R1,[R4]                                ; mark free pool as in use
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea
        MOVVS   R4,#0                                   ; shouldn't happen
        MOVVC   R3,R1
        MOVVC   R4,R0                                   ; start address of free pool
        B       %FT01
        ]

        |
        MOV     R1,#1
        STRB    R1,memoryOK
        MOV     R1,R5
        CMP     R1,#0
        SETV    LT
        LDRVC   R0,wimparea
        SWIVC   XOS_ChangeDynamicArea
        MOV     R4,#0
        STRB    R4,memoryOK
        MOVVS   R0,#6                           ; freepool, just size!!!
        LDRVC   R0,wimparea                     ; our area
        MOV     R2,#0
        CLRV
        SWI     XOS_ReadDynamicArea
        TEQ     R2,#0
        MOV     R3,R1
        MOVNE   R4,R0                           ; no start if claim failed
        CLRV

        B       %FT01
        ]
02
        ]

        TEQ     R0,#0
        LDRB    R5,memoryOK             ; always load R5
        BICEQ   R5,R5,#mem_claimed
        STREQB  R5,memoryOK
        BEQ     ExitWimp
;
        MOV     R3,#0                   ; R3=0  no memory available
        MOV     R4,#0                   ; R4=0  can't claim
;
        TEQ     R5,#0
        BNE     %FT01                   ; can't claim (nasty business going on)
;
        LDR     R14,freepool
        CMP     R14,#0
        BLE     %FT01                   ; can't claim (no free pool)
;
        LDR     R3,orig_applicationspacesize
        LDR     R4,freepoolbase
        SUB     R3,R3,R4                ; R3 = length available
;
        ADD     R14,R3,#1
        CMP     R1,R14                  ; C=1 ==> too long!
        MOVCS   R4,#0                   ; address = 0 if carry set
        ORRCC   R5,R5,#mem_claimed
        STRCCB  R5,memoryOK
01
        STMIA   sp,{R3,R4}              ; R1,R2 on return = length,addr
        B       ExitWimp

wimp_area_handler
        TST     R0,#1
        MOVNES  PC,lr                   ; not insterested in postshrink/grow
        SETV
; must be a pre shrink/grow, allow this if it was caused by the claim above
        Push    R0
        LDRB    R0,memoryOK
        TEQ     R0,#0
        Pull    R0
        CLRV    NE
        MOVVC   PC,lr
        CMP     R0,#2
        MOVEQ   R3,#0
        MOV     R0,#0
        SETV
        MOV     PC,lr
;
; Transfer memory from one application to another
; Entry:  R0 = task handle of source
;         R1 --> source buffer
;         R2 = task handle of destination
;         R3 --> destination buffer
;         R4 = buffer length
;         buffer addresses and length are byte-aligned (not nec. word-aligned)
;         the buffer addresses are validated to ensure they are in range
; Errors: "Invalid task handle"
;         "Wimp transfer out of range"
;

SWIWimp_TransferBlock  ROUT
        MyEntry "TransferBlock"
;
  Debug mjs2,"&&&Wimp_TransferBlock",R0,R1,R2,R3,R4
        Push    "R0-R4"
        MOV     R0,#MemoryLimit         ; force this field to be up-to-date
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        LDR     R14,taskhandle
  Debug mjs2,"&&& taskhandle,MemoryLimit",R14,R1
        LDR     R14,[wsptr,R14]
        CMP     R14,#0
        STRGT   R1,[R14,#task_environment+12*MemoryLimit]
        [ Medusa
        MedusaOS
        LDMEQIA SP,{R0-R4}                      ; leave them on the stack
        LDMNEIA SP!,{R0-R4}
        |
        Pull    "R0-R4"
        ]
;
        BL      validtask_alive
        MOVVC   R7,R6                   ; R7 --> dest task block
        MOVVC   R2,R0
        [ Medusa
        Push    "R5"
        ]
        BLVC    validtask_alive         ; R6 --> source task block
        BVC     %FT05
medusa_exit_trb
        [ Medusa
        ADD     SP,SP,#4                ; the push above was non-conditional
        ]
medusa_exit_trb2
        [ Medusa
        MedusaOS
        ADDEQ   SP,SP,#20
        SETV                            ; want an error
        ]
        B       ExitWimp
;
05
        SUBS    R10,R4,#0               ; length must be >= 0
        BNE     %FT07                   ; ignore zero length now!
        [ Medusa
        ADD     SP,SP,#4
        MedusaOS
        ADDEQ   SP,SP,#20
        ; no error so don't set V
        ]
        B       ExitWimp

07
        SUBGES  R8,R1,#ApplicationStart ; buffer start >= &8000
        SUBGES  R9,R3,#ApplicationStart ; R8,R9 = offsets into domain
        BLT     err_badtransfer
;
        [ Medusa :LAND: sixteenmeg
        MedusaOS
        MOVEQ   R11,#16*1024*1024
        LDRNE   R11,orig_applicationspacesize
        |
        LDR     R11,orig_applicationspacesize
        ]
;
        CMP     R1,R11                  ; not in application space?
        ADDGE   R8,R8,#ApplicationStart ; make absolute again
        BGE     %FT11
        LDR     R14,[R6,#task_environment+12*MemoryLimit]
  Debug mjs2,"&&& source memlimit",R14
        ADD     R0,R1,R4
        CMP     R0,R14
        BGT     err_badtransfer
11
        CMP     R3,R11                  ; not in application space?
        ADDGE   R9,R9,#ApplicationStart ; make absolute again
        BGE     %FT01
        LDR     R14,[R7,#task_environment+12*MemoryLimit]
  Debug mjs2,"&&& dest memlimit",R14
        ADD     R2,R3,R4
        CMP     R2,R14
        BGT     err_badtransfer
01
;
; map all slots into memory space, copy the data, then unmap them
; NOTE: make sure the slots are mapped out before exitting!!!
;
        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment   ; R1 --> end of current slot
;

        [ Medusa
        MedusaOS
; orignal calling values are still on the stack
        BNE     %FT03
        CMP     R6,R7                   ; are the tasks the same?
        BEQ     %FT02
        CMP     R10,#7*1024*1024
        BLT     %FT02
; ok we're doing a BIG transfer, so split it up
        MOV     R10,#7*1024*1024        ; 7 meg, leave a bit of breathing space
        ADD     R0,SP,#4
        LDMIA   R0,{R0-R4}
        ADD     R1,R1,#7*1024*1024      ; we'll carry on but only do 7 megs worth
        ADD     R3,R3,#7*1024*1024      ; then recall the routine, but starting 7 meg
        SUB     R4,R4,#7*1024*1024      ; further on.
        SWI     XWimp_TransferBlock
; this will cycle through as many times as required
02
; now if the ammount to copy+ R1 > app space, or 2* copy if neither task is the current task
; then part or all of current task must be paged out.
        MOV     R0,R1
        LDR     R1,taskhandle
        LDR     R2,pagesize
        LDR     R4,[SP]                 ; task handle
        CMP     R1,R4
        BEQ     onetask_currentr4       ; one of the tasks is the current task
        CMP     R1,R5
        BEQ     onetask_currentr5
        CMP     R8,R11
        ADDLT   R0,R0,R10
        ADDLT   R0,R0,R2                ; just in case copy is over a page
        CMP     R9,R11
        ADDLT   R0,R0,R10
        ADDLT   R0,R0,R10
        [ sixteenmeg
        CMP     R0,#16*1024*1024
        |
        MedusaOS
        MOVNE   R14,#16*1024*1024
        LDREQ   R14,orig_applicationspacesize
        CMP     R0,R14
        ]
        BLT     %FT03

; since the copy must take place in application space (on ARM 3 its the only place! and on
; ARM 600 a level 2 page table would be required- 24K) we have to make some room by paging
; out part of the current task. For simplicity, we page the whole of the task out on the
; assumption that it is only rare circumstances that will bring us here. It's also
; potentially dangerous paging out bits of the current task, eg. if an exception occurs
; the Environment may point to somewhere that we've paged a different bit of memory to.
; Another complication with selective paging of the current task is that the bit we choose
; to page out may be required in the copy, obviously we need to do more work to make sure
; we don't fall over in these situations.
makespacefromct
  Debug mjs2,"&&& makespacefromct"
        Push    "R1"                    ; save task handle
        BL      mapslotout              ; map out CT
        MOV     R0,#0
        STR     R0,taskhandle
        ADD     R0,SP,#4
        LDMIA   R0,{R0-R4}
        SWI     XWimp_TransferBlock     ; do it again, only this time there is no current task
        Pull    "R1"
        STR     R1,taskhandle           ; return to how it all was
        BL      mapslotin
        ADD     SP,SP,#24
        B       ExitWimp

; this is potentially dodgy as the bit we want to map out of the way may actually be in
; the transfer range

onetask_currentr5
  Debug mjs2,"&&& onetask_currentr5"
        CMP     R5,R4
        BEQ     %FT03
        CMP     R8,R11                  ; we only need to woryy about space if the copy
                                        ; is actually in the tasks app space
        BLT     onetaskcurrent
        B       %FT03

onetask_currentr4
  Debug mjs2,"&&& onetask_currentr4"
        CMP     R5,R4
        BEQ     %FT03
        CMP     R9,R11

onetaskcurrent
        ADDLT   R0,R0,R10
        ADDLT   R0,R0,R2                ; just in case copy is over a page
        [ sixteenmeg
        CMP     R0,#16*1024*1024
        |
        MedusaOS
        MOVNE   R14,#16*1024*1024
        LDREQ   R14,orig_applicationspacesize
        CMP     R0,R14
        ]

        BLT     %FT03
        B       makespacefromct


03
        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment   ; R1 --> end of current slot
  Debug mjs2,"&&& end of current slot",R1
        Pull    "R4"
        MedusaOS
        ADDEQ   SP,SP,#20               ; will always be original values on stack
        MOV     R2,R1
        LDR     R3,taskhandle
        CMP     R8,R11                  ; do we need it paged in ?
        BGE     %FT04
        CMP     R3,R5
        ADDEQ   R8,R8,#ApplicationStart
        BEQ     %FT04
        LDR     R0,[R6,#task_slotptr]
        MOV     R1,R8
        MOV     R8,R2
        BL      mapenoughslot
        ADD     R8,R8,R0
04
        CMP     R9,R11
        BGE     %FT06
        CMP     R3,R4
        ADDEQ   R9,R9,#ApplicationStart
        BEQ     %FT06
        LDR     R0,[R7,#task_slotptr]
        MOV     R1,R9
        MOV     R9,R2
        BL      mapenoughslot           ; page in only whats required for the copy
        ADD     R9,R9,R0
06
        |
        BL      rackupslots             ; In: R1= bit; Out: trashes R0-R4
;
        CMP     R8,R11
        LDRLT   R14,[R6,#task_slotptr]  ; must be a slot here if address valid
        LDRLT   R14,[R14,#4]            ; get address of first page
        ADDLT   R8,R8,R14               ; R8 --> source buffer
;
        CMP     R9,R11
        LDRLT   R14,[R7,#task_slotptr]  ; must be a slot here if address valid
        LDRLT   R14,[R14,#4]            ; get address of first page
        ADDLT   R9,R9,R14               ; R9 --> destination buffer
        ]
;
; copy data in the correct order, in case source task = destination
;
        TST     R8,#3
        TSTEQ   R9,#3
        TSTEQ   R10,#3
        BEQ     wordcopy                ; word aligned, yipee!!!

        CMP     R8,R9
        BGE     %FT02
        ADD     R8,R8,R10
        ADD     R9,R9,R10
01
        LDRB    R14,[R8,#-1]!           ; descending copy if source < dest
        STRB    R14,[R9,#-1]!
        SUBS    R10,R10,#1
        BNE     %BT01
        B       %FT03
02
        LDRB    R14,[R8],#1             ; ascending copy if source >= dest
        STRB    R14,[R9],#1
        SUBS    R10,R10,#1
        BNE     %BT02
03
        [ Medusa
        LDR     R2,taskhandle           ; page out the bits we paged in, unless CT
        CMP     R2,R5
        BEQ     %FT05
        LDR     R0,[R6,#task_slotptr]
        CMP     R0,#-1
        BLNE    mapout
05
        CMP     R2,R4
        BEQ     %FT10
        LDR     R0,[R7,#task_slotptr]
        CMP     R0,#-1
        BLNE    mapout
10
        |
        BL      unrackslots
        ]
        B       ExitWimp

wordcopy
        CMP     R8,R9
        BGE     %FT02
        ADD     R8,R8,R10
        ADD     R9,R9,R10
01
        LDR     R14,[R8,#-4]!           ; descending copy if source < dest
        STR     R14,[R9,#-4]!
        SUBS    R10,R10,#4
        BNE     %BT01
        B       %BT03
02
        LDR     R14,[R8],#4             ; ascending copy if source >= dest
        STR     R14,[R9],#4
        SUBS    R10,R10,#4
        BNE     %BT02
        B       %BT03

;mjs version of mapenoughslot
; maps only the pages that are required for the copy to address R2, slot R0, length R10
; domain offset R1

mapenoughslot
        Push    "R0-R1,R3-R5,LR"

   Debug mjs2,"mjs version of mapenoughslot",R0,R1,R2,R10

        LDR     R4,pagesize
        SUB     R4,R4,#1

        AND     R5,R1,R4         ;offset from page
        STR     R5,[SP]          ;R0 on return
        ADD     R5,R5,R10
        ADD     R5,R5,R4
        BIC     R5,R5,R4         ;no. of pages required x pagesize
        MOV     R5,R5,LSR #12    ;no. of (4k) pages

        BIC     R1,R1,R4         ;start of map (page boundary)

        MOV     R3,R1,LSR #12    ;offset in (4k) pages to start of map
        MOV     R1,R2            ;start address
        MOV     R2,R0            ;handle
        MOV     R0,#3
        ORR     R0,R0,#&100      ;reason code 3, plus bit 8 set (mapsome)
        MOV     R4,R5            ;no. of pages to map
        SWI     XOS_AMBControl
        BVS     err_badtransfer2

        ADD     R2,R1,R4,LSL #12 ;R2 return
   Debug mjs2," <mapenoughslot",R2

        Pull    "R0-R1,R3-R5,PC"

err_badtransfer2
        MyXError        WimpBadSlot
        B               medusa_exit_trb2         ; task handle no longer on stack
        MakeErrorBlock  WimpBadSlot

err_badtransfer
        MyXError  WimpBadTransfer
        B         medusa_exit_trb
        MakeErrorBlock WimpBadTransfer


;
; free pool set up on entry (unless application memory is already in use)
;   order of pages in the free pool is unimportant
;
; Read in table of all OS pages
; work out which ones are in application space
; put them into free pool list
;
; Data structures:
; slot table:  list of 3-word entries (as passed to OS_ReadMemMapEntries)
; free pool:   list of 3-word entries (enough room for all pages in machine)
;              pages are used as in a LIFO stack, with lower addresses last
;
; Exit:  if application space used, [freepool] = -1
;                              else [freepool] --> free pool block
;
        DCB     "FindPages"

findpages       ROUT
        Push    "R1-R11,LR"
;
        MOV     R14,#nullptr
        STR     R14,freepool            ; lock application memory
        LDR     R14,taskhandle
        STR     R14,inithandle          ; this task slot "owns" the memory
;
        SWI     XOS_ReadMemMapInfo      ; R0 = page size, R1 = no of pages
        Pull    "R1-R11,PC",VS
        STR     R0,pagesize
        STR     R1,npages               ; used later
;
; under the Medusa kernel, try and shrink app space by as much as possible

        [ Medusa
        MedusaOS
        BNE     %FT01
        MOV     R0,#6                   ; free pool
        MOV     R1,#&10000000           ; try and shrink app space
        SWI     XOS_ChangeDynamicArea
; this sets up memory limit/ app space size as well
        [ :LNOT: sixteenmeg
        MOV     R0,#-1
        SWI     XOS_ReadDynamicArea
        ADDVC   R5,R0,R2
        STRVC   R5,orig_applicationspacesize
         [ :LNOT: FreePoolWCF
; create dynamic area for Wimp_ClaimFreeMemory
        ADRL    R0,wimpareastring       ; Look up name for Wimp dynamic area.
        ADR     R2,errorbuffer          ; Use safe place for temporary string (copied by OS_DynamicArea).
        MOV     R3,#256
        BL      LookupToken1
        MOVVC   R8,R2
        ADRVSL  R8,wimpareastring       ; If look up fails then create something anyway.

        MOV     R0,#0
        LDR     R1,wimparea
        MOV     R2,#0
        MOV     R3,#-1
        MOV     R4,#128                 ; not dragable
        MOV     R5,#-1
        ADRL    R6,wimp_area_handler
        MOV     R7,R12
        SWI     XOS_DynamicArea
; ignore errors
         ]
        ]

        CLRV

        Pull    "R1-R11,PC"
01
        ]
;
; if application space in use, we can't construct a free pool
; but we must still read orig_memorylimit and orig_applicationspacesize
;

        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        MOVVC   R3,R1                           ; R3 --> real end of memory
        STRVC   R3,orig_applicationspacesize
;
        MOVVC   R0,#MemoryLimit
        MOVVC   R1,#0
        SWIVC   XOS_ChangeEnvironment
        STRVC   R1,orig_memorylimit
;
;
        TEQ     R1,R3                   ; preserves V
        Pull    "R1-R11,PC",NE          ; these must be equal on entry
;
        BLVC    testapplication         ; CC ==> space is in use
        Pull    "R1-R11,PC",VS
        Pull    "R1-R11,PC",CC          ; we'll get back to this later if used

;
; allocate a "free pool" block, with 12 bytes per page
;
        LDR     R3,npages
        MOV     R3,R3,LSL #2            ; multiply by 12
        ADD     R3,R3,R3,LSL #1
        ADD     R3,R3,#4                ; leave room for terminator
        BL      claimblock
        STRVC   R2,freepool
;
; construct free pool array by calling OS_FindMemMapEntries
;
        MOVVC   R1,#ApplicationStart
        STRVC   R1,freepoolbase         ; base address of free pages

        LDRVC   R1,orig_applicationspacesize
        BLVC    findfreepool
        MOVVC   R1,#2                   ; protect against USR mode access
        BLVC    setslotaccess
;
; I don't know what this is doing here!
;
        MOVVC   R14,#0
        STRVCB  R14,memoryOK            ; it's had it by now anyway!
;
; now protect all these pages, keeping them just below orig_memlimit
; and set MemoryLimit small
;
        MOVVC   R1,#ApplicationStart
        BLVC    setmemsize              ; sets ACTUAL handlers (current task)
;
        LDRVC   R0,freepool
        SWIVC   XOS_SetMemMapEntries

        Pull    "R1-R11,PC"


; In    R1 = application space size (one after end of free pool)
;       R2 -> free pool page table
;       [freepoolbase] = start of free pool
; Out   free pool table filled in (lowest address last in list)
;       [freepoolbase] updated if less than application space size
;       [freepoolpages] set up

        DCB     "FindFreePool"

findfreepool    ROUT
        Push    "R1-R5,LR"


        LDR     R3,freepoolbase
        CMP     R3,R1
        MOVGT   R3,R1
        STRGT   R3,freepoolbase

        MOV     R4,#0                   ; R4 = no of pages so far
        MOV     R0,#0                   ; R0 = probable page no (don't know)
        LDR     R5,pagesize
01      SUB     R1,R1,R5                ; R1 = address of next page
        CMP     R1,R3
        STMGEIA R2!,{R0,R1,R14}         ; page no, address, access (undefined)
        ADDGE   R4,R4,#1
        BGE     %BT01
        STR     R4,freepoolpages
        MOV     R14,#-1
        STR     R14,[R2]                ; terminator

        LDR     R0,[sp,#1*4]
        SWI     XOS_FindMemMapEntries   ; find relevent pages

        Pull    "R1-R5,PC"

; In    R1 = page protection level required
;       R2 -> slot block
; Out   page protection level set, array updated
;       R0 corrupted

setslotaccess   ROUT
        Push    "R2,LR"

01      LDR     R14,[R2],#12            ; unless terminator,
        CMP     R14,#0
        STRGE   R1,[R2,#-4]             ; fill in access field
        BGE     %BT01

        LDR     R0,[sp]
        SWI     XOS_SetMemMapEntries

        Pull    "R2,PC"

;
; testapplication
; works out whether application space is in use
; Entry: [orig_memorylimit] = upper bound of memory used by application
;                             if &8000, then application space is not in use
; Exit:  CC ==> memory in use
;
; Method:
;    1. If CAO pointer < MemoryLimit, then application memory is in use.
;    2. Issue Service_Memory: R0 = large - if anyone objects, memory is in use
;

ApplicationStart  *  &8000
IsAnybodyThere    *  -64*&100000        ; large negative number
                                        ; NB: this number is checked for by ShellCLI
testapplication ROUT
        Push    "R1-R3,LR"
;
        [ Medusa :LAND: sixteenmeg
        MedusaOS
        LDRNE   R1,orig_applicationspacesize    ; watch out for Twin etc!
        MOVEQ   R1,#16*1024*1024                ; boo hiss
        |
        LDR     R1,orig_applicationspacesize    ; watch out for Twin etc!
        ]
        BL      readCAOpointer                  ; use OS_ChangeEnvironment
        CMP     R2,R1                           ; below memorylimit?
        Pull    "R1-R3,PC",CC
;
  Debug mjs3,"testapplication routine issueing Service_Memory"
        MOV     R1,#Service_Memory
        MOV     R0,#IsAnybodyThere      ; 64 megabytes should be enough!
        SWI     XOS_ServiceCall
        CMPVC   R1,#1                   ; CC ==> service was claimed
;
        Pull    "R1-R3,PC"


; Out   R2 = CAO pointer (read using OS_ChangeEnvironment)

readCAOpointer  ROUT
        Push    "R0-R3,LR"

        MOV     R0,#CAOPointer
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        STR     R1,[sp,#2*4]

        Pull    "R0-R3,PC",,^           ; assume no errors

;
; restorepages
; put back the free pool when the last task dies - do not disturb current stuff
; Entry:  all tasks dead
;         use OS_ChangeEnvironment to set/read end of application memory
;         free pool block indicates remaining spare pages
; Exit:   all pages replaced in application space
;         memorylimit increased if appropriate
;         free pool block released
;

restorepages    ROUT
        Push    "R1-R7,LR"
;
        BL      deletependingtask       ; not interested in this task

        [ Medusa
        MedusaOS
        MOVEQ   R4,#-&10000000            ; shrink freepool as much as we can
        BLEQ    SafeChangeDynamic
        Pull    "R1-R7,PC",EQ
        ]
;                                       ; just add to the pages present
        LDR     R6,freepool
        CMP     R6,#0
        BLE     go_restorememlimit      ; NB: orig_ values MUST BE CORRECT!
;
        MOV     R0,#MemoryLimit
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment   ; R1 = current memory limit
;
; free pool is already in the right place - just set access bits to 0
;
        LDR     R2,freepool
        MOV     R1,#0                   ; 0 => USR mode read/write access
        BL      setslotaccess           ; R2 -> free pool still

        MOV     R14,#nullptr2           ; application space NOT in use by Wimp
        STR     R14,freepool            ; NB only applies if not used on entry
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module              ; ignore errors from here

go_restorememlimit
        BL      restorememlimit
;
        Pull    "R1-R7,PC"

restorememlimit ROUT
        Push    "LR"
        MOV     R0,#MemoryLimit
        LDR     R1,orig_memorylimit
        SWI     XOS_ChangeEnvironment
        MOV     R0,#ApplicationSpaceSize
        LDR     R1,orig_applicationspacesize
        SWI     XOS_ChangeEnvironment
        Pull    "PC",,^                 ; must preserve flags

;
; allocateslot
; take pages from the free pool, and construct a page array block
; Entry:  [taskhandle] = current task
;         [slotsize] = max no of pages to use in new slot
; Exit:   taskhandle->task_slotptr --> block (suitable for OS_SetMemMapEntries)
;         pages transferred from the free pool to the slot
;         [freepoolbase] updated
;         slot size = 0 if no free pool (ie. all used up)
;         MemoryLimit updated to reflect the amount of memory available
;
        DCB     "AllocateSlot"

;mjs version
allocateslot    ROUT
       Push    "R0-R4,LR"
       LDR     R1,slotsize ;no. of pages
    Debug mjs2,"mjs version of allocateslot",R1
       MOV     R0,#0       ;reason code 0 (allocate)
       SWI     XOS_AMBControl
       BVC     %FT01
       BL      setdefaulthandlers
       Pull    "R0-R4,PC"
01
    Debug mjs2,"  allocateslot pages,slotptr",R1,R2
       LDR     R1,taskhandle
       LDR     R1,[wsptr,R1]
       STR     R2,[R1,#task_slotptr]
       Pull    "R0-R4,PC"


;
; Entry:  R2 --> slot block
;         R5 = number of pages required
; Exit:   R1 = amount of memory transferred
;         slot block, [freepoolbase], free pool sp updated
;         pages are not actually mapped in yet, and addresses are un-initialised
;

mapfromfreepool ROUT
        Push    "R2-R7,LR"
;
        LDR     R7,freepoolpages        ; R7 = number of pages in free pool
        SUB     R14,R7,R5
        STR     R14,freepoolpages       ; update [freepoolpages]

        ADD     R7,R7,R7,LSL #1
        LDR     R14,freepool
        ADD     R7,R14,R7,LSL #2        ; R7 -> terminator of free pool

        MOV     R4,#0                   ; R4 = page protection level (always 0)
01      SUBS    R5,R5,#1
        LDRPL   R0,[R7,#-12]!           ; R0 = page no
        STMPLIA R2!,{R0,R3,R4}          ; page no, address (uninit), access
        BPL     %BT01

        MOV     R14,#-1
        STR     R14,[R2]                ; slot block terminator
        STR     R14,[R7]                ; free pool terminator
;
; update [freepoolbase] and R1
;
        LDR     R0,pagesize             ; R0 = page size
        LDR     R5,[sp,#3*4]
        MUL     R1,R0,R5                ; R1 = amount of memory transferred
        LDR     R14,freepoolbase
        ADD     R14,R14,R1              ; update [freepoolbase]
        STR     R14,freepoolbase
;
        Pull    "R2-R7,PC"

;
; setmemsize
; sets up MemoryLimit and ApplicationSpaceSize for (polltaskhandle) task
; NB: these values apply to the CALLING task (so OS_ChangeEnvironment is used)
; Entry:  R1 = new memorylimit / applicationspacesize
; Exit:   OS_ChangeEnvironment used to change OS versions of these variables
;         if task is alive, its copies are also updated
;         R1 = old memorylimit
;

setmemsize      ROUT
        Push    "LR"
        MOV     R0,#ApplicationSpaceSize
        Push    "R1"
        SWI     XOS_ChangeEnvironment
        MOVVC   R0,#MemoryLimit
        Pull    "R1"
        SWIVC   XOS_ChangeEnvironment
        Pull    "PC"

;
; deallocateslot
; returns pages from a used slot to the free pool
; Entry:  [taskhandle] = current task
; Exit:   slot block deallocated (if any)
;         taskhandle->task_slotptr = null
;         pages put back into free pool (NB block never needs extension)
;

;mjs version
deallocateslot  ROUT
        Push    "R1-R2,LR"

   Debug mjs2,"mjs version of deallocateslot"
        LDR     R14,taskhandle
        LDR     R1,[wsptr,R14]          ; R1 --> task block
        LDR     R2,[R1,#task_slotptr]

        CMP     R2,#0
        MOVGT   R14,#nullptr
        STRGT   R14,[R1,#task_slotptr]
        BLE     %FT03

        MOV     R0,#1       ;deallocpages reason code
        SWI     XOS_AMBControl
03
        Pull    "R1-R2,PC",,^           ; preserve flags

;
; Entry:  R2 --> slot block
; Exit:   pages mapped into free pool etc. (maptofreepool called)
;         slot block deallocated
;

;mjs version
deallocate      ROUT
        Push    "R0,LR"
        CMP     R2,#0
        Pull    "R0,PC",LE              ;return if invalid slot pointer

   Debug mjs2,"mjs version of deallocate"

        MOV     R0,#1      ;deallocate reason code (not from App space)
        SWI     XOS_AMBControl
        STRVS   R0,[SP]
        Pull    "R0,PC"

;
; Entry:  R2 --> slot block
; Exit:   pages mapped to base of free pool
;         page numbers put into free pool (lowest page last)
;         [freepoolbase] updated
;

maptofreepool   ROUT
        Push    "R1-R7,LR"
;
        CMP     R2,#0
        Pull    "R1-R7,PC",LE           ; no block!
;

        LDR     R6,freepool
        LDR     R7,freepoolpages        ; R7 = number of pages in free pool
        ADD     R6,R6,R7,LSL #2
        ADD     R6,R6,R7,LSL #3         ; R6 -> terminators of free pool
        MOV     R0,R6                   ; R0 -> block for OS_SetMemMapEntries

        LDR     R1,pagesize
        LDR     R4,freepoolbase         ; R4 -> next address
        MOV     R5,#2                   ; R5 = protection level
01      LDR     R3,[R2],#12             ; R3 = page number
        CMP     R3,#0
        SUBGE   R4,R4,R1
        STMGEIA R6!,{R3,R4,R5}          ; page number, address, protection level
        ADDGE   R7,R7,#1
        BGE     %BT01


        STR     R4,freepoolbase
        STR     R7,freepoolpages
        MOV     R14,#-1
        STR     R14,[R6]                ; terminator


        SWI     XOS_SetMemMapEntries

        Pull    "R1-R7,PC"              ; don't alter memorylimit

;
; mapslotin
; all pages in a slot are put into the application space (&8000)
; Entry:  [taskhandle] = current task
; Exit:   pages mapped in
;         handlers (eg. MemoryLimit) are also set up from task data
;

mapslotin       ROUT
        Push    "R1-R4,LR"
;
        LDR     R14,taskhandle
        LDR     R1,[wsptr,R14]          ; R1 --> task block
        CMP     R1,#0
        Pull    "R1-R4,PC",LE           ; task is dead (shouldn't happen)
;
        LDR     R0,[R1,#task_slotptr]
        CMP     R0,#0                   ; no slot allocated
        BLGT    mapin                   ; (corrupts R2)
;

        LDR     R14,taskhandle
        LDR     R4,[wsptr,R14]          ; NB task cannot be dead
        ADD     R4,R4,#task_environment
;
        MOV     R0,#0                   ; handler number
01
        LDMIA   R4!,{R1-R3}             ; restore task handler data
        SWI     XOS_ChangeEnvironment
        ADD     R0,R0,#1
        CMP     R0,#MaxEnvNumber
        BCC     %BT01
;
        Pull    "R1-R4,PC"

;
; Entry:  R0 --> block suitable for passing to OS_SetMemMapEntries
; Exit:   the pages in the block are mapped into the application area
;

;mjs version
mapin   ROUT
        Push    "R0-R2,LR"
        MOV     R2,R0                ;handle
        MOV     R0,#3                ;reason code 3 (mapslot)
        MOV     R1,#ApplicationStart
        SWI     XOS_AMBControl
        STRVS   R0,[SP]
        Pull    "R0-R2,PC"

; Entry:  R0 --> page map block
;         R2 --> start address of place to map pages to
; Exit:   R2 --> after the memory

mapslot         ROUT
        Push    "R1,R3,LR"
;
        LDR     R3,pagesize
        MOV     R1,R0
01
        LDR     R14,[R1],#4
        CMP     R14,#0
        STRGE   R2,[R1],#8              ; next page
        ADDGE   R2,R2,R3
        BGE     %BT01
;
        SWI     XOS_SetMemMapEntries
;
        Pull    "R1,R3,PC"

;
; mapslotout
; all pages in a slot are put out of the way
; Entry:  [taskhandle] = current task
; Exit:   pages mapped out
;

mapslotout      ROUT
        Push    "R1-R6,LR"
;
        LDR     R14,taskhandle
        LDR     R6,[wsptr,R14]          ; R6 --> task block
        CMP     R6,#0
        Pull    "R1-R6,PC",LE           ; task is dead already
;
;
        ADD     R5,R6,#task_environment
        MOV     R0,#0
01
        TEQ     R0,#EscapeHandler       ; we must replace these now,
        TEQNE   R0,#EventHandler        ; since they are dangerous!
        MOVNE   R1,#0
        MOVNE   R2,#0
        MOVNE   R3,#0
        SWIEQ   XOS_ReadDefaultHandler  ; replace with 'kosher' handlers
        SWI     XOS_ChangeEnvironment   ; set, and read original settings
        STMIA   R5!,{R1-R3}             ; old data
        ADD     R0,R0,#1
        CMP     R0,#MaxEnvNumber
        BCC     %BT01
;
        LDR     R0,[R6,#task_slotptr]
        CMP     R0,#0                   ; R0 --> slot block
        BLGT    mapout                  ; NB do this afterwards!
;
        Pull    "R1-R6,PC"

;
; Entry:  R0 --> block suitable for passing to OS_SetMemMapEntries
; Exit:   all pages referenced in the block are mapped out of the way
;

;mjs version

mapout  ROUT
        Push    "R0-R2,LR"
        MOV     R2,R0                ;handle
        MOV     R0,#3                ;reason code 3 (mapslot)
        MOV     R1,#-1               ;map out
        SWI     XOS_AMBControl
        STRVS   R0,[SP]
        Pull    "R0-R2,PC"


;;----------------------------------------------------------------------------
;; *WimpSlot command (for changing amount of application space)
;;----------------------------------------------------------------------------

                ^       0
vec_min         #       4               ; fields in output vector
vec_max         #       4
vec_next        #       4

ss_outputvec    *       &100


Keydef  DCB     "min,max,next", 0       ; -min no longer compulsory
        ALIGN

WimpSlot_Code   ROUT
        Push    "R11,R12,LR"
        LDR     wsptr,[R12]
        MOV     R11,sp                  ; remember stack for later
;
        SUB     sp,sp,#ss_outputvec     ; local workspace
;
; scan the comand line by calling OS_ReadArgs
;
        MOV     R1,R0                   ; R1 = input string
        ADR     R0,Keydef               ; R0 = key definition string
        MOV     R2,sp                   ; R2 = output vector
        MOV     R3,#ss_outputvec        ; R3 = max output vector length
        SWI     XOS_ReadArgs
        BVS     %FT99
;
; scan the resulting vector for known fields
;
        MOV     R0,#MemoryLimit
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment
        SUB     R3,R1,#ApplicationStart ; R3 = current amount of memory
;
        LDR     R1,[sp,#vec_min]
        CMP     R1,#0
        BLE     %FT01
        BL      getminmax               ; R0 = min memory
        BVS     %FT99
        CMP     R0,R3
        BLE     %FT01
;
        Push    "R0"                    ; R0 = new current slot size
        MOV     R1,#-1                  ; leave next slot alone
        SWI     XWimp_SlotSize
        Pull    "R1"
        BVS     %FT99
        CMP     R0,R1                   ; R0=actual size, R1=required size
        BLT     err_notenoughmemory
        MOV     R3,R0                   ; R3 = new amount of memory
01
        LDR     R1,[sp,#vec_max]
        CMP     R1,#0
        BLE     %FT02
        BL      getminmax               ; R0 = max memory
        BVS     %FT99
        CMP     R0,R3
        MOVLT   R1,#-1                  ; leave next slot alone
        SWILT   XWimp_SlotSize
02
        LDR     R1,[sp,#vec_next]
        CMP     R1,#0
        BLE     %FT99
        BL      getminmax               ; R0 = new next slot size
        MOVVC   R1,R0
        MOVVC   R0,#-1                  ; leave current slot alone
        SWIVC   XWimp_SlotSize
99
        MOV     sp,R11
        Pull    "R11,R12,PC"

err_notenoughmemory
        MOV     R0,R1,ASR #10           ; R0 = size in K
;
        SUB     SP,SP,#32               ; allocate buffer big enough
;
        MOV     R1,SP
        MOV     R2,#20
        SWI     XOS_BinaryToDecimal     ; convert to a string
        ADDVS   SP,SP,#32
        BVS     %BT99                   ; (exit if it errored)
;
        MOV     R0,#0
        STRB    R0,[R1,R2]              ; terminate the string
;
        Push    "R4,R5"
;
        MOV     R4,R1                   ; -> string to use
        MOV     R5,#0

        MOV     R3,#(?errordynamic)-4
        ADRL    R2,errordynamic+4       ; -> buffer to fill in
        ADR     R0,errmem
        BL      LookupToken
;
        Pull    "R4,R5"
        ADD     SP,SP,#32               ; balance the stack
;
        ADRL    R0,errordynamic
        LDR     R1,=ErrorNumber_ChDynamNotAllMoved
        STR     R1,[R0]
;
        SETV
        B       %BT99                   ; exit having setup the error block

errmem  DCB     "ErrMem",0
        ALIGN

;
; Entry:  R1 --> string
; Exit:   R0 = parameter value (number)
; Errors: "Bad number"
;

getminmax       ROUT
        Push    "R1-R3,LR"
;
        MOV     R0,#10
        SWI     XOS_ReadUnsigned
        Pull    "R1-R3,PC",VS
;
        LDRB    R3,[R1]                 ; if terminator is "K" or "k",
        UpperCase R3, R14
        TEQ     R3,#"K"
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #10           ; multiply by 1024
;
        LDRB    R14,[R1]                ; check terminator
        RSBS    R14,R14,#" "+1          ; ensure GT set if OK
        MyXError BadNumb,LE
;
        MOVVC   R0,R2                   ; R0 = answer
        Pull    "R1-R3,PC"
        MakeInternatErrorBlock BadNumb,,BadParm


;;----------------------------------------------------------------------------
;; Stuff to deal with OS_ChangeDynamicArea
;;----------------------------------------------------------------------------

;
; intercept OS_ChangeDynamicArea
;

initdynamic     ROUT
        [ :LNOT: FreePoolWCF
        [ Medusa
         [ true
        Push    "R0-R2,lr"
        MOV     R0,#6
        SWI     XOS_ReadDynamicArea             ; is there a kernel free pool
        Pull    "R0-R2,lr"
        MOVVCS  PC,lr
        CLRV
        |
        MedusaOS
        MOVEQS PC,lr
         ]
        ]
        ]
        Push    "R1-R4,LR"
;
        ADR     R0,RAM_SWIEntry
        LDR     R1,copyofRAMcode+0
        LDR     R2,copyofRAMcode+4
        ADR     R3,My_ChangeDynamic
        LDR     R14,=SvcTable + 4 * OS_ChangeDynamicArea
        LDR     R4,[R14]                        ; R4 = old SWI entry
        TEQ     R4,R0
        Pull    "R1-R4,PC",EQ             ; if already in, forget it!

        STMIA R0,{R1-R4}
        STR   R0,[R14]                        ; R0 = RAM_SWIEntry
;
    ;StrongARM
    ;synchronise with respect to modified code at RAM_SWIEntry
        MOV     R1,R0                           ; start address
        ADD     R2,R1,#4                        ; end address (inclusive) for 2 words (other 2 are addresses)
        MOV     R0,#1                           ; means R1,R2 specify range
        SWI     XOS_SynchroniseCodeAreas        ; do the necessary

        Pull    "R1-R4,PC"

copyofRAMcode
        SUB     R12,PC,#:INDEX:RAM_SWIEntry+8
        LDR     PC,[PC,#-4]
        ASSERT  (.-copyofRAMcode = 8)
        ASSERT  (OScopy_ChangeDynamic-RAM_SWIEntry = 12)

resetdynamic    ROUT
       [ :LNOT: FreePoolWCF
        [ Medusa
        MedusaOS
        MOVEQS PC,lr
        ]
       ]

        Push    "R1,LR"
;
        LDR     R1,=SvcTable + 4 * OS_ChangeDynamicArea
        LDR     R14,OScopy_ChangeDynamic
        STR     R14,[R1]
;
        Pull    "R1,PC"
        LTORG


;----------------------------------------------------------------------------
; OS_ChangeDynamicArea
; Entry:  R0 = area to move (0=system heap, 1=RMA, 2=screen)
;         R1 = amount to move (+ve ==> take away from application space)
; Exit:   R1 = amount actually moved
; Errors: not all bytes moved (0 moved if R1 was +ve)
;
;  if freepool < 0 or CAO pointer <> Wimp,
;  then just pass it on
;  else if not enough free pool memory, grab some from current slot
;       map all pages into the application space
;       reset ApplicationSpaceSize/MemoryLimit to their original values
;       branch to the OS code
;-----------------------------------------------------------------------------

        LTORG

My_ChangeDynamic  ROUT
        Push    "R0-R5,LR"
        [ Medusa :LAND: FreePoolWCF
        MedusaOS
        BNE     %FT05
        ADRL    R14,freepoolinuse
        LDRB    R2,[R14]
        TEQ     R2,#0
        BEQ     goto_osentry
; free pool is in use by WCF, must trap with 'memory cannot be moved'
        MOV     R1,#0
        ADD     SP,SP,#8
        MyXError ChDynamNotAllMoved

        Pull    "R2-R5,lr"
        ORR     lr,lr,#V_bit                    ; note 26 bit mode only!!!!
        LDR     PC,=BranchToSWIExit

        MakeInternatErrorBlock ChDynamNotAllMoved,,ErrNoMv
        LTORG
05
        ]
;
; if freepool>0, the Wimp MUST be in control
;
        LDR     R14,freepool
        CMP     R14,#0
        BLE     goto_osentry
;
        MOV     R14,#IRQsema            ; if in IRQ, forget it!
        LDR     R14,[R14]
        TEQ     R14,#0
        BNE     goto_osentry
;
        LDRB    R14,memoryOK            ; check for re-entrancy
        TST     R14, #mem_remapped
        BNE     goto_osentry            ; shouldn't ever happen

        TST     R14, #mem_claimed       ; if free memory claimed
        BNE     noslot                  ; then continue, but trap it in Service_Memory
;
; work out if the current free pool is sufficient to meet the demand
; if not, see whether the current application would like to give some up
;
        LDR     R14,freepoolpages       ; R14 = number of free pages
        LDR     R0,pagesize
        MUL     R14,R0,R14              ; R14 = free memory
        LDR     R1,[sp,#4]
        SUBS    R14,R14,R1              ; R14 = extra needed (if -ve)
        BGE     noslot
        SUB     R0,R0,#1                ; round to next lower page boundary
        BIC     R0,R14,R0               ; assume pagesize = 2^n
;
        BL      readCAOpointer          ; OS_ChangeEnvironment -> R2
        LDR     R14,orig_applicationspacesize
        CMP     R2,R14
        BCC     noslot                  ; can't do it
        ADRL    R14,Module_BaseAddr
        TEQ     R2,R14
        BEQ     %FT02                   ; OK if Wimp active - don't even ask!
;
  Debug mjs3,"My_ChangeDynamic issuing Service_Memory"
        MOV     R1,#Service_Memory      ; R0 = amount to change area by
        SWI     XOS_ServiceCall
        CMP     R1,#0                   ; clear V!
        BEQ     noslot                  ; can't do it
02
        Push    "R0"                    ; amount to move (-ve)
        MOV     R0,#ApplicationSpaceSize
        MOV     R1,#0
        SWI     XOS_ChangeEnvironment   ; R1 = size of current slot
        Pull    "R0"
        SUB     R1,R1,#ApplicationStart ; convert from end address to SIZE
        ADDS    R0,R1,R0                ; R0 = new slot size (if -ve, ignore)
        MOVGE   R1,#-1
        SWIGE   XWimp_SlotSize          ; I hope this works!
noslot
;
; map all slots into application space
;
        MOV     R0,#CAOPointer          ; Wimp active during OS_ChangeDynamic
        ADRL    R1,Module_BaseAddr
        SWI     XOS_ChangeEnvironment
        STR     R1,oldCAOpointer        ;; MUST RESTORE CAOPOINTER !!!
;
; swap total memory limits with local ones
;
;
        MOV     R0,#MemoryLimit
        LDR     R1,orig_memorylimit
        SWI     XOS_ChangeEnvironment
        STR     R1,orig_memorylimit             ; swap these over
;
        MOV     R0,#ApplicationSpaceSize
        LDR     R1,orig_applicationspacesize
        STR     R1,oldapplimit                  ; used later
        SWI     XOS_ChangeEnvironment
        STR     R1,orig_applicationspacesize    ; swap these over
;
; map all slots into the area above the current one
;
        BL      rackupslots             ; R1 --> address to start from
                                        ; current task is left alone
;
; free pool is already present at the top end of the memory
; check that we now have a contiguous block of memory
;

        LDRB    R14,memoryOK
        ORR     R14,R14,#mem_remapped   ; set flag for Service_Memory
        STRB    R14,memoryOK

goto_osentry
        Pull    "R0-R5,LR"
        LDR     PC,OScopy_ChangeDynamic

;
; Entry:  R1 --> address to start putting slots at
; Exit:   all slots mapped into application space, not overlapping
;         R2 --> end address of slots
;         R0,R1,R3,R4 trashed
;
rackupslots     ROUT
        Push    "LR"
;
        MOV     R2,R1                           ; start mapping from here
        ADRL    R1,taskpointers
        LDR     R3,taskhandle           ; this one's been done already
        ADD     R3,wsptr,R3
        MOV     R4,#maxtasks
01
        TEQ     R1,R3                   ; is this the current task?
        LDR     R14,[R1],#4             ; NB always increment R1
        TEQNE   R14,#task_unused
        LDRNE   R0,[R14,#task_slotptr]
        MOVEQ   R0,#nullptr
        CMP     R0,#0
        BLGT    mapslot                 ; updates [R0..], R2
        SUBS    R4,R4,#1
        BNE     %BT01
;
        Pull    "PC"

;
; Entry:  all slots mapped into application space, consecutively
; Exit:   all slots except the current one are mapped out
;         R0-R4 trashed
;

unrackslots     ROUT
        Push    "LR"
;
        ADRL    R1,taskpointers
        LDR     R3,taskhandle           ; leave this one alone
        ADD     R3,wsptr,R3
        MOV     R4,#maxtasks
01
        TEQ     R1,R3                   ; is this the current task?
        LDR     R14,[R1],#4             ; NB always increment R1
        TEQNE   R14,#task_unused
        LDRNE   R0,[R14,#task_slotptr]
        MOVEQ   R0,#nullptr
        CMP     R0,#0
        BLGT    mapout
        SUBS    R4,R4,#1
        BNE     %BT01
;
        Pull    "PC"

        END
@


1.1.2.2
log
@Some obsolete assembly switches removed (chwidth in particular).
Behaviour of scrollbars with large extents improved.
Window tools now press in correctly after a Service_InvalidateCache.
Plotting of solid window tools optimised - background isn't drawn in.
Auto-fronting iconbar added.
Various optimisations, such as multiple OS_WriteI -> OS_WriteN.
HiResMono flag no longer relied on.
"22" tool sprites now chosen for 1x2,2x1 or 1x1 screen modes.
Buttons restored correctly after "application may have gone wrong" error box.
Positioning of outline font text shifted right 2 OS units to match system font.
Parameter of L validation string implemented.
Positioning of outline font "L" (multiple line) icons fixed.
Shift-toggle size behaviour fixed.
Wimp_TransferBlock above 2Gb should be fixed.
Post-rectangle filters implemented.
FPE4 flag added (to use LFM/SFM instead of LDFE/STFE).
Plotting of non-pixel aligned 3d icons fixed.
3d borders now solid in EX0/EY0 modes.
@
text
@d448 3
a450 6
	BLT	err_badtransfer
	CMP	R1,#ApplicationStart	; buffer start >= &8000
	CMPHS	R3,#ApplicationStart
	BLO	err_badtransfer
	SUB	R8,R1,#ApplicationStart ; R8,R9 = offsets into domain
	SUB	R9,R3,#ApplicationStart
d461 2
a462 2
        ADDHS   R8,R8,#ApplicationStart ; make absolute again
        BHS     %FT11
d467 1
a467 1
        BHI     err_badtransfer
d470 2
a471 2
        ADDHS   R9,R9,#ApplicationStart ; make absolute again
        BHS     %FT01
d476 1
a476 1
        BHI     err_badtransfer
d491 1
a491 1
        TEQ     R6,R7                   ; are the tasks the same?
d511 1
a511 1
        TEQ     R1,R4
d513 1
a513 1
        TEQ     R1,R5
d516 2
a517 2
        ADDLO   R0,R0,R10
        ADDLO   R0,R0,R2                ; just in case copy is over a page
d519 2
a520 6
        ADDLO   R0,R0,R10
	[ false
        ADDLO   R0,R0,R10		; Original code - surely a typo???
	|
	ADDLO	R0,R0,R2
	]
d529 1
a529 1
        BLO     %FT03
d560 1
a560 1
        TEQ     R5,R4
d564 1
a564 1
        BLO     onetaskcurrent
d569 1
a569 1
        TEQ     R5,R4
d574 2
a575 2
        ADDLO   R0,R0,R10
        ADDLO   R0,R0,R2                ; just in case copy is over a page
d585 1
a585 1
        BLO     %FT03
d600 2
a601 2
        BHS     %FT04
        TEQ     R3,R5
d611 2
a612 2
        BHS     %FT06
        TEQ     R3,R4
d625 3
a627 3
        LDRLO   R14,[R6,#task_slotptr]  ; must be a slot here if address valid
        LDRLO   R14,[R14,#4]            ; get address of first page
        ADDLO   R8,R8,R14               ; R8 --> source buffer
d630 3
a632 3
        LDRLO   R14,[R7,#task_slotptr]  ; must be a slot here if address valid
        LDRLO   R14,[R14,#4]            ; get address of first page
        ADDLO   R9,R9,R14               ; R9 --> destination buffer
d643 1
a643 1
        BHS     %FT02
d660 1
a660 1
        TEQ     R2,R5
d666 1
a666 1
        TEQ     R2,R4
d679 1
a679 1
        BHS     %FT02
@


1.1.2.3
log
@Wimp_TransferBlock fixes from RISC OS 3.71 merged.
@
text
@a393 1
; note that we use tempworkspace here
d398 1
a398 1
  Debug mjs4,"&&&Wimp_TransferBlock",R0,R1,R2,R3,R4
d404 3
a406 4
  Debug mjs4,"&&& taskhandle,MemoryLimit",R14,R1
	TEQ	R14,#0
        LDRNE   R14,[wsptr,R14]
        CMPNE   R14,#0
a415 1
  Debug mjs4,"&&& validtask_alive",R2
a421 1
  Debug mjs4,"&&& validtask_alive",R2
d437 1
a437 1
        SUBS    R10,R4,#0               ; length must != 0
d452 2
a453 3
	SUB	R8,R1,#ApplicationStart ; assuming app space...
	SUB	R9,R3,#ApplicationStart ; ... R8,R9 = offsets into domain
  Debug mjs4,"&&& offsets R8,R9",R8,R9
d467 1
a467 1
  Debug mjs4,"&&& source memlimit",R14
d476 1
a476 1
  Debug mjs4,"&&& dest memlimit",R14
d500 2
a501 3
	Push	"R1"			; save end-of-current-slot
        ADD     R0,SP,#8
        LDMIA   R0,{R0-R4}		; original parameters for Wimp_TransferBlock
a505 1
	Pull	"R1"			; restore end-of-current-slot
a509 1
  Debug mjs4,"&&& alleged end of current slot (R1)",R1
d523 3
d527 1
d548 1
a548 1
  Debug mjs4,"&&& makespacefromct"
d553 2
a554 2
        ADD     R0,SP,#8		; skipping just-pushed R1 and pushed R5 for Medusa...
        LDMIA   R0,{R0-R4}		; ...restore R0-R4 from stack for recursive call
d566 1
a566 1
  Debug mjs4,"&&& onetask_currentr5 R4,R5,R8,R11",R4,R5,R8,R11
d575 1
a575 1
  Debug mjs4,"&&& onetask_currentr4 R4,R5,R9,R11",R4,R5,R9,R11
a582 1
  Debug mjs4,"&&& onetask_current R0,R2,R10",R0,R2,R10
d600 1
a600 1
  Debug mjs4,"&&& end of current slot",R1
a603 3
	MOV	R2,#0
	STR	R2,tempworkspace+4	; indicate mapenoughslot
	STR	R2,tempworkspace+12	;  not used yet
a613 2
	STR	R1,tempworkspace	; save domain offset for later mapping-out use of mapenoughslot
	STR	R10,tempworkspace+4	; save length for later mapping-out use of mapenoughslot
a624 2
	STR	R1,tempworkspace+8	; save domain offset for later mapping out use of mapenoughslot
	STR	R10,tempworkspace+12	; save length for later mapping out ue of mapenoughslot
d671 1
a671 6
	LDRNE	R10,tempworkspace+4	; saved length (0 if no mapping done)
	TEQNE	R10,#0
	LDRNE	R1,tempworkspace	; saved domain offset
	MOVNE	R2,#-1			; map out
   Debug mjs4,"putative page out R0,R1,R2,R10",R0,R1,R2,R10
	BLNE	mapenoughslot
a672 1
	LDR	R2,taskhandle           ; page out the bits we paged in, unless CT
d677 1
a677 6
	LDRNE	R10,tempworkspace+12	; saved length (0 if no mapping done)
	TEQNE	R10,#0
	LDRNE	R1,tempworkspace+8	; saved domain offset
	MOVNE	R2,#-1			; map out
   Debug mjs4,"putative page out R0,R1,R2,R10",R0,R1,R2,R10
	BLNE	mapenoughslot
d704 1
a704 3
; domain offset R1, note that R2 = -1 means map out
;
; exit: R0 is offset from page boundary, R2 (if not -1) updated to next mappable address
d709 1
a709 1
   Debug mjs4,">mapenoughslot",R0,R1,R2,R10
d732 2
a733 4
	CMP	R1,#-1
	MOVEQ	R2,R1
        ADDNE   R2,R1,R4,LSL #12 ;R2 return
   Debug mjs4," <mapenoughslot",R2
@


1.1.2.4
log
@Added support for multiple options files (RO310, RO350, RO360, RO370, RCA,
Ursula).
Removed run-time MedusaOS checks.
Enabled correct build for RISC OS 3.1 machines.
Ensured that "freepoolinuse" is cleared before OS_ChangeDynamicArea
is intercepted.
Increased maxrects to 256.
Gave copy filter window handle in R10 (if ChildWindows).
Corrected a few border problems when no toolsprites.
Made toolsprites press in immediately - in particular close and toggle can
now be highlighted.
BounceClose flag no affects all of back,close,iconise and toggle.
Made "L" validation string parsing check manually for presence of a number,
to prevent error from OS_ReadUnsigned trashing MessageTrans' error buffers.
Allow error box buttons to stretch to fit text.
Fixed bug: floating point registers were not being saved unless on a portable.
Integrated some of the Wimp_TransferBlock fixes into Wimp08 from Wimp08s.
@
text
@d236 3
d335 1
d410 7
a416 1
        LDMIA   SP,{R0-R4}                      ; leave them on the stack
d422 1
d424 1
d429 1
d431 1
d433 3
a435 1
        ADD     SP,SP,#20
d437 1
d443 4
a446 1
        ADD     SP,SP,#24
d448 1
d460 4
a463 2
        [ sixteenmeg
        MOV     R11,#16*1024*1024
d495 2
d498 1
d535 3
a537 1
        LDR     R14,orig_applicationspacesize
d591 3
a593 1
        LDR     R14,orig_applicationspacesize
d607 2
a608 1
        ADD     SP,SP,#20               ; will always be original values on stack
d640 13
d677 1
d702 3
d791 1
d808 3
d846 1
a846 1

d915 1
d923 2
a924 2
        MOVHI   R3,R1
        STRHI   R3,freepoolbase
d931 2
a932 2
        STMHSIA R2!,{R0,R1,R14}         ; page no, address, access (undefined)
        ADDHS   R4,R4,#1
d979 4
a982 2
        [ sixteenmeg
        MOV     R1,#16*1024*1024                ; boo hiss
d1027 6
a1032 3
        MOV     R4,#-&10000000            ; shrink freepool as much as we can
        BL      SafeChangeDynamic
        Pull    "R1-R7,PC"
d1079 1
d1521 1
d1530 2
a1531 1
        MOVS   PC,lr
d1534 1
d1566 4
a1569 1
        MOVS   PC,lr
d1601 3
a1603 1
        [ FreePoolWCF
@

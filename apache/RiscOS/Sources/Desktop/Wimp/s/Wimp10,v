head	4.38;
access;
symbols
	Wimp-5_62:4.38
	Wimp-5_61:4.37
	Wimp-5_60:4.37
	Wimp-5_59:4.37
	Wimp-5_58:4.37
	Wimp-5_57:4.37
	Wimp-5_56:4.37
	Wimp-5_55:4.37
	Wimp-5_54:4.37
	Wimp-5_53:4.37
	Wimp-5_52:4.37
	Wimp-5_51:4.36
	Wimp-5_50:4.36
	Wimp-5_49:4.36
	Wimp-5_48:4.36
	Wimp-5_47-file1ad:4.35
	Wimp-5_47:4.35
	Wimp-5_46:4.35
	Wimp-5_45:4.35
	Wimp-5_44:4.34
	Wimp-5_43:4.34
	Wimp-5_42:4.34
	Wimp-5_41:4.34
	Wimp-5_40:4.33
	Wimp-5_39:4.33
	Wimp-5_38:4.33
	Wimp-5_37:4.33
	Wimp-5_36:4.32
	Wimp-5_35:4.32
	Wimp-5_34:4.32
	Wimp-5_33:4.32
	Wimp-5_32:4.30
	Wimp-5_31:4.29
	Wimp-5_30:4.29
	Wimp-530-pre4:4.27
	Wimp-5_30-pre3:4.26
	Wimp-5_30-pre2:4.25
	Wimp-5_30-pre1:4.25
	Wimp-5_29:4.25
	Wimp-5_28:4.23
	Wimp-5_27:4.23
	Wimp-5_26:4.22
	Wimp-5_25:4.22
	Wimp-5_24:4.21
	Wimp-5_23:4.20
	Wimp-5_22:4.20
	Wimp-5_21:4.20
	Wimp-5_20:4.19
	Wimp-5_19:4.17
	Wimp-5_18:4.17
	Wimp-5_17:4.17
	Wimp-5_16:4.17
	Wimp-5_15:4.16
	Wimp-5_14:4.16
	Wimp-5_13:4.16
	Wimp-5_12:4.16
	Wimp-5_11:4.16
	Wimp-5_10:4.16
	Wimp-5_09:4.16
	Wimp-5_08:4.16
	Wimp-5_07:4.16
	Wimp-5_06:4.16
	Wimp-5_05:4.16
	Wimp-5_04:4.16
	Wimp-5_03:4.16
	Wimp-5_02:4.15
	Wimp-5_01:4.15
	Wimp-4_66-4_77_2_1:4.11
	bavison_Threads_dev:4.11.0.2
	bavison_Threads_dev_bp:4.11
	Wimp-5_00:4.15
	Wimp-4_100:4.15
	Wimp-4_99:4.15
	Wimp-4_98:4.15
	Wimp-4_97:4.15
	Wimp-4_96:4.15
	Wimp-4_95:4.15
	Wimp-4_94:4.15
	RO_5_07:4.15
	Wimp-4_93:4.15
	Wimp-4_92:4.15
	Wimp-4_91:4.15
	Wimp-4_90:4.15
	Wimp-4_89:4.15
	Wimp-4_88:4.15
	Wimp-4_87:4.14
	Wimp-4_86:4.14
	Wimp-4_85:4.14
	Wimp-4_84:4.14
	Wimp-4_83:4.13
	Wimp-4_82:4.13
	Wimp-4_81:4.13
	Wimp-4_80:4.13
	Wimp-4_79:4.13
	Wimp-4_78:4.13
	Wimp-4_77:4.12
	Wimp-4_76:4.12
	Wimp-4_75:4.11
	Wimp-4_74:4.11
	Wimp-4_73:4.11
	Wimp-4_72:4.11
	Wimp-4_71:4.11
	Wimp-4_70:4.11
	Wimp-4_69:4.11
	Wimp-4_68:4.11
	Wimp-4_67:4.11
	Wimp-4_66:4.11
	Wimp-4_65:4.11
	Wimp-4_64:4.10
	Wimp-4_63:4.10
	Wimp-4_62:4.10
	Wimp-4_61:4.10
	Wimp-4_60:4.10
	Wimp-4_59:4.10
	Wimp-4_58:4.10
	Wimp-4_36-4_46_2_6:4.9
	Wimp-4_57:4.10
	Alpnet_approved:4.9
	Wimp-4_36-4_46_2_5:4.9
	Wimp-4_56:4.10
	dellis_autobuild_BaseSW:4.10
	Wimp-4_36-4_46_2_4:4.9
	Wimp-4_36-4_46_2_3:4.9
	Wimp-4_55:4.10
	Wimp-4_54:4.10
	Wimp-4_36-4_46_2_2:4.9
	Wimp-4_53:4.10
	Wimp-4_36-4_46_2_1:4.9
	Bethany:4.9.0.2
	Wimp-4_52:4.10
	Wimp-4_51:4.10
	Wimp-4_50:4.10
	Wimp-4_49:4.10
	Wimp-4_48:4.10
	Wimp-4_47:4.10
	Wimp-4_46:4.9
	Wimp-4_45:4.9
	Wimp-4_44:4.9
	Wimp-4_43:4.9
	Wimp-4_42:4.9
	sbrodie_sedwards_16Mar2000:4.9
	Wimp-4_41:4.9
	Wimp-4_40:4.9
	Wimp-4_39:4.9
	Wimp-4_38:4.9
	Wimp-4_37:4.9
	Wimp-4_36:4.9
	Wimp-4_35:4.9
	Wimp-4_34:4.8
	Wimp-4_33:4.8
	Wimp-4_32:4.8
	Wimp-4_31:4.8
	dcotton_autobuild_BaseSW:4.11
	Wimp-4_30:4.8
	Wimp-4_29:4.8
	Wimp-4_28:4.8
	Wimp-4_27:4.8
	Wimp-4_26:4.8
	Wimp-4_25:4.8
	Wimp-4_24:4.8
	Wimp-4_23:4.8
	Wimp-4_22:4.8
	Wimp-4_21:4.8
	Wimp-4_20:4.8
	Wimp-4_19:4.8
	Wimp-4_18:4.8
	Wimp-4_17:4.8
	Wimp-4_16:4.8
	Wimp-4_15:4.8
	Wimp-4_14:4.8
	Wimp-4_13:4.8
	Wimp-4_12:4.8
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.9
	bavison_Wimp-4_11:4.8
	Ursula_RiscPC:4.3.2.9.0.2
	Wimp-4_11:4.8
	Wimp-4_10:4.8
	Wimp-4_09:4.7
	Wimp-4_08:4.6
	Wimp-4_07:4.6
	Wimp-4_06:4.6
	Wimp-4_05:4.5
	Wimp-4_04:4.5
	bavison_Wimp-4_03_noshrinkables:4.5
	Wimp-4_03:4.5
	Wimp-4_02:4.5
	Ursula_merge:4.3.2.10
	bavison_Wimp-4_01:4.5
	Wimp-4_01:4.5
	nicke_Wimp_3_96M:4.1.7.2
	bavison_Wimp-4_00_TRUNK:4.4
	bavison_Wimp-4_00:4.3.2.10
	nicke_Wimp_3_96:4.1.7.2
	mjrobert_Wimp_3_98:4.3.2.1
	rthornb_UrsulaBuild-19Aug1998:4.3.2.9
	UrsulaBuild_FinalSoftload:4.3.2.9
	bavison_Wimp-3_99t:4.3.2.9
	rthornb_UrsulaBuild-12Aug1998:4.3.2.9
	bavison_Wimp-3_99s:4.3.2.9
	aglover_UrsulaBuild-05Aug1998:4.3.2.9
	bavison_Wimp-3_99r:4.3.2.9
	rthornb_UrsulaBuild-29Jul1998:4.3.2.8
	bavison_Wimp-3_99q:4.3.2.8
	jfarrell_NCWimp_3_96:4.1.7.2
	rthornb_UrsulaBuild-22Jul1998:4.3.2.7
	bavison_Wimp-3_99p:4.3.2.7
	rthornb_UrsulaBuild-15Jul1998:4.3.2.7
	bavison_Wimp-3_99o:4.3.2.7
	bavison_Wimp-3_99n:4.3.2.6
	rthornb_UrsulaBuild-07Jul1998:4.3.2.6
	bavison_Wimp-3_99m:4.3.2.6
	rthornb_UrsulaBuild-17Jun1998:4.3.2.6
	rthornb_UrsulaBuild-03Jun1998:4.3.2.6
	bavison_Wimp-3_99l:4.3.2.6
	rthornb_UrsulaBuild-27May1998:4.3.2.6
	rthornb_UrsulaBuild-21May1998:4.3.2.5
	bavison_Wimp-3_99k:4.3.2.6
	bavison_Wimp-3_99j:4.3.2.5
	bavison_Wimp-3_99i:4.3.2.5
	bavison_Wimp-3_99h:4.3.2.5
	rthornb_UrsulaBuild_01May1998:4.3.2.4
	bavison_Wimp_399g:4.3.2.4
	bavison_Wimp_399f:4.3.2.4
	afrost_NC2_Generic:4.1.7.2
	bavison_Wimp_399e:4.3.2.3
	bavison_Wimp_399d:4.3.2.2
	bavison_Wimp_399c:4.3.2.2
	Wimp_3_98:4.3.2.1
	kbracey_AW97:4.3
	Spinner_B20_2:4.1.7.2
	Spinner_19_3:4.1.7.2
	Spinner_B18:4.1.7.2
	Spinner_B17:4.1.7.2
	Spinner_B15:4.1.7.2
	Spinner_B14:4.1.7.2
	Spinner_B13:4.1.7.2
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula:4.3.0.2
	Ursula_bp:4.3
	Wimp_3_91:4.3
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1.2.4
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.2
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.38
date	2018.07.01.12.05.10;	author jlee;	state Exp;
branches;
next	4.37;
commitid	TwXih5IHBSRwEqIA;

4.37
date	2016.05.08.16.48.43;	author jlee;	state Exp;
branches;
next	4.36;
commitid	xXPn2osqjffdqH5z;

4.36
date	2015.07.08.07.57.24;	author rsprowson;	state Exp;
branches;
next	4.35;
commitid	QCjUcO42q8VKhssy;

4.35
date	2014.09.05.07.37.47;	author rsprowson;	state Exp;
branches;
next	4.34;
commitid	fuQh7ElpvcoR08Px;

4.34
date	2014.04.19.09.39.22;	author rsprowson;	state Exp;
branches;
next	4.33;
commitid	wEWgncfqw43A9hxx;

4.33
date	2014.03.09.17.39.43;	author jlee;	state Exp;
branches;
next	4.32;
commitid	jtr40bk3ymV683sx;

4.32
date	2013.10.08.00.14.19;	author jlee;	state Exp;
branches;
next	4.31;
commitid	ELGAm3ULXuvpeq8x;

4.31
date	2013.10.07.22.18.33;	author jlee;	state Exp;
branches;
next	4.30;
commitid	ATrKhtPyAxgGAp8x;

4.30
date	2013.09.08.18.53.30;	author rsprowson;	state Exp;
branches;
next	4.29;
commitid	46q23XZLtAc5oF4x;

4.29
date	2013.06.01.17.06.27;	author rsprowson;	state Exp;
branches;
next	4.28;
commitid	cfrGRVe6q9kCYVRw;

4.28
date	2013.06.01.16.50.09;	author rsprowson;	state Exp;
branches;
next	4.27;
commitid	T00MiOSzLYxNSVRw;

4.27
date	2013.06.01.16.46.09;	author rsprowson;	state Exp;
branches;
next	4.26;
commitid	JN66OJ2rTo2LQVRw;

4.26
date	2013.06.01.16.25.02;	author rsprowson;	state Exp;
branches;
next	4.25;
commitid	ED2vOQIaX05JJVRw;

4.25
date	2013.05.21.20.43.59;	author rsprowson;	state Exp;
branches;
next	4.24;
commitid	Jlxs4TLFYcOfxxQw;

4.24
date	2013.05.21.20.36.48;	author rsprowson;	state Exp;
branches;
next	4.23;
commitid	qpZh6Cn3wGUpuxQw;

4.23
date	2013.05.11.15.12.06;	author rsprowson;	state Exp;
branches;
next	4.22;
commitid	t0VXhGy6ECMh1ePw;

4.22
date	2013.05.06.11.54.49;	author rsprowson;	state Exp;
branches;
next	4.21;
commitid	dyQdYmrTRpty5zOw;

4.21
date	2013.05.03.21.08.17;	author rsprowson;	state Exp;
branches;
next	4.20;
commitid	QS59VqQdUOQmfeOw;

4.20
date	2013.03.31.17.40.49;	author jlee;	state Exp;
branches;
next	4.19;
commitid	9aIcBqwZ8383aYJw;

4.19
date	2013.03.28.08.07.33;	author rsprowson;	state Exp;
branches;
next	4.18;
commitid	6IoKYZf9tBXk5xJw;

4.18
date	2013.03.28.07.46.32;	author rsprowson;	state Exp;
branches;
next	4.17;
commitid	ShEaPU64dX96YwJw;

4.17
date	2012.07.08.23.15.41;	author jlee;	state Exp;
branches;
next	4.16;
commitid	3zoMINGB5Xq2zObw;

4.16
date	2008.09.10.15.47.58;	author srevill;	state Exp;
branches;
next	4.15;

4.15
date	2003.02.04.14.22.22;	author bavison;	state Exp;
branches;
next	4.14;

4.14
date	2002.12.20.19.48.21;	author bavison;	state Exp;
branches;
next	4.13;

4.13
date	2002.10.30.17.43.57;	author bavison;	state Exp;
branches;
next	4.12;

4.12
date	2002.10.23.17.12.38;	author bavison;	state Exp;
branches;
next	4.11;

4.11
date	2001.03.23.16.49.09;	author bavison;	state Exp;
branches;
next	4.10;

4.10
date	2000.04.25.12.24.11;	author kbracey;	state Exp;
branches;
next	4.9;

4.9
date	99.11.22.12.09.24;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	98.10.29.13.19.03;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	98.10.23.15.48.55;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	98.10.20.16.21.43;	author bavison;	state Exp;
branches;
next	4.5;

4.5
date	98.09.30.09.06.52;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	98.09.18.16.14.36;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.14.15.52;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.13.13.25.16;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.52;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	98.02.02.16.28.07;	author kbracey;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	98.03.10.16.11.58;	author bavison;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	98.04.17.16.54.19;	author bavison;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	98.04.21.16.58.06;	author bavison;	state Exp;
branches;
next	4.3.2.5;

4.3.2.5
date	98.05.08.11.43.55;	author bavison;	state Exp;
branches;
next	4.3.2.6;

4.3.2.6
date	98.05.25.17.59.46;	author bavison;	state Exp;
branches;
next	4.3.2.7;

4.3.2.7
date	98.07.14.16.34.22;	author bavison;	state Exp;
branches;
next	4.3.2.8;

4.3.2.8
date	98.07.28.17.11.20;	author bavison;	state Exp;
branches;
next	4.3.2.9;

4.3.2.9
date	98.08.05.09.09.49;	author bavison;	state Exp;
branches;
next	4.3.2.10;

4.3.2.10
date	98.09.18.14.14.36;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.30.52;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.33.19;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.25.04;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.22.30;	author nturton;	state Exp;
branches
	4.1.7.1.2.1;
next	4.1.7.2;

4.1.7.2
date	97.06.11.10.04.48;	author scormie;	state Exp;
branches;
next	;

4.1.7.1.2.1
date	97.04.10.13.51.39;	author kbracey;	state Exp;
branches;
next	4.1.7.1.2.2;

4.1.7.1.2.2
date	97.04.14.12.22.19;	author kbracey;	state Exp;
branches;
next	4.1.7.1.2.3;

4.1.7.1.2.3
date	97.04.14.13.35.27;	author kbracey;	state Exp;
branches;
next	4.1.7.1.2.4;

4.1.7.1.2.4
date	97.04.28.16.50.21;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.38
log
@Fix handling of tool sprite palettes in alpha-blended screen modes
Detail:
  s/Wimp10 - Update mastertoactive to force the palette/translation table to be sent through ColourTrans if either &RGB component ordering or alpha blending is in use for the current screen mode. Otherwise, for alpha modes, the alpha channel would typically be left at zero.
Admin:
  Tested on Raspberry Pi 3


Version 5.62. Tagged as 'Wimp-5_62'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Wimp10

;;-----------------------------------------------------------------------------
;; Icon border plotting routines / Window Border plotting routines
;;-----------------------------------------------------------------------------

;;-----------------------------------------------------------------------------
;; getborder - attempt to parse the validation string for the border number
;; and the highlight value.
;;
;; in   R1 = icon flags
;;      R3 -> validation string
;; out  R0 = border number to be used (always valid!)
;;      [border_type] => type of border to plot
;;      [border_highlight] => border highlight colour
;;-----------------------------------------------------------------------------

getborder EntryS "R2,R4-R5"

        Debug   bo,"getborder: icon flags, vstring, caller ",R1,R3,R14

        MOV     R4,#border_normal
        MOV     R5,#sc_midlightgrey     ; default values

        TST     R1,#if_text
        TSTNE   R1,#if_indirected
        BEQ     %FT11                   ; if not indirected + text then ignore
;
        AcceptLoosePointer_NegOrZero R3,-1
        CMP     R3,R3,ASR #31           ; is there a validation specified?
        BEQ     %10                     ; if not valid then skip
        MOV     R2,#WimpValidation_Border
        BL      findcommand
        BNE     %10                     ; if not present then skip
;
        BL      getnumber               ; get the border number
        MOV     R4,R0                   ; Defaults to zero
;
        LDRB    R14,[R3],#1             ; and then the next character
        TEQ     R14,#","
        BLEQ    getnumber               ; if its a comma, ie. following number get the highlight colour
        MOVEQ   R5,R0
10
        [ slabinout
        CMP     R4,#border_slabout
        BNE     %FT11
        TST     R1,#if_sprite
        BEQ     %FT11
        LDR     R4,two_sprite_save
;        EOR     R4,R4,R1                ; have flags been muddled with?
        TST     R4,#is_inverted
        MOVNE   R4,#border_slabin
        MOVEQ   R4,#border_slabout
        ]
11
        CMP     R4, #border_max         ; trap undefined cases immediately
        MOVHS   R4, #border_normal
        STR     R4,border_type
        STR     R5,border_highlight     ; setup the border + its highlight colour

        Debug   bo,"type,highlight",R4,R5

        MOV     R0,R4                   ; => border being used
        EXITS


;;-----------------------------------------------------------------------------
;; Adjust a set of co-ordinates based on the border size specified in R0.
;;
;; in   R0 = border type
;;      R1 = flags for icon
;;      x0-y1 => bounding box to be adjusted
;; out  R0 corrupt
;;      x0-y0 => snapped to inside of bounding box
;;-----------------------------------------------------------------------------

adjustforborder Entry "R1"

        TST     R1,#if_border           ; does the icon have a border?
        EXIT    EQ                      ; return if not

        TEQ     R0,#border_editable
        TEQNE   R0,#border_normal       ; this icons need an extra pixel removing
        LDREQ   R14,dx
        ADDEQ   x0,x0,R14
        SUBEQ   x1,x1,R14
        LDREQ   R14,dy
        ADDEQ   y0,y0,R14
        SUBEQ   y1,y1,R14               ; adjust by a single pixel borderness

        ADR     R1,sizetables
        LDRB    R0,[R1,R0]              ; get adjustment factor
        BL      adjust_bbox             ; snap to grid and then adjust by value in R0

        EXIT                            ; haven't corrupted C or V

sizetables      =  0,4,4,8,8,4,12,8

        ASSERT  ?sizetables =border_max


;;-----------------------------------------------------------------------------
;; various slab plotting routines.
;;
;; in   R1 = flags for icon
;;      x0-y1 => bounding box of the icon
;; out  -
;;-----------------------------------------------------------------------------

plot_slabin
        ADR     R3,ct_in
        B       plot_slab               ; draw 'slabbed in' region

plot_slabout
        ADR     R3,ct_out
        B       plot_slab               ; draw 'slabbed out' region

plot_editable Entry

        BL      plot_slabin             ; first slab
        ADR     R3,ct_grey
        BL      plot_slab

      [ TrueIcon2
        BL      icon_fg
        BL      hollowrectangle
      |
        TST     R1,#is_shaded           ; Icon disabled?
        BNE     %FT10                   ; Yes then no black border

        MOV     R0,#sc_black
        BL      int_setcolour           ; then a rectangle that is in black
        BL      hollowrectangle
10
      ]
        LDR     R0,dx
        ADD     x0,x0,R0
        SUB     x1,x1,R0
        LDR     R0,dy
        ADD     y0,y0,R0
        SUB     y1,y1,R0                ; acount for missing single pixel border (black jobbie)

        EXIT

plot_ridge Entry

        ADR     R3,ct_outshallow        ; ridge is made from two slabs, slab out and then in
        BL      plot_slab
        ADR     R3,ct_inshallow
        BL      plot_slab

        EXIT

plot_channel Entry

        ADR     R3,ct_inshallow         ; channel made from two slabs, slab in, slab out
        BL      plot_slab
        ADR     R3,ct_outshallow
        BL      plot_slab

        EXIT

plot_default Entry

        BL      plot_slabin             ; slab in
        ADR     R3,ct_cream
        BL      plot_slab               ; cream moat

        BL      plot_action             ; followed by an action button

        EXIT

plot_action

        TST     R1,#is_inverted
        BEQ     plot_slabout            ; action buttons are simply slabbed out
        BNE     plot_slabin



;;-----------------------------------------------------------------------------
;; plot_slab - plot a slab around the specified region using a colour table
;; supplied.
;;
;; in   R3 -> colour table
;;      x0-y1 co-ordinates to put the slab at
;; out  x0-y1 updated to reflect new bounding box
;;      R0-R3 preserved
;;-----------------------------------------------------------------------------

plot_slab Entry "R0-R4"

        BL      snap_coords             ; ensure snapped to a nice boundary

      [ fixslabalignment
        SUB     x1,x1,#1
        SUB     y1,y1,#1                ; adjust x1 and y1 to be inclusive

        ASSERT  :INDEX:dy - :INDEX:dx = 4
        ADR     R14,dx
        LDMIA   R14,{R0,R4}             ; get dx and dy
        TEQ     R0,#2
        TEQEQ   R4,#4
        BEQ     plot_slab_24

        CMP     R0,R4
        MOVLT   R4,R0                   ; R4 = smaller of dx and dy

        BL      render_bbox             ; plot first rectangle (at given coordinates)

        MOV     R0,#1
        BL      adjust_bbox             ; adjust the bounding box to cover reduced area

        CMP     R4,#1
        BLEQ    render_bbox             ; then fill again (but only if EX0 or EY0)

        MOV     R0,#1
        BL      adjust_bbox             ; adjust again
        BL      render_bbox             ; then fill again

        MOVEQ   R0,#1
        BLEQ    adjust_bbox             ; fill final line if hires
        BLEQ    render_bbox

        MOVEQ   R0,#1
        MOVNE   R0,#2
        BL      adjust_bbox             ; and finally return with adjust bounding box

        ADD     x1,x1,#1                ; adjust X1,Y1 to be exclusive again
        ADD     y1,y1,#1
      |
        LDR     R0,dx                   ; adjust X1,Y1 not to be inclusive
        SUB     x1,x1,R0
        LDR     R1,dy
        SUB     y1,y1,R0

        BL      render_bbox             ; plot first rectangle (at given coordinates)
        MOV     R0,#2
        BL      adjust_bbox             ; adjust the bounding box to cover reduced area

        BL      render_bbox             ; then fill again
        MOV     R0,#2
        BL      adjust_bbox             ; and finally return with adjust bounding box

        LDR     R0,dx                   ; adjust X1,Y1 not to be inclusive
        ADD     x1,x1,R0
        LDR     R1,dy
        ADD     y1,y1,R0
      ]

        EXIT

      [ fixslabalignment

;; special case of plot_slab for good, old-fashioned rectangular pixel modes.
;; It draws the bottom left and top right corners a bit more nicely
plot_slab_24
        MOV     R0,#2
        BL      adjust_bbox             ; draw inner line first
        BL      render_bbox
        MOV     R0,#-2
        BL      adjust_bbox
        BL      render_bbox             ; then outer line
        MOV     R0,#4
        BL      adjust_bbox             ; adjust final bounding box
        ADD     x1,x1,#1
        ADD     y1,y1,#1                ; restore original x1,y1
        EXIT
      ]


;;-----------------------------------------------------------------------------
;; snap_coords - snap coordinates to suitable OS unit boundaries for this
;;
;; in   x0-y1 => co-ordinates to align to a nice boundary
;; out  x0-y1 => co-ordinates having been aligned
;;-----------------------------------------------------------------------------

snap_coords
        LDR     R0,dx_1
        BIC     x0,x0,R0                ; align X0 back to nice grid point
      [ :LNOT:fixslabalignment
        ADD     x1,x1,R0
      ]
        BIC     x1,x1,R0                ; align X1 out to the next grid point

        LDR     R0,dy_1
        BIC     y0,y0,R0                ; align Y0 back to nice grid point
      [ :LNOT:fixslabalignment
        ADD     y1,y1,R0
      ]
        BIC     y1,y1,R0                ; align Y1 out to the next grid point

        MOV     PC,LR


;;-----------------------------------------------------------------------------
;; adjust_bbox - adjust all four co-ordinates by the specified value.
;;
;; in   R0 = adjustment factor in OS_Units
;;      x0-y1 => co-ordinates to massarge
;; out  x0-y1 => co-ordinates suitable tinkered with
;;-----------------------------------------------------------------------------

adjust_bbox ROUT
        ADD     x0,x0,R0                ; adjust x0,y0
        ADD     y0,y0,R0
        SUB     x1,x1,R0                ; adjust x1,y1
        SUB     y1,y1,R0
        MOV     PC,LR                   ; have preserved flags


;;-----------------------------------------------------------------------------
;; render_bbox - draw a rectangle around the specified co-ordinates, using the
;; byte array of colours for each of the four sides.
;;
;; in   R3 -> colour table (array)
;;      R4-R7 co-ordinates x0-y1.
;; out  -
;;-----------------------------------------------------------------------------

render_bbox EntryS "R3"

        MOV     R0,#4
        MOV     R1,x0
        MOV     R2,y0
        SWI     XOS_Plot                ; attempt to move to the bottom left

        MOV     R1,x1
        BL      render_line             ; plot along the bottom
        MOV     R2,y1
        BL      render_line             ; then up the right
        MOV     R1,x0
        BL      render_line             ; back across the top
        MOV     R2,y0
        BL      render_line             ; and then down back to the start

        EXITS                           ; must preserve flags

;..............................................................................

; render_line - plot line to specified user co-ordinates

; in    R1,R2 = co-ordinates
;       R3 -> byte containing colour to be used
; out   R3 -> next colour byte to be used

render_line Entry

      [ TrueIcon2
        LDR     R0, [R3], #4            ; get the line colour to be used
        LDR     R0, [wsptr, R0]
        Push    "R2-R4"
        LDR     R3, ditheringflag       ; set foreground
        MOV     R4, #0                  ; overwrite colour
        SWI     XColourTrans_SetGCOL
        Pull    "R2-R4"
      |
        LDRB    R0,[R3],#1              ; get the line colour to be used
        BL      int_setcolour           ; convert from the Wimp colour to suitable for screen
      ]
        MOV     R0,#&25
        SWI     XOS_Plot                ; and then plot the relevant line section

        EXIT


;;-----------------------------------------------------------------------------
;; Define constants relating to the borders.
;;-----------------------------------------------------------------------------

  [ TrueIcon2

ct_in
ct_inshallow    DCD     :INDEX: truefacecolour, :INDEX: truefacecolour, :INDEX: trueoppcolour,  :INDEX: trueoppcolour
ct_out
ct_outshallow   DCD     :INDEX: trueoppcolour,  :INDEX: trueoppcolour,  :INDEX: truefacecolour, :INDEX: truefacecolour
ct_cream
ct_grey         DCD     :INDEX: truewellcolour, :INDEX: truewellcolour, :INDEX: truewellcolour, :INDEX: truewellcolour

  |

    [ NCErrorBox
ct_in           = sc_darkgrey,      sc_darkgrey,      sc_verydarkgrey,  sc_verydarkgrey
ct_out          = sc_verydarkgrey,  sc_verydarkgrey,  sc_darkgrey,      sc_darkgrey
    |
ct_in           = sc_white,         sc_white,         sc_middarkgrey,   sc_middarkgrey
ct_out          = sc_middarkgrey,   sc_middarkgrey,   sc_white,         sc_white
    ]
ct_inshallow    = sc_white,         sc_white,         sc_lightgrey,     sc_lightgrey
ct_outshallow   = sc_lightgrey,     sc_lightgrey,     sc_white,         sc_white
ct_cream        = sc_cream,         sc_cream,         sc_cream,         sc_cream
ct_grey         = sc_verylightgrey, sc_verylightgrey, sc_verylightgrey, sc_verylightgrey

                ALIGN
  ]

;;-----------------------------------------------------------------------------
;; Handle replaceable window gadgets, this is simply a set of sprites which
;; can be used to replace all the window bits and bobs within the system.
;;
;; Tools are allowed to give two states; normal + pressed, though for some the
;; pressed state is omitted (eg. the scroll bar wells).
;;
;; All gadgets must be defined with the same palette and same mode, mixing is not
;; allowed.  Sprites are allowed to have mode suffix to allow different
;; EX EY factors to be supported.
;;
;; Tools sprite designers can optionally provide a set of precalculated translation
;; tables to map the toolsprites onto the standard 16 Wimp colours. Each table is
;; containerised as a sprite, but really it's just a translation table in disguise.
;;-----------------------------------------------------------------------------

tablebasename
        DCB     "table_1?", 0           ; Like background tiles, table_<wimpcolour>
        ALIGN

;;-----------------------------------------------------------------------------
;; Define the list of sprites and its workspace for the caching block.
;;
;; The table describes the sprite name and which information is important, such
;; as its width + depth.
;;
;;-----------------------------------------------------------------------------

spritetable

        ^ 0
        AddIcon back,,"bicon", back_width, title_height
        AddIcon close,,"cicon", close_width, title_height
        AddIcon toggle,,"ticon", vscroll_width, title_height
        AddIcon toggle1,,"ticon1", vscroll_width, title_height
        AddIcon size,,"sicon", vscroll_width, hscroll_height
      [ IconiseButton
        AddIcon iconise,,"iicon", iconise_width, title_height
      ]

        AddIcon up,,"uicon", vscroll_width, up_height
        AddIcon down,,"dicon", vscroll_width, down_height
        AddIcon right,,"ricon", right_width, hscroll_height
        AddIcon left,,"licon", left_width, hscroll_height

        AddIcon tbarlcap,,,title_left,title_height
        AddIcon tbarmidt,,,title_sectionwidth,title_topheight
        AddIcon tbarmidb,,,title_sectionwidth,title_bottomheight
        AddIcon tbarrcap,,,title_right,title_height

        AddIcon vwelltcap,no,,vscroll_width,vscroll_top
        AddIcon vwellt,no,,vscroll_width,vscroll_topfill

        AddIcon vbart,,,vscroll_width,vscroll_blobtop
        AddIcon vbarmid,,,vscroll_width,vscroll_blobfill
        AddIcon vbarb,,,vscroll_width,vscroll_blobbottom

        AddIcon vwellb,no,,vscroll_width,vscroll_bottomfill
        AddIcon vwellbcap,no,,vscroll_width,vscroll_bottom

        AddIcon hwelllcap,no,,hscroll_left,hscroll_height
        AddIcon hwelll,no,,hscroll_leftfill,hscroll_height

        AddIcon hbarl,,,hscroll_blobleft,hscroll_height
        AddIcon hbarmid,,,hscroll_blob,hscroll_height
        AddIcon hbarr,,,hscroll_blobright,hscroll_height

        AddIcon hwellr,no,,hscroll_rightfill,hscroll_height
        AddIcon hwellrcap,no,,hscroll_right,hscroll_height

      [ hvblip
        AddIcon hblip,,,hscroll_blipwidth,hscroll_height
        AddIcon vblip,,,vscroll_width,vscroll_blipheight
      ]

; this must always be the *LAST* sprite in the list!

        AddIcon blank,no,"blicon",vscroll_width,hscroll_height

        ALIGN

toolcachesize   * :INDEX: @@


;;-----------------------------------------------------------------------------
;; Attempt to build a list of the active icons within the system, this is used
;; for scanning through and replacing the various gadgets.  We attempt to
;; setup the caching list.
;;
;; NB: The tool sprites temporarily become part of the list of active
;;     sprites - avoid *IconSpriting any borders files.
;;
;; in   [tool_list] -> current tool list / =0 for none
;;      [tool_area] -> tool sprite area / =0 for none (don't build list)
;;      [dx/dy] => pixel sizes
;;      [xborder/yborder] = default border sizes to be used
;; out  [tool_list] -> new tool list
;;      [tool_plotparams] => suitable plotting parameters for sprites
;;      ... lots of others redefined to make plotting work
;;-----------------------------------------------------------------------------

maketoollist EntryS "R1-R11"

        Debug   tools,"Make tool list called =>",#tool_area,#tool_list,R14

        [ debugnk
        MOV R0,SP
        Debug   nk,"Make tool list called =>",#tool_area,#tool_list,R14,R0
        ]
;
        LDRB    R0,yborder
        LDRB    R1,xborder
        BL      default_params          ; default the parameters to border sizes

; if no list defined then drop back to a set of defaults for the current set
; of VDU style glyphs.


        LDR     R2,tool_area            ; still none?

        Debug   nk,"Tool area",R2

        TEQ     R2,#0
        BEQ     %FT45                   ; No then jump

      [ ToolTables

; look for any custom translation tables

        SUB     R13,R13,#12             ; space for "table_99"+0
        MOV     R4,#0                   ; bitmap of found wimp colours
        MOV     R5,#15                  ; wimp colour loop counter
        ADRL    R6,ttt_masterset
02
        ADR     R0,tablebasename
        MOV     R1,R13
        BL      copy0
        CMP     R5,#10                  ; numbery bit
        ADDCS   R0,R5,#'0' - 10
        STRCSB  R0,[R1,#-1]!
        ADDCC   R0,R5,#'0'
        STRCCB  R0,[R1,#-2]!
        MOV     R0,#0
        STRB    R0,[R1,#1]              ; terminate

        LDR     R0,=&100+SpriteReason_SelectSprite
        ADRL    R1,tool_areaCB
        MOV     R2,R13
        SWI     XOS_SpriteOp
        MOVVC   R0,#1                   ; hit
        ORRVC   R4,R4,R0,LSL R5
        LDRVC   R1,[R2,#spImage]
        ADDVC   R2,R2,R1
        MOVVS   R2,#0                   ; miss
        STR     R2,[R6,R5,LSL #2]       ; start of containerised 256x4 translation table

        SUBS    R5,R5,#1
        BPL     %BT02

; consider the results

        ADD     R13,R13,#12
        MOVS    R0,R4,LSL #16
        BEQ     %FT05                   ; we aint got naffin

        TST     R4,#1:SHL:2
        BLEQ    freetoolarea
        BEQ     %FT45                   ; need 'table_2' for tinting, can't use these tools
05
      ]
;..............................................................................
;
; attempt to work out the sizes of the various sprites and their modifications to
; the existing borders.

; work out which suffix to apply to sprite names

        MOV     R6,#1
        MOV     R10,#'0'

        MOV     R0,#-1
        MOV     R1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        ADD     R5,R10,R6,LSL R2

        MOV     R1,#VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        ADD     R6,R10,R6,LSL R2

      [ :LNOT: Sprites11
        TEQ     R5,#'1'
        TEQNE   R6,#'1'
        MOVEQ   R5,#'2'
        MOVEQ   R6,#'2'                 ; '1y' or 'x1' -> '22'
      ]
        TEQ     R6,#'2'
        TEQNE   R6,#'4'
        TEQEQ   R5,#'2'
        BNE     %FT05                   ; if not '22' or '24' then no mono alternative suffix

        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        TEQ     R2,#0
        BNE     %FT05                   ; not mono
        TEQ     R6,#'4'
        MOVEQ   R5,#'0'
        MOVEQ   R6,#0                   ; '24' -> '0'
        MOVNE   R6,#'3'                 ; '22' -> '23'
05
        ORR     R10,R5,R6,LSL #8        ; combine to make a postfix
;
; now attempt to sort out the sprites to be used
;
        MOV     R0,#-1
        STRB    R0,addtoolstolist       ; flag as adding tools into the list
        BL      freelist
;
        MOV     R0,#area_Wimp
        STR     R0,thisCBptr            ; reference to the Wimps sprite block
;
        LDR     R2,tool_list
        LDR     R3,=toolcachesize       ; -> list / size
;
        TEQ     R2,#0                   ; has the list buffer been setup yet?
        BNE     %FT07
        ADRL    R14,tool_list_backup
        LDR     R2,[R14]                ; this is a constant size so try and reuse
        CMP     R2,#0
        STRNE   R2,tool_list

        Debug   nk,"Tool list Backup",R2

        BNE     %FT07

        MOV     R0,#ModHandReason_Claim
        BL      XROS_Module
        STRVC   R2,tool_list
        ADRVCL  R14,tool_list_backup
        STRVC   R2,[R14]

        EXITS   VS                      ; return if it fails to claim
;
07
        MOV     R0,#0
        MOV     R1,#0                   ; Set tool sizes to 0 == undefined
        STRB    R1,spritecachevalid
        BL      default_params

        ADD     R3,R3,R2                ; -> end of list
        ADRL    R8,spritetable          ; -> list of sprite names
        MOV     R9,R2                   ; -> list to fill in
10
        SUBS    R14,R3,R9
        BEQ     %FT40                   ; finished the list so tidy up and exit
;
        Debuga  tools,"Block pointer =",R9
        DebugS  tools,", name ",R8
;
        SUB     SP,SP,#16               ; allocate some space for the name
        MOV     R4,SP
;
        STR     R4,spritename           ; -> buffer to be used
        STR     R4,lengthflags
15
        LDRB    R14,[R8],#1
        TEQ     R14,#0
        STRNEB  R14,[R4],#1
        BNE     %BT15                   ; copy sprite name to a RAM buffer
;
        ADD     R8,R8,#3
        BIC     R8,R8,#3                ; align name pointer to word boundary
;
        STRB    R10,[R4]
        MOVS    R14,R10,LSR #8
        STRB    R14,[R4,#1]
        MOVNE   R14,#0
        STRNEB  R14,[R4,#2]             ; attach a suitable postfix

        ; this uses different approach to cut down on 'sprite not found'

        LDRB    R14,spritecachevalid
        TEQ     R14,#0
        BNE     %FT04
        BL      cachespriteaddress      ; try with postfix
        BVC     %FT07                   ; list exists and postfixed sprite found

        LDR     R14,list_at
        CMP     R14,R14,ASR #31
        BEQ     %FT03
        BL      cachetoolspriteaddress  ; list exists, try other or no postfixes
        B       %FT07

03      MOV     R14,#1
        STRB    R14,spritecachevalid    ; remember there's no list for next toolsprite
04      LDR     R14,thisCBptr
        Push    "R14"
        ADRL    R14,tool_areaCB
        STR     R14,thisCBptr
        BL      cachespriteaddress
        BLVS    cachetoolspriteaddress
        Pull    "R14"
        STR     R14,thisCBptr
07
        ADD     SP,SP,#16
        ADDVS   R8,R8,#4*2
        BVS     %FT30                   ; if not found then skip
;
        Debug   tools,"Found at",R2
;
        Push    "R2-R3"
;
        MOV     R0,#SpriteReason_ReadSpriteSize +&200
        LDR     R1,tool_area
        SWI     XOS_SpriteOp            ; assume it works as sprite already found
;
        SUBS    R3,R3,#1
        MOVMI   R3,#0
        SUBS    R4,R4,#1
        MOVMI   R4,#0                   ; always returns an extra pixel - unhelpful!
;
      [ TrueIcon3
        ; If these are the ROM toolsprites, assume all tools are unmasked
        LDR     R0,ROMstart
        LDR     R14,ROMend
        CMP     R1,R0
        CMPHS   R14,R1
        BHS     %FT66
      ]
;
        TEQ     R5,#1
        LDREQ   R5,[sp]
        ORREQ   R5,R5,#1
        STREQ   R5,[sp]                 ; store mask status
66
        MOV     R0,R6
        MOV     R1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        MOVCC   R5,R3,LSL R2            ; get OS unit width
        MOVCC   R1,#VduExt_YEigFactor
        SWICC   XOS_ReadModeVariable
        MOVCC   R4,R4,LSL R2            ; get OS unit height
        MOVCS   R0,#0
        STRCS   R0,[SP]                 ; if mode invalid then sprite not found
        ADDCS   R8,R8,#4*2
        BCS     %FT20
;
        LDMIA   R8!,{R0,R1}             ; offsets to modifing the width / height suitably
        Debug   tools,"Offsets to modify (width,height) =>",R0,R1,R5,R4
;
        CMP     R0,#0
        LDRGT   R2,[wsptr,R0]           ; update the width if its bigger
        CMPGT   R5,R2
        STRGT   R5,[wsptr,R0]
;
        CMP     R1,#0
        LDRGT   R2,[wsptr,R1]           ; update the height if its bigger
        CMPGT   R4,R2
        STRGT   R4,[wsptr,R1]
20
        Pull    "R2-R3"
30      STR     R2,[R9],#4
        B       %BT10                   ; loop back until entire list as been scanned

; Set default sizes for undefined tools

40
      [ UTF8
        BL      read_current_alphabet
        BEQ     %FT88
      ]
        LDR     LR,back_width
        TEQ     LR,#0                   ; Back tool defined?
        ADREQL  R0,initvdustring2
        MOVEQ   R1,#endvdustring2-initvdustring2
        SWIEQ   XOS_WriteN              ; No then re-define glyphs
88
        LDRB    R1,yborder
        LDR     LR,title_height
        TEQ     LR,#0
        STREQ   R1,title_height
        LDR     LR,up_height
        TEQ     LR,#0
        STREQ   R1,up_height
        LDR     LR,down_height
        TEQ     LR,#0
        STREQ   R1,down_height
        LDR     LR,hscroll_height
        TEQ     LR,#0
        STREQ   R1,hscroll_height
;
        LDRB    R1,xborder
        LDR     LR,vscroll_width
        TEQ     LR,#0
        STREQ   R1,vscroll_width
        LDR     LR,back_width
        TEQ     LR,#0
        STREQ   R1,back_width
        LDR     LR,close_width
        TEQ     LR,#0
        STREQ   R1,close_width
      [ IconiseButton
        LDR     LR,iconise_width
        TEQ     LR,#0
        STREQ   R1,iconise_width
      ]
        LDR     LR,left_width
        TEQ     LR,#0
        STREQ   R1,left_width
        LDR     LR,right_width
        TEQ     LR,#0
        STREQ   R1,right_width

        MOV     R0,#0
        STRB    R0,addtoolstolist       ; remake list without tools present
        BL      freelist
;
; calculate a suitable pixel translation table for for the sprites,
; assume that R2 -> suitable sprite which describes the characteristics
; of all the other sprites being plotted.
;
        BIC     R2,R2,#1                ; strip our mask bit
        STR     R2,spritename
        MOV     R2,#0
        STR     R2,lengthflags          ; [spritename] is absolute
      [ TrueIcon3
        STRB    R2,tinted_tool          ; tinting off, incase the last window drawn was
                                        ; tinted before dropping to the CLI for *TOOLSPRITES
      ]
;
        BL      freetooltrans           ; release tool translation table
        BL      cachetoolspritedata     ; attempt to build a suitable pixtrans table
;
        BVC     %FT42
        ; a failure here usually means that we can't even allocate a pix table
        ; due to lack of memory. We have to free the lot!
        BL      freetoolarea
        EXITS
42
      [ Medusa
        MOV     R1, #8+32               ; Plot masked with wide tables by default
      |
        MOV     R1, #8                  ; Plot masked by default
      ]
      [ fastborders
        LDRB    R0,tsprite_needsfactors ; do we need to do translation
        TEQ     R0,#0
        LDREQ   R0,=&200+SpriteReason_PutSpriteUserCoords
        LDRNE   R0,=&200+SpriteReason_PutSpriteScaled
        ADRNEL  R2,tool_scalingblk
        LDRNE   R3,tpixtable_at
        MOVEQ   R3,#0
      |
        LDR     R0,=&200+SpriteReason_PutSpriteScaled
      [ TrueIcon3
        LDR     R14, tool_area
        LDR     R2, ROMstart
        LDR     R3, ROMend
        CMP     R14, R2
        CMPHS   R3, R14
      [ Medusa
        MOVHS   R1, #0+32               ; pretend ROM toolsprites are unmasked
      |
        MOVHS   R1, #0
      ]
      ]
        ADRL    R2,tool_scalingblk
        LDR     R3,tpixtable_at
      ]
;
        ASSERT  tool_maskop = tool_plotop+4
        ASSERT  tool_scaling = tool_maskop+4
        ASSERT  tool_transtable = tool_scaling+4
        ASSERT  ?tool_scalingblk = 4*4
;
        ADRL    R14,tool_plotparams
        STMIA   R14,{R0-R3}             ; setup a parameter block
;
      [ :LNOT: fastborders
        TEQ     R3,#0                   ; not needed with fastborders set
      ]
      [ ChildWindows
        ADR     R14,tsprite_factors
        LDMIA   R14,{R3,R4,R5,R6}
        ADRL    R14,tool_scalingblk
        STMIA   R14,{R3,R4,R5,R6}        ; take a copy of the scaling block (even if the tools don't always need it)
      |
      [ fastborders
        ADRNE   R14,tsprite_factors
        LDMNEIA R14,{R3,R4,R5,R6}
        STMNEIA R2,{R3,R4,R5,R6}        ; take a copy of the scaling block
      |
        ADR     R14,tsprite_factors
        LDMIA   R14,{R3,R4,R5,R6}
        STMIA   R2,{R3,R4,R5,R6}        ; take a copy of the scaling block
      ]
      ]

;
; calculate values + an OS unit for correct tessalation.
;
45      LDR     R0,title_height
        LDR     R1,dy
        ADD     R0,R0,R1
        STR     R0,title_height1        ; title_height1 = dy + title_height
;
        LDR     R0,hscroll_height
        ADD     R0,R0,R1
        STR     R0,hscroll_height1      ; hscroll_height1 = dx + hscroll_height
;
        LDR     R1,dx
        LDR     R0,vscroll_width
        ADD     R0,R0,R1
        STR     R0,vscroll_width1       ; vscroll_width1 = dx + vscroll_width
;
; now work out the information needed for the scroll bars.
;
        LDR     R0,left_width
        LDR     R1,xypixelsize
        ADD     R14,R0,R1,LSL #1
        STRB    R14,scroll_mxborder     ; gap at start of a horizontal scroll bar
;
        LDR     R0,up_height
        ADD     R14,R0,R1,LSL #1
        STRB    R14,scroll_myborder     ; gap at start of vertical scroll bar
;
        MOV     R14,R1,LSL #1
        STRB    R14,scroll_endmargin    ; border at end of scroll bars
;
 [ True
;        ADD     R14,R1,R1,LSL #4
        ADD     R14,R1,#32              ; 32 os units for scrollbar
 |
        ADD     R14,R1,R1,LSL #1
 ]
        STRB    R14,scroll_minlength    ; when min length gets imposed
;
        LDRB    R1,scroll_endmargin
        ADD     R14,R14,R1,LSL #1
        STRB    R14,scroll_minxbar
        STRB    R14,scroll_minybar      ; min length of scroll bars
;
        MOV     R14,#8                  ; this one is constant = defines distance of non-changing borders
        STRB    R14,scroll_sidemargin
;
        EXITS
        LTORG

;..............................................................................
; cachetoolspriteaddress
;
; [spritename], [thisCBptr], [lengthflags] as for cachespriteaddress
; in:  R4 -> resolution suffix                                               
;      R10 = first suffix tried (and failed)
; out: R2 -> sprite

cachetoolspriteaddress
        Push    "R14"
        MOV     R14,#&FF
        AND     R5,R14,R10
        AND     R6,R14,R10,LSR #8
        SUBS    R5,R5,#'0'
        SUB     R6,R6,#'0'
        MOVEQ   R5,#2
        MOVEQ   R6,#8                   ; pretend '0' was '28' so we try '24' next
        TEQ     R6,#3
        MOVEQ   R6,#4                   ; pretend '23' was '24' so we try '22' next

05      CMP     R5,R6
        MOVLO   R5,R5,LSL#1
        MOVHI   R6,R6,LSL#1
        BNE     %FT06                   ; after rectangular pixels, try next squarer version

        TEQ     R5,#1
        MOVEQ   R5,#2
        MOVEQ   R6,#2                   ; after '11', try '22'
        MOVNE   R5,#-'0'                ; after any other square pixels, try without suffix

06      ADD     R14,R5,#'0'
        STRB    R14,[R4]
        ADD     R14,R6,#'0'
        STRB    R14,[R4,#1]
        BL      cachespriteaddress
        Pull    "PC", VC                ; success
        TEQ     R5,#0
        BPL     %BT05                   ; try next suffix
        Pull    "PC"                    ; total failure, exit with V set

;..............................................................................

; defaultparams - modify the default parameters ready for further calculations

; in    R0 = vertical size to be stored
;       R1 = horizontal size to be stored
; out   -

default_params
        STR     R0,title_height         ; height based parameters
        STR     R0,up_height
        STR     R0,down_height
        STR     R0,hscroll_height
;
        STR     R1,vscroll_width        ; width based paramaters
        STR     R1,back_width
        STR     R1,close_width
      [ IconiseButton
        STR     R1,iconise_width
      ]
        STR     R1,left_width
        STR     R1,right_width
;
        MOV     R0,#0
        STR     R0,title_sectionwidth   ; reset constants for the title bar
        STR     R0,title_left
        STR     R0,title_right
        STR     R0,title_topheight
        STR     R0,title_bottomheight
;
        STR     R0,vscroll_top          ; and vscroll
        STR     R0,vscroll_topfill
        STR     R0,vscroll_blobtop
        STR     R0,vscroll_blobfill
        STR     R0,vscroll_blobbottom
        STR     R0,vscroll_bottomfill
        STR     R0,vscroll_bottom
;
        STR     R0,hscroll_left         ; finally the hscroll
        STR     R0,hscroll_leftfill
        STR     R0,hscroll_blobleft
        STR     R0,hscroll_blob
        STR     R0,hscroll_blobright
        STR     R0,hscroll_rightfill
        STR     R0,hscroll_right
;
      [ hvblip
        STR     R0,hscroll_blipwidth
        STR     R0,vscroll_blipheight
      ]

        MOV     PC,LR

  [ ToolTables
;;-----------------------------------------------------------------------------
;; make an active set of translation tables from the master set for this mode
;;
;; in    [ttt_masterset] have master tables, at least 'table_2' must exist
;; out   [ttt_activeset] updated
;;       V set R0 -> error, else corrupt
;;------------------------------------------------------------------------------

mastertoactive ROUT
        Push    "R1-R8,LR"
        ADRL    R6,ttt_masterset
        MOV     R1,#0
        MOV     R0,#15
05
        LDR     R14,[R6,R0,LSL #2]
        TEQ     R14,#0
        ADDNE   R1,R1,#1
        SUBS    R0,R0,#1
        BPL     %BT05

        LDR     R5,log2bpp              ; bpp 0,1,2,3,4,5
        CMP     R5,#4
        MOVCC   R7,#256*1
        MOVEQ   R7,#256*2
        MOVHI   R7,#256*4               ; => bytes per table entry
        MUL     R3,R1,R7                ; => bytes for all the tables present

        LDRHI   R14,modeflags
        ASSERT  ModeFlag_DataFormatSub_RGB > 8
        ASSERT  ModeFlag_DataFormatSub_Alpha > 8
        ANDHI   R14,R14,#ModeFlag_DataFormatSub_RGB+ModeFlag_DataFormatSub_Alpha
        ORRHI   R5,R14,R5               ; force table creation for non-BGR 32bpp
        
        LDR     R2,ttt_activeset_at
        TEQ     R2,#0
        BEQ     %FT15                   ; none claimed yet

        CMP     R5,#5
        LDRNE   R14,ttt_activeset_size
        MOVEQ   R14,#0                  ; 32bpp BGR, no copies needed, force a free
        CMP     R14,R3
        BCS     %FT20                   ; big enough
10
        MOV     R14,#0
        STR     R14,ttt_activeset_at
        MOV     R0,#ModHandReason_Free
        BL      XROS_Module             ; too small, free old one
15
        CMP     R5,#5
        BEQ     %FT20                   ; 32bpp BGR, no copies needed, skip the claim
        MOV     R0,#ModHandReason_Claim
        STR     R3,ttt_activeset_size
        BL      XROS_Module
        Pull    "R1-R8,PC",VS
        STR     R2,ttt_activeset_at
20
        ADRL    R4,ttt_activeset
        MOV     R3,#15                  ; for each master table present, generate user table
25
        ; R1=colour number to convert (0-255)
        ; R2->base of storage for active set tables
        ; R3=wimp colour (0-15)
        ; R4->table of active set pointers
        ; R5=log2bpp
        ; R6->table of master pointers
        ; R7=size of 1 active set table in bytes
        ; R8->base of master table for this wimp colour
        LDR     R8,[R6,R3,LSL #2]
        CMP     R8,#0                   ; master table absent?
        CMPNE   R5,#5                   ; or 32bpp BGR mode?
        STREQ   R8,[R4,R3,LSL #2]
        BEQ     %FT35

        MOV     R1, #255
30
        LDR     R0,[R8,R1,LSL #2]
        MOV     R0,R0,ROR #24           ; xBGR->BGRx
        SWI     XColourTrans_ReturnColourNumber
        CMP     R5,#4                   ; 32bpp is 4B/entry, 16bpp is 2B/entry, others are 1
        STRCCB  R0,[R2,R1]
        ADDEQ   R14,R2,R1,LSL #1
        STREQB  R0,[R14,#0]
        MOVEQ   R0,R0,LSR #8
        STREQB  R0,[R14,#1]
        STRHI   R0,[R2,R1,LSL #2]
        SUBS    R1,R1,#1
        BPL     %BT30

        STR     R2,[R4,R3,LSL #2]       ; point at the table just made
        ADD     R2,R2,R7                ; move storage along
35
        SUBS    R3,R3,#1                ; next wimp colour
        BPL     %BT25

        CLRV
        Pull    "R1-R8,PC"

;;-----------------------------------------------------------------------------
;; colour match the tool to a standard colour
;;
;; in    R1 = &BBGGRR00 true colour (or 4 bit wimp colour when not TrueIcon3)
;; out   R7 -> translation table to use
;;------------------------------------------------------------------------------

colourmatchtool
        Push    "R2-R3,LR"
        ADRL    R3,ttt_activeset
        LDR     R7,[R3,#ttt_table2]     ; Presence of 'table_2' implies custom translations
        TEQ     R7,#0
        LDREQ   R7,tool_transtable      ; Use generic translation table
        Pull    "R2-R3,PC",EQ

        STR     R1,ttt_lastlookup       ; remember last request incase ColourTrans invalidates everything
    [ TrueIcon3
        BL      getpalpointer           ; R14 -> active 16 entry palette
        MOV     R2,#15
10
        LDR     R7,[R14,R2,LSL #2]
        TEQ     R1,R7
        BNE     %FT15
        LDR     R7,[R3,R2,LSL #2]
        TEQ     R7,#0
        Pull    "R2-R3,PC",NE           ; Is a standard colour & have a custom translation
15
        SUBS    R2,R2,#1
        BPL     %BT10

        LDRB    R2,tinted_tool          ; Non standard, or no table, maybe tint it?
        TEQ     R2,#0
        LDREQ   R7,[R3,#ttt_table2]     ; Not a tinting candidate, use 'table_2'
        Pull    "R2-R3,PC",EQ

        Push    "R0-R1"                 ; Make a temporary tinting table

      [ Medusa
        LDR     R1,log2bpp              ; bpp 0,1,2,3,4,5
        CMP     R1,#4
        MOVCC   R1,#256*1
        MOVEQ   R1,#256*2
        MOVHI   R1,#256*4               ; => bytes per table entry
      |
        MOV     R1,#256
      ]
        LDR     R2,tpixtable_at
        LDR     R3,tpixtable_size
        TEQ     R2,#0
        BEQ     %FT20
        CMP     R3,R1                   ; Is what's there already big enough?
        BCS     %FT25
        MOV     R0,#0
        STR     R0,tpixtable_at
        MOV     R0,#ModHandReason_Free
        BL      XROS_Module
20
        MOV     R3,R1
        MOV     R0,#ModHandReason_Claim
        BL      XROS_Module
        MOVVS   R7,#0                   ; Out of memory, and no tpixtable! Use nothing
        Pull    "R0-R3,PC",VS
25
        STR     R2,tpixtable_at
        STR     R2,tool_transtable
        STR     R3,tpixtable_size

        ADRL    R3,ttt_masterset
        LDR     R7,[R3,#ttt_table2]     ; Use master 'table_2' as basis

        MOV     R1,#255
        LDR     R3,log2bpp
        ; R1=colour number to convert (0-255)
        ; R2->base of tinted translation table
        ; R3=log2bpp
        ; R7->base of master table 2
30
        LDR     R0,[R7,R1,LSL #2]       ; solid (0) -> transparent (255)
        MOV     R0,R0,ROR #24           ; &AABBGGRR -> &BBGGRRAA
        BL      bgr0_to_y
        ORR     R0,R0,R0,LSL #8         ; &0000YYYY
        ORR     R0,R0,R0,LSL #16        ; &YYYYYYYY
        BL      tintfunc
        SWI     XColourTrans_ReturnColourNumber
      [ Medusa
        CMP     R3,#4                   ; 32bpp is 4B/entry, 16bpp is 2B/entry, others are 1
        STRCCB  R0,[R2,R1]
        ADDEQ   R14,R2,R1,LSL #1
        STREQB  R0,[R14,#0]
        MOVEQ   R0,R0,LSR #8
        STREQB  R0,[R14,#1]
        STRHI   R0,[R2,R1,LSL #2]
      |
        STRB    R0,[R2,R1]              ; No wide translation tables
      ]
        SUBS    R1,R1,#1
        BPL     %BT30

        MOV     R7,R2                   ; Use table just made
        Pull    "R0-R3,PC"
    |
        LDR     R7,[R3,R1,LSL #2]       ; Direct lookup wimp colour
        TEQ     R7,#0
        LDREQ   R7,[R3,#ttt_table2]     ; No specific table, use 'table_2'
        Pull    "R2-R3,PC"
    ]
  ]

;;-----------------------------------------------------------------------------
;; free the tool sprites list (if defined)
;;
;; in    [tool_list] -> list / =0 for undefined
;; out   [tool_list] = 0
;;------------------------------------------------------------------------------

freetoollist ROUT
        Push    "R0,R2,LR"

        [ false
; don't free the area as its size is constant, just mark as invalid.
        MOV     R0,#ModHandReason_Free
        LDR     R2,tool_list            ; -> tool list
        TEQ     R2,#0
        BLNE   XROS_Module              ; release it (ignorning errors)
        ]
;
        MOV     R2,#0
        STR     R2,tool_list            ; free the tool list
        CLRV
        Pull    "R0,R2,PC"


;;-----------------------------------------------------------------------------
;; Free the translation table associated with the tool plotting routines.
;;
;; in   [tpixtable_at] -> table / =0 for none
;; out  [tpixtable_at] = 0 (block released)
;;-----------------------------------------------------------------------------

freetooltrans ROUT

        MOV     R1,R14
;
        LDR     R2,tpixtable_at
        CMP     R2,#0                   ; has a table been defined yet?
        MOVNE   R0,#ModHandReason_Free
        BLNE   XROS_Module              ; if so then release - ignore errors
;
        MOV     R0,#0
        STR     R0,tpixtable_at
        STR     R0,tool_transtable
      [ ToolTables
        LDR     R2,ttt_activeset_at
        STR     R0,ttt_activeset_at
        CMP     R2,#0                   ; have translation tables been supplied in the tool sprites?
        MOVNE   R0,#ModHandReason_Free
        BLNE   XROS_Module
      ]
;
        CLRV
        MOV     PC,R1


;;-----------------------------------------------------------------------------
;; Set tools area, and do accompanying service call
;;
;; in   R1 = value to set tool_area to
;;-----------------------------------------------------------------------------

settoolarea Entry "R1-R2"
        STR     R1,tool_area
        MOV     R2,R1                   ; R2 -> new tool area
        LDR     R1,=Service_WimpToolSpritesChanged
        SWI     XOS_ServiceCall
        EXIT
        LTORG


;;-----------------------------------------------------------------------------
;; Free tools area, this attempts to free the tools area owned, even if none
;; is owned the areaCB is reset back to the default 16 byte block.
;;
;; in   [tool_area] -> tool area / =0 undefined
;;      [tool_list] -> tool list / =0 undefined
;; out  R0 corrupt!
;;      [tool_list] = 0
;;      [tool_area] = 0
;;      [tool_areaCB] = default for no sprite pool
;;-----------------------------------------------------------------------------

freetoolarea EntryS "R1-R4"

        Debug   tools,"Free tool areas =",#tool_list,#tool_area
;
        MOV     R0,#ModHandReason_Free
;
        LDR     R2,tool_area
        CMP     R2,#0                   ; is there a tools area already?
        BEQ     %FT01

        LDR     R14,ROMstart            ; it may have started life in ROM
        LDR     R4,ROMend
        CMP     R2,R14
        CMPHS   R4,R2

        BLLO    XROS_Module             ; attempt to free the buffer (ignore errors)
;
01      MOV     R1,#0
        BL      settoolarea             ; flag as being released
;
        BL      freetoollist            ; release the tool list (used for finding the sprites)
        BL      freetooltrans           ; release translation tables
;
        ADRL    R0,romsprites
        LDMIA   R0,{R1,R2,R3,R4}
        ADRL    R0,tool_areaCB
        STMIA   R0,{R1,R2,R3,R4}        ; setup default block header
;
        EXITS


;;-----------------------------------------------------------------------------
;; *ToolSprites [<fsp>]
;;
;; Attempt to load a new set of borders for the windows, this routine
;; attempt to locate the sprite file.  If its in ResourceFS then we bind directly
;; to it.
;;-----------------------------------------------------------------------------

ToolSprites_Code Entry "R0"

        LDR     wsptr,[R12]
;
        CMP     R1,#0                   ; any parameters specified, if not then back to old glyphs
        MOVEQ   R0,#0
        BL      int_toolsprites         ; otherwise load a different set of the doofers
        BLVC    maketoollist            ; setup the tool list
;
        STRVS   R0,[SP]
        EXIT

;..............................................................................

; load the specified sprite file as a set of window borders.

; in    R0 -> filename to be opened / =0 for default
; out   sprites loaded / link setup

int_toolsprites Entry "R1-R6"

        MOVS    R1,R0                   ; if null then use default tools
        ADREQ   R1,default_tools
;
        DebugS  tools,"ToolSprites =",R1
;
        MOV     R0,#OSFind_ReadFile
        SWI     XOS_Find                ; open the file
        EXIT    VS
;
        MOV     R5,R0                   ; R5 = handle
;
        MOV     R0,#OSArgs_ReadEXT
        MOV     R1,R5
        SWI     XOS_Args                ; get the size of the file
        MOVVC   R6,R2                   ; keep the size somewhere safe
;
        MOVVC   R0,#FSControl_ReadFSHandle
        MOVVC   R1,R5
        SWIVC   XOS_FSControl           ; get the FS handle (ie. its address)
        BVS     %FT90                   ; close the file - reporting the error
;
        Debug   tools,"Handle, Size, FSHandle, FSInfo =",R5,R6,R1,R2
;
        AND     R2,R2,#&FF              ; extract the filing system handle
        TEQ     R2,#fsnumber_resourcefs
        BNE     %FT10                   ; not a ResourceFS so read into memory
;
; R1 -> files memory address (must be accessable)
; R5 = file handle
; R6 = size of the file
;
        Debug   tools,"Binding to ResourceFS block"
05
        BL      freetoolarea            ; release the existing area
        BL      settoolarea             ; -> tools in ResourcesFS
;
        ADD     R6,R6,#4
        LDMIA   R1!,{R7-R9}             ; get the next set of bytes
;
        ADD     R6,R6,#4
        ADRL    R0,tool_areaCB
        SUB     R8,R1,R0                ; offset to first sprite (CB +8)
        SUB     R14,R6,#16
        ADD     R9,R8,R14               ; offset to free area (CB +12)
;
        Debug   tools,"Area size, Count, First, Last, Real =",R6,R7,R8,R9,R1
        Debug   tools,"tool_areaCB =>",R0
;
        ASSERT  SpriteAreaCBsize = 4*4
        STMIA   R0,{R6-R9}              ; store control block
        B       %FT90                   ; and then close up shop

; handle loading the tools from RMA, this involves claiming a suitable
; block and then loading into it.

10      MOV     R0,#ModHandReason_Claim
        MOV     R3,R6
        BL     XROS_Module
        BVS     %FT90                   ; if the claim failed then return
;
        Debug   tools,"RMA buffer at =",R2
;
        Push    "R2"
        MOV     R0,#OSGBPB_ReadFromGiven
        MOV     R1,R5
        MOV     R4,#0
        SWI     XOS_GBPB                ; read from the given block into memory
        Pull    "R2"
;
        MOVVC   R1,R2
        BVC     %BT05                   ; attempt to allocate the area if it worked
;
        DebugE  tools,"Cannot load into the RMA"
;
        SavePSR R14
        Push    "R0,R14"
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module              ; free up the temporary block
        Pull    "R0,R14"
        RestPSR R14,,f                  ; restore flags
90
        SavePSR R14
        Push    "R0,R14"
        MOV     R0,#0
        MOV     R1,R5
        SWI     XOS_Find                ; attempt to close the file
        Pull    "R0,R14"
        RestPSR R14,,f                  ; restoring the flags word
;
        EXIT

default_tools
        = "WindowManager:Tools",0
        ALIGN


;;-----------------------------------------------------------------------------
;; Handle the modification of a tool icon, this includes clicks and releases.
;;
;; If select/adjust have been released then attempt to de-select the tool
;; icon - if defined, otherwise attempt to highlight it.
;;
;; in   R0,R1 = mouse co-ordinates
;;      R2 = button state
;;      R4 = icon handle
;;      R6 = button attributes
;;      R7 = mouse flag
;;      R8 = old button state
;;      handle = window handle
;;      [border_iconselected] = tool handle (if applicable)
;;      [border_windowselected] = window handle of tool window
;; out  [border_iconselected] / [border_windowselected] can be modified
;;-----------------------------------------------------------------------------

modifytool

        TST     R2,#button_left+button_right
        BEQ     modifytool_release      ; if either of the buttons released then tidy

        ; flow down into handling clicked on icons

;..............................................................................

; handle the selection of a tool, first check to see if there is a suitable
; sprite for highlighting the icon, otherwise ignore it.

modifytool_clicked

        Entry   "R0,R1,x0-y1,cx0-cy1"

        LDR     R14,border_iconselected
        TEQ     R14,R4
        LDREQ   R14,border_windowselected
        TEQEQ   R14,handle              ; check for auto-repeat gadgets (avoids flicker!)
        EXIT    EQ

; Release any pressed gadget in case ptr moves off of it

        LDR     R14, border_iconselected
        CMP     R14, #nullptr           ; Anything pressed?
        BLNE    modifytool_release      ; Yes then release the gadget

        CMP     R4 ,#windowicon_back    ; Window border gadget selected?
        EXIT    GT                      ; No then ignore it

; Only press gadgets on select/adjust leading edge

        EOR     R14, R8, R2             ; find changed buttons
        AND     R14, R14, R2            ; find pressed buttons
        TST     R14,#button_left+button_right
        EXIT    EQ                      ; if not start of press then ignore

      [ PushBothBars
        Push    "R14"
      ]
; Unslab any slabbed-in action button
        Push    "R0-R2,handle"
        LDR     handle, border_windowselected
        CMP     handle, #nullptr
        BEQ     %FT01
        LDR     R0, border_iconselected
        CMP     R0, #nullptr
        BLE     %FT01
        MOV     R1, #0
        MOV     R2, #is_inverted
        BL      int_set_icon_state
        MOV     R0, #nullptr
        STR     R0, border_windowselected
        STR     R0, border_iconselected
01
        Pull    "R0-R2,handle"

        ADRL    R2,glyphs_selected
        LDRB    R2,[R2,R4]
        TEQ     R2,#0                   ; is it possible for this glyph to have an alternate state?
      [ PushBothBars
        ADDEQ   sp, sp, #4*1
      ]
        EXIT    EQ                      ; nope, so return
        LDR     R3,tool_list
        TEQ     R3,#0                   ; is there a glyph list?
        BNE     %FT05
        Push    "R2"                    ; R2 corrupted :-(
        BL      restore_tool_list       ; if not, try to get one again
        Pull    "R2"
        LDR     R3,tool_list
        TEQ     R3,#0
05      LDRNE   R3,[R3,R2]
        TEQNE   R3,#0                   ; does the glyph have a second state cached?
      [ PushBothBars
        ADDEQ   sp, sp, #4*1
      ]
        EXIT    EQ                      ; return 'cos not allowed to toggle the state
;
; scroll bars are a special case - so handle seperately
;
      [ PushBothBars
        Pull    "R14"                   ; check to see if an adjust click on a scrollbar
        AND     R14, R14, #button_right
        CMP     R4, #windowicon_verticalbar
        CMPNE   R4, #windowicon_horizbar
        TEQEQ   R14, #button_right
        LDREQ   R14, [handle, #w_flags] ; but only for windows with two scrollbars!
        MVNEQ   R14, R14
        TSTEQ   R14, #wf_icon5 :OR: wf_icon7
      ]
        Debug   tools2,"Tool selected, handle =",R4,handle
;
      [ PushBothBars
        BEQ     modify_bothscroll
      ]
        CMP     R4,#windowicon_verticalbar
        BEQ     modify_vscroll
        CMP     R4,#windowicon_horizbar
        BEQ     modify_hscroll
10
        STR     R4,border_iconselected  ; flag as this icon / window selected
        STR     handle,border_windowselected
        BL      invalidate_glyph        ; ensure it gets redrawn
;
        EXIT

;..............................................................................

; cope with checking thepointer position in relation to the blob area on
; a scroll bar.

      [ PushBothBars
modify_bothscroll
        CMP     R4, #windowicon_horizbar
        BEQ     %FT01

        BL      getvscrollcoords
        Debug   tools2,"v scroll? x,y, x0,cy0,x1,cy1 =>",R0,R1,x0,cy0,x1,cy1
;
        CMP     R0,x1                   ; is it within the scroll blob?
        CMPLT   R1,cy1
        CMPLT   x0,R0
        CMPLT   cy0,R1
        EXIT    GE                      ; if not then return now
;
        Debug   tools2,"hit v scroll!"
        B       %FT02
01
        BL      gethscrollcoords
        Debug   tools2,"h scroll? x,y, x0,cy0,x1,cy1 =>",R0,R1,x0,cy0,x1,cy1
;
        CMP     R0,cx1                  ; is it within the scroll blob?
        CMPLT   R1,y1
        CMPLT   cx0,R0
        CMPLT   y0,R1
        EXIT    GE                      ; no so give up on this object
;
        Debug   tools2,"hit h scroll!"
02
        MOV     R4, #windowicon_bothbars
        STR     R4, border_iconselected
        STR     handle, border_windowselected
        MOV     R4, #windowicon_verticalbar
        BL      invalidate_glyph
        MOV     R4, #windowicon_horizbar
        BL      invalidate_glyph
        EXIT
      ]

modify_vscroll

        BL      getvscrollcoords
        Debug   tools2,"v scroll? x,y, x0,cy0,x1,cy1 =>",R0,R1,x0,cy0,x1,cy1
;
        CMP     R0,x1                   ; is it within the scroll blob?
        CMPLT   R1,cy1
        CMPLT   x0,R0
        CMPLT   cy0,R1
        EXIT    GE                      ; if not then return now
;
        Debug   tools2,"hit v scroll!"

        MOV     R4,#windowicon_verticalbar
        B       %BT10


modify_hscroll

        BL      gethscrollcoords
        Debug   tools2,"h scroll? x,y, x0,cy0,x1,cy1 =>",R0,R1,x0,cy0,x1,cy1
;
        CMP     R0,cx1                  ; is it within the scroll blob?
        CMPLT   R1,y1
        CMPLT   cx0,R0
        CMPLT   y0,R1
        EXIT    GE                      ; no so give up on this object
;
        Debug   tools2,"hit h scroll!"

        MOV     R4,#windowicon_horizbar
        B       %BT10

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; the buttons have been released so check to see if we need to redraw any of
; the window tools, ie. was the previously selected tool one of ours.

modifytool_release Entry "R4,handle"

        LDR     handle,border_windowselected
        CMP     handle,#nullptr
        EXIT    EQ
;
        LDR     R4,border_iconselected
        CMP     R4,#windowicon_back
        EXIT    GT                      ; exit if not the correct sort of icon
;
        MOV     R0,#nullptr             ; flag as no icon currently selected
        STR     R0,border_iconselected
        STR     R0,border_windowselected
;
      [ PushBothBars
        CMP     R4, #windowicon_bothbars
        MOVEQ   R4, #windowicon_verticalbar
        BLEQ    invalidate_glyph        ; preserves flags
        MOVEQ   R4, #windowicon_horizbar
      ]
        BL      invalidate_glyph        ; ensure returned back to its original state

        MOV     R4, #0
        STRB    R4, autorepeating       ; BJGA bugfix - deactivate autorepeat redraw optimisation
;
        EXIT


;;-----------------------------------------------------------------------------
;; Mark a window gadget invalid - redrawn at next opertunity.
;;
;; in   R4 = glyph handle
;;      handle = window handle
;; out  -
;;-----------------------------------------------------------------------------

invalidate_glyph EntryS "R0-R9"

        Debug   tools2,"invalidate glyph called =",R4,handle
;
        ADR     R0,iconposn_table
        LDRB    R0,[R0,R4]              ; get the value for icon posn
        BL      calc_w_iconposn         ; mark bounding box for icon invalid
        BL      checkredrawhandle
        BL      visibleportion_x0y0x1y1
      [ false
        BL      markinvalidrects
        BL      losewindowrects
      |
        ; Actually, lets do this immediately
        BL      int_redraw_window
invglp  EXIT    VS
        TEQ     R0,#0
        EXITS   EQ
        BL      int_get_rectangle
        B       invglp
      ]
;
        EXITS

; table to convert -ve icon handle to posn values

        [ IconiseButton
        = iconposn_iconise
        ]
        = 0
        = iconposn_hscroll
        = iconposn_hscroll
        = iconposn_hscroll
        = iconposn_resize
        = iconposn_vscroll
        = iconposn_vscroll
        = iconposn_vscroll
        = iconposn_toggle
        = iconposn_title
        = iconposn_close
        = iconposn_back
        = 0
iconposn_table

        ALIGN


;;------------------------------------------------------------------------------
;; Glyph tables, used for highlighting icons - deciding if highlightable.
;;------------------------------------------------------------------------------

        [ IconiseButton
        = tool_iconise
        ]
        = 0                             ; outer frame!
        = tool_right
        = 0                             ; horizontal scroll bar
        = tool_left
        = tool_size
        = tool_down
        = 0                             ; vertical scroll bar
        = tool_up
        = 0                             ; toggle is a special case
        = 0                             ; title bar
        = tool_close
        = tool_back
        = 0                             ; work area
glyphs_normal

        [ IconiseButton
        = tool_piconise
        ]
        = 0                             ; outer frame - special case
        = tool_pright
        = tool_phbarl
        = tool_pleft
        = tool_psize
        = tool_pdown
        = tool_pvbart
        = tool_pup
        = tool_ptoggle                  ; value not used, but non-0 to indicate highlightable
        = tool_ptbarlcap
        = tool_pclose
        = tool_pback
        = 0                             ; work area
glyphs_selected

        ALIGN


;;-----------------------------------------------------------------------------
;; Handle plotting a window gadget - given its icon handle plot it, if the
;; gadget is highlighted then the glyph is plotted differently, it assumes
;; there is an alternate state otherwise the flags would not indicate
;; the new bits.
;;
;; in   R2 = icon handle
;;      handle = window handle
;;      x0-y0 => region to plot the glyph into
;; out  EQ/NE if not plotted / plotted
;;-----------------------------------------------------------------------------

plot_windowglyph Entry "R0-R9"

        Debug   tools2,"plot_windowglyph: type, x0,y0,x1,y1 =>",R2,x0,y0,x1,y1
;
        Debug   tools2,"Clip =",#clipx0,#clipy0,#clipx1,#clipy1
;
        ADR     R14,clipx0
        LDMIA   R14,{R0,R1,R3,r4}
        CMP     x0,R3
        CMPLT   y0,R4
        CMPLT   R0,x1
        CMPLT   R1,y1
        BGE     plot_plotted            ; if outside the region then return
;
        LDR     R14,border_iconselected
        TEQ     R14,R2
        LDREQ   R14,border_windowselected
        TEQEQ   R14,handle              ; is it me or somebody else?
        ADREQL  R14,glyphs_selected
        ADRNEL  R14,glyphs_normal       ; -> selection table for the glyph
        LDRB    R14,[R14,R2]            ; = offset into tool list block

        LDR     R2,tool_list
        TEQ     R2,#0                   ; Tool list present?
        LDRNE   R2,[R2,R14]             ; = address of sprite to be plotted
        TEQNE   R2,#0
      [ debugtools
        BNE     %FT00
        Debug   tools2,"No toolsprite type", R2
00
      ]
        EXIT    EQ                      ; if not defined then return - do via VDU 5
;
; Allow toolsprites to be transparent (to show the colour through, if required)
;
        TST     R2,#1
        BLNE    solidrectangle          ; corrupts flags :-(
        TST     R2,#1
        BLNE    hollowrectangle        ; suitable rectangles
;
        MOV     R3,x0
        MOV     R4,y0                   ; x,y co-ordinates to plot at
;
        ADRL    R0,tool_plotparams
        LDMIA   R0,{R0,R5,R6,R7}        ; parameters to plot using
    [ ToolTables
      [ TrueIcon3
        LDR     R1,truetitlecolour
      |
        LDRB    R1,titlecolour
      ]
        BL      colourmatchtool
    ]
        Debug   tools2,"SpriteOp =",R0,R1,R2,R3,R4,R5
        BL      Tool_SpriteOp

plot_plotted
        CMP     PC,#0                   ; ensure returns NE!
        EXIT                            ; return indicating it was plotted


;;-----------------------------------------------------------------------------
;; Plot a scaled window gadget - for up and down arrows when scrollbar gets small
;; This routine frigs the tool_plotparams, and then restores them
;; in   R2 = icon handle
;;      R0 = height of original object
;;      handle = window handle
;;      x0,y0,x1,y1 => region to plot the glyph into
;; out  EQ/NE if not plotted / plotted
;;-----------------------------------------------------------------------------

      [ ChildWindows

plot_windowglyph_vscaled  Entry "R0,R1,cx0,cy0,cx1,cy1,y0,y1"

        ADD     R0,R0,#2                        ; urg - stored heights are all 1 pixel too small (assume toolsprite at 2x2 os/pix)

        ; frig scale factors so we can plot the thing scaled

        ADRL    R1,tool_scalingblk
        LDMIA   R1,{cx0,cy0,cx1,cy1}

        SUB     R14,y1,y0
        MUL     cy0,R14,cy0
        MUL     cy1,R0,cy1

        Push    "cx0,cy0,cx1,cy1"
        MOV     R1,SP                           ; R1 -> new scaling block (on stack)

        LDR     R2,tool_plotparams + 0          ; sprite reason code
        LDR     R3,tool_plotparams + 8          ; pointer to factors
        Push    "R2,R3"

        BIC     R2,R2,#&FF
        ORR     R2,R2,#SpriteReason_PutSpriteScaled
        STR     R2,tool_plotparams + 0
        STR     R1,tool_plotparams + 8          ; must have to scale it for this call

        ASSERT  R2 = cx0
        LDR     R2,[SP,#8*4]                    ; restore R2 from stacked cx0 on entry
        MOV     R1,R2                           ; for plot_windowglyph_clipped (later)
        BL      plot_windowglyph

        Pull    "R2,R3"
        STR     R2,tool_plotparams + 0          ; sprite reason code
        STR     R3,tool_plotparams + 8          ; pointer to factors

        ADD     SP,SP,#4*4                      ; correct stack

        ; now we must explicitly plot the top and bottom row, to avoid dropouts
        ; this involves messing with the clipping region (urg)

        Push    "x0,y0,x1,y1"
        Pull    "cx0,cy0,cx1,cy1"               ; copy x0,y0,x1,y1 to cx0,cy0,cx1,cy1 (for clip window)

        LDR     R14,dy
        Push    "y1,R14"

        ADD     cy1,cy0,R14
        ADD     y1,y0,R0
        BL      plot_windowglyph_clipped        ; plot bottom pixel row

        Pull    "y1,R14"

        MOV     cy1,y1
        SUB     cy0,cy1,R14
        SUB     y0,y1,R0
        BL      plot_windowglyph_clipped        ; plot top pixel row

        EXIT                                    ; flags on exit are as from plot_windowglyph
      ]


;;-----------------------------------------------------------------------------
;; Plot a scaled window gadget - for up and down arrows when scrollbar gets small
;; This routine frigs the tool_plotparams, and then restores them
;; in   R2 = icon handle
;;      R0 = height of original object
;;      handle = window handle
;;      x0,y0,x1,y1 => region to plot the glyph into
;; out  EQ/NE if not plotted / plotted
;;-----------------------------------------------------------------------------

      [ ChildWindows

plot_windowglyph_hscaled  Entry "R0,R1,cx0,cy0,cx1,cy1,x0,x1"

        ADD     R0,R0,#2                        ; urg - stored widths are all 1 pixel too small (assume toolsprite at 2x2 os/pix)

        ADRL    R1,tool_scalingblk
        LDMIA   R1,{cx0,cy0,cx1,cy1}

        SUB     R14,x1,x0
        MUL     cx0,R14,cx0
        MUL     cx1,R0,cx1

        Push    "cx0,cy0,cx1,cy1"
        MOV     R1,SP                           ; R1 -> new factors on stack

        LDR     R2,tool_plotparams + 0          ; sprite reason code
        LDR     R3,tool_plotparams + 8          ; pointer to factors
        Push    "R2,R3"

        BIC     R2,R2,#&FF
        ORR     R2,R2,#SpriteReason_PutSpriteScaled
        STR     R2,tool_plotparams + 0
        STR     R1,tool_plotparams + 8          ; must have to scale it for this call

        ASSERT  R2 = cx0
        LDR     R2,[SP,#8*4]                    ; restore R2 from stacked cx0 on entry
        MOV     R1,R2                           ; for plot_windowglyph_clipped (later)
        BL      plot_windowglyph

        Pull    "R2,R3"
        STR     R2,tool_plotparams + 0          ; sprite reason code
        STR     R3,tool_plotparams + 8          ; pointer to factors

        ADD     SP,SP,#4*4                      ; correct stack

        ; now we must explicitly plot the top and bottom row, to avoid dropouts
        ; this involves messing with the clipping region (urg)

        Push    "x0,y0,x1,y1"
        Pull    "cx0,cy0,cx1,cy1"               ; copy x0,y0,x1,y1 to cx0,cy0,cx1,cy1 (for clip window)

        LDR     R14,dx
        Push    "x1,R14"

        ADD     cx1,cx0,R14
        ADD     x1,x0,R0
        BL      plot_windowglyph_clipped        ; plot left-hand pixel row

        Pull    "x1,R14"

        MOV     cx1,x1
        SUB     cx0,cx1,R14
        SUB     x0,x1,R0
        BL      plot_windowglyph_clipped        ; plot right-hand pixel row

        EXIT                                    ; flags on exit are as from plot_windowglyph
      ]


;;-----------------------------------------------------------------------------
;; Plot a clipped window gadget - for getting the end pixels correct
;; in   R1 = icon handle
;;      x0,y0 = coordinate to plot at (bottom-left)
;;      cx0,cy0,cx1,cy1 = desired clip rectangle (will be further clipped)
;;      handle = window handle
;; out  flags preserved
;;-----------------------------------------------------------------------------

      [ ChildWindows

plot_windowglyph_clipped  EntryS "R0,R1,cx0,cy0,cx1,cy1,x0,y0,x1,y1"

        ADR     R14,clipx0
        LDMIA   R14,{x0,y0,x1,y1}

        Push    "x0,y0,x1,y1"

        max     x0,cx0
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1

        CMP     x0,x1
        CMPLT   y0,y1
        ADDGE   SP,SP,#4*4
        EXITS   GE                              ; forget it if this is a null clip window

        BL      graphicswindow                  ; set to x0,y0,x1,y1

        ADD     R14,SP,#Proc_RegOffset+10*4
        LDMIA   R14,{x0,y0,x1,y1}               ; recover original x0,y0,x1,y1

        MOVVC   R2,R1
        BLVC    plot_windowglyph

        Pull    "x0,y0,x1,y1"
        BL      graphicswindow                  ; restore graphics window

        EXITS
      ]


;;-----------------------------------------------------------------------------
;; Plot a gadget using the tools cached pixtrans information.
;;
;; in   R2 -> sprite to be plotted (assumed to be valid)
;;      x0-y1 contain the bounding box for the icon
;; out  all preserved - including PSR
;;-----------------------------------------------------------------------------

draw_spriteglyph EntryS "R0-R7"

        ADR     R0,clipx0
        LDMIA   R0,{R0,R1,R3,r4}
        CMP     x0,R3
        CMPLT   y0,R4
        CMPLT   R0,x1
        CMPLT   R1,y1
        EXITS   GE                      ; ignore if not plottable
;
      [ TrueIcon3
        TST     R2, #1
        BLNE    solidrectangle          ; corrupts flags :-(
        TST     R2, #1
        BLNE    hollowrectangle         ; plot the borders of the gadget
      |
        BL      solidrectangle
        BL      hollowrectangle         ; plot the borders of the gadget
      ]
;
        MOV     R3,x0
        MOV     R4,y0                   ; x,y co-ordinates to plot at
;
        ADRL    R0,tool_plotparams
        LDMIA   R0,{R0,R5,R6,R7}        ; get the tool information
    [ ToolTables
      [ TrueIcon3
        LDR     R1,truetitlecolour
      |
        LDRB    R1,titlecolour
      ]
        BL      colourmatchtool
    ]
        BL      Tool_SpriteOp
;
        EXITS


;;-----------------------------------------------------------------------------
;; plot title bar - sprite, plot the title bar, using the sprites as required
;;
;; in   R3 = window flags
;;      R4 -> sprite pool information
;;      clipX0-Y1 = current clip region
;;      x0-y1 = bounding box of title bar
;;      handle -> window defn (must be valid!)
;; out  -
;;-----------------------------------------------------------------------------

dofunkytitlebar EntryS "R0-R11"

        Debug   tools2,"into 'dofunkytitlebar'",x0,y0,x1,y1
;
        ADR     cx0,clipx0
        LDMIA   cx0,{cx0,cy0,cx1,cy1}   ; get the clip region
        CMP     x0,cx1
        CMPLT   y0,cy1
        CMPLT   cx0,x1
        CMPLT   cy0,y1                  ; do we need to plot our bits?
        EXITS   GE
;
        ADR     R14,oldclipx0
        STMIA   R14,{cx0,cy0,cx1,cy1}   ; push old clip region away
;
        Push    "x0-y1"
        max     x0,cx0
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1                  ; get the bounding box - clipped
        BL      graphicswindow          ; and then apply it
        Pull    "x0-y1"
;
        [       {FALSE} ;calculated by entry code now
        LDR     R1,[handle,#w_titleflags]
        ORR     R1,R1,#if_border:OR:if_filled
        LDREQB  R2,fontforeground
        ORREQ   R1,R1,R2,LSL #ib_fcol
        LDREQB  R2,fontbackground
        ORREQ   R1,R1,R2,LSL #ib_bcol
        ]
        ADD     R2,handle,#w_title
        Push    "R1"                    ; push the flags for use later on
;
      [ TrueIcon3
      [ true
        Push    "R0"
        LDR     R0, title_topheight
        LDR     R14, title_bottomheight
        ADD     R0, R0, R14
        ADD     R0, R0, #4              ; compensate for the fact that both topheight and bottomheight have been reduced by
                                        ; one sprite pixel (not even one screen pixel) - difficult to do properly at this stage
        LDR     R14, title_height
        CMP     R0, R14                 ; if there's a gap between tbatmidt and tbarmidb, we always need to fill in the background
        TEQGE   R0, R0                  ; if they overlapped, treat them as though they fitted perfectly, and check for mask
        Pull    "R0"
        LDREQ   R14, tool_list
        LDREQ   R14, [R14, #tool_tbarmidt]
        TSTEQ   R14, #1                 ; is title bar solid?
       |
        LDR     R14, tool_list
        LDR     R14, [R14, #tool_tbarmidt]
        TST     R14, #1                 ; is title bar solid?
      ]
        BICNE   R1,R1,#if_sprite:OR:if_text
        BLNE    drawicon_system         ; get the background / border plotted for the icon
      |
        BIC     R1,R1,#if_sprite:OR:if_text
        BL      drawicon_system         ; get the background / border plotted for the icon
      ]
;
        LDR     R2,dy
        SUB     y1,y1,R2
        LDR     R2,title_topheight
        SUB     y1,y1,R2                ; adjust to include the top height
;
        MOV     R3,x0
        MOV     R4,y0                   ; x,y co-ordinates to plot title sprites at
;
        ADRL    R0,tool_plotparams
        LDMIA   R0,{R0,R5,R6,R7}        ; R0,R5-R7 => sprite op information
    [ ToolTables
      [ TrueIcon3
        LDR     R1,truetitlecolour
      |
        LDRB    R1,titlecolour
      ]
        BL      colourmatchtool
    ]
        LDR     R1,tool_list            ; -> list of the glyphs
        Push    "R10,R11"               ; preserve these - they are important
;
; is it our window that is highlighted?
;
        LDR     R2,border_windowselected
        CMP     R2,handle
        LDREQ   R2,border_iconselected
        CMPEQ   R2,#windowicon_title    ; if its our window + the title bar then ... oh no!
        ASSERT  (tool_ptbarlcap-tool_tbarlcap) = (tool_ptbarmidb-tool_tbarmidb)
        ASSERT  (tool_ptbarlcap-tool_tbarlcap) = (tool_ptbarmidt-tool_tbarmidt)
        ASSERT  (tool_ptbarlcap-tool_tbarlcap) = (tool_ptbarrcap-tool_tbarrcap)
        ADDEQ   R1,R1,#tool_ptbarlcap-tool_tbarlcap
;
        LDR     R2, [R1,#tool_tbarlcap]
        LDR     R14,[R1,#tool_tbarrcap]
        ORRS    R2,R2,R14
        LDREQ   R14,[R1,#tool_tbarmidb]
        ORREQS  R2,R2,R14
        LDREQ   R14,[R1,#tool_tbarmidt]
        ORREQS  R2,R2,R14
        BEQ     %FT20                   ; none of the sprites exist, reduce flicker by not bothering

;
; prep the registers ready for advancing along the title bar - hut.. one.. two.. three.. four..
;
        LDR     R10,title_sectionwidth  ; width of the title bar sections
        LDR     R11,dx
        ADD     R10,R10,R11             ; including an extra pixel!
;
; title bar so attempt to plot the surround
;
        LDR     R2,[R1,#tool_tbarlcap]
        BL      Tool_SpriteOp
        LDR     R2,title_left           ; plot the left hand edge
        ADD     R3,R3,R2
        ADD     R3,R3,R11               ; and then advance ready for next section
10
        CMP     R3,x1                   ; have we finished yet?
        BGT     %FT15                   ; yes, so exit
;
        LDR     R2,[R1,#tool_tbarmidb]
        BL      Tool_SpriteOp            ; ... bottom
;
        Push    "R4"
        LDR     R2,[R1,#tool_tbarmidt]
        MOV     R4,y1
        BL      Tool_SpriteOp
        Pull    "R4"                    ; ... top
;
        ADD     R3,R3,R10
        B       %BT10
15
        LDR     R2,title_right
        SUB     R3,x1,R2
        SUB     R3,R3,R11               ; move back from right edge to plot right cap
        LDR     R2,[R1,#tool_tbarrcap]
        BL      Tool_SpriteOp
20
        Pull    "R10-R11"               ; all done so balance the stack
;
        ADR     x0,oldclipx0
        LDMIA   x0,{x0-y1}
        BL      graphicswindow          ; restore rectangle to original
;
        Pull    "R1"
;
        ADD     x0,sp,#Proc_RegOffset+sp_x0
        LDMIA   x0,{x0,y0,x1,y1}
;
      [ TrueIcon2 :LAND: :LNOT: TrueIcon3
        LDR     R2, [handle, #w_flags]
        TST     R2, #ws_hasfocus
        LDREQB  R2, [handle, #w_tbcol]
        LDRNEB  R2, [handle, #w_tbcol2]
        STRB    R2, work_back_colour    ; this is where mungetruecolours looks for font background if unfilled
      ]
        BIC     R1,R1,#if_border:OR:if_filled
        ADD     R2,handle,#w_title

; account for the caps at each end of title bar
        ADD     x0,x0,#4
        SUB     x1,x1,#4
        CMP     x0,x1
        MOVGT   x0,x1

        BL      drawicon_system         ; slap the text onto the title bar
;
        EXITS


;;-----------------------------------------------------------------------------
;; Plot funky scroll bars, these routines attempt to plot the current
;; scroll bars using sprites.  The sprites make up the entire scroll bar
;; with sections for the top bottom and middle blob.
;;
;; in   tools_at / R0 -> sprite list for gadgets (assume non-zero)
;;      x0-y1 => bounding box of outside scroll region
;;      cx0-cy1 => bounding box of inner scroll region (the blob)
;;      clipx0-clipy1 => defined clip region
;;      handle => window defn for the window being redrawn
;; out  -
;;-----------------------------------------------------------------------------


; frame description for finding scroll information from the stack

        ^ 4*2
sp_cx0  # 4                             ; stacked bounding box of total area
sp_cy0  # 4
sp_cx1  # 4
sp_cy1  # 4
sp_x0   # 4                             ; stacked bounding box of main area
sp_y0   # 4
sp_x1   # 4
sp_y1   # 4

sp_hand # 4                             ; = handle for window


;;-----------------------------------------------------------------------------
;; Plot the vertical scroll bar
;;-----------------------------------------------------------------------------

dofunkyvscroll EntryS "R0-R11"
;
        Debug   tools2,"into 'dofunkyvscroll'",x0,y0,x1,y1
        Debug   scroll,"dofunkyvscroll",x0,y0,x1,y1
;
        ADR     cx0,clipx0
        LDMIA   cx0,{cx0,cy0,cx1,cy1}   ; get the clip region
        CMP     x0,cx1
        CMPLT   y0,cy1
        CMPLT   cx0,x1
        CMPLT   cy0,y1                  ; do we need to plot our bits?
        EXITS   GE
;
        ADR     R14,oldclipx0
        STMIA   R14,{cx0,cy0,cx1,cy1}   ; push old clip region away
;
      [ :LNOT: TrueIcon3                ; don't think this is actually necessary
        BL      hollowrectangle         ; plot the border for the graphic
      ]
;
        max     x0,cx0
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1                  ; clip the two together
        ADRL    R14,tool_scrollclip
        STMIA   R14,{x0,y0,x1,y1}       ; push clip region for scroll bar

        Debug   scroll,"tool_scrollclip",x0,y0,x1,y1
;
        ADRL    R0,tool_plotparams
        LDMIA   R0,{R0,R5,R6,R7}        ; get the plotting parameters
    [ ToolTables
      [ TrueIcon3
        LDR     R1,truescoutcolour
      |
        LDRB    R1,[handle,#w_scouter]
      ]
        BL      colourmatchtool
    ]
;
        LDR     R1,dy                   ; single pixel at screen resolution
        LDR     R3,[sp,#Proc_RegOffset+sp_x0]
        LDR     R10,tool_list           ; -> tool sprite list
;
; plot the bottom section of the scroll bar
;
        LDR     R4,[sp,#Proc_RegOffset+sp_y0]
        LDR     R11,[sp,#Proc_RegOffset+sp_cy0]
        BL      set_vclip               ; define the clip region for this section
        BLE     %FT20

        LDR     R2,[R10,#tool_vwellbcap]
        BL      Tool_SpriteOp            ; Plot if unclipped
        LDR     R14,vscroll_bottom
        ADD     R4,R4,R14
        ADD     R4,R4,R1                ; plot the end of the block
        LDR     R2,[R10,#tool_vwellb]
        BL      set_vclip
        BLE     %FT20
        BL      Tool_SpriteOpTiled
  [ CanTileManually
        ; Plot manually if OS_SpriteOp 65 failed
        BVC     %FT20
10
        CMP     R4,R11
        BLLE    Tool_SpriteOp
        LDRLE   R14,vscroll_bottomfill
        ADDLE   R4,R4,R14
        ADDLE   R4,R4,R1
        BLE     %BT10                   ; fill in the top section
  ]
;
; now plot the top section of the scroll bar
;
20      LDR     R4,[sp,#Proc_RegOffset+sp_cy1]
        LDR     R11,[sp,#Proc_RegOffset+sp_y1]
        BL      set_vclip               ; set the clipping region
        BLE     %FT20                   ; Jump if not visible
;
        LDR     R2,[R10,#tool_vwelltcap]
        LDR     R4,[sp,#Proc_RegOffset+sp_y1]
        LDR     R14,vscroll_top
        SUB     R4,R4,R14
        SUB     R4,R4,R1
        BL      Tool_SpriteOp            ; plot the top shell
;
        LDR     R2,[R10,#tool_vwellt]
        MOV     R11,R4
        LDR     R4,[sp,#Proc_RegOffset+sp_cy1]
        BL      set_vclip
        BLE     %FT20
        MOV     R4,R11
        BL      Tool_SpriteOpTiled
  [ CanTileManually
        ; Plot manually if OS_SpriteOp 65 failed
        BVC     %FT20
        LDR     R11,[sp,#Proc_RegOffset+sp_cy1]
10
        CMP     R4,R11
        LDRGE   R14,vscroll_topfill
        SUBGE   R4,R4,R14
        SUBGE   R4,R4,R1
        BLGE    Tool_SpriteOp            ; plot a section
        BGE     %BT10                   ; loop back until all plotted
  ]
;
; plot the scroll sausage
;
20      LDR     R4,[sp,#Proc_RegOffset+sp_cy0]         ; min
        LDR     R11,[sp,#Proc_RegOffset+sp_cy1]        ; max
        BL      set_vclip               ; define the clip region
        BLE     %FT40                   ; Jump if all fixed
;
; now decide which routine to call to plot the sausage bits
;
        LDR     R2,[sp,#Proc_RegOffset+sp_hand]
    [ ToolTables
        Push    "R1"
      [ TrueIcon3
        LDR     R1,truescincolour
      |
        LDRB    R1,[R2,#w_scinner]
      ]
        BL      colourmatchtool
        Pull    "R1"
    ]
      [ PushBothBars
        LDR     R14, border_iconselected
        CMP     R14, #windowicon_verticalbar
        CMPNE   R14, #windowicon_bothbars
        LDREQ   R14, border_windowselected
        TEQEQ   R14, R2                 ; is it our window thats selected?
      |
        LDR     R14,border_windowselected
        TEQ     R14,R2                  ; is it our window thats selected?
        LDREQ   R14,border_iconselected
        CMPEQ   R14,#windowicon_verticalbar
      ]
        ASSERT  (tool_pvbarb-tool_vbarb) = (tool_pvbarmid-tool_vbarmid)
        ASSERT  (tool_pvbarb-tool_vbarb) = (tool_pvbart-tool_vbart)
      [ hvblip
        ASSERT  (tool_pvbarb-tool_vbarb) = (tool_pvblip-tool_vblip)
      ]
        ADDEQ   R10,R10,#tool_pvbarb-tool_vbarb

; now plot the scroll sausage bit in the middle

20      LDR     R2,[R10,#tool_vbarb]
        BL      Tool_SpriteOp
        LDR     R14,vscroll_blobbottom
        ADD     R4,R4,R14
        ADD     R4,R4,R1                ; base of the area
;
        LDR     R2,[R10,#tool_vbarmid]
        BL      set_vclip
        BLE     %FT20
        BL      Tool_SpriteOpTiled
  [ CanTileManually
        ; Plot manually if OS_SpriteOp 65 failed
        BVC     %FT20
10
        CMP     R4,R11
        BLLE    Tool_SpriteOp
        LDRLE   R14,vscroll_blobfill
        ADDLE   R4,R4,R14
        ADDLE   R4,R4,R1
        BLE     %BT10                   ; loop back until blob section plotted
  ]
;
20      LDR     R4,[sp,#Proc_RegOffset+sp_cy0]
        LDR     R11,[sp,#Proc_RegOffset+sp_cy1]
        BL      set_vclip               ; restore clip region
        LDR     R14,vscroll_blobtop
        SUB     R4,R11,R14
        SUB     R4,R4,R1
        LDR     R2,[R10,#tool_vbart]
        BL      Tool_SpriteOp            ; and put the end cap on
;
      [ hvblip
;
        LDR     R10,[R10,#tool_vblip]
        TEQ     R10,#0                  ; is there a vertical blip on this scroll bar?
        BEQ     %FT40
;
        LDR     R4,[sp,#Proc_RegOffset+sp_cy0]
        LDR     R2,vscroll_blobbottom
        ADD     R2,R2,R1
        ADD     R4,R4,R2                ; Y0 of the scroll bar blob section
;
        LDR     R14,[sp,#Proc_RegOffset+sp_cy1]
        LDR     R2,vscroll_blobtop
        ADD     R2,R2,R1
        SUB     R14,R14,R2              ; Y1 of the scroll blob section
;
        LDR     R2,vscroll_blipheight
        SUB     R14,R14,R4
        SUB     R14,R14,R2              ; total length that we can play with - blip height
;
        ADD     R4,R4,R14,ASR #1        ; work out actual co-ordinate to plot blip at (assuming bottom left)
        LDR     R2,dy_1                 ; then align to sensible boundaries
        ADD     R4,R4,R2
        BIC     R4,R4,R2
;
        MOV     R2,R10
        BL      Tool_SpriteOp            ; plot the blip at the correct position
      ]
40
        ADR     x0,oldclipx0
        LDMIA   x0,{x0,y0,x1,y1}
        BL      graphicswindow          ; restore the clip rectangle
;
        EXITS


;..............................................................................

; set vertical clip points (and region).

; in    R4 = min
;       R11 = max
; out
;       LE = all rectangle clipped
;       GT = rectangle ok to draw

set_vclip Entry "R0,R4,x0-y1,R11"

        Debug   scroll,"set_vclip: min, max",R4,R11

        ADRL    R0,tool_scrollclip
        LDMIA   R0,{x0-y1}              ; get the current bars clipping region
;
        max     y0,R4
        min     y1,R11                  ; adjust by the new values

        Debug   scroll,"set window",x0,y0,x1,y1

        BL      graphicswindow          ; adjust the graphics window

        CMP     y1,y0
        EXIT


;;------------------------------------------------------------------------------
;; Plot the horizontal scroll bar
;;------------------------------------------------------------------------------

dofunkyhscroll EntryS "R0-R11"
;
        Debug   tools2,"into 'dofunkyhscroll'",x0,y0,x1,y1
        Debug   scroll,"dofunkyhscroll",x0,y0,x1,y1
;
        ADR     cx0,clipx0
        LDMIA   cx0,{cx0,cy0,cx1,cy1}   ; get the clip region
        CMP     x0,cx1
        CMPLT   y0,cy1
        CMPLT   cx0,x1
        CMPLT   cy0,y1                  ; do we need to plot our bits?
        EXITS   GE
;
        ADR     R14,oldclipx0
        STMIA   R14,{cx0,cy0,cx1,cy1}   ; push old clip region away
;
      [ :LNOT: TrueIcon3                ; don't think this is actually necessary
        BL      hollowrectangle         ; plot the border for the graphic
      ]
;
        max     x0,cx0
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1                  ; clip the two together
        ADRL    R14,tool_scrollclip
        STMIA   R14,{x0,y0,x1,y1}       ; push clip region for scroll bar
;
        ADRL    R0,tool_plotparams
        LDMIA   R0,{R0,R5,R6,R7}        ; get the plotting parameters
    [ ToolTables
      [ TrueIcon3
        LDR     R1,truescoutcolour
      |
        LDRB    R1,[handle,#w_scouter]
      ]
        BL      colourmatchtool
    ]
;
        LDR     R1,dx                   ; single pixel at screen resolution
        LDR     R4,[sp,#Proc_RegOffset+sp_y0]
        LDR     R10,tool_list           ; -> tool sprite list
;
; plot the left hand side of the bar
;
        LDR     R3,[sp,#Proc_RegOffset+sp_x0]
        LDR     R11,[sp,#Proc_RegOffset+sp_cx0]
        BL      set_hclip               ; set the clip region for this section
        BLE     %FT15
;
        LDR     R2,[R10,#tool_hwelllcap]
        BL      Tool_SpriteOp
        LDR     R14,hscroll_left
        ADD     R3,R3,R14
        ADD     R3,R3,R1
;
        LDR     R2,[R10,#tool_hwelll]
        BL      set_hclip
        BLE     %FT15
        BL      Tool_SpriteOpTiled
  [ CanTileManually
        ; Plot manually if OS_SpriteOp 65 failed
        BVC     %FT15
10
        CMP     R3,R11                  ; have we finished plotting the blanking section
        BLLE    Tool_SpriteOp
        LDRLE   R14,hscroll_leftfill
        ADDLE   R3,R3,R14
        ADDLE   R3,R3,R1
        BLE     %BT10                   ; loop filling in the base area
  ]
;
; plot the right hand side of the bar
;
15      LDR     R3,[sp,#Proc_RegOffset+sp_cx1]
        LDR     R11,[sp,#Proc_RegOffset+sp_x1]
        BL      set_hclip               ; set the horizontal clip region
        BLE     %FT25
;
        LDR     R2,[R10,#tool_hwellrcap]
        LDR     R3,[sp,#Proc_RegOffset+sp_x1]
        LDR     R14,hscroll_right
        SUB     R3,R3,R14
        SUB     R3,R3,R1
        BL      Tool_SpriteOp            ; put the scroll blob
;
        LDR     R2,[R10,#tool_hwellr]
        MOV     R11,R3
        LDR     R3,[sp,#Proc_RegOffset+sp_cx1]
        BL      set_hclip
        BLE     %FT25
        MOV     R3,R11
        BL      Tool_SpriteOpTiled
  [ CanTileManually
        ; Plot manually if OS_SpriteOp 65 failed
        BVC     %FT25
        LDR     R11,[sp,#Proc_RegOffset+sp_cx1]
20      CMP     R3,R11
        LDRGE   R14,hscroll_rightfill
        SUBGE   R3,R3,R14
        SUBGE   R3,R3,R1
        BLGE    Tool_SpriteOp
        BGE     %BT20
  ]
;
; plot the scroll blob section
;
25      LDR     R3,[sp,#Proc_RegOffset+sp_cx0]         ; setup the region to plot the blob
        LDR     R11,[sp,#Proc_RegOffset+sp_cx1]
        BL      set_hclip
        BLE     %FT50
;
; first attempt to decide if the block is selected or not?
;
        LDR     R2,[sp,#Proc_RegOffset+sp_hand]
    [ ToolTables
        Push    "R1"
      [ TrueIcon3
        LDR     R1,truescincolour
      |
        LDRB    R1,[R2,#w_scinner]
      ]
        BL      colourmatchtool
        Pull    "R1"
    ]
      [ PushBothBars
        LDR     R14, border_iconselected
        CMP     R14, #windowicon_horizbar
        CMPNE   R14, #windowicon_bothbars
        LDREQ   R14, border_windowselected
        TEQEQ   R14, R2                 ; is it our window thats selected?
      |
        LDR     R14,border_windowselected
        CMP     R14,R2
        LDREQ   R14,border_iconselected
        CMPEQ   R14,#windowicon_horizbar
      ]
        ASSERT  (tool_phbarl-tool_hbarl) = (tool_phbarmid-tool_hbarmid)
        ASSERT  (tool_phbarl-tool_hbarl) = (tool_phbarr-tool_hbarr)
      [ hvblip
        ASSERT  (tool_phbarl-tool_hbarl) = (tool_phblip-tool_hblip)
      ]
        ADDEQ   R10,R10,#tool_phbarl-tool_hbarl

; handle plotting the horizontal scroll sausage

        LDR     R2,[R10,#tool_hbarl]

        Debug   scroll,"tool_phbarl",R2

        BL      Tool_SpriteOp
        LDR     R14,hscroll_blobleft
        ADD     R3,R3,R14
        ADD     R3,R3,R1
;
        LDR     R2,[R10,#tool_hbarmid]
        BL      set_hclip
        BLE     %FT40
        BL      Tool_SpriteOpTiled
  [ CanTileManually
        ; Plot manually if OS_SpriteOp 65 failed
        BVC     %FT40
38
        CMP     R3,R11
        BLLT    Tool_SpriteOp
        LDRLT   R14,hscroll_blob
        ADDLT   R3,R3,R14
        ADDLT   R3,R3,R1
        BLT     %BT38
  ]
;
40      LDR     R3,[sp,#Proc_RegOffset+sp_cx0]         ; setup the region to plot the blob
        LDR     R11,[sp,#Proc_RegOffset+sp_cx1]
        BL      set_hclip               ; restore clip region
        LDR     R2,[R10,#tool_hbarr]

        Debug   scroll,"tool_phbarr",R2

        LDR     R14,hscroll_blobright
        SUB     R3,R11,R14
        SUB     R3,R3,R1,LSR #1         ; Round
        BL      Tool_SpriteOp
;
      [ hvblip
;
        LDR     R10,[R10,#tool_hblip]
        TEQ     R10,#0                  ; is there a vertical blip on this scroll bar?
        BEQ     %FT50
;
        LDR     R3,[sp,#Proc_RegOffset+sp_cx0]
        LDR     R2,hscroll_blobleft
        SUB     R2,R2,R1
        ADD     R3,R3,R2                ; X0 of the scroll bar blob section
;
        LDR     R14,[sp,#Proc_RegOffset+sp_cx1]
        LDR     R2,hscroll_blobright
        SUB     R2,R2,R1
        SUB     R14,R14,R2              ; X1 of the scroll blob section
;
        LDR     R2,hscroll_blipwidth
        SUB     R14,R14,R3
        SUB     R14,R14,R2              ; total length that we can play with - blip width
;
        ADD     R3,R3,R14,ASR #1        ; work out actual co-ordinate to plot blip at (assuming bottom left)
        LDR     R2,dx_1                 ; then align to sensible boundaries
        SUB     R3,R3,R2
        BIC     R3,R3,R2
;
        MOV     R2,R10
        BL      Tool_SpriteOp            ; plot the blip at the correct position

      ]
50
        ADR     x0,oldclipx0
        LDMIA   x0,{x0,y0,x1,y1}
        BL      graphicswindow          ; restore the clip rectangle
;
        EXITS

;..............................................................................

; set the clip region between two horizontal points.

; in    R3 = start point
;       R11 = end point
; out
;       LE = all rectangle clipped
;       GT = rectangle ok to draw

set_hclip Entry "R0,R3,x0-y1,R11"

        ADRL    R0,tool_scrollclip
        LDMIA   R0,{x0-y1}              ; get the current bars clipping region
;
        max     x0,R3
        min     x1,R11                  ; adjust by the new values
        BL      graphicswindow          ; adjust the graphics window
;
        CMP     x1,x0
        EXIT


;;-----------------------------------------------------------------------------
;; Functions to handle the processing of fancy font text.  The new Window
;; Manager looks for the following system variables to describe which fonts
;; should be used:
;;
;;   Wimp$Font          = font name, including encoding, matrix
;;   Wimp$FontSize      = font size in (1/16)pt both horizontal and vertical
;;   Wimp$FontWidth     = font width, if required
;;
;; If we cannot find the font then we will attempt to revert back to VDU 5
;; handling, without reporting an error.
;;-----------------------------------------------------------------------------

      [ outlinefont

;;-----------------------------------------------------------------------------
;; Find the font and setup the font handle in our workspace.  If the font
;; size variable is not defined then default to a sensible size, if the font
;; name variable is not defined, or we fail to get the font from it then
;; leave the font handle as zero, but return no error!
;;-----------------------------------------------------------------------------

fname   =       "Wimp$Font", 0
fsize   =       "Wimp$FontSize", 0
fwidth  =       "Wimp$FontWidth", 0
        ALIGN

FindFont Entry  "R0-R10"
        TraceK  font, "FindFont"
        TraceNL font

        ;Attempt to lose the font is already claimed
        BL      LoseFont

        SUB     sp, sp, #44             ;44 = ALIGN (Font_NameLimit)

        MOV     R0,#ReadCMOS
        MOV     R1,#DesktopFeaturesCMOS
        SWI     XOS_Byte
        AND     R2,R2,#&1E
        MOV     R2,R2, LSR #1
        TEQ     R2,#1                   ; system font
        BNE     %FT50
        MOV     R0,#0
        STR     R0,systemfont
        SETV
        B       afterfindingfont

50      ;Allocate a buffer big enough for the font name and setup a pointer
        ;       to it
        MOV     R6, SP

        TEQ     R2,#0                   ; wimp$font
        BEQ     FindFont_get_font_size

        ; is the font the same as the last one we looked for ?
        ADRL    R14,fontnamebuffer
        LDRB    R8,[R14]
        TEQ     R8,R2
        ADDEQ   R6,R14,#1
        BEQ     fontinR6

        STRB    R2,[R14]

        SUB     R8,R2,#1                ; R8 is counter into rom fonts

        SUB     SP,SP,#256
        MOV     R2,SP                   ; buffer
        MOV     R5,#256

        MOV     R9,R6                   ; where to put it
        ADR     R1,starting_dir
        Push    "R6"
        MOV     R10,SP                  ; keep track of stack for fast rewind
        BL      recurse_down_fonts

; need R6->font name before finding the font

        Pull    "R6"

        ; copy font name into our buffer
        ADRL    R14,fontnamebuffer
        Push    R6
50
        LDRB    R7,[R6],#1
        STRB    R7,[R14,#1]!
        CMP     R7,#31
        BGE     %BT50
        Pull    R6

        ADD     SP,SP,#256              ; get rid of buffer

fontinR6
        MOV     R7,#192                 ; 12 point
        MOV     R8,#192
        B       FindFont_find_WIMP_font

recurse_down_fonts                      ; (R1=directory)

        Push    "R1,R4,lr"                 ; these are 'local'

        SUB     SP,SP,#256              ; make room for local string

        MOV     R4,#0
        MOV     R7,#-1
recurse_l1
        MOV     R0,#10
        MOV     R3,#1
        ADR     R6,int_metric
        SWI     XOS_GBPB
        TEQ     R4,R7
        TEQNE   R3,#1
        BNE     recurse_l1

        TEQ     R3,#1                   ; found ...Intmetric*, must be a font
        BNE     recurse_l1l2
        SUBS    R8,R8,#1
        BNE     recurse_l1l2

; copy font name to R9
        ADD     R0,R1,#18               ; jump resources:$.fonts.
copy_l1_loop
        LDRB    R14,[R0],#1
        STRB    R14,[R9],#1
        CMP     R14,#31
        BGT     copy_l1_loop
        SUB     SP,R10,#12
        Pull    "R1,R4,PC"
; now recurse down sub directories

recurse_l1l2
        MOV     R4,#0

recurse_l2
        MOV     R0,#12
        MOV     R3,#1
        ADR     R6,star_char
        SWI     XOS_GBPB
        TEQ     R3,#0
        BEQ     recurse_end
        LDR     R14,[R2,#20]
        TEQ     R14,#4096                       ; is it a directory?
        BNE     recurse_notadir
; need to copy new directory name onto stack
        MOV     R0,SP
        Push    "R1"
recurse_l2_loop
        LDRB    R14,[R1],#1
        CMP     R14,#31
        STRGTB  R14,[R0],#1                     ; must be GT as we're appending
        BGT     recurse_l2_loop
        MOV     R14,#"."
        STRB    R14,[R0],#1
        ADD     R1,R2,#24                       ; sub dir name
recurse_l3_loop
        LDRB    R14,[R1],#1
        STRB    R14,[R0],#1
        CMP     R14,#31
        BGT     recurse_l3_loop
        ADD     R1,SP,#4
        BL      recurse_down_fonts
        Pull    "R1"
recurse_notadir
        TEQ     R4,R7                          ; finished enumeration?
        BNE     recurse_l2
recurse_end
        ADD     SP,SP,#256
        Pull    "R1,R4,PC"


int_metric
        DCB     "IntMetric"
star_char
        DCB     "*",0,0
starting_dir
        DCB     "Resources:$.Fonts",0
        ALIGN


FindFont_get_font_size TraceL font
        ADRL    R0, fsize
        MOV     R1, R6
        MOV     R2, #4
        MOV     R3, #0
        MOV     R4, #VarType_Number
        SWI     XOS_ReadVarVal
        TEQ     R4, #VarType_String     ; convert from string if necessary
        BLEQ    string_to_number        ;
        TEQ     R4, #VarType_Number
        MOVNE   R7, #192        ;use 12pt if not a number
        BNE     FindFont_font_size_read
        MOVVS   R7, #192        ;use 12pt (no such variable)
        LDRVC   R7, [R1]        ;use variable if no error and a number
FindFont_font_size_read
        TraceK  font, "FindFont: font size*16/pt "
        TraceD  font, R7
        TraceNL font

FindFont_get_font_width TraceL font
        ADR     R0, fwidth
        MOV     R1, R6
        MOV     R2, #4
        MOV     R3, #0
        MOV     R4, #VarType_Number
        SWI     XOS_ReadVarVal
        TEQ     R4, #VarType_String     ; convert from string if necessary
        BLEQ    string_to_number        ;
        TEQ     R4, #VarType_Number
        MOVNE   R8, R7   ;use size if the variable isn't a number
        BNE     FindFont_font_width_read
        MOVVS   R8, R7   ;use size if error (no such variable)
        LDRVC   R8, [R1] ;use variable if no error and a number
FindFont_font_width_read
        TraceK  font, "FindFont: font width*16/pt "
        TraceD  font, R8
        TraceNL font

FindFont_get_font_name_on_stack TraceL font
        ADR     R0, fname
        MOV     R1, R6
        MOV     R2, #40
        MOV     R3, #0
        MOV     R4, #VarType_Expanded
        SWI     XOS_ReadVarVal
        BVS     afterfindingfont         ;return null font if variable not found/too long
        TEQ     R2, #0
        SETV    EQ
        BVS     afterfindingfont         ;return null font if we didn't get any characters
        MOV     R0, #:CHR: 0
        STRB    R0, [R1, R2]            ; terminate the string
        TraceK  font, "FindFont: font name '"
        TraceS  font, R6
        TraceK  font, "'"
        TraceNL font

FindFont_find_WIMP_font TraceL font
        MOV     R1, R6                  ; -> font name
        MOV     R2, R8
        MOV     R3, R7                  ; x/y point sizes
        MOV     R4, #0
        MOV     R5, #0                  ; x/y resolutions
        SWI     XFont_FindFont
afterfindingfont
        MOVVS   R0,#0
        MOVVS   R7,#192
        MOVVS   R8,#192                 ; still going to find symbol font- need size
        STR     R0, systemfont          ; storing the handle if it worked

; now cache the size of the font
        SWIVC   XFont_ReadInfo
        STRVC   R4,systemfonty1
        STRVC   R2,systemfonty0
        SUBVC   R1,R3,R1                ; width
        STRVC   R1,systemfontwidth
        CLRV

      [ UTF8
; now cache the defined symbol characters (speeds up pushfontstring)
        Push    "R11"
        MOV     R3, R0
        BL      measure_symbols
        STR     R11, systemfont_wimpsymbol_map
        Pull    "R11"
      ]

        BL     measure_ellipsis         ; and work out what it is in this alphabet

        [ true
; now resize iconbar icons
        MOV     R2,#1
        STRB    R2,iconbar_needs_rs
;        BL      resizeiconbaricons
        ]

;now tell everyone

        MOV     R2,R0
        MOV     R14,#ms_data+4
        STR     R14,[sp,#-(ms_data+4)]!
;
        MOV     R0,#User_Message        ; broadcasting a user message
        MOV     R1,sp
        STR     R2,[R1,#ms_data]        ; data = font handle
        MOV     R2,#0
        STR     R2,[R1,#ms_yourref]     ; no your ref
;
        LDR     R14,=Message_FontChanged
        STR     R14,[R1,#ms_action]
;
        BL      int_sendmessage_fromwimp
        ADD     sp,sp,#(ms_data+4)

FontMessageEnd

        TraceK  font, "FindFont: WIMP font handle "
        TraceX  font, R0
        TraceNL font

        ;Balance the stack before continuing
FindFont_WIMP_font_found
        ADD     sp, sp, #44

FindFont_find_symbol_font TraceL font
        ;Always find the symbol font: it's needed by "real" scalable icons.
        ADR     R1, wimpsymbol          ; -> font name
        MOV     R2, R8
        MOV     R3, R7                  ; x/y point sizes
        MOV     R4, #0
        MOV     R5, #0                  ; x/y resolutions
        SWI     XFont_FindFont
        STRVC   R0, symbolfont          ; storing the handle if it worked
        TraceK  font, "FindFont: symbol font handle "
        TraceX  font, R0
        TraceNL font

FindFontEnd

        CLRV
        EXIT

wimpsymbol = "WIMPSymbol", 0
        ALIGN

;;-----------------------------------------------------------------------------
;; string_to_number
;; Used only by font routines above to get dimensions from *Set variables
;; Entry: R1 pointer to string
;; Exit:  R1 points to number, R4 is VarType_Number
;; R0,R2 corrupted
;;-----------------------------------------------------------------------------

string_to_number
        Push    "LR"                    ;calling a SWI
        MOV     R0,#10
        MOV     R4,R1                   ;R1 corrupted by SWI
        SWI     XOS_ReadUnsigned
        MOV     R1,R4
        MOVVC   R4,#VarType_Number
        STRVC   R2,[R1]
        Pull    "PC"


;;-----------------------------------------------------------------------------
;; Lose fonts, only performed if non-zero.
;;-----------------------------------------------------------------------------

LoseFont EntryS "R0"
        TraceK  font, "LoseFont"
        TraceNL font

        ;Lose the WIMP font
        LDR     R0, systemfont
        TEQ     R0, #0                  ; is the system font defined
        BEQ     %FT05
        SWI     XFont_LoseFont          ; if it is then lose it
        MOV     R0, #0
        STR     R0, systemfont
05
        [       debug :LAND: debugfont
        BEQ     LoseFont_lost_WIMP_font
        ]
        TraceK  font, "LoseFont: lost WIMP font handle"
        TraceNL font
LoseFont_lost_WIMP_font

        ;Lose the symbol font
        LDR     R0, symbolfont
        TEQ     R0, #0                  ; is the symbol font defined
        BEQ     %FT10
        SWI     XFont_LoseFont          ; if it is then lose it
        MOV     R0, #0
        STR     R0, symbolfont
10
        [       debug :LAND: debugfont
        BEQ     LoseFont_lost_symbol_font
        ]
        TraceK  font, "LoseFont: lost symbol font handle"
        TraceNL font
LoseFont_lost_symbol_font

        EXITS


      ]

;;-----------------------------------------------------------------------------
;; Tool_SpriteOp
;; Perform an OS_SpriteOp on a tool from the tool_area
;; Entry: R0 reason code (b9 set)
;;        R2-R7 as required by the respective reason code
;; Exit:  R0,R1 preserved
;;        R2-R7 as returned by the respective reason code
;;-----------------------------------------------------------------------------

Tool_SpriteOp
        EntryS  "R0,R1"
        BL      Tool_SpriteOpCommon
        EXITS

Tool_SpriteOpTiled
        Entry   "R0,R1"
        LDR     R0,=SpriteReason_TileSpriteScaled+512 ; Regardless of op, make op tiled
        BL      Tool_SpriteOpCommon
        EXIT

Tool_SpriteOpCommon
        Push    "lr"
        LDRB    R1,tsprite_needsregen
        TEQ     R1,#0
        BEQ     %FT05
        Push    "R2"
        Debug tools,"Need regen",R7
        BL      restore_tool_list        ; ensure tool list valid, get 1st sprite entry
        BL      recache_tools_trans      ; make new tpixtable from 1st sprite entry
        Pull    "R2"
        LDR     R7,tool_transtable       ; reload new table
        Debug tools,"Regen     ",R7
        MOV     R1,#0
        STRB    R1,tsprite_needsregen
05
        LDR     R1,tool_area             ; R1 is quite often wrong!
        BIC     R2,R2,#1                 ; flag of masked
        SWI     XOS_SpriteOp
        Pull    "pc"

;;----------------------------------------------------------------------------
;; Mode-independent sprite code
;; Entry:  [spritename] --> sprite name
;;         [thisCBptr] --> sprite area
;;         [lengthflags] ==> is R2 a name ptr or a sprite ptr?
;; Exit:   R3,R4 = sprite size (pixels)
;;         mode data set up if different input mode from last time
;;----------------------------------------------------------------------------

cachetoolspritedata
        Entry   "R1-R2,R5-R7"

        MOV     R2,#1
        STRB    R2,selecttable_crit     ; entering critical period for pixtable

        LDR     R2,lengthflags
        CMP     R2,#0                   ; absolute pointer?
        LDR     R2,spritename
        BLNE    cachespriteaddress
        MOVVC   R0,#&200+SpriteReason_ReadSpriteSize
        SWIVC   XOS_SpriteOp            ; read information about the sprite
        BVS     %FT92
;
; R2 -> sprite in area
;
        LDR     R7,[R2,#spImage]
        LDR     R14,[R2,#spTrans]
        CMP     R7,R14                  ; min(image,trans)
        MOVHI   R7,R14

        LDR     R1,tpixtable_at
        CMP     R1,#0                   ; is a pixtable defined?
        BEQ     %FT10

      [ TrueIcon3
        LDRB    R14, tinted_tool
        TEQ     R14, #0                 ; if it's tinted, we must recalculate the table
        BNE     %FT10
      ]
      [ ToolTables
        ADRL    R14,ttt_masterset
        LDR     R14,[R14,#ttt_table2]   ; if it's a custom set, we must recalculate the table
        TEQ     R14,#0
        BNE     %FT10
      ]

        TEQ     R7,#spPalette           ; does it have a palette?
        LDREQ   R14,tsprite_lastmode
        TEQEQ   R6,R14                  ; no, so have we already cached this information?
        STREQ   R1,tool_transtable      ; repoint at the pixtable
        BEQ     %FT92

10      MOV     R0,R6                   ; R0 = mode of sprite

        TEQ     R7,#spPalette
        MOVNE   R6,#-1                  ; if it has a palette then corrupt last mode
      [ TrueIcon3
        LDRB    R14, tinted_tool
        TEQ     R14, #0                 ; if we're generating a tinted table, corrupt last mode too
        MOVNE   R6, #-1
      ]
        STR     R6,tsprite_lastmode

        Push    "R2,R3-R4"              ; R2 -> sprite, R3,R4 = height / width

        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        STRVC   R2,tsprite_log2bpp      ; get the depth of the sprite

        MOVVC   R1,#VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,tsprite_log2px       ; get the X scaling factor (pixels => OS units)

        MOVVC   R1,#VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,tsprite_log2py       ; get the Y scaling factor (pixels => OS units)

        MOVVC   R1,#VduExt_ModeFlags
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,tsprite_modeflags    ; get the mode flags

        MOVVC   R1,#VduExt_NColour
        SWIVC   XOS_ReadModeVariable
        STRVC   R2,tsprite_ncolour      ; get the ncolour
      [ ToolTables
        BLVC    mastertoactive          ; remap any custom translation tables
      ]
        Pull    "R2,R3-R4",VS
        BVS     %FT92

        LDR     R6,log2bpp
        MOV     LR,#ModeFlag_DataFormat_Mask
        TEQ     R6,#3
        ORRNE   LR,LR,#ModeFlag_64k     ; try and avoid false positives on 64K flag caused by 8bpp full palette flag.
        LDRNE   R1,tsprite_ncolour
        LDRNE   R5,ncolour
        TEQNE   R1,R5                   ; ncolour differs? (only check if not 8bpp to try and avoid 63/255 false positives)
        LDREQ   R1,modeflags
        LDREQ   R2,tsprite_modeflags
        ANDEQ   R2,R2,LR
        ANDEQ   R1,R1,LR
        TEQEQ   R1,R2                   ; any colour space conversion or alpha blending needed?
        LDREQ   R1,tsprite_lastmode
        TSTEQ   R2,#ModeFlag_DataFormatSub_Alpha ; does it have an alpha channel?
        TSTEQ   R1,#&80000000           ; does it have an alpha mask?
        LDR     R1,tsprite_log2bpp
        TEQEQ   R1,R6                   ; bpp differs?
        LDR     R0,tsprite_log2px
        LDR     R5,log2px
        TEQEQ   R0,R5
        LDR     R1,tsprite_log2py
        LDR     R6,log2py
        TEQEQ   R1,R6                   ; any special scaling?
        MOVEQ   R14,#0
        MOVNE   R14,#-1
        STRB    R14,tsprite_needsfactors       ; may be modified later

        ADR     r2,tsprite_factors
        BL      rationalisefactors

        Pull    "R1"                    ; R1 -> sprite
        MOV     R2,#-1
        MOV     R3,#-1                  ; convert to the current mode
      [ Medusa
        MOV     R5,#(1:SHL:0) :OR: 1:SHL:1 :OR: 1:SHL:4 ; Use mode's palette if sprite has none, make wide table
      |
        MOV     R5,#(1:SHL:0)
      ]
;
; we must now attempt to cope with the dilemma of sorting out the correct
; mapping table for the sprite.
;
; in earlier versions of the Window Manager it made no attempt to cope
; with different depth sprites other than 1,2 or 4BPP so we will break
; new ground and go boldly where no larma has been parping before.
;
        LDR     R14,tsprite_log2bpp

        Debug   ic,"Sprite bpp, palette",R14,R7

        CMP     R14,#3                  ; is it 8,16 or 32BPP?
        CMPLT   R7,#(spPalette+4)       ; or does it have a palette?
        BLT     %FT02

        LDR     R0,baseofromsprites     ; might have 8+ bpp sprites in ROM now
        LDR     R4,[R0,#saEnd]
        ADD     R4,R0,R4                ; R4 -> end of ROM sprite area
        CMP     R1,R0
        CMPHS   R4,R1                   ; is sprite in ROM?
        LDRLO   R0,baseofsprites        ; no, use RAM sprite area      ; 320nk Medusa fix
        B       %FT10
;
; sprite is in a depth less than 8BPP so take the current palette and munge
; it based on the translation table defined in workspace
;

02
        LDR     R0,[R1,#spMode]         ; R0 = mode of sprite
        ADRL    R1,temppaltable         ; R1 -> temporary palette area
        Push    "R0-R3,R5"

        BL      getpalpointer           ; R14 -> palette to be used

        LDR     R4,tsprite_log2bpp
        CMP     R4,#1
        ADRLTL  R4,transtable1          ; R4 => translation 1BPP
        ADREQL  R4,transtable2          ;       translation 2BPP
        ADRGTL  R4,transtable4          ;       translation 4BPP
        MOV     R5,#15

05      LDRB    R3,[R4,R5]              ; get index into real palette
        LDR     R3,[R14,R3,LSL #2]
        BIC     R3,R3,#&000000FF        ; R3 = &BBGGRR00
        STR     R3,[R1,R5,LSL #2]
        SUBS    R5,R5,#1
        BPL     %BT05                   ; loop back copying the data

        Pull    "R0-R3,R5"
10
      [ ToolTables
        ADRL    R14,ttt_masterset
        LDR     R14,[R14,#ttt_table2]   ; are these sprites using custom translations?
        TEQ     R14,#0
        BEQ     %FT15

        LDR     R1,ttt_lastlookup
        BL      colourmatchtool         ; redo the last lookup
        MOV     R14,R7
        B       %FT45                   ; skip the generic table generation
15
      ]
        MOV     R4,#0                   ; R4 =0 read table size
      [ TrueIcon3
        SWI     XColourTrans_GenerateTable ; ensure wide table flag is obeyed
      |
        SWI     XColourTrans_SelectTable
      ]
        BVS     %FT90                   ; exit

        LDR     R14,tpixtable_at
        TEQ     R14,#0                  ; does the pixtable exist?
        LDRNE   R14,tpixtable_size
        CMP     R14,R4                  ; is it big enough?
        BHS     %FT20

        Push    "R0-R3"

        LDR     R2,tpixtable_at
        CMP     R2,#0                   ; is there a pixel table defined yet?
        MOVNE   R0,#ModHandReason_Free
        BLNE    XROS_Module              ; free it if there is - ignoring errors

        MOV     R2,#0
        STR     R2,tpixtable_size
        STR     R2,tpixtable_at         ; mark as the pix table has been released

        MOV     R0,#ModHandReason_Claim
        MOV     R3,R4
        BL      XROS_Module              ; attempt to claim a new buffer big enough
        STRVC   R2,tpixtable_at
        STRVC   R3,tpixtable_size       ; store pointer and define the size

        STRVS   R0,[SP]
        Pull    "R0-R3"
        BVS     %FT90                   ; return if it errors

20      MOV     R6,R4                   ; R6 = size of table generated (first time)
        LDR     R4,tpixtable_at

        Debug   ic,"Sprite src mode, src pptr, dest mode, dest pptr",R0,R1,R2,R3

      [ TrueIcon3
        Push    "R6,R7"
        LDRB    R6, tinted_tool
        ORR     R5, R5, R6
        MOV     R6, wsptr
        ADR     R7, tintfunc
        SWI     XColourTrans_GenerateTable
        Pull    "R6,R7"
      |
        SWI     XColourTrans_SelectTable
      ]
        BVS     %FT90                   ; return if not important

        CMP     R6,#256
        BHI     %FT40                   ; if its greater than 8bpp then we can ignore it (was GT)

35      SUBS    R6,R6,#1                ; decrease the index into the table
        BMI     %FT90                   ; return if end of the world reached

        LDRB    R14,[R4,R6]
        TEQ     R14,R6                  ; colour number = index? (1:1 mapped)
        BEQ     %BT35
40
        LDR     R14,tpixtable_at        ; use that now
45
        STR     R14,tool_transtable
        MOV     R14,#-1
        STRB    R14,tsprite_needsfactors; mark as needing translation
90
        Pull    "R3-R4"
92
        MOV     R14, #0
        STRB    R14, selecttable_crit   ; passed the critical moment for pixtable

        EXIT

    [ TrueIcon3
;------------------------------------------------------------------------------
; Routine called to process a palette entry to "tint" a tool sprite
; Maps greys on to title bar foreground-background scale
; White - rgb_lightgrey - Black   --->   White - [truetitlecolour] - [truetitlefg]
;
; In:   R0 = input palette entry
; Out:  R0 = modified palette entry
;       all other registers preserved
;------------------------------------------------------------------------------
tintfunc Entry "R1-R8"

        MOV     R8, #&FF
        MOV     R3, R0, LSR #24         ; blue component
        AND     R2, R8, R0, LSR #16     ; green component
        AND     R1, R8, R0, LSR #8      ; red component

        TEQ     R1, R2
        TEQEQ   R2, R3
        EXIT    NE                      ; leave colours alone

        LDR     R4, truetitlecolour
        AND     R2, R8, R4, LSR #8      ; title background red component
        AND     R3, R8, R4, LSR #16     ; title background green component
        MOV     R4, R4, LSR #24         ; title background blue component

        CMP     R1, #&BB
        BLT     %FT02

        ; bright shades: blend to white
        SUB     R1, R8, R1              ; distance of source from white

        SUB     R2, R8, R2              ; R2 = distance from white
        MUL     R0, R1, R2              ; scale up by new size
        DivRem  R2, R0, #&44, R14,norem ; scale down by old size
        SUB     R2, R8, R2              ; make relative to white again

        SUB     R3, R8, R3
        MUL     R0, R1, R3
        DivRem  R3, R0, #&44, R14, norem
        SUB     R3, R8, R3

        SUB     R4, R8, R4
        MUL     R0, R1, R4
        DivRem  R4, R0, #&44, R14, norem
        SUB     R4, R8, R4

        B       %FT01

02      ; dark shades: blend between foreground and background
        LDR     R7, truetitlefg
        AND     R5, R8, R7, LSR #8      ; title foreground red component
        AND     R6, R8, R7, LSR #16     ; title foreground green component
        MOV     R7, R7, LSR #24         ; title foreground blue component

        RSB     R1, R1, #&BB            ; distance of source from Wimp grey 2

        SUBS    R5, R2, R5              ; R5 = total distance between bg and fg
        BEQ     %FT10                   ; just in case fg=bg (!)
        RSBLT   R5, R5, #0              ; R5 = |R5|
        SavePSR R8                      ; remember flags for later
        MUL     R0, R1, R5              ; scale up by new size
        DivRem  R5, R0, #&BB, R14,norem ; scale down by old size
        RestPSR R8,,f                   ; restore flags
        ADDLT   R2, R2, R5              ; make relative to new background
        SUBGT   R2, R2, R5              ;   (accounting for the sign of R2-R5 above)
10
        SUBS    R6, R3, R6
        BEQ     %FT10
        RSBLT   R6, R6, #0
        SavePSR R8
        MUL     R0, R1, R6
        DivRem  R6, R0, #&BB, R14, norem
        RestPSR R8,,f
        ADDLT   R3, R3, R6
        SUBGT   R3, R3, R6
10
        SUBS    R7, R4, R7
        BEQ     %FT10
        RSBLT   R7, R7, #0
        SavePSR R8
        MUL     R0, R1, R7
        DivRem  R7, R0, #&BB, R14, norem
        RestPSR R8,,f
        ADDLT   R4, R4, R7
        SUBGT   R4, R4, R7
10
01      ; recombine RGB from R2, R3, R4
        MOV     R0, R2, LSL #8
        ORR     R0, R0, R3, LSL #16
        ORR     R0, R0, R4, LSL #24

        EXIT
    ]

;;-----------------------------------------------------------------------------
;; restore_tool_list
;; Get a valid tool list from the backup (which is never freed to save bashing the RMA)
;; Entry: -
;; Exit:  R2 -> first sprite in the tools list
;;-----------------------------------------------------------------------------

restore_tool_list
        ADRL    R2,tool_list_backup
        LDR     R2,[R2]                 ; tool list pointer
        STR     R2,tool_list
        LDR     R2,[R2]                 ; get first tool, we assume that this is representitive
        MOV     PC, LR

 [ TrueIcon3
;;-----------------------------------------------------------------------------
;; recache_tools_trans
;; Regenerate the pixel translation tables for the tool sprites
;; In: R2 -> sprite representative of one in the tool_list
;;-----------------------------------------------------------------------------

recache_tools_trans
        Push    "R0-R4,R14"

        BIC     R2,R2,#1
        STR     R2,spritename
        MOV     R2,#0
        STR     R2,lengthflags          ; flag it's a sprite address (not a name)

        MOV     R14,#0
        STR     R14,tool_transtable     ; might move during cachetoolspritedata so kill it

        BL      cachetoolspritedata     ; this sets up the tool pixtable area

        CLRV                            ; clear errors
        Pull    "R0-R4,PC"
 ]

        LTORG

        END
@


4.37
log
@Avoid unnecessary remainder calculations
Detail:
  s/Wimp01, s/Wimp02, s/Wimp05, s/Wimp08s, s/Wimp10 - Avoid unnecessary remainder calculations in DivRem macro. Also make more use of DivRem's ability to accept a constant (not a register) as the divisor.
Admin:
  Tested on Cortex-A15


Version 5.52. Tagged as 'Wimp-5_52'
@
text
@d1082 3
a1084 2
        ANDHI   R14,R14,#ModeFlag_DataFormatSub_RGB
        ORRHI   R5,R14,R5               ; force table creation for RGB (but not BGR) 32bpp
@


4.36
log
@Only skip ColourTrans calls for 32bpp TBGR
The whizzy new TRGB modes can't assume 32bpp sprite data is equivalent to 32bpp palette entries, so must use ColourTrans.
* Disable the use-in-place optimisation if that's the case
* Update the comments to reflect this logic more clearly
Fix bug in non Medusa case, STRB was using the wrong register as the base address.

Tested briefly with 'Raspberry' theme, unchanged from previous version.

Version 5.48. Tagged as 'Wimp-5_48'
@
text
@d3559 1
a3559 1
        DivRem  R2, R0, #&44, R14       ; scale down by old size
d3564 1
a3564 1
        DivRem  R3, R0, #&44, R14
d3569 1
a3569 1
        DivRem  R4, R0, #&44, R14
d3587 1
a3587 1
        DivRem  R5, R0, #&BB, R14       ; scale down by old size
d3597 1
a3597 1
        DivRem  R6, R0, #&BB, R14
d3607 1
a3607 1
        DivRem  R7, R0, #&BB, R14
@


4.35
log
@Fix for background colour too light on non-bordered icons
Wimp04.s:
 Line 991, a register fumble meant the special case check (when the icon background colour equals the window work area colour) always failed so the icon background was lightened.
 Removed unnecessary ADR.
Wimp10.s:
 Function getborder() made more readable by use of symbols instead of magic numbers
Fixes ticket #395 reported by Paul Reuvers.

Version 5.45. Tagged as 'Wimp-5_45'
@
text
@d1075 3
a1077 3
        MOVCC   R7,#256
        MOVEQ   R7,#512
        MOVHI   R7,#1024                ; => bytes per table entry
d1080 5
d1091 1
a1091 1
        MOVEQ   R14,#0                  ; 32bpp, no copies needed, force a free
d1101 1
a1101 1
        BEQ     %FT20                   ; 32bpp, no copies needed, skip the claim
d1112 1
a1112 1
        ; R2->base of storage for user tables
d1114 1
a1114 1
        ; R4->table of user pointers
d1117 1
a1117 1
        ; R7=size of 1 user table in bytes
d1121 1
a1121 1
        CMPNE   R5,#5                   ; or 32bpp mode?
d1130 1
a1130 1
        CMP     R5,#4                   ; 16bpp is 2B/entry, others are 1
d1136 1
d1189 3
a1191 3
        MOVCC   R1,#256
        MOVEQ   R1,#512
        MOVHI   R1,#1024                ; => bytes per table entry
d1242 1
a1242 1
        STRB    R0,[R1,R1]              ; No wide translation tables
@


4.34
log
@Fix for missing window backgrounds/scroll bars when tiled sprite op not supported
For the backgrounds, the code was switched with 'standalone' however the Wimp actively wipes SA_FLAGS in its makefile so the standalone switch is always false during the install phase of a disc build. Also, the standalone switch is used to include resources which are ordinarily handled by the boot sequence prefixing the WindowManager$Path rather than using ResourceFS.
For the scroll bars, the decision to plot manually was being made by looking at the V flag on return from Tool_SpriteOp, except that that function uses EntryS/EXITS so the caller can't see the return flags.
Added new switch CanTileManually, removed 0 use tilewithspriteops switch.
Changed single use of NoFontBodge switch to use preferred 'outlinefont'.
Tested on RISC OS 4.02.

Version 5.41. Tagged as 'Wimp-5_41'
@
text
@d37 1
a37 1
        MOV     R5,#3                   ; default values
d55 1
a55 1
        BLEQ    getnumber               ; if its a comma, ie. following number get the highligt colour
d59 1
a59 1
        CMP     R4,#1
d66 2
a67 2
        MOVNE   R4,#2
        MOVEQ   R4,#1
a69 1
      [ true
d71 1
a71 2
        MOVHS   R4, #0
      ]
@


4.33
log
@Fix to build with HdrSrc-2_42. Use OS_SpriteOp 65 where possible.
Detail:
  s/Wimp01 - Update Wimp_SpriteOp handler to cope with the new SpriteReason_BadReasonCode value. Initialise unused bits of spritebits to 1 so that it acts as a whitelist, only allowing through operations that we know are safe.
  s/Tiling3D - Use OS_SpriteOp 65 for drawing tiled window backgrounds. Softload versions will fall back to using the old manual tiling code if OS_SpriteOp 65 is unavailable.
  s/Wimp10 - Use OS_SpriteOp 65 for drawing the tiled sprites that make up scrollbar wells and bars. Falls back to manual tiling in softload versions.
Admin:
  Tested on Iyonix, BB-xM
  Requires HdrSrc-2_42


Version 5.37. Tagged as 'Wimp-5_37'
@
text
@d2401 2
a2402 4
        LDR     R0,=SpriteReason_TileSpriteScaled+512
        BL      Tool_SpriteOp
        LDR     R0,tool_plotparams
  [ standalone
d2434 2
a2435 4
        LDR     R0,=SpriteReason_TileSpriteScaled+512
        BL      Tool_SpriteOp
        LDR     R0,tool_plotparams
  [ standalone
d2498 2
a2499 4
        LDR     R0,=SpriteReason_TileSpriteScaled+512
        BL      Tool_SpriteOp
        LDR     R0,tool_plotparams
  [ standalone
d2646 2
a2647 4
        LDR     R0,=SpriteReason_TileSpriteScaled+512
        BL      Tool_SpriteOp
        LDR     R0,tool_plotparams
  [ standalone
d2679 2
a2680 4
        LDR     R0,=SpriteReason_TileSpriteScaled+512
        BL      Tool_SpriteOp
        LDR     R0,tool_plotparams
  [ standalone
d2745 2
a2746 4
        LDR     R0,=SpriteReason_TileSpriteScaled+512
        BL      Tool_SpriteOp
        LDR     R0,tool_plotparams
  [ standalone
d3225 11
d3252 1
a3252 1
        EXITS
@


4.32
log
@Improvement to previous commit
Detail:
  s/Wimp04, s/Wimp10 - cachespritedata & cachetoolspritedata now force SpriteExtend to be used if the sprite has an alpha channel, to ensure plotting an alpha'd sprite into an alpha'd framebuffer performs blending instead of potentially skipping it (and copying the sprite alpha channel to the screen alpha channel)
Admin:
  Builds, but untested


Version 5.33. Retagged as 'Wimp-5_33'
@
text
@a2397 1

d2399 8
d2414 1
d2431 11
d2450 1
d2500 8
d2515 1
d2517 3
d2650 8
d2665 1
d2682 11
d2700 1
d2753 8
d2768 1
d2770 3
@


4.31
log
@Fix logic which decides whether to plot sprites using the Kernel or SpriteExtend to take into account the new sprite modes
Detail:
  s/Wimp01 - Add NColour mode variable to the list of variables cached for the current screen mode. Add modeflags & ncolour to the sprite & tool sprite variables.
  s/Wimp04, s/Wimp10 - Update cachespritedata and cachetoolspritedata to look at the modeflags, ncolour and alpha mask flag when deciding if sprite_needsfactors should be set or not (i.e. whether the code ultimately uses OS_SpriteOp 52 or 34). This should allow the Wimp to correctly detect if a sprite can safely be rendered by the Kernel or not (except for double pixel vs. non-double pixel - but presumably nobody's using double pixel mode sprites for icons/tool sprites, otherwise it would be fixed by now?)
  s/Wimp04 - Add an extra safety check to icon text rendering after a crash was seen when calling Wimp_PlotIcon outside of a redraw loop
Admin:
  Tested on BB-xM
  Fixes problem reported on forums with 32bpp, alpha-masked sm!Netsurf icon vanishing from filer when viewed in 32bpp modes
  https://www.riscosopen.org/forum/forums/3/topics/309?page=4#posts-25995


Version 5.33. Tagged as 'Wimp-5_33'
@
text
@d3293 1
@


4.30
log
@3 minor fixes, 2 minor enhancements
Makefile:
* Conditionally copy the disc resources, saving a little build time.
Wimp10.s; hdr/Wimp:
* Issue Service_WimpToolSpritesChanged when the tool sprite area is changed.
Wimp05:
* Fix bug in softloaded versions of the Wimp where menus would randomly lose the keyboard shortcut text. This was caused by use of an LDR to retrieve a byte wide variable. This specifically affected some softloads because the Wimp gets squeezed, and during unsqueezing the Wimp's workspace ends up being allocated from the same bit of RMA that used to contain the squeezed copy of the module (=lots of random numbers).
Wimp09:
* Fix bug where configuring WimpSpritePrecedence to ROM when a theme is loaded would cause redrawing of window textures to fail. This is because the Wimp intersects the ROM and RAM sprite areas and deletes any duplicates from the RAM area when remaking the fast lookup sprite list. So if the RAM sprites include the "tile_1" (etc) sprite on redrawing the desktop the Wimp points to this, then intersects the lists and deletes the sprite, leaving the pointers pointing at junk. Now, on deleting something, the window tile pointers are invalidated. Fixes ticket #346.
Wimp02:
* Fix bug where the title bar text, when the desktop font is the system font, is incorrectly rendered in the colour selected by WimpVisualFlag -WindowOutlineColour. The Wimp now restores the text colour if -WOC has set the graphics colour to something other than black.

Administrative -
In Wimp01, swap a couple of SpriteReasons from magic numbers. In the init of variables use the common reset_all_tiling_sprite function.
In Tiling3D, more SpriteReasons, and rationalise the registers used in reset_all_tiling_sprites.

Version 5.32. Tagged as 'Wimp-5_32'
@
text
@d3266 8
d3280 14
d3295 1
a3295 2
        LDR     R6,log2bpp
        TEQ     R1,R6                   ; any special translating?
@


4.29
log
@Add flexible scheme to allow non-grey/opaque toolsprites
The Wimp can now accept toolsprite sets which have precalculated (non default) colour translation tables supplied by the designer.
This allows the link between window template colour and displayed tool colour to be reestablished when the tools aren't grey (previously, the Ursula Wimp would only tint greys).
For full design details see Doc/ToolTables.
An example test set, TestO/TTTTest is provided. This is the 'Newlook' set but with a splotch in the corner of each sprite which is then replaced by the hex of the Wimp colour being requested.
Detail:
 Wimp01.s: New workspace requirements
 Wimp04.s: Pull out the RGB to greyscale function so it can be used elsewhere
 Wimp10.s: New tool table support code

Fixes ticket #323.
Also introduces a disc variant (with the extra EX0 EY0 resolution) of the 'Steel' theme, thus making it generally available.

Version 5.30. Tagged as 'Wimp-5_30'
@
text
@d1309 15
d1352 2
a1353 2
01      MOV     R0,#0
        STR     R0,tool_area            ; flag as being released
d1429 1
a1429 1
        STR     R1,tool_area            ; -> tools in ResourcesFS
@


4.28
log
@Order cachetoolspriteaddress out of line
Was previously inline but called as a function.
Not tagged.
@
text
@d424 4
d430 3
d539 45
d1054 198
d1296 7
d1381 1
a1381 1
        ADREQL  R1,default_tools
d1866 8
d2100 8
d2195 8
d2358 8
d2427 10
d2576 9
d2644 10
d3205 2
a3206 2
        LDR     R14,tpixtable_at
        CMP     R14,#0                  ; is a pixtable defined?
d3214 6
d3224 1
d3251 3
d3331 6
d3338 7
a3344 1
10      MOV     R4,#0                   ; R4 =0 read table size
d3407 3
a3548 3
        LDRVC   R0,tpixtable_at
        STRVC   R0,tool_transtable      ; update the new table location

@


4.27
log
@Change to method of window highlighting
The change made in Wimp-5_02 to Wimp-5_03 (to permit 'f' prefixed toolsprites) introduced a set of interesting boundary cases not covered by that scheme.
This commit restores the former behaviour, while retaining its simplification of H/V scrollbar plotting (beefed up with a few ASSERTs).
Part of fix for ticket #323.

Tagged as Wimp-5_30-pre4.
@
text
@a663 36
        B       %FT07

cachetoolspriteaddress ; [spritename], [thisCBptr], [lengthflags] as for cachespriteaddress
                       ; R4 -> resolution suffix
                       ; R10 = first suffix tried (and failed)
        Push    "R14"
        MOV     R14,#&FF
        AND     R5,R14,R10
        AND     R6,R14,R10,LSR #8
        SUBS    R5,R5,#'0'
        SUB     R6,R6,#'0'
        MOVEQ   R5,#2
        MOVEQ   R6,#8                   ; pretend '0' was '28' so we try '24' next
        TEQ     R6,#3
        MOVEQ   R6,#4                   ; pretend '23' was '24' so we try '22' next

05      CMP     R5,R6
        MOVLO   R5,R5,LSL#1
        MOVHI   R6,R6,LSL#1
        BNE     %FT06                   ; after rectangular pixels, try next squarer version

        TEQ     R5,#1
        MOVEQ   R5,#2
        MOVEQ   R6,#2                   ; after '11', try '22'
        MOVNE   R5,#-'0'                ; after any other square pixels, try without suffix

06      ADD     R14,R5,#'0'
        STRB    R14,[R4]
        ADD     R14,R6,#'0'
        STRB    R14,[R4,#1]
        BL      cachespriteaddress
        Pull    "PC", VC                ; success
        TEQ     R5,#0
        BPL     %BT05                   ; try next suffix
        Pull    "PC"                    ; total failure, exit with

d910 40
@


4.26
log
@Fix to incorrect tint of back & close icon after changing tool sets
If the last window drawn before dropping to the command line had the input focus then a *TOOLSPRITES command is used the default translation table would be tinted.
On reentering the desktop the back & close icon of the first window draw (= top of stack) would be the wrong colour.

Tagged as Wimp-5_30-pre3.
@
text
@d418 2
a419 5
;; All icons are allowed to give four states;
;; - normal,         this is the default state of an icon
;; - pressed normal, used when a mouse button is depressed over the icon
;; - focus,          used when window has the input focus
;; - pressed focus,  window has focus and mouse button is down over icon
d421 3
a423 3
;; all gadgets must be defined with the same palette and same mode,
;; mixing is not allowed.  Sprites are allowed to have mode suffix
;; to allow different depths to be supported.
d430 2
a431 2
;; The table describes the sprite name and which information is important,
;; such as its width + depth.
a432 3
;; The table is built up of four subtables, one for each state of an icon.
;; The LoopCnt variable determines which subtable will be built;
;; 0, 1, 2, 3 for normal, pressed normal, focus, pressed focus.
d438 13
d452 4
a455 1
        GBLA LoopCnt
d457 2
a458 1
LoopCnt SETA 0
d460 3
a462 1
        WHILE LoopCnt < 4
d464 5
a468 8
        AddIcon LoopCnt,back,,"bicon", back_width, title_height
        AddIcon LoopCnt,close,,"cicon", close_width, title_height
        AddIcon LoopCnt,toggle,,"ticon", vscroll_width, title_height
        AddIcon LoopCnt,toggle1,,"ticon1", vscroll_width, title_height
        AddIcon LoopCnt,size,,"sicon", vscroll_width, hscroll_height
        [ IconiseButton
        AddIcon LoopCnt,iconise,,"iicon", iconise_width, title_height
        ]
d470 3
a472 26
        AddIcon LoopCnt,up,,"uicon", vscroll_width, up_height
        AddIcon LoopCnt,down,,"dicon", vscroll_width, down_height
        AddIcon LoopCnt,right,,"ricon", right_width, hscroll_height
        AddIcon LoopCnt,left,,"licon", left_width, hscroll_height

        AddIcon LoopCnt,tbarlcap,,,title_left,title_height
        AddIcon LoopCnt,tbarmidt,,,title_sectionwidth,title_topheight
        AddIcon LoopCnt,tbarmidb,,,title_sectionwidth,title_bottomheight
        AddIcon LoopCnt,tbarrcap,,,title_right,title_height

        AddIcon LoopCnt,vwelltcap,no,,vscroll_width,vscroll_top
        AddIcon LoopCnt,vwellt,no,,vscroll_width,vscroll_topfill

        AddIcon LoopCnt,vbart,,,vscroll_width,vscroll_blobtop
        AddIcon LoopCnt,vbarmid,,,vscroll_width,vscroll_blobfill
        AddIcon LoopCnt,vbarb,,,vscroll_width,vscroll_blobbottom

        AddIcon LoopCnt,vwellb,no,,vscroll_width,vscroll_bottomfill
        AddIcon LoopCnt,vwellbcap,no,,vscroll_width,vscroll_bottom

        AddIcon LoopCnt,hwelllcap,no,,hscroll_left,hscroll_height
        AddIcon LoopCnt,hwelll,no,,hscroll_leftfill,hscroll_height

        AddIcon LoopCnt,hbarl,,,hscroll_blobleft,hscroll_height
        AddIcon LoopCnt,hbarmid,,,hscroll_blob,hscroll_height
        AddIcon LoopCnt,hbarr,,,hscroll_blobright,hscroll_height
d474 2
a475 2
        AddIcon LoopCnt,hwellr,no,,hscroll_rightfill,hscroll_height
        AddIcon LoopCnt,hwellrcap,no,,hscroll_right,hscroll_height
d478 2
a479 2
        AddIcon LoopCnt,hblip,,,hscroll_blipwidth,hscroll_height
        AddIcon LoopCnt,vblip,,,vscroll_width,vscroll_blipheight
a481 3
LoopCnt SETA LoopCnt+1
        WEND

d484 1
a484 1
        AddIcon 0,blank,no,"blicon",vscroll_width,hscroll_height
a700 1

a941 2
        BL      EnsureToolIcons

a944 60
;-------------------------------------------------------------------------------
; Ensure that all the various formats of the toolicons have valid sprites.
; We'll assume that the plain toolicon sprites are all present. First we
; check the pressed toolicon sprites. If one or more are missing then we
; replace them by their non-pressed equivalent.
; Next we check all the focus icons, missing icons are replaced with plain
; ones and missing pressed icons are replaced with pressed plain ones.
;-------------------------------------------------------------------------------
EnsureToolIcons
        Entry   "R0-R9"

        MOV     R9,#tool_blank          ;

;        Debug   perth,"number of toolicons in total = ",R9

        MOV     R9,R9,LSR #4            ; number of different tool icons

;        Debug   perth,"number of toolicons per set = ",R9

        MOV     R0,R9                   ; number of icons to do
        LDR     R1,tool_list            ; -> list of plain toolicons
        ADD     R2,R1,R9,LSL #2         ; -> list of pushed toolicons
        ADD     R3,R2,R9,LSL #2         ; -> list of plain focus toolicons
        ADD     R4,R3,R9,LSL #2         ; -> list of pushed focus toolicons

        ;------ Move through the list of pushed plain tools and
        ;       replace missing ones with their non-pushed version

01      LDR     R6,[R2],#4              ; get pushed toolicon
        LDR     R5,[R1],#4              ; get plain toolicon
        TEQ     R6,#0                   ; is there a pushed icon?
        STREQ   R5,[R2,#-4]             ; if not, copy in the plain icon

        ;------ Now do the same for the pushed focus tools

        LDR     R6,[R4],#4              ; get pushed focus toolicon
        LDR     R5,[R3],#4              ; get plain focus toolicon
        TEQ     R6,#0                   ; is there a pushed focus icon?
        STREQ   R5,[R4,#-4]             ; if not, copy in the plain focus icon

        SUBS    R0,R0,#1                ; have we done them all?
        BNE     %BT01                   ; if not, go back for next one

        ;------ Now check the focus icons, use plain icons for any missing

        MOV     R0,R9,LSL #1            ; number of icons to do
        LDR     R1,tool_list            ; -> list of plain toolicons
        ADD     R2,R1,R9,LSL #3         ; -> list of focus toolicons

02      LDR     R3,[R2],#4              ; get focus version of toolicon
        LDR     R4,[R1],#4              ; get plain version of toolicon
        TEQ     R3,#0                   ; is there a focus version?
        STREQ   R4,[R2,#-4]             ; if not, copy in the plain version

        SUBS    R0,R0,#1                ; have we done them all?
        BNE     %BT02                   ; if not, go back for next one

        EXIT


a1581 6
        LDR     R0, [handle, #w_flags]  ; get window flags
        TST     R0, #ws_hasfocus        ; does our window have the input focus?
        MOVEQ   R0, #0
        MOVNE   R0, #tool_blank
        MOVNE   R0,R0,LSR #1

a1583 1
        ADDNE   R2,R2,R0
d1913 2
a1914 2
        MOV     R0,#tool_blank          ;
        LDR     R1,tool_list            ; -> tool sprite list
d1916 4
a1919 5
; is it our window that has input focus?
;
        LDR     R2,[handle, #w_flags]   ; get window flags
        TST     R2,#ws_hasfocus         ; does our window have the input focus?
        ADDNE   R1,R1,R0,LSR #1         ;
d1927 4
a1930 8
        ADDEQ   R1,R1,R0,LSR #2
;
        MOV     R3,x0
        MOV     R4,y0                   ; x,y co-ordinates to plot title sprites at
;
        ADRL    R0,tool_plotparams
        LDMIA   R0,{R0,R5,R6,R7}        ; R0,R5-R7 => sprite op information
        Push    "R10,R11"               ; preserve these - they are important
d2071 3
a2075 3

        LDR     R0,[handle, #w_flags]   ; get window flags
        TST     R0,#ws_hasfocus         ; does our window have the input focus?
a2076 5
        MOVNE   R0,#tool_blank          ;
        ADDNE   R10,R10,R0,LSR #1       ;
;
        ADRL    R0,tool_plotparams
        LDMIA   R0,{R0,R5,R6,R7}        ; get the plotting parameters
d2146 6
a2151 3

        MOVEQ   R2,#tool_blank          ;
        ADDEQ   R10,R10,R2,LSR #2
d2271 2
a2274 3

        LDR     R0,[handle, #w_flags]   ; get window flags
        TST     R0,#ws_hasfocus         ; does our window have the input focus?
a2275 5
        MOVNE   R0,#tool_blank          ;
        ADDNE   R10,R10,R0,LSR #1       ;
;
        ADRL    R0,tool_plotparams
        LDMIA   R0,{R0,R5,R6,R7}        ; get the plotting parameters
d2344 6
a2349 3

        MOVEQ   R2,#tool_blank          ;
        ADDEQ   R10,R10,R2,LSR #2
d2353 1
a2353 1
35      LDR     R2,[R10,#tool_hbarl]
@


4.25
log
@Fix for null pointer dereference & data abort on swapping to no toolsprites
Way back in Wimp-4_76 the range check for being in ROM (in the free tool area function) was reworked as the ROM was no longer at the top of the 64M address space. In doing so the sense of the function got inverted and actually the tool area was not freed at all.
The result of this would be that swapping to no toolsprites (for that retro RISC OS 2 look) would data abort when the kernel tried to plot a sprite from address 0 because the check prior to the title bar plot believed a tool area existed.

Version 5.29. Tagged as 'Wimp-5_29'
@
text
@d839 4
d2935 1
d2940 1
d2945 1
a2945 1
        BIC     R2,R2,#1
@


4.24
log
@Change titlecolour variable to truetitlecolour
The word wide variable actually contains the RGB value, rename this to be distinct from the 4 bit Wimp colour, to make searching easier.
No change to binary, not tagged.
@
text
@d1142 1
a1142 1
        BNE     %FT01
d3167 1
a3167 1
; White - rgb_lightgrey - Black   --->   White - [titlecolour] - [truetitlefg]
@


4.23
log
@Introduce definitions of the 16 standard Wimp colours
Substitute magic numbers through the code.
Squash some UAL warnings from missing #'s in Wimp10.s

Version 5.27. Tagged as 'Wimp-5_27'
@
text
@d3184 1
a3184 1
        LDR     R4, titlecolour
@


4.22
log
@Refinements to disc based targets especially
Previous attempt to disable Sprites11 support for 3.10 and 3.50 hadn't spotted it was reenabled in the common options, also the Sprites11 switch was also tied up in Wimp$IconTheme support.
Title bars would flicker when picked up when using a tool sprite set with no 'p' pushed equivalents on RISC OS 4.0x due to screen cache.
Makefile now installs a default set of tools & sprites when target is ThemeDefs.
CLI limit reduced to 256 pre Ursula to save RAM.

Options/!Common:
  Promote Sprites11 switch into !Default
  Remove fixrmatools
Options/!Default:
  Sprites11 true by default
  LongCommandLines true by default, false on targets pre Ursula
  Remove ServiceCallTable (harmless to have it in all cases)
NewSWIs.s:
  Enable Wimp_Extend 13 all the time
Wimp01.s:
  Reduce RMA use by vital 1.5k for non long command line case
  Change sense of Sprites11 switch to adopt all its previous functionality, but not look for '11' suffix when the switch is false
  Adopt ServiceCallTable switch permanently
Wimp02.s:
  Comments ammended
Wimp07.s:
  Range of ADR
Wimp10.s:
  Change sense of Sprites11 switch to adopt all its previous functionality, but not look for '11' suffix when the switch is false
  Adopt :LNOT: fixrmatools switch permanently
  Supress title bar sprite plotting when none of the sprites exist

Version 5.25. Tagged as 'Wimp-5_25'
@
text
@d147 1
a147 1
        MOV     R0,#black
d399 11
a409 23
white           * 0
lightgrey       * 1
grey            * 2
midgrey         * 4
darkgrey        * 5
darkergrey      * 6
black           * 7

red             * 11
cream           * 12
orange          * 14

 [ NCErrorBox
ct_in           = darkgrey,   darkgrey,   darkergrey, darkergrey
ct_out          = darkergrey, darkergrey, darkgrey,   darkgrey
 |
ct_in           = white,     white,     midgrey,   midgrey
ct_out          = midgrey,   midgrey,   white,     white
 ]
ct_inshallow    = white,     white,     grey,      grey
ct_outshallow   = grey,      grey,      white,     white
ct_cream        = cream,     cream,     cream,     cream
ct_grey         = lightgrey, lightgrey, lightgrey, lightgrey
d881 2
a882 2
        ASSERT  tool_scaling = tool_maskop +4
        ASSERT  tool_transtable = tool_scaling +4
d2019 2
a2020 6
        LDR     R2, [R1,tool_tbarlcap]
        LDR     R14,[R1,tool_tbarrcap]
        ORR     R2,R2,R14
        LDR     R14,[R1,tool_tbarmidb]
        ORR     R2,R2,R14
        LDR     R14,[R1,tool_tbarmidt]
d2022 4
d3167 1
a3167 1
; White - &bbbbbb00 - Black   --->   White - [titlecolour] - [truetitlefg]
@


4.21
log
@Slacken pointer checks
The pointer comparison checking required when running in a system with > 64M memory was tightened up from Wimp-4_75 to Wimp-4_76, but to allow the module to target pre RISC OS 5 systems an option to relax those checks is required.
Each check has been revisited and where appropriate demarked with a "AcceptLoosePointer" macro, which just remaps the pointer into the stricter form and carries on. In the strict checking case, the macro reduces to nothing.

Detail:
Add AcceptLoosePointers switch.
Retire singular use of StrongARM switch (calling XOS_SynchroniseCodeAreas is harmless pre StrongARM anyway).
Rename Ursula_RPC options to RO400.
Put duplicate documentation in the attic.
Allow -2 or -1 as the iconbar handle in Wimp_ResizeIcon (ticket #203).
Tighten up the list terminator check in the DebugMemory switch of Memory.s

Tested on RISC OS 3.10 (emulated), 3.50, 3.60, 3.70, 4.02.

Version 5.24. Tagged as 'Wimp-5_24'
@
text
@a566 1
      [ Sprites11
d579 6
a597 28
      |
        MOV     R5,#"2"                 ; first char is "2"
;
        MOV     R0,#-1
        MOV     R1,#VduExt_ModeFlags
        SWI     XOS_ReadModeVariable    ; get the flags for the current mode
        TST     R2,#Flag_HiResMono
        MOVNE   R6,#"3"                 ; if hi-res mono then "23"
        BNE     %FT05                   ; and exit 'cos it has been found
;
        MOV     R1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        MOV     R3,R2                   ; = Xeig
;
        MOV     R1,#VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        CMP     R2,#1                   ; if both Xeig and Yeig <= 1 then use 22 postfix
        CMPLS   R3,#1
        MOVLS   R6,#"2"
        MOVHI   R5,#0
        MOVHI   R6,#-1
;
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        TEQ     R2,#0                   ; is it a monochrome mode?
        ADDEQS  R6,R6,#1
        MOVEQ   R5,#"0"                 ; use 23 if was 22, else 0.
      ]
a634 1
      [ :LNOT: fixrmatools
a635 1
      ]
d667 1
a667 2
;
        [ :LNOT: fixrmatools
a668 1
        [ Sprites11
d704 1
a704 1
        MOVEQ   R6,#8                   ; pretend '0' was '28' so we try '24'next
a727 65
        |

        CLRV
        LDRB    R14,spritecachevalid
        TEQ     R14,#0
        BLEQ    cachespriteaddress      ; try with postfix
        BVS     %FT03                   ; the list may exist, but this one failed
        LDRB    R14,spritecachevalid
        TEQ     R14,#0
        BEQ     %FT07                   ; the list exists and we succeded
03
        LDR     R14,list_at
        CMP     R14,R14,ASR #31
        BNE     %FT05                   ; the list exists, but the search failed
        MOV     R14,#1
        STRB    R14,spritecachevalid    ; list doesn't exist
        LDR     R14,thisCBptr
        Push    R14
        ADRL    R14,tool_areaCB
        STR     R14,thisCBptr
        BL      cachespriteaddress
        STRVSB  R2,[R4]
        BLVS    cachespriteaddress
        Pull    R14
        STR     R14,thisCBptr
        B       %FT07

05
        CLRV
        STRB    R2,[R4]                 ; try without the suffix
        BL      cachespriteaddress
        ; drop through...
        ]

        |

        BL      cachespriteaddress
; this will fail if the tool list cannot be remade, (eg. due to lack of RMA)
; so try with thisCBptr -> tool_areaCB  which will cause OS_SpriteOp to be used (NK 3.26)
        BVC     %FT07
        Push    "R0"
        LDR     R0,thisCBptr
        Push    "R0"
        ADRL    R0,tool_areaCB
        STR     R0,thisCBptr
        BL      cachespriteaddress
        Pull    "R0"
        STR     R0,tool_areaCB
        Pull    "R0"
        BVC     %FT07

        STRVSB  R2,[R4]
        BLVS    cachespriteaddress      ; and if that fails then without postfix

        BVC     %FT07
        Push    "R0"
        LDR     R0,thisCBptr
        Push    "R0"
        ADRL    R0,tool_areaCB
        STR     R0,thisCBptr
        BL      cachespriteaddress
        Pull    "R0"
        STR     R0,tool_areaCB
        Pull    "R0"
        ]
a741 1
        [ true
a745 1
        ]
d1254 1
d2031 10
d2047 1
a2047 1
; *non selected* title bar so attempt to plot the surround
d2075 1
a2075 1

@


4.20
log
@Fix RMA corruption when caching colour translation tables
Detail:
  s/Wimp10 - cachetoolspritedata was using two slightly different ColourTrans calls for reading the table size and then filling the table in. This was resulting in the 'generate wide table' flag sometimes being ignored when the table size was checked, resulting in too little memory being allocated and so heap corruption when the table generation call overflowed the end.
Admin:
  Tested on Pandora
  Fixes "not a heap block" errors when entering desktop


Version 5.21. Tagged as 'Wimp-5_21'
@
text
@d43 1
@


4.19
log
@Add support for wide translation tables for window tool furniture
With the introduction of 16bpp/32bpp modes it became possible to request tables from ColourTrans which used > 1 byte per colour, but the Wimp wasn't using this extension. Therefore tool sprites designed in 8bpp or less would be quantised horribly when plotted in a 16bpp or 32bpp mode.
The Wimp now requests and plots with a wide table, and to avoid thrashing ColourTrans so much with the prevalence of individually paletted icon sprites, keeps the table seperately to the icon sprites ones. At worst (in 32bpp) this uses an extra 256x4 bytes of RAM.
Trace.s: Split out the tracing routines from Wimp10 as it was getting a bit big.
Tiling.s: Namespace change for the icons versus tools distinction. Removed some unnecessary PC+8/PC+12 confused NOPs.
Tiling3D.s: Namespace change for the icons versus tools distinction.
Wimp01.s: New set of variables to track the tool translation tables separately. Various jiggling to keep ADRs in range.
Wimp02.s: Namespace change. Remove some double handling in Wimp_SetColourMapping.
Wimp04.s: Namespace change. Made factor rationalisation common to both the icon and tool grinding code. Removed dual use of cachespritedata for both icons and tools. The tintfunc moves to Wimp10. Service_InvalidateCache confusion resolved by adding a new flag to remember that the tools need regenerating rather than just marking the tool list as missing (which subsequently got restored in Tool_SpriteOp without actually doing any palette work.
Wimp10.s: Label tools_area renamed as it was immensely confusing to have that (which was actually holding the RMA allocation of the tool_list) and tool_area (which contains the sprite area) hanging around. Changed references to use tools-only cachetolspritedata routine. Added 'wide' flags to sprite op and colour trans calls. Tool_SpriteOp changed to actually regenerate the colour tables when they're known invalid (previously the tools list pointer was merely restored and no colour tables used). Trace functions extracted. Resolved confusion as to what recache_tools_trans and recache_tools_trans2 should be doing.

Tested with 4bpp "NewLook" sprites in 4bpp/8bpp/16bpp/32bpp and 8bpp smooth greyscaled "Steel" tool sprites in same modes.
Also ran a task window doing repeated Service_InvalidateCache calls while monitoring the RMA for leaks.
Generally navigated around some directories to ensure that inverse icons (during double click) and filer windows (with individually paletted sprites) were being rendered.

Version 5.20. Tagged as 'Wimp-5_20'
@
text
@d3185 3
d3189 1
@


4.18
log
@Tabs expanded in Wimp10
Not tagged.
@
text
@d637 1
a637 1
        ADRL    R14,tools_area
d649 1
a649 1
        ADRVCL  R14,tools_area
a944 16
       [ false

        LDR     R2,pixtable_at
        TEQ     R2,#0
        LDRNE   R1,tool_transtable
        TEQNE   R1,R2                   ; if they're the same, don't free

        MOVNE   R0,#ModHandReason_Free
        BLNE    XROS_Module

        LDR     R2,tool_transtable
        STR     R2,pixtable_at          ; attempt to reuse area
        ADRL    R14,tools_trans_size
        LDR     R2,[R14]
        STR     R2,pixtable_size
       |
d946 1
a946 2
       ]
        BL      cachespritedata         ; attempt to build a suitable pixtrans table
d954 5
d960 2
a961 2
        LDR     R1,needsfactors         ; do we need to do translation
        TEQ     R1,#0
a963 1
        MOV     R1,#8
d965 1
a965 1
        LDRNE   R3,pixtable_at
d970 1
a970 1
        LDR     R1, tool_area
d973 4
a976 4
        CMP     R1, R2
        CMPHS   R3, R1
        MOVHS   R1, #0                  ; pretend ROM toolsprites are unmasked
        MOVLO   R1, #8
d978 2
a979 1
        MOV     R1,#8
d982 1
a982 1
        LDR     R3,pixtable_at
a995 4
        MOVNE   R0,#0
        STRNE   R0,pixtable_at
        STRNE   R0,pixtable_size        ; flag as no active pixtable ('cos we stole it!)

d997 1
a997 1
        ADR     R14,factors
d1003 1
a1003 1
        ADRNE   R14,factors
d1007 1
a1007 1
        ADR     R14,factors
d1012 1
a1012 9
;
     [ true
; we store info about the current pixtable so that we can reuse it without freeing RMA
; this can become very important as RMA begins to run out.

        LDR     R0,pixtable_size
        ADRL    R1,tools_trans_size
        STR     R0,[R1]
     ]
d1206 2
a1207 2
;; in   [tool_transtable] -> table / =0 for none
;; out  [tool_transtable] = 0 (block released)
d1214 1
a1214 1
        LDR     R2,tool_transtable
d1220 1
d1481 1
a1481 1
        BL      recache_tools_trans     ; if not, try to get one again
d1492 1
a1492 1
; scroll bars are a special case - so handle seperatelym
d3010 8
a3017 1
        [       debug
d3019 17
a3035 2
; Some extra tracing routines by Jonathan. All preserve all registers and
; all flags
d3037 8
a3044 1
; HostFS_WriteC * &40102
d3046 2
a3047 2
;---------------------------------------------------------------------------
trace_char ROUT
d3049 2
a3050 1
; R0 = character to trace
d3052 14
a3065 1
        EntryS  "R0, R1, R2"
d3067 3
a3069 4
        CMP     R0, #32
        BLT     |trace_char: nonprintable character|
        CMP     R0, #127
        BGE     |trace_char: nonprintable character|
d3071 5
a3075 7
|trace_char: printable character|
        ;write character
        SWI     HostFS_WriteC
        ;if it's a backslash, write it again
        CMP     R0, #"\\"
        SWIEQ   HostFS_WriteC
        B       |trace_char: exit|
d3077 4
a3080 3
|trace_char: nonprintable character|
        CMP     R0, #:CHR: 10
        BNE     |trace_char: control character|
d3082 1
a3082 2
|trace_char: linefeed|
        SWI     HostFS_WriteC
d3084 8
a3091 2
        MOV     R0, #:CHR: 13
        SWI     HostFS_WriteC
d3093 1
a3093 1
        B       |trace_char: exit|
d3095 3
a3097 2
|trace_char: control character|
        ;save the character
d3099 43
a3141 2
        MOV     R1, R0
        ADR     R2, |trace_char: digits|
d3143 1
a3143 2
; R1 = character to trace
; R2 -> representation table
d3145 3
a3147 2
        MOV     R0, #"\\"
        SWI     HostFS_WriteC
d3149 11
a3159 2
        MOV     R0, #"x"
        SWI     HostFS_WriteC
d3161 32
a3192 4
        ;trace top nybble
        MOV     R0, R1, LSR #4
        LDRB    R0, [R2, R0]
        SWI     HostFS_WriteC
d3194 1
a3194 4
        ;trace bottom nybble
        AND     R0, R1, #&F
        LDRB    R0, [R2, R0]
        SWI     HostFS_WriteC
d3196 4
a3199 2
|trace_char: exit|
        EXITS
d3201 3
a3203 5
|trace_char: digits|
        =     "0123456789ABCDEF"
        ALIGN
;---------------------------------------------------------------------------
trace_string ROUT
d3205 5
a3209 1
; R0 -> string to trace
d3211 3
a3213 1
        EntryS  "R0, R1"
d3215 2
a3216 11
        MOV     R1, R0
; R1 -> string to trace

        B       |trace_string: end loop|
|trace_string: start loop|
        BL      trace_char
        ADD     R1, R1, #1
|trace_string: end loop|
        LDRB    R0, [R1]
        CMP     R0, #:CHR: 0
        BNE     |trace_string: start loop|
d3218 1
a3218 3
        EXITS
;---------------------------------------------------------------------------
trace_decimal ROUT
d3220 12
a3231 1
; R0 = integer to trace
d3233 2
a3234 1
        EntryS  "R0, R1, R2"
d3236 2
a3237 4
        SUB     SP, SP, #16
        MOV     R1, SP
        MOV     R2, #15
        SWI     OS_ConvertInteger4
d3239 11
a3249 3
        ;trace it
        BL      trace_string
        ADD     SP, SP, #16
a3251 2
;---------------------------------------------------------------------------
trace_hex ROUT
d3253 91
a3343 1
; R0 = integer to trace
d3345 2
a3346 1
        Push    "R0, R1, R2, LR"
d3348 6
a3353 36
        SUB     SP, SP, #16
        MOV     R1, SP
        MOV     R2, #15
        SWI     OS_ConvertHex8

        ;trace it
        BL      trace_string
        ADD     SP, SP, #16

        Pull    "R0, R1, R2, PC",, ^
;---------------------------------------------------------------------------
trace_nl ROUT

        EntryS  "R0"

        MOV     R0, #:CHR: 10
        BL      trace_char

        EXITS

        ]

Tool_SpriteOp
        EntryS  "R0,R1"
      [ false ; fastborders
; This reason code is only generated when fastborders is active - but this comparison
; is flawed anyway, because bit 9 of R0 is always set at this stage!!  BJGA May 1998
        TEQ     R0,#SpriteReason_PutSpriteUserCoords
        BEQ     %FT05                    ; no trans table needed if plotting
      ]
        LDR     R1,tool_list
        TEQ     R1,#0
        BLEQ    recache_tools_trans
05
        LDR     R1,tool_area             ; R1 is quite often wrong!
        BIC     R2,R2,#1
d3355 2
a3356 12
        SWI     XOS_SpriteOp
        LDR     R1,tool_list             ; if the tool list is wrong then reset the pointer
        TEQ     R1,#0
        ADREQL  R1,tools_area
        LDREQ   R1,[R1]
        STREQ   R1,tool_list
        EXITS


recache_tools_trans
        Push    "lr"
        ADRL    R2,tools_area
d3360 1
a3360 2
        TEQ     R2,#0
        BEQ     %FT99
d3362 6
a3367 1
        B       %FT99
d3369 2
a3370 10
99
        CLRV                            ; clear errors
        Pull    "PC"

 [ TrueIcon3
; In: R2 -> tool_list
; note that this code seems once to have been part of recache_tools_trans, but was dead
; code until the direct_tools_trans2 label was added as part of the TrueIcon3 work
recache_tools_trans2
        Push    "R0-R5,R14"
d3375 1
a3375 1
        STR     R2,lengthflags
d3377 2
a3378 6
        ; if pixtable is already in use, we must free it up before we re-use all
        ; the the standard pixtable variables in order to invoke cachespritedata
        LDR     R2,pixtable_at
        CMP     R2,#0
        MOVNE   R0,#ModHandReason_Free
        BLNE    XROS_Module
d3380 1
a3380 2
        LDR     R2,tool_transtable      ; reuse tool_transtable memory area
        STR     R2,pixtable_at
d3382 2
a3383 2
        MOV     R14,#0
        STR     R14,tool_transtable     ; for safety, make sure that only one variable points to it at once
a3384 14
        ADRL    R5,tools_trans_size
        LDR     R2,[R5]
        STR     R2,pixtable_size
        BL      cachespritedata         ; this sets up pixtable area
        BVS     %FT98

        LDR     R0,pixtable_size
        STR     R0,[R5]
        LDR     R0,pixtable_at
        STR     R0,tool_transtable
        MOV     R0,#0
        STR     R0,pixtable_at          ; exit with standard pixtable marked as needing recalculation
        STR     R0,pixtable_size
98
d3386 1
a3386 1
        Pull    "R0-R5,PC"
@


4.17
log
@Fix getborder thinking indirected sprites have validation strings
Detail:
  s/Wimp10 - Corrected interrogation of icon flag word IST bits to avoid trying to parse the sprite area pointer of an indirected sprite as a validation string
Admin:
  Tested on BB-xM with high processor vectors
  Fixes crash when dragging file icons in saveas dialogs


Version 5.16. Tagged as 'Wimp-5_16'
@
text
@d608 5
a612 5
	CMP	R2,#1			; if both Xeig and Yeig <= 1 then use 22 postfix
	CMPLS	R3,#1
	MOVLS	R6,#"2"
	MOVHI	R5,#0
	MOVHI	R6,#-1
d849 4
a852 4
	TEQ	R5,#1
	LDREQ	R5,[sp]
	ORREQ	R5,R5,#1
	STREQ	R5,[sp]			; store mask status
d921 3
a923 3
	LDR	LR,iconise_width
	TEQ	LR,#0
	STREQ	R1,iconise_width
d940 1
a940 1
	BIC	R2,R2,#1		; strip our mask bit
d1167 1
a1167 1
	STR	R1,iconise_width
d1426 3
a1428 3
;;	R6 = button attributes
;;	R7 = mouse flag
;;	R8 = old button state
d1499 1
a1499 1
	EXIT	EQ		      	; nope, so return
d1502 6
a1507 6
	BNE	%FT05
	Push	"R2"			; R2 corrupted :-(
	BL	recache_tools_trans	; if not, try to get one again
	Pull	"R2"
	LDR	R3,tool_list
	TEQ	R3,#0
d1627 2
a1628 2
	CMP	handle,#nullptr
	EXIT	EQ
d1673 7
a1679 7
	; Actually, lets do this immediately
	BL	int_redraw_window
invglp	EXIT	VS
	TEQ	R0,#0
	EXITS	EQ
	BL	int_get_rectangle
	B	invglp
d1686 3
a1688 3
	[ IconiseButton
	= iconposn_iconise
	]
d1711 3
a1713 3
	[ IconiseButton
	= tool_iconise
	]
d1729 3
a1731 3
	[ IconiseButton
	= tool_piconise
	]
d1740 1
a1740 1
        = tool_ptoggle			; value not used, but non-0 to indicate highlightable
d1804 3
a1806 3
	TST	R2,#1
        BLNE    solidrectangle	     	; corrupts flags :-(
	TST	R2,#1
d2026 3
a2028 3
	TST	R2, #1
        BLNE    solidrectangle	     	; corrupts flags :-(
	TST	R2, #1
d2690 1
a2690 1
	BNE	%FT50
d2693 1
a2693 1
	SETV
d2703 6
a2708 6
	; is the font the same as the last one we looked for ?
	ADRL	R14,fontnamebuffer
	LDRB	R8,[R14]
	TEQ	R8,R2
	ADDEQ	R6,R14,#1
	BEQ	fontinR6
d2710 1
a2710 1
	STRB	R2,[R14]
d2729 2
a2730 2
        ADRL	R14,fontnamebuffer
        Push	R6
d2732 5
a2736 5
	LDRB	R7,[R6],#1
	STRB	R7,[R14,#1]!
	CMP	R7,#31
	BGE	%BT50
	Pull	R6
d3182 1
a3182 1
	BIC	R2,R2,#1
d3215 1
a3215 1
        BIC	R2,R2,#1
@


4.16
log
@  Allow a different set of window toolicons for the window with the input focus.
Detail:
  Previous versions of the Window Manager required toolicons to have pixels
  that were transparent so that the background colour could be used to indicate
  whether a window had input focus or not. This means that new sets of toolicons
  either have to have transparent pixels or lose indication of input focus.
  To remove this limitation the support for toolicons has been extended so
  that a different set of toolicons can be used for the window with the input
  focus.

  The new icons have the prefix 'f' added to their names as follows:
    <toolname>    standard version of toolicon
    p<toolname>   pressed version of toolicon
    f<toolname>   focus version of toolicon
    pf<toolname>  pressed+focus version of toolicon

  Code has been added to ensure that all toolicons are represented.
  This is done in two stages; first the pressed icons are checked and for any
  missing its non-pressed equivalent will be filled in. Next the focus icons
  are checked and for missing ones its non-focus equivalent will be used.
Admin:
  Tested on Iyonix RO5.11
Author:
  Fred Graute

Version 5.03. Tagged as 'Wimp-5_03'
@
text
@d39 1
a39 2
        TST     R1,#if_sprite
        TSTEQ   R1,#if_text
@


4.15
log
@Added a couple of new Wimp_TextOp reason codes. Current clients are Filer
2.08 and Pinboard 0.80.

Version 4.88. Tagged as 'Wimp-4_88'
@
text
@d430 9
a438 4
;; All icons are allowed to give two states; normal + pressed, all gadgets
;; must be defined with the same palette and same mode, mixing is not
;; allowed.  Sprites are allowed to have mode prefix to allow different
;; depths to be supported.
d445 2
a446 2
;; The table describes the sprite name and which information is important, such
;; as its width + depth.
d448 3
d456 12
a467 5
        AddIcon back,,"bicon", back_width, title_height
        AddIcon close,,"cicon", close_width, title_height
        AddIcon toggle,,"ticon", vscroll_width, title_height
        AddIcon toggle1,,"ticon1", vscroll_width, title_height
        AddIcon size,,"sicon", vscroll_width, hscroll_height
d469 2
a470 2
	AddIcon iconise,,"iicon", iconise_width, title_height
	]
d472 26
a497 26
        AddIcon up,,"uicon", vscroll_width, up_height
        AddIcon down,,"dicon", vscroll_width, down_height
        AddIcon right,,"ricon", right_width, hscroll_height
        AddIcon left,,"licon", left_width, hscroll_height

        AddIcon tbarlcap,,,title_left,title_height
        AddIcon tbarmidt,,,title_sectionwidth,title_topheight
        AddIcon tbarmidb,,,title_sectionwidth,title_bottomheight
        AddIcon tbarrcap,,,title_right,title_height

        AddIcon vwelltcap,no,,vscroll_width,vscroll_top
        AddIcon vwellt,no,,vscroll_width,vscroll_topfill

        AddIcon vbart,,,vscroll_width,vscroll_blobtop
        AddIcon vbarmid,,,vscroll_width,vscroll_blobfill
        AddIcon vbarb,,,vscroll_width,vscroll_blobbottom

        AddIcon vwellb,no,,vscroll_width,vscroll_bottomfill
        AddIcon vwellbcap,no,,vscroll_width,vscroll_bottom

        AddIcon hwelllcap,no,,hscroll_left,hscroll_height
        AddIcon hwelll,no,,hscroll_leftfill,hscroll_height

        AddIcon hbarl,,,hscroll_blobleft,hscroll_height
        AddIcon hbarmid,,,hscroll_blob,hscroll_height
        AddIcon hbarr,,,hscroll_blobright,hscroll_height
d499 2
a500 2
        AddIcon hwellr,no,,hscroll_rightfill,hscroll_height
        AddIcon hwellrcap,no,,hscroll_right,hscroll_height
d503 2
a504 2
        AddIcon hblip,,,hscroll_blipwidth,hscroll_height
        AddIcon vblip,,,vscroll_width,vscroll_blipheight
d507 3
d512 1
a512 1
        AddIcon blank,no,"blicon",vscroll_width,hscroll_height
d731 1
a731 1
        MOVEQ   R6,#8                   ; pretend '0' was '28' so we try '24' next
d1085 2
d1090 60
d1324 1
a1324 1
        ADREQ   R1,default_tools
d1785 6
d1793 1
d2123 4
a2126 3
        LDR     R1,tool_list            ; -> list of the glyphs
        MOV     R3,x0
        MOV     R4,y0                   ; x,y co-ordinates to plot title sprites at
d2128 3
a2130 3
        ADRL    R0,tool_plotparams
        LDMIA   R0,{R0,R5,R6,R7}        ; R0,R5-R7 => sprite op information
        Push    "R10,R11"               ; preserve these - they are important
d2138 8
a2145 1
        BEQ     %FT20                   ; attempt to plot using pushed jobbies
a2180 8
        B       %FT30
;
; *selected* handle plotting the title bar
;

20      LDR     R10,title_sectionwidth  ; width of the title bar sections
        LDR     R11,dx
        ADD     R10,R10,R11             ; including an extra pixel!
a2181 27
        LDR     R2,[R1,#tool_ptbarlcap]
        BL      Tool_SpriteOp
        LDR     R2,title_left           ; plot the left hand edge
        ADD     R3,R3,R2
        ADD     R3,R3,R11               ; and then advance ready for next section
25
        CMP     R3,x1                   ; have we finished yet?
        BGT     %FT35                   ; yes, so exit
;
        LDR     R2,[R1,#tool_ptbarmidb]
        BL      Tool_SpriteOp            ; ... bottom
;
        Push    "R4"
        LDR     R2,[R1,#tool_ptbarmidt]
        MOV     R4,y1
        BL      Tool_SpriteOp
        Pull    "R4"                    ; ... top
;
        ADD     R3,R3,R10
        B       %BT25
35
        LDR     R2,title_right
        SUB     R3,x1,R2
        SUB     R3,R3,R11               ; move back from right edge to plot right cap
        LDR     R2,[R1,#tool_ptbarrcap]
        BL      Tool_SpriteOp
30
d2278 3
d2282 2
a2355 1
        BEQ     %FT20                   ; do it selected then!
d2357 4
a2360 1
; plot the scroll sausage bit in the middle *non selected*
d2362 1
a2362 1
        LDR     R2,[R10,#tool_vbarb]
a2383 28
        LDR     R10,[R10,#tool_vblip]   ; plot blip if its present
        B       %FT30
      |
        B       %FT40
      ]

; now plot the scroll sausage bit in the middle *selected*

20      LDR     R2,[R10,#tool_pvbarb]
        BL      Tool_SpriteOp
        LDR     R14,vscroll_blobbottom
        ADD     R4,R4,R14
        ADD     R4,R4,R1                ; base of the area
;
        LDR     R2,[R10,#tool_pvbarmid]
10
        CMP     R4,R11
        BLLE    Tool_SpriteOp
        LDRLE   R14,vscroll_blobfill
        ADDLE   R4,R4,R14
        ADDLE   R4,R4,R1
        BLE     %BT10                   ; loop back until blob section plotted
;
        LDR     R14,vscroll_blobtop
        SUB     R4,R11,R14
        SUB     R4,R4,R1
        LDR     R2,[R10,#tool_pvbart]
        BL      Tool_SpriteOp            ; and put the end cap on
d2385 1
a2385 4
      [ hvblip
;
        LDR     R10,[R10,#tool_pvblip]
30
d2480 3
d2484 2
a2556 5
        BEQ     %FT35
;
; handle plotting the horizontal scroll sausage *non selected*
;
        LDR     R2,[R10,#tool_hbarl]
d2558 2
a2559 1
        Debug   scroll,"tool_hbarl",R2
d2561 1
a2561 32
        BL      Tool_SpriteOp
        LDR     R14,hscroll_blobleft
        ADD     R3,R3,R14
        ADD     R3,R3,R1
;
        LDR     R2,[R10,#tool_hbarmid]
30
        CMP     R3,R11
        BLLT    Tool_SpriteOp
        LDRLT   R14,hscroll_blob
        ADDLT   R3,R3,R14
        ADDLT   R3,R3,R1
        BLT     %BT30
;
        LDR     R2,[R10,#tool_hbarr]
;
        Debug   scroll,"tool_hbarr",R2
;
        LDR     R14,hscroll_blobright
        SUB     R3,R11,R14
        SUB     R3,R3,R1,ASR #1         ; Round
;
        BL      Tool_SpriteOp
;
      [ hvblip
        LDR     R10,[R10,#tool_hblip]
        B       %FT40
      |
        B       %FT50
      ]

; handle plotting the horizontal scroll sausage *selected*
d2563 1
a2563 1
35      LDR     R2,[R10,#tool_phbarl]
d2572 1
a2572 1
        LDR     R2,[R10,#tool_phbarmid]
d2581 1
a2581 1
        LDR     R2,[R10,#tool_phbarr]
d2592 1
a2592 2
        LDR     R10,[R10,#tool_phblip]
40
@


4.14
log
@  Bugfixing, Sprites11 support and stretchy command windows.
Detail:
  * Bugfix: the contents of the pollword returned in the poll block by
    a PollWordNonZero event, where the pollword was flagged as high
    priority, was rotated by 8 bits due to a internal top-bit-set
    workaround. This no longer happens. (This was causing OmniClient never
    to complete initialisation on my machine.)
  * Extended the alternate resolution icon scheme for RAM/ROM sprites and
    toolsprites to be multi-pass, enabling the use of extra sprite sets for
    weird modes (most notably EX0 EY0 ones). After '23' or '0' suffixes
    (the latter still only applies to toolsprites), the suffix for the
    equivalent polychromatic resolution is tried. After rectangular
    suffixes, the next larger squarer suffix is tried. After '11', '22' is
    tried. Failing all of these, a match is attempted with no suffix.
  * The command window is now scaled and centred to match the current screen
    mode - up to a maximum size of 1280 x 1024 OS units.
  * Fixed the *WimpVisualFlags help strings (again).
  * Fixed 'task2' debugging to know about the structure of the SVC stack on
    32-bit machines.
  * Added support for generation of GPA files.
Admin:
  Tested on Tungsten.

Version 4.84. Tagged as 'Wimp-4_84'
@
text
@d2909 2
@


4.13
log
@  Merged in RISC OS 4.02 changes (including ROM patches). Also som bugfixes.
Detail:
  RISC OS 4 changes:
  * Font blending for desktop font (based on NC code, but now configurable)
  * 3-D window/menu/iconbar borders
  * Textured menu backgrounds
  * Loss of rubout box in unfilled text+sprite icons
  * *WimpVisualFlags controls various aspects of cosmetic changes above
  * Iconise button "slot" glyph slightly shorter (but only adopted in the RO400
    Resource directory)
  * Command window has front-window flag set
  * Byte at +39 of the window block has gained two new flag bits:
      bit 2 set => this window must never be given a 3D border
      bit 3 set => this window must always be given a 3D border
      (note that ResEd erroneously created windows with both bits set,
      this case is treated as though both bits were clear)
  * Another two colour specifiers on the end of C validation string command
    for icons controls the foreground and background colours to be used when
    the icon is selected
  * Pointer shape is correctly reprogrammed by the creation of icon
    underneath it
  * Full stops in writable icons are treated the same as spaces from the
    point of view of cursor navigation
  * spritesize routine returns a size of 0 if the sprite didn't exist
    (probably fixes some rendering problems)
  * Adjust-click on back icon brings window to front
  My changes:
  * DeleteRight turned on
  * Icon bar title background is set to default in all resource sets (avoids
    translation table recalc)
  * Error box title now cream across all resource sets
  * RISC OS 4 changes made 32-bit compatible / high addresses safe
  * Undocumented FullIconClipping option disabled
  * Command help made consistent for internationalised and non-
    internationalised builds
  * WimpVisualFlags defaults made sensible
  * Menu side width affected by ThreeD option at *run* time not assemble time
  * Right-clicking on menus with writable items no longer data aborts
  * Auto-opened menus are now at RHS of current icon (matches RISC OS 3.1)
  * Colour menus were knackered unless menu tiling was enabled
  * Fixed a bug whereby adding messages to a task that wanted all messages
    actually caused it to lose all other messages. The RISC OS 4 fix for
    this didn't work
  * Fixed bug introduced in version 4.76: tasks that wanted no messages got
    all of them
  * Autoscrolling is updated every 8 cs rather than every 12 cs
  * Added menu texture to pre-RISC OS 4 sprites files
Admin:
  Tested on Tungsten.

Version 4.78. Tagged as 'Wimp-4_78'
@
text
@d549 27
d602 1
d640 1
d642 1
d677 61
d768 3
a770 1
        B       %FT07
d772 1
a773 3
        ]

        [ fixrmatools
@


4.12
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@d316 1
a316 1
;; in   R3 = adjustment factor in OS_Units
@


4.11
log
@  Fixed a number of long-standing but low priority bugs in the Wimp.
Detail:
  * Any top-bit-set sprite area pointer in a window definition was treated
    as a null pointer, and any top-bit-set program name pointer in
    Wimp_ReportError was similarly treated as a null pointer.
  * For 24-bit window colour builds, when the Wimp drew a title bar with
    the input focus, and there were sprite icons in the previously redrawn
    window, and the most recently plotted icon sprite was unpaletted and not
    selected or inverted, then the translation table for the icon sprite (in
    the RMA) would leak. I suppose that's what I get for re-using a bit of
    dead code without fully working out why it was bypassed in the first
    place...
  * The key handling code used to be over-eager to read bytes from the
    keyboard buffer: it would attempt to read up to 6 bytes ahead to ease
    the recognition of UTF-8 character sequences. This could cause problems,
    in particular if F12 was one of those 6 bytes, then any following bytes
    would be queued for use as Wimp keypresses, rather than being left in
    the keyboard buffer for use by ShellCLI. The Wimp now analyses the first
    byte read to make a sensible estimate of how many bytes it needs to read
    ahead.
  * Select-dragging (including Select-resizing) of windows with panes used
    to soak up all the processor time. This was because when the task
    received an Open_Window_Request, it would re-open the pane in front of
    the main window, but this would cause the Wimp to believe that it had to
    re-open the main window at the front of the stack again when Wimp_Poll
    was next called. The problem has been fixed so that the Wimp now
    examines all the windows in front of the drag window to see if they have
    the pane window flag bit set, and doesn't reshuffle the windows if they
    all do. (Actually, the test is performed such that foreground windows
    in front of the drag window are also ignored.)
Admin:
  Tested on a desktop machine.

Version 4.65. Tagged as 'Wimp-4_65'
@
text
@d44 5
a48 4
        CMP     R3,#1                   ; is there a validation specified?
        MOVGE   R2,#WimpValidation_Border
        BLGE    findcommand
        BNE     %10                     ; if not present / valid then skip
d658 2
a659 2
        CMP     R14,#0
        BGT     %FT05                   ; the list exists, but the search failed
d734 5
a738 2
        CMP     R1, #ROMstart
        BGE     %FT66
d876 6
a881 3
        CMP     R1, #ROMstart
        MOVGE   R1, #0                  ; pretend ROM toolsprites are unmasked
        MOVLT   R1, #8
d1100 1
d1102 4
a1105 1
        RSBGTS  R14,R2,#ROMstart        ; it may have started life in ROM
d1107 1
a1107 1
        BLGT    XROS_Module             ; attempt to free the buffer (ignore errors)
d1109 1
a1109 1
        MOV     R0,#0
d3127 2
a3128 2
        MOVGT   R0,#ModHandReason_Free
        BLGT    XROS_Module
@


4.10
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d3095 5
d3101 3
a3103 2
; In: R2 must be set up as above
; note that the above doesn't fall through any more
d3105 1
a3105 3
        Push    "R14"
 ]
        Push    "R0-R5"
d3111 9
a3119 1
        LDR     R2,tool_transtable      ; try and reuse memory area.
d3121 4
d3130 1
d3136 1
a3136 1
        STR     R0,pixtable_at
a3138 2
        Pull    "R0-R5"
99
d3140 2
a3141 1
        Pull    "PC"
d3144 1
a3145 1

@


4.9
log
@  Rendering problems with Lazarus title bars and error box buttons fixed.

Detail:
  Title bars: one of the Ursula redraw optimisations was that if the title
  bar sprites had no mask, then the title bar is no longer filled in before the
  sprites are plotted. Lazarus' toolsprites were falling foul of this, because
  the title bar top and bottom sprites (tbarmidt/tbarmidb) had a lesser height
  than the end sprites (tbarlcap/tbarrcap). Because pre-Ursula Wimps filled
  in the title bar regardless, this may not have shown up in the past. The Wimp
  now has an additional check: if there is a gap between the title bar sprites,
  then it always fills in the title bar background before plotting the sprites.

  Error box buttons: the "illuminated" side of the 3D plinths have always been
  white, so they were getting lost against the white Lazarus UI background.
  Used Ursula Wimp icon colour validation string extension to colour the
  borders a uniform grey.

Admin:
  Tested on a desktop machine, soft-loading the Lazarus Wimp resources.
  Fixes faults 1115 and 1121.

Version 4.35. Tagged as 'Wimp-4_35'
@
text
@d32 1
a32 1
getborder Entry "R2,R4-R5"
d110 1
a110 1
        EXITS
d158 1
a158 1
        EXITS
d167 1
a167 1
        EXITS
d176 1
a176 1
        EXITS
d186 1
a186 1
        EXITS
d188 1
a188 1
plot_action Entry
d191 2
a192 2
        BLEQ    plot_slabout            ; action buttons are simply slabbed out
        BLNE    plot_slabin
a193 1
        EXITS
d266 1
a266 1
        EXITS
d283 1
a283 1
        EXITS
d309 1
a309 1
        MOVS    PC,LR
d325 1
a325 1
        MOVS    PC,LR
d337 1
a337 1
render_bbox Entry "R3"
d353 1
a353 1
        EXITS
d380 1
a380 1
        EXITS
d517 1
a517 1
maketoollist Entry "R1-R11"
d1023 1
a1023 1
        MOVS    PC,LR
d1046 2
a1047 1
        Pull    "R0,R2,PC",,^
d1069 2
a1070 1
        MOVS    PC,R1
d1085 1
a1085 1
freetoolarea Entry "R1-R4"
d1214 2
a1215 1
        Push    "R0,PC"
d1219 1
a1219 1
        TEQP    R14,#0                  ; restore flags
d1221 2
a1222 1
        Push    "R0,PC"
d1227 1
a1227 1
        TEQP    R14,#0                  ; restoring the flags word
d1274 1
a1274 1
        EXITS   EQ
d1283 1
a1283 1
        EXITS   GT                      ; No then ignore it
d1290 1
a1290 1
        EXITS   EQ                      ; if not start of press then ignore
d1318 1
a1318 1
	EXITS	EQ		      	; nope, so return
d1332 1
a1332 1
        EXITS   EQ                      ; return 'cos not allowed to toggle the state
d1360 1
a1360 1
        EXITS
d1379 1
a1379 1
        EXITS   GE                      ; if not then return now
d1391 1
a1391 1
        EXITS   GE                      ; no so give up on this object
d1402 1
a1402 1
        EXITS
d1414 1
a1414 1
        EXITS   GE                      ; if not then return now
d1431 1
a1431 1
        EXITS   GE                      ; no so give up on this object
d1447 1
a1447 1
	EXITS	EQ
d1451 1
a1451 1
        EXITS   GT                      ; exit if not the correct sort of icon
d1468 1
a1468 1
        EXITS
d1479 1
a1479 1
invalidate_glyph Entry "R0-R9"
d1787 1
a1787 1
plot_windowglyph_clipped  Entry "R0,R1,cx0,cy0,cx1,cy1,x0,y0,x1,y1"
d1806 1
a1806 1
        ADD     R14,SP,#10*4
d1827 1
a1827 1
draw_spriteglyph Entry "R0-R7"
d1868 1
a1868 1
dofunkytitlebar Entry "R0-R11"
d2028 1
a2028 1
        ADD     x0,sp,#sp_x0
d2085 1
a2085 1
dofunkyvscroll Entry "R0-R11"
d2115 1
a2115 1
        LDR     R3,[sp,#sp_x0]
d2123 2
a2124 2
        LDR     R4,[sp,#sp_y0]
        LDR     R11,[sp,#sp_cy0]
d2145 2
a2146 2
20      LDR     R4,[sp,#sp_cy1]
        LDR     R11,[sp,#sp_y1]
d2151 1
a2151 1
        LDR     R4,[sp,#sp_y1]
d2158 1
a2158 1
        LDR     R11,[sp,#sp_cy1]
d2169 2
a2170 2
20      LDR     R4,[sp,#sp_cy0]         ; min
        LDR     R11,[sp,#sp_cy1]        ; max
d2176 1
a2176 1
        LDR     R2,[sp,#sp_hand]
d2251 1
a2251 1
        LDR     R4,[sp,#sp_cy0]
d2256 1
a2256 1
        LDR     R14,[sp,#sp_cy1]
d2313 1
a2313 1
dofunkyhscroll Entry "R0-R11"
d2341 1
a2341 1
        LDR     R4,[sp,#sp_y0]
d2349 2
a2350 2
        LDR     R3,[sp,#sp_x0]
        LDR     R11,[sp,#sp_cx0]
d2371 2
a2372 2
15      LDR     R3,[sp,#sp_cx1]
        LDR     R11,[sp,#sp_x1]
d2377 1
a2377 1
        LDR     R3,[sp,#sp_x1]
d2384 1
a2384 1
        LDR     R11,[sp,#sp_cx1]
d2394 2
a2395 2
25      LDR     R3,[sp,#sp_cx0]         ; setup the region to plot the blob
        LDR     R11,[sp,#sp_cx1]
d2401 1
a2401 1
        LDR     R2,[sp,#sp_hand]
d2489 1
a2489 1
        LDR     R3,[sp,#sp_cx0]
d2494 1
a2494 1
        LDR     R14,[sp,#sp_cx1]
d2857 2
a2858 1
        EXITS
d2886 1
a2886 1
LoseFont Entry "R0"
d2893 5
a2897 4
        SWINE   XFont_LoseFont          ; if it is then lose it
        MOVNE   R0, #0
        STRNE   R0, systemfont

d2908 5
a2912 4
        SWINE   XFont_LoseFont          ; if it is then lose it
        MOVNE   R0, #0
        STRNE   R0, symbolfont

d2937 1
a2937 1
        Push    "R0, R1, R2, LR"
d2990 1
a2990 1
        Pull    "R0, R1, R2, PC",, ^
d3000 1
a3000 1
        Push    "R0, R1, LR"
d3014 1
a3014 1
        Pull    "R0, R1, PC",, ^
d3020 1
a3020 1
        Push    "R0, R1, R2, LR"
d3031 1
a3031 1
        Pull    "R0, R1, R2, PC",, ^
d3052 1
a3052 1
        Push    "R0, LR"
d3057 1
a3057 1
        Pull    "R0, PC",, ^
d3062 1
a3062 1
        Push    "R0,R1,lr"
d3082 1
a3082 1
        Pull    "R0,R1,PC",,^
@


4.8
log
@
my_StringBBox rewritten - effects are:
* Deprecated Font SWIs no longer used
* Height of UTF-8 strings now calculated correctly
* Fancy fonts in icons are now aligned the same as outline desktop-font icons
* Text rubout boxes for icons with text above the sprite are correctly sized

Lazy WimpSymbol subsitution implemented: characters are only substituted if
they are not already present in the font. For the first time, substitution
now works in UTF-8 text - but for the proper Unicode positions of the
relevant symbols, instead of usurping undefined positions (as in other
alphabets).

Version 4.10. Tagged as 'Wimp-4_10'
@
text
@d1900 15
d1918 1
@


4.7
log
@Adapted assembly process so that the choice of Options file (previously based
purely on the "System" variable) can be overridden by passing "OPTIONS=foo" as
an argument to either MkRom, or to amu/amu_machine directly, or indirectly,
by specifying it in the components file for a build. To accomplish this, it
was necessary to switch from using aasm to objasm - hence the large number of
source files affected in this commit.

Version 4.09. Tagged as 'Wimp-4_09'
@
text
@d2779 9
@


4.6
log
@UTF-8 support from previous version switched in; additional alphabet-
conditional support added as follows:
* Correctly converts character index returned from Font_FindCaret into byte
  index into raw string.
* Left-arrow, right-arrow, delete-left and delete-right now act as far as
  the next character boundary, instead of to the next byte.
* Menu item text justification works again (it relies on overwriting spaces
  with hard space characters, which are two-byte characters in UTF-8).
* General key handling code has been rewritten. The Wimp now has three
  internal key input buffers - one each for taking keyboard-generated,
  task-generated, and function-key-generated strings. Each input buffer is
  processed in chunks of one character, rather than one byte; malformed
  UTF-8 characters are rejected, so tasks don't have to worry about them
  (simplifying their character-handling code). There is also a key output
  buffer, to ensure that (UTF-8) sequences of Key_Pressed events are not
  broken up.
* As a result of the above, multiple calls to Wimp_ProcessKey are now
  possible between calls to Wimp_Poll. Previously, this resulted in bytes
  getting jumbled up - making it useless for input of UTF-8 characters.
* Multi-byte characters are inserted into writeable icons in one go, so you
  don't see a brief flicker of the "malformed character" symbol while the
  initial bytes are being inserted.
* Multi-byte characters that don't entirely fit in a writeable icon buffer
  are not inserted at all.
* A new validation string command ("U") can limit the contents of a
  writeable by number of characters, instead of bytes. This will hide the
  character sizes from the user interface.
* Allowable characters (validation string command "A") now works on Unicode
  characters and character ranges.
* Various other minor bugs are fixed (Wimp_ProcessKey 13 can activate a
  writeable menu item, Shift-arrow keys are always consistent in firing off
  Key_Pressed events, etc.)
* Password icons supported: one symbol is displayed for each character
  (instead of for each byte); the display character (validation string
  command "D") can be any UTF-8 character; correctly displays the caret
  after set-caret-by-index calls, even though characters in the processed
  string are different width to those in the raw string, in password icons.

Other changes:
* The border around NC-style error boxes is resized when the error window
  is grown or shrunk.
* Messages, CmdHelp and Template files made consistent across resource
  directories, including support for all Ursula features.
* ShrinkableAreas turned back on in System=RCA builds.
* User interface features of desktop OS builds standardised.

Version 4.06. Tagged as 'Wimp-4_06'
@
text
@d32 1
a32 1
getborder ENTRY "R2,R4-R5"
d92 1
a92 1
adjustforborder ENTRY "R1"
d133 1
a133 1
plot_editable ENTRY
d160 1
a160 1
plot_ridge ENTRY
d169 1
a169 1
plot_channel ENTRY
d178 1
a178 1
plot_default ENTRY
d188 1
a188 1
plot_action ENTRY
d207 1
a207 1
plot_slab ENTRY "R0-R4"
d338 1
a338 1
render_bbox ENTRY "R3"
d364 1
a364 1
render_line ENTRY
d518 1
a518 1
maketoollist ENTRY "R1-R11"
d1084 1
a1084 1
freetoolarea ENTRY "R1-R4"
d1119 1
a1119 1
ToolSprites_Code ENTRY "R0"
d1138 1
a1138 1
int_toolsprites ENTRY "R1-R6"
d1265 1
a1265 1
        ENTRY   "R0,R1,x0-y1,cx0-cy1"
d1440 1
a1440 1
modifytool_release ENTRY "R4,handle"
d1476 1
a1476 1
invalidate_glyph ENTRY "R0-R9"
d1578 1
a1578 1
plot_windowglyph ENTRY "R0-R9"
d1643 1
a1643 1
plot_windowglyph_vscaled  ENTRY "R0,R1,cx0,cy0,cx1,cy1,y0,y1"
d1715 1
a1715 1
plot_windowglyph_hscaled  ENTRY "R0,R1,cx0,cy0,cx1,cy1,x0,x1"
d1784 1
a1784 1
plot_windowglyph_clipped  ENTRY "R0,R1,cx0,cy0,cx1,cy1,x0,y0,x1,y1"
d1824 1
a1824 1
draw_spriteglyph ENTRY "R0-R7"
d1865 1
a1865 1
dofunkytitlebar ENTRY "R0-R11"
d2066 1
a2066 1
dofunkyvscroll ENTRY "R0-R11"
d2272 1
a2272 1
set_vclip ENTRY "R0,R4,x0-y1,R11"
d2294 1
a2294 1
dofunkyhscroll ENTRY "R0-R11"
d2510 1
a2510 1
set_hclip ENTRY "R0,R3,x0-y1,R11"
d2550 1
a2550 1
FindFont ENTRY  "R0-R10"
d2699 1
d2857 1
a2857 1
LoseFont ENTRY "R0"
d2917 1
a2917 1
        CMP     R0, #"\"
d2942 1
a2942 1
        MOV     R0, #"\"
@


4.5
log
@Spinner branch merged.
Changed to use srccommit.
All conditionals on "Version" removed.

Version 4.01. Tagged as 'Wimp-4_01'
@
text
@d411 1
a411 1
 [ BuildForNC
d776 1
a776 6
        Push    "R2"
        MOV     R0, #71
        MOV     R1, #127 ; read alphabet
        SWI     XOS_Byte
        Pull    "R2"
        TEQ     R1, #ISOAlphabet_UTF8
@


4.4
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d404 1
d411 4
d417 1
d487 1
a487 1
      [ Version >= 317 :LAND: hvblip
d1024 1
a1024 1
      [ Version >= 317 :LAND: hvblip
d1313 1
a1313 1
        
d2200 1
a2200 1
      [ Version >= 317 :LAND: hvblip
d2230 1
a2230 1
      [ Version >= 317 :LAND: hvblip
d2432 1
a2432 1
      [ Version >= 317 :LAND: hvblip
d2468 1
a2468 1
      [ Version >= 317 :LAND: hvblip
@


4.3
log
@ARTtmp branch folded in
@
text
@d69 4
d139 4
d150 1
d366 9
d377 1
d388 11
d418 1
a418 1

d726 6
d736 1
a736 1
;
d769 9
d783 1
a783 1

d870 6
d877 1
d890 3
a892 1
;        TEQ     R3,#0                  ; with fastborders
d1288 20
d1311 3
d1325 3
d1332 10
d1344 3
d1363 38
d1453 6
d1460 3
d1833 6
d1841 1
d1898 7
d1907 1
d2011 7
d2081 1
d2083 1
d2157 7
d2168 1
d2309 1
d2311 1
d2382 7
d2393 1
d3025 1
d3029 4
a3032 1
        Push    "R1,lr"
d3035 1
d3049 1
a3049 1
        Pull    "R1,PC",,^
d3062 6
a3067 1

d3070 1
a3070 1
	BIC	R2,R2,#1
d3094 1
@


4.3.2.1
log
@Fixed occasional lock-ups when error boxes displayed.
Added ALIGN directive before watchdog callback label.
Added option to select double-height VDU 4 modes.
Added German resources.
Added necessary options for parallel-port debugging via the PDebugM module.
@
text
@a2842 1

@


4.3.2.2
log
@Main new features in Ursula build so far
(some are also available in other builds):

* New icon highlighting scheme - hue rotated 180 degrees, photographic negative,
  darkened 25% - suits Ursula icons better.
* Release-button window tools compile-time switch turned on.
* Any "TASK" word cleared on exit from Wimp_OpenWindow, Wimp_GetWindowState,
  Wimp_ForceRedraw and Wimp_CloseDown.
* Child windows are no longer allowed to be opened inside the icon bar.
* Message_IconizeAt generation optimised, and no longer calls non-X SWIs.
* Message_IconsChanged implemented, and switched out on speed grounds.
* Wimp_ReadSysInfo 15 removed, replaced with (new) Wimp_Extend 11.
* Backwindows are now segregated from normal windows. A new category,
  foreground windows, are added, and stay above all other windows. (The error
  box template is updated to make it a foreground window.)
* ROM sprites override RAM sprites (and duplicate RAM sprites are deleted
  during the building of the sprite lookup list, preceding the first sprite
  plot after a sprite pool update).
* Wimp_ReadSysInfo 16 added, to return sprite area pointers in order of
  priority (Wimp_BaseOfSprites retains the ROM/RAM distinction).
* Error box code altered:
  + symbolic names used for offsets into tempworkspace
  + error button text buffer enlarged
  + stretched error buttons now shrink back for next use
  + int_flush_opens called at appropriate points to ensure buttons are seen to
    slab in, and to reduce flicker when redisplaying error box at a different
    width (also fixes some redraw bugs)
  + Cancel button given the R6 type border when it will be activated by Return
    (and is therefore moved to the extreme right in such cases)
  + Escape now always selects the second-right button (unless there's only one
    button!) - this also fixes a bug when there's a single user-defined button
  + keypresses in "xxx may have gone wrong" error boxes are now correctly
    interpreted - previously the buttons available in the underlying box were
    being used to determine the effect of keys
  + maximum number of buttons increased from 4 to 8, and the machine no longer
    crashes when the maximum is exceeded
  + window stretches horizontally to keep error message to 7 lines or less
* Bugfix: opening or creating a window with a minimum x visible area coordinate
  of -1 was leading to any of smearing/flickering/recursive drawing. (This was
  actually due to a failure to recognise which windows' positions had been
  updated.)
* Features merged in from spinner branch Wimp:
  + support for UpCall_MediaSearchEndMessage added
  + control-termination allowed in upcalls (used to require null-termination)
  + escape character switched to default during error box display, then
    switched back again afterwards
* GetRectangle filters are now called with (internal) window handle in R10.
* Autohourglass is deactivated whenever WrchV is invoked. (Also optimised.)
* Action button bugfixes:
  + action buttons now deselect if the pointer is dragged off and a window tool
    is the pressed before all the buttons have been released
  + action buttons now slab in following a long (autorepeating) press on a
    scroll arrow window tool
@
text
@a1233 17
; Unslab any slabbed-in action button
        Push    "R0-R2,handle"
        LDR     handle, border_windowselected
        CMP     handle, #nullptr
        BEQ     %FT01
        LDR     R0, border_iconselected
        CMP     R0, #nullptr
        BLE     %FT01
        MOV     R1, #0
        MOV     R2, #is_inverted
        BL      int_set_icon_state
        MOV     R0, #nullptr
        STR     R0, border_windowselected
        STR     R0, border_iconselected
01
        Pull    "R0-R2,handle"
        
a1322 3

        MOV     R4, #0
        STRB    R4, autorepeating       ; BJGA bugfix - deactivate autorepeat redraw optimisation
@


4.3.2.3
log
@Redraw of dragboxes when being resized/translated optimised to reduce flicker.

Autoscroll update period extended to 12cs to reduce flicker.

Added Wimp_ReadSysInfo 17 to return configured drag-and-drop scroll startup
delay (in cs) because the CMOS storage isn't easy to read.

Identified and bracketed changes from 3.9x responsible for 24-bit icon colours.

defaultfontcolours now works correctly again.

Introduced new icon colour code. This holds icon colours in 24 bits internally
throughout, rather than treating 24-bit colour specifiers as a special case.
This results in the following bugfixes/improvements:
 * 3D faces and moat colours, and slabbed-in action button backgrounds, can
   all be specified in 24-bits
 * fading of icons is now consistent across icon types, and utilises the
   colour range of >16 colour modes
 * 3D borders now get faded along with the rest of the icon
 * action buttons can now contain sprites (background is correct, and sprite
   is not inverted)
 * various cases where anti-aliasing didn't blend in to the background
   correctly are now fixed
 * conventional and 24-bit specifiers now behave equivalently to each other -
   the same colour specified either way behaves the same when faded, used as
   an EOR colour etc. (greys are now always dithered in 1-bpp modes, even if
   specified in 24-bit)
 * behaviour is now the same whether the Wimp font is the system font or a
   fancy font (amazingly, this wasn't always the case)
 * except for 3D icons, if the icon background matches the work area
   background, it is unaffected by fading - so for example, group boxes can now
   be faded correctly

Switched out AutoHourglass (Mike was concerned about the speed hit).

Corrected *Help syntax strings for On/Off configuration options.
@
text
@a134 4
      [ TrueIcon2
        BL      icon_fg
        BL      hollowrectangle
      |
a141 1
      ]
a356 9
      [ TrueIcon2
        LDR     R0, [R3], #4            ; get the line colour to be used
        LDR     R0, [wsptr, R0]
        Push    "R2-R4"
        LDR     R3, ditheringflag       ; set foreground
        MOV     R4, #0                  ; overwrite colour
        SWI     XColourTrans_SetGCOL
        Pull    "R2-R4"
      |
a358 1
      ]
a368 11
  [ TrueIcon2

ct_in
ct_inshallow    DCD     :INDEX: truefacecolour, :INDEX: truefacecolour, :INDEX: trueoppcolour,  :INDEX: trueoppcolour
ct_out
ct_outshallow   DCD     :INDEX: trueoppcolour,  :INDEX: trueoppcolour,  :INDEX: truefacecolour, :INDEX: truefacecolour
ct_cream
ct_grey         DCD     :INDEX: truewellcolour, :INDEX: truewellcolour, :INDEX: truewellcolour, :INDEX: truewellcolour

  |

d388 1
a388 1
  ]
a1875 7
      [ TrueIcon2
        LDR     R2, [handle, #w_flags]
        TST     R2, #ws_hasfocus
        LDREQB  R2, [handle, #w_tbcol]
        LDRNEB  R2, [handle, #w_tbcol2]
        STRB    R2, work_back_colour    ; this is where mungetruecolours looks for font background if unfilled
      ]
@


4.3.2.4
log
@Bugfixes:

Re-opening a menu structure containing a dialogue box (especially one
containing the caret) was causing data aborts under some OSes/builds.

The minimum title bar length is now the same for windows without line borders,
even if the vertical scroll bar is also absent. This prevents cases when the
title bar shrunk so far that a graphics clipping error occurred.

Wimp_DragBox was looking in R0 for its flags, rather than R3, as specified!

If the pointer was to the right of the central zone, vertical autoscrolling
was working too slowly.

On Service_SwitchingOutputToSprite, the Wimp now re-assesses its idea of the
screen limits. This prevents Wimp_PlotIcon plots outside the current screen
bounds from being optimised out.
@
text
@a2955 1
        LTORG
@


4.3.2.5
log
@The title bar, and the back, close and iconise buttons, are no longer redrawn
when a window is resized in just the vertical direction.

All window colours can now be specified in 24-bit colour.

Where a sprite is used to plot the back, close, title, iconise, toggle-size,
adjust-size or scroll arrow icons, the sprite is now plotted using a distorted
translation table, to give the sprites the appearance of being coloured
according to the window colours.

The 3D toolsprite set now has solid titlebar sprites.

The icon bar template now uses the standard title bar colours (this optimises
redraw because of the new border tinting code).

When the toggle-size icon or title bar are to be plotted using solid sprites,
the background is no longer filled in just prior to the event (although this
will still be performed if the relevant sprite is masked). This is to reduce
flicker. Similarly, the erroneous rectangle outlines plotted behind scrollbars
have been removed.

New "TASK"-form Wimp_ForceRedraw reason codes:
  R2 = 0 => redraw whole window border (includes line borders).
  R2 = 8 => redraw iconise button.
@
text
@a1738 6
      [ TrueIcon3
	TST	R2, #1
        BLNE    solidrectangle	     	; corrupts flags :-(
	TST	R2, #1
        BLNE    hollowrectangle         ; plot the borders of the gadget
      |
a1740 1
      ]
a1796 7
      [ TrueIcon3
        LDR     R14, tool_list
        LDR     R14, [R14, #tool_tbarmidt]
        TST     R14, #1                 ; is title bar solid?
        BICNE   R1,R1,#if_sprite:OR:if_text
        BLNE    drawicon_system         ; get the background / border plotted for the icon
      |
a1798 1
      ]
d1902 1
a1902 1
      [ TrueIcon2 :LAND: :LNOT: TrueIcon3
a1971 1
      [ :LNOT: TrueIcon3                ; don't think this is actually necessary
a1972 1
      ]
a2189 1
      [ :LNOT: TrueIcon3                ; don't think this is actually necessary
a2190 1
      ]
a2900 2
 [ :LNOT: TrueIcon3
; This won't have worked anyway, because bit 9 of R0 is always set. BJGA 7/5/98
a2906 1
 ]
d2929 1
a2929 6
 [ TrueIcon3
; In: R2 must be set up as above
; note that the above doesn't fall through any more
recache_tools_trans2
        Push    "R14"
 ]
d2932 1
a2932 1
        BIC	R2,R2,#1
@


4.3.2.6
log
@Fixed "multi-coloured borders" bug: a single TEQ statement had been commented
out when it should have been optioned out. Not my fault!!
@
text
@d864 1
a864 3
      [ :LNOT: fastborders
        TEQ     R3,#0                   ; not needed with fastborders set
      ]
d2919 3
a2921 4
        Push    "R0,R1,lr"
      [ false ; fastborders
; This reason code is only generated when fastborders is active - but this comparison
; is flawed anyway, because bit 9 of R0 is always set at this stage!!  BJGA May 1998
a2923 1
      ]
d2928 1
d2938 1
a2938 1
        Pull    "R0,R1,PC",,^
@


4.3.2.7
log
@Redraw of unfilled, font-specified icons now fixed; this caused antialising
errors, for example in CC applications' banner windows.

No longer maps anti-aliased system font character 128 to WimpSymbol tick;
this leaves character 128 free for use by Euro currency glyph.

Fixed Data Aborts in Wimp_SpriteOps 54, 57 and 58, and in *WimpKillSprite for
a sprite name found only in the ROM sprite pool.

Eureka window titles should now be redrawn correctly, without impacting the
redraw of Wimp-drawn titlebars, provided the ROM toolsprites are used. Note
that the toolsprite spritefile has regained sprite masks, but the colours
"behind" the mask are different to those in the last masked toolsprite file.
@
text
@a721 6
      [ TrueIcon3
        ; If these are the ROM toolsprites, assume all tools are unmasked
        CMP     R1, #ROMstart
        BGE     %FT66
      ]
;
d726 1
a726 1
66
a850 6
      [ TrueIcon3
        LDR     R1, tool_area
        CMP     R1, #ROMstart
        MOVGE   R1, #0                  ; pretend ROM toolsprites are unmasked
        MOVLT   R1, #8
      |
a851 1
      ]
@


4.3.2.8
log
@Corrected active point for autoscrolling pointers (was wrong in low-res modes).

Certain user-drawn dragbox routines (eg via DragASprite) don't pass the object
bounding box as the box; this was conflicting with one of the redraw
optimisations, and causing smearing when the underlying object was redrawn.
Relevant optimisation optioned out.

If a window stack-change causes the iconise button to appear or disappear,
this is now caught, and the window border is redrawn immediately.

Toggling of child windows now works - the return coordinates are linked to
the parent in the same way as the current ones. Note that this is unlikely to
be useful for anything other than alignment 0/0/0/0/0/0 children.

Return codes for the "Quit" and "Continue" buttons in "xxx may have gone wrong"
error boxes can now be specified.

Both scrollbars push in for adjust-drags.
@
text
@a1274 3
      [ PushBothBars
        Push    "R14"
      ]
a1305 3
      [ PushBothBars
        ADDEQ   sp, sp, #4*1
      ]
a1309 10
      [ PushBothBars
        Pull    "R14"                   ; check to see if an adjust click on a scrollbar
        AND     R14, R14, #button_right
        CMP     R4, #windowicon_verticalbar
        CMPNE   R4, #windowicon_horizbar
        TEQEQ   R14, #button_right
        LDREQ   R14, [handle, #w_flags] ; but only for windows with two scrollbars!
        MVNEQ   R14, R14
        TSTEQ   R14, #wf_icon5 :OR: wf_icon7
      ]
a1311 3
      [ PushBothBars
        BEQ     modify_bothscroll
      ]
a1327 38
      [ PushBothBars
modify_bothscroll
        CMP     R4, #windowicon_horizbar
        BEQ     %FT01

        BL      getvscrollcoords
        Debug   tools2,"v scroll? x,y, x0,cy0,x1,cy1 =>",R0,R1,x0,cy0,x1,cy1
;
        CMP     R0,x1                   ; is it within the scroll blob?
        CMPLT   R1,cy1
        CMPLT   x0,R0
        CMPLT   cy0,R1
        EXITS   GE                      ; if not then return now
;
        Debug   tools2,"hit v scroll!"
        B       %FT02
01
        BL      gethscrollcoords
        Debug   tools2,"h scroll? x,y, x0,cy0,x1,cy1 =>",R0,R1,x0,cy0,x1,cy1
;
        CMP     R0,cx1                  ; is it within the scroll blob?
        CMPLT   R1,y1
        CMPLT   cx0,R0
        CMPLT   y0,R1
        EXITS   GE                      ; no so give up on this object
;
        Debug   tools2,"hit h scroll!"
02
        MOV     R4, #windowicon_bothbars
        STR     R4, border_iconselected
        STR     handle, border_windowselected
        MOV     R4, #windowicon_verticalbar
        BL      invalidate_glyph
        MOV     R4, #windowicon_horizbar
        BL      invalidate_glyph
        EXITS
      ]

a1379 6
      [ PushBothBars
        CMP     R4, #windowicon_bothbars
        MOVEQ   R4, #windowicon_verticalbar
        BLEQ    invalidate_glyph        ; preserves flags
        MOVEQ   R4, #windowicon_horizbar
      ]
a2077 7
      [ PushBothBars
        LDR     R14, border_iconselected
        CMP     R14, #windowicon_verticalbar
        CMPNE   R14, #windowicon_bothbars
        LDREQ   R14, border_windowselected
        TEQEQ   R14, R2                 ; is it our window thats selected?
      |
a2081 1
      ]
a2294 7
      [ PushBothBars
        LDR     R14, border_iconselected
        CMP     R14, #windowicon_horizbar
        CMPNE   R14, #windowicon_bothbars
        LDREQ   R14, border_windowselected
        TEQEQ   R14, R2                 ; is it our window thats selected?
      |
a2298 1
      ]
@


4.3.2.9
log
@Text is now correctly justified when in an icon with validation string
commands R8, R9, R10, ...

R5/R6 type icons now behave more usefully with button types other than click,
release and auto-repeat.

Prevented coordinate overflow in dragboxes.

Stopped clipped dragboxes from flickering more than non-clipped ones.

Fixed a bug whereby data aborts occurred when generating the translation table
for inverted and/or shaded 256-colour sprites, if the first 256-colour sprite
plotted since the Wimp's cached translation table was invalidated (either by
Service_InvalidateCache or by plotting a 256-colour sprite after a non-256-
colour sprite one) was at an address that had since been invalidated or paged
out. This fixes a long-standing problem with 256-colour sprites in the desktop,
but which only happened sporadically.

Prevented palette corruption in paletted ( <256-colour) modes when the pointer
reverts from an autoscroll pointer to its original setting.

Fixed bug introduced in last build, where clicking on the bottom pixel row of a
horixontal scrollbar, or the left pixel column of a back icon, caused a crash.

All Wimp-drawn solid rectangles are now be plotted much faster - typically
around twice as fast - translating to a typical 30% increase in speed of
plotting filled icons. Improvements will be better still in cases where icons
are drawn in a non-contiguous order: this commonly affects Toolbox applications.

When a dialogue box is opened from a menu, the Wimp will no longer attempt to
place the caret in a shaded or deleted icon, but it will do so for a type-14
(writable/click/drag) icon, as well as the standard type-15 (writable) icons.
This brings it in line with KA-validation up/down arrow actions.
@
text
@a68 4
      [ true
        CMP     R4, #border_max         ; trap undefined cases immediately
        MOVHS   R4, #0
      ]
a1297 3
      [ PushBothBars
        ADDEQ   sp, sp, #4*1
      ]
@


4.3.2.10
log
@Re-inserted the fixed low-res autoscroll pointers (they disappeared in the
final softload ROM).
Fixed half-specified font-colour validation-string-command bug.
Partial UTF-8 support included, but switched out, since UTF-8 won't be any
theoretical future Ursula build.

Finally...
Cranked version number up to 4.00, to signify the end of Ursula development.
@
text
@a768 9
      [ UTF8
        Push    "R2"
        MOV     R0, #71
        MOV     R1, #127 ; read alphabet
        SWI     XOS_Byte
        Pull    "R2"
        TEQ     R1, #ISOAlphabet_UTF8
        BEQ     %FT88
      ]
d774 1
a774 1
88
@


4.2
log
@Merged WIMP imported
@
text
@d37 1
a37 1
        MOV     R5,#14                  ; default values
d198 1
a198 1
plot_slab ENTRY "R0-R3"
d202 37
d256 5
d262 13
d276 1
d289 1
d291 1
d296 1
d298 1
d395 1
a395 1
;; must be defined with the same palette and same mode, mixining is not
a412 1
        [ BounceClose
d414 2
a415 5
        |
        AddIcon close,no,"cicon", close_width, title_height
        ]
        AddIcon toggle,no,"ticon", vscroll_width, title_height
        AddIcon toggle1,no,"ticon1", vscroll_width, title_height
d417 3
d470 2
a471 2
;; NB: The tool sprites temporaryly become part of the list of active
;;     sprites - avoid IconSpriting any borders files.
d528 5
a532 7
        TEQ     R3,R2                   ; Yeig = Xeig?
        MOVEQ   R6,#"2"                 ; if so use 22 postfix
        MOVNE   R6,#"4"                 ; use 24 (ie usually default to none) NK Nov 17th 93
        TEQ     R3,#1
        TEQNE   R3,#0
        MOVNE   R5,#0                   ; else no suffix for now
        MOVNE   R6,#-1
d554 1
a554 1
        CMP     R2,#0                   ; has the list buffer been setup yet?
d696 5
d763 5
d783 1
d842 1
a842 1
        
d935 3
d1187 3
d1236 11
a1246 4
        TEQ     R2,#0                  ; is it possible for this glyph to have an alternate state?
        LDRNE   R3,tool_list
        TEQNE   R3,#0                   ; is there a glyph list?
        LDRNE   R3,[R3,R2]
d1310 4
a1317 2
        LDR     handle,border_windowselected
;
a1341 7
        [ false
        MOV     cx0,x0
        MOV     cy0,y0
        MOV     cx1,x1
        MOV     cy1,y1                  ; move to more sensible registers
        BL      markinvalid_cx0cy0cx1cy1
        |
d1344 1
d1347 9
a1355 1
        ]
d1361 3
d1386 3
d1404 3
d1415 1
a1415 1
        = 0                             ; toggle icon doesn't change state
a1416 1
        [ BounceClose
a1417 3
        |
        = 0                             ; close not highlightable
        ]
a1470 1
; TODO: Spot which toolsprites have a mask, and skip this bit for those that don't
d1472 4
a1475 2
        BL      solidrectangle
        BL      hollowrectangle        ; suitable rectangles
d1510 1
a1510 1
        
d1514 1
a1514 1
        
d1517 1
a1517 1
        
d1521 1
a1521 1
        
d1526 1
a1526 1
        
d1531 1
a1531 1
        
d1535 1
a1535 1
        
d1537 1
a1537 1
        
d1540 1
a1540 1
        
d1543 1
a1543 1
        
d1546 1
a1546 1
        
d1550 1
a1550 1
        
d1584 1
a1584 1
        
d1587 1
a1587 1
        
d1591 1
a1591 1
        
d1596 1
a1596 1
        
d1601 1
a1601 1
        
d1605 1
a1605 1
        
d1610 1
a1610 1
        
d1613 1
a1613 1
        
d1620 1
a1620 1
        
d1622 1
a1622 1
        
d1647 1
a1647 1
        
d1649 1
a1649 1
        
d1654 1
a1654 1
        
d1664 1
a1664 1
        
d1667 1
a1667 1
        
d1670 1
a1670 1
        
d2382 5
a2386 3
        MOVEQ   R0,#0
        STREQ   R0,systemfont
        BEQ     afterfindingfont
d2388 1
a2388 1
        ;Allocate a buffer big enough for the font name and setup a pointer
d2854 1
d2878 1
@


4.1
log
@Initial revision
@
text
@d768 1
a768 1
        STMIA   R14,{R0-R3}             ; setup a prameter block
d774 7
a780 1

d790 1
d1380 3
d1390 1
a1390 1
        LDMIA   R0,{R0,R5,R6,R7}        ; parmeters to plot using
d1400 185
d2754 1
a2754 1
        TEQ     R0,#34
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@When building for NCs, use IconHigh in error boxes, use different button
border colours, use replacement Templates file.
@
text
@a313 1
darkergrey      * 6
a319 4
 [ BuildForNC
ct_in           = darkgrey,   darkgrey,   darkergrey, darkergrey
ct_out          = darkergrey, darkergrey, darkgrey,   darkgrey
 |
a321 1
 ]
@


4.1.7.1.2.1
log
@AMBControl task switching merged from RO_3_70 branch.
PlotSpritesFromPalette and TwitterOnlyMenus options added.
ChildWindows merged in.
@
text
@d768 1
a768 1
        STMIA   R14,{R0-R3}             ; setup a parameter block
d774 1
a774 7
        
      [ ChildWindows
        ADR     R14,factors
        LDMIA   R14,{R3,R4,R5,R6}
        ADRL    R14,tool_scalingblk
        STMIA   R14,{R3,R4,R5,R6}        ; take a copy of the scaling block (even if the tools don't always need it)
      |
a783 1
      ]
a1372 3
; Allow toolsprites to be transparent (to show the colour through, if required)
; TODO: Spot which toolsprites have a mask, and skip this bit for those that don't
;
d1380 1
a1380 1
        LDMIA   R0,{R0,R5,R6,R7}        ; parameters to plot using
a1389 185
;; Plot a scaled window gadget - for up and down arrows when scrollbar gets small
;; This routine frigs the tool_plotparams, and then restores them
;; in   R2 = icon handle
;;      R0 = height of original object
;;      handle = window handle
;;      x0,y0,x1,y1 => region to plot the glyph into
;; out  EQ/NE if not plotted / plotted
;;-----------------------------------------------------------------------------

      [ ChildWindows

plot_windowglyph_vscaled  ENTRY "R0,R1,cx0,cy0,cx1,cy1,y0,y1"

        ADD     R0,R0,#2                        ; urg - stored heights are all 1 pixel too small (assume toolsprite at 2x2 os/pix)

        ; frig scale factors so we can plot the thing scaled

        ADRL    R1,tool_scalingblk
        LDMIA   R1,{cx0,cy0,cx1,cy1}
        
        SUB     R14,y1,y0
        MUL     cy0,R14,cy0
        MUL     cy1,R0,cy1
        
        Push    "cx0,cy0,cx1,cy1"
        MOV     R1,SP                           ; R1 -> new scaling block (on stack)
        
        LDR     R2,tool_plotparams + 0          ; sprite reason code
        LDR     R3,tool_plotparams + 8          ; pointer to factors
        Push    "R2,R3"
        
        BIC     R2,R2,#&FF
        ORR     R2,R2,#SpriteReason_PutSpriteScaled
        STR     R2,tool_plotparams + 0
        STR     R1,tool_plotparams + 8          ; must have to scale it for this call
        
        ASSERT  R2 = cx0
        LDR     R2,[SP,#8*4]                    ; restore R2 from stacked cx0 on entry
        MOV     R1,R2                           ; for plot_windowglyph_clipped (later)
        BL      plot_windowglyph
        
        Pull    "R2,R3"
        STR     R2,tool_plotparams + 0          ; sprite reason code
        STR     R3,tool_plotparams + 8          ; pointer to factors
        
        ADD     SP,SP,#4*4                      ; correct stack
        
        ; now we must explicitly plot the top and bottom row, to avoid dropouts
        ; this involves messing with the clipping region (urg)
        
        Push    "x0,y0,x1,y1"
        Pull    "cx0,cy0,cx1,cy1"               ; copy x0,y0,x1,y1 to cx0,cy0,cx1,cy1 (for clip window)
        
        LDR     R14,dy
        Push    "y1,R14"
        
        ADD     cy1,cy0,R14
        ADD     y1,y0,R0
        BL      plot_windowglyph_clipped        ; plot bottom pixel row
        
        Pull    "y1,R14"

        MOV     cy1,y1
        SUB     cy0,cy1,R14
        SUB     y0,y1,R0
        BL      plot_windowglyph_clipped        ; plot top pixel row

        EXIT                                    ; flags on exit are as from plot_windowglyph
      ]


;;-----------------------------------------------------------------------------
;; Plot a scaled window gadget - for up and down arrows when scrollbar gets small
;; This routine frigs the tool_plotparams, and then restores them
;; in   R2 = icon handle
;;      R0 = height of original object
;;      handle = window handle
;;      x0,y0,x1,y1 => region to plot the glyph into
;; out  EQ/NE if not plotted / plotted
;;-----------------------------------------------------------------------------

      [ ChildWindows

plot_windowglyph_hscaled  ENTRY "R0,R1,cx0,cy0,cx1,cy1,x0,x1"

        ADD     R0,R0,#2                        ; urg - stored widths are all 1 pixel too small (assume toolsprite at 2x2 os/pix)

        ADRL    R1,tool_scalingblk
        LDMIA   R1,{cx0,cy0,cx1,cy1}

        SUB     R14,x1,x0
        MUL     cx0,R14,cx0
        MUL     cx1,R0,cx1
        
        Push    "cx0,cy0,cx1,cy1"
        MOV     R1,SP                           ; R1 -> new factors on stack
        
        LDR     R2,tool_plotparams + 0          ; sprite reason code
        LDR     R3,tool_plotparams + 8          ; pointer to factors
        Push    "R2,R3"
        
        BIC     R2,R2,#&FF
        ORR     R2,R2,#SpriteReason_PutSpriteScaled
        STR     R2,tool_plotparams + 0
        STR     R1,tool_plotparams + 8          ; must have to scale it for this call
        
        ASSERT  R2 = cx0
        LDR     R2,[SP,#8*4]                    ; restore R2 from stacked cx0 on entry
        MOV     R1,R2                           ; for plot_windowglyph_clipped (later)
        BL      plot_windowglyph
        
        Pull    "R2,R3"
        STR     R2,tool_plotparams + 0          ; sprite reason code
        STR     R3,tool_plotparams + 8          ; pointer to factors
        
        ADD     SP,SP,#4*4                      ; correct stack

        ; now we must explicitly plot the top and bottom row, to avoid dropouts
        ; this involves messing with the clipping region (urg)
        
        Push    "x0,y0,x1,y1"
        Pull    "cx0,cy0,cx1,cy1"               ; copy x0,y0,x1,y1 to cx0,cy0,cx1,cy1 (for clip window)
        
        LDR     R14,dx
        Push    "x1,R14"

        ADD     cx1,cx0,R14
        ADD     x1,x0,R0
        BL      plot_windowglyph_clipped        ; plot left-hand pixel row
        
        Pull    "x1,R14"
        
        MOV     cx1,x1
        SUB     cx0,cx1,R14
        SUB     x0,x1,R0
        BL      plot_windowglyph_clipped        ; plot right-hand pixel row

        EXIT                                    ; flags on exit are as from plot_windowglyph
      ]


;;-----------------------------------------------------------------------------
;; Plot a clipped window gadget - for getting the end pixels correct
;; in   R1 = icon handle
;;      x0,y0 = coordinate to plot at (bottom-left)
;;      cx0,cy0,cx1,cy1 = desired clip rectangle (will be further clipped)
;;      handle = window handle
;; out  flags preserved
;;-----------------------------------------------------------------------------

      [ ChildWindows

plot_windowglyph_clipped  ENTRY "R0,R1,cx0,cy0,cx1,cy1,x0,y0,x1,y1"

        ADR     R14,clipx0
        LDMIA   R14,{x0,y0,x1,y1}
        
        Push    "x0,y0,x1,y1"
        
        max     x0,cx0
        max     y0,cy0
        min     x1,cx1
        min     y1,cy1
        
        CMP     x0,x1
        CMPLT   y0,y1
        ADDGE   SP,SP,#4*4
        EXITS   GE                              ; forget it if this is a null clip window

        BL      graphicswindow                  ; set to x0,y0,x1,y1

        ADD     R14,SP,#10*4
        LDMIA   R14,{x0,y0,x1,y1}               ; recover original x0,y0,x1,y1
        
        MOVVC   R2,R1
        BLVC    plot_windowglyph
        
        Pull    "x0,y0,x1,y1"
        BL      graphicswindow                  ; restore graphics window
        
        EXITS
      ]


;;-----------------------------------------------------------------------------
d2559 1
a2559 1
        TEQ     R0,#SpriteReason_PutSpriteUserCoords
@


4.1.7.1.2.2
log
@Some obsolete assembly switches removed (chwidth in particular).
Behaviour of scrollbars with large extents improved.
Window tools now press in correctly after a Service_InvalidateCache.
Plotting of solid window tools optimised - background isn't drawn in.
Auto-fronting iconbar added.
Various optimisations, such as multiple OS_WriteI -> OS_WriteN.
HiResMono flag no longer relied on.
"22" tool sprites now chosen for 1x2,2x1 or 1x1 screen modes.
Buttons restored correctly after "application may have gone wrong" error box.
Positioning of outline font text shifted right 2 OS units to match system font.
Parameter of L validation string implemented.
Positioning of outline font "L" (multiple line) icons fixed.
Shift-toggle size behaviour fixed.
Wimp_TransferBlock above 2Gb should be fixed.
Post-rectangle filters implemented.
FPE4 flag added (to use LFM/SFM instead of LDFE/STFE).
Plotting of non-pixel aligned 3d icons fixed.
3d borders now solid in EX0/EY0 modes.
@
text
@d37 1
a37 1
        MOV     R5,#3                   ; default values
d198 1
a198 1
plot_slab ENTRY "R0-R4"
a201 37
      [ fixslabalignment
        SUB     x1,x1,#1
        SUB     y1,y1,#1                ; adjust x1 and y1 to be inclusive

        ASSERT  :INDEX:dy - :INDEX:dx = 4
        ADR     R14,dx
        LDMIA   R14,{R0,R4}             ; get dx and dy
        TEQ     R0,#2
        TEQEQ   R4,#4
        BEQ     plot_slab_24

        CMP     R0,R4
        MOVLT   R4,R0                   ; R4 = smaller of dx and dy

        BL      render_bbox             ; plot first rectangle (at given coordinates)

        MOV     R0,#1
        BL      adjust_bbox             ; adjust the bounding box to cover reduced area

        CMP     R4,#1
        BLEQ    render_bbox             ; then fill again (but only if EX0 or EY0)

        MOV     R0,#1
        BL      adjust_bbox             ; adjust again
        BL      render_bbox             ; then fill again

        MOVEQ   R0,#1
        BLEQ    adjust_bbox             ; fill final line if hires
        BLEQ    render_bbox

        MOVEQ   R0,#1
        MOVNE   R0,#2
        BL      adjust_bbox             ; and finally return with adjust bounding box

        ADD     x1,x1,#1                ; adjust X1,Y1 to be exclusive again
        ADD     y1,y1,#1
      |
a218 1
      ]
a221 18
      [ fixslabalignment

;; special case of plot_slab for good, old-fashioned rectangular pixel modes.
;; It draws the bottom left and top right corners a bit more nicely
plot_slab_24
        MOV     R0,#2
        BL      adjust_bbox             ; draw inner line first
        BL      render_bbox
        MOV     R0,#-2
        BL      adjust_bbox
        BL      render_bbox             ; then outer line
        MOV     R0,#4
        BL      adjust_bbox             ; adjust final bounding box
        ADD     x1,x1,#1
        ADD     y1,y1,#1                ; restore original x1,y1
        EXITS
      ]

a232 1
      [ :LNOT:fixslabalignment
a233 1
      ]
a237 1
      [ :LNOT:fixslabalignment
a238 1
      ]
d335 1
a335 1
;; must be defined with the same palette and same mode, mixing is not
d411 2
a412 2
;; NB: The tool sprites temporarily become part of the list of active
;;     sprites - avoid *IconSpriting any borders files.
d469 7
a475 5
	CMP	R2,#1			; if both Xeig and Yeig <= 1 then use 22 postfix
	CMPLS	R3,#1
	MOVLS	R6,#"2"
	MOVHI	R5,#0
	MOVHI	R6,#-1
d497 1
a497 1
        TEQ     R2,#0                   ; has the list buffer been setup yet?
a638 5
	TEQ	R5,#1
	LDREQ	R5,[sp]
	ORREQ	R5,R5,#1
	STREQ	R5,[sp]			; store mask status
;
a715 1
	BIC	R2,R2,#1		; strip our mask bit
d774 1
a774 1

a1115 3
;;	R6 = button attributes
;;	R7 = mouse flag
;;	R8 = old button state
d1162 4
a1165 11
        TEQ     R2,#0                   ; is it possible for this glyph to have an alternate state?
	EXITS	EQ		      	; nope, so return
        LDR     R3,tool_list
        TEQ     R3,#0                   ; is there a glyph list?
	BNE	%FT05
	Push	"R2"			; R2 corrupted :-(
	BL	recache_tools_trans	; if not, try to get one again
	Pull	"R2"
	LDR	R3,tool_list
	TEQ	R3,#0
05      LDRNE   R3,[R3,R2]
d1381 1
d1383 2
a1384 4
	TST	R2,#1
        BLNE    solidrectangle	     	; corrupts flags :-(
	TST	R2,#1
        BLNE    hollowrectangle        ; suitable rectangles
d1419 1
a1419 1

d1423 1
a1423 1

d1426 1
a1426 1

d1430 1
a1430 1

d1435 1
a1435 1

d1440 1
a1440 1

d1444 1
a1444 1

d1446 1
a1446 1

d1449 1
a1449 1

d1452 1
a1452 1

d1455 1
a1455 1

d1459 1
a1459 1

d1493 1
a1493 1

d1496 1
a1496 1

d1500 1
a1500 1

d1505 1
a1505 1

d1510 1
a1510 1

d1514 1
a1514 1

d1519 1
a1519 1

d1522 1
a1522 1

d1529 1
a1529 1

d1531 1
a1531 1

d1556 1
a1556 1

d1558 1
a1558 1

d1563 1
a1563 1

d1573 1
a1573 1

d1576 1
a1576 1

d1579 1
a1579 1

d2291 3
a2293 5
	BNE	%FT50
        MOV     R0,#0
        STR     R0,systemfont
	SETV
        B       afterfindingfont
d2295 1
a2295 1
50      ;Allocate a buffer big enough for the font name and setup a pointer
a2760 1
	BIC	R2,R2,#1
a2783 1
	BIC	R2,R2,#1
@


4.1.7.1.2.3
log
@Iconise button added.
@
text
@a420 3
        [ IconiseButton
	AddIcon iconise,,"iicon", iconise_width, title_height
	]
a763 5
      [ IconiseButton
	LDR	LR,iconise_width
	TEQ	LR,#0
	STREQ	R1,iconise_width
      ]
a930 3
      [ IconiseButton
	STR	R1,iconise_width
      ]
a1349 3
	[ IconiseButton
	= iconposn_iconise
	]
a1371 3
	[ IconiseButton
	= tool_iconise
	]
a1386 3
	[ IconiseButton
	= tool_piconise
	]
@


4.1.7.1.2.4
log
@Added support for multiple options files (RO310, RO350, RO360, RO370, RCA,
Ursula).
Removed run-time MedusaOS checks.
Enabled correct build for RISC OS 3.1 machines.
Ensured that "freepoolinuse" is cleared before OS_ChangeDynamicArea
is intercepted.
Increased maxrects to 256.
Gave copy filter window handle in R10 (if ChildWindows).
Corrected a few border problems when no toolsprites.
Made toolsprites press in immediately - in particular close and toggle can
now be highlighted.
BounceClose flag no affects all of back,close,iconise and toggle.
Made "L" validation string parsing check manually for presence of a number,
to prevent error from OS_ReadUnsigned trashing MessageTrans' error buffers.
Allow error box buttons to stretch to fit text.
Fixed bug: floating point registers were not being saved unless on a portable.
Integrated some of the Wimp_TransferBlock fixes into Wimp08 from Wimp08s.
@
text
@d413 1
d415 5
a419 2
        AddIcon toggle,,"ticon", vscroll_width, title_height
        AddIcon toggle1,,"ticon1", vscroll_width, title_height
a1313 4
        LDR     handle,border_windowselected
	CMP	handle,#nullptr
	EXITS	EQ
;
d1318 2
d1344 7
a1352 1
      [ false
d1355 1
a1355 9
      |
	; Actually, lets do this immediately
	BL	int_redraw_window
invglp	EXIT	VS
	TEQ	R0,#0
	EXITS	EQ
	BL	int_get_rectangle
	B	invglp
      ]
d1415 1
a1415 1
        = tool_ptoggle			; value not used, but non-0 to indicate highlightable
d1417 1
d1419 3
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.34;
access;
symbols
	Wimp-5_62:4.34
	Wimp-5_61:4.34
	Wimp-5_60:4.34
	Wimp-5_59:4.33
	Wimp-5_58:4.33
	Wimp-5_57:4.33
	Wimp-5_56:4.33
	Wimp-5_55:4.33
	Wimp-5_54:4.33
	Wimp-5_53:4.33
	Wimp-5_52:4.33
	Wimp-5_51:4.33
	Wimp-5_50:4.32
	Wimp-5_49:4.32
	Wimp-5_48:4.32
	Wimp-5_47-file1ad:4.32
	Wimp-5_47:4.32
	Wimp-5_46:4.32
	Wimp-5_45:4.32
	Wimp-5_44:4.32
	Wimp-5_43:4.32
	Wimp-5_42:4.32
	Wimp-5_41:4.32
	Wimp-5_40:4.32
	Wimp-5_39:4.32
	Wimp-5_38:4.32
	Wimp-5_37:4.32
	Wimp-5_36:4.32
	Wimp-5_35:4.32
	Wimp-5_34:4.32
	Wimp-5_33:4.32
	Wimp-5_32:4.32
	Wimp-5_31:4.32
	Wimp-5_30:4.31
	Wimp-530-pre4:4.31
	Wimp-5_30-pre3:4.31
	Wimp-5_30-pre2:4.31
	Wimp-5_30-pre1:4.31
	Wimp-5_29:4.31
	Wimp-5_28:4.31
	Wimp-5_27:4.31
	Wimp-5_26:4.31
	Wimp-5_25:4.31
	Wimp-5_24:4.30
	Wimp-5_23:4.29
	Wimp-5_22:4.29
	Wimp-5_21:4.29
	Wimp-5_20:4.29
	Wimp-5_19:4.29
	Wimp-5_18:4.29
	Wimp-5_17:4.29
	Wimp-5_16:4.29
	Wimp-5_15:4.29
	Wimp-5_14:4.29
	Wimp-5_13:4.29
	Wimp-5_12:4.28
	Wimp-5_11:4.28
	Wimp-5_10:4.27
	Wimp-5_09:4.27
	Wimp-5_08:4.26
	Wimp-5_07:4.25
	Wimp-5_06:4.25
	Wimp-5_05:4.25
	Wimp-5_04:4.25
	Wimp-5_03:4.25
	Wimp-5_02:4.25
	Wimp-5_01:4.25
	Wimp-4_66-4_77_2_1:4.17.2.1
	bavison_Threads_dev:4.17.0.2
	bavison_Threads_dev_bp:4.17
	Wimp-5_00:4.25
	Wimp-4_100:4.25
	Wimp-4_99:4.25
	Wimp-4_98:4.25
	Wimp-4_97:4.25
	Wimp-4_96:4.25
	Wimp-4_95:4.25
	Wimp-4_94:4.25
	RO_5_07:4.24
	Wimp-4_93:4.24
	Wimp-4_92:4.24
	Wimp-4_91:4.24
	Wimp-4_90:4.24
	Wimp-4_89:4.24
	Wimp-4_88:4.22
	Wimp-4_87:4.22
	Wimp-4_86:4.22
	Wimp-4_85:4.21
	Wimp-4_84:4.21
	Wimp-4_83:4.21
	Wimp-4_82:4.21
	Wimp-4_81:4.21
	Wimp-4_80:4.21
	Wimp-4_79:4.21
	Wimp-4_78:4.20
	Wimp-4_77:4.20
	Wimp-4_76:4.20
	Wimp-4_75:4.19
	Wimp-4_74:4.19
	Wimp-4_73:4.19
	Wimp-4_72:4.19
	Wimp-4_71:4.19
	Wimp-4_70:4.19
	Wimp-4_69:4.19
	Wimp-4_68:4.18
	Wimp-4_67:4.18
	Wimp-4_66:4.17
	Wimp-4_65:4.17
	Wimp-4_64:4.16
	Wimp-4_63:4.16
	Wimp-4_62:4.16
	Wimp-4_61:4.16
	Wimp-4_60:4.16
	Wimp-4_59:4.16
	Wimp-4_58:4.16
	Wimp-4_36-4_46_2_6:4.14
	Wimp-4_57:4.16
	Alpnet_approved:4.14
	Wimp-4_36-4_46_2_5:4.14
	Wimp-4_56:4.16
	dellis_autobuild_BaseSW:4.16
	Wimp-4_36-4_46_2_4:4.14
	Wimp-4_36-4_46_2_3:4.14
	Wimp-4_55:4.16
	Wimp-4_54:4.16
	Wimp-4_36-4_46_2_2:4.14
	Wimp-4_53:4.16
	Wimp-4_36-4_46_2_1:4.14
	Bethany:4.14.0.2
	Wimp-4_52:4.16
	Wimp-4_51:4.16
	Wimp-4_50:4.16
	Wimp-4_49:4.16
	Wimp-4_48:4.16
	Wimp-4_47:4.16
	Wimp-4_46:4.15
	Wimp-4_45:4.15
	Wimp-4_44:4.15
	Wimp-4_43:4.15
	Wimp-4_42:4.15
	sbrodie_sedwards_16Mar2000:4.14
	Wimp-4_41:4.14
	Wimp-4_40:4.14
	Wimp-4_39:4.14
	Wimp-4_38:4.14
	Wimp-4_37:4.14
	Wimp-4_36:4.14
	Wimp-4_35:4.14
	Wimp-4_34:4.14
	Wimp-4_33:4.14
	Wimp-4_32:4.14
	Wimp-4_31:4.14
	dcotton_autobuild_BaseSW:4.19
	Wimp-4_30:4.14
	Wimp-4_29:4.14
	Wimp-4_28:4.14
	Wimp-4_27:4.14
	Wimp-4_26:4.14
	Wimp-4_25:4.14
	Wimp-4_24:4.14
	Wimp-4_23:4.14
	Wimp-4_22:4.14
	Wimp-4_21:4.14
	Wimp-4_20:4.14
	Wimp-4_19:4.14
	Wimp-4_18:4.13
	Wimp-4_17:4.13
	Wimp-4_16:4.12
	Wimp-4_15:4.12
	Wimp-4_14:4.12
	Wimp-4_13:4.12
	Wimp-4_12:4.11
	mstphens_UrsulaRiscPCBuild_20Nov98:4.4.2.12
	bavison_Wimp-4_11:4.10
	Ursula_RiscPC:4.4.2.12.0.2
	Wimp-4_11:4.10
	Wimp-4_10:4.9
	Wimp-4_09:4.9
	Wimp-4_08:4.8
	Wimp-4_07:4.8
	Wimp-4_06:4.8
	Wimp-4_05:4.7
	Wimp-4_04:4.7
	bavison_Wimp-4_03_noshrinkables:4.7
	Wimp-4_03:4.7
	Wimp-4_02:4.7
	Ursula_merge:4.4.2.12
	bavison_Wimp-4_01:4.6
	Wimp-4_01:4.6
	nicke_Wimp_3_96M:4.1.7.9
	bavison_Wimp-4_00_TRUNK:4.5
	bavison_Wimp-4_00:4.4.2.12
	nicke_Wimp_3_96:4.1.7.9
	mjrobert_Wimp_3_98:4.4.2.6
	rthornb_UrsulaBuild-19Aug1998:4.4.2.12
	UrsulaBuild_FinalSoftload:4.4.2.12
	bavison_Wimp-3_99t:4.4.2.12
	rthornb_UrsulaBuild-12Aug1998:4.4.2.12
	bavison_Wimp-3_99s:4.4.2.12
	aglover_UrsulaBuild-05Aug1998:4.4.2.12
	bavison_Wimp-3_99r:4.4.2.12
	rthornb_UrsulaBuild-29Jul1998:4.4.2.12
	bavison_Wimp-3_99q:4.4.2.12
	jfarrell_NCWimp_3_96:4.1.7.9
	rthornb_UrsulaBuild-22Jul1998:4.4.2.11
	bavison_Wimp-3_99p:4.4.2.11
	rthornb_UrsulaBuild-15Jul1998:4.4.2.11
	bavison_Wimp-3_99o:4.4.2.11
	bavison_Wimp-3_99n:4.4.2.11
	rthornb_UrsulaBuild-07Jul1998:4.4.2.11
	bavison_Wimp-3_99m:4.4.2.11
	rthornb_UrsulaBuild-17Jun1998:4.4.2.10
	rthornb_UrsulaBuild-03Jun1998:4.4.2.10
	bavison_Wimp-3_99l:4.4.2.10
	rthornb_UrsulaBuild-27May1998:4.4.2.10
	rthornb_UrsulaBuild-21May1998:4.4.2.10
	bavison_Wimp-3_99k:4.4.2.10
	bavison_Wimp-3_99j:4.4.2.10
	bavison_Wimp-3_99i:4.4.2.10
	bavison_Wimp-3_99h:4.4.2.10
	rthornb_UrsulaBuild_01May1998:4.4.2.10
	bavison_Wimp_399g:4.4.2.10
	bavison_Wimp_399f:4.4.2.10
	afrost_NC2_Generic:4.1.7.7
	bavison_Wimp_399e:4.4.2.9
	bavison_Wimp_399d:4.4.2.9
	bavison_Wimp_399c:4.4.2.9
	Wimp_3_98:4.4.2.6
	kbracey_AW97:4.4.2.4
	Spinner_B20_2:4.1.7.5
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.3
	Spinner_B17:4.1.7.3
	Spinner_B15:4.1.7.3
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Spinner_B12:4.1.7.2
	Spinner_B10:4.1.7.2
	Spin_Merge_16May97:4.1.7.1
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula:4.4.0.2
	Ursula_bp:4.4
	Wimp_3_91:4.3
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.1
	Spinner_B7:4.1.7.2
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1.2.4
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.10
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.34
date	2018.02.17.15.20.29;	author jlee;	state Exp;
branches;
next	4.33;
commitid	E4WYFV9zLEaz2erA;

4.33
date	2015.11.29.19.57.16;	author jlee;	state Exp;
branches;
next	4.32;
commitid	bEIfj6rhNgsJD1Ly;

4.32
date	2013.08.06.23.31.43;	author jlee;	state Exp;
branches;
next	4.31;
commitid	UbPZokvIlfdkZr0x;

4.31
date	2013.05.06.11.54.49;	author rsprowson;	state Exp;
branches;
next	4.30;
commitid	dyQdYmrTRpty5zOw;

4.30
date	2013.05.03.21.08.17;	author rsprowson;	state Exp;
branches;
next	4.29;
commitid	QS59VqQdUOQmfeOw;

4.29
date	2011.08.04.20.33.30;	author jlee;	state Exp;
branches;
next	4.28;
commitid	gzFhtZcn753Zyeuv;

4.28
date	2011.02.01.23.00.28;	author jlee;	state Exp;
branches;
next	4.27;

4.27
date	2010.11.26.18.47.52;	author jlee;	state Exp;
branches;
next	4.26;

4.26
date	2010.03.14.17.51.37;	author jlee;	state Exp;
branches;
next	4.25;

4.25
date	2005.01.17.13.38.30;	author bavison;	state Exp;
branches;
next	4.24;

4.24
date	2003.02.28.20.34.24;	author bavison;	state Exp;
branches;
next	4.23;

4.23
date	2003.02.28.16.09.32;	author bavison;	state Exp;
branches;
next	4.22;

4.22
date	2003.01.23.19.41.16;	author bavison;	state Exp;
branches;
next	4.21;

4.21
date	2002.10.31.17.00.18;	author bavison;	state Exp;
branches;
next	4.20;

4.20
date	2002.10.23.17.12.37;	author bavison;	state Exp;
branches;
next	4.19;

4.19
date	2001.09.14.21.27.15;	author bavison;	state Exp;
branches;
next	4.18;

4.18
date	2001.05.29.11.44.06;	author bavison;	state Exp;
branches;
next	4.17;

4.17
date	2001.03.23.16.49.09;	author bavison;	state Exp;
branches
	4.17.2.1;
next	4.16;

4.16
date	2000.04.25.12.24.09;	author kbracey;	state Exp;
branches;
next	4.15;

4.15
date	2000.03.29.13.59.23;	author bavison;	state Exp;
branches;
next	4.14;

4.14
date	99.04.29.11.02.11;	author kbracey;	state Exp;
branches;
next	4.13;

4.13
date	99.03.25.14.15.36;	author smiddle;	state Exp;
branches;
next	4.12;

4.12
date	98.11.27.20.56.19;	author bavison;	state Exp;
branches;
next	4.11;

4.11
date	98.11.26.14.04.44;	author bavison;	state Exp;
branches;
next	4.10;

4.10
date	98.11.09.12.49.43;	author bavison;	state Exp;
branches;
next	4.9;

4.9
date	98.10.23.15.48.49;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	98.10.20.16.21.40;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	98.10.07.16.34.21;	author scormie;	state Exp;
branches;
next	4.6;

4.6
date	98.09.30.09.06.48;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	98.09.18.16.14.29;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	97.05.16.13.40.56;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	97.05.07.14.15.46;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.13.13.25.13;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.51;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.17.2.1
date	2007.10.07.02.17.29;	author bavison;	state Exp;
branches;
next	;
commitid	NSavcPvbNd36pBAs;

4.4.2.1
date	97.07.07.11.25.12;	author bavison;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	97.09.02.12.45.29;	author kbracey;	state Exp;
branches;
next	4.4.2.3;

4.4.2.3
date	97.10.15.11.47.09;	author kbracey;	state Exp;
branches;
next	4.4.2.4;

4.4.2.4
date	97.10.16.14.01.12;	author kbracey;	state Exp;
branches;
next	4.4.2.5;

4.4.2.5
date	97.10.28.11.08.50;	author kbracey;	state Exp;
branches;
next	4.4.2.6;

4.4.2.6
date	98.02.02.16.28.06;	author kbracey;	state Exp;
branches;
next	4.4.2.7;

4.4.2.7
date	98.03.10.16.11.54;	author bavison;	state Exp;
branches;
next	4.4.2.8;

4.4.2.8
date	98.03.26.19.31.51;	author bavison;	state Exp;
branches;
next	4.4.2.9;

4.4.2.9
date	98.04.03.19.38.49;	author bavison;	state Exp;
branches;
next	4.4.2.10;

4.4.2.10
date	98.04.21.16.58.04;	author bavison;	state Exp;
branches;
next	4.4.2.11;

4.4.2.11
date	98.07.03.18.00.02;	author bavison;	state Exp;
branches;
next	4.4.2.12;

4.4.2.12
date	98.07.28.17.11.18;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.30.51;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.33.14;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.24.58;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.22.25;	author nturton;	state Exp;
branches
	4.1.7.1.2.1;
next	4.1.7.2;

4.1.7.2
date	97.04.30.16.50.39;	author scormie;	state Exp;
branches;
next	4.1.7.3;

4.1.7.3
date	97.06.11.10.04.47;	author scormie;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.07.25.13.27.34;	author jcoxhead;	state Exp;
branches;
next	4.1.7.5;

4.1.7.5
date	97.07.28.14.31.18;	author jcoxhead;	state Exp;
branches;
next	4.1.7.6;

4.1.7.6
date	97.07.31.16.17.10;	author scormie;	state Exp;
branches;
next	4.1.7.7;

4.1.7.7
date	97.08.19.15.04.18;	author arodger;	state Exp;
branches;
next	4.1.7.8;

4.1.7.8
date	98.06.15.10.05.44;	author olove;	state Exp;
branches;
next	4.1.7.9;

4.1.7.9
date	98.06.25.08.58.46;	author scormie;	state Exp;
branches;
next	4.1.7.10;

4.1.7.10
date	98.10.07.16.14.22;	author scormie;	state Exp;
branches;
next	;

4.1.7.1.2.1
date	97.04.10.13.51.33;	author kbracey;	state Exp;
branches;
next	4.1.7.1.2.2;

4.1.7.1.2.2
date	97.04.14.12.22.15;	author kbracey;	state Exp;
branches;
next	4.1.7.1.2.3;

4.1.7.1.2.3
date	97.04.14.21.56.11;	author kbracey;	state Exp;
branches;
next	4.1.7.1.2.4;

4.1.7.1.2.4
date	97.04.28.16.50.12;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.34
log
@Fix crashes when a Wimp_Poll post-filter causes the Wimp to postpone switching to a VFP-enabled task
Detail:
  s/Wimp07 - In ExitPoll, swap around the order of restoring the FP context and calling the poll post-filter so that the FP context is restored after the post-poll filter has been invoked. Previously, the VFP(+FPA) context would be restored, then the post-poll filter would be invoked. If the post-poll filter was claimed, the Wimp would then scan the pollwords again and most likely decide to switch to a different task. The appslot will then be switched over, and ExitPoll will be invoked again, attempting to restore the VFP/FPA context for that task - potentially causing a crash or other bad things because the VFP context used by the original choice of task is no longer paged in. For FPA this was never really a problem, since the context is stored in the RMA rather than being potentially stored in appspace.
  s/Wimp03 - Add some extra debug out for tracking VFP context management
Admin:
  Tested on wandboard
  Fixes issue reported on forums, where using the numpad in VFP SciCalc would cause a crash if KeyExtend was loaded:
  https://www.riscosopen.org/forum/forums/4/topics/10293


Version 5.60. Tagged as 'Wimp-5_60'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.Wimp07

;;----------------------------------------------------------------------------
;; Constants used by Wimp_SendMessage
;;----------------------------------------------------------------------------

                ^       0
msb_link        #       4
msb_receiver    #       4
msb_allsender   #       4               ; for R2 on exit from Wimp_Poll
msb_handle      #       4               ; remember window/icon handle
msb_reasoncode  #       4
msb_size        #       4               ; is also size of header!
msb_sender      #       4
msb_myref       #       4
msb_yourref     #       4               ; ms_xxx defined in Hdr.Messages

ms_sender       *       ms_taskhandle   ; for convenience!

min_messsize    *       ms_data         ; only applies to 17,18,19
max_messsize    *       256

msf_broadcast   *       1:SHL:31

MSToWimpMagicHandle     *       &706d6957       ; Reads "Wimp" in *memoryi, is not word aligned and has top bit (msf_broadcast) clear

        MACRO
$lab    CheckMsgQ
$lab
      [ NKmessages1
        LDR     R0,lastpointer
        SUBS    R0,R0,R2
        STREQ   R0,lastpointer
      ]
        MEND

;;----------------------------------------------------------------------------
;; Return Message to task (called by Wimp_Poll)
;; Entry:  R2 --> message to send (same as [headpointer]
;;         [headpointer] --> message blocks (linked list)
;; Exit:   [taskhandle] set up
;;         message block removed from list, if necessary
;;         code branches to ExitPoll, unless task dead or code is masked out
;;         broadcast messages of type 12:
;;           if any task acknowledges it, no more tasks get the broadcast
;;           if no tasks acknowledge it, the block is returned to sender
;;           - the code seems to have dropped out nicely !!!
;; Note:
;;         if a task or window has been subsequently deleted,
;;           the message is not delivered (returned if appropriate)
;;----------------------------------------------------------------------------

returnmessage
        [ debugpk
        LDR     R5,[R2,#msb_receiver]
        MOV     R5,R5,LSL #16
        LDR     R14,=&16840000
        TEQ     R14,R5
        BNE     glurg
        LDR     R14,[R2,#msb_reasoncode]        ; if its a message then checking
        LDR     R5,[R2,#msb_allsender]

        Debug   pk,"About to send message to TM ",R14,R5
        LDR     R14,[R2,#msb_link]
        CMP     R14,#nullptr
        BEQ     glurg

        LDR     R5,[R14,#msb_receiver]

        LDR     R14,[R14,#msb_reasoncode]
        Debug   pk,"Next reason code message is ",R14,R5

        LDR     R14,[R2,#msb_link]
        CMP     R14,#nullptr
        BEQ     glurg
        LDR     R14,[R14,#msb_link]
        CMP     R14,#nullptr
        BEQ     glurg


        LDR     R14,[R14,#msb_reasoncode]
        Debug   pk,"And the next is is ",R14

glurg
        ]

;
; set up 'sender', so ExitPoll can return R2 = sender's handle if necessary
;
        LDR     R14,[R2,#msb_allsender]
        STR     R14,sender
;
; page in appropriate task - if doing broadcast, update count
;
        LDR     R5,[R2,#msb_receiver]


        TST     R5,#msf_broadcast
        ADDNE   R14,R5,#4                       ; on to next task
        STRNE   R14,[R2,#msb_receiver]
        LDRNE   R0,=maxtaskhandle:OR:msf_broadcast
        CMPNE   R14,R0
        BICCS   R5,R5,#msf_broadcast            ; last one is just 'ordinary'
;
; if the task has died, don't send the message !!!
;
        TEQ     R5,#0                   ; if zero, don't send message
        BEQ     %FT01
;
; Catch messages to Wimp
;


        LDR     R14,=MSToWimpMagicHandle
        TEQ     R5,R14
        BEQ     autowimp_menu

        MOV     R14,R5,LSL #32-flag_versionbit
        LDR     R3,[wsptr,R14,LSR #32-flag_versionbit]  ; R3 --> task data
        TST     R3,#task_unused
        BNE     %FT01                           ; give up now!
;
        LDR     R14,[R2,#msb_reasoncode]        ; if its a message then checking

        CMP     R14,#User_Message
        CMPNE   R14,#User_Message_Recorded
        CMPNE   R14,#User_Message_Acknowledge
        BLEQ    checkformessage
;
        LDR     R3,[R3,#task_flagword]          ; R3 = flag word (if not dead)
        BIC     R14,R5,#msf_broadcast
        MOVS    R14,R14,LSR #flag_versionbit    ; if version bits set,
        TEQNE   R14,R3,LSR #flag_versionbit     ; ensure they are the same!
        MOVEQ   R14,#1
        LDREQ   R0,[R2,#msb_reasoncode]
        TSTEQ   R3,R14,LSL R0           ; check whether this code is masked out
01
        ANDNE   R5,R5,#msf_broadcast    ; mark lower bits 0 ==> don't send it!

;
; R5 (bits 0..19) = 0 ==> don't send message
;
        MOV     R14,R5,LSL #32-flag_versionbit
        MOVS    R14,R14,LSR #32-flag_versionbit
        BEQ     postposting
;
        Task    R14,,"Message return"           ; page in appropriate task
        ADD     R1,R2,#msb_size                 ; R1 --> actual message bit
        BL      calcmessagesize                 ; R3 = size of message block
        BVS     ExitPoll
;
        Debug   ms,"Message: task,rc,R1,size =",#taskhandle,R0,userblk,R3
        TEQ     R3,#0
        BEQ     postposting
        MOV     R4,userblk
01
        LDR     R14,[R1],#4                     ; copy into [userblk]
        STR     R14,[R4],#4
        SUBS    R3,R3,#4
        BNE     %BT01
;
; having copied the block out, decide whether to free the heap block
;
postposting
        TST     R5,#msf_broadcast               ; if broadcast,
        BNE     doneblock                       ; keep the block
;
        LDR     R0,[R2,#msb_reasoncode]         ; (may not have been loaded)
        TEQ     R0,#User_Message_Recorded       ; unless recorded,
        BEQ     %FT01                           ; delete block
;
        LDR     R14,[R2,#msb_link]
        STR     R14,headpointer
;
        Debug   ms,"Freeing block at:",R2
        Push    "R0"
        CheckMsgQ
        MOV     R0,#ModHandReason_Free
        BL     XROS_Module
        Pull    "R0"
        B       doneblock
01
        Debug   ms,"Marking 'return to sender':",R2
        MOV     R14,#User_Message_Acknowledge   ; mark 'return to sender'
        STR     R14,[R2,#msb_reasoncode]
        LDR     R14,[R2,#msb_sender]            ; redirect back to sender
        STR     R14,[R2,#msb_receiver]

doneblock
        BICS    R14,R5,#msf_broadcast
        BNE     ExitPoll                ; R0, [userblk] set up
        B       repollwimp              ; may call returnmessage again


;;----------------------------------------------------------------------------
;; Send Message
;; Entry:  R0 = reason code to generate
;;         R1 --> message block
;;             R1+0 = size of block
;;             R1+4 = handle of sending task (filled in by Wimp)
;;             R1+8 = my ref field           (filled in by Wimp)
;;             R1+12 = your ref field (0 if none)
;;             R1+16 = message action
;;             R1+20 = message data (format depends on [R1+16]
;;         R2 = task / window handle (Wimp can tell them apart)
;;         R2 = 0 ==> broadcast
;;         R3 = icon handle (if R2 = window handle on entry)
;; Exit:   R2 = actual task handle (or 0 if R2=0 on entry)
;;         [R1+8] = reference number of message (if R0 was 17 or 18 on entry)
;;         if [R1+12] <> 0, then any message with that myref value is killed
;; Errors: no room in RMA for message block
;;         illegal task/window handle
;;         illegal reason code (R0 on entry to Wimp_SendMessage)
;;         illegal message block size (must be <= 256, and be a multiple of 4)
;;----------------------------------------------------------------------------

SWIWimp_SendMessage

        MyEntry "SendMessage"

; first find out if application is sending a font changed message
        Push    "R0-R1"
        LDR     R0,[R1,#16]
        LDR     R1,=Message_FontChanged
        CMP     R0,R1
        Pull    "R0-R1"
        BNE     ordinary_message
        TEQ     R0,#User_Message
        BNE     ordinary_message
        [ outlinefont
        BL      FindFont                ; this will broadcast the message if it succeedes
        ]
        BLVC    BPR_invalidatewholescreen
        B       ExitWimp
ordinary_message
        BL      int_sendmessage
        STR     R2,[sp,#1*4]            ; return R2 = actual task handle
        B       ExitWimp                ; (0 if error has occurred)


int_sendmessage_fromwimp
        Push    "LR"
        LDR     R14,taskhandle
        Push    "R14"
        MOV     R14,#0                  ; fake it so sender is task 0
        STR     R14,taskhandle
        BL      int_sendmessage
        Pull    "R14"
        STR     R14,taskhandle
        Pull    "PC"


; NK's optimise
; if there is already a message_slot_size on the message queue
; for this task, then just update it rather than add another.

      [ NKmessages2

check_mem_message
        TEQ     R0,#User_Message
        MOVNE   PC,LR

        Push    "R7,LR"
        LDR     R7,=Message_SlotSize
        LDR     LR,[R1,#16]
        TEQ     LR,R7
        Pull    "R7,PC",NE

; check queue
        Push    "R0-R3"
        LDR     R0,headpointer
        LDR     R2,taskhandle
        CMP     R2,#0
        LDRGT   R14,[wsptr,R2]          ; NB task must be alive!
        LDRGT   R14,[R14,#task_flagword]
        MOVGT   R14,R14,LSR #flag_versionbit
        ORRGT   R2,R2,R14,LSL #flag_versionbit
        CMP     R0,#nullptr
        LDRNE   R0,[R0,#msb_link]       ; skip first message on stack - it may already have been delivered to some tasks
05
        CMP     R0,#nullptr
        BEQ     %FT99
        LDR     R3,[R0,#msb_reasoncode]
        TEQ     R3,#User_Message
        LDREQ   R3,[R0,#msb_sender]
        TEQEQ   R3,R2
; its the same task, is it the right message?
        LDREQ   R3,[R0,#msb_size+16]
        TEQEQ   R3,R7
        LDRNE   R0,[R0,#msb_link]
        BNE     %BT05

        LDR     R2,[R1,#24]             ; new next slot
        LDR     R1,[R1,#20]             ; new current

        STR     R1,[R0,#msb_size+20]
        STR     R2,[R0,#msb_size+24]
        Pull    "R0-R3,R7,PC"

99
        CMP     PC,#0
        Pull    "R0-R3,R7,PC"
      ]


int_sendmessage
        Push    "R3-R7,handle,LR"
;
        Debuga  ms,"*"
;
; validate receiving task / window handle
;
      [ NKmessages2
        BL      check_mem_message
        Pull    "R3-R7,handle,PC",EQ
      ]

        MOV     R6,#msh_wastask         ; assume not a window handle first
;
        CMP     R2,#0                   ; 0 ==> broadcast to all tasks
        LDREQ   R2,=(:INDEX:taskpointers):OR:msf_broadcast
        BEQ     gottaskhandle
;
        TST     R2,#3
        BEQ     trytaskhandle
;
        CMP     R2,#nullptr2            ; is this the icon bar?
        MOVNE   R6,R2                   ; R6 = window handle
        BNE     %FT01
;
        Push    "R0,R1"
        ORR     R6,R3,#msh_iconbar      ; R6 = window/icon handle
        MOV     R4,R3                   ; R4 = icon handle
        BL      findicon                ; R7 --> iconbar left/right (ignored)
        Pull    "R0,R1"
        LDREQ   R2,[R2,#icb_taskhandle]
        MOVNE   R2,#0                   ; if not found, don't deliver
        B       %FT02                   ; else add in version bits
01
        MOVS    handle,R2               ; if R2<0, treat as system window
        MOVMI   R2,#0                   ; 0 => system, -1 => menu
        BLPL    checkhandle             ; preserves flags (unless error)
        Pull    "R3-R7,handle,PC",VS    ; illegal window handle
        LDRPL   R2,[handle,#w_taskhandle]
02

; see if this window belongs to the Wimp or the menu owner
; if version 2.18 or later, menu owners can receive messages for menus

        CMP     R2,#0                   ; get the Wimp to interpret some actions
        CMPLE   R0,#Close_Window_Request
        LDRLE   R2,=MSToWimpMagicHandle ; Special Wimp window task handle for message system
        BLE     gottaskhandle

        CMP     R2,#0                   ; if this is a Wimp window,
        BGT     %FT03
        LDRLT   R2,menutaskhandle       ; see if the menu owner is clever
        CMPLT   R2,#0
        MOVLT   R2,#0
        BLE     gottaskhandle           ; don't deliver if Wimp window or no menus

        LDR     R14,[wsptr,R2]
        TST     R14,#task_unused
        MOVNE   R14,#0
        LDREQ   R14,[R14,#task_wimpver] ; does it know about Wimp 2.18?
        CMP     R14,#218
        MOVLT   R2,#0
        BLT     gottaskhandle
03

; convert internal task handle to external form

        LDR     R14,[wsptr,R2]          ; add in version bits (if alive)
        TST     R14,#task_unused
        LDREQ   R14,[R14,#task_flagword]
        MOVEQ   R14,R14,LSR #flag_versionbit
        ORREQ   R2,R2,R14,LSL #flag_versionbit
        B       gottaskhandle

trytaskhandle
        BL      validtask               ; In: R2=task, Out: R5=internal task
        BVS     %FT99                   ; don't worry if it's dead yet

; work out sender for all types of message

gottaskhandle
        LDR     R4,taskhandle           ; set up sender and myref fields
        CMP     R4,#0
        LDRGT   R14,[wsptr,R4]          ; NB task must be alive!
        LDRGT   R14,[R14,#task_flagword]
        MOVGT   R14,R14,LSR #flag_versionbit
        ORRGT   R4,R4,R14,LSL #flag_versionbit
        STR     R4,sender               ; used later when block is copied
;
; now check for user message / other reason code
;
        Debug   ms,"SendMessage: R0,R1,R2,R6 (processed) =",R0,R1,R2,R6
        TEQ     R0,#User_Message
        TEQNE   R0,#User_Message_Recorded
        TEQNE   R0,#User_Message_Acknowledge
        BNE     notusermess
;
        Push    "R3-R7"
        LDMIA   R1,{R3-R7}
        Debug   ms,"UserMessage:",R3,R4,R5,R6,R7
        Pull    "R3-R7"
;
; delete queued message if referenced by 'yourref'
; (it is being acknowledged)
;
        LDR     R3,[R1,#ms_yourref]             ; NB: ms_ not msb_ !!!
        ADR     R4,headpointer-msb_link
01
        LDR     R5,[R4,#msb_link]
        CMP     R5,#nullptr
        BEQ     doneackmess                     ; finished
        LDR     R14,[R5,#msb_myref]
        TEQ     R14,R3                          ; same id?
        MOVNE   R4,R5
        BNE     %BT01

        [ true
        LDR     R14,[R5,#msb_reasoncode]                ; WAGA WAGA WAGA!!!!
        TEQ     R14,#User_Message
        TEQNE   R14,#User_Message_Recorded
        TEQNE   R14,#User_Message_Acknowledge
        MOVNE   R4,R5

        BNE     %BT01
        ]
;
        Debug   ms,"Acknowledged block deleted:",R5
        Push    "R0-R2"
        LDR     R14,[R5,#msb_link]              ; #nullptr in version 1.43 !!!
        STR     R14,[R4,#msb_link]
        CheckMsgQ
        MOV     R0,#ModHandReason_Free
        MOV     R2,R5
        BL     XROS_Module
        Pull    "R0-R2"                 ; ignore errors
doneackmess
;
; set up sender and myref fields automatically
; NB: sender taskhandle includes version number bits!
;
        LDR     R14,myref
        ADDS    R14,R14,#1              ; clears V too!
        ADDEQ   R14,R14,#1              ; avoid 0
        STR     R14,myref
;
        LDR     R3,ROMstart
        LDR     R5,ROMend
        CMP     R1,R3                   ; don't splat the ROM!
        CMPHS   R5,R1
        LDR     R4,sender               ; worked out earlier
        STRLO   R4,[R1,#ms_sender]
        STRLO   R14,[R1,#ms_myref]
        Debug   ms,"New sender,my_ref =",R4,R14
;
; check for User_Message_Acknowledge - if it is, then don't actually send it
; (the message has already done its job)
;
        TEQ     R0,#User_Message_Acknowledge
        BEQ     %FT99                   ; return R2 = actual task handle

notusermess
        BL      calcmessagesize         ; R0,R1 = reasoncode,block;
;                                       ; on exit R3 = size
        Push    "R0-R3"                 ; reasoncode,block,receiver,size
        ADDVC   R3,R3,#msb_size
        BLVC    claimblock              ; R2 --> allocated block
        ADDVS   sp,sp,#4*4
        BVS     %FT99

; use lastpointer to determine where we should put the message

      [ NKmessages1
        LDR     R4,lastpointer
        CMP     R4,#nullptr
        ADREQ   R4,headpointer-msb_link
      |
        ADR     R4,headpointer-msb_link
01
        LDR     R14,[R4,#msb_link]
        CMP     R14,#nullptr
        MOVNE   R4,R14
        BNE     %BT01
      ]

        STR     R2,[R4,#msb_link]       ; add to end of list (FIFO)
        STR     R6,[R2,#msb_handle]     ; hope this is still intact!
      [ NKmessages1
        STR     R2,lastpointer
      ]

        Pull    "R4-R7"
;
; R4=reasoncode, R5=block, R6=receiver, R7=size
;
        MOV     R0,#nullptr
        ASSERT  msb_link = 0
        ASSERT  msb_receiver = 4
        ASSERT  msb_allsender = 8
        LDR     R14,sender
        STMIA   R2,{R0,R6,R14}
;
        STR     R4,[R2,#msb_reasoncode] ; reason code
        ADD     R2,R2,#msb_size
        B       %FT03
01
        LDR     R14,[R5,R7]
        TEQ     R4,#User_Message        ; can't be User_Message_Acknowledge!
        TEQNE   R4,#User_Message_Recorded
        BNE     %FT02
        TEQ     R7,#ms_sender
        LDREQ   R14,sender              ; in case block was in ROM
        TEQ     R7,#ms_myref
        LDREQ   R14,myref               ; ditto
02
        STR     R14,[R2,R7]
03
        SUBS    R7,R7,#4                ; now the actual message block
        BPL     %BT01
;
; message is not actually sent until the next Wimp_Poll
;
        MOVS    R2,R6                   ; on exit R2 = actual task handle
        MOVMI   R2,#0                   ; if broadcast, don't confuse punter
99
        MOVVS   R2,#0                   ; message not sent if error occurs
        Pull    "R3-R7,handle,PC"

        LTORG

; Get the Wimp to decide a message directly, if addressed at a system window
; In:   R2 -> msb message block
;       R5 = MSToWimpMagicHandle
; Out:  Goes to postposting (to junk message)
;       R2, R5 preserved

autowimp_menu
        LDR     R0,[R2,#msb_reasoncode]
        TEQ     R0,#Open_Window_Request
        BEQ     %FT01
        TEQ     R0,#Close_Window_Request
        BNE     postposting
        LDR     R0,[R2,#msb_size+u_handle]
        BL      int_close_window
        B       postposting
01
        Push    "R2,R5"
;
        LDR     R1,[R2,#msb_allsender]
        Debug   autoopen,"Open request came from task :",r1
        TEQ     r1,#0
        Pull    "R2,R5",NE
        BNE     postposting             ; refuse to open if not from WIMP.
;
        ADD     R1,R2,#msb_size
        MOV     userblk,R1
        Debug   opn,"Openning one of the wimp's windows..."
        BL      int_open_window
        Debug   opn,"Wimp window successfully opened"
        Pull    "R2,R5"
        B       postposting

;
; Entry:  R2 = external task handle
; Exit:   R5 = internal task handle, V clear (if valid)
;         R0 --> "Bad Task handle", V set (if invalid)
;         note that the version bits are not validated at this stage
;         preserves all but R5 if no error
;

validtask
        Push    "R3,LR"
;
        LDR     R5,=:INDEX:taskpointers
        MOV     R3,#maxtasks
        MOV     R14,R2,LSL #32-flag_versionbit
01
        TEQ     R14,R5,LSL #32-flag_versionbit
        Pull    "R3,PC",EQ              ; do this even if task is dead
        ADD     R5,R5,#4                ; (message is ignored later)
        SUBS    R3,R3,#1
        BNE     %BT01
        Debug   opn,"**** validtask fails handle",R2
        MyXError  WimpBadTaskHandle
        Pull    "R3,PC"
        MakeErrorBlock WimpBadTaskHandle
        LTORG

;
; Entry:  R2 = external task handle
; Exit:   R5 = internal task handle, V clear (if valid)
;         R6 --> task block (if alive)
;         R0 --> "Bad Task handle", V set (if invalid, or dead)
;

validtask_alive
        Push    "LR"
;
        BL      validtask
        Pull    "PC",VS
;
        LDR     R6,[wsptr,R5]          ; if this is not the same task
        TST     R6,#task_unused
        LDREQ   R14,[R6,#task_flagword]        ; (compare version numbers)
        MOVEQ   R14,R14,LSR #flag_versionbit
        TEQEQ   R14, R2,LSR #flag_versionbit
      [ debug
        Pull    "PC",EQ
        Debug   err,"**** validtask_alive fails handle",R2
      ]
        MyXError  WimpBadTaskHandle,NE
        Pull    "PC"

;
; Entry:  R0 = reason code
;         R1 --> user block
;

calcmessagesize
        Push    "LR"
;
        CMP     R0,#max_reason
        BCS     err_badreason
        ADR     R14,mess_sizes
        LDR     R3,[R14,R0,LSL #2]
        CMP     R3,#0
        Pull    "PC",GE                 ; < 0 ==> work it out
;
        TEQ     R0,#Menu_Select
        BEQ     go_menuselsize
        TEQ     R0,#User_Message
        TEQNE   R0,#User_Message_Recorded
        TEQNE   R0,#User_Message_Acknowledge
        BNE     err_badreason
        LDR     R3,[R1,#ms_size]
        TST     R3,#3                   ; must be a multiple of 4
        BNE     err_badmesssize
        CMP     R3,#max_messsize
        RSBLSS  R14,R3,#min_messsize   ; must include header
        Pull    "PC",LS

err_badmesssize
        MyXError  WimpBadMessageSize
        Pull    "PC"

mess_sizes
        DCD     4 * 0                   ; null
        DCD     4 * 1                   ; redraw_window
        DCD     4 * 8                   ; open_window (wh,x0,y0,x1,y1,sx,sy,bh)
        DCD     4 * 1                   ; close_window
        DCD     4 * 1                   ; ptr_leaving_window
        DCD     4 * 1                   ; ptr_entering_window
        DCD     4 * 6                   ; mouse_click (mx,my,bt,wh,ih,ob)
        DCD     4 * 4                   ; user_dragbox (x0,y0,x1,y1)
        DCD     4 * 7                   ; key_pressed (wh,ih,x,y,h,i,k)
        DCD     -1                      ; menu_select
        DCD     4 * 10                  ; scroll_window (cf. open_window)
        DCD     4 * 6                   ; lose_caret
        DCD     4 * 6                   ; gain_caret
        DCD     0               ;
        DCD     0               ; reserved (13..16)
        DCD     0               ;
        DCD     0               ;
        DCD     -1                      ; user_message
        DCD     -1                      ; user_message_recorded
        DCD     -1                      ; user_message_acknowledge
        ASSERT  (.-mess_sizes) = max_reason*4

go_menuselsize
        MOV     R3,R1                   ; R3 --> start of block
01
        LDR     R14,[R3],#4
        CMP     R14,#0                  ; stop on -1
        BGE     %BT01
        SUB     R3,R3,R1                ; R3 = size of block
        Pull    "PC"

err_badreason
        MyXError  WimpBadReasonCode
        Pull    "PC"

        MakeErrorBlock WimpBadMessageSize
        MakeErrorBlock WimpBadReasonCode

;
; mark any queued messages relating to windows/icons if window/icon deleted
; Entry:  R0 = window/icon handle
;

msh_iconbar     *       1:SHL:30
msh_wastask     *       1:SHL:29

byemessages
        Push    "R1,LR"
;
        ADR     R1,headpointer-msb_link
01
        LDR     R1,[R1,#msb_link]
        CMP     R1,#nullptr
        Pull    "R1,PC",EQ
;
        LDR     R14,[R1,#msb_handle]
        TEQ     R14,R0
        MOVEQ   R14,#0
        STREQ   R14,[R1,#msb_receiver]  ; this won't now be delivered
        B       %BT01


;;----------------------------------------------------------------------------
;; Start task
;; Entry:  R0 --> command (passed to XOS_CLI)
;; Exit:   eventually the Wimp will get back to you !!!
;;----------------------------------------------------------------------------

SWIWimp_StartTask
        MyEntry "StartTask"
;
; you can only start a task if you are a live Wimp task yourself
;
        LDR     R5,taskhandle
        LDR     R6,singletaskhandle
        TEQ     R5,R6
        LDRNE   R4,[wsptr,R5]                   ; check that parent is alive
        TEQNE   R4,#task_unused                 ; note TEQ not TST !!!
        MyXError  WimpCantTask,EQ
;
; save FP registers on Wimp_StartTask if task knows about Wimp 2.23 onwards
;
        BLVC    saveFPregs                      ; R4 -> task block
        BVS     ExitWimp
;
; save VFP context, lazily if possible
;
        Push    "R0-R1"
        MOV     R0,#0
        MOV     R1,#VFPSupport_ChangeContext_Lazy+VFPSupport_ChangeContext_AppSpace
        SWI     XVFPSupport_ChangeContext
        MOVVS   R0,#0 ; Ignore error (probably means VFPSupport isn't loaded)
        Debug   fp,"VFP on Wimp_StartTask entry",R0
        STR     R0,[R4,#task_vfpcontext]
        Pull    "R0-R1"
;
; find a spare task handle for the new task
;
        ADRL    R5,taskpointers
        MOV     R6,#maxtasks
01
        LDR     R14,[R5],#4
        TST     R14,#task_unused
        BNE     %FT02
        SUBS    R6,R6,#1
        BNE     %BT01
;
        MyXError  WimpNoTasks
        B       ExitWimp
02
        SUB     R5,R5,#4                ; R5 --> task data pointer entry
;
; now stash the parent task on the return stack, and start up the new one
;
        ADRL    R1,taskbuffer
01
        LDRB    R14,[R0],#1
        STRB    R14,[R1],#1
        CMP     R14,#32                 ; terminate on any ctrl-char
        BCS     %BT01
;
        BL      mapslotout              ; map parent out of the way
;
        LDR     R14,taskSP
        LDR     handle,polltaskhandle
        STR     handle,[R14],#4         ; empty ascending stack
        STR     R14,taskSP
        SUB     R14,R5,wsptr
        STR     R14,taskhandle
;
; we must mark the task used, so that ExitPoll can swap into it
; Version number = 0 => task is not initialised
;
        MOV     R0,#0                   ; latest known Wimp version
        BL      markinitialised         ; changes task 'version number'
        BVS     ExitWimp
;
        LDR     R14,taskhandle          ; assume single-tasking for now
        STR     R14,singletaskhandle
;
        MOV     R14,#0                  ; reset all handlers
        STR     R14,handlerword
        STR     R14,parentquithandler   ; must start application !!!
        BL      setdefaulthandlers
;
; allocate memory for the new task, then use callback to start it up
; [taskbuffer..] contains the *command to execute
;
        ADRL    R14,Module_BaseAddr
        BL      allocateslot            ; updates memorylimit
;
        ADRL    R0,taskbuffer           ; copy of *command is in here
        LDR     R5,taskhandle
        LDR     R5,[wsptr,R5]
        ADRL    R14,runthetask          ; PC must be set up explicitly
        STR     R14,[R5,#task_registers+4*15]   ; note PC has no flags, ie USR on 26-bit
        ; this next bit is harmless on a 26-bit system, as the 17th word is ignored
        MRS     R14,CPSR
        BIC     R14,R14,#2_11101111     ; get USR26/USR32, ARM, FIQs+IRQs on
        STR     R14,[R5,#task_registers+4*16]


;
; to be on the safe side, bring up a text window if any chars printed
;
        Push    "R0"                    ; this allows escape etc.
        SWI     XWimp_CommandWindow     ; in case this is a wally task
        Pull    "R0"                    ; Remember *command ptr
        CLRV

        B       ExitPoll_tochild        ; swap tasks, and end up at 'runthetask'

        MakeErrorBlock WimpCantTask
        MakeErrorBlock WimpNoTasks

;
; Entry point where we run the task!
; Entry:  R0 --> command to execute
;         entered in USR mode (I hope!)
;

runthetask
        MOV     R1,R0                   ; close down the task !!!
        SWI     Wimp_CloseDown

        MOV     R0,R1
        SWI     OS_CLI                  ; R0 --> OS_CLI command
        SWI     OS_Exit                 ; exit back to Wimp

;
; set up default environment handlers (Wimp should replace them all)
; only reset the ones corresponding to 0 bits in [handlerword]
;  0 in table ==> leave alone (MemoryLimit,ApplicationSpaceSize)
;  1 in table ==> use default handler
; >1 in table ==> use values in table
;

setdefaulthandlers
        Push    "R1-R6,LR"
;
        ADR     R4,defaulthandlers      ; R4 --> data
        LDR     R5,handlerword          ; R5 = flag word (0 bit ==> set it)
        MOV     R6,#MaxEnvNumber
01
        LDR     R1,[R4],#4              ; if zero, it's not an address offset
        TEQ     R1,#0
        RSBEQ   R0,R6,#MaxEnvNumber     ; R1=0 ==> use default handler
        SWIEQ   XOS_ReadDefaultHandler  ; NB: R0 can be set to 0 by this call!
        Pull    "R1-R6,PC",VS
        ADDNE   R1,R1,R4                ; R1 --> code address
        MOVNE   R2,wsptr
        ADRNE   R3,errorbuffer
02
        MOVS    R5,R5,LSR #1            ; has this handler been set already?
        RSBCC   R0,R6,#MaxEnvNumber
        SWICC   XOS_ChangeEnvironment
        SUBS    R6,R6,#1
        BNE     %BT01
;
        Pull    "R1-R6,PC"

;
; Default settings to pass to SWI XOS_ChangeEnvironment
;       R1 --> code address / buffer pointer
;       R2  =  returned in R12 (if R1 is an address) - maybe
;       R3 --> block           (if R1 is an address)
;

defaulthandlers
        DCD     0                       ; MemoryLimit

        DCD     0                       ; UndefinedHandler
        DCD     0                       ; PrefetchAbortHandler
        DCD     0                       ; DataAbortHandler
        DCD     0                       ; AddressExceptionHandler
        DCD     0                       ; OtherExceptionHandler

        DCD     Do_ErrorHandler-.-4
        DCD     0                       ; CallBackHandler
        DCD     0                       ; BreakPointHandler

        DCD     0                       ; EscapeHandler
        DCD     0                       ; EventHandler
        DCD     Do_ExitHandler-.-4
        DCD     0                       ; UnusedSWIHandler

        DCD     0                       ; ExceptionDumpArea
        DCD     0                       ; ApplicationSpaceSize
        DCD     Module_BaseAddr-.-4     ; CAO pointer

        DCD     0                       ; upcall handler

        ASSERT  (.-defaulthandlers)/4 = MaxEnvNumber

;
; report error contained in errorhandlerbuffer
; in USR mode here!
;

Do_ErrorHandler
        MOV     R12,R0                  ; wsptr is in R0!
      [ debugtask1
        ADRL    R13,stackspace
        Debuga  task1,"Error reported to Wimp: "
        CLI     "HostVdu"
        ADRL    R0,errorbuffer+8        ; skip saved PC & error number
        SWI     XOS_Write0
        SWI     XOS_NewLine
        CLI     "TubeVdu"
      ]
        ADRL    R0,errorbuffer+4        ; skip saved PC
        MOV     R1,#erf_cancelbox:OR:erf_htcancel:OR:erf_dontwait
        MOV     R2,#nullptr                        ; no application
        SWI     XWimp_ReportError
        SWI     XOS_Exit                ; must abort task (no error handler)

;
; delete task and exit back to the Wimp
; NB we must be in USR mode !!!
; NB Wimp_CloseDown causes the command window to be closed too
;

Do_ExitHandler
      [ debugtask1
        ADRL    R13,stackspace          ; need some stack to call debug!
      ]
        SWI     XWimp_CloseDown         ; delete task (may restore handler)
01
        MOV     R0, #198                ; read EXEC file handle
        MOV     R1, #0
        MOV     R2, #&FF
        SWI     XOS_Byte
        TEQ     R1, #0                  ; was an EXEC file open?
        BEQ     %FT02

        MOV     R0,#OSArgs_EOFCheck     ; if end of file, ignore it!
        SWI     XOS_Args
        TEQ     R2,#0
        BNE     %FT02

        ADR     r0, CliDPrompt
        ADR     r1, errorbuffer
        MOV     r2, #?errorbuffer
        MOV     r3, #0
        MOV     r4, #3
        SWI     XOS_ReadVarVal
        MOVVC   r0,r1
        MOVVC   r1,r2
        ADRVS   r0, DefaultPrompt
        MOVVS   r1, #1
        SWI     OS_WriteN

        ADR     R0,errorbuffer
        MOV     R1,#?errorbuffer
        MOV     R2,#32
        MOV     R3,#&FF
        SWI     OS_ReadLine             ; provoke errors (handler is there)
        SWICC   OS_CLI                  ; should preserve flags
        BCC     %BT01

        MOV     R0,#126                 ; acknowledge escape
        SWI     OS_Byte
        ADR     R0,ErrorBlock_Escape
        MOV     R1,#0
        MOV     R2,#0                   ; global error
        SWI     MessageTrans_ErrorLookup
        SWI     OS_GenerateError        ; generate escape error
        MakeErrorBlock Escape

02
        Debug   task1,"Exitting back to Wimp"
        ADR     R1,errorbuffer          ; ensure R1 > &8000 !!!
        SWI     XWimp_Poll              ; if task returns, it must be the last
        Debug   task1,"Poll returns - Exitting from Wimp"
        SWI     OS_Exit

CliDPrompt      =       "CLI$Prompt", 0
      [ debug
        ALIGN
      ]
DefaultPrompt   =       "*"
                ALIGN


;;-----------------------------------------------------------------------------
;; Exit point for task-switching
;;-----------------------------------------------------------------------------

; Report any errors during Wimp_Poll internally, unless single-tasking

reporterror
        LDR     R5,taskhandle
        LDR     R6,singletaskhandle
        TEQ     R5,R6
        BEQ     returnerror             ; can return errors to single task

        MOV     R1,#erf_okbox
        ADR     R2,wimp
        SWI     XWimp_ReportError
        B       repollwimp

wimp    DCB     "Wimp",0
        ALIGN

ExitPoll_tochild
        Debug   task1,"Exit to child:",#taskhandle
        MOV     R14,#-2
        STR     R14,sender              ; don't call postfilters
        B       ExitPoll

ExitPoll_toparent
        Debug   task1,"Exit to parent:",#taskhandle
        MOV     R14,#-1
        STR     R14,sender              ; don't return R2 from Wimp_StartTask

ExitPoll
        Debug   poll2, "ExitPoll"
        BVS     reporterror             ; don't return to caller
returnerror

; The Wimp MUST NOT exit to a dead task (no register data !!!)
; Wimp_Poll tries to find a live task on entry - it calls OS_Exit if none left

        LDR     handle,taskhandle
;
        LDR     R14,ptr_DomainId
        STR     handle,[R14]            ; for Stuart

        Debug   task,"Exit Poll: (old),task,reason =",#polltaskhandle,handle,R0

        TEQ     R0,#No_Reason           ; Not a null event?
 [ Stork
  [ PokeBorder
        Push    "R0-R1",NE
        LDRNE   R1, =&40FFFF00          ; cyan = fast
        MOVNE   R0, #VIDC
        STRNE   R1, [R0]
        Pull    "R0-R1",NE
  ]
        LDRNE   R14, WimpPortableFlags
        BICNE   R14, R14, #PowerSave
        STRNE   R14, WimpPortableFlags  ; (so go at full speed)
        TSTNE   R14, #PortableFeature_Speed     ; And speed switching works?
 |
        LDRNE   R14,WimpPortableFlag
        TEQNE   R14,#0                  ; And the portable module present?
 ]
        BEQ     %FT01
        Push    "R0-R1"
        MOV     R0,#0
        MOV     R1,#0
        SWI     XPortable_Speed         ; if not a null event then make it go fast
        Pull    "R0-R1"
01
      [ debugtask3
        LDR     R14,singletaskhandle
        CMP     R14,#nullptr            ; if single-tasking,
        CMPNE   R14,handle              ; we mustn't exit to anyone else!!!
        BEQ     %FT01
        Debug   task3,"Task swap: single,taskhandle =",R14,handle
01
      ]

;
      [ StartTaskPostFilter
        LDR     R14,sender
        CMP     R14,#-1
        BLT     %FT01                ; Are we starting up Wimp_StartTask?
        BNE     %FT02                ; Are we returning from Wimp_StartTask?

; We're returning from Wimp_StartTask and
; R0 = task handle of child (or 0). Wimps before 3.96
; would not call the post-filter in this case, but would
; call it if Wimp_StartTask returned 0 (so the filter
; would think a null event was happening.) Now, the
; Toolbox (and probably other filters) relies on the
; post filter to monitor the current task. If the postfilter
; doesn't get called here then there is no way of telling
; that this task has become active. So, we now call the filter
; with a null event, and ignore any attempt to claim it. (In
; the past the filter was able to claim the "null" event if
; Wimp_StartTask returned 0, causing instant death.
; This is the problem that hit Toolbox 1.33).
;
; Hopefully this shouldn't cause any problems, as filters
; will have had to be able to deal with the dummy "null"
; event for at least some Wimp_StartTask calls already.

        Push    "R0,R1"
        MOV     R0,#No_Reason
        MOV     R1,userblk
        CallFilter postfilter           ; call the post-poll filter (ignoring
        Pull    "R0,R1"                 ; R0 return)
        B       %FT01

02
      |
        CMP     R0,#max_reason          ; Valid message?
        BHS     %FT01                   ; No then jump,maybe -> *command from Wimp_StartTask
      ]

        Push    "R1"
        MOV     R1,userblk
        CallFilter postfilter           ; call the post-poll filter
        Pull    "R1"
        CMP     R0,#-1
        BEQ     repollwimp              ; if it claimed then just re-poll
01

        Push    "R0-R1"
        LDR     R4,[wsptr,handle]
        TEQ     R4,#task_unused

      [ debugtask4
; Stamp with event time for task priority and swapping

        SWINE   XOS_ReadMonotonicTime
        BEQ     %FT00
        Debug   task4,"Time",R0
00
        STRNE   R0,[R4,#task_eventtime]
      ]

; restore FP registers if they were saved (ie. save block present)

        LDRNE   R0,[R4,#task_fpblock]
        TEQNE   R0,#0                   ; NE => restore registers
        MOVEQ   R5,#C_runtime_status    ; ensure caller gets &70000 if he didn't save regs
        WFSEQ   R5
        BEQ     %FT01

        Debug   fp,"Restoring FP state from block at",R0

        MOV     R5,#0                   ; avoid FP exceptions
        WFS     R5                      ; will still occur if FPEmulator RMKilled
      [ FPE4
       [ false
        LFM     F0,4,[R0,#fp_reg0]      ; (only gets here if active previously)
        LFM     F4,4,[R0,#fp_reg4]
       |
        ; AAsm assembles the above as post-indexed not pre-indexed.
        ; Do it manually (bluch).
        DCD     &ED900200 :OR: (fp_reg0:SHR:2)
        DCD     &ED904200 :OR: (fp_reg4:SHR:2)
       ]
      |
        LDFE    F0,[R0,#fp_reg0]        ; (only gets here if active previously)
        LDFE    F1,[R0,#fp_reg1]
        LDFE    F2,[R0,#fp_reg2]
        LDFE    F3,[R0,#fp_reg3]
        LDFE    F4,[R0,#fp_reg4]
        LDFE    F5,[R0,#fp_reg5]
        LDFE    F6,[R0,#fp_reg6]
        LDFE    F7,[R0,#fp_reg7]
      ]
        LDR     R5,[R0,#fp_status]
        WFS     R5
01
; restore VFP context
        TEQ     R4,#task_unused
        LDRNE   R0,[R4,#task_vfpcontext]
        MOVNE   R1,#VFPSupport_ChangeContext_Lazy
        TEQNE   R0,#0 ; We should already be on the null context, so only call if user does have a context to restore
        DebugIf NE,fp,"VFP on Wimp_Poll exit",R0
        SWINE   XVFPSupport_ChangeContext
        Pull    "R0-R1"

      [ AutoHourglass
        Push    "R0-R2"
        LDR     R1, hourglass_status
      [ debugautohg
        Push    "handle"
        LDR     handle, taskhandle
        Debug   autohg, "Hourglass_On  at task switch: taskhandle, old status =", handle, R1
        Pull    "handle"
      ]
        TEQ     R1, #2
        SWIEQ   XHourglass_Off          ; if autohourglass is still pending or animating, turn it off
        TEQ     R1, #0
        MOVEQ   R0, #WrchV              ; get back on WrchV if necessary
        ADREQ   R1, deactivate_hourglass_on_wrchv
        BLEQ    claim

        MOV     R0, #hourglass_delay
        SWI     XHourglass_Start        ; turn on using special delay time
        CLRV                            ; ignore errors
        MOV     R1, #2
        STR     R1, hourglass_status    ; mark autohourglass fully active
        Pull    "R0-R2"
      ]
        BL      DeletePollTask          ; Delete task from polltask list

; don't need to do callback if this is the same task

        LDR     R14,polltaskhandle      ; see if this is the same task
        TEQ     handle,R14              ; NB doesn't affect V flag!!!
        BEQ     putsender_ExitWimp      ; exit, and set up R2 if required
;
; ensure that R0 and the flags are passed back to the correct task
; bodge: if same task, also keep R0 and flags now
;
      [ No32bitCode
        Push    "R0,PC"                 ; save R0 and flags
        SETPSR  I_bit, R5               ; disable interrupts
      |
        MRS     R5,CPSR
        Push    "R0,R5"
        ORR     R5,R5,#I32_bit
        MSR     CPSR_c,R5
      ]
;                                       ; NB preserve R14 in this code
        LDR     R5,[wsptr,handle]
        STR     R0,[R5,#task_registers+4*0]
      [ No32bitCode
        LDR     R0,[R5,#task_registers+4*15]
      |
        TEQ     PC,PC                           ; 32-bit system?
        LDRNE   R0,[R5,#task_registers+4*15]    ; 26-bit: modify R15
        LDREQ   R0,[R5,#task_registers+4*16]    ; 32-bit: modify CPSR
      ]
        BICVC   R0,R0,#V_bit            ; set up correct V bit
        ORRVS   R0,R0,#V_bit
      [ No32bitCode
        STR     R0,[R5,#task_registers+4*15]   ; save for new task
      |
        STRNE   R0,[R5,#task_registers+4*15]
        STREQ   R0,[R5,#task_registers+4*16]
      ]
;
; set up callback handler
; NOTE: since the task is already paged in, its handlers are set up already
; XXXX: it appears that the handlers are not always in the block yet!
;
        Debug   task1,"Setting callback handler"
;
        MOV     R0,#CallBackHandler     ; be careful when old task is dead
        ADR     R1,callbackpoll
        MOV     R2,wsptr
        LDR     R3,[wsptr,R14]          ; save old task registers
        TST     R3,#task_unused
        ADDEQ   R3,R3,#task_registers   ; be careful of dead tasks!
        ADRNEL  R3,registerbuffer       ; use temporary buffer (regs ignored)
        SWI     XOS_ChangeEnvironment
        ADR     R14,oldcallback
        STMIA   R14,{R1-R3}             ; will be restored later
;
; Exit temporarily - comes back to callback handler
; NB -- SWI XWimp_Poll must be used, since I don't know about bit 17
;
        SWI     XOS_SetCallBack         ; set call back flag
;
        Pull    "R0,R14"
      [ No32bitCode
        TEQP    R14,#0                  ; restore flags, ready for exit
      |
        MSR     CPSR_cf,R14             ; restore flags+ints, ready for exit
      ]
;
        B       ExitWimp_noswitch       ; pulls registers & exits to callback

;..............................................................................

; here R12 --> workspace (set up by ChangeEnvironment)
;
; Should enter this code in SVC mode with Ints off
; restore environment for new task

callbackpoll
      [ debugtask
        Push    "R0,LR"
;
      [ No32bitCode
        Push    "PC"
        Pull    "R0"
        AND     R0,R0,#ARM_CC_Mask
      |
        MRS     R0, CPSR
      ]
        Debug   task,"Flags on entry to callbackpoll:",R0
;
        Pull    "R0,LR"
      ]
;
        LDR     R14,taskhandle
        LDR     R4,[wsptr,R14]          ; NB task cannot be dead
        BL      getsender_R2                    ; if [R4,#task_wimpver] >= 253
        STRGE   R2,[R4,#task_registers+2*4]     ; return R2 = sender's handle

        ADR     R0,oldcallback
        LDMIA   R0,{R1-R3}
        MOV     R0,#CallBackHandler
        SWI     XOS_ChangeEnvironment   ; restore client's handler!
;
; exit to caller
;
        TEQ     PC,PC                           ; are we 26 or 32-bit?
        ADD     lr_svc,R4,#task_registers       ; lr_svc --> register block
        LDREQ   R0,[lr_svc,#16*4]
        MSREQ   SPSR_cxsf,R0
        LDMIA   lr_svc,{R0-R14}^                ; restore USR regs
        NOP
        LDR     lr_svc,[lr_svc,#15*4]
        MOVS    PC,lr_svc                       ; exit to caller, restoring flags

;..............................................................................

; WrchV routine to deactivate the autohourglass as soon as a character is output.
; The argument for this is that if the task is plotting something, you probably
; don't need the Wimp putting up an hourglass to let you know that the machine
; hasn't stiffed.
; Using this approach, the hourglass isn't shown, for example, while Paint is
; doing a screen grab (it doesn't Wimp_Poll, but it does plot a box on the screen).
; It also copes transparently with command windows, ShellCLI etc.

; On entry:  R12 -> workspace
;            [hourglass_status] = 1 or 2 (by definition)
;            processor is in SVC mode

      [ AutoHourglass
deactivate_hourglass_on_wrchv Entry "R0-R2"
        LDR     R1, hourglass_status
        Debug   autohg, "Hourglass_Off at WrchV, old status =", R1
        TEQ     R1, #2
        SWIEQ   XHourglass_Off          ; turn off hourglass if necessary
        MOV     R0, #WrchV
        ADR     R1, deactivate_hourglass_on_wrchv
        BL      release                 ; release WrchV
        MOV     R1, #0
        STR     R1, hourglass_status    ; mark fully deactivated
        EXITS                           ; pass on call (NB: nowhere to return errors to)
      ]

;.............................................................................

; In    R4 -> task block of current task
; Out   FP registers saved if FPEmulator present and task knows Wimp 2.23

saveFPregs
        EntryS  "R0-R3"

        Debug   fp,"Saving FP state for task",#taskhandle
        Debuga  fp,"Reading FP status: "

        RFS     R1                      ; <==== NB: pending trap can occur here
                                        ; so do it before claiming block!
        Debug   fp," value =",R1

        LDR     R2,[R4,#task_fpblock]           ; block may already be claimed
        CMP     R2,#0                           ; (assume will be required again)
        MOVEQ   R3,#fp_size
        BLEQ    claimblock                      ; R2 -> block address
        STRVS   R0,[sp,#Proc_RegOffset]
        EXIT    VS
        STR     R2,[R4,#task_fpblock]

        Debug   fp,"FP save block at",R2

        STR     R1,[R2,#fp_status]
        LDR     R1,=C_runtime_status            ; now C run-time status value
        WFS     R1
      [ FPE4
       [ false
        SFM     F0,4,[R2,#fp_reg0]
        SFM     F4,4,[R2,#fp_reg4]
       |
        ; AAsm assembles the above as post-indexed not pre-indexed.
        ; Do it manually (bluch).
        DCD     &ED820200 :OR: (fp_reg0:SHR:2)
        DCD     &ED824200 :OR: (fp_reg4:SHR:2)
       ]
      |
        STFE    F0,[R2,#fp_reg0]
        STFE    F1,[R2,#fp_reg1]
        STFE    F2,[R2,#fp_reg2]
        STFE    F3,[R2,#fp_reg3]
        STFE    F4,[R2,#fp_reg4]
        STFE    F5,[R2,#fp_reg5]
        STFE    F6,[R2,#fp_reg6]
        STFE    F7,[R2,#fp_reg7]
      ]
;
        EXITS                                   ; preserve flags

;.............................................................................

; In    handle = task handle of current task (must be alive)
;       R12 -> module workspace
;       [sp..] = stacked R1..
; Out   exits to Wimp with or without R2 set up (as appropriate)

putsender_ExitWimp
        SavePSR R3                      ; save flags
        LDR     R4,[wsptr,handle]
        BL      getsender_R2            ; GE => R2 = task handle of sender
        STRGE   R2,[sp,#4]              ; R2 = second word on stack
        RestPSR R3,,f                   ; restore error state
        B       ExitWimp

;.............................................................................

; In    R4 -> task block for task about to receive an event
;       R12 -> module workspace
; Out   GE => R2 = task handle of task that sent it (0 => Wimp)

getsender_R2
        LDR     R2,[R4,#task_wimpver]   ; latest known Wimp version number
        Debug   ms,"getsender_R2: handle, wimpver, sender =",#taskhandle,R4,R2,#sender
        CMP     R2,#253
        LDRGE   R2,sender               ; GE => R2 = sender's task handle
        CMPGE   R2,#0                   ; -1/-2 => this is a Wimp_StartTask
        MOV     PC,LR


;;----------------------------------------------------------------------------
;; Error reporting SWI
;;----------------------------------------------------------------------------
;
; Entry:  R1 --> icon definition
;         R2 = coords to centre on (horizontally)
; Exit:   x0,x1 = left,right of icon
;         icon definition updated
;

setbuttonx
        LDR     x0,[R1,#i_bbx0]
        LDR     x1,[R1,#i_bbx1]
        SUB     x1,x1,x0
        SUB     x0,R2,x1,ASR #1
        ADD     x1,x0,x1
        STR     x0,[R1,#i_bbx0]
        STR     x1,[R1,#i_bbx1]
        MOV     PC,LR                   ; must preserve flags

;
; Entry:  R0 --> error block
;         R1 = flags
;              bit 0 ==> OK box displayed
;              bit 1 ==> Cancel box displayed
;              bit 2 ==> highlight Cancel box (else highlight OK box)
;              bit 3 ==> dont wait for confirmation (if text-based)
;              bit 4 ==> omit 'Error from ' in title bar
;              bit 5 ==> 'poll' error window (ie. leave open & exit)
;              bit 6 ==> finish polling error window, select [r1] and close it
;              bit 7 ==> don't beep (even if WimpFlags bit 4 clear)
;              bit 8 ==> new type error report
;              bits 9-11 ==> error type
;
;         R2 --> application name (<=0 ==> Wimp has detected the error)
;         R3 --> sprite name (for new type error report)
;         R4 --> sprite area, or 1 for Wimp area (for new type error report)
;         R5 --> comma separated additional button list, or 0 for none (for new type error report)
;
; Exit:   R1 = 1 ==> Continue (OK) box was selected
;         R1 = 2 ==> Cancel box was selected
;         R1 = 3,4... ==> additional button pressed
;

;Rough outline (not gospel!) JRC 24 Jul 1997
;	Make service call ErrorStarting
;	IF	in command mode
;	THEN	report error in text
;		poll for a key press
;		return key pressed (Return/Escape)
;	ELSE	IF	closing an open error box
;		THEN	return button-click specified
;		ELSE	Create a window structure
;			Make service call WimpReportError 1
;			Switch output to screen
;			Disable file redirection
;			Enable VDU, disable Spool, printer & serial
;			Beep
;			Add the icon definitions to the window structure
;			int_open_window
;			int_redraw_window
;			int_get_rectangle
;			Smash hourglass
;			Bound pointer to window
;			Flush keyboard and mouse
;			Start IconHigh
;			DO	Read key with no time limit
;				Check mousebuttons
;			WHILE	nothing happens
;			Unbound pointer
;			int_close_window
;			Stop IconHigh
;			Make service call ErrorButtonPressed
;			Make service call ErrorEnding
;			Restore file redirection
;			Restore output to previous state
;			Make service call WimpReportError
;		FI
;	FI

errorprefix     DCB     "NoError",0
errorprefix1    DCB     "Error",0
errorprefix2    DCB     "ErrorF",0

execcom DCB     "Exec",0
        ALIGN

; tempworkspace layout
                        ^       0
errtws_spritearea       #       4  ;   +0  as passed in R4 / set by service call claimant(s)
errtws_buttonlist       #       4  ;   +4  pointer to comma-separated list of buttons
errtws_iconend          #       4  ;   +8  icon handle of (rightmost == first-in-string == highest-icon-handle) extra button, + 1
errtws_describebuttons  #       4  ;  +12  comma-separated list of buttons to use when program error is Described
errtws_icondata         #       4  ;  +16  if a "may have gone wrong" window, -> start of icon data for error window, else 0
errtws_cancelstr        #       4  ;  +20  -> "Cancel"
errtws_flags            #       4  ;  +24
errtws_mustntuse        #       4  ;  +28  corrupted by text plotting code

SWIWimp_ReportError
        MyEntry "ReportError"
;
        [ ErrorServiceCall
        Push    "R0-R5"
        Pull    "R2-R7"
        LDR     R1,=Service_ErrorStarting
        SWI     XOS_ServiceCall
        Push    "R2-R7"
        Pull    "R0-R5"
        MOV     userblk,R1
        ]

        Push    "R0-R3"
;
        [ NewErrorSystem
        STR     R4,tempworkspace+errtws_spritearea  ; R4 gets horribly corrupted
                                                    ; but is required for 3.21
        STR     R5,tempworkspace+errtws_buttonlist  ; ditto!
        ]

        LDR     R4,commandflag
        ORR     R14,R4,#cf_suspended
        STR     R14,commandflag         ; suspend this whatever
        TEQ     R14,#cf_active:OR:cf_suspended
        BNE     useerrorwindow

noerrorwindow                           ; come back here if error window dead
        TST     R1,#erf_dontwait
        ADREQ   R0,execcom              ; cancel exec file (if any)
        SWIEQ   XOS_CLI
;
        Pull    "R0-R3"
;
; report error as a line of text
;
        TST     R1,#erf_pollexit        ; finish - cancel suspended state
        ANDNE   R1,R1,#erf_okbox:OR:erf_cancelbox
        BNE     ExitError
;
        TST     R4,#cf_suspended        ; if suspended and poll bit set,
        TSTNE   R1,#erf_poll
        BNE     %FT11                   ; don't re-print the error message
;
        SWI     XOS_WriteI+4            ; just in case
        SWI     XOS_NewLine             ; textual form of error report
        ADD     R0,R0,#4
        SWI     XOS_Write0
        SWI     XOS_NewLine
;
        TST     R1,#erf_dontwait        ; R1 preserved if bit 3 was set
        BNE     ExitError
;
        TST     R1,#erf_poll            ; unless polling,
        BNE     %FT51

        Push    "R2,R3"
;
        ADRL    R0,pressspace
        ADRL    R2,errorbuffer
        MOV     R3,#?errorbuffer
        BL      LookupToken1            ; resolve the press-space to continue token
;
        ADRL    R0,errorbuffer
        SWI     XOS_Write0              ; display it
        SWI     XOS_NewLine             ; followed by a new line
;
        Pull    "R2,R3"
51
        BL      flushkbdmouse           ; only done the first time
11
        BL      powersave_tick
        BL      pollforkey
        BNE     %FT12

        LDR     R1,[sp,#0*4]
        TST     R1,#erf_poll            ; if no result, loop unless erf_poll
        BEQ     %BT11
;
        MOV     R1,#0                   ; leave command window suspended
        B       ExitError2              ; return 'no result'

12      TEQ     R1,#&1B                 ; escape key ==> non-default

        Debug   err,"ReportError: key=",R1

        MOVNE   R1,#erf_okbox
        MOVEQ   R1,#erf_cancelbox
        LDR     R14,[sp,#0*4]
        TST     R14,#erf_htcancel
        EORNE   R1,R1,#erf_okbox:EOR:erf_cancelbox
        ANDS    R14,R14,#erf_okbox:OR:erf_cancelbox
        MOVEQS  R14,#erf_okbox          ; if flags =0 it has an OK box
        ANDS    R1,R1,R14               ; can't select button that wasn't there
        TSTEQ   R14,#erf_poll
        BEQ     %BT11                   ; try again if 0 not allowed!

        Debug   err,"ReportError: return",R1

ExitError
        LDR     R14,commandflag
        BIC     R14,R14,#cf_suspended
        STR     R14,commandflag

ExitError2
        STR     R1,[sp,#0*4]
        B       ExitWimp

;
; report error in a window
;

useerrorwindow
        LDR     R8,errorhandle          ; R8 = relative error window handle
        CMP     R8,#nullptr
        BEQ     noerrorwindow           ; oops!
;
        ADRL    R0,execcom              ; always cancel exec file (if any)
        SWI     XOS_CLI
;
        Abs     handle,R8               ; handle --> window definition
;
        TST     R1,#erf_pollexit
        BEQ     %FT01

        ADD     sp,sp,#4*4              ; skip junk on stack

        TST     R4,#cf_suspended        ; is error window open?
        BEQ     ExitError               ; forget it if not (unsuspend window)

        MOV     R4,#1                   ; highlight either icon 1 or 4
        TST     R1,#erf_okbox           ; ('OK' preferably)
        MOVEQ   R4,#4
        B       finisherror             ; make selection and close error window
01
        TST     R4,#cf_suspended        ; if suspended and poll bit set,
        TSTNE   R1,#erf_poll
        Pull    "R4-R7"                 ; R4-R7 = original R0-R3
        BLEQ    starterrorbox

        MOV     R0, #229                ; Read current escape condition enable state so we can restore it later
        MOV     R1, #0
        MOV     R2, #255
        SWI     XOS_Byte
        STRB    r1, old_escape

        MOV     R0, #229                ; Disable escape conditions (Wimp hasn't actually checked for them for a long time)
        MOV     R1, #1
        MOV     R2, #0
        SWI     XOS_Byte
;
; bodge polling loop - look for mouse click in OK / Cancel boxes
;                    - also <escape> (27, or escape condition)
;

pollit
        BL      powersave_tick
        MOV     R0,#&81                 ; read key with 0 time limit
        MOV     R1,#0
        MOV     R2,#0
        SWI     XOS_Byte                ; CS => escape, else R1 = &FF => no char
        TEQ     R2,#&FF
        BEQ     %FT02                   ; no key pressed
;
        Debug   err,"ReportError: pollit key=",R1

        TEQ     R1,#&0D
        TEQNE   R1,#&1B                 ; old allow <CR> and <Esc>
        BNE     %FT02
;
        LDR     R14, tempworkspace+errtws_flags  ; to work out which button the key corresponds to, we need the current flags
                                                 ; note 1: these flags will be correct for "may have gone wrong" boxes
        Debug   err,"Error flags=",R14           ; note 2: these flags have not been checked to ensure there is at least an OK button

        MOV     R4, #-1                 ; Return button not yet determined
        MOV     R5, #-1                 ; Escape button not yet determined
        MVN     R14, R14                ; makes life easier when doing comparisons

        TST     R14, #erf_okbox
;        CMPEQ   R4, #-1                 ; have we found both buttons yet?
;        MOVEQ   R4, R5                  ; Return -> previous Escape button
        MOVEQ   R5, #1                  ; Escape -> OK button

        TST     R14, #erf_cancelbox
;        CMPEQ   R4, #-1                 ; have we found both buttons yet?
        MOVEQ   R4, R5                  ; Return -> previous Escape button
        MOVEQ   R5, #4                  ; Escape -> Cancel button

; note, the Describe button is never selected by a keypress
        TST     R14, #erf_newtype
        BNE     %FT06
        LDR     R2, tempworkspace+errtws_buttonlist
        AcceptLoosePointer_NegOrZero R2,0
        CMP     R2,R2,ASR #31
        BEQ     %FT06 ; if no extra buttons, skip next section

        LDR     R2, tempworkspace+errtws_iconend

        CMP     R2, #8                  ; are there at least 1 extra buttons?
        CMPHS   R4, #-1                 ; have we found both buttons yet?
        MOVEQ   R4, R5                  ; Return -> previous Escape button
        SUBEQ   R5, R2, #1              ; Escape -> highest-numbered (rightmost) extra button

        CMP     R2, #9                  ; are there at least 2 extra buttons?
        CMPHS   R4, #-1                 ; have we found both buttons yet?
        MOVEQ   R4, R5                  ; Return -> previous Escape button
        SUBEQ   R5, R2, #2              ; Escape -> second highest-numbered (second rightmost) extra button
06
        TST     R14, #erf_okbox :OR: erf_cancelbox :OR: erf_htcancel
        EOREQ   R4, R4, R5              ; if all three flags were set, the meanings of Return and Escape are reversed
        EOREQ   R5, R4, R5
        EOREQ   R4, R4, R5

        CMP     R5, #-1                 ; if no Escape button has been found, an OK/Continue button will have been added
        MOVEQ   R5, #1
        CMP     R4, #-1                 ; if no Return button has been found, there is only one button, so act as for Escape
        TEQNE   R1, #&1B                ; was Escape pressed?
        MOVEQ   R4, R5                  ; R4 now holds selected icon number
        Debug   err,"Icon=",R4
;
        B       finisherror
02
        LDR     R5,mousebuttons
        BL      getmouseposn            ; R0,R1 = mouse coords, R2 = buttons
        Push    "R5"
        MOV     R5,#0                   ; don't match shaded icons (not that there are any)
        BL      int_get_pointer_info    ; R3,R4 = window/icon handle
        Pull    "R5"
	;Debug	upcall, "int_get_pointer_info: w, i, oldbuttons, newbuttons:", R3, R4, R5, R2
        LDR     R14,errorhandle
        TEQ     R3,R14                  ; must be error window!
        BNE     notover
        [ NewErrorSystem
        SUB     R14, R4, #6             ; Describe button is handle 6, additional buttons are 7 to 6+maxno_error_buttons
        CMP     R14, #maxno_error_buttons
        CMPLS   R14, R14                ; set Z if in range
        ]
        TEQNE   R4,#1                   ; icon 1 = 'OK' box
        TEQNE   R4,#4                   ; icon 4 = 'Cancel' box
        BNE     notover
        [ false
        EOR	R14,R2,R5		; AR 13/8/97 look at both transitions, fixed a problem of double clicks
 	|
        BIC     R14,R2,R5               ; look for +ve edge SELECT/ADJUST
	]
        BICS    R14,R14,#button_middle  ; (ignore menu button)
        BNE     finisherror

notover
        LDR     R14,[sp,#0*4]           ; should we retry?
        TST     R14,#erf_poll
        BEQ     pollit
        MOV     R1,#0                   ; return 0 and go back to poller
        B       ExitError2              ; stores R1 in top stack entry

finisherror
        Push    "R4"                    ; R4 = 1 or 4 (icon to select)
;
	Debug	upcall, "finishing error ", r4
        MOV     R0,R4                   ; R0 = icon handle
        MOV     R1,#is_inverted         ; R1 = EOR word
        MOV     R2,#is_inverted         ; R2 = BIC word
        BL      int_set_icon_state      ; handle --> window definition
        BL      clearpointerwindow

      [ NCErrorBox
        Push    "r0-r2"
        MOV     R0, #0                  ; Unconditionally turn off IconHigh
        SWI XIconHigh_Stop
	; SJM 25Mar99 Do not restore the pointer shape here
	; anymore now that we have Wimp_Extend support
        Pull    "r0-r2"
      ]
;
        ADR     userblk,errorhandle     ; userblk --> window handle
        BL      int_close_window
        [ ChildWindows
        BL      int_flush_opens         ; this is necessary to avoid block-copying if the error box
        ]                               ; is subsequently displayed at a different size
;
        Pull    "R1"
        TEQ     R1,#4                   ; 1 ==> OK box selected
        MOVEQ   R1,#2                   ; 2 ==> Cancel box selected

        [ NewErrorSystem
        CMP     R1,#6
        BEQ     notoveryet
        SUBHI   R1,R1,#2
        LDRHI   R2,tempworkspace+errtws_iconend
        SUBHI   R1,R2,R1                ; extra icons 7-10 return 6-3
        ]

        [ ErrorServiceCall
        BL      InstallErrorButtonPressedHandlers
        MOV     R2,R1
        MOV     R0,#0
        LDR     R1,=Service_ErrorButtonPressed
        LDR     R3,tempworkspace+errtws_buttonlist
        SWI     XOS_ServiceCall
        BL      RemoveErrorButtonPressedHandlers
        CMP     R0,#0
        BEQ     servicecallend
; module wants error dialog redisplayed
redisplayerrorbox
        LDMIA   R2!,{R4-R7}
        LDMIA   R2,{R1-R2}
        ADR     R3,tempworkspace+errtws_spritearea ; also updates errtws_buttonlist
        STMIA   R3,{R1-R2}
        MOV     userblk,R5
        Push    "PC"                    ; routine returns with Pull "PC"
        B       starterrorbox_draw      ; This actually Pushes PC+12 on the stack
        NOP
        B       pollit
servicecallend
        LDR     R1,=Service_ErrorEnding
        SWI     XOS_ServiceCall
        MOV     R1,R2
        ]

        Debug   upcall,"ReportError returns R1",R1
        STR     R1,[sp,#0*4]

        [ NewErrorSystem
; now replace Quit with Cancel if necessary

        LDR     R1,tempworkspace+errtws_icondata
        TEQ     R1,#0
        BEQ     %FT05
        LDR     R6,tempworkspace+errtws_cancelstr
        STR     R6,[R1,#i_data+i_size*4]
        MOV     R1,#0
        STR     R1,tempworkspace+errtws_icondata
      [ true
        LDR     R0, progerrsaveblk + 4*1 ; retrieve flags
        TEQ     R2, #2                  ; was quit pressed, as opposed to continue?
        ANDNE   R1, R0, #erf_ocontcode
        MOVNE   R1, R1, LSR #erf_ocontcode_shift
        ANDEQ   R1, R0, #erf_ocancelcode
        MOVEQ   R1, R1, LSR #erf_ocancelcode_shift
        TSTEQ   R0, #erf_cancelbox      ; If quit clicked, but underlying window had no cancel
        TEQEQ   R1, #0                  ; and no return code has been specified either,
        MOVEQ   R1, #99                 ; flag that we'll have to call the exit handler.
        TEQ     R1, #0                  ; Otherwise, no return code means we have to pass 1 or 2 as appropriate
        MOVEQ   R1, R2                  ; for compatibility reasons.
        STR     R1, [sp]
      |
        TEQ     R2,#2                   ; was quit pressed ?
        BNE     %FT05
        LDR     R1,progerrsaveblk + 4*1
        TST     R1,#erf_cancelbox
        BNE     %FT05                   ; it asked for a cancel button, assume it will quit anyway
        MOV     R1,#99                  ; flag that control should be passed to exit handler instead
        STR     R1,[SP]
      ]
05
        ]

;
; tidy up afterwards
;
tidyupaftererror
        BL      losewindowrects         ; just in case - don't lose memory!

        ADR     R6,errorstack-14*4      ; this is where we put it previously
        LDMIA   R6!,{R1}                ; Get old VDU status

        Debug   err,"VDU status restored",R1

        TST     R1, #&80                ; Was screen disabled by VDU 21?
        SWINE   XOS_WriteI+21           ; Yes then disable it

        LDMIA   R6!,{R1}                ; Get FX3 state

        Debug   err,"FX3 status restored",R1

        MOV     R0,#3
        SWI     XOS_Byte                ; Restore it

        LDMIA   R6!,{R0,R1}             ; Get redirection handles

        Debug   err,"Redirection handles restored",R0,R1

        SWI     XOS_ChangeRedirection   ; Restore redirection

        LDMIA   R6!,{R0-R1,R2-R5}
        STR     R0,redrawhandle
        STR     R1,rlinks+windowrects
        ADR     R14,clipx0              ; restore clip window too!
        STMIA   R14,{R2-R5}

        LDMIA   r6,{R0-R3}
        SWI     XOS_SpriteOp            ; send output back to original
;
        MOV     R0,#124                 ; acknowledge escape (just in case)
        SWI     XOS_Byte
;
        LDR     R14,commandflag         ; finally un-suspend the window
        BIC     R14,R14,#cf_suspended
        STR     R14,commandflag

        [       outlinefont
        ;Restore the current font and font colours that were in force on
        ;       entry, if they've been changed. This must be done *before*
        ;        making the service call, so the code in ExitWimp is too late.
        Push    "r0-r3"
        LDR     R0, currentfont
        TEQ     R0, #0
        BEQ     ReportError_restored_font_colours
        LDR     R1, systemfont
        TEQ     R1, R0
        LDRNE   R1, currentbg
        LDRNE   R2, currentfg
        LDRNE   R3, currentoffset
        SWINE   XFont_SetFontColours
        MOV     R0, #0
        STR     R0, currentfont
ReportError_restored_font_colours
        Pull    "r0-r3"
        ]

      [ NCErrorBox
        ADRL    R14, ptrpreserveflag
        MOV     R0, #0
        STR     R0, [R14]               ; move the pointer the next time the error box is opened
      ]

        MOV     R0, #229                ; restore the old escape condition disable state
        LDRB    R1, old_escape
        MOV     R2, #0
        SWI     XOS_Byte

        MOV     R1,#Service_WimpReportError
        MOV     R0,#0                   ; closing down
        STRB    R0,errorbox_open
        SWI     XOS_ServiceCall
;
        LDR     R1,[sp]
        TEQ     R1,#99                  ; QUIT, rather than escape was pressed
        SWIEQ   XOS_Exit

        B       ExitWimp

        [ NewErrorSystem
notoveryet
        LDR     R1,tempworkspace+errtws_icondata
        LDR     R4,tempworkspace+errtws_cancelstr
        STR     R4,[R1,#i_data+i_size*4]
        MOV     R1,#0
        STR     R1,tempworkspace+errtws_icondata
        LDR     R1,tempworkspace+errtws_describebuttons  ; Get back buttons
        STR     R1,tempworkspace+errtws_buttonlist
      [ false
        ADRL    R5, ptrpreserveflag
        MOV     R4, #1
        STR     R4, [R5]                ; note not to move the pointer
      ]
        ADRL    R1,progerrsaveblk
        LDMIA   R1,{R4-R7}
        MOV     userblk,R5
        Push    "PC"                    ; routine returns with Pull "PC"
        B       starterrorbox_draw      ; This actually Pushes PC+12 on the stack
        NOP
        B       pollit

      [ ErrorServiceCall
InstallErrorButtonPressedHandlers
; Install Exit, Error and UpCall_NewApplication handlers for Service_ErrorButtonPressed client
        Entry   "R0-R4"
        ADRL    R4, errorbuttonoldhandlers
        MOV     R0, #ExitHandler
        ADR     R1, ErrorButtonExitHandler
        MOV     R2, R12
        SWI     XOS_ChangeEnvironment
        STMIA   R4!, {R1-R3}
        MOV     R0, #ErrorHandler
        ADR     R1, ErrorButtonErrorHandler
        MOV     R2, R12
        ADRL    R3, watchdogerror ; since errorbox_open is set, this won't be used by "App may have gone wrong"
        SWI     XOS_ChangeEnvironment
        STMIA   R4!, {R1-R3}
        MOV     R0, #UpCallHandler
        ADR     R1, ErrorButtonUpCallHandler
        MOV     R2, R12
        SWI     XOS_ChangeEnvironment
        STMIA   R4!, {R1-R3}
        EXIT

RemoveErrorButtonPressedHandlers
; Remove handlers installed in InstallErrorButtonPressedHandlers
        Entry   "R0-R4"
        ADRL    R4, errorbuttonoldhandlers
        MOV     R0, #ExitHandler
        LDMIA   R4!, {R1-R3}
        SWI     XOS_ChangeEnvironment
        MOV     R0, #ErrorHandler
        LDMIA   R4!, {R1-R3}
        SWI     XOS_ChangeEnvironment
        MOV     R0, #UpCallHandler
        LDMIA   R4!, {R1-R3}
        SWI     XOS_ChangeEnvironment
        EXIT

ErrorButtonErrorHandler
        ; This shouldn't ever be called, but if it is, then the SVC stack has been flattened,
        ; so we can't realistically continue execution afterwards; we also can't use an error
        ; box to display the message, since one is already open. So just print the message,
        ; then drop through the exit handler to tidy up the old error box.
        MOV     R12, R0
        ADRL    R0, watchdogerror + 8 ; skip the PC word and error number
        SWI     XOS_Write0
        SWI     XOS_NewLine
        ; drop through...
ErrorButtonExitHandler
        SWI     XOS_EnterOS     ; we need a stack
        BL      RemoveErrorButtonPressedHandlers
        LDR     R1, =Service_ErrorEnding
        MOV     R2, #2          ; fake a "Cancel" button for the purposes of this service call
        SWI     XOS_ServiceCall
        ; SVC stack has been flattened by OS_Exit, but the rest of the error box code
        ; assumes it can use the word at sp_svc to hold the R1 value to pass back from
        ; Wimp_ReportError. Use the top word of the SVC stack for this purpose instead -
        ; it'll be flattened again when *we* call OS_Exit.
        MOV     R1, #99         ; re-use magic value that causes OS_Exit to be called
        Push    "R1"
        B       tidyupaftererror

ErrorButtonUpCallHandler
        TEQ     R0, #UpCall_NewApplication
        MOVEQ   R0, #0          ; deny new application
        MOV     PC, R14
      ]

	LTORG

        MACRO
$lab    MakeInvisible   $num

        LDR     R14,[handle,#w_icons]
        LDR     R14,[R14,#i_flags+i_size*$num]
        ORR     R14,R14,#is_deleted
        LDR     R0,[handle,#w_icons]
        STR     R14,[R0,#i_flags+i_size*$num]
        MEND

        MACRO
$lab    MakeInvisibleReg   $reg

        Push    "R0,$reg"
        MOV     $reg,$reg , LSL #i_shift
        LDR     R0,[handle,#w_icons]
        ADD     R0,R0,$reg
        LDR     R14,[R0,#i_flags]
        ORR     R14,R14,#is_deleted
        STR     R14,[R0,#i_flags]
        Pull    "R0,$reg"

        MEND

; 16 byte boundaries of sprites to use

errspritetable
                DCB     "error",0,0,0
                DCD     0,0
                DCB     "information",0
                DCD     0
                DCB     "warning",0
                DCD     0,0
                DCB     "program",0
                DCD     0,0
                DCB     "question"
                DCD     0,0
                DCB     "user1",0,0,0
                DCD     0,0
                DCB     "user2",0,0,0
                DCD     0,0
                DCB     "program",0
                DCD     0,0


noprogapp       DCB     "Application",0
errorptoken     DCB     "ErrorP",0
quitlabel       DCB     "Quit",0

        ]

; In    R4-R7 = normal R0-R3 for Wimp_ReportError
;       R8 = relative handle of error window
; Out   [..errorstack] = (10 words) = stashed data
;                        original SwitchOutputToSprite values, clip window etc.

starterrorbox
        Push    "LR"

; copy error message (because messagetrans is unhelpful)
        ADRL    R0,watchdogerror
        TEQ     R0,R4                       ; is this coming from us?
        BEQ     %FT05

        ADD     R0,R4,#4
        BL      count0
        CMP     R1,#237
        BCS     %FT05
        MOV     R0,R4
        ADRL    R4,copyerror
        MOV     R1,R4
        LDR     LR,[R0],#4
        STR     LR,[R1],#4
        BL      copy0
05
        [ NewErrorSystem

; bit 31 is reserved, used internally

        BIC     R5,R5,#erf_describe
        BIC     userblk,userblk,#erf_describe

        MOV     R1,#0
        STR     R1,tempworkspace+errtws_icondata  ; make sure no label swapping

; is the error box already up? Don't need to save VDU info.

        LDRB    R1,errorbox_open
        CMP     R1,#1
        BEQ     starterrorbox_reenter

; check to see if this is a program error, if so use the watchdog area
; to create a temporary error block. and try not to use the stack!!!

        [ Bits30and23
        LDR     R0,=&C0800000                 ; bit 31 + bit 30 + bit 23
        LDR     R1,[R4]
        AND     R1,R1,R0
        TEQ     R1,#&80000000                   ; DA, AE etc.
        EOR     R0,R0,#&80000000
        TEQNE   R1,R0                           ; pgm error  (new)
        |
        LDR     R1,[R4]

        AND     R1,R1,#&80000000
        TEQ     R1,#&80000000
        BLNE    IsThisProgErr
        ]

        BNE     starterror_next
        ADRL    R1,progerrsaveblk
        STMIA   R1,{R4-R7}
        MOV     R1,#&07000000
        STR     R1,watchdogerror
        LDR     R1,errorhandle
        Abs     R1,R1                   ; real windows are Rel-ative
        LDR     R1,[R1,#w_icons]
        LDR     R2,[R1,#i_data+i_size*4]        ; cancel button
        STR     R2,tempworkspace+errtws_cancelstr
        STR     R1,tempworkspace+errtws_icondata  ; make life easier later
        ADR     R0,quitlabel            ; SMC: now lookup text for button
        ADRL    R2,quittext
        MOV     R3,#buttontextsize
        BL      LookupToken
        STR     R2,[R1,#i_data+i_size*4]
        MOVS    R4,R6
        CMPNE   R4,#nullptr
        ADREQ   R4,noprogapp
        LDRB    R14,[R4]
        TEQ     R14,#"\\"
        ADDEQ   R4,R4,#1
        ADRL    R2,watchdogerrtxt
        MOV     R3,#?watchdogerrtxt
        ADR     R0,errorptoken
        BL      LookupToken
        ADRL    R4,watchdogerror
        LDR     R1,tempworkspace+errtws_buttonlist        ; store buttons away
        STR     R1,tempworkspace+errtws_describebuttons   ; in case we need them again
                                                          ; when user hits describe
        TST     R5,#erf_newtype
      [ true
        LDR     R5,=erf_describe:OR:erf_cancelbox:OR:erf_okbox
      |
        MOV     R5,#erf_describe:OR:erf_cancelbox:OR:erf_okbox
      ]
        ORR     R5,R5,#erf_newtype                        ; continue rather than ok
        MOV     userblk,R5
        MOV     R6,#0
        MOVEQ   R7,#0                                     ; make sure no sprite if original error wasn't new type
        STREQ   R6,tempworkspace+errtws_spritearea
        STR     R6,tempworkspace+errtws_buttonlist        ; no custom buttons
        LDR     R6,progerrsaveblk + 4*2                   ; app name

starterror_next
        ]

        MOV     R1,#Service_WimpReportError
        MOV     R0,#1                   ; starting up
        STRB    R0,errorbox_open
        SWI     XOS_ServiceCall

        CLRV                                    ; just in case
        MOV     R0,#SpriteReason_SwitchOutputToSprite
        MOV     R1,#0
        MOV     R2,#0                   ; Switch to screen
        ADRL    R14,save_context
        LDR     R3,[R14]
        SWI     XOS_SpriteOp
        BVC     %FT05
;        B       %FT05

        ; if we get an error here, then its potentially quite serious...
        CLRV                            ; chances are it will happen again
        ADD     SP,SP,#4
        MOV     R1,#2
        STR     R1,[sp]                 ; cancel

        [       outlinefont
        ;Restore the current font and font colours that were in force on
        ;       entry, if they've been changed. This must be done *before*
        ;       making the service call, so the code in ExitWimp is too late.
        Push    "r0-r3"
        LDR     R0, currentfont
        TEQ     R0, #0
        BEQ     ReportError_restored_font_colours2
        LDR     R1, systemfont
        TEQ     R1, R0
        LDRNE   R1, currentbg
        LDRNE   R2, currentfg
        LDRNE   R3, currentoffset
        SWINE   XFont_SetFontColours
        MOV     R0, #0
        STR     R0, currentfont
ReportError_restored_font_colours2
        Pull    "r0-r3"
        ]

        MOV     R1,#Service_WimpReportError
        MOV     R0,#0                   ; closing down
        STRB    R0,errorbox_open
        SWI     XOS_ServiceCall

        B       ExitWimp

05

        ADR     R14,errorstack          ; FD stack
        STMDB   R14!,{R0-R3}            ; remember for later

        ADR     R0,clipx0               ; remember current clip rectangle
        LDMIA   R0,{R0-R3}
        STMDB   R14!,{R0-R3}

        LDR     R0,redrawhandle
        LDR     R1,rlinks+windowrects   ; NB requires YUK=false to work
        STMDB   R14!,{R0,R1}

; Restore normal VDU output

        MOV     R3, R14                 ; R3 = error stack

        MOV     R0,#0
        MOV     R1,#0
        SWI     XOS_ChangeRedirection   ; Disable all redirection
        STMDB   R3!,{R0,R1}             ; Save old handles

        Debug   err,"Redirected i/p, o/p handles",R0,R1

        MOV     R0,#3
        MOV     R1,#&14                 ; Enable VDU, disable Spool, printer & serial
        SWI     XOS_Byte
        STMDB   R3!,{R1}                ; Save for later

        Debug   err,"OS_Byte 3 status was",R1

        MOV     R2, #0
        MOV     R1, #0
        MOV     R0, #218
        SWI     XOS_Byte                ; Flush VDU queue

        MOV     R0,#117
        SWI     XOS_Byte                ; Read VDU status
        STMDB   R3!,{R1}                ; Save for later

        Debug   err,"VDU status is",R1

        TST     R1, #&80                ; Screen disabled by VDU 21?
        SWINE   XOS_WriteI+6            ; Yes then re-enable it with VDU 6

        LDRB    R14,sysflags            ; beep unless suppressed by user
        TST     R14,#sysflags_nobeep
        TSTEQ   R5,#erf_nobeep          ; can be suppressed in the call
        SWIEQ   XOS_WriteI+7
;
; now set up temporary state for drawing the error box
;

        STR     R8,redrawhandle
starterrorbox_reenter
        MOV     R14,#nullptr
        STR     R14,rlinks+windowrects  ; pretend there aren't any!
;

starterrorbox_draw

	Debug	err,"starterrorbox_draw"

        STR     R5, tempworkspace+errtws_flags ; for later use by pollit
        Push    "R4-R7"
      [ NewErrorSystem
; make sure we have default pointer
        MOV     R0,#SpriteReason_SetPointerShape
        ADRL    R2,ptr_default2
      [ NCErrorBox
        MOV     R3,#&41                 ; reprogram shape data, but don't switch to shape 1 yet
      |
        MOV     R3,#1
      ]
        MOV     R4,#0
        MOV     R5,#0
        MOV     R6,#0
        MOV     R7,#0
        SWI     XWimp_SpriteOp          ; take from Wimp's sprite area(s)
      ]

        BL      set16x32chars
        Pull    "R0-R3"                 ; R0-R3 = original registers
;
        Push    "R0"                    ; R0 --> error block
;
; construct title string (depends on R1 bit 4 and R2)
;
        Push    "R2-R5"
;
        AcceptLoosePointer_NegOrZero R2,0
        CMP     R2,R2,ASR #31           ; do they want an application name?
        ADREQL  R0,errorprefix1
        BICEQ   R1,R1,#erf_omiterror
        ADRNEL  R0,errorprefix2         ; -> suitable token

        TST     R1,#erf_omiterror
        ADRNEL  R0,errorprefix          ; include prefixing message?

        MOV     R5,#0
        MOVS    R4,R2                   ; parameter for the title string
        CMPNE   R4,#nullptr
        BEQ     %FT01
        LDRB    R14,[R4]
        TEQ     R14,#"\\"
        ADDEQ   R4,R4,#1
01
;
        MOV     R3,#?errortitle
        ADRL    R2,errortitle           ; -> title string for dialogue box
        BL      LookupToken
;
        ADRL    R2,errortitle
;
	DebugS	err,"errortitle=",R2

        Pull    "R2-R5"

        [ NewErrorSystem

; set up sprites in dialogue box

        MOV     R0,userblk
        AND     R0,R0,#erf_errortype
        addr    R14,errspritetable
        TST     userblk,#erf_newtype
        ADDNE   R0,R14,R0 , LSR #erb_errortype-4
        MOVEQ   R0,R14
        TST     userblk,#erf_describe
        ADDNE   R0,R0,#48               ; program symbol

; R14 now points to error type sprite name <= 12 chars
        LDR     R14,[handle,#w_icons]
        ADD     R14,R14,#i_data+i_size*3
        Push    "R1,R2"
        LDMIA   R0,{R0-R2}
        STMIA   R14,{R0-R2}                     ; copy name
        Pull    "R1,R2"

        ; set up app sprite
        MOV     R0,#1
        STR     R0,[handle,#w_areaCBptr]
        TST     userblk,#erf_newtype
        BEQ     oldappsprite
        AcceptLoosePointer_NegOrZero R3,0
        CMP     R3,R3,ASR #31

        LDREQ   R14,[handle,#w_icons]
        ADDEQ   R14,R14,#i_size
; make sure default says 'OK'
        ADREQ   R0,contlabel
        Push    "R2",EQ                         ; SMC: now lookup text for button but leave it to oldappsprite2 (must preserve R2)
        ADREQL  R2,conttext
        BEQ     oldappsprite2

        LDR     R2,tempworkspace+errtws_spritearea
        CMP     R2,#1
        STRHI   R2,[handle,#w_areaCBptr]
        MOV     R2,R3                           ; sprite given so use it
        LDR     R14,[handle,#w_icons]
        ADD     R14,R14,#i_size
; make sure default says 'Continue'
        ADR     R0,contlabel

        Push    "R2,R3,R14"                     ; SMC: now lookup text for button (made complicated by preserving regs)
        ADRL    R2,conttext
        MOV     R3,#buttontextsize
        BL      LookupToken
        LDR     R14,[SP,#8]
        STR     R2,[R14,#i_data]
        Pull    "R2,R3,R14"
;
        ADD     R14,R14,#i_data+i_size
        Push    "R1,R2"
        MOV     R1,#11
        B       oldapploop

oklabel
 [ :LNOT: STB
                DCB     "OK",0,0
 ]
contlabel       DCB     "Continue",0
noappname       DCB     "switcher",0
              [ true
ptr_default2    DCB     "ptr_default",0
              ]
                ALIGN

oldappsprite
        LDR     R14,[handle,#w_icons]
        ADD     R14,R14,#i_size
; make sure default says 'OK'
        ADR     R0,oklabel
        Push    "R2"                            ; SMC: now lookup text for button
        ADRL    R2,oktext
oldappsprite2
        Push    "R3,R14"                        ; SMC: must preserve registers over sub-routine call
        MOV     R3,#buttontextsize
        BL      LookupToken
        Pull    "R3,R14"
        STR     R2,[R14,#i_data]
        Pull    "R2"

        ADD     R14,R14,#i_data+i_size
        Push    "R1,R2"
        CMP     R2,R2,ASR #31
        ADREQ   R2,noappname
        MOVEQ   R1,#11
        BEQ     oldapploop
; is [R2] <= a space ?

        LDRB    R0,[R2]
        CMP     R0,#" "
        ADRLS   R2,noappname
        MOVLS   R1,#11
        BLS     oldapploop

; copy !<R2> to sprite name
        MOV     R0,#"!"
        STRB    R0,[R14],#1
        MOV     R1,#10
oldapploop
        LDRB    R0,[R2],#1
        STRB    R0,[R14],#1
        SUBS    R1,R1,#1
        BNE     oldapploop
; R1 now zero
        STRB    R1,[R14]                ; make sure its terminated
        SUB     R2,R14,#11              ; get R2 back to name that is actually used
; R2 should have a valid sprite, does it exist?
        LDR     R1,[handle,#w_areaCBptr]
      [ SpritePriority
        Push    "R2"
        CMP     R1, #1                  ; try any user area before either Wimp area
        SETPSR  V_bit, R0, EQ           ; SETV will *not* do, it corrupts Z
        MOVNE   R0, #256+SpriteReason_SelectSprite ; attempt to select sprite
        SWINE   XOS_SpriteOp
        MOVVS   R0, #256+SpriteReason_SelectSprite
        LDRVS   R1, baseofhisprites
        LDRVS   R2, [SP]
        SWIVS   XOS_SpriteOp            ; not there? try again within high-priority area
        MOVVS   R0, #256+24
        LDRVS   R1, baseoflosprites
        LDRVS   R2, [SP]
        SWIVS   XOS_SpriteOp            ; not there? try again within low-priority area
        Pull    "R2"                    ; sprite op can stuff R2
      |
        CMP     R1,#1
        LDREQ   R1,baseofsprites
        MOV     R0,#SpriteReason_SelectSprite+256 ; attempt to select sprite
        Push    "R2"
        SWI     XOS_SpriteOp
        LDRVS   R1,baseofromsprites
        MOVVS   R0,#256+SpriteReason_SelectSprite ; would have been done by the error!
        LDRVS   R2,[SP]
        SWIVS   XOS_SpriteOp            ; not there? try again within the ROM
        Pull    "R2"                    ; sprite op can stuff R2
      ]
        LDRVS   R0,[R2,#-8]             ; icon's ymax
        LDRVC   R0,[R2,#-16]            ; ymin
        SUBVC   R0,R0,#60               ; gap
        STR     R0,[R2,#+i_size-8]      ; icon 3's ymax
        Pull    "R1,R2"
doneappsprite

	Debug	err,"doneappsprite"
        MOV     R0,#-1
        Push    "R0"
; we use the stack to keep track of displayed icons

;
; put appropriate OK / Cancel box(es) into error window
;

        LDR     R14,tempworkspace+errtws_buttonlist
        TST     userblk,#erf_newtype
        AcceptLoosePointer_NegOrZero R14,0,NE,R0
        CMPNE   R14,R14,ASR #31
        BNE     %FT10

        TST     userblk,#erf_okbox:OR:erf_cancelbox
        ORREQ   userblk,userblk,#erf_okbox      ; ensure there is at least an OK
;
10
        TST     userblk,#erf_okbox
        MOV     R0,#1                   ; this is icon 1
        Push    "R0",NE                 ; displayed
        LDR     R0,[handle,#w_icons]
        LDR     R14,[R0,#i_flags+i_size*1]
        ORR     R14,R14,#is_deleted     ; will be undeleted later if necessary
        STR     R14,[R0,#i_flags+i_size*1]
;

        TST     userblk,#erf_cancelbox
        MOV     R0,#4                   ; this is icon 4
        Push    "R0",NE                 ; is displayed
        LDR     R0,[handle,#w_icons]
        LDR     R14,[R0,#i_flags+i_size*4]
        ORR     R14,R14,#is_deleted     ; will be undeleted later if necessary
        STR     R14,[R0,#i_flags+i_size*4]

        AND     R0, userblk, #erf_okbox :OR: erf_cancelbox :OR: erf_htcancel
        TEQ     R0, #erf_okbox :OR: erf_cancelbox :OR: erf_htcancel
; in this case, we must swap over the position of the OK/Cancel buttons to reflect the effect of keypresses
        MOVEQ   R0, #1
        STREQ   R0, [sp]
        MOVEQ   R0, #4
        STREQ   R0, [sp, #4]

        TST     userblk,#erf_describe
        MOV     R0,#6                   ; this is icon 6
        Push    "R0",NE                 ; is displayed
        LDR     R0,[handle,#w_icons]
        LDR     R14,[R0,#i_flags+i_size*6]
        ORR     R14,R14,#is_deleted     ; will be undeleted later if necessary
        STR     R14,[R0,#i_flags+i_size*6]


; now do dynamic icons 7,8,9,10

        LDR     R2,tempworkspace+errtws_buttonlist
        AcceptLoosePointer_NegOrZero R2,0
        CMP     R2,R2,ASR #31
        MOVEQ   R3,#7
        BEQ     markinvisibleicons

        TST     userblk,#erf_newtype
        MOVEQ   R3,#7
        BEQ     markinvisibleicons

; these are indirected captain. Can't splurge the data as it may come from ROM!
; need to copy it somewhere safe.

        MOV     R0,#-1
        Push    "R0"
        MOV     R14,#0
        ADRL    R3,errorbuttons
        MOV     R1,#errorbuttonsize
        MOV     R4,#maxno_error_buttons   ; this is the maximum number of additional buttons we can have
        Push    "R3"                      ; the first button is always at the start of the string
setupdynamicsloop
        SUBS    R1,R1,#1                  ; run out of buffer space? (one byte required for terminator)
        LDRNEB  R0,[R2],#1                ; get character from source
        TSTNE   R0,#224                   ; is it a control character?
        STREQB  R14,[R3]                  ; null-terminate the copy and finish
        BEQ     %FT06
        CMP     R0,#","                   ; is it a comma?
        STRNEB  R0,[R3],#1                ; no:  copy character and loop
        BNE     setupdynamicsloop
        STRB    R14,[R3],#1               ; yes: copy a NULL
        SUBS    R4,R4,#1                  ;      decrement buttons counter
        Push    "R3",NE                   ;      unless we've got all the buttons we can, push the button address and loop
        BNE     setupdynamicsloop
06
        [ debugerr
        Push    "R0-R8"
        ADD     R0, sp, #9*4
        LDMIA   R0,{R0-R8}
        Debug   err, "setupdynamicsloop: stack contains",R0,R1,R2,R3,R4,R5,R6,R7,R8
        Pull    "R0-R8"
        ]

; stack now holds pointers to button labels

        MOV     R3,#7
        LDR     R1,[handle,#w_icons]
        Pull    "R0"
setupiconsloop
        ADD     R2,R1,R3, LSL #i_shift  ; R2-> icon
        STR     R0,[R2,#i_data]
        Pull    "R0"
        ADD     R3,R3,#1
        CMP     R0,#-1
        BNE     setupiconsloop
        STR     R3,tempworkspace+errtws_iconend  ; number of extra buttons (+7)

        [ debugerr
        Push    "R0-R8"
        ADD     R0, sp, #9*4
        LDMIA   R0,{R0-R8}
        Debug   err, "setupiconsloop: stack contains",R0,R1,R2,R3,R4,R5,R6,R7,R8
        Pull    "R0-R8"
        ]

; now set what needs to be displayed and aligned

        SUB     R2,R3,#1
displayiconsloop
        Push    "R2"
        SUB     R2,R2,#1
        CMP     R2,#6
        BNE     displayiconsloop


markinvisibleicons
        MOV     R2,#-1
        Push    "R2"
; stack now contains list, eg:    (-1, 7, 8, 9, 10, 6, 4, 1, -1)
; if number >maxno_error_buttons, we must make some invisible, then position the rest

; unused icons need to be made invisible
markinvisloop
        CMP     R3,#7+maxno_error_buttons-1
        BHI     markinvend
        MakeInvisibleReg   R3
        ADD     R3,R3,#1
        CMP     R3,#7+maxno_error_buttons
        BLO     markinvisloop
markinvend

; count icons on stack
        ADD     R2,sp,#4                ; jump -1
        MOV     R0,#0
countstackicons
        LDR     R1,[R2],#4
        CMP     R1,#-1
        ADDNE   R0,R0,#1
        BNE     countstackicons

        CMP     R0,#maxno_error_buttons+1
        BLO     alignicons
        Pull    "R1"
        SUB     R0,R0,#maxno_error_buttons
marktoomanyicons
        Pull    "R1"
        MakeInvisibleReg  R1
        SUBS    R0,R0,#1
        BNE     marktoomanyicons
        MOV     R0,#-1
        Push    "R0"

alignicons

	Debug	err,"alignicons"

; stack now has at most maxno_error_buttons icons, R2-8 -> icon to appear on far right.

        SUB     R2,R2,#8
        LDR     R0,[handle,#w_wex1]     ; R0 is max x coord, use as running right posn
        SUB     R0,R0,#20               ; 20 OS unit border
        LDR     R1,[R2],#-4
        LDR     R14,[handle,#w_icons]

; the first icon is always a default (aka "highlighted") one
        ADD     R3, R14, R1, LSL #i_shift       ; R3 -> first icon
        LDR     R4, errbut_y0_def
        STR     R4, [R3, #i_bby0]
        LDR     R4, errbut_y1_def
        STR     R4, [R3, #i_bby1]
        LDR     R4, errbut_fl_def
        STR     R4, [R3, #i_flags]
        LDR     R4, errbut_va_def
        STR     R4, [R3, #i_data + 4]
        LDR     R4, errbut_w_def
        B       alignanddisplayicon

alignnexticon
        ADD     R3, R14, R1, LSL #i_shift       ; R3 -> icon
        LDR     R4, errbut_y0
        STR     R4, [R3, #i_bby0]
        LDR     R4, errbut_y1
        STR     R4, [R3, #i_bby1]
        LDR     R4, errbut_fl
        STR     R4, [R3, #i_flags]
        LDR     R4, errbut_va
        STR     R4, [R3, #i_data + 4]
        LDR     R4, errbut_w

alignanddisplayicon
; R1 is icon number, R14 is icon base, R0 is rhs of icon, R4 is minimum width

      [ StretchErrorButtons
        Push    "R0,R1,R2,R4,R14"
        LDR     R1,[R3,#i_flags]
	ADD	R2,R3,#i_data
	BL	seticonptrs
	LDR	R2,[R3,#i_data]
	Debug	err,">textwidth"
        BL      textwidth
	Debug	err,"<textwidth"
        ADD     R5,R4,#36                       ; allow 18 OS-units each side, in case it's a default button
        Pull    "R0,R1,R2,R4,R14"
        max     R4,R5
      ]
        MOV     R5,R0
        SUB     R0,R0,R4
        SUB     R0,R0,#20                       ; gap between buttons
        SUB     R4,R5,R4
        STR     R4,[R3,#i_bbx0]
        STR     R5,[R3,#i_bbx1]
        LDR     R1,[R2],#-4
        CMP     R1,#-1
        BNE     alignnexticon

        ADD     SP,SP,#4                        ; skip -1
clearstack
        Pull    "R1"
        CMP     R1,#-1
        BNE     clearstack

; now resize window if necessary, by moving lhs.

        CMP     R0,#0
        MOVGT   R0,#0                           ; this is the work area x0 required by the buttons

        LDR     R14, [handle, #w_icons]
        LDR     R1, errmess_x0
        ADD     R2, R14, #i_size * 0            ; R2 -> text icon definition
        ADD     R3, R0, R1                      ; stretch text icon to fit window
        STR     R3, [R2, #i_bbx0]

      [ StretchErrorText
        LDR     R0, [sp]                        ; get error block pointer
        ADD     R0, R0, #4
        STR     R0, [R2, #i_data + 0]           ; set up text pointer now, we need it to calculate the icon width

        Push    "R1-R6, R10, R14"
06
        MOV     R1, #-1
        STR     R1, linecount                   ; activate line counting
        LDR     R2, [sp, #1*4]                  ; R2 -> text icon definition
        LDMIA   R2, {x0, y0, x1, y1}            ;\.
        LDR     R1, [R2, #i_flags]              ; |
        LDR     R2, [R2, #i_data + 0]           ; | set up registers for line count
      [ outlinefont                             ; |
        LDR     R3, systemfont                  ;/
        TEQ     R3, #0
        ADREQL  R14, iconformatted_system
        ADRNEL  R14, iconformatted_fancy
      |
        ADRL    R14, iconformatted_system
      ]
        Push    "PC"                            ; PC+12 is actually stored
        MOV     PC, R14                         ; branch to appropriate routine - returns using Pull "PC"
        NOP

        LDR     R0, linecount
        Debug   err, "Error message icon line count =", R0
        CMP     R0, #errmess_maxlines
        BLE     %FT01                           ; satisfactory number of lines, we don't need to stretch any further
        LDR     R2, [sp, #1*4]                  ; R2 -> text icon definition
        LDR     R3, [R2, #i_bbx0]
        SUB     R3, R3, #errmess_increment      ; enlarge window by one step
        STR     R3, [R2, #i_bbx0]
        B       %BT06
01
        Pull    "R1-R6, R10, R14"

        LDR     R3, [R2, #i_bbx0]
        SUB     R0, R3, R1                      ; stretch window to fit icon

        MOV     R1, #0
        STR     R1, linecount                   ; deactivate line counting
      ]

        STR     R0,[handle,#w_wex0]
        LDR     R1,[handle,#w_wex1]
        STR     R0,[handle,#w_wax0]             ; horizontal centring dealt with later
        STR     R1,[handle,#w_wax1]             ; but the visible width *must* match the horizontal work area extent width

        ADD     R2, R14, #i_size * 2            ; move app sprite
        LDR     R3, [R2, #i_bbx0]
        LDR     R4, [R2, #i_bbx1]
        SUB     R4, R4, R3                      ; R4 = old width
        LDR     R3, errapp_x0
        ADD     R3, R3, R0                      ; make relative to new window edge
        ADD     R4, R4, R3
        STR     R3, [R2, #i_bbx0]
        STR     R4, [R2, #i_bbx1]

        ADD     R2, R14, #i_size * 3            ; move type sprite
        LDR     R3, [R2, #i_bbx0]
        LDR     R4, [R2, #i_bbx1]
        SUB     R4, R4, R3                      ; R4 = old width
        LDR     R3, errtype_x0
        ADD     R3, R3, R0                      ; make relative to new window edge
        ADD     R4, R4, R3
        STR     R3, [R2, #i_bbx0]
        STR     R4, [R2, #i_bbx1]

        ADD     R2, R14, #i_size * 5            ; stretch divider sprite
        STR     R0, [R2, #i_bbx0]
        STR     R1, [R2, #i_bbx1]

      [ NCErrorBox
        ADD     R2, R14, #i_size * 15           ; move left border
        STR     R0, [R2, #i_bbx0]
        ADD     R4, R0, #8                      ; magic number: width of vertical borders
        STR     R4, [R2, #i_bbx1]

        ADD     R2, R14, #i_size * 17           ; stretch top border
        STR     R0, [R2, #i_bbx0]

        ADD     R2, R14, #i_size * 18           ; stretch bottom border
        STR     R0, [R2, #i_bbx0]
      ]

; and we're done!!
        |
;
; put appropriate OK / Cancel box(es) into error window
;
        TST     userblk,#erf_okbox:OR:erf_cancelbox  ; 0 ==> just OK box
        MOVEQ   userblk,#erf_okbox
        TST     userblk,#erf_okbox
        ORREQ   userblk,userblk,#erf_htcancel   ; highlight one of them
;
        TST     userblk,#erf_okbox
        LDR     R14,[handle,#w_icons]
        LDR     R14,[R14,#i_flags+i_size*1]
        BIC     R14,R14,#is_inverted    ; ensure not inverted initially
        ORREQ   R14,R14,#is_deleted
        BICNE   R14,R14,#is_deleted
        TST     userblk,#erf_htcancel
        LDRNE   R0,unhighlighted_colour ; values read from icons initially
        LDREQ   R0,highlighted_colour   ; values read from icons initially
        BIC     R14,R14,#if_bcol:OR:if_fcol
        ORR     R14,R14,R0
        LDR     R0,[handle,#w_icons]
        STR     R14,[R0,#i_flags+i_size*1]
;
        TST     userblk,#erf_cancelbox
        LDR     R14,[handle,#w_icons]
        LDR     R14,[R14,#i_flags+i_size*4]
        BIC     R14,R14,#is_inverted    ; ensure not inverted initially
        ORREQ   R14,R14,#is_deleted
        BICNE   R14,R14,#is_deleted
        TST     userblk,#erf_htcancel
        LDREQ   R0,unhighlighted_colour ; values read from icons initially
        LDRNE   R0,highlighted_colour   ; values read from icons initially
        BIC     R14,R14,#if_bcol:OR:if_fcol
        ORR     R14,R14,R0
        LDR     R3,[handle,#w_icons]
        STR     R14,[R3,#i_flags+i_size*4]
        LDR     R2,[R3,#i_bbx0+i_size*0]
        LDR     R3,[R3,#i_bbx1+i_size*0]
        SUB     R3,R3,R2
        AND     R14,userblk,#erf_okbox:OR:erf_cancelbox
        CMP     R14,#2                  ; poss. values are 1,2,3 (L,R,BOTH)
        LDRNE   R1,[handle,#w_icons]
        ADDNE   R1,R1,#i_size*1
        ADDHI   R2,R2,R3,ASR #2         ; add 1/4 of width if both present
        ADDLO   R2,R2,R3,ASR #1         ; add 1/2 of width if 'OK' only
        BLNE    setbuttonx              ; R1-->icon,R2=centre x-coord
        ADDHS   R2,R2,R3,ASR #1         ; add 1/2 of width -> Cancel
        LDRHS   R1,[handle,#w_icons]
        ADDHS   R1,R1,#i_size*4
        BLHS    setbuttonx              ; R1-->icon,R2=centre x-coord
        ]

;
; work out window coords (use coords in template)
;
        ADD     R1,handle,#w_wax0
        ASSERT  cx0=R2

	Debug	err, "working out window coords"
;
        Push    "R1"                    ; centre the dialogue
        LDMIA   R1,{cx0,cy0,cx1,cy1}
        SUB     cx1,cx1,cx0
        SUB     cy1,cy1,cy0

        MOV     R0,#-1
        MOV     R1,#VduExt_YWindLimit
        SWI     XOS_ReadModeVariable
        MOV     y0,R2                   ; screen height in pixels
        MOV     R1,#VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        MOV     y0,y0,ASL R2
        MOV     y0,y0,LSR #1            ; half screen height in OS units

        SUB     cy0,y0,cy1,LSR #1       ; - half the box height
        ADD     cy1,cy1,cy0             ; + box height

        MOV     R1,#VduExt_XWindLimit
        SWI     XOS_ReadModeVariable
        MOV     x0,r2                   ; screen width in pixels
        MOV     R1,#VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        MOV     x0,x0,ASL r2
        MOV     x0,x0,LSR #1            ; half screen width in OS units

        SUB     cx0,x0,cx1,LSR #1
        ADD     cx1,cx1,cx0             ; - half box width + box width

        Pull    "R1"
        LDR     x0,[R1,#16]
        LDR     y0,[R1,#20]
        LDR     x1,[R1,#24]
;
; construct window block on stack, for use in OpenWindow etc.
;
        LDR     R14,[sp,#0*4]           ; get error block pointer
        ADD     R14,R14,#4
        LDR     R0,[handle,#w_icons]
        STR     R14,[R0,#0*i_size+i_data+0]
;
        ASSERT  cx0=R2
        LDR     R0,errorhandle
        Push    "R0,cx0,cy0,cx1,cy1,x0,y0,x1,R9-R12" ; 12 words needed on stack
        MOV     userblk,sp
	Debug	err,"int_open_window"
        BL      int_open_window
        [ ChildWindows
        BLVC    int_flush_opens         ; this is necessary to set the rectangles lists correctly
        ]
;
        BLVC    visibleouterportion     ; handle --> window definition already
        BLVC    int_redraw_window
        BVS     donegetr
getrlp
        TEQ     R0,#0
        BEQ     donegetr
        BL      int_get_rectangle
        BVC     getrlp

donegetr
        SWI     XHourglass_Smash        ; turn off hourglass (if displayed)
                                        ; ignore errors
        ADD     R14,handle,#w_x0        ; confine pointer to error box
        LDMIA   R14,{x0,y0,x1,y1}
        BL      pointerwindow
;
        MOV     R0, #ScreenBlankerReason_Unblank
        SWI     XScreenBlanker_Control  ; unblank screen (if blanked)
;
        BL      flushkbdmouse           ; get ready to read these
;
      [ NCErrorBox
        ADRL    R0, ptrpreserveflag
        LDR     R0, [R0]
        TEQ     R0, #0                  ; Should we move the pointer over the default action button?
        BNE     %FT01

        Push    "cx0-y0"
        LDR     R14, errorhandle
        Abs     R14, R14

        LDR     cx0, [R14, #w_wax1]
        SUB     cx0, cx0, #20           ; 20 OS unit border
        LDR     cx1, errbut_w_def
        SUB     cx0, cx0, cx1, ASR #1   ; screen x of icon centre

        LDR     cy1, [R14, #w_way1]
        LDR     y0, [R14, #w_scy]
        SUB     y0, cy1, y0             ; screen y of wao
        LDR     cy0, errbut_y0_def
        LDR     cy1, errbut_y1_def
        ADD     cy0, cy0, cy1
        ADD     cy0, y0, cy0, ASR #1    ; screen y of icon centre

        SUB     sp, sp, #8
        MOV     R1, sp
        MOV     R0, #3
        STRB    R0, [R1]
        strw    cx0, R1, 1
        strw    cy0, R1, 3
        MOV     R0, #&15
        SWI     XOS_Word                ; Set mouse position
        ADD     sp, sp, #8

        ADRL    R0, ptrsuspendflag      ; Update our copy of the coords
        LDR     R1, [R0]                ; because IconHigh reads the mouse
        TEQ     R1, #2                  ; position using Wimp_GetPointerInfo!
        MOVEQ   R1, #1                  ; If pointer is currently hidden
        STREQ   R1, [R0]                ; until the next mouse move, remember
        BL      getmouseposn            ; to discount next mouse read.
        Pull    "cx0-y0"

01      MOV     R0, #106
        MOV     R1, #0
        SWI     XOS_Byte                ; Read current pointer number (also turns it off, but we'll soon switch it back)
        ADRL    R14, ptrshlflag
        STR     R1, [R14]               ; Store old pointer shape
        MOV     R0, #2
        SWI     XIconHigh_Start         ; Unconditionally start single-tasking IconHigh
        ADRL    R14, ptrshlflag
        MOV     R0, #106
        LDR     R1, [R14]               ; Restore pointer to the way it was after Hourglass_Smash
        SWI     XOS_Byte                ; (also undoes any unwelcome changes due to IconHigh_Start)
      ]

        ADD     sp,sp,#13*4             ; forget open block / error pointer
        Pull    "PC"

        [ NewErrorSystem
errwatchdogguard   DCD     &E240569E


 LTORG
        [ :LNOT: Bits30and23

IsThisProgErr
; returns EQ is proram error, R4-> error number
        Push    "R0-R2,lr"
        LDR     R2,[R4]
        AND     R0,R2,#&3f000000        ; mask 'prog-detect'
        TEQ     R0,#27 :SHL: 24         ; escape shifted
        Pull    "R0-R2,PC",EQ

        ADR     R0,progerrslist
01
        LDR     R1,[R0],#4
        TEQ     R1,R2
        Pull    "R0-R2,PC",EQ
        CMP     R1,#-1
        BNE     %BT01
        MOVS    R1,#1                   ; NE

        Pull    "R0-R2,PC"
        ]

        ]

        END
@


4.33
log
@Make use of power saving features when sat waiting for user input
Detail:
  s/Wimp03 - Move two key bits of power-saving logic out of repollwimp and into a new subroutine (powersave_tick)
  s/Wimp01, s/Wimp07 - Call powersave_tick when displaying an error box or "Press SPACE or click mouse to continue", so that CPU will drop speed and enter WFI state instead of running at full tilt.
Admin:
  Tested on Pandaboard
  Fixes issue reported on forums with CPUs getting hot for no good reason:
  https://www.riscosopen.org/forum/forums/4/topics/3749


Version 5.51. Tagged as 'Wimp-5_51'
@
text
@d757 1
d1088 46
d1188 1
a1190 6
;
      [ StartTaskPostFilter
        LDR     R14,sender
        CMP     R14,#-1
        BLT     %FT01                ; Are we starting up Wimp_StartTask?
        BNE     %FT02                ; Are we returning from Wimp_StartTask?
a1191 38
; We're returning from Wimp_StartTask and
; R0 = task handle of child (or 0). Wimps before 3.96
; would not call the post-filter in this case, but would
; call it if Wimp_StartTask returned 0 (so the filter
; would think a null event was happening.) Now, the
; Toolbox (and probably other filters) relies on the
; post filter to monitor the current task. If the postfilter
; doesn't get called here then there is no way of telling
; that this task has become active. So, we now call the filter
; with a null event, and ignore any attempt to claim it. (In
; the past the filter was able to claim the "null" event if
; Wimp_StartTask returned 0, causing instant death.
; This is the problem that hit Toolbox 1.33).
;
; Hopefully this shouldn't cause any problems, as filters
; will have had to be able to deal with the dummy "null"
; event for at least some Wimp_StartTask calls already.

        Push    "R0,R1"
        MOV     R0,#No_Reason
        MOV     R1,userblk
        CallFilter postfilter           ; call the post-poll filter (ignoring
        Pull    "R0,R1"                 ; R0 return)
        B       %FT01

02
      |
        CMP     R0,#max_reason          ; Valid message?
        BHS     %FT01                   ; No then jump,maybe -> *command from Wimp_StartTask
      ]

        Push    "R1"
        MOV     R1,userblk
        CallFilter postfilter           ; call the post-poll filter
        Pull    "R1"
        CMP     R0,#-1
        BEQ     repollwimp              ; if it claimed then just re-poll
01
@


4.32
log
@Replace OS_SpriteOp reason code magic numbers with definitions. Add support for new screen modes.
Detail:
  s/Tiling, s/Tiling3D, s/Watchdog, s/Wimp05, s/Wimp07, s/Wimp09 - Replaced OS_SpriteOp reason code magic numbers with symbolic definitions.
  s/Wimp01 - Update *WimpMode / Wimp_SetMode to use OS_ScreenMode 13 (mode string to specifer) in place of its own code if a mode specifier string has been given. Note - mode number handling is unchanged, so a mode specifier string which begins with a mode number will currently have the specifier part ignored.
  s/Wimp01, s/Wimp02 - Flag_* -> ModeFlag_* renaming
  s/Wimp02 - Fix mode specifier copying to only stop copying when we hit a mode variable of -1. Previous code would also stop if the variable value was -1. Update mode set code to apply the Wimp's special greyscale palettes if the greyscale mode flag is set (i.e. greyscale mode was set via specifier generated by OS_ScreenMode 13)
Admin:
  Tested on BB-xM


Version 5.31. Tagged as 'Wimp-5_31'
@
text
@d1603 1
d1688 1
@


4.31
log
@Refinements to disc based targets especially
Previous attempt to disable Sprites11 support for 3.10 and 3.50 hadn't spotted it was reenabled in the common options, also the Sprites11 switch was also tied up in Wimp$IconTheme support.
Title bars would flicker when picked up when using a tool sprite set with no 'p' pushed equivalents on RISC OS 4.0x due to screen cache.
Makefile now installs a default set of tools & sprites when target is ThemeDefs.
CLI limit reduced to 256 pre Ursula to save RAM.

Options/!Common:
  Promote Sprites11 switch into !Default
  Remove fixrmatools
Options/!Default:
  Sprites11 true by default
  LongCommandLines true by default, false on targets pre Ursula
  Remove ServiceCallTable (harmless to have it in all cases)
NewSWIs.s:
  Enable Wimp_Extend 13 all the time
Wimp01.s:
  Reduce RMA use by vital 1.5k for non long command line case
  Change sense of Sprites11 switch to adopt all its previous functionality, but not look for '11' suffix when the switch is false
  Adopt ServiceCallTable switch permanently
Wimp02.s:
  Comments ammended
Wimp07.s:
  Range of ADR
Wimp10.s:
  Change sense of Sprites11 switch to adopt all its previous functionality, but not look for '11' suffix when the switch is false
  Adopt :LNOT: fixrmatools switch permanently
  Supress title bar sprite plotting when none of the sprites exist

Version 5.25. Tagged as 'Wimp-5_25'
@
text
@d2503 1
a2503 1
        MOVNE   R0, #256+24             ; attempt to select sprite
d2505 1
a2505 1
        MOVVS   R0, #256+24
d2517 1
a2517 1
        MOV     R0,#24+256              ; attempt to select sprite
d2521 1
a2521 1
        MOVVS   R0,#256+24              ; would have been done by the error!
@


4.30
log
@Slacken pointer checks
The pointer comparison checking required when running in a system with > 64M memory was tightened up from Wimp-4_75 to Wimp-4_76, but to allow the module to target pre RISC OS 5 systems an option to relax those checks is required.
Each check has been revisited and where appropriate demarked with a "AcceptLoosePointer" macro, which just remaps the pointer into the stricter form and carries on. In the strict checking case, the macro reduces to nothing.

Detail:
Add AcceptLoosePointers switch.
Retire singular use of StrongARM switch (calling XOS_SynchroniseCodeAreas is harmless pre StrongARM anyway).
Rename Ursula_RPC options to RO400.
Put duplicate documentation in the attic.
Allow -2 or -1 as the iconbar handle in Wimp_ResizeIcon (ticket #203).
Tighten up the list terminator check in the DebugMemory switch of Memory.s

Tested on RISC OS 3.10 (emulated), 3.50, 3.60, 3.70, 4.02.

Version 5.24. Tagged as 'Wimp-5_24'
@
text
@d778 1
a778 1
        ADR     R1,taskbuffer
d815 1
a815 1
        ADR     R0,taskbuffer           ; copy of *command is in here
@


4.29
log
@Make compatible with zero page relocation
Detail:
  s/Wimp, s/Wimp01, s/Wimp02, s/Wimp07, s/Wimp08 - Try using OS_ReadSysInfo 6 to get IRQsema & DomainId locations before falling back on legacy values. Store the pointers in module workspace for speedy access.
Admin:
  Tested on rev A2 BB-xM


Version 5.13. Tagged as 'Wimp-5_13'
@
text
@d1722 1
d2358 1
d2412 1
d2544 1
d2589 1
@


4.28
log
@Update Wimp to use new VFPSupport_ChangeContext_AppSpace flag
Detail:
  s/Wimp03, s/Wimp07 - When saving the VFP context the Wimp now uses lazy context switching where possible, via a combination of the Lazy & AppSpace flags
Admin:
  Tested on rev A2 BB-xM
  Requires VFPSupport 0.02


Version 5.11. Tagged as 'Wimp-5_11'
@
text
@d1049 2
a1050 2
        MOV     R14,#0
        STR     handle,[R14,#&FF8]      ; for Stuart
@


4.27
log
@Make the Wimp automatically switch VFP contexts
Detail:
  s/Wimp, s/Wimp01, s/Wimp02, s/Wimp03, s/Wimp07 - The Wimp now uses the VFPSupport module to switch VFP contexts when performing task switches.
  Each task begins with the null context active (i.e. no VFP/NEON access). When paging out a task the ID of the active context is saved in the Wimp's per-task workspace. This context is then restored when the task is about to be resumed.
  Context save/restore is performed while the right task's memory is paged in, so it's safe to use with contexts located in application space.
Admin:
  Tested with Iyonix & Beagle ROM builds.


Version 5.09. Tagged as 'Wimp-5_09'
@
text
@d750 1
a750 1
; save VFP context. Can't save lazily since it might be in application space.
d754 1
a754 1
        MOV     R1,#0
@


4.26
log
@Fix a few nasty Wimp bugs
Detail:
  s/Wimp05 (setcaretcoords_fancy), s/Wimp07 - Fix some dodgy comments that had trailing backslashes, causing the next line of code to be gobbled by objasm and omitted from the compiled code. The code in question has been around for a long time, so I guess a recent objasm change (or the switch from aasm) has caused the dodgy comments to turn malicious. The setcaretcoords_fancy bug was the cause of bug #241 in the ROOL tracker.
  s/Wimp05 (int_set_caret_position) - While testing the #241 fix, I found that opening the filer 'rename' menu, typing text (enough to cause the icon to scroll), and then clicking away to close the menu would cause an infinite abort loop. The cause seemed to be int_set_caret_position mistakenly setting the caret window ptr to 0 instead of nullptr (-1), which would then cause setwindowptrs to die when it tried dereferencing what it thought was a valid pointer. Although initially confused about how this bug has gone unnoticed so far, I've now realised the abort was just down to alignment exceptions being turned on and the code would have "worked" on <=ARMv5.
Admin:
  Tested on rev C2 beagleboard.
  Fixes bug #241.


Version 5.08. Tagged as 'Wimp-5_08'
@
text
@d750 10
d1087 1
a1093 1
        Push    "R0",NE
a1098 1
        Pull    "R0",NE
d1103 2
a1104 2
        LDRNE   R4,[R4,#task_fpblock]
        TEQNE   R4,#0                   ; NE => restore registers
d1109 1
a1109 1
        Debug   fp,"Restoring FP state from block at",R4
d1115 2
a1116 2
        LFM     F0,4,[R4,#fp_reg0]      ; (only gets here if active previously)
        LFM     F4,4,[R4,#fp_reg4]
d1120 2
a1121 2
        DCD     &ED940200 :OR: (fp_reg0:SHR:2)
        DCD     &ED944200 :OR: (fp_reg4:SHR:2)
d1124 8
a1131 8
        LDFE    F0,[R4,#fp_reg0]        ; (only gets here if active previously)
        LDFE    F1,[R4,#fp_reg1]
        LDFE    F2,[R4,#fp_reg2]
        LDFE    F3,[R4,#fp_reg3]
        LDFE    F4,[R4,#fp_reg4]
        LDFE    F5,[R4,#fp_reg5]
        LDFE    F6,[R4,#fp_reg6]
        LDFE    F7,[R4,#fp_reg7]
d1133 1
a1133 1
        LDR     R5,[R4,#fp_status]
d1136 7
@


4.25
log
@32-bitted some debugging code.
Moved the Hdr:NdrDebug routines so that debug versions build.

No change to production binaries, so not tagged.
@
text
@d2768 1
a2768 1
        LDMIA   R2, {x0, y0, x1, y1}            ;\
@


4.24
log
@Wimp_ReportError would loop indefinitely if the error string was zero length
and the desktop font was an outline font.

Version 4.89. Not tagged
@
text
@d1276 1
d1280 3
@


4.23
log
@Added a new window flag (extra flags byte bit 4) to indicate that
Wimp_GetPointerInfo should include shaded icons, in particular so that they
can now have interactive help. Included some information on RISC OS Select
APIs so that we can avoid clashes.

Version 4.89. Tagged as 'Wimp-4_89'
@
text
@d2782 1
a2782 1
        BLS     %FT01                           ; satisfactory number of lines, we don't need to stretch any further
@


4.22
log
@  Bugfixes.
Detail:
  * All tasks have erroneously been flagged as receiving all messages since
    version 4.78. Correct behaviour is now restored, and the previous
    fix (to ignore Wimp_AddMessages calls for tasks that already wanted
    all messages) should be unaffected.
  * Check for "P"-validation icon creation under the pointer was broken
    in three ways, now works.
  * The optimisation of multiple Message_SlotSize calls is overenthusiastic,
    and can lead to some messages being lost if the slot size is changed
    (including as a side-effect of OS_ChangeDynamicArea) during
    high-priority pollword-nonzero handlers or message handlers for
    Message_SlotSize - in both situations, a message block that may have
    already been delivered to some tasks is still present at the head of
    the message list. Now, the optimisation always ignores the message at
    the head of the message list.
Admin:
  Tested on Tungsten.

Version 4.86. Tagged as 'Wimp-4_86'
@
text
@d1733 2
d1736 1
@


4.21
log
@  Bugfixes.
Detail:
  * Message list pointers passed into Wimp_Initialises that didn't follow
    Wimp_StartTask used to be corrupted
  * Stack imbalance in ExitPoll if SWI Portable_Speed didn't preserve flags
  * 32-bit mode test speedups
  * Builds without RO4 option set
Admin:
  Tested on Tungsten and Risc PC.

Version 4.79. Tagged as 'Wimp-4_79'
@
text
@d292 2
@


4.20
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@d1059 7
a1065 6
        Push    "R0-R1",NE
        MOVNE   R0,#0
        MOVNE   R1,#0
        SWINE   XPortable_Speed         ; if not a null event then make it go fast
        Pull    "R0-R1",NE

d1219 3
a1221 4
        MRS     R0,CPSR
        TST     R0,#2_11100                     ; 32-bit system?
        LDREQ   R0,[R5,#task_registers+4*15]    ; 26-bit: modify R15
        LDRNE   R0,[R5,#task_registers+4*16]    ; 32-bit: modify CPSR
d1228 2
a1229 2
        STREQ   R0,[R5,#task_registers+4*15]
        STRNE   R0,[R5,#task_registers+4*16]
d1294 1
a1294 4
        MOV     R0,#0
        MRS     R0,CPSR
        TST     R0,#2_11100                     ; are we 26 or 32-bit?

d1296 2
a1297 2
        LDRNE   R0,[lr_svc,#16*4]
        MSRNE   SPSR_cxsf,R0
@


4.19
log
@  Commit of my Wimp changes that have trickled in over the last four months.
Detail:
  * The pointer passed to Wimp_CommandWindow can now be top-bit-set.
  * Bugfix to Wimp_CommandWindow: if the current task was uninitialised,
    or initialised as a non-multitasking task, then although entering the
    CommandWindow would restore escape condition generation to the way it
    was before entering the desktop, exiting the CommandWindow did not
    reset escape condition generation to the default desktop state (which is
    for escape condition generation to be disabled).
  * Escape condition generation is disabled for the duration of SWI
    Wimp_ReportError (instead of setting the default escape key for the
    duration). The previous state is restored on exit.
  * Added a minimal environment for the service call
    Service_ErrorButtonPressed, so that claimants can call OS_Exit without
    leaving the global Wimp error box in an undefined state.
  * In the Wimp_Poll loop, if there are no events to deliver to any tasks
    (not even null events), then rather than sitting in a SVC mode loop,
    the Wimp now triggers transient callbacks. This is particularly
    important in order not to halt all activity in the Internet stack.
    The option LeaveOS can be set to make the Wimp use the as-yet
    unimplemented SWI OS_LeaveOS for this purpose; this is currently unset
    for all builds.
  * By (persistent) request, reinstated the old iconbar popping code,
    though it is currently a build switch that is turned off for all builds.
Admin:
  Tested on a Risc PC.

Version 4.69. Tagged as 'Wimp-4_69'
@
text
@d79 2
a80 2
        CMP     R14,#0
        BLE     glurg
d88 2
a89 2
        CMP     R14,#0
        BLE     glurg
d91 2
a92 2
        CMP     R14,#0
        BLE     glurg
d293 2
a294 2
        CMP     R0,#0
        BLE     %FT99
d427 2
a428 2
        CMP     R5,#0
        BLE     doneackmess                     ; finished
d463 4
a466 2
        SUBS    R4,R1,#ROMstart         ; don't splat the ROM!
        RSBCSS  R4,R4,#OSROM_ImageSize * 1024
d468 2
a469 2
        STRCC   R4,[R1,#ms_sender]
        STRCC   R14,[R1,#ms_myref]
d491 2
a492 2
        CMP     R4,#0
        ADRLE   R4,headpointer-msb_link
d497 3
a499 3
        CMP     R14,#0
        MOVGT   R4,R14
        BGT     %BT01
d535 1
a535 1
        BGE     %BT01
d715 2
a716 2
        CMP     R1,#0
        Pull    "R1,PC",LE
d1351 2
a1352 2
        MOVLE   R3,#fp_size
        BLLE    claimblock                      ; R2 -> block address
d1626 2
a1627 2
        CMP     R8,#0
        BLE     noerrorwindow           ; oops!
d1703 2
a1704 2
        CMP     R2,#1
        BLT     %FT06 ; if no extra buttons, skip next section
d1709 1
a1709 1
        CMPGE   R4, #-1                 ; have we found both buttons yet?
d1714 1
a1714 1
        CMPGE   R4, #-1                 ; have we found both buttons yet?
d1794 3
a1796 3
        SUBGT   R1,R1,#2
        LDRGT   R2,tempworkspace+errtws_iconend
        SUBGT   R1,R2,R1                ; extra icons 7-10 return 6-3
d2335 1
a2335 2
        CMP     R2,#0                   ; do they want an application name?
        CMPNE   R2,#nullptr
d2388 1
a2388 1
        CMP     R3,#1
d2390 2
a2391 2
        LDRLT   R14,[handle,#w_icons]
        ADDLT   R14,R14,#i_size
d2393 4
a2396 4
        ADRLT   R0,contlabel
        Push    "R2",LT                         ; SMC: now lookup text for button but leave it to oldappsprite2 (must preserve R2)
        ADRLTL  R2,conttext
        BLT     oldappsprite2
d2399 2
a2400 2
        CMP     R2,#255
        STRGT   R2,[handle,#w_areaCBptr]
d2448 1
a2448 2
        CMP     R2,#0
        CMPNE   R2,#nullptr
d2456 3
a2458 3
        ADRLE   R2,noappname
        MOVLE   R1,#11
        BLE     oldapploop
d2519 1
a2519 1
        TEQNE   R14,#0
d2563 3
a2565 3
        CMP     R2,#1
        MOVLT   R3,#7
        BLT     markinvisibleicons
d2644 1
a2644 1
        BGT     markinvend
d2648 1
a2648 1
        BLT     markinvisloop
d2661 1
a2661 1
        BLT     alignicons
d2780 1
a2780 1
        BLE     %FT01                           ; satisfactory number of lines, we don't need to stretch any further
d2882 2
a2883 2
        ADDGT   R2,R2,R3,ASR #2         ; add 1/4 of width if both present
        ADDLT   R2,R2,R3,ASR #1         ; add 1/2 of width if 'OK' only
d2885 4
a2888 4
        ADDGE   R2,R2,R3,ASR #1         ; add 1/2 of width -> Cancel
        LDRGE   R1,[handle,#w_icons]
        ADDGE   R1,R1,#i_size*4
        BLGE    setbuttonx              ; R1-->icon,R2=centre x-coord
@


4.18
log
@  Minor fixes, some of which have been waiting to be committed for a while.
Detail:
  * Command line buffer for Wimp_StartTask (and anything that uses it,
    eg *WimpTask) increased from 256 bytes to 1024 bytes.
  * Top-bit-set message list pointers passed to Wimp_Initialise and
    Wimp_RemoveMessages now work (there was never a problem with
    Wimp_AddMessages!)
  * The fix for top-bit-set application name pointers in Wimp 4.65 actually
    only fixed lookup for "<application> may have gone wrong" lookups. They
    now work correctly in error window title construction, and when
    constructing an application sprite name if flag bit 8 is clear.
  * A pointer value of 0 is now accepted in addition to -1 for an
    "<application> may have gone wrong" lookup - this brings it into line
    with the other two places where the application name pointer is
    referenced.
  * When constructing an error window title, the Wimp would skip any leading
    backslash character. Now it does so when constructing "<application> may
    have gone wrong" too - this is a simple way to disable the application
    sprite in the error window.
Admin:
  Error box behaviour actually tested this time!

Version 4.67. Tagged as 'Wimp-4_67'
@
text
@d1650 1
a1650 1
        MOV     R0, #220                ; Read current escape key so we can restore it later
d1656 2
a1657 2
        MOV     R0, #220                ; Set default escape key
        MOV     R1, #27
d1798 1
d1804 1
d1808 1
d1865 1
d1931 1
a1931 1
        MOV     R0, #220                ; restore the old escape key
d1968 68
@


4.17
log
@  Fixed a number of long-standing but low priority bugs in the Wimp.
Detail:
  * Any top-bit-set sprite area pointer in a window definition was treated
    as a null pointer, and any top-bit-set program name pointer in
    Wimp_ReportError was similarly treated as a null pointer.
  * For 24-bit window colour builds, when the Wimp drew a title bar with
    the input focus, and there were sprite icons in the previously redrawn
    window, and the most recently plotted icon sprite was unpaletted and not
    selected or inverted, then the translation table for the icon sprite (in
    the RMA) would leak. I suppose that's what I get for re-using a bit of
    dead code without fully working out why it was bypassed in the first
    place...
  * The key handling code used to be over-eager to read bytes from the
    keyboard buffer: it would attempt to read up to 6 bytes ahead to ease
    the recognition of UTF-8 character sequences. This could cause problems,
    in particular if F12 was one of those 6 bytes, then any following bytes
    would be queued for use as Wimp keypresses, rather than being left in
    the keyboard buffer for use by ShellCLI. The Wimp now analyses the first
    byte read to make a sensible estimate of how many bytes it needs to read
    ahead.
  * Select-dragging (including Select-resizing) of windows with panes used
    to soak up all the processor time. This was because when the task
    received an Open_Window_Request, it would re-open the pane in front of
    the main window, but this would cause the Wimp to believe that it had to
    re-open the main window at the front of the stack again when Wimp_Poll
    was next called. The problem has been fixed so that the Wimp now
    examines all the windows in front of the drag window to see if they have
    the pane window flag bit set, and doesn't reshuffle the windows if they
    all do. (Actually, the test is performed such that foreground windows
    in front of the drag window are also ignored.)
Admin:
  Tested on a desktop machine.

Version 4.65. Tagged as 'Wimp-4_65'
@
text
@d2092 2
a2093 2
        CMP     R6,#nullptr
        MOVNE   R4,R6
d2095 3
d2262 4
a2265 3
        ADRLEL  R0,errorprefix1
        BICLE   R1,R1,#erf_omiterror
        ADRGTL  R0,errorprefix2         ; -> suitable token
d2272 2
a2273 2
        CMP     R4,#0
        BLE     %FT01
d2375 5
a2379 4
        CMP     R2,#1
        ADRLT   R2,noappname
        MOVLT   R1,#11
        BLT     oldapploop
@


4.17.2.1
log
@  Added Dan Ellis's multithreading support, on a development branch for now.
Detail:
  This breaks the equivalence between tasks and AMB slots, allowing many
  threads of execution to share the same AMB slot, where an application's
  heap is usually located. In API terms, it is presented as an extension to
  Wimp_StartTask, see Docs/Multithreading for more information. It is the
  caller's responsibility to create a new stack chunk for the new thread if
  required. Note that BASIC's variable storage model is fundamentally
  unsuited for multithreading.
Admin:
  This was developed in 2001 and was not committed at the time due to lack
  of testing and peer review. It is now being added as a branch from a
  contemporary trunk Wimp. Hopefully somebody will be interested enough to
  merge the branch into a recent version!

Version 4.66, 4.77.2.1. Tagged as 'Wimp-4_66-4_77_2_1'
@
text
@a763 5
 [ Threads
        MOVS    R2, R0                  ; save this for thread behaviour below
        BEQ     %FT02                   ; threads don't want the slot mapped out
 ]

a772 3
 [ Threads
02
 ]
a786 4
 [ Threads
        TEQ     R2, #0
        BEQ     %f04                    ; don't reset handlers for child
 ]
a793 30

 [ Threads
04
        TEQ     R2, #0                  ; if we're starting a thread we leave now
        BNE     %f10

; copy the parent's app slot, and increment the refcount
        LDR     R14, polltaskhandle
        LDR     R14, [wsptr, R14]
        LDR     R14, [R14, #task_slotptr]
        CMP     R14, #nullptr
        BEQ     %f05                    ; if there is no app slot, then we don't get one either!
        LDR     R0, [R14, #app_refcnt]
        ADD     R0, R0, #1
        STR     R0, [R14, #app_refcnt]
        Debug   thread, "Increasing refcnt,(thread),(parent) = ", R0, #taskhandle,#polltaskhandle

05
        LDR     R0, taskhandle
        LDR     R0, [wsptr, R0]
        STR     R14, [R0, #task_slotptr]

        ADR     R0, thread_title        ; in case the thread tries to output to screen,
        SWI     XWimp_CommandWindow     ; also leaves command window flags set correctly

        B       ExitPoll_tothread
thread_title = "Thread", 0
        ALIGN
10
 ]
d913 2
a914 7
;        Debuga  task1,"Error reported to Wimp: "
;        CLI     "HostVdu"
;        ADRL    R0,errorbuffer+8        ; skip saved PC & error number
;        SWI     XOS_Write0
;        SWI     XOS_NewLine
;        CLI     "TubeVdu"

d916 3
a918 1
        DebugS  task1,"Error reported to Wimp: ",R0
a1013 9
 [ Threads
ExitPoll_tothread
        Debug   task1,"Exit to thread:",#taskhandle
        Debug   thread,"Exit to thread,(old):",#taskhandle,#polltaskhandle
        MOV     R14,#-3
        STR     R14,sender              ; don't call postfilters
        B       ExitPoll
 ]

a1195 1

d1234 1
a1234 1
        Debug   task1,"Setting callback handler to ",#taskhandle
d1275 2
a1276 2
        Debug   task,"Flags on entry to callbackpoll,:",R0

a1291 15
 [ Threads
        LDR     R2, sender              ; If we're starting a new thread, load the
        CMP     R2, #-3                 ; parent's registers, with r0 = -1
        BNE     %f10
        LDR     R14,taskSP
        LDR     R14,[R14,#-4]
        Debug   thread,"Handles: taskhandle, stacked", #taskhandle, R14
        LDR     R4,[wsptr,R14]
        LDR     R0,[R4,#task_registers+15*4]
        Debug   thread,"Return address is: ", R0
        MOV     R0,#-1
        STR     R0,[R4,#task_registers+4*0]

10
 ]
a1586 4

        MOV     R0, #6
        MOV     R1, #0
        SWI     XOS_UpCall
d2092 2
a2093 2
        MOVS    R4,R6
        CMPNE   R4,#nullptr
a2094 3
        LDRB    R14,[R4]
        TEQ     R14,#"\\"
        ADDEQ   R4,R4,#1
d2259 3
a2261 4
        CMPNE   R2,#nullptr
        ADREQL  R0,errorprefix1
        BICEQ   R1,R1,#erf_omiterror
        ADRNEL  R0,errorprefix2         ; -> suitable token
d2268 2
a2269 2
        CMPNE   R4,#nullptr
        BEQ     %FT01
d2371 4
a2374 5
        CMP     R2,#0
        CMPNE   R2,#nullptr
        ADREQ   R2,noappname
        MOVEQ   R1,#11
        BEQ     oldapploop
@


4.16
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d2092 3
a2094 2
        MOVS    R4,R6
        ADRMI   R4,noprogapp
@


4.15
log
@  Various little changes.
Detail:
  * New STB Sprites, Templates and Tools files imported, based upon the
    Lazarus UI rather than the old STB UI.
  * STB build now includes WIMPSymbol.
  * No longer attempts to use WIMPSymbol font in UTF8 builds which didn't
    register the font in ResourceFS.
  * Simplified Resources directories by assigning only a single pair of
    Messages files to each locale, rather than for each UI directory within
    each locale directory. The only code change required is to make the Wimp
    error box always use the "Continue" token for NC/STB builds, rather than
    using one of "OK" and "Continue", as with desktop builds.
Admin:
  Not tested.

Version 4.42. Tagged as 'Wimp-4_42'
@
text
@d805 7
a811 1
        STR     R14,[R5,#task_registers+4*15]
d1201 1
d1204 6
d1213 1
d1215 6
d1223 1
d1225 4
d1253 1
d1255 3
d1292 4
d1297 2
d1338 1
a1338 1
        Push    "R0-R3,LR"
d1351 2
a1352 2
        STRVS   R0,[sp]
        Pull    "R0-R3,PC",VS
d1381 1
a1381 1
        Pull    "R0-R3,PC",,^                   ; preserve flags
d1391 1
a1391 1
        MOV     R3,PC                   ; save flags
d1395 1
a1395 1
        TEQP    R3,#0                   ; restore error state
d2342 3
a2344 4
 [ STB
oklabel         DCB     "Continue",0
 |
oklabel         DCB     "OK",0,0
@


4.14
log
@Increased size of indirected data buffer for error template from 256 to 1024.

Version 4.19. Tagged as 'Wimp-4_19'
@
text
@d2307 3
d2311 1
@


4.13
log
@Removed the code that restores the original pointer shape when
leaving an error box (NCErrorBox conditional in Wimp07:finisherror).
This option is no longer necessary now that the Wimp_Extend support
ensures that the pointer appears and disappears as the user expects.

Version 4.17. Tagged as 'Wimp-4_17'
@
text
@d1738 1
a1738 1
        SWI XIconHigh_Stop 
d2240 1
a2240 1
        ADR     R2,errortitle           ; -> title string for dialogue box
d2243 1
a2243 1
        ADR     R2,errortitle
@


4.12
log
@Another bugfix to and a new feature of NC error box code:
* If pointer was hidden-until-next-mouse-move, the act of confining the mouse
  to the error box window no longer causes it to be redisplayed.
* In error boxes, the pointer and the IconHigh highlight are now initially
  positioned over the rightmost (default) button. There is one exception to
  this rule: when "Next task" is clicked in a Watchdog window, the pointer
  stays over the "Next task" button.

Version 4.13. Tagged as 'Wimp-4_13'
@
text
@d1738 3
a1740 5
        SWI     XIconHigh_Stop
        ADRL    R14, ptrshlflag
        MOV     R0, #106
        LDR     R1, [R14]
        SWI     XOS_Byte                ; Restore pointer to the way it was after Hourglass_Smash
@


4.11
log
@* Disabled checking of both mouse button transitions in error boxes in NC
  builds: now behaves like desktop builds (only detects button-down events).
* When mouse pointer is hidden following Wimp_Extend 12, changes of mouse
  button state will no longer cause the pointer to be reinstated.

Version 4.12. Tagged as 'Wimp-4_12'
@
text
@d1888 6
d1919 5
d2857 41
a2897 1
        MOV     R0, #106
@


4.10
log
@Optimisation to new WimpSymbol substitution code: in icons containing fonts
  other than the desktop font, the substitution table is only calculated
  when a symbol character is encountered.
Embryonic cut-n-paste support introduced (currently in desktop builds only):
  * workspace is allocated and initialised;
  * extended Wimp_GetCaretPosition implemented;
  * pushfontstring adapted to allow insertion of arbitrary control sequences in
    font strings (to allow selected text to be plotted in inverted colours).
Inverted, unfilled text icons now work properly again in <256-colour modes.
Reworked NC error box code: see Doc.IconHigh.

Version 4.11. Tagged as 'Wimp-4_11'
@
text
@d1710 1
a1710 1
        [ NCErrorBox
@


4.9
log
@Adapted assembly process so that the choice of Options file (previously based
purely on the "System" variable) can be overridden by passing "OPTIONS=foo" as
an argument to either MkRom, or to amu/amu_machine directly, or indirectly,
by specifying it in the components file for a build. To accomplish this, it
was necessary to switch from using aasm to objasm - hence the large number of
source files affected in this commit.

Version 4.09. Tagged as 'Wimp-4_09'
@
text
@a1478 11
        [ PreservePointerOnError
        Push	"R0-R2"
        MOV     R0, #106                ; Select pointer/activate mouse
        MOV     R1, #0			; Turn off mouse pointer,
        SWI     XOS_Byte		; read current state,
	ADRL	R14, ptrshlflag
	STR	R1, [R14]		; save it
	SWI	XOS_Byte		; and restore it again!
	Pull	"R0-R2"
        ]

d1735 8
a1742 14
    [ NCErrorBox
      [ PreservePointerOnError
	Push    "r0-r2"
	; Restore pointer. JRC 25 Jul 1997
	ADRL	R1, ptrshlflag
	LDR	R1, [R1]
	TST	R1, #&07		; if pointer was off then
	Push	R1
        MOVEQ   R0, #0                  ; turn off IconHigh
        SWIEQ   XIconHigh_Stop
        Pull	R1

	MOV     R0, #106                ; Select pointer/activate mouse
	SWI     XOS_Byte
a1743 3
      |
        MOV     R0, #0                  ; turn off IconHigh
        SWI     XIconHigh_Stop
a1744 1
    ]
d2191 3
a2193 2
      [ true
        ADRL    R2,ptr_default2         ; ADRL doesn't reach if debugging enabled!
d2195 1
a2195 1
        ADRL    R2,ptr_default
a2196 1
        MOV     R3,#1
a2201 3
        MOV     R0,#&6A                 ; set/read pointer shape no
        MOV     R1,#1
        SWI     XOS_Byte                ; R1 := actual shape number
a2652 1
      [ debugerr
a2653 1
      ]
d2845 12
a2856 13
    [ NCErrorBox
      [ PreservePointerOnError
	ADRL	R14, ptrshlflag
	LDR	R1, [R14]		; Get current pointer state.
	TST	R1, #&07		; If pointer was off then
        MOVEQ   R0, #2                  ; turn on IconHigh, use single-tasking mode
        SWIEQ   XIconHigh_Start
        MOV	R0, #106		; Enable pointer
        MOV     R1, #1
        SWI	XOS_Byte
      |
        MOV     R0, #2                  ; turn on IconHigh, use single-tasking mode
        SWI     XIconHigh_Start
a2857 1
    ]
@


4.8
log
@UTF-8 support from previous version switched in; additional alphabet-
conditional support added as follows:
* Correctly converts character index returned from Font_FindCaret into byte
  index into raw string.
* Left-arrow, right-arrow, delete-left and delete-right now act as far as
  the next character boundary, instead of to the next byte.
* Menu item text justification works again (it relies on overwriting spaces
  with hard space characters, which are two-byte characters in UTF-8).
* General key handling code has been rewritten. The Wimp now has three
  internal key input buffers - one each for taking keyboard-generated,
  task-generated, and function-key-generated strings. Each input buffer is
  processed in chunks of one character, rather than one byte; malformed
  UTF-8 characters are rejected, so tasks don't have to worry about them
  (simplifying their character-handling code). There is also a key output
  buffer, to ensure that (UTF-8) sequences of Key_Pressed events are not
  broken up.
* As a result of the above, multiple calls to Wimp_ProcessKey are now
  possible between calls to Wimp_Poll. Previously, this resulted in bytes
  getting jumbled up - making it useless for input of UTF-8 characters.
* Multi-byte characters are inserted into writeable icons in one go, so you
  don't see a brief flicker of the "malformed character" symbol while the
  initial bytes are being inserted.
* Multi-byte characters that don't entirely fit in a writeable icon buffer
  are not inserted at all.
* A new validation string command ("U") can limit the contents of a
  writeable by number of characters, instead of bytes. This will hide the
  character sizes from the user interface.
* Allowable characters (validation string command "A") now works on Unicode
  characters and character ranges.
* Various other minor bugs are fixed (Wimp_ProcessKey 13 can activate a
  writeable menu item, Shift-arrow keys are always consistent in firing off
  Key_Pressed events, etc.)
* Password icons supported: one symbol is displayed for each character
  (instead of for each byte); the display character (validation string
  command "D") can be any UTF-8 character; correctly displays the caret
  after set-caret-by-index calls, even though characters in the processed
  string are different width to those in the raw string, in password icons.

Other changes:
* The border around NC-style error boxes is resized when the error window
  is grown or shrunk.
* Messages, CmdHelp and Template files made consistent across resource
  directories, including support for all Ursula features.
* ShrinkableAreas turned back on in System=RCA builds.
* User interface features of desktop OS builds standardised.

Version 4.06. Tagged as 'Wimp-4_06'
@
text
@d1284 1
a1284 1
deactivate_hourglass_on_wrchv ENTRY "R0-R2"
d2250 1
a2250 1
        TEQ     R14,#"\"
d2661 1
a2661 1
        LDMIA   R2, {x0, y0, x1, y1}            ;\
@


4.7
log
@Modify behaviour of pointer on Wimp errors for NCs.

Version 4.02. Tagged as 'Wimp-4_02'
@
text
@d1709 1
a1709 1
	;Debug	temp, "int_get_pointer_info: w, i, oldbuttons, newbuttons:", R3, R4, R5, R2
d1721 1
a1721 1
        [ BuildForNC
d1739 1
a1739 1
	Debug	temp, "finishing error ", r4
d1746 1
a1746 1
    [ BuildForNC
d1809 1
a1809 1
        Debug   temp,"ReportError returns R1",R1
d2726 13
d2871 1
a2871 1
    [ BuildForNC
@


4.6
log
@Spinner branch merged.
Changed to use srccommit.
All conditionals on "Version" removed.

Version 4.01. Tagged as 'Wimp-4_01'
@
text
@a2862 1
	Push	R1
d2865 2
a2866 2
        Pull	R1
        MOV	R0, #106		; Put pointer back to its stored state
@


4.5
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d828 1
a828 1
        
d1176 1
a1176 1
        
d1422 1
a1422 1
;Rough outline (not gospel!) JRC 24 Jul 1997           ; NB IconHigh stuff not in this branch (BJGA 02 March 1998)
a1457 2


d1473 1
a1473 1
errtws_flags            #       4  ;  +24  
d1479 11
d1662 1
a1662 1
        
d1667 1
a1667 1
        
d1672 1
a1672 1
        
d1679 1
a1679 1
        
d1681 1
a1681 1
        
d1686 1
a1686 1
        
d1696 1
a1696 1
        
d1709 1
d1721 3
d1725 1
d1739 1
d1745 22
a1773 1
;
a1784 2
        Debug   err,"ReportError returns R1",R1

d1809 1
a1809 1

d2441 1
a2441 1
        
d2515 1
a2515 1
        
d2650 1
a2650 1
        
d2655 1
a2655 1
        
d2659 1
a2659 1
        STR     R1, linecount                   ; activate line counting        
d2675 1
a2675 1
        
d2689 1
a2689 1
        
d2692 1
a2692 1
        
d2696 1
a2696 1
        
d2711 1
a2711 1
        
d2721 1
a2721 1
        
d2858 17
@


4.4
log
@Printer upcall changes from Spiner merged
@
text
@d232 3
a457 2
        LDR     R4,sender               ; worked out earlier
;
d463 3
a465 1
        CMP     R1,#ROMstart            ; don't splat the ROM!
d813 2
a814 1
        B       ExitPoll                ; swap tasks, and end up at 'runthetask'
d828 1
d981 3
d1008 6
d1020 1
d1094 9
a1102 2
	LFM	F0,4,[R4,#fp_reg0]      ; (only gets here if active previously)
	LFM	F4,4,[R4,#fp_reg4]
d1117 33
d1152 1
d1161 23
d1269 28
d1326 9
a1334 2
    	SFM	F0,4,[R2,#fp_reg0]
	SFM	F4,4,[R2,#fp_reg4]
d1374 1
a1374 1
        CMPGE   R2,#0                   ; -1 => this is a Wimp_StartTask
d1415 3
a1417 1
;         R5 --> comma separated additional button list, or 0 for none (for n; Exit:   R1 = 1 ==> OK box was selected
d1422 38
d1467 11
d1494 3
a1496 3
        STR     R4,tempworkspace                ; R4 gets horribly corrupted
                                                ; but is required for 3.21
        STR     R5,tempworkspace+4              ; ditto!
d1616 11
d1646 47
a1692 24
        LDR     R14,[sp,#0*4]           ; work out which of OK / Cancel to select

;        MOV R4,#0
;        STR R14,[R4,#0]
        Debug   err,"Error flags=",R14

        TST     R14,#erf_htcancel
        MOVEQ   R4,#1                   ; OK icon handle
        MOVNE   R4,#4                   ; Cancel icon handle

        TEQ     R1,#&1B                 ; if escape,
        EOREQ   R4,R4,#5                ; select opposite one
        TST     R14,#erf_okbox          ; if no OK box,
        MOVEQ   R4,#4                   ; select cancel
        TST     R14,#erf_cancelbox      ; if no cancel box,
        MOVEQ   R4,#1                   ; select OK
        TST     R14,#erf_okbox:OR:erf_cancelbox
        BNE     finisherror
        TST     R14,#erf_newtype
        BEQ     finisherror
        LDR     R4,tempworkspace+12              ; first extra button
        SUB     R4,R4,#1
        TEQ     R1,#&1b
        SUBEQ   R4,R4,#1
a1702 2
        TEQ     R4,#1                   ; icon 1 = 'OK' box
        TEQNE   R4,#4                   ; icon 4 = 'Cancel' box
d1704 3
a1706 5
        TEQNE   R4,#6                   ; describe button
        TEQNE   R4,#7
        TEQNE   R4,#8
        TEQNE   R4,#9
        TEQNE   R4,#10
d1708 2
a1728 1
;
d1732 3
d1745 1
a1745 2
;        RSBGT   R1,R1,#5
        LDRGT   R2,tempworkspace+12
d1755 1
a1755 1
        LDR     R3,tempworkspace+4
d1762 1
a1762 1
        ADR     R3,tempworkspace
d1781 1
a1781 1
        LDR     R1,watchdogerrtxt+216
d1784 1
a1784 1
        LDR     R6,watchdogerrtxt+220
d1787 15
a1801 1
        STR     R1,watchdogerrtxt+216
d1804 1
a1804 1
        LDR     R1,watchdogerrtxt+228
d1806 2
a1807 2
        BNE     %FT05                   ; it asked for cancel, assume quit
        MOV     R1,#99
d1809 1
d1855 5
a1859 5
	[	outlinefont
	;Restore the current font and font colours that were in force on
	;	entry, if they've been changed. This must be done *before*
	;	 making the service call, so the code in ExitWimp is too late.
	Push	"r0-r3"
d1865 4
a1868 4
        LDRNE	R1, currentbg
        LDRNE	R2, currentfg
        LDRNE	R3, currentoffset
        SWINE	XFont_SetFontColours
d1872 1
a1872 1
	Pull	"r0-r3"
d1875 5
d1893 2
a1894 2
        LDR     R1,watchdogerrtxt+216
        LDR     R4,watchdogerrtxt+220
d1897 4
a1900 4
        STR     R1,watchdogerrtxt+216
	LDR	R1,tempworkspace+16	; Get back buttons
	STR	R1,tempworkspace+4
        ADRL    R1,watchdogerrtxt+224
d1908 2
d1993 1
a1993 1
        STR     R1,watchdogerrtxt+216   ; make sure no label swapping
d2020 1
a2020 1
        ADRL    R1,watchdogerrtxt+224
d2028 2
a2029 2
        STR     R2,watchdogerrtxt+220
        STR     R1,watchdogerrtxt+216   ; make life easier later
d2038 1
a2038 1
        MOV     R3,#216
d2042 10
a2051 6
	LDR	R1,tempworkspace+4	; store buttons away
	STR	R1,tempworkspace+16	; in case we need them again
					; when user hits describe
	TST	R5,#erf_newtype
	MOV	R5,#erf_describe:OR:erf_cancelbox:OR:erf_okbox
        ORR     R5,R5,#erf_newtype      ; continue rather than ok
d2054 4
a2057 4
	MOVEQ	R7,#0			; make sure no sprite if original error wasn't new type
        STREQ   R6,tempworkspace
        STR     R6,tempworkspace+4      ; no custom buttons
        LDR     R6,watchdogerrtxt+232   ; app name
d2083 5
a2087 5
	[	outlinefont
	;Restore the current font and font colours that were in force on
	;	entry, if they've been changed. This must be done *before*
	;	making the service call, so the code in ExitWimp is too late.
	Push	"r0-r3"
d2093 4
a2096 4
        LDRNE	R1, currentbg
        LDRNE	R2, currentfg
        LDRNE	R3, currentoffset
        SWINE	XFont_SetFontColours
d2100 1
a2100 1
	Pull	"r0-r3"
d2171 3
d2178 1
a2178 1
      [ debug
d2226 2
d2266 1
a2266 1
        LDR     R2,tempworkspace
d2291 1
a2291 1
              [ debug
d2339 16
d2365 1
d2373 1
d2382 1
a2382 1
        LDR     R14,tempworkspace+4             ; button list
d2388 1
a2388 3
        ORREQ   userblk,userblk,#erf_okbox
        TST     userblk,#erf_okbox
        ORREQ   userblk,userblk,#erf_htcancel   ; highlight one of them
a2391 5
        LDR     R14,[handle,#w_icons]
        LDR     R14,[R14,#i_flags+i_size*1]
        BIC     R14,R14,#is_inverted    ; ensure not inverted initially
        ORREQ   R14,R14,#is_deleted
        BICNE   R14,R14,#is_deleted
a2393 5
        TST     userblk,#erf_htcancel
        LDRNE   R0,unhighlighted_colour ; values read from icons initially
        LDREQ   R0,highlighted_colour   ; values read from icons initially
        BIC     R14,R14,#if_bcol:OR:if_fcol
        ORR     R14,R14,R0
d2395 2
a2400 5
        LDR     R14,[handle,#w_icons]
        LDR     R14,[R14,#i_flags+i_size*4]
        BIC     R14,R14,#is_inverted    ; ensure not inverted initially
        ORREQ   R14,R14,#is_deleted
        BICNE   R14,R14,#is_deleted
d2403 12
a2414 7
        TST     userblk,#erf_htcancel
        LDREQ   R0,unhighlighted_colour ; values read from icons initially
        LDRNE   R0,highlighted_colour   ; values read from icons initially
        BIC     R14,R14,#if_bcol:OR:if_fcol
        ORR     R14,R14,R0
        LDR     R3,[handle,#w_icons]
        STR     R14,[R3,#i_flags+i_size*4]
a2416 5
        LDR     R14,[handle,#w_icons]
        LDR     R14,[R14,#i_flags+i_size*6]
        BIC     R14,R14,#is_inverted    ; ensure not inverted initially
        ORREQ   R14,R14,#is_deleted
        BICNE   R14,R14,#is_deleted
d2419 4
a2422 2
        LDR     R3,[handle,#w_icons]
        STR     R14,[R3,#i_flags+i_size*6]
d2427 1
a2427 1
        LDR     R2,tempworkspace+4      ; comma separated list of buttons
d2443 3
a2445 2
        MOV     R1,#errorbuttonsize-1
        Push    "R3"
d2447 11
a2457 7
        LDRB    R0,[R2],#1
        CMP     R0,#","
        STREQB  R14,[R3],#1
        STRNEB  R0,[R3],#1
        Push    "R3",EQ                 ; R3 now points to next button
        TST     R0,#224
        SUBNES  R1,R1,#1
d2459 8
a2466 1
        STRB    R14,[R3]
a2475 10

; make sure correct size
        LDR     R14,[handle,#w_icons]
        LDR     R0,[R14,#i_bby0+i_size*6]               ; use 'Describe' as template
        STR     R0,[R2,#i_bby0]
        LDR     R0,[R14,#i_bby1+i_size*6]
        STR     R0,[R2,#i_bby1]
        LDR     R0,[R14,#i_data+4+i_size*6]
        STR     R0,[R2,#i_data+4]                       ; validation string

d2480 9
a2488 1
        STR     R3,tempworkspace+12       ; number of extra buttons (+7)
a2499 5
; stack now contains list:    (-1,[7],[8],[9],[10],[6],[4],[1],-1)
; dependent on whether icon number is required
; if number >4 must make some invisible, then position the rest

; unused icons need to be made invisible
d2503 4
d2508 1
a2508 1
        CMP     R3,#10
d2512 1
a2512 1
        CMP     R3,#11
d2525 1
a2525 1
        CMP     R0,#5
d2528 1
a2528 1
        SUB     R0,R0,#4
d2538 4
a2541 1
; stack now has at most 4 icons, R2-8 -> icon to appear on far right.
a2546 2
        TEQ     R1,#4
        TEQNE   R1,#1
d2549 24
a2572 10
        BEQ     alignanddisplayicon
; the first icon is a 'custom' button
        ADD     R3,R14,R1, LSL #i_shift

        LDR     R4,[R14,#i_bby0+i_size*1]               ; use 'OK' as template
        STR     R4,[R3,#i_bby0]
        LDR     R4,[R14,#i_bby1+i_size*1]
        STR     R4,[R3,#i_bby1]
        LDR     R4,[R14,#i_data+4+i_size*1]
        STR     R4,[R3,#i_data+4]                       ; validation string
d2575 1
a2575 9
; R1 is icon number, R14 is icon base, R0 is rhs of icon
        ADD     R3,R14,R1, LSL #i_shift
        LDR     R4,[R3,#i_flags]
        BIC     R4,R4,#is_deleted :OR: is_inverted          ; not initially inverted
        STR     R4,[R3,#i_flags]

        LDR     R4,[R3,#i_bbx0]
        LDR     R5,[R3,#i_bbx1]
        SUB     R4,R5,R4
d2578 4
a2581 2
	Push	"R0,R1,R2,R4,R14"
	LDR	R1,[R3,#i_flags]
d2583 6
a2588 4
	BL	textwidth
	ADD	R5,R4,#36			; allow 18 OS-units each side, in case it's a default button
	Pull	"R0,R1,R2,R4,R14"
	max	R4,R5
d2598 1
a2598 1
        BNE     alignanddisplayicon
d2609 54
a2662 1
        MOVGT   R0,#0
d2664 27
a2690 12
        LDR     R1,[handle,#w_wax0]
        ADD     R1,R1,R0
        STR     R1,[handle,#w_wax0]

        LDR     R1,[handle,#w_icons]
        ADD     R1,R1,#i_size * 5               ; divider sprite
        STR     R0,[R1,#i_bbx0]
        LDR     R0,[handle,#w_wax1]
        LDR     R14,[handle,#w_wax0]
        SUB     R0,R0,r14
        ADD     R0,R0,#8
        STR     R0,[R1,#i_bbx1]
d2750 2
d2776 1
a2776 1
        MOV     x0,x0,LSR #1            ; half screen widht in OS units
d2797 1
d2799 3
d2818 3
@


4.4.2.1
log
@Hourglass depth now incremented by 1 between calls to Wimp_Poll; effect is
to automatically display hourglass whenever applications hog the CPU,
irrespective of whether they already display the hourglass themselves or not.
Hourglass is automatically smashed before any Command Windows are displayed
so that output-generating single-tasking programs are not forced to show the
hourglass due to the behaviour described above.
@
text
@a823 13
      [ Version >= 394 :LAND: AutoHourglass
        MOV	R0,PC                   ; \
        AND	R0,R0,#3		;  > just in case we're not in USR mode...
        EOR	R0,R0,#SVC_mode         ; /
        SWI	XOS_EnterOS		; because we need a stack
        Push	"R0"
        SWI	XHourglass_Off
        CLRV
        Pull	"R0"
        Debug	autohg,"Hourglass_Off at Wimp_StartTask child task entry point"
        TEQP	R0,PC                   ; return to original processor mode
        NOP
      ]
a1104 13
      [ Version >= 394 :LAND: AutoHourglass
        Push	"R0"
        MOV	R0,#hourglass_delay
        SWI	XHourglass_Start
        CLRV
        Pull	"R0"
      [ debugautohg
	Push	"handle"
	LDR	handle,taskhandle
        Debug	autohg,"Hourglass_On  at Wimp_Poll end, taskhandle =",handle
        Pull	"handle"
      ]
      ]
@


4.4.2.2
log
@Worked around bug in AAsm that caused FP register saving to fail
@
text
@a1091 1
       [ false
a1093 6
       |
        ; AAsm assembles the above as post-indexed not pre-indexed.
        ; Do it manually (bluch).
        DCD     &ED940200 :OR: (fp_reg0:SHR:2)
        DCD     &ED944200 :OR: (fp_reg4:SHR:2)
       ]
a1244 1
       [ false
a1246 6
       |
        ; AAsm assembles the above as post-indexed not pre-indexed.
        ; Do it manually (bluch).
        DCD     &ED820200 :OR: (fp_reg0:SHR:2)
        DCD     &ED824200 :OR: (fp_reg4:SHR:2)
       ]
@


4.4.2.3
log
@Stopped cursor jumping to top left when a task was killed outside the
desktop (eg *RMKill ShareFS at the F12 prompt).
@
text
@a988 3
      [ debug
        ALIGN
      ]
@


4.4.2.4
log
@Made the Wimp always call the postfilter when returning from Wimp_StartTask,
rather than only if the child didn't Wimp_Poll. Also ensured that nothing
untowards happens if the filter tries to claim this apparent "null event".
@
text
@a1117 32
      [ StartTaskPostFilter
        LDR     R14,sender              ; Are we returning from Wimp_StartTask?
        CMP     R14,#-1
        BNE     %FT02

; We're returning from Wimp_StartTask and
; R0 = task handle of child (or 0). Wimps before 3.96
; would not call the post-filter in this case, but would
; call it if Wimp_StartTask returned 0 (so the filter
; would think a null event was happening.) Now, the
; Toolbox (and probably other filters) relies on the
; post filter to monitor the current task. If the postfilter
; doesn't get called here then there is no way of telling
; that this task has become active. So, we now call the filter
; with a null event, and ignore any attempt to claim it. (In
; the past the filter was able to claim the "null" event if
; Wimp_StartTask returned 0, causing instant death.
; This is the problem that hit Toolbox 1.33).
;
; Hopefully this shouldn't cause any problems, as filters
; will have had to be able to deal with the dummy "null"
; event for at least some Wimp_StartTask calls already.

        Push    "R0,R1"
        MOV     R0,#No_Reason
        MOV     R1,userblk
        CallFilter postfilter           ; call the post-poll filter (ignoring
        Pull    "R0,R1"                 ; R0 return)
        B       %FT01

02
      |
a1119 1
      ]
@


4.4.2.5
log
@Fixed problem with PostFilters getting called when doing a Wimp_StartTask
callback exit.
@
text
@d810 1
a810 1
        B       ExitPoll_tochild        ; swap tasks, and end up at 'runthetask'
d825 6
a830 6
        MOV     R0,PC                   ; \
        AND     R0,R0,#3                ;  > just in case we're not in USR mode...
        EOR     R0,R0,#SVC_mode         ; /
        SWI     XOS_EnterOS             ; because we need a stack
        Push    "R0"
        SWI     XHourglass_Off
d832 3
a834 3
        Pull    "R0"
        Debug   autohg,"Hourglass_Off at Wimp_StartTask child task entry point"
        TEQP    R0,PC                   ; return to original processor mode
a1015 6
ExitPoll_tochild
        Debug   task1,"Exit to parent:",#taskhandle
        MOV     R14,#-2
        STR     R14,sender              ; don't call postfilters
        B       ExitPoll

d1096 2
a1097 2
        LFM     F0,4,[R4,#fp_reg0]      ; (only gets here if active previously)
        LFM     F4,4,[R4,#fp_reg4]
d1119 1
a1119 1
        LDR     R14,sender
d1121 1
a1121 2
        BLT     %FT01                ; Are we starting up Wimp_StartTask?
        BNE     %FT02                ; Are we returning from Wimp_StartTask?
d1162 3
a1164 3
        Push    "R0"
        MOV     R0,#hourglass_delay
        SWI     XHourglass_Start
d1166 1
a1166 1
        Pull    "R0"
d1168 4
a1171 4
        Push    "handle"
        LDR     handle,taskhandle
        Debug   autohg,"Hourglass_On  at Wimp_Poll end, taskhandle =",handle
        Pull    "handle"
d1289 2
a1290 2
        SFM     F0,4,[R2,#fp_reg0]
        SFM     F4,4,[R2,#fp_reg4]
d1336 1
a1336 1
        CMPGE   R2,#0                   ; -1/-2 => this is a Wimp_StartTask
d1718 5
a1722 5
        [       outlinefont
        ;Restore the current font and font colours that were in force on
        ;       entry, if they've been changed. This must be done *before*
        ;        making the service call, so the code in ExitWimp is too late.
        Push    "r0-r3"
d1728 4
a1731 4
        LDRNE   R1, currentbg
        LDRNE   R2, currentfg
        LDRNE   R3, currentoffset
        SWINE   XFont_SetFontColours
d1735 1
a1735 1
        Pull    "r0-r3"
d1756 2
a1757 2
        LDR     R1,tempworkspace+16     ; Get back buttons
        STR     R1,tempworkspace+4
d1898 5
a1902 5
        LDR     R1,tempworkspace+4      ; store buttons away
        STR     R1,tempworkspace+16     ; in case we need them again
                                        ; when user hits describe
        TST     R5,#erf_newtype
        MOV     R5,#erf_describe:OR:erf_cancelbox:OR:erf_okbox
d1906 1
a1906 1
        MOVEQ   R7,#0                   ; make sure no sprite if original error wasn't new type
d1935 5
a1939 5
        [       outlinefont
        ;Restore the current font and font colours that were in force on
        ;       entry, if they've been changed. This must be done *before*
        ;       making the service call, so the code in ExitWimp is too late.
        Push    "r0-r3"
d1945 4
a1948 4
        LDRNE   R1, currentbg
        LDRNE   R2, currentfg
        LDRNE   R3, currentoffset
        SWINE   XFont_SetFontColours
d1952 1
a1952 1
        Pull    "r0-r3"
d2404 7
a2410 7
        Push    "R0,R1,R2,R4,R14"
        LDR     R1,[R3,#i_flags]
        LDR     R2,[R3,#i_data]
        BL      textwidth
        ADD     R5,R4,#36                       ; allow 18 OS-units each side, in case it's a default button
        Pull    "R0,R1,R2,R4,R14"
        max     R4,R5
@


4.4.2.6
log
@Fixed occasional lock-ups when error boxes displayed.
Added ALIGN directive before watchdog callback label.
Added option to select double-height VDU 4 modes.
Added German resources.
Added necessary options for parallel-port debugging via the PDebugM module.
@
text
@a1388 2


a1772 2
	LTORG

a2029 2
	Debug	err,"starterrorbox_draw"

a2081 2
	DebugS	err,"errortitle=",R2

a2209 1
	Debug	err,"doneappsprite"
a2377 3

	Debug	err,"alignicons"

d2413 1
a2413 4
	ADD	R2,R3,#i_data
	BL	seticonptrs
	LDR	R2,[R3,#i_data]
	Debug	err,">textwidth"
a2414 1
	Debug	err,"<textwidth"
a2510 2

	Debug	err, "working out window coords"
a2555 1
	Debug	err,"int_open_window"
@


4.4.2.7
log
@Main new features in Ursula build so far
(some are also available in other builds):

* New icon highlighting scheme - hue rotated 180 degrees, photographic negative,
  darkened 25% - suits Ursula icons better.
* Release-button window tools compile-time switch turned on.
* Any "TASK" word cleared on exit from Wimp_OpenWindow, Wimp_GetWindowState,
  Wimp_ForceRedraw and Wimp_CloseDown.
* Child windows are no longer allowed to be opened inside the icon bar.
* Message_IconizeAt generation optimised, and no longer calls non-X SWIs.
* Message_IconsChanged implemented, and switched out on speed grounds.
* Wimp_ReadSysInfo 15 removed, replaced with (new) Wimp_Extend 11.
* Backwindows are now segregated from normal windows. A new category,
  foreground windows, are added, and stay above all other windows. (The error
  box template is updated to make it a foreground window.)
* ROM sprites override RAM sprites (and duplicate RAM sprites are deleted
  during the building of the sprite lookup list, preceding the first sprite
  plot after a sprite pool update).
* Wimp_ReadSysInfo 16 added, to return sprite area pointers in order of
  priority (Wimp_BaseOfSprites retains the ROM/RAM distinction).
* Error box code altered:
  + symbolic names used for offsets into tempworkspace
  + error button text buffer enlarged
  + stretched error buttons now shrink back for next use
  + int_flush_opens called at appropriate points to ensure buttons are seen to
    slab in, and to reduce flicker when redisplaying error box at a different
    width (also fixes some redraw bugs)
  + Cancel button given the R6 type border when it will be activated by Return
    (and is therefore moved to the extreme right in such cases)
  + Escape now always selects the second-right button (unless there's only one
    button!) - this also fixes a bug when there's a single user-defined button
  + keypresses in "xxx may have gone wrong" error boxes are now correctly
    interpreted - previously the buttons available in the underlying box were
    being used to determine the effect of keys
  + maximum number of buttons increased from 4 to 8, and the machine no longer
    crashes when the maximum is exceeded
  + window stretches horizontally to keep error message to 7 lines or less
* Bugfix: opening or creating a window with a minimum x visible area coordinate
  of -1 was leading to any of smearing/flickering/recursive drawing. (This was
  actually due to a failure to recognise which windows' positions had been
  updated.)
* Features merged in from spinner branch Wimp:
  + support for UpCall_MediaSearchEndMessage added
  + control-termination allowed in upcalls (used to require null-termination)
  + escape character switched to default during error box display, then
    switched back again afterwards
* GetRectangle filters are now called with (internal) window handle in R10.
* Autohourglass is deactivated whenever WrchV is invoked. (Also optimised.)
* Action button bugfixes:
  + action buttons now deselect if the pointer is dragged off and a window tool
    is the pressed before all the buttons have been released
  + action buttons now slab in following a long (autorepeating) press on a
    scroll arrow window tool
@
text
@a809 1

d824 13
a836 1
        
d1017 1
a1017 1
        Debug   task1,"Exit to child:",#taskhandle
d1168 6
a1173 3
      [ AutoHourglass
        Push    "R0-R2"
        LDR     R1, hourglass_status
d1176 2
a1177 2
        LDR     handle, taskhandle
        Debug   autohg, "Hourglass_On  at task switch: taskhandle, old status =", handle, R1
a1179 13
        TEQ     R1, #2
        SWIEQ   XHourglass_Off          ; if autohourglass is still pending or animating, turn it off
        TEQ     R1, #0
        MOVEQ   R0, #WrchV              ; get back on WrchV if necessary
        ADREQ   R1, deactivate_hourglass_on_wrchv
        BLEQ    claim
        
        MOV     R0, #hourglass_delay
        SWI     XHourglass_Start        ; turn on using special delay time
        CLRV                            ; ignore errors
        MOV     R1, #2
        STR     R1, hourglass_status    ; mark autohourglass fully active
        Pull    "R0-R2"
a1265 28
;..............................................................................

; WrchV routine to deactivate the autohourglass as soon as a character is output.
; The argument for this is that if the task is plotting something, you probably
; don't need the Wimp putting up an hourglass to let you know that the machine
; hasn't stiffed.
; Using this approach, the hourglass isn't shown, for example, while Paint is
; doing a screen grab (it doesn't Wimp_Poll, but it does plot a box on the screen).
; It also copes transparently with command windows, ShellCLI etc.

; On entry:  R12 -> workspace
;            [hourglass_status] = 1 or 2 (by definition)
;            processor is in SVC mode

      [ AutoHourglass
deactivate_hourglass_on_wrchv ENTRY "R0-R2"
        LDR     R1, hourglass_status
        Debug   autohg, "Hourglass_Off at WrchV, old status =", R1
        TEQ     R1, #2
        SWIEQ   XHourglass_Off          ; turn off hourglass if necessary
        MOV     R0, #WrchV
        ADR     R1, deactivate_hourglass_on_wrchv
        BL      release                 ; release WrchV
        MOV     R1, #0
        STR     R1, hourglass_status    ; mark fully deactivated
        EXITS                           ; pass on call (NB: nowhere to return errors to)
      ]

d1384 1
a1384 3
;         R5 --> comma separated additional button list, or 0 for none (for new type error report)
;
; Exit:   R1 = 1 ==> Continue (OK) box was selected
a1388 36
;Rough outline (not gospel!) JRC 24 Jul 1997           ; NB IconHigh stuff not in this branch (BJGA 02 March 1998)
;	Make service call ErrorStarting
;	IF	in command mode
;	THEN	report error in text
;		poll for a key press
;		return key pressed (Return/Escape)
;	ELSE	IF	closing an open error box
;		THEN	return button-click specified
;		ELSE	Create a window structure
;			Make service call WimpReportError 1
;			Switch output to screen
;			Disable file redirection
;			Enable VDU, disable Spool, printer & serial
;			Beep
;			Add the icon definitions to the window structure
;			int_open_window
;			int_redraw_window
;			int_get_rectangle
;			Smash hourglass
;			Bound pointer to window
;			Flush keyboard and mouse
;			Start IconHigh
;			DO	Read key with no time limit
;				Check mousebuttons
;			WHILE	nothing happens
;			Unbound pointer
;			int_close_window
;			Stop IconHigh
;			Make service call ErrorButtonPressed
;			Make service call ErrorEnding
;			Restore file redirection
;			Restore output to previous state
;			Make service call WimpReportError
;		FI
;	FI

a1397 11
; tempworkspace layout
                        ^       0
errtws_spritearea       #       4  ;   +0  as passed in R4 / set by service call claimant(s)
errtws_buttonlist       #       4  ;   +4  pointer to comma-separated list of buttons
errtws_iconend          #       4  ;   +8  icon handle of (rightmost == first-in-string == highest-icon-handle) extra button, + 1
errtws_describebuttons  #       4  ;  +12  comma-separated list of buttons to use when program error is Described
errtws_icondata         #       4  ;  +16  if a "may have gone wrong" window, -> start of icon data for error window, else 0
errtws_cancelstr        #       4  ;  +20  -> "Cancel"
errtws_flags            #       4  ;  +24  
errtws_mustntuse        #       4  ;  +28  corrupted by text plotting code

d1414 3
a1416 3
        STR     R4,tempworkspace+errtws_spritearea  ; R4 gets horribly corrupted
                                                    ; but is required for 3.21
        STR     R5,tempworkspace+errtws_buttonlist  ; ditto!
a1535 11

        MOV     R0, #220                ; Read current escape key so we can restore it later
        MOV     R1, #0
        MOV     R2, #255
        SWI     XOS_Byte
        STRB    r1, old_escape

        MOV     R0, #220                ; Set default escape key
        MOV     R1, #27
        MOV     R2, #0
        SWI     XOS_Byte
d1555 24
a1578 47
        LDR     R14, tempworkspace+errtws_flags  ; to work out which button the key corresponds to, we need the current flags
                                                 ; note 1: these flags will be correct for "may have gone wrong" boxes
        Debug   err,"Error flags=",R14           ; note 2: these flags have not been checked to ensure there is at least an OK button

        MOV     R4, #-1                 ; Return button not yet determined
        MOV     R5, #-1                 ; Escape button not yet determined
        MVN     R14, R14                ; makes life easier when doing comparisons
        
        TST     R14, #erf_okbox
;        CMPEQ   R4, #-1                 ; have we found both buttons yet?
;        MOVEQ   R4, R5                  ; Return -> previous Escape button
        MOVEQ   R5, #1                  ; Escape -> OK button
        
        TST     R14, #erf_cancelbox
;        CMPEQ   R4, #-1                 ; have we found both buttons yet?
        MOVEQ   R4, R5                  ; Return -> previous Escape button
        MOVEQ   R5, #4                  ; Escape -> Cancel button
        
; note, the Describe button is never selected by a keypress
        TST     R14, #erf_newtype
        BNE     %FT06
        LDR     R2, tempworkspace+errtws_buttonlist
        CMP     R2,#1
        BLT     %FT06 ; if no extra buttons, skip next section
        
        LDR     R2, tempworkspace+errtws_iconend
        
        CMP     R2, #8                  ; are there at least 1 extra buttons?
        CMPGE   R4, #-1                 ; have we found both buttons yet?
        MOVEQ   R4, R5                  ; Return -> previous Escape button
        SUBEQ   R5, R2, #1              ; Escape -> highest-numbered (rightmost) extra button
        
        CMP     R2, #9                  ; are there at least 2 extra buttons?
        CMPGE   R4, #-1                 ; have we found both buttons yet?
        MOVEQ   R4, R5                  ; Return -> previous Escape button
        SUBEQ   R5, R2, #2              ; Escape -> second highest-numbered (second rightmost) extra button
06
        TST     R14, #erf_okbox :OR: erf_cancelbox :OR: erf_htcancel
        EOREQ   R4, R4, R5              ; if all three flags were set, the meanings of Return and Escape are reversed
        EOREQ   R5, R4, R5
        EOREQ   R4, R4, R5
        
        CMP     R5, #-1                 ; if no Escape button has been found, an OK/Continue button will have been added
        MOVEQ   R5, #1
        CMP     R4, #-1                 ; if no Return button has been found, there is only one button, so act as for Escape
        TEQNE   R1, #&1B                ; was Escape pressed?
        MOVEQ   R4, R5                  ; R4 now holds selected icon number
d1589 2
d1592 5
a1596 3
        SUB     R14, R4, #6             ; Describe button is handle 6, additional buttons are 7 to 6+maxno_error_buttons
        CMP     R14, #maxno_error_buttons
        CMPLS   R14, R14                ; set Z if in range
a1597 2
        TEQNE   R4,#1                   ; icon 1 = 'OK' box
        TEQNE   R4,#4                   ; icon 4 = 'Cancel' box
d1617 1
a1620 3
        [ ChildWindows
        BL      int_flush_opens         ; this is necessary to avoid block-copying if the error box
        ]                               ; is subsequently displayed at a different size
d1631 2
a1632 1
        LDRGT   R2,tempworkspace+errtws_iconend
d1642 1
a1642 1
        LDR     R3,tempworkspace+errtws_buttonlist
d1649 1
a1649 1
        ADR     R3,tempworkspace+errtws_spritearea ; also updates errtws_buttonlist
d1668 1
a1668 1
        LDR     R1,tempworkspace+errtws_icondata
d1671 1
a1671 1
        LDR     R6,tempworkspace+errtws_cancelstr
d1674 1
a1674 1
        STR     R1,tempworkspace+errtws_icondata
d1677 1
a1677 1
        LDR     R1,progerrsaveblk + 4*1
d1679 2
a1680 2
        BNE     %FT05                   ; it asked for a cancel button, assume it will quit anyway
        MOV     R1,#99                  ; flag that control should be passed to exit handler instead
a1746 5
        MOV     R0, #220                ; restore the old escape key
        LDRB    R1, old_escape
        MOV     R2, #0
        SWI     XOS_Byte

d1760 2
a1761 2
        LDR     R1,tempworkspace+errtws_icondata
        LDR     R4,tempworkspace+errtws_cancelstr
d1764 4
a1767 4
        STR     R1,tempworkspace+errtws_icondata
        LDR     R1,tempworkspace+errtws_describebuttons  ; Get back buttons
        STR     R1,tempworkspace+errtws_buttonlist
        ADRL    R1,progerrsaveblk
d1860 1
a1860 1
        STR     R1,tempworkspace+errtws_icondata  ; make sure no label swapping
d1887 1
a1887 1
        ADRL    R1,progerrsaveblk
d1895 2
a1896 2
        STR     R2,tempworkspace+errtws_cancelstr
        STR     R1,tempworkspace+errtws_icondata  ; make life easier later
d1905 1
a1905 1
        MOV     R3,#?watchdogerrtxt
d1909 3
a1911 3
        LDR     R1,tempworkspace+errtws_buttonlist        ; store buttons away
        STR     R1,tempworkspace+errtws_describebuttons   ; in case we need them again
                                                          ; when user hits describe
d1914 1
a1914 1
        ORR     R5,R5,#erf_newtype                        ; continue rather than ok
d1917 4
a1920 4
        MOVEQ   R7,#0                                     ; make sure no sprite if original error wasn't new type
        STREQ   R6,tempworkspace+errtws_spritearea
        STR     R6,tempworkspace+errtws_buttonlist        ; no custom buttons
        LDR     R6,progerrsaveblk + 4*2                   ; app name
a2035 1
        STR     R5, tempworkspace+errtws_flags ; for later use by pollit
d2128 1
a2128 1
        LDR     R2,tempworkspace+errtws_spritearea
a2200 16
      [ SpritePriority
        Push    "R2"
        CMP     R1, #1                  ; try any user area before either Wimp area
        SETPSR  V_bit, R0, EQ           ; SETV will *not* do, it corrupts Z
        MOVNE   R0, #256+24             ; attempt to select sprite
        SWINE   XOS_SpriteOp
        MOVVS   R0, #256+24
        LDRVS   R1, baseofhisprites
        LDRVS   R2, [SP]
        SWIVS   XOS_SpriteOp            ; not there? try again within high-priority area
        MOVVS   R0, #256+24
        LDRVS   R1, baseoflosprites
        LDRVS   R2, [SP]
        SWIVS   XOS_SpriteOp            ; not there? try again within low-priority area
        Pull    "R2"                    ; sprite op can stuff R2
      |
a2210 1
      ]
d2227 1
a2227 1
        LDR     R14,tempworkspace+errtws_buttonlist
d2233 3
a2235 1
        ORREQ   userblk,userblk,#erf_okbox      ; ensure there is at least an OK
d2239 5
d2246 5
a2251 2
        LDR     R14,[R0,#i_flags+i_size*1]
        ORR     R14,R14,#is_deleted     ; will be undeleted later if necessary
d2256 5
d2263 7
a2269 12
        LDR     R0,[handle,#w_icons]
        LDR     R14,[R0,#i_flags+i_size*4]
        ORR     R14,R14,#is_deleted     ; will be undeleted later if necessary
        STR     R14,[R0,#i_flags+i_size*4]
        
        AND     R0, userblk, #erf_okbox :OR: erf_cancelbox :OR: erf_htcancel
        TEQ     R0, #erf_okbox :OR: erf_cancelbox :OR: erf_htcancel
; in this case, we must swap over the position of the OK/Cancel buttons to reflect the effect of keypresses
        MOVEQ   R0, #1
        STREQ   R0, [sp]
        MOVEQ   R0, #4
        STREQ   R0, [sp, #4]
d2272 5
d2279 2
a2280 4
        LDR     R0,[handle,#w_icons]
        LDR     R14,[R0,#i_flags+i_size*6]
        ORR     R14,R14,#is_deleted     ; will be undeleted later if necessary
        STR     R14,[R0,#i_flags+i_size*6]
d2285 1
a2285 1
        LDR     R2,tempworkspace+errtws_buttonlist
d2301 2
a2302 3
        MOV     R1,#errorbuttonsize
        MOV     R4,#maxno_error_buttons   ; this is the maximum number of additional buttons we can have
        Push    "R3"                      ; the first button is always at the start of the string
d2304 7
a2310 7
        SUBS    R1,R1,#1                  ; run out of buffer space? (one byte required for terminator)
        LDRNEB  R0,[R2],#1                ; get character from source
        TSTNE   R0,#224                   ; is it a control character?
        STREQB  R14,[R3]                  ; null-terminate the copy and finish
        BEQ     %FT06
        CMP     R0,#","                   ; is it a comma?
        STRNEB  R0,[R3],#1                ; no:  copy character and loop
d2312 1
a2312 12
        STRB    R14,[R3],#1               ; yes: copy a NULL
        SUBS    R4,R4,#1                  ;      decrement buttons counter
        Push    "R3",NE                   ;      unless we've got all the buttons we can, push the button address and loop
        BNE     setupdynamicsloop
06
        [ debugerr
        Push    "R0-R8"
        ADD     R0, sp, #9*4
        LDMIA   R0,{R0-R8}
        Debug   err, "setupdynamicsloop: stack contains",R0,R1,R2,R3,R4,R5,R6,R7,R8
        Pull    "R0-R8"
        ]
d2322 10
d2336 1
a2336 9
        STR     R3,tempworkspace+errtws_iconend  ; number of extra buttons (+7)
        
        [ debugerr
        Push    "R0-R8"
        ADD     R0, sp, #9*4
        LDMIA   R0,{R0-R8}
        Debug   err, "setupiconsloop: stack contains",R0,R1,R2,R3,R4,R5,R6,R7,R8
        Pull    "R0-R8"
        ]
d2348 5
a2355 4
; stack now contains list, eg:    (-1, 7, 8, 9, 10, 6, 4, 1, -1)
; if number >maxno_error_buttons, we must make some invisible, then position the rest

; unused icons need to be made invisible
d2357 1
a2357 1
        CMP     R3,#7+maxno_error_buttons-1
d2361 1
a2361 1
        CMP     R3,#7+maxno_error_buttons
d2374 1
a2374 1
        CMP     R0,#maxno_error_buttons+1
d2377 1
a2377 1
        SUB     R0,R0,#maxno_error_buttons
d2390 1
a2390 1
; stack now has at most maxno_error_buttons icons, R2-8 -> icon to appear on far right.
d2396 2
d2400 10
a2409 24
; the first icon is always a default (aka "highlighted") one
        ADD     R3, R14, R1, LSL #i_shift       ; R3 -> first icon
        LDR     R4, errbut_y0_def
        STR     R4, [R3, #i_bby0]
        LDR     R4, errbut_y1_def
        STR     R4, [R3, #i_bby1]
        LDR     R4, errbut_fl_def
        STR     R4, [R3, #i_flags]
        LDR     R4, errbut_va_def
        STR     R4, [R3, #i_data + 4]
        LDR     R4, errbut_w_def
        B       alignanddisplayicon

alignnexticon
        ADD     R3, R14, R1, LSL #i_shift       ; R3 -> icon
        LDR     R4, errbut_y0
        STR     R4, [R3, #i_bby0]
        LDR     R4, errbut_y1
        STR     R4, [R3, #i_bby1]
        LDR     R4, errbut_fl
        STR     R4, [R3, #i_flags]
        LDR     R4, errbut_va
        STR     R4, [R3, #i_data + 4]
        LDR     R4, errbut_w
d2412 9
a2420 1
; R1 is icon number, R14 is icon base, R0 is rhs of icon, R4 is minimum width
d2443 1
a2443 1
        BNE     alignnexticon
d2454 5
a2458 1
        MOVGT   R0,#0                           ; this is the work area x0 required by the buttons
d2460 8
a2467 80
        LDR     R14, [handle, #w_icons]
        LDR     R1, errmess_x0
        ADD     R2, R14, #i_size * 0            ; R2 -> text icon definition
        ADD     R3, R0, R1                      ; stretch text icon to fit window
        STR     R3, [R2, #i_bbx0]
        
      [ StretchErrorText
        LDR     R0, [sp]                        ; get error block pointer
        ADD     R0, R0, #4
        STR     R0, [R2, #i_data + 0]           ; set up text pointer now, we need it to calculate the icon width
        
        Push    "R1-R6, R10, R14"
06
        MOV     R1, #-1
        STR     R1, linecount                   ; activate line counting        
        LDR     R2, [sp, #1*4]                  ; R2 -> text icon definition
        LDMIA   R2, {x0, y0, x1, y1}            ;\
        LDR     R1, [R2, #i_flags]              ; |
        LDR     R2, [R2, #i_data + 0]           ; | set up registers for line count
      [ outlinefont                             ; |
        LDR     R3, systemfont                  ;/
        TEQ     R3, #0
        ADREQL  R14, iconformatted_system
        ADRNEL  R14, iconformatted_fancy
      |
        ADRL    R14, iconformatted_system
      ]
        Push    "PC"                            ; PC+12 is actually stored
        MOV     PC, R14                         ; branch to appropriate routine - returns using Pull "PC"
        NOP
        
        LDR     R0, linecount
      [ debugerr
        Debug   err, "Error message icon line count =", R0
      ]
        CMP     R0, #errmess_maxlines
        BLE     %FT01                           ; satisfactory number of lines, we don't need to stretch any further
        LDR     R2, [sp, #1*4]                  ; R2 -> text icon definition
        LDR     R3, [R2, #i_bbx0]
        SUB     R3, R3, #errmess_increment      ; enlarge window by one step
        STR     R3, [R2, #i_bbx0]
        B       %BT06
01
        Pull    "R1-R6, R10, R14"
        
        LDR     R3, [R2, #i_bbx0]
        SUB     R0, R3, R1                      ; stretch window to fit icon
        
        MOV     R1, #0
        STR     R1, linecount                   ; deactivate line counting
      ]
        
        STR     R0,[handle,#w_wex0]
        LDR     R1,[handle,#w_wex1]
        STR     R0,[handle,#w_wax0]             ; horizontal centring dealt with later
        STR     R1,[handle,#w_wax1]             ; but the visible width *must* match the horizontal work area extent width

        ADD     R2, R14, #i_size * 2            ; move app sprite
        LDR     R3, [R2, #i_bbx0]
        LDR     R4, [R2, #i_bbx1]
        SUB     R4, R4, R3                      ; R4 = old width
        LDR     R3, errapp_x0
        ADD     R3, R3, R0                      ; make relative to new window edge
        ADD     R4, R4, R3
        STR     R3, [R2, #i_bbx0]
        STR     R4, [R2, #i_bbx1]
        
        ADD     R2, R14, #i_size * 3            ; move type sprite
        LDR     R3, [R2, #i_bbx0]
        LDR     R4, [R2, #i_bbx1]
        SUB     R4, R4, R3                      ; R4 = old width
        LDR     R3, errtype_x0
        ADD     R3, R3, R0                      ; make relative to new window edge
        ADD     R4, R4, R3
        STR     R3, [R2, #i_bbx0]
        STR     R4, [R2, #i_bbx1]
        
        ADD     R2, R14, #i_size * 5            ; stretch divider sprite
        STR     R0, [R2, #i_bbx0]
        STR     R1, [R2, #i_bbx1]
a2575 3
        [ ChildWindows
        BLVC    int_flush_opens         ; this is necessary to set the rectangles lists correctly
        ]
@


4.4.2.8
log
@New features:
Dragboxes can now be clipped by and/or fixed to a given window's work area
SWI Wimp_AutoScroll implemented
Ursula icon highlighting scheme redesigned

Bugfixes:
Wimp_Extend 11 now performs the same check on R1 as the main SWI handling code
Message blocks now updated if in a dynamic area
Screenblanker now turned off when error box is displayed
ptr_double now turned off when a drag starts
@
text
@d455 2
d462 1
a462 3
        SUBS    R4,R1,#ROMstart         ; don't splat the ROM!
        RSBCSS  R4,R4,#OSROM_ImageSize * 1024
        LDR     R4,sender               ; worked out earlier
d2268 1
a2268 1
              [ true
a2794 3
;
        MOV     R0, #ScreenBlankerReason_Unblank
        SWI     XScreenBlanker_Control  ; unblank screen (if blanked)
@


4.4.2.9
log
@Iconise button removed from child windows
Icon bar now jumps to the back of the stack as soon as a window is opened above
it (excluding menus, dialogue boxes and foregroud windows). This is to avoid
the ambiguous situation when the icon bar can be part-way down the window stack.
Improved co-odination between auto-fronting and Shift-F12 behaviour.
Stopped scroll offset overflow during icon bar scroll.
Numerous features made configurable:
  WimpIconBarSpeed
  WimpIconBarAcceleration
  WimpSpritePrecedence
  WimpIconiseButton
  WimpStickyEdges (although not actually implemented yet)
  WimpAutoFrontIconBar
  WimpAutoFrontDelay
  WimpAutoScrollDelay
To make room for these in CMOS, Wimp<Drag|DoubleClick><Delay|Move> and
Wimp<AutoMenu|MenuDrag>Delay options are now stored in a more compressed form
in CMOS - but the *Configure interface is unaltered.
@
text
@d2155 1
a2155 1
      [ true
@


4.4.2.10
log
@Bugfixes:

Re-opening a menu structure containing a dialogue box (especially one
containing the caret) was causing data aborts under some OSes/builds.

The minimum title bar length is now the same for windows without line borders,
even if the vertical scroll bar is also absent. This prevents cases when the
title bar shrunk so far that a graphics clipping error occurred.

Wimp_DragBox was looking in R0 for its flags, rather than R3, as specified!

If the pointer was to the right of the central zone, vertical autoscrolling
was working too slowly.

On Service_SwitchingOutputToSprite, the Wimp now re-assesses its idea of the
screen limits. This prevents Wimp_PlotIcon plots outside the current screen
bounds from being optimised out.
@
text
@d2753 1
a2753 1
        MOV     x0,x0,LSR #1            ; half screen width in OS units
@


4.4.2.11
log
@Window tool button type is now configurable.
Windows now keep the same depth when toggle-size tool is clicked with Adjust.
Fixed bug where drags in Eureka caused branch-through-zeros and other
miscellaneous errors.
Fixed a few stray non-X form SWI calls.
Extended applicability/functionality of "MyEntry" debug macro.
@
text
@a231 3

        MyEntry "SendMessage"

a1016 1
        Debug   poll2, "ExitPoll"
@


4.4.2.12
log
@Corrected active point for autoscrolling pointers (was wrong in low-res modes).

Certain user-drawn dragbox routines (eg via DragASprite) don't pass the object
bounding box as the box; this was conflicting with one of the redraw
optimisations, and causing smearing when the underlying object was redrawn.
Relevant optimisation optioned out.

If a window stack-change causes the iconise button to appear or disappear,
this is now caught, and the window border is redrawn immediately.

Toggling of child windows now works - the return coordinates are linked to
the parent in the same way as the current ones. Note that this is unlikely to
be useful for anything other than alignment 0/0/0/0/0/0 children.

Return codes for the "Quit" and "Continue" buttons in "xxx may have gone wrong"
error boxes can now be specified.

Both scrollbars push in for adjust-drags.
@
text
@a1787 14
      [ true
        LDR     R0, progerrsaveblk + 4*1 ; retrieve flags
        TEQ     R2, #2                  ; was quit pressed, as opposed to continue?
        ANDNE   R1, R0, #erf_ocontcode
        MOVNE   R1, R1, LSR #erf_ocontcode_shift
        ANDEQ   R1, R0, #erf_ocancelcode
        MOVEQ   R1, R1, LSR #erf_ocancelcode_shift
        TSTEQ   R0, #erf_cancelbox      ; If quit clicked, but underlying window had no cancel
        TEQEQ   R1, #0                  ; and no return code has been specified either,
        MOVEQ   R1, #99                 ; flag that we'll have to call the exit handler.
        TEQ     R1, #0                  ; Otherwise, no return code means we have to pass 1 or 2 as appropriate
        MOVEQ   R1, R2                  ; for compatibility reasons.
        STR     R1, [sp]
      |
a1794 1
      ]
a2030 3
      [ true
        LDR     R5,=erf_describe:OR:erf_cancelbox:OR:erf_okbox
      |
a2031 1
      ]
@


4.3
log
@ARTtmp branch folded in
@
text
@d1641 21
a1661 1
;
d1858 20
@


4.2
log
@Merged WIMP imported
@
text
@d131 1
a131 1
;
d235 1
a235 1
        LDR     R1,=&400CF
d270 1
a270 1
check_mem_message                                            
d273 1
a273 1
                
d304 1
a304 1
                     
d325 1
a325 1
      ]  
d488 1
a488 1
      |  
d502 1
a502 1
        
d618 1
a618 1
      [ debug  
a1050 2
; Stamp with event time for task priority and swapping

d1054 3
a1058 1
 [ debugtask4
a1061 1
 ]
d1064 1
d1078 4
d1090 1
d1098 1
a1098 1
        Push    "R1-R2"
d1101 1
a1101 1
        Pull    "R1-R2"
a1186 3
      [ SAnaffsilicon
        NOP
      ]
d1218 4
d1230 1
d1295 3
d1299 3
a1301 1
; Exit:   R1 = 1 ==> OK box was selected
d1303 1
d1488 1
a1488 1
        TST     R14,#newerrorbits
d1660 2
d1749 2
a1750 2
        BIC     R5,R5,#&80000000
        BIC     userblk,userblk,#&80000000
d1802 6
a1807 2
        MOV     R5,#&80000003           ; cancel describe
        ORR     R5,R5,#&100              ; continue rather than ok
d1810 3
a1812 2
        STR     R6,tempworkspace
        STR     R6,tempworkspace+4      ; no custom buttons/sprite
a1813 1
        MOV     R7,#0                   ; no sprite
a1926 1
      [ chwidth
a1927 1
      ]
d1963 1
a1963 1
; set up sprites in dialog box
d1966 4
a1969 4
        AND     R0,R0,#errortypemask
        ADR     R14,errspritetable
        TST     userblk,#newerrorbits
        ADDNE   R0,R14,R0 , LSR #errortypeshift-4
d1971 1
a1971 1
        TST     userblk,#&80000000
d1985 1
a1985 1
        TST     userblk,#newerrorbits
d2096 1
a2096 1
        TST     userblk,#newerrorbits
d2158 1
a2158 1
        TST     userblk,#newerrorbits
d2286 10
@


4.1
log
@Initial revision
@
text
@d41 9
d191 1
d264 51
d322 5
d445 1
d481 8
a488 1
;
d495 2
a497 1
;
d499 4
a502 1
;
d594 1
d618 4
d1182 3
a1699 1
noappname       DCB     "switcher",0
d1889 1
a1889 1
        [ NewErrorSystem
d1892 3
d1896 1
d1906 1
a1906 1
        ]
d2004 5
a2008 1

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.2
log
@Modify UpCall handler; restore font colours before calling Service_WimpReportError at end of SWI Wimp_ReportError.
@
text
@d1542 1
a1542 21

	[	outlinefont
	;Restore the current font and font colours that were in force on
	;	entry, if they've been changed. This must be done *before*
	;	 making the service call, so the code in ExitWimp is too late.
	Push	"r0-r3"
        LDR     R0, currentfont
        TEQ     R0, #0
        BEQ     ReportError_restored_font_colours
        LDR     R1, systemfont
        TEQ     R1, R0
        LDRNE	R1, currentbg
        LDRNE	R2, currentfg
        LDRNE	R3, currentoffset
        SWINE	XFont_SetFontColours
        MOV     R0, #0
        STR     R0, currentfont
ReportError_restored_font_colours
	Pull	"r0-r3"
        ]

a1733 20

	[	outlinefont
	;Restore the current font and font colours that were in force on
	;	entry, if they've been changed. This must be done *before*
	;	making the service call, so the code in ExitWimp is too late.
	Push	"r0-r3"
        LDR     R0, currentfont
        TEQ     R0, #0
        BEQ     ReportError_restored_font_colours2
        LDR     R1, systemfont
        TEQ     R1, R0
        LDRNE	R1, currentbg
        LDRNE	R2, currentfg
        LDRNE	R3, currentoffset
        SWINE	XFont_SetFontColours
        MOV     R0, #0
        STR     R0, currentfont
ReportError_restored_font_colours2
	Pull	"r0-r3"
        ]
@


4.1.7.3
log
@When building for NCs, use IconHigh in error boxes, use different button
border colours, use replacement Templates file.
@
text
@a1351 11

        MOV     R0, #220                ; Read current escape key so we can restore it later
        MOV     R1, #0
        MOV     R2, #255
        SWI     XOS_Byte
        STRB    r1, old_escape

        MOV     R0, #220                ; Set default escape key
        MOV     R1, #27
        MOV     R2, #0
        SWI     XOS_Byte
a1453 5
        [ BuildForNC
        MOV     R0, #0                  ; turn off IconHigh
        SWI     &6E703
        ]

a1562 5
        MOV     R0, #220                ; restore the old escape key
        LDRB    R1, old_escape
        MOV     R2, #0
        SWI     XOS_Byte

a2372 7
        [ BuildForNC
        MOV     R0, #106                ; turn off mouse pointer
        MOV     R1, #0
        SWI     XOS_Byte
        MOV     R0, #2                  ; turn on IconHigh, use single-tasking mode
        SWI     &6E702
        ]
@


4.1.7.4
log
@   When turning the pointer off before Wimp_Report, save the state and
set it back to that state afterwards.
   Allow Wimp_GetPointerInfo, Wimp_GetWindowInfo, Wimp_GetWindowState outside
a task: needed to make IconHigh work in a ReportError box which has itself been
invoked from outside a task.
@
text
@a1206 36
;Rough outline (not gospel!) JRC 24 Jul 1997
;	Make service call ErrorStarting
;	IF	in command mode
;	THEN	report error in text
;		poll for a key press
;		return key pressed (Return/Escape)
;	ELSE	IF	closing an open error box
;		THEN	return button-click specified
;		ELSE	Create a window structure
;			Make service call WimpReportError 1
;			Switch output to screen
;			Disable file redirection
;			Enable VDU, disable Spool, printer & serial
;			Beep
;			Add the icon definitions to the window structure
;			int_open_window
;			int_redraw_window
;			int_get_rectangle
;			Smash hourglass
;			Bound pointer to window
;			Flush keyboard and mouse
;			Start IconHigh
;			DO	Read key with no time limit
;				Check mousebuttons
;			WHILE	nothing happens
;			Unbound pointer
;			int_close_window
;			Stop IconHigh
;			Make service call ErrorButtonPressed
;			Make service call ErrorEnding
;			Restore file redirection
;			Restore output to previous state
;			Make service call WimpReportError
;		FI
;	FI

a1465 6
	; Restore pointer. JRC 25 Jul 1997
	MOV     R0, #106                ; Select pointer/activate mouse
	ADRL	R1, ptrshlflag
	LDR	R1, [R1]
	SWI     XOS_Byte

d1467 1
a1467 1
        SWI     XIconHigh_Stop
d2395 2
a2396 2
        MOV     R0, #106                ; Select pointer/activate mouse
        MOV     R1, #0			; Turn off mouse pointer
a2397 3
        ADRL	R0, ptrshlflag
	STR	R1, [R0]		; save old state. JRC 25 Jul 1997

d2399 1
a2399 1
        SWI     XIconHigh_Start
@


4.1.7.5
log
@   Return result from Wimp_Report *before* corrupting it.
@
text
@a1448 1
	;Debug	temp, "int_get_pointer_info: w, i, oldbuttons, newbuttons:", R3, R4, R5, R2
a1475 1
	Debug	temp, "finishing error ", r4
d1486 1
d1499 1
a1499 2
        Debug   temp,"ReportError returns R1",R1
        STR     R1,[sp,#0*4]
d1535 3
@


4.1.7.6
log
@Moved turning off IconHigh on error windows to BEFORE the window is closed.
@
text
@a1481 13

        [ BuildForNC
	Push    "r0-r2"
	; Restore pointer. JRC 25 Jul 1997
	MOV     R0, #106                ; Select pointer/activate mouse
	ADRL	R1, ptrshlflag
	LDR	R1, [R1]
	SWI     XOS_Byte

        MOV     R0, #0                  ; turn off IconHigh
        SWI     XIconHigh_Stop
        Pull    "r0-r2"
        ]
d1500 14
a1536 3

        Debug   temp,"ReportError returns R1",R1
        STR     R1,[sp,#0*4]
@


4.1.7.7
log
@Build for NC tested positive and negative transitions in key presses.  This
avoided the double clicks.
@
text
@a1462 3
        [ BuildForNC
        EOR	R14,R2,R5		; AR 13/8/97 look at both transitions, fixed a problem of double clicks
 	|
a1463 1
	]
@


4.1.7.8
log
@Fixed NC code so it now only uses IconHigh when a mouse is being used and
turns the pointer on and off correctly.
@
text
@a1252 11
        [ BuildForNC
        Push	"R0-R2"
        MOV     R0, #106                ; Select pointer/activate mouse
        MOV     R1, #0			; Turn off mouse pointer,
        SWI     XOS_Byte		; read current state,
	ADRL	R14, ptrshlflag
	STR	R1, [R14]		; save it
	SWI	XOS_Byte		; and restore it again!
	Pull	"R0-R2"
        ]

a1485 1
        BL      clearpointerwindow
d1490 1
a1492 7
	TST	R1, #&07		; if pointer was off then
	Push	R1
        MOVEQ   R0, #0                  ; turn off IconHigh
        SWIEQ   XIconHigh_Stop
        Pull	R1
	
	MOV     R0, #106                ; Select pointer/activate mouse
d1495 2
d1500 1
d2442 8
a2449 9
	ADRL	R14, ptrshlflag
	LDR	R1, [R14]		; Get current pointer state.
	TST	R1, #&07		; If pointer was off then
	Push	R1
        MOVEQ   R0, #2                  ; turn on IconHigh, use single-tasking mode
        SWIEQ   XIconHigh_Start
        Pull	R1
        MOV	R0, #106		; Put pointer back to its stored state
        SWI	XOS_Byte
a2450 1

@


4.1.7.9
log
@Added new flag, PreservePointerOnError, to control whether the mouse pointer
state is preserved over errors. This is also dependent on BuildForNC being true.
@
text
@d1253 1
a1253 1
        [ PreservePointerOnError
d1499 1
a1499 2
    [ BuildForNC
      [ PreservePointerOnError
d1512 1
d1514 1
a1514 5
      |
        MOV     R0, #0                  ; turn off IconHigh
        SWI     XIconHigh_Stop
      ]
    ]
d2456 1
a2456 2
    [ BuildForNC
      [ PreservePointerOnError
d2466 1
a2466 5
      |
        MOV     R0, #2                  ; turn on IconHigh, use single-tasking mode
        SWI     XIconHigh_Start
      ]
    ]
@


4.1.7.10
log
@Modified behaviour of pointer during Wimp error boxes for NCs.
@
text
@d2465 1
d2468 2
a2469 2
        MOV	R0, #106		; Enable pointer
        MOV     R1, #1
@


4.1.7.1.2.1
log
@AMBControl task switching merged from RO_3_70 branch.
PlotSpritesFromPalette and TwitterOnlyMenus options added.
ChildWindows merged in.
@
text
@a40 9
        MACRO
$lab    CheckMsgQ
$lab
      [ NKmessages1
        LDR     R0,lastpointer
        SUBS    R0,R0,R2
        STREQ   R0,lastpointer
      ]
        MEND
a181 1
        CheckMsgQ
a253 51
; NK's optimise
; if there is already a message_slot_size on the message queue
; for this task, then just update it rather than add another.

      [ NKmessages2

check_mem_message
        TEQ     R0,#User_Message
        MOVNE   PC,LR

        Push    "R7,LR"
        LDR     R7,=Message_SlotSize
        LDR     LR,[R1,#16]
        TEQ     LR,R7
        Pull    "R7,PC",NE

; check queue
        Push    "R0-R3"
        LDR     R0,headpointer
        LDR     R2,taskhandle
        CMP     R2,#0
        LDRGT   R14,[wsptr,R2]          ; NB task must be alive!
        LDRGT   R14,[R14,#task_flagword]
        MOVGT   R14,R14,LSR #flag_versionbit
        ORRGT   R2,R2,R14,LSL #flag_versionbit
05
        CMP     R0,#0
        BLE     %FT99
        LDR     R3,[R0,#msb_reasoncode]
        TEQ     R3,#User_Message
        LDREQ   R3,[R0,#msb_sender]
        TEQEQ   R3,R2
; its the same task, is it the right message?
        LDREQ   R3,[R0,#msb_size+16]
        TEQEQ   R3,R7
        LDRNE   R0,[R0,#msb_link]
        BNE     %BT05

        LDR     R2,[R1,#24]             ; new next slot
        LDR     R1,[R1,#20]             ; new current

        STR     R1,[R0,#msb_size+20]
        STR     R2,[R0,#msb_size+24]
        Pull    "R0-R3,R7,PC"

99
        CMP     PC,#0
        Pull    "R0-R3,R7,PC"
      ]


a260 5
      [ NKmessages2
        BL      check_mem_message
        Pull    "R3-R7,handle,PC",EQ
      ]

a378 1
        CheckMsgQ
d414 1
a414 8

; use lastpointer to determine where we should put the message

      [ NKmessages1
        LDR     R4,lastpointer
        CMP     R4,#0
        ADRLE   R4,headpointer-msb_link
      |
a420 2
      ]

d422 1
d424 1
a424 4
      [ NKmessages1
        STR     R2,lastpointer
      ]

a515 1
        Debug   opn,"**** validtask fails handle",R2
a538 4
      [ debug
        Pull    "PC",EQ
        Debug   err,"**** validtask_alive fails handle",R2
      ]
d1614 1
d1804 1
a1804 1
      [ NewErrorSystem
a1806 3
      [ debug
        ADRL    R2,ptr_default2         ; ADRL doesn't reach if debugging enabled!
      |
a1807 1
      ]
d1817 1
a1817 1
      ]
d1915 1
a1915 5
noappname       DCB     "switcher",0
              [ debug
ptr_default2    DCB     "ptr_default",0
              ]
                ALIGN
@


4.1.7.1.2.2
log
@Some obsolete assembly switches removed (chwidth in particular).
Behaviour of scrollbars with large extents improved.
Window tools now press in correctly after a Service_InvalidateCache.
Plotting of solid window tools optimised - background isn't drawn in.
Auto-fronting iconbar added.
Various optimisations, such as multiple OS_WriteI -> OS_WriteN.
HiResMono flag no longer relied on.
"22" tool sprites now chosen for 1x2,2x1 or 1x1 screen modes.
Buttons restored correctly after "application may have gone wrong" error box.
Positioning of outline font text shifted right 2 OS units to match system font.
Parameter of L validation string implemented.
Positioning of outline font "L" (multiple line) icons fixed.
Shift-toggle size behaviour fixed.
Wimp_TransferBlock above 2Gb should be fixed.
Post-rectangle filters implemented.
FPE4 flag added (to use LFM/SFM instead of LDFE/STFE).
Plotting of non-pixel aligned 3d icons fixed.
3d borders now solid in EX0/EY0 modes.
@
text
@d131 1
a131 1

d235 1
a235 1
        LDR     R1,=Message_FontChanged
a1050 1
      [ debugtask4
d1058 1
d1062 1
a1064 1
      ]
a1077 4
      [ FPE4
	LFM	F0,4,[R4,#fp_reg0]      ; (only gets here if active previously)
	LFM	F4,4,[R4,#fp_reg4]
      |
a1085 1
      ]
d1093 1
a1093 1
        Push    "R1"
d1096 1
a1096 1
        Pull    "R1"
a1212 4
      [ FPE4
    	SFM	F0,4,[R2,#fp_reg0]
	SFM	F4,4,[R2,#fp_reg4]
      |
a1220 1
      ]
a1284 3
;              bit 8 ==> new type error report
;              bits 9-11 ==> error type
;
d1286 1
a1286 3
;         R3 --> sprite name (for new type error report)
;         R4 --> sprite area, or 1 for Wimp area (for new type error report)
;         R5 --> comma separated additional button list, or 0 for none (for n; Exit:   R1 = 1 ==> OK box was selected
a1287 1
;         R1 = 3,4... ==> additional button pressed
d1472 1
a1472 1
        TST     R14,#erf_newtype
a1643 2
	LDR	R1,tempworkspace+16	; Get back buttons
	STR	R1,tempworkspace+4
d1731 2
a1732 2
        BIC     R5,R5,#erf_describe
        BIC     userblk,userblk,#erf_describe
d1784 2
a1785 6
	LDR	R1,tempworkspace+4	; store buttons away
	STR	R1,tempworkspace+16	; in case we need them again
					; when user hits describe
	TST	R5,#erf_newtype
	MOV	R5,#erf_describe:OR:erf_cancelbox:OR:erf_okbox
        ORR     R5,R5,#erf_newtype      ; continue rather than ok
d1788 2
a1789 3
	MOVEQ	R7,#0			; make sure no sprite if original error wasn't new type
        STREQ   R6,tempworkspace
        STR     R6,tempworkspace+4      ; no custom buttons
d1791 1
d1905 1
d1907 1
d1943 1
a1943 1
; set up sprites in dialogue box
d1946 1
a1946 1
        AND     R0,R0,#erf_errortype
d1948 2
a1949 2
        TST     userblk,#erf_newtype
        ADDNE   R0,R14,R0 , LSR #erb_errortype-4
d1951 1
a1951 1
        TST     userblk,#erf_describe
d1965 1
a1965 1
        TST     userblk,#erf_newtype
d2076 1
a2076 1
        TST     userblk,#erf_newtype
d2138 1
a2138 1
        TST     userblk,#erf_newtype
@


4.1.7.1.2.3
log
@Corruption of userblk in oldvisible_knockout (causing data aborts when
input focus changes) fixed.
Care taken to ensure that characters (eg VDU 26) issued by the Wimp don't
trigger a command window.
@
text
@d1967 1
a1967 1
        addr    R14,errspritetable
@


4.1.7.1.2.4
log
@Added support for multiple options files (RO310, RO350, RO360, RO370, RCA,
Ursula).
Removed run-time MedusaOS checks.
Enabled correct build for RISC OS 3.1 machines.
Ensured that "freepoolinuse" is cleared before OS_ChangeDynamicArea
is intercepted.
Increased maxrects to 256.
Gave copy filter window handle in R10 (if ChildWindows).
Corrected a few border problems when no toolsprites.
Made toolsprites press in immediately - in particular close and toggle can
now be highlighted.
BounceClose flag no affects all of back,close,iconise and toggle.
Made "L" validation string parsing check manually for presence of a number,
to prevent error from OS_ReadUnsigned trashing MessageTrans' error buffers.
Allow error box buttons to stretch to fit text.
Fixed bug: floating point registers were not being saved unless on a portable.
Integrated some of the Wimp_TransferBlock fixes into Wimp08 from Wimp08s.
@
text
@d1051 3
a1056 3
      [ debugtask4
; Stamp with event time for task priority and swapping

a2285 10

      [ StretchErrorButtons
	Push	"R0,R1,R2,R4,R14"
	LDR	R1,[R3,#i_flags]
	LDR	R2,[R3,#i_data]
	BL	textwidth
	ADD	R5,R4,#36			; allow 18 OS-units each side, in case it's a default button
	Pull	"R0,R1,R2,R4,R14"
	max	R4,R5
      ]
@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@a40 8
      MACRO
$lab    CheckMsgQ
$lab
        LDR     R0,lastpointer
        SUBS    R0,R0,R2
        STREQ   R0,lastpointer

      MEND
a181 1
        CheckMsgQ
a253 47
; NK's optimise
; if there is already a message_slot_size on the message queue
; for this task, then just update it rather than add another.
check_mem_message                                            
        TEQ     R0,#User_Message
        MOVNE   PC,LR
                
        Push    "R7,LR"
        LDR     R7,=Message_SlotSize
        LDR     LR,[R1,#16]
        TEQ     LR,R7
        Pull    "R7,PC",NE

; check queue
        Push    "R0-R3"
        LDR     R0,headpointer
        LDR     R2,taskhandle
        CMP     R2,#0
        LDRGT   R14,[wsptr,R2]          ; NB task must be alive!
        LDRGT   R14,[R14,#task_flagword]
        MOVGT   R14,R14,LSR #flag_versionbit
        ORRGT   R2,R2,R14,LSL #flag_versionbit
05
        CMP     R0,#0
        BLE     %FT99
        LDR     R3,[R0,#msb_reasoncode]
        TEQ     R3,#User_Message
        LDREQ   R3,[R0,#msb_sender]
        TEQEQ   R3,R2
; its the same task, is it the right message?
        LDREQ   R3,[R0,#msb_size+16]
        TEQEQ   R3,R7
        LDRNE   R0,[R0,#msb_link]
        BNE     %BT05

        LDR     R2,[R1,#24]             ; new next slot
        LDR     R1,[R1,#20]             ; new current
                     
        STR     R1,[R0,#msb_size+20]
        STR     R2,[R0,#msb_size+24]
        Pull    "R0-R3,R7,PC"

99
        CMP     PC,#0
        Pull    "R0-R3,R7,PC"


a260 4
        ;NK's optimise
        BL      check_mem_message
        Pull    "R3-R7,handle,PC",EQ

d379 1
a380 2
        CheckMsgQ
        MOV     R0,#ModHandReason_Free
a414 1
        [ false
a420 7
        |
; use lastpointer to determine where we should put the message
        LDR     R4,lastpointer
        CMP     R4,#0
        ADRLE   R4,headpointer-msb_link
        ]

a423 1
        STR     R2,lastpointer
a1098 3
  [ SAnaffsilicon
        NOP
  ]
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

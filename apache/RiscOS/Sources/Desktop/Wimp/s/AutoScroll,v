head	4.5;
access;
symbols
	Wimp-5_62:4.5
	Wimp-5_61:4.5
	Wimp-5_60:4.5
	Wimp-5_59:4.5
	Wimp-5_58:4.5
	Wimp-5_57:4.5
	Wimp-5_56:4.5
	Wimp-5_55:4.5
	Wimp-5_54:4.5
	Wimp-5_53:4.5
	Wimp-5_52:4.5
	Wimp-5_51:4.5
	Wimp-5_50:4.5
	Wimp-5_49:4.5
	Wimp-5_48:4.5
	Wimp-5_47-file1ad:4.5
	Wimp-5_47:4.5
	Wimp-5_46:4.5
	Wimp-5_45:4.5
	Wimp-5_44:4.5
	Wimp-5_43:4.5
	Wimp-5_42:4.5
	Wimp-5_41:4.5
	Wimp-5_40:4.5
	Wimp-5_39:4.5
	Wimp-5_38:4.5
	Wimp-5_37:4.5
	Wimp-5_36:4.5
	Wimp-5_35:4.5
	Wimp-5_34:4.5
	Wimp-5_33:4.5
	Wimp-5_32:4.5
	Wimp-5_31:4.5
	Wimp-5_30:4.5
	Wimp-530-pre4:4.5
	Wimp-5_30-pre3:4.5
	Wimp-5_30-pre2:4.5
	Wimp-5_30-pre1:4.5
	Wimp-5_29:4.5
	Wimp-5_28:4.5
	Wimp-5_27:4.5
	Wimp-5_26:4.5
	Wimp-5_25:4.5
	Wimp-5_24:4.5
	Wimp-5_23:4.5
	Wimp-5_22:4.5
	Wimp-5_21:4.5
	Wimp-5_20:4.5
	Wimp-5_19:4.5
	Wimp-5_18:4.5
	Wimp-5_17:4.5
	Wimp-5_16:4.5
	Wimp-5_15:4.5
	Wimp-5_14:4.5
	Wimp-5_13:4.5
	Wimp-5_12:4.5
	Wimp-5_11:4.5
	Wimp-5_10:4.5
	Wimp-5_09:4.5
	Wimp-5_08:4.5
	Wimp-5_07:4.5
	Wimp-5_06:4.5
	Wimp-5_05:4.5
	Wimp-5_04:4.5
	Wimp-5_03:4.5
	Wimp-5_02:4.5
	Wimp-5_01:4.5
	Wimp-4_66-4_77_2_1:4.4
	bavison_Threads_dev:4.4.0.2
	bavison_Threads_dev_bp:4.4
	Wimp-5_00:4.5
	Wimp-4_100:4.5
	Wimp-4_99:4.5
	Wimp-4_98:4.5
	Wimp-4_97:4.5
	Wimp-4_96:4.5
	Wimp-4_95:4.5
	Wimp-4_94:4.5
	RO_5_07:4.5
	Wimp-4_93:4.5
	Wimp-4_92:4.5
	Wimp-4_91:4.5
	Wimp-4_90:4.5
	Wimp-4_89:4.5
	Wimp-4_88:4.5
	Wimp-4_87:4.5
	Wimp-4_86:4.5
	Wimp-4_85:4.5
	Wimp-4_84:4.5
	Wimp-4_83:4.5
	Wimp-4_82:4.5
	Wimp-4_81:4.5
	Wimp-4_80:4.5
	Wimp-4_79:4.5
	Wimp-4_78:4.5
	Wimp-4_77:4.5
	Wimp-4_76:4.5
	Wimp-4_75:4.4
	Wimp-4_74:4.4
	Wimp-4_73:4.4
	Wimp-4_72:4.4
	Wimp-4_71:4.4
	Wimp-4_70:4.4
	Wimp-4_69:4.4
	Wimp-4_68:4.4
	Wimp-4_67:4.4
	Wimp-4_66:4.4
	Wimp-4_65:4.4
	Wimp-4_64:4.4
	Wimp-4_63:4.4
	Wimp-4_62:4.4
	Wimp-4_61:4.4
	Wimp-4_60:4.4
	Wimp-4_59:4.4
	Wimp-4_58:4.3
	Wimp-4_36-4_46_2_6:4.2
	Wimp-4_57:4.3
	Alpnet_approved:4.2
	Wimp-4_36-4_46_2_5:4.2
	Wimp-4_56:4.3
	dellis_autobuild_BaseSW:4.3
	Wimp-4_36-4_46_2_4:4.2
	Wimp-4_36-4_46_2_3:4.2
	Wimp-4_55:4.3
	Wimp-4_54:4.3
	Wimp-4_36-4_46_2_2:4.2
	Wimp-4_53:4.3
	Wimp-4_36-4_46_2_1:4.2
	Bethany:4.2.0.2
	Wimp-4_52:4.3
	Wimp-4_51:4.3
	Wimp-4_50:4.3
	Wimp-4_49:4.3
	Wimp-4_48:4.3
	Wimp-4_47:4.3
	Wimp-4_46:4.2
	Wimp-4_45:4.2
	Wimp-4_44:4.2
	Wimp-4_43:4.2
	Wimp-4_42:4.2
	sbrodie_sedwards_16Mar2000:4.2
	Wimp-4_41:4.2
	Wimp-4_40:4.2
	Wimp-4_39:4.2
	Wimp-4_38:4.2
	Wimp-4_37:4.2
	Wimp-4_36:4.2
	Wimp-4_35:4.2
	Wimp-4_34:4.2
	Wimp-4_33:4.2
	Wimp-4_32:4.2
	Wimp-4_31:4.2
	dcotton_autobuild_BaseSW:4.4
	Wimp-4_30:4.2
	Wimp-4_29:4.2
	Wimp-4_28:4.2
	Wimp-4_27:4.2
	Wimp-4_26:4.2
	Wimp-4_25:4.2
	Wimp-4_24:4.2
	Wimp-4_23:4.2
	Wimp-4_22:4.2
	Wimp-4_21:4.2
	Wimp-4_20:4.2
	Wimp-4_19:4.2
	Wimp-4_18:4.2
	Wimp-4_17:4.2
	Wimp-4_16:4.2
	Wimp-4_15:4.2
	Wimp-4_14:4.2
	Wimp-4_13:4.2
	Wimp-4_12:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:1.1.2.6
	bavison_Wimp-4_11:4.2
	Ursula_RiscPC:1.1.2.6.0.2
	Wimp-4_11:4.2
	Wimp-4_10:4.2
	Wimp-4_09:4.2
	Wimp-4_08:4.1
	Wimp-4_07:4.1
	Wimp-4_06:4.1
	Wimp-4_05:4.1
	Wimp-4_04:4.1
	bavison_Wimp-4_03_noshrinkables:4.1
	Wimp-4_03:4.1
	Wimp-4_02:4.1
	Ursula_merge:1.1.2.6
	bavison_Wimp-4_01:4.1
	Wimp-4_01:4.1
	bavison_Wimp-4_00_TRUNK:4.1
	bavison_Wimp-4_00:1.1.2.6
	rthornb_UrsulaBuild-19Aug1998:1.1.2.6
	UrsulaBuild_FinalSoftload:1.1.2.6
	bavison_Wimp-3_99t:1.1.2.6
	rthornb_UrsulaBuild-12Aug1998:1.1.2.6
	bavison_Wimp-3_99s:1.1.2.6
	aglover_UrsulaBuild-05Aug1998:1.1.2.6
	bavison_Wimp-3_99r:1.1.2.6
	rthornb_UrsulaBuild-29Jul1998:1.1.2.5
	bavison_Wimp-3_99q:1.1.2.5
	rthornb_UrsulaBuild-22Jul1998:1.1.2.4
	bavison_Wimp-3_99p:1.1.2.4
	rthornb_UrsulaBuild-15Jul1998:1.1.2.4
	bavison_Wimp-3_99o:1.1.2.4
	bavison_Wimp-3_99n:1.1.2.4
	rthornb_UrsulaBuild-07Jul1998:1.1.2.4
	bavison_Wimp-3_99m:1.1.2.4
	rthornb_UrsulaBuild-17Jun1998:1.1.2.3
	rthornb_UrsulaBuild-03Jun1998:1.1.2.3
	bavison_Wimp-3_99l:1.1.2.3
	rthornb_UrsulaBuild-27May1998:1.1.2.3
	rthornb_UrsulaBuild-21May1998:1.1.2.3
	bavison_Wimp-3_99k:1.1.2.3
	bavison_Wimp-3_99j:1.1.2.3
	bavison_Wimp-3_99i:1.1.2.3
	bavison_Wimp-3_99h:1.1.2.3
	rthornb_UrsulaBuild_01May1998:1.1.2.3
	bavison_Wimp_399g:1.1.2.3
	bavison_Wimp_399f:1.1.2.3
	bavison_Wimp_399e:1.1.2.2
	bavison_Wimp_399d:1.1.2.1
	bavison_Wimp_399c:1.1.2.1
	Ursula:1.1.0.2;
locks; strict;
comment	@# @;


4.5
date	2002.10.23.17.12.35;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2000.11.08.10.47.49;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	2000.04.25.12.24.03;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	98.10.23.15.48.15;	author bavison;	state Exp;
branches;
next	4.1;

4.1
date	98.09.18.16.13.59;	author bavison;	state Exp;
branches;
next	1.1;

1.1
date	98.03.26.19.31.30;	author bavison;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	98.03.26.19.31.31;	author bavison;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	98.04.17.16.54.06;	author bavison;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	98.04.21.16.57.53;	author bavison;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	98.07.03.17.59.42;	author bavison;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	98.07.28.17.11.05;	author bavison;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	98.08.05.09.09.29;	author bavison;	state Exp;
branches;
next	;


desc
@@


4.5
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@; Copyright 1998 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Wimp.s.AutoScroll

;;-----------------------------------------------------------------------------
;; Automatic window scrolling
;;-----------------------------------------------------------------------------

      [ Autoscr

; Flags layout

af_enable       *       2_00000000000000000000000000000011
af_horizontal   *       2_00000000000000000000000000000001
af_vertical     *       2_00000000000000000000000000000010
af_scrollrq     *       2_00000000000000000000000000000100
af_read         *       2_00000000000000000000000010000000
af_scrolling    *       2_00000000000000000000000100000000
af_ptrout       *       2_00000000000000000000001000000000
af_ptrpause     *       2_00000000000000000000010000000000
af_ptrin        *       2_00000000000000000000100000000000
af_ptrleft      *       2_00000000000000000001000000000000
af_ptrdown      *       2_00000000000000000010000000000000
af_ptrright     *       2_00000000000000000100000000000000
af_ptrup        *       2_00000000000000001000000000000000
af_canleft      *       2_00000000000000010000000000000000
af_candown      *       2_00000000000000100000000000000000
af_canright     *       2_00000000000001000000000000000000
af_canup        *       2_00000000000010000000000000000000
af_status_bits  *       2_00000000000011111111111100000000
af_status_can   *       2_00000000000011110000000000000000
af_status_horiz *       2_00000000000001010000000000000000
af_status_vert  *       2_00000000000010100000000000000000

; Block definition
                ^       0
a_handle        #       4
a_pausex0       #       4
a_pausey0       #       4
a_pausex1       #       4
a_pausey1       #       4
a_pauselen      #       4
a_rout          #       4
a_wsptr         #       4

;;-----------------------------------------------------------------------------
;; SWI Wimp_AutoScroll
;;
;; in   R0 = autoscroll state flags
;;           bit 0 set => enable horizontal scrolling
;;           bit 1 set => enable vertical scrolling
;;           bit 2 set => send Scroll_Request instead of Open_Window_Request
;;           bit 7 set => just read current states of flags/block
;;      R1 -> block
;;           +0  window handle to scroll (must be owned by task)
;;           +4  left pause zone size
;;           +8  bottom pause zone size
;;           +12 right pause zone size
;;           +16 top pause zone size
;;           +20 pause duration (0 = pause not required, -1 = default length)
;;           +24 pointer-changing routine (0 for none, 1 for default)
;;           +28 workspace pointer for routine (if [R1,#24] >= &8000)
;; out  R0 = new autoscroll state flags
;;           bits 0-2 preserved, or (if bit 7 set on entry) read
;;           bit 7 clear
;;           bit 8  set => pause complete
;;           bit 9  set => pointer not over visible area rectangles
;;           bit 10 set => pointer over pause zone(s) rectangles
;;           bit 11 set => pointer over centre zone rectangles
;;           bit 12 set => pointer left of centre zone
;;           bit 13 set => pointer below centre zone
;;           bit 14 set => pointer right of centre zone
;;           bit 15 set => pointer above centre zone
;;           bit 16 set => there is work area left of the visible area
;;           bit 17 set => there is work area below the visible area
;;           bit 18 set => there is work area right of the visible area
;;           bit 19 set => there is work area above the visible area
;;-----------------------------------------------------------------------------

SWIWimp_AutoScroll
        MyEntry "AutoScroll"

        TST     R0, #af_read
        BNE     return_autoscroll_state ; Wimp_Init not necessary to read state

        LDR     R14, taskhandle
        LDR     R14, [wsptr, R14]
        TST     R14, #task_unused
        MyXError  WimpBadOp, NE, L
        BVS     ExitWimp                ; check alive

        TST     R0, #af_enable
        BEQ     %FT01                   ; don't bother validating if disabling

        CMP     userblk, #ApplicationStart
        MyXError  WimpBadPtrInR1, LO, L
        BVS     ExitWimp                ; then check pointer

        LDR     handle, [userblk, #a_handle]
        BL      checkhandle_owner
        BVS     ExitWimp                ; then check it's one of our windows

        ASSERT  a_handle = 0
        LDMIA   userblk, {R1, cx0, cy0, cx1, cy1, x0, y0, x1}
01
        BL      int_autoscroll

        LDRVC   R0, autoscr_state
        B       ExitWimp

return_autoscroll_state
        CMP     userblk, #ApplicationStart
        MyXError  WimpBadPtrInR1, LO, L
        BVS     ExitWimp                ; just check pointer

        ADRL    R14, autoscr_state
        LDMIA   R14, {R0, R1, cx0, cy0, cx1, cy1, x0, y0, x1}

        TST     R0, #af_enable
        ASSERT  a_handle = 0
        STMNEIA userblk, {R1, cx0, cy0, cx1, cy1, x0, y0, x1}

        B       ExitWimp

;;-----------------------------------------------------------------------------
;; int_autoscroll
;;
;; in   R0  = autoscroll state flags (see above)
;;      R1  = (external) window handle to scroll
;;      cx0 = left pause zone size
;;      cy0 = bottom pause zone size
;;      cx1 = right pause zone size
;;      cy1 = top pause zone size
;;      x0  = pause duration (0 = pause not required, -1 = default length)
;;      y0  = pointer routine (or 0 or 1)
;;      x1  = pointer routine workspace (if y0 >= &8000)
;;-----------------------------------------------------------------------------

int_autoscroll
        Entry   "R0-x1"
        MOV     R0, #0
        BL      update_autoscroll_state ; deactivate any existing autoscroll
                                        ; (does nothing if already off)
        LDR     R0, [sp]

        ADRL    R14, autoscr_handle
        STMIA   R14, {R1, cx0, cy0, cx1, cy1, x0, y0, x1}

        CMP     x0, #-1                 ; default pause time requested?
        LDREQB  x0, autoscr_default_pause
        MOVEQ   x0, x0, LSL #1
        ADDEQ   x0, x0, x0, LSL #2      ; load default time *10 (ds -> cs)

        CMP     y0, #ApplicationStart
        BHS     %FT01                   ; if a user routine, leave alone

        TST     y0, #1                  ; NB if you add further types, keeping
        MOVEQ   y0, #0                  ; bit 0 set will guarantee that some
        ADRNE   y0, autoscroll_pointer_routine_1 ; sort of pointer is displayed
        MOV     x1, wsptr               ; even when running on this old Wimp

01      ADRL    R14, autoscr_pause
        STMIA   R14, {x0, y0, x1}

        BL      update_autoscroll_state

        CLRV
        TST     R0, #af_enable
        EXIT    NE

        MOV     R0, #SpriteReason_SetPointerShape
        ADRL    R14, special_pointer    ; if turned off, get pointer to sprite
        LDR     R14, [R14]              ; name to return shape number 1 to
        TEQ     R14, #0
        ADREQL  R2, ptr_default2
        ADRNEL  R2, pointer_sprite
        MOV     R3, #&61                ; just reprogram the shape
        MOV     R4, #0                  ; assume origin at top-left
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XWimp_SpriteOp
        CLRV
        EXIT

update_autoscroll_state
; In: R0 = new autoscroll state, in bits 0-4
; Sends a message to the autoscroll owner if the state (of any bit) has changed
        Entry   "R0-R2"
        LDR     R1, autoscr_state
        STR     R0, autoscr_state
        BL      update_autoscroll_flags
        LDR     R0, autoscr_state

        CLRV
        TEQ     R0, R1
        EXIT    EQ                      ; no change

        LDR     R14, autoscr_rout
        TEQ     R14, #0
        EXIT    EQ                      ; no pointer update routine

        CLRV                            ; make sure clean on entry
        Push    "wsptr"
        LDR     R14, autoscr_rout
        Push    "R14"                   ; store new PC
        LDR     R14, autoscr_wsptr
        Push    "R14"                   ; store new wsptr
        MOV     R14, PC                 ; gets PC+8
        Pull    "wsptr, PC"             ; BL [autoscr_rout]
        Pull    "wsptr"                 ; retrieve Wimp wsptr
        EXIT

update_autoscroll_flags
; Updates status flag bits to reflect current state
        Entry   "R0-y1,handle,userblk"
        ADRL    R14, autoscr_state
        LDMIA   R14, {R0, R1, cx0, cy0, cx1, cy1}

        TST     R0, #af_enable
        MOVEQ   R0, #0                  ; if turned off, zero all bits and exit
        STREQ   R0, autoscr_state
        STREQB  R0, autoscr_scrolling
        STREQB  R0, autoscr_pausing
        EXIT    EQ

        LDR     R14, =af_status_bits    ; all bits default to 0
        BIC     userblk, R0, R14        ; keep in userblk until end of routine

        Abs     handle, R1
        LDR     R0, mousexpos
        LDR     R1, mouseypos

        ADD     R14, handle, #w_wax0
        LDMIA   R14, {cx0, cy0, cx1, cy1} ; cx0-cy1 = visible area
        SUB     cx1, cx1, #1              ; make inclusive
        SUB     cy1, cy1, #1

        BL      get_centre_zone         ; x0-y1 = centre zone
        SUB     x1, x1, #1              ; make inclusive
        SUB     y1, y1, #1

        CMP     cx0, R0                 ; is pointer outside visible area?
        CMPLE   R0, cx1
        CMPLE   cy0, R1
        CMPLE   R1, cy1
        ORRGT   userblk, userblk, #af_ptrout
        BGT     %FT01

        CMP     x0, R0                  ; is it in the centre, or a pause zone?
        CMPLE   R0, x1
        CMPLE   y0, R1
        CMPLE   R1, y1
        ORRGT   userblk, userblk, #af_ptrpause
        ORRLE   userblk, userblk, #af_ptrin
        MOVLE   R14, #0
        STRLEB  R14, autoscr_scrolling  ; deactivate scrolling if in centre
        STRLEB  R14, autoscr_pausing
01
        LDRB    R14, autoscr_scrolling  ; read separate flag for this
        TEQ     R14, #0
        ORRNE   userblk, userblk, #af_scrolling

        CMP     R0, x0                  ; is it in the left pause zone?
        ORRLT   userblk, userblk, #af_ptrleft

        CMP     R1, y0                  ; is it in the down pause zone?
        ORRLT   userblk, userblk, #af_ptrdown

        CMP     R0, x1                  ; is it in the right pause zone?
        ORRGT   userblk, userblk, #af_ptrright

        CMP     R1, y1                  ; is it in the up pause zone?
        ORRGT   userblk, userblk, #af_ptrup

        ADD     R14, handle, #w_wax0    ; get visible area and scroll offsets
        LDMIA   R14, {cx0, cy0, cx1, cy1, x0, y1}
        SUB     cx1, cx1, cx0           ; convert to work area coordinates
        SUB     cy0, cy0, cy1
        MOV     cx0, x0
        MOV     cy1, y1
        ADD     cx1, cx1, cx0
        ADD     cy0, cy0, cy1

        ADD     R14, handle, #w_wex0    ; get work area extent
        LDMIA   R14, {x0, y0, x1, y1}

        CMP     cx0, x0                 ; is there space to move left?
        ORRGT   userblk, userblk, #af_canleft

        CMP     cy0, y0                 ; is there space to move down?
        ORRGT   userblk, userblk, #af_candown

        CMP     cx1, x1                 ; is there space to move right?
        ORRLT   userblk, userblk, #af_canright

        CMP     cy1, y1                 ; is there space to move up?
        ORRLT   userblk, userblk, #af_canup

        AND     R0, userblk, #af_enable
        TEQ     R0, #af_vertical        ; do we clear the horizontal bits?
        BICEQ   userblk, userblk, #af_status_horiz

        TEQ     R0, #af_horizontal      ; do we clear the vertical bits?
        BICEQ   userblk, userblk, #af_status_vert

        STR     userblk, autoscr_state
        EXIT

get_centre_zone
; In:  handle = autoscroll window handle
; Out: x0-y0  = centre zone (may be zero width or height)
        Entry   "cx0-cy1"
        ADRL    R14, autoscr_pz_x0      ; load zone sizes
        LDMIA   R14, {cx0, cy0, cx1, cy1}

        CMP     cx0, #0                 ; can't be negative
        MOVLT   cx0, #0
        CMP     cy0, #0
        MOVLT   cy0, #0
        CMP     cx1, #0
        MOVLT   cx1, #0
        CMP     cy1, #0
        MOVLT   cy1, #0

        LDR     R14, autoscr_state
        AND     R14, R14, #af_enable
        TEQ     R14, #af_vertical       ; if just vertical scrolling,
        MOVEQ   cx0, #0                 ; don't supply horizontal pause zones
        MOVEQ   cx1, #0
        TEQ     R14, #af_horizontal     ; if just horizontal scrolling,
        MOVEQ   cy0, #0                 ; don't supply vertical pause zones
        MOVEQ   cy1, #0

        ADD     R14, handle, #w_wax0    ; load visible area
        LDMIA   R14, {x0, y0, x1, y1}

        ADD     x0, x0, cx0             ; add on the specified borders
        SUB     x1, x1, cx1
        ADD     y0, y0, cy0
        SUB     y1, y1, cy1

        CMP     x1, x0                  ; if x pause zone won't fit
        ADDLT   x1, x1, x0
        MOVLT   x0, x1, LSR#1           ; find the middle of the overlap
        MOVLT   x1, x0

        CMP     y1, y0                  ; if y pause zone won't fit
        ADDLT   y1, y1, y0
        MOVLT   y0, y1, LSR#1           ; find the middle of the overlap
        MOVLT   y1, y0

        EXIT

autoscroll_pointer_routine_1
; handles pointer changes according to the default rules
; In: R0 = new autoscroll state
;     R1 = old autoscroll state
        Entry   "R0-R7"
        TST     R0, #af_scrolling       ; don't show pointer if not scrolling
        MOVEQ   R0, #0
        TST     R1, #af_scrolling
        MOVEQ   R1, #0

        AND     R0, R0, R0, LSL #4      ; only consider directions in which we
        AND     R0, R0, #af_status_can  ; can scroll *and* where the pointer is
        AND     R1, R1, R1, LSL #4      ; suitably positioned
        AND     R1, R1, #af_status_can

        TEQ     R0, #0                  ; reduce to on/off status
        MOVNE   R0, #1
        TEQ     R1, #0
        MOVNE   R1, #1

        TEQ     R0, R1                  ; don't do anything if status constant
        EXIT    EQ

        TEQ     R0, #0                  ; is it being turned on or off?
        BEQ     %FT10

        ; turn *on* autoscroll pointer

        ADRL    R4, autoscr_old_ptr_colours

        MOV     R0, #1                  ; remember old colour 1
        MOV     R1, #&19
        SWI     XOS_ReadPalette
        BIC     R2, R2, #&FF
        STR     R2, [R4], #4

        MOV     R0, #2                  ; remember old colour 2
        MOV     R1, #&19
        SWI     XOS_ReadPalette
        BIC     R2, R2, #&FF
        STR     R2, [R4], #4

        MOV     R0, #3                  ; remember old colour 3
        MOV     R1, #&19
        SWI     XOS_ReadPalette
        BIC     R2, R2, #&FF
        STR     R2, [R4], #4

        ASSERT  autoscr_old_ptr_number - autoscr_old_ptr_colours = 3*4
        MOV     R0,#&6A                 ; set/read pointer shape no
        MOV     R1,#127                 ; this is invalid, so won't be set
        SWI     XOS_Byte                ; R1 := actual shape number
        AND     R1, R1, #&F             ; forget linkage flag
        STRB    R1, [R4]                ; remember old pointer number

        ADR     R0, autoscroll_pointers
        LDR     R2, [sp]                ; get R0 from stack
        AND     R2, R2, #af_enable      ; get allowed directions
        SUB     R2, R2, #1
        ADD     R2, R0, R2, LSL#4       ; point at the details for relevant ptr

        MOV     R0, #SpriteReason_ReadSpriteSize
        SWI     XWimp_SpriteOp
        MOV     R5, R4, LSR#1           ; active point y-offset
        MOV     R4, R3, LSR#1           ; active point x-offset

        TEQ     R1, #1                  ; does pointer number need changing?
        MOVEQ   R3, #&61                ; just change shape
        MOVNE   R3, #&21                ; change number and shape
                                        ; bit 5 clear => uses Wimp palette
        MOV     R6, #0                  ; scale for mode
        MOV     R7, #0                  ; no translation table
        MOV     R0, #SpriteReason_SetPointerShape
        SWI     XWimp_SpriteOp

        CLRV
        EXIT

10      ; turn *off* autoscroll pointer
        LDRB    R3, autoscr_old_ptr_number
        TEQ     R3, #1

        MOVNE   R0, #SpriteReason_SetPointerShape
        MOVNE   R2, #0
        ORRNE   R3, R3, #&30            ; just change number
        MOVNE   R4, #0
        MOVNE   R5, #0
        MOVNE   R6, #0
        MOVNE   R7, #0
        SWINE   XWimp_SpriteOp

        MOV     R0, #SpriteReason_SetPointerShape
        ADRL    R2, ptr_default2
        MOV     R3, #&61                ; just change shape 1 to ptr_default
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XWimp_SpriteOp

        ADRL    R2, autoscr_old_ptr_colours

        LDR     R0, [R2], #4            ; R0 = &BBGGRR00
        MOV     R1, R0, LSR#24          ; R1 = &BB
        MOV     R0, R0, LSL#8           ; R0 = &GGRR0000
        LDR     R3, =&1901
        ORR     R0, R0, R3
        Push    "R0, R1"
        MOV     R0, #OsWord_WritePalette
        MOV     R1, sp
        SWI     XOS_Word                ; restore original pointer colour 1
        ADD     sp, sp, #8

        LDR     R0, [R2], #4            ; R0 = &BBGGRR00
        MOV     R1, R0, LSR#24          ; R1 = &BB
        MOV     R0, R0, LSL#8           ; R0 = &GGRR0000
        LDR     R3, =&1902
        ORR     R0, R0, R3
        Push    "R0, R1"
        MOV     R0, #OsWord_WritePalette
        MOV     R1, sp
        SWI     XOS_Word                ; restore original pointer colour 2
        ADD     sp, sp, #8

        LDR     R0, [R2], #4            ; R0 = &BBGGRR00
        MOV     R1, R0, LSR#24          ; R1 = &BB
        MOV     R0, R0, LSL#8           ; R0 = &GGRR0000
        LDR     R3, =&1903
        ORR     R0, R0, R3
        Push    "R0, R1"
        MOV     R0, #OsWord_WritePalette
        MOV     R1, sp
        SWI     XOS_Word                ; restore original pointer colour 3
        ADD     sp, sp, #8

        CLRV
        EXIT

autoscroll_pointers
        DCB     "ptr_autoscrh", 0, 0, 0, 0
        DCB     "ptr_autoscrv", 0, 0, 0, 0
        DCB     "ptr_autoscr", 0, 0, 0, 0, 0

poll_autoscroll
; Called during poll - update scroll flags, issue open/scroll rqs if necessary
        EntryS  "R0-cy1"
        LDR     R0, autoscr_state
        BL      update_autoscroll_state

        LDRB    R0, autoscr_scrolling   ; what we do depends upon current state
        TEQ     R0, #0
        BNE     continueautoscroll
        LDRB    R0, autoscr_pausing
        TEQ     R0, #0
        BNE     %FT10

        ; Neither pausing nor scrolling
        LDR     R0, autoscr_state
        TST     R0, #af_ptrin
        EXITS   NE                      ; nothing to do in centre

        LDR     R1, autoscr_pause
        TEQ     R1, #0                  ; if no pause, start scrolling
        BEQ     startautoscroll         ; as soon as we leave the centre

        TST     R0, #af_ptrout
        EXITS   NE                      ; can't do anything if outside

        SWI     XOS_ReadMonotonicTime   ; R0 = current time
        ADD     R0, R0, R1              ; R0 = time when pause ends
        STR     R0, autoscr_next_t
        LDR     R0, mousexpos           ; recalculate pause end time
        STR     R0, autoscr_last_x      ; if these change subsequently
        LDR     R0, mouseypos           ;
        STR     R0, autoscr_last_y      ;
        MOV     R0, #-1
        STRB    R0, autoscr_pausing     ; mark pausing
        EXITS

10      ; Pausing
        LDR     R0, autoscr_state
        TST     R0, #af_ptrpause
        MOVEQ   R0, #0                  ; abandon the pause if no longer in
        STREQB  R0, autoscr_pausing     ; the pause zone(s)
        EXITS   EQ

        SWI     XOS_ReadMonotonicTime   ; R0 = current time
        LDR     cx0, mousexpos
        LDR     cx1, autoscr_last_x
        TEQ     cx0, cx1
        LDREQ   cy0, mouseypos
        LDREQ   cy1, autoscr_last_y
        TEQEQ   cy0, cy1

        LDRNE   R1, autoscr_pause       ; if the pointer's moved, update the
        ADDNE   R0, R0, R1              ; pointer position and pause end time
        STRNE   R0, autoscr_next_t
        STRNE   cx0, autoscr_last_x
        STRNE   cy0, autoscr_last_y
        EXITS   NE

        LDR     R1, autoscr_next_t      ; exit if pause hasn't finished
        CMP     R0, R1
        EXITS   LO                      ; else drop through to startautoscroll

startautoscroll
        MOV     R0, #-1                 ; set flags as necessary
        STRB    R0, autoscr_scrolling
        MOV     R0, #0
        STRB    R0, autoscr_pausing
        LDR     R0, autoscr_state
        BL      update_autoscroll_state

        SWI     XOS_ReadMonotonicTime   ; R0 = current time
        STR     R0, autoscr_last_t
        ADD     R0, R0, #autoscr_update_delay
        STR     R0, autoscr_next_t

        LDR     R0, autoscr_state
        TST     R0, #af_scrollrq        ; if issuing Open_Window_Requests,
        EXITS   EQ                      ; don't do anything else at this time

        LDR     handle, autoscr_handle
        Abs     handle, handle
        LDR     R0, [handle, #w_taskhandle]
        Task    "R0",, "Autoscroll start"
        ADD     sp, sp, #Proc_RegOffset+7*4     ; skip stuff pushed to stack
        MOV     R1, #0                          ; x scroll "direction"
        MOV     R2, #0                          ; y scroll "direction"
        B       userscroll                      ; return Scroll_Request event

continueautoscroll
        LDRB    R0, autoscr_pausing     ; check flag - ensure control passes
        TEQ     R0, #0                  ; further down the Wimp_Poll action
        MOVNE   R0, #0                  ; list at least once per window update
        STRB    R0, autoscr_pausing
        EXITS   NE

        SWI     XOS_ReadMonotonicTime   ; R0 = current time
        LDR     R1, autoscr_next_t
        CMP     R1, R0
        EXITS   HI                      ; give other events a chance

        MOV     R1, #-1
        STRB    R1, autoscr_pausing     ; give other events a chance next time

        LDR     R1, autoscr_last_t
        SUB     R1, R0, R1              ; time since last update
        STR     R1, tempworkspace       ; keep in case we need it later
        STR     R0, autoscr_last_t
        ADD     R0, R0, #autoscr_update_delay
        STR     R0, autoscr_next_t

        LDR     handle, autoscr_handle
        Abs     handle, handle
        LDR     R0, [handle, #w_taskhandle]
        Task    "R0",, "Autoscroll continue"

        LDR     R0, autoscr_state
        TST     R0, #af_scrollrq
        AND     R0, R0, R0, LSL#4       ; clear "can" bits where pointer isn't
        BEQ     continueautoscroll_open

        ADD     sp, sp, #Proc_RegOffset+7*4     ; skip stuff pushed to stack
        MOV     R1, #0                  ; determine scroll "directions"
        MOV     R2, #0
        TST     R0, #af_canleft
        MOVNE   R1, #-3
        TST     R0, #af_candown
        MOVNE   R2, #-3
        TST     R0, #af_canright
        MOVNE   R1, #+3
        TST     R0, #af_canup
        MOVNE   R2, #+3
        B       userscroll              ; return Scroll_Request event

continueautoscroll_open
        TST     R0, #af_status_can
        EXITS   EQ                      ; don't do anything if we can't scroll

        ADD     sp, sp, #Proc_RegOffset+7*4     ; skip stuff pushed to stack
        ADD     R14, handle, #w_wax0
        LDMIA   R14, {cx0, cy0, cx1, cy1, x0, y0}
        STMIA   userblk, {R0, cx0, cy0, cx1, cy1}

        MOV     cx0, x0                 ; old scroll offsets
        MOV     cy0, y0
        BL      get_centre_zone         ; overwrites x0-y1
        LDR     R14, dx
        SUB     x1, x1, R14             ; make inclusive
        LDR     R14, dy
        SUB     y1, y1, R14

        LDR     R14, tempworkspace      ; retrieve time since last update
        LDR     R1, mousexpos           ; find pointer x offset from window
        TST     R0, #af_canleft
        SUBNE   R1, R1, x0
        SUBEQ   R1, R1, x1
        TST     R0, #af_status_horiz
        MULNE   R1, R14, R1             ; multiply by time, and scale down
        MOVNE   R1, R1, ASR#autoscr_speed_factor
        TEQ     R1, #0
        LDRPL   R14, dx                 ; compensate for the asymmetric effect
        ADDPL   R1, R1, R14             ; of the rounding-down in OpenWindow
        TST     R0, #af_status_horiz
        ADDNE   cx0, cx0, R1            ; add to old scroll offset

        LDR     R14, tempworkspace      ; retrieve time since last update
        LDR     R1, mouseypos           ; find pointer y offset from window
        TST     R0, #af_candown
        SUBNE   R1, R1, y0
        SUBEQ   R1, R1, y1
        TST     R0, #af_status_vert
        MULNE   R1, R14, R1             ; multiply by time, and scale down
        MOVNE   R1, R1, ASR#autoscr_speed_factor
        TEQ     R1, #0
        LDRPL   R14, dy                 ; compensate for the asymmetric effect
        ADDPL   R1, R1, R14             ; of the rounding-down in OpenWindow
        TST     R0, #af_status_vert
        ADDNE   cy0, cy0, R1            ; add to old scroll offset

        Rel     cx1, handle             ; finish writing to [userblk]
        STR     cx1, [userblk, #u_handle]
        ADD     R14, userblk, #u_scx
        STMIA   R14, {cx0, cy0, cx1}    ; store scx, scy, bhandle

        B       Exit_OpenWindow         ; finally, get the window re-opened!

      ]
        LTORG
        DCD     12648430                ; amuse the hackers... ;-)
        END
@


4.4
log
@Fixed a stack imbalance in autoscroll code in 32-bit builds.

Version 4.59. Tagged as 'Wimp-4_59'
@
text
@d108 1
a108 1
        MyXError  WimpBadPtrInR1, LT, L
d125 1
a125 1
        MyXError  WimpBadPtrInR1, LT, L
d166 2
a167 2
        CMP     y0, #&8000
        BGE     %FT01                   ; if a user routine, leave alone
d570 1
a570 1
        EXITS   LT                      ; else drop through to startautoscroll
d608 1
a608 1
        EXITS   GT                      ; give other events a chance
@


4.3
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d593 4
a596 4
        ADD     sp, sp, #7*4            ; skip stuff pushed to stack
        MOV     R1, #0                  ; x scroll "direction"
        MOV     R2, #0                  ; y scroll "direction"
        B       userscroll              ; return Scroll_Request event
d630 1
a630 1
        ADD     sp, sp, #7*4            ; skip stuff pushed to stack
d647 1
a647 1
        ADD     sp, sp, #7*4            ; skip stuff pushed to stack
@


4.2
log
@Adapted assembly process so that the choice of Options file (previously based
purely on the "System" variable) can be overridden by passing "OPTIONS=foo" as
an argument to either MkRom, or to amu/amu_machine directly, or indirectly,
by specifying it in the components file for a build. To accomplish this, it
was necessary to switch from using aasm to objasm - hence the large number of
source files affected in this commit.

Version 4.09. Tagged as 'Wimp-4_09'
@
text
@d103 1
a103 1
        
d106 1
a106 1
        
d110 1
a110 1
        
d114 1
a114 1
        
d117 1
a117 1
01        
d119 1
a119 1
        
d127 1
a127 1
        
d130 1
a130 1
        
d134 1
a134 1
        
d157 1
a157 1
        
d160 1
a160 1
        
d165 1
a165 1
        
d168 1
a168 1
        
d173 1
a173 1
        
d176 1
a176 1
        
d178 2
a179 1
        
d181 2
a182 2
        EXITS   NE
        
d195 2
a196 1
        EXITS
d206 2
a207 1
        
d209 2
a210 2
        EXITS   EQ                      ; no change
        
d213 2
a214 2
        EXITS   EQ                      ; no pointer update routine
        
d221 1
a221 1
        MOV     R14, PC                 ; gets PC+12
a222 1
        NOP
d224 1
a224 1
        EXITS
d237 2
a238 2
        EXITS   EQ
        
d241 1
a241 1
        
d245 1
a245 1
        
d250 1
a250 1
        
d254 1
a254 1
        
d261 1
a261 1
        
d271 1
a271 1
01      
d275 1
a275 1
        
d278 1
a278 1
        
d281 1
a281 1
        
d284 1
a284 1
        
d287 1
a287 1
        
d296 1
a296 1
        
d299 1
a299 1
        
d302 1
a302 1
        
d305 1
a305 1
        
d308 1
a308 1
        
d311 1
a311 1
        
d315 1
a315 1
        
d318 1
a318 1
        
d320 1
a320 1
        EXITS
d328 1
a328 1
        
d337 1
a337 1
        
d346 1
a346 1
        
d349 1
a349 1
        
d354 1
a354 1
        
d359 1
a359 1
        
d364 2
a365 2
        
        EXITS
d376 1
a376 1
        
d381 1
a381 1
        
d386 1
a386 1
        
d388 2
a389 2
        EXITS   EQ
        
d392 1
a392 1
        
d394 1
a394 1
        
d396 1
a396 1
        
d402 1
a402 1
        
d408 1
a408 1
        
d414 1
a414 1
        
d427 1
a427 1
        
d432 1
a432 1
        
d441 4
a444 3
        
        EXITS
        
d448 1
a448 1
        
d457 1
a457 1
        
d466 1
a466 1
        
d468 1
a468 1
        
d479 1
a479 1
        
d490 1
a490 1
        
d501 3
a503 2
        
        EXITS
d512 1
a512 1
        Entry   "R0-cy1"
d515 1
a515 1
        
d522 1
a522 1
        
d527 1
a527 1
        
d531 1
a531 1
        
d534 1
a534 1
        
d545 1
a545 1
        
d552 1
a552 1
        
d560 1
a560 1
        
d567 1
a567 1
        
d571 1
a571 1
        
d579 1
a579 1
        
d584 1
a584 1
        
d588 1
a588 1
        
d597 1
a597 1
        
d604 1
a604 1
        
d609 1
a609 1
        
d612 1
a612 1
        
d619 1
a619 1
        
d624 1
a624 1
        
d629 1
a629 1
        
d642 1
a642 1
        
d646 1
a646 1
        
d651 1
a651 1
        
d659 1
a659 1
        
d673 1
a673 1
        
d687 1
a687 1
        
d692 1
a692 1
        
@


4.1
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d152 1
a152 1
        ENTRY   "R0-x1"
d199 1
a199 1
        ENTRY   "R0-R2"
d226 1
a226 1
        ENTRY   "R0-y1,handle,userblk"
d323 1
a323 1
        ENTRY   "cx0-cy1"
d369 1
a369 1
        ENTRY   "R0-R7"
d508 1
a508 1
        ENTRY   "R0-cy1"
@


1.1
log
@file AutoScroll was initially added on branch Ursula.
@
text
@d1 694
@


1.1.2.1
log
@New features:
Dragboxes can now be clipped by and/or fixed to a given window's work area
SWI Wimp_AutoScroll implemented
Ursula icon highlighting scheme redesigned

Bugfixes:
Wimp_Extend 11 now performs the same check on R1 as the main SWI handling code
Message blocks now updated if in a dynamic area
Screenblanker now turned off when error box is displayed
ptr_double now turned off when a drag starts
@
text
@a0 689
; Copyright 1998 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Wimp.s.AutoScroll

;;-----------------------------------------------------------------------------
;; Automatic window scrolling
;;-----------------------------------------------------------------------------

      [ Autoscr

; Flags layout

af_enable       *       2_00000000000000000000000000000011
af_horizontal   *       2_00000000000000000000000000000001
af_vertical     *       2_00000000000000000000000000000010
af_scrollrq     *       2_00000000000000000000000000000100
af_read         *       2_00000000000000000000000010000000
af_scrolling    *       2_00000000000000000000000100000000
af_ptrout       *       2_00000000000000000000001000000000
af_ptrpause     *       2_00000000000000000000010000000000
af_ptrin        *       2_00000000000000000000100000000000
af_ptrleft      *       2_00000000000000000001000000000000
af_ptrdown      *       2_00000000000000000010000000000000
af_ptrright     *       2_00000000000000000100000000000000
af_ptrup        *       2_00000000000000001000000000000000
af_canleft      *       2_00000000000000010000000000000000
af_candown      *       2_00000000000000100000000000000000
af_canright     *       2_00000000000001000000000000000000
af_canup        *       2_00000000000010000000000000000000
af_status_bits  *       2_00000000000011111111111100000000
af_status_can   *       2_00000000000011110000000000000000
af_status_horiz *       2_00000000000001010000000000000000
af_status_vert  *       2_00000000000010100000000000000000

; Block definition
                ^       0
a_handle        #       4
a_pausex0       #       4
a_pausey0       #       4
a_pausex1       #       4
a_pausey1       #       4
a_pauselen      #       4
a_rout          #       4
a_wsptr         #       4

;;-----------------------------------------------------------------------------
;; SWI Wimp_AutoScroll
;;
;; in   R0 = autoscroll state flags
;;           bit 0 set => enable horizontal scrolling
;;           bit 1 set => enable vertical scrolling
;;           bit 2 set => send Scroll_Request instead of Open_Window_Request
;;           bit 7 set => just read current states of flags/block
;;      R1 -> block
;;           +0  window handle to scroll (must be owned by task)
;;           +4  left pause zone size
;;           +8  bottom pause zone size
;;           +12 right pause zone size
;;           +16 top pause zone size
;;           +20 pause duration (0 = pause not required, -1 = default length)
;;           +24 pointer-changing routine (0 for none, 1 for default)
;;           +28 workspace pointer for routine (if [R1,#24] >= &8000)
;; out  R0 = new autoscroll state flags
;;           bits 0-2 preserved, or (if bit 7 set on entry) read
;;           bit 7 clear
;;           bit 8  set => pause complete
;;           bit 9  set => pointer not over visible area rectangles
;;           bit 10 set => pointer over pause zone(s) rectangles
;;           bit 11 set => pointer over centre zone rectangles
;;           bit 12 set => pointer left of centre zone
;;           bit 13 set => pointer below centre zone
;;           bit 14 set => pointer right of centre zone
;;           bit 15 set => pointer above centre zone
;;           bit 16 set => there is work area left of the visible area
;;           bit 17 set => there is work area below the visible area
;;           bit 18 set => there is work area right of the visible area
;;           bit 19 set => there is work area above the visible area
;;-----------------------------------------------------------------------------

SWIWimp_AutoScroll
        TST     R0, #af_read
        BNE     return_autoscroll_state ; Wimp_Init not necessary to read state

        LDR     R14, taskhandle
        LDR     R14, [wsptr, R14]
        TST     R14, #task_unused
        MyXError  WimpBadOp, NE, L
        BVS     ExitWimp                ; check alive
        
        TST     R0, #af_enable
        BEQ     %FT01                   ; don't bother validating if disabling
        
        CMP     userblk, #ApplicationStart
        MyXError  WimpBadPtrInR1, LT, L
        BVS     ExitWimp                ; then check pointer
        
        LDR     handle, [userblk, #a_handle]
        BL      checkhandle_owner
        BVS     ExitWimp                ; then check it's one of our windows
        
        ASSERT  a_handle = 0
        LDMIA   userblk, {R1, cx0, cy0, cx1, cy1, x0, y0, x1}
01        
        BL      int_autoscroll
        
        LDRVC   R0, autoscr_state
        B       ExitWimp

return_autoscroll_state
        CMP     userblk, #ApplicationStart
        MyXError  WimpBadPtrInR1, LT, L
        BVS     ExitWimp                ; just check pointer
        
        ADR     R14, autoscr_state
        LDMIA   R14, {R0, R1, cx0, cy0, cx1, cy1, x0, y0, x1}
        
        TST     R0, #af_enable
        ASSERT  a_handle = 0
        STMNEIA userblk, {R1, cx0, cy0, cx1, cy1, x0, y0, x1}
        
        B       ExitWimp

;;-----------------------------------------------------------------------------
;; int_autoscroll
;;
;; in   R0  = autoscroll state flags (see above)
;;      R1  = (external) window handle to scroll
;;      cx0 = left pause zone size
;;      cy0 = bottom pause zone size
;;      cx1 = right pause zone size
;;      cy1 = top pause zone size
;;      x0  = pause duration (0 = pause not required, -1 = default length)
;;      y0  = pointer routine (or 0 or 1)
;;      x1  = pointer routine workspace (if y0 >= &8000)
;;-----------------------------------------------------------------------------

int_autoscroll
        ENTRY   "R0-x1"
        MOV     R0, #0
        BL      update_autoscroll_state ; deactivate any existing autoscroll
                                        ; (does nothing if already off)
        LDR     R0, [sp]
        
        ADR     R14, autoscr_handle
        STMIA   R14, {R1, cx0, cy0, cx1, cy1, x0, y0, x1}
        
        CMP     x0, #-1                 ; default pause time requested?
        LDREQB  x0, autoscr_default_pause
        MOVEQ   x0, x0, LSL #1
        ADDEQ   x0, x0, x0, LSL #2      ; load default time *10 (ds -> cs)
        
        CMP     y0, #&8000
        BGE     %FT01                   ; if a user routine, leave alone
        
        TST     y0, #1                  ; NB if you add further types, keeping
        MOVEQ   y0, #0                  ; bit 0 set will guarantee that some
        ADRNE   y0, autoscroll_pointer_routine_1 ; sort of pointer is displayed
        MOV     x1, wsptr               ; even when running on this old Wimp
        
01      ADRL    R14, autoscr_pause
        STMIA   R14, {x0, y0, x1}
        
        BL      update_autoscroll_state
        
        TST     R0, #af_enable
        EXITS   NE
        
        MOV     R0, #SpriteReason_SetPointerShape
        ADRL    R14, special_pointer    ; if turned off, get pointer to sprite
        LDR     R14, [R14]              ; name to return shape number 1 to
        TEQ     R14, #0
        ADREQL  R2, ptr_default2
        ADRNEL  R2, pointer_sprite
        MOV     R3, #&61                ; just reprogram the shape
        MOV     R4, #0                  ; assume origin at top-left
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XWimp_SpriteOp
        EXITS

update_autoscroll_state
; In: R0 = new autoscroll state, in bits 0-4
; Sends a message to the autoscroll owner if the state (of any bit) has changed
        ENTRY   "R0-R2"
        LDR     R1, autoscr_state
        STR     R0, autoscr_state
        BL      update_autoscroll_flags
        LDR     R0, autoscr_state
        
        TEQ     R0, R1
        EXITS   EQ                      ; no change
        
        LDR     R14, autoscr_rout
        TEQ     R14, #0
        EXITS   EQ                      ; no pointer update routine
        
        CLRV                            ; make sure clean on entry
        Push    "wsptr"
        LDR     R14, autoscr_rout
        Push    "R14"                   ; store new PC
        LDR     R14, autoscr_wsptr
        Push    "R14"                   ; store new wsptr
        MOV     R14, PC                 ; gets PC+12
        Pull    "wsptr, PC"             ; BL [autoscr_rout]
        NOP
        Pull    "wsptr"                 ; retrieve Wimp wsptr
        EXITS

update_autoscroll_flags
; Updates status flag bits to reflect current state
        ENTRY   "R0-y1,handle,userblk"
        ADR     R14, autoscr_state
        LDMIA   R14, {R0, R1, cx0, cy0, cx1, cy1}

        TST     R0, #af_enable
        MOVEQ   R0, #0                  ; if turned off, zero all bits and exit
        STREQ   R0, autoscr_state
        STREQB  R0, autoscr_scrolling
        STREQB  R0, autoscr_pausing
        EXITS   EQ
        
        LDR     R14, =af_status_bits    ; all bits default to 0
        BIC     userblk, R0, R14        ; keep in userblk until end of routine
        
        Abs     handle, R1
        LDR     R0, mousexpos
        LDR     R1, mouseypos
        
        ADD     R14, handle, #w_wax0
        LDMIA   R14, {cx0, cy0, cx1, cy1} ; cx0-cy1 = visible area
        SUB     cx1, cx1, #1              ; make inclusive
        SUB     cy1, cy1, #1
        
        BL      get_centre_zone         ; x0-y1 = centre zone
        SUB     x1, x1, #1              ; make inclusive
        SUB     y1, y1, #1
        
        CMP     cx0, R0                 ; is pointer outside visible area?
        CMPLE   R0, cx1
        CMPLE   cy0, R1
        CMPLE   R1, cy1
        ORRGT   userblk, userblk, #af_ptrout
        BGT     %FT01
        
        CMP     x0, R0                  ; is it in the centre, or a pause zone?
        CMPLE   R0, x1
        CMPLE   y0, R1
        CMPLE   R1, y1
        ORRGT   userblk, userblk, #af_ptrpause
        ORRLE   userblk, userblk, #af_ptrin
        MOVLE   R14, #0
        STRLEB  R14, autoscr_scrolling  ; deactivate scrolling if in centre
        STRLEB  R14, autoscr_pausing
01      
        LDRB    R14, autoscr_scrolling  ; read separate flag for this
        TEQ     R14, #0
        ORRNE   userblk, userblk, #af_scrolling
        
        CMP     R0, x0                  ; is it in the left pause zone?
        ORRLT   userblk, userblk, #af_ptrleft
        
        CMP     R1, y0                  ; is it in the down pause zone?
        ORRLT   userblk, userblk, #af_ptrdown
        
        CMP     R0, x1                  ; is it in the right pause zone?
        ORRGT   userblk, userblk, #af_ptrright
        
        CMP     R1, y1                  ; is it in the up pause zone?
        ORRGT   userblk, userblk, #af_ptrup
        
        ADD     R14, handle, #w_wax0    ; get visible area and scroll offsets
        LDMIA   R14, {cx0, cy0, cx1, cy1, x0, y1}
        SUB     cx1, cx1, cx0           ; convert to work area coordinates
        SUB     cy0, cy0, cy1
        MOV     cx0, x0
        MOV     cy1, y1
        ADD     cx1, cx1, cx0
        ADD     cy0, cy0, cy1
        
        ADD     R14, handle, #w_wex0    ; get work area extent
        LDMIA   R14, {x0, y0, x1, y1}
        
        CMP     cx0, x0                 ; is there space to move left?
        ORRGT   userblk, userblk, #af_canleft
        
        CMP     cy0, y0                 ; is there space to move down?
        ORRGT   userblk, userblk, #af_candown
        
        CMP     cx1, x1                 ; is there space to move right?
        ORRLT   userblk, userblk, #af_canright
        
        CMP     cy1, y1                 ; is there space to move up?
        ORRLT   userblk, userblk, #af_canup
        
        AND     R0, userblk, #af_enable
        TEQ     R0, #af_vertical        ; do we clear the horizontal bits?
        BICEQ   userblk, userblk, #af_status_horiz
        
        TEQ     R0, #af_horizontal      ; do we clear the vertical bits?
        BICEQ   userblk, userblk, #af_status_vert
        
        STR     userblk, autoscr_state
        EXITS

get_centre_zone
; In:  handle = autoscroll window handle
; Out: x0-y0  = centre zone (may be zero width or height)
        ENTRY   "cx0-cy1"
        ADR     R14, autoscr_pz_x0      ; load zone sizes
        LDMIA   R14, {cx0, cy0, cx1, cy1}
        
        CMP     cx0, #0                 ; can't be negative
        MOVLT   cx0, #0
        CMP     cy0, #0
        MOVLT   cy0, #0
        CMP     cx1, #0
        MOVLT   cx1, #0
        CMP     cy1, #0
        MOVLT   cy1, #0
        
        LDR     R14, autoscr_state
        AND     R14, R14, #af_enable
        TEQ     R14, #af_vertical       ; if just vertical scrolling,
        MOVEQ   cx0, #0                 ; don't supply horizontal pause zones
        MOVEQ   cx1, #0
        TEQ     R14, #af_horizontal     ; if just horizontal scrolling,
        MOVEQ   cy0, #0                 ; don't supply vertical pause zones
        MOVEQ   cy1, #0
        
        ADD     R14, handle, #w_wax0    ; load visible area
        LDMIA   R14, {x0, y0, x1, y1}
        
        ADD     x0, x0, cx0             ; add on the specified borders
        SUB     x1, x1, cx1
        ADD     y0, y0, cy0
        SUB     y1, y1, cy1
        
        CMP     x1, x0                  ; if x pause zone won't fit
        ADDLT   x1, x1, x0
        MOVLT   x0, x1, LSR#1           ; find the middle of the overlap
        MOVLT   x1, x0
        
        CMP     y1, y0                  ; if y pause zone won't fit
        ADDLT   y1, y1, y0
        MOVLT   y0, y1, LSR#1           ; find the middle of the overlap
        MOVLT   y1, y0
        
        EXITS

autoscroll_pointer_routine_1
; handles pointer changes according to the default rules
; In: R0 = new autoscroll state
;     R1 = old autoscroll state
        ENTRY   "R0-R7"
        TST     R0, #af_scrolling       ; don't show pointer if not scrolling
        MOVEQ   R0, #0
        TST     R1, #af_scrolling
        MOVEQ   R1, #0
        
        AND     R0, R0, R0, LSL #4      ; only consider directions in which we
        AND     R0, R0, #af_status_can  ; can scroll *and* where the pointer is
        AND     R1, R1, R1, LSL #4      ; suitably positioned
        AND     R1, R1, #af_status_can
        
        TEQ     R0, #0                  ; reduce to on/off status
        MOVNE   R0, #1
        TEQ     R1, #0
        MOVNE   R1, #1
        
        TEQ     R0, R1                  ; don't do anything if status constant
        EXITS   EQ
        
        TEQ     R0, #0                  ; is it being turned on or off?
        BEQ     %FT10
        
        ; turn *on* autoscroll pointer
        
        ADRL    R4, autoscr_old_ptr_colours
        
        MOV     R0, #1                  ; remember old colour 1
        MOV     R1, #&19
        SWI     XOS_ReadPalette
        BIC     R2, R2, #&FF
        STR     R2, [R4], #4
        
        MOV     R0, #2                  ; remember old colour 2
        MOV     R1, #&19
        SWI     XOS_ReadPalette
        BIC     R2, R2, #&FF
        STR     R2, [R4], #4
        
        MOV     R0, #3                  ; remember old colour 3
        MOV     R1, #&19
        SWI     XOS_ReadPalette
        BIC     R2, R2, #&FF
        STR     R2, [R4], #4
        
        ASSERT  autoscr_old_ptr_number - autoscr_old_ptr_colours = 3*4
        MOV     R0,#&6A                 ; set/read pointer shape no
        MOV     R1,#127                 ; this is invalid, so won't be set
        SWI     XOS_Byte                ; R1 := actual shape number
        AND     R1, R1, #&F             ; forget linkage flag
        STRB    R1, [R4]                ; remember old pointer number

        ADR     R0, autoscroll_pointers
        LDR     R2, [sp]                ; get R0 from stack
        AND     R2, R2, #af_enable      ; get allowed directions
        SUB     R2, R2, #1
        ADD     R2, R0, R2, LSL#4       ; point at the details for relevant ptr
        
        TEQ     R1, #1                  ; does pointer number need changing?
        MOVEQ   R3, #&61                ; just change shape
        MOVNE   R3, #&21                ; change number and shape
                                        ; bit 5 clear => uses Wimp palette
        LDRB    R4, [R2, #14]           ; active point x-offset
        LDRB    R5, [R2, #15]           ; active point y-offset
        MOV     R6, #0                  ; scale for mode
        MOV     R7, #0                  ; no translation table
        MOV     R0, #SpriteReason_SetPointerShape
        SWI     XWimp_SpriteOp
        
        EXITS
        
10      ; turn *off* autoscroll pointer
        LDRB    R3, autoscr_old_ptr_number
        TEQ     R3, #1
        
        MOVNE   R0, #SpriteReason_SetPointerShape
        MOVNE   R2, #0
        ORRNE   R3, R3, #&30            ; just change number
        MOVNE   R4, #0
        MOVNE   R5, #0
        MOVNE   R6, #0
        MOVNE   R7, #0
        SWINE   XWimp_SpriteOp
        
        MOV     R0, #SpriteReason_SetPointerShape
        ADRL    R2, ptr_default2
        MOV     R3, #&61                ; just change shape 1 to ptr_default
        MOV     R4, #0
        MOV     R5, #0
        MOV     R6, #0
        MOV     R7, #0
        SWI     XWimp_SpriteOp
        
        ADRL    R2, autoscr_old_ptr_colours
        
        LDR     R0, [R2], #4            ; R0 = &BBGGRR00
        MOV     R1, R0, LSR#24          ; R1 = &BB
        MOV     R0, R0, LSL#8           ; R0 = &GGRR0000
        LDR     R3, =&1901
        AND     R0, R0, R3
        Push    "R0, R1"
        MOV     R0, #OsWord_WritePalette
        MOV     R1, sp
        SWI     XOS_Word                ; restore original pointer colour 1
        ADD     sp, sp, #8
        
        LDR     R0, [R2], #4            ; R0 = &BBGGRR00
        MOV     R1, R0, LSR#24          ; R1 = &BB
        MOV     R0, R0, LSL#8           ; R0 = &GGRR0000
        LDR     R3, =&1902
        AND     R0, R0, R3
        Push    "R0, R1"
        MOV     R0, #OsWord_WritePalette
        MOV     R1, sp
        SWI     XOS_Word                ; restore original pointer colour 2
        ADD     sp, sp, #8
        
        LDR     R0, [R2], #4            ; R0 = &BBGGRR00
        MOV     R1, R0, LSR#24          ; R1 = &BB
        MOV     R0, R0, LSL#8           ; R0 = &GGRR0000
        LDR     R3, =&1903
        AND     R0, R0, R3
        Push    "R0, R1"
        MOV     R0, #OsWord_WritePalette
        MOV     R1, sp
        SWI     XOS_Word                ; restore original pointer colour 3
        ADD     sp, sp, #8
        
        EXITS

autoscroll_pointers
        DCB     "ptr_autoscrh",   0, 0, 15, 4
        DCB     "ptr_autoscrv",   0, 0, 4,  15
        DCB     "ptr_autoscr", 0, 0, 0, 15, 15

poll_autoscroll
; Called during poll - update scroll flags, issue open/scroll rqs if necessary
        ENTRY   "R0-cy1"
        LDR     R0, autoscr_state
        BL      update_autoscroll_state
        
        LDRB    R0, autoscr_scrolling   ; what we do depends upon current state
        TEQ     R0, #0
        BNE     continueautoscroll
        LDRB    R0, autoscr_pausing
        TEQ     R0, #0
        BNE     %FT10
        
        ; Neither pausing nor scrolling
        LDR     R0, autoscr_state
        TST     R0, #af_ptrin
        EXITS   NE                      ; nothing to do in centre
        
        LDR     R1, autoscr_pause
        TEQ     R1, #0                  ; if no pause, start scrolling
        BEQ     startautoscroll         ; as soon as we leave the centre
        
        TST     R0, #af_ptrout
        EXITS   NE                      ; can't do anything if outside
        
        SWI     XOS_ReadMonotonicTime   ; R0 = current time
        ADD     R0, R0, R1              ; R0 = time when pause ends
        STR     R0, autoscr_next_t
        LDR     R0, mousexpos           ; recalculate pause end time
        STR     R0, autoscr_last_x      ; if these change subsequently
        LDR     R0, mouseypos           ;
        STR     R0, autoscr_last_y      ;
        MOV     R0, #-1
        STRB    R0, autoscr_pausing     ; mark pausing
        EXITS
        
10      ; Pausing
        LDR     R0, autoscr_state
        TST     R0, #af_ptrpause
        MOVEQ   R0, #0                  ; abandon the pause if no longer in
        STREQB  R0, autoscr_pausing     ; the pause zone(s)
        EXITS   EQ
        
        SWI     XOS_ReadMonotonicTime   ; R0 = current time
        LDR     cx0, mousexpos
        LDR     cx1, autoscr_last_x
        TEQ     cx0, cx1
        LDREQ   cy0, mouseypos
        LDREQ   cy1, autoscr_last_y
        TEQEQ   cy0, cy1
        
        LDRNE   R1, autoscr_pause       ; if the pointer's moved, update the
        ADDNE   R0, R0, R1              ; pointer position and pause end time
        STRNE   R0, autoscr_next_t
        STRNE   cx0, autoscr_last_x
        STRNE   cy0, autoscr_last_y
        EXITS   NE
        
        LDR     R1, autoscr_next_t      ; exit if pause hasn't finished
        CMP     R0, R1
        EXITS   LT                      ; else drop through to startautoscroll
        
startautoscroll
        MOV     R0, #-1                 ; set flags as necessary
        STRB    R0, autoscr_scrolling
        MOV     R0, #0
        STRB    R0, autoscr_pausing
        LDR     R0, autoscr_state
        BL      update_autoscroll_state
        
        SWI     XOS_ReadMonotonicTime   ; R0 = current time
        STR     R0, autoscr_last_t
        ADD     R0, R0, #autoscr_update_delay
        STR     R0, autoscr_next_t
        
        LDR     R0, autoscr_state
        TST     R0, #af_scrollrq        ; if issuing Open_Window_Requests,
        EXITS   EQ                      ; don't do anything else at this time
        
        LDR     handle, autoscr_handle
        Abs     handle, handle
        LDR     R0, [handle, #w_taskhandle]
        Task    "R0",, "Autoscroll start"
        ADD     sp, sp, #7*4            ; skip stuff pushed to stack
        MOV     R1, #0                  ; x scroll "direction"
        MOV     R2, #0                  ; y scroll "direction"
        B       userscroll              ; return Scroll_Request event
        
continueautoscroll
        LDRB    R0, autoscr_pausing     ; check flag - ensure control passes
        TEQ     R0, #0                  ; further down the Wimp_Poll action
        MOVNE   R0, #0                  ; list at least once per window update
        STRB    R0, autoscr_pausing
        EXITS   NE
        
        SWI     XOS_ReadMonotonicTime   ; R0 = current time
        LDR     R1, autoscr_next_t
        CMP     R1, R0
        EXITS   GT                      ; give other events a chance
        
        MOV     R1, #-1
        STRB    R1, autoscr_pausing     ; give other events a chance next time
        
        LDR     R1, autoscr_last_t
        SUB     R1, R0, R1              ; time since last update
        STR     R1, tempworkspace       ; keep in case we need it later
        STR     R0, autoscr_last_t
        ADD     R0, R0, #autoscr_update_delay
        STR     R0, autoscr_next_t
        
        LDR     handle, autoscr_handle
        Abs     handle, handle
        LDR     R0, [handle, #w_taskhandle]
        Task    "R0",, "Autoscroll continue"
        
        LDR     R0, autoscr_state
        TST     R0, #af_scrollrq
        AND     R0, R0, R0, LSL#4       ; clear "can" bits where pointer isn't
        BEQ     continueautoscroll_open
        
        ADD     sp, sp, #7*4            ; skip stuff pushed to stack
        MOV     R1, #0                  ; determine scroll "directions"
        MOV     R2, #0
        TST     R0, #af_canleft
        MOVNE   R1, #-3
        TST     R0, #af_candown
        MOVNE   R2, #-3
        TST     R0, #af_canright
        MOVNE   R1, #+3
        TST     R0, #af_canup
        MOVNE   R2, #+3
        B       userscroll              ; return Scroll_Request event
        
continueautoscroll_open
        TST     R0, #af_status_can
        EXITS   EQ                      ; don't do anything if we can't scroll
        
        ADD     sp, sp, #7*4            ; skip stuff pushed to stack
        ADD     R14, handle, #w_wax0
        LDMIA   R14, {cx0, cy0, cx1, cy1, x0, y0}
        STMIA   userblk, {R0, cx0, cy0, cx1, cy1}
        
        MOV     cx0, x0                 ; old scroll offsets
        MOV     cy0, y0
        BL      get_centre_zone         ; overwrites x0-y1
        LDR     R14, dx
        SUB     x1, x1, R14             ; make inclusive
        LDR     R14, dy
        SUB     y1, y1, R14
        LDR     R14, tempworkspace      ; retrieve time since last update
        
        LDR     R1, mousexpos           ; find pointer x offset from window
        TST     R0, #af_canleft
        SUBNE   R1, R1, x0
        SUBEQ   R1, R1, x1
        TST     R0, #af_status_horiz
        MULNE   R1, R14, R1             ; multiply by time, and scale down
        MOVNE   R1, R1, ASR#autoscr_speed_factor
        TEQ     R1, #0
        LDRPL   R14, dx                 ; compensate for the asymmetric effect
        ADDPL   R1, R1, R14             ; of the rounding-down in OpenWindow
        TST     R0, #af_status_horiz
        ADDNE   cx0, cx0, R1            ; add to old scroll offset
        
        LDR     R1, mouseypos           ; find pointer y offset from window
        TST     R0, #af_candown
        SUBNE   R1, R1, y0
        SUBEQ   R1, R1, y1
        TST     R0, #af_status_vert
        MULNE   R1, R14, R1             ; multiply by time, and scale down
        MOVNE   R1, R1, ASR#autoscr_speed_factor
        TEQ     R1, #0
        LDRPL   R14, dy                 ; compensate for the asymmetric effect
        ADDPL   R1, R1, R14             ; of the rounding-down in OpenWindow
        TST     R0, #af_status_vert
        ADDNE   cy0, cy0, R1            ; add to old scroll offset
        
        Rel     cx1, handle             ; finish writing to [userblk]
        STR     cx1, [userblk, #u_handle]
        ADD     R14, userblk, #u_scx
        STMIA   R14, {cx0, cy0, cx1}    ; store scx, scy, bhandle
        
        B       Exit_OpenWindow         ; finally, get the window re-opened!


        LTORG
        DCD     12648430                ; amuse the hackers... ;-)
      ]
        END
@


1.1.2.2
log
@Redraw of dragboxes when being resized/translated optimised to reduce flicker.

Autoscroll update period extended to 12cs to reduce flicker.

Added Wimp_ReadSysInfo 17 to return configured drag-and-drop scroll startup
delay (in cs) because the CMOS storage isn't easy to read.

Identified and bracketed changes from 3.9x responsible for 24-bit icon colours.

defaultfontcolours now works correctly again.

Introduced new icon colour code. This holds icon colours in 24 bits internally
throughout, rather than treating 24-bit colour specifiers as a special case.
This results in the following bugfixes/improvements:
 * 3D faces and moat colours, and slabbed-in action button backgrounds, can
   all be specified in 24-bits
 * fading of icons is now consistent across icon types, and utilises the
   colour range of >16 colour modes
 * 3D borders now get faded along with the rest of the icon
 * action buttons can now contain sprites (background is correct, and sprite
   is not inverted)
 * various cases where anti-aliasing didn't blend in to the background
   correctly are now fixed
 * conventional and 24-bit specifiers now behave equivalently to each other -
   the same colour specified either way behaves the same when faded, used as
   an EOR colour etc. (greys are now always dithered in 1-bpp modes, even if
   specified in 24-bit)
 * behaviour is now the same whether the Wimp font is the system font or a
   fancy font (amazingly, this wasn't always the case)
 * except for 3D icons, if the icon background matches the work area
   background, it is unaffected by fading - so for example, group boxes can now
   be faded correctly

Switched out AutoHourglass (Mike was concerned about the speed hit).

Corrected *Help syntax strings for On/Off configuration options.
@
text
@d126 1
a126 1
        ADRL    R14, autoscr_state
d156 1
a156 1
        ADRL    R14, autoscr_handle
d225 1
a225 1
        ADRL    R14, autoscr_state
d322 1
a322 1
        ADRL    R14, autoscr_pz_x0      ; load zone sizes
@


1.1.2.3
log
@Bugfixes:

Re-opening a menu structure containing a dialogue box (especially one
containing the caret) was causing data aborts under some OSes/builds.

The minimum title bar length is now the same for windows without line borders,
even if the vertical scroll bar is also absent. This prevents cases when the
title bar shrunk so far that a graphics clipping error occurred.

Wimp_DragBox was looking in R0 for its flags, rather than R3, as specified!

If the pointer was to the right of the central zone, vertical autoscrolling
was working too slowly.

On Service_SwitchingOutputToSprite, the Wimp now re-assesses its idea of the
screen limits. This prevents Wimp_PlotIcon plots outside the current screen
bounds from being optimised out.
@
text
@d650 1
a651 1
        LDR     R14, tempworkspace      ; retrieve time since last update
a664 1
        LDR     R14, tempworkspace      ; retrieve time since last update
d685 1
a685 1
      ]
d688 1
@


1.1.2.4
log
@Window tool button type is now configurable.
Windows now keep the same depth when toggle-size tool is clicked with Adjust.
Fixed bug where drags in Eureka caused branch-through-zeros and other
miscellaneous errors.
Fixed a few stray non-X form SWI calls.
Extended applicability/functionality of "MyEntry" debug macro.
@
text
@a92 2
        MyEntry "AutoScroll"

@


1.1.2.5
log
@Corrected active point for autoscrolling pointers (was wrong in low-res modes).

Certain user-drawn dragbox routines (eg via DragASprite) don't pass the object
bounding box as the box; this was conflicting with one of the redraw
optimisations, and causing smearing when the underlying object was redrawn.
Relevant optimisation optioned out.

If a window stack-change causes the iconise button to appear or disappear,
this is now caught, and the window border is redrawn immediately.

Toggling of child windows now works - the return coordinates are linked to
the parent in the same way as the current ones. Note that this is unlikely to
be useful for anything other than alignment 0/0/0/0/0/0 children.

Return codes for the "Quit" and "Continue" buttons in "xxx may have gone wrong"
error boxes can now be specified.

Both scrollbars push in for adjust-drags.
@
text
@a425 5
        MOV     R0, #SpriteReason_ReadSpriteSize
        SWI     XWimp_SpriteOp
        MOV     R5, R4, LSR#1           ; active point y-offset
        MOV     R4, R3, LSR#1           ; active point x-offset
        
d430 2
d499 3
a501 3
        DCB     "ptr_autoscrh", 0, 0, 0, 0
        DCB     "ptr_autoscrv", 0, 0, 0, 0
        DCB     "ptr_autoscr", 0, 0, 0, 0, 0
@


1.1.2.6
log
@Text is now correctly justified when in an icon with validation string
commands R8, R9, R10, ...

R5/R6 type icons now behave more usefully with button types other than click,
release and auto-repeat.

Prevented coordinate overflow in dragboxes.

Stopped clipped dragboxes from flickering more than non-clipped ones.

Fixed a bug whereby data aborts occurred when generating the translation table
for inverted and/or shaded 256-colour sprites, if the first 256-colour sprite
plotted since the Wimp's cached translation table was invalidated (either by
Service_InvalidateCache or by plotting a 256-colour sprite after a non-256-
colour sprite one) was at an address that had since been invalidated or paged
out. This fixes a long-standing problem with 256-colour sprites in the desktop,
but which only happened sporadically.

Prevented palette corruption in paletted ( <256-colour) modes when the pointer
reverts from an autoscroll pointer to its original setting.

Fixed bug introduced in last build, where clicking on the bottom pixel row of a
horixontal scrollbar, or the left pixel column of a back icon, caused a crash.

All Wimp-drawn solid rectangles are now be plotted much faster - typically
around twice as fast - translating to a typical 30% increase in speed of
plotting filled icons. Improvements will be better still in cases where icons
are drawn in a non-contiguous order: this commonly affects Toolbox applications.

When a dialogue box is opened from a menu, the Wimp will no longer attempt to
place the caret in a shaded or deleted icon, but it will do so for a type-14
(writable/click/drag) icon, as well as the standard type-15 (writable) icons.
This brings it in line with KA-validation up/down arrow actions.
@
text
@d470 1
a470 1
        ORR     R0, R0, R3
d481 1
a481 1
        ORR     R0, R0, R3
d492 1
a492 1
        ORR     R0, R0, R3
@

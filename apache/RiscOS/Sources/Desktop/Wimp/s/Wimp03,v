head	4.33;
access;
symbols
	Wimp-5_62:4.33
	Wimp-5_61:4.33
	Wimp-5_60:4.33
	Wimp-5_59:4.32
	Wimp-5_58:4.32
	Wimp-5_57:4.32
	Wimp-5_56:4.32
	Wimp-5_55:4.32
	Wimp-5_54:4.32
	Wimp-5_53:4.32
	Wimp-5_52:4.32
	Wimp-5_51:4.32
	Wimp-5_50:4.31
	Wimp-5_49:4.31
	Wimp-5_48:4.31
	Wimp-5_47-file1ad:4.31
	Wimp-5_47:4.31
	Wimp-5_46:4.31
	Wimp-5_45:4.31
	Wimp-5_44:4.31
	Wimp-5_43:4.31
	Wimp-5_42:4.31
	Wimp-5_41:4.30
	Wimp-5_40:4.30
	Wimp-5_39:4.30
	Wimp-5_38:4.30
	Wimp-5_37:4.30
	Wimp-5_36:4.30
	Wimp-5_35:4.30
	Wimp-5_34:4.30
	Wimp-5_33:4.30
	Wimp-5_32:4.30
	Wimp-5_31:4.30
	Wimp-5_30:4.30
	Wimp-530-pre4:4.30
	Wimp-5_30-pre3:4.30
	Wimp-5_30-pre2:4.30
	Wimp-5_30-pre1:4.30
	Wimp-5_29:4.30
	Wimp-5_28:4.30
	Wimp-5_27:4.30
	Wimp-5_26:4.30
	Wimp-5_25:4.30
	Wimp-5_24:4.30
	Wimp-5_23:4.28
	Wimp-5_22:4.28
	Wimp-5_21:4.28
	Wimp-5_20:4.28
	Wimp-5_19:4.28
	Wimp-5_18:4.28
	Wimp-5_17:4.28
	Wimp-5_16:4.28
	Wimp-5_15:4.28
	Wimp-5_14:4.28
	Wimp-5_13:4.28
	Wimp-5_12:4.28
	Wimp-5_11:4.28
	Wimp-5_10:4.27
	Wimp-5_09:4.27
	Wimp-5_08:4.26
	Wimp-5_07:4.26
	Wimp-5_06:4.25
	Wimp-5_05:4.25
	Wimp-5_04:4.25
	Wimp-5_03:4.25
	Wimp-5_02:4.25
	Wimp-5_01:4.25
	Wimp-4_66-4_77_2_1:4.14.2.1
	bavison_Threads_dev:4.14.0.2
	bavison_Threads_dev_bp:4.14
	Wimp-5_00:4.25
	Wimp-4_100:4.25
	Wimp-4_99:4.25
	Wimp-4_98:4.25
	Wimp-4_97:4.25
	Wimp-4_96:4.25
	Wimp-4_95:4.25
	Wimp-4_94:4.24
	RO_5_07:4.24
	Wimp-4_93:4.24
	Wimp-4_92:4.23
	Wimp-4_91:4.23
	Wimp-4_90:4.22
	Wimp-4_89:4.22
	Wimp-4_88:4.21
	Wimp-4_87:4.21
	Wimp-4_86:4.21
	Wimp-4_85:4.21
	Wimp-4_84:4.21
	Wimp-4_83:4.20
	Wimp-4_82:4.19
	Wimp-4_81:4.19
	Wimp-4_80:4.19
	Wimp-4_79:4.19
	Wimp-4_78:4.18
	Wimp-4_77:4.17
	Wimp-4_76:4.16
	Wimp-4_75:4.15
	Wimp-4_74:4.15
	Wimp-4_73:4.15
	Wimp-4_72:4.15
	Wimp-4_71:4.15
	Wimp-4_70:4.15
	Wimp-4_69:4.15
	Wimp-4_68:4.14
	Wimp-4_67:4.14
	Wimp-4_66:4.14
	Wimp-4_65:4.14
	Wimp-4_64:4.13
	Wimp-4_63:4.13
	Wimp-4_62:4.13
	Wimp-4_61:4.13
	Wimp-4_60:4.13
	Wimp-4_59:4.13
	Wimp-4_58:4.13
	Wimp-4_36-4_46_2_6:4.10
	Wimp-4_57:4.13
	Alpnet_approved:4.10
	Wimp-4_36-4_46_2_5:4.10
	Wimp-4_56:4.12
	dellis_autobuild_BaseSW:4.12
	Wimp-4_36-4_46_2_4:4.10
	Wimp-4_36-4_46_2_3:4.10
	Wimp-4_55:4.12
	Wimp-4_54:4.12
	Wimp-4_36-4_46_2_2:4.10
	Wimp-4_53:4.12
	Wimp-4_36-4_46_2_1:4.10
	Bethany:4.10.0.2
	Wimp-4_52:4.12
	Wimp-4_51:4.11
	Wimp-4_50:4.11
	Wimp-4_49:4.11
	Wimp-4_48:4.11
	Wimp-4_47:4.11
	Wimp-4_46:4.10
	Wimp-4_45:4.10
	Wimp-4_44:4.10
	Wimp-4_43:4.10
	Wimp-4_42:4.10
	sbrodie_sedwards_16Mar2000:4.10
	Wimp-4_41:4.10
	Wimp-4_40:4.10
	Wimp-4_39:4.10
	Wimp-4_38:4.10
	Wimp-4_37:4.10
	Wimp-4_36:4.10
	Wimp-4_35:4.10
	Wimp-4_34:4.10
	Wimp-4_33:4.10
	Wimp-4_32:4.10
	Wimp-4_31:4.10
	dcotton_autobuild_BaseSW:4.15
	Wimp-4_30:4.10
	Wimp-4_29:4.10
	Wimp-4_28:4.10
	Wimp-4_27:4.10
	Wimp-4_26:4.10
	Wimp-4_25:4.10
	Wimp-4_24:4.10
	Wimp-4_23:4.10
	Wimp-4_22:4.10
	Wimp-4_21:4.10
	Wimp-4_20:4.10
	Wimp-4_19:4.10
	Wimp-4_18:4.10
	Wimp-4_17:4.10
	Wimp-4_16:4.10
	Wimp-4_15:4.10
	Wimp-4_14:4.10
	Wimp-4_13:4.10
	Wimp-4_12:4.10
	mstphens_UrsulaRiscPCBuild_20Nov98:4.4.2.14
	bavison_Wimp-4_11:4.9
	Ursula_RiscPC:4.4.2.14.0.2
	Wimp-4_11:4.9
	Wimp-4_10:4.8
	Wimp-4_09:4.8
	Wimp-4_08:4.7
	Wimp-4_07:4.7
	Wimp-4_06:4.7
	Wimp-4_05:4.6
	Wimp-4_04:4.6
	bavison_Wimp-4_03_noshrinkables:4.6
	Wimp-4_03:4.6
	Wimp-4_02:4.6
	Ursula_merge:4.4.2.14
	bavison_Wimp-4_01:4.6
	Wimp-4_01:4.6
	nicke_Wimp_3_96M:4.1.7.4
	bavison_Wimp-4_00_TRUNK:4.5
	bavison_Wimp-4_00:4.4.2.14
	nicke_Wimp_3_96:4.1.7.4
	mjrobert_Wimp_3_98:4.4.2.3
	rthornb_UrsulaBuild-19Aug1998:4.4.2.14
	UrsulaBuild_FinalSoftload:4.4.2.14
	bavison_Wimp-3_99t:4.4.2.14
	rthornb_UrsulaBuild-12Aug1998:4.4.2.13
	bavison_Wimp-3_99s:4.4.2.13
	aglover_UrsulaBuild-05Aug1998:4.4.2.13
	bavison_Wimp-3_99r:4.4.2.13
	rthornb_UrsulaBuild-29Jul1998:4.4.2.12
	bavison_Wimp-3_99q:4.4.2.12
	jfarrell_NCWimp_3_96:4.1.7.4
	rthornb_UrsulaBuild-22Jul1998:4.4.2.12
	bavison_Wimp-3_99p:4.4.2.12
	rthornb_UrsulaBuild-15Jul1998:4.4.2.11
	bavison_Wimp-3_99o:4.4.2.11
	bavison_Wimp-3_99n:4.4.2.11
	rthornb_UrsulaBuild-07Jul1998:4.4.2.10
	bavison_Wimp-3_99m:4.4.2.10
	rthornb_UrsulaBuild-17Jun1998:4.4.2.9
	rthornb_UrsulaBuild-03Jun1998:4.4.2.9
	bavison_Wimp-3_99l:4.4.2.9
	rthornb_UrsulaBuild-27May1998:4.4.2.9
	rthornb_UrsulaBuild-21May1998:4.4.2.9
	bavison_Wimp-3_99k:4.4.2.9
	bavison_Wimp-3_99j:4.4.2.9
	bavison_Wimp-3_99i:4.4.2.8
	bavison_Wimp-3_99h:4.4.2.8
	rthornb_UrsulaBuild_01May1998:4.4.2.8
	bavison_Wimp_399g:4.4.2.8
	bavison_Wimp_399f:4.4.2.7
	afrost_NC2_Generic:4.1.7.4
	bavison_Wimp_399e:4.4.2.7
	bavison_Wimp_399d:4.4.2.7
	bavison_Wimp_399c:4.4.2.6
	Wimp_3_98:4.4.2.3
	kbracey_AW97:4.4.2.2
	Spinner_B20_2:4.1.7.4
	Spinner_19_3:4.1.7.4
	Spinner_B18:4.1.7.3
	Spinner_B17:4.1.7.3
	Spinner_B15:4.1.7.3
	Spinner_B14:4.1.7.3
	Spinner_B13:4.1.7.3
	Spinner_B12:4.1.7.3
	Spinner_B10:4.1.7.3
	Spin_merge_16May97:4.1.7.2
	Daytona:4.4.0.4
	Daytona_bp:4.4
	Ursula:4.4.0.2
	Ursula_bp:4.4
	Wimp_3_91:4.4
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.2
	Spinner_B7:4.1.7.3
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.2.2.5
	Spin_3Apr97:4.1.7.3
	ARTtmp:4.1.7.2.0.2
	Spin_merge:4.1.7.4
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.33
date	2018.02.17.15.20.29;	author jlee;	state Exp;
branches;
next	4.32;
commitid	E4WYFV9zLEaz2erA;

4.32
date	2015.11.29.19.57.16;	author jlee;	state Exp;
branches;
next	4.31;
commitid	bEIfj6rhNgsJD1Ly;

4.31
date	2014.05.28.19.11.50;	author rsprowson;	state Exp;
branches;
next	4.30;
commitid	9QyMnCxTPiHg4lCx;

4.30
date	2013.05.03.21.08.16;	author rsprowson;	state Exp;
branches;
next	4.29;
commitid	QS59VqQdUOQmfeOw;

4.29
date	2013.05.03.19.53.54;	author rsprowson;	state Exp;
branches;
next	4.28;
commitid	Bx7Y6yIqPRCWPdOw;

4.28
date	2011.02.01.23.00.28;	author jlee;	state Exp;
branches;
next	4.27;

4.27
date	2010.11.26.18.47.52;	author jlee;	state Exp;
branches;
next	4.26;

4.26
date	2009.11.06.23.32.27;	author jlee;	state Exp;
branches;
next	4.25;

4.25
date	2005.09.11.16.47.28;	author jballance;	state Exp;
branches;
next	4.24;

4.24
date	2004.08.12.14.31.26;	author jballance;	state Exp;
branches;
next	4.23;

4.23
date	2003.04.22.10.52.00;	author bavison;	state Exp;
branches;
next	4.22;

4.22
date	2003.02.28.16.09.32;	author bavison;	state Exp;
branches;
next	4.21;

4.21
date	2002.12.20.19.48.21;	author bavison;	state Exp;
branches;
next	4.20;

4.20
date	2002.12.13.21.57.25;	author bavison;	state Exp;
branches;
next	4.19;

4.19
date	2002.10.31.17.00.17;	author bavison;	state Exp;
branches;
next	4.18;

4.18
date	2002.10.30.17.43.55;	author bavison;	state Exp;
branches;
next	4.17;

4.17
date	2002.10.25.15.34.26;	author bavison;	state Exp;
branches;
next	4.16;

4.16
date	2002.10.23.17.12.36;	author bavison;	state Exp;
branches;
next	4.15;

4.15
date	2001.09.14.21.27.15;	author bavison;	state Exp;
branches;
next	4.14;

4.14
date	2001.03.23.16.49.09;	author bavison;	state Exp;
branches
	4.14.2.1;
next	4.13;

4.13
date	2000.10.20.12.44.26;	author bavison;	state Exp;
branches;
next	4.12;

4.12
date	2000.06.15.09.23.38;	author bavison;	state Exp;
branches;
next	4.11;

4.11
date	2000.04.25.12.24.07;	author kbracey;	state Exp;
branches;
next	4.10;

4.10
date	98.11.26.14.04.42;	author bavison;	state Exp;
branches;
next	4.9;

4.9
date	98.11.09.12.49.24;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	98.10.23.15.48.38;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	98.10.20.16.21.30;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	98.09.30.09.06.38;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	98.09.18.16.14.19;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	97.05.07.17.01.37;	author kbracey;	state Exp;
branches
	4.4.2.1;
next	4.3;

4.3
date	97.05.07.14.15.39;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.01.13.13.25.05;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.49;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.14.2.1
date	2007.10.07.02.17.29;	author bavison;	state Exp;
branches;
next	;
commitid	NSavcPvbNd36pBAs;

4.4.2.1
date	97.06.11.15.14.21;	author rleggett;	state Exp;
branches;
next	4.4.2.2;

4.4.2.2
date	97.07.07.11.25.10;	author bavison;	state Exp;
branches;
next	4.4.2.3;

4.4.2.3
date	97.12.08.16.02.19;	author rleggett;	state Exp;
branches;
next	4.4.2.4;

4.4.2.4
date	98.03.10.16.11.44;	author bavison;	state Exp;
branches;
next	4.4.2.5;

4.4.2.5
date	98.03.26.19.31.45;	author bavison;	state Exp;
branches;
next	4.4.2.6;

4.4.2.6
date	98.04.03.19.38.42;	author bavison;	state Exp;
branches;
next	4.4.2.7;

4.4.2.7
date	98.04.07.17.53.57;	author bavison;	state Exp;
branches;
next	4.4.2.8;

4.4.2.8
date	98.04.27.15.18.45;	author bavison;	state Exp;
branches;
next	4.4.2.9;

4.4.2.9
date	98.05.18.15.51.22;	author bavison;	state Exp;
branches;
next	4.4.2.10;

4.4.2.10
date	98.07.03.17.59.55;	author bavison;	state Exp;
branches;
next	4.4.2.11;

4.4.2.11
date	98.07.13.14.10.56;	author bavison;	state Exp;
branches;
next	4.4.2.12;

4.4.2.12
date	98.07.21.16.15.01;	author bavison;	state Exp;
branches;
next	4.4.2.13;

4.4.2.13
date	98.08.05.09.09.40;	author bavison;	state Exp;
branches;
next	4.4.2.14;

4.4.2.14
date	98.08.18.21.14.05;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.30.49;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.33.07;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.24.46;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.22.17;	author nturton;	state Exp;
branches;
next	4.1.7.2;

4.1.7.2
date	97.03.14.10.24.01;	author kbracey;	state Exp;
branches
	4.1.7.2.2.1;
next	4.1.7.3;

4.1.7.3
date	97.03.27.11.15.01;	author rbuckley;	state Exp;
branches;
next	4.1.7.4;

4.1.7.4
date	97.07.25.13.27.32;	author jcoxhead;	state Exp;
branches;
next	;

4.1.7.2.2.1
date	97.04.10.13.51.22;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.2;

4.1.7.2.2.2
date	97.04.14.12.22.06;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.3;

4.1.7.2.2.3
date	97.04.14.13.35.18;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.4;

4.1.7.2.2.4
date	97.04.14.21.56.04;	author kbracey;	state Exp;
branches;
next	4.1.7.2.2.5;

4.1.7.2.2.5
date	97.04.28.16.50.03;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.33
log
@Fix crashes when a Wimp_Poll post-filter causes the Wimp to postpone switching to a VFP-enabled task
Detail:
  s/Wimp07 - In ExitPoll, swap around the order of restoring the FP context and calling the poll post-filter so that the FP context is restored after the post-poll filter has been invoked. Previously, the VFP(+FPA) context would be restored, then the post-poll filter would be invoked. If the post-poll filter was claimed, the Wimp would then scan the pollwords again and most likely decide to switch to a different task. The appslot will then be switched over, and ExitPoll will be invoked again, attempting to restore the VFP/FPA context for that task - potentially causing a crash or other bad things because the VFP context used by the original choice of task is no longer paged in. For FPA this was never really a problem, since the context is stored in the RMA rather than being potentially stored in appspace.
  s/Wimp03 - Add some extra debug out for tracking VFP context management
Admin:
  Tested on wandboard
  Fixes issue reported on forums, where using the numpad in VFP SciCalc would cause a crash if KeyExtend was loaded:
  https://www.riscosopen.org/forum/forums/4/topics/10293


Version 5.60. Tagged as 'Wimp-5_60'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.Wimp03

;
; Entry:     [taskhandle] = current task handle
;         [newtaskhandle] = new task handle
; Exit:   R14, [flagword] = R0 on entry to Wimp_Poll (plus version bits)
;                 userblk = R1 on entry to Wimp_Poll
; Errors:  address exception if a dead task is paged IN here
;

pageintask
; Need to preserve flags, and return stuff in R14. Hence EntryS/EXITS are
; no good :(

      [ No32bitCode
        Push    "R0,R14"
      |
        Push    "R0,R1,R14"
        MRS     R1,CPSR
      ]
;
        Debuga  sw,"Page in task:",#newtaskhandle
        LDR     R14,newtaskhandle
        CMP     R14,#0                  ; taskhandle = -1 ==> menu owner
      [ debugsw
        BNE     %FT01
        Debug   sw," - system task"
01
      ]
        BEQ     pageintaskdone          ; 0 ==> no owner at all (ie. Wimp)
        LDRLT   R14,menutaskhandle      ; -1 ==> menus
      [ debugsw
        BGE     %FT01
        Debuga  sw," - menu task =",R14
01
      ]
        CMPLT   R14,#0
      [ debugsw
        BGE     %FT01
        Debuga  sw," - deleted!"
01
      ]
        Debug   sw,""
        BLT     pageintaskdone          ; if no menu owner, give up
        LDR     R0,taskhandle
        TEQ     R0,R14
        LDREQ   R14,flagword
        BEQ     pageintaskdone          ; DON'T RELOAD userblk if not nec.!!!
        Push    "R14"
        LDR     R14,[wsptr,R14]
        TST     R14,#task_unused
        BLEQ    mapslotout              ; map slot out, if still alive
        Pull    "R14"
        STR     R14,taskhandle
        BL      mapslotin
        LDR     R14,taskhandle
        LDR     R14,[wsptr,R14]
        TST     R14,#task_unused        ; tasks are sometimes allowed
      [ debugtask1                      ; to be dead here
        BEQ     %FT01
        Debug   task1,"Dead task paged in:",#taskhandle
01
      ]
        LDREQ   userblk,[R14,#task_registers+4*1]      ; get user R1
        LDREQ   R14,[R14,#task_flagword]
        STREQ   R14,flagword
pageintaskdone
      [ No32bitCode
        Pull    "R0,PC",,^                      ; must preserve flags
      |
        MSR     CPSR_f,R1
        Pull    "R0,R1,PC"                      ; must preserve flags
      ]

lookfornewtask
        Debug   task1,"Task dead on entry to Wimp_Poll"
;
; disconnect the task from any further contact with the Wimp
;
        LDR     R14,ptrtask
        LDR     R5,taskhandle
        TEQ     R5,R14
        MOVEQ   R14,#nullptr            ; avoid ptr_leaving_window!
        STREQ   R14,ptrwindow
;
        MOV     R0,#EscapeHandler       ; the domain is about to die -
        SWI     XOS_ReadDefaultHandler  ; prevent nasty handlers from being
        SWIVC   XOS_ChangeEnvironment   ; called when they shouldn't be!
;
        MOV     R0,#EventHandler
        SWI     XOS_ReadDefaultHandler
        SWIVC   XOS_ChangeEnvironment
;
        MOV     R0,#UpCallHandler
        SWI     XOS_ReadDefaultHandler
        SWIVC   XOS_ChangeEnvironment
;
        BL      deallocatependingtask   ; delete task block (gone for good)
                                        ; reclaim memory as well!
;
        Debug   co,"Closing down task: commandflag =",#commandflag
;
        LDR     R7,commandflag          ; R7 used further down!!!
;
        MOV     R0,#0                   ; 'Press SPACE' if anything printed
        BL      int_commandwindow       ; can't call SWI since task is dead!
        CLRV                            ; ignore errors
;
; now look for an alternative task (preserve R7 in this code)
;
        ADRL    R5,taskpointers
        MOV     R6,#maxtasks
01
        LDR     R14,[R5],#4
        TST     R14,#task_unused
        BEQ     %FT02
        SUBS    R6,R6,#1
        BNE     %BT01
;
        Debug   task1,"No tasks left - calling OS_Exit"
        SWI     XOS_Exit
02
        SUB     R5,R5,#4
        SUB     R5,R5,wsptr
        LDR     R6,taskhandle          ; R6 = previous task handle
        STR     R5,taskhandle
        LDR     userblk,[R14,#task_registers+4*1]
        Debug   task1,"Switching to task",R5
;
        BL      mapslotin               ; previous slot is already mapped out
;
; if that was the single task, change mode now!
; the rule is that the screen is reset unless the commandwindow is pending
; (used to be based on singletaskhandle)
;
        LDR     R5,singletaskhandle
        TEQ     R5,R6
        MOVEQ   R14,#nullptr            ; reset singletaskhandle BEFORE resetk
        STREQ   R14,singletaskhandle
        STREQ   R14,backwindow          ; must have been deleted
;
        TEQ     R7,#cf_pending          ; R7 set up further up !!!
        LDRNE   R0,currentmode          ; only change mode if chars printed

        BLNE    int_setmode
      [ Medusa
        ADRL    R14,greys_mode
        LDRB    R14,[R14]
        TEQ     R14,#0
        BLNE    recalc_greys_palette
      ]

        Debug   task1,"Returned from int_setmode"
;
        ADRL    R3,tempiconblk          ; forget old settings
        BL      resetkeycodes           ; *FX 4,2 etc.
;
        Debug   task1,"Paranoid resetting of state when task exits"
;
        B       taskisused



;;-----------------------------------------------------------------------------
;; Wimp_RegisterFilter - install/deinstall a filter routine
;;
;; in   R0 = filter reason
;;              =0 => pre-poll filter (prior to returning to task)
;;              =1 => post-poll filter (on return back to Wimp)
;;              =2 => block copy filter
;;              =3 => get rectangle filter
;;
;;      R1 -> filter routine / =0 for default
;;      R2 -> workspace for filter
;; out  -
;;-----------------------------------------------------------------------------

        ASSERT  postfilter =prefilter +8
        ASSERT  copyfilter =postfilter +8
        ASSERT  rectanglefilter =copyfilter +8
	ASSERT	postrectfilter =rectanglefilter +8
	ASSERT	posticonfilter =postrectfilter +8

        ASSERT  prefilterWP =prefilter -4

SWIWimp_RegisterFilter

        MyEntry "RegisterFilter"

        CMP     R0,#WimpFilter_MAX      ; filter number valid?
        BHS     err_badR0               ; if not then return an error

        TEQ     R1,#0                   ; de-register a filter
        ADREQ   R1,filtertable
        LDREQ   R2,[R1,R0,LSL #2]       ; get the default owner
        ADDEQ   R1,R1,R2                ; and resolve to an address, rather than offset

        ADRL    R14,prefilter
        ADD     R14,R14,R0,LSL #3       ; -> vector to store into
        STR     R1,[R14]
        STR     R2,[R14,#-4]            ; setup the handler correctly

        B       ExitWimp

;..............................................................................

; table of default vector owners

filtertable
        & prefilter_default -filtertable
        & postfilter_default -filtertable
        & copyfilter_default -filtertable
        & rectanglefilter_default -filtertable
        & postrectfilter_default -filtertable
	& posticonfilter_default -filtertable
        & -1

prefilter_default
postfilter_default
copyfilter_default
rectanglefilter_default
postrectfilter_default
posticonfilter_default

        MOV     PC,LR

;;-----------------------------------------------------------------------------
;; Reset the filters back to their default state, called on init and svc_reset,
;; once done issue a svc_RegisterFilters.
;;-----------------------------------------------------------------------------

defaultfilters EntryS "R0-R2"

        ADR     R0,filtertable          ; -> list of default owners
        ADRL    R1,prefilter            ; -> list of vectors to install
        MOV     R2,R0

10      LDR     R14,[R0],#4             ; get offset to routine
        CMP     R14,#-1
        ADDNE   R14,R14,R2
        STRNE   R14,[R1],#8             ; if not end of the table then store away
        BNE     %BT10

        ADR     R0,svc_callback
        MOV     R1,WsPtr
        SWI     XOS_AddCallBack         ; add the callback routine

        EXITS

;..............................................................................

; callback routine used to warn the outside world that they should register
; filters with the Window Manager.

svc_callback ROUT

        Push    "R1,LR"
        MOV     R1,#Service_WimpRegisterFilters
        SWI     XOS_ServiceCall
        Pull    "R1,PC"                 ; broadcast to the world


;;----------------------------------------------------------------------------
;; Wimp_Poll
;;
;; return codes are prioritised according to number:
;;
;;       1       Redraw_Window_Request
;;       2       Open_Window_Request
;;       3       Close_Window_Request
;;       4       Pointer_Leaving_Window
;;       5       Pointer_Entering_Window
;;       6       Mouse_Click
;;       7       User_Dragbox
;;       8       Key_Pressed
;;       9       Menu_Select
;;      10       Scroll_Request
;;
;; This is also the entry point after deleting a task
;;----------------------------------------------------------------------------

err_badR3
        MyXError  WimpBadR3
        B       ExitWimp
        MakeErrorBlock WimpBadR3

SWIWimp_PollIdle
        Debug   poll2, "Wimp_PollIdle entry"
        ORR     R0,R0,#flag_pollidle    ; time limit is in R2
        B       %FT01

SWIWimp_Poll
        Debug   poll2, "Wimp_Poll entry"
        BIC     R0,R0,#flag_pollidle    ; no time limit supplied

01
        MyEntry "Poll"

; remember task number, to allow optimisation of return to caller
;
; Entry: R0 = flag word
;        R1 = taskhandle
;        R2 = target time (if R0 & flag_pollidle) - as in ReadMonotonicTime
;        R3 -> poll word  (if R0 & flag_pollword, and Wimp 2.23 known)
;   userblk = original R1 --> poll block
;

; attempt to call a pre-poll filter routine, it may modify the flags in R0

        CallFilter prefilter
;
      [ AutoHourglass                   ; it could still be a while until the next task switch,
        LDR     R1, hourglass_status    ; so ensure the hourglass is off at this point
      [ debugautohg
	Push	"handle"
	LDR	handle, taskhandle
        Debug	autohg, "Hourglass_Off at Wimp_Poll entry: taskhandle, old status =", handle, R1
        Pull	"handle"
      ]
        TEQ     R1, #2                  ; is hourglass still pending or active?
        MOVEQ   R1, #1                  ; yes, so turn off hourglass (but keep on vector for speed reasons)
        STREQ   R1, hourglass_status
        SWIEQ   XHourglass_Off
        CLRV                            ; ignore errors
      ]

        LDR     R1,taskhandle
        LDR     R4,[wsptr,R1]           ; R4 = task data pointer
        TST     R4,#task_unused         ; if task not used, it's been deleted
        BNE     lookfornewtask

        LDR     R5,[R4,#task_flagword]  ; R5 = flag word
        LDR     R14,singletaskhandle
        TEQ     R1,R14                  ; if single-tasking
        LDREQ   R14,=masknewcodes
        ORREQ   R0,R0,R14               ; disallow new reason codes

; set up R3 -> poll word, with bottom bit set => urgent
; also validate R0,R3 (but only if task knows about Wimp 2.23)

        LDR     R14,[R4,#task_wimpver]
        CMP     R14,#223
        MOVLO   R3,#0                   ; R3=0 => no poll word
        BLLO    killfpblock             ; get rid of this!
        BLO     %FT01

; this stuff only applies to tasks that know about Wimp 2.23 or later
; bits 22,23 => poll word, bit 24 => save/restore FP registers

        TST     R0,#pollword_bit        ; if this event is disabled,
        BICNE   R0,R0,#flag_pollword    ; then there's no point polling!

        TST     R0,#flag_pollword       ; no poll word if this bit unset
        MOVEQ   R3,#0

        TST     R3,#3                   ; check that address is word-aligned
        BNE     err_badR3
        CMP     R3,#ApplicationStart    ; and not in application space

        [ Medusa
        LDRHS   R14,orig_applicationspacesize
        CMPHS   R14,R3
        |
        RSBHSS  R14,R3,#&1000000        ; APPSPACE
        ]
        BHS     err_badR3

	CLRV				; make sure we don't leave V set
        TST     R0,#flag_pollword
        TSTNE   R0,#flag_pollfast       ; bottom bit set => poll quickly
        ORRNE   R3,R3,#1

        MOV     R14,R0,LSR #flag_versionbit   ; object if others set
        BICS    R14,R14,#flag_allowed :SHR: flag_versionbit
        BNE     err_badR0                       ; error from Wimp_Poll !!!

; does the task want to save the FP registers?

        TST     R0,#flag_fpsave
        BLEQ    killfpblock                     ; preserves flags
        BLNE    saveFPregs
        BVS     ExitWimp

; save toned-down flag word in task workspace

01
        STR     R3,[R4,#task_pollword]

        LDR     R14,[R4,#task_priority]
        TST     R0,#flag_pollword
        TEQNE   R3,#0
        ORRNE   R14,R14,#priority_pollword      ; Has a poll word ?
        BICEQ   R14,R14,#priority_pollword

      [ debugpoll
        BEQ     %FT00
        Debug   poll,"New poll task: handle, posn",R1,#PollTaskPtr
00
      ]

        LDRNE   R3,PollTaskPtr
        STRNE   R1,[R3],#4                      ; Add task handle to list of polled tasks
        STRNE   R3,PollTaskPtr

        TST     R0,#flag_pollidle
        ORRNE   R14,R14,#priority_idle          ; Poll_idle ?
        BICNE   R14,R14,#priority_null
        BICEQ   R14,R14,#priority_idle
        BNE     %FT01

        TST     R0,#null_bit
        ORREQ   R14,R14,#priority_null          ; Wants Null events ?
        BICNE   R14,R14,#priority_null
01
        STR     R14,[R4,#task_priority]

        MOV     R0,R0,LSL #32-flag_versionbit   ; clear version bits
        MOV     R0,R0,LSR #32-flag_versionbit
        MOV     R5,R5,LSR #flag_versionbit      ; so we can retain the old ones
        ORR     R0,R0,R5,LSL #flag_versionbit
        STR     R0,[R4,#task_flagword]          ; remember original flags
        STR     R0,flagword
        STR     userblk,[R4,#task_registers+4*1]        ; and user R1
        STR     R2,[R4,#task_registers+4*2]             ; and target time
;
; save VFP context, lazily if possible
;
        MOV     R0,#0
        MOV     R1,#VFPSupport_ChangeContext_Lazy+VFPSupport_ChangeContext_AppSpace
        SWI     XVFPSupport_ChangeContext
        MOVVS   R0,#0 ; Ignore error (probably means VFPSupport isn't loaded)
        Debug   fp,"VFP on Wimp_Poll entry",R0
        STR     R0,[R4,#task_vfpcontext]
        CLRV
;
; check to see if there are any more outstanding parents
;
taskisused
        LDR     R14,taskSP
        ADR     R1,taskstack
        TEQ     R14,R1
        BEQ     %FT01

        LDR     R1,[R14,#-4]!           ; empty ascending stack
        STR     R14,taskSP

        LDR     R0,polltaskhandle       ; R0 = child's task handle
        LDR     R14,[wsptr,R0]          ; R14 = task block pointer
        TST     R14,#task_unused
        MOVNE   R0,#0                   ; R0=0 => child is already dead
        LDREQ   R14,[R14,#task_flagword]
        MOVEQ   R14,R14,LSR #flag_versionbit
        ORREQ   R0,R0,R14,LSL #flag_versionbit

        Task    R1,,"Parent"            ; make sure correct page swaps happen
        LDR     R14,[wsptr,R1]
        TST     R14,#task_unused        ; parent might be dead!
        BNE     lookfornewtask

        B       ExitPoll_toparent       ; exit back to parent task
01

;
; if menus marked for deletion, kill them off!
;
        LDR     R0,menus_temporary      ; -4 ==> kill menus
        TEQ     R0,#0
        STRNE   R0,menutaskhandle       ; NE ==> R0 = -4
        MOVNE   R14,#0
        STRNE   R14,menus_temporary
        BLNE    closemenus
;
; ensure that escape condition generation is disabled on entry
;
      [ debugescape
        LDR     R14,singletaskhandle
        CMP     R14,#nullptr            ; old Wimp didn't set up escape!
        BNE     %FT02
;
        Push    "R0-R2"

        MOV     R0,#229                 ; *FX 229,1 (escape ==> ascii 27)
        MOV     R1,#1
        MOV     R2,#0
        SWI     XOS_Byte
        TEQ     R1,#0                   ; was escape already disabled?
        TOGPSR  Z_bit, R14              ; NE => escape enabled
        MOVEQ   R0,#126
        SWIEQ   XOS_Byte
        TEQEQ   R1,#0                   ; or was there an escape condition?

        Pull    "R0-R2"
        BEQ     %FT02
        MyXError  WimpBadEscapeState
        B       ExitPoll                ; Wimp reports errors itself
        MakeErrorBlock WimpBadEscapeState
02
      ]
;
; re-entry point from within polling routines
;
repollwimp
        Debug   poll2, "repollwimp"
        BL      powersave_tick
        LDR     R14,taskhandle          ; get userblk back (may be corrupted)
        LDR     R14,[wsptr,R14]
        LDR     userblk,[R14,#task_registers+4*1]
;
        MOV     R0,#1
        BL      scanpollwords           ; scan high-priority tasks
        BNE     ExitPoll

        LDR     R2,headpointer          ; are there any outstanding messages?
        CMP     R2,#nullptr
        BNE     returnmessage
;
      [ MultiClose
        LDR     R2, nextwindowtoiconise
        TEQ     R2, #0
        BLNE    iconisenextwindow
        LDR     R2, headpointer         ; are there any outstanding messages now?
        CMP     R2, #nullptr
        BNE     returnmessage
      ]
;
        MOV     R14,#0
        STR     R14,sender              ; all Wimp messages from now on
        STR     R14,hotkeyptr           ; reset this if no more messages
;
; check for a recent mode change - if so, deliver Open_Window_Requests
;
        LDRB    R14,modechanged
        TEQ     R14,#0
        BEQ     nomodechange
        MOV     R14,#0
        STRB    R14,modechanged

; copy scrx1,y1 into lastmode_x1,y1 for next time

        LDR     R14,scrx1
        STR     R14,lastmode_x1
        LDR     R14,scry1
        STR     R14,lastmode_y1

; send Message_ModeChange first

        MOV     R14,#ms_data            ; size of block
        STR     R14,[sp,#-ms_data]!
        MOVVC   R0,#User_Message
        MOV     R1,sp
        MOV     R2,#0
        STRVC   R2,[R1,#ms_yourref]
        LDR     R14,=Message_ModeChange
        STRVC   R14,[R1,#ms_action]
        BLVC    int_sendmessage_fromwimp
        ADD     sp,sp,#ms_data          ; correct stack
;
        Debug   task1,"Mode change message sent"

; first make a copy of the window stack, so that changes in the order are OK
; Enumerate the window stack from back to front

        LDR     R5,activewinds+lh_backwards
01
        LDR     R4,[R5,#ll_backwards]
        CMP     R4,#nullptr
        BEQ     repollwimp
        SUB     handle,R5,#w_active_link
        MOV     R5,R4
;
        Debug   ms,"Mode Change: re-opening window handle",R0,handle
;
        LDR     R14,[handle,#w_flags]
        TST     R14,#wf_isapane         ; don't re-open panes
        BNE     %BT01
;
        Push    "R4,R5,userblk"

        LDR     R14,[handle,#w_flags]   ; ensure window is put on-screen

        LDR     R4,forceflags           ; 0 or ws_onscreenonce
        ORR     R14,R14,R4              ; R4 = 0 or ws_onscreenonce
        STR     R14,[handle,#w_flags]

        ADD     R14,handle,#w_wax0
        LDMIA   R14,{cx0,cy0,cx1,cy1,x0,y0}
        Rel     R14,handle              ; bhandle (open at same height)
        MOV     R0,R14

        Push    "R0,cx0,cy0,cx1,cy1,x0,y0,R14"
        MOV     R1,sp

        LDR     R2,[handle,#w_taskhandle]
        CMP     R2,#0                   ; if system window, open automatically
        BGT     %FT11

; Skip backwindow and iconbarwindow

      [ true
        B       %FT22
      |
        LDR     R14,backwindowhandle    ; if back window, open at full size
        TEQ     R0,R14
        LDRNE   R14,iconbarhandle
        TEQNE   R0,R14
        BEQ     %FT22                   ; ignore these (already done first)
      ]
11
        Rel     R2,handle               ; must send the handle, so that
        MOV     R0,#Open_Window_Request ; the message is lost if window deleted
        Debug   mode,"Sending open request to",R2
        BL      int_sendmessage_fromwimp
22
        ADD     sp,sp,#u_ow1            ; correct stack (& ignore errors)
        Pull    "R4,R5,userblk"
        B       %BT01

nomodechange
      [ redrawlast
        B       lookatpointer

check_redraw
      ]
;
; flush pending opens - make sure this is done BEFORE redraw stuff
;
      [ ChildWindows
        BL      int_flush_opens         ; may cause a braindead panic redraw
      ]
;
; look at invalid list to see if a redraw is necessary
;
        BL      checkredrawhandle
      [ :LNOT: ChildWindows             ; this is pointless - can't get an error from checkredrawhandle!
        BVS     ExitPoll                ; <<<< wot?
      ]
;
; Improved handling of rectangle area full:
; Redraw whole screen intelligently first, then, if that fails, draw
; all the windows from the back to the front (braindead isn't it!)

        LDR     R1,BPR_indication
        TEQ     R1,#BPR_panicnow
        BEQ     start_braindead_panic_redraw
        CMP     R1,#BPR_continuelevel
        BHS     continue_braindead_panic_redraw
        CMP     R1,#BPR_gotfullarea
        BLEQ    BPR_startintelligentredraw
;
        LDR     R1,rlinks+invalidrects
        CMP     R1,#nullptr

; Downgrade to no panic

        MOVEQ   R1,#BPR_notatall
        STREQ   R1,BPR_indication
      [ redrawlast
        BEQ     check_null
      |
        BEQ     lookatpointer           ; screen is all valid!
      ]
;
        LDR     R1,activewinds+lh_forwards

pollredrawlp
        LDR     R2,[R1,#ll_forwards]
        CMP     R2,#nullptr
        BEQ     clearrects

        SUB     handle,R1,#w_active_link

        Push    "R2"
        BL      invalidouterportion
        Pull    "R1"

        LDR     R2,rlinks+windowrects
        CMP     R2,#nullptr
        BEQ     pollredrawlp

;
; Right - windowrects is the intersection of this window's outer portion with the invalid list
; We need to check whether any of the window's children should be redrawn first
;

process_redrawable_window ROUT

        Debug   child,"process_redrawable_window",handle

      [ ChildWindows
        LDR     R2,[handle,#w_children + lh_forwards]           ; start from the top

01      LDR     R14,[R2,#ll_forwards]
        CMP     R14,#nullptr
        BEQ     %FT04

        Push    "R2"

        LDR     R14,[R2,#w_flags - w_active_link]
        TST     R14,#wf_inborder
        ADDNE   R14,handle,#w_x0                ; clip to outer box if it can go in the border
        ADDEQ   R14,handle,#w_wax0              ; clip to work area otherwise
        LDMIA   R14,{x0,y0,x1,y1}

        ADD     R14,R2,#w_x0 - w_active_link
        LDMIA   R14,{cx0,cy0,cx1,cy1}

        max     cx0,x0                          ; intersect child's outer box with parent's work area or outline
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1

        Debug   child,"process_redrawable: child rectangle",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,#torects
        BL      intrect                         ; see if this intersects with the invalid list

        Pull    "R2"

        LDR     R14,rlinks+torects
        CMP     R14,#nullptr
        BNE     %FT03

02      LDR     R2,[R2,#ll_forwards]
        B       %BT01

; Right - redraw the child first, rather than the parent

03      MOV     R0,#windowrects
        BL      assign_set                      ; calls SetRectPtrs internally
        SUB     handle,R2,#w_active_link
      [ debug
        LDR     R14,rlinks + windowrects
        Debug   child,"Detected redraw for child window,rects",handle,R14
      ]
        B       process_redrawable_window       ; in case of nested child windows
04

process_redrawable_window_actually ROUT

        Debug   child,"Actually redraw window",handle
      ]
;
; check for auto-redraw bit in window flags
;
        LDR     R14,[handle,#w_flags]
        Debug   child,"window flags are",R14
        TST     R14,#wf_autoredraw
        BEQ     tryreturnit
;
        BL      int_redraw_window
redrlp  BVS     ExitPoll                        ; <<<< wot?
        TEQ     R0,#0
        BEQ     repollwimp
 [ Twitter
        BL      checktwitter
        LDRNE   r14, getrectflags
        ORRNE   r14, r14, #getrect_twitter
        STRNE   r14, getrectflags
 ]
        BL      int_get_rectangle               ; will draw the user icons
        B       redrlp
;
; check that task did not disable Redraw_Window_Request
;
tryreturnit
        LDR     R14,[handle,#w_taskhandle]
        Task    R14,,"RedrawRq"         ; can't be a menu (auto-redraw)
        TST     R14,#redraw_bit
      [ redrawlast
        BNE     check_null
      |
        BNE     lookatpointer           ; CAN'T CARRY ON (doesn't work!)
      ]
;
; return Redraw_Window_Request (and remember the handle we want back!)
;
        Rel     R14,handle
        STR     R14,[userblk]
        STR     R14,redrawhandle
      [ debug
        LDR     R14,rlinks + windowrects
        Debug   child,"Returning Redraw_Window_Request for window,rects",#redrawhandle,R14
      ]
        MOV     R0,#Redraw_Window_Request
        B       ExitPoll

powersave_tick
        Entry   "r0"
        LDR     R14,IdlePerSec          ; update the idle information for the portable modules
        ADD     R14,R14,#1
        STR     R14,IdlePerSec
 [ Stork
        LDR     R14, WimpPortableFlags
        TST     R14, #PowerSave                 ; if power saving
        TSTNE   R14, #PortableFeature_Idle      ; and Portable_Idle works
        SWINE   XPortable_Idle                  ; then go dormant until next interrupt or centi-second tick
 ]
        EXIT

        LTORG

;
; clearrects - no more windows left, so clear the rest out
;
clearrects
        BL      defaultwindow
        LDR     R0,scrx0
        LDR     R1,scry1
        SUB     R1,R1,#1                ; default is top-left of screen
        SWI     XOS_SetECFOrigin
        MOV     R0,#4
        BL      background
;
        Push    "userblk"
        SetRectPtrs
;
        MOV     R1,#invalidrects
        B       endclearrects
clearrectslp
        getxy   R1,x,y
        BL      graphicswindow
        [ windowsprite
        Push    "R0"
        LDRB    R0,[handle,#w_wbcol]

        BL      plotspritebackground
        Pull    "R0"
        |
        SWI     XOS_WriteI+16
        ]
      [ Autoscr
        LDR     R14, dragflags
        TST     R14, #dragf_clip ; clipped dragboxes must only be redrawn within their own window
        LDRNE   R14, draghandle
        Abs     R14, R14, NE
        TEQNE   R14, handle
        BLEQ    forcedrag_on            ; put drag rectangle back if nec.
      |
        BL      forcedrag_on            ; put drag rectangle back if nec.
      ]
endclearrects
        LDR     R1,[rectlinks,R1]
        CMP     R1,#nullptr
        BNE     clearrectslp
;
        MOV     R0,#invalidrects
        BL      loserects
        BL      defaultwindow
;
        Pull    "userblk"
        B       repollwimp              ; try again!

start_braindead_panic_redraw
        Debug   bpr,"Starting braindead panic redraw"

; Clear screen to background

        BL      defaultwindow
        LDR     R0,scrx0
        LDR     R1,scry1
        SUB     R1,R1,#1                ; default is top-left of screen
        SWI     XOS_SetECFOrigin
        MOV     R0,#4
        BL      background
        SWI     XOS_WriteI+16           ; CLG

; Find the backmost window and store in BPR_indication -
; BPR_notatall is used to indicate no windows

        LDR     R14,activewinds+lh_backwards
        LDR     R0,[R14,#ll_backwards]
        CMP     R0,#nullptr
        MOVEQ   R14,#BPR_notatall
        SUBNE   R14,R14,#w_active_link
        Rel     R14,R14,NE
        STR     R14,BPR_indication

continue_braindead_panic_redraw

; Run out of windows? - done with redrawing

        LDR     handle,BPR_indication
        TEQ     handle,#BPR_notatall
        BEQ     repollwimp

        Debug   bpr,"Continuing braindead panic redraw on handle",handle

; Window gone? - start from the start again

        BL      checkhandle
        BVS     start_braindead_panic_redraw

; Window closed? - start from the start again

        LDR     R14,[handle,#w_flags]
        Debug   bpr,"handle, flags are",handle,R14
        TST     R14,#ws_open
        BEQ     start_braindead_panic_redraw

; Move BPR_indication to next window in stack (must deal with child window stacks as well)

      [ ChildWindows
        Push    "handle"

        LDR     R0,[handle,#w_children + lh_backwards]          ; go for backmost child window first
        LDR     R14,[R0,#ll_backwards]
        CMP     R14,#nullptr
        BNE     %FT02

01      LDR     R0,[handle,#w_active_link + ll_backwards]       ; then go for next sibling
        Debug   bpr,"Next sibling",handle,R0
        LDR     R14,[R0,#ll_backwards]
        CMP     R14,#nullptr
        BNE     %FT02

        LDR     handle,[handle,#w_parent]                       ; else go for parent's next sibling, etc.
        Debug   bpr,"Move up to parent",handle
        CMP     handle,#nullptr
        BNE     %BT01

02      MOVEQ   R0,#BPR_notatall
        SUBNE   R0,R0,#w_active_link
        Rel     R0,R0,NE
        STR     R0,BPR_indication

        Pull    "handle"

        Debug   bpr,"Braindead redraw: this,next",handle,R0
      |
        LDR     R0,[handle,#w_active_link+ll_backwards]
        LDR     R14,[R0,#ll_backwards]
        CMP     R14,#nullptr
        MOVEQ   R0,#BPR_notatall
        SUBNE   R0,R0,#w_active_link
        Rel     R0,R0,NE
        STR     R0,BPR_indication
      ]

; Process this window (exactly)

        BL      initrectptrs
        ADD     R0,handle,#w_x0
        LDMIA   R0,{cx0,cy0,cx1,cy1}

; If this is a child window, clip to parent's work area/outline

      [ ChildWindows
        MOV     R1,handle
        B       %FT12

11      TST     R0,#wf_inborder
        ADDNE   R14,R1,#w_x0            ; clip to outer box if allowed to overlap border
        ADDEQ   R14,R1,#w_wax0          ; clip to parent's work area otherwise
        LDMIA   R14,{x0,y0,x1,y1}
        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1

12      LDR     R0,[R1,#w_flags]
        LDR     R1,[R1,#w_parent]
        CMP     R1,#nullptr
        BNE     %BT11
      ]

; make one-rectangle list of the window's outer box (clipped to its parent's work area)

        MOV     R0,#windowrects
        MOV     R1,R0
        BL      addrect
        LDR     R14,rlinks+windowrects
        CMP     R14,#nullptr
        BEQ     continue_braindead_panic_redraw
      [ ChildWindows
        B       process_redrawable_window_actually      ; DON'T consider the children this time
      |
        B       process_redrawable_window
      ]


;;----------------------------------------------------------------------------
;; Just before looking at the mouse, check all poll words
;;----------------------------------------------------------------------------

lookatpointer
        MOV     R0,#-1
        BL      scanpollwords           ; scan all tasks with pollwords
        BNE     ExitPoll
;
; Has the ticker gone off to see if we need to look at the
; mouse co-ordinates, have they changed yet?!
;
      [ mousecache
        LDRB    R0,recacheposn
        TEQ     R0,#0                   ; do we recache the information?
        BEQ     trykeys                 ; no, so ignore
      ]
;
; now see what user input has occurred
;
        Debug   poll2, "Processing mouse"
        BL      getmouseposn            ; ie. MOUSE R0,R1,R2

      [ PoppingIconBar
	BL	checkiconbarpop
      ]
;
; are we dragging a box?
;
        LDR     R14,dragtype
        TEQ     R14,#0
        BEQ     notdragging
;
; update coords (depends on drag type) and do bound checking
;
        Push    "R0-R2"                 ; mouse x,y coords and buttons

        LDR     R14,dragoldx
        STR     R0,dragoldx
        SUB     R0,R0,R14               ; x-offset this time
        LDR     R14,dragoldy
        STR     R1,dragoldy
        SUB     R1,R1,R14

        ADR     R14,dragx0
        LDMIA   R14,{x0,y0,x1,y1}
        LDR     R14,dragtype
        TEQ     R14,#drag_size          ; do we move both coords?
        TEQNE   R14,#drag_user2         ; user rubber-box
        TEQNE   R14,#drag_subr_size     ; user-supplied subroutine, rubber box
        TEQNE   R14,#drag_subr_size2    ; user-supplied subroutine, rubber box
        ADDNE   x0,x0,R0
        ADDNE   y1,y1,R1
        ADD     x1,x1,R0
        ADD     y0,y0,R1
;
; if drag types 10 or 11, or still holding button down, update box and continue
;
        TEQ     R14,#drag_subr_posn2
        TEQNE   R14,#drag_subr_size2
        TOGPSR  Z_bit,R14               ; NE ==> it is one of these
        TSTEQ   R2,#button_left:OR:button_middle:OR:button_right
        BLEQ    nodrag
        BLNE    yesdrag                 ; updates dragx0,y0,x1,y1
        Pull    "R0-R2"
        BEQ     boxdropped
;
; check sysflags to see if continuous dragging occurs
;
        LDR     R14,dragtype
        TEQ     R14,#drag_scrollboth    ; use vscroll bit of sysflags for this
        MOVEQ   R14,#drag_vscroll
        CMP     R14,#drag_user
        BHS     notdragging             ; only system drags are elegible

        Push    "R0"
        LDRB    R0,sysflags             ; drag bits are 0..3
        MOVS    R0,R0,LSR R14
        Pull    "R0"
        BCC     notdragging             ; R0,R1 = mouse coords here

        LDR     R1,dragtype             ; R14 may not = dragtype
        B       returndrag
;
; box has been dropped
; cancel drag box, then return appropriate reason code
;
boxdropped
        Push    "x0,y0,x1,y1"
        BL      clearpointerwindow      ; corrupts x0,y0,x1,y1
        Pull    "x0,y0,x1,y1"
;
        LDR     R1,dragtype
        TEQ     R1,#drag_scrollboth
        BLEQ    pointeron

        MOV     R0,#0                           ; cancel drag operation
        STR     R0,dragtype                     ; >>> leave [draghandle] alone!
        LDR     R0,mouseflags                   ; (for compatibility)
        BIC     R0,R0,#mf_oldcoords
        STR     R0,mouseflags
;
; come here for continuous dragging as well
; R1 = drag type ([dragtype] may already be 0)
;
returndrag
        ADR     R14,dragoffx0                   ; compute box coords
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        ADD     cx0,x0,cx0
        ADD     cy0,y0,cy0
        ADD     cx1,x1,cx1
        ADD     cy1,y1,cy1
        LDR     R14,dragtask                    ; originator of drag
        TEQ     R14,#0                          ; if menu,
        ADREQL  userblk,tempiconblk             ; set up dummy userblk
        Task    R14,NE,"Drag"                   ; else point to user's block

        CMP     R1,#drag_scrollboth
        CMPNE   R1,#drag_user-1
        STMHIIA userblk,{cx0,cy0,cx1,cy1}       ; final box coords
        MOVHI   R0,#User_Dragbox
        BHI     ExitPoll                        ; return User_DragBox
;
; return Open_Window_Request to the application
; R1 = drag type
; [dragtype] = 0 (drag has terminated) - unless continuous dragging
;
        TEQ     R1,#drag_posn
        TEQNE   R1,#drag_size
        BEQ     gonewposnsize
;
        LDR     handle,draghandle
        STR     handle,[userblk]
        BL      checkhandle                     ; might have been deleted?
        BLVS    nodragging                      ; stop it looping
        BVS     notdragging
;
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{x0,y0,x1,y1}
        ADD     R14,userblk,#4
        STMIA   R14!,{x0,y0,x1,y1}
;
; scroll bar was dragged - now work out new scroll bar positions
;
        TEQ     R1,#drag_hscroll
        TEQNE   R1,#drag_scrollboth
        LDRNE   x0,[handle,#w_scx]
        BLEQ    getnewscx                       ; get x0 from cx0,cx1 etc.
;
        TEQ     R1,#drag_vscroll
        TEQNE   R1,#drag_scrollboth
        LDRNE   y0,[handle,#w_scy]
        BLEQ    getnewscy                       ; get y0 from cy0,cy1 etc.
;
        Push    "x0,y0"
        BL      calc_w_status
        Pull    "x0,y0"
        LDR     x1,[handle,#w_bhandle]          ; open at same place in stack
        ADD     R14,userblk,#u_scx
        STMIA   R14,{x0,y0,x1}
;
        B       Exit_OpenWindow

gonewposnsize
        LDR     handle,draghandle               ; handle of window to open
        STR     handle,[userblk,#u_handle]
        BL      checkhandle                     ; window deleted?
        BLVS    nodragging
        BVS     notdragging     ; CLRV
;
        TEQ     R1,#drag_size                   ; R1 = drag type
        BNE     %FT01
        LDR     R14,[handle,#w_flags]
        ORR     R14,R14,#ws_onscreenonce        ; force window onto screen!
        STR     R14,[handle,#w_flags]           ; (don't touch toggled bit)
01
        ADD     R14,handle,#w_scx
        LDMIA   R14,{x1,y1}
        ADD     R14,userblk,#u_wax0
        STMIA   R14!,{cx0,cy0,cx1,cy1}
        STMIA   R14,{x1,y1}                     ; scroll positions

        BL      calc_w_status           ; ensure bhandle up-to-date

        LDR     R2,oldbuttons
        B       openwindow_checkbuttons

	[ PoppingIconBar
	; Note - need to sort out Service_MouseTrap for all this!
	ROUT
checkiconbarpop
	Push	"R0,LR"
	LDR	R14,singletaskhandle
	CMP	R14,#nullptr
	Pull	"R0,PC",NE		; old-style tasks don't have an icon bar!
	LDR	R14,iconbar_pop_state
	ADD	PC,PC,R14,LSL #2
	NOP
	B	%F10
	B	%F20
	B	%F30
	[ OldStyleIconBar
; Icon bar is held by menu
	|
	NOP ; drops through
; Icon bar is held by menu, or fronted by keyboard
        ]
	Pull	"R0,PC"

; Icon bar is at back
10      LDRB    R14, popiconbar
        TEQ     R14, #0
        Pull    "R0, PC", EQ    ; don't bring to front if configured off

        TEQ	R1,#0		; are we at the bottom of the screen?
	Pull	"R0,PC",NE

      [ Autoscr
        ; Don't bring to front if autoscrolling
        LDR     R14, autoscr_state
        TST     R14, #af_enable
        Pull    "R0, PC", NE
      ]
	; Don't bring to front if dragging a window
	LDR	R14,dragtype
	CMP	R14,#drag_posn
	BLO	%FT11
	CMP	R14,#drag_vscroll
	Pull	"R0,PC",LO
	TEQ	R14,#drag_scrollboth
	Pull	"R0,PC",EQ

11	SWI	XOS_ReadMonotonicTime
	Pull	"R0,PC",VS
	[ true
	LDR	R14, popiconbar_pause
	ADD	R0,R0,R14
	|
	ADD	R0,R0,#pop_DelayTime
	]
	STR	R0,iconbar_pop_time
	MOV	R0,#pop_Delaying
	STR	R0,iconbar_pop_state
	Pull	"R0,PC"

; Icon bar is delaying
20	TEQ	R1,#0
	MOVNE	R14,#pop_Back
	STRNE	R14,iconbar_pop_state
	Pull	"R0,PC",NE
	SWI	XOS_ReadMonotonicTime
	LDR	R14,iconbar_pop_time
	CMP	R0,R14
	Pull	"R0,PC",LO
	MOV	R14,#pop_Front
	STR	R14,iconbar_pop_state
	MOV	R14,#0
	B	%FT50

; Icon bar is at front
30	LDR	R14,iconbarheight
	CMP	R1,R14
	Pull	"R0,PC",LE
	MOV	R14,#pop_Back
	STR	R14,iconbar_pop_state
	MOV	R14,#1

50
	MOV	R0,R14
	LDR	handle,iconbarhandle
	CMP	handle,#nullptr
	Pull	"R0,PC",EQ

;
; As we enter here, R0=0 means pop to front, else go to back (or previous position)
;
	Push	"R1-R11"
	BL	checkhandle             ; handle -> window block
	BLVC	calc_w_status           ; set up flag word
	LDRVC	R14,[handle,#w_flags]
	BVS	%FT70
	TEQ	R0,#0
	BNE	%FT60
	; Going to front. Remember where to go back to.
	[ OldStyleIconBar
	TST	R14,#wf_backwindow
	MOVNE	R6,#-2
	LDREQ	R6,[handle,#w_bhandle]
	ADRL	R0,iconbar_pop_previous
	STR	R6,[R0]
	]
	BIC	R14,R14,#wf_backwindow
	STR	R14,[handle,#w_flags]
	MOV	R6,#-1
	B	%FT65

60	; Going back to previous position.
        [ OldStyleIconBar
	ADRL	R6,iconbar_pop_previous
	LDR	R6,[R6]
	CMP	R6,#-2
	ORREQ	R14,R14,#wf_backwindow
	STREQ	R14,[handle,#w_flags]
	|
	ORR     R14, R14, #wf_backwindow
	STR     R14, [handle, #w_flags]
 [ HideIconBar
	MOV     R6, #-3
 |
	MOV     R6, #-2
 ]
	]
65
	ADD	R14,handle,#w_wax0
	LDMIA	R14,{R0-R3,R4,R5}
	Push	"R0-R6"
	LDR	R14,iconbarhandle
	Push	"R14"
	MOV	userblk,sp
	BL	int_open_window
	ADD	sp,sp,#8*4
70
	Pull	"R1-R11"
	Pull	"R0,PC"
	]

;;----------------------------------------------------------------------------
;; Check for pointer changing window
;;----------------------------------------------------------------------------

notdragging

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

      ; CLRV                            ; ignore errors if they reach here
        MOV     R5,#0                   ; don't match shaded icons
        BL      int_get_pointer_info    ; R3,R4 = window/icon handle

        LDR     R14,dragtype            ; We've just changed icon, do we
        TEQ     R14,#0                  ; to change pointer shape?
        BNE     %FT92
        LDR     R14,mouseflags
        TST     R14,#mf_waitdrag
        BNE     %FT92

        Push    "r0"

        ADRL    r0,old_icon
        LDR     R14,[r0]
        TEQ     R3,R14
        STRNE   R3,[r0]
        ADRL    r0,old_window
        LDREQ   R14,[r0]
        TEQEQ   R4,R14
        STRNE   R4,[r0]

        Pull    "r0"

        BEQ     %FT92

        Push    "R0-R7,handle"

        Abs     R14,R3
        LDR     R14,[R14,#w_taskhandle]
        CMP     R14,#-1                 ; is the task -1, ie. owned by a menu
        BNE     %FT01
;
        SWI     XOS_ReadMonotonicTime
        LDR     R1,automenu_timelimit
        ADD     R1,R1,R0                ; reset the time limit
        STR     R1,automenu_timeouttime
      [ ClickSubmenus
        MOV     R14, #0
        STRB    R14, submenuopenedbyclick
      ]
01
        CMP     R3,#nullptr
        BEQ     %FT90
        CMP     R4,#nullptr
        CMPNE   R4,#nullptr2
        BEQ     %FT90
;        TST     R3,#1
;        BEQ     %FT90

        Debug   bo,"New window,icon",r3,r4

        LDR     r14,iconbarhandle
        CMP     r14,r3
        Debug   bo,"iconbar handle , handle",r14,r3
        TEQ     r14,r3
        BNE     %FT01

        Push    "R1-R4,R7"
        BL      findicon
        LDR     R14,[R2,#icb_taskhandle]
        Task    R14,,"Icon bar pointer shape check"
        Pull    "R1-R4,R7"
        Abs     r14,r3
        B       ptr_iconbar_icon

01
        Abs     R14,r3
        LDR     r3,[r14,#w_taskhandle]
        Push    "R14"
        Task    r3
        Pull    "R14"

ptr_iconbar_icon
        LDR     R14,[R14,#w_icons]
        ADD     R14,R14,R4,ASL #i_shift ; Point at the icon.
        LDR     r3,[r14,#i_flags]
        TST     r3,#if_text
        TSTNE   r3,#if_indirected       ; Is it indirected text ?
        BEQ     %FT90

        MOV     r2,#WimpValidation_Pointer
        LDR     r3,[r14,#i_data+4]      ; Pointer to validation string.
        AcceptLoosePointer_NegOrZero r3,-1
        CMP     r3,r3,ASR #31
        BEQ     %FT90
        DebugS  bo,"Validation string is ",r3
        BL      findcommand
        BNE     %FT90

        ADRL    r2,pointer_sprite
        Debug   bo,"Copy Sprite name"
88
        LDRB    R14,[r3],#1
        CMP     R14,#","
        MOVEQ   R14,#-1
        CMP     R14,#";"
        MOVEQ   R14,#0
        CMP     R14,#" "
        STRGTB  r14,[r2],#1
        BGT     %BT88

        MOV     R4,#0                   ; Default active point is 0,0
        MOV     R5,#0
        STRB    R4,[r2]                 ; Terminate the sprite name.

        CMP     R14,#-1
        BNE     %FT02

        Debug   bo,"Sprite name copied"

        BL      getnumber
        MOV     R4,R0                   ; Returns 0 if not found.

        LDRB    R14,[R3],#1
        CMP     R14,#","
        BNE     %FT02
        BL      getnumber
        MOV     R5,R0                   ; Returns 0 if not found.

        [ debugbo
         ADRL    r2,pointer_sprite
         DebugS  bo,"Sprite name is :",r2
        ]
02
        MOV     R0,#SpriteReason_SetPointerShape
        ADRL    R2,pointer_sprite
        MOV     R3,#1
      [ Autoscr
        LDR     R14, autoscr_state      ; don't reprogram pointer if autoscrolling is enabled
        TST     R14, #af_enable
        ORRNE   R3, R3, #&10
      ]
        MOV     R6,#0
        MOV     R7,#0
        SWI     XWimp_SpriteOp          ; take from Wimp's sprite area(s)
        MOV     R14,#-1
        ADRL    R1,special_pointer
        STR     R14,[r1]
        B       %FT91
90
        ADRL    R1,special_pointer
        LDR     R14,[R1]
        CMP     R14,#0
        MOVNE   R14,#0
;        ADRNEL  R1,special_pointer
        STRNE   R14,[r1]
        MOVNE   R3,#1
        BLNE    doubleptr_off
91
        Pull    "r0-r7,handle"
92

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; if icon changes while drag pending, return code now!

        LDR     R14,pending_window      ; if icon changes while drag pending
        TEQ     R3,R14                  ; do it now!
        LDREQ   R14,pending_icon
        TEQEQ   R4,R14
        LDRNE   R7,mouseflags
        TSTNE   R7,#mf_waitdrag
        ORRNE   R7,R7,#mf_oldcoords     ; avoid missing clicks

        BNE     waitdrag_action         ; pre-emptive strike!

      [ Autoscr
; do we need to do something about autoscrolling?
        LDR     R14, autoscr_state
        TST     R14, #af_enable
        BLNE    poll_autoscroll         ; may or may not return, preserves flags if it does
        BNE     %FT01                   ; don't scroll icon bar if scrolling something else!
      ]

; if in iconbar, check whether we should scroll automatically

 [ false
        LDR     R14,iconbarhandle
        CMP     R14,#nullptr
        BEQ     %FT01                   ; no iconbar
        TEQ     R3,R14
        BNE     %FT01                   ; this isn't it!
;
        LDR     R14,scrx0
        ADD     R14,R14,#iconbarsepgap
        CMP     R0,R14
        MOVLT   R8,#-16                 ; scroll left
        BLT     %FT02
        LDR     R14,scrx1
        SUB     R14,R14,#iconbarsepgap
        CMP     R0,R14
        MOVGT   R8,#16                  ; scroll right
        BLE     %FT01
02
        Push    "R0-R8,handle,userblk"
        Abs     handle,R3
        BL      calc_w_status           ; ensure bhandle is correct
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{R1-R7}             ; x0,y0,x1,y1,scx,scy,bhandle
        LDR     R8,[sp,#8*4]
        ADD     R5,R5,R8                ; add in appropriate offset
        LDR     R0,iconbarhandle
        Push    "R0,R1-R7"              ; first word is window handle
        MOV     userblk,sp
        BL      int_open_window
        ADD     sp,sp,#4*8              ; handle,x0,y0,x1,y1,scx,scy,bhandle
        Pull    "R0-R8,handle,userblk"
  |
        LDR     R14,iconbarhandle
        CMP     R14,#nullptr
        BEQ     %FT01                   ; no iconbar
        TEQ     R3,R14
	MOVNE	R14,#0
	STRNE	R14,iconbar_scroll_start_time
        BNE     %FT01                   ; this isn't it!
;
        LDR     R14,scrx0
        ADD     R14,R14,#iconbarsepgap
        CMP     R0,R14
        LDRLT   R8, iconbar_scroll_speed
        MVNLT   R8, R8 ; ensure msb set                        ; scroll left
        BLT     %FT02
;
        LDR     R14,scrx1
        SUB     R14,R14,#iconbarsepgap
        CMP     R0,R14
	MOVLE	R14,#0
	STRLE	R14,iconbar_scroll_start_time
        BLE     %FT01
        LDRGT   R8, iconbar_scroll_speed                       ; scroll right
02
        Push    "R0-R8,handle,userblk"
        Abs     handle,R3
        BL      calc_w_status           ; ensure bhandle is correct
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{R1-R7}             ; x0,y0,x1,y1,scx,scy,bhandle
        LDR     R8,[sp,#8*4]

	SWI	XOS_ReadMonotonicTime
	LDR	R14,iconbar_scroll_start_time
	TEQ	R14,#0
	STREQ	R0,iconbar_scroll_start_time
	STREQ	R5,iconbar_scroll_start_scx
	BEQ	%FT04
	; The following formula gives speed = iconbar_scroll_speed+iconbar_scroll_accel * time
	Push	"R2"
	LDR	R5,iconbar_scroll_start_scx
	LDR	R2,iconbar_scroll_start_time
	SUB	R2,R0,R2		; R2=time since scroll start (in centi-seconds)
	CMP     R2, #&3800              ;; much more than this, and accel*time^2 will overflow
	MOVHI   R2, #&3800              ;; when maximum acceleration is configured
	LDR	LR, iconbar_scroll_accel
	MUL	LR,R2,LR		; LR=accel * time (cs)
	MOV     LR, LR, ASR#6
	ADD     LR, LR, LR, ASR#2       ; LR=accel * time (s) (within 3%)
	CMP	R8,#0
	ADDGE	R8,R8,LR
	SUBLT	R8,R8,LR		; R8=(+/-)(speed + accel*time)
	ADDLT   R8, R8, #1              ; adjust because we used NOT(speed) rather than -(speed) for velocity
	MUL	R8,R2,R8		; R8=(+/-)(speed + accel*time) * time (cs)
	ADD     R8, R8, R8, ASR#2
	ADD	R5,R5,R8,ASR #6		; R5+=(+/-)(speed + accel*time) * time (s)
	Pull	"R2"

        LDR     R0,iconbarhandle
        Push    "R0,R1-R7"              ; first word is window handle
        MOV     userblk,sp
        BL      int_open_window
        ADD     sp,sp,#4*8              ; handle,x0,y0,x1,y1,scx,scy,bhandle
04
        Pull    "R0-R8,handle,userblk"
  ]
01

; if dragging, treat as window -1 (do this after iconbar scrolling)

        LDR     R14,dragtype            ; avoid ptr_changing events
        TEQ     R14,#0
        TEQNE   R14,#drag_subr_posn2
        TEQNE   R14,#drag_subr_size2
        MOVNE   R3,#nullptr

; Ptr_Entering/Leaving_Window treats system area as window -1

        Push    "R3"                    ; actual window handle
      [ Autoscr
; also treat as window -1 (but just for the purposes of Pointer Leaving/Entering Window events) if
; we're autoscrolling (which is not necessarily a subset of if dragging)
        LDR     R14, autoscr_state
        TST     R14, #af_enable
        MOVNE   R3, #nullptr
      ]
        LDR     R14,iconbarhandle
        TEQ     R3,R14                  ; treat as window handle -1:
        LDRNE   R14,backwindow          ; (a) if in back window
        TEQNE   R3,R14
        LDRNE   R14,backwindowhandle    ;     (either of them)
        TEQNE   R3,R14
        CMPNE   R4,#nullptr2            ; (b) if in iconbar window
        MOVEQ   R3,#nullptr             ; (c) if in system area
        LDR     R14,ptrwindow
        CMP     R3,R14                  ; same window?
        Pull    "R3",EQ                 ; actual window handle
        BEQ     cantchange
        Debug   ptr,"pointer new,old",R3,r14


;
; if old window not null, return 'leaving window', and set ptrwindow to null
; otherwise set ptrwindow to new window, and return 'entering window'
; in both cases set mf_oldcoords bit.
;
        Push    "R0"                    ; now R0,R3 on stack
        CMP     R14,#nullptr
        BEQ     entering
leaving
        MOV     R8,R14                  ; old handle
        LDR     R9,ptrtask              ; old task

        CMP     R9,#nullptr
        LDRNE   R14,[wsptr,R9]          ; Check if old task is dead
        TSTNE   R14,#task_unused        ; If so, just return 'entering window'
        BEQ     %FT01
        CMP     R3,#nullptr             ; Unless new window is null !!
        BNE     entering                ;
        STR     R3,ptrwindow
        Pull    "r0,r3"
        B       cantchange
01
        MOV     R3,#nullptr             ; set ptrwindow to null
        MOV     R0,#Pointer_Leaving_Window
        MOV     R14,#ptrleaving_bit
        B       ptrboth

entering
        Abs     handle,R3
        LDR     R9,[handle,#w_taskhandle]

        MOV     R8,R3                   ; new handle
        MOV     R0,#Pointer_Entering_Window
        MOV     R14,#ptrentering_bit

ptrboth
        STR     R3,ptrwindow
;
        Push    "R14"
        CMP     R3,#nullptr          ; if ptrwindow not null, task is relevant
        Abs     handle,R3,NE
        LDRNE   R14,[handle,#w_taskhandle]
        STRNE   R14,ptrtask             ; not nec. same as taskhandle
        Pull    "R14"
;
        CMP     R9,#0                   ; if this is a menu or a system window
        Pull    "R0,R3",LE
        BLE     cantchange              ; ignore it!
;
        Push    "R14"
        Task    R9,,"PtrWindow"
        MOV     R9,R14                  ; get flag word
        Pull    "R14"

        TST     R9,R14                  ; see if relevant bit is set
        STREQ   R0,[sp]                 ; keep 'action' flag
        Pull    "R0,R3"
        BNE     cantchange              ; user isn't interested!
;
        LDR     R14,mouseflags
        ORR     R14,R14,#mf_oldcoords
        STR     R14,mouseflags           ; use same values again!
;
        STR     R8,[userblk]            ; R0 = reason code already
        B       ExitPoll


;;----------------------------------------------------------------------------
;; Check for interesting mouse clicks
;;   -  depends on 'button type' of relevant icon
;;----------------------------------------------------------------------------

;
; button attributes
;

ibb_notpressed  *       2_000000000001
ibb_select      *       2_000000000010
ibb_writeable   *       2_000000000100      ; for writeable icons
ibb_canreport   *       2_100000000000

ibb_waitrepeat  *       2_000000001000
ibb_waitclick   *       2_000000010000
ibb_waitdrag    *       2_000000100000
ibb_waitrelease *       2_000001000000
ibb_wait2clicks *       2_000010000000
ibb_waitremove  *       2_000100000000
ibb_pending     *       2_000111111000
ibb_report5     *       2_001000000000
ibb_report6     *       2_010000000000

ibb_justselect  *       ibb_pending :AND: (:NOT:ibb_waitdrag)

bb_setflags     *       3               ; bit number of pending flags


buttonattributes
        DCD     2_000000000000  ; 0 never report
        DCD     2_100000000001  ; 1 always report
        DCD     2_100000001000  ; 2 report if button clicked (auto-repeat)
        DCD     2_100000000000  ; 3 report if button clicked
        DCD     2_100101000010  ; 4 select if clicked, report if released
        DCD     2_100010000010  ; 5 select if clicked, report if 2 clicks
        DCD     2_100000100000  ; 6 as for (3), but can also drag
        DCD     2_100001100010  ; 7 as for (4), but can also drag
        DCD     2_100010100010  ; 8 as for (5), but can also drag
        DCD     2_100100010011  ; 9 select always, report if clicked
        DCD     2_101010100010  ;10 report 1 or 2 clicks (:SHL:8 if 1 click)
        DCD     2_100000100010  ;11 as (8), but select+notify on single click
        DCD     2_110010100010  ;12
        DCD     2_100010000000  ;13
        DCD     2_100000100100  ;14 writeable, but also report as for (6)
        DCD     2_000000000100  ;15 writeable icon (don't report)

        ALIGN

; R0,R1 = mouse coords (absolute)
;    R2 = mouse button state
; R3,R4 = actual window/icon handles (R3 not forced to -1 for background)

cantchange
        LDR     R14,dragtype
        TEQ     R14,#0
        TEQNE   R14,#drag_subr_posn2
        TEQNE   R14,#drag_subr_size2
        BNE     trykeys                 ; don't recognise any other buttons
;
        BL      scanmenus               ; preserves task if it returns here
        BVS     ExitPoll
;
; window handle can come back -1 if we clicked on a greyed-out menu item
;
        CMP     R3,#nullptr             ; should only happen for grey menu items
        BEQ     trykeys
;
; translate icon -2 to appropriate system icon handle
;
        CMP     R4,#nullptr2            ; in system area?
        BNE     %FT01

        BL      setwimpicon             ; set up R4 and R5
        B       gotbttype
;
; obtain 'button type' of user icon
;
01      CMP     R4,#nullptr
        LDREQ   R5,[handle,#w_workflags]; look up work area button type
        LDRNE   R5,[handle,#w_icons]
        ADDNE   R5,R5,#i_flags
        LDRNE   R5,[R5,R4,ASL #i_shift] ; R5 = flag word
;
; always report the menu button unless in border region
;

gotbttype
        CMP     R4,#nullptr2
        BLE     issystemarea
        LDR     R14,oldbuttons
        BIC     R14,R2,R14
        TST     R14,#button_middle      ; look for +ve edge of MENU button
        BNE     justtellhim
        BIC     R2,R2,#button_middle    ; pretend it's off!

issystemarea

;
; for select and adjust, check the button type
;
        AND     R14,R5,#if_buttontype           ; use field as index offset
        MOVS    R14,R14,LSR #ib_buttontype
        ADR     R6,buttonattributes
        LDR     R6,[R6,R14,ASL #2]              ; R6 = internal flag word
        LDR     R7,mouseflags                   ; R7 = mouse flags
        LDR     R8,oldbuttons                   ; R8 = old button state

; R0,R1 => x,y mouse co-ordinates
; R2 => button state
; R4 => icon handle
; R6 => button attributes
; R7 => mouse flag
; R8 => old button state
; handle => internal window handle

        Push    "R0-R2,handle"
;
        BL      modifytool                      ; attempt to handle window tools changing (when possible)
;
        TST     R2,#button_left+button_right
        BNE     %FT01                           ; if not released then ignore
;
        ASSERT  nullptr = windowicon_workarea
;
        LDR     R0,border_iconselected          ; may have changed!
        CMP     R0,#windowicon_workarea
        BLE     %FT01                           ; if -VE then ignore its not worth the hassle
;
        MOV     R1,#0
        MOV     R2,#is_inverted
        LDR     handle,border_windowselected
        BL      int_set_icon_state              ; modify the tool icon
;
        MOV     R0,#nullptr
        STR     R0,border_iconselected
        STR     R0,border_windowselected        ; flag as no icon / window selected
01
        Pull    "R0-R2,handle"
;
; cancel certain pending actions if icon has changed
;
        LDR     R14,pending_window
        TEQ     R3,R14
        LDREQ   R14,pending_icon
        TEQEQ   R4,R14
        BEQ     sameicon
;
        TST     R7,#mf_waitremove               ; cancel previous icon
        BEQ     dontpratabout
        Push    "R0,R4,handle"
        LDR     handle,pending_window
        BL      checkhandle                     ; IGNORE errors!
        LDRVC   R4,pending_icon
        BLVC    deselecticon
        Pull    "R0,R4,handle"                  ; V cleared lower down

dontpratabout
        TST     R7,#mf_wait2clicks              ; reset pointer shape if nec.
        BLNE    doubleptr_off
        BIC     R7,R7,#mf_pendingexceptdrag     ; cancel pending (except drag)
        STR     R7,mouseflags
;
sameicon
        TST     R7,#mf_waitdrag
        BLNE    waitdrag                        ; may or may not return here
        TST     R7,#mf_waitrelease
        BNE     waitrelease
        TST     R7,#mf_wait2clicks
        BNE     wait2clicks
        TST     R7,#mf_waitclick
        BNE     waitclick
        TST     R7,#mf_waitrepeat
        BNE     waitrepeat
;
testbutton
        CMP     R3,#nullptr             ; can't have select or adjust here!
        BEQ     trykeys
;
        BIC     R2,R2,R8                ; look for +ve edges
;
        TST     R6,#ibb_notpressed      ; unless notpressed, check key is down
        TSTEQ   R2,#button_left:OR:button_middle:OR:button_right
        BEQ     trykeys
;
; icon responds - set up appropriate pending flags
;
        AND     R14,R6,#ibb_pending
        BIC     R7,R7,#mf_pending
        ORR     R7,R7,R14,LSL #mfb_setflags-bb_setflags  ; set up mouseflags
        STR     R7,mouseflags

        TST     R14,#ibb_waitrepeat
        BLNE    getfx12                 ; get auto-repeat settings
        LDRNEB  R14,repeatdelay
        STRNEB  R14,repeatlimit
;
        LDR     R14,timeblk             ; go!
        STR     R14,pending_time
;
        ADR     R14,pending_x
        STMIA   R14,{R0-R4}             ; saves x,y,buttons,window,icon

; change pointer shape for double-clicks to help wally users

        TST     R7,#mf_wait2clicks
        BLNE    doubleptr_on            ; if current shape = 1, set double ptr

; see if the icon reports back, or is just selected

        TST     R6,#ibb_writeable       ; special code for writeable icons
        BLNE    clickonwriteable        ; will return here
        TST     R6,#ibb_canreport
        BEQ     trykeys                 ; type 15 is writeable but can't report
        TST     R6,#ibb_select
        BEQ     justtellhim             ; report direct to the user!
        TST     R6,#ibb_report5         ; report 1 click as well
        MOVNE   R2,R2,LSL #8            ; shift up by 8 bits
        BNE     justtellhim
        TST     R6,#ibb_report6
        BNE     trykeys                 ; don't tell him!
;
; implicit selection takes place (don't tell the user!)
;
        CMP     R4,#nullptr             ; don't select work or system area
        BLGT    selecticon              ; take note of ESG's etc.
;
        TST     R6,#ibb_justselect      ; if no pending actions,
        BEQ     justtellhim             ; notify the user AS WELL as selecting
;
        TST     R6,#ibb_waitclick       ; button could go down AT THE SAME TIME
        BICNES  R14,R2,R8               ; as the pointer enters the icon!
        BNE     justtellhim
;
        B       trykeys

;
; check for pending icon
;

waitrelease
        TST     R2,#button_left:OR:button_middle:OR:button_right
        BICEQ   R7,R7,#mf_waitrelease
        STREQ   R7,mouseflags
        LDREQ   R2,pending_buttons      ; remember original button press
        BEQ     justtellhim
        B       trykeys                 ; keep waiting!

wait2clicks

; new version changes the pointer shape during the double-click period

        LDRB    R5,doubleclick_movelimit
        BL      checkpointermoved       ; sets C if pointer moved too far

        LDR     R5,doubleclick_timelimit
        BLCC    pendingtime             ; preserves flags
        CMPCC   R14,R5
        BCS     %FT01                   ; too late!

        BICS    R2,R2,R8                ; doesn't affect C flag
        BEQ     testbutton

        LDR     R14,pending_buttons     ; can't double-click with different buttons
        TST     R2,R14
        CMPEQ   R2,R2                   ; set C => don't do the double-click
01
        BIC     R7,R7,#mf_wait2clicks
        STR     R7,mouseflags

        BL      doubleptr_off           ; preserves flags
        BCS     testbutton              ; CS: don't do the double-click
        B       justtellhim             ; CC: do the double-click

; In    R0,R1 = current mouse position
;       R5 = movement limit (OS units)
;       [pending_x/y] = mouse position when initial click occurred
; Out   CS => mouse has moved away from that position

checkpointermoved

        Push    "R6,LR"
        LDR     R14,pending_x           ; get chicago dist. from orig. point
        SUBS    R14,R14,R0
        RSBMI   R14,R14,#0
        LDR     R6,pending_y            ; R5 not used any more
        SUBS    R6,R6,R1
        RSBMI   R6,R6,#0
        ADD     R6,R6,R14
        CMP     R6,R5
        Pull    "R6,PC"                 ; CS => pointer has moved away

waitclick
        BICS    R14,R2,R8
        BEQ     testbutton              ; not interested
        B       justtellhim

waitrepeat
        LDR     R14,pending_buttons
        TST     R2,R14                  ; still held down?
        BICEQ   R7,R7,#mf_waitrepeat
        STREQ   R7,mouseflags
        BEQ     testbutton
;
        BL      pendingtime
        Push    "R2"
        LDRB    R2,repeatlimit
        CMP     R14,R2
        Pull    "R2"
        BCC     trykeys                 ; still waiting
;
        LDR     R14,timeblk             ; reset timer
        STR     R14,pending_time
        BL      getfx12
        LDRB    R14,repeatrate          ; different delay this time!
        STRB    R14,repeatlimit
        MOV     R14,#1
        STRB    R14,autorepeating
        B       justtellhim             ; return button press

getfx12
        Push    "R0-R2,LR"
        MOVNE   R0,#&C4
        MOVNE   R1,#0
        MOVNE   R2,#&FF
        SWINE   XOS_Byte
        STRNEB  R1,repeatdelay
        STRNEB  R2,repeatrate
        Pull    "R0-R2,PC"

waitdrag
        Push    "LR"
;
        TST     R2,#button_left:OR:button_middle:OR:button_right
        BICEQ   R7,R7,#mf_waitdrag      ; button released!
        STREQ   R7,mouseflags
        Pull    "PC",EQ
;
        LDRB    R5,drag_movelimit
        BL      checkpointermoved       ; CS => pointer has moved
        BLCC    pendingtime             ; can't return an error
        LDRCC   R5,drag_timelimit
        CMPCC   R14,R5
        Pull    "PC",CC                 ; still waiting
        Pull    "LR"                    ; drop through
;
; This code is also called from higher up, if the window/icon have changed
; Entry:  R7 = current mouseflags
; Exit:   drag buttons reported to the application
;
waitdrag_action
        BL      mousetrap               ; buttons haven't changed
;
        BIC     R7,R7,#mf_waitdrag      ; don't cancel others!
        STR     R7,mouseflags
        ADR     R14,pending_x
        LDMIA   R14,{R0-R4}
        STR     R0,mousexpos            ; to fool Drag_Box if called
        STR     R1,mouseypos
        MOV     R2,R2,ASL #4            ; 'alias' to different buttons
                                        ; drop through

;-----------------------------------------------------------------------------
; Return mouse buttons to the user
; Entry:  R0,R1 = mouse x,y coords
;         R2 = mouse buttons:

;              bits 0-3  = normal response    (depends on button type)
;              bits 4-7  = 'drag' operation   (button held down)
;              bits 8-11 = 'select' operation (ie. 1 click if it's that type)
;         R3,R4 = window/icon handles (-1 if none)
; Exit:   data put into [userblk], and Mouse_Click returned
;-----------------------------------------------------------------------------

justtellhim
        CMP     R4,#nullptr2
        BLE     wimpaction              ; click in system area
;
; if R3 is really -1, then we shouldn't return it to anyone
; (menu clicks on background only work in single-tasking mode)
;
        LDR     R14,backwindowhandle    ; this counts as the background too!
        CMP     R3,R14
        CMPNE   R3,#nullptr
        BEQ     repollwimp
;
; page in correct task (again) - R3 may be changed by waitdrag
;
        LDR     R14,iconbarhandle
        CMP     R14,#nullptr            ; don't do this if no iconbar!
        BEQ     notiniconbar
        TEQ     R3,R14
        BNE     notiniconbar
;
        Push    "R0-R4"                 ; save mouse data!
        BL      findicon                ; finds icon R4 in iconbar
        LDREQ   R14,[R2,#icb_taskhandle]
        Task    R14,EQ,"IconBar"
        Pull    "R0-R4"
        BNE     repollwimp              ; unrecognised!
        MOV     R3,#nullptr2            ; return window handle -2 for iconbar
        B       returnclick
;
; ensure that correct task is paged in
; NB ptrwindow may not be the same as R3 (eg. drag button activates later)
;
notiniconbar
        CMP     R3,#nullptr
        BEQ     repollwimp              ; window has been deleted!!!
        Abs     handle,R3
        LDR     R14,[handle,#w_taskhandle]
        Task    R14,,"ReturnClick"
;
        LDR     R14,flagword
        TST     R14,#buttonchange_bit
        BNE     trykeys
;
; if backwindow, pretend it's really window -1
;
        LDR     R14,backwindow
        TEQ     R3,R14
        MOVEQ   R3,#nullptr             ; (for menu clicks in singletask mode)
;
        CMP     R3,#nullptr             ; is it a real window?
        BEQ     %FT10                   ; if not then icon
;
        CMP     R4,#0
        BMI     %FT10                   ; if its the background then ignore it
;
	TST	R2,#button_middle	; ignore menu clicks for slabbing
	BNE	%FT10

        Push    "R0-R3"

; R3 = window handle / handle => window defn ( <= 0 if none )
; R4 = icon handle

        LDR     R14,[handle,#w_icons]
        ADD     R14,R14,R4,LSL #i_shift ; R14 -> icon defn
;
        LDR     R1,[R14,#i_flags]
        LDR     R3,[R14,#i_data+4]      ; get flags, -> validation string
      [ true
        AND     R14, R1, #if_buttontype ; border_icon/windowselected behaviour is only suitable for a few button types
        MOV     R14, R14, LSR #ib_buttontype
        TEQ     R14, #ibt_autorepeat
        TEQNE   R14, #ibt_click
        TEQNE   R14, #ibt_clickrelease
        TEQNE   R14, #ibt_click2
        TEQNE   R14, #ibt_dclick
        TEQNE   R14, #ibt_dclickrelease
        TEQNE   R14, #ibt_dclick2
        BNE     %FT03
      ]
        BL      getborder               ; decode to setup the border information
;
        TEQ     R0,#border_action
        TEQNE   R0,#border_defaultaction
	BNE	%FT03
;
	LDR	R14,border_windowselected    ; Make sure previous selected icon
	CMP	R14,#nullptr                 ; is unslabbed
	BEQ	%F1
	TEQ	R14,handle
	LDR	R0,border_iconselected
	CMP	R0,#nullptr
	BLE	%F1
	TEQ	R0,R4
	TEQEQ	R14,handle
	BEQ	%F2
	Push	"handle"
	MOV	handle,R14
	MOV	R1,#0
	MOV	R2,#is_inverted
	BL	int_set_icon_state
	Pull	"handle"

1       STR     handle,border_windowselected
        STR     R4,border_iconselected
;
2       LDRB    R0,autorepeating
        CMP     R0,#0
3       MOVNE   R0,#0
        STRNEB  R0,autorepeating
	BNE	%F5

        MOV     R0,R4                   ; R1 => icon handle
        MOV     R1,#is_inverted
        MOV     R2,#0
        BL      int_set_icon_state      ; and then select the icon
;
5
        Pull    "R0-R3"
10
;
; to ensure that Message_MenusDeleted arrives before the next click,
; send mouse clicks as messages if the message queue is not empty
;

returnclick
        LDR     R14,oldbuttons
        STMIA   userblk,{R0,R1,R2,R3,R4,R14}
        MOV     R0,#Mouse_Click

        LDR     R14,headpointer
        CMP     R14,#nullptr
        BEQ     ExitPoll                ; return directly for efficiency

        MOV     R1,userblk
        LDR     R2,taskhandle
        BL      int_sendmessage_fromwimp
        B       repollwimp              ; deliver outstanding messages


;----------------------------------------------------------------------------
; Check for a key press
;----------------------------------------------------------------------------

trykeys
        Debug   poll2, "Processing keys"
 [ UTF8
        ; First, check if caret task is queueing keypresses for later handling
        LDR     handle, caretdata + 0
        CMP     handle, #nullptr
        BEQ     %FT11                   ; still read character (may be hot!)
        BL      checkhandle             ; check it hasn't been deleted!
        MOVVS   handle, #nullptr
        STRVS   handle, caretdata + 0   ; if deleted, turn it off
        BVS     %FT11

        LDR     R14, [handle, #w_taskhandle]
        CMP     R14, #0
        LDRMI   R14, menutaskhandle
        LDR     R14, [wsptr, R14]
        LDR     R14, [R14, #task_flagword]
        TST     R14, #keypress_bit
        BNE     nothing                 ; queue for later handling
11

        ; See if we're in the middle of a multi-byte external key event
        LDRB    R14, keyout_buflen
        TEQ     R14, #0
        BEQ     trykeys_getinternalkeycode
        ADRL    R1, keyout_buffer
        LDRB    R6, [R1]                ; next byte to process
        ADD     R2, R1, R14
01      LDRB    R0, [R1, #1]            ; copy the other bytes down
        STRB    R0, [R1], #1
        CMP     R1, R2
        BLO     %BT01
        SUB     R14, R14, #1            ; decrement byte count
        STRB    R14, keyout_buflen

        LDR     R14, singletaskhandle
        CMP     R14, #nullptr
        BLEQ    topmost_window
        STREQ   R0, hotkeyptr           ; initialise hotkey system, unless we're single-tasking
        ADRL    R14, savedcaretdata     ; get caret data
        LDMIA   R14, {R0-R5}
        CMP     R0, #nullptr            ; is there a caret?
        BNE     %FT02
        BL      int_processkey          ; if not, send hotkey
        B       repollwimp              ; (no need to check if single-tasking, as we won't get here otherwise)
02      MOV     handle, R0
        BL      checkhandle             ; check savedcaret window hasn't been deleted
        MOVVS   R0, #0
        STRVSB  R0, keyout_buflen       ; if it has (!) then delete continuation byte queue
        BVS     trykeys                 ; and restart key processing
        LDR     R14, [handle, #w_taskhandle]
        CMP     R14, #0
        LDRMI   R14, menutaskhandle
        Task    R14,, "KeyPressed continuation"
        STMIA   userblk, {R0-R6}
        MOV     R0, #Key_Pressed
        B       ExitPoll                ; return Key_Pressed event

trykeys_getinternalkeycode
        ; Get the next "key" from the expanded function key (if applicable)
        ADR     R5, keystring_buffer
        ADRL    R7, keystring_buflen
        BL      get_internal_keycode_from_buffer
        CMP     R6, #-1                 ; was there one?
        BNE     trykeys_gotinternalkeycode

        ; Get the next task-generated key
        ADR     R5, keyprocess_buffer
        ADRL    R7, keyprocess_buflen
        BL      get_internal_keycode_from_buffer
        CMP     R6, #-1                 ; was there one?
        BNE     trykeys_gotinternalkeycode

        ; Fill our keyboard input buffer from kernel keyboard buffer (needed so we can look ahead)
        LDRB    R3, keyin_buflen
        ADRL    R5, keyin_buffer
      [ true
        MOV     R0, #&81                ; OS_Byte 129 (INKEY)
        MOV     R1, #0
        MOV     R2, #0                  ; time limit 0
        SWI     XOS_Byte
        TEQ     R2, #&FF
        BEQ     %FT02                   ; break if no byte available
        STRB    R1, [R5, R3]            ; stick byte in my buffer
        ADD     R3, R3, #1
        TEQ     R1, #0                  ; null byte (=> either a null or a function key) ?
        MOVEQ   R7, #2
        BEQ     %FT01
        BL      read_current_alphabet
        BNE     %FT02                   ; except in UTF-8, all chars are one byte
        MOV     R0, R1
        BL      estimate_UTF8_char_len  ; may return length 0, but that's okay because we've already read one byte
        MOV     R7, R1
01      CMP     R3, R7
      |
01      CMP     R3, #6
      ]
        BHS     %FT02                   ; break from loop if full
        MOV     R0, #&81                ; OS_Byte 129 (INKEY)
        MOV     R1, #0
        MOV     R2, #0                  ; time limit 0
        SWI     XOS_Byte
        TEQ     R2, #&FF
        BEQ     %FT02                   ; break if no byte available
        STRB    R1, [R5, R3]            ; stick byte in my buffer
        ADD     R3, R3, #1
        B       %BT01
02      STRB    R3, keyin_buflen

        ; Get a key from our input buffer
        ADRL    R7, keyin_buflen        ; R5 already set up
        BL      get_internal_keycode_from_buffer
        CMP     R6, #-1                 ; was there one?
        BEQ     nothing                 ; no keys to handle

trykeys_gotinternalkeycode
        ; *All* Key_Pressed events now return caretdata as it is at this time
        ; - ie. before the writable icon handling messes around with it.
        ; This saves on the horrible kludge of storing the Key_PressedOldData
        ; event number in order to specify where to get the caret data from.
        Push    "R0-R5"
        ADR     R14, caretdata
        LDMIA   R14, {R0-R5}
        ADRL    R14, savedcaretdata
        STMIA   R14, {R0-R5}
        Pull    "R0-R5"

        ; Page in correct task
        CMP     handle, #nullptr
        BEQ     %FT01
        LDR     R14, [handle, #w_taskhandle]
        CMP     R14, #0
        LDRMI   R14, menutaskhandle
        Task    R14,, "KeyPressed"
01

        ; KeyboardMenus gets a look in first
      [ KeyboardMenus
        LDR     R4, menuSP
        CMP     R4, #0
        BLT     %FT00                   ; no menu open so don't grab special keys

        ADR     R5, menudata            ; if it's a dbox then don't grab keys
        LDR     R5, [R5, R4]
        TST     R5, #3
        BNE     %FT00

        ADR     R14, menuhandles        ; if menu has caret then don't grab keys
        LDR     R14, [R14, R4]
        LDR     R0, menucaretwindow
        TEQ     R0, R14
        BEQ     %FT00

        TEQ     R6, #13                 ; check for return and cursor keys
        BEQ     handlemenukey
        TST     R6, #1:SHL:31
        BEQ     %FT00
        BIC     R14, R6, #1:SHL:31
        TEQ     R14, #&8C
        TEQNE   R14, #&8D
        TEQNE   R14, #&8E
        TEQNE   R14, #&8F
        SUBEQ   R6, R14, #(&8C-136)     ; map onto range 136-139
        BEQ     handlemenukey
00
      ]

        ; Handle escape keypresses
        TEQ     R6,#&1B                 ; escape?
        BNE     %FT02
      [ KeyboardMenus
        CMP     r4, #0                  ; if no menu open then skip
        BLT     %FT02
        TST     r5, #3                  ; check for dialogue
        SUBNE   r0, r4, #4              ; if dialogue open then just remove it
        MOVEQ   r0, #-4                 ; otherwise remove whole menu tree
        CMP     r0, #0
        BLLT    menusdeleted            ; send Message_MenusDeleted if whole menu going (preserves r0)
        BL      closemenus
      |
        LDR     R0,menuSP
        CMP     R0,#0
        BLT     %FT02

        BL      menusdeleted            ; send Message_MenusDeleted
        MOVVC   R0,#-4
        BLVC    closemenus
      ]
        BVC     nothing                 ; absorb escape if used to close menus
        B       ExitPoll                ; report error if any

02      ; Examine caret state to determine what to do with keypress
        ADRL    R14, savedcaretdata
        LDMIA   R14, {R0-R5}
        CMP     R0, #nullptr
        BEQ     tryhotkeys              ; no input focus
        CMP     R1, #nullptr
        BNE     processkey              ; wimp gets first bash at this one!

keypressed
; Return a Key_Pressed event to the caret-owning task
        BL      prepare_external_key_event
        STMIA   userblk, {R0-R6}
        MOV     R0,#Key_Pressed         ; task handle already set up
        B       ExitPoll

tryhotkeys
; Initiate hotkey chain of events
        BL      prepare_external_key_event
        MOVGT   R0, #0
        STRGTB  R0, keyout_buflen       ; don't cache the other bytes if we're single-tasking!
        BLLE    int_processkey
        B       repollwimp


; Support routines for the above

prepare_external_key_event
; Munges internal keycode back into UTF-8 / external keycode format, and initialises hotkey system
; Entry: R6 = internal key code
; Exit:  R6 = first external key code
;        keyout_buffer filled with any remaining external keycodes
;        hotkeyptr set up (unless we're not multitasking)
;        LE => we are multitasking
        Entry   "R0,R4,R5"
        TST     R6, #1:SHL:31           ; was it a function key?
        ANDNE   R6, R6, #&FF
        ORRNE   R6, R6, #&100           ; convert into external form if so
        BNE     %FT01

        BL      read_current_alphabet   ; are we in UTF-8 alphabet?
        ANDNE   R6, R6, #&FF
        BNE     %FT01                   ; return bottom byte if not

        SUB     sp, sp, #8
        MOV     R5, sp
        BL      convert_UCS4_to_UTF8
        LDRB    R6, [sp]                ; first byte
        SUB     R4, R4, #1
        STRB    R4, keyout_buflen       ; held-over byte count
        ADD     R14, R5, R4             ; -> last byte in sequence
        ADRL    R4, keyout_buffer
02      LDRB    R0, [R5, #1]!
        STRB    R0, [R4], #1
        CMP     R5, R14
        BLO     %BT02
        ADD     sp, sp, #8

01      LDR     R14, singletaskhandle
        CMP     R14, #nullptr
        BLEQ    topmost_window          ; if we're multitasking, get top window handle
        STREQ   R0, hotkeyptr           ; and store it as the first hotkey window
        EXIT                            ; leave flags as they are

get_internal_keycode_from_buffer
; Reads a key from one of keyin_buffer, keyprocess_buffer or keystring_buffer,
; from a range appropriate to the current alphabet
; Skips any malformed characters
; Entry: R5 -> buffer
;        R7 -> buffer length byte
; Exit:  R6 = internal keycode : -1 means no character
;                                &800000xx represents a function key
;                                else character code ( <= &7FFFFFFF if UTF-8 alphabet, <= &FF otherwise )
        Entry   "R0-R4"
        LDRB    R3, [R7]                ; get buffer length
get_internal_keycode_restartpoint
        CMP     R3, #0                  ; nothing in my buffer?
        MOVLE   R6, #-1
        EXIT    LE

        LDRB    R6, [R5]
        TEQ     R6, #0                  ; first byte null => either a null or a function key
        BNE     get_internal_keycode_isntafunctionkey

get_internal_keycode_isafunctionkey
        TEQ     R3, #1                  ; if it's just one null byte, it's a malformed character
        MOVEQ   R4, #1
        MOVEQ   R6, #-1
        BEQ     get_internal_keycode_removefrombuffer

        LDRB    R6, [R5, #1]
        TEQ     R6, #0
        ORRNE   R6, R6, #1:SHL:31       ; unless a null, set top bit to indicate function key status
        MOV     R4, #2                  ; either way, it's a 2-byte character
        B       get_internal_keycode_removefrombuffer

get_internal_keycode_isntafunctionkey
        BL      read_current_alphabet
        MOVNE   R4, #1                  ; if not UTF-8, then it's got to be a valid 1-byte character
        BNE     get_internal_keycode_removefrombuffer

        MOV     R6, R5
        MOV     R4, R3
        BL      convert_UTF8_to_UCS4    ; sets up R4 and R6

get_internal_keycode_removefrombuffer
        ; R6 = internal Wimp key number, or -1 if malformed
        ; R4 = number of bytes of keyboard buffer it used
        SUB     R3, R3, R4              ; number of bytes that will still be in buffer after removal
        STRB    R3, [R7]
        ADD     R1, R5, R3              ; -> byte after final byte in buffer (after copying down)
        MOV     R2, R5                  ; rover
01      LDRB    R0, [R2, R4]
        STRB    R0, [R2], #1            ; copy down
        CMP     R2, R1
        BLO     %BT01

        CMP     R6, #-1                 ; was it a malformed character?
        BEQ     get_internal_keycode_restartpoint  ; swallow it if so!

        EXIT

 | ; else not UTF8...

 [ KeyboardMenus
        MOV     r6, #-1                 ; so we can tell later on if we read a key
        LDR     r4, menuSP
        CMP     r4, #0
        BLT     %FT00                   ; no menu open so don't grab special keys

        ADR     r5, menudata            ; if it's a dbox then don't grab keys
        LDR     r5, [r5, r4]
        TST     r5, #3
        BNE     %FT00

        ADR     r14, menuhandles        ; if menu has caret then don't grab keys
        LDR     r14, [r14, r4]
        LDR     r0, menucaretwindow
        TEQ     r0, r14
        BEQ     %FT00

        MOV     r0, #4                  ; allow us to read cursor keys
        MOV     r1, #1
        SWI     XOS_Byte
        MOV     r3, r1
        MOV     r0, #&81                ; INKEY(0)
        MOV     r1, #0
        MOV     r2, #0
        SWI     XOS_Byte
        MOV     r6, r1
        MOV     r7, r2
        MOV     r0, #4                  ; restore cursor key state
        MOV     r1, r3
        SWI     XOS_Byte
        CMP     r7, #&FF                ; was there a key?
        BEQ     nothing

        TEQ     r6, #13                 ; check for return and cursor keys
        TEQNE   r6, #136
        TEQNE   r6, #137
        TEQNE   r6, #138
        TEQNE   r6, #139
        BEQ     handlemenukey
 ]
00
        LDR     handle,caretdata+0
        CMP     handle,#nullptr
        BEQ     %FT01                   ; still read character (may be hot!)
;
        BL      checkhandle             ; check it hasn't been deleted!
        MOVVS   handle,#nullptr
        STRVS   handle,caretdata+0      ; if deleted, turn it off
        BVS     %BT00
;
        LDR     R14,[handle,#w_taskhandle]
        CMP     R14,#0
        LDRMI   R14,menutaskhandle

        LDR     R14,[wsptr,R14]
        LDR     R14,[R14,#task_flagword]
        TST     R14,#keypress_bit
        BNE     nothing                 ; temporarily disabled

01
 [ KeyboardMenus
        CMP     r6, #0
        BGE     %FT22
        BL      inkey0                  ; if we don't have a key yet then get one
        MOVS    r6, r1
22
 |
        BL      inkey0                  ; may branch elsewhere
        MOVS    R6,R1                   ; actual key value
 ]
        BNE     %FT01
        BL      inkey0                  ; may branch elsewhere!
        MOVS    R6,R1
        ADDNE   R6,R6,#&100             ; add &100 to the value (unless 0)
01
        LDR     R14,caretdata+0
        CMP     R14,#nullptr
        LDRNE   R14,[handle,#w_taskhandle]
        LDREQ   R14,menutaskhandle
        Task    R14,,"KeyPressed"       ; page in correct task

        TEQ     R6,#&1B                 ; escape?
        BNE     %FT02

 [ KeyboardMenus
        CMP     r4, #0                  ; if no menu open then skip
        BLT     %FT02
        TST     r5, #3                  ; check for dialogue
        SUBNE   r0, r4, #4              ; if dialogue open then just remove it
        MOVEQ   r0, #-4                 ; otherwise remove whole menu tree
        CMP     r0, #0
        BLLT    menusdeleted            ; send Message_MenusDeleted if whole menu going (preserves r0)
        BL      closemenus
 |
        LDR     R0,menuSP
        CMP     R0,#0
        BLT     %FT02

        BL      menusdeleted            ; send Message_MenusDeleted
        MOVVC   R0,#-4
        BLVC    closemenus
 ]
        BVC     nothing                 ; absorb escape if used to close menus
        B       ExitPoll                ; report error if any

02      ADR     R14,caretdata
        LDMIA   R14,{R0-R5}
        CMP     R0,#nullptr
        BEQ     tryhotkeys              ; no input focus
        CMP     R1,#nullptr
        BNE     processkey              ; wimp gets first bash at this one!

keypressed
        STMIA   userblk,{R0-R6}         ; including the key value
        LDR     R14,singletaskhandle
        CMP     R14,#nullptr
        BLEQ    topmost_window
        STREQ   R0,hotkeyptr
;

        MOV     R0,#Key_Pressed         ; task handle already set up
        B       ExitPoll

tryhotkeys
        LDR     R14,singletaskhandle
        CMP     R14,#nullptr

; Set hotkeyptr to topmost window

        BLEQ    topmost_window
        STREQ   R0,hotkeyptr
        BLEQ    int_processkey          ; R6 = key code
        B       repollwimp

inkey0
        Push    "LR"
        MOV     R0,#&81                 ; INKEY(0)
        MOV     R1,#0
        MOV     R2,#0
        SWI     XOS_Byte
        Pull    "LR"
        BVS     ExitPoll                ; wot?
;
        CMP     R2,#&FF                 ; was there a key?
        BEQ     nothing
        MOV     PC,LR

 ] ; end UTF8 conditional


 [ KeyboardMenus
; In:   r4 = menuSP
;       r5 -> menu data
;       r6 = key pressed
;
handlemenukey
        LDR     R14, menutaskhandle
        Task    R14,,"KeyPressed"       ; page in correct task

        LDR     r14, mousexpos
        STR     r14, lastxpos
        LDR     r14, mouseypos
        STR     r14, lastypos

        ADR     r14, menuselections
        LDR     r1, [r14, r4]           ; r1 = previous selection index

        TEQ     r6, #13
        BNE     trymenucursorkeys
        CMP     r1, #0                  ; handle return
        BLT     nothing                 ; do nothing if no selection
        STR     r4, whichmenu
        MOV     r2, #4                  ; fake SELECT mouse button
        B       gomenuselect

trymenucursorkeys
        TEQ     r6, #137                ; check for right (sub-menu)
        BNE     trymenuleft
        CMP     r1, #0                  ; handle right
        BLT     nothing
        ADD     r7, r1, r1, LSL #1      ; r7 = selected item * 3 (also used later)
        ADD     r6, r5, r7, LSL #3      ; r6 -> selected menu item
        LDR     r1, [r6, #mi_submenu]   ; r1 -> sub-menu data block
        AcceptLoosePointer_NegOrZero r1,0
        CMP     r1, r1, ASR #31         ; check for sub-menu/dbox
        BEQ     nothing
        ADR     r14, menuhandles        ; get menu window handle
        LDR     handle, [r14, r4]
        BL      checkhandle
        BVS     nothing
        LDR     r2, reversedmenu
        CMP     r2, #"\\"
        LDREQ   r2, [handle, #w_wax0]   ; get menu x
        LDRNE   r2, [handle, #w_wax1]
        LDR     r14, [handle, #w_icons]
        ADD     r14, r14, #i_bby1
        ADD     r7, r7, #1              ; r7 = middle icon
        LDR     r3, [r14, r7, ASL #i_shift]
        LDR     r14, [handle, #w_way1]
        ADD     r3, r3, r14             ; get menu y
        LDR     r14, [handle, #w_scy]
        SUB     r3, r3, r14             ; adjust for scrolling
 [ NCMenus
        ADD     r3, r3, #24             ; adjust for NCMenus border
 ]
        LDR     r14, [r6, #mi_mflags]
        TST     r14, #mif_warning
        BLNE    sendmenuwarning         ; preserves flags
        BLEQ    int_create_menu
        B       nothing

trymenuleft
        TEQ     r6, #136
        BLNE    trymenuupdown           ; preserves flags
        BNE     nothing
        SUBS    r0, r4, #4              ; handle left
        BLGE    closemenus
        B       nothing

trymenuupdown
; In:   r1 = current selected menu item
;       r4 = menuSP
;       r5 -> menu data
;       r6 = key pressed
; Out:  Could corrupt almost anything
;       Flags preserved
;
        EntryS
        MOV     r7, #0                  ; determine how many items in menu
00
        ADD     r7, r7, #1
        LDR     r0, [r5], #mi_size
        TST     r0, #mif_lastone
        BEQ     %BT00

        CMP     r1, #-1
        SUBEQ   r1, r7, #1
        MOV     r0, r1                  ; start with current menu item
trynextupdown
        TEQ     r6, #138                ; check for down
        BNE     trymenuupkey
        ADD     r0, r0, #1              ; handle down key
        CMP     r0, r7
        MOVGE   r0, #0                  ; wrap if necessary
        B       %FT10

trymenuupkey
        TEQ     r6, #139                ; check for up
        BNE     %FT20
        SUBS    r0, r0, #1              ; handle up key
        SUBLT   r0, r7, #1              ; wrap if necessary
10
        TEQ     r0, r1                  ; if all menu items grey then don't loop forever
        BEQ     %FT20

        ADR     r14, menuhandles
        LDR     handle, [r14, r4]       ; get menu window handle
        BL      checkhandle
        BVS     %FT20
        Push    "r6,r7"
        BL      menuhighlight
        Pull    "r6,r7"
        BVS     %FT20
        TEQ     r14, #0
        BEQ     trynextupdown           ; if item greyed out then try next
20
        EXITS
 ]

;----------------------------------------------------------------------------
; Return to next task with null event
; The 'PollIdle' class of tasks is considered first,
; followed by the 'Poll' tasks (if none of the others have timed-out)
; The current task is taken as the starting point.
;----------------------------------------------------------------------------

nothing
      [ redrawlast
        B       check_redraw

check_null
      ]

        SWI     XOS_ReadMonotonicTime
        BVS     ExitPoll                ; wot?
;
; if an old-style program is running, the other clients are ignored
;
        LDR     R14,polltaskhandle
        LDR     R5,singletaskhandle
        TEQ     R14,R5
        BEQ     nullexit
;
; Wimp_Poll treated as Wimp_PollIdle but with immediate timeout
;
        LDR     R5,nulltaskhandle
        ADD     R5,wsptr,R5             ; R5 --> current task data
        ADD     R5,R5,#4                ; start at next one along
        ADRL    R7,taskpointers+maxtasks*4 ; R7 = wrap address
        MOV     R6,#maxtasks            ; R6 = number to try
01
        CMP     R5,R7
        ADRCSL  R5,taskpointers
        LDR     R4,[R5],#4
        TST     R4,#task_unused
        LDREQ   R14,[R4,#task_flagword]
        TSTEQ   R14,#null_bit
        BNE     %FT02
        TST     R14,#flag_pollidle
        BEQ     returnnull
        LDR     R2,[R4,#task_registers+2*4]
        CMP     R0,R2
        BPL     returnnull              ; time's up! (use PL not CS)
02
        SUBS    R6,R6,#1
        BNE     %BT01
        B       triggercallbacks        ; no 'null return' tasks

returnnull

        SUB     R14,R5,#4
        SUB     R14,R14,wsptr           ; R14 = task handle
        STR     R14,nulltaskhandle
        Task    R14,,"Null"

        MOV     R0,#No_Reason           ; null reason code
        B       ExitPoll

nullexit
        LDR     R14,flagword            ; single-tasking exit
        TST     R14,#null_bit
        BNE     triggercallbacks
        MOV     R0,#No_Reason           ; null reason code
        B       ExitPoll

triggercallbacks
        ; No null events to deliver, so try triggering callbacks
      [ UseLeaveOS
        SWI     XOS_LeaveOS
      |
      [ Medusa
        MRS     r0, CPSR
        BIC     r0, r0, #&F             ; drop to same 32-bitness of USR mode
        MSR     CPSR_c, r0
      |
        TEQP    pc, #0
        NOP
      ]
        SWI     XOS_IntOn               ; callbacks will be triggered on exit
      ]
        SWI     XOS_EnterOS
        B       repollwimp

;-----------------------------------------------------------
; Remove task from list of tasks with pollwords
;
; In:
;   handle = task to remove (if found)
;
; Out:
;   None, preserves flags
;
;-----------------------------------------------------------


DeletePollTask  EntryS "R0,R1"
        ADR     R0,PollTasks            ; Get -> start of polltask list
        LDR     R1,PollTaskPtr          ; Get -> first free slot
01
        CMP     R0,R1                   ; End of list?
        EXITS   HS                      ; Yes then exit, not found

        LDR     LR,[R0],#4              ; Get polled task handle
        TEQ     LR,handle               ; Match?
        BNE     %BT01                   ; No then try next polled task

        LDR     LR,[R1,#-4]!            ; Get last entry
        STR     LR,[R0,#-4]!            ; Overwrite current entry
        STR     R1,PollTaskPtr          ; New end of list

        Debug   poll,"Delete poll: handle, posn, new, end",handle,R0,LR,R1

        EXITS



;;----------------------------------------------------------------------------
;; Check tasks' poll words to see if they are non-zero
;;----------------------------------------------------------------------------

; In    R0 = mask word to apply to poll words (only consider if word & R0 set)
; Out   NE => R0=reason code, correct task paged in
;       [userblk,#0] = poll word address
;       [userblk,#4] = poll word contents, as read (once) by Wimp


scanpollwords   Entry "R1-R4"
        ADR     R1,PollTasks            ; Get -> start of polltask list
        LDR     R2,PollTaskPtr          ; Get -> first free slot
01
        TEQ     R1,R2                   ; End of list?
        EXIT    EQ                      ; Yes then exit, not found

        LDR     LR,[R1],#4              ; Read polled task handle
        LDR     R3,[LR,wsptr]           ; Read address of task data
        LDR     R3,[R3,#task_pollword]  ; Task pollword
        TST     R3,R0                   ; NE => consider this
        BICNE   R3,R3,#1                ; Can't combine this with LDR because non-rotated value mus be stored below
        LDRNE   R4,[R3]                 ; Read pollword
        TEQNE   R4,#0                   ; NE => word non-zero!
        BEQ     %BT01                   ; Jump if not found

        Debug   poll,"Pollword non-zero: task,list,address",LR,R1,R3

        Task    LR,,"Poll word"         ; preserves flags
        MOV     R0,#PollWord_NonZero    ; R0 = reason code
        STMIA   userblk,{R3,R4}

        EXIT                            ; Returns NE




;-----------------------------------------------------------------------------

pendingtime
        Push    "R2,LR"
;
        LDR     R14,timeblk
        LDR     R2,pending_time
        SUB     R14,R14,R2              ; R14 = elapsed time since 1st press
;
        Pull    "R2,PC"                 ; preserves flags


;----------------------------------------------------------------------------
; Routine to select an icon
; Also deselects any other icons in the same ESG
; Entry:  handle,R4 = window/icon to select
;         R2 = button state causing selection
;----------------------------------------------------------------------------

selecticon
        EntryS  "R0-R8"
;
        LDR     R5,[handle,#w_icons]
        ADD     R5,R5,#i_flags

        LDR     R6,[R5,R4,ASL #i_shift]         ; get flags
        ANDS    R14,R6,#if_esg2                 ; get ESG field
        MOVEQ   R2,#0                           ; invert state if on it's own
        BEQ     goselect
;
        TST     R6,#if_canadjust                ; can we select multiply?
        TSTNE   R2,#button_right
        BNE     dontcancel                      ; allow 'adjust' to work
        MOV     R6,R14                          ; get ESG
;
        LDR     R8,[handle,#w_nicons]
sellp
        SUBS    R8,R8,#1
        BMI     dontcancel                      ; finished
        CMP     R8,R4
        BEQ     sellp                           ; ignore this one
;
        LDR     R7,[R5,R8,ASL #i_shift]
        AND     R14,R7,#if_esg2                 ; see if same ESG
        TEQ     R14,R6
        BNE     sellp
;
        TST     R7,#is_inverted
        MOVNE   R0,R8
        MOVNE   R1,#0                   ; EOR value
        MOVNE   R2,#is_inverted         ; BIC value
        BLNE    int_set_icon_state
        B       sellp

dontcancel
        LDR     R2,[R13,#Proc_RegOffset+8] ; get button state again!
        TST     R2,#button_right
        MOVNE   R2,#0
        BNE     goselect                ; invert state if using ADJUST
;
        LDR     R14,[R5,R4,ASL #i_shift]        ; don't bother if already done
        TST     R14,#is_inverted
        BNE     exitselect
;
        MOV     R2,#is_inverted         ; BIC value (ie. set this state)
goselect
        MOV     R0,R4                   ; icon handle
        MOV     R1,#is_inverted         ; EOR value
        BL      int_set_icon_state
;
exitselect
        STRVS   R0,[R13,#Proc_RegOffset]
        EXITV                           ; preserve V


;;----------------------------------------------------------------------------
;; Wimp system icon detection
;; Entry:  R0,R1 = coords of mouse pointer
;;         R4 = -2 (in system area)
;;         handle -> window definition
;; Exit :  R4 = -2 to -n (corresponding to which icon the pointer is over)
;;         R5 = appropriate flag word
;;         other registers preserved (inc. flags)
;;----------------------------------------------------------------------------

setwimpicon
        CMP     R3,#nullptr
        MOVEQ   PC,LR                           ; forget it!
;
        Push    "R2,R3,x0,y0,x1,y1,LR"
;
        MOV     R3,#wf_icon1
        MOV     R4,#1
        LDR     R2,[handle,#w_flags]
01
        TST     R2,R3
        BEQ     %FT02
05
        Push    "R0,R1"
        MOV     R0,R4
        BL      calc_w_iconposn
        Pull    "R0,R1"
        CMP     R0,x0
        CMPGT   R1,y0
        CMPGT   x1,R0
        CMPGT   y1,R1
        BLE     %FT02
;        Debug   ub,"on an icon !"
;
        CMP     R4,#5                   ; icon 5 is really 3 icons
        BEQ     check_v_arrows
        ADDHI   R4,R4,#2
        CMP     R4,#7+2                 ; fudge!
        BEQ     check_h_arrows          ; icon 7 is also really 3 icons
      [ IconiseButton
        ADDHI	R4,R4,#3		; and skip -13 (which is the border)
      ]
03
      [ BounceClose
        LDRB    R14, buttontype
        TEQ     R14, #0
        ADREQ   R14, wiconflags - 4
        ADRNE   R14, wiconflags_release - 4
      |
        ADR     R14,wiconflags-4
      ]
        LDR     R5,[R14,R4,ASL #2]
        CMP     R5,#-1
        MOVEQ   R5,#ibt_click:SHL:ib_buttontype
        TSTEQ   R2,#wf_userscroll2      ; debounced form of userscroll
        MOVEQ   R5,#ibt_autorepeat:SHL:ib_buttontype
        MOV     R14,#-1
        SUB     R4,R14,R4               ; R4 in range -2 to -n
        Pull    "R2,R3,x0,y0,x1,y1,PC"

check_v_arrows
      [ ChildWindows
        LDR     R14,up_height           ; if scrollbar is small, only the arrows are shown (scaled down)
        LDR     R5,down_height
        ADD     R5,R14,R5
        SUB     R14,y1,y0
        CMP     R5,R14
        BLE     %FT10

        ADD     R14,y0,R14,LSR #1
        CMP     R1,R14
        ADDLT   R4,R4,#2                ; down arrow
        B       %BT03
10
      ]
        LDR     R14,up_height
        SUB     R14,y1,R14
        CMP     R1,R14
        ADDLT   R4,R4,#1                ; not up-arrow
        LDR     R14,down_height
        ADD     R14,y0,R14
        CMP     R1,R14
        ADDLT   R4,R4,#1                ; not middle bit
        B       %BT03

check_h_arrows
      [ ChildWindows
        LDR     R14,left_width          ; if scrollbar is small, only the arrows are shown (scaled down)
        LDR     R5,right_width
        ADD     R5,R14,R5
        SUB     R14,x1,x0
        CMP     R5,R14
        BLE     %FT11

        ADD     R14,x0,R14,LSR #1
        CMP     R0,R14
        ADDGT   R4,R4,#2                ; right arrow
        B       %BT03
11
      ]
        LDR     R14,left_width
        ADD     R14,x0,R14
        CMP     R0,R14
        ADDGT   R4,R4,#1                ; not left-arrow
        LDR     R14,right_width
        SUB     R14,x1,R14
        CMP     R0,R14
        ADDGT   R4,R4,#1                ; not middle bit
        B       %BT03

02
        MOVS    R3,R3,ASL #1
        ADD     R4,R4,#1
        CMP     R4,#8
        BLO     %BT01
      [ IconiseButton
	BHI	%FT04
	LDR	R2,[handle,#w_flags]
	TST	R2,#wf_icon2
	BEQ     %FT04
	LDR     R2, [handle, #w_parent]
	CMP     R2, #-1
	BNE     %FT04
	LDRB    R2, iconisebutton
	TEQ     R2, #0
	BNE     %BT05
04
      ]
;
        MOV     R4,#bordericon                          ; in the border
        MOV     R5,#ibt_never :SHL: ib_buttontype       ; has no effect
        Pull    "R2,R3,x0,y0,x1,y1,PC"


wiconflags
        DCD     ibt_click        :SHL: ib_buttontype        ; back
        DCD     ibt_click        :SHL: ib_buttontype        ; quit
        DCD     ibt_click        :SHL: ib_buttontype        ; move BLOBBY
        DCD     ibt_click        :SHL: ib_buttontype        ; toggle
        DCD     -1                                          ; scup
        DCD     ibt_click        :SHL: ib_buttontype        ; scvert
        DCD     -1                                          ; scdown
        DCD     ibt_click        :SHL: ib_buttontype        ; size
        DCD     -1                                          ; scleft
        DCD     ibt_click        :SHL: ib_buttontype        ; schoriz
        DCD     -1                                          ; scright
bordericon      *       -2 - (.-wiconflags)/4
	[ IconiseButton
	DCD	-1
	DCD	ibt_click        :SHL: ib_buttontype	    ; iconise
	]

    [ BounceClose
wiconflags_release
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; back
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; quit
        DCD     ibt_click        :SHL: ib_buttontype        ; move BLOBBY
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; toggle
        DCD     -1                                          ; scup
        DCD     ibt_click        :SHL: ib_buttontype        ; scvert
        DCD     -1                                          ; scdown
        DCD     ibt_click        :SHL: ib_buttontype        ; size
        DCD     -1                                          ; scleft
        DCD     ibt_click        :SHL: ib_buttontype        ; schoriz
        DCD     -1                                          ; scright
	[ IconiseButton
	DCD	-1
	DCD	ibt_clickrelease :SHL: ib_buttontype	    ; iconise
	]
    ]

wimpaction
        CMP     R3,#nullptr             ; is this a real window?
        BLNE    pageinicontask_R3R4     ; takes note of iconbar

        TST     R2,#button_left:OR:button_right
        BEQ     trykeys                         ; menu not allowed here!
        ADR     R14,wiconjump-8
        SUB     PC,R14,R4,ASL #2                ; wow!

wiconjump
        B       wicon_back
        B       wicon_quit
        B       wicon_move
        B       wicon_toggle
        B       wicon_scup
        B       wicon_scvert
        B       wicon_scdown
        B       wicon_size
        B       wicon_scleft
        B       wicon_schoriz
        B       wicon_scright
	[ IconiseButton
	MOV	PC,#0
	B	wicon_iconise
	]


;;----------------------------------------------------------------------------
;; jump destinations for possible wimp icons
;;----------------------------------------------------------------------------

wicon_size
        MOV     R0,#drag_size
        BL      int_drag_box            ; handle,R0 are params
        B       trykeys

wicon_move
        MOV     R0,#drag_posn
        BL      int_drag_box            ; handle,R0 are params
        B       trykeys

wicon_toggle
        MOV     R1,#wf_isapane          ; we want to ignore panes
        BL      go_get_window_state     ; 2nd entry point - uses R1
        LDR     R14,[handle,#w_flags]
      [ togglebits
        TST     R14,#ws_toggled :OR: ws_toggled2
        BIC     R14,R14,#ws_toggled2
      |
        TST     R14,#ws_toggled
      ]
        ORR     R14,R14,#ws_toggling     ; set up to toggle when opened
        ORREQ   R14,R14,#ws_onscreenonce ; keep on-screen this time
        STR     R14,[handle,#w_flags]
        BNE     makesmall
;
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        ADD     R14,handle,#w_bwax0     ; remember old position
        STMIA   R14!,{cx0,cy0,cx1,cy1}
        LDR     x0,[handle,#w_scx]
        LDR     y0,[handle,#w_scy]
        LDR     x1,[handle,#w_bhandle]

        STMIA   R14,{x0,y0,x1}
;
        ADD     R14,handle,#w_wex0      ; add max size to get other coords
        LDMIA   R14,{x0,y0,x1,y1}
        SUB     x1,x1,x0
        SUB     y1,y1,y0
        ADD     cx1,cx0,x1
        SUB     cy0,cy1,y1

; Now check to see if <shift> is depressed, either will do.  If it
; is then attempt to toggle the window to a sensible size, not obscuring
; the icon bar.

        Push    "R0-R2,R4,R6"

      [ ChildWindows
        LDR     R14,[handle,#w_parent]
        CMP     R14,#nullptr
        BNE     %FT01                   ; this stuff only applies to top-level windows
      ]

	LDR	R4,iconbarheight
	SUB	R4,R4,#8;-40
	LDR	R14,[handle,#w_flags]
	TSTS	R14,#wf_icon7
        LDRNE   R14,hscroll_height
        ADDNE   R4,R4,R14               ; area not to be obscured

        SUBS    R6,cy0,R4               ; does the bottom of the window obscure the icon bar?
        BGE     %FT01                   ; if not then don't bother faffing around

        MOV     R0,#121
        MOV     R1,#&80
        SWI     XOS_Byte                ; scan for shift being depressed

      [ togglebits
        Push    "R1"
        MOV     R0,#ReadCMOS
        MOV     R1,#FileSwitchCMOS
        SWI     XOS_Byte                ; check for special <shift> toggle action
        TST     R2,#WimpShiftToggleCMOSBit
        Pull    "R1"
        EORNE   R1,R1,#255              ; if active then invert the action
      ]

        TEQ     R1,#&FF
        BNE     %FT01                   ; if it isn't then ignore the munging of the bits

        MOV     cy0,R4
        SUB     cy1,cy1,R6              ; setup the new co-ordinates for bottom & top Y's

	LDR	R6,scry1
      [ togglebits
        LDR     R14, [handle, #w_flags]
        TST     R14, #wf_icon3          ; we can still have a toggle-size button without a title bar!
        LDRNE   R14, title_height
        SUBNE   R6, R6, R14
      |
	LDR	R14,title_height
	SUB	R6,R6,R14
      ]
	LDR	R14,iconbarheight
	SUB	R14,R14,#8
	SUB	R0,R6,R14
	LDR	R14,[handle,#w_flags]
	TSTS	R14,#wf_icon7
	LDRNE	R14,hscroll_height
	SUBNE	R0,R0,R14		; R0 = max window height that can fit on screen
	CMPS	y1,R0
	MOVGT	cy1,R6		        ; window won't fit at maximum extent, so carefully trim
	SUBGT	y1,cy1,cy0

      [ togglebits
        LDR     R14,[handle,#w_flags]   ; set toggled in silly way bit
        ORR     R14,R14,#ws_toggled2
        STR     R14,[handle,#w_flags]
      ]
01
        Pull    "R0-R2,R4,R6"

        ADD     R14,userblk,#u_wax0
        STMIA   R14,{cx0,cy0,cx1,cy1}
;
      [ togglebits
        SUB     cx0,cx1,cx0
        SUB     cy0,cy1,cy0             ; work out the area really shown
;
        ASSERT  w_toggleheight = w_togglewidth +4
        ADD     R14,handle,#w_togglewidth
        STMIA   R14,{cx0,cy0}           ; push the co-ordinates away
      ]
;
        BL      calc_w_status           ; ensure bhandle up-to-date

      [ BounceClose
        LDR     R2,pending_buttons      ; Horrible hack so adjust works even with release buttons
      |
        LDR     R2,mousebuttons         ; bhandle depends on adjust button
      ]

openwindow_checkbuttons
        TST     R2,#button_right        ; if adjust used, open at same level,
      [ true
        LDR     R14,[handle,#w_bhandle]
        BNE     %FT02
        ; first the special cases: if *this* window is a pane or a foreground window, use a bhandle of -1
        MOV     R4,#wf_isapane
        ORR     R4,R4,#wf_inborder      ; wf_isapane:OR:wf_inborder isn't a valid immediate constant
        LDR     R3,[handle,#w_flags]
        TST     R3,R4
        MOVNE   R14,#nullptr
        BNE     %FT02
        ; now check the windows above us in our window stack: if they're all either panes or foreground
        ; windows, then don't attempt any reordering, otherwise we end up in an endless loop opening
        ; panes in front of their main windows and vice versa, and nobody else gets any processor time
        LDR     R1,[handle,#w_active_link+ll_backwards]
01      LDR     R2,[R1,#ll_backwards]
        CMP     R2,#nullptr             ; if we've reached the front of the window stack
        BEQ     %FT02                   ; then break leaving R14 = current bhandle
        LDR     R3,[R1,#w_flags-w_active_link]
        TST     R3,R4
        MOVNE   R1,R2
        BNE     %BT01
        MOV     R14,#nullptr            ; found a non-pane non-foreground window: move drag window to top of stack
02
      |
        MOVEQ   R14,#nullptr            ; otherwise open window at front
        LDRNE   R14,[handle,#w_bhandle]
      ]
        STR     R14,[userblk,#u_bhandle]
;
        B       Exit_OpenWindow


makesmall
        ADD     R14,handle,#w_bwax0
        LDMIA   R14,{cx0,cy0,cx1,cy1,x0,y0,x1}  ; Load previous x0,y0,x1,y1,scx,scy,bhandle

        ; SMC: 18th January 1995
        ; Correct fix for MED-03674, original fix (amg: 28th September 1994) was too simple
        ; and caused MED-04376 which the following also fixes.

        CMP     x1, #nullptr                    ; If this window was at the top
        BEQ     %FT20                           ; then open it there.

        Push    "r2,r3"
      [ ChildWindows
        LDR     r14, [handle, #w_parent]            ; depending on whether this window is at the top-level,
        CMP     r14, #nullptr
        LDREQ   r2, activewinds+lh_forwards         ; scan the list of topmost windows
        LDRNE   r2, [r14, #w_children+lh_forwards]  ; or the list of siblings
      |
        LDR     r2, activewinds+lh_forwards     ; Otherwise, scan down the list of windows.
      ]
        BIC     r3, x1, #3                      ; Align bhandle for comparisons (should really use the Abs macro)
10
        LDR     r2, [r2, #ll_forwards]
        CMP     r2, #nullptr                    ; If we hit the end,
        LDRNE   r14, [r2, #w_flags-w_active_link]
        ANDNE   r14, r14, #wf_backwindow
        TEQNE   r14, #wf_backwindow             ; or if we hit a backwindow
        MOVEQ   x1, #-2                         ; then open our window at the bottom.
        SUBNE   r14, r2, #w_active_link
        TEQNE   r14, handle                     ; If we hit this window???
        TEQNE   r14, r3                         ; or the one to open behind then drop out and open behind stored window
        BNE     %BT10                           ; else go round loop again.
        Pull    "r2,r3"
20

        ADD     R14,userblk,#u_wax0
        STMIA   R14,{cx0,cy0,cx1,cy1,x0,y0,x1}
        B       Exit_OpenWindow

wicon_back
        BL      int_get_window_state
      [ true
        MOV     R0, #121
        MOV     R1, #&80
        SWI     XOS_Byte                ; Scan keyboard for Shift key
        TEQ     R1, #&FF
      ]
      [ true :LOR: RO4
        LDR     R14,pending_buttons
        AND     R14,R14,#button_right
        BEQ     %FT12                   ; Branch if so
        ASSERT  button_right = (nullptr - nullptr2)
11      ADD     R14,R14,#nullptr2
      |
        MOV     R14,#nullptr2                   ; will not match
      ]
        STR     R14,[userblk,#u_bhandle]        ; so will go to bottom
        B       Exit_OpenWindow

      [ true
12      LDR     R0,[userblk,#u_handle]
        Abs     R0,R0
        ADD     R0,R0,#w_active_link
        MOV     R2,#wf_isapane
        ORR     R2,R2,#wf_grabkeys
        TEQ     R14,#button_right
        MOVEQ   R3,#ll_backwards
        MOVNE   R3,#ll_forwards
        BNE     %FT14                   ; need to search 1 window down, or 2 windows up
13      LDR     R0,[R0,R3]
        LDR     R1,[R0,R3]
        CMP     R1,#nullptr             ; hit the stops?
        BEQ     %BT11                   ; yes, so behave as though shift wasn't pressed
        LDR     R1,[R0,#w_flags - w_active_link]
        TST     R1,R2
        BNE     %BT13                   ; skip over any panes or hotkey windows
14      LDR     R0,[R0,R3]
        LDR     R1,[R0,R3]
        CMP     R1,#nullptr             ; hit the stops?
        BEQ     %BT11                   ; yes, so behave as though shift wasn't pressed
        LDR     R1,[R0,#w_flags - w_active_link]
        TST     R1,#wf_backwindow       ; hit a backwindow (presumably going down)?
        BNE     %BT11                   ; don't open behind it!
        TST     R1,R2
        BNE     %BT14                   ; skip over any panes or hotkey windows
        SUB     R0,R0,#w_active_link
        Rel     R0,R0
        STR     R0,[userblk,#u_bhandle]
        B       Exit_OpenWindow
      ]

      [ IconiseButton
wicon_iconise
        Push	"r0-r4"
      [ MultiClose
        TST     R2, #button_right       ; Ctrl-Alt-*Adjust* isn't special
        MOVNE   R1, #0                  ; flag as due to iconise button
        BNE     %FT20

        MOV     R0, #121
        MOV     R1, #&81                ; Scan keyboard for Ctrl key
        SWI     XOS_Byte
        MOV     R4, R1
        MOV     R1, #&82                ; Scan keyboard for Alt key
        SWI     XOS_Byte
        TEQ     R4, #&FF
        TEQEQ   R1, #&FF
        MOVNE   R1, #0                  ; flag as due to iconise button
        BNE     %FT20

        ; Iconise all top-level windows that have close buttons (except hotkey windows)
        LDR     handle, activewinds + lh_forwards
        SUB     R0, handle, #w_active_link
        Rel     R0, R0
        STR     R0, nextwindowtoiconise
        BL      iconisenextwindow
        Pull    "R0-R4"
        B       trykeys

      |
        MOV     R1, #0                  ; NOT a shift+click on close icon
        B	%FT20
      ]
      ]

wicon_quit
        Push    "r0-r4"

        [ StickyMenus
        LDR     R0,[handle,#w_taskhandle]
        CMP     R0,#-1
        Pull    "r0-r4",EQ
        BEQ     not_alt                 ; can't iconise menu
        ]

        TST     R2,#button_right        ; If adjust, ignore it.
        Pull    "r0-r4",NE
        BNE     not_alt

      [ MultiClose
        MOV     R0, #121
        MOV     R1, #&81                ; Scan keyboard for Ctrl key
        SWI     XOS_Byte
        MOV     R4, R1
        MOV     R1, #&82                ; Scan keyboard for Alt key
        SWI     XOS_Byte
        TEQ     R4, #&FF
        TEQEQ   R1, #&FF
        BNE     %FT66

      [ BounceClose
        LDR     R2, pending_buttons
        STR     R2, mousebuttons        ; The usual Horrible Hack
      ]
        ; Close all windows at this level that have close buttons (except hotkey windows)
        LDR     handle, [handle, #w_parent]
        CMP     handle, #nullptr
        LDREQ   handle, activewinds + lh_backwards
        LDRNE   handle, [handle, #w_children + lh_backwards]
01      LDR     R0, [handle, #ll_backwards]
        CMP     R0, #nullptr
        BEQ     %FT02
        LDR     R14, [handle, #w_flags - w_active_link]
        TST     R14, #wf_icon2
        ANDNE   R14, R14, #wf_grabkeys
        TEQNE   R14, #wf_grabkeys
        MOVEQ   handle, R0
        BEQ     %BT01
        ; Found such a window; send close request message
        Push    "R0"
        SUB     handle, handle, #w_active_link
        SUB     sp, sp, #4
        Rel     R2, handle
        STR     R2, [sp]
        MOV     R0, #Close_Window_Request
        MOV     R1, sp
        BL      int_sendmessage_fromwimp
        ADD     sp, sp, #4
        Pull    "handle"
        B       %BT01
02
        Pull    "R0-R4"
        B       trykeys
66
      ]

        MOV     R0,#121                 ; Scan keyboard for shift key
        MOV     R1,#&80
        SWI     XOS_Byte

        CMP     R1,#&FF

        Pull    "r0-r4",NE
        BNE     not_alt

        [ ChildWindows
        LDR     R0, [handle, #w_parent] ; don't do anything if Shift-close on child windows
        CMP     R0, #-1
        Pull    "r0-r4",NE
        BNE     trykeys
        ]
20
      [ MultiClose
        LDR     r2, mousexpos
        LDR     r4, mouseypos
      ]
        BL      sendiconisemessages
        Pull    "r0-r4"
        B       trykeys

not_alt
        [ StickyMenus
;        LDR     R0,[handle,#w_taskhandle]
;        CMP     R0,#-1
;        BNE     %FT05
        LDR     R14,menuSP
        CMP     R14,#-4
        BEQ     %FT05                           ; no menu open

        LDR     R14,menuhandles
        Abs     R14,R14
        TEQ     handle,R14

        BNE     %FT02
        BL      menusdeleted
        MOVVC   R0,#-4
        BLVC    closemenus
        B       nothing                         ; swallow it.
02
        LDR     R14,menuSP
        ADD     R14,R14,#4
        ADR     R0,menuhandles
03
        LDR     R1,[R0,R14]
        Abs     R1,R1
        TEQ     R1,handle
        BEQ     %FT04
        SUBS    R14,R14,#4
        BGE     %BT03
        B       %FT05
04
        SUB     R0,R14,#4
        BL      closemenus              ; close down to one above
        B       nothing
05
        ]
	[ BounceClose
	STR	R2,mousebuttons		; Horrible hack so apps can tell that adjust was pressed
	]
        STR     R3,[userblk]
        MOV     R0,#Close_Window_Request
        B       ExitPoll

      [ MultiClose
iconisenextwindow
        Entry   "R0-R4,handle"
        LDR     handle, nextwindowtoiconise
        BL      checkhandle             ; make sure it's still valid
        TEQVS   PC, #0                  ; \ set Z = not (V)
        TEQVC   R0, R0                  ; /
        LDREQ   R14, [handle, #w_flags]
        ANDEQ   R0, R14, #ws_open
        CMPEQ   R0, #ws_open            ; and open
        ADDEQ   handle, handle, #w_active_link
        LDRNE   handle, activewinds + lh_forwards ; if not, restart from top
01
        LDR     R0, [handle, #ll_forwards]
        CMP     R0, #nullptr             ; have we reached the header?
        MOVEQ   R0, #0
        STREQ   R0, nextwindowtoiconise
        EXIT    EQ                       ; stop if we have
        LDR     R14, [handle, #w_flags - w_active_link]
        TST     R14, #wf_backwindow
        MOVNE   R0, #0
        STRNE   R0, nextwindowtoiconise
        EXIT    NE                       ; don't re-iconise already-iconised windows!
        TST     R14, #wf_icon2
        ANDNE   R14, R14, #wf_grabkeys
        TEQNE   R14, #wf_grabkeys
        MOVEQ   handle, R0
        BEQ     %BT01
        ; Found a suitable window; work out suitable entry conditions for sendiconisemessages
        Push    "R0"
        SUB     handle, handle, #w_active_link
        MOV     R0, #iconposn_iconise
        BL      calc_w_iconposn          ; x0-y1 = button bbox
        ADD     R2, x0, x1
        ADD     R4, y0, y1
        MOV     R2, R2, LSR#1
        MOV     R4, R4, LSR#1
        MOV     R1, #0
        Rel     R3, handle
        BL      sendiconisemessages
        ; Now store the next window to process (if any)
        Pull    "handle"
        LDR     R0, [handle, #ll_forwards]
        CMP     R0, #nullptr
        MOVEQ   R0, #0
        SUBNE   R0, handle, #w_active_link
        Rel     R0, R0, NE
        STR     R0, nextwindowtoiconise
        EXIT
      ]

sendiconisemessages
; Entry: R1 = &FF => caused by click on close icon; R1 = 0 => caused by click on iconise icon
;        R3 = relative window handle to send
; and if MultiClose enabled,
;        R2 = mouse x
;        R4 = mouse y
        Entry

        [ IconiseButton
        ; Send a Message_IconizeAt (RML)
        Push    "r3"
        SUB     sp, sp, #48

        CMP     r1, #&FF                 ; If a Shift+Click on close
        MOVEQ   r0, #1                   ; then bit 0 of flags is set
        MOVNE   r0, #0
        STR     r0, [sp, #ms_data+16]

        MOV     r1, sp
      [ MultiClose
        STR     r2, [r1, #ms_data+8]
        SUB     r4, r4, #32+17
        STR     r4, [r1, #ms_data+12]
      |
        LDR     r0, mousexpos
        STR     r0, [r1,#ms_data+8]
        LDR     r0, mouseypos
        SUB     r0, r0, #(32+17)
        STR     r0, [r1,#ms_data+12]
      ]
        MOV     r0, #40
        STR     r0, [r1,#ms_size]        ; size
        MOV     r0, #0
        STR     r0, [r1, #ms_yourref]    ; your ref
        LDR     r0, =Message_IconizeAt   ; (Message number 22)
        STR     r0, [r1, #ms_action]     ; message action
        STR     r3, [r1, #ms_data+0]     ; window handle

        ; Work out task handle
      [ MultiClose
        LDR     R2, [handle, #w_taskhandle]
      |
        LDR     r2, taskhandle
      ]
        LDR     r4, [wsptr, r2]          ; add in version bits (if alive)
        TST     r4, #task_unused
        LDREQ   r4, [r4, #task_flagword]
        MOVEQ   r4, r4, LSR #flag_versionbit
        ORREQ   r2, r2, r4, LSL #flag_versionbit
        STR     r2, [r1, #ms_data+4]

        MOV     r0, #User_Message
        MOV     r2, #0
        BL      int_sendmessage_fromwimp

        ADD     sp, sp, #48
        Pull    "r3"
        ]
                                                ; Shift-quit, send Message_Iconize.
        MOV     R14,#ms_data+8+20       ; size of block (Window,Task,20 byte from title ).
        STR     R14,[sp,#-(ms_data+8+20)]!
        MOV     R0,#User_Message
        MOV     R1,sp
        STR     R3,[R1,#ms_data]

      [ MultiClose
        LDR     R2, [handle, #w_taskhandle]
        LDR     R14, [handle, #w_titleflags]
        TST     R14, #if_indirected
        Task    "R2", NE, "Iconise: reading indirected title string"
      |
        LDR     R2,taskhandle
      ]
        LDR     R14,[wsptr,R2]          ; add in version bits (if alive)
        TST     R14,#task_unused
        LDREQ   R14,[R14,#task_flagword]
        MOVEQ   R14,R14,LSR #flag_versionbit
        ORREQ   R2,R2,R14,LSL #flag_versionbit
        STR     R2,[R1,#ms_data+4]

        ADD     R2,handle,#w_title
        LDR     R14,[handle,#w_titleflags]
        TST     R14,#if_indirected
        LDRNE   R2,[R2]                     ; If indirected get real address

00      LDRB    R3, [R2]                    ; always skip leading spaces
        TEQ     R3, #&20
        ADDEQ   R2, R2, #1
        BEQ     %BT00

        MOV     R14,R2                      ; Find first space or control terminator
01      LDRB    R3,[R14]
        CMP     R3,#&20
        ADDHI   R14,R14,#1
        BHI     %BT01

02      LDRB    R3,[R14]                    ; Go back to last '.'
        CMP     R14,R2
        CMPNE   R3,#"."
        SUBNE   R14,R14,#1
        BNE     %BT02

        CMP     R3,#"."                     ; Skip '.'
        ADDEQ   R14,R14,#1

        LDRB    R3, [R14]
        CMP     R3, #&20
        MOVLS   R14, R2                     ; if we'd get a null string, then jump back to start

        MOV     R4,#ms_data+8
03      LDRB    R3,[R14],#1
        CMP     R3,#&20
        BLS     %FT04
        STRB    R3,[R1,R4]
        ADD     R4,R4,#1
        CMP     R4,#27+ms_data
        BLO     %BT03

04      MOV     R3,#0                      ; Store zero terminator.
        STRB    R3,[R1,R4]

        MOV     R2,#0
        STR     R2,[R1,#ms_yourref]
        LDR     R14,=Message_Iconize
        STR     R14,[R1,#ms_action]
        BL      int_sendmessage_fromwimp
        ADD     sp,sp,#(ms_data+8+20)     ; correct stack

        EXIT

wicon_scup
        TST     R2,#button_right
        BNE     wicon_scdown2
wicon_scup2
        MOV     R14,#32
        LDR     R1,[handle,#w_wey1]             ; can't scroll up past top
        B       scrolly

wicon_scdown
        TST     R2,#button_right
        BNE     wicon_scup2
wicon_scdown2
        MOV     R14,#-32
        LDR     R1,[handle,#w_way0]
        LDR     R2,[handle,#w_way1]
        SUB     R1,R2,R1                        ; height of window
        LDR     R2,[handle,#w_wey0]
        ADD     R1,R2,R1                        ; min y-scroll coord (-ve)

scrolly
        LDR     R0,[handle,#w_flags]
        TST     R0,#wf_userscroll
        MOVNE   R1,#0                           ; x-scroll
        MOVNE   R2,R14,ASR #5                   ; scale down to +-1
        BNE     userscroll
;
        LDR     R0,[handle,#w_scy]
        TEQ     R0,R1
        BEQ     trykeys
;
        Push    R14
        BL      int_get_window_state
        LDR     R14,[handle,#w_bhandle]         ; open at same posn in stack
        STR     R14,[userblk,#u_bhandle]
        LDR     R0,[userblk,#u_scy]
        Pull    R14
        ADD     R0,R0,R14
        STR     R0,[userblk,#u_scy]
;
        B       Exit_OpenWindow

wicon_scleft
        TST     R2,#button_right
        BNE     wicon_scright2
wicon_scleft2
        MOV     R14,#-32
        LDR     R1,[handle,#w_wex0]             ; can't scroll left past wex0
        B       scrollx

wicon_scright
        TST     R2,#button_right
        BNE     wicon_scleft2
wicon_scright2
        MOV     R14,#32
        LDR     R1,[handle,#w_wax0]
        LDR     R2,[handle,#w_wax1]
        SUB     R1,R2,R1                        ; width of window
        LDR     R2,[handle,#w_wex1]
        SUB     R1,R2,R1                        ; max x-scroll coord

scrollx
        LDR     R0,[handle,#w_flags]
        TST     R0,#wf_userscroll
        MOVNE   R1,R14,ASR #5                   ; scale down to +-1
        MOVNE   R2,#0                           ; y-scroll
        BNE     userscroll
;
        LDR     R0,[handle,#w_scx]
        TEQ     R0,R1
        BEQ     trykeys
;
        Push    R14
        BL      int_get_window_state
        LDR     R14,[handle,#w_bhandle]         ; open at same posn in stack
        STR     R14,[userblk,#u_bhandle]
        LDR     R0,[userblk,#u_scx]
        Pull    R14
        ADD     R0,R0,R14
        STR     R0,[userblk,#u_scx]

;
; Get window opened
; Entry:  handle --> window definition
;         userblk --> data (handle,x0,y0,x1,y1,scx,scy,bhandle)
;

Exit_OpenWindow
        BL      calc_w_status                   ; ensure bhandle is correct
        ADD     R14,handle,#w_wax0
        LDMIA   R14!,{cx0,cy0,cx1,cy1}
        LDMIA   userblk,{R0,x0,y0,x1,y1}

        Push    R14
        LDR     R14,dx_1
        BIC     cx0,cx0,R14
        BIC     cx1,cx1,R14
        BIC     x0,x0,R14
        BIC     x1,x1,R14

        LDR     R14,dy_1
        BIC     cy1,cy1,R14
        BIC     cy0,cy0,R14
        BIC     y0,y0,R14
        BIC     y1,y1,R14
        Pull    R14

        TEQ     cx0,x0
        TEQEQ   cy0,y0
        TEQEQ   cx1,x1
        TEQEQ   cy1,y1
        LDMEQIA R14,{cx0,cy0,cx1}               ; scx,scy,bhandle
        ADDEQ   R14,userblk,#5*4                ; skip handle,x0,y0,x1,y1
        LDMEQIA R14,{x0,y0,x1}

        Push R14
        LDR     R14,dx_1
        BIC     cx0,cx0,R14
        BIC     x0,x0,R14

        LDR     R14,dy_1
        BIC     cy0,cy0,R14
        BIC     y0,y0,R14
        Pull    R14

        TEQEQ   cx0,x0
        TEQEQ   cy0,y0
        TEQEQ   cx1,x1
      [ togglebits
        LDR     R14, [handle, #w_flags]         ; don't mask out requests during a toggle operation!
        TSTEQ   R14, #ws_toggling
      ]
        BEQ     trykeys                         ; go to next bit of polling
;
        LDR     R14,[handle,#w_taskhandle]
        CMP     R14,#0                          ; <= 0 ==> system window
   ;    Task    R14,GT,"OpenWindow"     ; force errors into the open!
        MOVGT   R0,#Open_Window_Request
        BGT     ExitPoll
;
        BL      int_open_window         ; menus are opened automatically
        B       repollwimp

userscrollpage
        MOV     R2,R0                   ; R2 = cx0, so it's in R0 instead

userscroll
        Push    "R1,R2"
        BL      int_get_window_state
        LDR     R14,[userblk,#u_handle]         ; open at same posn in stack
        STR     R14,[userblk,#u_bhandle]
        Pull    "R1,R2"
        ADD     R14,userblk,#u_scroll
        STMIA   R14,{R1,R2}
;
        LDR     R14,[handle,#w_taskhandle]
        Task    R14,,"ScrollRequest"
        MOV     R0,#Scroll_Request
        B       ExitPoll

        LTORG


wicon_scvert
        BL      getvscrollcoords
        MOV     R1,#0                   ; x-scroll = 0
        LDR     R14,mouseypos
        CMP     R14,cy0
        MOVLT   R0,#-2                  ; R2 = cx0, so use R0 instead
        BLT     pagevert
        CMP     R14,cy1
        MOVGT   R0,#2
        BGT     pagevert
;
        LDR     R14,[handle,#w_flags]
        TST     R14,#wf_icon7           ; if there is a horizontal scroll bar,
        LDRNE   R14,mousebuttons        ; and the right-hand button is used
        TSTNE   R14,#button_right       ; allow 2-way scrolling
        MOVEQ   R0,#drag_vscroll
        MOVNE   R0,#drag_scrollboth
        BL      int_drag_box
        B       trykeys

wicon_schoriz
        BL      gethscrollcoords
        MOV     R0,#0                   ; y-scroll = 0
        LDR     R14,mousexpos           ; R2 = cx0, so use R0 instead
        CMP     R14,cx0
        MOVLT   R1,#-2
        BLT     pagehoriz
        CMP     R14,cx1
        MOVGT   R1,#2
        BGT     pagehoriz
;
        LDR     R14,[handle,#w_flags]
        TST     R14,#wf_icon5           ; if there is a vertical scroll bar,
        LDRNE   R14,mousebuttons        ; and the right-hand button is used
        TSTNE   R14,#button_right       ; allow 2-way scrolling
        MOVEQ   R0,#drag_hscroll
        MOVNE   R0,#drag_scrollboth
        BL      int_drag_box
        B       trykeys

pagevert
        LDR     R14,mousebuttons        ; reverse direction if r-button used
        TST     R14,#button_right
        RSBNE   R0,R0,#0
;
        LDR     R14,[handle,#w_flags]
        TST     R14,#wf_userscroll
        BNE     userscrollpage
;
        Rel     R1,handle
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{cx0,cy0,cx1,cy1,x0,y0,x1}
        SUB     R14,cy1,cy0
        TEQ     R0,#0                   ; y scroll direction
        ADDPL   y0,y0,R14
        SUBMI   y0,y0,R14
        ASSERT  (u_handle=0)
        STMIA   userblk,{R1,cx0,cy0,cx1,cy1,x0,y0,x1}
        STR     R1,[userblk,#u_bhandle]         ; same posn in stack
;
        B       Exit_OpenWindow

pagehoriz
        LDR     R14,mousebuttons        ; reverse direction if r-button used
        TST     R14,#button_right
        RSBNE   R1,R1,#0
;
        LDR     R14,[handle,#w_flags]
        TST     R14,#wf_userscroll
        BNE     userscrollpage
;
        Rel     R0,handle
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{cx0,cy0,cx1,cy1,x0,y0,x1}
        SUB     R14,cx1,cx0
        TEQ     R1,#0                   ; x scroll direction
        ADDPL   x0,x0,R14
        SUBMI   x0,x0,R14
        ASSERT  (u_handle=0)
        STMIA   userblk,{R0,cx0,cy0,cx1,cy1,x0,y0,x1}
        STR     R0,[userblk,#u_bhandle]         ; same posn in stack
;
        B       Exit_OpenWindow


;;----------------------------------------------------------------------------
;; Get_Pointer_Info - find out where the mouse pointer is
;;----------------------------------------------------------------------------

SWIWimp_GetPointerInfo
        MyEntry "GetPointerInfo"
;
        LDR     R0,mousexpos                    ; just read old values
        LDR     R1,mouseypos
        LDR     R2,mousebuttons
        MOV     R5,#wf2_shadedhelp              ; match shaded icons if this bit is set in window flags 2 byte
        BL      int_get_pointer_info

        CMP     R4, #nullptr2
        BNE     %FT01
	LDR     R14,singletaskhandle            ; if single-tasking,
	CMP     R14,#nullptr
	MOVNE   R4,#nullptr                     ; don't confuse punter!
        BLEQ    setwimpicon                     ; if new task, work out which icon it is
01
        LDR     R14,backwindowhandle
        TEQ     R3,R14
        LDRNE   R14,backwindow                  ; window -1 for either of these
        TEQNE   R3,R14
        MOVEQ   R3,#nullptr
;
        LDR     R14,iconbarhandle
        CMP     R14,#nullptr
        BEQ     %FT01
        TEQ     R3,R14
        MOVEQ   R3,#nullptr2                    ; return -2 for iconbar
01
   ;    LDR     R14,oldbuttons                  ; WAS last parameter
        STMIA   userblk,{R0,R1,R2,R3,R4}
        B       ExitWimp


;-----------------------------------------------------------------------------
; getmouseposn - takes note of mouseflags
;-----------------------------------------------------------------------------

getmouseposn
        Push    "LR"
;
        LDR     R14,mouseflags
        TST     R14,#mf_oldcoords
        BIC     R14,R14,#mf_oldcoords   ; test and reset bit
        STR     R14,mouseflags
        BEQ     newmouseposn
;
        LDR     R0,mousexpos
        LDR     R1,mouseypos
        LDR     R2,mousebuttons
        Pull    "PC"
;
newmouseposn
        LDR     R14,mousebuttons
        STR     R14,oldbuttons          ; copy only if want new buttons

        Push    "R3"

        MOV     R3,#0                   ; see if R3 is set up!

      [ mousecache

; if recacheposn is zero then no need to read the mouse values as they
; will not have been updated, instead read from our workspace and
; wait for the value to go non-zero.

        ASSERT  mouseypos = mousexpos +4
        ASSERT  mousebuttons = mouseypos +4
        ASSERT  mousetime = mousebuttons +4

        LDRB    R0,recacheposn
        TEQ     R0,#0                   ; do we have a cached posn for the mouse?
        ADREQ   R0,mousexpos            ; if they are then pick them up from our workspace
        LDMEQIA R0,{R0,R1,R2,R3}
        BEQ     %FT10

        STRB    R3,recacheposn
      ]

        SWI     XOS_Mouse
        LDR     R14,dx_1                ; R14 <- dx-1
        BIC     R0,R0,R14
        LDR     R14,dy_1                ; R14 <- dy-1
        BIC     R1,R1,R14

      [ mousecache
        ADR     R14,mousexpos
        STMIA   R14,{R0,R1,R2,R3}
      |
        STR     R0,mousexpos
        STR     R1,mouseypos
        STR     R2,mousebuttons
      ]
      [ NCErrorBox
        Push    "R0-R6"
        ASSERT  ptrsuspendflag = ptrsuspenddata + 12
        ADRL    R14, ptrsuspenddata
        LDMIA   R14, {R3-R6}

        TEQ     R6, #1                  ; waiting for keyboard-generated move?
        MOVEQ   R3, #2
        STMEQIA R14, {R0-R3}            ; store mouse state and new flag value

        TEQ     R6, #2                  ; waiting for mouse-generated move?
        BNE     %FT06
        TEQ     R0, R3
        TEQEQ   R1, R4
;        TEQEQ   R2, R5
        BEQ     %FT06                   ; no change

        ADRL    R14, ptrsuspendflag
        MOV     R0, #0
        STR     R0, [R14]               ; store new flag value
        MOV     R0, #106
        MOV     R1, #1
        SWI     XOS_Byte                ; turn on pointer
        TEQ     R1, #0
        SWINE   XOS_Byte                ; just in case it's been turned on by someone else already!
06
        Pull    "R0-R6"
      ]
10
        TEQ     R3,#0                   ; was it set up?
        BEQ     bodgetime
        STR     R3,timeblk
        Pull    "R3,PC"

bodgetime
        Push    "R0-R2"
        MOV     R0,#1
        ADR     R1,timeblk
        SWI     XOS_Word                ; make a note of the time
        Pull    "R0-R3,PC"


;-----------------------------------------------------------------------------
; int_get_pointer_info - called by Poll_Wimp
; look for a match with a window / user icon
; Entry :  R0,R1 = coords of mouse pointer
;          R5 = bits in windowflags2 that can be set to indicate shaded icons should b included
; Exit :   R3 = window handle (relative)
;          R4 = button index (or -1 if none)
;          handle --> window definition (if any)
;          If clicked in work area, [mousexyrel] = relative coordinates
;-----------------------------------------------------------------------------

int_get_pointer_info

        ADRL    R4,activewinds+lh_forwards-ll_forwards
      [ ChildWindows
        MOV     R3,#0                   ; ignore wf_inborder bit for top-level windows
      ]

; In:   R4 -> list head ( activewinds or [handle,#w_children] )
;       R3 = wf_inborder if we're to search only windows which have this bit
;       R3 = 0 if we're to search all windows in the list

int_get_pointer_info_R4                 ; for ChildWindows

      [ ChildWindows
        Push    "userblk,LR"

        MOV     userblk,R3              ; userblk = wf_inborder or 0
      |
        Push    "LR"
      ]

findwlp
        LDR     R4,[R4,#ll_forwards]
        LDR     R14,[R4,#ll_forwards]
        CMP     R14,#nullptr
        MOVEQ   R3,#nullptr
        MOVEQ   R4,#nullptr
      [ ChildWindows
        Pull    "userblk,PC",EQ
      |
        Pull    "PC",EQ
      ]
        SUB     handle,R4,#w_active_link
        Rel     R3,handle

      [ ChildWindows
        LDR     R14,[handle,#w_flags]
        AND     R14,R14,userblk
        TEQ     R14,userblk                     ; ignore window if userblk = wf_inborder and bit not
        BNE     findwlp
      ]

        ADD     R14,handle,#w_x0
        LDMIA   R14,{x0,y0,x1,y1}

        CMP     R0,x0
        CMPGE   R1,y0
        BLT     findwlp
        CMP     x1,R0
        CMPGT   y1,R1
        BLE     findwlp

;        Debug   child,"Click within outer box of",handle

; decide whether the click is inside or outside the work area

        Push    "R0-R3,R5-R9"
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{cx0,cy0,cx1,cy1,x0,y0}
;
        Push    "cx0,cy0,cx1,cy1"
        LDR     R14,dx
        SUB     cx0,cx0,R14                     ; include border!
        LDR     R14,dy
        SUB     cy0,cy0,R14
        CMP     R0,cx0                          ; check inside work area
        CMPGE   R1,cy0
        CMPGE   cx1,R0
        CMPGE   cy1,R1
        Pull    "cx0,cy0,cx1,cy1"
      [ :LNOT: ChildWindows
        BLT     noficon2
      ]

; right - a click inside the work area
; first check to see if it's inside any of the window's children

      [ ChildWindows
        Push    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk"
        MOVLT   R3,#wf_inborder                 ; click was in border area (so only scan children that overlap the border)
        MOVGE   R3,#0                           ; click was in work area (scan all children)
        MOV     userblk,R3
        ADD     R4,handle,#w_children + lh_forwards - ll_forwards
        LDR     R5,[SP,#(10+4)*4]               ; get back original R5
        BL      int_get_pointer_info_R4         ; scan child window stack for a hit
        CMP     R3,#nullptr
        ADDNE   SP,SP,#10*4
        STRNE   R3,[SP,#3*4]
        BNE     exitp4                          ; click found in one of the children
        TEQ     userblk,#0
        Pull    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk"
        BNE     noficon2                        ; click was in border area
      ]
;
; now scan the icon list for a hit (starting at the frontmost, ie. the highest-numbered)
;
        SUB     x1,cx0,x0                       ; coords of top-left
        SUB     y1,cy1,y0
        SUB     R0,R0,x1                        ; make mouse coords relative
        SUB     R1,R1,y1
;
        LDR     R4,[handle,#w_nicons]           ; R4 = no of icons
        LDR     R2,[handle,#w_icons]            ; R2 --> start of icons
        ADD     R2,R2,R4,ASL #i_shift           ; R3 --> end of list
        LDR     R5,[SP,#4*4]                    ; R5 on entry
ficlp
        SUBS    R4,R4,#1
        BMI     noficon                         ; no more left
        SUB     R2,R2,#i_size                   ; point to current icon
;
        LDR     R14,[R2,#i_flags]
        TST     R14,#is_deleted                 ; always ignore deleted icons
        BNE     ficlp
        TST     R14,#is_shaded                  ; only ignore shaded icons
        LDRNE   R14,[handle,#w_taskhandle]      ; if they're not in a menu
        CMPNE   R14,#nullptr                    ; -1 => menu
        BEQ     %FT01
        LDRB    R14,[handle,#w_flags2]
        TST     R14,R5                          ; do we want to match shaded icons in windows?
        BEQ     ficlp
01
        ASSERT  (i_bbx0=0)                      ; check LDMIA is OK
        ASSERT  cx1 = r4
        Push    "cx1,cy1"
        LDMIA   R2,{cx1,cy1,x0,y0}
        CMP     R0,cx1                          ; see if pointer is inside
        CMPGE   R1,cy1
        Pull    "cx1,cy1"
        BLT     ficlp
        CMP     R0,x0
        CMPLT   R1,y0
        BLT     endficon                ; got it!!!
        B       ficlp
;
noficon2
        MOV     R4,#nullptr2            ; if in border, set icon = -2
        B       endficon
noficon
        MOV     R4,#nullptr
endficon
        STR     R0,mousexrel            ; may be needed later
        STR     R1,mouseyrel
exitp4                                  ; for ChildWindows
      [ ChildWindows
        Pull    "R0-R3,R5-R9,userblk,PC" ; restore mouse coords etc.
      |
        Pull    "R0-R3,R5-R9,PC"        ; restore mouse coords etc.
      ]

        END
@


4.32
log
@Make use of power saving features when sat waiting for user input
Detail:
  s/Wimp03 - Move two key bits of power-saving logic out of repollwimp and into a new subroutine (powersave_tick)
  s/Wimp01, s/Wimp07 - Call powersave_tick when displaying an error box or "Press SPACE or click mouse to continue", so that CPU will drop speed and enter WFI state instead of running at full tilt.
Admin:
  Tested on Pandaboard
  Fixes issue reported on forums with CPUs getting hot for no good reason:
  https://www.riscosopen.org/forum/forums/4/topics/3749


Version 5.51. Tagged as 'Wimp-5_51'
@
text
@d446 1
@


4.31
log
@Fix for incorrect names on pinned windows
The post increment of R14 when looking for a control/space terminator meant that the search for a leafname started one too far along.
So in the situation where memory contained something like
  <window_title><null><dot><garbage>
the code would pick up the dot and try to use <garbage> as a leafname.
Submission from Fred Graute.
Fix for ticket #244.

Version 5.42. Tagged as 'Wimp-5_42'
@
text
@d517 1
a517 9
        LDR     R14,IdlePerSec          ; update the idle information for the portable modules
        ADD     R14,R14,#1
        STR     R14,IdlePerSec
 [ Stork
        LDR     R14, WimpPortableFlags
        TST     R14, #PowerSave                 ; if power saving
        TSTNE   R14, #PortableFeature_Idle      ; and Portable_Idle works
        SWINE   XPortable_Idle                  ; then go dormant until next interrupt or centi-second tick
 ]
d800 13
@


4.30
log
@Slacken pointer checks
The pointer comparison checking required when running in a system with > 64M memory was tightened up from Wimp-4_75 to Wimp-4_76, but to allow the module to target pre RISC OS 5 systems an option to relax those checks is required.
Each check has been revisited and where appropriate demarked with a "AcceptLoosePointer" macro, which just remaps the pointer into the stricter form and carries on. In the strict checking case, the macro reduces to nothing.

Detail:
Add AcceptLoosePointers switch.
Retire singular use of StrongARM switch (calling XOS_SynchroniseCodeAreas is harmless pre StrongARM anyway).
Rename Ursula_RPC options to RO400.
Put duplicate documentation in the attic.
Allow -2 or -1 as the iconbar handle in Wimp_ResizeIcon (ticket #203).
Tighten up the list terminator check in the DebugMemory switch of Memory.s

Tested on RISC OS 3.10 (emulated), 3.50, 3.60, 3.70, 4.02.

Version 5.24. Tagged as 'Wimp-5_24'
@
text
@d3786 1
a3786 2
      [ true
00      LDRB    R3, [R2]  ; always skip leading spaces
d3790 3
a3792 3
      ]
        MOV     R14,R2                      ; Find first space.
01      LDRB    R3,[R14],#1
d3794 1
d3805 1
a3805 1
      [ true
d3808 1
a3808 2
        MOVLS   R14, R2   ; if we'd get a null string, then jump back to start
      ]
@


4.29
log
@Fixes for pre AMBControl versions
Wimp03.s: check that pollword was in application space was corrupting R3 leading to an address exception (!) on pre Medusa targets
Wimp08.s: compare had erroneously been change to equality check, leading to screwy memory allocation and much instability on 3.50 and 3.60 especially when applications quit

Version 5.23. Not tagged
@
text
@d1406 1
d2713 1
@


4.28
log
@Update Wimp to use new VFPSupport_ChangeContext_AppSpace flag
Detail:
  s/Wimp03, s/Wimp07 - When saving the VFP context the Wimp now uses lazy context switching where possible, via a combination of the Lazy & AppSpace flags
Admin:
  Tested on rev A2 BB-xM
  Requires VFPSupport 0.02


Version 5.11. Tagged as 'Wimp-5_11'
@
text
@d378 1
a378 1
        RSBHSS  R3,R3,#&1000000		; APPSPACE
@


4.27
log
@Make the Wimp automatically switch VFP contexts
Detail:
  s/Wimp, s/Wimp01, s/Wimp02, s/Wimp03, s/Wimp07 - The Wimp now uses the VFPSupport module to switch VFP contexts when performing task switches.
  Each task begins with the null context active (i.e. no VFP/NEON access). When paging out a task the ID of the active context is saved in the Wimp's per-task workspace. This context is then restored when the task is about to be resumed.
  Context save/restore is performed while the right task's memory is paged in, so it's safe to use with contexts located in application space.
Admin:
  Tested with Iyonix & Beagle ROM builds.


Version 5.09. Tagged as 'Wimp-5_09'
@
text
@d440 1
a440 1
; save VFP context. Can't save lazily since it might be in application space.
d443 1
a443 1
        MOV     R1,#0
@


4.26
log
@Make Wimp NoUnaligned-safe
Detail:
  The "pointer leaving window" code now checks that ptrtask != nullptr before attempting to use it as an offset to the workspace pointer. This is required when alignment exceptions are enabled because nullptr is -1.
Admin:
  Tested on rev C2 beagleboard


Version 5.07. Tagged as 'Wimp-5_07'
@
text
@d440 9
@


4.25
log
@	Added a CLRV to ensure V starts clear when using a Wimp_Pollword
Detail:
	usergroup had identified a Hi bit set (32bit) issue with
	PollWords that existed in a hi bit set DA. There is evidence of
	previous work to avoid this, but a hi bit set pollword address
	could leave a V set condition floating around. Added CLRV to ensure it
	was cleared.
Admin:  tested in ROM at castle.. passes test from user that previously
	failed.  Castle added IP


Version 4.95. Tagged as 'Wimp-4_95'
@
text
@d1633 3
a1635 2
        LDR     R14,[wsptr,R9]          ; Check if old task is dead
        TST     R14,#task_unused        ; If so, just return 'entering window'
@


4.24
log
@
  Ensure thet usrblk is valid before checking fast pollwords

Details:
  s.Wimp03 : lines 502 to 505 moved 4 lines later
Admin:
  Tested in rom at Castle. fix believed benign at Tematic


Version 4.93. Tagged as 'Wimp-4_93'
@
text
@d382 1
@


4.23
log
@Icon flag bit 10 works again (bug introduced in 32-bitting).
Variants pre-Ursula now build again.

Version 4.91. Tagged as 'Wimp-4_91'
@
text
@d516 4
a523 4
        LDR     R14,taskhandle          ; get userblk back (may be corrupted)
        LDR     R14,[wsptr,R14]
        LDR     userblk,[R14,#task_registers+4*1]
;
@


4.22
log
@Added a new window flag (extra flags byte bit 4) to indicate that
Wimp_GetPointerInfo should include shaded icons, in particular so that they
can now have interactive help. Included some information on RISC OS Select
APIs so that we can avoid clashes.

Version 4.89. Tagged as 'Wimp-4_89'
@
text
@d2995 1
a2995 1
        LDR     R2,[R13,#8]             ; get button state again!
d3011 1
a3011 1
        STRVS   R0,[R13]
@


4.21
log
@  Bugfixing, Sprites11 support and stretchy command windows.
Detail:
  * Bugfix: the contents of the pollword returned in the poll block by
    a PollWordNonZero event, where the pollword was flagged as high
    priority, was rotated by 8 bits due to a internal top-bit-set
    workaround. This no longer happens. (This was causing OmniClient never
    to complete initialisation on my machine.)
  * Extended the alternate resolution icon scheme for RAM/ROM sprites and
    toolsprites to be multi-pass, enabling the use of extra sprite sets for
    weird modes (most notably EX0 EY0 ones). After '23' or '0' suffixes
    (the latter still only applies to toolsprites), the suffix for the
    equivalent polychromatic resolution is tried. After rectangular
    suffixes, the next larger squarer suffix is tried. After '11', '22' is
    tried. Failing all of these, a match is attempted with no suffix.
  * The command window is now scaled and centred to match the current screen
    mode - up to a maximum size of 1280 x 1024 OS units.
  * Fixed the *WimpVisualFlags help strings (again).
  * Fixed 'task2' debugging to know about the structure of the SVC stack on
    32-bit machines.
  * Added support for generation of GPA files.
Admin:
  Tested on Tungsten.

Version 4.84. Tagged as 'Wimp-4_84'
@
text
@d1314 1
d4076 1
d4208 1
d4298 1
d4319 1
d4331 5
a4335 2
        BNE     ficlp
;
d4337 2
a4338 1
        Push    "R2,R3,R4"
d4342 1
a4342 1
        Pull    "R2,R3,R4"              ; strategic move!
@


4.20
log
@  Bugfix and feature.
Detail:
  * Validation string commands to set the pointer shape were incorrectly
    interpreted if they contained commas to set the active point.
  * Holding down shift when clicking on the back icon will only move the
    window by one position within the window stack.
Admin:
  Tested on Tungsten.

Version 4.83. Tagged as 'Wimp-4_83'
@
text
@d2923 2
a2924 1
        LDRNE   R4,[R3]                 ; Read pollword (bottom bit is irrelevant to zero-ness!)
a2931 1
        BIC     R3,R3,#1
@


4.19
log
@  Bugfixes.
Detail:
  * Message list pointers passed into Wimp_Initialises that didn't follow
    Wimp_StartTask used to be corrupted
  * Stack imbalance in ExitPoll if SWI Portable_Speed didn't preserve flags
  * 32-bit mode test speedups
  * Builds without RO4 option set
Admin:
  Tested on Tungsten and Risc PC.

Version 4.79. Tagged as 'Wimp-4_79'
@
text
@d1410 2
a1411 2
        STRHIB  r14,[r2],#1
        BHI     %BT88
d3424 7
a3430 1
      [ RO4
d3433 1
d3435 1
a3435 1
        ADD     R14,R14,#nullptr2
d3441 32
@


4.18
log
@  Merged in RISC OS 4.02 changes (including ROM patches). Also som bugfixes.
Detail:
  RISC OS 4 changes:
  * Font blending for desktop font (based on NC code, but now configurable)
  * 3-D window/menu/iconbar borders
  * Textured menu backgrounds
  * Loss of rubout box in unfilled text+sprite icons
  * *WimpVisualFlags controls various aspects of cosmetic changes above
  * Iconise button "slot" glyph slightly shorter (but only adopted in the RO400
    Resource directory)
  * Command window has front-window flag set
  * Byte at +39 of the window block has gained two new flag bits:
      bit 2 set => this window must never be given a 3D border
      bit 3 set => this window must always be given a 3D border
      (note that ResEd erroneously created windows with both bits set,
      this case is treated as though both bits were clear)
  * Another two colour specifiers on the end of C validation string command
    for icons controls the foreground and background colours to be used when
    the icon is selected
  * Pointer shape is correctly reprogrammed by the creation of icon
    underneath it
  * Full stops in writable icons are treated the same as spaces from the
    point of view of cursor navigation
  * spritesize routine returns a size of 0 if the sprite didn't exist
    (probably fixes some rendering problems)
  * Adjust-click on back icon brings window to front
  My changes:
  * DeleteRight turned on
  * Icon bar title background is set to default in all resource sets (avoids
    translation table recalc)
  * Error box title now cream across all resource sets
  * RISC OS 4 changes made 32-bit compatible / high addresses safe
  * Undocumented FullIconClipping option disabled
  * Command help made consistent for internationalised and non-
    internationalised builds
  * WimpVisualFlags defaults made sensible
  * Menu side width affected by ThreeD option at *run* time not assemble time
  * Right-clicking on menus with writable items no longer data aborts
  * Auto-opened menus are now at RHS of current icon (matches RISC OS 3.1)
  * Colour menus were knackered unless menu tiling was enabled
  * Fixed a bug whereby adding messages to a task that wanted all messages
    actually caused it to lose all other messages. The RISC OS 4 fix for
    this didn't work
  * Fixed bug introduced in version 4.76: tasks that wanted no messages got
    all of them
  * Autoscrolling is updated every 8 cs rather than every 12 cs
  * Added menu texture to pre-RISC OS 4 sprites files
Admin:
  Tested on Tungsten.

Version 4.78. Tagged as 'Wimp-4_78'
@
text
@d352 1
a352 1
; set up R3 -> poll word, with top bit set => urgent
@


4.17
log
@  Memory-related stuff.
Detail:
  * Default UpCall handler is installed when an application is paged out,
    so there is no danger of it being called by naughty people issuing
    UpCalls in the background.
  * AMBControl builds now sit on Service_MemoryMoved so that they can issue
    Message_SlotSize when the kernel has resized the application slot
    independently (eg because the memory was needed to grow a dynamic area,
    and nobody objected via Service_Memory or UpCall_MovingMemory).
  * Medusa-onwards builds no longer request Service_ValidateAddress, because
    we're not managing the free pool any more, and the code that was here
    only called an ineffectual SWI!
  * SafeChangeDynamic wasn't setting the CAO high enough to be free of big
    application slots; now it points it at itself.
  * The free pool wasn't being shrunk/grown enough on initfirsttask /
    closelast. It still can't do by more than 1GB without stiffing - bug in
    kernel?
  * Bugs in top-bit-safe changes fixed: dragbox resizing was broken, Escape
    state wasn't being restored for new tasks.
Admin:
  Tested on high-ROM/stack, 48M-appslot Tungsten.

Version 4.77. Tagged as 'Wimp-4_77'
@
text
@d3420 1
a3420 1
        B       openwindow
d3424 6
d3431 1
a3432 1
openwindow
@


4.16
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@d108 4
@


4.15
log
@  Commit of my Wimp changes that have trickled in over the last four months.
Detail:
  * The pointer passed to Wimp_CommandWindow can now be top-bit-set.
  * Bugfix to Wimp_CommandWindow: if the current task was uninitialised,
    or initialised as a non-multitasking task, then although entering the
    CommandWindow would restore escape condition generation to the way it
    was before entering the desktop, exiting the CommandWindow did not
    reset escape condition generation to the default desktop state (which is
    for escape condition generation to be disabled).
  * Escape condition generation is disabled for the duration of SWI
    Wimp_ReportError (instead of setting the default escape key for the
    duration). The previous state is restored on exit.
  * Added a minimal environment for the service call
    Service_ErrorButtonPressed, so that claimants can call OS_Exit without
    leaving the global Wimp error box in an undefined state.
  * In the Wimp_Poll loop, if there are no events to deliver to any tasks
    (not even null events), then rather than sitting in a SVC mode loop,
    the Wimp now triggers transient callbacks. This is particularly
    important in order not to halt all activity in the Internet stack.
    The option LeaveOS can be set to make the Wimp use the as-yet
    unimplemented SWI OS_LeaveOS for this purpose; this is currently unset
    for all builds.
  * By (persistent) request, reinstated the old iconbar popping code,
    though it is currently a build switch that is turned off for all builds.
Admin:
  Tested on a Risc PC.

Version 4.69. Tagged as 'Wimp-4_69'
@
text
@d201 1
a201 1
        BGE     err_badR0               ; if not then return an error
d353 3
a355 3
        MOVLT   R3,#0                   ; R3=0 => no poll word
        BLLT    killfpblock             ; get rid of this!
        BLT     %FT01
a364 2
        TSTNE   R0,#flag_pollfast       ; top bit set => poll quickly
        ORRNE   R3,R3,#&80000000
d366 1
a366 2
        BICS    R14,R3,#&80000000       ; check that address is
        TST     R14,#3                  ; word-aligned
d368 1
a368 1
        CMP     R14,#&8000              ; and not in application space
d371 2
a372 6
        BLT     %FT05
        Push    "R0"
        LDR     R0,orig_applicationspacesize
        SUBS    R14,R0,R14
        Pull    "R0"
05
d374 1
a374 1
        RSBGES  R14,R14,#&1000000	; APPSPACE
d376 1
d378 3
a380 1
        BGE     err_badR3
d476 2
a477 2
        CMP     R14,#0                  ; old Wimp didn't set up escape!
        BGT     %FT02
d512 1
a512 1
        MOV     R0,#&80000000
d521 2
a522 2
        CMP     R2,#0
        BGT     returnmessage
d529 2
a530 2
        CMP     R2, #0
        BGT     returnmessage
d1048 1
a1048 1
        BGE     notdragging             ; only system drags are elegible
d1094 3
a1096 3
        STMGTIA userblk,{cx0,cy0,cx1,cy1}       ; final box coords
        MOVGT   R0,#User_Dragbox
        BGT     ExitPoll                        ; return User_DragBox
d1168 2
a1169 2
	CMP	R14,#0
	Pull	"R0,PC",GT		; old-style tasks don't have an icon bar!
d1201 1
a1201 1
	BLT	%FT11
d1203 1
a1203 1
	Pull	"R0,PC",LE
d1245 2
a1246 2
	CMP	handle,#0
	Pull	"R0,PC",LE
d1350 4
a1353 5
        CMP     R3,#0
        BLE     %FT90
        CMP     R4,#0
        BLT     %FT90
        TST     R3,#1
d1355 2
d1391 2
a1392 2
        CMP     r3,#0
        BLE     %FT90
d1406 2
a1407 2
        STRGTB  r14,[r2],#1
        BGT     %BT88
d1486 2
a1487 2
        CMP     R14,#0
        BLE     %FT01                   ; no iconbar
d1517 2
a1518 2
        CMP     R14,#0
        BLE     %FT01                   ; no iconbar
d2070 2
a2071 2
        CMP     R14,#0                  ; don't do this if no iconbar!
        BLE     notiniconbar
d2088 2
a2090 2
        CMP     handle,#0
        BLE     repollwimp              ; window has been deleted!!!
d2104 2
a2105 2
        CMP     R3,#0                   ; is it a real window?
        BLE     %FT10                   ; if not then icon
d2108 1
a2108 1
        BLT     %FT10                   ; if its the background then ignore it
d2143 1
a2143 1
	BLE	%F1
d2186 2
a2187 2
        CMP     R14,#0
        BLE     ExitPoll                ; return directly for efficiency
d2204 2
a2205 2
        CMP     handle, #0
        BLE     %FT11                   ; still read character (may be hot!)
d2213 1
a2213 1
        LDRLT   R14, menutaskhandle
d2230 1
a2230 1
        BLT     %BT01
d2235 3
a2237 3
        CMP     R14, #0
        BLLE    topmost_window
        STRLE   R0, hotkeyptr           ; initialise hotkey system, unless we're single-tasking
d2240 2
a2241 2
        CMP     R0, #0                  ; is there a caret?
        BGT     %FT02
d2251 1
a2251 1
        LDRLT   R14, menutaskhandle
d2296 1
a2296 1
        BGE     %FT02                   ; break from loop if full
d2327 2
a2328 2
        CMP     handle, #0
        BLE     %FT01
d2331 1
a2331 1
        LDRLT   R14, menutaskhandle
d2393 2
a2394 2
        CMP     R0, #0
        BLE     tryhotkeys              ; no input focus
d2444 1
a2444 1
        BLT     %BT02
d2448 3
a2450 3
        CMP     R14, #0
        BLLE    topmost_window          ; if we're multitasking, get top window handle
        STRLE   R0, hotkeyptr           ; and store it as the first hotkey window
d2504 1
a2504 1
        BLT     %BT01
d2555 2
a2556 2
        CMP     handle,#0
        BLE     %FT01                   ; still read character (may be hot!)
d2565 1
a2565 1
        LDRLT   R14,menutaskhandle
d2589 3
a2591 3
        CMP     R14,#0
        LDRGT   R14,[handle,#w_taskhandle]
        LDRLT   R14,menutaskhandle
d2620 2
a2621 2
        CMP     R0,#0
        BLE     tryhotkeys              ; no input focus
d2628 3
a2630 3
        CMP     R14,#0
        BLLE    topmost_window
        STRLE   R0,hotkeyptr
d2638 1
a2638 1
        CMP     R14,#0
d2642 3
a2644 3
        BLLE    topmost_window
        STRLE   R0,hotkeyptr
        BLLE    int_processkey          ; R6 = key code
d2696 2
a2697 2
        CMP     r1, #0                  ; check for sub-menu/dbox
        BLE     nothing
d2919 1
a2919 2
        BICNE   R3,R3,#&80000000        ; Reset hi-priority bit
        LDRNE   R4,[R3]                 ; Read pollword
d2927 1
d3046 1
a3046 1
        ADDGT   R4,R4,#2
d3050 1
a3050 1
        ADDGT	R4,R4,#3		; and skip -13 (which is the border)
d3182 2
a3183 2
        CMP     R3,#0                   ; is this a real window?
        BLGT    pageinicontask_R3R4     ; takes note of iconbar
d3732 1
a3732 1
        BGT     %BT01
d3745 1
a3745 1
        MOVLE   R14, R2   ; if we'd get a null string, then jump back to start
d3751 1
a3751 1
        BLE     %FT04
d3755 1
a3755 1
        BLT     %BT03
d4028 2
d4031 4
a4034 7
	RSBS    R14,R14,#0
	CMPLT   R4,#nullptr
	MOVLT   R4,#nullptr                     ; don't confuse punter!

        CMP     R4,#nullptr2                    ; if new task,
        BLEQ    setwimpicon                     ; work out which icon it is
;
d4042 2
a4043 2
        CMP     R14,#0
        BLE     %FT01
d4268 1
a4268 1
        BLT     noficon                         ; no more left
@


4.14
log
@  Fixed a number of long-standing but low priority bugs in the Wimp.
Detail:
  * Any top-bit-set sprite area pointer in a window definition was treated
    as a null pointer, and any top-bit-set program name pointer in
    Wimp_ReportError was similarly treated as a null pointer.
  * For 24-bit window colour builds, when the Wimp drew a title bar with
    the input focus, and there were sprite icons in the previously redrawn
    window, and the most recently plotted icon sprite was unpaletted and not
    selected or inverted, then the translation table for the icon sprite (in
    the RMA) would leak. I suppose that's what I get for re-using a bit of
    dead code without fully working out why it was bypassed in the first
    place...
  * The key handling code used to be over-eager to read bytes from the
    keyboard buffer: it would attempt to read up to 6 bytes ahead to ease
    the recognition of UTF-8 character sequences. This could cause problems,
    in particular if F12 was one of those 6 bytes, then any following bytes
    would be queued for use as Wimp keypresses, rather than being left in
    the keyboard buffer for use by ShellCLI. The Wimp now analyses the first
    byte read to make a sensible estimate of how many bytes it needs to read
    ahead.
  * Select-dragging (including Select-resizing) of windows with panes used
    to soak up all the processor time. This was because when the task
    received an Open_Window_Request, it would re-open the pane in front of
    the main window, but this would cause the Wimp to believe that it had to
    re-open the main window at the front of the stack again when Wimp_Poll
    was next called. The problem has been fixed so that the Wimp now
    examines all the windows in front of the drag window to see if they have
    the pane window flag bit set, and doesn't reshuffle the windows if they
    all do. (Actually, the test is performed such that foreground windows
    in front of the drag window are also ignored.)
Admin:
  Tested on a desktop machine.

Version 4.65. Tagged as 'Wimp-4_65'
@
text
@d1180 3
d1185 1
d1263 1
a1263 1
	[ false
d1276 1
a1276 1
        [ false
d2831 1
a2831 1
        B       repollwimp              ; no 'null return' tasks
d2846 1
a2846 1
        BNE     repollwimp
d2850 17
@


4.14.2.1
log
@  Added Dan Ellis's multithreading support, on a development branch for now.
Detail:
  This breaks the equivalence between tasks and AMB slots, allowing many
  threads of execution to share the same AMB slot, where an application's
  heap is usually located. In API terms, it is presented as an extension to
  Wimp_StartTask, see Docs/Multithreading for more information. It is the
  caller's responsibility to create a new stack chunk for the new thread if
  required. Note that BASIC's variable storage model is fundamentally
  unsuited for multithreading.
Admin:
  This was developed in 2001 and was not committed at the time due to lack
  of testing and peer review. It is now being added as a branch from a
  contemporary trunk Wimp. Hopefully somebody will be interested enough to
  merge the branch into a recent version!

Version 4.66, 4.77.2.1. Tagged as 'Wimp-4_66-4_77_2_1'
@
text
@a444 1
;        Debug   thread, "taskSP, taskstack: ", R14, R1
a461 1
;        Debug   thread, "Exiting to parent ", R14
@


4.13
log
@  Shock horror - a new feature for the Wimp! And some housekeeping too.
Detail:
  * Added new functionality for menu trees: submenus can now be opened by
    clicking on their parent menu item. This is particularly aimed at
    touchscreen devices, and is configurable via the new *Configure keyword
    WimpClickSubmenu.
  * Change to the menu inactivity timeout behaviour after auto-opening of
    submenus (either by hovering over the parent menu item or by the new
    click-to-open functionality): although all hover operations are still
    ignored for this period, any click operations *will* now be obeyed.
  * Corrected numerous misleading comments in the menu handling code.
  * Added some suspiciously absent ALIGNs in the *Configure keyword handlers.
  * Uses new ASCII case-forcing macros so there are now fewer warnings
    printed during assembly (and it should run faster now too).
  * Added an AREA directive so that objasm's -ABS switch is no longer needed.
  * Standardised ErrMem token across all Messages files that use English.
Admin:
  Tested on a desktop machine.
  Requires HdrSrc 1.06.

Version 4.57. Tagged as 'Wimp-4_57'
@
text
@d2274 19
d2294 1
d2453 2
a2454 1
; Reads a key from either keyin_buffer or keyprocess_buffer, from a range appropriate to the current alphabet
d3329 24
d3355 1
@


4.12
log
@  A number of bugfixes.
Detail:
  * The character codes returned from the Key_Pressed event were incorrect
    when the caret was in a writeable icon with Kd in the validation string,
    and either (a) the caret was not at the start and Delete or Backspace were
    pressed, or (b) the caret was not at the end and Copy was pressed. (This
    was because, in these cases, the writeable icon code exited through
    passbacktouser rather than exitprocess; the former expects the keycode to
    be preserved, but the UTF-8 extensions to key handling were corrupting it.)
    Shift-Copy, Ctrl-Copy and Ctrl-U were not affected.
  * The various checkhandle routines now preserve flags again, as they did
    before 32-bit support was added. This is crucial in a number of spots,
    because the flags are based upon a test of handle, and checkhandle
    corrupts the handle register. This fixes at least two bugs: you can now
    send messages to menus or dialogue boxes again, and Wimp_RedrawWindow
    called without a Redraw_Window_Request is back (so for example, the
    Desktop Welcome screen now works again).
  * Fixed a bit of errant 26-bitism in the multiple-window iconise code.
Admin:
  Tested briefly on an Ursula build.

Version 4.52. Tagged as 'Wimp-4_52'
@
text
@d1345 4
@


4.11
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d3524 2
a3525 2
        MOV     R0, PC
        TST     R0, #V_bit
@


4.10
log
@* Disabled checking of both mouse button transitions in error boxes in NC
  builds: now behaves like desktop builds (only detects button-down events).
* When mouse pointer is hidden following Wimp_Extend 12, changes of mouse
  button state will no longer cause the pointer to be reinstated.

Version 4.12. Tagged as 'Wimp-4_12'
@
text
@d26 9
a34 1
        Push    "R0,LR"
d44 1
a44 1
        Pull    "R0,PC",EQ,^            ; 0 ==> no owner at all (ie. Wimp)
d58 1
a58 1
        Pull    "R0,PC",LT,^            ; if no menu owner, give up
d62 1
a62 1
        Pull    "R0,PC",EQ,^            ; DON'T RELOAD userblk if not nec.!!!
d81 2
d84 4
a87 1

d235 1
a235 1
        MOVS    PC,LR
d242 1
a242 1
defaultfilters Entry "R0-R2"
d270 1
a270 1
        Pull    "R1,PC",,^              ; broadcast to the world
d1747 4
a1750 2
        BLEQ    setwimpicon             ; set up R4 and R5
        BEQ     gotbttype
d1754 1
a1754 1
        CMP     R4,#nullptr
d2441 1
a2441 1
        EXITS   LE
d2483 1
a2483 1
        EXITS
d2549 4
a2552 2
        BLLT    inkey0                  ; if we don't have a key yet then get one (preserves flags)
        MOVLTS  r6, r1
d2632 1
a2632 1
        MOVS    PC,LR                   ; must preserve flags
d2713 1
a2713 1
        Push    "lr"
d2752 1
a2752 1
        Pull    "pc",,^
d2834 1
a2834 1
DeletePollTask  Entry "R0,R1"
d2912 1
a2912 1
        Push    "R0-R8,LR"
d2964 1
a2964 3
        Pull    "R0-R8,LR"
        MOVVCS  PC,LR
        MOV     PC,LR                   ; preserve V
d2979 1
a2979 1
        MOVEQS  PC,LR                           ; forget it!
d3025 1
a3025 1
        Pull    "R2,R3,x0,y0,x1,y1,PC",,^
d3098 1
a3098 1
        Pull    "R2,R3,x0,y0,x1,y1,PC",,^
@


4.9
log
@Optimisation to new WimpSymbol substitution code: in icons containing fonts
  other than the desktop font, the substitution table is only calculated
  when a symbol character is encountered.
Embryonic cut-n-paste support introduced (currently in desktop builds only):
  * workspace is allocated and initialised;
  * extended Wimp_GetCaretPosition implemented;
  * pushfontstring adapted to allow insertion of arbitrary control sequences in
    font strings (to allow selected text to be plotted in inverted colours).
Inverted, unfilled text icons now work properly again in <256-colour modes.
Reworked NC error box code: see Doc.IconHigh.

Version 4.11. Tagged as 'Wimp-4_11'
@
text
@d4034 1
a4034 1
        
d4038 1
a4038 1
        
d4043 1
a4043 1
        TEQEQ   R2, R5
d4045 1
a4045 1
        
@


4.8
log
@Adapted assembly process so that the choice of Options file (previously based
purely on the "System" variable) can be overridden by passing "OPTIONS=foo" as
an argument to either MkRom, or to amu/amu_machine directly, or indirectly,
by specifying it in the components file for a build. To accomplish this, it
was necessary to switch from using aasm to objasm - hence the large number of
source files affected in this commit.

Version 4.09. Tagged as 'Wimp-4_09'
@
text
@d2269 1
a2269 1
        ADR     R7, keyin_buflen        ; R5 already set up
d4028 28
@


4.7
log
@UTF-8 support from previous version switched in; additional alphabet-
conditional support added as follows:
* Correctly converts character index returned from Font_FindCaret into byte
  index into raw string.
* Left-arrow, right-arrow, delete-left and delete-right now act as far as
  the next character boundary, instead of to the next byte.
* Menu item text justification works again (it relies on overwriting spaces
  with hard space characters, which are two-byte characters in UTF-8).
* General key handling code has been rewritten. The Wimp now has three
  internal key input buffers - one each for taking keyboard-generated,
  task-generated, and function-key-generated strings. Each input buffer is
  processed in chunks of one character, rather than one byte; malformed
  UTF-8 characters are rejected, so tasks don't have to worry about them
  (simplifying their character-handling code). There is also a key output
  buffer, to ensure that (UTF-8) sequences of Key_Pressed events are not
  broken up.
* As a result of the above, multiple calls to Wimp_ProcessKey are now
  possible between calls to Wimp_Poll. Previously, this resulted in bytes
  getting jumbled up - making it useless for input of UTF-8 characters.
* Multi-byte characters are inserted into writeable icons in one go, so you
  don't see a brief flicker of the "malformed character" symbol while the
  initial bytes are being inserted.
* Multi-byte characters that don't entirely fit in a writeable icon buffer
  are not inserted at all.
* A new validation string command ("U") can limit the contents of a
  writeable by number of characters, instead of bytes. This will hide the
  character sizes from the user interface.
* Allowable characters (validation string command "A") now works on Unicode
  characters and character ranges.
* Various other minor bugs are fixed (Wimp_ProcessKey 13 can activate a
  writeable menu item, Shift-arrow keys are always consistent in firing off
  Key_Pressed events, etc.)
* Password icons supported: one symbol is displayed for each character
  (instead of for each byte); the display character (validation string
  command "D") can be any UTF-8 character; correctly displays the caret
  after set-caret-by-index calls, even though characters in the processed
  string are different width to those in the raw string, in password icons.

Other changes:
* The border around NC-style error boxes is resized when the error window
  is grown or shrunk.
* Messages, CmdHelp and Template files made consistent across resource
  directories, including support for all Ursula features.
* ShrinkableAreas turned back on in System=RCA builds.
* User interface features of desktop OS builds standardised.

Version 4.06. Tagged as 'Wimp-4_06'
@
text
@d229 1
a229 1
defaultfilters ENTRY "R0-R2"
d2383 1
a2383 1
        ENTRY   "R0,R4,R5"
d2421 1
a2421 1
        ENTRY   "R0-R4"
d2660 1
a2660 1
        CMP     r2, #"\"
d2817 1
a2817 1
DeletePollTask  ENTRY "R0,R1"
d2848 1
a2848 1
scanpollwords   ENTRY "R1-R4"
d3506 1
a3506 1
        ENTRY   "R0-R4,handle"
d3561 1
a3561 1
        ENTRY
@


4.6
log
@Spinner branch merged.
Changed to use srccommit.
All conditionals on "Version" removed.

Version 4.01. Tagged as 'Wimp-4_01'
@
text
@d2181 291
d2616 3
@


4.5
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d295 1
a295 1
        
a394 1
    [ Version >= 311
a403 1
    ]
d978 1
a978 1
      [ Version >= 317 :LAND: mousecache
d1581 1
a1581 1
      ]      
a2521 1
      [ Version >= 311
a2541 1
      ]
a2552 1
      [ Version >= 311
a2577 35
      |

scanpollwords
        Push    "R2-R9,LR"

        ADRL    R2,taskpointers-4       ; R2 -> one before first
        ADD     R3,R2,#maxtasks*4       ; R3 -> last element
        LDR     R5,pollwordtaskhandle
        ADD     R5,wsptr,R5             ; R5 -> current task data
        MOV     R6,#maxtasks            ; R6 = number to try
01
        CMP     R5,R3                   ; wrap if reached end
        MOVCS   R5,R2
        LDR     R4,[R5,#4]!
        TEQ     R4,#task_unused         ; NE => task is alive
        LDRNE   R8,[R4,#task_pollword]
        TSTNE   R8,R0                   ; NE => consider this
        BICNE   R8,R8,#&80000000
        LDRNE   R9,[R8]
        TEQNE   R9,#0                   ; NE => word non-zero!
        BNE     returnpollword

        SUBS    R6,R6,#1
        BNE     %BT01
        Pull    "R2-R9,PC"              ; EQ => not found

returnpollword
        SUB     R14,R5,wsptr            ; R14 = task handle
        STR     R14,pollwordtaskhandle
        Task    R14,,"Poll word"        ; preserves flags
        MOV     R0,#PollWord_NonZero    ; R0 = reason code
        STMIA   userblk,{R8,R9}

        Pull    "R2-R9,PC"              ; NE => found!
 ]
d2874 1
a2874 1
      [ Version >= 317 :LAND: togglebits
d2928 1
a2928 1
      [ Version >= 317 :LAND: togglebits
d2965 1
a2965 1
      [ Version >= 317 :LAND: togglebits
d2976 1
a2976 1
      [ Version >= 317 :LAND: togglebits
d3137 1
a3137 1
02        
d3151 1
a3151 1
        
d3269 1
a3269 1
        [ Version >= 393 :LAND: IconiseButton
d3278 1
a3278 1
        
d3298 1
a3298 1
        
d3303 1
a3303 1
        LDR     r2, taskhandle           
d3311 1
a3311 1
        
d3315 1
a3315 1
        
d3650 6
a3655 6
;
        LDR     R14,singletaskhandle            ; if single-tasking,
        RSBS    R14,R14,#0
        CMPLT   R4,#nullptr
        MOVLT   R4,#nullptr                     ; don't confuse punter!
;
d3702 1
a3702 1
      [ Version >= 317 :LAND: mousecache
d3727 1
a3727 1
      [ Version >= 317 :LAND: mousecache
@


4.4
log
@Corrected setting of WatchdogTimer option to false.
Made options files specify any text wanted after the module version number.
Auto-fronting iconbar now returns to previous position rather than back, so
it interacts with Shift+F12 better.
@
text
@d285 1
d290 1
d295 1
a295 1
;
d309 15
d495 1
d517 9
d818 8
d827 1
d852 1
a852 1
        SWI     OS_WriteI+16            ; CLG
d988 1
d1169 2
a1170 1
; Icon bar is held by menu
d1174 5
a1178 1
10	TEQ	R1,#0		; are we at the bottom of the screen?
d1181 6
d1198 2
a1199 2
	[ false
	LDR	R14,automenu_timelimit
d1248 1
d1254 1
d1261 1
d1267 9
d1419 5
d1458 8
a1508 1
	[ true
d1511 2
a1512 1
        MOVLT   R8,#-iconbar_scroll_speed * 100 - 1                ; scroll left
d1514 1
a1514 5
	|
	ADD	R14,R14,#iconbar_scroll_speed
	SUBS	R8,R0,R14
	BLT	%FT02
	]
a1515 1
	[ true
d1521 1
a1521 8
        MOVGT   R8,#iconbar_scroll_speed * 100                 ; scroll right
	|
	SUB	R14,R14,#iconbar_scroll_speed
	SUBS	R8,R0,R14
	MOVLE	R14,#0
	STRLE	R14,iconbar_scroll_start_time
	BLE	%FT01
	]
d1541 6
a1546 7
	[ iconbar_scroll_accel = 1
	CMP	R8,#0
	ADDGT	R8,R8,R2
	SUBLT	R8,R8,R2		; R8=(+/-)(speed + accel*time)
	|
	MOV	LR,#iconbar_scroll_accel
	MUL	LR,R2,LR		; LR=accel * time
d1548 1
a1548 1
	ADDGT	R8,R8,LR
d1550 4
a1553 3
	]
	MUL	R8,R2,R8		; R8=(+/-)(speed + accel*time) * time
	ADD	R5,R5,R8,ASR #6		; R5+=(+/-)(speed + accel*time) * time/128 (approximation to 100)
d1577 7
d2105 12
d2182 1
d2741 6
d2748 1
d2817 7
a2823 1
	BNE	%BT05
a2832 4
        [ BounceClose
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; back
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; quit
        |
d2834 1
a2834 2
        DCD     ibt_click        :SHL: ib_buttontype
        ]
a2835 3
	[ BounceClose
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; toggle
	|
a2836 1
	]
a2846 3
	[ BounceClose
	DCD	ibt_clickrelease :SHL: ib_buttontype	    ; iconise
	|
d2849 17
d2867 2
d2985 6
d2993 1
d3027 3
d3031 1
d3090 30
a3119 2
	Push	"r0-r4"
	B	%FT20
d3136 47
d3185 1
a3185 1
        SWI     OS_Byte
d3191 28
d3220 141
a3360 2
                                        ; Shift-quit, send message_Iconize.
20      MOV     R14,#ms_data+8+20       ; size of block (Window,Task,20 byte from title ).
d3366 6
d3373 1
d3386 6
d3405 5
d3430 1
a3430 45
       Pull     "r0-r4"
       B        trykeys

not_alt
        [ StickyMenus
;        LDR     R0,[handle,#w_taskhandle]
;        CMP     R0,#-1
;        BNE     %FT05
        LDR     R14,menuSP
        CMP     R14,#-4
        BEQ     %FT05                           ; no menu open

        LDR     R14,menuhandles
        Abs     R14,R14
        TEQ     handle,R14

        BNE     %FT02
        BL      menusdeleted
        MOVVC   R0,#-4
        BLVC    closemenus
        B       nothing                         ; swallow it.
02
        LDR     R14,menuSP
        ADD     R14,R14,#4
        ADR     R0,menuhandles
03
        LDR     R1,[R0,R14]
        Abs     R1,R1
        TEQ     R1,handle
        BEQ     %FT04
        SUBS    R14,R14,#4
        BGE     %BT03
        B       %FT05
04
        SUB     R0,R14,#4
        BL      closemenus              ; close down to one above
        B       nothing
05
        ]
	[ BounceClose
	STR	R2,mousebuttons		; Horrible hack so apps can tell that adjust was pressed
	]
        STR     R3,[userblk]
        MOV     R0,#Close_Window_Request
        B       ExitPoll
d3559 4
d3684 1
a3684 1
        MyEntry "Get_Pointer_Info"
d3851 1
a3851 1
        Debug   child,"Click within outer box of",handle
@


4.4.2.1
log
@Added Message_IconizeAt before Message_Iconize is sent
@
text
@d3004 3
a3006 42
        
        [ Version >= 393
20
        ; Send a Message_IconizeAt (RML)
        Push    "r0-r4"
        SUB     sp, sp, #48
        MOV     r1, sp
        SWI     Wimp_GetPointerInfo
        
        LDR     r0, [r1]
        STR     r0, [r1, #28]            ; x co-ord
        LDR     r0, [r1, #4]
        SUB     r0, r0, #(32+17)
        STR     r0, [r1, #32]            ; y co-ord
        MOV     r0, #36
        STR     r0, [r1]                 ; size
        MOV     r0, #0
        STR     r0, [r1, #12]            ; your ref
        LDR     r0, =Message_IconizeAt   ; (Message number 22)
        STR     r0, [r1, #16]            ; message action
        STR     r3, [r1, #20]            ; window handle
        
        ; Work out task handle
        LDR     r2, taskhandle           
        LDR     r4, [wsptr, r2]          ; add in version bits (if alive)
        TST     r4, #task_unused
        LDREQ   r4, [r4, #task_flagword]
        MOVEQ   r4, r4, LSR #flag_versionbit
        ORREQ   r2, r2, r4, LSL #flag_versionbit
        STR     r2, [r1, #24]
        
        MOV     r0, #User_Message
        MOV     r2, #0
        SWI     Wimp_SendMessage
        
        ADD     sp, sp, #48
        Pull    "r0-r4"
        |
20
        ]
                                                ; Shift-quit, send message_Iconize.
        MOV     R14,#ms_data+8+20       ; size of block (Window,Task,20 byte from title ).
@


4.4.2.2
log
@Hourglass depth now incremented by 1 between calls to Wimp_Poll; effect is
to automatically display hourglass whenever applications hog the CPU,
irrespective of whether they already display the hourglass themselves or not.
Hourglass is automatically smashed before any Command Windows are displayed
so that output-generating single-tasking programs are not forced to show the
hourglass due to the behaviour described above.
@
text
@a292 12
      [ Version >= 394 :LAND: AutoHourglass
        Push	"R0"
        SWI	XHourglass_Off
        CLRV
        Pull	"R0"
      [ debugautohg
	Push	"handle"
	LDR	handle,taskhandle
        Debug	autohg,"Hourglass_Off at Wimp_Poll start, taskhandle =",handle
        Pull	"handle"
      ]
      ]
@


4.4.2.3
log
@Added flags word to Message_IconizeAt, as per Pinboard FS.
@
text
@a2990 1
	MOV     r1, #0                  ; NOT a shift+click on close icon
a3021 6

        CMP     r1, #&FF                 ; If a Shift+Click on close
        MOVEQ   r0, #1                   ; then bit 0 of flags is set
        MOVNE   r0, #0
        STR     r0, [sp, #36]
        
d3030 1
a3030 1
        MOV     r0, #40
@


4.4.2.4
log
@Main new features in Ursula build so far
(some are also available in other builds):

* New icon highlighting scheme - hue rotated 180 degrees, photographic negative,
  darkened 25% - suits Ursula icons better.
* Release-button window tools compile-time switch turned on.
* Any "TASK" word cleared on exit from Wimp_OpenWindow, Wimp_GetWindowState,
  Wimp_ForceRedraw and Wimp_CloseDown.
* Child windows are no longer allowed to be opened inside the icon bar.
* Message_IconizeAt generation optimised, and no longer calls non-X SWIs.
* Message_IconsChanged implemented, and switched out on speed grounds.
* Wimp_ReadSysInfo 15 removed, replaced with (new) Wimp_Extend 11.
* Backwindows are now segregated from normal windows. A new category,
  foreground windows, are added, and stay above all other windows. (The error
  box template is updated to make it a foreground window.)
* ROM sprites override RAM sprites (and duplicate RAM sprites are deleted
  during the building of the sprite lookup list, preceding the first sprite
  plot after a sprite pool update).
* Wimp_ReadSysInfo 16 added, to return sprite area pointers in order of
  priority (Wimp_BaseOfSprites retains the ROM/RAM distinction).
* Error box code altered:
  + symbolic names used for offsets into tempworkspace
  + error button text buffer enlarged
  + stretched error buttons now shrink back for next use
  + int_flush_opens called at appropriate points to ensure buttons are seen to
    slab in, and to reduce flicker when redisplaying error box at a different
    width (also fixes some redraw bugs)
  + Cancel button given the R6 type border when it will be activated by Return
    (and is therefore moved to the extreme right in such cases)
  + Escape now always selects the second-right button (unless there's only one
    button!) - this also fixes a bug when there's a single user-defined button
  + keypresses in "xxx may have gone wrong" error boxes are now correctly
    interpreted - previously the buttons available in the underlying box were
    being used to determine the effect of keys
  + maximum number of buttons increased from 4 to 8, and the machine no longer
    crashes when the maximum is exceeded
  + window stretches horizontally to keep error message to 7 lines or less
* Bugfix: opening or creating a window with a minimum x visible area coordinate
  of -1 was leading to any of smearing/flickering/recursive drawing. (This was
  actually due to a failure to recognise which windows' positions had been
  updated.)
* Features merged in from spinner branch Wimp:
  + support for UpCall_MediaSearchEndMessage added
  + control-termination allowed in upcalls (used to require null-termination)
  + escape character switched to default during error box display, then
    switched back again afterwards
* GetRectangle filters are now called with (internal) window handle in R10.
* Autohourglass is deactivated whenever WrchV is invoked. (Also optimised.)
* Action button bugfixes:
  + action buttons now deselect if the pointer is dragged off and a window tool
    is the pressed before all the buttons have been released
  + action buttons now slab in following a long (autorepeating) press on a
    scroll arrow window tool
@
text
@d293 13
a305 1
        
a318 15
      [ AutoHourglass                   ; it could still be a while until the next task switch,
        LDR     R1, hourglass_status    ; so ensure the hourglass is off at this point
      [ debugautohg
	Push	"handle"
	LDR	handle, taskhandle
        Debug	autohg, "Hourglass_Off at Wimp_Poll entry: taskhandle, old status =", handle, R1
        Pull	"handle"
      ]
        TEQ     R1, #2                  ; is hourglass still pending or active?
        MOVEQ   R1, #1                  ; yes, so turn off hourglass (but keep on vector for speed reasons)
        STREQ   R1, hourglass_status
        SWIEQ   XHourglass_Off
        CLRV                            ; ignore errors
      ]

d3018 1
a3018 1
        [ Version >= 393 :LAND: IconiseButton
d3030 2
a3031 8
        [ true
        LDR     r0, mousexpos
        STR     r0, [r1,#ms_data+8]
        LDR     r0, mouseypos
        SUB     r0, r0, #(32+17)
        STR     r0, [r1,#ms_data+12]
        |
        SWI     Wimp_GetPointerInfo        
a3036 1
        ]
d3038 1
a3038 1
        STR     r0, [r1,#ms_size]        ; size
d3040 1
a3040 1
        STR     r0, [r1, #ms_yourref]    ; your ref
d3042 2
a3043 2
        STR     r0, [r1, #ms_action]     ; message action
        STR     r3, [r1, #ms_data+0]     ; window handle
d3052 1
a3052 1
        STR     r2, [r1, #ms_data+4]
d3056 1
a3056 1
        BL      int_sendmessage_fromwimp
@


4.4.2.5
log
@New features:
Dragboxes can now be clipped by and/or fixed to a given window's work area
SWI Wimp_AutoScroll implemented
Ursula icon highlighting scheme redesigned

Bugfixes:
Wimp_Extend 11 now performs the same check on R1 as the main SWI handling code
Message blocks now updated if in a dynamic area
Screenblanker now turned off when error box is displayed
ptr_double now turned off when a drag starts
@
text
@a805 8
      [ Autoscr
        LDR     R14, dragflags
        TST     R14, #dragf_clip ; clipped dragboxes must only be redrawn within their own window
        LDRNE   R14, draghandle
        Abs     R14, R14, NE
        TEQNE   R14, handle
        BLEQ    forcedrag_on            ; put drag rectangle back if nec.
      |
a806 1
      ]
a1153 6
      [ Autoscr
        ; Don't bring to front if autoscrolling
        LDR     R14, autoscr_state
        TST     R14, #af_enable
        Pull    "R0, PC", NE
      ]
a1373 5
      [ Autoscr
        LDR     R14, autoscr_state      ; don't reprogram pointer if autoscrolling is enabled
        TST     R14, #af_enable
        ORRNE   R3, R3, #&10
      ]
a1407 8
      [ Autoscr
; do we need to do something about autoscrolling?
        LDR     R14, autoscr_state
        TST     R14, #af_enable
        BLNE    poll_autoscroll         ; may or may not return, preserves flags if it does
        BNE     %FT01                   ; don't scroll icon bar if scrolling something else!
      ]

a1530 7
      [ Autoscr
; also treat as window -1 (but just for the purposes of Pointer Leaving/Entering Window events) if
; we're autoscrolling (which is not necessarily a subset of if dragging)
        LDR     R14, autoscr_state
        TST     R14, #af_enable
        MOVNE   R3, #nullptr
      ]      
@


4.4.2.6
log
@Iconise button removed from child windows
Icon bar now jumps to the back of the stack as soon as a window is opened above
it (excluding menus, dialogue boxes and foregroud windows). This is to avoid
the ambiguous situation when the icon bar can be part-way down the window stack.
Improved co-odination between auto-fronting and Shift-F12 behaviour.
Stopped scroll offset overflow during icon bar scroll.
Numerous features made configurable:
  WimpIconBarSpeed
  WimpIconBarAcceleration
  WimpSpritePrecedence
  WimpIconiseButton
  WimpStickyEdges (although not actually implemented yet)
  WimpAutoFrontIconBar
  WimpAutoFrontDelay
  WimpAutoScrollDelay
To make room for these in CMOS, Wimp<Drag|DoubleClick><Delay|Move> and
Wimp<AutoMenu|MenuDrag>Delay options are now stored in a more compressed form
in CMOS - but the *Configure interface is unaltered.
@
text
@d1156 1
a1156 2
	NOP ; drops through
; Icon bar is held by menu, or fronted by keyboard
d1160 1
a1160 5
10      LDRB    R14, popiconbar
        TEQ     R14, #0
        Pull    "R0, PC", EQ    ; don't bring to front if configured off

        TEQ	R1,#0		; are we at the bottom of the screen?
d1180 2
a1181 2
	[ true
	LDR	R14, popiconbar_pause
a1229 1
	[ false
a1234 1
	]
a1240 1
        [ false
a1245 5
	|
	ORR     R14, R14, #wf_backwindow
	STR     R14, [handle, #w_flags]
	MOV     R6, #-2
	]
d1479 1
d1482 1
a1482 2
        LDRLT   R8, iconbar_scroll_speed
        MVNLT   R8, R8 ; ensure msb set                        ; scroll left
d1484 5
a1488 1
;
d1490 1
d1496 8
a1503 1
        LDRGT   R8, iconbar_scroll_speed                       ; scroll right
d1523 7
a1529 6
	CMP     R2, #&3800              ;; much more than this, and accel*time^2 will overflow
	MOVHI   R2, #&3800              ;; when maximum acceleration is configured
	LDR	LR, iconbar_scroll_accel
	MUL	LR,R2,LR		; LR=accel * time (cs)
	MOV     LR, LR, ASR#6
	ADD     LR, LR, LR, ASR#2       ; LR=accel * time (s) (within 3%)
d1531 1
a1531 1
	ADDGE	R8,R8,LR
d1533 3
a1535 4
	ADDLT   R8, R8, #1              ; adjust because we used NOT(speed) rather than -(speed) for velocity
	MUL	R8,R2,R8		; R8=(+/-)(speed + accel*time) * time (cs)
	ADD     R8, R8, R8, ASR#2
	ADD	R5,R5,R8,ASR #6		; R5+=(+/-)(speed + accel*time) * time (s)
d2779 1
a2779 7
	BEQ     %FT04
	LDR     R2, [handle, #w_parent]
	CMP     R2, #-1
	BNE     %FT04
	LDRB    R2, iconisebutton
	TEQ     R2, #0
	BNE     %BT05
@


4.4.2.7
log
@Added Ursula Service Call table
Flushes cached screen after dragbox updates
Fixed window stack behaviour so background windows interact conventionally again
  (fixes a number of window positioning bugs)
Disabled Shift-Select-close for child windows
@
text
@a3062 7
        [ ChildWindows
        LDR     R0, [handle, #w_parent] ; don't do anything if Shift-close on child windows
        CMP     R0, #-1
        Pull    "r0-r4",NE
        BNE     trykeys
        ]
        
@


4.4.2.8
log
@* When a window was reopened such that the iconise button replaces the
  toggle-size icon (or vice versa), the Wimp now spots that the relevant
  rectangle needs redrawing.
* When a window stays put, but scrolls in one direction, the unaffected
  scrollbar is no longer redrawn, in order to reduce flicker. This was
  coded, but broken, on Risc PC Wimps, but doubly broken in the Nested Wimps
  - and the flicker was particularly noticeable with Ursula's cached screen
  enabled...
* Fixed nasty bug in nested window open flushing: this seems to have been
  caused by faulty behaviour of addsub when passed a rectangle where cx0>cx1
  and/or cy0>cy1. Filtering out such cases from subrect calls in
  (old)subtract_openingchildren prevents this from being the case. The old
  behaviour was trashing the borderrects list, which resulted in the loss of
  the invalidrects list, causing full-screen redraw when a window containing
  seven (or more) child windows was scrolled or resized.
* Fixed a bug introduced in last version, whereby program error and watchdog
  error box text was overwritten with "WindowManager:Sprites22".
* Supported long pathnames for *IconSprites.
@
text
@d3636 1
a3636 1
;        Debug   child,"Click within outer box of",handle
@


4.4.2.9
log
@Added a couple of extra compile-time options for use in specialied
applications; both are switched out in all standard builds.

ForceTwitter: used in combination with Twitter flag, this causes
   antitwittering to be employed irrespective of ModeFlags bit 8,
   and also irrespective of whether a window is auto-redraw or not.

HideIconBar: ensures that the icon bar is behind the backwindow, unless
   it has been brought to the front (by either method). In conjunction with
   a modified Pinboard, this can produce a quick-and-dirty iconbar-less
   machine.
@
text
@a1256 3
 [ HideIconBar
	MOV     R6, #-3
 |
a1257 1
 ]
@


4.4.2.10
log
@Window tool button type is now configurable.
Windows now keep the same depth when toggle-size tool is clicked with Adjust.
Fixed bug where drags in Eureka caused branch-through-zeros and other
miscellaneous errors.
Fixed a few stray non-X form SWI calls.
Extended applicability/functionality of "MyEntry" debug macro.
@
text
@a284 1
        Debug   poll2, "Wimp_PollIdle entry"
a288 1
        Debug   poll2, "Wimp_Poll entry"
a492 1
        Debug   poll2, "repollwimp"
d840 1
a840 1
        SWI     XOS_WriteI+16           ; CLG
a975 1
        Debug   poll2, "Processing mouse"
a2156 1
        Debug   poll2, "Processing keys"
a2714 6
      [ BounceClose
        LDRB    R14, buttontype
        TEQ     R14, #0
        ADREQ   R14, wiconflags - 4
        ADRNE   R14, wiconflags_release - 4
      |
a2715 1
      ]
d2800 4
d2805 2
a2806 1
        DCD     ibt_click        :SHL: ib_buttontype        ; quit
d2808 3
d2812 1
d2823 3
a2827 17

    [ BounceClose
wiconflags_release
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; back
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; quit
        DCD     ibt_click        :SHL: ib_buttontype        ; move BLOBBY
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; toggle
        DCD     -1                                          ; scup
        DCD     ibt_click        :SHL: ib_buttontype        ; scvert
        DCD     -1                                          ; scdown
        DCD     ibt_click        :SHL: ib_buttontype        ; size
        DCD     -1                                          ; scleft
        DCD     ibt_click        :SHL: ib_buttontype        ; schoriz
        DCD     -1                                          ; scright
	[ IconiseButton
	DCD	-1
	DCD	ibt_clickrelease :SHL: ib_buttontype	    ; iconise
a2828 2
    ]

a2870 3
	[ BounceClose
	STR	R2,mousebuttons		; Horrible hack so adjust-toggle still works properly
	]
d3060 1
a3060 1
        SWI     XOS_Byte
d3473 1
a3473 1
        MyEntry "GetPointerInfo"
@


4.4.2.11
log
@Window status flag bit 17 "window is fully visible" is now correctly set for
nested windows.
If the lowest window (eg most recently iconised window) is a hotkey window,
the Wimp used to hang if a keypress was not claimed by any task. Now fixed.
Hotkey events can now be delivered to nested windows.
Ctrl-Alt-Close now closes all windows, at the same nesting level, provided
that they have close buttons.
Ctr-Alt-Iconise now iconises all top-level windows that have close buttons.
Low-res versions of autoscroll pointers fixed: they had been in 256 greys!
@
text
@a516 9
      [ MultiClose
        LDR     R2, nextwindowtoiconise
        TEQ     R2, #0
        BLNE    iconisenextwindow
        LDR     R2, headpointer         ; are there any outstanding messages now?
        CMP     R2, #0
        BGT     returnmessage
      ]
;
d2890 3
a3001 3
      [ BounceClose
        LDR     R2,pending_buttons      ; Horrible hack so adjust works even with release buttons
      |
a3002 1
      ]
d3061 3
a3063 30
        Push	"r0-r4"
      [ MultiClose
        TST     R2, #button_right       ; Ctrl-Alt-*Adjust* isn't special
        MOVNE   R1, #0                  ; flag as due to iconise button
        BNE     %FT20

        MOV     R0, #121
        MOV     R1, #&81                ; Scan keyboard for Ctrl key
        SWI     XOS_Byte
        MOV     R4, R1
        MOV     R1, #&82                ; Scan keyboard for Alt key
        SWI     XOS_Byte
        TEQ     R4, #&FF
        TEQEQ   R1, #&FF
        MOVNE   R1, #0                  ; flag as due to iconise button
        BNE     %FT20

        ; Iconise all top-level windows that have close buttons (except hotkey windows)
        LDR     handle, activewinds + lh_forwards
        SUB     R0, handle, #w_active_link
        Rel     R0, R0
        STR     R0, nextwindowtoiconise
        BL      iconisenextwindow
        Pull    "R0-R4"
        B       trykeys

      |
        MOV     R1, #0                  ; NOT a shift+click on close icon
        B	%FT20
      ]
a3079 47
      [ MultiClose
        MOV     R0, #121
        MOV     R1, #&81                ; Scan keyboard for Ctrl key
        SWI     XOS_Byte
        MOV     R4, R1
        MOV     R1, #&82                ; Scan keyboard for Alt key
        SWI     XOS_Byte
        TEQ     R4, #&FF
        TEQEQ   R1, #&FF
        BNE     %FT66

      [ BounceClose
        LDR     R2, pending_buttons
        STR     R2, mousebuttons        ; The usual Horrible Hack
      ]
        ; Close all windows at this level that have close buttons (except hotkey windows)
        LDR     handle, [handle, #w_parent]
        CMP     handle, #nullptr
        LDREQ   handle, activewinds + lh_backwards
        LDRNE   handle, [handle, #w_children + lh_backwards]
01      LDR     R0, [handle, #ll_backwards]
        CMP     R0, #nullptr
        BEQ     %FT02
        LDR     R14, [handle, #w_flags - w_active_link]
        TST     R14, #wf_icon2
        ANDNE   R14, R14, #wf_grabkeys
        TEQNE   R14, #wf_grabkeys
        MOVEQ   handle, R0
        BEQ     %BT01
        ; Found such a window; send close request message
        Push    "R0"
        SUB     handle, handle, #w_active_link
        SUB     sp, sp, #4
        Rel     R2, handle
        STR     R2, [sp]
        MOV     R0, #Close_Window_Request
        MOV     R1, sp
        BL      int_sendmessage_fromwimp
        ADD     sp, sp, #4
        Pull    "handle"
        B       %BT01
02        
        Pull    "R0-R4"
        B       trykeys
66
      ]

d3095 2
a3097 111
      [ MultiClose
        LDR     r2, mousexpos
        LDR     r4, mouseypos
      ]
        BL      sendiconisemessages
        Pull    "r0-r4"
        B       trykeys

not_alt
        [ StickyMenus
;        LDR     R0,[handle,#w_taskhandle]
;        CMP     R0,#-1
;        BNE     %FT05
        LDR     R14,menuSP
        CMP     R14,#-4
        BEQ     %FT05                           ; no menu open

        LDR     R14,menuhandles
        Abs     R14,R14
        TEQ     handle,R14

        BNE     %FT02
        BL      menusdeleted
        MOVVC   R0,#-4
        BLVC    closemenus
        B       nothing                         ; swallow it.
02
        LDR     R14,menuSP
        ADD     R14,R14,#4
        ADR     R0,menuhandles
03
        LDR     R1,[R0,R14]
        Abs     R1,R1
        TEQ     R1,handle
        BEQ     %FT04
        SUBS    R14,R14,#4
        BGE     %BT03
        B       %FT05
04
        SUB     R0,R14,#4
        BL      closemenus              ; close down to one above
        B       nothing
05
        ]
	[ BounceClose
	STR	R2,mousebuttons		; Horrible hack so apps can tell that adjust was pressed
	]
        STR     R3,[userblk]
        MOV     R0,#Close_Window_Request
        B       ExitPoll

      [ MultiClose
iconisenextwindow
        ENTRY   "R0-R4,handle"
        LDR     handle, nextwindowtoiconise
        BL      checkhandle             ; make sure it's still valid
        MOV     R0, PC
        TST     R0, #V_bit
        LDREQ   R14, [handle, #w_flags]
        ANDEQ   R0, R14, #ws_open
        CMPEQ   R0, #ws_open            ; and open
        ADDEQ   handle, handle, #w_active_link
        LDRNE   handle, activewinds + lh_forwards ; if not, restart from top
01
        LDR     R0, [handle, #ll_forwards]
        CMP     R0, #nullptr             ; have we reached the header?
        MOVEQ   R0, #0
        STREQ   R0, nextwindowtoiconise
        EXIT    EQ                       ; stop if we have
        LDR     R14, [handle, #w_flags - w_active_link]
        TST     R14, #wf_backwindow
        MOVNE   R0, #0
        STRNE   R0, nextwindowtoiconise
        EXIT    NE                       ; don't re-iconise already-iconised windows!
        TST     R14, #wf_icon2
        ANDNE   R14, R14, #wf_grabkeys
        TEQNE   R14, #wf_grabkeys
        MOVEQ   handle, R0
        BEQ     %BT01
        ; Found a suitable window; work out suitable entry conditions for sendiconisemessages
        Push    "R0"
        SUB     handle, handle, #w_active_link
        MOV     R0, #iconposn_iconise
        BL      calc_w_iconposn          ; x0-y1 = button bbox
        ADD     R2, x0, x1
        ADD     R4, y0, y1
        MOV     R2, R2, LSR#1
        MOV     R4, R4, LSR#1
        MOV     R1, #0
        Rel     R3, handle
        BL      sendiconisemessages
        ; Now store the next window to process (if any)
        Pull    "handle"
        LDR     R0, [handle, #ll_forwards]
        CMP     R0, #nullptr
        MOVEQ   R0, #0
        SUBNE   R0, handle, #w_active_link
        Rel     R0, R0, NE
        STR     R0, nextwindowtoiconise
        EXIT
      ]

sendiconisemessages
; Entry: R1 = &FF => caused by click on close icon; R1 = 0 => caused by click on iconise icon
;        R3 = relative window handle to send
; and if MultiClose enabled,
;        R2 = mouse x
;        R4 = mouse y
        ENTRY

        [ Version >= 393 :LAND: IconiseButton
d3099 1
a3099 1
        Push    "r3"
d3105 1
a3105 1
        STR     r0, [sp, #ms_data+16]
d3108 1
a3108 5
      [ MultiClose
        STR     r2, [r1, #ms_data+8]
        SUB     r4, r4, #32+17
        STR     r4, [r1, #ms_data+12]
      |
d3114 8
a3121 1
      ]
a3130 3
      [ MultiClose
        LDR     R2, [handle, #w_taskhandle]
      |
a3131 1
      ]
d3144 3
a3146 1
        Pull    "r3"
a3154 6
      [ MultiClose
        LDR     R2, [handle, #w_taskhandle]
        LDR     R14, [handle, #w_titleflags]
        TST     R14, #if_indirected
        Task    "R2", NE, "Iconise: reading indirected title string"
      |
a3155 1
      ]
d3201 45
a3245 1
        EXIT
@


4.4.2.12
log
@Faded text-plus-sprite icons in Impression and ArtWorks were being plotted
incorrectly, due to what appears to have been a workaround for a RISC OS 2
Wimp bug.

A redraw problem turned out to be due to the rectangle limit, so this has been
doubled again.

A number of window-toggling bugs are fixed:
* if a window had no title bar, shift-toggle left a gap before the top of the
  screen
* window status flag bit 19 was always cleared during a call to Wimp_SetExtent
* tasks which called Wimp_SetExtent after an Open_Window_Request (eg the Filer)
  weren't always being considered "full-size" after a shift-toggle operation
* when a non-toggled window and its shift-toggled version were the same size,
  various problems arose (window status flags being wrongly set, toggle button
  being non-responsive for next click, toggle button not being redrawn
  correctly)
@
text
@a2972 6
      [ togglebits
        LDR     R14, [handle, #w_flags]
        TST     R14, #wf_icon3          ; we can still have a toggle-size button without a title bar!
        LDRNE   R14, title_height
        SUBNE   R6, R6, R14
      |
a2974 1
      ]
a3528 4
      [ togglebits
        LDR     R14, [handle, #w_flags]         ; don't mask out requests during a toggle operation!
        TSTEQ   R14, #ws_toggling
      ]
@


4.4.2.13
log
@Text is now correctly justified when in an icon with validation string
commands R8, R9, R10, ...

R5/R6 type icons now behave more usefully with button types other than click,
release and auto-repeat.

Prevented coordinate overflow in dragboxes.

Stopped clipped dragboxes from flickering more than non-clipped ones.

Fixed a bug whereby data aborts occurred when generating the translation table
for inverted and/or shaded 256-colour sprites, if the first 256-colour sprite
plotted since the Wimp's cached translation table was invalidated (either by
Service_InvalidateCache or by plotting a 256-colour sprite after a non-256-
colour sprite one) was at an address that had since been invalidated or paged
out. This fixes a long-standing problem with 256-colour sprites in the desktop,
but which only happened sporadically.

Prevented palette corruption in paletted ( <256-colour) modes when the pointer
reverts from an autoscroll pointer to its original setting.

Fixed bug introduced in last build, where clicking on the bottom pixel row of a
horixontal scrollbar, or the left pixel column of a back icon, caused a crash.

All Wimp-drawn solid rectangles are now be plotted much faster - typically
around twice as fast - translating to a typical 30% increase in speed of
plotting filled icons. Improvements will be better still in cases where icons
are drawn in a non-contiguous order: this commonly affects Toolbox applications.

When a dialogue box is opened from a menu, the Wimp will no longer attempt to
place the caret in a shaded or deleted icon, but it will do so for a type-14
(writable/click/drag) icon, as well as the standard type-15 (writable) icons.
This brings it in line with KA-validation up/down arrow actions.
@
text
@a2104 8
      [ true
        AND     R14, R1, #if_buttontype ; border_icon/windowselected behaviour is only suitable for a few button types
        MOV     R14, R14, LSR #ib_buttontype
        TEQ     R14, #ibt_autorepeat
        TEQNE   R14, #ibt_click
        TEQNE   R14, #ibt_clickrelease
        BNE     %FT03
      ]
@


4.4.2.14
log
@Bugfixes:
* icons with border R5 or R6 and button type 5-8 now slab in/out as on old
  Wimps again: this had been causing Marcel problems
* window titles with leading spaces and/or trailing periods no longer result
  in an iconised icon with a null text string
@
text
@a2110 4
        TEQNE   R14, #ibt_click2
        TEQNE   R14, #ibt_dclick
        TEQNE   R14, #ibt_dclickrelease
        TEQNE   R14, #ibt_dclick2
d3355 1
a3355 1
                                                ; Shift-quit, send Message_Iconize.
a3381 6
      [ true
00      LDRB    R3, [R2]  ; always skip leading spaces
        TEQ     R3, #&20
        ADDEQ   R2, R2, #1
        BEQ     %BT00
      ]
a3394 5
      [ true
        LDRB    R3, [R14]
        CMP     R3, #&20
        MOVLE   R14, R2   ; if we'd get a null string, then jump back to start
      ]
@


4.3
log
@ARTtmp branch folded in
@
text
@d1189 3
d1196 1
d1198 3
a1200 6
	BICEQ	R14,R14,#wf_backwindow
	ORRNE	R14,R14,#wf_backwindow
	STRVC	R14,[handle,#w_flags]
	ADDVC	R14,handle,#w_wax0
	LDMVCIA	R14,{R0-R3,R4,R5}
	MOVEQ	R6,#-1
d1202 17
d1220 1
a1220 1
	LDRVC	R14,iconbarhandle
d1222 2
a1223 2
	MOVVC	userblk,sp
	BLVC	int_open_window
d1225 1
@


4.2
log
@Merged WIMP imported
@
text
@d143 1
d148 1
d178 2
d211 2
d219 2
a344 1
        MedusaOS
d346 1
a346 2
        LDREQ   R0,orig_applicationspacesize
        MOVNE   R0,#&1000000
d374 1
a374 1
        CMPNE   R3,#0
d771 1
a771 1
        MOV     R0,#15
d814 1
a814 1
        MOV     R0,#15
d953 4
d1001 1
a1001 1
        CMP     R14,#drag_scrollboth    ; use vscroll bit of sysflags for this
d1118 92
d1376 1
d1407 77
d1703 1
a1703 1
        BLE     %FT01                           ; if -VE then ignore its not worth the hassel
d1942 1
d2005 3
d2022 1
d2024 19
a2042 2
        STREQ   handle,border_windowselected
        STREQ   R4,border_iconselected
d2044 3
a2046 4

        LDREQB  R0,autorepeating
        CMPEQ   R0,#0
        MOVNE   R0,#0
d2048 1
d2050 4
a2053 4
        MOVEQ   R0,R4                   ; R1 => icon handle
        MOVEQ   R1,#is_inverted
        MOVEQ   R2,#0
        BLEQ    int_set_icon_state      ; and then select the icon
d2055 1
d2620 1
a2620 1
;
d2637 3
d2705 8
a2712 1
        BCC     %BT01
a2719 1
        DCD     ibt_click        :SHL: ib_buttontype        ; back
d2721 2
a2722 1
        DCD     ibt_clickrelease        :SHL: ib_buttontype        ; quit
d2724 2
a2725 1
        DCD     ibt_click       :SHL: ib_buttontype
d2728 3
d2732 1
d2741 8
a2748 1

d2770 4
d2826 1
a2826 1
        Push    "R0-R2,R4"
d2834 6
a2839 2
        LDR     R4,hscroll_height
        ADD     R4,R4,#168              ; area not to be obscured
d2841 1
a2841 1
        CMP     cy0,R4                  ; does the bottom of the window obscure the icon bar?
d2862 1
a2862 1
        ADD     cy1,cy0,y1              ; setup the new co-ordinates for bottom & top Y's
d2864 13
a2876 3
        LDR     R14,scry1
        CMP     cy1,R14                 ; if y1 > screen top then truncate
        MOVGT   cy1,R14
d2884 1
a2884 1
        Pull    "R0-R2,R4"
d2957 6
d2977 1
a2977 1
        MOV     R0,#&79                 ; Scan keyboard for shift key
d2987 1
a2987 1
        MOV     R14,#ms_data+8+20       ; size of block (Window,Task,20 byte from title ).
d3078 3
@


4.1
log
@Initial revision
@
text
@d161 1
a161 1
;;                                                         
d180 1
a180 1
        
d185 1
a185 1
           
d190 2
a191 2
        
        ADRL    R14,prefilter   
d207 1
a207 1
        & -1                 
d212 1
a212 1
rectanglefilter_default 
d215 1
a215 1
                     
d225 1
a225 1
        MOV     R2,R0                   
d228 1
a228 1
        CMP     R14,#-1                      
d232 1
a232 1
                    
d237 2
a238 2
        EXITS             
            
d248 1
a248 1
        SWI     XOS_ServiceCall        
d296 1
a296 1
                             
d334 1
a334 1
        
d342 1
a342 1
        Pull    "R0" 
d565 4
a568 4
	
	[ true
	B	%FT22
	|
d574 1
a574 1
        ]
d591 6
a596 1

d601 1
d603 1
d631 1
d636 1
d638 1
a639 1

d642 1
a642 1
;
d647 36
a682 1
process_redrawable_window
d684 25
d713 1
d721 6
d737 1
a737 1
        BNE     check_null      
d747 4
d831 1
a831 1
        Debug   bpr,"Continuing braindead panic readraw on handle",handle
d841 1
d845 25
a869 1
; Move to next window in stack
d871 4
d882 1
d889 24
d919 3
d923 1
d935 1
a935 1
; Has the ticker gone off to see if we need to look at the 
d937 1
a937 1
; 
d1127 2
a1128 2
        Push    "r0"   
                
d1140 3
a1142 1
        BEQ     %FT92           
a1143 2
        Push    "R0-R7,handle" 
              
d1164 2
a1165 2
        CMP     r14,r3  
        Debug   bo,"iconbar handle , handle",r14,r3 
d1169 1
a1169 1
        Push    "R1-R4,R7"                 
d1178 1
a1178 1
        Abs     R14,r3 
d1188 1
a1188 1
        TST     r3,#if_text 
d1217 1
a1217 1
        BNE     %FT02 
d1219 1
a1219 1
        Debug   bo,"Sprite name copied"        
d1221 1
a1221 1
        BL      getnumber 
d1234 1
a1234 1
02                                    
d1255 1
a1255 1
        Pull    "r0-r7,handle"       
d1331 1
a1331 1
     
d1343 1
a1343 1
       
d1346 1
a1346 1
        BEQ     %FT01   
d1348 1
a1348 1
        BNE     entering                ; 
d1356 1
a1356 1
        B       ptrboth 
d1441 1
a1441 1
        DCD     2_100010000000  ;13 
d1460 1
a1460 1
;    
d1503 2
a1504 2
                
; R0,R1 => x,y mouse co-ordinates                
d1509 1
a1509 1
; R8 => old button state 
d1513 1
a1513 1
;                
d1522 1
a1522 1
        CMP     R0,#windowicon_workarea        
d1557 1
a1557 1
        STR     R7,mouseflags                       
d1825 1
a1825 1
                  
d1827 2
a1828 2
; R4 = icon handle                
        
d1834 2
a1835 2
        BL      getborder               ; decode to setup the border information           
;       
d1838 1
a1838 1
;  
d1842 1
a1842 1
       
d1850 1
a1850 1
        MOVEQ   R2,#0   
d1880 41
d1928 1
a1928 1
        BVS     trykeys
d1931 5
a1935 4
         CMP    R14,#0
         LDRLT  R14,menutaskhandle
         LDR    R14,[wsptr,R14]
         LDR    R14,[R14,#task_flagword]
d1940 5
d1947 1
a1947 1
;
d1957 1
a1957 1
        Task    R14,,"KeyPressed"       ; page in correct task      
d1961 11
d1979 1
d2025 117
d2241 1
a2241 1
                      
d2253 1
a2253 1
       
d2446 14
d2471 14
d2575 1
a2575 1
;                                     
d2578 1
a2578 1
        ADD     R14,handle,#w_bwax0     ; remember old position    
d2583 1
a2583 1
        
d2591 1
a2591 1
        SUB     cy0,cy1,y1             
d2599 6
d2607 1
a2607 1
              
d2609 2
a2610 2
        BGE     %FT01                   ; if not then don't bother faffing around  
        
d2614 1
a2614 1
                
d2618 1
a2618 1
        MOV     R1,#FileSwitchCMOS  
d2625 3
a2627 3
        TEQ     R1,#&FF                                              
        BNE     %FT01                   ; if it isn't then ignore the munging of the bits             
                      
d2630 1
a2630 1
        
d2633 2
a2634 2
        MOVGT   cy1,R14                   
        
d2648 1
a2648 1
        SUB     cy0,cy1,cy0             ; work out the area really shown        
d2657 2
a2658 2
        LDR     R2,mousebuttons         ; bhandle depends on adjust button   
        
d2671 1
a2671 1
        
d2680 6
d2687 2
a2688 1
        BIC     r3, x1, #3                      ; Align bhandle for comparisons.
d2703 2
a2704 2
        ADD     R14,userblk,#u_wax0      
        STMIA   R14,{cx0,cy0,cx1,cy1,x0,y0,x1}   
d2718 1
a2718 1
        LDR     R0,[handle,#w_taskhandle]       
d2727 2
a2728 2
        
        MOV     R0,#&79                 ; Scan keyboard for shift key 
d2732 2
a2733 2
        CMP     R1,#&FF 
        
d2735 3
a2737 3
        BNE     not_alt                          
        
                                        ; Shift-quit, send message_Iconize. 
d2763 1
a2763 1
        CMP     R14,R2                      
d2778 1
a2778 1
        BLT     %BT03     
d2789 1
a2789 1
 
d2792 2
a2793 2
 
not_alt 
d2795 1
a2795 1
;        LDR     R0,[handle,#w_taskhandle]       
d2811 1
a2811 1
02                     
d2827 1
a2827 1
05                   
d2970 1
a2970 1
                                                            
d3142 1
a3142 1
; will not have been updated, instead read from our workspace and 
d3152 2
a3153 2
        LDMEQIA R0,{R0,R1,R2,R3}      
        BEQ     %FT10              
d3158 1
a3158 1
        SWI     XOS_Mouse  
d3163 1
a3163 1
        
d3193 1
d3197 17
d3215 2
a3216 4
;
; look for a suitable window
;
        ADRL    R4,activewinds+lh_forwards-ll_forwards
d3223 3
d3227 1
d3230 8
a3237 1
;
d3240 1
a3240 1
;
d3247 5
a3251 3
;
; now see if any icons match up
;
d3266 1
d3268 22
d3332 4
a3335 1
;
d3337 1
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@a650 6
 [ Twitter
        BL      checktwitter
        LDRNE   r14, getrectflags
        ORRNE   r14, r14, #getrect_twitter
        STRNE   r14, getrectflags
 ]
a1741 41
 [ KeyboardMenus
        MOV     r6, #-1                 ; so we can tell later on if we read a key
        LDR     r4, menuSP
        CMP     r4, #0
        BLT     %FT00                   ; no menu open so don't grab special keys

        ADR     r5, menudata            ; if it's a dbox then don't grab keys
        LDR     r5, [r5, r4]
        TST     r5, #3
        BNE     %FT00

        ADR     r14, menuhandles        ; if menu has caret then don't grab keys
        LDR     r14, [r14, r4]
        LDR     r0, menucaretwindow
        TEQ     r0, r14
        BEQ     %FT00
        
        MOV     r0, #4                  ; allow us to read cursor keys
        MOV     r1, #1
        SWI     XOS_Byte
        MOV     r3, r1
        MOV     r0, #&81                ; INKEY(0)
        MOV     r1, #0
        MOV     r2, #0
        SWI     XOS_Byte
        MOV     r6, r1
        MOV     r7, r2
        MOV     r0, #4                  ; restore cursor key state
        MOV     r1, r3
        SWI     XOS_Byte
        CMP     r7, #&FF                ; was there a key?
        BEQ     nothing
        
        TEQ     r6, #13                 ; check for return and cursor keys
        TEQNE   r6, #136
        TEQNE   r6, #137
        TEQNE   r6, #138
        TEQNE   r6, #139
        BEQ     handlemenukey
 ]
00
d1749 1
a1749 1
        BVS     %BT00
d1752 4
a1755 5
        CMP     R14,#0
        LDRLT   R14,menutaskhandle

        LDR     R14,[wsptr,R14]
        LDR     R14,[R14,#task_flagword]
a1759 5
 [ KeyboardMenus
        CMP     r6, #0
        BLLT    inkey0                  ; if we don't have a key yet then get one (preserves flags)
        MOVLTS  r6, r1
 |
d1762 1
a1762 1
 ]
a1775 11

 [ KeyboardMenus
        CMP     r4, #0                  ; if no menu open then skip
        BLT     %FT02
        TST     r5, #3                  ; check for dialogue
        SUBNE   r0, r4, #4              ; if dialogue open then just remove it
        MOVEQ   r0, #-4                 ; otherwise remove whole menu tree
        CMP     r0, #0
        BLLT    menusdeleted            ; send Message_MenusDeleted if whole menu going (preserves r0)
        BL      closemenus
 |
a1782 1
 ]
a1827 16
 [ KeyboardMenus
; In:   r4 = menuSP
;       r5 -> menu data
;       r6 = key pressed
;
handlemenukey
        LDR     R14, menutaskhandle
        Task    R14,,"KeyPressed"       ; page in correct task

        LDR     r14, mousexpos
        STR     r14, lastxpos
        LDR     r14, mouseypos
        STR     r14, lastypos
        
        ADR     r14, menuselections
        LDR     r1, [r14, r4]           ; r1 = previous selection index
a1828 99
        TEQ     r6, #13
        BNE     trymenucursorkeys
        CMP     r1, #0                  ; handle return
        BLT     nothing                 ; do nothing if no selection
        STR     r4, whichmenu
        MOV     r2, #4                  ; fake SELECT mouse button
        B       gomenuselect

trymenucursorkeys
        TEQ     r6, #137                ; check for right (sub-menu)
        BNE     trymenuleft
        CMP     r1, #0                  ; handle right
        BLT     nothing
        ADD     r7, r1, r1, LSL #1      ; r7 = selected item * 3 (also used later)
        ADD     r6, r5, r7, LSL #3      ; r6 -> selected menu item
        LDR     r1, [r6, #mi_submenu]   ; r1 -> sub-menu data block
        CMP     r1, #0                  ; check for sub-menu/dbox
        BLE     nothing
        ADR     r14, menuhandles        ; get menu window handle
        LDR     handle, [r14, r4]
        BL      checkhandle
        BVS     nothing
        LDR     r2, reversedmenu
        CMP     r2, #"\"
        LDREQ   r2, [handle, #w_wax0]   ; get menu x
        LDRNE   r2, [handle, #w_wax1]
        LDR     r14, [handle, #w_icons]
        ADD     r14, r14, #i_bby1
        ADD     r7, r7, #1              ; r7 = middle icon
        LDR     r3, [r14, r7, ASL #i_shift]
        LDR     r14, [handle, #w_way1]
        ADD     r3, r3, r14             ; get menu y
        LDR     r14, [handle, #w_scy]
        SUB     r3, r3, r14             ; adjust for scrolling
 [ NCMenus
        ADD     r3, r3, #24             ; adjust for NCMenus border
 ]
        LDR     r14, [r6, #mi_mflags]
        TST     r14, #mif_warning
        BLNE    sendmenuwarning         ; preserves flags
        BLEQ    int_create_menu
        B       nothing

trymenuleft
        TEQ     r6, #136
        BLNE    trymenuupdown           ; preserves flags
        BNE     nothing
        SUBS    r0, r4, #4              ; handle left
        BLGE    closemenus
        B       nothing
        
trymenuupdown
; In:   r1 = current selected menu item
;       r4 = menuSP
;       r5 -> menu data
;       r6 = key pressed
; Out:  Could corrupt almost anything
;       Flags preserved
;
        Push    "lr"
        MOV     r7, #0                  ; determine how many items in menu
00
        ADD     r7, r7, #1
        LDR     r0, [r5], #mi_size
        TST     r0, #mif_lastone
        BEQ     %BT00

        MOV     r0, r1                  ; start with current menu item
trynextupdown
        TEQ     r6, #138                ; check for down
        BNE     trymenuupkey
        ADD     r0, r0, #1              ; handle down key
        CMP     r0, r7
        MOVGE   r0, #0                  ; wrap if necessary
        B       %FT10

trymenuupkey
        TEQ     r6, #139                ; check for up
        BNE     %FT20
        SUBS    r0, r0, #1              ; handle up key
        SUBLT   r0, r7, #1              ; wrap if necessary
10
        TEQ     r0, r1                  ; if all menu items grey then don't loop forever
        BEQ     %FT20

        ADR     r14, menuhandles
        LDR     handle, [r14, r4]       ; get menu window handle
        BL      checkhandle
        BVS     %FT20
        Push    "r6,r7"
        BL      menuhighlight
        Pull    "r6,r7"
        BVS     %FT20
        TEQ     r14, #0
        BEQ     trynextupdown           ; if item greyed out then try next
20
        Pull    "pc",,^
 ]
 
@


4.1.7.2
log
@Rectangle filters not called when caret moves.
Post-rectangle and post-icon filters added.
@
text
@d161 1
a161 1
;;
a175 2
	ASSERT	postrectfilter =rectanglefilter +8
	ASSERT	posticonfilter =postrectfilter +8
d180 1
a180 1

d185 1
a185 1

d190 2
a191 2

        ADRL    R14,prefilter
d207 1
a207 3
        & postrectfilter_default -filtertable
	& posticonfilter_default -filtertable
        & -1
d212 1
a212 3
rectanglefilter_default
postrectfilter_default
posticonfilter_default
d215 1
a215 1

d225 1
a225 1
        MOV     R2,R0
d228 1
a228 1
        CMP     R14,#-1
d232 1
a232 1

d237 2
a238 2
        EXITS

d248 1
a248 1
        SWI     XOS_ServiceCall
d296 1
a296 1

d334 1
a334 1

d342 1
a342 1
        Pull    "R0"
d565 1
a565 1

d667 1
a667 1
        BNE     check_null
d803 1
a803 1
; Has the ticker gone off to see if we need to look at the
d805 1
a805 1
;
d995 2
a996 2
        Push    "r0"

d1008 1
a1008 3
        BEQ     %FT92

        Push    "R0-R7,handle"
d1010 2
d1032 2
a1033 2
        CMP     r14,r3
        Debug   bo,"iconbar handle , handle",r14,r3
d1037 1
a1037 1
        Push    "R1-R4,R7"
d1046 1
a1046 1
        Abs     R14,r3
d1056 1
a1056 1
        TST     r3,#if_text
d1085 1
a1085 1
        BNE     %FT02
d1087 1
a1087 1
        Debug   bo,"Sprite name copied"
d1089 1
a1089 1
        BL      getnumber
d1102 1
a1102 1
02
d1123 1
a1123 1
        Pull    "r0-r7,handle"
d1199 1
a1199 1

d1211 1
a1211 1

d1214 1
a1214 1
        BEQ     %FT01
d1216 1
a1216 1
        BNE     entering                ;
d1224 1
a1224 1
        B       ptrboth
d1309 1
a1309 1
        DCD     2_100010000000  ;13
d1328 1
a1328 1
;
d1371 2
a1372 2

; R0,R1 => x,y mouse co-ordinates
d1377 1
a1377 1
; R8 => old button state
d1381 1
a1381 1
;
d1390 1
a1390 1
        CMP     R0,#windowicon_workarea
d1425 1
a1425 1
        STR     R7,mouseflags
d1693 1
a1693 1

d1695 2
a1696 2
; R4 = icon handle

d1702 2
a1703 2
        BL      getborder               ; decode to setup the border information
;
d1706 1
a1706 1
;
d1710 1
a1710 1

d1718 1
a1718 1
        MOVEQ   R2,#0
d1764 1
a1764 1

d1780 1
a1780 1

d1825 1
a1825 1
        Task    R14,,"KeyPressed"       ; page in correct task
d1906 1
a1906 1

d1960 1
a1960 1

d2008 1
a2008 1

d2107 1
a2107 1

d2119 1
a2119 1

d2413 1
a2413 1
;
d2416 1
a2416 1
        ADD     R14,handle,#w_bwax0     ; remember old position
d2421 1
a2421 1

d2429 1
a2429 1
        SUB     cy0,cy1,y1
d2439 1
a2439 1

d2441 2
a2442 2
        BGE     %FT01                   ; if not then don't bother faffing around

d2446 1
a2446 1

d2450 1
a2450 1
        MOV     R1,#FileSwitchCMOS
d2457 3
a2459 3
        TEQ     R1,#&FF
        BNE     %FT01                   ; if it isn't then ignore the munging of the bits

d2462 1
a2462 1

d2465 2
a2466 2
        MOVGT   cy1,R14

d2480 1
a2480 1
        SUB     cy0,cy1,cy0             ; work out the area really shown
d2489 2
a2490 2
        LDR     R2,mousebuttons         ; bhandle depends on adjust button

d2503 1
a2503 1

d2528 2
a2529 2
        ADD     R14,userblk,#u_wax0
        STMIA   R14,{cx0,cy0,cx1,cy1,x0,y0,x1}
d2543 1
a2543 1
        LDR     R0,[handle,#w_taskhandle]
d2552 2
a2553 2

        MOV     R0,#&79                 ; Scan keyboard for shift key
d2557 2
a2558 2
        CMP     R1,#&FF

d2560 3
a2562 3
        BNE     not_alt

                                        ; Shift-quit, send message_Iconize.
d2588 1
a2588 1
        CMP     R14,R2
d2603 1
a2603 1
        BLT     %BT03
d2614 1
a2614 1

d2617 2
a2618 2

not_alt
d2620 1
a2620 1
;        LDR     R0,[handle,#w_taskhandle]
d2636 1
a2636 1
02
d2652 1
a2652 1
05
d2795 1
a2795 1

d2967 1
a2967 1
; will not have been updated, instead read from our workspace and
d2977 2
a2978 2
        LDMEQIA R0,{R0,R1,R2,R3}
        BEQ     %FT10
d2983 1
a2983 1
        SWI     XOS_Mouse
d2988 1
a2988 1

@


4.1.7.2.2.1
log
@AMBControl task switching merged from RO_3_70 branch.
PlotSpritesFromPalette and TwitterOnlyMenus options added.
ChildWindows merged in.
@
text
@d572 3
a574 3
      [ true
        B       %FT22
      |
d580 1
a580 1
      ]
d597 1
a597 6
;
; flush pending opens - make sure this is done BEFORE redraw stuff
;
      [ ChildWindows
        BL      int_flush_opens         ; may cause a braindead panic redraw
      ]
a601 1
      [ :LNOT: ChildWindows             ; this is pointless - can't get an error from checkredrawhandle!
a602 1
      ]
a629 1

a633 1

d635 1
a636 1
        Push    "R2"
d639 1
a639 1

d644 1
a644 57
;
; Right - windowrects is the intersection of this window's outer portion with the invalid list
; We need to check whether any of the window's children should be redrawn first
;

process_redrawable_window ROUT

        Debug   child,"process_redrawable_window",handle

      [ ChildWindows
        LDR     R2,[handle,#w_children + lh_forwards]           ; start from the top

01      LDR     R14,[R2,#ll_forwards]
        CMP     R14,#nullptr
        BEQ     %FT04

        Push    "R2"

        LDR     R14,[R2,#w_flags - w_active_link]
        TST     R14,#wf_inborder
        ADDNE   R14,handle,#w_x0                ; clip to outer box if it can go in the border
        ADDEQ   R14,handle,#w_wax0              ; clip to work area otherwise
        LDMIA   R14,{x0,y0,x1,y1}

        ADD     R14,R2,#w_x0 - w_active_link
        LDMIA   R14,{cx0,cy0,cx1,cy1}

        max     cx0,x0                          ; intersect child's outer box with parent's work area or outline
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1

        Debug   child,"process_redrawable: child rectangle",cx0,cy0,cx1,cy1
        MOV     R0,#windowrects
        MOV     R1,#torects
        BL      intrect                         ; see if this intersects with the invalid list

        Pull    "R2"

        LDR     R14,rlinks+torects
        CMP     R14,#nullptr
        BNE     %FT03

02      LDR     R2,[R2,#ll_forwards]
        B       %BT01

; Right - redraw the child first, rather than the parent

03      MOV     R0,#windowrects
        BL      assign_set                      ; calls SetRectPtrs internally
        SUB     handle,R2,#w_active_link
      [ debug
        LDR     R14,rlinks + windowrects
        Debug   child,"Detected redraw for child window,rects",handle,R14
      ]
        B       process_redrawable_window       ; in case of nested child windows
04
a645 4
process_redrawable_window_actually ROUT

        Debug   child,"Actually redraw window",handle
      ]
a649 1
        Debug   child,"window flags are",R14
a682 4
      [ debug
        LDR     R14,rlinks + windowrects
        Debug   child,"Returning Redraw_Window_Request for window,rects",#redrawhandle,R14
      ]
d763 1
a763 1
        Debug   bpr,"Continuing braindead panic redraw on handle",handle
a772 1
        Debug   bpr,"handle, flags are",handle,R14
d776 1
a776 4
; Move BPR_indication to next window in stack (must deal with child window stacks as well)

      [ ChildWindows
        Push    "handle"
a777 25
        LDR     R0,[handle,#w_children + lh_backwards]          ; go for backmost child window first
        LDR     R14,[R0,#ll_backwards]
        CMP     R14,#nullptr
        BNE     %FT02

01      LDR     R0,[handle,#w_active_link + ll_backwards]       ; then go for next sibling
        Debug   bpr,"Next sibling",handle,R0
        LDR     R14,[R0,#ll_backwards]
        CMP     R14,#nullptr
        BNE     %FT02

        LDR     handle,[handle,#w_parent]                       ; else go for parent's next sibling, etc.
        Debug   bpr,"Move up to parent",handle
        CMP     handle,#nullptr
        BNE     %BT01

02      MOVEQ   R0,#BPR_notatall
        SUBNE   R0,R0,#w_active_link
        Rel     R0,R0,NE
        STR     R0,BPR_indication

        Pull    "handle"

        Debug   bpr,"Braindead redraw: this,next",handle,R0
      |
a784 1
      ]
a790 24

; If this is a child window, clip to parent's work area/outline

      [ ChildWindows
        MOV     R1,handle
        B       %FT12

11      TST     R0,#wf_inborder
        ADDNE   R14,R1,#w_x0            ; clip to outer box if allowed to overlap border
        ADDEQ   R14,R1,#w_wax0          ; clip to parent's work area otherwise
        LDMIA   R14,{x0,y0,x1,y1}
        max     cx0,x0
        max     cy0,y0
        min     cx1,x1
        min     cy1,y1

12      LDR     R0,[R1,#w_flags]
        LDR     R1,[R1,#w_parent]
        CMP     R1,#nullptr
        BNE     %BT11
      ]

; make one-rectangle list of the window's outer box (clipped to its parent's work area)

a796 3
      [ ChildWindows
        B       process_redrawable_window_actually      ; DON'T consider the children this time
      |
a797 1
      ]
a1982 2
        CMP     r1, #-1
        SUBEQ   r1, r7, #1
a2317 14
      [ ChildWindows
        LDR     R14,up_height           ; if scrollbar is small, only the arrows are shown (scaled down)
        LDR     R5,down_height
        ADD     R5,R14,R5
        SUB     R14,y1,y0
        CMP     R5,R14
        BLE     %FT10

        ADD     R14,y0,R14,LSR #1
        CMP     R1,R14
        ADDLT   R4,R4,#2                ; down arrow
        B       %BT03
10
      ]
a2328 14
      [ ChildWindows
        LDR     R14,left_width          ; if scrollbar is small, only the arrows are shown (scaled down)
        LDR     R5,right_width
        ADD     R5,R14,R5
        SUB     R14,x1,x0
        CMP     R5,R14
        BLE     %FT11

        ADD     R14,x0,R14,LSR #1
        CMP     R0,R14
        ADDGT   R4,R4,#2                ; right arrow
        B       %BT03
11
      ]
a2442 6
      [ ChildWindows
        LDR     R14,[handle,#w_parent]
        CMP     R14,#nullptr
        BNE     %FT01                   ; this stuff only applies to top-level windows
      ]

a2517 6
      [ ChildWindows
        LDR     r14, [handle, #w_parent]            ; depending on whether this window is at the top-level,
        CMP     r14, #nullptr
        LDREQ   r2, activewinds+lh_forwards         ; scan the list of topmost windows
        LDRNE   r2, [r14, #w_children+lh_forwards]  ; or the list of siblings
      |
d2519 1
a2519 2
      ]
        BIC     r3, x1, #3                      ; Align bhandle for comparisons (should really use the Abs macro)
a3023 1
;          If clicked in work area, [mousexyrel] = relative coordinates
d3027 4
a3030 1

a3031 18
      [ ChildWindows
        MOV     R3,#0                   ; ignore wf_inborder bit for top-level windows
      ]

; In:   R4 -> list head ( activewinds or [handle,#w_children] )
;       R3 = wf_inborder if we're to search only windows which have this bit
;       R3 = 0 if we're to search all windows in the list

int_get_pointer_info_R4                 ; for ChildWindows

      [ ChildWindows
        Push    "userblk,LR"

        MOV     userblk,R3              ; userblk = wf_inborder or 0
      |
        Push    "LR"
      ]

a3037 3
      [ ChildWindows
        Pull    "userblk,PC",EQ
      |
a3038 1
      ]
d3041 1
a3041 8

      [ ChildWindows
        LDR     R14,[handle,#w_flags]
        AND     R14,R14,userblk
        TEQ     R14,userblk                     ; ignore window if userblk = wf_inborder and bit not
        BNE     findwlp
      ]

d3044 1
a3044 1

d3051 3
a3053 5

        Debug   child,"Click within outer box of",handle

; decide whether the click is inside or outside the work area

a3067 1
      [ :LNOT: ChildWindows
a3068 22
      ]

; right - a click inside the work area
; first check to see if it's inside any of the window's children

      [ ChildWindows
        Push    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk"
        MOVLT   R3,#wf_inborder                 ; click was in border area (so only scan children that overlap the border)
        MOVGE   R3,#0                           ; click was in work area (scan all children)
        MOV     userblk,R3
        ADD     R4,handle,#w_children + lh_forwards - ll_forwards
        BL      int_get_pointer_info_R4         ; scan child window stack for a hit
        CMP     R3,#nullptr
        ADDNE   SP,SP,#10*4
        STRNE   R3,[SP,#3*4]
        BNE     exitp4                          ; click found in one of the children
        TEQ     userblk,#0
        Pull    "cx0,cy0,cx1,cy1,x0,y0,x1,y1,handle,userblk"
        BNE     noficon2                        ; click was in border area
      ]
;
; now scan the icon list for a hit (starting at the frontmost, ie. the highest-numbered)
d3111 1
a3111 4
exitp4                                  ; for ChildWindows
      [ ChildWindows
        Pull    "R0-R3,R5-R9,userblk,PC" ; restore mouse coords etc.
      |
a3112 1
      ]
@


4.1.7.2.2.2
log
@Some obsolete assembly switches removed (chwidth in particular).
Behaviour of scrollbars with large extents improved.
Window tools now press in correctly after a Service_InvalidateCache.
Plotting of solid window tools optimised - background isn't drawn in.
Auto-fronting iconbar added.
Various optimisations, such as multiple OS_WriteI -> OS_WriteN.
HiResMono flag no longer relied on.
"22" tool sprites now chosen for 1x2,2x1 or 1x1 screen modes.
Buttons restored correctly after "application may have gone wrong" error box.
Positioning of outline font text shifted right 2 OS units to match system font.
Parameter of L validation string implemented.
Positioning of outline font "L" (multiple line) icons fixed.
Shift-toggle size behaviour fixed.
Wimp_TransferBlock above 2Gb should be fixed.
Post-rectangle filters implemented.
FPE4 flag added (to use LFM/SFM instead of LDFE/STFE).
Plotting of non-pixel aligned 3d icons fixed.
3d borders now solid in EX0/EY0 modes.
@
text
@d374 1
a374 1
        TEQNE   R3,#0
d771 1
a771 1
        MOV     R0,#4
d814 1
a814 1
        MOV     R0,#4
a952 4

      [ PoppingIconBar
	BL	checkiconbarpop
      ]
d997 1
a997 1
        TEQ     R14,#drag_scrollboth    ; use vscroll bit of sysflags for this
a1113 92
	[ PoppingIconBar
	; Note - need to sort out Service_MouseTrap for all this!
	ROUT
checkiconbarpop
	Push	"R0,LR"
	LDR	R14,singletaskhandle
	CMP	R14,#0
	Pull	"R0,PC",GT		; old-style tasks don't have an icon bar!
	LDR	R14,iconbar_pop_state
	ADD	PC,PC,R14,LSL #2
	NOP
	B	%F10
	B	%F20
	B	%F30
; Icon bar is held by menu
	Pull	"R0,PC"

; Icon bar is at back
10	TEQ	R1,#0		; are we at the bottom of the screen?
	Pull	"R0,PC",NE

	; Don't bring to front if dragging a window
	LDR	R14,dragtype
	CMP	R14,#drag_posn
	BLT	%FT11
	CMP	R14,#drag_vscroll
	Pull	"R0,PC",LE
	TEQ	R14,#drag_scrollboth
	Pull	"R0,PC",EQ

11	SWI	XOS_ReadMonotonicTime
	Pull	"R0,PC",VS
	[ false
	LDR	R14,automenu_timelimit
	ADD	R0,R0,R14
	|
	ADD	R0,R0,#pop_DelayTime
	]
	STR	R0,iconbar_pop_time
	MOV	R0,#pop_Delaying
	STR	R0,iconbar_pop_state
	Pull	"R0,PC"

; Icon bar is delaying
20	TEQ	R1,#0
	MOVNE	R14,#pop_Back
	STRNE	R14,iconbar_pop_state
	Pull	"R0,PC",NE
	SWI	XOS_ReadMonotonicTime
	LDR	R14,iconbar_pop_time
	CMP	R0,R14
	Pull	"R0,PC",LO
	MOV	R14,#pop_Front
	STR	R14,iconbar_pop_state
	MOV	R14,#0
	B	%FT50

; Icon bar is at front
30	LDR	R14,iconbarheight
	CMP	R1,R14
	Pull	"R0,PC",LE
	MOV	R14,#pop_Back
	STR	R14,iconbar_pop_state
	MOV	R14,#1

50
	MOV	R0,R14
	LDR	handle,iconbarhandle
	CMP	handle,#0
	Pull	"R0,PC",LE

	Push	"R1-R11"
	BL	checkhandle             ; handle -> window block
	BLVC	calc_w_status           ; set up flag word
	LDRVC	R14,[handle,#w_flags]
	TEQ	R0,#0
	BICEQ	R14,R14,#wf_backwindow
	ORRNE	R14,R14,#wf_backwindow
	STRVC	R14,[handle,#w_flags]
	ADDVC	R14,handle,#w_wax0
	LDMVCIA	R14,{R0-R3,R4,R5}
	MOVEQ	R6,#-1
	MOVNE	R6,#-2
	Push	"R0-R6"
	LDRVC	R14,iconbarhandle
	Push	"R14"
	MOVVC	userblk,sp
	BLVC	int_open_window
	ADD	sp,sp,#8*4
	Pull	"R1-R11"
	Pull	"R0,PC"
	]
a1279 1
 [ false
a1309 77
  |
        LDR     R14,iconbarhandle
        CMP     R14,#0
        BLE     %FT01                   ; no iconbar
        TEQ     R3,R14
	MOVNE	R14,#0
	STRNE	R14,iconbar_scroll_start_time
        BNE     %FT01                   ; this isn't it!
;
        LDR     R14,scrx0
	[ true
        ADD     R14,R14,#iconbarsepgap
        CMP     R0,R14
        MOVLT   R8,#-iconbar_scroll_speed * 100 - 1                ; scroll left
        BLT     %FT02
	|
	ADD	R14,R14,#iconbar_scroll_speed
	SUBS	R8,R0,R14
	BLT	%FT02
	]
        LDR     R14,scrx1
	[ true
        SUB     R14,R14,#iconbarsepgap
        CMP     R0,R14
	MOVLE	R14,#0
	STRLE	R14,iconbar_scroll_start_time
        BLE     %FT01
        MOVGT   R8,#iconbar_scroll_speed * 100                 ; scroll right
	|
	SUB	R14,R14,#iconbar_scroll_speed
	SUBS	R8,R0,R14
	MOVLE	R14,#0
	STRLE	R14,iconbar_scroll_start_time
	BLE	%FT01
	]
02
        Push    "R0-R8,handle,userblk"
        Abs     handle,R3
        BL      calc_w_status           ; ensure bhandle is correct
        ADD     R14,handle,#w_wax0
        LDMIA   R14,{R1-R7}             ; x0,y0,x1,y1,scx,scy,bhandle
        LDR     R8,[sp,#8*4]

	SWI	XOS_ReadMonotonicTime
	LDR	R14,iconbar_scroll_start_time
	TEQ	R14,#0
	STREQ	R0,iconbar_scroll_start_time
	STREQ	R5,iconbar_scroll_start_scx
	BEQ	%FT04
	; The following formula gives speed = iconbar_scroll_speed+iconbar_scroll_accel * time
	Push	"R2"
	LDR	R5,iconbar_scroll_start_scx
	LDR	R2,iconbar_scroll_start_time
	SUB	R2,R0,R2		; R2=time since scroll start (in centi-seconds)
	[ iconbar_scroll_accel = 1
	CMP	R8,#0
	ADDGT	R8,R8,R2
	SUBLT	R8,R8,R2		; R8=(+/-)(speed + accel*time)
	|
	MOV	LR,#iconbar_scroll_accel
	MUL	LR,R2,LR		; LR=accel * time
	CMP	R8,#0
	ADDGT	R8,R8,LR
	SUBLT	R8,R8,LR		; R8=(+/-)(speed + accel*time)
	]
	MUL	R8,R2,R8		; R8=(+/-)(speed + accel*time) * time
	ADD	R5,R5,R8,ASR #6		; R5+=(+/-)(speed + accel*time) * time/128 (approximation to 100)
	Pull	"R2"

        LDR     R0,iconbarhandle
        Push    "R0,R1-R7"              ; first word is window handle
        MOV     userblk,sp
        BL      int_open_window
        ADD     sp,sp,#4*8              ; handle,x0,y0,x1,y1,scx,scy,bhandle
04
        Pull    "R0-R8,handle,userblk"
  ]
a1829 3
	TST	R2,#button_middle	; ignore menu clicks for slabbing
	BNE	%FT10

a1843 1
	BNE	%FT03
d1845 3
a1847 16
	LDR	R14,border_windowselected    ; Make sure previous selected icon
	CMP	R14,#nullptr                 ; is unslabbed
	BLE	%F1
	TEQ	R14,handle
	LDR	R0,border_iconselected
	CMP	R0,#nullptr
	BLE	%F1
	TEQ	R0,R4
	TEQEQ	R14,handle
	BEQ	%F2
	Push	"handle"
	MOV	handle,R14
	MOV	R1,#0
	MOV	R2,#is_inverted
	BL	int_set_icon_state
	Pull	"handle"
d1849 3
a1851 6
1       STR     handle,border_windowselected
        STR     R4,border_iconselected
;
2       LDRB    R0,autorepeating
        CMP     R0,#0
3       MOVNE   R0,#0
a1852 1
	BNE	%F5
d1854 4
a1857 4
        MOV     R0,R4                   ; R1 => icon handle
        MOV     R1,#is_inverted
        MOV     R2,#0
        BL      int_set_icon_state      ; and then select the icon
a1858 1
5
d2423 1
a2423 1
05
d2603 1
a2603 1
        Push    "R0-R2,R4,R6"
d2611 2
a2612 6
	LDR	R4,iconbarheight
	SUB	R4,R4,#8;-40
	LDR	R14,[handle,#w_flags]
	TSTS	R14,#wf_icon7
        LDRNE   R14,hscroll_height
        ADDNE   R4,R4,R14               ; area not to be obscured
d2614 1
a2614 1
        SUBS    R6,cy0,R4               ; does the bottom of the window obscure the icon bar?
d2635 1
a2635 1
        SUB     cy1,cy1,R6              ; setup the new co-ordinates for bottom & top Y's
d2637 3
a2639 13
	LDR	R6,scry1
	LDR	R14,title_height
	SUB	R6,R6,R14
	LDR	R14,iconbarheight
	SUB	R14,R14,#8
	SUB	R0,R6,R14
	LDR	R14,[handle,#w_flags]
	TSTS	R14,#wf_icon7
	LDRNE	R14,hscroll_height
	SUBNE	R0,R0,R14		; R0 = max window height that can fit on screen
	CMPS	y1,R0
	MOVGT	cy1,R6		        ; window won't fit at maximum extent, so carefully trim
	SUBGT	y1,cy1,cy0
d2647 1
a2647 1
        Pull    "R0-R2,R4,R6"
d2734 1
a2734 1
        MOV     R0,#121                 ; Scan keyboard for shift key
d2744 1
a2744 1
20      MOV     R14,#ms_data+8+20       ; size of block (Window,Task,20 byte from title ).
a2834 3
	[ BounceClose
	STR	R2,mousebuttons		; Horrible hack so apps can tell that adjust was pressed
	]
@


4.1.7.2.2.3
log
@Iconise button added.
@
text
@a2635 3
      [ IconiseButton
        ADDGT	R4,R4,#3		; and skip -13 (which is the border)
      ]
d2701 1
a2701 8
        BLO     %BT01
      [ IconiseButton
	BHI	%FT04
	LDR	R2,[handle,#w_flags]
	TST	R2,#wf_icon2
	BNE	%BT05
04
      ]
d2725 1
a2725 4
	[ IconiseButton
	DCD	-1
	DCD	ibt_clickrelease :SHL: ib_buttontype	    ; iconise
	]
a2746 4
	[ IconiseButton
	MOV	PC,#0
	B	wicon_iconise
	]
a2928 6

      [ IconiseButton
wicon_iconise
	Push	"r0-r4"
	B	%FT20
      ]
@


4.1.7.2.2.4
log
@Corruption of userblk in oldvisible_knockout (causing data aborts when
input focus changes) fixed.
Care taken to ensure that characters (eg VDU 26) issued by the Wimp don't
trigger a command window.
@
text
@d1703 1
a1703 1
        BLE     %FT01                           ; if -VE then ignore its not worth the hassle
a1941 1

@


4.1.7.2.2.5
log
@Added support for multiple options files (RO310, RO350, RO360, RO370, RCA,
Ursula).
Removed run-time MedusaOS checks.
Enabled correct build for RISC OS 3.1 machines.
Ensured that "freepoolinuse" is cleared before OS_ChangeDynamicArea
is intercepted.
Increased maxrects to 256.
Gave copy filter window handle in R10 (if ChildWindows).
Corrected a few border problems when no toolsprites.
Made toolsprites press in immediately - in particular close and toggle can
now be highlighted.
BounceClose flag no affects all of back,close,iconise and toggle.
Made "L" validation string parsing check manually for presence of a number,
to prevent error from OS_ReadUnsigned trashing MessageTrans' error buffers.
Allow error box buttons to stretch to fit text.
Fixed bug: floating point registers were not being saved unless on a portable.
Integrated some of the Wimp_TransferBlock fixes into Wimp08 from Wimp08s.
@
text
@a142 1
      [ Medusa
a146 1
      ]
d343 1
d345 2
a346 1
        LDR     R0,orig_applicationspacesize
d2720 1
d2722 1
a2722 2
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; back
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; quit
d2724 1
a2724 2
        DCD     ibt_click        :SHL: ib_buttontype        ; back
        DCD     ibt_click        :SHL: ib_buttontype
a2726 3
	[ BounceClose
        DCD     ibt_clickrelease :SHL: ib_buttontype        ; toggle
	|
a2727 1
	]
a2737 1
	[ BounceClose
a2738 3
	|
	DCD	ibt_click        :SHL: ib_buttontype	    ; iconise
	]
@


4.1.7.3
log
@Applied keyboard menu bug fix (3.88).
@
text
@a1982 2
        CMP     r1, #-1
        SUBEQ   r1, r7, #1
@


4.1.7.4
log
@   When turning the pointer off before Wimp_Report, save the state and
set it back to that state afterwards.
   Allow Wimp_GetPointerInfo, Wimp_GetWindowInfo, Wimp_GetWindowState outside
a task: needed to make IconHigh work in a ReportError box which has itself been
invoked from outside a task.
@
text
@d2920 6
a2925 6

	LDR     R14,singletaskhandle            ; if single-tasking,
	RSBS    R14,R14,#0
	CMPLT   R4,#nullptr
	MOVLT   R4,#nullptr                     ; don't confuse punter!

@


4.1.5.1
log
@Import from SrcFiler
@
text
@a650 6
 [ Twitter
        BL      checktwitter
        LDRNE   r14, getrectflags
        ORRNE   r14, r14, #getrect_twitter
        STRNE   r14, getrectflags
 ]
a1741 41
 [ KeyboardMenus
        MOV     r6, #-1                 ; so we can tell later on if we read a key
        LDR     r4, menuSP
        CMP     r4, #0
        BLT     %FT00                   ; no menu open so don't grab special keys

        ADR     r5, menudata            ; if it's a dbox then don't grab keys
        LDR     r5, [r5, r4]
        TST     r5, #3
        BNE     %FT00

        ADR     r14, menuhandles        ; if menu has caret then don't grab keys
        LDR     r14, [r14, r4]
        LDR     r0, menucaretwindow
        TEQ     r0, r14
        BEQ     %FT00
        
        MOV     r0, #4                  ; allow us to read cursor keys
        MOV     r1, #1
        SWI     XOS_Byte
        MOV     r3, r1
        MOV     r0, #&81                ; INKEY(0)
        MOV     r1, #0
        MOV     r2, #0
        SWI     XOS_Byte
        MOV     r6, r1
        MOV     r7, r2
        MOV     r0, #4                  ; restore cursor key state
        MOV     r1, r3
        SWI     XOS_Byte
        CMP     r7, #&FF                ; was there a key?
        BEQ     nothing
        
        TEQ     r6, #13                 ; check for return and cursor keys
        TEQNE   r6, #136
        TEQNE   r6, #137
        TEQNE   r6, #138
        TEQNE   r6, #139
        BEQ     handlemenukey
 ]
00
d1749 1
a1749 1
        BVS     %BT00
d1752 4
a1755 5
        CMP     R14,#0
        LDRLT   R14,menutaskhandle

        LDR     R14,[wsptr,R14]
        LDR     R14,[R14,#task_flagword]
a1759 5
 [ KeyboardMenus
        CMP     r6, #0
        BLLT    inkey0                  ; if we don't have a key yet then get one (preserves flags)
        MOVLTS  r6, r1
 |
d1762 1
a1762 1
 ]
a1775 11

 [ KeyboardMenus
        CMP     r4, #0                  ; if no menu open then skip
        BLT     %FT02
        TST     r5, #3                  ; check for dialogue
        SUBNE   r0, r4, #4              ; if dialogue open then just remove it
        MOVEQ   r0, #-4                 ; otherwise remove whole menu tree
        CMP     r0, #0
        BLLT    menusdeleted            ; send Message_MenusDeleted if whole menu going (preserves r0)
        BL      closemenus
 |
a1782 1
 ]
a1827 16
 [ KeyboardMenus
; In:   r4 = menuSP
;       r5 -> menu data
;       r6 = key pressed
;
handlemenukey
        LDR     R14, menutaskhandle
        Task    R14,,"KeyPressed"       ; page in correct task

        LDR     r14, mousexpos
        STR     r14, lastxpos
        LDR     r14, mouseypos
        STR     r14, lastypos
        
        ADR     r14, menuselections
        LDR     r1, [r14, r4]           ; r1 = previous selection index
a1828 99
        TEQ     r6, #13
        BNE     trymenucursorkeys
        CMP     r1, #0                  ; handle return
        BLT     nothing                 ; do nothing if no selection
        STR     r4, whichmenu
        MOV     r2, #4                  ; fake SELECT mouse button
        B       gomenuselect

trymenucursorkeys
        TEQ     r6, #137                ; check for right (sub-menu)
        BNE     trymenuleft
        CMP     r1, #0                  ; handle right
        BLT     nothing
        ADD     r7, r1, r1, LSL #1      ; r7 = selected item * 3 (also used later)
        ADD     r6, r5, r7, LSL #3      ; r6 -> selected menu item
        LDR     r1, [r6, #mi_submenu]   ; r1 -> sub-menu data block
        CMP     r1, #0                  ; check for sub-menu/dbox
        BLE     nothing
        ADR     r14, menuhandles        ; get menu window handle
        LDR     handle, [r14, r4]
        BL      checkhandle
        BVS     nothing
        LDR     r2, reversedmenu
        CMP     r2, #"\"
        LDREQ   r2, [handle, #w_wax0]   ; get menu x
        LDRNE   r2, [handle, #w_wax1]
        LDR     r14, [handle, #w_icons]
        ADD     r14, r14, #i_bby1
        ADD     r7, r7, #1              ; r7 = middle icon
        LDR     r3, [r14, r7, ASL #i_shift]
        LDR     r14, [handle, #w_way1]
        ADD     r3, r3, r14             ; get menu y
        LDR     r14, [handle, #w_scy]
        SUB     r3, r3, r14             ; adjust for scrolling
 [ NCMenus
        ADD     r3, r3, #24             ; adjust for NCMenus border
 ]
        LDR     r14, [r6, #mi_mflags]
        TST     r14, #mif_warning
        BLNE    sendmenuwarning         ; preserves flags
        BLEQ    int_create_menu
        B       nothing

trymenuleft
        TEQ     r6, #136
        BLNE    trymenuupdown           ; preserves flags
        BNE     nothing
        SUBS    r0, r4, #4              ; handle left
        BLGE    closemenus
        B       nothing
        
trymenuupdown
; In:   r1 = current selected menu item
;       r4 = menuSP
;       r5 -> menu data
;       r6 = key pressed
; Out:  Could corrupt almost anything
;       Flags preserved
;
        Push    "lr"
        MOV     r7, #0                  ; determine how many items in menu
00
        ADD     r7, r7, #1
        LDR     r0, [r5], #mi_size
        TST     r0, #mif_lastone
        BEQ     %BT00

        MOV     r0, r1                  ; start with current menu item
trynextupdown
        TEQ     r6, #138                ; check for down
        BNE     trymenuupkey
        ADD     r0, r0, #1              ; handle down key
        CMP     r0, r7
        MOVGE   r0, #0                  ; wrap if necessary
        B       %FT10

trymenuupkey
        TEQ     r6, #139                ; check for up
        BNE     %FT20
        SUBS    r0, r0, #1              ; handle up key
        SUBLT   r0, r7, #1              ; wrap if necessary
10
        TEQ     r0, r1                  ; if all menu items grey then don't loop forever
        BEQ     %FT20

        ADR     r14, menuhandles
        LDR     handle, [r14, r4]       ; get menu window handle
        BL      checkhandle
        BVS     %FT20
        Push    "r6,r7"
        BL      menuhighlight
        Pull    "r6,r7"
        BVS     %FT20
        TEQ     r14, #0
        BEQ     trynextupdown           ; if item greyed out then try next
20
        Pull    "pc",,^
 ]
 
@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.6;
access;
symbols
	Wimp-5_62:4.6
	Wimp-5_61:4.6
	Wimp-5_60:4.6
	Wimp-5_59:4.6
	Wimp-5_58:4.6
	Wimp-5_57:4.6
	Wimp-5_56:4.6
	Wimp-5_55:4.6
	Wimp-5_54:4.6
	Wimp-5_53:4.6
	Wimp-5_52:4.6
	Wimp-5_51:4.6
	Wimp-5_50:4.6
	Wimp-5_49:4.6
	Wimp-5_48:4.6
	Wimp-5_47-file1ad:4.6
	Wimp-5_47:4.6
	Wimp-5_46:4.6
	Wimp-5_45:4.6
	Wimp-5_44:4.6
	Wimp-5_43:4.6
	Wimp-5_42:4.6
	Wimp-5_41:4.6
	Wimp-5_40:4.6
	Wimp-5_39:4.6
	Wimp-5_38:4.6
	Wimp-5_37:4.6
	Wimp-5_36:4.6
	Wimp-5_35:4.6
	Wimp-5_34:4.6
	Wimp-5_33:4.6
	Wimp-5_32:4.6
	Wimp-5_31:4.6
	Wimp-5_30:4.6
	Wimp-530-pre4:4.6
	Wimp-5_30-pre3:4.6
	Wimp-5_30-pre2:4.6
	Wimp-5_30-pre1:4.6
	Wimp-5_29:4.6
	Wimp-5_28:4.6
	Wimp-5_27:4.6
	Wimp-5_26:4.6
	Wimp-5_25:4.6
	Wimp-5_24:4.6
	Wimp-5_23:4.5
	Wimp-5_22:4.5
	Wimp-5_21:4.5
	Wimp-5_20:4.5
	Wimp-5_19:4.5
	Wimp-5_18:4.5
	Wimp-5_17:4.5
	Wimp-5_16:4.5
	Wimp-5_15:4.5
	Wimp-5_14:4.5
	Wimp-5_13:4.5
	Wimp-5_12:4.5
	Wimp-5_11:4.5
	Wimp-5_10:4.5
	Wimp-5_09:4.5
	Wimp-5_08:4.5
	Wimp-5_07:4.5
	Wimp-5_06:4.5
	Wimp-5_05:4.5
	Wimp-5_04:4.5
	Wimp-5_03:4.5
	Wimp-5_02:4.5
	Wimp-5_01:4.5
	Wimp-4_66-4_77_2_1:4.4
	bavison_Threads_dev:4.4.0.2
	bavison_Threads_dev_bp:4.4
	Wimp-5_00:4.5
	Wimp-4_100:4.5
	Wimp-4_99:4.5
	Wimp-4_98:4.5
	Wimp-4_97:4.5
	Wimp-4_96:4.5
	Wimp-4_95:4.5
	Wimp-4_94:4.5
	RO_5_07:4.5
	Wimp-4_93:4.5
	Wimp-4_92:4.5
	Wimp-4_91:4.5
	Wimp-4_90:4.5
	Wimp-4_89:4.5
	Wimp-4_88:4.5
	Wimp-4_87:4.5
	Wimp-4_86:4.5
	Wimp-4_85:4.5
	Wimp-4_84:4.5
	Wimp-4_83:4.5
	Wimp-4_82:4.5
	Wimp-4_81:4.5
	Wimp-4_80:4.5
	Wimp-4_79:4.5
	Wimp-4_78:4.5
	Wimp-4_77:4.5
	Wimp-4_76:4.5
	Wimp-4_75:4.4
	Wimp-4_74:4.4
	Wimp-4_73:4.4
	Wimp-4_72:4.4
	Wimp-4_71:4.4
	Wimp-4_70:4.4
	Wimp-4_69:4.4
	Wimp-4_68:4.4
	Wimp-4_67:4.4
	Wimp-4_66:4.4
	Wimp-4_65:4.4
	Wimp-4_64:4.4
	Wimp-4_63:4.4
	Wimp-4_62:4.4
	Wimp-4_61:4.4
	Wimp-4_60:4.4
	Wimp-4_59:4.4
	Wimp-4_58:4.4
	Wimp-4_36-4_46_2_6:4.3
	Wimp-4_57:4.4
	Alpnet_approved:4.3
	Wimp-4_36-4_46_2_5:4.3
	Wimp-4_56:4.4
	dellis_autobuild_BaseSW:4.4
	Wimp-4_36-4_46_2_4:4.3
	Wimp-4_36-4_46_2_3:4.3
	Wimp-4_55:4.4
	Wimp-4_54:4.4
	Wimp-4_36-4_46_2_2:4.3
	Wimp-4_53:4.4
	Wimp-4_36-4_46_2_1:4.3
	Bethany:4.3.0.2
	Wimp-4_52:4.4
	Wimp-4_51:4.4
	Wimp-4_50:4.4
	Wimp-4_49:4.4
	Wimp-4_48:4.4
	Wimp-4_47:4.4
	Wimp-4_46:4.3
	Wimp-4_45:4.3
	Wimp-4_44:4.3
	Wimp-4_43:4.3
	Wimp-4_42:4.3
	sbrodie_sedwards_16Mar2000:4.3
	Wimp-4_41:4.3
	Wimp-4_40:4.3
	Wimp-4_39:4.3
	Wimp-4_38:4.3
	Wimp-4_37:4.3
	Wimp-4_36:4.3
	Wimp-4_35:4.3
	Wimp-4_34:4.3
	Wimp-4_33:4.3
	Wimp-4_32:4.3
	Wimp-4_31:4.3
	dcotton_autobuild_BaseSW:4.4
	Wimp-4_30:4.3
	Wimp-4_29:4.3
	Wimp-4_28:4.3
	Wimp-4_27:4.3
	Wimp-4_26:4.3
	Wimp-4_25:4.3
	Wimp-4_24:4.3
	Wimp-4_23:4.3
	Wimp-4_22:4.3
	Wimp-4_21:4.3
	Wimp-4_20:4.3
	Wimp-4_19:4.3
	Wimp-4_18:4.3
	Wimp-4_17:4.3
	Wimp-4_16:4.3
	Wimp-4_15:4.3
	Wimp-4_14:4.3
	Wimp-4_13:4.3
	Wimp-4_12:4.3
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.1
	bavison_Wimp-4_11:4.3
	Ursula_RiscPC:4.1.4.1.0.2
	Wimp-4_11:4.3
	Wimp-4_10:4.3
	Wimp-4_09:4.3
	Wimp-4_08:4.2
	Wimp-4_07:4.2
	Wimp-4_06:4.2
	Wimp-4_05:4.2
	Wimp-4_04:4.2
	bavison_Wimp-4_03_noshrinkables:4.2
	Wimp-4_03:4.2
	Wimp-4_02:4.2
	Ursula_merge:4.1.4.1
	bavison_Wimp-4_01:4.2
	Wimp-4_01:4.2
	nicke_Wimp_3_96M:4.1.7.1
	bavison_Wimp-4_00_TRUNK:4.2
	bavison_Wimp-4_00:4.1.4.1
	nicke_Wimp_3_96:4.1.7.1
	mjrobert_Wimp_3_98:4.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.1
	UrsulaBuild_FinalSoftload:4.1.4.1
	bavison_Wimp-3_99t:4.1.4.1
	rthornb_UrsulaBuild-12Aug1998:4.1.4.1
	bavison_Wimp-3_99s:4.1.4.1
	aglover_UrsulaBuild-05Aug1998:4.1.4.1
	bavison_Wimp-3_99r:4.1.4.1
	rthornb_UrsulaBuild-29Jul1998:4.1.4.1
	bavison_Wimp-3_99q:4.1.4.1
	jfarrell_NCWimp_3_96:4.1.7.1
	rthornb_UrsulaBuild-22Jul1998:4.1.4.1
	bavison_Wimp-3_99p:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	bavison_Wimp-3_99o:4.1.4.1
	bavison_Wimp-3_99n:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	bavison_Wimp-3_99m:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	bavison_Wimp-3_99l:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	bavison_Wimp-3_99k:4.1
	bavison_Wimp-3_99j:4.1
	bavison_Wimp-3_99i:4.1
	bavison_Wimp-3_99h:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	bavison_Wimp_399g:4.1
	bavison_Wimp_399f:4.1
	afrost_NC2_Generic:4.1.7.1
	bavison_Wimp_399e:4.1
	bavison_Wimp_399d:4.1
	bavison_Wimp_399c:4.1
	Wimp_3_98:4.1
	kbracey_AW97:4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Wimp_3_91:4.1
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.6
date	2013.05.03.21.08.17;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	QS59VqQdUOQmfeOw;

4.5
date	2002.10.23.17.12.37;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	2000.04.25.12.24.09;	author kbracey;	state Exp;
branches;
next	4.3;

4.3
date	98.10.23.15.48.47;	author bavison;	state Exp;
branches;
next	4.2;

4.2
date	98.09.18.16.14.28;	author bavison;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.51;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.30.51;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.33.13;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.07.03.18.00.00;	author bavison;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.24.57;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.22.24;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.6
log
@Slacken pointer checks
The pointer comparison checking required when running in a system with > 64M memory was tightened up from Wimp-4_75 to Wimp-4_76, but to allow the module to target pre RISC OS 5 systems an option to relax those checks is required.
Each check has been revisited and where appropriate demarked with a "AcceptLoosePointer" macro, which just remaps the pointer into the stricter form and carries on. In the strict checking case, the macro reduces to nothing.

Detail:
Add AcceptLoosePointers switch.
Retire singular use of StrongARM switch (calling XOS_SynchroniseCodeAreas is harmless pre StrongARM anyway).
Rename Ursula_RPC options to RO400.
Put duplicate documentation in the attic.
Allow -2 or -1 as the iconbar handle in Wimp_ResizeIcon (ticket #203).
Tighten up the list terminator check in the DebugMemory switch of Memory.s

Tested on RISC OS 3.10 (emulated), 3.50, 3.60, 3.70, 4.02.

Version 5.24. Tagged as 'Wimp-5_24'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > s.Wimp06

;;----------------------------------------------------------------------------
;; Template loading section
;;----------------------------------------------------------------------------

find_close      *       &00
find_openin     *       &40
find_openout    *       &80
find_openup     *       &C0

gbpb_writeR4    *       1
gbpb_write      *       2
gbpb_readR4     *       3
gbpb_read       *       4


;;-----------------------------------------------------------------------------
;; int_setptr
;;
;; in   [filehandle] = handle / =-1 if RAM resident file
;;      R2 = offset to be used
;; out  R4 = offset to be used if RAM based
;;-----------------------------------------------------------------------------

int_setptr Entry "R1"

        LDR     R1,filehandle           ; RAM based transfer?
        CMP     R1,#-1
        CMPNE   R1,#-2                  ; resfs NK

        MOVEQ   R4,R2                   ; if -1 then set to be handle
        MOVNE   R0,#OSArgs_SetPTR
        SWINE   XOS_Args                ; if file then use OS_Args

        EXIT


;;----------------------------------------------------------------------------
;; int_bget - get a single character from the file, trapping EOF
;;
;; in   [filehande] = handle / =-1 if RAM resident
;;      [fileaddress] -> file if [filehandle] =-1
;;      [filelength] = size of file if RAM resident
;;      R4 = index of byte to be obtained
;; out  R0 = byte read
;;      R1 preserved
;;      R4 updated
;;-----------------------------------------------------------------------------

int_bget Entry "R1-R2"

        LDR     R1,filehandle           ; get the handle
        CMP     R1,#-1                  ; is it a RAM based object?
        CMPNE   R1,#-2                  ; res fs
        BNE     %FT10

        LDR     R1,fileaddress          ; -> ram based object
        LDR     R2,filelength           ; = size of the file being read

        Debug   tmp,"int_bget: fileat, filesize, ptr:",R1,R2,R4

        CMP     R4,R2                   ; is the byte within this file
        LDRLOB  R0,[R1,R4]              ; get a byte
        ADDLO   R4,R4,#1
        EXIT    LO                      ; and return if obtained

        MyXError TemplateEOF
        EXIT

        MakeErrorBlock TemplateEOF

10      SWI     XOS_BGet                ; get the byte if not
        EXIT


;;-----------------------------------------------------------------------------
;; int_gbpb - perform block transfer from file / memory
;;
;; in   R2 -> buffer to fill
;;      R3 = number of bytes to be read
;;      R4 = offset to start reading from
;;      [filehande] = handle / =-1 if RAM resident
;;      [fileaddress] -> file if [filehandle] =-1
;;      [filelength] = size of file if RAM resident
;; out  R2,R3,R4 updated
;;-----------------------------------------------------------------------------

int_gbpb Entry "R1"

        LDR     R1,filehandle           ; get the handle of the file
        CMP     R1,#-1                  ; is it coming from memory rather than a file?
        CMPNE   R1,#-2
        BNE     %FT10

        LDR     R0,filelength
        LDR     R1,fileaddress          ; get the address of the file

        Debug   tmp,"int_gbpb: filelen, fileat, into, size, ptr:",R0,R1,R2,R3,R4

05      CMP     R3,#0                   ; finished transfer yet?
        EXIT    EQ

        CMP     R4,R0                   ; have we reached the end of the file yet?
        MyXError TemplateEOF, HS
        EXIT    VS

        LDRB    R14,[R1,R4]
        STRB    R14,[R2],#1             ; copy a byte

        SUB     R3,R3,#1                ; decrease counter to transfer data
        ADD     R4,R4,#1                ; and index into the file
        B       %BT05

10      MOV     R0,#gbpb_readR4
        SWI     XOS_GBPB
        EXIT                            ; fall back to old GBPB method


;----------------------------------------------------------------------------
; Open template file - caches font table address and resets binding table
; Entry:  R1 --> file name
; Exit:   file opened (handle is held internally)
;----------------------------------------------------------------------------

SWIWimp_OpenTemplate

        MyEntry "OpenTemplate"

        BL      int_open_template
        B       ExitWimp

int_open_template
        Push    "LR"

        MOV     R2,#0                   ; zero all font bindings
        ADRL    R3,fontbindings
        MOV     R4,#&100
01
        STR     R2,[R3],#4
        SUBS    R4,R4,#4
        BNE     %BT01

; check that the object exists, read its catalogue information and scan for resources:

        DebugS  tmp,"filename =",R1

        MOV     R0,#OSFile_ReadNoPath
        SWI     XOS_File                ; attempt to read catalogue information on the file
        Pull    "PC",VS                 ; if it fails then exit

        CMP     R0,#object_file         ; check that the object is valid
        MOVNE   R2,R0
        MOVNE   R0,#OSFile_MakeError
        SWINE   XOS_File                ; and generate a meaningful error if its not

        DebugE  tmp,"ERROR in template file type "

        MOVVC   R0,#OSFind_ReadFile
        SWIVC   XOS_Find                ; attempt to open a file
        Pull    "PC",VS                 ; return if it errors (may already have above)

        Debug   tmp,"file handle, size =",R0,R4

        MOVS    R1,R0
        MyXError WimpNoTemplateFile, EQ
        Pull    "PC",VS                 ; if unable to open a stream then exit

; catch case of resources: object

        Push    "R1"
        MOV     R0,#FSControl_ReadFSHandle
        SWI     XOS_FSControl

        DebugE  tmp,"ERROR in template FSinfo "
        Debug   tmp,"fshandle, fsinfo =",R1,R2

        AND     R2,R2,#&FF              ; get FS that the file resides on
        TEQ     R2,#fsnumber_resourcefs
        Pull    "R1",NE                 ; restore the file handle
        BNE     %FT10                   ; exit the loop

; yeehaa its on resources so cache directly from there

        Debug   tmp,"resources: object"

        STR     R1,fileaddress
        STR     R4,filelength           ; setup information about file location

        Pull    "R1"                    ; restore the file handle ready to be clopsed

; NK, stop wimp trying to free bits of ROM and other modules!
        MOV     R0,#find_close
        SWI     XOS_Find                ; close the stream
        MOV     R0,#-2
        STR     R0,filehandle           ; flag as coming from resourcefs

        B       %FT40

; not a resources: object so attempt to read into ram and then exit

10      MOV     R0,#ModHandReason_Claim
        MOV     R3,R4                   ; size of the block to allocate
        BL     XROS_Module

        DebugE  tmp,"ERROR in template cache claim "

        BVS     %FT35                   ; read directly from the file if this fails

; attempt to copy into ram/setup ram pointers worked

        Debug   tmp,"file cache at, size =",R2,R3

        STR     R2,fileaddress
        STR     R3,filelength           ; store file block pointers

        MOV     R0,#gbpb_readR4
        MOV     R4,#0                   ; read directly from the file
        SWI     XOS_GBPB

        DebugE  tmp,"ERROR in caching template "

        BVS     %FT30                   ; failed so attempt to read from the file

; Cache successful, lose file and flag as in memory

20      MOV     R0,#find_close
        SWI     XOS_Find                ; close the stream
        MOV     R0,#-1
        STR     R0,filehandle           ; flag as coming from RAM

        Debug   tmp,"caching directly from file"

        B       %FT40                   ; and then read the header

; attempt to tidy up - an error occurred while block owned, release and fall back to file

30      MOV     R0,#ModHandReason_Free
        LDR     R2,fileaddress
        BL      XROS_Module              ; release the caching block

35      MOV     R0,#0
        STR     R0,fileaddress
        STR     R0,filelength           ; flag as the block has been released
        STR     R1,filehandle           ; and setup a meaningful file handle

        Debug   tmp,"reading from file handle =",R1

; read the file header

40      ADRL    R2,templatehdr
        MOV     R3,#tf_hdr
        MOV     R4,#0
        BL      int_gbpb

        DebugE  tmp,"ERROR in int_gbpb "
;
        MOVVC   R0,R1                   ; put handle back in R0
        Pull    "PC"

        MakeErrorBlock WimpNoTemplateFile


;----------------------------------------------------------------------------
; Close template file
;----------------------------------------------------------------------------

SWIWimp_CloseTemplate ROUT

        MyEntry "CloseTemplate"

        BL      int_close_template
        B       ExitWimp

int_close_template
        Push    "R1,LR"
;
        LDR     R1,filehandle
        TEQ     R1,#0                   ; ignore this if file closed already
        BEQ     %FT01
;
        CMP     R1,#-1                  ; is it a file or in-memory block
        BLEQ    %FT10                   ; release RAM based object, or
        CMPNE   R1,#-2                  ; NK res fs
        MOVNE   R0,#find_close
        SWINE   XOS_Find                ; attempt to close the file
01
        MOV     R14,#0
        STR     R14,filehandle
        STR     R14,fileaddress
        STR     R14,filelength          ; flag as no file / no memory block
;
        Pull    "R1,PC"

;..............................................................................

; release the RAM based block - doesn't zap the pointers

10
      [ :LNOT:No32bitCode
        Push    "LR"
        MRS     R1,CPSR
      |
        MOV     R1,LR
      ]
;
        MOV     R0,#ModHandReason_Free
        LDR     R2,fileaddress
        CMP     R2,#0

        BLNE    XROS_Module              ; release the RAM based object - ignoring errors!
        MOVNE   R2,#0
        STRNE   R2,fileaddress
;
      [ No32bitCode
        MOVS    PC,R1                   ; return back - restoring the flags
      |
        MSR     CPSR_f,R1
        Pull    "PC"
      ]

;----------------------------------------------------------------------------
; Load template definition from file to user workspace
; In:   R1 --> user buffer to hold window defn (userblk=R1 on entry)
;       R2 --> free space to put 'indirected' entries
;       R3 --> end of free space
;       R4 --> 256-byte reference count array (for font handles)
;       R5 --> name of entry (may be wildcarded)
;       R6 --> first index entry to look at (0 ==> all)
; Out:  R2 --> new free space
;       R6 --> next index entry (0 ==> not found)
;
; OR (Wimp 2.45 or later):
;
; In:   R1 = -1
;       R5 --> name of entry (may be wildcarded)
;       R6 --> first index entry to look at (0 ==> all)
; Out:  R1 = size of scratch buffer required
;       R2 = size of indirected data
;       R6 --> next index entry (0 ==> not found)
;----------------------------------------------------------------------------

SWIWimp_LoadTemplate

        MyEntry "LoadTemplate"

        BL      int_load_template
        B       ExitWimp2               ; R1-R6 returned to user

int_load_template
        Push    "LR"
;
        LDR     R1,filehandle
        STR     R2,userfreeptr
        STR     R3,userfreeend
        STR     R4,userfontcounts
;
        MOVS    R4,R6
        MOVEQ   R4,#tf_hdr              ; if 0, start at first index entry
srchindex
        ADRL    R2,tempiconblk
        MOV     R3,#tf_indexsize
;
        BL      int_gbpb
;
        STR     R4,templateindex
        BVS     exittemplate

; unless last entry, check for match with (wildcarded) name

        LDR     R6,tempiconblk
        TEQ     R6,#0
        BEQ     exittemplate2           ; keep R6
        ADRL    R6,tempiconblk+12
        BL      matchnames              ; EQ => matched, [tempworkspace] NE => wildcarded
        BNE     srchindex

; if [R5..] was wildcarded, copy actual name back (R5 word-aligned)

        LDR     R14,tempworkspace
        CMP     R14,#0                  ; don't copy if match name not wildcarded
        BEQ     %FT01
;
        TST     R5,#3                   ; must be word-aligned here!
        ADREQL  R14,tempiconblk+12
        LDMEQIA R14,{R0,R6,R14}         ; safest thing is to just not do it
        STMEQIA R5,{R0,R6,R14}
01

; load data into user buffer (unless R1 null on entry)

        Debug   tmp,"Template: offset,size,type =",#tempiconblk,#tempiconblk+4,#tempiconblk+8

        LDR     R4,tempiconblk          ; data offset in file
        LDR     R3,tempiconblk+4        ; data size
        AcceptLoosePointer_NegOrZero userblk,0
        MOVS    R2,userblk
        CMPNE   R2,#nullptr
        BNE     %FT01

        LDR     R14,tempiconblk+8       ; is this a window?
        TEQ     R14,#1
        MOVNE   R10,R3                  ; R10 = size of buffer needed
        MOVNE   R9,#0                   ; R9 = size of indirected data
        BNE     exittemplate_size

        ADR     R2,tempworkspace
        ADD     R4,R4,#w_nicons-w_cw0
        MOV     R3,#4                   ; just read number of icons
01
        Debug   tmp,"XOS_GBPB:",R0,R1,R2,R3,R4
        BL      int_gbpb                ; read from the file
        BVS     exittemplate

; if userblk was null, we want to return R1 = size of scratch block, R2 = size of indirected data
; unless object type = 1 (window), all data is put into the scratch block

        LDR     R14,tempiconblk+8       ; R14 = object type
        AcceptLoosePointer_NegOrZero userblk,0
        CMP     userblk,userblk,ASR #31
        MOVNE   R8,#-1                  ; R8 =-1 => we're actually loading the data
        LDREQ   userblk,tempiconblk+0   ; userblk = offset of data in file
        LDREQ   R8,tempworkspace        ; R8 = number of icons
        MOVEQ   R9,#0                   ; R9 = total size of indirected data
        LDREQ   R10,tempiconblk+4       ; R10 = total size of template entry

        ; EQ => R14=1 (object type checked earlier)

        TEQ     R14,#1                  ; if loading item, just leave now
        BNE     exittemplate

; process icons if this object is a window
; R8 = -1 => userblk -> user buffer containing data, else
; R8 = nicons => userblk = offset of data in file (we're counting it)

        ADD     R1,userblk,#w_titleflags-w_cw0  ; R1 -> icon flags
        ADD     R2,userblk,#w_title-w_cw0       ; R2 -> icon data
        BL      templateicon
        BVS     exittemplate
;
        ADD     R14,userblk,#w_nicons-w_cw0
        MOV     R6,R8                           ; if R8 = -1,
        CMP     R6,#-1
        LDREQ   R6,[userblk,#w_nicons-w_cw0]    ; get nicons from block
        CMP     R6,#0
        BEQ     %FT01

        ADD     R7,userblk,#w_size-w_cw0
doicons
        ADD     R1,R7,#i_flags                  ; R1 -> icon flags
        ADD     R2,R7,#i_data                   ; R2 -> icon data
        BL      templateicon
        BVS     exittemplate
        ADD     R7,R7,#i_size
        SUBS    R6,R6,#1
        BNE     doicons
01
        CMP     R8,#-1                          ; R8 <> -1 => we're counting:
        BNE     exittemplate_size               ; R9 = indirected data size, R10 = total size

exittemplate
        LDR     R6,templateindex
exittemplate2
        MOV     R1,#1
        BVS     %FT05
        AcceptLoosePointer_NegOrZero userblk,0
        CMP     userblk,userblk,ASR #31
        STRNE   R1,[userblk,#64]       ; make sure window's sprite area is sensible
        CLRV                            ; cmp sets V !!!!!
05
        MOV     R1,userblk
        LDR     R2,userfreeptr
exittemplate3                           ; returns R1,R2 = buffer sizes
        LDR     R3,userfreeend
        LDR     R4,userfontcounts
        Pull    "PC"                    ; code goes to ExitWimp2
        MakeErrorBlock WimpBadTemplate

exittemplate_size
        LDR     R6,templateindex
        MOV     R1,R10                  ; R1 = buffer size required
        MOV     R2,R9                   ; R2 = indirected data size required
        Debug   tmp,"Template size =",R1,R2
        B       exittemplate3

; In    R1 --> flag word for icon
;       R2 --> data for icon (could be indirected)
;       R8 = -1 => R1,R2 are file offsets (we're just counting the size required)
;       R9 = current size of indirected data
; Out   R9 updated
;       R0,R1,R3 corrupted

templateicon
        Push    "R2,R4,R7,LR"
;
        CMP     R8,#-1                  ; if just counting, ignore font stuff
        BNE     counttemplateicon
;
        LDR     R14,[R1]
        TST     R14,#if_fancyfont
        BEQ     tryindirected
;
        LDR     R14,userfontcounts
        CMP     R14,#-1
        MyXError  WimpBadFonts,EQ
        Pull    "R2,R4,R7,PC",VS
;
; if we already know about this font, just change the handle
;
        ASSERT  (ib_fontno=24)
        LDRB    R7,[R1,#3]              ; R7 = internal font handle
        ADRL    R14,fontbindings
        LDRB    R0,[R14,R7]
        TEQ     R0,#0                   ; if not zero, we can use it direct
        STRNEB  R0,[R1,#3]              ; R0 = external font handle
        BNE     tryindirected
;
; to find out the binding, we must get the data from the file
;
        Push    "R1-R5"
        SUB     R4,R7,#1                ; R4 = offset into file =base+48*(R7-1)
        ADD     R4,R4,R4,ASL #1                 ; mul by 3
        MOV     R4,R4,ASL #tf_log2fontsize      ; mul by 16
        LDR     R14,templatehdr+0
        ADD     R4,R4,R14
        MOV     R3,#tf_fontsize
        ADRL    R2,tempiconblk
        BL      int_gbpb
;
        ADRVCL  R1,tempiconblk+8        ; R1 --> font name
        LDRVC   R2,tempiconblk+0        ; R2 = x-size * 16
        LDRVC   R3,tempiconblk+4        ; R3 = y-size * 16
        MOVVC   R4,#0                   ; use default resolution
        MOVVC   R5,#0
        SWIVC   XFont_FindFont
        BVS     errinfont
;
        ADRL    R14,fontbindings        ; update bindings
        STRB    R0,[R14,R7]
;
; having called FindFont, notify the user of this fact!
;
        LDR     R14,userfontcounts
        LDRB    R2,[R14,R0]             ; user thinks in external handles
        ADD     R2,R2,#1
        STRB    R2,[R14,R0]
        CMP     R2,#255                 ; stop the rot before it's too late!
        MyXError  WimpBadFonts,GE         ; (don't allow it to get to 256)
errinfont
        Pull    "R1-R5"
        Pull    "R2,R4,R7,PC",VS
        STRB    R0,[R1,#3]              ; put back external handle
;
; now check for indirected icons
;
tryindirected
        LDR     R14,[R1]
        TST     R14,#if_indirected
        Pull    "R2,R4,R7,PC",EQ
;
        LDR     R0,[R2,#8]              ; size of buffer required
        CMP     R0,#0                   ; size <= 0 => leave pointer alone
        BLGT    relocateitem
        Pull    "R2,R4,R7,PC",VS
;
        LDR     R14,[R2,#4]!            ; now do the validation string
        CMP     R14,#w_cw1-w_cw0-1      ; must point to an item after the icon itself
        Pull    "R2,R4,R7,PC",LE        ; no need
;
        ADD     R14,userblk,R14
        MOV     R7,R14
getlen
        LDRB    R0,[R14],#1
        CMP     R0,#32
        BCS     getlen
        SUB     R0,R14,R7
        BL      relocateitem
;
        Pull    "R2,R4,R7,PC"
        MakeErrorBlock WimpBadFonts

;........................................................................

; count size of indirected icons

counttemplateicon
        Push    "R1-R3"
        SUB     R14,R2,R1               ; if R2 = R1+4,
        ADRL    R2,tempiconblk
        CMP     R14,#4
        MOVEQ   R3,#16                  ; read all 16 bytes at once
        BEQ     %FT01

        MOV     R3,#4
        BL      readR1_R3               ; read 4 bytes of icon flags, updating R2
        LDRVC   R1,[sp,#4]
        MOVVC   R3,#12                  ; read 12 bytes of icon data
01
        BLVC    readR1_R3               ; read rest of icon
        Pull    "R1-R3"
        Pull    "R2,R4,R7,PC",VS

        LDR     R14,tempiconblk+0       ; icon flags
        TST     R14,#if_indirected
        Pull    "R2,R4,R7,PC",EQ
;
        LDR     R0,tempiconblk+12       ; size of buffer required
        CMP     R0,#0                   ; size <= 0 => this isn't really the size
        ADDGT   R9,R9,R0                ; update indirected data size
;
        LDR     R14,tempiconblk+8       ; now do the validation string
        CMP     R14,#w_cw1-w_cw0-1      ; if ptr, must point past window block at least
        Pull    "R2,R4,R7,PC",LE        ; -1, or 0..87 => not a pointer
;
        ADD     R2,userblk,R14          ; R2 -> address of first byte
        BL      int_setptr
;
        Debug   tmp,"Counting validation string at",R2
countlen
        BL      int_bget
        Pull    "R2,R4,R7,PC",VS
;
        CMP     R0,#32
        ADD     R9,R9,#1                ; update indirected data size
        BCS     countlen                ; (including terminator!)
;
        Pull    "R2,R4,R7,PC"

;........................................................................

; In    R1 = file offset
;       R2 -> user buffer
;       R3 = number of bytes to read
; Out   R2 updated (new R2 = old R2 + R3)
;       R0 corrupted

readR1_R3
        Push    "R1,R3,R4,LR"

        MOV     R4,R1
        BL      int_gbpb
        Debug   tmp,"XOS_GBPB:",R0,R1,R2,R3,R4

        Pull    "R1,R3,R4,PC"

;........................................................................

; In    R0 = size of buffer required
;       [R2] --> data (rel. to userblk)
; Out   data copied into free space
;       userfreeptr updated

relocateitem
        Push    "R7,LR"

        Debug   tmp,"Relocate: ptr,size,end =",#userfreeptr,R0,#userfreeend

        LDR     R7,userfreeptr
        ADD     R14,R7,R0
        LDR     R0,userfreeend
        CMP     R14,R0
        STRLS   R14,userfreeptr         ; update free space ptr
        MyXError  WimpTooBig,HI,L
        Pull    "R7,PC",VS

        LDR     R14,[R2]                ; old pointer to data
        STR     R7,[R2]                 ; new pointer
        ADD     R14,userblk,R14         ; (old one is rel. to userblk)
getwritem
        LDRB    R0,[R14],#1             ; copy into user workspace
        STRB    R0,[R7],#1
        CMP     R0,#32
        BCS     getwritem

        Pull    "R7,PC"

;........................................................................

; In    R5 --> target name (wildcarded)
;       R6 --> candidate name
; Out   EQ => names match
;       [tempworkspace] <> 0 => name was wildcarded

matchnames
        Push    "R5,R7,R8,LR"
        MOV     R7,#0                   ; for going back to (none yet)
        STR     R7,tempworkspace
matchlp
        LDRB    R0,[R5],#1
        CMP     R0,#"*"
        STREQ   R0,tempworkspace        ; NE => name was wildcarded
        MOVEQ   R7,R5
        MOVEQ   R8,R6
        BEQ     matchlp
;
        LDRB    R14,[R6],#1
        CMP     R0,#32
        CMPCC   R14,#32
        BCC     yesmatch                ; both terminated (OK)
        CMP     R14,#32
        BCC     nomatch                 ; candidate terminated (not OK)
;
        CMP     R0,#"#"
        STREQ   R0,tempworkspace        ; NE => name was wildcarded
        EORNE   R14,R14,R0
        TSTNE   R14,#&DF                ; equate case
        BEQ     matchlp
;
        MOVS    R5,R7                   ; old match ptr (if any)
        MOVNE   R6,R8
        ADDNE   R8,R8,#1
        BNE     matchlp
nomatch
        CMP     R0,#-1
        Pull    "R5,R7,R8,PC"
yesmatch
        CMP     R0,R0
        Pull    "R5,R7,R8,PC"


        END
@


4.5
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@d410 1
d433 1
d480 1
@


4.4
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d78 3
a80 3
        LDRLTB  R0,[R1,R4]              ; get a byte
        ADDLT   R4,R4,#1
        EXIT    LT                      ; and return if obtained
d119 1
a119 1
        MyXError TemplateEOF, GE
d325 3
a327 3
        BLGT    XROS_Module              ; release the RAM based object - ignoring errors!
        MOVGT   R2,#0
        STRGT   R2,fileaddress
d410 3
a412 2
        SUBS    R2,userblk,#0
        BGT     %FT01
d432 6
a437 6
        CMP     userblk,#0
        MOVGT   R8,#-1                  ; R8 < 0 => we're actually loading the data
        LDRLE   userblk,tempiconblk+0   ; userblk = offset of data in file
        LDRLE   R8,tempworkspace        ; R8 = number of icons
        MOVLE   R9,#0                   ; R9 = total size of indirected data
        LDRLE   R10,tempiconblk+4       ; R10 = total size of template entry
d439 1
a439 1
        ; LE => R14=1 (object type checked earlier)
d445 1
a445 1
; R8 < 0 => userblk -> user buffer containing data, else
d448 3
a450 3
        ADDVC   R1,userblk,#w_titleflags-w_cw0  ; R1 -> icon flags
        ADDVC   R2,userblk,#w_title-w_cw0       ; R2 -> icon data
        BLVC    templateicon
d454 3
a456 2
        SUBS    R6,R8,#0                        ; if R8 < 0,
        LDRLT   R6,[userblk,#w_nicons-w_cw0]    ; get nicons from block
d458 1
a458 1
        BLE     %FT01
d470 2
a471 2
        CMP     R8,#0                           ; R8 >= 0 => we're counting:
        BGE     exittemplate_size               ; R9 = indirected data size, R10 = total size
d478 2
a479 2
        CMP     userblk,#0
        STRGT   R1,[userblk,#64]       ; make sure window's sprite area is sensible
d499 1
a499 1
;       R8 < 0 => R1,R2 are file offsets (we're just counting the size required)
d507 2
a508 2
        CMP     R8,#0                   ; if just counting, ignore font stuff
        BGE     counttemplateicon
d515 2
a516 2
        CMP     R14,#0
        MyXError  WimpBadFonts,LE
d673 2
a674 2
        STRLE   R14,userfreeptr         ; update free space ptr
        MyXError  WimpTooBig,GT,L
@


4.3
log
@Adapted assembly process so that the choice of Options file (previously based
purely on the "System" variable) can be overridden by passing "OPTIONS=foo" as
an argument to either MkRom, or to amu/amu_machine directly, or indirectly,
by specifying it in the components file for a build. To accomplish this, it
was necessary to switch from using aasm to objasm - hence the large number of
source files affected in this commit.

Version 4.09. Tagged as 'Wimp-4_09'
@
text
@d29 1
a29 1
gbpb_read       *       4        
d58 1
a58 1
;;      [filelength] = size of file if RAM resident 
d62 1
a62 1
;;      R4 updated 
d68 1
a68 1
        CMP     R1,#-1                  ; is it a RAM based object?     
d74 1
a74 1
                     
d81 1
a81 1
                 
d84 1
a84 1
        
d87 1
a87 1
10      SWI     XOS_BGet                ; get the byte if not            
d90 1
a90 1
                      
d99 1
a99 1
;;      [filelength] = size of file if RAM resident 
d109 2
a110 2
        
        LDR     R0,filelength    
d112 1
a112 1
                  
d122 1
a122 1
        LDRB    R14,[R1,R4]             
d128 1
a128 1
        
d159 1
a159 1
                    
d180 1
a180 1
        MyXError WimpNoTemplateFile, EQ   
d187 1
a187 1
        SWI     XOS_FSControl        
d205 1
a205 1
                                                                        
d218 1
a218 1
        BL     XROS_Module  
d230 1
a230 1
                
d233 1
a233 1
        SWI     XOS_GBPB                
d313 7
a319 1
10      MOV     R1,LR
d329 1
d331 4
d635 1
a635 1
;                
@


4.2
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d40 1
a40 1
int_setptr ENTRY "R1"
d65 1
a65 1
int_bget ENTRY "R1-R2"
d103 1
a103 1
int_gbpb ENTRY "R1"
@


4.1
log
@Initial revision
@
text
@d141 3
d283 3
d347 3
@


4.1.4.1
log
@Window tool button type is now configurable.
Windows now keep the same depth when toggle-size tool is clicked with Adjust.
Fixed bug where drags in Eureka caused branch-through-zeros and other
miscellaneous errors.
Fixed a few stray non-X form SWI calls.
Extended applicability/functionality of "MyEntry" debug macro.
@
text
@a140 3

        MyEntry "OpenTemplate"

a279 3

        MyEntry "CloseTemplate"

a340 3

        MyEntry "LoadTemplate"

@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

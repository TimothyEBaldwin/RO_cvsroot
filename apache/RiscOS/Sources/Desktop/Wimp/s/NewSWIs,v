head	4.18;
access;
symbols
	Wimp-5_62:4.18
	Wimp-5_61:4.18
	Wimp-5_60:4.18
	Wimp-5_59:4.18
	Wimp-5_58:4.18
	Wimp-5_57:4.18
	Wimp-5_56:4.18
	Wimp-5_55:4.18
	Wimp-5_54:4.18
	Wimp-5_53:4.18
	Wimp-5_52:4.18
	Wimp-5_51:4.18
	Wimp-5_50:4.18
	Wimp-5_49:4.18
	Wimp-5_48:4.18
	Wimp-5_47-file1ad:4.18
	Wimp-5_47:4.18
	Wimp-5_46:4.18
	Wimp-5_45:4.18
	Wimp-5_44:4.18
	Wimp-5_43:4.18
	Wimp-5_42:4.18
	Wimp-5_41:4.18
	Wimp-5_40:4.18
	Wimp-5_39:4.18
	Wimp-5_38:4.18
	Wimp-5_37:4.18
	Wimp-5_36:4.18
	Wimp-5_35:4.17
	Wimp-5_34:4.16
	Wimp-5_33:4.15
	Wimp-5_32:4.15
	Wimp-5_31:4.15
	Wimp-5_30:4.15
	Wimp-530-pre4:4.15
	Wimp-5_30-pre3:4.15
	Wimp-5_30-pre2:4.15
	Wimp-5_30-pre1:4.15
	Wimp-5_29:4.15
	Wimp-5_28:4.15
	Wimp-5_27:4.15
	Wimp-5_26:4.15
	Wimp-5_25:4.15
	Wimp-5_24:4.14
	Wimp-5_23:4.13
	Wimp-5_22:4.13
	Wimp-5_21:4.12
	Wimp-5_20:4.12
	Wimp-5_19:4.12
	Wimp-5_18:4.12
	Wimp-5_17:4.12
	Wimp-5_16:4.12
	Wimp-5_15:4.12
	Wimp-5_14:4.12
	Wimp-5_13:4.11
	Wimp-5_12:4.11
	Wimp-5_11:4.11
	Wimp-5_10:4.11
	Wimp-5_09:4.11
	Wimp-5_08:4.11
	Wimp-5_07:4.11
	Wimp-5_06:4.11
	Wimp-5_05:4.11
	Wimp-5_04:4.11
	Wimp-5_03:4.11
	Wimp-5_02:4.11
	Wimp-5_01:4.11
	Wimp-4_66-4_77_2_1:4.6
	bavison_Threads_dev:4.6.0.2
	bavison_Threads_dev_bp:4.6
	Wimp-5_00:4.11
	Wimp-4_100:4.11
	Wimp-4_99:4.11
	Wimp-4_98:4.11
	Wimp-4_97:4.11
	Wimp-4_96:4.11
	Wimp-4_95:4.11
	Wimp-4_94:4.11
	RO_5_07:4.11
	Wimp-4_93:4.11
	Wimp-4_92:4.11
	Wimp-4_91:4.10
	Wimp-4_90:4.10
	Wimp-4_89:4.10
	Wimp-4_88:4.9
	Wimp-4_87:4.8
	Wimp-4_86:4.8
	Wimp-4_85:4.8
	Wimp-4_84:4.7
	Wimp-4_83:4.7
	Wimp-4_82:4.7
	Wimp-4_81:4.7
	Wimp-4_80:4.7
	Wimp-4_79:4.7
	Wimp-4_78:4.7
	Wimp-4_77:4.7
	Wimp-4_76:4.7
	Wimp-4_75:4.6
	Wimp-4_74:4.6
	Wimp-4_73:4.6
	Wimp-4_72:4.6
	Wimp-4_71:4.6
	Wimp-4_70:4.6
	Wimp-4_69:4.6
	Wimp-4_68:4.6
	Wimp-4_67:4.6
	Wimp-4_66:4.6
	Wimp-4_65:4.6
	Wimp-4_64:4.6
	Wimp-4_63:4.6
	Wimp-4_62:4.6
	Wimp-4_61:4.6
	Wimp-4_60:4.6
	Wimp-4_59:4.6
	Wimp-4_58:4.6
	Wimp-4_36-4_46_2_6:4.5
	Wimp-4_57:4.6
	Alpnet_approved:4.5
	Wimp-4_36-4_46_2_5:4.5
	Wimp-4_56:4.6
	dellis_autobuild_BaseSW:4.6
	Wimp-4_36-4_46_2_4:4.5
	Wimp-4_36-4_46_2_3:4.5
	Wimp-4_55:4.6
	Wimp-4_54:4.6
	Wimp-4_36-4_46_2_2:4.5
	Wimp-4_53:4.6
	Wimp-4_36-4_46_2_1:4.5
	Bethany:4.5.0.2
	Wimp-4_52:4.6
	Wimp-4_51:4.6
	Wimp-4_50:4.6
	Wimp-4_49:4.6
	Wimp-4_48:4.6
	Wimp-4_47:4.6
	Wimp-4_46:4.5
	Wimp-4_45:4.5
	Wimp-4_44:4.5
	Wimp-4_43:4.5
	Wimp-4_42:4.5
	sbrodie_sedwards_16Mar2000:4.5
	Wimp-4_41:4.5
	Wimp-4_40:4.5
	Wimp-4_39:4.5
	Wimp-4_38:4.5
	Wimp-4_37:4.5
	Wimp-4_36:4.5
	Wimp-4_35:4.5
	Wimp-4_34:4.5
	Wimp-4_33:4.5
	Wimp-4_32:4.5
	Wimp-4_31:4.5
	dcotton_autobuild_BaseSW:4.6
	Wimp-4_30:4.5
	Wimp-4_29:4.5
	Wimp-4_28:4.5
	Wimp-4_27:4.5
	Wimp-4_26:4.5
	Wimp-4_25:4.5
	Wimp-4_24:4.5
	Wimp-4_23:4.5
	Wimp-4_22:4.5
	Wimp-4_21:4.5
	Wimp-4_20:4.5
	Wimp-4_19:4.5
	Wimp-4_18:4.5
	Wimp-4_17:4.5
	Wimp-4_16:4.5
	Wimp-4_15:4.5
	Wimp-4_14:4.5
	Wimp-4_13:4.5
	Wimp-4_12:4.5
	mstphens_UrsulaRiscPCBuild_20Nov98:4.3.2.4
	bavison_Wimp-4_11:4.5
	Ursula_RiscPC:4.3.2.4.0.2
	Wimp-4_11:4.5
	Wimp-4_10:4.4
	Wimp-4_09:4.4
	Wimp-4_08:4.4
	Wimp-4_07:4.4
	Wimp-4_06:4.4
	Wimp-4_05:4.4
	Wimp-4_04:4.4
	bavison_Wimp-4_03_noshrinkables:4.4
	Wimp-4_03:4.4
	Wimp-4_02:4.4
	Ursula_merge:4.3.2.4
	bavison_Wimp-4_01:4.4
	Wimp-4_01:4.4
	nicke_Wimp_3_96M:4.1.7.1
	bavison_Wimp-4_00_TRUNK:4.4
	bavison_Wimp-4_00:4.3.2.4
	nicke_Wimp_3_96:4.1.7.1
	mjrobert_Wimp_3_98:4.3
	rthornb_UrsulaBuild-19Aug1998:4.3.2.4
	UrsulaBuild_FinalSoftload:4.3.2.4
	bavison_Wimp-3_99t:4.3.2.4
	rthornb_UrsulaBuild-12Aug1998:4.3.2.4
	bavison_Wimp-3_99s:4.3.2.4
	aglover_UrsulaBuild-05Aug1998:4.3.2.4
	bavison_Wimp-3_99r:4.3.2.4
	rthornb_UrsulaBuild-29Jul1998:4.3.2.4
	bavison_Wimp-3_99q:4.3.2.4
	jfarrell_NCWimp_3_96:4.1.7.1
	rthornb_UrsulaBuild-22Jul1998:4.3.2.4
	bavison_Wimp-3_99p:4.3.2.4
	rthornb_UrsulaBuild-15Jul1998:4.3.2.4
	bavison_Wimp-3_99o:4.3.2.4
	bavison_Wimp-3_99n:4.3.2.4
	rthornb_UrsulaBuild-07Jul1998:4.3.2.4
	bavison_Wimp-3_99m:4.3.2.4
	rthornb_UrsulaBuild-17Jun1998:4.3.2.3
	rthornb_UrsulaBuild-03Jun1998:4.3.2.3
	bavison_Wimp-3_99l:4.3.2.3
	rthornb_UrsulaBuild-27May1998:4.3.2.3
	rthornb_UrsulaBuild-21May1998:4.3.2.3
	bavison_Wimp-3_99k:4.3.2.3
	bavison_Wimp-3_99j:4.3.2.3
	bavison_Wimp-3_99i:4.3.2.3
	bavison_Wimp-3_99h:4.3.2.3
	rthornb_UrsulaBuild_01May1998:4.3.2.3
	bavison_Wimp_399g:4.3.2.3
	bavison_Wimp_399f:4.3.2.3
	afrost_NC2_Generic:4.1.7.1
	bavison_Wimp_399e:4.3.2.3
	bavison_Wimp_399d:4.3.2.3
	bavison_Wimp_399c:4.3.2.3
	Wimp_3_98:4.3
	kbracey_AW97:4.3
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.3.0.4
	Daytona_bp:4.3
	Ursula:4.3.0.2
	Ursula_bp:4.3
	Wimp_3_91:4.3
	Spin_merge_7May97:4.1.7.1
	ARTtmp_bp:4.1.7.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1.2.2
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.18
date	2014.03.01.22.42.57;	author jlee;	state Exp;
branches;
next	4.17;
commitid	KQ4bwdJetbz443rx;

4.17
date	2014.01.01.19.47.57;	author jlee;	state Exp;
branches;
next	4.16;
commitid	LFYgvVGTUEWBZrjx;

4.16
date	2013.11.30.01.22.06;	author jlee;	state Exp;
branches;
next	4.15;
commitid	NHBF77CIMgF0Uefx;

4.15
date	2013.05.06.11.54.48;	author rsprowson;	state Exp;
branches;
next	4.14;
commitid	dyQdYmrTRpty5zOw;

4.14
date	2013.05.03.21.08.16;	author rsprowson;	state Exp;
branches;
next	4.13;
commitid	QS59VqQdUOQmfeOw;

4.13
date	2013.04.10.20.48.44;	author rsprowson;	state Exp;
branches;
next	4.12;
commitid	oyotsfYRPfGzSgLw;

4.12
date	2012.01.27.21.12.29;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	SVSK1WYyfHjp7RQv;

4.11
date	2004.07.05.13.17.45;	author bavison;	state Exp;
branches;
next	4.10;

4.10
date	2003.02.28.16.09.31;	author bavison;	state Exp;
branches;
next	4.9;

4.9
date	2003.02.04.14.22.21;	author bavison;	state Exp;
branches;
next	4.8;

4.8
date	2003.01.17.19.35.23;	author bavison;	state Exp;
branches;
next	4.7;

4.7
date	2002.10.23.17.12.35;	author bavison;	state Exp;
branches;
next	4.6;

4.6
date	2000.04.25.12.24.04;	author kbracey;	state Exp;
branches;
next	4.5;

4.5
date	98.11.09.12.49.08;	author bavison;	state Exp;
branches;
next	4.4;

4.4
date	98.09.18.16.14.04;	author bavison;	state Exp;
branches;
next	4.3;

4.3
date	97.05.07.14.15.24;	author kbracey;	state Exp;
branches
	4.3.2.1;
next	4.2;

4.2
date	97.01.13.13.24.55;	author nturton;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.30.46;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.3.2.1
date	98.03.10.16.11.25;	author bavison;	state Exp;
branches;
next	4.3.2.2;

4.3.2.2
date	98.03.26.19.31.32;	author bavison;	state Exp;
branches;
next	4.3.2.3;

4.3.2.3
date	98.04.03.19.38.32;	author bavison;	state Exp;
branches;
next	4.3.2.4;

4.3.2.4
date	98.07.03.17.59.43;	author bavison;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.30.46;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.32.51;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.24.29;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.22.03;	author nturton;	state Exp;
branches
	4.1.7.1.2.1;
next	;

4.1.7.1.2.1
date	97.04.10.13.51.13;	author kbracey;	state Exp;
branches;
next	4.1.7.1.2.2;

4.1.7.1.2.2
date	97.04.28.16.49.52;	author kbracey;	state Exp;
branches;
next	;


desc
@@


4.18
log
@Implement sprite translation table caching
Detail:
  This set of changes allows the Wimp to cache the last-used translation table, and cleans up some instances where translation tables were being generated and then not used
  s/Wimp01 - Expand selecttable_args to store all 8 registers needed by ColourTrans_GenerateTable. Add 1K of space for caching the palette that the cached translation table was generated from. Remove unused spriteX, spriteY variables.
  s/Wimp04 - Split cachespritedata in two. cachespritedata now only caches the basic information, while the new cachespritepixtable rotuine will generate a translation table (shaded/inverted if required). This allows table generation to be deferred until we're just about to render the sprite, ensuring that the table isn't generated only to not be used. Also updated icon sprite rendering to check the sprite is within the graphics window before attempting to render it, allowing removal of one more case where tables can be needlessly generated.
  s/NewSWIs, s/Wimp09 - Change ADR to ADRL
  s/Tiling, s/Tiling3D - Use cachespritepixtable when needed
Admin:
  Tested on Iyonix, BB-xM, StrongARM RiscPC


Version 5.36. Tagged as 'Wimp-5_36'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > source.NewSWIs

SWIWimp_TextOp
        MyEntry "TextOp"

        AND     userblk,R0,#255
        CMP     userblk,#4
        SETV    HI
        ADRVSL  R0,ErrorBlock_WimpBadReasonCode
        BVS     ExitWimp
        [ AllowMatrix
        TST     R0,#&20000000
        MOVNE   R14,R6
        MOVEQ   R14,#0
        ]
        CMP     userblk,#1
        [ AllowMatrix
        STRHS   R14,validationstring
        ]
        ADR     R14, %FT90
        BLO     textop_setcolours
        BEQ     textop_gettextwidth
        CMP     userblk,#3
        BLO     textop_painttext
        BEQ     textop_getsplitpoint
        BHI     textop_truncate
90
        B       ExitWimp

textop_setcolours
        Push    lr
        [ outlinefont
        LDR     R3,systemfont
        TEQ     R3,#0
        STRNE   R1,last_fg_gcol
        STRNE   R2,last_bg_gcol
        Pull    PC,NE
        ]
        MOV     R0,R2
        MOV     R3,#128                 ; bg
        MOV     R4,#0
        SWI     XColourTrans_SetGCOL
        MOVVC   R0,R1
        MOVVC   R3,#0
        SWIVC   XColourTrans_SetGCOL

        Pull    PC

textop_painttext
        Push    "lr"

        TST     R0,#&20000000
        LDRNE   R3,redrawhandle
        Abs     R3,R3,NE
        LDRNE   R14,[R3,#w_wax0]
        ADDNE   R4,R4,R14
        LDRNE   R14,[R3,#w_way1]
        ADDNE   R5,R5,R14

        [ outlinefont
        LDR     R3,systemfont
        TEQ     R3,#0
        BEQ     systemfont_paint

        MOV     R2,R1
        MOV     R1,#is_deleted
        MOV     R9,#bignum
      [ CnP
        MOV     R7, #nullptr
      ]
        BL      pushfontstring

        LDR     R9,last_fg_gcol
        CMP     R9,#-1
        MOVNE   R9,R9, LSR #8
        ORRNE   R9,R9,#&0E000000
        Push    "R9",NE
        LDRNE   R9,last_bg_gcol
        MOVNE   R9,R9, LSR #8
        MOVNE   R9,R9, LSL #8
        ORRNE   R9,R9,#19               ; set font colours
        Push    "R9",NE
        ADDNE   R7,R7,#8
        SUBNE   R1,R1,#8
        MOVNE   R9,#-1
        STRNE   R9,last_fg_gcol

        TST     R0,#&40000000
        LDRNE   R14,systemfonty1
        SUBNE   R14,R14,#28             ; system font was 28 OS units above baseline
        SUBNE   R5,R5,R14 ,LSR #1

        TST     R0,#&10000000           ; vertically central
        LDRNE   R14,systemfonty1
        SUBNE   R5,R5,R14 ,LSR #1

;        LDRNE   R14,systemfonty0
;        SUBNE   R5,R5,R14 ,LSR #1
;        SUBNE   R5,R5,R14               ; p'=p-(y1-3y2)/2


test_rightjustified
        TST     R0,#&80000000
        BEQ     textop_paintfancy
; right justified
        Push    "R1-R5"
        MOV     R2,#0
        MOV     R3,#bignum
        MOV     R4,#bignum
        SWI     XFont_ScanString
        MOV     R1,R3
        SWI     XFont_ConverttoOS
        MOV     R0,R1
        Pull    "R1-R5"
        SUB     R4,R4,R0                ; R4 was RHS
textop_paintfancy
        MOV     R3,R4
;        LDR     R14,systemfonty0        ; get baseline same as system font
;        ADD     R14,R14,#4
;        SUB     R4,R5,R14
        MOV     R4,R5
        MOV     R2,#16                  ; use OS units

        LDR     R14,dx_1
        BIC     R3,R3,R14
        LDR     R14,dy_1
        ADD     R4,R4,R14               ; round up
        BIC     R4,R4,R14

        SWI     XFont_Paint

        ADD     sp,sp,R7                ; balance stack from pushfontstring
        Pull    "PC"

systemfont_paint

        ]

        TST     R0,#&10000000           ; vertically central
        SUBNE   R5,R5,#16               ; system font is 32 OS units high

        LDR     R14,dx_1
        BIC     R4,R4,R14
        LDR     R14,dy_1
        SUB     R5,R5,R14               ; round down as plotting from top left
        BIC     R5,R5,R14

        TST     R0,#&80000000           ; right justified ?
        BEQ     paint_systemfont
        MOV     R0,#0
        MOV     R7,R1
systemfontlength
        LDRB    R6,[R7],#1
        CMP     R6,#31
        ADDHI   R0,R0,#1
        BHI     systemfontlength
        MOV     R0,R0,LSL #4            ; 16 OS units per char
        SUB     R4,R4,R0
paint_systemfont
        Push    "R1"
        MOV     R1,R4
        ADD     R2,R5,#28               ; top left vs btm left
        MOV     R0,#4                   ; move abbsolute
        SWI     XOS_Plot
        Pull    "R0"
        SWI     XOS_Write0
        Pull    "PC"


textop_gettextwidth
        ; RISC OS 4.32 uses flag bit 31 to indicate that bounding box not width is required
        Push    "lr"

        MOV     R9,#bignum
        CMP     R2,#0
        MOVGT   R9,R2

        [ outlinefont
        LDR     R3,systemfont
        TEQ     R3,#0
        BEQ     textop_sysfontwidth

        MOV     R2,R1
        MOV     R1,#is_deleted
      [ CnP
        MOV     R7, #nullptr
      ]
        BL      pushfontstring
        [ true
        MOV     R2,#0
        MOV     R3,#bignum
        MOV     R4,#bignum
        SWI     XFont_ScanString
        ADD     sp,sp,R7
        MOV     R1,R3
        |
        SWI     XFont_StringBBox                        ; calls scanstring internally
        SUB     R1,R3,R1
        ADD     sp,sp,R7
        ]
        SWI     XFont_ConverttoOS
        MOV     R0,R1
        Pull    "PC"

textop_sysfontwidth
        ]
        MOV     R0,#0

textop_sysfontwidth_loop

        LDRB    R3,[R1],#1
        CMP     R3,#31
        ADDHI   R0,R0,#1
        CMPHI   R9,R0
        BHI     textop_sysfontwidth_loop
        MOV     R0,R0, LSL #4
        Pull    "PC"


textop_getsplitpoint
        ; In:
        ;  r1 -> string
        ;  r2 = width, OS units
        ;  r3 = split character
        ; Out:
        ;  r0 -> split point
        Push    "lr"

      [ outlinefont
        Push    "r3"
        LDR     r3,systemfont
        TEQ     r3,#0
        BEQ     textop_sysfontsplit

        Push    "r1,r2"
        MOV     r9,#bignum
      [ CnP
        MOV     r7,#-1
      ]
        MOV     r2,r1
        MOV     r1,#is_deleted
        BL      pushfontstring

        ADD     r3,r1,r7                ; point above stacked string
        LDMIB   r3,{r1,r8}              ; retrieve original r2,r3
        MOV     r2,#0
        SWI     XFont_Converttopoints

        MOV     r3,#0
        MOV     r4,#0
        MOV     r5,#0
        MOV     r6,#0
        Push    "r3-r6,r8"

        MOV     r5,sp
        MOV     r4,#0
        MOV     r3,r1
        MOV     r2,#1:SHL:5
        ADD     r1,sp,#20
        SWI     XFont_ScanString
        ADD     sp,sp,#20

        MOV     r2,sp
        MOV     r3,#0
        MOV     r6,#bignum
01      CMP     r2,r1
        BHS     %FT03
02      LDRB    r14,[r2]
        TEQ     r14,#26                 ; font change?
        ADDEQ   r2,r2,#2
        BEQ     %BT01                   ; skip it if so
      [ UTF8
        BL      skipcharR
      |
        ADD     r2,r2,#1
      ]
        CMP     r2,r1
        ADDLS   r3,r3,#1
        BLO     %BT02
03      ; r3 = number of characters to split point
        ADD     sp,sp,r7                ; junk pushed string
        Pull    "r2"                    ; retrieve original r1
        ADD     sp,sp,#8                ; junk original r2,r3
        CMP     r3,#0
        BEQ     %FT12
11
      [ UTF8
        BL      skipcharR
      |
        ADD     r2,r2,#1
      ]
        SUBS    r3,r3,#1
        BNE     %BT11
12      MOV     r0,r2
        Pull    "pc"

textop_sysfontsplit
        Pull    "r3"
      ]
        ; Can't cope properly with Unicode system font until appropriate APIs are designed
        MOV     r2,r2,LSR #4            ; r2 = width converted to 8-pixel-wide characters
        MOV     r0,r1                   ; initialise last-seen split character
        CMP     r2,#0
        BEQ     %FT22
        LDRB    r14,[r1],#1
21      CMP     r14,#31                 ; if we've hit the terminator
        SUBLS   r1,r1,#1                ;   then point r1 at the terminator
        BLS     %FT22                   ;   and break from loop
        LDRB    r14,[r1],#1             ; before looping (or not) to next character,
        CMP     r14,#31                 ;   see if it's going to be
        TEQLS   r14,r14                 ;   a terminator
        TEQNE   r14,r3                  ;   or a split character
        SUBEQ   r0,r1,#1                ;   and update last-seen split character if so
        SUBS    r2,r2,#1
        BNE     %BT21
        SUB     r1,r1,#1
22      CMP     r3,#-1                  ; if no split character
        MOVEQ   r0,r1                   ; then just point after last character
        Pull    "pc"


textop_truncate
        ; In:
        ;  r1 -> string
        ;  r2 -> output buffer
        ;  r3 = buffer size
        ;  r4 = max width, OS units
        ; Out:
        ;  r0 = size of buffer needed
        Push    "r1-r4,lr"
        MOV     r2,#0
        BL      textop_gettextwidth
        LDR     r4,[sp,#3*4]
        CMP     r0,r4
        BLS     %FT50

        LDR     r14,ellipsiswidth
        LDR     r1,[sp,#0*4]
        SUB     r2,r4,r14
        MOV     r3,#-1
        BL      textop_getsplitpoint

        Pull    "r1-r3"
        ADD     sp,sp,#4
        SUB     r4,r0,r1                ; r4 = length to copy from original string
        LDRB    r14,ellipsis+1
        TEQ     r14,#0
        MOVEQ   r5,#1                   ; r5 = length of ellipsis
        MOVNE   r5,#3
        ADD     r0,r4,r5
        ADD     r0,r0,#1

        CMP     r3,#0
        Pull    "pc", EQ
11      LDRB    r14,[r1],#1
        STRB    r14,[r2],#1             ; copy bytes from original string while buffer not full
        SUB     r4,r4,#1
        SUBS    r3,r3,#1
        TEQNE   r4,#0
        BNE     %BT11
        CMP     r3,#0
        Pull    "pc", EQ
        ADRL    r1,ellipsis
12      LDRB    r14,[r1],#1
        STRB    r14,[r2],#1
        SUB     r5,r5,#1
        SUBS    r3,r3,#1
        TEQNE   r5,#0
        BNE     %BT12
        CMP     r3,#0
        MOVNE   r14,#0
        STRNEB  r14,[r2]
        Pull    "pc"

50      ; String already fitted in width specified - copy into buffer
        Pull    "r1-r3"
        ADD     sp,sp,#4
        MOV     r4,#0
51      LDRB    r14,[r1,r4]
        ADD     r4,r4,#1                ; count bytes up to and including terminator
        CMP     r14,#' '
        BHS     %BT51
        ; Now r4 = buffer needed
        MOV     r0,r4
        CMP     r3,r4
        MOVHS   r3,r4
        CMP     r3,#0
        Pull    "pc", EQ
52      LDRB    r14,[r1],#1
        STRB    r14,[r2],#1             ; copy bytes including terminator, up to min (buffer size, string length)
        SUBS    r3,r3,#1
        BNE     %BT52
        Pull    "pc"


measure_ellipsis ; called from FindFont, sets things up for textop_truncate
        Entry   "r0-r5"
      [ UTF8
        BL      read_current_alphabet
        LDREQ   r0,=&A680E2             ; lookup not appropriate for UTF-8 - use &E2 &80 &A6
        BEQ     %FT05

        MOV     r1,#Service_International
        MOV     r2,#Inter_UCSTable
        LDRB    r3,alphabet
        SWI     XOS_ServiceCall
        TEQ     r1,#0                   ; not recognised? (or maybe old International module?)
        LDRNE   r0,=&2E2E2E             ; use "..." if so
        BNE     %FT05

        ADD     r4,r4,#&80*4            ; skip first &80 characters, unlikely to be ellipsis
        MOV     r3,#&80
        LDR     lr,=&2026               ; UCS-4 ellipsis is &2026
01      LDR     r0,[r4],#4
        TEQ     r0,lr
        SUBNES  r3,r3,#1
        BNE     %BT01
        TEQ     r3,#0
        LDREQ   r0,=&2E2E2E             ; use "..." if not in alphabet
        RSBNE   r0,r3,#&100             ; else use appropriate character
      |
        LDR     r0,=&2E2E2E
      ]
05      STR     r0,ellipsis

      [ outlinefont
        LDR     r0,systemfont
        TEQ     r0,#0
        BEQ     %FT50

10      SUB     sp,sp,#16
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#0
        MOV     r4,#0
        MOV     r5,#-1
        Push    "r1-r5"
        ADRL    r1,ellipsis
        LDR     r2,=1:SHL:18 :OR: 1:SHL:8 :OR: 1:SHL:5
        MOV     r3,#bignum/16
        MOV     r4,#bignum/16
        MOV     r5,sp
        SWI     XFont_ScanString
        ADD     sp,sp,#20
        Pull    "r1-r2,r5,r14"          ; get bounding box
        CMP     r5,r1
        CMPLE   r14,r2                  ; if bounding box has zero or negative width and height
        TEQLE   r3,#0
        TEQEQ   r4,#0                   ;   and offsets are both zero
        LDREQ   r0,=&2E2E2E             ;   then consider character to be undefined, so use "..."
        LDR     r14,ellipsis
        MOVNE   r0,r14
        TEQ     r0,r14                  ; if we've just changed to "..." then measure "..." instead
        STRNE   r0,ellipsis
        LDRNE   r0,systemfont
        BNE     %BT10

        LDR     r1,dx
        MOV     r2,#0
        SWI     XFont_Converttopoints
        SUB     r1,r1,#1
        ADD     r3,r3,r1
        BIC     r1,r3,r1                ; round up to next whole number of pixels (cos ConverttoOS will round down)
        SWI     XFont_ConverttoOS

        STR     r1,ellipsiswidth
        EXIT
50
      ]
        LDR     r0,ellipsis
        CMP     r0,#&100
        MOVHS   r0,#48
        MOVLO   r0,#16
        STR     r0,ellipsiswidth
        EXIT


SWIWimp_ResizeIcon
        MyEntry "ResizeIcon"

        AcceptLoosePointer_Neg R0,nullptr
        CMP     R0,#nullptr             ; equate to iconbar per PRM
        CMPNE   R0,#nullptr2            ; let through -2 as iconbar, seems natural
        LDREQ   handle,iconbarhandle
        MOVNE   handle,R0
        BL      checkhandle
        BVS     ExitWimp
        LDR     R0,[handle,#w_nicons]
        CMP     R1,R0
        BHI     badiconhandle
        CMP     R1,#0
        BMI     badiconhandle
        LDR     R0,[handle,#w_icons]
        ADD     R0,R0,R1, LSL #i_shift
        STMIA   R0,{R2-R5}
        B       ExitWimp

        [ UseDynamicArea
wimpspritepoolarea
        DCB     "WSpr"
wimpspritepool
        DCB     "WSP",0
        ALIGN
        ]

allocatespritememory
      [ UseDynamicArea
        Push    "R1,R8,LR"

        TEQ     R0,#ModHandReason_Claim
        BNE     %FT10
        ADR     R0,wimpspritepool               ; Look up name for Wimp sprite pool.
        ADR     R2,errorbuffer                  ; Put it in a safe place for now (copied out by OS_DynamicArea).
        MOV     R3,#256
        BL      LookupToken1
        Pull    "R1,R8,PC",VS
        MOV     R8,R2
        MOV     R0,#ModHandReason_Claim         ; Restore corrupted R0.
10
        LDR     R1,wimpspritepoolarea
        BL      Dynamic_Module
        Pull    "R1,R8,PC",VC

        MyXError WimpNoSprites
        Pull    "R1,R8,PC"
      |
	Push	"LR"
	SWI	XOS_Module
	Pull	"PC"
      ]

        MakeErrorBlock WimpNoSprites

badiconhandle
        ADRL    R0,ErrorBlock_WimpBadIconHandle
        SETV
        B       ExitWimp

badextend * ExitWimp

SWIWimp_Extend  ROUT
        MyEntry "Extend"

        CMP     R0,#WimpExtend_MAX
        ADDLO   PC,PC,R0,LSL #2
        B       extend_more
00
        B       badextend
        B       extend_workspace
        B       extend_jumptable
        B       extend_swicallback
        B       extend_spritenamepointers
        B       extend_tilingcallback
        B       extend_parent
        B       extend_frontchild
        B       extend_backchild
        B       extend_siblingabove
        B       extend_siblingbehind
        B       extend_getborderinfo
        B       extend_ncerrorpointersuspend
        B       extend_spritesuffix
        ASSERT . - %BT00 = WimpExtend_MAX*4

extend_more
        SUB     R14,R0,#256
        CMP     R14,#WimpExtend_SpriteSuffix_ROL-256
        BEQ     extend_spritesuffix_rol
        B       badextend

extend_workspace
        MOV     R0,R12
        B       ExitWimp

extend_jumptable
        ADR     R0,extendjumptable
        B       ExitWimp

extend_swicallback
        LDR     R0,wimpswiintercept
        STR     R1,wimpswiintercept
        B       ExitWimp

extend_spritenamepointers
        ADR     R0,spritename
        ADRL    R1,list_at
        STR     R1,[sp]
        B       ExitWimp

extend_tilingcallback
        LDR     R0,plotsprCB
        STR     R1,plotsprCB
        B       ExitWimp

      [ ChildWindows
extend_parent
extend_frontchild
extend_backchild
extend_siblingabove
extend_siblingbehind
        ROUT
        ; In: R0 = 6 => get parent, 7,8 => get top/bottom child, 9,10 => get next/previous sibling
        ;     R1 = window handle, or -1 for top-level
        ; Out: R1 = result handle, or -1 for none
        CMP     R1,#nullptr
        BEQ     %FT05

        MOV     handle,R1
        BL      checkhandle_iconbar
        BVS     ExitWimp

        CMP     R0,#WimpExtend_FrontChild
        LDRLO   handle,[handle,#w_parent]
        BLO     %FT03

        LDREQ   handle,[handle,#w_children + lh_forwards]
        BEQ     %FT02

        CMP     R0,#WimpExtend_SiblingAbove
        LDRLO   handle,[handle,#w_children + lh_backwards]
        BLO     %FT02

        LDR     R14,[handle,#w_flags]
        TST     R14,#ws_open                    ; sibling pointers are garbage if window is not open
        MOVEQ   handle,#nullptr
        BEQ     %FT04

        CMP     R0,#WimpExtend_SiblingAbove
        LDREQ   handle,[handle,#w_active_link + ll_forwards]
        LDRHI   handle,[handle,#w_active_link + ll_backwards]

02      CMP     handle,#nullptr
        LDRNE   R14,[handle,#ll_forwards]       ; if either forward or backward pointer is null, we're at the head entry (not a window)
        CMPNE   R14,#nullptr
        LDRNE   R14,[handle,#ll_backwards]
        CMPNE   R14,#nullptr
        MOVEQ   handle,#nullptr
        SUBNE   handle,handle,#w_active_link

03      CMP     handle,#nullptr
        Rel     handle,handle,NE

04      STR     handle,[sp]
        B       ExitWimp

05      CMP     R0,#WimpExtend_FrontChild
        LDREQ   handle,activewinds + lh_forwards
        BEQ     %BT02

        CMP     R0,#WimpExtend_BackChild
        LDREQ   handle,activewinds + lh_backwards
        BEQ     %BT02

        B       ExitWimp
      |
extend_parent * badextend
extend_frontchild * badextend
extend_backchild * badextend
extend_siblingabove * badextend
extend_siblingbehind * badextend
      ]

      [ NCErrorBox
        ; Handle hiding of pointer for the duration of keyboard-driving of pointer
extend_ncerrorpointersuspend
        MOV     R0, #106
        MOV     R1, #0
        SWI     XOS_Byte        ; turn off pointer
        MOV     R0, #1
        ADRL    R14, ptrsuspendflag
        STR     R0, [R14]
        B       ExitWimp
      |
extend_ncerrorpointersuspend * badextend      
      ]

extend_spritesuffix ROUT
        ; Work out for the client what resolution suffix to append to a sprites file
        ; First available in Wimp 4.85
        ; Older Wimps don't return error, but can be detected because all registers are preserved
        ; On entry:
        ;   r0 = 13 (reason code)
        ;   r1 -> pathname of file without suffix
        ;   r2 -> buffer for result
        ;   r3 = size of buffer (0 to read size required)
        ; On exit:
        ;   r0 corrupted
        ;   r3 = space left in buffer (ie negative of size required if r3=0 on entry)
        ;   other registers preserved
        ;   contents of buffer are only valid if r3>=0
        ;   error "File not found" may be returned
        MOV     R0, R1
loop1   LDRB    LR, [R0], #1
        CMP     LR, #32
        BCS     loop1
        SUB     R0, R0, R1      ; length of original string (incl terminator)
        ADD     R0, R0, #2      ; for the moment, we know the resultant string will be at most 2 bytes longer

        SUBS    R3, R3, R0
        STR     R3, [SP, #2*4]  ; put result in stack frame
        BMI     ExitWimp        ; exit now if buffer not big enough

loop2   LDRB    LR, [R1], #1
        CMP     LR, #32
        STRCSB  LR, [R2], #1    ; copy string into buffer
        BCS     loop2
        MOV     LR, #0
        STRB    LR, [R2, #2]    ; insert terminator after two more characters

        LDRB    R5, romspr_suffix
        LDRB    R6, romspr_suffix+1
        SUB     R5, R5, #'0'
        SUB     R6, R6, #'0'
loop3
      [ SpritesA
        CMP     R5,R6
        LDREQB  R0,alphaspriteflag
        CMPEQ   R0,#255
        MOVEQ   R5,#'A'-'0'     ; Try alpha before square pixels
      ]
loop4   ADD     LR, R5, #'0'
        STRB    LR, [R2]
        ADD     LR, R6, #'0'
        STRB    LR, [R2, #1]
        MOV     R0, #&4C        ; try opening a file on File$Path (matches *SLoad etc)
        LDR     R1, [SP, #1*4]  ; retrieve pointer to start of buffer
        SWI     XOS_Find
        MOVVC   R1, R0
        MOVVC   R0, #0
        SWIVC   XOS_Find
        BVC     ExitWimp        ; buffer contains a valid file, so exit

      [ SpritesA
        CMP     R5,#'A'-'0'
        MOVEQ   R5,R6
        BEQ     loop4           ; Try square pixels if alpha failed
      ]

        TEQ     R6, #3
        MOVEQ   R6, #2
        BEQ     loop3           ; after Sprites23, try Sprites22

        CMP     R5, R6
        MOVLO   R5, R5, LSL #1
        MOVHI   R6, R6, LSL #1
        BNE     loop3           ; after rectangular pixels, try next squarer version

      [ Sprites11
        TEQ     R5, #1
        MOVEQ   R5, #2
        MOVEQ   R6, #2
        BEQ     loop3           ; after Sprites11, try Sprites22
      ]

      [ SpritesA
        LDRB    R0,alphaspriteflag
        CMP     R0,#0
        BEQ     %FT135
        MOV     R14,#'A'
        STRB    R14,[R2]
        MOV     R14,#0
        STRB    R14,[R2,#1]
        MOV     R0, #&4C
        LDR     R1, [SP, #1*4]
        SWI     XOS_Find        ; try just <filename>A before falling back to the original
        MOVVC   R1, R0
        MOVVC   R0, #0
        SWIVC   XOS_Find
        BVC     ExitWimp
135
      ]

        MOV     LR, #0
        STRB    LR, [R2]
        MOV     R0, #&4C
        LDR     R1, [SP, #1*4]
        SWI     XOS_Find        ; finally, try with no suffix
        MOVVC   R1, R0
        MOVVC   R0, #0
        SWIVC   XOS_Find
        B       ExitWimp        ; return any error we got from this last one

extend_spritesuffix_rol ROUT
        ; In:   R1 = buffer containing pathname of file with no suffix
        ; Out:  R0 = buffer passed in
        ;       R1 = 0 (to indicate call supported by Wimp version)
        ; This is effectively the same as Wimp_Extend 13, except the name is
        ; updated in-place, and no error is returned if no suitable file is
        ; found.
        ; To keep things simple, we'll just allocate a temporary buffer from the
        ; RMA and call Wimp_Extend 13.
        MOV     R3, #0
        STR     R3, [SP]
10
        LDRB    R0, [R1, R3]
        ADD     R3, R3, #1
        CMP     R0, #32
        BCS     %BT10
        ADD     R3, R3, #2
        MOV     R0, #ModHandReason_Claim
        BL     XROS_Module
        BVS     %FT90           ; Give up if no memory
        MOV     R0, #WimpExtend_SpriteSuffix
        SWI     XWimp_Extend
        BVS     %FT30
        ; Copy result to original buffer
        MOV     R3, #0
20
        LDRB    R0, [R2, R3]
        STRB    R0, [R1, R3]
        CMP     R0, #32
        ADD     R3, R3, #1
        BCS     %BT20
30
        MOV     R0, #ModHandReason_Free
        BL     XROS_Module
90
        MOV     R0, R1
        CLRV
        B       ExitWimp


extendjumptable
        B       getspriteaddr
      [ CnP
        B       extendjumptable_pushfontstring
      |
        B       pushfontstring
      ]
        B       callaswi
        B       ExitWimp
        B       ExitWimp2
        B       godrawicon
        B       exitcicon
        B       int_setcolour

      [ CnP
extendjumptable_pushfontstring
        MOV     R7, #nullptr
        B       pushfontstring
      ]
                     ^  0, userblk
furnblock_handle     #  4
furnblock_lborder    #  4
furnblock_bborder    #  4
furnblock_rborder    #  4
furnblock_tborder    #  4
furnblock_back       #  4
furnblock_close      #  4
furnblock_titlegap0  #  4
furnblock_title      #  4
furnblock_titlegap1  #  4
furnblock_iconise    #  4
furnblock_togglew    #  4
furnblock_toggleh    #  4
furnblock_vscrgap1   #  4
furnblock_up         #  4
furnblock_vscr       #  4
furnblock_down       #  4
furnblock_vscrgap0   #  4
furnblock_adjusth    #  4
furnblock_adjustw    #  4
furnblock_hscrgap1   #  4
furnblock_right      #  4
furnblock_hscr       #  4
furnblock_left       #  4
furnblock_hscrgap0   #  4

extend_getborderinfo ROUT
        ; In: R1 = pointer to block to fill with furniture dimensions
        ;     [R1,#0] = window handle to use, or 0 for generic values
        CMP     userblk, #ApplicationStart
        MyXError  WimpBadPtrInR1, LO, L
        BVS     ExitWimp                ; check pointer valid in this case

        LDR     handle, furnblock_handle
        TEQ     handle, #0
        BEQ     %FT01

        BL      checkhandle_iconbar
        BVS     ExitWimp
        ADD     R0, handle, #w_ow0
        LDMIA   R0, {cx0, cy0, cx1, cy1} ; cx0-cy1 = visible area
        LDMIA   R0, {x0, y0, x1, y1}     ; x0-y1 = visible area
        BL      calc_w_x0y0x1y1          ; x0-y1 = window outline
        SUB     R0, cx0, x0
        STR     R0, furnblock_lborder
        SUB     R0, cy0, y0
        STR     R0, furnblock_bborder
        SUB     R0, x1, cx1
        STR     R0, furnblock_rborder
        SUB     R0, y1, cy1
        STR     R0, furnblock_tborder
        SUB     x1, x1, x0               ; calc total lengths of sides - top edge
        SUB     y1, y1, y0               ; - right edge
        MOV     x0, x1                   ; - bottom edge
        LDR     R14, [handle, #w_flags]  ; load flags
        LDR     R1, [handle, #w_parent]  ; get parent
        B       %FT02

01      LDR     R0, dx                   ; assume max border widths
        STR     R0, furnblock_lborder
        LDR     R0, hscroll_height1
        STR     R0, furnblock_bborder
        LDR     R0, vscroll_width1
        STR     R0, furnblock_rborder
        LDR     R0, title_height1
        STR     R0, furnblock_tborder
        MOV     x1, #&200                ; assume reasonably large
        MOV     y1, x1
        MOV     x0, x1
        MOV     R14, #wf_iconbits        ; assume all border flags set
        MOV     R1, #-1                  ; assume a top-level window

02
        TST     R14, #wf_icon1           ; back icon?
        LDRNE   R0, back_width
        MOVEQ   R0, #0
        SUB     x1, x1, R0
        STR     R0, furnblock_back

        TST     R14, #wf_icon2           ; close / iconise icons?
        LDRNE   R0, close_width
        MOVEQ   R0, #0
        SUB     x1, x1, R0
        STR     R0, furnblock_close
      [ IconiseButton
        BEQ     %FT06
        MOV     R0, #0
        CMP     R1, #-1
        BNE     %FT06 ; no iconise button on children
        LDRB    R1, iconisebutton
        TEQ     R1, #0
        BEQ     %FT06
        LDR     R0, iconise_width
06
      |
        MOV     R0, #0
      ]
        SUB     x1, x1, R0
        STR     R0, furnblock_iconise

        TST     R14, #wf_icon4           ; toggle-size icon?
        LDRNE   R0, vscroll_width
        MOVEQ   R0, #0
        SUB     x1, x1, R0
        STR     R0, furnblock_togglew
        LDRNE   R0, title_height
        SUB     y1, y1, R0
        STR     R0, furnblock_toggleh

        TST     R14, #wf_icon3           ; title bar?
        MOVEQ   x1, #0
        STR     x1, furnblock_title

        MOV     R0, #0
        STR     R0, furnblock_titlegap0  ; provided to support future expansion
        STR     R0, furnblock_titlegap1  ; eg extra buttons, or a squashable title bar

        MVN     R0, R14
        TST     R0, #wf_icon5 :OR: wf_icon7
        TSTNE   R0, #wf_icon6            ; adjust-size / blank?
        LDREQ   R0, hscroll_height
        MOVNE   R0, #0
        SUB     y1, y1, R0
        STR     R0, furnblock_adjusth
        LDREQ   R0, vscroll_width
        SUB     x0, x0, R0
        STR     R0, furnblock_adjustw

        TST     R14, #wf_icon5           ; if no vscroll, clear the vscroll words
        MOV     R0, #0
        STREQ   R0, furnblock_vscrgap1
        STREQ   R0, furnblock_up
        STREQ   R0, furnblock_vscr
        STREQ   R0, furnblock_down
        STREQ   R0, furnblock_vscrgap0
        BEQ     %FT04

        Push    "R14"
        TEQ     handle, #0
;       MOVEQ   R0, #0                   ; gap0 = 0
        MOVEQ   R14, #0                  ; gap1 = 0
        BEQ     %FT03
      [ ChildWindows
        Push    "x0,y1"                  ; determine vertical gaps
        MOV     R0, #iconposn_vscroll
        BL      calc_w_iconposn2
        SUB     R0, y0, cy0
        SUB     R14, cy1, y1
        Pull    "x0,y1"
      ]
03      STR     R0, furnblock_vscrgap0
        STR     R14, furnblock_vscrgap1
        SUB     y1, y1, R0
        SUBS    y1, y1, R14

;       CMP     y1, #0                   ; see if vertical arrows are squashed
        MOVLE   cy0, #0                  ; arrows given 0 length if scrollbar has -ve length (it can happen!)
        MOVLE   cy1, #0
        LDRGT   cy0, down_height         ; standard lengths
        LDRGT   cy1, up_height
        ADDGT   R14, cy0, cy1
        RSBGTS  R0, y1, R14
        MOVGT   cy0, y1, LSR#1           ; which may be squashed
        SUBGT   cy1, y1, cy0
        SUB     y1, y1, cy0              ; take arrows from the bar length to give the well length
        SUB     y1, y1, cy1
        STR     cy1, furnblock_up
        STR     y1, furnblock_vscr
        STR     cy0, furnblock_down
        Pull    "R14"

04
        TST     R14, #wf_icon7           ; if no hscroll, clear the hscroll words
        MOV     R0, #0
        STREQ   R0, furnblock_hscrgap1
        STREQ   R0, furnblock_right
        STREQ   R0, furnblock_hscr
        STREQ   R0, furnblock_left
        STREQ   R0, furnblock_hscrgap0
        BEQ     ExitWimp                 ; all done

        TEQ     handle, #0
;       MOVEQ   R0, #0                   ; gap0 = 0
        MOVEQ   R14, #0                  ; gap1 = 0
        BEQ     %FT05
      [ ChildWindows
        Push    "x0"                     ; determine horizontal gaps
        MOV     R0, #iconposn_hscroll
        BL      calc_w_iconposn2
        SUB     R0, x0, cx0
        SUB     R14, cx1, x1
        Pull    "x0"
      ]
05      STR     R0, furnblock_hscrgap0
        STR     R14, furnblock_hscrgap1
        SUB     x0, x0, R0
        SUBS    x0, x0, R14

;       CMP     x0, #0                   ; see if horizontal arrows are squashed
        MOVLE   cx0, #0                  ; arrows given 0 length if scrollbar has -ve length (it can happen!)
        MOVLE   cx1, #0
        LDRGT   cx0, left_width          ; standard lengths
        LDRGT   cx1, right_width
        ADDGT   R14, cx0, cx1
        RSBGTS  R0, x0, R14
        MOVGT   cx0, x0, LSR#1           ; which may be squashed
        SUBGT   cx1, x0, cx0
        SUB     x0, x0, cx0              ; take arrows from the bar length to give the well length
        SUB     x0, x0, cx1
        STR     cx1, furnblock_right
        STR     x0, furnblock_hscr
        STR     cx0, furnblock_left
        B       ExitWimp                 ; all done

        END
@


4.17
log
@Change Wimp_ReadSysInfo 2 to not return alpha sprite names. Add Wimp_ReadSysInfo 29 and Wimp_Extend 257.
Detail:
  s/Wimp01 - Change romspr_suffix initialisation so that it won't store alpha sprite suffixes. This has the knock-on effect of making Wimp_ReadSysInfo 2 no longer return alpha sprite suffixes, without affecting any of the sprite search code
  hdr/Wimp, s/Wimp01 - Add Wimp_ReadSysInfo 29 to read the alphaspriteflag value - i.e. whether alpha sprites are supported by the OS/Wimp and *IconSprites, Wimp_Extend 13, etc. will look for them
  hdr/Wimp - Document the private Wimp_Extend reason codes and add a couple of ROL's reason codes
  s/NewSWIs - Tidy up Wimp_Extend implementation to use a jump table instead of a load of tests and branches. Add an implementation of ROL's Wimp_Extend 257, which just acts as a wrapper around Wimp_Extend 13
Admin:
  Tested on Raspberry Pi
  Wimp_ReadSysInfo 2 change should fix issue reported on forums with software unexpectedly using low-res sprites or failing altogether:
  http://www.riscosopen.org/forum/forums/4/topics/2274


Version 5.35. Tagged as 'Wimp-5_35'
@
text
@d599 1
a599 1
        ADR     R1,list_at
@


4.16
log
@Add support for *iconspriting of alpha-masked sprites. Fix icon shading/inverting to work with true colour sprites.
Detail:
  Options/s/!Default, s/NewSWIs, s/Wimp01:

  Updated ROM sprite find code, *IconSprites and Wimp_Extend 13 to understand a new spritefile suffix.
  If the Wimp detects that RISC OS Select style alpha masked sprites are supported, and we're not using the mode 23 sprites, then the code will enable support for alpha masked sprites of the form !SpritesA1, !SpritesA2, !SpritesA, etc. Alpha-masked sprites are only looked for when looking for square pixel sprites or just before looking for the default sprites. This means the full search pattern for (e.g.) a !Sprites21 mode would be as follows:

  !Sprites21  (original mode)
  !SpritesA2  (next squarer mode, alpha sprites)
  !Sprites22  (next squarer mode)
  !SpritesA   (default alpha sprites)
  !Sprites    (default sprites)

  Like with !Sprites11 support, this feature can be toggled off via the SpritesA option if necessary.

  s/Wimp01, s/Wimp04:

  Updated icon plotting code (wimp_SpriteOp_putsprite and calculateinverse) to allow true colour sprites/icons to be rendered shaded/inverted.
  For this to work the Wimp needs a version of SpriteExtend which supports colour mapping (specifically it checks for the relevant ROOL version number).
  The colour mapping function which is used to build the translation tables used for shading/inverting palettised sprites is too slow to be sensibly used on a per-pixel basis, so the first time a shaded/inverted true colour sprite is requested the Wimp will generate a set of lookup tables which can be used by a much simpler colour mapping routine.
  To keep memory usage down these lookup tables only use 4K colours each; however the quality isn't always that great and so this may need revising in future.

Admin:
  Tested on BB-xM


Version 5.34. Tagged as 'Wimp-5_34'
@
text
@d553 3
a555 1
SWIWimp_Extend
d558 48
a605 32
        TEQ     R0,#1
        MOVEQ   R0,R12
        BEQ     ExitWimp
        TEQ     R0,#2
        ADREQ   R0,extendjumptable
        BEQ     ExitWimp
        TEQ     R0,#3
        LDREQ   R0,wimpswiintercept
        STREQ   R1,wimpswiintercept
        BEQ     ExitWimp
        TEQ     R0,#4
        ADREQ   R0,spritename
        ADREQ   R1,list_at
        STREQ   R1,[sp]
        BEQ     ExitWimp
        TEQ     R0,#5
        LDREQ   R0,plotsprCB
        STREQ   R1,plotsprCB
        BEQ     ExitWimp
      [ ChildWindows
        CMP     R0,#6                   ; In: R0 = 6 => get parent, 7,8 => get top/bottom child, 9,10 => get next/previous sibling
        RSBHSS  R14,R0,#10              ; In: R1 = window handle, or -1 for top-level ; Out: R1 = result handle, or -1 for none
        BHS     %FT01
      ]
        TEQ     R0,#11                  ; In: R1 = pointer to block to fill with furniture dimensions
        BEQ     %FT11                   ;     [R1,#0] = window handle to use, or 0 for generic values
      [ NCErrorBox
        TEQ     R0,#12
        BEQ     %FT12
      ]
        TEQ     R0,#13
        BEQ     %FT13
d609 10
a618 2

01      CMP     R1,#nullptr
d625 1
a625 1
        CMP     R0,#7
d632 1
a632 1
        CMP     R0,#9
d641 1
a641 1
        CMP     R0,#9
d659 1
a659 1
05      CMP     R0,#7
d663 1
a663 1
        CMP     R0,#8
d668 6
d678 2
a679 1
12      MOV     R0, #106
d686 2
d690 2
a691 1
13      ; Work out for the client what resolution suffix to append to a sprites file
d796 40
d882 3
a884 1
11
@


4.15
log
@Refinements to disc based targets especially
Previous attempt to disable Sprites11 support for 3.10 and 3.50 hadn't spotted it was reenabled in the common options, also the Sprites11 switch was also tied up in Wimp$IconTheme support.
Title bars would flicker when picked up when using a tool sprite set with no 'p' pushed equivalents on RISC OS 4.0x due to screen cache.
Makefile now installs a default set of tools & sprites when target is ThemeDefs.
CLI limit reduced to 256 pre Ursula to save RAM.

Options/!Common:
  Promote Sprites11 switch into !Default
  Remove fixrmatools
Options/!Default:
  Sprites11 true by default
  LongCommandLines true by default, false on targets pre Ursula
  Remove ServiceCallTable (harmless to have it in all cases)
NewSWIs.s:
  Enable Wimp_Extend 13 all the time
Wimp01.s:
  Reduce RMA use by vital 1.5k for non long command line case
  Change sense of Sprites11 switch to adopt all its previous functionality, but not look for '11' suffix when the switch is false
  Adopt ServiceCallTable switch permanently
Wimp02.s:
  Comments ammended
Wimp07.s:
  Range of ADR
Wimp10.s:
  Change sense of Sprites11 switch to adopt all its previous functionality, but not look for '11' suffix when the switch is false
  Adopt :LNOT: fixrmatools switch permanently
  Supress title bar sprite plotting when none of the sprites exist

Version 5.25. Tagged as 'Wimp-5_25'
@
text
@d691 8
a698 1
loop3   ADD     LR, R5, #'0'
d710 6
d731 19
@


4.14
log
@Slacken pointer checks
The pointer comparison checking required when running in a system with > 64M memory was tightened up from Wimp-4_75 to Wimp-4_76, but to allow the module to target pre RISC OS 5 systems an option to relax those checks is required.
Each check has been revisited and where appropriate demarked with a "AcceptLoosePointer" macro, which just remaps the pointer into the stricter form and carries on. In the strict checking case, the macro reduces to nothing.

Detail:
Add AcceptLoosePointers switch.
Retire singular use of StrongARM switch (calling XOS_SynchroniseCodeAreas is harmless pre StrongARM anyway).
Rename Ursula_RPC options to RO400.
Put duplicate documentation in the attic.
Allow -2 or -1 as the iconbar handle in Wimp_ResizeIcon (ticket #203).
Tighten up the list terminator check in the DebugMemory switch of Memory.s

Tested on RISC OS 3.10 (emulated), 3.50, 3.60, 3.70, 4.02.

Version 5.24. Tagged as 'Wimp-5_24'
@
text
@a585 1
      [ Sprites11
a587 1
      ]
a654 1
      [ Sprites11
d712 1
d717 1
a717 1

a726 1
      ]
@


4.13
log
@Build fixes for variants pre RISC OS 5
Minor fixups as part of univeral !Boot work.
Options no longer ASSERT on International_Help (which is a definition exported by the kernel, rather than a build switch), and instead define a switch which is true for > 3.50.
Non UTF8 supporting case has simple substitutes for Wimp_TextOp.
Legacy_DomainId and LegacyIRQsema no longer cause NULL pointer dereference.
MOVeQ => MOVEQ to placate ObjAsm.

Ursula_RPC version built and used briefly on RISC OS 4.02 host. No other run time testing.

Version 5.22. Tagged as 'Wimp-5_22'
@
text
@d495 3
a497 1
        CMP     R0,#nullptr
@


4.12
log
@Get of international module header.
Retagged as Wimp-5_14.
@
text
@a276 1
        ASSERT  UTF8
d286 1
d288 3
d300 6
a305 1
11      BL      skipcharR
d412 1
d435 3
a437 1

@


4.11
log
@Changes from Kevin:
* New options file for STB
* Changed some ADRs to ADRLs so that they reach for the options combination
  for STB

Version 4.92. Tagged as 'Wimp-4_92'
@
text
@d409 1
a409 1
        MOV     r2,#8 ; Inter_UCSTable
@


4.10
log
@Added a new window flag (extra flags byte bit 4) to indicate that
Wimp_GetPointerInfo should include shaded icons, in particular so that they
can now have interactive help. Included some information on RISC OS Select
APIs so that we can avoid clashes.

Version 4.89. Tagged as 'Wimp-4_89'
@
text
@d369 1
a369 1
        ADR     r1,ellipsis
d441 1
a441 1
        ADR     r1,ellipsis
@


4.9
log
@Added a couple of new Wimp_TextOp reason codes. Current clients are Filer
2.08 and Pinboard 0.80.

Version 4.88. Tagged as 'Wimp-4_88'
@
text
@d185 1
@


4.8
log
@  Menu bugfixes and sprite variation support.
Detail:
  * Adjust clicking on menu items was leading to Message_MenusDeleted being
    broadcast, resulting in incorrect behaviour in many applications.
  * Sprite-only menu items (eg !Draw's line pattern submenu) now highlight
    correctly when tiled menus are configured.
  * Added Wimp_Extend 13, which works out the appropriate resolution suffix
    for a given sprite pathname - required since Sprites11 support needs
    an iterative approach. This supercedes Wimp_ReadSysInfo 2.
  * *IconSprites now tries prefixing the last element of its path argument
    with "<Wimp$IconTheme>".
Admin:
  Tested on Tungsten.

Version 4.85. Tagged as 'Wimp-4_85'
@
text
@d21 2
a22 4
        TEQ     userblk,#0
        TEQNE   userblk,#1
        TEQNE   userblk,#2
        SETV    NE
a24 2
        TEQ     userblk,#0
        BLEQ    textop_setcolours
a28 1
        STR     R14,validationstring
d30 12
a41 4
        TEQ     userblk,#1
        BLEQ    textop_gettextwidth
        TEQ     userblk,#2
        BLEQ    textop_painttext
d189 1
a189 1
        MOVHI   R9,R2
d231 248
@


4.7
log
@  Given a good thrashing.
Detail:
  All pointers passed to the Wimp (mode selectors, menus, sprite areas,
  palettes, pollwords, validation strings, message lists, routines etc etc)
  in any of its APIs can now be anywhere within the 32-bit address range.
  In general, whenever "<= 0" was accepted as a null condition, the value
  must now be either 0 or -1. It should also be tolerant of system memory
  areas (supervisor stack and RMA) being in the top half of memory.
  Also:
  * Default next slot now a build option - Ursula builds (eg Tungsten) use
    1024K instead of 640K
  * Ursula builds no longer have a build variant in the help string
  * Autosenses ROM location
  * CR-LFs in *Configure messages replaced with LF-CRs
  * Added Iyonix resources (currently based on Morris4)
  * Morris4 sprites files have gained file_lxa, small_lxa, file_unf,
    small_unf and lo!help sprites
  * Ursula sprites files have gained lo!help sprites
  * *WimpSlot can take memory sizes in megabytes or gigabytes
Admin:
  Tested on a "traditional" memory-mapped Tungsten.

Version 4.76. Tagged as 'Wimp-4_76'
@
text
@d321 4
d390 74
@


4.6
log
@  Made 32-bit compatible.
Detail:
  Lots of little changes throughout a lot of source.
Admin:
  Appears to work - not stress tested with things like lots of tasks, big
  transfers, and all the other things that tend to go wrong.

Version 4.47. Tagged as 'Wimp-4_47'
@
text
@d166 2
a167 2
        ADDGT   R0,R0,#1
        BGT     systemfontlength
d186 1
a186 1
        MOVGT   R9,R2
d223 3
a225 3
        ADDGT   R0,R0,#1
        CMPGT   R9,R0
        BGT     textop_sysfontwidth_loop
d232 3
a234 3
        CMP     R0,#0
        LDRLT   handle,iconbarhandle
        MOVGE   handle,R0
d239 1
a239 1
        BGT     badiconhandle
d241 1
a241 1
        BLT     badiconhandle
d312 2
a313 2
        RSBGES  R14,R0,#10              ; In: R1 = window handle, or -1 for top-level ; Out: R1 = result handle, or -1 for none
        BGE     %FT01
d333 2
a334 2
        LDRLT   handle,[handle,#w_parent]
        BLT     %FT03
d340 2
a341 2
        LDRLT   handle,[handle,#w_children + lh_backwards]
        BLT     %FT02
d350 1
a350 1
        LDRGT   handle,[handle,#w_active_link + ll_backwards]
d436 1
a436 1
        MyXError  WimpBadPtrInR1, LT, L
@


4.5
log
@Optimisation to new WimpSymbol substitution code: in icons containing fonts
  other than the desktop font, the substitution table is only calculated
  when a symbol character is encountered.
Embryonic cut-n-paste support introduced (currently in desktop builds only):
  * workspace is allocated and initialised;
  * extended Wimp_GetCaretPosition implemented;
  * pushfontstring adapted to allow insertion of arbitrary control sequences in
    font strings (to allow selected text to be plotted in inverted colours).
Inverted, unfilled text icons now work properly again in <256-colour modes.
Reworked NC error box code: see Doc.IconHigh.

Version 4.11. Tagged as 'Wimp-4_11'
@
text
@d271 1
a271 1
        Pull    "R1,R8,PC",VC,^
d434 1
a434 1
11      
d438 1
a438 1
        
d442 1
a442 1
        
d463 1
a463 1
        
d478 1
a478 1
02      
d484 1
a484 1
        
d505 1
a505 1
        
d514 1
a514 1
        
d518 1
a518 1
        
d522 1
a522 1
        
d533 1
a533 1
        
d542 1
a542 1
        
d560 1
a560 1
        
d576 2
a577 2
        
04      
d586 1
a586 1
        
d603 1
a603 1
        
@


4.4
log
@Ursula branch Wimp merged back onto trunk.
@
text
@d79 3
d195 3
d317 4
d377 11
d390 3
d394 1
d402 5
@


4.3
log
@ARTtmp branch folded in
@
text
@d18 2
d53 1
a53 1
        SWI     ColourTrans_SetGCOL
d56 1
a56 1
        SWIVC   ColourTrans_SetGCOL
d224 2
d283 2
d309 2
d376 213
@


4.3.2.1
log
@Main new features in Ursula build so far
(some are also available in other builds):

* New icon highlighting scheme - hue rotated 180 degrees, photographic negative,
  darkened 25% - suits Ursula icons better.
* Release-button window tools compile-time switch turned on.
* Any "TASK" word cleared on exit from Wimp_OpenWindow, Wimp_GetWindowState,
  Wimp_ForceRedraw and Wimp_CloseDown.
* Child windows are no longer allowed to be opened inside the icon bar.
* Message_IconizeAt generation optimised, and no longer calls non-X SWIs.
* Message_IconsChanged implemented, and switched out on speed grounds.
* Wimp_ReadSysInfo 15 removed, replaced with (new) Wimp_Extend 11.
* Backwindows are now segregated from normal windows. A new category,
  foreground windows, are added, and stay above all other windows. (The error
  box template is updated to make it a foreground window.)
* ROM sprites override RAM sprites (and duplicate RAM sprites are deleted
  during the building of the sprite lookup list, preceding the first sprite
  plot after a sprite pool update).
* Wimp_ReadSysInfo 16 added, to return sprite area pointers in order of
  priority (Wimp_BaseOfSprites retains the ROM/RAM distinction).
* Error box code altered:
  + symbolic names used for offsets into tempworkspace
  + error button text buffer enlarged
  + stretched error buttons now shrink back for next use
  + int_flush_opens called at appropriate points to ensure buttons are seen to
    slab in, and to reduce flicker when redisplaying error box at a different
    width (also fixes some redraw bugs)
  + Cancel button given the R6 type border when it will be activated by Return
    (and is therefore moved to the extreme right in such cases)
  + Escape now always selects the second-right button (unless there's only one
    button!) - this also fixes a bug when there's a single user-defined button
  + keypresses in "xxx may have gone wrong" error boxes are now correctly
    interpreted - previously the buttons available in the underlying box were
    being used to determine the effect of keys
  + maximum number of buttons increased from 4 to 8, and the machine no longer
    crashes when the maximum is exceeded
  + window stretches horizontally to keep error message to 7 lines or less
* Bugfix: opening or creating a window with a minimum x visible area coordinate
  of -1 was leading to any of smearing/flickering/recursive drawing. (This was
  actually due to a failure to recognise which windows' positions had been
  updated.)
* Features merged in from spinner branch Wimp:
  + support for UpCall_MediaSearchEndMessage added
  + control-termination allowed in upcalls (used to require null-termination)
  + escape character switched to default during error box display, then
    switched back again afterwards
* GetRectangle filters are now called with (internal) window handle in R10.
* Autohourglass is deactivated whenever WrchV is invoked. (Also optimised.)
* Action button bugfixes:
  + action buttons now deselect if the pointer is dragged off and a window tool
    is the pressed before all the buttons have been released
  + action buttons now slab in following a long (autorepeating) press on a
    scroll arrow window tool
@
text
@a302 2
        TEQ     R0,#11                  ; In: R1 = pointer to block to fill with furniture dimensions
        BEQ     %FT11                   ;     [R1,#0] = window handle to use, or 0 for generic values
a367 199

                     ^  0, R1
furnblock_handle     #  4
furnblock_lborder    #  4
furnblock_bborder    #  4
furnblock_rborder    #  4
furnblock_tborder    #  4
furnblock_back       #  4
furnblock_close      #  4
furnblock_titlegap0  #  4
furnblock_title      #  4
furnblock_titlegap1  #  4
furnblock_iconise    #  4
furnblock_togglew    #  4
furnblock_toggleh    #  4
furnblock_vscrgap1   #  4
furnblock_up         #  4
furnblock_vscr       #  4
furnblock_down       #  4
furnblock_vscrgap0   #  4
furnblock_adjusth    #  4
furnblock_adjustw    #  4
furnblock_hscrgap1   #  4
furnblock_right      #  4
furnblock_hscr       #  4
furnblock_left       #  4
furnblock_hscrgap0   #  4

11      
        LDR     handle, furnblock_handle
        TEQ     handle, #0
        BEQ     %FT01
        
        BL      checkhandle_iconbar
        BVS     ExitWimp
        ADD     R0, handle, #w_ow0
        LDMIA   R0, {cx0, cy0, cx1, cy1} ; cx0-cy1 = visible area
        LDMIA   R0, {x0, y0, x1, y1}     ; x0-y1 = visible area
        BL      calc_w_x0y0x1y1          ; x0-y1 = window outline
        SUB     R0, cx0, x0
        STR     R0, furnblock_lborder
        SUB     R0, cy0, y0
        STR     R0, furnblock_bborder
        SUB     R0, x1, cx1
        STR     R0, furnblock_rborder
        SUB     R0, y1, cy1
        STR     R0, furnblock_tborder
        SUB     x1, x1, x0               ; calc total lengths of sides - top edge
        SUB     y1, y1, y0               ; - right edge
        MOV     x0, x1                   ; - bottom edge
        LDR     R14, [handle, #w_flags]  ; load flags
        B       %FT02
        
01      LDR     R0, dx                   ; assume max border widths
        STR     R0, furnblock_lborder
        LDR     R0, hscroll_height1
        STR     R0, furnblock_bborder
        LDR     R0, vscroll_width1
        STR     R0, furnblock_rborder
        LDR     R0, title_height1
        STR     R0, furnblock_tborder
        MOV     x1, #&200                ; assume reasonably large
        MOV     y1, x1
        MOV     x0, x1
        MOV     R14, #wf_iconbits        ; assume all border flags set

02      
        TST     R14, #wf_icon1           ; back icon?
        LDRNE   R0, back_width
        MOVEQ   R0, #0
        SUB     x1, x1, R0
        STR     R0, furnblock_back
        
        TST     R14, #wf_icon2           ; close / iconise icons?
        LDRNE   R0, close_width
        MOVEQ   R0, #0
        SUB     x1, x1, R0
        STR     R0, furnblock_close
      [ IconiseButton
        LDRNE   R0, iconise_width
      |
        MOV     R0, #0
      ]
        SUB     x1, x1, R0
        STR     R0, furnblock_iconise
        
        TST     R14, #wf_icon4           ; toggle-size icon?
        LDRNE   R0, vscroll_width
        MOVEQ   R0, #0
        SUB     x1, x1, R0
        STR     R0, furnblock_togglew
        LDRNE   R0, title_height
        SUB     y1, y1, R0
        STR     R0, furnblock_toggleh
        
        TST     R14, #wf_icon3           ; title bar?
        MOVEQ   x1, #0
        STR     x1, furnblock_title
        
        MOV     R0, #0
        STR     R0, furnblock_titlegap0  ; provided to support future expansion
        STR     R0, furnblock_titlegap1  ; eg extra buttons, or a squashable title bar
        
        MVN     R0, R14
        TST     R0, #wf_icon5 :OR: wf_icon7
        TSTNE   R0, #wf_icon6            ; adjust-size / blank?
        LDREQ   R0, hscroll_height
        MOVNE   R0, #0
        SUB     y1, y1, R0
        STR     R0, furnblock_adjusth
        LDREQ   R0, vscroll_width
        SUB     x0, x0, R0
        STR     R0, furnblock_adjustw
        
        TST     R14, #wf_icon5           ; if no vscroll, clear the vscroll words
        MOV     R0, #0
        STREQ   R0, furnblock_vscrgap1
        STREQ   R0, furnblock_up
        STREQ   R0, furnblock_vscr
        STREQ   R0, furnblock_down
        STREQ   R0, furnblock_vscrgap0
        BEQ     %FT04
        
        Push    "R14"
        TEQ     handle, #0
;       MOVEQ   R0, #0                   ; gap0 = 0
        MOVEQ   R14, #0                  ; gap1 = 0
        BEQ     %FT03
      [ ChildWindows
        Push    "x0,y1"                  ; determine vertical gaps
        MOV     R0, #iconposn_vscroll
        BL      calc_w_iconposn2
        SUB     R0, y0, cy0
        SUB     R14, cy1, y1
        Pull    "x0,y1"
      ]
03      STR     R0, furnblock_vscrgap0
        STR     R14, furnblock_vscrgap1
        SUB     y1, y1, R0
        SUBS    y1, y1, R14
        
;       CMP     y1, #0                   ; see if vertical arrows are squashed
        MOVLE   cy0, #0                  ; arrows given 0 length if scrollbar has -ve length (it can happen!)
        MOVLE   cy1, #0
        LDRGT   cy0, down_height         ; standard lengths
        LDRGT   cy1, up_height
        ADDGT   R14, cy0, cy1
        RSBGTS  R0, y1, R14
        MOVGT   cy0, y1, LSR#1           ; which may be squashed
        SUBGT   cy1, y1, cy0
        SUB     y1, y1, cy0              ; take arrows from the bar length to give the well length
        SUB     y1, y1, cy1
        STR     cy1, furnblock_up
        STR     y1, furnblock_vscr
        STR     cy0, furnblock_down
        Pull    "R14"
        
04      
        TST     R14, #wf_icon7           ; if no hscroll, clear the hscroll words
        MOV     R0, #0
        STREQ   R0, furnblock_hscrgap1
        STREQ   R0, furnblock_right
        STREQ   R0, furnblock_hscr
        STREQ   R0, furnblock_left
        STREQ   R0, furnblock_hscrgap0
        BEQ     ExitWimp                 ; all done
        
        TEQ     handle, #0
;       MOVEQ   R0, #0                   ; gap0 = 0
        MOVEQ   R14, #0                  ; gap1 = 0
        BEQ     %FT05
      [ ChildWindows
        Push    "x0"                     ; determine horizontal gaps
        MOV     R0, #iconposn_hscroll
        BL      calc_w_iconposn2
        SUB     R0, x0, cx0
        SUB     R14, cx1, x1
        Pull    "x0"
      ]
05      STR     R0, furnblock_hscrgap0
        STR     R14, furnblock_hscrgap1
        SUB     x0, x0, R0
        SUBS    x0, x0, R14
        
;       CMP     x0, #0                   ; see if horizontal arrows are squashed
        MOVLE   cx0, #0                  ; arrows given 0 length if scrollbar has -ve length (it can happen!)
        MOVLE   cx1, #0
        LDRGT   cx0, left_width          ; standard lengths
        LDRGT   cx1, right_width
        ADDGT   R14, cx0, cx1
        RSBGTS  R0, x0, R14
        MOVGT   cx0, x0, LSR#1           ; which may be squashed
        SUBGT   cx1, x0, cx0
        SUB     x0, x0, cx0              ; take arrows from the bar length to give the well length
        SUB     x0, x0, cx1
        STR     cx1, furnblock_right
        STR     x0, furnblock_hscr
        STR     cx0, furnblock_left
        B       ExitWimp                 ; all done
@


4.3.2.2
log
@New features:
Dragboxes can now be clipped by and/or fixed to a given window's work area
SWI Wimp_AutoScroll implemented
Ursula icon highlighting scheme redesigned

Bugfixes:
Wimp_Extend 11 now performs the same check on R1 as the main SWI handling code
Message blocks now updated if in a dynamic area
Screenblanker now turned off when error box is displayed
ptr_double now turned off when a drag starts
@
text
@d371 1
a371 1
                     ^  0, userblk
a398 4
        CMP     userblk, #ApplicationStart
        MyXError  WimpBadPtrInR1, LT, L
        BVS     ExitWimp                ; check pointer valid in this case
        
@


4.3.2.3
log
@Iconise button removed from child windows
Icon bar now jumps to the back of the stack as soon as a window is opened above
it (excluding menus, dialogue boxes and foregroud windows). This is to avoid
the ambiguous situation when the icon bar can be part-way down the window stack.
Improved co-odination between auto-fronting and Shift-F12 behaviour.
Stopped scroll offset overflow during icon bar scroll.
Numerous features made configurable:
  WimpIconBarSpeed
  WimpIconBarAcceleration
  WimpSpritePrecedence
  WimpIconiseButton
  WimpStickyEdges (although not actually implemented yet)
  WimpAutoFrontIconBar
  WimpAutoFrontDelay
  WimpAutoScrollDelay
To make room for these in CMOS, Wimp<Drag|DoubleClick><Delay|Move> and
Wimp<AutoMenu|MenuDrag>Delay options are now stored in a more compressed form
in CMOS - but the *Configure interface is unaltered.
@
text
@a424 1
        LDR     R1, [handle, #w_parent]  ; get parent
a438 1
        MOV     R1, #-1                  ; assume a top-level window
d453 1
a453 9
        BEQ     %FT06
        MOV     R0, #0
        CMP     R1, #-1
        BNE     %FT06 ; no iconise button on children
        LDRB    R1, iconisebutton
        TEQ     R1, #0
        BEQ     %FT06
        LDR     R0, iconise_width
06
@


4.3.2.4
log
@Window tool button type is now configurable.
Windows now keep the same depth when toggle-size tool is clicked with Adjust.
Fixed bug where drags in Eureka caused branch-through-zeros and other
miscellaneous errors.
Fixed a few stray non-X form SWI calls.
Extended applicability/functionality of "MyEntry" debug macro.
@
text
@a17 2
        MyEntry "TextOp"

d51 1
a51 1
        SWI     XColourTrans_SetGCOL
d54 1
a54 1
        SWIVC   XColourTrans_SetGCOL
a221 2
        MyEntry "ResizeIcon"

a278 2
        MyEntry "Extend"

@


4.2
log
@Merged WIMP imported
@
text
@d246 1
d265 5
d313 1
a313 1
        
d317 1
a317 1
        
d320 1
a320 1
        
d324 1
a324 1
        
d341 1
a341 1
        
d351 1
a351 1
        
d355 1
a355 1
        
@


4.1
log
@Initial revision
@
text
@a266 2


d292 11
d304 36
d342 10
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.7.1.2.1
log
@AMBControl task switching merged from RO_3_70 branch.
PlotSpritesFromPalette and TwitterOnlyMenus options added.
ChildWindows merged in.
@
text
@d267 2
a293 11
      [ ChildWindows
        CMP     R0,#6                   ; In: R0 = 6 => get parent, 7,8 => get top/bottom child, 9,10 => get next/previous sibling
        RSBGES  R14,R0,#10              ; In: R1 = window handle, or -1 for top-level ; Out: R1 = result handle, or -1 for none
        BGE     %FT01
      ]
        B       ExitWimp

      [ ChildWindows

01      CMP     R1,#nullptr
        BEQ     %FT05
a294 36
        MOV     handle,R1
        BL      checkhandle_iconbar
        BVS     ExitWimp
        
        CMP     R0,#7
        LDRLT   handle,[handle,#w_parent]
        BLT     %FT03
        
        LDREQ   handle,[handle,#w_children + lh_forwards]
        BEQ     %FT02
        
        CMP     R0,#9
        LDRLT   handle,[handle,#w_children + lh_backwards]
        BLT     %FT02
        
        LDR     R14,[handle,#w_flags]
        TST     R14,#ws_open                    ; sibling pointers are garbage if window is not open
        MOVEQ   handle,#nullptr
        BEQ     %FT04

        CMP     R0,#9
        LDREQ   handle,[handle,#w_active_link + ll_forwards]
        LDRGT   handle,[handle,#w_active_link + ll_backwards]

02      CMP     handle,#nullptr
        LDRNE   R14,[handle,#ll_forwards]       ; if either forward or backward pointer is null, we're at the head entry (not a window)
        CMPNE   R14,#nullptr
        LDRNE   R14,[handle,#ll_backwards]
        CMPNE   R14,#nullptr
        MOVEQ   handle,#nullptr
        SUBNE   handle,handle,#w_active_link
        
03      CMP     handle,#nullptr
        Rel     handle,handle,NE

04      STR     handle,[sp]
a296 10
05      CMP     R0,#7
        LDREQ   handle,activewinds + lh_forwards
        BEQ     %BT02
        
        CMP     R0,#8
        LDREQ   handle,activewinds + lh_backwards
        BEQ     %BT02
        
        B       ExitWimp
      ]
@


4.1.7.1.2.2
log
@Added support for multiple options files (RO310, RO350, RO360, RO370, RCA,
Ursula).
Removed run-time MedusaOS checks.
Enabled correct build for RISC OS 3.1 machines.
Ensured that "freepoolinuse" is cleared before OS_ChangeDynamicArea
is intercepted.
Increased maxrects to 256.
Gave copy filter window handle in R10 (if ChildWindows).
Corrected a few border problems when no toolsprites.
Made toolsprites press in immediately - in particular close and toggle can
now be highlighted.
BounceClose flag no affects all of back,close,iconise and toggle.
Made "L" validation string parsing check manually for presence of a number,
to prevent error from OS_ReadUnsigned trashing MessageTrans' error buffers.
Allow error box buttons to stretch to fit text.
Fixed bug: floating point registers were not being saved unless on a portable.
Integrated some of the Wimp_TransferBlock fixes into Wimp08 from Wimp08s.
@
text
@a245 1
      [ UseDynamicArea
a263 5
      |
	Push	"LR"
	SWI	XOS_Module
	Pull	"PC"
      ]
d307 1
a307 1

d311 1
a311 1

d314 1
a314 1

d318 1
a318 1

d335 1
a335 1

d345 1
a345 1

d349 1
a349 1

@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

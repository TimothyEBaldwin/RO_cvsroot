head	4.10;
access;
symbols
	DragASprit-0_21:4.10
	DragASprit-0_20:4.9
	DragASprit-0_19:4.8
	DragASprit-0_18:4.7
	DragASprit-0_17:4.6
	DragASprit-0_16:4.5
	RO_5_07:4.4
	DragASprit-0_15:4.4
	dellis_autobuild_BaseSW:4.3
	DragASprit-0_14:4.3
	sbrodie_sedwards_16Mar2000:4.2
	Ursula_merge:4.1.4.2
	DragASprit-0_13:4.2
	dcotton_autobuild_BaseSW:4.4
	nturton_DragASprit-0_11:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1.4.2
	Ursula_RiscPC:4.1.4.2.0.2
	nicke_DragASprite_0_11:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1.4.2
	UrsulaBuild_FinalSoftload:4.1.4.2
	rthornb_UrsulaBuild-12Aug1998:4.1.4.2
	aglover_UrsulaBuild-05Aug1998:4.1.4.2
	rthornb_UrsulaBuild-29Jul1998:4.1.4.2
	rthornb_UrsulaBuild-22Jul1998:4.1.4.2
	rleggett_DragASprit-0_13:4.1.4.2
	bavison_DragASprite-0_12:4.1.4.1
	rthornb_UrsulaBuild-15Jul1998:4.1.4.1
	rthornb_UrsulaBuild-07Jul1998:4.1.4.1
	rthornb_UrsulaBuild-17Jun1998:4.1.4.1
	rthornb_UrsulaBuild-03Jun1998:4.1.4.1
	rthornb_UrsulaBuild-27May1998:4.1.4.1
	rthornb_UrsulaBuild-21May1998:4.1.4.1
	rthornb_UrsulaBuild_01May1998:4.1.4.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	ARTtmp:4.1.7.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.10
date	2017.08.30.22.36.06;	author jlee;	state Exp;
branches;
next	4.9;
commitid	cEmt8eL1pUvNWh5A;

4.9
date	2016.05.08.16.39.32;	author jlee;	state Exp;
branches;
next	4.8;
commitid	3yxufEQR94T5nH5z;

4.8
date	2014.07.05.12.06.16;	author jlee;	state Exp;
branches;
next	4.7;
commitid	LoVRzNlwqbCyubHx;

4.7
date	2014.07.03.22.40.09;	author jlee;	state Exp;
branches;
next	4.6;
commitid	Wvkrnx3yQXMZ3ZGx;

4.6
date	2013.10.14.23.28.26;	author jlee;	state Exp;
branches;
next	4.5;
commitid	Z9zBtet7qrvIKj9x;

4.5
date	2013.10.07.00.48.32;	author jlee;	state Exp;
branches;
next	4.4;
commitid	VmHZmrpDtev8si8x;

4.4
date	2001.03.16.17.09.41;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.04.20.15.57.17;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2000.02.17.16.33.45;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.14;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.4.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.14;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.26.43;	author nturton;	state Exp;
branches;
next	;

4.1.4.1
date	98.02.16.13.53.08;	author bavison;	state Exp;
branches;
next	4.1.4.2;

4.1.4.2
date	98.07.22.09.24.09;	author rleggett;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.15.12;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.15.22;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.10
log
@Fix redraw issue with alpha drop shadow
Detail:
  s/StartUp - When the alpha drop shadow is in use, the foreground sprite is one row+column larger than normal, to allow the shadow to be feathered. However the drag box calculations weren't taking this into account, resulting in slightly wonky coordinates that can result in redraw issues in some situations (specifically, the screen area under the sprite's current location is filled with a plain colour if the bounding box overlaps the graphics window in a certain manner). Introduce orig_x_size and orig_y_size variables so that the drag box calculations can be correct regardless of how much padding is added to the image (with the limitation that the padding must be on the right / bottom)
  Also, fix the AtPointer support so that the pointer is placed at the centre of the input sprite, not the padded sprite.
Admin:
  Tested on Raspberry Pi
  Resolves ticket #402, and similar corruption with animated windows (e.g. start a drag of a sprite which overlaps !Alarm's icon)


Version 0.21. Tagged as 'DragASprit-0_21'
@
text
@; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
;; Compilation flags for this version of the module

                GBLL    hatching
hatching        SETL    1=1


; StartUp the drag
;
; In    r0 = flags:
;               Bits    Meaning
;               0-1     Horizontal location of sprite in box:
;                       00      Left
;                       01      Centre
;                       10      Right
;                       11      <undefined>
;               2-3     Vertical location of sprite in box:
;                       00      Bottom
;                       01      Centre
;                       10      Top
;                       11      <undefined>
;               4-5     Drag bounding box is:
;                       00      Whole screen
;                       01      Display area of window that the pointer's over
;                       10      User specified
;                       11      <undefined>
;               6       Bounding box applies to:
;                       0       The box
;                       1       The pointer
;               7       Control of drop-shadow:
;                       0       Don't do a drop-shadow
;                       1       Make a drop shadow when copying the sprite
;               8       0       Hatch the sprite / Render translucent
;                       1       Never hatch the sprite / never translucent
;               9       0       Sprite's position is determined by bits 0-3
;                       1       Sprite is centred on pointer position
;               10-31   Reserved for future use, should be set to 0.
;       r1 = sprite area:
;               0       System sprite area
;               1       Wimp sprite area
;               other   Address of sprite area
;       r2 = sprite name^
;       r3 = Pointer to 16-byte block containing box:
;               Offset  Use
;               0       x0
;               4       y0
;               8       x1
;               12      y1
;       r4 = Pointer to optional (see flags) 16-byte block containing bounding box:
;               Offset  Use
;               0       x0
;               4       y0
;               8       x1
;               12      y1

;       Out:
;       All registers preserved.

DS_DropShadowDistance    *      8       ; OS units
DS_TranslucencyValue     *      128     ; i.e. 50%, as per hatching
DS_TranslucencyValue_256 *      104     ; Use a value of about 40% in 256 colour modes. With the default RISC OS 5 Wimp theme sprites this greatly helps file icons to retain their colour when dragged over window & desktop backgrounds.
DS_DropShadowAlpha       *      96
DS_DropShadowFGAlpha     *      128
DS_DropShadowFGAlpha_256 *      160

        MACRO
$label  TestAFlag       $reg, $what, $iswhat, $workreg
        AND     $workreg, $reg, #DS_$|what|_Mask
        TEQ     $workreg, #DS_$|what|_$iswhat
        MEND

; Local variables
                ^       0,sp
dragstr         #       dr_size
scale_block     #       16
tx_block        #       16
spr_dragbox     #       16      ; Box to use for sprite dragging calculations
local_flags     #       4
orig_x_size     #       4       ; Size in OS units of input sprite
orig_y_size     #       4       ; Size in OS units of input sprite
StartUp_frame_size * :INDEX: @@

StartUp Entry "r0-r8", StartUp_frame_size
 [ debugstart
        DLINE   "StartUp started"
        DREG    r0, "Flags ",cc
        DREG    r1, "  area ",cc
        DSTRING r2, "  sprite ",cc
        LDR     r8, [r3, #box_x0]
        DREG    r8, "  Box (", cc
        LDR     r8, [r3, #box_y0]
        DREG    r8, ",", cc
        LDR     r8, [r3, #box_x1]
        DREG    r8, ",", cc
        LDR     r8, [r3, #box_y1]
        DREG    r8, ",", cc
        DLINE   ")"
 ]
        BL      Done            ; Junk any drag pending at the moment
        BVS     %FT90

        STR     R0, local_flags

        ; ensure the box passed in is rounded to osunits

        STMFD   R13!,{R0-R2}       ; save R0-R2
        MOV     R0, #-1            ; read for current screen mode
        MOV     R1, #VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        MOV     R7, R2             ; R7 is the xeig factor
        MOV     R1, #VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        MOV     R8, R2             ; R8 is the yeig factor

        ; If we want to use translucency, set the translucency value and massage the flags as appropriate
        MOV     LR, #0
        STRB    LR, Translucency
        LDR     LR, local_flags + 3*4
        TST     LR, #DS_NoHatching
        BNE     %FT02

        ; Check SpriteExtend version if we're not sure yet
        ; (ROM init order means that checking on startup won't work)
        LDRB    R0, TranslucencyOK
        CMP     R0, #128
        BNE     %FT01
        ADRL    R0, SpriteExtendCheck
        SWI     XOS_CLI
        MOVVC   R0, #255
        MOVVS   R0, #0
        CLRV
        STRB    R0, TranslucencyOK
01
        ; Work out translucency value to use for current screen mode
        MOV     R0, #-1
        MOV     R1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        TEQ     R2, #3
        MOVEQ   LR, #DS_TranslucencyValue_256
        MOVNE   LR, #DS_TranslucencyValue
        ; If translucency available, and we've got more than 2 colours to play
        ; with, prefer that over hatching
        TEQ     R2, #0
        LDRNEB  R1, TranslucencyOK
        ANDNES  R1, R1, LR
        BEQ     %FT02
        LDR     R0, local_flags + 3*4
        ; If we have more than 4 colours available and want a drop shadow, use
        ; an ABGR sprite with a soft shadow
        TST     R2, #&FE
        TSTNE   R0, #DS_DropShadow_Present
        LDRNEB  LR, AlphaOK
        TEQNE   LR, #0
        MOVNE   R1, #1        
        STRB    R1, Translucency
        ; Disable hatching
        ORR     R0, R0, #DS_NoHatching
        STR     R0, local_flags + 3*4
02
        LDMFD   R13!,{R0-R2}       ; recover the registers we've messed up

        MOV     R6, #1             ; a handy constant for shifts

        TEQ     R7, #0             ; if xeig=0 then no need to round

        MOVNE   R7, R6, LSL R7     ; number of osunits per pixel x
        SUBNE   R7, R7, R6         ; minus one, to give masking value

        LDRNE   R5, [R3, #box_x0]  ; load, mask and store x0
        BICNE   R5, R5, R7
        STRNE   R5, [R3, #box_x0]

        LDRNE   R5, [R3, #box_x1]  ; load, mask and store x1
        BICNE   R5, R5, R7
        STRNE   R5, [R3, #box_x1]

        TEQ     R8, #0             ; if yeig=0 then no need to round

        MOVNE   R8, R6, LSL R8     ; number of osunits per pixel y
        SUBNE   R8, R8, R6         ; minus one for masking value

        LDRNE   R5, [R3, #box_y0]  ; load, mask and store y0
        BIC     R5, R5, R8
        STRNE   R5, [R3, #box_y0]

        LDRNE   R5, [R3, #box_y1]  ; load, mask and store y1
        BIC     R5, R5, R8
        STRNE   R5, [R3, #box_y1]

        ; Get a sprite area big enough for:
        ; 2 background sprites the size of the source sprite
        ; a copy of the source sprite in native screen mode
        ; /* a copy of the source sprite (only used when the screen mode changes) */
        ; a double the source sprite sized buffer sprite for moving
        BL      CoordSizeOfSprite

        ; Probably failed due to missing sprite, hence...
        BVS     ResortToNormalDrag
        
        ; Remember original size so we can get drag box calculations correct
        STR     r0, orig_x_size
        STR     r1, orig_y_size

        ; If there's a drop-shadow grow the size by the required distance
        LDR     r2, local_flags
        TestAFlag r2, DropShadow, Present, r14
        ADDEQ   r0, r0, #DS_DropShadowDistance
        ADDEQ   r1, r1, #DS_DropShadowDistance
        ; If we have a translucent drop shadow then grow 1 more row+column so
        ; that we can feather the shadow
        LDRB    lr, Translucency
        CMP     lr, #1
        ADDEQ   r0, r0, r7
        ADDEQ   r1, r1, r8
        ADDEQ   r0, r0, #1
        ADDEQ   r1, r1, #1
        STR     r0, x_size
        STR     r1, y_size

        ; Convert to bytes needed for the sprite(s)
        BL      ByteSizeOfSprite
        BVS     %FT90

        ; Add enough for the sprite area header
        ADD     r3, r3, #SpriteAreaCBsize

        ; Claim bg0 and bg1 at that size
        ADRL    r1, bg0sa
        BL      MakeSpriteArea
        ADRVCL  r1, bg1sa
        BLVC    MakeSpriteArea

        ; Claim fg with enough space for a mask
        ADDVC   r3, r4, #SpriteAreaCBsize
        ADRVCL  r1, fgsa
        BLVC    MakeSpriteArea

        ; Any errors up to here are probably due to memory shortage, hence...
        BVS     ResortToNormalDrag

 [ debugstart
        DLINE   "Gotten areas..doing normal dragasprite"
 ]

        ; Create the two background sprites (bg0 and bg1)
        LDR     r0, =SpriteReason_GetSpriteUserCoords + &100
        LDR     r1, bg0sa
        ADRL    r2, bg_name
        MOV     r3, #0          ; no palette
        MOV     r4, #0
        MOV     r5, #0
        LDR     r6, x_size
        SUB     r6, r6, #1
        LDR     r7, y_size
        SUB     r7, r7, #1
        SWI     XOS_SpriteOp
        LDRVC   r1, bg1sa
        ADRVCL  r2, bg_name
        SWIVC   XOS_SpriteOp
        BVS     %FT80

        ; If we're doing a translucent sprite with drop shadow, go and
        ; generate that
        LDRB    lr, Translucency
        CMP     lr, #1
        BNE     %FT03
        LDR     r0, local_flags
        ADD     r1, sp, #Proc_LocalStack
        BL      GenerateTranslucentDropShadow
        BVS     %FT80
        B       %FT53

03

        ; Create the foreground sprite (fg)
        LDR     r0, =SpriteReason_GetSpriteUserCoords + &100
        LDR     r1, fgsa
        ADRL    r2, fg_name
        SWI     XOS_SpriteOp
        BVS     %FT80

 [ debugstart
        DLINE   "Created sprites"
 ]
        ; Get a scaling table for the user's sprite onto the stack
        MOV     r0, #&100
        LDR     r1, [sp, #Proc_LocalStack + 1*4]
        LDR     r2, [sp, #Proc_LocalStack + 2*4]
        ADR     r6, scale_block
        ADR     r7, tx_block
        SWI     XWimp_ReadPixTrans
        BVS     %FT80

; try and claim memory for pixtable
        MOV     r0, r1
        MOV     r1, r2
        BL      GetSpritePixTable

        ; Create a transparency mask and fill it in
        LDR     r0, =SpriteReason_CreateMask + &100
        LDR     r1, fgsa
        ADRL    r2, fg_name
        SWI     XOS_SpriteOp
        BVC     %FT05                   ; masks fail on first version of Medusa
                                        ; so try and carry on drag solidly.
        ; make sure dithering disabled- doesn't look good!
        LDR     R0, local_flags
        ORR     R0,R0, #DS_NoHatching
        STR     R0, local_flags

        ; Switch output to the sprite
        MOV     r0, #SpriteReason_SwitchOutputToSprite + &100
        LDR     r1, fgsa
        ADRL    r2, fg_name
        MOV     r3, #0  ; No save area
        SWI     XOS_SpriteOp
        BVS     %FT80
        Push    "r0-r3"

        ; clear it, because we have no mask
        ADRVCL  r0, setcolallset
        MOVVC   r1, #?setcolallset
        SWIVC   XOS_WriteN
        SWIVC   XOS_WriteI+16
        B       %FT35

05

        ; Switch output to the mask
        LDR     r0, =SpriteReason_SwitchOutputToMask + &100
        LDR     r1, fgsa
        ADRL    r2, fg_name
        MOV     r3, #0  ; No save area
        SWI     XOS_SpriteOp
        BVS     %FT80
        Push    "r0-r3"

        ; Clear the mask out and set to writing all bits set
        ADRL    r0, setcolnoneset
        MOV     r1, #?setcolnoneset
        SWI     XOS_WriteN
        SWIVC   XOS_WriteI+16
        ADRVCL  r0, setcolallset
        MOVVC   r1, #?setcolallset
        SWIVC   XOS_WriteN
        BVS     %FT70

        ; Test for drop-shadow
        LDR     r0, local_flags + 4*4
        TestAFlag r0, DropShadow, Present, r14

        ; Load up common parameters
        LDR     r0, =SpriteReason_PlotMaskScaled
        LDR     r1, [sp, #4*4 + Proc_LocalStack + 1*4]
        LDR     r2, [sp, #4*4 + Proc_LocalStack + 2*4]

        ; Switch on drop-shadow
        BEQ     %FT10

        ; Plot the user's mask in the background colour scaled as specified
        MOV     r3, #0
        MOV     r4, #0
        BL      DoSpriteOp

        B       %FT20

10
        ; Plot a drop shadow style mask
        MOV     r3, #DS_DropShadowDistance
        MOV     r4, #0
        BL      DoSpriteOp
        MOVVC   r3, #0
        MOVVC   r4, #DS_DropShadowDistance
        BLVC    DoSpriteOp

20
        ; Return back to original output location
        BVS     %FT70
        Pull    "r0-r3"
        SWI     XOS_SpriteOp
        BVS     %FT80

30
        ; Plot foreground into fg

        ; Switch output to the sprite
        MOV     r0, #SpriteReason_SwitchOutputToSprite + &100
        LDR     r1, fgsa
        ADRL    r2, fg_name
        MOV     r3, #0  ; No save area
        SWI     XOS_SpriteOp
        BVS     %FT80
        Push    "r0-r3"
35
        ; Test for drop shadow
        LDR     r0, local_flags + 4*4
        TestAFlag r0, DropShadow, Present, r14

        ; Load up the common parameters
        LDR     r1, [sp, #4*4 + Proc_LocalStack + 1*4]
        LDR     r2, [sp, #4*4 + Proc_LocalStack + 2*4]
        MOV     r5, #8                  ; Overwrite, using transparency mask

        ; Branch on the drop shadow
        BEQ     %FT40

        ; Plot the user's sprite in the background colour scaled as specified
        MOV     r0, #SpriteReason_PutSpriteScaled
        MOV     r3, #0
        MOV     r4, #0
        BL      DoSpriteOp
        B       %FT50

40
        ; Set background to black
        MOV     r0, #&87
        SWI     XWimp_SetColour

        ; Plot the mask there
        MOV     r0, #SpriteReason_PlotMaskScaled
        MOV     r3, #DS_DropShadowDistance
        MOV     r4, #0
        BLVC    DoSpriteOp

        ; Plot the drop-shadow foreground
        MOV     r0, #SpriteReason_PutSpriteScaled
        MOVVC   r3, #0
        MOVVC   r4, #DS_DropShadowDistance
        BL      DoSpriteOp

50

; free temporary pix trans block

        SavePSR R1
        ADR     R14,tx_block
        CMP     R7,#0
        BLE     wibble2
        TEQ     R14,R7
        MOVNE   R0,#ModHandReason_Free
        MOVNE   R2,R7
        SWINE   XOS_Module
        RestPSR R1,,f

;; We need the depth of the sprite so read it

wibble2

      [ hatching
        MOVVC   R0,#-1
        MOVVC   R1,#VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable
        MOVVC   R7,R2                           ; keep the depth of the sprite
        MOVVC   R8,R2

; medusa has 1bpp masks
        Push    "R2-R6"
        MOVVC   R0,#&100 + SpriteReason_ReadSpriteSize
        LDRVC   R1,fgsa
        ADRVCL  R2,fg_name
        SWIVC   XOS_SpriteOp
        MOVVS   R6,#0
        CMP     R6,#255
        MOVGT   R7,R3, LSL #8                   ; put the width (pixels) in here
        Pull    "R2-R6"
      ]

        ; Return back to original output location
        BVS     %FT70
        Pull    "r0-r3"
        SWI     XOS_SpriteOp

;; Pixelate the mask so that we get this funky sort of masking where
;; you can see all alternate pixels.

      [ hatching
        LDR     R0, local_flags
        TST     R0, #DS_NoHatching
        BNE     %FT53                           ; if no hatching then skip

        MOV     R3,#0
        CMP     R7,#31
        MOVGT   R3,R7, LSR #8
        MOVGT   R7,#0                           ; 1bit mask, n bit sprite

        MOV     R0,#1
        MOV     R7,R0,LSL R7                    ; R0 = bits per pixel of the sprite (1,2,4,8,16 or 32)
        RSB     R1,R7,#32                       ; R1 = shift to move pixels into bottom bits
        MOV     R5,#-1

        CMP     R0,#32
        MOVNE   R5,R5,LSR R1                    ; bits 0-R0 contain masking bits (AMG)

        MOV     R0,R7
10
        ADD     R0,R0,R0
        ANDS    R0,R0,#31
        ORRNE   R5,R5,R5,LSL R0                 ; combine to make mask
        BNE     %BT10

        LDR     R0,=SpriteReason_SelectSprite +&100
        LDR     R1,fgsa
        ADRL    R2,fg_name
        SWI     XOS_SpriteOp                    ; R2 -> sprite in the area

        TEQ     R3,#0
        LDREQ   R3,[R2,#spWidth]                ; width, height and pixel mask to apply
        ADDNE   R3,R3,#31
        MOVNE   R3,R3, LSR #5                   ; size of mask in words
        SUBNE   R3,R3,#1
        LDR     R4,[R2,#spHeight]
        LDR     R6,[R2,#spTrans]
        ADD     R6,R6,R2                        ; -> mask data

;; R5 contains mask for the current depth
;; R7 contains the shift

        [ {FALSE}
51
        MOV     R5,R5,ROR R7                    ; rotate mask by one for alternate lines
        Push    "R3"
52
        LDR     LR,[R6]
        BIC     LR,LR,R5
        STR     LR,[R6],#4                      ; apply masking data to image

        ;when dealing with 32bpp it's impossible to use the rotating mask bits in
        ;a word trick. Instead we flip the whole word between 0 and &FFFFFFFF
        CMP     R7,#32                          ; is it 32bpp
        MOVEQ   R14,#-1                         ; -1 constant
        SUBEQ   R5,R14,R5                       ; flip between 0 and -1

        SUBS    R3,R3,#1                        ; decrease number of lines to do
        BPL     %BT52                           ; and loop again if more

        Pull    "R3"
        SUBS    R4,R4,#1
        BPL     %BT51                           ; loop back until all lines are done
53

        |
51
        MOV     LR,#-1
        EOR     R5,R14,R5                       ; rotate mask by one for alternate lines

        Push    "R3"                            ; save the line length
52
        LDR     LR,[R6]
        BIC     LR,LR,R5
        STR     LR,[R6],#4                      ; apply masking data to image
;        STR     R5,[R6],#4

        SUBS    R3,R3,#1
        BMI     %FT54

        CMP     R7,#32                          ; if dealing with a 32bpp sprite
        MOVEQ   LR,#-1
        EOREQ   R5,R5,LR

        LDR     LR,[R6]
        BIC     LR,LR,R5
        STR     LR,[R6],#4
;        STR     R5,[R6],#4

        CMP     R7,#32
        MOVEQ   LR,#-1
        EOREQ   R5,R5,LR

        SUBS    R3,R3,#1                        ; decrease number of words to do
        BPL     %BT52                           ; and loop again if more
54
        Pull    "R3"
        SUBS    R4,R4,#1
        BPL     %BT51                           ; loop back until all lines are done
53
               ]
        ]
 [ debugstart
        DLINE   "Generated fg, starting drag..."
 ]

;        MOV     R0,#SpriteReason_SaveSpriteFile+256
;        LDR     R1,fgsa
;        ADRL    R2,savename
;        SWI     OS_SpriteOp

        ; Sprites now claimed, let's start the drag

        ; Fill in the dragstr
        MOV     r14, #dragtype_userfixedbox
        STR     r14, dragstr + dr_type

        ; Calculate the offset from box to sprite
        LDR     r0, local_flags
        LDR     r3, [sp, #Proc_LocalStack + 3*4]

  [ AtPointerFlag
        ; Check first if flag is set to put sprite at pointer position
        TST       r0, #DS_SpriteAtPointer
        BEQ       %FT54

        ; Get pointer position
        ADR       r1, ptrbuffer
        SWI       XWimp_GetPointerInfo
        BVS       %FT54
        MOV       r2, r1

        ; Work out x offset
        LDR       r1, [r2]
        LDR       r14, [r3, #box_x0]
        SUB       r1, r1, r14
        LDR       r14, orig_x_size
        SUB       r1, r1, r14, LSR #1
        STR       r1, bl_offset_x               ; Store x offset

        ; Work out y offset
        LDR       r1, [r2, #4]
        LDR       r14, [r3, #box_y0]
        SUB       r1, r1, r14
        B         %FT61                         ; Share centre justify code
54
  ]

        TestAFlag r0, HJustify, Left, r14

        ; Left justify
        MOVEQ   r1, #0
        BEQ     %FT57

        TestAFlag r0, HJustify, Centre, r14
        BNE     %FT55

        ; Centre justify
        LDR     r1, [r3, #box_x1]
        LDR     r2, [r3, #box_x0]
        SUB     r1, r1, r2
        MOV     r1, r1, ASR #1
        LDR     r2, orig_x_size
        SUB     r1, r1, r2, ASR #1
        B       %FT57

55
        ; Right justify
        LDR     r1, [r3, #box_x1]
        LDR     r2, orig_x_size
        SUB     r1, r1, r2
        LDR     lr, [r3, #box_x0]
        SUB     r1, r1, lr

57
        STR     r1, bl_offset_x

        TestAFlag r0, VJustify, Bottom, r14
        BNE     %FT60

        ; Bottom justify
        LDR     r14, orig_y_size
        LDR     r1, y_size
        SUB     r1, r14, r1

        B       %FT65

60
        TestAFlag r0, VJustify, Centre, r14
        BNE     %FT62

        ; Centre justify
        LDR     r1, [r3, #box_y1]
        LDR     r2, [r3, #box_y0]
        SUB     r1, r1, r2
        MOV     r1, r1, ASR #1
61
        LDR     r14, orig_y_size
        LDR     r2, y_size
        RSB     r2, r14, r2, LSL #1             ; i.e. orig_y_size + 2*padding
        SUB     r1, r1, r2, ASR #1
        B       %FT65

62
        ; Top justify
        LDR     r1, [r3, #box_y1]
        LDR     r2, y_size
        SUB     r1, r1, r2
        LDR     lr, [r3, #box_y0]
        SUB     r1, r1, lr

65
        STR     r1, bl_offset_y

        ; Given the bl offsets and the original box, generate the sprite's drag box
        LDR     r1, [r3, #box_x0]
        LDR     r2, bl_offset_x
        ADD     r1, r1, r2
        STR     r1, spr_dragbox + box_x0
        LDR     r2, orig_x_size
        ADD     r1, r1, r2
        STR     r1, spr_dragbox + box_x1
        LDR     r1, [r3, #box_y0]
        LDR     r2, bl_offset_y
        ADD     r1, r1, r2
        LDR     r2, orig_y_size
        LDR     r14, y_size
        SUB     r14, r14, r2
        ADD     r1, r1, r14
        STR     r1, spr_dragbox + box_y0
        ADD     r1, r1, r2
        STR     r1, spr_dragbox + box_y1

 [ debugstart
        DLINE   "Generated bl offsets, filling in dragstr"
 ]

        ; The drag routines
        STR     r12, dragstr + dr_userR12
        ADRL    r14, UnPlot
        STR     r14, dragstr + dr_userRemove
        ADRL    r14, Plot
        STR     r14, dragstr + dr_userDraw
        ADRL    r14, Move
        STR     r14, dragstr + dr_userMove

        ADD     r14, sp, #Proc_LocalStack
        LDMIA   r14, {r0-r4}

        B       FinishStartingDrag

70
        ; Switch output back to screen error exit
        STR     r0, [sp, #4*4 + Proc_LocalStack + 0*4]
        Pull    "r0-r3"
        SWI     XOS_SpriteOp
        LDR     r0, [sp, #4*4 + Proc_LocalStack + 0*4]

80
        ; Free the sprite areas error exit
        STR     r0, [sp, #Proc_LocalStack + 0*4]
        BL      Done
        LDR     r0, [sp, #Proc_LocalStack + 0*4]

90
        STR     r0, [sp, #Proc_LocalStack + 0*4]
 [ debugstart
        ADD     r0, r0, #4
        DSTRING r0, "Error return:"
 ]
        EXIT

;savename    DCB "$.sprites.das",0
        ALIGN

ResortToNormalDrag
        ; Junk any sprite garbage
        BL      Done

        ; Cancel any error
        CLRV

        ; Store the norml drag specific bits in the dragstr
        MOV     r14, #dragtype_fixedbox
        STR     r14, dragstr + dr_type

        LDMIA   r3, {r5-r8}
        ADR     lr, spr_dragbox
        STMIA   lr, {r5-r8}

        ADD     r14, sp, #Proc_LocalStack
        LDMIA   r14, {r0-r4}

FinishStartingDrag
        ; spr_dragbox - box of thing to appear to be dragged

        ; Construct the common parts of a drag structure and start the drag
 [ debugstart
        DLINE   "Doing common part fo dragstr"
 ]

        ; Box being moved is always the user's supplied box
        LDR     r14, [sp, #Proc_LocalStack + 3*4]
        LDMIA   r14, {r5-r8}
        ADR     r14, dragstr + dr_x0
        STMIA   r14, {r5-r8}

        ; Parent box
        ADR     r3, dragstr + dr_x0
        ADR     r2, spr_dragbox
        BL      GetParentBox
        ADR     r14, dragstr + dr_parentx0
 [ debugstart
        DREG    r5, "Parent = (",cc
        DREG    r6, ",",cc
        DREG    r7, ",",cc
        DREG    r8, ",",cc
        DLINE   ")"
 ]
        STMIA   r14, {r5-r8}

 [ debugstart
        DLINE   "dragstr ready, starting drag"
 ]

        ; Indicate first move will be plot, not move
        MOV     lr, #1
        STRB    lr, FirstMoveIsPlot

        ; Start the drag
        ADR     r1, dragstr
        SWI     XWimp_DragBox
        STRVS   r0, [sp, #Proc_LocalStack + 0*4]
        BLVS    Done

 [ debugstart
        DLINE   "drag started, all done"
 ]
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; GetSpritePixTable
;
; In    r0 = area
;       r1 = sprite
;       r7 = wimp pixtrans ptr
;
; Out   r7 = table to use
;
GetSpritePixTable ROUT
        Entry   "r0-r5"
        TEQ     R0,#1
        MOVNE   R5,#2                                   ; sprite is a name

        BNE     %FT50

        MOV     R0, #16
        SWI     XWimp_ReadSysInfo
        SWIVS   XWimp_BaseOfSprites                     ; cater for old Wimps
        MOV     R3,R0
        MOV     R0,#SpriteReason_SelectSprite+256
        FRAMLDR r2,,r1
        SWI     XOS_SpriteOp
        MOVVC   R0,R1
        MOVVC   R1,R2
        MOVVC   R5,#3
        BVC     %FT50

        MOV     R0,#SpriteReason_SelectSprite+256
        MOV     R1,R3
        SWI     XOS_SpriteOp
        MOVVS   R7,#0
        BVS     %FT90

        MOV     R5,#3                                   ; sprite is pointer
        MOV     R0,R1
        MOV     R1,R2
50

        MOV     R2,#-1
        MOV     R3,#-1
        MOV     R4,#0
        SWI     XColourTrans_SelectTable

    [ debugstart
        DREG    R4," table size"
   ]

        CMP     R4,#17
        BLT     %FT90                                   ; wimp table will be ok

        Push    R0
        MOV     R0,#ModHandReason_Claim
        MOV     R3,R4
        SWI     XOS_Module
        Pull    R0,VC
        ADDVS   sp,sp,#4
        MOVVS   R7,#0
        BVS     %FT90

        MOV     R4,R2
        MOV     R2,#-1
        MOV     R3,#-1

        SWI     XColourTrans_SelectTable
        MOVVC   R7,R4
        MOVVS   R7,#0

        MOVVS   R2,R4
        MOVVS   R0,#ModHandReason_Free
        SWIVS   XOS_Module
90
        ; For now, match old code and don't return any errors
        CLRV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; GenerateTranslucentDropShadow
;
; In    r0 = drag flags
;       r1 -> StartUp r0-r4
;
GenerateTranslucentDropShadow ROUT
; Local variables
                ^       0,sp
spriteredir     #       16
inarea          #       4
inspr           #       4
inmode          #       4
inxeig          #       4
inyeig          #       4
inmask          #       4
outxeig         #       4
outyeig         #       4
outw            #       4
outh            #       4
outdata         #       4
dropbuf         #       4
fgalpha         #       4
scale_block2    #       16
tx_block2       #       16
GTDS_frame_size * :INDEX: @@
        Entry   "r0-r11", GTDS_frame_size

        MOV     lr, #0
        STR     lr, dropbuf

        ; Read details of source sprite
        LDMIB   r1, {r1,r2}
        STR     r1, inarea
        STR     r2, inspr
        MOV     r0, #SpriteReason_ReadSpriteSize
        BL      DoSpriteOp
        BVS     %FT99
        STR     r5, inmask
        STR     r6, inmode
        MOV     r0, r6
        BL      PixToOSUnitFactors
        BVS     %FT99
        STR     r5, inxeig
        STR     r2, inyeig

        ; Decide on the alpha value to use for the foreground sprite
        MOV     r0, #-1
        MOV     r1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        CMP     r2, #3
        MOVLE   r2, #DS_DropShadowFGAlpha_256
        MOVGT   r2, #DS_DropShadowFGAlpha
        STR     r2, fgalpha

        ; Read eigen values for current mode
        MOV     r0, #-1
        BL      PixToOSUnitFactors
        BVS     %FT99
        STR     r5, outxeig
        STR     r2, outyeig

        ; Compute dimensions of output sprite, and create
        LDR     r4, x_size
        LDR     r6, =&78000001+(SpriteType_New32bpp<<20)+ModeFlag_DataFormatSub_Alpha
        MOV     r4, r4, LSR r5
        ORR     r6, r6, r5, LSL #4
        LDR     r5, y_size
        ORR     r6, r6, r2, LSL #6
        MOV     r5, r5, LSR r2
        STR     r4, outw
        STR     r5, outh
        LDR     r0, =SpriteReason_CreateSprite+&100
        LDR     r1, fgsa
        ADRL    r2, fg_name
        MOV     r3, #0
        SWI     XOS_SpriteOp
        BVS     %FT99

        ; Create temp buffer for calculating drop shadow
        MUL     r3, r4, r5
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        BVS     %FT99
        STR     r2, dropbuf

        ; Switch output to the sprite
        MOV     r0, #SpriteReason_SwitchOutputToSprite + &100
        LDR     r1, fgsa
        ADRL    r2, fg_name
        MOV     r3, #0  ; No save area
        SWI     XOS_SpriteOp
        BVS     %FT99
        ASSERT  :INDEX: spriteredir=0
        STMIA   sp,{r0-r3}

        ; Get a scaling table for the user's sprite onto the stack
        MOV     r0, #&100
        LDR     r1, inarea
        LDR     r2, inspr
        ADR     r6, scale_block2
        ADR     r7, tx_block2
        SWI     XWimp_ReadPixTrans

        ; try and claim memory for pixtable
        MOVVC   r0, r1
        MOVVC   r1, r2
        BLVC    GetSpritePixTable

        ; Plot source sprite into output
        MOVVC   r0, #SpriteReason_PutSpriteScaled
        LDRVC   r1, inarea
        LDRVC   r2, inspr
        MOVVC   r3, #0
        LDRVC   r4, outyeig
        MOVVC   lr, #1
        MOVVC   r4, lr, LSL r4
        ADDVC   r4, r4, #DS_DropShadowDistance
        MOVVC   r5, #0
        BLVC    DoSpriteOp

        ; free temporary pix trans block
        ADR     R14,tx_block2
        SavePSR R1
        Push    "R0-R1"
        CMP     R7,#0
        BLE     %FT05
        TEQ     R14,R7
        MOVNE   R0,#ModHandReason_Free
        MOVNE   R2,R7
        SWINE   XOS_Module
05
        ; Restore screen redirection
        ADR     R0,spriteredir+8
        LDMIA   R0,{R0-R3}
        SWI     XOS_SpriteOp
        Pull    "R0-R1"
        RestPSR R1,,f
        BVS     %FT99

        ; Get pointer to pixel data
        LDR     r6, fgsa
        ADD     r6, r6, #SpriteAreaCBsize+SpriteCBsize
        STR     r6, outdata
        ADD     r6, r6, #3

        ; Fix up alpha channel if the source had a mask
        LDR     r0, inmask
        CMP     r0, #0
        BEQ     %FT20
        LDR     r11, outh
        LDR     r7, outyeig
        MOV     r0, #DS_DropShadowDistance
        SUB     r11, r11, r0, LSR r7
        SUB     r11, r11, #1
        LDR     r9, inmode
        EOR     r9, r9, #&80000000
10
        SUBS    r11, r11, #1
        BLT     %FT20
        LDR     r7, outyeig
        LDR     r8, inyeig
        MOV     r4, r11, LSL r7
        MOV     r4, r4, LSR r8
        LDR     r7, outxeig
        LDR     r8, inxeig
        MOV     r10, #0
15
        MOV     r3, r10, LSL r7
        MOV     r3, r3, LSR r8
        MOV     r0, #SpriteReason_ReadPixelMask
        LDR     r1, inarea
        LDR     r2, inspr
        BL      DoSpriteOp
        MOVVS   r5, #0 ; Probably out of bounds
        CMP     r5, #0
        TSTNE   r9, #&80000000 ; Standard mask?
        MOVNE   r5, #255
        STRB    r5, [r6], #4
        LDR     lr, outw
        ADD     r10, r10, #1
        CMP     r10, lr
        BLT     %BT15
        B       %BT10
20

        ; Build the drop shadow
        LDR     r0, outdata
        LDR     r1, dropbuf
        LDR     r2, outw
        LDR     r3, outh
        LDR     r4, outxeig
        LDR     r5, outyeig
        MOV     r11, #0
        ADD     r0, r0, #3
25
        MOV     r10, #0
26
        MOV     r7, #DS_DropShadowDistance
        SUB     r6, r10, r7, LSR r4
        SUB     r7, r11, r7, LSR r5
        ; Sample a 3x3 area from (r6-1,r7-1) to (r6+1,r7+1)
        MOV     r9, #3
        SUB     r6, r6, #1
        SUB     r7, r7, #1
        MOV     r8, #0
27
        BL      GTDS_Sample
        ADD     r6, r6, #1
        BL      GTDS_Sample
        ADD     r6, r6, #1
        BL      GTDS_Sample
        SUB     r6, r6, #2
        SUBS    r9, r9, #1
        ADD     r7, r7, #1
        BNE     %BT27
        ; Scale by drop shadow alpha
        LDR     r9, =(DS_DropShadowAlpha*256)/9
        MUL     r8, r9, r8
        MOV     r8, r8, LSR #16
        STRB    r8, [r1], #1
        ADD     r10, r10, #1
        CMP     r10, r2
        BLT     %BT26
        ADD     r11, r11, #1
        CMP     r11, r3
        BLT     %BT25

        ; Now composite the two
        SUB     r0, r0, #3
        LDR     r1, dropbuf
        MUL     r2, r3, r2
30
        ; Read drop shadow
        LDRB    r3, [r1], #1
        CMP     r3, #128
        ADDGE   r3, r3, #1
        ; Read image alpha
        LDRB    r4, [r0, #3]
        CMP     r4, #128
        ADDGE   r4, r4, #1
        ; Make drop shadow invisible when viewed through foreground
        RSB     lr, r4, #256
        MUL     r3, lr, r3
        MOV     r3, r3, LSR #8
        TEQ     r4, #0
        ; Adjust foreground alpha
        LDRNE   lr, fgalpha
        MULNE   r4, lr, r4
        MOVNES  r4, r4, LSR #8
        BEQ     %FT50
        LDRB    r5, [r0, #0]
        LDRB    r6, [r0, #1]
        LDRB    r7, [r0, #2]
        ; Composite blend is required
        ; Ac = 1-((1-As)*(1-Ad))
        ; s = As/Ac
        ; Rc = Rs*s + Rd*(1-s)
        ; Gc = Gs*s + Gd*(1-s)
        ; Bc = Bs*s + Bd*(1-s)
        ; Skip blend if Ad==0
        CMP     r3, #0
        MOVEQ   r3, r4
        BEQ     %FT45
        ; Calculate Ac
        RSB     lr, r4, #256
        RSB     r3, r3, #256
        MUL     r3, lr, r3
        MOV     r3, r3, LSR #8
        RSB     r3, r3, #256 ; r3 = Ac
        ; Calculate s
        MOV     r4, r4, LSL #8
        DivRem  r8, r4, r3, lr, norem ; r8 = s
        ; Calculate final RGB
        ; This is rather simple, since we want the drop shadow to be black
        MUL     r5, r8, r5
        MUL     r6, r8, r6
        MUL     r7, r8, r7
        MOV     r5, r5, LSR #8
        MOV     r6, r6, LSR #8
        MOV     r7, r7, LSR #8
45
        ORR     r4, r5, r6, LSL #8
        ORR     r4, r4, r7, LSL #16
50
        CMP     r3, #128
        SUBGT   r3, r3, #1
        ORR     r4, r4, r3, LSL #24
        STR     r4, [r0], #4
        SUBS    r2, r2, #1
        BNE     %BT30        

        MOV     r0, #ModHandReason_Free
        LDR     r2, dropbuf
        TEQ     r2, #0
        SWINE   XOS_Module

        ; Generate any translation table that's needed to plot this sprite
        LDR     r0, fgsa
        ADRL    r1, fg_name
        MOV     r2, #-1
        MOV     r3, #-1
        MOV     r4, #0
        MOV     r5, #16
        SWI     XColourTrans_GenerateTable
        BVS     %FT99
        MOVS    r3, r4
        EXIT    EQ
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        BVS     %FT99
        LDR     r0, fgsa
        MOV     r4, r2
        MOV     r2, #-1
        MOV     r3, #-1
        SWI     XColourTrans_GenerateTable
        STRVC   r4, fgtranstable
        EXIT    VC
        
        FRAMSTR r0
        MOV     r0, #ModHandReason_Free
        MOV     r2, r4
        SWI     XOS_Module
        SETV        
        EXIT

99
        FRAMSTR r0
        MOV     r0, #ModHandReason_Free
        LDR     r2, dropbuf
        TEQ     r2, #0
        SWINE   XOS_Module
        SETV
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; GTDS_Sample
;
; In    r0 -> source data
;       r2 = width
;       r3 = height
;       r6 = x
;       r7 = y
;       r8 = accumulator
;
; Out   r8 updated
;

GTDS_Sample ROUT
        CMP     r6, r2
        CMPLO   r7, r3
        MOVHS   pc, lr
        Entry
        MLA     lr, r2, r7, r6
        LDRB    lr, [r0, lr, LSL #2]
        ADD     r8, r8, lr
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; GetParentBox
;
; In    r0 = flags
;       r2 -> box supplied to Wimp_DragBox
;       r3 -> box wish user to 'see'
;       r4 -> optional parent box
;       Mouse pointer has a location (hopefully over a window)
;
; Out   r5-r8 = parent box
;
GetParentBox ROUT
        Entry "r0-r4"
        TestAFlag r0, BoundTo, Screen, r14
        BEQ     %FT10
        TestAFlag r0, BoundTo, Window, r14
        BEQ     %FT20
        TestAFlag r0, BoundTo, UserBox, r14
        BEQ     %FT30
        ADR     r0, ErrorBlock_BadParameters
        MOV     r1, #0
        BL      LookupError
        SETV
        BVS     %FT90

10
        ; Bound to screen - find screen limits
        BL      GetScreenGWindow
        MOV     r5, r0
        MOV     r6, r1
        ADD     r7, r2, #1
        ADD     r8, r3, #1
        LDR     r3, [sp, #Proc_LocalStack + 3*4]
        B       %FT50

20
        ; Bound to window the mouse pointer's over

        ; Get the pointer's window
        SUB     sp, sp, #b_size
        MOV     r1, sp
        SWI     XWimp_GetPointerInfo
        LDR     r1, [sp, #b_window]
        ADD     sp, sp, #b_size
        BVS     %FT90

        ; Get that window's windowstate
        SUB     sp, sp, #u_windowstate
        STR     r1, [sp, #u_handle]
        MOV     r1, sp
        SWI     XWimp_GetWindowState

        ; Get the work area from the windowstate
        ADD     r1, sp, #u_wax0
        LDMIA   r1, {r5-r8}
        ADD     sp, sp, #u_windowstate
        BVS     %FT90

        B       %FT50

30
        ; Bound to user specified box
        LDMIA   r4, {r5-r8}

50
        ; Unadjusted parent box in r5-r8

        ; Pick up flags again
        LDR     r0, [sp, #0*4]

        ; Pick up two boxes again
        LDR     r2, [sp, #2*4]
        LDR     r3, [sp, #3*4]

        TestAFlag r0, Bound, Box, r14
        BNE     %FT60

        ; Bounding the box to the parent - adjust for box differences
        LDR     lr, [r2, #box_x0]
        SUB     r5, r5, lr
        LDR     lr, [r3, #box_x0]
        ADD     r5, r5, lr
        LDR     lr, [r2, #box_y0]
        SUB     r6, r6, lr
        LDR     lr, [r3, #box_y0]
        ADD     r6, r6, lr
        LDR     lr, [r2, #box_x1]
        SUB     r7, r7, lr
        LDR     lr, [r3, #box_x1]
        ADD     r7, r7, lr
        LDR     lr, [r2, #box_y1]
        SUB     r8, r8, lr
        LDR     lr, [r3, #box_y1]
        ADD     r8, r8, lr
        EXIT

60
        ; Else, we must be bounding the pointer, so some faffing to do

        ; Get the pointer's position
        SUB     sp, sp, #b_size
        MOV     r1, sp
        SWI     XWimp_GetPointerInfo
        ADD     r14, sp, #b_x
        LDMIA   r14, {r1,r2}
        ADD     sp, sp, #b_size
        BVS     %FT90

        ; Correct the parent box with a border equal to the distance from the
        ; pointer to the drag box edge.
        LDR     r0, [r3, #box_x0]
        ADD     r5, r5, r0
        SUB     r5, r5, r1
        LDR     r0, [r3, #box_y0]
        ADD     r6, r6, r0
        SUB     r6, r6, r2
        LDR     r0, [r3, #box_x1]
        ADD     r7, r7, r0
        SUB     r7, r7, r1
        Push    "r1,r2"
        MOV     r0, #-1
        MOV     r1, #VduExt_XEigFactor
        SWI     XOS_ReadModeVariable
        MOVVC   r0, r2
        Pull    "r1,r2"
        EXIT    VS
        MOV     lr, #1
        SUB     r7, r7, lr, ASL r0      ; To correct for non-exclusive-top-rightness of mouse's 'box'
        LDR     r0, [r3, #box_y1]
        ADD     r8, r8, r0
        SUB     r8, r8, r2
        Push    "r1,r2"
        MOV     r0, #-1
        MOV     r1, #VduExt_YEigFactor
        SWI     XOS_ReadModeVariable
        MOVVC   r0, r2
        Pull    "r1,r2"
        EXIT    VS
        MOV     lr, #1
        SUB     r8, r8, lr, ASL r0      ; To correct for non-exclusive-top-rightness of mouse's 'box'

        ; Parent box now constructed
        EXIT

90
        STRVS   r0, [sp]
        EXIT

99
        DCD     VduExt_OrgX
        DCD     VduExt_OrgY
        DCD     -1

        LTORG
bg_name         DCB     "bg", 0
fg_name         DCB     "fg", 0
setcolnoneset   DCB     18,0,128,23,17,3,0,0,0,0,0,0,0
setcolallset    DCB     18,0,128+63,23,17,3,&c0,0,0,0,0,0,0

        MakeInternatErrorBlock BadParameters,,BadParm

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; ByteSizeOfSprite
;
; In    r0 = x-OS units
;       r1 = y-OS units
;       r2 = drag flags
;
; Out   r3 = size of sprite
;       r4 = size of foreground sprite
;
ByteSizeOfSprite Entry "r0,r1,r2,r5"

        ; Convert x-OS units to pixels per row
        MOV     r0, #-1
        BL      PixToOSUnitFactors
        BVS     %FT10

 [ debugstart
        DREG    r5,"Factors are ",cc
        DREG    r2, ","
 ]
        ; Convert x-OS units to pixels per row
        LDR     r0, [sp]
        MOV     r0, r0, LSR r5

        ; Convert y-OS units to rows
        MOV     r1, r1, LSR r2
        ADD     r1, r1, #1              ; Add one for overlap effects

        ; Convert pixels per row into bytes per row
        Push    "r0,r1"
        MOV     r0, #-1
        MOV     r1, #VduExt_Log2BPP
        SWI     XOS_ReadModeVariable
        ADDVS   sp, sp, #2*4
        BVS     %FT10
        Pull    "r0,r1"
        MOV     lr, r0
        MOV     r0, r0, ASL r2          ; Bits per row
        MOV     r5, #32
        MOV     r5, r5, LSR r2          ; Pixels per word
        SUB     r5, r5, #1              ; minus one
        MOV     r5, r5, ASL r2          ; convert back to bits
        ADD     r0, r0, r5, ASL #1      ; Add two lots of that for left and right wastage
        MOV     r5, #1
        ADD     r0, r0, r5, ASL r2      ; Add another pixel for overlap effects
        ADD     r0, r0, #31             ; Round to a word
        BIC     r0, r0, #31
        MOV     r0, r0, LSR #3          ; Convert bits to bytes

        ; Multiply up and add the header
        MUL     r3, r0, r1
        ADD     r3, r3, #SpriteCBsize

        ; If translucent drop shadow then we'll be using a 32bpp ABGR fg sprite
        LDRB    r5, Translucency
        CMP     r5, #1
        BNE     %FT01
        ; Size is simply w*h*4+SpriteCBsize
        MUL     r4, lr, r1
        MOV     r4, r4, LSL #2
        ADD     r4, r4, #SpriteCBsize
        B       %FT10

01
        ; Not using translucent drop shadow. Calculate standard fg sprite size.
        ; Work out bytes per mask row
        CMP     r2, #3
        MOVGT   r2, #1 ; If >8bpp then must be new style sprite, so 1bpp mask
        ; Width in bits
        MOV     lr, lr, LSL r2
        ; Round up to word
        ADD     lr, lr, #31
        ; Round down to bytes
        BIC     lr, lr, #31
        MOV     lr, lr, LSR #3
        ; Add on to existing base size
        MLA     r4, lr, r1, r3

10
        STRVS   r0, [sp]
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; CoordSizeOfSprite
;
; In    (r1,r2)->sprite
;
; Out   (r0,r1) OS unit size of sprite
;
CoordSizeOfSprite Entry "r2-r6"
        MOV     r0, #SpriteReason_ReadSpriteSize
        BL      DoSpriteOp
        MOVVC   r0, r6
        BLVC    PixToOSUnitFactors
        EXIT    VS
        TEQ     r2,#0
        MOVNE   r1, r4, ASL r2
        MOVEQ   r1,r4

        TEQ     r5,#0
        MOVNE   r0, r3, ASL r5
        MOVEQ   r0, r3

        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; PixToOSUnitFactors
;
; In    r0 = Mode to get factors for
;
; Out   r2 = Y factor
;       r5 = X factor
;
PixToOSUnitFactors Entry "r1"
        MOVVC   r1, #VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   r5, r2
        [ {FALSE}
        MOVVC   r1, #VduExt_Log2BPC
        SWIVC   XOS_ReadModeVariable
        ADDVC   r5, r5, r2
        MOVVC   r1, #VduExt_Log2BPP
        SWIVC   XOS_ReadModeVariable
        SUBVC   r5, r5, r2
        ]
        MOVVC   r1, #VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; MakeSpriteArea
;
; In    r1 = pointer to pointer to sprite area
;       r3 = size of sprite area
;
; Out   Sprite area RMA claimed and initialised
;
MakeSpriteArea Entry "r0,r1,r2"
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        STRVS   r0, [sp]
        EXIT    VS
        STR     r2, [r1]
        STR     r3, [r2, #saEnd]
        MOV     r0, #16
        STR     r0, [r2, #saFirst]
        MOV     r1, r2
        LDR     r0, =SpriteReason_ClearSprites + &100
        SWI     XOS_SpriteOp
        EXIT    VC

        ; Error clearing the sprite area - free it and return
        STR     r0, [sp]                ; The error
        LDR     r1, [sp, #1*4]
        LDR     r2, [r1]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        MOV     r2, #0
        STR     r2, [r1]
        EXIT

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; DoSpriteOp
;
; In    r0 = SpriteOp (Without &100 or &200)
;       r1 = Sprite area:
;               0 - system sprite area
;               1 - Wimp's sprite area
;               other - user sprite area
;       r2 = Sprite name
;
DoSpriteOp Entry
        TEQ     r1, #1
        BEQ     %FT50
        TEQ     r1, #0
        ORRNE   r0, r0, #&100
        SWI     XOS_SpriteOp
        EXIT
50
        SWI     XWimp_SpriteOp
        EXIT

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Junk all allocated sprite areas (should call after drag finished)
;
Done Entry "r0,r1,r2"

 [ debugstart
        DLINE "Done start"
 ]

        ; Kill any drag, just in case it's ours!
        MOV     r1, #0
        SWI     XWimp_DragBox
        CLRV                    ; Cancel any error

        ADRVC   r1, fgsa
        BLVC    CheckedRMAFree
        ADRVC   r1, bg0sa
        BLVC    CheckedRMAFree
        ADRVC   r1, bg1sa
        BLVC    CheckedRMAFree
        ADRVC   r1, fgtranstable
        BLVC    CheckedRMAFree
 [ debugstart
        DLINE "done end"
 ]
        EXIT    VC

        ; Error exit - return the original error and bumble through the rest!
        STR     r0, [sp]
        ADR     r1, fgsa
        BL      CheckedRMAFree
        ADR     r1, bg0sa
        BL      CheckedRMAFree
        ADR     r1, bg1sa
        BL      CheckedRMAFree
        ADR     r1, fgtranstable
        BL      CheckedRMAFree
        EXIT


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; CheckedRMAFree
;
; In    r1 = pointer to pointer to RMA block to free.
;
; Out   block freed
;
CheckedRMAFree Entry "r0,r2"
        LDR     r2, [r1]
        TEQ     r2, #0
        EXIT    EQ

        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        STRVS   r0, [sp]

        ; Clear the block regardless (avoids error loops)
        MOV     r2, #0
        STR     r2, [r1]
        EXIT

        END
@


4.9
log
@Avoid unnecessary remainder calculations
Detail:
  s/StartUp - Avoid unnecessary remainder calculations in DivRem macro
Admin:
  Tested on Cortex-A15


Version 0.20. Tagged as 'DragASprit-0_20'
@
text
@d92 2
d212 4
d625 1
a625 1
        LDR       r14, x_size
d633 1
a633 3
        LDR       r14, y_size
        SUB       r1, r1, r14, LSR #1           ; This value will be stord after next branch
        B         %FT65
d651 1
a651 3
        LDR     r2, x_size
        TestAFlag r0, DropShadow, Present, r14
        SUBEQ   r2, r2, #DS_DropShadowDistance
d658 1
a658 1
        LDR     r2, x_size
a659 2
        TestAFlag r0, DropShadow, Present, r14
        ADDEQ   r1, r1, #DS_DropShadowDistance
d670 3
a672 3
        MOV     r1, #0
        TestAFlag r0, DropShadow, Present, r14
        SUBEQ   r1, r1, #DS_DropShadowDistance
d685 2
d688 1
a688 2
        TestAFlag r0, DropShadow, Present, r14
        ADDEQ   r2, r2, #DS_DropShadowDistance
a703 1
        TestAFlag r0, DropShadow, Present, r14
d708 1
a708 1
        LDR     r2, x_size
a709 1
        SUBEQ   r1, r1, #DS_DropShadowDistance
d714 4
a717 1
        ADDEQ   r1, r1, #DS_DropShadowDistance
a718 1
        LDR     r2, y_size
a719 1
        SUBEQ   r1, r1, #DS_DropShadowDistance
@


4.8
log
@Fix flickery drags. Tweak translucent drop shadows.
Detail:
  s/Drag - When moving the dragged sprite, avoid plotting over the top of its old location in order to prevent flicker caused by overdraw. This flicker wasn't so apparent with the older translucent or hatched sprite plotting, but is a lot more noticeable with ABGR sprites.
  s/StartUp - Use 50% alpha for the ABGR sprite in true colour modes, to match hatching & non-drop shadow variants. Also make the drop shadow completely invisible when behind the sprite - better than having it there but making it almost completely imperceptible in order to try and hide the fact that it always looks a bit funny
Admin:
  Tested on Iyonix


Version 0.19. Tagged as 'DragASprit-0_19'
@
text
@d1180 1
a1180 1
        DivRem  r8, r4, r3, lr ; r8 = s
@


4.7
log
@Add support for translucent drop shadows
Detail:
  Drop shadows were disabled in DragASprite 0.17 when using translucency due to them looking a bit ugly. This change brings them back, but implemented in a different manner to produce a better result.
  Instead of using a standard sprite and rendering it with translucency, we create a sprite with an alpha channel and use the alpha to control the relative intensity of the dragged sprite and its shadow. The alpha channel also allows us to feather/blur the shadow, getting rid of the hard edges that were mostly resposible for the previous version looking so poor.
  s/Drag - Adjust TranslucentPlot to support plotting of the ABGR sprite
  s/StartUp - Adjust drag startup logic so that >2bpp uses an ABGR sprite, 2bpp uses a translucent plot (+ hard shadow), and 1bpp continues to use dithering/hatching. Add new GenerateTranslucentDropShadow routine that's responsible for creating the ABGR sprite. Adjust GetByteSizeOfSprite to return separate values for the size of the foreground (masked/ABGR) and background sprites.
  s/Support - Add new check for whether the kernel supports ABGR sprites
Admin:
  Tested on BB-xM
  Fixes issue #390:
  https://www.riscosopen.org/tracker/tickets/390


Version 0.18. Tagged as 'DragASprit-0_18'
@
text
@d76 2
a77 1
DS_DropShadowFGAlpha     *      160      
d930 1
d954 9
d1149 2
a1150 3
        ; Make drop shadow less intense when viewed through foreground
        ADD     lr, r4, r4, LSR #2
        RSB     lr, lr, #512
d1152 1
a1152 1
        MOV     r3, r3, LSR #9
d1155 1
a1155 1
        MOVNE   lr, #DS_DropShadowFGAlpha
@


4.6
log
@Disable drop shadow when using translucency
Detail:
  s/StartUp - By popular demand, automatically disable the drop shadow when we're performing a translucent drag, as general opinion seems to be that translucent drags will look better without it. Reportedly this also matches the behaviour of ROL's version of the module.
Admin:
  Tested on BB-xM


Version 0.17. Tagged as 'DragASprit-0_17'
@
text
@d75 2
d154 2
a155 2
        LDRNEB  R2, TranslucencyOK
        ANDNES  R2, R2, LR
a156 1
        STRB    R2, Translucency
d158 9
a166 1
        ; Disable hatching + dropshadow (drop shadow is possible, but general opinion is that it looks better without when translucency is in use)
a167 1
        BIC     R0, R0, #DS_DropShadow_Mask
d215 8
d233 1
a233 1
        ; Claim fg, bg0 and bg1 at that size
d239 2
a240 2
        ; Twice as much space is needed for fg due to the potential need for a mask
        MOVVC   r3, r3, ASL #1
d251 1
a251 1
        ; Create the foreground sprite (fg)
d253 2
a254 2
        LDR     r1, fgsa
        ADRL    r2, fg_name
d263 13
d277 1
d279 3
a281 1
        ; Create the two background sprites (bg0 and bg1)
d283 2
a284 2
        LDR     r1, bg0sa
        ADRL    r2, bg_name
a285 3
        LDRVC   r1, bg1sa
        ADRVCL  r2, bg_name
        SWIVC   XOS_SpriteOp
a290 1

d301 3
a303 68
        Push    "R0-R5"
        LDR     r0, [sp, #4*6 + Proc_LocalStack + 1*4]
        TEQ     R0,#1
        MOVNE   R5,#2                                   ; sprite is a name
        LDRNE   r1, [sp, #4*6 + Proc_LocalStack + 2*4]

        BNE     ego

        MOV     R0, #16
        SWI     XWimp_ReadSysInfo
        SWIVS   XWimp_BaseOfSprites                     ; cater for old Wimps
        MOV     R3,R0
        MOV     R0,#SpriteReason_SelectSprite+256
        LDR     r2, [sp, #4*6 + Proc_LocalStack + 2*4]
        SWI     XOS_SpriteOp
        MOVVC   R0,R1
        MOVVC   R1,R2
        MOVVC   R5,#3
        BVC     ego

        MOV     R0,#SpriteReason_SelectSprite+256
        MOV     R1,R3
        SWI     XOS_SpriteOp
        MOVVS   R7,#0
        BVS     wibble

        MOV     R5,#3                                   ; pointer
;        LDR     R0,fgsa                                 ; any sprite area
        MOV     R0,R1                                   ;; eh? use the correct sprite area
        MOV     R1,R2                                   ;; and remember to point R1 at the sprite!!

ego

        MOV     R2,#-1
        MOV     R3,#-1
        MOV     R4,#0
        SWI     XColourTrans_SelectTable

    [ debugstart
        DREG    R4," table size"
   ]

        CMP     R4,#17
        BLT     wibble                                  ; wimp table will be ok

        Push    R0
        MOV     R0,#ModHandReason_Claim
        MOV     R3,R4
        SWI     XOS_Module
        Pull    R0,VC
        ADDVS   sp,sp,#4
        MOVVS   R7,#0
        BVS     wibble

        MOV     R4,R2
        MOV     R2,#-1
        MOV     R3,#-1

        SWI     XColourTrans_SelectTable
        MOVVC   R7,R4
        MOVVS   R7,#0

        MOVVS   R2,R4
        MOVVS   R0,#ModHandReason_Free
        SWIVS   XOS_Module
wibble
        CLRV
        Pull    "R0-R5"
d761 1
d831 429
a1259 1
; ByteSizeOfSprite
d1269 2
a1270 1
GetParentBox Entry "r0-r4"
d1425 1
d1427 2
a1428 1
; Out   r3 = size of sprite (multiple of words)
d1457 1
d1474 25
d1581 1
a1581 1
        MOV     r2, #Nowt
d1628 2
d1637 3
a1639 1
        ADRL    r1, fgsa
d1641 1
a1641 1
        ADRL    r1, bg0sa
d1643 1
a1643 1
        ADRL    r1, bg1sa
d1658 1
a1658 1
        TEQ     r2, #Nowt
d1666 1
a1666 1
        MOV     r2, #Nowt
@


4.5
log
@Add support for translucent rendering of dragged sprites
Detail:
  As per ROL's version of DragASprite, we now support translucent drags as well.
  As long as you have a suitable SpriteExtend version, DragASprite will try and use translucent drags wherever it used to use hatching before.
  The only exception to this is in 1bpp modes, where blending is essentially impossible and so it sticks with the old hatching code.
  As with ROL's version, the only way of disabling translucent drags (short of loading an older SpriteExtend) is to set bit 8 of the flags in R0 when calling DragASprite_Start.
  File changes:
  s/Drag - Drag sprite rendering now goes via new TranslucentPlot routine, to allow translucent/non-translucent rendering to be performed as appropriate
  s/Startup, s/Support - Updated with code to detect when translucency is and isn't supported. A few OS_SpriteOp reason code magic numbers replaced with symbols.
Admin:
  Tested on BB-xM


Version 0.16. Tagged as 'DragASprit-0_16'
@
text
@d74 1
a74 1
DS_TranslucencyValue_256 *      104     ; Use a value of about 40% in 256 colour modes. With the default Wimp theme sprites this greatly helps file icons to retain their colour when dragged over window & desktop backgrounds.
d88 1
d110 2
d122 40
d203 1
a203 1
        LDR     r2, [sp, #Proc_LocalStack + 0*4]
d350 1
a350 1
        LDR     R0, [sp, #Proc_LocalStack + 0*4]
d352 1
a352 1
        STR     R0, [sp, #Proc_LocalStack + 0*4]
d392 1
a392 1
        LDR     r0, [sp, #4*4 + Proc_LocalStack + 0*4]
d439 1
a439 1
        LDR     r0, [sp, #4*4 + Proc_LocalStack + 0*4]
d520 1
a520 1
        LDR     R0, [sp, #Proc_LocalStack + 0*4]
a523 24
        ; Check SpriteExtend version if we're not sure yet
        ; (ROM init order means that checking on startup won't work)
        LDRB    R0,TranslucencyOK
        CMP     R0,#128
        BNE     %FT09
        ADRL    R0,SpriteExtendCheck
        SWI     XOS_CLI
        MOVVC   R0,#255
        MOVVS   R0,#0
        CLRV
        STRB    R0,TranslucencyOK
09
        ; Work out translucency value to use for current screen mode
        TEQ     R8,#3
        MOVEQ   LR,#DS_TranslucencyValue_256
        MOVNE   LR,#DS_TranslucencyValue
        ; If translucency available, and we've got more than 2 colours to play
        ; with, prefer that over hatching
        MOVS    R3,R8
        LDRNEB  R3,TranslucencyOK
        ANDNES  R3,R3,LR
        STRB    R3,Translucency
        BNE     %FT53

d637 1
a637 1
        LDR     r0, [sp, #Proc_LocalStack + 0*4]
@


4.4
log
@  Updated build structure to use the shared AAsmModule makefile.
  Updated to build using objasm instead of aasm.
  Sources changed to be objasm-compatible.
Admin:
  Requires Library 0.71 or later.
  Requires BuildSys 3.06 or later.
  Requires Env 0.65 or later.

Version 0.15. Tagged as 'DragASprit-0_15'
@
text
@d46 2
a47 2
;               8       0       Hatch the sprite
;                       1       Never hatch the sprite
d72 3
a74 1
DS_DropShadowDistance   *       8       ; OS units
a240 1
;        SWI     Wimp_BaseOfSprites
d242 1
a242 1
        MOV     R0,#24+256                              ; select sprite
d250 1
a250 1
        MOV     R0,#24+256
d454 1
d458 1
a458 1
        MOVVC   R0,#&128
d479 25
a503 1
        BNE     %FT53                           ; if no hatching then
d606 1
a606 1
;        MOV     R0,#12+256
@


4.3
log
@Module made 32-bit compatible. Placed under srccommit control.

Version 0.14. Tagged as 'DragASprit-0_14'
@
text
@d88 1
a88 1
StartUp ENTRY "r0-r8", StartUp_frame_size
d599 1
a599 1
        
d605 1
a605 1
        
d613 1
a613 1
        
d623 1
a623 1
        
d832 1
a832 1
GetParentBox ENTRY "r0-r4"
d990 1
a990 1
ByteSizeOfSprite ENTRY "r0,r1,r2,r5"
d1045 1
a1045 1
CoordSizeOfSprite ENTRY "r2-r6"
d1070 1
a1070 1
PixToOSUnitFactors ENTRY "r1"
d1095 1
a1095 1
MakeSpriteArea ENTRY "r0,r1,r2"
d1130 1
a1130 1
DoSpriteOp ENTRY
d1145 1
a1145 1
Done ENTRY "r0,r1,r2"
d1186 1
a1186 1
CheckedRMAFree ENTRY "r0,r2"
@


4.2
log
@Ursula branch merged.
@
text
@d230 1
a230 1
        TEQ     R0,#1   
d247 1
a247 1
        BVC     ego  
d261 1
a261 1
               
d264 1
a264 1
        MOV     R4,#0 
d273 1
a273 1
                                                        
d279 1
a279 1
        ADDVS   sp,sp,#4 
d286 1
a286 1
        
d381 1
a381 1
                  
d431 1
a431 1
                          
d433 2
a434 2
        
        MOV     R1,PC
d442 1
a442 1
        TEQP    PC,R1
d445 1
a445 1
                     
d470 1
a470 1
              
d474 1
a474 1
      [ hatching                    
d477 1
a477 1
        BNE     %FT53                           ; if no hatching then 
d483 1
a483 1
        
d503 1
a503 1
        
d506 1
a506 1
        ADDNE   R3,R3,#31                       
d519 2
a520 2
        Push    "R3"                
52            
d538 1
a538 1
        
d540 1
a540 1
51      
d548 1
a548 1
        STR     LR,[R6],#4                      ; apply masking data to image                        
d550 1
a550 1
           
d553 1
a553 1
        
d574 1
a574 1
               ]      
d1057 1
a1057 1
        MOVEQ   r0, r3          
@


4.1
log
@Initial revision
@
text
@d20 1
d48 3
a50 1
;               9-31    Reserved for future use, should be set to 0.
d236 4
a239 1
        SWI     Wimp_BaseOfSprites
d256 3
a258 1
        LDR     R0,fgsa                                 ; any sprite area
d595 29
@


4.1.4.1
log
@* Fixed bug which meant translation table used for ROM sprites was corrupt -
  since they have traditionally been 16-colour sprites, it defaulted to the
  Wimp palette, and nobody noticed
* Added checking of Wimp_ReadSysInfo 16 to determine the ROM/RAM sprite pool
  relative priority
@
text
@d233 1
a233 4
        MOV     R0, #16
        SWI     XWimp_ReadSysInfo
        SWIVS   XWimp_BaseOfSprites                     ; cater for old Wimps
;        SWI     Wimp_BaseOfSprites
d250 1
a250 3
;        LDR     R0,fgsa                                 ; any sprite area
        MOV     R0,R1                                   ;; eh? use the correct sprite area
        MOV     R1,R2                                   ;; and remember to point R1 at the sprite!!
@


4.1.4.2
log
@Added flag bit (bit 9) to DragASprite_Start SWI. If set, sprite is placed at
pointer position and bits 0-3 are ignored.
@
text
@a19 1

d47 1
a47 3
;               9       0       Sprite's position is determined by bits 0-3
;                       1       Sprite is centred on pointer position
;               10-31   Reserved for future use, should be set to 0.
a591 29
  [ AtPointerFlag
        ; Check first if flag is set to put sprite at pointer position
        TST       r0, #DS_SpriteAtPointer
        BEQ       %FT54
        
        ; Get pointer position
        ADR       r1, ptrbuffer
        SWI       XWimp_GetPointerInfo
        BVS       %FT54
        MOV       r2, r1
        
        ; Work out x offset
        LDR       r1, [r2]
        LDR       r14, [r3, #box_x0]
        SUB       r1, r1, r14
        LDR       r14, x_size
        SUB       r1, r1, r14, LSR #1
        STR       r1, bl_offset_x               ; Store x offset
        
        ; Work out y offset
        LDR       r1, [r2, #4]
        LDR       r14, [r3, #box_y0]
        SUB       r1, r1, r14
        LDR       r14, y_size
        SUB       r1, r1, r14, LSR #1           ; This value will be stord after next branch
        B         %FT65
54
  ]
        
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

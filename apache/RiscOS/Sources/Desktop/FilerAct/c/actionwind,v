head	4.14;
access;
symbols
	FilerAct-0_62:4.14
	FilerAct-0_61:4.14
	FilerAct-0_60:4.14
	FilerAct-0_59:4.14
	FilerAct-0_58:4.14
	FilerAct-0_57:4.14
	FilerAct-0_55:4.13
	FilerAct-0_54:4.12
	FilerAct-0_53:4.11
	FilerAct-0_52:4.10
	FilerAct-0_51:4.9
	FilerAct-0_50:4.7
	FilerAct-0_49:4.6
	FilerAct-0_48:4.5
	RO_5_07:4.5
	FilerAct-0_47:4.5
	FilerAct-0_46:4.5
	FilerAct-0_45:4.4
	dellis_autobuild_BaseSW:4.4
	FilerAct-0_44:4.4
	FilerAct-0_43:4.3
	sbrodie_sedwards_16Mar2000:4.3
	FilerAct-0_42:4.3
	Ursula_merge:4.2.2.1
	dcotton_autobuild_BaseSW:4.4
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2.2.1
	Ursula_RiscPC:4.2.2.1.0.2
	nicke_FilerAct_0_39:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2.2.1
	UrsulaBuild_FinalSoftload:4.2.2.1
	rthornb_UrsulaBuild-12Aug1998:4.2.2.1
	aglover_UrsulaBuild-05Aug1998:4.2.2.1
	rthornb_UrsulaBuild-29Jul1998:4.2.2.1
	rthornb_UrsulaBuild-22Jul1998:4.2.2.1
	rthornb_UrsulaBuild-15Jul1998:4.2.2.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.2.2.1
	rthornb_UrsulaBuild-17Jun1998:4.2.2.1
	rthornb_UrsulaBuild-03Jun1998:4.2.2.1
	rthornb_UrsulaBuild-27May1998:4.2.2.1
	rleggett_FilerAct-0_42:4.2.2.1
	rthornb_UrsulaBuild-21May1998:4.2.2.1
	rthornb_UrsulaBuild_01May1998:4.2.2.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.14
date	2012.07.13.10.28.08;	author rgriffin;	state Exp;
branches;
next	4.13;
commitid	ePxQigwSIOcL9ocw;

4.13
date	2012.06.24.21.06.54;	author jlee;	state Exp;
branches;
next	4.12;
commitid	boqeHi31FmcLi0aw;

4.12
date	2011.10.23.07.55.47;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	xuMPqvl0RQswNrEv;

4.11
date	2011.10.23.07.46.59;	author rsprowson;	state Exp;
branches;
next	4.10;
commitid	7I8FKGdkajlxKrEv;

4.10
date	2011.10.20.20.36.00;	author rsprowson;	state Exp;
branches;
next	4.9;
commitid	YJZPZatOdKOo68Ev;

4.9
date	2011.10.20.20.32.44;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	DXWFsDOPRJsd58Ev;

4.8
date	2011.10.20.20.23.02;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	xmwir195eiLF18Ev;

4.7
date	2011.10.06.09.53.24;	author rgriffin;	state Exp;
branches;
next	4.6;
commitid	TPe2mWq0vF5QZgCv;

4.6
date	2011.06.29.09.21.48;	author rgriffin;	state Exp;
branches;
next	4.5;
commitid	OcnnyIVQ9uPd0ypv;

4.5
date	2002.09.23.18.25.36;	author kbracey;	state Exp;
branches;
next	4.4;

4.4
date	2000.05.16.09.32.50;	author sbrodie;	state Exp;
branches;
next	4.3;

4.3
date	2000.02.17.16.36.26;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	97.05.01.17.47.32;	author kbracey;	state Exp;
branches
	4.2.2.1;
next	4.1;

4.1
date	96.11.05.09.29.35;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.2.2.1
date	97.09.24.13.36.00;	author rleggett;	state Exp;
branches;
next	;

4.1.1.1
date	96.11.05.09.29.35;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.27.59;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.14.25.39;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.10.31.32;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.17.52;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.16.44;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.14
log
@Fixed flicker when Filer Action window is behind another window.

Version 0.56. Not tagged
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
     Control the Filer's action window.

This code compiles into a relocatable module which controls the Filer's
action window.

0.00  08-May-89  JSR  Copied from allfiles - a 'list all files matching
                      pattern' utility.

0.01  09-May-89  JSR  Incorporate into a wimp interface.

0.02  12-May-89  JSR  Change into being a module.

0.03  31-May-89  JSR  Change into being Filer Action Window.

0.04  20-Jun-89  JSR  First round of bug fixes:
                      Delete deletes a few before asking
                      Setting access change of title
                      Immediate display on verbose
                      Force verbose on count
                      Implement copy Local
                      Implement FilerControlAction
                      Handle pre-quit message
                      Change button name Quiet instead of Quick
                      Add stamp option
                      Return directories when copying to ensure
                         access etc gets set for them
                      Init dboxquery for quit handling

0.05  29-Jun-89  JSR  Bug fixes from FilerAct 0.01 release:
                      Restart does not quit before writing out
                         reread stuff.
                      Handle help requests

0.06  04-Jul-89  JSR  Remove const from strings.
                      Do unsigned comparison of low 4 bytes of date stamp.

0.07  29-Sep-89  JSR  Use overflowing_ memory allocation routines.
                      Treat directories as being unstamped.
                      Set time for doing doings to be twice that time
                         already taken to do one doing, bounded to between
                         Minimum_Doings_Time and Maximum_Doings_Time
                      If an error happened when setting the access to enable
                         a delete which failed, then report the access setting
                         error, not the delete error.
                      Make the top progress field keep up with the info field
                         better when writing.
                      Use standard module application generating wrapper to fix
                         ctrl-shft-f12 bug.
                      Display a summary of what was counted.
                      Add find file.
                      Fix handling of translation of rename into a copy-move for the
                         first directory.
                      Extend the functionality of copylocal to cope with non-leaf
                         destinations.
                      Adjust meaning of set access to allow 'leave alone' on access bits
0.08  16-Oct-89  JSR  Correct setting of bottom info field to not overflow its fixed buffer
                         when a long leaf name is encountered.
                      Correct error handling so that skip is present.
                      Reporting of locked errors whilst deleting improved.
                      Only allow found directories to be opened.
                      Only wimpt_complain on the first disc full.
0.09  19-Oct-89  JSR  Don't switch to Open buttons when found directory is an application.
                      Add control_action 2 to hide an operation
                      Verbose applies to count
                      Set window titles to conform to RISC_OS style.
0.10  13-Nov-89  JSR  Ensure overflowing_free is used when next_nodename is used.
                      Internationalise the text.
0.11  17-Nov-89  JSR  Declare action_environment as being file global in scope. Previously
                         the declaration of the function type button_function was assumed
                         to do this, but it doesn't.
                      Split into several parts.
                      Fix bug whereby in set_bottom_info_field a small poo was purpetrated
                         as the nul string terminator overflowed newfield.
0.12  04-Dec-89  JSR  Add the Bad_RENAME case on failed rename.
                      Relock un renamed locked files when force is on.
                      Already exists errors on renames mapped to copy-moves.
                      For NetFS owner write bit masked out on set acceses on directories (CLUDGE!).
0.13  10-Jan-90  JSR  Set the bottom info field at the end of counting as during counting.
                      Routines used locally only made static.
                      Set the title of the query box on a prequit message to match that of the
                         action window itself.
0.14  22-Jan-90  JSR  Inhibit delete progress if a locked file isn't deleted.
0.22  16-Aug-91  PJC  If start_operation fails, use werr rather than wimpt_noerr
0.30  05-Nov-93  SMC  No longer uses red error text in error version of filer action window.
*/

#if 0
#define debugact(k) dprintf k
#else
#define debugact(k) /* Disabled */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <ctype.h>

#include "Global/FSNumbers.h"
#include "Interface/HighFSI.h"
#include "swis.h"

#include "os.h"
#include "akbd.h"
#include "wimp.h"
#include "wimpt.h"
#include "werr.h"
#include "win.h"
#include "res.h"
#include "resspr.h"
#include "template.h"
#include "msgs.h"
#include "event.h"
#include "dbox.h"
#include "dboxquery.h"
#include "flex.h"
#include "heap.h"
#include "bbc.h"

#include "Options.h"
#include "allerrs.h"
#include "malloc+.h"
#include "listfiles.h"
#include "memmanage.h"
#include "actionwind.h"
#include "Initialise.h"
#include "Buttons.h"
#include "debug.h"
#include "dboxlong.h" /* locally */

#define Option_FilerAction_Verbose              0x00000001
#define Option_FilerAction_Confirm              0x00000002
#define Option_FilerAction_Force                0x00000004
#define Option_FilerAction_Newer                0x00000008
#define Option_FilerAction_Recurse              0x00000010
#define Option_FilerAction_ConfirmDeletes       0x00000020 /* RML */
#define Option_FilerAction_Faster               0x00000040 /* RML */

#ifdef USE_STATUS_IN_TITLE
static char TitleString[64];
#endif
static char PathString[ Top_Info_Field_Length + 1 ];


#define FileChar_ManyAny '*'
#define FileChar_Any     '#'

#define HELP_MESSAGE_CONTROL_NOBUTTON "1"
#define HELP_MESSAGE_CONTROL          "2"


/*
     A chain link structure
*/
typedef struct chain_link
{
     struct chain_link *forwards;
     struct chain_link *backwards;

     /* somewhere to point at the structure in which this resides */
     void *wrapper;
}    chain_link;

typedef struct
{
     chain_link     link;
     char           *buffer;
}    buffer_header;

/*
     For c.modulewrap
*/
extern os_error *i_am_now_active( void );

#define No 0
#define Yes (!No)

#define SPACE ' '

#define Max_Invocation_Name_Length 20

/*
 *   Field masks for date stamping
 */
#define DateStamped_Mask                0xfff00000
#define DateStamp_HighByte              0x000000ff

/*
     Status indications
*/
action_environment env;
const char *last_top_info_field;
static clock_t doings_time = (10*CLK_TCK)/100;
static int UpdatePath = 0, UpdateTop = 0, UpdateBottom = 0;

#define Number_Of_Actions 10
#define Number_Of_Icon_Strings 5
#define Title_Text 0
#define Top_Progress_Line_Text 1
#define Bottom_Progress_Line_Text 2
#define Top_Info_Field_Text 3
#define Help_Message_Operation_Fillin 4

static char *icon_strings[ Number_Of_Actions ][ Number_Of_Icon_Strings ] =
{
  /* title        top       bottom      top info   help           action */
  /*            progress   progress                                      */
  {   "29",        "30",     "31",     "32",         "33"    },  /* copying */
  {   "34",        "30",     "35",     NULL/*36*/,   "37"    },  /* moving (renaming) */
  {   "38",        "39",     "40",     NULL/*41*/,   "42"    },  /* deleting */
  {   "43",        "44",     "45",     NULL/*46*/,   "47"    },  /* setting access */
  {   "48",        "49",     "50",     NULL/*51*/,   "52"    },  /* settype */
  {   "53",        "54",     "55",     NULL/*56*/,   "57"    },  /* count */
  {   "34",        "30",     "58",     "32",         "37"    },  /* copy/moving */
  {   "29",        "30",     "31",     "32",         "33"    },  /* copy local */
  {   "59",        "60",     "61",     NULL/*62*/,   "63"    },  /* stamp */
  {   "64",        "65",     "66",     NULL/*67*/,   "68"    }   /* find */
};


/*
   Changed this so we show everything in faster mode, except the "bytes to go"
   field in a copy operation
*/
static BOOL show_when_faster[ Number_Of_Actions ][2] =
{
        /*     top progress bottom progress                action */
        {               No,             Yes     },      /* copying */
        {               No,             Yes     },      /* moving (renaming) */
        {               Yes,            Yes     },      /* deleting */
        {               Yes,            Yes     },      /* setting access */
        {               Yes,            Yes     },      /* settype */
        {               Yes,            Yes     },      /* count */
        {               No,             Yes     },      /* copy/moving */
        {               No,             Yes     },      /* copy local */
        {               Yes,            Yes     },      /* stamp */
        {               Yes,            Yes     }       /* find */
};

static char *action_prompt[] =
{
     "69",
     "70",
     "71",
     "72",
     "73",
     "74",
     "75",
     "76",
     "77",
     "78"
};

#ifdef debug
static char *debug_operation(int op)
{
  switch (op)
  {
  case Action_Copying : return "Action_Copying";
  case Action_Moving : return "Action_Moving";
  case Action_Deleting : return "Action_Deleting";
  case Action_Setting_Access : return "Action_Setting_Access";
  case Action_Setting_Type : return "Action_Setting_Type";
  case Action_Counting : return "Action_Counting";
  case Action_CopyMoving : return "Action_CopyMoving";
  case Action_CopyLocal : return "Action_CopyLocal";
  case Action_Stamping : return "Action_Stamping";
  case Action_Finding : return "Action_Finding";
  }

  return "unknown";
}
#else
#define debug_operation(op) NULL
#endif

/* RML */
static void hide_faster_stuff( action_environment *env );

/*
     Establish a delayed switch on/off for the dbox.
     Delay is in centiseconds
*/
void switch_dbox_on_off( action_environment *env, int direction, int delay )
{
     env->time_to_boxchange = clock() + (delay * CLK_TCK)/100;
     env->boxchange_direction = direction;
}

/*
        a is wild b isn't
*/
static int caseless_wildcmp( const char *a, const char *b )
{
    int last_wildrover = -1;        /* first wild char after last wildcard */
    int last_realrover = -1;        /* first real char after wildcard in this test sequence */
    int wild_rover = 0;
    int real_rover = 0;
    int d;

    while ( (a[wild_rover] || b[real_rover]) )
    {
        switch( a[wild_rover] )
        {
        case FileChar_ManyAny:
            last_wildrover = ++wild_rover;  /* Carry on after * in wildcard string */
            last_realrover = real_rover;    /* try matching from here */
            break;

        case FileChar_Any:
            if ( !b[real_rover] )
                return a[wild_rover];

            wild_rover++;
            real_rover++;
            break;

        default:
            d = toupper( a[wild_rover] ) - toupper( b[real_rover] );
            if ( d )
            {
                if ( last_wildrover < 0 || !b[real_rover] )
                    return d;

                wild_rover = last_wildrover;    /* Restart after * in wilcard string */
                real_rover = ++last_realrover;  /* test one character on */
            }
            else
            {
                wild_rover++;
                real_rover++;
            }
            break;
        }
    }

    return 0;
}


/*
 * Prevent flicker when the filer action window is behind another window
*/
static void set_title(wimp_w handle, char *title) {
  wimp_winfo winfo;

  winfo.w = handle;
  if (_swix(Wimp_GetWindowInfo, _IN(1), ((unsigned int)&winfo) | 1) == NULL) {
    strcpy(winfo.info.title.indirecttext.buffer, title);
  }

  _swix(Wimp_ForceRedraw, _INR(0,2), handle, 0x4B534154, 3);
}


/*
   Set the status text displayed in the top field, or the title bar
*/
static void set_top_info_field_raw(action_environment *env, char *text)
{
    #ifdef USE_STATUS_IN_TITLE
    if (text != NULL)
    {
        char title[256];

        sprintf(title, "%s - %s", TitleString, text);
        set_title( env->window_handle, title );
    }
    else
    {
        set_title( env->window_handle, TitleString );
    }
    #else
    if (text == NULL) text = "";
    dbox_setfield( env->status_box, Top_Info_Field, text );
    #endif

    last_top_info_field = text;
}


/*
   Set the status text, from a token in the messages file
*/
static void set_top_info_field(action_environment *env, char *token)
{
    char *text = NULL;

    if (token != NULL && token[0] != '\0')
    {
        text = msgs_lookup( token );
    }

    set_top_info_field_raw(env, text);
}


void set_top_info_field_with_current_info(action_environment *env, char *token1, char *token2)
{

    if (env->current_info_token != NULL)
    {
        char buffer[Top_Info_Field_Length];

        strcpy(buffer, token1);
        strcat(buffer, env->current_info_token);
        sprintf(buffer, msgs_lookup(buffer), tolower(env->current_info[0]), &env->current_info[1]);

        set_top_info_field_raw(env, buffer);

    }
    else
    {
        set_top_info_field(env, token2);
    }

}


/*
    Set the content of the path display from the file name.
    We no longer split the path into two parts, as the display field has been made wider.
*/
static void set_bottom_info_field( action_environment *env, char *text )
{
    int l;

    IGNORE(env);

    if ( text == NULL )
    return;

    if ((l = strlen(text)) > Top_Info_Field_Length)
    {
        strncpy(PathString, text + l - Top_Info_Field_Length, Top_Info_Field_Length);
        PathString[Top_Info_Field_Length] = '\0';
    }
    else
    {
        strcpy(PathString, text);
    }

    UpdatePath = 1;

}


static void set_top_progress_field( action_environment *env, uint64_t value )
{
    env->top_progress = value;
    UpdateTop = 1;
}


/*
   Add a value to top progress. Instead of directly updating the icon, we set a flag
   that causes it to be updated on the next null poll.
*/
static void more_top_progress( action_environment *env, uint32_t change )
{
    env->top_progress += change;
    UpdateTop = 1;
}


/*
   Add a value to bottom progress. Instead of directly updating the icon, we set a flag
   that causes it to be updated on the next null poll.
*/
static void more_bottom_progress( action_environment *env, uint32_t change )
{
    env->bottom_progress += change;
    UpdateBottom = 1;
}


#ifdef USE_PROGRESS_BAR
/*
   Add a value to the progress indicator
*/
static void add_progress(action_environment *env, uint32_t progress, char *text)
{
    env->progress += progress;
    if (env->progress > INT32_MAX) env->progress = INT32_MAX;
    if (text != NULL)
    {
        debugact(( "%s: +%08x -> %08x\n", text, progress, env->progress ));
    }
}


/*
   Show the current progress indicator. Called on null poll events.
   The first time this is called, we calculate how much progress is represented by
   one OS unit. The Progress_Bar icon is then resized to be a proportion of the total
   size of the Progress_Bar_BBox icon.
*/
static void update_progress_bar(action_environment *env)
{
    static int ppos = 0, max = 0, last = 0;
    static wimp_icon i;
    int w, size;
    os_regset r;

    w = dbox_syshandle( env->status_box );

    if (ppos == 0)
    {
        wimp_icon b;
        if (wimp_get_icon_info(w, Progress_Bar, &i) != NULL) return;
        if (wimp_get_icon_info(w, Progress_Bar_BBox, &b) != NULL) return;
        max = b.box.x1 - b.box.x0;
        ppos = INT32_MAX / max; /* progress per os unit */
        i.box = b.box;
    }

    size = env->progress / ppos + 2;
    if (size > max) size = max;
    if (size >= last && size < last + 2)
        return; /* no change from last time */

    i.box.x1 = i.box.x0 + size;

    r.r[0] = w;
    r.r[1] = Progress_Bar;
    r.r[2] = i.box.x0;
    r.r[3] = i.box.y0;
    r.r[4] = i.box.x1;
    r.r[5] = i.box.y1;
    os_swix( Wimp_ResizeIcon, &r );

    wimp_set_icon_state(w, Progress_Bar, (wimp_iconflags)0, (wimp_iconflags)0);
    last = size;

    debugact(( "update_progress_bar: %08x -> %d / %d\n", env->progress, size, max ));
}
#endif


static void switch_box_to_error( action_environment *env, os_error *err )
{
    wimp_openstr o;
    template *tplt = template_find( MAIN_TEMPLATE_NAME );
    int xw;
    int yw;

    dbox_setfield( env->status_box, Error_Field, err->errmess );

    o.w = dbox_syshandle( env->status_box );
    o.x = -tplt->window.ex.x0;
    o.y = -tplt->window.ex.y1;
    o.box = tplt->window.ex;
    o.behind = -1;

    xw = ((bbc_modevar( -1, bbc_XWindLimit ) + 1) << bbc_modevar( -1, bbc_XEigFactor )) - bbc_vduvar( bbc_OrgX );
    yw = ((bbc_modevar( -1, bbc_YWindLimit ) + 1) << bbc_modevar( -1, bbc_YEigFactor )) - bbc_vduvar( bbc_OrgY );

    xw = xw/2 - (o.box.x1 + o.box.x0)/2;
    yw = yw/2 - (o.box.y1 + o.box.y0)/2;

    o.box.x0 += xw;
    o.box.y0 += yw;
    o.box.x1 += xw;
    o.box.y1 += yw;

    wimpt_noerr( wimp_open_wind( &o ));
}


static void switch_box_from_error( action_environment *env )
{
    wimp_wstate s;
    template *tplt = template_find( MAIN_TEMPLATE_NAME );
    int xw;
    int yw;

    wimpt_noerr( wimp_get_wind_state( dbox_syshandle( env->status_box ), &s ));

    xw = (s.o.box.x0 - s.o.x) - (tplt->window.box.x0 - tplt->window.scx);
    yw = (s.o.box.y1 - s.o.y) - (tplt->window.box.y1 - tplt->window.scy);

    s.o.x = tplt->window.scx;
    s.o.y = tplt->window.scy;
    s.o.box.x0 = tplt->window.box.x0 + xw;
    s.o.box.y0 = tplt->window.box.y0 + yw;
    s.o.box.x1 = tplt->window.box.x1 + xw;
    s.o.box.y1 = tplt->window.box.y1 + yw;

    wimpt_noerr( wimp_open_wind( &s.o ));
}


void switch_to_reading( action_environment *env )
{
    env->current_info = msgs_lookup( "32" );
    env->current_info_token = "32";

    set_bottom_info_field( env, next_file_to_be_read());

    set_top_progress_field( env, bytes_left_to_read());

    env->action = Check_Full_Reading;
}


/*
     Acknowledge a message
*/
static os_error *ack_message( wimp_eventstr *event )
{
     event->data.msg.hdr.your_ref = event->data.msg.hdr.my_ref;
     return wimp_sendmessage( wimp_EACK, &event->data.msg, event->data.msg.hdr.task );
}


static BOOL menus_greyed[ 3 ][ 5 ] =
{
        {       No,     No,     No,     No,     No },
        {       No,     No,     No,     No,     Yes },
        {       No,     Yes,    No,     Yes,    Yes }
};


typedef enum {none, name, access, type } destination_type;
typedef enum {mt_all, mt_notcopy, mt_information } menu_type;


static struct start_up_details_str
{
        int init_for_copy:1;
        destination_type dest;
        int return_dirs_last:1;
        int return_dirs_first:1;
        int recurse:1;
        int disable_flex:1;             /* stops flex being enabled later */
        int flex_now:1;                 /* is flex going now? */
        int partition_is_directory:1;   /* for listfiles - is a partition a dir or file */
        menu_type men;
}       start_up_details[ 10 ] =
{
        /*      copy    dest    last?   first?  recurse no flex flex    P==D?   menu                       action */
        {       Yes,    name,   No,     Yes,    Yes,    No,     Yes,    No,     mt_all          },      /* copying */
        {       No,     name,   No,     Yes,    No,     No,     No,     No,     mt_all          },      /* moving (rename) */
        {       No,     none,   Yes,    Yes,    Yes,    Yes,    No,     No,     mt_notcopy      },      /* deleting */
        {       No,     access, No,     Yes,    Yes,    Yes,    No,     Yes,    mt_notcopy      },      /* setting access */
        {       No,     type,   No,     Yes,    No,     Yes,    No,     No,     mt_notcopy      },      /* settype */
        {       No,     none,   No,     No,     Yes,    Yes,    No,     No,     mt_information  },      /* count */
        {       Yes,    name,   Yes,    Yes,    Yes,    No,     Yes,    No,     mt_all          },      /* copying/moving */
        {       Yes,    name,   No,     Yes,    Yes,    No,     Yes,    No,     mt_all          },      /* copy local */
        {       No,     none,   No,     Yes,    Yes,    Yes,    Yes,    Yes,    mt_notcopy      },      /* stamp */
        {       No,     name,   No,     Yes,    Yes,    Yes,    Yes,    Yes,    mt_information  }       /* find */
};

static void reflect_menu_flags( action_environment *env )
{
        menu_setflags( env->option_menu, 1, env->faster, menus_greyed[ start_up_details[ env->operation ].men ][ 0 ] );
        menu_setflags( env->option_menu, 2, env->confirm, menus_greyed[ start_up_details[ env->operation ].men ][ 1 ] );
        menu_setflags( env->option_menu, 3, env->verbose, menus_greyed[ start_up_details[ env->operation ].men ][ 2 ] );
        menu_setflags( env->option_menu, 4, env->force, menus_greyed[ start_up_details[ env->operation ].men ][ 3 ] );
        menu_setflags( env->option_menu, 5, env->looknewer, menus_greyed[ start_up_details[ env->operation ].men ][ 4 ] );
}

/*
     Operation has been specified, start doing it
*/
static os_error *start_operation( action_environment *env, actions_possible operation, int options, void *auxilliary_information )
{
    os_error *err;

    env->operation = operation;
    debugact(( "new operation: %s\n", debug_operation( env->operation ) ));

    dbox_setfield( env->status_box, Top_Progress_Line, msgs_lookup( icon_strings[ operation ][ Top_Progress_Line_Text ] ));
    dbox_setfield( env->status_box, Bottom_Progress_Line, msgs_lookup( icon_strings[ operation ][ Bottom_Progress_Line_Text ] ));

    #ifdef USE_STATUS_IN_TITLE
    strcpy(TitleString, msgs_lookup( icon_strings[ operation ][ Title_Text ] ));
    set_title( env->window_handle, TitleString );
    #else
    set_title( dbox_syshandle( env->status_box ), msgs_lookup( icon_strings[ operation ][ Title_Text ] ));
    #endif

    env->top_progress = 0;
    env->bottom_progress = 0;
    dbox_setlongnumeric( env->status_box, Top_Progress_Field, env->top_progress );
    dbox_setlongnumeric( env->status_box, Bottom_Progress_Field, env->bottom_progress );
    #ifdef USE_PROGRESS_BAR
    env->progress = 0;
    update_progress_bar(env);
    #endif

    env->faster    = No;
    env->faster_stuff_hidden = No;
    env->verbose   = (options & Option_FilerAction_Verbose) != 0;
    env->confirm   = (options & Option_FilerAction_Confirm) != 0;
    env->force     = (options & Option_FilerAction_Force) != 0;

    /* RML */
    if ((options & Option_FilerAction_ConfirmDeletes) && (operation==Action_Deleting)) env->confirm = Yes;

    if (options & Option_FilerAction_Faster)
    {
        env->faster = Yes;
        doings_time = CLK_TCK;          /* 1 second */
        hide_faster_stuff( env );
    }

    env->looknewer = (options & Option_FilerAction_Newer) != 0;

    env->disc_full_already = No;
    env->auto_skip_cvs = (getenv("Filer_Action$Skip") != NULL) ? Yes : No;

    switch_buttons( env, &abort_pause_buttons );
    set_faster_state( env );

    if ( env->verbose )
    {
        switch_dbox_on_off( env, 1, Display_Delay );
    }

    env->current_info_token = icon_strings[operation][Top_Info_Field_Text];
    if ( env->current_info_token )
    {
        env->current_info = msgs_lookup( env->current_info_token );
    }
    else
    {
        env->current_info = "";
    }

    env->action = Next_File;

    if ( start_up_details[ env->operation ].init_for_copy )
    {
        err = init_for_copying();
        if ( err )
            return err;
    }

    switch( start_up_details[ env->operation ].dest )
    {
    case none:
        break;

    case name:
        /*
                Store the destination directory somewhere useful
        */
        env->destination_name = overflowing_malloc( strlen( auxilliary_information ) + 1 );
        if ( env->destination_name == NULL )
                return error( mb_malloc_failed );
        strcpy( env->destination_name, auxilliary_information );
        break;

    case access:
        env->new_access = *(int *)auxilliary_information;
        break;

    case type:
        env->new_type = *(int *)auxilliary_information;
        debugact(( "new type is %d\n", env->new_type ));
        break;

    default:
        break;
    }

    return_directories_last( env->test_search, start_up_details[ env->operation ].return_dirs_last );
    return_directories_first( env->test_search, start_up_details[ env->operation ].return_dirs_first );
    recurse_search_context( env->test_search, start_up_details[ env->operation ].recurse );
    treat_partitions_as_directories( env->test_search, start_up_details[ env->operation ].partition_is_directory );
    env->disable_flex = start_up_details[ env->operation ].disable_flex;
    env->flex_memory = start_up_details[ env->operation ].flex_now;

    switch( env->operation )
    {

    case Action_Counting:

        err = selection_summary( env->test_search, &env->selection_summary );

        if ( err )
             return err;

            /* drop through into... */
    case Action_Finding:
        #ifndef CONFIRM_MEANS_CONFIRM_ALL
        env->confirm = No;
        #endif

            /* drop through into... */
    case Action_Stamping:
    case Action_Setting_Type:
    case Action_Copying:
    case Action_CopyLocal:
    case Action_Moving:
        break;

    case Action_Deleting:
        err = selection_summary( env->test_search, &env->selection_summary );
        if ( err )
                return err;

        env->locked_not_deleted = 0;
        break;

    case Action_Setting_Access:
        {
            os_regset r;
            char *first_nodename;

            recurse_search_context( env->test_search, (options & Option_FilerAction_Recurse) != 0 );

            env->directory_access_setting_mask = 0xffffffff;

            err = next_nodename( env->test_search, &first_nodename );

            if ( err || first_nodename == NULL )
                break;

            r.r[0] = FSControl_LookupFS;
            r.r[1] = (int) first_nodename;
            r.r[2] = 0;             /* truncate on . or : etc */

            err = os_swix( OS_FSControl, &r );

            overflowing_free( first_nodename );

            /*
                NetFS doesn't like OwnerWrite being set on directories.
            */
            if ( !err && r.r[1] == fsnumber_net )
                env->directory_access_setting_mask &= ~write_attribute;

            break;
        }

    default:
            break;
    }

    reflect_menu_flags( env );

    return NULL;
}


static void go_verbose( action_environment *env )
{
    wimp_wstate state;

    if ( wimp_get_wind_state( dbox_syshandle( env->status_box ), &state ) )
        return;

    dbox_showstatic( env->status_box );

    state.o.behind = -1;

    if ( wimp_open_wind( &state.o ) )
        return;

    env->verbose = Yes;
    env->boxchange_direction = 0;
}


/* JRF: Toggle the faster operation of the window.
        This is accessed from the Buttons.c source.
 */

void toggle_faster( action_environment *env )
{
    env->faster = !env->faster;
    copy_go_faster( env->faster );
    if ( env->faster )
    {
        doings_time = CLK_TCK;          /* 1 second */
        hide_faster_stuff( env );
    }
    else
    {
        doings_time = (10*CLK_TCK)/100; /* 1/10 second */
        show_faster_stuff( env );
    }
    menu_setflags( env->option_menu, 1, env->faster, menus_greyed[ start_up_details[ env->operation ].men ][ 0 ] );
}


static void go_terse( action_environment *env )
{
        env->verbose = No;
        env->boxchange_direction = 0;

        if ( (event_getmask() & wimp_EMNULL) == 0 )
        {
                dbox_hide( env->status_box );
        }
}

/*
     Control the action in progress
*/
static void control_action( action_environment *env, wimp_eventstr *event )
{
    switch ( event->data.msg.data.words[0] )
    {
    case 0:
        /*
           Acknowledge the message
        */
        ack_message( event );
        break;

    case 1:   /* show window and bring it to the front */
        go_verbose( env );
        break;

    case 2:   /* Turn verbose off - hide the window */
        go_terse( env );
        break;

    default:
        /*
           Do nothing implicitely
        */
        break;
    }
}


/*
     Message processor
*/
BOOL message_event_handler( wimp_eventstr *event, void *environment )
{
    action_environment *env = environment;
    BOOL processed = No;

    switch( event->e )
    {
    case wimp_ESEND:
    case wimp_ESENDWANTACK:

        processed = Yes;

        switch( event->data.msg.hdr.action )
        {
        case wimp_MPREQUIT:
            {
               /* amg 9th August 1994. Only return a C/S/F12 */
               /* if the flag word tells us that it was a shutdown */
               /* or there's no flag word at all */

                int size_of_prequit = event->data.msg.hdr.size;
                int flags_of_prequit = event->data.msg.data.words[0];
                wimp_t sender = event->data.msg.hdr.task;
                char query_message[ 150 ];

                wimpt_noerr( ack_message( event ));

                /*
                   Construct a context sensitive message for the query.
                */
                sprintf( query_message, msgs_lookup( "81" ), msgs_lookup( icon_strings[ env->operation ][ Help_Message_Operation_Fillin ] ) );

                switch( dboxquery( query_message ) )
                {
                case dboxquery_YES:
                    debugact(( "Discard selected\n" ));
                    if (!(size_of_prequit > sizeof(wimp_msghdr) && flags_of_prequit & 1))
                    {
                      wimp_get_caret_pos( &event->data.key.c );
                      event->data.key.chcode = akbd_Ctl | akbd_Sh | akbd_Fn12;
                      wimp_sendmessage( wimp_EKEY, (wimp_msgstr *)&event->data, sender );
                      debugact(( "sent message to &%x\n",sender ));
                    }
                    abort_operation( env );
                    break;

                case dboxquery_NO:
                case dboxquery_CANCEL:
                    debugact(( "Cancel selected\n" ));
                    break;
                }
            }
            break;

        case wimp_MSETSLOT:
            debugact(( "Slot(%d,%d) - T=%d\n", event->data.msg.data.words[0],event->data.msg.data.words[1], wimpt_task() ));
            if ( !env->disable_flex )
            {
                if ( event->data.msg.data.words[1] == wimpt_task() )
                {
                    if ( env->flex_memory &&
                        event->data.msg.data.words[0] >= 0 )
                    {
                        action_slot( event->data.msg.data.words[0] );
                    }

                    wimpt_noerr( ack_message( event ));
                }
                else
                {
                    processed = No;
                }
            }
            break;

        case wimp_MHELPREQUEST:
            event->data.msg.hdr.your_ref = event->data.msg.hdr.my_ref;
            event->data.msg.hdr.action = wimp_MHELPREPLY;
            event->data.msg.hdr.size = 256; /* enough for all messages */

            switch( event->data.msg.data.helprequest.m.i )
            {
            case Abort_Button:
            case No_Skip_Button:
            case Yes_Retry_Button:
            case Misc_Button:
            case Skip_Button:
                sprintf( event->data.msg.data.helpreply.text, msgs_lookup( HELP_MESSAGE_CONTROL ),
                    msgs_lookup( icon_strings[ env->operation ][ Help_Message_Operation_Fillin ] ),
                    msgs_lookup( env->button_actions.button_helps[ event->data.msg.data.helprequest.m.i - Abort_Button ] ));
                break;

            default:
                sprintf( event->data.msg.data.helpreply.text, msgs_lookup( HELP_MESSAGE_CONTROL_NOBUTTON ),
                        msgs_lookup( icon_strings[ env->operation ][ Help_Message_Operation_Fillin ] ));
                 break;
            }

            wimpt_noerr( wimp_sendmessage( wimp_ESEND, &event->data.msg, event->data.msg.hdr.task ));
            break;

        case wimp_MFilerSelectionDirectory:
            clear_selection( env->test_search );
            wimpt_noerr( set_directory( env->test_search, event->data.msg.data.chars ));
            env->source_directory_name_length = strlen( event->data.msg.data.chars );
            debugact(("MFilerSelectionDirectory: %s\n", event->data.msg.data.chars));
            break;

        #ifdef USE_LOAD_OPERATIONS
        case wimp_MDATALOAD:
                if ((env->operation != Action_Copying) &&
                    (env->operation != Action_Moving) &&
                    (env->operation != Action_Deleting) &&
                    (env->operation != Action_Setting_Access) &&
                    (env->operation != Action_Setting_Type) &&
                    (env->operation != Action_Counting) &&
                    (env->operation != Action_Stamping) )
                {
                  /* Generate some kind of error for the user to see */
                }
                else
                {
                  extern char *get_directory(search_handle);
                  char *ourdir=get_directory(env->test_search);
                  char *theirfile=event->data.msg.data.dataload.name;
                  int ourdirlen=strlen(ourdir);
                  processed=Yes;
                  if ( (strncmp(ourdir,theirfile,ourdirlen)==0) &&
                       (theirfile[ourdirlen]=='.') &&
                       (strchr(&theirfile[ourdirlen+1],'.')==NULL) )
                  { /* It's something we can use - yay! */
                    char *file= &theirfile[ourdirlen+1];
                    wimpt_noerr( add_selection( env->test_search, file, strlen(file) ) );
                  }
                }
                break;
        #endif

        case wimp_MFilerAddSelection:
            {
                char *pos;
                int wordlen;
                char *wordpos;

                /*
                   Wander over the string of selections peeling
                   them off, one at a time
                */
                for ( pos = &event->data.msg.data.chars[0];
                      *pos != '\0';
                      pos++ )
                {
                    /*
                         If we have a candidate word
                    */
                    if ( *pos != SPACE )
                    {
                        wordpos = strchr( pos, SPACE );

                        if ( wordpos == NULL )
                        {
                            wordlen = strlen( pos );
                        }
                        else
                        {
                            wordlen = wordpos - pos;
                        }

                        wimpt_noerr( add_selection( env->test_search, pos, wordlen ));


                        /*
                                pos is on the last character of the word
                        */
                        pos += wordlen - 1;
                    }
                }
            }
            break;

        case wimp_MFilerAction:
            {
                os_error *err;

                actions_possible action;
                int options;
                void *auxilliary_information;

                action = (actions_possible)event->data.msg.data.words[ 0 ];
                options = event->data.msg.data.words[ 1 ];
                auxilliary_information = &event->data.msg.data.words[ 2 ];

                err = start_operation( env, action, options, auxilliary_information );
                if (err)
                    werr(TRUE, err->errmess);
            }
            break;

        case wimp_MFilerControlAction:
            control_action( env, event );
            break;

        default:
            processed = No;
            break;
        }
        break;
    }

    return processed;
}


/*
   Because the display of fields is more efficient, we don't hide everything in faster mode
*/
static void hide_faster_stuff( action_environment *env )
{
    if ( env->faster && !env->faster_stuff_hidden )
    {
        if ( !show_when_faster[ env->operation ][ 0 ] )
            dbox_setfield( env->status_box, Top_Progress_Field, "-" );
        if ( !show_when_faster[ env->operation ][ 1 ] )
            dbox_setfield( env->status_box, Bottom_Progress_Field, "-" );

        env->faster_stuff_hidden = Yes;
        set_faster_state ( env );
    }
}


void show_faster_stuff( action_environment *env )
{
    if ( env->faster_stuff_hidden )
    {
        if ( !show_when_faster[ env->operation ][ 0 ] )
            dbox_setlongnumeric( env->status_box, Top_Progress_Field, env->top_progress );
        if ( !show_when_faster[ env->operation ][ 1 ] )
        {
            dbox_setlongnumeric( env->status_box, Bottom_Progress_Field, env->bottom_progress );
        }

        env->faster_stuff_hidden = No;

        set_faster_state( env );
    }
}


void option_menu_handler( action_environment *env, char *hit )
{
    switch( hit[0] )
    {
    case 1: /* faster */
        toggle_faster( env ); /* JRF: Now a function to aid the */
                              /* button */
        break;

    case 2: /* confirm */
        env->confirm = !env->confirm;
        break;

    case 3: /* verbose */
        if ( env->verbose )
            go_terse( env );
        else
            go_verbose( env );
        break;

    case 4: /* force */
        env->force = !env->force;
        break;

    case 5: /* newer */
        env->looknewer = !env->looknewer;
        break;

    default:
        break;
    }

    reflect_menu_flags( env );
}


void switch_to_writing( action_environment *env )
{
     env->current_info = msgs_lookup( "82" );
     env->current_info_token = "82";

     set_bottom_info_field( env, next_file_to_be_written());

     set_top_progress_field( env, bytes_left_to_write());

     env->action = Check_Empty_Writing;
}

/*
     Create the destination file name from the source
*/
static os_error *create_destination_localfile( action_environment *env, char *source, char **destination )
{
    char *sourcegunge;
    char *sourceleaf = source + env->source_directory_name_length + 1;
    char *destleaf;
    char *temp;

    /*
        This takes
        source = <source dir><source leaf><gunge>
        and
        dest = <dest dir><dest leaf>
        making
        destn = <destdir><dest leaf><gunge>

        or
        dest = <dest leaf>
        making
        destn = <source dir><dest leaf><gunge>
    */

    /*
        sourcegunge points to the stuff past the source leaf (which is
        one of the selected items).
    */
    if ( strchr( sourceleaf, '.' ) == 0 )
    {
        sourcegunge = source + strlen( source );
    }
    else
    {
        sourcegunge = strchr( sourceleaf, '.' );
    }

    /*
            destleaf points to the leaf part of the destination
    */
    destleaf = strrchr( env->destination_name, '.' );
    temp = strrchr( env->destination_name, ':' );

    if ( temp > destleaf )
        destleaf = temp;

    if ( destleaf == NULL )
    {
        destleaf = env->destination_name;
    }
    else
    {
        destleaf++;     /* move beyond the separator (. or :) */
    }

    if ( destleaf > env->destination_name )
    {
        /*
            Destination directory is present
        */
        *destination = overflowing_malloc( strlen( env->destination_name ) + strlen( sourcegunge ) + 1 );

        if ( *destination == NULL )
            return error( mb_malloc_failed );

        sprintf( *destination, "%s%s", env->destination_name, sourcegunge );
    }
    else
    {
        *destination = overflowing_malloc( env->source_directory_name_length + 1 + strlen( env->destination_name ) + strlen( sourcegunge ) + 1 );

        if ( *destination == NULL )
            return error( mb_malloc_failed );

        strncpy( *destination, source, env->source_directory_name_length + 1 );

        sprintf( *destination + env->source_directory_name_length + 1, "%s%s", env->destination_name, sourcegunge );
    }

    return NULL;
}

/*
     Create the destination file name from the source
*/
static os_error *create_destination_filename( action_environment *env, char *source, char **destination )
{
     *destination = overflowing_malloc( strlen( source ) - env->source_directory_name_length
                                              + strlen( env->destination_name ) + 1 );

     if ( !*destination )
          return error( mb_malloc_failed );

     sprintf( *destination, "%s%s",
                           env->destination_name,
                           &source[ env->source_directory_name_length ] );

     return NULL;
}

/*
     Add next file to read list
*/
static os_error *test_add_to_read_list( action_environment *env, BOOL *should_be_added )
{
    char *destination;
    char *source;
    os_filestr fileplace;
    os_error *err;
    int source_reload;
    int destination_reload;

    wimpt_noerr( next_nodename( env->test_search, &source ));

    if ( env->operation != Action_CopyLocal )
    {
        wimpt_noerr( create_destination_filename( env, source, &destination ));
    }
    else
    {
        wimpt_noerr( create_destination_localfile( env, source, &destination ));
    }

    source_reload = reload_of_next_node( env->test_search );

    /*
            Only look newer if source has a datestamp
    */
    if ( env->looknewer &&
         ( source_reload & DateStamped_Mask ) == DateStamped_Mask &&
         objecttype_of_next_node( env->test_search ) != object_directory  )
    {
        /*
                Get the destination's information
        */
        fileplace.action = OSFile_ReadInfo;
        fileplace.name = destination;

        err = os_file( &fileplace );

        /*
            If an error happened which wasn't 'not found' then return
            with that error. 'not found' means datestamp checking need
            not happen.
        */
        if ( err )
        {
            if ( ( err->errnum & FileError_Mask ) != ErrorNumber_NotFound )
            {
                overflowing_free( source );
                overflowing_free( destination );

                return err;
            }
        }
        else
        {
            /*
                    If destination is datestamped after source, then don't
                    add source to read list
            */
            destination_reload = fileplace.loadaddr;
            if ( ( destination_reload & DateStamped_Mask ) == DateStamped_Mask )
            {
                if ( (destination_reload & DateStamp_HighByte) >
                          (source_reload & DateStamp_HighByte) ||
                     ( (destination_reload & DateStamp_HighByte) ==
                            (source_reload & DateStamp_HighByte) &&
                       (unsigned int)fileplace.execaddr >=
                       (unsigned int)execute_of_next_node( env->test_search ) )
                   )
                {
                    overflowing_free( source );
                    overflowing_free( destination );

                    *should_be_added = No;

                    return NULL;
                }
            }
        }
    }

    overflowing_free( destination );
    overflowing_free( source );

    *should_be_added = Yes;

    return NULL;
}

/*
        This actually adds the next file to the read list.
*/
static void add_to_read_list( action_environment *env, BOOL *i_am_full )
{
    char *destination;
    char *source;

    wimpt_noerr( next_nodename( env->test_search, &source ));

    if ( env->operation != Action_CopyLocal )
    {
        wimpt_noerr( create_destination_filename( env, source, &destination ));
    }
    else
    {
        wimpt_noerr( create_destination_localfile( env, source, &destination ));
    }

    wimpt_noerr( add_file_to_chain( destination, source,
        size_of_next_node( env->test_search ),
        reload_of_next_node( env->test_search ),
        execute_of_next_node( env->test_search ),
        attributes_of_next_node( env->test_search ),
        objecttype_of_next_node( env->test_search ),
        env->force,
        i_am_full
        #ifdef USE_PROGRESS_BAR
        , progress_of_next_node( env->test_search )
        , chain_ref_ptr_of_next_node(env->test_search)
        #endif
    ));

    overflowing_free( destination );
    overflowing_free( source );

    switch_to_reading( env );
}


/*
     Get the access of a file
*/
static os_error *get_access_to_file( char *filename, int *access )
{
     os_error *err;
     os_filestr fileplace;

     fileplace.action = OSFile_ReadInfo;
     fileplace.name = filename;

     err = os_file( &fileplace );

     *access = fileplace.end;
     return err;
}


/*
     Set the access to any file
*/
static os_error *set_access_to_file( char *filename, int access )
{
     os_filestr fileplace;

     fileplace.action = OSFile_WriteAttr;
     fileplace.name = filename;
     fileplace.end = access;

     return os_file( &fileplace );
}


/*
     Attempt to delete a node
 */
static os_error *delete_node(char *name)
{
     os_filestr fileplace;
     fileplace.action = OSFile_Delete;
     fileplace.name = name;

     return os_file( &fileplace );
}


/*
     Set the access of next node
*/
static os_error *set_access( action_environment *env, int access )
{
     char *filename;
     os_error *err;

     err = next_nodename( env->test_search, &filename );

     if ( err )
          return err;

     err = set_access_to_file( filename, access );

     overflowing_free( filename );

     return err;
}


/*
     Stamp any file
*/
static os_error *stamp_file( char *filename )
{
     os_filestr fileplace;

     fileplace.action = OSFile_SetStamp;
     fileplace.name = filename;

     return os_file( &fileplace );
}


/*
     Stamp next node
*/
static os_error *stamp( action_environment *env )
{
     char *filename;
     os_error *err;

     err = next_nodename( env->test_search, &filename );

     if ( err )
          return err;

     err = stamp_file( filename );

     overflowing_free( filename );

     return err;
}


/*
        Do a rename
*/
static os_error *riscos_rename( action_environment *env )
{
    os_error *err;
    os_regset r;
    char *source;
    char *destination;
    BOOL should_be_added;

    test_add_to_read_list(env, &should_be_added);
    wimpt_noerr( next_nodename( env->test_search, &source ));
    if (!should_be_added) return 0;

    wimpt_noerr( create_destination_filename( env, source, &destination ));
    debugact(( "riscos_rename: src = %s, dest = %s\n",source,destination ));
    r.r[0] = FSControl_Rename;
    r.r[1] = (int)source;
    r.r[2] = (int)destination;

    err = os_swix( OS_FSControl, &r );

    overflowing_free( source );
    overflowing_free( destination );

    return err;
}


static os_error *Do_Next_File( action_environment *env )
{
    os_error *err;
    char *filename;
    BOOL inhibit_confirm = No;
    BOOL is_cvs_directory = No;
    uint32_t p = 0;

    err = step_to_next_node( env->test_search, &p);

    #ifdef USE_PROGRESS_BAR
    add_progress(env, p, "Do_Next_File");
    #endif

    if ( err )
        return err;

    if ( another_node( env->test_search ))
    {
        err = next_nodename( env->test_search, &filename );

        if ( err )
            return err;

        set_bottom_info_field( env, filename );

        if ( env->auto_skip_cvs )
        {
          size_t length = strlen( filename );
          if (length > 4 && strcmp(filename + length - 4, ".CVS") == 0)
          {
              is_cvs_directory = Yes;
          }
          else if (length > 8 && strcmp(filename + length - 8, "./cvstag") == 0)
          {
              is_cvs_directory = Yes;
          }
        }

        overflowing_free( filename );

        switch( env->operation )
        {
        case Action_Copying:
        case Action_CopyLocal:
            env->action = Test_Add_To_Read_List;
            inhibit_confirm = Yes;
            if ( is_cvs_directory == Yes)
            {
                skip_list_file(env->test_search);
                env->action = Next_File;
            }
            break;

        case Action_Moving:
            env->action = Attempt_1st_Rename;
            break;

        case Action_CopyMoving:
            if ( objecttype_of_next_node( env->test_search ) == object_directory &&
                 directory_is_after_contents( env->test_search ) )
            {
                env->action = Add_To_Read_List;
            }
            else
            {
                env->action = Test_Add_To_Read_List;
            }
            inhibit_confirm = Yes;
            break;

        case Action_Deleting:
            if ( objecttype_of_next_node( env->test_search ) == object_directory )
            {
                if ( directory_is_after_contents( env->test_search ) )
                {
                    env->action = Attempt_Delete;
                    inhibit_confirm = Yes;
                }
                else
                {
                    env->action = Next_File;
                }
            }
            else
            {
                env->action = Attempt_Delete;
            }
            break;

        case Action_Setting_Access:
            env->action = Attempt_Set_Access;
            break;

        case Action_Setting_Type:
            env->action = Attempt_Set_Type;
            break;

        case Action_Counting:
            more_top_progress( env, 1 );
            more_bottom_progress( env, size_of_next_node( env->test_search ) );

            #ifdef USE_PROGRESS_BAR
            add_progress(env, progress_of_next_node(env->test_search), "Action_Counting");
            #endif
            break;

        case Action_Stamping:
            env->action = Attempt_Stamp;
            break;

        case Action_Finding:
            if ( !caseless_wildcmp( env->destination_name, name_of_next_node( env->test_search )) )
            {
                set_top_info_field( env, "84" );

                if ( (objecttype_of_next_node( env->test_search ) == object_directory &&
                    name_of_next_node( env->test_search )[0] != '!') ||
                    objecttype_of_next_node( env->test_search ) == (object_directory | object_file) )
                {
                    switch_buttons( env, &open_buttons );
                }
                else
                {
                    switch_buttons( env, &run_view_buttons );
                }
            }

            /*
                Keep the user informed of what's happening
            */
            if ( objecttype_of_next_node( env->test_search ) != object_file )
            {
                more_top_progress( env, 1 );
            }
            else
            {
                more_bottom_progress( env, 1 );
            }

            #ifdef USE_PROGRESS_BAR
            add_progress(env, progress_of_next_node(env->test_search), "Action_Finding");
            #endif

            break;

        default:
            break;
        }

        /*
            Don't confirm until we are sure this file is going to
            be added to the read list.
        */
        if ( env->confirm &&
             !inhibit_confirm )
        {
            switch_buttons( env, &confirm_buttons );
            set_top_info_field( env, action_prompt[ env->operation ] );
        }
    }
    else
    {
        /*
            No more files
        */
        if ( env->operation == Action_Copying ||
             env->operation == Action_CopyMoving ||
             env->operation == Action_CopyLocal )
        {
            switch_to_writing( env );
        }
        else if ( env->operation == Action_Counting )
        {
            /*
                Change buttons, display dbox, clear
                unwanted fields etc
            */
            switch_buttons( env, &ok_button );

            set_top_info_field( env, "85" );
            set_bottom_info_field( env, env->selection_summary );
        }
        else if ( ( env->operation == Action_Deleting ||
                env->operation == Action_CopyMoving ) &&
              env->locked_not_deleted > 0 )
        {
             char top_field[ 50 ];

             switch_buttons( env, &ok_button );

             sprintf( top_field, msgs_lookup( "86" ), env->locked_not_deleted );

             set_top_info_field( env, "85" );
             set_bottom_info_field( env, top_field);

        }
        else
        {
            /*
                Finished doing everything else, so
                kill ourselves off
            */
            abort_operation( env );
        }
    }

    return NULL;
}


static os_error *Do_Test_Add_To_Read_List( action_environment *env )
{
    os_error *err;
    BOOL should_be_added;

    err = test_add_to_read_list( env, &should_be_added );

    if ( err )
        return err;

    if ( should_be_added )
    {
        env->action = Add_To_Read_List;

        /*
            Confirm if necessary.
        */
        if ( env->confirm )
        {
            switch_buttons( env, &confirm_buttons );
            set_top_info_field( env, action_prompt[ env->operation ] );
        }
    }
    else
    {
        env->action = Next_File;
    }

    return NULL;
}

static os_error *Do_Add_To_Read_List( action_environment *env )
{
    BOOL i_am_full;

    add_to_read_list( env, &i_am_full );

    if ( i_am_full )
        switch_to_writing( env );

    return NULL;
}

static os_error *Do_Check_Full_Reading( action_environment *env )
{
    os_error *err;
    BOOL i_am_full;
    BOOL need_another_file;
    BOOL that_finished_a_file;
    uint32_t p = 0;

    err = read_a_block( &i_am_full, &need_another_file, &that_finished_a_file, &p );

    if ( err )
        return err;

    #ifdef USE_PROGRESS_BAR
    add_progress(env, p, "Block read");
    #endif

    if ( i_am_full )
    {
        switch_to_writing( env );
    }
    else if ( need_another_file )
    {
        if ( another_node( env->test_search ))
        {
            env->action = Next_File;
        }
        else if ( next_file_to_be_written() == NULL )
        {
            abort_operation( env );
        }
        else
        {
            switch_to_writing( env );
        }
    }
    else
    {
        set_top_progress_field( env, bytes_left_to_read());

        if ( that_finished_a_file )
        {
            set_bottom_info_field( env, next_file_to_be_read());
        }
    }

    return NULL;
}


static os_error *Do_Check_Empty_Writing( action_environment *env )
{
    os_error *err;
    BOOL i_am_empty;
    BOOL that_finished_a_file;
    uint32_t p = 0;

    err = write_a_block( &i_am_empty, &that_finished_a_file, &p );

    if ( err )
        return err;

    #ifdef USE_PROGRESS_BAR
    add_progress(env, p, "Block write");
    #endif

    if ( i_am_empty )
    {
        switch_to_reading( env );
    }
    else if ( that_finished_a_file )
    {

        if ( env->operation != Action_CopyMoving )
        {
            if ( finished_obj_was_file )
            {
                more_bottom_progress( env, 1 );
            }

            set_bottom_info_field( env, next_file_to_be_written());
            set_top_progress_field( env, bytes_left_to_write());
        }
        else
        {
            /*
                We are copyMoving, hence:
                Attempt_Delete (will work for dirs on way up tree, but fail on way down)
            */
            env->action = Attempt_Delete;
        }
    }
    else
    {
        set_top_progress_field( env, bytes_left_to_write());
    }

    return NULL;
}


static os_error *Do_Attempt_Rename( action_environment *env, int which_one )
{
    os_error *err;

    err = riscos_rename( env );

    if ( err )
    {
        switch ( err->errnum & FileError_Mask )
        {
        case ErrorNumber_Locked:
            if ( which_one == 1 )
            {
                env->action = Attempt_Unlock;
                err = NULL;
            }
            break;

        case ErrorNumber_NotSameDisc:
        case ErrorNumber_BadRename:
        case ErrorNumber_AlreadyExists:
            if ( which_one == 1 )
                env->action = Convert_To_CopyMove;
            else
                env->action = Convert_To_CopyMove_After_Unlock;
            err = NULL;
            break;
        }
    }
    else
    {
        if ( which_one == 1 )
        {
            more_bottom_progress( env, 1 );
            env->action = Next_File;
        }
        else
        {
            env->action = Attempt_Relock;
        }
        #ifdef USE_PROGRESS_BAR
        add_progress(env, progress_of_next_node(env->test_search), "Do_Attempt_Rename");
        #endif
    }

    return err;
}


static os_error *Do_Attempt_Unlock( action_environment *env )
{
    os_error *err;
    char *filename;

    err = next_nodename( env->test_search, &filename );

    if ( err )
        return err;

    /*
        Ignore error as don't care if it fails
    */
    (void)set_access_to_file( filename, attributes_of_next_node( env->test_search ) & ~locked_attribute );

    overflowing_free( filename );

    env->action = Attempt_2nd_Rename;

    return NULL;
}


/*
    Relock destination of rename after unlocking source
*/
static os_error *Do_Attempt_Relock( action_environment *env )
{
    os_error *err;
    char *source;
    char *destination;

    err = next_nodename( env->test_search, &source );

    if ( err )
        return err;

    err = create_destination_filename( env, source, &destination );

    overflowing_free( source );

    if ( err )
        return err;

    /*
        Ignore error as don't care if it fails
    */
    (void)set_access_to_file( destination, attributes_of_next_node( env->test_search ) );

    overflowing_free( destination );

    more_bottom_progress( env, 1 );

    env->action = Next_File;

    return NULL;
}


static os_error *Do_Convert_To_CopyMove( action_environment *env, BOOL after_unlock )
{
    os_error *err;
    char *filename;

    /*
        Relock the node if necessary, don't object if this
        fails!
    */
    if ( after_unlock )
    {
        /*
            return the attributes to their old values (but ignore errors back)
        */

        err = next_nodename( env->test_search, &filename );

        if ( err )
            return err;

        (void)set_access_to_file( filename, attributes_of_next_node( env->test_search ));

        overflowing_free( filename );
    }

    init_for_copying();
    env->flex_memory = Yes;
    env->operation = Action_CopyMoving;
    env->action = Add_To_Read_List;
    return_directories_first( env->test_search, Yes );
    return_directories_last( env->test_search, Yes );
    recurse_search_context( env->test_search, Yes );

    /*
       Reset the progress bar as the operation is restarted as a copymove
    */
    #ifdef USE_PROGRESS_BAR
    debugact(( "changed operation: %s\n", debug_operation( env->operation ) ));
    listfiles_convert_to_copymove( env->test_search );
    env->progress = 0;
    #endif

    err = selection_summary( env->test_search, &env->selection_summary );

    env->locked_not_deleted = 0;

    return err;
}


static os_error *Do_Attempt_Delete( action_environment *env )
{
    os_error *err;
    char *filename;
    BOOL inhibit_progress = No;
    int prev_access;
    uint32_t p = 0;

    if ( env->operation != Action_CopyMoving )
    {
        wimpt_noerr( next_nodename( env->test_search, &filename ));
        #ifdef USE_PROGRESS_BAR
        p = progress_of_next_node(env->test_search);
        #endif
    }
    else
    {
        filename = finished_obj_source_name;
    }

    debugact(( "Do_Attempt_Delete: filename = %s p = %08x\n", filename, p ));

    /*
        JRS 29/1/92 1st attempt to delete the node without touching the access.
        In most cases this will work without further ado
     */
    err = delete_node( filename );

    /*
        If forcing delete, set no read/write access and
        unlock it. If this fails, then the delete will
        never work!
    */
    prev_access = -1; /* special value to test for */
    if ( (err != NULL) &&
         (env->force ||
         env->operation == Action_CopyMoving) )
    {
        err = get_access_to_file(filename, &prev_access);
        if ( err ) prev_access = -1;

        err = set_access_to_file(filename, prev_access & ~locked_attribute);

        if ( err && (err->errnum & FileError_Mask) != ErrorNumber_NotFound )
            return err;
        /*
            Retry deletion
         */
        err = delete_node( filename );
    }


    /*
        If it didn't work, cancel the error if its an ignorable
        error for this operation
    */
    if ( err )
    {
        /* JRS 28/1/92 test if access should be restored */
        if ( prev_access != -1 )
        {
          /*
            Put the access back to where it was
           */
            set_access_to_file( filename, prev_access);
        }

        switch( err->errnum & FileError_Mask )
        {
        case ErrorNumber_Locked:
            /*
                If forcing delete failed due to locked file then something's
                happening which the user should know about, so don't drop
                through the 'cancel this error' code.
            */
            if ( env->force )
                break;

            /*
                Otherwise, just note that one file hasn't been deleted
                due to a locked file and drop through to the 'it didn't
                get deleted, and it was there, and we don't mind' case.
            */
            env->locked_not_deleted++;

        case ErrorNumber_DirectoryNotEmpty:
            /*
                Reach here if the file didn't get deleted and it was
                there and we don't mind. If these conditions are satisfied
                then we don't want to count this object as deleted.
            */
            inhibit_progress = Yes;
            err = NULL;
            break;

        case ErrorNumber_NotFound:
            /*
                This
                entry point is used for the 'its already gone' situation,
                in which case we fib to the user that it was the user which
                caused the deletion (but it wasn't really; who cares -
                the file's gone anyway).
            */
            err = NULL;
            deleted_next_node( env->test_search, filename );
            break;

        default:
            break;
        }
    }
    else
    {
        /*
            Tell the file listing stuff we've deleted the node
        */
        deleted_next_node( env->test_search, filename );
    }

    if ( env->operation != Action_CopyMoving )
        overflowing_free( filename );

    if ( err )
        return err;

    /*
        Only update progress bar if the file was actually deleted
    */
    #ifdef USE_PROGRESS_BAR
    add_progress(env, p, "Do_Attempt_Delete");
    #endif

    if ( env->operation != Action_CopyMoving )
    {
        if ( !inhibit_progress )
        {
            /*
                Keep the user informed of what's happening
            */
            if ( objecttype_of_next_node( env->test_search ) != object_file )
            {
                more_top_progress( env, 1 );
            }
            else
            {
                more_bottom_progress( env, 1 );
            }
        }

        env->action = Next_File;
    }
    else
    {
        /*
            Update progress if it's a file we've just finished moving
        */
        if ( finished_obj_was_file )
        {
            more_bottom_progress( env, 1 );
        }

        set_bottom_info_field( env, next_file_to_be_written());

        env->action = Check_Empty_Writing;
    }

    return NULL;
}


static os_error *Do_Attempt_Set_Access( action_environment *env )
{
    os_error *err;

    if ( objecttype_of_next_node( env->test_search ) != object_file )
    {
        err =
            set_access(
                env,
                ((attributes_of_next_node( env->test_search) & (env->new_access >> 16) & 0xffff) |
                (env->new_access & ~(env->new_access >> 16) & 0xffff)) &
                env->directory_access_setting_mask );

        if ( err )
            return err;

        more_top_progress( env, 1 );
    }
    else
    {
        err =
            set_access(
                env,
                (attributes_of_next_node( env->test_search) & (env->new_access >> 16) & 0xffff) |
                (env->new_access & ~(env->new_access >> 16) & 0xffff) );

        if ( err )
            return err;

        more_bottom_progress( env, 1 );
    }

    #ifdef USE_PROGRESS_BAR
    add_progress(env, progress_of_next_node(env->test_search), "Do_Attempt_Set_Access");
    #endif

    env->action = Next_File;

    return NULL;
}


static os_error *Do_Attempt_Set_Type( action_environment *env )
{
    os_error *err;
    char *filename;
    os_filestr fileplace;

    if ( objecttype_of_next_node( env->test_search ) == object_directory )
    {
        more_top_progress( env, 1 );
    }
    else
    {

        err = next_nodename( env->test_search, &filename );

        if ( err )
            return err;

        fileplace.action = OSFile_SetType;
        fileplace.name = filename;
        fileplace.loadaddr = env->new_type;

        err = os_file( &fileplace );

        overflowing_free( filename );

        if ( err )
            return err;

        more_bottom_progress( env, 1 );

    }

    #ifdef USE_PROGRESS_BAR
    add_progress(env, progress_of_next_node(env->test_search), "Do_Attempt_Set_Type");
    #endif

    env->action = Next_File;

    return NULL;
}


static os_error *Do_Attempt_Stamp( action_environment *env )
{
    os_error *err;

    err = stamp( env );

    #ifdef USE_PROGRESS_BAR
    add_progress(env, progress_of_next_node(env->test_search), "Do_Attempt_Stamp");
    #endif

    /*
        Filter out F. S. Error 46 as this is the error generated by file
        servers which can't stamp directories
    */
    if ( err && (err->errnum & FileError_Mask) != ErrorNumber_FSError46 )
        return err;

    err = NULL;

    if ( objecttype_of_next_node( env->test_search ) == object_file )
        more_bottom_progress( env, 1 );
    else
        more_top_progress( env, 1 );

    env->action = Next_File;

    return NULL;
}


/*
     --- Activity processor for null events ---
*/
static void null_event_activity( action_environment *env )
{
    os_error *err = NULL;
    clock_t   end_time;

    end_time = clock() + doings_time;
    hide_faster_stuff( env );

    do
    {
        if ( env->action == Abort_Operation )
        {
            abort_operation( env );
        }

        if ( last_top_info_field != env->current_info )
        {
            if ( env->in_error )
            {
                #ifdef USE_RED_ERROR
                wimp_set_icon_state( dbox_syshandle( env->status_box ), Top_Info_Field, 0xc000000, 0 );
                wimp_set_icon_state( dbox_syshandle( env->status_box ), Bottom_Info_Field, 0xc000000, 0 );
                #endif

                env->in_error = No;
                switch_box_from_error( env );
            }

            set_top_info_field_raw( env, env->current_info );
        }

        switch( env->action )
        {
        case Next_File:
            err = Do_Next_File( env );
            break;

        case Test_Add_To_Read_List:
            err = Do_Test_Add_To_Read_List( env );
            break;

        case Add_To_Read_List:
            err = Do_Add_To_Read_List( env );
            break;

        case Check_Full_Reading:
            err = Do_Check_Full_Reading( env );
            break;

        case Check_Empty_Writing:
            err = Do_Check_Empty_Writing( env );
            break;

        case Attempt_1st_Rename:
            err = Do_Attempt_Rename( env, 1 );
            break;

        case Attempt_Unlock:
            err = Do_Attempt_Unlock( env );
            break;

        case Attempt_2nd_Rename:
            err = Do_Attempt_Rename( env, 2 );
            break;

        case Attempt_Relock:
            err = Do_Attempt_Relock( env );
            break;

        case Convert_To_CopyMove:
            err = Do_Convert_To_CopyMove( env, No );
            break;

        case Convert_To_CopyMove_After_Unlock:
            err = Do_Convert_To_CopyMove( env, Yes );
            break;

        case Attempt_Delete:
            err = Do_Attempt_Delete( env );
            break;

        case Attempt_Set_Access:
            err = Do_Attempt_Set_Access( env );
            break;

        case Attempt_Set_Type:
            err = Do_Attempt_Set_Type( env );
            break;

        case Attempt_Stamp:
            err = Do_Attempt_Stamp( env );
            break;

        default:
            break;
        }

      /*
          While there is not error and
              we havn't run out of time and
              we are accepting NULL events
      */
    } while ( !err &&
        clock() < end_time &&
        ( event_getmask() & wimp_EMNULL ) == 0 );


    #ifdef USE_PROGRESS_BAR
    update_progress_bar(env);
    #endif

    /*
       Update the various fields in the dialogue box, if the flags are set
    */

    if (UpdatePath)
    {
      UpdatePath = 0;
      dbox_setfield( env->status_box, Bottom_Info_Path, PathString );
    }

    if (UpdateTop)
    {
      UpdateTop = 0;
      if ( !env->faster || show_when_faster[ env->operation ][ 0 ] )
      {
        dbox_setlongnumeric( env->status_box, Top_Progress_Field, env->top_progress );
      }
    }

    if (UpdateBottom)
    {
      UpdateBottom = 0;
      if ( !env->faster || show_when_faster[ env->operation ][ 1 ] )
      {
        dbox_setlongnumeric( env->status_box, Bottom_Progress_Field, env->bottom_progress);
      }
    }


    if ( err )
    {
        if ( err->errnum == 0 )
        {
            /*
                Internally generated error - this is fatal
            */
            wimpt_noerr( err );
        }
        else
        {
            /*
                Externally generated error - give the user a chance
                to correct it.
            */

            if ( ( env->operation == Action_Copying ||
                   env->operation == Action_CopyMoving ||
                   env->operation == Action_CopyLocal ) &&
                 ( env->action == Check_Full_Reading ||
                   env->action == Check_Empty_Writing ) )
            {
                /*
                        Read/Write during a copy or copy move
                */
                switch_buttons( env, &restart_button );
            }
            else
            {
                /*
                        Attempted activity normal for operation, but failed
                */
                switch_buttons( env, &norestart_button );
            }

            /*
                Construct error indicator
            */
            if ( ( err->errnum & FileError_Mask ) == ErrorNumber_DiscFull )
            {
                set_top_info_field_with_current_info(env, "87a", "87");

                if ( env->disc_full_already )
                {
                        /*
                                Cancel the report of a second or subsequent disc full error
                        */
                        err = NULL;
                }
                else
                {
                        env->disc_full_already = Yes;
                        switch_box_to_error( env, err );
                }
            }
            else
            {
                set_top_info_field_with_current_info(env, "88a", "88");

                switch_box_to_error( env, err );
            }

            /*
                 Set the info field text to red (assuming it was black)
            */
            env->in_error = Yes;
            #ifdef USE_RED_ERROR
            wimp_set_icon_state( dbox_syshandle( env->status_box ), Top_Info_Field, 0xc000000, 0 );
            wimp_set_icon_state( dbox_syshandle( env->status_box ), Bottom_Info_Field, 0xc000000, 0 );
            #endif
        }
    }
}


/*
     --- NULL event handler for status box. ---
*/
BOOL idle_event_handler(dbox db, void *event, void *handle)
{
    BOOL handled = No;

    IGNORE(db);

    switch( ((wimp_eventstr *)event)->e )
    {
    case wimp_ENULL:
        {
            action_environment *env = handle;

            /*
                Process delayed box showing and hiding
            */
            if ( env->boxchange_direction != 0 &&
                 clock() >= env->time_to_boxchange )
            {
                if ( env->boxchange_direction > 0 )
                {
                        dbox_showstatic( env->status_box );
                }
                else
                {
                        dbox_hide( env->status_box );
                }

                env->boxchange_direction = 0;
            }

            null_event_activity( env );
        }
        handled = Yes;
        break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
        handled = message_event_handler( event, handle );
        break;

    default:
        break;
    }

    return handled;
}


/* Fixed stack size !!!
 * 3.5k is the max required.
 * 2k is a bodge safety factor.
 */
int __root_stack_size = 3*1024+512+2*1024;
extern int disable_stack_extension;

/*
     This is the entry point for the Filer_Action module.
*/
int main( int argc, char *argv[] )
{
    disable_stack_extension = 1;

    wimpt_install_signal_handlers();

    wimpt_noerr( initialise( &env, argc, argv ));

    while (TRUE)
    {
        event_process();
    }

    return 0;
}

@


4.13
log
@Fix null pointer dereference
Detail:
  c/actionwind - start_operation() wasn't checking if there's any info field text for the current operation, leading to a null pointer dereference when it attempts to look up the right message token via msgs_lookup()
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.55. Tagged as 'FilerAct-0_55'
@
text
@d358 15
d381 1
a381 1
    
d383 1
a383 1
        win_settitle( env->window_handle, title );
d387 1
a387 1
        win_settitle( env->window_handle, TitleString );
d393 1
a393 1
  
d404 1
a404 1
  
d409 1
a409 1
  
d443 1
a443 1
  
d445 1
a445 1
  
d448 1
a448 1
  
d458 1
a458 1
  
d520 1
a520 1
  
d522 1
a522 1
  
d532 1
a532 1
  
d537 1
a537 1
  
d539 1
a539 1
  
d547 1
a547 1
  
d550 1
a550 1
  
d694 1
a694 1
    win_settitle( env->window_handle, TitleString );
d696 1
a696 1
    win_settitle( dbox_syshandle( env->status_box ), msgs_lookup( icon_strings[ operation ][ Title_Text ] ));
d1055 1
@


4.12
log
@Fix to work with files > 2G.
A good rake over the code to change filesizes to be uint32_t not ints.
Change makefile to use StdTools.
Shuffle icon clipping in the templates to allow for maximal numbers by moving the text a bit to the right, still fits even in system font.
A couple more ints swapped for BOOLs.
The memmanage code is largely unchanged and makes extensive use of signed numbers, partly because the wimpslot setting API does. This will all fall over in a big mess if the wimpslot ever gets >2G, but then the API would need changing for that to happen anyway.
Function count_objects_in_dir swapped to use os_gbpb.
Structure search_nest_level gains a 'counted' flag rather than signalling counting is needed by setting the filesize to -1.
Should now be good for up to 4 billion files each of 4 billion bytes.

Version 0.54. Tagged as 'FilerAct-0_54'
@
text
@a721 1
    env->current_info = msgs_lookup( icon_strings[ operation ][ Top_Info_Field_Text ] );
d723 8
@


4.11
log
@Swap magic constants for defines from headers.
OS_FSControl, OS_File, OS_GBPB, OS_Args, OS_Find now use HighFSI.h.
Indentation made more consistent.
Variety of DEBUG macros changed to allow them to be enabled and disabled on a per-file basis.
Put USE_RED_ERROR box switch into options.h (undefined though).
Functionally equivalent to 0.52, but lots of diffs.

Version 0.53. Tagged as 'FilerAct-0_53'
@
text
@a166 1
#define QUERY_TEMPLATE_NAME     "query"
d241 1
a241 1
static int show_when_faster[ Number_Of_Actions ][2] =
d300 1
a300 1
/*static*/ void switch_dbox_on_off( action_environment *env, int direction, int delay )
d460 1
a460 1
static void more_top_progress( action_environment *env, int change )
d471 1
a471 1
static void more_bottom_progress( action_environment *env, unsigned int change )
d482 1
a482 1
static void add_progress(action_environment *env, unsigned int progress, char *text)
d544 1
a544 1
    template *tplt = template_find( Main_Window );
d574 1
a574 1
    template *tplt = template_find( Main_Window );
d617 1
a617 1
static int menus_greyed[ 3 ][ 5 ] =
d1444 1
a1444 1
        , (void **) chain_ref_ptr_of_next_node(env->test_search)
d1593 1
a1593 1
    unsigned int p = 0;
d1847 1
a1847 1
    unsigned int p = 0;
d1896 1
a1896 1
    unsigned int p = 0;
d2106 1
a2106 3
    #ifdef USE_PROGRESS_BAR
    int prog;
    #endif
d2112 1
a2112 1
        prog = progress_of_next_node(env->test_search);
a2117 3
        #ifdef USE_PROGRESS_BAR
        prog = 0;
        #endif
d2120 1
a2120 1
    debugact(( "Do_Attempt_Delete: filename = %s  prog = %08x\n", filename, prog ));
d2229 1
a2229 1
    add_progress(env, prog, "Do_Attempt_Delete");
@


4.10
log
@More BOOLs and things changed to C99 types.
Basically the same as version 0.51 otherwise.

Version 0.52. Tagged as 'FilerAct-0_52'
@
text
@d103 3
a105 1
#define debugact
d115 2
a116 1
/* AMcC 22-Jul-94 include swis.h rather than arthur.h !! */
d120 1
d162 1
a162 3
#define FileChar_Any '#'

#define FileSystemNumber_NetFS                  5
d165 1
a165 1
#define HELP_MESSAGE_CONTROL "2"
d195 2
a198 4
/* AMcC: 22-Jul-94 - defined in swis.h
 * #define OS_ExitAndDie 0x50
 */

a204 8
#define Attribute_OwnerRead             0x00000001
#define Attribute_OwnerWrite            0x00000002
#define Attribute_Locked                0x00000008
#define Attribute_PublicRead            0x00000010
#define Attribute_PublicWrite           0x00000020

#define SPACE ' '

d290 2
a293 1

d363 18
a380 20

  #ifdef USE_STATUS_IN_TITLE
  if (text != NULL)
  {
    char title[256];

    sprintf(title, "%s - %s", TitleString, text);
    win_settitle( env->window_handle, title );
  }
  else
  {
    win_settitle( env->window_handle, TitleString );
  }

  #else
  if (text == NULL) text = "";
  dbox_setfield( env->status_box, Top_Info_Field, text );
  #endif

  last_top_info_field = text;
d389 8
a396 8
  char *text = NULL;

  if (token != NULL && token[0] != '\0')
  {
    text = msgs_lookup( token );
  }

  set_top_info_field_raw(env, text);
d428 18
a445 18
  int l;

  IGNORE(env);

  if ( text == NULL )
  return;

  if ((l = strlen(text)) > Top_Info_Field_Length)
  {
    strncpy(PathString, text + l - Top_Info_Field_Length, Top_Info_Field_Length);
    PathString[Top_Info_Field_Length] = '\0';
  }
  else
  {
    strcpy(PathString, text);
  }

  UpdatePath = 1;
d485 6
a490 6
  env->progress += progress;
  if (env->progress > PROGRESS_MAX) env->progress = PROGRESS_MAX;
  if (text != NULL)
  {
    DEBUG(("%s: +%08x -> %08x\n", text, progress, env->progress));
  }
d502 36
a537 28
  static int ppos = 0, max = 0, last = 0;
  static wimp_icon i;
  int w, size;

  w = dbox_syshandle( env->status_box );

  if (ppos == 0)
  {
    wimp_icon b;
    if (wimp_get_icon_info(w, Progress_Bar, &i) != NULL) return;
    if (wimp_get_icon_info(w, Progress_Bar_BBox, &b) != NULL) return;
    max = b.box.x1 - b.box.x0;
    ppos = PROGRESS_MAX / max; /* progress per os unit */
    i.box = b.box;
  }

  size = env->progress / ppos + 2;
  if (size > max) size = max;
  if (size >= last && size < last + 2)
    return; /* no change from last time */

  i.box.x1 = i.box.x0 + size;

  _swix(Wimp_ResizeIcon, _INR(0,5), w, Progress_Bar, i.box.x0, i.box.y0, i.box.x1, i.box.y1);
  wimp_set_icon_state(w, Progress_Bar, (wimp_iconflags)0, (wimp_iconflags)0);
  last = size;

  DEBUG(("update_progress_bar: %08x -> %d / %d\n", env->progress, size, max));
d673 1
a673 1
    DEBUG(("new operation: %s\n", debug_operation(env->operation)));
d756 1
a756 3
        #ifdef debugact
        DEBUG(( "new type is %d\n", env->new_type ));
        #endif
d792 1
a792 1
            break;
d814 1
a814 1
                    break;
d816 1
a816 1
            r.r[0] = 13;            /* lookup FS */
d827 2
a828 2
            if ( !err && r.r[1] == FileSystemNumber_NetFS )
                    env->directory_access_setting_mask &= ~Attribute_OwnerWrite;
d964 1
a964 3
                    #ifdef debugact
                    DEBUG(("Discard selected\n"));
                    #endif
d968 1
a968 1
                      event->data.key.chcode = 0x1fc; /* ctrl/shft/f12 */
d970 1
a970 3
                      #ifdef debugact
                      DEBUG(("sent message to &%x\n",sender));
                      #endif
d977 1
a977 3
                    #ifdef debugact
                    DEBUG(("Cancel selected\n"));
                    #endif
d984 1
a984 3
            #ifdef debugact
            DEBUG(( "Slot(%d,%d) - T=%d\n", event->data.msg.data.words[0],event->data.msg.data.words[1], wimpt_task() ));
            #endif
d1192 1
a1192 1
                go_terse( env );
d1194 1
a1194 1
                go_verbose( env );
d1355 1
a1355 1
         objecttype_of_next_node( env->test_search ) != ObjectType_Directory  )
d1360 1
a1360 1
        fileplace.action = 5; /* read catalogue information */
d1464 1
a1464 1
     fileplace.action = 5; /* get file attributes */
d1481 1
a1481 1
     fileplace.action = 4; /* set file attributes */
d1495 1
a1495 1
     fileplace.action = 6; /* delete object */
d1530 1
a1530 1
     fileplace.action = 9; /* stamp file */
d1574 2
a1575 4
    #ifdef debugact
    DEBUG(("riscos_rename: src = %s, dest = %s\n",source,destination));
    #endif
    r.r[0] = 25; /* rename */
d1647 1
a1647 1
            if ( objecttype_of_next_node( env->test_search ) == ObjectType_Directory &&
d1660 1
a1660 1
            if ( objecttype_of_next_node( env->test_search ) == ObjectType_Directory )
d1704 1
a1704 1
                if ( (objecttype_of_next_node( env->test_search ) == ObjectType_Directory &&
d1706 1
a1706 1
                    objecttype_of_next_node( env->test_search ) == (ObjectType_Directory | ObjectType_File) )
d1719 1
a1719 1
            if ( objecttype_of_next_node( env->test_search ) != ObjectType_File )
d2005 1
a2005 1
    (void)set_access_to_file( filename, attributes_of_next_node( env->test_search ) & ~Attribute_Locked );
d2069 1
a2069 1
               return err;
d2088 2
a2089 2
    DEBUG(("changed operation: %s\n", debug_operation(env->operation)));
    listfiles_convert_to_copymove(env->test_search);
d2126 1
a2126 3
    #ifdef debugact
    DEBUG(("Do_Attempt_Delete: filename = %s  prog = %08x\n", filename, prog));
    #endif
d2147 1
a2147 1
        err = set_access_to_file(filename, prev_access & ~Attribute_Locked);
d2245 1
a2245 1
            if ( objecttype_of_next_node( env->test_search ) != ObjectType_File )
d2280 1
a2280 1
    if ( objecttype_of_next_node( env->test_search ) != ObjectType_File )
d2324 1
a2324 1
    if ( objecttype_of_next_node( env->test_search ) == ObjectType_Directory )
d2336 1
a2336 1
        fileplace.action = 0x12; /* set file type */
d2380 1
a2380 1
    if ( objecttype_of_next_node( env->test_search ) == ObjectType_File )
d2413 1
a2413 1
                #ifdef REDERROR
d2600 1
a2600 1
            #ifdef REDERROR
d2616 1
a2616 1
    db = db; /* keep the compiler quiet */
@


4.9
log
@Fix display of bytes-to-go when there are > 2G left.
Was doing a widening cast of a signed number to 64 bits, so showed 16 trillion bytes remaining.
Fix templates to not say "stuff" by default in the name, as this was left on screen if an error occured before processing began.
Things that read from clock() now use clock_t.
Uncurled some "} else {" to match all the other files.
Deleted the USE_LONG_LONG switch, it's been needed ever since harddiscs got bigger than 4G anyway.
Anything assigned 'Yes' or 'No' changed to type BOOL.
Variable 'source_of_finished_file' was signalling that a directory had been copied by setting the length to a -ve number. This has been refactored to use a BOOL instead, so files can have top bit set sizes.
Fix bug in stack grab in count_objects_in_dir(), was grabbing an array of 2048 pointers (=8k) not 2048 bytes.
Functions bytes_left_to_read() and bytes_left_to_write() reprototyped to return uint32_t not signed numbers.
Still falls over copying files > 2G, but at least it gets the display right!

Version 0.51. Tagged as 'FilerAct-0_51'
@
text
@d1339 1
a1339 1
static os_error *test_add_to_read_list( action_environment *env, int *should_be_added )
d1430 1
a1430 1
static void add_to_read_list( action_environment *env, int *i_am_full )
d1578 1
a1578 1
    int should_be_added;
d1815 1
a1815 1
    int should_be_added;
d1845 1
a1845 1
    int i_am_full;
d1858 3
a1860 3
    int i_am_full;
    int need_another_file;
    int that_finished_a_file;
d1908 2
a1909 2
    int i_am_empty;
    int that_finished_a_file;
d2064 1
a2064 1
static os_error *Do_Convert_To_CopyMove( action_environment *env, int after_unlock )
@


4.8
log
@Didn't compile with PROGRESS_BAR turned off.
Rationalised all the switches a bit.
Not tagged.
@
text
@a150 7
/* AMcC: 22-Jul-94 - Shouldn't be defined here
 * #define FilerAction_SendSelectedDirectory       0x88000
 * #define FilerAction_SendSelectedFile            0x88001
 * #define FilerAction_SendStartOperation          0x88002
 */


d152 1
a152 1
  static char TitleString[64];
a189 1
#define Yes 1
d191 2
a212 2
#define max(a,b) ((a)>(b)?(a):(b))

d218 1
a218 1
static int doings_time = (10*CLK_TCK)/100;
d280 4
a283 2
static char *debug_operation(int op) {
  switch (op) {
d298 1
a298 1
#endif	// debug
d368 2
a369 1
static void set_top_info_field_raw(action_environment *env, char *text) {
d372 2
a373 1
  if (text != NULL) {
d378 3
a380 1
  } else {
d396 2
a397 1
static void set_top_info_field(action_environment *env, char *token) {
d400 2
a401 1
  if (token != NULL && token[0] != '\0') {
d409 2
a410 1
void set_top_info_field_with_current_info(action_environment *env, char *token1, char *token2) {
d412 2
a413 1
    if (env->current_info_token != NULL) {
d422 3
a424 2
    } else {

d444 2
a445 1
  if ((l = strlen(text)) > Top_Info_Field_Length) {
d448 3
a450 1
  } else {
d459 1
a459 5
#ifdef USE_LONG_LONG
static void set_top_progress_field( action_environment *env, uintmax_t value )
#else
static void set_top_progress_field( action_environment *env, unsigned value )
#endif
d492 2
a493 1
static void add_progress(action_environment *env, unsigned int progress, char *text) {
d496 2
a497 1
  if (text != NULL) {
d509 2
a510 1
static void update_progress_bar(action_environment *env) {
d517 2
a518 1
  if (ppos == 0) {
d523 1
a523 1
    ppos = PROGRESS_MAX / max;		// progress per os unit
d529 2
a530 1
  if (size >= last && size < last + 2) return;	// no change from last time
d1605 2
a1606 2
    int inhibit_confirm = No;
    int is_cvs_directory = No;
d1627 2
a1628 1
        if ( env->auto_skip_cvs ) {
a1793 3
//             set_top_info_field_raw( env, top_field );
//             set_bottom_info_field( env, env->selection_summary );

d1930 1
a1930 1
            if ( size_of_finished_file >= 0 )
d2118 1
a2118 1
    int inhibit_progress = No;
d2133 1
a2133 1
        filename = source_of_finished_file;
d2181 2
a2182 1
        { /*
d2277 1
a2277 1
        if ( size_of_finished_file >= 0 )
d2412 1
a2412 1
    int end_time;
d2524 2
a2525 1
    if (UpdatePath) {
d2530 2
a2531 1
    if (UpdateTop) {
d2533 2
a2534 1
      if ( !env->faster || show_when_faster[ env->operation ][ 0 ] ) {
d2539 2
a2540 1
    if (UpdateBottom) {
d2542 2
a2543 1
      if ( !env->faster || show_when_faster[ env->operation ][ 1 ] ) {
@


4.7
log
@Fixed progress bar bug in Filer Action.
Progress bar was wrong during a CopyMove operation that required more
memory than the available wimp slot.

Version 0.50. Tagged as 'FilerAct-0_50'
@
text
@d18 1
a18 1
This code compilers into a relocatable module which controls the Filer's
d158 1
a158 1
#ifdef STATUS_IN_TITLE
d376 1
a376 1
  #ifdef STATUS_IN_TITLE
d486 1
a486 1
#ifdef PROGRESS_BAR
d672 1
a672 1
    #ifdef STATUS_IN_TITLE
d683 1
a683 1
    #ifdef PROGRESS_BAR
d1447 1
a1447 1
        #ifdef PROGRESS_BAR
d1604 1
a1604 1
    #ifdef PROGRESS_BAR
d1695 1
a1695 1
            #ifdef PROGRESS_BAR
d1733 1
a1733 1
            #ifdef PROGRESS_BAR
d1863 1
a1863 1
    #ifdef PROGRESS_BAR
d1912 1
a1912 1
    #ifdef PROGRESS_BAR
d1991 1
a1991 1
        #ifdef PROGRESS_BAR
d2095 1
a2095 1
    #ifdef PROGRESS_BAR
d2115 1
a2115 1
    #ifdef PROGRESS_BAR
d2122 1
d2124 1
d2129 1
d2131 1
d2243 1
a2243 1
    #ifdef PROGRESS_BAR
d2317 1
a2317 1
    #ifdef PROGRESS_BAR
d2360 1
a2360 1
    #ifdef PROGRESS_BAR
d2376 1
a2376 1
    #ifdef PROGRESS_BAR
d2510 1
a2510 1
    #ifdef PROGRESS_BAR
@


4.6
log
@Redesigned window to show more of path.
Added progress bar.
Performance improvements, especially in 'slower' mode.
Fixed 'count summary' bug.
Fixed various compiler warnings.

Version 0.49. Tagged as 'FilerAct-0_49'
@
text
@d287 19
d667 1
a667 1
    DEBUG(("new operation: %d\n", env->operation));
d2096 1
a2096 1
    DEBUG(("changed operation: %d\n", env->operation));
d2115 3
d2122 1
d2127 1
d2131 1
a2131 1
    DEBUG(("Do_Attempt_Delete: filename = %s\n",filename));
d2240 1
a2240 1
    add_progress(env, progress_of_next_node(env->test_search), "Do_Attempt_Delete");
@


4.5
log
@Added functionality from RISC OS 4.02 (Faster button, 64-bit display, number
separators). This implementation does not use the Netscape libraries, and
looks up the number separation scheme from the current territory.

Now copies directory datestamps, as per the command-line *Copy.

Version 0.46. Tagged as 'FilerAct-0_46'
@
text
@d158 5
d225 1
a225 1
char *last_top_info_field;
d227 1
d239 12
a250 11
        /*     title     top progress bottom progress        top info   help               action */
        {       "29",           "30",           "31",           "32",   "33"    },      /* copying */
        {       "34",           "30",           "35",           "36",   "37"    },      /* moving (renaming) */
        {       "38",           "39",           "40",           "41",   "42"    },      /* deleting */
        {       "43",           "44",           "45",           "46",   "47"    },      /* setting access */
        {       "48",           "49",           "50",           "51",   "52"    },      /* settype */
        {       "53",           "54",           "55",           "56",   "57"    },      /* count */
        {       "34",           "30",           "58",           "32",   "37"    },      /* copy/moving */
        {       "29",           "30",           "31",           "32",   "33"    },      /* copy local */
        {       "59",           "60",           "61",           "62",   "63"    },      /* stamp */
        {       "64",           "65",           "66",           "67",   "68"    }       /* find */
d253 5
d266 1
a266 1
        {               No,             No      },      /* count */
d270 1
a270 1
        {               Yes,            No      }       /* find */
d287 1
d306 22
a327 5
        int last_wildrover = -1;        /* first wild char after last wildcard */
        int last_realrover = -1;        /* first real char after wildcard in this test sequence */
        int wild_rover = 0;
        int real_rover = 0;
        int d;
d329 6
a334 23
        while ( (a[wild_rover] || b[real_rover]) )
        {
                switch( a[wild_rover] )
                {
                case FileChar_ManyAny:
                        last_wildrover = ++wild_rover;  /* Carry on after * in wildcard string */
                        last_realrover = real_rover;    /* try matching from here */
                        break;

                case FileChar_Any:
                        if ( !b[real_rover] )
                                return a[wild_rover];

                        wild_rover++;
                        real_rover++;
                        break;

                default:
                        d = toupper( a[wild_rover] ) - toupper( b[real_rover] );
                        if ( d )
                        {
                                if ( last_wildrover < 0 || !b[real_rover] )
                                        return d;
d336 9
a344 10
                                wild_rover = last_wildrover;    /* Restart after * in wilcard string */
                                real_rover = ++last_realrover;  /* test one character on */
                        }
                        else
                        {
                                wild_rover++;
                                real_rover++;
                        }
                        break;
                }
d346 59
a405 1
        return 0;
a407 2
static char newpath[ Info_Field_Length + 1 ];
static char newleaf[ 10 + 1 ];
d410 2
a411 1
        Set the content of the bottom info field from the file name
d415 1
a415 1
        char *leaf;
d417 1
a417 2
        if ( text == NULL )
                return;
d419 2
a420 2
        /* Split text into path and leafname */
        leaf = strrchr( text, '.' );
d422 6
a427 20
        if ( leaf != NULL )
        {
                leaf += 1;

                if ( leaf - text > Info_Field_Length )
                {
                        strncpy( newpath, leaf - Info_Field_Length, Info_Field_Length );
                        newpath[ Info_Field_Length ] = '\0';
                }
                else
                {
                        strncpy( newpath, text, leaf - text );
                        newpath[ leaf - text ] = '\0';
                }
        }
        else
        {
                *newpath = '\0';
                leaf = text;
        }
d429 1
a429 2
        strncpy( newleaf, leaf, 10 );
        newleaf[ 10 ] = '\0';
a430 5
        if ( !env->faster )
        {
                dbox_setfield( env->status_box, Bottom_Info_Path, newpath );
                dbox_setfield( env->status_box, Bottom_Info_Leaf, newleaf );
        }
d433 1
d440 73
a512 3
        env->top_progress = value;
        if ( !env->faster || show_when_faster[ env->operation ][ 0 ] )
                dbox_setlongnumeric( env->status_box, Top_Progress_Field, value );
d514 2
d519 23
a541 23
        wimp_openstr o;
        template *tplt = template_find( Main_Window );
        int xw;
        int yw;

        dbox_setfield( env->status_box, Error_Field, err->errmess );

        o.w = dbox_syshandle( env->status_box );
        o.x = -tplt->window.ex.x0;
        o.y = -tplt->window.ex.y1;
        o.box = tplt->window.ex;
        o.behind = -1;

        xw = ((bbc_modevar( -1, bbc_XWindLimit ) + 1) << bbc_modevar( -1, bbc_XEigFactor )) - bbc_vduvar( bbc_OrgX );
        yw = ((bbc_modevar( -1, bbc_YWindLimit ) + 1) << bbc_modevar( -1, bbc_YEigFactor )) - bbc_vduvar( bbc_OrgY );

        xw = xw/2 - (o.box.x1 + o.box.x0)/2;
        yw = yw/2 - (o.box.y1 + o.box.y0)/2;

        o.box.x0 += xw;
        o.box.y0 += yw;
        o.box.x1 += xw;
        o.box.y1 += yw;
d543 1
a543 1
        wimpt_noerr( wimp_open_wind( &o ));
d546 1
d549 16
a564 16
        wimp_wstate s;
        template *tplt = template_find( Main_Window );
        int xw;
        int yw;

        wimpt_noerr( wimp_get_wind_state( dbox_syshandle( env->status_box ), &s ));

        xw = (s.o.box.x0 - s.o.x) - (tplt->window.box.x0 - tplt->window.scx);
        yw = (s.o.box.y1 - s.o.y) - (tplt->window.box.y1 - tplt->window.scy);

        s.o.x = tplt->window.scx;
        s.o.y = tplt->window.scy;
        s.o.box.x0 = tplt->window.box.x0 + xw;
        s.o.box.y0 = tplt->window.box.y0 + yw;
        s.o.box.x1 = tplt->window.box.x1 + xw;
        s.o.box.y1 = tplt->window.box.y1 + yw;
d566 1
a566 1
        wimpt_noerr( wimp_open_wind( &s.o ));
d569 1
d572 2
a573 2
     env->current_info = msgs_lookup( "32" );
     env->current_info_token = "32";
d575 1
a575 1
     set_bottom_info_field( env, next_file_to_be_read());
d577 1
a577 1
     set_top_progress_field( env, bytes_left_to_read());
d579 1
a579 1
     env->action = Check_Full_Reading;
d582 1
d592 1
d600 1
d604 1
d645 1
a645 1
        os_error *err;
d647 2
a648 4
        env->operation = operation;
        dbox_setfield( env->status_box, Top_Progress_Line, msgs_lookup( icon_strings[ operation ][ Top_Progress_Line_Text ] ));
        dbox_setfield( env->status_box, Bottom_Progress_Line, msgs_lookup( icon_strings[ operation ][ Bottom_Progress_Line_Text ] ));
        win_settitle( dbox_syshandle( env->status_box ), msgs_lookup( icon_strings[ operation ][ Title_Text ] ));
d650 34
a683 4
        env->top_progress = 0;
        env->bottom_progress = 0;
        dbox_setlongnumeric( env->status_box, Top_Progress_Field, env->top_progress );
        dbox_setlongnumeric( env->status_box, Bottom_Progress_Field, env->bottom_progress );
d685 1
a685 5
        env->faster    = No;
        env->faster_stuff_hidden = No;
        env->verbose   = (options & Option_FilerAction_Verbose) != 0;
        env->confirm   = (options & Option_FilerAction_Confirm) != 0;
        env->force     = (options & Option_FilerAction_Force) != 0;
d687 2
a688 2
        /* RML */
        if ((options & Option_FilerAction_ConfirmDeletes) && (operation==Action_Deleting)) env->confirm = Yes;
d690 2
a691 6
        if (options & Option_FilerAction_Faster)
        {
            env->faster = Yes;
            doings_time = CLK_TCK;          /* 1 second */
            hide_faster_stuff( env );
        }
d693 4
a696 1
        env->looknewer = (options & Option_FilerAction_Newer) != 0;
d698 2
a699 2
        env->disc_full_already = No;
        env->auto_skip_cvs = (getenv("Filer_Action$Skip") != NULL) ? Yes : No;
d701 1
a701 2
        switch_buttons( env, &abort_pause_buttons );
        set_faster_state( env );
d703 6
a708 4
        if ( env->verbose )
        {
                switch_dbox_on_off( env, 1, Display_Delay );
        }
d710 4
a713 2
        env->current_info = msgs_lookup( icon_strings[ operation ][ Top_Info_Field_Text ] );
        env->current_info_token = icon_strings[operation][Top_Info_Field_Text];
d715 31
a745 1
        env->action = Next_File;
d747 2
a748 6
        if ( start_up_details[ env->operation ].init_for_copy )
        {
                err = init_for_copying();
                if ( err )
                        return err;
        }
d750 1
a750 4
        switch( start_up_details[ env->operation ].dest )
        {
        case none:
                break;
d752 1
a752 9
        case name:
                /*
                        Store the destination directory somewhere useful
                */
                env->destination_name = overflowing_malloc( strlen( auxilliary_information ) + 1 );
                if ( env->destination_name == NULL )
                        return error( mb_malloc_failed );
                strcpy( env->destination_name, auxilliary_information );
                break;
d754 2
a755 3
        case access:
                env->new_access = *(int *)auxilliary_information;
                break;
d757 13
a769 6
        case type:
                env->new_type = *(int *)auxilliary_information;
#ifdef debugact
                dprintf( "new type is %d\n", env->new_type );
#endif
                break;
d771 4
a774 3
        default:
                break;
        }
d776 2
a777 6
        return_directories_last( env->test_search, start_up_details[ env->operation ].return_dirs_last );
        return_directories_first( env->test_search, start_up_details[ env->operation ].return_dirs_first );
        recurse_search_context( env->test_search, start_up_details[ env->operation ].recurse );
        treat_partitions_as_directories( env->test_search, start_up_details[ env->operation ].partition_is_directory );
        env->disable_flex = start_up_details[ env->operation ].disable_flex;
        env->flex_memory = start_up_details[ env->operation ].flex_now;
d779 1
a779 1
        switch( env->operation )
d781 2
d784 1
a784 3
        case Action_Counting:

                err = selection_summary( env->test_search, &env->selection_summary );
d786 1
a786 2
                if ( err )
                     return err;
d788 1
a788 18
                /* drop through into... */
        case Action_Finding:
#ifndef CONFIRM_MEANS_CONFIRM_ALL
                env->confirm = No;
#endif

                /* drop through into... */
        case Action_Stamping:
        case Action_Setting_Type:
        case Action_Copying:
        case Action_CopyLocal:
        case Action_Moving:
                break;

        case Action_Deleting:
                err = selection_summary( env->test_search, &env->selection_summary );
                if ( err )
                        return err;
d790 2
a791 2
                env->locked_not_deleted = 0;
                break;
d793 3
a795 4
        case Action_Setting_Access:
                {
                        os_regset r;
                        char *first_nodename;
d797 1
a797 1
                        recurse_search_context( env->test_search, (options & Option_FilerAction_Recurse) != 0 );
d799 1
a799 1
                        env->directory_access_setting_mask = 0xffffffff;
d801 5
a805 1
                        err = next_nodename( env->test_search, &first_nodename );
d807 2
a808 2
                        if ( err || first_nodename == NULL )
                                break;
d810 3
a812 3
                        r.r[0] = 13;            /* lookup FS */
                        r.r[1] = (int) first_nodename;
                        r.r[2] = 0;             /* truncate on . or : etc */
d814 1
a814 1
                        err = os_swix( OS_FSControl, &r );
d816 2
a817 1
                        overflowing_free( first_nodename );
a818 17
                        /*
                                NetFS doesn't like OwnerWrite being set on directories.
                        */
                        if ( !err && r.r[1] == FileSystemNumber_NetFS )
                                env->directory_access_setting_mask &= ~Attribute_OwnerWrite;

                        break;
                }

        default:
                break;
        }

        reflect_menu_flags( env );

        return NULL;
}
d822 1
a822 1
        wimp_wstate state;
d824 2
a825 2
        if ( wimp_get_wind_state( dbox_syshandle( env->status_box ), &state ) )
                return;
d827 1
a827 1
        dbox_showstatic( env->status_box );
d829 1
a829 1
        state.o.behind = -1;
d831 2
a832 2
        if ( wimp_open_wind( &state.o ) )
                return;
d834 2
a835 2
        env->verbose = Yes;
        env->boxchange_direction = 0;
d838 1
d845 13
a857 13
        env->faster = !env->faster;
        copy_go_faster( env->faster );
        if ( env->faster )
        {
                doings_time = CLK_TCK;          /* 1 second */
                hide_faster_stuff( env );
        }
        else
        {
                doings_time = (10*CLK_TCK)/100; /* 1/10 second */
                show_faster_stuff( env );
        }
        menu_setflags( env->option_menu, 1, env->faster, menus_greyed[ start_up_details[ env->operation ].men ][ 0 ] );
d860 1
d877 8
a884 8
        switch ( event->data.msg.data.words[0] )
        {
        case 0:
                /*
                     Acknowledge the message
                */
                ack_message( event );
                break;
d886 7
a892 3
        case 1:   /* show window and bring it to the front */
                go_verbose( env );
                break;
d894 7
a900 3
        case 2:   /* Turn verbose off - hide the window */
                go_terse( env );
                break;
a901 7
        default:
             /*
                  Do nothing implicitely
             */
             break;
        }
}
d908 22
a929 2
        action_environment *env = environment;
        BOOL processed = No;
d931 1
a931 4
        switch( event->e )
        {
        case wimp_ESEND:
        case wimp_ESENDWANTACK:
d933 4
a936 1
                processed = Yes;
d938 1
a938 1
                switch( event->data.msg.hdr.action )
d940 39
a978 45
                case wimp_MPREQUIT:
                        {
                               /* amg 9th August 1994. Only return a C/S/F12 */
                               /* if the flag word tells us that it was a shutdown */
                               /* or there's no flag word at all */

                                int size_of_prequit = event->data.msg.hdr.size;
                                int flags_of_prequit = event->data.msg.data.words[0];
                                wimp_t sender = event->data.msg.hdr.task;
                                char query_message[ 150 ];

                                wimpt_noerr( ack_message( event ));

                                /*
                                        Construct a context sensitive message for the query.
                                */
                                sprintf( query_message, msgs_lookup( "81" ), msgs_lookup( icon_strings[ env->operation ][ Help_Message_Operation_Fillin ] ) );

                                switch( dboxquery( query_message ) )
                                {
                                case dboxquery_YES:
#ifdef debugact
dprintf("Discard selected\n");
#endif
                                        if (!(size_of_prequit > sizeof(wimp_msghdr) && flags_of_prequit & 1))
                                        {
                                          wimp_get_caret_pos( &event->data.key.c );
                                          event->data.key.chcode = 0x1fc; /* ctrl/shft/f12 */
                                          wimp_sendmessage( wimp_EKEY, (wimp_msgstr *)&event->data, sender );
#ifdef debugact
dprintf("sent message to &%x\n",sender);
#endif
                                        }
                                        abort_operation( env );
                                        break;

                                case dboxquery_NO:
                                case dboxquery_CANCEL:
#ifdef debugact
dprintf("Cancel selected\n");
#endif
                                        break;
                                }
                        }
                        break;
d980 8
a987 22
                case wimp_MSETSLOT:
#ifdef debugact
dprintf( "Slot(%d,%d) - T=%d\n", event->data.msg.data.words[0],event->data.msg.data.words[1], wimpt_task() );
#endif
                        if ( !env->disable_flex )
                        {
                                if ( event->data.msg.data.words[1] == wimpt_task() )
                                {
                                        if ( env->flex_memory &&
                                                event->data.msg.data.words[0] >= 0 )
                                        {
                                                action_slot( event->data.msg.data.words[0] );
                                        }

                                        wimpt_noerr( ack_message( event ));
                                }
                                else
                                {
                                        processed = No;
                                }
                        }
                        break;
d989 61
a1049 4
                case wimp_MHELPREQUEST:
                        event->data.msg.hdr.your_ref = event->data.msg.hdr.my_ref;
                        event->data.msg.hdr.action = wimp_MHELPREPLY;
                        event->data.msg.hdr.size = 256; /* enough for all messages */
d1051 5
a1055 18
                        switch( event->data.msg.data.helprequest.m.i )
                        {
                        case Abort_Button:
                        case No_Skip_Button:
                        case Yes_Retry_Button:
                        case Misc_Button:
                        case Skip_Button:
                                sprintf( event->data.msg.data.helpreply.text, msgs_lookup( HELP_MESSAGE_CONTROL ),
                                        msgs_lookup( icon_strings[ env->operation ][ Help_Message_Operation_Fillin ] ),
                                        msgs_lookup( env->button_actions.button_helps[
                                                event->data.msg.data.helprequest.m.i - Abort_Button ] ));
                                break;

                        default:
                                sprintf( event->data.msg.data.helpreply.text, msgs_lookup( HELP_MESSAGE_CONTROL_NOBUTTON ),
                                        msgs_lookup( icon_strings[ env->operation ][ Help_Message_Operation_Fillin ] ));
                             break;
                        }
d1057 14
a1070 2
                        wimpt_noerr( wimp_sendmessage( wimp_ESEND, &event->data.msg, event->data.msg.hdr.task ));
                        break;
d1072 1
a1072 15
                case wimp_MFilerSelectionDirectory:
                        clear_selection( env->test_search );
                        wimpt_noerr( set_directory( env->test_search, event->data.msg.data.chars ));
                        env->source_directory_name_length = strlen( event->data.msg.data.chars );
                        break;

#ifdef USE_LOAD_OPERATIONS
                case wimp_MDATALOAD:
                        if ((env->operation != Action_Copying) &&
                            (env->operation != Action_Moving) &&
                            (env->operation != Action_Deleting) &&
                            (env->operation != Action_Setting_Access) &&
                            (env->operation != Action_Setting_Type) &&
                            (env->operation != Action_Counting) &&
                            (env->operation != Action_Stamping) )
d1074 1
a1074 1
                          /* Generate some kind of error for the user to see */
d1078 1
a1078 12
                          extern char *get_directory(search_handle);
                          char *ourdir=get_directory(env->test_search);
                          char *theirfile=event->data.msg.data.dataload.name;
                          int ourdirlen=strlen(ourdir);
                          processed=Yes;
                          if ( (strncmp(ourdir,theirfile,ourdirlen)==0) &&
                               (theirfile[ourdirlen]=='.') &&
                               (strchr(&theirfile[ourdirlen+1],'.')==NULL) )
                          { /* It's something we can use - yay! */
                            char *file= &theirfile[ourdirlen+1];
                            wimpt_noerr( add_selection( env->test_search, file, strlen(file) ) );
                          }
a1079 2
                        break;
#endif
d1081 2
a1082 41
                case wimp_MFilerAddSelection:
                        {
                                char *pos;
                                int wordlen;
                                char *wordpos;

                                /*
                                        Wander over the string of selections peeling
                                        them off, one at a time
                                */
                                for ( pos = &event->data.msg.data.chars[0];
                                      *pos != '\0';
                                      pos++ )
                                {
                                        /*
                                             If we have a candidate word
                                        */
                                        if ( *pos != SPACE )
                                        {
                                                wordpos = strchr( pos, SPACE );

                                                if ( wordpos == NULL )
                                                {
                                                        wordlen = strlen( pos );
                                                }
                                                else
                                                {
                                                        wordlen = wordpos - pos;
                                                }

                                                wimpt_noerr( add_selection( env->test_search, pos, wordlen ));


                                                /*
                                                        pos is on the last character of the word
                                                */
                                                pos += wordlen - 1;
                                        }
                                }
                        }
                        break;
d1084 8
a1091 3
                case wimp_MFilerAction:
                        {
                                os_error *err;
d1093 21
a1113 13
                                actions_possible action;
                                int options;
                                void *auxilliary_information;

                                action = (actions_possible)event->data.msg.data.words[ 0 ];
                                options = event->data.msg.data.words[ 1 ];
                                auxilliary_information = &event->data.msg.data.words[ 2 ];

                                err = start_operation( env, action, options, auxilliary_information );
                                if (err)
                                 werr(TRUE, err->errmess);
                        }
                        break;
d1115 3
a1117 9
                case wimp_MFilerControlAction:
                        control_action( env, event );
                        break;

                default:
                        processed = No;
                        break;
                }
                break;
d1119 2
d1122 1
a1122 1
        return processed;
d1125 4
d1131 11
a1141 10
        if ( env->faster && !env->faster_stuff_hidden )
        {
                dbox_setfield( env->status_box, Bottom_Info_Path, "" );
                dbox_setfield( env->status_box, Bottom_Info_Leaf, "" );
                if ( !show_when_faster[ env->operation ][ 0 ] )
                        dbox_setfield( env->status_box, Top_Progress_Field, "-" );
                if ( !show_when_faster[ env->operation ][ 1 ] )
                        dbox_setfield( env->status_box, Bottom_Progress_Field, "-" );

                env->faster_stuff_hidden = Yes;
a1142 4
                /* JRF: Make the 'Faster' button show 'Slower' now */
                set_faster_state ( env );
        }
}
d1146 5
a1150 1
        if ( env->faster_stuff_hidden )
d1152 2
a1153 11
                dbox_setfield( env->status_box, Bottom_Info_Path, newpath );
                dbox_setfield( env->status_box, Bottom_Info_Leaf, newleaf );
                if ( !show_when_faster[ env->operation ][ 0 ] )
                        dbox_setlongnumeric( env->status_box, Top_Progress_Field, env->top_progress );
                if ( !show_when_faster[ env->operation ][ 1 ] )
                {
                        dbox_setlongnumeric( env->status_box, Bottom_Progress_Field, env->bottom_progress );
                        /* char buf[20]; */
                        /* sprintf(buf,"%u",env->bottom_progress); */
                        /* dbox_setfield( env->status_box, Bottom_Progress_Field, buf ); */
                }
d1155 1
a1155 1
                env->faster_stuff_hidden = No;
d1157 2
a1158 3
                /* JRF: Make the 'Faster' button show 'Faster' now */
                set_faster_state( env );
        }
d1161 1
d1164 10
a1173 6
        switch( hit[0] )
        {
        case 1: /* faster */
                toggle_faster( env ); /* JRF: Now a function to aid the */
                                      /* button */
                break;
d1175 6
a1180 3
        case 2: /* confirm */
                env->confirm = !env->confirm;
                break;
d1182 3
a1184 6
        case 3: /* verbose */
                if ( env->verbose )
                        go_terse( env );
                else
                        go_verbose( env );
                break;
d1186 3
a1188 3
        case 4: /* force */
                env->force = !env->force;
                break;
d1190 3
a1192 3
        case 5: /* newer */
                env->looknewer = !env->looknewer;
                break;
d1194 2
a1195 3
        default:
                break;
        }
a1196 2
        reflect_menu_flags( env );
}
d1215 49
a1263 4
        char *sourcegunge;
        char *sourceleaf = source + env->source_directory_name_length + 1;
        char *destleaf;
        char *temp;
d1265 2
d1268 1
a1268 11
                This takes
                source = <source dir><source leaf><gunge>
                and
                dest = <dest dir><dest leaf>
                making
                destn = <destdir><dest leaf><gunge>

                or
                dest = <dest leaf>
                making
                destn = <source dir><dest leaf><gunge>
d1270 18
d1289 1
a1289 59
        /*
                sourcegunge points to the stuff past the source leaf (which is
                one of the selected items).
        */
        if ( strchr( sourceleaf, '.' ) == 0 )
        {
                sourcegunge = source + strlen( source );
        }
        else
        {
                sourcegunge = strchr( sourceleaf, '.' );
        }

        /*
                destleaf points to the leaf part of the destination
        */
        destleaf = strrchr( env->destination_name, '.' );
        temp = strrchr( env->destination_name, ':' );

        if ( temp > destleaf )
                destleaf = temp;

        if ( destleaf == NULL )
        {
                destleaf = env->destination_name;
        }
        else
        {
                destleaf++;     /* move beyond the separator (. or :) */
        }

        if ( destleaf > env->destination_name )
        {
                /*
                        Destination directory is present
                */
                *destination = overflowing_malloc( strlen( env->destination_name ) + strlen( sourcegunge ) + 1 );

                if ( *destination == NULL )
                        return error( mb_malloc_failed );

                sprintf( *destination, "%s%s", env->destination_name, sourcegunge );
        }
        else
        {
                *destination = overflowing_malloc( env->source_directory_name_length + 1 + strlen( env->destination_name ) +
                                        strlen( sourcegunge ) + 1 );

                if ( *destination == NULL )
                        return error( mb_malloc_failed );

                strncpy( *destination, source, env->source_directory_name_length + 1 );

                sprintf( *destination + env->source_directory_name_length + 1, "%s%s",
                                env->destination_name,
                                sourcegunge );
        }

        return NULL;
d1315 6
a1320 6
        char *destination;
        char *source;
        os_filestr fileplace;
        os_error *err;
        int source_reload;
        int destination_reload;
d1322 1
a1322 1
        wimpt_noerr( next_nodename( env->test_search, &source ));
d1324 23
a1346 8
        if ( env->operation != Action_CopyLocal )
        {
                wimpt_noerr( create_destination_filename( env, source, &destination ));
        }
        else
        {
                wimpt_noerr( create_destination_localfile( env, source, &destination ));
        }
d1348 1
a1348 1
        source_reload = reload_of_next_node( env->test_search );
d1351 3
a1353 1
                Only look newer if source has a datestamp
d1355 1
a1355 3
        if ( env->looknewer &&
             ( source_reload & DateStamped_Mask ) == DateStamped_Mask &&
             objecttype_of_next_node( env->test_search ) != ObjectType_Directory  )
d1357 4
a1360 5
                /*
                        Get the destination's information
                */
                fileplace.action = 5; /* read catalogue information */
                fileplace.name = destination;
d1362 28
a1389 43
                err = os_file( &fileplace );

                /*
                        If an error happened which wasn't 'not found' then return
                        with that error. 'not found' means datestamp checking need
                        not happen.
                */
                if ( err )
                {
                        if ( ( err->errnum & FileError_Mask ) != ErrorNumber_NotFound )
                        {
                                overflowing_free( source );
                                overflowing_free( destination );

                                return err;
                        }
                }
                else
                {
                        /*
                                If destination is datestamped after source, then don't
                                add source to read list
                        */
                        destination_reload = fileplace.loadaddr;
                        if ( ( destination_reload & DateStamped_Mask ) == DateStamped_Mask )
                        {
                                if ( (destination_reload & DateStamp_HighByte) >
                                          (source_reload & DateStamp_HighByte) ||
                                     ( (destination_reload & DateStamp_HighByte) ==
                                            (source_reload & DateStamp_HighByte) &&
                                       (unsigned int)fileplace.execaddr >=
                                       (unsigned int)execute_of_next_node( env->test_search ) )
                                   )
                                {
                                        overflowing_free( source );
                                        overflowing_free( destination );

                                        *should_be_added = No;

                                        return NULL;
                                }
                        }
                }
d1391 1
d1393 2
a1394 2
        overflowing_free( destination );
        overflowing_free( source );
d1396 1
a1396 1
        *should_be_added = Yes;
d1398 1
a1398 1
        return NULL;
d1406 2
a1407 2
        char *destination;
        char *source;
d1409 1
a1409 1
        wimpt_noerr( next_nodename( env->test_search, &source ));
d1411 22
a1432 8
        if ( env->operation != Action_CopyLocal )
        {
                wimpt_noerr( create_destination_filename( env, source, &destination ));
        }
        else
        {
                wimpt_noerr( create_destination_localfile( env, source, &destination ));
        }
d1434 2
a1435 8
        wimpt_noerr( add_file_to_chain( destination, source,
                       size_of_next_node( env->test_search ),
                       reload_of_next_node( env->test_search ),
                       execute_of_next_node( env->test_search ),
                       attributes_of_next_node( env->test_search ),
                       objecttype_of_next_node( env->test_search ),
                       env->force,
                       i_am_full ));
d1437 1
a1437 13
        overflowing_free( destination );
        overflowing_free( source );

        switch_to_reading( env );
}

/*
     Record more top progress
*/
static void more_top_progress( action_environment *env, int change )
{
        env->top_progress += change;
        set_top_progress_field( env, env->top_progress );
a1439 14
/*
     Record more bottom progress
*/
static void more_bottom_progress( action_environment *env, unsigned int change )
{
        env->bottom_progress += change;
        if ( !env->faster || show_when_faster[ env->operation ][ 1 ] )
        {
                dbox_setlongnumeric( env->status_box, Bottom_Progress_Field, env->bottom_progress);
                /* char buf[20]; */
                /* sprintf(buf,"%u",env->bottom_progress); */
                /* dbox_setfield( env->status_box, Bottom_Progress_Field, buf ); */
        }
}
d1458 1
d1473 1
d1486 1
d1507 1
d1521 1
d1542 1
d1548 17
a1564 17
        os_error *err;
        os_regset r;
        char *source;
        char *destination;
        int should_be_added;

        test_add_to_read_list(env, &should_be_added);
        wimpt_noerr( next_nodename( env->test_search, &source ));
        if (!should_be_added) return 0;

        wimpt_noerr( create_destination_filename( env, source, &destination ));
#ifdef debugact
dprintf("riscos_rename: src = %s, dest = %s\n",source,destination);
#endif
        r.r[0] = 25; /* rename */
        r.r[1] = (int)source;
        r.r[2] = (int)destination;
d1566 1
a1566 1
        err = os_swix( OS_FSControl, &r );
d1568 2
a1569 2
        overflowing_free( source );
        overflowing_free( destination );
d1571 1
a1571 1
        return err;
d1574 1
d1577 11
a1587 4
        os_error *err;
        char *filename;
        int inhibit_confirm = No;
        int is_cvs_directory = No;
d1589 6
a1594 1
        err = step_to_next_node( env->test_search );
d1597 17
a1613 1
                return err;
d1615 1
a1615 1
        if ( another_node( env->test_search ))
d1617 10
a1626 1
                err = next_nodename( env->test_search, &filename );
d1628 3
a1630 2
                if ( err )
                        return err;
d1632 12
a1643 1
                set_bottom_info_field( env, filename );
d1645 7
a1651 10
                if ( env->auto_skip_cvs ) {
                  size_t length = strlen( filename );
                  if (length > 4 && strcmp(filename + length - 4, ".CVS") == 0)
                  {
                          is_cvs_directory = Yes;
                  }
                  else if (length > 8 && strcmp(filename + length - 8, "./cvstag") == 0)
                  {
                          is_cvs_directory = Yes;
                  }
d1653 1
a1653 4

                overflowing_free( filename );

                switch( env->operation )
d1655 8
a1662 10
                case Action_Copying:
                case Action_CopyLocal:
                        env->action = Test_Add_To_Read_List;
                        inhibit_confirm = Yes;
                        if ( is_cvs_directory == Yes)
                        {
                                skip_list_file(env->test_search);
                                env->action = Next_File;
                        }
                        break;
d1664 3
a1666 16
                case Action_Moving:
                        env->action = Attempt_1st_Rename;
                        break;

                case Action_CopyMoving:
                        if ( objecttype_of_next_node( env->test_search ) == ObjectType_Directory &&
                             directory_is_after_contents( env->test_search ) )
                        {
                                env->action = Add_To_Read_List;
                        }
                        else
                        {
                                env->action = Test_Add_To_Read_List;
                        }
                        inhibit_confirm = Yes;
                        break;
d1668 3
a1670 18
                case Action_Deleting:
                        if ( objecttype_of_next_node( env->test_search ) == ObjectType_Directory )
                        {
                                if ( directory_is_after_contents( env->test_search ) )
                                {
                                        env->action = Attempt_Delete;
                                        inhibit_confirm = Yes;
                                }
                                else
                                {
                                        env->action = Next_File;
                                }
                        }
                        else
                        {
                                env->action = Attempt_Delete;
                        }
                        break;
d1672 3
a1674 16
                case Action_Setting_Access:
                        env->action = Attempt_Set_Access;
                        break;

                case Action_Setting_Type:
                        env->action = Attempt_Set_Type;
                        break;

                case Action_Counting:
                        more_top_progress( env, 1 );
                        more_bottom_progress( env, size_of_next_node( env->test_search ) );
                        break;

                case Action_Stamping:
                        env->action = Attempt_Stamp;
                        break;
d1676 4
a1679 16
                case Action_Finding:
                        if ( !caseless_wildcmp( env->destination_name, name_of_next_node( env->test_search )) )
                        {
                                last_top_info_field = msgs_lookup( "84" );
                                dbox_setfield( env->status_box, Top_Info_Field, last_top_info_field );
                                if ( (objecttype_of_next_node( env->test_search ) == ObjectType_Directory &&
                                      name_of_next_node( env->test_search )[0] != '!') ||
                                      objecttype_of_next_node( env->test_search ) == (ObjectType_Directory | ObjectType_File) )
                                {
                                        switch_buttons( env, &open_buttons );
                                }
                                else
                                {
                                        switch_buttons( env, &run_view_buttons );
                                }
                        }
d1681 3
a1683 12
                        /*
                                Keep the user informed of what's happening
                        */
                        if ( objecttype_of_next_node( env->test_search ) != ObjectType_File )
                        {
                                more_top_progress( env, 1 );
                        }
                        else
                        {
                                more_bottom_progress( env, 1 );
                        }
                        break;
d1685 10
a1694 2
                default:
                        break;
d1696 1
a1696 7

                /*
                        Don't confirm until we are sure this file is going to
                        be added to the read list.
                */
                if ( env->confirm &&
                     !inhibit_confirm )
d1698 1
a1698 3
                        switch_buttons( env, &confirm_buttons );
                        last_top_info_field = msgs_lookup( action_prompt[ env->operation ] );
                        dbox_setfield( env->status_box, Top_Info_Field, last_top_info_field );
d1700 45
d1746 14
a1759 1
        else
d1761 3
a1763 16
                /*
                        No more files
                */
                if ( env->operation == Action_Copying ||
                     env->operation == Action_CopyMoving ||
                     env->operation == Action_CopyLocal )
                {
                        switch_to_writing( env );
                }
                else if ( env->operation == Action_Counting )
                {
                        /*
                                Change buttons, display dbox, clear
                                unwanted fields etc
                        */
                        switch_buttons( env, &ok_button );
d1765 1
a1765 8
                        dbox_setfield( env->status_box, Top_Info_Field, msgs_lookup( "85" ));
                        set_bottom_info_field( env, env->selection_summary );
                }
                else if ( ( env->operation == Action_Deleting ||
                            env->operation == Action_CopyMoving ) &&
                          env->locked_not_deleted > 0 )
                {
                         char top_field[ 50 ];
d1767 2
a1768 1
                         switch_buttons( env, &ok_button );
d1770 2
a1771 1
                         sprintf( top_field, msgs_lookup( "86" ), env->locked_not_deleted );
a1772 11
                         dbox_setfield( env->status_box, Top_Info_Field, top_field );
                         set_bottom_info_field( env, env->selection_summary );
                }
                else
                {
                        /*
                                Finished doing everything else, so
                                kill ourselves off
                        */
                        abort_operation( env );
                }
d1774 9
d1784 1
a1784 1
        return NULL;
d1787 1
d1790 2
a1791 2
        os_error *err;
        int should_be_added;
d1793 1
a1793 1
        err = test_add_to_read_list( env, &should_be_added );
d1795 2
a1796 2
        if ( err )
                return err;
d1798 3
a1800 3
        if ( should_be_added )
        {
                env->action = Add_To_Read_List;
d1802 4
a1805 11
                /*
                        Confirm if necessary.
                */
                if ( env->confirm )
                {
                        switch_buttons( env, &confirm_buttons );
                        last_top_info_field = msgs_lookup( action_prompt[ env->operation ] );
                        dbox_setfield( env->status_box, Top_Info_Field, last_top_info_field );
                }
        }
        else
d1807 2
a1808 1
                env->action = Next_File;
d1810 5
d1816 1
a1816 1
        return NULL;
d1821 1
a1821 1
        int i_am_full;
d1823 1
a1823 1
        add_to_read_list( env, &i_am_full );
d1825 2
a1826 2
        if ( i_am_full )
                switch_to_writing( env );
d1828 1
a1828 1
        return NULL;
d1833 5
a1837 4
        os_error *err;
        int i_am_full;
        int need_another_file;
        int that_finished_a_file;
d1839 1
a1839 1
        err = read_a_block( &i_am_full, &need_another_file, &that_finished_a_file );
d1841 2
a1842 2
        if ( err )
                return err;
d1844 11
a1854 1
        if ( i_am_full )
d1856 1
a1856 1
                switch_to_writing( env );
d1858 1
a1858 1
        else if ( need_another_file )
d1860 1
a1860 12
                if ( another_node( env->test_search ))
                {
                        env->action = Next_File;
                }
                else if ( next_file_to_be_written() == NULL )
                {
                        abort_operation( env );
                }
                else
                {
                        switch_to_writing( env );
                }
d1864 6
a1869 1
                set_top_progress_field( env, bytes_left_to_read());
d1871 3
a1873 4
                if ( that_finished_a_file )
                {
                        set_bottom_info_field( env, next_file_to_be_read());
                }
d1875 1
d1877 1
a1877 1
        return NULL;
d1880 1
d1883 4
a1886 3
        os_error *err;
        int i_am_empty;
        int that_finished_a_file;
d1888 1
a1888 1
        err = write_a_block( &i_am_empty, &that_finished_a_file );
d1890 13
a1902 2
        if ( err )
                return err;
d1904 1
a1904 1
        if ( i_am_empty )
d1906 4
a1909 10
                switch_to_reading( env );
        }
        else if ( that_finished_a_file )
        {
                if ( env->operation != Action_CopyMoving )
                {
                        if ( size_of_finished_file >= 0 )
                        {
                                more_bottom_progress( env, 1 );
                        }
d1911 2
a1912 11
                        set_bottom_info_field( env, next_file_to_be_written());
                        set_top_progress_field( env, bytes_left_to_write());
                }
                else
                {
                        /*
                                We are copyMoving, hence:
                                Attempt_Delete (will work for dirs on way up tree, but fail on way down)
                        */
                        env->action = Attempt_Delete;
                }
d1916 11
a1926 2
                set_top_progress_field( env, bytes_left_to_write());
        }
d1928 1
a1928 1
        return NULL;
d1931 1
d1934 1
a1934 1
        os_error *err;
d1936 1
a1936 1
        err = riscos_rename( env );
d1938 26
a1963 1
        if ( err )
d1965 2
a1966 20
                switch ( err->errnum & FileError_Mask )
                {
                case ErrorNumber_Locked:
                        if ( which_one == 1 )
                        {
                                env->action = Attempt_Unlock;
                                err = NULL;
                        }
                        break;

                case ErrorNumber_NotSameDisc:
                case ErrorNumber_BadRename:
                case ErrorNumber_AlreadyExists:
                        if ( which_one == 1 )
                                env->action = Convert_To_CopyMove;
                        else
                                env->action = Convert_To_CopyMove_After_Unlock;
                        err = NULL;
                        break;
                }
d1970 1
a1970 9
                if ( which_one == 1 )
                {
                        more_bottom_progress( env, 1 );
                        env->action = Next_File;
                }
                else
                {
                        env->action = Attempt_Relock;
                }
d1972 4
d1977 1
a1977 1
        return err;
d1980 1
d1983 2
a1984 2
        os_error *err;
        char *filename;
d1986 1
a1986 1
        err = next_nodename( env->test_search, &filename );
d1988 2
a1989 2
        if ( err )
                return err;
d1991 4
a1994 4
        /*
                Ignore error as don't care if it fails
        */
        (void)set_access_to_file( filename, attributes_of_next_node( env->test_search ) & ~Attribute_Locked );
d1996 1
a1996 1
        overflowing_free( filename );
d1998 1
a1998 1
        env->action = Attempt_2nd_Rename;
d2000 1
a2000 1
        return NULL;
d2003 1
d2005 1
a2005 1
        Relock destination of rename after unlocking source
d2009 3
a2011 3
        os_error *err;
        char *source;
        char *destination;
d2013 1
a2013 1
        err = next_nodename( env->test_search, &source );
d2015 2
a2016 2
        if ( err )
                return err;
d2018 1
a2018 1
        err = create_destination_filename( env, source, &destination );
d2020 1
a2020 1
        overflowing_free( source );
d2022 2
a2023 2
        if ( err )
                return err;
d2025 4
a2028 4
        /*
                Ignore error as don't care if it fails
        */
        (void)set_access_to_file( destination, attributes_of_next_node( env->test_search ) );
d2030 1
a2030 1
        overflowing_free( destination );
d2032 1
a2032 1
        more_bottom_progress( env, 1 );
d2034 1
a2034 1
        env->action = Next_File;
d2036 1
a2036 1
        return NULL;
d2039 1
d2042 2
a2043 2
        os_error *err;
        char *filename;
d2045 6
d2052 1
a2052 2
                Relock the node if necessary, don't object if this
                fails!
a2053 5
        if ( after_unlock )
        {
                /*
                        return the attributes to their old values (but ignore errors back)
                */
d2055 1
a2055 1
                err = next_nodename( env->test_search, &filename );
d2057 2
a2058 2
                if ( err )
                       return err;
d2060 1
a2060 1
                (void)set_access_to_file( filename, attributes_of_next_node( env->test_search ));
d2062 2
a2063 2
                overflowing_free( filename );
        }
d2065 16
a2080 7
        init_for_copying();
        env->flex_memory = Yes;
        env->operation = Action_CopyMoving;
        env->action = Add_To_Read_List;
        return_directories_first( env->test_search, Yes );
        return_directories_last( env->test_search, Yes );
        recurse_search_context( env->test_search, Yes );
d2082 1
a2082 1
        err = selection_summary( env->test_search, &env->selection_summary );
d2084 1
a2084 1
        env->locked_not_deleted = 0;
d2086 1
a2086 1
        return err;
d2089 1
d2092 36
a2127 4
        os_error *err;
        char *filename;
        int inhibit_progress = No;
        int prev_access;
d2129 1
a2129 12
        if ( env->operation != Action_CopyMoving )
        {
                wimpt_noerr( next_nodename( env->test_search, &filename ));
        }
        else
        {
                filename = source_of_finished_file;
        }

#ifdef debugact
dprintf("Do_Attempt_Delete: filename = %s\n",filename);
#endif
d2131 2
d2134 1
a2134 2
                JRS 29/1/92 1st attempt to delete the node without touching the access.
                In most cases this will work without further ado
d2137 1
a2138 12
        /*
                If forcing delete, set no read/write access and
                unlock it. If this fails, then the delete will
                never work!
        */
        prev_access = -1; /* special value to test for */
        if ( (err != NULL) &&
             (env->force ||
             env->operation == Action_CopyMoving) )
        {
                err = get_access_to_file(filename, &prev_access);
                if ( err ) prev_access = -1;
d2140 53
a2192 1
                err = set_access_to_file(filename, prev_access & ~Attribute_Locked);
d2194 2
a2195 6
                if ( err && (err->errnum & FileError_Mask) != ErrorNumber_NotFound )
                        return err;
                /*
                        Retry deletion
                 */
                err = delete_node( filename );
d2197 3
a2199 2


d2201 1
a2201 2
                If it didn't work, cancel the error if its an ignorable
                error for this operation
d2203 2
a2204 9
        if ( err )
        {
                /* JRS 28/1/92 test if access should be restored */
                if ( prev_access != -1 )
                { /*
                        Put the access back to where it was
                   */
                        set_access_to_file( filename, prev_access);
                }
d2206 2
a2207 10
                switch( err->errnum & FileError_Mask )
                {
                case ErrorNumber_Locked:
                        /*
                                If forcing delete failed due to locked file then something's
                                happening which the user should know about, so don't drop
                                through the 'cancel this error' code.
                        */
                        if ( env->force )
                                break;
d2209 2
a2210 6
                        /*
                                Otherwise, just note that one file hasn't been deleted
                                due to a locked file and drop through to the 'it didn't
                                get deleted, and it was there, and we don't mind' case.
                        */
                        env->locked_not_deleted++;
d2212 22
a2233 32
                case ErrorNumber_DirectoryNotEmpty:
                        /*
                                Reach here if the file didn't get deleted and it was
                                there and we don't mind. If these conditions are satisfied
                                then we don't want to count this object as deleted.
                        */
                        inhibit_progress = Yes;
                        err = NULL;
                        break;

                case ErrorNumber_NotFound:
                        /*
                                This
                                entry point is used for the 'its already gone' situation,
                                in which case we fib to the user that it was the user which
                                caused the deletion (but it wasn't really; who cares -
                                the file's gone anyway).
                        */
                        err = NULL;
                        deleted_next_node( env->test_search, filename );
                        break;

                default:
                        break;
                }
        }
        else
        {
                /*
                        Tell the file listing stuff we've deleted the node
                */
                deleted_next_node( env->test_search, filename );
d2236 8
a2243 7
        if ( env->operation != Action_CopyMoving )
                overflowing_free( filename );

        if ( err )
                return err;

        if ( env->operation != Action_CopyMoving )
d2245 1
a2245 16
                if ( !inhibit_progress )
                {
                        /*
                                Keep the user informed of what's happening
                        */
                        if ( objecttype_of_next_node( env->test_search ) != ObjectType_File )
                        {
                                more_top_progress( env, 1 );
                        }
                        else
                        {
                                more_bottom_progress( env, 1 );
                        }
                }

                env->action = Next_File;
a2246 9
        else
        {
                /*
                        Update progress if it's a file we've just finished moving
                */
                if ( size_of_finished_file >= 0 )
                {
                        more_bottom_progress( env, 1 );
                }
d2248 1
a2248 1
                set_bottom_info_field( env, next_file_to_be_written());
d2250 2
a2251 2
                env->action = Check_Empty_Writing;
        }
d2253 1
a2253 1
        return NULL;
d2256 1
d2259 1
a2259 1
        os_error *err;
d2261 11
a2271 8
        if ( objecttype_of_next_node( env->test_search ) != ObjectType_File )
        {
                err =
                        set_access(
                                env,
                                ((attributes_of_next_node( env->test_search) & (env->new_access >> 16) & 0xffff) |
                                (env->new_access & ~(env->new_access >> 16) & 0xffff)) &
                                env->directory_access_setting_mask );
d2273 9
a2281 2
                if ( err )
                        return err;
d2283 2
a2284 9
                more_top_progress( env, 1 );
        }
        else
        {
                err =
                        set_access(
                                env,
                                (attributes_of_next_node( env->test_search) & (env->new_access >> 16) & 0xffff) |
                                (env->new_access & ~(env->new_access >> 16) & 0xffff) );
d2286 2
a2287 2
                if ( err )
                        return err;
d2289 3
a2291 2
                more_bottom_progress( env, 1 );
        }
d2293 1
a2293 1
        env->action = Next_File;
d2295 1
a2295 1
        return NULL;
d2298 1
d2301 10
a2310 3
        os_error *err;
        char *filename;
        os_filestr fileplace;
d2312 1
a2312 6
        if ( objecttype_of_next_node( env->test_search ) == ObjectType_Directory )
        {
                more_top_progress( env, 1 );
        }
        else
        {
d2314 2
a2315 1
                err = next_nodename( env->test_search, &filename );
d2317 3
a2319 2
                if ( err )
                        return err;
d2321 1
a2321 3
                fileplace.action = 0x12; /* set file type */
                fileplace.name = filename;
                fileplace.loadaddr = env->new_type;
d2323 1
a2323 1
                err = os_file( &fileplace );
d2325 2
a2326 1
                overflowing_free( filename );
d2328 1
a2328 2
                if ( err )
                        return err;
d2330 1
a2330 1
                more_bottom_progress( env, 1 );
d2332 3
a2334 1
        }
d2336 1
a2336 1
        env->action = Next_File;
d2338 1
a2338 1
        return NULL;
d2341 1
d2344 1
a2344 1
        os_error *err;
d2346 1
a2346 1
        err = stamp( env );
d2348 10
a2357 6
        /*
                Filter out F. S. Error 46 as this is the error generated by file
                servers which can't stamp directories
        */
        if ( err && (err->errnum & FileError_Mask) != ErrorNumber_FSError46 )
                return err;
d2359 1
a2359 1
        err = NULL;
d2361 4
a2364 4
        if ( objecttype_of_next_node( env->test_search ) == ObjectType_File )
                more_bottom_progress( env, 1 );
        else
                more_top_progress( env, 1 );
d2366 1
a2366 1
        env->action = Next_File;
d2368 1
a2368 1
        return NULL;
d2371 1
d2377 12
a2388 3
        os_error *err = NULL;
        char info_buffer[ Info_Field_Length + 15 ];
        int end_time;
d2390 15
a2404 2
        end_time = clock() + doings_time;
        hide_faster_stuff( env );
d2406 1
a2406 1
        do
d2408 43
a2450 4
                if ( env->action == Abort_Operation )
                {
                        abort_operation( env );
                }
d2452 3
a2454 8
                if ( last_top_info_field != env->current_info )
                {
                        if ( env->in_error )
                        {
#ifdef REDERROR
                                wimp_set_icon_state( dbox_syshandle( env->status_box ), Top_Info_Field, 0xc000000, 0 );
                                wimp_set_icon_state( dbox_syshandle( env->status_box ), Bottom_Info_Field, 0xc000000, 0 );
#endif
d2456 3
a2458 6
                                env->in_error = No;
                                switch_box_from_error( env );
                        }
                        dbox_setfield( env->status_box, Top_Info_Field, env->current_info );
                        last_top_info_field = env->current_info;
                }
d2460 3
a2462 61
                switch( env->action )
                {
                case Next_File:
                        err = Do_Next_File( env );
                        break;

                case Test_Add_To_Read_List:
                        err = Do_Test_Add_To_Read_List( env );
                        break;

                case Add_To_Read_List:
                        err = Do_Add_To_Read_List( env );
                        break;

                case Check_Full_Reading:
                        err = Do_Check_Full_Reading( env );
                        break;

                case Check_Empty_Writing:
                        err = Do_Check_Empty_Writing( env );
                        break;

                case Attempt_1st_Rename:
                        err = Do_Attempt_Rename( env, 1 );
                        break;

                case Attempt_Unlock:
                        err = Do_Attempt_Unlock( env );
                        break;

                case Attempt_2nd_Rename:
                        err = Do_Attempt_Rename( env, 2 );
                        break;

                case Attempt_Relock:
                        err = Do_Attempt_Relock( env );
                        break;

                case Convert_To_CopyMove:
                        err = Do_Convert_To_CopyMove( env, No );
                        break;

                case Convert_To_CopyMove_After_Unlock:
                        err = Do_Convert_To_CopyMove( env, Yes );
                        break;

                case Attempt_Delete:
                        err = Do_Attempt_Delete( env );
                        break;

                case Attempt_Set_Access:
                        err = Do_Attempt_Set_Access( env );
                        break;

                case Attempt_Set_Type:
                        err = Do_Attempt_Set_Type( env );
                        break;

                case Attempt_Stamp:
                        err = Do_Attempt_Stamp( env );
                        break;
d2464 3
a2466 3
                default:
                        break;
                }
d2468 2
a2470 8
        /*
                While there is not error and
                        we havn't run out of time and
                        we are accepting NULL events
        */
        while ( !err &&
                clock() < end_time &&
                ( event_getmask() & wimp_EMNULL ) == 0 );
d2472 48
a2519 1
        if ( err )
d2521 32
a2552 1
                if ( err->errnum == 0 )
d2555 1
a2555 1
                                Internally generated error - this is fatal
d2557 1
a2557 1
                        wimpt_noerr( err );
d2561 2
a2562 66
                        /*
                                Externally generated error - give the user a chance
                                to correct it.
                        */

                        if ( ( env->operation == Action_Copying ||
                               env->operation == Action_CopyMoving ||
                               env->operation == Action_CopyLocal ) &&
                             ( env->action == Check_Full_Reading ||
                               env->action == Check_Empty_Writing ) )
                        {
                                /*
                                        Read/Write during a copy or copy move
                                */
                                switch_buttons( env, &restart_button );
                        }
                        else
                        {
                                /*
                                        Attempted activity normal for operation, but failed
                                */
                                switch_buttons( env, &norestart_button );
                        }

                        /*
                                Construct error indicator
                        */
                        if ( ( err->errnum & FileError_Mask ) == ErrorNumber_DiscFull )
                        {
                                strcpy(info_buffer, "87a");
                                strcat(info_buffer, env->current_info_token);
                                sprintf(info_buffer, msgs_lookup(info_buffer), tolower(env->current_info[0]), &env->current_info[1]);

                                if ( env->disc_full_already )
                                {
                                        /*
                                                Cancel the report of a second or subsequent disc full error
                                        */
                                        err = NULL;
                                }
                                else
                                {
                                        env->disc_full_already = Yes;
                                        switch_box_to_error( env, err );
                                }
                        }
                        else
                        {
                                strcpy(info_buffer, "88a");
                                strcat(info_buffer, env->current_info_token);
                                sprintf(info_buffer, msgs_lookup(info_buffer), tolower(env->current_info[0]), &env->current_info[1]);

                                switch_box_to_error( env, err );
                        }

                        dbox_setfield( env->status_box, Top_Info_Field, info_buffer );
                        last_top_info_field = info_buffer;

                        /*
                             Set the info field text to red (assuming it was black)
                        */
                        env->in_error = Yes;
#ifdef REDERROR
                        wimp_set_icon_state( dbox_syshandle( env->status_box ), Top_Info_Field, 0xc000000, 0 );
                        wimp_set_icon_state( dbox_syshandle( env->status_box ), Bottom_Info_Field, 0xc000000, 0 );
#endif
d2564 16
d2581 1
d2584 1
d2590 1
a2590 1
        BOOL handled = No;
d2592 1
a2592 1
        db = db; /* keep the compiler quiet */
d2594 3
a2596 1
        switch( ((wimp_eventstr *)event)->e )
d2598 9
a2606 1
        case wimp_ENULL:
d2608 6
a2613 1
                        action_environment *env = handle;
d2615 2
a2616 14
                        /*
                                Process delayed box showing and hiding
                        */
                        if ( env->boxchange_direction != 0 &&
                             clock() >= env->time_to_boxchange )
                        {
                                if ( env->boxchange_direction > 0 )
                                {
                                        dbox_showstatic( env->status_box );
                                }
                                else
                                {
                                        dbox_hide( env->status_box );
                                }
d2618 4
a2621 2
                                env->boxchange_direction = 0;
                        }
d2623 4
a2626 4
                        null_event_activity( env );
                }
                handled = Yes;
                break;
d2628 3
a2630 4
        case wimp_ESEND:
        case wimp_ESENDWANTACK:
                handled = message_event_handler( event, handle );
                break;
d2632 2
a2633 3
        default:
                break;
        }
a2634 2
        return handled;
}
d2648 1
a2648 1
        disable_stack_extension = 1;
d2650 1
a2650 1
        wimpt_install_signal_handlers();
d2652 1
a2652 1
        wimpt_noerr( initialise( &env, argc, argv ));
d2654 4
a2657 4
        while (TRUE)
        {
                event_process();
        }
d2659 1
a2659 1
        return 0;
@


4.4
log
@  Minor improvement to enable optional skipping of objects during copies.
Detail:
  If the system variable Filer_Action$Skip is set (to anything - even the
    null string), then during a Copy operation, Filer_Action will skip
    directories called "CVS" and files called "/cvstag".  Variable is read
    whenever Filer_Action desktop task starts (ie. at the start of each
    copy).  This dramatically reduces the time it takes to copy a checkout
    tree from NFS->RISC OS.
Admin:
  Tested in desktop build.

Version 0.44. Tagged as 'FilerAct-0_44'
@
text
@d109 1
d132 1
d141 1
d219 2
a220 2
action_environment env = {};
char *last_top_info_field = NULL;
d385 5
a389 1
static void set_top_progress_field( action_environment *env, int value )
d393 1
a393 1
                dbox_setnumeric( env->status_box, Top_Progress_Field, value );
d527 2
a528 2
        dbox_setnumeric( env->status_box, Top_Progress_Field, env->top_progress );
        dbox_setnumeric( env->status_box, Bottom_Progress_Field, env->bottom_progress );
d538 1
a545 1

d552 1
d620 1
d622 1
d698 21
d879 30
d995 3
d1008 1
a1008 1
                        dbox_setnumeric( env->status_box, Top_Progress_Field, env->top_progress );
d1011 4
a1014 3
                        char buf[20];
                        sprintf(buf,"%u",env->bottom_progress);
                        dbox_setfield( env->status_box, Bottom_Progress_Field, buf );
d1018 3
d1029 2
a1030 12
                env->faster = !env->faster;
                copy_go_faster( env->faster );
                if ( env->faster )
                {
                        doings_time = CLK_TCK;          /* 1 second */
                        hide_faster_stuff( env );
                }
                else
                {
                        doings_time = (10*CLK_TCK)/100; /* 1/10 second */
                        show_faster_stuff( env );
                }
d1316 4
a1319 3
                char buf[20];
                sprintf(buf,"%u",env->bottom_progress);
                dbox_setfield( env->status_box, Bottom_Progress_Field, buf );
@


4.3
log
@Ursula branch merged
@
text
@d536 1
a536 1
        }            
d542 1
d1396 1
d1412 12
d1432 5
@


4.2
log
@Version RO_3_71 merged
@
text
@d145 2
d154 2
d272 3
d528 10
@


4.2.2.1
log
@Added new options - Faster (from start of op) and ConfirmDeletes.
@
text
@a144 2
#define Option_FilerAction_ConfirmDeletes       0x00000020 /* RML */
#define Option_FilerAction_Faster               0x00000040 /* RML */
a151 2


a267 3
/* RML */
static void hide_faster_stuff( action_environment *env );

a520 10

        /* RML */
        if ((options & Option_FilerAction_ConfirmDeletes) && (operation==Action_Deleting)) env->confirm = Yes;
        if (options & Option_FilerAction_Faster)
        {
            env->faster = Yes;
            doings_time = CLK_TCK;          /* 1 second */
            hide_faster_stuff( env );
        }            

@


4.1
log
@Initial revision
@
text
@d928 5
a932 1
                        dbox_setnumeric( env->status_box, Bottom_Progress_Field, env->bottom_progress );
d1235 1
a1235 1
static void more_bottom_progress( action_environment *env, int change )
d1239 5
a1243 1
                dbox_setnumeric( env->status_box, Bottom_Progress_Field, env->bottom_progress );
d1449 1
a1449 1
                        more_bottom_progress( env, size_of_next_node( env->test_search ));
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.3.2
log
@Version RO_3_71 taken
@
text
@d928 1
a928 5
                {
                        char buf[20];
                        sprintf(buf,"%u",env->bottom_progress);
                        dbox_setfield( env->status_box, Bottom_Progress_Field, buf );
                }
d1231 1
a1231 1
static void more_bottom_progress( action_environment *env, unsigned int change )
d1235 1
a1235 5
        {
                char buf[20];
                sprintf(buf,"%u",env->bottom_progress);
                dbox_setfield( env->status_box, Bottom_Progress_Field, buf );
        }
d1441 1
a1441 1
                        more_bottom_progress( env, size_of_next_node( env->test_search ) );
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d928 1
a928 5
                {
                        char buf[20];
                        sprintf(buf,"%u",env->bottom_progress);
                        dbox_setfield( env->status_box, Bottom_Progress_Field, buf );
                }
d1231 1
a1231 1
static void more_bottom_progress( action_environment *env, unsigned int change )
d1235 1
a1235 5
        {
                char buf[20];
                sprintf(buf,"%u",env->bottom_progress);
                dbox_setfield( env->status_box, Bottom_Progress_Field, buf );
        }
d1441 1
a1441 1
                        more_bottom_progress( env, size_of_next_node( env->test_search ) );
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

head	4.12;
access;
symbols
	FilerAct-0_62:4.12
	FilerAct-0_61:4.11
	FilerAct-0_60:4.10
	FilerAct-0_59:4.10
	FilerAct-0_58:4.10
	FilerAct-0_57:4.10
	FilerAct-0_55:4.9
	FilerAct-0_54:4.9
	FilerAct-0_53:4.8
	FilerAct-0_52:4.7
	FilerAct-0_51:4.6
	FilerAct-0_50:4.4
	FilerAct-0_49:4.3
	FilerAct-0_48:4.2
	RO_5_07:4.2
	FilerAct-0_47:4.2
	FilerAct-0_46:4.2
	FilerAct-0_45:4.2
	dellis_autobuild_BaseSW:4.2
	FilerAct-0_44:4.2
	FilerAct-0_43:4.2
	sbrodie_sedwards_16Mar2000:4.2
	FilerAct-0_42:4.2
	Ursula_merge:4.2
	dcotton_autobuild_BaseSW:4.2
	mstphens_UrsulaRiscPCBuild_20Nov98:4.2
	Ursula_RiscPC:4.2.0.6
	nicke_FilerAct_0_39:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.2
	UrsulaBuild_FinalSoftload:4.2
	rthornb_UrsulaBuild-12Aug1998:4.2
	aglover_UrsulaBuild-05Aug1998:4.2
	rthornb_UrsulaBuild-29Jul1998:4.2
	rthornb_UrsulaBuild-22Jul1998:4.2
	rthornb_UrsulaBuild-15Jul1998:4.2
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.2
	rthornb_UrsulaBuild-17Jun1998:4.2
	rthornb_UrsulaBuild-03Jun1998:4.2
	rthornb_UrsulaBuild-27May1998:4.2
	rleggett_FilerAct-0_42:4.2
	rthornb_UrsulaBuild-21May1998:4.2
	rthornb_UrsulaBuild_01May1998:4.2
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.2.0.4
	Daytona_bp:4.2
	Ursula:4.2.0.2
	Ursula_bp:4.2
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.2
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.12
date	2016.08.13.16.56.51;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	XhEWf5jy4xvHlaiz;

4.11
date	2015.07.01.21.01.58;	author jlee;	state Exp;
branches;
next	4.10;
commitid	jcgr0oB2C3ESQCry;

4.10
date	2012.07.13.10.28.08;	author rgriffin;	state Exp;
branches;
next	4.9;
commitid	ePxQigwSIOcL9ocw;

4.9
date	2011.10.23.07.55.47;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	xuMPqvl0RQswNrEv;

4.8
date	2011.10.23.07.46.59;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	7I8FKGdkajlxKrEv;

4.7
date	2011.10.20.20.36.00;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	YJZPZatOdKOo68Ev;

4.6
date	2011.10.20.20.32.44;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	DXWFsDOPRJsd58Ev;

4.5
date	2011.10.20.20.23.03;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	xmwir195eiLF18Ev;

4.4
date	2011.10.06.09.53.24;	author rgriffin;	state Exp;
branches;
next	4.3;
commitid	TPe2mWq0vF5QZgCv;

4.3
date	2011.06.29.09.21.49;	author rgriffin;	state Exp;
branches;
next	4.2;
commitid	OcnnyIVQ9uPd0ypv;

4.2
date	97.05.01.17.47.33;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.36;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.36;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.28.04;	author nturton;	state Exp;
branches
	4.1.3.1.2.1;
next	4.1.3.2;

4.1.3.2
date	97.05.01.14.25.41;	author kbracey;	state Exp;
branches;
next	;

4.1.3.1.2.1
date	97.04.30.10.31.33;	author kbracey;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.18.01;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.16.51;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Fix for NULL pointer dereference skipping/retrying the last file
If an error occurs during an operation (for example, during a copy move where the source is on a read only medium) the status window changes to an error window with "Abort/Skip/Retry". The skip and retry options call read_next_node_parameters() to peek the next queued item, but would attempt to OS_File 5 of a NULL filename if the error happens when there are no more.
Check the next_nodename isn't NULL to avoid an abort in OS_GSInit with zero page protection enabled.

Version 0.62. Tagged as 'FilerAct-0_62'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
     List files as specified in a selection.

Revision History:

0.00  02-Jun-89  JSR  Created from extracts of c.actionwind.

0.01  27-Jun-89  JSR  Update to cope with arbitrary length file names.

0.02  29-Sep-89  JSR  Use overflowing_ memory allocation routines.
                      Add selection_summary.
                      Add name_of_next_node.

0.03  17-Oct-89  JSR  Upgrade next_nodename and next_filename to not
                      prepend the directory if the directory is a nul
                      string.
*/

#if 0
#define debuglist(k) dprintf k
#else
#define debuglist(k) /* Disabled */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "Interface/HighFSI.h"

#include "os.h"

#include "Options.h"
#include "malloc+.h"
#include "listfiles.h"
#include "allerrs.h"
#include "debug.h"
#include "memmanage.h"

#define No 0
#define Yes (!No)

#define Directory_Buffer_Size 20
#define Temp_DirBuffer_Size   640

typedef struct
{
     int      load_address;
     int      execution_address;
     uint32_t length;
     int      attributes;
     int      object_type;
     char     *object_name;

     #ifdef USE_PROGRESS_BAR
     void     *chain_ref;
     #endif

}    directory_buffer_entry;

typedef struct Search_Nest_Level
{
     struct Search_Nest_Level *next_search_nest_level;
     int                      offset_to_next_item;
     int                      entries_in_buffer;
     int                      next_entry_to_return;
     directory_buffer_entry   directory_buffer[ Directory_Buffer_Size ];

     #ifdef USE_PROGRESS_BAR
     BOOL                     counted;
     uint32_t                 total_entries;
     int                      total_progress;
     int                      progress_per_object;
     #endif

}    search_nest_level;

typedef struct File_Selection
{
     struct File_Selection *next_file;
     char                  *selection_name;
}    file_selection;

/*
     This enumerates the states for finding the next leaf to process.
*/
typedef enum
{
     Next_Leaf,               /* Find the next leaf at this level */
     Process_Node,            /* Process that found by Next_Leaf */
     Read_Next_Cache_Full,    /* Read another directory cache-full */
     Nest_Into_Directory      /* Start up into a nested directory */
}    next_leaf_state;

typedef struct search_context
{
    search_nest_level *nested_filenames;
    char              *directory;
    file_selection    *selection;
    file_selection    **last_selections_link;
    next_leaf_state   action;
    uint32_t          selections_size;
    int               selections_loadaddr;
    int               selections_execaddr;
    int               selections_attributes;
    int               selections_objecttype;
    int               recursive:1;
    int               directories_first:1;
    int               directories_last:1;
    int               partitions_as_directories:1;

    #ifdef USE_PROGRESS_BAR
    uint32_t          total_entries;
    int               total_progress;
    int               progress_per_object;
    void              *chain_ref;
    #endif

} search_context;

#ifdef USE_PROGRESS_BAR
static uint32_t count_objects_in_dir( char *dir )
{
    os_error   *err;
    os_gbpbstr request;
    char       buff[Temp_DirBuffer_Size];
    int        context = 0, c, num = 0;
    uint32_t   total = 0;

    while (context != -1)
    {
        request.action      = OSGBPB_ReadDirEntries;
        request.file_handle = (int)dir;
        request.data_addr   = buff;
        request.number      = 256;
        request.seq_point   = context;
        request.buf_len     = Temp_DirBuffer_Size;
        request.wild_fld    = 0;

        err = os_gbpb( &request );
        num = request.number;
        c = request.seq_point;
        if (err == NULL)
        {
            if (c == context)
            {
                /*
                   Broken archives cause context to never be updated ... not sure why
                   the SWI does not return an error.
                */
                debuglist(( "count_objects_in_dir: aborting\n" ));
                return 0;
            }

            context = c;
            total += num;
        }
        else
        {
            debuglist(( "count_objects_in_dir: %s\n", err->errmess ));
            return 0;
        }
    }

    return total;
}
#endif

/*
     This initialises an empty search context.
     The search will return a list of files or directories, which must
     be added to the context after it has been created. The context is
     created recursive.
*/
os_error *create_search_context( search_handle *handle )
{
    search_context *new_context;

    if ( ( new_context = overflowing_malloc( sizeof( search_context ))) != NULL )
    {
        *handle = (search_handle)new_context;
        new_context->directory = NULL;
        new_context->nested_filenames = NULL;
        new_context->selection = NULL;
        new_context->last_selections_link = &new_context->selection;
        new_context->recursive = Yes;
        new_context->directories_first = No;
        new_context->directories_last = No;
        new_context->partitions_as_directories = Yes;
        new_context->action = Process_Node;

        #ifdef USE_PROGRESS_BAR
        new_context->total_entries = 0;
        new_context->total_progress = INT32_MAX;
        new_context->progress_per_object = 0;
        new_context->chain_ref = NULL;
        #endif

        return NULL;
    }
    else
    {
        return error( mb_malloc_failed );
    }
}


static int is_a_directory( search_handle handle, int objecttype )
{
    if ( objecttype == object_directory ||
            (objecttype == (object_directory | object_file) &&
             handle->partitions_as_directories) )
    {
            return Yes;
    }
    else
    {
            return No;
    }
}

/*
     Sets whether the search is recursive or not
*/
void recurse_search_context( search_handle handle, BOOL recursive )
{
    /*
            Make sure when changing to recursive that the children of this
            directory get returned
    */
    if ( !handle->recursive &&
         recursive &&
         is_a_directory( handle, objecttype_of_next_node( handle )) &&
         handle->action == Next_Leaf )
    {
            handle->action = Nest_Into_Directory;
    }

    handle->recursive = recursive != No;
}

/*
    Sets whether directories should be returned before their contents.
    This is relevant only when recursing.
*/
void return_directories_first( search_handle handle, BOOL directories_first )
{
    ((search_context *)handle)->directories_first = directories_first != No;
}

/*
    Sets whether directories should be returned after their contents.
    This is relevant only when recursing.
*/
void return_directories_last( search_handle handle, BOOL directories_last )
{
    handle->directories_last = directories_last != No;
}

/*
     Sets whether partitions should be treated the same as directories or not.
     This is relevant only when recursing.
*/
void treat_partitions_as_directories( search_handle handle, BOOL partitions_are_directories )
{
    handle->partitions_as_directories = partitions_are_directories;
}

/*
     Changes the directory in which the search will take place
*/
os_error *set_directory( search_handle handle, char *directory )
{
     search_context *context = (search_context *)handle;

     if ( context->directory )
     {
         overflowing_free( context->directory );
     }

     if ( ( context->directory = overflowing_malloc( strlen( directory ) + 1 )) != NULL )
     {
         strcpy( context->directory, directory );

         return NULL;
     }
     else
     {
         return error( mb_malloc_failed );
     }
}

/*
     frees the passed selection
*/
static void free_selection( file_selection *selection )
{
     overflowing_free( selection->selection_name );
     overflowing_free( selection );
}

/*
     Clears down a whole selection
*/
void clear_selection( search_handle handle )
{
     search_context *context = (search_context *)handle;
     file_selection *next_selection;
     file_selection *this_selection;

     /*
      Free the chain of selections
     */
     for ( this_selection = context->selection;
       this_selection != NULL;
       this_selection = next_selection )
     {
         next_selection = this_selection->next_file;
         free_selection( this_selection );
     }

     /*
      close off the head of the list
     */
     context->selection = NULL;
     context->last_selections_link = &context->selection;
}

/*
     Add a selection to an initialised search context. The search context
     will return found files in the order in which they were added.
*/
os_error *add_selection( search_handle handle, char *file_name, int wordlen )
{
     file_selection *new_selection;
     search_context *context = (search_context *)handle;

     /*
      These two if statements allocate the new selection structure and
      then some space for the file name. The mallocs are checked to
      work, and if they don't everything is tidied up and an error
      is returned.
     */
     new_selection = overflowing_malloc( sizeof( file_selection ));
     if ( new_selection != NULL )
     {
         new_selection->selection_name = overflowing_malloc( wordlen + 1 );
         if ( new_selection->selection_name != NULL )
         {
              /*
               Everything allocated OK, so copy the string and
               link the new selection onto the end of the list.
              */
              *context->last_selections_link = new_selection;
              strncpy( new_selection->selection_name, file_name, wordlen );
              new_selection->selection_name[ wordlen ] = '\0';
              context->last_selections_link = &new_selection->next_file;
              new_selection->next_file = NULL;

              debuglist(( "context: %x new selection: %s\n", context, new_selection->selection_name ));
              #ifdef USE_PROGRESS_BAR
              context->total_entries++;
              context->progress_per_object = context->total_progress / context->total_entries;
              #endif

              return NULL;
         }
         else
         {
              /*
               No room for selection name.
               Free up the selection structure and tidy up the ends
              */
              overflowing_free( new_selection );

              return error( mb_malloc_failed );
         }
     }
     else
     {
         return error( mb_malloc_failed );
     }
}

/*
     Free the abstract data type search_context. This is an equivalent
     to free(), but for this data type. It free all things hanging off it
     as well as the base structure.
*/
void dispose_search_context( search_handle handle )
{
     search_context *context = (search_context *)handle;
     search_nest_level *rover;
     search_nest_level *temp_rover;
     int i;

     /*
      Free the search nest level chain
     */
     rover = context->nested_filenames;

     while( rover != NULL )
     {
         temp_rover = rover;
         rover = rover->next_search_nest_level;
         for ( i = 0; i < Directory_Buffer_Size; i++ )
         {
              overflowing_free( temp_rover->directory_buffer[ i ].object_name );
         }
         overflowing_free( temp_rover );
     }

     clear_selection( handle );

     overflowing_free( context->directory );

     overflowing_free( context );
}

static int size_of_next_filename( search_context *context, search_nest_level *nesting )
{
     search_nest_level *nest_level = nesting;
     int returned_length = 0;

     if ( context->directory &&
      context->selection &&
      context->selection->selection_name )
     {
         returned_length = strlen( context->directory );

         /*
              Only Add one in if there's going to be a . in between dir and selection
         */
         if ( returned_length )
              returned_length++;

         returned_length += strlen( context->selection->selection_name );

         if ( context->recursive )
         {
              while (( nest_level != NULL ) && ( nest_level->next_entry_to_return >= 0 ) && ( nest_level->next_entry_to_return < nest_level->entries_in_buffer ))
              {
                  returned_length += 1 + strlen( nest_level->
                                                directory_buffer[ nest_level->next_entry_to_return ].
                                                object_name );
                  nest_level = nest_level->next_search_nest_level;
              }
         }
     }

     return returned_length;
}

/*
     Returns a pointer to the next filename in search_context

     This is a 'malloc'ed piece of memory, which should be 'free'ed when
     it is no longer needed.
*/
static os_error *next_filename( search_context *context, search_nest_level *nesting, char **hook_location )
{
     search_nest_level *nest_level = nesting;
     char *buffer = NULL;
     char *rover;
     int next_filename_size = size_of_next_filename( context, nesting );
     int part_length;

     if ( next_filename_size > 0 )
     {
         buffer = overflowing_malloc( next_filename_size + 1 );

         if ( buffer == NULL )
         {
              return error( mb_malloc_failed );
         }
     }

     if ( buffer != NULL )
     {
         if ( context->directory[0] )
         {
              sprintf( buffer, "%s.%s", context->directory, context->selection->selection_name );
         }
         else
         {
              sprintf( buffer, "%s", context->selection->selection_name );
         }

         rover = buffer + next_filename_size;

         *rover = '\0';

         while (( nest_level != NULL ) && ( nest_level->next_entry_to_return >= 0 ) && ( nest_level->next_entry_to_return < nest_level->entries_in_buffer ))
         {
              part_length = strlen( nest_level->
                directory_buffer[ nest_level->next_entry_to_return ].
                object_name );
              rover -= part_length + 1;

              rover[0] = '.';

              memcpy( &rover[1], nest_level->
                directory_buffer[ nest_level->next_entry_to_return ].
                object_name, part_length );

              nest_level = nest_level->next_search_nest_level;
         }
     }

     *hook_location = buffer;

     return NULL;
}

os_error *next_nodename( search_handle handle, char **hook_location )
{
     search_context *context = (search_context *)handle;
     return next_filename( context, context->nested_filenames, hook_location );
}

os_error *selection_summary( search_handle handle, char **summary )
{
    search_context *context = (search_context *)handle;
    char *cont;

    if ( context->selection == NULL )
    {
        cont = msgs_lookup("93"); /* 'nothing' */
    }
    else if ( context->selection->next_file == NULL )
    {
        cont = context->selection->selection_name;
    }
    else
    {
        cont = msgs_lookup("92"); /* 'many' */
    }

    *summary = overflowing_malloc( strlen( context->directory ) + 1 + strlen( cont ) + 1 );

    if ( *summary == NULL )
        return error( mb_malloc_failed );

    sprintf( *summary, "%s.%s", context->directory, cont );

    return NULL;
}

/*
     Finds the degree by which mstring matches the current next node.
     It returns the next mismatching position, and other information
     concerning where the mismatch occured
*/
static char *first_position_not_matched( search_handle handle, search_nest_level *nl, char *mstring,
     search_nest_level **deepest_match, search_nest_level **shallowest_non_match )
{
     char *matched_position;
     char *ms;
     int dl;
     int sl;

     if ( nl == NULL )
     {
         matched_position = mstring;

         dl = strlen( handle->directory );

         if ( strncmp( handle->directory, matched_position, dl ) != 0 )
              return NULL;

         matched_position += dl;

         if ( *matched_position != '.' )
              return NULL;

         matched_position += 1;

         sl = strlen( handle->selection->selection_name );

         if ( strncmp( handle->selection->selection_name, matched_position, sl ) != 0 )
              return NULL;

         matched_position += sl;

         return matched_position;
     }
     else
     {
         matched_position = first_position_not_matched( handle, nl->next_search_nest_level, mstring,
              deepest_match, shallowest_non_match );

         if ( matched_position == NULL )
              return NULL;

         ms = nl->directory_buffer[ nl->next_entry_to_return ].object_name;
         sl = strlen( ms );

         if ( *matched_position == '.' &&
              strncmp( matched_position + 1, ms, sl ) == 0 )
         {
              matched_position += 1 + sl;

              *deepest_match = nl;
         }
         else
         {
              if ( nl->next_search_nest_level == *deepest_match )
              {
                  *shallowest_non_match = nl;
              }
         }

         return matched_position;
     }
}

/*
    Informs that next node has been deleted
*/
void deleted_next_node( search_handle handle, char *deleted_node )
{
    if ( handle->nested_filenames && handle->selection )
    {
        char *matched_position;
        search_nest_level *deepest_match = NULL;
        search_nest_level *shallowest_non_match = NULL;

        matched_position = first_position_not_matched( handle, handle->nested_filenames, deleted_node, &deepest_match, &shallowest_non_match );

        if ( matched_position != NULL )
        {
            /*
             Deleted node is before something in shallowest non-match
            */
            if ( matched_position == strrchr( deleted_node, '.' ) &&
                 shallowest_non_match != NULL )
            {
                    shallowest_non_match->offset_to_next_item--;
            }

            /*
             Deleted is current node or a parent of it (gulp!)
            */
            if ( *matched_position == '\0' &&
                 deepest_match != NULL )
            {
                    deepest_match->offset_to_next_item--;
            }
        }
    }
}

/*
     Read the parameters for the next node, don't update
     if an error occurs
*/
void read_next_node_parameters( search_handle handle )
{
    os_filestr fileplace;
    char *filename;
    os_error *err;

    err = next_nodename( handle, &filename );

    if ( err || filename == NULL )
            return;

    fileplace.action = OSFile_ReadInfo;
    fileplace.name = filename;

    err = os_file( &fileplace );

    if ( err )
            return;

    handle->selections_size       = fileplace.start;
    handle->selections_loadaddr   = fileplace.loadaddr;
    handle->selections_execaddr   = fileplace.execaddr;
    handle->selections_attributes = fileplace.end;
}

typedef enum {
  the_size, the_load_address, the_execute_address, the_attributes, the_type, the_name
  #ifdef USE_PROGRESS_BAR
  , the_progress, the_ref_ptr
  #endif
} which_thing;

/*
    Returns one of the values associated with the next node.
    If the node doesn't exist the value not_found is returned.
*/
static int thing_of_next_node( search_handle handle, which_thing thing, int not_found )
{
    search_context *context = (search_context *)handle;
    search_nest_level *nf;

    if ( context->selection )
    {
        if ( (nf = context->nested_filenames) == NULL )
        {
            switch( thing )
            {
            case the_size:
                return (int) context->selections_size;
            case the_load_address:
                return context->selections_loadaddr;
            case the_execute_address:
                return context->selections_execaddr;
            case the_attributes:
                return context->selections_attributes;
            case the_type:
                return context->selections_objecttype;
            case the_name:
                return (int) context->selection->selection_name;

            #ifdef USE_PROGRESS_BAR
            case the_progress:
                if (context->selections_objecttype == object_directory)
                {
                    debuglist(( "ponn: selection: %08x\n", 0 ));
                    return 0;
                }
                else
                {
                    debuglist(( "ponn: selection: %08x\n", context->progress_per_object ));
                    return context->progress_per_object;
                }

            case the_ref_ptr:
                return (int) &context->chain_ref;
            #endif

            } /* end switch */
        }
        else
        {
            directory_buffer_entry *d;

            d = nf->directory_buffer + nf->next_entry_to_return;

            switch( thing )
            {
            case the_size:
                return (int) d->length;
            case the_load_address:
                return d->load_address;
            case the_execute_address:
                return d->execution_address;
            case the_attributes:
                return d->attributes;
            case the_type:
                return d->object_type;
            case the_name:
                return (int) d->object_name;

            #ifdef USE_PROGRESS_BAR
            case the_progress:
                if (d->object_type == object_directory)
                {
                    debuglist(( "ponn: nested: %08x\n", 0 ));
                    return 0;
                }
                else
                {
                    debuglist(( "ponn: nested: %08x\n", nf->progress_per_object ));
                    return nf->progress_per_object;
                }

            case the_ref_ptr:
                return (int) &d->chain_ref;
            #endif

            }
        }
    }

    debuglist(( "tonn: not found\n" ));

    return not_found;
}

uint32_t size_of_next_node( search_handle handle )
{
    return (uint32_t)thing_of_next_node( handle, the_size, 0 );
}

int reload_of_next_node( search_handle handle )
{
    return thing_of_next_node( handle, the_load_address, -1 );
}

int execute_of_next_node( search_handle handle )
{
    return thing_of_next_node( handle, the_execute_address, -1 );
}

int attributes_of_next_node( search_handle handle )
{
    return thing_of_next_node( handle, the_attributes, -1 );
}

int objecttype_of_next_node( search_handle handle )
{
    return thing_of_next_node( handle, the_type, object_nothing );
}

char *name_of_next_node( search_handle handle )
{
    return (char *)thing_of_next_node( handle, the_name, NULL );
}

#ifdef USE_PROGRESS_BAR
uint32_t progress_of_next_node( search_handle handle )
{
    return (uint32_t)thing_of_next_node( handle, the_progress, 0 );
}


void **chain_ref_ptr_of_next_node( search_handle handle )
{
    return (void **)thing_of_next_node( handle, the_ref_ptr, NULL );
}
#endif

/*
    Assuming a directory has just been found, return whether this return
    of this directory was before or after its contents.
*/
BOOL directory_is_after_contents( search_handle handle )
{
    search_context *context = (search_context *)handle;

    return context->action == Next_Leaf;
}

/*
     Returns 0 if no more nodes
     Returns non-0 if more nodes
*/
BOOL another_node( search_handle handle )
{
    return ((search_context *)handle)->selection != NULL;
}

/*
    When finding a selection fails call this to skip it.
*/
void skip_failed_selection( search_handle handle )
{
    search_context *context = (search_context *)handle;

    switch ( context->action )
    {
    case Next_Leaf:
        /*
        Can't generate an error in this state
        */
        break;

    case Process_Node:
        context->action = Next_Leaf;
        break;

    case Read_Next_Cache_Full:
        /*
        This forces un-nesting then continuing at the upper level
        */
        context->nested_filenames->offset_to_next_item = -1;
        break;

    case Nest_Into_Directory:
        context->action = Next_Leaf;
        break;
    }
}

void skip_list_file( search_handle handle )
{
    search_context *context = (search_context *)handle;

    context->action = Next_Leaf;
}

os_error *step_to_next_node( search_handle handle, uint32_t *progress )
{
    search_context *context = (search_context *)handle;
    search_nest_level *temp_context;
    os_gbpbstr gbpbplace;
    os_filestr fileplace;
    char temp_directory_buffer[ Temp_DirBuffer_Size ];
    int i;
    int pos;
    BOOL resolved = No;
    os_error *err = NULL;
    file_selection *next_selection;
    int objecttype;

    debuglist(( "\nstep_to_next_node\n" ));

    /*
        While the answer hasn't resolved itself and there's no error
        then try the next step of resolving the answer
    */
    while( !resolved && !err )
    {
        switch( context->action )
        {
        case Next_Leaf:
            /*
                Step to the next leaf at this nesting level
            */
            debuglist(( "Next_Leaf " ));
            if ( context->nested_filenames == NULL )
            {
                /*
                    Get next selection
                */
                next_selection = context->selection->next_file;
                free_selection( context->selection );
                context->selection = next_selection;

                debuglist(( "get next selection" ));

                context->action = Process_Node;
            }
            else
            {
                /*
                    Get next cached entry
                */
                context->nested_filenames->next_entry_to_return++;
                if ( context->nested_filenames->next_entry_to_return >=
                 context->nested_filenames->entries_in_buffer )
                {
                    /*
                        We've run out of cached entries
                    */
                    debuglist(( "cache empty " ));
                    context->action = Read_Next_Cache_Full;
                }
                else
                {
                    /*
                        Found an entry in the cache, so let's
                        process it
                    */
                    debuglist(( "cache ok " ));
                    context->action = Process_Node;
                }
            }
            break;

        case Process_Node:
            /*
                Process the node as supplied by Next_Leaf
            */
            debuglist(( "Process_Node " ));
            if ( context->selection == NULL )
            {
                /*
                    No more entries in the selection, so we've
                    resolved what happens next
                */
                debuglist(( "resolved all " ));
                resolved = Yes;
            }
            else
            {
                /*
                    Get type of node if needed
                */
                debuglist(( "%s ", name_of_next_node( context ) ));
                if ( context->nested_filenames == NULL )
                {
                    fileplace.action = OSFile_ReadNoPath;
                    err = next_filename( context, context->nested_filenames, &fileplace.name );
                    debuglist(( "%s ", fileplace.name ));

                    if ( err )
                    {
                        debuglist(( "err\n" ));
                        continue;
                    }

                    err = os_file( &fileplace );

                    if ( err )
                    {
                        overflowing_free( fileplace.name );
                        debuglist(( " error\n" ));
                        continue;
                    }

                    /*
                        Didn't find a selection - generate an error.
                    */
                    if ( fileplace.action == object_nothing )
                    {
                        fileplace.loadaddr = fileplace.action;
                        fileplace.action = OSFile_MakeError;
                        err = os_file( &fileplace );
                        overflowing_free( fileplace.name );
                        debuglist(( " not found\n" ));
                        continue;
                    }

                    overflowing_free( fileplace.name );

                    context->selections_objecttype = fileplace.action;
                    context->selections_size = fileplace.start;
                    context->selections_loadaddr = fileplace.loadaddr;
                    context->selections_execaddr = fileplace.execaddr;
                    context->selections_attributes = fileplace.end;
                } /* end if (nested_filenames == NULL) */

                objecttype = objecttype_of_next_node( (search_handle)context );

                if ( objecttype == object_nothing )
                {
                    /*
                        Didn't find that, so go around
                        for another time - nothing to do here
                    */
                    debuglist(( "not found " ));

                    context->action = Next_Leaf;
                }
                else if ( context->recursive &&
                      is_a_directory( context, objecttype ) )
                {
                    /*
                        If we are returning directories first, then
                        we have resolved it at this level
                    */
                    debuglist(( "directory " ));
                    resolved = context->directories_first;

                    context->action = Nest_Into_Directory;
                }
                else
                {
                    /*
                        Found a file or we found a directory
                        when not recursing, in which case
                        we've found something worth while and
                        so we've resolved things.
                    */
                    resolved = Yes;
                    context->action = Next_Leaf;
                    debuglist(( "resolved " ));

                }
            }
            break;

        case Read_Next_Cache_Full:
            /*
                If run out of entries in this directory
            */
            debuglist(( "Read_Next_Cache_Full " ));
            if ( context->nested_filenames->offset_to_next_item == -1 )
            {
                #ifdef USE_PROGRESS_BAR
                search_nest_level *nf = context->nested_filenames;
                int p = 0;

                /*
                   Compensate for rounding errors by adding the 'spare' progress
                   Isn't totally accurate if copying, as the actual progress values
                   used will have been halved.
                */
                p = nf->total_progress - (nf->total_entries * nf->progress_per_object);
                if (p > 0) *progress += (uint32_t)p;
                debuglist(( "finished %d entries (total %08x) extra progress +%08x", nf->total_entries, nf->total_progress, p ));
                #else
                IGNORE(progress);
                #endif

                /*
                    Down down one level
                */
                temp_context = context->nested_filenames->next_search_nest_level;
                for ( i = 0; i < Directory_Buffer_Size; i++ )
                {
                    overflowing_free( context->nested_filenames->directory_buffer[ i ].object_name );
                }
                overflowing_free( context->nested_filenames );
                context->nested_filenames = temp_context;

                /*
                    Return the directory after all the files in it
                */
                resolved = context->directories_last;

                context->action = Next_Leaf;
            }
            else
            {
                char **filename_store;
                search_nest_level *nf = context->nested_filenames;

                /*
                    Read more of this directory
                */
                gbpbplace.action      = OSGBPB_ReadDirEntriesInfo;

                err = next_filename( context, nf->next_search_nest_level, (char **)&gbpbplace.file_handle );

                if ( err )
                    continue;

                debuglist(( "%s ", (char *)gbpbplace.file_handle ));


                #ifdef USE_PROGRESS_BAR
                if (!nf->counted)
                {
                    nf->total_entries = count_objects_in_dir( (char *)gbpbplace.file_handle );
                    nf->counted = Yes;
                    if (nf->total_entries != 0)
                    {
                        nf->progress_per_object = nf->total_progress / nf->total_entries;
                    }
                    else
                    {
                        void *ref;

                        /*
                           Modify progress values so that half the progress for the dir is
                           added when the dir is finished (in the rounding process above)
                           and the other half when written. We have to do this now as when
                           the dir was added to the chain, we didn't know it was empty.
                           Of course if the dir is not in the chain, we are not copying, and
                           so we add all the progress for this dir at once.
                        */

                        if (nf->next_search_nest_level == NULL)
                        {
                            /* top level */
                            ref = context->chain_ref;
                        }
                        else
                        {
                            int i = nf->next_search_nest_level->next_entry_to_return;
                            ref = nf->next_search_nest_level->directory_buffer[i].chain_ref;
                        }

                        if (ref != NULL)
                        {
                            nf->total_progress /= 2;
                            nf->progress_per_object = 0;
                            modify_chain_file_progress(ref, nf->total_progress);
                        }

                    } /* end if (total_entries > 0) */

                    debuglist(( "%d entries %08x total progress %08x per object ", nf->total_entries, nf->total_progress, nf->progress_per_object ));

                } /* end if (!counted) */

                #endif

                gbpbplace.data_addr   = &temp_directory_buffer;
                gbpbplace.number      = Directory_Buffer_Size;
                gbpbplace.seq_point   = context->nested_filenames->offset_to_next_item;
                gbpbplace.buf_len     = Temp_DirBuffer_Size;
                gbpbplace.wild_fld    = "*";

                err = os_gbpb( &gbpbplace );
                overflowing_free( (void *)gbpbplace.file_handle );

                if ( err )
                {
                    if ( (err->errnum & FileError_Mask) == ErrorNumber_NotFound )
                    {
                        /*
                                Cancel the error
                        */
                        err = NULL;

                        /*
                             Down down one level
                        */
                        temp_context = context->nested_filenames->next_search_nest_level;
                        for ( i = 0; i < Directory_Buffer_Size; i++ )
                        {
                                overflowing_free( context->nested_filenames->directory_buffer[ i ].object_name );
                        }
                        overflowing_free( context->nested_filenames );
                        context->nested_filenames = temp_context;

                        /*
                                Don't return the directory, as it
                                doesn't exist!
                        */

                        context->action = Next_Leaf;
                    }

                    continue;
                }

                for ( i = 0, pos = 0; i < gbpbplace.number; i++ )
                {
                    context->nested_filenames->directory_buffer[ i ].load_address      = *(int *)&temp_directory_buffer[ pos ];
                    pos += sizeof(int);
                    context->nested_filenames->directory_buffer[ i ].execution_address = *(int *)&temp_directory_buffer[ pos ];
                    pos += sizeof(int);
                    context->nested_filenames->directory_buffer[ i ].length            = *(uint32_t *)&temp_directory_buffer[ pos ];
                    pos += sizeof(uint32_t);
                    context->nested_filenames->directory_buffer[ i ].attributes        = *(int *)&temp_directory_buffer[ pos ];
                    pos += sizeof(int);
                    context->nested_filenames->directory_buffer[ i ].object_type       = *(int *)&temp_directory_buffer[ pos ];
                    pos += sizeof(int);

                    /*
                        Free the filename if there's one there
                    */
                    filename_store = &context->nested_filenames->directory_buffer[ i ].object_name;
                    if ( *filename_store )
                    {
                        overflowing_free ( *filename_store );
                        *filename_store = NULL;
                    }

                    /*
                        Allocate some space for the file name
                    */
                    if ( ( *filename_store = overflowing_malloc( strlen( &temp_directory_buffer[ pos ] ) + 1 ) ) == NULL )
                    {
                        /*
                                If the allocation failed, free everything up
                        */
                        int j;

                        for ( j = 0; j < i; j++ )
                        {
                                overflowing_free( context->nested_filenames->directory_buffer[ j ].object_name );
                                context->nested_filenames->directory_buffer[ j ].object_name = NULL;
                        }

                        err = error( mb_malloc_failed );

                        break;
                    }

                    strcpy( *filename_store, &temp_directory_buffer[ pos ] );

                    pos += strlen( &temp_directory_buffer[ pos ] ) + 1;

                    /* round pos up to a word boundary */
                    pos = (( pos + 3 ) / 4 ) * 4;
                }

                if ( err )
                    break;

                context->nested_filenames->offset_to_next_item = gbpbplace.seq_point;
                context->nested_filenames->entries_in_buffer = gbpbplace.number;
                context->nested_filenames->next_entry_to_return = -1;

                context->action = Next_Leaf;
            }
        break;

        case Nest_Into_Directory:
            /*
                Go down into the next nesting level
            */
            debuglist(( "Nest_Into_Directory " ));

            temp_context = context->nested_filenames;

            context->nested_filenames = overflowing_malloc( sizeof( search_nest_level ));
            if ( context->nested_filenames == NULL )
            {
                context->nested_filenames = temp_context;
                err = error( mb_malloc_failed );
                continue;
            }

            context->nested_filenames->next_search_nest_level = temp_context;
            context->nested_filenames->offset_to_next_item = 0;
            context->nested_filenames->entries_in_buffer = 0;
            context->nested_filenames->next_entry_to_return = -1;

            #ifdef USE_PROGRESS_BAR
            if (temp_context != NULL)
            {
              context->nested_filenames->total_progress = temp_context->progress_per_object;
            }
            else
            {
              context->nested_filenames->total_progress = context->progress_per_object;
            }
            /* Default values, will be overwitten if this object is a dir */
            context->nested_filenames->progress_per_object = 0;
            context->nested_filenames->total_entries = 0;
            context->nested_filenames->counted = No;
            #endif

            for ( i = 0; i < Directory_Buffer_Size; i++ )
            {
                context->nested_filenames->directory_buffer[ i ].object_name = NULL;
                #ifdef USE_PROGRESS_BAR
                context->nested_filenames->directory_buffer[ i ].chain_ref = NULL;
                #endif
            }

            context->action = Next_Leaf;

            break;

        default:  /* disaster!!!!! */
            err = error( mb_unexpected_state );
            break;
        } /* end switch */

        debuglist(( "\n" ));

    } /* end while */

    return err;
}


#ifdef USE_PROGRESS_BAR
void listfiles_convert_to_copymove( search_handle handle )
{
  search_context *context = (search_context *)handle;

  if (context == NULL) return;

  context->total_progress /= 2;
}
#endif
@


4.11
log
@Fix null pointer dereference when continuing after some errors
Detail:
  c/listfiles - If the first call to enumerate the contents of a directory fails (e.g. when trying to step into a bad image file), next_entry_to_return will be left at a value >= entries_in_buffer. This doesn't impact the operation of the state machine, but it will cause a null/bad pointer dereference in the user interface code when switch_buttons() calls read_next_node_parameters() and the code attempts to construct the path name of the current object. Fix the issue by terminating the path if an invalid cache entry index is found.
Admin:
  Tested on Iyonix with zero page relocation


Version 0.61. Tagged as 'FilerAct-0_61'
@
text
@d680 1
a680 1
    if ( err )
@


4.10
log
@Fixed flicker when Filer Action window is behind another window.

Version 0.56. Not tagged
@
text
@d456 1
a456 1
              while ( nest_level != NULL )
d508 1
a508 1
         while ( nest_level != NULL )
@


4.9
log
@Fix to work with files > 2G.
A good rake over the code to change filesizes to be uint32_t not ints.
Change makefile to use StdTools.
Shuffle icon clipping in the templates to allow for maximal numbers by moving the text a bit to the right, still fits even in system font.
A couple more ints swapped for BOOLs.
The memmanage code is largely unchanged and makes extensive use of signed numbers, partly because the wimpslot setting API does. This will all fall over in a big mess if the wimpslot ever gets >2G, but then the API would need changing for that to happen anyway.
Function count_objects_in_dir swapped to use os_gbpb.
Structure search_nest_level gains a 'counted' flag rather than signalling counting is needed by setting the filesize to -1.
Should now be good for up to 4 billion files each of 4 billion bytes.

Version 0.54. Tagged as 'FilerAct-0_54'
@
text
@d144 1
a144 1
   
d169 1
a169 1
       
d175 1
a175 1
            debuglist(( "count_objects_in_dir: %s\n", e->errmess ));
d179 1
a179 1
   
d299 1
a299 1
   
d374 1
a374 1
   
d380 1
a380 1
   
d390 1
a390 1
   
d445 1
a445 1
   
d451 1
a451 1
   
d453 1
a453 1
   
d486 1
a486 1
   
d503 1
a503 1
   
d505 1
a505 1
   
d507 1
a507 1
   
d514 1
a514 1
   
d516 1
a516 1
   
d520 1
a520 1
   
d580 1
a580 1
   
d582 1
a582 1
   
d585 1
a585 1
   
d587 1
a587 1
   
d590 1
a590 1
   
d592 1
a592 1
   
d594 1
a594 1
   
d597 1
a597 1
   
d599 1
a599 1
   
d606 1
a606 1
   
d609 1
a609 1
   
d612 1
a612 1
   
d617 1
a617 1
   
d627 1
a627 1
   
d655 1
a655 1
    
d924 1
a924 1
        case Next_Leaf: 
d937 1
a937 1
    
d939 1
a939 1
    
d994 1
a994 1
    
d1000 1
a1000 1
    
d1002 1
a1002 1
    
d1009 1
a1009 1
    
d1022 1
a1022 1
    
d1024 1
a1024 1
    
d1031 1
a1031 1
    
d1033 1
a1033 1
    
d1041 1
a1041 1
    
d1053 1
a1053 1
    
d1067 1
a1067 1
    
d1094 1
a1094 1
    
d1105 1
a1105 1
    
d1110 1
a1110 1
    
d1117 1
a1117 1
    
d1122 1
a1122 1
    
d1124 1
a1124 1
    
d1127 1
a1127 1
    
d1129 2
a1130 2
    
    
d1143 1
a1143 1
                        
d1152 1
a1152 1
                        
d1163 1
a1163 1
                        
d1170 1
a1170 1
    
d1172 1
a1172 1
    
d1174 1
a1174 1
    
d1176 1
a1176 1
    
d1178 1
a1178 1
    
d1184 1
a1184 1
    
d1187 1
a1187 1
    
d1196 1
a1196 1
    
d1207 1
a1207 1
    
d1212 1
a1212 1
    
d1215 1
a1215 1
    
d1218 1
a1218 1
    
d1231 1
a1231 1
    
d1241 1
a1241 1
    
d1251 1
a1251 1
    
d1257 1
a1257 1
    
d1259 1
a1259 1
    
d1262 1
a1262 1
    
d1264 1
a1264 1
    
d1266 1
a1266 1
    
d1270 1
a1270 1
    
d1273 1
a1273 1
    
d1277 1
a1277 1
    
d1287 1
a1287 1
    
d1289 1
a1289 1
    
d1297 1
a1297 1
    
d1302 1
a1302 1
    
d1317 1
a1317 1
    
d1325 1
a1325 1
    
d1327 1
a1327 1
    
@


4.8
log
@Swap magic constants for defines from headers.
OS_FSControl, OS_File, OS_GBPB, OS_Args, OS_Find now use HighFSI.h.
Indentation made more consistent.
Variety of DEBUG macros changed to allow them to be enabled and disabled on a per-file basis.
Put USE_RED_ERROR box switch into options.h (undefined though).
Functionally equivalent to 0.52, but lots of diffs.

Version 0.53. Tagged as 'FilerAct-0_53'
@
text
@d63 6
a68 6
     int  load_address;
     int  execution_address;
     int  length;
     int  attributes;
     int  object_type;
     char *object_name;
d71 1
a71 1
     void *chain_ref;
d79 3
a81 3
     int  offset_to_next_item;
     int  entries_in_buffer;
     int  next_entry_to_return;
d85 4
a88 3
     int total_entries;
     int total_progress;
     int progress_per_object;
d112 14
a125 14
    search_nest_level       *nested_filenames;
    char                    *directory;
    file_selection          *selection;
    file_selection          **last_selections_link;
    next_leaf_state         action;
    unsigned int            selections_size;
    unsigned int            selections_loadaddr;
    unsigned int            selections_execaddr;
    unsigned int            selections_attributes;
    unsigned int            selections_objecttype;
    unsigned int            recursive:1;
    unsigned int            directories_first:1;
    unsigned int            directories_last:1;
    unsigned int            partitions_as_directories:1;
d128 4
a131 4
    int total_entries;
    int total_progress;
    int progress_per_object;
    void *chain_ref;
d137 1
a137 2
#include "swis.h"
static int count_objects_in_dir( char *dir )
d139 5
a143 3
    os_error *e;
    char      buff[Temp_DirBuffer_Size];
    int       chunk = 256, context = 0, c, num = 0, total = 0;
d147 12
a158 2
        if ((e = _swix(OS_GBPB, _INR(0,6) | _OUTR(3,4), OSGBPB_ReadDirEntries,
                       dir, buff, chunk, context, Temp_DirBuffer_Size, 0, &num, &c)) == NULL)
d708 1
a708 1
static unsigned int thing_of_next_node( search_handle handle, which_thing thing, int not_found )
d716 1
a716 1
            {
d720 1
a720 1
                    return context->selections_size;
d722 1
a722 1
                    return context->selections_loadaddr;
d724 1
a724 1
                    return context->selections_execaddr;
d726 1
a726 1
                    return context->selections_attributes;
d728 1
a728 1
                    return context->selections_objecttype;
d730 1
a730 1
                    return (int)context->selection->selection_name;
d734 10
a743 9
              if (context->selections_objecttype == object_directory)
              {
                debuglist(( "ponn: selection: %08x\n", 0 ));
                return 0;
              } else
              {
                debuglist(( "ponn: selection: %08x\n", context->progress_per_object ));
                return context->progress_per_object;
              }
d746 1
a746 1
                return (unsigned int) &context->chain_ref;
d760 1
a760 1
                    return d->length;
d762 1
a762 1
                    return d->load_address;
d764 1
a764 1
                    return d->execution_address;
d766 1
a766 1
                    return d->attributes;
d768 1
a768 1
                    return d->object_type;
d770 1
a770 1
                    return (int) d->object_name;
d774 10
a783 10
              if (d->object_type == object_directory)
              {
                debuglist(( "ponn: nested: %08x\n", 0 ));
                return 0;
              }
              else
              {
                debuglist(( "ponn: nested: %08x\n", nf->progress_per_object ));
                return nf->progress_per_object;
              }
d798 1
a798 1
unsigned int size_of_next_node( search_handle handle )
d800 1
a800 1
    return thing_of_next_node( handle, the_size, -1 );
d803 1
a803 1
unsigned int reload_of_next_node( search_handle handle )
d808 1
a808 1
unsigned int execute_of_next_node( search_handle handle )
d813 1
a813 1
unsigned int attributes_of_next_node( search_handle handle )
d818 1
a818 1
unsigned int objecttype_of_next_node( search_handle handle )
a827 1

d829 1
a829 1
unsigned int progress_of_next_node( search_handle handle )
d831 1
a831 1
    return thing_of_next_node( handle, the_progress, 0 );
d835 1
a835 1
unsigned int chain_ref_ptr_of_next_node( search_handle handle )
d837 1
a837 1
    return thing_of_next_node( handle, the_ref_ptr, 0 );
a840 1

d845 1
a845 1
unsigned int directory_is_after_contents( search_handle handle )
d856 1
a856 1
unsigned int another_node( search_handle handle )
d900 1
a900 1
os_error *step_to_next_node( search_handle handle, unsigned int *progress )
d1089 1
a1089 1
                if (p > 0) *progress += p;
d1116 1
d1123 1
a1123 1
                err = next_filename( context, context->nested_filenames->next_search_nest_level, (char **)&gbpbplace.file_handle );
d1132 1
a1132 3
                search_nest_level *nf = context->nested_filenames;
    
                if (nf->total_entries == -1)
d1134 3
a1136 3
                    nf->total_entries = count_objects_in_dir((char *)gbpbplace.file_handle);
    
                    if (nf->total_entries > 0)
d1155 1
a1155 1
                            /* top level        */
d1175 1
a1175 1
                } /* end if (total_entries == -1) */
d1225 2
a1226 2
                    context->nested_filenames->directory_buffer[ i ].length            = *(int *)&temp_directory_buffer[ pos ];
                    pos += sizeof(int);
d1314 2
a1315 1
            context->nested_filenames->total_entries = -1;
@


4.7
log
@More BOOLs and things changed to C99 types.
Basically the same as version 0.51 otherwise.

Version 0.52. Tagged as 'FilerAct-0_52'
@
text
@d34 3
a36 1
#define debuglist
d44 2
a45 1
#ifndef __os_h
a46 1
#endif
a54 1

d59 1
a59 2
#define Temp_DirBuffer_Size 640
#define Directory_File_Type 2
d95 1
a95 1
     char *selection_name;
a134 1

a136 1
#define SIZE 2048
d140 1
a140 1
    char      buff[SIZE];
d145 2
a146 1
        if ((e = _swix(OS_GBPB, _INR(0,6) | _OUTR(3,4), 9, dir, buff, chunk, context, SIZE, 0, &num, &c)) == NULL)
d150 6
a155 6
              /*
                 Broken archives cause context to never be updated ... not sure why
                 the SWI does not return an error.
              */
              DEBUG(("count_objects_in_dir: aborting\n"));
              return 0;
d163 1
a163 1
            DEBUG(("count_objects_in_dir: %s\n", e->errmess));
a169 1
#undef SIZE
a171 1

d197 1
a197 1
        new_context->total_progress = PROGRESS_MAX;
d213 2
a214 2
    if ( objecttype == ObjectType_Directory ||
            (objecttype == (ObjectType_Directory | ObjectType_File) &&
d281 1
a281 1
      overflowing_free( context->directory );
d286 3
a288 3
      strcpy( context->directory, directory );

      return NULL;
d292 1
a292 1
      return error( mb_malloc_failed );
d321 2
a322 2
      next_selection = this_selection->next_file;
      free_selection( this_selection );
d350 31
a380 31
      new_selection->selection_name = overflowing_malloc( wordlen + 1 );
      if ( new_selection->selection_name != NULL )
      {
           /*
        Everything allocated OK, so copy the string and
        link the new selection onto the end of the list.
           */
           *context->last_selections_link = new_selection;
           strncpy( new_selection->selection_name, file_name, wordlen );
           new_selection->selection_name[ wordlen ] = '\0';
           context->last_selections_link = &new_selection->next_file;
           new_selection->next_file = NULL;

           DEBUG(("context: %x new selection: %s\n", context, new_selection->selection_name));
           #ifdef USE_PROGRESS_BAR
           context->total_entries++;
           context->progress_per_object = context->total_progress / context->total_entries;
           #endif

           return NULL;
      }
      else
      {
           /*
        No room for selection name.
        Free up the selection structure and tidy up the ends
           */
           overflowing_free( new_selection );

           return error( mb_malloc_failed );
      }
d384 1
a384 1
      return error( mb_malloc_failed );
d407 7
a413 7
      temp_rover = rover;
      rover = rover->next_search_nest_level;
      for ( i = 0; i < Directory_Buffer_Size; i++ )
      {
           overflowing_free( temp_rover->directory_buffer[ i ].object_name );
      }
      overflowing_free( temp_rover );
d432 20
a451 20
      returned_length = strlen( context->directory );

      /*
           Only Add one in if there's going to be a . in between dir and selection
      */
      if ( returned_length )
           returned_length++;

      returned_length += strlen( context->selection->selection_name );

      if ( context->recursive )
      {
           while ( nest_level != NULL )
           {
               returned_length += 1 + strlen( nest_level->
                                             directory_buffer[ nest_level->next_entry_to_return ].
                                             object_name );
               nest_level = nest_level->next_search_nest_level;
           }
      }
d473 6
a478 6
      buffer = overflowing_malloc( next_filename_size + 1 );

      if ( buffer == NULL )
      {
           return error( mb_malloc_failed );
      }
d483 28
a510 28
      if ( context->directory[0] )
      {
           sprintf( buffer, "%s.%s", context->directory, context->selection->selection_name );
      }
      else
      {
           sprintf( buffer, "%s", context->selection->selection_name );
      }

      rover = buffer + next_filename_size;

      *rover = '\0';

      while ( nest_level != NULL )
      {
           part_length = strlen( nest_level->
             directory_buffer[ nest_level->next_entry_to_return ].
             object_name );
           rover -= part_length + 1;

           rover[0] = '.';

           memcpy( &rover[1], nest_level->
             directory_buffer[ nest_level->next_entry_to_return ].
             object_name, part_length );

           nest_level = nest_level->next_search_nest_level;
      }
d531 1
a531 1
            cont = msgs_lookup("93"); /* 'nothing' */
d535 1
a535 1
            cont = context->selection->selection_name;
d539 1
a539 1
            cont = msgs_lookup("92"); /* 'many' */
d545 1
a545 1
            return error( mb_malloc_failed );
d567 22
a588 22
      matched_position = mstring;

      dl = strlen( handle->directory );

      if ( strncmp( handle->directory, matched_position, dl ) != 0 )
           return NULL;

      matched_position += dl;

      if ( *matched_position != '.' )
           return NULL;

      matched_position += 1;

      sl = strlen( handle->selection->selection_name );

      if ( strncmp( handle->selection->selection_name, matched_position, sl ) != 0 )
           return NULL;

      matched_position += sl;

      return matched_position;
d592 25
a616 25
      matched_position = first_position_not_matched( handle, nl->next_search_nest_level, mstring,
           deepest_match, shallowest_non_match );

      if ( matched_position == NULL )
           return NULL;

      ms = nl->directory_buffer[ nl->next_entry_to_return ].object_name;
      sl = strlen( ms );

      if ( *matched_position == '.' &&
           strncmp( matched_position + 1, ms, sl ) == 0 )
      {
           matched_position += 1 + sl;

           *deepest_match = nl;
      }
      else
      {
           if ( nl->next_search_nest_level == *deepest_match )
           {
        *shallowest_non_match = nl;
           }
      }

      return matched_position;
d627 3
a629 3
            char *matched_position;
            search_nest_level *deepest_match = NULL;
            search_nest_level *shallowest_non_match = NULL;
d631 1
a631 1
            matched_position = first_position_not_matched( handle, handle->nested_filenames, deleted_node, &deepest_match, &shallowest_non_match );
d633 2
a634 2
            if ( matched_position != NULL )
            {
d636 1
a636 1
            Deleted node is before something in shallowest non-match
d643 1
a643 1

d645 1
a645 1
                    Deleted is current node or a parent of it (gulp!)
d652 1
a652 1
            }
d671 1
a671 1
    fileplace.action = 5; /* read catalogue information */
d722 1
a722 1
              if (context->selections_objecttype == ObjectType_Directory)
d724 1
a724 1
                DEBUG(("ponn: selection: %08x\n", 0));
d728 1
a728 1
                DEBUG(("ponn: selection: %08x\n", context->progress_per_object));
d761 1
a761 1
              if (d->object_type == ObjectType_Directory)
d763 1
a763 1
                DEBUG(("ponn: nested: %08x\n", 0));
d768 1
a768 1
                DEBUG(("ponn: nested: %08x\n", nf->progress_per_object));
d780 1
a780 1
    DEBUG(("tonn: not found\n"));
d807 1
a807 1
    return thing_of_next_node( handle, the_type, ObjectType_NotFound );
d860 4
a863 4
            /*
            Can't generate an error in this state
            */
            break;
d866 2
a867 2
            context->action = Next_Leaf;
            break;
d870 5
a874 5
            /*
            This forces un-nesting then continuing at the upper level
            */
            context->nested_filenames->offset_to_next_item = -1;
            break;
d877 2
a878 2
            context->action = Next_Leaf;
            break;
d903 1
a903 1
    DEBUG(("\nstep_to_next_node\n"));
d913 1
a913 6
        case Next_Leaf: DEBUG(("Next_Leaf "));
        /*
            Step to the next leaf at this nesting level
        */
        if ( context->nested_filenames == NULL )
        {
d915 1
a915 1
                Get next selection
d917 2
a918 16
            next_selection = context->selection->next_file;
            free_selection( context->selection );
            context->selection = next_selection;

            DEBUG(("get next selection"));

            context->action = Process_Node;
        }
        else
        {
            /*
                Get next cached entry
            */
            context->nested_filenames->next_entry_to_return++;
            if ( context->nested_filenames->next_entry_to_return >=
             context->nested_filenames->entries_in_buffer )
d921 1
a921 1
                    We've run out of cached entries
d923 7
a929 2
                DEBUG(("cache empty "));
                context->action = Read_Next_Cache_Full;
d934 1
a934 2
                    Found an entry in the cache, so let's
                    process it
d936 3
a938 32
                DEBUG(("cache ok "));
                context->action = Process_Node;
            }
        }
        break;

        case Process_Node: DEBUG(("Process_Node "));
        /*
            Process the node as supplied by Next_Leaf
        */
        if ( context->selection == NULL )
        {
            /*
                No more entries in the selection, so we've
                resolved what happens next
            */
            DEBUG(("resolved all "));
            resolved = Yes;
        }
        else
        {
            DEBUG(("%s ", name_of_next_node(context)));
            /*
                Get type of node if needed
            */
            if ( context->nested_filenames == NULL )
            {
                fileplace.action = 17;
                err = next_filename( context, context->nested_filenames, &fileplace.name );
                DEBUG(("%s ", fileplace.name));

                if ( err )
d940 5
a944 2
                    DEBUG(("err\n"));
                    continue;
d946 1
a946 4

                err = os_file( &fileplace );

                if ( err )
d948 6
a953 3
                    overflowing_free( fileplace.name );
                    DEBUG((" error\n"));
                    continue;
d955 2
d958 6
a963 25
                /*
                    Didn't find a selection - generate an error.
                */
                if ( fileplace.action == ObjectType_NotFound )
                {
                    fileplace.loadaddr = fileplace.action;
                    fileplace.action = 19;
                    err = os_file( &fileplace );
                    overflowing_free( fileplace.name );
                    DEBUG((" not found\n"));
                    continue;
                }

                overflowing_free( fileplace.name );

                context->selections_objecttype = fileplace.action;
                context->selections_size = fileplace.start;
                context->selections_loadaddr = fileplace.loadaddr;
                context->selections_execaddr = fileplace.execaddr;
                context->selections_attributes = fileplace.end;
            } /* end if (nested_filenames == NULL) */

            objecttype = objecttype_of_next_node( (search_handle)context );

            if ( objecttype == ObjectType_NotFound )
d966 2
a967 2
                    Didn't find that, so go around
                    for another time - nothing to do here
d969 2
a970 15
                DEBUG(("not found "));

                context->action = Next_Leaf;
            }
            else if ( context->recursive &&
                  is_a_directory( context, objecttype ) )
            {
                /*
                    If we are returning directories first, then
                    we have resolved it at this level
                */
                DEBUG(("directory "));
                resolved = context->directories_first;

                context->action = Nest_Into_Directory;
d975 1
a975 4
                    Found a file or we found a directory
                    when not recursing, in which case
                    we've found something worth while and
                    so we've resolved things.
d977 2
a978 73
                resolved = Yes;
                context->action = Next_Leaf;
                DEBUG(("resolved "));

            }
        }
        break;

        case Read_Next_Cache_Full: DEBUG(("Read_Next_Cache_Full "));
        /*
            If run out of entries in this directory
        */
        if ( context->nested_filenames->offset_to_next_item == -1 )
        {
            #ifdef USE_PROGRESS_BAR
            search_nest_level *nf = context->nested_filenames;
            unsigned int p = 0;

            /*
               Compensate for rounding errors by adding the 'spare' progress
               Isn't totally accurate if copying, as the actual progress values
               used will have been halved.
            */
            p = nf->total_progress - (nf->total_entries * nf->progress_per_object);
            if (p > 0) *progress += p;
            DEBUG(("finished %d entries (total %08x) extra progress +%08x", nf->total_entries, nf->total_progress, p));
            #else
            IGNORE(progress);
            #endif

            /*
                Down down one level
            */
            temp_context = context->nested_filenames->next_search_nest_level;
            for ( i = 0; i < Directory_Buffer_Size; i++ )
            {
                overflowing_free( context->nested_filenames->directory_buffer[ i ].object_name );
            }
            overflowing_free( context->nested_filenames );
            context->nested_filenames = temp_context;

            /*
                Return the directory after all the files in it
            */
            resolved = context->directories_last;

            context->action = Next_Leaf;
        }
        else
        {
            char **filename_store;

            /*
                Read more of this directory
            */
            gbpbplace.action      = 10;

            err = next_filename( context, context->nested_filenames->next_search_nest_level, (char **)&gbpbplace.file_handle );

            if ( err )
                continue;

            DEBUG(("%s ", (char *)gbpbplace.file_handle));


            #ifdef USE_PROGRESS_BAR
            search_nest_level *nf = context->nested_filenames;

            if (nf->total_entries == -1)
            {
                nf->total_entries = count_objects_in_dir((char *)gbpbplace.file_handle);

                if (nf->total_entries > 0)
d980 44
a1023 53
                  nf->progress_per_object = nf->total_progress / nf->total_entries;
                }
                else
                {
                  void *ref;

                  /*
                     Modify progress values so that half the progress for the dir is
                     added when the dir is finished (in the rounding process above)
                     and the other half when written. We have to do this now as when
                     the dir was added to the chain, we didn't know it was empty.
                     Of course if the dir is not in the chain, we are not copying, and
                     so we add all the progress for this dir at once.
                  */

                  if (nf->next_search_nest_level == NULL)
                  {
                    /* top level	*/
                    ref = context->chain_ref;
                  }
                  else
                  {
                    int i = nf->next_search_nest_level->next_entry_to_return;
                    ref = nf->next_search_nest_level->directory_buffer[i].chain_ref;
                  }

                  if (ref != NULL)
                  {
                    nf->total_progress /= 2;
                    nf->progress_per_object = 0;
                    modify_chain_file_progress(ref, nf->total_progress);
                  }

                } /* end if (total_entries > 0) */

                DEBUG(("%d entries %08x total progress %08x per object ", nf->total_entries, nf->total_progress, nf->progress_per_object));

            } /* end if (total_entries == -1) */

            #endif

            gbpbplace.data_addr   = &temp_directory_buffer;
            gbpbplace.number      = Directory_Buffer_Size;
            gbpbplace.seq_point   = context->nested_filenames->offset_to_next_item;
            gbpbplace.buf_len     = Temp_DirBuffer_Size;
            gbpbplace.wild_fld    = "*";

            err = os_gbpb( &gbpbplace );
            overflowing_free( (void *)gbpbplace.file_handle );

            if ( err )
            {
                if ( (err->errnum & FileError_Mask) == ErrorNumber_NotFound )
d1026 2
a1027 1
                            Cancel the error
d1029 7
a1035 2
                    err = NULL;

d1037 2
a1038 1
                         Down down one level
d1040 7
a1046 8
                    temp_context = context->nested_filenames->next_search_nest_level;
                    for ( i = 0; i < Directory_Buffer_Size; i++ )
                    {
                            overflowing_free( context->nested_filenames->directory_buffer[ i ].object_name );
                    }
                    overflowing_free( context->nested_filenames );
                    context->nested_filenames = temp_context;

d1048 4
a1051 2
                            Don't return the directory, as it
                            doesn't exist!
d1053 1
a1053 1

d1055 2
a1057 2

                continue;
d1059 1
d1061 6
a1066 1
            for ( i = 0, pos = 0; i < gbpbplace.number; i++ )
d1068 3
a1070 10
                context->nested_filenames->directory_buffer[ i ].load_address      = *(int *)&temp_directory_buffer[ pos ];
                pos += 4;
                context->nested_filenames->directory_buffer[ i ].execution_address = *(int *)&temp_directory_buffer[ pos ];
                pos += 4;
                context->nested_filenames->directory_buffer[ i ].length            = *(int *)&temp_directory_buffer[ pos ];
                pos += 4;
                context->nested_filenames->directory_buffer[ i ].attributes        = *(int *)&temp_directory_buffer[ pos ];
                pos += 4;
                context->nested_filenames->directory_buffer[ i ].object_type       = *(int *)&temp_directory_buffer[ pos ];
                pos += 4;
d1073 3
a1075 1
                    Free the filename if there's one there
d1077 12
a1088 2
                filename_store = &context->nested_filenames->directory_buffer[ i ].object_name;
                if ( *filename_store )
d1090 1
a1090 2
                    overflowing_free ( *filename_store );
                    *filename_store = NULL;
d1092 14
a1105 1

d1107 1
a1107 1
                    Allocate some space for the file name
d1109 101
a1209 1
                if ( ( *filename_store = overflowing_malloc( strlen( &temp_directory_buffer[ pos ] ) + 1 ) ) == NULL )
d1211 21
d1233 1
a1233 1
                            If the allocation failed, free everything up
d1235 1
a1235 3
                    int j;

                    for ( j = 0; j < i; j++ )
d1237 14
a1250 2
                            overflowing_free( context->nested_filenames->directory_buffer[ j ].object_name );
                            context->nested_filenames->directory_buffer[ j ].object_name = NULL;
d1252 10
a1261 3

                    err = error( mb_malloc_failed );

d1263 8
a1270 1
                }
d1272 14
a1285 6
                strcpy( *filename_store, &temp_directory_buffer[ pos ] );

                pos += strlen( &temp_directory_buffer[ pos ] ) + 1;

                /* round pos up to a word boundary */
                pos = (( pos + 3 ) / 4 ) * 4;
d1287 4
a1290 6

            if ( err )
                break;

            context->nested_filenames->offset_to_next_item = gbpbplace.seq_point;
            context->nested_filenames->entries_in_buffer = gbpbplace.number;
d1292 1
a1292 42

            context->action = Next_Leaf;
        }
        break;

        case Nest_Into_Directory: DEBUG(("Nest_Into_Directory "));
        /*
            Go down into the next nesting level
        */

        temp_context = context->nested_filenames;

        context->nested_filenames = overflowing_malloc( sizeof( search_nest_level ));
        if ( context->nested_filenames == NULL )
        {
            context->nested_filenames = temp_context;
            err = error( mb_malloc_failed );
            continue;
        }

        context->nested_filenames->next_search_nest_level = temp_context;
        context->nested_filenames->offset_to_next_item = 0;
        context->nested_filenames->entries_in_buffer = 0;
        context->nested_filenames->next_entry_to_return = -1;

        #ifdef USE_PROGRESS_BAR
        if (temp_context != NULL)
        {
          context->nested_filenames->total_progress = temp_context->progress_per_object;
        }
        else
        {
          context->nested_filenames->total_progress = context->progress_per_object;
        }
        /* Default values, will be overwitten if this object is a dir */
        context->nested_filenames->progress_per_object = 0;
        context->nested_filenames->total_entries = -1;
        #endif

        for ( i = 0; i < Directory_Buffer_Size; i++ )
        {
            context->nested_filenames->directory_buffer[ i ].object_name = NULL;
d1294 11
a1304 1
            context->nested_filenames->directory_buffer[ i ].chain_ref = NULL;
d1306 12
a1317 5
        }

        context->action = Next_Leaf;

        break;
d1320 2
a1321 2
        err = error( mb_unexpected_state );
        break;
d1324 1
a1324 1
        DEBUG(("\n"));
@


4.6
log
@Fix display of bytes-to-go when there are > 2G left.
Was doing a widening cast of a signed number to 64 bits, so showed 16 trillion bytes remaining.
Fix templates to not say "stuff" by default in the name, as this was left on screen if an error occured before processing began.
Things that read from clock() now use clock_t.
Uncurled some "} else {" to match all the other files.
Deleted the USE_LONG_LONG switch, it's been needed ever since harddiscs got bigger than 4G anyway.
Anything assigned 'Yes' or 'No' changed to type BOOL.
Variable 'source_of_finished_file' was signalling that a directory had been copied by setting the length to a -ve number. This has been refactored to use a BOOL instead, so files can have top bit set sizes.
Fix bug in stack grab in count_objects_in_dir(), was grabbing an array of 2048 pointers (=8k) not 2048 bytes.
Functions bytes_left_to_read() and bytes_left_to_write() reprototyped to return uint32_t not signed numbers.
Still falls over copying files > 2G, but at least it gets the display right!

Version 0.51. Tagged as 'FilerAct-0_51'
@
text
@d139 1
a139 1
static int count_objects_in_dir(char *dir)
d231 1
a231 1
extern void recurse_search_context( search_handle handle, int recursive )
d252 1
a252 1
extern void return_directories_first( search_handle handle, int directories_first )
d261 1
a261 1
extern void return_directories_last( search_handle handle, int directories_last )
d270 1
a270 1
extern void treat_partitions_as_directories( search_handle handle, int partitions_are_directories )
d1332 1
a1332 1
void listfiles_convert_to_copymove(search_handle handle)
@


4.5
log
@Didn't compile with PROGRESS_BAR turned off.
Rationalised all the switches a bit.
Not tagged.
@
text
@d40 1
a53 1
#define Yes 1
d55 1
d117 2
a118 2
    unsigned int            selections_reload;
    unsigned int            selections_execute;
d138 29
a166 24

#define SIZE	2048
static int count_objects_in_dir(char *dir) {
  os_error *e;
  char *buff[SIZE];
  int chunk = 256, context = 0, c, num = 0, total = 0;

  while (context != -1) {
    if ((e = _swix(OS_GBPB, _INR(0,6) | _OUTR(3,4), 9, dir, buff, chunk, context, SIZE, 0, &num, &c)) == NULL) {

      if (c == context) {
        /*
           Broken archives cause context to never be updated ... not sure why
           the SWI does not return an error.
        */
        DEBUG(("count_objects_in_dir: aborting\n"));
        return 0;
      }

      context = c;
      total += num;
    } else {
      DEBUG(("count_objects_in_dir: %s\n", e->errmess));
      return 0;
d168 2
a169 3
  }

  return total;
d449 4
a452 4
        returned_length += 1 + strlen( nest_level->
                                      directory_buffer[ nest_level->next_entry_to_return ].
                                      object_name );
        nest_level = nest_level->next_search_nest_level;
d534 1
a534 1
            cont = msgs_lookup("93");	// 'nothing'
d542 1
a542 1
            cont = msgs_lookup("92");	// 'many'
d683 2
a684 2
    handle->selections_reload     = fileplace.loadaddr;
    handle->selections_execute    = fileplace.execaddr;
d688 2
a689 1
typedef enum { the_size, the_load_address, the_execute_address, the_attributes, the_type, the_name
d713 1
a713 1
                    return context->selections_reload;
d715 1
a715 1
                    return context->selections_execute;
d725 2
a726 1
              if (context->selections_objecttype == ObjectType_Directory) {
d729 2
a730 1
              } else {
d739 1
a739 1
            } // end switch
d764 2
a765 1
              if (d->object_type == ObjectType_Directory) {
d768 3
a770 1
              } else {
d901 1
a901 1
    int resolved = No;
d985 2
a986 1
                if ( err ) {
d1017 2
a1018 2
                context->selections_reload = fileplace.loadaddr;
                context->selections_execute = fileplace.execaddr;
d1020 1
a1020 1
            } // end if (nested_filenames == NULL)
d1069 1
a1069 1
            search_nest_level *nf = context->nested_filenames;	// for legibility
d1122 2
a1123 1
            if (nf->total_entries == -1) {
d1126 2
a1127 1
                if (nf->total_entries > 0) {
d1129 3
a1131 1
                } else {
d1143 2
a1144 1
                  if (nf->next_search_nest_level == NULL) {
d1147 3
a1149 1
                  } else {
d1154 2
a1155 1
                  if (ref != NULL) {
d1161 1
a1161 1
                } // end if (total_entries > 0)
d1165 1
a1165 1
            } // end if (total_entries == -1)
d1293 2
a1294 1
        if (temp_context != NULL) {
d1296 3
a1298 1
        } else {
d1321 1
a1321 1
        } // end switch
d1325 1
a1325 1
    } // end while
d1332 2
a1333 1
void listfiles_convert_to_copymove(search_handle handle) {
a1338 1

@


4.4
log
@Fixed progress bar bug in Filer Action.
Progress bar was wrong during a CopyMove operation that required more
memory than the available wimp slot.

Version 0.50. Tagged as 'FilerAct-0_50'
@
text
@d69 1
a69 1
     #ifdef PROGRESS_BAR
d83 1
a83 1
     #ifdef PROGRESS_BAR
d125 1
a125 1
    #ifdef PROGRESS_BAR
d135 1
a135 1
#ifdef PROGRESS_BAR
d167 1
a167 1
#endif	// PROGRESS_BAR
d193 1
a193 1
        #ifdef PROGRESS_BAR
d362 1
a362 1
           #ifdef PROGRESS_BAR
d684 1
a684 1
  #ifdef PROGRESS_BAR
d717 1
a717 1
            #ifdef PROGRESS_BAR
d754 1
a754 1
            #ifdef PROGRESS_BAR
d808 1
a808 1
#ifdef PROGRESS_BAR
d1056 1
a1057 2

            #ifdef PROGRESS_BAR
d1068 2
d1107 2
a1108 2
            #ifdef PROGRESS_BAR
            search_nest_level *nf = context->nested_filenames;	// for legibility
d1147 1
a1147 1
            #endif // PROGRESS_BAR
d1272 1
a1272 1
        #ifdef PROGRESS_BAR
d1286 1
a1286 1
            #ifdef PROGRESS_BAR
d1308 1
a1308 1
#ifdef PROGRESS_BAR
@


4.3
log
@Redesigned window to show more of path.
Added progress bar.
Performance improvements, especially in 'slower' mode.
Fixed 'count summary' bug.
Fixed various compiler warnings.

Version 0.49. Tagged as 'FilerAct-0_49'
@
text
@d772 2
@


4.2
log
@Version RO_3_71 merged
@
text
@d45 1
d50 2
d68 5
d82 7
d110 59
a168 15
        search_nest_level       *nested_filenames;
        char                    *directory;
        file_selection          *selection;
        file_selection          **last_selections_link;
        next_leaf_state         action;
        unsigned int            selections_size;
        unsigned int            selections_reload;
        unsigned int            selections_execute;
        unsigned int            selections_attributes;
        unsigned int            selections_objecttype;
        unsigned int            recursive:1;
        unsigned int            directories_first:1;
        unsigned int            directories_last:1;
        unsigned int            partitions_as_directories:1;
}    search_context;
d178 1
a178 1
        search_context *new_context;
d180 19
a198 12
        if ( ( new_context = overflowing_malloc( sizeof( search_context ))) != NULL )
        {
                *handle = (search_handle)new_context;
                new_context->directory = NULL;
                new_context->nested_filenames = NULL;
                new_context->selection = NULL;
                new_context->last_selections_link = &new_context->selection;
                new_context->recursive = Yes;
                new_context->directories_first = No;
                new_context->directories_last = No;
                new_context->partitions_as_directories = Yes;
                new_context->action = Process_Node;
d200 6
a205 6
                return NULL;
        }
        else
        {
                return error( mb_malloc_failed );
        }
d211 10
a220 10
        if ( objecttype == ObjectType_Directory ||
                (objecttype == (ObjectType_Directory | ObjectType_File) &&
                 handle->partitions_as_directories) )
        {
                return Yes;
        }
        else
        {
                return No;
        }
d228 11
a238 11
        /*
                Make sure when changing to recursive that the children of this
                directory get returned
        */
        if ( !handle->recursive &&
             recursive &&
             is_a_directory( handle, objecttype_of_next_node( handle )) &&
             handle->action == Next_Leaf )
        {
                handle->action = Nest_Into_Directory;
        }
d240 1
a240 1
        handle->recursive = recursive != No;
d244 2
a245 2
        Sets whether directories should be returned before their contents.
        This is relevant only when recursing.
d249 1
a249 1
        ((search_context *)handle)->directories_first = directories_first != No;
d253 2
a254 2
        Sets whether directories should be returned after their contents.
        This is relevant only when recursing.
d258 1
a258 1
        handle->directories_last = directories_last != No;
d267 1
a267 1
        handle->partitions_as_directories = partitions_are_directories;
d279 1
a279 1
          overflowing_free( context->directory );
d284 1
a284 1
          strcpy( context->directory, directory );
d286 1
a286 1
          return NULL;
d290 1
a290 1
          return error( mb_malloc_failed );
d313 1
a313 1
          Free the chain of selections
d316 2
a317 2
           this_selection != NULL;
           this_selection = next_selection )
d319 2
a320 2
          next_selection = this_selection->next_file;
          free_selection( this_selection );
d324 1
a324 1
          close off the head of the list
d340 4
a343 4
          These two if statements allocate the new selection structure and
          then some space for the file name. The mallocs are checked to
          work, and if they don't everything is tidied up and an error
          is returned.
d348 28
a375 22
          new_selection->selection_name = overflowing_malloc( wordlen + 1 );
          if ( new_selection->selection_name != NULL )
          {
               /*
                    Everything allocated OK, so copy the string and
                    link the new selection onto the end of the list.
               */
               *context->last_selections_link = new_selection;
               strncpy( new_selection->selection_name, file_name, wordlen );
               new_selection->selection_name[ wordlen ] = '\0';
               context->last_selections_link = &new_selection->next_file;
               new_selection->next_file = NULL;

               return NULL;
          }
          else
          {
               /*
                    No room for selection name.
                    Free up the selection structure and tidy up the ends
               */
               overflowing_free( new_selection );
d377 2
a378 2
               return error( mb_malloc_failed );
          }
d382 1
a382 1
          return error( mb_malloc_failed );
d399 1
a399 1
          Free the search nest level chain
d405 7
a411 7
          temp_rover = rover;
          rover = rover->next_search_nest_level;
          for ( i = 0; i < Directory_Buffer_Size; i++ )
          {
               overflowing_free( temp_rover->directory_buffer[ i ].object_name );
          }
          overflowing_free( temp_rover );
d427 2
a428 2
          context->selection &&
          context->selection->selection_name )
d430 1
a430 1
          returned_length = strlen( context->directory );
d432 18
a449 18
          /*
               Only Add one in if there's going to be a . in between dir and selection
          */
          if ( returned_length )
               returned_length++;

          returned_length += strlen( context->selection->selection_name );

          if ( context->recursive )
          {
               while ( nest_level != NULL )
               {
                    returned_length += 1 + strlen( nest_level->
                                                  directory_buffer[ nest_level->next_entry_to_return ].
                                                  object_name );
                    nest_level = nest_level->next_search_nest_level;
               }
          }
d471 1
a471 1
          buffer = overflowing_malloc( next_filename_size + 1 );
d473 4
a476 4
          if ( buffer == NULL )
          {
               return error( mb_malloc_failed );
          }
d481 25
a505 25
          if ( context->directory[0] )
          {
               sprintf( buffer, "%s.%s", context->directory, context->selection->selection_name );
          }
          else
          {
               sprintf( buffer, "%s", context->selection->selection_name );
          }

          rover = buffer + next_filename_size;

          *rover = '\0';

          while ( nest_level != NULL )
          {
               part_length = strlen( nest_level->
                         directory_buffer[ nest_level->next_entry_to_return ].
                         object_name );
               rover -= part_length + 1;

               rover[0] = '.';

               memcpy( &rover[1], nest_level->
                         directory_buffer[ nest_level->next_entry_to_return ].
                         object_name, part_length );
d507 2
a508 2
               nest_level = nest_level->next_search_nest_level;
          }
d524 2
a525 2
        search_context *context = (search_context *)handle;
        char *cont;
d527 12
a538 12
        if ( context->selection == NULL )
        {
                cont = msgs_lookup("93");
        }
        else if ( context->selection->next_file == NULL )
        {
                cont = context->selection->selection_name;
        }
        else
        {
                cont = msgs_lookup("92");
        }
d540 1
a540 1
        *summary = overflowing_malloc( strlen( context->directory ) + 1 + strlen( cont ) + 1 );
d542 2
a543 2
        if ( *summary == NULL )
                return error( mb_malloc_failed );
d545 1
a545 1
        sprintf( *summary, "%s.%s", context->directory, cont );
d547 1
a547 1
        return NULL;
d565 1
a565 1
          matched_position = mstring;
d567 1
a567 1
          dl = strlen( handle->directory );
d569 2
a570 2
          if ( strncmp( handle->directory, matched_position, dl ) != 0 )
               return NULL;
d572 1
a572 1
          matched_position += dl;
d574 2
a575 2
          if ( *matched_position != '.' )
               return NULL;
d577 1
a577 1
          matched_position += 1;
d579 1
a579 1
          sl = strlen( handle->selection->selection_name );
d581 2
a582 2
          if ( strncmp( handle->selection->selection_name, matched_position, sl ) != 0 )
               return NULL;
d584 1
a584 1
          matched_position += sl;
d586 1
a586 1
          return matched_position;
d590 2
a591 2
          matched_position = first_position_not_matched( handle, nl->next_search_nest_level, mstring,
               deepest_match, shallowest_non_match );
d593 2
a594 2
          if ( matched_position == NULL )
               return NULL;
d596 2
a597 2
          ms = nl->directory_buffer[ nl->next_entry_to_return ].object_name;
          sl = strlen( ms );
d599 14
a612 14
          if ( *matched_position == '.' &&
               strncmp( matched_position + 1, ms, sl ) == 0 )
          {
               matched_position += 1 + sl;

               *deepest_match = nl;
          }
          else
          {
               if ( nl->next_search_nest_level == *deepest_match )
               {
                    *shallowest_non_match = nl;
               }
          }
d614 1
a614 1
          return matched_position;
d619 1
a619 1
        Informs that next node has been deleted
d623 29
a651 29
        if ( handle->nested_filenames && handle->selection )
        {
                char *matched_position;
                search_nest_level *deepest_match = NULL;
                search_nest_level *shallowest_non_match = NULL;

                matched_position = first_position_not_matched( handle, handle->nested_filenames, deleted_node, &deepest_match, &shallowest_non_match );

                if ( matched_position != NULL )
                {
                        /*
                                Deleted node is before something in shallowest non-match
                        */
                        if ( matched_position == strrchr( deleted_node, '.' ) &&
                             shallowest_non_match != NULL )
                        {
                                shallowest_non_match->offset_to_next_item--;
                        }

                        /*
                                Deleted is current node or a parent of it (gulp!)
                        */
                        if ( *matched_position == '\0' &&
                             deepest_match != NULL )
                        {
                                deepest_match->offset_to_next_item--;
                        }
                }
        }
d660 3
a662 3
        os_filestr fileplace;
        char *filename;
        os_error *err;
d664 1
a664 1
        err = next_nodename( handle, &filename );
d666 2
a667 2
        if ( err )
                return;
d669 2
a670 2
        fileplace.action = 5; /* read catalogue information */
        fileplace.name = filename;
d672 1
a672 1
        err = os_file( &fileplace );
d674 2
a675 2
        if ( err )
                return;
d677 4
a680 4
        handle->selections_size       = fileplace.start;
        handle->selections_reload     = fileplace.loadaddr;
        handle->selections_execute    = fileplace.execaddr;
        handle->selections_attributes = fileplace.end;
d683 5
a687 1
typedef enum { the_size, the_load_address, the_execute_address, the_attributes, the_type, the_name } which_thing;
d690 2
a691 2
        Returns one of the values associated with the next node.
        If the node doesn't exist the value not_found is returned.
d695 2
a696 2
        search_context *context = (search_context *)handle;
        search_nest_level *nf;
d698 36
a733 1
        if ( context->selection )
d735 34
a768 36
                if ( (nf = context->nested_filenames) == NULL )
                {
                        switch( thing )
                        {
                        case the_size:
                                return context->selections_size;
                        case the_load_address:
                                return context->selections_reload;
                        case the_execute_address:
                                return context->selections_execute;
                        case the_attributes:
                                return context->selections_attributes;
                        case the_type:
                                return context->selections_objecttype;
                        case the_name:
                                return (int)context->selection->selection_name;
                        }
                }
                else
                {
                        switch( thing )
                        {
                        case the_size:
                                return nf->directory_buffer[ nf->next_entry_to_return ].length;
                        case the_load_address:
                                return nf->directory_buffer[ nf->next_entry_to_return ].load_address;
                        case the_execute_address:
                                return nf->directory_buffer[ nf->next_entry_to_return ].execution_address;
                        case the_attributes:
                                return nf->directory_buffer[ nf->next_entry_to_return ].attributes;
                        case the_type:
                                return nf->directory_buffer[ nf->next_entry_to_return ].object_type;
                        case the_name:
                                return (int)nf->directory_buffer[ nf->next_entry_to_return ].object_name;
                        }
                }
d770 1
d772 1
a772 1
        return not_found;
d777 1
a777 1
        return thing_of_next_node( handle, the_size, -1 );
d782 1
a782 1
        return thing_of_next_node( handle, the_load_address, -1 );
d787 1
a787 1
        return thing_of_next_node( handle, the_execute_address, -1 );
d792 1
a792 1
        return thing_of_next_node( handle, the_attributes, -1 );
d797 1
a797 1
        return thing_of_next_node( handle, the_type, ObjectType_NotFound );
d802 14
a815 1
        return (char *)thing_of_next_node( handle, the_name, NULL );
d817 2
d821 2
a822 2
        Assuming a directory has just been found, return whether this return
        of this directory was before or after its contents.
d826 1
a826 1
        search_context *context = (search_context *)handle;
d828 1
a828 1
        return context->action == Next_Leaf;
d837 1
a837 1
        return ((search_context *)handle)->selection != NULL;
d841 1
a841 1
        When finding a selection fails call this to skip it.
d845 33
a877 1
        search_context *context = (search_context *)handle;
d879 23
a901 1
        switch ( context->action )
d903 109
a1011 1
        case Next_Leaf:
d1013 2
a1014 1
                        Can't generate an error in this state
d1016 1
a1016 1
                break;
a1017 1
        case Process_Node:
d1019 10
a1028 1
                break;
d1030 4
a1033 1
        case Read_Next_Cache_Full:
d1035 4
a1038 1
                        This forces un-nesting then continuing at the upper level
d1040 44
a1083 2
                context->nested_filenames->offset_to_next_item = -1;
                break;
d1085 1
a1085 3
        case Nest_Into_Directory:
                context->action = Next_Leaf;
                break;
d1087 150
a1236 1
}
d1238 2
a1239 3
void skip_list_file( search_handle handle )
{
        search_context *context = (search_context *)handle;
d1241 3
a1243 2
        context->action = Next_Leaf;
}
d1245 3
a1247 13
os_error *step_to_next_node( search_handle handle )
{
        search_context *context = (search_context *)handle;
        search_nest_level *temp_context;
        os_gbpbstr gbpbplace;
        os_filestr fileplace;
        char temp_directory_buffer[ Temp_DirBuffer_Size ];
        int i;
        int pos;
        int resolved = No;
        os_error *err = NULL;
        file_selection *next_selection;
        int objecttype;
d1249 1
d1251 1
a1251 2
                While the answer hasn't resolved itself and there's no error
                then try the next step of resolving the answer
d1253 28
a1280 1
        while( !resolved && !err )
d1282 4
a1285 307
                switch( context->action )
                {
                case Next_Leaf:
                        /*
                                Step to the next leaf at this nesting level
                        */
                        if ( context->nested_filenames == NULL )
                        {
                                /*
                                        Get next selection
                                */
                                next_selection = context->selection->next_file;
                                free_selection( context->selection );
                                context->selection = next_selection;

                                context->action = Process_Node;
                        }
                        else
                        {
                                /*
                                        Get next cached entry
                                */
                                context->nested_filenames->next_entry_to_return++;
                                if ( context->nested_filenames->next_entry_to_return >=
                                     context->nested_filenames->entries_in_buffer )
                                {
                                        /*
                                             We've run out of cached entries
                                        */
                                        context->action = Read_Next_Cache_Full;
                                }
                                else
                                {
                                        /*
                                                Found an entry in the cache, so let's
                                                process it
                                        */
                                        context->action = Process_Node;
                                }
                        }
                        break;

                case Process_Node:
                        /*
                                Process the node as supplied by Next_Leaf
                        */
                        if ( context->selection == NULL )
                        {
                                /*
                                        No more entries in the selection, so we've
                                        resolved what happens next
                                */
                                resolved = Yes;
                        }
                        else
                        {
                                /*
                                        Get type of node if needed
                                */
                                if ( context->nested_filenames == NULL )
                                {
                                        fileplace.action = 17;
                                        err = next_filename( context, context->nested_filenames, &fileplace.name );

                                        if ( err )
                                                continue;

                                        err = os_file( &fileplace );

                                        if ( err )
                                        {
                                                overflowing_free( fileplace.name );
                                                continue;
                                        }

                                        /*
                                                Didn't find a selection - generate an error.
                                        */
                                        if ( fileplace.action == ObjectType_NotFound )
                                        {
                                                fileplace.loadaddr = fileplace.action;
                                                fileplace.action = 19;
                                                err = os_file( &fileplace );
                                                overflowing_free( fileplace.name );
                                                continue;
                                        }

                                        overflowing_free( fileplace.name );

                                        context->selections_objecttype = fileplace.action;
                                        context->selections_size = fileplace.start;
                                        context->selections_reload = fileplace.loadaddr;
                                        context->selections_execute = fileplace.execaddr;
                                        context->selections_attributes = fileplace.end;
                                }

                                objecttype = objecttype_of_next_node( (search_handle)context );

                                if ( objecttype == ObjectType_NotFound )
                                {
                                        /*
                                                Didn't find that, so go around
                                                for another time - nothing to do here
                                        */

                                        context->action = Next_Leaf;
                                }
                                else if ( context->recursive &&
                                          is_a_directory( context, objecttype ) )
                                {
                                        /*
                                                If we are returning directories first, then
                                                we have resolved it at this level
                                        */
                                        resolved = context->directories_first;

                                        context->action = Nest_Into_Directory;
                                }
                                else
                                {
                                        /*
                                                Found a file or we found a directory
                                                when not recursing, in which case
                                                we've found something worth while and
                                                so we've resolved things.
                                        */
                                        resolved = Yes;

                                        context->action = Next_Leaf;
                                }
                        }
                        break;

                case Read_Next_Cache_Full:
                        /*
                                If run out of entries in this directory
                        */
                        if ( context->nested_filenames->offset_to_next_item == -1 )
                        {
                                /*
                                        Down down one level
                                */
                                temp_context = context->nested_filenames->next_search_nest_level;
                                for ( i = 0; i < Directory_Buffer_Size; i++ )
                                {
                                        overflowing_free( context->nested_filenames->directory_buffer[ i ].object_name );
                                }
                                overflowing_free( context->nested_filenames );
                                context->nested_filenames = temp_context;

                                /*
                                        Return the directory after all the files in it
                                */
                                resolved = context->directories_last;

                                context->action = Next_Leaf;
                        }
                        else
                        {
                                char **filename_store;

                                /*
                                        Read more of this directory
                                */
                                gbpbplace.action      = 10;

                                err = next_filename( context, context->nested_filenames->next_search_nest_level, (char **)&gbpbplace.file_handle );

                                if ( err )
                                        continue;

                                gbpbplace.data_addr   = &temp_directory_buffer;
                                gbpbplace.number      = Directory_Buffer_Size;
                                gbpbplace.seq_point   = context->nested_filenames->offset_to_next_item;
                                gbpbplace.buf_len     = Temp_DirBuffer_Size;
                                gbpbplace.wild_fld    = "*";

                                err = os_gbpb( &gbpbplace );
                                overflowing_free( (void *)gbpbplace.file_handle );

                                if ( err )
                                {
                                        if ( (err->errnum & FileError_Mask) == ErrorNumber_NotFound )
                                        {
                                                /*
                                                        Cancel the error
                                                */
                                                err = NULL;

                                                /*
                                                     Down down one level
                                                */
                                                temp_context = context->nested_filenames->next_search_nest_level;
                                                for ( i = 0; i < Directory_Buffer_Size; i++ )
                                                {
                                                        overflowing_free( context->nested_filenames->directory_buffer[ i ].object_name );
                                                }
                                                overflowing_free( context->nested_filenames );
                                                context->nested_filenames = temp_context;

                                                /*
                                                        Don't return the directory, as it
                                                        doesn't exist!
                                                */

                                                context->action = Next_Leaf;
                                        }

                                        continue;
                                }

                                for ( i = 0, pos = 0; i < gbpbplace.number; i++ )
                                {
                                        context->nested_filenames->directory_buffer[ i ].load_address      = *(int *)&temp_directory_buffer[ pos ];
                                        pos += 4;
                                        context->nested_filenames->directory_buffer[ i ].execution_address = *(int *)&temp_directory_buffer[ pos ];
                                        pos += 4;
                                        context->nested_filenames->directory_buffer[ i ].length            = *(int *)&temp_directory_buffer[ pos ];
                                        pos += 4;
                                        context->nested_filenames->directory_buffer[ i ].attributes        = *(int *)&temp_directory_buffer[ pos ];
                                        pos += 4;
                                        context->nested_filenames->directory_buffer[ i ].object_type       = *(int *)&temp_directory_buffer[ pos ];
                                        pos += 4;

                                        /*
                                                Free the filename if there's one there
                                        */
                                        filename_store = &context->nested_filenames->directory_buffer[ i ].object_name;
                                        if ( *filename_store )
                                        {
                                                overflowing_free ( *filename_store );
                                                *filename_store = NULL;
                                        }

                                        /*
                                                Allocate some space for the file name
                                        */
                                        if ( ( *filename_store = overflowing_malloc( strlen( &temp_directory_buffer[ pos ] ) + 1 ) ) == NULL )
                                        {
                                                /*
                                                        If the allocation failed, free everything up
                                                */
                                                int j;

                                                for ( j = 0; j < i; j++ )
                                                {
                                                        overflowing_free( context->nested_filenames->directory_buffer[ j ].object_name );
                                                        context->nested_filenames->directory_buffer[ j ].object_name = NULL;
                                                }

                                                err = error( mb_malloc_failed );

                                                break;
                                        }

                                        strcpy( *filename_store, &temp_directory_buffer[ pos ] );

                                        pos += strlen( &temp_directory_buffer[ pos ] ) + 1;

                                        /* round pos up to a word boundary */
                                        pos = (( pos + 3 ) / 4 ) * 4;
                                }

                                if ( err )
                                        break;

                                context->nested_filenames->offset_to_next_item = gbpbplace.seq_point;
                                context->nested_filenames->entries_in_buffer = gbpbplace.number;
                                context->nested_filenames->next_entry_to_return = -1;

                                context->action = Next_Leaf;
                        }
                        break;

                case Nest_Into_Directory:
                        /*
                                Go down into the next nesting level
                        */

                        temp_context = context->nested_filenames;

                        context->nested_filenames = overflowing_malloc( sizeof( search_nest_level ));
                        if ( context->nested_filenames == NULL )
                        {
                                context->nested_filenames = temp_context;
                                err = error( mb_malloc_failed );
                                continue;
                        }

                        context->nested_filenames->next_search_nest_level = temp_context;
                        context->nested_filenames->offset_to_next_item = 0;
                        context->nested_filenames->entries_in_buffer = 0;
                        context->nested_filenames->next_entry_to_return = -1;

                        for ( i = 0; i < Directory_Buffer_Size; i++ )
                        {
                                context->nested_filenames->directory_buffer[ i ].object_name = NULL;
                        }

                        context->action = Next_Leaf;

                        break;

                default:  /* disaster!!!!! */
                        err = error( mb_unexpected_state );
                        break;
                }
d1288 14
a1301 1
        return err;
d1304 11
@


4.1
log
@Initial revision
@
text
@d100 9
a108 9
        int                     selections_size;
        int                     selections_reload;
        int                     selections_execute;
        int                     selections_attributes;
        int                     selections_objecttype;
        int                     recursive:1;
        int                     directories_first:1;
        int                     directories_last:1;
        int                     partitions_as_directories:1;
d617 1
a617 1
static int thing_of_next_node( search_handle handle, which_thing thing, int not_found )
d665 1
a665 1
int size_of_next_node( search_handle handle )
d670 1
a670 1
int reload_of_next_node( search_handle handle )
d675 1
a675 1
int execute_of_next_node( search_handle handle )
d680 1
a680 1
int attributes_of_next_node( search_handle handle )
d685 1
a685 1
int objecttype_of_next_node( search_handle handle )
d699 1
a699 1
int directory_is_after_contents( search_handle handle )
d710 1
a710 1
int another_node( search_handle handle )
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.3.2
log
@Version RO_3_71 taken
@
text
@d100 9
a108 9
        unsigned int            selections_size;
        unsigned int            selections_reload;
        unsigned int            selections_execute;
        unsigned int            selections_attributes;
        unsigned int            selections_objecttype;
        unsigned int            recursive:1;
        unsigned int            directories_first:1;
        unsigned int            directories_last:1;
        unsigned int            partitions_as_directories:1;
d617 1
a617 1
static unsigned int thing_of_next_node( search_handle handle, which_thing thing, int not_found )
d665 1
a665 1
unsigned int size_of_next_node( search_handle handle )
d670 1
a670 1
unsigned int reload_of_next_node( search_handle handle )
d675 1
a675 1
unsigned int execute_of_next_node( search_handle handle )
d680 1
a680 1
unsigned int attributes_of_next_node( search_handle handle )
d685 1
a685 1
unsigned int objecttype_of_next_node( search_handle handle )
d699 1
a699 1
unsigned int directory_is_after_contents( search_handle handle )
d710 1
a710 1
unsigned int another_node( search_handle handle )
@


4.1.3.1.2.1
log
@Merged from 3.71 CD
@
text
@d100 9
a108 9
        unsigned int            selections_size;
        unsigned int            selections_reload;
        unsigned int            selections_execute;
        unsigned int            selections_attributes;
        unsigned int            selections_objecttype;
        unsigned int            recursive:1;
        unsigned int            directories_first:1;
        unsigned int            directories_last:1;
        unsigned int            partitions_as_directories:1;
d617 1
a617 1
static unsigned int thing_of_next_node( search_handle handle, which_thing thing, int not_found )
d665 1
a665 1
unsigned int size_of_next_node( search_handle handle )
d670 1
a670 1
unsigned int reload_of_next_node( search_handle handle )
d675 1
a675 1
unsigned int execute_of_next_node( search_handle handle )
d680 1
a680 1
unsigned int attributes_of_next_node( search_handle handle )
d685 1
a685 1
unsigned int objecttype_of_next_node( search_handle handle )
d699 1
a699 1
unsigned int directory_is_after_contents( search_handle handle )
d710 1
a710 1
unsigned int another_node( search_handle handle )
@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@

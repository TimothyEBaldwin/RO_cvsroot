head	4.12;
access;
symbols
	FilerAct-0_62:4.12
	FilerAct-0_61:4.12
	FilerAct-0_60:4.12
	FilerAct-0_59:4.12
	FilerAct-0_58:4.11
	FilerAct-0_57:4.10
	FilerAct-0_55:4.9
	FilerAct-0_54:4.9
	FilerAct-0_53:4.8
	FilerAct-0_52:4.7
	FilerAct-0_51:4.6
	FilerAct-0_50:4.4
	FilerAct-0_49:4.4
	FilerAct-0_48:4.3
	RO_5_07:4.3
	FilerAct-0_47:4.3
	FilerAct-0_46:4.2
	FilerAct-0_45:4.1
	dellis_autobuild_BaseSW:4.1
	FilerAct-0_44:4.1
	FilerAct-0_43:4.1
	sbrodie_sedwards_16Mar2000:4.1
	FilerAct-0_42:4.1
	Ursula_merge:4.1
	dcotton_autobuild_BaseSW:4.1
	mstphens_UrsulaRiscPCBuild_20Nov98:4.1
	Ursula_RiscPC:4.1.0.8
	nicke_FilerAct_0_39:4.1.7.1
	rthornb_UrsulaBuild-19Aug1998:4.1
	UrsulaBuild_FinalSoftload:4.1
	rthornb_UrsulaBuild-12Aug1998:4.1
	aglover_UrsulaBuild-05Aug1998:4.1
	rthornb_UrsulaBuild-29Jul1998:4.1
	rthornb_UrsulaBuild-22Jul1998:4.1
	rthornb_UrsulaBuild-15Jul1998:4.1
	hsimons_BOCA-1_2-Release:4.1.7.1
	rthornb_UrsulaBuild-07Jul1998:4.1
	rthornb_UrsulaBuild-17Jun1998:4.1
	rthornb_UrsulaBuild-03Jun1998:4.1
	rthornb_UrsulaBuild-27May1998:4.1
	rleggett_FilerAct-0_42:4.1
	rthornb_UrsulaBuild-21May1998:4.1
	rthornb_UrsulaBuild_01May1998:4.1
	Spinner_RCA116:4.1.7.1
	Spinner_B20_2:4.1.7.1
	Spinner_19_3:4.1.7.1
	Spinner_B18:4.1.7.1
	Spinner_B17:4.1.7.1
	Spinner_B15:4.1.7.1
	Spinner_B14:4.1.7.1
	Spinner_B13:4.1.7.1
	Spinner_B12:4.1.7.1
	Spinner_B10:4.1.7.1
	Daytona:4.1.0.6
	Daytona_bp:4.1
	Ursula:4.1.0.4
	Ursula_bp:4.1
	Spinner_B7:4.1.7.1
	RO_3_71:4.1.3.1
	ARTtmp_merge:4.1.7.1
	Spin_3Apr97:4.1.7.1
	RCA_bp:4.1
	ARTtmp:4.1.7.1.0.2
	RCA:4.1.0.2
	Spin_merge:4.1.7.1
	MergeFiles:4.1.3.1
	RO_3_70:4.1.3.1
	NC_1_06:4.1.7.1
	Spinner:4.1.7
	Spin_xx:4.1.5
	NC_xx:4.1.5.1
	RO_3_60:4.1.1.1
	StrongARM:4.1.3
	Black:4.1.1;
locks; strict;
comment	@# @;


4.12
date	2013.04.05.22.24.32;	author rsprowson;	state Exp;
branches;
next	4.11;
commitid	daL2AHU2omeqzDKw;

4.11
date	2012.08.16.20.00.24;	author jlee;	state Exp;
branches;
next	4.10;
commitid	Srsl6s2fnXskeOgw;

4.10
date	2012.07.15.15.45.55;	author bavison;	state Exp;
branches;
next	4.9;
commitid	qJ2mMp5DjjSNQFcw;

4.9
date	2011.10.23.07.55.48;	author rsprowson;	state Exp;
branches;
next	4.8;
commitid	xuMPqvl0RQswNrEv;

4.8
date	2011.10.23.07.46.59;	author rsprowson;	state Exp;
branches;
next	4.7;
commitid	7I8FKGdkajlxKrEv;

4.7
date	2011.10.20.20.36.00;	author rsprowson;	state Exp;
branches;
next	4.6;
commitid	YJZPZatOdKOo68Ev;

4.6
date	2011.10.20.20.32.44;	author rsprowson;	state Exp;
branches;
next	4.5;
commitid	DXWFsDOPRJsd58Ev;

4.5
date	2011.10.20.20.23.03;	author rsprowson;	state Exp;
branches;
next	4.4;
commitid	xmwir195eiLF18Ev;

4.4
date	2011.06.29.09.21.49;	author rgriffin;	state Exp;
branches;
next	4.3;
commitid	OcnnyIVQ9uPd0ypv;

4.3
date	2003.04.15.20.48.58;	author kbracey;	state Exp;
branches;
next	4.2;

4.2
date	2002.09.23.18.25.36;	author kbracey;	state Exp;
branches;
next	4.1;

4.1
date	96.11.05.09.29.37;	author nturton;	state Exp;
branches
	4.1.1.1
	4.1.3.1
	4.1.5.1
	4.1.7.1;
next	;

4.1.1.1
date	96.11.05.09.29.37;	author nturton;	state Exp;
branches;
next	;

4.1.3.1
date	96.11.05.23.28.05;	author nturton;	state Exp;
branches;
next	;

4.1.5.1
date	96.11.21.12.18.04;	author nturton;	state Exp;
branches;
next	;

4.1.7.1
date	96.11.29.20.16.52;	author nturton;	state Exp;
branches;
next	;


desc
@@


4.12
log
@Fix for occasional divide-by-zero in filer copies
An else clause was being run for both the "write not complete" case but also when an error had occurred in an earlier step. The error would generally be a failure to create and hence a file size of zero. Bang.
Steps to recreate (other, more obscure and hard to catch cases exist)
 1. Open ResourceFS
 2. Copy Resources:$.Resources to Resources:$.Apps
 3. As ResourceFS is read only the reads all buffer OK but the first write (should return 'read only') gives divide-by-zero

Version 0.59. Tagged as 'FilerAct-0_59'
@
text
@/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
     File and memory management for Filer_Action

Revision History:

0.07  13-May-90  ARW  Totally new implementation to old interface
*/

#define Timing 0

/*

Theory:

(1) read blocks (or all) of source file(s) into a contiguous chunk of store
    - extend as necessary up to next slot size
    - be prepared to lose information if slot size has to be shrunk

(2) write blocks to destination file(s)

(3) repeat until done

Notes:

(a) dynamically resize the block quanta for source and destination according
    to the real time it took: its programmed to update the user information
    (or allow other tasks in) around time_quanta (may get to 2*time_quanta).
    Hysteresis built in to the change in block size:
    - growth: <4096: +1024 AND NOT 1023
              <16K:  +4K AND NOT (4K-1)
              else:  double size
    - shrink: <4096: -256
              <16K:  -1024
              else:  -(quarter size)
    Initial block size is initial_block_size for both (=4096?)

(b) if a file is smaller than src_block, it is *loaded
    if a file is smaller than dest_block, it is *saved
    - these operations are not checked against time_quanta

(c) care needed to ensure that a contiguous block exists and can be moved
    by memcpy when it needs to be (user changes slot allocation - "action_slot").

 JRS 17/1/92 Measure the average transfer rate at the initial block size. If the blocksize
 is reduced below a certain critical value, then the transfer rate is compared with the initial
 value and if it is substantially worse, the value of time_quanta is increased, to allow
 blocksize to increase and get a better transfer rate at the expense of 'lumpy' response.
 Added hysteresis to time_quanta to prevent it always growing and shrinking

*/

#if 0
#define debugmem(k) dprintf k
#else
#define debugmem(k) /* Disabled */
#endif

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include <stdlib.h>

#include "kernel.h"
#include "Interface/HighFSI.h"

#include "os.h"
#include "wimp.h"

#include "Options.h"
#include "chains.h"
#include "allerrs.h"
#include "malloc+.h"
#include "memmanage.h"
#include "debug.h"

#if Timing
static clock_t copytime;
#endif

#define No 0
#define Yes (!No)

#define InitialBlockSize 4096
#define SmallBlockSize   3072 /* check the transfer rate is not too low if the blocksize reduces below this */
#define MinimumWorkingSize InitialBlockSize*3

#define NominalTimeQuanta 25 /* cs */
#define MaxTimeQuanta    100
#define TimeQuantaHysteresis 3

/*
     The file headers are held in a doubly linked list, on the malloc+ heap
*/
typedef enum {
    write_not_started,
    write_f_tried_unlock,   /* open/save failed - have tried to unlock it */
    write_f_tried_cdirs,    /* open/save failed - have tried to cdir it */
    write_f_tried_both,     /* open/save failed - have tried both cdirs and unlock */
    write_openit,           /* have created it, now open it */
    write_truncateopen,     /* have opened it now truncate it */
    write_blocks,           /* next thing is writing blocks out */
    write_closeit,          /* next thing is to close it */
    write_adjust_access,    /* next thing is adjust the access */
    write_adjust_info,      /* next thing is adjust the info */
    write_all_done          /* and junk the fh */
}   write_activity;

typedef struct
{
    chain_link      link;
    char            *source_filename;
    int             source_file_handle;
    char            *destination_filename;
    int             destination_file_handle;
    uint32_t        size;
    int             reload;
    int             execute;
    int             attributes;
    int             objecttype;
    BOOL            forceit;
    uint32_t        read_to;
    uint32_t        written_to;
    write_activity  write_state;
    int             start_of_buffer;        /* offset into memory */

#ifdef USE_PROGRESS_BAR
    uint32_t        total_progress;
    uint32_t        read_progress;
    uint32_t        write_progress;
#endif
}   files_header;

/*
     Structures for copying files
*/
static chain_header files_chain;        /* All the files registered with memmanage */
static int application_max_size;
static char *buffer_base_address;       /* Base of buffer area */
static int buffer_offset;               /* offset to add to bottom, top, and any other offsets into the area */
                                        /* used when the area contents are shuffled */
static int buffer_bottom;               /* offset to 1st used byte in buffer area */
static int buffer_top;                  /* offset to top free section in buffer area */
static int buffer_end;                  /* offset to end of buffer area */
static int src_block_size;
static int dest_block_size;
static int time_quanta = NominalTimeQuanta;
static int minimum_block_size = 512;

BOOL  finished_obj_was_file;
char *finished_obj_source_name;

/* JRS addition 16/1/92 */
/* accumulate transfer times at initial blocksize to compare timings at smaller
 * blocksizes to detect when the time per byte increases unacceptably. This triggers
 * an increase in time_quanta which causes the blocksize to grow and the overall
 * transfer rate to improve */

#define timing_Reading 0
#define timing_Writing 1

#define timing_NAccumulated 4  /* accumulate this many timings to average out variation */

static struct
{
    int rate; /* transfer rate calculated from accumulator and blocksize */
    int accumulator;
    int naccumulated;
}   timing[2]; /* read and write initial timing */
/*
     Rate evaluation functions
*/

static void timing_init(void)
{
    int rw;
    for (rw = 0; rw < 2; rw++) /* reading and writing */
    {
        timing[rw].rate = 0;
        timing[rw].accumulator = 0;
        timing[rw].naccumulated = 0;
    }
}

static int t__accumulatortorate(int accumulated_time, int blocksize)
{ /* convert an accumulated timing to a transfer rate value */
    if (accumulated_time < 1) accumulated_time = 1; /* ensure no div by zero */
    debugmem(( "t__accumulatortorate: %d,%d->%d\n", accumulated_time, blocksize,(blocksize<<8) / accumulated_time));

    return (blocksize<<8) / accumulated_time; /* shift is to gain integer value range */
}

static void timing_accumulate(int rw, int t, int blocksize)
/* accumulate a timing for read or write, return Yes if it is full (enough have been accumulated) */
{
    assert((rw==timing_Reading)||(rw==timing_Writing));
    assert(timing[rw].naccumulated < timing_NAccumulated);
    timing[rw].naccumulated++;
    timing[rw].accumulator += t;
    if ( timing[rw].naccumulated >= timing_NAccumulated )
    { /* accumulator is full and rate is not yet calculated; calculate rate */
        assert(timing[rw].rate == 0);
        timing[rw].rate = t__accumulatortorate(timing[rw].accumulator, blocksize);
    }
}

static int timing_accumulating(int rw)
{
    assert((rw==timing_Reading)||(rw==timing_Writing));
    return (timing[rw].naccumulated < timing_NAccumulated);
}

static int timing_poorrate(int rw, int t, int blocksize)
{ /* compare the given time, converted to a rate against the rate for the initial blocksize.
   * Return Yes if it is worse than 2/3 of the initial rate */
    assert((rw==timing_Reading)||(rw==timing_Writing));
    return ( t__accumulatortorate(t * timing_NAccumulated, blocksize) <  (2*timing[rw].rate)/3 );
}


static int application_current_size( void )
{
    int currentslot = -1;
    int nextslot = -1;
    int freepool;

    wimp_slotsize( &currentslot, &nextslot, &freepool );

    return currentslot;
}

static int current_next_slot( void )
{
    int currentslot = -1;
    int nextslot = -1;
    int freepool;

    wimp_slotsize( &currentslot, &nextslot, &freepool );

    return nextslot;
}

/*
    returns amount actually changed by
*/
static int extend_application_slot( int amount )
{
    int oldslot;
    int currentslot;
    int nextslot = -1;
    int freepool;

    if ( amount != 0 )
    {
        oldslot = application_current_size();

        currentslot = oldslot + amount;

        wimp_slotsize( &currentslot, &nextslot, &freepool );

        debugmem(( "extend_application_slot: amount = %d, new size = %d\n",amount,currentslot));

        return currentslot - oldslot;
    }
    else
    {
        return 0;
    }
}

/*
    Ensure that the top to end amount free is at least size
*/
static BOOL buffer_ensure( int size )
{
    if ( buffer_end - buffer_top < size )
    {
        buffer_end += extend_application_slot( size - (buffer_end - buffer_top) );
    }

    return buffer_end - buffer_top >= size;
}

/*
    Grow the buffer so that "size" is available, limiting by application_max_siz.
    Reduces *size to fit space.
    Returns Yes if not enough space available for original requested *size.
*/
static int grow_buffer( int *size )
{
    BOOL answer = No;

    /*
        Upper bound by application_max_size
    */
    if ( (int)(buffer_base_address + *size + buffer_top + buffer_offset) > application_max_size + 0x8000 )
    {
        *size = application_max_size + 0x8000 - (int)(buffer_base_address + buffer_top + buffer_offset);
        answer = Yes;
    }

    /*
        Try to ensure that much space
    */
    answer = answer || !buffer_ensure( *size );

    if ( buffer_end - buffer_top < *size )
    {
        *size = buffer_end - buffer_top;
        answer = Yes;
    }

    return answer;
}

static os_error *close_file( int *handle )
{
    os_regset r;
    os_error *err;

    r.r[0] = 0; /* close file */
    r.r[1] = *handle;

    err = os_find( &r );

    /*
         Even a failed close leaves the file closed afterwards
    */
    *handle = 0;

    return err;
}

/*
     Creates the file to be the given size, dead, with read/write
     access only.
*/
static os_error *create_file_dead( char *filename, uint32_t size )
{
    os_filestr fileplace;
    os_error *err;

    fileplace.action   = OSFile_Create;
    fileplace.name     = filename;
    fileplace.loadaddr = (int) 0xdeaddead;
    fileplace.execaddr = (int) 0xdeaddead;
    fileplace.start    = 0;
    fileplace.end      = (int)size;

    err = os_file( &fileplace );

    if ( err )
         return err;

    fileplace.action = OSFile_WriteAttr;
    fileplace.name = filename;
    fileplace.end = read_attribute | write_attribute;

    return os_file( &fileplace );
}

static os_error *create_directory( char *dirname )
{
    os_filestr fileplace;

    fileplace.action = OSFile_CreateDir;
    fileplace.name = dirname;
    fileplace.start = 0;

    return os_file( &fileplace );
}

static os_error *write_catalogue_information( char *filename, int objecttype, int reload, int execute, int attributes )
{
    os_filestr fileplace;

    if (objecttype == object_directory)
    {
        /* Check if we're overwriting an image file's information from a directory */
        fileplace.action = OSFile_ReadNoPath;
        fileplace.name = filename;
        os_error *err = os_file( &fileplace );
        if ( err != NULL )
            return err;

        if ( fileplace.action != objecttype )
        {
            /* Leave the filetype and user read/write bits alone */
            reload = (reload &~ 0xFFF00) | (fileplace.loadaddr & 0xFFF00);
            attributes = (attributes &~ 3) | (fileplace.end & 3);
        }
    }

    fileplace.action    = OSFile_WriteInfo;
    fileplace.name      = filename;
    fileplace.loadaddr  = reload;
    fileplace.execaddr  = execute;
    fileplace.end       = attributes;

    return os_file( &fileplace );
}

static os_error *write_attributes( char *filename, int attributes )
{
    os_filestr fileplace;

    fileplace.action    = OSFile_WriteAttr;
    fileplace.name      = filename;
    fileplace.end       = attributes;

    return os_file( &fileplace );
}

static char *first_dirbreak( char *filename )
{
    char *trypos;
    char *endpos;

    /*
        Point trypos past the -<fsname>- / <fsname>: bit
    */
    if ( filename[0] == '-' )
    {
        /*
            -<fsname>-
        */
        trypos = strchr( filename + 1, '-' ) + 1;
    }
    else if ( filename[0] != ':' )
    {
        /*
            <fsname>: perhaps
        */
        trypos = strchr( filename, ':' );

        if ( trypos == NULL )
        {
            /*
                 It wasn't <fsname>:, never mind
            */
            trypos = filename;
        }
        else
        {
            trypos++;
        }
    }
    else
    {
        trypos = filename;
    }

    /*
        Move trypos past the :<devname> or :<devname>. bit if it's there
    */
    if ( *trypos == ':' )
    {
        endpos = strchr( trypos, '.' );

        if ( endpos == NULL )
        {
            trypos = trypos + strlen( trypos );
        }
        else
        {
            trypos = endpos + 1;
        }
    }

    /*
         Move past the first component (and any $. &. %. @@. or \.)
    */
    if ( *trypos != '\0' )
    {
        switch( *trypos )
        {
        case '$':
        case '&':
        case '%':
        case '@@':
        case '\\':

            trypos ++;

            if ( *trypos == '.' )
                trypos++;

             /*
                Fall through to skipping over the next component
             */

        default:
            endpos = strchr( trypos, '.' );

            if ( endpos == NULL )
            {
                trypos = trypos + strlen( trypos );
            }
            else
            {
                trypos = endpos;
            }

            break;
        }
    }

    /*
         trypos now points past the first non-special component
         of the filename or at the terminating nul
    */

    return trypos;
}

static os_error *ensure_file_directories( char *filename )
{
    char *currpos;
    os_error *err;

    for ( currpos = first_dirbreak( filename );
          currpos && *currpos;
          currpos = strchr( currpos + 1, '.' ) )
    {
        *currpos = '\0';

        err = create_directory( filename );

        *currpos = '.';

        if ( err )
            return err;
    }

    return NULL;
}

/*
     Ensures files used by fh are closed, and ignores any errors it gets
     back. The destination file, if closed, will be truncated to the
     written_to size, and set to dead.
*/
static void ensure_files_closed( files_header *fh )
{
    if ( fh->destination_file_handle )
        close_file( &fh->destination_file_handle );

    if ( fh->source_file_handle )
        close_file( &fh->source_file_handle );
}

/*
     Totally junk an fh: remove it from the files chain
*/
static void remove_fh( files_header *fh )
{
    chain_remove_link( &fh->link );

    ensure_files_closed( fh );

    if ( fh->start_of_buffer + fh->read_to - fh->written_to >= buffer_top )
    {
        /*
            removing buffer at end
        */

        if ( fh->start_of_buffer < buffer_top )
            buffer_top = fh->start_of_buffer;
    }
    else
    {
        /*
            removing buffer at start
        */
        buffer_bottom += fh->read_to - fh->written_to;
    }

    if ( fh->source_filename )
        overflowing_free( fh->source_filename );

    overflowing_free( fh->destination_filename );
    overflowing_free( fh );
}

/*
     Assuming no buffer in buffer chain, and no open files, remove
     forwards file from files_chain.
*/
static void remove_file_from_chain( void )
{
    chain_link *link = files_chain.forwards;
    files_header *fh;

    if ( !link->forwards )
        return;

    fh = chain_link_Wrapper( link );

    /*
        Special indication that it has been a directory that's just
        been finished
    */
    if ( fh->objecttype == object_directory )
    {
        finished_obj_was_file = No;
    }
    else
    {
        finished_obj_was_file = Yes;
    }

    /*
        Record the source filename of the finished file
    */
    if ( finished_obj_source_name )
        overflowing_free( finished_obj_source_name );

    finished_obj_source_name = fh->source_filename;
    fh->source_filename = NULL;

    remove_fh( fh );
}

/*
     returns the files_handle of the next file to read
*/
static files_header *next_fh_to_read( void )
{
    chain_link *link;
    files_header *fh;

    for ( link = files_chain.forwards; link->forwards; link = link->forwards )
    {
        fh = chain_link_Wrapper( link );

        if ( fh->objecttype != object_directory &&
             ( fh->read_to < fh->size ||
               fh->source_file_handle ) )
        {
            return fh;
        }
    }

    return NULL;
}

/*
     skip a general file
*/
static void skip_file( files_header *fh )
{
    if ( fh == NULL )
        return;

    remove_fh( fh );
}

/*
     algorithms to grow and shrink block size on time out
*/

static int grow( int block )
{
    if ( block < 4096 )
    {
        block = (block + 1024) & ~1023;
    }
    else if ( block < 16384 )
    {
        block = (block + 4096) & ~4095;
    }
    else
    {
        block = (block + (block>>1)) & ~4095;
    }

    debugmem(( "grow: to %d\n", block ));

    return block;
}

static int shrink( int block )
{
    if ( block < 4096 )
    {
        block = (block - 256) & ~255;
    }
    else if ( block < 16384 )
    {
        block = (block - 1024) & ~1023;
    }
    else
    {
        block = (block - (block>>2)) & ~1023;
    }

    if ( block < minimum_block_size )
        block = minimum_block_size;

    debugmem(( "shrink: to %d\n", block ));

    return block;
}

/*
    Go through all readable files and discard their buffers if they overhang
    the top of the buffer
*/
static void truncate_overhanging_files( void )
{
    chain_link *link;
    files_header *fh;

    for ( link = files_chain.forwards; link->forwards; link = link->forwards )
    {
        fh = chain_link_Wrapper( link );

        if ( fh->objecttype != object_directory )
        {
            if ( fh->start_of_buffer >= buffer_top )
            {
                /*
                    file buffer starts beyond end of buffer
                */
                fh->start_of_buffer = 0;
                fh->read_to = fh->written_to;
            }
            else if ( fh->start_of_buffer + fh->read_to - fh->written_to > buffer_top )
            {
                /*
                    file buffer hangs over end of buffer
                */
                fh->read_to = buffer_top - (fh->start_of_buffer - fh->written_to);
            }
        }
    }
}

static int memmanage_slotextend( int n, void **p )
{
    int size_grown;
    int movement;

    size_grown = MinimumWorkingSize - (buffer_end + buffer_offset - n);
    if ( size_grown > 0 )
    {
        /*
            Not enough room in current slot, so try to extend
            If fail to extend then can't satisfy request
        */
        buffer_end += extend_application_slot( size_grown );

        if ( buffer_end + buffer_offset - n < MinimumWorkingSize )
            return 0;

        if ( application_max_size < (int)(buffer_base_address + buffer_offset + buffer_end) - 0x8000 )
            application_max_size = (int)(buffer_base_address + buffer_offset + buffer_end) - 0x8000;
    }

    if ( buffer_bottom + buffer_offset >= n )
    {
        /*
            Already enough room below used section - no action necessary
        */
    }
    else if ( buffer_bottom + buffer_offset + buffer_end - buffer_top >= n )
    {
        /*
            Enough room in unused space, but not enough room below
            used section so move used section of buffer up
            to make room.
        */
        memmove( buffer_base_address + n,
            buffer_base_address + buffer_bottom + buffer_offset,
            buffer_top - buffer_bottom );

        movement = n - (buffer_offset + buffer_bottom);
        buffer_end -= movement;
        buffer_offset += movement;
    }
    else
    {
        /*
            Not enough room in the available slot - try to extend
        */
        size_grown = n - (buffer_bottom + buffer_offset + buffer_end - buffer_top);

        (void)grow_buffer( &size_grown );

        memmove( buffer_base_address + n,
            buffer_base_address + buffer_bottom + buffer_offset,
            buffer_end + buffer_offset - n );

        movement = n - (buffer_offset + buffer_bottom);
        buffer_end -= movement;
        buffer_offset += movement;

        if ( buffer_top > buffer_end )
        {
            buffer_top = buffer_end;
            truncate_overhanging_files();
        }
    }

    *p = buffer_base_address;
    buffer_base_address += n;
    buffer_offset -= n;

    return n;
}

/*****************************************************************

Below here is the external interface stuff

*****************************************************************/

/*
     Set the slot size to that passed.
     Return an error if the wimp_slotsize failed or the slot size
      obtained is less than that requested.
*/
void action_slot( int size )
{
    int size_change = size - application_current_size();

    debugmem(( "action_slot: by %d to %d\n", size_change, size ));

    if ( size_change > 0 )
    {
        /*
            Grow slot
        */
        buffer_end += extend_application_slot( size_change );
    }
    else if ( size_change < 0 )
    {
        /*
            Shrink slot
        */

        /*
            Lower-bound size change to ensure we still have MinimumWorkingSize
        */
        if ( buffer_end + buffer_offset + size_change < MinimumWorkingSize )
            size_change = MinimumWorkingSize - buffer_end - buffer_offset;

        if ( buffer_top > buffer_end + size_change )
        {
            /*
                Ensure the data is at the bottom of the buffer area
            */
            debugmem(( "action_slot: Base=%#010x, offset=%d, bottom=%d, top=%d, end=%d\n", (int)buffer_base_address, buffer_offset, buffer_bottom, buffer_top, buffer_end ));
            memmove(
                buffer_base_address,
                buffer_base_address + buffer_bottom + buffer_offset,
                buffer_top - buffer_bottom );

            buffer_end += buffer_bottom + buffer_offset;
            buffer_offset -= buffer_bottom + buffer_offset;
        }

        size_change = extend_application_slot( size_change );

        /*
            Adjust buffer_end by actual amount changed by
        */
        buffer_end += size_change;

        /*
            Upper bound buffer_top by buffer_end
        */
        if ( buffer_top > buffer_end )
            buffer_top = buffer_end;
    }

    truncate_overhanging_files();

    application_max_size = (int)(buffer_base_address + buffer_offset + buffer_end) - 0x8000;
    debugmem(( "action_slot: app max size %d\n", application_max_size ));
    debugmem(( "action_slot: Base=%#010x, offset=%d, bottom=%d, top=%d, end=%d\n", (int)buffer_base_address, buffer_offset, buffer_bottom, buffer_top, buffer_end ));
}

/*
     Initialise to end in suitable place for closedown
*/
os_error *init_memmanagement( void )
{
    /*
        Things that use real memory ( base = null )
    */
    chain_initialise_header( &files_chain );

    /*
        This determines the maximum size we will allow buffer
        allocation to grow to. This starts at the
        current next slot size, then gets adjusted when the
        user drags the memory slider
    */
    application_max_size = current_next_slot();

    /*
        The buffer area
    */
    buffer_base_address = (char *)(application_current_size() + 0x8000);
    buffer_offset = 0;
    buffer_bottom = 0;
    buffer_top = 0;
    buffer_end = 0;

    finished_obj_source_name = NULL;

    (void)_kernel_register_slotextend( memmanage_slotextend );

    return NULL;
}

/*
     Get into a fit state for copying. The chains and area
     pointers should already been zeroed out by calling
     init_memmangement. This routine starts off flex and heap,
     which grab more wimp space, which is why this part of the
     initialisation is left out of the general initialisation
     sequence. The routine also tries to grab a buffer, just to
     make sure this is feasible. No buffer => No copying!
*/
os_error *init_for_copying( void )
{
#if Timing
    copytime = clock();
#endif
    src_block_size = InitialBlockSize;
    dest_block_size = InitialBlockSize;
    timing_init();

    if ( buffer_ensure( MinimumWorkingSize ) )
    {
        if ( application_max_size < application_current_size() )
            application_max_size = application_current_size();

        return NULL;
    }
    else
    {
        return error( mb_slotsize_too_small ); /* was mb_malloc_failed */
    }
}

/*
     Misc. ESSENTIAL tidying up:
      Close down any open files
*/
void closedown_memmanagement( void )
{
    chain_link *link;
    files_header *fh;

    for ( link = files_chain.forwards; link->forwards; link = link->forwards )
    {
        fh = chain_link_Wrapper( link );

        ensure_files_closed( fh );
    }
#if Timing
    copytime = clock() - copytime;
    werr(0, "time taken for file copy = %d.%02ds", copytime/100, copytime%100);
#endif
#ifdef debug
#ifdef debugfile
    if ( debugf != NULL ) fclose( debugf );
#endif
#endif
}

/*
     Add a file to the end of the files chain
*/
os_error *add_file_to_chain( char *destination, char *source,
                             uint32_t size, int reload, int execute, int attributes, int objecttype,
                             BOOL forceit, BOOL *i_am_full
                             #ifdef USE_PROGRESS_BAR
                             , uint32_t progress, void **ref
                             #endif
                           )
{
    files_header *fh;

    fh = overflowing_malloc( sizeof( files_header ));
    if ( fh )
    {
        fh->source_filename = overflowing_malloc( strlen( source ) + 1 );

        if ( fh->source_filename )
        {
            fh->destination_filename = overflowing_malloc( strlen( destination ) + 1 );

            if ( fh->destination_filename )
            {
                /*
                     Initialise the structure
                */
                strcpy( fh->source_filename, source );
                fh->source_file_handle = 0;
                strcpy( fh->destination_filename, destination );
                fh->destination_file_handle = 0;
                fh->size = size;
                fh->reload = reload;
                fh->execute = execute;
                fh->attributes = attributes;
                fh->objecttype = objecttype;
                fh->forceit = forceit;
                fh->read_to = 0;
                fh->written_to = 0;
                fh->write_state = write_not_started;
                fh->start_of_buffer = 0;

                #ifdef USE_PROGRESS_BAR
                fh->total_progress = progress / 2;
                fh->write_progress = fh->read_progress = fh->total_progress;
                if (ref != NULL) *ref = fh;
                debugmem(( "add_file_to_chain: %s type %d progress %08x\n", destination, objecttype, fh->total_progress ));
                #endif

                /*
                     link to backwards end of files chain
                */
                chain_insert_before_header( &fh->link, fh, &files_chain );

                *i_am_full = No;

                return NULL;
            }

            overflowing_free( fh->source_filename );
        }

        overflowing_free( fh );
    }

    *i_am_full = Yes;

    /*
         one of the heap_allocs failed
    */
    return error( mb_malloc_failed );
}


#ifdef USE_PROGRESS_BAR
void modify_chain_file_progress(void *ref, uint32_t progress)
{
  files_header *fh = (files_header *)ref;

  if (fh != NULL)
  {
    debugmem(( "\nmodify chain: %s %x\n", fh->destination_filename, progress ));
    fh->write_progress = fh->total_progress = progress;
  }
}
#endif


/* Modified to return the progress value of the finished file	*/
os_error *read_a_block( BOOL *i_am_full, BOOL *need_another_file, BOOL *that_finished_a_file, uint32_t *progress )
{
    files_header *fh;
    os_regset    r;
    os_error     *err;
    os_gbpbstr   gbpbplace;
    int          size_needed;
    uint32_t     start_read_to;
    clock_t      t;

    *i_am_full = No;
    *that_finished_a_file = No;

    fh = next_fh_to_read();

    if ( !fh )
    {
        *need_another_file = Yes;

        return NULL;
    }

    *need_another_file = No;

    debugmem(( "read_a_block: from %s\n", fh->source_filename ));

    start_read_to = fh->read_to;

    /*
         If we have to do some reading
    */
    if ( fh->read_to < fh->size )
    {
        debugmem(( "R" ));
        /*
            Work out how much buffer is needed...
        */

        /*
            Upper bound to src_block_size and amount to read in file
        */
        if ( fh->size - fh->read_to > src_block_size )
        {
            size_needed = src_block_size;
        }
        else
        {
            /* This calculation fits in a signed integer provided src_block_size < 2G */
            size_needed = fh->size - fh->read_to;
        }

        /*
             Ensure word-alignment of file ptr and buffer address
             equal, to ensure DMA operation on DMA-capable disc
             systems (eg Iyonix ADFS).
        */
        if ( fh->read_to == fh->written_to &&
             (buffer_top & 3) != (fh->read_to & 3) )
        {
            int pad = ((fh->read_to & 3) - (buffer_top & 3)) & 3;
            *i_am_full = grow_buffer( &pad );
            if ( pad <= 0)
                return NULL;
            buffer_top += pad;
        }
        /*
             Enlarge the buffer (if possible)
        */
        *i_am_full = grow_buffer( &size_needed );

        if ( size_needed <= 0 )
            return NULL;

        /*
            Set up new buffer
        */
        if ( fh->read_to == fh->written_to )
        {
            fh->start_of_buffer = buffer_top;
        }

        /*
             Sub-optimal case: read file in chunks

             If the file isn't open yet, then open it
        */
        if ( fh->source_file_handle == 0 )
        {
            debugmem(( "O" ));
            r.r[0] = open_read | open_nopath | open_nodir | open_mustopen;
            r.r[1] = (int)fh->source_filename;

            err = os_find( &r );

            if ( err )
                return err;

            fh->source_file_handle = r.r[0];
        }

        t = clock();

        /*
            Read a block into the buffer.
        */
        gbpbplace.action = OSGBPB_ReadFromGiven;
        gbpbplace.file_handle = fh->source_file_handle;
        gbpbplace.data_addr = buffer_base_address + buffer_offset + buffer_top;
        gbpbplace.number = size_needed;
        gbpbplace.seq_point = fh->read_to;

        debugmem(( "read_a_block: buf %x + %u [%u-%u]\n", buffer_base_address, buffer_offset,
                                                          buffer_bottom, buffer_top ));
        debugmem(( "read_a_block: (%d,%d<-%d)\n", gbpbplace.data_addr, gbpbplace.number, gbpbplace.seq_point ));

        err = os_gbpb( &gbpbplace );
        if ( err )
            return err;

        fh->read_to += size_needed;
        buffer_top += size_needed;

        if (src_block_size == size_needed)
        {  /* only time full block transfers */
            t = clock() - t;
            if ( timing_accumulating(timing_Reading) )
            { /* accumulating initial timings */
                assert(src_block_size == InitialBlockSize);
                timing_accumulate(timing_Reading, t, src_block_size);
            }
            else if (time_quanta < MaxTimeQuanta)
            {
                if ( (src_block_size <= SmallBlockSize)
                  && timing_poorrate(timing_Reading, t, src_block_size) )
                { /* if the transfer rate is suffering at this small blocksize,
                   * increase time_quanta to cause the blocksize to grow */
                    if (time_quanta < MaxTimeQuanta) time_quanta *= 2;
                    debugmem(( "read_a_block: time_quanta to %d\n", time_quanta));
                }
                if ( t < time_quanta - TimeQuantaHysteresis) src_block_size = grow( src_block_size );
                if ( t > time_quanta + TimeQuantaHysteresis) src_block_size = shrink( src_block_size );
            }
        }

        if ( fh->read_to >= fh->size )
        {
            debugmem(( "C" ));
            err = close_file( &fh->source_file_handle );
            if ( err )
                return err;
        }
    }

    /*
         If we've finished reading the file
    */
    if ( fh->read_to >= fh->size )
    {
        *that_finished_a_file = Yes;

        #ifdef USE_PROGRESS_BAR
        *progress = fh->read_progress;
        #else
        IGNORE(progress);
        #endif

        /*
            If there isn't another file to read, tell the client about
            it now.
        */
        if ( next_fh_to_read() == NULL )
            *need_another_file = Yes;
    }
    #ifdef USE_PROGRESS_BAR
    else
    {
        uint64_t p;
        uint32_t b;

        b = fh->read_to - start_read_to; /* bytes read this time */
        p = (fh->total_progress * (uint64_t)b) / fh->size;

        fh->read_progress -= (uint32_t) p;
        *progress = (uint32_t) p;

        debugmem(( "partial read: %u bytes / %u = %08x progress\n", b, fh->size, *progress ));
    }
    #endif

    debugmem(( "X\n" ));

    return NULL;
}

void skip_file_read( void )
{
    skip_file( next_fh_to_read() );
}

static os_error *int_write_a_block( BOOL *i_am_empty, BOOL *that_finished_a_file, uint32_t *progress )
{
    os_gbpbstr   gbpbplace;
    os_filestr   fileplace;
    files_header *fh;
    os_regset    r;
    os_error     *err = NULL;
    int          amount_to_write;
    uint32_t     start_written_to;
    clock_t      t;
    static BOOL  dont_set_dir_info = No;

    *i_am_empty = No;
    *that_finished_a_file = No;

    /*
        no more files to write?
    */
    if ( !files_chain.forwards->forwards )
    {
        *i_am_empty = Yes;

        return NULL;
    }

    fh = chain_link_Wrapper( files_chain.forwards );

    debugmem(( "int_write_a_block to %s\n", fh->destination_filename ));

    /*
        no more buffer to write when there's more file to write?
    */
    if ( fh->objecttype != object_directory &&
        fh->read_to - fh->written_to == 0 &&
        fh->written_to < fh->size )
    {
        *i_am_empty = Yes;

        return NULL;
    }

    start_written_to = fh->written_to;

    debugmem(( "W" ));

    /*
        amount_to_write is lesser of a dest_block_size and the amount buffered of the file
    */
    if ( fh->read_to - fh->written_to > dest_block_size )
    {
        amount_to_write = dest_block_size;
    }
    else
    {
        /* This calculation fits in a signed integer provided dest_block_size < 2G */
        amount_to_write = fh->read_to - fh->written_to;
    }

    while ( !err &&
           ( fh->write_state == write_not_started ||
         fh->write_state == write_f_tried_unlock ||
         fh->write_state == write_f_tried_cdirs ||
         fh->write_state == write_f_tried_both ))
    {
        if ( fh->objecttype == object_directory )
        {
            debugmem(( "D" ));
            /*
                Start up directory
            */
            err = create_directory( fh->destination_filename );

            if ( !err )
                fh->write_state = dont_set_dir_info ?
                            write_adjust_access :
                            write_adjust_info;
        }
        else
        {
            /*
                Start up file (or partition)
            */
            if ( fh->size <= amount_to_write )
            {
                debugmem(( "S" ));
                /*
                    Optimised case - try save
                */
                fileplace.action = OSFile_Save;
                fileplace.name = fh->destination_filename;
                fileplace.loadaddr = fh->reload;
                fileplace.execaddr = fh->execute;
                fileplace.start = (int)(buffer_base_address + buffer_offset + fh->start_of_buffer);
                fileplace.end = fileplace.start + fh->size;

                err = os_file( &fileplace );

                if ( !err )
                {
                    fh->written_to = fh->size;
                    fh->start_of_buffer += fh->size;
                    buffer_bottom += fh->size;

                    fh->write_state = write_adjust_access;
                }
            }
            else
            {
                debugmem(( "c" ));
                /*
                    Sub-optimal case - open, GBPB, close
                */
                err = create_file_dead( fh->destination_filename, fh->size );

                if ( !err )
                {
                    fh->write_state = write_openit;
                }
            }
        }

        if ( err )
        {
            if ( (err->errnum & FileError_Mask) == ErrorNumber_Locked &&
                fh->forceit &&
                fh->write_state != write_f_tried_unlock &&
                fh->write_state != write_f_tried_both )
            {
                /*
                    We haven't tried unlocking yet - give it a go
                */
                fileplace.action = OSFile_WriteAttr;
                fileplace.name = fh->destination_filename;
                fileplace.end = read_attribute | write_attribute;

                os_file( &fileplace );  /* ignore any error back */

                err = NULL;

                if ( fh->write_state == write_not_started )
                    fh->write_state = write_f_tried_unlock;
                else if ( fh->write_state == write_f_tried_cdirs )
                    fh->write_state = write_f_tried_both;
            }
            else if ( ((err->errnum & FileError_Mask) == ErrorNumber_NotFound ||
                   err->errnum == ErrorNumber_CantOpenFile) &&
                   fh->write_state != write_f_tried_cdirs &&
                   fh->write_state != write_f_tried_both )
            {
                /*
                    We haven't tried cdirs yet - give it a go
                */
                err = ensure_file_directories( fh->destination_filename );

                if ( !err )
                {
                    /*
                        no error - try opening/saving again, but don't retry cdirs on fail
                    */
                    if ( fh->write_state == write_not_started )
                        fh->write_state = write_f_tried_cdirs;
                    else if ( fh->write_state == write_f_tried_unlock )
                        fh->write_state = write_f_tried_both;
                }
            }
        }
    }

    if ( !err && fh->write_state == write_openit )
    {
        debugmem(( "O" ));
        /*
            Open it up. The file has been successfully created if we're here, so
            any failures at this point are bad news.
        */
        r.r[0] = open_update | open_nopath | open_nodir | open_mustopen;
        r.r[1] = (int)fh->destination_filename;

        err = os_find( &r );

        if ( !err )
        {
            fh->write_state = write_truncateopen;
            fh->destination_file_handle = r.r[0];
        }
    }

    if ( !err && fh->write_state == write_truncateopen )
    {
        debugmem(( "T" ));
        /*
            Once the file's open set its extent to 0. This
            prevents FileSwitch loading before update on
            blocks of the file.
        */
        r.r[0] = OSArgs_SetEXT;
        r.r[1] = (int)fh->destination_file_handle;
        r.r[2] = 0; /* to 0 */

        err = os_args( &r );

        if ( !err )
        {
            fh->write_state = write_blocks;
        }
    }

    if ( !err && fh->write_state == write_blocks )
    {
        /*
            Write a block out
        */
        gbpbplace.action = OSGBPB_WriteAtGiven;
        gbpbplace.file_handle = fh->destination_file_handle;
        gbpbplace.data_addr = buffer_base_address + buffer_offset + fh->start_of_buffer;
        gbpbplace.number = amount_to_write;
        gbpbplace.seq_point = fh->written_to;

        debugmem(( "int_write_a_block: buf %x + %d [%d-%d]\n", buffer_base_address, buffer_offset,
                                                               buffer_bottom, buffer_top ));
        debugmem(( "int_write_a_block: w(%d,%u->%u)", (int)gbpbplace.data_addr, gbpbplace.number, gbpbplace.seq_point ));

        t = clock();

        err = os_gbpb( &gbpbplace );

        if ( !err )
        {
            if (dest_block_size == amount_to_write)
            {  /* only time full block transfers */
                t = clock() - t;
                if ( timing_accumulating(timing_Writing) )
                { /* accumulating initial timings */
                    assert(dest_block_size == InitialBlockSize);
                    timing_accumulate(timing_Writing, t, dest_block_size);
                }
                else
                {
                    if ( (dest_block_size <= SmallBlockSize)
                      && timing_poorrate(timing_Writing, t, dest_block_size) )
                    { /* if the transfer rate is suffering at this small blocksize,
                       * increase time_quanta to cause the blocksize to grow */
                        if (time_quanta < MaxTimeQuanta) time_quanta *= 2;
                        debugmem(( "int_write_a_block: time_quanta to %d\n", time_quanta ));
                    }
                    if ( t < time_quanta - TimeQuantaHysteresis) dest_block_size = grow( dest_block_size );
                    if ( t > time_quanta + TimeQuantaHysteresis) dest_block_size = shrink( dest_block_size );
                }
            }
            fh->written_to += amount_to_write;
            fh->start_of_buffer += amount_to_write;
            buffer_bottom += amount_to_write;

            if ( fh->written_to >= fh->size )
                fh->write_state = write_closeit;
        }
    }

    if ( !err && fh->write_state == write_closeit )
    {
        debugmem(( "C" ));
        err = close_file( &fh->destination_file_handle );

        /*
            Regardless of whether the close worked, the file will be closed,
            so always move onto adjusting the file's info
        */
        fh->write_state = write_adjust_info;
    }

    if ( !err && fh->write_state == write_adjust_info )
    {
        debugmem(( "I" ));
        /*
            Always adjust the info as it's almost always wrong
        */
        err = write_catalogue_information(
              fh->destination_filename,
              fh->objecttype,
              fh->reload,
              fh->execute,
              fh->attributes );

        if ( err && fh->objecttype == object_directory)
        {
            /* Some FS's can't do this for a directory - back
               off to just doing the access permission.
             */
            err = NULL;
            dont_set_dir_info = Yes;
            fh->write_state = write_adjust_access;
        }
        else if ( !err )
            fh->write_state = write_all_done;
    }

    if ( !err && fh->write_state == write_adjust_access )
    {
        debugmem(( "A" ));
        /*
            Only adjust attributes if they're non-default ones
        */
        err = write_attributes(
              fh->destination_filename,
              fh->attributes );

        if ( !err )
            fh->write_state = write_all_done;
    }

    if ( !err && fh->write_state == write_all_done )
    {
        *that_finished_a_file = Yes;
        #ifdef USE_PROGRESS_BAR
        *progress = fh->write_progress;
        #else
        IGNORE(progress);
        #endif

        remove_file_from_chain();
    }
    #ifdef USE_PROGRESS_BAR
    else
    {
        uint64_t p;
        uint32_t b;

        if ( err ) return err;

        b = fh->written_to - start_written_to; /* bytes written this time */
        p = (fh->total_progress * (uint64_t)b) / fh->size;
        
        fh->write_progress -= (uint32_t) p;
        *progress = (uint32_t) p;
        
        debugmem(( "partial write: %u bytes / %u = %08x progress\n", b, fh->size, *progress ));
    }
    #endif

    debugmem(( "X\n" ));

    return err;
}


os_error *write_a_block( BOOL *i_am_empty, BOOL *that_finished_a_file, uint32_t *progress )
{
    os_error *err = int_write_a_block( i_am_empty, that_finished_a_file, progress );

    if ( *i_am_empty )
    {
        buffer_end += buffer_offset;
        buffer_offset = buffer_bottom = buffer_top = 0;
    }

    return err;
}

void skip_file_write( void )
{
    if ( files_chain.forwards->forwards )
    {
        skip_file( chain_link_Wrapper( files_chain.forwards ));
    }
}

char *next_file_to_be_written( void )
{
    files_header *fh;

    if ( files_chain.forwards->forwards )
    {
        fh = chain_link_Wrapper( files_chain.forwards );

        return fh->destination_filename;
    }
    else
    {
        return NULL;
    }
}

char *next_file_to_be_read( void )
{
    files_header *fh = next_fh_to_read();

    if ( fh != NULL )
        return fh->source_filename;
    else
        return NULL;
}

void restart_file_read( void )
{
    files_header *fh = next_fh_to_read();

    debugmem(( "restart_file_read: fh=&08X\n", (int)fh ));

    if ( fh != NULL )
    {
        ensure_files_closed( fh );
        buffer_top -= fh->read_to;
        if ( buffer_top < 0 ) buffer_bottom = buffer_top = buffer_offset = 0;
        fh->read_to = 0;
        fh->written_to = 0;
        fh->write_state = write_not_started;
    }
}

void restart_file_write( void )
{
    files_header *fh = chain_link_Wrapper( files_chain.forwards );

    debugmem(( "restart_file_write: fh=&08X\n", (int)fh ));

    if ( fh != NULL )
    {
        /* Only restart file if we still have all of its contents so far.
         * If we don't then we can't just read from the start because we might
         * overwrite another file's data so just do nothing (== retry).
         */
        int file_start = fh->start_of_buffer - fh->written_to;
        if ( file_start >= 0 )
        {
            ensure_files_closed( fh );
            fh->start_of_buffer = file_start;
            buffer_bottom -= fh->written_to;
            fh->written_to = 0;
            fh->write_state = write_not_started;
            debugmem(( "restart_file_write: start_of_buffer=%08X, buffer_bottom=%08X\n", fh->start_of_buffer, buffer_bottom ));
        }
    }
}

uint32_t bytes_left_to_read( void )
{
    files_header *fh = next_fh_to_read();

    if ( fh )
    {
        return fh->size - fh->read_to;
    }
    else
    {
        return 0;
    }
}

uint32_t bytes_left_to_write( void )
{
    files_header *fh;

    if ( files_chain.forwards->forwards )
    {
        fh = chain_link_Wrapper( files_chain.forwards );

        return fh->size - fh->written_to;
    }
    else
    {
        return 0;
    }
}

void copy_go_faster( BOOL do_it )
{
    if ( do_it )
    {
        /*
            Go faster
        */

        time_quanta = MaxTimeQuanta;      /* centi-seconds */

        minimum_block_size = 15*1024; /* bytes: optimised for econet */

        if ( src_block_size < minimum_block_size )
            src_block_size = minimum_block_size;
        if ( dest_block_size < minimum_block_size )
            dest_block_size = minimum_block_size;
    }
    else
    {
        /*
            Go slower
        */

        time_quanta = NominalTimeQuanta;

        minimum_block_size = 512;
    }
}
@


4.11
log
@Fix file type not being applied when copying image files
Detail:
  c/memmanage - An earlier fix to prevent directory filetypes being applied to image files had the unintended side-effect of stopping image file types being applied to anything other than an existing image file.
  Check has now been revised to only limit the application of directory types to image files; there's no need to worry about image file types being applied to directories, as the filer won't let you copy a (image) file over a directory in the first place.
Admin:
  Tested on Raspberry Pi with high processor vectors


Version 0.58. Tagged as 'FilerAct-0_58'
@
text
@d1250 1
a1250 1

a1251 1
    }
d1264 1
a1265 1
    }
d1597 1
a1597 1

a1598 1
    }
d1601 2
a1602 2
      uint64_t p;
      uint32_t b;
d1604 1
a1604 2
      b = fh->written_to - start_written_to;
      p = (fh->total_progress * (uint64_t)b) / fh->size;
d1606 8
a1613 4
      fh->write_progress -= (uint32_t) p;
      *progress = (uint32_t) p;

      debugmem(( "partial write: %u bytes / %u = %08x progress\n", b, fh->size, *progress ));
a1614 1
    }
@


4.10
log
@  No longer trashes filetype and user access bits when copying a directory over an image file
Detail:
  Was doing a cimple copy of the load/execution and attribute words from the
  source to the destination. However, for directories the filetype bits in the
  load address are always &FFD (data) and the user access bits are always 0
  (even though all directories actually have user read/write access). Now
  these bits are left alone when updating an image file from a directory.
Admin:
  Tested on a Raspberry Pi, doing a partial update of !Boot.Loader image file.

Version 0.57. Tagged as 'FilerAct-0_57'
@
text
@d391 1
a391 1
    if (objecttype & object_directory)
d393 1
a393 1
        /* Check if we're copying an image file's information from a directory or vice versa */
@


4.9
log
@Fix to work with files > 2G.
A good rake over the code to change filesizes to be uint32_t not ints.
Change makefile to use StdTools.
Shuffle icon clipping in the templates to allow for maximal numbers by moving the text a bit to the right, still fits even in system font.
A couple more ints swapped for BOOLs.
The memmanage code is largely unchanged and makes extensive use of signed numbers, partly because the wimpslot setting API does. This will all fall over in a big mess if the wimpslot ever gets >2G, but then the API would need changing for that to happen anyway.
Function count_objects_in_dir swapped to use os_gbpb.
Structure search_nest_level gains a 'counted' flag rather than signalling counting is needed by setting the filesize to -1.
Should now be good for up to 4 billion files each of 4 billion bytes.

Version 0.54. Tagged as 'FilerAct-0_54'
@
text
@d387 1
a387 1
static os_error *write_catalogue_information( char *filename, int reload, int execute, int attributes )
d391 17
d1556 1
@


4.8
log
@Swap magic constants for defines from headers.
OS_FSControl, OS_File, OS_GBPB, OS_Args, OS_Find now use HighFSI.h.
Indentation made more consistent.
Variety of DEBUG macros changed to allow them to be enabled and disabled on a per-file basis.
Put USE_RED_ERROR box switch into options.h (undefined though).
Functionally equivalent to 0.52, but lots of diffs.

Version 0.53. Tagged as 'FilerAct-0_53'
@
text
@d142 3
a144 1
    unsigned int total_progress, read_progress, write_progress;
d154 2
a155 2
static int buffer_offset;               /* offset to add to botom, top, and any other offsets into the area */
                                    /* used when the area contents are shuffled */
a158 1
static int last_requested_size;
d179 5
a183 5
  {
  int rate; /* transfer rate calculated from accumulator and blocksize */
  int accumulator;
  int naccumulated;
  } timing[2]; /* read and write initial timing */
d288 1
a288 1
static BOOL buffer_ensure( uint32_t size )
d290 1
a290 1
    if ( (uint32_t)(buffer_end - buffer_top) < size )
d292 1
a292 1
        buffer_end += extend_application_slot( size - (uint32_t)(buffer_end - buffer_top) );
d295 1
a295 1
    return (uint32_t)(buffer_end - buffer_top) >= size;
d352 1
a352 1
static os_error *create_file_dead( char *filename, int size )
d362 1
a362 1
    fileplace.end      = size;
d577 1
d892 1
a892 1
        This determins the maximum size we will allow buffer
a907 6
    /*
        A cludge to stop memory size dragging from oscillating
        about a non-memory block size boundary.
    */
    last_requested_size = -1;

d979 1
a979 1
                             , unsigned int progress, void **ref
d1047 1
a1047 1
void modify_chain_file_progress(void *ref, unsigned int progress)
d1061 1
a1061 1
os_error *read_a_block( BOOL *i_am_full, BOOL *need_another_file, BOOL *that_finished_a_file, unsigned int *progress )
d1064 6
a1069 5
    os_regset r;
    os_error *err;
    os_gbpbstr gbpbplace;
    int size_needed, start_read_to;
    clock_t t;
d1108 1
a1141 2
#if 0
/* Using OS_GBPB is faster if the file is already open */
d1143 3
a1145 2
            If haven't already started on the open-gbpb-close sequence AND
                file size fits into buffer allowed
d1147 1
a1147 1
        if ( fh->read_to == 0 && fh->size <= size_needed )
d1149 3
a1151 13
            /*
                If were reading by blocks, but now decided its OK to read by whole file
            */
            if ( fh->source_file_handle )
                close_file( &fh->source_file_handle );

            /*
                optimal read case: enough ram to read whole file
            */
            fileplace.action = OSFile_LoadNoPath; /* load file */
            fileplace.name = fh->source_filename;
            fileplace.loadaddr = (int)(buffer_base_address + buffer_offset + fh->start_of_buffer);
            fileplace.execaddr = 0;
d1153 1
a1153 1
            err = os_file( &fileplace );
d1158 1
a1158 2
            fh->read_to = fh->size;
            buffer_top += fh->size;
a1159 5
        else
#endif
        {
            /*
                 Sub-optimal case: read file in chunks
d1161 14
a1174 7
                 If the file isn't open yet, then open it
            */
            if ( fh->source_file_handle == 0 )
            {
                debugmem(( "O" ));
                r.r[0] = open_read | open_nopath | open_nodir | open_mustopen;
                r.r[1] = (int)fh->source_filename;
d1176 3
a1178 1
                err = os_find( &r );
d1180 2
a1181 2
                if ( err )
                    return err;
d1183 7
a1189 1
                fh->source_file_handle = r.r[0];
d1191 13
d1205 4
a1208 16
            t = clock();

            /*
                Read a block into the buffer.
            */
            gbpbplace.action = OSGBPB_ReadFromGiven;
            gbpbplace.file_handle = fh->source_file_handle;
            gbpbplace.data_addr = buffer_base_address + buffer_offset + buffer_top;
            gbpbplace.number = size_needed;
            gbpbplace.seq_point = fh->read_to;

            debugmem(( "read_a_block: buf %x + %u [%u-%u]\n", buffer_base_address, buffer_offset,
                                                              buffer_bottom, buffer_top ));
            debugmem(( "read_a_block: (%d,%d<-%d)\n", gbpbplace.data_addr, gbpbplace.number, gbpbplace.seq_point ));

            err = os_gbpb( &gbpbplace );
a1210 33

            fh->read_to += size_needed;
            buffer_top += size_needed;

            if (src_block_size == size_needed)
            {  /* only time full block transfers */
                t = clock() - t;
                if ( timing_accumulating(timing_Reading) )
                { /* accumulating initial timings */
                    assert(src_block_size == InitialBlockSize);
                    timing_accumulate(timing_Reading, t, src_block_size);
                }
                else if (time_quanta < MaxTimeQuanta)
                {
                    if ( (src_block_size <= SmallBlockSize)
                      && timing_poorrate(timing_Reading, t, src_block_size) )
                    { /* if the transfer rate is suffering at this small blocksize,
                       * increase time_quanta to cause the blocksize to grow */
                        if (time_quanta < MaxTimeQuanta) time_quanta *= 2;
                        debugmem(( "read_a_block: time_quanta to %d\n", time_quanta));
                    }
                    if ( t < time_quanta - TimeQuantaHysteresis) src_block_size = grow( src_block_size );
                    if ( t > time_quanta + TimeQuantaHysteresis) src_block_size = shrink( src_block_size );
                }
            }

            if ( fh->read_to >= fh->size )
            {
                debugmem(( "C" ));
                err = close_file( &fh->source_file_handle );
                if ( err )
                    return err;
            }
d1244 2
a1245 2
        fh->read_progress -= (unsigned int) p;
        *progress = (unsigned int) p;
d1261 1
a1261 2

static os_error *int_write_a_block( BOOL *i_am_empty, BOOL *that_finished_a_file, unsigned int *progress )
d1263 2
a1264 2
    os_gbpbstr gbpbplace;
    os_filestr fileplace;
d1266 6
a1271 5
    os_regset r;
    os_error *err = NULL;
    int amount_to_write, start_written_to;
    clock_t t;
    static BOOL dont_set_dir_info = No;
d1315 1
d1479 1
a1479 1
        debugmem(( "int_write_a_block: buf %x + %u [%u-%u]\n", buffer_base_address, buffer_offset,
d1481 1
a1481 1
        debugmem(( "int_write_a_block: w(%d,%d->%d)", (int)gbpbplace.data_addr, gbpbplace.number, gbpbplace.seq_point ));
d1591 2
a1592 2
      fh->write_progress -= (unsigned int) p;
      *progress = (unsigned int) p;
d1604 1
a1604 1
os_error *write_a_block( BOOL *i_am_empty, BOOL *that_finished_a_file, unsigned int *progress )
@


4.7
log
@More BOOLs and things changed to C99 types.
Basically the same as version 0.51 otherwise.

Version 0.52. Tagged as 'FilerAct-0_52'
@
text
@d67 3
a69 1
#define debugmem
d79 1
a97 5
#define ObjectType_NotFound   0
#define ObjectType_File       1
#define ObjectType_Directory  2


d130 1
a130 1
    int             size;
d135 3
a137 3
    int             forceit;
    int             read_to;
    int             written_to;
d201 2
a202 3
#ifdef debugmem
dprintf("calcrate %d,%d->%d\n", accumulated_time, blocksize,(blocksize<<8) / accumulated_time);
#endif
d274 1
a274 3
#ifdef debugmem
dprintf("extend_application_slot: amount = %d, new size = %d\n",amount,currentslot);
#endif
d287 1
a287 1
static int buffer_ensure( int size )
d289 1
a289 1
    if ( buffer_end - buffer_top < size )
d291 1
a291 1
        buffer_end += extend_application_slot( size - (buffer_end - buffer_top) );
d294 1
a294 1
    return buffer_end - buffer_top >= size;
d356 1
a356 1
    fileplace.action   = 7; /* create a file */
d368 1
a368 1
    fileplace.action = 4; /* set access to a file */
d370 1
a370 1
    fileplace.end = 0x3; /* read/write only */
d379 1
a379 1
    fileplace.action = 8; /* create a directory */
d390 1
a390 1
    fileplace.action    = 1; /* write catalogue information */
d403 1
a403 1
    fileplace.action    = 4; /* write attributes */
d598 1
a598 1
    if ( fh->objecttype == ObjectType_Directory )
d631 1
a631 1
        if ( fh->objecttype != ObjectType_Directory &&
d672 1
a672 3
#ifdef debugmem
dprintf( "growing to %d\n", block );
#endif
d695 1
a695 3
#ifdef debugmem
dprintf( "shrinking to %d\n", block );
#endif
d713 1
a713 1
        if ( fh->objecttype != ObjectType_Directory )
d822 1
a822 3
#ifdef debugmem
dprintf( "Change slot by %d to %d\n", size_change, size );
#endif
d848 1
a848 3
#ifdef debugmem
dprintf( "Base=%#010x, offset=%d, bottom=%d, top=%d, end=%d\n", (int)buffer_base_address, buffer_offset, buffer_bottom, buffer_top, buffer_end );
#endif
d875 2
a876 4
#ifdef debugmem
dprintf( "Application max size is now %d\n", application_max_size );
dprintf( "Base=%#010x, offset=%d, bottom=%d, top=%d, end=%d\n", (int)buffer_base_address, buffer_offset, buffer_bottom, buffer_top, buffer_end );
#endif
d980 1
a980 1
                             int size, int reload, int execute, int attributes, int objecttype,
d1022 1
a1022 1
                DEBUG(("add_file_to_chain: %s type %d progress %08x\n", destination, objecttype, fh->total_progress));
d1057 1
a1057 1
    DEBUG(("\nmodify chain: %s %x\n", fh->destination_filename, progress));
d1088 1
a1088 3
#ifdef debugmem
dprintf( "read_a_block from %s\n", fh->source_filename );
#endif
d1097 1
a1097 3
#ifdef debugmem
dprintf( "R" );
#endif
d1161 1
a1161 1
            fileplace.action = 16; /* load file */
d1184 2
a1185 4
#ifdef debugmem
dprintf( "O" );
#endif
                r.r[0] = 0x4f;
d1201 1
a1201 1
            gbpbplace.action = 3; /* read bytes from file at position */
d1207 3
a1209 3
#ifdef debugmem
dprintf( "r(%d,%d<-%d)", gbpbplace.data_addr, gbpbplace.number, gbpbplace.seq_point );
#endif
d1233 1
a1233 3
#ifdef debugmem
dprintf("change time_quanta to %d\n", time_quanta);
#endif
d1242 1
a1242 3
#ifdef debugmem
dprintf( "C" );
#endif
d1283 1
a1283 1
        DEBUG(("partial read: %d bytes / %d = %08x progress\n", (int)b, fh->size, p));
d1287 1
a1287 4

#ifdef debugmem
dprintf( "X\n" );
#endif
d1324 1
a1324 3
#ifdef debugmem
dprintf( "int_write_a_block to %s\n", fh->destination_filename );
#endif
d1329 1
a1329 1
    if ( fh->objecttype != ObjectType_Directory &&
d1340 1
a1340 3
#ifdef debugmem
dprintf( "W" );
#endif
d1360 1
a1360 1
        if ( fh->objecttype == ObjectType_Directory )
d1362 1
a1362 3
#ifdef debugmem
dprintf( "D" );
#endif
d1380 1
a1380 3
#ifdef debugmem
dprintf( "S" );
#endif
d1384 1
a1384 1
                fileplace.action = 0; /* save file */
d1404 1
a1404 3
#ifdef debugmem
dprintf( "c" );
#endif
d1427 1
a1427 1
                fileplace.action = 4;   /* set file attributes */
d1429 1
a1429 1
                fileplace.end = 3;      /* owner read/write */
d1453 1
a1453 1
                        no error - try openning/saveing again, but don't retry cdirs on fail
d1466 1
a1466 3
#ifdef debugmem
dprintf( "O" );
#endif
d1471 1
a1471 1
        r.r[0] = 0xcf; /* open up and give an error if directory or not exists */
d1485 1
a1485 3
#ifdef debugmem
dprintf( "T" );
#endif
d1491 1
a1491 1
        r.r[0] = 3; /* set extent */
d1508 1
a1508 1
        gbpbplace.action = 1;    /* write bytes at location */
d1514 3
a1516 3
#ifdef debugmem
dprintf( "w(%d,%d->%d)", (int)gbpbplace.data_addr, gbpbplace.number, gbpbplace.seq_point );
#endif
d1539 1
a1539 3
#ifdef debugmem
dprintf( "change time_quanta to %d\n", time_quanta );
#endif
d1556 1
a1556 3
#ifdef debugmem
dprintf( "C" );
#endif
d1568 1
a1568 3
#ifdef debugmem
dprintf( "I" );
#endif
d1570 1
a1570 1
            Always adjust the info as its almost always wrong
d1578 1
a1578 1
        if ( err && fh->objecttype == ObjectType_Directory)
d1593 1
a1593 3
#ifdef debugmem
dprintf( "A" );
#endif
d1629 1
a1629 1
      DEBUG(("partial write: %d bytes / %d = %08x progress\n", (int)b, fh->size, p));
d1633 1
a1633 3
#ifdef debugmem
dprintf( "X\n" );
#endif
d1690 1
a1690 3
#ifdef debugmem
dprintf( "restart_file_read: fh=&08X\n", (int)fh );
#endif
d1707 1
a1707 3
#ifdef debugmem
dprintf( "restart_file_write: fh=&08X\n", (int)fh );
#endif
d1723 1
a1723 3
#ifdef debugmem
dprintf( "restarting write: start_of_buffer=%08X, buffer_bottom=%08X\n", fh->start_of_buffer, buffer_bottom );
#endif
@


4.6
log
@Fix display of bytes-to-go when there are > 2G left.
Was doing a widening cast of a signed number to 64 bits, so showed 16 trillion bytes remaining.
Fix templates to not say "stuff" by default in the name, as this was left on screen if an error occured before processing began.
Things that read from clock() now use clock_t.
Uncurled some "} else {" to match all the other files.
Deleted the USE_LONG_LONG switch, it's been needed ever since harddiscs got bigger than 4G anyway.
Anything assigned 'Yes' or 'No' changed to type BOOL.
Variable 'source_of_finished_file' was signalling that a directory had been copied by setting the length to a -ve number. This has been refactored to use a BOOL instead, so files can have top bit set sizes.
Fix bug in stack grab in count_objects_in_dir(), was grabbing an array of 2048 pointers (=8k) not 2048 bytes.
Functions bytes_left_to_read() and bytes_left_to_write() reprototyped to return uint32_t not signed numbers.
Still falls over copying files > 2G, but at least it gets the display right!

Version 0.51. Tagged as 'FilerAct-0_51'
@
text
@d994 8
a1001 5
os_error *add_file_to_chain( char *destination, char *source, int size, int reload, int execute, int attributes, int objecttype, int forceit, int *i_am_full
#ifdef USE_PROGRESS_BAR
, unsigned int progress, void **ref
#endif
) {
d1080 1
a1080 1
os_error *read_a_block( int *i_am_full, int *need_another_file, int *that_finished_a_file, unsigned int *progress )
d1299 2
a1300 2
        long long unsigned int p;
        int b;
d1303 1
a1303 1
        p = (fh->total_progress * (long long) b) / (long long) fh->size;
d1326 1
a1326 1
static os_error *int_write_a_block( int *i_am_empty, int *that_finished_a_file, unsigned int *progress )
d1335 1
a1335 1
    static int dont_set_dir_info;
d1632 1
a1632 1
            dont_set_dir_info = 1;
d1670 2
a1671 2
      long long unsigned int p;
      int b;
d1674 1
a1674 1
      p = (fh->total_progress * (long long) b) / (long long) fh->size;
d1691 1
a1691 1
os_error *write_a_block( int *i_am_empty, int *that_finished_a_file, unsigned int *progress )
d1816 1
a1816 1
void copy_go_faster( int do_it )
@


4.5
log
@Didn't compile with PROGRESS_BAR turned off.
Rationalised all the switches a bit.
Not tagged.
@
text
@d72 1
d89 1
a89 1
static int copytime;
a91 1
#define Yes 1
d93 1
d123 1
a123 1
}       write_activity;
d146 1
a146 1
} files_header;
d164 3
a166 2
int size_of_finished_file;
char *source_of_finished_file;
d185 3
d309 1
a309 1
    int answer = No;
d586 1
a586 1
     Assumuing no buffer in buffer chain, and no open files, remove
d605 1
a605 1
        size_of_finished_file = -1;
d609 1
a609 1
        size_of_finished_file = fh->size;
d615 2
a616 2
    if ( source_of_finished_file )
        overflowing_free( source_of_finished_file );
d618 1
a618 1
    source_of_finished_file = fh->source_filename;
d927 1
a927 1
    source_of_finished_file = NULL;
d1063 2
a1064 1
void modify_chain_file_progress(void *ref, unsigned int progress) {
d1067 2
a1068 1
  if (fh != NULL) {
d1083 2
a1084 2
    int size_needed;
    int t, start_read_to;
d1293 3
a1295 1
    } else {
d1299 1
a1299 1
        b = fh->read_to - start_read_to;	// bytes read this time
d1330 2
a1331 2
    int amount_to_write;
    int t, start_written_to;
d1664 3
a1666 1
    } else {
d1783 1
a1783 1
int bytes_left_to_read( void )
d1797 1
a1797 1
int bytes_left_to_write( void )
@


4.4
log
@Redesigned window to show more of path.
Added progress bar.
Performance improvements, especially in 'slower' mode.
Fixed 'count summary' bug.
Fixed various compiler warnings.

Version 0.49. Tagged as 'FilerAct-0_49'
@
text
@d31 1
a31 1
    - be prepared to loose information if slot size has to be shrunk
d142 1
a142 1
#ifdef PROGRESS_BAR
d990 1
a990 1
#ifdef PROGRESS_BAR
d1025 1
a1025 1
                #ifdef PROGRESS_BAR
d1057 1
a1057 1
#ifdef PROGRESS_BAR
d1272 1
a1272 1
        #ifdef PROGRESS_BAR
d1274 2
d1285 1
a1285 1
    #ifdef PROGRESS_BAR
d1646 1
a1646 1
        #ifdef PROGRESS_BAR
d1648 2
d1654 1
a1654 1
#ifdef PROGRESS_BAR
d1666 1
a1666 1
#endif
@


4.3
log
@Improvements to performance through word alignment and biting bigger
chunks.
MkClean also cleans dependancies.

Version 0.47. Tagged as 'FilerAct-0_47'
@
text
@d80 1
d111 11
a121 11
        write_not_started,
        write_f_tried_unlock,   /* open/save failed - have tried to unlock it */
        write_f_tried_cdirs,    /* open/save failed - have tried to cdir it */
        write_f_tried_both,     /* open/save failed - have tried both cdirs and unlock */
        write_openit,           /* have created it, now open it */
        write_truncateopen,     /* have opened it now truncate it */
        write_blocks,           /* next thing is writing blocks out */
        write_closeit,          /* next thing is to close it */
        write_adjust_access,    /* next thing is adjust the access */
        write_adjust_info,      /* next thing is adjust the info */
        write_all_done          /* and junk the fh */
d126 20
a145 16
        chain_link      link;
        char            *source_filename;
        int             source_file_handle;
        char            *destination_filename;
        int             destination_file_handle;
        int             size;
        int             reload;
        int             execute;
        int             attributes;
        int             objecttype;
        int             forceit;
        int             read_to;
        int             written_to;
        write_activity  write_state;
        int             start_of_buffer;        /* offset into memory */
}       files_header;
d154 1
a154 1
                                        /* used when the area contents are shuffled */
d186 7
a192 7
        int rw;
        for (rw = 0; rw < 2; rw++) /* reading and writing */
        {
                timing[rw].rate = 0;
                timing[rw].accumulator = 0;
                timing[rw].naccumulated = 0;
        }
d197 1
a197 1
        if (accumulated_time < 1) accumulated_time = 1; /* ensure no div by zero */
d201 1
a201 1
        return (blocksize<<8) / accumulated_time; /* shift is to gain integer value range */
d207 9
a215 9
        assert((rw==timing_Reading)||(rw==timing_Writing));
        assert(timing[rw].naccumulated < timing_NAccumulated);
        timing[rw].naccumulated++;
        timing[rw].accumulator += t;
        if ( timing[rw].naccumulated >= timing_NAccumulated )
        { /* accumulator is full and rate is not yet calculated; calculate rate */
                assert(timing[rw].rate == 0);
                timing[rw].rate = t__accumulatortorate(timing[rw].accumulator, blocksize);
        }
d220 2
a221 2
        assert((rw==timing_Reading)||(rw==timing_Writing));
        return (timing[rw].naccumulated < timing_NAccumulated);
d227 2
a228 2
        assert((rw==timing_Reading)||(rw==timing_Writing));
        return ( t__accumulatortorate(t * timing_NAccumulated, blocksize) <  (2*timing[rw].rate)/3 );
d234 3
a236 3
        int currentslot = -1;
        int nextslot = -1;
        int freepool;
d238 1
a238 1
        wimp_slotsize( &currentslot, &nextslot, &freepool );
d240 1
a240 1
        return currentslot;
d245 3
a247 3
        int currentslot = -1;
        int nextslot = -1;
        int freepool;
d249 1
a249 1
        wimp_slotsize( &currentslot, &nextslot, &freepool );
d251 1
a251 1
        return nextslot;
d255 1
a255 1
        returns amount actually changed by
d259 8
a266 4
        int oldslot;
        int currentslot;
        int nextslot = -1;
        int freepool;
d268 1
a268 3
        if ( amount != 0 )
        {
                oldslot = application_current_size();
d270 1
a270 3
                currentslot = oldslot + amount;

                wimp_slotsize( &currentslot, &nextslot, &freepool );
d276 6
a281 6
                return currentslot - oldslot;
        }
        else
        {
                return 0;
        }
d285 1
a285 1
        Ensure that the top to end amount free is at least size
d289 4
a292 4
        if ( buffer_end - buffer_top < size )
        {
                buffer_end += extend_application_slot( size - (buffer_end - buffer_top) );
        }
d294 1
a294 1
        return buffer_end - buffer_top >= size;
d298 3
a300 3
        Grow the buffer so that "size" is available, limiting by application_max_siz.
        Reduces *size to fit space.
        Returns Yes if not enough space available for original requested *size.
d304 1
a304 15
        int answer = No;

        /*
                Upper bound by application_max_size
        */
        if ( (int)(buffer_base_address + *size + buffer_top + buffer_offset) > application_max_size + 0x8000 )
        {
                *size = application_max_size + 0x8000 - (int)(buffer_base_address + buffer_top + buffer_offset);
                answer = Yes;
        }

        /*
                Try to ensure that much space
        */
        answer = answer || !buffer_ensure( *size );
d306 19
a324 5
        if ( buffer_end - buffer_top < *size )
        {
                *size = buffer_end - buffer_top;
                answer = Yes;
        }
d326 1
a326 1
        return answer;
d331 2
a332 2
        os_regset r;
        os_error *err;
d334 2
a335 2
        r.r[0] = 0; /* close file */
        r.r[1] = *handle;
d337 1
a337 1
        err = os_find( &r );
d339 4
a342 4
        /*
             Even a failed close leaves the file closed afterwards
        */
        *handle = 0;
d344 1
a344 1
        return err;
d353 2
a354 2
        os_filestr fileplace;
        os_error *err;
d356 15
a370 6
        fileplace.action   = 7; /* create a file */
        fileplace.name     = filename;
        fileplace.loadaddr = (int) 0xdeaddead;
        fileplace.execaddr = (int) 0xdeaddead;
        fileplace.start    = 0;
        fileplace.end      = size;
d372 1
a372 10
        err = os_file( &fileplace );

        if ( err )
             return err;

        fileplace.action = 4; /* set access to a file */
        fileplace.name = filename;
        fileplace.end = 0x3; /* read/write only */

        return os_file( &fileplace );
d377 1
a377 1
        os_filestr fileplace;
d379 3
a381 3
        fileplace.action = 8; /* create a directory */
        fileplace.name = dirname;
        fileplace.start = 0;
d383 1
a383 1
        return os_file( &fileplace );
d388 1
a388 1
        os_filestr fileplace;
d390 5
a394 5
        fileplace.action    = 1; /* write catalogue information */
        fileplace.name      = filename;
        fileplace.loadaddr  = reload;
        fileplace.execaddr  = execute;
        fileplace.end       = attributes;
d396 1
a396 1
        return os_file( &fileplace );
d401 1
a401 1
        os_filestr fileplace;
d403 3
a405 3
        fileplace.action    = 4; /* write attributes */
        fileplace.name      = filename;
        fileplace.end       = attributes;
d407 1
a407 1
        return os_file( &fileplace );
d412 2
a413 2
        char *trypos;
        char *endpos;
d415 5
d421 1
a421 1
                Point trypos past the -<fsname>- / <fsname>: bit
d423 10
a432 1
        if ( filename[0] == '-' )
d434 4
a437 23
                /*
                        -<fsname>-
                */
                trypos = strchr( filename + 1, '-' ) + 1;
        }
        else if ( filename[0] != ':' )
        {
                /*
                        <fsname>: perhaps
                */
                trypos = strchr( filename, ':' );

                if ( trypos == NULL )
                {
                        /*
                             It wasn't <fsname>:, never mind
                        */
                        trypos = filename;
                }
                else
                {
                        trypos++;
                }
d441 1
a441 1
                trypos = filename;
d443 12
d456 1
a456 4
        /*
                Move trypos past the :<devname> or :<devname>. bit if it's there
        */
        if ( *trypos == ':' )
d458 1
a458 10
                endpos = strchr( trypos, '.' );

                if ( endpos == NULL )
                {
                        trypos = trypos + strlen( trypos );
                }
                else
                {
                        trypos = endpos + 1;
                }
d460 1
a460 5

        /*
             Move past the first component (and any $. &. %. @@. or \.)
        */
        if ( *trypos != '\0' )
d462 1
a462 31
                switch( *trypos )
                {
                case '$':
                case '&':
                case '%':
                case '@@':
                case '\\':

                        trypos ++;

                        if ( *trypos == '.' )
                                trypos++;

                         /*
                                Fall through to skipping over the next component
                         */

                default:
                        endpos = strchr( trypos, '.' );

                        if ( endpos == NULL )
                        {
                                trypos = trypos + strlen( trypos );
                        }
                        else
                        {
                                trypos = endpos;
                        }

                        break;
                }
d464 1
d466 42
a507 4
        /*
             trypos now points past the first non-special component
             of the filename or at the terminating nul
        */
d509 1
a509 1
        return trypos;
d514 2
a515 2
        char *currpos;
        os_error *err;
d517 5
a521 5
        for ( currpos = first_dirbreak( filename );
              currpos && *currpos;
              currpos = strchr( currpos + 1, '.' ) )
        {
                *currpos = '\0';
d523 1
a523 1
                err = create_directory( filename );
d525 1
a525 1
                *currpos = '.';
d527 3
a529 3
                if ( err )
                        return err;
        }
d531 1
a531 1
        return NULL;
d541 2
a542 2
        if ( fh->destination_file_handle )
                close_file( &fh->destination_file_handle );
d544 2
a545 2
        if ( fh->source_file_handle )
                close_file( &fh->source_file_handle );
d553 1
a553 1
        chain_remove_link( &fh->link );
d555 1
a555 1
        ensure_files_closed( fh );
d557 5
a561 5
        if ( fh->start_of_buffer + fh->read_to - fh->written_to >= buffer_top )
        {
                /*
                        removing buffer at end
                */
d563 10
a572 10
                if ( fh->start_of_buffer < buffer_top )
                        buffer_top = fh->start_of_buffer;
        }
        else
        {
                /*
                        removing buffer at start
                */
                buffer_bottom += fh->read_to - fh->written_to;
        }
d574 4
a577 4
        if ( fh->source_filename )
                overflowing_free( fh->source_filename );
        overflowing_free( fh->destination_filename );
        overflowing_free( fh );
d586 2
a587 2
        chain_link *link = files_chain.forwards;
        files_header *fh;
d589 2
a590 2
        if ( !link->forwards )
                return;
d592 1
a592 1
        fh = chain_link_Wrapper( link );
d594 18
a611 18
        /*
                Special indication that it has been a directory that's just
                been finished
        */
        if ( fh->objecttype == ObjectType_Directory )
        {
                size_of_finished_file = -1;
        }
        else
        {
                size_of_finished_file = fh->size;
        }

        /*
                Record the source filename of the finished file
        */
        if ( source_of_finished_file )
                overflowing_free( source_of_finished_file );
d613 2
a614 2
        source_of_finished_file = fh->source_filename;
        fh->source_filename = NULL;
d616 1
a616 1
        remove_fh( fh );
d624 2
a625 2
        chain_link *link;
        files_header *fh;
d627 7
a633 1
        for ( link = files_chain.forwards; link->forwards; link = link->forwards )
d635 1
a635 8
                fh = chain_link_Wrapper( link );

                if ( fh->objecttype != ObjectType_Directory &&
                     ( fh->read_to < fh->size ||
                       fh->source_file_handle ) )
                {
                        return fh;
                }
d637 1
d639 1
a639 1
        return NULL;
d647 2
a648 2
        if ( fh == NULL )
                return;
d650 1
a650 1
        remove_fh( fh );
d659 12
a670 12
        if ( block < 4096 )
        {
                block = (block + 1024) & ~1023;
        }
        else if ( block < 16384 )
        {
                block = (block + 4096) & ~4095;
        }
        else
        {
                block = (block + (block>>1)) & ~4095;
        }
d676 1
a676 1
        return block;
d681 12
a692 12
        if ( block < 4096 )
        {
                block = (block - 256) & ~255;
        }
        else if ( block < 16384 )
        {
                block = (block - 1024) & ~1023;
        }
        else
        {
                block = (block - (block>>2)) & ~1023;
        }
d694 2
a695 2
        if ( block < minimum_block_size )
                block = minimum_block_size;
d701 1
a701 1
        return block;
d705 2
a706 2
        Go through all readable files and discard their buffers if they overhang
        the top of the buffer
d710 2
a711 2
        chain_link *link;
        files_header *fh;
d713 5
a717 1
        for ( link = files_chain.forwards; link->forwards; link = link->forwards )
d719 15
a733 20
                fh = chain_link_Wrapper( link );

                if ( fh->objecttype != ObjectType_Directory )
                {
                        if ( fh->start_of_buffer >= buffer_top )
                        {
                                /*
                                        file buffer starts beyond end of buffer
                                */
                                fh->start_of_buffer = 0;
                                fh->read_to = fh->written_to;
                        }
                        else if ( fh->start_of_buffer + fh->read_to - fh->written_to > buffer_top )
                        {
                                /*
                                        file buffer hangs over end of buffer
                                */
                                fh->read_to = buffer_top - (fh->start_of_buffer - fh->written_to);
                        }
                }
d735 1
d740 2
a741 2
        int size_grown;
        int movement;
d743 8
a750 8
        size_grown = MinimumWorkingSize - (buffer_end + buffer_offset - n);
        if ( size_grown > 0 )
        {
                /*
                        Not enough room in current slot, so try to extend
                        If fail to extend then can't satisfy request
                */
                buffer_end += extend_application_slot( size_grown );
d752 2
a753 2
                if ( buffer_end + buffer_offset - n < MinimumWorkingSize )
                        return 0;
d755 3
a757 3
                if ( application_max_size < (int)(buffer_base_address + buffer_offset + buffer_end) - 0x8000 )
                        application_max_size = (int)(buffer_base_address + buffer_offset + buffer_end) - 0x8000;
        }
d759 27
a785 27
        if ( buffer_bottom + buffer_offset >= n )
        {
                /*
                        Already enough room below used section - no action necessary
                */
        }
        else if ( buffer_bottom + buffer_offset + buffer_end - buffer_top >= n )
        {
                /*
                        Enough room in unused space, but not enough room below
                        used section so move used section of buffer up
                        to make room.
                */
                memmove( buffer_base_address + n,
                        buffer_base_address + buffer_bottom + buffer_offset,
                        buffer_top - buffer_bottom );

                movement = n - (buffer_offset + buffer_bottom);
                buffer_end -= movement;
                buffer_offset += movement;
        }
        else
        {
                /*
                        Not enough room in the available slot - try to extend
                */
                size_grown = n - (buffer_bottom + buffer_offset + buffer_end - buffer_top);
d787 1
a787 1
                (void)grow_buffer( &size_grown );
d789 3
a791 3
                memmove( buffer_base_address + n,
                        buffer_base_address + buffer_bottom + buffer_offset,
                        buffer_end + buffer_offset - n );
d793 3
a795 3
                movement = n - (buffer_offset + buffer_bottom);
                buffer_end -= movement;
                buffer_offset += movement;
d797 4
a800 5
                if ( buffer_top > buffer_end )
                {
                        buffer_top = buffer_end;
                        truncate_overhanging_files();
                }
d802 1
d804 3
a806 3
        *p = buffer_base_address;
        buffer_base_address += n;
        buffer_offset -= n;
d808 1
a808 1
        return n;
d820 1
a820 1
          obtained is less than that requested.
d824 1
a824 1
        int size_change = size - application_current_size();
d830 12
a841 12
        if ( size_change > 0 )
        {
                /*
                        Grow slot
                */
                buffer_end += extend_application_slot( size_change );
        }
        else if ( size_change < 0 )
        {
                /*
                        Shrink slot
                */
d843 5
a847 5
                /*
                        Lower-bound size change to ensure we still have MinimumWorkingSize
                */
                if ( buffer_end + buffer_offset + size_change < MinimumWorkingSize )
                        size_change = MinimumWorkingSize - buffer_end - buffer_offset;
d849 5
a853 5
                if ( buffer_top > buffer_end + size_change )
                {
                        /*
                                Ensure the data is at the bottom of the buffer area
                        */
d857 4
a860 4
                        memmove(
                                buffer_base_address,
                                buffer_base_address + buffer_bottom + buffer_offset,
                                buffer_top - buffer_bottom );
d862 3
a864 3
                        buffer_end += buffer_bottom + buffer_offset;
                        buffer_offset -= buffer_bottom + buffer_offset;
                }
d866 1
a866 1
                size_change = extend_application_slot( size_change );
d868 4
a871 4
                /*
                        Adjust buffer_end by actual amount changed by
                */
                buffer_end += size_change;
d873 6
a878 6
                /*
                        Upper bound buffer_top by buffer_end
                */
                if ( buffer_top > buffer_end )
                        buffer_top = buffer_end;
        }
d880 1
a880 1
        truncate_overhanging_files();
d882 1
a882 1
        application_max_size = (int)(buffer_base_address + buffer_offset + buffer_end) - 0x8000;
d894 27
a920 4
        /*
                Things that use real memory ( base = null )
        */
        chain_initialise_header( &files_chain );
d922 1
a922 7
        /*
                This determins the maximum size we will allow buffer
                allocation to grow to. This starts at the
                current next slot size, then gets adjusted when the
                user drags the memory slider
        */
        application_max_size = current_next_slot();
d924 1
a924 14
        /*
                The buffer area
        */
        buffer_base_address = (char *)(application_current_size() + 0x8000);
        buffer_offset = 0;
        buffer_bottom = 0;
        buffer_top = 0;
        buffer_end = 0;

        /*
                A cludge to stop memory size dragging from oscillating
                about a non-memory block size boundary.
        */
        last_requested_size = -1;
d926 1
a926 5
        source_of_finished_file = NULL;

        (void)_kernel_register_slotextend( memmanage_slotextend );

        return NULL;
d941 1
a941 1
        copytime = clock();
d943 8
a950 3
        src_block_size = InitialBlockSize;
        dest_block_size = InitialBlockSize;
        timing_init();
d952 6
a957 11
        if ( buffer_ensure( MinimumWorkingSize ) )
        {
                if ( application_max_size < application_current_size() )
                        application_max_size = application_current_size();

                return NULL;
        }
        else
        {
                return error( mb_slotsize_too_small ); /* was mb_malloc_failed */
        }
d962 1
a962 1
          Close down any open files
d966 2
a967 2
        chain_link *link;
        files_header *fh;
d969 3
a971 3
        for ( link = files_chain.forwards; link->forwards; link = link->forwards )
        {
                fh = chain_link_Wrapper( link );
d973 2
a974 2
                ensure_files_closed( fh );
        }
d976 2
a977 2
        copytime = clock() - copytime;
        werr(0, "time taken for file copy = %d.%02ds", copytime/100, copytime%100);
d981 1
a981 1
        if ( debugf != NULL ) fclose( debugf );
d989 11
a999 3
os_error *add_file_to_chain( char *destination, char *source, int size, int reload, int execute, int attributes, int objecttype, int forceit, int *i_am_full )
{
        files_header *fh;
d1001 1
a1001 2
        fh = overflowing_malloc( sizeof( files_header ));
        if ( fh )
d1003 1
a1003 1
                fh->source_filename = overflowing_malloc( strlen( source ) + 1 );
d1005 19
a1023 3
                if ( fh->source_filename )
                {
                        fh->destination_filename = overflowing_malloc( strlen( destination ) + 1 );
d1025 6
a1030 24
                        if ( fh->destination_filename )
                        {
                                /*
                                     Initialise the structure
                                */
                                strcpy( fh->source_filename, source );
                                fh->source_file_handle = 0;
                                strcpy( fh->destination_filename, destination );
                                fh->destination_file_handle = 0;
                                fh->size = size;
                                fh->reload = reload;
                                fh->execute = execute;
                                fh->attributes = attributes;
                                fh->objecttype = objecttype;
                                fh->forceit = forceit;
                                fh->read_to = 0;
                                fh->written_to = 0;
                                fh->write_state = write_not_started;
                                fh->start_of_buffer = 0;

                                /*
                                     link to backwards end of files chain
                                */
                                chain_insert_before_header( &fh->link, fh, &files_chain );
d1032 4
a1035 1
                                *i_am_full = No;
d1037 1
a1037 2
                                return NULL;
                        }
d1039 2
a1040 2
                        overflowing_free( fh->source_filename );
                }
d1042 1
a1042 1
                overflowing_free( fh );
d1045 15
a1059 1
        *i_am_full = Yes;
d1061 4
a1064 4
        /*
             one of the heap_allocs failed
        */
        return error( mb_malloc_failed );
d1066 2
d1069 2
a1070 1
os_error *read_a_block( int *i_am_full, int *need_another_file, int *that_finished_a_file )
d1072 6
a1077 6
        files_header *fh;
        os_regset r;
        os_error *err;
        os_gbpbstr gbpbplace;
        int size_needed;
        int t;
d1079 2
a1080 2
        *i_am_full = No;
        *that_finished_a_file = No;
d1082 1
a1082 1
        fh = next_fh_to_read();
d1084 3
a1086 3
        if ( !fh )
        {
                *need_another_file = Yes;
d1088 2
a1089 2
                return NULL;
        }
d1091 1
a1091 1
        *need_another_file = No;
d1097 7
a1103 5
        /*
             If we have to do some reading
        */
        if ( fh->read_to < fh->size )
        {
d1107 3
a1109 3
                /*
                        Work out how much buffer is needed...
                */
d1111 11
a1121 11
                /*
                        Upper bound to src_block_size and amount to read in file
                */
                if ( fh->size - fh->read_to > src_block_size )
                {
                        size_needed = src_block_size;
                }
                else
                {
                        size_needed = fh->size - fh->read_to;
                }
d1123 18
a1140 18
                /*
                         Ensure word-alignment of file ptr and buffer address
                         equal, to ensure DMA operation on DMA-capable disc
                         systems (eg Iyonix ADFS).
                */
                if ( fh->read_to == fh->written_to &&
                     (buffer_top & 3) != (fh->read_to & 3) )
                {
                        int pad = ((fh->read_to & 3) - (buffer_top & 3)) & 3;
                        *i_am_full = grow_buffer( &pad );
                        if ( pad <= 0)
                                return NULL;
                        buffer_top += pad;
                }
                /*
                     Enlarge the buffer (if possible)
                */
                *i_am_full = grow_buffer( &size_needed );
d1142 2
a1143 2
                if ( size_needed <= 0 )
                        return NULL;
d1145 7
a1151 7
                /*
                        Set up new buffer
                */
                if ( fh->read_to == fh->written_to )
                {
                        fh->start_of_buffer = buffer_top;
                }
d1155 19
a1173 19
                /*
                        If haven't already started on the open-gbpb-close sequence AND
                                file size fits into buffer allowed
                */
                if ( fh->read_to == 0 && fh->size <= size_needed )
                {
                        /*
                                If were reading by blocks, but now decided its OK to read by whole file
                        */
                        if ( fh->source_file_handle )
                                close_file( &fh->source_file_handle );

                        /*
                                optimal read case: enough ram to read whole file
                        */
                        fileplace.action = 16; /* load file */
                        fileplace.name = fh->source_filename;
                        fileplace.loadaddr = (int)(buffer_base_address + buffer_offset + fh->start_of_buffer);
                        fileplace.execaddr = 0;
d1175 1
a1175 1
                        err = os_file( &fileplace );
d1177 2
a1178 2
                        if ( err )
                                return err;
d1180 4
a1183 4
                        fh->read_to = fh->size;
                        buffer_top += fh->size;
                }
                else
d1185 3
a1187 3
                {
                        /*
                             Sub-optimal case: read file in chunks
d1189 4
a1192 4
                             If the file isn't open yet, then open it
                        */
                        if ( fh->source_file_handle == 0 )
                        {
d1196 4
a1199 2
                                r.r[0] = 0x4f;
                                r.r[1] = (int)fh->source_filename;
d1201 5
a1205 1
                                err = os_find( &r );
d1207 1
a1207 2
                                if ( err )
                                        return err;
d1209 8
a1216 13
                                fh->source_file_handle = r.r[0];
                        }

                        t = clock();

                        /*
                                Read a block into the buffer.
                        */
                        gbpbplace.action = 3; /* read bytes from file at position */
                        gbpbplace.file_handle = fh->source_file_handle;
                        gbpbplace.data_addr = buffer_base_address + buffer_offset + buffer_top;
                        gbpbplace.number = size_needed;
                        gbpbplace.seq_point = fh->read_to;
d1222 22
a1243 22
                        err = os_gbpb( &gbpbplace );
                        if ( err )
                                return err;

                        fh->read_to += size_needed;
                        buffer_top += size_needed;

                        if (src_block_size == size_needed)
                        {  /* only time full block transfers */
                                t = clock() - t;
                                if ( timing_accumulating(timing_Reading) )
                                { /* accumulating initial timings */
                                        assert(src_block_size == InitialBlockSize);
                                        timing_accumulate(timing_Reading, t, src_block_size);
                                }
                                else if (time_quanta < MaxTimeQuanta)
                                {
                                        if ( (src_block_size <= SmallBlockSize)
                                          && timing_poorrate(timing_Reading, t, src_block_size) )
                                        { /* if the transfer rate is suffering at this small blocksize,
                                           * increase time_quanta to cause the blocksize to grow */
                                                if (time_quanta < MaxTimeQuanta) time_quanta *= 2;
d1247 5
a1251 5
                                        }
                                        if ( t < time_quanta - TimeQuantaHysteresis) src_block_size = grow( src_block_size );
                                        if ( t > time_quanta + TimeQuantaHysteresis) src_block_size = shrink( src_block_size );
                                }
                        }
d1253 2
a1254 2
                        if ( fh->read_to >= fh->size )
                        {
d1258 4
a1261 5
                                err = close_file( &fh->source_file_handle );
                                if ( err )
                                        return err;
                        }
                }
d1263 12
d1277 2
a1278 1
             If we've finished reading the file
d1280 17
a1296 3
        if ( fh->read_to >= fh->size )
        {
                *that_finished_a_file = Yes;
a1297 7
                /*
                        If there isn't another file to read, tell the client about
                        it now.
                */
                if ( next_fh_to_read() == NULL )
                        *need_another_file = Yes;
        }
d1303 1
a1303 1
        return NULL;
d1308 1
a1308 1
        skip_file( next_fh_to_read() );
d1311 2
a1312 1
static os_error *int_write_a_block( int *i_am_empty, int *that_finished_a_file )
d1314 18
a1331 8
        os_gbpbstr gbpbplace;
        os_filestr fileplace;
        files_header *fh;
        os_regset r;
        os_error *err = NULL;
        int amount_to_write;
        int t;
        static int dont_set_dir_info;
d1333 2
a1334 9
        *i_am_empty = No;
        *that_finished_a_file = No;

        /*
                no more files to write?
        */
        if ( !files_chain.forwards->forwards )
        {
                *i_am_empty = Yes;
d1336 1
a1336 4
                return NULL;
        }

        fh = chain_link_Wrapper( files_chain.forwards );
d1342 11
a1352 8
        /*
                no more buffer to write when there's more file to write?
        */
        if ( fh->objecttype != ObjectType_Directory &&
                fh->read_to - fh->written_to == 0 &&
                fh->written_to < fh->size )
        {
                *i_am_empty = Yes;
d1354 1
a1354 2
                return NULL;
        }
d1360 19
a1378 4
        /*
                amount_to_write is lesser of a dest_block_size and the amount buffered of the file
        */
        if ( fh->read_to - fh->written_to > dest_block_size )
d1380 12
a1391 1
                amount_to_write = dest_block_size;
d1395 5
a1399 11
                amount_to_write = fh->read_to - fh->written_to;
        }

        while ( !err &&
               ( fh->write_state == write_not_started ||
                 fh->write_state == write_f_tried_unlock ||
                 fh->write_state == write_f_tried_cdirs ||
                 fh->write_state == write_f_tried_both ))
        {
                if ( fh->objecttype == ObjectType_Directory )
                {
d1401 1
a1401 1
dprintf( "D" );
d1403 13
a1415 11
                        /*
                                Start up directory
                        */
                        err = create_directory( fh->destination_filename );

                        if ( !err )
                                fh->write_state = dont_set_dir_info ?
                                                    write_adjust_access :
                                                    write_adjust_info;
                }
                else
d1417 9
a1425 31
                        /*
                                Start up file (or partition)
                        */
                        if ( fh->size <= amount_to_write )
                        {
#ifdef debugmem
dprintf( "S" );
#endif
                                /*
                                        Optimised case - try save
                                */
                                fileplace.action = 0; /* save file */
                                fileplace.name = fh->destination_filename;
                                fileplace.loadaddr = fh->reload;
                                fileplace.execaddr = fh->execute;
                                fileplace.start = (int)(buffer_base_address + buffer_offset + fh->start_of_buffer);
                                fileplace.end = fileplace.start + fh->size;

                                err = os_file( &fileplace );

                                if ( !err )
                                {
                                        fh->written_to = fh->size;
                                        fh->start_of_buffer += fh->size;
                                        buffer_bottom += fh->size;

                                        fh->write_state = write_adjust_access;
                                }
                        }
                        else
                        {
d1429 4
a1432 11
                                /*
                                        Sub-optimal case - open, GBPB, close
                                */
                                err = create_file_dead( fh->destination_filename, fh->size );

                                if ( !err )
                                {
                                        fh->write_state = write_openit;
                                }
                        }
                }
d1434 1
a1434 1
                if ( err )
d1436 1
a1436 42
                        if ( (err->errnum & FileError_Mask) == ErrorNumber_Locked &&
                                fh->forceit &&
                                fh->write_state != write_f_tried_unlock &&
                                fh->write_state != write_f_tried_both )
                        {
                                /*
                                        We haven't tried unlocking yet - give it a go
                                */
                                fileplace.action = 4;   /* set file attributes */
                                fileplace.name = fh->destination_filename;
                                fileplace.end = 3;      /* owner read/write */

                                os_file( &fileplace );  /* ignore any error back */

                                err = NULL;

                                if ( fh->write_state == write_not_started )
                                        fh->write_state = write_f_tried_unlock;
                                else if ( fh->write_state == write_f_tried_cdirs )
                                        fh->write_state = write_f_tried_both;
                        }
                        else if ( ((err->errnum & FileError_Mask) == ErrorNumber_NotFound ||
                                   err->errnum == ErrorNumber_CantOpenFile) &&
                                   fh->write_state != write_f_tried_cdirs &&
                                   fh->write_state != write_f_tried_both )
                        {
                                /*
                                        We haven't tried cdirs yet - give it a go
                                */
                                err = ensure_file_directories( fh->destination_filename );

                                if ( !err )
                                {
                                        /*
                                                no error - try openning/saveing again, but don't retry cdirs on fail
                                        */
                                        if ( fh->write_state == write_not_started )
                                                fh->write_state = write_f_tried_cdirs;
                                        else if ( fh->write_state == write_f_tried_unlock )
                                                fh->write_state = write_f_tried_both;
                                }
                        }
d1438 1
d1441 1
a1441 1
        if ( !err && fh->write_state == write_openit )
d1443 26
a1468 3
#ifdef debugmem
dprintf( "O" );
#endif
d1470 1
a1470 2
                        Open it up. The file has been successfully created if we're here, so
                        any failures at this point are bad news.
d1472 1
a1472 4
                r.r[0] = 0xcf; /* open up and give an error if directory or not exists */
                r.r[1] = (int)fh->destination_filename;

                err = os_find( &r );
d1476 7
a1482 2
                        fh->write_state = write_truncateopen;
                        fh->destination_file_handle = r.r[0];
d1484 1
d1486 13
d1500 3
a1502 1
        if ( !err && fh->write_state == write_truncateopen )
d1504 7
d1514 8
a1521 8
                /*
                        Once the file's open set its extent to 0. This
                        prevents FileSwitch loading before update on
                        blocks of the file.
                */
                r.r[0] = 3; /* set extent */
                r.r[1] = (int)fh->destination_file_handle;
                r.r[2] = 0; /* to 0 */
d1523 1
a1523 1
                err = os_args( &r );
d1525 3
a1527 4
                if ( !err )
                {
                        fh->write_state = write_blocks;
                }
d1529 1
d1531 10
a1540 10
        if ( !err && fh->write_state == write_blocks )
        {
                /*
                        Write a block out
                */
                gbpbplace.action = 1;    /* write bytes at location */
                gbpbplace.file_handle = fh->destination_file_handle;
                gbpbplace.data_addr = buffer_base_address + buffer_offset + fh->start_of_buffer;
                gbpbplace.number = amount_to_write;
                gbpbplace.seq_point = fh->written_to;
d1546 1
a1546 1
                t = clock();
d1548 1
a1548 1
                err = os_gbpb( &gbpbplace );
d1550 11
a1560 1
                if ( !err )
d1562 5
a1566 15
                        if (dest_block_size == amount_to_write)
                        {  /* only time full block transfers */
                                t = clock() - t;
                                if ( timing_accumulating(timing_Writing) )
                                { /* accumulating initial timings */
                                        assert(dest_block_size == InitialBlockSize);
                                        timing_accumulate(timing_Writing, t, dest_block_size);
                                }
                                else
                                {
                                        if ( (dest_block_size <= SmallBlockSize)
                                          && timing_poorrate(timing_Writing, t, dest_block_size) )
                                        { /* if the transfer rate is suffering at this small blocksize,
                                           * increase time_quanta to cause the blocksize to grow */
                                                if (time_quanta < MaxTimeQuanta) time_quanta *= 2;
d1570 8
a1577 8
                                        }
                                        if ( t < time_quanta - TimeQuantaHysteresis) dest_block_size = grow( dest_block_size );
                                        if ( t > time_quanta + TimeQuantaHysteresis) dest_block_size = shrink( dest_block_size );
                                }
                        }
                        fh->written_to += amount_to_write;
                        fh->start_of_buffer += amount_to_write;
                        buffer_bottom += amount_to_write;
d1579 2
a1580 3
                        if ( fh->written_to >= fh->size )
                                fh->write_state = write_closeit;
                }
d1582 1
d1584 2
a1585 2
        if ( !err && fh->write_state == write_closeit )
        {
d1589 1
a1589 1
                err = close_file( &fh->destination_file_handle );
d1591 6
a1596 6
                /*
                        Regardless of whether the close worked, the file will be closed,
                        so always move onto adjusting the file's info
                */
                fh->write_state = write_adjust_info;
        }
d1598 2
a1599 2
        if ( !err && fh->write_state == write_adjust_info )
        {
d1603 21
a1623 21
                /*
                        Always adjust the info as its almost always wrong
                */
                err = write_catalogue_information(
                          fh->destination_filename,
                          fh->reload,
                          fh->execute,
                          fh->attributes );

                if ( err && fh->objecttype == ObjectType_Directory)
                {
                        /* Some FS's can't do this for a directory - back
                           off to just doing the access permission.
                         */
                        err = NULL;
                        dont_set_dir_info = 1;
                        fh->write_state = write_adjust_access;
                }
                else if ( !err )
                        fh->write_state = write_all_done;
        }
d1625 2
a1626 2
        if ( !err && fh->write_state == write_adjust_access )
        {
d1630 24
a1653 6
                /*
                        Only adjust attributes if they're non-default ones
                */
                err = write_attributes(
                          fh->destination_filename,
                          fh->attributes );
d1655 2
a1656 3
                if ( !err )
                        fh->write_state = write_all_done;
        }
d1658 2
a1659 3
        if ( !err && fh->write_state == write_all_done )
        {
                *that_finished_a_file = Yes;
d1661 3
a1663 2
                remove_file_from_chain();
        }
d1669 1
a1669 1
        return err;
d1672 2
a1673 1
os_error *write_a_block( int *i_am_empty, int *that_finished_a_file )
d1675 1
a1675 1
        os_error *err = int_write_a_block( i_am_empty, that_finished_a_file );
d1677 5
a1681 5
        if ( *i_am_empty )
        {
                buffer_end += buffer_offset;
                buffer_offset = buffer_bottom = buffer_top = 0;
        }
d1683 1
a1683 1
        return err;
d1688 4
a1691 4
        if ( files_chain.forwards->forwards )
        {
                skip_file( chain_link_Wrapper( files_chain.forwards ));
        }
d1696 1
a1696 1
        files_header *fh;
d1698 3
a1700 3
        if ( files_chain.forwards->forwards )
        {
                fh = chain_link_Wrapper( files_chain.forwards );
d1702 6
a1707 6
                return fh->destination_filename;
        }
        else
        {
                return NULL;
        }
d1712 1
a1712 1
        files_header *fh = next_fh_to_read();
d1714 4
a1717 4
        if ( fh != NULL )
                return fh->source_filename;
        else
                return NULL;
d1722 1
a1722 1
        files_header *fh = next_fh_to_read();
d1728 9
a1736 9
        if ( fh != NULL )
        {
                ensure_files_closed( fh );
                buffer_top -= fh->read_to;
                if ( buffer_top < 0 ) buffer_bottom = buffer_top = buffer_offset = 0;
                fh->read_to = 0;
                fh->written_to = 0;
                fh->write_state = write_not_started;
        }
d1741 1
a1741 1
        files_header *fh = chain_link_Wrapper( files_chain.forwards );
d1747 14
a1760 14
        if ( fh != NULL )
        {
                /* Only restart file if we still have all of its contents so far.
                 * If we don't then we can't just read from the start because we might
                 * overwrite another file's data so just do nothing (== retry).
                 */
                int file_start = fh->start_of_buffer - fh->written_to;
                if ( file_start >= 0 )
                {
                        ensure_files_closed( fh );
                        fh->start_of_buffer = file_start;
                        buffer_bottom -= fh->written_to;
                        fh->written_to = 0;
                        fh->write_state = write_not_started;
a1763 1
                }
d1765 1
d1770 1
a1770 1
        files_header *fh = next_fh_to_read();
d1772 8
a1779 8
        if ( fh )
        {
                return fh->size - fh->read_to;
        }
        else
        {
                return 0;
        }
d1784 1
a1784 1
        files_header *fh;
d1786 3
a1788 3
        if ( files_chain.forwards->forwards )
        {
                fh = chain_link_Wrapper( files_chain.forwards );
d1790 6
a1795 6
                return fh->size - fh->written_to;
        }
        else
        {
                return 0;
        }
d1800 5
a1804 5
        if ( do_it )
        {
                /*
                        Go faster
                */
d1806 1
a1806 1
                time_quanta = MaxTimeQuanta;      /* centi-seconds */
d1808 1
a1808 1
                minimum_block_size = 15*1024; /* bytes: optimised for econet */
d1810 10
a1819 10
                if ( src_block_size < minimum_block_size )
                        src_block_size = minimum_block_size;
                if ( dest_block_size < minimum_block_size )
                        dest_block_size = minimum_block_size;
        }
        else
        {
                /*
                        Go slower
                */
d1821 1
a1821 1
                time_quanta = NominalTimeQuanta;
d1823 2
a1824 2
                minimum_block_size = 512;
        }
@


4.2
log
@Added functionality from RISC OS 4.02 (Faster button, 64-bit display, number
separators). This implementation does not use the Netscape libraries, and
looks up the number separation scheme from the current territory.

Now copies directory datestamps, as per the command-line *Copy.

Version 0.46. Tagged as 'FilerAct-0_46'
@
text
@d664 1
a664 1
                block += block>>1;
d686 1
a686 1
                block -= block>>2;
d1092 14
@


4.1
log
@Initial revision
@
text
@d353 2
a354 2
        fileplace.loadaddr = 0xdeaddead;
        fileplace.execaddr = 0xdeaddead;
d1256 1
d1322 3
a1324 1
                                fh->write_state = write_adjust_access;
d1531 1
a1531 1
        if ( !err && fh->write_state == write_adjust_access )
d1534 1
a1534 1
dprintf( "A" );
d1537 1
a1537 1
                        Only adjust attributes if they're non-default ones
d1539 1
a1539 1
                err = write_attributes(
d1541 2
d1545 10
a1554 1
                if ( !err )
d1558 1
a1558 1
        if ( !err && fh->write_state == write_adjust_info )
d1561 1
a1561 1
dprintf( "I" );
d1564 1
a1564 1
                        Always adjust the info as its almost always wrong
d1566 1
a1566 1
                err = write_catalogue_information(
a1567 2
                          fh->reload,
                          fh->execute,
@


4.1.7.1
log
@NCOS 1.06 Imported from Zip drive
@
text
@@


4.1.5.1
log
@Import from SrcFiler
@
text
@@


4.1.3.1
log
@Import from cleaned 370 CD
@
text
@@


4.1.1.1
log
@Import from cleaned 360 CD
@
text
@@
